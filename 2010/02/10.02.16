00:00:32 <c_wraith> why would http://hackage.haskell.org/trac/ghc/ be putting me in a redirect loop?
00:00:53 <c_wraith> (after logging in)
00:00:54 <copumpkin> someone failed, I'd assume
00:03:46 <opdolio> Must be a long manual.
00:04:55 <c_wraith> Is this something I'm doing wrong?  Can other people log into ghc trac?
00:07:27 <opdolio> I just logged in.
00:09:56 <jrockway> c_wraith: cookie problems?
00:10:05 <c_wraith> hmm.
00:10:14 <c_wraith> I don't do anything strange with cookies
00:10:25 <jrockway> hmm, then probably not the issue
00:10:39 <jrockway> (i tend to experience cookie problems from time to time, but i use privoxy, which rewrites the cookies)
00:11:38 <c_wraith> well, I'll re-check
00:15:33 <dmwit> ARGH
00:15:47 <c_wraith> Well.  doesn't seem to be cookie related.
00:15:49 <dmwit> Network.Browser does encodings...
00:15:51 <dmwit> =(
00:16:05 <c_wraith> I think my issue has something to do with just having reset my password for ghc trac
00:16:28 <c_wraith> like it's trying to redirect me to the settings page when I log in, and then the settings page tries to redirect me to itself
00:16:32 <c_wraith> or something along those lines
00:16:48 <jrockway> delete cookies, close browser, retry
00:17:00 <jrockway> trac is very buggy, in my experience
00:17:18 <dmwit> or... hm
00:17:19 <c_wraith> That's what I did when I said I was retrying
00:17:41 <jrockway> it just hates you then
00:17:43 <jrockway> :)
00:19:21 <RecycleCorn>  It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  They never will!  The same goes for New Orleans!  Cancun in Mexico suffered few fatalities after their major hurricane, and the rebuilding is already completed.  What have the niggers in
00:19:21 <c_wraith> And I wanted to report a legit bug in 6.12 :(
00:19:24 <RecycleCorn> New Orleans done? If you are sick of this, join Chimpout Forum!  http://www.chimpout.com/forum
00:19:27 <dmwit> Hm, maybe it's my fault after all. =D
00:19:56 <k23z__> RecycleCorn: hey go suck on a coconut you idiot
00:19:57 <jrockway> i thought the new ircd was supposed to kill spam
00:20:02 <jrockway> k23z__: it's a bot
00:20:12 <k23z__> I know ...
00:21:24 <theorbtwo> Sigh.  They should just instakill http://.*chimpout , but they'd just start using shorteners.
00:21:43 <kmc> no software invented by man can stop people from saying stupid shit on the internet
00:21:45 <jrockway> just follow the shortened URL
00:21:52 <dmwit> Sweet, he k-lined.
00:22:00 <jrockway> kmc: people, yes
00:22:01 <jrockway> bots, no
00:22:04 <jrockway> bots can be stopped
00:22:23 <theorbtwo> jrockway: ...but behind the bot is a person.
00:22:37 <jrockway> how lazy is that person?
00:22:47 <theorbtwo> That is a very good question.
00:22:49 <jrockway> when you start blocking domain names, you start costing them money
00:23:09 <dmwit> Not if they have a botnet.
00:23:20 <theorbtwo> Only if you do so unusually effectively.
00:23:48 <jrockway> it's unlikely that they have a botnet
00:23:57 <kmc> this is not some hacker mastermind
00:23:57 <Jafet> You start costing your neighbour money
00:23:58 <jrockway> people with botnets make money, they don't spread racist propaganda
00:24:04 <jrockway> exactly
00:24:07 <jrockway> it's just some kid with free time
00:24:09 <Jafet> Where do you think they get the money from
00:24:09 <kmc> it's probably one guy with an IRC client configured to paste some message when he enters a room
00:24:27 <jrockway> it's more sophisticated than that
00:24:48 <jrockway> that page used to have javascript that started talking enough IRC to join channels and spam
00:24:51 <k23z__> so what do you think about niggers in Haiti ?
00:24:53 <k23z__> lol
00:25:18 <jrockway> (the irc server just ignored the HTTP commands that were mixed with the irc commands, lol)
00:25:24 <theorbtwo> First, you kick people on a fairly simple regex.  Then they use a shortener.  Then you follow the shortener, so they use one that doesn't do http redirects.  Then you follow html meta redirects, they use js redirects.  *Then* maybe they start buying more domain names.
00:26:07 <theorbtwo> jrockway: Oh, that's a good idea!
00:26:47 <jrockway> everything is impossible in theory
00:27:14 <theorbtwo> Heh.  This is #haskell, you shouldn't throw around statments like that.
00:27:23 <theorbtwo> Somebody will probably disprove you.
00:27:33 <kmc> well almost all languages are undecidable
00:28:46 <jrockway> theorbtwo: when you start saying "that's impossible", you start sounding like randal schwartz
00:28:59 <theorbtwo> jrockway: Didn't say it was impossible.
00:29:01 <k23z__> jrockway: randal just says that because he's old
00:29:06 <jrockway> who was banned from #moose last week because people were trying to discuss parsing perl, and he kept interjecting how "that's impossible"
00:29:17 <k23z__> ahahhahaha
00:29:21 <k23z__> he was banned from #moose
00:29:30 <k23z__> jrockway: you surprise me
00:29:38 <theorbtwo> I just said that there's a lot of hoops to jump through before you start costing them money.
00:30:02 <theorbtwo> You start by costing you both time, and hoping that you have more skill*time to spend on it.
00:30:19 <k23z__> jrockway: so he really got banned ?
00:30:23 <jrockway> yes
00:30:26 <dmwit> Isn't he technically right?
00:30:32 <k23z__> jrockway: but he's randal schwartz, it's impossible !
00:30:33 <dmwit> I mean, isn't parsing perl undecidable?
00:30:41 <k23z__> jrockway: they banned the uncle of Perl
00:31:51 <theorbtwo> k23z__: The creepy uncle who keeps scaring the kids with his war stories, yes.
00:31:52 <jrockway> http://twitter.com/merlyn/status/8482813603
00:32:17 <k23z__> jrockway: you cannot imagine how happy I feel
00:32:37 <jrockway> :)
00:34:56 <jrockway> k23z__: here's the relevant log excerpt if you care: http://scsys.co.uk:8001/39359
01:12:21 <Jafet> ping
01:12:22 <gogonkt> PONG, now at #haskell
01:13:46 * Daerim wonders if the internet would be faster without all those ping-pong balls going back and forth
01:14:33 <Jafet> What nonsense. IP stands for Internet over Pingpong
01:16:33 <Daerim> ohh, that makes sense. Incredible what they can fit into those small cables
01:17:22 <pettter> only because it's all DIGITAL
01:17:45 <k23z__> where's jordi ?
01:17:57 <Jafet> They even developed a pingpong ball theory of light, to explain how those small cables work.
01:19:14 <dolio> Jordy? http://www.youtube.com/watch?v=7IiLZ0dvDWU
01:21:43 <Daerim> Jafet, ahh I heard about that one. Something about ping/pong duality
01:34:58 <eflister> hey, anyone have time to help me with a relatively involved question?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21003
01:35:30 <eflister> the gist is wanting to be able to start threads from within ghci and control them interactively from the prompt, but i think they're not starting cuz of laziness
01:38:32 <quicksilver> eflister: laziness should never stop a thread starting.
01:38:34 <quicksilver> that's not what laziness is.
01:38:45 <quicksilver> laziness is about delaying pure computations until the result is demanded.
01:38:57 <quicksilver> it specifically doesn't apply to the execution of IO effects, such as thread creation.
01:39:29 <eflister> well the thread might be starting but since there's nothing demanding that it do anything, i think it's waiting around doing nothing...
01:40:15 <eflister> i tried a few $!'s at places i thought would help, but they didn't.
01:40:46 <quicksilver> as I say, it shouldn't help.
01:40:51 <quicksilver> if it does you're doing something horrible.
01:41:06 <quicksilver> strictness annotations control the evaluation of pure functions, where timing doesn't matter
01:41:20 <eflister> :)  any chance you could work thru my code with me?  it shouldn't be too hairy...
01:41:22 <quicksilver> they're irrelevant to the execution of IO effects, where timing of course is an important part of the semantic.
01:41:26 <quicksilver> I am looking
01:41:30 <eflister> cool thx!
01:41:34 <quicksilver> but it's a little too big to spot the problem in 10 seconds.
01:41:54 <quicksilver> if you used the horrible, broken, misdocumented writeList2Chan or getChanContents that might explain it
01:41:58 <quicksilver> but it doesn't look like you do
01:42:13 <eflister> nope
01:42:18 <eflister> i just forkIO
01:43:14 <eflister> and it worked before when i was generating a fixed number of events rather than letting it generate continuously until an MVar flipped...  (same threading architecture, etc)
01:45:19 <bastl> Hi. I need advice: My supervisor "wants to learn haskell" but he doesn't find the "right" book. He's theoretician, working on measure and category theory, probably no will to "play with ghci". What could I give him to quickly learn the correspondences between category theory / algebraic specifications and advanced stuff like generic programming (e.g. with multirec or regular)?
01:45:43 <quicksilver> eflister: deadlocking on an mvar perhaps
01:45:51 <quicksilver> eflister: I don't have time now to look further
01:45:59 <eflister> ok thx for looking
01:46:20 <eflister> any opinion if this is totally the wrong way to be trying to do this?
01:47:53 <eflister> i don't think i have a deadlock, but any easy strategy to find out?  i'm not familiar with the debugger...
01:50:38 <quicksilver> eflister: I don't see how else it could be "doing nothing" unless a deadlock
01:51:19 <Daerim> bastl, not quite sure.... It might be better to ask later when more of the mathheads are on. "Real world haskell" is the standard haskell book, but it's not that mathematical to be honest
01:51:34 <Adamant> bastl: might not be the best suggestion, but a link to sigfpe's blog might be best.
01:52:16 <bastl> link?
01:52:29 <dschoepe> @google sigfpe blog
01:52:30 <lambdabot> http://blog.sigfpe.com/
01:52:30 <lambdabot> Title: A Neighborhood of Infinity
01:52:31 <bastl> got it
01:53:26 <eflister> quicksilver: well, kind of a lame design that i have cuz i was migrating from a non-interactive version, is that all the action is driven by printing out WriterT logs.  when i moved from a fixed number of events, so that the end of a list drove the demand to print out the log, to this design where it is supposed to run indefinitely (so no one demands the log is printed out), is when this behavior started...
01:55:20 <bastl> *sigh*, no much to advanced. He has the theoretical background, but _no_ idea of the practics: a question was: "typeclasses", is that the same like overloading? He needs to learn the very basics.
01:56:14 <dschoepe> bastl: perhaps "A Gentle Introduction to Haskell" might be a good start, since a lot of people don't consider it that gentle and suitable for mathematicians
01:59:13 <eflister> bastl: i can't think of something that is gentle in haskell but advanced in category theory.  these lecture notes in combination with the gentle introduction or wikibook and rwh may fit the bill: http://haskell.org/haskellwiki/User:Michiexile/MATH198
01:59:14 <bastl> Hmm. he knows about all that "popular" stuff, he also had a look at (perhaps even read) Gentle Intro, and RWH but still asks those questions. I think the problem is not finding "the right book", but finding the right way and gaining experience. But how to communicate that? :-/
01:59:44 <eflister> wait if he read that stuff and doesn't know what typeclasses are...
02:00:25 <eflister> maybe the typeclassopedia is about right
02:00:51 <eflister> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
02:03:29 <bastl> that one is new to me
02:03:43 <eflister> quicksilver: oh you may be right, i forgot i hadn't resolved the problem on line 123
02:03:47 <bastl> I have to read up also the lecture notes from above.
02:05:55 <eflister> the typeclassopedia is killer -- it all falls into place after that
02:16:38 * hackagebot upload: lrucache 0.1.1 - a simple, pure LRU cache (CarlHowells)
02:27:01 <lpsmith> why the hell does cabal-install *insist* on installing template-haskell-2.3.0.1,   and fails at that...
02:27:44 <lpsmith> I've resorted to compiling packages manually... although cabal unpack is certainly a *big* help!
02:28:36 <Daerim> lpsmith, look on the bright part. At least cabal doesn't actively ruin your installation. Python's pip has been known to do this
02:28:45 <lpsmith> haha, true
02:28:51 <lpsmith> Not ever tried using pip though
02:29:33 <lpsmith> I had Ubuntu distribution upgrade totally destroy an installation once,  beyond any reasonable hope of recovery
02:30:00 <lpsmith> I can't wait for btrfs,  no more worries about stuff like that...
02:30:25 <Daerim> well, a distro upgrade is likely to break any kind of linux afaik
02:30:31 <Daerim> btrfs?
02:31:14 <c_wraith> the linux response to zfs
02:31:21 <lpsmith> btrfs,  it has efficient,  writable snapshots
02:31:57 <lpsmith> yeah, I've read about zfs, never had the chance to play with it though
02:32:10 <Jafet> Why don't they just use zfs
02:32:25 <Daerim> ohh, right. read about that. Supposed to replace  extfs, yes?
02:32:46 <Jafet> Nothing will ever replace extfs
02:32:49 <c_wraith> the kernel developers don't like that zfs ignores their rules for how a file system should be built.  It's not all nicely-contained layers
02:33:01 <koala_man> zfs was licensed specifically to be gpl incompatible
02:33:03 <Jafet> xfs and reiserfs have tried, and failed
02:33:24 <lpsmith> I use JFS,  I'm quite happy with it, for now
02:33:26 <Jafet> You don't need GPL compatibility to include something in a distro.
02:33:30 <c_wraith> (mostly because those layers prevented doing things that zfs's devs deemed important)
02:34:05 <koala_man> Jafet: no, and indeed there is a fuse based zfs implementation. it's fairly slow from what I hear
02:34:23 <lpsmith> And I don't know too many details,  but the internals of ZFS and btrfs are *very* different,  not to mention that I'd imagine it would be considerable work to get it to work with the linux kernel
02:34:35 <Jafet> Perhaps that's because it's still being written
03:12:59 <Zeiris> jmcarthur, is the googleai-haskell-starter a public library, or your own bot, or what?
03:45:06 <dang> hello
03:45:58 <dang> i've just started with haskell and i know the data statement in general to declare data types. but now i stumbled on something that says data Foo a n where VFoo :: Foo a Zero.... how do i interpret that?
03:46:24 <zygoloid> dang: that's a GADT. if you've just started, i'd recommend ignoring them for the time being
03:46:41 <dang> GADT is some ghc extension?
03:46:45 <zygoloid> yes.
03:46:53 <dang> ok thank you!
03:48:29 <zygoloid> briefly: GADT syntax looks like: 'data Foo a b where C1 :: t1 -> t2 -> Foo a1 b1; C2 :: t3 -> Foo a2 b2'. the things after the 'where' are the type signatures for the data constructors of 'Foo'
03:48:41 <ziman> generalized algebraic data type, if you feel like googling
03:49:31 <dang> ill definitely do that, thanks for the pointers!
03:49:34 <zygoloid> this basically allows you to put restrictions on the type and context in which the data constructor can be used.
03:49:56 <dang> was that introduces to have better methods of express types over polymorphic data types?
03:50:01 <dang> oh ok
03:50:03 <Jafet> This sounds like the sort of stuff you see in "Agda for newbies"
03:50:11 <zygoloid> so given 'data Foo a where DFoo :: Double -> Foo Double; IFoo :: Int -> Foo Int', Foo Int has the Ifoo constructor, Foo Double has the DFoo constructor, and other 'Foo a' types have no constructors at all
03:50:49 <zygoloid> dang: well you can use GADT syntax to describe normal ADTs (and some people do this because they find the syntax nicer)
03:51:00 <dang> ok i understand
03:51:15 <zygoloid> equally, with -XTypeFamilies and -XExistentialQuantification, you can do (i think) everything you can do with GADTs with normal ADT syntax
03:51:19 <dang> i think i got the point but given i didnt know this syntax until a few minutes ok its still a bit confusing :)
03:51:23 <dang> thanks so far!
03:58:02 <bastl> Is there a comprehensive list of language extensions ? E.g. i want to look up details on "TypeOperators"
03:58:34 <IceDane> Is there a way to specify what characters are valid to be parsed in Parsec? Pretty much the opposite of noneOf.. I want to do something like: "many (only validChars)" where valid chars is a String of valid chars.
03:58:42 <dolio> The ghc user guide should have info on most of them.
03:59:09 <dolio> @hoogle oneOf
03:59:09 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:59:09 <lambdabot> Text.ParserCombinators.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
03:59:09 <lambdabot> Test.QuickCheck oneof :: [Gen a] -> Gen a
03:59:21 <IceDane> dolio: Doesn't that only parse one of those characters?
03:59:23 <IceDane> oh, duh
03:59:24 <IceDane> many
03:59:25 <IceDane> thanks.
03:59:27 <bastl> yeah, im browsing chap 7.4 but im looking for a reference ...
04:01:12 <bastl> like in api reference
04:01:21 <dolio> Well, I'd expect type operators to be in 7.3.
04:02:21 <dolio> I don't see it mentioned, though.
04:03:53 <bastl> So there is no reference? Fulltext search in the pdf got me three hits ... and none of them explained it thoroughly
04:03:58 <nschoe> Hi all, can anyone explain to me how I can get rid of the "Ambiguous type variable 'e' in the constraint : 'GHC.Exception.Exception e' " message, I'm trying to use in handle but I get this message.
04:04:12 <dolio> Anyhow TypeOperators lets you use infix syntax for types.
04:04:42 <dolio> Which includes both stuff like `T` and stuff like +++.
04:04:48 <bastl> ok, thanks. But it seems i have to ask again for the next extension i encounter and dont understand ...
04:05:16 <dolio> Well, a lot of them are in chapter 7.
04:07:10 <zygoloid> bastl: ghc --supported-languages will list them but not describe what they do
04:07:28 <zygoloid> however the extension names are usually good for googling
04:08:22 <bastl> Ok, thanks. Perhaps someone could mention this as an advancement to the editors of the guide.
04:12:09 <IceDane> Is there no way to return a custom type from a parser combinator in parsec? I'm basicaly doing something like: "p = do x <- parsex; y <- parsex; return MyType x y"
04:12:44 <dolio> return (MyType x y)
04:12:57 <byorgey> or  return $ MyType x y
04:13:14 <dolio> Or   MyType <$> parsex <*> parsex
04:13:16 <byorgey> OR  p = liftM2 MyType parsex parsex
04:13:37 <byorgey> yes, or that if you have an Applicative instance for Parser
04:14:02 <dolio> I think parsec 3 does, at least (since I've used it).
04:14:14 <byorgey> yes, it does, but parsec 2 doesn't
04:14:25 <byorgey> although it's easy enough to add
04:14:36 <dolio> Well, that's just one more reason for people to upgrade. :)
04:14:42 <byorgey> =)
04:15:53 <Alpounet> nschoe, you should paste your code on http://hpaste.org/ and give us the link
04:16:02 <zygoloid> dolio: to add onto the list of bytestring support and slower parsing? ;-)
04:16:32 <dolio> And being 1 higher.
04:17:09 <IceDane> dolio: ah, yeah, of course
04:26:40 <benmachine> these parsers go up to 3
04:27:52 <Beelsebob> yeh, well my parser goes up to 11
04:28:54 <quicksilver> @tell jmcarthur I can explain my misgivings about lub more clearly now :) It is related to monotonicity but I didn't express it well.
04:28:54 <lambdabot> Consider it noted.
04:31:31 <dolio> quicksilver: Oh yeah?
04:31:51 <quicksilver> dolio: lub _|_ 4 = 4
04:32:04 <quicksilver> dolio: so what is lub 3 4 ?
04:32:15 <quicksilver> it should be "more defined" than 4
04:32:21 <quicksilver> that's what monotonicity says?
04:32:24 <dolio> A violation of the unenforced precondition.
04:32:29 <quicksilver> right.
04:32:52 <quicksilver> but normally the semantic account of violated preconditions is _|_
04:33:02 <quicksilver> as in, for example, head []
04:33:32 <quicksilver> in this case, we can't use _|_; (1) because it's not a computable violation and (2) if we did that wouldn't be monotonic.
04:34:11 <dolio> Ah, true.
04:34:48 <quicksilver> that's why it makes me feel queasy
04:35:03 <quicksilver> and my intuition tells me we might be able to violate this precondition in quite subtle ways
04:35:19 <quicksilver> take the lub of two rather long lists which are certain equal for the first few elements
04:35:33 <quicksilver> I think you could develop subtle bugs that way
04:35:57 <quicksilver> bugs which have no semantic account, because you've violated a precondition without which you have no semantics.
04:38:48 <Figs> Hi
04:39:13 <Figs> I get weird notices from my antivirus software when I use cabal
04:39:47 <Figs> Is cabal supposed to build and strangely named executables (usually all numbers) during an install process?
04:39:53 <Figs> *build and run
04:43:39 <dolio> quicksilver: I was thinking you might have a reason to dislike it even within the preconditions. It kind of makes me uneasy, too, but I think it's due to the behavior outside of its intended use.
04:43:51 <dolio> Of course, the fact that it's impossible to enforce the intended use is bad.
04:48:17 <quicksilver> dolio: generally we expect incorrect (outside intended use) code to *have* a semantics, though?
04:48:20 <kingping> Is there any lite haskell interpreter just for learing purposes?
04:48:27 <quicksilver> dolio: it's a bit nasty if only correct code has semantics.
04:48:31 <quicksilver> dolio: how then do you reason about mistakes?
04:49:15 <quicksilver> kingping: yes, hugs, is a bit smaller and possibly easier to install. But most people use ghci in practice.
04:49:25 <dolio> Yes. I hadn't thought about the fact that there's no semantically admissable thing you can return when the precondition is violated, even in principle.
04:49:30 <kingping> quicksilver: Thanks.
04:49:35 <dolio> That's a good point.
04:50:55 <kingping> oh, it uses X.
04:51:38 <quicksilver> dolio: unless you add top to the semantics.
04:51:52 <quicksilver> hugs doesn't really use X
04:52:06 <quicksilver> it might have a windowed client
04:52:16 <quicksilver> but it is basicaly a commandline app, just like ghci
04:52:53 <quicksilver> dolio: it really does point to *needing* the type system to verify this. It's something you want to know statically.
04:53:04 <dolio> Yeah. I'd thought top wasn't particularly useful, since it behaves a lot like bottom. But perhaps adding it would allow you to make lub well-defined.
04:53:15 <etpace> I can make my own type act like a Number with instance Num etc, but is there a way I can make it act like a Bool? so that things like list comprehensions will work
04:53:28 <quicksilver> dolio: I.e. lub is only really 'sane' in a system powerful enough to carry around this kind of proof
04:53:49 <quicksilver> etpace: no. Bool (and its place in list comps) is special.
04:54:27 <dolio> Yeah, although, on that end, I wonder how useful it is. How often can you prove that x ~= y without more or less knowing what you want lub x y to be already?
04:54:32 <kingping> quicksilver: requires X in ports, suppose I can disable it by specifying WITHOUT_X.
04:54:38 <dolio> I suppose it's still useful for provably commutative operators.
04:54:45 <etpace> so my best bet is reimplementing == etc to do (a -> a -> MyBool)?
04:55:01 <etpace> is there a reason why bool is special?
04:55:53 <quicksilver> etpace: not really, no. simplicity.
04:56:03 <quicksilver> the idea of a bool typeclass comes up every few months.
04:56:20 <benmachine> it's only special in that desugaring of if, do, listcomps etc. are hardcoded to Bool
04:56:37 <quicksilver> dolio: well that's another block in my intuition; I don't really know what lub is useful for, that I woudl consider sane.
04:56:38 <benmachine> I think
04:56:49 <quicksilver> dolio: for the record, I don't consider the way conal does FRP as sane, for example ;)
04:56:52 <benmachine> oh, and guards I suppose
04:58:44 <rovar> I have a general design question regarding mixing multiple monads in a sane fashion.
04:59:57 <rovar> I have several apps that are basically RPC clients/servers that all have 3 things in common. They use (different) binary serialization. They are multithreaded, and they need quality error reporting.
05:00:34 <rovar> I was thinking about making a generic network client monad, which would handle State, STM, and Errors.   First, does such a thing already exist?
05:00:54 <quicksilver> I'm not aware of such a thing rovar.
05:01:17 <dolio> quicksilver: Well, if you can prove that 'op' being commutative implies that 'liftM2 op' is commutative up to the partial equivalence relation, which seems like it might be possible, then liftM2 op x y `lub` liftM2 op y x migth be useful.
05:01:26 <rovar> if not.. i saw a thread that recommends using ErrorT and STM  : http://www.opensubscriber.com/message/haskell@haskell.org/4182029.html
05:01:28 <dolio> The monad in question being the partiality monad.
05:02:25 <quicksilver> dolio: *nod*
05:02:33 <rovar> i think that will get me close.. but I am concerned primarily about ergonomics.
05:05:43 * ksf decides to forget about http for now and implement spdy instead
05:07:22 <IceDane> Is there a short way(using >>=/>> etc) to do: "fn = do x <- doStuff; doOtherStuff; return x" ?
05:08:42 <dolio> @type (<*)
05:08:43 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
05:08:44 <mux> > (return 1) <* return 3
05:08:45 <lambdabot>   No instance for (GHC.Show.Show (f t))
05:08:46 <lambdabot>    arising from a use of `M6097545188...
05:08:57 <shambler> that spdy thing is interesting
05:08:58 <galdor> IceDane:  doStuff >>= doOtherStuff >>= return ? I may be wrong, I'm a beginner ^^
05:09:02 <mux> > return 1 <* return 3 :: [Int]
05:09:03 <lambdabot>   [1]
05:09:07 <galdor> oops
05:09:20 <galdor> my bad, doOtherStuff doesn't use x
05:09:23 <mux> applicative functors to the rescue
05:09:32 <ksf> but I'm talking nonsense, I still need to do http
05:09:49 <ksf> the nice thing is that I can forget about that insane http pipelining
05:10:36 <IceDane> dolio: Do I need to define GenParser .. etc .. as an isntance of applicative myself, then, as is done in RWH?
05:10:53 <dolio> IceDane: Are you using parsec 2?
05:11:01 * mux remembers having done that in the past
05:11:02 <IceDane> dolio: I really have no idea
05:11:08 <mux> parsec 3 should have it already
05:11:19 <IceDane> I'm just using whatever parsec I had
05:11:25 <IceDane> I see
05:11:26 <dolio> What module names are you importing?
05:11:38 <IceDane> Text.ParserCombinators.Parsec
05:12:14 <IceDane> Any way to test which parsec module I have installed?
05:12:15 <dolio> I guess that's probably 2, then. Anyhow, you can try using the applicative stuff, and if it doesn't work, define it yourself.
05:12:25 <dolio> ghc-pkg list parsec
05:12:31 <dolio> Should show you what you have installed.
05:12:34 <IceDane> Hmm, alright
05:12:39 <IceDane> Ah, yes, 2.1
05:12:41 <IceDane> .0.1
05:13:11 <dolio> Anyhow, an implementation is just 'instance Applicative (Parser ...) where pure = return ; (<*>) = ap'
05:13:52 <IceDane> Yeah, I remember from RWH. I just wasn't sure if it was 'standard/well known use', if you get me, and I didn't want my code to be doing strange things that not everyone might recognize
05:14:03 <IceDane> But I assume it's common since it's in parsec 3
05:14:23 <dolio> The various applicative combinators are very useful during parsing, if you ask me.
05:14:43 <benmachine> doing strange thigns that people don't recognise is how you make progress :P
05:14:48 <benmachine> ish
05:14:53 <IceDane> They seem so.. I don't understand applicative parsing to its full extent, but it looks pretty nice in RWH.
05:15:02 <IceDane> I don't get how parsing didn't make sense to me before
05:15:05 <IceDane> it's so declarative
05:16:13 <dolio> Foo <$ string "Foo"    Binary <$> arg1 <* comma <*> arg2
05:16:15 <dolio> Etc.
05:16:58 <ksf> "It takes about ten gigabytes or so of disk space to check out and build the source tree."
05:16:59 <ksf> It takes about ten gigabytes or so of disk space to check out and build the source tree.
05:17:01 <ksf> wtf
05:17:23 <benmachine> which source tree is this
05:17:37 <Dark_Shikari> homo sapiens?
05:17:51 <ksf> chromium
05:18:24 <benmachine> hah
05:18:28 <IceDane> I just installed parsec3 - should I be removing parsec2? It seems ubuntu wants to remove libghc6-network-dev along with it as well
05:18:29 <benmachine> aaawesome
05:18:37 <benmachine> IceDane: dont' remove parsec2
05:18:42 <benmachine> some things still use it
05:18:52 <IceDane> ah, alright
05:18:56 <benmachine> (e.g. libghc6-network-dev, apparently)
05:19:08 <IceDane> How do I make sure i'm using parsec3 instead of 2 in my code?
05:19:14 <ksf> ...I'm just trying to get hold of a spdy client implementation
05:19:15 <IceDane> Highest version by default?
05:19:37 <benmachine> import Text.Parsec
05:19:43 <IceDane> ah, cool, thanks.
05:19:56 <benmachine> the ParserCombinators bit of the name was dropped in version 3
05:20:15 <dolio> It should just use the highest version by default, though. If you want to pick specific version requirements, you can use cabal.
05:20:22 <benmachine> or -package
05:20:26 <dolio> Yeah.
05:20:27 <benmachine> or -hide-package
05:20:32 <IceDane> I see.
05:21:12 <jao> When i try to read the contents of a file in /proc using Data.ByteString.Char8.readFile, the result is always an empty bytestring. Data.ByteString.Lazy.Char8 works, though. Is that expected behaviour?
05:22:03 <yokto> when using hint I came upon a problem - if i use loadModules ["Module.From.Package"] - i get the error "module `Module.From.Package' is a package module" - so how do i load it? - if i don't load it at all it sais it's not loaded
05:23:13 <IceDane> Heh, trying to recompile using parsec3 breaks my code. Is it really that different?
05:23:46 <Alpounet> parsec3 won't make it into Haskell Platform
05:23:47 <medfly> ! is forcing strict evaluation, right?
05:23:52 <Alpounet> neither in the arch repos, apparently
05:24:21 <Alpounet> so I guess the general opinion about it is to focus on parsec2 for the moment.
05:24:21 <ksf> I don't think parsec is a particularily good parser
05:24:22 <medfly> (and how do I make my file tell that it needs to use this extension?)
05:24:32 <Alpounet> ksf, what would you recommend ?
05:24:43 <ksf> uu-parsinglib is a better candidate, but it could definitely use a useability overhaul
05:24:53 <quicksilver> polyparse is another option
05:24:55 <ksf> if in doubt, write your own
05:25:03 <quicksilver> parsec's no-backtrack-by-default annoys me muchly.
05:25:16 <ksf> the one I just wrote doesn't backtrack, either.
05:25:24 <IceDane> Meh. I'll just remove parsec 3 again and then define genparser .. etc .. as an instance of applicative myself
05:25:26 <ksf> or looks ahead
05:25:41 <ksf> there's also frisby, but it's not on hackage
05:26:47 <ksf> right now, it seems like i'm going to completely seperate the context-free stuff from everything monadic.
05:27:25 <shambler> ksf, why do you think parsec isn't good?
05:27:27 <ksf> need to mull over how to make my parsing ADT directly an instance of an iteratee class, somehow
05:27:39 <ksf> backtracking is the biggest issue
05:28:09 <Zeiris> Is there a faster/lighter data type for small 2D arrays than Data.Array? My own wrapper of Data.Bytestring maybe?
05:28:30 <ksf> bytestring is a wrapper around data.array, basically
05:28:38 <ksf> you might try to work directly on Ptr a
05:28:49 <ksf> ...but what are you trying to do?
05:29:11 <ksf> fixed-size tuples might work
05:29:21 <Zeiris> On second thought? Nothing that requires this much pre-emptive optimization :E
05:29:39 <ksf> some vector libs use tuple types
05:29:57 <quicksilver> Zeiris: http://donsbot.wordpress.com/2010/02/15/migrating-from-uvector-to-vector/
05:30:05 <quicksilver> Zeiris: but, this does sound like premature optimisation to me ;)
05:30:26 <ksf> gragh. I tend to type "chromium" to start chromium, and get a video game.
05:31:52 <medfly> @hoogle a -> b -> Ordering
05:31:54 <lambdabot> Prelude const :: a -> b -> a
05:31:54 <lambdabot> Data.Function const :: a -> b -> a
05:31:54 <lambdabot> Prelude seq :: a -> b -> b
05:31:59 <medfly> er...
05:32:24 <domor> I was wondering if there was a more idiomatic/short way of validating user input. Something like ask = fromMaybe ask (return parse <$> getLine) -- does not compile, where parse returns Just something or Nothing depending on whether it could parse the input. My current code (http://codepad.org/9qcHjpye) looks ugly.
05:32:31 <medfly> @hoogle (Ord a) => a -> a -> Ordering
05:32:31 <lambdabot> Prelude compare :: Ord a => a -> a -> Ordering
05:32:32 <lambdabot> Data.Ord compare :: Ord a => a -> a -> Ordering
05:32:32 <lambdabot> Prelude max :: Ord a => a -> a -> a
05:34:44 <quicksilver> ksf: put /usr...bin in your PATH before /usr/games/ ?
05:36:17 <Zeiris> quicksilver, cool, is there a significant difference between a 2D Array and Vector stacked two-deep though?
05:36:48 <Botje> domor: tolower is in Data.Char
05:36:53 <Botje> oh, nvm
05:37:01 <Botje> that was automatically added by the pastebin :(
05:37:11 <domor> yes, it's not really runnable anyway
05:37:22 <Botje> domor: you could use the maybe function?
05:37:32 <ksf> quicksilver, won't work, googles chromium is called chromium-bin
05:37:42 <etpace> Does lazy IO make haskell sockets nonblocking by default?
05:37:57 <ksf> ...and I've got no idea how to make it speak spdy
05:38:47 <Botje> hmm
05:38:51 <Botje> or even mplus.
05:39:05 <Botje> blah, nvm :(
05:39:19 <domor> if I make it simpler: I don't really understand why ask = fromMaybe ask (return $ parse <$> getChar)   returns a maybe and not a value
05:39:21 <quicksilver> Zeiris: 2D arrarys are really 1D
05:39:32 <quicksilver> Zeiris: the indices are just a translation layer
05:39:45 <quicksilver> Zeiris: it might or might not be worth implementing a similar layer on a vector.
05:40:04 <ksf> the other possibility is to make someone of _y'all_ implement a spdy client
05:40:13 <quicksilver> etpace: lazy IO is entirely unrelated to sockets being blocking or nonblocking.
05:40:15 <ksf> ...if I do it myself, I'm going to be bug-compatible to myself.
05:40:44 <Botje> domor: maybe getChoice return (parse $ head r)
05:41:17 <Botje> is that not-ugly enough for you ? :)
05:42:11 <etpace> well if I have something like read socket >>= \data -> .. do stuff >> do stuff with data, wont the socket not actually "wait" for data until I do stuff with it?
05:44:05 <quicksilver> etpace: IO in haskell is blocking by default and that's probably the best way to use it
05:44:19 <quicksilver> (use threads if you don't want to wait for a read, rather than trying a non-blocking read)
05:44:35 <quicksilver> etpace: and to answer you question, no it won't wait. It will read immediately.
05:44:53 <quicksilver> "lazy IO" is mis-named, semantically unsound, and a non-composable abstraction
05:45:01 <etpace> heh ok
05:45:04 <quicksilver> "fortunately" it's restricted to a small number of primitves in the standard library
05:45:16 <quicksilver> getContents, readFile, getChanContents
05:45:42 <quicksilver> the dangers of it are worse with chans than with files, and worse with sockets than with changs.
05:45:45 <quicksilver> chans.
05:46:55 <theorbtwo> Hm, and I was thinking of trying my haskell again, attempting to build a lazy parser for potentially very large binary files.
05:47:15 <Zeiris> What does 'boxed' mean with respect to arrays?
05:47:24 <etpace> ok, thanks quicksilver
05:47:49 <quicksilver> theorbtwo: obviously one should take my bile with a pinch of salt.
05:47:49 <osaunders> Why is this illegal: instance Eq ((,) String String) where... ?
05:47:58 <doserj> Zeiris: elements are pointers to possibly unevaluated values (thunks)
05:48:22 <Daerim> theorbtwo, use binary :) Fast and lazy
05:48:47 <domor> Botje: thanks. took me a while to understand that return was the a->b :)
05:48:48 <quicksilver> theorbtwo: mostly I object the (ab)use of the word 'lazy'. A parser for potentialy very large binary files which interleaves the IO is an interesting thing.
05:48:55 <quicksilver> theorbtwo: you just have to understand the risks of interleaving the IO.
05:49:18 <quicksilver> (it's not very different from what mmap() does, e.g., although mmap() doesn't give you automatic garbage collection of pages)
05:49:21 <doserj> osaunders: there already is an Eq instance for tuples
05:49:36 <quicksilver> osaunders: it's not legal because haskell98 has a curious restriction on instance form
05:49:48 <quicksilver> osaunders: well, actually, two curious restrictions forbid that one
05:50:00 <quicksilver> with -XFlexibleInstances and -XTypeSynonymInstance that instance is legal
05:50:11 <quicksilver> although, as doserj says, there is already an instance for that type.
05:50:25 <osaunders> quicksilver: What was the thinking behind those restrictions?
05:51:22 <quicksilver> not 100% sure. I think the general idea was that parametric types should have parametric instances
05:51:30 <quicksilver> so you shouldn't make an instance (of anything) for [Int]
05:51:40 <quicksilver> instead you should seek the way to make the parametrict instance for [a]
05:51:47 <quicksilver> as a guideline it's a sensible one.
05:52:40 <theorbtwo> Hm.  You can still do Eq a => [a], though?
05:53:03 <osaunders> theorbtwo: That's not an instance declaration.
05:53:14 <osaunders> quicksilver: OK. That makes sense.
05:53:19 <quicksilver> theorbtwo: yes, that would be an example of an appropriately parametric one
05:53:53 <quicksilver> instance Eq a => Eq [a] where [] == [] = True; (x:xs) == (y:ys) = x == y && xs == ys
05:54:22 <quicksilver> osaunders: but there are plenty of cases where it is an annoying restriction.
05:54:40 <quicksilver> osaunders: in your case, though, there is a natural parametric instance Eq a, Eq b => Eq (a,b)
05:54:44 <quicksilver> ...and that's in the prelud.
05:54:55 <quicksilver> > (1,"hi") == (2,"bye")
05:54:56 <lambdabot>   False
05:55:47 <osaunders> Yeah.
05:55:56 <osaunders> theorbtwo: Ignore my silly comment.
05:57:28 <medfly> @src maximumBy
05:57:29 <lambdabot> Source not found. Just try something else.
06:00:39 * theorbtwo decides to go off-script for a while, and write some Mass Effect data file parsers.
06:04:21 <freiksenet> hello! I am trying to learn a bit of haskell, and I have a small question ) I wonder if it is possible to have 'where' to work over multiple  function definitions,
06:05:24 <zygoloid> freiksenet: no. since 'where' scopes over the function arguments, that can't really work.
06:05:46 <mornfall> freiksenet: I don't think so. You have to lift the bodies to a peer where clause.
06:06:11 <IceDane> How come when I can "cat file" in shell, readFile returns "resource busy (file is locked)" ?
06:06:14 <mornfall> Say myfun = go where go [] = ... ; go (a:as) = ...; helper = ...
06:06:54 <zygoloid> IceDane: sounds like a bug
06:07:33 <freiksenet> mornfall: well I can just use case pattern matching then :) I
06:08:15 <freiksenet> just had one helper that is used in both matches of one function, so wondered if where can affect both. if not, I will probably use case.
06:08:41 <mornfall> freiksenet: Yes, that's of course an option, too. :)
06:08:56 <freiksenet> thanks :)
06:10:11 <medfly> hi... I have a problem with this code I have, blowing the stack :(
06:10:42 <quicksilver> IceDane: windows?
06:10:58 <Botje> medfly: can you put the code online?
06:11:07 <Botje> and does it still stack overflow if you compile with ghc --make -O2 ?
06:12:02 <IceDane> quicksilver: linux
06:13:13 <medfly> oh, neat
06:13:15 <quicksilver> IceDane: baffling
06:13:23 <medfly> Botje, it actually does not. what's the difference?
06:13:47 <quicksilver> -O2 does various things which might remove stack overflows
06:13:59 <quicksilver> list fusion, RULEs rewriting, strictness analysis
06:14:01 <medfly> oh
06:14:20 <Botje> yes
06:14:22 <medfly> yeah, I wanted to make something be evaluated strictly, I think that would have worked too...
06:14:29 * ddarius recommends writing code that doesn't stack overflow even without optimizations.
06:14:31 <medfly> RULEs writing is what?
06:14:40 <medfly> I just couldn't figure out how to do that
06:14:44 <Botje> things which stack overflow in ghci usually work just fine (and much faster) with ghc
06:15:07 <kingping> It's me again. Is this a tail-recursive?     rec [] y = y             rec x y = rec (tail x) ((head x):y)
06:15:11 <ddarius> s/recommends/highly recommends/
06:15:18 <ddarius> kingping: Yes.
06:15:27 <medfly> so how do I make something evaluate strictly? :)
06:15:28 <kingping> ddarius: Cool.
06:15:28 <IceDane> quicksilver: I've made conky execute "cat file" periodically.. then I'm trying to write to this file with my haskell program in the shell
06:15:31 <medfly> thanks.
06:15:37 <IceDane> I can echo something > file, and cat file in the shell
06:15:41 <Botje> kingping: you should use pattern matching instead of head/tail though
06:16:04 <IceDane> but can't readFile or writeFile
06:16:07 <IceDane> strange stuff.
06:16:18 <doserj> IceDane: you are opening the same file twice without closing it inbetween
06:16:26 <kingping> Botje: Sure, I'm just started learning, wanted to make sure it has tail recursion as in erlang.
06:16:30 <kingping> :]
06:17:21 <ddarius> kingping: A function being tail recursive is a syntactic property independent of tail call optimization and stack usage.
06:17:30 <IceDane> doserj: CAn I not use openFile to return a handle that I then read from, modify the contents, and write to it?
06:17:34 <Saizan> tail recursion is the second-best option in haskell though :)
06:17:35 <ddarius> The equivalent function in C would also be tail recursive.
06:17:53 <Botje> kingping: haskell is built on graph reduction; tail recursion doesn't necessarily apply.
06:17:55 <kingping> BTW is there any real interpreter -- I'm using Hugs atm -- with REPL?
06:18:01 <Botje> ghci
06:18:10 <Botje> don't use hugs, it's old and crufty
06:18:16 <ddarius> Botje: Haskell isn't built on graph reduction, but if it were, tail recursion would apply.
06:18:44 <Botje> hmm, then i have to re-read the simonpj book. boo!
06:19:15 <kingping> Botje: Hmm, it's applicable to all Haskell implementations and reduces the chances I get the same speed and efficiency I would get with Erlang, Prolog?
06:19:24 <ddarius> s/tail recursion would apply/tail recursions would be optimized/
06:19:24 <doserj> IceDane: that should work
06:19:37 <Botje> oh.
06:19:39 <kingping> Botje: But it's small :( Have no cheap inet here.
06:19:44 <Botje> kingping: ignore me
06:20:19 <ddarius> kingping: Haskell doesn't require tail calls to be optimized, but any sane implementation will and all extant ones do optimize tail calls.
06:20:38 <IceDane> doserj:  hPutStr: illegal operation (handle is closed)
06:20:41 <IceDane> eh, sorry
06:20:45 <IceDane> http://codepad.org/3DjiyM5r
06:20:46 <IceDane> There.
06:20:51 <ddarius> kingping: However, lazy evaluation brings other considerations into play and can make code that is good in an eager language bad in Haskell and vice versa.
06:20:53 <IceDane> Anything wrong with that code, anyone?
06:21:07 <kingping> Ok mates, I'll read more on it somewhere. I'm just new to the haskell world.
06:21:27 <ddarius> kingping: Just learn to do call-by-name reduction by hand and you can just see all this.
06:21:48 <medfly> http://moonpatio.org/fastcgi/hpaste.fcgi/view?id=7473#a7473 <- so this was the code that blew the stack, I think what I need to do is strictly evaluate the stuff collatz receives...
06:21:55 <doserj> IceDane: hGetContents is the problem
06:21:58 <Saizan> IceDane: you can't reuse an handle you've passed to hGetContents
06:22:09 <IceDane> Really?
06:22:13 <IceDane> Why is that?
06:22:14 <kingping> ddarius: Last thing you say unknown to me. :] gonna google.
06:22:34 <Saizan> @wiki Stack overflow
06:22:34 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
06:23:34 <Botje> medfly: use an accumulator for collatz
06:23:36 <kingping> thx Saizan
06:23:45 <Botje> and then strictly evaluate that at each step
06:23:49 <medfly> Botje, what does that mean?
06:24:47 <Saizan> IceDane: to keep things saner, otherwise you could observe lazy evaluation via the point where the Handle would be, and that's a mess to manage
06:24:56 <Botje> collatz s 1 = s; collatz s n | odd n = collatz (s+2) ((3*n+1) `div` 2)
06:25:01 <Botje> roughly.
06:25:14 <medfly> oh
06:25:17 <Botje> but that isn't strict in s yet, so you'll still get overflows
06:25:28 <Botje> if you make it collatz !s 1 = s
06:25:30 <Botje> it's strict
06:25:41 <medfly> uh, I'm using this strange syntax because I read that's how you get memoization, and I wondered if having two parameters would sort of make that useless...
06:25:53 <IceDane> Saizan: Ah..
06:26:12 <Botje> medfly: you're currently not memoizing.
06:26:15 <Saizan> medfly: you don't get memoization magically by using some name
06:26:16 <medfly> damn
06:26:32 <medfly> hey, I looked it up and they *seemed* to be using this syntax for something like that.
06:26:33 <Saizan> it was together with some library, or some other code
06:26:50 <Saizan> like memo-combinators on hackage
06:26:58 <Botje> medfly: if you wanted to memoize, collatz would index into that list instead of recursing
06:27:16 <medfly> :/
06:27:22 <medfly> well, never mind then
06:28:22 <Saizan> IceDane: this is because hGetContents uses unsafeInterleaveIO to read from the Handle on demand
06:29:32 <Saizan> IceDane: other IO primitives don't do this
06:34:21 <chrisdone> today I realised that bool is a monoid on &&, and it seemed really novel that I could use the &= thing in c# and it felt like mappend and my heart was warmed
06:35:06 <koala_man> ^___^
06:35:09 <chrisdone> ^_^
06:35:43 <benmachine> is &= bitwise though
06:35:47 <benmachine> might need to be careful abotu that
06:36:03 <benmachine> > 1 .&. 2
06:36:04 <lambdabot>   Ambiguous type variable `t' in the constraint:
06:36:04 <lambdabot>    `Data.Bits.Bits t'
06:36:04 <lambdabot>      a...
06:36:06 <benmachine> fff
06:36:09 <benmachine> > 1 .&. 2 :: Int
06:36:10 <lambdabot>   0
06:39:22 <Botje> in php, &= is some funky reference magic.
06:39:22 <Alpounet> @type (.&.)
06:39:23 <lambdabot>     Ambiguous occurrence `.&.'
06:39:23 <lambdabot>     It could refer to either `Data.Bits..&.', imported from Data.Bits
06:39:23 <lambdabot>                           or `Test.QuickCheck..&.', imported from Test.QuickCheck
06:39:32 <Alpounet> oh k
06:43:04 * hackagebot upload: cabal-macosx 0.1.0 - Cabal support for creating Mac OSX application bundles. (AndyGimblett)
06:43:15 <nainaide> :t <<
06:43:16 <lambdabot> parse error on input `<<'
06:44:39 <Saizan> :t (<<)
06:44:40 <lambdabot> Not in scope: `<<'
06:45:00 <nainaide> Where can I find the definition of "<<" please?
06:45:30 <Saizan> i don't think there's one in the standard libs
06:45:31 <chrisdone> benmachine: "The & operator performs a bitwise logical AND operation on integral operands and logical AND on bool operands."
06:45:34 <Saizan> ?hoogle (<<)
06:45:34 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
06:45:34 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
06:45:34 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
06:45:43 <nainaide> :) Thanks!
06:46:36 <chrisdone> benmachine: (as you would expect really)
06:46:41 <nainaide> Infact <<  and >> confuse me, :)
06:48:04 <quicksilver> it would be fairly natural for << to be defined as flip (>>)
06:48:10 <quicksilver> since we have =<< and >>=
06:50:33 <zygoloid> @index (<<)
06:50:33 <lambdabot> Text.Html
06:51:31 <Alpounet> @hoogle (<<)
06:51:31 <lambdabot> Text.Html (<<) :: HTML a => (Html -> b) -> a -> b
06:51:31 <lambdabot> Text.XHtml.Frameset (<<) :: HTML a => (Html -> b) -> a -> b
06:51:31 <lambdabot> Text.XHtml.Strict (<<) :: HTML a => (Html -> b) -> a -> b
06:51:55 <Alpounet> of, it's been done above, sorry.
06:54:09 <forrest> hey, i'm just starting to learn haskell, and i've gotten myself into doing a report on it -- why haskell is the greatest thing since sliced bread and why we should all learn it
06:54:31 <forrest> this is in grad school, largely professional developers working in java and the like
06:54:52 <chrisdone> are you going to include code samples?
06:54:57 <medfly> since when do universities have professional developers
06:55:11 <chrisdone> with comparisons against other languages?
06:55:13 <forrest> i know i can sell "we should all learn a functional language" but why haskell?
06:55:25 <forrest> it's a program for working professionals, weekend classes
06:55:34 <medfly> ah
06:55:37 <medfly> that's more reasonable
06:55:44 <Twey> http://book.realworldhaskell.org/read/why-functional-programming-why-haskell.html
06:55:56 <Botje> forrest: "because it's fun"
06:55:58 <Botje> obviously :)
06:56:08 <chrisdone> I doubt you'll be able to make a particularly compelling report if you aren't convined of it yourself
06:56:56 <chrisdone> sorry. that sounds kind of harsh. but I wouldn't trust someone who'd just learned Scala to tell me why it's great
06:56:58 <forrest> well, the thing is i don't know any functional languages (unless you count xslt) and I picked haskell -- but I can't argue haskell vs. other functional languages
06:57:14 <quicksilver> forrest: read twey's link, read "why functional programming matters" which is an old paper on the topic
06:57:29 <quicksilver> forrest: as for "why haskell versus other FP languages" that's mostly a story about purity and laziness.
06:57:46 <Twey> forrest: Well, first learn Haskell
06:57:52 <Twey> forrest: Then you'll understand :Ã¾
06:57:53 <forrest> lisp and its variants, in particular, have strong advocates
06:58:13 <forrest> I'm working on it!  The report is first, later I will have to give a demo
06:58:26 <forrest> I've already decided to do a rot13 decoder
06:58:47 <Twey> Hm
06:59:01 <forrest> I think I can manage that
06:59:09 * Botje ducks for the inevitable barrage of oneliners
06:59:19 <Twey> It's not a particularly elegant problem domain, but sure
06:59:35 <forrest> to be honest, I was put off of lisp by all the parentheses.  but lispers say ha! that's no reason
06:59:50 <Twey> It's not much of a reason :Ã¾
07:00:13 <Botje> you can write lisp with braces if you want
07:00:54 <forrest> so, i have to give another reason why someone who doesn't have a functional language yet should learn haskell instead of lisp
07:01:10 <Botje> because it's more fun :)
07:01:10 <forrest> s/learn/start with/
07:01:19 <Botje> and because it's hard
07:01:29 <quicksilver> forrest: purity.
07:01:38 <forrest> that kind of goes along with the parens things -- counting parens is less fun
07:01:45 <quicksilver> type checking.
07:01:51 <Ke> forrest: lisp is an abomination
07:02:02 <quicksilver> custom data types which model your problem domain are a powerful tool to help program design and catch bugs.
07:02:15 <Ke> and will incur velociraptor related accidents
07:02:25 <Twey> Laziness!
07:02:30 <forrest> these are better answers.
07:02:35 <forrest> lisp isn't lazy?
07:02:50 <arw> Ke: any weird syntax will incur those accidents
07:03:04 * arw looks at those indent-based languages out there...
07:03:24 <quicksilver> forrest: no, lisp isn't lazy
07:03:29 * dschoepe thinks indentation-based syntax is a good thing
07:03:38 <quicksilver> forrest: impure languages can't easily be lazy
07:04:01 <quicksilver> forrest: I think purity + custom data types are both stronger reasons than laziness though
07:04:06 <quicksilver> more critically, easy to explain reasons
07:04:12 <quicksilver> it's quite hard to explain a strong case for laziness.
07:04:19 <quicksilver> (certainly laziness isn't the reason I use haskell)
07:04:43 <Twey> I like it
07:04:50 <Twey> Laziness really helps code reÃ¼se
07:05:25 <Twey> It's much nicer to pass an infinite list around than to rewrite all the functions that operate on it so they create the list a chunk at a time
07:05:26 <quicksilver> I don't dislike it
07:05:32 <quicksilver> I just don't think it's a key reason for me
07:05:37 <quicksilver> I don't really use infinite lists very often.
07:05:44 <quicksilver> except when showing newbies things in #haskell
07:06:11 <jmcarthur> i use infinite structures a lot
07:06:12 <lambdabot> jmcarthur: You have 1 new message. '/msg lambdabot @messages' to read it.
07:06:20 <eevar2> Twey: there are lisps which support lazy data structures as well
07:06:38 <Twey> Indeed
07:06:43 <Twey> âLispâ isn't a language
07:06:56 <Twey> Heck, we even have Liskell
07:07:00 <chrisdone> being put off by lisp's parantheses is really juvenile. adding to that the fact paren-mode makes writing code in lisp incredibly easy, lisp's syntax is something to be envied
07:07:14 <quicksilver> chrisdone: paredit-mode is the bee's knees
07:07:21 <jmcarthur> Zeiris: public domain library. use it if you want to
07:07:42 <chrisdone> quicksilver: the bee's knees indeed
07:07:53 <Zeiris> jmcarthur, sweet. It was educational even if I don't.
07:08:06 <jmcarthur> i should include a license with it
07:08:07 <forrest> well, this is an interesting page from real world haskell, but it doesn't have haskell vs. other functional languages -- is there some article about that?
07:08:18 <Zeiris> (I learned that there's a whole pile of functions I don't use or know what they're good for :( )
07:08:32 <jmcarthur> Zeiris: ha!
07:08:39 <jmcarthur> always good to learn though
07:09:14 <quicksilver> chrisdone: I actually use it for editing haskell sometimes
07:09:21 <chrisdone> I would also like to see a document directly comparing Haskell to other modern languages in a big range of problems
07:09:22 <quicksilver> chrisdone: mainly when editing nested lists/tuples
07:09:29 <chrisdone> quicksilver: neat!
07:10:06 <jmcarthur> Zeiris: well, you've inspired me to add a license to it. i'll do that at work some time today
07:10:18 <Zeiris> Always a good idea :)
07:10:45 <jmcarthur> it will just be a file saying that the code is public domain
07:11:32 <chrisdone> are there any wikis that present problems and people post solutions in different languages?
07:11:50 <eevar2> chrisdone: google for project euler
07:12:11 <chrisdone> project euler is not accessible without logging in and doing the puzzles, kind of a barrier for entry
07:12:14 <chrisdone> I said WIKI
07:12:50 <chrisdone> the nice thing about a wiki would be other users could come and fix your code if it's a bit sloppy
07:13:00 <chrisdone> so the language comparisons would be that little bit fairer
07:14:13 <freiksenet> there is a project with code snippets for many problems
07:14:18 <freiksenet> in many languages
07:14:22 <freiksenet> forgot the name
07:14:28 <Alpounet> PLEAC
07:14:30 <Alpounet> something like that
07:14:42 <freiksenet> Rosetta code
07:14:54 <freiksenet> http://rosettacode.org/wiki/Main_Page
07:15:22 <Alpounet> http://pleac.sourceforge.net/ too
07:15:24 <nainaide> In Text.XHtml,  h1 "hello" doesn't work but why h1 << "hello" works without  toHtml "hello" ?
07:15:42 <fasta> chrisdone, there are lots of them. Unfortunately, none of them solve interesting problems.
07:15:43 <chrisdone> there's that one about narwals or whatever
07:16:00 <Twey> nainaide: Strings are an instance of Element, I think
07:16:13 <mux> an instance of HTML, IIRC
07:16:21 <Twey> That's the one
07:16:27 <Twey> toHtml is if you don't want to escape it (e.g. to embed strings of literal HTML)
07:16:37 <quicksilver> the overloading in Text.XHtml is slightly inconsistent
07:16:39 <nainaide> if string is a instance of HTML, then h1 "abc" should work
07:16:46 <quicksilver> some operations are overloaded and some aren't
07:17:03 <quicksilver> at least that's how it looked to me last time I was looking over the docs for someone else
07:17:06 <quicksilver> @hoogle h1
07:17:07 <lambdabot> Text.Html h1 :: Html -> Html
07:17:07 <lambdabot> Text.XHtml.Frameset h1 :: Html -> Html
07:17:07 <lambdabot> Text.XHtml.Strict h1 :: Html -> Html
07:17:10 <jmcarthur> i think we need something like the shootout but limited strictly to "idiomatic" code
07:17:21 <quicksilver> yeah, h1 :: Html -> Html, not HTML x => x -> Html
07:17:27 <quicksilver> it's not overloaded.
07:17:40 <chrisdone> quicksilver: yeah that annoys me a bit
07:17:51 <quicksilver> chrisdone: it's just another unfinished combinator library :)
07:17:53 <chrisdone> think I ended up just defining a layer over it
07:18:02 <chrisdone> hehe
07:18:03 <quicksilver> chrisdone: some good ideas, not much field testing or evolution
07:18:15 <quicksilver> some bits work well, some bits only work for certain use cases etc
07:18:31 <chrisdone> I used it for a Real World project and wrote a whole bunch of extra combinators, maybe I should submit them
07:19:20 <Twey> Correct it?
07:19:40 <nainaide> got, thanks you all!
07:19:49 <chrisdone> jmcarthur: yeah that sounds like a great idea
07:21:16 <chrisdone> jmcarthur: judging for elegance/brevity/reusability instead of just speed
07:24:54 <ickane> is haskell compiled to byte code similiar to java and/or python?
07:25:04 <Twey> Itâ¦ can be
07:25:14 <Twey> Most commonly it's compiled to native code, though
07:25:57 <ickane> I guess i'm wondering how its converted to assembly and then even machine code?
07:26:09 <quicksilver> by a compiler
07:26:15 * quicksilver wonders if that isn't quite the answer you wanted.
07:27:25 <ickane> haha
07:28:38 <Jafet> But it's so abstract!
07:29:03 <dolio> It's possible to compile Haskell down to a pretty simple functional language containing mostly just 'let foo = <lambda expression>' for closure creation, and 'case foo of ...' for evaluation.
07:29:31 <dolio> Which has an operational semantics that isn't too hard to translate to an imperative machine.
07:30:02 <quicksilver> ickane: can you ask the question in a way which makes it more clear how detailed an answer you would like?
07:31:07 <ickane> well assembly is so closely paralelled by lower level c ideas, ie function prototypes. I was wondering how haskell is able to present such a different computational modle and still adhere to the proto-C-like restrictions of assembly
07:31:35 <quicksilver> ickane: assembly is not remotely parallelled by C ideas
07:31:38 <ickane> but to be honest while i wrote that out i realized i probably need to understand haskell much more intimately before I can properly ask that question
07:31:45 <quicksilver> ickane: assembly has no restrictions involving function prototypes
07:31:51 <ickane> lables?
07:31:53 <quicksilver> assembly is far, far more flexible than C
07:31:57 <Jafet> Evidently you've never actually done assembly programming
07:32:02 <quicksilver> labels are a trivial convenience
07:32:15 <quicksilver> they're not an important aspect; you could calculate the exact addresses if you wanted to
07:32:22 <quicksilver> (or the relative addresses)
07:32:27 <ickane> Jafet: only 16bit microcontrollers
07:32:34 <ickane> and not very much at that
07:32:54 <quicksilver> but, I suppose you mean the mapping from a functional language to a register machine isn't obvious
07:32:59 <quicksilver> I agree, it's not obvious
07:33:05 <quicksilver> although dolio just gave a very high level sketch
07:33:12 <Jafet> Assembly is being able to run the same code three times with different meanings each time
07:33:19 <quicksilver> there is loads of literature about compilers for functional languages though
07:33:25 <Jafet> By changing the offset of ip
07:33:37 <quicksilver> simon peyton jones' book is one example which is particularly about haskell
07:36:37 <zygoloid> there is something of a correspondence between simple-minded asm function prologues/epilogues and prototypes
07:37:46 <yaxu> > map (+ 1) [1]
07:37:47 <lambdabot>   [2]
07:37:50 <yaxu> > map (- 1) [1]
07:37:51 <lambdabot>   No instance for (GHC.Num.Num (a -> b))
07:37:51 <lambdabot>    arising from a use of syntactic n...
07:37:57 <yaxu> > map (\n -> n - 1) [1]
07:37:58 <lambdabot>   [0]
07:38:02 <zygoloid> in a certain sense, C was designed to be not-too-hard to compile to machine code, whereas i get the impression that was not a significant concern for haskell (rather the opposite -- the language specification encouraged research into implementation techniques)
07:38:14 <yaxu> is there a terser way of writing (\n -> n - 1) ?
07:38:26 <quicksilver> yaxu: (subtract 1)
07:38:27 <zygoloid> subtract 1
07:38:30 <Lemmih> @pl \n -> n - 1
07:38:31 <lambdabot> subtract 1
07:38:36 <zygoloid> @src subtract
07:38:36 <Jafet> :t (- 1)
07:38:36 <lambdabot> subtract x y = y - x
07:38:37 <lambdabot> forall a. (Num a) => a
07:38:50 <yaxu> thanks!
07:38:59 <dolio> > (length "\\n -> n - 1", length "subtract 1")
07:39:00 <lambdabot>   (11,10)
07:39:11 <Twey> It's about elegance, not length :Ã¾
07:39:25 <Jafet> > length "(+-1)"
07:39:26 <lambdabot>   5
07:39:28 <Twey> 'course, if we had significant whitespace we could just write (- 1) an' get bothâ¦
07:39:31 <dolio> Is that what "terse" means now? :)
07:39:50 <zygoloid> > length "let(%)=(-)in(%1)"
07:39:51 <lambdabot>   16
07:39:52 <Twey> dolio: Two tokens instead of six :Ã¾
07:39:53 <zygoloid> :(
07:40:09 <Jafet> > (+-1) 1
07:40:10 <lambdabot>   Not in scope: `+-'
07:40:19 <Twey> Needs a space
07:40:19 <Jafet> > (+ -1) 1
07:40:20 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
07:40:20 <lambdabot>      must have lower prece...
07:40:24 <Twey> Oof
07:40:28 <Jafet> Blooey.
07:40:30 <zygoloid> > (+(-1)) 42
07:40:31 <lambdabot>   41
07:40:39 <zygoloid> length "(+(-1))"
07:40:47 <zygoloid> <lambdabot> 7
07:40:48 <zygoloid> yay
07:42:15 <yaxu> crikey
07:42:25 <Twey> Ych
07:46:15 <quicksilver> Twey: we de have significant whitespace
07:46:18 <quicksilver> Twey: but, if we had more...
07:46:22 <quicksilver> s/de/do/
07:46:32 <jmcarthur> Zeiris: it occurred to me on the way to work that i've got some code in the start package that I can't make public domain. it's technically just library code, but be aware if you start using it. i'll mark things up appropriately in the repo today
07:46:54 <Alpounet> jmcarthur, regarding 'Computation' ?
07:46:57 <Twey> quicksilver: As you say :Ã¾
07:47:04 <jmcarthur> Alpounet: actually that's not in the start package
07:47:06 <jmcarthur> *starter
07:47:32 <Alpounet> oh
07:47:34 <jmcarthur> Alpounet: the starter package i have on patch tag includes a Data.EnumSet file that i ripped from another project on hackage
07:47:39 <Zeiris> Well, as long as it's being used as a library and is clearly marked as such, and there's no license that says you CAN'T use it for some purpose...
07:47:57 <Alpounet> ah okay
07:47:59 <Alpounet> yeah I've read that code
07:49:16 <jmcarthur> actually... it looks like the code i stole from hackage was on the haskell.org wiki first
07:50:41 <Jafet> (If you rewrite it point-free, is it still a derivative work?)
07:50:56 <jmcarthur> haha
07:51:30 <jmcarthur> is it generally assumed that code on the haskell.org wiki is public domain if it doesn't say otherwise, or would that be bad?
07:52:01 <jmcarthur> ah, nevermind
07:52:03 <jmcarthur> http://www.haskell.org/haskellwiki/HaskellWiki:Copyrights
07:52:35 <jmcarthur> Zeiris, Alpounet: good news. it's all public domain
07:53:18 <Alpounet> nice
07:54:02 <jmcarthur> actually, i guess i should still stick that haskell.org license onto EnumSet, but it's as good as public domain as far as i can tell
07:55:33 <jmcarthur> eh, no restriction, i won't botther
07:55:40 <jmcarthur> *bother
08:02:35 <jmcarthur> Zeiris, Alpounet: okay, licensing added. my code is public domain, and i use the license from the wiki for EnumSet
08:02:55 <IceDane> There are no functions for Either as there are for Maybe(fromJust), fromRight, fromLeft?
08:03:06 <Alpounet> jmcarthur, advertise it now :)
08:03:20 <jmcarthur> Alpounet: where?
08:03:30 <Alpounet> planet, whatever
08:03:33 <jmcarthur> i've done it in #googleai, here, and the contest forums
08:03:56 <jmcarthur> i suppose i could do haskell reddit
08:04:03 <jmcarthur> my blog isn't on planet
08:04:13 <Botje> IceDane: there's an either function
08:04:21 <Botje> but there's no fromLeft or fromRight, no.
08:04:39 <Botje> you shouldn't be using those even if they existed, :)
08:04:40 <Alpounet> haskell reddit should be fine :)
08:04:44 <IceDane> Botje: Why not?
08:04:57 <quicksilver> because they're partial
08:05:02 <Botje> big fat exception if you ever get Left where you expected Right and vice versa
08:05:03 <quicksilver> IceDane: almost every use of fromJust is a mistake.
08:05:23 <quicksilver> similar code smell is "if (isJust ...) ..."
08:05:40 <quicksilver> "catLefts" and "catRights" would be useful, though
08:05:45 <quicksilver> however they're easy to write.
08:05:54 <IceDane> So you should be using pattern matching?
08:05:58 <quicksilver> :t \xs -> [x | Left x <- xs]
08:06:00 <lambdabot> forall t t1. [Either t t1] -> [t]
08:06:02 <quicksilver> IceDane: correct.
08:06:06 <jmcarthur> Alpounet: http://www.reddit.com/r/haskell/comments/b2qf7/new_haskell_starter_package_for_the_google_ai/
08:06:09 <quicksilver> IceDane: use pattern matching and handle the Nothing case
08:06:21 <quicksilver> IceDane: (or use 'maybe' which is just a functionalised pattern match)
08:06:26 <IceDane> Alright, cool, thanks.
08:06:50 <Alpounet> nice
08:06:51 <jmcarthur> man, i'm itching to try out the new vector library
08:07:45 <Botje> jmcarthur: that's just the itching powder that comes with all of dons' blog posts
08:07:48 <jmcarthur> i bet it wouldn't go over well on the contest server though
08:08:02 <rovar> hi all, I asked this earlier, but I have a bunch of networked "driver" type apps for database clients, RPC etc. They are all quite similar. They all use Put/Get, forkIO, STM, need to store state, and require extensive error handling/reporting.  I was thinking about making a generic Network.ProtocolClient and ProtocolServer which combine all of these items into a handy monad.  Does anyone know if such a thing already exists?
08:08:07 <jmcarthur> GHC 6.8 and all
08:08:27 <jmcarthur> Botje: yeah, dons blog posts make me itchy
08:08:36 <rovar> I could see them being used for RPC such as HTTP/xml-rpc/BERT etc.. the underlying transport could also be switchable. ..
08:09:23 <fasta> rovar, nobody cares about overly general code. Make something useful first. That it is general is something extra.
08:09:45 <rovar> fasta:  I have two useful apps as such, and they are quite similar.
08:09:52 <fasta> rovar, all these "it could be" things, never happen or someone just writes another library.
08:09:52 <rovar> that is the problem.
08:10:26 <rovar> i also don't see how this is overly general.. that's like saying Network.Socket is overly general.
08:10:38 <fasta> rovar, or in other words: it is pointless to ask here. Just write whatever is the shortest way to express both of your problems.
08:10:52 <fasta> rovar, if that happens to involve a library that you want to put on Hackage, fine.
08:11:02 <fasta> rovar, if not, also fine.
08:11:19 <jmcarthur> wow, it looks like nearly every function in the vector package is annotated with INLINE
08:11:22 <Saizan> fasta: well, it's reasonable to ask if such a thing exists.
08:11:37 <jmcarthur> is that actually still productive?
08:11:40 <rovar> I'm just attempting to abstract out the boilerplate, but this seems like such a common problem, I assumed that someone would have created it already.
08:11:42 <galdor> rovar: network client are really dependent of the problem, i'm not sure you want to generalize them
08:11:54 <quicksilver> although he did ask before and I told him 'No'. Apparently he believes it's possible for quicksilver to be wrong? :)
08:12:05 <Saizan> heresy!
08:12:31 <fasta> quicksilver, well, you can be wrong. I think you were once a few months ago ;)
08:12:43 <quicksilver> fasta: hush. I've had the logs changed.
08:12:57 <jmcarthur> oh apparently some of them are annotated with INLINE_STREAM, which i've never seen before
08:13:19 <quicksilver> jmcarthur: most small things will be inlined anyway but the inlining threshold is a bit opaque
08:13:26 <rovar> quicksilver:  I did ask again, I did actually start working on this code after I asked you. But I was just hoping to ask again when more folks were present, maybe they know of something that hasn't been publicized.
08:13:35 <quicksilver> jmcarthur: and I think it's sensitive to commandline options
08:13:41 <quicksilver> jmcarthur: maybe they didn't want to take the risk?
08:13:47 <Saizan> rovar: take a look at the  Holumbus framework maybe, i'm not sure if it's at the right level of abstraction though
08:13:50 <quicksilver> rovar: I'm not serious.
08:13:51 <jmcarthur> quicksilver: that makes sense i guess
08:14:30 <quicksilver> rovar: I generally agree with fasta's point - it's surprisingly hard to get something sufficiently general and sufficiently abstract in this domain that it will be useful to another project
08:14:35 <Alpounet> jmcarthur, I'll dive into that vector package for hnn as soon as I find some time for it :)
08:14:42 <quicksilver> not impossible, and certainly interesting to try.
08:14:46 <jmcarthur> Alpounet: sweet!
08:15:20 <rovar> I've looked at several RPC client/servers and a couple database drivers, all written by different people, and they seem 80% similar.
08:15:55 <jmcarthur> one thing i'm not 100% happy with is that it looks like you can only index the arrays with Ints
08:16:00 <xerox> http://mathoverflow.net/questions/15435/if-a-category-is-monadic-is-it-necessarily-so-in-a-unique-manner
08:16:05 <jmcarthur> but that would be a simple thing to add on top i guess
08:16:15 <Saizan> extrapolating from a bunch of specific implementations is much easier than coming up with an API from scratch
08:16:52 <jmcarthur> oh wait, Data.Vector.Generic
08:16:54 <jmcarthur> awesome
08:17:01 <Saizan> so i'd be optimistic
08:17:36 <jmcarthur> oh i misread what Data.Vector.Generic does
08:17:38 <jmcarthur> nevermind
08:17:46 <jmcarthur> but yeah, it's easy to add on top
08:18:45 <rovar> so let me try for some more specific bits.  I would reckon that each driver would need a combination of STM protected state, error handling, and IO.  The closest thing I've found that achieves that is Dons' "Programmable Semicolons" entry
08:19:01 <jmcarthur> i'm also pleased to see that DPH is going to have a more familiar interface like this
08:19:10 <jmcarthur> or at least that's what i hear
08:19:20 <rovar> that seems like a common thing to need, anyone else know of similar constructs in hackage?
08:20:45 <Arnar> can I ask quickcheck to generate an infinite list?
08:20:57 <Saizan> if you add persistence that sounds a bit like happstack-state
08:21:10 <jmcarthur> Arnar: no, but you can use lazysmallcheck for some things like that
08:21:40 <Arnar> jmcarthur: ok.. thanks!
08:21:55 <Arnar> jmcarthur: I can cheat and do cycle (vectorOf 1000)
08:22:23 <Alpounet> jmcarthur, you're on twitter too now heh
08:22:24 <jmcarthur> Arnar: the reason it works is because lazysmallcheck will generate some of it and then make the rest _|_, and if the test passes for that then it would pass for anything else in place of the _|_
08:22:27 <Alpounet> (I mean your package)
08:22:34 <jmcarthur> Alpounet: ha
08:22:41 <jmcarthur> didn't think about that happening
08:22:49 <Alpounet> that's nice
08:22:58 <Alpounet> it enforces the presence of haskell on that contest
08:23:31 <Arnar> J-Mad: ah
08:23:32 <rovar> huh
08:23:34 <Arnar> sorry
08:23:44 <Arnar> jmcarthur: meant for you ^^
08:29:51 <b0fh_ua> Hi there! I've created simple program to query same HTTP page as different users. http://pastebin.com/d469a1b30
08:30:10 <b0fh_ua> with this program I am getting the error: ghc: NetworkziCurlziEasy_dg1j: interrupted
08:30:14 <b0fh_ua> what did I miss there?
08:30:54 <b0fh_ua> with iteration over getChanContents list program never finishes, seems like it waits for new data in channel
08:34:44 <Botje> b0fh_ua: aren't you better off reading (length credentials) times?
08:35:24 <Botje> b0fh_ua: also, Left in Either usually signals an error, whereas Right usually signals success .-
08:36:17 <quicksilver> b0fh_ua: never use getChanContents
08:36:28 <quicksilver> it is broken by design.
08:36:35 <b0fh_ua> Botje: that's good idea
08:36:44 <b0fh_ua> quicksilver: i see
08:36:50 <uorygl> > 10.0 * 10.0 == 1.0 * 100.0
08:36:51 <lambdabot>   True
08:37:05 <uorygl> > 100.0 * 100.0 == 10.0 * 1000.0
08:37:06 <lambdabot>   True
08:37:25 <uorygl> > pi
08:37:26 <lambdabot>   3.141592653589793
08:40:28 <freiksenet> I am using this AI challenge as a good way to learn haskell, and I am doing a flood fill algorithm to get available free spaces for a position. Other languages will just have a global state with current colored and uncolored tiles of the map, how can I do it without a global state?
08:40:49 <freiksenet> availableSpace :: Board -> Tile -> Int
08:40:49 <freiksenet> availableSpace board tile = foldl (+) (map (\ x -> availableSpace board x) (validMoves board tile)
08:41:04 <freiksenet> I have this stuff now, but it will recourse indefinetely.
08:41:16 <freiksenet> (and I have some syntax errors there)
08:41:28 <uorygl> You have an unmatched parenthesis.
08:41:43 <Botje> freiksenet: maintain a set of seen squares
08:41:45 * hackagebot upload: uulib 0.9.11 - Haskell Utrecht Tools Library (DoaitseSwierstra)
08:41:59 <freiksenet> Botje: could you elaborate?
08:42:34 <uorygl> A recursive function can "hang onto" a value by passing the value to itself.
08:42:38 <uorygl> To the function, I mean.
08:43:02 <uorygl> An example: f x = f (x+1). This function "stores" a value x and repeatedly adds 1 to it.
08:43:33 <Botje> availableSpace board (tile:tiles) seen = if (not $ tile `elem` seen) then ... availableSpace tiles (insert tile seen) else ... availableSpace tiles seen
08:43:36 <freiksenet> okay. so something like (availableSpace board x x:oldList)
08:43:38 <Botje> very roughly :)
08:44:01 <IceDane> @src asks - can I assume that ask just returns the state?
08:44:01 <lambdabot> Source not found. Just try something else.
08:44:04 <IceDane> eh
08:44:06 <IceDane> @src asks
08:44:06 <lambdabot> asks f = do
08:44:06 <lambdabot>     r <- ask
08:44:06 <lambdabot>     return (f r)
08:44:17 <freiksenet> Botje: oh, cool. thanks
08:44:54 <Botje> you might want to use a Data.Set.Set instead of a list
08:47:15 <Beelsebob> so asks is fmap in yet another name?
08:47:33 <doserj> asks = (<$>ask)
08:47:47 <Beelsebob> idd
08:47:51 <uorygl> @type asks
08:47:52 <lambdabot> forall r a (m :: * -> *). (MonadReader r m) => (r -> a) -> m a
08:50:05 <jmcarthur> huh, it actually looks like asks is the same as the Reader constructor
08:50:12 <jmcarthur> i didn't think of it like that before
08:50:23 <jmcarthur> of course it works on any MonadReader instead of just Reader
08:50:41 <jmcarthur> :t Reader
08:50:42 <lambdabot> forall r a. (r -> a) -> Reader r a
08:51:37 <Botje> :t asks (+1)
08:51:38 <lambdabot> forall r (m :: * -> *). (Num r, MonadReader r m) => m r
08:51:39 <benmachine> asks f = fmap f ask, and ask = Reader id
08:52:09 <jmcarthur> asks = Reader, and ask = asks id
08:52:17 <benmachine> if you like :P
08:52:24 <jmcarthur> it's shorter :P
08:53:31 <MissPiggy> :t Reader
08:53:32 <lambdabot> forall r a. (r -> a) -> Reader r a
08:55:25 <mreh> I'm finding it hard to get how signal functions are Arrows
08:56:17 <uorygl> What are signal functions?
08:56:41 <mreh> oh, they're a concept from yampa, functional reactive programming
08:56:48 <Beelsebob> they're functions that work in signals, i.e. functions that work on time varying values
08:56:54 <mreh> they're a function: Time -> Signals
08:57:07 <mreh> Beelsebob: they're a function of time
08:57:17 <mreh> oh, sorry
08:57:36 <mreh> ah, conal has arrived! He can explain how signal functions are Arrows!
08:57:44 <mreh> if he's not too busy
08:57:51 <Beelsebob> he might just slap you for complicating FRP though :P
08:57:54 <uorygl> I still don't know what signal functions are.
08:58:13 <conal> i can try helping.
08:58:27 <mreh> they're just functions, but they have the type Time -> Signal
08:58:29 <uorygl> A function Signal a -> Signal b, where Signal a is a time-varying signal of type a?
08:58:44 <conal> uorygl: yeah.  that's the semantic model.
08:58:53 <mreh> maybe I don't understand the basics yet!
08:58:58 <conal> uorygl: or "mental model".  the impl may differ.
08:59:04 <uorygl> mreh: yeah, it kind of sounds like you don't know what they are either.
08:59:09 <conal> and that's one model of frp.
08:59:39 <mreh> I'm reading about yampa, but some people criticise it for lacking any kind of denotation semantics
09:00:25 <conal> mreh: there's a simple & precise denotational semantics for arrow-frp -- the one uorygl gave.  first appeared in "genuinely functional user interfaces" (iirc)
09:00:39 <MissPiggy> "signal functions are Arrows!" haha now I see
09:00:40 <conal> however, yampa may have strayed from it.
09:01:27 <conal> MissPiggy: nit-pick (to prevent possible confusion): "the type of signal functions *is* an arrow"
09:01:51 <mreh> i.e. SF a b is an Arrow?
09:01:59 <conal> MissPiggy: probably what you meant.  but i see so much confusion.
09:02:05 <conal> mreh.  almost.  SF is an Arrow
09:02:16 <conal> mreh like (->) is an arrow
09:02:19 <MissPiggy> conal I just copy pasted what someone else said
09:02:47 <conal> MissPiggy: i bet.  that confusion is rampant.  like "lists are monads"
09:03:29 <mreh> this is a very abstract topic afterall
09:03:47 <mreh> hmm, I didn't really understand arrows it seems
09:04:05 <conal> mreh: frp isn't really abstract.  it's just that some abstract notions happen to apply nicely to frp.
09:04:24 <mreh> I see an Arrow as an abstract black box, something of type a goes in, something of type b comes out
09:04:44 <conal> mreh: eep.  an arrow isn't anything.
09:05:02 <conal> mreh: in general.  nothing more than a binary type constructor with a signature pattern and some laws.
09:05:02 * Twey doesn't understand arrows.  â¹
09:05:21 <conal> Twey: do you mean you don't understand *any* arrow?
09:05:35 <Twey> conal: Not really
09:05:42 <Twey> I *know* them, but I don't grok them
09:05:44 <benmachine> you can understand every individual arrow without understanding the notion of arrows
09:05:51 <Twey> I can't look at something and say âoh, this is an arrowâ
09:06:01 <quicksilver> "nothing more than...."
09:06:06 <quicksilver> well those things are quite a lot, actually.
09:06:07 <conal> Twey: do you understand groups (or fields, or rings, or monoids, or ...)?
09:06:12 <quicksilver> An arrow is something with a notion of composition.
09:06:19 <Twey> conal: Monoids, maybe :Ã¾
09:06:21 <quicksilver> and something which somehow "contains" functions
09:06:33 <quicksilver> in a way compatible with the obvious notion of composition on functions.
09:06:42 <conal> the notions that type classes capture are very abstract.  that's what makes them powerful.
09:06:49 <mreh> surely an Arrow is *something* in the abstract
09:06:49 <Twey> conal: Aye
09:06:52 <conal> but they're usually unnecessary.
09:07:03 <MissPiggy>  I just learned a much mor elegant way to divide complex numbers than teh usual one
09:07:10 <benmachine> what is the usual one
09:07:16 <conal> mreh: *each* arrow is something
09:07:24 <MissPiggy> well okay it's exactly the same as the usual one
09:07:27 <conal> people confuse themselves by trying to "understand monads" or "understand arrows"
09:07:28 <benmachine> awesome
09:07:32 <Twey> Yeah, I guess
09:07:36 <MissPiggy> but it's written better
09:07:41 <uorygl> MissPiggy: a more elegant method of performing the same operation?
09:07:44 <mreh> so what are the laws of Arrows?
09:07:45 <MissPiggy> yes
09:07:58 <IceDane> @books
09:07:59 <lambdabot> Unknown command, try @list
09:08:08 <uorygl> Something is an arrow if it has serial composition, parallel composition, and lifting!
09:08:11 * uorygl coughs.
09:08:13 <conal> instead, get to understand each concrete instance.  the commonalities will follow.
09:08:24 <IceDane> What good books were recommended except RWH?
09:08:28 <mreh> I see, there is no spoon
09:08:30 <benmachine> there aren't really that many arrows though
09:08:38 <benmachine> the only standard non-> one is Kleisli
09:08:42 <MissPiggy> instead of going 1/(a+ib) and multiply both sides bit the conjugate then solving a system -- you go N(a+ib)=a^2+b^2, so N(z)=z*z^bar <=> z^-1 = z^bar/N(z)
09:08:51 <benmachine> there are loads of monads to look at
09:08:53 <conal> ben: there are probably infinitely many arrows
09:09:12 <conal> benmachine: ^^
09:09:23 <uorygl> newtype Foo a b = Foo Integer
09:09:25 <benmachine> conal: okay, but I think it was proved that there were infinitely many transcendental numbers before anyone actually found one :P
09:09:37 <uorygl> Foo can be made an instance of Arrow in infinitely many ways!
09:09:41 <benmachine> (may be nonsense, but I remember something like that being true)
09:09:45 <conal> benmachine: oh, maybe you meant there aren't a lot of arrows in the popular FP literature.
09:09:45 <Twey> benmachine: Lots of things use them
09:09:56 <Twey> Yeah, they're a bit obscure
09:09:58 * cons sets out to confuse more people :)
09:10:00 <quicksilver> it's quite hard to come up with interesting non-kleisli arrows
09:10:03 <benmachine> conal: I just mean I personally haven't seen many arrows
09:10:08 <Twey> If only Cale would write an arrow tutorialâ¦ :Ã¾
09:10:11 <conal> benmachine: ah.  got it.  thx.
09:10:15 <uorygl> What's the Kleisli arrow? a -> m b?
09:10:20 <Saizan> yes
09:10:30 <Saizan> Monad m => that
09:10:31 * uorygl tries to come up with another interesting arrow.
09:10:33 <mreh> :t (>>>)
09:10:33 <quicksilver> the connection with applicatives is strong, too.
09:10:34 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
09:10:34 <Twey> benmachine: (->), Kleisli, HXT, Yampa
09:10:49 <mreh> :t (>=>)
09:10:50 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:10:55 <quicksilver> All arrows are applicatives
09:10:55 <conal> i use arrows in tangible functional programming.
09:11:07 <quicksilver> and all composable (categories) which are applicative are arrows
09:11:23 <benmachine> I remember listening to quicksilver talking about this and thinking oh that's interesting and then forgetting all of it
09:11:25 <conal> to generate UIs, types, code, and values.
09:11:52 <uorygl> I think I'm coming up with an idea.
09:11:54 <conal> it sometimes takes a while for abstractions to find applications.
09:12:22 <conal> oh -- another example: Comonad.  Nifty & useful examples are emerging.
09:12:24 <mreh> are we going to call Haskell "abstraction oriented" programming then? It needs a gimmick
09:12:34 <quicksilver> conal: IIRC tangible values aren't arrows?
09:12:37 <Twey> mreh: I like it :Ã¾
09:12:39 <quicksilver> conal: just categories.
09:12:45 <conal> quicksilver: yeah.
09:12:49 <lispy> mreh: I think we should call it fun programming :)
09:12:53 <conal> quicksilver: both less and more than Arrow.
09:13:16 <conal> lispy: i have a library with Data.Fun
09:13:24 <lispy> conal: hah, nice
09:13:28 <conal> :)
09:13:30 <mreh> when I saw the code for the Frag game, my jaw hit the floor, it's amazingly powerful abstraction, I just wish I grok it
09:13:53 <conal> mreh: okay.  my guess is that you're not tripping over arrow as much as arrow-frp.
09:14:07 <conal> mreh: ie the type rather than the type class.
09:14:11 <monochrom> Haskell is type-driven abstraction-oriented intelligent-design programming.
09:14:15 <mreh> conal: quite likely
09:14:23 <benmachine> when I saw frag's code I saw much more code than type signatures, and I disapproved :P
09:14:30 <conal> mreh: similarly for folks who struggle with IO and think they're trying to "understand monads"
09:14:40 <mreh> i've used >=> quite comfortably, and use the -> Arrow all the time
09:14:40 <benmachine> but that is because I was trying to edit it without having to also understand it
09:14:43 <pikhq> Huh. I think I managed to get GCC to perform stream analysis on some C code without meaning to.
09:15:19 <mreh> conal: for two days i thought monads were IO, all this talk of impure code
09:15:30 <lispy> monochrom: Intelligence Oriented Design?  IOP?
09:15:44 <sizur_> What kind of morphism is filter?
09:15:48 <uorygl> newtype Warrow a b = Warrow {unWarrow :: Either a b -> Either b a}
09:15:49 <conal> mreh: yeah.  that's the misunderstanding the all this monad obsession perpetuates.
09:15:49 <monochrom> No, I like the term Intelligent Design as-is.
09:16:02 <lispy> sizur_: surjective?
09:16:08 <uorygl> No, I don't think that works.
09:16:35 <conal> so here's the deal with frp and these abstractions.  first came the semantic/mental model--functions of time--with a vocab (combinator lib) to manipulate them.
09:16:38 <uorygl> So what is this Frag game?
09:16:40 <pikhq> (you know you're bored when you're writing up some immutable data structures in C and wondering if you're going to use them for something. XD)
09:16:45 <uorygl> It sounds awesome.
09:16:55 <lispy> uorygl: cabal instal frog
09:17:02 <uorygl> I enjoy trying to hunt for things I can't understand. >.>
09:17:03 <mreh> uorygl, it's on hackage
09:17:04 <lispy> uorygl: it's Quake3 in pure Haskell
09:17:17 <conal> then much later i realized that the frp notions fit into some some standard patterns (type classes).
09:17:18 <mreh> preview on youtube
09:17:20 <benmachine> has it actually been updated to new GL yet
09:17:27 <mreh> @google frag haskell youtube
09:17:28 <lambdabot> http://www.youtube.com/watch?v=0jYdu2u8gAU
09:17:28 <lambdabot> Title: YouTube - Frag - 3D FPS game written in Haskell
09:17:35 <sizur_> Lispy: thanks
09:17:36 * benmachine suspects not
09:17:37 <uorygl> So, I guess I just have to, uh, get cabal.
09:17:38 <conal> which meant some invented names could be replaced by common ones.
09:18:02 <mreh> conal: i'm listening
09:18:07 <conal> :)
09:18:09 <lispy> sizur_: hehe, I don't actually know if what I suggested is a good answer to that question.
09:18:27 * uorygl first tries to pretend that he's using Linux.
09:18:52 <conal> moreover, using the common patterns (Functor, Applicative, Monoid etc), i could verify that the semantics of frp is well-behaved.
09:19:21 <conal> as captured in the notion of "type class morphism" (TCM).  informally, TCM just means no abstraction leak.
09:19:32 <uorygl> Let's see if I can successfully install Cabal under Mac OS X.
09:19:53 <lispy> uorygl: which version of GHC do you have installed?
09:19:54 <freiksenet> back to my flood fill thingie. here is my function that gets list of all available squares, it doesn't compile for some reason
09:19:56 <freiksenet> availableSpace :: Board -> Tile -> [Tile] -> Int
09:19:56 <freiksenet> availableSpace board tile seen = foldl (\ seen x -> availableSpace board x tile:seen) (filter (\ x -> x `elem` seen) (validMoves board tile)) []
09:20:06 <uorygl> It's a certified Unix system, so if Cabal doesn't install, it's Cabal's fault. :P
09:20:08 <quicksilver> freiksenet: if it's more than one line, use  paste bin
09:20:14 <freiksenet> quicksilver: ok, sorry
09:20:14 <uorygl> lispy: you're implying that I should install GHC first.
09:20:26 <benmachine> freiksenet: if you could include the build error in a comment that'd be handy
09:20:38 <lispy> uorygl: indeed.  So, what version of OSX is this?  Snow Leopard?
09:20:46 <conal> but when you read about frp (classic-style or arrow-style), you don't have to "understand" the type classes in general.  just focus on frp.  similarly for other types.  Eg understand numbers without understanding various monoids.
09:20:50 <Saizan> freiksenet: s/tile:seen/(tile:seen)/ i suspect
09:20:58 <conal> oops.  i mean without understanding Monoid in general.
09:21:09 <freiksenet> just a momemnt
09:21:17 <uorygl> lispy: yeah.
09:21:29 <uorygl> I'm looking at the Haskell Wiki page about OS X.
09:21:31 <conal> if you insist on understanding field theory before you play with numbers, you'd have a hard time.
09:21:43 <benmachine> is 6.12 required for snow leopard?
09:21:50 <lispy> uorygl: okay.  That makes things slightly trickier.  Normally, I'd say install the Haskell Platform to get your GHC.  But yeah, follow the wiki page :)
09:22:12 <lispy> benmachine: not required, but it may be a bit easier for a beginner to install
09:22:14 <conal> uorygl: url for osx haskell page?
09:22:21 <conal> uorygl: i have the same question.
09:22:22 <mreh> conal: okay, it all sounds very zen
09:22:22 <uorygl> conal: http://www.haskell.org/haskellwiki/Mac_OS_X
09:22:27 <conal> uorygl: thx!
09:22:36 <lispy> benmachine: 6.10.x requires a post install step to make it handle the 64bit GCC
09:22:43 <uorygl> Hmm. "GHC generates 32bit code, but gcc on Snow Leopard defaults to 64bit code on machines with processors that support it."
09:22:46 <benmachine> oh right
09:22:51 <conal> is the Haskell Platform available for 6.12 on os x yet?
09:22:55 <uorygl> So GHC generates platform-specific C?
09:23:04 <freiksenet> Saizan: doesn't works
09:23:05 <freiksenet> https://gist.github.com/0c5eacd7baf2210ce812
09:23:09 <merijn> uorygl: I installed the Haskell Platform without problems on OS X.
09:23:18 <Saizan> conal: no haskell platform for 6.12 yet
09:23:21 <lispy> conal: I think 6.12 + Haskell Platform is scheduled to exist around the time of ZuriHac
09:23:38 <conal> lispy: oh!  when is ZuriHac?
09:23:47 <quicksilver> uorygl: GHC doesn't typically generate C
09:23:53 <lispy> conal: mid to late March
09:23:56 <conal> i hear that unamb works much better in 6.12.
09:24:03 <conal> lispy: cool.  thx.
09:24:09 <lispy> conal: np :)
09:24:13 <uorygl> When it does generate C, is it 32-bit-only C?
09:24:15 <conal> i'm also looking forward to tuple sections.
09:24:28 <conal> any other wonderful features of 6.12?
09:24:34 <merijn> uorygl: No such thing, C isn't inherently 32 or 64 bit
09:24:36 <benmachine> I think DeriveFunctor is pretty clever
09:24:47 <merijn> uorygl: So it depends on your C compiler
09:24:47 <Saizan> DeriveTraversable ftw
09:24:53 <benmachine> I wondered about that
09:24:56 <conal> sweet!
09:25:04 <uorygl> merijn: isn't code that assumes 2^32 = 0 32-bit-only?
09:25:07 <benmachine> surely there is more than one way of traversing a structure?
09:25:20 <merijn> uorygl: Yeah, but that's code and you should be shot if you write that
09:25:20 <benmachine> I can accept the idea of only one possible Functor instance
09:25:30 <benmachine> but Traversable and Foldable surprise me
09:25:39 <uorygl> merijn: my question is whether GHC generates shoot-worthy code, then.
09:25:41 <merijn> uorygl: As there is no guarantee on how big an int is. There's only a minimum size guarantee, no exact size
09:25:57 <conal> will 6.12 generate working 64-bit code for os x?
09:26:15 <quicksilver> uorygl: that's not the reason for the 32/64 bit problems
09:26:18 <tromp> :2^32:: Word32
09:26:25 <uorygl> quicksilver: oh? What is the reason?
09:26:27 <tromp> > 2^32:: Word32
09:26:28 <lambdabot>   0
09:26:30 <quicksilver> uorygl: (32 bit specific C or otherwise)
09:26:34 <quicksilver> it's boring linker problems
09:26:46 <uorygl> That sounds boring.
09:26:47 <tromp> > 2^32:: Int64
09:26:48 <lambdabot>   4294967296
09:26:51 <quicksilver> parts of GHC are written *in* C
09:26:58 <Twey> Still?
09:27:00 <mreh> > 2^32 - 1 :: Int32
09:27:00 <quicksilver> most of GHC is written in haskell
09:27:01 <lambdabot>   -1
09:27:03 <quicksilver> Twey: always.
09:27:04 <freiksenet> so, any idea why my code didn't run? I am kinda puzzled, cause I don't get where GHC gets int from :/
09:27:05 <mreh> hmm
09:27:06 <benmachine> the RTS I think
09:27:16 <quicksilver> parts are written in Cmm
09:27:19 <benmachine> it'd be a little odd to write the RTS in haskell
09:27:22 <quicksilver> the three parts all have to link together.
09:27:36 <Twey> benmachine: Why?
09:27:40 <quicksilver> so you need a compiler/linker infrastructure for C which is compatible with the one you have for haskell
09:27:43 <Twey> What do you think the C RTS is written in?  :Ã¾
09:27:48 <Saizan> http://hackage.haskell.org/trac/ghc/ticket/2965
09:27:50 <benmachine> technicality >_>
09:27:51 <MissPiggy> conal, might just be me lacking some flag or whatever, but I don't get a 64 bit compile from ghc
09:27:55 <uorygl> Twey: let me look that up.
09:27:57 <quicksilver> some parts of the C RTS are written in assembly language.
09:28:01 <Berengal> benmachine: It's a compiler. It can just compile the RTS
09:28:16 <uorygl> Twey: the C RTS is written in C.
09:28:19 <conal> MissPiggy: i guess it'll happen eventually.
09:28:24 <benmachine> would the RTS collect its own garbage
09:28:34 <benmachine> that would make sense I suppose
09:28:46 <uorygl> And it doesn't need an RTS because it's too cool for that.
09:28:52 <merijn> freiksenet: The fact it's complaining about int vs inferred time [Tile] means you told the compiler (via the type annotation) that you were gonna give it a [Tile], while you're actually giving it an int instead. Hence it complains and is calling you a liar
09:29:07 <|Jedai|> Still if it was written in Haskell it would have to be compiled by an Haskell compiler that don't need this RTS otherwise you have a circularity problem
09:29:13 <Berengal> benmachine: The RTS is the thing that generates the garbage in the first place. There usually aren't explicit allocations in the haskell code
09:29:28 <Saizan> freiksenet: if the result of your foldl has to be an Int as the type signature says, that means that the accumulator is an Int too, so seen :: Int
09:29:31 <merijn> |Jedai|: You'd first have to write a haskell compiler in something other then haskell, yes.
09:29:35 <uorygl> f x = f (3:x)
09:29:41 <Berengal> merijn: Or interpreter
09:29:41 <|Jedai|> merijn: Well no
09:29:42 <uorygl> That looks like an explicit allocation to me!
09:29:50 <merijn> |Jedai|: But that holds for any compiler
09:29:53 <benmachine> it doesn't need to be a very good haskell compiler though
09:29:57 <benmachine> just good enough to compile GHC :P
09:30:03 <freiksenet> Saizan: oh, now I see. that it stupid, I haven't modified the signature when I modified the function
09:30:07 <freiksenet> is*
09:30:11 <freiksenet> Saizan: thanks a lot
09:30:20 <merijn> Berengal: If you wrote an interpreter in something other then haskell you couldn't compile the haskell compiler to native code (since it's an interpreter, not a compiler)
09:30:22 <pikhq> uorygl: I see no malloc.
09:30:22 <|Jedai|> merijn: you already have one. What I meant to say is that you would need to write another compiler that wouldn't use the GHC RTS
09:30:23 <Berengal> uorygl: Doesn't have to be an allocation. There's nothing anywhere saying it can't not be an allocation
09:30:24 <Saizan> freiksenet: np
09:30:24 <conal> pure FP eats circularity for breakfast.
09:30:29 <Berengal> merijn: Why not?
09:30:30 <pikhq> uorygl: I see a graph.
09:30:48 <MissPiggy> http://en.wikipedia.org/wiki/E8_%28mathematics%29
09:30:50 <MissPiggy> this is nice
09:30:58 <benmachine> merijn: interpret the compiler to compile itself wooo
09:31:01 <merijn> Berengal: Oh, I suppose you could run the haskell compiler in the interpreter to compile the compiler. I stand corrected
09:31:04 <|Jedai|> merijn: we could write this other compiler in any language, Haskell is already bootstrapped
09:31:24 <Berengal> merijn: You have an haskell interpreter that runs, and a haskell compiler written in haskell. Just interpret the compiler code and give it itself as input. The compiled compiler is the output
09:31:30 <pikhq> benmachine: Compiling GHC *probably* requires a rather good compiler.
09:31:32 <uorygl> MissPiggy: have you figured out what E8 actually is and why it's important yet?
09:31:37 <pikhq> At least in terms of language support.
09:31:42 <MissPiggy> uorygl, what lol
09:31:52 <pikhq> Not necessarily in terms of analysis & optimisation.
09:31:57 <MissPiggy> I a mjust looking at the pictures
09:32:08 <benmachine> pikhq: I guess so
09:32:25 <benmachine> but yeah, optimisation would be semi-optional
09:32:29 <|Jedai|> pikhq: Well, to be honest, compiling GHC now almost require GHC, its code use some low-level extension that are very GHC-specific
09:33:03 <benmachine> it does have bootstrapping mechanisms though doesn't it?
09:33:06 <pikhq> |Jedai|: So, it'd require a compiler with very good GHC support.
09:33:12 <benmachine> it is compiled in several stages
09:33:25 <|Jedai|> though that's only a small portion of GHC, maybe it could be rewritten otherwise
09:33:29 <merijn> benmachine: It has to, I can compile GHC on freebsd from scratch
09:33:39 <|Jedai|> benmachine: True
09:33:53 <quicksilver> the normal bootstrap involves a binary of an older GHC
09:34:05 <merijn> benmachine: It first compiles a compiler from (I suppose) C, then compiles GHC from haskell
09:34:15 <quicksilver> if merijn means the freebsd ports bootstrap, I'm pretty sure that's the binary bootstrap
09:34:21 <merijn> quicksilver: Really?
09:34:25 <quicksilver> the purely source bootstrap hasn't worked since 6.4 (?)
09:34:26 <|Jedai|> merijn: Really,
09:34:32 <quicksilver> so you first have to source-bootstrap 6.4
09:34:38 <quicksilver> and then use that to binary bootstrap 6.8
09:34:40 <mux> merijn: I can confirm that
09:34:41 <merijn> I'm disappointed in ports now
09:34:44 <quicksilver> and then use that to binary bootstrap 6.12, IIRC
09:34:50 <benmachine> heh
09:34:54 <quicksilver> possibly you can go 6.4->6.10->6.12
09:35:28 <mux> merijn: see this URL (from the Makefile): http://www.autistici.org/jacula/FreeBSD/
09:35:29 <|Jedai|> If i remember correctly, the only way to bootstrap on a new architecture is to use a cross-platform compiler to compile the C output from GHC
09:35:32 <quicksilver> the purely source bootstrap works by keep around a bunch of C files which have been compiled from haskell
09:35:33 <mux> that's where the binaries are taken from
09:35:47 <quicksilver> |Jedai|: yes, but the C output hasn't worked properly, for this purpose, since 6.4
09:35:52 <|Jedai|> Of course, it don't work very well now
09:36:10 <quicksilver> I think fixing the pure source bootstrap is on the todo list for 6.14
09:36:11 <Polarina> Why hasn't the C output worked very well?
09:36:16 <quicksilver> because it got broken ;)
09:36:24 <Polarina> Define "broken".
09:36:27 <|Jedai|> quicksilver: Right, but if it ever was to be done it would be this way from what I understand
09:36:35 <c_wraith> hmm.  One of my programs is growing in size, and I don't think it should be.  What are my tools for figuring out why?
09:36:48 * benmachine wonders if GHC binaries detect when they are compiling GHC and secretly inject GHC-detection code
09:36:53 <lispy> c_wraith: chapter 25 (or is it 26) of real-world haskell
09:37:01 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/1346
09:37:12 <quicksilver> looks like they *did* get the fix into 6.12.1
09:37:20 <quicksilver> so it does work again now, or should.
09:37:30 <quicksilver> c_wraith: heap profiling.
09:37:47 <lispy> c_wraith: that's the best explanation of the tools I know of.  Basically, you want to look at using ghc's profiler.  Start with heap (-hc) or retainer profiling (-hr).  use hp2ps -c foo.hp to get a nice graph
09:38:07 <benmachine> quicksilver: http://hackage.haskell.org/trac/ghc/ticket/3472
09:38:55 <quicksilver> benmachine: that says cross-bootstrapping isn't working
09:39:02 <quicksilver> benmachine: not quite the same as boostrapping at all.
09:39:04 <benmachine> oh okay
09:39:14 <quicksilver> ticket 1346 suggests plain bootstrapping is now working
09:39:22 <MissPiggy> apparently it has applications in physics
09:39:33 <ksf> haskell sucks
09:39:36 <ksf> it's just too slow
09:39:40 <ksf> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21048#a21048
09:39:55 <chrissbx> Why is this invalid?: let a:b = a + b in  1 :2
09:39:57 <ksf> additionally, hpaste sucks. it doesn't understand package imports
09:39:58 <merijn> btw, arbitrary question, is it possible for haskell to run out of memory when trying to allocate data structures? If so, what happens?
09:40:11 <MissPiggy> ksf did you want a book on that theorem about diophatine sets
09:40:19 <ksf> er no
09:40:28 <benmachine> chrissbx: are you trying to use 2 as a list there?
09:40:32 <quicksilver> chrissbx: (:) is magic, you can't override it
09:40:34 <aavogt> chrissbx: write a Num instance for []
09:40:36 <benmachine> oh
09:40:37 <quicksilver> chrissbx: shame, really.
09:40:38 <benmachine> I see
09:40:38 <rovar> cabal: internal error: impossible
09:40:39 <MissPiggy> CPS convert you data types itll go faster probably
09:40:40 <benmachine> yes
09:40:41 <rovar> hahaha
09:40:51 <benmachine> well, even if it wasn't magic it'd still be a constructor
09:40:58 <lispy> > let (:) a b = a + b in (:) 1 2
09:40:58 <|Jedai|> merijn: Well that depends on your OS, and of course its possible
09:40:59 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
09:41:06 <quicksilver> benmachine: true.
09:41:13 <ksf> sincerely though, I'd like someone to explain to me, in simple and clear words, why my code gets abysmally slow if I feed the parser more and more spaces like in "foo        ,          ,      bar\n"
09:41:15 <|Jedai|> merijn: after all we still don't have infinite memory computer
09:41:31 <benmachine> chrissbx: operators beginning with : can't be functinos
09:41:33 <benmachine> functions
09:41:49 <benmachine> they are like names beginning with a capital letter
09:42:03 <chrissbx> aha constructors
09:42:15 <benmachine> yes
09:42:22 <chrissbx> d'oh.
09:42:24 <benmachine> @src Complex
09:42:24 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
09:42:28 <lispy> ksf: what is this line? import "mtl" Control.Monad.Identity
09:42:35 <lispy> ksf: that looks like a typo?
09:42:39 <merijn> |Jedai|: Well, yeah I know it's possible, but I have no clue how haskell allocates memory so in normal use does that happen in any situation other then exhausting all RAM + swap?
09:42:49 <ksf> lispy, it's a package-qualified import
09:42:49 <Berengal> lispy: package import
09:43:02 <MissPiggy> noo
09:43:05 <Berengal> Useful mainly for mtl/transformers
09:43:07 <lispy> I've never seen that syntax before
09:43:10 <MissPiggy> I am have more cabal problems :/ haskell98-1.0.1.1-0fdaf3b26bc38c43ce8371edf538dbf6
09:43:13 <benmachine> it's a rare extension
09:43:15 <Berengal> (or was that monads-fd?)
09:43:27 <MissPiggy>     ListLike-1.0.1-49bb34054169106051cc1f022810a42c is unusable due to missing or recursive dependencies:
09:43:30 <MissPiggy> really
09:43:38 <sportplusbr> www.pt-br.justin.tv/sportplusbr => [17:30] UEFA CHAMPIONS LEAGUE: MILAN X MANCHESTER UNITED (OITAVAS DE FINAIS) AO VIVO
09:43:45 --- mode: ChanServ set +o quicksilver
09:43:45 <ksf> MissPiggy, -v or stay confused
09:43:48 <zygoloid> ksf: looks like the problem is: hash p = ... many pLWS ... = ... many (some (anyOf " \9")) ...
09:43:50 <lispy> ksf: Which function is the entry point?
09:43:54 --- mode: quicksilver set -o quicksilver
09:44:10 <ksf> test, dbgParse or dbgParseI, as you like
09:44:11 <Berengal> Is the haddock-TH bug fixed?
09:44:36 <Saizan> Berengal: not in any released version at least
09:44:40 <zygoloid> ksf: i'd guess "many . some" gives exponential time in backtracking
09:44:50 <Berengal> Saizan: :(
09:44:52 <ksf> there's no backtracking.
09:45:09 <MissPiggy> hey that's good it gives me lots more info
09:45:21 <ksf> also, pToken doesn't include pLWS
09:46:02 <MissPiggy> well I stil have no clue how to fix this
09:46:04 <Berengal> ksf: Profile it to count entry points
09:46:12 <lispy> ksf: Have you looked at why it's slow?  Using something like +RTS -sfoo.stats -RTS to see if it's GC time or calculation time?  using profiling to see which cost centers are expensive?
09:46:20 <nainaide> Why parse error in pattern on  writeLog :: [(String, String)] -> IO ()   writeLog x:xs = do ....  ?
09:46:32 <lispy> nainaide: you need a parens
09:46:33 <|Jedai|> merijn: Well there's the stack overflow
09:46:42 <c_wraith> Err.
09:46:45 <lispy> nainaide: around the pattern when it's on the left side of the equals
09:46:48 <MissPiggy> any good mantras or whatnot to make cabal work?
09:46:48 <c_wraith> It looks like putMVar is leaking.
09:46:59 <lispy> nainaide: so, like, writeLog (x:xs) = ...
09:47:11 <Saizan> MissPiggy: first we need to know what the situation is, ghc-pkg list ?
09:47:16 <lispy> c_wraith: oh, use the strict-concurrency package on hackage
09:47:30 <MissPiggy> there are no red packages in ghc-pkg list, that's why I am lost for what to do
09:47:31 <|Jedai|> merijn: though you can recurse much more than in most imperative language, many recursive pattern also only consume constant stack space
09:47:37 <lispy> c_wraith: if it fixes the problem you might send Don a note letting him know.  He's looking for examples
09:47:44 <nainaide> lispy,  thanks.
09:47:49 <c_wraith> lispy: hmm.  ok.  I'll look at that
09:47:55 <ksf> first try stack overflow...
09:48:00 <Berengal> MissPiggy: cp ~.cabal/config ~/cabal-config && rm -rf ~/.cabal && mkdir ~/.cabal && cp ~/cabal-config ~/.cabal/config
09:48:05 <Saizan> MissPiggy: yeah, but how many instances of  haskell98-1.0.1.1 do you have?
09:48:20 <|Jedai|> merijn: mostly, stack overflow in Haskell results from too much or not enough lazyness
09:48:24 <Saizan> Berengal: you forgot a rm -fr ~/.ghc
09:48:41 <Saizan> Berengal: but that whole thing is not usually necessary.
09:48:46 <Berengal> Saizan: Yeah...
09:48:52 <MissPiggy> just one
09:48:55 <|Jedai|> merijn: see the page on Foldl foldr and foldl' on the Haskell wiki for an example
09:48:58 <ksf> it's <|> called from <*>
09:49:18 <Berengal> Saizan: I have it as a script. Useful if you forget to turn on profiling...
09:49:36 <merijn> |Jedai|: Looks like its mostly handle via StackOverflow and HeapOverflow exceptions according to http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
09:49:50 <MissPiggy> well I can't even compile ksfs program
09:49:56 <Saizan> MissPiggy: and ListLike is not red?  weird
09:50:07 * hackagebot upload: hs-gchart 0.4 - Haskell wrapper for the Google Chart API (DeepakJois)
09:50:19 <MissPiggy> no it's not red
09:50:26 <Saizan> ghc-pkg check ?
09:50:37 <MissPiggy> that doesn't seem to do anything
09:50:38 <IceDane> I've been looking at the state monad, and its explanations on several different pages and books now.. Is there anyone here that would feel up for writing a short program that makes use of the state monad, wherein the state is initialized, threaded into another function to be modified and then printed out, or something like that? Heh
09:50:48 <Saizan> it doesn't report any problem?
09:50:55 <MissPiggy> no
09:50:59 <IceDane> The only real example of state in RWH is the random stuff.. It doesn't make anything click for me.
09:51:00 <c_wraith> agh.  strict-concurrency depends on base < 4, my package depends on base > 4
09:51:31 <c_wraith> Though not for any reason other than making GHC 6.12 stop complaining
09:51:35 <zygoloid> ksf: what structure do you imagine your top-level P will have?
09:51:41 <Saizan> c_wraith: just use "putMVar var $! foo" then
09:51:50 <Saizan> c_wraith: or rnf if needed
09:52:05 <c_wraith> but it does appear to solve the problem in my most primitive test
09:52:10 <Saizan> MissPiggy: how did you get the above error about ListLike?
09:52:16 <ksf> zygoloid, infinite.
09:52:17 <c_wraith> I'll check on everything further
09:52:18 * ddarius doesn't know why rnf is so often suggested.
09:52:28 <ksf> the finite ones look quite nice, though.
09:52:56 <ksf> the heap profile is all spiky up to 30m, the bulk belonging to Map
09:53:00 <lispy> ddarius: because it's more precise than bang patterns and does a better job of recursively evaluating than adding seq :)
09:53:10 <Saizan> ddarius: because it's the shortest way to say "make sure you strictify all the relevant parts"?
09:53:30 <ddarius> lispy: More "precise" in what sense?
09:53:31 <lispy> ksf: oh, inserting thunks (instead of values) into Maps is a common cause of space blow ups
09:54:11 <ksf> but just if that's keys, not values, or not?
09:54:21 <lispy> ddarius: You can put an rnf anywhere (or not put it) but bang patterns are on the fields and or params and happen each time the the constructor is used or the function called
09:54:38 <ddarius> Saizan: I agree that it is a simple way to force everything, but its a very expensive operation and is rarely called for.  It is also often suggested blindly.
09:54:59 <ddarius> lispy: Okay, I get what you're getting at.
09:55:29 <ddarius> In my opinion, rnf is almost never the best solution.
09:55:33 <lispy> ddarius: using it "blindly" can be a good way to determine if some lighter approach will help.  (rnf can be a big hammer of recursive evalutions and yeah, that can suck)
09:56:33 <benmachine> IceDane: I have a semi-finished but relatively simple project that uses State
09:56:39 <benmachine> it is 113 lines long
09:56:44 <MissPiggy> well it is doing  /usr/bin/ghc --make -package-name iteratee-0.3.1 ...
09:56:47 <IceDane> benmachine: I wouldn't mind looking at it =)
09:56:49 <benmachine> I make no guarantees as to its legibility
09:56:49 <IceDane> if you wouldn't mind
09:56:51 <benmachine> okay one sec
09:56:56 <MissPiggy> and that says:
09:56:56 <MissPiggy> <command line>: cannot satisfy -package-id ListLike-1.0.1-49bb34054169106051cc1f022810a42c:
09:57:00 <MissPiggy>     ListLike-1.0.1-49bb34054169106051cc1f022810a42c is unusable due to missing or recursive dependencies:
09:57:03 <MissPiggy>       haskell98-1.0.1.1-0fdaf3b26bc38c43ce8371edf538dbf6
09:57:34 <benmachine> www.srcf.ucam.org/~bm380/dc.hs
09:57:41 <IceDane> thanks =)
09:57:43 <ksf> ...if I keep the parser in a CAF, though, the second run is instantaneous.
09:57:57 <lispy> ksf: Oh, that's telling
09:58:12 <lispy> ksf: So building the CAF is expensive but it doesn't change much/
09:58:13 <lispy> ?
09:58:22 <benmachine> IceDane: I didn't make it to be read, so if it's incomprehensible that might be my fault
09:58:38 <ksf> not only expensive, but exponential
09:59:09 <IceDane> benmachine: It doesn't look too bad tbh
09:59:16 <benmachine> good
09:59:17 <IceDane> I'll have to look at it for a bit to decide, heh
09:59:18 <IceDane> thanks
09:59:46 <Saizan> ksf: maybe your <*>/<|> has the same problem as a right associated (++), only worse :)
10:00:56 <mreh> does the "let" in a do just wrap a return around the RHS and replace the = with an arrow?
10:01:12 <mreh> <-
10:01:16 <mreh> that kind of arrow
10:01:59 <Saizan> MissPiggy: i don't know then maybe Berengal's advice of wiping out your userdb is the best, but it would be good to find out more about this problem, it might be a bug
10:02:45 <Saizan> mreh: no
10:03:04 <Saizan> @undo do let x = foo; bar
10:03:04 <lambdabot>  Parse error at end of input
10:03:15 <freiksenet> what is the best way to debug haskell?
10:03:18 <Saizan> @undo do let {x = foo}; bar
10:03:18 <lambdabot> let { x = foo} in bar
10:03:43 <mreh> oh I see
10:03:45 <ksf> ugh. limiting pToken to only recognize "fobar" induces a stack overflow
10:03:50 <mreh> so the do becomes a function of x
10:04:12 <mreh> @undo do { let x = foo; bar x}
10:04:12 <lambdabot>  Parse error at "}" (column 24)
10:04:22 <mreh> @undo do let {x = foo}; bar x
10:04:23 <lambdabot> let { x = foo} in bar x
10:04:34 <ksf> lispy, matching against an equal or smaller amount of spaces is fast, increasing the count hogs the cpu, again
10:04:39 <mreh> @undo do let {x = foo}; bar x; baz
10:04:39 <lambdabot> let { x = foo} in bar x >> baz
10:04:54 <mreh> if I @pl that, it would make sense
10:05:09 <mreh> @pl let {x = foo} in bar x
10:05:09 <lambdabot> (line 1, column 5):
10:05:09 <lambdabot> unexpected "{"
10:05:09 <lambdabot> expecting "()", natural, identifier or "in"
10:05:25 <IceDane> benmachine: [plusOp, subOp, mulOp, divOp] = map (binOp . numOp) [(+), (-), (*), (/)]  <- that stuff is wicked, heh. No idea that was possible.
10:05:32 <Saizan> ksf: it seems you're unfolding an infinite structure rather than traversing a cyclic one
10:05:43 <mreh> I'm not making much sense today...
10:05:55 <ksf> Saizan, exactly.
10:06:01 <lispy> ksf: Hmm...So if you do a type or retainer profile can you start to see why you're holding on to spaces?  It sounds like you're creating a lot in the map for each space.  But, since I'm no longer looking at the code I'm not sure.  Perhaps you're storing strings with increasing length in the map?  " ", "  ", "   ", etc.
10:06:23 <aavogt> @pl let in
10:06:23 <lambdabot> (line 1, column 7):
10:06:23 <lambdabot> unexpected end of input
10:06:23 <lambdabot> expecting end of "in", lambda abstraction or expression
10:06:52 <Saizan> lispy: nah, he just keeps having more and more nodes in its parser :)
10:06:52 <shapr> Igloo: The life recording application is actually a really cool idea, I think it would be perfect if it worked in the browser.
10:06:53 <ksf> ...and that's because it's not really cyclic. parse "foo" <|> parse "bazz" repeats every 12 chars...
10:07:21 <ksf> I'm only storing chars in the map
10:07:49 <Igloo> shapr: Huh?
10:08:25 <shapr> Igloo: Remember the app you wrote long years ago that recorded stuff that happened in your life? Like, when you lived somewhere, and how long you did something?
10:08:39 <c_wraith> well..  head normal form isn't doing the job
10:08:47 <c_wraith> guess I need rnf (or similar)
10:08:58 <Igloo> Oh, right. Vaguely.
10:09:18 <lispy> hey shapr!  How is school?
10:09:33 <shapr> Igloo: I think, strangely enough, it would be a very successful FaceBook app.
10:09:44 <lispy> c_wraith: Too bad strict concurrent wasn't compiling :(
10:10:11 <shapr> lispy: University is awesome! I haven't gotten to use Haskell yet for my infosec class, but I'm trying to find a way to squeeze it in!
10:10:12 <Berengal> MissPiggy: Have you wiped your user packagedb yet?
10:10:16 <Saizan> ksf: i'd blindly use a Codensity transformation if it applies, it might solve the problem
10:10:21 <lispy> shapr: it seems like it should be named, "life graph" or "life chart" or something like that
10:10:44 <MissPiggy> no
10:10:51 <MissPiggy> I have no what I am doing I need a language for babies
10:10:55 <MissPiggy> haskell is too hard
10:11:27 <Berengal> MissPiggy: do a ghc-pkg describe and compare the hashes
10:11:27 <EvanCarroll> I agree.
10:11:31 <shapr> lispy: The reason for a facebook app imho, is that others would be able to say "no it actually happened here, and at this time" and they'd be able to connect to your life graph.
10:11:54 <Berengal> MissPiggy: And a ghc-pkg list to see if you've got several versions of the package in question
10:12:02 <EvanCarroll> Haskell would be easier if only it was more like C
10:12:10 <lispy> shapr: I think it would be fun to see all the times I've moved :)
10:12:14 <EvanCarroll> it should move in that direction
10:12:19 <MissPiggy> I'm trying to do  cabal install iteratee
10:12:24 <lispy> shapr: I started tracking that in google earth, but I lost my data file
10:12:25 <ksf> Saizan, as explained here? http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=367
10:12:28 <MissPiggy> Warning: This package indirectly depends on multiple versions of the same
10:12:28 <MissPiggy> package. This is highly likely to cause a compile failure.
10:12:34 <MissPiggy> Highly Likely lol
10:12:40 <lispy> shapr: but I had a fly through of all the locations on the globe in order of residence
10:12:44 <shapr> Anyway, Igloo wrote a gtk app that did that, it was quite nifty.
10:12:54 <MissPiggy> so maybe if I try 300x one of them will work
10:13:00 <Berengal> MissPiggy: If you've got more than one version of the package, one library might be compiled with the first package and another with the second, in which case there's a diamond dependency issue, even if they're the same package versions
10:14:01 <MissPiggy> I have no idea I think I will just go to bed
10:14:18 <Saizan> ksf: as not explained there, yeah :)
10:14:29 <Berengal> MissPiggy: Also a viable alternative :)
10:15:04 <Saizan> ksf: newtype Codensity f a = Codensity (forall r. (a -> f a) -> f a)
10:15:14 <Saizan> ksf: oops newtype Codensity f a = Codensity (forall r. (a -> f r) -> f r)
10:15:59 <Saizan> ksf: it's a bit like DList but for monads
10:16:12 <MissPiggy> that's pretty cool
10:16:27 <MissPiggy> it comes from category theory?
10:16:31 <mreh> man, the original arrows paper is good
10:16:49 <MissPiggy> and anyone made some graphs about it's speed?
10:17:08 <Saizan> yes, it comes from CT
10:17:13 <MissPiggy> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=367 -- I wish I'd been there
10:17:44 <Saizan> not sure about graphs, but it's been used to reduce the complexity of some monads
10:17:50 <ksf> I've found http://wwwtcs.inf.tu-dresden.de/~voigt/mpc08.pdf
10:17:58 <Saizan> i.e. not just constant factors
10:18:01 <rovar> is System.Event being integrated into haskell base?
10:18:23 <rovar> I saw something reguarding a diff to base for  registerFD, but can't find any documentation for such a thing
10:18:26 <ksf> otoh, I'm merely using an applicative functor
10:19:10 <ksf> "Despite this simplicity of use, our technique is able to
10:19:10 <ksf> achieve true asymptotic runtime improvements. We demonstrate this by
10:19:10 <ksf> examples for which the complexity is reduced from quadratic to linear."
10:19:23 <Saizan> yeah, so i'm not sure if it really applies..
10:19:28 <ksf> ...that sounds like an awefully cruel april's fool joke.
10:19:56 <Saizan> Result a (P t a) <- in a free monad you'd just have Result a
10:20:00 <Gracenotes> hurrah for n^-1 factor improvement
10:20:19 <zygoloid> hmm, looks a lot like ContT. is it the same performance fix (re0association of >>=)?
10:20:37 <Saizan> zygoloid: yup, it's a restricted version of ContT
10:20:51 <ksf> I _did_ wonder how to get rid of it, but didn't manage to get rid of it and still match each input exactly once against a map
10:21:13 <ksf> Iteratees don't lend themselves very well to backtracking
10:21:38 <Berengal> ksf: I would think backtracking goes against the very spirit of iteratees
10:22:06 <ksf> there's seekable iteratees that can do it efficiently, but yes, it's not their style.
10:22:36 <Saizan> OTOH, Codensity f is a Monad even if f isn't.
10:22:54 <zygoloid> for all f, or just Functor f?
10:23:24 <Saizan> but Codensity f is not isomorphic to f, e.g. Codensity Set still doesn't make a nice Set monad
10:23:36 <Saizan> because the pruning happens only at the end.
10:23:41 <Saizan> zygoloid: all f
10:24:06 <ddarius> That's because the Codensity f monad is just the continuation monad which is completely polymorphic in the answer type.
10:24:43 <jonathanturner> sorry to interrupt the much cooler conversation. I'm trying to make the equiv of a lookup table.  If I have [('a', 1), ('b', 2), ('c', 3)] how would I find the corresponding value for 'b'?  Or is there a better way to do it?
10:24:44 <Saizan> forall r. ContT r f
10:24:57 <benmachine> :t lookup
10:24:58 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
10:25:00 <byorgey> jonathanturner: with the 'lookup' function
10:25:12 <ddarius> The better way would be to use a Ma\p.
10:25:13 <jonathanturner> heh, I knew it was going to be something obvious
10:25:30 <benmachine> jonathanturner: there are lots of more effective data structures, but if you only have a few things to look at, I wouldn't worry about it
10:25:37 <ddarius> Assuming the lookup table gets moderately large (say more than a few dozen or so elements)
10:26:12 <Berengal> ddarius: Or a trie
10:26:25 <benmachine> or an Array
10:26:26 <Berengal> Since maps are strict in the spine
10:26:48 <c_wraith> using deepseq completely squashed the memory leak.  *sigh*.  I like laziness.
10:27:17 <ddarius> c_wraith: Now find out how to fix the problem without using deepSeq.
10:27:26 <Berengal> c_wraith: Now you only have redundant traversals to worry about
10:27:52 <ddarius> The ideal programs are a balance between eagerness and laziness.
10:28:49 <c_wraith> I'm somewhat limited by using Data.Map as my backing structure.  I'm stuck with its default laziness, unless I want to re-implement it
10:29:19 <Berengal> c_wraith: It's strict in the spine and keys, so just seq the values as you insert them
10:29:30 <mathijs> hi all
10:29:43 <c_wraith> It is strict in the spine?  Then I shouldn't need deepseq at all.  the leak isn't in the keys
10:29:58 <c_wraith> err, isn't in the values.
10:30:07 <c_wraith> the leak's in the thunks made by my wrapping functions.
10:30:24 <c_wraith> So I just need them to be strict in the structure, I guess
10:30:53 <Berengal> c_wraith: deepseqing a map is usually bad for performance since it has to traverse the entire map, while seqing the values at the right time won't traverse at all
10:31:24 <benmachine> you might need to deepseq the values?
10:31:33 <Berengal> That's a different issue
10:31:48 <Berengal> data Map k a
10:31:48 <Berengal>   = Data.Map.Tip
10:31:48 <Berengal>   | Data.Map.Bin !Data.Map.Size !k a !(Map k a) !(Map k a)
10:32:19 <c_wraith> I doubt the values are the issue.  I should be able to just make my data structures strict appropriately.
10:33:02 <Berengal> c_wraith: Then lazyness probably exists outside of the map, thunking entire maps themselves
10:33:19 <uorygl> Is there a limit to how many constructors a type can have?
10:33:21 <c_wraith> berengal: yes, certainly.  I'm wrapping a map with some additional information in structures that aren't strict.
10:33:27 <Berengal> If so, simply seqing the map where you're deepseqing it now should be enough
10:34:04 <mathijs> I have a question (not strictly haskell related). I have a multi-threaded program, which has some shared state (Map). I don't want a lot of locking (preferably none), so I decided to make the state immutable (as in haskell). so putting stuff in/chaning/deleting generates a new Map. Now I like STM's 'atomically' functionality, so threads just take the state, do some stuff (non-mutable) and when they have a new state ready, I need to put it 
10:34:22 <uorygl> Can it have a milliatillion of them?
10:35:30 <mathijs> problem is... between checking if state changed and putting in the new state (if no changes), another thread might still update the state. so I'm affraid I need to lock 'updating the state'. Am I right or is there a nicer way?
10:36:09 <Berengal> mathijs: Well, you need a write-lock at least
10:36:22 <Berengal> mathijs: And the state needs to be a mutable pointer, of course
10:36:35 <Berengal> This is the same in haskell(, but with references instead of pointers)
10:37:38 <Berengal> When you take the write-lock depends. You could bundle the reference with a version number, and increment that each time you write a new state. In this case you only need to check the version when you're writing your new state, and redo if someone else stepped on your toes
10:37:39 <c_wraith> Can you make fields of a data type using record syntax strict?
10:37:44 <mathijs> Berengal: yeah, state points to latest state. so modifying this pointer will need to get locked... I was affraid of this. well at least it minimizes locking to the bare minimum. so I guess 'atomically' locks too somehow?
10:37:46 <BenceF> how can i look up the source of prelude modules?
10:37:50 <byorgey> c_wraith: yes
10:37:52 <McManiaC> anyone ever tried to compile Graphics.Vty on windows?
10:37:58 <c_wraith> byorgey: what's the syntax?
10:38:08 <byorgey> Foo { blah :: !Int, blerg :: !Baz }
10:38:12 <c_wraith> thanks
10:38:33 <Berengal> mathijs: "atomically" rolls back and redoes the transaction if someone else messed up your state
10:38:45 <Berengal> mathijs: This is similar to the version number way
10:39:32 <Berengal> mathijs: You could also take the write-lock at the beginning of the generate-new-state period. This would lock out all other threads from accessing the state in that period though
10:40:53 <mathijs> Berengal: yeah, I don't want that. I want to minimize locking. so locking just on the update is fine.
10:41:18 <Saizan> ksf: how do you run a test for your parser?
10:41:37 <BenceF> nevermind. ive got it
10:42:02 <Berengal> mathijs: You have to be careful in that you must consider the state out-of-date once you read it though. In theory another thread could update it right after you read it
10:42:31 <mathijs> Berengal: thanks for helping though. I was affraid some locking would be needed anyway, just needed to make sure I didn't forget to look at some possible workarounds :)
10:43:04 <Berengal> mathijs: There's probably some lock-free algorithms for reading and writing pointers around, but there's no need to overcomplicate things :)
10:44:10 <mathijs> Berengal: I know, that's why I check before writing back the changes (so the effect is the same as atomically, will fail if anyone changed stuff inbetween, just fails at the end instead of intantly)
10:44:14 <sioraiocht> Is there a library that abstracts over ByteArray# that is less abstract than UArray?
10:45:09 <Berengal> mathijs: You also need a read-lock when reading the pointer, although it would only prevent the write-lock from being taken. You don't want to read half-written pointers
10:46:33 <Berengal> mathijs: Also, atomically isn't guaranteed to fail instantly. I suppose it fails at the first opportunity it can, with at least one guaranteed opportunity in the end, at the "commit" phase.
10:48:04 <mathijs> Berengal: I know... writelocking without readlocking anywhere is a mistake most of the time :)   and didn't know about atomically not guaranteeing failing instantly. so probably my solution is pretty close to it.
10:48:50 <monochrom> locking is hard. let's open all doors.
10:48:58 <portnov> @pl \m -> do {f <- m; return $ concatMap f}
10:48:59 <lambdabot> (line 1, column 10):
10:48:59 <lambdabot> unexpected "{"
10:48:59 <lambdabot> expecting variable, "(", operator or end of input
10:49:33 <portnov> @type \m -> m >>= (return . concatMap)
10:49:34 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> [b]) -> m ([a] -> [b])
10:50:39 <doserj> @type (concatMap <$>)
10:50:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> [b]) -> f ([a] -> [b])
10:51:33 <IceDane> So, the state monad contains a function? Is this right? This question may not make sense, but how does it 'store state(f.x. a string or something) and a function' ? I've been looking at it, its examples and whatnot in RWH so many times now, but it still doesn't make any sense.
10:51:35 <portnov> @type flip fmap concatMap
10:51:36 <lambdabot> forall b a b1. (([a] -> [b1]) -> b) -> (a -> [b1]) -> b
10:51:46 <BenceF> can guards be multple levels?
10:52:29 <monochrom> IceDane: the state value is "stored" as function parameters and function return values.
10:52:35 <opqdonut> @src State
10:52:36 <lambdabot> Source not found. My brain just exploded
10:52:50 <zygoloid> @type Codensity (\f -> putStrLn "Hello" >> f 42 <* putStrLn "Goodbye")
10:52:51 <portnov> @type fmap concatMap
10:52:51 <lambdabot> Not in scope: data constructor `Codensity'
10:52:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> [b]) -> f ([a] -> [b])
10:52:54 <opqdonut> anyway: Data State a = State (s -> (s,a))
10:52:54 <aavogt> BenceF: you can put commas if you want to check multiple things
10:53:11 <BenceF> ok. ill try
10:53:16 <Berengal> mathijs: In principle, STM may be implemented as a single global lock
10:53:25 <aavogt> > case () of _ | True, False -> "no" | True -> "yes"
10:53:26 <lambdabot>   "yes"
10:53:37 <IceDane> monochrom: I'm not sure I understand what that means.
10:53:42 <opqdonut> IceDane: so the state is "stored" nowhere, the State monad just represents actions that take in state and transform it
10:53:50 <IceDane> Hmm
10:53:55 <opqdonut> IceDane: the initial State is pluggen in at the top level with runState or something
10:53:58 <monochrom> You have s->(s,a). I bunch of functions of that type. Then you chain them up in the obvious way. "storing" is an illusion.
10:53:58 <opqdonut> :t runState
10:53:59 <lambdabot> forall s a. State s a -> s -> (a, s)
10:54:06 <monochrom> s/I/A/
10:54:23 <opqdonut> then, on the other hand, the state _comonad_ really stores the state
10:54:27 <portnov> @type liftM concatMap
10:54:27 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> [b]) -> m ([a] -> [b])
10:54:38 <opqdonut> it looks something like "data CoState s a = CoState s a"
10:54:57 <opqdonut> i.e. just a tuple
10:55:03 <aavogt> though if you want to factor out some redundancy and still go on to the next guard if you don't match it's probably easier to bind that function in a where decl
10:55:46 <IceDane> What would a function look like that returned some initial state for a string, that I could pass on to be modified, then?
10:55:57 <aavogt> > case () of _ | expensive, False -> "no" | expensive, True -> "yes" | True -> "fallback" where expensive = False
10:55:58 <lambdabot>   "fallback"
10:56:12 <opqdonut> IceDane: initial state for a string?
10:56:20 <aavogt> otherwise just nest case expressions
10:56:55 <Berengal> aavogt: Can you "where" a case?
10:57:04 <aavogt> I just did
10:57:11 <IceDane> opqdonut: Some made up program that does threads state that 'contains' a string through, modifying it. Say, from reading a file or something, just without the reading and some made up string.
10:57:14 <aavogt> or do you mean something else, Berengal?
10:57:26 <opqdonut> > runState (get >>= \s -> put (s ++ " world!")) "hello"
10:57:26 <IceDane> I don't even know if my questions make sense - that's how bad my understanding of the state monad
10:57:27 <lambdabot>   ((),"hello world!")
10:57:47 <Berengal> aavogt: That's what I meant, but I wasn't sure it wasn't just lambdabot magic
10:57:51 <opqdonut> > runState (modify (++ " world!")) "hello"
10:57:53 <lambdabot>   ((),"hello world!")
10:58:00 <opqdonut> those are some minimal examples of the state monad
10:58:15 <opqdonut> the state is initially "hello" and is modified by adding " world!" to it
10:58:26 <aavogt> > case () of _ | expensive, False -> "no" | expensive, True -> "yes" | True -> "fallback"; _ -> "scoped per initial match" where expensive = False
10:58:27 <lambdabot>   Not in scope: `expensive'Not in scope: `expensive'
10:58:31 <IceDane> Hmm..
10:58:41 <monochrom> Â«modify (++ " world!")Â» expands to \s -> (s ++ " world!", () )
10:58:43 <aavogt> > case () of { _ | expensive, False -> "no" | expensive, True -> "yes" | True -> "fallback"; _ -> "scoped per initial match" } where expensive = False
10:58:44 <lambdabot>   <no location info>: parse error on input `where'
10:59:15 <c_wraith> arg
10:59:24 <c_wraith> the leak *is* in the values to the map.
10:59:33 * c_wraith plans where to strictify them carefully
10:59:34 <aavogt> @type M.insert'
10:59:35 <lambdabot> Couldn't find qualified module.
11:00:13 <aavogt> hmm, I thought there was an insert function that was strict in the values too
11:00:25 <ski> aavogt : what is `expensive, False' supposed to mean, there ?
11:00:35 <monochrom> If your state is just a number, and you want to do the analogue of i++: \s -> (s+1,())
11:00:52 <c_wraith> I'm actually using M.adjust more than M.insert.  That's almost certainly where the thunks are coming from
11:00:58 <aavogt> ski: it's supposed to represent two expressions evalating to a Bool
11:01:17 <monochrom> If you say, wait, the full semantics of i++ is modifying i but also leaking the pre-modified i: (\s -> (s+1, s))
11:01:26 <ski> aavogt : and maybe you want to combine those two expressions with `(&&)' or maybe with `(||)' ?
11:01:34 <monochrom> Similarly, ++i is (\s -> (s+1, s+1))
11:01:46 <aavogt> ski: in guards the comma is like &&
11:02:02 <monochrom> Don't store state. Just say how to convert old state to new state.
11:02:10 <ski> (monochrom : if that is `State', shouldn't it be "i++: \s -> ((),s+1)" ?)
11:02:23 <monochrom> Maybe.
11:02:51 <Twey> join (***) succ
11:02:53 <IceDane> I'm reading what you're saying, and it might be coming to me
11:02:54 <monochrom> I trusted somebody else.
11:02:55 <Berengal> ski: Commas in guards separate individual pattern-guards, which may or may not contain a pattern match. The patterns make && not work
11:03:09 <ski> aavogt : you mean pattern guards ?
11:03:10 <opqdonut> ski: well i++ has a value, but also a side-effect
11:03:15 <IceDane> Thanks, at any rate, I'll see if I can get myself to 'grok' it
11:03:35 <opqdonut> ah yes, you corrected the order of the tuple in the first example
11:03:35 <ski> @type State
11:03:36 <lambdabot> forall s a. (s -> (a, s)) -> State s a
11:03:38 <opqdonut> nvm
11:03:59 <ski> opqdonut : i was refering to the ordering of `a' and `s' in the tuple type, there ^
11:04:28 <opqdonut> yes
11:05:09 <c_wraith> crap.  how do I strictify Map.adjust?
11:05:13 <ski> aavogt : in that case, `expensive, False' should be the same as `False' (modulo possible `_|_' from forcing `expensive'), no ?
11:05:33 <Saizan> @tell ksf http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21048#a21069 , i get an improvement, but the asymptotics still seem to be bad
11:05:33 <lambdabot> Consider it noted.
11:05:40 <aavogt> yes, but False should be some more interesting expression
11:06:16 <ski> oh, ok
11:06:35 * ski just came in ..
11:08:40 <c_wraith> Is there no way at all to make Map.adjust strict?  Am I really stuck with traversing the map twice, in a read, apply strictly, write pattern?
11:10:21 <zygoloid> Saizan: so the codensity monad allows you to perform arbitrary operations on some result value 'at a distance', so long as your operations are generic in what's "contained in" the result?
11:10:34 <c_wraith> Oh.  It appears I can bend Map.insertWith' to do what I want.
11:10:58 <zygoloid> so with Codensity Set you can't find whether the set contains a certain element, but you can find its size
11:11:31 <Saizan> zygoloid: mh, no, the intermediate Set's don't get constructed at all
11:11:42 <Saizan> zygoloid: that's why you don't need Ord for the intermediate types
11:12:17 <Saizan> zygoloid: by intermediate i mean the ones that would be constructed with uses of return/fmap/>>=
11:13:41 <ksf> Saizan, I need to get those repetitions straight, yes
11:13:42 <lambdabot> ksf: You have 1 new message. '/msg lambdabot @messages' to read it.
11:14:28 <ksf> that codensity result is impressive
11:15:18 <Saizan> yeah, for such a mindless transformation :)
11:15:37 <ksf> is it possible to inject it into the compiler pipeline?
11:15:48 <ksf> or is figuring out where to do that too expensive?
11:16:10 <zygoloid> Saizan: right, that's what i meant by "at a distance".
11:16:26 <Saizan> ksf: well, it changes the semantics
11:17:32 <Saizan> (in fact it's not always a win)
11:18:10 <zygoloid> Saizan: hmm, further it looks like you can't really make decisions within 'Codensity' based on the constructed value either
11:19:16 <Saizan> zygoloid: what do you mean by that?
11:20:25 <Saizan> zygoloid: at some point you'd need a liftC :: m a -> Codensity m a, which is basically (>>=) + newtype wrapping, but can be written for non-monads too
11:20:55 * Saizan is not explaining this too well
11:21:01 <zygoloid> Saizan: for instance, in Codensity IO it seems like you can't write something like 'readFile :: String -> Codensity IO String'
11:21:30 * zygoloid is being silly, of course you can
11:22:07 <zygoloid> but you can't, in Codensity Set, write 'size :: Codensity Set Int' afaics
11:23:25 <Saizan> what should that do?
11:23:54 <zygoloid> what is the key difference between that and readFile which makes oen possible and the other not possible?
11:24:08 <zygoloid> in the readFile case you're inheriting some kind of chaining operation from it being a monad
11:24:16 <zygoloid> (it == IO)
11:25:08 <Saizan> size :: Set a -> Int, not size :: Foo -> Set Bar though
11:25:47 <Saizan> i.e. size is not really "monadic" from the start
11:26:21 <Saizan> IOW it's not an arrow in the Kleisli category
11:27:39 <zygoloid> ok, but... forkIO :: IO () -> IO ThreadId, and yet forkIO exists in Codensity (where it does something /very/ strange)
11:28:23 <zygoloid> "\f -> forkIO (f ())" (plus some MVar stuff to carry the result in and out) seems to fork off the rest of the computation into another thread
11:28:58 <Saizan> forkIO :: Codensity IO () -> Codensity IO ThreadId; forkIO (Codensity m) = Codensity $ \k -> forkIO (m return) >>= k ?
11:29:41 <Saizan> forkIO :: Codensity IO () -> Codensity IO ThreadId; forkIO (Codensity m) = Codensity $ \k -> forkIO (m k) >>= k -- this would be very strange :)
11:30:18 <zygoloid> i was thinking "Codensity $ \k -> do m <- newEmptyMVar; forkIO (k () >>= writeMVar m); readMVar m"
11:30:32 <zygoloid> though that's obviously not very useful :)
11:30:51 <Saizan> mh, that forks the rest of the computation :)
11:32:12 <helgikrs> i'm trying to install wx, but ghc-pkg complains that a few dependencies (such as base-4.2.0.0) "doesn't exist", but "ghc-pkg list" does list all of them, with the same version, and "/usr/lib/ghc-6.12.1/base-4.2.0.0" does indeed exist
11:32:14 <zygoloid> Monad m => Codensity m also seems to imbue m with scoping power. you can write 'bracket :: m () -> m () -> Codensity m ()', then 'bracket a b >> c' is something like 'a >> b >> c'
11:32:27 <MissPiggy> helgikrs I got something like that
11:32:48 <helgikrs> any reason why that is?
11:33:42 <zygoloid> bracket before after = Codensity $ \k -> before >> k () >> after
11:34:34 <Saizan> zygoloid: yeah, you get some rewriting ability
11:38:22 <zygoloid> hum. so in the [] monad you can access the values but not the structure (you can't say 'give me the third element now please' without leaving the inside of the monad). but in Codensity [] you can access the structure but not the values. weird
11:44:00 <freiksenet> https://gist.github.com/21dc3f273c0773f7154c <- I have this kind of error. Do I need to define this "showList" instance for Type in order to make it work?
11:44:28 <freiksenet> or show for [Type]?
11:44:54 <aavogt> freiksenet: no, you need an instance to show functions
11:44:57 <opqdonut> freiksenet: it is a function [Tile]->[Tile]
11:45:04 <opqdonut> not a list
11:45:12 <opqdonut> there is no default Show instance for functions
11:45:17 <freiksenet> ah, ok
11:45:45 <freiksenet> thanks
11:46:10 <freiksenet> I really like all the functional features of haskell, but when it comes to all sideeffecty stuff I am totally confused.
11:46:15 <aavogt> or first apply an argument to your  ([Tile] -> [Tile]) function before showing it
11:46:34 <freiksenet> yes, that must be bug, because i never intended to return a function
11:46:35 <aavogt> maybe you're confused by the way function application associates
11:46:44 <c_wraith> So, yeah.  In conclusion, this has been solved by writing strict versions of modifyMVar, modifyMVar_, and  Map.adjust
11:46:47 <aavogt> > show (+1) 0
11:46:48 <freiksenet> (bug in my code)
11:46:48 <lambdabot>   Couldn't match expected type `t1 -> t'
11:46:48 <lambdabot>         against inferred type `GHC.B...
11:46:57 <aavogt> > show $ (+1) 0
11:46:58 <opqdonut> type definitions for top-level functions!
11:46:58 <lambdabot>   "1"
11:47:06 <opqdonut> iron out bugs like that
11:47:26 <freiksenet> I found the bug already, didn't pass last argument %)
11:48:04 * ksf would like a show instance for ((->) a)
11:48:24 <zygoloid> > (+1)
11:48:25 <lambdabot>   {-3->-2;-2->-1;-1->0;0->1;1->2;2->3;3->4}
11:48:34 <ksf> it's supposed to reduce the function with all the arguments it already got, and pretty-print the rest.
11:48:39 <uorygl> > (==2)
11:48:40 <lambdabot>   {-3->False;-2->False;-1->False;0->False;1->False;2->True;3->False}
11:48:49 <uorygl> > id
11:48:50 <lambdabot>   {()->()}
11:49:09 <uorygl> > (.)
11:49:11 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
11:49:11 <lambdabot>                    GHC.Show...
11:49:26 <freiksenet> the most confusing thing is that I am unable to print-debug :)
11:49:27 <zygoloid> > map
11:49:28 <lambdabot>   {{()->()}->{[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}}
11:49:38 <ksf> freiksenet, try Debug.Trace
11:49:39 <MissPiggy> > fmap
11:49:40 <lambdabot>   No instances for (Test.SmallCheck.Serial (f a),
11:49:40 <lambdabot>                    GHC.Show...
11:49:45 <freiksenet> now I found ghci debugger, this is a bit easier.
11:49:46 <ksf> it's a refreshing desert in an oasis of purity.
11:49:58 <freiksenet> ksf: I couldn't figure out how to use, TBH. :(
11:50:09 <ksf> :t trace
11:50:10 <lambdabot> Not in scope: `trace'
11:50:14 <ksf> @hoogle trace
11:50:15 <lambdabot> Debug.Trace trace :: String -> a -> a
11:50:15 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
11:50:15 <lambdabot> module Debug.Trace
11:50:22 <uorygl> > map (+1)
11:50:23 <lambdabot>   []->
11:50:23 <lambdabot>    []
11:50:23 <lambdabot>  [-2]->
11:50:23 <lambdabot>    [-1]
11:50:23 <lambdabot>  [-2,-1]->
11:50:25 <lambdabot> [4 @more lines]
11:50:30 <zygoloid> Saizan: thanks for your help. time for some more googling!
11:50:34 <uorygl> @more! @more!
11:50:34 <lambdabot>    [-1,0]
11:50:34 <lambdabot>  [-2,-1,0]->
11:50:34 <lambdabot>    [-1,0,1]
11:50:34 <lambdabot>  [...
11:50:43 <ksf> ...you pass some string and a value. it's going to print the string as soon as the value is forced
11:50:52 <freiksenet> ksf: ooh.
11:51:10 <ksf> ...evaluating itself to the value, of course.
11:51:16 <uorygl> > trace "Rah!" 4
11:51:17 <lambdabot>   Not in scope: `trace'
11:51:21 <uorygl> Aww.
11:51:29 <freiksenet> ksf: so I can just use it in pure functions?
11:51:33 <ksf> yep
11:51:38 <freiksenet> ksf: ooooh. awesome
11:51:40 <freiksenet> thanks a lot
11:51:57 <ksf> another useful thing to have is trace' x = trace (show x) x
11:52:09 <ksf> ...as that's quite a common thing to write.
11:52:23 <osaunders> What's trace?
11:52:29 <ksf> black magic
11:52:34 <ksf> @hoogle unsafePerformIO
11:52:34 <lambdabot> Foreign unsafePerformIO :: IO a -> a
11:52:34 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
11:53:11 <osaunders> Ah.
11:53:12 <roconnor> @quote oasis
11:53:13 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
11:53:20 <burp> :t seq
11:53:21 <lambdabot> forall a t. a -> t -> t
11:53:25 <burp> and some of that ;)
11:53:46 <medfly> @hoogle unsafeCoerce
11:53:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:53:58 <osaunders> That's a nice quote.
11:54:08 <medfly> why is there System.IO.Unsafe and Unsafe.something, weird...
11:54:49 <burp> I guess because unsafecoerce has nothing to do with IO
11:55:20 <ksf> well, it's one way to turn an IO String into a String
11:55:57 <burp> that works with it?
11:56:36 <ksf> dunno, never tried.
11:56:41 <burp> unsafeCoerce (return "x" :: IO String) :: String
11:56:44 <burp> nope :>
11:56:59 <ksf> but I know that instance MonadFix STM where mfix = unsafeCoerce fixIO works.
11:57:27 <ksf> (and propably makes spj cry out in anguish)
11:58:17 <Pete1> Hello, do anyone know if there are ready functions for decoding data sent in html forms (with POST)
11:58:38 <ksf> there should be several
11:58:53 <ksf> ...either as part of the various web frameworks, or as a dependency of those.
11:59:09 <freiksenet> ksf: you saved my mind with this trace/trace'
11:59:46 <burp> always remember you use evil unsafe stuff in the back with trace :D
12:00:24 <ksf> heh. the next thing that'd be nice is a special Show-like class that doesn't complain not being mentioned in type signatures. I always end up commenting out half of my source when I use trace...
12:00:56 <opqdonut> heh
12:00:58 <ksf> or -XIgnoreTypeSignatures
12:02:13 <ben> instance Show a where show = unsafePerformInstance show
12:04:04 <c_wraith> Can I link to a function/data declaration that isn't imported with haddock?
12:04:26 <ksf> haddock won't find the destination
12:04:27 <c_wraith> I'd hate to add imports just to make my docs cleaner
12:04:34 <ksf> ...but you can set arbitrary links
12:04:47 <ksf> which propably isn't what you want.
12:04:54 <c_wraith> It's to outside my package, so it's definitely not what I want.
12:05:09 <c_wraith> I guess I'll use a qualified import just for haddock.  >_>
12:05:12 <ksf> you might want to try fully qualified names in backticks
12:05:21 <c_wraith> Oh, ok.  I'll see if that works
12:05:47 <ksf> but import qualified Foo.Bar as Doc is also telling.
12:06:25 <c_wraith> yeah, backticks didn't work.
12:06:35 <c_wraith> Guess I'll just import it. >_>
12:07:51 <c_wraith> I wonder if this will make ghc tell me I have an unused import. >_>
12:08:32 <Saizan> zygoloid: btw, "bracket before after = Codensity $ \k -> before >> do x <- k (); after; return x" otherwise it doesn't typecheck
12:11:56 * ezyang is sad because his comonad doesn't enforce time invariance 
12:14:19 <roconnor> that is very sad
12:14:32 <roconnor> netwon doesn't approve
12:14:39 <roconnor> newton
12:17:06 <tavelram> haskell platform on ubuntu 9.04, all the guides Ive found so far compiles ghc from scratch, isnt there an easier way?
12:17:47 <tavelram> apt-get only has ghc 6.8.2.
12:17:48 <ezyang> someone561's PPA was what I used back in the day
12:18:05 <ezyang> but I think he's like on 6.12 these days?
12:18:25 <tavelram> cool
12:18:38 <tavelram> I found that one, but it felt a bit overkill to add sources to apt-get and whatnot.
12:18:55 <tavelram> haskell platform doesn't really give the impression of batteries included =/
12:19:26 <Zao> Nothing stops you from using a HP designed for your GHC version.
12:19:46 <tavelram> oh, true.
12:20:28 <tavelram> actually, there is a generic binary for 6.10.4...
12:20:30 <ezyang> tavelram: Cabal is basically the battery
12:22:45 <tavelram> ezyang, ok, i installed it, but it ended up locally, ie ~/.cabal/ and from there on it seemed to be unaware of the rest of the ghc and libghc i already had.
12:23:30 <tavelram> and it didnt seem to get all the dependencies, since it thought it found the system-wide ones, but were unable to use thme.
12:23:40 <ezyang> you probably need to rebuild everything now
12:24:05 <opqdonut> as always with cabal... :)
12:25:52 <tavelram> ezyang, ok, well, but I guess it would be easier to try hp directly?
12:25:58 <tavelram> opqdonut :)
12:27:20 <tavelram> how come ghc-6.10.4-i386-unknown-linux-n.tar.bz2 untars to more than 500MiB?
12:28:01 <burp> is that unexpected?
12:28:27 <tavelram> it feels like alot. is that the binaries only, or the sources?
12:30:01 <burp> something of both I think :>
12:32:57 <roconnor> @hoogle ((a,b) -> c) -> ((b,a) -> c)
12:32:58 <lambdabot> No results found
12:33:17 <mauke> (. swap)
12:33:39 <tavelram> burp, ok, that would explain it then? since ghc only takes like 150mb when installed from apt-get...
12:33:55 <tavelram> but can I install cabal and then grab ghc/hp/whatever?
12:34:25 <burp> tavelram: are you sure it's 150 mb unpacked?
12:34:31 <burp> or the package is 150MB?
12:34:52 <tavelram> burp, i think apt-get said that removing it would free up 150mb.
12:34:57 <burp> http://packages.debian.org/sid/ghc6 it says installed size ~380MB for x86_64 and ~280MB for i386
12:34:57 <MissPiggy> :t uncurry . flip . curry
12:34:59 <lambdabot> forall a b c. ((b, a) -> c) -> (a, b) -> c
12:35:04 <tavelram> oh
12:35:07 <MissPiggy> damn so close
12:35:14 <burp> and there are also dependencies..
12:35:23 <tavelram> yeah, they were probably left.
12:35:48 <burp> documentation, haskell libraries that come with ghc
12:36:34 <tavelram> yeah, i think all the libghc are still there.
12:36:59 <burp> dpkg --get-selections | grep ghc
12:37:32 <burp> this will show you
12:38:20 <abbe> damn, this aduh_kpleset is PMing to everyone joining this channel
12:38:53 <ksf> Saizan, it's no wonder. many pLWS has 2^n complexity
12:39:08 <Zao> abbe: So get him glined?
12:39:26 <mauke> not me
12:39:29 <abbe> yes, whatever is the policy
12:41:09 <tavelram> burp, yeah
12:42:16 <Walt> abbe, he did not pm me.
12:42:26 <abbe> hmm...
12:44:16 <mreh> no pm here either
12:44:20 <abbe> Walt: he PMed me twice, but not this time.
12:44:38 <abbe> * aduh_kpleset  ÃÃ£ ÃÃÃ­ÃÃÃÃ¤Ã ÃÃ­ ÃÃÃÃ ÃÃ¡Ã£ÃÃÃÃÃ¥ Ã¦ ÃÃÃÃ¡ ÃÃ¡Ã¬ ÃÃ¦ÃÃÃ + Ã¥Ã¦ÃÃ ÃÃÃ Ã¦Ã£ÃÃÃ¤Ã­   /server IRC.ForChat.Net
12:45:45 <mauke> aduh_kpleset: how would you pass the turing test?
12:51:11 * hackagebot upload: lrucache 0.2 - a simple, pure LRU cache (CarlHowells)
12:52:39 <merijn> abbe: I think you can set a mode on yourself to prevent PMs from unregistered nicks, but you'd have to check the freenode site to be sure
12:53:20 <abbe> merijn: I don't have problem with unregistered nicks PMing me, but I don't want spam.
12:53:34 <abbe> merijn: maybe he stopped PMing
12:54:21 <merijn> Well, it blocks most spam. A lot of people/channels here are barring unregistered nicks anyway
13:01:54 <nomeata> Hi. Iâm wondering: Is anyone actually using Hugs, and what for? Does it offer advantages over ghc?
13:02:12 <damd> afaik, no one uses it seriously today
13:02:13 <aavogt> it is smaller
13:02:27 <merijn> nomeata: Supposedly it loads faster then GHCi so you can test faster? But I don't bother as GHCi is plenty fast for me
13:02:31 <aavogt> also more portable
13:03:35 <monochrom> hugs error messages are shorter
13:04:22 <nomeata> Debian is deciding whether to drop Hugs support from the (non-bundled) libraries. Do you think anyone would miss Hugs support for, say, binary or utf8-string?
13:04:34 <Twey> nomeata: I doubt itâ¦
13:04:52 <Twey> nomeata: Hugs is mostly used for teaching nowadays
13:05:05 <Twey> I don't think that such real-world libraries are going to be missed
13:05:12 <damd> when i took intro-haskell at the university we used hugs, but that was in 2004
13:05:31 <nomeata> Twey, thatâs what I thought.
13:05:34 <chrisdone> 'case you haven't seen it yet, this is kind of neat: http://www.engineyard.com/blog/2010/a-hint-of-hubris/
13:05:51 <Twey> I suggested that name \o/
13:06:05 * Twey takes inordinate pride
13:06:43 <chrisdone> hahaha
13:09:31 <chrisdone> I like this language mingling
13:09:48 * ezyang is slightly horrified 
13:10:03 <Twey> It's a cool concept, though I don't really see the benefit
13:10:13 <Twey> Just write it in Haskell already
13:10:18 <Axman6> heh
13:20:05 <Philonous> I wonder whether there is a deeper connection between the fact that a parser written in an arrow interface can parse context free grammars  (rather than context sensitive one, as a monadic one could) and how the nested pairs used to compose arrows computations form a stack
13:20:34 <MissPiggy> deeper than the obvious link you are alluding to/
13:20:35 <MissPiggy> ?
13:20:52 <Philonous> Is it really as obvious? Has someone written down the details?
13:21:51 <ezyang> maybe it's locked away in an academic paper somewhere...
13:22:30 <ezyang> "we should ask Oleg"
13:23:30 <Saizan> Wadler is more likely to have written on it :)
13:24:58 <dolio> Can you write infinite grammars with arrows, like you can with most other parser libraries in Haskell?
13:25:17 <dolio> Because if you can, odds are you can parse any language.
13:25:34 <Heffalump> I don't see why not
13:25:52 <dolio> I don't either, but you never know.
13:26:12 <dolio> Anyhow, infinite 'regular' grammars can parse any language.
13:26:37 <Cale> *any* language?
13:26:48 <Philonous> Cale: When the grammer itself is infinite
13:26:51 <kosmikus> Cale: :)
13:26:58 <Cale> Oh, well, I suppose so.
13:27:02 <ezyang> "that's not very useful"
13:27:08 <Cale> You can just have an enumeration of the words.
13:27:13 <Philonous> Cale: You can just trivially add an inference rule for any word in the language
13:27:18 <dolio> Any language for which your host language can generate an appropriate infinite 'regular' grammar.
13:27:19 <Saizan> the (a -> P b) part gets replaces with an infinitely branching node, basically?
13:27:31 <Cale> (assuming the words are finite)
13:28:00 <dolio> And if you're working in something crazy like ZFC, you can probably show that there's an infinite grammar for each language of finite strings.
13:28:19 <Cale> yeah, that's easy enough
13:29:20 <kosmikus> not every language is recursively enumerable
13:29:51 <dolio> Nils Anders Danielsson has an example with his Agda parser combinators. Since he has coinductive grammars, he can parse any language that Agda can recognize.
13:30:03 <Cale> How about languages of infinite words? :)  What's the smallest class of infinite grammar necessary to capture them all?
13:30:35 <Cale> (on a finite alphabet still)
13:31:40 <Cale> Obviously, regular grammars with cardinality c will do, since there are only c-many such words. But can we get away with countable grammars of some sort?
13:32:06 <ezyang> I feel like you could use a diagonal argument to argue the inverse
13:32:54 <dolio> I don't know. Seems unlikely at first blush.
13:33:42 <Philonous> I am undertaking the pointless task of writing a tutorial "from functions to computations in 5 steps and back again" and am trying to illustrate the power of arrows. Context free grammars came to mind, and the way nested pairs form a stack. But I don't want to state connections that aren't there
13:33:53 <dolio> The construction for languages with finite strings is to build an infinite n-branching tree, where n is the size of your alphabet, with either 'accept' or 'reject' at each node for whether the language contains the string or not.
13:34:29 <dolio> The straight-forward way to extend that would be to have some kind of omega-far-away nodes, but it'd have uncountably many of those.
13:35:02 <kw317> I'm trying to understand how to use Control.Morphism.Hylo..
13:35:26 <kw317> and implement some of the algorithms from this paper: http://www.springerlink.com/content/h61p218282301335/fulltext.pdf
13:35:53 <ezyang> kw317: Do you know what a hylomorphism is?
13:35:59 <kw317> suppose you have a functor G(X) = 1+C^2*X^3.. how would that look in Haskell?
13:36:02 <kw317> ezyang: yeah
13:40:58 <balor> ghc does a great job of inferring the type signature of functions, why then do I have to supply it?
13:41:24 <kw317> in some cases you need it
13:41:29 <ezyang> balor: type signatures are documentation, and keep GHC from straing too far off the path when you're wrong
13:41:29 <kw317> in many it's just for readability
13:41:38 <balor> ok, thanks.
13:42:01 <kw317> it's nice to see them in the code most of the time, type signatures tell you a lot about what the function does / cannot do
13:42:18 <dolio> Occasionally, if you let inference have free reign, you can get rather non-local error messages.
13:42:40 <mrshoe> for what percentage of functions would you say experienced haskell coders provide type signatures?
13:42:41 <kw317> ezyang: but I know hylomorphisms as anamorphism followed by catamorphism, I don't quite get the categorical definition (yet)
13:43:11 * kw317 wonders about that.. most?
13:43:16 <ezyang> kw317: that's about where I am too. Hopefully someone else can help you :-)
13:43:23 <mrshoe> 80%? 95%?
13:43:31 <Cale> kw317: What categorical definition?
13:43:35 <IceDane> Is it not possible to do something like this? data MyType = Type1 | Type2 ... type Alias = Type1 ?
13:43:38 <Twey> 100% of exposed functions, I would hope
13:43:42 <kw317> all functions that you expect to be used by others
13:43:47 <mrshoe> gotcha
13:44:06 <kw317> Cale: with F-algebras and F-coalgebras and some commuting diagram
13:44:09 <aavogt> IceDane: constructors are in a different namespace than types
13:44:11 <Cale> ah, okay
13:44:18 <ksf> given two arbitrary numbers a and b as well as their sum s, how many permutations of the form f = (+) <$> (a <|> b) <*> f are there such that f = s?
13:44:20 <dolio> kw317: One way to think about hylomorphisms is that they're general recursion where the shape of the call tree is specified by the functor.
13:44:20 <Cale> I suppose that catamorphisms and anamorphisms can be characterised categorically, but they're not terms from usual category theory.
13:44:23 <aavogt> you could define    alias = type
13:44:30 <aavogt> err   alias = Type1
13:44:32 <kw317> Cale: the one I know is that hylo fi psi = cata fi . ana psi
13:44:54 <Cale> yeah
13:45:29 <kw317> so.. if you have something like G(X) = 1+C^2*X^3, how does this thing look in Haskell?
13:45:32 <dolio> And of course, cata g . ana f conceptually builds that intermediate tree, and then destroys it.
13:45:58 <kw317> data G a = G (Either () ((a, a), (G a, G a, G a)))?
13:46:05 <ksf> kw317, g x = 1 + c^2 * x ^ 3
13:46:20 <ksf> dunno where c comes from, though.
13:46:32 <Cale> data G x = GNil | GCons C C (G x) (G x) (G x)
13:46:43 <Cale> er, no
13:46:48 <Cale> data G x = GNil | GCons C C x x x
13:46:56 <Cale> Depends if you want the fixed point :)
13:47:05 <kw317> I think you want the fixed point
13:47:16 <Cale> Then the first one
13:48:31 <kw317> hmm.. then I need to make it a functor
13:48:35 <roconnor> @type uncurry . flip . curry
13:48:36 <lambdabot> forall a b c. ((b, a) -> c) -> (a, b) -> c
13:48:59 <Saizan> you should use the latter and then take the fixed point as Mu G
13:49:19 <kw317> so fmap f (GCons a b x1 x2 x3) = GCons (f a) (f b) (fmap f x1) (fmap f x2) (fmap f x3)
13:49:35 <kw317> Saizan: how?
13:49:52 <roconnor> @type snd &&& fst
13:49:53 <lambdabot> forall a c. (a, c) -> (c, a)
13:50:25 <ksf> hmmm it doesn't matter anyhow. depending on size of a and b, their sum is just too bleeding big anyway, not to mention the permutations.
13:50:49 <Saizan> data G x = GNil | GCons C C x x x; fmap f (GCons a b x1 x2 x3) = GCons a b (f x1) (f x2) (f x3); fmap _ GNil = GNil; newtype Mu f = Mu (f (Mu f)); type GFix = Mu G
13:51:14 <roconnor> @type swap
13:51:15 <lambdabot> Not in scope: `swap'
13:51:18 <roconnor> gah
13:51:27 <roconnor> did we never close that ticket
13:51:37 <Saizan> Mu has the connotation of least fixed point though, maybe you want a less specific name.
13:52:55 <jao> argh. so i have this cabal file that uses some flags. configure and build seem to work as expected. but when i do 'cabal install', the package is reconfigured (i.e., i can see setup being ran again), without any flag, and then rebuilt. rings a bell to anyone?
13:52:56 <Cale> Yeah, in Haskell it's actually the greatest fixed point
13:52:56 <Saizan> however, the idea is that you can write "cata :: Functor f => (f a -> a) -> Mu f -> a" once for all 'f'
13:53:22 <Saizan> jao: yes, that's how it works
13:53:29 <ksf> actuall, the more I force my parser to work with iteratees, the more it _becomes_ iteratees.
13:53:31 <sm> g'day all
13:53:37 <Cale> So I've seen it written with nu instead.
13:53:56 <jao> Saizan: oh. so i need to provide the configuration flags to 'cabal install' instead?
13:54:00 <Saizan> jao: the preferred way is to use "cabal install" and pass the configure flags to that command directly
13:54:17 <kw317> Saizan: but how do you take a fixed point then?
13:54:41 <Saizan> kw317: "Mu f" is the fixed point of f
13:54:47 <jao> Saizan: aha. i see... a bit unintuitive to me, but i guess there are reasons. thanks!
13:55:31 <sm> formatTime formats %Y without leading zeroes.. is that correct behaviour ?
13:56:04 <sm> to get leading zeroes I'm using %f%g, which are "first/last two digits of year for Week Date format". Not sure what Week Date format is, but hopefully this is correct
13:56:13 <kw317> Saizan: is Mu another functor?
13:56:22 <Saizan> newtype Mu f = Mu (f (Mu f));
13:56:32 <kw317> ah
13:57:05 <monochrom> newtype Meow f = ...
13:57:12 <kw317> ;-)
13:57:29 <kw317> ok, I'm going to go and grok all of this
13:57:33 <kw317> thanks!
13:57:35 <Saizan> though s/Mu/Fix/ is more appropriate if you're going to use it for both cata and ana, and it's not the least fixed point anyway
13:57:37 <IceDane> is there a way to parse to the end of a string in parsec? As in, your data has no 'designated end characters', you just want to parse whatevers left?
13:58:04 <IceDane> Parsec, btw.
13:58:13 <monochrom> many (...)
13:58:16 <Saizan> manyTill anyToken eof -- something like this
13:58:30 <Saizan> or just many?
13:58:46 <monochrom> Both works.
13:58:48 <dolio> In a category like the ones Haskell takes its semantics from, least fixed points are the same as greatest fixed points.
13:59:28 <IceDane> many anyChar seems to have worked
13:59:29 <IceDane> thanks
13:59:54 <brooksbp> Does anybody know where I can find formal semantics for the let construct?
14:00:12 <brooksbp> preferably contextual semantics
14:01:33 <mmmulani> http://www.haskell.org/haskellwiki/HXT
14:01:45 <mmmulani> is the answer for exercise 4.3 that they are the same?
14:02:37 <c_wraith> anyone know offhand when the hackage haddock job runs
14:02:38 <c_wraith> ?
14:03:17 <monochrom> brooksbp: The closest is http://www.haskell.org/onlinereport/exps.html#sect3.12 , which reduces to the unformalized semantics of case.
14:03:25 <Cale> "contextual semantics"?
14:03:58 <Axman6> c_wraith: every 6 hours i think
14:03:58 <Saizan> dolio: why is that?
14:04:37 <c_wraith> Axman6: that sounds about right.  thanks
14:07:53 <dolio> Well, I guess the easiest way to try and show it is to treat Haskell as a sort of internal language for the appropriate categories, and since it has general recursion, you can write catamorphisms for any terminal coalgebra, and anamorphisms for any initial algebra.
14:08:05 <Cale> Actually, I'm not sure I particularly like that translation of let... I suppose it results in a smaller core language, but I'm not sure I'd want lazy patterns in the core. I'd prefer having simple let bindings and strict cases.
14:09:03 <dolio> Saizan: I think I've seen something that actually proves for some specific category of domains that intial algebras are terminal coalgebras and vice versa, but that was quite difficult to find, and I don't remember where it is.
14:10:22 <Cale> brooksbp: let/case/lambda are all sort of intertwined, and there's a good deal of freedom available in what you choose to be more primitive.
14:11:15 <Cale> I wonder what choice the early denotational semantics for Haskell used.
14:11:23 * Cale looks it up...
14:11:27 <gwern> *finally*. I made it back to ubuntu jaunty
14:11:31 <gwern> what a waste of 2 days
14:11:38 <monochrom> I prefer one single construct (case) and nonstrictness markups.
14:11:48 <brooksbp> Cale: I'm just wondering where the redex of a "let x = e in c".... You need to evaluate e, then assign it to x, then execute c.... but I don't see how the context/redexes match up
14:11:57 <gwern> (the tide turned when I flashed the bios and made a frankencomputer, which *finally* got my computer to boot off a live CD)
14:12:08 <Cale> brooksbp: No, that's not at all what you do.
14:12:24 <brooksbp> Cale: well... for my own let construct...
14:12:33 <Cale> brooksbp: you evaluate c, and only if x is evaluated, it evaluates to e
14:12:34 <brooksbp> I don't mean Haskell
14:12:38 <Saizan> dolio: heh, i think i see the high-level sketch at least, thanks :)
14:12:55 <Cale> brooksbp: let x = undefined in 5  is 5, not undefined
14:13:01 <brooksbp> Cale: I see... you mean lazy-like?
14:13:05 <Cale> > let x = 5 in undefined
14:13:07 <lambdabot>   * Exception: Prelude.undefined
14:13:12 <Cale> > let x = undefined in 5
14:13:13 <lambdabot>   5
14:13:19 <monochrom> When I first compared implementations of State.Strict and State.Lazy, I could not compare them. Then I translated State.Lazy's let into case+~, and they became directly comparable. Essentially same code, different nonstrictness markups. Completely illuminating.
14:14:25 <monochrom> The duality is complete once we get bang patterns too.
14:15:56 <Cale> I really dislike how bang-patterns turn let into case.
14:16:00 <aavogt> preflex: zdec sybzmwithzmclasszm0zi6zi1_DataziGenericsziSYBziWithClassziInstances_constrZMacyMZN_closure
14:16:00 <preflex>  syb-with-class-0.6.1_Data.Generics.SYB.WithClass.Instances_constr[acyM]_closure
14:16:09 <dolio> You can't take let as the sole primitive, though, because it can't do branching.
14:17:02 <mauke> hmm, bong patterns
14:17:27 <dolio> Dave's not here, man.
14:17:57 <Saizan> aavogt: as a wild guess: cabal install syb-with-class-0.6.1 --reinstall --disable-documentation
14:18:31 <aavogt> Saizan: I'm trying to compile happstack-data-0.4.1 with profiling
14:18:57 <Saizan> "cabal install syb-with-class-0.6.1 --reinstall --disable-documentation -p" then
14:19:02 <Cale> The original translation of bang patterns was more consistent, I think.
14:19:17 <Cale> Now it's really complicated
14:19:23 <monochrom> I love four-corner symmetries like let, case, ~, !
14:19:49 <MissPiggy> monochrom you know linear logic
14:20:02 <monochrom> I don't know linear logic.
14:20:05 <MissPiggy> oh
14:20:12 <dolio> You should learn it.
14:20:17 <MissPiggy> there is symmetry you can enjoy :)))
14:20:19 <dolio> Everything comes in pairs.
14:20:23 <lament> four-corner time symmetries
14:20:27 <MissPiggy> lol
14:20:30 <dolio> Even more pairs than regular logic.
14:20:54 <monochrom> I counter-propose temporal algebra to you.
14:21:06 <aavogt> terminal algebra
14:21:09 <MissPiggy> I need algorithms
14:21:12 <MissPiggy> hi shapr
14:21:15 <Saizan> aavogt: there's a bug in Cabal that makes a build break if you use haddock and there are symbols' names generated via TH
14:21:21 <MissPiggy> I need numerical I think I need TAOCP
14:21:24 <shapr> Anyone know when ghc6 will be updated to 6.12 in ubuntu karmic?
14:21:30 <MissPiggy> no
14:21:39 <Cale> shapr: It probably won't?
14:21:42 <shapr> :-/
14:21:47 * hackagebot upload: hslogger 1.0.9 - Versatile logging framework (JohnGoerzen)
14:21:49 <dolio> Cale: The current let ! makes letting of unboxed types more uniform, at least.
14:21:54 <Cale> shapr: Not that I know for sure, but going on the pattern of history.
14:22:09 <eflister> hi -- i'm trying to use untilM in some threads to produce events.  i expect to get a lot of events but i only get one per thread -- maybe cuz of laziness?  could anyone take a look?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21112
14:22:09 <shapr> suck
14:22:25 <Cale> shapr: I've learned not to trust ubuntu's packages for GHC.
14:22:53 <Polarina> I compile ghc myself. :)
14:22:56 <Cale> shapr: I always just install the generic linux binary.
14:23:03 <shapr> :-/
14:23:06 <lispy> Yeah, never trust debian/ubuntu to package GHC
14:23:08 <Cale> Compiling yourself is a waste of time unless you're also hacking on it.
14:23:28 <Cale> (especially as you need a working GHC to compile GHC)
14:23:31 <Zao> I think I run on Fedora GHC packages now. Rather sane.
14:23:41 <lispy> I've seen so many beginners give up in frustration because they started with the Debian/Ubuntu package
14:23:48 * hackagebot upload: darcs-benchmark 0.1.5.1 - Comparative benchmark suite for darcs. (EricKow)
14:23:56 <dolio> I compile GHC 3 times in a row, for best performance, just like on Gentoo.
14:24:09 <Polarina> dolio, the ghc build thingy does that already.
14:24:19 <dolio> That was a joke. :)
14:24:24 <Zao> dolio: Any attempts I've had at compiling GHC ends in segfaults in stage2 :)
14:24:25 <monochrom> temporal algebra: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.50.9227
14:24:38 <Cale> The Debian guys, for some stupid reason, split GHC up into dozens of tiny packages which have to be separately installed, and as far as I can tell, provide no meta-package to get the equivalent of installing GHC properly.
14:24:53 <Zao> Cale: And for great justice, intermingle "core" packages with things like xmonad.
14:25:13 <Zao> So installing libghc6-* pulls in half the world.
14:25:18 <Cale> yep
14:25:47 <tavelram> so true.
14:25:48 <jao> Cale: i've got  ghc 6.12.1 installed in my debian sid without a glitch. i install all my libraries using cabal, though.
14:25:55 <Cale> It's so much easier just to install the linux binary, and then bootstrap cabal-install than to do anything else.
14:26:21 <Zao> I used to use the distro xmonad, so the GHC that pulled in survives.
14:27:27 <monochrom> Isn't it Ian Lynagh who did the split up?
14:27:34 <eflister> hey anyone think they could help me make my threads produce a lot of events instead of only one each?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21112
14:27:51 <Zao> Looking at the Fedora reposes, it seems equally split.
14:30:35 <Heffalump> it's the obvious thing to do
14:32:00 <Cale> This is a good example of what I consider the wrong way to use monad transformers. This code is being made more complicated by the introduction of the transformers than it would be written in a direct style.
14:32:29 <eflister> cale: yeah i'm just learning :)
14:32:58 <eflister> cale: this is a very stripped down minimal example of something from a larger system where i think they help.
14:34:12 <Zao> Heffalump: It feels wrong to finely chop something that's distributed as a lump by upstream.
14:34:42 <ksf> Cale, rant about debian on reddit.
14:35:00 <ksf> or, actually, lispy.
14:35:06 <ksf> you've got more emotional reasons.
14:35:08 <MissPiggy> is there a guide on making cabal/ghc-pkg work?
14:35:13 <Cale> ksf: Why?
14:35:30 <Cale> ksf: There's an easy way to avoid the problem altogether: don't use debian's packages.
14:35:38 <ksf> ...if they're producing that amount of bunk, they should just leave ghc out alltogether.
14:35:58 <Cale> I tend not to use my distribution's packages for any of the software that I really deeply care about.
14:36:31 <Cale> Other people, who care less about the condition that their GHC is in, but just need it to compile something random, will probably be fine with the Ubuntu/Debian packages.
14:36:53 <Cale> I also don't use Ubuntu's packages for firefox, for instance.
14:36:54 <ben> Cale: Does that not strike you as a problem with your distribution? :/
14:37:35 <Cale> Not particularly. It would be nice if they produced packages that were always up to my personal standards, but I can understand how that's not really very easy to do.
14:37:55 <ksf> why should someone who uses a binary distro and doesnt care about ghc's condition need to install ghc?
14:37:59 <ulfdoz> Cale: You may want gentoo.
14:38:00 <Cale> Ubuntu has more serious problems than its support for GHC.
14:38:10 <Cale> Gentoo is *way* more seriously fuct.
14:38:18 <lispy> ksf: I don't use reddit and I've mentioned it to debian maintainers.  From their point of view the packaging is correct, but an appropriate virtual package is simply missing.
14:38:22 <ben> I basically use my distribution's packages because I do not trust myself to install ghc properly
14:38:31 <Cale> Gentoo is a massive waste of electricity.
14:38:46 <ksf> tbh, I installed ghc via portage, too.
14:38:57 <ksf> ...but I don't use it for the rest
14:39:24 <ksf> except xmonad. it's nice if it survives wiping ~/.cabal
14:39:25 <monochrom> @remember Cale Gentoo is a massive waste of electricity.
14:39:26 <lambdabot> It is forever etched in my memory.
14:39:29 <ulfdoz> Cale: If it does, what I need, I can afford it.
14:39:31 <midfield> conal: i'm looking for example code for how to use Control.Arrow.Operations and Control.Arrow.Transforms.  all the papers i've read are fascinating but i'm a bit short on basic details.
14:39:31 <monochrom> :)
14:39:50 <Cale> I don't want my machine to compile everything. In fact, it would be best if I never had to compile anything at all, though I'm marginally content with compiling Haskell libraries via cabal.
14:39:52 <conal> midfield: i don't know those modules.  does anyone else?
14:40:28 <Zao> I'm abusing syb a lot. Halp.
14:40:33 <conal> midfield: do you have a doc URL, e.g. on hackage?
14:40:39 <Cale> (It would be better if cabal had some system of binary distribution though.)
14:40:47 <Zao> Like Bamse on Windows?
14:40:49 <midfield> oh, i thought you used them in your bot hackage package.
14:41:11 <midfield> conal: it's the arrows package.  http://hackage.haskell.org/package/arrows
14:41:25 <conal> midfield: maybe i did use them and then forgot.  thx.
14:41:53 * hackagebot upload: MissingH 1.1.0.3 - Large utility library (JohnGoerzen)
14:43:15 <iaefai> A question somewhat related to haskell: I am implementing a menu for a game, and using s-expressions as the basis of the menu, a sample shown here: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21122#a21122  (where menu, button, get, etc. are interpreted at runtime). I remember fondly the hackage format was quite nice to read. Could that format potential work in this case?
14:43:25 <eflister> hey could anyone help me figure out how to get my threads to produce more than one event each?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21112  cale -- any specific advice?
14:44:38 <conal> oh, hrmf.  my bot package has fallen behind the times w.r.t Arrow & Category.
14:45:12 <midfield> conal: bot is not alone in this.....
14:46:00 <midfield> conal: also was wondering what your opinions were on Liu's causal commutative arrows thing, if you've looked at it.
14:46:19 <conal> midfield: i like it.
14:46:22 <Cale> eflister: Well, it has nothing to do with laziness, I'll tell you that much :)
14:46:41 <midfield> conal: i thought it was pretty nice.  although extending it to include ArrowChoice might be tricky.
14:46:45 <conal> midfield: i like how he abstract he's able to keeps things
14:47:04 <eflister> cale: hm ok...  why aren't the untilM's looping?
14:47:20 <Cale> Well, perhaps p x is True?
14:47:30 <Peaker_> @check liftA2 (==) (:[]) id
14:47:31 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
14:48:00 <Cale> oh, supper
14:48:12 <Peaker_> @check liftA2 (==) (:[]) return
14:48:13 <lambdabot>   "OK, passed 500 tests."
14:48:15 <midfield> conal: the application i have in mind is something like FRP / CCA, but maybe a little different.  i'm interested in online restartable computations.
14:48:33 <conal> midfield: neat!
14:48:38 <ksf> .oO( what I basically need to do, is reducing <|> to fix )
14:48:57 <midfield> conal: an example would be a (weighted) running average of a discrete sequence of numbers.  but maybe the sequence is only available once a day, so you want to be able to save and restart the computation.
14:49:00 <eflister> cale: it shouldn't be until stop runs -- i think the untilM's don't start until stop runs, when logs start wanting to get printed -- that's what i mean by lazy...
14:49:45 <conal> midfield: oh -- cool idea.
14:50:06 <conal> midfield: maybe something like the Automaton transformer
14:50:11 <midfield> conal: i tried using a monadic setup but i ran into difficulties.
14:50:30 <conal> midfield: like the ones described in the first Arrows paper?
14:50:31 <MissPiggy> @pl ((:[]),return)
14:50:31 <lambdabot> (return, return)
14:50:48 <conal> midfield: (the application to web programming)
14:50:50 <MissPiggy> PL = Prove equaL
14:51:19 <midfield> conal: yeah, or a combination of that with the state arrow.
14:51:31 <midfield> conal: i mean, it's like a mealy machine with saveable state.
14:51:42 <conal> midfield: sure
14:51:46 <midfield> conal: the application i had in mine was long-running statistical computations.
14:51:52 <ksf> eflister, scatter a couple of traces througout your code
14:52:28 <midfield> conal: the data comes intermittantly.  you want to be able to look at intermediate results, you want to be able to update the results in at a later time when more data comes in.
14:53:02 <ksf> ...and storing IO actions in mvars sounds fishy to me
14:53:29 <conal> midfield: i like your idea very much.  logically a single, ongoing computation, but only very rarely consuming any memory or cpu resources (even threads/processes).
14:54:25 <midfield> conal: i'm somewhat of a haskell beginner, my background is in mathematics.  so making the typeclasses and all work has been challenging.
14:54:34 <aavogt> Saizan: thanks, that worked
14:54:56 <copumpkin> midfield: typeclasses are relations on types!
14:55:00 <copumpkin> zomg
14:55:12 * MissPiggy wants to ask midfield if he knows how to factor gaussian integers
14:55:28 <conal> copumpkin: amen!  that's why the word "class" is so awkward in this context.
14:55:45 <copumpkin> yeah :)
14:55:50 <conal> copumpkin: a "binary class"?  "binary relation" fits better.
14:55:56 <copumpkin> definitely
14:55:58 <conal> a class/set is a unary relation.
14:56:09 <copumpkin> I guess MPTC was an afterthought
14:56:40 <conal> i agitated a bit about "class" vs "relation" in the mid-90s.
14:56:46 <midfield> conal: you can see an older question i had on this topic (when i was thinking in terms of monads) here http://www.haskell.org/pipermail/haskell-cafe/2009-September/066977.html
14:57:07 <conal> answer i got was that "type relation" was already meaning-loaded from parametricity.
14:57:15 * MissPiggy still hasn't found anyn good algorithm
14:57:17 <copumpkin> ah, I see
14:57:25 <copumpkin> alright, gotta run, food awaits :)
14:57:26 <midfield> conal: later on i realized that i needed something different, maybe comonads or arrows.  that's where i'm at now.....
14:57:27 <copumpkin> I'll be back later
14:58:46 <conal> midfield: do you really want a state-style interface?
14:59:00 <conal> midfield: sounds like a very functional/non-state sort of problem space
14:59:53 <conal> midfield: just a first impression
14:59:56 <midfield> conal: i didn't know how to solve the "save the world" problem without keeping track of state, and using Binary.
15:00:19 <conal> midfield: hm.  implementation issues creeping into interface design?
15:00:43 <midfield> conal: for sure.  i'm trying to not compromise my principles.  that's why i'm asking you!
15:00:50 <conal> heh
15:01:45 <midfield> conal: there is a "streamarrow" interface to statearrows, where you just pass the (next) state up the stream.  that would hide some of it.
15:02:30 <Cale> eflister: tell should never prevent the remainder of the computation from continuing.
15:03:00 <Cale> eflister: Perhaps you're somehow getting yourself into deadlock?
15:03:06 <midfield> eflister: hey is this erik flister who used to live in austin?
15:03:16 * MissPiggy is confused, if I have a proof that this is a UFD why don't I have an algorithm to factorize?
15:03:25 <eflister> midfield: yeah ha that's funny
15:03:42 <theorbtwo> Constructive vs nonconstructive proof.
15:04:05 <theorbtwo> Proving that something exists does not neccessarly tell you much about how to find it.
15:04:10 <eflister> cale: i'm making some traces...  seems the forkIO doesn't start the threads til the last minute
15:04:15 <Nereid_> proof that what is a UFD?
15:04:37 <Cale> eflister: That doesn't make much sense. forkIO starts a thread immediately, and doesn't block
15:05:10 <conal> midfield: i wonder about another approach, in which you keep *very* close to classic functional style.  say you start with defs for lists, maybe point-free, and then replace the list functions with semantically equivalent ones that work on these "intermittent lists" (for lack of a better term)
15:05:44 <conal> midfield: e.g. you're not likely to write "get" & "put" in the list versions.
15:05:55 <conal> midfield: but rather map, filter, fold.
15:06:01 <midfield> conal: my original versino was a big mapAccumL or something.....
15:06:11 <conal> midfield: cool.
15:06:34 <MissPiggy> Nereid_ gassian integers
15:06:35 <midfield> conal: but then i couldn't figure out the stop/start thing.  i wanted to avoid state-passing but i can't seem to get around it.
15:06:40 <Nereid_> ah
15:06:51 <midfield> eflister: your beard is huge!
15:06:58 <conal> midfield: can't avoid *explicit* state passing (ie in the interface)?
15:07:18 <eflister> midfield: who do i know in math... ben lee?
15:07:29 <midfield> eflister: yeah that's me
15:07:48 <eflister> midfield: ha ha crazy.  i was actually wondering if you were getting into haskell...
15:08:18 <eflister> midfield: i guess it's big among the finance peeps?
15:08:22 <midfield> eflister: i've been psyched about it for some time now, though haven't had the time to do much serious.
15:08:31 <midfield> eflister: i wouldn't know
15:08:52 <eflister> midfield: i thought i heard that's what you were doing.  i'm doing some music stuff with it...
15:09:01 <midfield> eflister: though i've heard lennart and others have worked in finance for a while
15:09:35 <midfield> midfield: i'm working on a double secret skunkworks project!
15:09:42 <midfield> eflister: heh.
15:10:05 <eflister> midfiel: cool, i'm just finishing a neuro phd.  have to find a postdoc..
15:10:16 <midfield> conal: i started doing some explicit state-passing in the mapAccumL interface, and then decided to try to use the state monad, and then decided to try arrows.....
15:10:19 <Nereid_> MissPiggy: well if a and b are gaussian integers, then N(ab) = N(a) N(b) (where N(x+yi) = x^2+y^2)
15:10:27 <Nereid_> so you can try factoring N(ab) (which is an integer)
15:10:30 <Nereid_> er
15:10:35 <Nereid_> N(a) where a is what you want to factor
15:10:35 <midfield> conal: still trying to understand the right way to set it up
15:11:01 <Nereid_> not sure if that helps much
15:11:10 <eflister> midfield: dunno if it's relevant, but have you seen the typeclassopedia?
15:11:11 <Peaker> midfield: I think maybe it's better to figure out what combinator you want first, and then later decide what type-class semantics it fits to best
15:11:16 <MissPiggy> Nereid_ yeah so if N(a) factors into n_0*n_1*...n_m then what do you do? generate every Gass integer with Norm n_0 and then see if you can divide a with it?
15:11:29 <Nereid_> that's why I said I'm not sure if that helps much
15:11:30 <Nereid_> :(
15:11:34 <MissPiggy> hehe
15:11:39 <MissPiggy> I have no idea how to factor these guys
15:12:05 <Peaker> midfield: Do you know Iteratee? What you described sounds a bit similar to that...
15:12:36 <conal> midfield: i'm with Peaker.  connecting with type classes will give you some feedback on your semantic design (as in my type class morphisms paper), but i begin a design with concrete semantic models.
15:13:24 <conal> midfield: since type-classes are nearly semantics-free -- compared with your actual types.
15:13:28 <pastorn> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21135#a21135 <-- help me make it work!
15:13:31 <pastorn> i wantz it
15:13:32 <Cale> MissPiggy: Yeah, that'll do.
15:13:47 <midfield> Peaker: yes, i thought about using iteratee.  the issue i had with it is that it seemed to be "inside-out" many times.  the reason why i wanted to use haskell was to have code that expressed what i wanted naturally -- i didn't look closely but iteratee might have been inverted for me.
15:14:01 <midfield> Peaker: but i will take another look, thanks.
15:14:03 <MissPiggy> Cale, basically brute force then?
15:14:24 <Cale> MissPiggy: Well, there is a more clever way
15:14:31 <MissPiggy> oh!! I want to know about that :)
15:14:45 <Peaker> midfield: I think Iteratee is explained poorly and the names are horrible.. mind if I try to explain it shortly?
15:15:04 <Peaker> (Maybe others can give me feedback about my explanation, whether it is inaccurate/incomplete)
15:15:41 <midfield> Peaker: go ahead.  i think i understand it alright, but i haven't thought clearly about how to phrase what i wanted in their terms.  perhaps it is easy.
15:16:27 <pastorn> is there any well grounded reason why i can't make a monad for
15:16:35 <pastorn> type State s a = s -> (a,s)
15:16:41 <Peaker> What they call Iteratee would better be called Consumer.   Consumer a = WantData (Message a -> Consumer a) | Completed        Message is basically a chunk, notification of completion, or "error".  What they call Enumerator would better be called Producer.  Producer a = Consumer a -> Consumer a  (From hungry to full).
15:17:19 <Peaker> pastorn: Well, there's a monad instance for (a -> b),  having another instance for   s -> (a, s)    would overlap and differentiating the two would be problematic
15:18:20 <Cale> MissPiggy: Well, first thing you should notice is that if z = a+bi and a^2 + b^2 is prime in Z, then z is prime in Z[i].
15:18:27 <midfield> Peaker: wow looks like oleg has some new iteratee stuff since i last looked
15:19:01 <midfield> Peaker: thanks for reminding me, i'll give it another go
15:19:18 <Cale> MissPiggy: A corollary of this is that if p is a prime in Z which can be written as the sum of two squares p = a^2 + b^2, then a+bi is prime in Z[i].
15:19:59 <Peaker> midfield: I liked the idea behind Iteratee very much, but when I looked at the code I found it less elegant than it could be - and there were some annoying issues I had (need to compose producer with EOF-producer to produce a completing input)
15:20:34 <pastorn> Peaker: ype synonym `State' should have 2 arguments, but has been given 1
15:20:36 <pastorn>     In the instance declaration for `Monad (State s)'
15:20:37 <Peaker> midfield: I wanted to give reimplementing Iteratee a shot sometime, but then I saw some aspects improve. I hope they fix the names.. Iteratee/Enumerator  is pretty awful compared to  Producer/Consumer and so
15:20:44 <Cale> MissPiggy: There's a theorem that an odd prime p can be written as a sum of two squares iff p = 1 (mod 4).
15:20:44 <pastorn> Peaker: so no, that's not it :(
15:21:00 <Peaker> pastorn: well, there are even earlier issues regarding type synonym instances, then
15:21:07 <conal> Peaker: i'd expect producer to be a functor and consumer to be a contra-functor.  are they?
15:21:21 <Cale> and as a corollary to that, if p is a prime in Z, and p = 3 (mod 4), then p is a prime in Z[i]
15:22:02 <Nereid_> and all of that is mentioned in the wikipedia page on the gaussian integers.
15:22:05 <Nereid_> :]
15:22:21 <Cale> It probably is ;)
15:22:34 <MissPiggy> Cale oooh I see
15:22:47 <midfield> Peaker: one thing that is appealing about arrows is that they have thought about things like merging streams, conditionals, looping and the like.  i'll have to take a look closer at what oleg has done in this regard.
15:22:58 <MissPiggy> I was trying to use pythagorean triples, but the thing is p wasn't a square
15:23:06 <Cale> So, we get that the primes in Z[i] are the following (and their associates -- multiplying by 1,-1,i and -i)
15:23:30 <Cale> We have 1+i and 1-i lying over 2 in Z.
15:23:51 <Cale> and then each prime p in Z which is congruent to 3 mod 4.
15:24:19 <Cale> and then a + bi and a - bi where (a+bi)(a-bi) = a^2 + b^2 = p where p is prime in Z with p = 1 (mod 4)
15:25:06 <Nereid_> such as 3 + 2i
15:25:15 <Peaker> conal: I don't think either is ContraFunctor
15:25:39 <Polarina> http://codepad.org/XzGofrLF
15:25:45 <Polarina> I am a proud coder. :)
15:25:50 <conal> Peaker: oh, interesting.  i think of contrafunctors as typically being consumers.
15:26:36 <ksf> Consumer is good, but I'm generally unconfortable with any name for Consumer a -> Consumer a
15:26:56 <dmwit> Polarina: Nice!
15:27:03 <Peaker> conal: I forgot an important detail, a Consumer has a result too
15:27:04 <dmwit> Polarina: Though totally unreadable. =)
15:27:15 <ksf> ...there's too much things you can do with that. either enumerate, or transform.
15:27:16 <jmcarthur> producer and consumer seem more general than what interatee is
15:27:29 <jmcarthur> *iteratee, even
15:27:41 <MissPiggy> Cale: so it means there are only a small number of cases I need to check -- each time I want to take out a factor?
15:27:54 <Nereid_> Polarina: I don't think it's correct -- try q [2,1,2,3]
15:27:54 <SubStack> conal: looks like I can use your vector-space module to solve for camera ray intersections with volume solids on the gpu :D
15:28:00 <Nereid_> oh wait, nbm
15:28:01 <Nereid_> nm
15:28:03 <Nereid_> :-)
15:28:05 <SubStack> with some other code of course
15:28:14 <Polarina> :)
15:28:22 <ksf> ...iteratee itself is also a more generic term than that strange continuation stuff iteratees are.
15:28:33 <conal> SubStack: sweet!  i'm also using that module for gpu computations.  both vectors and derivatives.
15:28:37 <Peaker> conal: Something along: Consumer a r = WantData (Message a -> Consumer a r) | Completed r -- so   return = Completed ; (>>=) is probably like the Cont bind here
15:29:19 <Peaker> jmcarthur: why more general?
15:29:45 <Cale> MissPiggy: So suppose we want to factor something like 4 + 3i. N(4 + 3i) = 25, and so if (4 + 3i) = (a + bi) (c + di), then we know that 25 = (a^2 + b^2) (c^2 + d^2)
15:29:58 <ksf> Completed doesn't mean the iteratee is "finished"
15:30:02 <ksf> it's more like Yield
15:30:09 <ksf> and I like Stall for WantData
15:30:48 <conal> SubStack: school project? hobby?  work?
15:30:55 <SubStack> first two
15:31:16 <Peaker> ksf: looking at the code, Completed (called Done there) does actually seem to mean the consumer is completed (but the next consumer bound to it may continue where it left off)
15:31:41 <SubStack> conal: basically, I'm tired of solving for camera-ray intersections by hand
15:31:43 <Peaker> ksf: I dislike how the consumer is allowed to inject data into the stream (to the next consumer), that seems to violate the guarantees it should be providing
15:31:45 <Cale> So, if this thing is going to factor nontrivially, it'll have to factor into two parts which have norm 5.
15:32:04 <Cale> (which is congruent to 1 mod 4)
15:32:21 <ksf> Peaker, that's necessary for them to chain up
15:32:24 <MissPiggy> Cale, I understand that - well, needn't only one of them be 1 (mod 4)?
15:32:38 <Cale> Well, 5 is
15:32:51 <SubStack> conal: but I can unroll the derivatives like http://www.emeyex.com/site/projects/raytorus.pdf does for torus-ray intersections, except generally
15:33:08 <ksf> Peaker, the difference is between Done a EOF and Done a (Stream)
15:33:32 <ksf> ...in the first case, the iteratee says "I can't produce any more"
15:33:55 <conal> SubStack: and you use the derivatives for root-finding?
15:33:57 <Cale> So, we split 5 into a sum of squares, it's 1^2 + 2^2, and so we'll have a = +-2 and b = +-1, or a = +-1 and b = +-2.
15:34:01 <SubStack> conal: yep!
15:34:10 <SubStack> conal: well that's the idea anyways
15:34:19 <conal> SubStack: nice!
15:34:22 <SubStack> still need to put the pieces together
15:34:31 <SubStack> seems like this approach should work though
15:34:44 <conal> SubStack: are you using OpenCL?  something else?
15:34:45 <Cale> We can divide 4+3i by 1+2i to obtain a remainder of 2-i, which is prime.
15:35:03 <SubStack> conal: just glsl for now
15:35:16 <MissPiggy> since you got a remainder, that means 1+2i isn't a factor
15:35:23 <MissPiggy> so you try the next one?
15:35:26 <Cale> er, not a remainder
15:35:28 <Nereid_> he meant quotient, not remainder
15:35:29 <Nereid_> :)
15:35:31 <Cale> a quotient, sorry
15:35:32 <Cale> yes
15:35:39 <conal> SubStack: me too.  cuda & opencl intimidated me last i looked.  and i'm targeting iphone etc.
15:35:45 <Peaker> ksf: I must be misunderstanding then - I thought "Done a EOF" would mean the Iteratee simply doesn't have any part-chunk left?
15:35:45 <MissPiggy> oh so it's literally: 4+3i=(1+2i)(2-i)
15:35:48 <Nereid_> yes
15:36:04 <xerox> 1+2i is prime!
15:36:10 <Nereid_> indeed
15:36:13 <Peaker> ksf: Also, "necessary to chain up" - I am not sure. Could always give up the "chaining" notion, and avoid lookahead, and then you don't need it
15:36:15 <Cale> I meant remainder in the less technical sense, but that's confusing here :P
15:36:37 <MissPiggy> sorry
15:36:49 <Nereid_> especially Z[i] is indeed a euclidean domain
15:36:49 <Nereid_> :/
15:36:55 <Nereid_> especially since*
15:36:59 <Cale> yeah
15:37:03 <ksf> Peaker, it means both.
15:37:29 <ksf> ...by chaining, I mean the equivalent of map toUpper . map toLower . map foo ...
15:37:30 <MissPiggy>  so suppose I can compute all the numbers whos squares sum to n
15:37:37 <ksf> just that it's all concatMaps.
15:37:56 <ksf> (well, at least with convStream, that is)
15:37:57 <Cale> MissPiggy: Yeah, for each prime factor which is congruent to 1 mod 4.
15:38:29 <adu_> wow
15:38:30 <Peaker> ksf: I guess my intuitive understanding of Iteratee is incomplete. I should toy around with it some more
15:38:30 <Cale> The ones which are congruent to 3 mod 4 could only have come from normal integer primes.
15:38:36 <MissPiggy> because if it's nto = 1 (mod 4) then it's not prime
15:38:53 <MissPiggy> ah this is  the case where a+ib, a and b are nonzero
15:39:00 <Cale> yeah
15:39:04 <ksf> I don't think anyone who didn't yet implement them understands them.
15:39:09 <MissPiggy> if one of a or b are zero you can use integer factorization
15:39:59 <ksf> continuations, especially oleg-style, are as problematic to functional programmers as recursion is to imperative programmers...
15:40:01 <adu_> i just learned about Mondrian, and it is part of the most complicated compilation pipeline i've ever seen!
15:40:58 <dmwit> eh?
15:41:05 <MissPiggy> Cale, oh and I should divide out the gcd (a,b) first of all -- so that all the factors left are of the same a,b nonzero form!
15:41:08 <dmwit> There's a compilation pipeline that goes via *mondrian*?
15:41:19 <adu_> Haskell -> GHC Core -> Mondrian -> Mondrian Core -> CIL -> x86
15:41:29 <dmwit> augh
15:41:31 <adu_> ya
15:41:32 <mauke> well, at least it's not Piet
15:41:32 <dmwit> Why?
15:41:48 <Cale> MissPiggy: Basically, you just factor the norm, and then for each of the primes which is congruent to 1 mod 4, you do a little more work.
15:42:20 <dmwit> Oh, I was thinking of Piet.
15:42:25 <adu_> dmwit: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.11.7425
15:43:08 <MissPiggy> Cale factoring polynomials is soo much easier :)
15:43:13 <MissPiggy> univariate ones...
15:43:20 <MissPiggy> multivariate is probably really hard
15:43:26 <Cale> adu_: You could stick something else which compiles to Haskell on top of that ;)
15:43:37 <dmwit> agda
15:43:42 <adu_> Cale: lol
15:43:48 <dmwit> or cayenne
15:43:53 <MissPiggy> thanks for tell me this Cale by the way it's great!
15:44:00 <Nereid_> yeah polynomials is easy
15:44:07 <dmwit> Let's see how mondrian handles all those unsafeCoerce#'s!
15:44:37 <adu_> ouch
15:44:41 <mauke> well, Piet would have been cooler
15:44:42 <MissPiggy> Nereid_ -- my algorithm is to pick a,b such that a+b = n, to factor an order n polynomial: then you just multiply them together and solve the linear system
15:44:50 <mauke> also, better looking object files
15:44:54 <MissPiggy> Nereid_ is it a kind of stupid/suboptimal way? :)
15:45:01 <Nereid_> look up Kronecker's method
15:45:02 <Nereid_> :)
15:45:18 <MissPiggy> Nereid_ (of course I can pull out all the linear factors from rational roots)
15:45:38 <MissPiggy> ohh
15:45:42 <MissPiggy> this looks way better than mine
15:46:01 <Nereid_> works over any UFD
15:46:19 <MissPiggy> this is great news for me :)
15:47:17 <adu_> speaking of pipelines, I was noticing how easily GHC Core can be mapped to MathML...
15:47:40 <ezyang> Oh?
15:47:50 <Nereid_> and I don't see why you can't extend it to multivariate polynomials
15:48:18 <Nereid_> since D[x1,...,xn] = D[x1]...[xn] and polynomial rings over UFDs are UFDs
15:48:22 <MissPiggy> Nereid_: well if it works over any UFD, I guess that I can use it on Z[x] to factor polynomials in (Z[x])[y] which is equvi to Z[x,y]
15:48:27 <Nereid_> yeah
15:48:31 <MissPiggy> Nereid_ yeah! it will be interesting to try that out
15:48:45 <waterlaz> adu_, how good are you at GHC Core?
15:49:14 <adu_> waterlaz: I can read it, and edit it, but i cannot write it
15:49:23 <waterlaz> why are the case statements are all reversed?
15:51:32 <Nereid_> MissPiggy: I see a problem
15:51:39 <adu_> waterlaz: afaik, the only reordering that must happen is that all (_ -> ...) cases are put at the beginning
15:51:53 <MissPiggy> oh what is it?
15:52:10 <Nereid_> if f in R[x,y] is irreducble over R[x], is it irreducble over R?
15:52:31 <waterlaz> adu_, well I somehow always had the __DEFAULT pattern always the first
15:52:51 <adu_> waterlaz: ya, the GHC Core spec says %_ must come first
15:53:01 <MissPiggy> hm
15:53:10 <waterlaz> if I tried to write the same thing in normal haskell it would result in overlapping patterns
15:53:11 <MissPiggy> I don't even undersatnd
15:53:27 <Nereid_> although
15:53:28 <MissPiggy> it means that say, you factored m \in R[x,y] = a*b*c*d
15:53:38 <Nereid_> I suppose
15:53:45 <adu_> waterlaz: I think that error message happens before the Core stage
15:53:46 <Nereid_> even if that's not true
15:53:49 <MissPiggy> then perhaps some of a,b,c and d are reducible in R?
15:53:59 <Nereid_> say you factor f in R[x,y] into irreducibles over R[x]
15:54:05 <Nereid_> and then factor each one into irreducbles over R
15:54:06 <Nereid_> and then you're done
15:54:12 <MissPiggy> aha
15:54:18 <MissPiggy> so it is a little different
15:54:25 <Nereid_> indeed
15:54:33 <MissPiggy> I will try and figure out if I can see a way to unify them
15:55:07 <waterlaz> adu_, well but the core code works fine while regular haskell with __DEFAULT being first always matches the first pattern
15:56:09 <Nereid_> wait
15:56:10 <waterlaz> I can live with this ofcourse. I just don't get why is this different
15:56:20 <Nereid_> MissPiggy: now I'm not sure even that works
15:56:23 <Cale> Uh, don't you need polynomial division to implement Kronecker's algorithm?
15:56:41 <Cale> R[x] is a EucD, but R[x,y] isn't.
15:56:41 <Nereid_> I don't think so
15:56:50 <Nereid_> it works over any UFD
15:57:01 <MissPiggy> wel polynomial division is one of the easier algorithms
15:57:09 <Cale> Well, perhaps I'm thinking of a different algorithm.
15:57:12 <Nereid_> possibly
15:57:20 <Nereid_> I'm looking at p.166-167 of Hungerford.
15:57:38 * Cale opens Hungerford :)
15:57:48 <MissPiggy> I am not in the Hungerford club :(
15:57:51 <Nereid_> :(
15:58:06 <MissPiggy> nice I like books called "Algebra"
15:58:21 <medfly> Hunger ford.
15:59:08 <adu_> waterlaz: I have no idea, but I would imagine it would be to simplify the "else" handling code, i.e. instead of (execute findLast), its just (execute 0)
15:59:59 <waterlaz> ok, thanks.
16:00:19 <waterlaz> I've read a few articles on the Core and none even mentioned t
16:00:21 <waterlaz> *it
16:00:58 <adu_> waterlaz: I'm looking at "An External Representation for the GHC Core Language" page 11, paragraph 1
16:01:00 <Cale> Wait, this description makes no sense. He just starts using F randomly, and seems to assume that it's a field.
16:01:24 <gwern> Cale: what else could F be? a flapjack?
16:01:29 <MissPiggy> maybe it's the feild of quotients
16:01:31 <Nereid_> wow, what
16:01:47 <Nereid_> Cale: it says F is the quotient field of D
16:02:00 <MissPiggy> because you can reduce factoring in Z to factoring in Quot(Z) = Q
16:02:01 <Cale> oh, sorry, yes
16:02:06 <MissPiggy> wait I meant that the other way around
16:02:20 <MissPiggy> oh whatever, it works both ways
16:02:27 <waterlaz> adu_ I only read the draft for 5.02 (2001)
16:02:29 <Cale> Okay, yeah, we can use the fact that F[x] is a Euclidean domain.
16:02:34 <ickane> /i/fdksal'
16:02:36 <waterlaz> *for ghc5.02
16:02:37 <ickane> sorry
16:02:54 <adu_> waterlaz: mine says (For GHC 6.10)
16:03:10 * MissPiggy wondrse what does prime mean O_O
16:03:11 <Nereid_> Cale: why is it a euclidean domain?
16:03:17 <waterlaz> ok, I'll google for a newer version then. Thanks
16:03:26 <Cale> Because F[x] is a Euclidean domain for any field F.
16:03:29 <Nereid_> MissPiggy: p is prime if p|ab => p|a or p|b
16:03:48 <MissPiggy> hmm oh that's a really nice definition
16:03:55 <Nereid_> Cale: oh duh.
16:03:57 <Nereid_> :P
16:04:05 <Cale> "Check to see if the polynomial g of part (c) is a factor of f in F[x]"
16:04:12 <Cale> If that were D[x] instead, that's much harder.
16:04:12 <Nereid_> MissPiggy: p is irreducble if ab = p => a or b is a unit
16:04:26 <Nereid_> in a UFD, prime and irreducble are the same
16:04:52 <Cale> Oh, you need a little more than UFD here. You need UFD with finitely many units.
16:05:00 <Nereid_> I should also say in both cases that p is not a unit.
16:05:05 <Nereid_> Cale: indeed
16:05:47 <SubStack> I can't seem to find any good modules for polynomial expansion. Know of any off hand?
16:05:49 <Cale> Wow, this is going to be a remarkably slow algorithm in general.
16:06:07 <Nereid_> no one said it was practical
16:06:16 <Cale> "Try all possible m-tuples of units in D" :)
16:06:33 <ddarius> Only n^m for n units.
16:06:41 <Nereid_> which is fine if D = Z
16:06:59 <adu_> ooo i just heard about the IHG
16:07:13 <Cale> That's still exponential in m which is linear in n.
16:07:40 <Nereid_> I think we're confusing two different n here
16:07:58 <Cale> n is the degree
16:08:16 <Cale> m is the largest number <= n/2
16:08:39 <Cale> So m is linear in n
16:08:44 <Nereid_> but yeah, if D is some large finite field, then ...
16:08:52 <Nereid_> :)
16:08:58 <Cale> Then it's even worse.
16:09:08 <Cale> But even if there are only 2 units...
16:09:16 <Cale> this is exponential in the degree of the polynomial
16:09:52 <Nereid_> indeed
16:09:54 <Cale> You have 2^m ~ 2^(n/2) possibilities to check
16:10:28 <doublenegation> is there any moderately painless way to save image files from haskell? any format would do
16:11:11 <dmwit> doublenegation: There's half a dozen libraries for this on Hackage.
16:11:23 <dmwit> Bindings to libgd, libsdl-image, libgtk2, etc.
16:11:49 <adu_> doublenegation: ya, i was gonna say gd too
16:11:52 <SubStack> too bad libgd is so imperitive
16:12:14 <SubStack> hard to use across threads without segfaults too
16:12:17 <Nereid_> there are certainly improvements to be made to the algorithm
16:12:34 <SubStack> but it's fairly painless for simple stuff
16:12:54 * dmwit awaits bindings to gegl
16:13:08 <adu_> doublenegation: another option is to produce SVG with HXT or something, then call an external app to do the whole svg2png thing
16:14:06 <Nereid_> also presumably D has to have at least n+1 elements
16:15:20 <mm_freak_> i'm failing to parallelize getPrime from Codec.Encryption.RSA.NumberTheory
16:15:24 <eflister> cale and ksf -- can you explain why it can't be laziness?  as best i can tell from tracing, the threads do start immediately, but the working part of them doesn't do anything until stop asks to print out their logs -- and since their only output is via their logs, laziness would imply that they shouldn't do anything until that moment.
16:15:27 <mm_freak_> seems like it doesn't use FFI
16:15:55 <mm_freak_> but using multiple cores gives me at most 105%-110% user time
16:16:53 <Cale> eflister: Because laziness has to do with evaluation only.
16:16:54 <copumpkin> mm_freak_: maybe it just isn't very parallel, or the pars are in the wrong places?
16:17:03 <Cale> eflister: That is, how expressions are turned into values
16:17:14 <mm_freak_> copumpkin: no pars, but forkIO
16:17:20 <Cale> eflister: *Not* with how IO actions are carried out.
16:17:21 <mm_freak_> @hoogle getPrime
16:17:21 <lambdabot> No results found
16:17:27 <copumpkin> ah
16:17:41 <mm_freak_> getPrime :: Int -> IO Integer
16:18:07 <eflister> cale: isn't that consistent with not computing values until some IO action will depend on them?
16:19:05 <Cale> eflister: When executed, IO actions occur immediately, in the sequence that they describe. Of course, if part of the action takes forever to evaluate, that will hold things up, but otherwise, it has nothing to do with when results are needed.
16:20:02 <eflister> cale: well my code is specifically delaying the request to print out the logs, in order to give the threads a chance to compute a bunch of values
16:20:21 <Cale> eflister: There are two interleaved processes in the execution of any Haskell program: there's evaluation which turns expressions into values so that they can be pattern matched against, and there's execution which is the carrying out of effects as described by IO action values.
16:20:55 <Cale> evaluation is lazy and pure
16:21:29 <Peaker> "pattern matched against" or applied
16:21:41 <eflister> cale: its behavior is totally consistent with no values being computed until the moment it tries to print out the logs.  if i never asked to print them, it would never compute them, right?
16:22:06 <Cale> eflister: You can't tell the difference between a non-evaluated expression and one which is evaluated.
16:22:18 <Cale> eflister: Specifically, evaluation has no effects.
16:23:11 <Cale> eflister: (No *visible* effects anyway -- it has a memory effect, but it's not something you can see from inside the Haskell program unless you use low-level IO to examine memory.)
16:23:44 <Peaker> and unless you use lazy I/O against a socket or pipe :-P
16:24:06 <Cale> Well, yes, there is some lazy I/O which breaks the rules, but you're not using it.
16:24:32 <Cale> (getContents / hGetContents / readFile)
16:25:03 <sahazel> wait, those functions break the rules?
16:25:16 <pikhq> Yes.
16:25:27 <sahazel> I think I don't understand the rules!
16:25:31 <pikhq> Though getContents is a value, not a function.
16:25:39 <sahazel> right
16:25:57 <copumpkin> a magic value!
16:26:03 <copumpkin> instance Monad Magic where
16:26:04 <Cale> getContents, when executed, produces a String which when evaluated, demands input on stdin.
16:26:16 <Cale> Which is magic that you can't normally accomplish.
16:27:11 <Cale> The I/O is deferred to the evaluation of the result of the IO action.
16:27:24 <eflister> cale: i think i'm doing it weird, definitely in a way that doesn't match the usual style.  the idea is to start threads that should spin in an until loop, calculating values.  but the only place these values go is into the log.  the until loop doesn't stop until an MVar flips, and i specifically threadDelay that, in an ettempt to build up a lot of values.  but if i never asked to print the logs, no values would have been put in the logs, 
16:27:24 <eflister>  and if i wait a long time to print the logs, there's nothing causing it to compute values and be filling the logs until the last moment, when it only has time left for one.  what part of this am i getting wrong?
16:29:54 <Cale> eflister: Minding that I haven't really understood in detail what your code is doing, putting values in a log, whether using WriterT or using an MVar containing the log won't cause things to block until the log is read. It will continue immediately.
16:30:15 <Cale> eflister: Mind you, if you try to write to a full MVar or read from an empty one, it will block.
16:31:08 <Cale> This includes modifyMVar_ which you seem to be using.
16:31:09 <eflister> cale: i'm as sure as i can be that that isn't happening and that it's not putting anything into the logs until print is called.  i can't think of what else to try
16:31:42 <Cale> Is the MVar full on the first call to modifyMVar_?
16:32:15 <Cale> er, oh, you're only using that for the kill MVar
16:32:17 <eflister> cale: it is inited to newMVar False
16:33:30 <eflister> cale: and everyone else only ReadMVars it until stop calls modify
16:33:44 <MissPiggy> blegh
16:33:57 <MissPiggy> I soooo cannot be bothered writing these factoring proofs in Coq
16:34:16 <MissPiggy> it seems like a good idea at first but then it is a lot of work
16:34:25 <copumpkin> when faced with tedium, write a program that does it for you :)
16:34:35 <copumpkin> ;)
16:35:31 <ddarius> It's called Ltac.
16:35:33 <eflister> cale: why isn't this like "let x=[1 ..]", and then waiting a while, and then asking "x !! 99999" -- nothing happens until you try to print, right?   this is all in ghci btw
16:35:45 <MissPiggy> http://coq.inria.fr/stdlib/Coq.ZArith.Znumtheory.html
16:35:49 <MissPiggy> there's some number theory there
16:36:15 <copumpkin> Zorro would approve.
16:36:20 <Cale> eflister: It's not like that because it has nothing to do with evaluation.
16:36:46 <Cale> eflister: The evaluation of all the actions involved is trivial.
16:36:48 <MissPiggy> maybe I should just force myself to do it
16:37:29 <eflister> cale: aren't i evaluating what values to put in the log?  and if, as far as it knows, no one is ever going to ask to see them, why would it start computing them?
16:37:40 <Nereid_> is there a way to define a custom way to derive instances?
16:38:15 <Nereid_> actually nevermind, even if there was it wouldn't work in my case
16:38:23 <copumpkin> I don't think so, though
16:38:30 <copumpkin> there's Data.Derive and the other one
16:38:39 <copumpkin> but those aren't "built in"
16:38:55 <MissPiggy> there's no programs to help me copumpkin
16:39:07 <copumpkin> MissPiggy: that's sad :(
16:39:12 <MissPiggy> is it
16:39:27 <MissPiggy> wat about these folks that spend their life trying to escape godels theorem
16:39:40 <copumpkin> everything is sad!
16:39:43 <Cale> eflister: In order to execute  untilM fst (make . snd) (False, [0..]), it first evaluates untilM, which expands into a case with guards, and then has to evaluate p x, which in this case is  fst (False, [0..]), which of course evaluates to False
16:40:59 <Cale> eflister: It then takes the otherwise branch, which is  f x >>= untilM p f. Making the substitutions, we have ((make . snd) (False, [0..])) >>= untilM fst (make . snd)
16:42:10 <Cale> and the executor proceeds by executing (make . snd) (False, [0..]), which forces a bit more evaluation to happen, since make pattern matches on the list you provide it
16:42:50 <Cale> make (snd (False, [0..])) -> make [0..] -> make (0 : [1..]), and now make can pattern match, so m = 0 and ms = [1..]
16:43:24 <eflister> cale: this is the intended design :)
16:43:26 <Cale> Now we proceed to execute the body of that do-block in make, with the required substitutions
16:43:33 <Cale> liftIO . putStrLn $ "doing " ++ show 0
16:43:43 <Cale> and we see "doing 0"
16:43:54 <Cale> last <- liftIO . readMVar =<< (lift $ asks kill)
16:44:24 <eflister> cale: but "doing" does not type out until stop has been called -- 4 secs after the thread was started!
16:45:54 <Cale> Well, it's going to happen basically as soon as you execute the untilM
16:45:56 <kw317> supose I have this type: data G x = GNil | GCons C C x x x and I'm interested in making it an instance of Functor class.. also, later on I will be interested in taking the fixed point of G.. how do I do it?
16:46:04 <kw317> I'm getting a bit lost in all of this :)
16:46:21 <Cale> So we can infer from this that produce isn't being executed until after the delay.
16:46:47 <eflister> cale: right!  is my threadDelay in the main thread somehow affecting the forked threads?
16:47:03 <dmwit> kw317: Well, Functor is pretty easy; it just needs fmap.
16:47:35 <dmwit> kw317: Once you line up the type of fmap, there's really not a lot of choices of how to implement it for that data type. =)
16:48:26 <kw317> well, the problem with implementing fmap is that the type variable bound by instance declaration is not what x is supposed to be in the datatype declaration above
16:49:23 <kw317> because later I'd like to take a fixed point of G with type Mu f = Mu (f (Mu f))
16:49:53 <Cale> eflister: I'm willing to bet that the problem is with the MVars getting jammed up somehow.
16:49:53 <MissPiggy> kw317 that's a good idea
16:50:44 <Saizan> kw317: instance Functor G where fmap f GNil = GNil; fmap f (GCons a b x1 x2 x3) = GCons a b (f x1) (f x2) (f x3)
16:50:52 <midfield> eflister: have you seen yampasynth?
16:51:02 <MissPiggy> you can't make a functor out of Mu G
16:51:13 <Saizan> yeah
16:51:40 <Cale> eflister: Oh, I think I see. Yeah, it's all about how you're pausing.
16:51:50 <Saizan> if you start with a bifunctor then you can make the fixedpoint over only one place a functor itself
16:52:03 <Cale> eflister: er, maybe...
16:52:18 <eflister> cale: i'll definitely take the bet -- i don't see how they could be.  do you see any possibilities for how to check?
16:52:32 <kw317> Saizan: and if I wanted to have it parameterized over another type variable?
16:52:57 <kw317> Saizan: say something like data G a x = G a a x x x?
16:53:20 <MissPiggy> but then you need
16:53:21 <kyagrd> Is there a magical LANGUAGE pragma for Haskell 2010? (something like {-# LANGUAGE Haskell2010 #-}
16:53:29 <Saizan> kw317: e.g.if you start with L l a = Nil | Cons a l; and have BFix bf a = BFix (bf (BFix bf a) a); then BFix L a is isomorphic to [a]
16:53:32 <eflister> midfield: looks cool -- i haven't been able to decide if frp is just kindof hype.  streams/arrows are cool for sure
16:53:35 <MissPiggy> data Mu f a = Mu (f a (Mu f a))
16:53:48 <MissPiggy> now Mu G is a functor
16:53:50 <dmwit> MissPiggy: You could call it... mewtwo
16:53:54 <MissPiggy> haha
16:54:02 <kw317> the idea is that later I'm gong to use it to implement (say) lcs as hylomorphism, then I'd like to have something like lcs for int lists and char lists, etc
16:54:39 <Saizan> you can also just partially apply it
16:54:48 <Saizan> Mu (G a)
16:54:59 <MissPiggy> oh my god
16:55:06 <MissPiggy> Saizan that is so clever
16:55:06 <kw317> ok, cool
16:55:12 <MissPiggy> I am kicking myself for not thinking of that
16:55:18 <Saizan> with instance Functor (G a) where ..same code as before..
16:55:22 <copumpkin> kw317: not a histomorphism?
16:55:33 <kw317> copumpkin: lcs won't work as histomorphism
16:55:47 <kw317> copumpkin: you can do it as hylo, but then if you want to be clever you need to do more work
16:56:02 <Cale> eflister: OH!
16:56:13 <kw317> copumpkin: there's another scheme called dynamorphism, which is designed for things like that
16:56:25 <eflister> cale:   :)
16:56:35 <hatds> what's a good solution for mutable maps?
16:56:37 <Cale> eflister: There's something very weird going on here.
16:56:37 <kw317> copumpkin: AFAIK histomorphisms are good for course-of-values recursion, and you don't get that with many algorithms
16:56:46 <copumpkin> I could've sworn I saw LCS in a paper on histomorphisms
16:56:49 <Cale> eflister: start is returning a continuation
16:56:53 * kw317 has an evil plan to write answers to exam questions in bioninformatics in this manner
16:56:54 <nainaide> In 4.2 Getting user input, http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell,  how can 'getInput "name" ' works before render the form to browse first? Sorry for the silly question.
16:57:08 <copumpkin> ah, it was dynamorphism, sorry
16:58:16 <eflister> cale: hm, i thought i was just returning a function that could see the shared state -- i haven't used continuations before but it sounds kind of like my impression of what they were
16:58:55 <Cale> inContext . storeLog prodLog False . inContext $ execWriterT produce
16:59:03 <Cale> ^^ whatever this is doing, it's not running produce
16:59:34 <Cale> You can stick some liftIO'd putStrLn's before and after it to see
17:00:19 <Cale> (and maybe one inside produce itself)
17:00:53 <Cale> okay, yeah, it's doing this funny storeLog thing
17:02:11 <Saizan> nainaide: in fact it renders the inputForm when getInput "name" fails
17:02:43 <eflister> cale: yeah, before and after get typed, but produce doesn't get typed until the end
17:02:52 <Saizan> nainaide: where failure here is denoted by returning a Nothing
17:03:30 <eflister> cale: i'm storing the logs like that so that they don't clobber each other by trying to type out at the same time
17:03:39 <nainaide> Saizan, that means at getInput will return Nothing at least once?
17:04:00 <copumpkin> unless you kill it!
17:04:15 <Cale> eflister: oh, wow, it is incredible that this typechecks.
17:04:29 <Cale> It's because functions are an instance of MonadReader
17:04:46 <Saizan> nainaide: yeah, unless the user is some script which sends directly the data
17:04:57 <eflister> cale: hrm
17:05:22 <nainaide> Saizan, got it, thanks
17:05:23 <Cale> er...
17:05:37 <Cale> This is making me dizzy
17:05:45 <Cale> How did you manage to write this? :)
17:06:20 * copumpkin is curious now
17:07:07 <eflister> cale: heh -- well the idea was to make a framework for livecoding.  i want to be able to spawn off threads in ghci that will continuously produce events, but to then be able to use ghci to modify state that they can see to alter the events they are producing.
17:07:15 <MissPiggy> co-curious?
17:08:07 <eflister> cale: so in ghci, the idea would be to call start, which would pass back a "context" (c here), and then be able to operate on c in ghci, and then ultimately call c stop to clean everything up.
17:08:23 <Cale> eflister: Okay, the type of storeLog makes it patently obvious that it's not using its third parameter for anything remotely relevant, and in particular could not possibly be executing it.
17:08:46 <Cale> eflister: Which is a shame, since the third parameter is in fact the action which you had meant to run.
17:09:01 <Cale> Instead, what you're doing is stuffing that IO action into an MVar
17:09:52 <Cale> which, of course you can do, since prodLog for some inexplicable reason is an MVar of IO actions which if executed would produce lists of Strings.
17:10:24 <Cale> So, all that you're doing there is stuffing the produce action into an MVar
17:10:30 <Cale> (not executing it)
17:11:15 <eflister> cale: well since i call execWriterT/runWriterT, storeLog's third parameter is just supposed to hold the [String] log that resulted from running those writers
17:12:00 <Cale> and then later in stop, you call printStoredLog, which gets the action back out of the MVar, as g, and then passes it along to printLog
17:12:16 <Cale> as the 3rd parameter to printLog
17:12:34 <Cale> and *finally* it runs there.
17:12:58 <Cale> You need to be aware that an IO [String] is not the same thing *at all* as a list of strings.
17:13:20 <Cale> Instead, it is a bunch of actions which if they were to be carried out, would result in a list of strings.
17:13:46 <eflister> cale: i was thinking of my logs as in the IO monad cuz they depend on reading MVars (and other IO in the larger system that this is extracted from)
17:13:51 <Cale> But evaluating an IO [String] doesn't cause it to occur any more than opening a program in a text editor causes it to run.
17:14:14 <Cale> What you really want is for prodLog :: MVar [String]
17:14:25 <Cale> (maybe)
17:14:39 <Cale> Actually, all of this machinery is absurdly complicated for what you're trying to do.
17:15:07 <eflister> cale: yeah i'd love to learn how to do it nicely :)
17:15:46 <Saizan> preflex: seen ddarius
17:15:47 <preflex>  ddarius was last seen on #haskell 40 minutes and 16 seconds ago, saying: It's called Ltac.
17:15:56 <Cale> First thing, don't use monad transformers at all.
17:16:26 <eflister> cale: hm, ok.
17:16:33 <Cale> Transforming IO is almost always a bad idea.
17:17:00 <Cale> There are some exceptions to that, but they're not so common.
17:17:24 <eflister> cale: in my real app, it's doing midi i/o, getting random generators, etc, so all these logs i want to see if anything goes wrong wind up looking like this.
17:18:07 <Cale> IO already has lots and lots of nice features, and adding things to it is usually redundant, and even in the best case you end up with lots of liftIO
17:18:21 <Cale> which is a lot worse than passing an extra parameter to things
17:18:37 <eflister> cale: yeah i've been hating all my lifts...
17:19:46 <Cale> If you really want to produce/consume streams of events, there's already a nice abstraction which exists for that in IO
17:19:49 <Cale> It's called Chan
17:19:58 <Cale> (in Control.Concurrent.Chan)
17:20:13 <eflister> cale: that's fifo, and i need a priority queue, that i already have working well
17:20:45 <Cale> Okay, well, you could probably also get away with something like an MVar of a PSQueue
17:21:27 <Cale> However, you can also use Chans for logging.
17:21:43 <Cale> You don't need WriterT
17:24:04 <Cale> What you can do is to create a new Chan String, and pass the write end of that Chan (which is just the function writeChan c :: String -> IO ()) to the computation which needs to do logging, and then do whatever you want with the logged messages using readChan c :: IO String to read off the logged messages elsewhere.
17:25:44 <eflister> cale: yeah my event queue an mvar data.heap.  but i'm missing the big picture as to what other deisgn is possible -- the real goal is to be able to call "start" in ghci, get back a context record that carries state about the threads that got created, be able to modify that context to change how events are getting created, and then be able to call close on it to clean it up.  i'm not getting how changing the logging mechanism is the key th
17:26:02 <Cale> Data.Heap?
17:26:22 <eflister> http://hackage.haskell.org/package/heap
17:27:23 <Cale> Ah, okay. http://hackage.haskell.org/package/PSQueue -- this is what I normally like to use for priority queues.
17:27:48 <Gracenotes> oh, that is nice
17:28:51 <Cale> eflister: Okay, I suppose I don't understand what you mean by "change how events are getting created"
17:29:10 <gwern> anyone know how to contact arcanux of the lambdacats?
17:29:12 <gwern> they're down
17:29:25 <Cale> Of course, if you create new threads, you'll probably want to hang on to their ThreadIds so that you can kill them later.
17:29:33 <Cale> But what other state is there?
17:30:26 <eflister> cale: well, speaking just any kind of state dependence.  so maybe when you call start, there is a generator spitting out midi events at one tempo and pitch.  then you'd like to be able to change the state and have the generator notice, and change tempo/pitch.
17:31:01 <Gracenotes> thread ids can't quite be treated like pointers to the thread, though, you still need the MVars and such
17:31:06 <eflister> cale: the idea of the kill :: MVar Bool part of the context is that when you call stop, that bit gets set, and all the threads in their UntilM loops notice that and gracefully finish
17:31:08 <HugoDaniel> hi
17:31:22 <HugoDaniel> i want help in building a monad (or something like that...)
17:31:29 <Gracenotes> that includes interruption mechanisms, ones which can be recovered from
17:31:31 <HugoDaniel> here is what im planing to do: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21174#a21174
17:31:34 <HugoDaniel> is this possible in haskell ?
17:31:45 <dmwit> ?faq is this possible in Haskell?
17:31:45 <lambdabot> The answer is: Yes! Haskell can do that.
17:31:47 <HugoDaniel> i mean... with this sintax (or a simpler one) ?
17:32:10 <HugoDaniel> im terribly bad at building monads :(
17:32:23 <monochrom> @faq Does Haskell bootstrap all and only those languages who don't bootstrap themselves? Tee hee hee!
17:32:24 <lambdabot> The answer is: Yes! Haskell can do that.
17:32:31 <Gracenotes> Tee hee hee!
17:32:39 <sshc> Tee hee hee!
17:33:19 <Gracenotes> HugoDaniel: what is the effect you want a command like generator/selector/rotate to have?
17:33:20 <sshc> why is there "module Etc." in an export list of another module?
17:33:30 <dmwit> HugoDaniel: It's impossible to really understand what you want to do just from what you posted.
17:33:32 <sshc> will that cause the module to be exported when the other one is?
17:33:37 <HugoDaniel> sorry
17:33:39 <HugoDaniel> ill update it
17:33:52 <HugoDaniel> well, in the end it all outputs a nice Double
17:33:52 <dmwit> sshc: If you export a module, that means to export all the symbols you imported from that module.
17:34:29 <sshc> dmwit: module Control.Monad.State.Lazy ( module Control.Monad.State.Class, -- * The State Monad State(..), evalState, etc.) where
17:35:06 <Gracenotes> to do that, you can just f _ = 0.0
17:35:11 <Cale> eflister: Okay, so you probably want the thing which starts a given process to return a tuple (or other datatype) of functions/IO actions which cause certain effects on the state of the process.
17:36:06 <eflister> cale: sounds good.  i was picturing them all just reading/modifying MVars from Context
17:36:25 <Cale> eflister: This tuple might just consist of, say, a partially applied modifyMVar for each specific MVar that the process uses.
17:36:49 <eflister> cale: makes sense...
17:38:54 <Cale> eflister: Or perhaps the write end of a SampleVar
17:39:22 <Saizan> sshc: it reexports everything exported by the specified module
17:40:03 <Cale> SampleVars are nice because writers never block (though readers do, so you have to be careful)
17:40:15 <HugoDaniel> clearer now: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21175#a21175
17:40:25 <Cale> You might even make it an IORef if you don't mind the possibility of fighting for control. :)
17:41:32 <eflister> cale: one problem with my current approach was that in ghci i couldn't find any way to get my hands on Context (start's return value)
17:42:35 <Cale> eflister: An approach which is often better than passing a big tuple of MVars everywhere is to split things up and pass around actions which give different permissions to access things.
17:43:25 <Cale> But the stuff which is in Context is not really the state that you're after.
17:43:36 <eflister> cale: so, starting simply, let's say we just want a start and a stop.  sounds like start would pass back stop?  so the types would be...
17:43:49 <Cale> start :: IO (IO ())
17:44:29 <Cale> Or, if you want to be fancier:
17:44:45 <Cale> data Process = P { stop :: IO () }
17:44:50 <Cale> start :: IO Process
17:44:54 <Saizan> HugoDaniel: if you've a syntax and an interpretation in mind and you want to build a monad, this should explain how http://apfelmus.nfshost.com/articles/operational-monad.html
17:45:39 <HugoDaniel> thanks
17:45:49 <Cale> and then you'd use it like:
17:45:50 <eflister> cale: and from ghci, we'd say "stop = start" to start?  that can't be right...
17:45:53 <Cale> p <- start
17:45:57 <HugoDaniel> ive been reading several monad tutorials, but they all talk about the maybe monad... which is a pain :/
17:45:57 <Cale> stop p
17:46:05 <Cale> eflister: stop <- start
17:46:17 <eflister> cale: oh i didn't realize you could <- in ghci :b
17:46:26 <Cale> eflister: start will start the process and pass back an IO action which if executed will stop the process.
17:46:48 <Cale> (this is the lovely thing about IO actions being first class)
17:47:05 <eflister> cale: got that part.  ok and if we want the process to be logging itself...
17:47:34 <Cale> and since they're not the same thing as functions you don't have to worry so much about evaluation accidentally triggering them -- the only way the process will stop is when you execute that action (or it stops on its own)
17:48:06 <Saizan> HugoDaniel: that one is quite different :)
17:48:16 <Cale> If you want the process to log, you probably want to pass in a way for it to log, *or* pass back a way to get at the logged messages
17:48:23 <Cale> So, perhaps:
17:48:38 <Cale> start :: (String -> IO ()) -> IO Process
17:48:39 <Cale> or
17:49:02 <Cale> data Process = P { stop :: IO (), readLog :: IO String }
17:49:41 <Cale> (perhaps IO (Maybe String) there, in case you don't want to block in the case of an empty log)
17:50:06 <Cale> The convention you choose is all about who is responsible for creating the Chan
17:50:22 <Cale> the first convention is nice in that if you want to log to stdout, you just pass in putStrLn
17:51:52 <eflister> cale: ok, trying to writeup just this much...  where does the mvar for stopping go?
17:52:07 <Cale> You create it inside start
17:52:21 <altmattr> Using Maybes in do notation is great.  But I want to have the fail string be used.  If I recall, Either is not a good monad, is there a MaybeX where the fail string is kept with the Nothing constructor?
17:52:58 <Saizan> Either String sounds like what you want
17:53:11 * Cale concurs with Saizan 
17:54:07 <eflister> Either String String?  for nominal and error conditions?
17:54:10 <Saizan> your use case is what makes the Monad (Either e) instance bad for most of the others :)
17:54:48 <Cale> altmattr: fail was a mistake, and having it take a String parameter is not so wonderful.
17:55:10 <Cale> altmattr: I would just use throwError or use Left directly
17:55:43 <Saizan> unless these strings are from pattern match failures
17:55:44 <altmattr> but it is perfect for me, I am writing a type checker and I get either type or an error
17:56:08 <altmattr> but i want a little more flexibility than throwing an error
17:56:41 <Cale> If your typechecker is already in IO, then using exceptions would work well.
17:56:45 <Saizan> "throwError" is not the same as "error", and doesn't involve "fail"
17:56:58 <altmattr> Cale: not in IO
17:57:08 <altmattr> Saizan: more info?
17:57:15 <Saizan> ?src MonadError
17:57:16 <lambdabot> class (Monad m) => MonadError e m | m -> e where
17:57:16 <lambdabot>     throwError :: e -> m a
17:57:16 <lambdabot>     catchError :: m a -> (e -> m a) -> m a
17:57:33 <Saizan> ?instances-importing Control.Monad.Error MonadError
17:57:34 <lambdabot> IOError IO, e (Either e), e (ErrorT e m), e (RWST r w s m), e (ReaderT r m), e (StateT s m), e (WriterT w m)
17:57:35 <Cale> Either String is an instance of MonadError, where e = String
17:58:08 <Saizan> throwError = fail for Either String
17:58:21 <Saizan> (all of this in mtl)
17:58:43 <altmattr> Saizan: still a little confusing, but thanks
18:00:15 <Cale> altmattr: Of course, in the Either String monad instance from mtl, throwError is the same as fail like Saizan mentions, but I think it's best to pretend that "fail" doesn't exist.
18:02:04 * Saizan remembers the times when fail was part of the standard explanation of Monads
18:02:58 <Cale> That time was briefly after Haskell 98 was released.
18:03:27 <altmattr> Boy, I am confused.  I have been tot he haddock for Control.Mondad.Errror and Control.Monad.Either and ... what?
18:03:30 <Saizan> i came here much later :)
18:04:04 <Saizan> is there a Control.Monad.Either?
18:04:31 <Cale> altmattr: Basically, you can mostly ignore that
18:04:37 <Cale> altmattr: Here's the basic idea
18:04:47 <Cale> return x = Right x
18:04:54 <Cale> and then:
18:05:03 <Cale> Left e >>= f = Left e
18:05:21 <Cale> So, errors (Lefts) are propagated, and the rest of the computation skipped
18:05:27 <Cale> Right x >>= f = f x
18:05:38 <altmattr> Cale: I get this, I wrote my own Either monad once before since I really wanted this behavour
18:05:43 <Cale> right
18:05:44 <altmattr> but it was a god-awful pain
18:05:54 <altmattr> and I guessed people do this all the time
18:06:03 <Cale> So, this is effectively what that instance from Control.Monad.Error does
18:06:09 <Cale> and throwError = Left
18:06:22 <mauke> (tangent: why is Right x >>= f = f x; e >>= _ = e ; wrong?)
18:06:34 <Cale> mauke: Types.
18:06:37 <altmattr> Cale: I see, so is MonadError the instance of Monad?
18:06:52 <Saizan> MonadError is a typeclass
18:06:53 <altmattr> no, that is a class
18:07:00 <Cale> altmattr: No, Either e is.
18:07:03 <altmattr> oh - it uses class inheritance (sik)
18:07:10 <altmattr> which I totally forgot about
18:07:18 <Cale> MonadError is just another typeclass for monads which have error handling.
18:07:24 <altmattr> it adds throwError and catch error to Monad
18:07:29 <Cale> yeah
18:08:06 <altmattr> Cale: thankyou very much, that was where I was getting confused, I thought MonadError not Monad
18:08:22 <altmattr> and there is Either as an instance of MonadError
18:08:24 <altmattr> lovelly
18:09:33 <eflister> cale: something along these lines?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21177
18:10:23 <Cale> eflister: I was thinking the log would be a Chan
18:10:32 <Cale> eflister: and readLog would read one entry from it
18:11:30 <Cale> setState shouldn't be a String
18:11:39 <Cale> String -> IO ()
18:11:50 <Cale> (perhaps)
18:13:15 <eflister> cale: i've never really gotten using record syntax this way, but i think i'm starting to see it
18:24:31 <medfly> @hoogle mappend
18:24:31 <lambdabot> Data.Monoid mappend :: Monoid a => a -> a -> a
18:27:00 <altmattr> Cale: thanks, that worked a treat
18:28:58 <Cale> altmattr: no problem
18:34:34 <Alpounet> hi guys
18:34:38 <Alpounet> @hoogle gfold
18:34:38 <lambdabot> Data.Graph.Inductive.Basic gfold :: Graph gr => (Context a b -> [Node]) -> (Context a b -> c -> d) -> (Maybe d -> c -> c, c) -> [Node] -> gr a b -> c
18:34:38 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
18:34:38 <lambdabot> Data.Generics.Twins gfoldlAccum :: Data d => (a -> c (e -> r) -> e -> (a, c r)) -> (a -> g -> (a, c g)) -> a -> d -> (a, c d)
18:35:12 <Alpounet> the first one ; what's the point of that 'd' value, returned by the second function ?
18:35:45 <Alpounet> oh
18:35:50 <Alpounet> it's used right after
18:36:06 <Alpounet> as an argument to the function right after, okay.
18:44:54 <ahpook> Oh woe, having hxt troubles
18:47:02 <ahpook> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21192#a21192
18:47:38 <ahpook> all I get is that haskell dump, no xml output
18:53:56 <monochrom> because of a_show_haskell being v_1
18:54:08 <dancor> data Cons = Cons Int Int.  is there anything like Functor so that fmap f (Cons a b) = Cons (f a) b?  Functor/fmap doesn't work since Cons isn't parametrized.
18:54:46 <Alpounet> such typeclasses are always related to parametrized data types
18:55:03 <Alpounet> it doesn't mean anything to define a 'fmap' for your Cons data type
18:55:07 <dancor> i.e. i want to specify with an instance that the first record is the one that is of typical interest
18:55:10 <hatds> no, and although you could generalize your datatype to Cons a = Cons a a or Cons a b it doesn't feel like a good fit for Functor
18:55:24 <dancor> hm
18:55:55 <dancor> "of typical interest" -> the one you typically want to modify 'in-place' as it were
18:56:27 <hatds> is IntMap strict in it's elements?
18:56:37 <aavogt> @src IntMap
18:56:37 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:56:48 <Alpounet> @hoogle IntMap
18:56:49 <lambdabot> module Data.IntMap
18:56:49 <lambdabot> Data.IntMap data IntMap a
18:56:55 <Alpounet> check the docs
18:56:57 <aavogt> hatds: I think it's lazy in the values like Data.Map
18:57:05 <aavogt> @src Map
18:57:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:57:09 <aavogt> @src M.Map
18:57:10 <lambdabot> Source not found. Wrong!  You cheating scum!
18:57:31 <Alpounet> it wouldn't make sense to have it being strict by default
18:58:13 <aavogt> well it could be lazy in the shape of the tree too...
18:58:23 <ahpook> monochrom: thanks
18:58:34 <hatds> it doesn't have strict versions of insertWith and so on
18:59:31 <aavogt> hatds:   Data.IntMap.keys (Data.IntMap.fromList [(1,undefined)]) == [1]
18:59:46 <hatds> yea, just doing that myself
18:59:50 <aavogt> therefore it is layz in the values
19:00:19 <hatds> I don't see why they don't provide the same functions as Map..
19:01:17 <aavogt> it does as far as I've needed
19:04:26 <noob> hi. anybody can tell me more about Continuations and continuation-passing style, like a problem that is best solved by using this approach?
19:05:35 <Alpounet> noob, IIRC, bos has reimplemented a (parsing, IIRC) library with CPS and he got major performance improvements
19:06:16 <Alpounet> http://twitter.com/bos31337/status/8909111479
19:07:11 <Alpounet> I guess GHC makes better guesses about what happens when you use CPS, probably more straightforward for the inherent algorithms.
19:07:12 <tomoj> I don't know much about continuations and I'm not even sure this counts as CPS, but I use a web framework where middleware that modifies the request or the response are implemented as functions with type (Request -> Response) -> Request -> Response
19:08:06 <tomoj> so the middleware function takes a request handler (as a "continuation"?) and returns a modified request handler
19:09:37 <aavogt> @unmtl Cont r a
19:09:37 <lambdabot> (a -> r) -> r
19:09:38 <noob> thank you for the answer Alpounet
19:11:19 * copumpkin looks forward to a beautiful pure FRP approach to making pretty, smooth visualizations like those made with processing or flash, without the fugliness
19:11:24 <copumpkin> (in code)
19:30:27 <c_wraith> hmm.  what changed in haddock under 6.12?
19:31:00 <c_wraith> My -- ^ comments on function arguments aren't showing uup
19:38:17 <copumpkin> has anyone considered making a "specialized" fingertree for strict values?
19:38:41 <copumpkin> Ã  la vector/uvector for space efficiency and very little indirection
19:38:46 <copumpkin> (with associated types)
19:39:52 <c_wraith> I really don't understand.  For about half my functions, haddock is reading the markup properly.  I don't see what' different about the functions where it isn't
19:42:33 <rothwell> 'lo. is HDBC the most "mature" library for accessing an sqlite db at the moment?
19:42:35 <c_wraith> The only pattern I can see offhand is that the ones where it's reading the markup wrong are the ones which are affected by the not-home directive
19:47:47 <savanni> Hey, everyone.  I have a (hopefully) quick question.
19:47:55 <aavogt> ask away
19:48:19 <savanni> In an application that is using the GStreamer part of Gtk2Hs, how can I do teardown on the Elements that I have created when I am done with them?
19:48:54 <savanni> There is an objectUnref function way up at the top of the hierarchy, but I cannot figure out how to get the FinalizePtr that the function requires.
19:49:16 <aavogt> if the binding isn't braindead, that could happen when the haskell value gets garbage collected
19:50:01 <savanni> I think that is how it is supposed to work, however in the one time that I was running the program for a couple of hours, I started noticing some performance oddities.  Could have been anything on my computer, but I was wondering about this.
19:50:59 <savanni> I even went to try to figure out how to reuse a pipeline, but it behaves very strangely when I try and I have not the time at the moment to figure out why.
19:51:21 <aavogt> @hoole Element
19:51:22 <lambdabot> Test.QuickCheck elements :: [a] -> Gen a
19:51:22 <lambdabot> Text.Html getHtmlElements :: Html -> [HtmlElement]
19:51:22 <lambdabot> Text.Html data HtmlElement
19:52:42 <monochrom> @src groupBy
19:52:43 <lambdabot> groupBy _  []       =  []
19:52:43 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
19:52:43 <lambdabot>     where (ys,zs) = span (eq x) xs
19:52:52 <savanni> Huh.  Wrong element.
19:53:07 <savanni> @hoole Media.Streaming.GStreamer.Element
19:53:07 <lambdabot> No results found
19:58:32 <savanni> Oh well.  Thank you for your answer, aavogt.  I am going to try this program without doing the cleanup and see how it performs over time.  Hopefully the binding handles it all.
19:59:39 <erickl> hello, I'm trying to use Data.Set.empty in a case pattern but I get a "Qualified variable in pattern: Data.Set.empty" error.  However, simply using "empty" alone works!  What is the difference?
19:59:50 <aavogt> yeah, as far as I can tell it does already take care of that http://www.haskell.org/gtk2hs/docs/gtk2hs-docs-0.10.0/System-Glib-GObject.html#v%3AobjectUnref
20:00:21 <aavogt> the only functions for suggesting when an object can be removed are "internal"
20:00:52 <savanni> Okay.  Then I shall trust the system and attribute previous weirdness to just the weirdness of my computer. :)
20:01:11 <endpoint_david> is there a canonical doc for embedding the ghc runtime (including the compiler itself) in a c-based application?
20:01:25 <aavogt> ghc manual?
20:01:52 <endpoint_david> heh, can't get much more canonical than that... :-)
20:02:41 <aavogt> I'm not sure what you mean by embedding the compiler itself, but it certainly describes how to call haskell from C
20:03:08 <aavogt> and you can probably use the ghc-api (which permits interpreting code) in that haskell code...
20:03:37 <aavogt> @hackage hint maybe be easier than going directly through the ghc-api though
20:03:37 <lambdabot> http://hackage.haskell.org/package/hint maybe be easier than going directly through the ghc-api though
20:04:35 <savanni> erikl: I see the same thing.  No idea why that is.
20:04:49 <endpoint_david> hint looks nice/useful
20:05:09 * copumpkin is impressed
20:05:28 * aavogt is appalled
20:05:31 * copumpkin modified the interval tree that came with fingertree to be a 2d bounding box tree with zero thought whatsoever
20:05:46 <copumpkin> it was basically a textual replace
20:06:36 <aavogt> oh, that is convenient
20:07:01 <copumpkin> I can't say I've tested it much but it appears to work
20:07:56 <copumpkin> now it would take just a bit more effort to make it into an r-tree-like thing, but all this non-thought has exhausted me
20:09:44 <jmcarthur> i love fingertree
20:10:38 <endpoint_david> does hint require reinterpretation each time, or can you essentially create/bind functions in the interpreter itself?
20:13:59 <xynus> Hi there, does some one which of the regexp libraries has support for unicode ?
20:15:55 * endpoint_david thinking his question is answered via the FromSession type
20:16:32 <m3ga> xynus: regex-tdfa-utf8
20:16:55 <Cale> Some people, when confronted with a problem, think "I know, I'll use regular expressions." Then they have two problems.
20:17:08 <copumpkin> lol
20:17:28 <copumpkin> Cale: did you see? I made a 2d interval tree using fingertree! and my head CPU usage never went above 0%
20:17:42 * copumpkin grins
20:17:52 <Cale> neat
20:18:12 <Cale> head CPU usage?
20:18:27 <copumpkin> it took no brain activity
20:18:30 <jmcarthur> fingertree shits golden bricks. i mean that. i'm not just using hyperbole.
20:18:34 <copumpkin> which is good because I don't have much to give it
20:18:37 <Cale> ah, right
20:19:01 <Cale> Yeah, it's pretty straightforward to do some fairly awesome things with fingertree.
20:19:14 <Cale> I similarly implemented a priority search queue without thinking.
20:19:29 <copumpkin> :)
20:19:40 <aavogt> mmmmmm, digits
20:19:41 <copumpkin> now all I'd need to do is write a point insertion routine and I'd get a real spatial datastructure
20:19:42 <xynus> Cale: Actually I now regexp is a bitch in Haskell, I would go with parsec for serious stuff, but I just need to show and example to some people :).
20:20:12 <jmcarthur> xynus: if the point is to demonstrate the awesomeness of haskell, i strongly recommend against doing it with regex ;)
20:20:17 <Cale> Ah, in that case, probably m3ga's suggestion is good :)
20:20:26 <ddarius> There's nothing particularly bad about Haskell's regex support for searching.
20:20:47 <jmcarthur> no, but it's not in any way remarkable, either
20:20:52 <ddarius> Agreed.
20:21:06 <m3ga> regexes are only bad when they are used as adhoc parsers.
20:21:13 <savanni> Like for HTML.
20:21:17 <Cale> regex-base is a really irritating interface
20:21:19 <jmcarthur> m3ga: so... regex is bad
20:21:32 <copumpkin> if monads give us context-sensitive parsers and applicatives give us context-free, is there something between a functor and an applicative that gives us regular languages?
20:21:48 <jmcarthur> m3ga: i'm just joking, btw
20:22:06 <xynus> that's my case, I just want to show some regex not really going to parsec, they are just some freshers learning about regex, in fact, My example works bettter in Emacs
20:22:25 * endpoint_david waiting for copumpkin's punchline... :-)
20:22:33 <copumpkin> endpoint_david: don't have one :)
20:22:40 <jmcarthur> lame
20:22:45 * copumpkin pouts
20:22:56 <copumpkin> I was hoping the categorymeisters might have an answer
20:23:30 <aavogt> what kind of grammar is functor?
20:23:56 <jmcarthur> crippled
20:23:57 <aavogt> I suppose there isn't a way to combine them...
20:24:04 <copumpkin> crappled
20:24:13 <aavogt> copumpkin: look at monoid?
20:24:23 <xynus> jmcarthur: What would you recommend to teach some regex without using regex ?
20:24:28 <copumpkin> aavogt: what about it?
20:24:32 <jmcarthur> without using regex?
20:24:42 <Cale> xynus: Here's some possibly instructive code: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21225#a21225
20:24:52 <ddarius> copumpkin: Subsets of Arrow would do it.
20:24:54 <aavogt> it could be simpler than applicative
20:24:59 <jmcarthur> xynus: i'm being harsher on regex than i mean to be
20:24:59 <Cale> (with no comments in it, lol)
20:25:02 <gio123> Cale: one translation please :)
20:26:21 <xynus> jmcarthur:  I mean, you said "i strongly recommend against doing it with regex". But how could I probably show concepts like  "*",+, groups, without using regexp.
20:26:22 * jmcarthur finds that he uses let when he's designing bottom-up and where when he's designing top-down
20:26:39 <copumpkin> ddarius: hmm, ArrowChoice would give us some of it
20:26:41 <jmcarthur> xynus: "if the point is to demonstrate the awesomeness of haskell"
20:26:50 <jmcarthur> xynus: it sounds to me like that's not the point here
20:27:04 <xynus> jmcarthur: indeed, that's not the point..
20:27:12 <jmcarthur> then my statement is irrelevant
20:27:35 <Cale> xynus: Implementing regular expressions as a Haskell algebraic datatype is probably the best way for educational purposes.
20:27:51 <xynus> jmcarthur: I just wanted to code some Haskell, and show that is even less lines that it is in Java :)
20:28:03 <xynus> Cale: Sound interesting .
20:28:07 <xynus> *s
20:28:15 <Cale> xynus: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21225#a21225
20:28:21 * copumpkin started doing that in agda but then started shaving a yak that he never finished
20:28:44 <xynus> Cale: thanks for the link, I'll look at it .
20:28:44 * jmcarthur wears a yak hair shirt
20:28:51 <copumpkin> but now that dolio wrote zigzag I could probably get back to it :)
20:28:53 <Cale> my Reg type there has the primitives for regular expressions on an alphabet of type a
20:30:10 <copumpkin> monoid-indexed trees aren't unique to fingertree, right? are there papers from outside the haskell community that cover applications of them?
20:30:42 <Cale> copumpkin: Strangely, I've never seen them mentioned outside of fingertrees, but they seem like the sort of thing which ought to be as old as computer science itself.
20:30:57 <copumpkin> odd :)
20:32:43 <copumpkin> you'd think it would've come up in GiST
20:32:59 <copumpkin> but it doesn't seem to deal with them explicitly, and I'm not even sure if it's that general
20:33:12 <copumpkin> it mentions being able to deal with anything that can be represented as nested sets
20:34:20 <tensorpudding> > "fun" `isPrefixOf` "functional"
20:34:21 <lambdabot>   True
20:34:26 <tensorpudding> :D
20:35:41 <Cale> > "funk" `isPrefixOf` "funktional"
20:35:42 <lambdabot>   True
20:37:14 <copumpkin> @hackage monoids
20:37:15 <lambdabot> http://hackage.haskell.org/package/monoids
20:42:19 <copumpkin> looks like edwardk cleaned that up a bit :)
20:46:02 <copumpkin>     signum = error "broken numerical type tower"
20:56:31 <eflister> cale -- i think i finally have it working -- thanks for all your help http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21238
20:57:10 <eflister> i learned a lot (i know you don't like the string log, but it's just so i have a structure down)
20:57:34 <eflister> let me know if you see that i missed some useful concept...
20:59:14 <iaefai> It would really be nice to use haskell right now for part of my iphone program :P
20:59:42 <shachaf> iaefai: Haven't some people made that work?
20:59:55 <iaefai> I haven't heard for sure
21:00:16 <Gracenotes> it is difficult to integrate a new programming language with an existing toolchain, methinks
21:00:24 <Gracenotes> new to said toolchain anyway
21:00:27 <jmcarthur> yeah there are some patches for ghc to make it work for iphone stuff
21:00:58 <jmcarthur> forget the name of the group that's running that show though
21:01:15 <copumpkin> ipwn studios :)
21:01:17 <monochrom> @src words
21:01:17 <lambdabot> words s = case dropWhile isSpace s of
21:01:17 <lambdabot>     "" -> []
21:01:17 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
21:01:21 <iaefai> jhc seems to have some explicit support, any idea how good that compiler is?
21:02:31 <iaefai> I guess what I really need is some way of producing a static library and interfacing with Objective C
21:03:05 <Cale> eflister: Why is readLog :: (String -> IO ()) -> IO () rather than IO String?  I guess it works either way.
21:03:38 <eflister> cale: yeah you're right it's not a great choice
21:05:21 <copumpkin> Cont!
21:05:24 <copumpkin> :P
21:09:57 <eflister> is this basically a continuation?  is that what copumpkin meant?
21:10:24 <copumpkin> @unmtl Cont (IO ()) String
21:10:25 <lambdabot> (String -> IO ()) -> IO ()
21:11:31 <monochrom> A strange use.
21:11:34 <eflister> why does continuatino have specifically to do with string/io?  i thought it just contained runnable state?  but that's just sounding like a closure...
21:11:57 <eflister> oh sorry that was a kind of Cont
21:12:13 <copumpkin> it doesn't have anything specifically to do with String or IO :)
21:12:23 <copumpkin> (a -> r) -> r
21:12:28 <copumpkin> that's all it is
21:12:53 <monochrom> Normally you use Â«Cont r (anything you like here)Â» and leave the r there polymorphic, not specialize to IO().
21:13:43 <monochrom> Indeed if you ever want to use >>= and return and callCC of Cont, you must do so.
21:14:10 <monochrom> Err, nevermind.
21:15:29 <eflister> how are they different than function application?  or closures?
21:35:01 <Cale> eflister: Continuations are simply functions representing the remainder of a computation to be done.
21:35:53 <Cale> eflister: Closures are a data structure sometimes used in the implementation of first class functions, consisting of a pair with some code, and a mapping from the free variables in that code to values.
21:39:50 <Cale> When you have "first class continuations" it means that there is some primitive fashion in which a function or procedure representing the remainder of the program can be accessed -- typically via a function called call/cc (or callCC in Haskell) which passes that continuation as a parameter to whatever function you give it.
21:41:24 <Cale> You can arrange for such a function/procedure to be available by writing everything in a style where rather than returning a value immediately, the rest of the computation is always a parameter to each function you write, and is called with what would be the normal result of the function.
21:41:34 <Cale> This is called continuation-passing style.
21:43:36 <Cale> The Cont monad is a thin wrapper around continuation passing style, with an implementation of callCC that accesses the remainder of the computation which is implicitly a parameter to everything.
21:44:15 <scutigera> Cale: why isn't it an IO monad ?
21:44:25 <Cale> You can ContT over IO.
21:44:47 <scutigera> hey wait, maybe I meant a state monad...
21:44:49 <Cale> But continuations don't specifically have anything to do with IO
21:45:42 <eflister> cale: i was seeing connections to what we wrote, since the interface is a bunch of functions that know something about what computation has been going on, and a closure similarly as a function that has some state possibly built up from what's been going on.  but i can see that those are less specific than "the rest of the computation".  as far as i can understand what that means, it would be state saved up in something like a closure, rig
21:46:20 <Cale> I don't like using the word 'closure' in the context of anything other than implementing a compiler or interpreter.
21:46:27 <Cale> Closures are an implementation detail.
21:47:04 <eflister> cale: but helps to understand that a closure could be used to implement a continuation :)
21:47:24 <scutigera> something like let a = 3 in \x -> 3 * x is what I would normally refer to as a closure.
21:47:41 <Cale> Well, yeah, in that continuations are functions (or in effectful cases, procedures), and closures are used to implement those things :)
21:48:42 <Cale> scutigera: To me, "closure" refers to a (code, environment) pair.
21:49:03 <Cale> If you can't separate that pair anymore, then what you have is no longer a closure, but something more abstract.
21:49:18 <Cale> (a closure might be used to implement it)
21:50:01 <Cale> That's the standard meaning anyway. It gets abused a lot.
21:50:19 <Cale> People confuse their language implementations with their languages :)
21:50:39 <scutigera> ever read lisp in small pieces ?
21:50:53 <Cale> No, but I'm generally familiar with lisp.
21:51:18 <Cale> I've read SICP, and written (small) programs in scheme and common lisp.
21:51:23 <scutigera> very good book,covers some of the practicalities of implementing closures,  call frames and the like
21:51:31 <eflister> so (a -> r) -> r looks to me like "if you have an a and an a -> r, i'll give you an r" -- kind of just function application.  but i assume that's missing something important :)
21:51:54 <Cale> eflister: Just "if you have an (a -> r), then I'll give you an r"
21:52:15 <Cale> eflister: This is *sort of* like a value of type a, except that you can only ask questions of type r about it.
21:52:25 <Zao> let x = omg (+3)
21:52:40 <Cale> eflister: For instance, suppose we have r = Bool.
21:52:45 <andrewsw> it implies that there is an a already lying around?
21:53:15 <Cale> Then (a -> Bool) -> Bool is like a box where you can ask it any true/false question about a value of type a, and it will give you an answer.
21:53:27 <Cale> However, it might be cheating.
21:53:40 <Cale> There might not actually be a value of type a which would give the same answers as the box.
21:54:02 <Cale> For example, it could give you the negation of whatever the answer would have been instead.
21:54:29 <scutigera> aren't you asking the question about type (a -> r) ?
21:54:34 <Zao> andrewsw: You never have access to a a.
21:54:50 <Cale> scutigera: a function of type (a -> r) is an r-valued question about a value of type a
21:54:53 <Zao> *the a
21:55:13 <andrewsw> Zao: yes I realise that, but the type (a -> r) -> r says to me that there is some a aroudn somewhere
21:55:18 <andrewsw> *around
21:55:27 <andrewsw> or am I misguided there?
21:55:44 <Cale> andrewsw: Maybe not... perhaps, in the r = Bool case, it's just the const False function.
21:56:08 <copumpkin> r = Void!
21:56:13 <scutigera> \_ -> False
21:56:21 <andrewsw> sure
21:56:28 <Cale> In general, there are functions of type (a -> r) -> r which are not of the form (\f -> f x) for some x :: a
21:56:39 <andrewsw> yes
21:56:40 <Zao> Cale: But the mysterious entity must apply it to something a-ish, surely?
21:56:49 <Cale> However, those do correspond to an important class of such functions.
21:56:56 <Zao> May it be an actual value, _|_ or whatever?
21:57:18 <Cale> Specifically, in the Cont monad, those are the Cont r a values resulting from  return x  for various x :: a
21:57:32 <Cale> Zao: It may not apply the function at all.\
21:57:35 <pikhq> \f->f undefined -- Mmm. Evil lambda.
21:57:47 <Cale> Zao: If it can get a value of type r from somewhere else, it may give you that.
21:57:58 <copumpkin> :t ($ undefined)
21:57:59 <lambdabot> forall a b. (a -> b) -> b
21:58:04 <andrewsw> it can ignore the (a -> r) essentially
21:58:18 <Cale> Zao: Or it might twist your question in various ways before asking some other question-box :)
21:58:30 <Zao> Sneaky, but sure :)
21:59:00 <Cale> It's the sneaky possibilities which result in the strange properties that the Cont monad has. :)
21:59:09 <eflister> cale: what's an example where twisting is beneficial?
21:59:32 <Zao> It's not an instance of Honest t and Transparent t.
22:00:19 <aavogt> HonesT a
22:01:22 <Berengal> eflister: "Give me a function to convert a number to a string, and I'll give you a string", i.e. (Int -> String) -> String. If, to get that number, it suddenly divides by zero, it can just return a string "divide by zero" instead of converting the number to a string like it should
22:01:44 <Cale> Berengal: That's a good one :)
22:03:48 <eflister> ok, so then how do we connect this to "representing the rest of a computation"
22:04:55 <Cale> eflister: Okay, so instead of an Int in this case, we're using (Int -> String) -> String, and the Int -> String is meant to be the rest of the computation.
22:05:01 <Cale> That is, what we would have done with the Int
22:05:17 <Cale> (to get the final result of type String)
22:07:11 <Cale> eflister: Since this is no longer an Int, but an (Int -> String) -> String, it's allowed to give up on the remainder of the computation, and just produce an error
22:07:43 <eflister> so, for instance, if my Int were too large to keep in memory, and my (Int->String) were too expensive to actually compute, i might rather just carry around an unevaluated potential String that may or may not be related to what i would have gotten from applying my (Int->String) to my Int?
22:08:16 <Cale> It's also allowed to use the remainder of the computation in more subtle ways. For instance, it could try some Int value, and if it didn't like the final result, go back and choose some other one.
22:08:36 <Cale> That's... something rather unrelated to this.
22:08:52 <Cale> All the functions we're talking about here might as well be strict functions.
22:10:08 <Berengal> eflister: Something I've been working a bit on lately is storing the rest of the computation, loading it later and resuming.
22:11:15 <iaefai> Has anyone seen the ghc 6.12 mac installer package for the mac stop at 'preparing glasgow hasekll compiler'?
22:11:27 <Berengal> This allows us to do arbitrary things inbetween two instructions, say, write a http response and wait for a new request
22:11:59 <Berengal> Which again leads to webapps like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21264#a21264
22:20:39 * hackagebot upload: data-ordlist 0.4.1 - Set and bag operations on ordered lists (LeonSmith)
22:33:04 <emef> so i'm planning on developing some sort of physics engine and i'm not sure exactly how to go about this. I was thinking it would be nice to have some sort of typeclass that requires certain accessor functions (like mass, velocity, etc) then i could write some generic functions that take any type of this typeclass and change it's state
22:33:45 <emef> is this a case where i would use some sort of state monad? i'm still a beginner at haskell and this is a project which will hopefully help me grasp the workflow of a function language rather than its semantics
22:34:23 <emef> does anyone have any advice on how i would structure a library like this?
22:36:31 <SubStack> you could just use records
22:37:23 <emef> well yeah i wanted to be able to create different objects (records) that implement a PhysicsObject typeclass that would act like an interface
22:37:33 <emef> is that a good way to go?
22:37:40 <copumpkin> I wouldn't
22:37:52 <aavogt> it does work
22:38:00 <copumpkin> it's basically using haskell like a dynamic language and typeclasses like OO interfaces
22:38:14 <copumpkin> nothing wrong with it, but you might be missing out on some opportunities
22:38:16 <emef> i probably shouldn't bend it that way eh?
22:38:22 <aavogt> what is a dynamic language in that sense, copumpkin?
22:38:35 <copumpkin> well, maybe not a dynamic language
22:38:41 <copumpkin> but an OO one
22:38:42 <aavogt> the required typeclasses are statically known
22:38:44 <emef> that's the point of this project, so i can learn to utilize haskell rather than try and make it work like c++ or java
22:39:11 <copumpkin> it'd be full of existential wrappers on "interfaces" as typeclasses
22:39:53 <Cale> Using something existential-esque might not be a bad way to go though. (You might not need a real existential type)
22:41:19 <copumpkin> I guess you should think hard about what you intend to add to it in future, and why you think it should be extensible
22:41:23 <Cale> I might just represent a physical object as a record of "operations" -- each of which might produce futher objects or be information about the object. You needn't actually do anything with real mutation here.
22:42:01 <Cale> It depends on what sorts of operations you want your physics engine to support.
22:42:52 <quicksilver> typeclasses are just a way of getting the type-checker to 'automatically' collect the record of operations from the type
22:43:03 <quicksilver> it's more flexible ; more general to just collect the record yourself
22:43:08 <quicksilver> it might not make sense to be type directed.
22:43:18 <quicksilver> in the right context being type-directed can saving typing (pun!)
22:43:23 <copumpkin> might want to check out http://physics-dph.blogspot.com/ btw
22:44:24 <Cale> But you might have something like (just a minimal example, not intended to be realistic)  data Object = O { contains :: Point -> Bool, centre :: Point, step :: TimeDiff -> Object, draw :: IO () }
22:45:13 <emef> ahh thankyou that sounds like a better idea
22:45:22 <aavogt> yeah, once you start adding dummy parameters to your typeclass methods to be able to resolve the instance, then you might as well use data instead
22:45:24 <Cale> and then let's say you want to have an accelerating sphere...
22:45:59 <Zao> I intend to use syb for my future awesome physics solver.
22:46:11 <emef> syb?
22:47:14 <jmcarthur> what does syb have to do with physics?
22:47:19 <Zao> Library for generic programming.
22:47:43 <Zao> jmcarthur: Take update/solve function, throw at game state, have it transform anything physical.
22:47:44 <Cale> sphere r x v a = O { contains = \p -> norm (p - x) <= r, centre = x, step = \t -> sphere r (1/2 * a * t^2 + v * t + x) (a*t + v) a, draw = drawSphere r x }
22:47:46 <aavogt> Cale: could you mix and match different sets of capabilities by using records of methods?
22:47:59 <jmcarthur> Zao: heh, i guess i can see that
22:48:07 <aavogt> apply the laws of physics everywhere
22:48:09 <jmcarthur> i kind of prefer more structured approaches, but to each his own
22:48:10 <Cale> aavogt: yeah, you might want to factor the types a bit differently in a real program
22:49:00 <aavogt> I mean if you use typeclasses you can say:    f :: (HasX a, HasY a, HasZ a) => a -> IO ()
22:49:34 <aavogt> while if you use data, you have to predict which combinations could exist when you write the data decl
22:49:45 <aavogt> as opposed to deciding when you write the instances
22:49:52 <Cale> aavogt: Well, you could factor the record types into smaller pieces as well.
22:51:10 <Cale> aavogt: But if you know what operations you'll want to support, there's really only one type which you need.
22:51:16 <Cale> The general one :)
22:51:26 <Cale> (which just consists of the implementations of those operations)
22:52:05 <Cale> I also wanted to point out that you can also use RecordWildCards to get nice syntax for this style of programming:
22:52:10 <Cale> circle radius (ax,ay) (vx,vy) (x,y) = GameObject { .. }
22:52:10 <Cale>   where updateObject gs ks = [circle radius (ax,ay) (vx+ax,vy+ay) (x+vx,y+vy)]
22:52:10 <Cale>         renderGameObject = drawCircle (x,y) radius
22:52:10 <Cale>         hitTest (x',y') = distance (x,y) (x',y') <= radius
22:52:46 <emef> hmm interesting
22:52:47 <Cale> This was in an example where we have:
22:52:48 <Cale> data GameObject = GameObject { updateObject :: GameState -> [Key] -> [GameObject],
22:52:48 <Cale>                                renderGameObject :: IO (),
22:52:48 <Cale>                                hitTest :: Point -> Bool }
22:52:50 <freiksenet> is it possible to skip first line of input without reading it?
22:53:08 <Cale> freiksenet: what do you mean "without reading it"?
22:53:11 <quicksilver> freiksenet: well, read it and ignore the result, is the simplest way.
22:53:32 <Cale> freiksenet: yeah, just execute  getLine  and fail to capture the result
22:53:43 <freiksenet> Cale: ok, that works.
22:53:56 <freiksenet> it won't get evaluated ever so I don't lose time on that IO?
22:54:27 <Cale> That IO does take time, as it would when written in any programming language.
22:54:45 <Cale> You can't skip over one line without determining where the newline occurs.
22:54:59 <Cale> and in order to find the first newline, you have to look at each character up to that point
22:55:01 <freiksenet> Cale: ok, makes sense.
22:55:06 <freiksenet> thanks
22:57:02 <emef> Cale: do you know of a good tutorial on a game/rendering engine?
22:58:50 <quicksilver> I've not seen one.
22:59:05 <quicksilver> Lots of people who write one are doing something slightly experimental, just cos that's interesting.
22:59:12 <quicksilver> e.g. they're playing with FRP.
22:59:13 <SubStack> in haskell?
22:59:19 <quicksilver> which is fun, but might not make for a simple tutorial.
22:59:28 <SubStack> indeed
23:00:07 <emef> yeah in haskell, or any sort of tutorial that's not something like parsing
23:00:22 <SubStack> you could dive into hopengl
23:00:42 <SubStack> the red book was ported and makes for good reference material
23:00:54 <SubStack> despite the unwarranted use of IORefs
23:00:57 <emef> was it ported? i was looking into hopengl briefly earlier
23:00:58 <aavogt> Cale: hmm, how do you ensure that the variations that can't implement the most general interface cannot be passed to functions that require those additional features?
23:01:06 * Zao kicks bindings-directx on the shins.
23:01:27 <Zao> For some reason, it refuses to build when half the source is missing from the darcs repos :P
23:03:00 <SubStack> emef: for some reason all the links to the glut examples are dead, but they're in the distribution still I'm pretty sure
23:03:29 <Cale> aavogt: That'll just be a straightforward type error, won't it?
23:03:37 <emef> thanks, i'll look into i
23:03:39 <emef> it
23:04:25 <SubStack> the problem is that opengl is absurdly imperitive and stateful
23:04:40 <SubStack> although there are people around here who are trying to change that ;)
23:05:51 <aavogt> Cale: well what I mean is that you sometimes want to separate out your objects based on the interfaces they provide.... say you have some GameObjectS which don't have sensible ways to handle all KeyS?
23:06:57 <Cale> aavogt: (The intention there would be that they just ignore any keys that they don't respond to)
23:07:57 <quicksilver> that's certaily not something I'd personally try to model in the typesystem
23:08:02 <Cale> But I get what you mean. You might conceivably want to use static typing to enforce certain things about which objects are referenced by various parts of the program.
23:08:05 <quicksilver> (whether an object responds to the key 'H')
23:08:22 <aavogt> ok, so with that design, there's no way to statically ensure that your object supports some set of KeyS
23:08:30 <dmwit> Especially once you start reading in keymaps from a config file... =P
23:08:31 <quicksilver> I'd consider that a dynamic property and model it by doing nothing in response to that event, or perhaps returning the value Nothing.
23:09:04 <quicksilver> anythign you want to enforce statically must be part of the type, agreed, aavogt.
23:09:32 * dmwit is experimenting with using literal tabs in his Haskell.
23:09:42 <quicksilver> but the more dynamic model lets things change - like a particle which splits into new particles with just slightly different behaviour
23:09:44 <aavogt> hmm, maybe you can get the best of both worlds with phantom types here?
23:09:57 <quicksilver> and 'procedural behaviour'
23:09:57 <Cale> dmwit: ew.
23:10:02 <dmwit> Cale: nope
23:10:03 <quicksilver> where you don't want to generate all the types upfront.
23:10:04 <aavogt> then the appropriate   fmap (const undefined) to 'coerce'
23:10:08 <dmwit> Cale: I haven't noticed any "ew" yet.
23:10:46 <Cale> dmwit: hard tabs are evil, because Haskell isn't really indentation sensitive -- it's alignment sensitive
23:10:55 <dmwit> Right.
23:11:09 <Cale> I hope you're at least using 8-space tabs.
23:11:10 <dmwit> This is why I use tabs for indentation, and spaces for alignment -- and don't get confused about the difference.
23:11:27 <dmwit> The whole point of tabs is that it's up to the person editing the code how big they are.
23:11:36 <Cale> The compiler will treat tabs as aligning to the next 8-space multiple
23:11:40 <dmwit> Yes.
23:11:53 <dmwit> Like I said: I'm carefully differentiating between alignment and indentation.
23:12:04 <dmwit> For instance, blocks always start on their own line.
23:12:33 <dmwit> One level of indentation greater than the previous block, if any.
23:12:55 <Cale> Oh, that's even worse, because you end up either with a hideous layout, or you drive yourself mad with lines starting with some number of tabs and some number of spaces
23:13:16 <theorbtwo> Actually, the whole point of hard tabs is that they save a little bit of bandwidth on a very bandwidth-starved telephone line before the invention of compression.  They are obsolete and shouldn't be used.
23:13:19 <Cale> Like, having to hit newline after 'do' or 'let'
23:13:30 <theorbtwo> ...largely because of what Cale just said.
23:13:30 <dmwit> I don't feel mad.
23:13:41 * aavogt thinks dmwit is trolling :)
23:14:16 <theorbtwo> You can either very carefully always use hard tabs at the beginning of lines, and not spaces, or always use spaces and not tabs, as a pratical matter.
23:14:23 <dmwit> theorbtwo: I like four-space indentation. My advisor likes two-space indentation. There's a crazy here who uses six spaces. Who's right?
23:14:28 <theorbtwo> The second one is a lot easier.
23:15:01 <aavogt> dmwit: run everything through a pretty printer before looking at it
23:15:09 <dmwit> very practical, thanks
23:15:12 <ManateeLazyCat> I use `import Data.Map (Map)` in file Manatee.Types, ghc-6.12.1 give me error: Multiple declarations of `Manatee.Types.Map', looks so strange? I use two option: {-# LANGUAGE ExistentialQuantification, DeriveDataTypeable #-}, i can't understand.
23:15:12 <ManateeLazyCat>  
23:15:13 <theorbtwo> dmwit: Two choices: the guy writing the code is right, or the guy who outranks everybody else is right.
23:15:29 <dmwit> theorbtwo: I offer you choice three: everybody is right.
23:15:57 <dmwit> In a real way, your text editor's tab settings *are* a pretty-printer.
23:16:23 <theorbtwo> dmwit: And your console's.  And less's, and everything else you might potentially use to view this file.
23:16:24 <dmwit> ManateeLazyCat: paste it, maybe?
23:16:29 <ManateeLazyCat> When i use `import Data.Map (Map)`, GHC should consider `Map` is `Data.Map.Map`, why it consider i declare `Map` twice?
23:16:31 <ManateeLazyCat> okay.
23:16:35 * dmwit nods at theorbtwo
23:16:44 * ManateeLazyCat pasted "Manatee.Types.hs" at http://paste2.org/get/672854
23:16:46 <ManateeLazyCat> dmwit: See above
23:16:53 <quicksilver> dmwit: I agree; customisable tab widths are a nice idea. However they're a pain in haskell
23:17:11 <quicksilver> dmwit: for example you need a newline before *and* after every 'do'
23:17:24 <dmwit> Surely not before.
23:17:27 <dmwit> Only after. =)
23:17:35 <quicksilver> yes, before
23:17:48 <dmwit> Blocks take the indentation of the first non-whitespace after the end of the 'do'.
23:17:50 <aavogt> I think you could setup your editor to pretty print to your indentation preferences on loading the file, and then saving to whatever the standard indentation is
23:17:53 <ManateeLazyCat> dmwit: You can search `Map` in Manatee.Types.hs, it's a problem of GHC?
23:17:55 <quicksilver> otherwise you risk haskell deciding you are 'less indented' than the enclosing context.
23:18:08 <quicksilver> dmwit: but only if that is strictly to the right of the enclosing block.
23:18:26 <quicksilver> (and the decision 'strictly to the right of' is hardwired to believe TAB = 8 spaces)
23:18:27 <dmwit> quicksilver: but of course
23:18:29 <aavogt> it doesn't have to be impractical once set up
23:18:41 <dmwit> Blocks must have strictly increasing indentation -- but that's no hardship.
23:19:49 <quicksilver> dmwit: hmm. maybe you're right. I can't construct the example I was thnking of.
23:19:51 <dmwit> ManateeLazyCat: What's the exact error?
23:20:10 * dmwit challenges the status quo
23:20:15 <dmwit> It's mildly effective!
23:20:53 <ManateeLazyCat> Multiple declarations of `Manatee.Types.Map'
23:21:22 <dmwit> ManateeLazyCat: What else?
23:21:28 <dmwit> ManateeLazyCat: The whole thing, please. =)
23:23:24 <ManateeLazyCat> dmwit: Okay, i write `import Data.Map (Map)` in file Manatee.Types.hs for use short name `Map`, but GHC give me "Multiple declarations of `Manatee.Types.Map'" error at line that use `Map`.
23:24:49 <ManateeLazyCat> "data TabGroup = Map WindowId (Map (PageMode, ModeVisible) [(ProcessId, PageId, PagePlugId, PageName)])"
23:24:53 <ManateeLazyCat> is wrong format? When i comment this line, GHC won't report error.
23:25:32 <Zao> ManateeLazyCat: You're defining a ctor named Map, and try to import one named Map as well.
23:25:36 <dmwit> ManateeLazyCat: You are declaring a new datatype with a constructor called Map.
23:25:41 <Muad_Dibber> the problem is data TabGroup = Map ... defines another ctor named Map
23:25:57 <Zao> Consider an   import qualified Data.Map (Map) as M  or so.
23:25:57 <dmwit> ManateeLazyCat: ...twice
23:26:06 <dmwit> ManateeLazyCat: Once in data PageList, once in data TabGroup.
23:26:11 <dmwit> ManateeLazyCat: It has nothing to do with your import. =)
23:26:28 <quicksilver> I think you mean data TabGroup = TabGroup (Map WindowId .....
23:26:35 <dmwit> no
23:26:38 <quicksilver> i.e. you missed the constructor.
23:26:40 <dmwit> I think he means type instead of data. =)
23:26:45 <quicksilver> no, never use type
23:26:54 <ski> (or possibly s/data/newtype/)
23:26:58 <dmwit> or not
23:27:12 <dmwit> Yeah, can't tell just from this code which he means.
23:27:39 <dmwit> I guess you're probably right, though.
23:27:43 <ManateeLazyCat> quicksilver: you're right, i lost TabGroup after `=`
23:28:16 <ManateeLazyCat> quicksilver: I use it like `type`, and i need `data.
23:28:37 <ManateeLazyCat> Sorry, my stupid mistake. :)
23:28:54 <ski> ManateeLazyCat : if `TabGroup' is "essentially" just a type synonym, but you want a new distict type for it, consider using `newtype' instead of `data'
23:29:10 <SubStack> oh nifty, if I implement (*) and quot in Num, I get (^) for free
23:29:47 <ski> (which you can do, assuming you don't add another data constructor, or another argument to the current data constructor)
23:31:01 <SubStack> building DSLs by abusing Num is such fun
23:32:08 <aavogt> @type (^)
23:32:09 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
23:32:23 <aavogt> @src (^)
23:32:23 <lambdabot> x ^ 0            =  1
23:32:24 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
23:32:24 <lambdabot>   where f _ 0 y = y
23:32:24 <lambdabot>         f x n y = g x n
23:32:24 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
23:32:25 <lambdabot>                       | otherwise = f x (n-1) (x*y)
23:32:27 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
23:32:55 <aavogt> @type even
23:32:56 <lambdabot> forall a. (Integral a) => a -> Bool
23:33:04 <quicksilver> although that can be annoying in cases where repeated squaring isn't the right implementation for (^)
23:33:23 <aavogt> so it should be a typeclass method?
23:33:37 <dmwit> aavogt: For fun, try benchmarking even on Int's compared to, say, C.
23:33:44 <quicksilver> that's the natural conclusion of my objection, yes.
23:33:53 <quicksilver> depends what you think the Num typeclass is 'for' though
23:34:13 <quicksilver> you can't do a good Interval Arithmetic instance because of that (^) implementation.
23:34:18 <aavogt> tough choice if the need to override it is extremely rare
23:35:23 <Veinor_> quicksilver: (^) = undefined for intervals? :p
23:35:32 <Veinor_> oh wait, you can't override, right
23:35:51 <dmwit> No, there is a good implementation, it's just not via repeated squaring.
23:45:13 <quicksilver> aavogt: well it could be a method with a default implementation.
23:45:23 <quicksilver> aavogt: then instances which don't want to override it could decide not to.
23:45:39 <quicksilver> I think it's simply 'Num wasn't intended for this'
23:45:50 <quicksilver> just a shame that it's so nearly so good at it :)
23:47:30 * ski idly wonders whether <http://en.wikipedia.org/wiki/Operational_transformation> is related to the darcs patch theory
23:48:07 <dmwit> pretty related, yeah
23:49:35 <RLa> cabal-install requires package time, how the heck i install it without cabal?
23:50:23 <dmwit> time should come with your installation of GHC
23:50:31 <RLa> no, it did not
23:50:33 <RLa> apparently
23:50:38 <dmwit> um
23:50:44 <aavogt> RLa: cabal install has a bootstrap.sh to get stuff like network... maybe it can fetch time too
23:50:58 <aavogt> or the cabal install you downloaded is too new for your ghc
23:51:00 <dmwit> Anyway, it's pretty easy to install packages without cabal-install.
23:51:21 <dmwit> Grab the tarball from hackage, unpack it, and run Setup.hs configure && Setup.hs build && Setup.hs install.
23:51:24 <RLa> aavogt, bootstarp.sh is exactly what complains
23:51:34 <dmwit> but seriously
23:51:42 <dmwit> Could you post the output of ghc-pkg list somewhere?
23:51:43 <dmwit> ?hpaste
23:51:43 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
23:51:45 <dmwit> for example
23:51:51 <RLa> there is old-time tho
23:51:57 <RLa> a sec
23:52:39 <dmwit> ghc --version # would be handy, too
23:53:47 <RLa> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21280
23:54:05 <RLa> ghc is 6.10.4
23:55:07 <dmwit> odd
23:55:22 <dmwit> What method did you use to install GHC?
23:55:59 <dmwit> I mean... you could certainly try installing the time package by hand.
23:56:06 <RLa> well, i needed agda, not ghc, so i used apt-get install agda-mode
23:56:07 <dmwit> http://hackage.haskell.org/package/time is the hackage page
23:56:40 <RLa> but i got too old version of agda and prof told me to upgrade through cabal
23:56:57 <dmwit> tar xf time-1.1.4.tar.gz && cd time-1.1.4 && ghc --make Setup.?hs && ./Setup configure && ./Setup build && sudo ./Setup install
23:57:00 <dmwit> =)
23:57:35 <dmwit> hm
23:57:42 <dmwit> maybe have to replace the Setup.?hs with a Setup.*hs
23:58:00 <dmwit> I can't remember whether ? is "any one char" or "one or no chars" now.
23:58:32 <RLa> a sec
