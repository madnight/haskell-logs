00:01:22 <ksf> blast those html5 guys
00:01:36 <ksf> >4mb html files all around, and no sources in sight
00:01:45 <ksf> almost makes me believe they're writing those by hand.
00:02:39 <ksf> how can people possibly think that putting a 4 meg html file up on the web is a decent idea?
00:06:00 <Yamagushi> wtf
00:06:02 <Yamagushi> lies
00:06:06 <trzkril> ksf: they test those pages via their LAN connection to their webserver and everything is just fine.
00:06:11 <roboshibby> greetings
00:09:25 <ksf> trzkril, they must've faster machines than me because both firefox and chrome become seriously sluggish rendering 4 megs, even when its loaded.
00:33:39 <ksf> wtf they actually _are_ editing that beast by hand. I've seen diffs.
00:49:15 <roboshibby> ksf, what? catch me up
00:56:00 <Jonno_FTW> *tumbleweed*
00:56:25 <roboshibby> rofl
00:56:35 <roboshibby> well said
00:57:22 <copumpkin> shh, I'm hunting bunny wabbits
00:58:40 <roboshibby> http://icanhascheezburger.com/2010/02/18/funny-pictures-sleepy-kitteh-stretching/
00:58:54 <roboshibby> click the link, you know you want to
00:59:26 <Jonno_FTW> since when was this haskell-blah?
01:00:16 <roboshibby> is that the policy?
01:00:22 <Jonno_FTW> something like that
01:00:29 <Jonno_FTW> also, i want my 50 seconds back now
01:00:57 <otulp> roboshibby: http://www.youtube.com/watch?v=AAfpq6EPKck Your eyes only
01:05:37 <roboshibby> uhm
01:05:43 <roboshibby> kinda weird, can't lie
01:26:00 <ap139> hello
01:33:08 <Cale> hello
01:38:43 <ap139> how to change channel
01:38:49 <ap139> please
01:39:21 <ap139> tell me
01:46:49 <Jonno_FTW> in irc?
01:46:50 <Jonno_FTW> iirc
01:47:02 <Jonno_FTW> you type /join #channel
01:47:15 <Jonno_FTW> afaik
02:08:35 <mux_> how would you guys initialize a mutable vector to a list of elements with vector-0.5? Using Data.Vector.Generic.New as New I came up with "New.run (New.unstream $ S.fromList mylist)
02:09:01 <mux_> S.fromList being Data.Vector.Fusion.Stream.fromList
02:09:29 <mux_> not sure if this has any advantage compared to a plain new and a forM_ loop calling write
02:13:25 <tensorpudding> does filterM break laziness?
02:13:33 <tensorpudding> @src filterM
02:13:33 <lambdabot> Source not found. Just try something else.
02:13:49 <quicksilver> @hoogle filterM
02:13:49 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
02:13:50 <lambdabot> Data.Graph.Inductive.Query.Monad graphFilterM :: GraphM m gr => (Context a b -> Bool) -> GT m (gr a b) [Context a b]
02:14:14 <quicksilver> tensorpudding: any operation which returns "m [a]" will perform all the effects in the monad 'before' returning the complete list [a]
02:14:23 <tensorpudding> okay
02:14:38 <quicksilver> that's just what the type means.
02:14:48 <quicksilver> the only exception would be functions like getContents
02:14:52 <quicksilver> which are broken.
02:15:00 <quicksilver> (and have to cheat to acheive that effect)
02:15:25 <Jonno_FTW> @src liftM
02:15:25 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
02:15:59 <tensorpudding> @src foldM
02:15:59 <lambdabot> foldM _ a []     = return a
02:15:59 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
02:16:54 <Jonno_FTW> @src M
02:16:54 <lambdabot> Source not found. :(
02:17:15 <Jonno_FTW> @src fmap
02:17:16 <lambdabot> Source not found. Where did you learn to type?
02:17:19 <Jonno_FTW> @src fMap
02:17:19 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:17:28 <Jonno_FTW> @hoogle fmap
02:17:28 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
02:17:28 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
02:17:28 <lambdabot> Control.Monad.Instances fmap :: Functor f => (a -> b) -> f a -> f b
02:17:32 <Jonno_FTW> >:3
03:20:45 <Beelsebob> argh
03:20:54 * Beelsebob just discovered a new way in which C's type system sucks
03:24:33 <zygoloid> Beelsebob: don't leave us hanging :)
03:24:58 <Jonno_FTW> how do you keep morons hanging?
03:25:05 <Beelsebob> BOOL ctrlDown = modifierFlags & NSControlKeyMask;
03:25:09 <Beelsebob> that code is fine, right?
03:25:16 <Beelsebob> >.>
03:25:20 <Beelsebob> (obviously not, but why)
03:25:49 <Jafet> There isn't a bool type in C, so I don't see why not
03:26:10 <Beelsebob> there is actually since C99
03:27:02 <Beelsebob> to push this further... consider whether if (ctrlDown) and if (modifierFlags & NSControlKeyMask) cause the same branch to be executed
03:27:40 <Jafet> @quote generalized
03:27:40 <lambdabot> No quotes match. stty: unknown mode: doofus
03:27:49 <Jafet> @quote generalization
03:27:49 <lambdabot> No quotes match. I've seen penguins that can type better than that.
03:28:26 <Jafet> @quote generalisation
03:28:26 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
03:28:33 <IceDane> How is it exactly that <*> works? Can I use it to do something like this?: parser = try ( string "http://" <*> parseRestOfUrl ), and it would 'concatenate' the results together or something?
03:28:35 <Jafet> Damn you brits
03:29:21 <Beelsebob> (the answer is no â€“Â because in this instance modifierFlags is 32 bit, and the lower 8 bits of NSControlKeyMask are all 0)
03:29:31 <Beelsebob> the first one executes the false branch, the second the true branch
03:32:16 <zygoloid> Beelsebob: you're saying conversion to C99 BOOL only looks at the bottom char?
03:32:36 <Beelsebob> I'm saying that conversion from int -> int of different lengths truncates
03:32:42 <Beelsebob> and a bool in C99 is an 8 bit int
03:32:43 <Jafet> C conversion to boolean: if n==0 then True else False
03:32:47 <Jafet> Erm
03:32:52 <Jafet> if n/=0
03:33:03 <Beelsebob> Jafet: nope
03:33:10 <Beelsebob> C conversion to boolean is just truncating
03:33:24 <Beelsebob> same as any other integer type to integer type conversion
03:33:48 <zygoloid> if nothing else this is a reason to use a c++ compiler as a 'better C' ;p
03:33:52 <Twey> Really?  2 is falsy in C?
03:34:08 <zygoloid> Twey: no, but (unsigned char)256 is
03:34:29 <Twey> Well, of course â€” (unsigned char) 256 == 0
03:47:28 <Jonno_FTW> what is a signed char?
03:48:19 <Jafet> Something you pay Gordon Ramsey a lot to grill
03:48:55 <idnar> Jonno_FTW: like an unsigned char, except signed
03:49:15 <Jonno_FTW> what is an unsigned char then?
03:49:43 <idnar> it's generally an 8-bit numeric type
03:52:20 <savonarola> is usage of State monad considered to be normal practice? isn't this a return to error-prone imperative world?
03:52:48 <fasta> Why do RecordWildCards bring variables into scope which are not imported?
03:53:32 <IceDane> What would be the best way to resolve an hostname to an IP address?
03:53:51 <IceDane> Or well, how can I use a hostname(url for example) to connect to a server?
03:54:15 <BONUS> savonarola: it's normal practice and it's not really a return to the imperative world since it's still modeled as a pure function s -> (a,s)
03:54:15 <IceDane> .. Wait, scratch that. It's already doing that
03:54:30 <BONUS> it just comes very handy for stuff like random numbers and such
03:54:58 <fasta> That is, import module Foo hiding (x,y); data X = X {x,y ::Int} and then z X{..} Foo{..} tells me that x conflicts.
03:58:44 <savonarola> BONUS, yes it's build in pure function, but inside a state model controlling state is somewhat like  controlling a global variable
03:59:08 <savonarola> isn't this considered dangerous
04:00:43 <BONUS> i tend not to think of it that way, i just tend to think of it as gluing together several s -> (a,s) functions. it's still pure and all
04:00:50 <Jafet> It formalizes the semantics of mutable state in a way that is impossible in other languages
04:01:15 <fasta> Jafet, that doesn't mean anything.
04:01:45 <Cale> Jafet: Huh? It's quite possible in other languages...
04:02:05 <fasta> savonarola, in Haskell you also have the equivalent of null pointers, they are called Nothing. It is just a lot more explicit.
04:02:14 <Cale> Though, the monad abstraction as a whole is often difficult to do well.
04:02:18 <Jafet> Nevermind, that was poorly worded
04:02:41 <fasta> savonarola, or you can have references to undefined.
04:03:04 <fasta> savonarola, what is pure and what is not is not what is important (those are just words).
04:03:23 <fasta> savonarola, the important thing is to make the state-space of your program to be as small as possible.
04:03:50 <fasta> savonarola, all the encapsulation and other fancy words come down to just that.
04:03:55 <zygoloid> fasta: it's not bringing the x and y from Foo into scope, it's bringing in the x and y you'd get in z X{x=x, y=y} Foo{x=x,y=y} = ... (that is, the variables, not the record labels)
04:04:13 <savonarola> fasta, does this mean to avoid using State monads widely?
04:04:39 <fasta> savonarola, the thing is that it becomes tiring to pass variables all the time.
04:04:49 <fasta> savonarola, that is why the state monad exists.
04:05:03 <fasta> savonarola, and the state space does not become larger in all cases.
04:05:42 <BONUS> yeah, the state monad itself does not actually allow for mutable state and all the headaches that come with it. it just abstracts over functions that take some state and return a value along with a new state
04:06:11 <BONUS> for really mutable data, there's the ST monad, which is pure on the outside but impure on the inside, so it should be used wisely
04:06:12 <fasta> savonarola, in the state monad there are no pointers.
04:08:01 <fasta> BONUS: this "impure" is a matter of opinion.
04:08:16 <fasta> BONUS: the operations of the ST monad have a well-defined semantics.
04:08:17 <zygoloid> savonarola: it's not as bad as global state; you can have two concurrent "State s" computations which are using different state (even if they're executing the same code)
04:08:34 <fasta> The ST monad is also not global state.
04:08:48 <fasta> You can run two ST computations in parallel.
04:09:44 <BONUS> hmm, i suppose you're right in some way
04:18:49 <nlogax> i'm gonna go with the guy whose name is in all caps, he must be important
04:19:05 <BONUS> WELL IT MAKES SENSE
04:20:45 <quicksilver> there is a sense in which everythign is "impure on the inside"
04:20:49 <quicksilver> it's the outside that matters
04:20:54 <quicksilver> ST is semantically pure, so it's pure.
04:21:35 <BONUS> hmm yeah, actually i agree
04:30:11 <IceDane> Is it possible to somehow return Nothing if I can't parse something using Parsec? I'm trying to parse URLs, and I want to set the relativePath of my custom type to Nothing if the url is just "www.google.com"
04:30:49 <osaunders> @hoogle (a -> a -> b) -> [a] -> [a] -> [b]
04:30:49 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
04:30:50 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
04:30:50 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
04:31:14 <McManiaC> is anyone here using Hack?
04:31:22 <McManiaC> I'm having problems with utf8 chars hereâ€¦
04:32:41 <quicksilver> IceDane: yes.
04:32:51 <McManiaC> IceDane: either (const Nothing) Just $ parse ...
04:33:09 <quicksilver> IceDane: parser <|> return Nothing
04:33:20 <quicksilver> or, if you parser doesn't already return a MAybe type
04:33:27 <quicksilver> fmap Just parser <|> return Nothing
04:33:33 <ksf> IceDane, in Control.Applicative is optional
04:33:54 <ksf> ...which is exactly what quicksilver wrote
04:33:57 <IceDane> I see
04:33:59 <IceDane> Thanks guys =)
04:35:04 <quicksilver> McManiaC's version sticks the Nothing in "after" parsing, if there is a parse error
04:35:19 <quicksilver> my version sticks it in "inside" the parsing, effectively guaranteeing there can never be an error
04:35:25 <quicksilver> I think they're equivalent though.
04:36:53 <ksf> does any of those fancy record packages solve the overloading problem?
04:37:35 <quicksilver> you mean having two records sharing a field name?
04:38:10 <ksf> yep
04:38:16 <quicksilver> I don't they do exactly
04:38:23 <quicksilver> but they make the obvious solution a whole lot more useful.
04:38:35 <quicksilver> The 'obvious' solution being to make a typeclass.
04:38:42 <ksf> I'm going to generate all that stuff anyway, so...
04:38:55 <quicksilver> but once you have a decent notion of 'lens' then a lens in a typeclass is a lot more useful than, say, a selector in a typeclass
04:41:25 <BONUS> interesting (little known) fact: in the ST monad, the ST stands for "Star Trek"
04:41:46 <Sagi> is it a BONUS-fact?
04:41:55 <BONUS> honest to god
04:42:08 <osaunders> lol
04:42:41 <ksf> it's documented that the file extension .hs stands for "homosexual"
04:43:20 <Sagi> there's also the lonely variety
04:44:25 <Sagi> blegh, I want to add 4-bit values to a Bytestring, but I have no clue how to do that.
04:44:46 <osaunders> Sagi: Data.Binary ?
04:45:02 <osaunders> There are a couple of libraries that provide that module.
04:45:06 <ksf> I'm actually serious. http://uncyclopedia.wikia.com/wiki/Haskell
04:45:37 <Sagi> ksf: ah, it is an alternative to .name?
04:45:48 <Sagi> for people being honest about their preferences?
04:46:14 <Sagi> osaunders: I looked at it, but it seemed awfully complicated for my purpose
04:46:29 <Sagi> I still have to use bit masking etc.
04:46:47 <Sagi> (or I don't understand the module ofc.)
04:46:48 * ksf can't tell where he stopped being able to follow the train of thought
04:47:13 <osaunders> Sagi: Some guy wrote a DSL for parsing binary protocols a while ago.
04:47:30 <osaunders> I'm pretty sure that will handle packed structures.
04:47:45 <osaunders> And might work in reverse, giving you what you want.
04:48:20 <osaunders> Sagi: http://cprg-research.blogspot.com/2010/02/domain-specific-language-for-binary.html
04:48:46 <osaunders> "Bit Fields" I think is what he calls them.
04:49:07 <ksf> @remember uncyclopedia Calculations which are undefined are denoted by the _|_ symbol, pronounced Bottom, which the documentation explains as the compiler giving you the finger.
04:49:07 <lambdabot> It is forever etched in my memory.
04:50:27 <Sagi> osaunders: ah thanks
04:55:33 <Sagi> hmm
04:55:42 <Sagi> that's not as useful as I hoped.
04:56:22 <Sagi> I think I'll just hack it in now and return to it later when I'm a more experienced haskell-programmer
04:58:07 <ksf> what's wrong with Data.Binary.Get?
04:58:36 <ksf> oh, bit banging
04:59:19 <ksf> I'd say tokenize the stuff and then feed it into some parsing lib
04:59:40 <ksf> that might not be the most space-efficient thing to do, but it shouldn't be slow.
05:00:48 <ksf> ...but all that probably won't be worth the bother if you're only dealing with a handfull of bit structures.
05:01:47 <osaunders> I asked this before but I got confusing answers. Would it be possible to have a number type that didn't include 0?
05:03:11 <Cale> osaunders: Well, any instance of Num will define fromInteger, which ought to be totally defined
05:03:18 <Cale> But sure
05:03:32 <osaunders> How would you do it?
05:04:05 <osaunders> Or another example: a type that only contained even numbers?
05:04:08 <Cale> data PosInteger = One | Succ PosInteger
05:04:21 <Cale> It's the same thing as Nat of course.
05:04:23 <osaunders> Oh nice.
05:04:31 <osaunders> Nat?
05:04:40 <Cale> data Nat = Zero | Succ Nat
05:05:06 <Cale> Structurally, there's no difference. How you implement addition will be a bit different.
05:05:21 <osaunders> I'd have to redefine all the functions.
05:05:24 <osaunders> Yeah.
05:06:16 <Twey> newtype PosInteger = PosInteger Nat
05:06:30 <Twey> And just add one on conversion
05:09:17 <Daerim> If I wanted to do something silly, like say, IO [IO [[a]]] -> IO [[[a]]], how might I approach this?
05:10:58 <Twey> Daerim: join . mapM
05:11:47 <Twey> :t undefined :: IO [IO [[a]]]
05:11:48 <lambdabot> forall a. IO [IO [[a]]]
05:11:53 <Twey> :t mapM (undefined :: IO [IO [[a]]])
05:11:54 <lambdabot>     Couldn't match expected type `a -> m b'
05:11:55 <lambdabot>            against inferred type `IO [IO [[a1]]]'
05:11:55 <lambdabot>     In the first argument of `mapM', namely
05:12:01 <Twey> Oh, right, yeah
05:12:13 <Twey> :t (undefined :: IO [IO [[a]]]) >>= mapM
05:12:14 <lambdabot>     Couldn't match expected type `[IO [[a]]]'
05:12:14 <lambdabot>            against inferred type `a1 -> m b'
05:12:14 <lambdabot>     In the second argument of `(>>=)', namely `mapM'
05:12:19 <Twey> o.x
05:13:00 <quicksilver> Daerim: sequence will go from [IO b] to IO [b]
05:13:21 <quicksilver> Daerim: therefore "fmap sequence" will go from IO [IO b] to IO (IO [b])
05:13:34 <quicksilver> Daerim: and then "join" from IO (IO [b]) to IO [b]
05:13:46 <quicksilver> Daerim: throughout, b == [[a]], it was less confusion to read ;)
05:14:02 <quicksilver> :t join . fmap sequence
05:14:03 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m [m a] -> m [a]
05:14:31 <quicksilver> :t (join . fmap sequence) :: IO [IO [[a]]] -> IO [[[a]]]
05:14:32 <lambdabot> forall a. IO [IO [[a]]] -> IO [[[a]]]
05:14:33 <Daerim> quicksilver, heh I see what you mean. I've got the feeling that I might have made things more difficult than they ought to be
05:14:49 <quicksilver> you probably shouldn' have got into this mess in the first place, no :)
05:15:04 <quicksilver> nesting IO inside IO like that isn't often what you want
05:15:21 <quicksilver> (occasionally it is though : that's what you do when you want an IO action to return an IO action which you might call later)
05:15:43 <osaunders> One of the things I really like about Haskell is that you can often avoid this kind of convoluted thing.
05:15:46 <Twey> Oh, sequence, that's what I wanted
05:16:16 <quicksilver> in a sense, do notation is all about avoiding this kind of thing
05:16:22 <osaunders> Large applications in Haskell remain comprehensible and tractable.
05:16:23 <quicksilver> it kind of automatically unwraps as you go
05:16:32 <quicksilver> so you don't need to explicitly do all the various unwrappings
05:16:33 <Twey> Also >>=
05:17:15 <quicksilver> yes, join . fmap is >>= but I felt it easier to explain this way :)
05:17:37 <Daerim> quicksilver, well I want to call a batch of external processes, wait for them to finish in their own thread, and then add another batch
05:18:19 <Daerim> was gonna give you an example, but hpaste is down?
05:18:33 <osaunders> Daerim: codepad
05:21:51 <Daerim> http://codepad.org/dznGSSJC I hope this gives an idea of what I mean
05:22:12 * hackagebot upload: iteratee-parsec 0.0.1 - Package allowing parsec parser initeratee (MaciejPiechotka)
05:25:42 <quicksilver> Daerim: just get rid of the 'return' at the begining of line 6
05:25:44 <bastl> Is there an easy way to create a multiline string is haskell? I want to avoid putting many "\n" into the string (which is a text-file itself).
05:25:52 <bastl> is=in
05:25:54 <quicksilver> then your type will be IO [[[a]]] instead of  IO[IO [[a]]] anyway
05:26:19 <Zao> bastl: unlines ["foo", "bar", "baz"]
05:26:43 <Zao> bastl: http://www.haskell.org/haskellwiki/Poor_man%27s_here_document
05:27:05 <quicksilver> Daerim: (and you then won't need the join fmap sequence bit)
05:27:42 <bastl> No, I have a text-file which i want to use as a string constant without IO.
05:27:55 <bastl> here documents look good but seem to involve IO ?
05:28:00 <Twey> TH?
05:28:14 <Twey> http://www.math.columbia.edu/~bayer/Haskell/Annote/HereDocs.html
05:28:27 <Daerim> quicksilver, ahh. Should have seen that one. I end up in a monadic mess too often these days. Thanks for untangling it for me :)
05:28:40 <Twey> Personally, though, I prefer to create a list of strings and interpolate them with '\n'
05:28:50 <quicksilver> Daerim: It's ok. return is for returning simple values (as opposed to actions)
05:28:57 <Zao> unsafePerformAAAAAAARGH.
05:29:19 <quicksilver> I'm with Twey. I think it looks nicer with unlines or concat or intercalate
05:29:31 <quicksilver> apart from anything else, my syntax highlighter gets it right, then.
05:29:36 <Twey> Yeah, heh
05:29:37 <quicksilver> (ok that's a dumb reason, but still)
05:29:42 <bastl> Twey: that looks good. (does the job for a tiny example)
05:29:45 <Daerim> quicksilver, will it work thought? will the new threads wait for the old ones to finish, or do I have to make sure they reuse the same mvars?
05:29:45 <quicksilver> and it doesn't mess with the indentation.
05:29:51 <Zao> If you have files, you have files. There's not much you can do about that.
05:30:02 <quicksilver> Daerim: your final 'forM' is waiting for them all to finish.
05:30:15 <quicksilver> before the next iteration of the outer loop
05:31:12 <Daerim> quicksilver, perfect :) Was running out of memory running all of them at once. Thanks again
05:31:44 <zygoloid> , let str = QuasiQuoter stringE undefined in [$str| this is a string constant! |]
05:32:11 <osaunders> Has anyone used Hint before?
05:32:29 <bastl> yes
05:33:18 <osaunders> Do you know how you get it to import the Prelude and stuff?
05:37:31 <fasta> osaunders, isn't the Prelude implicitly imported?
05:37:45 <fasta> osaunders, I used Hint 6 years ago.
05:37:56 <fasta> osaunders, so, things might have changed ;)
05:38:11 <osaunders> runInterpreter (eval "head [True,False]") gives me:
05:38:16 <osaunders> Left (WontCompile [GhcError {errMsg = "Not in scope: `head'"},GhcError {errMsg = "Not in scope: data constructor `True'"},GhcError {errMsg = "Not in scope: data constructor `False'"}])
05:39:31 <bastl> osaunders: I used to to dynamically load user suplied modules at startup. I think Prelude was there with loaded modules ...
05:40:20 <osaunders> The main problem is that I don't understand monads and everything in Hint is written with this InterpreterMonad.
05:40:40 <fasta> osaunders, uhm, using Hint and modifying the Hint interpreter are two different things.
05:41:06 <osaunders> I'm not modifying it.
05:41:45 <osaunders> But the functions that createâ€”or set or whateverâ€”the interpreter options seem to have lots of monads in their type sigs too
05:43:04 <Sogekingu> hi I am trying to create a "test" module in my program
05:43:38 <Sogekingu> test -> [String] -> [Token]
05:43:41 <Sogekingu> doesnt seem to work
05:44:00 <Sogekingu> i mean, test :: [String] -> [Token]
05:44:26 <Sogekingu> in the test module I am calling 2 functions
05:44:36 <Sogekingu> 1 outputing [Token]
05:45:17 <Sogekingu> and then calling itself on the remainder of the list
05:45:29 <Sogekingu> ... Im not making any sense am I :s
05:46:37 <osaunders> Sogekingu: Not really, you seem to be talking about a bunch of separate things.
05:47:09 <bastl> osaunders: here how we used it: http://preview.tinyurl.com/y8omyuf
05:47:26 <bastl> never had problems with missing prelude functions
05:48:20 <osaunders> bastl: OK, thanks, let me look into it further.
05:48:32 <Sogekingu> hmm ok I have a function scanner :: [Char] -> [Token] and now I want a function to be able to take a list of strings and call the scanner function for each of its string members, how would I do that? doTests :: [String] -> [Token] doesnt seem to be right/
05:48:47 <nadder> Does anyone know how you install the readline package, I tried installing gnu readline, but configure still complains about missing gun readline framework ?
05:49:14 <medfly> [String] isn't [Char]
05:49:18 <medfly> it's [[Char]]..
05:49:21 <osaunders> Sogekingu: map.
05:49:36 <Sagi> nadder: did you install the -dev package?
05:49:40 <osaunders> Sogekingu: map someFn [list, of, things, for, fn, to, act, on]
05:49:41 <medfly> @type map
05:49:42 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:50:00 <nadder> Sagi, not sure, I installed the one that came up on gnu page, 6.1
05:50:06 <medfly> you want doTests :: [String] -> [[Token]], I think.
05:50:08 <osaunders> Sogekingu: Also as medfly says, String == [Char]
05:50:10 <nadder> Sagi, any way I can check it?
05:50:16 <Sagi> nadder: what is your os/distro?
05:50:33 <Sogekingu> ok ill play around with what you guys said, thanks
05:50:34 <nadder> Sagi, Linuxmint, ubuntu clone (I think).
05:50:50 <Sagi> so it has aptitude, right? Then try aptitude search readline
05:50:51 <osaunders> nadder: I had to specify the path directly.
05:51:00 <Sagi> I think it's called libreadline-dev or something like that
05:51:19 <osaunders> nadder: I filed a ticket for the problem let me find it.
05:51:32 <Sagi> apt-cache search readline works too
05:52:24 * nadder is trying aptitude search ...
05:52:43 <osaunders> nadder: http://hackage.haskell.org/trac/hackage/ticket/631?format=tab
05:55:23 <bastl> zygoloid: I try your TH-Expression from above. How would that work in ghcI? let str = QuasiQuoter stringE undefined in [$str| this is a string constant! |]
05:55:28 <nadder> Sagi, http://codepad.org/rkuKSYwO
05:55:48 <bastl> Can I use TH-code in GHCI ?
05:56:49 <Sagi> I'd try  libreadline-dev first, check if it works, if it doesn't try the version 5, and do the same with version 6
05:57:05 <Sogekingu> is there a tutorial anyone knows of to understand map functions?
05:57:20 <Esteban25> hey
05:57:33 <Esteban25> is anyone alive here??
05:57:51 <Esteban25> :(
05:58:16 <nadder> Sagi, I'm a bit slow, what do you mean by *try* libreadline-dev ? Doesn't this mean it's already installed?
05:58:23 <Esteban25> [lambdabot]
05:58:31 <osaunders> Sogekingu: http://learnyouahaskell.com/higher-order-functions
05:58:44 <Sagi> no, these are just the packages matching your search string
05:58:48 <Sagi> i means installed
05:58:56 <osaunders> Esteban25: Plenty of people.
05:59:14 <nadder> Ah, thanks, I'm with you now.
05:59:48 <Esteban25> cool osaunders
05:59:55 <Sagi> see also man aptitude, the other characters are explained there aswell
05:59:59 <Sogekingu> ahh really awesome link osaunders, thats the website that actually made sense to me when I first found haskell. Been looking for it for ages. :D
06:00:07 <Esteban25> i was wondering if someone would give me a hand on this haskell excersise :/
06:00:26 <osaunders> Esteban25: People don't tend to say hi so much because we like to get straight to the meat of the conversation. Mmmm, meaty.
06:00:35 <Esteban25> ahh oka
06:00:52 <osaunders> What exercise?
06:01:15 <Esteban25> i'll copy part of it in hpaste
06:01:26 <Esteban25> aw not workig hpaste?
06:01:59 <quicksilver> no, try codepad.org
06:02:08 <Esteban25> ok
06:02:08 <osaunders> Sogekingu: LYAH is great but don't fall into the trap of reading it for long periods of time without trying the stuff out yourself, you don't learn much by reading alone (at least that's what I've found).
06:03:00 <nadder> Sagi, that seemed to work, thank's alot, it's not easy being a linux noob.
06:03:25 <Sogekingu> osaunders yeah, I gotta do this coureswork which is in haskell so it should help lots :D
06:05:14 <Sagi> nadder: haha, you're welcome :)
06:06:48 <Esteban25> http://codepad.org/qlR3O9ii
06:07:15 <ksf> gnaaaargh. I can specify constraint in my cabal config and it works fine, as long as packages I want to install depend on those packages.
06:08:11 <bastl> ghci tries to load two versions of bytestring and crashes afterwards, how can i avoid that?
06:08:48 <joe1> this line ensures that if a line starts with a ';', then it is ignored:  processline line@(';':xs) datastack = return datastack
06:09:06 <joe1> i am wondering how I can identify lines with a prefix of space.
06:09:15 <osaunders> Esteban25: The parenthesis you have around "f3 f xs" isn't creating a tuple.
06:09:16 <joe1> such as '   ;xxx'
06:09:36 <joe1> instead of when the line is ';xxx'
06:09:46 <Esteban25> [osaunders] i knoiw, i just dont know how to return the number of elements that verify the function
06:09:55 <Esteban25> that function returns only a list
06:10:01 <bastl> :q
06:10:03 <bastl> oops
06:10:17 <quicksilver> joe1: isComment l = take 1 (dropWhile isSpace l) == ';'
06:10:22 <osaunders> Esteban25: You another function to wrap the return of f3.
06:10:25 <osaunders> *Use another.
06:10:33 <quicksilver> joe1: then, processline line datastack | isComment line = return datastack
06:10:44 <quicksilver> joe1: see what I did there?
06:10:47 * osaunders shouldn't use the word return, I think.
06:11:04 <joe1> quicksilver: i am trying to understand. please give me a minute
06:11:29 <Esteban25> [osaunders] you mean i should create another function?
06:11:40 <joe1> quicksilver: thanks, i understand now.
06:11:46 <Esteban25> [osaunders] i think im not allowed to create auxiliar functions :/
06:11:56 <osaunders> Esteban25: As an easy first-step, yes. After you've done that there's a way to make it a bit cleaner.
06:12:17 <osaunders> Esteban25: Hint: Use a where clause.
06:12:38 <quicksilver> joe1: I could have fitted it all into one line but I thought it was easier to read to introduce a helper function called 'isComment'
06:13:09 <IceDane> I'm trying to parse an html tag from a website using Parsec. I figured I could do "many anyChar >> string "<title>""(roughly) but then figured out that many anyChar is greedy and will parse everything. I then tried "many (noneOf "<") >> string "title"", but that doesn't work because < can appear several times before the title, obviously. How can I do this?
06:13:45 <osaunders> bastl: You could hideâ€”or is it unregister?â€”one of the packages with ghc-pkg
06:14:14 <quicksilver> IceDane: you can't do anything that naive
06:14:43 <bastl> IceDace: google for Tagsoup and parsec. You can get a list of tags as a token list.
06:14:46 <quicksilver> IceDane: recommend considering an HTML parsing library
06:14:49 <quicksilver> like Tagsoup
06:14:53 <quicksilver> or haxml or hxt
06:15:23 <Saizan> manyTill anyChar (try $ string "title") ? -- i never remember how manyTill works wrt backtracking
06:15:23 <Twey> Esteban25: f3 = fmap (length &&& id) . filter
06:15:51 <bastl> http://hackage.haskell.org/package/tagsoup-parsec
06:15:51 <Twey> > fmap (length &&& id) . filter $ even [1, 2, 3]
06:15:52 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
06:15:52 <lambdabot>         against inferred ...
06:15:55 <Twey> Damn
06:15:57 <Twey> Oh
06:16:03 <Twey> > (fmap (length &&& id) . filter) even [1, 2, 3]
06:16:04 <lambdabot>   (1,[2])
06:16:16 <Twey> There we go
06:19:31 <joe1> :info isSpace
06:19:39 <IceDane> Saizan: thanks - I needed manyTill
06:19:43 <joe1> @hoogle isSpace
06:19:43 <lambdabot> Data.Char isSpace :: Char -> Bool
06:19:43 <lambdabot> Data.ByteString.Internal isSpaceChar8 :: Char -> Bool
06:19:43 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
06:22:31 <trzkril> @type fmap (length &&& id)
06:22:32 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f (Int, [a])
06:23:22 <Esteban25> thanks twanvl
06:23:24 <Esteban25> Twey*
06:23:46 <twanvl> thanks Esteban25 :)
06:23:46 <lambdabot> twanvl: You have 2 new messages. '/msg lambdabot @messages' to read them.
06:24:02 <trzkril> @type fmap (length &&& id) . filter
06:24:03 <lambdabot> forall a. (a -> Bool) -> [a] -> (Int, [a])
06:27:50 <Sogekingu> using the readFile to read files into a variable
06:28:01 <Sogekingu> but is it possible to read multiple "strings" from 1 file?
06:28:13 <Sogekingu> at the moment 1 readFile reads all of it as 1 string.
06:28:55 <Saizan> you can chop it up with functions from Data.List
06:28:56 <IceDane> Sogekingu: lines on the string
06:29:12 <Saizan> > lines "foo\nbar\nbaz"
06:29:13 <lambdabot>   ["foo","bar","baz"]
06:29:54 <Sogekingu> ok ill look into lines, cheers
06:33:38 <IceDane> I asked this question before, but I wound up solving another problem. I did however try to implement this solution, but it didn't really work out as I intended. I'm trying to parse a part of a string, and if the parsing fails, I want to return nothing. If it succeeds I want to return Maybe "parsed" value. I know I can just do fmap Just on it if it succeeds, but I'm not entirely sure what I can do to 'lift' Nothing into the GenParser monad on fa
06:33:44 <IceDane> Can try do this?
06:35:26 <Saizan> fmap Just (try p) <|> return Nothing
06:36:04 <Saizan> there's probably an "optional a p = p <|> return a"
06:36:22 <Sogekingu> @type test = [[Char]]
06:36:23 <lambdabot> parse error on input `='
06:36:34 <Sogekingu> @type test [[Char]]
06:36:35 <lambdabot> Not in scope: `test'
06:36:35 <lambdabot> Not in scope: data constructor `Char'
06:36:40 <IceDane> oh, of course, thanks.
06:36:49 <IceDane> (I was missing the return nothing)
06:36:54 <IceDane> eh, the return
06:37:04 <Sogekingu> how can I declare a variable of type [[Char]]?
06:37:21 <Twey> Sogekingu: foo = ["foo"]
06:37:29 <Twey> :t ["foo"]
06:37:30 <lambdabot> [[Char]]
06:38:13 <Sogekingu> I want to create a variable of type [[Char]] to use in a function though
06:38:13 <Saizan> you can write "test :: [[Char]]; test = ...;" in a file, where you replace ... with an expression
06:38:22 <Zao> :t [['x'],[]]
06:38:23 <lambdabot> [[Char]]
06:38:24 <Sogekingu> oh ok cheers
06:38:45 <Saizan> though it's not a variable as in imperative languages
06:38:53 <Saizan> it's more like a definition
06:39:06 <Saizan> and you've to put it in a where or a let .. in
06:39:48 <Saizan> in fact, we usually omit the type declaration
06:40:14 <IceDane> Saizan: You omit type declarations for most functions?
06:40:17 <IceDane> Is that common practice?
06:40:25 <Zao> :t [[]] :: [[Char]]
06:40:26 <lambdabot> [[Char]]
06:40:38 <Zao> I tend to generate signatures for all my functions.
06:41:02 <Zao> As suitable warning levels nag about it, and it helps constrain type deduction retardedness.
06:41:17 <IceDane> Yeah
06:41:18 <Sogekingu> Ok why is it so that a readFile output is IO String, and cant be boung to a String?
06:41:32 <IceDane> Sogekingu: You'll have to look into monads to understand properly
06:41:40 <IceDane> It can be bound to a string, in fact
06:42:09 <appamatto> are there type systems where any term can be a type, and vice-versa?
06:42:10 <Zao> Sogekingu: A value of type (IO String) represents an IO action that gives you a String when sequenced.
06:42:48 <Sogekingu> Zao so how would I bind it to a string?
06:42:48 <Esteban25> [Twey] ive written the function again like this: f1 f xs = (length(filter (f) xs), filter (f) xs)
06:43:03 <Zao> @type [getLine, return "omg", getLine]
06:43:04 <lambdabot> [IO String]
06:43:06 <Esteban25> and works as expected
06:43:31 <Zao> Sogekingu: Either by <- in a do block or >>= to compose it into a larger IO action.
06:43:31 <copumpkin> preflex: seen edwardk
06:43:31 <preflex>  edwardk was last seen on ##logic 1 day, 14 hours, 47 minutes and 12 seconds ago, saying: who is _YKY_?
06:43:36 <Twey> Esteban25: f1 = fmap (length &&& id) . filter
06:43:44 <Zao> @type getLine >>= print
06:43:45 <lambdabot> IO ()
06:43:50 <Twey> Esteban25: Those brackets are unnecessary, and you're not sharing as much as you should be
06:44:03 <Zao> @type do { x <- getLine; print x }
06:44:04 <lambdabot> IO ()
06:44:13 <Twey> f1 p xs = let rs = filter p xs in (length rs, rs)
06:44:15 <Esteban25> ah oka Twey
06:44:17 <Zao> Sogekingu: Those two actions are semantically equivalent.
06:44:25 <Twey> Would be the ugly way of doing it
06:44:42 <Zao> As is   getLine >>= \x -> print x
06:44:54 <Twey> Or you can go for maximum efficiency (all the ones suggested so far have iterated the list twice) by using a single foldr
06:45:08 <Sogekingu> so would this be correct? tests :: [[Char]]     tests <- lines readFile "bla.txt"?
06:45:23 <Zao> Sogekingu: Not quite.
06:45:59 <Zao> <- only makes sense inside a do block, and such a do block has the type (m a)
06:46:12 <Beelsebob> Sogekingu: no, lines operates on a String, not an IO String
06:46:17 <Beelsebob> you need to use fmap to push lines inside the IO
06:46:18 <Twey> f1 p = foldr (\x (n, rs) -> if p x then (n + 1, x : rs) else (n, rs)) (0, [])
06:46:44 <Zao> tests :: IO [String]   tests = do { contents <- readFile "bla.txt"; return (lines contents) }
06:46:54 <Beelsebob> tests <- lines <$> readFile "blah.txt" <-- Sogekingu
06:47:19 <Sogekingu> Beelsebob what is the <$>?
06:47:25 <Beelsebob> it's a synonym for fmap
06:47:27 <Zao> getContents would probably help, but lazy IO is scary.
06:47:40 <Zao> Sogekingu: It's like a $, but more awesome.
06:47:43 <Beelsebob> it maps lines over the contents of the IO data constructor in this case
06:47:49 <benmachine> readFile is lazy too
06:48:33 <Zao> Why did I think that getContents was FilePath -> String.
06:48:35 <Zao> That would be scary.
06:48:47 <Beelsebob> o.O
06:48:50 <Beelsebob> that *would* be scary
06:48:55 <Beelsebob> and nothing to do with lazy IO
06:49:03 <Beelsebob> just broken, non referentially transparent IO
06:49:09 <Zao> nomnomnom :: FilePath -> String
06:49:43 * hackagebot upload: HsSVN 0.4.3 - (Part of) Subversion binding for Haskell (MasatakeDaimon)
06:50:38 <joe1> > let line = "  .some_byte_label: .Byte 1"; digitToInt $ head $ (words line) !! 2
06:50:39 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
06:50:44 <joe1>  let line = "  .some_byte_label: .Byte 1"; digitToInt $ head $ (words line) !! 2
06:50:47 <joe1> : let line = "  .some_byte_label: .Byte 1"; digitToInt $ head $ (words line) !! 2
06:50:58 <joe1> : let line = "  .some_byte_label: .Byte 1"
06:50:59 <Zao> let omg in wtf
06:51:05 <Zao> With > before
06:51:09 <joe1> > digitToInt $ head $ (words line) !! 2
06:51:10 <lambdabot>   Not in scope: `line'
06:51:29 <Zao> joe1: Do note that lambdabot serves private requests too.
06:51:38 <joe1> > digitToInt $ head $ (words "   .somebytelabel: .BYTE 1) !! 2
06:51:39 <lambdabot>   <no location info>:
06:51:39 <lambdabot>      lexical error in string/character literal at end o...
06:51:44 <joe1> > digitToInt $ head $ (words "   .somebytelabel: .BYTE 1") !! 2
06:51:45 <lambdabot>   1
06:51:59 <benmachine> joe1: in an expression, the syntax for let is
06:52:02 <benmachine> > let x = 4 in x
06:52:04 <lambdabot>   4
06:52:09 <Beelsebob> > let line = " .some_byte_label: .Byte 1" in digitToInt . head . words . (!! 2) $ line
06:52:09 <benmachine> "in" not ;
06:52:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
06:52:10 <lambdabot>         against inferred type...
06:52:16 <joe1> wondering if I can change the above code to read 10 or 20 instead of 1
06:52:27 <Beelsebob> > let line = " .some_byte_label: .Byte 1" in digitToInt . head . (!! 2) . words $ line
06:52:28 <lambdabot>   1
06:52:31 <joe1> benmachine: thanks.
06:52:47 <joe1> beelsebob: very cool. I like the new structure..
06:52:49 <galdor> hpaste.org seems to have trouble
06:53:29 <joe1> > let line = " .some_byte_label: .Byte 99" in digitToInt . head . (!! 2) . words $ line
06:53:30 <lambdabot>   9
06:53:35 <benmachine> > let in let in let in let in let in let in let in 4
06:53:36 <lambdabot>   4
06:53:41 <joe1> how can I get 99 instead of 9 above?
06:53:59 <benmachine> replace digitToInt . head with read
06:54:15 <joe1> tried it, could not get it to work..
06:54:24 <joe1> read needs ::Int.
06:54:30 <joe1> and I was not sure how to add it in.
06:54:31 <Zao> > read "99" :: Int
06:54:32 <lambdabot>   99
06:54:41 <benmachine> well, either you need to force the type of the whole expression
06:54:46 <benmachine> which will force the type of read
06:54:49 <benmachine> or you can do
06:54:52 <joe1> zao: yes, but as part of the whole expression.
06:55:03 <Zao> joe1: I typed that before your question.
06:55:12 <doserj> > (read :: String -> Int) "99"
06:55:13 <benmachine> > let readInteger :: String -> Integer; readInteger = read in readInteger "4"
06:55:13 <lambdabot>   99
06:55:14 <lambdabot>   4
06:55:26 <benmachine> yeah that works too
06:55:55 <joe1> > let line = " .some_byte_label: .Byte 99" in ((read :: String -> Int) . (!! 2) . words $ line)
06:55:56 <lambdabot>   99
06:56:06 <joe1> doserj: thanks. that's cool.
06:56:20 <Sogekingu> this hurting my head.
06:57:27 <Beelsebob> > let readByteLabel :: String -> Int; readByteLabel = read . (!!2) . words; line = " .some_byte_label: .Byte 99" in readByteLabel line
06:57:29 <lambdabot>   99
06:57:30 <Sogekingu> I just want to create a module which does the testing for me by reading in the textfile tests
06:58:16 <Jafet> > 99
06:58:17 <lambdabot>   99
07:00:42 <Sogekingu> I tried to use <$> but it gives errors
07:01:11 <Beelsebob> Sogekingu: post code
07:01:15 <Beelsebob> and errors
07:06:28 <Sogekingu> Beelsebob http://pastebin.com/d6d867570
07:06:45 <Sogekingu> theres more code, but I dont think it matters as its unrelated
07:07:09 <Beelsebob> Sogekingu: you can't use <- to bind something outside a do block
07:07:32 <Sogekingu> what significance does a do block have?
07:08:10 <Zao> Sogekingu: It's a block where some syntactic sugar is allowed.
07:08:18 <Zao> Like <- and the use of newlines to delimit statements.
07:08:38 <Jafet> Like monads, it is a tutorial catalyst
07:08:42 <Sogekingu> whats term should I be using to read up about it?
07:08:49 <Sogekingu> like to google
07:08:50 <Zao> do { foo; x <- bar; baz x } is equivalent to (foo >> bar >>= \x -> baz x)
07:09:03 <Zao> Which is equivalent to foo >> bar >>= baz  if you want to be neat
07:09:22 <Zao> @type (>>=)
07:09:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:09:23 <Zao> @type (>>)
07:09:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
07:09:38 <benmachine> see @undo
07:09:45 <Beelsebob> Sogekingu: http://pastebin.com/m4ab4ea37
07:09:50 <benmachine> @undo do { foo; x <- bar; bax z }
07:09:50 <lambdabot> foo >> bar >>= \ x -> bax z
07:10:35 <benmachine> the parentheses around (checkTokens . doTest scanner) aren't strictly necessary there
07:10:40 <Beelsebob> indeed
07:11:09 <Beelsebob> Sogekingu: also note, the second clause in doTest is superfluous
07:11:15 <Beelsebob> it does the exact same thing as the third clause
07:11:52 <Beelsebob> so better yet... http://pastebin.com/m5ef9f36b
07:11:55 <Sogekingu> what exactly have you done?
07:12:13 <Beelsebob> okay, first things first...
07:12:18 <Beelsebob> I've defined a type synonym for Scanner
07:12:23 <Beelsebob> so your type signatures look nicer
07:12:47 <Sogekingu> i see
07:12:51 <Beelsebob> secondly, when you read a file, you get a side effecting value, so you need the IO monad
07:13:01 <Beelsebob> so testFile, being the contents of the file, needs to go into the IO monad
07:13:41 <Esteban25> mm prolog people isn't That friendly
07:13:44 <Beelsebob> thirdly, I've added a runTests function which runs your scanner over your test file, evaluates some unknown checkTokens function which should take token lists and give you a test output
07:13:56 <Beelsebob> and it then prints the output of that checkToken function
07:14:29 <Beelsebob> you can also condense this a little more like this... http://pastebin.com/m79d0a249
07:14:35 <Beelsebob> which presonally I find a bit nicer
07:15:08 <zygoloid> bastl: http://codepad.org/92gpTgJ0 <-- yes, you can use it from ghci, but not for multiline strings sadly
07:15:15 <Sogekingu> why is it that testFile = lines <$> readFile "blah" worked for you?
07:15:22 <Sogekingu> I tried that first but it didnt work for me.
07:15:28 <Beelsebob> because (1) I used =, not <-
07:15:40 <Sogekingu> yeah first i had used an = too.
07:15:48 <Beelsebob> (2) I made testFile :: IO [String] not testFile :: [String]
07:15:54 <Sogekingu> oh yeah my bad.
07:16:44 <zygoloid> If someone with the ability to edit the wiki wants to add this technique [http://codepad.org/92gpTgJ0] to here [http://www.haskell.org/haskellwiki/Poor_man%27s_here_document], that would be great :)
07:17:12 <benmachine> doTest = map?
07:17:33 <Sogekingu> I understand the code
07:17:35 <Beelsebob> oh, good point benmachine
07:17:52 <Sogekingu> exept the last part "runTests = print =<< checkTokens . doTest scanner <$> testFile"
07:18:03 <Sogekingu> except*
07:18:13 <Beelsebob> http://pastebin.com/m568f0658 <-- with benmachine's suggestion
07:18:18 <Beelsebob> Sogekingu: okay so...
07:18:21 <Sogekingu> is checkTokens a function?
07:18:28 <Beelsebob> it is, it's one you're yet to write
07:18:42 <Sogekingu> oh ok
07:18:42 <Beelsebob> it has type [[Token]] -> String
07:18:43 <fasta> zygoloid, (your URLs are not clickable in my IRC client)
07:19:04 <Sogekingu> what about the "."?
07:19:08 <joe1> @hoogle showHex
07:19:08 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
07:19:16 <Beelsebob> . is function composition
07:19:19 <Sogekingu> mapping to function doTest?
07:19:20 <Beelsebob> you can roughly read it as "after"
07:19:28 <benmachine> zygoloid: it's not hard to get a wiki account, you know
07:19:30 <Sogekingu> ok that makes sense
07:19:37 <zygoloid> fasta: (i am truley sorry for your lots)
07:19:41 <benmachine> zygoloid: and it makes you at least 30% cooler
07:20:02 <zygoloid> benmachine: i have one, and i have 0% knowledge of the password ;)
07:20:02 <Beelsebob> Sogekingu: this is a slightly different program, but probably what you're after...
07:20:03 <Beelsebob> http://pastebin.com/m4117c329
07:20:06 <benmachine> ah
07:20:12 <benmachine> can't you get it emailed to you?
07:20:16 <fasta> zygoloid, no need to respond like that.
07:20:17 <zygoloid> i'm also not 100% sure of the username ;-)
07:20:20 <benmachine> hah
07:20:40 <Beelsebob> this one even Sogekingu http://pastebin.com/m79eb35f -- we don't want to show the list, we want it to just come out nicely printed
07:21:23 <benmachine> does QuasiQuotes imply TemplateHaskell?
07:21:35 <yaru1022> Hi, I tried to install hslogger using cabal install, but I got the following error:
07:21:44 <yaru1022> src/System/Log/Logger.hs:465:19: Not in scope: type constructor or class `Control.Exception.SomeException'
07:21:44 <yaru1022>  
07:21:51 <yaru1022> Does anyone know what the problem is..?
07:22:06 <fasta> yaru1022, let me guess: you use 6.10.4?
07:22:22 <Saizan> yaru1022: cabal install hslogger --preference="base >= 4"
07:22:22 <zygoloid> benmachine: no.
07:22:23 <yaru1022> fasta, yes
07:22:34 <Beelsebob> which gets closer to a nice function... http://pastebin.com/m4d77406c <-- probably the best you'll get Sogekingu
07:22:36 <benmachine> zygoloid: so, you don't need TemplateHaskell for that to work?
07:22:50 * ksf wonders how to parse _any_ token with uu-parsinglib
07:22:58 <fasta> yaru1022, some stuff changed when compared to 6.10.2. Probably Saizan's suggestion works then.
07:23:07 <ksf> ...which is distinct from "match any of those I give you"
07:23:15 <zygoloid> benmachine: no. you only need TemplateHaskell for the $( ... ) and [| ... |]-style jobbers (with no $) iiuc
07:23:28 <benmachine> okay cool
07:23:31 <Sogekingu> the idea isnt for me to parse anything yet
07:23:41 <Beelsebob> oops, helps if you read the file, not try to read the string >.> http://pastebin.com/m7a13cbfc
07:23:45 <Sogekingu> its just to scan, im testing to see if the scanner works
07:23:49 <Beelsebob> Sogekingu: right
07:23:51 <yaru1022> fasta, Saizan: awesome! Saizan's suggestion worked.
07:23:51 <Saizan> yaru1022: you should probably upgrade your cabal-install too: cabal install "cabal-install >= 0.8.0" if you haven't
07:24:03 <Beelsebob> Sogekingu: so checkResult here should check the scanner's output
07:24:11 <Beelsebob> and give some output about that line's checking
07:24:33 <joe1> @hoogle openFile
07:24:33 <lambdabot> System.IO openFile :: FilePath -> IOMode -> IO Handle
07:26:11 <yaru1022> Saizan: I'm just curious.. is there a way to upgrade ghc using cabal, too?
07:26:24 <joe1> @hoogle hIsEof
07:26:24 <lambdabot> System.IO hIsEOF :: Handle -> IO Bool
07:26:36 <Saizan> yaru1022: no
07:27:35 <joe1> @hoogle IOMode
07:27:35 <lambdabot> System.IO data IOMode
07:28:37 <benmachine> zygoloid: I don't really know enough about QQ to comment on the code, so can I just drop it in a new section alone? do you want your name on it?
07:30:02 <zygoloid> benmachine: i don't care about attribution. yeah, just putting it in a new section sounds fine to me.
07:31:27 <benmachine> hey, would return . stringL . LitP work for the second argument?
07:31:30 * benmachine playing around in ghci
07:31:44 <Sogekingu> I still get the error that <$> is not in scope.
07:31:50 <Sogekingu> even with the code you guys wrote
07:31:55 <benmachine> Sogekingu: GHC 6.10?
07:32:22 <benmachine> or 6.12?
07:32:25 <benmachine> err
07:32:31 <benmachine> import Control.Applicative ((<$>))
07:32:33 <benmachine> that'll work
07:32:47 <Sogekingu> ooh ok
07:32:58 <Sogekingu> i think that may have been the bane of me not able to figure this out
07:34:14 <Sogekingu> btw benmachine where would I put that line?
07:34:20 <benmachine> the import line?
07:34:21 <Sogekingu> putting it at the top of my code didnt work.
07:34:22 <Sogekingu> yeah
07:34:28 <benmachine> at the top should work
07:34:32 <benmachine> what does it say?
07:34:58 <Sogekingu> TXL-Unix.hs:11:0: parse error on input `module
07:35:06 <benmachine> oh
07:35:07 <Saizan> after module ... where
07:35:10 <benmachine> module has to be at the top
07:35:15 <benmachine> import is next after that
07:35:44 <Sogekingu> ok cheers
07:36:25 <benmachine> zygoloid: http://www.haskell.org/haskellwiki/Poor_man%27s_here_document edited
07:36:26 <Fare> hi!
07:36:26 <lambdabot> Fare: You have 1 new message. '/msg lambdabot @messages' to read it.
07:36:40 <benmachine> (I made a slight change to the definition of str, but I tested it first)
07:38:02 <Fare> Hi, what is good documentation on how Haskell *implements* type classes?
07:38:17 <benmachine> zygoloid: is there any way to include |] in the string? just out of curiousity
07:38:20 <freiksenet> Hello! I am trying to use Data.Tree in GHCi. I have them loaded in my module with import qualified as T, but when I try to do anything with T.Tree in GHCI I get his error:
07:38:21 <freiksenet>     Failed to load interface for `T':
07:38:21 <benmachine> curiosity, perhaps
07:39:21 <benmachine> Fare: probably different compilers do it in different ways
07:40:04 <Botje> freiksenet: sounds like you'll have to reinstall Data.Tree
07:40:05 <benmachine> Fare: I don't know the answer to your question, but you're better off asking "how does GHC implement..." or "how does Hugs implement..."
07:40:18 <benmachine> Botje: does it?
07:40:31 <benmachine> freiksenet: have you compiled the module you're loading?
07:40:44 <freiksenet> Botje: isn't it in standard library?
07:40:50 <freiksenet> benmachine: no
07:40:53 <benmachine> hmm
07:41:01 <benmachine> do you load more than one module?
07:41:07 <benmachine> er
07:41:10 <Botje> freiksenet: can you put the full error on hpaste or something?
07:41:13 <benmachine> just tell me what the ghci prompt looks like
07:41:24 <benmachine> that is, if it isn't just ghci> like mine :P
07:42:10 <Fare> I'm doing something which I believe is an implementation of typeclasses in Common Lisp, with the downside that there is no type inference to help you, and the upside that you can do things the Haskell type inferencer can't do.
07:42:18 <freiksenet> Botje: just a moment
07:42:30 <freiksenet> *Main>
07:42:40 <freiksenet> https://gist.github.com/a64cd7c92e3ba778827b
07:42:49 <freiksenet> and -v doesn't work :)
07:42:57 <benmachine> doesn't work?
07:43:16 <Fare> (like a same datastructure being instance of a same class in many different ways)
07:43:34 <kuribas> Fare: Then you would get something like CLOS?
07:43:58 <domor> I'm trying to port an OpenGL demo to the latest version, but I get "No instance for (MatrixComponent Float) arising from use of rotate" etc. any ideas?
07:44:04 <freiksenet> benmachine: unknown command?
07:44:48 <benmachine> freiksenet: start ghci with the -v option on the command line
07:44:50 <benmachine> is what that means
07:45:01 <freiksenet> benmachine: ah, ok
07:45:34 <zygoloid> benmachine: QuasiQuoter stringE (litP . stringL) works. and AFAIK there's no way to include |] in the string.
07:45:34 <Fare> kuribas, no.
07:45:47 <Botje> freiksenet: weird.
07:45:52 <freiksenet> benmachine: this is really weird
07:45:57 <Fare> kuribas, I'm using CLOS to implement easily a rich semantics for my "interface classes"
07:46:09 <zygoloid> (i assume litP = return . LitP)
07:46:25 <freiksenet> https://gist.github.com/36ebe41eb19b10bafe05
07:46:39 <Fare> I *could* implement a whole object system on top of that, but the point is rather to provide parametric polymorphism and such to Lisp.
07:48:02 <Fare> so with "interface classes" that I pass as an *explicit* argument (as opposed to implicit argument in Haskell type classes), I can have generic programs that are parametrized by such interfaces.
07:48:31 <Fare> I just wrote a few generic functional data structures like that, it's beautiful
07:48:43 <Fare> I want to write an article on that, and credit Haskell type classes.
07:49:00 <Fare> and so I'm looking for academic papers to cite on Haskell type classes
07:49:21 <gal_bolle> hi all
07:49:27 <Fare> which themselves could have interesting stuff in their bibliography
07:50:06 <freiksenet> could it be that Data.Tree is not included into GHC?
07:50:32 <gal_bolle> is there a tool (emacs mode or otherwise) for exploiting .prof files? in particular, collapse a subtree of the call tree, go to the biggest son of a nodeâ€¦
07:50:38 <benmachine> Data.Tree is in the containers package
07:50:41 <benmachine> which comes with ghc I think
07:50:57 <CosmicRay> is it possible to get unixodbc installed on the hackage server so that the docs for HDBC-odbc will build?  I imagine that the -dev packages for sqlite3 and postgreql are installed, allowing HDBC-{sqlite3,postgresql} to build?
07:51:00 <CosmicRay> who do I talk to about that?
07:51:30 <benmachine> freiksenet: in your paste it looks like ghci is looking in the wrong place
07:51:45 <CosmicRay> strangely HDBC-odbc 2.1.0.0 built succesfully
07:51:52 <benmachine> so that would not suggest anything necessarily wrong with Data.Tree; possibly a bug in ghci
07:51:59 <benmachine> try importing it unqualified
07:52:29 <freiksenet> benmachine: same
07:52:44 <benmachine> Failed to load interface for Data.Tree?
07:53:14 <Fare> damn it, citeseer is down!
07:53:17 <freiksenet> T
07:53:19 <freiksenet> aa
07:53:24 <freiksenet> there is no need for as
07:53:48 <benmachine> as is handy though
07:54:01 <freiksenet> <interactive>:1:0: Not in scope: data constructor `Tree'
07:54:26 <freiksenet> weird shit :/
07:54:33 <benmachine> freiksenet: this is odd
07:55:41 <benmachine> freiksenet: hmm
07:55:49 <benmachine> freiksenet: I can do T.drawTree but not T.Tree
07:56:13 <benmachine> wait
07:56:17 <freiksenet> yaeh, I can do drawTree too
07:56:19 <benmachine> Tree isn't a data constructor
07:56:24 <benmachine> it's a type constructor
07:56:30 <freiksenet> aaah
07:56:36 <freiksenet> :/
07:56:38 <benmachine> try T.Node
07:56:39 <benmachine> etc.
07:56:42 <freiksenet> ok
07:56:54 <freiksenet> thanks ) Sorry
07:57:10 <benmachine> that message could probably do with improving
08:14:21 <tavelram> Ive got a monad instance which doesnt accept (return () >> yada "text"), which according to monad law 1 should be equivalent to (yada "text"), right?
08:14:42 <benmachine> tavelram: yeah
08:14:43 <Berengal> tavelram: yes
08:14:58 * benmachine isn't sure which monad law is 1
08:15:05 <tavelram> ok, right identity?
08:15:08 <Berengal> one of them
08:15:10 <tavelram> yeah
08:15:25 <benmachine> (but yes, return x >> a == a)
08:15:34 <MissPiggy> tavelram doesn't accept??
08:15:40 <tavelram> yeah
08:15:43 <MissPiggy> what
08:15:58 <benmachine> which instance
08:16:19 <tavelram> MissPiggy, yeah, the run function pattern matches on bind nodes, but not on all the leaf nodes...
08:16:20 <tavelram> sort of.
08:16:30 <MissPiggy> i don't understand!
08:16:38 <tavelram> yeah, sorry :,p
08:16:48 <Berengal> modulo operational semantics
08:18:40 <tavelram> Ive got a gadt with constructors Bind, Return, Yada, Yada2. And Ive got a deep embedding of a dsl, so I pattern match in the runfunction, but I cant really pattern match on run (Yada), only on run (Bind a b) and run (return x).
08:18:45 <tavelram> MissPiggy, like that.
08:18:54 <MissPiggy> tavelram what's the GADT?
08:19:08 <MissPiggy> and I guess you have defined eval on it?
08:19:22 <tavelram> nope? whats eval?
08:19:30 <MissPiggy> I mean some kind of interpreter for the monad
08:19:39 <tavelram> yeah, thats the "run" function.
08:19:41 <bastl> i get confused about relating category theory notions to haskell: 1) The category Hask consists of types as objects and functions as arrows, correct?
08:19:44 <MissPiggy> okay that's good
08:19:48 <MissPiggy> and what is it?
08:19:52 <MissPiggy> both GADT and run
08:20:05 <bastl> How about typeclasses Functor and Monad ?
08:20:20 <bastl> List functor maps from what category to what category ?
08:20:39 <quicksilver> bastl: list functor maps from Hask to Hask
08:20:40 <int-e> bastl: Hask to Hask. It's an endofunctor.
08:20:40 <bastl> List ::  Hask -> Hask ?
08:20:47 <bastl> ok
08:21:00 <Berengal> bastl: All functors on Hask are endofunctors
08:21:09 <Berengal> Well, at least all type constructors
08:21:10 <bastl> anyone else ?
08:21:10 <Saizan> the Functor typeclass is really about Endofunctors in Hask
08:21:18 <quicksilver> Functor and Monad btoh attempt to classify maps Hask -> Hask
08:21:24 <bastl> :-)
08:21:34 <bastl> ok. Now how do i think about terms?
08:21:36 <quicksilver> although in Hask -> Hask any functor is automatically a Functor
08:21:38 <quicksilver> that's what it means.
08:21:54 <Saizan> and, the arrows are the monomorphic functions
08:21:56 <quicksilver> erm, that's backwards :)
08:21:58 <Berengal> quicksilver: Monad attempts to classify monoids in the category of endofunctors on Hask
08:21:59 <tavelram> MissPiggy, dont know if I can pastebin it, its part of a school assignment. but the gadt has those for constructors, bind and return are as usual, and Yada and Yada2 are unary, very similiar to return.
08:21:59 <quicksilver> any Functor is a functor.
08:22:00 <Berengal> ;)
08:22:06 <quicksilver> Berengal: right.
08:22:12 <quicksilver> plenty of functors aren't Functors
08:22:20 <quicksilver> because to be a Functor you need to be a type constructor
08:22:29 <quicksilver> however, all functors are isomorphic to a Functor.
08:22:31 <MissPiggy> maybe someone can guess better than me about vauge stuff like that then
08:22:35 <quicksilver> via an appropriate newtype
08:22:44 <tavelram> MissPiggy, sorry :p
08:23:08 <bastl> I dont think about terms, because Objects are blackbox ?
08:23:15 <BONUS> preflex: seen mmorrow
08:23:16 <preflex>  mmorrow was last seen on #ghc 31 days, 13 hours, 25 minutes and 31 seconds ago, saying: * mmorrow is rtfm'ing
08:23:18 <MissPiggy> what's the application of thinking of haskell as a category?
08:23:19 <int-e> mmmm. covariant functors.
08:23:31 <MissPiggy> (rather than using haskell to implement categorical concepts)
08:23:44 <quicksilver> bastl: well, Hask is a semantic model
08:23:44 <ksf> uu-parsinglib is vastly underestimated
08:23:50 <Berengal> tavelram: The issue is in your run function. To run Bind, I assume you have to run 'a', then feed the result into 'b', return the result of running that?
08:23:51 <quicksilver> bastl: so, it model values, not erms
08:24:07 <quicksilver> bastl: you can think of terms as a term algebra
08:24:16 <ksf> there's virtually nothing it doesn't solve, except easy graspability.
08:24:22 <bastl> quicksilver: ah?
08:24:23 <Berengal> tavelram: Because if that's what you do then you should get the same value (Yada "text") in both cases
08:24:38 <quicksilver> bastl: models are semantic, terms are syntactic.
08:24:48 <tavelram> MissPiggy, the problem is basically that ive got this: run (Bind (Return x) f) a b c = run (f x) a b c, and that results in a single constructor Yada, which I dont pattern match - I only pattern match bind and return at the first "level".
08:24:52 <quicksilver> bastl: but term algebras are a kind of canonical syntactic construction.
08:25:02 <quicksilver> one which I know very little about so I may not be much help you past here
08:25:29 <tavelram> Berengal, yeah
08:25:42 <Saizan> tavelram: well, why don't you pattern match those too?
08:25:43 <MissPiggy> ksf, how is it different from readp or parsec?
08:25:51 <Saizan> tavelram: and what's the type of run?
08:26:04 <freiksenet> is planet haskell rss working for you guys alright? I can't subscribe to it using thunderbird
08:26:08 <bastl> Hmm. thanks for the reflections
08:26:26 <Berengal> ksf: Is it easy to get a stack/tree trace for debugging your parsers?
08:26:35 <tavelram> Saizan, because that would only be valid if run (Yada) wasnt in a bind? right? I think there were some ambiguity or something.
08:26:39 <MissPiggy> http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators#New_Version there's a rundown there
08:26:41 <ksf> it's readp _and_ parsec.
08:26:53 <bastl> any good literature on this stuff?
08:27:06 <tavelram> But I was missing monad law 3 as well in the run function at that time, and that will remove the ambiguity..
08:27:13 <Saizan> tavelram: i mean, why don't you have a case run (Yada foo) a b c = .. ?
08:27:40 <bastl> there is a lot, but i still miss a good introduction into the connections between haskell and category theory.
08:27:43 <ksf> it matches strictly breath-first and supports both greedy and non-greedy strategies
08:28:08 <tavelram> Saizan, yeah, it felt a bit redundant, since I already had it as run (Bind (..)), and it shouldnt be allowed to happen, right?
08:28:14 <ksf> it can switch tokenizers on the fly, so you can embed agda in haskell in agda in haskell in agda in haskell
08:28:25 <tavelram> hmm, oh, it will always happen as long as yada is the last in a do though..
08:28:34 <ksf> oh, and it can error-correct
08:28:46 <MissPiggy> "#  two versions of basic parsers, in order to cope with a potential black hole in the Swierstra & Hughes ICFP paper. " -- what??
08:29:05 <Saizan> tavelram: i think pattern matching it inside Bind might be the redundant case
08:30:15 <kuribas> Isn't there a function to replace an element at a specific position in a list?
08:30:24 <byorgey> kuribas: no
08:30:31 <kuribas> ok
08:30:40 <Botje> easily written, though
08:30:45 <ksf> MissPiggy, it's described in the tutorial. it's got to do with >>= and splicing and data flowing in different directions
08:31:40 <MissPiggy> where is that tutorial?
08:32:02 <ksf> http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf
08:32:02 <Botje> replace n x = uncurry (++) . second ((x:) . tail) . splitAt n
08:32:05 <ksf> http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
08:32:09 <MissPiggy> oh thank you
08:32:15 <Botje> roughly :o)
08:32:40 <Botje> :t uncurry (++) . second ((x:) . tail) . splitAt n
08:32:41 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
08:32:41 <lambdabot>     In the first argument of `splitAt', namely `n'
08:32:41 <lambdabot>     In the second argument of `(.)', namely `splitAt n'
08:32:50 <Botje> :t \n x -> uncurry (++) . second ((x:) . tail) . splitAt n
08:32:51 <lambdabot> forall a. Int -> a -> [a] -> [a]
08:32:56 <ksf> ...the main problem is that it's not a tutorial about how to use it, but how to write it.
08:32:57 <Botje> huh. it even typechecks :]
08:33:17 <kuribas> :t take i l ++ [e] ++ drop (i+1) l
08:33:18 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
08:33:18 <lambdabot>     In the first argument of `take', namely `i'
08:33:18 <lambdabot>     In the first argument of `(++)', namely `take i l'
08:33:31 <kuribas> :t \i e l -> take i l ++ [e] ++ drop (i+1) l
08:33:32 <lambdabot> forall a. Int -> a -> [a] -> [a]
08:33:35 <tavelram> Saizan, well, that is true. the problem is my typew though :p. Ive got some more arguments in the run function, that should actually be in a state :p
08:33:41 <MissPiggy> ksf, heh okay that sounds fun anyway
08:33:55 <Botje> kuribas: that's probably more readable, yes :]
08:34:32 <Saizan> tavelram: so your run function is soemthing like run :: Expr a -> Foo -> (Foo, a) ?
08:34:41 <kuribas> Botje: By me at any case :-)
08:34:47 <ksf> ...could not deduce "Oleg t" from the context "You t" arising from a use of Haskell in Foo.hs
08:35:10 <Botje> grin
08:36:05 <tavelram> Saizan, well, it should be something like that, but it its actually something like run :: A -> B -> B -> A. So I should really use a transformer or something.
08:36:31 <osaunders> Does anyone know of a graphical programming environment for Haskell where you create functions by snapping together other functions that have the appropriate input and outputs and can watch the data flow through?
08:36:45 <ksf> re-reading it and this time grokking the second part makes my attempts at a parser appear wholly inappropriate.
08:36:48 <tavelram> Saizan, and the problem is really that im lazy, in the bad way :p
08:37:32 <Saizan> tavelram: that doesn't really look statey, but yeah, with the appropriate monad it should look like run (Bind m f) = run  . f =<< run m
08:37:38 <ksf> osaunders, we don't even have a gui lib that's worthy to be used in implementing such a gem.
08:37:59 <osaunders> ksf: Really?!
08:38:09 <MissPiggy> "A second approach is to extend the type checker of Haskell such that the gen-
08:38:09 <MissPiggy> erated error messages can be tailored by the programmer. Now, the library
08:38:09 <MissPiggy> designer not only designs his library, but also the domain speciï¬c error mes-
08:38:12 <MissPiggy> sages that come with the library. In the Helium compiler [5], which handles a
08:38:15 <MissPiggy> subset of Haskell, this approach has been implemented with good results."
08:38:31 <MissPiggy> somehow this is not as well known as it should be
08:38:34 <osaunders> What the?!
08:38:36 <ksf> ...disregarding tangible values, perhaps, but we have to wait for conals utter enlightenment or care about bitrot, ourselves.
08:39:32 <Saizan> MissPiggy: they should port it to ghc :\
08:39:37 <ksf> custom type errors sounds awesome
08:39:54 <MissPiggy> "It has been designed to make learning Haskell easier by giving clearer error messages. It is being developed at Utrecht University, Netherlands" -- so maybe they have used some of the same techniques in ECH
08:39:55 <osaunders> ksf: Such a thing would be cool though right?
08:40:00 <MissPiggy> EHC/UHC
08:40:11 <ksf> usually it bogs down to desinging type classes in such a way that you get "cannot deduce DoSuchAndSuch t"
08:40:31 <MissPiggy> http://people.cs.uu.nl/bastiaan/phdthesis/ -- this sounds good
08:40:53 <MissPiggy> Top Quality Type Error Messages
08:41:24 <fasta> MissPiggy, I have that one in print.
08:41:39 <jmcarthur> woah, DSL-specific error messages would be AWESOME
08:41:53 <MissPiggy> "we see that Helium, by using a specialised version of the type
08:41:53 <MissPiggy> rules which are provided by the programmer of the library, manages to address
08:41:54 <MissPiggy> the application programmer in terms of the embedded language;"
08:42:05 <MissPiggy> Also I think Ziggeraut is probably relevant here
08:42:07 <fasta> jmcarthur, are you serious?
08:42:14 <ksf> uhc looks like being almost ready to compete with ghc
08:42:21 <MissPiggy> http://lambda-the-ultimate.org/node/3179
08:42:24 <jmcarthur> fasta: i guess it depends how it works
08:42:28 <fasta> jmcarthur, I see it as not much more as an incremental improvement.
08:42:53 <MissPiggy> ksf: does it have GADTs yet :|
08:43:04 <MissPiggy> ksf: it has so much cool stuff but last time I checked no GADT...
08:43:08 <sm> woah.. I put #php and #haskell tabs adjacent in colloquy and got whiplash..
08:43:19 <jmcarthur> fasta: i think it would be nice even if it's only used to direct you to the proper documentation for the types that are failing to unify
08:43:24 <MissPiggy> I think they used to have GADTs but it got removed (to be added back in later)
08:43:36 <fasta> MissPiggy, that sounds like it goes in the right direction.
08:43:56 <MissPiggy> fasta, which thing?
08:44:12 <fasta> MissPiggy, the extensible system you linked.
08:44:32 <ksf> partial type sigs are particularily nice.
08:44:37 <fasta> I still think QiII is a very nice system.
08:44:48 <MissPiggy> fasta, yes there was some very good illustrations in the paper -
08:45:08 <MissPiggy> I keep meaning to do something with it but never really getting around to it
08:46:39 <fasta> jmcarthur, language researchers never consider that language environments are at least as important as the languages themselves.
08:46:49 <fasta> jmcarthur, or they get no money to do so.
08:46:56 <jmcarthur> :(
08:47:07 <roconnor> how do association lists compare to nested closures of comparision functions for represent loopup tables?
08:47:16 <roconnor> lookup
08:47:34 <fasta> jmcarthur, the only exception I can think of is PLT Scheme, but IMHO the implementation is kind of bad.
08:47:49 <fasta> (in some areas)
08:48:08 <fasta> Things like custodians are obviously very nice.
08:48:12 <chupish> PLT even admits that it's not the fastest interpreter in most areas
08:48:44 <fasta> chupish, I was referring to the tools now. If you asked it to annotate the code you had to wait 5 seconds or more.
08:49:34 <chupish> fasta: definitely
08:49:58 <fasta> Another disadvantage is that I have the impression that lots of their libraries are really tied to PLT Scheme.
08:50:06 <fasta> (for no real reason)
08:50:18 <MissPiggy> yeah that's frustrating
08:50:28 <chupish> well, normally the reason is that they have their own nomenclature for most things
08:50:53 <fasta> They should just focus on making a good development environment such that your nightly builds run on Stalin.
08:51:13 <fasta> Then there is an actual real world use for PLT Scheme.
08:51:17 <chupish> heh, Stalin
08:51:26 <fasta> Of course some people already use it like that.
08:51:45 <fasta> chupish, yes, and Stalin needs to be brought up to date first ;)
08:52:06 <chupish> fasta: I'd say; it's one of the better compilers, but is still barely R4RS
08:52:27 <MissPiggy> and as we know bigger number means better right? :p
08:52:43 <chupish> I'd actually like to something like PreScheme become better documented & support more required features
08:53:20 <fasta> chupish, yes, PreScheme seemed to be worthy of love ;)
08:53:32 <ksf> another possibility is to implement -Oinsane for GHC
08:53:50 <chupish> fasta: there's quite a few versions of it that have nice papers written about them :D
08:54:00 <fasta> GHC is essentially doing the same thing as PLT Scheme, but in language features.
08:54:19 <chupish> well, at least GHC is de facto standard, if not soon de iure
08:54:33 <fasta> chupish, iure?
08:54:35 <chupish> PLT is just another dialect, that sometimes kinda sorta fits into the RnRS system
08:54:49 <chupish> de jure "by law" de jure, de iure, depends on your latin
08:54:50 <chupish> :D
08:55:00 <Sogekingu> how can I make function which tests to see whether an error was met doing a function?
08:55:11 <ksf> ...which is yet another reason for any of the other compilers to finish Haskell10 support
08:55:17 <chupish> http://en.wikipedia.org/wiki/De_iure
08:55:20 <chupish> :D
08:55:46 <fasta> chupish, I had Latin on high school. IIRC, jus is the nominativus.
08:55:53 <ksf> I want to have two bug trackers, in each of which being slower in some case than the other compiler is regarded as a valid bug.
08:56:05 <fasta> chupish, but I can forget, unfortunately.
08:56:19 <chupish> fasta: it's mostly classical versus modern interpretations, but I believe you are correct. I don't use latin much :D
08:57:24 <kuribas> Sogekingu: What kind of error?  An exception?
08:58:30 <kuribas> Sogekingu: you can test for exceptions from the IO Monad using try or catch.
08:59:24 <tomoj> apparently jus can also mean "the juice of the purple-fish"
08:59:54 <tomoj> oh, rather just "juice"
09:00:31 <Sogekingu> kuribas I have a function which I use "error whatever" when it meets an error
09:00:50 <Sogekingu> some guys here helped me make a test fuction to test it, however it stops when it meets errors.
09:00:54 <MissPiggy> I thought it was french...
09:01:10 <MissPiggy> soup du jour
09:01:23 <kuribas> Sogekingu: If you want a purely functional alternative you can use (Either String).
09:01:54 <ksf> error can be caught, but it's insanity from a software design pov
09:02:43 <kuribas> Sogekingu: It depends what you want, or have...
09:02:45 <fasta> MissPiggy, jus de fruit is fruit juice, yes.
09:03:01 <fasta> MissPiggy, jus d'orange is orange juice.
09:03:07 <ksf> the easy way is to use kuribas proposal (or a Maybe), the ultimate solution is stuff like http://hackage.haskell.org/package/control-monad-exception
09:03:33 <fasta> MissPiggy, and apparently it is also just juice ;)
09:04:02 <aavogt> juicy justice
09:05:07 <ksf> Sogekingu, in general it's good practice to make all your functions total, that is non-looping and non-exception throwing.
09:05:24 <Saizan> or http://hackage.haskell.org/package/pure-exception
09:05:58 <ksf> exceptions in pure code are particularily nasty because you have to catch them where the exception is forced, not where the function that throws is mentioned.
09:06:22 <Saizan> ..not on hackage maybe
09:07:39 <ksf> control.monad.exception has all that cozy java-style b&d exception handling, except you can switch it to ignore all throws declarations or force yourself to even catch runtime exceptions.
09:18:28 <MissPiggy> suppose I write a haskell program which is just like a input/output command line terminal thing
09:18:54 <MissPiggy> you type in a line of text hit enter and it gives some HTML back -- mabye it's just a function in haskell or it could be a command line program that was compiled
09:18:59 <MissPiggy> whichever is easiest
09:19:23 <MissPiggy> the question is, how to make an interfact that actually displays the HTML rendered properly, rather than as normally you just get text back
09:21:08 <Saizan> in a terminal i don't know, maybe some of the CLI browsers expose a library
09:21:27 <MissPiggy> no it doesh't have to be in terminal
09:22:35 <aavogt> maybe it's just as easy to have it run an a user's browser?
09:22:48 <MissPiggy> okay but how do I do that?
09:22:51 <aavogt> as in write some cgi script or happstack app
09:23:08 <monochrom> It doesn't have to be the same window.
09:23:15 <MissPiggy> happstack is kind of scary looking
09:23:26 <chupish> something like XQuery but in Haskell would be nice
09:23:33 <chupish> There's Link too btw
09:23:37 * hackagebot upload: LDAP 0.6.6 - Haskell binding for C LDAP API (JohnGoerzen)
09:24:16 <monochrom> I type in an xterm. I type like "hello". Then the program saves html code into a file called "haha.html". Then the program execs "firefox haha.html".
09:24:16 <Saizan> gtk2hs had mozembed but i don't see it anymore in the haddock
09:24:38 <MissPiggy> monochrom that would work I guess but it wouldn't be nice to use
09:24:43 <Saizan> MissPiggy: you could follow this http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell
09:24:46 <fasta> Saizan, I would not be surprised if they dropped it, since it was buggy.
09:25:09 <monochrom> Some other people think it is nice to use.
09:26:27 * copumpkin wonders how the entrance of vector affects ByteString
09:26:40 <copumpkin> type ByteString = Vector Word8 ?
09:26:53 <copumpkin> next we just need lazy vectors
09:27:01 <jmcarthur> copumpkin: :D
09:27:05 <aavogt> yeah, bytestrings can be chunky
09:27:13 <monochrom> Some people even think that my last execing part is unnecessary, just have user hope over to the browser and ctrl-r.
09:27:26 <copumpkin> having a lazy vector and a "rope vector" built on top of regular vector
09:27:29 <copumpkin> would be awesome :)
09:27:31 <jmcarthur> type LazyVector a = [Vector a]
09:27:48 <copumpkin> well, you'd want it strict in elements and lazy in the spine
09:27:50 <copumpkin> probably
09:27:51 <MissPiggy> that's odd
09:27:54 <MissPiggy> it just prints out html
09:28:08 <jmcarthur> yeah
09:28:32 <copumpkin> but having a general lazy chunked datatype
09:28:33 <jmcarthur> copumpkin: i kind of wish lists did that already
09:28:35 <copumpkin> would be awesome :)
09:28:42 <monochrom> Perhaps you feel odd because I have been nonconstructive about my "some". So here is the constructive witness: LaTeX fanatics.
09:29:05 <copumpkin> but having a rope-like structure would also be awesome
09:29:09 <copumpkin> it could be built easily with fingertree
09:29:11 <MissPiggy> monochrom: I don't think so, by the way I am writing this program for my own use
09:29:18 <jmcarthur> indeed
09:30:04 <jmcarthur> Text should use Vector, too
09:30:13 <jmcarthur> at least indirectly through ByteString using Vector
09:30:18 <jmcarthur> it would be awesome
09:30:49 <copumpkin> yeah
09:30:53 <copumpkin> well Text isn't built on ByteString
09:30:57 <monochrom> Do you know the LaTeX fanatics workflow? Type text in one window, press some key to save, press some more key to render. The render appears in a second window, and they have to press some "reload" key over there too.
09:31:18 <monochrom> And just yesterday someone right here actually defended this as the best interaction ever.
09:31:28 <jmcarthur> copumpkin: oh you're right. i thought it was
09:31:39 <copumpkin> but it could be built over Vector of Word16
09:31:44 <jmcarthur> yes
09:32:07 <MissPiggy> I have to set up some kind of CGI thing this is so confusing
09:32:11 <Saizan> monochrom: oh, even when there are latex editors and pdf viewers that make that a single keypress?
09:32:43 <MissPiggy> "To run the compiled program, visit the URL of the CGI program with your web browser."
09:32:44 <monochrom> AFAIK they still need at least two keys, one to save, one to render.
09:32:52 <MissPiggy> this is a great tutorial lol they just tell you nothing
09:32:56 <Saizan> evince rerenders automatically.
09:33:09 <monochrom> Yes I am talking about the editor side.
09:33:40 <Saizan> ah, well, just bind another key to do both :)
09:34:06 <monochrom> A reasonable person would.
09:34:48 <MissPiggy> Hello World!
09:34:57 <monochrom> I don't know whether I'm talking about reasonable persons or real persons.
09:35:26 * copumpkin is really unreasonable
09:36:23 <tavelram> Saizan, yeah. thanks for the help guys.
09:36:23 <MissPiggy> " Extending the CGI monad with monad transformers
09:36:36 <MissPiggy> I will need to do that so that I can have also the GHCi monad
09:36:45 <MissPiggy> I guess that is the right way...
09:37:09 <MissPiggy> hm maybe I should not use ghci because it is horribly difficult to use
09:38:35 <MissPiggy> ugh if the haskell program is restarted every time that wont work
09:39:09 <monochrom> May I ask why?
09:39:28 <wto> MissPiggy: AFP, is it?
09:40:36 <Saizan> MissPiggy: with fastcgi it should be a running process
09:41:59 * ksf decides that the instance documentation  "Show a => Provides (Str a) (a -> Bool, String, a) a" in uu parsinglib is the most obfuscated way to document that one can match with arbitrary boolean predicates, ever.
09:42:18 <monochrom> If you want to thread states through, hide state data in the web form.
09:42:20 <ksf> but it's damn ingenious
09:42:48 <ksf> you can match against an a with pSym 'a', and against a..z with pSym ('a','z')
09:42:56 <MissPiggy> I wonder if someone had already written what I need
09:43:08 <ksf> ...and against any character with pSym (\(_::Char) -> False, "any character", u::Char)
09:43:13 <ksf> er True
09:43:47 <levente_meszaros> hail
10:25:20 <c_wraith> wow.  thread leaks are bad.  I've confirmed that's the problem.  Now to sort out why the ThreadIds are being held.
10:40:44 <MissPiggy> I just wasted an hour or two on this and still nothing I hatet his
10:43:34 <IceDane> Is hGetContents lazy, by chance?
10:43:48 <IceDane> if so, is there a non-lazy way to get all the data available to be received from a socket?
10:43:59 <Zao> IceDane: Force it all?
10:44:08 <Berengal> MissPiggy: On what? CGI?
10:44:09 <MissPiggy> it is but there is a version in the strict package
10:44:18 <IceDane> Zao: How do I do thhat?
10:44:19 <jmcarthur> i think IceDane means what's currently int he receive buffer, not everything to be received
10:44:19 <Saizan> Data.ByteString.hGetContents is strict too
10:44:26 <IceDane> Ah..
10:44:31 <jmcarthur> IceDane: am i right?
10:44:33 <MissPiggy> Berengal, well I have actually been trying to get this working for weeks now
10:44:43 <Berengal> IceDane: c <- hGetContents socket; seq (last c) (return ())
10:44:50 <MissPiggy> don't seq :/
10:44:52 <Berengal> MissPiggy: Use happstack. Much easier :P
10:44:59 <IceDane> jmcarthur: Wut?
10:45:12 <MissPiggy> okay I will try happstack
10:45:14 <IceDane> Berengal: Thanks - I'll try it out
10:45:15 <jmcarthur> IceDane: do you want to get everything that will ever be sent on the socket or just what has already been sent?
10:45:28 <MissPiggy> Does anyone who knows happstack want to hel me write this tiny little web thing!?
10:45:37 <Berengal> MissPiggy: What do you need?
10:45:40 <MissPiggy> it's just a REPL (like ghci or whatever) but in a web browser
10:45:49 <aavogt> and you failed at cgi?
10:45:51 <MissPiggy> it should be dead simple but for some reason I just can't do it
10:45:52 <IceDane> jmcarthur: Haha, what as already been sent
10:45:58 <Berengal> MissPiggy: How does the communication back and forth work? AJAX?
10:45:59 <MissPiggy> not just cgi I have tried everything I can think of
10:46:05 <MissPiggy> Berengal -- yeah
10:46:06 <jmcarthur> IceDane: ah, then everybody is giving you the wrong answer ;)
10:46:27 <joe1> runghc works fine, but I keep getting errors when I do "ghc <haskell file>.hs"
10:46:28 <joe1> ghc read_sram.hs
10:46:28 <joe1> read_sram.o: In function `r244_info':
10:46:28 <joe1> (.text+0x721): undefined reference to `usbzm0zi3zi0zi1_SystemziUSBziInternal_zdf67_closure'
10:46:35 <IceDane> The thing is, I'm running parsec on the code of a web page after I sent a get request. If I have a "writeFile "somefile" contents" it will parse correctly
10:46:37 <Saizan> joe1: use --make
10:46:38 <IceDane> if I do not, it errors out
10:46:38 <IceDane> I don
10:46:52 <IceDane> I don't know why I it would happen, but I have a feeling it has something to do with laziness
10:46:52 <Berengal> MissPiggy: I can help you map requests to (request -> response) -ish constructs if you're okay with providing the mappings yourslf
10:47:09 <MissPiggy> I don't actually know what that means Berengal
10:47:32 <MissPiggy> suppose I have some monad like IO (or maybe ST)
10:47:37 <joe1> saizan: thanks, it helped.
10:47:37 <Saizan> IceDane: it's not really laziness, it's hGetContents that uses unsafeInterleaveIO making the side-effect of reading from the Handle to happen in a concurrent fashion
10:47:54 <MissPiggy> and there is a function which reads a line (that would come from the input box) and then it prints a line
10:47:55 <Saizan> IceDane: driven by you forcing the result
10:48:10 <MissPiggy> I just need a HTML interfacte to that, so I can display images instead of ASCII
10:48:12 <jmcarthur> it's lazy IO (BAD BAD BAD)
10:48:21 <IceDane> Saizan: Ah, I see.. So it doesn't directly 'block' as I would expect it to coming from C?
10:48:28 <Berengal> MissPiggy: The simple answer is "main = simpleHTTP nullConf $ msum [dir "foo" fooPage, dir "bar" barPage]
10:48:29 <Saizan> IceDane: yeah
10:48:29 <Berengal> "
10:48:32 <IceDane> Oh, wow
10:48:36 <IceDane> That is definitely strange
10:48:39 <Saizan> IceDane: it doesn't, i mean
10:48:47 <MissPiggy> main = simpleHTTP nullConf $ msum [dir "foo" fooPage, dir  "bar" barPage]
10:48:48 <MissPiggy> oops
10:48:54 <Saizan> IceDane: however, are you perhaps using hClose on the Handle?
10:48:55 <jmcarthur> IceDane: hGetContents should be unsafeHGetContents :(
10:48:55 <MissPiggy> I didn't mean to paste that back into here
10:49:15 <Berengal> MissPiggy: And "import Happstack.Server"
10:49:20 <Saizan> IceDane: that's most likely why you get the parse errors occasionally
10:49:28 <IceDane> Saizan: I am, actually. I put it in for debug purposes some time ago and I didn't see it make a difference, and I kind of thought it wouldn't do any harm
10:49:29 <MissPiggy> sigh
10:49:29 <MissPiggy> hslogger-1.0.7 failed during the building phase. The exception was:
10:49:29 <MissPiggy> ExitFailure 1
10:49:32 <IceDane> Ah, I'll try removing it, thanks.
10:49:36 <Berengal> MissPiggy: Well, the absolutely simplest would be "simpleHTTP nullConf (return "Hello world!")
10:49:52 <MissPiggy> Berengal yeah but that isn't a REPL :(
10:50:00 <Berengal> MissPiggy: No, but it can be
10:50:13 <MissPiggy> I can't even install happstack so what does it matter
10:50:25 <IceDane> Saizan: Wow, thanks! That seems to be the issue
10:50:26 <Berengal> MissPiggy: Which ghc are you running?
10:50:32 <MissPiggy> 6.12
10:50:35 <Berengal> And which cabal version?
10:50:37 <Berengal> 1.8?
10:50:38 <IceDane> I'll need to test it further, but it worked on pages it didn't work before.
10:50:40 <IceDane> brb food
10:50:41 <MissPiggy> yes
10:50:46 <Berengal> Also, are you building with documentation?
10:51:26 <MissPiggy> just trying cabal install happstack
10:51:29 <Berengal> cat ~.cabal/config | grep Documentation
10:51:42 <sjw> IceDane: if it is any consolation, hClose and hGetContents caught me once as well
10:52:00 <IceDane> sjw: Hehe
10:52:16 <IceDane> Why is it these were implemented like this?
10:52:21 <IceDane> I can only see it causing problems
10:52:27 <sjw> hGetContents is pretty hacky
10:52:47 <Saizan> IceDane: hGetContents is nice memory-wise for large data
10:52:55 <sjw> it is more or less nice for small programs
10:52:57 <Berengal> MissPiggy: There's a bug in haddock in that it regenerates .hi files. GHCs object files are very tightly linked with their .hi files, so this is a bad idea. It usually works, but whenever there's TH involved, and the TH in question generates random names... well, it's not pretty
10:53:04 <Saizan> IceDane: if you can consume it in a stream processing style
10:53:09 <IceDane> Ah.. So hGetContents will never read the entire file?
10:53:15 <IceDane> Hmm, I recall reading about this in RWH
10:53:19 <IceDane> Maybe I should revisit that section
10:53:49 <Saizan> it'll read it as far as you consume the result
10:54:07 <Saizan> so when you're in the middle garbage collection might have already disposed of the start of it, etc..
10:54:27 <IceDane> I see
10:54:59 <Saizan> however, it's considered a wart that such a complicated semantics is used for a such innocently looking function :)
10:55:13 <Saizan> (by some, at least)
10:55:20 <IceDane> I already dislike it, heh
10:55:27 <Berengal> I also consider it a wart that there's no strict hGetContents for strings
10:55:32 <IceDane> Maybe I'll like it if I ever heave to read af ile that's several gigs
10:55:55 <Saizan> for several gigs i'd probably use lazy bytestrings though
10:55:56 <Berengal> IceDane: That's what I've used it for. Works nicely if the logic is simple
10:56:38 <Saizan> though it might not make a difference if you never store more than a few characters at once
10:56:43 <Saizan> in memory
10:57:04 <sjw> Saizan: are you aure that is the reason?
10:57:10 <MissPiggy> this jst not working
10:57:13 <sjw> I am pretty sure the IO stuff with handles buffers
10:57:15 <IceDane> I see. Well, thanks for your help guys, it's dinner time.
10:57:25 <c_wraith> Looking at my heap profiles.  (:) often has more memory allocated than anything else.  It's awesome.
10:58:27 <Saizan> sjw: what about buffers?
10:59:19 * MissPiggy wants to just die
10:59:26 <Saizan> c_wraith: maybe you need bytestrings too?:)
10:59:28 * medfly hugs MissPiggy 
10:59:44 <Saizan> MissPiggy: what's the actual error installing hslogger gave? it should be in the scrollback
10:59:56 <MissPiggy> I don't know I broke my ghc install
11:00:05 <c_wraith> bytestrings would help..  But then all the parsing code would have to be re-written to use them.
11:00:09 <abbe> MissPiggy: Why 'Just Die' ? Why not Nothing :)
11:00:30 <c_wraith> woo.  thread leak eradicated!
11:01:23 <sjw> :t hGetBuffering
11:01:24 <lambdabot> Not in scope: `hGetBuffering'
11:01:45 <sjw> :t System.IO.hGetBuffering
11:01:46 <lambdabot> GHC.IOBase.Handle -> IO GHC.IOBase.BufferMode
11:02:35 <sjw> so presumably (assuming things are set up OK) hGetChar will go via a buffer
11:03:31 <c_wraith> If the handle is set to buffer, yes
11:03:35 <Saizan> yeah
11:03:43 <sjw> so hGetContents probably won't be more efficient
11:03:59 <choffstein> Is there a way to get numeric limits in Haskell like C++'s std::numeric_limits<float>::infinity()?
11:04:04 <sjw> i would imagine hGetContents is probably more of a hack so you don't have to deal with IO :)
11:04:09 <c_wraith> by the way.  I'm pretty sure handles are *not* threadsafe.  Beware of that
11:04:35 <burp> @hoogle bound
11:04:35 <lambdabot> Network.Socket Bound :: SocketStatus
11:04:35 <lambdabot> Prelude class Bounded a
11:04:35 <lambdabot> Data.Graph type Bounds = (Vertex, Vertex)
11:04:41 <Saizan> sjw: it's more efficient in the sense that you get a value that represents the whole content of the stream without really reading it all into memory up front
11:04:48 <c_wraith> (I think I deadlocked the production server by trying to hflush from one thread and write from another last night.  oops.)
11:04:59 <burp> choffstein: maxBound :: Double â† like this?
11:05:06 <choffstein> yessir!
11:05:09 <mauke> I don't think Double is bounded
11:05:12 <Saizan> it's not more efficient than explicitly doing chuncked reads from IO
11:05:14 <burp> uh yes
11:05:22 <burp> but you get the idea :p
11:05:33 <Pirace> Hi!  I'm kind of new to Windows programming, so the question might sound silly.  How do I investigate what causes Â«Package unix-2.4.0.0 can't be built on this systemÂ» in Cabal?
11:05:38 <burp> why is Double not bounded btw?
11:05:47 <Pirace> Cabal's stdout + stderr: http://nebydlo.ath.cx:6680/p/cabal_log.txt
11:05:55 <mauke> Pirace: probably because it's unix bindings?
11:06:09 <jmcarthur> burp: i think the idea is that we pretend Double = Real
11:06:17 <sjw> > maxBound :: Double
11:06:18 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
11:06:18 <lambdabot>    arising from a use o...
11:06:26 <sjw> huh
11:06:38 <medfly> I guess something else bounds it...?
11:06:40 <medfly> oh, nvm
11:06:42 <medfly> oops. right :)
11:06:58 <Pirace> mauke: I have the Mingw thingie with coreutils
11:07:50 <burp> I'll add a Bounded Double instance to my burpskell prelude ;)
11:07:52 <Pirace> unix >=2.3 is required by astrds
11:08:14 <mauke> instance Bounded Double where minBound = -1/0; maxBound = 1/0
11:09:02 <Saizan> Pirace: i'm afraid you can't use it on windows
11:09:47 <MissPiggy> how do you just completely erase all traces of GHC and cabal and everything?
11:10:21 <c_wraith> remove it from where it was installed, remove ~/.ghc and ~/.cabal
11:10:22 <mauke> dd if=/dev/zero of=/dev/sdaEVERYTHING
11:11:10 <burp> > 1.7*10^308 :: Double
11:11:10 <choffstein> Okay, very newbie haskell question alert.  If I am trying to define a type that expects an input type 'a', how can I set up my type definition to make sure a is Num?
11:11:11 <lambdabot>   1.700000000000001e308
11:11:15 <burp> somewhere around this ;)
11:11:30 <mauke> choffstein: you can't
11:11:54 <MissPiggy> > 1.8*10^308 :: Double
11:11:55 <lambdabot>   Infinity
11:11:58 <choffstein> mauke: Okay.  Any possible solutions?
11:12:12 <mauke> choffstein: why does your type definition care about Num?
11:12:23 <zygoloid> you can write "data Num a => T a = C a" but it won't do what you want, sadly
11:12:41 <sjw> :t Infinity
11:12:42 <lambdabot> Not in scope: data constructor `Infinity'
11:12:50 <sjw> sigh
11:13:22 <zygoloid> @type infinity
11:13:24 <lambdabot> Natural
11:13:33 <aavogt> @hackage unix-compat
11:13:33 <lambdabot> http://hackage.haskell.org/package/unix-compat
11:13:38 <mreh> I think what choffstein is talking about *is* a type context
11:13:50 <aavogt> Pirace: it could be that you could substitute that package ^^
11:13:52 <choffstein> mauke: Well, I defined a class and then several instances of that class.  Then my data type has a list in it which I want to ensure I can map over using a function defined in my class
11:14:00 <choffstein> Sorry for sloppy language, I am very very green with Haskell
11:14:05 <Esteban25> @type 0
11:14:06 <lambdabot> forall t. (Num t) => t
11:14:10 <choffstein> Seeing the light after years of C++ and Ruby
11:14:18 <zygoloid> choffstein: the usual thing to do is to put the Num constraint on the functions which use the type, not on the type itself.
11:14:57 <Berengal> zygoloid: What does the class function look like?
11:15:03 <Pirace> aavogt: what do you mean?
11:15:03 <Berengal> Err, choffstein
11:15:03 <choffstein> zygoloid: Okay, that makes sense.  As long as the restriction is defined somewhere, the type system should propagate the restriction through?
11:15:26 <choffstein> class Mutatable a where
11:15:26 <choffstein> 		mutate :: a -> a
11:15:31 <Pirace> Is there a way to get epochTime on Windows without depending on System.Posix from package Â«unixÂ»?
11:15:44 <Berengal> choffstein: And you want a to be a Num?
11:15:51 <mauke> choffstein: that sounds like existential types
11:15:53 <choffstein> No, I was really just using num as an example
11:15:54 <Berengal> Then mutate :: (Num a) => a -> a
11:16:08 <choffstein> I want to do something like: data (Mutatable a) => Genome a = Genome [a]
11:16:11 <mauke> which require a language extension
11:16:23 <mauke> choffstein: that still makes all a's the same type
11:16:33 <mauke> it doesn't let you put different types in one list
11:16:38 <mreh> choffstein making a GA?
11:16:42 <choffstein> I don't want different types in one list mauke
11:16:48 <choffstein> I just want to ensure the type is Mutatable
11:16:58 <Berengal> choffstein: Ah, then just make data Genome a = Genome [a], and put the constraint on the functions using Genome
11:17:12 <choffstein> mreh: yessir.  A GA, PSO, Simulated Annealing hybrid.  Figured I'd get my feet wet with Haskell with a serious project
11:17:19 <mauke> s/ta//
11:17:34 <choffstein> Berengal: Ah, that makes sense.  Okay, thank you
11:17:34 <Berengal> For example genomotron :: (Mutable a) => Genome a -> Mutant a
11:17:35 <Gracenotes> hm.. braid has frame-of-reference sideways platforms
11:17:39 <burp> > (1 - 2^^(-53))*2^1024 :: Double -- hmm
11:17:40 <lambdabot>   Infinity
11:18:08 <mreh> braid is amazing
11:18:19 <Berengal> Braid was awesome, but boring at the same time...
11:18:24 <aavogt> Pirace: yes, time seems to be more portable... I'm not sure if you can directly get seconds using a library function though
11:18:31 <burp> > (1 - 2^^(-53))*2^1024 :: CReal
11:18:32 <lambdabot>   179769313486231570814527423731704356798070567525844996598917476803157260780...
11:18:38 <burp> arg, yes
11:19:05 <aavogt> > fromEnum (1/0)
11:19:05 <lambdabot>   0
11:19:16 <aavogt> > fromEnum (0/0)
11:19:17 <lambdabot>   0
11:19:18 <Berengal> > to Enum 0 :: Double
11:19:19 <lambdabot>   Not in scope: `to'Not in scope: data constructor `Enum'
11:19:20 <mreh> i'm going to make asteroids with hardcore weapons and gravity fields
11:19:22 <Berengal> > toEnum 0 :: Double
11:19:23 <lambdabot>   0.0
11:19:48 <mreh> this guy in the yampa paper seems to think that velocity is limited by the capabilities of a space-craft
11:19:51 <Berengal> mreh: chipmunked asteroids would be awesome
11:20:05 <MissPiggy> mreh that seems quite reasonable though
11:20:20 <Berengal> mreh: In games that's true. Relativistic physics are boring, even in space.
11:20:32 <lament> s/relativistic/newtonian
11:20:34 <choffstein> thanks for all the help guys
11:20:40 <mreh> friction is what limits your velocity
11:20:41 <ksf> rotfl
11:20:49 <burp> > 1.797693134862314*10^308 :: Double
11:20:50 <lambdabot>   1.7976931348623151e308
11:20:54 <burp> damn rounding errors
11:21:03 <Berengal> lament: realistic, then
11:21:03 <lament> mreh: it is reasonable though. There's still friction in space.
11:21:10 <mreh> that's more accurate that QED
11:21:12 <ksf> uu-parsinglibs correction tells me to comment out those parts of the input for which I did'nt write the grammar yet.
11:21:21 <mreh> r/that/than/
11:21:27 <lament> mreh: i mean, velocity *is* limited by the capabilities, just like it is for ships.
11:21:44 <lament> it's just faster than it normally gets in video games.
11:21:45 <mreh> maximum speed is limited
11:22:13 <Berengal> lament: Video games have warp speed
11:22:19 <Berengal> Well, sometimes
11:22:26 <mreh> anyway, yes, even Atari's 1979 Asteroids had friction
11:22:37 <mreh> *in space* of all places
11:23:10 <ksf> mreh, in eve it's the same.
11:23:11 <mreh> Asteroids has infinity speed if you hit the right button, you just have no idea where you're going to end up
11:23:15 <Berengal> mreh: As I said, real physics is boring in space. I've tried some games that have that, and they're impossible to control
11:23:32 <zygoloid> Berengal: EVE? :)
11:23:51 <sjw> Berengal: well, you only have so much fuel
11:23:53 <zygoloid> actually that doesn't have correct physics i don't think :(
11:24:06 <mreh> Berengal: which games did you have in mind
11:24:10 <Berengal> zygoloid: EVE's controls are based on economics and spreadsheets, not physics
11:24:24 <mreh> if you run out of fuel you wont slow down!
11:24:28 <Berengal> mreh: Can't remember the name, but some open source thing that's in the ubuntu repos
11:24:30 <jmcarthur> i've played at least one 3d space game that had realistic physics, and it was indeed very difficult
11:24:44 <mreh> lunar lander? :)
11:24:55 <lament> what a painful game
11:24:56 <mreh> oh, *3D*
11:25:06 <Dark_Shikari> jmcarthur: vendetta online
11:25:06 <Dark_Shikari> I think
11:25:14 <ksf> hardly. your ship has a top speed, and for some strange reason space seems to be divided into cubes which influence the sensors...
11:25:14 <Dark_Shikari> it has a newtonian flight mode that was an utter bitch to deal with
11:25:31 <fizruk> hi all! i have stack overflow in ghc 6.10.4 for "maximum [1..999999]", what to do? hugs gives segfault
11:25:35 <lament> realistic 3d spaceflight sounds like something you'd take a while getting used to, but then get used to
11:25:45 <Berengal> fizruk: foldl' max minBound instead of maximum
11:25:47 <aavogt> fizruk: compile with optimizations
11:25:51 <burp> and don't use hugs
11:25:55 <ksf> there's just no way to do that without an autopilot.
11:26:00 <jmcarthur> it was a search and rescue game, so lots of landing and taking off
11:26:28 <Berengal> lament: Perhaps you'd get used to it, but it does have inherent limitations. Dogfights, for example, would be nonexistant
11:26:34 <fizruk> mm... ok, but why maximum fails?
11:26:35 <ksf> ...although, with negative friction (which is how warp works in eve), you can start and stop basically instantly.
11:26:39 <Berengal> lament: There'd be no big fleet battles, just hit-and-runs
11:26:51 <lament> Berengal: why?
11:26:55 <ksf> but then, all ships would suddenly be the same speed. and I don't want to be hunted by titans.
11:27:18 <jmcarthur> http://www.nether.org.uk/bad_mac_code.html#rescue
11:27:28 <lament> Berengal: it's hard to execute a hit-and-run, if the other ship sees you coming it can easily dodge
11:27:30 <jmcarthur> i actually don't remember if it has a speed limiter or not
11:27:42 <jmcarthur> i never got it going very fast
11:27:47 <Berengal> lament: A bit hard to see something travelling at the speed of light
11:27:55 <mreh> your ships would not be the same speed
11:27:56 <fizruk> @src maximum
11:27:56 <lambdabot> maximum [] = undefined
11:27:56 <lambdabot> maximum xs = foldl1 max xs
11:27:59 <lament> Berengal: i assume you have some kind of radar?
11:28:22 <mreh> they have different rates of acceleration
11:29:25 <jmcarthur> Berengal: they dog fight fairly well in battlestar galactica
11:29:26 <sjw> mreh: sure, but you won't go any faster
11:30:12 <Berengal> jmcarthur: BSG also doesn't really care about the physics of space battles
11:30:15 <jmcarthur> it's just not so much swooping as position management
11:30:21 <fizruk> i till don't understand, why maximum [1..999999] doesn't work :(
11:30:31 <sjw> IIRC Frontier had a semi-realistic space sim
11:30:33 <Berengal> fizruk: Lazy evaluation
11:30:42 <fizruk> and?
11:30:42 <mreh> you can go VERY fast in space, until you start reaching relativistic speeds
11:30:51 <jmcarthur> Berengal: well, no, it's a tv show, but they do incorporate elements of more realistic space battles. they don't "swoop" for example
11:30:59 <c_wraith> > maximum [1..999999]
11:31:01 <lambdabot>   * Exception: stack overflow
11:31:09 <Philonous> @src maximum
11:31:09 <lambdabot> maximum [] = undefined
11:31:09 <lambdabot> maximum xs = foldl1 max xs
11:31:23 <mreh> why do spaceships always meet in the same orientation, there's no up or down?
11:31:23 <Berengal> fizruk: Let's see at how maximum behaves
11:31:38 <mreh> we should take this to -blah really
11:31:42 <trzkril> > maximum [a, b, c, d]
11:31:42 <c_wraith> > foldl1' max [1..999999]
11:31:43 <lambdabot>   max (max (max a b) c) d
11:31:43 <lambdabot>   999999
11:32:10 <fizruk> @src foldl1'
11:32:10 <lambdabot> Source not found. Wrong!  You cheating scum!
11:32:16 <trzkril> > foldl1' [a, b, c, d]
11:32:17 <lambdabot>   Couldn't match expected type `a -> a -> a'
11:32:17 <lambdabot>         against inferred type `[...
11:32:23 <trzkril> > foldl1' max [a, b, c, d]
11:32:24 <lambdabot>   max (max (max a b) c) d
11:32:44 <Philonous> fizruk: foldl1' is a strictified version of foldl1
11:33:03 <fizruk> Philonous, thanks )
11:33:04 <Berengal> maximum [1,2,3, 4] = max 1 (maximum [2,3,4]) = max 1 (max 2 (maximum [3, 4])) = max 1 (max 2 (max 3 4)) = max 1 (max 2 4) = max 1 4 = 4
11:33:06 <Philonous> fizruk: It doesn't build up thinks but computes the maximum immediately as it goes along
11:33:11 <Philonous> thunks*
11:33:15 <trzkril> > foldr max [0..999999]
11:33:20 <lambdabot>   mueval-core: Time limit exceeded
11:34:03 <Berengal> fizruk: maximum recurses through the list calling "max" on every element. Because of lazy evaluation however, that max isn't further evaluated, and you end up with a deeply nested expression (the max 1 (max 2 (max 3 ...)) bit)
11:34:06 <trzkril> > foldlr max [a, b, c, d]
11:34:09 <lambdabot>   Not in scope: `foldlr'
11:34:11 <trzkril> > foldr max [a, b, c, d]
11:34:12 <lambdabot>   No instance for (Test.SmallCheck.Serial SimpleReflect.Expr)
11:34:12 <lambdabot>    arising from...
11:34:23 <roboshibby> mreh:
11:34:23 <roboshibby> why do spaceships always meet in the same orientation, there's no up or down? <-- what i like to call the star trek paradox =)
11:34:25 <trzkril> > foldr1 max [a, b, c, d]
11:34:27 <lambdabot>   max a (max b (max c d))
11:34:43 <Berengal> fizruk: It starts by evaluating the outermost expression, but that's not immediately reducible. It has to push that expression on the stack and evaluate the inner expression first
11:34:48 <burp> roboshibby: lol, never thought about that
11:34:56 <Twey> A.K.A. a `max` b `max` c `max d
11:35:01 <roboshibby> interesting huh?
11:35:06 <Berengal> fizruk: In the case of maximum [1..9999999] it has to do this alot, causing the stack to grow out of bounds
11:35:07 <Philonous> roboshibby: It's not as paradoxical when you consider that the galaxy is rather flat
11:35:12 <mreh> it's funny how noone wants to discuss a topic after it's been moved to #haskell-blah :)
11:35:33 <roboshibby> Philonous: yea however you desire to outsmart yourself, it is paradoxical
11:36:18 <Twey> mreh: So long as it's happening in here, we feel like we're being productive.
11:36:48 <monochrom> I don't understand why people don't start in #haskell-blah in the first place.
11:37:08 <Berengal> Plenty OT conversations start in -blah
11:37:09 <monochrom> It is not like conversations violate the well-ordering principle.
11:37:19 <Philonous> Also, it is supposed to be a naval metaphor. But I guess that misses the point of (humorously) applying scientific rigor to fiction?
11:37:35 <fizruk> Berengal: so, with optimizations on, fold will be turned into somthing like cycle, and there would be no stack overflow?
11:37:37 <mreh> I don't want to have to pass a RandomGen explicity to my SignalFunctions :.(
11:37:51 <mightybyte> Anyone know of a BBCode library in haskell?  Hackage and google have turned up dry.
11:38:07 <jmcarthur> mreh: MonadRandom
11:38:18 <Berengal> fizruk: With optimizations on the compiler will notice that max is a strict function, and strictify the fold as well. At least it will in the case of integers
11:38:37 <mreh> jmcarthur: can I do monads in Arrow syntax?
11:38:49 <jmcarthur> mreh: you can with Kleisli, but why would you want to?
11:38:49 <mreh> I was going to say "Arrow code", that's something else
11:38:52 <fizruk> Berengal: ok, thanks a lot :)
11:38:55 <Berengal> fizruk: There's also specializations, which library authors can specify as pragmas, which makes it easier for the compiler to know these things
11:39:16 <mreh> jmcarthur: stochastic processes happening in my SignalFunctions
11:39:34 <jmcarthur> mreh: well you can make an arrow from any monad using kleisli
11:39:49 <Dan> Hey, I have two modules. Useful and Useful.Dictionary - is there a way I can make it so that if you import Useful you also get all the stuff in Useful.Dictionary. Sorry I'm sort of new to cabal.
11:39:55 <jmcarthur> and you can make a monad from any ArrowApply
11:39:55 <mreh> jmcarthur: it's already in an arrow, the "SF a b" arrow
11:40:16 <mreh> that's what I mean by doing monads in Arrow syntax
11:40:19 <fizruk> Berengal: so most prefered solution is turning on optimizations or using maximum' with foldl1'?
11:40:34 <Berengal> fizruk: Strictness analyzation is not something you can depend upon in general though. Your program won't automatically be as strict as possible while retaining the terminating properties of lazy evaluation. In case of doubt the compiler errs on the side of semantics, prefering lazyness over strictness when it can't deduce they reduce to the same thing
11:41:25 <monochrom> Dan: Useful says: module Useful(module Useful.Dictionary, other stuff)
11:41:25 <mreh> I need the type RandomGen g => SF a (Rand g b)
11:41:27 <Berengal> fizruk: So use strict functions when you want to be strict. That is, use foldl'/foldl1'. You'll almost never want to use the lazy foldl. (The lazy foldr, however, is a whole different story)
11:41:38 <Dan> monochrom - Thanks
11:42:15 <mreh> is it easy to do Monads inside monads without using a transformer?
11:42:32 <Dan> awesome. Works perfectly.
11:42:45 <mreh> obviously you can't use the do syntax, but I could do it with >>= and return
11:42:48 <jmcarthur> mreh: if you want to make a monad or arrow out of that you will probably want to make a new type out of it that is an instance of the things you want
11:43:08 <fizruk> Berengal: so it's better to use strict functions, than using compilers optimizations? to be sure :)
11:43:10 <jmcarthur> mreh: so some sort of transformer or monad composition or something
11:43:10 <monochrom> What is "monads inside monads"?
11:43:30 <mreh> monchrom: [Rand g a]
11:43:31 <jmcarthur> mreh: but yeah, you could just leave it like that if you want
11:43:43 <jmcarthur> it's just a bit of syntactic burden
11:44:02 <samagon> could anyone explain me what are possible reasons of non-exhaustive patterns error?
11:44:05 <mreh> jmcarthur: not as bad as passing and forking random gens all over the place
11:44:17 <mreh> samagon: it's rather self explanatory
11:44:19 <Berengal> fizruk: If you want to be strict, yes. I usually don't care, using lazyness wherever and trusting the compiler not to make a mess of it. I only use explicit strictness when I know for sure that I want something to be strict
11:44:23 <jmcarthur> samagon: you didn't consider every possible case in your pattern matching
11:44:50 <fizruk> Berengal: thanks :)
11:44:51 <jmcarthur> samagon: or you are using view patterns or gadts or something with a version of ghc that complains no matter what you do when you use those
11:44:52 <Berengal> fizruk: When to use what is something that comes with experience.
11:44:52 <mreh> for example only matching (x:xs) with a list
11:45:03 <samagon> I get this in lambda expression...
11:45:03 <mreh> you need to consider [] too
11:46:02 <monochrom> Example of monads inside monads: do { x<-getChar; putStrLn (do {y <- [x..'z']; return (succ y)}) }
11:46:04 <Berengal> samagon: Arguments to lambdas can only have one pattern, so you have to be pretty sure you won't pass in a different constructor than the one you're matching on
11:46:11 <fizruk> @src maximum
11:46:11 <lambdabot> maximum [] = undefined
11:46:12 <lambdabot> maximum xs = foldl1 max xs
11:47:04 <mreh> monochrom: I don't know what all the fuss about Monad transformers is then
11:47:13 <mreh> all you need is some brackets
11:48:34 <Berengal> mreh: Well, just as State abstracts passing a state argument across function applications, StateT abstract passing a state argument across binds.
11:48:39 <sjw> monad transformers FTW
11:48:46 <monochrom> hehehe
11:49:11 <Berengal> mreh: Without the transformers you'd have to runState everywhere you wanted to use the state, then make sure you pass the resulting state on to the next runState
11:49:14 <monochrom> This is why evolved languages are so much fun.
11:49:16 <sjw> they are nice for build apps a bit at a time --- start with state, add error/logging later
11:49:34 <MissPiggy> Berengal I have a working crapstack!
11:49:38 <monochrom> @quote monochrom meaningful
11:49:38 <lambdabot> No quotes match. I've seen penguins that can type better than that.
11:49:45 <Berengal> MissPiggy: Yay, I guess :)
11:49:47 <MissPiggy> I just had to redibble ghci
11:50:41 <MissPiggy> so what should I do now?
11:50:43 <MissPiggy> I rtied your examples
11:51:02 <jonrafkind> basic monad question: monads must be threaded using function compostion because that is the only way to enforce a proper evaluation order. so the do notation is just syntactic sugar to achieve this?
11:51:11 <mauke> yes
11:51:13 <Berengal> MissPiggy: Did they work?
11:51:16 <MissPiggy> yes
11:51:31 <mauke> jonrafkind: do notation desugars to lambdas and calls to >> and >>=
11:51:37 <jonrafkind> right
11:51:41 <Berengal> MissPiggy: Okay. Well, basically, use the dir function to dispatch on the request path
11:52:17 <Berengal> MissPiggy: How you implement the ServerParts is up to you
11:52:29 <MissPiggy> :(
11:52:32 <sjw> jonrafkind: >>= does the ordering
11:52:33 <mreh> monochrom: evolved?
11:52:48 <sjw> more or less
11:52:50 <MissPiggy>  just need a repl in the browser is there an example of that
11:52:54 <MissPiggy> whch I can modify
11:52:55 <MissPiggy> or anything
11:53:25 <monochrom> for example English is evolved. The opposite of intelligent-designed such as most first-order-logic syntax and haskell.
11:53:31 <jonrafkind> could I bother you guys to provide a simple explanation of what arrows are? I read about them online but I didn't get it
11:53:54 <monochrom> Really, "monads inside monads" means a million things, which is another way to say it means nothing.
11:54:05 <samagon> http://pastebin.ca/1801896  <- this is the code where I get the non-exhaustive pattern in lambda expression error
11:54:15 <samagon> what is wrong there?
11:54:19 <geekagent> jonrafkind: think of an arrow as a generalization of a monad.
11:54:21 <Berengal> jonrafkind: Arrows, put simply (and wrongly) are just things that take some input and return some output
11:54:22 <djahandarie> Is there a parallel parsec?
11:54:57 <djahandarie> There is one called "parsek" noted on the wiki, but it is a dead link
11:55:03 <mreh> Berengal: that's exactly what they are
11:55:04 <djahandarie> And I can't find it
11:55:04 <jonrafkind> isnt the generalzation of a monad just a functor? (in terms of category theory)
11:55:14 <mreh> jonrafkind, read the Arrow paper
11:55:19 <Berengal> mreh: It's the truth, but not the whole truth
11:55:20 <mreh> it's on the wiki
11:55:29 <monochrom> So if you notice you're arguing "just add more brackets" but other people are like "need transformers", maybe you should think this is the result of having a million meanings.
11:55:40 <Berengal> There's stuff like laws and.. stuff
11:55:42 <Dan> monochrom - I'm getting an error: The export item `module Useful.Dictionary' is not imported ?
11:55:58 <sjw> samagon: maybe in the \[y]?
11:56:04 <monochrom> Dan: In Useful, you have to import Useful.Dictionary too.
11:56:09 <Dan> ah ok
11:56:09 <Dan> thanks
11:56:10 <mreh> what's the original Arrow paper, 2000 is the year
11:56:11 <jonrafkind> ok I see the papers.. ill read them
11:56:15 <jonrafkind> hughes?
11:56:18 <MissPiggy> Berengal *cry*
11:56:21 <geekagent> jonrafkind: Yeah, specific questions about the arrow paper would be easier to answer.
11:56:25 <jonrafkind> ok
11:56:40 <Berengal> MissPiggy: Hang on...
11:56:46 <Berengal> @paste
11:56:46 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:56:54 <sjw> samagon: if you pass it a list with 0 or >1 args it will break
11:56:56 <MissPiggy> http://gitit.net/img/logo.png that is cute
11:57:02 <samagon> um... lambda takes [CVar] and I need Cvar, so I just take value out of the list
11:58:15 <mreh> jonrafkind, yes Hughes was the first to propose them, something about LL Parsers, but you can skip that part without missing a good introduction to Arrows
11:58:16 <sjw> > (\[x] -> x) [1 .. 10]
11:58:17 <lambdabot>   * Exception: <interactive>:1:146-154: Non-exhaustive patterns in lambda
11:58:34 <Berengal> MissPiggy: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7677#a7677
11:59:07 <Berengal> MissPiggy: The top part is the beginning of a library I'm writing. The bottom part is an example of how to use it. If that helps
11:59:38 <Berengal> MissPiggy: A REPL might very well be possible with something like that
12:00:45 <Berengal> (I'm also a bit stuck on the semantics of running multiple continuations, so feedback appreciated)
12:01:20 <roboshibby> any of you guys like The Office?
12:01:35 <aavogt> they don't program haskell in the Office
12:01:37 <aavogt> or do they?
12:01:53 <roboshibby> no but jim did make a macro to replace "dwight" with "diaper"
12:02:17 <MissPiggy> I played your number game
12:02:23 <MissPiggy> cool
12:02:48 <MissPiggy> `vsrrrr
12:02:50 <roboshibby> it's hilarious when michael goes to nyc, heads down into the subway, and comes back up quickly remarking "there's a guy pooping in a cardboard box"
12:03:10 <MissPiggy> roboshibby I used to like that show about 10 years ago
12:03:18 <roboshibby> it was on 10 years ago?
12:04:08 <roboshibby> i just came across it this past fall :P
12:04:15 <MissPiggy> ;)
12:04:15 <roboshibby> been watching reruns -- all new to me
12:04:34 <MissPiggy> Berengal I haevn't a clue how to do this but maybe ti will become clear soon
12:04:43 <roboshibby> it's the only thing i watch besides man vs wild when i happen to catch it
12:04:48 <jpcooper> hello
12:04:49 <fizruk> @src and
12:04:49 <lambdabot> and   =  foldr (&&) True
12:04:52 <Berengal> MissPiggy: Feel free to ask about details
12:05:01 <jpcooper> could someone tell me how to convert a Ratio Int to a float?
12:05:04 <MissPiggy> well I just want a repl :[
12:05:18 <roboshibby> what's a ratio int?
12:05:27 <mauke> jpcooper: try realToFrac
12:05:33 <mauke> if that doesn't work, I'll have to think
12:05:43 <Saizan> ?type realToFrac :: Ration Int -> Float
12:05:45 <lambdabot>     Not in scope: type constructor or class `Ration'
12:05:51 <Saizan> ?type realToFrac :: Ratio Int -> Float
12:05:52 <lambdabot> Ratio Int -> Float
12:05:52 <jpcooper> thanks
12:05:59 <jpcooper> @hoogle realToFrac
12:06:00 <lambdabot> Prelude realToFrac :: (Real a, Fractional b) => a -> b
12:06:00 <Berengal> MissPiggy: forever $ readInput >>= eval >>= printOutput
12:06:21 <MissPiggy> huh???
12:06:31 <Berengal> That's a REPL
12:06:35 <Berengal> Read-eval-print-loop
12:06:37 <jpcooper> that works, thanks
12:06:38 <MissPiggy> in the web ?
12:07:54 <Berengal> Well, I'd probably write it something like "repl = foreverFrom "hello" $ \output -> do { input <- prompt output; eval input}"
12:08:10 <ski> Berengal : "running multiple continuations" meaning ?
12:08:12 <Berengal> (or 'return (eval input)' if eval is pure
12:08:26 <Berengal> ski: a tree of them, possibly with duplicates
12:08:38 <ski> i'm not sure what you mean
12:08:53 <MissPiggy> Berengal if you happen to make one, even a very crude one, please tell me!!!
12:10:00 <Berengal> ski: you have a webpage with a calendar component backed by a continuation, a colour component backed by a continuation etc. When the user sends a request you need to dispatch it to the right continuation
12:10:36 <roboshibby> you guys make web sites with haskell?
12:10:38 <Berengal> MissPiggy: Give me a few minutes
12:11:12 <ski> Berengal : hm, web continuations, then ?
12:12:33 <Esteban25> @src foldl
12:12:33 <lambdabot> foldl f z []     = z
12:12:34 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
12:13:16 <Berengal> ski: Yes, that's what I've been working on.
12:13:44 <Berengal> ski: It might be easier if continuations can only live in AJAX land, because then I don't have to care about keeping around the result of previous invocations
12:14:14 * ski knows nothing about AJAX
12:15:24 <roboshibby> Berengal: what are continuations? and what are web continuations?
12:16:31 <Berengal> MissPiggy: http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7677#a7678
12:17:06 <Berengal> roboshibby: Continuations are the inverse to the state monad... ish
12:17:28 <c_wraith> as for web continuations...  look up MAWL.
12:17:44 <Berengal> roboshibby: They're functions that take a function as input, and instead of returning a result they call that function with their result
12:18:02 <roboshibby> cool!
12:18:11 <roboshibby> sounds like the mobius =)
12:18:44 <Berengal> roboshibby: Of course, this means they don't have to call the function at all, or may call the function several times, or even return the function, or store it somewhere for later retrieval
12:18:57 <roboshibby> sure
12:19:04 <roboshibby> but it's a function wiht a function argument
12:19:05 <roboshibby> essentially
12:19:23 <roboshibby> i dig
12:19:29 <Berengal> roboshibby: I'm doing the latter. When I get to a certain point in my program, I store the entire rest of it in the session and return a response. When I get a new request I load the continuation from the session and resume
12:19:31 <choffstein> Okay, I need some help.  I am having a hard time encapsulating the parts of my application that use the IO Monad and those that don't.  I am trying to generate random numbers in part of my application, and it seems like it is forcing me to throw IO around everywhere -- which tells me I am doing something very, very wrong
12:19:43 <c_wraith> It's been shown that continuations can simulate all other known forms of control flow.  (IIRC)
12:20:33 <MissPiggy> it doesn't seem to work
12:20:52 <Berengal> roboshibby: It's like a time machine. More powerful than gotos, and potentially much more dangerous as well in terms of spaghetti code.
12:21:22 <sjw> choffstein: you will need some state for the random numbers, right?
12:21:37 <sjw> what are you using?
12:21:55 <choffstein> sjw: System.Random.Mersenne MTGen is the state I am passing around
12:22:06 <ski> c_wraith : continuations & state .. or equivalently, composable/delimited continuations
12:22:12 <Berengal> choffstein: Take a look at MonadRand
12:22:24 <choffstein> Berengal: Okay, thanks
12:22:37 <Berengal> MissPiggy: What part doesn't work?
12:22:48 <MissPiggy> it doesn't get the input correctly
12:23:04 <MissPiggy> every input seems to be "
12:23:07 <MissPiggy> "" empty tring
12:23:22 <Esteban25> @src foldr
12:23:22 <lambdabot> foldr f z []     = z
12:23:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:24:25 <Berengal> MissPiggy: Ah, I forgot, prompt only returns the first word
12:24:42 <Berengal> MissPiggy: Anyway, you should be able to fix that yourself by looking at the definition of prompt
12:25:14 <ski> Berengal : what is the `Maybe (WebCont r m r)' part in `WebCont r m a' for ?
12:25:18 <Berengal> MissPiggy: Also, keep in mind it's a MonadIO, so you can liftIO Â· print anything
12:25:32 <Berengal> ski: If it's done or not. On Nothing it clears the session
12:26:31 <Berengal> ski: The session needs to be abstracted out a bit. Currently it's a little bit too deeply tied into the webCont function
12:27:08 <ski> @src ContT lift
12:27:09 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:27:21 <ski> @type \m -> ContT (\c -> lift m >>= c)
12:27:21 <lambdabot> forall a r (m :: * -> *) (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m, Monad (t m)) => m a -> ContT r (t m) a
12:28:07 <ski> hm, couldn't you replace `ContT (\c -> lift m >>= c)' with `lift m' ?
12:28:51 <Berengal> ski: Indeed I can...
12:28:53 <ski> (i.e. `lift = WebCont . lift')
12:29:01 <Berengal> I think
12:29:36 <Berengal> Wait, no
12:29:41 <Berengal> Infinite type
12:30:08 <choffstein> Berengal: Can I PM you really quickly about a code question?
12:30:10 <Berengal> WebCont . lift . lift works
12:30:19 <choffstein> I don't want to spam the chat with some code
12:30:21 <Berengal> choffstein: Sure, but why not ask here?
12:30:24 <Berengal> use
12:30:26 <Berengal> @paste
12:30:27 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:30:31 <Berengal> For code
12:30:35 <choffstein> perfect, thanks
12:31:01 <ski> Berengal : hm .. the type above seems to agree with you .. but i don't see it, yet
12:31:09 <ski> oh, right
12:31:18 <ski> you already had a `lift' call in there
12:31:29 <Berengal> ski: I'm considering limiting it to ServerPartT IO though
12:31:56 <Berengal> I don't see a reason why it should be anything else, but then again there's no reason it shouldn't be
12:31:57 <ski> `WebCont' ?
12:32:12 <Berengal> Yeah
12:32:29 <Berengal> I've only found ways of running ServerPartT IO's, not arbitrary ServerPartT m's
12:32:44 <ski> well, keeping it abstract makes it not depend on `m' being `IO', i suppose
12:32:47 <Berengal> I'm probably mistaken
12:32:51 <choffstein> Can someone explain to me why my 'mutate' method in instance Mutatable is expecting to return (IO b) instead of just b?  http://moonpatio.com/fastcgi/hpaste.fcgi/view?id=7679#a7679
12:33:21 <ski> maybe there could be `ServerPartT (FooT IO)', for some user-given `FooT' ?
12:33:36 <lament> choffstein: probably because of the whole "do" thing
12:33:46 <Berengal> ski: Yeah. I'll just keep it abstract I think
12:33:47 <ski> (not really sure, since i don't know your code)
12:33:50 <choffstein> lament: I am a haskell idiot -- just started learning this week
12:34:05 <lament> choffstein: you need to learn what do notation does
12:34:07 <Berengal> ski: Heck, even I don't know my code...
12:34:08 <choffstein> lament: I thought that by doing <-, I was getting the regular type back instead of IO type
12:34:20 <lament> choffstein: "do 1" is very different from "1"
12:34:28 <lament> choffstein: correct, but it's not what the whole thing returns.
12:34:33 <ski> Berengal : we're all doomed. DOOMED i tell you :)
12:34:43 <lament> choffstein: b is regular type, but "do b" is not.
12:34:44 <Berengal> choffstein: You only get it out because you promise to put it back in later
12:34:46 <choffstein> lament: Right, right.  Okay, that makes sense
12:35:00 <Berengal> choffstein: You're not doing that, so it complains
12:35:05 <choffstein> Alright, back to the drawing board then.
12:37:06 <sjw> choffstein: what is the Mutatable class attempting to capture?
12:38:17 <sjw> something like 'give me a random number at this type'?
12:38:50 <choffstein> sjw: basically, how the elements of a genome mutate.  So if my genome is made up of characters, I am making it so that I can just call 'map mutate' on my genome and have all the individual elements mutate
12:39:26 <mao> Hey guys
12:39:34 * sjw doesn't know how elements of the genome mutates :)
12:39:57 <ski> you'd probably need something closer to `mapM mutate'
12:40:38 <ski> @type System.Random.Mersenne.random
12:40:39 <lambdabot> Couldn't find qualified module.
12:40:52 <mao> Do you recommend using http://hpaste.org
12:40:53 <mao> ?
12:40:54 <mreh> chosffstein: your GA is basically a HOF, a framework if you may, you get the user to supply a function that mutates a type of "Genome a"
12:41:38 <Berengal> mao: Not right now I do
12:41:48 <choffstein> mreh: That is an interesting idea...
12:42:04 <mao> Berengal: heh
12:42:16 <Berengal> @paste
12:42:16 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
12:42:19 <ski> mao : you may use that, yes .. or <http://moonpatio.com/>, or `<http://paste.lisp.org/new>' or ..
12:42:21 <Berengal> That one works
12:42:31 <mao> thanks
12:42:37 <ski> (.. though hpaste appears to be down, atm)
12:43:51 <sjw> choffstein: you could do mutate :: Monad m => (a -> m a) -> Genome a -> m (Genome a)
12:44:25 <sjw> where the first argument tells you how to mutate something of type a
12:44:49 <choffstein> sjw: Maybe I haven't really understood Haskell, but doesn't that propagate the Monad m throughout the system if I return m (Genome a)?
12:44:50 <ski> @type Data.Traversable.mapM
12:44:50 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
12:44:54 <sjw> the monad part lets the function access some state accross calls
12:45:30 <sjw> things tend to become less monadic the further down you get
12:45:59 <Esteban25> @src even
12:46:00 <lambdabot> even n = n `rem` 2 == 0
12:46:01 <sjw> so at the top you have IO for interacting with the world, down the bottom you have map and foldl etc
12:47:22 <choffstein> sjw: okay, thanks.  I'll chew on it.  It seems that I would end up passing around lots of m (Genome a)s...
12:48:08 <mao> http://5z8.info/banned-in-the-US_u6n2_5waystokillwithamelon Oh wow
12:48:14 <mao> that's crazy man!
12:48:40 <MissPiggy> mao: that is last measure
12:48:45 <sjw> choffstein: well, you don't have much choice --- if you want the random seed to persist between calls to mutateGenome
12:48:47 <mao> MissPiggy: ...no?
12:48:53 <mao> its' not
12:48:54 <MissPiggy> mao yes it is
12:49:22 <mao> no..
12:49:27 <MissPiggy> mao it is
12:49:28 <Asztal> it would appear to be, though I don't really want to take noscript off to find out
12:50:00 <choffstein> sjw: Okay, thanks.  I think I need to look at a larger Haskell project to see how things are actually done in application, and not just toy examples in a book
12:52:07 <roboshibby> mao, you fucking asshole
12:52:09 <roboshibby> why did you do that
12:52:22 <sjw> choffstein: good luck :)  If you haven't done much FP before the itch to be stateful is hard not to scratch
12:52:41 <choffstein> sjw: Well, I did SML in school about two years ago
12:53:05 <sjw> it is too easy to cheat in SML :)
12:53:27 <MissPiggy> monochrom?
12:54:06 <chrissbx> What's the best way to check for an integer to be zero, negative or else?
12:54:30 <Asztal> > compare 0
12:54:31 <lambdabot>   {-3->GT;-2->GT;-1->GT;0->EQ;1->LT;2->LT;3->LT}
12:54:43 <jmcarthur> :t (compare, signum)
12:54:43 <lambdabot> forall a a1. (Ord a, Num a1) => (a -> a -> Ordering, a1 -> a1)
12:55:07 <chrissbx> heh, thanks
12:56:03 <choffstein> sjw: Hey, at least I am _trying_ to see the light!
12:56:20 <choffstein> Its a horrible, awful mess at the moment -- but I am sure it will all clear up very soon
12:56:23 <jmcarthur> it's worth it
12:57:12 <shapr> Can I build-depends: on a particular version of alex?
13:00:09 <gwern> so, there are 4 instances of Monoid html
13:00:50 <gwern> shapr: not currently. alex doesn't do the library/executable split, so you can't use the trick of depending on the library & really using the executable
13:00:59 <gwern> and cabal doesnt' track executables at all
13:01:04 <gwern> much less their version
13:01:21 <Berengal> Isn't there a build-tools or something?
13:01:23 <shapr> Too bad, attoparsec requires alex > 2.2
13:01:24 <Berengal> other-dependencies?
13:01:46 <gwern> Berengal: mm, not that I heard of, but dcoutts is always adding stuff
13:02:08 <shapr> The current version of attoparsec requires whatever version of alex has AlexWrapper-strict-bytestring
13:02:13 <shapr> And alex 2.2 does not
13:06:53 * hackagebot upload: darcs-beta 2.3.99.2 - a distributed, interactive, smart revision control system (ReinierLamers)
13:09:01 <chrissbx> Is there an operation to do mod and div at the same time? (For efficiency)
13:09:09 <mauke> :t divMod
13:09:10 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
13:09:19 <chrissbx> thanks!
13:14:11 <Botje> @src divMod
13:14:11 <lambdabot> Source not found. I feel much better now.
13:14:58 * jmcarthur is curious about how much performance benefit there actually is between divMod and separate div and mod
13:15:03 <choffstein> What would be the best way for me to split a list into two parts -- especially if I want to split at a random location?
13:15:13 <jmcarthur> is divMod a primitive op on x86 or anything?
13:15:41 <jmcarthur> choffstein: the *best* would be to use something besides a list for that sort of thing in the first place. second best might be splitAt
13:15:44 <jmcarthur> :t splitAt
13:15:45 <lambdabot> forall a. Int -> [a] -> ([a], [a])
13:16:00 <jmcarthur> but splitAt will be O(n) since it's a linked list
13:16:04 <Botje> jmcarthur: the IDIV instruction can do integer division with remainder
13:16:15 <jmcarthur> Botje: ah, thanks
13:16:40 <choffstein> jmcarthur: Normally in any other language I would just use an array of sorts.  What would the Haskell way?
13:17:17 <jmcarthur> choffstein: well, we do have arrays (a spiffy new Data.Vector in addition to the stock Array type), but that's still not ideal (nor is it ideal for imperative languages)
13:17:31 <jmcarthur> choffstein: Data.Sequence can give you O(log n) split, i think
13:17:45 <choffstein> jmcarthur: thanks, I will check it out
13:18:33 <jmcarthur> choffstein: it's O(log(min(i,n-i))) according to the docs
13:18:41 <jmcarthur> choffstein: i think i is the index of the split
13:19:01 <choffstein> that makes sense -- it will either look from the front or the back.
13:19:19 <jmcarthur> choffstein: and if you like Data.Sequence you would love the fingertree package. will blow your mind ;)
13:20:02 <choffstein> what happens if I need to mapM over a Seq though?  Damnit, I suck at Haskell.
13:21:03 <jmcarthur> choffstein: Seq is an instance for Foldable and Traversable ;)
13:21:21 <choffstein> P.S. I am really sorry for all the stupid questions today guys.
13:21:29 <jmcarthur> these aren't stupid questions
13:21:36 <jmcarthur> :t Data.Traversable.mapM
13:21:37 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
13:22:20 <choffstein> Hey, that worked perfectly!  Thanks
13:22:25 <jmcarthur> np
13:23:21 * Provenzano is now away, auto away after 15mins idle (log\on pager\on)
13:23:44 <jmcarthur> this is even better efficiency than splitting a mutable array in an imperative language :)
13:23:47 <mauke> Provenzano: no away announcements, please
13:23:53 <jmcarthur> or in any language, rather
13:24:01 --- mode: ChanServ set +o monochrom
13:24:27 --- mode: monochrom set +b *!*@*.evad.in
13:24:33 --- kick: mao was kicked by monochrom (mao)
13:24:39 --- mode: monochrom set -o monochrom
13:25:53 * sinelaw removes channel operator status from sinelaw
13:26:17 * monochrom removes clothes from lambdabot
13:26:32 * sinelaw removes monochrom from lambdabot
13:27:05 <mauke> @time mauke
13:27:08 <lambdabot> Local time for mauke is approximately 22:26
13:27:54 <choffstein> If I want to define a function within a function, can I define its type above it?
13:27:55 <ski> @time lambdabot
13:27:56 <lambdabot> I live on the internet, do you expect me to have a local time?
13:28:07 <ski> choffstein : yes
13:28:14 <choffstein> ski: Thanks
13:28:41 <jmcarthur> that's something i've only just recently started doing
13:28:54 <jmcarthur> after realizing that a lot of my code is unreadable
13:29:07 <ski> (but if it's using parameters from the outer function, then you might need PatternSignatures (or what they've renamed that into))
13:29:29 <jmcarthur> ScopedTypeVariables or something like that?
13:29:36 <ski> aye
13:29:58 <ski> (you can also use the ugly `foo :: forall a b. ..a..b..' syntax)
13:30:18 <jmcarthur> which i believe is required by ScopedTypeVariables anyway
13:30:33 <ski> yes, it enables both things
13:30:55 <jmcarthur> wait, maybe i don't know the "other" thing?
13:31:01 * jmcarthur checks docs
13:31:17 <ski> for sillyness sake, consider
13:31:21 <choffstein> Does an internal function have access to variables defined in the function containing it?
13:31:30 <Botje> yep
13:31:37 <choffstein> Thanks
13:31:54 <ski>   silly :: (a -> b -> c) -> (a -> [b] -> [c])
13:32:18 <ski>   silly f a = map siller
13:32:22 <ski>     where
13:32:38 <ski>     sillier b = f a b
13:32:51 <ski> if you want to add the type signature
13:33:00 <ski>     siller :: b -> c
13:33:10 <ski> to this, then it will not work, outright
13:35:01 * ski just checked in GHCi, to see if he remembered correcttly
13:35:36 <ski> this is because the `b' and `c' in `sillier :: b -> c' will be implicitly quantified as `sillier :: forall b c. b -> c'
13:35:47 <jmcarthur> right
13:35:57 <ski> but what we want here is to let both those be the same as in the type signature of `silly'
13:36:26 <ski> (in some cases, one might still want to have some of the type variables in `sillier's type signature be quantified at that point)
13:36:34 <ski> so, what one can do, is to either say
13:36:44 <ski>   silly :: (a -> b -> c) -> (a -> [b] -> [c])
13:36:57 <ski>   silly f a :: [b] -> [c] = map sillier
13:37:01 <ski>     where
13:37:09 <ski>     sillier :: b -> c
13:37:13 <ski>     sillier b = f a b
13:37:15 <mauke> does that parse?
13:37:43 <jmcarthur> eek. i think i prefer the forall syntax
13:37:53 <c_wraith> doesn't the scoped type variables extension work with this?
13:38:02 <ski> this way, the type variables `b' and `c' are bound in the equation defining `silly', and so are in scope in the type signature for `sillier', so that they don't get to be implicitly quantified, there
13:38:30 <choffstein> If I have two lists of the same length (though the length is arbitrary) and want to concatenate every other element from each list, what would be the best way (i.e. element 0 from list 1, element 1 from list 2, element 2 from list 3, etc)?  Zip the lists together somehow and then alternate between choosing the front or back element?
13:38:42 <ski> if you eta-expand `silly', you could instead write
13:38:47 <mauke> list 3?
13:38:55 <ski>   silly f a (bs :: [b]) :: [c] = map sillier bs
13:38:56 <mauke> you said you had two lists
13:38:58 <sshc> if I have nested pattern matching such as "(Just (Wrapper x))", is there a way I can refer to "fromJust x" in the pattern match itself?
13:38:59 <jmcarthur> choffstein: you want to interleave them?
13:39:08 <sshc> could I accomplish this by using as-patterns?
13:39:25 <Heffalump> choffstein: I'd write a recursive function that called itself with the list arguments swapped
13:39:31 <Berengal> sshc: ViewPatterns
13:39:31 <choffstein> jmcarthur: not quite, I don't think.
13:39:32 <c_wraith> (Just jx@(Wrapper x))
13:39:36 <ski> c_wraith : yes, this is the (formerly) `PatternSignatures' part of `ScopedTypeVariables'
13:39:40 <choffstein> Heffalump: Ah, that makes perfect sense!
13:39:46 <Heffalump> (you said you have two lists, and then talked about lists 1,2,3, so I'm not quite sure what you mean, though :-)
13:40:09 <Berengal> sshc: Or is that what you're already using?
13:40:11 <jmcarthur> choffstein: foo [1,2,3] [4,5,6] = [1,4,2,5,3,6]  ?
13:40:23 <ski> the other part/variant is to simply change the type signature of `silly' to
13:40:33 <ski>   silly :: forall a b c. (a -> b -> c) -> (a -> [b] -> [c])
13:40:38 <choffstein> jmcarther: foo [1,2,3] [4,5,6] = ([1,5,3], [4,2,6])
13:40:38 <sshc> c_wraith: in that, jx refers to the unwrapped value
13:40:48 <ski> (maybe you can omit the quantification for `a' there, i'm not sure)
13:40:50 <sshc> c_wraith: it's kind of the oppisite of what I want
13:40:59 <sshc> c_wraith: s/unwrpaped/wrapped/
13:41:18 <Botje> choffstein: zipWith3 curry (cycle [fst, snd]) list1 list2
13:41:20 <ski> this also causes `b' and `c' (and `a') to be in scope of the clauses of `silly'
13:41:26 <jmcarthur> ski: i think you can. the forall just puts things into scope for the definition
13:41:35 <ski> but i'm not really fond of this style
13:41:42 <choffstein> Botje: Woah.  Okay, thanks.
13:41:43 <jmcarthur> but is not required for variables you don't refer to later
13:41:44 <ski> it seems backwards, somehow
13:41:53 <Berengal> sshc: What do you want to be bound to x if called with "Just (Wrapper 5)"?
13:41:59 <jmcarthur> i think i can see why you see it that way
13:42:19 <Botje> > zipWith3 curry (cycle [fst, snd]) [1..10] [21..30]
13:42:20 <lambdabot>   [1,22,3,24,5,26,7,28,9,30]
13:42:22 <sshc> Berengal: 5
13:42:33 <ski> if i write `silly :: forall a b c. (a -> b -> c) -> (a -> [b] -> [c])', then i expect `a',`b',`c' there to only be in scope in the part of the type that the `forall' scopes over
13:42:39 <Berengal> sshc: Then "Just (Wrapper x)" works :)
13:42:54 <ski> cf. `(forall s. ST s a) -> a', here `s' is only in scope in a part of the type
13:42:57 <Botje> choffstein: i'm a bit shocked it works, myself :)
13:43:11 <Berengal> > (\Just (Just x) -> x) (Just (Just 5))
13:43:12 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
13:43:21 <Berengal> > (\(Just (Just x)) -> x) (Just (Just 5))
13:43:22 <lambdabot>   5
13:43:30 <sshc> Berengal: thanks!
13:43:53 <ski> i would prefer if either (a) using `forall' like above does *not* bring the variables in scope in the definition - but leaving out the `forall' *does* ! (i think this would possibly be breaking backwards-compatibility)
13:44:02 <ski> or, (b), allow a syntax like
13:44:14 <ski>   forall a b c.
13:44:22 <ski>     silly :: (a -> b -> c) -> (a -> [b] -> [c])
13:44:25 <mauke> heh. "possibly".
13:44:31 <ski>     silly f a = map sillier
13:44:33 <ski>       where
13:44:40 <ski>       sillier :: b -> c
13:44:45 <choffstein> Botje: Its pretty cool
13:44:46 <ski>       sillier b = f a b
13:44:52 <Twey> http://paste.lisp.org/display/95209 â€” halp?  Can't install happstack-server due to conflicting dependencies
13:45:11 <ski> this way, it is clear that the `forall a b c.' scopes both over the type signature and the definition
13:45:19 <MissPiggy> Twey I deleted ghc and cabal and reinstalled everything then happstack worked
13:45:40 <Twey> MissPiggy: Did that, no luck
13:45:40 <ski> (also, remember that you don't have to put the type signature close to the definition .. you can even put a type signature on many operations, all at once)
13:45:49 <MissPiggy> oh :(
13:45:53 <Twey> MissPiggy: (managed to get HXT installed that way, though)
13:46:01 <dolio> ski: I don't think you can omit variables in the quantification anymore (if you ever could). It assumes that if you're using an explicit forall, you're going to declare all the variables you use.
13:46:24 <ski> dolio : i was suspecting that
13:46:31 <augustss> howdy
13:46:40 <ski> evening, augustss
13:46:42 <Berengal> Twey: Mess with the cabal file to remove the QC dependency. Also, my happstack-server doesn't depend on QC at all
13:46:58 <Twey> Berengal: Won't that break it?
13:47:20 <Berengal> Oh, happstack-util...
13:47:35 <Twey> Yeah
13:47:36 <Berengal> Twey: Possibly not. Make sure you're not compiling the tests :P
13:48:10 <jmcarthur> there should be a test-depends and test-executable or something like that, and a new cabal command: cabal test <package>
13:48:20 <Berengal> Where does the tagsoup dependency come from?
13:48:25 <jmcarthur> although i guess flags can cover this anyway
13:48:39 <Berengal> jmcarthur: Not satisfiably
13:48:48 <jmcarthur> no, not ideally
13:48:57 <jmcarthur> some built in support would be very nice
13:49:27 <Lemmih> What is 'darcs send' in git-speak?
13:49:48 <Berengal> Anyone got a quick reverse-dependency computron expression handy?
13:50:12 <Twey> Lemmih: git push?
13:50:20 <jmcarthur> git send-email?
13:50:26 <jmcarthur> never used it
13:50:32 <jmcarthur> send-email, that is
13:50:57 <Twey> Berengal: Hmmâ€¦ how would I do that?  I need to install as many dependencies as I can, then get the tarball?
13:51:17 <Berengal> Twey: cabal unpack ftw!
13:52:09 <theorbtwo> Can you have a polymorphic type for an element of a record type?  data Key = Key {version :: (Num a) => a} gives me "Illegal polymorphic or qualified type: forall a. (Num a) => a In the definition of data constructor `Key' In the data type declaration for `Key'"
13:52:12 <mreh> could someone explain how "integral" in Yampa works, I haven't found a sufficient explanation
13:52:38 <jmcarthur> i don't know for sure, but doesn't it just sample and add over time?
13:52:38 <mreh> all I can think is that it calculates the are of a trapezium
13:52:42 <Berengal> theorbtwo: The short answer is "yes". The helpful answer is "Don't put constraints in data declarations"
13:53:05 <mauke> theorbtwo: that looks like an existential type
13:53:09 <mauke> requires a language extension
13:53:42 <mreh> jmcarthur: that wouldn't approximate well, but it makes sense, it sounds quite computationally intense though
13:53:44 <Berengal> theorbtwo: The questioning answer is "Do you want 'data Key a = <stuff with a>', or do you want to explicitly not care what 'a' is in any of the values, as long as it's of a certain class?"
13:53:56 <Twey> Berengal: Ooh
13:54:04 <jmcarthur> mreh: depends how expensive it is to sample
13:54:12 <theorbtwo> I don't really care what a is, so long as it can store 1.1.
13:54:26 <jmcarthur> mreh: i believe yampa actually exposes the sampling period in its interface, and it's not extremely fine iirc
13:54:30 <mauke> theorbtwo: how are you going to store 1.1 in an Int?
13:54:52 <theorbtwo> Yeah.  "Num" wasn't right in the first place, it should have been Fractional.
13:54:58 <mreh> jmcarthur: where? in reactimate?
13:55:02 <Berengal> theorbtwo: Store, or convert (using fromInteger)?
13:55:04 <mauke> theorbtwo: can't you just use Rational?
13:55:09 <Berengal> or fromRational...
13:55:10 <jmcarthur> mreh: i dunno. i remember reading a paper about it
13:55:17 <theorbtwo> I'm about to, I think.
13:55:35 <mreh> as far as I can see it just recalculates as and when
13:56:10 <jmcarthur> mreh: when i say "exposes" i just mean you have to make sure that the signal you are integrating over doesn't vary too fast for the sampling rate
13:58:04 <copumpkin> can someone kick HPHCAGLHL?
13:58:18 <copumpkin> (auto pm link to "sexy galleries" on join channel)
13:58:25 * theorbtwo was trying to not use a specific type where a class of them would do... but it seems to not be worth the effort in this case.
13:59:24 <copumpkin> mauke: did it work?
13:59:28 <mauke> no
13:59:37 <copumpkin> hm, maybe it checks how long you've been connected too
13:59:41 <mreh> I don't get any of these auto pms
13:59:52 <mauke> HPHCAGLHL: how would you pass the turing test?
13:59:53 <copumpkin> maybe you have +r or whatever the flag is?
14:00:04 <copumpkin> mauke: check its /whois :P
14:00:10 <mauke> I did
14:00:22 <copumpkin> I guess pussy is a reasonable username
14:00:35 <mauke> better than root
14:00:35 <theorbtwo> Gaaaah.  "key: key.hs:(40,0)-(41,33): Non-exhaustive patterns in function versionNumberToRational"
14:00:49 <gwern> copumpkin: or pussy-in-boots
14:00:54 <theorbtwo> Can't you tell me *what* the argument is that isn't matched?
14:01:00 <theorbtwo> (Yes, it is a Show.)
14:01:05 --- mode: ChanServ set +o monochrom
14:01:24 * Hunner found a way to understand monads: Pretend like you understand them until you get confused. Eventually you will be confused less and less
14:01:27 <copumpkin> http://snapplr.com/x03q
14:01:33 <mreh> how does one gen entrusted with operator status on here?
14:01:40 <copumpkin> mreh: by being super l33t
14:01:45 <mreh> :(
14:02:09 * mreh is not super 133t
14:02:12 <mauke> copumpkin: is that a *@$% screenshot? OF A CHAT TEXT PROTOCOL?
14:02:13 <Berengal> Hunner: Alternative: Pretend like you understand them until you get confused. Pretend you're not confused.
14:02:31 <copumpkin> mauke: I have screenshot + upload one key combo away, so I often do that :P
14:02:40 <mreh> monads: do not try, only do
14:02:47 <jmcarthur> Hunner: just don't understand them. it's not necessary
14:02:51 <mauke> oh the humanity
14:03:01 <jmcarthur> oh the huge manitee
14:03:03 <ulfdoz> Aber für Audio ist streaming im großen und ganzen schon fast geklärt. Da kommt wohl 'ne kleine WLAN-fähige Mediabox ran. Nur ein Produkt mit 802.11n für einen vernünftigen Preis fehlt mir noch. Digitalausgang an verstärker gekabelt und fertitsch.
14:03:10 <ulfdoz> ewin, sorry.
14:03:11 <gwern> oh the poor manatees!
14:03:22 <jmcarthur> oh i can't spell
14:03:58 <ulfdoz> ngtd
14:05:51 <roboshibby> ulfdoz: what was that chicken scratch?
14:05:59 * ski supposes another interpretation would be `data Key = Key {version :: forall a. (Num a) => a}'
14:06:05 <roboshibby> looked like you set your cat on your keyboard
14:06:20 <mreh> roboshibby, it was German
14:06:22 <ski> (but maybe mauke already covered that, implicitly)
14:06:37 <ulfdoz> roboshibby: An accident.
14:06:37 <roboshibby> mreh, German? that's still around?
14:06:44 <mreh> I still don't understand the existential qualifier
14:06:56 <ski> mreh : where ?
14:06:57 <mreh> roboshibby, yes, you're on the cusp of racism
14:07:02 <copumpkin> mreh: that's universal
14:07:17 <roboshibby> mreh, easy there silver. i think you're assuming quite a lot douche
14:07:18 <mreh> copumpkin, why does it need to be there?
14:07:27 <copumpkin> mreh: it's saying you want a polymorphic value
14:07:32 * ski idly wonders whether there's a philosophical school named "universalism"
14:08:02 <ski> mreh : "there" being ?
14:08:06 <Berengal> ski: I thought that was a religious school. I may be mistaken
14:08:20 <mreh> ski: in your type signature
14:08:35 <ski> Berengal : i was thinking re "existentialism"
14:08:37 <mreh> isn't it kind of tautologous
14:08:51 <ski> mreh : well, that's a universal quantifier, not an existential one
14:09:04 <Berengal> http://en.wikipedia.org/wiki/Universalism
14:09:14 <mreh> ski: I know, I said one thing and meant the other
14:09:23 <tensorpudding> existentialism doesn't have much to do with existential quantification
14:09:36 <ski> an "existential data type" version of `Key' would be `data Key = forall a. Num a => Key {version :: a}' .. and is completely different from the above
14:10:09 <mreh> well, excuse me!
14:10:21 * ski duly excuses mreh
14:10:39 <mreh>  I can't see the difference
14:10:48 <mreh> oh, I see the difference
14:10:49 <roboshibby> oh look, mreh and ski are playing michael scott and andy bernard from The Office
14:10:51 <c_wraith> Is there a way to tell cabal to build profiling libraries instead of erroring out when they're they're not found?
14:11:16 * mreh thinks roboshibby has nothing of value of to contribute
14:11:41 * roboshibby thinks mreh has a right to an incorrect opinion
14:11:43 <Berengal> c_wraith: Yes, rm 'rf ~/.cabal'
14:11:55 <Berengal> *rm -rf ~./cabal
14:12:04 <c_wraith> Berengal: that doesn't play well with preserving the exact versions I currently have
14:12:07 * theorbtwo boggles.
14:12:11 <ski> mreh : `data Key = forall a. Num a => MkKey {version :: a}' means that `MkKey :: forall a. Num a => a -> Key', which is more or less the same as `MkKey :: (exists a. Num a *> a) -> Key'
14:12:33 * mreh remember the advice he was given about feeding trolls as a child
14:12:48 <ski> mreh : otoh, `data Key = MkKey {version :: forall a. Num a => a}' would mean that `MkKey :: (forall a. Num a => a) -> Key'
14:12:51 * roboshibby hopes mreh doesnt therefore starve to death
14:13:00 <MissPiggy> roboshibby stop it!!!!!!!!!!!
14:13:10 <roboshibby> ?
14:13:12 <mauke> MissPiggy: s/!+/!/
14:13:23 <theorbtwo> versionNumberToRational :: String -> Rational; versionNumberToRational str = read (trace ("'"++str++"'") str)
14:13:43 <Philippa> roboshibby: I suggest you distinguish yourself from a troll or other undesirable, and fast. This channel doesn't need people who behave as you're doing
14:13:46 <theorbtwo> The trace says '1.1', so why am I getting "no parse".
14:13:56 <mauke> > read "1.1" :: Rational
14:13:57 <lambdabot>   * Exception: Prelude.read: no parse
14:14:05 <roboshibby> *yawn*
14:14:06 <mauke> because that's not how read from Rationals works
14:14:16 <mauke> > read "11%10" :: Rational
14:14:18 <lambdabot>   11 % 10
14:14:33 <Berengal> c_wraith: There may be some cabal build -profiling option. Makes sense for there to be one, at least. It's all a matter of "for PACKAGE in `ls ~/.cabal/stuff`; do tar -xzf $PACKAGE; cd $PACKAGE; cabal build -profiling; done"
14:14:34 <mreh> so you'd be indifferent to being kicked
14:14:37 <mauke> > 1.1 :: Rational
14:14:38 <lambdabot>   11 % 10
14:14:42 <MissPiggy> > read "mauke" :: Inteferrend
14:14:43 <lambdabot>   Not in scope: type constructor or class `Inteferrend'
14:14:43 <mreh> !ops
14:14:47 <roboshibby> mreh, i would. and to prove it...
14:14:48 <Berengal> c_wraith: except with real bash instead of pseudocode
14:14:48 <MissPiggy> mreh stop ;(
14:14:58 <mreh> :P
14:15:01 <tensorpudding> hmm
14:15:12 <tensorpudding> > 3.141592 :: Rational
14:15:13 <lambdabot>   392699 % 125000
14:15:16 <mreh> MissPiggy, he wasn't interested in being reasonable
14:15:20 <MissPiggy> 22 % 7
14:15:20 --- mode: monochrom set -o monochrom
14:15:44 <Philippa> mreh: what makes you think we weren't already on the case?
14:15:49 <Berengal> > read (show (pi :: CReal)) :: Rational
14:15:50 <lambdabot>   * Exception: Prelude.read: no parse
14:15:55 <ski> > toRational (read "1.1" :: Double)
14:15:55 <lambdabot>   2476979795053773 % 2251799813685248
14:16:03 <mauke> mreh: do you want to annoy as many ops as possible?
14:16:07 <Berengal> > show (pi :: CReal)
14:16:09 <lambdabot>   "3.1415926535897932384626433832795028841972"
14:16:24 <Berengal> > read "3.1415926535897932384626433832795028841972" :: Rational
14:16:25 <lambdabot>   * Exception: Prelude.read: no parse
14:16:31 <Berengal> > read "3.1415926535897932384626433832795028841972" :: Double
14:16:32 <tensorpudding> wonder if there is code which reads a list of ints as a continued fraction
14:16:32 <lambdabot>   3.141592653589793
14:16:47 <theorbtwo> ski: Yeah, as the function name suggests, this is a version number, I'd prefer to not jump through floating point.
14:16:53 <copumpkin> tensorpudding: that'd be pretty neat
14:17:04 <tensorpudding> maybe in HaskellForMath
14:17:07 <copumpkin> CReal -> [Integer] and [Integer] -> CReal
14:17:10 <mreh> this guy was trolling me, I thought I handled it pretty well
14:17:15 <ski> theorbtwo : maybe `[1,1]' would be acceptable instead of `1.1' ?
14:17:29 <mreh> implying I could kick him was probably a step too far
14:17:40 <mreh> I apologise
14:17:45 <tensorpudding> hmm, doesn't look like it
14:17:50 <mauke> oh, advanced meta-trolling
14:17:54 <MissPiggy> thanks mreh
14:18:02 <mauke> nice
14:18:22 <Berengal> mreh: /ignore
14:18:24 <mreh> I wasn't trying to be clever!
14:18:35 <mreh> yes, good advice, I'll use it in the future
14:18:46 <MissPiggy> mreh: /msg lambdabot > 2^64867-1
14:19:33 <theorbtwo> Hm.  You know what?  I can just leave it as a string, I think, and punt to later if I want to compare it with < and > instead of just ==.
14:20:00 <Berengal> theorbtwo: Version numbers are usually [EnumType]
14:20:20 <mreh> I've just had fillings done, I'm probably just irritable because of the pain
14:20:23 <Berengal> Where EnumType is usually Integer
14:21:19 <theorbtwo> Yeah.  I could wrap a data type around that, and then write a Show and a Cmp for it... but I'll save it until I need it.
14:21:26 <MissPiggy> mreh see me, I am irritable because I haven't had mine done
14:21:36 <theorbtwo> I thought this would be easy.  They max out at two components, too.
14:21:48 <mreh> MissPiggy, I might have to have a root canal :(
14:21:54 * theorbtwo thanks his mother for good teeth genes.
14:22:14 <mreh> MissPiggy: just go to the dentist now, it's worth going as soon as you can
14:24:40 <theorbtwo> Whee, the version number looks vaugely sane.  It's just *everything else* that looks wrong...
14:26:23 <ksf> @pl (\xs f -> f xs)
14:26:23 <lambdabot> flip id
14:26:33 <ksf> :t id
14:26:34 <lambdabot> forall a. a -> a
14:26:37 <ksf> :t flip id
14:26:38 <lambdabot> forall a b. a -> (a -> b) -> b
14:26:40 <ksf> zomfg
14:26:56 <mreh> ksf: id = ($)
14:27:04 <mreh> it's amazing!
14:27:11 <ksf> :t flip ($)
14:27:12 <lambdabot> forall a b. a -> (a -> b) -> b
14:27:20 <ksf> it's obfuscated.
14:27:25 <mreh> heh
14:27:36 <mreh> it's not
14:27:46 <mreh> haskell has lots of newbie padding
14:28:01 <MissPiggy> what's that
14:28:04 <Twey> It's not obfuscated.
14:28:06 <Twey> :t id
14:28:07 <MissPiggy> I could probably use some
14:28:08 <lambdabot> forall a. a -> a
14:28:14 <Twey> Consider a = b -> c
14:28:27 <mreh> MissPiggy: like all the function and operator synonyms
14:28:30 <altmattr> can anyone point me to examples of gfoldl in use?
14:28:37 <mreh> fmap = liftM = <$>
14:28:41 <Twey> :t id (undefined :: b -> c)
14:28:42 <lambdabot> forall b c. b -> c
14:28:45 <MissPiggy> mreh ahh
14:28:53 <MissPiggy> mreh yeah I am all for getting rid of stuff
14:28:57 <Twey> :t id (undefined :: b -> c) (undefined :: b)
14:28:58 <lambdabot> forall c. c
14:29:16 <mreh> MissPiggy: it means you can start programming before you understand all the theoretical mathematics
14:29:27 <mreh> uhh... pure mathematics
14:29:41 <Twey> Let's tuck them all away in a module, Acme.NewbiePadding
14:30:15 <Twey> That gets imported automatically with the Prelude unless you specify -XNotANoob
14:30:16 <midfield> hello all.  anyone care to chat about causal commutative arrows?
14:30:43 <MissPiggy> I don't have anything to say about arrows exccept I am amazed how they are suddenly trendy again
14:30:51 <Twey> Hehe
14:31:16 <midfield> i think dataflow stuff is trendy again, maybe
14:31:17 * djahandarie hasn't been around enough to notice the downfall and reintroduction of arrows
14:31:27 <mreh> how am I supposed to summon an op then?
14:31:35 * jmcarthur never noticed a downfall, really
14:31:37 <mreh> it isn't !ops
14:31:41 <Botje> @where ops
14:31:42 <lambdabot> shapr Cale glguy dons sjanssen sorear dcoutts Saizan allbery_b dibblego conal Philippa bos arjanb psnl xerox vincenz davidhouse Heffalump kosmikus wli Pseudonym Igloo musasabi quicksilver monochrom
14:31:44 <MissPiggy> mreh, not by using an annoying command like that
14:31:44 <Botje> like that :p
14:31:45 <jmcarthur> mreh: @where ops
14:31:51 <jmcarthur> Botje: ugh
14:31:54 --- mode: ChanServ set +o xerox
14:31:56 <MissPiggy> or how about nobody uses @where ops because it's irritating?
14:32:03 <jmcarthur> are you just trying to be obnoxious?
14:32:07 <xerox> what?
14:32:08 <djahandarie> MissPiggy, it is pretty useful when there is an issue.
14:32:08 <ski> Botje : you needn't to actually do it now ..
14:32:20 <Botje> sigh, did i get baited? :(
14:32:20 <MissPiggy> djahandarie, I've never observedthat
14:32:24 <Botje> xerox: false alarm, sorry.
14:32:33 <xerox> oh np.
14:32:33 <jmcarthur> xerox: go back to sleep everything is okay it's just the neighbor's dog
14:32:40 <mreh> what does !ops do?
14:32:43 <sieson> I have to write an example program to show the concurrent features of Haskell in 2 weeks time.  I am thinking to write a client/server program to demonstrate this. I am new to haskell and have no idea how long it would take to do this. Does anyone have any idea?
14:32:44 <ski> nothing
14:32:44 <mauke> mreh: nothing
14:32:45 <djahandarie> MissPiggy, nothing
14:32:53 <djahandarie> Echo.. echo... echo
14:32:54 <mreh> why do I see people typing it?
14:33:07 <jmcarthur> mreh: it's a common command for bots. just not for lambdabot
14:33:13 <ski> mreh : maybe it means something to bots in other channels
14:33:20 --- mode: xerox set -o xerox
14:33:30 * theorbtwo sighs... my haskell parser is right according to the spec.  The spec just doesn't match the file.
14:33:44 <mreh> sieson: concurrent, or parallel, there is a distinction in haskell
14:33:47 <theorbtwo> (Not terribly surprising; it's a 1.0 spec and a 1.1 file.)
14:33:55 <djahandarie> theorbtwo, that is a spec issue, not a Haskell issue. ;p
14:34:05 <mreh> and I hope you haven't taken a functional programming class thinking you can teach it by reading a book concurrently with the course
14:34:22 <theorbtwo> djahandarie: Indeed, I know.
14:34:30 <sieson> mreh: I have to demonstrate the use of par and seq keywords. So I guess its parallel.
14:34:36 <ddarius> There's a distinction between concurrent and parallel in any language.
14:34:53 <djahandarie> ddarius, assuming the definitions that Haskell uses, yes. :P
14:34:58 <mreh> lol
14:35:24 <ddarius> djahandarie: These aren't Haskell terms.
14:35:39 <theorbtwo> seq has nothing to do with parallelisim, or concurrency.
14:35:43 <Berengal> sieson: Yeah, par, seq and pseq are parts of the parallel part of multithreading. It's only used to drive computation, not interaction
14:35:52 <theorbtwo> ...or I could be crazy, of course.
14:35:53 <Berengal> theorbtwo: It does a little bit
14:35:54 <mreh> theorbtwo, it does
14:35:57 <mreh> echo
14:36:07 <Berengal> But pseq is recommended
14:36:08 <mreh> echo?
14:36:16 <Berengal> echo
14:36:23 <djahandarie> ddarius, sure, but the two terms are usually interchangable in the other languages. Either way, you are right so this is a moot argument. :P
14:36:25 <Berengal> (echo?)
14:36:31 <mreh> sieson: you're opening a can of worms really, you need to know some graph reduction
14:36:49 <mreh> ...(echoo)
14:37:00 <sieson> Berengal: so the client/server idea is not good for showing the parallel features of haskell?
14:37:16 <Berengal> mreh: Not a can of worms, just some yoghurt that's a few days overdue
14:37:28 <Berengal> sieson: Not just a bad idea, but an impossible idea
14:37:37 <mreh> sieson: the textbook example program is fibs
14:37:59 <djahandarie> sieson, parallel features? Just load in some of the Data Parallel Haskell stuff and that'll be pretty impressive. ;)
14:38:30 <Berengal> sieson: Parallelism only works for pure computations, because when you're pure the order of evaluation doesn't matter as long as there are no data dependencies
14:38:34 <sieson> mreh: yeah I've seen that. But I am trying to find something that would get to a few hundred lines of code.
14:38:51 <djahandarie> sieson, normally one tries to reduce the lines of code.
14:38:53 <mreh> sieson: that's unlikely
14:39:34 <Dementati> So I tend to find it extremely hard to name functions when using a functional language. I want to define helper functions that doesn't really have a grand purpose, but can be relatively complex still, and it's difficult to come up with a concise name that properly describes its function. Suggestions?
14:39:51 <Zao> Dementati: f
14:39:55 <ddarius> Dementati: Think harder.
14:40:00 <djahandarie> Any assignment that involves meeting a line count rather than an operative goal should only involve a punch to the teacher's face.
14:40:16 <Zao> I tend to give any helper functions some silly names and put them in a `where' block.
14:40:17 <jmcarthur> Dementati: this is why we use so much math terminology ;)
14:40:18 <Berengal> sieson: One of the benefits of parallelism in Haskell is that when there _are_ data dependencies it just reduces to a sequential program. When you're dealing with explicit threads and synchronization for parallelism you're the one that has to ensure all dependencies are met
14:40:19 <sieson> mreh: I have to show how haskell can be used for some practical applications which have parallelism in them.  Is there anyway to stretch the computations?
14:40:21 <mreh> Dementati, you don't have to be concise, but annotating with the type system helps alot
14:40:28 <Zao> If I find that I need to reuse them, I focus on the name then.
14:40:55 <mreh> sieson: haskell isn't far more subtle than a lot of businessmen find convenient
14:40:55 <Dementati> mreh: I don't quite understand.
14:41:00 <mreh> or can comprehend
14:41:17 <mreh> Dementati: if you look at the type of a function you can often infer what it is that it does
14:41:24 <Dementati> mreh: Ah, right.
14:41:35 <mauke> have some random words: hemishowdown insionellia thymasy Escarupterpent stationage Chiloquy Laudlam
14:41:40 <Berengal> sieson: You could go dig in the GHC parallel test-suite. They're bound to have some interesting snippets
14:42:03 <mreh> yeah, do that
14:42:10 <mreh> don't listen to me :)
14:42:17 <sieson> Berengal: are they all about computations of short algorithms?
14:42:26 <mreh> sieson: go look at them!
14:42:34 <Berengal> sieson: I don't know. I haven't dug that far
14:42:50 <sieson> Berengal: I was thinking to write the matrix multiplication algorithm in haskell. But I am not sure if thats a good idea!
14:42:58 <Berengal> sieson: It is
14:43:04 <mreh> sieson: you can get the sources from cabal by using the "unpack" command
14:43:06 <djahandarie> sieson, I thought you weren't interested in short algorithms? :P
14:43:30 <Berengal> mreh: GHC isn't on hackage though
14:43:35 <sieson> djahandarie: I don't have a choice anymore. This demonstration has to be done in 2 weeks
14:44:07 <mreh> haskell is an expressive language, you don't need as many lines as an imperative language
14:44:46 <theorbtwo> If you can't figure out how to describe what a function does, you are splitting up your program into functions incorrectly, I'd say.
14:44:50 <mreh> the classic one-liner is the (psuedo-)quicksort
14:45:03 <Twey> It's a real quicksort!  :<
14:45:04 <sieson> mreh: but i need to somehow show that haskell can work as well as other languages and show the other newbies that they can do a lot of stuff easily. which doesn't seem to be the case for myself
14:45:20 <mreh> sieson: it's easy when you know how :)
14:45:33 <theorbtwo> A newbie, by definition, is somebody who doesn't know how.
14:45:39 <djahandarie> sieson, it seems you are unable to define the problem rather than find a solution?
14:45:41 <sieson> mreh: of course!
14:45:56 <sieson> djahandarie: what do you mean?
14:45:57 <mreh> functional programmers think differently to imperative programmers
14:46:22 <ddarius> mreh: There are programmers that are both functional programmers and imperative programmers?  Are they schizoid?
14:46:24 <mreh> sieson: how much experience do you have?
14:46:34 <medfly> ddarius, wrong term
14:46:41 <theorbtwo> Hm.
14:46:42 <mreh> ddarius: schizophrenic :)
14:46:46 <theorbtwo> :t liftM
14:46:47 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
14:46:47 <medfly> still wrong
14:46:54 <djahandarie> sieson, you dismiss most of what is already implemented concisely in Haskell as "too simple". So what would you consider applicable to a real-world problem? Find your problem then get a solution, it is easier that way.
14:46:56 <sieson> mreh: in functional programming very little. Imperative 5-6 years.
14:46:57 <theorbtwo> :t (+)
14:46:58 <lambdabot> forall a. (Num a) => a -> a -> a
14:46:59 <mreh> medfly: multiple personalities?
14:47:00 <sjw> ddarius: you just end up seeing monads everywhere
14:47:03 <Dementati> mreh: Thanks, that actually does help.
14:47:05 <medfly> good
14:47:08 <theorbtwo> How does it decide what variable names to use?
14:47:14 <theorbtwo> s/variable/type variable/
14:48:12 <mreh> sieson: it takes a while to get deprogrammed
14:48:18 <sieson> djahandarie: the problem is that I want to find some idea to implement in haskell and show how parallelism can work easier in haskell. Because I don't know the language well enough, its hard to choose a  specific problem.
14:48:37 <djahandarie> sieson, well, rather than trying to rig the assignment, choose any problem. :-)
14:48:47 <theorbtwo> I don't know much either... but matrix multipication seems like a pretty good one to me.
14:49:11 <theorbtwo> It's not *overly* complex, it's familiar (maybe), and it has plenty of oppurtunity to parallize.
14:49:12 <sieson> djahandarie: i've got 2 weeks and can't choose a risky one.
14:49:20 <Dementati> 'if x then y else z :: Type' <- Does this annotate z or the entire expression?
14:49:24 <djahandarie> Then do matrix multiplication. It's easy with DPH
14:49:41 <theorbtwo> Dementati: It doesn't matter, since z's type is also the type of the entire expression.
14:49:41 <ski> Dementati : i'm not sure, but it shouldn't matter
14:49:41 <Saizan> Dementati: the whole expression
14:49:58 <medfly> > if True then 1 else undefined
14:49:59 <Dementati> Oh, yeah.
14:49:59 <lambdabot>   1
14:50:05 <Dementati> Thanks.
14:50:15 <sieson> djahandarie: I think thats the best to do for now.
14:50:17 <sieson> Thanks guys for the help
14:51:08 <mreh> Dementati: use type synonyms for extra abstraction, like giving higher-order types names
14:51:13 <mreh> like "Geoff"
14:51:20 <cicciodarkast> hi
14:51:47 <Dementati> mreh: Yeah, that makes sense.
14:54:16 <Tim> hi
14:54:23 <Tim> i'm new here
14:54:39 <medfly> hi
14:54:57 <Tim> and i want to know, if it pays off to use leksah?
14:54:57 <Twey> Hello, Tim
14:55:04 <Twey> Does Leksah actually work?
14:56:03 <jutaro> It just takes some hours and it will work
14:57:13 <Dementati> Are type annotations not allowed in patterns?
14:57:32 <Twey> They are with the appropriate extension enabled
14:57:41 <Twey> Tim: I'm going to veer on the side of â€˜noâ€™
14:58:02 <Twey> Tim: emacs haskell-mode has come a long way lately.  I'd stick with that.
14:58:05 <mreh> you can do "do { (a :: Foo) <-  Bar }
14:58:27 <jutaro> Twey: I hate this extensions.
14:58:37 <Twey> jutaro: Why?
14:58:44 * Cale uses vim and ghci. :)
14:58:51 <Berengal> Twey: leksah isn't useless. I'd consider it if I wasn't used to emacs
14:58:56 <Cale> That's all the IDE that I need :)
14:59:01 <Twey> Berengal: I didn't think it even built
14:59:09 <Berengal> Twey: Not on 6.12 it doesn't
14:59:12 <djahandarie> Cale, no yi? :P
14:59:20 <jutaro> Twey:I mean that you have to specify it.
14:59:20 <Berengal> The latest cabal version built fine for me back in june though
14:59:31 <Twey> jutaro: Ohâ€¦ why?
14:59:34 * Berengal uses notepad and butterflies
14:59:50 <tensorpudding> whoops
14:59:52 <Twey> jutaro: Just stick a LANGUAGE pragma in your file, or the appropriate thingamibobby in your .cabal file
14:59:57 <tensorpudding> this continued fraction seems to be a bit wrong
15:00:35 <Twey> What's that?
15:00:37 <jutaro> The next Leksah will include Yi integration, but this will not work.
15:00:40 <copumpkin> ooh, you need continuation fractions
15:00:45 <copumpkin> Ratio (Cont Ratio Ratio)
15:00:47 <Twey> jutaro: Heh
15:00:49 <MissPiggy> O_O
15:00:53 <copumpkin> yeah!
15:00:56 <Twey> copumpkin: Yow
15:01:04 <copumpkin> actually
15:01:08 <MissPiggy> just what th hell is that
15:01:14 <copumpkin> Ratio (Cont Rational Rational)
15:01:20 <copumpkin> that's continuation fractions
15:01:26 <Berengal> Mu Ratio
15:01:31 <MissPiggy> @unmtl Ratio (Cont Rational Rational)
15:01:32 <lambdabot> Ratio ((Rational -> Rational) -> Rational)
15:01:38 <jmcarthur> wat
15:01:39 <ddarius> :k Mu Complex
15:01:40 <lambdabot> *
15:01:47 <MissPiggy> and how do you use it
15:01:48 <tensorpudding> oh shit continuation fractions
15:01:54 <medfly> @src Mu
15:01:54 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
15:02:00 <medfly> o.O
15:02:06 <ddarius> @src fix
15:02:06 <lambdabot> fix f = let x = f x in x
15:02:16 <ddarius> @. pl src fix
15:02:16 <lambdabot> (line 1, column 1):
15:02:17 <lambdabot> unexpected end of input
15:02:17 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:02:23 <copumpkin> MissPiggy: you need to use the codensity rational zygohistomorphic prepromorphisms
15:02:23 <ddarius> (Stupid broken @src plugin)
15:02:26 <MissPiggy> fix f = f (fix f)
15:02:29 <Tim> i will try my luck with leksah
15:03:26 <Lycurgus> ghc 6.12 was first to support dynamic linking?
15:03:35 <ivanm> Lycurgus: yes
15:03:45 <ivanm> unless you count 6.11, the development version
15:03:47 <hd> hi
15:03:49 <Lycurgus> ivanm, thx
15:03:51 <Berengal> Lycurgus: I think there were dlls on windows at some earlier point, but yes.
15:03:54 <ivanm> greeting, hd
15:04:43 <tensorpudding> stupid floating point and its rounding errors
15:05:11 <Berengal> Yeah, they should just fix the point so it stopped floating around
15:05:22 <tensorpudding> this thing seems to do all right for finding expansions of irrational numbers but it fails to terminate for some real numbers that should terminate
15:05:52 <Berengal> > fix point
15:05:54 <lambdabot>   fixedpoint
15:06:03 <sjw> awesome :)
15:06:04 <mauke> <purl> somebody said yarr was yet another rompiler rompiler or heavily patched, at least over one eye
15:06:07 <balboa02> Why is a list considered to be a non-deterministic computation? Is the statement that "[1,2,3] is simultaneously the values 1, 2 and 3" correct?
15:06:24 <Cale> balboa02: yeah
15:06:52 <sizur> hi all.  what's a lib to or how would i do prologsy stuff in haskell?
15:07:06 <Berengal> sizur: Logic
15:07:19 <HugoDaniel_> need help with monad plz: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21819#a21819
15:07:20 <MissPiggy> Logic tottaly doesn't ...
15:07:30 <Berengal> MissPiggy: Logic isn't a verb
15:07:32 <Berengal> You can't join it
15:07:37 <balboa02> Cale: Thanks
15:07:50 <MissPiggy> @hackage monadiccp
15:07:50 <lambdabot> http://hackage.haskell.org/package/monadiccp
15:07:53 <Berengal> Is there a unification monad by the way?
15:07:54 <sizur> i checked logict, but it doesnt look prologsy at all
15:08:00 <MissPiggy> prolog isn't monadic
15:08:06 <MissPiggy> logict isn't anything to do with logic programming
15:08:08 <ski> balboa02 : because of how `return' and `(>>=)' works for the list monad
15:08:08 <Cale> sizur: It's not prologsy, but you can get a lot of the same effect.
15:08:31 <Cale> It's basically a fast nondeterminism monad.
15:08:36 <sjw> didn't oleg have a paper about backtracking monads a while ago?
15:08:37 <MissPiggy> sizur, you can get idea from monadiccp & silvija seres' PhD
15:08:39 <Cale> along with a bunch of useful operations
15:09:35 <balboa02> ski: so specifically with respect to that implementation? From wikipedia I was gathering that if taken in order, then its deterministic, but in an arbitary order is nondeterministic?
15:10:42 <dolio> Several of the operations in logict are at least presented as being motivated by logic programming.
15:11:12 <dolio> Without evil things like cut.
15:11:16 <ski> Berengal : i've made one, and there's probably one on hackage
15:11:32 <HugoDaniel_> if return has type a -> m a, how do i make sure that a belongs to a given type class ?
15:11:37 <MissPiggy> I have made one too
15:11:47 <Berengal> So newtype Prolog a = LogicT UnificationMonad a
15:11:56 <MissPiggy> :/
15:12:02 <MissPiggy> not really accurate
15:12:04 <Cale> HugoDaniel_: hm?
15:12:07 * ski 's system was based on Silvia' & Seres' system, adding goal implication
15:12:10 <MissPiggy> don't call it prolog say it is something else
15:12:14 <Cale> HugoDaniel_: return is required to be completely polymorphic in a
15:12:26 <dolio> Berengal: Prolog is far more evil than that.
15:12:27 <MissPiggy> you can do better than basic prolog quite easy
15:12:32 <dolio> IO would have to be in there somewhere.
15:12:34 <Cale> HugoDaniel_: You're not allowed to put constraints on the type a when defining it.
15:12:36 <Berengal> PureProlog?
15:12:43 <ski> balboa02 : a monad is specified by a type constructor, *and* implementations of `return' and `(>>=)'
15:13:20 <HugoDaniel_> oh
15:13:20 <HugoDaniel_> ok
15:13:28 <Berengal> balboa02: Don't think of lists as nondeterministic. Just think of nondeterminism as a computational context, and lists as being part of the implementation of that context
15:13:29 <Cale> HugoDaniel_: Also, your NoiseMonad type is pretty silly
15:13:35 <HugoDaniel_> yes, it is :D
15:13:45 <HugoDaniel_> i have it working without it
15:13:59 <Cale> HugoDaniel_: The class constraint on data declarations is stupid and doesn't mean what most people expect it to.
15:14:03 <Berengal> balboa02: The lists themselves really have nothing to do with nondeterminism. They're just an artifact of the translation to a deterministic computation
15:14:05 <ski> > do c <- [0 .. 10]; b <- [0 .. c-1]; a <- [0 .. b-1]; guard (a^2 + b^2 == c^2); return (a,b,c)
15:14:06 <lambdabot>   [(3,4,5),(6,8,10)]
15:14:16 <HugoDaniel_> Cale: that was an act of despair
15:14:17 <HugoDaniel_> :/
15:14:47 <Berengal> Cale: What _does_ it mean?
15:15:00 <ski> balboa02 : that's code finding a few pythagoreas triples. read `b <- [0 .. c-1]' as "nondeterministically let `b' be any integer between `0' and `c-1'"
15:15:06 <Cale> Berengal: It simply constrains the type of data constructors which use the given type variables.
15:15:15 <balboa02> Berengal: Does that hold true abstractly for the concept of lists in general?
15:15:15 <HugoDaniel_> but i have a clear idea of what i want my noisemonad to do, and im not being able to implement it :/
15:15:23 <sizur> sounds fail.  now where is that UnificationMonad :)
15:15:35 <MissPiggy> :(
15:15:37 <sizur> i mean fair, not fail
15:15:38 <Cale> Berengal: You still have to write all the class constraints you wrote before.
15:15:49 <MissPiggy> did you even look at my suggestions
15:15:52 <Cale> HugoDaniel_: Are you certain that it's a monad?
15:16:00 <Berengal> Cale: I see
15:16:19 <sizur> MissPiggy: yeah, trying to understand monadiccp
15:16:29 <MissPiggy> sizur it has unification
15:16:30 <HugoDaniel_> Cale: no :)
15:16:31 <balboa02> ski: but they will always return in order, does that not factor in into whether it is deterministic?
15:16:47 <Berengal> balboa02: Well, lists are lists, not just in Haskell, and you can use them to implement nondeterminism in other languages too, if that's what you meant
15:16:50 <ski> Berengal : lists do have something to do with *angelic* nondeterminism .. though, yes, mostly any sequence type would do
15:17:07 <Cale> Berengal: A more sensible implementation would be to package a class dictionary along with the data, and you can get that effect in recent GHCs using GADTs or by putting the class constraints on the other side of the = sign.
15:17:11 <MissPiggy> I don't know the other type of nondeterminism
15:17:15 <MissPiggy> demonic?
15:17:17 <balboa02> Berengal: I meant more of in the abstract mathematical sense?
15:17:26 <ski> MissPiggy : yes, aka committed-choice
15:17:31 <MissPiggy> oh okay
15:17:50 <sizur> MissPiggy: so i need to read http://www.cs.kuleuven.be/~toms/Research/papers/monadic_cp_draft.pdf right?
15:17:51 <ski> balboa02 : the order in the list is unrelated to the nondeterminism (or not) here
15:18:08 <MissPiggy> Idon't know
15:18:15 <Cale> HugoDaniel_: What sort of thing are you after?
15:18:43 <Berengal> balboa02: Well, mathematicians tend to prefer sets, but you could arrive at a translation from nondeterminism to determinism via lists in mathematics too
15:18:44 <HugoDaniel_> Cale: let me try to write out an example of what i want...
15:19:04 <ddarius> There's angelic, demonic, and erratic.
15:19:17 * Berengal doesn't remember the difference
15:19:19 <ski> ddarius : "erratic" being ?
15:19:47 <balboa02> ski: ok, thanks
15:19:48 <medfly> @wn erratic
15:19:49 <lambdabot> *** "erratic" wn "WordNet (r) 2.0"
15:19:50 <lambdabot> erratic
15:19:50 <lambdabot>      adj 1: having no fixed course; "an erratic comet"; "his life
15:19:50 <lambdabot>             followed a wandering course"; "a planetary vagabond"
15:19:50 <lambdabot>             [syn: {planetary}, {wandering}]
15:19:51 <lambdabot> [9 @more lines]
15:20:07 <ddarius> Angelic is if -any- path succeeds then you get success; demonic is if -any- path fails you get failure; erratic gives neither guarantee.
15:20:11 <kuitang> Hey, could anybody explain how line 28 works in http://pastebin.ca/1802095 ?
15:20:22 <ski> (iirc, angelic corresponds to the Smyth powerdomain preorder, and demonic to the Hoare powerdomain preorder (or maybe the other way around) .. something satisfying both having the Egli-Milner powerdomain preorder)
15:20:46 <sizur> MissPiggy: thanks for the pointer :)
15:20:55 <ski> medfly : i know the ordinary meaning of the term, i was asking ddarius for the technical meaning :)
15:21:14 <balboa02> Berengal: Thanks
15:22:05 <medfly> okay
15:23:25 <ski> balboa02 : if you have a nondeterministic operation, then mathematically, you can imagine a set of all the possible results. demonic will pick anyone (assuming there is at least one), even if later things get stuck. angelic will "pick the right one (is there is one)", so that later choices always work out .. one usual way to implement this is by backtracking
15:23:37 <Cale> kuitang: "How it works?"
15:23:51 <Cale> Well, okay...
15:23:51 <ski> balboa02 : also see ddarius above
15:24:26 <twink> Isn't demonic supposed to produce no results if any thing at all gets stuck along the way?
15:24:49 <balboa02> ski: fun names - any suggested reading?
15:24:50 <Cale> (t',x) is defined as the result of  comp'' x t
15:25:06 <jao> Does 'peekCAString foo' take ownership of foo's memory, or is the contents of foo copied to create the returned String?
15:25:20 <altmattr> I am looking for a one-level version of Uniplate's transform function
15:25:21 <ddarius> There was a wonderful paper about twelve types of lambda calculi based on different variations on the semantics of non-determinism, but I can't find it anymore.
15:25:25 <altmattr> any ideas?
15:25:31 <Cale> kuitang: Of course, we don't evaluate x first
15:25:55 <ski> balboa02 : sadly, i have no idea where i picked up "angelic" and "demonic" nondeterminism
15:26:02 <Cale> kuitang: Let's try it on some specific tree.
15:26:25 <Cale> we'll start small
15:26:29 <Cale> comp' (NodeBT 1 Empty Empty)
15:26:50 <ski> balboa02 : i think Steven Vickers "Topology Via Logic" mentions the Smyth,Hoare,Egli-Milner powerdomain preorders
15:26:53 <Cale> So the result of that is equal to t' where (t',x) = comp'' x (NodeBT 1 Empty Empty)
15:27:15 * Hunner just had a flash of brilliance about why monads use m and comonads use w
15:27:22 <ddarius> There's definitely a paper (quite a few, I believe) about powerdomain semantics for non-determinism.
15:27:26 <Hunner> w is just m upside down!
15:27:26 <copumpkin> Cale: I thought of two tree structures that I don't think I can represent as fingertrees, btw
15:27:34 <balboa02> ski: Thanks. So that terminology isn't necessary ubiquitous?
15:27:43 <Cale> and we know that  comp'' x (NodeBT 1 Empty Empty) = (NodeBT (fromIntegral 1 / fromIntegral x) p1 p2, v + s1 + s2)
15:27:51 <ddarius> Hunner: Ssshh!  Don't let out the secret!
15:27:59 <ski> balboa02 : i'm quite sure i've read it in some papers on Logic Programming, but i have no idea which
15:28:01 <Twey> Hunner: Lies!
15:28:04 <ddarius> balboa02: It's pretty common.  It's used in multiple contexts.
15:28:10 <Twey> Hunner: É¯ is m upside-down
15:28:15 <Cale> where (p1, s1) = comp'' x Empty; (p2, s2) = comp'' x Empty
15:28:16 <Hunner> >_<
15:28:22 <Twey> w upside down would be more like Ê
15:28:23 <HugoDaniel_> Cale: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21826#a21826
15:28:50 <ddarius> But what would 'm' upside-down be like?
15:29:21 <Cale> So what do we know so far about x? Well, we know that it's equal to v + s1 + s2
15:29:27 <balboa02> ddarius, ski: thanks
15:30:33 <Cale> HugoDaniel_: Okay, the code you've written is blatantly a type error, however you might be able to get away with something like  p <- gen (perlin {...})
15:31:37 <HugoDaniel_> and isn't it possible to "hide" the 'gen' function ?
15:31:45 <Cale> HugoDaniel_: Right.
15:32:09 <altmattr> found my answer
15:32:10 <altmattr> @type Data.Generics.Uniplate.descend
15:32:11 <lambdabot> forall on. (Data.Generics.Uniplate.Uniplate on) => (on -> on) -> on -> on
15:32:22 <altmattr> uniplate++
15:32:44 <Cale> kuitang: Basically, x becomes more determined as you go along. In the base cases:
15:32:56 <Cale> comp'' x Empty = (Empty, 0)
15:33:05 <Cale> kuitang: x becomes determined immediately :)
15:33:55 <ski> (Cale : .. tying the knot ?)
15:34:01 <Cale> ski: yeah
15:34:39 <Cale> kuitang: But the point is that it doesn't run the thing twice, only once.
15:35:46 <ivanm> Cale: do you have any suggestions for a data structure for planar graphs where I also care about the angles between edges?  Just use a "normal" graph and do bookkeeping in the node labels storing the angles?
15:36:52 <Cale> kuitang: To do its work, it doesn't have to examine the value of x, it only needs to eventually determine x by the time that anyone looks at the value stored in the resulting NodeBT's. (evaluating the fromIntegral v / fromIntegral x will require evaluating x)
15:37:40 <nus> ivanm, possibly add more vertexes and edges?
15:37:54 <Cale> ivanm: Nothing too insightful
15:37:55 <ivanm> huh? why would I want to add even _more_ vertices and edges?
15:37:58 <ivanm> Cale: *nod*
15:38:10 <Cale> ivanm: Just store the locations of the points, and compute the angles?
15:38:48 <ivanm> Cale: hmmm... well, it's for "growing" of graphs, and some of the growths depend on what the resultant angle is...
15:39:07 <ivanm> plus posssibly doing operations like "make sure there aren't two pentagons next to each other" :s
15:39:08 <ski> Cale : you might mention that one can explicitly stage things by `comp_foo :: Fractional i => BinTree i -> (i,i -> BinTree i)' (ignoring the strange `fromIntegral's in there)
15:40:13 <HugoDaniel_> i hate monads :/
15:40:44 <nus> ivanm, I mean, generalize from the concrete vertex type, add a vertex (and an arc to it) describing the angle
15:41:00 <Cale> HugoDaniel_: What's wrong?
15:41:02 <ivanm> nus: still not following...
15:41:04 <ivanm> HugoDaniel_: why?
15:41:51 * ski wonders if kuitang is still with us in this world ..
15:41:56 * ddarius is starting to think the paper was "Non-determinism in functional languages" but doesn't know how he got it.
15:42:07 <ivanm> preflex: seen kuitang
15:42:08 <preflex>  kuitang was last seen on #haskell 21 minutes and 56 seconds ago, saying: Hey, could anybody explain how line 28 works in http://pastebin.ca/1802095 ?
15:42:47 <HugoDaniel_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21831#a21831
15:43:30 <nus> ivanm, get out of the plane...
15:43:42 <Cale> HugoDaniel_: That doesn't make any sense.
15:44:01 <HugoDaniel_> why can't i do some matching on the return ?
15:44:10 <Cale> HugoDaniel_: Because return :: a -> m a
15:44:20 <Cale> Where a is any type at all.
15:44:20 <ivanm> nus: OK, say I have a - b - c, with a 90 degree angle at b
15:44:26 <ivanm> how do you say I should record that?
15:44:30 <Cale> So you obviously can't pattern match.
15:44:35 <Cale> a could be a function type
15:44:44 <HugoDaniel_> oh, then im doomed
15:44:49 <copumpkin> DOOM!
15:44:52 <ski>   return :: forall a. a -> m a
15:44:58 <ivanm> shush, copumpkin
15:45:05 <copumpkin> :(
15:45:24 <HugoDaniel_> ok, ill try to hack around it some other way then
15:45:25 <ski> `return' is supposed to work on any type `a' the user wants to call it with
15:45:49 <HugoDaniel_> yes, seen that way i can understand why ghci is complaning
15:46:18 <HugoDaniel_> ok, thanks
15:46:39 <Cale> HugoDaniel_: Also, the NoiseMonad data declaration is still silly
15:46:52 <Cale> HugoDaniel_: You're ignoring the type parameter altogether. That can't be right.
15:46:57 <HugoDaniel_> :D
15:47:10 <Cale> Don't set out to create a monad.
15:47:18 <HugoDaniel_> is it desperate enough ?
15:47:22 <Cale> If something turns out to be a monad, then define an instance.
15:47:41 <Cale> But saying "I'm going to invent a new monad today" is usually the wrong approach.
15:47:54 <nus> ivanm, how do you represent an edge?
15:48:17 <Cale> First figure out what primitives and operations you want to support and what their types are, and check that they're implementable.
15:48:33 <HugoDaniel_> Cale: ok
15:49:22 <Cale> and if that happens to include some things with the same types as return and >>=, that's great, but if it doesn't, that's also not a big problem.
15:49:33 <ivanm> nus: I'm thinking of just having Map n [n] or something (or maybe an FGL graph... I won't be implementing this any time soon)
15:49:42 <HugoDaniel_> ok
15:49:54 <HugoDaniel_> it started because "deriving (Monad)" didn't work...
15:51:57 <Lycurgus> after the 6.12.1 compiler is built is there a need for the earlier compiler on the system?
15:53:02 <chrissbx> Is there a way to use a variable as placeholder for a constant in a pattern match? Like in let f quote = q where q (quote:str) = '\\':quote:(q str) ; q (c:str) = c:(q str)
15:53:21 <mauke> not directly
15:53:46 <mauke> but you can use a guard
15:54:05 <byorgey> Lycurgus: not particularly.
15:54:15 <Lycurgus> byorgey, thx
15:54:36 <chrissbx> mauke: a guard? Something else than just using if?
15:54:43 <byorgey> you can keep it around if you want to have it for testing etc. but once built, the 6.12.1 compiler will work fine without the old one around.
15:54:57 <mauke> q (x : str) | x == quote = '\\' : ...
15:55:29 <chrissbx> aha. Thakns
15:55:35 <ivanm> HugoDaniel_: you can't define monad; if you do a newtype though then there's an extension that will let you do so
15:55:56 <ivanm> the only types you can derive are the "simple" ones like Show, Read, Eq, Ord, Enum, etc.
15:56:01 <Berengal> ivanm: s/define/derive/
15:56:12 <Berengal> You certainly can define a monad
15:56:12 <Lycurgus> (i asked because ghc 6.12.1 announces that it "... stage 2 booted by GHC version 6.8.2" where i suppose it meant cross 'compiled by')
15:56:15 <ivanm> yeah
15:56:19 * Berengal defines monads to be puppies
15:56:27 <ivanm> Berengal: heh
15:56:29 <byorgey> Lycurgus: yep.
15:56:30 <ivanm> not burritos?
15:56:45 <Berengal> ivanm: Puppies are cuter, and they don't make me fart as much
15:57:08 <lament> you can put something in a puppy, but it's very difficult to get it back, as in the movie Snatch?
15:57:18 <Lycurgus> prolly a super cutie puppy would make you fart too
15:57:19 <byorgey> true, warm fuzzy burritos don't sound very appetizing
15:57:20 <Berengal> Something like that
15:57:20 <ivanm> but some puppies can stink all on their own without needing burritos to cause gas release
15:57:34 <byorgey> although warm fuzzy puppies don't sound appetizing either
15:57:42 <Berengal> ivanm: Yeah, but you don't need to be around to smell it
15:57:44 <ivanm> byorgey: are there any docs for diagrams online somewhere (since hackage doesn't like it)?
15:57:55 <byorgey> ivanm: yes, let me find you a link
15:57:59 <ivanm> ta
15:58:27 <byorgey> ivanm: http://code.haskell.org/diagrams/doc/html/diagrams/index.html
15:58:38 <lament> monads are like puppies - they're very cute, but they smell
15:58:39 <Berengal> ... perhaps puppies are really monad transformers, since they would readily eat a burrito.
15:59:01 <Veinor_> haha
15:59:22 <ivanm> hmmm... looks like diagrams won't suit my purposes...
15:59:25 <ivanm> thanks anyway
15:59:47 <byorgey> ivanm: out of curiosity, what are your purposes?
15:59:56 <byorgey> I'm in the middle of completely redesigning/rewriting the library
16:00:00 <ivanm> Berengal: and then in asia they get chopped up and put into new burritos? (since monad transformers create new monads...)
16:00:01 <ski> monads are like endofunctors with unit and combination natural transformations satisfying unit and associative laws
16:00:02 <sinelaw> conal, what \bibliographystyle do you use in your papers?
16:00:20 * conal looks
16:00:22 <ivanm> byorgey: I was hoping I could use it as a graph-like structure for dealing with fullerenes ;-)
16:00:29 <copumpkin> byorgey: I was wondering about the project you mentioned you were working on, with the eventual possibility of type-level number literals
16:00:49 <byorgey> ivanm: right, you will be able to do that with the new version once I finish it
16:00:55 <byorgey> but not currently
16:00:55 <copumpkin> byorgey: what would you do about the existing type called 1 from GHC's generics?
16:01:00 <conal> copumpkin: i use a combo of \bibliographystyle{plainnat} and \usepackage[]{natbib}
16:01:02 <ivanm> sinelaw: I think I'll scrap the "process multiple DotGraphs at one time" code; it doesn't seem to be working :s
16:01:05 <ivanm> byorgey: :o
16:01:08 <ivanm> byorgey++
16:01:10 <copumpkin> conal: ?
16:01:17 <ivanm> he meant sinelaw
16:01:19 <conal> oops.  for sinelaw
16:01:44 <byorgey> copumpkin: I don't know, type-level number literals are not really the point at all
16:01:44 <sinelaw> ivanm, ok, as long as it has a heritage somewhere in the virtual universe of source control.
16:01:52 <ivanm> heh
16:01:58 <ivanm> yeah, I'll just record a reverse patch
16:01:58 <copumpkin> byorgey: I know :) but they might be an eventual consequence?
16:01:59 <sinelaw> ivanm, i mean it's ok anyway, but pity to lose that work
16:02:08 <sinelaw> conal, thanks!
16:02:10 <conal> sinelaw: and two natbib settings: "\bibpunct();A{}," and "\let\cite=\citep"
16:02:17 * copumpkin is just taking advantage of the opportunity to bitch about the 1 type some more, really
16:02:17 <byorgey> copumpkin: well, sure, it's possible.
16:02:21 <conal> sinelaw: :)
16:02:23 <ivanm> (so if I work out how to do it, I can reverse the reverse patch... which can then be reversed... ow, my head!)
16:02:31 <byorgey> copumpkin: is the 1 type in scope even if you don't import the generics library?
16:02:52 <copumpkin> byorgey: yeah
16:02:58 <byorgey> bizarre
16:02:58 <copumpkin> it feels dirty
16:03:16 * ivanm passes copumpkin some soap
16:03:20 <copumpkin> thanks
16:03:21 * copumpkin scrubs
16:03:35 <byorgey> well, if we ever did get type-level number literals I imagine the existing 1 type would be nuked.  but who knows.
16:04:43 <ski> @type let x :: 1; x = x in x
16:04:44 <lambdabot> Unit
16:04:46 <ski> @type let x :: 0; x = x in x
16:04:47 <lambdabot> Only unit numeric type pattern is valid
16:04:52 <ski> what, no `Void' ?
16:05:41 <byorgey> silly, isn't it?
16:05:56 <byorgey> having an explicit Void usually isn't that useful in generic programming though, so it's understandable
16:06:12 <copumpkin> hey, I want a 0 :*: a
16:08:07 <djahandarie> Deffered foreign key checking O.O
16:12:15 <theorbtwo> ghc's pretty-printer just "misprinted" my code in a "In a 'do' expression" snippet in an error.
16:12:25 <ivanm> theorbtwo: oh? care to paste?
16:12:40 <theorbtwo> Does this imply that my code doesn't say what I think it does, or that ghc's error writer is somewhat imperfect?
16:12:52 <Zao> hpaste your code and the output.
16:13:32 <theorbtwo> OK, will be a bit.
16:14:02 <Lycurgus> is there anything like HP that is in sync with 6.12?
16:14:26 <Lycurgus> (besides making a base cabal script of your own)
16:14:29 <Zao> Lycurgus: Not yet.
16:14:31 <Zao> Soon[TM]
16:14:43 <Lycurgus> :(
16:14:52 <Zao> Until then, install cabal-install and pull in whatever you need.
16:14:55 <Zao> And pray.
16:15:27 * Lycurgus had an involuntary reflex to get up on a soapbox at the mention of "prayer".
16:16:24 <Zao> Hallowed are the Simons. Oleg.
16:16:51 <ivanm> and dons, dcoutts, Igloo, etc.
16:17:37 <Kruppe> I have a type class that looks something like this: class (RRow c, RTable b c) => ARTable a b where ... where RRow and RTable are typeclasses. I get an error saying "Not in scope: type variable c". Anything obvious that Im doing wrong here or that I can't actually do?
16:17:59 <mauke> yes, what's c supposed to be?
16:18:11 <Cale> theorbtwo: Of course, make sure that you don't have tab characters in the file...
16:18:35 <ivanm> Kruppe: I think it's because you're not using c in the ARTable definition
16:18:42 <ivanm> that is, have "ARTable a b c"
16:18:47 <Kruppe> ivanm: oh
16:18:57 <theorbtwo> That's an odd error message for that.
16:19:17 <Kruppe> theorbtwo: the error was confusing me, thats for sure
16:19:21 <theorbtwo> OTOH, I've noticed of late that haskell & ghc don't always give good error messages.
16:19:32 <ivanm> it makes sense once you're used to it and you know what it's complaining about
16:19:35 <Cale> Yeah, that's what it is, c isn't in scope because it doesn't appear anywhere to the right of the =>
16:19:44 <Cale> You can only constrain type variables that you actually use.
16:19:45 <Zao> Kruppe: As I understand it, it's about the use of c on the LHS of =>, as it isn't mentioned at all on the RHS.
16:19:54 <theorbtwo> Eeep.  hpaste is 500ing.
16:19:55 <Zao> As far as it knows, there is no c in scope.
16:20:26 <Zao> Would functional dependencies be relevant here, depending on what he's trying to achieve?
16:20:26 <Kruppe> yup, error gone. Thanks!
16:21:03 <mauke> sometimes I think of instances as function equations at the type level
16:21:29 <theorbtwo> http://pastie.org/831844 is the error.
16:21:47 <theorbtwo> That "required le32 0 le32" is on two lines in the source.
16:21:52 <mauke> instance (A a, B a) => C (T a)  <=>  fC (T a) = (fA a, fB a)
16:22:06 <theorbtwo> http://pastie.org/831847 is the source.
16:22:24 <ivanm> theorbtwo: no tabs in source code?
16:22:38 <ivanm> I'm thinking it just doesn't deal with printing out multiline expressions too well
16:22:42 <theorbtwo> Shouldn't be, emacs haskell-mode did the indenting.  I'll double-check, though.
16:23:01 <theorbtwo> No hard tabs.
16:23:09 <ivanm> theorbtwo: methinks you need a do in the then statement
16:23:19 <ivanm> or a >>
16:23:24 <uorygl> I wonder if cabal and its sister programs could be considered an operating system.
16:23:30 <theorbtwo> Oh.  It's not already in the outer do?
16:24:18 <theorbtwo> Ah, lovely.
16:24:22 <Cale> theorbtwo: do-expressions serve to glue together multiple actions into a single action
16:24:58 <theorbtwo> Sticking a "do" just after the "then" and "else" both fixed the error message and gave me correct-looking results.
16:25:04 <winxordie> uorgyl: I was thinking about that when I got the haskell platform. I then encountered 'House'.
16:25:26 <ivanm> theorbtwo: you won't need one after the else since you only have a single statement there
16:25:46 <Cale> theorbtwo: Each expression inside the do-block should be an action, including if it's a conditional one based on an if/then/else -- there's no exception to the syntax there, so if you want the actions in the then and else parts to be built from multiple actions, you need another do
16:26:45 <Cale> ghc seems to be laying out the if/then/else in a silly way
16:26:54 <Cale> Maybe it's that way in your source too?
16:26:55 <theorbtwo> Hm.
16:27:08 <Cale> if foo
16:27:10 <Cale>    then bar
16:27:13 <Cale>    else quux
16:27:22 <Cale> is the normal way
16:27:26 <theorbtwo> Oh.
16:27:41 <theorbtwo> haskell-mode doesn't like that; it puts them all at the same indent level.
16:27:43 <theorbtwo> iff foo
16:27:45 <theorbtwo> then bar
16:27:47 <theorbtwo> else quux
16:28:19 <Cale> I stopped using the "smart" indent mode in emacs for reasons like that.
16:28:51 <Cale> Actually, I think it may do it right if you hit tab *after* typing the 'then' or 'else'
16:29:06 <Cale> But it's rather unnatural to do that :)
16:30:40 <Cale> Nope, seems to fail here. That's unfortunate.
16:31:25 <Cale> theorbtwo: Anyway, the logic behind it is that whenever you have something which is part of something else, it should start on a deeper column
16:31:35 <Cale> theorbtwo: and things which are siblings should be at the same level
16:31:37 <ivanm> theorbtwo: haskell-mode will indent the then an extra time first IIRC
16:31:42 <theorbtwo> Ah.  There's a configuration option for that.  Even better, it links to a wiki page.
16:31:57 <ivanm> Cale: is the "smart" mode the new one or the old smart one? ;
16:32:03 <Cale> ivanm: I don't know.
16:32:10 <Cale> tbh I don't use emacs all that often
16:32:38 <ivanm> fair enough
16:32:38 <Cale> I probably used whatever the old one was, it was a few years ago when I last used emacs a lot.
16:32:42 <ivanm> haskell-indentation is the new one
16:33:20 <theorbtwo> Right.  When set, it looks much saner to me.
16:34:02 <theorbtwo> Time to go back to trying to figure out how to match offsets and parsec in a vaugely sane manner.
16:34:29 <theorbtwo> I have a feeling this isn't going to be simple.
16:35:05 * hackagebot upload: minirotate 0.1.2.0 - Minimalistic file rotation utility (KrzysztofSkrzetnicki)
16:37:04 * ivanm -> lunch
16:37:41 <cpettitt> I'm having some trouble creating a multi-parameter class. I'd like to create a class that has a collection type (ByteString, String, etc), but I also need to get the individual elements of that type (Char in both of the above cases). I've tried a multi-parameter class (http://pastebin.com/m478f87f9), but get "No instance for (Key C.ByteString b)" when I try to use it (head $ C.pack "test")
16:37:55 <cpettitt> Also, it seems a little weird to specify the element type in the class
16:38:44 <Accidus> How is the second monad law called? Not the unit one.
16:39:09 <copumpkin> associativity?
16:39:09 <doserj> cpettitt: you either need a functional dependency, or an associated type
16:39:56 <cpettitt> cool, I'll look those up. Thanks Doserj!
16:40:15 <doserj> cpettitt: class Key a b | a -> b where ..., or class Key a where type Elem a ...
16:40:47 <sinelaw> conal: sinelaw, expertly avoiding non-referential This's since 2009.
16:41:15 <cpettitt> doserj: totally new syntax for me, looks like I've got a bit of reading ahead of me :D
16:42:42 <Accidus> Sorry, I didn't mean law. I meant transformation
16:43:08 <Accidus> So we have the unit A -> TA, how is the T²A -> TA called?
16:43:16 <cpettitt> doserj: don't understand the theory behind it, but your suggestion "Key a b | a -> b" worked perfectly. Thanks so much!
16:44:09 * hackagebot upload: llvm 0.7.1.0 - Bindings to the LLVM compiler toolkit. (LennartAugustsson)
16:44:15 <doserj> cpettitt: that simply means that a determines the type b.
16:44:49 <doserj> cpettitt: i.e., for any type a, there can only be one type b such that instance Key a b holds.
16:44:54 <ddarius> Accidus: The multiplication if you call A -> TA the unit.
16:45:15 <doserj> cpettitt: in your case, a collection can only contain one type of elements
16:45:27 <Accidus> ddarius, Really? sounds... wrong
16:45:53 <cpettitt> Excellent, that makes sense and is exactly what I want... that prevents me doing something stupid like instance ByteString Char and instance ByteString Int, but I can do instance ByteString Char and instance String Char
16:49:51 <Accidus> Hmm... I see Wadler referring to it as "join" in his "comprehending monads" paper.
16:49:58 <copumpkin> :t join
16:49:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:50:24 <c_wraith> :t join . fmap
16:50:26 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
16:50:26 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
16:50:26 <lambdabot>     In the second argument of `(.)', namely `fmap'
16:50:36 <ddarius> Accidus: join is what is called in Haskell, but return isn't called unit in Haskell.
16:50:44 <copumpkin> :t (join .) . fmap
16:50:45 <c_wraith> :t (join .) . fmap
16:50:46 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
16:50:46 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
16:51:16 <Accidus> ddarius, ah, I see. Hrm. are you sure about the multiplication? Have you got a reference?
16:51:32 <ddarius> @google multiplication of a monad
16:51:33 <lambdabot> http://en.wikipedia.org/wiki/File:Monad_multiplication_explicit.svg
16:51:55 <MissPiggy> explicit?
16:52:04 <copumpkin> hawt monad action
16:52:16 <c_wraith> :t let f .. g = \x y -> f (g x y) in join .. fmap
16:52:17 <lambdabot> parse error on input `..'
16:52:21 <Kruppe> Im having trouble with the instances of the class that I mentioned earlier. Here is an example of what the instance looks like: http://pastebin.org/93839. The error is also included there. Any idea why this doesnt work? Something similar worked for me before on a single parameter typeclass.
16:52:21 <Kruppe>  
16:52:24 <ddarius> Accidus: For something to be a unit, it requires a "multiplication" for it to be the unit of.
16:52:27 <c_wraith> I can't name an operator ..?  boo!
16:52:41 <ddarius> c_wraith: [0 .. 9]
16:52:46 <copumpkin> > let (..?) = (+) in 0 ..? 5
16:52:47 <lambdabot>   5
16:53:01 <copumpkin> :P
16:53:06 * copumpkin loves missing the point
16:53:06 <c_wraith> :t let f .' g = \x y -> f (g x y) in join .' fmap
16:53:07 <lambdabot>     lexical error in string/character literal at character 'g'
16:53:11 <RayNbow> copumpkin, will that Que reader you tweeted about have an SDK?
16:53:36 <copumpkin> RayNbow: there's remarkably little information on it :/ so don't know :(
16:53:37 <Accidus> ddarius, Hmm.... Oh well. Let's call it multiplication.
16:53:53 * copumpkin resists the temptation to do the usual monad as monoid quote
16:54:01 <c_wraith> oh, I can't mix punctuation with non-punctuation
16:54:19 <ddarius> @quote endofunctor.category
16:54:19 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
16:54:21 <c_wraith> :t let f . g = \x y -> f (g x y) in join . fmap
16:54:22 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
16:54:26 <c_wraith> there. >_>
16:54:41 <RayNbow> copumpkin: the reason I'm asking is because of djvu support :p
16:54:57 * RayNbow knows that luite wrote a djvu plugin for an iRex ereader
16:55:01 <copumpkin> RayNbow: their support people got back to me in a couple of hours when I sent them a question. You could just email them
16:55:09 <MissPiggy> I know what a monad and a monoid and a endomorphism is
16:55:13 <Accidus> There used to be a Wadler quote along the same lines
16:55:15 <MissPiggy> so what the hell does that mean??
16:55:20 <RayNbow> ah, I might email then the next morning I wake up :p
16:55:23 <copumpkin> MissPiggy: a monoidal category?
16:55:28 <MissPiggy> endofunction is like  m a -> m a  ?
16:55:32 <MissPiggy> functor*
16:55:42 <ddarius> MissPiggy: Do you know what a "monoid object" is?
16:55:58 <MissPiggy> I don't think so
16:55:58 <Hunner> :t liftM
16:55:59 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
16:56:38 <ddarius> MissPiggy: Then look that up and work out the details of "a monoid object in an endofunctor category."
16:56:56 * copumpkin and Cale both have reddit posts going through most of the details
16:57:09 <copumpkin> mine was fairly sloppy but Cale's was pretty good, somewhat unsurprisingly
16:58:45 <dolio> You should write a reddit post about how a monoid is a monad in a 2-category with a single object.
16:58:59 <MissPiggy> lol
16:59:04 <copumpkin> that's the plan
16:59:15 <copumpkin> I'm going to submit it as a self.programming with "Monads are easy!"
16:59:26 <ddarius> dolio: A monad is a lax functor into the two category of Cat.
17:00:11 <copumpkin> Damn, MissPiggy left
17:00:17 <copumpkin> I just found Cale's explanation
17:01:19 <dolio> ddarius: From some specific other category? Or just in general?
17:02:48 <dolio> Other 2-category, that is.
17:06:50 <dolio> Ah, it's lax functors from the point category, as I suspected.
17:08:59 <chrissbx> I've got a case where it will only dynamically be known whether a function (walking a tree) will be possible, but I need to handle the case where it's not.
17:09:22 <chrissbx> Is there a way to catch pattern match exceptions or should I rewrite the code using Maybe or something?
17:09:35 <ski> wouldn't that be a monad global point, as opposed to a monad generalized element ?
17:10:25 * ski would probably use `Maybe' or `[]', or possibly `m' where `MonadPlus m'
17:10:40 <dolio> I'd use Maybe, too.
17:10:54 <dolio> Catching pattern match exceptions for that sounds evil.
17:11:26 <Alpounet> @quote lax functor
17:11:26 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
17:11:43 <dolio> @quote lax.functor
17:11:43 <lambdabot> copumpkin says: a monad is just a lax functor from a terminal bicategory, duh. fuck that monoid in category of endofunctors shit
17:11:54 <Alpounet> yeah, thanks
17:11:56 <chrissbx> What about introducing trows somehow, i.e. extend my pattern matches to exit using one specific exception--or first class continuation?
17:12:09 <chrissbx> I'd prefer not having to change too much of my code.
17:12:32 <chrissbx> (But I've never used Maybe, maybe that doesn't need so many changes?)
17:12:33 <dolio> Those would both require changing your code as much as Maybe.
17:13:12 * chrissbx tries Maybe
17:13:41 <foxy> I have the latest Cabal, HTTP, and zlib installed.  I build and install cabal-install, then run "cabal update" to which I receive: "cabal: Codec.Compression.Zlib: incorrect header check" how do I correct this?
17:17:59 <Saizan> foxy: what happens if you retry?
17:18:11 <foxy> same thing
17:18:52 <Saizan> and this is cabal-install-0.8.0 ?
17:19:18 <foxy> Saizan: 0.6.2
17:19:36 <Warrigal> I just reduced my number of irssi windows eightfold and my number of application windows about eighteenfold.
17:20:04 <foxy> Saizan: ah
17:20:13 <Warrigal> So, now to start working on a spiffy little web application!
17:21:30 <Saizan> foxy: it might also be this http://hackage.haskell.org/trac/hackage/ticket/622
17:21:41 <Saizan> foxy: though i'd give a try to 0.8.0
17:21:53 <foxy> Saizan: thanks
17:23:25 <Warrigal> Hum. When I tried to update cabal, it told me, "/tmp/80397.c:1:0: error: CPU you selected does not support x86-64 instruction set". This is on a new Mac.
17:24:38 <sm> ayayay
17:24:58 <Saizan> Warrigal: ghc-6.10?
17:25:01 <foxy> Saizan:  Yes, I think its that ticket.  On the mac when I download tar.gz files from hackage they get unzipped somewhere up to my download folder
17:25:02 <sm> so many problems working with such a robust language
17:25:26 <Warrigal> Saizan: I have GHC 6.10.4.
17:25:42 <Saizan> Warrigal: http://obvioushints.blogspot.com/2009/09/running-haskell-ghc-on-snow-leopard.html
17:28:33 <Warrigal> Wonderful. Thank you.
17:28:56 <Saizan> foxy: hah weird that happens for programs too though, you could get the 00-index.tar under ~/.cabal/packages/hackage.haskell.org/ manually, but i'm not sure what would happen when cabal tries to fetch the source tarballs
17:39:04 * Accidus groans. 
17:39:19 <Accidus> What do you do when you can't decypher your supervisor's handwriting?
17:40:24 <ivanm> ask him wtf he wrote?
17:40:31 <Accidus> it's 1:40
17:40:37 <Accidus> not going to call him
17:40:43 <Accidus> :)
17:40:53 <Accidus> But I need to finish this by tomorrow :-/
17:40:54 <ivanm> heh
17:40:59 <Accidus> (technically by 3 months ago)
17:41:00 <ivanm> make it up!
17:41:08 <Accidus> I'm trying.
17:41:18 <Accidus> Right now it looks like: une*lmed
17:41:27 <Accidus> Or rather "still une*lmed"
17:41:45 <Warrigal> Accidus: why can't you call him?
17:41:59 <Accidus> Warrigal, he's probably asleep (it's 1:41)
17:42:18 <Warrigal> Oh, it's 01:41.
17:42:34 <chrissbx> Is there something better to match Maybe values and branch on them than using case? (I guess that'd be the Maybe monad?)
17:42:57 <Accidus> chrissbx, how would you like it to look like?
17:43:03 <Warrigal> Well, what's more important to him: that you finish this by tomorrow, or that he not be woken up?
17:43:17 <Accidus> Warrigal, probably the latter :)
17:43:34 <Warrigal> Could you contact a coworker somehow?
17:43:42 <c_wraith> you could scan it/take a picture of it, and see if any of us could decipher it
17:43:47 <c_wraith> ;)
17:44:01 <copumpkin> Accidus: scan/take a pic and show it to us?
17:44:03 <ivanm> chrissbx: maybe, fromMaybe, etc.
17:44:06 <ivanm> @type maybe
17:44:06 <copumpkin> with a bit of context
17:44:07 <chrissbx> Accidus: something like Scheme's (cond ((f x) => (lambda (x) ..)) (else ...)
17:44:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:44:09 <ivanm> @type fromMaybe
17:44:11 <lambdabot> forall a. a -> Maybe a -> a
17:44:28 <Warrigal> > fromMaybe Nothing Just
17:44:28 <Accidus> chrissbx and how does the haskell version look like? more or less the same, no?
17:44:29 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
17:44:29 <lambdabot>                             ...
17:44:46 <Accidus> oh well. I guess it will give me something to do. I'll fetch the camera
17:44:49 <c_wraith> oh, blah.  CPP is doing something I don't expect to this file.  Is there any way to see what it looks like after CPP hits it?
17:44:54 <Warrigal> > maybe Nothing Just
17:44:55 <lambdabot>   {Nothing->Nothing;Just ()->Just ()}
17:45:11 <ivanm> Warrigal: heh
17:45:11 <Warrigal> So, yay. cabal gave me some failures to install.
17:45:39 <Warrigal> ivanm: it's in my "foldr (:) []" series
17:45:44 <ivanm> heh
17:47:55 <ivanm> > foldr (:) []
17:47:56 <lambdabot>   {[]->[];[()]->[()];[(),()]->[(),()];[(),(),()]->[(),(),()]}
17:48:37 <Warrigal> So, for cabal, I want to edit my .profile by adding PATH=$PATH:~/.cabal/bin, right?
17:51:33 <ivanm> well, it might not be your ~/.provile
17:51:36 <ivanm> *profile
17:51:41 <ivanm> depends on which shell you're using, etc.
17:52:02 <Warrigal> It's bash.
17:55:14 <Saizan> Warrigal: i wouldn't use ~ there
17:55:35 <Saizan> $HOME is better.
17:55:36 <ivanm> Warrigal: so you can use ~/.bashrc or ~/.bash_profile
17:55:44 <ivanm> not sure if ~/.profile will work...
17:55:49 <ivanm> Saizan: oh? how come?
17:56:00 <Warrigal> Why wouldn't .profile work?
17:56:26 <ivanm> IIRC, it doesn't on some distros
17:56:29 <ivanm> that's all
17:56:36 <ivanm> if you've already used it, then go ahead
17:56:47 <ivanm> but I vaguely recall some problems using ~/.profile on some machines
17:57:01 <Warrigal> I'm on the Snow Leopard distro. :P
17:57:25 <c_wraith> That causes its own issues for GHC < 6.12
17:57:29 <Saizan> ivanm: iirc GHC doesn't interpret ~ when found in the $PATH , e.g. when it's trying to run some preprocessor
17:57:45 <ivanm> Saizan: right, but we're not talking about GHC here ;-)
17:57:48 <Warrigal> Should I upgrade to 6.12?
17:57:52 <ivanm> we're talking about his shell ;-)
17:57:57 <Warrigal> Since I'm currently on 6.10, and all.
17:57:58 <ivanm> Warrigal: are you more a developer or a user?
17:58:20 <c_wraith> So..  solution was:  create a file *just* for the stuff that CPP is being used on.  Don't put a ton of other crap in the same file, or CPP will mangle it
17:58:32 <Accidus> Okay, got it scanned: http://imagebin.ca/view/xBw7P0xM.html
17:58:38 <Warrigal> ivanm: of what?
17:58:46 <ivanm> of haskell
17:59:02 <Warrigal> I guess I'm entirely a user.
17:59:07 <ivanm> Warrigal: if you write a lot of libs, etc. then go for 6.12
17:59:27 <Warrigal> Unless by "Haskell" you mean "stuff written in Haskell", in which case I'm more a developer.
17:59:29 <ivanm> if you just use it for assessment or just want some haskellian apps, then stick with 6.10 until the next release of the haskell platform
17:59:32 <c_wraith> You'll have to do some hacking to make 6.10 work, but it's still more compatible with existing code than 6.12 is
17:59:47 <Warrigal> I think I did the requisite hacking to make 6.10 work.
17:59:47 <c_wraith> the hacks are all documented nicely somewhere
17:59:51 <ivanm> yeah, there's no gtk2hs release with the 6.12 patch yet AFAIK :@
17:59:55 <c_wraith> all the -m32 stuff?
17:59:56 <Saizan> ivanm: but i imagine that things under ~/.cabal/bin will likely end up being used by the haskell toolchain :P
18:00:04 <Warrigal> Yeah, all the -m32 stuff.
18:00:13 <c_wraith> Ok, then.  You should be in fine shape for GHC
18:00:18 <ivanm> Saizan: and they wouldn't just search the $PATH? you sure?
18:00:48 <Saizan> ivanm: when ghc searches the $PATH and sees a ~ it doesn't interpret it correctly.
18:00:58 <ivanm> Accidus: "still unbalanced"?
18:01:04 <ivanm> Saizan: hmmm....
18:01:12 <ivanm> I thought the shells converted the path...
18:01:39 <Accidus> ivanm, Hmm.... Maybe. Thanks. Now I have to understand what he meant. We had a long discussion about that comment
18:01:46 <sm> shells do, but apps don't unless written to do that
18:01:55 <ivanm> Accidus: I'm guessing you're missing some parens or something...
18:02:08 <Saizan> though ~ might get converted by the shell before the whole string gets assigned to PATH, but i wouldn't bet on that
18:02:13 <Accidus> hehe, no, that would be easy to spot
18:02:22 <ivanm> Saizan: that's what I thought happened ;s
18:02:22 <Accidus> It's a definition for some algebraic structure
18:02:38 <Saizan> ivanm: i've seen cases where it didn't :)
18:02:48 <ivanm> fair enough
18:03:09 <Accidus> ivanm, besides, TeX would grumble if I had unbalanced parentheses.
18:03:16 <copumpkin> Accidus: you forgot parentheses? :P
18:03:23 <copumpkin> Accidus: not always
18:03:32 <ivanm> if you had them elsewhere...
18:03:38 <copumpkin> if it's a \left \right it'll bitch
18:03:55 <Accidus> copumpkin, Anything that is complex enough as to contain unbalanced parentheses, I wrap in a \parent{...} macro
18:03:56 <copumpkin> but it doesn't ensure they're the same type, and it doesn't ensure regular parens are balanced
18:04:04 <Accidus> (admittedly, it turns my TeX code into lisp)
18:04:51 <ivanm> never heard of \parent{...}
18:04:54 <ivanm> what does it do?
18:05:02 <Accidus> guess. It's my own macro. :)
18:05:20 <ivanm> heh
18:06:35 <Accidus> I think I know what he means. But not sure why he called it "balanced"
18:06:45 <Accidus> (if that is indeed what he wrote)
18:07:38 <Warrigal> Hum. When I try to install hslogger-1.0.9, it complains that Control.Exception.SomeException is not in scope.
18:08:05 <ivanm> Warrigal: should be; that's in >= 6.10 ...
18:08:12 <ivanm> unless it's specifying base-3 ...
18:09:38 <Saizan> Warrigal: --preference="base >= 4"
18:09:59 <Warrigal> Here's the full error: http://pastebin.ca/1802248
18:10:01 <Saizan> Warrigal: with cabal-install-0.8.0 it should just work
18:10:11 <ivanm> Saizan: doesn't it default to base-3 anymore?
18:10:40 <Saizan> ivanm: not if there's an upper bound
18:10:53 <ivanm> oh, right
18:10:55 <Warrigal> Oh, I have 6.4. Do I want to cabal update and then cabal install cabal-install?
18:11:11 <Saizan> Warrigal: oh, and don't sudo cabal .., use cabal install --global --root-cmd=sudo if you want a global install
18:11:24 <Saizan> cabal install "cabal-install >= 0.8.0"
18:11:50 <Warrigal> How about I just leave the sudo off?
18:11:52 <ivanm> Saizan: why, what's wrong with using sudo?
18:12:01 * ivanm generally su's into root anyway
18:12:20 <Saizan> Warrigal: that's fine too
18:12:34 <Warrigal> Hum, leaving off the sudo gives me a permission error.
18:12:53 <Saizan> because you screwed up your files by using it before
18:13:01 <Warrigal> Ouch.
18:13:09 <Warrigal> So I gave my cabal a sudo addiction.
18:13:16 <Saizan> chown -R on ~/.cabal and ~/.ghc
18:13:33 <sm> sudo chown -R me.me ~/.cabal
18:13:46 <Warrigal> me.me, literally?
18:13:52 <Saizan> ivanm: here's what's wrong :)
18:14:13 <c_wraith> I always use me:  (leaving off the group tells chown to pick your default group)
18:14:43 <ivanm> aha
18:15:16 <Warrigal> Apparently my default group is "staff". Who knew.
18:16:44 * Warrigal installs cabal for the fifth time.
18:17:24 <Accidus> May I trouble you for two more? http://imagebin.ca/view/ncWb6DU.html and http://imagebin.ca/view/wnPX1M.html .
18:17:25 <Saizan> you get bonus points.
18:19:37 <ivanm> Accidus: "really? Disjoint (?) I guess but not there" for the first one; disjoint is the best word I could come up with but it doesn't look right
18:19:52 <ivanm> and no idea bout the second one
18:20:12 <Accidus> Ah!
18:20:16 <Cale> wow, that's some sloppy handwriting :)
18:20:17 <Accidus> ivanm, It's disjunction
18:20:18 <ivanm> Accidus: maybe go ask a doctor? :p
18:20:22 <ivanm> Accidus: aha
18:20:42 <Accidus> I don't think it's there though
18:20:49 <Accidus> I mean "there"
18:20:55 <Accidus> I don't see how the last word is "there"
18:21:09 <Accidus> And it doesn't seem to fit the context.
18:21:12 <Cale> not others?
18:21:29 <Warrigal> The third letter of this "disjoint" letter looks like an upside-down s.
18:21:41 <Warrigal> So it's probably an s.
18:22:08 <Warrigal> Then you have a mystery letter with a long descender, then a malformed i...
18:22:24 <Accidus> Warrigal, it's disjunction, for sure.
18:22:38 <Accidus> But the last word doesn't seem to be "there". Contextually.
18:22:38 <Cale> ah, that explains the dot :)
18:22:42 <Cale> "others"
18:22:43 <Warrigal> On, that almost makes sense.
18:23:10 <c_wraith> collaborative handwriting recognition
18:23:19 <ivanm> heh
18:23:23 <Cale> The last word looks like "others" to me.
18:23:26 <Accidus> Cale, "others" seems to fit the appearance, but it still doesn't make sense
18:23:39 <ivanm> c_wraith: we can alwasy raise some funds for haskell by offering our services to google! ;-)
18:23:45 <Saizan> next we discover that this is just an elaborate captcha.
18:23:51 <Accidus> hehe
18:24:04 <Accidus> Saizan, this means I failed the Captcha then?
18:24:11 <Cale> What's the text that it's a comment about?
18:24:13 <Warrigal> I'd rather raise some funds for Haskell by going around and asking people where I can find some money.
18:24:18 <Accidus> My research proposal
18:24:23 <Accidus> This bit is about access control
18:24:28 <medfly> I wouldn't mind work
18:24:33 <ivanm> that's a long research proposal...
18:24:54 <Accidus> ivanm, indeed it is. waaay too long. That's why I want to finish it tonight
18:25:01 <ivanm> heh
18:25:04 <Warrigal> Assuming the paragraph actually ends where it's cut off, "One can similarly define concipals. Abadi [GA08] presents operations on principals. I'm using the principal operation."
18:25:05 <ivanm> mine was about a page...
18:25:38 <Accidus> Warrigal, lol
18:25:53 <Warrigal> I want to learn more about concipals.
18:26:07 <Cale> Haha, a 2cm wide strip of text.
18:26:10 <Accidus> Warrigal, the I'm is actually "In". And Concipals are conjuction
18:26:13 <Accidus> and principals
18:26:35 <kuitang> Cale: thanks for the explanation. I had to run earlier
18:26:37 <Accidus> :)
18:26:53 <Cale> kuitang: I didn't quite finish the explanation, but perhaps you get what's going on now :)
18:27:12 <Accidus> Ahh... I think I understand what he says
18:27:28 <Warrigal> Let's see. "Concipal" means "with in importance".
18:27:43 <Accidus> He's taking the wrong view of things though.
18:27:50 <Warrigal> So a concipal of Barack Obama is something whose importance is with Barack Obama's importance, for example.
18:28:01 <gwern> > (18 * 5000) / 60
18:28:02 <lambdabot>   1500.0
18:28:08 <gwern> > (18 * 5000) / 120
18:28:09 <lambdabot>   750.0
18:28:11 <Accidus> Oh... Right. now I understand
18:28:19 <gwern> > ((18 * 5000) / 60) / 60
18:28:20 <lambdabot>   25.0
18:28:31 <kuitang> Cale: so the interpreter recurses to compute x, and computes the (fromIntegral v / fromIntegral x) as it goes back down the call stack instead of traversing twice, right?
18:28:47 <Accidus> That sentence says "One can also define conjunction, disjunction and other operations", and he can't really see the other operations.
18:28:51 <Cale> kuitang: There isn't really a call stack
18:29:08 <Accidus> So he can't see the other operations.
18:29:18 <Warrigal> Okay, it seems that though I installed cabal-install version 0.8.0, the version that runs when I cabal --version is 0.6.2.
18:29:19 <Accidus> Oh well. With the latest version the question is moot.
18:30:13 <Accidus> Even less than moot --- irrelevant.
18:31:32 <Cale> kuitang: Let's just take a closer look at the base case again...
18:32:08 <Cale> kuitang: So if we call  comp' Empty, what do we get? Well, I'll write it using let, so we constantly have an expression
18:32:23 <Cale> let (t',x) = comp'' x Empty in t'
18:32:42 <Accidus> Ah! I figured the second one out
18:32:48 <Accidus> "propositional"
18:32:54 <Accidus> Thanks a lot!
18:33:03 <kuitang> Cale: Empty
18:33:10 <Cale> So now to evaluate t', we need to pattern match comp'' x Empty, which as it's not immediatelyin the form of a tuple, we have to evaluate it
18:33:34 <Cale> So we do, and get  let (t',x) = (Empty, 0) in t'
18:33:41 <Cale> and then pattern match and get Empty
18:33:51 <Cale> and note that the x was never a problem in this case
18:34:16 <Cale> but, we did manage to determine x anyway -- it's 0
18:34:21 <Cale> (in this case)
18:34:40 <Saizan> Warrigal: you probably have both installed in different locations
18:35:00 <Cale> So, I'd like to do that comp' (NodeBT 1 Empty Empty) case once more :)
18:35:11 <Cale> comp' (NodeBT 1 Empty Empty)
18:35:22 <Warrigal> "which cabal" lists only one.
18:35:24 <Cale> -> let (t',x) = comp'' x (NodeBT 1 Empty Empty) in t'
18:36:40 <Saizan> Warrigal: does which ever list more than one path?
18:36:55 <Warrigal> Uh, good question.
18:37:04 <Cale> -> let { (t',x) = let { (p1,s1) = comp'' x Empty; (p2,s2) = comp'' x Empty } in (NodeBT (fromIntegral v / fromIntegral x) p1 p2, v + s1 + s2) } in t'
18:37:06 <Warrigal> When it
18:37:12 <Warrigal> When it's run with -a. :P
18:37:20 <Warrigal> which -a cabal lists two of them.
18:37:40 <Warrigal> And indeed the second one is the correct version.
18:37:49 <Warrigal> The first one is /usr/local/bin/cabal. I'm guessing I want to blow that away.
18:38:07 <kuitang> Cale: so there is an x in the expression but we did not define x; what happens here?
18:38:15 <Cale> We did define x.
18:38:23 <kuitang> Cale: x = 0?
18:38:23 <Cale> (t',x) = ...
18:38:49 <Cale> This defines x as the second part of the tuple in the result of evaluating that expression "..."
18:39:10 <Warrigal> It would be nice if I could run a command to determine why a file exists.
18:39:24 <Cale> um, actually, I made a small mistake, forgot to substitute for v
18:39:39 <Cale> -> let { (t',x) = let { (p1,s1) = comp'' x Empty; (p2,s2) = comp'' x Empty } in (NodeBT (fromIntegral 1 / fromIntegral x) p1 p2, 1 + s1 + s2) } in t'
18:39:54 <Cale> So currently, we know that x is equal to 1 + s1 + s2
18:40:22 <Cale> We could actually split up the pattern binding now, since we can pattern match the tuple...
18:40:57 <kuitang> Cale: oh, i see, so the right part of the tuple = x = 1 + s1 + s2 = 1 + 0 + 0
18:41:03 <Cale> But let's leave it, and evaluate the comp'' x Empty
18:41:04 <Warrigal> Would it be safe to simply rename /usr/local/bin/cabal in order to get it out of the way?
18:41:06 <Cale> yeah
18:41:08 <kuitang> Cale: then the left part uses that x
18:41:10 <kuitang> Cale: thanks
18:41:12 <Cale> yeah
18:41:59 <Cale> So this defines x unambiguously, it's just that you have to remember not to insist that the parameters to a function are evaluated before making the substitutions.
18:42:47 <Cale> Here's a simpler example...
18:43:05 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in evens
18:43:06 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
18:43:48 <Cale> Well, that's mutual recursion on values.
18:44:34 <tomberek> anyone know how to use par and pseq?
18:44:39 <Cale> tomberek: I do.
18:44:44 <tomberek> hi Cale
18:45:07 <tomberek> i'm just playing around and getting odd behavior
18:45:18 <Cale> odd in what way?
18:46:00 <tomberek> code is faster in ghci than compiled!
18:46:50 <Warrigal> I guess Haskell has matured past the point where compiling is good for it.
18:46:50 <Cale> tomberek: that's interesting
18:46:53 <Cale> heh
18:47:04 <Cale> How are you compiling the code?
18:47:12 <tomberek> http://haskell.pastebin.com/m18928159 these are the functions
18:47:20 <ivanm> Cale: as a quick reminder, what does k-connected mean for graphs?  wikipedia doesn't help :s
18:47:24 <Accidus> tomberek, what kind of time speedup are we talking about?
18:47:36 <Accidus> tomberek, I mean, how long does the program run?
18:48:02 <Cale> ivanm: It means that there isn't a set of k-1 vertices you could remove to disconnect the graph
18:48:06 <tomberek> Accidus: I think it's a GC issue because it's a lot
18:48:20 <ivanm> Cale: ta
18:48:22 <Accidus> tomberek, are we talking about a few minutes?
18:48:26 <Accidus> tomberek, or a few seconds?
18:48:33 <tomberek> look at the pastebin above: am I using par and pseq right?
18:48:35 <Cale> Or, to put that another way, removing any k-1 vertices will still leave you with a connected graph.
18:48:39 <ivanm> yup
18:48:47 <ivanm> I remember what it means now
18:48:54 <Cale> tomberek: no.
18:49:08 <ivanm> and now even wikipedia's explanation makes sense ;-)
18:49:21 <ivanm> tomberek: I _think_ you want to replace pseq with another par...
18:49:26 <Cale> tomberek: you're wasting time computing fib n and then discarding the result and computing it again
18:49:26 <ddarius> simple.wikipedia.org
18:49:39 <ivanm> oh, wait, yes
18:49:39 <tomberek> i've tried that too, desperaton
18:49:55 <tomberek> Cale i'm just testing stuff out... they are two different sequences
18:50:02 <ivanm> ddarius: no simple english version of the connectivity page
18:50:03 <Cale> parFib n = let x = fib n; y = fib2 n in x `par` y `pseq` (x,y)
18:50:16 <Cale> tomberek: ^^ do it like that
18:50:18 <ivanm> Cale: won't y be calculated with (x,y)?
18:50:19 <ddarius> tomberek: You might want to actually read something about how to use par and pseq.
18:50:26 <ivanm> or does it mean do y  before (x,y) ?
18:50:31 <ddarius> ivanm: You could fix that.
18:50:35 <ivanm> ddarius: I think he was just assuming caching...
18:50:36 <ivanm> ddarius: heh
18:50:49 <Cale> ivanm: it means y will be computed before (x,y)
18:50:53 <ivanm> *nod*
18:51:07 <ivanm> still interesting that ghci computed it faster...
18:51:12 <Saizan> also, i'd write (x `par` y) `pseq` (x,y) to be sure
18:51:17 <ivanm> Saizan: yeah
18:51:44 <Saizan> ghci probably doesn't cache the 's' between runs of fib and fib2
18:51:51 <Cale> Saizan: Is there a real difference between that and x `par` (y `pseq` (x,y))?
18:51:53 <Saizan> keeping the heap smaller
18:52:47 <Saizan> Cale: if par is strict in both arguments there is
18:53:07 <ivanm> Cale: :o there's something you didn't know? :o
18:53:07 <ivanm> ;-)
18:53:08 <Cale> tomberek: The important thing to notice is that if you write fib 5 + fib 5, say, this is different from writing let x = fib 5 in x + x
18:53:18 <Cale> tomberek: It *will* recompute fib 5 twice.
18:53:23 <Saizan> Cale: it might end up evaluating (y `pseq` (x,y)) before sparking x
18:53:30 <ddarius> I don't believe par is strict in x.
18:53:47 <Saizan> that's worse
18:54:11 <Cale> Evaluating par x y will always spark x before resulting in y
18:54:20 <Cale> But it's not strict in x
18:54:31 <ddarius> Yes, but I don't think par _|_ y = _|_ ever (when y is not _|_)
18:54:38 <Cale> right
18:54:42 <Cale> par _|_ y = y
18:55:19 <ddarius> And of course there is no guarantee that par will spark a thread at all.
18:56:34 <Cale> If it was going to spark the expression at all, it should do it in either case though.
18:57:25 <Saizan> if par _ _|_ = _|_ then the strictness analyzer can move the evaluation of (y `pseq` (x,y)) before the evaluation of the par application
18:58:38 <Cale> Hmm...
18:58:50 <Cale> I thought that par was a special case there.
18:59:01 <tomberek> hey,, had some issues....... Cale: doen't Haskell know that (fib n)'s value or whnf can be used in (fib n,fib2 n) ?
18:59:11 <Cale> Obviously if it does that, it makes par generally rather useless.
18:59:35 <Saizan> unless you use pseq wisely :)
18:59:40 <Cale> tomberek: It won't memoise fib for you automatically, because that wastes memory.
18:59:58 * c_wraith is dual-wielding laptops.  I was suddenly inspired as to the cause of the remaining space leak in my app.  I'm so excited, I need two laptops to fix this!
19:00:18 <tomberek> even though it's the same expression?  the compiler doesn't do a conversion?
19:00:52 <Cale> tomberek: No, because common subexpression elimination is not always an optimisation, and it's hard to tell when it's good.
19:01:05 <Cale> tomberek: So you have to tell it explicitly using let.
19:01:22 <medfly> Cale, are you saying Haskell sucks?
19:01:27 <Cale> medfly: no.
19:01:43 <Cale> I'm saying that GHC does the right thing by not eliminating common subexpressions.
19:02:06 <Cale> Because it's hard (read: impossible) to tell when it would be a good idea to do it.
19:02:29 <Cale> It trades space for time.
19:02:57 <Cale> So if GHC did it automatically, Haskell programs would use more memory, but maybe run faster.
19:02:58 <tomberek> ah
19:03:02 <tomberek> ok
19:03:17 <c_wraith> unless they used so much more memory that it made them slower, of course.
19:03:18 <Cale> (sometimes exponentially more memory)
19:03:26 <c_wraith> Better to give the programmer control
19:03:29 <tomberek> so adding a where clause is enough to tell GHC that it's worth it this time?
19:03:35 <Cale> Yeah
19:03:47 <Cale> define fib n and fib2 n as constants in a let or where
19:03:58 <Cale> and then use par/pseq as you have been
19:04:05 <c_wraith> basically, anything that's bound to a name will be computer only once where the name is in scope
19:04:06 <tomberek> like this http://haskell.pastebin.com/m6063301b ?
19:04:10 <c_wraith> *computed
19:04:27 <Cale> anything that's bound to a name and is not typeclass polymorphic :)
19:04:35 <Cale> tomberek: yeah
19:04:45 <ddarius> Incidentally, without the threaded run-time, par presumably just simplifies to const id, so...
19:05:14 <Cale> Make sure that you're compiling with -threaded
19:05:19 <tomberek> roger,, one sec
19:05:38 <dolio> Saizan: If that's a problem, then in (x `par` y) `pseq` (x,y), it can move the evaluation of x until after everything else anyway, since it doesn't figure in to the result at all.
19:06:10 <gwern> Cale: did anyone ever try out the auto-parallelizing profile stuff, except for CSE?
19:06:20 <gwern> maybe it would've been more worthwhile with CSE
19:06:21 <dolio> Talking only about what the denotational semantics allow isn't going to give the full picture for par.
19:06:29 <ddarius> Semantically, par is const id, so the difference it makes has to be all operational, which can of course include behavior that disallows such transformations.
19:06:57 <Saizan> i'm talking about the information seen by the strict. analyzer
19:07:19 <Saizan> like pseq is strict in the first and lazy in the second, even if it doesn't make sense.
19:08:13 <tomberek> ok,, still not working right... it's taking double the time with two cores
19:08:24 <Saizan> dolio: the important thing is that par is evaluated before y
19:08:39 <ddarius> It would be potentially unsafe to view par as strict in its first argument, and it leads to the behaviors you describe to consider it lazy in the first argument, so I don't think the strictness analyzer's view is too important.
19:08:39 <Saizan> dolio: ..and before x
19:08:56 <ddarius> @google dons parallel fib
19:08:57 <lambdabot> No Result Found.
19:09:08 <ddarius> @google don stewart parallel fib
19:09:09 <lambdabot> No Result Found.
19:09:14 <ddarius> Bloody @google.
19:09:22 <tomberek> Cale: here's the whole thing, i think i'm doing a calculation twice somewhere    http://haskell.pastebin.com/m1e9be482
19:11:00 <Cale> tomberek: Do you happen to be on linux?
19:11:12 <Cale> (and does your machine have exactly 2 cores?)
19:11:54 <tomberek> yes, I have exactly 2 cores.. I got all this to work off of a tutorial's code perfectly.  Now I'm trying to do it on my wn.
19:12:06 <Cale> tomberek: ah, okay
19:12:21 <Cale> tomberek: Note that there is a last-core slowdown problem on linux.
19:12:46 <Cale> tomberek: Which is going to be fixed soonish, but I believe it still exists in 6.12.1
19:13:15 <tomberek> roger.... all I want to do is calculate two sequences in parallel... i still don't know what's wrong
19:13:16 <dolio> Saizan: That doesn't mean that that evaluation order has to be justified by making it denotationally incorrect to evaluate any other way.
19:14:00 <Saizan> dolio: that's what they did for pseq though
19:14:12 <Cale> Saizan: They did it for seq, not pseq
19:14:33 <Cale> pseq has more operational guarantees than seq, but is denotationally equivalent
19:14:43 <dolio> A strictness analyzer doesn't reorder operations on its own. It presumably just informs the optimizer of what reorderings are (denotationally) semantically sound.
19:15:12 <Saizan> Cale: there are special annotations to make pseq look lazy in its second argument, and strict in the first
19:15:17 <dolio> That doesn't mean that's the only thing that the optimizer is concerned with.
19:15:30 <Saizan> Cale: so you don't get the reorderings you might get with seq
19:16:00 <tomberek> Cale: I'm stll getting a 100% slowdown when I specify two cores to the RTS,,or should I not be doing that?
19:16:04 <dolio> pseq is a primitive. The annotations are just something John Meacham (I believe) has used to explain how one would implement pseq in terms of seq and those annotations.
19:16:22 <Cale> tomberek: That is something that you should be doing. Do your cores both light up?
19:16:38 <dolio> I'm not sure it's actually defined that way in the library.
19:16:53 <ivanm> Cale: well, Haskell will be the number 1 programming language in the world "soonish" ;-)
19:16:55 <tomberek> Cale: yes, both with and withoutthe -N2
19:17:19 <copumpkin> by GHC 7
19:17:19 <tomberek> Cale: but it takes ~4 seconds without it, and ~8 seconds with it
19:17:31 <Saizan> dolio: it is http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.2.0.0/src/GHC-Conc.html#pseq
19:17:36 <tomberek> the opposite of what I expected
19:17:37 <ivanm> copumpkin: oh, good-o
19:18:14 <Saizan> par is also lazy in its second argument though
19:19:14 * twink would rather Haskell have some more specific set of ideas to express well as opposed to merely becoming the "number 1 programming language in the world."
19:19:51 * Cale hopes that Haskell never becomes too popular so that it can continue improving.
19:20:05 <Cale> popularity is death
19:20:15 <ezyang> avoid success at all costs
19:20:25 <Saizan> however i got the impression that grouping of par vs. pseq from bos, which were doing some measurements at the time, things might have changed though.
19:20:26 <ezyang> though, it might be said we've already lost
19:20:35 <dolio> Well, don't worry. We won't be popular until we get... Higher-order modules and polymorphic variants.
19:20:43 <tomberek> Cale: any thoughts?
19:20:44 <copumpkin> he never said it would be successful
19:20:45 <Saizan> s/from/was important from/
19:20:46 <copumpkin> just that it'd be #1
19:20:59 <ivanm> dolio: "higher order modules" mean we actually have ways of saying that two modules have the same API?
19:21:00 <Cale> tomberek: I don't have a multicore machine handy to try it.
19:21:04 <shapr> copumpkin: Who said that?
19:21:07 <copumpkin> haskell will be #1 when all languages that exist are ordered in an arbitrary order
19:21:10 <copumpkin> shapr: ivanm did
19:21:17 <dolio> ivanm: Among other things.
19:21:29 <ivanm> shapr: I was commenting on Cale's usage of the term "soonish" ;-)
19:21:40 <shapr> oh
19:22:09 <tomberek> Cale: thanks for the help though
19:22:33 <twink> dolio: Polymorphic variants?
19:22:37 <Cale> tomberek: maybe the program is using twice as much memory now.
19:22:52 * ivanm tries to work out what crazy logo dons has put for the haskell reddit this time...
19:23:32 <Cale> tomberek: it would be nice to see what this looks like in threadscope
19:24:04 <tomberek> Cale: possible, this way of calculating fib needs some GC's..... yeah, i tried to get threadscope before and ran into so many dependecy issues I gave up
19:24:06 <dolio> twink: Polymorphic variants let you write things like: foo :: Int -> < `Foo :: Char | `Bar :: String > ; foo 0 = `Foo '0' ; foo _ = `Bar "baz"
19:25:08 <Cale> tomberek: What does it depend on, aside from Gtk2Hs?
19:25:12 <dolio> twink: They're like Haskell's tuples, only sums instead of products, and with named fields.
19:25:34 <twink> Sounds a little like variant subtyping.
19:25:36 <tomberek> Cale: i forget, it was a while ago, i think it was a diffenent compiler version as well
19:25:45 <tomberek> can anyone give this a shot on a multicore machine?  try both with and without the -N2 http://haskell.pastebin.com/m1e9be482
19:25:58 <dolio> The product version would be a nicer record system.
19:26:03 <ezyang> like... anonymous data types?
19:26:19 <Cale> tomberek: and you're compiling with -threaded, yeah?
19:26:19 * ezyang shivers 
19:26:21 <twink> dolio: Yeah, it'd help with nameclashes on records.
19:27:28 <dolio> I don't think any haskell implementation has done variants, though. Hugs has some sort of extensible record extension.
19:27:31 <tomberek> Cale: yep
19:27:55 <twink> TREX is row types/kinds -based IIRC
19:28:33 <dolio> Yes, well, that's what I'd expect variants to be based on, as well.
19:28:40 <tomberek> Cale: that's the wierd part, the behavior is opposite of expected.  It is twice as slow with -N2.
19:28:49 <dolio> Because row polymorphism is great.
19:30:17 <twink> If it works better than subtyping, I guess we grab onto it.
19:30:48 <Accidus> Sheesh. It's late.
19:30:56 <Accidus> Okay, I'm off. This is not going to be finished tonight.
19:31:01 <shapr> 9:30pm?
19:31:11 <Accidus> 3:30am
19:31:14 <shapr> oh
19:31:37 <Accidus> Thanks for everyone who helped me with the decription
19:31:41 <Accidus> decryption
19:31:41 <Saizan> tomberek: it uses more CPU time with -N2 but less wall clock time
19:32:07 <ezyang> hmm, looking at Neel Krishnaswami's slides on row polymorphism and being slightly confuzzled
19:32:08 <Warrigal> Is it 9:30 in the entire Central time zone or something?
19:32:25 <dolio> Of course, no one's bothered implementing it, which probably means no one really cares about actually having it.
19:32:33 <Accidus> Ooh... Row polymorphism....
19:32:38 <ddarius> Neel Krishnaswami is a trig cookie.
19:32:40 <Accidus> hrmph. Must... leave...
19:32:42 <tomberek> Saizan: for me it is the opposite
19:32:46 <ezyang> huh?
19:33:10 <Warrigal> Accidus: meditate on the question "How do I feel about leaving?"
19:33:12 * ddarius eyes dolio.
19:33:31 <Warrigal> If you do it right, you'll end up with a meaningful answer.
19:33:34 <Accidus> I'm just going to sleep. No meditation.
19:33:43 <Accidus> too tired.
19:34:02 <Warrigal> I was proposing that meditation as a method of leaving. I guess sleeping is another good method!
19:34:04 <Accidus> Sheesh. Pulling two almost alnighters in a row. I just want to be past this proposal.
19:34:39 <Accidus> Ciao
19:35:57 <ezyang> oh, is row polymorphism just letting the extra info come along for the ride in the function?
19:36:44 <ezyang> it smells a little bit like typeclasses
19:37:20 <dolio> ddarius: As far as I know, the "get extensible records into GHC" movement roughly stops at people around here, or on mailing lists saying "that'd be nice" once in a while.
19:39:02 <dolio> ezyang: Row polymorphism would essentially add a new kind and new kind formers to the type language.
19:39:18 <ezyang> Hmmm.
19:39:21 <Saizan> tomberek: btw, fixing a strictness bug with your way of calculating fib gives better results for the parallel code too :)
19:39:33 <dolio> So, they're like type classes inasmuch as type classes sort of let you define new kinds.
19:39:50 <ezyang> I guess I say they smell like typeclasses because I can get similar effects with typeclasses.
19:39:56 <twink> How much can there really be to do with Fibonacci?
19:39:58 <tomberek> Saizan: what do you mean?
19:40:03 <dolio> Meaning you can use type classes to hack some row polymorphism into the type system.
19:40:26 <ezyang> If I say "this function takes records with field a", it translates roughly into "this function takes types that have the AField typeclass defined for them"
19:40:31 <ezyang> and I don't lose information.
19:40:32 <ezyang> yup
19:40:36 <dolio> ezyang: HList is extensible records and row polymorphism implemented in Haskell.
19:41:04 <ezyang> I should figure out how HList works under the hood.
19:41:15 <scutigera> ezyang: so it takes _any_ type that has the field a in it ?
19:41:15 <scutigera>  
19:41:34 <ezyang> the annoying bit is you have to define AField instances for anythin gyou care about
19:42:04 <Saizan> tomberek: http://haskell.pastebin.com/m365d0ef8
19:43:10 <ddarius> twink: The Fibonacci sequence is absolutely rife with mathematical significance.
19:43:44 <tomberek> Saizan: ok, I think I get that.  It makes all the calculations go to completion?
19:44:15 <Saizan> tomberek: it just makes the sums evaluated as they go, instead of building a huge thunk
19:44:53 <tomberek> um...
19:44:55 <dolio> ezyang: Implementing a good record system with type classes is a lot of work, though. It's not just defining a class for each field you want.
19:45:13 <Saizan> dolio: a thing that always annoyed me with HList is that because of how typeclass resolution work you don't get as much unification as you'd want
19:45:23 <dolio> Because you want to be able to define record types on the fly.
19:45:44 <ezyang> dolio: Fair enough
19:46:06 <dolio> And you want things like: { a :: t, b :: u | r } is the same type as { b :: u, a :: t | r }.
19:46:12 <twink> ddarius: Its significance can be enormous, but programming it quickly runs out of tasks to carry out after using some of the O(lg(n)) recurrences and so on.
19:46:16 <roboshibby> hey guys, what's the haskell concept for invoking a method?
19:46:23 <roboshibby> like, running a function
19:46:41 <ezyang> roboshibby: erm, come again?
19:46:50 <tomberek> Saizan: that fixed it!
19:47:08 <ezyang> dolio: Well, I think typeclasses would give you that
19:47:19 <tomberek> Saizan: except now both-N2 and without it take the same amount of time... or is that -N2 opional?
19:47:43 <Saizan> tomberek: it isn't
19:47:43 <dolio> ezyang: Or, possibly, < a :: t, b :: u | r > is the same row as < b :: u, a :: t | r >, so it automatically works for both records and variants.
19:47:54 <Saizan> tomberek: are you compiling with -O2 -threaded ?
19:48:00 <tomberek> Saizan: i am
19:48:00 <ezyang> mmm, yeah. That might be a little tricky.
19:48:15 <ezyang> I've never quite figured out what to do about punning
19:48:27 <c_wraith> Man, I'm getting temporarily paranoid about space leaks.  Someone reassure me that thunks that aren't held anywhere can't leak.
19:48:44 * ezyang reassures c_wraith 
19:48:49 <Alpounet> hp2any may be of help
19:49:19 <Saizan> tomberek: i get these results with 6.12.1 http://haskell.pastebin.com/m19ea31f8
19:49:29 <pikhq> c_wraith: Anything not referenced is garbage collected.
19:49:39 <dolio> The way HList works, I think, is that it has type-level constructs for constructing rows, and probably a type class representing the proper equivalence relation on rows.
19:49:45 <roboshibby> well in haskell, how do you 'call' code?
19:50:03 <pikhq> roboshibby: seq.
19:50:09 <ezyang> roboshibby: func arg1 arg2 arg3
19:50:18 <scutigera> roboshibby: that's right
19:50:19 <ezyang> except it's lazy, so it won't get called unless something needs it :o)
19:50:32 <tomberek> Saizan:  that's what I am trying to acheve..... is there something like some default compilation or runtime flags that I might have messed up somehow?
19:50:34 <roboshibby> what if you want to observe the result?
19:50:36 <ezyang> dolio: That was the impressoin I got from skimming the paper.
19:50:38 <roboshibby> would it still not run?
19:50:58 <ezyang> roboshibby: it would have to be in the IO monad, in that case
19:51:04 <pikhq> roboshibby: If you observe the result, then you will run the function until such time as the result can be observed.
19:51:13 <scutigera> roboshibby: sure if you putStrLn $ show result it will be evaluated
19:51:30 <pikhq> Unless by "observe the result" you mean "have a side effect" rather than "get the value in a pattern match".
19:51:31 <Saizan> tomberek: not that i'm aware of
19:51:49 <roboshibby> i mean like, get the value from a method
19:52:10 <scutigera> roboshibby: you mean like #c++ ?
19:52:22 <Saizan> > let x = [1..3] in x
19:52:24 <lambdabot>   [1,2,3]
19:52:32 <Saizan> > let x = map (+1) [1..3] in x
19:52:33 <lambdabot>   [2,3,4]
19:53:28 <Saizan> roboshibby: why are you asking this?
19:53:40 <scutigera> strictness annotations would "force" evaluation, right ?
19:53:49 <Saizan> not really
19:54:19 <Saizan> > const 1 (id $! undefined)
19:54:21 <lambdabot>   1
19:54:26 <Saizan> > (id $! undefined)
19:54:28 <lambdabot>   * Exception: Prelude.undefined
19:54:31 <scutigera> :t const
19:54:32 <lambdabot> forall a b. a -> b -> a
19:54:41 <Saizan> so it's all a matter of chaining data-dependencies
19:54:45 <ezyang> const 1 $! (id $! undefined)
19:55:00 <Saizan> except for side-effects of IO actions
19:55:04 <ezyang> > const 1 $! (id $! undefined)
19:55:06 <lambdabot>   * Exception: Prelude.undefined
19:55:11 <roboshibby> Saizan: i guess because im trying to figure out what kind of interaction it is to 'run' code. (as in, invoke a method) i look at the consequence of a function as a value which you can observe lik eany other
19:55:18 <Saizan> which gets executed by the RTS when it unfolds main
19:55:27 <roboshibby> is it a load? is it a store?
19:55:39 <roboshibby> doesn't seem a 3rd one 'run' is necessary
19:55:41 <ezyang> roboshibby: "Do not concern yourself with such low-level trivialities"
19:56:01 <roboshibby> thanks for your suggestion ezyang
19:56:04 <scutigera> really, the high level trivialities are more than enough work
19:56:27 <ezyang> To be more serious
19:56:43 <Saizan> at the lowlevel each expression gets stored as a closure on the heap until for some reason it needs to be evaluated
19:57:02 <ezyang> I have no idea what Haskell does under the hood to make its laziness work. I have some idea what a lazily evaluated language might do, but only because I implemented thunks in a metacircular evaluator in Scheme.
19:57:19 <Saizan> (unless optimizations can optimize this away)
19:57:25 <roconnor> ezyang: I was very surpised that GHC has a stack
19:57:28 <scutigera> if strictness annotation doesn't force eval, then what's the point of them ? as usual I'm misunderstanding a simple concept I thought I understood :-(
19:57:33 <ezyang> And even this is a misrepresentation, due to optimizations
19:57:36 <roconnor> I typically imagine a graph reduction machine
19:58:03 <roboshibby> nice
19:58:26 <Saizan> scutigera: the point is to add more data-dependencies so that GHC can decide to evaluate things earlier without changing the semantic of your code
19:58:28 <ezyang> roconnor: I... guess it's kind of hard not to have one? ;-)
19:59:01 <roconnor> ezyang: the graph reduction machine I imagine doesn't have one.  I wonder if the Clean complier uses a stack.
19:59:04 <Saizan> scutigera: you still need some source of forcing though
19:59:19 <dolio> roconnor: Well, you need a stack to remember where to go after you're done rewriting part of the graph.
19:59:21 <roboshibby> roconnor: how could it not have a stack?
19:59:32 <Saizan> scutigera:  const 1 (id $! undefined) -- here (id $! undefined) is ignored because const doesn't use its second argument at all
19:59:41 <roconnor> (and I mean ignoring the stack for prim ops)
19:59:57 <roconnor> dolio: don't you always do reduction at the top of the graph?
20:00:07 <ezyang> Saizan: But I could argue that you've added the strictness annotation just for the (id $! undefined) part of the world
20:00:19 <ezyang> so const gets to not use that at all
20:00:24 <roconnor> dolio: oh, you might have to decend the graph to do more reduction?
20:00:41 <Saizan> yeah, but if strictness annotations forced evaluation that undefined would get forced.
20:00:45 <roconnor> meh, I bet you could do something nice with back pointers instead of a stack.
20:00:45 <scutigera> Saizan: but the expression is going to be eval'ed anyway if there is a source of forcing, so it seems as though the strictness still doesn't do anything.
20:00:53 <ezyang> Saizan: Ah, I see what you're doing
20:00:55 <dolio> No. let x = 1 + 2 ; y = x + x in y + y
20:01:21 <roconnor> dolio: that is a counter example to my backpointer talk?
20:01:26 <Saizan> scutigera: well, there's a difference between "const 1 undefined" and "const 1 $! undefined"
20:02:28 <dolio> It was an example where you need to rewrite at a place other than the 'root' of the graph first.
20:02:39 <Saizan> scutigera: the strictness annotation makes the evaluation of the whole expression depend on the evaluation of undefined
20:02:53 <roconnor> dolio: ya, but can't you maybe decend without a stack?
20:02:55 <Saizan> scutigera: without the annotation there's no such dependency
20:03:29 <Saizan> scutigera: but you still need to get to a point where the evaluation of "const 1 $! undefined" is needed
20:03:47 <scutigera> Saizan: ah, got it. thanks.
20:03:54 <dolio> roconnor: I don't see how back-pointers are really any different than a stack. You've just encoded the stack by adding overhead directly to every node in the graph.
20:04:02 <Saizan> scutigera: ultimately the need to evaluate something will come from IO
20:04:29 <roboshibby> dolio, well-sad
20:04:31 <scutigera> Saizan: yes, saw that very early on.  big loops with no prints run real fast :-)
20:05:14 <roconnor> dolio: either by doing crazy pointer xoring tricks or by simply replacing the decending pointer temporarily with an accending pointer, kinda vaguely like a zipper if we make a functional analogy to an imperitive algorithm.
20:05:16 <Saizan> right, nice optimization, eh?:)
20:05:29 <roconnor> dolio: maybe we could do it in constant space
20:05:44 <roconnor> dolio: by ya, the onus is on me to show it can be done.
20:05:47 <roconnor> but ya
20:05:49 <scutigera> Saizan: yep.  mlton, even though ml is strict, will also do the same thing...
20:05:57 * Alpounet just discovered TTFP
20:06:21 <roconnor> Alpounet: that is what got me into Haskell and Coq 10 years ago
20:06:36 <roboshibby> ttfp?
20:06:42 <roconnor> @what ttfp
20:06:42 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
20:07:01 <Alpounet> roconnor, what were you working with before ?
20:07:07 <Alpounet> ML ?
20:08:11 <roconnor> I knew of ML and liked it, but I didn't really do functional programming
20:08:12 <roboshibby> nice
20:08:23 <roconnor> someone tried to introduce me to Haskell in 1998
20:08:33 <roconnor> but I was like, meh, I don't see how this is better than ML.
20:08:40 <dolio> roconnor: Well, as I recall, the general definition of a zipper for mu F is something like Stack [deriv F (mu F)] * mu F.
20:08:59 <ddarius> It wasn't just immediately -prettier- than ML?
20:09:00 <dolio> Er, Stack (deriv ...
20:09:05 <roconnor> dolio: sure, but the space is constant, assuming linear use of the zipper.
20:09:27 <Alpounet> roconnor, heh ok. TTFP seems very nice
20:09:29 <scutigera> roconnor: I'm not sure you can say it's "better" now.  ML is a gentler intro to functional than haskell is, and still very powerful.
20:09:36 <Alpounet> I will give it a whirl after TAPL.
20:09:56 <roconnor> dolio: I guess I mean that there it can be done in constant space (rather than caring if there is an implicit or explicit stack like structure somewhere).
20:10:25 <roboshibby> yes i agree. ultimately, structure-irrespective, it boils down to context
20:10:30 <roconnor> scutigera: Haskell is certainly better than ML. :D  I can certainly say this on this channel :D
20:11:35 <scutigera> roconnor: of course it is, of course it is, I meant no disrespect, grovel, grovel.
20:11:41 <roconnor> :D
20:12:28 <roconnor> I've been working with ocaml lately.  It is kinda frusterating, but I suppose I really need to give it a change.  It is much easier to see what ocaml is missing compared to Haskell than to see what new things ocaml has to offer.
20:12:34 <roconnor> to give it a chance.
20:14:06 <scutigera> roconnor: yes I went through an ocaml "phase" also. ML with funny syntax and objects. meh.
20:14:30 <scutigera> roconnor: darn good performance though.
20:14:31 <roconnor> I'm most intersted in the open varients
20:14:36 <roconnor> which I don't understand at all
20:14:53 <Alpounet> they are very nice
20:14:55 <dolio> roconnor: Wouldn't it only be constant space if you consider the entire graph to already be resident? That's true of GHC's stack, too. There won't be more pushes than biggest depth of the graph, so it's O(1), obviously. :)
20:15:15 <Alpounet> that and the parametrized modules ("module functors")
20:15:40 <roconnor> dolio: I mean the traversal of the graph is in constant space.  Obviously graph segments have to be copied during some "reductions"
20:16:24 <scutigera> instance Num Symbolic where ... : terminology: is Symbolic an instance of the Num type class ?
20:17:54 <dolio> roconnor: Maybe I'm off, but I think you're giving the stack a harder time than the zipper.
20:18:24 <roconnor> I don't think so, but I'm being so vague that you might be right.
20:18:42 <roboshibby> roconnor: are you working to eliminate needs for stacks?
20:19:06 <roconnor> roboshibby: well, there is no stack in my mental model of a haskell interpreter.
20:19:07 <dolio> If we're using a zipper, and we keep (say) rewriting the current node into something, and descending into it, in what sense is that constant space?
20:19:42 <dolio> Which is what you'd do with the zipper in the case where with a stack, you'd keep pushing frames in an infinite loop.
20:19:47 <dolio> (I think.)
20:19:48 <roconnor> roboshibby: but my mental model also has back pointer, adding one word to every node in the graph.
20:20:19 <dolio> Like 'sum [1..] :: Integer'.
20:20:33 <roboshibby> roconnor: what dont you like about the idea of a stack?
20:20:53 <roconnor> roboshibby: it tends to run out before the heap does
20:21:06 <dolio> We keep rewriting the graph into a bigger and bigger graph.
20:21:07 <roboshibby> hm
20:21:15 <roboshibby> interesting
20:21:21 <roconnor> dolio: only reductions are increasing the graph size, not the traversal.
20:21:25 <roboshibby> well i always like the idea of challenging generally accepted ideas
20:21:30 <ddarius> roconnor: You can store the stack on the heap or simply grow it arbitrarily.
20:21:46 <roconnor> ddarius: I guess that is true.
20:22:17 <roconnor> dolio: in ghc when you do sum [1..] the stack runs out of space
20:22:25 <ezyang> > sum [1..]
20:22:30 <lambdabot>   mueval: ExitFailure 1
20:22:31 <roconnor> dolio: it isn't the linked list that is becoming too big
20:22:46 <roconnor> er
20:22:48 <dolio> roconnor: That's because it has checks on the memory designated 'stack' to detect infinite loops.
20:22:53 <jmcarthur> how much time spent is GC is considered a lot?
20:22:55 <dolio> You can make it do heap checks, too.
20:23:00 <roconnor> dolio: is that the only reason?
20:23:05 <dolio> Yes.
20:23:08 <roconnor> oh
20:23:12 <ezyang> jmcarthur: probably depends on what you're doing
20:23:18 <roconnor> that's a little lame
20:23:40 <dolio> I think there even used to be a way to turn off stack overflows. I'm not sure if you still can.
20:23:44 <roconnor> wow
20:23:45 <jmcarthur> ezyang: yeah i kind of suspect that, but i'm just wondering ballpark. is 20% a lot? 10%?
20:23:51 <scutigera> jmcarthur: generally if I see > 20% something probably needs some optimization
20:24:19 <jmcarthur> alright, so seeing 11% is probably nothing to be worried about?
20:24:29 <jmcarthur> i've never had a program spend much more than that
20:24:30 <roconnor> dolio: thanks for this
20:24:46 <scutigera> jmcarthur: I generally see ~ 10%
20:24:51 <jmcarthur> okay, thanks!
20:24:53 <roconnor> dolio: loops can also be detected on constant space though it does take twice as long
20:25:22 <roconnor> er, well it might be hairy to do in a graph reduction machine
20:25:28 <Jonno_FTW> how can I make this work: lines $ readFile "sometext.txt
20:25:51 <Jonno_FTW> "
20:26:01 <roconnor> I think it should be possible.
20:26:16 <roconnor> lines `fmap` readFile "sometext.txt"
20:26:37 <roconnor> if you import Control.Applicative you can even do lines <$> readFile "sometext.txt"
20:27:07 * ezyang <3 <$> 
20:27:23 <ezyang> Jonno_FTW: <$> == fmap
20:27:54 <Jonno_FTW> where is <$> ?
20:28:11 <ezyang> The operator observes the similarity between ($) :: (a -> b) -> a -> b and (<$>) :: (a -> b) -> f a -> f b
20:28:11 <Jonno_FTW> oh right
20:29:14 <pikhq> <$> is in Control.Applicative.
20:29:26 <hexpuem> what performance implications does mallocForeignPtr have? If im filling out an array through FFI: is allocating with allocaBytes + peeking for results to construct a new Data.Vector array through a list better in the long run?
20:30:00 <tensorpudding> can you specify a literate haskell file using a pragma?
20:30:22 <ezyang> I think usually you have lhs?
20:32:40 <Jonno_FTW> How come this won't work?
20:32:46 <Jonno_FTW>  fmap (\ x -> tail$dropWhile (/= ':') x) (lines <$> readFile "sometext.txt")
20:32:46 <copumpkin> hard to say
20:33:01 <copumpkin> you're fmapping twice!
20:33:23 <jmcarthur> oh well shoot my gc time goes up when i don't do profiling
20:33:28 <Axman6> fmapfmapfmap
20:33:34 <Jonno_FTW> shouldn't it fmap the lamda over the list?
20:33:43 <copumpkin> no
20:33:52 <Jonno_FTW> then how do i do it?
20:33:56 <tensorpudding> ezyang: yes, usually
20:33:56 <copumpkin> if you put that inside the parentheses it could
20:34:12 <Jonno_FTW> how?
20:34:21 <pikhq> It'll apply that lambda to the contents of that IO value there...
20:34:23 <tensorpudding> but i believe that ghc has a switch that you can use to force it to parse it as literal
20:34:23 <roconnor> Jonno_FTW: you want  fmap (\ x -> tail$dropWhile (/= ':') x) <$> (lines <$> readFile "sometext.txt")
20:34:32 <Jonno_FTW> oh
20:34:44 <copumpkin> map (tail . dropWhile (/= ':')) . lines <$> readFile "sometext.txt"
20:34:47 <roconnor> or (fmap (\ x -> tail$dropWhile (/= ':') x) . lines) <$> readFile "sometext.txt")
20:34:50 <ezyang> tensorpudding: aha
20:35:08 <ezyang> You should figure out what the type of x is. It will make you a lot hapier
20:35:11 <ezyang> *happier
20:35:21 <copumpkin> nah, you'll be really sad
20:35:30 <ezyang> (to Jonno_FTW)
20:35:38 <copumpkin> yeah, same here
20:35:40 <roconnor> Jonno_FTW: you should take some time to understand the type of every subexpression there
20:35:50 <roconnor> cause it is getting a bit hairy
20:36:02 <Jonno_FTW> i just didn't get why i couldn't apply the lambda over the list
20:36:09 <copumpkin> because you have an IO too
20:36:24 <copumpkin> if you'd used map instead of fmap you would have had a more obvious error message, possibly
20:36:25 <Axman6> you weren't applying it over the list, but to the list itself
20:37:16 <dolio> Wow, don't run foldr (+) 0 [0..] with +RTS -K800M.
20:37:20 <copumpkin> :t map (tail . dropWhile (/= ':')) . lines <$> readFile ?f
20:37:21 <lambdabot> (?f::FilePath) => IO [[Char]]
20:37:32 <dolio> Whatever it did, it didn't stop with an 800 megabyte stack.
20:37:37 <tensorpudding> -K800M reads like KABOOM to me
20:37:47 <copumpkin> that's cute
20:37:48 <roboshibby> 800mB stack? damn
20:37:51 <Axman6> -K4800M
20:38:00 <copumpkin> :P
20:38:02 <dolio> Actually, I guess the problem would also be giant heap usage.
20:38:25 <dolio> So I had whatever heap usage 800M of stack could allocate as well.
20:38:32 <dolio> Which meant my computer locked up.
20:39:13 <tensorpudding> ouch
20:40:28 <ivanm> Axman6: I met Clem this morning
20:40:35 <Axman6> oh good
20:40:44 <ivanm> he asked if I'll tutor for him, including some 2nd year course
20:40:53 <Axman6> he's one of the coolest lecturers i've had
20:40:58 <ivanm> I told him I'd have to see for the 2nd year one, because I'm a little weak on theory :s
20:40:58 <Axman6> nice, which courses?
20:41:05 <Axman6> heh
20:41:14 <Axman6> 2600?
20:41:36 <dolio> roconnor: Anyhow, I don't see any way to turn off stack overflow messages (-K0 doesn't work), but you can always set it to something ridiculous like 30000M, and it won't overflow until it uses all your memory many times over.
20:41:38 <copumpkin> http://en.wikipedia.org/wiki/2600_The_Hacker_Quarterly
20:41:45 <roboshibby> wow
20:41:53 <roboshibby> i still have my 2600 collection
20:41:58 <ezyang> That cover is classy.
20:42:16 <ivanm> Axman6: dunno, some induction, etc. based one
20:42:24 <Axman6> sounds like 2600
20:43:01 <Axman6> i'd like to tutor that one, but i'm not too good at propositional logic
20:43:16 <Axman6> (though, i managed to grok it in the exam, and pulled of an HD :P)
20:43:22 <copumpkin> need moar logic
20:43:32 <roboshibby> mmmrrm
20:43:36 * copumpkin invites Axman6 to #agda
20:43:51 <ezyang> Oh you grad students :-)
20:43:55 <Axman6> it was strange for me, the more the coourse went on, the easier it got (ie, the more it came close to the stuff i'd already done in haskell, the easier it was)
20:44:05 <roboshibby> logic isnt just for students of university
20:44:05 <Axman6> -o
20:44:09 <roboshibby> it's for thinking people
20:44:21 <copumpkin> pff who needs thought
20:44:30 <ivanm> thinking? what's that?
20:44:39 <Axman6> it's interesting where i manage to find propositional logic in everyday life now though
20:44:46 <ezyang> I once took two classes in parallel; one was "go from transistors to a mini operating system", and one was "build an operating system from scratch".  The second class made the last half of the first class trivial :-)
20:45:03 <copumpkin> I bet
20:45:44 <ezyang> except, the stack of the cpu we built went in the opposite direction... that confused the heck out of me
20:45:45 <Jonno_FTW> I got stuck again on: writeFile "output.txt"  (printf $ fmap unlines $ fmap (\x->tail$dropWhile (/= ':')x) <$> (lines <$> readFile "sometext.txt1"))
20:45:53 <ivanm> Axman6: anyway, I'm in the room that was formerly known as the aquarium...
20:46:03 <ezyang> you need a monad
20:46:05 <copumpkin> Jonno_FTW: what's the printf for?
20:46:10 <Axman6> i'll have to come and visit you next week sometime
20:46:17 <copumpkin> Jonno_FTW: anyway, you'll probably want a =<< in there
20:46:22 <Jonno_FTW> i want to to be able to write out each original line on a newline
20:46:27 <copumpkin> Jonno_FTW: or you could just work in a do block and not get confused :P
20:46:30 <Jonno_FTW> containing the edited text
20:46:46 * ezyang thinks doing it w/o a do block builds character! 
20:46:47 <Axman6> there's no need for printf there at all :\
20:47:06 <Jonno_FTW> then how do i get them on the newline?
20:47:18 <copumpkin> unlines already did that?
20:47:36 <Axman6> that's exactly what unlines does
20:47:37 <Jonno_FTW> so will writefile put them on a new line?
20:47:46 <Axman6> > unlines ["hello","world"]
20:47:47 <lambdabot>   "hello\nworld\n"
20:47:56 <ezyang> :t unlines
20:47:57 <lambdabot> [String] -> String
20:48:00 * copumpkin still thinks Jonno_FTW would have a much easier time at first if he went with a do block
20:48:12 * Axman6 agrees completely
20:48:18 <Axman6> sohum!
20:48:38 <sohum> Axman6!
20:48:47 <ezyang> Jonno_FTW: So I have to ask, are you in the "need to get this working" mood or the "I want to understand what's going on" mood
20:48:48 <Jonno_FTW> well, the input looks like this: RSA-DK:195.24.8.232-195.24.8.239 EDS:195.24.11.48-195.24.11.63
20:48:50 <Axman6> how's it going?
20:48:53 * sohum insert slowmo running towards each other in field of flowers scene
20:49:06 <Jonno_FTW> except with a newline
20:49:08 * Axman6 ducks at the last second for the tackle!
20:49:18 * sohum crap
20:49:36 <Jonno_FTW> i just want the preceeding text removed, leaving a pair of ip's, each pair on its own line
20:50:05 <Jonno_FTW> and the output written to a file
20:50:06 * ezyang supposes it would be improper to suggest Parsec at this point 
20:50:18 * Axman6 agrees again
20:50:43 <ddarius> With a little words, unlines, dropWhile, map, and read this will all be done in seconds.
20:50:54 <Jonno_FTW> that's what I was trying
20:51:02 <ivanm> ezyang: yeah, let's use polyparse
20:51:04 * ivanm ducks
20:51:12 * ezyang giggles 
20:51:36 <ezyang> Jonno_FTW: Here's what I suggest
20:51:52 <ezyang> Fire up GHCi, and figure out what function that has /no/ IO involved does what you want
20:51:57 <ezyang> put that in a function.
20:52:03 <ezyang> Then write the glue to make it talk to IO
20:52:14 <Jonno_FTW> that's the part I can't do
20:52:16 <Jonno_FTW> the glue
20:52:37 <Axman6> because you're trying to do it the hard way
20:52:40 <Axman6> use a do block
20:52:41 <ezyang> Well, you've got IO and pure computation tangled up, and I suspect it's confusing you.
20:52:52 <roconnor> @tell conal http://www.haskell.org/haskellwiki/Talk:IO_Semantics
20:52:52 <lambdabot> Consider it noted.
20:53:20 <Axman6> do input <- readFile blah; let result = f input; writeFile baz result
20:53:35 <ddarius> interact f
20:55:32 <ClaudiusMaximus> are there any nice abstractions for caching resources that are expensive to allocate and deallocate?
20:55:46 <ezyang> "a giant array"
20:55:50 <Axman6> or a map
20:55:51 <jmcarthur> you mean like memoization?
20:56:21 <copumpkin> ClaudiusMaximus: allocation is pretty cheap in GHC haskell
20:57:08 <ClaudiusMaximus> copumpkin: i mean allocating resources from outside the haskell world, things like OpenGL framebuffers etc
20:57:35 <ezyang> Ahhh
20:58:07 <ClaudiusMaximus> maybe i should benchmark some stupidly naive code first before worrying too much about this stuff...
20:58:30 <ezyang> Yes you should.
20:58:55 <Axman6> sohum: what courses are you taking this semester?
20:59:39 <sohum> oh gods don't even ask me that question
20:59:47 <Axman6> heh
20:59:59 * sohum stabs prereqs and honours years
21:00:13 <ivanm> sohum: why?
21:00:30 <Axman6> this is what you get for taking a weak three (?) year degree :P
21:01:06 <chrissbx> Is there some optimization going on to automatically turn a ++ b into generating a with b as tail in the first place?
21:01:19 <Axman6> no
21:01:27 <ezyang> Axman6: Wait, really?
21:01:31 <Axman6> because, that's exactly what a++b does ;)
21:01:41 <ezyang> oh, haha :-)
21:01:48 <Axman6> well, it might if they're static values
21:01:58 <sohum> ivanm: basically, because I did most of my required courses and now have to make Big Decisions on whether I want to do some more advanced CS stuff now or leave that til next year and what I can leave for next year and if I don't do the ACSS now I can do some linguistics maybe or suchlike...
21:02:01 <Jonno_FTW> using a do block has got me more confused
21:02:12 <ivanm> what's ACSS?
21:02:15 <sohum> Axman6: oh no, it's because the course is /too good/ :P
21:02:20 <chrissbx> Even if a is not static, it could turn [] in the generation of a into b.
21:02:21 <Axman6> Jonno_FTW: did you see what i wrote? i don't think it could be simpler :\
21:02:22 <sohum> ivanm: "advances CS stuff"
21:02:25 <ezyang> Jonno_FTW: Why don't you paste what you have?
21:02:26 <sohum> *-ed
21:02:27 <ivanm> ahhh
21:02:45 <sohum> Axman6: *degree
21:02:56 <Axman6> pfft
21:02:58 * ezyang thinks prereqs are bogus and people should take classes for which they have not gotten the prereqs for >:-) 
21:03:07 <ivanm> sohum: see, I squeezed two degrees (one of which had 2 majors) into 4 years... _then_ I realised that there weren't many maths honours subjects I could do because i hadn't done the pre-reqs for them :p
21:03:11 <Axman6> you don't get to electronics, sp pfft :P
21:03:14 <Axman6> so*
21:03:17 <copumpkin> ezyang: I agree
21:03:26 <ivanm> ezyang: I think it's bogus when people take subjects because they're easy...
21:03:36 <sohum> ivanm: hehehe, yeah
21:03:38 <ezyang> So what if you actually needed the prereqs: time to crash course in those subjects!
21:03:48 * ezyang fondly remembers learning assembly in a week :-) 
21:03:57 <ivanm> heh
21:04:07 <sohum> ivanm: I should really draw out a graph of the prereqs, postreqs, coreqs, and suchlike of all the courses in the uni
21:04:17 <pikhq> ezyang: Quite reasonable, really.
21:04:28 <sohum> Axman6: why would I want to do electronics?
21:04:33 <Jonno_FTW> http://pastebin.ws/f8ffn4 is what i have now
21:04:40 <Axman6> sohum: so you can get a job >_>
21:04:41 <Axman6> :P
21:04:49 <copumpkin> F that
21:04:58 <sohum> Axman6: you're saying this in #haskell...
21:05:02 * sohum ducks
21:05:19 * Axman6 is after a job with haskell
21:05:20 <ivanm> sohum: heh
21:05:39 <ivanm> sohum: see, before I started my degree, I kinda did something like that for all the math, physics and IT courses available...
21:05:43 <sohum> (unrelated but awesome: http://ghcsparc.blogspot.com/2010/02/memory-barriers-and-ghc-6121.html )
21:06:08 <sohum> ivanm: something like what, sorry?
21:06:23 <ivanm> creating a graph of all prereqs, etc.
21:06:32 <ivanm> sohum: it's not awesome, in that I figured I could meet ben when I got to ANU... and then I find he's defected to UNSW!
21:06:34 <sohum> (we'll miss ben, but he gets to work on DPH!)
21:06:51 <Jonno_FTW> needs more abbreviations
21:06:53 <sohum> ivanm: ah, well, you should've come earlier!
21:07:06 <sohum> ivanm: how hard was it to make said graph?
21:07:17 <ozataman> hey all.. i'm having some trouble doing "darcs get http://patch-tag.com/r/mae/happstack"... it's telling me darcs failed:  Couldn't fetch `0000000801-b6f0097a5c27fcb92647192e835613dd3a9347878f74a8ce9c06381823c5c1c9'
21:07:19 <ozataman> any ideas?
21:07:41 <Axman6> ivanm: if you write the software to make a graph of all courses and prereqs, and whether you can make them or not, and put a nice web interface on it, i'd hu7g you, and ANU should hire you
21:07:48 <ezyang> Jonno_FTW: your code is very strange
21:07:58 <ivanm> sohum: not that hard, since I cut out all DB subjects that I didn't have to do, etc.
21:08:01 <Axman6> because their timetabling and course selection sites are fucking pathetic
21:08:10 <ivanm> ozataman: wipe what you've gotten and try again?
21:08:17 <sohum> Axman6: given the structured data - which presumably exists at /some/ level of their system, it shouldn't be too difficult
21:08:20 <ivanm> Axman6: heh
21:08:23 <ozataman> ivanm: I tried that.. didn't help unfortunately
21:08:24 <ivanm> sohum: exactly
21:08:25 <sohum> ivanm: ah, so you did it by hand?
21:08:25 <Jonno_FTW> ezyang: how so?
21:08:29 <Axman6> sohum: you'd assume so
21:08:34 <ivanm> Axman6: it's stuff like that what my honours thesis was actually about :p
21:08:35 <ezyang> (\x->tail$dropWhile (/= ':')x) xs == tail $ dropWhile (/= ':') xs
21:08:48 <Axman6> ivanm: good!
21:08:52 <ivanm> sohum: yeah, there weren't that many (that were relavent and sounded interesting)
21:08:54 <Axman6> fucken get to it man!
21:08:59 <sohum> ivanm: *nod*
21:09:07 * ivanm points Axman6 to his Graphalyze library
21:09:09 <ezyang> input is of type String, not IO String, so you don't need the fmap anymore
21:09:17 <ivanm> Axman6: eh, I'm too busy getting my new machine here at uni set up
21:09:23 <ivanm> besides, it only has ghc-6.8! :@
21:09:32 <Axman6> yeah :\
21:09:39 <Axman6> talk to Bob i think it is
21:09:56 <Axman6> he seems to be the one who looks after all the machines software
21:10:03 <Axman6> get them to out 6.10.4 on at least
21:10:07 <Axman6> if not 6.12.1
21:10:17 <Axman6> tell them you _need_ it for your research
21:10:37 <sohum> huh, 6.12.1 is in debian unstable
21:10:44 <ivanm> Axman6: yeah, they said they're waiting for the next ubuntu LTS :s
21:10:55 <Axman6> URGGGGGGGH
21:10:58 <Axman6> >_______<
21:11:03 <ezyang> fix those up, and then repaste, Jonno_FTW
21:11:07 <ivanm> Axman6: that's the next version of ubuntu ;-)
21:11:09 <sohum> that's not... that far away, right?
21:11:13 <sohum> like, a month or two
21:11:15 <ivanm> I'll send them an email next week asking for new emacs as well...
21:11:15 <Axman6> i don't care! screw ubuntu!
21:11:17 <ivanm> sohum: yeah
21:11:21 <ivanm> add in time for testing, etc.
21:11:27 * Axman6 rages at ANU some more
21:11:27 <sohum> yea
21:11:29 * ivanm had just gotten used to fedora at UQ...
21:11:35 <sohum> meh, I can see their pov
21:11:45 <ivanm> Axman6: I've been told that if I want, they can give me root access to this machine... but then they restrict my internets :s
21:12:00 <Axman6> ha
21:12:06 <Hunner> ivanm: you can compile ghc and cabal in your homedir just fine
21:12:41 * Axman6 can't
21:12:53 <Axman6> ghc neede more than 600MB of free space to compile etc
21:13:14 <Hunner> Ask for a chmoded local dir on the drive to put it in?
21:14:20 <Hunner> Some unis will give out research stashes to store data in
21:14:34 * Axman6 is an undergrad
21:14:41 <Jonno_FTW> ezyang: http://pastebin.ws/6d28sb
21:15:29 <Jonno_FTW> ignore the error in f xs
21:15:40 <Cale> Axman6: Why do you need to compile GHC?
21:15:50 <Axman6> because they have 6.8
21:15:59 <Cale> So?
21:16:02 <Cale> Get a binary
21:16:07 <Hunner> Axman6: then a chmodded dir? it takes 5 seconds of their time and isn't a security concern...
21:16:24 <ivanm> Hunner: yeah, I could...
21:16:31 <ezyang> :t (tail$dropWhile (/= ':')) xs
21:16:32 <lambdabot> Not in scope: `xs'
21:16:34 <ivanm> but I've never compiled it by hand before :s
21:16:36 <ezyang> :t (tail$dropWhile (/= ':'))
21:16:37 <Axman6> Cale: there's not enough room for that either
21:16:37 <lambdabot>     Couldn't match expected type `[a]'
21:16:37 <lambdabot>            against inferred type `[Char] -> [Char]'
21:16:37 <lambdabot>     In the second argument of `($)', namely `dropWhile (/= ':')'
21:16:47 <ivanm> Hunner: I have a whole scratch drive to do it in!
21:16:51 <Hunner> ivanm: It might be fun. Or you could just unpack the binary
21:16:56 <ivanm> ssshhh!
21:17:00 <Jonno_FTW> replace the dollar sign with .
21:17:11 <ezyang> I suggest you look carefully at that piece of code
21:17:11 * ivanm 's fingers are itching to just do "paludis -i ghc"
21:17:22 <Jonno_FTW> :t (tail.dropWhile (/= ':')) xs
21:17:23 <lambdabot> Not in scope: `xs'
21:17:25 <Jonno_FTW> :t (tail.dropWhile (/= ':'))
21:17:26 <lambdabot> [Char] -> [Char]
21:17:36 <ivanm> Axman6: apparently I can share my scratch drive...
21:17:58 <Axman6> > map (tail . dropWhile (/= ':')) ["test:thing","a:b"]
21:17:59 <lambdabot>   ["thing","b"]
21:18:04 <Jonno_FTW> > let f = (tail.dropWhile (/= ':')) in f "some:cuttoff"
21:18:05 <lambdabot>   "cuttoff"
21:18:13 <ezyang> there you go :-)
21:18:22 <ezyang> you can also do this process in GHCi, fwiw
21:18:26 <Axman6> > map (tail . dropWhile (/= ':')) . lines $ "test:thing\na:b"
21:18:27 <lambdabot>   ["thing","b"]
21:18:30 <Jonno_FTW> i was
21:19:03 <ezyang> you should probably s/fmap/map/; you don't need the generality and seeing it in side a do-block might make someone think it's lifting the function into IO, when it's not
21:19:37 <Hunner> #haskell is multiplayer ghci
21:19:38 * sohum is leaving this den of awful internet in a few hours, thank god
21:21:42 <Pisco_Sour> Why is Haskell suddenly so popular?
21:21:55 <Jonno_FTW> it WORKS!
21:22:07 <Axman6> ha
21:22:08 <sohum> and it's AWESOEM
21:22:08 <ezyang> congrats :-)
21:22:21 <twink> Pisco_Sour: It's suddenly popular?
21:22:24 <ivanm> Pisco_Sour: "suddenly"
21:22:27 * ezyang wonders, "was Jonno_FTW answering Pisco_Sour, or referring to his code" 
21:22:28 <ivanm> ?
21:22:35 <Axman6> Pisco_Sour: because it solves a hell of a lot of problems we're facing today, while being beautiful, fast, and mind bending
21:22:38 <Jonno_FTW>  input <- lines <$> readFile "bt_level1";  let output = unlines $ fmap f input;  writeFile "ipfilter.dat"  output
21:22:44 <ivanm> sohum: not awesome enough to check your spelling though...
21:22:53 <sohum> ivanm: that was post-sarcastic, though.
21:23:06 <Axman6> Jonno_FTW: urgh -_-, i see you still haven't been listening :P
21:23:35 <Jonno_FTW> ?
21:23:46 <monochrom> Haskell is mind-opening.
21:23:54 <scutigera> Pisco_Sour: many of were lurkers, waiting for the compiler to catch-up with the promise of haskell.
21:23:55 <Axman6> Jonno_FTW: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21923#a21923
21:24:13 <Jonno_FTW> ?
21:24:18 <Axman6> quit making your life harder by playing with Applicative stuff when you don't yet understand it
21:24:33 <Jonno_FTW> ....
21:24:39 <Cale> Playing with stuff is a good way to learn it
21:24:46 <Pisco_Sour> Thanks for the insight.
21:25:28 <Jonno_FTW> i replied with the fixed version Axman6
21:25:48 <medfly> you don't know Haskell! stop playing with it!
21:25:59 <scutigera> you'll go blind
21:26:14 <medfly> Pisco_Sour, I know some universities started teaching it
21:26:23 <medfly> Pisco_Sour, so that's a lot of people there
21:26:27 <Jonno_FTW> how do i perform system commands in haskell?
21:26:34 * Axman6 adds http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21923#a21925 to show off a little
21:26:49 <Pisco_Sour> What kind of applications do you build with it?
21:26:53 <monochrom> Jonno_FTW: Something in System.Process
21:26:54 <Axman6> everything
21:26:57 <Jonno_FTW> ok
21:27:05 <scutigera> yep, it's got good library support.
21:27:13 <ivanm> medfly: "started"?
21:27:21 <Cale> Pisco_Sour: That's a bit like asking what kind of applications you build with C++ or Java.
21:27:22 <ivanm> Haskell was in part designed to _be_ a teaching language
21:27:30 <ivanm> as such, they've been teaching haskell fromt he word go
21:27:48 <ivanm> Pisco_Sour: it's a general purpose programming language
21:27:53 <ivanm> you can do scripting in it as well
21:28:11 <scutigera> ivanm: scheme was much more of a teaching language and is very good for functional ideas.  lacks type system and of course is strict.
21:28:25 <Pisco_Sour> does it have a ui framework?
21:28:30 <Axman6> everything from web servers, to high performance computing, compilers, to games have been written in haskell
21:28:30 * ezyang thinks shell scripting has an unfair advantage since it uses precisely the same syntax ezyang uses on the terminal every day 
21:28:30 <Cale> Pisco_Sour: A few
21:28:35 <ivanm> define what you mean by "ui framework"
21:28:54 <Pisco_Sour> in the sense that qt is a "ui framework"
21:28:56 <QtPlatypus> scutigera: It has dynamic type system
21:29:12 <Cale> Pisco_Sour: There's Gtk2Hs, WxHaskell, OpenGL, SDL, and a number of other things.
21:29:18 <Axman6> Pisco_Sour: there are a few, though they're all bindings to things like qt or gtk
21:29:25 <Pisco_Sour> thanks, axman
21:29:31 <scutigera> QtPlatypus: yep. not sure which is better from a teaching point of few, strong typing or dynamic.
21:29:33 <Cale> There is a binding to Qt, but I'm not sure how well it works, as I've never tried it.
21:29:34 * Axman6 doesn't like gui apps
21:29:55 <Cale> I'd expect Qt to be hard to write bindings for.
21:30:00 <Cale> (being a C++ library)
21:30:28 <scutigera> is gtk2hs still active ?
21:30:32 <Axman6> Jonno_FTW: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21923#a21927 is shorter, though harder to understand
21:30:32 <QtPlatypus> I think you mean static, "strong typing" is a meaningless term.
21:30:33 <ivanm> Cale: well, someone started
21:30:35 <ivanm> scutigera: apparently
21:30:37 <Cale> scutigera: Yes, as far as I know.
21:30:55 <shapr> QtPlatypus: Unless it's old enough to smell...
21:30:56 <ivanm> Pisco_Sour: well, ncurses is a ui framework; it isn't, however, a gui framework
21:31:00 <ivanm> Axman6: writing or using?
21:31:02 <Axman6> scutigera: it's the most active haskell gui toolkit
21:31:05 <ivanm> shapr: heh
21:31:07 <scutigera> Cale: last I checked, it looked like it, but haskell + wx looked not so active.
21:31:09 <Axman6> ivanm: writing
21:31:14 <ivanm> Axman6: wxhaskell is gaining some momentum
21:31:14 <ezyang> in theory, you could get compile time type checking in scheme
21:31:21 <ivanm> Axman6: yeah, I hate writing user-oriented apps...
21:31:23 <ivanm> damn users...
21:31:28 <ivanm> ezyang: with tagging?
21:31:28 <Axman6> bastards
21:31:31 <scutigera> lusers ?
21:31:34 * Axman6 mostly writes apps for himself
21:31:39 <ivanm> same
21:31:39 <ezyang> ivanm: that'd be runtime, no?
21:31:45 <ivanm> ezyang: true
21:31:48 <scutigera> Axman6: gui apps ?
21:31:50 <shapr> QtPlatypus: What about strong typing here? http://en.wikipedia.org/wiki/Strongly_typed_programming_language
21:31:54 <Axman6> no
21:32:18 <shapr> Actually, that wikipedia page agrees with QtPlatypus
21:32:52 <scutigera> QtPlatypus: you're right I meant static
21:33:33 <ivanm> http://www.pphsg.org/cdsmith/types.html
21:33:35 <ivanm> scutigera: ^^
21:34:18 <scutigera> no debate, I like both, I was just wondering which is better to teach first (I certainly don't know)
21:34:39 * ivanm might set the last release of the platform building and head home for the weekend...
21:34:42 <scutigera> ivanm: the right tool for the job and all that
21:35:56 <scutigera> ivanm: good page, regardless
21:36:30 <monochrom> I use haskell to process xml. My latest exploit is this. <tab><r/><d/>1 <d/>2 <r/><d/>A <d/>B</tab> is turned into <table><tr><td>1</td> <td>2</td></tr> <tr><td>A</td> <td>B</td></tr></table>. In other words, <r/> starts a table row, <d/> starts a table cell.
21:37:18 <scutigera> monochrom: real haskell programmers design DSLs to process xml ;-)
21:37:23 <Axman6> you just optimised HTML. hoorah
21:37:55 <Axman6> so, LLVM backend for GHC eh?
21:37:58 <Axman6> yum yum
21:37:59 <shapr> yay!
21:38:06 <ezyang> oh man html
21:38:11 <monochrom> If you write <d id="b" x="2" y="3"/>C , it is turned into <td id="b" rowspan="2" colspan="3">C</td>
21:39:38 <monochrom> I use HXT. That's like DSL for xml. My exploit above uses Parsec in addition (an xml node is a token), that's like DSL for stream processing.
21:40:02 <monochrom> or shall I say, DSL for stream conversion.
21:41:59 <scutigera> monochrom: and you are doing this for ... (just for fun being the best answer :-)
21:42:26 <monochrom> I am doing this for the next greatest math tutorial on my home page.
21:43:11 <scutigera> monochrom: math good !
21:44:07 <monochrom> I need to show calculations. A calculation is a table displaying "A = B = C" as: row 1 col 2 "A", row 2 col 1 "=", row 3 col 2 "B", row 4 col 1 "=", row 5 col 2 "C".
21:44:33 <monochrom> In fact, why don't I do it right now...
21:45:21 <ivanm> hang on, doesn't the haskell platform _come_ with 6.10.4?
21:45:44 <monochrom> haskell platform binaries come with 6.10.4. source doesn't.
21:46:06 <ezyang> aight, g'night #haskell!
21:46:45 <ivanm> monochrom: ahhh
21:46:57 <ivanm> fine then, I'll build 6.10.4 first...
21:47:03 <blackh> Axman6: I am very excited about the LLVM back end! This could be very interesting. I need to find out what cool things you can do with LLVM.
21:47:20 <ivanm> Axman6: any idea how to specify that 6.8 should be used rather than 6.4 @ ANU?
21:47:25 <ivanm> (since they have both installed...)
21:47:48 <Axman6> i'm really hoping for easier porting (especially to OS X 64 bit!)
21:47:56 <ivanm> heh
21:48:03 <Axman6> ivanm: not a clue. change your PATH? create a link?
21:48:06 <Axman6> ionno
21:48:11 <blackh> I'm hoping the LLVM back end for ARM works
21:48:21 <Axman6> me too
21:48:28 <Axman6> but, just because i like ARM
21:48:40 <ivanm> yeah, maybe
21:48:53 <scutigera> Axman6: easier porting is supposed to be a feature...
21:48:59 <Axman6> yeah
21:49:17 <monochrom> Oh haha I mixed up x and y. x should be colspan, y should be rowspan.
21:49:41 <ivanm> Axman6: grrr.... /usr/local/bin has 6.4 and is overriding 6.8 in /usr/bin :@
21:49:57 <Axman6> fix ur path yo!
21:50:22 <Axman6> i'd make a ~/bin, and put links to what you want
21:50:50 <ivanm> yeah, I will once I've got this set up
21:51:30 <blackh> Axman6: Do you happen to know, where's the garbage collector? Is that in the LLVM?
21:51:49 <ivanm> I woudl think still in the RTS
21:51:52 <Axman6> there may not be one/it might use the current GHC one
21:51:59 <ivanm> IIRC, the LLVM wasn't actually doing all that much...
21:52:09 <Axman6> LLVM doesn't have any GC stuff
21:53:09 <ivanm> I think they were going to work on it because so many languages nowadays used GC
21:53:23 <blackh> If it's the GHC one, then you would need to link LLVM output to C.
21:53:26 <hexpuem> is there a way to get a Ptr to any of the arrays in that Data.Vector library that replaces uvector (Excluding the storable array version)
21:57:58 <ivanm> Axman6: anyway, I might see you next week then
21:58:01 * ivanm heads  off
21:58:07 <Axman6> o/
21:59:37 <choffstein> is it possible to map over a Sequence?
21:59:52 <ivanm> choffstein: fmap
22:00:00 <choffstein> ivanm: thanks!
22:00:02 <ivanm> @instances-importing Data.Seq Functor
22:00:03 <lambdabot> IO, Maybe, []
22:00:07 <ivanm> grrr....
22:00:11 <ivanm> @instances-importing Data.Sequence Functor
22:00:12 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, Seq, State s, StateT s m, ViewL, ViewR, Writer w, WriterT w m, []
22:00:18 <ivanm> there we are
22:03:09 <choffstein> ivanm: Any thoughts on a zipWith equivalent for Sequence?  Also, how can I find these answers for myself?
22:06:27 <shrughes> choffstein: you mean Data.Sequence.Seq?
22:06:47 <choffstein> Yes
22:06:58 <shrughes> see http://www.haskell.org/ghc/docs/latest/html/libraries/containers-0.3.0.0/Data-Sequence.html
22:07:06 <shrughes> there is zipWith in that module
22:07:40 <choffstein> Ah, thanks.  Sorry -- I am just learning Haskell and have been asking stupid questions all day
22:11:39 <choffstein> So, if I am doing 'import Data.Sequence', I should just be able to use zipWith on a Seq and it will work, right?  I am getting that it is expecting a List instead, and I can't seem to call it explicitly (not in scope?)
22:12:15 <Axman6> no, that's not how it works
22:12:25 <Axman6> :t zipWith
22:12:26 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
22:13:37 <choffstein> there is a zipWith defined in Data.Sequence, (a -> b -> c) -> Seq a -> Seq b -> Seq c
22:13:45 <Axman6> you'll need to impoprt Data.Sequence qualified: import qualified Data.Sequence as S, anf then use S.zipWith
22:13:52 <Axman6> and*
22:13:54 <choffstein> Ah, I see
22:14:14 <Axman6> actually, this might be better
22:14:40 <Axman6> imort qualified Data.Sequence (zipWith) as S
22:14:44 <Axman6> and
22:14:44 <choffstein> When I do that, I get 'Not in scope: S.zipWith'
22:14:45 <Axman6> import Data.Sequence
22:14:47 <Axman6> as wekk
22:14:56 <Axman6> ll*
22:15:03 <Axman6> urgh, failing hard at typing today
22:15:20 <mm_freak> usually you do something like this:
22:15:27 <mm_freak> import qualified Data.Sequence as S
22:15:33 <mm_freak> import Data.Sequence (Seq)
22:15:55 <mm_freak> then you can say 'Seq Int' instead of 'S.Seq Int'
22:16:23 <choffstein> S.zipWith is still not in scope, while S.index is working fine...
22:16:49 <mm_freak> choffstein: using an old base maybe?
22:17:01 <choffstein> just installed on Mac OS X like three days ago
22:17:18 <mm_freak> did you install the haskell platform?
22:18:14 <choffstein> I thought I did
22:18:33 <Axman6> choffstein: installed it on what?
22:18:41 <choffstein> Snow Leopard
22:18:51 <Axman6> no, installed OS x on what
22:18:53 <choffstein> Followed the simple instructions...
22:19:04 <choffstein> I didn't install OS X.  I installed Haskell on OS X
22:19:09 <Axman6> ah, ok :)
22:19:16 <Axman6> sounded like you were a hackintosh user ;)
22:19:36 <mm_freak> wait
22:19:42 <mm_freak> zipWith doesn't show up for me either
22:20:11 <choffstein> okay, now I feel a bit better
22:20:28 <mm_freak>     Latest version available: 0.3.0.0
22:20:29 <mm_freak>     Latest version installed: 0.2.0.1
22:20:32 <mm_freak> hmm
22:20:51 <choffstein> how do you check that?
22:21:00 <mm_freak> cabal list containers
22:21:15 <mm_freak> you can upgrade it manually:  cabal upgrade containers
22:22:03 <choffstein> seems like 0.3.0.0 is not compatible with 6.10.4?
22:22:06 * hackagebot upload: vty-ui 0.3 - A user interface composition library for Vty (JonathanDaugherty)
22:22:44 <choffstein> 'cabal: cannot configure containers-0.3.0.0. It requires base >=4.2 && <6'
22:22:47 <choffstein> Bummer...
22:22:55 <mm_freak> ah, ok
22:23:23 <mm_freak> well, for the time being, it seems you need to reinvent the wheel =)
22:23:30 <choffstein> Huzzah!
22:24:47 <choffstein> Well, thanks for the help!
22:25:23 <mm_freak> you're welcome
22:25:42 <Axman6> choffstein: it shouldn't be too hard luckily :)
22:25:55 <Axman6> (plus it should be fun, and a good learning experience)
22:26:08 <choffstein> Axman6: I think it may only be hard because I am working with sequences
22:26:30 <choffstein> Axman6: And as far as I know, I can't just convert them to lists and back...
22:26:31 <Axman6> should only be two lines i think
22:26:40 <choffstein> Really?
22:26:43 <Axman6> you probably can, but there's a more fun way >_>
22:26:48 <choffstein> Lemme give it a whack and see if I can figure it out
22:26:56 <mm_freak> well, Seq is a Functor
22:27:07 <mm_freak> hmm, that doesn't help i think
22:27:46 <mm_freak> Axman6: there is no way
22:27:58 <mm_freak> there is only a fromList, no toList =)
22:28:01 <Axman6> ph well
22:28:03 <Axman6> o*
22:28:34 <mm_freak> choffstein: you can let ghci display the contents of a module
22:28:49 <mm_freak> :bro(wse) Data.Sequence
22:28:59 <choffstein> ah, thanks.  I've just been viewing them online
22:29:49 <choffstein> Doesn't Foldable have a toList?
22:30:07 <mm_freak> :i Foldable
22:30:08 <mm_freak> =)
22:30:34 <mm_freak> it doesn't, but it has foldr
22:31:23 <ski> @type Data.Foldable.foldr (:) []
22:31:24 <lambdabot> forall a (t :: * -> *). (Data.Foldable.Foldable t) => t a -> [a]
22:32:57 <Cale> :t Data.Foldable.toList
22:32:58 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
22:33:08 <Cale> Foldable absolutely does have a toList ;)
22:33:13 <mm_freak> hmm
22:33:32 <mm_freak> oh, of course
22:33:37 <mm_freak> it's not part of the class =)
22:33:39 * Axman6 likes his zipWith definition anyway
22:34:47 <mm_freak> i think you can define it nicely using view patterns
22:35:09 <choffstein> I think this one might be beyond my abilities
22:37:20 <mm_freak> i don't like recursive definitions anyway
22:40:42 <mm_freak> > let seqZipWith f xs (viewl -> EmptyL) = empty; seqZipWith f (viewl -> EmptyL) ys = empty; seqZipWith f (viewl -> x :< xs) (viewl -> y :< ys) = (x `f` y) <| seqZipWith f xs ys in seqZipWith (+) (fromList [1,2,3]) (fromList [7,6,5])
22:40:43 <lambdabot>   Illegal view pattern:  (viewl -> EmptyL)
22:40:43 <lambdabot>  Use -XViewPatterns to enable view...
22:40:53 <RecycleCorn>  It is time to put those Haitian jigaboos in their place!  No matter how many times the civilized world donates money, opens schools, rebuilds their nation, and holds their little monkey paws, the damn niggers can never get it right.  They never will!  The same goes for New Orleans!  Cancun in Mexico suffered few fatalities after their major hurricane, and the rebuilding is already completed.  What
22:40:53 <RecycleCorn> have the niggers in New Orleans done? If you are sick of this, join Chimpout Forum!  http://www.chimpout.com/forum
22:41:05 --- mode: ChanServ set +o mauke
22:41:06 --- kick: RecycleCorn was kicked by mauke (RecycleCorn)
22:41:06 --- mode: mauke set +b *!*@201.160.242.20.cable.dyn.cableonline.com.mx
22:41:18 <mm_freak> so that's why they're called "view patterns"
22:41:30 <mm_freak> i always wondered about that name
22:43:05 --- mode: mauke set -o mauke
22:54:21 <Sagi> I want to expose a single function from a module, but not the module itself. So in the .cabal, I didn't include it in the exposed-modules. Now if I try to use the function in a different project I get "Failed to load interface for" errors.
22:54:26 <Sagi> Is this normal?
22:55:03 <Sagi> I exported this single function in a module which is listed in exposed-modules
22:59:58 <Sagi> ah never mind, I probably need to list it in other-modules
23:01:20 <Sagi> yeah, that solved it
23:08:02 <ski> Axman6 : a `zipWith' definition for `Foldable' types ?
23:08:13 <Axman6> Seq
23:08:45 <ski> where ?
23:10:16 <Axman6> it's nothing special :\
23:10:41 <Axman6> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=21955#a21955
23:20:16 <ski> i wonder whether it would be sensible to try to define a `zipWith' that tried to split into halves, instead of chopping off one element at a time
23:49:54 <nainaide> Does [ [], [] ] equal [] ?
23:50:07 <tensorpudding> > [[],[]] == []
23:50:08 <lambdabot>   False
23:50:46 <nainaide> > ( "... /t", 3) : [[],[]]
23:50:47 <lambdabot>   Couldn't match expected type `([GHC.Types.Char], t)'
23:50:47 <lambdabot>         against inferr...
23:50:59 <nainaide> > ( "... /t", 3) : []
23:51:00 <lambdabot>   [("... /t",3)]
23:51:40 <tensorpudding> yeah, [[],[]] is a list of lists
23:52:08 <tensorpudding> [] of course is polymorphic in all types
23:52:24 <tensorpudding> :t []
23:52:25 <lambdabot> forall a. [a]
23:52:56 <nainaide> ( "... /t", 3) : [[],[]] should equal ( "... /t", 3) : [] , right?
23:53:15 <mreh> does [forall a. a] make sense?
23:54:36 <tensorpudding> nainaide: no
23:54:53 <tensorpudding> the former is ill-typed
23:55:09 <mreh> [[],[]] :: [[a]]
23:55:42 <nainaide> ( "... /t", 3) : concat [[],[]]
23:55:50 <nainaide> > ( "... /t", 3) : concat [[],[]]
23:55:51 <lambdabot>   [("... /t",3)]
23:56:12 <tensorpudding> if you have a list of type [a], the (:) accepts elements of type a
23:56:14 <nainaide> concat [[],[]] == []
23:56:20 <tensorpudding> yes
23:56:26 <nainaide> > concat [[],[]] == []
23:56:27 <lambdabot>   True
23:56:34 <nainaide> yeah, I got it.
23:56:47 <nainaide> tensorpudding, mreh, thanks
23:57:31 * hackagebot upload: llvm 0.7.1.1 - Bindings to the LLVM compiler toolkit. (LennartAugustsson)
