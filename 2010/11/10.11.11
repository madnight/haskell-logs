00:06:49 <Eduard_Munteanu> I'm having trouble with 'cabal install' in a mingw/msys + Wine environment. Packages don't build, and I get this without much indication:
00:06:52 <Eduard_Munteanu> spawnv failed: errno 2: No such file or directory
00:07:06 <Eduard_Munteanu> Any ideas?
00:08:14 <Eduard_Munteanu> I'm also getting other messages, but this looked interesting.
00:23:23 <Saizan> Eduard_Munteanu: for all packages?
00:23:55 <Saizan> pasting the complete -v log might help
00:27:48 <Eduard_Munteanu> $ wine cabal install -v chart 2>&1 | wgetpaste
00:27:49 <Eduard_Munteanu> Your paste can be seen here: http://paste.pocoo.org/show/289644/
00:27:56 <Eduard_Munteanu> Saizan: here it is.
00:28:43 <Eduard_Munteanu> I'm using HaskellPlatform-2010.2.0.0
00:31:18 <Eduard_Munteanu> Basically yes, I think it's for all packages.
00:32:20 <Eduard_Munteanu> ghci works, if that's any indication.
00:36:53 <Saizan> does that gcc.exe work?
00:38:50 <Eduard_Munteanu> Saizan: MinGW's does, the GHC one I didn't try, lemme see...
00:39:09 <Eduard_Munteanu> Saizan: oh, ghc can't compile a test program.
00:39:28 <Eduard_Munteanu> I get that "spawnv failed: errno 2: No such file or directory"
00:40:07 <endojelly> this coroutine library rocks
00:40:57 <Eduard_Munteanu> Hm, I'm thinking I could replace Platform's gcc with MinGW's.
00:41:11 <shachaf> endojelly: Which?
00:41:50 <Saizan> Platform's gcc is taken from mingw, so i guess that might work
00:42:32 <Eduard_Munteanu> Yeah, I'm replacing the whole mingw from Platform.
00:42:41 <endojelly> shachaf, http://hackage.haskell.org/package/monad-coroutine-0.6
00:43:03 <Eduard_Munteanu> Saizan: yup, ghc compiles my hello world now.
00:43:14 <Eduard_Munteanu> Trying cabal install...
00:43:48 <Eduard_Munteanu> Saizan: thanks, it seems to be working.
00:44:10 <Saizan> Eduard_Munteanu: np
00:47:31 <JoshTriplett> How can I find out if lambdabot supports a particular module?
00:49:54 <dolio> Use something from it.
00:50:24 <JoshTriplett> > emptyRecordP
00:50:24 <lambdabot>   Not in scope: `emptyRecordP'
00:50:28 <JoshTriplett> Not so much. :)
00:51:39 <dolio> What module is that even from?
00:51:43 <JoshTriplett> So, an hlist question: why do # and .!. use "infixr" rather than "infixl"?  That fixity means you can't write something like this without parentheses:
00:51:43 <JoshTriplett> (a .=. (b .=. 1 .*. c .=. 2 .*. emptyRecordP) .*. b .=. True .*. emptyRecordP) # a # b
00:51:48 <Veinor> @hoogle emptyRecordP
00:51:48 <lambdabot> No results found
00:51:49 <JoshTriplett> dolio: Data.HList.
00:52:06 <JoshTriplett> (Specifically Data.HList.RecordP.)
00:52:44 <dolio> Sounds like an oversight.
00:53:19 <dolio> I can't imagine wanting to project a record field name out of a record, and use it to project out of a second record.
00:54:54 <JoshTriplett> dolio: Yeah, exactly.  Whereas nesting records seems much more common. :)
00:55:00 <dolio> Yes.
00:55:12 * JoshTriplett looks for an appropriate bug reporting address. :)
00:58:11 <Eduard_Munteanu> Hm, why would gtk2hsC2hs.exe invoke a shell?
00:58:57 <Eduard_Munteanu> Cairo fails building after running that, when I get dropped to a CMD shell. Then when I quit that, it says gtk2hsC2hs.exe does not exist (but I can run it)
00:58:58 <FeiRuoWa> bedtime for stupid overworked freshmen who took too many courses :p
01:00:29 <Eduard_Munteanu> http://paste.pocoo.org/show/289648/
01:00:48 <Eduard_Munteanu> C:\users\edi\Temp\cairo-0.12.08\cairo-0.12.0>gtk2hsC2hs.exe: does not exist
01:00:54 <Eduard_Munteanu> There I type exit ^
01:01:07 <Eduard_Munteanu> line 182
01:03:43 <Eduard_Munteanu> Background on this: I'm using the Haskell Platform for Windows on Wine, and some mingw in there.
01:21:05 <kmc> > 355 / 113
01:21:05 <lambdabot>   3.1415929203539825
01:27:49 <Eduard_Munteanu> Does 'cabal install cairo' even work on Windows?
01:39:20 <tab> Eduard_Munteanu: is gtk2hsC2hs.exe in your paths ?
01:39:51 <tab> i mean the default path where executable are searched
01:41:47 <Eduard_Munteanu> tab: if I type 'wine gtk2hsC2hs' it finds it.
01:41:58 <Eduard_Munteanu> tab: also from a cmd prompt.
01:42:05 <Eduard_Munteanu> So it is in PATH
01:43:35 <tab> Eduard_Munteanu: cabal might run with different environment and paths .. i'll look into that if i were you.
01:45:45 <turiya> can i create a list inside a function?
01:46:02 <kmc> yes
01:46:32 <turiya> kmc, how? right now i am passing an empty list as an argument and growing it inside the function..
01:46:43 <dmwit> Eduard_Munteanu: My understanding is that libraries that use the FFI need some mingw love in Windows.
01:46:52 <kmc> turiya, that doesn't make sense, you don't modify lists in place, you only return new lists
01:46:58 <kmc> here is a function that returns a list
01:47:02 <dmwit> Though that's cargo-cult compiling, I've never done it myself.
01:47:06 <kmc> > let f n = [n, n+2, n+7] in n 20
01:47:07 <lambdabot>   Couldn't match expected type `t1 -> t'
01:47:07 <lambdabot>         against inferred type `Simpl...
01:47:14 <kmc> > let f n = [n, n+2, n+7] in f 20
01:47:14 <Eduard_Munteanu> tab: this line looks like it finds it, really: C:\users\edi\Application Data\cabal\bin\gtk2hsC2hs.exe --include=dist\build --include=C:\
01:47:15 <lambdabot>   [20,22,27]
01:47:29 <kmc> turiya, don't think in terms of action verbs like create, modify, etc.
01:47:33 <kmc> think in terms of values and equations
01:47:40 <kmc> f of n *is* the list [n, n+2, n+7]
01:47:45 <kmc> we don't need to say that f *does* anything
01:48:34 <Eduard_Munteanu> dmwit: so actually gtk2hs doesn't work in Windows? Because it seems the Platform uses mingw on Windows anyway.
01:48:38 <Jafet> Modified equations create value
01:48:42 <dmwit> > let step x = Just (floor x, recip (x - floor x)) in unfoldr step pi
01:48:43 <lambdabot>   Ambiguous type variable `b' in the constraints:
01:48:43 <lambdabot>    `GHC.Float.Floating b'
01:48:43 <lambdabot>  ...
01:48:50 <dmwit> > let step x = Just (floor x, recip (x - floor x)) in unfoldr step (pi :: Double)
01:48:51 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
01:48:51 <lambdabot>    arising from a use ...
01:49:00 <dmwit> :t unfoldr
01:49:01 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:49:17 <turiya> kmc, i am having trouble expressing my problem.. 
01:49:32 <kmc> yeah
01:49:32 <dmwit> > let step x = Just (floor x, recip (x - fromIntegral (floor x :: Int))) in unfoldr step (pi :: Double)
01:49:33 <turiya> i understand that lists are not modified
01:49:33 <lambdabot>   [3,7,15,1,292,1,1,1,2,1,3,1,14,3,3,23,1,1,7,4,35,1,1,1,2,3,3,3,3,1,1,14,6,4...
01:49:44 <kmc> do you understand my general advice about thinking in terms of values and equations?
01:49:59 <dmwit> Eduard_Munteanu: Building the platform requires mingw, yeah, but I don't think the platform itself installs mingw.
01:50:07 <kmc> it is easier to understand Haskell functions as equations on values, than it is to understand them as sequences of steps which are performed in order
01:50:08 <dmwit> gtk2hs works in Windows.
01:50:13 <kmc> this is the opposite of most languages
01:50:19 <turiya> yes.. sort of.. suppose i want a function, say, f :: Int -> [String]
01:50:20 <kmc> which encourage you to think in terms of sequences of steps
01:50:23 <kmc> ok
01:50:23 <Jafet>  @let typeTax = fromIntegral
01:50:26 <turiya> how can i do this?
01:50:30 <kmc> well, what should the function do?
01:50:36 <kmc> there's loads of different functions with that type
01:50:36 <dmwit> :t fmod
01:50:37 <lambdabot> Not in scope: `fmod'
01:50:56 <turiya> oh slight adjustment, f :: Int -> String
01:51:08 <kmc> :t let f :: Int -> String; f n = "hello world" in f
01:51:09 <lambdabot> Int -> String
01:51:11 <turiya> say convert the digits in an integer to characters
01:51:19 <Eduard_Munteanu> dmwit: it does, I found a fresh mingw installed by the platform in its Program Files folder. Different from my own, since mine has GCC 4.5.0 and this one was 3.4-ish
01:51:26 <kmc> :t digitToInt
01:51:27 <lambdabot> Char -> Int
01:51:36 <kmc> :t show
01:51:36 <lambdabot> forall a. (Show a) => a -> String
01:51:40 <kmc> :t show :: Int -> String
01:51:41 <lambdabot> Int -> String
01:51:52 <kmc> turiya, but i guess you want to write this conversion yourself?
01:52:02 <turiya> hmm..yes exactly
01:52:33 <kmc> here's a hint, it will be easier to produce the digits in the reverse order
01:52:36 <kmc> and then you can reverse them at the end
01:52:40 <Eduard_Munteanu> dmwit: and it didn't even work, ghc was failing to build anything. I replaced it by symlinking to my own, which made it work.
01:52:46 <dmwit> > 3 + 1 / (7 + 1 / 15) :: Rational
01:52:47 <lambdabot>   333 % 106
01:53:02 <kmc> does that help?
01:53:13 <turiya> i want to see an example..
01:53:15 <dmwit> Eduard_Munteanu: Sorry, I was already out of my depth when I started. =P
01:53:18 <dmwit> Good luck, though...
01:53:24 <Eduard_Munteanu> dmwit: is there any other way to install this GTK stuff, like a prebuilt package?
01:53:26 <turiya> yes, it would help
01:53:29 <Eduard_Munteanu> Oh.
01:53:29 <kmc> turiya, you want me to write this function for you, as an example?
01:53:37 <dmwit> Eduard_Munteanu: Well, gtk2hs used to have a Windows installer on its website.
01:53:47 <Eduard_Munteanu> dmwit: thanks, I'll go grab that then.
01:54:06 <turiya> yes.. would that function require too many lines of code?
01:54:09 <kmc> no
01:54:29 <turiya> ok.. can you show me an example?
01:54:31 <kmc> yes
01:55:33 <turiya> thanks..
01:56:09 <kmc> turiya, http://hpaste.org/41374/digits
01:56:25 <kmc> turiya, so we have 0 as a special case, because it renders as "0" and not ""
01:56:31 <kmc> but otherwise, we do recursion down to 0
01:56:35 <kmc> with this helper function "go"
01:57:00 <kmc> each step we use 'mod' to get the least-significant digit, and 'div' to shift the number over one digit in the recursive step
01:57:08 <kmc> this gives the list of digits in reverse order, so we apply "reverse"
01:57:18 <kmc> the helper function "dig" converts an Int from 0 to 9 into a digit
01:57:24 <kmc> a single char
01:57:26 <companion_cube> @pl \x -> x * x
01:57:26 <lambdabot> join (*)
01:57:36 <kmc> turiya, there are some optimizations (like using divMod) but this is the basic idea
01:57:39 <kmc> makes sense?
01:57:57 <turiya> kmc, am still trying to understand .. :)
01:58:11 <companion_cube> @type join
01:58:11 <dmwit> > unfoldr (\x -> guard (x > 0) >> return (x `divMod` 10)) 4298375
01:58:12 <lambdabot>   [429837,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
01:58:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
01:58:21 <kmc> it also won't work for negative numbers
01:58:35 <dmwit> > (42 `divMod` 10, 10 `divMod` 42)
01:58:35 <lambdabot>   ((4,2),(0,10))
01:58:49 <kmc> > 12345 `mod` 10
01:58:50 <lambdabot>   5
01:58:51 <kmc> > 12345 `div` 10
01:58:52 <lambdabot>   1234
01:59:25 <dmwit> :t unfoldr
01:59:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
01:59:44 <turiya> kmc, i think i understand the basic idea..
01:59:47 <dmwit> oh
01:59:53 <turiya> but i have one general question..
02:00:28 <dmwit> > let flip (x,y) = (y,x) in unfoldr (\x -> guard (x > 0) >> (return . flip) (x `divMod` 10)) 4298375
02:00:29 <lambdabot>   [5,7,3,8,9,2,4]
02:01:17 <turiya> without using functions that "return" a String or Char, is it possible to write a function that does this digit to char conversion?
02:01:35 <dmwit> No.
02:01:53 <dmwit> What would that even mean?
02:02:05 <dmwit> What would it mean to write a conversion to characters that can't return characters?
02:02:07 <kmc> how could you make a list of chars without returning a char or a list
02:02:30 <kmc> turiya, but the main thing building the list here is the data constructor :
02:02:35 <kmc> > 1 : [2,3,4]
02:02:35 <lambdabot>   [1,2,3,4]
02:02:41 <kmc> 4 : []
02:02:43 <kmc> > 4 : []
02:02:43 <lambdabot>   [4]
02:03:27 <dmwit> > 'a' : ['b', 'c', 'd'] -- lists of chars are just printed differently
02:03:28 <lambdabot>   "abcd"
02:04:02 <turiya> kmc, dmwit : i was just trying to say that somewhere down the line there are functions which return a type that is not input as an argument
02:04:22 <kmc> yes
02:04:36 <kmc> you've got to get from Int to [Char]; you can't do that with only functions of type Int -> Int
02:04:54 <kmc> turiya, is there some particular significance of this fact, to you?
02:05:44 <turiya> no, i was just trying to understand why i can "return" a String when an Int is the sole argument..
02:05:57 <mietek> Why would linking cabal take an awfully long time on x86_64?
02:06:26 <turiya> that may be a dumb thing to do.. but it clears a stupid doubt..
02:08:36 <kmc> i think it's a good line of thinking
02:09:13 <kmc> when you write polymorphic functions, you can determine a lot from the limited way in which they must use their args
02:09:16 <kmc> like, length :: [a] -> Int
02:09:19 * hackagebot tga 0.1 - Reading and writing of tga image files  http://hackage.haskell.org/package/tga-0.1 (TillmannVogt)
02:09:26 <kmc> so we know that length can't care about the actual values in the list
02:09:35 <kmc> because it treats them as some unknown type 'a'
02:09:41 <kmc> so we know that length [1,2] == length [3,4]
02:09:57 <turiya> kmc, yes, i too think the type of a function tells a lot about what the function actually does..
02:10:00 <kmc> but if we had crazyLength :: [a] -> (a -> Int) -> Int
02:10:05 <kmc> then it could do lots of different things
02:11:44 <endojelly> am I the only one who sometimes writes really complicated things (like continuation stuff) without specifying an explicit type signature, and look at it afterwards?
02:11:54 <kmc> you mean you ask ghci the type?
02:11:55 <endojelly> and sometimes I think "oh, that's interesting
02:12:03 <turiya> kmc, yes..
02:12:05 <endojelly> kmc, yeah.
02:12:18 <kmc> endojelly, i think that's a good way to learn, but not a good thing for real code
02:12:56 <endojelly> kmc, I think it's okay if you specify the type signature afterwards, while checking that it really is what you want of course
02:13:05 <ManateeLazyCat> I lost my xmonad config, can someone share it? Thanks.
02:13:45 <endojelly> kmc, during my continuation experiments I noticed that those types can really explode. worse, you change a very little thing in a monad body and the type changes in complicated ways.
02:13:58 <dmwit> ManateeLazyCat: You want a copy of the default config?
02:14:15 <endojelly> I also really like specifying the type first, and afterwards filling in code that satisfies that type
02:14:21 <endojelly> but sometimes that's unwieldy
02:14:22 <ManateeLazyCat> dmwit: I want some simple config, best with customize keystroke.
02:14:38 <ManateeLazyCat> dmwit: I have my own xmonad config, unfortunately, i lost it.
02:14:43 <dmwit> ManateeLazyCat: the simplest config is "import XMonad; main = xmonad defaultConfig"
02:15:31 * ManateeLazyCat pasted "xmonad.hs" at http://paste2.org/get/1084113
02:15:31 <ManateeLazyCat> dmwit: Oh, i found it. above. 
02:15:57 <ManateeLazyCat> dmwit: Thanks for help. :)
02:16:29 <ManateeLazyCat> Thanks god, i have my xmonad config.
02:16:35 <dmwit> ManateeLazyCat: In the future, you might get more help in #xmonad.
02:18:44 <ManateeLazyCat> dmwit: Infact, i don't need xmonad, just test it with my project.
02:21:33 <ManateeLazyCat> Bye all, test Manatee in Xmonad.
02:35:28 <ManateeLazyCat> Saizan: Interested, why manatee can work in XMonad?
02:36:04 <ManateeLazyCat> Saizan: I have test Manatee with XMonad, works fine.
02:39:05 <ManateeLazyCat> Saizan: But i found some problem, looks Manatee's popup input window block by XMonad
02:41:34 <Saizan> ManateeLazyCat: might be something else about my setup
02:42:13 <ManateeLazyCat> Saizan: I can switch Manatee, and press keymap in Manatee.
02:42:36 <ManateeLazyCat> Saizan: But i found when i type M-f to input something Manatee, XMonad looks block my *popup window*. 
02:43:25 <ManateeLazyCat> Saizan: XMonad think Manatee's *Poup window* is standalone window, but it's belong to Manatee.
02:43:44 <Eduard_Munteanu> Hm.. this seems to be the problem, gtk2hsC2hs is invoking this:
02:43:48 <Eduard_Munteanu> cpp  -xc -w -Idistbuildautogen -Idistbuild -IC:/gtk/include/cairo -IC:/gtk/include/glib-2.0 -IC:/gtk/lib/glib-2.0/include -IC:/gtk/include -IC:/gtk/include/freetype2 -IC:/gtk/include/libpng14 .\cairo-gtk2hs.h >cairo-gtk2hs.i
02:43:57 * ManateeLazyCat pasted "my xmonad config" at http://paste2.org/get/1084150
02:43:58 <ManateeLazyCat> Can you try my XMOnad config ?
02:44:08 <Eduard_Munteanu> But cpp doesn't like the .\cairo-gtk2hs.h
02:44:21 <ManateeLazyCat> Eduard_Munteanu: Which gtk2hs version?
02:44:58 <ManateeLazyCat> Saizan: My xmonad is very simple, just change default XMonad keymap. 
02:45:00 <Eduard_Munteanu> ManateeLazyCat: well, latest stuff from Cabal.
02:45:08 <Eduard_Munteanu> ManateeLazyCat: I'm simply trying to install Cairo.
02:45:15 <ManateeLazyCat> Eduard_Munteanu: What's wrong when you install gtk2hs?
02:45:25 <ManateeLazyCat> Eduard_Munteanu: cabal install gtk2hs-buildtools gtk
02:45:38 <ManateeLazyCat> Eduard_Munteanu: Or "cabal install gtk2hs-buildtools glib gio cairo pango gtk"
02:45:39 <Eduard_Munteanu> ManateeLazyCat: gtk2hs-buildtools installs fine
02:45:44 <Eduard_Munteanu> ManateeLazyCat: but gtk doesn't
02:45:54 <ManateeLazyCat> Eduard_Munteanu: Can you paste error let me check?
02:45:59 <Eduard_Munteanu> ManateeLazyCat: lemme try...
02:46:34 <ManateeLazyCat> I love XMOnad, notify works fine, don't like Gnome, notify window can't work when my program in fullscreen. 
02:47:39 <Eduard_Munteanu> ManateeLazyCat: well it tries to install Cairo all over again which fails.
02:48:11 <Eduard_Munteanu> ManateeLazyCat: http://paste.pocoo.org/show/289648/
02:48:42 <tab> Eduard_Munteanu: is .\ a valid path in windows ?
02:48:50 <Eduard_Munteanu> ManateeLazyCat: I can assure you gtk2hsC2hs is there, it runs, but somehow it invokes cpp wrongly which then invokes cmd
02:48:59 <Eduard_Munteanu> tab: I have no clue :). I suppose not.
02:49:11 <Eduard_Munteanu> tab: if I remove the dot it works.
02:49:14 <rwallace> tab, yes it is
02:49:23 <ManateeLazyCat> Eduard_Munteanu: Oh, Windows platform
02:49:34 <tab> rwallace: does it means the same thing than ./ on unix though ?
02:49:41 <rwallace> yes
02:49:44 <Eduard_Munteanu> ManateeLazyCat: yes, Windows platform through Wine :)
02:49:49 <tab> rwallace: ok
02:50:01 <Eduard_Munteanu> on Linux of course.
02:50:10 <ManateeLazyCat> Eduard_Munteanu: Can you install gtk2hs-0.11.x correctly?
02:50:37 <Eduard_Munteanu> ManateeLazyCat: hm, how would I do that? I mean, there's no actual gtk2hs cabal pkg.
02:52:02 <Eduard_Munteanu> ManateeLazyCat: I'm more to happy to install an older version.
02:52:15 <ManateeLazyCat> Eduard_Munteanu: Are you sure you gtk2hsC2hs.exe in your path?
02:53:03 <Eduard_Munteanu> ManateeLazyCat: yes, as I said, if I run it with -d trace, I can tell that the 'cpp' command it runs is a bit wrong.
02:53:30 <ManateeLazyCat> Eduard_Munteanu: I think this something wrong config in Windows, because i have friend can install gtk2hs successful.
02:53:39 <Eduard_Munteanu> ManateeLazyCat: 0.12?
02:53:41 <ManateeLazyCat> Eduard_Munteanu: Wait let me think his nick.
02:53:45 <ManateeLazyCat> Eduard_Munteanu: Yes.
02:54:00 <ManateeLazyCat> Eduard_Munteanu: I let he test it before i release gtk2hs-0.12.0
02:54:01 <Eduard_Munteanu> Weeelll... it's not Windows, it's Wine.
02:54:12 <ManateeLazyCat> Eduard_Munteanu: Why you need do that?
02:54:23 <ManateeLazyCat> Eduard_Munteanu: If you use Linux, why not install directly?
02:54:41 <ManateeLazyCat> Eduard_Munteanu: Wine's library is easy to broken.
02:54:49 <Eduard_Munteanu> ManateeLazyCat: because we have some homework, I want to do it in Haskell, but the instructor is hard-headed on having binaries which he can run.
02:55:08 <Eduard_Munteanu> ManateeLazyCat: so this is some poor man's cross compilation
02:55:35 <ManateeLazyCat> Eduard_Munteanu: I'm sure newest gtk2hs can install on Windows, but don't know how about Wine.
02:55:57 <ManateeLazyCat> Eduard_Munteanu: If so, can you build VirtualMachine to build Windows?
02:56:28 <ManateeLazyCat> Eduard_Munteanu: Instructor just have Windows?
02:56:45 <Eduard_Munteanu> ManateeLazyCat: you mean to run Windows in a VM? Well I suppose I'll do that at some point, it seemed a bit more comfortable not to get some Windows.
02:56:50 <Eduard_Munteanu> ManateeLazyCat: yes.
02:57:29 <ManateeLazyCat> Eduard_Munteanu: If you have power box, best install windows in a VM.
02:57:55 <ManateeLazyCat> Eduard_Munteanu: Then you can build Windows binary in VM, and you can use Linux at the same time.
02:58:04 <Saizan> Eduard_Munteanu: to install an earlier version of gtk2hs you can fetch the tarballs from gtk2hs's website
02:58:16 <Saizan> Eduard_Munteanu: they didn't install through Cabal
02:58:19 <Eduard_Munteanu> Yeah, I suppose I could try building that on my father's computer, he uses Windows.
02:58:39 <Eduard_Munteanu> Saizan: hm, that sounds good, thanks. I'll try it now.
02:58:41 <ManateeLazyCat> Eduard_Munteanu: Wine's library not complete, some library maybe missing make you can't build gtk2hs.
02:59:26 <Eduard_Munteanu> ManateeLazyCat: yeah, I suppose there's a subtle bug in Wine. Neither did the Platform's mingw work, I had to replace it with my own.
03:00:45 <Eduard_Munteanu> Saizan: hm, will cabal find those and use them as dependencies?
03:00:59 <Eduard_Munteanu> I'm planning on installing Chart which depends on Cairo and that stuff.
03:02:51 <ManateeLazyCat> Eduard_Munteanu: Yes.
03:03:43 <Saizan> Eduard_Munteanu: yes, since they'll still get registered with ghc-pkg
03:03:57 <ManateeLazyCat> Saizan: I have test, i think Manatee's multi-processes framework confuse XMOnad
03:04:39 <Saizan> ManateeLazyCat: i can't test it currently
03:05:09 <ManateeLazyCat> Saizan: You can try make Manatee and other program in same layout.
03:05:24 <ManateeLazyCat> Saizan: Then Manatee can response key press.
03:06:32 <ManateeLazyCat> Saizan: Problem is, XMOnad will lost focus when you press M-f input something, Manatee works fine on other situation.
03:13:25 <ManateeLazyCat> Saizan: I try to change GTK+ code.....
03:13:30 <Eduard_Munteanu> Wow ./configure sure is slow in mingw.
03:17:42 <ManateeLazyCat> Manatee is damn fast running in XMonad. :)
03:18:02 <ManateeLazyCat> Manatee and XMonad are same style about Window Manage.
03:19:38 <Eduard_Munteanu> I like xmonad too :D.
03:20:11 <Eduard_Munteanu> As a matter of fact Eduard_Munteanu is speaking from irssi hosted in an xmonad window.
03:20:32 <ManateeLazyCat> Saizan: I will let you know when i fix focus problem between Manatee and XMonad.
03:20:51 <ManateeLazyCat> Eduard_Munteanu: http://goo.gl/MkVw
03:21:53 <Eduard_Munteanu> ManateeLazyCat: oh nice, your integrated browser/editor/etc project.
03:22:09 <ManateeLazyCat> @package manatee
03:22:09 <lambdabot> http://hackage.haskell.org/package/manatee
03:22:11 <ManateeLazyCat> Eduard_Munteanu: ^^^^
03:22:25 <ManateeLazyCat> Eduard_Munteanu: And never end. :)
03:22:30 * Eduard_Munteanu will have a look at it.
03:24:04 <ManateeLazyCat> Eduard_Munteanu: I'm fix focus problem between Manatee and XMonad, if you want try, run Manatee in Gnome.
03:24:50 <ManateeLazyCat> Eduard_Munteanu: Because Manatee is multi-processes framework, it's more like Environment with mini WM to integrated those sub-module (editor, browser etc.)
03:27:26 <ManateeLazyCat> I think Manatee + XMonad is perfect combination
03:28:50 <ketil> Eduard_Munteanu, last time I used mingw, fork was really, really, really slow.  And shell scripts tend to do that a lot.
03:29:15 <ketil> This is a while ago, though.
03:30:50 <ketil> ManateeLazyCat, I can't make any sense of the screenshots, though.
03:31:11 <ManateeLazyCat> ketil: I can understand.
03:31:11 <ketil> Are all of those of Manatee?
03:31:15 <ManateeLazyCat> ketil: Yes.
03:31:27 <ManateeLazyCat> ketil: Different sub-module running in separate processes.
03:31:45 <ManateeLazyCat> ketil: Manatee is integrated environment provide those sub-module.
03:32:16 <ketil> I thought it was an IDE, but clearly it goes a bit beyond that, then.
03:32:25 <ManateeLazyCat> ketil: It's IE
03:32:34 <ManateeLazyCat> ketil: Integrated Environment, but not just for develop
03:32:40 <ManateeLazyCat> ketil: Include IDE, but not IDE
03:32:43 <ketil> So more like Gnome or KDE?
03:33:21 <ManateeLazyCat> ketil: You can consider it's Emacs style of Gnome.
03:33:56 <ManateeLazyCat> ketil: You can use GTK+ develop any graphics program you want, but work like Emacs style.
03:34:24 <ManateeLazyCat> ketil: Use keyboard control graphics program, but mouse also support too. :)
03:36:16 <ManateeLazyCat> XMonad focus is weird, sometime can focus correctly, sometime can't, i need think.....
03:36:33 <ManateeLazyCat> Maybe XMonad have special policy....
03:42:39 <ManateeLazyCat> I love Google's real-time preview....
03:43:33 <Jafet> Doesn't work for PDFs, though. Die ACM, IEEE, S-V, die.
03:47:12 <ManateeLazyCat> Jafet: But i have many pdf book need read. :)
03:53:16 <qooo> why yi-editor never releases?
03:53:59 <Jafet> Because it's not emacs yet
03:54:05 <daimrod> qooo: vaporware ?
03:55:03 <qooo> Jafet: maybe a new emacs is too much
03:55:24 <qooo> Jafet: it would have been released if aiming on vim
03:59:01 <qooo> i wonder if any author of my installed cabal packages is a girl :p
04:00:58 <Eduard_Munteanu> Last time I heard, people were saying yi's vim mode is a mere mockup.
04:01:36 <osfameron> last I tried, it was
04:01:46 <dcoutts_> qooo: it's probably best not to wonder or to ask
04:01:48 <edlinde> hi all, I wanted to test "pure "Hey" :: [String] " on my ghci but it says "pure" is not in scope
04:02:00 <edlinde> so I wonder how do I get around this? some sort of import?
04:02:06 <Eduard_Munteanu> @hoogle pure
04:02:07 <lambdabot> Control.Applicative pure :: Applicative f => a -> f a
04:02:08 <edlinde> but can i do this in ghci? or a file is needed?
04:02:17 <Eduard_Munteanu> edlinde: you can
04:02:18 <ziman> import Control.Applicative, I suppose
04:02:24 <edlinde> just in ghci?
04:02:25 <Eduard_Munteanu> Yes.
04:02:41 <ManateeLazyCat> All problem between Manatee and XMonad is focus problem.
04:02:42 <edlinde> yep worked
04:02:51 <edlinde> it just changed my Prelude prompt
04:02:55 <qooo> edlinde: sure? i think it should be :m +
04:02:58 <ziman> some people prefer :m+, I use import.
04:03:06 <nlogax> qooo: they both work
04:03:26 <Eduard_Munteanu> ManateeLazyCat: what happens? Does focus shift from one window to another many times very fast?
04:03:30 <ManateeLazyCat> I found two, one is popup window wrong focus, and another is XMonad's 'toggleWS' function
04:03:34 <edlinde> so I am thinking the way to think of pure in applicative functors is to think what is the smallest value in say a list that "makes sense"?
04:03:40 <edlinde> would I be right in this assumption?
04:03:44 <qooo> nlogax: yeah it is, my fault
04:03:58 <ManateeLazyCat> Eduard_Munteanu: I think Manatee popup input window let user input.
04:04:03 <ManateeLazyCat> Eduard_Munteanu: And that confuse XMOnad
04:04:09 <edlinde> did i make sense there? :)
04:04:14 <ManateeLazyCat> Eduard_Munteanu: Manatee works fine in Gnome,
04:04:41 <ManateeLazyCat> Eduard_Munteanu: I think that focus problem can fix by modified Manatee's source code.
04:05:00 <ManateeLazyCat> Eduard_Munteanu: I'm investigate 'toggleWS' strange behaviour....
04:05:31 <ziman> edlinde, I think of them as singletons or consts.
04:05:48 <edlinde> ziman: ok... singletons sounds better
04:05:54 <Eduard_Munteanu> edlinde: hm, better as functor application itself
04:06:04 <edlinde> ziman: so for say a tree, pure would imply a single node in the tree ?
04:06:33 <ziman> yes. (I'm thinking whether the laws actually enforce this...)
04:06:40 <Eduard_Munteanu> ManateeLazyCat: a simple but non-satisfactory fix would be not to make that window floating.
04:07:04 <Eduard_Munteanu> @src Applicative
04:07:04 <lambdabot> class Functor f => Applicative f where
04:07:04 <lambdabot>     pure  :: a -> f a
04:07:04 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
04:07:33 <ManateeLazyCat> Eduard_Munteanu: I think i can fix that by modified Manatee, add some WM properties...
04:08:04 <edlinde> these applicative functors are pretty hardcore... so I need them to understand Monads?
04:08:11 <Eduard_Munteanu> I think pure can certainly create some context, i.e. be non trivial.
04:08:21 <ziman> edlinde, to satisfy the (Identity) condition, it's inevitable, I think: http://applicative.functor.sk/
04:09:19 <edlinde> are functors and applicative functors used a lot in practise?
04:09:25 <ziman> edlinde, um, I don't really think they're hardcore, neither are monads; have you seen the tutorial "you might have invented monads (and maybe you already have)"?
04:09:28 <ziman> edlinde, yes.
04:09:32 <edlinde> I am finding it hard to think of a time when I will use them
04:09:40 <Eduard_Munteanu> Who takes up a whole subdomain for applicatives? :)
04:09:48 <ziman> parsing, for example.
04:10:00 <ziman> combinatorial parsing, that is.
04:10:02 <edlinde> parsing using applicative functors?
04:10:14 <ziman> it's *very* elegant and powerful.
04:10:16 <edlinde> hmmm combinatorial parsing might make sense 
04:10:39 <edlinde> but you can do combinatorial stuff with normal list comprehensions too yeah?
04:10:58 <ziman> not parsing — the applicative values are not lists.
04:11:12 <edlinde> I suppose since <*> on a list already provides the list comprehension .. so maybe best use that
04:11:32 <edlinde> so what would they look like?
04:11:34 <edlinde> for example
04:11:46 <edlinde> would they looks like "Just a", "Just 2" 
04:11:48 <edlinde> blah?
04:11:59 <edlinde> but then you cannot mix those types yeah
04:12:06 <Eduard_Munteanu> Applicatives also makes sense when you don't actually need a monad, just some of its properties.
04:12:29 <ziman> edlinde, but there have been propositions to return monad comprehensions back to haskell (thus generalizing list comprehensions) — then you could use those for applicatives, usually, too
04:12:29 <edlinde> ok
04:12:36 <Eduard_Munteanu> (remember that return is just like pure)
04:12:48 <ziman> > Just (+1) <*> Just 3
04:12:48 <lambdabot>   Just 4
04:12:49 <edlinde> I haven't yet read about monads
04:13:05 <edlinde> so know nothing about it... still with Applicative Functors and Monoids
04:13:07 <ziman> ^^ very easy, it's just using "wrapped" values instead of pure values
04:13:27 <earthy> hm. blagh. I recall having read a blogarticle once on how to neatly push global options down into a calculation while not necessarily using a reader monad for it
04:13:30 <edlinde> ziman: yeah that part I get
04:13:32 <ziman> with suitable handling of the wrapping (where suitable depends on the type/application)
04:13:39 <earthy> anybody know where I might find that article again?
04:13:40 <ziman> > Nothing <*> Just 3
04:13:41 <lambdabot>   Nothing
04:14:00 <Eduard_Munteanu> edlinde: monads provide their own 'pure' and a way to collapse the double application of 'pure' to a single 'pure'. These are the return and join operations.
04:14:09 <ziman> using applicative functors, you can avoid long case-sequences
04:14:18 <Eduard_Munteanu> And monads are also functors.
04:14:32 <Eduard_Munteanu> They have fmap.
04:14:57 <edlinde> ok will go back to reading on then :)
04:15:01 <edlinde> but thanks guys
04:15:09 <ziman> edlinde, suppose you have two Maybe Ints and you want to sum them
04:15:27 <ziman> and do the right thing when one of them is Nothing
04:15:43 <edlinde> yeah <*> would come handy
04:15:47 <ziman> you can either case-match on them, or just lift the (+) into Maybe.
04:16:29 <ziman> and these cases/settings are ubiquitous.
04:26:06 <ziman> and, it's general, too — you can do similar things with lists, functions, parsers...
04:26:06 <Cheery> whee. I'm getting text width out here. :)
04:26:36 <ziman> > [(+1),(+2),(+3)] <*> [10,20,30]
04:26:37 <lambdabot>   [11,21,31,12,22,32,13,23,33]
04:29:18 * ksf_ wants uniqueness typing.
04:29:38 <ksf_> http://hackage.haskell.org/packages/archive/blaze-builder/0.2.0.1/doc/html/src/Blaze-ByteString-Builder-Internal.html#toByteStringIOWith
04:30:16 <ksf_> that's just scary. the executed io action could retain a pointer to the buffer, and then we've broken referential transparency.
04:30:40 <ksf_> otoh, it's bloody useful to do what the function's doing.
04:34:41 <lars9> ls
04:34:52 <lars9> @hoogle ls
04:34:52 <lambdabot> Data.Graph.Inductive.Graph lsuc :: Graph gr => gr a b -> Node -> [(Node, b)]
04:34:52 <lambdabot> Data.Graph.Inductive.Graph lsuc' :: Context a b -> [(Node, b)]
04:34:52 <lambdabot> Text.Regex.Base.RegexLike newtype AllSubmatches f b
05:09:24 * hackagebot network 2.3 - Low-level networking interface  http://hackage.haskell.org/package/network-2.3 (JohanTibell)
05:17:24 <ManateeLazyCat> XMonad looks can't support floating window well. :(
05:20:19 <paolino> hello, I need a help with this code http://hpaste.org/41377/parse_existential . parseSerial just gives always Nothing. 
05:20:48 <paolino> *Main> parseSerial "1" [Serial $ (0::Integer)]
05:20:48 <paolino> Nothing
05:23:31 <Entroacceptor> ManateeLazyCat: what do you mean?
05:24:06 <ManateeLazyCat> Entroacceptor: Manatee can't work in XMOnad, because's floating window (new popup window) confuse XMonad.
05:24:15 <ManateeLazyCat> Entroacceptor: And manatee can't focus correctly
05:24:20 <ManateeLazyCat> @package manatee
05:24:20 <lambdabot> http://hackage.haskell.org/package/manatee
05:24:24 <ManateeLazyCat> Entroacceptor: ^^^^
05:25:22 <Entroacceptor> ManateeLazyCat: do you set the proper flags for the windows?
05:25:56 <Entroacceptor> oh, packaged it? :)
05:26:22 <paolino> anyone, please ?
05:27:28 <ManateeLazyCat> Entroacceptor: Yes.
05:27:33 <ManateeLazyCat> Entroacceptor: You can install it. 
05:27:56 <Entroacceptor> ManateeLazyCat: I've got the -darcs version installed
05:28:06 <ManateeLazyCat> Entroacceptor: Something like my interactivebar : http://www.flickr.com/photos/48809572@N02/5154125200/lightbox/
05:28:20 <ManateeLazyCat> Entroacceptor: In Gnome, i popup new window and stick parent window.
05:28:44 <ManateeLazyCat> Entroacceptor: Then i foucs parent window, works well in Gnome
05:29:17 <ManateeLazyCat> Entroacceptor: But looks XMOnad focus popup window forcely. :(
05:29:47 <ManateeLazyCat> Entroacceptor: What do you mean "set the proper flags for the windows"? I need add some XMOnad config?
05:31:08 <Entroacceptor> ManateeLazyCat: no, it's just that some apps forget to set the proper hints, so that xmonad looks confused, but in fact it's the application that can't cope with xmonad not using the prefered size
05:32:04 <lars9> ManateeLazyCat: hi i see chinese text in your screenshots, are you chinese?
05:32:08 <Entroacceptor> best example: firefox
05:32:11 <ManateeLazyCat> Entroacceptor: I see, i will research XMOnad behaviour and set some window proper on Gtk2Hs side.
05:32:16 <ManateeLazyCat> lars9: Yes.
05:32:26 <Entroacceptor> ManateeLazyCat: but best ask on the mailing list
05:32:36 <ManateeLazyCat> Entroacceptor: Ok, thanks for help.
05:32:37 <Entroacceptor> ManateeLazyCat: or try it in some other tiling wms
05:33:00 <Entroacceptor> ManateeLazyCat: if everyone else does it wrong, it's probably xmonad's fault. If not, youre ;)
05:33:04 <Entroacceptor> * yours
05:33:21 <ManateeLazyCat> Entroacceptor: Ok, i see. :)
05:33:37 <ManateeLazyCat> Entroacceptor: But i'm not XMonad expert. 
05:33:42 <ManateeLazyCat> Entroacceptor: I will try to my best.
05:33:51 <ManateeLazyCat> Entroacceptor: Perhaps i need write some Wiki page first.
05:34:00 <lars9> ManateeLazyCat: awesome
05:34:32 <ManateeLazyCat> lars9: Chinese people not too many? Like visit in Zoo?
05:34:33 <ManateeLazyCat> :)
05:34:49 <ManateeLazyCat> Entroacceptor: Let people how to write application in Manatee framework.
05:38:53 <ManateeLazyCat> Entroacceptor: What's most new feature you want add in Manatee?
05:39:27 <lars9> is there a website similar to lambda-the-ultimate but only about haskell?
05:40:34 <Entroacceptor> paolino: can you patternmatch on lists?
05:41:40 <paolino> Entroacceptor: I solved, thanks, it was "Just . Serial. (`asTypeOf` x) $ y'"
05:42:03 <paolino> sometimes <$> hypnotizes me
05:42:05 <Entroacceptor> ahm ofc
05:42:39 <ManateeLazyCat> Entroacceptor: Can you talk some features you don't like in Manatee? I want improve it.
05:43:06 <Entroacceptor> ManateeLazyCat: haven't tried lots, yet
05:43:26 <Entroacceptor> ManateeLazyCat: but I want session saving, with more than one saved state
05:44:05 <ManateeLazyCat> Entroacceptor: Something like layout save list. I can build IDE layout for develop, and build Music blog layout to search Music resource....etc.?
05:44:21 <Entroacceptor> a bit
05:44:32 <ManateeLazyCat> Entroacceptor: When i select those session list, it will open buffer and adjust layout automatically?
05:45:22 <ManateeLazyCat> Entroacceptor: Or you want Manatee save your last layout, it will restore those layout when you next time start it?
05:45:22 <Entroacceptor> ManateeLazyCat: use case example, I'm hacking on manatee, so I have some .hs files, a shell with directory ~/workspace/manatee and IRC with #haskell open
05:45:47 <Entroacceptor> ManateeLazyCat: then I'm switching to my diploma thesis, which closes IRC, opens some .tex files and a pdf viewer
05:46:05 <Entroacceptor> that's a thing I've wanted so long
05:46:34 <ManateeLazyCat> Entroacceptor: So you want session manager, that you can switch different session for different kind work?
05:47:24 <ManateeLazyCat> Entroacceptor: Shell or terminal module still in developing, i think i will release new manatee-temrinal in the soon future.
05:47:24 <Entroacceptor> ManateeLazyCat: that would be so cool, yes
05:47:32 <jmcarthur> so is the idea behind manatee to be kind of a swiss army knife? i'm a little confused about it
05:47:39 <jmcarthur> maybe i should just try it out
05:47:54 <srobertson> the 's' in "ST s" and "STRef s a", other than RealWorld, is a dummy type used only to ensure one doesn't mix different ST contexts. is that right?
05:47:58 <ManateeLazyCat> Entroacceptor: Ok, i have add your suggestion in my TODO list, i will find some time to implement it.
05:48:04 <ManateeLazyCat> Entroacceptor: Thanks for your suggestion.
05:49:10 <ManateeLazyCat> jmcarthur: More than that.
05:49:12 <ManateeLazyCat> jmcarthur: :)
05:49:28 <ManateeLazyCat> jmcarthur: My aim is build super cool environment and hacking for you want. :)
05:49:28 <MrAI> How would I go about creating a list containing 1x1 up to 9x9?
05:49:46 <Zao> MrAI: All 81 combinations?
05:49:47 <ManateeLazyCat> jmcarthur: For *fast* *safe* and *flexibility*. :)
05:49:49 <jmcarthur> my impression of it right now is that it's a collection of applications with a shared gui
05:49:52 <MrAI> Yes Zao
05:50:14 <lars9> MrAI: string?
05:50:28 <MrAI> a list of the numbers so I can check if they are palindromes
05:50:31 <ManateeLazyCat> jmcarthur: Those application running in separate processes, and i create some gtk2hs code to share those different applications in share GUI.
05:50:41 <MrAI> I have it all worked out apart from generating my list
05:50:42 <sipa1024> MrAI: give an example?
05:50:47 <sipa1024> MrAI: i'm not sure what you want
05:50:58 <jmcarthur> i'm curious what advantages it could offer over my current setup with various applications running in xmonad
05:50:59 <ManateeLazyCat> jmcarthur: Then you can use it like Gnome, but with uniform interface and behaviour.
05:51:05 <MrAI> 1x1 2x1 3x1.... [1,2,3...]
05:51:17 <ManateeLazyCat> jmcarthur: It's MVC design
05:51:21 <sipa1024> MrAI: but what are those?
05:51:23 <sipa1024> strings?
05:51:27 <ManateeLazyCat> jmcarthur: You can split current window with many parts.
05:51:29 <MrAI> Ints in the list
05:51:35 <jmcarthur> ManateeLazyCat: as in i can attach a different GUI to a common backend?
05:51:37 <ManateeLazyCat> jmcarthur: But those different split view share same data (model)
05:51:41 <jmcarthur> ah
05:51:47 <sipa1024> MrAI: do you mean multiplication?
05:51:49 <MrAI> Yes
05:51:55 <MrAI> Sorry if I was uncler
05:51:57 <MrAI> *unclear
05:52:05 <ManateeLazyCat> jmcarthur: So you can use split operation to mix different application in some layout.
05:52:07 <sipa1024> [ x*y | x<-[1..9], y<-[1..9] ]
05:52:09 <Zao> > let op = (*) in [x `op` y | x <- [1..3], y <- [1..3]]
05:52:10 <lambdabot>   [1,2,3,2,4,6,3,6,9]
05:52:18 <jmcarthur> ManateeLazyCat: oh, so it's composable?
05:52:20 <MrAI> Thanks - I didnt know you could do that
05:52:38 <jmcarthur> ManateeLazyCat: is it similar to conal's Tangible Values research?
05:52:40 <ManateeLazyCat> jmcarthur: So it's need use MVC design your GTK+ program.
05:52:44 <Zao> You can probably do cute stuff in the List monad too.
05:52:51 <ManateeLazyCat> jmcarthur: I don't know what's is it.
05:53:19 <ManateeLazyCat> jmcarthur: Because it's Model/View split, you can running GTK+ program in backend and without display it.
05:53:30 <lars9> Zao: how to write that without list comprehension?
05:53:41 <ManateeLazyCat> jmcarthur: You just need switch tab when you want see some module.
05:54:06 <ManateeLazyCat> jmcarthur: I think perhaps yes.
05:54:07 <hpc> lars9: (*) <$> [1..3] <*> [1..3]
05:54:11 <ManateeLazyCat> jmcarthur: If you want different GUI.
05:54:12 <jmcarthur> ManateeLazyCat: tangible functional programming is essentially an attempt to bring composition into the GUI
05:54:12 <hpc> > (*) <$> [1..3] <*> [1..3]
05:54:13 <lambdabot>   [1,2,3,2,4,6,3,6,9]
05:54:19 <Zao> > do { x <- [1..3]; y <- [1..3]; return (x*y) }
05:54:20 <lambdabot>   [1,2,3,2,4,6,3,6,9]
05:54:37 <ManateeLazyCat> jmcarthur: I never read conal's paper.
05:54:50 <jmcarthur> ManateeLazyCat: it's cool research. you may enjoy learning about it
05:54:53 <ManateeLazyCat> jmcarthur: Those idea in my mind when i was crazy emacs user.
05:55:00 <ManateeLazyCat> jmcarthur: LInk?
05:55:04 <jmcarthur> there's also a google tech talk somewhere
05:55:09 <jmcarthur> lemme find a couple links
05:55:15 <ManateeLazyCat> jmcarthur: Thanks! :)
05:55:15 <fryguybob> > [1..3] >>= \x -> [1..3] >>= \y -> return (x * y)
05:55:16 <lambdabot>   [1,2,3,2,4,6,3,6,9]
05:55:38 <ManateeLazyCat> jmcarthur: It's different you running many different program in XMOnad.
05:56:00 <ManateeLazyCat> jmcarthur: Because you just can got *one view* of different program 
05:56:01 <jmcarthur> ManateeLazyCat: http://conal.net/papers/Eros/ and http://www.youtube.com/watch?v=faJ8N0giqzw
05:56:16 <hpc> > liftM2 (*) [1..3] [1..3]
05:56:16 <lambdabot>   [1,2,3,2,4,6,3,6,9]
05:56:20 <ManateeLazyCat> jmcarthur: In Manatee, you can split current program with any number window.
05:56:57 <lars9> hpc: are Monad/Applicative/Functor overlapping?
05:57:03 <jmcarthur> ManateeLazyCat: i'm not sure i'm convinced that you are talking about something xmonad can't do yet. i see the power in separating the backends from the frontends
05:57:05 <ManateeLazyCat> jmcarthur: Looking...
05:57:17 <ManateeLazyCat> jmcarthur: Yes.
05:57:31 <hpc> lars9: list is an instance of all three; monads can implement applicative and functor
05:57:45 <ManateeLazyCat> jmcarthur: Infact, program just need backend to run, you just need frontend when you want view data.
05:58:09 <jmcarthur> ManateeLazyCat: oh, so it's kind of like emacs server and emacs client in that sense
05:58:16 <hpc> er, derp
05:58:18 <ManateeLazyCat> jmcarthur: Something like, you can use editor edit some file, you can hide editor *view* when you on browser,
05:58:21 <unkanon> is there a ghci online somewhere? that will let me let functions (so no lambdabot and no tryhaskell)
05:58:32 <hpc> you can implement applicative from monad, but not functor
05:58:36 <ManateeLazyCat> jmcarthur: And editor buffer still running in backend, but view is destroy
05:58:43 <lars9> hpc: whats the <$> equivalent in Monad?
05:58:54 <ManateeLazyCat> jmcarthur: When you want switch editor again, it will create view widget to display editor buffer.
05:59:12 <hpc> @free Monad m => (a -> b) -> m a -> m b
05:59:12 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
05:59:13 <ManateeLazyCat> jmcarthur: Like Emacs' Buffer and Window
05:59:25 <jmcarthur> lars9: liftM
05:59:27 <hpc> @djinn Monad m => (a -> b) -> m a -> m b
05:59:27 <ManateeLazyCat> jmcarthur: In Emacs, buffer is MODEL, window is VIEW
05:59:27 <lambdabot> -- f cannot be realized.
05:59:29 <fryguybob> @where typeclassopedia -- lars9
05:59:29 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
05:59:31 <Zao> ManateeLazyCat: How do you handle situations when the application needs to know things about the view? Say for example that the application needs to know the dimensions of a window, or whether the screen is locked, or whether it has focus?
05:59:48 <Zao> It's extremely hard to make a generic completely decoupled model, view and controller.
06:00:00 <unkanon> ManateeLazyCat: in vim too, no?
06:00:13 <jmcarthur> Zao: i've not seen many cases where a model actually cares at all about the view, myself
06:00:21 <Zao> Or heck, if the application needs to capture bits of the view.
06:00:32 <Zao> jmcarthur: In an application where MVC fits, sure.
06:00:37 <jmcarthur> Zao: have you an example?
06:00:40 <Zao> It doesn't for all, though.
06:01:46 <Zao> It adds lots of complexity for very little gain if you're to run a GUI application completely detached.
06:01:54 <Zao> Not to mention persisting the view state across detachings.
06:02:06 <jmcarthur> persisting the view state sounds counter to the purpose here
06:02:32 <jmcarthur> hmm, but maybe not... ManateeLazyCat? ^^
06:03:07 <ManateeL`> Zao: So Window manage is in daemon side.
06:03:13 <jmcarthur> Zao: if that's what the goal is then i agree. persisting the view state isn't a great separation of the model from the view
06:03:46 <ManateeL`> jmcarthur: Yes, all state is save in model.
06:03:53 <ManateeL`> jmcarthur: View widget just for display it.
06:04:18 <ManateeL`> Zao: I use TChan build a broadcast channel to connection model and veiw in sub-processes.
06:04:40 <ManateeL`> Zao: See http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/, you will understand my point. :)
06:05:08 <jmcarthur> ManateeL`: okay then it seems like Zao's point stands, to me. you must necessarily store view-specific data in the model in order to persist it, right?
06:05:35 <ManateeL`> jmcarthur: Yes, all state data in save in model.
06:05:54 <ManateeL`> jmcarthur: When we need display it, i will create new view widget to render model state
06:06:16 <Zao> ManateeL`: So you're restricted to pure GTK for your UI too? That makes things a lot easier, and a lot less powerful.
06:06:35 <Zao> I'm coming from a native proper perspective, where you don't have luxury like off-screen HWNDs.
06:06:41 <ManateeL`> Zao: Not really, i still have some view state.
06:06:55 <jmcarthur> ManateeL`: is there a way to add my own view to an existing model? how would i persist my own view state for an existing backend, if so?
06:07:16 <ManateeL`> jmcarthur: I ues TVar
06:07:30 <Cheery> damn with these statevars
06:07:31 <Cheery> in GL
06:07:35 <Cheery> how do they work?
06:07:40 <ManateeL`> jmcarthur: Infact, view state is duty of Window Manager
06:07:57 <jmcarthur> Cheery: they aren't complicated, but i still hate them. they make much of my preexisting opengl knowledge obsolete
06:08:29 <Cheery> jmcarthur: how do you resize viewport?
06:08:32 <jmcarthur> ManateeL`: heh then i'm still confused. but i must go now. i will be back later. we should continue the conversation later (perhaps after i've actually played with manatee)
06:08:48 <jmcarthur> Cheery: don't remember. i g2g, sorry
06:08:48 <Zao> jmcarthur: They map reasonably 1:1 to state though.
06:08:50 <ManateeL`> jmcarthur: Play it will help. :)
06:09:03 <ManateeL`> jmcarthur: Sorry my English is not so good, confuse you. :(
06:09:15 <Zao> Much like how SlimDX types and members map reasonably 1:1 to native DirectX.
06:09:22 <jmcarthur> Zao: yes, but they require learning new names for old ideas with no gain in composability
06:09:45 <jmcarthur> okay, really going now
06:12:01 <Cheery> Couldn't match expected type `GLsizei' against inferred type `Int'
06:12:32 <Cheery> alright. this one is taking too long.
06:12:46 <ManateeLazyCat> Entroacceptor: Happy hacking manatee, let me know if you have any problem with it. :)
06:13:02 <Cheery> cya.
06:13:20 <ManateeLazyCat> Entroacceptor: You can read manatee-editor for a quick start.
06:13:36 <Entroacceptor> ManateeLazyCat: if I find time... :)
06:13:38 <ManateeLazyCat> Entroacceptor: I'm now writing Chinese/English documentation/wiki for Manatee.
06:13:46 <ManateeLazyCat> Entroacceptor: Then fix XMOnad issue.
06:14:01 <shapr> Good Morning #haskell! How's code treating everybody?
06:14:17 <fryguybob> shapr: Excellent.
06:14:22 <ManateeLazyCat> Entroacceptor: Infact, many code can fix in 5 minutes. :)
06:14:29 <ManateeLazyCat> s/fix/finish
06:14:31 <shapr> fryguybob: Yay! What code are you writing?
06:14:44 <ManateeLazyCat> Entroacceptor: Like webkit code for manatee-browser.
06:15:08 <ManateeLazyCat> Entroacceptor: Currently, every module still every basic, i hope code is simple enough make user can hacking it. :)
06:15:38 <fryguybob> shapr: Not so much writing right now but thinking about denotational design.
06:15:47 <shapr> fryguybob: Tell me more!
06:16:49 <fryguybob> shapr: Conal's http://conal.net/blog/posts/denotational-design-with-type-class-morphisms/ fits very well with some non-haskell work that I have done.
06:16:53 <ManateeLazyCat> Why gmane.org looks no response for my new create mail-listing?
06:17:01 <fryguybob> It clearly works out much better in haskell :D.
06:17:08 <ManateeLazyCat> Anybody know how to create new mail-listing ?
06:17:33 <shapr> fryguybob: What code did you write that did this sort of thing?
06:18:09 <fryguybob> My thinking of it before was as "language driven design" where I write an ideal DSL that simply captures the problem, then implement something to work with that language (embedded dsl or a dsl directly).
06:18:21 <fryguybob> Custom CAD stuff.
06:18:24 <lars9> ManateeLazyCat: google group can do that
06:18:28 <shapr> fryguybob: That makes sense so far.
06:18:33 <ManateeLazyCat> lars9: Google Group filter in China.
06:18:40 <ManateeLazyCat> lars9: Because GFW
06:18:44 <ManateeLazyCat> @google GFW
06:18:46 <lambdabot> http://www.gfw.k12.mn.us/
06:19:05 <fryguybob> Denotational design is a little more fine grained than language oriented and points to why that approach gives good results.
06:19:20 <shapr> Wow, that sounds really cool. I must read this paper.
06:19:31 <ManateeLazyCat> GFW : http://en.wikipedia.org/wiki/Golden_Shield_Project
06:20:40 <fryguybob> shapr: Also http://lukepalmer.wordpress.com/2008/07/18/semantic-design/
06:20:52 <lars9> ManateeLazyCat: google group is the only maillist i know...
06:20:57 <shapr> My employer is starting a project that uses a framework for distributed computing from zeroc.com. I want to write a binding for that framework in Haskell. Previously I've heard that attoparsec is best for protocol implementation in Haskell, is that still true?
06:21:07 <ManateeLazyCat> lars9: I use gmane.org
06:21:31 <ManateeLazyCat> lars9: I have subscripte something at http://gmane.org/subscribe.php , but looks no response
06:21:47 <shapr> ManateeLazyCat: It takes time for gmane.org to subscribe to a mailing list.
06:21:57 <ManateeLazyCat> shapr: How long?
06:22:06 <shapr> ManateeLazyCat: I don't know, last time I tried it, it took several days.
06:22:14 <ManateeLazyCat> shapr: I subscribe yesterday.
06:22:27 <shapr> ManateeLazyCat: Thus I would suggest you give them at least a week.
06:22:45 * shapr cabal installs manatee-browser
06:23:01 <shapr> Oh hey! Is there a popcon for hackage?
06:23:17 <ManateeLazyCat> shapr: Should be "cabal install manatee-core manatee-anything manatee-browser manatee"
06:23:27 <ManateeLazyCat> shapr: If you just want browser.
06:24:12 <ManateeLazyCat> shapr: I fill "Mailing list email address" (http://gmane.org/subscribe.php) with "manatee@public.gmane.org", can work?
06:24:29 <shapr> I don't know, it's been years since I've added a mailing list to gmane.org
06:24:34 <tonkman> Any windows gurus here?
06:24:47 <ManateeLazyCat> shapr: Or i need create mail for that mail-listing self?
06:24:56 <shapr> ManateeLazyCat: I don't understand that question.
06:25:10 <shapr> ManateeLazyCat: You will need to create the google mailing list yourself, and then gmane can subscribe to the mailing list.
06:25:23 <shapr> tonkman: I don't know much about windows, but if you have a Haskell-specific question, I might be able to help.
06:25:35 <ManateeLazyCat> shapr: Can't gmane.org build new mail for my mailing list?
06:25:44 <shapr> ManateeLazyCat: I don't understand that question.
06:25:51 <ManateeLazyCat> shapr: I found yi mailing-list use yi-devel-/JYPxA39Uh5TLH3MbocFFw@public.gmane.org
06:26:12 <tonkman> well, I have haskell+hgl program that hangs on server 2003, but not on, for example, windows 7
06:26:26 <tonkman> a hello world :)
06:26:33 <shapr> ManateeLazyCat: That address is most likely a hash of the actual address.
06:26:43 <tonkman> so hgl doesnt work at all
06:26:57 <ManateeLazyCat> shapr: I mean if i fill "Mailing list email address" with "manatee@gmane.org", the administor of gmane.org will create that mail address for my mailing list?
06:27:20 <tonkman> Graphics.Win32 although works
06:27:26 <shapr> tonkman: Did you build the binary on a ghc + hgl + opengl libs installed on that same server 2003?
06:27:33 <tonkman> yes
06:27:40 <ManateeLazyCat> shapr: After you finish "cabal install manatee-core manatee-anything manatee-browser manatee" , type url in manatee *search* interface, and hit "Alt + m" will open in browser. 
06:27:40 <tonkman> with ghc --make Main
06:27:41 <shapr> ManateeLazyCat: From what I remember, I think the answer is Yes.
06:27:54 <ManateeLazyCat> shapr: Fair enough, thanks!
06:28:09 <ManateeLazyCat> shapr: Noticed, manatee can't work in XMonad now, you need Gnome to run it. :)
06:28:31 <tonkman> runghc or running on ghci works neither
06:28:44 <ManateeLazyCat> shapr: Ok, i will waiting gmane.org mail some days. :)
06:28:45 <shapr> tonkman: Sounds like you've done the right things to me. At this point I'd suggest checking to see if the OpenGL drivers on the different systems offer different levels of OpenGL support?
06:29:06 <tonkman> Why OpenGl?
06:29:17 <shapr> tonkman: If neither runghc nor ghci work, it sounds like you may not have a full build of ghc?
06:29:18 <tonkman> isnt HGL just using Win32
06:29:29 <Zao> I hate the name of HGL.
06:29:42 <Zao> As it has nothing to do with OpenGL at all.
06:29:47 <Zao> (as far as I know)
06:29:49 <tonkman> shapr: they work, but running the program on them, doesnt
06:30:02 <FunctorSalad> Zao: :o good to know
06:30:05 <tonkman> Zao: yes, I think so too
06:30:16 <FunctorSalad> (I'd have thought it does)
06:30:20 <shapr> tonkman: Last I checked, the Haskell OpenGL bindings call the OpenGL libraries for your platform, and thus require a certain amount of support from the system itself.
06:30:22 <Zao> The OpenGL one is HOpenGL or something along those lines.
06:30:26 * shapr wonders if that was too circular
06:30:33 <Zao> shapr: http://hackage.haskell.org/package/HGL
06:30:35 <tonkman> Im downloading now huge debuging package from microsoft
06:31:05 <shapr> Wait, does HGL do OpenGL stuff?
06:31:08 <Zao> shapr: NO!
06:31:09 <tonkman> I wish I can locate the problem
06:31:24 <shapr> Zao: Thanks for pointing out my confusion.
06:31:29 <Zao> It's a portable drawing toolkit that uses X11 or Win32 :D
06:31:36 * shapr rewinds
06:31:55 <fryguybob> tonkman: Can you paste your hello world code?
06:32:04 <Zao> tonkman: Do you have an XP64 or XP box where it breaks too?
06:32:44 <tonkman> Nope, havent try on XP
06:32:47 * hackagebot ListLike 2.0.0 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-2.0.0 (JohnLato)
06:33:09 <tonkman> fryguybob: http://hackage.haskell.org/packages/archive/HGL/3.2.0.2/doc/html/Graphics-HGL.html
06:33:25 <Zao> 2003 is after all 5.2, which is two revs below Seven, which is 6.1.
06:33:42 <Zao> If it worked on XP (5.1) or XP64 (5.2), you'd localized it to a server SKU.
06:35:10 <tonkman> windows debugger says:
06:35:17 <tonkman> *** ERROR: Symbol file could not be found.  Defaulted to export symbols for ntdll.dll - 
06:35:20 <tonkman> ntdll!DbgBreakPoint:
06:35:48 * hackagebot ListLike 2.0.1 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-2.0.1 (JohnLato)
06:36:41 <fryguybob> tonkman: running that in ghci hangs for me but ghc --make and it works fine.
06:37:14 <tonkman> imo running in ghci should hang
06:37:38 <tonkman> Im not sure
06:37:47 <ManateeLazyCat> shapr: Success on manatee-browser?
06:38:37 <shapr> ManateeLazyCat: webkit build failure: Configuring webkit-0.12.0... \n setup: gtk2hsHookGenerator: Invalid character in input file: \n MSTRI
06:39:10 <ManateeLazyCat> shapr: Hmm, webkit package failed?
06:39:25 <ManateeLazyCat> shapr: Wait, i try.
06:40:12 <dolio> @yarr!
06:40:12 <lambdabot> Well Ahoy! thar.
06:40:17 <shapr> ManateeLazyCat: I'm using ubuntu 10.10 and I did apt-get install libwebkit-dev and then cabal install webkit
06:40:20 <shapr> @yarr!
06:40:20 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
06:40:37 <shapr> Heh, I added those quotes for International Talk Like a Pirate day :-)
06:40:49 <ManateeLazyCat> shapr: I doubt you use gtk2hs-buildtools-0.11.x that can't parse webkit-0.12.0
06:41:02 <ManateeLazyCat> shapr: I have reinstall it successful.
06:41:21 <ManateeLazyCat> shapr: Please "cabal install gtk2hs-buildtools-0.12.0" first
06:42:00 <shapr> ManateeLazyCat: Yes, it seems that I had an older version installed.
06:42:15 <ManateeLazyCat> shapr: That problem will fix after you isntall gtk2hs-buildtools-0.12.0
06:42:30 <ManateeLazyCat> shapr: Please let me know if you still have problem with it.
06:42:40 <shapr> I will, thanks!
06:44:34 <lars9> ManateeLazyCat: are you Peter Gavin at http://www.haskell.org/gtk2hs/development/ ?
06:44:36 <ManateeLazyCat> @package manatee
06:44:36 <lambdabot> http://hackage.haskell.org/package/manatee
06:44:46 <ManateeLazyCat> lars9: I'm Andy Stewart
06:44:56 <ManateeLazyCat> lars9: /whois ManateeLazyCat
06:44:58 <ManateeLazyCat> :)
06:45:36 <lars9> not listed in gtk2hs's page?
06:46:34 <ManateeLazyCat> lars9: http://code.haskell.org/gtk2hs/AUTHORS
06:47:00 <ManateeLazyCat> lars9: I join gtk2hs last year. :)
06:47:13 <ManateeLazyCat> lars9: So i'm new to you guys. :)
06:47:43 <lars9> yeah you should let them add you to gkt2hs' webpage
06:47:58 <ManateeLazyCat> lars9: I don't care.
06:48:22 <ManateeLazyCat> lars9: I just care gtk2hs whether can work for haskeller. :)
06:50:57 <shapr> I like that approach.
06:51:25 <roconnor> hey shapr
06:51:25 <ManateeLazyCat> shapr: Compile success now?
06:52:53 <shapr> howdy roconnor 
06:53:16 <shapr> ManateeLazyCat: manatee-core is now compiling... and my laptop cpu is getting hot!
06:53:26 <ManateeLazyCat> shapr: Good, 
06:53:46 <ManateeLazyCat> shapr: After manatee package compile finish, you can type "manatee" to play it. :)
06:54:49 <roconnor> anyone know where I can find the paradise boilerplate benchmark?
06:55:16 <aavogt> @where syb
06:55:16 <lambdabot> http://www.cs.vu.nl/boilerplate
06:56:02 <roconnor> You don't have permission to access /boilerplate on this server.
06:56:54 <aavogt> roconnor: you mean this snippet http://web.archive.org/web/20080622204226/http://www.cs.vu.nl/boilerplate/#paradise ?
06:57:39 <roconnor> heh, that isn't as sophisticated as I imagined.
07:03:58 * hackagebot flock 0.2.1 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.2.1 (ErikHesselink)
07:04:36 <ManateeLazyCat> shapr: If you use Linux, i suggest you use gold-linker instead ld to improve link speed.
07:04:54 <ManateeLazyCat> shapr: Install all manatee modules, ld use 9m, gold-linker use 6m
07:08:15 <ManateeLazyCat> http://haskell.org/haskellwiki/User:AndyStewart created
07:11:55 * ManateeLazyCat Creating wiki page for Manatee.
07:12:31 <dino-> oof, http://darcs.haskell.org/yaht no longer available or any working link to PDF format from Wikibooks for it.
07:14:33 * Saizan wouldn't recommend yaht anyway
07:14:52 <dino-> It's all about Learn You now, isn't it?
07:15:09 <Saizan> yeah
07:15:19 <dino-> Just a little before my time, never read it, but definitely I should.
07:15:22 <Saizan> but even if that wasn't around i still wouldn't recommend yaht :)
07:15:49 <Philippa> eh, in favour of the gentle introduction still
07:16:17 <aavogt> Saizan: what's wrong with yaht?
07:17:13 * aavogt doesn't remember anything bad in particular
07:17:56 <tibbe> what's Ross Patterson's nickname?
07:17:57 <dino-> It's got a couple of incomplete parts, like continuations. But yaht was very valuable for me.
07:18:21 <Saizan> aavogt: starts with IO, presents foldr and foldl as if the main difference was the way things get associated, gets into a random detour about CPS ..
07:18:29 <Saizan> and then i think i stopped reading it
07:18:31 <dino-> Nobody really needs to learn about cont at the beginner stage, it could be argued.
07:18:34 <Taejo> is yaht Hal's tutorial? I found it much more helpful after I knew a bit of Haskell already
07:18:46 <aavogt> Taejo: yes
07:18:54 <dino-> Taejo: ya, I can agree with that.
07:19:39 <Taejo> I can't remember how I first learned haskell, though
07:19:46 <Philippa> CPS is useful for some people to know they have available, in a "now I know I can do anything, let's find out how to do it well" kinda way
07:21:00 <MrAI> Why does [a:b:c:[]|a<-[1..1000],b<-[a+1,1000],c<-[b+1..1000], ((a*a)+(b*b))==c*c,(a+b+c)==1000] work in the GHCi but not when i do triplet = [a:b:c:[]|a<-[1..1000],b<-[a+1,1000],c<-[b+1..1000], ((a*a)+(b*b))==c*c,(a+b+c)==1000] ?
07:21:32 <Saizan> i also remember i had to study lisp to get a description of "function application as justaxposition"
07:21:46 <magicman> MrAI: to define things in ghci, you use let.
07:21:52 <sipa1024> > [a:b:c:[]|a<-[1..1000],b<-[a+1,1000],c<-[b+1..1000], ((a*a)+(b*b))==c*c,(a+b+c)==1000]
07:21:52 <magicman> So: let triplet = ...
07:21:53 <lambdabot>   []
07:22:06 <Saizan> *juxtaposition
07:22:25 <MrAI> See even lambdabot returns [] but when run in the ghci it gives me results
07:22:39 * Saizan had a Java/Perl/Python background
07:22:57 <sipa1024> MrAI: no results in my ghci
07:23:14 <Saizan> Perl/Python made it more difficult because they have it for some special cases, probably :)
07:23:17 <MrAI> Just type [a:b:c:[]|a<-[1..1000],b<-[a+1,1000],c<-[b+1..1000], ((a*a)+(b*b))==c*c,(a+b+c)==1000]
07:23:19 <MrAI> without the let
07:23:31 <dino-> Ah, I already had the gentle intro pdf squirrelled away here and didn't know it.
07:23:44 <aristid> :t [a:b:c:[]|a<-[1..1000],b<-[a+1,1000],c<-[b+1..1000], ((a*a)+(b*b))==c*c,(a+b+c)==1000]
07:23:45 <lambdabot> forall t. (Num t, Enum t) => [[t]]
07:23:49 <sipa1024> MrAI: don't you mean a+1..1000 instead of a+1,1000 ?
07:24:02 <Taejo> I think I learned Haskell by trying to read A Gentle Introduction, failing miserably (the fact that one can't type arbitrary Haskell code into Hugs' REPL was part of what tripped me up), then learning a couple lisps (Scheme in a here's a bit about functional programming kind of way, and Common in a writing actual programs way)
07:24:07 <MrAI> Ah so I do
07:24:10 <MrAI> Thanks, silly me :D
07:24:11 <aristid> :t [a:b:c:[]|a<-[1..1000],b<-[a+1..1000],c<-[b+1..1000], ((a*a)+(b*b))==c*c,(a+b+c)==1000]
07:24:12 <lambdabot> forall t. (Num t, Enum t) => [[t]]
07:24:16 <aavogt> many of the () are redundant
07:24:17 <MrAI> Damn typo :p
07:24:29 <aavogt> in fact, all of them I think
07:24:34 <Taejo> and then coming back to A Gentle Introduction and finding it much easier
07:24:45 <aristid> :t [[a,b,c]|a<-[1..1000],b<-[a+1..1000],c<-[b+1..1000], a*a+b*b==c*c,a+b+c==1000]
07:24:46 <lambdabot> forall t. (Num t, Enum t) => [[t]]
07:24:53 <MrAI> Yeh they are all gone - I typed it wrong and thought maybe it needed ()
07:25:08 <MrAI> Thanks all :D
07:25:36 <Saizan> aavogt: oh, also, when it actually bothers to explain IO (severl chapters after you have to use it in exercises) it uses World -> (World,a)
07:25:41 <roconnor> @hoogle traverse
07:25:41 <lambdabot> Data.Traversable traverse :: (Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
07:25:41 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
07:25:57 <ManateeLazyCat> shapr: manatee-browser running well?
07:26:14 <revenantphx> My new favorite "legal C99 of the day":
07:26:15 <revenantphx> int32_t x = *(int32_t*) (int8_t[]){0x01, 0x02, 0x03, 0x04};
07:26:39 <sipa1024> MrAI: this is faster:
07:26:41 <sipa1024> [ (a,b,c) |a <- [1..1000],b <- [a+1..1000-a],c <- [1000-a-b], a*a+b*b==c*c ]
07:26:56 <aristid> revenantphx: i would use "\x01\x02\x03\x04" if so inclined
07:27:03 <revenantphx> aristid: true.
07:27:12 <ziman> revenantphx, why is it legal?
07:27:18 <aristid> ziman: because it is.
07:27:20 <revenantphx> What do yo umean.
07:27:26 <revenantphx> because the spec says so, and it compiles.
07:27:32 <engla> why not? there are explicit casts
07:27:43 <revenantphx> (int8_t[]){0x01, 0x02...} is a compound literal.
07:27:49 <revenantphx> It's not "really" a cast.
07:27:50 <ziman> bad question — i thought you couldn't cast differently sized ints arbitrarily
07:28:02 <ziman> pointers to differently-sized ints
07:28:13 <revenantphx> you can always cast, but if you cast from short to long or something, you may pick up some stack trash.
07:28:32 <engla> there are no rules for casting :-)
07:28:42 <revenantphx> casting is telling the compiler who's boss.
07:28:57 <sipa1024> and this will give you different results on a big-endian machine
07:29:01 <revenantphx> sipa1024: yep
07:29:10 <revenantphx> that gives you 0x04030201
07:29:14 <revenantphx> on my little endian intel box.
07:29:28 <sipa1024> as it should
07:29:41 <sipa1024> it will be 0x01020304 on big-endian
07:31:11 <revenantphx> aristid: you could use strings like you said, but
07:31:20 <revenantphx> then it's not so easy to use arbitrary variables :D
07:31:38 <revenantphx> int32_t x = *(int32_t*) (int8_t[]){a, b, c->d, c->e};
07:31:38 <revenantphx> w/e
07:31:53 <ziman> i wouldn't be surprised if you had to have (int32 *) ptrs aligned to 4-byte boundaries on some architectures
07:32:15 <revenantphx> it's a pointer, it doesn't matter what it points too, it's aligned the same way.
07:34:11 * hackagebot template 0.2.0.2 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.2 (JohanTibell)
07:35:03 <ziman> for example, ARMs raise an access violation exception if you try to dereference such pointers, according to this: http://stackoverflow.com/questions/1237963/alignment-along-4-byte-boundaries
07:35:47 <ziman> (or they just silently load wrong data :) )
07:37:01 <roconnor> I wish record updates had the same syntax as a declaration set.
07:38:22 <ManateeLazyCat> I should build some extension to edit Haskell Wiki, like i build Yaoddmuse (http://www.emacswiki.org/emacs/Yaoddmuse) for EmacsWiki
07:38:54 <sm> ManateeLazyCat: sounds good. Or convert it to a gitit wiki 
07:39:32 <ManateeLazyCat> sm: In Yaoddmuse, i just need fill content, all markup can complete automatically.
07:39:49 <ManateeLazyCat> sm: If i have time, i will build Manatee extension for it.
07:40:08 <sm> congrats on manatee btw, it sounds pretty cool
07:40:33 <ManateeLazyCat> sm: Thanks, still in early develop, all module still very basic.
07:40:39 <ManateeLazyCat> sm: Just core framework finish.
07:41:03 <ManateeLazyCat> sm: I hope more people can hacking it to write them own extension, i'm writing HaskellWiki page.
07:41:11 <sm> is it like a graphical shell/window manager/api for gnome libs ?
07:41:33 <ManateeLazyCat> sm: No, it's pure Haskell build everything.
07:41:39 <ManateeLazyCat> sm: Don't need any gnome library.
07:41:54 <sm> it uses cairo and gtk, I guess that's what I meant
07:41:56 <ManateeLazyCat> sm: It's a self include program, don't need WM.
07:42:05 <sm> so it implements a WM
07:42:05 <ManateeLazyCat> sm: Yes, cairo and gtk+
07:42:40 <ManateeLazyCat> sm: It's more like mini WM for manatee itself, not like conventional WM for all GTK+ program.
07:42:55 <sm> right. Well you seem very productive with it 
07:43:29 <ManateeLazyCat> sm: It's just beginning, :)
07:43:33 <sm> :)
07:44:48 <ManateeLazyCat> sm: I hope someday, we only use Haskell program. :)
07:45:09 <sm> ManateeLazyCat: have you really stopped using emacs ?
07:45:20 * sm is reading your emacswiki page
07:45:28 <ManateeLazyCat> sm: Just for mail-client until i implement mail-client in Manatee.
07:45:36 <sm> whoa
07:46:02 <Saizan> roconnor: declaration set?
07:46:51 <roconnor> Saizan: instead of writing record { salary = \s -> incS k s } I"d 
07:47:03 <roconnor> like to write recrod {salary s = incS k }
07:47:06 <roconnor> like to write recrod {salary s = incS k s}
07:47:12 <Saizan> ah, yeah
07:47:17 <roconnor> well this is a bad example since I can eta-contract
07:47:39 <roconnor> but I'd like to pattern match and stuff
07:47:42 <Saizan> that's a big oversight
07:47:44 <roconnor> in general
07:47:53 <MrAI> What function would take a Integer, split up it by each number and turn it into a list? e.g. 1245 = [1,2,4,5]
07:48:15 * hackagebot hyena 0.1.0.1 - Simple web application server  http://hackage.haskell.org/package/hyena-0.1.0.1 (JohanTibell)
07:48:16 <MrAI> Or would I need to turn it into a String, then a list of Chars?
07:49:04 <ziman> show? :)
07:49:15 <Saizan> maybe with some extension you can write let Record{..} = record; salary s = incS k s in Record{..}, but that's a bit confusing
07:49:37 <MrAI> ziman : Show turns my integer into a String
07:50:06 <ziman> :t digitToInt
07:50:07 <lambdabot> Char -> Int
07:50:50 <MrAI> I have a long integer that I want to turn into a list of integers... e.g. 1234 to [1,2,3,4]
07:50:56 <Entroacceptor> MrAI: that list isn't a unique representation
07:51:25 <Entroacceptor> 1234 could be [1,0,0,1,1,0,1,0,0,1,0], too
07:51:39 <MrAI> How so?
07:51:40 <Entroacceptor> so I guess show is the way to go
07:51:44 <Entroacceptor> in binary
07:51:51 <MrAI> Ok
07:52:02 <Entroacceptor> or [2, 3, 2, 2] in oct :)
07:52:02 <MrAI> How do I go from show to a list of chars?
07:52:36 <Entroacceptor> show is Int -> [Char]
07:52:45 <Entroacceptor> > show 5
07:52:46 <lambdabot>   "5"
07:52:51 <Entroacceptor> :t show 5
07:52:52 <lambdabot> String
07:53:13 <MrAI> But I cant do : sum( show 1245)
07:53:30 <Entroacceptor> ziman told you, digitToInt
07:53:41 <Twey> MrAI: Of course you can't.  Adding chars makes no sense.  Did you mean a list of ints?
07:53:41 <Entroacceptor> > map digitToInt (show 1234)
07:53:42 <lambdabot>   [1,2,3,4]
07:54:00 <MrAI> Ah ok - thats how its done
07:54:05 <fryguybob> > let f ds n | n > 0 = f (n `mod` 10:ds) (n `div` 10) | otherwise = ds in f [] 1234
07:54:06 <lambdabot>   [1,2,3,4]
07:54:07 <MrAI> I didnt think to use map
07:55:23 <MrAI> map digitToInt (show 1234)
07:55:40 <MrAI> > map digitToInt (show 1234)
07:55:40 <lambdabot>   [1,2,3,4]
07:55:51 <Twey> > sum . map digitToInt $ show 1234
07:55:52 <lambdabot>   10
07:56:17 <MrAI> "map digitToInt (show 1245)" doesnt work in ghci but it does in lambdabot
07:56:36 <Twey> import Data.Char
07:56:43 <MrAI> Ah I got it
07:56:47 <fryguybob> @hoogle digitToInt
07:56:47 <lambdabot> Data.Char digitToInt :: Char -> Int
07:56:50 <Twey> (and mention the error next time something ‘doesn't work’)
07:56:52 <MrAI> map Char.digitToInt (show 12345)
07:56:55 <MrAI> Thanks
07:56:57 <Twey> … no
07:57:12 <MrAI> no?
07:57:18 <Twey> import Data.Char
07:57:18 <MrAI> Its a ghci thing
07:57:33 <Twey> Char is a legacy H98 name for Data.Char
07:57:42 <MrAI> Ah ok
07:58:11 <Twey> The fact that you can reference a function from a module in qualified form without loading the module first is a GHCi idiosyncracy
07:58:30 <Twey> You should just import Data.Char and use the name unqualified; that's what you'd have to do in a real program, anyway.
07:58:39 <MrAI> I see
08:01:52 <ManateeLazyCat> HaskellWiki update after some delay?
08:02:28 <ManateeLazyCat> Damn it, i lost my wiki page data.
08:04:16 <roconnor> w00t, my paradise benchmark works
08:04:28 <MrAI> Is: import qualified Data.Char (digitToInt) right?
08:05:15 <ManateeLazyCat> I have write some simple Manatee manual at http://haskell.org/haskellwiki/Manatee enjoy!
08:05:59 <Saizan> ?hoogle digitToInt
08:05:59 <lambdabot> Data.Char digitToInt :: Char -> Int
08:06:49 <gds> MrAI: You can import everything that module wants to export, or you can import just the functions you explicitly ask for....
08:07:09 <gds> What you seem to be doing there is asking specifically for just digitToInt
08:07:25 <Twey> Not in GHCi
08:07:34 <gds> No? Oh :)
08:07:46 <Twey> GHCi doesn't support qualified imports, AFAIK
08:07:50 <MrAI> As soon as I put import Data.Char above my "module Main where" my program doesnt load
08:07:59 * aavogt checks if import syntax in ghci-7 has been fixed as claimed
08:08:00 <Twey> (the ‘import’ syntax itself is just sugar for :m +, in GHCi)
08:08:11 <gds> Ah.
08:08:20 <Twey> MrAI: That's because it goes underneath it
08:08:21 <stepcut>  MrAI: the imports go after module Main where
08:08:25 <aristid> Twey: at least before ghc 7, which supposedly improves that
08:08:30 <Twey> aristid: Oh good
08:09:38 <aavogt> Twey: ghci-7 (RC2) seems to handle the full syntax
08:09:41 <aristid> Twey: the migration to ghc 7 will be interesting, i'm sure :)
08:10:08 <ManateeLazyCat> Welcome to edit page http://haskell.org/haskellwiki/Manatee
08:10:38 <MrAI> module Main
08:10:38 <MrAI>  where
08:10:38 <MrAI> import Data.Char
08:10:44 <MrAI> Is that right?
08:11:45 <MrAI> If I do that then my first function in the list throws a parse error
08:12:29 <Twey> No; read a Haskell tutorial.  The contents of the module must be indented as much as or more than the line containing the ‘where’.
08:12:46 <Twey> @where lyah
08:12:46 <lambdabot> http://www.learnyouahaskell.com/
08:12:55 <Twey> — lots of people recommend this book for starting out
08:13:14 <Twey> But I'm not sure if it covers module syntax and so on, so you might be better off with RWH
08:13:23 * hackagebot manatee 0.0.5 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.5 (AndyStewart)
08:13:24 <opqdonut> Twey: that's not correct
08:13:35 <opqdonut> MrAI: that works, at least on ghc
08:13:38 <ManateeLazyCat> Just docs update, code is same.
08:13:39 <MrAI> This is the first time ive come accross modules - till this point all my code has worked fine
08:13:47 <opqdonut> at least for me
08:13:58 <aavogt> you only have to align to the next non-whitespace character after where
08:14:15 <opqdonut> yes
08:14:32 <Twey> Really?  I thought I tried that and discovered otherwise a while back
08:14:50 <MrAI> I dont understand what your saying
08:14:52 <Twey> Oh, well — okay.
08:15:19 <gds> MrAI: haskell is sensitive to layout. If you indent a program wrong, then it won't compile.
08:15:42 <MrAI> Ok.
08:15:43 <MrAI> I have :
08:15:44 <MrAI> module Main 
08:15:51 <MrAI> What spaces do I need to put in?
08:16:16 <aavogt> just put where right after Main, and don't indent anything
08:16:24 <MrAI> ok
08:16:42 <aavogt> you can only put one module per file, so there's no sense in indenting the body of the module
08:17:05 <MrAI> Thanks - ok im back to loading again
08:17:42 <gds> as aavogt says, there's no sense in indenting the whole module - But  if you start indenting it, then you have to carry on doing so, otherwise ghc will complain.
08:17:54 <MrAI> I see
08:18:30 <MrAI> Thanks
08:18:36 <gds> np
08:19:08 <aavogt> for the details of syntax, the haskell report is probably your best option
08:19:27 <MrAI> Where is that found?
08:19:42 <gds> How readable is the haskell report for beginners? I confess, I've never actually read it....
08:19:45 <aavogt> if tutorials described everything that was legal syntax, there'd be no space for teaching you what the code means
08:19:54 <aavogt> @where report
08:19:54 <lambdabot> http://www.haskell.org/onlinereport/
08:23:37 * ManateeLazyCat No more mail, i'm crazy now.... :(
08:24:14 <MrAI> lol
08:26:13 <ManateeLazyCat> Found funny blog http://int.github.com/ and http://int.github.com/2010/07/06/some_random_thoughts_about_learning_haskell.html
08:26:20 <ManateeLazyCat> Unlearn and free yourself to embrace a new world. Take a deep breath and forget all those idiom/design-pattern/concepts/OO-coolness in your old language. Why? because "class is not class, instance is not instance, function is not function, return is not return, blah is not blah any more".
08:29:02 <ManateeLazyCat> I love words "Unlearn and free yourself to embrace a new world".
08:29:51 <magicman> A whole new world. A new fantastic point of view...
08:29:58 <magicman> </earworm>
08:30:28 <ManateeLazyCat> magicman: True,
08:30:40 <ManateeLazyCat> magicman: I can't leave Haskell anymore!
08:31:09 <Entroacceptor> MrAI: do you know 'read', btw?
08:31:28 <Entroacceptor> > map read $ show 1234
08:31:29 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:31:29 <lambdabot>         against inferred ty...
08:31:33 <Entroacceptor> oh
08:31:53 <gds> @type read
08:31:54 <lambdabot> forall a. (Read a) => String -> a
08:32:10 <gds> > sum $ map read $ show 1234
08:32:11 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
08:32:11 <lambdabot>         against inferred ty...
08:32:15 <gds> Ah well :)
08:33:34 <Entroacceptor> > map (read $ flip (:) []) $ show 1234
08:33:35 <lambdabot>   Couldn't match expected type `[a -> GHC.Types.Char]'
08:33:35 <lambdabot>         against inferr...
08:33:41 <Entroacceptor> dang =)
08:34:39 <mm_freak> i'm constantly switching between haskell+yesod (home) and php+zend (work)…  this really messes up your brain
08:34:53 <gds> > sum $ map (read $ (:[])) $ show 1234
08:34:54 <lambdabot>   The section `: []' takes one argument,
08:34:54 <lambdabot>  but its type `GHC.Base.String' has ...
08:35:02 <otto_s_> > map (read . (:[])) $ show 1234
08:35:03 <lambdabot>   [*Exception: Prelude.read: no parse
08:35:45 <byorgey> I think it is defaulting to ()
08:35:56 <otto_s_> > (map (read . (:[])) $ show 1234) :: [Int]
08:35:57 <lambdabot>   [1,2,3,4]
08:36:12 <gds> Woo!
08:36:13 <gds> :)
08:37:24 * gds clearly still doesn't quite understand the difference between "$" and ".".
08:37:25 <Entroacceptor> aaah :D
08:37:40 <gds> Getting better, but still not great.
08:37:41 <Entroacceptor> the dot is point-free, of course ;)
08:37:49 <byorgey> everyone always asks what the "difference" is between $ and ., but this is a meaningless question
08:38:04 <Botje_> gds: the second argument to (.) has to be a function
08:38:21 <byorgey> it is like asking what is the difference between 'map' and 'filter'
08:38:27 <gds> > sum $ map (read . (:[])) $ show 1234
08:38:28 <lambdabot>   10
08:38:34 <byorgey> they are just different functions.
08:38:46 <byorgey> although they tend to be used in similar sorts of situations.
08:38:46 <Botje_> gds: f $ g $ h $ x is the same as (f . g . h) x or just f . g . h $ x
08:39:00 <aavogt> the question is really when to use one instead of the other
08:39:17 <gds> I think I often get it right if I'm paying attention, but trip up over it when I'm not...
08:39:19 <byorgey> you must deeply understand what they ARE, and only then will you understand how they are different.
08:39:55 * gds will just have to practice more.
08:40:04 <byorgey> yup, that's the best way =)
08:40:16 <byorgey> and while you are practicing, keep in mind these three things:
08:40:17 <ManateeLazyCat> byorgey: Most time, . is clearer
08:40:23 <byorgey> 1) types  2) types  3) types
08:40:31 <gds> @type (.)
08:40:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:40:35 <gds> @type ($)
08:40:36 <lambdabot> forall a b. (a -> b) -> a -> b
08:40:43 <byorgey> oh, except don't ask lambdabot for the type of (.)
08:40:49 <gds> heh
08:40:54 <byorgey> that is the type of (.) in Caleskell
08:41:04 <gds> I seemed to remember them having the same type....
08:41:21 <byorgey> (.) :: (b -> c) -> (a -> b) -> (a -> c)
08:42:02 <aristid> :t ((Prelude..), fmap, (<<<))
08:42:03 <lambdabot> forall b c a a1 b1 (f :: * -> *) (cat :: * -> * -> *) b2 c1 a2. (Functor f, Control.Category.Category cat) => ((b -> c) -> (a -> b) -> a -> c, (a1 -> b1) -> f a1 -> f b1, cat b2 c1 -> cat a2 b2 ->
08:42:03 <lambdabot> cat a2 c1)
08:42:08 * aavogt wonders about the existence of a .!
08:42:20 <aavogt> @src ($!)
08:42:20 <lambdabot> f $! x = x `seq` f x
08:42:36 <gds> Out of curiosity, what's lambdabot talking about when I ask for the type of (.) ?
08:42:41 <aristid> (a .! b) x = a $! b x
08:42:46 <gds> Another definition of (.) in some module somewhere?
08:42:50 <aristid> aavogt: like that?
08:42:55 <gds> Or another way of thinking about the usual one?
08:43:13 <aavogt> or should (b x) force x first?
08:45:07 * aavogt interprets seq rather loosely
08:45:40 <aristid> aavogt: as in (a .! b) x = a $! b $! x?
08:45:47 <djahandarie> gds, in lambdabot (.) is fmap
08:45:50 <Vanadium> gds: Another, more general, definition
08:46:16 <gds> Ah :)
08:46:25 <djahandarie> gds, which works because there is a Functor instance for functions
08:46:29 * gds has been reading the typeclassopedia, and has some vague clue....
08:46:38 <aavogt> aristid: so which of the three options makes sense (if any)?
08:46:39 <gds> But not /much/ ;)
08:46:54 * shapr hugs aristid 
08:47:00 <aristid> aww
08:47:14 <aristid> shapr: you always manage to surprise
08:47:16 <djahandarie> > fmap (+2) (+5) $ 3
08:47:17 <lambdabot>   10
08:47:24 <aristid> aavogt: three? i only saw too
08:47:29 <shapr> aristid: Yay! Surprise hugs! Better than surprise ghci?
08:47:29 <aristid> *two
08:47:47 <aristid> shapr: ghci is just no surprise anymore
08:47:56 <aavogt> aristid: a .! b = \x -> a $ b $! x
08:48:05 <aristid> aavogt: ah.
08:48:19 <aristid> aavogt: i tend towards (a .! b) x = a $! b x
08:48:23 <gds> djahandarie: That looks like a cool thing - is it likely to change that way in ghci? 
08:48:30 <ray> which version of base am i supposed to depend on these days, >=4?
08:48:33 <djahandarie> gds, nope, that'll never happen
08:48:39 <aristid> ray: yes
08:48:53 <djahandarie> gds, the functor instance is in Control.Monad.Instances
08:48:56 <aavogt> it needs a max bound to please hackage
08:49:05 <djahandarie> gds, but the (.) symbol will never be overwritten like that
08:49:23 <gds> Ah, so you don't want to force dependancies on that module...
08:49:52 <ray> >=4 && <5 then
08:49:57 <gds> djahandarie: If you do it the lambdabot/Cale way, does that allow you do do anything new? Or is it just "fun" ?
08:50:25 <djahandarie> It allows you to fmap more succinctly, but that is it
08:50:33 * gds nods
08:50:38 <magicman> There's also (Control.Category..) :: Category cat => cat b c -> cat a b -> cat a c
08:50:46 <djahandarie> > (*2).[1,2,3,4]
08:50:47 <lambdabot>   [2,4,6,8]
08:50:52 <magicman> Which is yet another interpretation of (.).
08:51:16 <gds> Ah...
08:51:21 * djahandarie goes to school, bbl
08:51:32 <aavogt> some people redefine it to    (.) = flip ($), or similar
08:51:57 <danr> @type (.)
08:51:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:52:02 <danr> @type flip ($)
08:52:03 <lambdabot> forall a b. a -> (a -> b) -> b
08:52:04 <aavogt> so you end up with    tupleOfTuples.fst.snd
08:52:44 <aavogt> which isn't any sort of generalization
08:52:51 <aristid> and habit apparently does interesting things with . too
08:53:26 <danr> I like that...
08:53:28 <ray> what, you don't think @pl output is the whisperings of an elder god?
08:53:59 <Starfire> Studying @pl too closely will make you mad?
08:54:01 * hackagebot template 0.2.0.3 - Simple string substitution  http://hackage.haskell.org/package/template-0.2.0.3 (JohanTibell)
08:54:04 <aristid> @pl \a (b, c) d -> a b c d
08:54:04 <lambdabot> (`ap` snd) . (. fst)
08:54:09 <ray> @pl \f h t a g n -> n g a t h f
08:54:10 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
08:54:10 <aristid> hmm that was too easy
08:54:15 <jmcarthur> i would also lean toward (a .! b) x = a $! b x. it's more flexible. you can still get a $! b $! x by saying a .! b $! x, and you can get a . b $! x easily enough anyway
08:54:56 <ray> the elder god flip`ap`id
08:55:10 <jmcarthur> :t flip <*> id
08:55:10 <lambdabot>     Occurs check: cannot construct the infinite type: a = f (a -> b)
08:55:10 <lambdabot>       Expected type: a
08:55:10 <lambdabot>       Inferred type: f (a -> b)
08:55:13 <Twey> \a (b, c) d -> a b c d = uncurry
08:56:00 <ray> :t curry $ snd &&& fst
08:56:01 <lambdabot> forall a b. a -> b -> (b, a)
08:56:23 <Twey> swap . (,)
08:56:29 <Twey> flip (,)
08:56:31 <jmcarthur> flip (,)
08:56:33 <jmcarthur> bah
08:56:35 <Twey> :þ
08:56:41 <ray> NO THORNS
08:56:54 <ray> http://nothorns.org/favicon.ico
08:56:58 * Twey throws ray into a briar patch.
08:57:13 <ray> just as planned
08:57:22 <Twey> Hehehe
08:57:29 <Twey> Is this your site?
08:57:55 <aavogt> swap is serious business
08:58:06 <dons> ddarius: can you comment on the parsec 2 v 3 thread on libraries@?
08:58:18 <dons> i want to upgrade the HP to parsec 3, but need the support of the maintainer.
08:58:37 <ray> yes
08:58:39 <ray> i really hate thorns
08:59:03 * hackagebot timeplot 0.2.4 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-0.2.4 (EugeneKirpichov)
08:59:44 <Twey> ray: I þink ðat we should restore þorn and eð to ðeir rightful places in the English language, personally
09:00:02 <Twey> Then we can finally distinguish between ‘th’ and… er… ‘th’.  Silly orthography.
09:00:15 <ray> i hope you get fired for looking at þorn sites at work
09:00:27 <Twey> Haha
09:01:04 <fryguybob> > let þ = [] in (:þ) 42
09:01:05 <lambdabot>   [42]
09:02:32 <zygoloid> Twey: i think it'd be easier to persuade people to use the cornish 'dh' instead of eth, and use 'th' for thorn.
09:02:44 <Twey> zygoloid: Probably, but I hate digraphs.
09:03:15 <Twey> Especially when they contain letters already used elsewhere, so you never know whether it's a digraph or just two unfortunate letters that ended up next to one another.
09:05:38 <ManateeLazyCat> Night all! :)
09:09:29 <ray> just call unsafeDestroyUniverse, then you'll have no universe and it's trivial to prove the properties of your lack-of-universe
09:09:43 <roconnor> @hoogle getSum
09:09:44 <lambdabot> Data.Monoid getSum :: Sum a -> a
09:12:14 * hackagebot haskelldb 2.1.0 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.1.0 (JustinBailey)
09:12:16 * hackagebot haskelldb-hdbc 2.1.0 - HaskellDB support for HDBC.  http://hackage.haskell.org/package/haskelldb-hdbc-2.1.0 (JustinBailey)
09:12:18 * hackagebot haskelldb-hdbc-odbc 2.1.0 - HaskellDB support for the HDBC ODBC driver.  http://hackage.haskell.org/package/haskelldb-hdbc-odbc-2.1.0 (JustinBailey)
09:12:20 * hackagebot haskelldb-hdbc-postgresql 2.1.0 - HaskellDB support for the HDBC PostgreSQL driver.  http://hackage.haskell.org/package/haskelldb-hdbc-postgresql-2.1.0 (JustinBailey)
09:12:23 * hackagebot haskelldb-hdbc-sqlite3 2.1.0 - HaskellDB support for the HDBC SQLite driver.  http://hackage.haskell.org/package/haskelldb-hdbc-sqlite3-2.1.0 (JustinBailey)
09:12:25 <dixie> ahojte
09:12:28 <dixie> ccc
09:12:29 <dixie> co to je ?
09:12:42 * dixie oops, sorry wrong channel :-)
09:14:24 * hackagebot haskelldb-th 2.1.0 - Template Haskell utilities for HaskellDB.  http://hackage.haskell.org/package/haskelldb-th-2.1.0 (JustinBailey)
09:17:32 <ray> paul graham? bleh
09:19:49 <aristid> ray: why do you randomly mention a name from some person?
09:20:02 <kamatsu> what has pg done now?
09:20:05 <ray> i was just overtaken by dislike for paul graham there
09:20:21 <ray> (wrong window syndrome, except it was the right window but the wrong channel)
09:20:25 <kamatsu> he is the epitome of "lisp weenie"
09:21:34 <aristid> hmm why would you hate paul graham? he's been right about some things, and wrong about others
09:22:09 <jmcarthur> i found myself amused/disappointed at Arc after all he hyped it up. i find many of his writings to be kind of inspiring, though
09:22:10 <ray> i like a subset of what he writes
09:22:28 <ray> basically just the stuff where he encourages people to consider being entrepreneurs
09:22:29 <Vanadium> I like the definite articles
09:23:15 <jmcarthur> i'm personally not a fan of the VC approach to startups, although not having created a successful startup i am not qualified to diss it fully
09:23:23 <razvandimescu> how would i write a filter like this:->    filter (`mod` 2 ==0) [1..10]
09:23:24 <razvandimescu> ?
09:23:38 <jmcarthur> filter even ;)
09:23:45 <jmcarthur> okay but more seriously:
09:23:49 <Twey> > filter even [1 .. 10]
09:23:50 <lambdabot>   [2,4,6,8,10]
09:24:04 <jmcarthur> > filter ((==0) . (`mod` 2)) [1..10]
09:24:04 <Twey> > filter ((== 0) . (`mod` 2)) [1 .. 10]
09:24:05 <lambdabot>   [2,4,6,8,10]
09:24:05 <lambdabot>   [2,4,6,8,10]
09:24:14 <Adamant> jmcarthur: Arc hasn't panned out, for sure.
09:24:20 <jmcarthur> > filter (\x -> n `mod` 2 == 0) [1..10]
09:24:20 <lambdabot>   []
09:24:27 <jmcarthur> haha
09:24:32 <jmcarthur> > filter (\x -> x `mod` 2 == 0) [1..10]
09:24:33 <lambdabot>   [2,4,6,8,10]
09:24:40 <jmcarthur> > n
09:24:41 <lambdabot>   n
09:24:44 <jmcarthur> bleh
09:24:59 <gds> @type n
09:24:59 <lambdabot> Expr
09:25:04 <jmcarthur> > m + n
09:25:05 <lambdabot>   m + n
09:25:14 <gds> @hoogle Expr
09:25:14 <lambdabot> module Text.Parsec.Expr
09:25:14 <lambdabot> module Text.ParserCombinators.Parsec.Expr
09:25:14 <lambdabot> Text.Parsec.Expr buildExpressionParser :: Stream s m t => OperatorTable s u m a -> ParsecT s u m a -> ParsecT s u m a
09:25:16 <jmcarthur> > foldr f z [a,b,c,d,e]
09:25:17 <lambdabot>   f a (f b (f c (f d (f e z))))
09:25:19 <razvandimescu> cool, thanks
09:25:19 <gds> Ah.
09:25:45 <jmcarthur> > n `mod` 2
09:25:46 <lambdabot>   n `mod` 2
09:25:49 <jmcarthur> > n `mod` 2 == 0
09:25:50 <lambdabot>   False
09:25:52 <jmcarthur> interesting
09:26:14 <jmcarthur> maybe Expr shouldn't be an instance of (==)?
09:26:18 <jmcarthur> of Eq*
09:26:26 <magicman> > (2*n) `mod` 2 == 0
09:26:26 <lambdabot>   False
09:26:32 * magicman calls shenanigans.
09:26:36 <jmcarthur> yeah...
09:26:59 <jmcarthur> > n+m-m == n
09:26:59 <lambdabot>   False
09:27:04 <jmcarthur> > n == n
09:27:05 <lambdabot>   True
09:27:12 <gds> > n == m
09:27:13 <lambdabot>   False
09:27:18 <jmcarthur> > n `mod` 2 == n `mod` 2
09:27:19 <lambdabot>   True
09:27:21 <zygoloid> > n + m - m
09:27:22 <lambdabot>   n + m - m
09:27:31 <jmcarthur> it's basically expression equality
09:27:42 <jmcarthur> not expression equivalence
09:27:43 <magicman> *nod*
09:27:56 <jmcarthur> *value equality
09:28:16 <magicman> > mod n 2
09:28:17 <lambdabot>   n `mod` 2
09:28:22 <magicman> Heh.
09:28:28 <magicman> Cute :P
09:28:44 <jmcarthur> > foldr mod z [a,b,c,d,e]
09:28:45 <lambdabot>   a `mod` (b `mod` (c `mod` (d `mod` (e `mod` z))))
09:29:21 <magicman> > sum [a,b,c,d,e]
09:29:22 <lambdabot>   0 + a + b + c + d + e
09:29:42 <magicman> > scanl (+) [a,b,c]
09:29:43 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
09:29:43 <lambdabot>    arising from a use of...
09:29:50 <magicman> Oh, right.
09:29:57 * magicman fails.
09:30:06 <jmcarthur> :t scanl
09:30:07 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
09:30:16 <jmcarthur> > scanl (+) z [a,b,c]
09:30:17 <lambdabot>   [z,z + a,z + a + b,z + a + b + c]
09:30:34 <magicman> This SimpleReflect is quite neat.
09:31:00 <magicman> > scanr (+) z [a,b,c]
09:31:01 <lambdabot>   [a + (b + (c + z)),b + (c + z),c + z,z]
09:31:17 <magicman> Makes sense...
09:31:19 * jmcarthur has never actually used scanr before
09:31:28 * magicman has never actually used scan* before >_>
09:31:53 <aavogt> @src tails
09:31:53 <lambdabot> tails []         = [[]]
09:31:53 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:31:54 <jmcarthur> > scanr (:) [] "foobar"
09:31:54 <lambdabot>   ["foobar","oobar","obar","bar","ar","r",""]
09:32:00 * Twey has never actually used *l before
09:32:07 <magicman> Wait, no. scanl for the obligatory digits-at-base-n thing.
09:32:20 <Twey> How'd you scanl that?
09:32:41 <magicman> Er, never mind, I really *am* being confused today v_v
09:32:44 <jmcarthur> > scanr (:) [] $ "foo" ++ undefined ++ "bar"
09:32:45 <lambdabot>   ["foo*Exception: Prelude.undefined
09:32:51 <jmcarthur> > map head . scanr (:) [] $ "foo" ++ undefined ++ "bar"
09:32:51 <lambdabot>   "foo*Exception: Prelude.undefined
09:33:14 <jmcarthur> lazy and everything. cool
09:33:42 <jmcarthur> @src scanr
09:33:42 <lambdabot> scanr _ q0 []     =  [q0]
09:33:42 <lambdabot> scanr f q0 (x:xs) =  f x q : qs
09:33:42 <lambdabot>     where qs@(q:_) = scanr f q0 xs
09:33:54 <sjoerd_visscher> Could anybody explain FunctorSalad's quote in HWN? "sum is just the free monoid functor applied to the mediating arrow of the terminality of ()"
09:34:09 <sjoerd_visscher> I get map (const ()) if I try to write it out
09:34:36 <aavogt> @check \xs -> tails xs == scanr (:) [] (xs :: [Bool])
09:34:37 <lambdabot>   "OK, passed 500 tests."
09:34:41 <FunctorSalad> sjoerd_visscher: it's totally wrong, I was drunk :o how did that get into HWN?
09:34:43 <jmcarthur> > reverse $ scanr (+) 0 [undefined,1,2,3,4]
09:34:44 <lambdabot>   [0,4,7,9,10,*Exception: Prelude.undefined
09:34:51 <FunctorSalad> (the function I describe is 'length', not 'sum')
09:34:58 <jmcarthur> okay i like scanr
09:35:09 <FunctorSalad> sjoerd_visscher: I thought I deleted the quote from lambdabot
09:35:29 <FunctorSalad> :-(
09:35:29 <sjoerd_visscher> FunctorSalad: lenght, yes that makes sense
09:35:36 <jmcarthur> @quote mediating
09:35:36 <lambdabot> No quotes match. Wrong!  You cheating scum!
09:35:40 <aavogt> @check \xs -> inits xs == (map reverse $ scanr (flip (:)) [] (xs :: [Bool]))
09:35:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:35:44 <dixie> > [ show (x, y) | x <- [1..1000], y <- [1..1000], x/y == 42 ]
09:35:46 <lambdabot>   ["(42.0,1.0)","(84.0,2.0)","(126.0,3.0)","(168.0,4.0)","(210.0,5.0)","(252....
09:35:50 <aavogt> @check \xs -> inits xs == (map reverse $ scanl (flip (:)) [] (xs :: [Bool]))
09:35:51 <lambdabot>   "OK, passed 500 tests."
09:36:41 <magicman> HWN greps the logs for @remember, it doesn't interact with lambdabot in any way, IIRC.
09:36:48 <jmcarthur> haha
09:37:17 <FunctorSalad> sjoerd_visscher: I was intentionally talking contrivedly to continue the wadler/monad/monoid (mis-?)quote. that's what I get for trying to do that in that state, I guess
09:37:41 <FunctorSalad> I wasn't actually trying to explain something.
09:39:24 <sjoerd_visscher> FunctorSalad: it is FreeMonoid % terminate id with the data-category package
09:39:27 <FunctorSalad> sjoerd_visscher: btw yes, it's map (const :: a -> ()), which is 'length' if you consider [()] as peano numbers :)
09:39:29 <ray> functorsalad: a wadler is just an initial element in the category of stupid haskell category jokes
09:40:07 <FunctorSalad> *const ()
09:40:48 <magicman> That *almost* looked like C.
09:44:01 <Twey> @quote FunctorSalad it's totally wrong, I was drunk :o how did that get into HWN?
09:44:01 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
09:44:04 <Twey> Err
09:44:09 <Twey> @remember FunctorSalad it's totally wrong, I was drunk :o how did that get into HWN?
09:44:09 <lambdabot> Done.
09:44:17 <ray> @quote drunk
09:44:17 <lambdabot> dons says: keroppi: i was thinking of a similar thing recently, on a bus travelling between the hotel and the google summer of code summit, sitting next to guys from apache, python, freebsd, netbsd,
09:44:17 <lambdabot> perl, gentoo... the end of open source was a drunk driver away, with only php goons left to run the show
09:44:40 <Twey> Heh
09:44:46 <FunctorSalad> Twey: thanks, maybe that will partially save my face?
09:45:24 <benmachine> hay guys
09:45:43 <jaredj> i'm about to make trees of (Quilt -> Quilt) functions in an attempt to genetically optimize quilts. is it dumb to use the Arbitrary typeclass from QuickCheck as part of this endeavor?
09:46:24 <FunctorSalad> for purposes other than testing?
09:46:27 <jaredj> yes
09:46:41 <jaredj> to generate arbitrary (Quilt -> Quilt)s
09:47:22 <benmachine> fibon: didn't you get released on hackage a few days ago?
09:47:25 <FunctorSalad> hmm, maybe it isn't the fastest PRNG? don't know
09:47:45 <Twey> FunctorSalad: Maybe, but at any rate it's a damn good quote.
09:47:53 <benmachine> jaredj: if you just want to generate random things, isn't there a Random class for that?
09:48:00 <ray> you're a loose cannon, but you make damn good quotes
09:48:11 <jaredj> yeh, but it just makes numbers
09:48:15 <jaredj> i want random functions
09:48:27 <jaredj> (chosen out of a set i've made)
09:48:28 <jmcarthur> i once considered making a standalone dsl for the specification of random value generation. one that isn't tied to any particular backend or to any particular package like testing libraries
09:48:30 <Twey> It doesn't: it makes any Random
09:48:37 <Twey> :t randoms
09:48:38 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
09:48:44 <jmcarthur> jaredj: there is a type class you can instantiate
09:48:49 <benmachine> yeah, no mention of numbers in Random
09:48:52 <jmcarthur> like Arbitrary
09:48:54 <jaredj> !
09:48:57 <jaredj> ok
09:49:03 <magicman> :i Random
09:49:05 <ray> randoms in haskell are annoying, that's why i didn't bother including an example quantum bogosort in my DestroyUniverse package
09:49:05 <jaredj> :d
09:49:08 <jmcarthur> it's a bit less handy than Arbitrary, unfortunately
09:49:10 <magicman> Hrm.
09:50:14 <benmachine> ray: that sounds like a fun package :>
09:50:37 <ray> honestly it's funnier to explain it than to actually see it, which is why it only exists on my computer
09:50:44 <benmachine> heh
09:51:04 <jaredj> instance Random Cat where ...
09:51:55 <benmachine> anyway, I have a question that isn't technically haskell, but it's sort of data structures - I have a finite set, and a collection of subsets that are pairwise either disjoint or nested, I think this looks a bit like a tree (or forest, perhaps) but I'm not sure
09:52:09 <sjoerd_visscher> FunctorSalad: sum is the terminal object component of the multiplication of the monad defined by the free monoid adjunction
09:52:26 <benmachine> can anyone come up with a reasonably efficient (as in, low 'junk') representation for such an arrangement?
09:53:03 <Vanadium> I cannot believe you guys get to go on talking about sum as some crazy non-arithmetic thing yet I get quote-grabbed for mentioning my C++ highlight
09:53:24 <benmachine> (low 'junk': as little information duplication as possible/as few values that fail the invariant as possible)
09:54:00 <ray> sounds treeish to me
09:54:05 <FunctorSalad> sjoerd_visscher: you mean if we make [()] a Num?
09:54:40 <benmachine> ray: it's a bit treeish but I think all the leaf labels are distinct, which isn't super easy to encode
09:56:04 <FunctorSalad> sjoerd_visscher: for other 'Num A' I guess we use Hask(A,W) ~ HaskMonoid([A],W) and set W=A? ;)
09:56:17 <FunctorSalad> (the adjunction isomorphism)
09:56:50 <FunctorSalad> ignoring that Nums aren't usually declared Monoid instances for their addition, anyway
09:56:55 <benmachine> ray: actually I'm really not sure what the leaf labels are at all, or what it's a tree of >_> I just have the sense that it's kinda-tree-y
09:57:11 <opqdonut> it is a forest
09:57:22 <benmachine> I guess it's a tree of lists
09:57:30 <benmachine> a forest of lists
09:57:36 <opqdonut> what do you need lists for
09:57:48 <opqdonut> a node represents the set of all the keys in the leafs under it
09:58:00 <benmachine> a forest of sets, then?
09:58:14 <opqdonut> a forest, a set of trees
09:58:21 <benmachine> hmm
09:58:23 <opqdonut> you'd probably want parent pointers in there
09:58:34 <opqdonut> so you can go from element a to all the sets X that contain it
09:58:35 <benmachine> pointers are not involved :P
09:58:40 <benmachine> this is a conceptual question
09:58:45 <opqdonut> oh, sure
09:58:54 <opqdonut> just modelling, no operations?
09:59:10 <benmachine> yes
09:59:50 <opqdonut> I think the forest captures it pretty well
09:59:58 <benmachine> hmm okay
10:00:01 * benmachine fiddles with it
10:00:02 <jmcarthur> whenever i hear "in the leafs" i think of free monads. is this perhaps Free Set?
10:00:32 <opqdonut> what does Free Set look like?
10:00:50 <benmachine> context: this is a maths questions about the number of possible topologies on a finite set. I've shown that every toplogy has a basis consisting of U_n = the smallest open set containing n
10:00:55 <jmcarthur> newtype Foo a = Either a (Set (Foo a))
10:01:03 <benmachine> and now I'm trying to work out how I can count the number of possibilities here
10:01:12 <benmachine> the U_n are either disjoint or nested
10:01:32 <jmcarthur> that could also include an annotation keeping track of the number of leaves in each branch, perhaps
10:01:36 <jmcarthur> or whatever you need
10:01:42 <jmcarthur> if it must be tracked incrementally
10:01:59 <jmcarthur> i suck at syntax ^^
10:02:06 <jmcarthur> newtype Foo a = Foo (Either a (Set (Foo a)))
10:02:25 <FunctorSalad> a + Set a + Set^2 a + Set^3 a + ... ? :)
10:02:34 <jmcarthur> ha
10:02:41 <FunctorSalad> (expanding it)
10:02:43 <opqdonut> yyeah
10:02:45 <jmcarthur> that appears to be a correct expansion
10:02:47 <opqdonut> that's not quite it
10:02:52 <jmcarthur> no?
10:02:57 <jmcarthur> oh, right
10:03:00 <opqdonut> constant depth
10:03:07 <jmcarthur> it doesn't have to be balanced like that, yeah
10:03:09 <opqdonut> a nifty type, tho
10:03:23 <opqdonut> reminds me of finger trees
10:03:40 <jmcarthur> finger trees could be simplified into two ideas
10:03:47 <jmcarthur> one is the tree structure, the other is the annotations
10:03:55 <benmachine> hmm I wonder if I could recast this as the number of ways of non-redundantly parenthising an expression
10:04:05 <jmcarthur> s/simplified/decomposed/
10:04:12 <opqdonut> i think: one is the tree+monoid idea. the other is the fingers
10:04:25 <benmachine> (non-redundantly as in not containing ((x)), but I'd allow (x))
10:04:35 <opqdonut> cached reductions as a tree is a useful idea on its own too
10:04:39 <opqdonut> so are fingers
10:04:51 <jmcarthur> the monoidness is specific to that particular structure. it could be more general i think
10:05:03 <opqdonut> benmachine: hmm yeah, I guess that's the same
10:05:27 <jmcarthur> like the operation you would apply cata to
10:06:38 <jmcarthur> the annotations are essentially a catamorphism that you can keep up to date with a changing tree structure :)
10:08:51 <jmcarthur> class FooMeasure a b where measure :: a -> b ; accum :: Either b (Set b) -> b
10:08:54 <byorgey> preflex: seen edwinb
10:08:54 <preflex>  edwinb was last seen on #haskell 134 days, 2 hours, 9 minutes and 8 seconds ago, saying: kosmikus: It doesn't do I/O very well though
10:09:36 <jmcarthur> newtype AnnotatedFoo a b = Foo (Either (a, b) (b, Set (AnnotatedFoo a b)))
10:09:38 <jmcarthur> or something like that
10:12:01 <jmcarthur> and then one of the novelties of the finger tree idea is searching the tree using those annotations. so lovely
10:15:19 * hackagebot authenticate 0.7.2.2 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-0.7.2.2 (MichaelSnoyman)
10:15:39 <byorgey> has anyone here played with idris?  I just installed it but can't get it to do anything other than spit out the error message "idris: Nothing to rename"
10:15:58 <Mitar> is there a way that I would get from a list of values of some data type first values for each constructor of this data type, generically for every data type?
10:16:19 <Mitar> so if I would have data Foo = Foo | Bar and list [Foo, Foo, Bar, Foo] I would get out [Foo, Bar]
10:16:20 <Mitar> ?
10:16:20 * hackagebot http-enumerator 0.2.1.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.1.1 (MichaelSnoyman)
10:16:22 * hackagebot wai-extra 0.2.4.1 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.4.1 (MichaelSnoyman)
10:16:24 * hackagebot wai-handler-devel 0.1.1.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.1.1.1 (MichaelSnoyman)
10:16:40 <jmcarthur> Mitar: nubBy is one way
10:16:48 <FunctorSalad> benmachine: iirc counting partitions is tricky in its own right, isn't it?
10:16:55 <byorgey> Mitar: you could do that easily with any one of the generic programming libraries
10:17:02 <Mitar> like?
10:17:25 <FunctorSalad> benmachine: (though a priori it's possible that this problem is easier than counting partitions for some reason)
10:17:26 * hackagebot yesod 0.6.1.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.1.2 (MichaelSnoyman)
10:17:32 <byorgey> Mitar: like replib or EMGM
10:17:48 <jmcarthur> > nubBy (\x y -> gcd x y == 1) [2..]
10:17:49 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
10:18:02 <jmcarthur> > nubBy (\x y -> gcd x y /= 1) [2..]
10:18:03 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
10:18:10 <byorgey> Mitar: otherwise, you can do it with nub as long as the Eq instances only compare constructors.  But that's probably not what you want to do.
10:18:25 <jmcarthur> that's why i suggested nub*By*
10:18:40 <roconnor> does Hugs support RankNpolymorphism?  does Hugs support GADTs? what about other compilers such as Yhc or Uhc?
10:18:47 <Mitar> yes, but do I have to defined that some helper functions for every data type I would like to use?
10:18:47 <byorgey> nubBy works but you have to implement the comparison function separately for each new data type you want it to work with.
10:18:58 <Mitar> i thought so
10:19:08 <jmcarthur> right
10:19:23 <jmcarthur> oh i missed the "generically for every data type" part
10:20:15 <ray> i don't think hugs and yhc support either, don't know about uhc and my information on those two could be old
10:20:24 <benmachine> FunctorSalad: mm, this problem only required a lower bound bigger than C^n and I got an n! so I'm done (still interesting though)
10:20:27 <Mitar> yes, I would like a function into which I would put a list and would get out such list as I described
10:23:05 <zygoloid> Mitar: what would you expect from yourFunction [Nothing, Just 1, Just 2] ?
10:23:18 <Mitar> [Nothing, Just 1]
10:24:05 <Mitar> and how can EMGM help here?
10:24:13 <sm> yay, go snoyberg
10:24:26 <aavogt> @ty toConstr
10:24:27 <lambdabot> forall a. (Data a) => a -> Constr
10:24:58 <Mitar> ha, I could misuse Show ;-)
10:25:03 <benmachine> :t nubBy ((==) `on` toConstr)
10:25:03 <lambdabot> forall a. (Data a) => [a] -> [a]
10:25:27 <benmachine> Mitar: use Data instead, it's what it's for
10:25:41 <benmachine> hmm no
10:25:46 <benmachine> :t nubBy ((==) `on` constrIndex . toConstr)
10:25:47 <lambdabot> forall a. (Data a) => [a] -> [a]
10:25:53 <jmcarthur> > nubBy ((==) `on` toConstr) [Nothing, Just 1, Just 2]
10:25:54 <lambdabot>   [Nothing,Just 1]
10:25:58 <benmachine> oh
10:26:02 <benmachine> fine them :)
10:26:03 <benmachine> *then
10:26:07 <Mitar> ooo
10:26:21 <Mitar> @hoogle Data
10:26:21 <lambdabot> module Data.Data
10:26:21 <lambdabot> Data.Data class Typeable a => Data a
10:26:21 <lambdabot> Data.Data dataCast1 :: (Data a, Typeable1 t) => c (t d) -> Maybe (c a)
10:26:25 <benmachine> Mitar: toConstr is in Data.Data
10:26:40 <jmcarthur> > nubBy ((==) `on` toConstr) [Left 5, Left 6, Right "foo", Right "bar", Left 7]
10:26:41 <lambdabot>   [Left 5,Right "foo"]
10:26:57 <orlandu63> Mitar: you can also derive the Enum instance for each class and do (nubBy ((==) `on` fromEnum))
10:27:12 <benmachine> orlandu63: only works for nullary datatypes though
10:27:12 <orlandu63> for each data type*
10:27:20 <Mitar> nullary?
10:27:25 <jmcarthur> > sortBy ((==) `on` toConstr) [Left 5, Left 6, Right "foo", Right "bar", Left 7]
10:27:26 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
10:27:26 <lambdabot>         against inferr...
10:27:30 <benmachine> Mitar: ones that don't contain anything
10:27:34 <jmcarthur> > sortBy (comparing toConstr) [Left 5, Left 6, Right "foo", Right "bar", Left 7]
10:27:34 <lambdabot>   No instance for (GHC.Classes.Ord Data.Data.Constr)
10:27:34 <lambdabot>    arising from a use of...
10:27:38 <jmcarthur> aw
10:27:51 <jmcarthur> > sortBy (comparing (constrIndex . toConstr)) [Left 5, Left 6, Right "foo", Right "bar", Left 7]
10:27:51 <benmachine> Mitar: so all the constructors have no arguments
10:27:52 <lambdabot>   [Left 5,Left 6,Left 7,Right "foo",Right "bar"]
10:28:01 <aavogt>  as in, this fails:    data Foo = Foo Int Char deriving (Enum)
10:28:22 <jmcarthur> > map head . groupBy ((==) `on` toConstr) . sortBy (comparing (constrIndex . toConstr)) $ [Left 5, Left 6, Right "foo", Right "bar", Left 7]
10:28:24 <lambdabot>   [Left 5,Right "foo"]
10:28:50 <jmcarthur> ^^ more efficient, less lazy, less terse
10:29:36 <jmcarthur> *more efficient when the whole result will be forced anyway
10:30:00 <Zhuangzi> I am trying out GHC 7 RC2. Where do you chaps usually put your alternate GHC versions? /opt/GHC7? ~/GHCs/7/? I'm curious what the norm is.
10:30:01 <jmcarthur> and under some other scenarios i suppose
10:30:11 <Mitar> sortBy is stable?
10:30:25 <benmachine> I think so
10:30:30 <jmcarthur> Mitar: i don't know if it is by spec, but i think it is as implemented
10:30:39 <jmcarthur> @src sortBy
10:30:39 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:30:45 <sproingie> Zhuangzi: i usually have a directory called /pkg/foo-x.y.z and a symlink /opt/foo that points to whatever version is current
10:30:51 <jmcarthur> uh
10:31:01 <jmcarthur> i don't think that's the real sortBy :)
10:31:06 <jmcarthur> in ghc, anyway
10:31:14 <sproingie> Zhuangzi: i'd probably have a /opt/ghc7 til i wanted to make it the global default of /opt/ghc
10:31:32 <jmcarthur> Zhuangzi: i have a ~/bin and whatever other ~/* dirs i need
10:32:12 <jmcarthur> which i use for more than just ghc
10:32:19 <benmachine> jmcarthur: I have a vague memory that that's the one in the report
10:32:27 <jmcarthur> benmachine: probably is
10:32:34 <jmcarthur> and that doesn't look stable to me
10:32:42 <benmachine> no?
10:32:43 <sproingie> i have the same scheme in alternate roots on some systems, but for my home PC i just attach them to /
10:33:04 <orlandu63> Zhuangzi: if you want to be proper, put it somehwere in $HOME/.local
10:33:08 <Mitar> this one is stable?
10:33:16 <Mitar> insertion sort is stable, as far as I remember ;-)
10:33:18 <sproingie> orlandu63: is that FSSTD or something?
10:33:18 <benmachine> it looks stable to me
10:33:38 <benmachine> insertBy cmp is (:) if cmp returns equal, so sortBy cmp is id :)
10:34:12 <orlandu63> sproingie: i think it's an XDG standard
10:35:20 <Zhuangzi> > sortBy (comparing snd) $ [(2,2),(1,3),(1,1)]
10:35:20 <Zhuangzi> > sortBy (comparing fst) $ sortBy (comparing snd) $ [(2,2),(1,3),(1,1)]
10:35:21 <lambdabot>   [(1,1),(2,2),(1,3)]
10:35:21 <lambdabot>   [(1,1),(1,3),(2,2)]
10:35:24 <jmcarthur> > let sortBy cmp = foldr (insertBy cmp) [] in sortBy (comparing (constrIndex . toConstr)) [Left 5, Left 7, Right "foo", Right "bar", Left 6]
10:35:25 <lambdabot>   [Left 5,Left 7,Left 6,Right "foo",Right "bar"]
10:35:26 <sproingie> orlandu63: ah, looks like it.  i dunno, you populate stuff that way by hand, it's going to expect you have configs and so forth set up too
10:36:16 <jmcarthur> > let sortBy cmp = foldr (insertBy cmp) [] in sortBy (comparing (constrIndex . toConstr)) [Left 5, Left 6, Right "foo", Right "bar", Left 6]
10:36:17 <lambdabot>   [Left 5,Left 6,Left 6,Right "foo",Right "bar"]
10:36:23 <jmcarthur> well duh
10:36:28 <Zhuangzi> sproingie: jmcarthur: Thanks, symlinks sound good. The thought never occured.
10:37:06 <jmcarthur> > let sortBy cmp = foldr (insertBy cmp) [] in sortBy (comparing fst) [(1,3),(2,2),(1,4)]
10:37:07 <lambdabot>   [(1,3),(1,4),(2,2)]
10:37:22 <sproingie> Zhuangzi: sun used to organize their internal software distributions that way, though they threw in some wrapper scripts to support multi-arch installs without automount trickery
10:37:23 <jmcarthur> okay i guess i'm convinced
10:38:22 <jaredj> @pl do { f <- liftM ([id] !!) next; x <- next; y <- next; return (f x y) }
10:38:22 <lambdabot> (line 1, column 4):
10:38:22 <lambdabot> unexpected "{"
10:38:22 <lambdabot> expecting variable, "(", operator or end of input
10:38:26 <Zhuangzi> sproingie: Sure. I'm eager to try 7 out in the hope that it is somehow faster at loading modules in GHCi.
10:38:29 <jmcarthur> i think i was working on incorrect knowledge about insertion sort
10:38:30 <sproingie> we do something similar here but the arch-specific stuff is done by automount on a different share
10:38:39 <jmcarthur> that's just sad
10:38:50 <benmachine> jaredj: try @. pl undo
10:39:06 <benmachine> @. pl undo do { f <- liftM ([id] !!) next; x <- next; y <- next; return (f x y) }
10:39:06 <lambdabot> (next >>=) . (((next >>=) . (return .)) .) =<< fmap ([id] !!) next
10:39:07 <jaredj> ohh
10:39:10 * benmachine cries
10:39:26 <benmachine> also, ([id] !!) wat
10:39:36 <jmcarthur> this is why we need bind, bind2, bind3, etc.
10:39:46 <jaredj> well, it was (functions !!) but i haven't defined functions yet
10:39:50 <sproingie> Zhuangzi: i never expect ghci to be terribly fast, but shiny new stuff is always good :)
10:39:52 <jmcarthur> oh, that's a liftA*
10:40:05 <benmachine> @. pl undo do { f <- liftM ([id] !!) next; liftM2 f next next }
10:40:05 <lambdabot> flip (flip liftM2 next) next =<< fmap ([id] !!) next
10:40:09 <jmcarthur> in the absense of the return at the end it would have needed a bind*
10:40:46 <benmachine> :t liftM3 id
10:40:47 <lambdabot> forall a2 a3 r (m :: * -> *). (Monad m) => m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
10:40:55 <Zhuangzi> sproingie: Each time I edit my file and want to compile it to type check, it has to load 25 modules which takes 3 seconds.
10:41:18 <jmcarthur> bind3 :: (a -> b -> m c) -> m a -> m b -> m c
10:41:47 <benmachine> jaredj: I think: liftM3 id (liftM ([id] !!) next) next next
10:41:49 <jmcarthur> the signature is actually closer to =<< than it is to >>= though
10:41:50 <Zhuangzi> sproingie: It may not seem like a lot of time but when you're in a hurry it's a life time.
10:41:50 <roconnor> @type msum
10:41:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
10:41:57 <sproingie> Zhuangzi: ouch.  well let me know how ghci7 works out.  flymake tends to drag for me too.
10:42:06 <roconnor> @src mconcat
10:42:06 <lambdabot> Source not found.
10:42:08 <jaredj> benmachine: oi
10:42:24 <benmachine> jaredj: io?
10:42:24 <aavogt> Zhuangzi: it's quicker to load compiled code, if some part of your project doesn't change much
10:42:32 <benmachine> jaredj: unsafely? :O
10:42:35 <Zhuangzi> sproingie: I may fiddle around with GHC or Scion just for the type-checking part. Does flymake actually build and output code every time?
10:42:38 <revenantphx> how does this make haskell feel:
10:42:39 <revenantphx> [outStream write:(uint8_t *)&(int32_t){htonl(0x03)} maxLength:sizeof(uint32_t)];
10:42:41 <sproingie> actually i'm pretty sure i use ghc and not ghci for flymake
10:43:03 <sproingie> Zhuangzi: it builds the file you're editing, but it should use --make.  actually i can't remember how i have it set up
10:43:14 <jaredj> benmachine: i think i'll stick with the liftM then liftM2 :)
10:43:37 <sproingie> all the nifty fixes i made to flymake for haskell were lost in a crash with no backup (
10:43:38 <benmachine> jaredj: suit yourself. you can do it all applicative-style of course
10:43:42 <Zhuangzi> aavogt: Yeah, I've been copying the .o/.hi files to the relative .hs directories of my files when I build with Cabal. That makes the load time fairly instant, except when it doesn't. It seems to crash GHCi and cause a lot of memory usage over time. I think it's somewhat buggy.
10:43:45 <Zhuangzi> xb
10:43:48 <sproingie> (i haz a sad so hard it haz no eyes)
10:43:49 <Zhuangzi> Oops.
10:43:58 <jaredj> now there were some neat things they did with Arbitrary relating to size
10:44:15 <jaredj> so you could make random trees that would certainly not be infinite
10:44:17 <Zhuangzi> sproingie: Did you learn your lesson and start using Github?
10:44:18 <roconnor> @hoogle getProd
10:44:18 <lambdabot> Data.Monoid getProduct :: Product a -> a
10:44:19 <benmachine> in fact I think (functions !!) <$> next <*> next <*> next
10:44:21 <benmachine> might do it
10:44:22 <fryguybob> byorgey: I just tried out the new code and it works!
10:44:29 <Zhuangzi> sproingie: (Or patch-tag, or <insert here>)
10:44:30 <aavogt> well ghci keeps expanding in memory every time you :reload, at least in 6.12
10:44:57 <sproingie> Zhuangzi: i started using git a lot more, didn't think it was so much "packagable" as to push it out to github
10:45:06 <benmachine> hmm
10:45:12 <benmachine> :t liftM3 id
10:45:13 <lambdabot> forall a2 a3 r (m :: * -> *). (Monad m) => m (a2 -> a3 -> r) -> m a2 -> m a3 -> m r
10:45:23 <Zhuangzi> aavogt: That's my experience. It was never an issue in the past on small projects, but on this big one it can grind my laptop to a halt for a few seconds.
10:45:33 <benmachine> :t \f x y -> f <*> x <*> y
10:45:34 <lambdabot> forall (f :: * -> *) a a1 b. (Applicative f) => f (a -> a1 -> b) -> f a -> f a1 -> f b
10:45:47 <benmachine> oh, good, I've not gone barking
10:45:48 <benmachine> that's nice
10:45:53 <sproingie> my favorite use of git is when using java.  i version my eclipse install with it so if and when it inevitably craps itself, i can roll it back instead of reinstalling
10:46:04 <jmcarthur> lol
10:46:13 <Zhuangzi> Eclipse sounds like a powerful system.
10:46:24 <sproingie> it is, but it's quite baroque too
10:46:36 * Zhuangzi considers putting his Cabal packages under Git...
10:47:06 <sproingie> i had high hopes it would be as hackable as emacs but it lacks the incrementalism, internal documentation, and ease of discovery that emacs gives you
10:47:36 <sproingie> there's just no "whipitupitude" to it, you have to put together a plugin project and all that
10:48:01 <Zhuangzi> Exactly the kind of thing you don't feel like doing when you're in the middle of a project and you want a quick hack to make your editing easier.
10:48:09 <sproingie> exactamundo
10:48:18 <kmc> sproingie, you should write a Java plugin project framework factory
10:49:11 <sproingie> i have a 2000-line emacs lisp bulk-regex-matching thingie that just organically grew out of my needs over a couple years
10:49:39 <sproingie> sadly it's for xemacs so it's not too reusable.  someone else wrote most of its functionality in javascript and made it a ff plugin anyway
10:50:34 * sproingie meanders over to -blah with his emacs ramblings
10:50:36 <jaredj> er - wait
10:50:41 <Zhuangzi> kmc: http://xr.com/wtfgetoutofmyhead
10:51:00 <jaredj> having written a function in the Random monad how do i return the random value along with the generator?
10:51:19 <Zhuangzi> A la MonadRandom?
10:51:34 <jaredj> that's probably what i mean
10:51:35 <dcoutts_> Zhuangzi: no need to copy .o .hi files around, just pass the right flags to ghci and it'll use them where they are
10:51:42 <Zhuangzi> I've used that before. Let me look...
10:52:15 <jaredj> ok that's probably what i was missing - i thought Random was the monad
10:53:02 <jaredj> waiwait, no, maybe not
10:53:11 <dskippy> Is there a Haskell function in the prelude or set of ghc distributed libraries that will act like 'all' accept it takes two lists and a function of two arguments? Do I need to use zipWith?
10:53:47 <zygoloid> dskippy: yeah, that sounds like a natural combination of all / and, and zipWith
10:53:49 <c_wraith> dskippy, some combination of all zip and uncurry would do that.
10:53:56 <c_wraith> but zipwith is better
10:54:20 <dskippy> Cool. Thanks. Figure I needed to zipWith.
10:54:25 <zygoloid> @type (fmap.fmap.fmap) and zipWith
10:54:25 <lambdabot> forall a b. (a -> b -> Bool) -> [a] -> [b] -> Bool
10:54:26 <Zhuangzi> jaredj: `Random' refers to the random value. A source of randomness. In the MonadRandom package, `Rand' is the monad: http://hackage.haskell.org/packages/archive/MonadRandom/0.1.5/doc/html/Control-Monad-Random.html
10:55:04 <Zhuangzi> dcoutts_: Sure.
10:55:17 <Nopik> hi all
10:55:19 <Nopik> what 
10:55:30 <Nopik> what environment you're using for haskell programming on mac?
10:55:46 <Zhuangzi> I use Emacs and GHCi on OS X.
10:57:49 <Nopik> yeah, i'll probably go for vim
10:58:00 <alpounet> zygoloid, how does it guess the "Bool" ?
10:58:08 <alpounet> oh
10:58:09 <alpounet> and
10:58:09 <alpounet> ok
10:58:10 <Nopik> so far i've also set up xcode environment, which is not bad, though there is no syntax coloring
10:59:20 <Zhuangzi> Vim's Haskell support is good. It has syntax colouring, completion, stuff like that. I have heard the indentation support sucks, but that may have been incompetence.
10:59:57 <kmc> i use vim, with a very regular indentation style
11:00:03 <kmc> pretty much everything is indented 2 spaces
11:00:12 <FunctorSalad> I second apparent lack of indentation support, with the same disclaimer about incompetence
11:00:13 <Entroacceptor> Zhuangzi: completetion?
11:00:21 <kmc> i never let the length of code on a line determine how the next block is indented
11:00:25 <Zhuangzi> kmc: Oddly, I use Emacs and I use the same style. Indent 2 spaces, always.
11:00:27 <kmc> that's ugly anyway
11:00:33 <Nopik> i have aquamacs installed, though i'm not familiar with emacs too much (and been using vim for last 12+ years already..).. and learning haskell *and* emacs in the same time is too much :)
11:00:48 <FunctorSalad> and ^X^U completion is a bit slow, sadly
11:00:49 <olsner> the "smart" indent for haskell seems completely broken, but simple autoindent works fine
11:00:56 <Zhuangzi> Entroacceptor: Based on TAGS and things like that.
11:01:15 <Nopik> Zhuangzi: yeah, with vim you can configure indentation quite flexibly.. though i had not checked yet how good it is for haskell
11:01:26 <FunctorSalad> (the one that uses your haddock index)
11:01:57 <Entroacceptor> you have to give me a pointer how to set it up
11:02:11 <Zhuangzi> I prefer a simple three-way tab function. Indent 2 spaces in, go to the same column as above, or one back. The tab cycling in Haskell-mode almost never gets what I want the first time.
11:02:19 <FunctorSalad> on the plus side over emacs (last time I checked haskell-mode, anyway), you can quickly add import statements for the current word with _i or _im
11:02:28 <Zhuangzi> Entroacceptor: I don't know Vim but other people in here do.
11:05:58 <Mitar> how can i add a class constraint on data type of type family?
11:07:24 <zygoloid> Mitar: use an associated type and put it in the context of the class, maybe?
11:07:51 <Mitar> yes, for that associated type i would like to make a constraint
11:07:57 <zygoloid> (not sure that works as you'd like, but it's the first thing i'd try)
11:08:00 <Zhuangzi> http://hpaste.org/41381/datahasth (For those interested.)
11:08:02 <jmcarthur> Zhuangzi: i have yet to see a tabbing scheme in an editor that i really like for haskell
11:08:12 <Mitar> class Foo where data Bar a
11:08:32 <FunctorSalad> class Show (Bar a) => Foo a where ....
11:08:42 <FunctorSalad> (iirc)
11:08:44 <Mitar> ooo
11:08:45 <Mitar> true
11:09:00 <zygoloid> Mitar: i'm suggesting: class Ctxt => Foo where data Bar a
11:09:23 <Mitar> yes
11:10:32 <chadz> Prelude Control.Monad.Reader> Control.Monad.Reader.Reader
11:10:34 <chadz> <interactive>:1:0:
11:10:36 <chadz>     Not in scope: data constructor `Control.Monad.Reader.Reader'
11:10:46 <chadz> anyone sure why my system's doing this? can't build xmonad-contrib atm due to this
11:11:36 <danols> hi all what will haskell output if 0 == False is compared ?
11:11:43 <FunctorSalad> chadz: it's mtl 2.0
11:11:44 <jmcarthur> > 0 == False
11:11:44 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
11:11:44 <lambdabot>    arising from the literal `0'...
11:11:47 <jmcarthur> danols: that
11:12:13 <FunctorSalad> chadz: mtl is now transformers, which uses type Reader foo = ReaderT foo Identity
11:12:17 <Mitar> how can I derive Data instances automatically?
11:12:19 <FunctorSalad> so there's no longer a 'Reader' ctor
11:12:30 <proq> > False == False
11:12:31 <lambdabot>   True
11:12:34 <chadz> so xmonad-contrib packages are just broke now until they're updated?
11:12:54 <FunctorSalad> chadz: replacing 'Reader blah' by 'ReaderT (Identity blah)' should do it
11:12:57 <kmc> Mitar, with the GHC extension DeriveDataTypeable
11:13:07 <chadz> FunctorSalad: alright, i'll give it a shot.
11:13:18 <roconnor> did you know you can write "foo, bar, baz :: signature" for haskell type declarations?
11:13:23 <kmc> danols, you can just try it
11:13:25 <FunctorSalad> (and I think you need to import Identity from Data.Functor.Identity or so)
11:13:36 <jmcarthur> chadz: something like this might work for you:   cabal install xmonad-contrib --preference='mtl < 2'
11:13:39 <roconnor> @hoogle Identity
11:13:40 <lambdabot> module Control.Monad.Identity
11:13:40 <lambdabot> Control.Monad.Identity newtype Identity a
11:13:40 <lambdabot> Control.Monad.Identity Identity :: a -> Identity a
11:13:51 <kmc> danols, it's a compile-time type error.  the Haskell spec says that the question "0 == False" makes no sense, you're not allowed to ask it
11:14:04 <Zhuangzi> jmcarthur: Indeed, the Lisps really have it made regarding editing. I don't find Haskell enjoyable to edit.
11:14:06 <zygoloid> instance Num Bool where fromIntegral = fromEnum . fromIntegral; (+) = (||); (*) = (&&) :)
11:14:24 <FunctorSalad> roconnor: yes. and it messes up vim syntax highlighting ;)
11:14:38 <FunctorSalad> (that's too strong. only for that line I mean)
11:14:53 <jmcarthur> Zhuangzi: on the flip side, i very much enjoy haskell's indentation-aware syntax when it comes to *reading* the code later.
11:15:21 <FunctorSalad> (and I don't know a way to add haddocks to such decls)
11:16:52 <Nopik> anyone tried to use eclipse/netbeans or other bigger ide for haskell?
11:17:03 <Nopik> i've heard that there is haskell mode for eclipse.. is it any good?
11:17:21 <roconnor> FunctorSalad: I noticed that too
11:18:21 <ManateeLazyCat> XMonad not like me. :(
11:19:34 <shepheb> can I have yesod routes like /view and /view/#Int? my impression is no.
11:19:38 <Zhuangzi> jmcarthur: Indeed. In general, though, I prefer reading Lisp. The parentheses are always there so you merely come to see the tree, you don't have to interpret operators or consider precedence, ever. It's all lower case and regular. I would genuinely consider using Liskell if it was maintained and approved of by the Haskell community. That will never be the case, however.
11:20:48 <danols> Man I miss Haskell
11:21:04 <FunctorSalad> Zhuangzi: why the last part?
11:21:08 <Zhuangzi> *Real* Haskell code, I generally find hard to read at a glance. It's all over the place. Line noise, operators and upper case all over, but I put up with it for the fantastic semantics, libraries and community.
11:21:09 <chadz> danols: what was he like?
11:21:16 <Zhuangzi> danols: The dog?
11:21:38 <chadz> yeah. i'm not a fan of the operator abuse either
11:21:56 <jmcarthur> Zhuangzi: i kind of like the ability to use infix operators, etc., and i don't find it difficult to read. to each his own i guess
11:22:12 <FunctorSalad> infix operators can save parens
11:22:14 <chadz> <&&^&&^&>
11:22:15 <jmcarthur> but my preference is for there to always be a non-operator version of something even when an operator for it is defined
11:22:18 <chadz> what doz it mean!?
11:22:49 <jmcarthur> i would hate even simple things like function composition without the ability to write it infix, though
11:23:24 <aristid> jmcarthur: using operators in () syntax is ugly, so yeah, a non-operator version is nice to have
11:23:27 <Zhuangzi> jmcarthur: I do like the ability, I use it often myself. I merely mean if I had my ideal Haskell, it would be, syntactically, a Lisp.
11:23:51 <ManateeLazyCat> Saizan: I perhaps skip XMonad now, i can't understand why XMonad not like Manatee.
11:24:00 <Zhuangzi> Well, in Lisp syntax nothing stops you from writing:
11:24:14 <Zhuangzi> (. a b c d)
11:24:20 <ManateeLazyCat> Saizan: Maybe some XMonad expert can help me fix it. 
11:24:41 <ManateeLazyCat> Saizan: Now i give up, sorry. :(
11:24:44 <jmcarthur> Zhuangzi: but what if i meant, in haskell syntax:  (a . b) c d
11:24:57 <jmcarthur> Zhuangzi: i guess that can be made unambiguous
11:24:59 <Zhuangzi> But anyway. My Final Solution is to make it so easy to edit Haskell that I don't mind it so much.
11:25:10 <jmcarthur> if you introduce some rules about it of some sort
11:25:13 <Zhuangzi> jmcarthur: That would be ((. a b) c d), no?
11:25:17 <aristid> jmcarthur: i think that'd be ((. a b) c d)
11:25:25 <aavogt> ManateeLazyCat: we cna discuss in #xmonad?
11:25:31 <aavogt> can
11:25:39 <jmcarthur> what does (. a) b c mean?
11:25:51 <Mitar> how can I get this patch: http://hackage.haskell.org/trac/ghc/ticket/4220 ?
11:25:53 <ray> same thing it means in haskell i guess
11:26:00 <FauxFaux> @pl (. a) b c
11:26:00 <lambdabot> b (a c)
11:26:06 <jmcarthur> i mean in the liskell syntax
11:26:18 <FunctorSalad> (. a) = a presumably
11:26:19 <ray> :t (.) a
11:26:20 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
11:26:20 <lambdabot>     In the first argument of `(.)', namely `a'
11:26:20 <lambdabot>     In the expression: (.) a
11:26:35 <ray> i don't know why i expected Expr a to work there.
11:26:38 <ray> but that's what i mean
11:26:41 <jmcarthur> it just seems kind of ad hoc to me
11:26:43 <Zhuangzi> I don't know how Liskell solves it, but yeah. You could limit it to only be a two-arg function, or make it "special" and when given more than one argument, it asks as many compositions.
11:26:58 <FunctorSalad> assuming (. x1 ... xn) = foldr (.) id [x1, ... , xn]
11:27:09 <FunctorSalad> or a hetero-variant thereof
11:27:30 <jmcarthur> seems about as arbitrary as precedence rules to me
11:27:48 <aristid> also most people prefer non-lisp syntax :P
11:28:05 <FunctorSalad> though you may want to skip the typesystem and expand (. x1 ... xn) to a chain of binary expressions?
11:28:44 <JohnnyL> the parser for ghc is pretty weak.. it can't tell that 0.4 and .4 are the same thing. wtf?
11:29:07 <jmcarthur> > (.4) (+1) undefined
11:29:07 <lambdabot>   5
11:29:09 <FunctorSalad> > (3 . 4) 5
11:29:10 <lambdabot>   3
11:29:15 <FunctorSalad> :D
11:29:38 <jmcarthur> JohnnyL: the reason for that is because you might mean the (.) operator
11:30:02 <kmc> :t (.4)
11:30:02 <lambdabot> forall a b (f :: * -> *). (Num (f a), Functor f) => (a -> b) -> f b
11:30:04 <kmc> :t (.'x')
11:30:05 <lambdabot>     Couldn't match expected type `f a' against inferred type `Char'
11:30:05 <lambdabot>     In the second argument of `(.)', namely 'x'
11:30:05 <lambdabot>     In the expression: (. 'x')
11:30:13 <JohnnyL> (3+2+10+0.4+0.4+.4)*8
11:30:16 <nus> > foldr (.) id [ ?f, ?g, ?h ]
11:30:16 <JohnnyL> > (3+2+10+0.4+0.4+.4)*8
11:30:17 <lambdabot>   mueval-core: internal error: PAP object entered!
11:30:17 <lambdabot>      (GHC version 6.10.4 f...
11:30:17 <lambdabot>   Not in scope: `+.'
11:30:22 <nus> @more
11:30:24 <kmc> whaaaat
11:30:31 <jmcarthur> nice, mueval
11:30:36 <kmc> nus, you did that?
11:30:40 <kmc> > ?f
11:30:41 <lambdabot>   mueval-core: internal error: PAP object entered!
11:30:41 <JohnnyL> it only understand (.4) or 0.4, not .4.
11:30:41 <lambdabot>      (GHC version 6.10.4 f...
11:30:44 <kmc> heh
11:30:52 <kmc> > .4
11:30:53 <lambdabot>   <no location info>: parse error on input `.'
11:31:00 * nus is shocked (well, almost ;-)
11:31:14 <kmc> :t ?f
11:31:15 <lambdabot> forall t. (?f::t) => t
11:31:18 <nus> wtf PAP object?
11:31:18 <jmcarthur> JohnnyL: (.4) doesn't mean 0.4 either
11:31:19 <ragloublog> ManateeLazyCat: Hi it's ragloulob
11:31:21 <FunctorSalad> shouldn't that just give an implicit parameter fail?
11:31:23 <FunctorSalad> nus's
11:31:36 <jmcarthur> JohnnyL: and (+.4) means something else, even
11:31:42 <jmcarthur> JohnnyL: it's not a parse error though
11:31:50 <ManateeLazyCat> ragloublog: Hi.
11:31:52 <FunctorSalad> section of the +. operator
11:32:00 <ManateeLazyCat> ragloublog: So you can't use Manatee in Ubuntu 10.04
11:32:01 <ManateeLazyCat> ?
11:32:08 <jmcarthur> @let a +. b = a + (b `div` 10)
11:32:09 <lambdabot>  Defined.
11:32:10 <jmcarthur> :)
11:32:14 <ragloublog> ManateeLazyCat: it's Kubuntu 10.04
11:32:17 <JoshTriplett> Currently trying to help someone with a crazy Haskell bug.  The net result, according to strace: I have two different Haskell threads (the original and one spawned by System.Cmd.Utils to deal with a pipe) which both attempt to do IO on the same file descriptor at the same time.
11:32:18 <jmcarthur> oh snap that's wrong too
11:32:23 <ManateeLazyCat> ragloublog: Can you use editor, or all modules (editor, browser etc.) can't work?
11:32:24 <jmcarthur> @undef
11:32:38 <JoshTriplett> And so they both read data simultaneously and end up with different chunks of the data.
11:32:43 <JoshTriplett> I have no clue how to start debugging this.
11:32:44 <ragloublog> ManateeLazyCat: no only the irc and news reader
11:32:59 <augur> anyone have any good book references for applications of category theory?
11:33:06 <jmcarthur> @let a +. b = a + (read . ("0."++) . show b)  -- ugly hack
11:33:06 <lambdabot>  <local>:1:32:
11:33:06 <lambdabot>      Couldn't match expected type `[Char]' against inferred ty...
11:33:17 <ragloublog> ManateeLazyCat: I'm not able to open a file with the search input dialog
11:33:30 <JohnnyL> i wonder how many years will be spent cumulatively focused on parsing .4 correctly.
11:33:32 <jolly1> hi i just joined this channel, can anyone tell what my IP was announced ?
11:33:44 <thermoplyae> augur: most textbooks with 'algebra' somewhere in the title
11:33:45 <jmcarthur> umm...
11:33:45 <jmcarthur> not seeing it
11:33:58 <jmcarthur> jolly1: it's parsed correctly already
11:34:03 <jmcarthur> JohnnyL: ^^
11:34:09 <ManateeLazyCat> ragloublog: So you still hang on search input interface?
11:34:12 <jmcarthur> JohnnyL: it's just not what you intend
11:34:16 <ManateeLazyCat> ragloublog: Can't open any tab?
11:34:20 <ragloublog> ManateeLazyCat: M-m and M-/ don't work
11:34:26 <ragloublog> ManateeLazyCat: no tab
11:34:32 <alpounet> > 1 + read ("0." ++ "123")
11:34:33 <lambdabot>   *Exception: Prelude.read: no parse
11:34:47 <jolly1> @jmcarthur just paste since i did not see it
11:34:47 <lambdabot> Unknown command, try @list
11:34:51 <ManateeLazyCat> ragloublog: Do you have those processes "dbus-daemon" "dbus-launch" running in your system?
11:35:05 <ragloublog> ManateeLazyCat: I've not the completion you show in the screenshots
11:35:06 <jolly1> like this ::: hoknamahn [~hoknamahn@91.104.86.196] entered the room.
11:35:12 <ragloublog> ManateeLazyCat: will seee, wait
11:35:16 <Zhuangzi> jmcarthur: I don't know, I think you could come up with a simple semantics that doesn't require knowledge of 9 precedence levels. The solution isn't obvious, but I wouldn't discount the idea either.
11:35:45 <ManateeLazyCat> ragloublog: I'm test Manatee in Gnome.
11:35:52 <FunctorSalad> is there a hackage equivalent to html2text?
11:36:03 <JoshTriplett> > 1.0 + read ("0." ++ "123")
11:36:03 <lambdabot>   1.123
11:36:11 <jolly1> what was my IP announced on this irc
11:36:24 <ragloublog> ManateeLazyCat: bin/dbus-daemon --fork --print-pid 5 --print-address 7 --session
11:36:27 <FunctorSalad> (or elinks -dump)
11:36:30 <jolly1> what was my IP annouced on this channel???
11:36:30 <JoshTriplett> jolly1: http://www.whatismyip.com/
11:36:41 <jolly1> no
11:36:50 <jolly1> i want to know what was it annouced here
11:36:51 <mornfall> jolly1: 75.31.66.53
11:36:52 <ragloublog> ManateeLazyCat: /usr/bin/dbus-launch --exit-with-session x-session-manager
11:37:03 <mornfall> jolly1: You can /whois yourself, I guess.
11:37:07 <mornfall> To find out next time.
11:37:14 <ManateeLazyCat> ragloublog: How to you install manatee?
11:37:26 * JoshTriplett wonders what jolly1 is trying to do.
11:37:35 <ManateeLazyCat> @package manatee
11:37:35 <lambdabot> http://hackage.haskell.org/package/manatee
11:37:55 <kmc> JoshTriplett, well i'd expect two threads reading with no synchronization to be a problem
11:37:57 <ManateeLazyCat> ragloublog: Full step should "cabal install manatee-core manatee-anything manatee-browser manatee-editor manatee-filemanager manatee-imageviewer manatee-ircclient manatee-mplayer manatee-pdfviewer manatee-processmanager manatee-reader manatee"
11:38:15 <kmc> JoshTriplett, why not spawn a third thread to do the IO
11:38:19 <ragloublog> ManateeLazyCat: I've read your install instructions on manatee web page
11:38:25 <ManateeLazyCat> ragloublog: I have Chinese friend have same situation like you, last found he not install those module correctly.
11:38:32 <jmcarthur> jolly1: i did not mean to message you. sorry
11:38:33 <JoshTriplett> kmc: Absolutely.  Except the process in question doesn't intentionally spawn any threads.
11:38:44 <jolly1> what i am trying to do is to see how to use a proxy to hide my ip
11:38:44 <sproingie> oh the huge manatee!
11:38:48 <jmcarthur> Zhuangzi: by no means did i intend to discount it
11:38:50 <ManateeLazyCat> ragloublog: How about "ls ~/.cabal/bin/ | grep manatee" ?
11:38:52 <ragloublog> ManateeLazyCat: perhaps that's the problem
11:39:00 <Zhuangzi> jmcarthur: Sure.
11:39:00 <jolly1> i am a noob
11:39:19 <kmc> JoshTriplett, ah.  so it's done by System.Cmd?
11:39:22 <ragloublog> ManateeLazyCat: manatee
11:39:22 <ragloublog> manatee-anything
11:39:22 <ragloublog> manatee-browser
11:39:22 <ragloublog> manatee-editor
11:39:23 <ragloublog> manatee-filemanager
11:39:25 <JoshTriplett> kmc: Yeah.
11:39:26 <ragloublog> manatee-imageviewer
11:39:28 <ragloublog> manatee-ircclient
11:39:29 <kmc> ragloublog, don't flood
11:39:30 <ragloublog> manatee-irc-daemon
11:39:32 <ragloublog> manatee-mplayer
11:39:34 <ragloublog> manatee-mplayer-daemon
11:39:36 <ChongLi> jolly1: you want tor
11:39:36 <ragloublog> manatee-pdfviewer
11:39:39 <ragloublog> manatee-processmanager
11:39:41 <ragloublog> manatee-reader
11:39:48 <alpounet> kmc, too late i guess
11:39:52 <kmc> JohnnyL, i don't understand this attitude of "i misunderstand the parsing rule, therefore it must be a bug in GHC"
11:39:52 <jolly1> tor works with irc ?
11:40:19 <kmc> JoshTriplett, and why do both threads need to read the same fd?
11:40:32 <ChongLi> jolly1: oh, you didn't say
11:40:35 <JoshTriplett> They don't.  Hence my wondering why they end up doing so inside GHC. :)
11:40:36 <ChongLi> just use an irc proxy
11:40:55 <kmc> i see
11:41:02 <sproingie> jolly1: tor works with tcp in general
11:41:15 <ManateeLazyCat> ragloublog: Can you run manatee in terminal? If you found "newTabInternal : Can't found rule for `PageReader`", it's mean manatee can't found manatee-reader.
11:41:16 <sproingie> jolly1: the irc network just sees you connecting from a tor egress node
11:41:18 <alpounet> ManateeLazyCat, long time no talk
11:41:22 <alpounet> i just saw your projects
11:41:24 <alpounet> good job 
11:41:29 <ManateeLazyCat> alpounet: Thanks.
11:41:39 <sproingie> jolly1: those nodes do tend to be blacklisted due to abuse tho :-/
11:42:20 <jolly1> @sproingie what about a squid proxy
11:42:20 <lambdabot> Unknown command, try @list
11:42:25 <ManateeLazyCat> alpounet: Now just beginning, not perfect, still have many work need to do.
11:42:35 <jolly1> @list
11:42:35 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:43:01 <alpounet> ManateeLazyCat, yet, i have seen the screenshots and that's pretty impressive
11:43:04 <sproingie> jolly1: that's just a standard proxy, usually just for http.  same story, the irc network sees you connecting from the proxy
11:43:29 * hackagebot imbib 1.0.0 - Minimalistic reference manager.  http://hackage.haskell.org/package/imbib-1.0.0 (JeanPhilippeBernardy)
11:43:59 <ragloublog> ManateeLazyCat: no mesage like this one: only "Anyting process (5289) startup."
11:44:15 <ManateeLazyCat> ragloublog: Are you use XMonad ?
11:44:27 <ManateeLazyCat> ragloublog: Manatee can't work in XMOnad now.
11:44:33 <ragloublog> ManateeLazyCat: what is this ?
11:44:57 <ManateeLazyCat> ragloublog: Looks you use KDE.
11:45:14 <ragloublog> ManateeLazyCat: YES !
11:45:33 <ragloublog> ManateeLazyCat: that's the problem ?
11:45:48 <ManateeLazyCat> ragloublog: I don't know, i just test Manatee in Gnome.
11:46:28 <ragloublog> ManateeLazyCat: ok sorry for my ignorance
11:46:49 <ragloublog> ManateeLazyCat: did you think it could run under kde some time ?
11:46:49 <ManateeLazyCat> ragloublog: Are you install Manatee with sudo permission?
11:47:20 <ragloublog> ManateeLazyCat: no only the way you suggest in your web page
11:47:21 <ManateeLazyCat> ragloublog: Infact, i try KDE before, Manatee works well.
11:47:53 <ManateeLazyCat> ragloublog: I think KDE should work, i remember i test Manatee in KDE before.
11:48:04 <ManateeLazyCat> ragloublog: Just not so fast like in Gnome.
11:48:09 <ManateeLazyCat> ragloublog: But works well.
11:48:52 <ManateeLazyCat> ragloublog: So you hang on this interface : http://www.flickr.com/photos/48809572@N02/5154125192/lightbox/ and can't open any tab?
11:49:58 <ragloublog> ManateeLazyCat: not exacltly only the search input dialog on the upper part no browser history, application and process
11:50:16 <ManateeLazyCat> ragloublog: So nothing when you in search interface?
11:50:16 <JoshTriplett> kmc: Some additional digging into the strace showed that the second process got forked to go exec the program getting piped from, but partway through doing so, it did a select on a *different* fd, and then read from that fd.
11:50:22 <ManateeLazyCat> ragloublog: Just blank?
11:50:33 <ManateeLazyCat> ragloublog: BTW, you just can running *one* manatee.
11:50:45 <ManateeLazyCat> ragloublog: If you running two manatee, second can't work.
11:50:47 <ragloublog> ManateeLazyCat: yep blank one
11:51:05 <ManateeLazyCat> ragloublog: Can you kill all manatee-* process and try again?
11:51:15 <ragloublog> ManateeLazyCat: will try
11:51:45 <ManateeLazyCat> ragloublog: I remember Jens try running two manatee, same situation like you, blank search.
11:53:00 <ragloublog> ManateeLazyCat: no a ps -ef |grep manatee gives me only one process
11:53:19 <ManateeLazyCat> ragloublog: If still can't work, i can install kde now for test.
11:53:54 <pygmalion> can anyone see why i'm getting a parse error on line 15? http://pastebin.com/XmrNLfJa
11:54:44 <JoshTriplett> pygmalion: you outdented.
11:55:01 <JoshTriplett> pygmalion: Move sign_parse to start in column 4.
11:55:06 <JoshTriplett> pygmalion: Not column 8.
11:55:33 <ManateeLazyCat> ragloublog: How to install minimum KDE?
11:55:43 <pygmalion> JoshTriplett: duh whoops thanks
11:56:23 <JoshTriplett> pygmalion: Do you use tabs, or did you just try to line up the "sign_parse" with the "sign_parse" in opt_sign_parse??
11:57:28 <ragloublog> ManateeLazyCat: you can try sudo apt-get install kde-minimal
11:57:56 <ManateeLazyCat> ragloublog: I haven't kde-minimal in my system
11:58:19 <ragloublog> ManateeLazyCat: kde-desktop ?
11:58:35 <engla> what is the "default monad" if I do 'sequence []'?
11:59:12 <engla> ah it must be an io monad right that the program is "always" executing inside
11:59:27 <osaunders> :t sequence
11:59:27 <JoshTriplett> engla: Only if you run in the context of IO.
11:59:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
11:59:33 <ManateeLazyCat> ragloublog: I guess is kde-standard
11:59:37 <JoshTriplett> :t sequence []
11:59:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a]
11:59:39 <osaunders> :t sequence []
11:59:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m [a]
11:59:55 <ManateeLazyCat> ragloublog: Perhaps need 18m to install ...
12:00:02 <JoshTriplett> engla: sequence [] will generate an empty list in whatever monad you run it in the context of.
12:00:20 <engla> JoshTriplett: for example in the ghci repl, it's still an IO context(?)
12:00:38 <ragloublog> ManateeLazyCat: sorry try kubuntu-desktop
12:00:41 <JoshTriplett> engla: Yes, in ghci's top-level you run in the IO monad.
12:00:55 <ManateeLazyCat> ragloublog: Oh, that's huge
12:01:08 <ManateeLazyCat> ragloublog: Will install too many software i don't want.
12:01:19 <ragloublog> ManateeLazyCat: yep, sorry that's all the desktop
12:01:24 <engla> I was just surprised that sequence [] completes without error or output on the gchi output (clearly haskell was selecting some monad to use). now I understand
12:01:24 <osaunders> What is a continuation in the context of Haskell or don't you have them?
12:01:36 <ManateeLazyCat> ragloublog: BTW, i think KDE should works well with manatee.
12:01:37 <ragloublog> ManateeLazyCat: don't wich packge is the smallest one
12:01:41 <ManateeLazyCat> ragloublog: Since DBus is from KDE
12:03:20 <ManateeLazyCat> ragloublog: Can you wait me some moment? I switch to XMonad to test, and install kde at the same time.
12:04:00 <ManateeLazyCat> I will back soon.
12:04:06 <ragloublog> ManateeLazyCat: yep, no problem but you don't have to do that for me  !
12:04:21 <JohnnyL> > 1.0 + read(".4" ++ "123")
12:04:22 <lambdabot>   *Exception: Prelude.read: no parse
12:05:04 <osaunders> > 1.0 + read("0.4" ++ "123")
12:05:05 <lambdabot>   1.4123
12:05:19 <JohnnyL> Your name is Toby! ... 'No Kunta Kente!'... No your name is Toby! Ad infintum.
12:05:24 <McManiaC> http://npaste.de/pe/ :)
12:05:32 <McManiaC> monad comprehensions \o/
12:06:05 <JoshTriplett> Cute.
12:06:40 <JoshTriplett> McManiaC: Effectively it just runs the computations on the RHS of the |, then does "return" on the expression on the left?:
12:06:46 <Zhuangzi> > cycle "Your name is Toby! "
12:06:47 <lambdabot>   "Your name is Toby! Your name is Toby! Your name is Toby! Your name is Toby...
12:07:03 <McManiaC> JoshTriplett: jup, kind of
12:07:34 <solistic> hmm, I have a minimal program that uses ncurses getch with timeout to wait 3 seconds for input, without -threaded it works just fine, but with `-threaded' getch returns immediately
12:07:52 <McManiaC> JoshTriplett: it's a generalisation for list comprehensions - since lists are monads aswell
12:08:11 <solistic> the paste is here: http://hpaste.org/41382/behaves_odd_with_threaded
12:08:28 <solistic> does somebody has an idea how I could invetigate this?
12:09:03 <Adamant> um wat
12:09:27 <solistic> Adamant: was that to me?
12:09:30 <kmc> > printf "foo" >>= print
12:09:31 <lambdabot>   <IO ()>
12:09:35 <Adamant> solistic: no
12:09:46 <solistic> Adamant: ok
12:09:48 <Adamant> more the use of quotes from 'Roots' on #haskell
12:11:23 <JoshTriplett> kmc: Funny. :)
12:11:36 <JoshTriplett> > print (putStr "")
12:11:37 <lambdabot>   <IO ()>
12:11:46 <JoshTriplett> @instances Show
12:11:47 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
12:12:01 <JoshTriplett> :t show . print
12:12:02 <lambdabot> forall a. (Show a) => a -> String
12:12:03 <kmc> « printf "foo" >>= print » is a runtime exception
12:12:05 <osaunders> solistic: Why don't you use the Haskell primitives for those things?
12:12:05 <kmc> try it in ghci
12:12:17 <Jiten> I have a bit of code that several different functions will all need to perform identically that I'd really like to separate into a different function but I just can figure out how. Could you help me with it? here's the code as it is and how I'd like to change it to be http://hpaste.org/41383/abstracting_functionality
12:12:18 <JoshTriplett> kmc: I think lambdabot has some magic instances.
12:12:25 <kmc> see last par in §2.4.5 of GHC manual
12:12:34 <solistic> osaunders: What exactly do you mean?
12:12:35 <kmc> JoshTriplett, it does, but that's not what i was getting at; I failed to demonstrate what I set out to
12:12:39 <kmc> anyway, bbl
12:13:03 <osaunders> solistic: Use HSCurses
12:13:04 <dmead> @hoogle outputable
12:13:04 <lambdabot> No results found
12:13:08 <dmead> @hoogle outputablebndr
12:13:08 <lambdabot> No results found
12:13:30 <osaunders> solistic: And getChar
12:13:54 <solistic> osaunders: Ah, I only tried getch from hscurses
12:14:18 <solistic> osaunders: I missed that
12:14:34 <osaunders> solistic: and Control.Concurrent.threadDelay (the only delay function I could find in the entire of Haskell but works for non-threaded stuff too).
12:14:51 <osaunders> s/non-/single/
12:14:59 <ManateeLazyCat> Damn, XMonad failed gain.
12:15:52 <ragloublog> ManateeLazyCat: it also doesn't work for you 
12:16:02 <ManateeLazyCat> ragloublog: Just XMonad can't work.
12:16:09 <ManateeLazyCat> KDE still in test.
12:16:19 <ManateeLazyCat> ragloublog: XMonad is WM written by Haskell.
12:16:51 <ManateeLazyCat> @package manatee
12:16:51 <ragloublog> ManateeLazyCat: ha ok ... thanks
12:16:52 <lambdabot> http://hackage.haskell.org/package/manatee
12:17:00 <sm> you'd think the haskell WM would run the haskell gui app
12:17:33 <ManateeLazyCat> sm: Infact, Manatee even don't need WM
12:17:49 <ManateeLazyCat> sm: Manatee is WM itself.
12:18:14 <solistic> osaunders: osaunders did you mean that getChar works with timeouts (from what I can tell so far, it does not)?
12:18:24 <ManateeLazyCat> ragloublog: KDE still in install....
12:18:49 <ragloublog> ManateeLazyCat: indeed that's huge :)
12:18:51 <solistic> osaunders: It does not return immediatley but it blocks infinitely
12:18:52 <shapeless> Jiten: Imho there are only some missing $
12:18:55 <ManateeLazyCat> ragloublog: Yes,
12:19:02 <ManateeLazyCat> ragloublog: Too many package need install.
12:19:22 <osaunders> solistic: Yes it does.
12:19:24 <ManateeLazyCat> ragloublog: perhaps install package need some tiem.
12:19:31 <osaunders> solistic: What behavior did you want?
12:19:51 <solistic> osaunders: a timeout of 3 seconds
12:20:07 <solistic> osaunders: maybe I missed something
12:20:29 <osaunders> solistic: Define timeout in this instance. You only want it to block for 3 seconds?
12:20:46 <Mitar> how can I get this patch/change out of the repository to try to portback it?
12:20:51 <Mitar> http://hackage.haskell.org/trac/ghc/ticket/4302
12:21:15 <solistic> osaunders: ah, I see getChar is from the prelude, so it will probably not respect the timeout passed to ncourse, rigt?
12:21:29 <shapeless> Jiten: look at your paste
12:21:54 <solistic> osaunders: and yes, I only want it to block for a specified time
12:22:27 <Mitar> ok, managed: darcs diff --patch "Fix Trac #4302, plus a little refactoring"
12:22:28 <osaunders> solistic: OK, what exactly are you doing or wanting to do with threads?
12:23:04 <osaunders> solistic: And yeah, getChar won't give a poop about some random function you just imported via FFI.
12:23:44 <osaunders> (not that I know anything about FFI but the world would have to be broken for me to be wrong about that).
12:24:16 <solistic> osaunders: basically I just want to be able to update the screen while waiting for user input
12:24:19 <Jiten> shapeless: the withState function needs to apply the first argument the function it's passed takes and then return a function that still takes the other parameters the passed function would take.
12:24:42 <solistic> osaunders: I did this with ncurses, wating for input in an other thread and communicating through a chan
12:24:45 <osaunders> solistic: Right. You don't need threads for that. And I can tell you exactly how to do that.
12:24:59 <solistic> osaunders: ok, I listen:)
12:25:00 <Jiten> like that it won't work because the first arguments to prepareWork and handleResult needs to be ServerState
12:25:04 <osaunders> Hang on. I've already done this in a game I've written.
12:25:17 * osaunders writes code
12:25:41 * solistic is curious
12:25:50 <sm> new code! awesome. That's sure to work :)
12:26:11 <sm> j/k. Also interested.
12:26:17 <aristid> sm: after the types check, it will surely work
12:26:32 <Jiten> shapeless: although, I think it would work if I move the ServerState argument be the last one it takes...
12:26:39 <Jiten> yes, I think that would solve it. Thank you :)
12:26:39 <sm> aristid: surely!
12:26:59 * solistic .oO(Oh, maybe I still need threads, as I wait for input on a socket too)
12:27:57 <shapeless> Is there something on Hackage to output video-files?
12:28:27 <ManateeLazyCat> Saizan: I try many times XMonad, i can't fix it now, sorry.
12:28:33 <solistic> shapeless: maybe the xine bindings?
12:28:40 <solistic> shapeless: http://hackage.haskell.org/package/xine
12:28:42 <ManateeLazyCat> Saizan: I will pick it again if i have more time on XMOnad.
12:29:00 <ManateeLazyCat> solistic: xine binding is for music play
12:30:13 <Entroacceptor> launch an mplayer process
12:30:14 <Jiten> shapeless: although, I'm still curious if it would be possible without moving the state argument to be the last argument :)
12:30:39 <shapeless> solistic: It don't seems to output program-generated video
12:31:09 <Entroacceptor> shapeless: I bet it can output streams or pipes
12:31:27 <shapeless> Jiten: It is possible, you just have to write flip often enough ;)
12:31:33 <Entroacceptor> ManateeLazyCat: it looks like it can output video, too
12:31:40 <ManateeLazyCat> Entroacceptor: Maybe Gstreamer bidning can work.
12:31:56 <nha_> are there any usable libraries for zippers with multiple cursors?
12:32:03 <ManateeLazyCat> Entroacceptor: But i haven't try.
12:32:07 <solistic> ManateeLazyCat: I thought xine supports FFmpeg?
12:32:15 <monochrom> Hrm! You are supposed to go to sleep, ManateeLazyCat!
12:32:21 <ManateeLazyCat> solistic: I'm mplayer fans
12:32:26 <ManateeLazyCat> monochrom: Too many work.
12:32:35 <Entroacceptor> there's even an example on how to play a video on the xine binding page :)
12:32:39 <monochrom> haha ok, have fun, enjoy the dark night
12:32:40 <ManateeLazyCat> monochrom: I perhaps won't sleep tonight. :)
12:32:48 <cheater99> hi
12:32:51 <cheater99> how can i do this? filter (<6) && (>2) [1..7]
12:32:53 <ManateeLazyCat> monochrom:  04:32 am in China.
12:32:59 <monochrom> night is for coding, day is for dreaming
12:33:02 <cheater99> of course this gives a syntax error
12:33:04 <Zao> cheater99: More parens and a lambda.
12:33:07 <arcatan> and there are also ffmpeg bindings
12:33:10 <ManateeLazyCat> monochrom: night day for coding
12:33:12 <Zao> Or some silly combinator like &&& or something.
12:33:36 <cheater99> how do i use lambda in haskell?
12:33:39 * monochrom has another one: bed is for reading, desk (or school class) is for sleeping
12:33:56 <cheater99> i tried \x: (x>2) && (x<6)  but it didn't do.
12:34:00 <ManateeLazyCat> monochrom: Some old friend crazy me, i receive 70 mails today. :(
12:34:02 <Zao> > map (\x -> x * x) [42, 3, 5]
12:34:02 <lambdabot>   [1764,9,25]
12:34:16 <cheater99> ah, i need to use -> and not :.
12:34:28 <Zao> > filter (\x -> odd x || even x) [1..10]
12:34:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
12:34:43 * ManateeLazyCat How many crap install in KDE?
12:34:52 <tg_> ManateeLazyCat: nice work with manatee.
12:34:57 <cheater99> what is &&&?
12:35:00 <tg_> and thanks for choosing GPL ;)
12:35:02 <ManateeLazyCat> tg_: Thanks.
12:35:10 <Zao> tg_: Eew.
12:35:14 <ManateeLazyCat> tg_: Yep, GPL3
12:35:30 <kmc> ugh
12:35:31 <Zao> I don't want to start the usual wars, but MIT/BSD/anythingsane :D
12:35:34 <tg_> tg_: some don't like it, but it will help your project
12:35:36 <ManateeLazyCat> tg_: Can you use manatee correctly?
12:35:38 <kmc> let's start a huge flamewar right now!
12:35:41 <kmc> just as i'm headed out the door!
12:36:02 <tg_> ManateeLazyCat: not yet; i just had some similar goals in mind, and you seem to have made better decisions than I was thinking
12:36:05 <osaunders> solistic: OK, done.
12:36:13 <osaunders> solistic: http://hpaste.org/paste/41382/reading_with_continuous_progra#p41386
12:36:25 <ManateeLazyCat> ragloublog: Most my friends have use Manatee well.
12:36:28 <Entroacceptor> Zao: that's only sane in the 'in'-way
12:36:29 * solistic is sudying
12:36:36 <ManateeLazyCat> ragloublog: Anyway, i will help you test it with KDE.
12:36:47 * solistic is, oh well, studying
12:36:54 <ManateeLazyCat> Bye all, switch KDE to test manatee, back soon.
12:38:07 <monochrom> curiosity killed the cat. the cat killed the conversation
12:38:28 <tg_> and hitler killed everything
12:38:41 <sproingie> including hitler
12:38:46 <tg_> true story
12:38:53 <monochrom> haha
12:39:26 <manateeUser> Say hello from Manatee-IrcClient (KDE WM)
12:39:34 <solistic> osaunders: nice
12:39:35 <osaunders> Hitler didn't kill me.
12:39:39 <tg_> hello from ...
12:39:45 <tg_> osaunders: he tried, he tried...
12:39:50 <solistic> osaunders: but it restricts input to 10 characters per second, right?
12:40:02 <sproingie> ManateeLazyCat: yay, haskell irc client?
12:40:11 <tg_> sproingie: among many other things
12:40:18 <ManateeLazyCat> sproingie: Yes.
12:40:31 <ManateeLazyCat> ragloublog: I have test Manatee all modules in KDE, works fine.
12:40:42 <sproingie> oh wow manatee looks freakin amazing
12:41:04 <ragloublog> ManateeLazyCat: damned that's my installation
12:41:21 <ragloublog> ManateeLazyCat: how to test my installation ?
12:41:28 <osaunders> solistic: Huh? It only reads a character once per second.
12:41:43 <ragloublog> ManateeLazyCat: perhaps I miss somthing from gnome desktop ?
12:42:04 <ragloublog> ManateeLazyCat: I only have kde with kubuntu
12:42:07 <ManateeLazyCat> ragloublog: I just install kde-standard, and do nothing, startup emacs, test all modules, works well.
12:42:51 <solistic> osaunders: yep, you are right
12:43:07 <tg_> ManateeLazyCat: surely you won't be offended if someone tries to make a vim version of manatee?
12:43:12 <ManateeLazyCat> sproingie: Manatee project is just beginning, in future will add mail-client, twitter-client, BT-client, Jabbar-client .... etc.
12:43:49 <ManateeLazyCat> tg_: I will add customize system later, so free free hacking i.t
12:44:12 <ManateeLazyCat> tg_: BTW, i will add terminal in Manatee, then you can running vi or emacs in it. :)
12:44:21 <tg_> hehe.
12:44:28 <sproingie> ManateeLazyCat: i'm more psyched about the whole platform aspect of it than any one app
12:44:30 <tg_> I am just speaking of the keybindings and modality elements of vi
12:44:36 <ragloublog> ManateeLazyCat: good point on the terminal !
12:45:07 <ragloublog> tg_: good one also on vim like mode editing 
12:45:15 <ManateeLazyCat> tg_: Wait, i give your screenshot of first version of Manatee.
12:45:23 <tg_> ManateeLazyCat: I saw it from reddit
12:45:27 <tg_> unless you have something different
12:46:06 <ManateeLazyCat> tg_: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
12:46:13 <ManateeLazyCat> tg_: Yes, different.
12:46:38 <tg_> indeed it is
12:46:40 <ragloublog> ManateeLazyCat: this is a good one !
12:46:40 <tg_> ok i'll look at it later
12:46:43 <tg_> going to the gym now
12:46:51 <ragloublog> ManateeLazyCat: world domination :)
12:46:54 <ManateeLazyCat> tg_: Last i remove temrinal 
12:47:11 <ManateeLazyCat> tg_: That screenshot use VTE library
12:47:14 <ManateeLazyCat> @package vte
12:47:14 <lambdabot> http://hackage.haskell.org/package/vte
12:47:26 <ManateeLazyCat> tg_: But VTE is not MVC design, i plan to write new one.
12:48:29 <ManateeLazyCat> ragloublog: Do you binding M-m in KDE?
12:48:43 <osaunders> PUMPING IRON!!!! RAWRRRRRRR
12:48:50 * osaunders doesn't go to the jim
12:49:01 <ragloublog> ManateeLazyCat: no: I'm using emacs also
12:49:11 <ManateeLazyCat> ragloublog: Wehn you startup manatee, do you found "manatee-anything" process running?
12:49:22 * osaunders is weak and feeble and more recently off-topic too
12:49:32 <ManateeLazyCat> ragloublog: "manatee-anything" is for input search.
12:49:35 <ragloublog> ManateeLazyCat: will look, wait a second
12:50:41 <ManateeLazyCat> ragloublog: I can help you debug it if i develop RPC module in Manatee. :)
12:50:41 <ragloublog> ManateeLazyCat: no the only manatee process is manatee
12:51:08 <ragloublog> ManateeLazyCat: :)
12:51:14 <ManateeLazyCat> ragloublog: manatee-anything is at ~/.cabal/bin ?
12:51:38 <ragloublog> ManateeLazyCat: yes
12:52:45 <ManateeLazyCat> ragloublog: Can you paste result out from Manatee?
12:53:09 <ManateeLazyCat> ragloublog: It's paste result maybe be help.
12:53:23 <ragloublog> ManateeLazyCat: what do you mean ?
12:53:33 <ManateeLazyCat> ragloublog: Run manatee in terminal
12:53:46 <ragloublog> ManateeLazyCat: the standard output from the command line ?
12:53:47 <ManateeLazyCat> ragloublog: Then Manatee will print some debug information...
12:53:51 <ManateeLazyCat> ragloublog: Yes.
12:54:14 <ragloublog> ManateeLazyCat: I've only have Anyting process (7007) startup.
12:54:17 <ManateeLazyCat> ragloublog: BTW, can you input character in manatee, just blank search.
12:54:43 <ManateeLazyCat> ragloublog: Now process manatee-anything is running?
12:54:48 <ragloublog> ManateeLazyCat: I can input some characters but M-m is not working
12:55:26 <ManateeLazyCat> ragloublog: process manatee-anything is running when you input characters? 
12:55:31 <ragloublog> ManateeLazyCat: no manatee-anything process
12:56:05 <ManateeLazyCat> ragloublog: Looks mantee-anything crash when you input something.
12:56:46 <ragloublog> ManateeLazyCat: perhaps beacuse I see something wich disapeed very quicly 
12:57:02 <ragloublog> ManateeLazyCat: don't no if it's the anything completion
12:57:03 <ManateeLazyCat> ragloublog: Next step is bit complicated, do you want try?
12:57:19 <ragloublog> ManateeLazyCat: let's go
12:57:45 <ManateeLazyCat> ragloublog: Decompress package manatee-anything.tar.gz
12:57:59 <ManateeLazyCat> ragloublog: It have Main.hs file, open it.
12:58:22 <ragloublog> ManateeLazyCat: where can I find this package archive ?
12:58:25 <ManateeLazyCat> ragloublog: Then you will see GlobalSearch ["Irc", "Locate", "Buffer"....]
12:58:29 <ManateeLazyCat> @package manatee-anything
12:58:29 <lambdabot> http://hackage.haskell.org/package/manatee-anything
13:00:09 <ManateeLazyCat> ragloublog: You need comment some string in (GlobalSearch, ["Irc" ,"Locate" ,"Buffer" ,"BrowseHistory" ,"BufferHistory" ,"Browser" ,"GoogleSuggest" ,"Application" ,"ExecuteFile" ,"Process"])
13:00:15 <ragloublog> ManateeLazyCat: I'm in, lets modify this file
13:00:21 <shapeless> Entroacceptor: Generated by my program?
13:00:36 <ManateeLazyCat> ragloublog: Example, you can just have ["Locate"]
13:00:50 <Zao> Fun fact of the day - it's possible to create IRC channels of your own :D
13:00:53 <ManateeLazyCat> ragloublog: Then do "cabal install" install manatee-anything again.
13:01:03 <ManateeLazyCat> Zao: ##manatee
13:01:20 <Zao> ManateeLazyCat: Well, I don't care about your project. I care about reading Haskell conversations :)
13:01:45 <ManateeLazyCat> ragloublog: Then manatee-anything just search file.
13:01:57 <ManateeLazyCat> Zao: Manatee is haskell.
13:02:09 <Zao> So's my tetris.
13:02:27 * solistic likes tetris
13:02:35 <solistic> Zao: so tell me more about your tetris
13:02:43 <Zao> ManateeLazyCat: My poorly hidden point is, it's hard to see topical discussions about the Haskell language here.
13:02:56 <ManateeLazyCat> Zao: Ok,
13:03:02 <ManateeLazyCat> ragloublog: Can we talk in ##manatee?
13:03:50 <ManateeLazyCat> ragloublog: /join ##manatee
13:04:45 <ManateeLazyCat> Cale: Can you bring lambda bot to ##manatee ? Thanks
13:07:25 <dmead> @hoogle MatchGroup
13:07:25 <lambdabot> No results found
13:07:28 <dmead> @hoogle MatchGrp
13:07:28 <lambdabot> No results found
13:08:16 <mjuad> i believe the bot responds to PM
13:08:53 <mjuad> indeed it does
13:09:48 <dmead> then how will my search queries be publicly ridiculed?
13:10:15 <osaunders> Is someone writing tetris?
13:11:36 <Zao> osaunders: I was, years ago.
13:11:54 <Zao> Never bothered finishing it, http://www.acc.umu.se/~zao/Hastris/
13:17:05 <ManateeLazyCat> manateeUser: ragloublog is you?
13:17:39 <sm> there's another tetris on hackage and another on my hard drive
13:17:46 <shepheb> anyone got a link to a quick-and-dirty tutorial on using an enumerator?
13:17:56 <sm> (by syntaxglitch)
13:18:00 <osaunders> Zao: Released the source anywhere?
13:18:17 <Zao> osaunders: That URL might be a darcs repository as well.
13:18:35 <Zao> osaunders: Not that it's remotely beautiful, nor probably won't build with anything newer than 6.6
13:19:19 <osaunders> OK
13:19:27 <osaunders> Is that OGL graphics?
13:19:42 <shepheb> the way it's used there makes it sound like an adjective. Australia has "bonzer"
13:19:46 <shepheb> mischan
13:19:58 <osaunders> Oh actually it probably isn't any use to me because I'm using GPipe and I don't think that has been around long.
13:19:59 <Zao> osaunders: Yup. Not much choice wrt. 3D in Haskell, sadly.
13:20:17 <Zao> osaunders: Mostly because Direct3D is a right bother to import.
13:20:23 * sm is so glad to see discussion of a hot new app instead of CS/type theory prattle for once
13:20:34 <osaunders> I don't care about D3D.
13:20:46 <ManateeLazyCat> I guess ragloublog has play Manatee.
13:21:04 <osaunders> I just recently finished writing Snake using HSCurses and I want to use OGL now.
13:21:27 <osaunders> GPipe is this functional abstraction of OGL which I'm just trying to get my head round. Should be fun though.
13:21:42 <jaredj> @. pl undo do { fa <- next; fb <- next; return (fb . fa) }
13:21:42 <lambdabot> (`fmap` next) . flip (.) =<< next
13:21:54 <jaredj> @undo do { fa <- next; fb <- next; return (fb . fa) }
13:21:54 <lambdabot> next >>= \ fa -> next >>= \ fb -> return (fb . fa)
13:22:15 <jaredj> @. pl undo do { fa <- next; fb <- next; return (fa . fb) }
13:22:15 <lambdabot> (`fmap` next) . (.) =<< next
13:22:51 <lispy1> osaunders: Will you (or have you?) written a tutorial for others about what you learned?
13:23:02 <lispy1> osaunders: maybe on a blog or the haskell wiki?
13:23:14 <osaunders> Better
13:23:22 <osaunders> I did a talk, it was videoed.
13:23:33 <lispy1> osaunders: awesome, is it on the 'net yet?
13:24:18 <osaunders> Sort of better. I might do a write up too. But it isn't really finished.
13:24:18 <osaunders> No, will probably be weeks. Someone else is doing all the video stuff for me and he's got another 4 to do as well.
13:24:35 <lispy1> cool
13:24:57 <lispy1> osaunders: I'm happy to hear that you're documenting the process.  It's a huge help to those who will come after you :)
13:25:33 <jaredj> oh noes!
13:25:54 <jaredj> i can't declare an instance Random (Quilt -> Quilt). how weird is -XFlexibleInstances
13:25:57 <jaredj> ?
13:26:29 <lispy1> jaredj: flexible instances is more or less tame
13:26:41 <lispy1> jaredj: but, that's a weird looking instace
13:26:45 <osaunders> Can you generate random functions at all?
13:26:48 <lispy1> jaredj: you want to randomly generate functions?
13:27:03 <sipa1024> jaredj: in haskell98 you can only declare instances on types defined by ADTs
13:27:13 <lispy1> osaunders: yes, because functions are first class.  You can return a function from a function
13:27:24 <quintessence> jaredj: you can newtype it if you don't want to have to use extensions
13:27:31 <osaunders> Yeah but functions aren't even equatable
13:28:05 <lispy1> osaunders: you can declare point-wise equality for functions
13:28:15 <osaunders> lispy1: I don't know what kind of language Haskell would be if functions weren't first-class, sheeh.
13:28:36 <osaunders> point-wise?
13:28:44 <osaunders> arity-wise?
13:28:58 <lispy1> osaunders: yes, you compare the functions at each value in the domain
13:29:47 <Zhuangzi> What's that ghc option to provide a program that does some rewriting on the source before GHC touches it? I know Cabal does this, but I thought I had read that GHC can do it too.
13:29:56 <osaunders> lispy1: Can you give an example?
13:30:07 <lispy1> something like, f `pointWiseEquality` g = foldr (==) (\x -> f x == g x) {- some way to enumerate the domain -}
13:30:08 <c_wraith> Zhuangzi, you mean the CPP extension?
13:30:17 <dcoutts_> Zhuangzi: -F I think, see the ghc user guide
13:30:25 <quintessence> instance Eq a => Eq (Bool -> a) where f == g = (f True == g True) && (f False == g False)
13:30:35 <Zhuangzi> c_wraith: No, not CPP. A custom program that rewrites the source.
13:30:56 <Zhuangzi> I read the man page but it wasn't there. The manual was my next bet after asking in here.
13:31:04 <sproingie> there's one for giving it an arbitrary preprocessor.  cant remember what that is either
13:31:33 <c_wraith> well, dcoutts_ did answer the question, too. :)
13:32:02 <Zhuangzi> -F is the CPP
13:32:06 <osaunders> lispy1: You could have to run that on every possible value of x though.
13:32:31 <dcoutts_> Zhuangzi: see the ghc user guide about -F flag
13:32:48 <osaunders> lispy1: For instance (+2) and abs are equal for -1 but not otherwise.
13:34:25 <osaunders> As quintessence demonstrates it is completely feasible for booleans. 
13:34:56 <Zhuangzi> dcoutts_: Ahh, I misread "-F Enable the use of a pre-processor (set with -pgmF)" as "the pre-processor". I just read the manual; it's pretty cool that it works in interpreted mode. :-)
13:34:56 <sipa1024> instance (Eq a, Enum b, Bounded b) => Eq (b -> a) where f == g = and (\x -> f x == f y) [minBound..maxBound]
13:35:20 <sipa1024> ow, f x == g x
13:36:08 <lispy1> osaunders: Enumeration is a separate problem :)
13:36:33 <sipa1024> @pl \x -> f x == g x
13:36:33 <lambdabot> liftM2 (==) f g
13:36:38 <osaunders> Whatever
13:36:40 <lispy1> osaunders: and Haskell programs don't have to terminate to be valid :)
13:37:04 <lispy1> But yes, it's a much easier problem when the domains are finite
13:38:12 <osaunders> I'm not interested in writing code that is merely valid.
13:39:07 <ManateeLazyCat> ragloublog: Can you tell people how do you feeling mantee?
13:41:56 * Zhuangzi feels ManateeLazyCat
13:42:01 <Zhuangzi> You're all furry!
13:42:07 <ragloublog> Guys Manatee is realy awesome
13:42:18 <ragloublog> it's an emacs killer realy
13:42:38 <osaunders> Anyway, here's the source of Snake for whoever is interested: https://github.com/olliesaunders/Snake
13:42:39 <lispy1> ManateeLazyCat: is ragloublog a bot?
13:42:51 <ManateeLazyCat> lispy1: No.
13:43:01 <ragloublog> this project is so exciting
13:43:08 <ManateeLazyCat> lispy1: ragloublog is my friend. :)
13:43:19 <lispy1> osaunders: cool
13:43:24 <lispy1> ManateeLazyCat: ah
13:43:41 <ragloublog> emacs like productivity with better ui and power
13:43:47 <ragloublog> let's try it !
13:44:05 <ragloublog> you will be hooked !
13:44:14 <acemo> is there any default function to switch 2 elements in a list?
13:44:29 <Zhuangzi> Not that I know of.
13:44:50 <Zhuangzi> It's really a problem of how to insert into a list.
13:44:57 <Zhuangzi> Which I *think* does have a function somewhere.
13:45:06 <osaunders> Ah crap, just realized I use a command that other people don't have
13:45:48 <lispy1> Manatee, taking over the linux desktop one app at a time!
13:46:56 <Zhuangzi> acemo: FWIW, might be one knocking about here: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:swap
13:47:45 <solistic> osaunders: what are the key bindings?
13:47:58 <osaunders> wsad
13:48:04 <osaunders> Says in the readme.
13:48:30 <solistic> osaunders: on dvorka that will be give extra scores..
13:49:00 <acemo> Zhuangzi: think i'll just make a few simple list comprehensions.. gimme a min
13:50:29 <sm> osaunders: graphics-drawingcombinators hides opengl nicely
13:50:38 <foo-nix> I notices the pan package isn' t maintained anymore, but couldn' t find any info on recent info of Pancito, would anyone know if it is still maintained?
13:50:57 <ManateeLazyCat> ragloublog: Take me to say hello to your baby, congratulation! :)
13:51:13 <osaunders> sm: Better than GPipe?
13:51:17 * ManateeLazyCat Back to Gnome, 
13:51:31 <sm> I don't know, I'll have to look at that. Simple, though
13:51:41 <ManateeLazyCat> Glad Manatee can work on Gnome and KDE.
13:52:05 <osaunders> sm: GPipe uses Data.Vec which I don't like.
13:52:38 <ManateeLazyCat> Bye all, night! :)
13:53:55 <Zhuangzi> > let replace a (n+1) (x:xs) = x : replace a n xs; replace a 0 (_:xs) = a : xs; replace _ _ [] = []
13:53:56 <lambdabot>   not an expression: `let replace a (n+1) (x:xs) = x : replace a n xs; replac...
13:53:57 <sm> osaunders: hscurses Snake is great :) But rude.
13:54:12 <Zhuangzi> > let replace a (n+1) (x:xs) = x : replace a n xs; replace a 0 (_:xs) = a : xs; replace _ _ [] = [] in replace 'a' 1 "hello"
13:54:13 <lambdabot>   "hallo"
13:54:35 <osaunders> sm: But rude?
13:54:36 <lispy1> > text "hallo"
13:54:36 <lambdabot>   hallo
13:54:42 <sm> when you lose
13:54:53 <osaunders> Yes!
13:54:53 <Zhuangzi> :t replace
13:54:54 <lambdabot> forall a t. (Integral t) => a -> t -> [a] -> [a]
13:55:11 <osaunders> :t text
13:55:12 <lambdabot> String -> Doc
13:55:29 * sm also has a nice graphical snake that came with fungen
13:56:17 <Nikla> hey it might be simple thing but how can i check the lambda-expressions i haskell say expression like this (\f.\g.\x.\y.f x (g x y))
13:56:29 <Zhuangzi> > let swap n n' xs = replace (xs!!n') n $ replace (xs!!n) n' xs in swap 1 4 "hello"
13:56:30 <lambdabot>   "holle"
13:57:01 <lispy1> > let swap n n' xs = replace (xs!!n') n $ replace (xs!!n) n' xs in swap 1 100 "hello"
13:57:02 <Zhuangzi> That's the first time I've ever used an n+k pattern.
13:57:02 <lambdabot>   "h*Exception: Prelude.(!!): index too large
13:57:09 <sipa1024> Nikla: \f g x y -> f x (g x y)
13:57:20 <sipa1024> @pl \f g x y -> f x (g x y)
13:57:21 <lambdabot> liftM2 (.)
13:57:26 <sipa1024> or like that :)
13:57:26 <djahandarie> osaunders, what's wrong with Data.Vec?
13:57:31 <osaunders> sm: It is also sadistic, when you get down to apple 1.
13:57:33 <Zhuangzi> lispy1: You exposed the fatal flaw! I didn't think of that! :-O
13:57:39 <djahandarie> Besides how it isn't using type families yet ;)
13:57:51 <osaunders> djahandarie: The syntax is horrible
13:58:06 <osaunders> And you get weird errors from it sometimes.
13:58:22 <Nikla> @sipa1024 (\f.\g.\x.\y.f x (g x y)) thsi is OR and if i want to pass say true and false then i just type true and false lambda expression after that 
13:58:22 <lambdabot> Unknown command, try @list
13:58:25 <djahandarie> Is there a better fixed-length list solution out there somewhere?
13:59:37 <Nikla> @sipal1042 and i got some error like No instance for (Show ((t -> t1 -> t2) -> (t -> t3 -> t1) -> t -> t3 -> t2))
13:59:37 <lambdabot> Unknown command, try @list
14:00:22 <osaunders> djahandarie: I tried to write one: https://github.com/olliesaunders/TVec but concluded that these things were pretty annoying and hint at a known limitation of Haskell.
14:00:29 <sm> osaunders: what's refresh in your tick function ?
14:00:57 <osaunders> sm: Makes HSCurse draw.
14:01:03 <sm> aha
14:01:43 <sm> ah there it is
14:02:07 <sm> I've used vty, not hscurses.. did you try that ?
14:03:00 <djahandarie> osaunders, you're... just making TVec be a wrapper around tuples?
14:03:20 <osaunders> djahandarie: Yeah basically.
14:03:28 <djahandarie> That doesn't seem like it'll scale unless you involve Template Haskell
14:03:36 <osaunders> Yeah
14:03:43 <osaunders> I didn't say it was good :-)
14:03:45 <djahandarie> Vec works by enforcing the length on the type level
14:03:57 <osaunders> It won't work for any length though.
14:04:15 <osaunders> > 1:.()
14:04:16 <lambdabot>   Not in scope: data constructor `:.'
14:04:19 <osaunders> > 1:.2:.()
14:04:20 <lambdabot>   Not in scope: data constructor `:.'Not in scope: data constructor `:.'
14:04:33 <djahandarie> It should work unless your length is really big (since Peano numbers kinda suck)
14:04:48 <osaunders> OK, well I tried 1:.2:.3 ... all the way up to 20 and it was a type error.
14:05:29 <kwos> I need an idea for a demo on using concurrency in haskell
14:05:57 <kwos> something that takes (say) a csv file, reads it in chunks, processes each chunk in parallel and spits some result out
14:06:10 <acemo> great.. inferred type is not general enough
14:06:12 <kwos> any plausible projects?
14:06:19 <osaunders> kwos: What's wrong with that idea?
14:06:40 <kwos> osaunders: with which one?
14:06:52 <sproingie> port apache camel to haskell and i'll love you forever and ever :)
14:06:55 <osaunders> kwos: CSV idea
14:07:08 <kwos> I need some cpu bound stuff to show off what haskell can do
14:07:09 * osaunders wonders what acemo is referring to
14:07:46 <kwos> also, how to deal with for example iteratee based io and concurrency?
14:08:49 <acemo> osaunders: getting that error for this function: http://pastebin.com/efifDiVm the inferred type is Ord Int => Int -> [Int] -> [Int]
14:09:50 <roconnor> @type (Prelude..)
14:09:50 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
14:10:32 <roconnor> @type (fmap)
14:10:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:10:42 <roconnor> @type (fmap (.))
14:10:43 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
14:11:48 <roconnor> @type (fmap (Prelude..))
14:11:49 <lambdabot> forall b c a (f :: * -> *). (Functor f) => f (b -> c) -> f ((a -> b) -> a -> c)
14:13:54 <Zhuangzi> I just accidentally installed vlc-nox and it played the movie in the terminal, with coloured ASCII. That's going too far.
14:14:15 <osaunders> lol
14:14:21 <proq> nice
14:14:41 <acemo> Zhuangzi: coloured ascii movies are nice :)
14:14:56 <acemo> thanks for reminding me the name of it :)
14:15:03 <boegel> crap, I was hoping to redeem my free coupon of RWH online to read it on the flight, but seems like that won't work :(
14:15:09 <djahandarie> osaunders, that's because there is a context reduction limit (at 20) in GHC
14:15:17 <boegel> O'Reilly's app doesn't seem to support offline viewing :(
14:15:21 <djahandarie> You can increase it
14:15:38 <osaunders> djahandarie: Ah
14:16:24 <djahandarie> Look at this more closely though, I don't really like how it works very much either
14:16:38 <djahandarie> Maybe I'll write a nicer one in all my free time
14:17:09 <osaunders> djahandarie: How?
14:17:57 <djahandarie> Using type families which lead to much nicer code (imo) for everything
14:19:54 <osaunders> I think I'll just manage with lists.
14:20:55 <djahandarie> I have little clue what you're using this for so I can't really comment. :P
14:24:32 <guest__> hello everyone, does anyone understand mapreduce
14:25:11 <osaunders> Dunno, what's the question?
14:25:46 <guest__> osaunders: I will paste the link
14:31:11 <guest__> osaunders : here is the link   http://pastebin.com/VApJtD5z
14:35:47 <osaunders> OK, well you aren't even specifying the parameters in the right order according to your comments.
14:36:02 <osaunders> s/parameters/arguments/
14:36:39 <alpounet> Zao, out of curiosity, is hastrix's code public ?
14:41:51 <guest__> osaunders does the args have to be in the order of mapReduce?
14:42:13 <osaunders> Hell yes
14:45:33 <guest__> so my order is off, ok 
14:45:49 <guest__> let me try and fix it
14:46:32 <osaunders> What is mapReduce supposed to do?
14:46:38 <sipa1024> i've seen that code before
14:46:58 <osaunders> sipa1024: Yeah it is a homework, I think
14:47:07 * hackagebot vector-static 0.3.0.1 - Statically checked sizes on Data.Vector  http://hackage.haskell.org/package/vector-static-0.3.0.1 (JakeMcArthur)
14:47:12 <sipa1024> osaunders: yes
14:48:02 <djahandarie> jmcarthur, no maintainer anymore?
14:50:57 <jmcarthur> djahandarie: i haven't been maintaining it anyway. i only just got around to saying so on hackage
14:51:24 <jmcarthur> djahandarie: a couple people have expressed interest in picking up the reigns
14:52:06 <alpounet> is there much left to do on vector-static ?
14:52:25 <jmcarthur> alpounet: a fair bit. pumpkin wrote some bad code, and i wrote some more :P
14:52:49 <alpounet> how bad ?
14:53:00 <pumpkin> bad in the sense that it isn't easily usable in haskell
14:53:05 <pumpkin> and I don't think that will improve
14:53:08 <pumpkin> I consider it a failed experiment :P
14:53:24 <jmcarthur> pumpkin: in the case of the code that i wrote, also bad in the sense that i'm not sure if some of it even works correctly
14:53:26 <pumpkin> Saizan also contributed to it
14:53:29 <pumpkin> ah
14:53:36 <jmcarthur> ah, but Saizan didn't write bad code :P
14:53:44 <alpounet> pumpkin, you're talking about the type-level "numbers" to give the static size ?
14:53:50 <pumpkin> alpounet: yeah
14:53:51 <ddarius> He doesn't sound like a team player.
14:53:59 <Zao> alpounet: It's under "I don't remember what's in it, so do whatever you want, license".
14:54:17 <alpounet> yeah too bad haskell doesn't support constants passing
14:54:19 <alpounet> like in C++
14:54:20 <Zao> alpounet: Not horribly much more than a shoddy xtris protocol implementation and a shiny GL renderer :D
14:54:31 <jmcarthur> i don't remember if i made the unbox instance for static length vectors sane or not, namely
14:54:41 <jmcarthur> i had at first done it in a rather embarrassing way
14:55:24 <alpounet> Zao, that's actually that shiny GL renderer that i would like to take a look to :P
14:55:24 <alpounet> at*
14:55:34 <jmcarthur> looking at the source it at least looks like i had made it more sane than before after all
14:55:38 <Zao> The only innovative bits are probably the texture loading.
14:55:45 <jmcarthur> i still can't claim that it works, of course :P
14:56:00 <jmcarthur> what GL renderer?
14:56:04 <jmcarthur> i'm curious :)
14:57:01 <jmcarthur> pumpkin: honestly i don't think it must be necessarily unweildly to use
14:57:18 <jmcarthur> i mainly just got sick of rewriting and tracking the vector package
14:57:43 <jmcarthur> my personal preference would be to use newtype wrappers instead, but i don't remember why i didn't just try that
14:58:14 <jmcarthur> maybe you remember why you didn't in the first place?
14:58:20 <jmcarthur> that might jog my memory
15:00:18 <alpounet> jmcarthur, that of http://www.acc.umu.se/~zao/Hastris/
15:01:32 <alex404> What's the reasoning behind removing the State constructor from mtl-2? Do I really have to wrap all my state definitions with 'get' and 'put'?
15:01:58 <dobblego> I'll be writing haskell for a contract job
15:02:14 <osaunders> dobblego: What job?
15:02:37 <byorgey> alex404: State is now defined as StateT Identity
15:02:39 <dobblego> a bunch of functions (e.g. set difference) between some text file formats denoting inventory
15:02:51 <dobblego> I also write haskell in my day job, but that's a little different
15:02:58 <byorgey> alex404: so you can either use the StateT constructor, but that requires doing some wrapping + unwrapping of Identity as well
15:03:05 <osaunders> dobblego: cool
15:03:18 <byorgey> alex404: IIRC in the transformers package there is also a function called 'state' which is supposed to be a drop-in replacement for the State constructor
15:03:26 <byorgey> alex404: and there was some talk of adding it to mtl as well
15:03:37 <alex404> byorgey: I se...
15:04:07 <byorgey> alex404: but no, the reasoning is not to make you define everything in terms of get and put
15:04:12 <alex404> byorgey: Without the 'state' function, what's the correct way to turn a function \s -> (a,s) into a State computation? Do you need to use get and put?
15:04:25 <sproingie> what's an example of the state function?
15:05:27 <byorgey> alex404: well, it's not too hard to define 'state' in terms of  get and put:  state k = do s <- get; let (a,s') = k s; put s'; return a
15:06:13 <alex404> byorgey: Right... I guess it just seems a little obtuse to me. I'll just deal with it.
15:06:16 <quintessence> pumpkin: I've been playing with hmatrix-static lately, and it doesn't seem so unusable.  Does vector-static do something differently, or are the use cases for vectors just different enough from linear algebra that the hoops you have to jump through get in the way more?
15:06:45 <byorgey> alex404: but I think the 'state' function from the transformers package is not implemented like that, it is written directly in terms of the StateT constructor
15:07:00 <aavogt> @src State
15:07:00 <lambdabot> Source not found. Wrong!  You cheating scum!
15:07:22 <byorgey> alex404: there used to be separate State and StateT types; the new version has lses code duplication since State is simply defined in terms of StateT
15:07:25 <byorgey> that's the rationale
15:07:37 <int80_h> I'm trying to map over a list of strings in order to do the following. First, strip the first character from the string, then run the parse function over that string. Here's my attempt which is wrong. But what is right?  map (parseTest p_query) $ drop 1 collected
15:07:43 <byorgey> but it is a little annoying if you were using the State constructor
15:07:51 <alex404> byorgey: I see. Fair enough.
15:08:09 <alex404> byorgey: And I can always use StateT Identity...
15:08:26 <byorgey> alex404: sure
15:08:56 <alex404> byorgey: What is the difference exactly between transformer and mtl?
15:09:24 <int80_h> oh wait that's not my latest attempt. Here it is. map (parseTest p_query . drop 1) collected
15:09:37 <byorgey> alex404: mtl-2 just re-exports both transformers and monads-fd
15:09:46 <byorgey> alex404: so transformers is a subset of mtl
15:10:01 <alex404> byorgey: Except it has this handy little state function...
15:10:22 <byorgey> ah, well, right, apparently mtl does not re-export EVERYTHING =)
15:10:48 <byorgey> but if you have mtl you already have transformers, so it's just a matter of importing the right module from transformers to get access to 'state'
15:11:22 <byorgey> in particular transformers defines all the basic types and so forth, it's haskell-98 I think
15:11:37 <alex404> byorgey: Gotchya.
15:11:38 <byorgey> and monads-fd defines the classes like MonadState and MonadReader etc. that require functional dependencies
15:11:49 <byorgey> there's also monads-tf that uses type families instead.
15:12:21 <alex404> byorgey: Hmmm... interesting...
15:20:35 <int80_h> I have the following string with type IO (), would I use liftM to lift it out of  IO (). [("resourceId",Just "4"),("policy",Just "0"),("returnTo",Just "/showWebForwards.do")]
15:20:55 <int80_h> s/string/list
15:21:06 <ezyang> a string can't have type IO () 
15:21:15 <int80_h> yes I meant to say list
15:21:18 <ezyang> But you probably want >>= (or maybe mapM) 
15:21:26 <lispy1> ezyang: hey
15:21:29 <lispy1> ezyang: how's it going?
15:21:44 <ezyang> Yo! It's going well :-) 
15:21:52 <int80_h> @ mapM
15:21:56 <ezyang> being next door to the simons is lots of fun 
15:22:02 <int80_h> how do I invoke hoogle?
15:22:08 <ezyang> @hoogle mapM 
15:22:09 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:22:09 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
15:22:09 <lambdabot> Data.Traversable mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
15:22:16 <int80_h> oog in the Prelude!
15:22:19 <lispy1> ezyang: I bet
15:22:49 <dobblego> int80_h, [("resourceId",Just "4"),("policy",Just "0"),("returnTo",Just "/showWebForwards.do")] doesn't have a type related to IO
15:23:06 <aavogt> the data could be in IO though
15:23:25 <dobblego> ah you have IO [(String, Maybe String)] int80_h ?
15:23:56 <int80_h> I did the following
15:23:59 <int80_h> let parsedTest = parseTest p_query $ drop 1 "?resourceId=4&policy=0&returnTo=%2FshowWebForwards.do"
15:24:27 <int80_h> when I checked the type of parsedTest, I got parsedTest :: IO ()
15:24:41 <int80_h> that means parsedTest has type IO (), right?
15:25:46 <dobblego> that depends on the types of parseTest and p_query?
15:26:02 <quintessence> int80_h: parseTest (if that's the attoparsec one) doesn't actually return anything useful, it just prints stuff
15:26:20 <int80_h> ooh!, no it's the parsec one
15:26:25 <int80_h> so I don't actually need it
15:26:34 <int80_h> that would explain why things are being put in IO ()
15:26:36 <quintessence> int80_h: you probably want parse instead of parseTest
15:27:46 <joe6> "do" can only be used in functions with a return type of IO (). Is it true?
15:28:00 <aavogt> > do Just 1; Just 2
15:28:01 <lambdabot>   Just 2
15:28:07 <mauke> joe6: no
15:28:11 <joe6> else it adds sequencing?
15:28:21 <int80_h> I need to read up on Parsec.
15:28:24 <mauke> joe6: 'do' can be used outside of functions and it's not limited to IO
15:28:35 <int80_h> let parsedTest = parse p_query $ drop 1 "?resourceId=4&policy=0&returnTo=%2FshowWebForwards.do"
15:28:40 <mauke> joe6: depends on your definition of "sequencing"
15:28:50 <int80_h> that yields type parsedTest :: [Char] -> Either ParseError [(String, Maybe String)]
15:28:57 <joe6> first do "Just 1" and then do "Just 2"
15:29:08 <aavogt> > do 5
15:29:09 <lambdabot>   5
15:29:09 <int80_h> I wanted the results of the function, not a function.
15:29:15 <joe6> does that not break the functional substitution mechanism?
15:29:24 <aavogt> you can put do nearly everywhere
15:29:40 <mauke> joe6: no, why?
15:29:50 <mauke> > do Just 1; Just 2
15:29:51 <lambdabot>   Just 2
15:30:06 <mauke> > do [1, 2]; "xyz"
15:30:07 <lambdabot>   "xyzxyz"
15:30:10 <joe6> why does the program need to evaluate "Just 1" when it just needs the value of "Just 2"?
15:30:18 <mauke> it doesn't evaluate Just 1
15:30:30 <joe6> or execute, I mean?
15:30:49 <joe6> so, "Just 1" never gets executed?
15:30:58 <mauke> what do you mean by "executed"?
15:31:05 <joe6> I mean run.
15:31:08 <mauke> what do you mean by "run"?
15:31:10 <mauke> 'do' isn't magic
15:31:23 <mauke> 'do Just 1; Just 2' is equivalent to 'Just 1 >> Just 2'
15:31:28 <mauke> so look at the definition of (>>)
15:31:44 <sipa1024> @src (>>=) Maybe
15:31:45 <lambdabot> Source not found. You type like i drive.
15:32:09 <ddarius> @src Maybe (>>=)
15:32:09 <lambdabot> (Just x) >>= k      = k x
15:32:09 <lambdabot> Nothing  >>= _      = Nothing
15:32:16 <joe6> but >> is for monadic itemsL
15:32:21 <joe6> s/L/?/
15:32:47 <djahandarie> Yes. So, do notation can be used for any type with a monad instance.
15:32:54 <mauke> Just 1 is a monadic item
15:33:01 <mauke> a.k.a. "mote"
15:33:18 <djahandarie> Last time I tried using that a bunch of people disagreed with it
15:33:22 <djahandarie> But yeah, mote
15:33:24 <pumpkin> quintessence: you tend to not want submatrices as often as you want subvectors
15:33:29 <djahandarie> > do Nothing; Just 1
15:33:30 <lambdabot>   Nothing
15:33:43 <djahandarie> > Nothing >> Just 1
15:33:43 <lambdabot>   Nothing
15:33:52 <djahandarie> @undo do Nothing; Just 1
15:33:52 <lambdabot> Nothing >> Just 1
15:33:55 <aavogt> @type do $ do $ do $ do something
15:33:56 <lambdabot> Empty 'do' construct
15:34:11 <mauke> > do Just (error "bam!"); Just "this"
15:34:12 <lambdabot>   Just "this"
15:34:30 <aavogt> @type do (do something)
15:34:31 <lambdabot> forall u a. (Data a) => GenericQ (Maybe u) -> a -> Maybe u
15:34:43 <joe6> f x = f y + f y; -- mathematical notation. But, how can you use "do"or">>" in mathematics?
15:35:00 <mauke> f x = f y >> f y
15:35:08 <mauke> well, you'd have to define what you mean by '>>' first
15:35:15 <djahandarie> Just like how you need to define +
15:35:25 <joe6> first do the first portion and then do the second portion?
15:35:30 <joe6> isn't that ">>"?
15:36:26 <sproingie> > do { Just undefined; Just 2 }
15:36:27 <lambdabot>   Just 2
15:37:07 <joe6> then given the laziness, why should haskell execute or calculate "Just undefined"?
15:40:00 <joe6> so, "do" can only be used where monadic types are involved?
15:40:21 <mauke> joe6: what >> does depends on you how define >>
15:40:53 <joe6> and not for a straightforward String -> [String] kind of function? though, when I tested in ghci, it raises a warning but still allows the compilation.
15:41:20 <mm_freak> > isJust (Just undefined)
15:41:21 <lambdabot>   True
15:41:52 <sipa1024> mauke: if you do not import Prelude and define (>>) as something completely unrelated to Monads, would you be able to use 'do' ?
15:41:53 <mauke> functions are monadic values
15:41:58 <joe6> mauke:  function 1 = do function 2; function 3 <-- does this make sense mathematically.?
15:42:16 <mauke> joe6: looks like an infinite loop
15:42:20 <mauke> and/or a type error
15:42:25 <mauke> but it depends on how you define '>>'
15:42:37 <mauke> sipa1024: 'do' would still use Prelude.>>
15:42:48 <joe6> i understand that haskell functions are church's substitutable functions?
15:43:32 <sipa1024> mauke: that's what i expected
15:43:35 <joe6> sorry, guys. I think I am missing something here. will check on google about sequencing in mathematics and correlate that with haskell
15:43:36 <djahandarie> no-implicit-prelude will make do notation use whatever (>>) is defined in the file though
15:43:53 <sipa1024> djahandarie: oh, nice
15:43:59 <mauke> joe6: forget "sequencing"
15:44:15 <mauke> joe6: do-notation turns into calls to '>>', which is just another operator/function
15:44:16 <int80_h> so I', reading up on Parsec via RWH. I come across this type signature and I'd like to get an explaination as it doesn't look like a type signature I've seen before. p_pair :: CharParser () (String, Maybe String)
15:44:24 <mm_freak> mauke: it would be a pattern match failure probably
15:44:39 <mm_freak> > let function 1 = do function 2 >> function 3 in function 1
15:44:39 <lambdabot>   No instance for (GHC.Show.Show (m a))
15:44:40 <lambdabot>    arising from a use of `M2562384759...
15:44:47 <mm_freak> > let function 1 = do function 2 >> function 3 in function 1 :: IO ()
15:44:48 <lambdabot>   <IO ()>
15:44:54 <mm_freak> > let function 1 = do function 2 >> function 3 in function 1 :: Maybe ()
15:44:55 <lambdabot>   *Exception: <interactive>:1:153-192: Non-exhaustive patterns in function fu...
15:44:58 <mm_freak> yeah
15:45:23 <mm_freak> unless (>>) is completely non-strict
15:46:55 <joe6> mauke: ha,ha.. look at it as a function operator >> and forget about sequencing.
15:47:09 <mauke> yes
15:47:15 <djahandarie> You don't need to 'look at it' like that. That is literally what it is.
15:47:36 <joe6> so, ">>" is an operator just as "-" or "+"
15:47:37 <mauke> there is no magic here
15:47:40 <djahandarie> Yes.
15:51:03 <joe6> just curious, why is it not "Just 1; Just 2" instead of "Just 1 >> Just 2"? why not just treat ";" as the ">>" operator?
15:51:40 <mm_freak> joe6: because ; is syntax and used elsewhere, too
15:51:45 <joe6> is there a mathematical foundation to using the ">>" operator?
15:51:49 <mauke> OCaml actually does that
15:52:05 <danharaj> :t (>>)
15:52:06 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
15:52:17 <mm_freak> > let x = 3; y = 4 in (x,y)
15:52:17 <lambdabot>   (3,4)
15:52:38 <mm_freak> otherwise we would have to use ocaml's ;; instead, which i would find ugly
15:52:50 <Saizan> joe6: ; is used as a line separator in general in the haskell grammar
15:53:32 <mauke> mm_freak: let x = 3 and y = 4 in (x, y)  (* :-) *)
15:54:01 <sipa1024> > do { [1,2]; [3,4] }
15:54:02 <lambdabot>   [3,4,3,4]
15:54:27 <Saizan> joe6: and can be replaced by use of layout
15:54:31 <hpc> > do {[1]; [1, 2]}
15:54:32 <lambdabot>   [1,2]
15:54:41 <mm_freak> mauke: yes, but that's not the state of things
15:54:47 <joe6> oh, ok... ">>" is no big deal other than to convey the message that the functions bound by it are executed one after the other and the result of such a compound function is the return value of the second function.
15:54:59 <mm_freak> and honestly i prefer ; over "and"
15:55:07 <mauke> joe6: except when it isn't
15:55:09 <danharaj> >> has more structure than that
15:55:20 <mauke> joe6: also, >> doesn't take functions
15:55:26 <mm_freak> for example this would be quite funny with "and":  let x :: Integer and x = 3 …
15:55:28 <danharaj> for example, foo >> bar, where foo and bar are IO values.
15:56:02 <danharaj> >> in the identity monad is (\x y -> y) though
15:56:13 <mm_freak> joe6: try to understand (>>=) instead of (>>)
15:56:27 <mm_freak> this gives you much more insight into both
15:56:32 <mauke> try to understand liftM and join instead of (>>=) :-)
15:56:33 <hpc> also, (>>=) = (.)
15:56:40 <sproingie> >> is >>= that throws away its arg on the right
15:56:40 <mm_freak> lol mauke 
15:56:52 <joe6> s/right/left/?
15:56:54 <hpc> :t (>>= const)
15:56:55 <lambdabot> forall a b. (b -> a) -> b -> a
15:57:09 <sproingie> the arg that comes from the left
15:57:13 <hpc> :t (>>= flip const)
15:57:14 <lambdabot> forall a b. (b -> a) -> b -> b
15:57:18 <danharaj> sproingie: no it isn't. (>>) foo is not equal to id.
15:57:26 <danharaj> in general
15:57:28 <sipa1024> @pl (>>= const)
15:57:28 <lambdabot> (const =<<)
15:57:37 <sipa1024> ...
15:57:40 <hpc> haha
15:57:41 <mauke> @src (=<<)
15:57:41 <lambdabot> f =<< x = x >>= f
15:58:01 <Saizan> hpc: (>>=) = (.) when?
15:58:10 <hpc> when identity monad
15:58:11 <joe6> is there any tutorial that can explain the mathematical foundations of haskell?
15:58:14 <hpc> :t (>>=)
15:58:15 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:58:22 <hpc> er
15:58:28 <Saizan> (>>=) = flip ($)
15:58:32 <hpc> derp
15:58:43 <ezyang> lies lies 
15:58:46 <sproingie> er wha no
15:58:49 <hpc> :t ($ const)
15:58:50 <lambdabot> forall b a b1. ((a -> b1 -> a) -> b) -> b
15:59:02 <hpc> whoa, that's a trippy function
15:59:02 <djahandarie> :t flip ($)
15:59:03 <lambdabot> forall a b. a -> (a -> b) -> b
15:59:10 <sproingie> @src id
15:59:10 <lambdabot> id x = x
15:59:14 <mm_freak> joe6: honestly i don't recommend trying to understand the mathematical foundations, unless you like dry math…  try to read a good monads tutorial
15:59:15 <djahandarie> :t flip
15:59:16 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
15:59:17 <sproingie> @src ($)
15:59:17 <lambdabot> f $ x = f x
15:59:24 <mm_freak> joe6: a /haskell/ monads tutorial that is
15:59:36 <djahandarie> Screw the monads tutorial
15:59:41 <djahandarie> Read the monoid tutorial and the functor tutorial first
15:59:47 <hpc> ^
15:59:49 <djahandarie> If they exist
15:59:50 <hpc> also applicative
15:59:59 <djahandarie> http://learnyouahaskell.com
15:59:59 <hpc> djahandarie: learn you a haskell does it in that order
16:00:04 <djahandarie> I know
16:00:07 <mm_freak> well, you don't need to monoid tutorial, but the functor tutorial would be a great start
16:00:14 <mm_freak> then move to applicative and finally to monad =)
16:00:43 <Saizan> read moggi's paper on monads
16:01:18 <hpc> monoid is a good helping step to monad
16:01:39 <ddarius> Read "The essence of functional programming."  Entertaining, interesting, and effective.
16:01:45 <danharaj> I forget, what is the mathematical formulation of an applicative functor again?
16:01:50 <mauke> > "abc" ++ "def"  -- now you understand monoids
16:01:51 <lambdabot>   "abcdef"
16:01:52 <danharaj> Monoidal functor?
16:02:44 <ddarius> hpc: The abstract thinking behind understanding monoid is a good step.  Despite the "monoid object in the category of endofunctors" bit, monoids would not directly help much in understanding monads.
16:02:52 <mm_freak> hpc: i found that understanding the categorical definition of monads doesn't bring you haskell monads much closer…  after all many people don't realize that in order to understand haskell monads, you need to look at examples of them
16:03:18 <mm_freak> not the abstract definition, and absolutely no fancy metaphors
16:03:36 <sproingie> fancy metaphors are like burritos
16:03:38 <ezyang> monads as monoids is a convenient way of remembering the monad laws. 
16:03:49 <hpc> sproingie: expensive and gross?
16:04:06 <sproingie> i guess that's a simile not a metaphor
16:04:07 <mm_freak> ezyang: most programmers have either no background in algebra or have forgotten everything
16:04:16 <djahandarie> A monoid object also not a monoid
16:04:23 <djahandarie> (Except in Set)
16:04:50 <Dan__> hey everyone I have a simple question
16:05:07 <mauke> I have a useless answer
16:05:07 <danharaj> I think monoids are monoids in a concrete category?
16:05:21 <sipa1024> Dan__: unless you ask it, no one will be able to answer :)
16:05:28 <ddarius> hpc: Where do you find expensive burritos?
16:05:29 <Dan__> hold on i'm think of how to phrase it
16:05:47 <mm_freak> Dan__: if you need to think about how to phrase it, it can't be that simple ;)
16:05:48 <hpc> ddarius: i live in DC; /everything/ is expensive
16:05:52 <Dan__> so i've got myFunction :: [[Int]] -> Bool
16:06:06 <Dan__> [[Int]] is a list of lists, right?
16:06:13 <hpc> Dan__: yes
16:06:35 <jmcarthur> ezyang: i also like thinking of the monad laws in terms of their kleisli arrow counterparts
16:06:39 <Dan__> i need a way to evaluate the lists seperately
16:06:51 <joe6> Dan__: map?
16:06:52 <mm_freak> Dan__: that depends on what you want to do
16:06:55 <ezyang> Oh yeah. the laws are much more readable using Kleisli composition 
16:07:10 <ddarius> hpc: Find a Baja Fresh and get a Burrito Ultimo.  I know there are Baja Freshes at least in the DC area if not in DC itself and a Burrito Ultimo isn't too cheap but it is very cheap and very good for how much you get.
16:07:24 <hpc> ddarius: awesome; will do
16:07:35 * ezyang kind of wants a burrito now 
16:07:36 <Dan__> okay let's say i've got this:
16:07:48 <sproingie> i prefer chipotle
16:07:51 <djahandarie> Monads: coming to fast food joints near you
16:07:52 <mm_freak> > map length [[1,2,3], [4,5], [6,7,8,9]]
16:07:53 <lambdabot>   [3,2,4]
16:08:20 <ddarius> sproingie: I've never been to a Chipotle, but there are several around here and a lot of people I've known elsewhere have seemed to really like Chipotle.
16:08:21 <hpc> > map reverse [[1, 2, 3], [3, 2], [1]]
16:08:22 <lambdabot>   [[3,2,1],[2,3],[1]]
16:08:28 <Dan__> [
16:08:28 <ddarius> sproingie: That said, I never saw one when I lived in the DC area.
16:08:29 <Dan__> [
16:08:31 <Dan__> [0,10,15], [0,1,15], [0,8,15], [0,4,15]
16:08:33 <Dan__> ],
16:08:34 <Dan__> [
16:08:36 <Dan__> [1,10,15],[1,4,15],[0,4,15],[0,7,15],[0,2,15],[0,3,15]
16:08:37 <Dan__> ]
16:08:39 <Dan__> ]
16:08:41 <sipa1024> Dan__: for longer pastes, please use hpaste.org
16:08:41 <Dan__> sorry
16:08:43 <mm_freak> Dan__: please use a pasting service
16:08:45 <Dan__> okay
16:08:45 <ezyang> Dan__: Hpaste please. 
16:08:57 <hpc> or at least put it on one line
16:09:02 <sipa1024> > map (const "bla bla bla") [[1, 2, 3], [3, 2], [1]]
16:09:03 <lambdabot>   ["bla bla bla","bla bla bla","bla bla bla"]
16:09:08 <hpc> also, that's Num a => [[[a]]]
16:09:17 <Dan__> how do i send it from hpaste?
16:09:23 <Dan__> just copy and paste :)
16:09:24 <hpc> copy url
16:09:30 <Dan__> okay: http://hpaste.org/41395/lists
16:09:33 <mm_freak> > unwords . reverse . words $ "this is a groovy test"
16:09:34 <lambdabot>   "test groovy a is this"
16:10:02 <Dan__> so there are two lists of "items" there
16:10:05 <lispy1> > text . unwords . reverse . words $ "this is a groovy test"
16:10:06 <lambdabot>   test groovy a is this
16:10:20 <mm_freak> Dan__: that's a list of list of lists
16:10:21 <Dan__> i need the first number to be 0 exactly four times for both
16:10:29 <Dan__> okay
16:10:47 <Dan__> how should I evaluate a list of lists?
16:10:53 <ezyang> Dan__: So you would like to test that fact? 
16:10:59 <mauke> what do you mean by "evaluate"?
16:11:22 <ezyang> Dan__: In which case, I recommend first throwing away unnecessary information; namely, you only need the heads of the list to answer that question. 
16:11:23 <Dan__> Make sure that 4 lists start with 0
16:11:24 <Dan__> for both lists
16:11:31 <ezyang> map (map head) 
16:11:34 <Dan__> okay
16:11:50 <ezyang> that'll give you a list of lists of numbers 
16:12:36 <mm_freak> > map (length . filter (== 0) . map head) $ [[[0,1,2], [0,1,2], [1,1,2]], [[0,1,2], [0,2,3], [0,3,4], [0,4,5]]]
16:12:37 <lambdabot>   [2,4]
16:13:11 <ezyang> well, there's an answer :-) 
16:13:24 <mm_freak> remove the $, it's there for historical reasons only =P
16:13:41 <mm_freak> (i always put a $, when i know i'm going to use function composition)
16:13:45 <Dan__> okay so I've got it reading in: http://hpaste.org/41396/readinlists
16:14:18 <mm_freak> Dan__: side note, you should try to avoid unsafe functions like 'head'
16:14:22 <mm_freak> use pattern matching instead
16:15:10 <mm_freak> do args <- getArgs; case args of file:_ -> readFile file >>= doSomethingWithFileContents;  _ -> hPutStrLn stderr "Missing argument"
16:16:05 <Dan__> Okay once I've got this read in and have a [[Int]]
16:16:49 <Dan__> I can use head to get the front of the lists?
16:17:05 <brisbin> > head []
16:17:05 <lambdabot>   *Exception: Prelude.head: empty list
16:17:13 <joe6> there is a fundamental difference between lists of lisp and lists of haskell. Lists of haskell must be elements of the same type, whereas the lists of lisp can be elements of different types.
16:17:36 <ezyang> joe6: That's more of a typing philosophy difference. 
16:17:40 <joe6> oh, ok.
16:17:48 <joe6> static typing vs dynamic typing?
16:17:50 <djahandarie> Note that all Haskell learners may not know Lisp anyways
16:17:52 <ezyang> but lisp lists are also mutable, so there is a bit of difference. 
16:18:02 <mm_freak> joe6: that's not so much a fundamental difference…  after all you can have mixed type elements in haskell, too
16:18:04 <joe6> what is meant by mutable?
16:18:11 <ezyang> One is well advised to treat cons cells as pairs of pointers :-) 
16:18:14 <joe6> mm_freak: tuple?
16:18:18 <ezyang> joe6: I can set-car! and set-cdr! 
16:18:33 <joe6> ezyang: yes.
16:18:37 <osaunders> mm_freak: How?
16:18:43 <mm_freak> joe6: no, but:  data Object = Car | House | Horse;  someList :: [Object]
16:18:45 <joe6> mm_freak: as an ADT?
16:18:57 <ezyang> osaunders: Dynamic or any other variety of naughty tricks :-) 
16:18:58 <joe6> mm_freak: yes, makes sense.
16:19:04 <mauke> cons x y = (x, y)
16:19:06 <mauke> nil = ()
16:19:10 <mm_freak> yes, as an ADT
16:19:10 <sipa1024> static types and dynamic types are very different concepts :)
16:19:15 <osaunders> ezyang: Is Dynamic a library?
16:19:20 <sipa1024> joe6: a static type is a compile-time property of an expression, a dynamic type is a runtime-property of a value
16:19:23 <ezyang> Data.Dynamic is a module 
16:19:36 <mm_freak> you might even want this:  newtype Object = forall a. SomeClass => Object a
16:19:46 <djahandarie> So guys. Why don't we have something simple like this in Hackage? http://hpaste.org/41397/simple_vect
16:20:07 <djahandarie> All the existing vec implementations are just overcomplicated as hell
16:20:40 <mm_freak> djahandarie: because it's not really useful in most practical applications
16:20:58 <mm_freak> note that the list length needs to be known statically
16:21:02 <pumpkin_> sure it is
16:21:08 <mm_freak> although reification might be useful here
16:21:09 <pumpkin_> and no it doesn't
16:21:12 <ezyang> Type complexity (or theorem proving complexity, really) tends to get introduced when you try to do real work :-) 
16:21:31 <aavogt> djahandarie: even this one http://hackage.haskell.org/package/Vec ?
16:21:33 <sipa1024> try to write a nub for those Vectors
16:21:49 <djahandarie> aavogt, I think it's overcomplicated
16:21:56 <sipa1024> where the length depends on more than statically known properties
16:21:56 <djahandarie> And refication is very easy to add to this
16:22:03 <joe6> sipa1024: never thought of them that way, makes sense.
16:22:06 <mm_freak> pumpkin_: as soon as you read a file as such a list, you will have to runtime-check the length
16:22:23 <pumpkin_> mm_freak: the point is that you can have a typed maybe
16:22:28 <pumpkin_> existentials are crucial here
16:22:53 <pumpkin_> but you can guarantee local properties at compile time
16:22:58 <osaunders> Damn this room is too interesting
16:23:31 <mm_freak> pumpkin_: yes, it can be useful at some spots, but such a list shouldn't be the 'default' list type, i think
16:23:39 <pumpkin_> something like readLength5 :: FilePath -> IO (Maybe (Vec (S (S (S (S (S Z))))) Int))
16:23:47 <pumpkin_> I definitely agree it shouldn't be the default
16:23:51 <pumpkin_> but it should be available
16:23:53 <djahandarie> I agree with that too
16:24:13 <pumpkin_> then once I have that Vec (S (S (S (S (S Z)))) Int, I can pass that elsewhere and know it's definitely 5
16:24:18 <mm_freak> well, such a type gets really useful, as soon as you have dependent types
16:24:22 <mm_freak> but you don't have them in haskell
16:24:30 <pumpkin_> or I can just guarantee that the rows and cols of my matrices match for multiplication, without necessarily knwoing them
16:24:30 <mm_freak> so it gets hacky
16:24:56 <pumpkin_> you can do plenty of fairly dependent things in haskell already, but the duplication between typelevel and valuelevel is annoying
16:25:11 <mm_freak> yes
16:25:14 <aavogt> does she help pumpkin_?
16:25:28 <pumpkin_> ?
16:25:30 <djahandarie> I'll keep on bugging byorgey until we get something better ! ;)
16:25:35 <djahandarie> pumpkin_, SHE, probably...
16:25:38 <pumpkin_> oh
16:25:47 <pumpkin_> yeah, I wrote a fairly complete Vec in SHE a while back
16:25:56 <pumpkin_> with conal's vector-space instances for it
16:26:07 <pumpkin_> and matrices
16:26:29 <conal> matrices? not linear maps?
16:26:41 <pumpkin_> oh here it is
16:26:41 <pumpkin_> http://hpaste.org/8890
16:26:49 <pumpkin_> or one of the iterations of it, at least
16:27:08 <pumpkin_> it wasn't as elegant as I'd hoped
16:27:23 <pumpkin_> () ~ Basis a
16:27:38 <pumpkin_> and a ~ Scalar a
16:28:30 <JohnnyL> > .4
16:28:30 <lambdabot>   <no location info>: parse error on input `.'
16:28:34 <JohnnyL> ha ha
16:28:37 <pumpkin_> the Infinity stuff was me not knowing haskell well enough
16:28:48 <alex404> Okay, I'm not sure if this question even makes sense, but is it possible to apply a state transformer to GHCi so as to turn it into a combo of say, IO and State monads?
16:29:39 <ezyang> alex404: Not really. 
16:29:47 <ezyang> Fortunately, you can simulate basically any monad in IO :-) 
16:29:51 <int80_h> @hoogle mzero
16:29:51 <lambdabot> Control.Monad mzero :: MonadPlus m => m a
16:30:10 <alex404> ezyang: I suppose that's true...
16:30:46 <hpc> ezyang: i wonder if there's a general hack for simulating other monads like there is for Cont
16:30:56 <alex404> Exactly
16:31:05 <alex404> I'd rather not have to rewrite my pretty interface
16:31:17 <alex404> But it'd be cool to be able to give it to people to play with in GHCi
16:31:25 <pumpkin_> mm_freak: ideally, you shouldn't have to choose between List and Ve
16:31:26 <pumpkin_> Vec
16:31:34 <pumpkin_> or duplicate definitions for them
16:31:38 <ezyang> They can still play with it in GHC, they just have to bracket it properly ;-) 
16:31:41 <int80_h> @hoogle readSigned
16:31:41 <lambdabot> Numeric readSigned :: Real a => ReadS a -> ReadS a
16:31:47 <alex404> ezyang: Boo.
16:31:58 <pumpkin_> there's been some interest in the DT community recently about the relationship between nat/list/vec
16:32:05 <hpc> foo <- runMonadT monadTFunction bar
16:32:12 <pumpkin_> and similar structurally similar structures
16:32:17 <hpc> foo :: Monad returnValue
16:32:22 <pumpkin_> that's a pretty fucked up message I just wrote
16:32:24 <joe6> just noticed that the ghc executable is 17M. Do you know if anyone has tried to make it smaller?
16:32:26 <ezyang> I've been wanting to make GHCi more flexible. 
16:32:28 <hpc> er, foo :: returnValue
16:32:36 <hpc> er, derp
16:32:38 <pumpkin_> joe6: probably not, as I doubt many people care
16:32:43 <ezyang> For example, making it use something besides Show to print values. 
16:32:43 <joe6> oh, ok.
16:33:03 <ezyang> but the last time I looked at the code I figured out what I had to do and it didn't look pretty. 
16:33:05 <alex404> hpc: What's going on there?
16:33:27 <alex404> ezyang: Roll up those sleeves!
16:33:30 <alex404> (make my life easier)
16:33:33 <alex404> ;)
16:33:42 <hpc> @where hpaste
16:33:43 <lambdabot> http://hpaste.org/
16:34:25 <aavogt> ezyang: I agree about ghci
16:35:01 <ezyang> btw, GHC's bytecode interpreter is AWESOME 
16:35:03 <djahandarie> Oh, I and K are neat
16:35:18 <aavogt> presumably you just add another field in whatever state monad is in use to contain the (a -> String) (or maybe IO instead?)
16:35:46 <hpc> alex404: http://hpaste.org/41398/extracting_from_transformer
16:36:20 <pumpkin_> ezyang: you writing a JIT for it? :P
16:36:20 <hpc> the output of that will either be "Nothing" or "Just 6"
16:36:21 <pumpkin_> kthx
16:36:40 <hpc> depending on the line you give it
16:36:50 <ezyang> No, although that would be pretty hilarious. 
16:37:23 <hpc> (replacing "mzero" with "fail []" might be necessary, and MaybeT isn't in mtl either)
16:37:34 <alex404> hpc: That's interesting...
16:37:43 <hpc> @hoogle MaybeT
16:37:44 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
16:38:02 <aavogt> @hackage MaybeT
16:38:02 <lambdabot> http://hackage.haskell.org/package/MaybeT
16:38:21 <aavogt> @hoogle ErrorT
16:38:21 <lambdabot> Control.Monad.Error newtype ErrorT e m a
16:38:21 <lambdabot> Control.Monad.Error ErrorT :: m (Either e a) -> ErrorT e m a
16:38:21 <lambdabot> System.IO.Error alreadyExistsErrorType :: IOErrorType
16:39:30 <ddarius> ezyang: Why is it awesome?
16:40:14 <ezyang> ddarius: It just... does so many terrifying things. 
16:40:25 <led> &djinn
16:42:51 <led> @type map
16:42:51 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:42:58 <led> @djinn a -> b
16:42:58 <lambdabot> -- f cannot be realized.
16:43:07 <led> hmm
16:43:28 <pumpkin_> @djinn (a -> b) -> Maybe a -> Maybe b
16:43:28 <lambdabot> f a b =
16:43:28 <lambdabot>     case b of
16:43:28 <lambdabot>     Nothing -> Nothing
16:43:28 <lambdabot>     Just c -> Just (a c)
16:43:31 <pumpkin_> (I bet it gets it wrong)
16:43:36 <pumpkin_> oh nice
16:43:37 <led> Ha
16:43:44 <led> Well I'll be damned
16:43:50 <pumpkin_> I guess it does usually make an effort to use all parameters
16:43:56 <pumpkin_> which the wrong answer wouldn't have done
16:44:14 <led> @djinn (s -> Maybe (a, w)) -> s -> (Maybe (a, w))
16:44:14 <lambdabot> f a = a
16:44:16 <led> heh
16:44:27 <led> ah wait
16:44:34 <led> @djinn (s -> Maybe a, w)) -> s -> (Maybe (a, w))
16:44:34 <lambdabot> Cannot parse command
16:44:35 <pumpkin_> @djinn (a -> b) -> (c -> d) -> Either a c -> Either b d
16:44:35 <lambdabot> f a b c =
16:44:35 <lambdabot>     case c of
16:44:35 <lambdabot>     Left d -> Left (a d)
16:44:35 <lambdabot>     Right e -> Right (b e)
16:44:42 <led> @djinn (s -> (Maybe a, w)) -> s -> (Maybe (a, w))
16:44:42 <lambdabot> f a b =
16:44:42 <lambdabot>     case a b of
16:44:42 <lambdabot>     (c, d) -> case c of
16:44:42 <lambdabot>               Nothing -> Nothing
16:44:44 <lambdabot>               Just e -> Just (e, d)
16:45:03 <led> right, now to run some continuations through it
16:45:37 <Apocalisp_> pumpkin_, are you in Boston yet?
16:45:53 <led> @djinn ((r -> (t -> a)) -> (t -> a)) -> t -> ((r -> a)) -> a)
16:45:53 <lambdabot> Cannot parse command
16:45:55 <led> bah
16:46:08 <led> @djinn ((r -> (t -> a)) -> (t -> a)) -> t -> ((r -> a) -> a)
16:46:08 <lambdabot> f a b c = a (\ d _ -> c d) b
16:47:20 <mm_freak> pumpkin_: well, [] could be a special case of Vec, and the latter could support no restrictions
16:47:38 <led> @djinn (t -> ((r -> a) -> a)) -> (r -> (t -> a)) -> (t -> a)
16:47:38 <lambdabot> f a b c = a c (\ d -> b d c)
16:48:20 <led> a week of pointless research rendered obsolete by djinn
16:48:24 <led> wahey
16:48:50 <dons> heh
16:49:26 <monochrom> many students still don't know that propositional logic is a done deal.
16:51:04 <Rotaerk_> monochrom, I thought it was just a proposition!?
16:52:10 <monochrom> sorry, "it" = ?
16:52:11 <led> excuse me whilst i beat djinn down with a load of typing judgements, everyone
16:52:16 <led> usual service will resume shortly
16:52:28 <djahandarie> You can just cabal install it
16:52:34 <djahandarie> cabal install djinn
16:52:39 <led> touche
16:53:01 <djahandarie> Or /msg lambdabot
16:53:16 <led> ah
16:53:23 <led> i haven't used IRC in many a month
16:53:25 <monochrom> you may like /msg lambdabot @djinn a->a  but I enjoy your trials, so don't feel pushed either way
16:53:25 <led> thanks
16:53:29 <led> heh
16:53:59 <led> im trying to work out isomorphisms between different permutations of monad transformers, turning the handle manually works up to a point
16:54:09 <led> as soon as you start involving continuations, it goes to hell
16:55:02 <monochrom> if you accidentally go to hell, use callCC to come back
16:55:08 <led> :p
16:55:12 <djahandarie> Do not pass Go.
16:55:36 <led> @djinn ((r -> (s -> (a, s))) -> (s -> (a, s))) -> s -> (r -> (a, s)) -> (a, s)
16:55:36 <lambdabot> f a b c =
16:55:36 <lambdabot>     (case a (\ d e ->
16:55:36 <lambdabot>              case c d of
16:55:36 <lambdabot>              (f, _) -> (f, e)) b of
16:55:36 <lambdabot>      (g, _) -> g,
16:55:38 <lambdabot>      b)
16:55:55 <led> a mild stutter there :p
16:56:35 <monochrom> callCC (\c -> c False >> gandolf says "you shall not pass!!!" >> return True)
16:57:31 <djahandarie> lol
17:00:06 * hackagebot iteratee 0.6.0.1 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.6.0.1 (JohnLato)
17:01:07 * hackagebot mutable-iter 0.4 - iteratees based upon mutable buffers  http://hackage.haskell.org/package/mutable-iter-0.4 (JohnLato)
17:01:58 <sm> GO HACKAGE
17:02:09 * hackagebot sndfile-enumerators 0.6.0 - Audio file reading/writing  http://hackage.haskell.org/package/sndfile-enumerators-0.6.0 (JohnLato)
17:06:56 <ymasory> what happens if you use a comparison operator on lists of a type whose elements aren't comparable? (meaning the two lists of are of the same type, but the individual elements have no notion of order)
17:08:16 <ClaudiusMaximus> :t [] < []
17:08:17 <brisbin> type error, no Ord instance ?
17:08:17 <lambdabot> Bool
17:08:59 <ymasory> hmm that blows my mind. such a restriction cannot be expressed in scala
17:09:06 <aavogt> > [(+)] `compare` [subtract]
17:09:07 <lambdabot>   *Exception: (==): No overloading for function
17:09:11 <aavogt> heh
17:09:50 <djahandarie> That being a side effect of vector-space
17:09:51 <djahandarie> As usual
17:10:01 <aavogt> that instance isn't usually present
17:10:32 <ClaudiusMaximus> > [show] < [read]
17:10:33 <lambdabot>   *Exception: (==): No overloading for function
17:10:36 <ClaudiusMaximus> hm, bizarre
17:11:02 <aavogt> > [Endo succ] `compare` [Endo pred]
17:11:03 <lambdabot>   No instance for (GHC.Classes.Ord (Data.Monoid.Endo a))
17:11:03 <lambdabot>    arising from a us...
17:12:43 <aavogt> ymasory: shouldn't the equivalent in scala be that there is no such method present, or no implicit conversion to make the method become present?
17:13:59 <ymasory> aavogt: List[X] either does or does not have the method <. You can't selectively define methods based on the type parameter.
17:14:26 <aavogt> the method can't have a type that says X is in some other class?
17:14:57 <ymasory> hmm that's a good point
17:15:07 * aavogt hasn't really learned much scala
17:15:16 <monochrom> > compare [True,False] [False]
17:15:16 <lambdabot>   GT
17:21:16 <monochrom> "data  [a]  =  [] | a : [a]  deriving (Eq, Ord)" from the report. [] < x:xs, x<y implies x:xs < y:ys, xs<ys implies x:xs<x:ys
17:37:50 <cathper_> Say, I have a list of lists. I'd like to know what's in the intersection of all the lists in the list. How to do such thing elegantly?
17:38:15 <cathper_> I have Data.List.intersect, but that's for the intersection of two lists.
17:39:06 <Draconx|Laptop> cathper_, so do foldr1 intersect.
17:40:00 <cathper_> Would I take the head out and use fol... Draconx|Laptop: I see.
17:41:45 <zachk> folds are beautiful 
17:42:06 <djahandarie> Not as beautiful as recursionEngines
17:42:12 <zachk> oh whats that 
17:42:21 <djahandarie> An inside joke
17:42:22 <aavogt> @src recursionEngine
17:42:22 <lambdabot> Source not found. I feel much better now.
17:42:36 <aavogt> @src mapReduce
17:42:37 <lambdabot> Source not found.
17:42:39 <aavogt> why?!
17:42:44 <alex404_> Is there any magic generalization of zippers to cyclic graphics, or is mathematically impossible to model cyclic graphics without state?
17:43:06 <alex404_> and by graphics I mean graphs
17:46:56 <jmcarthur> alex404_: you can always use Int as an approximation to pointers and IntMaps to look up the values they point to
17:47:43 <jmcarthur> alex404_: so the zipper would basically be some mappings along with an index to represent the location of the current hole
17:48:09 <jmcarthur> from some angles, it's a hack, but it still retains many of those nice properties of pure code
17:48:31 <alex404_> Indeed... it does look mostly like a hack...
17:48:34 <alex404_> But what would it gain you?
17:49:16 <jmcarthur> you retain referential transparency, free undo, etc.
17:49:35 <alex404_> Indeed...
17:49:55 <alex404_> I'm just building up a big neural network library
17:50:00 <jmcarthur> and IntMaps are effectively constant time lookup because Int is bounded in number of bits
17:50:02 <alex404_> My feedforward interface is really nice I think
17:50:29 <alex404_> But I'm trying to figure out the nicest way construct a recurrent network structure
17:50:55 <alex404_> Hmmm... IntMaps are smokin fast, I suppose...
17:51:00 <jmcarthur> O(log n) for n :: Int means O(32) or O(64), which is, of course, O(1)
17:51:13 <alex404_> Yar
17:51:40 <jmcarthur> "smokin fast" might be pushing it, but they are typically quite acceptable, at least for most of my purposes
17:52:06 <jmcarthur> if the structure of the graph doesn't ever change you could even use arrays instead of intmaps
17:52:22 <alex404_> Yah, the structure of the graph is fixed
17:52:26 <jmcarthur> or other collections, depending on what you're doing with them of course
17:52:41 <jmcarthur> arrays are tougher to update incrementally though
17:52:48 <alex404_> Why would I use arrays instead of vectors?
17:52:54 <jmcarthur> there's DiffArray, but it is known for heavy constant factors
17:53:02 <jmcarthur> arrays and vectors are essentially the same, afaik
17:53:08 <alex404_> fair enough
17:53:20 <djahandarie> Is it really just constant factors in DiffArray?
17:53:32 <jmcarthur> djahandarie: the MVars i think are the problem
17:53:54 <jmcarthur> djahandarie: okay, it's only constant factor issues when you never use old versions of the arrays
17:54:03 <jmcarthur> otherwise it becomes an even bigger problem
17:54:36 <jmcarthur> alex404_: they have different interfaces, of course
17:55:21 <jmcarthur> that is, if you are talking about the array package vs. the vector package
17:55:28 <alex404_> Yah
17:56:24 <jmcarthur> alex404_: alpounet has an interest in neural nets, authored HNN, and i think (?) is continuing to work on it. you may want to hit him up with some of these questions about implementation
17:57:15 <alex404_> jmcarthur: Oh? It looked fairly dead. Would you know the best way to get in touch with him?
17:57:23 <alpounet> highlight me
17:57:27 <alpounet> i'm often around :p
17:57:38 <alpounet> alex404_, interested in implementing neural networks in haskell ?
17:57:46 <alex404_> Hah
17:58:23 <alex404_> alpounet: I've been toying with the idea of developing a general bayesian machine learning packaegf
17:58:32 <alex404_> alex404_: And am starting with neural nets
17:58:37 <alpounet> ok
17:58:39 <alpounet> here is the thing
17:58:44 <alpounet> when i started learning haskell
17:58:55 <alpounet> i experimented implementing a minimal neural network library
17:58:58 <alpounet> let's be clear
17:59:00 <alex404_> The HNN
17:59:02 <alpounet> the version on hackage just sucks
17:59:09 <alpounet> however
17:59:34 <alpounet> it was more of a "hey, there's something we can work on and improve" release
17:59:42 <alpounet> than a serious release
17:59:51 <alpounet> a few people chimed in right after
17:59:59 <alpounet> most just went away a bit later
18:00:08 <alex404_> Right
18:00:15 <alpounet> but there's one person still around
18:00:23 <alpounet> (tomberek on IRC)
18:00:55 <alpounet> and we talked *a lot* about the new version
18:00:56 <alpounet> our conclusion was that we needed a better graph library than FGL currently is
18:01:13 <alpounet> so he's currently working on a rewrite of FGL
18:01:27 <alpounet> and i'm quite busy with my studies
18:01:30 <alex404_> Ahh
18:01:34 <alpounet> so until we have a good rewrite of FGL
18:01:34 <djahandarie> There seems to be a lot of movement on the graph library front these days
18:01:45 <alpounet> the project is somehow "paused"
18:01:48 <alpounet> but not dead
18:01:48 <djahandarie> ivanm was talking about one the other day
18:02:05 <alpounet> particularly not if you're interested in joining the effort alex404_ :)
18:02:12 <alpounet> djahandarie, the problem is
18:02:21 <alpounet> nobody is giving feedback to Thomas
18:02:36 <alpounet> (except Ivan and I, mostly)
18:02:42 <alpounet> me*
18:02:50 <alex404_> Definitely. I have a long term interest in developing this. Otherwise I'll be stuck using python and matlab for the rest of my life.
18:03:21 <alpounet> yeah
18:03:25 <djahandarie> Hmm
18:03:45 <alpounet> alex404_, would you be interested in checking out Thomas work on the graph library ?
18:04:05 <alex404_> alpounet: Sure.
18:04:25 <nus> @seen tomberek
18:04:25 <lambdabot> Unknown command, try @list
18:04:25 <preflex>  tomberek was last seen on #haskell 15 days, 16 hours, 22 minutes and 52 seconds ago, saying: erg, sorry
18:04:33 <alex404_> heh
18:04:36 <djahandarie> Would be interesting to see Haskellers used to coordinate this more publically
18:04:49 <djahandarie> ...at least get a link to the source repo on there or something :P
18:05:21 <alpounet> alex404_, http://hpaste.org/41231/basic
18:05:39 <alpounet> alex404_, you might just want to give me your email
18:05:52 <alpounet> i'll email both of you, saying that you're interested in these stuffs 
18:06:04 <alpounet> it'll probably motivate him for setting up a public repo
18:06:05 <alpounet> etc
18:06:10 <alpounet> and he's preparing a post for -cafe
18:09:57 <alex404_> alpounet: So why is a well developed graph library necessary anyway? For feedforward nets anyway I can't imagine them being necessary. I've been putting together an RBM package and I can't see how graphs would be a step above mere vectors...
18:11:09 <dobblego> data TreeM m a = NodeM (m a) [TreeM (m a)] -- does this make sense?
18:12:11 <alpounet> alex404_, the thing is that Thomas is willing to extend hnn
18:12:13 <aavogt> that seems about the same as    Data.Tree.Tree (m a)
18:12:23 <dobblego> ah yeah it is
18:12:37 <alpounet> alex404_, no more restriction to feed forward NNs
18:12:42 <aavogt> though maybe you'd need to use the data like that if you have a problem with -XFlexibleInstances
18:12:45 <soulthief> 04http://www.anno1777.com/index.php?i=13864 economic strategy game... in game money= real money... just try it
18:12:47 <dobblego> perhaps I just need newtype TreeT m a = TreeT (Tree (m a))
18:12:55 --- mode: ChanServ set +o dobblego
18:13:03 --- mode: dobblego set +b *!*soulthief@82.77.166.*
18:13:20 <alex404_> alpounet: Indeed.
18:13:24 <alpounet> alex404_, actually
18:13:34 <alpounet> we tried to discuss some quite advanced models
18:13:51 <alpounet> like neural networks with real time feedbacks
18:13:53 <alpounet> kohonen maps
18:13:54 <alpounet> etc
18:14:05 <alex404_> Cool
18:14:08 <cads> hey, how do we construct a monoid in the category of endofunctors?
18:14:09 <alex404_> That interested me as well
18:14:52 <cads> we must have an associative operation . with and identity, yees?
18:14:59 <cads> an*
18:15:10 <Cale> cads: Well, a monoid object is an object M (a functor, in this case) together with arrows eta: 1 -> M, and mu: M . M -> M
18:15:28 <Cale> In this case the monoidal operation for our category is composition
18:15:32 <alpounet> alex404_, before deciding we needed a better graph library
18:15:38 <alex404_> alpounet: Yah, I can see that.
18:15:40 <alpounet> we were at this point: http://trac.haskell.org/HNN/wiki/CodeDraft
18:15:43 <Cale> and the identity for that monoidal operation on objects is the identity functor
18:16:01 <Cale> and our arrows eta and mu are natural transformations
18:16:03 <djahandarie> (The morphisms being natural transformation)
18:16:09 <djahandarie> sigh
18:16:24 <alex404_> alpounet: Cool, I'll have a look.
18:16:24 <cads> Cale, thanks!
18:16:29 <alpounet> alex404_, and you may alsa want to browse the (few) messages on the mailing list: http://projects.haskell.org/pipermail/hnn/
18:17:05 <cads> that makes perfect sense, even
18:18:22 <cads> I will see if I can construct a monoid object in category set!
18:18:40 <djahandarie> I hope you can. :P
18:19:00 <cads> heh, no hints
18:19:31 <alex404_> alpounet: I've been brainstorming about a few things as well. I have a few thoughts about Bayesian typeclass which I think could be pretty fun. You know, models will be instances, will implement the bayes operator, and may come with some more toys attached.
18:20:51 <alex404_> alpounet: I've been discussing a robotics project with my supervisor. A clean interface for generative models is kind of my main interest.
18:21:33 <alpounet> alex404_, great
18:21:41 <Rotaerk_> is it pathetic that the primary reason I picked F# over haskell was that I didn't feel like learning graphics programming with GL
18:21:50 <alpounet> feel free to answer the email, explaining how you would see these stuffs, etc
18:22:57 <alex404_> alpounet: Cool. I should probably head to bed now anyway. I'll look over the links you sent me and get back to you.
18:24:19 <alpounet> sure
18:24:22 <alpounet> hey tomberek :)
18:24:27 <tomberek> good day
18:24:56 <alpounet> alex404_ is the new person on board
18:25:09 <alex404_> Oh, hey. That's funny.
18:25:10 <tomberek> not bad
18:25:38 <alpounet> haha
18:25:59 <tomberek> i hear Alp told you a bit of where we are.... and it's not very far
18:26:40 <alex404_> Yah.
18:26:55 <alex404_> FGL would appear to be the bottleneck.
18:27:18 <tomberek> yes, that's what motivated me to move a step up in abstraction and try to work on FGL
18:28:09 <tomberek> honestly, I then ran into other bottlenecks and would like to work on a containers API, but this never-ending chain of moving up abstractions to fix everything is beyond my abilities
18:28:28 <tomberek> so for now I decided to stop at graphs and work on that
18:28:36 <alex404_> Heh
18:28:58 <nus> tomberek, weren't you playing with comonads?
18:29:17 <tomberek> nus: yes, neural network evaluation as a comonad
18:29:37 <nus> tomberek, found them too abstract?
18:29:38 <cads> hey, in haskell, do we have any bifunctors?
18:30:08 <Cale> cads: Sure, lots of them, but there's no standard typeclass for them (except if you count category-extras)
18:30:25 <Rotaerk> hmm is readability the only advantage of point-free style
18:30:30 <tomberek> nus: i liked it, got the idea from http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
18:30:39 <Rotaerk> and thus if it actually makes the code longer, it's no longer worth it
18:30:56 <cads> Rotaerk, algebraic manipulation of the terms can be easier
18:31:09 <tomberek> nus: I just didn't know (probably still) if it was any better than any other method
18:31:13 <alex404_> tomberek: Anyway, I should call it a night, but I'd be up for having a discussion to get me up to speed
18:31:23 <Rotaerk> cads, terms? algebraic manipulation?
18:31:24 <tomberek> alex404_ that would be great
18:31:33 <Rotaerk> what're the terms of a function
18:31:51 <tomberek> nus: do you know a lot about them?
18:32:25 <tomberek> nus: they seem to follow the generate then prune concept, which with laziness should end up well
18:32:25 <cads> Rotaerk, yeah, if you're deriving a program using higher order functions, you can use the algebra of the functions you're working with to write programs
18:32:32 <nus> tomberek, no, and I believe you've already found edwardk (-:
18:32:35 <cads> rather, it becomes easier to do this
18:32:41 <alex404_> Cool. G'night folks.
18:32:55 <tomberek> nus: yes, and he presented a problem: an empty graph is not a comonad
18:33:07 <alpounet> alex404_, as stated in the email, we can just arrange an IRC "meeting" some time soon
18:33:15 <tomberek> nus: so from a categorical point of view, we have a problem
18:33:17 <Rotaerk> sounds over my head
18:33:21 <Rotaerk> "deriving" a program..
18:35:04 <cads> Rotaerk, so you have a code written with two mappings composed in line, like this:  (map f)  .  (map g)
18:35:16 <Rotaerk> k
18:35:26 <tomberek> nus: I think we can work around that, but i needed some Category-hackery from edwardk, but he is a busy man
18:35:27 <cads> you can simplify this code into just map (f.g)
18:35:42 <Rotaerk> ah..
18:36:08 <Rotaerk> cads, and how does point free style help you?
18:36:42 <cads> you've now brought f and g together in the code - if you know more about them, you might write a simpler function h which is equivalent to f.g but is more efficient.
18:36:59 <cads> so finally it becomes just  map h.
18:37:02 <Rotaerk> I see
18:37:04 <Rotaerk> interesting
18:37:32 <cads> it basically lets you write programs like you're solving an equation from highschool
18:37:36 <ivanm> does anyone have any suggestions on how I can test if two lists are == including rotations?
18:37:45 <nus> tomberek, so.. is there any sense in talking about modelling non-graphs based neural "nets"?
18:38:14 <jmcarthur> ivanm: rotations but not general permutations?
18:38:20 <ivanm> jmcarthur: right
18:38:23 <jmcarthur> hmm
18:38:40 <ivanm> the obvious way is to perform every possible rotation and test all of them... but that's rather fugly
18:38:58 <tomberek_> sorry, internet hiccup
18:39:00 <aavogt> in principle maybe... the code won't be too bad
18:39:35 <jmcarthur> ivanm: maybe concatenate one of the lists with itself and then search for the other list inside of that using a known search algo such as boyer moore?
18:39:49 <ivanm> jmcarthur: hmmm, that's not a bad idea
18:40:01 <aavogt>  any (ys ==) (rotations xs); rotations x = zipWith (++) (inits x) (tails x) -- give or take
18:40:04 <ivanm> @hoogle [a] -> [a] -> Bool
18:40:05 <lambdabot> Data.List isInfixOf :: Eq a => [a] -> [a] -> Bool
18:40:05 <lambdabot> Data.List isPrefixOf :: Eq a => [a] -> [a] -> Bool
18:40:05 <lambdabot> Data.List isSuffixOf :: Eq a => [a] -> [a] -> Bool
18:40:19 <jmcarthur> ivanm: the every rotations version would certainly be easier
18:40:27 <ivanm> aavogt: yeah, thought of that
18:40:33 <aavogt> > inits "abc"
18:40:34 <lambdabot>   ["","a","ab","abc"]
18:40:36 <ivanm> jmcarthur: oh? why is that?
18:40:54 <Rotaerk> cads, http://rotaerk.pastebin.com/hdKn5k95  just having trouble justifying using the latter over the former
18:40:58 <jmcarthur> ivanm: because it should be easier to express using the existing functions in the standard lib i think
18:40:59 <ivanm> > zipWith (++) (inits "abc") (tails "abc")
18:41:00 <lambdabot>   ["abc","abc","abc","abc"]
18:41:05 <tomberek_> nus: what are you referring to? SOMs?
18:41:11 <Rotaerk> cads, longer, arguably harder to read (note this is F#)
18:41:11 <ivanm> jmcarthur: there's isInfixOf ;)
18:41:28 <cads> Rotaerk, honestly I don't use it too much
18:41:29 <jmcarthur> > tails $ "foo" ++ "foo"
18:41:30 <lambdabot>   ["foofoo","oofoo","ofoo","foo","oo","o",""]
18:41:34 <cads> I'm still pretty green
18:41:44 <jmcarthur> > ("off" `isPrefixOf`) . tails $ "foo" ++ "foo"
18:41:45 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
18:41:45 <lambdabot>         against inferred type...
18:41:50 <cads> also I hate having to put an uncurry in my code and have implicit pairs going aroun
18:41:52 <cads> d*
18:41:52 <jmcarthur> > any ("oof" `isPrefixOf`) . tails $ "foo" ++ "foo"
18:41:53 <lambdabot>   True
18:42:18 <jmcarthur> :t \xs ys -> any (xs `isPrefixOf`) . tails $ ys ++ ys
18:42:19 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:42:23 <Rotaerk> cads, yea the only way to really make a function point free, when one of the inputs needs to be used in multiple ways, is to tee it
18:42:25 <ivanm> jmcarthur: oh, I suppose the concatenation one could throw up false positives...
18:42:25 <aavogt> > let x = "abc" in zipWith (++) (tails x) (inits x)
18:42:26 <lambdabot>   ["abc","bca","cab","abc"]
18:42:34 <jmcarthur> ivanm: how?
18:42:36 <Rotaerk> cads, and then uncurry the function that it gets fed to
18:42:47 <ivanm> jmcarthur: "abcd" == "abc"
18:42:56 <jmcarthur> that won't be positive
18:42:56 <ivanm> where == does circular as well
18:43:12 <ivanm> I mean: rotEq "abcd" "abc"
18:43:17 <jmcarthur> ivanm: oh i see. it would work with the arguments the other way around
18:43:28 <ivanm> right, so unless you do length-based verification as well...
18:43:34 <jmcarthur> yuck :)
18:43:40 <ivanm> yup
18:44:30 <jmcarthur> :t \xs ys -> any ((xs ++ xs) `isPrefixOf`) . tails $ ys ++ ys ++ ys  -- i wonder if this ugly thing fixes that
18:44:31 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:44:34 <ivanm> aavogt: I must say, that's a rather neat way of doing all possible rotations
18:44:45 <ivanm> jmcarthur: heh, too ugly ;)
18:45:35 <aavogt> ivanm: for the string search, you could use a regex library :p
18:45:59 <aavogt> if you're going that way with things
18:46:06 <ivanm> aavogt: well, it's actually for use as an alternate equality testing for pointedlist or data-clist
18:46:15 <jmcarthur> :t \xs -> any (== xs) . liftA2 (zipWith (++)) tails inits
18:46:16 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
18:46:23 <ivanm> atm they both just do (==) `on` toList
18:46:32 <twb> How do you ask "./Setup configure" what flags it supports?
18:46:46 <jmcarthur> >let rotEq xs = any (== xs) . liftA2 (zipWith (++)) tails inits in rotEq "abcd" "abc"
18:46:48 <ivanm> twb: as in Cabal flags?
18:46:51 <twb> Yes
18:46:52 <ivanm> read the Cabal file? :p
18:46:58 <twb> Boo
18:47:00 <jmcarthur> > let rotEq xs = any (== xs) . liftA2 (zipWith (++)) tails inits in rotEq "abcd" "abc"
18:47:01 <twb> That was plan B
18:47:01 <lambdabot>   False
18:47:04 <jmcarthur> > let rotEq xs = any (== xs) . liftA2 (zipWith (++)) tails inits in rotEq "abc" "abcd"
18:47:05 <lambdabot>   False
18:47:15 <jmcarthur> > let rotEq xs = any (== xs) . liftA2 (zipWith (++)) tails inits in rotEq "bcda" "abcd"
18:47:16 <lambdabot>   True
18:47:43 <ivanm> twb: yeah, that's probably something worth a bug report (if there isn't already one) for Cabal
18:47:46 <pkrumins> Is calling hClose on a handle from accept call enough to close a network connection? 
18:47:59 <twb> I vaguely recalled there was a way to do it
18:48:07 <twb> I haven't touched anything haskelly for, like, six months
18:48:10 <ivanm> @pl \xs -> any (== xs) . liftA2 (zipWith (++)) tails inits
18:48:10 <lambdabot> (. liftA2 (zipWith (++)) tails inits) . any . (==)
18:48:12 <ivanm> twb: :o
18:48:15 <ivanm> wb then! ;)
18:48:40 <twb> Heh, I'm only issuing a RC fix for squeeze's darcs
18:49:34 <monochrom> pkrumins: in my experience yes, but I don't have proof
18:49:37 <jmcarthur> my ugly one doesn't fix it anyway, for the record
18:50:00 <djahandarie> Has alpha beta pruning been implemented anywhere?
18:50:18 <jmcarthur> djahandarie: i think there is a game tree search package on hackage, but i haven't looked at it
18:50:22 <tomberek_> djahandarie: i really hope so
18:50:37 <aavogt> @hackage game-tree
18:50:37 <lambdabot> http://hackage.haskell.org/package/game-tree
18:50:55 <jmcarthur> wow, totally idiomatic naming there
18:51:06 <djahandarie> I saw that, but it looked nasty as hell
18:51:29 <pkrumins> i can't get the closed this way
18:51:29 <pkrumins> using haskell on windows
18:51:31 <djahandarie> Was hoping for a slightly more elegant solution
18:51:48 <jmcarthur> i had started it once but ended up doing something different instead
19:05:17 <roconnor> alpha-beta pruning is one of the examples in "Why Functional Programming Matters"
19:22:16 <stepkut> I think that is a song by cake.. 'pruning in the alpha-beta parking lot...'
19:30:38 <monochrom> http://stackoverflow.com/questions/4099627/haskell-define-merge-using-mapreduce
19:31:13 <monochrom> so, he/she finds his/her way to Stack Overflow as well, and subsequently to HWN
19:31:45 <monochrom> to qualify for mention in HWN, it has to be a "top stackoverflow question"
19:32:18 <monochrom> if that qualifies as a "top stackoverflow question", I am glad I am absent from stackoverflow
19:37:58 <djahandarie> lol
19:41:00 <ymasory> silly question ...er analogy. in scala a function body is a series of statements. in haskell a function body is ...?
19:41:04 <ymasory> a single expression?
19:41:12 <monochrom> yes
19:41:21 <ymasory> thank you
19:41:37 <monochrom> an expression is a tree of more expressions. this is richer than merely series.
19:44:52 <roconnor> in Haskell a do block is a series of "statements"
19:45:49 <djahandarie> Which desugar to an expression
19:45:56 <Philippa> we also call constructs like "case" and "let" statements sometimes, but grammatically they're still expressions
19:46:29 <djahandarie> It's true the question was a syntactic one, but I don't think the syntax was really the concern...
19:46:41 <djahandarie> More like, philosophy ;)
19:47:04 <Philippa> eh, both. That's the best and worst thing about formal systems
19:49:07 <djahandarie> Unrelated... I sometimes still have the urge to line things up in columns in my code, but I know it just leads to a dark pit of me never wanting to touch stuff because it looks so nice
19:50:08 <Philippa> heh
19:50:57 <Philippa> I have slightly idiosyncratic layout style that leads to that in places, but that's not really the same - I have my editor set to use 1 space for indent/dedent though, and just bang the key however many times I need
19:54:53 <Philippa> btw: half-formed-but-developable proposal to do something sane about records on -cafe. I happened to be the idiot who posted it, but don't let that stop you :-)
19:56:10 <developernotes> I just installed HUnit from cabal, when I launch ghci, I tried to load it but I get the following output: http://pastie.org/1291765  Any ideas?
19:56:51 <ymasory> can i use guards anywhere except directly on the parameters of a function?
19:59:49 <Funktorsalat> is it faster to use ScopedTypeVariables for polymorphic let-bindings than make the let-binding fully polymorphic? the disadvantage with STVs is that you get 'forall's cluttering up the haddock ;)
20:00:09 <Funktorsalat> say, when fixing stuff to work with ghc 7
20:01:06 <roconnor> Philippa: does your proposal involve lenses
20:02:08 <ricree> can someone suggest a source that discusses data types that have named properties?  They show up in libraries sometimes (System.Process), for example, but most of the guides I've seen to custom types don't seem to discuss them
20:03:03 <Philippa> heh, no - but you could fit them into it reasonably, I suspect? And knowing my luck, having said that it probably turns out to constitute syntax for a lens
20:03:04 <Axman6> ricree: they're called records, that should help you google for better material
20:03:27 <developernotes> I just installed HUnit from cabal, when I launch ghci, I tried to load it but I get the following output: http://pastie.org/1291765  Any ideas?
20:03:37 <ricree> Axman6:  thank you.  
20:04:22 <Philippa> I should disappear shortly btw, it's 4am and I don't want to end up on US east coast time again. If anyone really needs to prod me, you can PM me - but preferably, ask on -cafe? Getting some traffic there should help get more people reading
20:10:09 <Rotaerk> this function's so tangled.. not sure if I can make it pointfree..
20:10:19 <Rotaerk> but I'm gonna try !
20:10:47 <ivanm> developernotes: because there is no "HUnit" module
20:10:52 <ivanm> @hackage HUnit
20:10:52 <lambdabot> http://hackage.haskell.org/package/HUnit
20:10:58 <ivanm> see the module listing there ^^
20:10:59 <int80_h> I'm getting a type match error here. How can I make it right? map (takeWhile (/= '&')) "startRow=0&pageSize=25&sortReverse=true&sortName=webForward.name"
20:11:19 <ivanm> Rotaerk: _any_ function can become pointfree; it will probably be ugly, but anyway...
20:11:36 <Rotaerk> hmm
20:11:38 <ivanm> int80_h: I think you want repeated breaks
20:11:41 <developernotes> ivanm: Ah, I misunderstood a module for something I was installing through cabal.  Thanks
20:11:47 <ivanm> Rotaerk: that's the point of @pl
20:11:49 <int80_h> map (takeWhile (/= '&')) "startRow=0&pageSize=25&sortReverse=true&sortName=webForward.name"
20:11:53 <int80_h> oops sorry
20:12:08 <ivanm> int80_h: yes, map (takeWhile (/= '&')) is :: [String] -> [String]
20:12:12 <ivanm> int80_h: see the split package
20:12:18 <ivanm> I think it has what you seem to want
20:12:53 <int80_h> ivanm : yeah I think that sounds better. I'm trying to get String -> [String] 
20:13:08 <int80_h> and I'll move on from there but one step at a time
20:13:22 <int80_h> @hoogle split
20:13:22 <lambdabot> Data.ByteString split :: Word8 -> ByteString -> [ByteString]
20:13:23 <lambdabot> Data.IntMap split :: Key -> IntMap a -> (IntMap a, IntMap a)
20:13:23 <lambdabot> Data.IntSet split :: Int -> IntSet -> (IntSet, IntSet)
20:13:39 <ivanm> int80_h: http://hackage.haskell.org/packages/archive/split/0.1.2.1/doc/html/Data-List-Split.html#v:splitOn
20:13:54 <developernotes> ivanm: Thanks, I take it this doc. is just out of date due to it referencing "import HUnit"? http://hunit.sourceforge.net/HUnit-1.0/Guide.html
20:13:55 <Eduard_Munteanu> o/
20:14:21 <ivanm> developernotes: probably
20:14:25 <ivanm> hey Eduard_Munteanu 
20:14:33 <developernotes> ivanm: thanks for your help.
20:14:38 <aavogt> > iterate (break (== '&') . drop 1 . snd) ([],"12&32&32")
20:14:38 <ivanm> np
20:14:38 <lambdabot>   [("","12&32&32"),("2","&32&32"),("32","&32"),("32",""),("",""),("",""),("",...
20:14:56 <ivanm> aavogt: not quite right
20:15:04 <ivanm> I wonder if an unfoldr would work better there than iterate
20:15:16 <ivanm> though I generally did explicit recursion
20:15:44 <int80_h> splitON is exactly what I want. Parsec was like trying to boil an egg with a nuclear reactor
20:15:52 <aavogt> yeah, unfoldr is about right
20:15:53 <Eduard_Munteanu> Damn, what does TAPL mean by |- ? I kinda skipped over the implementation chapters and I can't find the definition for that in the index or the typographical conventions.
20:16:26 <new11> pl f x y z = (x y) (x z)
20:16:28 <aavogt> turnstiles in #haskell now?
20:17:01 <roconnor> |-
20:17:10 <ivanm>  -|
20:17:10 <aavogt> Eduard_Munteanu: http://en.wikipedia.org/wiki/Turnstile_(symbol)
20:17:18 <new11> @pl f x y z = (x y) (x z)
20:17:18 <lambdabot> f = flip =<< ((.) .)
20:17:19 <Eduard_Munteanu> Thanks.
20:17:23 <roconnor> ivanm: adjoin this!!
20:17:29 <roconnor> *adjoint
20:18:19 <new11> @pl q5 x = zipWith (\x y -> (map ((flip (!!)) x) y)) [0..length (head x)-1] (repeat x)
20:18:20 <lambdabot> q5 = ap (zipWith (const (map =<< flip (!!))) . enumFromTo 0 . subtract 1 . length . head) repeat
20:19:35 <new11> @pl q1 x = zipWith (flip (foldr (:))) ((foldr ((:).(((foldl (flip (:)) [])))) []) x) x
20:19:35 <lambdabot> q1 = zipWith (flip (foldr (:))) =<< foldr ((:) . foldl (flip (:)) []) []
20:23:16 <Eduard_Munteanu> Ah, so '|-' isn't that much different from ----------, only it's used to express typing rules?
20:24:39 <Eduard_Munteanu> I don't know why, TAPL assumes some familiarity with '|-', it's strange.
20:25:11 <pumpkin_> entails
20:25:15 <pumpkin_> or something like that
20:25:33 <pumpkin_> http://en.wikipedia.org/wiki/Turnstile_(symbol)
20:25:48 <Eduard_Munteanu> pumpkin_: yeah, aavogt just linked me to that.
20:25:55 <pumpkin_> oh
20:25:57 <pumpkin_> :)
20:26:02 <djahandarie> pumpkin_, Vec's last and init would be impossible to implement without having access to doing stuff on the kind-level, right?
20:26:05 <pumpkin_> that'll teach me to not read
20:26:17 <Eduard_Munteanu> Is there any significant difference to '---------------'
20:26:18 <pumpkin_> djahandarie: why?
20:26:22 <Eduard_Munteanu> (the horizontal line)
20:26:51 <djahandarie> pumpkin_, not sure, but this naive implementation doesn't seem to be doing it for me
20:27:19 <djahandarie> I think if I were doing it in a dependently typed language I could make it work by using Vec one level higher
20:27:23 <fengshaun> is it conventional to bind pure values to names using <- and return like this: name <- return "mystring" ?
20:27:36 <fengshaun> or is it more conventional to use let name = "mystring" ?
20:27:51 <Eduard_Munteanu> fengshaun: the latter
20:28:05 <pumpkin_> djahandarie: I don't see the issue
20:28:10 <fengshaun> Eduard_Munteanu, thanks
20:28:34 <djahandarie> Maybe I'm just missing something stupid
20:28:56 <pumpkin_> just a sec
20:30:32 <djahandarie> I imagine I could do this with an unsafeCoerce pretty obviously
20:31:03 <djahandarie> I imagine I could do this with an unsafeCoerce pretty obviously
20:31:04 <pumpkin_> nah, no need
20:31:06 <djahandarie> Whoops
20:31:22 <pumpkin_> http://hpaste.org/41400/last_and_init
20:31:39 <pumpkin_> the trick is just remembering to pattern match as much as you can
20:31:51 <djahandarie> Oh
20:31:56 <pumpkin_> since otherwise it doesn't know enough
20:31:56 <djahandarie> lol...
20:32:02 <pumpkin_> you'd have the same issue in agda
20:32:13 <pumpkin_> if you pattern match on Nil and then xs
20:32:23 <pumpkin_> it's not smart enough to see that if Nil didn't match, it _must_ be Cons
20:32:24 <djahandarie> Why is that?
20:32:27 <pumpkin_> (in agda, at least)
20:32:52 <pumpkin_> I guess it's not common enough to pattern match on all constructors but one and then to leave the last one implicitly matched
20:32:58 <pumpkin_> without acutally using any bound fields
20:33:38 <djahandarie> Seems like a shitty reason
20:33:39 <djahandarie> :P
20:33:49 <pumpkin_> well, consider that they'd need to explicitly check for that case
20:33:59 <pumpkin_> it's not something that happens magically given the algorithms behind it
20:35:16 <pumpkin_> you don't really _need_ DTs for most of this Vec stuff
20:35:33 <pumpkin_> but it gets awfully painful sometimes
20:38:36 <int80_h> This gets a type error, break isEqualsSign "startRow=0"
20:39:00 <monochrom> @type break
20:39:01 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:39:09 <int80_h> but I examined the type for break isEqualsSign and "startRow=0" and it all seems to match up
20:39:39 <int80_h> the type for break is break :: (a -> Bool) -> [a] -> ([a], [a])
20:39:49 <int80_h> so let's check the next function
20:39:53 <int80_h> it's type is
20:40:07 <int80_h> isEqualsSign :: [Char] -> Bool
20:40:14 <monochrom> Char -> Bool
20:40:22 <int80_h> fine, it expects a [Char], so what's the type for the string?
20:40:23 <monochrom> a = Char, [a] = String
20:40:41 <int80_h> "startRow=0" :: [Char]
20:40:57 <int80_h> don't the type match up though?
20:41:07 <monochrom> (Char -> Bool) -> String -> (String,String)
20:41:45 <int80_h> monochrom I'm missing your point. Sorry it's a little late here.
20:41:58 <monochrom> isEqualsSign :: Char -> Bool
20:42:07 <djahandarie> pumpkin_, hm, the other thing I'm having a problem with is reverse
20:42:15 <int80_h> it's [Char] -> Bool according to ghci
20:42:33 <monochrom> then you shall rewrite isEqualsSign until it is Char -> Bool
20:42:47 <int80_h> fine, I will go do that
20:43:17 <djahandarie> At least implementing it with foldl that is
20:43:42 <pumpkin_> djahandarie: that's tricky
20:43:50 <pumpkin_> I think I had one in my SHE Vec
20:44:09 <pumpkin_> http://hpaste.org/8890
20:44:16 <pumpkin_> it's not straightforward though
20:44:25 <djahandarie> Oh, nice
20:44:39 <djahandarie> Hmmm
20:45:03 <Dan_> Okay guys I just can't get this working. I've got a program reading in a file: 
20:45:05 <Dan_> http://hpaste.org/41401/tracks
20:45:06 <Dan_> and I need the function 
20:45:08 <Dan_> isOval :: [[Int]] -> Bool
20:45:09 <Dan_> to return true if there are exactly 4 0's at the beginning of each of the three lists. How do I go about doing this?
20:45:25 <dobblego> Dan_, is this for homework?
20:45:33 <Dan_> absolutely
20:45:53 <Dan_> and haskell is like nothing I've ever programmed before
20:45:58 <int80_h> @src elem
20:45:58 <lambdabot> elem x    =  any (== x)
20:46:00 <dobblego> Dan_, check out the filter function, take function and the null function
20:46:13 <djahandarie> dobblego, you never deopped btw :P
20:46:18 <dobblego> djahandarie, ta
20:46:21 --- mode: dobblego set -o dobblego
20:46:47 <Dan_> do i need to make a lot of functions, or can I do most of this in the same function?
20:47:05 <monochrom> you should prefer a lot of functions, at least as a draft
20:47:09 <Dan_> okay
20:47:50 <int80_h> that sounds like a job for let/in
20:47:55 <monochrom> haskell or not, you must learn how to decompose a big problem into several small problems properly.
20:48:17 <aavogt> int80_h: where? :p
20:48:34 <Dan_> and I can use head to get the elements at the beginning of each list, right?
20:48:59 <djahandarie> Dan_, someone actually wrote the whole function for you when you asked the question last time
20:49:02 <djahandarie> I think you missed it
20:49:06 <monochrom> in the final code, you are welcome to combine things and mix them up and obfuscate as you see fit. but your thought process should not be mixed up.
20:49:34 <Dan_> well yes I know
20:49:36 <monochrom> head only gives you 1 element. you want 4.
20:50:13 <Dan_> sorry I just started haskell not too many ours ago
20:50:41 <int80_h> map!
20:51:15 <int80_h> @src odd
20:51:15 <lambdabot> odd = not . even
20:51:27 <int80_h> @src even
20:51:27 <lambdabot> even n = n `rem` 2 == 0
20:51:38 <int80_h> > :t even
20:51:39 <lambdabot>   <no location info>: parse error on input `:'
20:51:45 <int80_h> bah
20:51:49 <int80_h> :t even
20:51:50 <lambdabot> forall a. (Integral a) => a -> Bool
20:51:54 <monochrom> then again, if you plan to use head 4 times, I have no objection
20:53:44 <int80_h> monochrom : I fail to see why this gives the type signature [Char] -> Bool "> isEqualsSign c = c == "="
20:54:04 <monochrom> "=" is [Char] not Char. '=' is Char.
20:54:15 <monochrom> @type ("=", '=')
20:54:16 <lambdabot> ([Char], Char)
20:54:26 <Dan_> Okay I think I'm getting somewhere thank you very much
20:54:27 <int80_h> I think I'm following the model of functions like even, or isLineTerminator from RWH
20:54:47 <int80_h> ack!
20:59:10 <int80_h> break isEqualsSign "startRow=0" gives me ("startRow","=0"). I know I can use drop to get rid of the =, is there a more efficient way?
21:00:34 <monochrom> one way is to write one yourself. (I did.) another way is to use http://hackage.haskell.org/package/split
21:02:49 <int80_h> I could write it, I'd use drop. But I'll check out split. I'm trying to keep my code a readable as possible
21:03:24 <dmead> @hoogle splitby
21:03:24 <lambdabot> No results found
21:03:30 <dmead> :t splitBy
21:03:31 <lambdabot> Not in scope: `splitBy'
21:03:33 <dmead> gah
21:03:37 <dmead> look for splitby
21:03:39 <dmead> it's somewhere
21:03:39 <monochrom> it's an awesome library
21:03:42 <dmead> it'll let you do
21:03:55 <monochrom> @hoogle splitby
21:03:55 <lambdabot> No results found
21:03:55 <int80_h> oh wait, split returns lists. I need pairs
21:04:00 <Mitar> i have problems uncompressing latest ghc-7.0 tar.bz2s from http://www.haskell.org/ghc/dist/stable/dist/
21:04:02 <dmead> splitBy (\x -> x == "=") somelists
21:04:06 <Mitar> is this a known problem?
21:04:30 <dmead> int80_h, so get the list and then conver to tuples
21:04:40 <int80_h> trying to make [(x,y)] from [String]
21:04:59 <int80_h> yeah I can do that
21:04:59 <dmead> int80_h, you'll have to use a list as in intermediate
21:05:06 <dmead> then process the list into a list of pairs
21:05:22 <dmead> it'll be clearer, anyway
21:05:43 <int80_h> okay, I was thinking I might be getting too convoluted if I went that way, and there may be a function out there that does what I want already.
21:05:48 <int80_h> right on
21:06:09 <int80_h> s/convoluted/verbose
21:06:50 <int80_h> I'm just waiting for people to say "why didn't you just use PArsec", when I get this reviewed.
21:07:11 <dmead> int80_h, that would be ideal
21:07:20 <dmead> int80_h, but then you'd have to take the trouble of learning parsec
21:07:31 <int80_h> it's a nuclear rector, and all I'm trying to do is boil an egg.
21:07:39 <int80_h> well, I will take that trouble
21:07:42 <dmead> yea, if you're just splitting up lines in a file
21:07:52 <dmead> parsec might be overkill
21:07:58 <int80_h> but for this project I am taking this approach "get it working, then get it working right"
21:08:26 <int80_h> I'm screen scraping and trying to get the values from name=value pairs.
21:08:46 <dmead> what does the data look like?
21:09:01 <int80_h> well I begin with an unordered html file
21:09:08 <int80_h> but I have reduced that down to this
21:09:35 <int80_h> a list of things that look like this
21:09:39 <int80_h> "startRow=0&pageSize=25&sortReverse=true&sortName=webForward.name"
21:10:08 <int80_h> I used TagSoup to get me that far, plus filter and dropWhile
21:10:43 <monochrom> I wrote 10 lines of javascript for that :)
21:11:00 <int80_h> javascript depends upon browsers
21:11:14 <dmead> http://osdir.com/ml/glasgow-haskell-users@haskell.org/2010-11/msg00004.html
21:11:22 <dmead> steal that splitBy there
21:11:24 <dmead> and you can do
21:11:28 <int80_h> this is just one task in a list of tasks that go together to make the system.
21:12:48 <dmead> map (splitBy (\x ->( x=='='))) (splitBy (\x -> (x == '&')) list)
21:12:55 <ksf> what's the state of getting hold of mmx/sse etc insns in ghc?
21:13:08 <dmead> int80_h, capische?
21:13:31 <int80_h> yeah I dig it. I don't use lambdas much myself.
21:13:42 <dmead> learn to love it
21:13:44 <int80_h> but it makes sense here
21:14:03 <dmead> well, you don' thave to make the lambda explict
21:14:07 <dmead> you can make a partial function
21:14:11 <dmead> =='='
21:14:17 <dmead> or =='&'
21:14:17 <dmead> etc
21:14:37 <dmead> splitBy (=='=') blah blah
21:14:44 <int80_h> thanks man :)
21:15:13 <dmead> np
21:15:44 <dmead> > (,) 1 2
21:15:45 <lambdabot>   (1,2)
21:15:47 <dmead> ah yea
21:15:53 <dmead> so you'll get a list of lists from that
21:16:00 <danharaj> is there a typeclass for a functor that preserves cartesian product?
21:16:02 <dmead> and you'll have to map (,) over them to get the tuples
21:16:23 <dmead> > (1,) 1
21:16:24 <lambdabot>   <no location info>: parse error on input `)'
21:16:26 <dmead> hmm
21:16:30 <dmead> i thought that was a new feature
21:17:07 <ymasory> am i correct in assuming foldl is not implemented in haskell?
21:17:16 <monochrom> not correct
21:17:16 <danharaj> you are incorrect
21:17:28 <ymasory> bummer
21:17:35 <ymasory> how would you do it without a loop?
21:17:46 <ymasory> pattern matching ...
21:17:54 <monochrom> @src foldl
21:17:54 <lambdabot> foldl f z []     = z
21:17:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
21:18:00 <monochrom> do you accept that?
21:18:04 <danharaj> @src foldr
21:18:04 <lambdabot> foldr f z []     = z
21:18:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
21:18:07 <ymasory> yeah saw that coming :)
21:18:29 <monochrom> I'm just too lazy to write it myself.
21:19:02 <ymasory> are there any common haskell functions that can't be written in haskell?
21:19:17 <danharaj> It depends on what you mean by common.
21:19:29 <danharaj> @src seq
21:19:29 <lambdabot> Source not found. You type like i drive.
21:19:31 <dmead> stuff that addresses the runtime system isn't written in haskell
21:19:38 <dmead> so theres that..
21:19:52 <danharaj> IO functions
21:19:53 <danharaj> etc.
21:19:55 <ymasory> gotcha thanks
21:20:11 <danharaj> basically the things that aren't written in a language generally
21:20:16 <ymasory> nothing regarding the lack of control structures though
21:20:18 <monochrom> seq can't be written in haskell
21:20:28 <ymasory> since they can all be done with pattern matching and recursion
21:20:33 <danharaj> You can embed any control structure in haskell
21:20:42 <danharaj> you can also embed any control structure in C
21:20:44 <danharaj> etc.
21:20:52 <danharaj> Whether it is *easy* is another question :p
21:21:10 <monochrom> more precisely, seq can't be written in (haskell 2010 minus seq)
21:21:21 <dmead> why can't it?
21:21:23 <dmead> que?
21:21:32 <dmead> :t seq
21:21:32 <lambdabot> forall a t. a -> t -> t
21:21:44 <danharaj> because seq's affect is semantic but not syntactic
21:21:49 <danharaj> (to be a pithy dick)
21:22:11 <danharaj> you can't write its effect as a lambda because it affects evaluation, which is not reflected in the language.
21:22:19 <danharaj> evaluation strategy*
21:22:50 <dmead> ah
21:23:19 <dmead> but you could write seq in a lisp or something
21:23:38 <danharaj> lisp is eager so it wouldn't have any effect
21:23:53 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1260006.2
21:24:36 <monochrom> "As a consequence, ⊥ is not the same as \x -> ⊥, since seq can be used to distinguish them."
21:25:08 <djahandarie> pumpkin_, how do I tell Haskell that Plus m (S n) is the same as Plus (S m) n
21:25:12 <koninkje> In theory you could try (\a t -> case a of _ -> t), but haskell
21:25:22 <koninkje> 's smart enough to be lazy about the case
21:25:28 <monochrom> (haskell 2010 minus seq) cannot distinguish them, (haskell 2010) can, so seq cannot be written in (haskell 2010 minus seq).
21:29:00 <monochrom> "case v of { _ -> e; _ -> e′ } = e" so (\a t -> case a of _ -> t) = (\a t -> t).  http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-610003.17.3
21:29:16 <ManateeAuthor> Say hello from manatee
21:29:29 <monochrom> ahoy matey
21:29:35 <jmcarthur> this is a mind exercise i've been through before, but i don't remember the result. wouldn't this also allow us to distinguish \x -> _|_ and _|_?   data Seq a b = Seq !a b ; seq x y = case Seq x y of Seq _ y -> y
21:29:59 <jmcarthur> that's actually wrong...
21:30:09 <monochrom> oh dart, I have completely forgotten "!"!
21:30:22 <jmcarthur> i think
21:30:45 <monochrom> I agree with your approach. I am screwed.
21:33:13 <jmcarthur> i guess it doesn't really matter whether the second element under the Seq constructor is lazy or strict in this case, so i think it's correct
21:33:23 <jmcarthur> although perhaps it would be cleaner for it to just be strict
21:33:38 <ksf> @hoogle CSize
21:33:38 <lambdabot> Foreign.C.Types data CSize
21:33:53 <ksf> @hoogle COfs
21:33:53 <lambdabot> No results found
21:34:04 <jmcarthur> because if a "seq a b" expression is forced then b will be forced anyway
21:34:20 <ksf> CPtrdiff?
21:37:11 <monochrom> haskell 2010 report on "!": "Translation: .... $! if s_i is of the form !t_i"
21:39:37 <monochrom> more concretely, Seq x y is translated to (\x1 x2 -> (Seq $! x1) $ x2) x y
21:40:52 <jmcarthur> makes sense
21:41:24 <jmcarthur> i'm personally a fan of the old way of doing seq: a type class
21:41:39 <jmcarthur> i think people just hated having to put it in type signatures though
21:42:41 <aefjt> @src seq
21:42:42 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
21:42:52 <jmcarthur> i think (but am not sure) that in those days there weren't strictness annotations either, so \x -> _|_ wasn't actually distinguishable from _|_
21:43:04 <jmcarthur> because the type class couldn't be instantiated for functions
21:43:25 <jmcarthur> or at least not in a way that met its specification...
21:45:19 <jmcarthur> now, if seq evaluated expressions all the way to their normal forms then we would also be okay :)
21:45:27 <jmcarthur> actually.... would HNF be enough?
21:48:25 <aefjt> Isn't that called deepseq?
21:49:47 <jmcarthur> i don't think deepseq evaluates under lambdas, aefjt 
21:50:18 <Eduard_Munteanu> @src deepSeq
21:50:18 <lambdabot> Source not found. My pet ferret can type better than you!
21:50:22 <jmcarthur> :t deepSeq
21:50:23 <lambdabot> Not in scope: `deepSeq'
21:50:36 <new11> if evens n = [x | x <- [1..n], even x] how do I prove that "evens n" generates all even numbers between 1 and n?
21:50:53 <aefjt> I'm not sure what it would mean to evaluate under a lambda
21:51:20 <aefjt> You want something that reduces closures as well?
21:51:21 <Eduard_Munteanu> new11: I'd do so by contradiction.
21:51:30 <jmcarthur> aefjt: it would mean that \x -> 1+2  => \x -> 3
21:52:11 <aefjt> Well, that sounds like an overly broad way to define _|_.
21:52:12 <Eduard_Munteanu> new11: uhm, rather unfold the definitions
21:52:23 <new11> Eduard_Munteanu: thanks, but how do I handle the list monad in it?
21:52:25 <jmcarthur> aefjt: hmm?
21:52:27 <Axman6> new11: well, [1..n] produces all numbers between 1 and n, and the predicate even x says that only even numbers make it into the result?
21:52:33 <jmcarthur> i wasn't intending to define _|_...
21:52:47 <Eduard_Munteanu> new11: do you think you should go that far?
21:53:26 <aefjt> jmcarthur: why do you want a seq that does that?
21:53:45 <aefjt> (Eg. if there is an alternative formal basis for this sort of thing)
21:53:50 <new11> Eduard_Munteanu: actually yes, and here I am just wondering how this can be done?
21:54:06 <jmcarthur> aefjt: i didn't say i did. i was just saying essentially that if seq evaluated under lambdas then \x -> _|_ would be indistinguishable from _|_
21:54:32 <new11> Eduard_Munteanu: actually no, but here I am just wondering how this can be done?
21:54:42 <jmcarthur> aefjt: and i was questioning whether NF was necessary for that of if HNF was sufficient (i suspect the latter now)
21:54:46 <jmcarthur> *or if
21:56:00 <Eduard_Munteanu> new11: I'm not familiar with the formal desugaring of those comprehensions, though it most likely expands to a chaining of lambdas and maps.
21:56:11 <Eduard_Munteanu> Lemme look...
21:56:41 <aefjt> If I have this right, (const undefined) 1 = undefined in hnf, and only _|_ in nf
21:57:04 <jmcarthur> well of course for the specific case of \x -> _|_, HNF would be plenty to guarantee that we can't tell it apart from _|_. i was thinking about the possibility of more general cases, but i'm not really thinking that's sensible now
21:57:40 <jmcarthur> aefjt: i don't think that's quite right
21:58:02 <jmcarthur> aefjt: the nf and hnf are the same for that expression (1)
21:58:31 <Eduard_Munteanu> new11: http://www.haskell.org/onlinereport/exps.html#list-comprehensions
21:58:31 <jmcarthur> oh
21:58:34 <jmcarthur> i misread
21:58:49 <jmcarthur> they are both _|_
21:59:03 <new11> Eduard_Munteanu: thanks.
21:59:06 <aefjt> I see.
21:59:13 <jmcarthur> undefined == _|_
22:00:17 <jmcarthur> aefjt: (\x -> _|_) is in WHNF but not HNF or NF, is my point
22:00:43 <new11> Eduard_Munteanu: thank you very much.
22:00:55 <Eduard_Munteanu> new11: no problem.
22:04:03 <Eduard_Munteanu> BTW, is there any reason comprehensions aren't allowed anymore for other monads? Or is there an extension for that?
22:04:31 <aefjt> Could I have an example of a form that is HNF but not NF?
22:05:32 <Axman6> Just (\x -> y)?
22:05:54 <c_wraith> that's not a good example.
22:06:10 <Axman6> well, i wasn't sure if it was a correct efample at all :)
22:06:12 <c_wraith> that is normal form, specifically
22:06:47 <c_wraith> something that's HNF but not NF would be: 5:undefined
22:07:24 <c_wraith> the top-level constructor, : is evaluated
22:07:32 <c_wraith> its first argument, the 5, is also evaluated
22:07:46 <c_wraith> But the second argument to : is not evaluated, so it's not in normal form
22:08:02 <c_wraith> But the top-level constructor is, so it's in head-normal form
22:10:16 <aefjt> c_wraith: what about undefined:[]?
22:10:29 <c_wraith> yes, that is another example
22:10:37 <c_wraith> even undefined:undefined
22:10:47 <c_wraith> Or Just undefined
22:11:12 <jmcarthur> (5 : 1+2) as well. _|_ doesn't have to appear in the term for it to not be in NF
22:11:18 <c_wraith> true
22:11:27 <c_wraith> well, except that doesn't type. :P
22:11:32 <jmcarthur> *expression
22:11:37 <jmcarthur> bah
22:11:39 <jmcarthur> :P
22:11:40 <c_wraith> (1 + 2 : []) on the other hand... :)
22:11:45 <jmcarthur> [5, 1+2] is what i meant
22:12:09 <aefjt> So, as long as there is no beta at the top-level, it is in HNF
22:12:31 <jmcarthur> aefjt: HNF also can be a lambda with a HNF body
22:12:45 <c_wraith> which is where WHNF comes from.
22:12:50 <c_wraith> as it drops that case
22:12:53 <jmcarthur> (\x -> (5:undefined)) for example
22:12:58 <jmcarthur> that's in HNF
22:13:06 <Eduard_Munteanu> Well is it okay to say stuck terms are normal forms?
22:13:12 <Eduard_Munteanu> 5 : 1+3 looks like it.
22:13:28 <jmcarthur> heh
22:13:31 <c_wraith> But (\x -> 1 + 3) is not HNF.  It is WHNF.
22:13:36 <jmcarthur> i'd rather just disallow that Eduard_Munteanu 
22:13:45 <jmcarthur> ;)
22:14:17 <aefjt> My total confusion level has been conserved throughout this discussion
22:14:22 <jmcarthur> i don't think it's common to say that stuck terms are in normal form, but i'm not sure if it's incorrect either
22:14:31 <c_wraith> WHNF is what haskell's seq function guarantees
22:14:44 <jmcarthur> aefjt: here are the rules:  NF = no reduction possible
22:15:23 * Axman6 thinks out normal forms are much more useful than the DB normal forms
22:15:25 <Eduard_Munteanu> I bet you could have a default rule that evaluates previously stuck terms to 'error', which would be a normal form but more informative.
22:15:26 <Axman6> our*
22:15:37 <jmcarthur> HNF = either a constructor with possibly unevaluated terms, or a lambda where the body is in HNF
22:15:46 <c_wraith> I agree with you there, Axman6. :)
22:15:58 <jmcarthur> WHNF = either a constructor with possibly unevaluated body, or a lambda (with no condition on the body)
22:16:11 <Axman6> i hated my databases class, even if i did manage to get an HD
22:16:16 <Eduard_Munteanu> To think about it, DBs have fundeps too :)
22:16:40 <aefjt> jmcarthur: thanks, it's going down now
22:16:40 <Eduard_Munteanu> Axman6: I failed my SQL exam last year, ha!
22:16:47 <jmcarthur> i keep abusing the word "term"
22:16:52 <jmcarthur> so wrong
22:17:00 <c_wraith> yes, jmcarthur's explanation was good.
22:18:06 <c_wraith> oh, if you haven't seen the term before, the W in WHNF is weak.
22:29:48 * hackagebot http-enumerator 0.2.1.2 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.1.2 (MichaelSnoyman)
22:36:25 <lars9> what's your fav PL blog?
23:00:30 <JohnnyL> > .4
23:00:31 <lambdabot>   <no location info>: parse error on input `.'
23:01:06 <dolio> > 0x0.A
23:01:07 <lambdabot>   Not in scope: data constructor `A'
23:04:18 <yf`> @pl newConcatMap f = foldr ((++).f) []
23:04:18 <lambdabot> newConcatMap = flip foldr [] . ((++) .)
23:10:54 <zack> hello
23:11:05 <zack> having a problem in haskell of course
23:11:13 <zack> using ghci interpreter
23:11:48 <zack> let pascal xs = zipWith (+)(0:xs) (xs:0)
23:11:57 <zack> throws an error
23:12:02 <zack> something about infinite types
23:12:17 <ksf> should iteratees be allowed to insert data into the stream (to be consumed by iteratees further down the line)?
23:12:34 <ksf> I ask because I _hate_ to ignore arguments to a function.
23:12:58 <ivanm> zack: because : is used to add a value to the front of a list
23:13:04 <ivanm> you're trying to use it to append a value
23:13:07 <ksf> http://hackage.haskell.org/packages/archive/enumerator/0.4.2/doc/html/src/Data-Enumerator.html#Enumeratee does exactly that.
23:13:11 <zack> ok
23:13:16 <zack> makes sense
23:13:33 <zack> any idea how I can make the fact that my list is finite explicit?
23:13:34 <ivanm> > let pascal xs = zipWith (+) (0:xs) (xs++[0]) in pascal [1..5]
23:13:35 <lambdabot>   [1,3,5,7,9,5]
23:13:39 <zack> ok
23:13:40 <ivanm> zack: ^^
23:13:42 <zack> thanks
23:13:45 <ivanm> np
23:14:33 <zack> doing eulerproject and I thought I'd learn a new language at the same time
23:15:44 <ksf> project euler isn't about programming
23:16:03 <lars9> ksf: agree...
23:16:22 <lars9> ksf zack topcoder is better
23:16:59 <zack> as a language or a website?
23:17:21 <lars9> as practice problem set
23:17:21 <zack> rather, is it a language or a website?
23:17:24 <zack> ok
23:18:48 <ksf> nothing beats rewriting once painstakingly follow-the-type-errorsly constructed code and ending up with a thing that's five times shorter and actually understandable.
23:20:36 <gnostus> refactoring is the best part :D
23:20:58 <gnostus> turns you into a proper code snob 
23:21:00 <gnostus> :P
23:25:01 <zack> the hardest part of using this interpreter is remembering never to evaulate your infinite lists
23:26:25 <lars9> zack: ctrl-C helps
23:26:41 <zack> <-- command prompt
23:27:14 <aefjt> > let pascal xs = zipWith (+) (xs++[0]) (0:xs) in iterate pascal [1]
23:27:15 <lambdabot>   [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1]...
23:27:39 <zack> ah
23:27:42 <zack> iterate
23:27:48 <zack> I made a whole other function
23:38:14 <Mitar> how can i install additinal packages fro GHC 7?
23:39:20 <ivanm> the same way you would with earlier versions of GHC?
23:40:35 <zack> yes, use induction to solve this one
23:41:54 <Mitar> but the problem is that boot libraries are too new
23:42:05 <Mitar> for example filepath is 1.2
23:42:28 <Mitar> but in Cabal.cabal of Cabal packge it is written filepath >=1 && <1.2
23:42:36 <Mitar> I am getting such error:
23:42:37 <Mitar> Setup.hs: At least the following dependencies are missing:
23:42:37 <Mitar> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
23:42:38 <ivanm> Mitar: you have to get the dev version of Cabal
23:44:14 <Mitar> and will i have to do for all and every package?
23:44:21 <Mitar> or will packages from hackagedb work?
23:44:59 <ivanm> depends
23:45:07 <ivanm> some might work, others won't
23:45:24 <ivanm> that's why the platform is recommended so much for new users rather than getting the latest and greatest ghc
23:45:50 <Eduard_Munteanu> I wish it contained Gtk2Hs, I'm having major problems getting that to work on Wine.
23:46:10 <Eduard_Munteanu> *to build
23:46:17 <ivanm> that's been proposed; IIRC they want to stabilise the API first
23:46:29 <Eduard_Munteanu> Nice.
23:49:16 <vegai> building gtk2hs isn't trivial on any platform...
23:49:26 <lars9> what's exciting about ghc7?
23:49:38 <ivanm> lars9: new improved type engine
23:49:59 <ivanm> vegai: sure it is: emerge gtk2hs
23:50:00 <ivanm> ;-)
23:50:10 <vegai> ivanm: burn!
23:50:13 <ivanm> it's also cabalised now...
23:50:28 <Eduard_Munteanu> Well I'm having troubles with the Cabal version.
23:50:28 <vegai> it is? Cool.
23:50:37 <Eduard_Munteanu> Although the installer version won't do either.
23:50:45 <lars9> ivanm: what does that mean to average haskell learners?
23:59:12 * hackagebot HTF 0.6.0.0 - The Haskell Test Framework  http://hackage.haskell.org/package/HTF-0.6.0.0 (StefanWehr)
