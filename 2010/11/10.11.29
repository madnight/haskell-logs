00:00:03 * hackagebot webserver 0.4.3 - HTTP server library  http://hackage.haskell.org/package/webserver-0.4.3 (KazuYamamoto)
00:03:03 <lars9> copumpkin: how to implement this with GADT? in xmonad: -- | An existential type that can hold any object that is in Read and LayoutClass.
00:03:06 <lars9> data Layout a = forall l. (LayoutClass l a, Read (l a)) => Layout (l a)
00:03:33 <copumpkin> data Layout a where Layout :: forall l. (LayoutClass l a, Read (l a)) => l a -> Layout a
00:06:01 <lars9> it's like defining a data constructer the same as defining a normal function?
00:06:40 <copumpkin> sort of, yeah
00:06:45 <copumpkin> although they aren't always functions
00:06:54 <copumpkin> data Moo where Baa :: Moo
00:07:18 <lars9> what's Baa here, a value?
00:07:30 <copumpkin> a data constructor of the Moo type
00:07:45 <lars9> the same as: Moo = Baa ?
00:07:47 <copumpkin> data MyEnum where OptionA :: MyEnum; OptionB :: MyEnum; OptionC :: MyEnum
00:07:52 <copumpkin> no
00:08:00 <copumpkin> oh I see
00:08:00 <lars9> *  data Moo = Baa
00:08:01 <copumpkin> yeah
00:10:15 <lars9> so it seems Existential Types is not at the same level of GADTs. it focuses on forall.
00:10:50 <copumpkin> yeah, a GADT can do everything a simple existential type can do, and more
00:11:33 * hackagebot mighttpd 0.4.3 - Simple Web Server in Haskell  http://hackage.haskell.org/package/mighttpd-0.4.3 (KazuYamamoto)
00:14:30 <lars9> copumpkin: very inspiring, thanks
00:17:36 <lars9> and in the 1st example, we dont need forall anymore: data Layout a where Layout :: forall l. (LayoutClass l a, Read (l a)) => l a -> Layout a
00:17:45 <lars9> and in the 1st example, we dont need forall anymore: data Layout a where Layout :: (LayoutClass l a, Read (l a)) => l a -> Layout a
00:17:48 <lars9> right?
00:18:35 * hackagebot ghc-mod 0.5.1 - Happy Haskell programming on Emacs  http://hackage.haskell.org/package/ghc-mod-0.5.1 (KazuYamamoto)
00:18:59 <copumpkin> yeah, that's right
00:28:59 <lars9> can we use GADT to define an addOne for all Num? add 1::Int for Int, 1.0::Float for Float...
00:38:50 <augur> copumpkin: remind me what existential types do
00:48:23 <ManateeLazyCat> Hi all. :)
01:06:51 * hackagebot stm-io-hooks 0.7.0 - An STM monad with IO hooks  http://hackage.haskell.org/package/stm-io-hooks-0.7.0 (PeterRobinson)
01:15:57 <sinelaw> Is there a way (typeclass?) to constraint a type to be "enum-like"?
01:16:08 <sinelaw> which means a finite sum-type?
01:19:35 <sinelaw> @hoogle [k] -> Map k a -> Map k a
01:19:35 <lambdabot> Data.Map delete :: Ord k => k -> Map k a -> Map k a
01:19:36 <lambdabot> Data.Map deleteAt :: Int -> Map k a -> Map k a
01:19:36 <lambdabot> Data.Map adjustWithKey :: Ord k => (k -> a -> a) -> k -> Map k a -> Map k a
01:22:57 <sinelaw> @hoogle [a] -> a -> bool
01:22:58 <lambdabot> Did you mean: [a] -> a -> Bool /count=20
01:22:58 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
01:22:58 <lambdabot> Network.BufferType buf_concat :: BufferOp a -> [a] -> a
01:44:02 <hvr> new ghc-mod ... yey :-)
01:54:55 <edwardk> morning
01:59:53 <sinelaw> edwardk, noon ;)
02:00:18 <sinelaw> what's a nice string templating lib ?
02:00:27 <sinelaw> i've seen a few in hackage
02:00:30 <sinelaw> need to pick one
02:01:37 <edwardk> sinelaw not sure
02:01:41 <quicksilver> sinelaw: I like the sound of HStringTemplate, but I haven't used it.
02:02:50 <edwardk> for the interested. in a strict language, you have lots of recursive types: https://github.com/ekmett/scalaz/blob/master/core/src/main/scala/scalaz/Recursion.scala
02:03:44 <edwardk> Nu and Mu cease to coincide, and whether or not your recursion is through a type that provides covariance through the argument you are recursing further splits up the subtyping you can do
02:06:30 <romildo> I noticed the availability of the some functions to deal with temporary files in the standard library, but all of them opens the temporary file. I need only a temporary file name, that will be used to save a file that will be downloaded from the web. What do you suggest in order to get this temporary file name without opening the file itself?
02:07:37 <sinelaw> is there something built in that does:
02:07:46 <sinelaw> [[], a, b, [], c] -> [a,b,c] ?
02:07:49 <sinelaw> well
02:07:52 <sinelaw> except filter null :)
02:07:53 <sinelaw> nvm.
02:08:30 <sinelaw> not null. whatever.
02:09:11 <Axman6> @pl \x -> p == f x
02:09:12 <lambdabot> (p ==) . f
02:25:47 <sinelaw_> @hoogle Either a b -> b
02:25:48 <lambdabot> Data.Either rights :: [Either a b] -> [b]
02:25:48 <lambdabot> Data.Typeable typeOf2 :: Typeable2 t => t a b -> TypeRep
02:25:48 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
03:05:44 <ski> sinelaw_ : maybe `Ix' for "enum-like" ?
03:06:45 <ski> augur : having a data type with a polymorphic data constructor, where the quantified type variable doesn't appear in the result type
03:08:16 <ski> augur : like `data Stream a = forall s. Unfold (s -> (a,s)) s', yielding `Unfold :: forall a s. (s -> (a,s)) -> (s -> Stream a)'
03:10:09 <ski> or like `data Stack a = forall s. MkStack {empty :: s,push :: a -> s -> s,pull :: s -> Maybe (a,s),stack :: s}'
03:10:34 <sinelaw_> ski, whats Ix?
03:10:39 <sinelaw_> index types?
03:10:41 <sinelaw_> class
03:10:42 <sinelaw_> es
03:10:44 <sinelaw_> :)
03:10:48 <quicksilver> array indices
03:11:02 <quicksilver> supports natural things like tuple indices for n-dimensional arrays
03:11:09 <quicksilver> and adjustable 'origin'
03:11:34 <c_wraith> @src Ix
03:11:34 <lambdabot> class (Ord a) => Ix a where
03:11:34 <lambdabot>     range           :: (a,a) -> [a]
03:11:34 <lambdabot>     index           :: (a,a) -> a -> Int
03:11:34 <lambdabot>     inRange         :: (a,a) -> a -> Bool
03:11:34 <lambdabot>     rangeSize       :: (a,a) -> Int
03:11:36 <ski> @type (!)
03:11:37 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
03:11:39 <Jafet> I define you, you instance me, we are one big type family
03:13:34 <sipa> Jafet: all belonging to the same class?
03:13:35 <c_wraith> I finally understand what fundeps actually do.  The explanation "one parameter unique determines the other" is a really incredibly poor way to express what they're doing.
03:15:35 <ski> c_wraith : so, what do they actually do ?
03:16:04 <c_wraith> correction.  I know one out of the many things they do. :)
03:16:41 <ski> .. that one being ? :)
03:17:17 <c_wraith> they prevent multiple instances of a class that differ only in the depending type.
03:17:37 <ski> yeah .. but not only that
03:17:42 <quicksilver> it's a bit stronger than that
03:17:43 <ski> if you have, say
03:17:48 <ski>   class C a b | a -> b
03:17:50 <c_wraith> like I said, I know *one* thing they do. :)
03:17:53 <edon> Hi, how do i tell cabal to use the instances from a certain package and not from another one (i'm getting duplicate instance declarations) ?
03:18:00 <quicksilver> they permit the compiler to deduce which instance to used based only on some of the types
03:18:10 <quicksilver> (because it knows the others are uniquely determined by the fundeps)
03:18:26 <c_wraith> right, quicksilver.  But that's now how I interpreted the phrase I saw all over the place.
03:18:40 <ski> then that makes sure that if the constraints `(C a b0,C a b1)' are inferred, then the fun.dep. means that `b0' and `b1' must be the same type, so that constraint can be replaced with `C a b', often removing ambiguities
03:18:47 <quicksilver> edon: you can't easily use packages with conflicting instances.
03:19:04 <quicksilver> edon: you might be ok if you avoid importing the troublesome modules into the same place
03:19:05 <ski> (which is, sortof, the *point* of fun.deps .. apart from wanting to statically specify the functional dependency)
03:19:05 <gds> edon: is one of them mtl?
03:20:06 <c_wraith> ski: ah, that makes a ton more sense than *any* explanation on the wiki.
03:20:28 <ski> c_wraith : so the "prevent multiple instances of a class that differ only in the depending type" is the condition that has to be true, to make the rewriting from `(C a b0,C a b1)' to `C a b' be safe
03:21:14 <c_wraith> because the way it's usually worded makes it sound like "there can only be one type b for any particular a" in your example, which is horribly wrong.
03:21:25 <ski> ("safe" here meaning being most general, so the type system doesn't "guess" wrong which types you wanted, giving you a type error where none should occur)
03:21:27 <gds> edon: So, I had a problem once where a package I depended on required monads-fd, and another required mtl. In that case, the right thing to do seemed to be to "hide" monads-fd.
03:22:33 <ski> c_wraith : yeah, that's a bit unclear. the FD in `class C a b | a -> b' can be phrased logically as `forall a. unique b. C a b', which expands as `forall a b0 b1. (C a b0,C a b1) => (b0 = b1)'
03:22:41 <edon> gds: nope this is, combinatorrent and QuickCheck
03:23:02 <quicksilver> c_wraith: how is "there can only be one type b for any particular a" horribly wrong?
03:23:16 <ski> c_wraith : so, if you can decipher that formula, that both explains why you can't add certain instances together, and explains the simplification of constraints that it will perform
03:23:21 <c_wraith> @src MonadState
03:23:21 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:23:22 <gds> edon: Ah, then I'm not so sure. Are you using things from both packages in /your/ code, or do you just have them both around because something else depends on one of them?
03:24:14 <c_wraith> here it is:  class Monad m => MonadState s m | m -> s where
03:24:29 <gds> edon: You can specify which package to import things from in your import line if you're using ghc...
03:24:56 <edon> gds: nope, just tried installing combinatorrent, and it seems that the author used his own instances of Arbitrary which conflict with the QuickCheck ones. thanks anyway
03:25:18 <gds> edon: A bit like this, IIRC: """import "mtl" Control.Monad.Cont""
03:25:41 <c_wraith> quicksilver: "for any type m, there can be only one instance of s" would mean that if m was State, s would have to be one thing.  Int, say.  So you couldn't have a MonadState instance for State and [Int]
03:25:59 <quicksilver> c_wraith: "m" can't be State.
03:26:07 <quicksilver> c_wraith: "m" is a type. State is a type constructor.
03:26:20 <quicksilver> well... to be more precise.
03:26:26 <ski> c_wraith : yeah, so the logical condition there is `forall m. Monad m => unique s. MonadState s m', expanding to `forall m s0 s1. (Monad m,MonadState m s0,MonadState m s1) => s0 = s1'
03:26:28 <quicksilver> "m" has kind * -> *; State has kind * -> * -> *
03:26:38 <quicksilver> c_wraith: so, "m" can be, e.g., State Int
03:26:41 <c_wraith> oh.  So..  it means "State s" has a specific s.  Ok, I can see that now.
03:26:51 <quicksilver> c_wraith: and then, the s is indeed determined.
03:26:52 <ski> c_wraith : exactly
03:27:16 <ski> however, in the case of `StateT s0 (State s)', this is irritating
03:27:29 <ski> (s/s)/s1)/)
03:27:31 <c_wraith> Well, MonadState is irritating when nested anyway.
03:28:19 <ski> (or `StateT s0 (ContT o (State s1))' if you want something less trivial)
03:29:03 <c_wraith> Well, the first got the point across. :)
03:29:04 <ski> c_wraith : i think we'd really want to be able to associate a "tag" with each part of the transformer stack, and be able to use that, to refer to the levels
03:29:12 <quicksilver> but you can hand-write a MonadState (s0,s1) instance for that
03:29:18 <quicksilver> the lifts are a pain but you only have to do it once
03:29:37 <quicksilver> or better, you can write some appropriate primitives that are meaningful for your monad stack.
03:29:43 <ski> quicksilver : for `StateT s0 (State s1)' or for `StateT s0 (ContT o (State s1))' ?
03:29:48 <quicksilver> (...when I say "for that" I mean "for a newtype of that")
03:30:04 <quicksilver> both?
03:30:22 <ski> @unmtl StateT s0 (ContT o (State s1)) a
03:30:22 <lambdabot> s0 -> (a -> s0 -> s1 -> (o, s1)) -> s1 -> (o, s1)
03:31:41 <ski> hm .. it seems needless to "touch" one part of the state, if you only need to interact with the other part
03:32:19 <quicksilver> sure
03:32:30 <quicksilver> that's where the "appropriate primitives part" comes in ;)
03:32:57 <quicksilver> getFurble :: Ski s0; getBurble :: Ski s1;
03:34:13 <ski> i still think it seems to monolithic
03:34:18 <ski> s/to/too/
03:34:56 <ski> (i'll have to think about the `MonadState (s0,s1) m' one)
03:35:52 <quicksilver> whenever I've used complex monads in real code (not often) the solution which has worked best for me is giving the monad custom primitives
03:35:54 <romildo> @pl \xs -> do hPut tempHandler xs; return tempFileName
03:35:55 <lambdabot> (line 1, column 30):
03:35:55 <lambdabot> unexpected ";"
03:35:55 <lambdabot> expecting variable, "(", operator or end of input
03:35:59 <quicksilver> and not exporting any of the MTL classes to consumers.
03:36:22 <quicksilver> (a potential disadvantage of this is your "consumers" can't use any library routines which work over the MTL classes, though)
03:43:21 <reuben> hi
03:45:52 <reuben> if I want to use a tuple returned by another function in a function, how do i do it?
03:46:07 <merijn> reuben: How do you mean?
03:46:28 <merijn> Just pas the tuple to the function you want to use it?
03:48:00 <c_wraith> > let (q, r) = 5 `divmod` 3 in q + r
03:48:01 <lambdabot>   Not in scope: `divmod'
03:48:06 <c_wraith> > let (q, r) = 5 `divMod` 3 in q + r
03:48:07 <lambdabot>   3
03:48:31 <c_wraith> reuben, is that the sort of thing you mean?  pattern-matching the result?
03:48:33 <c_wraith> :t divMod
03:48:34 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
03:49:36 <reuben> I have a method called size, which returns (float width,float height),(float x,float), I want to use size in a function which returns the difference in scale between a given x
03:49:44 <reuben>  width and height
03:50:53 <reuben> so basically I want to get the width returned/the width given etc
03:50:56 <merijn> reuben: So basically you want to get the first and second value out of the tuple?
03:51:00 <merijn> :t fst
03:51:01 <lambdabot> forall a b. (a, b) -> a
03:51:05 <merijn> :t snd
03:51:06 <lambdabot> forall a b. (a, b) -> b
03:51:14 <merijn> > fst (1,2)
03:51:15 <lambdabot>   1
03:51:47 <merijn> There may be better ways, depending on what you're doing, but those are the most obvious ways of doing it
03:59:57 <reuben> Wait, no that was wrong, I needed to get the first tuple from a custom datatype which has two tuples defined as data DType = Point Point deriving Show, point being defined as  type Point = (Float, Float)
04:00:14 <tab> is there a way to receive data on a handle with the same behavior of Network.Socket.recv (like a read syscall in C) ?
04:02:20 <arcatan> reuben: use pattern-matching. something like this: getFirst (DType a b) = a
04:02:47 <arcatan> or if DType is defined by you, you could use records
04:03:15 <reuben> DType is defined by me.
04:05:01 <arcatan> reuben: LYAH explains record syntax: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#record-syntax
04:17:30 <reuben> arcatan that got it! 
04:36:28 <reuben> arcatan: to add a further level of complexity
04:37:24 <reuben> there are mappings of Type Point = (float,float) and type Length float so i'm having trouble comparing them
04:37:28 <reuben> how do i solve that?
04:39:12 <reuben> Well, how do I convert custom float types to floats to compare
04:40:07 <sipa> what is a custom float type?
04:40:18 <reuben> like
04:40:22 <reuben> in the code defined as like
04:40:26 <reuben> type Length = float
04:40:43 <c_wraith> type create synonyms only
04:40:51 <c_wraith> They're exactly the same type in every way
04:40:54 <c_wraith> It's just an extra name
04:40:59 <c_wraith> So no conversion is necessary
04:41:34 <reuben> That's what I thought but my code gave me this: Couldn't match expected type `Length' against inferred type `Point`
04:42:06 <shachaf> reuben: That's a good type error.
04:42:08 <nlogax> but your Point is not like your Length
04:42:13 <c_wraith> Ah, but point is (Float, Float)
04:42:14 <Saizan> reuben: that's because Float and (Float,Float) are different
04:42:16 <shachaf> reuben: You aren't supposed to be able to compare Points with Lengths.
04:42:32 <shachaf> They're two different types of thigs.
04:42:46 <reuben> but it's comparing with fst point which should just return a float right
04:43:02 <reuben> (point is defined as type Point = (float,float))
04:43:31 <Saizan> it's not comparing with the first unless you explicitly do that
04:43:36 <Cale> reuben: Clearly according to the type error, it's not :)
04:43:45 <Saizan> otoh, we've not seen the code :)
04:43:59 <reuben> Whoops, it helps, if I intend to do it, that i actually type the fst bit. sorry.
04:44:00 <Cale> reuben: So, you've probably missed out on pattern matching or using the fst function.
04:44:23 <remy_o> or operator priority
04:47:21 <sinelaw_> how to export only the constructor of a data type?
04:47:44 <sipa> module Foo.Bar (Type(Constructor), ...)
04:48:08 <nlogax> reuben: http://codepad.org/xv1DVfin you can paste show and run code there.
04:48:35 <reuben> nlogax it works now, i'd forgotten to put in the fst bit
04:48:39 <nlogax> ah 
04:49:26 <sinelaw_> does the monomorphism restriction apply also to a function that requires a different type class constraint inside?
04:49:43 <sinelaw_> (or something like that; weird error here, trying to decipher)
04:50:30 <aristid> sinelaw_: just try NoMonomorphismRestriction :D
04:50:30 <datenwolf> Trying to build GHC from source, something in the documentation build process is messed up: Docbook XML is fed right into LaTeX which fails the process.
04:51:04 <sinelaw_> ok
04:51:07 <sinelaw_> :D
04:51:24 <quicksilver> the monomorphism restriction says: No value may have a non-annotated type of the form (Ctxt a) => foo unless it is "syntactically" a function, i.e. written as f x = ...
04:56:17 <sinelaw_> what's like show but doesn't escape String values with "" ?
04:56:28 <quicksilver> id
04:56:50 <quicksilver> > id "Hello"
04:56:51 <lambdabot>   "Hello"
04:56:51 <aristid> :D
04:56:55 <sinelaw_> meh
04:56:56 <quicksilver> > show "Hello"
04:56:57 <lambdabot>   "\"Hello\""
04:57:10 <sinelaw_> quicksilver, typeclassylike
04:57:13 <aristid> sinelaw_: or do you want it to work on non-String types too?
04:57:14 <shachaf> quicksilver: No, no, the "" is still there.
04:57:19 <sinelaw_> aristid, yeah
04:57:20 * quicksilver slaps shachaf 
04:57:21 <shachaf> > text "Hello" -- This is what you want.
04:57:22 <lambdabot>   Hello
04:57:32 <revenantphx> So it seems like having a Chan associated with a Handle, and then having a thread which reads from the Chan into the Handle is kind of common
04:57:33 <sinelaw_> ah
04:57:34 <quicksilver> sinelaw_: nothing.
04:57:34 <sinelaw_> thanks
04:57:38 <sinelaw_> what
04:57:38 <quicksilver> > text 3
04:57:39 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
04:57:39 <lambdabot>    arising from the literal `...
04:57:40 <sinelaw_> @type text
04:57:41 <lambdabot> String -> Doc
04:57:44 <sinelaw_> heh
04:57:49 <sinelaw_> ok, then no
04:57:52 <aristid> > text . show $ 3
04:57:53 <quicksilver> sinelaw_: "show" is for producing haskell syntax.
04:57:53 <lambdabot>   3
04:57:57 <sinelaw_> i'm schtuck
04:58:01 <aristid> > text . show $ "now with quotes"
04:58:02 <lambdabot>   "now with quotes"
04:58:02 <quicksilver> there is nothing which shows some types and not others.
04:58:13 <sinelaw_> i want to show them all, just show strings differently 
04:58:13 <quicksilver> what are you actually trying to do?
04:58:16 <sinelaw_> than the default show
04:58:19 <aristid> sinelaw_: you can write your own typeclass :)
04:58:31 <aristid> also, String should have been a newtype
04:58:34 <sinelaw_> quicksilver, generate some text
04:58:38 <sinelaw_> (actually it will be code)
04:58:39 <quicksilver> if you want to do anything different than the default show, then your objective is not to show.
04:58:47 <quicksilver> the objective of 'show' is to show in haskell syntax.
04:58:55 <quicksilver> what is your objective, since it is clearly not that?
04:59:01 <remy_o> @type disp 3
04:59:01 <sinelaw_> ok, then my objective is not to show. never mind, i think i go tthat
04:59:02 <lambdabot> Not in scope: `disp'
04:59:05 <remy_o> @type display 3
04:59:06 <lambdabot> Not in scope: `display'
04:59:12 <aristid> not . show
04:59:12 <sinelaw_> generating non-haskell syntax
04:59:15 <aristid> does not work tho :D
04:59:20 <quicksilver> I'm not trying to be snarky. I'm trying to find out what you actually want to do so we can help ;)
04:59:35 <sinelaw_> nvm, got it
04:59:36 <shachaf> quicksilver: Probably the equivalent of to_s in Ruby?
04:59:43 <aristid> sinelaw_: you probably only need a couple of types to convert to strings, right?
05:00:04 <sinelaw_> actually it's parameterized
05:00:06 <quicksilver> if I was generating non-haskell syntax, I'd have a data type like
05:00:12 <remy_o> @type Distribution.Text.disp 
05:00:13 <lambdabot> forall a. (Distribution.Text.Text a) => a -> Doc
05:00:20 <quicksilver> data PythonVal = I Int | S String
05:00:28 <quicksilver> and I'd just write a functtion on that type
05:02:00 <revenantphx> Okay... https://gist.github.com/719610
05:02:16 <revenantphx> So I'm wondering if theres a better way for managing the TChan and Handle here.
05:02:48 <revenantphx> This is a really simple example where it's not even a problem.
05:03:05 <revenantphx> But is there at all a better way than passing all the state in a tuple?
05:03:53 <merijn> The State monad? :p (Mind you, I'm not enough of a haskell programmer to know if that's the correct answer)
05:03:58 <quicksilver> typically, in programs like that, you end up with a custom data type MyIRCState which includes all the TChans and stuff
05:04:11 <revenantphx> Okay, so that's not bad at all?
05:04:12 <quicksilver> you can then choose to put it in a monad, or not, it's largely a matter of taste.
05:04:21 <revenantphx> What do you mean put it in a monad?
05:04:47 <quicksilver> the Reader monad encapsulates the pattern where the same arguments are being passed to lots of functions
05:04:57 <quicksilver> and makes them implicitly passed to other actions in the monad without you needing to do so
05:05:05 <quicksilver> (the State monad is similar but lets you alter them too)
05:07:55 <revenantphx> I see.
05:08:40 <sinelaw_> @type mconcat
05:08:41 <lambdabot> forall a. (Monoid a) => [a] -> a
05:08:44 <sinelaw_> @type concat
05:08:45 <lambdabot> forall a. [[a]] -> [a]
05:09:15 <revenantphx> concat "flattens" a 2d array to 1d, mconcat is for monoids (like [] and ++) I believe.
05:09:20 <revenantphx> So mconcat is ++.
05:09:40 <shachaf> revenantphx: No, you can see by the type that they're the same.
05:09:44 <shachaf> @ty mappend
05:09:44 <lambdabot> forall a. (Monoid a) => a -> a -> a
05:09:59 <revenantphx> oh, tha'ts mappend :\
05:10:01 <shachaf> @ty (++) -- Cale++
05:10:02 <lambdabot> forall m. (Monoid m) => m -> m -> m
05:10:11 <sinelaw_> @type print
05:10:13 <lambdabot> forall a. (Show a) => a -> IO ()
05:10:19 <revenantphx> odd.
05:10:22 <sinelaw_> @hoogle String -> IO ()
05:10:22 <lambdabot> Prelude putStr :: String -> IO ()
05:10:22 <lambdabot> Prelude putStrLn :: String -> IO ()
05:10:22 <lambdabot> System.IO putStr :: String -> IO ()
05:10:23 <shachaf> @ty printf
05:10:24 <lambdabot> forall r. (PrintfType r) => String -> r
05:10:26 <revenantphx> I'm confused now. again...
05:10:30 <aavogt> @ty foldr (++) mempty
05:10:31 <lambdabot> forall a. (Monoid a) => [a] -> a
05:11:50 <aristid> @ty mconcat
05:11:51 <lambdabot> forall a. (Monoid a) => [a] -> a
05:11:56 <hpc> @src mconcat
05:11:57 <lambdabot> Source not found. :(
05:12:07 <aristid> mconcat = foldr mappend mempty
05:12:38 <aavogt> it's a class method, so people can override it for specific instances
05:12:42 <aavogt> @src Monoid
05:12:43 <lambdabot> class Monoid a where
05:12:44 <lambdabot>     mempty  :: a
05:12:47 <lambdabot>     mappend :: a -> a -> a
05:12:48 <lambdabot>     mconcat :: [a] -> a
05:12:54 <hpc> nifty
05:13:13 <aristid> aavogt: i wonder if there are many instances that actually do override it
05:13:15 <orlandu63> what is the difference between a tchan and a chan? or rather, when should i use one over the other?
05:13:40 <quicksilver> a tchan has transactional guarantees
05:13:44 <aavogt> aristid: then go look and report back
05:13:50 <aristid> :)
05:13:52 <quicksilver> use a tchan when you need to, e.g., read two items from a channel
05:13:59 <aristid> aavogt: i would, if i was not too lazy :P
05:14:01 <quicksilver> and guarantee that you have read two *successive* items
05:14:10 <quicksilver> or read-in-sync between two chans, etc.
05:14:11 <aavogt> perhaps the discussion that added it has enough motivating examples
05:15:39 <orlandu63> what is the use case for a chan over a tchan? why _wouldn't_ you want transactional guarantees?
05:16:24 <quicksilver> orlandu63: might be faster. Although I'm not sure if it is.
05:16:30 <Cale> orlandu63: Well, STM does currently have some overhead. Maybe a Chan is all you need.
05:16:53 <Cale> If nothing else, there's syntactic overhead to have to apply atomically to things.
05:16:54 <Gilly> Is there a linear algebra package that can perform Gaussian elimination or matrix inversion when working over the rationals?
05:17:16 <aavogt> @hackage vec
05:17:16 <lambdabot> http://hackage.haskell.org/package/vec
05:17:26 <aavogt> @hackage Vec
05:17:26 <lambdabot> http://hackage.haskell.org/package/Vec
05:17:47 <Gilly> Thanks, I'll look at those.
05:17:47 <orlandu63> hmm, okay
05:18:41 <aavogt> it's only one package, and the gaussElim there only seems to be ok with Rational
05:19:09 <Cale> orlandu63: If your STM actions all consist of atomically applied to some primitive STM action, then you might as well not be using STM.
05:20:02 <adimit> Does anyone know of projects that use Lazar Miljenovic's graphviz library? The documentation is sparse, and I'd just like to look at some example code.
05:23:14 <Cale> preflex: seen ivanm
05:23:14 <preflex>  ivanm was last seen on #haskell-blah 4 hours, 44 minutes and 49 seconds ago, saying: luite: so either everyone else assumed it was harder than it actually was, you've done something completely stupid with your algorithm or you've stuffed up your complexity calculations?
05:23:46 <Cale> adimit: ivanm is the person you probably want to talk to :)
05:24:03 <adimit> ah, good to know he hangs out here sometimes. I don't really wanna bug him too much, I'm sure he's got more important stuff to doâ€¦ but I'm a bit lost :-|
05:24:18 <adimit> Cale: thanks.
05:24:28 <Cale> I don't know of projects using it, but what are you having trouble with? Perhaps I can help navigate the docs.
05:25:27 <adimit> well, I've got my data in [LEdge String] and [LNode String] form, and I can convert it to graphs just fine. However, I'd like the nodes and edges in the PNG output to have labels.
05:25:50 <adimit> I'm aware that I could probably construct the whole thing manually, but I was wondering what was the *easiest* way to do it :-)
05:26:16 <adimit> I looked at the test suite, but it left me none the wiser :-\
05:27:08 <adimit> <
05:27:29 <adimit> whoops sorry, I spiled tea on my keyboard :\
05:27:49 <Zao> Doh.
05:29:00 <Cale> okay, so you set Label attributes for them?
05:30:35 <adimit> well, right now I'm using graphToDot to convert a patricia tree graph (Gr String String) to a DotGraph Node
05:33:28 <Cale> adimit: So, it looks like (and I'm not really familiar with this library), when you provide the GraphvizParams value, the fmtNode and fmtEdge fields in it are functions which take nodes and edges and assign attributes to them.
05:33:30 <lars9> is there any zipper lib supports undo?
05:33:54 <adimit> Cale: thanks for the pointer. I'm going to try that now.
05:33:56 <Cale> adimit: So at that point, you might just be able to apply the label based on the data in the node or edge
05:34:11 <adimit> Cale: that sounds exactly like what I want to be doing.
05:35:25 <Cale> lars9: undo? That sounds a bit like a list zipper to begin with :)
05:35:49 <lars9> what's the proper word for horizontal and vertical? direction has been given to up/down/left/right
05:36:13 <Jafet> "orthogonal", lars9
05:36:14 <quicksilver> orientation?
05:36:15 <Zao> You clearly want a preprohistoric zygomorphism?
05:36:40 <lars9> Cale: guess so, it seems zipper is very dependent to our own data structure
05:36:43 <sipa> what's wrong with 'direction' ?
05:37:00 <Jafet> Oh
05:37:08 <Jafet> How about direction'
05:37:13 <Cale> lars9: I don't understand
05:37:19 <lars9> orientation sounds good
05:38:07 <lars9> Cale: i mean different data structures have very different zippers, so it seems no zipper lib can solve all problems
05:38:11 <Jafet> I'm sure there's a unicode symbol that shows exactly what you mean
05:38:49 <lars9> | - ?
05:38:51 <lars9> :)
05:40:07 <Cale> lars9: The main problem with constructing a unified zipper library is that the type constructor for the zipper of a type (the derivative, more or less), would have to inspect the constructors of the datatype, and give names to their derivatives.
05:40:25 <Cale> lars9: It's still quite possible to build a typeclass framework for zippers.
05:42:38 <adimit> Cale: thanks very much, that was exactly what I needed :-)
05:42:45 <Cale> lars9: I'll paste a bit of code from Conor McBride in this direction...
05:43:00 <lars9> Cale: that's great, thanks:)
05:43:35 <Cale> actually, maybe I can link to the whole mailing list post
05:43:55 <Cale> http://www.haskell.org/pipermail/libraries/2010-July/013843.html
05:43:59 <Cale> there it is :)
05:44:06 <Cale> (Google ftw)
05:44:22 <Cale> (It was actually in reply to a message of mine :)
05:46:00 <lars9> Cale: let me check
06:21:07 <gds> Hm - if I want to install the haskell platform on a web server (for writing web apps...), do I really need opengl?
06:21:30 <gds> the configure script of the source dist seems to think so...
06:22:09 <c_wraith> the platform is not server-oriented
06:22:55 <hpc> if you are installing it on a webserver, why not install GHC and libs separately?
06:28:09 <ManateeLazyCat> Don't do "read foo :: String" if foo already String... otherwise read error information will confuse you ... :)
06:33:50 * hackagebot pvd 1.0.1 - A photo viewer daemon application with remote controlling abilities.  http://hackage.haskell.org/package/pvd-1.0.1 (RickardNilsson)
06:36:41 <Jafet> haskell-platformer
06:49:11 <revenantphx> okay, now I'm having this issue :\
06:49:13 <revenantphx> https://gist.github.com/720032
06:49:22 <revenantphx> Say I want to put joining channels into its own function.
06:49:32 <revenantphx> Oh wait, I cant, since it needs state from the main function.
06:49:46 <revenantphx> So then I have to pass it to it as well from the recvIRC...
06:53:43 <quicksilver> revenantphx: yes, you either have "Handle -> TChan String ->" in every function's signature
06:53:54 <quicksilver> revenantphx: or you encapsulate that into a type and have "MyState ->"
06:54:03 <revenantphx> I have MyState :\
06:54:07 <revenantphx> (changed it a bit)
06:54:10 <quicksilver> revenantphx: or you encapsulate that into a Monad and have "MyMonad"
06:54:25 <revenantphx> I still don't get that part. I looked at Reader a bit,
06:54:31 <revenantphx> but I'm a bit confused.
06:54:42 <quicksilver> it's very unmagical.
06:54:50 <revenantphx> Oh, one quick thing.
06:54:52 <quicksilver> it's just a name for the idea of passing arguments.
06:54:57 <Cale> Well, (MyState ->) is a monad
06:54:59 <revenantphx> Is there an easy way to pattern match strings?
06:55:06 <revenantphx> Other than char by char
06:55:07 <quicksilver> String -> String -> ReaderT MyState IO ()
06:55:10 <quicksilver> is exactly like
06:55:14 <merijn> revenantphx: You mean like regular expressions? >.>
06:55:16 <quicksilver> MyState -> String -> String -> IO ()
06:55:17 <Cale> revenantphx: use functions like isPrefixOf
06:55:21 <Cale> (and guards)
06:55:23 <revenantphx> merijn: yeah, except only prefixes
06:55:27 <revenantphx> guards would world.
06:55:29 <revenantphx> work*
06:55:37 <Cale> Or any other functions for string matching of course
06:55:49 <revenantphx> It's just with irc I want to detect : prefixed system messages and numeric prefixed commands.
06:56:02 <revenantphx> I need to send joins after I receive 001.
06:57:16 <revenantphx> Having overloads for each prefix seemed convenient you know :P.
06:58:08 <merijn> These sorts of protocols scream to me "I want dependent types!" :>
06:58:44 <Saizan> i think there are a few irc parsers on hackage
06:59:08 <revenantphx> Saizan: Well, I'm not exactly trying to use an existing one am I.
06:59:15 <revenantphx> merijn: what do you mean?
07:02:07 <merijn> revenantphx: Dependent typing is extension/addition to the type system Haskell currently has, but its not really relevant for you in solving this problem (since afaik there's no practical language with an implementation atm)
07:02:18 <revenantphx> Oh I see.
07:02:21 <revenantphx> What's the idea though?
07:02:27 <revenantphx> The type being dependant on something?
07:02:31 <revenantphx> dependent*
07:03:36 <merijn> revenantphx: The type depending on values, yes (for instance tuples (a, b) where the type of b depends on the *value* of a)
07:03:44 <Saizan> the main thing is that the result type of a function can depend on the value of its argument
07:03:51 <revenantphx> Hm, that's neat.
07:04:14 <revenantphx> In one parser I wrote in ObjC, I had some rather extreme polymorphism that was like that.
07:04:36 <revenantphx> Depending on the value passed into the initializer, an entirely different subclass was returned.
07:05:01 <revenantphx> And all of the subclass methods were dynamically generated, or the superclass ones were tooled to work differently depending on the calling subclass.... it was evil.
07:05:04 <revenantphx> but fun.
07:05:44 <revenantphx> https://gist.github.com/720046
07:05:51 <revenantphx> Very ugly but useful code.
07:05:57 <merijn> revenantphx: The difference with dependent types is that its done (and checked) at compile time
07:06:00 <Saizan> that's easy to do in haskell by representing a class as a record of functions
07:06:11 <revenantphx> merijn: Yeah I can see the coolness.
07:06:15 <revenantphx> Or at least some of it :P
07:06:30 <revenantphx> Saizan: heh?
07:06:50 <quicksilver> revenantphx: your 'dynamic subclass' thing
07:06:57 <quicksilver> can be done in haskell with a record of functions
07:07:01 <quicksilver> (being the methods of the 'subclass')
07:07:20 <merijn> A record of functions is essentially how python and ruby do it, no?
07:07:38 <Saizan> i'm assuming that the result type of the initializer didn't mention the subclass
07:07:43 <quicksilver> no, python and ruby both have this braindead notion of 'classes'.
07:07:47 <merijn> Just have a hash map of function names to functions and look them up at runtime
07:07:51 <revenantphx> Saizan: No, it just mentions the superclass.
07:07:54 <quicksilver> a record of functions is essentially how javascript does it.
07:08:04 <revenantphx> That's also how Objective-C manages methods.
07:08:08 <revenantphx> That's why my method works.
07:08:29 <merijn> quicksilver: A class in python is just and object + associated dictionary afaik
07:08:39 <Cale> If you're not going to be statically typechecking your object oriented language, it seems pretty silly to introduce a notion of classes anyway.
07:09:13 <revenantphx> Cale: Classes are introspective, so the "class" of an object becomes more of a way to tell what it can do at runtime.
07:09:20 <merijn> Cale: Well, I think python mostly does it to soothe the mind of the people damaged by Java/C++ :p
07:09:23 <Saizan> revenantphx: with dependent types it could, e.g. you can have a printf function that depending on which String you pass to it takes a different number and types of parameters, checking them at compile time
07:09:32 <quicksilver> merijn: it's been a long time since I remembered any python, but yes, my point is the record of functions isn't a property of the object, but of the class.
07:09:33 <revenantphx> Saizan: Yeah, that's really cool.
07:09:36 <revenantphx> Wow.
07:09:39 <quicksilver> merijn: so you can't change a single method of a single object.
07:09:52 <quicksilver> merijn: you'd be changing the class.
07:09:54 <Cale> quicksilver: Oh, that's really dumb.
07:09:58 <merijn> quicksilver: You can do that in python.
07:10:05 <revenantphx> In most OO languages, methods can only be changed by class.
07:10:12 <quicksilver> merijn: in that case I stand corrected.
07:10:13 <revenantphx> Of course, there are nasty tricks to get around it.
07:10:15 <merijn> Python looks at the specific object first, then if its not found it looks it up in the class hierarchy
07:10:49 <revenantphx> In ObjC you could create an anonymous subclass which changes said method, and put it as the objects class. Then edit the -class method as well, so it "skips" it.
07:11:06 <revenantphx> Essentially you hold the object at gunpoint, tell it this new class is its class, but that it should NEVER TELL ANYONE about it.
07:11:20 <Cale> Putting method implementations in classes is a stupid idea to begin with.
07:11:36 <revenantphx> Cale: I don't see how.
07:11:44 <revenantphx> If you put them in objects the overhead would be horrid.
07:11:50 <Cale> The whole point of objects is that they're values which are determined by the manner in which they respond to messages (or how they implement methods)
07:12:03 <revenantphx> Then go use a prototyped OO language.
07:12:27 <revenantphx> Classes are supposed to be blueprints for an object, and it follows that every object made from the same blueprint does the same thing.
07:12:42 <Cale> The overhead isn't horrid -- you use the same techniques as are available in any functional programming language to compile them.
07:12:53 <revenantphx> ?...
07:12:54 <lambdabot> Not enough arguments to @.
07:13:05 <quicksilver> revenantphx: that's a description but not a justification :)
07:13:16 <Cale> Method implementations can just be lambda abstractions
07:13:27 <Cale> You compile them in the same way
07:13:30 <revenantphx> Yep, you've lost me.
07:13:32 <quicksilver> revenantphx: we understand how class-based OO works, we just don't think it's sensible.
07:13:32 <revenantphx> XD
07:13:37 <merijn> Objects are a poor man's closures!
07:13:45 <merijn> Closures are a poor man's objects!
07:14:09 <revenantphx> With Apple's GCC extension for blocks... Closures are objects!
07:14:14 <revenantphx> And in python methods are objects.
07:15:22 <Cale> I kind of dislike that comparison between objects and closures, because again it's mixing up implementation details with language features :)
07:16:39 <merijn> Cale: As, you don't appreciate venerable master Qc Na? :p (http://c2.com/cgi/wiki?ClosuresAndObjectsAreEquivalent)
07:17:03 <Cale> :)
07:17:09 <danzajdband> i have a question
07:17:20 <danzajdband> if i have 2 Char lists
07:17:21 <arcatan> please ask
07:17:23 <Cale> vtables are a poor man's closures
07:17:34 <Cale> ^^ better
07:17:51 <Cale> Or objects are a poor man's lambda abstractions
07:18:10 <danzajdband> and i want to Â¿take out? (sorry for my awful english) all aparittions of the first in the other one
07:18:17 <merijn> Pffft, lambda calculi are a poor man's Turing machines :)
07:18:17 <danzajdband> i dont now how to do this
07:19:37 <revenantphx> I'm a noob, but I'm thinking you could map delete over the first list
07:19:51 <danzajdband> anyone?
07:20:03 <quicksilver> danzajdband: revenantphx just gave you the answer.
07:20:15 <revenantphx> Is that really the best way?
07:20:40 <Cale> danzajdband: Like,   remove "ab" "abracadabra" = "racadra"?
07:20:43 <quicksilver> no, but maybe it doesn't matter.
07:20:49 <danzajdband> it matter
07:20:59 <revenantphx> > let arr1 = [1,2,3,4], arr2 = [1,2,3,4,5,6] in map (\x -> delete x arr2) arr1
07:21:00 <lambdabot>   <no location info>: parse error on input `,'
07:21:07 <quicksilver> it would be better to convert the second into a set first.
07:21:12 <revenantphx> let arr1 = [1,2,3,4]; arr2 = [1,2,3,4,5,6] in map (\x -> delete x arr2) arr1
07:21:24 <Cale> Wait, I'm not sure people are understanding danzajdband's question correctly
07:21:47 <Cale> He said he wants to remove occurrences of the first list in the second list (of the same type)
07:21:55 <danzajdband> yep
07:21:59 <danzajdband> cale is right
07:22:08 <revenantphx> But he said he has 2 Char lists.
07:22:21 <danzajdband> an example is
07:22:21 <Cale> Which might mean that he wants to remove each of the elements occurring in the first list from the second one entirely, or it might mean he wants to locate and remove that exact sequence.
07:22:31 <revenantphx> I think his intent is more likely what I suggested
07:22:44 <revenantphx> How do you do multiple let definitions with lambdadot :\
07:22:51 <revenantphx> > let a = 10; b= 9 in a + b
07:22:52 <lambdabot>   19
07:22:53 <revenantphx> oh
07:22:55 <danzajdband> ['h','e']  ['a','h','e','l']  -->  ['a','l']
07:23:00 <revenantphx> > let arr1 = [1,2,3,4]; arr2 = [1,2,3,4,5,6] in map (\x -> delete x arr2) arr1
07:23:01 <lambdabot>   [[2,3,4,5,6],[1,3,4,5,6],[1,2,4,5,6],[1,2,3,5,6]]
07:23:05 <revenantphx> That's not right....
07:23:10 <Cale> danzajdband: should  remove "ab" "abracadabra" = "racadra"  or  remove "ab" "abracadabra" = "rcdr" ?
07:23:32 <danzajdband> the last one
07:23:40 <roconnor> come vote in my costate renaming survey: http://www.reddit.com/r/haskell/comments/ed184/survey_new_name_for_the_costate_comonad/
07:23:41 <Cale> okay, good, because that's easier :)
07:23:49 <danzajdband> nono
07:23:53 <danzajdband> the first one
07:23:54 <danzajdband> sorry
07:23:56 <Cale> heh
07:24:08 <Cale> all right, then everyone was wrong about what you wanted :)
07:24:10 <revenantphx> just the first occurence.
07:24:13 <revenantphx> mm
07:24:19 <danzajdband> no
07:24:20 <Cale> No, not just the first occurrence.
07:24:23 <danzajdband> all the ocurrencies
07:24:30 <revenantphx> oh, ack right
07:24:33 <revenantphx> yeah I see.
07:24:34 <Cale> But the elements of the first string have to occur in the same order in the second list
07:24:41 <Cale> (and adjacent to each other)
07:24:49 <danzajdband> "ha" "hahoha"  --> "ho"
07:24:53 <luite> suppose you remove "aba",  would "abababa" -> "b" or ""? and "aabababaa" -> "aba" or "" ?
07:24:56 <revenantphx> Oh I see.
07:25:14 <quicksilver> luite++ # good testcase
07:25:20 <luite> oh the last one can even be "aabbaa" :)
07:25:26 <Cale> Right, that was going to be my next question :)
07:25:52 <danzajdband> i think
07:26:10 <danzajdband> "aba",  would "abababa" -> "b"
07:26:22 <danzajdband> from left to right
07:26:33 <revenantphx> Wouldn't it be "ba" then?
07:26:40 <revenantphx> ah no
07:26:41 <revenantphx> I see.
07:26:50 <revenantphx> So each removal is a function of the previous one :\.
07:26:56 <danzajdband> yeah
07:27:04 <revenantphx> recursion time :D?
07:27:27 <danzajdband> im a haskell newbbie
07:27:32 <Cale> danzajdband: How about "aababa"?
07:27:41 <Cale> (if we remove aba)
07:27:53 <danzajdband> "aababa" -> "aba"
07:27:55 <danzajdband> hahaa
07:28:00 <revenantphx> ...ffff
07:28:04 <revenantphx> That's confusing now
07:28:16 <danzajdband> im not worried about the Â¿line? cases
07:28:24 <danzajdband> sopouse you cant do that thing
07:28:26 <Cale> boundary
07:28:27 <luite> oh right that's a simplified version of my 2nd test case, a bit clearer
07:28:46 <revenantphx> danzajdband: So does each removal depend on the previous one or not?
07:28:48 <danzajdband> sopouse you cant insert line cases
07:28:51 <revenantphx> You said it does, but in that situation it doesnt.
07:28:52 <danzajdband> not
07:28:57 <Cale> Well, let's suppose that you want to remove the second aba as well, that makes it easier.
07:29:02 <danzajdband> ok
07:29:03 <danzajdband> great
07:29:05 <revenantphx> mm
07:29:07 <danzajdband> lest do this
07:29:10 <quicksilver> I think danzajdband's version is easy enough
07:29:19 <Cale> Well... okay :)
07:29:25 <danzajdband> do you have the answer?
07:29:27 <danzajdband> :D
07:29:28 <Cale> Either way is not so bad.
07:29:43 <quicksilver> remove a b@(x:xs) | a `isPrefixOf` b = stripPrefix a b | otherwise = x : remove a xs
07:29:52 <danzajdband> thank you!
07:29:54 <quicksilver> not quite sure I have the type of stripPrefix right
07:29:58 <danzajdband> im gonna test that answer
07:30:06 <quicksilver> and I'm missing the obvious [] case
07:30:09 <Cale> danzajdband: You'll have to write stripPrefix
07:30:22 <Cale> danzajdband: But isPrefixOf is in Data.List
07:30:25 <quicksilver> Cale: no, he doesn't
07:30:26 <quicksilver> http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Data-List.html#v:stripPrefix
07:30:32 <quicksilver> but he has to use it correctly given its type :)
07:31:06 * hackagebot SoccerFun 0.5.1 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.5.1 (JanRochel)
07:32:08 * hackagebot SoccerFunGL 0.5.1 - OpenGL UI for the SoccerFun framework  http://hackage.haskell.org/package/SoccerFunGL-0.5.1 (JanRochel)
07:32:58 <duckinator> hi
07:34:02 <xarch> how do you deal with cyclic imports?
07:34:26 <Zao> xarch: Booting.
07:35:05 <ManateeLazyCat> xarch: Intro Types.hs
07:35:28 <ManateeLazyCat> xarch: Just define Type in Types.hs that will import by many other module.
07:35:41 <Zao> http://markmail.org/message/5g7jb2uhvisadlsz
07:35:57 <Zao> ManateeLazyCat: Not everything can be solved by abstracting out more files.
07:36:04 <Zao> ManateeLazyCat: Nor may it be suitable for the application.
07:36:18 <Zao> You can write a .hs-boot file to "bootstrap" the recursion.
07:36:22 <ManateeLazyCat> Zao: Types.hs can't work?
07:36:33 <ManateeLazyCat> Zao: .hs-boot will crazy you when you have big project
07:36:39 <Zao> I can't find the relevant GHC page.
07:36:39 <ManateeLazyCat> Zao: And import each other.
07:37:03 <Zao> ManateeLazyCat: Not all definitions can be factored out like that.
07:37:19 <Zao> If anything, the universal solution is to merge together files.
07:37:46 <ManateeLazyCat> Zao: I'm not mean everything in one Types.hs, just Tyep that communications each other.
07:38:03 <Cale> quicksilver: Oh, that's new :)
07:38:04 <Zao> ManateeLazyCat: Yes, I know what you are meaning. I am saying it is not always possible.
07:38:06 <ManateeLazyCat> Zao: If one Type is basic type for other module, ok, anyplace can work.
07:38:10 <xarch> ok, thanks!
07:38:43 <Cale> quicksilver: He could use it to do both the test and stripping at once.
07:39:01 <ManateeLazyCat> Zao: Example?
07:39:25 <ManateeLazyCat> Zao: Close-Source project?
07:39:29 <Cale> remove a b@(x:xs) = case stripPrefix a b of Nothing -> x : remove a xs; Just ys -> remove a ys
07:42:33 <xarch> hum well ManateeLazyCat, I don't really want to use a Types.hs file, I prefer having files whose names are clear
07:42:42 <kmc> so, hscolor and HsColour are unrelated programs?
07:42:49 <xarch> and really explain what is in the file
07:43:07 <ManateeLazyCat> xarch: For current import system, Types.hs is clear solution.
07:44:15 <Zao> xarch: If you do not wish to refactor your code, a hs-boot is your only choice.
07:44:28 <ManateeLazyCat> xarch: Is your project big?
07:44:37 <Zao> There has been tickets open for a good while that suggest that whole-program compilation should be done, but it's apparently highly non-trivial.
07:44:47 <Zao> http://hackage.haskell.org/trac/ghc/ticket/1409
07:45:22 <Zao> I see that ManateeLazyCat is on the CC list for that bug, heh.
07:46:17 <ManateeLazyCat> Because when use .hs-boot in large project will cause crazy result:  A -> B -> C then C -> A, if your modules is too many, those cych path can't solve
07:47:03 <ManateeLazyCat> xarch: You fix one cycle-import, then you got another cycle-improt, then another, unless crazy you *complete*.
07:47:36 <ManateeLazyCat> xarch: But it's okay if your project is not large, .hs-boot is neater way.
07:48:51 <quicksilver> I tend to agree that trying to avoid cyclical deps is a good starting point
07:48:59 <xarch> yeah, I'm using hs-boot and it seems to work
07:49:12 <Renze> good afternoon!
07:49:27 <xarch> (and yes, my project is really small)
07:50:18 <Renze> could anybody tell me why my cmd says: "<command line>: cannot satisfy -package CGI", while the WASH library says you should use that (in their manual)?
07:51:12 <Zao> Renze: Case?
07:51:16 <Zao> Do you have the package installed?
07:54:15 <ManateeLazyCat> xarch: Ok, i suggest you use .hs-boot, more neat. :)
08:01:10 <crutcher> Hi. Is there any reason to prefer Data.ByteString.Char8 over Data.ByteString ?
08:01:56 <Renze> Zao: yes, I tried every possibility but none worked
08:02:20 <Renze> but my guess is that my cmd doesn't know "-package", so that the package doesn't even matter in the case.
08:02:56 <Zao> What does the shell have to do with Haskell packages?
08:03:44 <quicksilver> Renze: I think we need to know what your command line is. I don't really understand what you're saying. -package is an option for GHC.
08:03:47 <Renze> don't know to be honest
08:05:06 <Renze> quicksilver: ghc -package WASH --make Main
08:05:58 <Renze> and also tried different names for the package, but nothing worked
08:06:07 <Renze> (like WASHCGI, WASH.CGI.CGI (which works to import))
08:06:31 <Zao> ghc-pkg list
08:06:31 <quicksilver> what about plain ghc --make Main
08:06:42 <Cale> crutcher: They're the same datatype
08:06:49 <quicksilver> Renze: (WASH.CGI.CGI is a module name, not a package name)
08:06:52 <Zao> You might need an -user if it's not global.
08:07:01 <revenantphx> how would I change a character at one index?
08:07:13 <Zao> revenantphx: Of a string?
08:07:16 <revenantphx> yes.
08:07:18 <Cale> crutcher: If you want to think of the bytes of the ByteString as low-order characters, then the .Char8 module lets you do that
08:07:19 <revenantphx> [Char]
08:07:23 <Zao> revenantphx: Split it out, then reassemble a new list.
08:07:32 <Renze> quicksilver: you're right, but I just tried to be sure
08:07:32 <revenantphx> hm, no simple way I guess.
08:07:33 <revenantphx> Oh well.
08:07:50 <Cale> revenantphx: It's an unnatural operation to perform on a list.
08:07:53 <Zao> (front, (_,back)) = splitAt 9001 xs
08:07:57 <crutcher> Cale: so, same datatype, different function behaviour?
08:08:00 <Renze> just plain ghc --make main doesn't work because -package WASH is needed to import the package CGI in my module
08:08:04 <Cale> crutcher: yeah
08:08:08 <revenantphx> Cale: The reason is if I get "PING :1586328167", I want to just respond by switching the I to an O
08:08:08 <quicksilver> Renze: take n l ++ [x] ++ drop (n+1) l
08:08:10 <revenantphx> and sending it back.
08:08:14 <Zao> Err, (_:back), that is.
08:08:18 <quicksilver> Renze: it shouldn't be need.
08:08:20 <revenantphx> I suppose I could just split it at the colon instead.
08:08:27 <quicksilver> revenantphx: that was for you, about take + drop
08:08:29 <Zao> quicksilver: I prefer split, communicates it better.
08:08:31 <revenantphx> Yeah.
08:08:32 <Cale> crutcher: You can even use both at once if you want.
08:08:36 <quicksilver> Zao: sure.
08:08:43 <crutcher> Cale: crazy talk. thanks :)
08:08:57 <quicksilver> Renze: the point of --make is to select packages automatically for you
08:09:04 <quicksilver> Renze: what error do you get if you use just --make ?
08:09:07 <Zao> Or dependning on the application, regexen or a proper parser.
08:09:29 <Renze> Couldn't find module 'CGI'
08:09:53 <quicksilver> Renze: which Wash package are you using? the Wash package I'm looking at does not include a module called CGI
08:09:56 <Zao> Sounds odd to have a toplevel module name like that.
08:10:10 <Zao> The docs you used may be ancient, or you've found some ancient pacakge.
08:10:13 <Renze> the newest, downloaded yesterday
08:10:20 <Zao> Knowing WASH, it has lots of history.
08:10:23 <quicksilver> Renze: http://hackage.haskell.org/package/WashNGo ?
08:10:26 <Zao> Renze: "newest" depends a lot where you look.
08:10:36 <quicksilver> that package does not contain a module called 'CGI'.
08:10:37 <Zao> And what you mean.
08:10:39 <revenantphx> this should be fine
08:10:39 <revenantphx> sendIRC st "PONG" (drop 4 ln)
08:10:45 <Renze> yes, that one
08:10:49 <revenantphx> I can just send the body of the PING instead.
08:10:52 <Renze> I meant from hackage
08:10:54 <quicksilver> renze: so, next question - why is your code looking for a module called CGI?
08:10:57 <Renze> but, I'm coming one step further
08:11:08 <Renze> so just a few secs, so I can try to fix it myself
08:11:30 <Zao> revenantphx: Typically one tends to tokenize messages a bit more earlier than that.
08:11:38 <revenantphx> Zao: Of course.
08:11:45 <revenantphx> I'm tokenizing them in a where clause on the guard now.
08:12:19 <Renze> now he is compling it, but he says there is an unexpect '<', but that's why I'm running it from the command line right? because he has to parse it
08:12:50 <Renze> because WASH can just has plain HTML in a *.hs (well, that's what I assumed from the manual, and I just copied it from there)
08:14:25 <quicksilver> oh, there is some kind of pre-processor
08:14:28 <quicksilver> I didn't know that
08:15:28 <quicksilver> that manual looks suspicious to me.
08:15:49 <quicksilver> I don't understand the mechanism by which ghc -package WASH --make Main could invoke a preprocessor
08:16:30 <Renze> I know, but I don't know another solution
08:16:52 <quicksilver> explain to me then? How would that command invoke a pre-processor
08:17:05 <quicksilver> I would think you would have to run 'wash2hs' first
08:17:05 <ManateeLazyCat> revenantphx: Develop IRC paser? 
08:17:17 <revenantphx> One thing I just realized.
08:17:28 <revenantphx> I've never seen a non-monad, non-let haskell function. that's kind of cool.
08:17:35 <revenantphx> Like, a pure function.
08:17:37 <revenantphx> Er
08:17:41 <revenantphx> pure multiline function.
08:18:43 <Renze> you're right quicksilver; how could I save that file somewhere to be found again?
08:19:04 <quicksilver> wash2hs filename > someotherfilename
08:21:07 <reuben> Can I use record syntax on a DataType in a file i've imported?
08:21:08 <revenantphx> http://hackage.haskell.org/packages/archive/irc/0.4.3/doc/html/Network-IRC-Parser.html
08:21:10 <revenantphx> lol.
08:21:14 <revenantphx> That's a convenient library.
08:22:57 <Renze> thank quicksilver, now I can go on with the real work instead of errors :)
08:23:07 <quicksilver> :)
08:23:23 <quicksilver> Renze: I don't understand how in the manual the preprocesing seemed to happen 'automatically'
08:23:36 <quicksilver> Renze: either the manual has typoes or they are using some feature I'm unaware of.
08:23:44 <Renze> yes indeed
08:24:06 <Renze> well, bye then!
08:32:28 <revenantphx> quick question
08:32:39 <revenantphx> How do CharParsers work >_>
08:32:49 <revenantphx> I noticed this and was wondering about it
08:32:50 <revenantphx> http://hackage.haskell.org/packages/archive/irc/0.4.3/doc/html/Network-IRC-Parser.html
08:33:32 <quicksilver> it's a parsec type
08:33:53 <revenantphx> googling parsec tutorails...
08:34:15 <revenantphx> Whati s THIS
08:34:16 <revenantphx> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
08:34:21 <revenantphx> 0.o
08:36:43 <gds> @tell hpc Sorry - I got called into an unexpected meeting and didn't see your reply. Thanks :)
08:36:43 <lambdabot> Consider it noted.
08:37:14 <gds> @tell c_wraith Sorry - I got called into an unexpected meeting and didn't see your reply. Thanks :)
08:37:14 <lambdabot> Consider it noted.
08:39:23 <bluestorm> my question : why is Colin Ross on Planet Haskell ?
08:40:36 <bluestorm> I don't feel legitimate to complain about the web crap on the planet when it's done in Haskell, but why do I have to get empty posts about Javascript or the iPad in my RSS reader ?
08:41:48 <bluestorm> That's actually a serious question : who decide who's on the planet ? how long do the blogger that never talk about Haskell stay ?
08:42:15 <Cale> bluestorm: lol, his blog doesn't contain even one item containing the word Haskell.
08:43:34 <Saizan> bluestorm: iirc, planet.haskell.org has a faq about this
08:43:37 <quicksilver> Cale: according to http://sequence.complete.org/node?page=5 he used to blog on haskell.
08:44:00 <quicksilver> but I guess he lost his host / deleted all posts and hasn't made any more about haskell for a long time
08:44:11 <quicksilver> IMO, if you publish a blog, you should keep all articles around forever.
08:44:14 <quicksilver> on pain of death.
08:44:47 <bluestorm> hm
08:45:05 <Cale> hmm
08:45:29 <bluestorm> according to the FAQ, I should write an email to planet@community.haskell.org asking for the blog's removal
08:45:51 <bluestorm> but I don't feel comfortable doing so
08:46:36 <Cale> do it
08:47:55 * osfameron eventually got the planet haskell editors to point at only his tags:FP feed, because some commenters got irritable every time I posted about anything else
08:48:30 <osfameron> now is much easier to just post without worrying about annoying people (which is nice... as it's already so easy to make excuses about not blogging ;-)
08:49:02 * Saizan reads only a selected few posts out of his feeds
08:49:21 <quicksilver> I never seem to feel like reading planet haskell
08:49:22 <osfameron> the problem is that Planet Haskell is explicitly not *only* about Haskell (iirc, unless that's changed) so up to a point they also want off-topic posts, to show what haskell-programmers are interested in
08:49:41 <quicksilver> the posts are either uninteresting, or interesting.
08:49:44 <yrlnry> I like that.  
08:49:55 <quicksilver> but the interesting ones are *so* interesting, or complicated, that I don't feel I have time to read them
08:50:01 <quicksilver> at the time that I normally do an RSS-trawl ;)
08:50:16 <yrlnry> I mena, I like that PH is explicitly about "what Haskell people are thinking about", not "about Haskell".
08:50:17 <alpounet> osfameron, only "star" haskell devs "can" talk publish off-topic posts on haskell
08:50:30 * hackagebot language-css 0.0.1 - CSS 2.1 syntax  http://hackage.haskell.org/package/language-css-0.0.1 (AntonKholomiov)
08:50:33 <osfameron> ah fair enough
08:51:46 <osfameron> though I think the admins resisted setting me to tags:FP the first time I asked, so there were some mixed messages maybe
08:52:03 <bluestorm> alpounet: there is good off-topic and bad off-topic
08:53:02 <yrlnry> I think PH would be diminished by the omission of ezyang's many fascinating non-Haskell posts.
08:53:22 <bluestorm> i'd have quoted the cute John Goerzen posts
08:53:39 <bluestorm> I'm not sure which one of ezyang's post are off-topic
08:53:48 <yrlnry> That's what I like about them.
08:53:49 <bluestorm> isn't cambridge an integral part of the haskell world ?
08:54:19 <alpounet> somehow yes blackrain 
08:54:21 <alpounet> bluestorm*
08:56:27 <bluestorm> anyway, I sent the mail about vcolin.com
09:00:35 * hackagebot simple-css 0.0.1 - simple binding of css and html  http://hackage.haskell.org/package/simple-css-0.0.1 (AntonKholomiov)
09:00:59 <bluestorm> is it possible to send a mail to planet@... to persuade sigfpe of posting more often ?
09:01:40 <Saizan> send one to sigfpe directly?
09:01:43 <Botje> ofer cookies :)
09:02:03 <quicksilver> better, send some cookies to sigfpe
09:02:08 <quicksilver> and promise more if good articles follow.
09:02:15 <quicksilver> proves you are serious.
09:02:31 <quicksilver> empty promises of cookies aren't work the chocolate chips they are made of.
09:09:35 <aristid> 8 minutes ago, sigfpe was in the financial district in san francisco
09:10:00 <mwc> Is there a way to export my own bindings (to a string value) into the Paths_project file cabal generates?
09:10:13 <mwc> looking through the Distribution.Simple.* modules, nothing jumps out
09:10:25 <mwc> seems like it's one of those things that "ought" to be supported
09:11:16 <dcoutts_> mwc: what's the purpose?
09:12:08 <mwc> dcoutts_: want to export RCS information to identify builds
09:12:31 <mwc> dcoutts_: currently doing it by modifying the versionTags, but that feels kludgy
09:12:51 <dcoutts_> mwc: right versions tags are not ideal (and more or less deprecated)
09:13:11 <dcoutts_> ok, and so you want to generate this in the Setup.hs during the configure step?
09:13:36 <dcoutts_> mwc: how about just generating an extra module, do you need to modify the Paths one?
09:13:46 <mwc> dcoutts_: no, no particular reason to pick on Paths
09:14:20 <dcoutts_> mwc: e.g. see how the darcs Setup.hs generate something similar with the darcs context for dev builds
09:14:57 <mwc> dcoutts_: alrighty, I'll look into that. Trying to avoid relying on sh/Make tools so that in principle this'll work on windows assuming msys-git or the like is installed
09:29:35 <absentia> I read something the other day where someone claimed that Haskell was faster than C++ ... I need to see some numbers on that. -- anyone agree with that statement -- and have a reference for a place with numbers?
09:30:42 <opqdonut> quibbling over the relative speeds of _languages_ is quite inane
09:30:51 <absentia> I'm not quibbling.
09:31:04 <djahandarie> absentia, how do you measure the speed of a language?
09:31:14 <opqdonut> but it is surprising how fast relatively idiomatic haskell can be
09:31:32 <HalfWayMan> absentia: There is the "Great Computer Language Shootout" or whatever it is called. GHC ranks quite highly there.
09:31:33 <opqdonut> I've got no links, sorry. The programming language shootout might be relevant.
09:31:48 <opqdonut> No links to academic papers, that is.
09:31:50 <kmc> idiomatic haskell compiled in GHC can be a lot faster than idiomatic Python running in the crappy CPython interpreter
09:31:54 <kmc> that's not surprising
09:32:03 <absentia> exactly... I wonder why that statement was made... seems one case here, one case there...  for me, speed of a language is speed of developement with production (not poc or prototype) code... 
09:32:03 <djahandarie> absentia, in the shootout benchmarks GHC is slower than C++, except for one benchmark I think.
09:32:06 <opqdonut> kmc: :D No it's not
09:32:10 <romildo> Is there a function for substring replacement in the standard library?
09:32:21 <absentia> but I'm sure that's not the speed most people mean when they refer to speed of a language :-)
09:32:34 <djahandarie> absentia, but those shootout benchmarks are hardly representative of code you'd actually be writing
09:32:41 <opqdonut> romildo: no
09:32:41 <kmc> i find idiomatic Haskell rarely beats hand-coded C or C++, but (GHC) Haskell gives you lots of options for optimization by going more low-level
09:32:47 <absentia> ya, I watch the shootout all the time -- and I am familiar with the disclaimer there.
09:32:51 <opqdonut> romildo: there might be something in a package, at least for ByteString
09:32:57 <engla> no need to call CPython crappy. Python is harder to execute fast because of all the dynamic features (attribute lookup rules etc)
09:32:59 <djahandarie> Haskell goes pretty fast for anything you throw at it, and you can make it go faster with some small tweaks, and even faster with more tweaks.
09:33:02 <quicksilver> kmc: idiomatic haskell rarely beats *skilfully* hand-coded C or C++
09:33:10 <absentia> a lot of times, to get the speed in a language, the programs are poor... in the sense that they're written for speed.  :-<
09:33:13 <kmc> engla, look at a good tracing JIT
09:33:14 <quicksilver> kmc: however, most C or C++ is not skilfully handcoded.
09:33:20 <kmc> LuaJIT or V8 etc
09:33:28 <opqdonut> yeah
09:33:41 <kmc> CPython has a terrible architecture
09:33:44 <djahandarie> Man that question summoned like everyone into the room
09:33:46 <engla> kmc: yes those are for different languages. the language construction influences what the JIT can do. I know LuaJIT
09:34:05 <engla> lua is a very simple language (that's its genious) and that enables LuaJIT to be this impressive.
09:34:05 <opqdonut> my experience is that the _end result_ can look like idiomatic haskell, but still be pretty far from what you started with
09:34:17 <osfameron> wasn't there a nice article on Supero and how supercompilation *can* sometimes produce faster results than equivalent hand-written C ?
09:34:19 <opqdonut> luckily optimizing is quite fun
09:34:25 <opqdonut> optimizing haskell, that is
09:34:39 <quicksilver> osfameron: yes, it certainly can.
09:34:51 <opqdonut> lua is great
09:34:56 <quicksilver> osfameron: C is an appalling specimen, as a low level language. It maps very poorly to modern CPUs ;)
09:35:04 <HalfWayMan> osfameron: You mean this? http://community.haskell.org/~ndm/downloads/slides-supercompilation_for_haskell-03_mar_2009.pdf
09:35:09 <quicksilver> osfameron: ...on the other hand, modern C compilers are rather good.
09:35:16 <rajeshsr> hi folks!
09:35:26 <rajeshsr> visiting #haskell after a loong time!!
09:35:30 * absentia uses Objective-C -- which seems to hav a reputation for being slow... people claim C++ is inherently fast... I'm just confused.
09:35:30 <djahandarie> quicksilver, depends on who you ask ;)
09:35:36 <osfameron> HalfWayMan: yeah, probably that one or an earlier version
09:35:53 <djahandarie> quicksilver, I don't think anyone in #x264 would say that gcc is any good ;)
09:35:59 <HalfWayMan> osfameron: There is more on Neil Mitchell's blog as well.
09:36:04 <opqdonut> absentia: people claim lots of things. I usually ask for numbers :)
09:36:13 <opqdonut> (or provide them)
09:36:35 * absentia refers opq to absentia's first line in this conversation...   ---------------^ up there.
09:36:45 <opqdonut> indeed
09:36:47 <quicksilver> djahandarie: it's all relative.
09:37:07 <HalfWayMan> absentia: Well, I can claim that C is faster than C++, and then assembly code is faster than C... not that I would want to write everything in assembly code :)
09:37:09 <djahandarie> Everything!
09:37:30 <quicksilver> djahandarie: I suppose what I mean is that gcc is far from a naive C compiler; it can often produce assembly which looks nothing like the naive translation of C to asm.
09:37:46 <quicksilver> djahandarie: and, as such, it does often produce much better code than a 'naive translation' would.
09:37:58 <quicksilver> djahandarie: I'm not suggesting it often produces optimal asm.
09:38:45 <djahandarie> Right. And producing the optimal ASM is actually really hard anyways
09:39:04 <djahandarie> i.e., autovectorization
09:39:51 <quicksilver> djahandarie: extraordinarily hard on modern CPUs, yes.
09:40:05 <HalfWayMan> absentia: Are you wanting to implement something specifically, or just change language?
09:40:45 <quicksilver> djahandarie: anyhow, my point was that the further modern CPUs get from 'naive C' as an execution model, the more ground the compiler has to make, and the less C's "automatic advantage" becomes
09:41:19 <djahandarie> So we need a new low-level higher-level language? Is that what you're saying? ;)
09:41:45 <quicksilver> no, I think it's right for the compilers to do the hard work
09:41:51 <quicksilver> we just need better compilers
09:41:55 <quicksilver> and better haskell copmilers in particular :)
09:42:34 <djahandarie> The intel internship was related to making an EDSL for vectorization... or something like that
09:43:52 <djahandarie> I'm not an Expert Haskell/GHC programmer or a grad student though, so I'll wait a couple years before I apply for that haha
09:50:17 <sm> does anyone have a version of words that is quotes-sensitive, ie does not break on spaces which are inside quotes ?
09:52:21 <djahandarie> I thought that Data.Text.ICU.Break might have that, but it didn't
09:52:44 <mee> sm: that's a pretty easy thing to do with Parsec if you can't find something pre-rolled
09:53:06 <djahandarie> I'd probably do it without Parsec
09:53:36 <mee> everything is looking like a nail to me right now, as I just learned Parsec ;)
09:53:52 <crutcher> Hi; I'm using attoparsec, and I need something that fails
09:53:57 <crutcher> I'm not sure how to do that
09:54:09 <dom96> I had bad experiences with parsec.
09:54:40 <crutcher> something like: Bool -> Parser a -> Parser a
09:54:46 <crutcher> where bool fails
09:54:49 <sm> thanks
09:55:00 <crutcher> is it just error?
09:55:08 <crutcher> or fail?
09:57:28 <djahandarie> crutcher, a lot of things can make it fail
09:57:56 <djahandarie> I don't think the monad fail function will make the Result fail though, I think it actually throws an error. Could be wrong though
09:58:02 <crutcher> I want to test a bool, and if true, continue, and if not true, fail
09:58:21 <crutcher> there was a method for this in parsec I think
09:58:31 <crutcher> but I'm not finding anything in attoparsec
09:59:29 <monochrom> is an instance of MonadPlus
09:59:33 <monochrom> @type guard
09:59:34 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
09:59:46 <monochrom> applies to attoparsec
09:59:52 <monochrom> @type mzero
09:59:53 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
09:59:54 <monochrom> applies to attoparsec
10:00:29 <crutcher> I tried: guard (n > 0) $ fail "msg"
10:01:01 <djahandarie> mzero is a failDesc "mzero"
10:01:17 <djahandarie> You can just call failDesc on a condition, the function isn't difficult to write yourself
10:01:24 <djahandarie> (If you want a custom error)
10:02:13 <monochrom> guard (n>0) <?> "msg"
10:04:33 <crutcher> monochrom: no, that doesn't use the "msg"
10:12:08 <crutcher>   unless (n > 0) $ fail "boom"
10:12:11 <crutcher> does the right thing
10:16:38 <dom96> I think you need to use try, if you want the message to be displayed.
10:17:51 <crutcher> does anyone know why hoogle is down?
10:17:58 <crutcher> it's been down for a day or so now
10:22:16 <dom96> @hoogle try
10:22:17 <lambdabot> Control.Exception try :: Exception e => IO a -> IO (Either e a)
10:22:17 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
10:22:17 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
10:22:34 <dom96> The API still works?
10:23:15 <Cale> I don't think that accesses the web version of hoogle.
10:27:56 <revenantphx> is there a ghc flag to make it clean up the object files it produces?
10:38:03 <ClaudiusMaximus> revenantphx: there are flags to get it to put .o/.hi files into a different directory, not sure if there's one to delete them
10:45:31 <dom96> Does Network.Browser support SSL? If not what's the best alternative?
10:47:36 <romildo> I need a function to create a directory given its path, and returns a "Maybe FilePath": "Nothing" for a failure, and "Just path" otherwise. As I am not yet good at exception handling, would someone help me with this function?
10:50:40 * hackagebot bindings-sc3 0.0.0 - Bindings to the SuperCollider synthesis engine library.  http://hackage.haskell.org/package/bindings-sc3-0.0.0 (StefanKersten)
10:53:18 <maurer_> Does anyone know of a compiler that uses the haskell LLVM bindings? I keep finding myself needing dependent types, and I'm sure there has to be a way around this...
10:53:51 <vincenzo61066|3> ciao
10:54:00 <vincenzo61066|3> !list
10:54:55 <maurer_> (the specific problem I'm encountering is that defining a function requires you to define it with its type, but given that I am compiling a file which is handed to me, I cannot possibly know the type before runtime)
10:56:30 <Saizan> (existentials?)
10:56:47 <Saizan> (or rankN polymorphism anyway)
10:57:02 <maurer_> Saizan: Is that directed at me?
10:57:22 <Cale> maurer_: yes
10:57:42 <Cale> Existentials are actually what I was thinking too, but I know nothing about the specifics of the LLVM binding.
10:57:59 <Cale> I could perhaps take a look at it for you
10:58:06 <EvanCarroll> why doesn't my bracketing work here : mapMaybe (\case x of { (Just x) -> Just (x+4); Nothing -> 0 } ) $ [Just 4, Nothing]
10:58:11 <EvanCarroll> and is there a better way to write that?
10:58:24 <Cale> EvanCarroll: \case ?
10:58:29 <maurer_> Cale: I was thinking of using existentials, and those may work for calling the function later, but defining the function in the first place is the hard bit
10:58:51 <maurer_> The LLVM bindings use typeclasses parameterized on the type of the function in order to define it :(
10:59:03 <berit> what's up with hoogle?
10:59:10 <EvanCarroll> Cale: nifty: mapMaybe (\x -> case x of { (Just x) -> Just (x+4); Nothing -> Just 0 } ) $ [Just 4, Nothing]
10:59:22 <Cale> maurer_: Well, what function in particular, so that I can look at the type signature
10:59:24 <berit> really need it now..
10:59:39 <Cale> berit: What are you trying to look up?
11:00:00 <berit> I'm looking for Data.Set but the site is down (500 internal).
11:00:26 <berit> guess I should get used to some offline stuff..
11:00:56 <Cale> http://hackage.haskell.org/packages/archive/containers/0.4.0.0/doc/html/Data-Set.html
11:00:59 <Cale> Or just use the documentation on Hackage
11:01:30 <berit> sweet, thanks!
11:03:06 <maurer_> Cale: onesec
11:03:39 <maurer_> Cale: defineFunction
11:03:54 <maurer_> The type "f" in that constraint is what I'm having troubles with
11:07:52 <Cale> maurer_: If all else fails, you might be able to steal the source of defineFunction and use it at a different type.
11:09:11 <Cale> Function a is internally just a pointer
11:09:15 <maurer_> Yes.
11:10:06 <maurer_> I may end up mucking around with the LLVM package internals, but I was hoping someone had already written a compiler using it so that I could see how they dealt with the multi-typing issue.
11:10:22 <maurer_> (I have seen a unityped compiler hooked up to this, but that's it)
11:10:55 * hackagebot hsc3-process 0.4.0 - Create and control scsynth processes  http://hackage.haskell.org/package/hsc3-process-0.4.0 (StefanKersten)
11:11:44 <maurer_> I was thinking of trying something like variadic functions, but unfortunately the recursion done in the funcArgs typeclass will not work correctly with that.
11:13:34 <Cale> preflex: seen bos
11:13:34 <preflex>  bos was last seen on #ghc 2 days, 19 hours, 38 minutes and 38 seconds ago, saying: Igloo: oh, and the patches should apply to both 7.0.2 and HEAD
11:13:46 <bos> Cal>
11:13:50 <bos> Cale: ?
11:13:50 <Cale> hey
11:14:02 <Cale> maurer has a question about the LLVM bindings :)
11:15:32 <Cale> (specifically, how to make calls to createFunction/defineFunction statically typecheck when you don't statically know the types of the functions you're going to be compiling -- I'm thinking something with existentials, but perhaps you have a clearer idea of how things should go)
11:22:03 <MrAI> data Months = Jan | Feb | Dec
11:22:03 <MrAI> summer :: Months -> Bool
11:22:04 <MrAI> summer Jan = True
11:22:05 <MrAI> Is that right?
11:22:22 <benmachine> MrAI: only if you're in the southern hemisphere :P
11:22:27 <MrAI> haha thanks
11:22:27 <Cale> MrAI: It is if you're in Australia
11:22:31 <MrAI> :D
11:22:43 <benmachine> MrAI: although, summer is a partial function - summer Feb is an error
11:23:13 <MrAI> summer Feb = False, is wrong?
11:23:23 <benmachine> no it's right
11:23:34 <benmachine> well, issues of what actual season February is aside
11:23:49 <c_wraith> hmm.  the paper link on http://www.cse.chalmers.se/~hallgren/Papers/wm01.html 404s.  Anyone know where I can find that paper?
11:23:50 <MrAI> :)
11:23:50 <lambdabot> c_wraith: You have 1 new message. '/msg lambdabot @messages' to read it.
11:24:04 <benmachine> I meant that, if that's the only clause you have, then you haven't said what summer Feb is
11:24:21 <MrAI> Ah I have the others also :)
11:24:24 <benmachine> oh right
11:24:30 <MrAI> Just didnt want to paste too much cod
11:24:32 <MrAI> *code
11:24:37 <benmachine> that's what hpaste.org is for :)
11:25:18 <MrAI> So when do you need to add an input to the constructor? I also have made this:
11:25:24 <MrAI> data Shape = Square Int | Rectangle Int Int  | Circle Int
11:25:24 <MrAI> prim :: Shape -> Int
11:25:24 <MrAI> prim (Square x) = x*4
11:25:31 <MrAI> (Ignore the fact the other two are not there)
11:25:52 <benmachine> that looks sensible
11:25:59 <benmachine> what do you mean by an input?
11:26:24 <MrAI> Well: data Tree a = Leaf a | Node (Tree a) (Tree a)
11:26:32 <MrAI> Tree takes in an input as a in the constructor
11:26:48 <MrAI> Why/When do I need to do that?
11:27:00 <Cale> mkTree = Node (Leaf 5) (Node (Leaf 7) (Leaf 9))
11:27:05 <Cale> er, myTree
11:27:20 <benmachine> MrAI: Trees contain stuff in a tree shape
11:27:31 <benmachine> like lists contain stuff in a list shape
11:27:35 <Cale> myTree :: Tree Integer
11:27:39 <MrAI> Ah because its been recursively defined
11:27:44 <benmachine> well no
11:27:55 <benmachine> the recursion is interesting but not necessary
11:28:00 <benmachine> data Maybe a = Nothing | Just a
11:28:04 <MrAI> To help the type checker?
11:28:07 <BONUS> MrAI: you could have data Shape a = Square a | Rectangle a a | Circle a
11:28:08 <lambdabot> BONUS: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:28:11 <benmachine> ^ Maybes wouldn't be very interesting if they didn't take an input
11:28:13 <Cale> Well, both trees and lists are recursively defined -- the recursion is somewhat responsible for the tree shape :)
11:28:20 <BONUS> and then you'd be able to use eithe an Int or a Double or anything
11:28:35 <benmachine> ah wait
11:28:41 <benmachine> MrAI: are you talking about the type constructor?
11:28:53 <benmachine> i.e. Shape in your example
11:28:56 <BONUS> he's asking why the need for type parameters
11:28:57 <MrAI> The "data Tree a" part
11:29:01 <Cale> MrAI: yeah
11:29:06 <benmachine> rather than Square or Rectangle or Circle which are value constructors
11:29:13 <benmachine> oh ok
11:29:14 <Cale> MrAI: So the type constructor there takes a type parameter 'a'
11:29:20 <MrAI> Im following
11:29:28 <Cale> MrAI: Which is going to be the type of the values stored in the tree
11:29:38 <Cale> So that you can have  Tree Integer  or  Tree String
11:29:41 <MrAI> Yep
11:29:50 <Cale> for trees of Integers or Strings respectively of course :)
11:30:10 <BONUS> MrAI: say you have data Pair = Pair Int Int that represents a pair of Ints. what if you want a pair of strings? ok well then make data StringyPair = StringyPair String String
11:30:13 <Cale> and you can even write fun things like   mapTree :: (a -> b) -> Tree a -> Tree b
11:30:17 <MrAI> So the type in the constructor helps the type checker determine how to build it?
11:30:28 <BONUS> this would suck if you had to make a separate type for each of the contents type of the pair
11:30:36 <Cale> MrAI: Well, it certainly aids typechecking.
11:30:38 <BONUS> so you can do data Pair a = Pair a a
11:30:42 <Cale> MrAI: It's part of the type of the tree.
11:30:47 <BONUS> so now your data type can be a pair of anything
11:31:04 <Cale> MrAI: If you didn't have the parameter, you'd be stuck with values of only a single type in your trees
11:31:16 <MrAI> Ah I see
11:31:22 <benmachine> MrAI: so basically it provides flexibility
11:31:26 <Cale> MrAI: This way, you can write functions like  size :: Tree a -> Integer   which work for all types of trees at once
11:31:27 <MrAI> Yep
11:31:35 <MrAI> Im with you all :D
11:32:03 <MrAI> Thanks: benmachine, BONUS, Cale,
11:33:13 <MrAI> Im also having trouble with types at the moment - but im not sure what about them im not getting. Could someone provide a basic example?
11:33:22 <benmachine> MrAI: of a type?
11:33:26 <c_wraith> also, is there a summary of the differences between containers-0.3.0.0 and containers-0.4.0.0 somewhere?
11:33:28 <MrAI> In defining your own type
11:33:44 <MrAI> e.g. type TheI = [Int]
11:33:57 <shachaf> MrAI: That's not defining your own type.
11:34:11 <shachaf> MrAI: It's just giving a different name to the same type.
11:34:18 <shachaf> MrAI: "type" is more or less "#define".
11:34:22 <benmachine> c_wraith: does reading 'darcs changes' count? :P
11:34:27 <MrAI> I see
11:34:38 <c_wraith> benmachine: I guess it would if I grabbed the repo :)
11:34:39 <MrAI> Synoums they are called? or something close?
11:34:45 <opqdonut> type synonyms, yes
11:34:46 <benmachine> c_wraith: http://darcs.haskell.org/packages/containers/ then
11:34:52 <benmachine> I didn't see a changelog obviously anywhere
11:34:54 <opqdonut> data and newtype define types
11:34:59 <benmachine> there might be if you poke around the trac or something
11:35:16 <MrAI> I see. So how do I use them?
11:35:29 <MrAI> Wait I should look that up myself :)
11:35:34 <benmachine> MrAI: you use them for convenience or documentation
11:36:06 <MrAI> They confuse me sometimes, lol
11:36:44 <c_wraith> ok....  step one, cabal install darcs
11:38:10 <Cale> MrAI: Use type synonyms sparingly, since they can make it confusing to work out exactly which functions can be used with what.
11:38:31 <MrAI> I think thats maybe my problem - but again im not sure :)
11:39:02 <Cale> MrAI: They don't really define new types, they just define syntax sugar for existing types.
11:39:30 <Cale> type String = [Char]  for example, just means that wherever the type 'String' occurs, it's as if you've written '[Char]' there.
11:39:41 <MrAI> Yep
11:40:43 <c_wraith> hey, looks like darcs has had some real network performance improvements since the last time I used it.
11:40:46 <c_wraith> that's good to see
11:41:22 <benmachine> so guys, I'm working on a thing for inferring the type of a haskell-src-exts expression
11:41:45 <benmachine> I got it to successfully infer the most general type of the S combinator, woo
11:41:48 <c_wraith> This get would have taken about 20x longer before, I suspect.
11:42:09 <FauxFaux> c_wraith: The darcs team has seen a massive boost in productivity since they started tracking their code with git.
11:42:20 <benmachine> but the really important question: what to name the module :O
11:42:36 <benmachine> FauxFaux: lol
11:42:37 <c_wraith> benmachine, that's also the hardest question :)
11:43:04 <benmachine> yeah but seriously I'm going to github this somewhere I guess
11:43:15 <benmachine> I wonder if I should tell haskell-cafe about it
11:43:21 <benmachine> or get it working on more than just lambdas first >_>
11:43:36 <benmachine> I'm actually not even on -cafe at the moment
11:43:46 <benmachine> it was super heavy traffic last I checked
11:44:48 <benmachine> although
11:44:53 <benmachine> what do people think would be more interesting
11:45:00 <c_wraith> most of the changes to containers-0.4.0.0 appear to be Milan Straka's performance enhancements
11:45:04 <benmachine> mm
11:45:56 <benmachine> should I work on completing the type inference engine, or should I take it in a different direction
11:46:12 <benmachine> and make it show the steps of type inference
11:46:24 <benmachine> so people can see what's going on
11:47:03 <mreh> is it possible to have a polymorphic monad transformer with a specific monad in it
11:47:21 * sinelaw__ decided that optimization dev. should be priced at $1 per milli improvement
11:47:30 <sinelaw__> just "earned" $5000!
11:47:40 <mreh> specifically a (Trans t) => t m that implements Monad
11:48:06 <benmachine> mreh: huh? you mean, regardless of if m is a Monad?
11:48:07 <mreh> because (Trans t) => t m is not a Monad by default
11:48:15 <mreh> benmachine: no
11:48:42 <benmachine> Monad m => Monad (StateT s m) certainly exists
11:49:08 <EvanCarroll> when matching against type `Maybe a`, is it advisable to deconstruct for Nothing? or is `case x of { (Just x) -> ...; _ -> ... }`, ok? if there are only two constructors do you test for the second or just wildcard it?
11:49:28 <benmachine> EvanCarroll: personally I think it's clearer to match against Nothing but it's not a big deal
11:49:46 <benmachine> EvanCarroll: if you have a nontrivial pattern in Just x, the difference is relevant
11:49:50 <roconnor> What are the standard references about lenses (aka functional references) for functional languages such as Haskell?
11:49:51 <mreh> I want (Trans t) => t Either a
11:50:01 <Cale> I often want to match the Nothing first and get it out of the way, because it's usually simpler.
11:50:15 <Cale> roconnor: A blog post...
11:50:36 <benmachine> mreh: you could make a value of type (MonadTrans t) => t Maybe a
11:50:41 <benmachine> :t lift Nothing
11:50:42 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t) => t Maybe a
11:50:43 <mreh> but I want (t Either) to be a Monad
11:50:50 <Cale> by twanvl
11:51:13 <benmachine> mreh: pretty sure there are some t for which it isn't
11:51:41 <benmachine> mreh: if you want that as a constraint, I think FlexibleContexts will let you go (Monad (t Maybe))
11:51:46 <mreh> benmachine: but I want to implement it that way, I want to use the Monad interface of (t Either)
11:51:51 <benmachine> ah
11:51:51 <roconnor> Cale: I'm sure it was established well before twanvl excellent blog post.
11:51:57 <mreh> benmachine: ah, great
11:52:08 <benmachine> :t lift Nothing >>= return
11:52:09 <lambdabot> forall a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad (t Maybe)) => t Maybe a
11:52:16 <benmachine> there you go :)
11:52:27 <benmachine> (p.s. Either isn't a monad, (Either e) is :P)
11:52:34 <mreh> yah yah, :)
11:52:54 <Cale> http://www.st.cs.ru.nl/papers/2005/eves2005-FFormsIFL04.pdf is apparently relevant
11:52:54 <mreh> I can't parse what you just wrote
11:53:03 <benmachine> which
11:53:11 <mreh> lift Nothing >>= return
11:53:17 <benmachine> oh
11:53:32 <mreh> practice, I'm new to monad in disguise
11:53:42 <benmachine> (lift Nothing) >>= return -- better?
11:54:03 <benmachine> lift x takes a value in a monad and puts it in a transformed monad
11:54:09 <benmachine> m a -> t m a
11:54:26 <roconnor> Cale: that looks goodish
11:54:27 <benmachine> then >>= return doesn't do anything interesting, except demands that the type we're using is a monad
11:54:27 <mreh> so t m a is a monad for that to be possible
11:54:31 <mreh> yah
11:54:39 <benmachine> :t lift
11:54:41 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:54:44 <mreh> t Maybe that is
11:55:09 <benmachine> for lift Nothing to be possible, we need Maybe a monad and 't' a MonadTrans
11:55:43 <roconnor> Cale: it referes to Kagawa's Compositional references for stateful functional programming.
11:57:48 <Saizan> roconnor: pierce has quite a few publications on lenses, not sure if they are functional or not
11:58:11 <roconnor> Saizan: yes, I was looking at those, but they seem to talk more about Harmony than Haskell
11:58:37 <roconnor> Saizan: I wonder if he was the one to call these things lenses
11:58:55 <roconnor> Kagawa calls it "Mutable"
12:00:55 <dpratt71> is the next version of the Haskell Platform (first quarter 2011?) likely to be based on GHC 7?
12:02:26 <c_wraith> dpratt71, I would assume so
12:03:13 <dpratt71> c_wraith: ok, thanks
12:04:58 <MrAI> Please help: http://pastebin.com/yRAHDwXA
12:05:49 <c_wraith> MrAI, I'm not really clear on what the function is supposed to do.  The type alone isn't enough to tell me.
12:06:02 <c_wraith> Is it supposed to list ever path in the tree?
12:06:06 <MrAI> Yes
12:06:08 <c_wraith> err, *every
12:06:31 <c_wraith> But not the value at the end of that path?
12:06:36 <MrAI> No
12:06:39 <c_wraith> ok
12:06:39 <MrAI> Well yes
12:06:51 <MrAI> It should just say its journey not its value
12:07:33 <c_wraith> yeah.  Ok, so your basic idea is right...
12:07:43 <MrAI> Base case and rest
12:07:44 <c_wraith> though the code you have commented out is clearly wrong, as you probably realize :)
12:07:50 <MrAI> Yes, lol
12:08:00 <Cale> MrAI: The base case is wrong.
12:08:10 <c_wraith> Cale, I think the base case is right.
12:08:15 <Cale> MrAI: There's one path in the tree which is just a leaf, the empty path.
12:08:21 <MrAI> If its a Leaf I dont know if its Left or Right. So I left it empty
12:08:25 <c_wraith> oh, you're right.
12:08:31 <c_wraith> It needs to return [[]]
12:08:47 <MrAI> Ah ok
12:08:55 <MrAI> Why again?
12:09:01 <c_wraith> read cale's remark again
12:09:15 <c_wraith> there *is* a path in the leaf node...  the empty path
12:09:21 <MrAI> Ah I get it
12:10:02 <c_wraith> I'd recommend starting by breaking it down into: paths (Node l r) = leftPaths ++ rightPaths where ...
12:10:12 <c_wraith> And then figure out how to implement each of leftPaths and rightPaths
12:10:52 <MrAI> lefthpaths :: Tree a -> [Path], define that?
12:11:04 <c_wraith> No, just have them be local subexpressions
12:11:06 <c_wraith> Not functions
12:11:14 <c_wraith> that's why I put the "where" in there
12:11:54 <MrAI> Ah i see
12:12:05 <c_wraith> http://pastebin.com/bRWpDXKv
12:12:13 <c_wraith> contains Cale's fix and my suggestion
12:12:32 <MrAI> Yep Im with you
12:12:52 <c_wraith> and each of those subexpressions will contain a recursive call to paths, of course
12:13:11 <MrAI> Yes
12:13:21 <c_wraith> So, what do you want to do with the result of each recursive call?
12:13:30 <c_wraith> That's the only interesting part left :)
12:13:46 <MrAI> I want it to put in a [L] if its left and [R] if its a right
12:14:12 <MrAI> Straight off the top of my head im thinking (test L) ++ paths(l)
12:14:13 <c_wraith> I think, expressed in a slightly different way, what you want to do is prepend either L or R to each returned list, right"
12:14:28 <c_wraith> s/"/?
12:14:28 <MrAI> Yep
12:14:39 <MrAI> ?
12:14:53 <c_wraith> sorry, perl-ism for correcting my typo.  though I mangled that too
12:15:07 <MrAI> Ah
12:15:25 <c_wraith> anyway.  You want to perform an operation on each returned element.  What operation does this suggest?
12:16:03 <MrAI> I know I want [L, + rest of tree]
12:16:37 <c_wraith> I meant the operation of "generating a new list based on modifying each element of an existing list"
12:17:50 <c_wraith> that's a very common pattern, and there's a name for it in haskell.  Actually, there are like 4 names for it in the standard library, but there's one that's most common.  :)
12:18:30 * hackagebot rdtsc 1.1.3 - Binding for the rdtsc machine instruction  http://hackage.haskell.org/package/rdtsc-1.1.3 (MartinGrabmueller)
12:18:57 <MrAI> Im thinking - a little lost :)
12:19:25 <MrAI> Im so used to thinking bottom up, not top down
12:19:26 <c_wraith> > map (* 2) [1..5]
12:19:27 <lambdabot>   [2,4,6,8,10]
12:19:38 <MrAI> I was going to go with map
12:19:40 <berit> fold?
12:20:25 <c_wraith> yes, map is what I had in mind.  (also spelled <$>, fmap, and liftM in various points in the standard library, but don't worry about that)
12:20:26 <SKK> hey there
12:20:39 <MrAI> haha ok I wont
12:20:52 <benmachine> :t liftA
12:20:53 <MrAI> So we have the big list, with map adding new lists on to it
12:20:53 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (a -> b) -> f a -> f b
12:21:00 <c_wraith> oh, right, I forgot about liftA :)
12:21:08 <benmachine> it's almost useless :P
12:21:15 <benmachine> but there it is anyway
12:21:26 <SKK> anyone tried ghc7 yet?
12:22:02 <c_wraith> MrAI, so each recursive call gives you a resulting list of paths.  To each path, you want to prepend either L or R, depending on if it's the leftPaths or rightPaths
12:22:41 <MrAI> Thats the bit I dont know, how do I prepend either L or R? Which is where my problem of understanding synoums came in
12:22:50 <c_wraith> just use (:)
12:23:02 <c_wraith> They are still lists.  the standard list constructor still works
12:23:03 <MrAI> test L before the rest of the list?
12:23:09 <c_wraith> you don't need to test anything
12:23:21 <MrAI> Just use [L]?
12:23:36 * hackagebot cpuid 0.2.1 - Binding for the cpuid machine instruction on x86 compatible  processors  http://hackage.haskell.org/package/cpuid-0.2.1 (MartinGrabmueller)
12:23:45 <c_wraith> You already know which ones are the left children, because they came from the left subchild
12:23:56 <c_wraith> And you know they all need to have L prepended
12:24:05 <MrAI> Yep
12:24:13 <MrAI> So the test function is useless really?
12:24:18 <MrAI> *definition
12:24:19 <c_wraith> But use (L:) instead of ([L] ++)
12:24:27 <c_wraith> it's clearer, and more efficient
12:25:07 <c_wraith> well, it's probably not more efficient with all the optimizations ghc has for lists.  But it's still clearer.
12:25:33 <EvanCarroll> what if you're using ByteStrings?
12:25:57 <c_wraith> EvanCarroll, then none of this applies.  but these aren't even strings.  they're lists of a custom enumeration :)
12:26:34 <MrAI> Are the brackets necessary? In both cases above
12:26:46 <c_wraith> you mean the parentheses?
12:26:49 <MrAI> Yes
12:26:56 <c_wraith> I'm using section syntax there
12:27:18 <c_wraith> Those indicate functions that are made by partially applying an infix function.
12:27:28 <c_wraith> :t (2:)
12:27:30 <lambdabot> forall t. (Num t) => [t] -> [t]
12:27:34 <MrAI> ok
12:27:35 <c_wraith> :t ([2] ++)
12:27:36 <lambdabot> forall t. (Num t) => [t] -> [t]
12:27:44 <Cale> > (2:) [5,6,7]
12:27:45 <lambdabot>   [2,5,6,7]
12:28:06 <MrAI> I see
12:28:34 <ion> In other words (2:) is syntactic sugar for \x -> 2:x and ([2] ++) is syntactic sugar for \x -> [2] ++ x
12:29:01 <MrAI> I got it
12:29:39 <sinelaw> preflex, seen Peaker
12:29:39 <preflex>  Peaker was last seen on #haskell 2 days, 22 hours, 3 minutes and 50 seconds ago, saying: Cin, I discovered that if I work on that project, though, I cannot work on challenging projects at my workplace (if they're not the "top idea in my mind") so that's why I'm suspending it (I hope to finish the current project finally and leave :-)
12:29:40 <sinelaw> preflex, seen PeakerWork
12:29:40 <preflex>  PeakerWork was last seen on ##c 41 days, 3 hours, 43 minutes and 4 seconds ago, saying: Wulf: Yeah, I found that as well
12:29:58 <sinelaw> ooh
12:30:14 <shachaf> c_wraith: Would you say that "a ++ b : c" is clearer than "a ++ [b] ++ c"?
12:30:19 <benmachine> did he lose his job? :P
12:30:29 <benmachine> oh wait
12:30:30 * benmachine reads
12:30:50 <benmachine> shachaf: I think it depends
12:30:57 <benmachine> so, not always
12:30:57 <sinelaw> benmachine, he's quite an asset for them i think :)
12:31:09 <benmachine> sinelaw: did his job lose him :P
12:31:11 <c_wraith> shachaf, in that case, I'd say the latter is clearer, sure.  But for the case of "prepending a single element" as the only operation going on, I wouldn't. :)
12:31:15 <sinelaw> benmachine, no
12:31:23 <benmachine> mm
12:31:50 <shachaf> c_wraith: I think the clearest advantage of (x:) is that you can pattern match with it.
12:32:01 <SKK> a stupid question.  if i build ghc7.0 from source, will it have cabal-install?  and how do I install it from ghc? (I have crispy clean installation, so it doesn't have anything yet.)
12:32:45 <benmachine> cabal-install doesn't come with GHC
12:33:00 <benmachine> it will have the Cabal library but you have to install cabal-install separately
12:33:07 <c_wraith> SKK: cabal-install also doesn't build on ghc 7 last I heard.  But you can use an existing cabal binary
12:33:16 <SKK> ouch!
12:33:17 <benmachine> by manually installing like the two dependencies
12:33:19 <SKK> scary
12:33:30 <SKK> so wait, how do install cabal-install then?
12:33:42 <SKK> oh yes, but that's a pain too, last time i tried
12:33:42 <benmachine> SKK: I think it comes with a bootstrap script
12:33:58 <benmachine> they intentionally keep dependencies small to make this stuff less painful :)
12:34:44 <SKK> ok thx ben.  might have to ask something else in the course of the next 30-90 minutes... :"(
12:35:04 <benmachine> c_wraith: some dependency stuff for GHC 7 got mentioned in recent darcs logs
12:35:13 <SKK> wait --- it doesn't build you said?
12:35:26 <benmachine> SKK: the darcs version might, if you're feeling adventurous :D
12:35:28 <c_wraith> MrAI, How is it going?  You should have all the basic pieces now.
12:35:35 <benmachine> uh but, you probably don't have darcs >_<
12:35:45 <SKK> i am *NOT* feeling adventurous! I just want to get it over with :o
12:35:55 <benmachine> SKK: then why are you installing GHC 7 >_>
12:36:00 <SKK> darcs doesn't come with ghc either?
12:36:04 <benmachine> nah
12:36:05 <MrAI> c_wraith: Icky, lol
12:36:16 <SKK> :'(
12:36:17 <benmachine> GHC by itself is huge, don't want to bloat it any further :x
12:36:37 <benmachine> there might be binary packages for your platform though?
12:36:50 <SKK> couldn't they just add the tiny cabal-install so that people don't have to read bootstrapping manuals
12:36:59 <dpratt71> well, I've toyed around with Haskell long enough and now I think it's time for me to create something serious...
12:37:07 <dpratt71> ...a sudoku solver!
12:37:23 <arcatan> people usually don't bother with compiling GHC without a good reason
12:37:24 <benmachine> SKK: GHC 7 is new enough that this stuff isn't easy yet, but it will be
12:37:34 <benmachine> SKK: when the libraries and utilities have caught up
12:37:46 <benmachine> SKK: I'd just recommend going with the latest haskell-platform and GHC 6.12
12:38:01 <dpratt71> haven't gotten very far and yet I've come up with a bunch of questions
12:38:04 <SKK> hm...
12:38:10 <dpratt71> mostly about my approach
12:38:22 <SKK> haskell-platform requires ghc too though?
12:38:24 <MrAI> c_wraith: I tried leftpaths = (L:) paths(l)
12:38:47 <SKK> so wait say again --- getting binary for cabal-install means installing the two dependencies? 
12:39:00 <c_wraith> MrAI, you forgot about the map. :)
12:39:16 <arcatan> SKK: platform comes with GHC
12:39:25 <dpratt71> at first I thought to represent the value of a single cell as an ADT...something like data Cell = Blank | Is Int...
12:39:33 <benmachine> SKK: or getting the platform, which comes with it :)
12:39:36 <Cale> SKK: You still probably shouldn't be compiling GHC on your own... There are binaries, you know :)
12:39:42 <MrAI> c_wraith: I also tried leftpaths = map (L:) paths(l)
12:40:02 <dpratt71> then I thought that maybe that was overkill and decided that cell values were Int and 0 = blank
12:40:08 <Cale> MrAI: surely you want that to be (paths l)
12:40:11 <c_wraith> MrAI, that last one is close, but a type error.  
12:40:15 <dpratt71> good decision, or no?
12:40:16 <c_wraith> Cale's suggestion fixes it. :)
12:40:20 <SKK> ok... that's like 5 ppl saying "SKK, don't get the latest version of ghc7"
12:40:54 <Zao> SKK: I foolishly installed 7.
12:40:57 <SKK> but what's wrong with being up to date?
12:41:01 <Zao> I'm window-manager-less now.
12:41:08 <Zao> SKK: It's brand new, and quite different inside.
12:41:13 <SKK> i don't need a haskell window manager :-/
12:41:15 <c_wraith> SKK: until libraries get up to date, it's more of a pre-release
12:41:21 <Zao> SKK: As such, most of the ecosystem isn't up to date yet.
12:41:27 <benmachine> SKK: you're more up-to-date than library authors are :)
12:41:46 <Zao> Heck, I can't even build Cabal.
12:41:47 <MrAI> c_wraith: Ah silly thing
12:41:53 <SKK> so what percentage of the library does not compile with ghc7?
12:41:56 <MrAI> c_wraith: Haskell is so unforgiving ;)
12:42:03 <Zao> SKK: "the library" is a vague expressin.
12:42:05 <SKK> Zao: ????  Doesn't cabal come with ghc??
12:42:11 <Zao> SKK: We're talking about Hackage in general.
12:42:18 <Zao> SKK: Depends on what version you want.
12:42:27 <SKK> the library ::= standard stuff that you use day to day
12:42:51 <SKK> why can't you use the latest version?
12:43:16 * arcatan uses the GHC 7.0.1 binary
12:43:22 <MrAI> c_wraith: I tried throwing tree1 = Node (Leaf 8) (Leaf3), and it didnt like it
12:43:40 <benmachine> MrAI: space?
12:43:43 <Zao> SKK: I haven't fecked around much with it on non-Windows, but today I tried migrating to GHC7, with catastrophic results.
12:43:43 <benmachine> Leaf 3
12:43:59 <Zao> I hope I can downgrade before my office hours tomorrow :D
12:44:02 <MrAI> c_wraith: "No instance for ( Show Dir)"
12:44:15 <MrAI> benmachine: What do you mean by space ?
12:44:21 <arcatan> SKK: you can use the latest version, but you have to be ready to encounter some problems
12:44:40 <benmachine> MrAI: in between Leaf and 3 I think there should be a space
12:45:00 <benmachine> SKK: being on the cutting edge means being adventurous
12:45:03 <MrAI> benmachine: Just a typo by me typing it here :)
12:45:12 <benmachine> MrAI: oh, k
12:45:27 <SKK> i'm ok with problems with libraries, since i don't use anything fancy yet, but i'd like to have cabal-install without getting brain damage
12:45:47 <midorikid> I parallelized my GA with "parMap (rseq `dot` rpar) evalFitness population" and now it segfaults or freezes, alternately. :(
12:46:07 <MrAI> c_wraith: It compiles fine. But when I throw something at it - it doesnt like it
12:46:37 <SKK> so arcatan -- did you get cabal-install to install?
12:46:37 <benmachine> SKK: you either get the darcs version, or you twiddle the cabal file a bit, or you get a binary, or you get GHC 6.12
12:46:41 <c_wraith> MrAI, the "no instance for show" thing means you should add "deriving Show" at the end of the definition of Dir
12:47:19 <Cale> midorikid: I don't understand why you're composing rseq and rpar like that.
12:47:20 <SKK> could "twiddling" entail more than erasing dependency constraints?
12:47:29 <benmachine> SKK: I don't expect so
12:47:31 <benmachine> but I'm not sure
12:47:32 <arcatan> SKK: I'm using cabal-install built with previous version of GHC, left from my previous install
12:47:40 <Cale> midorikid: You should just parMap rseq ...
12:47:42 <SKK> ok, then i'll give it a shot
12:47:57 <SKK> thx, until some time from now
12:47:57 <c_wraith> MrAI, beyond that, I'd suggest posting your code for paths in its new state
12:48:07 <Cale> midorikid: But that doesn't explain why it would segfault or freeze.
12:48:52 <MrAI> c_wraith: http://pastebin.com/jzkCMjJQ
12:48:55 <SKK> question: did you say it worked with darcs?  and how do i install darcs without cabal?
12:48:56 <midorikid> Cale: Honestly, I don't understand why either. I want parallel evaluation but without the both I get no speed up (and only a single core is loaded).
12:49:38 <Cale> midorikid: Are you compiling with -threaded and running the program with +RTS -n2 ?
12:49:46 <arcatan> SKK: probably something like this: http://darcs.net/manual/node8.html#SECTION00820000000000000000
12:49:47 <SKK> the whole ghc installation process contains a good amount of recursion
12:49:51 <MrAI> c_wraith: I dont know what you mean with the 'Show'
12:49:56 <midorikid> Cale: I suspect the crashing is due to a library I'm using being nonthread safe. (hmatrix maybe)
12:49:58 <MrAI> c_wraith: Where do I put it?
12:50:15 <c_wraith> MrAI, http://pastebin.com/NK1MNN5V has the deriving thing.  That's necessary if you want to be able to see your results in GHCi.  Basically, it just means "make this printable".  Don't worry about the details beyond that for now
12:50:26 <midorikid> Cale: Yes and yes. If I change it to -n1 the bad behavior stops.
12:50:28 <SKK> thx
12:51:10 <Cale> midorikid: Yeah, segfaults are almost always the fault of some C library which is being used via FFI (they could theoretically be compiler bugs, but that's rare by comparison)
12:51:29 <c_wraith> MrAI, if you want to be able to print Trees too, you probably should add the same deriving clause to its declaration
12:52:06 <MrAI> c_wraith: I see
12:52:07 <SKK> What does this mean?     Loading package integer-gmp ... <command line>: can't load .so/.DLL for: gmp (libgmp.so: cannot open shared object file: No such file or directory)
12:52:07 <SKK> a
12:52:22 <Cale> It means you don't have libgmp installed.
12:52:32 <Cale> It's required by GHC.
12:52:42 <benmachine> Cale: it's possible to segfault using just IO :P
12:52:45 <benmachine> or unsafeCoerce
12:53:01 <Cale> benmachine: It's possible using FFI stuff.
12:53:10 <benmachine> well, I guess so
12:53:12 <SKK> is it called libgmp?  cause I get E: Unable to locate package libgmp
12:53:19 <MrAI> c_wraith: Thanks for all your help. Really thanks
12:53:22 <benmachine> but you don't actually need a C library
12:53:23 <Cale> SKK: yeah, usually...
12:53:27 <benmachine> just peek nullPtr :P
12:53:53 <midorikid> benmachine: I wish I was doing something like that so I could attempt to fix it. As it is, I'm stuck.
12:53:56 <c_wraith> MrAI, you're welcome
12:54:03 <Cale> SKK: On my system the package is libgmp3c2
12:54:24 <SKK> libgmp3c2 is already the newest version.
12:54:25 <SKK>  
12:54:47 <Cale> huh
12:54:50 <Cale> umm
12:55:45 <SKK> http://hpaste.org/41930/libghc
12:56:22 <Zao> SKK: You might need the -dev package.
12:56:38 <Zao> Hug packages.{debian.org,ubuntu.com}
12:56:57 <SKK> what does that mean?
12:56:58 <Zao> Oh, you used the binaries.
12:57:20 <Zao> {foo,bar} is a shell glob, expanding to foo or bar.
12:57:36 <Zao> Your OS might be too new or too old.
12:57:38 <SKK> i mean the verb in that sentence
12:57:43 <Zao> Or too inbetween.
12:57:47 <SKK> it's maverick 10.10
12:59:30 <ion> It expands to the two parameters foo bar, not foo or bar. </nitpick> :-)
13:00:03 <midorikid> Cale: You're right about rseq. I checked my revision logs and I had only tried rpar and rseq `dot` rpar. Silly me, I thought the one with "par" was the parallel one. ;) Using just rseq loads all my cores and it hasn't crashed yet. I don't expect it to last, though.
13:00:25 <SKK> Yeah!!
13:00:27 <SKK> Success!!
13:00:35 <SKK> ... getting ghci to run 
13:01:48 <ion> Just install haskell-platform and you should have the basics.
13:02:52 <SKK> ion: it's too late for that... i'm beyond the point of no return
13:03:49 <Cale> midorikid: Out of interest, which GHC version?
13:10:02 * hackagebot simple-css 0.0.2 - simple binding of css and html  http://hackage.haskell.org/package/simple-css-0.0.2 (AntonKholomiov)
13:12:27 <midorikid> Cale: 6.12.1
13:18:42 <mreh> who would be interested in a Yampa hackathon?
13:18:59 <pumpkin> where would it be?
13:19:23 <mreh> henrik things nottingham would be a possibility, I presume he means to use university resources
13:19:30 <mreh> nottingham, UK
13:19:40 <pumpkin> sherwood forrest?
13:19:42 <pumpkin> -f
13:19:43 <pumpkin> -r
13:19:45 <pumpkin> +f
13:19:55 <mreh> aye
13:20:05 <mreh> robin hood... although he never existed
13:20:47 <Cale> Robbin Hoodd from Sherrwood Forrest
13:21:17 <monochrom> The Forrest is full of Ggumps
13:21:18 <mreh> back on topic please
13:21:39 <mreh> pwease... I'd like to see this go ahead
13:23:23 <monochrom> back on topic: when will deforestation stop? http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.6971
13:24:10 <roconnor> come vote in my costate renaming survey: http://www.reddit.com/r/haskell/comments/ed184/survey_new_name_for_the_costate_comonad/
13:24:36 * Veinor covotes
13:24:48 <roconnor> covotes are welcome too
13:25:33 <Philippa_> mreh: I might be convinced to show up if it's on my doorstep. Though I just de-subbed from most of the mailing lists, so dunno if I'd hear enough about it happening
13:26:05 <Cale> roconnor: Does anyone actually use Costate for anything?
13:26:14 * geheimdienst didn't notice the deforest for the trees
13:26:20 <roconnor> Cale: They are the codomain of lenses.
13:26:26 <endojelly> what's costate?
13:26:30 <Cale> Ah, okay
13:26:35 <Cale> data Costate b a = Costate b (b -> a)
13:26:54 <Cale> endojelly: The comonad dual to the State monad
13:26:56 <roconnor> Cale: ... granted I haven't really seen the comonadic operations used with lenses.
13:27:16 <endojelly> Cale, I don't know if that's the right question, but what does it do?
13:27:55 <Philippa_> mreh: you probably shouldn't make any/all organisation happen over IRC, especially as you'd mostly be looking at people already in the UK showing up
13:28:09 <Philippa_> it's a bit tricky getting hold of a group like that in real(ish) time
13:28:22 <roconnor> Cale: http://en.wikipedia.org/wiki/List_box <-- I think this is effectively a costate comonad.
13:28:37 <roconnor> er
13:28:39 <roconnor> not that
13:28:47 <midorikid> mreh: The location will be a problem for me too. Call it a conference (with published proceedings) and I can get funding! :)
13:28:49 <roconnor> like that but disallowing multiple selections
13:29:29 <roconnor> http://en.wikipedia.org/wiki/Drop-down_list
13:29:41 <roconnor> that is more like it
13:30:24 <Philippa_> (just in case anyone cares and doesn't know already: yes, Nottingham is my doorstep)
13:30:30 <Philippa_> midorikid: workshop not good enough?
13:30:40 <endojelly> a dropdown list is a costate monad?
13:31:07 <Cale> endojelly: In a sense
13:31:14 <endojelly> Philippa_, I stayed there when I was in London, liked it very much
13:31:43 <roconnor> endojelly: comonad
13:31:43 <endojelly> Philippa_, there was a very nice pub, it was called prince something, with two stories
13:31:48 <Cale> endojelly: You have a bunch of things (the structures behind the dropdown list that you're actually selecting) which are labelled (say by strings or positions) and you're selecting one of those.
13:31:58 <Cale> One of the strings or positions, that is.
13:32:29 <Cale> cf.  data Costate b a = Costate b (b -> a)
13:32:30 <roconnor> Cale: oh, and the kleisli arrows for (Costate Nat) are stream transformers; very popular
13:32:58 <endojelly> oh. there's the problem. I don't know what a Comonad is yet. will look that up.
13:33:30 <roconnor> endojelly: it is like a coburrito
13:34:08 <Cale> endojelly: It's a functor W with extract :: W a -> a (instead of return :: a -> M a), and duplicate :: W a -> W (W a) (instead of join :: M (M a) -> M a)
13:34:14 <remy_o> roconnor: you mean the (C a -> c) -> (C b -> c) -> (C a -> c) maps ?
13:34:14 <endojelly> roconnor, no questions anymore then
13:34:24 <Cale> endojelly: satisfying laws which are similar to the monad laws, but backwards
13:34:38 <roconnor> remy_o: I'm not sure what you are refering to
13:34:51 <remy_o> roconnor: what's a stream transformer ? 
13:34:56 <endojelly> Cale, interesting
13:34:58 <Cale> remy_o gave the type of co-Kleisli composition
13:35:08 <geheimdienst> endojelly: in simple terms, it's the codual to the surjunctive transformation of a futufunctor
13:35:14 <Funktorsalat> roconnor: bab comonad? o_O
13:35:17 <Cale> geheimdienst: wat?
13:35:27 <Funktorsalat> ((b -> a, b))
13:35:39 <endojelly> geheimdienst, category theory makes everthing so simple and obvious.
13:36:40 <Cale> Yeah, maybe Selection b a would be appropriate
13:36:46 <mreh> Philippa_: we've started over mailing list, it's very early days
13:38:30 <roconnor> you mean (C a -> b) -> (C b -> c) -> (C a -> c) ?
13:38:37 <roconnor> remy_o: ^^
13:39:39 <Cale> I actually don't hate Costate as a name either now though. It makes a vague kind of sense that this is the dual to state machines.
13:39:46 <roconnor> Filling in C x = Nat * (Nat -> x) in for (C a -> b) we get (Nat * (Nat -> a) -> b) which is isomorphic to (Nat -> a) -> (Nat -> b)  which is isomorphic to Stream a -> Stream b
13:40:13 <Funktorsalat> can a state and a costate value with somehow compatible parameters annihilate? ;)
13:40:34 <remy_o> roconnor: yes
13:40:42 <Cale> Oh, right, remy_o messed up the alignment of the arrows a bit there :)
13:41:11 <Cale> Though probably you really want  (C b -> c) -> (C a -> b) -> (C a -> c)
13:41:27 <Cale> (which is just the flip of that)
13:41:48 <Cale> hmm
13:41:52 <roconnor> yes
13:41:58 <roconnor> bbl
13:42:00 <remy_o> roconnor: I understand that (C a -> b) is the same as (Stream a -> Stream b)... But I would most naturally use (Stream a) rather than (Nat, Nat -> a)
13:42:27 <Philippa_> mreh: which list?
13:42:31 <roconnor> remy_o: do you use (s * a) -> (s * b) instead of a -> State s b ?
13:42:38 <mreh> Philippa_ yampa users right now
13:42:47 <Philippa_> 'k
13:42:56 <roconnor> anyhow, bbl
13:43:25 <remy_o> roconnor: in non-functional programming yes, in Haskell I would not do that, because functions would naturally have "a" as argument...
13:43:56 <remy_o> in what kind of function would I define (f :: C a -> b, f n (g :: Nat -> T) = ...) ?
13:44:42 <remy_o> oh, it's actually easier than writing a function Stream a -> Stream b
13:44:54 <Funktorsalat> (extract of Costate, return of State) are the (counit,unit) of the product-hom-adjunction right?
13:45:15 <remy_o> yes
13:45:28 <Funktorsalat> hmm
13:46:49 <Funktorsalat> so I guess the 'annihilation' is merely the triangle equalities hmpf
13:47:18 <Funktorsalat> nevermind, I don't have a point ;)
13:49:48 <aristid> all you have is a salad of functors
13:50:06 <Funktorsalat> :(
13:50:31 <aristid> Funktorsalat: that's something tho :)
13:52:03 <sm> cabal install haskeline gives https://gist.github.com/720697 after a clean install of ubuntu maverick's haskell-platform packages. What causes this ?
13:53:13 <sm> ghc-pkg check reports no problems. ghc-pkg list shows two identical-looking directory-1.0.1.0 packages in the global list
13:53:19 <Funktorsalat> is there some way to trace/debug hxt pickler combinations?
13:53:41 <Funktorsalat> failure seems to be completely silent; the arrow just returns an empty list :|
13:53:44 <sm> and, where would you report this problem ?
13:53:47 <Funktorsalat> even with withTrace 4
13:58:50 <monochrom> sm: it is mysterious why there are two instances of directory-1.0.1.0 in global. I have only seen one global one local. but in any case two instances lead to all sorts of problems and an avalanche of more problems.
14:00:41 <monochrom> oops, perhaps two global instances is possible after all
14:01:03 <sm> yes, first time I've seen it. I guess it's related to this "hidden version" issue where cabal can differentiate between packages with the same version based on some hidden state (build flags ? dependencies ?)
14:03:18 <sm> but it's strange. I nuked ~/.ghc and ~/.cabal, removed and reinstalled all the haskell-platform packages, then cabal-installed only a few new ones, not including directory.
14:03:38 <sm> I guess I won't spend more time on it
14:03:47 <monochrom> that doesn't nuke global
14:04:14 <sm> removing the haskell-platform packages doesn't nuke global ?
14:04:25 <monochrom> no
14:04:41 <monochrom> global database is owned by ghc
14:04:53 <sm> aha, that could be it. Maybe purging them would have worked better
14:05:19 <dancor> thank god haskeline handles unicode+backspace correctly
14:05:31 <dancor> readline didn't out of the box anyway
14:09:07 <revenantphx> Parsec is pretty neat.
14:09:46 * hackagebot Unixutils 1.28 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.28 (JeremyShaw)
14:09:52 <sm> monochrom: I've purged them now.. any idea where global packages are stored so I can make sure ?
14:10:32 <sm>  /var/lib/ghc-6.12.1 maybe
14:10:33 <monochrom> /var/lib/ghc-6.12.1/package.conf.d in your case
14:10:38 <sm> thanks
14:10:56 <aindl> Hi. Have somebody experience with ghc-mod for emacs installation? I am doing all as saing at http://www.mew.org/~kazu/proj/ghc-mod/en/install.html but in emcas have: ghc-mod not found
14:10:56 <aindl> File mode specification error: (wrong-type-argument listp "ghc-mod not found")
14:11:00 <monochrom> I have much info at http://www.vex.net/~trebla/haskell/sicp.xhtml
14:11:19 <sm> interesting.. after the purge, two innocent-looking packages remaining in that dir (directory and process)
14:12:03 <sm> monochrom: good info, thanks!
14:12:32 <monochrom> without knowledge of the complete history of your computing, let's just say they're leftovers from before the Big Bang.
14:12:50 <pygmalion> can anyone see why i'm getting an infinite type error here? i'm at a loss... http://pastie.org/private/sggbgnbomh2jbyhnjq
14:16:21 <monochrom> "dpkg-query --search" may help find who put it there.
14:16:27 <arcatan> pygmalion: on lines 11-12 you have insert's arguments in wrong order
14:17:01 <pygmalion> was just about to say i noticed that. thanks arcatan 
14:29:09 <mikeg> For general use, it is "better" (faster, lower memory, etc) to use bytestring-trie over Map ByteString a?
14:30:29 <mikeg> * is it
14:30:43 <BrianHV> I want to write a function playC :: Panel (CPianoViewer [Piano.Key]) -> IO () that can access the [Key].  can't seem to come up with a pattern match syntax that works.  Panel is from wxHaskell, and CPianoViewer is data CPianoViewer a = CPianoViewer a
14:31:16 <jmc_fr_> hello everybody. I'm a french newbie with an odd question about "Data.Object.Yaml encodeFile" and letters with accents ( Ã  Ã© Ã¨ Ã§ Ã¹ etc)
14:31:47 <therp> isn't hPutStr supposed to throw an IOException when I try to write to a closed socket via a handle?
14:31:53 <therp> ghc 6.12.3 just spins
14:32:17 <pkrumins> throws for me
14:34:40 <therp> the tcp example from http://sequence.complete.org/node/258 spins at hPutStrLn in the forM over clients, when I 1. connect, disconnect, reconnect, write a line. any following lines won't be echoed back
14:34:40 <adimit> jmc_fr_: it's usually good to actually ask your question :-)
14:34:43 <jmc_fr_> when i do : fileData <- readFile "sandbox_input_texte_accentue.txt" ; (encode fileData in the right yaml structure) ; encodeFile myData "output.yml" , it results in lots of strange codes
14:35:01 <therp> pkrumins: what did you do to provoke that?
14:35:02 <adimit> jmc_fr_: like \234 or so?
14:35:07 <jmc_fr_> input.txt : "hahahÃ©hÃ©" ; output.yml = "hahah\xE9h\xE9"
14:35:27 <pkrumins> therp: nothing, it just throws for me
14:35:43 <therp> pkrumins: ok stupid question. can you send me the code and what you did?
14:35:44 <adimit> jmc_fr_: how are you printing the code? i.e. are you writing it manually to a file, or does the yaml-library do that for you?
14:35:52 <jmc_fr_> adimit: "ask your question" LOL, I'm not very fast
14:36:11 <sm> monochrom: http://www.vex.net/~trebla/haskell/sicp.xhtml is most enlightening.. a must-read. I've added it to http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
14:36:14 <pkrumins> therp: i wrapped everything in catch
14:36:18 <adimit> jmc_fr_: no biggie, it's just that sometimes folks are like: may I ask a question here? :-P
14:36:19 <pkrumins> therp: let me find the code
14:36:26 <jmc_fr_> the Data.Object.Yaml.encodeFile does write the file
14:36:30 <sm> thanks
14:36:38 <therp> the STM/TCP server looks pretty straight forward to me. the reader thread closes the socket, and the writer thread is supposed to get an exception on the next try
14:36:48 <therp> pkrumins: same here. wrapped in catch. 
14:37:06 <monochrom> sm: thanks for the high regard
14:37:19 <sm> monochrom: the only thing I might change is the title
14:37:28 <monochrom> hahaha I am naughty!
14:38:07 <adimit> jmc_fr_: I am not familiar with the yaml library, but this seems to be an encoding error then (or a very odd bug in yaml.) 
14:38:14 <sm> it's very un-findable
14:38:15 <adimit> jmc_fr_: is there any way for you to set the encoding?
14:38:40 <pkrumins> therp: http://hpaste.org/41933/pkruman
14:38:43 <jmc_fr_> well I don't now how. No function like that in the yaml library
14:39:38 <adimit> ah, just looked at it. yeah, the library is fairlyâ€¦ minimalist.
14:40:03 <therp> pkrumins: thanks!
14:40:34 <jmc_fr_> well, I'm not bouded to it, I could use an xml encoding, but it should be reasonably human readable
14:40:40 <hpc> is there any particular reason why hoogle is broken?
14:41:10 <jmc_fr_> adimit: well, I'm not bouded to it, I could use an xml encoding, but it should be reasonably human readable
14:41:35 <revenantphx> "The title of this article is deliberately, naughtily contrived to admit the acronym SICP."
14:41:36 <revenantphx> :\
14:41:46 <adimit> jmc_fr_: wait a sec. I tseems like encode (in the yaml library) takes ByteString. Can you give me a paste of your code? hpaste.org
14:41:48 <sm> so having exorcised the ghosts from /var/lib/ghc*, I'm further along.. cabal install of my package is dying with nothing more informative than ExitFailure 11. Is that a segfault ?
14:42:31 <monochrom> hrm, after cleaning /var/lib/ghc*, you're supposed to install ghc...
14:42:44 <sm> oh sure, I reinstalled the haskell-platform
14:42:53 <jmc_fr_> adimit: ok, in a few secs
14:42:57 <sm> everything is building fine except this one package (which built before)
14:42:59 <monochrom> I see, that should be enough
14:44:01 <Saizan> well, there's still ~/.ghc left
14:44:30 * sm did clean that and ~/.cabal too
14:45:42 <sm> if I do cabal configure; cabal build, build complains that I haven't configured
14:46:07 <monochrom> eww, which package is this?
14:46:13 <jmc_fr_> adimit: http://hpaste.org/41934/txttoyamlhs
14:46:48 <sm> monochrom: http://joyful.com/repos/hledger/hledger/
14:47:09 <geheimdienst> sm, could it be that configure fails? i noticed you're doing "configure; build", not "configure && build"
14:47:31 <adimit> jmc_fr_: ok, lemme play with it for a second.
14:47:43 <sm> good idea, that's a better way to write it
14:48:24 <sm> geheimdienst: you're right, configure is failing with no error output
14:48:41 <sm> I can't think why, with everything as clean as it is
14:49:02 <geheimdienst> try to crank up the verbose. maybe there's some clue
14:50:20 <Phyx-> :t let embed = undefined :: a -> (a -> b, a) in uncurry ($) .  embed
14:50:21 <lambdabot> forall b b1. b -> b1
14:53:53 <sm> geheimdienst: I didn't see any. https://gist.github.com/720803
14:54:25 <jmc_fr_> adimit: input = http://hpaste.org/41935/inputyml
14:54:40 <Phyx-> :t first (.e)
14:54:41 <lambdabot>     Couldn't match expected type `f a' against inferred type `Expr'
14:54:42 <lambdabot>     In the second argument of `(.)', namely `e'
14:54:42 <lambdabot>     In the first argument of `first', namely `(. e)'
14:54:48 <Phyx-> :t first (.id)
14:54:50 <lambdabot> forall a b d. (a -> b, d) -> (a -> b, d)
14:55:13 <hpc> :t (.id)
14:55:14 <lambdabot> forall a b. (a -> b) -> a -> b
14:55:25 <jmc_fr_> adimit : output = http://hpaste.org/41936/outputyml
14:56:11 <Phyx-> hmm
14:56:38 <sm> my last hope: upgrade cabal-install
14:56:46 <geheimdienst> sm, strange. did it create a dist/ directory ...?
14:56:53 <sm> yes
14:57:17 <geheimdienst> wait. what happens when you run /usr/bin/ghc --numeric-version
14:57:28 <sm> 6.12.1
14:57:51 <sm> it's an ubuntu haskell-platform install, clean as I could make it
14:58:41 <geheimdienst> bizarre. i totally expected it to say at least ExitFailure or something
14:59:16 <monochrom> have you "cabal clean"ed?
14:59:17 <jmc_fr_> adimit: you still here ? wan't me to make you a coffe ? ;-)
14:59:25 <sm> monochrom: yes
14:59:26 <adimit> lol :-) 
14:59:43 <adimit> jmc_fr_: it's ok. I'm getting the feeling that you chose a rather strangely coded yaml library.
14:59:49 <adimit> right now, I'll say it's a bug in the lib.
15:00:04 * sm is a frickin bug magnet today :/
15:00:36 <sm> I should take a nap
15:01:03 <sm> then the bugs will go hide again
15:01:10 <benmachine> sm: just a thought, could you do ghc --numeric-version && echo success
15:01:12 <jmc_fr_> ok, so a bug report to the maintainer ... . tks
15:01:14 <benmachine> and see if it says success
15:01:24 <sm> benmachine: it does
15:01:32 <benmachine> huh.
15:02:46 <therp> pkrumins: just FYI, the buffering mode different from NoBuffering provokes the problem. your code sets this buffer mode
15:03:24 <pkrumins> therp: oh
15:03:29 <pkrumins> good tht i have it set then :)
15:03:31 <adimit> jmc_fr_: sorry, that's all I'm getting right now. Maybe you can find a better yaml library on hackage: http://hackage.haskell.org/packages/archive/pkg-list.html A casual text search for yaml yields several libraries.
15:03:59 * adimit thinks that YAML and all that XML stuff should go die somewhereâ€¦
15:04:02 <therp> pkrumins: yes :), imho it should also give an exception with the other buffer modes..
15:04:14 <jmc_fr_> adimit: tks, this helps me already a lot - good night
15:04:31 <monochrom> it can't give an exception until you flush
15:04:38 <adimit> jmc_fr_: bon nuit!
15:05:22 <therp> monochrom: the flush comes right afterwords (http://sequence.complete.org/node/258) hPutStrLn h line in forM clients
15:05:30 <jmc_fr_> adimit: U2 ... :-)
15:05:47 <therp> monochrom: the problem is  that the preceding hPutStrLn never returns, it just consumes CPU.  
15:06:36 <Phyx-> :t (id,)
15:06:37 <lambdabot> parse error on input `)'
15:06:50 <Phyx-> @pl \a->(id,a)
15:06:51 <lambdabot> (,) id
15:06:53 <Phyx-> lol
15:06:56 <Phyx-> duh
15:07:28 <adimit> ooh. does the @pl command make lambdabot golf your code?
15:07:37 <Phyx-> golf?
15:07:48 <adimit> make it shorter/more elegant. like hlint.
15:07:51 <Phyx-> @pl == pointless
15:07:52 <lambdabot> (line 1, column 1):
15:07:52 <lambdabot> unexpected "="
15:07:52 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
15:07:55 <benmachine> adimit: not exactly
15:07:56 <Phyx-> or pointfree
15:08:01 <benmachine> adimit: it removes explicit arguments
15:08:11 <benmachine> sometimes this will make code noisier
15:08:18 <adimit> benmachine: ah, ok. pointfree. wasn't able to infer pointfree from @pl :-P
15:08:22 <Phyx-> very sometimes
15:08:38 <benmachine> @pl \a b c d e f g -> c a b b a g e
15:08:39 <lambdabot> (((const . (const .) . flip) .) .) . (flip =<< (flip .) . join . (flip .) . flip . flip id)
15:08:42 <benmachine> ...yeah
15:08:56 <benmachine> @help pl
15:08:56 <lambdabot> pointless <expr>. Play with pointfree code.
15:09:04 <adimit> eayh, eta-reduction is fun :-P
15:09:15 <therp> http://clemens.endorphin.org/TcpExample.lhs if anyone wants to try. 
15:09:23 <adimit> that y kind skipped a couple of charactersâ€¦
15:09:27 <Phyx-> great... at 00.08, while being semi drunk, in 5mins i solved a problem i've been trying to solve for days and in 5 lines...
15:09:31 <therp> added some fixes such as cast around the exception handler
15:09:31 <Phyx-> that's just sad...
15:09:43 <adimit> Phyx-: that's the ballmer peak.
15:10:06 <Phyx-> hmmm could it be?
15:10:07 <therp> Phyx-: verify you really solved it :)
15:10:09 <MrAI> benmachine: How do I pass in a function to a function? e.g. test :: (a->b) -> Int -> Int, how do I write the inputs? "test a b =" ?
15:10:21 <Phyx-> therp: tests are running now
15:10:22 <benmachine> MrAI: sure
15:10:24 * hackagebot kit 0.5.1 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.5.1 (NickPartridge)
15:10:27 <adimit> Phyx-: it's a well-known phenomenon :-P reference: http://xkcd.com/323/ (just because it's funny.)
15:10:44 <benmachine> MrAI: although, it's more common to name functions f, g, ...
15:11:05 <Phyx-> adimit: i know what it is, I've just never been able to attain it
15:11:27 <MrAI> benmachine: How would I then call that function? <<< Thats the part im unsure of
15:12:07 <br1> how do I combine as and lazy patterns?
15:12:19 <MrAI> benmachine: Say I want to pass it map (*2) ?
15:12:21 <kmc> with lots of parentheses
15:12:29 <adimit> Phyx-: well, grats. Happens a lot to me that after failing to prove something consequently for days, I come back, and write out a trivial proof in 5 minutes. it's frustratingâ€¦ but just the way it is.
15:12:50 <monochrom> x@~(xx:ss)
15:13:02 <kmc> > let test f = f [2,3,4] in test (map (*2)) -- MrAI
15:13:03 <lambdabot>   [4,6,8]
15:13:20 <MrAI> Thanks
15:13:34 <kmc> functions are values like any other
15:13:46 <benmachine> MrAI: test (map (*2)) 8
15:13:54 <br1> monochrom: thx! it actually was x@(~(xx:ss))
15:14:00 <Phyx-> ah ok, false alarm
15:14:02 <Phyx-> it's broken
15:14:04 <Phyx-> :)
15:15:38 <MrAI> I want to write: test a b = b a  but I know thats wrong, lol
15:16:32 <kmc> why is it wrong?
15:16:36 <kmc> that's a valid function
15:16:40 <kmc> is it the function you want?
15:16:44 <kmc> :t let test a b = b a in test
15:16:45 <lambdabot> forall t t1. t -> (t -> t1) -> t1
15:16:54 <kmc> > let test a b = b a in test 3 succ
15:16:55 <lambdabot>   4
15:17:18 <MrAI> ghc comes back with an error :s
15:17:33 <MrAI> I have : test :: (a->b) -> Int -> Int
15:17:33 <MrAI> test a b = b a 
15:17:48 <benmachine> oh that's wrong
15:17:59 <benmachine> because your type says, you can pass any function you like
15:18:11 <benmachine> so I could reasonable call your function with, say, reverse
15:18:13 <c_wraith> yeah, it's tough to do anything with the first argument to that function
15:18:43 <MrAI> I see. What do I need to read up on for understanding that?
15:18:49 <sm> well guess what.. installing the latest cabal-install fixes my configure error. Actually, it installed the same cabal-install version I already had (0.8.0 + 1.8.0.2), but with a different abi hash
15:20:31 <MrAI> Im thinking High Order Functions.
15:20:47 <MrAI> *higher 
15:21:21 <kmc> MrAI, your code is fine; you gave it the wrong type signature
15:21:28 <kmc> you can leave off the sig and see what type GHCi gives it
15:21:35 <aavogt> benmachine: you maintain haskell-src-meta, right?
15:21:38 <kmc> :t let test a b = b a in test
15:21:39 <lambdabot> forall t t1. t -> (t -> t1) -> t1
15:21:44 <benmachine> aavogt: <_< >_> yeah
15:21:47 <geheimdienst> sm, that's an evil bug :-(
15:21:50 <kmc> i'd probably say:   test :: a -> (a -> b) -> b
15:22:22 <benmachine> aavogt: what of it :P
15:22:25 <kmc> or you could write:   test :: (Int -> Int) -> Int -> Int
15:22:38 <kmc> this would place an artifical restriction on 'test'
15:22:51 <benmachine> kmc: those arguments are the wrong way around though
15:22:51 <MrAI> Could I go with: test:: (a -> b) -> a -> a ?
15:23:03 <MrAI> *a -> a
15:23:07 <benmachine> MrAI: no
15:23:19 <benmachine> MrAI: the (a -> b) function produces a thing of type b
15:23:23 <benmachine> then what do you do with it?
15:23:26 <aavogt> benmachine: it doesn't work with ghc-7, since the QuasiQuoter got bigger, ViewP was added, and the template-haskell version was bumped so cabal gets confused and tries to install 2.4
15:23:28 <c_wraith> well, you could, but the only useful function with that type is flip const
15:23:43 <Veinor> so, google is telling me that snap and happstack come with servers and such. what should i use if i just want to build a webapp that will run on my existing server?
15:23:45 <MrAI> I meant: test :: (a -> a) -> a -> a
15:23:46 <MrAI> :)
15:23:50 <benmachine> aavogt: oh, yeah, I don't have GHC 7 yet
15:23:56 <benmachine> https://github.com/benmachine/haskell-src-meta/issues#issue/2
15:24:03 <aavogt> benmachine: I can get you some of those changes, once I figure git out
15:24:18 <benmachine> aavogt: I also take plain patches :)
15:24:25 <Veinor> or should i just roll my own
15:24:30 <benmachine> MrAI: that's a reasonable type signature, but test a b = b a doesn't match it
15:24:55 <MrAI> Thats really what im asking then. How do I match it?
15:24:57 <benmachine> Veinor: it depends on your use case, CGI is nice and simple for small things
15:25:06 <benmachine> MrAI: well, what does that type signature say?
15:25:08 <Funktorsalat> benmachine: one breaking change in TH 2.5 is that ClassI has 2 fields, not 1
15:25:12 <MrAI> I know it takes in: a function, and an input
15:25:23 <MrAI> And outputs a type a
15:25:30 <benmachine> MrAI: right, look at your definition
15:25:35 <benmachine> test a b = -- whatever
15:25:41 <benmachine> which one is the function and which is the input?
15:25:43 <kmc> err yeah i meant Int -> (Int -> Int) -> In
15:25:43 <Saizan> Veinor: happstack can run as a cgi/fastcgi app, iirc
15:25:44 <kmc> t
15:25:49 <Veinor> Saizan: neat
15:26:01 * Veinor will look into it
15:26:53 <MrAI> benmachine: the second
15:27:06 <benmachine> MrAI: how do you know?
15:27:25 <MrAI> benmachine: The definition?
15:27:33 <benmachine> MrAI: but what does the type signature say?
15:27:45 <benmachine> about the argument order
15:28:18 <aavogt> benmachine: sent
15:28:25 <MrAI> benmachine: Int -> (Int -> Int) -> Int, takes in an int; takes in a function from int to int; outputs an int
15:28:42 <benmachine> MrAI: right
15:28:52 <benmachine> 23:23:18 < MrAI> I meant: test :: (a -> a) -> a -> a
15:29:00 <benmachine> that's what I was talking about though
15:29:43 <MrAI> benmachine: a -> (a -> a) -> a, takes in an a; takes in a function from a to a; outputs an a
15:29:54 <MrAI> benmachine: But a is undefined :s
15:30:04 <benmachine> MrAI: ah, we're on the same page now :P
15:30:09 <MrAI> benmachine: :D
15:30:14 <benmachine> MrAI: type variables are implicitly defined, sort of
15:30:24 <benmachine> a type signature like test :: (a -> a) -> a -> a
15:30:41 <MrAI> benmachine: so the answer should of been: test :: (a->b) -> a -> b ?
15:30:41 <benmachine> means "for any a, test can have the type (a -> a) -> a -> a"
15:30:53 <benmachine> MrAI: blink blink
15:31:10 <MrAI> benmachine: Is that your eyes or a bulb coming on?
15:31:16 <benmachine> eyes
15:31:27 <benmachine> can you please decide whether you want the function or input first :P
15:31:50 <MrAI> oops :) lets put the function first
15:32:12 <benmachine> oh, in that case then both (a -> a) -> a -> a and (a -> b) -> a -> b are allowed
15:32:12 <geheimdienst> ... and no flip-flopping on that issue ... (hee hee)
15:32:22 <benmachine> but the latter is more powerful
15:32:29 <MrAI> I see
15:32:42 <benmachine> well, it is more general
15:33:08 <MrAI> Im with you
15:34:12 <MrAI> And so im guessing: test a b = b a is no longer valid
15:34:45 <MrAI> :t test a b = b a
15:34:45 <lambdabot> parse error on input `='
15:34:56 <bos> dons: yo
15:35:06 <benmachine> MrAI: right, because now the function is first
15:35:21 <mun> if i have a list of lists of pairs, what's a good way to flatten the list and return only a list of the fst of each pair?
15:35:53 <benmachine> mun: so you have [[(a,b)]] and you want [a]?
15:35:58 <Funktorsalat> mv Language.Haskell.TH TH
15:36:07 <Kaidelong> liftM fst . join ?
15:36:19 <Funktorsalat> not worth the incompatibility but otherwise I'd be for that ;)
15:36:27 <benmachine> Funktorsalat: tired of typing? :P
15:36:41 <MrAI> So it should be: test a b = a b
15:36:44 <Funktorsalat> yeah, my vim doesn't have completion for that either
15:36:45 <benmachine> MrAI: right
15:36:53 <mun> benmachine, yes, well there could be more than one sublist.
15:37:03 <MrAI> Ahhhh I get it :D
15:37:06 <benmachine> mun: I'm talking about types though
15:37:15 <mun> benmachine, yes
15:37:17 <benmachine> right
15:37:19 <Kaidelong> you can't have different levels of nesting without some kind of union type
15:37:34 <benmachine> Kaidelong's answer was good
15:37:39 <benmachine> :t map fst . concat
15:37:40 <lambdabot> forall a b. [[(a, b)]] -> [a]
15:37:45 <benmachine> ^ less general
15:37:52 <Funktorsalat> omg did you know TH supports GADTs already? :O
15:38:10 <Funktorsalat> they just don't use a separate ctor of Dec
15:38:24 <mun> thanks
15:38:36 <Kaidelong> what do you mean by more than one sublist?
15:38:51 <Kaidelong> just that you can have many sublists?
15:38:56 <benmachine> heh
15:39:01 <benmachine> that would seem a reasonable interpretation
15:39:27 <Kaidelong> the other interpretation would be that he wants to work with a union of [a] and [[a]]
15:39:38 <benmachine> mm
15:40:03 <Kaidelong> or something that allows deep nesting
15:40:04 <MrAI> benmachine: And so then it becomes like any other; test (map (*2)) [2,3,4]
15:40:11 <MrAI> benmachine: Thanks :)
15:40:21 <benmachine> MrAI: :)
15:42:10 <MrAI> Log link for the channel is wrong: "http://tunes.org/~nef/logs/haskell/]" should be "http://tunes.org/~nef/logs/haskell/"
15:43:04 <Veinor> link works for me
15:43:05 <MrAI> Vicki
15:43:07 <MrAI> oops :)
15:44:03 <MrAI> Strange - must be YChat im using. It gives me the extra ] at the end
15:44:17 <Veinor> "Logs: http://tunes.org/~nef/logs/haskell/"
15:44:34 <MrAI> Yours works
15:44:42 <MrAI> I get: "http://tunes.org/~nef/logs/haskell/]"
15:44:49 <MrAI> When I click on it in the info
15:45:06 <Eridius> MrAI: The entire topic appears to be a list of strings. That particular link shows up for me as "Logs: http://tunes.org/~nef/logs/haskell/"] (with the quotes)
15:45:23 <Eridius> now of course the terminal app I'm using correctly detects the link and lets me open that just fine
15:45:51 <MrAI> Must just be my client then - the link wrapper is slightly off :)
15:46:02 <monochrom> I think the complaint is the order: ]"
15:46:11 <monochrom> but I see this order: "]
15:46:15 <Eridius> if your client is swapping the " and ] then it's definitely broken
15:46:35 <MrAI> It removes the " but leaves the ]
15:46:54 <Eridius> that's awfully bizarre
15:46:58 <MrAI> And likewise for http://hpaste.org/ it leaves in the , and gives me http://hpaste.org,/
15:47:30 <Veinor> okay, time to add... option handling!
15:47:39 <Veinor> (dun dun dunnnn)
15:47:55 <MrAI> It strips out the " but anything after it keeps - dumb client, lol
15:47:56 <MrAI> :D
15:52:09 <Veinor> eight data constructors for the Option type. hm.
15:52:17 <rothwell> src/full/Agda/TypeChecking/Rules/Data.hs:291:0: error: no newline at end of file
15:52:24 <rothwell> doh!
15:53:19 <rothwell> anyone seen that, trying to build agda?
15:57:09 <Saizan> yep, add a newline
15:57:28 <Saizan> or you could use the darcs version
15:57:45 <rothwell> Saizan: i'm not sure how to do that without having cabal extract the original archive over my changes
15:57:59 <rothwell> suppose i should use the darcs version, really
15:58:32 <Saizan> rothwell: cabal unpack Agda; cd Agda-*; add newline; "cabal install"
15:58:48 <rothwell> Saizan: ah! thanks
15:59:00 <Saizan> with no package name specified it'll install from the current dir
15:59:44 <sm> I think haskell98 needs to tighten up its dependency on directory.. I keep getting Directory.hs not in scope 'setOwnerReadable' etc.
16:07:06 <Veinor> hmm.
16:07:18 <Veinor> userTimeline "username" optionList or userTimeline optionList "username"?
16:07:39 * Veinor is going with the former since it seems nicer
16:07:59 * MrAI agrees
16:11:23 <sm> can you specify build flags for dependencies in a cabal file ?
16:11:55 <sm> ie, depend on dependency X built with a particular flag
16:13:00 <Quadrescence> Cale: you about?
16:13:12 <Quadrescence> Cale: pm
16:13:56 <Cale> sure
16:14:02 <Cale> lambdabot: @join #not-math
16:15:18 * Veinor runs into a namespace collision
16:15:25 <Veinor> ow!
16:15:29 <identity_> I'm trying to grok zippers; would it make sense to grok a zipper for a list as a type of doubly linked list?
16:15:47 <hpc> identity_: read the lyah chapter
16:15:55 <hpc> it uses that exact simplification
16:16:16 <identity_> hpc: Oh, there is a lyah chapter?
16:16:18 <identity_> I didn't know; thanks
16:16:22 <sproingie> you could say a zipper is a generalization of a doubly linked list
16:16:24 <identity_> Been using the wikibooks stuff
16:19:20 <jules2> why does parsec not backtrack by default?
16:21:50 <aristid> jules2: maybe because it would be computationally expensive?
16:23:00 <jules2> right, but I cannot think of a practical case where it would be expensive
16:24:22 <jules2> I would like to know such cases. They must exist because the natural way to implement parsec would be to do backtracking by default.
16:26:11 <sproingie> backtracking requires more space
16:27:07 <Cale> jules2: While some libraries have now been devised which circumvent this problem, the usual problem with backtracking is the requirement of holding on to the beginning of the input because the remainder of the parser might fail.
16:27:54 <jules2> Ah yes that makes sense because you want to be able to parse files bigger than memory :) Which libraries do you mean?
16:28:25 <Cale> ReadP
16:28:53 <Cale> It has a commutative choice combinator, and parses all alternatives in parallel.
16:30:30 <Kaidelong> class declarations are always exported, right?
16:30:37 <Kaidelong> so I can just say module Foo()?
16:30:44 <Kaidelong> if all that's in a module is a class declaration?
16:30:57 <Cale> No, instances are always exported
16:31:03 <Cale> classes might not be
16:31:18 <Kaidelong> okay, so what do I put down, module Foo(ClassName)?
16:31:23 <Cale> You give the class name along with (..) to export all the methods
16:31:38 <Kaidelong> module Foo(ClassName (..))
16:31:39 <Kaidelong> ?
16:31:55 <Cale> yeah
16:32:39 <Kaidelong> okay, and Foo.Bar just puts the period in the module name, like in ML?
16:32:40 <Cale> Just listing ClassName will export the class, but not its methods. ClassName (f1,f2,...,fn) will export just the listed methods.
16:32:52 <Cale> yeah
16:32:56 <Kaidelong> great
16:32:57 <Kaidelong> thanks
16:33:08 <Kaidelong> module HarmonySearch.Class(HarmonyMemory (..))
16:33:22 <Kaidelong> is what I end up with
16:33:52 <Cale> GHC will look in both  HarmonySearch/Class.hs  and  HarmonySearch.Class.hs  for that module.
16:34:19 <Kaidelong> oh, module names are tried to file names?
16:34:42 <Cale> yeah
16:34:45 <Kaidelong> well I called it HarmonySearch.Class.lhs
16:34:59 <Kaidelong> so hopefully that shouldn't be a problem
16:35:21 <Cale> (Only in that if you don't name the files after the modules, GHC won't be able to find them automatically, and you'll have to pass them explicitly on the commandline)
16:35:32 <jules2> Cale: thanks. The source of ReadP looks good, I'll try to study it
16:37:09 <benmachine> Cale: wait, will it? I thought that was a JHC thing
16:37:18 <benmachine> and GHC only looked for HarmonySearch/Class.hs
16:37:42 <Cale> benmachine: I could be wrong.
16:39:34 <litb> hello folks
16:39:43 <ndrsndrs> doesn't look like GHC tries A.B.C.hs
16:39:50 <Cale> hmm, yeah
16:40:01 <Cale> (I just tried it too)
16:40:06 <litb> Prelude.. is different from lambdabot's . ?
16:40:13 <ndrsndrs> would be nice if it did though :p
16:40:15 <Cale> Kaidelong: So you might have to move it to a subdirectory.
16:40:30 <Cale> litb: yes
16:40:41 <Kaidelong> Cale: alright then
16:40:42 <litb> @src Prelude..
16:40:42 <lambdabot> Source not found. :(
16:40:43 <Cale> litb: Lambdabot's (.) is a generalisation
16:40:50 <Cale> @src (.)
16:40:50 <lambdabot> (f . g) x = f (g x)
16:40:50 <lambdabot> NB: In lambdabot,  (.) = fmap
16:41:00 <litb> oh that's prelude's one
16:41:15 <litb> ohh nice
16:41:53 <Cale> The @src command just has an arbitrary textfile consisting of definitions of things collected from various places, and might not correspond to the real definitions anywhere.
16:42:33 <ndrsndrs> are there any actual libraries/prelude replacements/whatever that have (.) = fmap, btw?
16:43:31 <Cale> Well, it wouldn't be hard to make one, but it's about as hard to import such a library as it is to just make that definition yourself.
16:43:55 <benmachine> well, unless it came with other neat things as well
16:44:02 <Cale> (seeing as you have to import the Prelude hiding its definition of (.)
16:44:03 <ndrsndrs> well, i suppose. i meant maybe one with (++) = mappend as well, and things like that
16:44:28 <ndrsndrs> or mplus, or whatever
16:44:39 <Cale> I'd prefer mappend, myself :)
16:44:55 <Cale> mplus isn't so bad, mappend is getting a little long :)
16:45:10 <ndrsndrs> me too. there's always Alternative's (<|>) for mplus if we're rearranging things anyway
16:45:13 <Cale> yeah
16:45:16 <hpc> mempty is an obnoxiously long alias for 0
16:45:25 <benmachine> wasn't there a libraries proposal for (<>)
16:45:34 <hpc> i would use <+> for mappend
16:45:36 <bos> we should call mempty "meh" instead
16:45:41 <hpc> er, mplus
16:45:46 <bos> benmachine: there was, i wrote it
16:46:00 <bos> benmachine: it got stuck in the libraries tar pit
16:46:14 <benmachine> aw
16:46:48 <Cale> It took years for Data.List to get a permutations function. We seriously need new management of the base libraries.
16:47:17 <Cale> (Or something!)
16:48:05 <hpc> i would do it, but i would probably end up rotating damn near everything
16:48:15 <ClaudiusMaximus> would it be reasonable to implement a watchdog thread (to check if some other threads are making insufficient progress) using   threadDelay, MVar (), tryTakeMVar, tryPutMVar
16:48:17 * hpc is rather picky about code he maintains
16:49:44 <ClaudiusMaximus> or is there a better way that doesn't involve so much synchronization when progress is being made?
16:49:54 <Cale> GHC 6.8.3 didn't have permutations in Data.List, and it was released in 2008, which means that it literally took a decade to put a permutations function into Data.List :)
16:50:13 <Cale> (from the release of the Haskell 98 standard, at least :)
16:52:36 <Cale> ClaudiusMaximus: SampleVar?
16:52:46 <Igloo> Cale: Well, only if someone was /trying/ to put it in in 1998. You could equally well say it took 1000 years to put it in, starting from 1008.
16:53:33 <hpc> Igloo: 1000 years? why, it took 4.8 /billion/ years for C++ to get lambdas!
16:53:48 <Cale> Were there any other changes to the list library (other than the move from List to Data.List) since standardisation?
16:54:08 <Igloo> I think there hav been some strictness changes
16:54:47 <Igloo> I don't know if there were other changes. But even if there weren't, that's not an indication that anything is necessarily wrong
16:54:57 <ClaudiusMaximus> Cale: hm, it's implemented as a newtype over nested MVar, so it'd be slower if anything
16:55:15 <Igloo> List was pretty much the first module written, so it shouldn't be surprising that it stabilised early on
16:55:32 <Igloo> And there were standards before H98 too, of course
16:56:37 <Cale> Well, sure, but it seems to take a long time for even pretty uncontroversial things to get into the base libraries.
16:57:08 <ClaudiusMaximus> i suppose i should just implement it and see how much it slows down when i call tryPutMVar for each pixel...
16:59:48 <Igloo> Cale: There's no reason they shouldn't be in by the next GHC major release
17:04:15 <nkunda> hello, I just installed ghc  and am having a problem running ghci 
17:04:24 <nkunda> I get the error message:
17:04:29 <nkunda> <command line>: can't load .so/.DLL for: gmp (libgmp.so: cannot open shared object file: No such file or directory)
17:05:08 <nkunda> can anyone tell me what I'm doing wrong. I followed the install instructions exactly
17:06:08 <Funktorsalat> could multirec be extended to support existentials (and equality constraints, thus gadts)?
17:06:35 <gienah> nkunda: which os?
17:06:51 <nkunda> ubuntu 
17:07:07 <Funktorsalat> it supports finite families of monomorphic types, so it couldn't model a *whole* gadt, but its shadow for some values of the parameter
17:07:23 <Funktorsalat> whether that's good for anything is another question ;)
17:08:25 <Kaidelong> GHCi does not respect my LANGUAGE header pragma in my LHS file
17:08:30 <MrAI> data Tree a = Leaf a | Node (Tree a) a (Tree a) deriving Show
17:08:30 <MrAI> mapTree :: (a -> b) -> Tree a -> Tree b
17:08:31 <MrAI> mapTree a (Leaf x) = a (Leaf x)
17:08:31 <MrAI> mapTree a (Node l n r) = Node (mapTree(a l)) (mapTree(a (Leaf n))) (mapTree(a r))
17:08:36 <MrAI> Can someone throw me a hint on this one please
17:08:42 <Kaidelong> is there some special interaction between LHS and pragmas that I need to be aware of?
17:09:30 <Kaidelong> MrAI: for starters, you're going to want to have an empty tree in your data type
17:10:10 <Kaidelong> MrAI: second, you're going to want to construct a new leaf with a new value in it like so:
17:10:46 <Kaidelong> mapTree f (Node l n r) = Node (mapTree f l, f n, mapTree f r)
17:10:50 <sipa> MrAI: you're almost there
17:11:04 <Kaidelong> also get rid of the leaf constructor you don't need it
17:11:10 <Kaidelong> a leaf is just a tree with empty subtrees
17:11:44 <Kaidelong> mapTree f EmptyTree = EmptyTree
17:11:45 <Saizan> Kaidelong: are your language pragmas in a code section?
17:11:46 <Kaidelong> for that case
17:11:54 <Kaidelong> Saizan: indented with >'s
17:12:02 <Kaidelong> not using \begin
17:12:04 <Kaidelong> {code}
17:12:12 <nkunda> gienah; it encountered the error while trying to load the package integer-gmp.. I'm using ubuntu
17:12:13 <Kaidelong> but it shouldn't matter
17:12:20 <Saizan> eight
17:12:23 <Kaidelong> since I think what I have is valid literate haskell
17:12:26 <Saizan> *right
17:12:35 <Kaidelong> and not lhs2TeX specific
17:12:47 <Saizan> they should also be at the top of the file, before the module header
17:13:14 <Kaidelong> well it's not at the top of the file because I have the latex header stuff above it
17:13:20 <Kaidelong> but those should look like comments
17:13:24 <Kaidelong> which IIRC are allowed
17:13:28 <Kaidelong> before a header pragma
17:13:48 <MrAI> kaidelong: I see
17:13:50 <sipa> > let val = 1 : [ x+y+1 | x <- val, y <- val ] in val
17:13:51 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
17:13:59 <Kaidelong> let me paste it
17:14:04 <Kaidelong> hang on
17:14:32 <sipa> MrAI seems to have found a very cunning way to encode trees with an odd number of elements
17:14:51 <MrAI> sipa: I have? lol
17:14:57 <Kaidelong> http://hpaste.org/41938/help_language_pragma_not_bein
17:15:02 <Kaidelong> anyone can help me here?
17:15:39 <sipa> > let val = 1 : [ (val!!x)x+(val!!(s-x))+1 | s <- [0..], x <- [0..s] ] in val
17:15:40 <lambdabot>   Occurs check: cannot construct the infinite type:
17:15:40 <lambdabot>    a = GHC.Types.Int -> a
17:15:45 <lispy> Kaidelong: is there an error?
17:16:03 <sipa> > let val = 1 : [ (val!!x)x+(val!!(s-x))+1 | s <- [0..], x <- [0..s] ] in val
17:16:04 <lambdabot>   Occurs check: cannot construct the infinite type:
17:16:04 <lambdabot>    a = GHC.Types.Int -> a
17:16:06 <sipa> > let val = 1 : [ (val!!x)+(val!!(s-x))+1 | s <- [0..], x <- [0..s] ] in val
17:16:07 <lambdabot>   [1,3,5,5,7,7,7,7,9,9,7,9,9,11,9,9,9,11,11,11,11,9,9,11,13,11,13,11,9,9,11,1...
17:16:31 <sipa> MrAI: try to write a tree with 2 elements :)
17:16:42 <Kaidelong> lispy: yeah, GHCi complains that I'm not allowed to make multi-parameter typeclasses without enabling multi-parameter type classes
17:16:49 <MrAI> With which code? Ive got (so far):
17:16:50 <MrAI> data Tree a = EmptyTree | Node (Tree a) a (Tree a) deriving Show
17:16:50 <MrAI> mapTree :: (a -> b) -> Tree a -> Tree b
17:16:50 <MrAI> mapTree f EmptyTree = EmptyTree
17:16:50 <MrAI> mapTree f (Node l n r) = Node (mapTree f l, f n, mapTree f r)
17:16:55 <Kaidelong> lispy: but I did put a pragma in there
17:17:02 <sipa> MrAI: yes, with that data type
17:17:27 <MrAI> sipa: guess: tree1 = Node (Leaf 5) null (Leaf 4) ?
17:17:32 <MrAI> oops
17:17:42 <sipa> what is null ?
17:17:49 <MrAI> I was going to go with 0
17:17:53 <MrAI> But that made no sense
17:18:00 <lispy> Kaidelong: same problem if you use ghc instead of GHCi?
17:18:09 <sipa> MrAI: you see the problem?
17:18:24 <Kaidelong> lispy: yes
17:18:29 <MrAI> sipa: Yes
17:18:33 <lispy> Kaidelong: GHC version?
17:18:41 <MrAI> sipa: But the problem requires I have data at the node aswell
17:18:47 <Kaidelong> 6.12.1
17:18:49 <sipa> MrAI: that is the problem indeed
17:19:02 <sipa> and Kaidelong already told you how fix it
17:19:16 <MrAI> data Tree a = EmptyTree | Node (Tree a) a (Tree a) deriving Show
17:19:16 <MrAI> mapTree :: (a -> b) -> Tree a -> Tree b
17:19:17 <MrAI> mapTree f EmptyTree = EmptyTree
17:19:17 <MrAI> mapTree f (Node l n r) = Node (mapTree f l, f n, mapTree f r)
17:19:19 <MrAI> DId I miss something?
17:19:30 <Kaidelong> you are getting it
17:19:34 <sipa> MrAI: looks right to me
17:20:19 <ndrsndrs> You're passing Node a tuple in the second equation of mapTree; you mean `Node (mapTree f l) (f n) (mapTree f r)`
17:20:33 <lispy> Kaidelong: huh, it works great here on ghc7 (well, there is a type error)
17:20:46 <Kaidelong> lispy: there is a mistake in the code, at least one, and a mistake in the latex
17:20:58 <Kaidelong> but it -should- respect the pragma on my end yet it doesn't seem to
17:21:08 <MrAI> Ahhh
17:21:11 <Kaidelong> let me see if for some bizzare reason going superuser fixes the problem
17:21:13 <lispy> Kaidelong: what does it tell you?  can you add the error message to your paste?
17:21:30 <MrAI> I had that part right then :)
17:21:31 <sipa> ndrsndrs: ah, right, my on-brain ghci is still to permissive
17:21:40 <MrAI> I honestly did not think to build my tree that way :)
17:21:45 <ndrsndrs> Kaidelong: it seems to work for me as well, apart from the type error; 6.12.3
17:22:21 <nkunda> Question about GHCi on Hpaste: http://hpaste.org/41939
17:22:38 <ndrsndrs> sipa: i was writing some ML the other day, so i kept making the opposite mistake :P
17:23:06 <sipa> i used to write some ocaml code
17:23:08 <MrAI> Thanks: kaidelong, supra :D
17:23:16 <MrAI> *sipa
17:23:28 <Saizan> nkunda: you need to apt-get install libgmp3-dev (or a simirarly named package)
17:23:29 <sipa> i think i have all but forgotten the syntax after two years of haskell
17:25:01 <MrAI> I personally like Haskell ALOT
17:25:01 <byorgey> nkunda: you seem to be missing the gmp library.  are there any ubuntu packages involving 'gmp'?
17:25:01 * sipa also
17:25:01 <MrAI> ...once I get it :) lol
17:25:01 <byorgey> ski: like 'libgmp' or something similar?
17:25:01 <sipa> libgmp3-dev
17:25:01 <Kaidelong> http://hpaste.org/paste/41940/the_error_message#p41941
17:25:01 <sipa> is what you need to compile things using it, i believe
17:25:01 <Kaidelong> Here is the paste, with the error message
17:25:33 <lispy> Kaidelong: weird.  Maybe your GHC has a bug.  Works for me on 7.0.1
17:25:49 <gienah> nkunda: could also check the version of the /usr/lib/libgmp.so* and which one ghc wants with ldd /usr/lib64/ghc-6.12.3/ghc or something like that
17:26:03 <ion> nkunda: Why not use the version of GHC provided by the distro? Just apt-get install haskell-platform and youâ€™re good to go.
17:26:04 <lispy> Kaidelong: I would recommend upgrading to 6.12.3
17:26:28 <Kaidelong> lispy: can I do that with cabal?
17:26:40 <gienah> ion: go with your advice since I use gentoo, not ubuntu
17:26:43 <lispy> Kaidelong: No.  You will need to install a new version of GHC
17:26:55 <lispy> Kaidelong: http://hackage.haskell.org/platform/
17:27:14 <Kaidelong> let me see if a new version of the platform is on ubuntu's repositories
17:27:45 <ion> 2010.1.0.0.1
17:28:06 <ion> Not the newest version, but perhaps new enough. :-)
17:29:01 <nkunda> Saizan; byorgey; gienah; ion; thanks for the help! Saizan was right, Ubuntu 10 does not come with libgmp3-dev and requires a manual installation.
17:29:18 <nkunda> it works now!
17:29:26 <Manifesto> whats the alternative to Data.Numeric.showIntAtBase for negative numbers?
17:30:04 <sipa> nkunda: ubuntu doesn't install any dev libraries or tools in a default installation
17:30:33 <gienah> sipa: thanks, gentoo always installs the dev stuff of course
17:30:59 <byorgey> nkunda: great!
17:31:47 <Manifesto> readInt it is
17:32:39 <pastorn> no printf instances for text?
17:33:11 <Kaidelong> Okay, I see there are new security updates today anyway, I'll reboot, see if I can upgrade GHC from apt, and if things still don't respect the pragma I guess I'll be looking for help...
17:33:26 <Kaidelong> I've had similar issues with GHC being unable to find parts of Haskore even though they are installed
17:34:19 <Kaidelong> as far as cabal is concerned, anyway
17:35:08 <byorgey> that may be due to local/global install issues
17:35:37 <byorgey> like if a package is installed in your local user package DB and you are trying to build and install a package into the global package DB
17:36:08 <Kaidelong> so that might be fixed if I reinstall something with superuser privilidges?
17:36:20 <Kaidelong> or should I always use cabal in superuser mode if I can?
17:36:29 <Kaidelong> at least when it comes to installing things
17:37:11 <Veinor> hm
17:37:53 <byorgey> no, other way around.
17:38:36 <byorgey> I've found best practice is to let your global package DB contain whatever packages are installed by GHC and/or the Haskell Platform, and then never touch it again
17:38:56 <byorgey> and do everything working just with your local package DB.
17:42:32 <Kaidelong> okay good, that's pretty much what I was doing, only going into superuser mode if something fails because it doesn't have permissions to modify /share
17:44:05 <Saizan> it should never need permissions
17:44:48 <byorgey> if you ever do need superuser permission, be sure to do  cabal install --root-cmd=sudo ...  and not  sudo cabal install  ...
17:44:57 <byorgey> but like Saizan said, you should never need to do that
17:45:16 <Saizan> one gotcha is that runghc Setup defaults to --global, so you need to pass it --user if you're using that
17:45:31 <Kaidelong> oh
17:45:45 <Saizan> but there isn't much of a reason to call runghc Setup directly
17:45:49 <Kaidelong> so going "ghci --user" might help get rid of it being unable to find modules I've installed?
17:46:06 <Saizan> no, ghci reads the user package db by default
17:46:09 <Kaidelong> oh
17:46:42 <Kaidelong> Well if I run into it again I'll try to get it sorted out
17:47:05 <Saizan> if it can't find a module but ghc-pkg reports it as installed and not broken, run ghci with an higher verbosity to see if it's shadowing that package away
17:51:18 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.cafe/83818/focus=83868
17:56:11 <pastorn> I want to generate i list of imports from a specific folder at compile time
17:56:42 <pastorn> so for each file X.hs in directory DIR i want to have 'import qualified DIR.X as X'
17:58:29 <Kaidelong> I figured out the source of all my woes
17:58:41 <byorgey> do tell!
17:59:15 <kmc> pastorn, i don't think template haskell can do that
17:59:16 <pastorn> what feature suits this best? Quasiquoting? TemplateHaskell? Preprocessor?
17:59:45 <kmc> and quasiquoting is a TH feature
17:59:55 <kmc> i think you'll need to write a custom preprocessor
18:00:00 <kmc> haskell-src-exts could be useful for that
18:04:04 <unkanon> I just read a little about the universal property of fold
18:04:17 <unkanon> so I tried to write a length function like that
18:04:33 <unkanon> @let myLen2 = foldr (\_ -> (+1)) 0
18:04:34 <lambdabot>  Defined.
18:04:41 <unkanon> > myLen2 [1,2,3]
18:04:42 <lambdabot>   3
18:04:59 <unkanon> yeah but I have -Wall set and I get all sorts of warnings
18:05:11 <unkanon> about defaulting constraints
18:05:28 <benmachine> unkanon: did you give the function an explicit type constraint?
18:05:33 <benmachine> type signature
18:05:51 <unkanon> no because that proved a bit difficult :)
18:06:14 <benmachine> oh ok
18:06:19 <unkanon> when I did it I think it really threw errors instead of just warnings
18:08:13 <Veinor> @hoogle a -> a
18:08:14 <lambdabot> Prelude id :: a -> a
18:08:14 <lambdabot> Data.Function id :: a -> a
18:08:14 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
18:08:27 <pastorn> would it be too hard to just have a function :: IO String
18:08:45 <pastorn> which i run at compile time and which just pastes whatever it generates to the place where i call it?
18:08:58 <Veinor> hm
18:09:10 <Veinor> (a -> m b) -> m [a] -> m [b]
18:09:15 <Veinor> what do
18:09:44 <pastorn> @type mapM
18:09:45 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
18:09:55 <pastorn> liftM2 mapM
18:09:58 <pastorn> @type liftM2 mapM
18:09:59 <lambdabot> forall a (m :: * -> *) b (m1 :: * -> *). (Monad m, Monad m1) => m1 (a -> m b) -> m1 [a] -> m1 (m [b])
18:10:09 <pastorn> no, not that
18:10:14 <benmachine> @type \f -> (mapM f =<<)
18:10:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m [a] -> m [b]
18:10:22 <Veinor> benmachine: yeah, that's what I figured
18:11:02 <ndrsndrs> @pl \f -> (mapM f =<<)
18:11:02 <lambdabot> (=<<) . mapM
18:11:39 <ndrsndrs> ok that was obvious :(
18:11:56 <benmachine> it's easy to forget how to compose binary functions
18:12:14 <pumpkin> benmachine: because they don't exist?
18:12:36 <benmachine> pumpkin: shh :P
18:12:42 <benmachine> that's not even true anyway
18:12:43 <kmc> pastorn, in principle that's not hard to implement
18:12:48 <benmachine> binary functions do exist
18:12:54 <kmc> but TH works in terms of syntax trees, not text
18:13:03 <kmc> and doesn't seem to provide a syntax tree node for imports :/
18:13:10 <benmachine> I define them to be functions that produce a function
18:13:18 <benmachine> kmc: I guess TH has to be resolved after imports
18:13:26 <kmc> i think a custom preprocessor or hsc2hs-style code generator is a reasonable solution
18:13:28 <benmachine> kmc: since you probably imported the TH code you are using :P
18:13:51 <kmc> i've been ranting for a while that Haskell needs a preprocessor which is somewhere between CPP and TH in terms of power, complexity, hackishness, etc
18:16:13 <pastorn> hehe
18:16:23 <liyang> I think she fits the bill.
18:16:50 <dolio> The main feature that would be useful beyond CPP for CPP-like purposes is easy integration with cabal.
18:17:31 <pumpkin> liyang: she isn't very general
18:18:05 <kmc> she implement specific features
18:18:10 <dolio> It doesn't really do anything that CPP does.
18:18:18 <dolio> Unless I'm missing something.
18:18:19 <liyang> she does what she does well enough.
18:18:29 <kmc> i'm talking about basic CPP-style macros, but slightly less nauseating in implementation
18:18:39 <dolio> I guess pattern aliases are a special case of macros.
18:18:39 <kmc> but firmly within the world of generating text rather than generating ASTs
18:18:53 <kmc> sometimes generating ASTs is the right solution, and I hope TH continues to improve
18:18:55 <dolio> Except, they really aren't.
18:18:57 <kmc> but sometimes it's not the right solution
18:19:20 <MrAI> How would I write an expressions for: data GTree a = GNode a [GTree a] deriving Show ? I tried "gtree1 x ys = GNode x ys" and "gtree2 = GNode 5 [7,4,3]"
18:19:43 <pastorn> data Foreign = ImportF Callconv Safety String Name Type
18:19:44 <MrAI> Its an n-tree
18:19:44 <pastorn>              | ExportF Callconv        String Name Type
18:19:49 <benmachine> kmc: I would be in favour of that except that I kind of think the nauseating is semi-intrinsic
18:19:54 <pastorn> in Language.Haskell.TH.Syntax
18:20:10 <pastorn> kmc, benmachine: could that be useful? ^^^
18:20:22 <unkanon> how do I unset something in ghci?
18:20:27 <benmachine> pastorn: that's foreign decls
18:20:30 <unkanon> I did :set -Wall but now I'm tired of it
18:20:31 <benmachine> not module imports
18:21:02 <monochrom> :set -w
18:21:12 <pastorn> damn type safety bullshit
18:21:43 <benmachine> giggle
18:21:43 <monochrom> in general http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/flag-reference.html tells you the opposite and you :set the opposite
18:21:48 <unkanon> monochrom: I would never have guessed that. thanks!
18:21:59 <unkanon> I'll look at that right now
18:22:33 <monochrom> I never guessed. I read every doc once briefly so I remember where to find things.
18:23:05 <unkanon> where did you find a handy list of "all the docs" ?
18:23:30 <monochrom> my bookmarks
18:23:43 <benmachine> unkanon: you pick it up by osmosis
18:23:52 <benmachine> just hang around them for long enough and they seep in your cell membranes
18:23:57 <benmachine> metaphorically.
18:24:15 <monochrom> every time I download a piece of software, I take note of where its doc is. usually the doc is included too. either way I bookmark them.
18:24:36 <unkanon> benmachine: I've been hanging around :)
18:24:49 <benmachine> unkanon: more!
18:24:49 <monochrom> and of course I must take note of its location because I have to read it briefly once, remember?
18:24:52 <unkanon> monochrom: I'll take that to heart
18:25:14 <benmachine> I evaluate docs lazily
18:25:29 <benmachine> I google them when I actually need to know something
18:25:35 <benmachine> actually I evaluate them speculatively
18:25:41 <benmachine> "ooh, this looks like it might be interesting"
18:25:42 <monochrom> lazy is fine. you need a thunk that points to the doc.
18:26:00 <unkanon> I have to reorganize my bookmarks I guess
18:26:24 <pastorn> doesn't lambdabot do what i want to do?
18:26:31 <pastorn> (generate imports at compile time)
18:26:49 <benmachine> pastorn: no
18:26:52 <monochrom> software should implement maximum surprise so people are motivated to take a brief look at the doc
18:26:57 <benmachine> not as far as I know anyway
18:27:15 <benmachine> monochrom: I would describe that idea as "wonderfully perverse"
18:28:06 <Funktorsalat> wasn't there some way to evaluate type expressions in ghci?
18:28:14 <MrAI> I got it thanks :D
18:28:21 <Funktorsalat> (involving type syn families)
18:29:11 <Funktorsalat> or maybe that was just a proposal ;)
18:31:36 <pastorn> bah! i'll just create a makefile that runs a small script that generates a file, which in turn just reexports stuff
18:35:52 <Veinor> yay code golfing
18:37:03 <pastorn> Veinor: lots of @pl?
18:42:29 <Veinor> pastorn: more like @undo
18:43:37 <Veinor> @. pl undo  do { r <- o ! "q"; mapM re r }
18:43:38 <lambdabot> mapM re =<< o ! "q"
18:46:35 <MrAI> Ok blonde moment..how do you pass in a non-empty set :D
18:46:39 <MrAI> to a function
18:47:00 <MrAI> I have sizeGTree (GNode _ []), need the other pattern e.g. the none empty set now :s
18:47:18 <MrAI> Is it just [xs]?
18:48:22 <MrAI> No wait got it :D
18:49:47 <cnclathe> hello guys!
18:50:12 <MrAI> Hey
18:50:13 <cnclathe> i´m need of the help with a problem wirh system in haskell
18:50:55 <cnclathe> someone can help me?
18:51:50 <cnclathe> c´mon guys, someone help me?
18:52:18 <MrAI> Im afraid im too new to Haskell to help with anything beyond the basics.
18:52:33 <Cale> cnclathe: Ask away :)
18:52:44 <ion> No need to ask to ask.
18:52:47 <cnclathe> I just need someone can pass me a program written in haskell
18:52:55 <ion> Or alternatively, you should ask to ask to ask first. ;-)
18:53:03 <cnclathe> rsrsrs
18:53:10 <cnclathe> ion, Cale, thank you.
18:53:13 <ion> â€œCan I ask whether I can ask a question about Haskell?â€
18:53:23 <cnclathe> ion, ahaha
18:53:30 <tg_> ion: I'm not sure if I can respond
18:53:34 <Cale> cnclathe: It's hard for anyone to know if they can help if they don't know what your question is. It's not customary to ask to ask on IRC.
18:53:49 <tg_> ion: but I think you... already have...
18:53:49 <MrAI> Yes your too polite cnclathe :D
18:53:54 <cnclathe> ion, you could pass me a program written in haskell?
18:53:54 <MrAI> By more mean!
18:54:08 <MrAI> *Be
18:54:12 <Cale> cnclathe: Any program at all?
18:54:13 <cnclathe> MrAI, Great! ahah
18:54:15 <ion> f = 42
18:54:23 <tg_> > f = 42
18:54:23 <lambdabot>   <no location info>: parse error on input `='
18:54:33 <Cale> cnclathe: main = putStrLn "Hello, World"
18:54:44 <MrAI> module Main where
18:54:44 * tg_ points the laser cannon haphazardly around the chatroom
18:54:44 <MrAI> f = 42
18:54:59 * MrAI ducks and falls into the chicken fryer...
18:55:35 <cnclathe> No, a simple program, or a simple system for presentation at the last minute tomorrow at college. I just need a code written in haskell to do something outside factor, calculator and so on. I need something a little more refined.
18:55:41 <tg_> we have a chicken fryer in here? That'll come in handy later...
18:55:45 <Cale> > let primes = 2 : filter isPrime [3,5..]; isPrime n = all (\p -> n `mod` p /= 0) . takeWhile (\p -> p*p <= n) $ primes in primes
18:55:46 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
18:56:20 <Cale> cnclathe: hmm, like what?
18:56:21 <Funktorsalat> static cat seems to be intrigued by the laser
18:56:34 <ion> @pl \p -> p*p <= n
18:56:35 <Cale> cnclathe: There's lots of stuff on Hackage you could look through
18:56:35 <lambdabot> (<= n) . join (*)
18:56:48 <tg_> Funktorsalat: we just got a new puppy, and he plays with laser dots just like cats do...
18:56:56 <Cale> cnclathe: http://hackage.haskell.org/packages/archive/pkg-list.html
18:56:56 <cnclathe> Yes! Cale, can be anything. Less said that because these are very simple.
18:56:59 <tg_> except, like any puppy (and unlike cats), he quickly gets bored
18:56:59 <Funktorsalat> (this one FWIW :) http://asset.soup.io/asset/1242/4612_9891_420.jpeg)
18:57:54 <cnclathe> Cale, oh you have a system ready in haskell?
18:58:23 <tg_> cnclathe: hackage is like perl's CPAN
18:58:28 <Cale> cnclathe: I don't know what you mean by 'system'. I linked you to lots of libraries and programs written in Haskell
18:59:21 <MrAI> How would I get the list length of [[2],[[4],[5]],[3]]?
18:59:26 <Cale> MrAI: length
18:59:55 <Cale> but actually, that's more likely a type error than not
19:00:08 <A1kmm> Does anyone know if there is a process for dealing with packages in Hackage which still depend on base < 4 if the maintainer doesn't respond to patches?
19:00:09 <Cale> (unless there's an instance of Num for lists)
19:00:18 <A1kmm> (patch sent on the 16th of November).
19:00:45 <Cale> A1kmm: The security model is "let anyone upload a new version of anything" still, iirc. :)
19:01:05 <cnclathe> Cale, I understand, let me explain. I just need some program code that is not simple. Would be a simple calculator in haskell, or a factorial in haskell. I wanted a code of some program to do something interesting, for example: A program that could get names and student grades, and could figure out if that student has passed the year or not.
19:01:41 <A1kmm> Cale: I guess that would be one solution... is that encouraged though?
19:02:05 <Cale> A1kmm: Well, if the maintainer has disappeared, there's not much else that you can do.
19:02:26 <MrAI> OH MY GOSH I DID IT :D:D:D
19:02:37 <MrAI> data GTree a = GNode a [GTree a] deriving Show
19:02:37 <MrAI> sizeGTree :: GTree a -> Int
19:02:37 <MrAI> sizeGTree (GNode x []) = 1
19:02:37 <MrAI> sizeGTree (GNode x (f:fs)) = 1 + sizeGTree (GNode f []) + sizeGTree (GNode x fs)
19:02:39 <MrAI> BOOM! :D
19:03:02 <unkanon> MrAI: you sure that couldn't have been a fold?
19:03:03 <A1kmm> Cale: Except I don't necessarily want to be the maintainer myself.
19:03:15 <Cale> MrAI: That looks wrong
19:03:26 <Cale> A1kmm: which package?
19:03:26 <MrAI> It works :p lol
19:03:40 <A1kmm> typehash - I have a patch which makes it work with base 4.
19:03:42 <unkanon> that looks like a fold
19:03:52 <Aune> cnclathe: try this site http://rosettacode.org/wiki/Haskell
19:04:12 <MrAI> You reckon so unkanon?
19:04:24 <unkanon> MrAI: yes it looks exactly like a fold
19:04:25 <MrAI> We of course you do :) lol. Hmmmm....
19:04:36 <benmachine> A1kmm: if it were me I'd subscribe to haskell-cafe and ask around there, in case anyone knows the maintainer
19:04:42 <Kaidelong> MrAI: what does your length function return for an empty tree
19:04:55 <Cale> MrAI: Try   sizeGTree (GNode 1 [GNode 2 [GNode 3 [GNode 4 []]]])
19:05:07 <aavogt> why shouldn't that be 1 :p
19:05:20 <aavogt> err, 2
19:05:25 <cnclathe> Aune, thank you, i´m look now
19:05:32 <MrAI> :o! It doesnt work :(
19:05:49 <Cale> MrAI: The correct answer is simpler than what you have
19:05:51 <MrAI> Unboom!
19:06:10 <aavogt> there's a   deriving Foldable, which gives you a size which probably works correctly
19:06:21 <aavogt> @hoogle size
19:06:21 <lambdabot> Data.IntMap size :: IntMap a -> Int
19:06:22 <lambdabot> Data.IntSet size :: IntSet -> Int
19:06:22 <lambdabot> Data.Map size :: Map k a -> Int
19:06:30 <aavogt> @type Data.Foldable.size
19:06:30 <lambdabot> Not in scope: `Data.Foldable.size'
19:06:31 <benmachine> aavogt: not very didactic though :P
19:06:36 <unkanon> MrAI: have a look at this: http://bit.ly/entpKj
19:06:53 <Kaidelong> MrAI: try "foldr (+) 1 (map sizeGTree fs)"
19:07:07 <Kaidelong> just to make things a bit easier on you
19:07:20 <MrAI> Two secs just looking up that link
19:07:40 <unkanon> MrAI: that will help you turn a function that has the shape of a fold into a proper fold
19:07:54 <aavogt> @hoogle t a -> Int
19:07:54 <lambdabot> Data.IntMap size :: IntMap a -> Int
19:07:55 <lambdabot> Data.Sequence length :: Seq a -> Int
19:07:55 <lambdabot> Data.Set size :: Set a -> Int
19:08:45 <aavogt> benmachine: and apparently such a function doesn't exist either
19:08:57 <HollyhockGod> 'Boolean and' is (&&), 'Boolean or' is (||), how do I write boolean xor? 
19:09:00 <benmachine> aavogt: well, there's always length . toList I guess
19:09:47 <benmachine> HollyhockGod: (/=)
19:09:52 <benmachine> i.e. not equal :)
19:09:57 <aavogt> @ty getSum . foldMap (const (Sum 1))
19:09:58 <lambdabot>     Ambiguous occurrence `getSum'
19:09:58 <lambdabot>     It could refer to either `Control.Monad.RWS.getSum', imported from Control.Monad.RWS
19:09:58 <lambdabot>                           or `Data.VectorSpace.getSum', imported from Data.VectorSpace
19:10:22 <aavogt> VectorSpace ruins all the fun here
19:10:27 <benmachine> it does rather
19:10:28 <HollyhockGod> benmachine: doh! Thanks!
19:12:14 <MrAI> foldr (+) 1 (map sizeGTree fs) doesnt work
19:13:39 <aavogt> MrAI: are you still splitting the list like   f:fs?
19:14:47 <unkanon> I want to use sortBy
19:14:54 <unkanon> how do I learn how to use it just from ghci ?
19:14:59 <unkanon> @type sortBy
19:15:01 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
19:15:16 <unkanon> what is an "Ordering" and how do I build one? (i.e. how do I ask ghci those questions?)
19:15:35 <ndrsndrs> :i Ordering
19:15:39 <unkanon> I did that
19:15:49 <unkanon> it showed me that it's an instance of Eq, Ord, etc
19:15:56 <unkanon> oh
19:16:05 <unkanon> data Ordering = LT | EQ | GT 
19:16:05 <ndrsndrs> also:
19:16:08 <ndrsndrs> @type compare
19:16:09 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:16:10 <unkanon> @info Ordering
19:16:11 <lambdabot> Ordering
19:16:47 <unkanon> hmm let me try and use t then
19:16:53 <unkanon> s/t/it/
19:30:59 <unkanon> ndrsndrs: thanks for pointing me to "compare"
19:31:16 <ndrsndrs> np
19:31:27 <unkanon> if it wasn't for that I would have an absurd "case ... of" that would say things like LT -> LT and EQ -> EQ  :P
19:32:27 <cnclathe> People, someone can help me with a simple code program? I need a recursive function to fetch a higher number.
19:32:42 <cnclathe> Cale, help-me
19:33:57 <cnclathe> MrAI, help-me
19:35:08 <Mitar> a homework assignment?
19:35:24 <aavogt> cnclathe: how much higher?
19:35:59 <aavogt> @type fix (+1) -- perhaps this is satisfactory?
19:36:00 <lambdabot> forall a. (Num a) => a
19:38:00 <roconnor> @wn paroxysm
19:38:02 <lambdabot> *** "paroxysm" wn "WordNet (r) 2.0"
19:38:02 <lambdabot> paroxysm
19:38:02 <lambdabot>      n : a sudden uncontrollable attack; "a paroxysm of giggling"; "a
19:38:02 <lambdabot>          fit of coughing"; "convulsions of laughter" [syn: {fit},
19:38:02 <lambdabot>          {convulsion}]
19:39:51 <Kaidelong> cnclathe: what do you mean by fetch a higher number and why'd you need the function to be recursive?
19:52:26 * hackagebot OpenGLRaw21 1.0 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-1.0 (JakeMcArthur)
19:53:36 <tg_> oh why oh why did he include 1.0
19:53:53 <jmcarthur> that's the package version number...
19:54:22 <tg_> yeah
19:54:28 <tg_> can you choose it arbitrarily?
19:54:37 <benmachine> yes
19:54:40 <jmcarthur> well, yes, but i wouldn't want to
19:54:48 <tg_> is it 1.0 stable?
19:54:51 <benmachine> hence HTTP being on version 4001 or something
19:55:04 <jmcarthur> i inevitably will need to make changes to it, so the version number just can't correlate with the opengl version number
19:55:33 <tg_> jmcarthur: i know, I just felt a small sense of horror reading that line
19:55:35 <benmachine> jmcarthur: well you could have the major version number match and twiddle the minors, or something
19:56:26 <jmcarthur> tg_: all it does is reexport some stuff from OpenGLRaw, so in that sense it is stable. if i have to add more things to export later than i will have to change the version number of course. 1.0 doesn't have to imply stability, either way
19:56:41 <jmcarthur> as long as i follow the version numbering policy
19:56:56 <jmcarthur> benmachine: yeah but then i might not be able to follow policy :\
19:57:10 <benmachine> jmcarthur: true, I suppose
19:57:40 <jmcarthur> i probably should have made that something like 1.0.0.0 or something though. i don't know how cabal treats missing minor numbers
19:58:20 <jmcarthur> i should change that...
19:58:47 <tg_> jmcarthur: like I said, I don't have any formal objection nor a suggestion for improvement
19:59:09 <tg_> It just seemed, reading the hackagebot announcement... that small children are crying somewhere
19:59:43 <benmachine> jmcarthur: I don't believe it's important
19:59:46 <jmcarthur> i once felt the same way about the other OpenGL packages
19:59:52 <jmcarthur> benmachine: well, too late ^_^
20:00:08 <benmachine> I think 1.0 < 1.0.0.0 but most people will go >= 1.0 or == 1.0.* which both do the Right Thing I think
20:00:23 <jmcarthur> i seem to recall having issues with the 1.0.* syntax
20:00:29 * hackagebot OpenGLRaw21 1.0.0.1 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-1.0.0.1 (JakeMcArthur)
20:00:31 <jmcarthur> and short number strings i mean
20:00:36 * benmachine shrug
20:00:50 <benmachine> if it doesn't do what you want that might be a bug? :P
20:00:56 <jmcarthur> probably is
20:01:12 <jmcarthur> either way, if my memory is serving me correctly, i'd like to avoid myself or others having the same issue
20:02:08 <pastorn> is there a way to enforce a special error message if an import doesn't exist
20:02:11 <pastorn> ?
20:02:17 <pastorn> (since i will be generating the import)
20:11:56 <tg_> has anyone here given any thought about how to approach rewriting haskellbot?
20:14:26 <tg_> s/haskellbot/lambdabot/
20:16:55 <crutcher> If I want to use Iteratees, which lib should i use? Data.Enumerator seems more complete
20:27:45 <lispy> crutcher: yeah, use that one
20:27:58 <lispy> crutcher: that's sort of the latest and greatest in the evolution of iteratees
20:28:21 <lispy> tg_: What do you want to change?
20:28:29 <crutcher> lispy: thanks :)
20:28:32 <lispy> tg_: It's actually been rewritten once already
20:28:50 <lispy> tg_: that doesn't mean it can't get better, so what do you have in mind :)
20:28:53 <aavogt> @seen
20:28:53 <preflex>  what
20:28:53 <lambdabot> Unknown command, try @list
20:44:32 <Funktorsalat> for a class with a method that only depends on the type (like Typeable) and with significant cost to calculate the value (say an Int), wouldn't it be better to have method have type (Int,a) rather than a -> Int?
20:44:40 <Funktorsalat> so it gets memoized
20:45:03 <Funktorsalat> *the method
20:45:26 <Funktorsalat> you'd use it like "fst (themethod :: (Int,MyType))"
20:45:56 <Funktorsalat> it'd return undefined in the second component
20:46:21 <Kaidelong> Funktorsalat: why not make a data type for it and use that?
20:46:33 <Kaidelong> data CachedWhatever
20:46:38 <Funktorsalat> Kaidelong: instead of (mis)using (,)?
20:46:50 <Kaidelong> well why would you want to use an undefined value
20:46:58 <aavogt> Funktorsalat: does it really get memoized?
20:47:12 <Funktorsalat> Kaidelong: the type needs to appear in the method signature *somewhere*
20:47:22 <jmcarthur> Funktorsalat: see the tagged package
20:47:27 <aavogt> or you're expecting some CSE to happen (which you should really expect not to happen)
20:47:30 <Funktorsalat> aavogt: hmm I don't know, I assumed it would
20:48:24 <Funktorsalat> since there's only one dictionary value globally, or not?
20:48:31 <Kaidelong> I've got an issue that sounds similar (calculating fitness values for bus routes) and my solution was to make a data type that has a cached fitness (maybe) and re-define my operations over that data-typed
20:48:32 <Funktorsalat> (per instance)
20:49:15 <Funktorsalat> jmcarthur: ah, Tagged Int sounds sensible
20:49:27 <jmcarthur> well, it would be Tagged a Int
20:49:27 <Funktorsalat> *Tagged a Int
20:49:30 <jmcarthur> yeah
21:00:35 <Funktorsalat> so I tried to test it http://hpaste.org/41943/wtf
21:00:39 <Funktorsalat> explanation? :o
21:01:03 <Funktorsalat> ah wait, the trace output is *between* the 'Tagged' and the '3'
21:01:13 <Funktorsalat> thought I was going mad
21:01:34 <Funktorsalat> aavogt: that seems to show that it does get memoized
21:02:34 <aavogt> Funktorsalat: memoized would be only one trace output
21:02:45 <Funktorsalat> there is only one for the mfoo :)
21:03:03 <aavogt> tricky
21:03:37 <Funktorsalat> apparently it isn't cse, since it dumps stuff when compiling with -O, but not without, and mfoo is memoized even without
21:03:53 <Funktorsalat> curiously, -O makes the foo get memoized too
21:04:09 <Funktorsalat> (or optimized some other way)
21:05:10 <jmcarthur> is foo still shared if you do it with -O -fno-full-laziness ?
21:06:30 <jmcarthur> Funktorsalat: ^^
21:07:24 <Funktorsalat> jmcarthur: yes
21:07:29 <jmcarthur> ah interesting
21:07:42 <jmcarthur> that may be some cse then perhaps
21:08:23 <jmcarthur> Funktorsalat: what about -O -fno-full-laziness -fno-cse ?
21:08:44 <Funktorsalat> jmcarthur: hmm, still
21:08:45 <jmcarthur> i suspect it won't make a difference
21:08:48 <jmcarthur> okay
21:08:55 <Funktorsalat> maybe it just gets evaluated statically?
21:09:04 <jmcarthur> well now i'm curious which optimization is doing it
21:09:24 <jmcarthur> it could just be that, yeah
21:09:33 <Funktorsalat> command line is 'ghc --make memo.hs -fforce-recomp -O -fno-full-laziness -fno-cse' in case the order matters
21:10:04 <jmcarthur> maybe you could stick a NOINLINE under your implementation of foo
21:10:21 <jmcarthur> whatev
21:11:39 <Kaidelong> common subexpression elimination?
21:11:50 <jmcarthur> that's cse, yes
21:11:57 <Kaidelong> thanks
21:12:42 <Funktorsalat> heh. only one "fooing..." even with {-# NOINLINE foo #-}
21:14:10 <lispy1> Funktorsalat: you should read the core if you really want to understand what you're getting
21:14:24 <lispy1> Funktorsalat: cabal install ghc-core
21:14:38 <Funktorsalat> lispy1: trying but it's full of noise :|
21:14:49 <lispy1> Funktorsalat: try harder :)
21:16:11 <Funktorsalat> what's this: "RULES: Built in rule for foo: "Class op foo""
21:16:18 <Funktorsalat> in an annotation in the core
21:26:08 <lispy1> Funktorsalat: it's an optimization
21:26:23 <lispy1> Funktorsalat: But, I can't tell from that how it works or what it does
21:28:40 <Funktorsalat> it gets stranger still. if I remove the MemoFoo stuff (to get less core), -fno-full-laziness does make it trace twice ( @ jmcarthur )
21:30:33 <jmcarthur> Funktorsalat: it makes the Foo stuff trace twice? weird!
21:31:31 <jmcarthur> that only happens with -fno-full-laziness? you're sure it wouldn't do the same with just -O2 and without MemoFoo?
21:31:49 <jmcarthur> -O, i mean
21:32:29 <Funktorsalat> it traces once in all combinations of MemoFoo-present * full-laziness except (MemoFoo absent, no-full-laziness) :)
21:32:49 <jmcarthur> really weird...
21:34:49 <Funktorsalat> jmcarthur: ah wait. I also moved the NOINLINE pragma around in the MemoFoo-less version...
21:35:20 <Funktorsalat> put it indented into the instance Foo () instead of toplevel
21:35:53 <Funktorsalat> that makes the (yes MemoFoo, no-full-laziness) print twice too
21:36:17 <jmcarthur> okay
21:37:10 <jmcarthur> so the NOINLINE along with -fno-full-laziness makes it print twice
21:37:15 <jmcarthur> that is about what i'd expect
21:37:18 <Funktorsalat> didn't realize indentation matters
21:38:12 <jmcarthur> yeah the NOINLINE has to be indented under the instance definition in order to apply to a method definition
21:38:37 <jmcarthur> i'm surprised you weren't getting a warning with it not indented like that
21:39:17 <Funktorsalat> no warning, indeed (even with -Wall)
21:39:34 <jmcarthur> oh well
21:39:41 <jmcarthur> i'm satisfied with this result at least
21:40:01 <Funktorsalat> while {-# NOINLINE nonexistant #-} is an error, even
21:40:02 <jmcarthur> it mirrors my own experiences messing with sharing and optimizations
21:44:13 <Funktorsalat> MemoFoo is unaffected by NOINLINE as expected
21:44:58 <Funktorsalat> (or by -O0, even)
22:13:08 * hackagebot Etage 0.1 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1 (MitarMilutinovic)
22:14:08 * hackagebot NXT 0.1.6 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1.6 (MitarMilutinovic)
22:26:57 <adnap> Can you not use as-patterns on types created with type synonyms?
22:28:17 <mauke> huh?
22:28:59 <adnap> mauke: Do you know what an as-pattern is?
22:29:14 <mauke> yes
22:29:25 <Kaidelong> adnap: don't type synonyms just get turned into the thing it is a synonym for?
22:29:30 <c_wraith> I don't! someone want to fill me in?
22:29:37 <mauke> c_wraith: var@pattern
22:29:45 <Kaidelong> so you're probably fine
22:29:49 <c_wraith> Oh.  What's that got to do with types at all?
22:29:53 <mauke> nothing
22:29:57 <c_wraith> then I'm confused
22:30:05 <mauke> so am I
22:30:11 <adnap> So, I have a type Foo = (Int, Int Int)
22:30:18 <mauke> kind error
22:30:33 <adnap> um, what?
22:30:38 <adnap> How is that a kind error?
22:30:44 <ddarius> adnap: Read more closely.
22:31:13 <Kaidelong> @kind Int Int
22:31:14 <lambdabot>     Kind error: `Int' is applied to too many type arguments
22:31:20 <adnap> oh come on
22:31:27 <adnap> type Foo = (Int, Int, Int)
22:31:30 <adnap> geez
22:31:33 <adnap> Okay
22:31:49 <Kaidelong> all that happens is that the compiler substitutes (Int, Int, Int) for Foo when it sees foo in type signatures
22:32:03 <Kaidelong> it does not have anything to do with patterns
22:32:04 <adnap> So, I can't use as-patterns on built-in types?
22:32:05 <Kaidelong> so you are fine
22:32:13 <mauke> adnap: you can't use patterns on types
22:32:17 <mauke> patterns are for values
22:32:39 <adnap> mauke: I feel like you're maybe picking on me.  Do you really not understand what I mean?
22:33:03 <c_wraith> adnap, post some code.
22:33:13 <mauke> adnap: yes! I have no idea what you're talking about!
22:33:15 <c_wraith> But really, type aliases are irrelevant to pattern matching
22:33:15 <Kaidelong> adnap: I am pretty sure either we don't know what you mean or you don't know what we mean, so a little clarification would be nice
22:33:34 <mauke> adnap: you post some fake code containing errors then go off and ask about pattern matching, which has nothing to do with type synonyms
22:33:38 <mauke> wtf?
22:34:57 <adnap> Well, apparently what I'm thinking of works.  I will post the code so that everyone knows what I mean.
22:35:02 <kadoban> adnap: anyway, you can certainly pattern match on tuples, including using as patterns, if that's what you're asking...it just has notrhing to do with type synonyms
22:35:30 <adnap> http://hpaste.org/41945/aspattern
22:35:52 <Kaidelong> yeah
22:35:59 <Kaidelong> that has nothing to do with the type synonym
22:36:02 <Kaidelong> hence why it works
22:36:02 <adnap> Okay, but I had a specific issue when using a type synonym.
22:36:13 <mauke> then why don't you ask about your actual issue?
22:36:15 <adnap> I wasn't sure if it was related until I made this simple example.
22:36:52 <adnap> mauke: Because I would like to avoid the burden of explaining a larger problem if it can be simplified.
22:37:09 <mauke> that worked well
22:37:19 <adnap> mauke: Why are you being such an ass to me?
22:37:44 <Kaidelong> just chill out dude, we can work through this
22:37:56 <Kaidelong> show the code that was causing the problem?
22:38:12 <adnap> I was perfectly fine before mauke started snapping at me.
22:38:26 <Kaidelong> I don't think mauke has anything against you in particular
22:38:47 <Kaidelong> and that won't help fix the problem anyway
22:39:12 <adnap> Alright, so, ghci has problems when I use as-patterns in the following code...
22:39:21 <crutcher> which lib for Typeable is the correct lib for Typeable?
22:40:02 <guest2425> hello
22:40:55 <mauke> adnap: I'm sorry, I don't have anything against you
22:41:24 <adnap> http://hpaste.org/41946/aspattern_problem
22:41:32 <mauke> but to quote mst, "This sounds like a case of having solved half of your problem, and now just needing help with the other half - the half that doesn't make any sense"
22:41:57 <Kaidelong> could you annotate the error adnap?
22:42:36 <adnap> did
22:43:12 <Kaidelong> adnap: I'd say your problem is that .: is different type constructor from ,
22:43:21 <adnap> mauke: I'm sorry if I didn't make any sense, but sometimes that happens when you have a problem, because the source of your problem is a misunderstanding.
22:43:21 <Kaidelong> wait perhaps not
22:43:33 <Kaidelong> oh this is beyond what I know nevermind, someone else handle it
22:43:46 <adnap> By the way, it works just fine if I don't use the as-pattern.
22:44:26 <adnap> Actually, that's not true.
22:44:56 <adnap> It seems the problem is something else entirely.  However, it does work when I use an as-pattern and make Triangle a real type.
22:46:21 <adnap> Well, I need to make Triangle a real type anyway.
22:56:55 <guest2425> hello
23:01:22 <lispy1> guest2425: hello, welcome to #haskell
23:01:34 <lispy1> wow, there are a lot of guests here
23:01:57 <lispy1> really messes with my autocompletion
23:06:23 <dskippy> Is there type class that will make my data type cyclic in enumeration, so (succ maxBound) == minBound or do I need to write a function for that?
23:07:05 <guest2425> lispy1: thank you
23:07:50 <copumpkin> dskippy: you could make a newtype for that
23:08:05 <copumpkin> with an instance on it
23:09:30 <copumpkin> newtype Cyclic a = Cyclic a; instance (Eq a, Bounded a, Enum a) => Enum (Cyclic a) where blah
23:10:08 <dskippy> copumpkin: I could make a new type class that others could derive I guess.
23:10:19 <copumpkin> why would you?
23:10:24 <dskippy> I was wondering if it were as simple as "deriving CyclicEnum" is all.
23:10:34 <copumpkin> and people can't derive custom typeclasses
23:16:40 <Mitar> is return strict? does it force evaluation?
23:16:52 <Mitar> so after: a <- return somePureComputation
23:16:57 <Mitar> is a evaluated or not?
23:18:45 <McManiaC> no
23:18:55 <bss03> Mitar: AFAIK, return is not strict.
23:19:04 <McManiaC> dont use "x <- return y"
23:19:14 <McManiaC> "let x = y" is way better practice
23:19:22 <Veinor> yeah
23:19:43 <bss03> You might want "x <- return $! y", but that is a pretty silly use of return.
23:20:25 <McManiaC> let !x = 5
23:20:57 <McManiaC> I think it requires BangPatterns
23:21:24 <Mitar> ok, more general question: if I send some value over Chan
23:21:33 <Mitar> on which side of Chan it is evaluated?
23:21:43 <copumpkin> whoever needs it
23:21:45 <bss03> But, "!" or "seq" only get you to HNF, FWIU.  If you want to force full evaluation, look at the deepseq package.
23:21:49 <Mitar> before I send it or when the other side tried to use it
23:22:33 <copumpkin> Mitar: when it needs to be evaluated, it'll be evaluated
23:22:47 <bss03> "Use" forces evaluation; maximal laziness.
23:22:52 <copumpkin> Mitar: if you send it over the chan, and then later evaluate it yourself, the other guy will get the "memoized" evaluated version
23:22:55 <McManiaC> I'd say that's a more specific question ;)
23:23:16 <copumpkin> if you send it over the chan, then the other person evaluates it, then it'll get evaluated "over there"
23:23:30 <Mitar> ;-)
23:23:51 <Mitar> great, very fun when you try to offload things with threads
23:24:13 <copumpkin> basically, Chans don't affect the evaluation model at all
23:24:27 <bss03> Just like in "let x = crazyLongCalculation in (x, x)" if someone evaluates part of "fst" whoever uses "snd" won't calculate it again.
23:24:47 <Mitar> so the only thing which in fact forces evaluation is interaction with world
23:25:00 <McManiaC> Mitar: no, see above
23:25:10 <copumpkin> bss03: what if crazyLongCalculation returns a polymorphic value? :)
23:25:12 <McManiaC> use seq or "!"
23:25:28 <bss03> `seq` and deepseq can make sure things are evaluated in a certain order.
23:25:50 <bss03> x `seq` y "looks" like y, but forces the evaluation of x before y is evaluated.
23:26:00 <Mitar> yes, i understand, i thought without special flags
23:26:23 <Mitar> so if programmer does not specifically say so only interaction with world evaluates things
23:26:24 <McManiaC> they're not that special... :)
23:26:32 <McManiaC> and seq works without it
23:26:44 <bss03> copumpkin: Er, use [x,x] instead then.
23:27:01 <bss03> And head / last instead of fst / snd.
23:27:32 <McManiaC> it could still be polymorphic :>
23:27:44 <bss03> Mitar: By default, Haskell is "maximally lazy", yes.
23:28:19 <McManiaC> > let x = read in ( (x "5" :: Int) , (x "2.5" :: Float) )
23:28:20 <lambdabot>   (5,2.5)
23:28:30 <bss03> McManiaC: Yes, but [x,x] forces both head and last to be the same type.  So evaluating the head and the tail are the same object.
23:29:14 <copumpkin> bss03: what if you have impredicative polymorphism turned on and the caller evaluates x as different types!??!
23:29:34 <bss03> copumpkin: You lost me.
23:29:38 <McManiaC> bss03: it's about creating a polymorphic list, not about different types in its elements
23:29:42 * bss03 is NOT a type expert.
23:29:49 <copumpkin> bss03: you can have [forall a. (Blah a) => a]
23:30:06 <McManiaC> crazyLongCalculation :: Blah => [a]
23:30:15 <McManiaC> *Blah a =>
23:30:19 <bss03> copumpkin: Isn't that a rank 1 type... so not in H-M typing?
23:30:28 * hackagebot weighted-regexp 0.3.1 - Weighted Regular Expression Matcher  http://hackage.haskell.org/package/weighted-regexp-0.3.1 (SebastianFischer)
23:30:29 <copumpkin> it won't get inferred
23:30:43 <copumpkin> but with impredicative types you can specify it if applicable
23:31:09 <bss03> copumpkin: In that case, don't DO that. :P
23:31:36 <McManiaC> :D
23:34:57 <copumpkin> > let x :: [forall a. Num a => a]; x = [genericLength [1..1000000], genericLength [1......20000000]; in (x !! 0 :: Double, x !! 1 :: Int, x !! 0 Integer)
23:34:59 <lambdabot>   <no location info>: parse error on input `;'
23:35:07 <copumpkin> > let x :: [forall a. Num a => a]; x = [genericLength [1..1000000], genericLength [1......20000000] in (x !! 0 :: Double, x !! 1 :: Int, x !! 0 Integer)
23:35:09 <lambdabot>   <no location info>: parse error on input `in'
23:35:59 <Veinor> copumpkin: interesting type signature for x :o
23:37:13 <copumpkin> indeed!
23:39:08 <bss03> > let { x :: [forall a. Num a => a]; x = [genericLength [1..1000000], genericLength [1......20000000]]} in (x !! 0 :: Double, x !! 1 :: Int, x !! 0 Integer)
23:39:09 <lambdabot>   Not in scope: `......'Not in scope: data constructor `Integer'
23:39:18 <bss03> > let { x :: [forall a. Num a => a]; x = [genericLength [1..1000000], genericLength [1......20000000]]} in (x !! 0 :: Double, x !! 1 :: Int, x !! 0 :: Integer)
23:39:19 <lambdabot>   Not in scope: `......'
23:39:40 <copumpkin> lol, I need to sleep
23:39:41 <bss03> > let { x :: [forall a. Num a => a]; x = [genericLength [1..1000000], genericLength [1..20000000]]} in (x !! 0 :: Double, x !! 1 :: Int, x !! 0 :: Integer)
23:39:42 <lambdabot>   (*Exception: stack overflow
23:40:44 <bss03> Not that I didn't believe you before, but that type-checked so I know GHC implements that crazyGoNuts stuff.
23:41:13 <Mitar> if i say: time <- getPOSIXTime
23:41:17 <Mitar> and send this time over chan
23:41:55 <Mitar> will this time will have a value of current time before i send it through channel?
23:42:09 <Mitar> or of time when it was evaluated at the end?
23:42:39 <bss03> The I/O doesn't have to be performed until time is evaluated, so I'd say when it was evaluated.  But, I'm not sure.
23:43:55 <bss03> The getPOSIXTime will be evaluated before any subsequent I/O actions and after previous I/O actions, since the IO Monad effectively sequences it's monadic operations.
23:45:26 <bss03> Other Monads may or may not do such sequencing.  I've not dealt with Chans; do they operate inside the IO Monad?
23:47:01 <Mitar> yes, they are inside IO chans
23:48:04 <Mitar> but the quesiton is how deep does IO monad evaluate the value
23:50:45 <c_wraith> the value from getPOSIXTime is fixed when the action is sequenced
23:51:19 <c_wraith> It's not lazy.
23:54:08 <sinelaw> @pl concat . intersperse
23:54:08 <lambdabot> join . intersperse
23:54:11 <sinelaw> BAH
23:54:18 <sinelaw> @type concat . intersperse
23:54:20 <lambdabot>     Couldn't match expected type `[[a]]'
23:54:20 <lambdabot>            against inferred type `[a1] -> [a1]'
23:54:20 <lambdabot>     Probable cause: `intersperse' is applied to too few arguments
23:54:45 <sinelaw> @type \ x xs -> concat . intersperse x $ xs
23:54:46 <lambdabot> forall a. [a] -> [[a]] -> [a]
23:54:55 <sinelaw> @pl \ x xs -> concat . intersperse x $ xs
23:54:55 <lambdabot> (join .) . intersperse
23:55:00 <medfly> :t (concat . intersperse)
23:55:01 <lambdabot>     Couldn't match expected type `[[a]]'
23:55:01 <lambdabot>            against inferred type `[a1] -> [a1]'
23:55:01 <lambdabot>     Probable cause: `intersperse' is applied to too few arguments
23:55:03 <sinelaw> @hoogle [a] -> [[a]] -> [a]
23:55:03 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
23:55:04 <lambdabot> Prelude (++) :: [a] -> [a] -> [a]
23:55:04 <lambdabot> Data.List (++) :: [a] -> [a] -> [a]
23:55:10 <sinelaw> intercalate :)
23:55:40 <Mitar> but arguments for sequenced action are no necessary fixed if the action itself does not evaluate them?
23:56:34 <c_wraith> Mitar, correct
23:57:03 <Mitar> thanks
23:57:23 <c_wraith> Also, different monads have different rules
23:57:38 <c_wraith> But few actions in IO have lazy results.
