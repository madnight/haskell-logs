00:00:03 <Axman6> fmap :: (a -> b) -> (r -> a) -> (r -> b)
00:00:17 <tolkad> that's just one instance of fmap
00:00:30 <Axman6> tolkad: and that';s the one instance he's asking about.
00:00:58 <tolkad> @instances Functor
00:00:59 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
00:01:14 <Axman6> lars9: still with me?
00:01:38 <lars9> tolkad: yeah i understand behavior of fmap with List Maybe etc just not Function, so Function is what we are talking about
00:01:58 <lars9> Axman6: yeah, watching & learning, thanks very much
00:02:08 --- mode: quicksilver set -o quicksilver
00:02:17 <tolkad> @src (fmap :: (a -> b) -> (r -> a) -> (r -> b))
00:02:17 <lambdabot> Source not found. I've seen penguins that can type better than that.
00:02:23 <tolkad> -_-
00:02:24 <Axman6> lars9: ok, so, if we're lucky, the type of fmap i showed you there will be familliar, but you might not know it yet
00:02:35 <tolkad> @src instance Functor ((->) r)
00:02:35 <lambdabot> Source not found. There are some things that I just don't know.
00:02:48 <Axman6> tolkad: shoosh, please. trying to learn from many people at once is confusing
00:02:55 <Axman6> and i got here first ;)
00:03:05 <ray> @src Functor ((->) r)
00:03:05 <lambdabot> Source not found. Wrong!  You cheating scum!
00:03:10 <ray> it's something like that
00:03:20 <ray> @src Monad Maybe
00:03:20 <lambdabot> Source not found. My mind is going. I can feel it.
00:03:28 <ray> i know they are in there
00:03:28 <Axman6> it's @src ((->) r) fmap, but we'll get to that
00:03:42 <tolkad> @src ((->) r) fmap,
00:03:42 <lambdabot> Source not found. My mind is going. I can feel it.
00:03:44 <Axman6> lars9: care to join me in #haskell-blah?
00:03:44 <tolkad> @src ((->) r) fmap
00:03:44 <lambdabot> Source not found. I am sorry.
00:03:53 <lars9> Axman6: sure,
00:03:57 <Axman6> thanks
00:32:58 <guest2425> Hello
00:33:04 <guest2425> I have a question
00:33:08 <guest2425> about Haskell
00:33:27 <Neurotron> Hello all.
00:33:38 <guest2425> Hello
00:33:45 <guest2425> I need help big time
00:33:47 <Neurotron> ?
00:34:01 <guest2425> yes a big question
00:34:11 <Neurotron> I'm intending to master Haskell, does anyone have good recommendations on how?
00:38:33 <guest2425> I am getting this error message http://pastebin.com/NxjzWMwT
00:38:37 <guest2425> please help
00:38:50 <kfish> Neurotron, hack lots, read lyah and the typeclassopedia, learn about types, learn to profile
00:39:01 <Saizan> Neurotron: also RWH
00:39:05 <Neurotron> kfish: As in Learn Yourself a Haskell?
00:39:20 <Neurotron> kfish: The process is tedious, isn't it?
00:39:23 <Saizan> then start reading papers
00:39:43 <Saizan> and absorb from #haskell
00:39:46 <Neurotron> What if you do not have a strong mathematical background, is that still all right?
00:39:54 <Saizan> yep
00:39:59 <kfish> Neurotron, sure, just code :)
00:40:17 <Neurotron> Oh I see.
00:40:23 <Neurotron> How long did you guys take to master it?
00:41:40 <Neurotron> (I got interested in Haskell because I read somewhere that it was good for concurrency. Is that true also?)
00:41:41 <Starfire> No one has mastered Haskell, we are all just in different stages of training. :)
00:41:47 <ibid> guest2425: looks to me like a rather clear error message
00:41:57 <Neurotron> Starfire: Yeah I guess so.
00:42:12 <Starfire> But yes, Haskell is very good for concurrency.
00:43:11 <Neurotron> Somehow it kind of gets very tedious along the way. I mean I haven't even reached monads yet and I'm getting overwhelmed.
01:01:14 <guest2425> hello 
01:01:20 <guest2425> I have another error message 
01:03:41 <guest2425> Here is the error message http://pastebin.com/Q90p4GaY
01:03:59 <guest2425> I am trying to do a draw Tree with no limitations
01:05:08 <Entroacceptor> line 5 is wrong
01:05:34 <Entroacceptor> and you want the 'where' clause further down, I think
01:06:21 <Entroacceptor> you're missing at least one )
01:06:46 <guest2425> Entroacceptor: I am missing a (
01:06:59 <Rutix> no
01:07:00 <Rutix> a )
01:07:09 <Entroacceptor> and a proper definition
01:07:12 <Rutix> and i guess the (show aTree a is wrong too
01:10:03 <Entroacceptor> guest2425: what type should drawTree have?
01:11:02 <Entroacceptor> guest2425_: what type should drawTree have?
01:12:59 <guest2425_> this
01:13:06 <guest2425_> drawTree :: (Show t) => Tree t -> [Char]
01:13:19 <guest2425_> oh now
01:13:58 <guest2425_> This drawTree :: Tree String -> StringSource
01:14:44 <guest2425_> Entroacceptor:  drawTree :: Tree String -> StringSource
01:15:00 <guest2425_> But I want to create this one drawTree :: (Show t) => Tree t -> [Char]
01:15:14 <guest2425_> Entroacceptor:: drawTree :: (Show t) => Tree t -> [Char]
01:15:23 <guest2425_> am i in the correct track
01:15:58 <Entroacceptor> that looks reasonable, and better than the stuff in that paste
01:16:35 <guest2425_> Entroacceptor: what I have is wrong?
01:16:49 <Entroacceptor> #
01:16:53 <Entroacceptor> drawTree :: (show aTree a -> StringdrawTree  =  unlines . draw
01:17:10 <Entroacceptor> where does that look like drawTree :: (Show t) => Tree t -> [Char] 
01:17:11 <Entroacceptor> ?
01:20:55 <guest2425_> Entroacceptor: Do you know how can I  tested ?
01:24:18 <guest2425_>  Entroacceptor: Do you know how can I  tested  my function?
01:24:31 <Entroacceptor> I don't understand what you're asking
02:13:15 <adnap> Is there something which simplifies the following? (\x -> return $ foo x)
02:14:01 <Saizan> return . foo
02:14:40 <Saizan> m >>= return . foo = liftM foo m     (= fmap foo m = foo <$> m, btw)
02:15:25 <adnap> Yeah, I had tried that.  I'm not sure why it's not working.  I guess it must be something else.
02:15:38 <Jafet> = foo.m
02:16:48 <adnap> Oh wait, the problem is actually this: \x y -> return $ foo x y
02:17:18 <Saizan> that'd be (return .) . foo
02:17:28 <sipa> @pl \x y -> return $ foo x y
02:17:28 <lambdabot> (return .) . foo
02:17:33 <adnap> Bwuuhh?
02:17:35 <sipa> nice, Saizan :)
02:17:41 <Jafet> @pl \x y z -> return $ foo x y z
02:17:41 <lambdabot> ((return .) .) . foo
02:17:43 <adnap> Also, what does pl stand for?
02:17:48 <Jafet> I like this series.
02:17:49 <sipa> pointless
02:17:59 <Saizan> or "(fmap . fmap) return foo" if you prefer
02:18:18 <Saizan> (with the Functor ((->) r) instance for those fmap's)
02:18:53 <tolkad> @src (.)
02:18:53 <lambdabot> (f . g) x = f (g x)
02:18:53 <lambdabot> NB: In lambdabot,  (.) = fmap
02:19:10 <tolkad> @src fmap
02:19:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
02:19:13 <adnap> I would like to partially apply one of the arguments.
02:19:30 <adnap> (return .) . foo x doesn't work.
02:19:46 <Jafet> > let (.) = fmap in succ.[0]
02:19:47 <Saizan> in that case it's "return . foo x"
02:19:47 <lambdabot>   [1]
02:19:57 <adnap> I tried that.
02:20:02 <Saizan> you keep changing the description of your problem
02:20:14 <Saizan> maybe you could paste the actual code with the error you're getting
02:20:22 <adnap> Oh, shoot.
02:20:27 <adnap> It was a parenthesis problem.
02:20:31 <adnap> Nevermind -_-
02:20:44 <Jafet> adnap: you can't concatenate valid code with valid code in haskell and expect the result to be valid
02:21:02 <Saizan> btw, "((retunrn .) . foo) x" would have worked
02:21:16 <adnap> See, 'cause return . foo x was actually being passed to another function, and I didn't write (return . foo x)
02:21:30 <Saizan> makes sense
02:22:02 <adnap> I think I just overlooked it because return . foo x was on a line by itself, as I had broken the arguments to the outer function onto multiple lines.
02:22:24 <adnap> The code is pretty neato.
02:22:35 <adnap> I was just testing out gpipe-collada
02:22:44 <adnap> It works really nicely.
02:23:30 <adnap> I'll put it on hpaste in a sec in case anyone wants to give it a try.
02:24:38 <adnap> Also, you can pattern match a list like this, right? x:_
02:25:16 <adnap> Yep, seems to work.
02:27:07 <tolkad> lol I remember when I firsted started with haskell I thought I had to check whether a list was empty before I could pattern match on (:), in other words I thought I had to pattern match on [] first
02:29:13 <adnap> Here it is: 
02:29:22 <adnap> fail
02:29:25 <adnap> http://hpaste.org/41134/view_collada
02:29:50 <adnap> This is a good place to find collada stuff, apparently: http://sketchup.google.com/3dwarehouse/
03:14:02 <ketil> @hello?  Bot?
03:14:02 <lambdabot> Unknown command, try @list
03:14:19 <ketil> ah.
03:14:27 <tolkad> > 5
03:14:28 <lambdabot>   5
03:14:44 <tolkad> it's use is mostly just to execute haskell
03:14:51 <tolkad> look up the source of haskell functions
03:14:55 <tolkad> search for haskell functions
03:21:56 <gspr_> Say I have a type parametrized by two type variables: data Foo a b = Foo a b. In the context  (Ord b, Ord c)  I have a  map :: (b -> c) -> Foo a b -> Foo a c  behaving map-like.
03:22:14 <gspr_> Now I want  Foo a  to be an instance of Functor, and naturally I'd like fmap to be map.
03:22:52 <gspr_> But  map  is only available when the second type parametrizing Foo is an instance of Ord. Is there a way to state this when making Foo a  an instance of Functor?
03:23:00 <quicksilver> no, unfortunately not.
03:23:05 <gspr_> ugh :(
03:23:11 <quicksilver> constrained Functors aren't Functors, in haskell
03:23:18 <gspr_> that's a shame
03:23:26 <quicksilver> it is.
03:23:44 <gspr_> thanks for giving the above thingy a name, though :)
03:24:00 <quicksilver> I'm not sure it's the right name actually
03:24:09 <gspr_> It sounds good, though
03:24:28 <quicksilver> this is relevant, gspr_ : http://comonad.com/reader/2007/parameterized-monads-in-haskell/
03:24:34 <gspr_> I was about to ask a stackoverflow question with a title like "constraining functors in haskell"
03:24:35 <quicksilver> it's about monads but the basic problem is the same
03:24:46 <gspr_> ah, thanks
03:24:52 <tolkad> gspr_: you could make your own class CFunctor f a where cfmap :: CFunctor f b => (a -> b) -> f a -> f b
03:25:09 <gspr_> tolkad: Yeah, I was about to before coming here
03:25:40 <gspr_> tolkad: In my case it'll probably be fine too, but in *general* one would sort of lose the entire point, wouldn't one?
03:25:56 <quicksilver> gspr_: this is also relevant : http://okmij.org/ftp/Haskell/types.html#restricted-datatypes
03:26:56 <gspr_> quicksilver: Thanks
03:27:13 <quicksilver> gspr_: and here is an LTU thread on the topic : http://lambda-the-ultimate.org/node/2911
03:29:39 <gspr_> interesting, that seems very in line with my problem indeed
03:55:30 <wto> > take 100 $ cycle "OM N"
03:55:31 <lambdabot>   "OM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM NOM...
03:55:34 <wto> :D
03:56:09 <Jafet> > cycle "OL"
03:56:10 <lambdabot>   "OLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOLOL...
03:56:45 <Entroacceptor> > bicycle 
03:56:46 <lambdabot>   Not in scope: `bicycle'
04:23:14 * hackagebot hmk 0.9.7.1 - A make alternative based on Plan9's mk.  http://hackage.haskell.org/package/hmk-0.9.7.1 (MathieuBoespflug)
04:39:59 <kstt> quicksilver: hi. You kindly advised me yesterday to wrap the Snap monad in a ReaderT so that I could carry implicitely a persistent shared MVar accross requests.
04:40:11 <quicksilver> well actually I didn't, quite :)
04:40:23 <quicksilver> I wasn't sure if that would be possible in the way Snap works.
04:40:42 <quicksilver> because frameworks don't necessarily allow you to extend their monads.
04:41:02 <quicksilver> I spent 5 mins looking at the Snap docs but couldn't easily see what the recommended solution was, and then had to go back to work.
04:41:53 <kstt> true, I just read back the log, and you advised me to pass it explicitely. Another haskeller proposed the ReaderT
04:43:23 <kstt> I was wondering if I could flatten reader and Snap in a single monad. That mean Snap methods + ask, all in a single layer, with no stack, no lift needed.
04:45:11 <kstt> because method names dont clash, I can easily (but explicitly ...) delegate all Snap functions called from the ReaderT to the wrapped Snap. Is there some recommanded method to get this effect freely ?
04:48:19 <aristid> kstt: in snap 0.3 there is a class MonadSnap, so you could write a newtype wrapper around ReaderT x Snap, and write an instance for MonadSnap
04:48:35 <aristid> and an instance of MonadReader of course
04:49:52 <quicksilver> aristid's answer sounds like it's the right way.
04:50:04 <quicksilver> I was hoping for something like that
04:50:08 <aristid> only problem: snap 0.2 is still the released version
04:50:13 <quicksilver> but obviously looked in the wrong place, or at hte wrong version, or something
04:50:14 <quicksilver> ah.
05:24:34 <Funktorsalat> ghc comment: 	-- (You can get a PhD for explaining the True Meaning
05:24:34 <Funktorsalat> 	--  of this last construct.)
05:25:24 <Funktorsalat> below the decl of HsBindLR (trying to figure out what an 'AbsBinds' is)
05:26:04 <Funktorsalat> "-- Binds abstraction; TRANSLATION" -- okay :)
05:26:25 <Jafet> It's a mechanism to perpetuate future ghc developers
05:31:33 <hpc> lol
05:32:18 <Azrael-> BONUS, I am finally learning haskell thanks to your excellent guide. You have succeeded in making something that can hold my attention for long enough for me to learn things without flicking over to Reddit, and for that I am greatful.
05:32:50 <koala_man> which guide is that?
05:32:57 <quicksilver> @where lyah
05:32:57 <lambdabot> http://www.learnyouahaskell.com/
05:32:57 <Twey> @where lyah
05:32:57 <lambdabot> http://www.learnyouahaskell.com/
05:33:00 <Twey> Heh
05:33:01 <koala_man> ah
05:33:15 <quicksilver> BONUS++
05:33:23 <hpc> @karma BONUS
05:33:23 <lambdabot> BONUS has a karma of 9
05:33:33 <quicksilver> it's a crime.
05:33:39 <ray> exercise: write a program in haskell that electrocutes you if you visit reddit
05:34:06 <Entroacceptor> mmh, I could maybe patch xmonad to do that...
05:34:17 <Azrael-> Unfortunately I've yet to get to the bits about monads and electricity.
05:34:19 <quicksilver> put all the reddit hosts to 127.0.0.1 in your hosts file.
05:34:32 <hpc> ray: main = putStrLn "GTFO Reddit!" >> return unsafeKillAllHumans
05:34:34 <Entroacceptor> learn self control
05:34:48 <quicksilver> self control is overrated. controlling other people is more fun and profitable.
05:34:50 <Entroacceptor> ha, just kidding
05:34:51 <hpc> you might need to import System.Skynet
05:35:34 <Entroacceptor> import Bofh.Electrocute
05:37:48 <ray> unsafeDestroyUniverse does the same thing but is easier to implement
05:37:57 <ray> indeed I already have
05:46:16 <Funktorsalat> how is that unsafe? seems pretty idempotent to me
05:46:40 <Funktorsalat> though zero vs. once-or-more evaluations would matter
05:46:52 <Maddas> I don't think unsafeDestroyUniverse has any visible side-effects
05:47:14 <aristid> it's non-execution has visible side-effects
05:47:21 <aristid> *its
05:47:46 <Maddas> Fortunately non-execution always occurs in the time monad!
06:36:11 <EvanR-work> Maddas: time monad? ;)
06:42:50 <kstt> aristid: quicksilver : thx !
06:43:46 <aristid> kstt: you switched to snap 0.3?
06:44:26 <kstt> aristid: No, not yet.
06:44:37 <kstt> When should it be available in hackage ?
06:44:42 <aristid> no idea :)
06:44:59 <aristid> kstt: maybe ask in #snapframework ?
06:46:14 <kstt> ok
06:49:12 * hackagebot equivalence 0.2.2 - Maintaining an equivalence relation implemented as union-find using STT.  http://hackage.haskell.org/package/equivalence-0.2.2 (PatrickBahr)
07:14:30 <haskellElephant> @pl  \c a  -> fromIntegral (ceiling (c * (fromIntegral $ s a)))
07:14:30 <lambdabot> ((fromIntegral . ceiling) .) . (. (fromIntegral . s)) . (*)
07:14:40 <haskellElephant> hmm... not really nice
07:15:54 <BONUS> Azrael: thanks! :)
07:16:29 <haskellElephant> @list
07:16:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:16:53 <haskellElephant> @pf ((fromIntegral . ceiling) .) . (. (fromIntegral . s)) . (*)
07:16:53 <lambdabot> Maybe you meant: bf pl
07:17:19 <haskellElephant> what is the pointfull command again?
07:17:32 <Jafet> @unpl ((fromIntegral . ceiling) .) . (. (fromIntegral . s)) . (*)
07:17:32 <lambdabot> (\ e q -> fromIntegral (ceiling (e * (fromIntegral (s q)))))
07:18:26 <haskellElephant> anyone have any ideas about how to make this a bit nicer?
07:18:51 <Jafet> let haskellSucks = fromIntegral
07:19:07 <Jafet> :t (\ e q -> fromIntegral (ceiling (e * (fromIntegral (s q)))))
07:19:08 <lambdabot>     Couldn't match expected type `t -> a' against inferred type `Expr'
07:19:08 <lambdabot>     In the first argument of `fromIntegral', namely `(s q)'
07:19:08 <lambdabot>     In the second argument of `(*)', namely `(fromIntegral (s q))'
07:20:41 <haskellElephant> s is here a function giving an Integral so it is actually ok..
07:21:06 <haskellElephant> :t (\ e q -> fromIntegral (ceiling (e * (fromIntegral  q))))
07:21:07 <lambdabot> forall a a1 b. (Integral a1, RealFrac a, Num b) => a -> a1 -> b
07:21:43 <Jafet> Okay, that isn't even legitimate haskell
07:21:53 <Jafet> Er nevermind, misread a1 as a
07:22:18 <Jafet> :t ceiling
07:22:19 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:22:54 <tromp__> i wrote a cute c program. http://en.wikipedia.org/wiki/Hilbert_curve#C_Implementation_with_ASCII_output
07:24:29 <Twey> tromp__: You know the point of code examples in WP pages is to exemplify the algorithm, right?
07:24:54 <Twey> Clever though it may be to have the code *be* a Hilbert curve, it doesn't much help towards that goal :þ
07:25:16 <tromp__> yes, it's not very exemplary
07:25:48 <tromp__> an exemplary version would be too long:(
07:26:45 <Jafet> elephant: so anyway, fromIntegral.ceiling is redundant
07:27:10 <Twey> Haha, ‘Java implementation: <74 lines>.  Haskell implementation: <7 lines>.’
07:27:30 <haskellElephant> @pl (\ e q  s-> fromIntegral (ceiling (e * (fromIntegral (s q)))))
07:27:30 <lambdabot> (((fromIntegral . ceiling) .) .) . (. ((fromIntegral .) . flip id)) . (.) . (*)
07:27:32 <tromp__> the java implementation is the real space waster on that page
07:27:50 <tromp__> it doesn't add much over the others either
07:27:59 <haskellElephant> damn thats ugly!
07:28:00 <Twey> You could probably remove it
07:28:16 <Twey> haskellElephant: @pl generally doesn't generate exemplary point-free code
07:28:27 <haskellElephant> Twey: ye
07:28:58 <haskellElephant> Jafet: Thanks!
07:32:09 <haskellElephant> Twey: but sometimes it does do a nice job...
07:34:52 <Twey> I get: flip . fmap . flip fmap fromIntegral . fmap ceiling . (*)
07:35:03 <Twey> Still not that nice, I guess
07:35:19 <Twey> haskellElephant: Yeah, but it doesn't have much concept of what is ‘nice’ to humans
07:36:14 <Jafet> :t (flip.)
07:36:15 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f1 (f (a -> b)) -> f1 (a -> f b)
07:36:23 <Jafet> Dammit
07:36:36 <lars9> is LYAH's author a teacher?
07:36:36 <Jafet> :t let (f.g) x = f (g x) in (flip.)
07:36:36 <lambdabot> forall (f :: * -> *) a b t. (Functor f) => (t -> f (a -> b)) -> t -> a -> f b
07:36:46 <Twey> haskellElephant: You're always better off doing it by hand, for any non-trivial expression.  @pl really comes into its own when you're trying to remember how to point-free a particular pattern.
07:37:06 <Jafet> Double dammit
07:37:15 <Jafet> :t let (f.g) x = f (g x); flip f x y = f y x in (flip.)
07:37:16 <lambdabot> forall t t1 t2 t3. (t3 -> t -> t1 -> t2) -> t3 -> t1 -> t -> t2
07:37:46 <Twey> @pl \c -> (f c) (g c)
07:37:46 <lambdabot> ap f g
07:37:48 <Twey> For example
07:38:03 <haskellElephant> @pl \e q -> ceiling (e * (fromIntegral q))
07:38:03 <lambdabot> (ceiling .) . (. fromIntegral) . (*)
07:38:12 <Twey> lars9: I don't think so.  Why don't you ask him?
07:39:30 <haskellElephant> @pl \e q -> e * (fromIntegral q)
07:39:30 <lambdabot> (. fromIntegral) . (*)
07:41:38 <lars9> Twey: good idea
07:42:16 <roconnor> what is UX?
07:44:23 <Zao> User eXperience.
07:44:39 <Zao> The feel of an user interface.
07:45:32 <_mpu> @pl \b f g -> if b then f else g
07:45:33 <lambdabot> if'
07:45:51 <_mpu> > :t if'
07:45:52 <lambdabot>   <no location info>: parse error on input `:'
07:46:03 <_mpu> :t if'
07:46:03 <lambdabot> Not in scope: `if''
07:46:08 <copumpkin> I hate people sticking X into acronyms where it doesn't belong
07:47:04 <_mpu> what is "if'" ?
07:47:15 <quicksilver> _mpu: a fictional function
07:47:24 <quicksilver> invented by @pl so it can point-free if statements.
07:47:34 <quicksilver> if' b x y = if b then x else y
07:48:03 <Twey> Ych
07:48:25 <Twey> ‘(y ?? n) p = if p then y else n’ is so much nicer for actual use
07:48:40 <_mpu> @pl \b x -> if b x then Left x else Right x
07:48:40 <lambdabot> (`ap` Right) . (`ap` Left) . (if' .)
07:48:42 <frerich6> Why is it that many (all?) people who are familiar with Haskell seem to find it desireable to write point-free expressions. There must be something to it which I (being a Haskell beginner) cannot see yet.
07:49:41 <Twey> join $ (Left ?? Right) . b
07:49:48 <quicksilver> frerich6: the desire to avoid naming something which is only used once.
07:50:01 <quicksilver> is the basic idea.
07:50:11 <Twey> The desire to avoid redundancy
07:50:15 <quicksilver> I would only use the point-free version when it is genuinely more attractive.
07:50:34 <Botje> frerich6: at its basic form, "flip insert" looks nicer than "\v k -> insert k v"
07:50:39 <quicksilver> compare "map (\xs -> length (lines xs)) [....]"
07:50:41 <quicksilver> with
07:50:48 <quicksilver> "map (length . lines) [....]
07:50:55 <quicksilver> why bother to name the 'xs' which is only used once?
07:50:56 <Twey> 14:49:50 < quicksilver> I would only use the point-free version when it is genuinely more attractive.
07:50:59 <Twey> I do too
07:51:04 <_mpu> what is ??
07:51:05 <quicksilver> what added value does that naming grant?
07:51:11 <Twey> But I think my threshold for that is higher than most people's
07:51:15 <Twey> _mpu: The function I just defined
07:51:22 <Twey> _mpu: (y ?? n) p = if p then y else n
07:51:42 <_mpu> okay
07:51:52 <aristid> Twey: i have an even more generalised (??) :P
07:52:07 <Twey> aristid: ‘Even more generalised’?
07:53:03 <frerich6> Aaah, indeed - point-free expression let you use currying with function composition! As in 'fn x = f (g (h x))' vs. 'fn = f . g . h'
07:53:12 <frerich6> I only realize this now
07:53:22 <aristid> Twey: well ok your (??) is not generalised at all. but it's a function at least. http://hackage.haskell.org/packages/archive/shortcircuit/0.1/doc/html/Control-Shortcircuit.html#v:-63--63-
07:54:38 <Twey> aristid: What's it for?
07:54:56 <Twey> (‘Shortcircuit’ is kind of a misleading name in a lazy language…)
07:55:16 <quicksilver> frerich6: this is nothing to do with currying.
07:55:26 <aristid> Twey: well, mplus is not short-circuiting, for example.
07:55:28 <quicksilver> frerich6: but despite your use of that word, yes, I believe you get the point ;)
07:55:42 <Jafet> @pl filter
07:55:42 <lambdabot> filter
07:55:49 <Twey> aristid: Says who?
07:55:50 <aristid> Twey: i mean liftM2 mplus
07:55:52 <michaelb> I'm a total haskell n00b, so forgive the n00bishness of my question, but is it possible to have a guard in a lambda expression?
07:55:53 <Jafet> There isn't a shorter name for filter?
07:56:02 <Twey> michaelb: No
07:56:05 <quicksilver> michaelb: sadly not
07:56:19 <quicksilver> there is the rather ugly "case () of _ | <guard> -> ...."
07:56:20 <Twey> michaelb: Lambdas are meant for very simple functions, with only one possible match
07:56:24 <michaelb> darn, k, thx
07:56:37 <Twey> michaelb: If they get more complex than that, consider giving them a name in a where
07:56:42 <quicksilver> you can always define a function with guards in a nearby where or let clause
07:56:44 <frerich6> quicksilver: Hm, but - currying and pointfree seems related somehow. For instance, in "f = (+ 1)" <-- that's a pointfree expression since it has no point which the function acts on, no? And it also uses currying with the (+) function.
07:57:04 <quicksilver> frerich6: I think you're talking about partial application.
07:57:23 <quicksilver> your first example "fn x = f (g (h x))" has neither currying nor partial application in.
07:57:37 <quicksilver> f = (+ 1) is a kind of partial application of (+), yes.
07:57:41 <aristid> Twey: maybe the reason that the name is misleading is that initially the module only contained orM and andM, and the rest just arose
07:57:42 <Twey> frerich6: Partial application is one way of making a function point-free, for certain types of functions.
07:57:42 <frerich6> quicksilver: But 'h' could take more than one argument, no?
07:58:01 <quicksilver> frerich6: ok, it could :) and yes, then it would be.
07:58:06 <Jafet> If your combinatorial logic didn't have partial application, you could simply make combinators that did it.
07:58:12 <quicksilver> partial application but not currying.
07:58:34 <frerich6> I thought currying means partially application of some function so that you get a new function.
07:58:44 <quicksilver> no. currying is specifically the transformation from functions which take multiple parameters to functions which only take one parameter and return a function.
07:59:04 <quicksilver> in haskell all functions are curried and there is not really any such thing as a function which takes multiple parameters in the sense of the definition of 'curry'.
07:59:15 <quicksilver> although, once we've *done* the transformation
07:59:25 <quicksilver> we're then free to treat a -> b -> c as if it had two parameters.
07:59:30 <Jafet> :t curry
07:59:30 <quicksilver> but it is a curried form.
07:59:31 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
07:59:39 <quicksilver> Jafet: that's just another lie, or cheat.
07:59:50 <quicksilver> that's using tuples as a model for multiple parameters.
07:59:51 <Jafet> Just an innocent, harmless misnomer.
07:59:56 <quicksilver> which is neither here not there, really.
08:00:05 <michaelb> Twey: the where worked, thx
08:00:10 <quicksilver> although it does serve to illustrate what curry is, at some level.
08:01:02 <frerich6> quicksilver: Yes, I gathered that much. I think I misunderstood 'partial application of a function' then. I thought "+ 1" is a partial application of the function (+)
08:01:47 <quicksilver> yes.
08:01:52 <quicksilver> that's a reasonable thing to call it.
08:01:58 * frerich6 thought currying is a process which turns a function with n arguments into a function with n-1 arguments; and this is done by partially applying the function.
08:02:02 <quicksilver> no.
08:02:25 <frerich6> Oops, then I got my nomenclature wrong all the time. :-}
08:02:29 <quicksilver> currying does not involve actually giving the function an argument.
08:02:42 <quicksilver> currying is just the transformation from "two arguments at once"
08:02:56 <quicksilver> to "one argument, return a function (which you can then supply a further argument to)"
08:03:14 <quicksilver> (+1) is a slightly odd case in that you're applying the wrong argument first
08:03:25 <quicksilver> but it's still natural to describe it as partial application.
08:04:10 <mux> I got "scolded" once for saying t hat (+1) is partial application, because IIRC, left/right sections and partial applications are different
08:05:17 <ecooper> Quick question: what's the name of the technique of representing a list as a function that appends that list onto its argument?
08:05:22 <endojelly> mux, (1+) and (+) 1 should be equivalent, isn't it?
08:05:36 <mux> endojelly: right
08:05:42 <Jafet> Is there a way to define an arbitrary generalization of, say, zipWith? Eg. zipWithN n which provides a function of the type (t1 -> ... -> tn -> r) -> [t1] -> ... -> [tn] -> [r], where n is a type-level natural
08:05:54 <mux> Jafet: there's a generalization using applicative functors
08:06:09 <Jafet> (+1) is sugar for flip (+) 1, if you like
08:06:15 <mux> > getZipList $ (+) <$> [1,2,3] <*> [4,5,6]
08:06:16 <lambdabot>   Couldn't match expected type `Control.Applicative.ZipList a'
08:06:16 <lambdabot>         agains...
08:06:27 <unkanon> mux: would that also work for turning all the liftMn to a single function?
08:06:28 <mux> > getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [4,5,6]
08:06:29 <lambdabot>   [5,7,9]
08:06:32 <mux> here
08:06:36 <Jafet> mux: ah, cool
08:06:50 <BONUS> > let (-:) = zipWith id in (,,) -: [1,2,3] -: [4,5,6]
08:06:51 <lambdabot>   Couldn't match expected type `[b1 -> b -> c]'
08:06:51 <lambdabot>         against inferred type...
08:06:59 <BONUS> > let (-:) = zipWith id in (,,) [1,2,3] -: [4,5,6]
08:07:00 <lambdabot>   Couldn't match expected type `[b -> c]'
08:07:00 <lambdabot>         against inferred type `b1 -...
08:07:03 <BONUS> ugh, sorry
08:07:15 <mux> > getZipList $ (\x y z -> x + y + z) <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9]
08:07:16 <lambdabot>   [12,15,18]
08:07:20 <mux> and so on
08:07:33 <dons> BONUS: you're coming to belhac?
08:07:40 <BONUS> > let (-:) = zipWith id in fmap (,,,) [1,2,3] -: [4,5,6] -: [8,9,10]
08:07:41 <lambdabot>   Overlapping instances for GHC.Show.Show (d -> (a, b, b1, d))
08:07:41 <lambdabot>    arising fro...
08:07:44 <BONUS> ughghghghgh
08:07:47 <BONUS> dons: yup :)
08:07:48 <poucet> dons: you're going to belhac?
08:07:53 <dons> BONUS: i'll see you tomorrow!!
08:07:56 <mux> unkanon: yes, that already exists and it's called ap
08:07:57 <BONUS> cool! see ya!
08:07:58 <dons> yes. i'll be there.
08:08:00 <mux> :t ap
08:08:00 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:08:05 * dons -> later
08:08:25 <unkanon> ?src ap
08:08:25 <lambdabot> ap = liftM2 id
08:08:43 <frerich6> quicksilver: Hm, I hope I'm not being too dense here, trying to sort my nomenclature out. Would it be acceptable to say that currying means partially applying a function and then returning a new function (with less arguments)?
08:08:43 <quicksilver> mux: depends whether you're speaking operationally or semantically, in my opinion.
08:08:51 <quicksilver> frerich6: no.
08:08:57 <mux> :t (,) `fmap` readLine `ap` readLine
08:08:58 <lambdabot> Not in scope: `readLine'
08:08:58 <lambdabot> Not in scope: `readLine'
08:09:01 <mux> dang
08:09:03 <mux> :t readLn
08:09:04 <lambdabot> forall a. (Read a) => IO a
08:09:05 <quicksilver> frerich6: "partially applying a function" involves giving it an argument.
08:09:16 <quicksilver> frerich6: "currying" does not involve giving the function any arguments
08:09:20 <mux> @hoogle IO String
08:09:21 <lambdabot> Did you mean: :: IO String /count=20
08:09:21 <lambdabot> System.IO.Error ioeGetErrorString :: IOError -> String
08:09:21 <lambdabot> System.IO.Error ioeSetErrorString :: IOError -> String -> IOError
08:09:27 * mux grumbles
08:09:35 <quicksilver> frerich6: currying is not part of applying the function - it's a transformation on the function itself, without supplying any arguments.
08:10:00 <frerich6> quicksilver: But to curry a function (like +) you need to give it some argument, no?
08:10:09 <Jafet> Perhaps I should have qualified my question with "and does not involve Applicative"
08:10:13 <mux> :t (,) `fmap` readLine "foo" `ap` readFile "bar"
08:10:14 <quicksilver> mux: operationally - for example, in the design of an STG-machine, or some other concrete interpreter - you have a very operational notion of application.
08:10:14 <lambdabot> Not in scope: `readLine'
08:10:21 <mux> :t (,) `fmap` readFile "foo" `ap` readFile "bar"
08:10:22 <lambdabot> IO (String, String)
08:10:25 <mux> HAH.
08:10:29 <quicksilver> mux: an application is typically a fundamental - and simple - operation.
08:10:34 <mux> quicksilver: fully agreed
08:10:36 <unkanon> frerich6: take a look at lambda calculus, it'll help you think of a function that takes several arguments as several functions that take one argument. that'll give you a better explanation of currying
08:10:39 <quicksilver> mux: in that sense (+1) doesn't really fit.
08:10:42 <mux> unkanon: does that help?
08:10:56 <quicksilver> mux: however, thiking just about semnatics, (+1) is clearlly partially applying the function +.
08:11:02 <quicksilver> frerich6: no.
08:11:04 <mux> quicksilver: *nods*
08:11:15 <unkanon> mux: yes :)
08:11:19 <quicksilver> frerich6: consider C: int plus(int a, int b)
08:11:25 <Twey> :t (,) <$> readFile "foo" <*> readFile "bar"
08:11:26 <lambdabot> IO (String, String)
08:11:30 <mux> :t (,,) `fmap` readFile "foo" `ap` readFile "bar" `ap` readFile "baz"
08:11:30 <quicksilver> frerich6: this is a function which takes two arguments (are you familiar with C?)
08:11:31 <lambdabot> IO (String, String, String)
08:11:36 <mux> Look, ma, no liftM !
08:11:42 <frerich6> quicksilver: *nod* (Yes, I am)
08:11:55 <unkanon> mux: so ap can also be used instead of liftM3 and 4?
08:12:03 <quicksilver> frerich6: to "curry" that funciton you turn it into a function which takes one arguments, and returns a function.
08:12:07 <Twey> :t (,,) <$> readFile "foo" <*> readFile "bar"
08:12:08 <lambdabot> forall c. IO (c -> (String, String, c))
08:12:09 <mux> unkanon: yup, as I just did with the last example (no liftM3)
08:12:20 <aristid> mux: yeah but then you can just use Applicative if you're already using Functor
08:12:21 <quicksilver> frerich6: you can't actually do that in any simple way in vanilla C (no simple way to make a closure)
08:12:26 <mux> but it's cuter to use the applicative functor syntax, as Twey insists on showing
08:12:31 <mux> I was trying to demonstrate using ap.
08:12:36 <quicksilver> frerich6: in haskell :: (+) :: Int -> Int -> Int
08:12:36 <Twey> ap = (<*>)
08:12:40 <unkanon> mux: cool
08:12:42 <mux> Twey: nope
08:12:47 <quicksilver> frerich6: in haskell (+) is a function which returns a function.
08:12:51 <mux> :t ap
08:12:52 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:12:55 <Twey> For any Monad that is also sensibly an Applicative
08:12:57 <quicksilver> frerich6: in haskell (+) is already curried (as are all functions, in haskell)
08:12:57 <mux> :t (<*>)
08:12:58 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:13:01 <mux> Twey: now we agree ;-)
08:13:02 <aristid> mux: for all well-behaved monads, ap = (<*>)
08:13:08 <mux> yup.
08:13:11 <unkanon> ?pl ap
08:13:11 <lambdabot> ap
08:13:16 <unkanon> ?unpl ap
08:13:16 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
08:13:22 <quicksilver> frerich6: sometimes we use tuples as a model for uncurried functions, as in (Int,Int) -> Int
08:13:25 <unkanon> ?pl (<*>)
08:13:25 <lambdabot> (<*>)
08:13:28 * mux bbl &
08:13:32 <quicksilver> frerich6: that's convenient if slightly dishonest.
08:13:45 <frerich6> It seems 'impure'
08:13:47 <Twey> unkanon: There are no variables in ‘(<*>)’ or in ‘ap’
08:13:53 <quicksilver> frerich6: the *process* of currying is shifting from the "int plus(int a, int b)" view to the "Int -> Int -> Int" view.
08:13:58 <unkanon> Twey: right
08:14:17 <Twey> unkanon: So there's nothing to remove
08:14:25 <Twey> So they're already point-free
08:14:27 <unkanon> Twey: can you show that ap = (<*>) ?
08:14:40 <Twey> unkanon: Just by definition
08:14:49 <Jafet> @src (<*>)
08:14:49 <lambdabot> Source not found. Maybe if you used more than just two fingers...
08:14:55 <quicksilver> frerich6: you can make it a bit more explicit in javascript, which has a sensible syntax for both cases.
08:15:01 <Twey> unkanon: ‘ap’ is just the Monad name for the operation Applicative calls (<*>)
08:15:18 <unkanon> Twey: or so it's really defined like that
08:15:35 <quicksilver> "function plus(a,b) { return a+b; // I am not curried }; function plus(a) { return function(b) { return a+b; } ; // I am curried }
08:15:42 <Twey> unkanon: It's defined as ap = liftM2 id
08:15:46 <frerich6> quicksilver: Ok, so all functions (in Haskell, at least) with more than one argument are functions which take one argument and then return a function which takes one argument less. In C, that'd be "int (*)(int) plus(int)".
08:15:54 <quicksilver> frerich6: yes, sort of.
08:16:03 <Twey> Because Applicative is sadly not necessary for Monad (it should be, since all Monads are conceptually also Applicatives)
08:16:08 <quicksilver> except you can't really implement that in C because it doesn't have any way to store the value of 'a' in a closure
08:16:17 <frerich6> quicksilver: So a 'curried' function is per definition a function which takes only one argument and returns another function?
08:16:19 <quicksilver> so you have to return a struct which stores the arguments values, or something.
08:16:23 <quicksilver> frerich6: yes.
08:16:43 <frerich6> quicksilver: You could consider the argument to be a function with no arguments which returns an int. And it's only called when the whole thing is evaluated.
08:16:53 <quicksilver> yes, you could do that.
08:16:58 <unkanon> Twey: well, we don't get to choose what is necessary for something to be a monad ;)
08:17:01 <quicksilver> that would make it more like haskell, too :)
08:17:19 <unkanon> Twey: that's for the math folks to decide/discover i guess
08:17:27 <Twey> unkanon: No no
08:17:39 <Twey> unkanon: Mathematically and conceptually, every Monad is also an Applicative
08:17:53 <Twey> unkanon: It's just that Haskell doesn't enforce that constraint
08:17:55 <jmcarthur> unkanon: Applicative is just a more general Monad
08:18:00 <unkanon> Twey: so you're saying haskel is in the wrong?
08:18:04 <Twey> unkanon: Yes
08:18:08 <Twey> unkanon: It's a well-known issue
08:18:09 <unkanon> gotcha
08:18:21 <Twey> But it's not fixed because it might break some code that uses ill-behaved Monads
08:18:25 <Twey> Likewise with Functor
08:18:30 <jmcarthur> who cares, IMO
08:18:40 <jmcarthur> if it's ill behaved you brought it upon yourself
08:18:42 <Twey> I'm with jmcarthur… it's their fault for writing crappy code
08:18:50 <Twey> Maybe in the next standard, then
08:18:55 <frerich6> quicksilver: Ok, so far so good. At this point I'd like to thank you for the patience. Rest assured that some head is smoking here 8-}
08:19:00 <quicksilver> frerich6: :)
08:19:07 <unkanon> Twey: that's awful, i'm trying to learn category theory to learn how to use functors and monads well, i thought haskell would hold my hands and keep me from making malformed monads
08:19:20 <quicksilver> frerich6: I think you understood all the ideas. It's just the naming of the ideas :)
08:19:21 <Twey> unkanon: Heh, no, it doesn't
08:19:29 <quicksilver> frerich6: naming isn't important, except it helps us communicate.
08:19:41 <jmcarthur> unkanon: i promise you, category theory doesn't provide much additional insight into haskell functors and monads
08:19:47 <Twey> unkanon: It doesn't even enforce the monad/functor laws
08:19:59 <quicksilver> Twey, jmcarthur : there are also practical issues with making the type class hierarchy finegrained, in terms of the number of instances you'd have to write.
08:20:14 <jmcarthur> quicksilver: there have been extensions proposed to make that simpler
08:20:15 <unkanon> jmcarthur: really? so there's no need or advantage whatsoever in learning the mathematical base for the concepts haskell uses?
08:20:15 <quicksilver> I think that was used as an argument for not relating Monad / Functor.
08:20:21 <quicksilver> jmcarthur: there have, but nobody has implemented them
08:20:25 <jmcarthur> quicksilver: i also don't mind having to instantiate many type classes, personally
08:20:29 <quicksilver> so, therefore, nobody knows if they are actually sound :)
08:20:36 <jmcarthur> unkanon: i didn't mean that
08:20:39 <quicksilver> jmcarthur: in the case of Functor/Applicative/Monad, neither do I.
08:21:00 <Twey> quicksilver: Ar :-\
08:21:02 <quicksilver> jmcarthur: in the case of proposed fine-grained mathematical hierarchies I can see it would be a pain. (Magma/Group/Ring/Field/....)
08:21:17 <Twey> I'd rather have to instantiate a bunch of classes than be stuck with Monads that aren't Functors.
08:21:23 <quicksilver> 3 instances is no burden
08:21:28 <quicksilver> 15 instances to define a new Num might be a pain.
08:21:36 <quicksilver> (then again I don't define new Nums very often)
08:22:36 <unkanon> jmcarthur: i feel if i don't learn category theory, i'll never understand what you guys talk about here (for example, this screen's worth of conversation right here) :)
08:22:53 <jmcarthur> unkanon: i just mean that in learning category theory all you will learn about functors and monads is the same laws you already know. you may know the origins, but you since we aren't actually *deriving* functors and monads in haskell anyway that isn't really helpful
08:23:25 <jmcarthur> unkanon: mainly we are just using terminology from category theory. we aren't implementing functors and monads in their fully general forms anyway
08:24:08 <frerich6> quicksilver: In some sense, "partial application" doesn't happen in Haskell, does it? Every function takes one argument anyway (even if you don't define those functions yourself) so you cannot 'partially' apply a function - either you apply it, by calling it, or you don't. Maybe "partial application" means taking a shortcut in the currying "chain" so that when "f x y z" is called you don't have "(((f x) y) z)"
08:24:08 <frerich6>  (I hope this pseudo-syntax makes sense, I tried to visualize the three "anonymous" functions). Instead, you can "curry" it like "g = f 1 2" so that when evaluating the function call you just have "(g x)".
08:24:20 * frerich6 hopes these musings make some sense
08:24:41 <unkanon> jmcarthur: I don't know if i should be disappointed that haskell isn't all that deep into math, or happy that it isn't because i don't know that much math anyway
08:24:47 <jmcarthur> quicksilver: well, 15 sounds unrealistically high, but i wouldn't mind implementing half that number of type classes to make Num. if we would just suck it up, extensions would inevitably come around to make it more convenient anyway
08:25:07 <jmcarthur> unkanon: i feel like it's a bit of both
08:25:15 <unkanon> frerich6: that makes sense to me
08:25:47 <jmcarthur> unkanon: if you want to see a language that is entirely based on category theory you could check out http://pll.cpsc.ucalgary.ca/charity1/www/home.html
08:25:53 <Twey> frerich6: Sounds right to me
08:26:09 <jmcarthur> unkanon: there are others too, but i think charity has the most direct approach
08:26:15 <quicksilver> frerich6: yes, all applications in haskell might as well be partial
08:26:24 <unkanon> jmcarthur: no, i just wanted to measure how far into math haskell is. I still want a _programming_ language, not a math language
08:26:36 <quicksilver> frerich6: on the other hand, a compiler or interpreter might have a different execution technical for strictly partial applications versus compelte ones
08:26:44 <jmcarthur> unkanon: oh there is no reason a language can't be both
08:26:55 <jmcarthur> unkanon: aside from the designers' ignorance ;)
08:27:04 <unkanon> jmcarthur: agreed. but if a language is math only that means it's quite unreachable for me :)
08:27:12 <frerich6> quicksilver: Actually, now that I think about it, wouldn't it be more correct to say that every function in Haskell has zero arguments - and those with one arguments are curried (they take one argument and return a function with zero arguments).
08:27:21 <jmcarthur> unkanon: i completely disagree. it just means you have to learn some terminology
08:27:37 <quicksilver> frerich6: if "f x y z = bar" then evaluating "f x y z" can be replaced directly with (a pointer to) bar, whereas "f x y" involves constructing a new thunk, point to 'x' and 'y', which is waiting for a 'z'.
08:27:42 <unkanon> jmcarthur: so in that sese i'm kind of relieved that haskell took some shortcuts to make the language more practical (that's what I understood from you guys' convo)
08:27:45 <jmcarthur> unkanon: you have to do that to begin programming at all. it makes sense to me that you have to do the same to learn revolutionary programming languages
08:28:09 <unkanon> jmcarthur: that's what I was learning by learning category theory, and you said I didn't have to
08:28:11 <jmcarthur> unkanon: yes, haskell takes shortcuts. sometimes i agree with those shortcuts, and sometimes i disagree
08:28:26 <jmcarthur> unkanon: well, i don't want to discourage you from learning category theory
08:28:33 <jmcarthur> unkanon: it just isn't so helpful for learning haskell
08:28:39 <jmcarthur> unkanon: i can help *later*
08:28:46 <unkanon> jmcarthur: oh then i'll keep at it
08:28:48 <jmcarthur> to gain deeper insight into your code
08:28:56 <unkanon> jmcarthur: that's what i'm looking for
08:29:02 <jmcarthur> but really that comes after learning haskell separately
08:29:07 <unkanon> jmcarthur: i want to fully understand the implications of the code i'm writing
08:29:27 <unkanon> jmcarthur: that's ok i'm not in a hurry ;)
08:29:56 <unkanon> i'm juggling two haskell books and some wikibooks on haskell
08:30:00 <jmcarthur> unkanon: i'd say you might want to study something like domain theory or something then. it's all about assigning mathematical meaning to things
08:30:24 <unkanon> jmcarthur: domain theory, so that will also help me?
08:30:26 <jmcarthur> unkanon: and that includes programming languages :)
08:30:36 <jmcarthur> unkanon: it depends on what you mean by "help you"
08:31:06 <unkanon> well my goal is to go beyond simply writing haskell code and actually understand what's going on, and be able to chat meaningfully here
08:31:14 <jmcarthur> unkanon: if you mean "help you understand your code" then the answer is yes, but only after lots of hard work. if you mean "help you learn haskell" the answer is pretty much no
08:31:16 <unkanon> i find this stuff fascinating to be honest
08:31:19 <jmcarthur> okay
08:31:27 <jmcarthur> domain theory is going to be cool to you then
08:31:36 <jmcarthur> i need to learn more about it myself
08:31:53 <jmcarthur> unkanon: http://en.wikipedia.org/wiki/Denotational_semantics
08:32:35 * unkanon clicks the link
08:33:39 <jmcarthur> unkanon: key sentence: "Some work in denotational semantics has interpreted types as domains in the sense of domain theory which can be seen as a branch of model theory, leading to connections with type theory and category theory."    <-- that's where it all comes from
08:33:39 <unkanon> jmcarthur: a week ago i felt i'd never be able to grasp category theory.
08:33:46 <unkanon> jmcarthur: after some reading i feel i can take it
08:34:03 <jmcarthur> unkanon: yeah it's really not so bad. just *really* dense reading
08:34:20 <unkanon> jmcarthur: that's beautiful, should i look into type theory too? (too curious not to, anyway)
08:34:33 <jmcarthur> unkanon: you *must* :)
08:34:39 <jmcarthur> type theory is our meat and potatos
08:35:16 <jmcarthur> unkanon: this could easily become one of your favorite books: http://www.amazon.com/exec/obidos/ASIN/0262162091/benjamcpierce
08:35:33 <jmcarthur> unkanon: and this followup http://www.amazon.com/Advanced-Topics-Types-Programming-Languages/dp/0262162288/ref=pd_bxgy_b_img_b
08:36:00 <quicksilver> category theory is just an extreme example of an abstraction. Lots of structures in mathematics have the general form of being composed of widgets and fudgets, where each fudget is associated with two widgets, and if have have two fudgets which match at their ends (like a domino) you can make a new fudget.
08:36:16 <jmcarthur> exactly
08:36:22 <quicksilver> category theory is the exploration of the things these various chunks of mathematics have in common.
08:36:24 <jmcarthur> sort of exactly ;)
08:36:35 <quicksilver> and the extra stuff you can add to pin down some more specific cases.
08:36:46 <jmcarthur> well, category theory is a particular model of all those things, anyway
08:37:00 <unkanon> quicksilver: i read a really good explanation by a category theorist about what category theory is. he compared it to islands and bridges. i can find the link again
08:37:09 <jmcarthur> analogies!
08:37:27 <jmcarthur> @quote analogy
08:37:27 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
08:37:44 <unkanon> quicksilver: http://pozorvlak.livejournal.com/48494.html
08:38:47 <quicksilver> yup.
08:39:06 <quicksilver> although I think his analogy works better at a higher level than the one he chooses to use.
08:39:35 <quicksilver> the islands are disciplines of mathematics; the bridges are theorems that connect them; the bridge-geeks are the CT theorists.
08:40:37 <unkanon> quicksilver: right, that's how i saw it
08:41:42 <unkanon> jmcarthur: i looked at the books, that's scary stuff, i hope to be able to understand them at some point in time
08:46:26 <jmcarthur> unkanon: TAPL is not really scary. it's quite introductory, in fact
08:46:34 <jmcarthur> unkanon: pretty easy reading, i mean
08:46:59 <jmcarthur> unkanon: there aren't even really any prereqs that you are unlikely to know already
08:47:21 <unkanon> jmcarthur: ok, i might start with that then, after i'm done with my CT intro
08:48:28 <jmcarthur> unkanon: here's another interesting read: www.cs.kent.ac.uk/people/staff/dat/miranda/ctfp.pdf
08:48:36 <unkanon> jmcarthur: give that Pierce teaches CS i'd expect TAPL to have a programmign slant? (which is good)
08:48:46 <jmcarthur> unkanon: a pretty good overview of a lot of areas of programming language research ^^
08:48:48 <unkanon> s/give/given/
08:49:03 <jmcarthur> unkanon: yes, it's all about programming languages and type systems
08:49:23 <unkanon> jmcarthur: great
08:58:08 <unkanon> jmcarthur: so yeah i'm trying to learn all that in parallel with actually learning haskell
08:58:09 <erisco> had a question but answered it myself when I started typing it ;)
08:58:59 <monochrom> the first step of solve a problem is stating it properly. usually the last step too.
09:00:41 <unkanon> jmcarthur: looks like Pierce also has an intro book on CT
09:02:31 <Saizan> unkanon: it's not that great
09:05:06 <quicksilver> most introduction to CT books give no motivation
09:05:13 <quicksilver> they may be a fine way to learn the definitions and theorems
09:05:23 <quicksilver> but they don't give you a feeling about what it's all actually *for*
09:05:57 <quicksilver> I never read a CT book I found gave useful motivation. If you just want a list of theorems and definitons and proofs I found MacLane fine.
09:06:22 <quicksilver> the 'catsters' videos on youtube are interesting if you like to learn that way.
09:07:24 <Apocalisp_> "Category Theory" by Steve Awodey is excellent.
09:07:39 <Apocalisp_> 2nd edition
09:08:54 <monochrom> The best motivation is to learn several math fields, then you have an itch to formalize the common pattern you think you see, then you read category theory and you say "this is it".
09:09:17 <Apocalisp_> Awodey's motivational statement is "Functions are everywhere!" :)
09:09:28 <dolio> That is implicitly in a lot of category theory books.
09:09:43 <dolio> Because they pull examples from all over math.
09:09:49 <quicksilver> I feel I should clarify my remark.
09:09:51 <monochrom> As Piaget foresaw, tons of examples before the next little abstraction.
09:09:59 <dolio> But I don't think many explicitly say that.
09:10:00 <quicksilver> I was, at the time, explicitly looking for *computer science* motivation
09:10:06 <unkanon> Saizan: yeah i saw the comments
09:10:11 <quicksilver> and that's what I found little of.
09:10:32 <quicksilver> however, I'd add that just noticing that lots of things are instances of categorical structures is cute, but pointless.
09:10:43 <quicksilver> the useful bit is when you actually manage to transfer a theorem
09:10:51 <quicksilver> and that's a much more rare event, in the above-mentioned books.
09:11:14 <unkanon> i'm really only looking for CS motivation too
09:11:16 <quicksilver> I think the first instance was one of the adjoint functor theorems and that's severl hundred pages in to some of them :)
09:11:37 <Apocalisp_> quicksilver: That kind of motivation is definitely missing. A book that makes the connection from functional programming to combinator libraries, to abstracting over combinator libraries, to discovering patterns in those abstractions, to category theory.
09:11:49 * quicksilver nods
09:12:14 <unkanon> Apocalisp_: are you going to write that book then? ;)
09:12:21 <Apocalisp_> I'm actually on chapter 2
09:12:36 <Apocalisp_> :)
09:12:44 <unkanon> naw... really?
09:13:07 <Apocalisp_> Yeah, no promises that it will be finished this decade though.
09:13:34 <unkanon> Apocalisp_: you should turn it into a wiki and maybe people here would be motivated to contribute
09:13:34 <monochrom> Pierce's little book has CS examples.
09:14:09 <Apocalisp_> unkanon: Not a bad idea, really
09:14:53 <unkanon> well if you ever do that let me know. i won't be able to contribute but i'll read it!
09:16:04 * hackagebot ecu 0.0.5 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.5 (TomHawkins)
09:19:23 <Saizan> i guess one could read moggi's papers to go that route
09:21:04 <sm> dear lazyweb, could someone add an org-mode reader to pandoc
09:23:22 <Taejo> :t sequence
09:23:23 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
09:36:26 <EvanR-work> you know what would be cool, anonymous data
09:36:43 <quicksilver> EvanR-work: yes it would, sometimes.
09:36:51 <quicksilver> EvanR-work: of course (,) and Either are a bit like that.
09:37:08 <EvanR-work> i was modelling something on the board and i got caught up in naming stuff, so i did
09:37:08 <quicksilver> but they don't cover some of the higher rank possibilities.
09:37:55 <EvanR-work> data Example = C1 T1 | C2 T2 (D1 | D2 T3 | D3 (E1 | E2))
09:38:15 <EvanR-work> i didnt want to use Maybe or Either because the werent descriptive
09:38:27 <EvanR-work> i mean, their constructors
09:38:51 <Saizan> if we had labels..
09:40:55 <EvanR-work> somehow data has been shaping my idea of programs more than functions recently
09:40:57 <quicksilver> EvanR-work: ah, so it's the nesting of constructor names you're after
09:41:01 <quicksilver> without naming the nested bits
09:41:05 <quicksilver> yes, I can understand that.
09:41:13 <quicksilver> that would be useful.
09:41:15 <EvanR-work> yes, one shot data types
09:41:23 <EvanR-work> whos constructors are defined inline
09:41:33 <quicksilver> I thought you wanted to not have to name 'Example' at all.
09:41:45 <EvanR-work> no thats ok, its the top level type
09:41:51 <quicksilver> (that's whence my (,)/Either comment)
09:42:57 <evilgeenius> my first haskell programme just took me down :-(   fac(100000)
09:43:16 <evilgeenius> How the hell can haskell deal with such massive number
09:43:23 <EvanR-work> > product [1..100000]
09:43:27 <lambdabot>   mueval-core: Time limit exceeded
09:43:40 <dolio> > 100000^100000
09:43:41 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
09:43:54 <EvanR-work> use lazy naturals ;)
09:44:53 <monochrom> > foldl' (*) 1 [1..100000]
09:44:57 <lambdabot>   mueval-core: Time limit exceeded
09:45:07 <EvanR-work> @src product
09:45:07 <lambdabot> product = foldl (*) 1
09:45:12 <EvanR-work> lame
09:45:19 <monochrom> don't believe @src
09:45:37 <monochrom> @src (.)
09:45:37 <lambdabot> (f . g) x = f (g x)
09:45:37 <lambdabot> NB: In lambdabot,  (.) = fmap
09:45:38 <Jafet> > let bs _ [] = undefined; bs _ [x] = x; bs f xs = let l = length xs `div` 2 in ((++) `on` (bs f)) (take l f) (drop l f) in bs (*) [1..100000]
09:45:39 <lambdabot>   Couldn't match expected type `[a]'
09:45:39 <lambdabot>         against inferred type `a1 -> a1 ...
09:45:46 <Jafet> > let bs _ [] = undefined; bs _ [x] = x; bs f xs = let l = length xs `div` 2 in (f `on` (bs f)) (take l f) (drop l f) in bs (*) [1..100000]
09:45:46 <lambdabot>   Couldn't match expected type `[c]'
09:45:46 <lambdabot>         against inferred type `c -> c ->...
09:46:04 <Jafet> > let bs _ [] = undefined; bs _ [x] = x; bs f xs = let l = length xs `div` 2 in (f `on` (bs f)) (take l xs) (drop l xs) in bs (*) [1..100000]
09:46:05 <lambdabot>   282422940796034787429342157802453551847749492609122485057891808654297795090...
09:46:16 <Jafet> > let bs _ [] = undefined; bs _ [x] = x; bs f xs = let l = length xs `div` 2 in (f `on` (bs f)) (take l xs) (drop l xs) in bs (*) [1..200000]
09:46:18 <lambdabot>   142022534547031440496694633368230597608996535674640162269622474462922677851...
09:46:26 <EvanR-work> Jafet is god
09:46:37 <mm_freak> > foldl' (*) 1 [2..100000]
09:46:38 <Jafet> (Quadratic -> loglinear, binary splitting ftw)
09:46:41 <lambdabot>   mueval-core: Time limit exceeded
09:47:21 <monochrom> > length (show (foldl' (*) 1 [1..10000]))
09:47:21 <lambdabot>   35660
09:48:01 <monochrom> my ghci just found out that 100000! has 456574 digits
09:48:12 <mm_freak> > sum $ map (logBase 10) [1..100000]
09:48:15 <lambdabot>   456573.4508999712
09:48:39 <Jafet> Still not as balanced as it should be
09:48:42 <mm_freak> monochrom: you forgot a 0
09:49:02 <monochrom> it was intentional.
09:49:11 <Zao> > (sum [1..100000]) `mod` 10
09:49:13 <lambdabot>   0
09:52:24 <EvanR-work> :t (`mod` 10) . (*)
09:52:27 <lambdabot> forall a. (Integral (a -> a), Num a) => a -> a -> a
09:53:06 <EvanR-work> > foldl' ((`mod` 10) . (*)) 1 [1..1000]
09:53:07 <lambdabot>   No instance for (GHC.Real.Integral (a -> a))
09:53:07 <lambdabot>    arising from a use of `e_11...
09:53:33 <exDM69> > [sum [1..10^x] | x <- [1..5]]
09:53:35 <lambdabot>   [55,5050,500500,50005000,5000050000]
09:53:37 <exDM69> neat
09:54:04 <EvanR-work> Integral (a->a) => ?? :\
09:54:40 <EvanR-work> :t \x y -> x * y `mod` 10
09:54:41 <lambdabot> forall a. (Integral a) => a -> a -> a
09:54:52 <EvanR-work> oh (.)
09:55:14 <EvanR-work> :t (`mod` 10) .: (*)
09:55:15 <lambdabot> forall a. (Integral a) => a -> a -> a
09:55:18 <Jafet> > ((+) + (*)) 4 2
09:55:19 <EvanR-work> \o/
09:55:19 <lambdabot>   14
09:55:34 <Jafet> @index (.:)
09:55:34 <lambdabot> bzzt
09:55:38 <EvanR-work> Jafet: looks like a deranged dog
09:55:53 <Jafet> Shocking, lambdabot
09:56:07 <EvanR-work> > foldl' ((`mod` 10) .: (*)) 1 [1..1000]
09:56:08 <lambdabot>   0
09:57:11 <aristid> :t (.:)
09:57:12 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:57:14 <aristid> \o/
09:59:10 <Jafet> :t (.).(.)
09:59:11 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:03:59 <Jafet> > product [1..200] :: CReal
10:04:02 <lambdabot>   mueval-core: Time limit exceeded
10:05:34 <EvanR-work> so if oop teaches using animals and phyla, what does fp use to teach... fibonacci, factorial, and other useless math operations? ;)
10:05:59 <Jafet> Burritos
10:06:58 <Botje> space suits
10:07:00 <Botje> apples
10:07:04 <Botje> robot monkeys
10:07:42 <EvanR-work> i never found anything less than real life use-cases motivating
10:07:49 <EvanR-work> real-life use cases
10:08:10 <EvanR-work> in OOP there arent that many, but no one can tell over the din of zoo animals
10:08:19 <sproingie> animals were always a terrible example for OOP
10:08:25 * hackagebot archlinux 0.3.5 - Support for working with Arch Linux packages.  http://hackage.haskell.org/package/archlinux-0.3.5 (PeterSimons)
10:10:41 <sproingie> MUDs were a good source for programming examples back in the day
10:10:47 <sproingie> no one plays MUDs anymore tho
10:10:59 <EvanR-work> relative to wow i guess not
10:11:10 <sproingie> relative to MUDs 10 years ago even
10:11:27 * hackagebot cabal2arch 0.7.6 - Create Arch Linux packages from Cabal packages.  http://hackage.haskell.org/package/cabal2arch-0.7.6 (PeterSimons)
10:11:29 <EvanR-work> i got the feeling muds were dead 10 years ago
10:11:50 <sproingie> they were certainly well into decline.  frankly they were never all that big, the internet just got bigger.
10:12:15 <danr> @src (.:)
10:12:15 <lambdabot> Source not found. My mind is going. I can feel it.
10:12:22 <danr> Which library is that in?
10:12:30 <EvanR-work> you havent defined it yet
10:12:47 <EvanR-work> (.:) belongs to everyone
10:12:52 <sproingie> my foray back into MUD-land taught me that it's pointless to write a nifty new MUD server with modern design and language etc because no one's going to play it anyway
10:13:14 <EvanR-work> no, never think that way! ;)
10:13:43 <EvanR-work> danr: = (.) . (.)
10:13:57 <danr> EvanR-work: yes I know, but I wondered if it was defined in some library
10:14:03 <danr> I use it all the time
10:14:10 <sproingie> show me an example?
10:14:15 <EvanR-work> if its not in missingH
10:14:23 <EvanR-work> it doesnt exist
10:14:28 * hackagebot haskeline 0.6.3.2 - A command-line interface for user input, written in Haskell.  http://hackage.haskell.org/package/haskeline-0.6.3.2 (JudahJacobson)
10:15:18 <danr> let dotProduct = sum .: zipWith (*)
10:15:29 <danr> > let dotProduct = sum .: zipWith (*)
10:15:29 <lambdabot>   not an expression: `let dotProduct = sum .: zipWith (*)'
10:15:45 <danr> > let dotProduct = ((.) . (.)) sum (zipWith (*))
10:15:47 <lambdabot>   not an expression: `let dotProduct = ((.) . (.)) sum (zipWith (*))'
10:15:56 <danr> you are an expression, lambdabot!
10:16:09 <danr> well, that's an example :)
10:16:55 <danr> > sqrt . sum . map (^2) .: zipWith (-)
10:16:56 <lambdabot>   Precedence parsing error
10:16:56 <lambdabot>      cannot mix `L..' [infixr 9] and `L..:' [infix...
10:17:08 <danr> > (sqrt . sum . map (^2)) .: zipWith (-)
10:17:09 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [a] -> a)
10:17:09 <lambdabot>    arising from a...
10:17:31 <danr> > ((sqrt . sum . map (^2)) .: zipWith (-)) [2,1] [5,5]
10:17:32 <lambdabot>   5.0
10:17:34 <EvanR-work> fail spam!
10:17:47 <danr> distance between two vectors, etc. (.) . (.) is everywhere!
10:18:04 <danr> I plea for it to be in some standard library! Data.Function maybe
10:18:05 <EvanR-work> lifting a monadic action function which takes two args
10:21:11 <EvanR-work> i noticed in haskell there is not much library bickering about what should or shouldnt be a library
10:21:22 <EvanR-work> even when libraries overlap
10:21:54 <EvanR-work> in digital mars d, they are still arguing about the 2 standard libraries. its often used as a reason to not use the language at all
10:22:13 <EvanR-work> in haskell its like, who cares, cabal will get your deps
10:22:47 <kmc> EvanR-work, there was lots of arguing about whether and how 'text' should make it into Haskell Platform
10:23:07 <monochrom> someone in haskell-cafe bickered about the lack of a particular library recently
10:23:08 <danr> EvanR-work: I could do some language bickering :) I'm tired of importing Data.{Function,Ord,List} and Control.{Arrow,Applicative,Monad} in all my haskell programs :)
10:23:29 <EvanR-work> danr: cant you 're export' them all from a single module?
10:23:47 <monochrom> but yes, such behaviour led to being called "troll" and so no one does it anymore :)
10:23:47 <EvanR-work> monochrom: lack of, but not 'too many of'
10:23:48 <danr> EvanR-work: yes indeed I could. I usually do this for some larger projects
10:24:18 <EvanR-work> i guess the problem in d is that they arent actually libraries
10:24:36 <EvanR-work> they are like different runtime systems / compilers
10:25:18 <sproingie> yah D is still a train wreck
10:25:57 <monochrom> there have been lamentations (but not bickering) on too many alternatives and not knowing how to choose
10:26:30 <EvanR-work> i guess its not common to see 'why to not use haskell' in the haskell channels themselves
10:26:32 <monochrom> they all ended with "don't you wish there were a voting system" and nothing happened.
10:27:06 <maurer_> danr: Go to the HaskellPrime Traq and tell them, with a good explanation, and it may make it into the next standard.
10:27:23 <maurer_> I used to think HaskellPrime was just wankery, but they did release Haskell2010, so it looks like they actually do intend on releasing standards.
10:27:40 <quicksilver> EvanR-work, danr : re-exporting can't do qualification
10:27:42 <EvanR-work> the down side is youll have to wait until 2020
10:27:42 <quicksilver> which is a shame
10:27:51 <quicksilver> otherwise it would be a very handy technique.
10:28:13 <quicksilver> module QuicksilverStuff where (module Data.Map as M, module Data.Set as S, ..... )
10:28:21 <monochrom> http://hackage.haskell.org/packages/archive/prelude-plus/0.0.0.6/doc/html/Prelude-Plus.html
10:28:39 <sproingie> haskell 2010 tinkerered around the edges.  i hope it picks up some steam and does something bold like at least add multi-parameter typeclasses
10:28:50 <danr> maurer_: oh. good plan! thanks!
10:28:56 <sproingie> in 2011 or whenever the next standard is
10:29:40 <sproingie> overlapping instances, mptc, drop the MR (by default or not), what else?
10:30:08 <Saizan> i don't think overlapping instances is that likely to get into the standard
10:30:27 <dolio> I certainly hope not.
10:30:47 <quicksilver> didn't MR by default already go out in 2010?
10:31:32 <quicksilver> MPTC will be definitely in some future version of haskell', but I think the point is that MPTC alone isn't very useful. You need either fundeps or ATs to usefully regulate your MPTCS
10:31:41 <quicksilver> and those are still a bit immature fora  standard.
10:32:30 <Saizan> yet you could have MPTCs with all FlexibleContexts/Instances ..
10:32:33 <sproingie> fundeps seem pretty mature to me, tho i suppose there's richer mechanisms yet we could skip straight to
10:32:55 <Saizan> so we don't have to add so many extensions to write innocuous type signatures :)
10:33:18 <sproingie> i just get the feeling that by the time those are standardized, there'll be something else niftier.  what's that dilemma called, when you always put off a purchase because of something better on the horizon?
10:33:36 <sproingie> something about opportunity cost i guess
10:34:45 <dolio> Functional dependencies as implemented in GHC aren't completely compatible with associated types in GHC.
10:34:48 <Saizan> that's just natural, if something feels nifty it's probably so new you still don't know if it's good
10:35:08 <dolio> So, you have to decide how you want them to behave.
10:35:38 <kstt> sproingie: "tracking rainbows" ?
10:35:40 <dolio> If fundeps were made to work more like type families, overlapping instances would no longer be okay, for instance.
10:36:29 <guest2425> dolio: I have a question
10:36:37 <dolio> Okay.
10:37:03 <monochrom> http://www.vex.net/~trebla/humour/lazy-question-stream.html
10:37:22 <guest2425> dolio: is complicated do
10:37:31 <guest2425> I dont even know how to start
10:38:44 <monochrom> the best way to win is not to play
10:39:36 <guest2425> dolio: here is my code http://paste.org/pastebin/view/24436
10:39:39 <guest2425> any idea?
10:41:18 <dolio> guest2425: Merge_Package says the things it holds are integers.
10:41:36 <guest2425> oh ok
10:41:36 <dolio> Then you're using xs == null. null is a function that tests if a list is empty.
10:41:59 <guest2425> but I am taking list for merge sort
10:42:16 <dolio> > null []
10:42:17 <lambdabot>   True
10:42:20 <dolio> > null [2]
10:42:21 <lambdabot>   False
10:43:04 <guest2425> dolio: How can I change it to take 2 lists
10:43:05 <guest2425> ?
10:43:33 <dolio> Lists of integers?
10:43:45 <guest2425> yes
10:43:57 <dolio> data Merge_Package = MergePackage [Integer] [Integer]
10:44:06 <guest2425> ok kool
10:44:24 <guest2425> because merge should take list of integers correct?
10:44:41 <dolio> Probably.
10:45:07 <guest2425> merge means 
10:49:56 <guest2425> dolio: I dont know how to pattern matching the following  http://paste.org/pastebin/view/24437
10:52:26 <guest2425> dolio: any idea?
10:52:45 <dolio> Are you sure that the termination condition should be taking a Merge_Package?
10:54:04 <guest2425> yes
10:55:03 <guest2425> dolio: oh what do you think
10:57:21 <dolio> I don't know. I'm not used to trying to fit my functions into all-in-one recursion constructs like that recursionEngine.
10:59:35 <Jafet> I'm sure dolio would be more interested in your code if it had a Monad instance somewhere
11:00:09 <evilgeenius_> I'm just going through the tutorial "Haskell in 5 steps" but i get the error "Could not find module `Control.Parallel':" when compiling one of the example scripts. How can I fix this? 
11:00:46 <evilgeenius_> i havent quit
11:00:48 <Saizan> i think you need to install the "parallel" package
11:00:58 <c_wraith> yeah, parallel is not installed by default
11:01:09 <evilgeenius_> How do I do that?
11:01:16 <pistacchio> hi, is there any production-ready (fast and stable) database driver for haskell? ideally mysql or postgres or mongodb. thanks
11:01:21 <monochrom> http://paste.org/pastebin/view/24432 is revealing
11:02:15 <evilgeenius_> Saizan: is there a haskell package manager or can i install it with apt?
11:02:28 <monochrom> I think it is best to skip the Control.Parallel example for now.
11:02:43 <Colours> use cabal to install Haskell libraries
11:03:00 <Saizan> apt might have libghc6-parallel-dev
11:03:10 <Colours> you can use your package manager but it probably won't have all of the libraries that you can get with cabal
11:03:44 <Jafet> And find -ipath '*ghc*' -or -ipath '*haskell*' -print0 | xargs -0 rm to uninstall them
11:05:43 <evilgeenius_> test
11:06:12 <evilgeenius_> x
11:06:22 <zygoloid> 2 / 2 test(s) passed
11:06:22 <lambdabot> zygoloid: You have 1 new message. '/msg lambdabot @messages' to read it.
11:06:44 <c_wraith> more importantly, unless you're on arch, your package manager is probably months out of date with respect to haskell packages.
11:08:24 <evilgeenius_> Is haskell mainly an academic/research language?
11:08:40 <monochrom> not any more
11:09:34 <c_wraith> people kept using it to write software.  they couldn't keep it in academia forever
11:10:07 <maurer_> If it weren't for GHC, it probably would have stayed there.
11:10:11 <evilgeenius_> What does the par and pseq mean in this line of haskel :  " a `par` b `par` c `pseq` print(...."
11:10:18 <maurer_> hugs wasn't really fast enough.
11:11:10 <EvanR-work> haskell being mainly academic research is a common anti haskell propaganda. i.e. its like that so you shouldnt use it
11:11:10 <Vanadium> evilgeenius_: They are functions from Control.Parallel
11:11:12 <monochrom> x `par` y: try to evaluate both x,y in parallel. x `pseq` y: try to evaluate x before y
11:11:33 <maurer_> evilgeenius: If you wish to evaluate the print statement, please evaluate a, b, and c
11:11:46 <maurer_> pseq is strict in left arg, not strict in right arg, so you still get a lazy statement
11:12:18 <evilgeenius_> strange how the functions are in quotes
11:12:20 <maurer_> par is strict in both so a, b, and c can all be considered reorderable and concurrently evaluable
11:12:34 <maurer_> evilgeenius_: a `somefunc` b == somefunc a b
11:12:55 <monochrom> x `par` y is syntax sugar for par x y. try 10 `div` 3 and div 10 3 some day.
11:12:56 <maurer_> Similarly, a + b == (+) a b
11:13:17 <EvanR-work> however!
11:13:23 <EvanR-work> > 4 `(+)` 6
11:13:24 <monochrom> > (not `map` [True,False]) == (map not [True,False])
11:13:24 <lambdabot>   <no location info>: parse error on input `('
11:13:25 <lambdabot>   True
11:13:34 <evilgeenius_> \m
11:13:41 <evilgeenius_> ok you lost me
11:13:53 <monochrom> lost in syntax
11:13:59 <Colours> > (+) 4 6
11:14:00 <lambdabot>   10
11:14:15 <evilgeenius_> so could you do : pseq par x y print(....
11:14:46 <EvanR-work> does haskell have a dangling else?
11:14:48 <monochrom> you probably first need to recall your childhood wish of "I have defined a function called 'hello' in 2 parameters. I wish to use it infix."
11:15:14 <monochrom> haskell doesn't have a dangling else.
11:15:34 <EvanR-work> because of then
11:15:53 <monochrom> actually, because else is mandatory.
11:16:08 <evilgeenius_> Did all haskell programmers being programming at 1?
11:16:14 <evilgeenius_> *begin
11:16:20 <Jafet> C has dangling else because the grammar rules overlap
11:16:28 <maurer_> Really, I don't know why we didn't make "if, then, else" not keywords and make "if :: Bool -> a -> a -> a" a prelude function.
11:16:28 <sipa> evilgeenius_: how do you mean?
11:16:47 <sipa> maurer_: indeed
11:16:54 <evilgeenius_> it seems like quite a hardcore language
11:16:56 <EvanR-work> maurer_: cultural reasons
11:17:10 <Jafet> @pl \p t f -> if p then t else f
11:17:10 <lambdabot> if'
11:17:14 <EvanR-work> haskell wants to look like math ;)
11:17:26 <maurer_> EvanR-work: Hm? It seems like you'd still get the nice math-like layout
11:17:32 <sipa> no haskell *is* math, but it tries to look like a programming language :)
11:17:43 <Jafet> @pl \(another,pl,cheat) -> 0
11:17:43 <lambdabot> (line 1, column 13):
11:17:44 <maurer_> You just wouldn't have explicit "then" and "else" before the second two arguments
11:17:44 <lambdabot> unexpected ","
11:17:44 <lambdabot> expecting letter or digit, operator or ")"
11:17:44 <lambdabot> ambiguous use of a non associative operator
11:18:02 <maurer_> People who _really_ wanted it could just define "then = id" and "else = id"
11:18:03 <maurer_> :P
11:18:03 <EvanR-work> haskell is math, yeah right, ask anyone about the result of genericLength
11:18:32 <monochrom> people disagree on what math is.
11:18:45 <sipa> do people disagree on what haskell is? :)
11:18:52 <monochrom> yes.
11:18:53 <maurer_> EvanR-work: Please enlighten me, what's wrong with genericLength?
11:18:57 <sipa> is there anything people don't disagee about?
11:18:59 <EvanR-work> it doesnt work
11:19:05 <sipa> how so?
11:19:10 <roconnor> math is computer science without the computation.
11:19:11 <dolio> The name is too long.
11:19:16 <sipa> > genericLength "bla" :: Int
11:19:17 <lambdabot>   3
11:19:18 <monochrom> in particular, they disagree on whether this question makes sense: "is haskell a compiled language?"
11:19:22 <EvanR-work> > genericLength [1..100000]
11:19:23 <lambdabot>   100000
11:19:26 <EvanR-work> > genericLength [1..1000000]
11:19:27 <lambdabot>   *Exception: stack overflow
11:19:39 <sipa> that's an implementation issue :)
11:19:44 <EvanR-work> uh huh
11:19:56 <Jafet> @src genericLength
11:19:56 <lambdabot> genericLength []    = 0
11:19:56 <lambdabot> genericLength (_:l) = 1 + genericLength l
11:20:14 <sipa> > 5 :: Nat
11:20:15 <lambdabot>   Not in scope: type constructor or class `Nat'
11:20:34 <EvanR-work> @src length
11:20:34 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:20:45 <EvanR-work> > length [1..1000000]
11:20:46 <lambdabot>   1000000
11:21:16 <evilgeenius_> 1 * 2
11:21:31 <sipa> did anyone notice (or think about) this: you can make data Nat = Z | S nat an instance of Num, in which case the expression "(genericLength [1..] :: Nat) > 5" immediately evaluates to True
11:21:49 <dolio> Yes.
11:21:53 <sipa> it
11:21:59 <Jafet> > let genericLength = foldl' ((succ.) . const) 0 in genericLength [1..1000000]
11:22:00 <roconnor> > (genericLength [1..] :: Nat) > 5
11:22:01 <lambdabot>   Not in scope: type constructor or class `Nat'
11:22:01 <lambdabot>   1000000
11:22:07 <roconnor> > (genericLength [1..] :: Natural) > 5
11:22:08 <lambdabot>   Not in scope: type constructor or class `Natural'
11:22:08 <evilgeenius_> Is there a haskel interpreter in this irc room??
11:22:17 <roconnor> where is Nat
11:22:20 <EvanR-work> evilgeenius_: yes there is
11:22:26 <sipa> @vixen are you a haskell interpreter?
11:22:26 <lambdabot> Ooh, functional programmers are so hot!
11:22:34 <Jafet> Haskell interpreter? What nonsense
11:22:49 <dolio> roconnor: It disappeared a while ago for some reason.
11:22:52 <monochrom> no, there is no haskell interpreter in this room
11:22:55 <evilgeenius_> > 1 * 2
11:22:56 <lambdabot>   2
11:22:58 <dolio> And no one's bugged Cale enough to get it back, I guess.
11:23:00 <monochrom> and no room for humans either
11:23:10 <sipa> dolio: it's obvious of course, Nat has the possibility to have a lazy (+), but i thought is was neat :)
11:23:29 <evilgeenius_> EvanR-work: thank god for that, i thought you were all totally mental for a while, finishing of each others sentences ...
11:23:36 <sipa> and lazy (>)
11:23:43 <monochrom> lazy + is neat. it is the only justification for genericLength
11:24:07 <EvanR-work> i would not mind if genericLength terminate normally
11:24:13 <EvanR-work> terminated
11:24:17 <evilgeenius_> > fac n = if n == 0 then 1 else n * fac (n-1)
11:24:18 <lambdabot>   <no location info>: parse error on input `='
11:24:23 <EvanR-work> given enough time
11:24:26 <evilgeenius_> > let fac n = if n == 0 then 1 else n * fac (n-1)
11:24:27 <lambdabot>   not an expression: `let fac n = if n == 0 then 1 else n * fac (n-1)'
11:24:28 <Jafet> genericLength also saves making an obscene synonym for fromIntegral
11:25:42 <zygoloid> > genericLength [1..] :: Data.Number.Natural.Natural
11:25:43 <lambdabot>   Not in scope:
11:25:43 <lambdabot>    type constructor or class `Data.Number.Natural.Natural'
11:25:49 <EvanR-work> i guess practically speaking, using length of a non short list in an algorithm is stupid
11:26:22 <EvanR-work> its only use would be actually producing a count at the end
11:26:40 <zygoloid> well, genericLength :: [a] -> Natural is basically just map (const undefined) [if we take Natural = [Void]]
11:27:26 <evilgeenius_> > do { n <- readLn ; print (n^2) }
11:27:27 <lambdabot>   <IO ()>
11:27:37 <EvanR-work> zygoloid: the preschool formulation of the naturals ;)
11:28:33 <Dybber> Hi, I have a bit of trouble with installing snap-server from cabal, caused by the new mlt-2.0. Cabal error message: http://hpaste.org/41142/snap_installation_mtl20_con
11:30:36 <Jafet> instance Integral [Void] where
11:31:07 <sipa> > undefined :: Void
11:31:08 <lambdabot>   Not in scope: type constructor or class `Void'
11:31:12 * Jafet abruptly stops continuing that and slinks away
11:31:14 <sipa> you mean (), no?
11:32:24 <dmead> hey channel
11:32:32 <dmead> did something change in ghci recently?
11:32:41 <EvanR-work> how do you have a list of Void anyway
11:32:42 <Jafet> @src Integral
11:32:42 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:32:42 <dmead> it won't chase files in the current directory anymore
11:32:42 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:32:42 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:32:42 <lambdabot>     toInteger           :: a -> Integer
11:32:44 <EvanR-work> ah, bottom
11:33:02 <sipa> > [] :: [()]
11:33:03 <lambdabot>   []
11:33:09 <sipa> > [(),()] :: [()]
11:33:10 <Jafet> Well, [Void] = [!()], or however the rules for this made up notation go
11:33:10 <lambdabot>   [(),()]
11:33:20 <monochrom> ghci destroys itself every 5 weeks.
11:33:40 <Jafet> I don't want to implement quotrem for Natural.
11:33:42 <EvanR-work> > length [undefined, undefined]
11:33:43 <lambdabot>   2
11:34:02 <aristid> > length "EvanR"
11:34:03 <lambdabot>   5
11:34:11 <aristid> amazing
11:34:16 <zygoloid> Jafet: fortunately you don't have to since i already have
11:34:18 <sipa> > length [1..1000000]
11:34:18 <lambdabot>   1000000
11:34:19 <zygoloid> @hackage numbers
11:34:19 <lambdabot> http://hackage.haskell.org/package/numbers
11:34:20 <sipa> > length [1..10000000]
11:34:21 <lambdabot>   10000000
11:34:23 <sipa> > length [1..100000000]
11:34:25 * Jafet relieved
11:34:27 <lambdabot>   mueval-core: Time limit exceeded
11:34:34 <sipa> > genericLength [1..10000000] :: Int
11:34:35 <lambdabot>   *Exception: stack overflow
11:34:48 <zygoloid> Jafet: or possibly augustss did, can't remember
11:35:17 <EvanR-work> strict arithmetic sucks!
11:36:07 <EvanR-work> if you replace with lazy natural, what else is there to drive the program?
11:36:09 <EvanR-work> IO ?
11:36:48 <Jafet> Then replace all String with Bytestring.Lazy
11:37:11 <Jafet> Finally, retire to an english country home.
11:37:33 * copumpkin wants to write a new lazy/strict natural library
11:38:37 <snonkings> How can I get  laid by writing Haskell? Does this Dons guy get a lot of pussy?
11:38:48 --- mode: ChanServ set +o copumpkin
11:38:49 * zygoloid wonders whether it's possible to get a more compact and efficient representation without sacrificing laziness
11:39:07 <copumpkin> zygoloid: I was thinking of taking a difference list of GMP naturals
11:39:10 <copumpkin> representing "add X"
11:39:10 <snonkings> Just want to be sure about what I'm getting into here
11:39:17 <copumpkin> snonkings: trolling?
11:39:33 <EvanR-work> zygoloid: what about smalltalk numbers...
11:39:36 <snonkings> Is Dons getting laid or not?
11:39:46 --- kick: snonkings was kicked by copumpkin (none of your business)
11:40:05 <snonkings> that was not nice
11:40:21 --- mode: ChanServ set +o monochrom
11:40:33 <copumpkin> snonkings: do you have any questions about haskell the language? cause you just sound like a troll right now
11:40:33 --- mode: monochrom set +q *!*@gateway/web/freenode/ip.80.212.75.*
11:40:42 --- mode: monochrom set -q *!*@gateway/web/freenode/ip.80.212.75.71
11:40:45 --- mode: monochrom set -o monochrom
11:41:03 --- mode: copumpkin set -o copumpkin
11:41:13 <Botje> trolling #haskell must be really boring, everyone is so nice and rational.
11:41:18 <Jafet> Well, if they add to the shootout a sex related challenge...
11:41:31 <monochrom> last night here was a troll from 80.212.75.71. I think I see a pattern.
11:41:37 <kmc> Botje, it's not hard to troll #haskell
11:41:40 <copumpkin> zygoloid: seems like that representation would support a lot more efficient operations than the usual unary form, yet still be lazy
11:41:55 <kmc> just get confused and angry about the difference between String and IO String
11:42:07 <Botje> heh :)
11:42:19 <copumpkin> zygoloid: I'm in the process of making a cmm-level binding to GMP's natural interface (as opposed to the GHC integer one)
11:42:59 <zygoloid> copumpkin: i guess you'd need something unamb-style to avoid forcing the list of summands in any particular order
11:43:15 <copumpkin> ah, maybe
11:43:32 <zygoloid> (though maybe it's fine for 5 + _|_ + 5 > 8 to be _|_, since it is for Natural already)
11:44:07 <copumpkin> it'd be nice for it not to be, but until we have an unamb# primop that does it as efficiently as possible
11:44:12 <copumpkin> it might not be possible :/
11:44:36 <Jafet> Would interval arithmetic work?
11:44:43 <aristid> so this IO String... it's not a function, right? HOW CAN IT DO ANYTHING?!
11:44:51 <Jafet> (5,5) + (0,inf) + (5,5) = (10,inf) > (8,8)
11:45:07 <monochrom> it doesn't do anything. retire to an english country home.
11:45:27 <danr> aristid: well, it is in the IO-monad so it is allowed to do any input/output to produce this String
11:45:39 <zygoloid> Jafet: you still need a mechanism to relax _|_ to (0,inf) in a way where non-_|_ values can provide additional information
11:45:54 <aristid> danr: but people told me i didn't need to learn that scary "monad" business
11:46:14 <danr> aristid: maybe you can just view it as some instruction for the computer/haskess to produce a String for you
11:46:20 <Jafet> (5,5,id) + (0,inf,moredigit) + (5,5,id)
11:46:26 <infoe> scary?
11:46:31 <aristid> danr: you mean like a function that takes no arguments?
11:46:36 <Jafet> ...that's starting to look like CReal now
11:47:02 <Jafet> Also, I don't know how to add id and moredigit
11:47:12 <byorgey> aristid: a recipe is not a function, it is just some text written on a piece of paper
11:47:22 <EvanR-work> an instruction for some external entity with access to physics to produce a string for you
11:47:24 <Jafet> A recipe for burritos!
11:47:29 <danr> aristid: like an instruction. Example: getLine :: IO String is an instruction how to read a String from the user's console/terminal
11:47:33 <byorgey> aristid: in the same way, a value of type IO String is just a "recipe" for how to produce a String while potentially doing some I/O
11:47:41 <monochrom> I think all of you underestimate the power of <kmc> Botje, it's not hard to troll #haskell <kmc> just get confused and angry about the difference between String and IO String
11:47:52 <siml1> hi. i am new to haskell and cant find my mistake. Thx! http://pastebin.com/zrmWkFUA
11:47:53 <byorgey> aristid: eventually it will be interpreted by the Haskell runtime
11:47:57 <Jafet> I think they're just doing a practice run, monochrom
11:48:02 <EvanR-work> lol
11:48:08 <Jafet> We haven't had one of those in a while, you see.
11:48:09 <monochrom> ok!
11:48:13 <danr> monochrom: what about IO (IO String), then? :p
11:48:19 <EvanR-work> this is 4th order trolling
11:48:27 <aristid> byorgey: right. apparently you didn't see that kmc said the best way to troll this channel is to get confused and angry about the difference between String and IO String? :P
11:48:44 <EvanR-work> byorgey is in on it
11:48:48 <sipa> siml1: what is the error?
11:48:52 * monochrom underestimates the power of that too
11:49:02 <ZekeDragon> siml1: Your second if statement in doLoop does not have an else statement.
11:49:13 * byorgey is tired
11:49:13 <EvanR-work> IO^n String
11:49:18 <siml1> sipa: last line comment
11:49:32 <siml1> ZekeDragon, and if i dont need an else?
11:49:33 <aristid> danr: IO (IO String) is strictly more powerful than IO String :)
11:49:35 <danr> aristid: efficient way to waste people's time there...
11:49:43 <Jafet> > return $ return 1 :: IO (IO Int)
11:49:44 <lambdabot>   <IO (IO Int)>
11:49:56 <sipa> siml1: you need an else
11:50:01 <sipa> not only a if
11:50:04 <sipa> *then
11:50:16 <siml1> sipa, can i have an empty else?
11:50:24 <sipa> else return ()
11:50:28 <zygoloid> @type when
11:50:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:50:35 <monochrom> @src when
11:50:35 <lambdabot> when p s = if p then s else return ()
11:50:38 <zygoloid> ^^ if with no else, for use within do
11:52:46 <monochrom> methinks "if with no else" is very damaging. there is always an else.
11:53:03 <EvanR-work> IO is a special kind of monad because it does not have to adhere to the laws of haskell that most monads obey. this leads me to ask, what other possibilities are there for IO-like monads, that is, rules breaking monads
11:53:05 <ricree> does anyone know which module in Graphics.UI.WX the attributes are defined in?
11:53:08 <copumpkin> if not endOfUniverse then ... else ???
11:53:18 <sipa> which rules does IO break?
11:53:26 <ksf> Main> get 124502398456127592348754 root
11:53:26 <ksf> "atafugupunetufapakapi"
11:53:29 <EvanR-work> hmm
11:53:41 <EvanR-work> will theres no runIO which defines how IO actions will behave ahead of time
11:53:54 <copumpkin> just think of there being an implicit runIO around main
11:53:59 * ksf thinks he has just found the perfect way to present random numbers for map generation, serial numbers, hashes etc.
11:54:03 <copumpkin> the RTS is your runIO
11:54:06 <kmc> there's no rule that monadic values need to be runnable
11:54:14 <zygoloid> EvanR-work: one can still implement IO in the pure fragment of haskell, but picking a good representation for IO turns out to be nontrivial.
11:54:15 <monochrom> maybe your else branch is "nop" and you like to saving typing. but when you reason about your program, you have to always put the "else nop" back.
11:54:22 <sipa> there is no "run[]" either
11:54:35 <kmc> sipa, but you don't need it, because [a] is not an abstract type
11:54:45 <kmc> EvanR-work, you should distinguish the actual monad laws from other properties that tend to hold
11:55:11 <EvanR-work> i didnt mean to refer to the actual monad laws
11:55:16 <aristid> EvanR: huh? runIO exists and it's called unsafePerformIO
11:55:43 <zygoloid> (actually, i take that back, i've never been convinced that IORefs are implementable even within the IO-as-free-monad-over-FFI-functor model)
11:55:49 <Jafet> Most importantly you must realize that there is no Universe (only RealWorld#).
11:55:53 <EvanR-work> unsafePerformIO, getChar, etc are IO actions that you cant define in terms of haskell
11:56:02 <Jafet> main = return (unsafePerformIO main)
11:56:10 <EvanR-work> i mean, if its IO String, theres no way to know what that String is
11:56:21 <EvanR-work> even in principle
11:56:25 <monochrom> movie title: RealWorld# is not enough
11:56:26 <sipa> that's exactly the point
11:56:33 <sipa> the IO monad allows you to hide that
11:56:38 <sipa> because it isn't representable
11:56:58 <EvanR-work> but theres always a representation in haskell of a State S String
11:57:19 <EvanR-work> unless its bottom
11:57:23 <zygoloid> is it really unrepresentable? there have been various partial models of IO presented here and on -cafe.
11:57:32 <EvanR-work> right but by default there isnt one
11:57:40 <EvanR-work> you are introducing another model
11:57:44 <sipa> zygoloid: sure, it's more the possibility of hiding it
11:57:47 <EvanR-work> im asking about anti-models
11:57:50 <zygoloid> EvanR-work: how do you know that without breaking the abstraction barrier?
11:58:02 <kmc> "theres no way to know what that String is" ← there is no String, it's a nonsense question
11:58:04 <EvanR-work> i guess if IOs behavior isnt defined
11:58:17 <EvanR-work> it doesnt make sense to ask for something similar that isnt IO
11:58:20 <zygoloid> for all i know there's a compiler out there that actually uses the free monad approach to implement IO
11:58:23 <EvanR-work> because you couldnt tell the difference
11:58:58 <sipa> in the [] monad value [] of type [String], there is no String either
11:59:18 <EvanR-work> no, its []
11:59:33 <EvanR-work> there is some representation
11:59:39 <sipa> just as an IO String is not a String, and there does not need to be one
11:59:43 <kmc> data Trivial a = Trivial
11:59:46 <kmc> make that a monad
11:59:51 <kmc> there's no String in (Trivial String), period
12:00:00 <zygoloid> in the (->) r monad, an (r -> String) doesn't contain a String in pretty much the same way an IO String doesn't.
12:00:06 <EvanR-work> Trivial has an implementation
12:00:10 <sipa> EvanR-work: you seem to think of monads as general data structures
12:00:12 <EvanR-work> definable in haskell
12:00:17 <EvanR-work> sipa: no
12:00:19 <sipa> there can be a lot more than that though
12:00:30 <EvanR-work> i dont think of IO as a data structure
12:00:30 <kmc> there is no rule that «T a» must contain «a»
12:00:37 <kmc> this isn't about monads; it's a much more general question
12:00:42 <EvanR-work> im looking at IO as the one that isnt implemented as data
12:00:50 <zygoloid> EvanR-work: how do you know? it could be.
12:00:57 <kmc> in GHC, IO is implemented as data
12:01:11 <kmc> as much as State is
12:01:39 <roconnor> exitWithSuccess : IO String has no string
12:01:43 <jmcarthur> but that's just ugliness to make it work under ghc's evaluation rules
12:01:48 <zygoloid> the GHC implementation is really not enlightening, unless you want to understand GHC internals
12:01:49 <aristid> @unmtl StateT a IO
12:01:49 <lambdabot> err: `StateT a IO' is not applied to enough arguments, giving `/\A. a -> IO (A, a)'
12:01:51 <kmc> yeah
12:01:54 <kmc> was about to say that ;)
12:01:58 <EvanR-work> so do you have a model of IO that is implemented in haskell and actually works like IO
12:01:59 <aristid> @unmtl StateT s IO a
12:01:59 <lambdabot> s -> IO (a, s)
12:02:16 <roconnor> don't bring up how GHC implements IO.  That isn't helpful.
12:02:20 <kmc> EvanR-work, sure, you can build a GADT where return, (>>=), and each IO primitive has a constructor
12:02:25 <roconnor> talk about the free FFI monad instead.
12:02:34 <EvanR-work> the fffi monad doesnt help
12:02:40 <kmc> then you can write an "interpreter" for that in terms of the original IO monad
12:02:43 <EvanR-work> neither does kmc suggestion
12:02:44 <roconnor> EvanR-work: I think it does
12:02:57 <EvanR-work> heres an example, get time of day, three times in a row
12:03:02 <EvanR-work> make that work like IO
12:03:17 <kmc> obviously the Haskell spec gives no way to do IO other than the IO monad, so you can't implement your free FFI monad or whatever without using the existing IO
12:03:19 <aristid> i wonder if IoRefT would make sense, i.e. same interface as StateT but based on IORefs
12:03:22 <EvanR-work> replicateM getTimeOfDay
12:03:28 <roconnor> EvanR-work: anything could potentially happen because someone could reset the system clock between calls.
12:03:30 <zygoloid> EvanR-work: GetTimeOfDay (\t1 -> GetTimeOfDay (\t2 -> GetTimeOfDay (\t3 -> (t1,t2,t3))))
12:03:34 <EvanR-work> roconnor: yes
12:03:35 <zygoloid> EvanR-work: next.
12:03:40 <roconnor> EvanR-work: you have no guarentees
12:03:44 <EvanR-work> yes
12:03:47 <EvanR-work> so you cant do it
12:03:55 <zygoloid> EvanR-work: I just did it.
12:03:59 <roconnor> which is exactly what the free monad gives you: No Guarentees
12:04:10 <copumpkin> you get what you pay for
12:04:13 <copumpkin> free is free
12:04:15 <copumpkin> :(
12:04:20 <EvanR-work> whats t1, t2, and t3
12:04:24 <zygoloid> GetTimeOfDay :: (TimeOfDay -> IO a) -> IO a
12:04:27 <EvanR-work> runIO please
12:04:39 <zygoloid> EvanR-work: runIO is not part of IO's interface.
12:04:50 <aristid> runIO :: IO a -> RealIO a
12:04:50 <EvanR-work> well its not acting like real IO
12:04:58 <zygoloid> EvanR-work: how so?
12:05:07 <copumpkin> runIO is pretty trivial with the free IO monad
12:05:08 <roconnor> IO doesn't *Act* like anything, as we all should know.
12:05:08 <EvanR-work> i can get a t1 t2 t3 in real IO
12:05:31 <zygoloid> EvanR-work: no you can't. all you can do is pass off an IO () to main and let the RTS interpret it
12:05:35 <copumpkin> but you should split the commands from the free monad structure
12:05:38 <copumpkin> it makes it easier to deal with
12:05:38 <EvanR-work> i know that
12:05:43 <copumpkin> (like in monadprompt or operational)
12:05:48 <EvanR-work> zygoloid: i clearly see three numbers on my screen
12:05:51 <zygoloid> EvanR-work: same here. you pass off this structure to the RTS, it interprets it.
12:05:58 <EvanR-work> ok, make an interpreter
12:06:13 <roconnor> zygoloid: the RTS is responsible for putting stuff on the screen.  But that isn't haskell, that is the CRT
12:06:15 <monochrom> I no longer understand the question.
12:06:16 <zygoloid> EvanR-work: sure: id
12:06:17 <copumpkin> http://hackage.haskell.org/package/IOSpec
12:06:24 <roconnor> er
12:06:30 <EvanR-work> monochrom: the question was deleted
12:06:33 <roconnor> EvanR-work: the RTS *isn't* responsible for putting stuff on the screen.  But that isn't haskell, that is the CRT
12:06:35 <EvanR-work> no one is interested
12:06:40 <kmc> the question was: how to troll #haskell
12:06:57 <roconnor> the answer is: discuss what IO a is
12:07:06 <Jafet> kmc: we are computing the answer now, one bad analogy at a time
12:07:07 <EvanR-work> make an RTS in haskell for this IO model
12:07:32 <copumpkin> EvanR-work: that reduces to the existing IO model?
12:07:40 <roconnor> the answer is clearly take the free monad generated by all the primitives and mod out by all the laws that you have between those primitives.
12:07:49 <EvanR-work> copumpkin: i said acts like...
12:08:01 <EvanR-work> so i guess you could make a deterministic rts that always gives 0 0 0
12:08:01 <roconnor> and since there are almost now laws about the primitives, you get essentially a free monad
12:08:12 <monochrom> I think it is correct to say can't be done in haskell98 unless you use haskell98's IO again.
12:08:14 <EvanR-work> everything executes instantly
12:08:32 <EvanR-work> and all concurrent processes execute one after the other in a defined order
12:08:34 <roconnor> EvanR-work: it is pretty easy if you use override the program with LD environment magic.
12:08:35 <copumpkin> EvanR-work: sure, or you could simulate the progression of time units with every "command"
12:08:41 <zygoloid> EvanR-work: an interpreter for IO a would have type IO a -> IO a, right? what's wrong with using id?
12:08:58 <EvanR-work> zygoloid: no it would be IO a -> a
12:08:58 <copumpkin> zygoloid: I think he wants an interpreter from FreeIO a -> IO a
12:09:02 <copumpkin> or FreeIO a -> a
12:09:24 <zygoloid> EvanR-work: why would it have that type? should an interpreter for [a] have type [a] -> a?
12:09:26 <monochrom> "-> a" clearly is undesirable
12:09:43 <EvanR-work> it has that type because we think of IO a as an io action that when executed gives a single value of type a
12:09:44 <copumpkin> FreeIO a -> a has no side effects
12:09:50 <zygoloid> should an interpreter for (r -> a) (whatever that would mean) have type (r -> a) -> a?
12:10:01 <EvanR-work> indeed there will be no side effects
12:10:07 <copumpkin> String -> FreeIO a -> (a, String) might handle input and output to stdin/out
12:10:41 <EvanR-work> ok there are many ways to define an interpreter
12:10:48 <Eduard_Munteanu> o/
12:10:48 <EvanR-work> some with side effects some without
12:10:54 <copumpkin> EvanR-work: yep
12:11:01 <copumpkin> depending on what your FreeIO includes
12:11:05 <EvanR-work> cool
12:11:31 <aristid> runIO :: Free IO a -> RealWorld -> (a, RealWorld) -- bad joke
12:11:48 <EvanR-work> hm
12:11:57 <EvanR-work> i see RealWorld may actually be adequate here
12:12:17 <copumpkin> assuming it actually wraps up a bunch of information about the RealWorld, unlike the current RealWorld type
12:12:18 <EvanR-work> just provide RealWorld initial with a random seed to introduce incertainty ;)
12:12:47 <Eduard_Munteanu> So that is _probably_ safe? :)
12:12:51 <zygoloid> you don't even need an explicit RealWorld parameter. start with a 'default' RealWorld with no files and all file handles closed
12:13:06 <Jafet> What if you're a child process!
12:13:16 <copumpkin> Eduard_Munteanu: it's definitely safe if you provide a pure interpreter and reify your effects as values that the interpreter returns/takes/passes around
12:13:18 <EvanR-work> you would be nice if you could alter the initial state
12:13:39 <EvanR-work> repeated applications are outside this model
12:13:47 <EvanR-work> i guess default is all you need
12:14:07 <zygoloid> as i said earlier, you can implement a lot of stuff that way, but i don't think you can implement working IORefs that way
12:14:24 <copumpkin> you could with Dynamic, I think
12:14:34 <zygoloid> only if you have Typeable instances for all types
12:14:35 <EvanR-work> why not?
12:14:42 <roconnor> State RealWorld doesn't handle forever
12:14:51 <copumpkin> EvanR-work: you need a map of iorefs to their values
12:15:00 <copumpkin> EvanR-work: the IORefs can carry different types
12:15:04 <copumpkin> so you need a heterogeneous map
12:15:15 <EvanR-work> ok so IO is special ;)
12:15:20 <copumpkin> no
12:15:20 <EvanR-work> it requires physics
12:15:26 <zygoloid> EvanR-work: I've never proved implementing ST is impossible, but i'm reasonably convinced it is
12:15:28 <EvanR-work> because of a type system limitation
12:15:28 <copumpkin> well, it is special in some sense
12:15:30 * hackagebot tls 0.3 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.3 (VincentHanquez)
12:15:39 <zygoloid> EvanR-work: IO isn't special, ST is special. IO is a special case of ST ;)
12:15:52 <EvanR-work> is ST the only defect?
12:15:52 <roconnor> IO is *not* about putting stuff on the screen
12:15:54 <zygoloid> (the non-ST bits do seem implementable..)
12:15:54 <monochrom> notice that IORef is not in haskell98
12:15:59 <roconnor> IO is about calling the CRT
12:16:09 <roconnor> and doing whatever it does
12:16:21 <EvanR-work> CRT = physics right
12:16:33 <EvanR-work> a screen buffer could be simulated
12:16:34 <roconnor> probably not
12:16:38 <monochrom> why don't we just agree "it's physics" and go home
12:16:51 <copumpkin> EvanR-work: what are you trying to get out of this?
12:17:07 <roconnor> copumpkin: a better explaination of IO
12:17:09 <EvanR-work> im interested in the ST thing
12:17:13 <zygoloid> EvanR-work: ST is the only bit i know of that i don't believe you can implement in pure haskell.
12:17:33 <EvanR-work> if ST cant be done, are there other interesting things that also cant be done, but we could make the implementation do anyway
12:17:39 <roconnor> zygoloid: :D  Funny I thoguht ST was the only bit that I beleive I could implement in pure haskell.
12:17:41 <copumpkin> if you had a dependently typed language, you could probably do ST/IO refs
12:18:00 <copumpkin> by explicitly adding the ref and its type to an environment as you move along
12:18:14 <monochrom> proof-carrying ref cells?
12:18:18 <roconnor> copumpkin: what do types have to do with ST?
12:18:35 <copumpkin> roconnor: STRefs have a type, and you can't put them all into a single Data.MAp
12:18:37 <copumpkin> Data.Map
12:18:50 <zygoloid> monochrom: what would they carry a proof of?
12:18:57 <copumpkin> you could however make an STRef a simple incrementing reference into a list of types
12:19:15 <Eduard_Munteanu> Um would that mean HList does it?
12:19:19 <copumpkin> a bit like how you'd make a typed LC interpreter
12:19:33 <copumpkin> Eduard_Munteanu: you can't really represent indices into an HList dynamically
12:19:48 <EvanR-work> having typeable instances for everything is fine
12:19:54 <roconnor> roconnor: But you could put them into a hetrogenous list.
12:19:57 <monochrom> I'm thinking proof of type so you can type-coerce correctly
12:19:58 <Eduard_Munteanu> Hm, makes sense.
12:20:13 <copumpkin> roconnor: but as I just said, the indices are resolved dynamically
12:20:22 <copumpkin> maybe a GADT representing the index might work, but it'd be pretty hardcore
12:20:27 <zygoloid> monochrom: proof that the ref is of which type, though? parametricity seems to get in the way.
12:20:30 <jmcarthur> not that hardcore
12:20:37 <EvanR-work> next question, could you define a behavior for IO ST or some special monad that could not in principle be done purely, but could be done other wise
12:20:42 <copumpkin> jmcarthur: do it then!
12:20:56 <copumpkin> I'm thinking of something along the lines of http://pumpkinpat.ch/moo.html
12:21:00 <copumpkin> it's almost the same thing, really
12:21:07 <jmcarthur> data Index :: * -> * -> * where Z :: Index (a, ctx) a ; S :: Index ctx a -> Index (b, ctx) a
12:21:17 <EvanR-work> random results is an interesting behavior, but im not sure how to define it
12:21:22 <zygoloid> EvanR-work: how about something using unamb which violates monotonicity?
12:21:34 * EvanR-work looks up unamb
12:21:39 <siml1> sipa, thx a lot btw
12:21:42 <copumpkin> lub is another similar thing
12:22:01 <copumpkin> jmcarthur: yeah
12:22:03 <jmcarthur> i really want a more efficient lub
12:22:11 <EvanR-work> whats monotonicity in this context?
12:22:23 <copumpkin> EvanR-work: functions only ever go from more defined to less defined
12:22:30 <copumpkin> jmcarthur: still not efficient, and I doubt you could make a usable tree-shaped map
12:22:47 * copumpkin tries out the pure ST idea though
12:23:11 <EvanR-work> zygoloid: you could violate that by fiddling with ghc?
12:23:12 <zygoloid> copumpkin: good luck. :)
12:23:14 <copumpkin> :P
12:23:18 <jmcarthur> copumpkin: i think it could be done, but i don't really want to devite brain power to it right now
12:23:30 <jmcarthur> *devote
12:23:32 <copumpkin> :)
12:23:35 * copumpkin is bored
12:24:54 <zygoloid> EvanR-work: i'm not actually sure you can violate monotonicity even with unamb. i'll give this some thought on the way home! :)
12:24:59 <copumpkin> try spoon
12:25:04 <Eduard_Munteanu> :t unamb
12:25:04 <lambdabot> Not in scope: `unamb'
12:25:05 <copumpkin> that violates monotonicity on purpose
12:25:14 <Eduard_Munteanu> @hoogle unamb
12:25:14 <lambdabot> No results found
12:25:23 <zygoloid> yeah, but that's almost cheating ;)
12:25:35 <Eduard_Munteanu> Found it... http://www.haskell.org/haskellwiki/Unamb
12:25:50 <copumpkin> I think I can write a pure ST, but not use the Monad interface on it
12:25:54 <zygoloid> spoon distinguishes different types of _|_, which is already Not Cool
12:26:24 <EvanR-work> cheating is basically ok
12:26:26 <zygoloid> copumpkin: do you need to carry the types of all references you've made in the 's' type?
12:26:31 <copumpkin> zygoloid: yeah
12:26:34 <EvanR-work> thats basically the point
12:26:35 <copumpkin> oh wait, not the s type
12:26:36 <EvanR-work> im getting at
12:26:38 <copumpkin> a separate context type
12:26:41 <Eduard_Munteanu> How's definedness distinguished really?
12:26:48 <Eduard_Munteanu> I mean, is it consistent to do so?
12:27:08 <zygoloid> i found an 'implementation' which carries the reference types in the 's' parameter, but that's not good enough! :)
12:27:33 <copumpkin> carrying it in a parameter prevents you from using the Monad interface
12:27:50 <copumpkin> I can write a bind that has a more suitable type for this
12:28:41 <zygoloid> copumpkin: if you can get that working, it'd still an impressive achievement.
12:28:46 <zygoloid> +be
12:28:49 * copumpkin plays some more
12:29:46 <EvanR-work> Eduard_Munteanu: fix (definedness is defined as)
12:29:53 <EvanR-work> ""++
12:30:33 <aristid> > fix ("definedness is defined as " ++)
12:30:34 <lambdabot>   "definedness is defined as definedness is defined as definedness is defined...
12:30:42 <Eduard_Munteanu> :)
12:30:55 <EvanR-work> definitions can utilize undefined primitives and / or other definitions, possibly recursive
12:31:02 <EvanR-work> i say
12:31:33 <EvanR-work> recursive would be a problem if you had to evaluate a definition, but is there a point to that really ;)
12:31:58 <EvanR-work> the only way to terminate is on undefined terms
12:32:07 <aoe> /?
12:32:21 <jmcarthur> copumpkin: happy birthday http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed-State.html#t:IxStateT
12:32:39 <copumpkin> hah
12:32:44 <Eduard_Munteanu> Hm, so undefined is "more" undefined than something that eventually 'fix'-es to undefined, or something like that?
12:33:01 <Saizan> not really
12:33:27 <jmcarthur> undefined is just easier to observe when you are cheating
12:33:27 <Saizan> well, according to the usual denotational semantics, every _|_ is the same
12:34:09 <Eduard_Munteanu> Um, so the whole monotonicity deal is just trivial? As in defined > undefined?
12:34:21 <jmcarthur> not quite that trivial
12:34:39 <Saizan> it's less simple when you have intermediate structures
12:34:49 <Saizan> e.g. Just _|_ < Just ()
12:34:55 <jmcarthur> for some data constructor Foo,   Foo defined > Foo undefined > undefined
12:35:06 <Eduard_Munteanu> Oh.
12:35:13 <jmcarthur> assuming the wrapped value is lazy
12:35:24 <Eduard_Munteanu> I took Saizan's comment to mean Just _|_ was just as undefined as outright _|_.
12:35:28 <jmcarthur> if it's strict then the last two are the same
12:35:44 <Eduard_Munteanu> jmcarthur: ah, it makes sense if laziness is the reason.
12:36:26 <jmcarthur> and then it gets even more complicated once you have products
12:38:10 <jmcarthur> ((), ()) > (_|_, ()) > (_|_, _|_) > _|_     ((), ()) > ((), _|_) > (_|_, _|_)
12:40:13 <EvanR-work> you could define a topology or metric space or something
12:42:07 <Eduard_Munteanu> jmcarthur: I see. I suppose there isn't a natural definedness order for that, is it?
12:43:50 <jmcarthur> "natural"?
12:44:33 <Saizan> Eduard_Munteanu: that wasn't the intended meaning
12:45:15 <Eduard_Munteanu> jmcarthur, Saizan: yeah, I mean does it arise from some axioms, or do you need to define it for every constructor?
12:45:31 <Eduard_Munteanu> Like compating Just _|_ to [_|_]
12:45:38 <Eduard_Munteanu> *comparing
12:46:11 <Eduard_Munteanu> or (_|_, ()) to (_|_, _|_).
12:46:36 <Twey> > let triangles = 0 : zipWith (+) triangles [1 ..] in take 10 triangles
12:46:37 <lambdabot>   [0,1,3,6,10,15,21,28,36,45]
12:46:48 <Eduard_Munteanu> jmcarthur: btw, I got TAPL some days ago, it's really nice, but I'm not far into it yet :)
12:47:01 <Saizan> Eduard_Munteanu: it's easily defined by recursive over the structure of the type
12:47:06 <Saizan> *recursing
12:47:08 <Eduard_Munteanu> jmcarthur: a lot nicer than Awodey's so far
12:47:21 <Saizan> anyhow, you only ever compare values of the same type
12:47:22 <Eduard_Munteanu> (Awodey's category theory)
12:47:42 <Eduard_Munteanu> Saizan: oh. That explains my misconception.
12:49:25 <tibbe> trac.haskell.org is down
12:50:13 <Saizan> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics#Algebraic_Data_Types
12:50:59 <Eduard_Munteanu> Saizan: thanks.
12:51:22 <Eduard_Munteanu> Will probably be useful, since TAPL is supposedly very short on denotational semantics.
12:52:58 <Saizan> you only get reduction rules in TAPL iirc
12:54:08 <Saizan> anyhow, denotational semantics are just interpreters, you're still left with the need to explain the host language :)
12:54:57 <Eduard_Munteanu> Saizan: so far, TAPL has been using operational semantics.
12:55:02 <EvanR-work> whats a good book/paper for an introduction to denotational semantics
12:55:10 <nus-> re CT: http://haskell.org/haskellwiki/User:Michiexile/MATH198
12:55:41 <monochrom> TaPL is almost 0 on denotational semantics. So how do you know a type system is sound in TaPL? By seeing that typing implies progress and preserving types when you evaluate terms.
12:56:30 <nus-> progress?
12:57:02 <monochrom> a typechecked term can be evaluated by at least one step
12:58:07 <Eduard_Munteanu> I'd be curious about EvanR-work's question as well.
12:58:22 <Eduard_Munteanu> Though I suppose the wikibooks stuff is a piece of that.
12:59:57 <monochrom> and old book "semantics of programming languages" by Tennent does denotational semantics and is short.
13:00:20 <Eduard_Munteanu> Thanks, I'll look it up.
13:00:45 <Eduard_Munteanu> Also I remember conal had a paper on denotational semantics in Haskell practice.
13:00:57 <monochrom> a modern book "foundation for programming languages" by Mitchell does everything and is thick. 800-900 pages.
13:01:05 * magicman kind of wants "forall" to be a valid identifier on the value-level...
13:01:05 <Eduard_Munteanu> (and Coq tutorials seemed to use that a lot)
13:02:22 <Eduard_Munteanu> IANATypeTheorist, but magicman, that doesn't really make sense, why?
13:02:40 <monochrom> but really, I learned denotational semantics from a lattice theory book by Davey and Priestley
13:03:02 <monochrom> forall is a valid identifier on the value level in haskell98
13:03:24 <Eduard_Munteanu> monochrom: hm, I could tell how denotational semantics and definedness relate to lattices, but still, that would be only a tangential topic right?
13:03:26 <magicman> That's true.
13:03:31 <copumpkin> zygoloid: I'm getting there, I think
13:03:35 <monochrom> > let forall x = x in forall 0
13:03:36 <lambdabot>   0
13:03:36 <Eduard_Munteanu> monochrom: how so?
13:03:44 <Eduard_Munteanu> Oh.
13:04:01 <magicman> It's because I keep using "exists = flip any" and "forall' = flip all". Except I also use it when I need forall-as-a-keyword.
13:04:15 <magicman> And from what I remember, it's been giving me parse errors :-/
13:04:40 <Eduard_Munteanu> magicman: you mean for writing proofs?
13:04:44 <magicman> exists [1,2,3] $ \num -> some very complicated boolean expression using num.
13:05:01 <Eduard_Munteanu> That would make some sense.
13:05:16 <monochrom> The Davey and Priestley book has chapters customized to CPOs as used by denotational semantics.
13:05:44 <magicman> When the property to test is a lot of code, using flip any/all is better style than the unflipped version IMHO.
13:05:53 <magicman> Similar with "for = flip map".
13:06:04 <magicman> (which does exist)
13:06:33 <Twey> @index for
13:06:33 <lambdabot> bzzt
13:06:38 <Twey> ITYM forM
13:06:40 <Eduard_Munteanu> :t forM
13:06:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
13:06:56 <Eduard_Munteanu> Didn't hear about 'for' though.
13:06:57 <Eduard_Munteanu> :t for
13:06:58 <lambdabot> Not in scope: `for'
13:07:14 <magicman> Oh, hrm.
13:07:19 <Twey> There's no ‘for’ AFAIK.
13:07:33 <magicman> Ah, in Data.Traversable
13:07:44 <magicman> But yes, you're right.
13:07:53 <magicman> I was being confused with forM vs mapM
13:07:54 <monochrom> I suggest you use "every" when you want to use "forall" but can't. "every xs (== 4)" reads well in english.
13:08:01 <magicman> My apologies.
13:08:05 <magicman> Oooh, that's a good one.
13:08:57 <Eduard_Munteanu> Still, that sucks if you use -XUnicodeSyntax and want to use symbolic forall/exists :)
13:09:27 <Eduard_Munteanu> I assume those expand to forall which is taken, right?
13:09:37 <Eduard_Munteanu> s/those expand/that expands/
13:10:16 <magicman> Probably :-/
13:10:49 * magicman doesn't use -XUnicodeSyntax very often.
13:13:34 <copumpkin> zygoloid: zomg
13:14:54 <merijn> Eduard_Munteanu: Why would that expand to forall? That's madness
13:15:37 <ciscon> any bluetile users in here by chance?
13:15:49 <Eduard_Munteanu> merijn: erm, yeah, forget that. At least it's probably interpreted just like forall.
13:16:06 <Eduard_Munteanu> So no way you can reuse it as an infix/function
13:18:22 <merijn> Eduard_Munteanu: I'd say it being interpreted as forall is still madness
13:18:49 <merijn> Random unicode characters expanding to reserved Haskell (or any language) symbols is a recipe for disaster
13:19:09 <EvanR-work> random yes
13:19:17 <EvanR-work> a small previous defined subset, maybe ;)
13:19:39 <EvanR-work> randomly gives me an idea for an esoteric language ;)
13:19:42 <Eduard_Munteanu> merijn: look at the UnicodeSyntax extension, it allows forall, -> and a few other Unicode variants of those.
13:19:55 <Eduard_Munteanu> Heh.
13:20:04 <merijn> EvanR-work: I think that's called APL?
13:20:07 <EvanR-work> lol
13:20:14 <EvanR-work> apl is deterministic
13:20:20 <EvanR-work> thats old hat now
13:20:31 <merijn> ooh
13:21:17 <merijn> EvanR-work: Well, requiring a syntax with random semantics would be silly, there's more efficient solutions to do the same
13:21:18 <EvanR-work> to emulate deterministic programming youd need to carefully compose two events which result is something with probability 1 ;)
13:21:20 <merijn> Evolutionary algorithm generating random code and you just vote on how close it is to your intended solution
13:21:56 <EvanR-work> more efficient?
13:22:05 <EvanR-work> did you miss the esoteric part
13:22:17 <merijn> That's more efficient then having to type the language by hand before executing random semantics :p
13:22:21 <aristid> effficiently esoteric
13:22:32 <merijn> Mine just skips straight to executing random semantics :p
13:22:39 <EvanR-work> please merijn, make malbolge more efficient
13:22:52 <EvanR-work> while youre at it ;)
13:23:08 <merijn> EvanR-work: Easy, "rm -rf `which malbolgec`" ;)
13:23:32 <merijn> EA can easily (for given values of easy) optimize malbolge as easy as anything else
13:24:08 <EvanR-work> ._.
13:25:05 <EvanR-work> i dont think i have ever heard a joking or other wise proposal to optimize such languages
13:25:25 <jmcarthur> EvanR-work: i kind of like the sound of your esoteric language idea
13:25:55 * Eduard_Munteanu goes study randomatic semantics :P
13:26:00 <jmcarthur> EvanR-work: although the first thing that comes to my mind is basically prolog with a *very* inefficient implementation
13:26:13 <EvanR-work> haha
13:27:29 <merijn> jmcarthur: So basically just Prolog? *duck*
13:28:28 <tonkman> im writing somewhat a simple gui program with haskell
13:28:44 <tonkman> is there an independet gui library for haskell?
13:29:24 <tonkman> by independent i mean that it doesnt require installing any platforms or else
13:29:44 <tonkman> i can see that win32 is a pain in the ass
13:30:11 <pistacchio_> hi, whay does this not work  (ghci)?  let b = [1, 2, 3, 4, 5]  ; tail b : head b (or even tail b : [head b] ) ? thanks
13:30:27 <EvanR-work> tonkman: no you must use some existing platform
13:30:41 <roconnor> pistacchio_: use ++
13:31:05 <tonkman> how about ffi?
13:31:06 <EvanR-work> be it windows, X11, gtk+, qt, tcl, fltk, SDL, linux framebuffer etc
13:31:06 <pistacchio_> roconnor: thanks :)
13:31:17 <pistacchio_> i'm just on my second hour of haskell
13:31:43 <Twey> pistacchio_: tail b :: [a]; head b :: a
13:31:48 <Eduard_Munteanu> EvanR-work: interestingly, you missed out wx, there probably was a reason :D
13:31:51 <Twey> (:) :: a -> [a] -> [a]
13:32:01 <EvanR-work> i forgot, permanently
13:32:09 <Twey> (tail b :: [a]) : (head b :: a) = error
13:32:15 * Eduard_Munteanu started disliking wx since he experienced Gtk2Hs
13:32:52 <EvanR-work> tonkman: yeah you can ffi to some existing platform
13:33:00 <EvanR-work> i meant to throw in java guis
13:33:00 <tonkman> Gtk2Hs is the second best option thus
13:34:10 <tonkman> though i remember that i had huge problems trying to install it
13:37:58 <EvanR-work> hmmmmm ... object oriented programming monad
13:39:29 <monochrom> can be just a newtype OOP a = State (Data.Map Attribute Dynamic) a
13:40:13 <aristid> monochrom: i guess a nicer way would be desirable tho
13:40:34 <monochrom> The nicest way is a dependent typing system.
13:40:58 <EvanR-work> to start an OOP computation you pick one of the basic oop operations, method lookup (at the moment lets not allowed side effects), method reassignment, object construction
13:40:59 <Eduard_Munteanu> Why would you need that for OOP?
13:41:05 <EvanR-work> thats three run functions
13:41:53 <Eduard_Munteanu> AFAICT, Haskell currently provides for everything besides encapsulation.
13:42:01 <Eduard_Munteanu> Though there is some of that too.
13:42:02 <EvanR-work> bump that formulation
13:42:12 <EvanR-work> encapsulation is a general concept not a language feature
13:42:23 * hackagebot HDBC-sqlite3 2.3.1.0 - Sqlite v3 driver for HDBC  http://hackage.haskell.org/package/HDBC-sqlite3-2.3.1.0 (JohnGoerzen)
13:43:02 <tonkman> what is the easiest way to install Gtk2Hs
13:43:30 <Eduard_Munteanu> tonkman: get GTK and use cabal install for Gtk2Hs? I'm not sure how well that fares on Windows though.
13:43:56 <Eduard_Munteanu> tonkman: though I remember GTK itself installs relatively easily on Windows.
13:44:13 <tonkman> ok, I give a try
13:44:27 <luite> yes, you have to download the binary distribution from the gtk site, unzip it somewhere, and add a directory to your path
13:44:47 <Entroacceptor> the last gtk stuff I used in windows looked ugly
13:44:58 <monoidal> > 2 :: [1]
13:44:59 <lambdabot>   No instance for (GHC.Num.Num [GHC.Generics.Unit])
13:44:59 <lambdabot>    arising from the liter...
13:45:11 <tonkman> so what library should I use if not gtk2hs?
13:45:14 <tonkman> wx?
13:45:15 <monoidal> how does this arise?
13:45:18 <Eduard_Munteanu> AFAICT, Gtk2Hs is the safest solution to go for.
13:45:35 <monoidal> can 1 be a type somehow?
13:45:46 <Eduard_Munteanu> It has reasonable documentation and reasonable functionality.
13:46:46 <monoidal> :t undefined :: 1
13:46:47 <lambdabot> Unit
13:47:22 <Eduard_Munteanu> monoidal: some term can be used both as a value and as a type name.
13:47:31 <Eduard_Munteanu> like in data declarations.
13:47:52 <monoidal> first time I see a number used as a type
13:48:00 <monoidal> apparently other numbers than 1 are illegal
13:48:10 <tonkman> I have heard about exe-hacks which compile all depencies in one executable
13:48:11 <Eduard_Munteanu> monoidal: they're probably not defined
13:48:33 <Eduard_Munteanu> tonkman: by default GHC does static linking.
13:48:45 <alkabetz> Say I define `square x = x * x'.  Now, if I run `square reallyExpensiveFunction', reallyExpensiveFunction will get run twice, right?
13:48:49 <monoidal> it seems 1 is an alias for GHC.Generics.Unit
13:48:55 <tonkman> but I still have to install GTK environment
13:49:11 <monoidal> alkabetz: only once
13:49:20 <tonkman> if I want to run my program on other computer
13:49:23 <Eduard_Munteanu> @let data Foo a = 5 a deriving Show
13:49:23 <lambdabot>   Parse error: IntTok 5
13:49:25 * hackagebot web-routes 0.23.1 - Library for maintaining correctness and composability of URLs within an application.  http://hackage.haskell.org/package/web-routes-0.23.1 (JeremyShaw)
13:49:44 <Eduard_Munteanu> > let data Foo a = 5 a deriving Show in 5 2
13:49:44 <lambdabot>   <no location info>: parse error on input `data'
13:49:50 <Eduard_Munteanu> Grr.
13:49:54 <Vanadium> How does it know not to evaluate it twice
13:50:13 <Eduard_Munteanu> Kind inference?
13:50:22 <Eduard_Munteanu> Oh.
13:50:29 <alkabetz> monoidal: Why does it only evaluate once?  Does GHC figure out that x in both calls must evaluate to the same thing?
13:50:33 <Eduard_Munteanu> You were talking about alkabetz's question.
13:50:52 <Vanadium> Sorry
13:50:54 <kmc> anyone know if MichaelNelson is in this channel?
13:50:55 <monoidal> alkabetz: a thunk for reallyExpensiveFunction is passed, when it is forced its value is used in several places
13:51:04 <EvanR-work> kmc: from MST3K ?
13:51:11 <monoidal> alkabetz: as in let x = <complicated> in x*x
13:51:14 <Vanadium> When do thunks get generated?
13:51:17 <kmc> probably not EvanR-work
13:51:28 <jmcarthur> alkabetz: it simply shares the computation. the same computation is shared everywhere it's used, and then when it's reduced (in place!) all uses benefit from that reduction
13:51:28 <kmc> a thunk is created by "let"
13:51:44 <EvanR-work> alkabetz: variables bound to an expression always have a certain value, no matter how many times you evaluate them
13:52:09 <EvanR-work> assuming it evaluates to something
13:52:11 <Eduard_Munteanu> alkabetz: you might also want to look up memoization for a more general sense.
13:52:20 <jmcarthur> alkabetz: that it, it mutates the computation from the original code into code that just returns the result
13:52:32 <Eduard_Munteanu> In this case it's trivial.
13:52:58 <kmc> alkabetz, this is the difference between "call by name" evaluation and "call by need" aka "lazy" evaluation
13:53:00 <monoidal> alkabetz: however, this doesn't work if you call functions. If you define let f x = x+5 in f 2 + f 2 then f 2 will probably be evaluated twice, unless the compiler optimizes it
13:53:16 <kmc> but the compiler is free to perform that optimization, since functions are side-effect-free
13:53:24 <Eduard_Munteanu> ... also depending on the monomorphism restriction.
13:53:26 * hackagebot web-routes-happstack 0.21.1 - Adds support for using web-routes with Happstack  http://hackage.haskell.org/package/web-routes-happstack-0.21.1 (JeremyShaw)
13:53:32 <kmc> (and if you make a function that's actually not side-effect-free, the compiler is free to break it)
13:53:37 <jmcarthur> ghc normally doesn't do that optimization though
13:53:39 <alkabetz> monoidal: So in that context I should do let a = f 2 in a + a?
13:53:48 <monoidal> alkabetz: yes
13:53:52 <kmc> that's a safe way to avoid extra work
13:54:01 <Eduard_Munteanu> jmcarthur: CSE?
13:54:02 <kmc> but so is (\x -> x + x) (f 2)
13:54:05 <jmcarthur> because introducing sharing can sometimes hurt and ghc isn't always smart enough
13:54:13 <jmcarthur> Eduard_Munteanu: Common Subexpression Elimination
13:54:26 <Eduard_Munteanu> jmcarthur: yeah, I know, I was asking if you're referring to that.
13:54:30 <jmcarthur> yes
13:54:42 <jmcarthur> Eduard_Munteanu: oh i thought i said it and you were asking what it was
13:54:45 <Eduard_Munteanu> jmcarthur: I saw the GHC manual reporting CSE, I'm unsure if it's default at some -O level, so it must do somethign.
13:54:51 <Eduard_Munteanu> Heh.
13:54:57 <jmcarthur> Eduard_Munteanu: it does do *some* but it's very conservative
13:55:11 <monoidal> :k 1
13:55:12 <lambdabot> *
13:55:15 <alkabetz> kmc: So it seems like giving the thunk a name triggers saving the forced value--correct?
13:55:27 <kmc> alkabetz, no, it works for function arguments too
13:55:35 <kmc> (except you can consider 'x' a name there)
13:55:45 <Eduard_Munteanu> jmcarthur: I suppose CSE would save the monomorphism restriction related case.
13:55:46 <kmc> (so it doesn't really contradict what you said)
13:55:50 <alkabetz> kmc: Right, okay.  Cool.
13:56:11 <Eduard_Munteanu> Or it's still computed multiple times?
13:56:13 <kmc> alkabetz, a thunk is not a Haskell concept -- it's an artifact of an implementation strategy used by popular compilers
13:56:20 <tonkman> so i always need gtk environment?
13:56:22 <jmcarthur> Eduard_Munteanu: i'm not sure what you mean by the MR related case
13:56:36 <kmc> a thunk is an object in memory, which other things can point to, and which represents an unevaluated expression
13:56:42 <jmcarthur> Eduard_Munteanu: oh n/m i see
13:56:49 <kmc> when the value of the expression is demanded, the resulting value is written over the thunk
13:56:50 <Cale> Yeah, I like the term "expression" or "term" better than "thunk".
13:56:58 <kmc> so that other stuff pointing to it does not recompute
13:56:58 <Eduard_Munteanu> jmcarthur: when you're not supplying type sigs, and some function ends up more polymorphic than necessary and it's computed multiple times.
13:57:11 <jmcarthur> Eduard_Munteanu: if you use a polymorphic value as different types i'm pretty sure it must necessarily be recomputed
13:57:11 <Cale> Even though strictly speaking, thunks only correspond to unevaluated expressions.
13:57:27 * hackagebot web-routes-hsp 0.21.1 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.21.1 (JeremyShaw)
13:57:29 * hackagebot web-routes-mtl 0.19.1 - Extends web-routes with mtl-based MonadIO / MonadTrans RouteT instances  http://hackage.haskell.org/package/web-routes-mtl-0.19.1 (JeremyShaw)
13:58:11 <jmcarthur> Eduard_Munteanu: if it's used as the same type more than once then those could be candidates for CSE (although the MR only concerns itself with top level values, iirc, so it might share those anyway)
13:58:28 * hackagebot web-routes-regular 0.18.1 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-regular-0.18.1 (JeremyShaw)
13:58:29 <kmc> it's slightly ironic that Haskell discourages mutable data at source level, but Haskell compilers rely on mutation behind the scenes to implement laziness
13:58:32 <Eduard_Munteanu> tonkman: well yes, you need GTK for Gtk2Hs.
13:58:46 <Eduard_Munteanu> jmcarthur: i see.
13:59:08 <kmc> but all high-level languages have that kind of disparity.  you make the compiler do something so you don't have to think about it
13:59:32 <alkabetz> Thanks everyone for your help; this seems a lot clearer now.
13:59:41 <jmcarthur> kmc: personally i think it's a bit overly strict to disallow mutable data, but i don't see a great semantics to allow it without getting complicated.
13:59:57 <kmc> jmcarthur, well there's plenty of mutable reference types in GHC Haskell
14:00:16 <jmcarthur> kmc: the reduction steps of the lambda calculus preserve meaning. i'm sure may data structures could have similar meaning-preserving reductions
14:00:16 <kmc> i like that data-memocombinators and MemoTrie provide efficient function memoization on top of laziness, without explicitly invoking mutation
14:00:18 <Eduard_Munteanu> I think IORef/STRef classifies as totally impure.
14:00:29 * hackagebot web-routes-th 0.20.1 - Support for deriving PathInfo using Template Haskell  http://hackage.haskell.org/package/web-routes-th-0.20.1 (JeremyShaw)
14:00:30 <jmcarthur> i'm not talking about impure data structures
14:00:37 <Eduard_Munteanu> As in "there's no nice way to turn that around into a pure computation using monads".
14:00:41 <jmcarthur> i'm talking about meaning-preserving mutation
14:01:12 <jmcarthur> we have static rewrite rules that can be used to do that, but i think it could be possible to do similar things at runtime
14:01:18 <kmc> Eduard_Munteanu, what do you mean?
14:01:28 <kmc> that you can't implement STRef in ordinary Haskell?
14:01:29 * hackagebot web-routes-transformers 0.19.1 - Extends web-routes with some transformers instances for RouteT  http://hackage.haskell.org/package/web-routes-transformers-0.19.1 (JeremyShaw)
14:01:30 <mm_freak> where do i find the 'system' function in GHC 6.8?
14:01:50 <jmcarthur> Eduard_Munteanu: copumpkin has today declared that he's going to try writing a pure ST implementation ;)
14:01:55 <Eduard_Munteanu> kmc: there's no way to rewrite the way *Refs work without compiler/FFI support.
14:01:59 <Eduard_Munteanu> kmc: is it?
14:02:17 <jmcarthur> ah yeah, you need to do impure things to create in-place mutation ;)
14:02:25 <monoidal> :t undefined :: (1 :+: 1) :*: (1 :+: 1)
14:02:26 <lambdabot> (Unit :+: Unit) :*: (Unit :+: Unit)
14:02:32 <jmcarthur> well, arbitrary mutation, at least
14:02:45 <jmcarthur> graph reduction is of course pure, but still mutation
14:02:59 <Eduard_Munteanu> kmc, jmcarthur: though if memoization could work so swell, perhaps what copumpkin tries is possible, although I'm unsure about the semantics of that.
14:03:50 <mm_freak> found it
14:03:52 <jmcarthur> i think copumpkin is just going with some sort of heterogeneous map thing or something
14:04:08 * Eduard_Munteanu hasn't seen mm_freak in a while o/
14:04:30 * hackagebot web-routes-wai 0.19.1 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.19.1 (JeremyShaw)
14:05:17 <Eduard_Munteanu> If the compiler were so smart, it could replace already pure updates with in-place updates... but it doesn't. That's what I mean.
14:05:51 <EvanR-work> Eduard_Munteanu: with zero sharing that would be easy
14:06:03 <EvanR-work> but would mean a lot more gc
14:06:12 <EvanR-work> defeating the purpose!
14:06:21 <Eduard_Munteanu> EvanR-work: yeah, I think it has to guarantee "no more references will be held to this from this point on".
14:06:22 <jmcarthur> Eduard_Munteanu: some type systems also allow that
14:06:42 <EvanR-work> Eduard_Munteanu: uniqueness types sounds like
14:06:43 <Eduard_Munteanu> I see.
14:06:44 <jmcarthur> Eduard_Munteanu: uniqueness types, linear types, etc.
14:07:05 <Eduard_Munteanu> Hm, I could go have a look at that. I think I heard about the first sort.
14:07:25 <jmcarthur> Eduard_Munteanu: ATTAPL covers linear types
14:07:30 <Eduard_Munteanu> Grr...
14:07:34 <jmcarthur> Eduard_Munteanu: the Clean language has uniqueness types
14:07:34 * Eduard_Munteanu didn't order that...
14:07:49 <Eduard_Munteanu> But then again, TAPL is still a lot of material I have to go through.
14:07:56 <Eduard_Munteanu> jmcarthur: I see.
14:08:29 <Eduard_Munteanu> jmcarthur: what about Coq? As far as I hear, the CoC should really have everything :)
14:08:39 <jmcarthur> Eduard_Munteanu: it's not quite like that
14:09:10 <jmcarthur> Eduard_Munteanu: CoC is very powerful and i'm sure you can *implement* linear types in it and then use it at the type level
14:09:21 <monoidal> anyone know about the 1 type? is it just an alias to GHC.Generics.Unit?
14:09:24 <jmcarthur> but that's different from having linear types or uniqueness types built in
14:09:26 <Eduard_Munteanu> Ah, but it's not there as a language feature.
14:09:31 <jmcarthur> right
14:09:41 <dreixel> monoidal: yes
14:09:49 <dreixel> as far I understand it, at least
14:09:59 <monoidal> thanks
14:10:18 <Eduard_Munteanu> jmcarthur: any way, pondering about what language I should approach next if I decide to do so, Coq really seems the most extreme type-theory-wise.
14:10:21 <dreixel> should remember to remove that too
14:11:18 <Eduard_Munteanu> I think Agda is not CoC.
14:11:18 <jmcarthur> Eduard_Munteanu: Coq isn't very much like most programming languages since it's designed as a proof assistant. i personally prefer Agda to it since it fits my programmer mentality. Agda and Coq have quite different theories though
14:11:27 <Eduard_Munteanu> Not sure where Martin-Lof stands on that.
14:11:27 <jmcarthur> Eduard_Munteanu: yeah, Agda is just dependent types
14:11:33 <Eduard_Munteanu> I see.
14:12:04 <roconnor> I don't get this
14:12:17 <Eduard_Munteanu> jmcarthur: there is some info on writing programs in Coq though. Lots of denotational semantics last time I went through a tutorial. And they acknowledged it's not really easy to write programs, but possible.
14:12:21 <roconnor> Coq and Adga term langauage are almost the same
14:12:36 <jmcarthur> Eduard_Munteanu: yes, you can do real programming in Coq
14:12:36 <roconnor> Plus Coq has an interactive thereom prover, and Agda doesn't.
14:12:49 <roconnor> I don't quite understand why people gravitate to Agda.
14:13:06 <jmcarthur> maybe it's syntax, roconnor 
14:13:07 <Eduard_Munteanu> roconnor: perhaps it's meant as more of a programming language?
14:13:11 <roconnor> That being said, Agda handles dependent matching in a much better way than Coq
14:13:25 <roconnor> so if you want to do depenent programming, then Agda is easier.
14:13:26 <jmcarthur> and yes, my main reason is because i like actually programming in Agda more than in Coq
14:13:32 <roconnor> which probably explains it.
14:14:17 <Eduard_Munteanu> Agda also binds nicely to Haskell code, IIRC.
14:14:28 <roconnor> Still, you can only go so far in Agda without a interactive proof assistant.
14:14:42 <roconnor> though it is unclear how far that far is.
14:14:48 <roconnor> it could be pretty far
14:15:59 <raceRider> what's an easy way to find which package provides what import module. Say I see import Control.Monad.State, how can I quickly find which package provides that module? Module names and package names on hackage don't seem to map easily. 
14:16:21 <Eduard_Munteanu> @hoogle Control.Monad.State
14:16:22 <lambdabot> module Control.Monad.State
14:16:22 <lambdabot> Control.Monad.State.Lazy newtype State s a
14:16:22 <lambdabot> Control.Monad.State.Lazy State :: (s -> (a, s)) -> State s a
14:16:37 <Eduard_Munteanu> Grr.
14:16:45 <Eduard_Munteanu> Maybe you can try Hoogle.
14:16:49 <Eduard_Munteanu> @where hoogle
14:16:50 <lambdabot> http://haskell.org/hoogle
14:17:09 <raceRider> to get the package name so I can install using cabal, right/ 
14:17:41 <roconnor> are there co applicative functors?
14:17:57 <Eduard_Munteanu> roconnor: Copointed is about there.
14:18:10 <Eduard_Munteanu> roconnor: from category-extras
14:18:16 <roconnor> Then we need a co-ap
14:18:58 <Eduard_Munteanu> raceRider: hm, I'm not that sure what hoogle indexes, perhaps you can have a try there.
14:19:07 <Veinor> you can also check hayoo
14:19:40 <Eduard_Munteanu> Ah, that too.
14:20:27 <raceRider> Eduard_Munteanu: thanks, that's what I've been doing but I was wondering if there was an easier way to map import statements to specific packages. Either through cabal or any other command line utility.
14:20:46 <monoidal> roconnor: f (a,b) -> (f a, f b)?
14:21:20 <roconnor> monoidal: that's a good comonoidal 
14:21:24 <Eduard_Munteanu> raceRider: ah, I don't know about that.
14:21:51 <raceRider> Eduard_Munteanu: thanks anyway
14:21:55 <monoidal> roconnor: is it equivalent to coapplicative?
14:22:06 <roconnor> monoidal: probably, though I don't know what coapplicative is
14:22:18 <Eduard_Munteanu> @src Applicative
14:22:18 <lambdabot> class Functor f => Applicative f where
14:22:18 <lambdabot>     pure  :: a -> f a
14:22:19 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:22:21 <monoidal> me neither
14:22:32 <Eduard_Munteanu> extract would be copure
14:22:36 <roconnor> but certainly having (f a, f b) -> f (a,b) is all you need for applicative.
14:22:39 <Eduard_Munteanu> for comonads.
14:22:46 <Eduard_Munteanu> So it makes sense to just flip arrows.
14:23:13 <monoidal> :t map fst *** map snd
14:23:13 <lambdabot> forall a b a1 b1. ([(a, b)], [(a1, b1)]) -> ([a], [b1])
14:23:18 <monoidal> :t fmap fst *** fmap snd
14:23:19 <lambdabot> forall a b (f :: * -> *) a1 b1 (f1 :: * -> *). (Functor f, Functor f1) => (f (a, b), f1 (a1, b1)) -> (f a, f1 b1)
14:23:25 <monoidal> :t fmap fst &&& fmap snd
14:23:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a, b) -> (f a, f b)
14:23:35 <roconnor> monoidal: streams (as a comonad) have that function
14:23:43 <roconnor> monoidal: presumaly we can write that for all comonads?
14:23:54 <monoidal> for all functors
14:24:25 <Eduard_Munteanu> I guess it's still a functor application in some sense.
14:24:37 <monoidal> roconnor: do you think about another implementation than fmap fst &&& fmap snd?
14:24:44 <roconnor> cobind (\(fa, fb) -> (extract a, extract b))
14:24:52 <roconnor> cobind (\(fa, fb) -> (extract fa, extract fb))
14:25:33 <Eduard_Munteanu> @src Copointed
14:25:33 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:25:37 <Eduard_Munteanu> Gr.
14:25:51 <Eduard_Munteanu> class Functor f => Copointed f where extract :: f a -> a
14:26:21 <Eduard_Munteanu> It's a bit different than how standard stuff does it.
14:38:00 <jmcarthur> roconnor: on how far you can go with Agda relative to Coq: Coq can probably go farther, but you also pay for the extra complexity, even with the nicer proof facilities that Coq has
14:38:15 <jmcarthur> the extra complexity of going farther i mean
14:38:16 <roconnor> jmcarthur: what extra complexity?
14:38:28 <jmcarthur> i don't mean Coq compared to Agda for the same problem
14:38:48 <jmcarthur> Agda, as I see it, is a more conservative language than Coq
14:39:05 <pistacchio_> is there a "random" like function in haskell's standard library?
14:39:39 <EvanR-work> pistacchio_: randomIO
14:39:51 <jmcarthur> System.Random
14:40:04 <pistacchio_> thanks :)
14:40:09 <jmcarthur> or just Random if you are stuck with haskell 98 o_O
14:40:31 <jmcarthur> actually, i'm never going to talk about haskell 98 again
14:40:46 * Eduard_Munteanu how much actual legacy Haskell98 stuff is out there given Haskell's popularity.
14:40:54 <Eduard_Munteanu> *wonders
14:41:15 <roconnor> jmcarthur: I don't understand
14:41:29 <roconnor> jmcarthur: you can write terms in Coq almost as easily as you can write terms in Coq
14:41:34 <roconnor> jmcarthur: you can write terms in Coq almost as easily as you can write terms in Agda
14:42:18 <jmcarthur> roconnor: that's not what i was trying to reture
14:42:22 <jmcarthur> *refute
14:42:57 <jmcarthur> roconnor: you were talking about how far you could go in each language. may argument was basically that many people aren't interested in that
14:43:00 <jmcarthur> *my
14:44:26 <jmcarthur> roconnor: i sometimes see Agda as a continuation of the Haskell journey into dependently typed land. i don't really see it as an attempt to subsume all other theories or something. on the other hand, i kind of approach Coq as an attempt to tackle more difficult things
14:44:55 <jmcarthur> like, well, complicated proofs
14:45:24 <ccasin> jmcarthur: I think they are more alike than you suspect!  Their underlying theories are really really similar.  It's just that agda has better facilities for standard programming tasks and coq has better stuff for standard proving tasks
14:45:38 <jmcarthur> ccasin: i agree
14:45:56 <jmcarthur> ccasin: i'm just saying that if your goal is standard programming then agda may be a better fit
14:46:23 <jmcarthur> ccasin: as that seems to be the point that roconnor was differing with me on
14:46:50 <ccasin> Well, it's getting better in coq, thanks to mattam.  But I think if your goal is practical programming you are hosed in either case :)
14:46:56 <ccasin> we'll get there though
14:47:03 <jmcarthur> ccasin: to stretch that journey metaphor a bit, coq and agda walk together a lot
14:47:19 <jmcarthur> but that doesn't mean they have the same destination
14:47:21 <copumpkin> jmcarthur: I'm trying it with noimplicitprelude, but had a talk to go to and now have to go to dinner!
14:47:26 <copumpkin> with any luck it'll work when I get back
14:47:32 <jmcarthur> copumpkin: ah!
14:47:43 <jmcarthur> oh you're after do notation
14:48:00 <copumpkin> damn right
14:48:19 <Eduard_Munteanu> Is there any real application done in a total language like that?
14:48:29 <roconnor> jmcarthur: I think that when doing dependent programming eventually you need to do sophisticated proofs, and you will want a proof mode for that.
14:48:33 <ccasin> jmcarthur: maybe so.  But since the underlying core language are the same (in principle), it's my hope we can end up with one language that reaches both destinations!  That's basically the focus of 75% of the current work in dependently-typed programming
14:48:34 <jmcarthur> Eduard_Munteanu: well, agda isn't strictly total
14:48:40 <roconnor> jmcarthur: Agda as it is is only good for toy problems.
14:48:44 <Eduard_Munteanu> Oh.
14:48:46 <roconnor> I think.
14:49:00 <lispy1> hey
14:49:06 <jmcarthur> roconnor: i think if you write haskell in agda you can get similar levels of productivity as you get in haskell
14:49:26 <roconnor> jmcarthur: true, but none of the advantages of dependent types
14:49:32 <ccasin> wait
14:49:34 <ccasin> no way!
14:49:50 <roconnor> jmcarthur: and writing Haskell in Coq is just as easy as writing Haskell in Agda
14:49:51 <jmcarthur> roconnor: you can then cherry pick little places to use dependent types with fairly minimal extra effort though
14:50:00 <ccasin> the termination checker and the lack of libraries definitely prevent writing haskell-ish stuff in agda with ease
14:50:06 <roconnor> jmcarthur: yep, that is true
14:50:08 <jmcarthur> roconnor: well, binding to haskell is a bit more involved in coq though, isn't it?
14:50:25 <jmcarthur> ccasin: agda's termination checker is optional
14:50:28 <roconnor> jmcarthur: proving correct the XMonad stacks could done nicely in Agda I think
14:50:33 <lispy1> ccasin: you can just turn off the termination checker ;)
14:50:35 <jmcarthur> ccasin: and it's easy to bind to haskell libs ;)
14:50:40 <Eduard_Munteanu> jmcarthur: that's what you meant by "not strictly total"?
14:50:48 <Eduard_Munteanu> Optional checking?
14:50:52 * hackagebot yuuko 2010.11.5 - A transcendental HTML parser gently wrapping the HXT library  http://hackage.haskell.org/package/yuuko-2010.11.5 (JinjingWang)
14:50:53 <Eduard_Munteanu> *termination checking
14:50:56 <roconnor> jmcarthur: there is a haskell export in Coq, and you can bind abstract functions to other things.
14:50:57 <jmcarthur> Eduard_Munteanu: right. you can even turn the termination checker off for only specific modules
14:51:05 <ccasin> jmcarthur, lispy1: sure, but if you're going to turn off the termination checker, why not just write in haskell? :)
14:51:18 <roconnor> jmcarthur: I haven't used Agda's Haskell export so I can't really make an informed comment.
14:51:22 <jmcarthur> ccasin: the idea is to turn it off for only specific parts of the program
14:51:24 <Eduard_Munteanu> jmcarthur: that's really nice.
14:51:44 <lispy1> Does Coq reason about _|_ correctly?
14:51:49 <roconnor> jmcarthur: does Agda's export mechinism remove proof irrelevent terms?
14:51:50 <jmcarthur> Eduard_Munteanu: also, codata alleviates a lot of the perceived difficulties with total languages
14:51:59 <roconnor> lispy1: Coq has no bottoms
14:52:01 <lispy1> I know this is an important feature of HOLCF (Isabelle)
14:52:02 <jmcarthur> roconnor: not yet, afaik
14:52:10 <jmcarthur> roconnor: but i think it's an area of research
14:52:21 <jmcarthur> roconnor: agda of course doesn't have the Prop Set distinction
14:52:35 <roconnor> jmcarthur: oh yes, braddy?'s extraction is good.  It just needs to be implemented in Agda.
14:52:38 <Eduard_Munteanu> jmcarthur: yeah, though I'm yet to put my finger on what that means exactly.
14:52:39 <lispy1> roconnor: Well, if you extract Haskell code from Coq then bottoms become of interest in the interaction between your "correct" extracted code and your other haskell
14:53:02 <roconnor> lispy1: I dont' care about bottoms in Haskell either. :P
14:53:38 <roconnor> lispy1: but you point is well taken
14:53:44 <jmcarthur> personally i want a language with partiality in the type system
14:53:48 <Eduard_Munteanu> I suppose it's analogous to coinduction, but I'm not yet initiated in that sort of stuff.
14:53:57 <lispy1> jmcarthur: the partiality monad?
14:54:02 <roconnor> it is unclear how extracted code will behave when passed bottoms other than what monotonicity will imply
14:54:02 <jmcarthur> lispy1: that's one way
14:54:27 <roconnor> jmcarthur: why do you want partiality?
14:54:51 <Eduard_Munteanu> Turing-completeness?
14:55:06 <jmcarthur> Turing completeness is not such a great goal, Eduard_Munteanu ;)
14:55:37 <jmcarthur> roconnor: because partiality side-steps this whole issue of what's expressible and what isn't, mainly
14:55:39 <Eduard_Munteanu> jmcarthur: well it is for just about any Haskell program that uses 'forever' for example.
14:55:58 <jmcarthur> roconnor: i agree that a total language can go amazingly far though
14:56:02 <Eduard_Munteanu> I think you do need to do that for some applications.
14:56:26 <jmcarthur> Eduard_Munteanu: Turing completeness is probably not required to express those same programs though
14:56:27 <roconnor> jmcarthur: do you think expresibility is important?
14:57:15 <roconnor> I mean, Coq/Agda is more than adequate to create super-exponential functions.
14:58:15 <erg0t> is there any function that if I have a list of lists like: [[1,2,3],[1,2]] it makes a new list [1,2,3,1,2]?
14:58:24 <HaskellElephant> concat ...
14:58:24 <Eduard_Munteanu> :t concat
14:58:25 <lambdabot> forall a. [[a]] -> [a]
14:58:30 <erg0t> thanks
14:59:29 <ricree> if I'm getting a "The last statement in a 'do' construct must be an expression" error, is there any easy way to see what it thinks is the last line of the do block?
14:59:34 <EvanR-work> fibs \ primes
14:59:37 <EvanR-work> discuss
15:00:04 <benmachine> http://hpaste.org/paste/41150/error#p41151 I missed out a do here and GHC came up with the least helpful error ever, can anyone work out what parse it tried that lead it to believe case was a pattern?
15:00:13 <Eduard_Munteanu> ricree: you're probably doing something like 'a <- foo' in that last line.
15:00:21 <benmachine> (in my actual code it was not even the first alternative, it was like seven lines later)
15:00:29 <kmc> is there a package for decoding GHC's 'z'-mangling?
15:00:30 <benmachine> ricree: your indentation might be iffy
15:00:41 <benmachine> kmc: it's fairly straightforward
15:01:08 <ricree> Eduard_Munteanu: I definitely am not in what I think is the last line, which is why I'm trying to figure out a way to get more information on what it thinks is the last line
15:01:32 <benmachine> kmc: I know this isn't what you asked for, but http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/SymbolNames in case you didn't know
15:01:34 <ricree> benmachine:  Probably, though I haven't had any luck figuring out where yet
15:01:50 <benmachine> ricree: hmm, doesn't it tell you the line number in that error?
15:01:57 <benmachine> in which case presumably it'd be the statement on that line
15:02:06 <benmachine> ricree: or you could hpaste the code and we could tell you :)
15:02:14 <jmcarthur> roconnor: the issue to me is that termination checkers aren't perfect. reasonable ones are overly strict
15:02:25 <Eduard_Munteanu> Not if it says something like 'error in ... do expression at line'
15:02:36 <benmachine> jmcarthur: you mean termination checkers can't check if every program terminates? :O
15:02:49 <Eduard_Munteanu> overly _strict_
15:03:07 <Eduard_Munteanu> Oh.
15:03:16 <Eduard_Munteanu> Crap, I get the idea.
15:03:20 <benmachine> <_<
15:03:24 * benmachine lame halting problem joke
15:03:39 <Eduard_Munteanu> Yeah, not lame, but my mind was wandering.
15:03:58 <HaskellElephant> Here is ta funny game that me and some buddies where playing lately given one or more functions, a time limit, using those functions, parenthesis and (.), make the longest function that is equal to identity. Anyone play any other good Haskell car games?
15:04:08 <kmc> ok, i can use GHC API directly benmachine
15:04:08 <kmc> cool
15:04:24 <ricree> benmachine:  http://hpaste.org/41152/do_last_statement
15:04:28 <Eduard_Munteanu> HaskellElephant: lol
15:04:35 <EvanR-work> in the car?
15:04:46 <EvanR-work> im not that good :S
15:04:52 <benmachine> ricree: it might be that the statements of the do need to be indented more than the let
15:05:09 <benmachine> HaskellElephant: presumably you can't use a function more than once? >_>
15:05:12 <jmcarthur> roconnor: partiality at the type level means you can continue using the termination checker most of the time, but if you hit a problem with it you can just make a partial function without fear of using it improperly (e.g. in a proof term, if you are against undecidable type checking)
15:05:14 <HaskellElephant> We bring paper on car trips (god we are nerdy).
15:05:14 <benmachine> > fix ("id . " ++)
15:05:15 <lambdabot>   "id . id . id . id . id . id . id . id . id . id . id . id . id . id . id ....
15:05:24 <aristid> HaskellElephant: the longest? that's easy, find some function like that and repeat it an arbitrary number of times (connecting them with (.))
15:05:50 <HaskellElephant> benchmachine, no, but no repeat ...
15:05:54 <EvanR-work> whats the biggest number greater than 4
15:06:02 <jmcarthur> aristid: for added complexity you have to compare sizes after gzip
15:06:05 <jmcarthur> :)
15:06:06 <EvanR-work> haha, 'no fair repeats'
15:06:17 <aristid> > intersperse " . " $ replicate 5 "id"
15:06:18 <lambdabot>   ["id"," . ","id"," . ","id"," . ","id"," . ","id"]
15:06:28 <EvanR-work> jmcarthur: gzip on an infinite cycle works? xD
15:06:28 <aristid> > intercalate " . " $ replicate 5 "id"
15:06:29 <lambdabot>   "id . id . id . id . id"
15:06:30 <HaskellElephant> so if you find two, then you can just add them to eachother
15:06:36 <EvanR-work> probably not
15:06:42 <jmcarthur> EvanR-work: if it's infinite does the program terminate?
15:06:43 <fengshaun> :t id
15:06:44 <lambdabot> forall a. a -> a
15:06:45 <benmachine> :t fmap fix pure
15:06:46 <lambdabot> forall a. a -> a
15:06:51 <aristid> jmcarthur: if you repeat often enough, that does not metter
15:06:54 <jmcarthur> EvanR-work: and if it doesn't terminate is it really id?
15:06:56 <HaskellElephant> we usually use functions that are kinda hard, feks concatMap and : ...
15:06:58 <fengshaun> > id
15:06:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
15:07:00 <lambdabot>    arising from a use of `...
15:07:12 <EvanR-work> jmcarthur: if it was given information about where it repeats, the decompressor could lazily produce the results
15:07:14 <kmc> so GHC's codebase doesn't use hierarchical modules so much
15:07:21 <kmc> does that mean i'm stuck with their flat module names when i use GHC API?
15:07:25 <jmcarthur> EvanR-work: i'm talking about using the program after decompression
15:07:41 <benmachine> jmcarthur: just need a compiler capable of applying rewrite rules infinitely often
15:07:43 <EvanR-work> then would gzip approach a limit?
15:07:44 <jmcarthur> EvanR-work: if the spec is id then that means feeding it something that's not bottom should not result in bottom
15:07:58 <roconnor> jmcarthur: ah, that is fair.  Proving termination is a pain
15:08:00 <aristid> kmc: no. you can simply change GHC :)
15:08:01 <EvanR-work> i think it would be like ln
15:08:05 <jmcarthur> > fix id 5   -- will this terminate, EvanR-work?
15:08:09 <lambdabot>   mueval-core: Time limit exceeded
15:08:21 <EvanR-work> make it a finite iteration of (.)
15:08:24 <monochrom> fix id doesn't end well
15:08:26 <jmcarthur> > fix (id .) 5   -- will this terminate, EvanR-work?
15:08:29 <EvanR-work> the gzip would grow like sum of 1/n
15:08:30 <lambdabot>   mueval-core: Time limit exceeded
15:08:39 <EvanR-work> just guessing
15:08:52 <benmachine> I'd imagine it would grow linearly
15:08:55 <benmachine> but very slowly
15:09:02 <benmachine> wait no
15:09:05 <benmachine> logally
15:09:13 <Eduard_Munteanu> fix gzip ?
15:09:21 <monochrom> > fix (const id) 5
15:09:22 <lambdabot>   5
15:09:26 <EvanR-work> more like break gzip
15:09:30 <Eduard_Munteanu> :)
15:09:39 <kmc> aristid, of course, why didn't i think of that, it's so easy
15:09:46 <monochrom> I think someone found a fixed point of gzip.
15:09:54 <Eduard_Munteanu> I'm not convinced it grows without bound.
15:09:55 <aristid> kmc: that's because you didn't think rigorously enough
15:09:58 <jmcarthur> i think the fixpoint of a compression algorithm would grow logarithmically for most inputs
15:10:05 <EvanR-work> Eduard_Munteanu: its got to
15:10:18 <EvanR-work> it at least needs to store how many repetitions there are
15:10:24 <jmcarthur> EvanR-work: exactly
15:10:28 <dolio> monochrom: Yes.
15:10:30 <Eduard_Munteanu> EvanR-work: entropically that adds nothing.
15:10:44 <EvanR-work> i dont know who suggested iterating gzip
15:10:50 <jmcarthur> EvanR-work: and the representation of that number grows logarithmically :)
15:10:53 <EvanR-work> but i was just talking about gzipping an arbitrarily long cycle
15:11:03 <EvanR-work> jmcarthur: in place value!
15:11:09 <EvanR-work> use a better way
15:11:13 <jmcarthur> EvanR-work: huh?
15:11:21 <Eduard_Munteanu> So I'm not excluding it just goes through lots of unrepeating results without actually growing beyond a constant.
15:11:26 <EvanR-work> use a sublog representation for numbers
15:11:57 <jmcarthur> EvanR-work: like what?
15:12:07 <pistacchio> i'm following the ebook "learn you a haskell" while i stuck to this problem : http://hpaste.org/41154/learn_you_a_haskell_problem
15:12:18 <pistacchio> can anyone check it out, plz?
15:12:24 <EvanR-work> jmcarthur: funny
15:12:30 <Eduard_Munteanu> That doesn't mean it has a fixed point though.
15:12:34 <EvanR-work> i think its impossible
15:12:45 <jmcarthur> EvanR-work: i do too, without proof
15:12:58 <EvanR-work> but would be cool if it werent!
15:13:17 <jmcarthur> EvanR-work: i thought that would basically allow you to compress random data arbitrarily
15:13:31 <EvanR-work> well that works if you have an unlimited alphabet ;)
15:13:34 <jmcarthur> s/thought/think/
15:13:38 <EvanR-work> such as... N
15:13:59 <Eduard_Munteanu> Could be either way, it's just I'm unconvinced.
15:14:07 <monochrom> pistacchio: I get no error when I try it.
15:14:19 <kmc> pistacchio, which line is line 23?
15:14:28 <EvanR-work> maybe its a continuum hypothesis like thing, you can only have infinite alphabet or logarithmic growth, nothing in between
15:14:32 <kmc> pistacchio, are you using tab characters in your file?
15:14:42 <arcatan> pistacchio: you might have an indentation problem - be sure that (f:_) and (l:_) are indented to the same column
15:14:47 <Eduard_Munteanu> EvanR-work: though some experiment should be able to easily demonstrate monotonicity, or the lack of it.
15:15:01 <EvanR-work> Eduard_Munteanu: are you still on fix gzip
15:15:08 <EvanR-work> that was monochrom 
15:15:19 <jmcarthur> Eduard_Munteanu: gzip does have a known fixpoint
15:15:19 <EvanR-work> or iterate gzip
15:15:22 <maurer_> pistacchio: Copy pasting that code runs fo rme.
15:15:23 <Eduard_Munteanu> Yeah.
15:15:26 <Eduard_Munteanu> jmcarthur: oh.
15:15:34 <pistacchio> arcatan: it was an indentation problem, indeed, tabs vs spaces, thanks
15:15:34 <ricree> benmachine: the problem turned out to be the missing let in the middle of the do block.  The assignment was being treated as part of the upper let, which ended the do block.  Thank you for the help.
15:15:43 <benmachine> ricree: oh right
15:15:46 <benmachine> well
15:15:56 <benmachine> I'm off again, have fun guys
15:15:59 <Eduard_Munteanu> EvanR-work, jmcarthur, technically I'm talking about gzip (gzip (gzip ...
15:16:17 <EvanR-work> :t iterate
15:16:18 <lambdabot> forall a. (a -> a) -> a -> [a]
15:16:27 <jmcarthur> Eduard_Munteanu: right
15:16:57 <EvanR-work> > iterate sqrt 16
15:16:58 <lambdabot>   [16.0,4.0,2.0,1.4142135623730951,1.189207115002721,1.0905077326652577,1.044...
15:17:05 <EvanR-work> > limit (iterate sqrt 16)
15:17:06 <lambdabot>   Not in scope: `limit'
15:17:13 <Eduard_Munteanu> limit?
15:17:14 <EvanR-work> 1
15:17:18 <Eduard_Munteanu> Oh.
15:17:27 <EvanR-work> haskell is not Mathematica ;)
15:17:35 <jmcarthur> Eduard_Munteanu: http://www.maximumcompression.com/selfgz.gz
15:18:08 <jmcarthur> Eduard_Munteanu: you can decompress that as many times as you want, but you'll always get the same thing :)
15:18:29 <jmcarthur> hmm... i'm less certain about compressing it though
15:18:31 <Eduard_Munteanu> jmcarthur: grr... I'm unsure, would any repeated application of gzip converge to that fixed point? I'm rather concerned about the iterate problem.
15:18:42 <jmcarthur> Eduard_Munteanu: yeah i'm not as certain about that
15:18:47 <EvanR-work> jmcarthur: the filename should be self.gz.gz.gz.gz.gz... ;)
15:18:53 <Eduard_Munteanu> Heh.
15:18:55 <jmcarthur> EvanR-work: but then it wouldn't be a fixpoint ;)
15:19:04 <monochrom> not all fixed points can be solved by mere iteration
15:19:19 <johnzorn> Any ubuntu users here? is the best way to install the haskell platform by installing the ubuntu cabal package and then using cabal to install the rest?
15:19:59 <Eduard_Munteanu> That makes sense, only in Haskell is the iterative definition more common, or that's where I've first seen it.
15:20:31 <Eduard_Munteanu> fix finds the least defined fixpoint IIRC.
15:20:37 <monochrom> I use ubuntu. I don't use any of the ubuntu packages for haskell. It is best for me. Not sure if it is best for you.
15:21:18 <monochrom> Upload your brain somewhere and I can analyze it for 1.5 years and then tell you what is best. :)
15:21:37 <johnzorn> monochrom, how come u dont use the ubuntu packages?
15:21:38 <HaskellElephant> monochrom: I think that can be arranged :D
15:21:45 <jmcarthur> whenever i use ubuntu i don't use the ubuntu haskell packages
15:22:01 <monochrom> lag and omissions
15:22:14 <Eduard_Munteanu> I then suppose you erase and re-cabalize everything now and then?
15:22:20 <Eduard_Munteanu> *erase ~/.cabal
15:22:21 <monochrom> OTOH I do use ubuntu packages for everything else.
15:22:53 <monochrom> for example I don't mind firefox or thunderbird or xchat lagging a bit.
15:22:54 <johnzorn> from doing searches and reading forums it seems to be a good idea to avoid the ubuntu packages
15:23:02 <Eduard_Munteanu> AFAICT, cabal install doesn't really work well with upgrades
15:23:15 <johnzorn> monochrom, u have 32 or 64bit ubuntu?
15:23:26 <jmcarthur> Eduard_Munteanu: that's not been my experience
15:23:27 <monochrom> I even use ubuntu packages for coq and proof-general
15:23:33 <monochrom> 32bit
15:23:37 <jmcarthur> Eduard_Munteanu: you just shouldn't upgrade ghc packages with cabal-install, that's all
15:23:44 <Eduard_Munteanu> jmcarthur: hm I might be repeating too much what ivanm said
15:23:46 <monochrom> and yes proof-general is awesome!
15:24:21 <EvanR-work> jmcarthur: what about compressing?
15:24:32 <monochrom> erasing ~/.cabal is insufficient and unnecessary. ghc's metadata not even there.
15:25:10 <jmcarthur> EvanR-work: the gzip file i pasted a link too is a fixpoint for decompressing, but not for compressing (at least with my default gzip settings)
15:25:49 <monochrom> ghc keeps its own metadata about what libs are installed where. cabal does not. cabal begs ghc for getting and setting that metadata every time. ~/.cabal is worth nothing on this.
15:26:07 <sciolizer> @hoogle CBool
15:26:07 <lambdabot> No results found
15:26:14 <Eduard_Munteanu> monochrom: grr... where's the user-local metadata then?
15:26:24 <alex404__> Why doesn't 'map $ fun $ xs' work?
15:26:27 <monochrom> ~/.ghc
15:26:36 <Eduard_Munteanu> I see.
15:27:01 <Eduard_Munteanu> alex404__: because it's map (fun xs)?
15:27:10 <monoidal> alex404__: it is map (fun xs) instead of map fun xs = (map fun) xs
15:27:28 <monoidal> alex404__: you can also write map fun $ xs
15:28:01 <alex404__> monochrom: Right... But if 'fun' has a few arguments that I need to evaluate first, there's no snytax I can use besides ()?
15:28:14 <monochrom> you mean monoidal
15:28:31 <monochrom> you should just not cite nicknames at all.
15:28:47 <Eduard_Munteanu> '()' is better style for that IMHO
15:29:14 <alex404__> Fair enough... I suppose brackets have there place sometimes...
15:29:19 <monoidal> alex404__: there isn't; you might use <$> from Control.Applicative
15:29:32 <alex404__> monochrom: Ahh, that's a good point
15:29:40 <jmcarthur> IMO it would be better if ($) was left associative
15:30:00 <Eduard_Munteanu> Hrm... why not cite nicknames?
15:30:02 <jmcarthur> then alex404__'s version would work, and we wouldn't lose any expressivity when combined with (.)
15:30:17 <alex404__> Indeed...
15:30:37 <Eduard_Munteanu> It makes sense when ambiguous, or when others are dealing with multiple tasks at once.
15:31:19 <monochrom> neither holds now.
15:31:37 <Eduard_Munteanu> Fair enough.
15:31:44 <alex404__> jmcarthur: Would it be possible to even right a ($) which is left associative?
15:31:53 <jmcarthur> yeah
15:31:57 <monochrom> as you have just seen, factoring in mistakes, citing nicknames is more ambiguous, not less.
15:32:16 <jmcarthur> alex404__: f $ x = f x ; infixl $ 9    -- at least, i think that's the right syntax
15:32:45 <alex404__> @source ($)
15:32:46 <lambdabot> ($) not available
15:32:51 <jmcarthur> i always get confused on the precedence declaration syntax
15:32:54 <jmcarthur> @src ($)
15:32:55 <lambdabot> f $ x = f x
15:33:14 <alex404__> Oh, infixl is the difference
15:33:14 <jmcarthur> and also what direction the numbers go in
15:33:40 <monoidal> @info ($)
15:33:40 <lambdabot> ($)
15:33:57 <monochrom> I always ask ghci ":info * +" to remind me what the numbers mean.
15:34:00 <alex404__> I didn't even know you could do that... I thought haskell was *always* right associative...
15:34:20 <Eduard_Munteanu> Nope.
15:34:25 <monoidal> > 1 - 1 - 1
15:34:26 <lambdabot>   -1
15:35:11 <alex404__> So 1 - (1 - 1) vs (1 - 1) - 1
15:35:12 <alex404__> Huh
15:35:14 <alex404__> Neat
15:35:27 <alex404__> I still find it very difficult to even conceptualize realize brackets
15:35:55 <monoidal> there's also "infix", which doesn't allow left or right associativity
15:36:10 <alex404__> Associativity to me is always 'yah whatever there's only one reasonable way to do things...'
15:36:12 <monoidal> > 2 `elem` [3] `elem` [True]
15:36:12 <lambdabot>   Precedence parsing error
15:36:12 <lambdabot>      cannot mix `GHC.List.elem' [infix 4] and `GHC...
15:36:17 <monoidal> > (2 `elem` [3]) `elem` [True]
15:36:18 <lambdabot>   False
15:37:26 <monochrom> people haven't even agreed on what's the one only reasonable answer to 0^0.
15:37:36 <kmc> my policy is, never look up associativity
15:37:47 <kmc> because if it's not obvious while writing it, it won't be obvious while reading
15:38:08 <Eduard_Munteanu> My policy is trial and error.
15:38:13 <alex404__> kmc: I think that's how my brain deals with it as well
15:39:17 <alex404__> So what's the logic behind (-) being left associative? Neither seems obvious to me, actually.
15:39:41 <Eduard_Munteanu> alex404__: that's how it is in maths too.
15:39:44 <monoidal> it's usual everywhere, x - y - z is always meant as (x-y)-z
15:40:02 <alex404__> Yah... I guess I've just never thought about it first
15:40:06 <alex404__> *before
15:40:07 <monoidal> it can be thought as x + (-y) + (-z)
15:40:35 <alex404__> That's the way I break it down... I've just never realized that implies left associativity, I guess
15:41:09 <monoidal> i always think of a long expression x+y-z+t-u-v+w as a single sum of x,y,-z,t,-u,-v,w
15:41:26 <alex404__> Indeed
15:41:46 <alex404__> Strictly speaking, it is
15:42:07 <Eduard_Munteanu> Not in Haskell unfortunately.
15:42:34 <Eduard_Munteanu> Num (+) could've been a group.
15:43:06 <alex404__> monochrom: In your elem example above, can I imagine 'infix' meaning that you put brackets around both sides of the equation, which doesn't make sense when you have the two `elems`?
15:43:18 <monoidal> it's me
15:43:25 <Eduard_Munteanu> :))
15:43:38 <alex404__> err
15:43:50 <Eduard_Munteanu> Dang tab completion.
15:44:03 <alex404__> monoidal: : In your elem example above, can I imagine 'infix' meaning that you put brackets around both sides of the equation, which doesn't make sense when you have the two `elems`?
15:44:05 <alex404__> There we go
15:44:41 <monoidal> alex404__: "infix" means that you cannot use operator as in x+y+z
15:44:56 <alex404__> monoidal: Fair enough
15:45:25 <monoidal> alex404__: sometimes you can put brackets in two ways and get different results. For (-) it is left associative. For (**) it is right assoc.
15:45:44 <monoidal> > 3 ** 3 ** 3
15:45:44 <lambdabot>   7.625597484987e12
15:45:47 <monoidal> > (3 ** 3) ** 3
15:45:48 <lambdabot>   19683.0
15:46:02 <alex404__> Is there a chance that haskell will ever move to a more theoretically founded prelude?
15:46:11 <alex404__> With rings and groups and so on?
15:46:22 <monochrom> 0 chance
15:46:25 <Eduard_Munteanu> People are already complaining about the word 'monoid'
15:46:45 <alex404__> That's silly
15:46:49 <Eduard_Munteanu> Though alternate preludes exist.
15:47:07 <alex404__> The only thing people need to know about rings and groups is that their associated with (+) and (*)
15:47:23 <stepcut> aleander: http://hackage.haskell.org/package/numeric-prelude ?
15:47:26 <Eduard_Munteanu> It's high school math here.
15:47:37 <kmc> alex404__, i think there's a chance; the first step would be for some alternate prelude package to become widely used
15:47:38 <Eduard_Munteanu> stepcut: you too? :)
15:47:42 <kmc> afaik numeric-prelude is unpopular
15:47:54 <alex404__> It didn't seem to attractive to me for some reason...
15:47:59 <alex404__> Has anyone used it?
15:48:01 <HaskellElephant> @unpl ap (,) f
15:48:02 <lambdabot> ((,) >>= \ b -> f >>= \ a -> return (b a))
15:48:15 <monochrom> I diagree that mathy names is an issue. I think the issue is conflicting requirements from different users.
15:49:04 <HaskellElephant> :t \ f ->  (,) f
15:49:05 <lambdabot> forall a b. a -> b -> (a, b)
15:49:16 <alex404__> Perhaps different preludes for different uses is ideal... it just doesn't seem like there's much for alternatives atm
15:49:27 <HaskellElephant> :t \ f ->  ap (,) f
15:49:27 <monoidal> :t (,)
15:49:28 <lambdabot> forall a b. a -> b -> (a, b)
15:49:28 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
15:49:54 <Eduard_Munteanu> Math high school coverage might be leaner in the US. Though even here I hear ordinary people nagging about math and pretending "it's advanced stuff".
15:50:30 <stepcut> if we listened to the complainers we would have duck-type and objects instead of static type checking and type classes :p
15:50:45 <Eduard_Munteanu> Indeed.
15:50:47 <HaskellElephant> @pl \i -> (i,f i)
15:50:47 <kmc> yeah
15:50:48 <lambdabot> ap (,) f
15:50:50 <kmc> recursion is soooooo hard
15:51:11 <alex404__> Well, it still seems like a strange point. If people are going to accept that IO is defined as a monad, they can accept that + and * are algebraic operators.
15:51:31 <alex404__> And you don't need to understand monads in order to use IO, which is the beauty of it
15:51:51 <Eduard_Munteanu> (To be fair I'm not asking people in the humanities to know those (though that's some other discussion), but programmers, engineers etc.? Come on)
15:52:15 * hackagebot vector 0.7.0.1 - Efficient Arrays  http://hackage.haskell.org/package/vector-0.7.0.1 (RomanLeshchinskiy)
15:52:17 <Eduard_Munteanu> It boils down to convenient double standards.
15:52:32 <Eduard_Munteanu> alex404__: yeah.
15:52:41 <Eduard_Munteanu> They can happily think they're spacesuits.
15:52:51 <alex404__> Wrapped in burritos, right?
15:52:57 <Eduard_Munteanu> alex404__: yep
15:52:58 <kmc> omnom
15:54:35 <absentia> ok, gonna see if I can get life wallpaper to compile on my personal laptop
15:54:45 <absentia> missend, sorry.
15:54:49 <Eduard_Munteanu> The strange thing is abstract algebra isn't much about those boring calculations many dislike about maths. It's just basic intuition, at least at that level.
15:55:26 <djahandarie> I wish there were fewer boring calculations in math
15:55:46 <monochrom> programmers are the last people to appreciate math. they take pride in "my teacher says I need math, but I ignore him/her and hack away in my mom's basement anyway".
15:55:47 <djahandarie> Just let me open ghci during the quiz, I swear
15:56:08 <monochrom> I literally saw a college ad that says that.
15:56:11 <alex404__> Well, that's math in general. I picked up a minor in pure math as an undergrad, and recently started a computational graduate program. People were blown away that I couldn't solve integrals and calculate determinants like a wizard
15:56:20 <lispy1> I love that programmers are so easy to stereotype
15:56:45 <lispy1> It's handy that we're all like in temperament.
15:56:45 <monochrom> (a college ad that says that as an example of successful programmer student)
15:56:46 <HaskellElephant> Anyone know a good way to write "ap (,)" in arrows?
15:57:14 <hpc> (,) can't be made an arrow
15:57:18 <Eduard_Munteanu> monochrom: that's certainly doable for some applications, that's not something I'm complaining about. Rather the cultural phenomena "let's ignore math, praise humanities and accept blind so-called pragmatism"
15:57:27 <hpc> :t arr
15:57:28 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
15:58:11 <monochrom> In fact humanities people appreciate more math than programmers do. At least numbers and statistics. When a humanities person tries to claim "so-and-so improves economics", at least they try to look for numerical evidence. When a programmer claims "so-and-so increases productivity", they don't even bother.
15:58:14 <Eduard_Munteanu> Limited applications though... but suffice to say there's GUI design and webdesign.
15:59:31 <Eduard_Munteanu> monochrom: uh, I'm not really including economics in humanities :/. Makes little sense to do so. More like the so-called intellectual type that C. P. Snow complained about.
16:00:03 <Eduard_Munteanu> Arts, some philosophy, that stuff.
16:00:25 <Eduard_Munteanu> Completely oblivious of scientific knowledge, a familiar type.
16:00:46 <Eduard_Munteanu> Yet asks that others value his work :).
16:00:53 <blackdog> heh, that's pretty funny - you can't build ghc 6.12.1 with ghc 7 :) skolem error.
16:01:10 <blackdog> "i just don't understand my dad any more..."
16:01:23 <jacobian> The question I have is whether or not haskell goes far enough down the Curry Howard rabbit hole :) 
16:02:59 <HaskellElephant> hpc, I was thinking about something like this: Arrow a => a b c -> b -> a b (b,c) ; doing "ap (,)" in the "obvious way".
16:03:31 <hpc> HaskellElephant: ah; well i am too tired to think about new things :P
16:03:49 <HaskellElephant> hpc: he he, actually I should be too =D
16:04:38 <monoidal> :t \a b -> a &&& (arr (const b))
16:04:39 <lambdabot> forall (a :: * -> * -> *) b c a1. (Arrow a) => a b c -> a1 -> a b (c, a1)
16:04:44 <erg0t> what is the best option if I want to pretty print a string that is actually a long line result from show?
16:04:49 <monoidal> HaskellElephant: ^ ?
16:05:28 <HaskellElephant> monoidal: yea that seems to be the one!
16:05:37 <monoidal> @pl \a b -> a &&& (arr (const b))
16:05:37 <lambdabot> (. (arr . const)) . (&&&)
16:05:48 <erg0t> should I use the haskell parser and then Language.Haskell.Pretty?
16:05:54 <kmc> erg0t, it's been done
16:05:57 <kmc> see 'groom'
16:06:00 <monochrom> the best option would be to not have the string to begin with. use a pretty printer properly, on the original data, not after show.
16:06:09 <kmc> also 'ipprint'
16:06:20 <erg0t> thanks :)
16:06:36 <kmc> good idea ;)
16:06:57 <djahandarie> Oh god
16:07:06 <djahandarie> I hope HaskellElephant doesn't use that anywhere
16:08:02 <monoidal> @pl \() -> x
16:08:03 <lambdabot> (line 1, column 4):
16:08:03 <lambdabot> unexpected " "
16:08:03 <lambdabot> expecting operator, pattern or "->"
16:08:20 <monoidal> @pl (\() -> x)
16:08:20 <lambdabot> (line 1, column 5):
16:08:20 <lambdabot> unexpected " "
16:08:20 <lambdabot> expecting operator, pattern or "->"
16:08:35 <monoidal> @pl (\x -> case x of () -> y)
16:08:35 <lambdabot> (line 1, column 20):
16:08:35 <lambdabot> unexpected " "
16:08:35 <lambdabot> expecting variable, "(", operator or ")"
16:09:31 <c_wraith> I think @pl doesn't know ()
16:10:16 <hpc> pl doesn't know patterns in general
16:10:29 <Twey> Or ‘case’
16:10:40 <hpc> i think all it can do is a very basic translation to head and tail
16:10:54 <Twey> Really?
16:11:02 <hpc> @pl \(x:xs) -> x
16:11:02 <lambdabot> head
16:11:09 <Twey> @pl \x -> case x of (h : t) -> h : t
16:11:09 <lambdabot> (line 1, column 25):
16:11:09 <lambdabot> unexpected ">" or "-"
16:11:09 <lambdabot> expecting variable, "(", operator or end of input
16:11:12 <hpc> @pl \(Just x) -> x
16:11:12 <lambdabot> (line 1, column 8):
16:11:12 <lambdabot> unexpected "x"
16:11:12 <lambdabot> expecting operator or ")"
16:11:29 <djahandarie> @pl f (Just x) = x
16:11:30 <lambdabot> (line 1, column 12):
16:11:30 <lambdabot> unexpected "="
16:11:30 <lambdabot> expecting variable, "(", operator or end of input
16:11:34 <Twey> @pl \x -> case x of (h : t) -> h
16:11:34 <lambdabot> (line 1, column 25):
16:11:34 <lambdabot> unexpected ">" or "-"
16:11:34 <lambdabot> expecting variable, "(", operator or end of input
16:11:37 <Twey> @pl \x -> case x of (h:t) -> h
16:11:37 <lambdabot> (line 1, column 23):
16:11:37 <lambdabot> unexpected ">" or "-"
16:11:38 <lambdabot> expecting variable, "(", operator or end of input
16:11:47 <Twey> @pl \z -> case z of (x:xs) -> h
16:11:47 <lambdabot> (line 1, column 24):
16:11:47 <lambdabot> unexpected ">" or "-"
16:11:47 <lambdabot> expecting variable, "(", operator or end of input
16:11:56 <Twey> Why doesn't it like mine?
16:11:59 <djahandarie> lambdabot, please use a pastebin
16:12:06 <Twey> Oh, it can do lambda patterns but not case, I guess
16:12:08 <Twey> Hah
16:12:19 <djahandarie> Twey, it can't parse lambda patterns, it's just a replace
16:12:22 <djahandarie> I think
16:12:31 <djahandarie> Can't parse them well
16:12:34 <Twey> Aye
16:13:17 <Eduard_Munteanu> @pl \(a:b:xs) -> b
16:13:17 <lambdabot> head . tail
16:13:51 <djahandarie> Hmmm
16:14:20 <djahandarie> Only lambda patterns on lists, I think
16:14:45 <Eduard_Munteanu> @pl \([a]) -> a
16:14:45 <lambdabot> (line 1, column 3):
16:14:45 <lambdabot> unexpected "["
16:14:45 <lambdabot> expecting pattern
16:16:12 <Eduard_Munteanu> @pl \(Just a) -> a
16:16:12 <lambdabot> (line 1, column 8):
16:16:12 <lambdabot> unexpected "a"
16:16:12 <lambdabot> expecting operator or ")"
16:20:02 <astroboy> Why does this code: http://hpaste.org/41157/alex_monad_problem?pid=41157&lang_41157=Haskell generate this error: "Scanner.x:81:24: Not in scope: data constructor `TOEF'"?
16:24:13 <monoidal> TOEF or TEOF?
16:25:08 <astroboy> monoidal: aaaarrrgh right. i'm tired i guess
16:25:36 <astroboy> monoidal: no wait I wrote it right :P
16:25:52 <djahandarie> It was wrong in your error
16:26:30 <astroboy> oh.. I guess I have to generate the file again
16:31:25 <astroboy> oh no the problem was somewhere else... stupid error anyway
16:31:29 <astroboy> type
16:31:32 <astroboy> *typo
16:37:28 <srobertson> i think i need 'sequence' for an Applicative type which is not a Monad instance (Yesod.Form.FormResult). is there a simple / "good" way to do ([f a] -> f [a])?
16:37:57 <stepcut> srobertson: sequenceA from Data.Traversable ?
16:38:40 <ddarius> Though if you wanted to implement it it would just be foldr (liftA2 (:)) (pure [])
16:39:20 <srobertson> perfect. thanks stepcut, ddarius
16:39:39 <aristid> srobertson: you found a real Applicative that is not a Monad? wtf
16:40:29 <kmc> :t asum
16:40:30 <lambdabot> Not in scope: `asum'
16:40:37 <kmc> :t Control.Foldable.asum
16:40:38 <lambdabot> Couldn't find qualified module.
16:40:43 <kmc> :t Data.Foldable.asum
16:40:44 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Foldable.Foldable t, Alternative f) => t (f a) -> f a
16:41:11 <jmcarthur> aristid: ZipList
16:41:20 <porton> In Haskell "return" has one argument. However in CT a unit of a monad is a zero-arguments operation. Isn't "return" supposed to be the unit and thus zero-arguments?
16:41:31 * hackagebot hweblib 0.2 - Haskell Web Library  http://hackage.haskell.org/package/hweblib-0.2 (AycanIrican)
16:41:33 <aristid> jmcarthur: ok, sure, i mean... :D
16:41:46 <kmc> :t Data.Traversable.sequenceA
16:41:47 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
16:41:52 <kmc> srobertson, ^^^^
16:42:07 <jmcarthur> porton: think of the 'm' in 'a -> m a' as the unit
16:42:31 <porton> jmcarthur: So, "return" isn't a unit? What is it?
16:42:32 <jmcarthur> porton: and it also makes more sense to think of it that way when looking at join :: m (m a) -> m a   :)
16:42:57 <jmcarthur> it makes m*m -> m fit
16:43:07 <jmcarthur> i only know this stuff *very* informally
16:43:11 <fxr> when I try to escape from rfc implementations I suddenly find myself implementing one.
16:43:16 <porton> jmcarthur: I didn't understood
16:43:38 <porton> ... about "m*m -> m fit"
16:43:44 <djahandarie> fit is a verb
16:43:47 <jmcarthur> porton: http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
16:43:47 <monochrom> haha there is no escape from monads or rfcs
16:45:00 <FauxFaux> You can escape monoids if you only use Haskell for golf competitions where the input is hardcoded.
16:45:42 <porton> I have some study of Haskell in order to know math better :-)
16:46:33 <porton> Haskell gives me the first practical example of use of monads about which read in a CT book
16:46:46 <monoidal> porton: in CT, return is a nat. transformation 1 -> T
16:46:53 <fxr> I'm looking for contributors to my package: https://github.com/aycanirican/hweblib, if anyone interested...
16:47:08 <monoidal> porton: in haskell natural transformations between functors f g are the type forall x. f x -> g x
16:47:32 <porton> monoidal: Is "return" a unit?
16:47:36 <monoidal> porton: yes
16:47:43 <fxr> which started as a web library but now it's a network library I guess
16:48:07 <porton> Above was said that 'a -> m a' is the unit. Isn't it a contradiction?
16:48:15 <monoidal> return is a -> m a
16:48:35 <monoidal> a -> m a is the type of natural transformations from identity functor to m
16:48:43 <monoidal> and one of these transformations is return
16:49:04 <jmcarthur> porton: think of it like:   return :: Id a -> m a
16:49:15 <porton> What happens if "return" is at the middle of a "do" calculation, not at the end?
16:49:16 <wlangstroth> wouldn't "unit" be the more mathematical name for return? Maybe I'm confusing it with something else.
16:49:24 <monoidal> for connections between monads and monoids, you can check sigfpe's post; I wrote it using kind polymorphism here: http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
16:49:33 <monochrom> yes, many math books call return unit
16:49:35 <jmcarthur> wlangstroth: it's not a bad name for it
16:49:50 <monoidal> porton: "return" is not return from imperative languages; it doesn't abort the control flow
16:50:03 <monoidal> do x <- return 4; y <- [6,8]; return (x+y)
16:50:06 <jmcarthur> and that's why return is an unfortunate name
16:50:12 <monoidal> > do x <- return 4; y <- [6,8]; return (x+y)
16:50:13 <lambdabot>   [10,12]
16:50:15 <sipa> it should be called lift
16:50:18 <jmcarthur> point
16:50:21 <ddarius> η would be the more mathematical term.
16:50:22 <roconnor> or unit :P
16:50:23 <Philippa> liftM0?
16:50:27 <jmcarthur> ha
16:50:37 <wlangstroth> ddarius - Eta?
16:50:39 <monochrom> imperative languages be damned
16:50:49 <wlangstroth> monocrom, preaching to the choir
16:50:52 <Philippa> that they be...
16:51:03 <wlangstroth> (monochrom)
16:51:33 <porton> My second question: Can Haskell (I mean GHC) optimize stateful monoidal calculations, as if these would be in an imperative language?
16:51:40 <monochrom> there is no hope in avoiding name clashes with imperative languages. what would you call objects otherwise?
16:51:48 <anonym> subjects
16:52:06 <wlangstroth> jmcarthur: some sort of historical reason it got "return" instead - do you know?
16:52:35 <sipa> > return 5 :: [Int]
16:52:36 <lambdabot>   [5]
16:52:46 <sipa> > return 5 :: Maybe Int
16:52:47 <lambdabot>   Just 5
16:52:56 <sipa> > return 5 :: IO Int
16:52:57 <lambdabot>   <IO Int>
16:53:01 <ddarius> anonym: See subject-oriented programming which is related to object oriented programming.
16:53:06 <dagle> Hmm. I have gotten a assigment and I should write a function that zton :: N -> Z , but shouldn't zton be zton :: Z -> N ? (just checking, feels like a typo)
16:53:26 <sipa> sounds like a typo indeed
16:53:39 <dagle> Then I can solve it!
16:53:51 <monochrom> you can solve both
16:54:00 <mm_freak> it's really frustrating, when you have years of experience in haskell, and then you get into a company, which uses PHP
16:54:16 <jmcarthur> wlangstroth: i think it was due to whoever wanted do notation to look just like imperative programming
16:54:16 <dagle> monochrom: There are some other restrictions.
16:54:17 <mm_freak> luckily at least they allow me to use haxe for my projects, and i can write my tools in haskell
16:54:20 * ddarius would stick with what is written, it's easier and as monochrom says, names mean nothing.
16:54:38 <jmcarthur> mm_freak: i believe facebook uses haskell to generate some of their php
16:54:43 <ddarius> mm_freak: You could have gone to a different company.
16:54:47 <wlangstroth> mm_freak: "object oriented" PHP?
16:55:08 <mm_freak> ddarius: yes, but the money keeps me there
16:55:11 <jmcarthur> ddarius: know of a company that's hiring haskell programmers right now?
16:55:26 <mm_freak> note that i don't have anything on paper
16:55:51 <mm_freak> wlangstroth: yes, we use Zend, which abuses OOP in a particularly ugly way
16:55:55 <wlangstroth> jmcarthur, unfortunate. The do notation is pretty friendly, though
16:55:57 <monochrom> money is good. scam their money as much as you can. consider it a social service. and yes, you keep the money!
16:56:20 <ddarius> jmcarthur: There're plenty, especially if you don't require limiting to one's that use Haskell.
16:56:38 <porton> jmcarthur: Write free software in Haskell in your spare time
16:56:43 <wlangstroth> mm_freak: my sympathies; object oriented PHP is almost as silly as object oriented JavaScript
16:56:47 <sproingie> mm_freak: what does zend do?
16:56:57 <jmcarthur> porton: there isn't much money there unless i get really lucky
16:56:59 <monochrom> wait, object oriented javascript is not silly
16:57:03 <mm_freak> porton: i do, but most of the stuff is useless to the community, so i don't upload it
16:57:05 <sproingie> wlangstroth: javascript has a frighteningly elegant OOP system
16:57:22 <jmcarthur> mm_freak: ditto
16:57:24 <monochrom> unless you just mean the whole phrase is redundant.
16:57:30 <wlangstroth> monochrom, sproingie: yeah, when it's not warped into "classical" object orientation
16:57:41 <sproingie> i've seen little of that
16:57:54 <wlangstroth> sproingie: MooTools?
16:57:55 <mm_freak> sproingie: it's a web framework for PHP…  despite its conceptual ugliness it allows to create web apps quickly, but it's nowhere near a good haskell web framework like yesod
16:58:13 <sproingie> it can certainly be abused when morons from rails find that they can hack on Object.__prototype__
16:58:21 * jmcarthur still hasn't given yesod a fair chance
16:58:46 * wlangstroth got hooked on playing with Snap early
16:58:50 <mm_freak> wlangstroth: actually PHP has the same OOP stuff that java has, mostly even with the same syntax, if you disregard those dumb dollar symbols everywhere
16:59:06 <sproingie> mm_freak: i've heard of zend, just not familiar with its particular flavor of braindeadness
16:59:09 <monochrom> dollar symbol is the dumbest invention ever
16:59:09 <jmcarthur> yeah i'm on snap right now too, but i should really be giving yesod a chance since it looks like it currently does a lot more
16:59:11 <wlangstroth> mm_freak: yeah, I know; I've fixed many a PHP site
16:59:17 <mm_freak> wlangstroth: but it doesn't beat C# and it's nowhere near CLOS
16:59:36 <fxr> :) spoken frameworks cannot parse formal urls.
16:59:42 <sproingie> i'm a fan of python's object model.  mostly.
17:00:10 <sproingie> combine it with scala's and i'd be in hog heaven
17:00:10 <mm_freak> jmcarthur: try it, for me it even beats happstack
17:00:12 <wlangstroth> mm_freak, C# is much, much better, faster, etc. for that. Boring, and not fun like Haskell, but still
17:00:26 <romanandreg> hey guys... do you think is a good a idea to use a Zipper to move inside a Matrix?
17:00:29 <pickles> there's always F#
17:00:51 <wlangstroth> F# is actually pretty comfy, especially if you've used O'Caml
17:00:52 <jmcarthur> romanandreg: depends on what you're doing
17:00:54 <mm_freak> pickles: F# isn't really mature IMO
17:00:57 <porton> Oh, I now understand that I haven't understood: Why the unit "return" maps some object into a monad state, instead of mapping a state of the monad into a state of the monad?
17:01:19 <romanandreg> jmcarthur: I'm moving inside the matrix... like a I would do in a maze
17:01:28 <pickles> mm_freak: i've only just been looking at it, but haven't actually done anythign with it
17:01:32 <jmcarthur> porton: it maps the Identity monad into some other monad
17:01:33 <sproingie> porton: right, "return" takes a plain value and makes it monadic
17:01:48 <jmcarthur> porton: except in haskell we drop the Identity since it's not very useful
17:02:12 <jmcarthur> s/monad/functor/
17:02:12 <mm_freak> jmcarthur: rather since we cannot represent it explicitly
17:02:21 <jmcarthur> mm_freak: we can't?
17:02:26 <sproingie> we can represent Identity explicitly, it just isn't very useful
17:02:30 <jmcarthur> newtype Identity?
17:02:30 <mm_freak> jmcarthur: we can only represent the identity monad "up to isomorphism"
17:02:35 <porton> So "return" is not a unit?
17:02:46 <sproingie> jmcarthur: if you don't mind having to decorate every last thing with Identity
17:02:51 <jmcarthur> sproingie: right
17:02:56 <sipa> > return 5 :: Identity Int
17:02:57 <lambdabot>   No instance for (GHC.Show.Show
17:02:57 <lambdabot>                     (Control.Monad.Identity....
17:02:59 <jmcarthur> but that's kind of the point
17:03:04 <mm_freak> jmcarthur: Identity is not the real identity monad, it's just isomorphic to it
17:03:11 <sproingie> huh there's not even a Show instance for Identity
17:03:13 <mm_freak> this is easy to see:  Identity a /= a
17:03:13 <jmcarthur> mm_freak: isn't isomorphic close enough?
17:03:19 <mm_freak> jmcarthur: yes, mostly
17:03:25 <jmcarthur> where is it not?
17:03:32 <sipa> porton: what do you mean by 'unit' ?
17:03:46 <mm_freak> jmcarthur: where you want stricter equivalence
17:03:50 <porton> sipa: Unit as defined in the CT definition of monad
17:04:08 <jmcarthur> porton: it's a unit in the same sense that unit :: () -> T is a unit
17:04:19 <sipa> oh, i don't know CT, unfortunately
17:04:26 <sproingie> i got yer unit
17:04:33 <sipa> thought i have the feeling that if you stay long enough in this channel, i will
17:04:34 <wlangstroth> :)
17:04:41 <mm_freak> sproingie: B&B?
17:04:42 <sipa> s/you/i/
17:04:51 <sproingie> sipa: i've been hanging out here for years and i still dont grok CT
17:04:53 <monochrom> hahahah
17:05:11 <jmcarthur> porton: it's just parameterized. so instead of  () -> T  it's  () a -> T a
17:05:12 <mm_freak> sipa: to understand CT, you really need to be interested in it (or need it)
17:05:15 <sproingie> i just see little ovals with arrows coming out of them and thats as far as it goes
17:05:15 <monochrom> I will stay until you know CT
17:05:19 <sipa> mm_freak: i might be
17:05:22 <mm_freak> i understand only the basic concept
17:05:32 <sipa> just need to take the time to study it more in detail
17:05:35 <wlangstroth> I asked before, but have any of you guys played with the redis module?
17:05:37 <mm_freak> sipa: i thought i might be, but CT is very dry
17:05:43 <astroboy> What does the "@" operator do? for example inp@(_,str)
17:05:51 <sipa> astroboy: alias
17:05:54 <mm_freak> although haskell gives it some practical purposes
17:06:08 <sproingie> astroboy: it binds inp to the whole pattern which then gets further destructured by the pattern match
17:06:21 <monochrom> not an operator. syntax. it makes inp refer to the whole parameter.
17:06:28 <sipa> > case Just 5 of x@(Just y) -> "x=" ++ show x  ++ " y=" ++ show y
17:06:29 <lambdabot>   "x=Just 5 y=5"
17:06:34 <mm_freak> astroboy: it's actually not an operator
17:06:38 <kmc> yep.  x@p matches anything that p matches, binding the variables p binds, and also binds x to the whole value
17:06:40 <monoidal> > let f x@(a:b) = (x,a,b) in f [1,2,3] -- astroboy
17:06:40 <lambdabot>   ([1,2,3],1,[2,3])
17:06:45 <sipa> > case Just 5 of x@(Just y) -> "x=(" ++ show x ++ ") y=(" ++ show y ++ ")"
17:06:46 <lambdabot>   "x=(Just 5) y=(5)"
17:07:02 <sproingie> > let f inp@(_,str) = (inp,str) in f (1,"yay")
17:07:03 <lambdabot>   ((1,"yay"),"yay")
17:07:12 <sproingie> man i type slow today
17:07:12 <monochrom> in SML @ is called "as"
17:07:17 <astroboy> oh I see, basically is to pattern match when you cant
17:07:17 <mm_freak> > let ()@() = () in ()
17:07:18 <lambdabot>   <no location info>: parse error on input `@'
17:07:36 <mm_freak> > let Nothing@Nothing = Nothing in ()
17:07:37 <lambdabot>   <no location info>: parse error on input `@'
17:07:43 <mm_freak> hmm, that would be a great feature
17:07:47 <jmcarthur> > let a@Nothing = Nothing in ()
17:07:48 <sproingie> pretty sure you can only have an identifier on the left of @
17:07:48 <sipa> > case Just (Just 5) of (Just x)@(Just (Just y)) -> "bla"
17:07:48 <lambdabot>   ()
17:07:48 <astroboy> it would be the same to have a where (_, str) = inp, wouldn't it?
17:07:49 <lambdabot>   <no location info>: parse error on input `@'
17:07:51 <mm_freak> if the LHS of @ could be a pattern itself
17:08:09 <sproingie> > let f (a,b)@(x,y) = (a,y) in f (1,2)
17:08:10 <lambdabot>   <no location info>: parse error on input `@'
17:08:21 <djahandarie> mm_freak, you'd say it's drier than eg abstract algebra?
17:08:24 <wlangstroth> yikes - that "pattern" already hurts readability
17:08:27 <sproingie> mm_freak: that would be pretty wild
17:08:31 <mm_freak> astroboy: yes, almost, other than that you would have to bind 'inp' yourself in that case
17:08:42 <mm_freak> djahandarie: yeah
17:08:56 <mm_freak> djahandarie: abstract algebra is more than just a language
17:08:56 <monochrom> "where (_, str) = inp" is not the same if you also care about strictness/evaluation order
17:09:11 <sproingie> heck you should be able to use ~ and chain as many @'s as you want
17:09:19 <sproingie> then you could try multiple different patterns
17:09:21 <djahandarie> I'd say CT is more than a language too...
17:09:24 <jmcarthur> i don't find AA anywhere near as dry as CT
17:09:24 * sproingie eyes himself warily
17:09:30 <sipa> AA?
17:09:34 <jmcarthur> abstract algebra
17:09:35 <mm_freak> monochrom: sure?  wouldn't it depend on how you bind 'inp'?
17:09:38 <sipa> oh, ok
17:09:49 <sproingie> the first step in abstract algebra is admitting you have an algebra
17:09:59 <sproingie> the second step is to find your higher order power
17:10:03 <mm_freak> sproingie: you couldn't really try them, unless you catch exceptions
17:10:04 <jmcarthur> but the reason i think that is probably because i know a lot more AA than CT
17:10:07 <wlangstroth> sproingie: bravo
17:10:08 <monochrom> f inp@(_,_) = "hey"  -- bombs with f undefined
17:10:14 <astroboy> mm_freak: where can I find documentation on "@"? possibly with examples
17:10:14 <ddarius> For both it depends on what you read.
17:10:26 <monochrom> f inp= "hey" where (_,_)=inp -- does not bomb with f undefined
17:10:27 <ddarius> And yes, as you get deeper into either they get more interesting.
17:10:47 <ddarius> CT grew out of algebraic topology.
17:10:52 <sproingie> the funny thing is the other places i frequent have another expansion of "CT"
17:10:56 <sproingie> namely "Conspiracy Theory"
17:11:03 <mm_freak> astroboy: what you read here is really the full story…  x@y just binds x to the whole y
17:11:06 <jmcarthur> sounds like you frequent fun places
17:11:23 <sproingie> well CT is used as a reason for downrating
17:11:30 <mm_freak> > let x@(a,b) = (1,2) in (x, a, b)
17:11:31 <lambdabot>   ((1,2),1,2)
17:11:49 <mm_freak> x is an alias for the entire pattern to the right of @
17:12:18 <monochrom> full documentation of @ is in the Haskell 2010 report: http://www.haskell.org/onlinereport/haskell2010/
17:12:20 <astroboy> mm_freak: then why the _ in (_, str)? It just says that you won't use the thing on the left anyway?
17:12:21 <mm_freak> djahandarie: yes, but in AA you get many proofs
17:12:29 <sproingie> astroboy: _ means ignore it
17:12:35 <mm_freak> astroboy: _ matches anything, but doesn't give it a name
17:12:40 <mm_freak> a placeholder, so to say
17:12:51 <mm_freak> > let (a, _, c) = (1,2,3) in (a,c)
17:12:52 <lambdabot>   (1,3)
17:13:15 <mm_freak> you could have put a 'b' instead of '_' to give the 2 a name
17:13:16 <aavogt> > let __ = __ in case __ of _ -> __
17:13:20 <lambdabot>   mueval-core: Time limit exceeded
17:13:29 <astroboy> mm_freak: so that alias would just "replace" any occurence of inp with (_, str)?
17:13:40 <sproingie> aavogt: there's a special circle in hell just for you
17:14:22 <romanandreg> yeah the Zipper in the Matrix
17:14:24 <wlangstroth> sproigie: according to my copy of the Inferno, it's Circle 7, ring 3
17:14:24 <mm_freak> astroboy: no, inp is just a name for the whole pattern, for example i often have a pattern like this:  x@(x0:xs), so that instead of writing 'x0:xs' i can just write 'x'
17:14:26 <romanandreg> is not as efficient
17:14:28 <romanandreg> as I would like
17:14:52 <aavogt> > let __ = __ in case __ of _ -> __ where _ = __
17:14:56 <lambdabot>   mueval-core: Time limit exceeded
17:15:08 <astroboy> mm_freak: ok so is it just syntactic sugar?
17:15:15 <aavogt> sproingie: it's missing @ and ~ though
17:15:19 <aavogt> also view patterns
17:15:21 <mm_freak> astroboy: not just that, it can also help efficiency
17:15:39 <mm_freak> astroboy: you save the constructor call (:)
17:15:56 <aavogt> has anybody measured the difference?
17:15:57 <wlangstroth> hmm ... perhaps ditch 9 of circle 8
17:16:02 <astroboy> mm_freak: but would the meaning of my code change?
17:16:25 <mm_freak> > let oddToNothing x@(Just n) | even n = x | otherwise = Nothing in oddToNothing (Just 3)
17:16:26 <lambdabot>   Nothing
17:16:38 <mm_freak> instead of writing Just n, i can just write x
17:16:56 <mm_freak> x is already constructed, so i save the call to Just
17:17:16 <astroboy> mm_freak: oh so the (x0:xs) gets evaluated as soon as you use @?
17:17:35 <mm_freak> astroboy: no, the evaluation isn't changed
17:17:47 <astroboy> ok I'm confused :P
17:17:49 <mm_freak> but if i would use 'n', i'd have to wrap it in a Just again
17:18:00 <mm_freak> i could have written it this way instead:
17:18:08 <astroboy> yeah but I don't get why is it more efficient
17:18:15 <mm_freak> > let oddToNothing (Just n) | even n = Just n | otherwise = Nothing in oddToNothing (Just 3)
17:18:16 <lambdabot>   Nothing
17:18:31 <mm_freak> i unwrap 'n' just to wrap it again in a Just
17:18:46 <mm_freak> GHC optimizes this away, but other compilers might really do the wrapping again
17:18:53 <monochrom> From the Haskell 2010 report: Patterns of the form var@pat are called as-patterns, and allow one to use var as a name for the value being matched by pat. For example, case e of { xs@(x:rest) -> if x==0 then rest else xs } is equivalent to: let { xs = e } in case xs of { (x:rest) -> if x==0 then rest else xs }. http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-580003.17
17:19:49 <mm_freak> astroboy: just remember:  whenever you repeat a pattern in the code, it's a great candidate for a use case of @
17:19:53 <astroboy> mm_freak: oh ok, I think I get it, thanks a lot
17:21:30 <mm_freak> at least it removes redundancy, but it might give you faster code, too
17:22:08 <monochrom> if you change data structures and therefore certain patterns, @ is robust.
17:22:24 <porton> What is "monadic value" (http://www.haskell.org/tutorial/monads.html) in terms of CT?
17:22:59 <mm_freak> porton: an object in the destination category, i think
17:23:27 <porton> mm_freak: In definition of monad there are only one category and is considered only one object!
17:23:44 <pickles> anyone know of any good haskell windowing libs (for windows) that don't require a bunch of 3rd party stuff?
17:24:25 <aavogt> you're probably going to have to relax one or both of your constraints
17:24:50 <pickles> mm
17:25:26 <aavogt> as in, you're not willing to try gtk2hs, wxhaskell
17:25:52 <monochrom> "return True" is an example of monadic value. you will quickly find that it is not in category theory, unless you open up an object, consider it a set, and find it has elements. For example, "return True" is an element of the object m Bool, where m is your monad.
17:25:53 <aavogt> maybe there's a binding to win32...
17:25:58 <astroboy> another thing, I don't really get the role of startcodes in Alex
17:26:20 <mm_freak> i'm not sure, but i think a monad is generally a functor from a category to a subcategory of itself
17:26:49 <pickles> aavogt: i would probably be willing to attempt installing either of those on the weekend, but my current mental state is vectored towards least effort
17:26:59 <mm_freak> so 'M a' would be an object in the subcategory, but that's not really a monadic "value"
17:27:19 <aavogt> pickles: I don't think those are difficult... there should be installers for them
17:27:20 <mm_freak> it's a type, and in CT terms it's an object
17:28:02 <porton> mm_freak: But for a monad in CT sense can be only one object!
17:28:07 <mm_freak> a value of that type probably doesn't have a concrete representataion in CT in general
17:28:26 <mm_freak> in Hask it has, because we know something about Hask:  objects are sets
17:28:32 <pickles> aavogt: mmk, ill check em out, thanks :)
17:28:34 <mm_freak> and sets have elements
17:28:48 <mm_freak> a monadic value is such an element
17:31:25 <monochrom> learning haskell requires formatting your mind
17:32:04 <monochrom> formatting your disk to get rid of python etc also helps
17:32:24 <copumpkin> zygoloid, jmcarthur : I think I figured it out
17:32:30 <mm_freak> porton: objects from other categories may not have a notion of elements, just take an order category as example
17:33:00 <mm_freak> so "monadic values" are really a peculiarity of Hask and similar categories
17:34:11 <monochrom> many ceii have joined #haskell
17:34:30 <porton> I realized the source of my frustration: (From Wikipedia) As a minor terminological mismatch, the term monad in functional programming contexts is usually used with a meaning corresponding to that of the term strong monad in category theory, a specific kind of category-theoretical monad.
17:35:16 <jmcarthur> copumpkin: :D
17:35:47 <pickles> is the LYAH(FGG) author about? i found a typo
17:36:04 <monochrom> @seen BONUS
17:36:04 <lambdabot> Unknown command, try @list
17:36:04 <preflex>  BONUS was last seen on #haskell 9 hours, 28 minutes and 7 seconds ago, saying: cool! see ya!
17:36:07 <pickles> *rather, a grammar thing
17:36:23 <monochrom> that summons the author
17:36:59 <pickles> summons?
17:37:06 <pickles> (am i missing something?)
17:37:17 <sproingie> he has a knack for showing up right when people are talking about him
17:37:22 <pickles> ah
17:37:32 <dbelange> hi guys
17:37:33 <monochrom> if you feel like leaving a message, "@tell BONUS you have a typo" works. you may use public or pm to lambdabot for that
17:37:38 <dbelange> are you having trouble with the lambdabot that I wrote
17:37:52 <pickles> thx monochrom
17:38:28 <monochrom> and BONUS (and everyone, and me) is a pokemon and so needs to be summoned
17:38:31 <ddarius> While Haskell monads are inherently strong, having a strength doesn't change -that- much.
17:39:07 <ddarius> Incidentally, there is a 2-categorical definition of monad divorced from Cat, but given no other context, monad usually means a monad in Cat.
17:39:28 <Eduard_Munteanu> ddarius: what about the regular monads doesn't fit Haskell's current system?
17:39:38 <Eduard_Munteanu> They pretty much look like normal monads to me.
17:42:11 <pickles> monochrom: we summoned DarkOne once when there were 666 ppl in the room
17:42:32 <monochrom> see, it worked. :)
17:42:44 <pickles> does that mean satan is a pokemon?
17:43:10 <monochrom> yeah!
17:43:34 <copumpkin> zygoloid: however, it's hacky, and needs a lift STRef operation, which I don't think can be avoided without dependent types
17:43:43 <monochrom> everything is a pokemon. (risking russell's pokemon paradox now.)
17:43:55 <mauke> preflex: seen satan
17:43:55 <preflex>  satan was last seen on ##php 2 years, 67 days, 4 hours, 44 minutes and 52 seconds ago, saying: tekhneek: no it's not
17:44:22 <pickles> reflex seen darkone
17:44:30 <pickles> preflex: seen darkone
17:44:30 <preflex>  darkone was last seen on #haskell 1 day, 11 hours, 16 minutes and 23 seconds ago, saying: Have you tried presenting some case data? So everyone knows what you want exactly?
17:44:37 <wlangstroth> monochrom is clearly a pokemon
17:44:48 <mm_freak> module Data.Hell (Hell) where newtype Hell a = Hell (IO a) deriving Monad
17:44:55 <Darkone> DING DING DING
17:45:05 * wlangstroth has no idea what that entails, but "pokemon" sounds funny
17:45:20 <Darkone> "On behalf of the president and senator,  we welco- DDIIIIIIIINNGGGG"
17:45:20 <pickles> its only risking russell paradox if you're trying to find the set of pokemon who don't contain sets of pokemon
17:45:23 <Darkone> :(
17:46:05 <pickles> or...
17:46:20 <pickles> logic does not seem to be my friend at the mooment
17:46:33 <pickles> and apparently im turning into a cow, so that fits i guess
17:46:56 <monochrom> pickled cow
17:47:15 <pickles> ... that sounds disgusting
17:48:24 <fengshaun> > let xs = [25, 64]
17:48:25 <lambdabot>   not an expression: `let xs = [25, 64]'
17:48:53 <fengshaun> > sqrt $ [25, 64] !! 0
17:48:54 <lambdabot>   5.0
17:48:57 <fengshaun> hmmm
17:49:26 <fengshaun> > let xs = [25, 64] in
17:49:27 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:49:39 <fengshaun> > let xs = [25, 64] in sqrt $ xs !! 0
17:49:40 <lambdabot>   5.0
17:49:44 <Eduard_Munteanu> Hm, can someone answer that? I've seen that said many times, and I can't really tell why.
17:50:06 <Eduard_Munteanu> Monad axioms don't really require anything beyond a unit and join natural transformations.
17:50:08 <kmc> @src (.)
17:50:08 <lambdabot> (f . g) x = f (g x)
17:50:08 <lambdabot> NB: In lambdabot,  (.) = fmap
17:50:19 <sipa> > [1,3] + [3,4]
17:50:20 <lambdabot>   No instance for (GHC.Num.Num [t])
17:50:20 <lambdabot>    arising from a use of `e_11334' at <in...
17:50:27 <sipa> > ([1,3] + [3,4]) :: [Int]
17:50:28 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
17:50:28 <lambdabot>    arising from a use of `GHC...
17:50:32 <sipa> bleh
17:50:36 <monochrom> I forgot the law about "strong" and why Haskell ensures it.
17:50:47 <pickles> fengshaun: @let
17:51:08 <Eduard_Munteanu> Ah, nevermind, maybe ddarius comes back with an answer.
17:52:30 <dobblego> how do I pass options to haddock when I 'cabal haddock' ?
17:53:32 <Eduard_Munteanu> s/Monad axioms/Haskell Monad axioms/  -- for clarity
17:56:40 <kmc> dobblego, just after haddock
17:56:42 <kmc> i think?
17:56:57 <dobblego> nah it looks for a cabal option then
17:57:23 <ddarius> Eduard_Munteanu: If I say a foo monoid is any monoid over the integers, i.e. only has to satisfy the monoid laws, that doesn't make all monoids foo monoids.
17:58:09 <Eduard_Munteanu> ddarius: so in the same sense, there are strong and regular monads in Haskell?
17:58:13 <dolio> Eduard_Munteanu: I don't know what the original guy's problem was, but all functors in Haskell are strong, meaning you can write (a, F b) -> F (a, b).
17:58:37 <dolio> This is a consequence of Hask being Cartesian closed, I believe.
17:59:11 <dolio> I don't really understand why that's a big deal to some people.
17:59:11 <Eduard_Munteanu> dolio: uh, I don't really understand that (a, F b) -> F (a, b), but that's probably my fault :/
17:59:38 <dolio> F is the functor in question.
17:59:56 <djahandarie> What are some open problems in type theory?
17:59:59 <Eduard_Munteanu> Yes, that much I get.
18:00:03 <Veinor> :t \(x,y) -> do { a <- y; return (x, a) }
18:00:03 <ddarius> Eduard_Munteanu: No.  Some monoids are also rings, but all foo monoids are rings.
18:00:04 <lambdabot> forall t (m :: * -> *) t1. (Monad m) => (t, m t1) -> m (t, t1)
18:00:15 <dolio> strong :: Functor f => (a, f b) -> f (a, b) ; strong (x, fy) = fmap (x,) fy
18:00:25 <Veinor> bah, you and your fmap
18:00:56 * ddarius recommends the definition, fmap . (,) since it drives home the important aspect of strength.
18:01:06 <lars9> @src filterM
18:01:07 <lambdabot> Source not found. Where did you learn to type?
18:01:20 <Eduard_Munteanu> dolio: so they're strong simply because that's provable?
18:01:34 <Eduard_Munteanu> that type sig I mean.
18:02:02 <ddarius> What dolio called "strong" and is usually called "strength" also has to satisfy some laws.
18:02:10 <dolio> Yes. The definition of a strong functor is a functor equipped with such a natural transformation.
18:02:15 <dolio> And, yeah, my bad.
18:02:38 <Eduard_Munteanu> Ah, I understand then.
18:03:09 <dolio> Anyhow, saying, "the Haskell concept of monad corresponds to strong monads in category theory," seems to be missing the point, to me.
18:03:22 <dolio> The real point is that Monad is a class for monads over Hask.
18:03:33 <dolio> Which all happen to be strong because of the structure of Hask.
18:03:34 <astroboy> I am using alex with the monad wrapper, how do I modify the wrapper to suit my needs? Do I have to edit the generated .hs file directly?
18:03:37 <ddarius> The Haskell concept doesn't.  It simply is an example.
18:03:46 <Eduard_Munteanu> Hask -> Hask functors, that is.
18:04:16 <ddarius> dolio: You can have non-strong functors/monad over Hask.
18:04:25 <ddarius> (Unless you identify Hask with Set.)
18:05:05 <Eduard_Munteanu> Grr... where would I find that Hask exact definition? I assume not in the report, but in some papers?
18:05:16 <dolio> You mean, because there are functions that we can't write in haskell, or something like that?
18:05:44 <Eduard_Munteanu> Or does every System F-omega language have Hask-like behavior?
18:05:53 <ddarius> Eduard_Munteanu: There is no definition because, at least the most natural one, doesn't form a category.  However, if you fudge enough, you get something like CPO or various other "computable function" categories.
18:05:54 <dolio> No, I suppose that wouldn't be the reason.
18:06:28 <Eduard_Munteanu> ddarius: what does CPO stand for?
18:06:39 * Eduard_Munteanu will look that up
18:07:14 <copumpkin> Eduard_Munteanu: you could say Hask = (->), which tells you how to combine two objects to get a morphism between them, and shows you by its kind that the objects are *
18:07:24 <copumpkin> (ignoring the ? and ??)
18:07:56 <ddarius> A functor is strong if fmap of that functor itself is a morphism of the relevant category.  Haskell Functors are strong because we write fmap in Haskell and (idealized) Hask has exponentials.
18:08:01 <Eduard_Munteanu> copumpkin: yeah, I can relate that to kinds.
18:09:05 <ddarius> You can show that for a category with exponentials, having strength for a functor is equivalent to fmap being a morphism in that category.  We've already shown one direction.
18:09:13 <copumpkin> http://hpaste.org/41160/pure_st_but_not_really
18:09:29 <dolio> ddarius: Ah, so the action on morphisms could be an incomputable function, conceivably.
18:09:31 <Eduard_Munteanu> :t fmap
18:09:31 <copumpkin> the problem there is liftSTRef :/
18:09:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:09:59 <Eduard_Munteanu> I'm rather thinking of fmap as mapping arrows to arrows.
18:10:32 <dolio> Which would prevent it from being internalized.
18:10:36 <djahandarie> copumpkin, nice
18:10:45 <copumpkin> djahandarie: it's not good though :/
18:10:45 <Eduard_Munteanu> e.g. the part of the functor that does the arrows.
18:10:53 <Eduard_Munteanu> dolio: I see.
18:10:54 <Zao> http://www.youtube.com/watch?v=ka5Ypwub2BA&feature=channel
18:11:00 <Zao> Erm, off by 7 channels.
18:11:09 <copumpkin> djahandarie: I need to figure out how to automatically apply Suc to existing STRefs and I'm not sure it's possible
18:11:34 <dolio> I'll admit, I don't typically think about that possibility.
18:12:12 <Eduard_Munteanu> whereas pure maps objects
18:12:23 <copumpkin> Eduard_Munteanu: nope :P
18:12:29 <copumpkin> I said that last time you said that too
18:12:34 <copumpkin> (I think it was you)
18:12:40 <Eduard_Munteanu> Was I? :/
18:12:51 <copumpkin> if you have Functor f, f itself maps objects
18:12:57 <ddarius> dolio: It doesn't necessarily have to be uncomputable, it just has to not be a Haskell function, though most of the time there will be an equivalent Haskell definition.
18:12:58 <copumpkin> since the objects are types
18:13:00 <copumpkin> f :: * -> *
18:13:15 <Eduard_Munteanu> Oh.
18:13:31 <ddarius> Incidentally, all functors from Set -> Set are strong.
18:13:53 <copumpkin> djahandarie: if you can think of a way to make it work the way we'd expect, I'd be very happy!
18:14:19 <djahandarie> copumpkin, don't hold your breadth
18:14:38 <dolio> Obviously Hask is a Hask-enriched category. :)
18:14:51 <Eduard_Munteanu> I'm a bit uneasy with "fmap is a morphism". I'd expect it to take some arrow (a -> b) to another arrow (f a -> f b), so how is it an arrow itself?
18:14:55 <ddarius> As usually viewed, yep.
18:15:01 <ddarius> (re dolio)
18:15:23 <Eduard_Munteanu> More importantly, in what category?
18:15:34 <ddarius> (a -> b) and (f a -> f b) are both object of Hask.
18:15:47 <ddarius> +s
18:16:42 <Eduard_Munteanu> ddarius: ah, so by virtue of being a self-adjoint functor, fmap can be an arrow.
18:16:59 <Eduard_Munteanu> Aw crap, objects.
18:17:32 <Eduard_Munteanu> ddarius: I'm confused :)
18:18:02 <Eduard_Munteanu> What would an arrow/morphism be then?
18:18:07 <ddarius> Functions.
18:18:14 <ddarius> Functions are values.  a -> b is a type.
18:18:32 <Eduard_Munteanu> Aaaaah.
18:18:34 <Eduard_Munteanu> Makes sense.
18:20:02 <Eduard_Munteanu> Thanks for the clarifications everybody.
18:20:32 <Eduard_Munteanu> I wish there was some reference on this specifically related to Haskell.
18:20:32 <tolkad> if I have a type which has a bunch of constructors with no parameters how does GHC represent this in memory?
18:20:49 <copumpkin> tolkad: I'd guess as an int
18:21:00 <kmc> tolkad, each parameter-less constructor gets a single statically-allocated closure
18:21:15 <kmc> a value of such type is a pointer to a statically-allocated closure
18:21:22 <kmc> (rather than a heap-allocated closure)
18:21:25 <copumpkin> oh, interesting
18:21:27 <kmc> so it's a single machine word
18:21:30 <tolkad> darn it
18:21:40 <kmc> using just an int enum would break the regularity of representations
18:21:50 <kmc> such values need to be enterable and GC-able, like any other
18:21:56 <copumpkin> yeah
18:22:00 <kmc> however you can of course call fromEnum
18:22:05 <kmc> and you can derive Enum
18:22:13 <WStude> hey, quick Haskell Q
18:22:17 <ddarius> If the enumeration is small, it will be entirely encoded in tag bits.
18:22:21 <lars9> @instances Monad
18:22:21 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:22:35 <kmc> ddarius, good point.  so the closures still exist, but you don't explicitly enter them?
18:22:44 <tolkad> I wanted to be able to do « data T = TA | TB; data S = SA | SB; data TS = TS {-# UNPACK #-} !T {-# UNPACK #-} !S » and have it only take one word
18:22:50 <WStude> Trying to run a program, and I keep getting the error message "Syntax error in expression (unexpected symbol "trans")"
18:22:53 <kmc> tolkad, static closures can be used for only part of a type.  for example Nothing has a single static closure, while (Just x) values are heap-allocated
18:22:58 <WStude> trans being the name of a function
18:23:02 <kmc> WStude, can you put your code on hpaste.org?
18:23:07 <ddarius> kmc: You'll check and if you have a non-thunk tag bit, you're done, otherwise you enter as normal.
18:23:11 <WStude> hold on...
18:23:30 <tolkad> kmc: it can't create a new set of static closures for TS?
18:23:30 <kmc> tolkad, oh.  well T and S will each take only one word (pointer to static closure)
18:23:34 <kmc> tolkad, it might
18:23:37 <kmc> check the code
18:23:48 * Eduard_Munteanu remembers to coerce his wgetpaste to accept hpaste.org
18:23:49 <tolkad> I can't get ghc-core to install
18:23:56 <tolkad> it says I'm missing C library pcre
18:24:06 <ddarius> tolkad: ghc-core is just a pretty-printer.
18:24:09 <kmc> then install C library pcre
18:24:21 <copumpkin> or just ask ghc to show you the core
18:24:32 <WStude> done. It's called Lab_Exercise
18:24:38 <Eduard_Munteanu> WStude: link
18:24:47 <WStude> http://hpaste.org/41161/lab_exercise
18:24:51 <monochrom> perhaps it is called libpcre3-dev
18:24:54 <WStude> under 6
18:25:08 <copumpkin> WStude: you can't write if,then without else
18:25:09 <ddarius> I don't think core will help much for this question though.
18:25:24 <WStude> .......wow. cant believe I forgot that....
18:25:49 <monochrom> you see why I say "if without else is damaging".
18:26:07 <WStude> alright, thanks copumpkin
18:26:15 <tolkad> kmc: Thanks! that worked
18:26:38 <tolkad> I have been trying to get that to install for weeks
18:26:57 <djahandarie> What is wrong with just dump-core?
18:27:08 <ddarius> djahandarie: The user.
18:27:10 <monochrom> there is no "just dump-core"
18:27:13 <tolkad> idk, someone told me to use ghc-core last time I asked something about this
18:27:13 <djahandarie> Well
18:27:23 <tolkad> well, something like this
18:27:25 <kmc> ghc-core is handy
18:27:29 <kmc> but you can do  ghc -ddump-simpl
18:27:31 <monochrom> I use "-ddump-simpl" or something.
18:28:01 <monochrom> it is not a very guessable name.
18:28:16 <djahandarie> A lot of the time I just dump everything possible
18:28:17 <ddarius> -dp@ssw0rd
18:28:22 <alex404__> Woo. My pure restricted boltzmann machine works!
18:28:28 <djahandarie> And navigate through the files as needed
18:28:36 <alex404__> Just... had to tell people who might understand.
18:28:43 <tolkad> what is this
18:28:48 <tolkad> it isn't haskell
18:28:55 <djahandarie> It's core.
18:28:56 <kmc> tolkad, could it be... core?
18:31:14 <Eduard_Munteanu> It's hardcore.
18:32:05 <tolkad> this is barely anything like haskell
18:32:10 <kmc> no, it's pretty close
18:32:11 <djahandarie> It's pretty similiar.
18:32:18 <kmc> it's mostly a subset
18:32:22 <tolkad> there's all these colons
18:32:25 <tolkad> and @s
18:32:28 <kmc> also has explicit type applications
18:32:30 <kmc> which are written with @
18:32:32 <tolkad> and something called "letrec"
18:32:35 <kmc> i'm not sure which colons you refer to
18:32:57 <tolkad> lvl12_sWf =  : @ Char showList__2 s_ak6
18:33:13 <tolkad> in a let
18:33:20 <kmc> is that just the (:) constructor?
18:33:36 <kmc> in core everything is prefix, and parens around operator names aren't used
18:33:42 <alpounet> what's the GHC version on the great language shootout ?
18:33:43 <Eduard_Munteanu> Mostly I think it's expanded dictionaries and complete module dot function/types names
18:34:27 <tolkad> it will have function type signatures and then just say "GblId"
18:34:38 <djahandarie> alpounet, 6.12.1
18:34:39 <copumpkin> autogenerated names
18:34:50 <alpounet> thanks djahandarie 
18:35:16 <Eduard_Munteanu> I suppose those showList and that sorta stuff is typeclass dictionary in some sort of "resolved" form?
18:35:16 <djahandarie> Trying to beat one of the existing scripts?
18:35:38 <Eduard_Munteanu> or...
18:35:41 <Eduard_Munteanu> :t showList
18:35:41 <lambdabot> forall a. (Show a) => [a] -> String -> String
18:35:44 <Eduard_Munteanu> Ah.
18:36:05 <aavogt> @src Show
18:36:05 <lambdabot> class  Show a  where
18:36:05 <lambdabot>     showsPrec :: Int -> a -> ShowS
18:36:05 <lambdabot>     show      :: a   -> String
18:36:05 <lambdabot>     showList  :: [a] -> ShowS
18:36:18 <djahandarie> (ShowS being String -> String)
18:36:32 <aavogt> Eduard_Munteanu: the  showList is in there because     instance Show a => Show [a]     is 'evil'
18:36:32 <ddarius> showList is the hack that makes show "foo" work.
18:37:08 <Eduard_Munteanu> show = id :: String -> String ?
18:37:09 <monochrom> isn't ghc core exciting!
18:37:15 <alpounet> djahandarie, i'm actually wondering why we're so slow on two of them
18:37:16 <Eduard_Munteanu> Gr, no.
18:37:18 <Eduard_Munteanu> Damn.
18:37:23 <Eduard_Munteanu> It's additional quoting.
18:37:46 <Eduard_Munteanu> > show $ show "Hi"
18:37:47 <lambdabot>   "\"\\\"Hi\\\"\""
18:37:55 <aavogt> it could do  show "abc" = "['a','b','c']"
18:38:13 <aavogt> > read "['a','b','c']" :: [Char]
18:38:14 <lambdabot>   "abc"
18:38:23 <aavogt> > read "['a','b','c']" :: String
18:38:23 <lambdabot>   "abc"
18:38:40 <tolkad> kmc: it's hard to tell but I don't think it works. I think it will end up using two words
18:39:10 <djahandarie> It'd be interesting to see the shootout benchmarks using LLVM
18:39:16 <tolkad> aavogt: why is that evil?
18:39:21 <Eduard_Munteanu> show x = "\"" ++ x ++ "\""    :: String -> String        -- what about this then? :/
18:39:47 <alpounet> djahandarie, definitely
18:39:51 <Eduard_Munteanu> I mean, why evil? :)
18:39:55 <tolkad> aavogt: just use overlapping instances!
18:39:55 <kmc> Eduard_Munteanu, escapes?
18:39:55 <ddarius> I don't think core gives you the information to make a verifiable determination on that.
18:40:11 <tolkad> ddarius: oh
18:40:20 <tolkad> ddarius: this thing is impossible to understand
18:40:30 <Eduard_Munteanu> kmc: yes, those look fine to me, are they somehow wrong?
18:40:31 <tolkad> like look at this:
18:40:34 <tolkad> main2 =
18:40:36 <tolkad>   $wshowsPrec 0 TA SA ([] @ Char)
18:40:40 <ddarius> tolkad: I've seen core before.
18:40:59 <tolkad> :t showsPrec
18:41:00 <lambdabot> forall a. (Show a) => Int -> a -> String -> String
18:41:00 <monochrom> notice that overlapping instances just tells you your code is accepted but doesn't tell you how choices are made by the compiler.
18:41:08 <kmc> tolkad, lots of people will claim that Haskell is impossible to understand, too
18:41:12 <kmc> turns out, things can be learned
18:41:47 <tolkad> kmc: I know. But I think I would need to know assembly first, which I don't
18:41:59 <Eduard_Munteanu> @let showEvil x = "\"" ++ x ++ "\""
18:42:01 <lambdabot>  Defined.
18:42:06 <Eduard_Munteanu> > showEvil "foo"
18:42:07 <lambdabot>   "\"foo\""
18:42:09 <kmc> to understand core?
18:42:13 <kmc> core is not close to assembly
18:42:13 <Eduard_Munteanu> > show "foo"
18:42:14 <lambdabot>   "\"foo\""
18:42:25 <ddarius> Which is why it doesn't answer your question.
18:42:26 <tolkad> kmc: the entire second half of the file is assembly
18:42:34 <kmc> tolkad, yes, the half which is not core
18:42:40 <tolkad> oh
18:42:41 <kmc> ghc-core outputs lots of things
18:42:42 <aavogt> > showEvil "foo\" "
18:42:43 <lambdabot>   "\"foo\" \""
18:42:53 <aavogt> Eduard_Munteanu: look broken?
18:42:55 <tolkad> well where is core documented?
18:43:06 <Eduard_Munteanu> > show "foo\" "
18:43:07 <lambdabot>   "\"foo\\\" \""
18:43:15 <Eduard_Munteanu> Hm, yeah.
18:43:15 <kmc> it is very easy to understand assembly, in terms of syntax and saying what each line does
18:43:27 <kmc> it is very hard to learn to read a big chunk of assembly and see what it does holistically
18:43:58 <ddarius> It's very hard to read a big chunk of any code and see what it does.  In fact it is probably much easier in assembly simply because assembly is less dense.
18:45:19 <tolkad> ddarius: depends on what kind of code
18:45:58 <tolkad> ddarius: complex mathemetical calculations would probably be hard to understand if the code didn't indicate their purpose
18:46:07 <copumpkin> not really
18:46:16 <Eduard_Munteanu> Core is more like running CPP on a C file, or looking at the SSA form or HIR tree, not like assembly.
18:46:21 <tolkad> copumpkin: I mean understand their purpose
18:46:27 <copumpkin> so do I :P
18:46:37 <Eduard_Munteanu> CPP = C preprocessor
18:46:38 <tolkad> ddarius: but something like a parser is easy to understand
18:46:39 <copumpkin> but I dunno, maybe some ridiculous algorithm might be hard
18:46:51 <ddarius> tolkad: I don't know why you are talking to me.
18:47:03 <tolkad> ddarius: I'm responding to <ddarius> It's very hard to read a big chunk of any code and see what it does.  In fact it is probably much easier in assembly simply because assembly is less dense
18:47:06 <tolkad> nevermind
18:49:18 <tolkad> I have found myself a bit confused by the order in which to apply monad transformers
18:49:42 <Eduard_Munteanu> And thought core translation would help? :D
18:49:49 <tolkad> no, different topic
18:50:13 <aavogt> tolkad: are you familiar with @unmtl?
18:50:20 <tolkad> aavogt: no
18:50:27 <tolkad> @unmtl MaybeT IO
18:50:27 <lambdabot> err: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
18:50:32 <tolkad> @unmtl MaybeT IO a
18:50:32 <lambdabot> IO (Maybe a)
18:50:37 <tolkad> oh, that's nice
18:50:46 <tolkad> @unmtl MaybeT (StateT s IO) a
18:50:47 <lambdabot> s -> IO (Maybe a, s)
18:51:07 <tolkad> @unmtl StateT (MaybeT IO) a
18:51:08 <lambdabot> err: `StateT (MaybeT IO) a' is not applied to enough arguments.
18:51:14 <tolkad> @unmtl StateT s (MaybeT IO) a
18:51:14 <lambdabot> s -> IO (Maybe (a, s))
18:51:28 <aavogt> and \bot even answers private messages
18:51:57 <tolkad> so I guess you usually have to think of them backwards
18:53:18 <aavogt> yeah, if it's container-ish, the FooT modifies the inside
18:53:36 <aavogt> *leftmost
19:03:25 <alex404> @src iterate
19:03:25 <lambdabot> iterate f x =  x : iterate f (f x)
19:04:03 <monochrom> I see that I missed an opportunity to chip in my "core is like ____"
19:04:10 <monochrom> core is like burritos
19:05:17 <roconnor> @pl (\_ x -> x)
19:05:18 <lambdabot> const id
19:07:21 <kisielk_home> okay, total Haskell n00b here.. but say I have a function that divides even numbers by 2, is there some way I can still have the function return an Integral type ?
19:07:45 <copumpkin> use div
19:07:54 <copumpkin> > 5 `div` 2
19:07:55 <lambdabot>   2
19:08:11 <kisielk_home> ah, perfect
19:23:05 * Eduard_Munteanu has to go o/
19:44:59 * edwardk waves hello
19:47:26 * hackagebot monad-coroutine 0.6 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.6 (MarioBlazevic)
19:49:11 <edwardk> Control.Cofunctor ? *twitch*
19:51:27 * hackagebot scc 0.6 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.6 (MarioBlazevic)
19:54:28 * hackagebot coroutine-enumerator 0.1 - Bridge between the monad-coroutine and enumerator packages.  http://hackage.haskell.org/package/coroutine-enumerator-0.1 (MarioBlazevic)
19:55:00 <FunctorSalad_> edwardk: don't worry, apparently it just has Control.Cofunctor.Ticker ;)
19:55:21 <edwardk> FunctorSalad_: hah
19:55:49 <FunctorSalad_> oh wait, I misunderstood your concern
19:56:22 <edwardk> mostly just twitching on the 'cofunctor = functor' thing ;)
19:56:33 <FunctorSalad_> yeah
19:57:12 <FunctorSalad_> (or ambiguous name for 'contrafunctor'...)
19:57:31 <ddarius> Functor^coop
19:57:45 <edwardk> well, co is a pretty crappy abbreviation for contra, lest you not be able to tell the difference between covariant and contravariant ;)
20:00:06 <ddarius> Sch ~ Rng^op
20:00:18 <ddarius> er CRng
20:00:38 <fengshaun> How can I fix this type error? http://hpaste.org/41164/type_error
20:01:01 <fengshaun> I'm trying to give joinRoots a [Int], but it doesn't accept it!
20:05:52 <monochrom> "No instances for (Floating Int, RealFrac Int) arising from a use of `joinRoots'"  So who *uses* joinRoots?
20:06:04 <monochrom> squareFactors uses joinRoots.
20:06:32 <monochrom> what trick is squareFactors playing? it prepares a list and give to joinRoots.
20:06:51 <edwardk> joinRoots?
20:06:51 <monochrom> what is the type of that list?
20:07:03 <monochrom> the type of that list is [Int].
20:07:18 <monochrom> You are using joinRoots as though it is [Int]->Int
20:08:00 <monochrom> can you do "map (blahblah . sqrt)" to [Int]? can you do sqrt to Int?
20:08:02 <monochrom> No.
20:08:20 <monochrom> @type sqrt
20:08:21 <lambdabot> forall a. (Floating a) => a -> a
20:08:30 <monochrom> @type floor
20:08:30 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:09:12 <monochrom> you do "floor . sqrt" to Int, you are forcing Floating Int and RealFrac Int.
20:09:47 <edwardk> > map (floor . sqrt . fromIntegral) [1,2,3 :: Int]
20:09:48 <lambdabot>   [1,1,1]
20:09:51 <monochrom> which is what the error message says. the error message says everything I say. don't tell me the error message is unhelpful. I can't do better than it.
20:17:59 <wjt> ** (bustle:13706): CRITICAL **: gtk2hs_store_get_impl: assertion `GTK2HS_IS_STORE(store)' failed
20:18:36 <wjt> well, the "no segfaults" honeymoon couldn't last forever :D
20:22:20 <ddarius> That's not a segfault and its in FFI code.
20:27:56 <wjt> ddarius: no, the next line (which i didn't paste) is a segfault. :)
20:28:19 <EvanR> segfaults really piss me off
20:28:24 <EvanR> in haskell
20:28:26 <wjt> (failing gobject checked casts normally quickly lead to disaster)
20:29:49 <wjt> time to see what's up...
20:35:16 <lars9> is it possible to use zipper in a graph structure?
20:35:25 <lars9> seems not...
20:37:24 <fengshaun> monochrom, edwardk: sorry, I wasn't here!  How can I fix it?
20:37:52 <monochrom> edwardk says something like (... floor . sqrt . fromIntegral)
20:38:09 <fengshaun> so fromIntegral?  I'll try that then!
20:38:43 <edwardk> monochrom: i just now connected what you were doing with fengshaun's question ;)
20:39:44 <fengshaun> edwardk, so joinRoots = read . concat . map (show . floor . sqrt . fromIntegral) still doesn't work
20:39:53 <fengshaun> with the same error
20:40:04 <lars9> if we have a 2D table, the elements need to be updated frequently, what's the efficient way? generate a whole new table seems not
20:40:16 <EvanR> concat .: map == concatMap
20:40:17 <edwardk> i was just answering a comment by monochrom, i didn't actually notice your code paste ;)
20:40:31 <EvanR> :t concatMap
20:40:32 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
20:40:44 <fengshaun> > map (show . floor . sqrt . fromIntegral) [1, 2, 3 :: Int]
20:40:45 <lambdabot>   ["1","1","1"]
20:40:48 <edwardk> what is join roots supposed ot do?
20:41:07 <EvanR> concatMap f xs = xs >>= f
20:41:28 <fengshaun> it takes two perfect squares and concatenates their square roots
20:41:40 <fengshaun> so [36, 49] -> 37
20:42:03 <edwardk> > map (floor . sqrt . fromIntegral) [36,49]
20:42:04 <lambdabot>   [6,7]
20:42:07 <fengshaun> EvanR, thanks, I'll try that
20:42:09 <edwardk> 67?
20:42:19 <fengshaun> yes, sorry
20:42:34 <edwardk> > concatMap (show . floor . sqrt . fromIntegral) [36,49]
20:42:35 <lambdabot>   "67"
20:42:50 <fengshaun> hmmm let me try it
20:43:48 <fengshaun> edwardk, Oh finally, I just needed to change the sig to [Int] -> Int and add fromIntegral
20:44:05 <fengshaun> damn, I should really learn this casting stuff, thanks a lot!
20:44:39 <fengshaun> aha, it's working!
20:48:02 <tolkad> can someone explain this to me? http://www.reddit.com/r/programming/comments/e0qqc/learn_you_a_haskell_zippers/c14h8ey
20:48:13 <tolkad> it doesn't seem logical
20:48:27 <tolkad> I'm confused
20:48:30 <augur> hey peeps
20:49:38 <augur> alright people
20:49:39 <EvanR> what is a 'functional future value' ?
20:50:05 <augur> who has an interest in Categories in Computer Science?
20:50:15 <edwardk> tolkad: i think seppler9000 started doing hits of acid somewhere between the first and second paragraph
20:50:34 <ddarius> Never too late to start doing tabs.
20:52:36 <tolkad> Evanr: A value with some purpose that exists in the future
20:52:39 <zkoch> I just read the second chapter of Learn You a Haskel... and so I figured I would try it out. So I have two variables defined called lincoln and lincoln' where lincoln is a string and lincoln' is a reverse of that string. And then I want to get a list of all the possible combinations of characters between these two strings, so I did: getGreplin = [ forward ++ reverse | forward <- lincoln, reverse <- lincoln' ]. But this doesn't work.. Can someone explain why 
20:52:40 <zkoch> idiot?
20:52:55 <augur> anyone?
20:53:25 <edwardk> zkoch: define the 'combinations of characters between those two strings. do you mean, one character from the first, one from the second?
20:53:52 <tolkad> zkoch: because the type of ++ is [a] -> [a] -> [a]
20:54:09 <edwardk> > (,) <$> "hello" <*> "olleh"
20:54:10 <lambdabot>   [('h','o'),('h','l'),('h','l'),('h','e'),('h','h'),('e','o'),('e','l'),('e'...
20:54:31 <tolkad> @let lincoln = ['a'..'z']
20:54:32 <lambdabot>  Defined.
20:54:42 <tolkad> @let lincoln' = reverse lincoln
20:54:43 <lambdabot>  Defined.
20:54:53 <edwardk> > [ (x,y) | x <- lincoln, y <- lincoln' ]
20:54:54 <lambdabot>   [('a','z'),('a','y'),('a','x'),('a','w'),('a','v'),('a','u'),('a','t'),('a'...
20:55:16 <tolkad> > concatMap [ [forward, reverse] | forward <- lincoln, reverse <- lincoln' ].
20:55:17 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:55:19 <tolkad> > concatMap [ [forward, reverse] | forward <- lincoln, reverse <- lincoln' ]
20:55:20 <lambdabot>   Couldn't match expected type `a -> [b]'
20:55:20 <lambdabot>         against inferred type `[a1]'
20:55:29 <tolkad> wait what
20:55:31 <edwardk> > [ [x,y] | x <- lincoln, y <- lincoln' ]
20:55:32 <lambdabot>   ["az","ay","ax","aw","av","au","at","as","ar","aq","ap","ao","an","am","al"...
20:55:34 <tolkad> :t concatMap
20:55:35 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
20:55:42 <tolkad> oh
20:55:49 <tolkad> > concat [ [forward, reverse] | forward <- lincoln, reverse <- lincoln' ]
20:55:50 <lambdabot>   "azayaxawavauatasaraqapaoanamalakajaiahagafaeadacabaabzbybxbwbvbubtbsbrbqbp...
20:55:50 <tolkad> whoops
20:55:56 <tolkad> there we go
20:56:27 <zkoch> Okay, I need to catch up here...
20:56:56 <tolkad> zkloch: you were trying to concat two characters together, ++ can only concat lists
20:57:32 <tolkad> zkloch: and even if you put them in a list, you end up with a list of lists
20:57:44 <zkoch> Ah, right, got it.
20:58:17 <zkoch> I was looking at the example from the chapter where he has two lists with adjectives and nouns and then does [adjective ++ " " ++ noun | adjective <- adjectives, noun <- nouns] to concat those together
20:58:50 <zkoch> So I was trying to apply the same logic, but I see where my thinking went wrong
20:59:03 <edwardk> zkoch: thats all that matters in the end =)
21:06:52 <tolkad> I have been looking at the omega programming language and it seems cool. Are there any plans to add level polymorphism to haskell?
21:08:20 <lars9> is Data.Tree provided for programmers or for other libs?
21:08:38 <stepkut> lars9: it is for anyone who wants it..
21:08:41 <monochrom> Data.Tree is provided for everyone
21:09:00 <EvanR> it belongs to the people
21:09:02 <monochrom> note that "other libs" is a special case of "programmers"
21:09:28 <lars9> monochrom: yeah it is
21:10:26 <tolkad> it would be cool to be able to do data Bool :: level n. *n = False | True
21:11:23 <lars9> zipper can only be used for the data structure in which there is only one way from an elem to another?
21:12:13 <rndm> newbie question: is there a way to extract a value from an adt inline? like a cross between a where and a pattern match?
21:12:43 <EvanR> > (\(_,x,_) -> x) (4,6,3)
21:12:44 <lambdabot>   6
21:13:04 <rndm> lambda expression the only way?
21:13:13 <EvanR> fieldnames
21:13:30 <EvanR> or make a observation function (implemented with pattern matching)
21:13:50 <rndm> which is equivalent to fieldnames but less automatic i guess
21:13:57 <rndm> so it sounds like fieldnames
21:14:00 <EvanR> middle (_,x,_) = x
21:14:16 <EvanR> thats basically field names
21:14:21 <stepcut> EvanR: were we talking about happstack-state / MACID the other day? or was that someone else ?
21:14:29 <EvanR> i was talking to someone
21:14:33 <EvanR> about it
21:14:44 <lars9> @hoogle (a,b,c) -> b
21:14:44 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
21:14:44 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
21:15:05 <stepcut> EvanR: there is a tiny bit of a tutorial now, http://www.happstack.com/docs/crashcourse/HappstackState.html
21:15:09 <EvanR> stepcut: i did some reading, and ultimately it seems to come down to a cost vs requirements thing. how much room do i need, and can i afford it
21:15:15 <stepcut> EvanR: not enough to answer all your questions though
21:15:40 <EvanR> without replication i would need several computers to hold several gigs of data
21:15:44 <stepcut> EvanR: yeah, a lot of those issues will be better addressed in happstack 7
21:16:16 <stepcut> or one really big computer.. you *can* get computers with 1TB or more of RAM these days.. just not cheaply :)
21:16:42 <EvanR> so a single web app could probably go with ram. but the company database with mostly archival data would not make sense
21:16:44 <mtnviewmark> oh - are there Happstack folks here?
21:17:02 <mtnviewmark> I'm looking for the person who got it to work with dynamic plugins
21:17:03 <EvanR> if the web app wasnt expecting to store much data
21:17:15 <EvanR> speed vs room
21:17:17 <EvanR> vs $
21:17:27 <stepcut> mtnviewmark: that would be me.. there is also the #happs channel
21:17:40 <mtnviewmark> excellent - I'll ask you there
21:17:43 <EvanR> currently we have a web app which has a lot of room, and is damn slow
21:17:49 <EvanR> on mysql
21:18:24 <stepcut> EvanR: well, there are several different data points. For a small app, using MACID can provide rapid develop -- which is a win. For very large apps, MACID can (hopefully) provide more predictable query times -- which is important. 
21:18:50 <stepcut> EvanR: if you want cheap storage, and variance is not an issue, then SQL can be a fine way to go
21:19:04 <EvanR> i like relational
21:19:08 <EvanR> i hate mysql
21:19:16 <EvanR> and sql somewhat
21:19:16 <tolkad> why?
21:19:36 <tolkad> yeah, sql just isn't webscale
21:19:46 <stepcut> EvanR: if you look at a huge site, like facebook, they still keep more than 80% of their working data set in RAM -- and then spend a lot of time trying to minimize variance, even if it lowers overall throughput. As long as it is predicatble.
21:19:56 <EvanR> sql not being webscale is really a misguided rant against mysql
21:20:07 <EvanR> stepcut: with memcache or what
21:20:22 <mtnviewmark> sql isn't webscale? well.. not if you are Google or Amazon... but there are a zillions of big sites that use it!
21:20:47 <EvanR> i do not buy the intended message that relational databases are not webscale
21:20:48 <tolkad> mtnviewmark: you need to use a nosql database like mongodb if you want to really be webscale
21:21:29 <tolkad> with a nosql database you are free. you aren't forced to stick to some schema
21:21:37 <tolkad> you just define fields as you need them
21:21:41 <mtnviewmark> well, again "really webscale" is relative - I know many HUGE webscale companies that use SQL databases
21:21:50 <EvanR> is tolkad really saying this?
21:21:58 <stepcut> mtnviewmark: what is interesting is to look at *how* they use it. facebook uses it. But they don't use transactions, the mostly have tables with only two rows. And they don't do joins in SQL. They read the rows into memcached and do the joins in PHP. Even though PHP is much slower, they can add many more PHP frontends than they can scale up with sql backends
21:22:04 <tolkad> EvanR: :P
21:22:14 <stepcut> ebay also does not use transactions I believe
21:22:20 <EvanR> your humor is very serious soundin
21:22:36 <mtnviewmark> stepcut - indeed - transactions are generally right out - but facebook's model isn't the only one
21:22:48 <FunctorSalad_> "<EvanR> sql not being webscale is really a misguided rant against mysql" <-- actually the video is pretty obviously pro-sql :O
21:22:49 <Cale> Hey guys, I'm afraid that category theory isn't webscale. I've heard that model theory is better, you just plug it in and it scales right up.
21:23:04 <EvanR> what video
21:23:13 <FunctorSalad_> the webscale one
21:23:17 * mtnviewmark <- was more than somewhat involved in the largest virtual world implementation -- and it used SQL!
21:23:33 <EvanR> FunctorSalad_: i guess were talking about a video i didnt think was that popular
21:23:36 <mtnviewmark> not that I'm advocating SQL as a panacea - just don't throw the baby out with the bath water
21:23:39 <FunctorSalad_> Cale: just add some large cardinal axioms
21:23:40 <Cale> Relational algebra is too slow.
21:23:41 <FunctorSalad_> o_O
21:23:44 <FunctorSalad_> webscale cardinals
21:23:46 <Cale> ;)
21:23:49 <mtnviewmark> sometimes, SQL is just what you need - and it can be made to get pretty darn huge if needed
21:23:54 <stepcut> mtnviewmark: yep
21:24:15 <FunctorSalad_> EvanR: I thought the video was the origin of 'webscale'
21:24:19 <stepcut> mtnviewmark: but for everything else there is MACID :p
21:24:23 <EvanR> i would not know
21:24:40 <FunctorSalad_> but it could well be that it was just mocking a preexisting word
21:24:58 <tolkad> SQL zealots will tell you to "shard" your database claiming it will make it webscale. Well, let's look up "shard" in the dictionary: "a fragment, esp. of broken earthenware.". Do you want your database to be BROKEN? with nosql there is no need for breaking anything. it just works and scales all by itself
21:25:02 <EvanR> in my mind the json xpath-like stuff provided by mongodb is inappropriate unless you mash your problem into that form
21:25:22 <EvanR> which most people like to do anyway
21:25:29 <EvanR> because they have no idea what their data really is
21:25:39 <EvanR> they think its naturally object oriented
21:25:43 <EvanR> isnt everything?
21:27:27 <tolkad> EvanR: the reason OOP is used so widely is because it can model any system
21:28:01 <FunctorSalad_> "<edwardk> tolkad: i think seppler9000 started doing hits of acid somewhere between the first and second paragraph" *nod*
21:28:17 <EvanR> tolkad: at a fraction of the cost?
21:28:18 <tolkad> for examplelook at the elegance of this solution: http://en.wikipedia.org/wiki/Multiple_dispatch#Java
21:28:43 <tolkad> EvanR: with support from an organization you can trust
21:31:35 <tolkad> EvanR: tell me how you would use the singleton pattern in haskell?
21:31:44 <tolkad> EvanR: doesn't really make sense, does it?
21:31:56 <tolkad> EvanR: yet another thing OOP can model that haskell can't
21:32:04 <EvanR> this is painful
21:32:12 <Cale> tolkad: haha
21:32:36 <EvanR> its hilarious but i cant laugh
21:34:32 <EvanR> make a static class to hold your data
21:34:55 <EvanR> pass the class around
21:35:23 <EvanR> run a method to get a reference to the static class so you can use it
21:35:40 <EvanR> its worse than cobol
21:38:05 <tolkad> EvanR: well at least it has instanceof. Once something is an existential in haskell you can't do anything with it. In Java you can use instanceof to figure out what it is at runtime. This allows for a more agile programming style: make your parameter types "Object" and then worry about what types you will actually pass to them later
21:38:17 <roconnor> this wikipedia article is confusing me
21:38:31 <EvanR> tolkad: wait, do you have a running list of these?
21:38:34 <EvanR> i want it
21:38:35 <tolkad> roconnor: it's just multi parameter type classes
21:38:44 <tolkad> EvanR: nah I don't
21:41:12 <augur> so guys
21:41:15 <augur> i scanned a book
21:41:20 <augur> for anyone who wants it
21:41:47 <augur> its called Categories in Computer Science
21:42:02 <roconnor> I usually make my parameters type variables and worry about the types later ^_^
21:42:11 <EvanR> augur: the authorities are on their way
21:42:15 <augur> :P
21:42:29 <EvanR> do not attempt to leave the premises
21:42:43 <tolkad> roconnor: but then you cant use reverse-polymorphism with instanceof
21:43:03 <EvanR> tolkad: ok, what about reflection?
21:43:07 <roconnor> why would I do that. I'd lose my free theorems ^_^
21:43:58 <FunctorSalad_> tolkad: are you serious about java being better than haskell due to 'instanceof'?
21:44:07 <EvanR> lol FunctorSalad_ 
21:44:14 <tolkad> FunctorSalad_: well, not just that.
21:44:16 <FunctorSalad_> first, like roconnor said, it breaks parametricity
21:44:25 <FunctorSalad_> second, there's Typeable if you want that behaviour in haskle
21:44:41 <EvanR> this is a third order troll
21:44:50 <tolkad> FunctorSalad_: Typeable is too hard to use for the average programmer. Java takes a less elitist approacher
21:45:22 <roconnor> finally, #haskell gets trolling :D
21:46:05 <djahandarie> It's usually the regulars trolling anyways
21:46:35 <FunctorSalad_> tolkad: I find it rather nice that in haskell, you have the guarantee that a function of a type like 'a -> b -> a' can't do anything but return its first arg (or wantonly diverge)
21:46:59 <FunctorSalad_> mandatory runtime type reflection would break that
21:47:10 <tolkad> FunctorSalad_: in Java instanceof is safe. In haskell you could cause a runtime crash by combining Typeable with package-qualified imports
21:47:28 <EvanR> hahahah
21:47:33 <FunctorSalad_> what :o
21:48:03 <EvanR> haskells support for duck typing is pretty primitive
21:48:11 <augur> http://wellnowwhat.net/transfers/Categories%20in%20Computer%20Science%20-%20Gray%20and%20Scedrov.pdf (42.66MB)
21:48:14 <augur> if anyones interested.
21:49:00 <EvanR> tolkad: how do you feel about anonymous delegates
21:49:44 <FunctorSalad_> it can be hard to tell whether tolkad is engaging in trollery
21:49:58 <tolkad> EvanR: Java has the Runnable interface, just as good as haskell's solution
21:50:01 <FunctorSalad_> *illegal trollery
21:50:16 <EvanR> FunctorSalad_: higher order trolling
21:50:17 <roconnor> FunctorSalad_: what does it mean combining Typable with package-qualified imports?
21:50:24 <Rotaerk> hmm need a naming suggestion; in F# I've created some operators:  optionalValue1 |?| lazy optionalValue2 |?| lazy optionalValue3 |? lazy defaultValue
21:50:36 <FunctorSalad_> Rotaerk: I didn't bring it up
21:50:43 <FunctorSalad_> s/Rotaerk/roconnor
21:50:50 <EvanR> EvanCarroll: wrong person
21:50:52 <EvanR> oops
21:50:56 <FunctorSalad_> and I don't see how it'd break it
21:51:02 <Rotaerk> |? is coalesce of course, since it resolves an option to a non-option, using a default
21:51:04 <roconnor> FunctorSalad_: but you claimed it was hard to tell if tolkad was trolling
21:51:09 <Rotaerk> but |?| is kind of an "or"
21:51:16 <Rotaerk> so I'm thinking "tryCoalesce" or "orMaybe"
21:51:32 <Rotaerk> (these operators correspond to named functions)
21:51:35 <roconnor> |?| is mplus
21:51:42 <FunctorSalad_> roconnor: are you saying that it's obvious nonsense?
21:51:43 <tolkad> roconnor: I mean types are distinguished in the Data.Typeable API using strings. You are supposed to use the full module path of your type, for example "Data.Int.Int". you could get two types with the same type-string in scope using package qualified imports
21:51:59 <Rotaerk> hmm so perhaps Option.plus
21:52:12 <FunctorSalad_> tolkad: I thought it used Int keys actually
21:52:41 <roconnor> |? is fromMaybe I think
21:52:43 <roconnor> @type fromMaybe
21:52:44 <lambdabot> forall a. a -> Maybe a -> a
21:52:54 <roconnor> well flip fromMaybe
21:52:59 <FunctorSalad_> tolkad: data TypeRep = TypeRep !Key TyCon [TypeRep] 
21:53:10 <tolkad> FunctorSalad_: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Typeable.html#v%3AmkTyCon
21:53:14 <FunctorSalad_> please don't make up fud :o
21:53:51 <magicman> > typeOf (undefined :: Int)
21:53:52 <lambdabot>   Int
21:54:08 <jmcarthur> omg tolkad just decided to be a troll all of a sudden?
21:54:16 <FunctorSalad_> mkTyCon str = TyCon (mkTyConKey str) str
21:54:23 <EvanR> all of a sudden?
21:54:34 <roconnor> anyhow, Scrap your Boilerplate is a crap way to program.
21:54:35 <roconnor> IMHO
21:54:40 <FunctorSalad_> tolkad: though it seems you may be right after all if mkTyConKey is deterministic
21:54:41 * djahandarie agrees with roconnor
21:54:45 * jmcarthur too
21:54:51 * FunctorSalad_ disagrees
21:54:59 <Rotaerk> I looked into SYB and it seemed ... messy
21:55:01 * copumpkin disagrees with both parties
21:55:03 <jmcarthur> i have used uniplate for epic hax before
21:55:06 <copumpkin> ...just to be contrary
21:55:07 <roconnor> McBride agrees with roconnor
21:55:13 <FunctorSalad_> roconnor: it may not be nice but are you seriously going to collect all names from a HsBindsLR BY HAND?
21:55:20 <copumpkin> roconnor: reductio ad conorum?
21:55:23 <jmcarthur> and it was indeed very concise
21:55:25 <djahandarie> God agrees with djahandarie
21:55:27 <roconnor> copumpkin: yes
21:55:29 * Rotaerk agrees with Rotaerk.
21:55:32 <jmcarthur> but i would not use it in anything remotely complicated
21:55:33 <EvanR> SYB provides the missing support for c++ template programming right
21:55:43 <copumpkin> nope
21:55:46 <jmcarthur> EvanR: no
21:55:53 <roconnor> EvanR: Templete Haskell provides missing support for C++ template programming
21:55:55 <copumpkin> template programming is covered by typeclasses mostly, minus the specialization
21:55:57 <FunctorSalad_> roconnor: (I'm talking about one of the haskell AST types in ghc here)
21:56:01 <roconnor> FunctorSalad_: what is HsBindsLR?
21:56:11 <EvanR> i didnt think so
21:56:13 <FunctorSalad_> just a random example I came across earlier
21:56:35 <jmcarthur> EvanR: SYB is basically a way to dig deep into a data structure of arbitrary complexity and pick out nodes with certain criteria
21:56:54 <jmcarthur> EvanR: and it uses all sort of Typeable magic to get there
21:56:55 <FunctorSalad_> roconnor: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/HsBinds.html#t%3AHsBindLR
21:56:57 <fengshaun> how can I uniquify a list?
21:57:03 <jmcarthur> nub?
21:57:04 <copumpkin> fengshaun: nub
21:57:09 <FunctorSalad_> something close to the toplevel of a haskell ast, anyway
21:57:10 <roconnor> fengshaun: unique
21:57:13 <roconnor> @type unique
21:57:14 <lambdabot> Not in scope: `unique'
21:57:15 <jmcarthur> why is it called nub, anyway?
21:57:18 <roconnor> @hoogle unique
21:57:18 <lambdabot> module Data.Unique
21:57:18 <lambdabot> Data.Unique data Unique
21:57:18 <lambdabot> Data.Unique hashUnique :: Unique -> Int
21:57:20 <fengshaun> roconnor, yea, not in scope
21:57:21 <roconnor> er
21:57:23 <copumpkin> jmcarthur: cause only nubs use it
21:57:24 <roconnor> fengshaun: sorry
21:57:26 <roconnor> fengshaun: nub
21:57:29 <roconnor> @hoggle nub
21:57:29 <lambdabot> Data.List nub :: Eq a => [a] -> [a]
21:57:29 <lambdabot> Data.List nubBy :: (a -> a -> Bool) -> [a] -> [a]
21:57:33 <tolkad> anyway, I have a serious question. In haskell when you are processing a large data structure lazily from some IO thing how do you deal with a parse error somewhere in the middle?
21:57:35 <EvanR> the etimology of nub
21:57:36 <FunctorSalad_> roconnor: note that that thing contains even more homungous types as components
21:57:38 <fengshaun> roconnor, copumpkin: thanks
21:57:42 <EvanR> haskell lore lost to time
21:57:44 <FunctorSalad_> writing the traversal by hand would be a nightmare
21:57:48 <tolkad> throw an exception?
21:57:52 <copumpkin> tolkad: it's tough, but usually yeah
21:58:09 <EvanR> tolkad: i thought you were being serious
21:58:13 <FunctorSalad_> roconnor: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/HsExpr.html#t%3AHsExpr
21:58:19 <roconnor> FunctorSalad_: I've been using Uniplate in my latest project.  It has worked nicely so far.
21:58:28 <copumpkin> I like uniplate
21:58:33 <copumpkin> I'd like more generics options though
21:58:40 <FunctorSalad_> roconnor: well ok if you're comparing syb vs uniplate I can't comment due to lack of having used the latter
21:58:42 <jmcarthur> i like it. for one shot hacks, mainly
21:58:45 <FunctorSalad_> I'm comparing syb vs nothing.
21:58:47 <tolkad> copumpkin: it's kind of unsafe, that means you have to check for the exception everywhere you pass that unsafeInterleaveIO'd data structure
21:58:56 <roconnor> FunctorSalad_: Uniplate is mostly Haskell 98
21:59:01 <copumpkin> tolkad: yep, and I'm not sure what to do about it :/
21:59:21 <jmcarthur> tolkad: if you are doing complex things with unsafeInterleaveIO then maybe you could think about doing those complex things with iteratee?
21:59:24 <FunctorSalad_> is Uniplate automatically derivable?
21:59:36 <FunctorSalad_> (by TH if not by builtin functionality)
21:59:38 <djahandarie> uniplate is all Haskell 98 unless you want some of the more advanced features
21:59:38 <roconnor> FunctorSalad_: it can be.
21:59:51 <copumpkin> it magically inherits from Data
21:59:55 <copumpkin> if you import the right module
21:59:56 <jmcarthur> FunctorSalad_: it can use the syb machinery for a slow version or some other thing for a fast version
22:00:12 <jmcarthur> FunctorSalad_: and the some other thing i'm pretty sure could be automagic in theory
22:00:36 <copumpkin> someone's working on generic automatic deriving for GHC
22:00:47 <jmcarthur> yeah that could be nice
22:00:56 <roconnor> FunctorSalad_: but I've written my Biplates by hand.
22:01:02 <tolkad> jmcarthur: if your data structure is recursive that can be hard
22:01:06 <FunctorSalad_> btw I'm trying to use that AST to make a variable renamer
22:01:11 <FunctorSalad_> like in visual studio
22:01:13 <jmcarthur> tolkad: what can be?
22:01:17 <copumpkin> roconnor: real men use magnetized needles though
22:01:22 <tolkad> jmcarthur: processing it incrementally
22:01:34 <tolkad> jmcarthur: like, an XML file for example
22:01:54 <roconnor> copumpkin: The problem is that I have some syntactic subexprssion that are not semantic subexpressions.
22:01:54 <jmcarthur> tolkad: http://hackage.haskell.org/package/libxml-enumerator
22:01:58 <FunctorSalad_> any ideas how to write the changes? currently I'm planning to only read from the AST, and if I find a matching name, take its SrcLoc and blindly trust it
22:01:59 <copumpkin> tolkad: it's a tough question
22:02:09 <roconnor> copumpkin: and automagic derivations wouldn't get this correct
22:02:10 <FunctorSalad_> replacing the specified characters in the file by the new name
22:02:16 <copumpkin> roconnor: ah
22:02:27 <roconnor> quoteing an expression is not actually an expression.  It is more like a literal.
22:02:33 <roconnor> (this langauge has quotes and evals in it)
22:02:34 <FunctorSalad_> the alternative would be to somehow modify and reprettyprint the AST
22:02:44 <jmcarthur> tolkad: also http://hackage.haskell.org/package/expat-enumerator
22:02:48 <FunctorSalad_> but sadly the prettyprinter doesn't always produce actual haskell last time I checked
22:03:04 <jmcarthur> tolkad: and http://hackage.haskell.org/package/hexpat-iteratee
22:03:26 <roconnor> FunctorSalad_: anyhow, I do agree that generic programming is important.
22:03:43 <roconnor> FunctorSalad_: and it is something Haskell is poor at
22:03:57 <FunctorSalad_> I find syb pretty easy to use actually
22:04:11 <FunctorSalad_> just use gmapQ or gmapT
22:04:16 <FunctorSalad_> instead of the more confusing schemes
22:04:25 <roconnor> I find the lack of type safety disturbing
22:04:55 <FunctorSalad_> (gmapQ only looks at the immediate children, giving you control over the traversal)
22:05:19 <roconnor> FunctorSalad_: just like Uniplate's decend function
22:05:32 <roconnor> anyhow
22:05:37 <roconnor> way past my bed time
22:05:42 <roconnor> see all y'all later
22:05:46 <tolkad> Ωmega looks cool. Will it eventually get a good compiler?
22:05:48 <FunctorSalad_> see ya
22:05:57 <tolkad> comparable to ghc
22:06:16 <tolkad> I don't know much about how well new languages like this do
22:06:16 * jmcarthur shrugs
22:06:45 <jmcarthur> i like omega too, but i have no idea how well it will do
22:09:20 <FunctorSalad_> tolkad: do you have an actual example of the Typeable problem? It does something funny with unsafePerformIO, not quite sure what it'd do with identical names
22:10:32 <FunctorSalad_> toplevel even
22:11:10 <tolkad> FunctorSalad_: no, I just thought of it on the spot I have no idea if it's true
22:11:30 <tolkad> FunctorSalad_: I didn't realize they use Ints at the time
22:11:43 <FunctorSalad_> tolkad: TypeReps do have a hidden Int member, but I'm not sure what exactly its relation to the string is
22:12:04 <FunctorSalad_> if the int is a function of the string, you're right
22:20:19 <FunctorSalad_> tolkad: oh god you're right
22:20:35 <FunctorSalad_> just made ghc asplode that way
22:21:54 <FunctorSalad_> (segfault)
22:24:18 <monochrom> real men pay $10 to a grad student to write a whole OS.
22:24:42 <FunctorSalad_> darcs get http://code.haskell.org/~daniels/TypeableTest
22:24:59 <FunctorSalad_> cabal install both testpkg1 and testpkt2, then compile and run "Boom.hs"
22:25:34 <FunctorSalad_> it's only using "deriving Typeable", not custom instance
22:25:39 <FunctorSalad_> @tolkad
22:25:39 <lambdabot> Unknown command, try @list
22:25:58 <FunctorSalad_> +a
22:26:31 <Jafet> Real grad students can eat for half a year on $10.
22:28:03 <lars9> is Arrow useful?
22:28:34 <lars9> @instances Typeable
22:28:35 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
22:28:57 <lars9> @instances-importing Typeable
22:28:57 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
22:30:55 <FunctorSalad_> tolkad: you might want to report a bug
22:41:02 <pygmalion> hi folks, would anyone be willing to take a look at a problem assigned by my teacher for me? i have a solution posted with it as well, i'm just not sure exactly what he's asking. http://hpaste.org/41165/question
22:50:03 <kfish> pygmalion, what is the type of >>= ?
22:50:44 <pygmalion> kfish: m a -> (a -> m b) -> m b
22:52:04 <copumpkin> m a -> Cont (m b) a!
22:54:20 <kfish> pygmalion, what don't you understand about the teacher's question?
22:55:04 <pygmalion> kfish: i guess i'm just not clear on what he wants to be returned. so is the string after failure to be an error string?
22:55:30 <pygmalion> kfish: i.e. is that how he wants to "immediately return" it
22:55:42 <kfish> what is it for some other monad?
22:55:42 <copumpkin> pygmalion: it should get "passed on"
22:56:05 <pygmalion> copumpkin: what do you mean?
22:56:09 <pygmalion> kfish: what is what?
22:56:13 <pygmalion> the string?
22:56:18 <copumpkin> pygmalion: a failure early in the computation invalidates the entire thing
22:56:33 <pygmalion> copumpkin: isn't that what he's asking for?
22:56:49 <copumpkin> pygmalion: meaning if the first statement of a program in this monad is Failure, then the entire program should result in Failure...
22:57:04 <pygmalion> copumpkin: ah right right yeah i see that
22:57:15 <copumpkin> do you see how to implement it?
22:57:27 <pygmalion> copumpkin: how is that different from the Maybe monad?
22:57:43 <copumpkin> it's almost exactly Maybe, except it keeps an error message, apparently
22:59:02 <pygmalion> copumpkin: is that what he seems to be looking for? the line "successes get passed along by >>=, but failures are immediately returned" is still throwing me. i assumed that immediately returned and what the maybe monad does (which is just passing the Nothings through the chain) were different
22:59:21 <copumpkin> not really any different, as far as I can see
22:59:29 <copumpkin> it's also the only pure thing you can do, really :)
22:59:50 <copumpkin> but if your Failure a >>= f case "returns immediately"
22:59:54 <copumpkin> that means it doesn't evaluate f, right?
22:59:58 <copumpkin> what can it return then
23:00:04 <copumpkin> all it has is Failure a
23:00:30 <pygmalion> copumpkin: doesn't it just want to return error a?
23:00:44 <copumpkin> error isn't a pure Haskell value and should be avoided wherever possible
23:00:48 <copumpkin> since it can't be caught easily
23:01:03 <pygmalion> oh. so should i just be returning a?
23:01:13 <copumpkin> nope, what's the type of the thing you need to return?
23:01:22 <pygmalion> m b
23:01:26 <copumpkin> more specifically?
23:01:40 <pygmalion> a function of a value?
23:01:52 <copumpkin> Conditional b is what I meant :)
23:01:59 <pygmalion> oh i see haha sorry
23:02:00 <copumpkin> anyway
23:02:10 <copumpkin> what values do you have of that type, in the Failure a >>= f case?
23:02:37 <pygmalion> none
23:02:41 <copumpkin> really?
23:02:47 <copumpkin> what's the type of Failure a?
23:03:09 <pygmalion> oh i guess the whole thing is Conditional
23:03:32 <pygmalion> i.e. Failure a is b in "Conditional b"
23:04:04 <copumpkin> it is? what's Failure a constructor of?
23:04:33 <copumpkin> what's the type of Failure "moo", for example?
23:05:03 <pygmalion> Conditional...i thought?
23:05:18 <copumpkin> yeah, Conditional a, for any type a
23:05:33 <copumpkin> you said it's `b` in `Conditional b`, before though
23:05:49 <pygmalion> oh right. i see. duh.
23:06:15 <copumpkin> so do you see what the complete >>= definition is?
23:06:20 <copumpkin> you don't have much freedom, but you do have a bit
23:06:22 <jmcarthur> i must be tired
23:06:41 <jmcarthur> i want to call Cont this: (<-)
23:07:17 <jmcarthur> m a -> (m b <- a)   :P
23:07:31 <copumpkin> :o
23:07:38 <pygmalion> copumpkin: i just f Failure a?
23:07:53 <copumpkin> what was that? :P
23:07:56 <copumpkin> write the whole clause
23:08:12 <jmcarthur> i accidentally a f Failure a
23:08:20 <magicman> I wrote a pretty useless monad once, base on that (>>=) :: m a -> Cont (m b) a
23:08:29 <copumpkin> pygmalion: Failure str >>= f = ... ?
23:08:55 <magicman> It was brilliant. (>>=) was just the newtype destructor.
23:08:56 <pygmalion> copumpkin: yeah sorry... that wasn't english. Uh this: Failure str >>= f = f (Failure str)
23:09:02 <copumpkin> pygmalion: that doesn't typecheck!
23:09:19 <copumpkin> f wants an `a`, but you gave it a `Conditional b`
23:09:58 <copumpkin> that `a` is not free
23:10:47 <pygmalion> so Failure str >>= f = f str?
23:11:04 <copumpkin> nope
23:11:12 <copumpkin> what type does the bit after the = need to have?
23:11:17 <copumpkin> and what's the type of Failure str ?
23:11:48 <pygmalion> Failure str is Conditional b
23:12:04 <copumpkin> yep
23:12:08 <pygmalion> i want m b
23:12:12 <copumpkin> nope
23:12:15 <tolkad> FunctorSalad_: btw, I'm probably not going to bother filing a bug report. File one yourself if you want
23:12:21 <copumpkin> you're writing the instance for m = Conditional
23:12:22 <pygmalion> where f is a function (a->m b)
23:12:27 <copumpkin> so you want specifically Conditional b
23:12:37 <jmcarthur> it's a shame that it's so hard to work with graphs in haskell, especially considering that the VM is basically a huge graph
23:12:52 <copumpkin> jmcarthur: join the graphs special interest group on haskellers :)
23:12:58 <jmcarthur> i mean, i guess it's not *hard*, but it's a lot less natural than trees
23:13:47 <copumpkin> pygmalion: do you see what I mean?
23:13:54 <copumpkin> pygmalion: you're trying to be more general than you need to be
23:14:04 <pygmalion> copumpkin: i'm afraid not. 
23:14:13 <pygmalion> copumpkin: i have Failure str which is Conditional b
23:14:17 <copumpkin> pygmalion: in your definition of (>>=), f has type (a -> Conditional b), and your function needs to return Conditional b
23:14:19 <jmcarthur> i'm wanting to write a graph reducer and i was thinking about prototyping it in haskell first, but i really might as well just write it in C to begin with...
23:14:39 <pygmalion> copumpkin: okay i see that
23:14:50 <copumpkin> pygmalion: in other words, by writing instance Monad Conditional, the usual `m` for Monad is specifically Conditional, not just any Monad
23:15:09 <copumpkin> so you have a Conditional b and need to return a Conditional b
23:15:18 <copumpkin> you really only have one* option
23:15:33 <pygmalion> is it not just "Failure str"
23:15:40 <copumpkin> it is!
23:16:14 <pygmalion> oh. for some reason i feel like i had tried that so i was dismissing it. yeah that makes a lot of sense. so Failure a >>= f = Failure a
23:16:32 <copumpkin> yep
23:16:36 <copumpkin> so it's ignoring the f
23:16:42 <djahandarie> Is there a general plan on how to fix graph stuff in Haskell?
23:16:45 <copumpkin> or in other words, not continuing the computation and "returning immediately"
23:17:12 <pygmalion> copumpkin: is that identical to Maybe except instead of Nothing >>= f = Nothing, i have Failure and an additional string?
23:17:19 <copumpkin> yep
23:17:29 <copumpkin> the additional freedom I mentioned is that you could stick another string in there
23:17:39 <copumpkin> like Failure "moo"
23:17:51 <pygmalion> copumpkin: and it's as simple as that. huh. my frequent problem in learning haskell has been that i except things to be much more complicated than they are....
23:17:56 <djahandarie> Which works nicely for fail
23:18:01 <copumpkin> but it makes more sense to pass the original value around
23:18:09 <copumpkin> pygmalion: hah, haskell is surprisingly simple once you grasp the basics :)
23:18:17 <copumpkin> it's the simple bits put together that can do some awesome stuff
23:18:19 <pygmalion> copumpkin: i'm really loving it
23:18:46 <djahandarie> Why is fail in the Monad typeclass anyways? It has nothing to do with monads
23:18:51 <copumpkin> djahandarie: ugliness
23:18:57 <copumpkin> we like it
23:19:02 <copumpkin> same reason we have Num and Enum
23:19:06 <djahandarie> :P
23:19:17 * copumpkin wishes he could play liszt
23:19:46 <djahandarie> ... what did that have to do with the topic?
23:19:52 <copumpkin> nothing at all
23:19:56 <djahandarie> lol
23:19:57 <copumpkin> except it's playing on my computer right now
23:20:11 <djahandarie> I can't play any actual songs on my piano
23:20:15 <copumpkin> aw
23:20:34 <djahandarie> I'm good at piano though, as contradicatary as that sounds
23:20:45 <copumpkin> aha
23:21:00 <djahandarie> Good enough that I can play and let whoever is listening enjoy the experience
23:25:51 <Zeiris_> Has anyone played with the erlang FFI package? How stable is it?
23:31:51 <newlfie> hello
23:32:04 <copumpkin> allo!
23:32:54 <pygmalion> copumpkin: thanks again!
23:33:23 <copumpkin> pygmalion: no problem, feel free to come back with more questions :)
23:33:31 <newlfie> I just came here from tryhaskell.org
23:40:48 <qpt`> Hey guys, check out my rap vid and give me your feedback. I want to make it bigg ass fuuuuk. Hot, thanks http://www.youtube.com/watch?v=wC60h6H39Hc
23:41:32 <copumpkin> lol
23:44:22 <Jafet> Surely the local massage parlour would have sufficed
