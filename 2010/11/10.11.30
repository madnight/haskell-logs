00:00:21 <sinelaw> @hoogle interspace
00:00:22 <lambdabot> No results found
00:00:29 <sinelaw> woohoo. interspace = intercalate " "
00:07:35 * hackagebot Etage 0.1.1 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.1 (MitarMilutinovic)
00:13:47 <sinelaw> @hoogle a -> [a] -> [a]
00:13:48 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
00:13:48 <lambdabot> Data.List insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
00:13:48 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
00:20:24 <sinelaw> can I uncurry data constructors?
00:20:32 <sinelaw> @type uncurry Left
00:20:33 <lambdabot>     Couldn't match expected type `b -> c'
00:20:33 <lambdabot>            against inferred type `Either a b1'
00:20:33 <lambdabot>     In the first argument of `uncurry', namely `Left'
00:20:42 <sinelaw> oops
00:20:55 <ivanm> except there's no need to uncurry Left...
00:21:04 <ivanm> @type uncurry (:)
00:21:06 <lambdabot> forall a. (a, [a]) -> [a]
00:21:12 <sinelaw> yes, silly me.
00:21:21 <sinelaw> i forgot that uncurry works only for 2-tuples
00:21:28 <sinelaw> 2 args. whatever.
00:22:17 <sinelaw> howzit, ivan ?
00:22:23 <sinelaw> ivanm, that is.
00:24:44 <ivanm> not bad, yourself?
00:25:47 <sinelaw> same
00:26:13 <sinelaw> writing a code generator
00:26:43 <sinelaw> i have an rpc Java <-> .NET here at work
00:26:54 <sinelaw> with type safety
00:27:33 <sinelaw> currently i generate the classes on both ends using a T4 templates (a visual studio thing) but they really suck
00:27:41 <sinelaw> plus some ugly C# code
00:28:47 <sinelaw> i'd like to get on top of awesomeprelude sometime
00:28:56 <sinelaw> and program only in haskell, even when it's actually C# or Java :)
00:31:14 <ivanm> in case you still care, I'm hoping to be able to try and get multiple augmentation of graphs in graphviz happening early next year
00:31:28 <ivanm> going to try switching to Text-based stuff first, see if that improves the performance
00:32:26 <sinelaw> glad to hear you're still working on that
00:32:34 <sinelaw> i've barely had time to continue that project
00:32:43 <sinelaw> but i still intend to go back to it eventually :)
00:39:40 <turiya> i have installed wxHaskell but i am unable to load the module Graphics.UI.WX, any suggestions?
00:42:43 * hackagebot text 0.10.0.1 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.10.0.1 (BryanOSullivan)
00:46:10 <ddarius> Yay, shotwell is quite a bit better than F-spot.
00:47:46 <ion> It is? Nice. Iâ€™ve been meaning to try it some day.
00:52:46 * hackagebot text 0.11.0.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.11.0.0 (BryanOSullivan)
00:55:47 * hackagebot text-icu 0.6.3.1 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.1 (BryanOSullivan)
01:05:32 <ivanm> turiya: how did you install it?
01:05:55 <ivanm> and what's the error that you get?
01:08:40 <turiya> ivanm: i did cabal install wx --global as root
01:08:40 <turiya> when i type :m Graphics.UI.WX, it says could not find module
01:12:12 <ivanm> turiya: does "ghc-pkg list wx" show it?
01:12:22 <ivanm> any particular reason for using --global?
01:35:36 <Eduard_Munteanu> I'm a bit confused, will a ByteString make a difference over normal String IO when processing a file char by char?
01:36:11 <Jafet> How is "char by char" significant to that question?
01:36:23 <Eduard_Munteanu> Jafet: as in not doing any random access.
01:36:32 <Eduard_Munteanu> My bad, I should've said 'sequentially'.
01:36:47 <ivanm> sounds like using an iteratee might suit
01:36:50 <Jafet> ByteString.Lazy should be at least as fast as String
01:37:08 <Jafet> And possibly more efficient
01:37:13 <Eduard_Munteanu> Jafet: I see, but I'm asking the opposite question: is it worth?
01:37:18 <Eduard_Munteanu> Jafet: why would it be?
01:37:27 <ivanm> Eduard_Munteanu: the IO aspects could be faster
01:37:42 <Jafet> Because it uses packed storage, and does IO in chunks.
01:37:42 <Eduard_Munteanu> Ah, buffering larger chunks I gather.
01:37:46 <Funktorsalat> haha awesome. this code is getting the current source filename through exceptions
01:37:48 <ivanm> though using a Bytestring requires that you only use single-byte Char values
01:37:56 <ivanm> Funktorsalat: :o
01:37:57 <Funktorsalat> http://community.haskell.org/~claus/misc/Canvas.hs
01:38:14 <Eduard_Munteanu> ivanm: yeah, I'm packing Word8s either way.
01:39:18 <Jafet> {-# OPTIONS_GHC -fno-ignore-asserts #-}
01:39:27 <Jafet> Now it has a purpoe
01:39:29 <Funktorsalat> I'd use, but $( lift . loc_filename =<< location ) ;)
01:39:43 <Funktorsalat> * I'd use $( lift . loc_filename =<< location ), but ;)
01:40:04 <Eduard_Munteanu> I'd try a CPP trick.
01:40:07 <Eduard_Munteanu> :)
01:40:38 <Jafet> Is there a similar way to get the current executable filename
01:40:42 <Jafet> I'm all ears
01:41:21 <Eduard_Munteanu> I think looking in /proc would be a way, but non-portable.
01:41:28 <ddarius> Oh my god
01:41:29 <Funktorsalat> Jafet: System.Environment.getProgName maybe
01:41:42 <ivanm> Funktorsalat: I think he meant via an exception
01:43:55 <Eduard_Munteanu> What would I use for C-like bitwise operations? I'd like some assurance it doesn't compile to something else.
01:44:16 <Eduard_Munteanu> I'm interested for Word8s and such.
01:44:56 <JoeyA> import Data.Word; import Data.Bits (I think those are what you want)
01:45:00 <dmead> Eduard_Munteanu, google is your friend
01:45:01 <dmead> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/Data-Bits.html
01:45:09 <Eduard_Munteanu> Like, I don't want code like 'if (foo & 1)' to end up like 'if (odd foo)'
01:45:23 <Eduard_Munteanu> dmead: I've seen that. Is it efficient?
01:45:36 <dmead> Eduard_Munteanu, how could it not be?
01:45:50 <dmead> you think bit shifting is suddently theta(n^2) because it's haskell?
01:46:11 <ivanm> dmead: I thought it was Theta(n^2.5) actually...
01:46:12 <ivanm> :p
01:46:16 <Eduard_Munteanu> dmead: I wasn't sure of the internal representation.
01:46:34 <ivanm> Eduard_Munteanu: you could always try it and profile...
01:46:39 <Eduard_Munteanu> Like if it decides to do div 2 instead of shifting
01:46:46 <dmead> Eduard_Munteanu, if you look at the source files you'll see it uses external C calls
01:47:14 <Eduard_Munteanu> Oh.
01:47:25 <Eduard_Munteanu> Thanks, I'll try it and see if it makes a difference.
01:47:52 <dmead> what were you doing? messing with lists?
01:48:26 <Jafet> Haskell suddenly seems much more fun than C when you realize it has a Bits instance for Integer.
01:48:31 <dmead> don't stop
01:48:33 <dmead> come a little closer
01:48:45 <dmead> as we jam, the rythm gets stronger
01:48:50 <dmead> theres nothing wrong
01:48:55 <dmead> with just a little fun
01:48:59 <dmead> we were dancing
01:49:01 <dmead> all night long
01:49:07 <Eduard_Munteanu> dmead: no, I was doing it in terms of, e.g., division by 2 instead of right shifting
01:49:35 <dmead> ah
01:49:56 <Eduard_Munteanu> And yeah, I'm using lists to generate my data, then pack it into Word8s but I don't think that's bad, is it?
01:49:57 <dmead> you'd think the compiler would convert that to shifting anyway
01:50:28 <dmead> probably reasonable
01:51:02 <Eduard_Munteanu> The C version of this thingy does the same, now I'm trying to optimize the Haskell code a bit, it's a bit slower.
01:51:18 <Eduard_Munteanu> (about 2-3 times)
01:51:29 <dmead> do you use lists in C?
01:52:07 <dmead> perhaps try and emulate the way your code works in C rather than doing it the haskell way?
01:52:21 <dmead> linked lists might be slow if you're using arrays in C
01:52:26 <ivanm> Eduard_Munteanu: yes, but how much shorter (in terms of length and development time) and readable is the Haskell version over the C version?
01:52:29 <dmead> random access etc etc
01:52:39 <Eduard_Munteanu> dmead: no, of course not. I'm simply calling my packer function telling it to add the bit.
01:53:04 <Eduard_Munteanu> ivanm: indeed it's shorter in Haskell
01:53:20 <Eduard_Munteanu> dmead: that in C. But in Haskell 
01:53:34 <dmead> what in C?
01:53:36 <Eduard_Munteanu> I'm trying to leverage laziness and hoping the lists would be fused away
01:53:53 <Eduard_Munteanu> dmead: I meant calling a function to pack bits, not using lists. 
01:54:22 <dmead> yea, haskell has a bunch of overhead that can never compete with C for some things
01:54:42 <dmead> so if you've got a chunck of memory in C that remains in place it'll be really fast
01:54:55 <dmead> whereas your haskell lists might be getting copied here and there
01:54:57 <Eduard_Munteanu> I'm just trying to get it in the < 2x slower range. Currently it's about 3, max 4 times slower
01:55:01 <dmead> and the efficiency goes down the drain
01:55:28 <dmead> try using mutable arrays?
01:56:42 <Eduard_Munteanu> dmead: I'm not sure how that helps. I have some code that produces bits (a list of Bools), which I then pack into Word8s.
01:56:52 <dmead> Eduard_Munteanu, whats your code doing anyway?
01:57:35 <Eduard_Munteanu> dmead: Shannon-Fano compression. Basically I lookup codes in a tree and record the path represented by Left or Right turns. Left is False, Right is True.
01:57:44 <dmead> ah
01:57:57 <dmead> sort of like huffman trees?
01:58:07 <Eduard_Munteanu> dmead: yeah.
01:58:35 <Eduard_Munteanu> It's a school assignment, there are probably variants of those trees that don't actually need bitwise ops.
01:59:13 <dmead> gotcha
01:59:21 <dmead> what are you using to time execution?
01:59:22 <Eduard_Munteanu> (well I'm not assigned to do it in Haskell, but I'm hoping that works :) )
01:59:49 <Eduard_Munteanu> dmead: time on the Linux console, and GHC profiling
02:01:45 <dmead> wel 3-4 times slower for haskell might be the best you can do
02:01:50 <dmead> take a look at the debian langauge shootout
02:01:52 <dmead> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ghc&lang2=gcc
02:02:42 <Eduard_Munteanu> Hm yes, and some of those have been optimized to the point of unreadability, IIRC.
02:02:47 <dmead> true
02:03:04 <dmead> but thats really fast haskell
02:03:10 <dmead> and it's still alot slower than C
02:03:53 <medfly> @quote haskell faster 
02:03:54 <lambdabot> No quotes match. You untyped fool!
02:03:56 <medfly> err
02:04:03 <medfly> @quote faster than
02:04:03 <lambdabot> No quotes for this person. There are some things that I just don't know.
02:04:07 <medfly> ugh. right.
02:04:34 <medfly> @quote monochrom
02:04:34 <lambdabot> monochrom says: All numbers just sit there doing nothing.
02:04:38 <medfly> @quote monochrom
02:04:38 <lambdabot> monochrom says: MonadOr is french for Gold Monad.
02:04:41 <medfly> too many!
02:04:55 <medfly> that's the one: <monochrom> einstein's theory implies that haskell cannot be faster than c
02:05:25 <Eduard_Munteanu> Hm... I might've been mistaken...
02:05:39 <Eduard_Munteanu> real    0m0.329s          vs         real    0m2.867s
02:05:39 <dmead> Eduard_Munteanu, about?
02:05:52 <Eduard_Munteanu> dmead: it's really slower...
02:06:00 <dmead> seems so
02:06:07 <dmead> but is that a stand alone binary?
02:06:17 <Eduard_Munteanu> dmead: yes, ghc -O --make
02:06:33 <dmead> what about running in ghci?
02:06:45 <Eduard_Munteanu> Lemme try...
02:07:01 <dmead> i think alot of that is startup time for the vm?
02:07:03 <Eduard_Munteanu> dmead: hm, I wouldn't be able to 'time' it.
02:07:20 <dmead> yea. but you can see how long it takes your code to run
02:07:29 <dmead> and not include vm stuff
02:07:35 <Eduard_Munteanu> Hm, lemme see..
02:07:54 <dmead> it's like :set +s or something
02:07:57 <dmead> in ghci
02:08:06 <dmead> +r?
02:09:18 <dmead> Eduard_Munteanu, ?
02:09:41 <Eduard_Munteanu> dmead: it's way way slower in ghci
02:09:58 <ivanm> Eduard_Munteanu: _everything_ is way slower in ghci...
02:09:59 <dmead> did you set optimizations?
02:10:23 <Eduard_Munteanu> dmead: ghci -O
02:10:35 <ivanm> does ghci respect -O flags?
02:10:53 <dmead> maybe?
02:11:39 <Eduard_Munteanu> Hm, maybe I could try using the GCC backend and supply -O3 -march=native to it?
02:11:49 <dmead> it seems to like :set -O3
02:11:53 <dmead> try it?
02:12:01 <Eduard_Munteanu> Lemme try...
02:12:10 <ivanm> Eduard_Munteanu: why are you using ghci and expecting it to be efficient?
02:12:30 <dmead> xD
02:12:50 <Eduard_Munteanu> ivanm: dmead told me :)
02:13:05 <Eduard_Munteanu> dmead: nah, still slow.
02:13:27 <dmead> post your code?
02:13:29 <Eduard_Munteanu> ivanm: actually I want an efficient binary.
02:13:37 <dmead> i'
02:13:45 <dmead> i'll steal your code and put my name on it
02:13:53 <dmead> also, lunchmoney please
02:15:07 <ivanm> lol
02:15:15 <Eduard_Munteanu> http://paste.pocoo.org/show/297969/
02:15:31 <Eduard_Munteanu> (sorry for not using hpaste, wgetpaste was there)
02:16:46 <dmead> do you do changes to the tree?
02:16:46 <Eduard_Munteanu> http://hpaste.org/41948/sf
02:17:02 <Eduard_Munteanu> dmead: no, I just build it once, then do lots of lookups.
02:17:49 <dmead> what about using a binary heap instead?
02:18:52 <Eduard_Munteanu> dmead: hm the lookup _could_ be inefficient according to the profile.
02:19:13 <dmead> what you could do is insted of using an actual tree is put it into a binary heap
02:19:14 <Eduard_Munteanu> I suppose I could use arrays inside trees instead of lists.
02:19:22 <dmead> then use continuation passing style to stop eating up stack space
02:19:53 <dmead> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style
02:19:59 <Eduard_Munteanu> I see.
02:20:19 <Eduard_Munteanu> Hm, I'll try that but first, lemme get rid of stuff like unpack' = map odd . take 8 . iterate (`div` 2) for bitwise ops.
02:20:38 <dmead> yea thats probably way bad
02:20:45 <dmead> when you could be just doing a shift in constant time
02:21:40 <Eduard_Munteanu> BTW, what's a good way to convert Bools to 0 / 1? If?
02:22:15 <dmead> :t ?
02:22:16 <lambdabot> parse error on input `?'
02:22:38 <Eduard_Munteanu> :t (?)
02:22:39 <lambdabot> Not in scope: `?'
02:22:50 <dmead> thought the teriary operator was in haskell
02:23:24 <dmead> do you need the digits during your computations?
02:23:30 <dmead> or just to display the results?
02:24:41 <Eduard_Munteanu> Nah, I'm simply writing it to a file, decompress it back, and check with md5sum.
02:25:09 <dmead> > map (\x -> (if x then 1 else 0)) [True, False]
02:25:10 <lambdabot>   [1,0]
02:25:18 <dmead> > map (\x -> (if x then 1 else 0)) [True, False, True, True]
02:25:19 <lambdabot>   [1,0,1,1]
02:25:28 <shachaf> > map fromEnum [True,False,True,True]
02:25:29 <lambdabot>   [1,0,1,1]
02:25:38 <dmead> ahh
02:25:38 <Eduard_Munteanu> Oh, thanks.
02:25:51 <dmead> Eduard_Munteanu, you could also look at bytestrings
02:26:00 <dmead> instead of [Word8] or whatever
02:26:05 <dmead> anyway
02:26:08 <dmead> i have to sleep
02:26:12 <dmead> goodnight internet
02:28:08 <Eduard_Munteanu> dmead: I'm already using them for some stuff.
02:28:11 <Eduard_Munteanu> Thanks.
02:28:19 <Eduard_Munteanu> Good night, dmead.
02:31:35 <therp> interesting. I found that even hIsWritable can block.
02:31:53 <therp> and/or hIsOpen.
02:32:25 * sinelaw_ lives next to a preschool and there's a kid crying for 2 hours already
02:32:30 <sinelaw_> :(
02:33:31 <ddarius> Sounds like you need to go on a murderous rampage.
02:33:44 <sinelaw_> wha?? poor kid
02:34:01 <sinelaw_> it's not the noise that bothers me
02:34:17 <ddarius> I'm sure you can find someone worth murdering.
02:34:51 * sinelaw_ eyes ddarius cautiously
02:35:01 * Twey chuckles.
02:35:10 <sinelaw_> what continent are you on?
02:35:23 <Twey> For once, I'm glad I don't share a continent with ddarius :Ã¾
02:36:15 <therp> constant noise esp at home is terrible
02:36:19 <Eduard_Munteanu> Ok, it seems looking up the symbol in the tree node has significant overhead.
02:36:45 <medfly> sinelaw_, some kids just scream a lot, I'm told
02:37:10 <medfly> my grandma told me that my dad used to scream so much that they had to talk with the cops and such sometimes :-/
02:39:39 <sinelaw_> prossibly
02:40:26 <sinelaw_> traffic sucks, btw. 
02:40:32 <ddarius> Agreed.
02:41:14 * ddarius looks up the song "Bad Habit" by The Offspring.
02:41:19 <therp> I'm fighting with various parties to get a sound-proofing upgrade for my windows at my flat.. for like 2 years now.
02:42:45 <sinelaw_> therp, i feel you. I used to live over a major street. 
02:44:06 <therp> not too bad. I'm moving to ZÃ¼rich next month anyway
02:45:08 <sinelaw_> Zurich. cool
02:45:17 <sinelaw_> i mean, low temperature
02:47:03 <ddarius> Having my window cracked is like having my own little refridgerator in my bedroom.
02:47:09 <sinelaw_> any hot stuff 'bout Haskell diplomats in the wikileak?
02:47:22 <medfly> Haskell diplomats?
02:47:24 <therp> low? switzerland is not russia :) but I'm not changing latitude that much
02:47:28 <sinelaw_> ;)
02:52:41 <Eduard_Munteanu> Is there a binary search for Seq?
02:58:03 <shachaf> Is there a reasonable way to represent an unordered pair?
03:00:53 <romildo> Is the "regexec" function common to all regex implementations based on regex-base? In other words, can I write a program using regexec and switch the regex implementation later on?
03:00:53 <quicksilver> shachaf: I would just use a newtyped pair with appropriate instances.
03:01:20 <shachaf> quicksilver: I don't mean for practical use.
03:01:22 <ivanm> quicksilver: in that case, mightn't you as well use a new datatype altogether?
03:01:40 <ivanm> romildo: is it class-based?
03:02:55 <quicksilver> shachaf: there isn't anything very clever, no.
03:03:22 <quicksilver> shachaf: set-theoretically your choice is either ordered pairs under an equivalence relation, or multi-sets with cardinality 2.
03:03:33 <quicksilver> shachaf: neither of those has particularly "nice" properties.
03:03:51 <quicksilver> if you assume an ordering there is of course a natural way.
03:04:33 <Eduard_Munteanu> Grr... It looks like Data.Map has efficient lookups, but I have a Data.Sequence at hand.
03:04:51 <Eduard_Munteanu> I suppose it wouldn't be efficient to make a Map from a Seq just to look up.
03:05:05 <shachaf> Eduard_Munteanu: A Seq of what?
03:05:10 <romildo> ivan, No, it is not class-based. Its type in module Text.Regex.TDFA.String is:
03:05:11 <romildo> regexec :: Regex -> String -> Either String (Maybe (String, String, String, [String]))
03:05:14 <quicksilver> Eduard_Munteanu: Data.Seq has efficient lookups too.
03:05:26 <quicksilver> Eduard_Munteanu: can you explain at all what you're trying to do.
03:05:35 <Eduard_Munteanu> shachaf: tuples, also they're already ordered.
03:06:03 <Eduard_Munteanu> quicksilver: yes, well I have a Seq with a order on it. I want some sort of binary search, or something efficient at least.
03:06:07 <quicksilver> Data.Seq and Data.Map is a strange comparison because Seq is value only and Map is key-value
03:06:23 <quicksilver> perhaps you should be comparing Data.Seq to Data.Set?
03:06:34 <quicksilver> Eduard_Munteanu: binary search on Seq is quite efficient.
03:06:41 <Eduard_Munteanu> quicksilver: how do I do it?
03:06:44 <romildo> ivan, It has similar types in other modules, like Text.Regex.TDFA.String and  Text.Regex.PCRE.String, and Text.Regex.Posix.String
03:06:45 <quicksilver> you just do it.
03:06:52 <quicksilver> you're a programmer, write the program.
03:07:03 <Eduard_Munteanu> quicksilver: oh ok, I was looking if there's something already implemented.
03:07:22 <ivanm> romildo: sounds like it's something that is implemented in all of them, but there's no real guarantees
03:07:30 <quicksilver> Eduard_Munteanu: in the 14 minutes since you first asked, you could have already written it twice :)
03:07:45 <Eduard_Munteanu> Hm, yeah, that's true.
03:08:21 <quicksilver> converting to Data.Set, assuming that's what you really meant, is a one-time O(n log n) cost
03:08:34 <mornfall> That attitude is a double-edged sword.
03:08:38 <quicksilver> and makes lookups slightly faster (log n < log k log n)
03:08:50 <Eduard_Munteanu> quicksilver: I still need the ordering.
03:09:03 <quicksilver> Eduard_Munteanu: I still don't understand.
03:09:13 <quicksilver> what are you actually trying to do.
03:09:14 <Eduard_Munteanu> quicksilver: isn't Set an unordered set?
03:09:24 <quicksilver> not really
03:09:29 <quicksilver> Set is a set ordered by Ord
03:09:33 <quicksilver> in effect.
03:09:46 <quicksilver> if that isn't the ordering you want, of course, it's wrongly ordered.
03:10:45 <Eduard_Munteanu> quicksilver: I have a Tree a (Node a) (Node a). 'a' is currently a list of something that tells me how to go through the tree on lookups, but that's a bottleneck.
03:11:45 <ddarius> @google polymorphic quotient containers
03:11:47 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.4046&rep=rep1&type=pdf
03:11:47 <lambdabot> Title: Constructing Polymorphic Programs with Quotient Types
03:11:56 <ddarius> For shachaf 
03:12:00 <quicksilver> Eduard_Munteanu: what are Tree and Node?
03:12:12 <quicksilver> are they constructors or types?
03:12:30 <Eduard_Munteanu> quicksilver: uhm, sorry, data Tree a = Empty | Node a (Tree a) (Tree a)
03:12:43 <quicksilver> OK.
03:12:55 <quicksilver> and you're working with a tree of lists, as in Tree [b], right?
03:12:59 <Eduard_Munteanu> Yes.
03:13:01 <shachaf> ddarius: Ah.
03:13:05 <quicksilver> and what are you trying to do?
03:13:06 * shachaf looks
03:13:14 <shachaf> ddarius: I was trying to figure out what "T^2/2" would mean.
03:13:51 <Eduard_Munteanu> quicksilver: I'm currently looking up in each of the children to decide which path to take, e.g. if the left children contains my lookup key, I go left. But using 'any (key ==)' on lists is really bad according to profiling.
03:14:20 <Eduard_Munteanu> I'm thinking I could convert store Maps instead of lists there.
03:14:28 <Eduard_Munteanu> *convert/store
03:14:34 <romildo> Can haddock be used to produce documentation in a print friendly file format, like pdf?
03:15:01 <tibbe> .
03:15:09 <quicksilver> Eduard_Munteanu: OK, if you're using any (key ==) then fastest lookup is Data.Set; but you're worried about losing the ordering, yes?
03:15:13 <Eduard_Munteanu> quicksilver: here's my code, it's a bit sucky at the moment: http://hpaste.org/41948/sf
03:15:58 <Eduard_Munteanu> quicksilver: a bit, actually since the list is preordered I'm concerned that I might lose an advantage.
03:16:28 <quicksilver> Eduard_Munteanu: you can construct a Set fast from a pre-ordered list using Data.Set.fromAscList
03:17:19 <Eduard_Munteanu> Hm, O(n log n) sounds good considering I'm only doing this when building the tree.
03:17:34 <Eduard_Munteanu> quicksilver: thanks, I'll try the Set stuff first.
03:17:48 <quicksilver> I don't understand why you have a Tree with ordered lists at each node though ;)
03:18:22 <Eduard_Munteanu> quicksilver: I'm more or less trying to follow the ideas layed out in my assignment, they aren't really made for functional code.
03:18:50 <quicksilver> ok
03:18:54 <quicksilver> fair enough!
03:19:11 <Eduard_Munteanu> quicksilver: the ordering is a mere artifact of building those Seqs.
03:19:54 <Eduard_Munteanu> (and I needed Seqs to follow the assignments idea of going through an array from both ends to find a "midpoint")
03:20:34 <quicksilver> ok, well if the Seqs aren't in their natural ordering
03:20:40 <quicksilver> then you can't use Data.Set without extra work.
03:20:47 <quicksilver> Data.Sets are ordered by the Ord instance.
03:21:05 <quicksilver> You could store a pair of Set and Seq, treating the Set as unordered and just using it for fast membership tests
03:21:14 <quicksilver> but that might be overhead that's not worth it.
03:21:49 <Eduard_Munteanu> I have a Seq of (Word8, Int), and it's sorted in descending order by the second component.
03:22:32 <Eduard_Munteanu> Lookup is by Word8, so I don't think I should really care.
03:22:49 <Eduard_Munteanu> I realised that now. :)
03:23:46 <Eduard_Munteanu> quicksilver: anyway, thanks, I'll go with Set.
03:27:36 * hackagebot kit 0.5.2 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.5.2 (NickPartridge)
03:54:41 <Eduard_Munteanu> Bah, optimizing this is pissy.
03:55:25 * Eduard_Munteanu can't seem to go below 8-9x C code time.
03:57:12 <lars9> Eduard_Munteanu: how about mem?
03:57:26 <lars9> also 8-9x c?
03:57:48 <Eduard_Munteanu> Memory consumption is bad too.
03:58:22 <Eduard_Munteanu> total alloc = 6,456,171,160 bytes  (excludes profiling overheads)
03:58:42 <lars9> too much update?
03:59:13 <Eduard_Munteanu> lars9: I don't really do much updates. Just lazily converting input to output.
03:59:31 <lars9> Eduard_Munteanu: we need a haskell machine.
03:59:43 <Eduard_Munteanu> Most of the time is spent doing stuff that involves lookups and no updates at all.
04:01:16 <Eduard_Munteanu> lars9: I'm probably expecting too much from deforestation.
04:01:18 <lars9> Eduard_Munteanu: once i reimplemented my python program in C, and it became slower... because the hash lib i found for C is too crapy
04:04:23 <quicksilver> Eduard_Munteanu: compiling with -O2 ?
04:05:46 <Eduard_Munteanu> quicksilver: -O or -O2 doesn't make much difference. I also added -funbox-strict-fields and annotated my tree, it's a bit better but not much.
04:06:01 <ManateeLazyCat> New version Manatee fix some bugs, improve code to protected core won't crash even you send malformed DBus message to core. Integrated (Download-Manager) with browser. Right click, select "Download" will call download manager. You can also type url in "search interface" to download file directly. Enjoy! :)
04:06:05 <Eduard_Munteanu> *annotated with ! in the node value.
04:08:04 * hackagebot manatee-core 0.0.6 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.6 (AndyStewart)
04:08:06 * hackagebot manatee-anything 0.0.6 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.6 (AndyStewart)
04:08:08 * hackagebot manatee-browser 0.0.6 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.6 (AndyStewart)
04:08:10 * hackagebot manatee-editor 0.0.6 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.6 (AndyStewart)
04:08:12 * hackagebot manatee-filemanager 0.0.6 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.6 (AndyStewart)
04:08:52 <exDM69> what is Manatee?
04:09:12 <ManateeLazyCat> exDM69: Depend on you how to use it. :)
04:09:14 * hackagebot manatee-pdfviewer 0.0.6 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.6 (AndyStewart)
04:09:16 <Jafet> What are you writing, eduard?
04:09:16 * hackagebot manatee-mplayer 0.0.6 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.6 (AndyStewart)
04:09:18 * hackagebot manatee-ircclient 0.0.6 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.6 (AndyStewart)
04:09:20 * hackagebot manatee-processmanager 0.0.6 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.6 (AndyStewart)
04:09:22 * hackagebot manatee-imageviewer 0.0.6 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.6 (AndyStewart)
04:09:48 <Eduard_Munteanu> Jafet: Shannon-Fano compression.
04:10:25 * hackagebot manatee-reader 0.0.6 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.6 (AndyStewart)
04:10:27 * hackagebot manatee-curl 0.0.6 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.0.6 (AndyStewart)
04:10:29 * hackagebot manatee 0.1.2 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.2 (AndyStewart)
04:10:54 <Jafet> Oh, that suboptimal one.
04:10:57 <lars9> is it LZ like?
04:10:58 <ManateeLazyCat> exDM69: http://hackage.haskell.org/package/manatee
04:11:02 <Eduard_Munteanu> Jafet: http://hpaste.org/41952/sf2
04:11:46 <Eduard_Munteanu> Jafet: basically the compression gets a list of bools (by looking up the codes for each symbol in a tree) and packs it into Word8s.
04:11:49 <exDM69> ManateeLazyCat: checking it out
04:12:04 <quicksilver> exDM69: something like an application framework for cooperating GUI applications, in haskell, using GTK as toolkit.
04:12:04 <Eduard_Munteanu> lars9: not really.
04:12:16 <Eduard_Munteanu> lars9: more like Huffman.
04:12:27 <quicksilver> exDM69: so far it seems to be half way between lotus notes and emacs, but in haskell :)
04:12:39 <ManateeLazyCat> quicksilver: Build quickbot answer when people ask "What's Manatee?" :)
04:12:46 <sipa> Eduard_Munteanu: why not huffman?
04:12:48 <Jafet> That code's a bit too long for me to read
04:12:54 <Eduard_Munteanu> Actually the C variant isn't very fast either, but still about 8-9 times faster than Haskell.
04:12:59 <Jafet> What does cost-center profiling suggest?
04:13:07 * hackagebot typehash 1.4.0.1 - Create a unique hash value for a type.  http://hackage.haskell.org/package/typehash-1.4.0.1 (LennartAugustsson)
04:13:16 <quicksilver> Jafet, Eduard_Munteanu: also, what %age time is GC time?
04:13:28 <Eduard_Munteanu> sipa: it's an assignment I did in C, I'd like to do it in Haskell.
04:13:45 <sipa> Eduard_Munteanu: i see
04:14:05 <Jafet> Well, don't ask me.
04:15:30 <Eduard_Munteanu> http://hpaste.org/41953/profiling
04:16:08 <Eduard_Munteanu> quicksilver, Jafet: ^ profiling data
04:16:25 <quicksilver> Eduard_Munteanu: also let's see +RTS -sstderr
04:16:30 <ManateeLazyCat> Now starting thinking "perfect dynamic customize" solution, you guys can customize Manatee in next version. :)
04:16:34 <quicksilver> Eduard_Munteanu: that gives MUT time vs GC time.
04:16:47 <ManateeLazyCat> Maybe need perfect package 'pdynload' first. :)
04:17:54 <quicksilver> Eduard_Munteanu: well, "pack" is a very big offender there.
04:18:17 <ManateeLazyCat> exDM69: Watch video first, then understand what's it. :) Video at : http://www.youtube.com/watch?v=weS6zys3U8k (select 720p HD version) 
04:18:24 <quicksilver> Eduard_Munteanu: I'm sure you can do better than repeated right shifts.
04:18:38 <exDM69> ManateeLazyCat: I did take a look at the screenshots.
04:19:00 <quicksilver> Eduard_Munteanu: there's probably some good bit packing code on hackage, but if not, it should be faster to do this:
04:19:01 <exDM69> ManateeLazyCat: no video on crappy mmobile connection
04:19:02 <Eduard_Munteanu> quicksilver: yeah, that became apparent after optimizing the lookup code a bit more.
04:19:23 <Eduard_Munteanu> But I do a similar thing in C too.
04:19:37 <ManateeLazyCat> exDM69: Hehe, you can't feeling "integrated" idea if you just see screenshot. :)
04:19:42 <quicksilver> let [a,b,c,d,e,f,g,h] = eight in (if a then 128 else 0 .|. if b then 64 else 0 .|. if c then 32 else 0 .|. .... )
04:19:55 <quicksilver> and try with + instead of .|. that might be faster.
04:20:10 <exDM69> ManateeLazyCat: is the architecture based on the Yi paper "dynamic applications from ground up"?
04:20:17 <silver> ooooh the song is so sweet
04:20:25 <ManateeLazyCat> quicksilver: BTW, do you use paredit for lisp coding? I suggest you use it, automatic complete bracket and smart jump. :)
04:20:25 <exDM69> or something like it?
04:20:42 <quicksilver> Eduard_Munteanu: not really that similar, to be honest. That haskell code does a lot more work than the C equivalent.
04:20:43 <ManateeLazyCat> exDM69: No.
04:20:46 <Eduard_Munteanu> quicksilver: http://hpaste.org/41954/sstderr 
04:20:54 <ManateeLazyCat> exDM69: It's new framework.
04:21:00 <quicksilver> ManateeLazyCat: yes, although not consistently. I don't do much elisp coding. paredit is great though.
04:21:02 <exDM69> same ideas?
04:21:17 <Eduard_Munteanu> quicksilver: hm, that looks an awful lot like the Duff thingy
04:21:26 <ManateeLazyCat> quicksilver: I plan write Haskell version paredit in my editor. :)
04:21:27 <Eduard_Munteanu> I could try this unrolled variant, maybe it's faster.
04:21:32 <quicksilver> ManateeLazyCat: good.
04:22:42 <ManateeLazyCat> exDM69: You can consider : Manatee = Chrome (sandbox) + Emacs (behaviour) + Firefox (Extension policy) + GTK+ (Render engine) + Haskell (Concurrent) + Me (Idea) + #haskell (help) . :)
04:23:12 <exDM69> cool
04:23:26 <exDM69> gotta look at the video when I get home
04:23:38 <exDM69> does it have a Vim mode? :)
04:23:54 <ManateeLazyCat> exDM69: You can add any application in it, it's open framework. :)
04:24:21 <ManateeLazyCat> exDM69: The correct answer to "What's Manatee?" should be : Depend on you how to use it. :)
04:24:48 <ManateeLazyCat> exDM69: You can find everything you need at : http://haskell.org/haskellwiki/Manatee
04:27:58 <Eduard_Munteanu> quicksilver: not much difference with the unrolled pack'
04:28:15 <Eduard_Munteanu> real    0m2.479s
04:28:39 <Eduard_Munteanu> $ du -sh tema2
04:28:40 <Eduard_Munteanu> 1.5M    tema2
04:29:37 <Eduard_Munteanu> by comparison the C code yields real    0m0.329s
04:29:51 <quicksilver> Eduard_Munteanu: has the profile changed though?
04:30:58 <Eduard_Munteanu> I think it's insignificant: pack                           Main                  39.0   46.3    171 373534842
04:31:10 <Eduard_Munteanu> vs now:    pack                           Main                  28.9   43.5    112 353035249
04:31:50 <cnclathe> people, the code don´t works, anybody can help?
04:31:52 <cnclathe> { main = do { (pass,students) <- readIO =<< getContents; putStrLn "(Name,Passed,Average,Maximum)";
04:31:52 <cnclathe> <aavogt> print (map (\(n,gs) -> let avg = sum gs / fromIntegral (length gs) in (n :: String, avg >= pass, avg, maximum gs)) students) };
04:31:52 <cnclathe> <aavogt> maxList (a:as) = mx a as where { mx c (a:as) | c > a = mx c as | otherwise = mx a as; mx c [] = c }}
04:31:52 <quicksilver> Eduard_Munteanu: you could try rewriting pack' to use Data.Binary.BitPut
04:31:55 <quicksilver> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/binary-strict/0.4.8/doc/html/Data-Binary-BitPut.html
04:32:30 <quicksilver> cnclathe: don't paste multiple lines in channgel please. What's the problem with the code? Do you understand what it's supposed to do?
04:32:48 <quicksilver> (and what happens)
04:32:55 <Eduard_Munteanu> quicksilver: hm thanks, that looks nice.
04:33:09 <sipa> :t readIO
04:33:10 <lambdabot> forall a. (Read a) => String -> IO a
04:33:47 <benmachine> readIO is kind of silly
04:33:58 <benmachine> it has its uses though I suppose
04:34:28 <quicksilver> Eduard_Munteanu: also, you can try Data.IntSet instead of Data.Set
04:37:13 <nostrand> quicksilver: i use boolean vectors in ST for my int sets :P
04:37:41 <quicksilver> nostrand: is that faster than data.intset?
04:38:10 * quicksilver would be surprised if it was in general. 
04:38:16 <nostrand> quicksilver: in my special case i think so
04:38:19 <quicksilver> althouhg in Eduard_Munteanu's precise case (all ints < 255) it might well be.
04:38:38 <cnclathe> quicksilver, the program dont´s works, to run the program I type (6, [("Robert", [2,5,6,7])])
04:38:38 <cnclathe> and (Name, Passed, Average, Maximum), the pro said: user error, parser.
04:38:56 <cnclathe> user error, no parser.
04:39:45 <nostrand> quicksilver: i have a smaller range and some specific operations. Eh really not sets anyway i realized :D
04:39:55 <quicksilver> cnclathe: do you understand what the code does? do you understand what it's trying to parse? Do you understand what type 'pass' and 'students' are?
04:40:09 <therp> from experimentation and reading GHC.IO.Handle.Internals it appears to me that concurrent reading (one thread blocking on read) and writing (another thread) onto a network stream is not possible. write will block until something has been read from the socket. therefore, making a read thread for each client doesn't seem to work as structural approach for a haskell network server. am I missing something here? this seems a limitation too big to be true
04:41:04 <quicksilver> therp: that's certainly the approach I've always used, and I haven't noticed a problem, but I haven't written a serious server with it.
04:41:13 <quicksilver> therp: are you talking about the new IO manager (7.0) or the old one?
04:41:59 <cnclathe> quicksilver, i not understand nothing... i don´t know haskell....
04:42:05 <therp> quicksilver: both, I think. I just upgraded to ghc-7.0 to check whether the concurrent one changes the situation.. then I only looked at the code of 7.0. the simple example http://sequence.complete.org/node/258 does not work smoothly  with ghc-7.0
04:42:15 <therp> and the example is really really simple and straight forwarda
04:42:37 <therp> accept thread + read threads + main loop thread multiplexing everything
04:43:15 <quicksilver> cnclathe: OK, well I'm not going to write a program for you. We're here to help you learn haskell, not to do work for you. 
04:43:31 <quicksilver> cnclathe: if you want to learn, feel free to ask questions and we will try to answer them.
04:44:24 <quicksilver> therp: I've written code broadly like that and not seen anomalies, although I generally turn off buffering rather than trying to remember to hFlush every time.
04:44:30 <cnclathe> quicksilver, ok, but i help you for write this program, i take that leave nat college for my apresentation...
04:44:39 <cnclathe> but, i don´t know, haskell...
04:44:48 <cnclathe> i´m desesperate...
04:45:19 <quicksilver> therp: did you look at the unix code or the windows?
04:45:27 <therp> quicksilver: also tried with NoBuffering, same result
04:45:35 <quicksilver> therp: the (old) unix code just used select(), surely it wouldn't behave like you suggest?
04:46:06 <cnclathe> quicksilver, just look my code, and help-me to execute them.
04:46:12 <cnclathe> quicksilver, just look my code, and help-me to execute him.
04:46:29 <therp> quicksilver: the problem in my opinion comes from withHandle in Internals.hs - I added a little code before hPutBuf namely hIsOpen and hIsWritable to do more checks, but those calls are blocking too when another thread is read-blocking. 
04:46:44 <quicksilver> cnclathe: sorry. I'm not going to help you if you're not going to try to understand. Maybe someone else will help you, but I doubt it.
04:47:01 <therp> quicksilver: hIsOpen/hIsWritable is wrapped withing withHandle, and I assume that there is a read-block inside another thread's withHandle, blocking the MVar
04:47:33 <quicksilver> therp: Interesting. I think you probably need JaffaCake to help you there. Or nominolo.
04:47:50 <quicksilver> therp: if you can't find the right expertise I suggest a post to g-h-u
04:48:00 <quicksilver> therp: I hope you're wrong but I don't know enough to disprove you :)
04:48:02 <cnclathe> anybody can look my code?
04:48:52 <therp> quicksilver: I hope I am wrong too. Again, this looks too serious to have gone unnoticed. I have to construct a decent test case first
04:49:05 <therp> quicksilver: thanks for your comments, though :)
04:51:31 * ManateeLazyCat Bye all, goto fix gtk2hs bug....
04:52:15 <Eduard_Munteanu> Hm what's a forM that returns the last result?
04:52:27 <cnclathe> quicksilver, just look my code...
04:52:58 <hpc> :t forM
04:52:59 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:52:59 <Eduard_Munteanu> BitPut offers no function to get the internal BitPut, so I kinda need the last result putBit generates.
04:53:17 <quicksilver> Eduard_Munteanu: "the last result"?
04:53:19 <hpc> :t sequence
04:53:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
04:53:37 <quicksilver> Eduard_Munteanu: surely you run it with runBitPut?
04:53:43 <Eduard_Munteanu> quicksilver: putBit :: Bool -> BitPut.
04:53:55 <quicksilver> Eduard_Munteanu: BitPut is a monad.
04:53:58 <Eduard_Munteanu> quicksilver: yes, but if I do forM_ how do I return the BitPut?
04:54:13 <quicksilver> forM_ myList putBut
04:54:18 <quicksilver> will have the type BitPut
04:54:20 <quicksilver> isn't that what you want?
04:54:28 <quicksilver> (modulo typos ;)
04:54:31 <Eduard_Munteanu> Hmz...
04:54:35 <Eduard_Munteanu> :t forM_
04:54:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
04:54:38 <Eduard_Munteanu> Oh.
04:54:46 <quicksilver> here m is BitPut'
04:54:51 <quicksilver> and BitPut' () is BitPut
04:54:53 <Eduard_Munteanu> Yeah, sorry, I mixed it up.
04:55:18 <quicksilver> Eduard_Munteanu: you're better off using putBits directly on your Word8s, though?
04:55:27 <quicksilver> no need to do your own bit-splitting
04:56:35 <quicksilver> ah no
04:56:40 <Eduard_Munteanu> quicksilver: well the compression takes in Word8s and produces a variable number of bits for each symbol.
04:56:41 <quicksilver> you're generating a bitStream directly
04:56:43 <quicksilver> ignore me
04:56:46 <quicksilver> yeah, sorry
04:57:16 <Eduard_Munteanu> I guess that's inefficient anyway, and any realworld algo won't operate on bits like that, right?
04:57:26 <quicksilver> forM_ (fst cdata) putBit for now
04:57:32 <Eduard_Munteanu> Yeah.
04:57:42 <quicksilver> if that still feels slow
04:57:53 <quicksilver> you can try calling putBit directly in the compress code
04:58:29 <Eduard_Munteanu> Oh noes... real    0m11.245s
04:58:34 <quicksilver> so instead of compress :: ByteString -> ([Bool],[SymCount]) you end up with ByteString -> BitPut [SymCount], I think.
04:58:38 <Eduard_Munteanu> 4 times slower now :)
04:58:46 <quicksilver> haha.
04:58:52 <quicksilver> :(
04:59:25 <therp> quicksilver: ah, just FYI, writing is ok, presumably because it doesn't use withHandle. hIsOpen blocks though, (hIsWritable isn't). Interesting.
04:59:48 <Eduard_Munteanu> quicksilver: that's what I do in C, I thought laziness would abstract it away :)
05:00:12 <quicksilver> Eduard_Munteanu: it does, but abstraction isn not always free :)
05:00:12 <therp> quicksilver: finding a proper minimal test case magically solves a lot of bugs. 
05:00:17 <quicksilver> therp: :)
05:00:19 <quicksilver> therp: I find that too.
05:02:15 <Eduard_Munteanu> quicksilver: so you think it's faster to move compression into IO?
05:02:20 <Eduard_Munteanu> *might be
05:02:25 <quicksilver> Eduard_Munteanu: I wasn't suggesting moving it into IO
05:02:33 <quicksilver> I was suggesting moving it into BitPut
05:02:45 <Eduard_Munteanu> quicksilver: well I wouldn't use BitPut, they warn about longer bitfields.
05:03:25 <Eduard_Munteanu> I was thinking maybe pack could directly write a byte to IO once it's ready.
05:03:44 <Eduard_Munteanu> Would that save any work? :/
05:04:10 <quicksilver> Eduard_Munteanu: perhaps. That's exactly what BitPut does for you.
05:04:16 <quicksilver> which is why I was suggesting it
05:04:27 <quicksilver> except "write" only to a lazy bytestring not actually write out
05:05:11 <Eduard_Munteanu> It's a bit strange, they seem to imply the layout is MSB ... LSB on the whole ByteString.
05:05:32 <cnclathe> quicksilver, cabecalho :: String, lexical error UTF-8 deconding error
05:05:33 <Eduard_Munteanu> Wouldn't that be hella inefficient?
05:05:38 <cnclathe> can help with this
05:05:38 <cnclathe> ?
05:07:19 <benmachine> Eduard_Munteanu: sometimes doing IO in batches is faster than doing it as soon as possible
05:07:32 <benmachine> (but there are software buffers for that reason, I suppose)
05:07:41 <quicksilver> cnclathe: it means you're giving it invalid UTF8 when it's expecting UTF8
05:07:50 <quicksilver> cnclathe: probably some other encoding like latin-1 or -9?
05:07:59 <Eduard_Munteanu> benmachine: yeah, ByteString should take care of that for me I think.
05:08:09 <cnclathe> what do i do so?
05:08:13 <cnclathe> quicksilver
05:08:16 <cnclathe> ?
05:09:07 <quicksilver> cnclathe: well the simplest thing is to stop sending whatever encoding you're sending, and send UTF8 instead.
05:09:32 <Azrael-> @src foldr
05:09:33 <lambdabot> foldr f z []     = z
05:09:33 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:10:33 <Azrael-> :t foldr
05:10:35 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
05:11:11 <cnclathe> quicksilver, this cabecalho = "Aluno Nota\n", its ut8?
05:11:41 <benmachine> so I'm thinking of writing a tool that explains the type checking of some expression
05:12:03 <benmachine> I wrote up this by hand as a sort of specification of the kind of output I want: http://www.srcf.ucam.org/~bm380/example.txt
05:12:21 <benmachine> I'd appreciate it if some people (especially people not that good with types!) could tell me if they think it's clear
05:12:27 <benmachine> or how it could be made more so
05:12:42 <Jafet> Randomly change a token, pass it to ghc and parse the type error?
05:12:53 <benmachine> >_<
05:13:22 <Jafet> I use that to get top-level signatures sometimes
05:13:28 <Eduard_Munteanu> Hm, my system's GHC is 6.12.3, should I expect significantly better optimizations in newer versions?
05:13:40 <Jafet> 6.12.3 is a pretty new version.
05:13:42 <Eduard_Munteanu> Gentoo Linux here, no platform.
05:13:45 <benmachine> Jafet: you can just use -fwarn-missing-something for the same effect
05:13:50 * benmachine forgets exactly what
05:13:52 <Zao> Eduard_Munteanu: The only newer is like 7.0.1, which has lots of scary package breakings.
05:14:12 <benmachine> GHC 7 does have some cases in which it is significantly faster
05:14:17 <benmachine> but no guarantees that they're yours :P
05:14:42 <Eduard_Munteanu> Hm, I see.
05:14:58 * Eduard_Munteanu also tried -fvia-c -optc -O3 -optc -march=native, not much
05:15:00 <tcatipax> http://pastebin.com/W5P0MwJR -- can anyone explain this? Seems odd.
05:15:55 <benmachine> tcatipax: I think there's an open ticket about it - basically cabal is bad at tracking dependencies that aren't libraries
05:15:57 <tcatipax> "alex" isn't found when needed as a dependency but running the command to install alex is fine
05:16:03 <tcatipax> Okay, thanks
05:16:15 <hpc> typo in the cabal file?
05:16:23 <Jafet> benmachine: it looks like you're producing a recursive breakdown of the type
05:16:31 <hpc> maybe it requested a non-existent version
05:16:55 <Jafet> benmachine: it would be nice if your program interface would reflect that
05:16:56 <tcatipax> Any version satisfies the dependency afaik.
05:16:56 <dcoutts> benmachine: not "bad", more like non-existant. cabal-install simply does not do dep planning for anything other than libs (atm)
05:17:27 <benmachine> Jafet: hmm?
05:17:33 <benmachine> dcoutts: well, non-existence is bad :P
05:17:37 <hpc> haha
05:17:52 <dcoutts> benmachine: heh
05:21:19 <cnclathe> quicksilver, idade :: Int 
05:21:20 <cnclathe> idade = 17
05:21:28 <cnclathe> parser erron on input =
05:21:29 <cnclathe> ?
05:22:07 <Jafet> benmachine: eg. unfold each part of the type to show an explanation and further breakdown
05:22:09 <quicksilver> cnclathe: in isolation that looks fine. How are you loading it? compiling in a file? loading into ghci?
05:22:39 <benmachine> Jafet: how is that different from what I'm doing now, just make the separation more clear?
05:23:12 <Jafet> benmachine: well, what you posted is a full traversal of the explanation
05:23:25 <benmachine> Jafet: right
05:23:55 <Jafet> I'd suppose that students get the simpler types first, so they can skip (not unfold) them if they want
05:24:06 <benmachine> ah
05:24:10 <Jafet> It's just a conjecture on my part
05:24:27 <cnclathe> quicksilver, compiling file, ghc projeto.hs
05:24:28 <benmachine> so you have, like, collapsible explanations
05:24:45 <benmachine> pick whatever part is unclear to you and it goes up a level of detail
05:24:52 <benmachine> for that part
05:24:54 <benmachine> or something
05:28:44 <quicksilver> cnclathe: What you pasted looked fine, can you put the whole file on http://hpaste.org/ ?
05:35:47 <cnclathe> quicksilver
05:36:00 <cnclathe> not in scope fromInt
05:36:11 <cnclathe> media n = (soma n) / (fromInt n)
05:36:23 <hpc> on hpaste, dude
05:36:25 <cnclathe> error, not in scope: fromInt
05:37:27 <benmachine> did you define fromInt?
05:37:28 <cnclathe> ?
05:38:35 <bartavelle> hello
05:39:05 <bartavelle> i'd like to write an alternative show method for some of my types, so I created a BBStateShow class
05:39:23 <bartavelle> I don't know how to write the instance for (CustomType, CustomType)
05:39:42 <bartavelle> I can't find the proper syntax, or perhaps this is something I just did not understand
05:39:50 <lars9> could anyone suggest a good name for my data structure? it's a rectangular plane divided recursively. division can be horizaontal or vertical: XXTree = XXTree [XXTree] | Container
05:39:55 <quicksilver> cnclathe: fromInt doesn't exist by default although there is a standard function 'fromIntegral'
05:40:13 <quicksilver> bartavelle: instance BBStateShow (TypeA,TypeB) where ....
05:40:20 <lars9> Container is the leaf node, a rect
05:40:25 <quicksilver> bartavelle: but that requires extensions
05:40:27 <lars9> *a
05:40:30 <bartavelle> quicksilver, doesn't seem to work
05:40:31 <bartavelle> hah
05:40:35 <quicksilver> bartavelle: FlexibleInstances, I think
05:40:54 <bartavelle> I saw that in the error message but thought it was because i did it wrong
05:41:00 <bartavelle> thanks
05:41:05 <quicksilver> bartavelle: you'll have to be careful not to overlap; for example you won't be able to make a generic instance for (a,b)
05:41:23 <quicksilver> bartavelle: ...in fact are you sure you don't just want a generic instance for (a,b), that might make more sense?
05:41:35 <bartavelle> yeah i'd like to do a generic instance for (a,a)
05:41:38 <bartavelle> then for a
05:41:42 <benmachine> bartavelle: alternatively you could do, newtype TypeWrapper = TypeWrapper (TypeA, TypeB) and then instance BBStateShow TypeWrapper
05:41:52 <benmachine> actually
05:42:00 <benmachine> you could just do instance Show TypeWrapper
05:42:08 <benmachine> and then wrap the type when you want to use the alternative isntance
05:42:13 <benmachine> and unwrap it when you don't
05:42:18 <benmachine> might not suit your purposes though
05:42:28 <bartavelle> I'll first have to understand that if y
05:42:34 <benmachine> also why do I *always* type isntance rather than instance
05:42:34 <bartavelle> I want to know if it suits my purpose
05:42:56 <benmachine> bartavelle: is there anything wrong with just using a normal function rather than a new type class?
05:42:57 <bartavelle> thanks for the tips I'll look into that
05:43:17 <bartavelle> can i write such a polymorphic function ?
05:43:22 <benmachine> some people think that because Show exists, every function for turning things into Strings should be polymorphic
05:43:29 <benmachine> *seem to think
05:43:32 <bartavelle> it must work on several types, one of them being (TypeA, TypeA)
05:43:37 <benmachine> oh ok
05:43:56 <benmachine> you don't know in advance which types you're using it on?
05:44:07 <bartavelle> Well, I'll know when the program is written
05:44:09 <bartavelle> :)
05:44:13 <benmachine> heh
05:44:15 <bartavelle> I'm adding them as I'm going
05:44:31 <benmachine> all I mean is, sometimes a type class doesn't give you anything except name overloading
05:44:42 <benmachine> if that's all you get from it, just use more names, it's simpler
05:44:55 <hpc> also, the whole point of Show is to interact with Read
05:45:02 <hpc> that is, show . read should == id
05:45:04 <quicksilver> well he's not using Show.
05:45:06 <benmachine> but sometimes type classes give you more than that, because they give you generic functions
05:45:09 <benmachine> like
05:45:11 <benmachine> :t print
05:45:12 <quicksilver> he's very sensibly defining his own class.
05:45:12 <lambdabot> forall a. (Show a) => a -> IO ()
05:45:12 <hpc> ah
05:45:27 <hpc> nvm then
05:45:29 <AddyWaddy> yo
05:45:32 <benmachine> basically I think type classes are overused :)
05:45:37 <quicksilver> benmachine: names is not a zero benefit.
05:45:47 <benmachine> quicksilver: no, but it's a questionable one
05:45:53 <bartavelle> yeah i'm using prettyprint to write a tree and I wanted to write the tree display function just once
05:45:53 <quicksilver> benmachine: the overloading of (+) doesn't gain you much more than names
05:45:56 <benmachine> quicksilver: sometimes it can make code less obvious
05:46:11 <benmachine> quicksilver: well, I'm not sure
05:46:16 <quicksilver> (there aren't many polymorphic functions over Num)
05:46:26 <benmachine> quicksilver: what about the sum function? I could argue that depends on (+) being associative
05:46:35 * quicksilver nods
05:46:39 <quicksilver> sure.
05:46:40 <quicksilver> :t sum
05:46:42 <lambdabot> forall a. (Num a) => [a] -> a
05:46:52 <quicksilver> I don't use that very much, but you're right :)
05:47:08 <unkanon> can every function be made pointless?
05:47:10 <benmachine> nor I actually but that's not the point :P
05:47:10 <quicksilver> I agree typeclasses are overused.
05:47:21 <Botje> unkanon: yes.
05:47:25 <benmachine> unkanon: it depends what you mean
05:47:27 <quicksilver> unkanon: no.
05:47:29 <Botje> however, not all of them SHOULD be made pointless
05:47:46 <quicksilver> only if every datatype involved has appropriate destructors.
05:47:47 <benmachine> unkanon: you need the right combinators
05:47:58 <unkanon> well, if init (tails xs) is basically init . tails, how do I write the pointless version of concat ( intersperse x ys ) ?
05:48:09 <unkanon> @pl is not solving this for me
05:48:09 <lambdabot> is not solving this for me
05:48:14 <unkanon> lol
05:48:25 <quicksilver> there's no way to make "f (a,b,c) = c" pointless in the standard lib
05:48:26 <benmachine> @pl \x ys -> concat (intersperse x ys)
05:48:27 <lambdabot> (join .) . intersperse
05:48:27 <hpc> :t (.:)
05:48:28 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
05:48:49 <hpc> unkanon: define (.:) = fmap fmap fmap
05:48:50 <benmachine> hpc: neat, did you @let that or is it lambdabot standard?
05:49:00 <unkanon> hpc: did somebody finally teach lambdabot .: ?  :)
05:49:04 <hpc> apparently
05:49:08 <unkanon> I remember when we were last talking about it
05:49:08 <hpc> @src (.:)
05:49:09 <lambdabot> Source not found. The more you drive -- the dumber you get.
05:49:22 <hpc> that or nobody ever undefined it
05:49:25 <benmachine> @undefine
05:49:30 <unkanon> benmachine: thanks for teaching me the right way to ask lambdabot
05:49:32 <benmachine> @type (.:)
05:49:33 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
05:49:37 <benmachine> cool :)
05:49:40 <hpc> awesome!
05:49:48 <benmachine> unkanon: you can also do:
05:49:58 <benmachine> @pl f x ys = concat (intersperse x ys)
05:49:59 <lambdabot> f = (join .) . intersperse
05:50:10 <benmachine> unkanon: and you can get partial pointfree by omitting some of the arguments
05:50:12 <unkanon> benmachine: oh ok
05:50:14 <benmachine> @pl f ys = concat (intersperse x ys)
05:50:15 <lambdabot> f = join . intersperse x
05:50:17 <cnclathe> quicksilver, thank you!
05:50:17 <narasim_7> i am trying to pass some paths to --extra-include-dirs , I don't know how to pass multiple paths  . I gave  --extra-include-dirs twice but configure is not working then..
05:50:30 <hpc> i think you can also use applicative
05:50:31 <unkanon> wow that's cool, partial pointless
05:50:43 <hpc> :t concat . intersperse
05:50:45 <lambdabot>     Couldn't match expected type `[[a]]'
05:50:45 <lambdabot>            against inferred type `[a1] -> [a1]'
05:50:45 <lambdabot>     Probable cause: `intersperse' is applied to too few arguments
05:50:46 <unkanon> hpc: but why were you showing me .: ?
05:50:50 <unkanon> does it help here?
05:50:55 <benmachine> :t concat .: intersperse
05:50:56 <lambdabot> forall a. [a] -> [[a]] -> [a]
05:50:57 <hpc> :t (concat <$> intersperse <*>)
05:50:58 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[a1]'
05:50:58 <lambdabot>     In the first argument of `(<$>)', namely `concat'
05:50:58 <lambdabot>     In the first argument of `(<*>)', namely `concat <$> intersperse'
05:51:08 <hpc> bah
05:51:15 <hpc> still, .: works
05:51:44 <hpc> unkanon: (.:) is like (.) for a function with more arguments
05:51:57 <unkanon> hpc: arbitrarily more args?
05:52:01 <hpc> or more accurately, for a more deeply nested functor
05:52:06 <hpc> unkanon: no, just one
05:52:27 <hpc> though they might be chainable if you are clever enough; too early in the morning for me to check
05:53:02 <unkanon> > concat .: intersperse "-" ["abc","def"]
05:53:03 <lambdabot>   Couldn't match expected type `[[a]]'
05:53:03 <lambdabot>         against inferred type `GHC.Typ...
05:53:36 <quicksilver> > (concaat .: intersperse) "-" ["abc","def"]
05:53:37 <lambdabot>   Not in scope: `concaat'
05:53:39 <quicksilver> > (concat .: intersperse) "-" ["abc","def"]
05:53:40 <lambdabot>   "abc-def"
05:53:47 <quicksilver> unkanon: also spelt 'intercalate' ;)
05:53:58 <quicksilver> > intercalate "-" ["abc","def"]
05:53:59 <lambdabot>   "abc-def"
05:54:20 <unkanon> quicksilver: hmm I knew that once :) I'm doing RWH' exercises
05:54:39 * hackagebot Etage 0.1.2 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.2 (MitarMilutinovic)
05:54:56 <unkanon> too bad when people @let something to lambdabot, @src doesn't work on it
05:55:12 <unkanon> let's leave that as an exercise to me
05:55:35 <hpc> heh
05:55:53 <hpc> i gave you the source for .: up above
05:55:58 <hpc> (.:) = fmap fmap fmap
05:56:08 <hpc> or fmap . fmap, if you prefer
05:56:20 <unkanon> hpc: yes you did but I have no clue why that works (don't tell me! ;))
05:56:29 <hpc> heh, k
05:57:01 <unkanon> I appreciate the help as always, gentlemen. gotta start working now. :/
06:06:29 <cnclathe> quicksilver, how can i skip a line in interpreted code? "\ n" not working
06:07:39 <cnclathe> ?
06:07:51 <Botje> what do you mean skip a line?
06:08:21 <Botje> continue a long line on the next one?
06:08:25 <cnclathe> Botje, yes!!
06:08:32 <Botje> just indent it a little bit
06:08:34 <Botje> like
06:08:39 <cnclathe> Botje, skip a line
06:08:41 <benmachine> what do you mean by interpreted code
06:08:41 <Botje> foo $ bar $ baz $ qux
06:08:47 <Botje>     blah x (foo)
06:09:35 <Botje> cnclathe: oh, you mean in ghci?
06:09:49 <cnclathe> Botje, ? not understand, the "\n" don´t works in code interpreted, what i do?
06:10:02 <cnclathe> Botje, yes! ghci!
06:10:13 <Botje> cnclathe: you want to paste multiple lines at once into ghci?
06:10:20 <Botje> wrap them in :{...:}
06:10:26 <benmachine> cnclathe: I would personally not use ghci for anything very long
06:10:33 <benmachine> cnclathe: write it in a file and then load the file
06:11:11 <cnclathe> Botje, i want skip a line. what i do?
06:11:23 <cnclathe> "\n" don´t work.
06:11:28 <Botje> cnclathe: WHAT DO YOU MEAN BY SKIP?
06:11:36 <cnclathe> "Aluno Nota/n"
06:11:37 <Botje> do you want ghci to ignore that line?
06:11:54 <Botje> what do you want to do with that?
06:12:03 <Botje> if you putStr that you 'skip a line', yes.
06:12:22 <cnclathe> in my code i have: cabecalho = "Aluno Nota/n" ++ "Igual"
06:12:27 <lars9> what is rosetree's zipper's type? Tree = Data | Node [Tree]
06:12:30 <benmachine> cnclathe: \n not /n
06:12:33 <Botje> it's \n, not /n
06:12:51 <cnclathe> someway, don´t works...
06:12:53 <Botje> but unless you putStr that, ghci will just return "...\n..."
06:13:05 <Botje> cnclathe: what do you mean by 'doesn't work'
06:13:10 <Botje> what did you expect? what happens instead?
06:13:56 <cnclathe> Botje, in my code i have: cabecalho = "Aluno Nota/n" ++ "Igual", the result for this will be: 
06:14:01 <cnclathe> Aluno Nota
06:14:04 <cnclathe> Igual
06:14:05 <unkanon> cnclathe: it's \n
06:14:13 <unkanon> not /n
06:14:17 <Botje> and what do you receive instead?
06:14:29 <cnclathe> but, i receive Aluno Nota/nIgual
06:14:29 <Botje> and how are you evaluating your variable?
06:15:11 <Botje> are you just typing the name into ghci?
06:15:30 <Botje> change the /n into \n
06:15:48 <Botje> and type "putStr cabecalho" into ghci
06:16:04 <cnclathe> Botje, i change, but i receive  Aluno Nota\nIgual
06:16:11 <Botje> cnclathe: did you use putStr?
06:16:26 <cnclathe> Botje, i try now.
06:19:19 <cnclathe> Botje, i not compiling the file... just interpreting, putStr function does not work either.
06:20:12 <Botje> cnclathe: please be precise. 'does not work' is not very helpful
06:20:27 <unkanon> cnclathe: paste it on hpaste.org
06:20:33 <cnclathe> ok
06:20:35 <cnclathe> 1 min
06:20:37 <Botje> cnclathe: and i get the expected response:
06:20:37 <Botje> Prelude> putStr "hello\ntest\n"
06:20:38 <Botje> hello
06:20:38 <Botje> test
06:22:07 <cnclathe> http://hpaste.org/41955/notas
06:22:15 <cnclathe> unkanon, Botje, http://hpaste.org/41955/notas
06:22:36 <cnclathe> try Load the code, and type tabela 4
06:22:36 <Botje> cnclathe: for, like, the fifth time now.
06:22:41 <Botje> it is \n, not /n
06:23:00 <Botje> backslash, not forward slash.
06:23:20 <revenantphx> Does anyone have any tutorials or references for attoparsec beyond the RFC2616 example?
06:24:40 <cnclathe> Botje, it's the same ... i receive Aluno Notas\n
06:24:56 <Botje> cnclathe: are you using putStr to print your string?
06:25:15 <cnclathe> change, /n for \n and look
06:25:34 <Botje> ghci will ONLY interpret the \n if you putStr your string.
06:25:51 <cnclathe> ok i try
06:27:03 <cnclathe> Botje, how use putStr
06:27:09 <cnclathe> ?
06:27:21 <cnclathe> in my code?
06:27:33 <cnclathe> http://hpaste.org/41955/notas
06:27:34 <sipa> how does the code where you print out the string now look?
06:27:54 <Botje> cnclathe: something like putStr (tabela 5)
06:27:57 <Botje> or whatever you are testing now.
06:28:06 <cnclathe> ok
06:32:34 <revenantphx> :t (*>)
06:32:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
06:33:32 <cnclathe> Botje, please run my code and see what happens...
06:33:39 <cnclathe> please run...
06:34:15 <cnclathe> i don´t know use putStr in my code...
06:34:24 <revenantphx> > putStr "Hello world"
06:34:26 <lambdabot>   <IO ()>
06:34:33 <revenantphx> > show "Hello world"
06:34:34 <lambdabot>   "\"Hello world\""
06:34:39 <unkanon> cnclathe: there's nothing to run in your code now
06:34:45 <Botje> *Main> putStr (tabela 5)
06:34:45 <Botje> Aluno Nota
06:34:45 <Botje> 1 7.5
06:34:45 <Botje> 2 10.0
06:34:45 <Botje> 3 9.0
06:34:48 <unkanon> cnclathe: you have to have a main = something
06:34:57 <Botje> cnclathe: works for me.
06:35:03 <Botje> but only AFTER i change all /n to \n
06:35:04 <cnclathe> i try.
06:35:11 <unkanon> or load it into ghci like Botje 
06:36:40 <cnclathe> Botje, thank you friend, work!
06:36:42 <cnclathe> :)
06:36:53 <Botje> cnclathe: so, what did you learn?
06:37:10 <Botje> do you know what you were doing wrong?
06:37:49 <cnclathe> putStr tabela 4, and not putStr (tabela 5)
06:38:07 <revenantphx> :t (*>)
06:38:09 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
06:38:11 <revenantphx> :t (>>)
06:38:12 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
06:39:05 <Botje> cnclathe: uh, other way around actually.
06:39:09 <revenantphx> So it's just then for applicatives...?
06:39:11 <Botje> putStr only takes one argument
06:39:16 <benmachine> revenantphx: yes
06:39:23 <benmachine> more or less
06:39:27 <revenantphx> So if you're using parsec (a monad) why do I see *> instead of >>
06:39:35 <revenantphx> http://bitbucket.org/bos/attoparsec/src/14961a428103/examples/Parsec_RFC2616.hs
06:40:02 <benmachine> revenantphx: that looks like <*
06:40:09 <revenantphx> well, there were both
06:40:12 <revenantphx> :t (<*)
06:40:12 <benmachine> well
06:40:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
06:40:14 <revenantphx> :t (<<)
06:40:15 <lambdabot> Not in scope: `<<'
06:40:16 <benmachine> when you use one the other makes sense
06:40:23 <benmachine> the fixities match better
06:40:26 <revenantphx> :t (<*)
06:40:28 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
06:40:29 <benmachine> (<*) is *not* flip (*>)
06:40:36 <revenantphx> :t (<*)
06:40:38 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
06:40:38 <revenantphx> :t (>*)
06:40:40 <lambdabot> Not in scope: `>*'
06:40:44 <revenantphx> :t (*>)
06:40:46 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
06:40:49 <revenantphx> hm
06:41:14 <revenantphx> so what is this line for instance?
06:41:14 <revenantphx> header <- many1 token <* char ':' <* skipHSpaces
06:41:35 <revenantphx> token, char and skipHSpaces are all Parser monads.
06:41:53 <quicksilver> revenantphx: it takes the return value from many1 token
06:41:59 <benmachine> revenantphx: a <* b is 'do a then b and then return the result of a'
06:42:37 <quicksilver> it's equivalent to "header <- do { result <- many1 token ; char ':' ; skipHSpaces ; return result }"
06:42:39 <revenantphx> @source attoparsec
06:42:40 <lambdabot> attoparsec not available
06:42:47 <revenantphx> I see.
06:43:09 <revenantphx> So then char : and skipHSpaces are being ignored?
06:43:18 <benmachine> yes
06:43:19 <revenantphx> Or rather, they're consuming input but not being stored.
06:43:19 <benmachine> well
06:43:32 <quicksilver> corect.
06:43:33 <benmachine> the return value of char ':' is not super-useful :P
06:43:39 <quicksilver> consuming input but results being ignore.
06:43:59 <quicksilver> *> is therefore exactly like >> expect perhaps precedence + associativity.
06:44:04 <revenantphx> Okay.
06:44:11 <revenantphx> So how would that line be written with >>/>>=
06:44:14 <revenantphx> @do header <- do { result <- many1 token ; char ':' ; skipHSpaces ; return result }
06:44:15 <lambdabot>  Parse error at "<-" (column 8)
06:44:19 <revenantphx> er...
06:44:28 <revenantphx> @do result <- many1 token ; char ':' ; skipHSpaces ; return result
06:44:28 <lambdabot>  Parse error at "<-" (column 8)
06:44:40 <revenantphx> @do {result <- many1 token ; char ':' ; skipHSpaces ; return result}
06:44:41 <lambdabot>  Parse error at "{resu..." (column 1)
06:44:42 <benmachine> perhaps you want @undo?
06:44:52 <revenantphx> @undo result <- many1 token ; char ':' ; skipHSpaces ; return result
06:44:53 <lambdabot>  Parse error at "<-" (column 8)
06:44:56 <revenantphx> Whatever.
06:45:04 <Jafet> @undo do { header <- do { result <- many1 token ; char ':' ; skipHSpaces ; return result; }; return header; }
06:45:05 <lambdabot> many1 token >>= \ result -> char ':' >> skipHSpaces >> return result >>= \ header -> return header
06:45:18 <benmachine> @undo do { result <- many1 token; char ':'; skipHSpaces; return result; }
06:45:18 <lambdabot> many1 token >>= \ result -> char ':' >> skipHSpaces >> return result
06:45:23 <Jafet> ...well, you can snip off everything from the last >>=
06:45:54 <revenantphx> Hm yeah, I see.
06:46:09 <revenantphx> Would it be the same to just do
06:46:15 <revenantphx> header <- many1 token
06:46:18 <revenantphx> char ':'
06:46:19 <revenantphx> skipHSpaces
06:46:22 <revenantphx> on separate lines?
06:55:52 <elliott> What's that function -- mapMaybes or something? Wow, what a vague question.
06:56:07 <quicksilver> catMaybes ?
06:56:16 <quicksilver> although I think there might have been a mapMaybes somewhere
06:56:22 <sipa> fmap ?
06:56:51 <revenantphx> > sequence [return 9, return 9, return 9]
06:56:51 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
06:56:52 <lambdabot>    arising from a use of `M86283285...
06:56:57 <elliott> catMaybes sounds like it.
06:57:02 <elliott> Indeed. Thank you quicksilver :)
06:57:11 <revenantphx> print $ sequence [return 9, return 9, return 9]
06:57:16 <revenantphx> > print $ sequence [return 9, return 9, return 9]
06:57:17 <Phantom_Hoover> What's happened to haskell.org?
06:57:17 <lambdabot>   No instance for (GHC.Show.Show (m [t]))
06:57:18 <lambdabot>    arising from a use of `System.IO...
06:58:17 <Phantom_Hoover> It seems to be down...
06:59:17 <quicksilver> yes, it's down.
06:59:28 <elliott> heh, someone rm -rf sitewiki?
06:59:30 <Phantom_Hoover> Why?
06:59:33 <elliott> *-rf'd
06:59:45 <elliott> Phantom_Hoover: um, accidentally perhaps?
07:00:07 <Phantom_Hoover> elliott, I supposed as much.
07:00:46 <jmcarthur> wasn't there some planned downtime this week?
07:01:09 <jmcarthur> ah yes http://www.haskell.org/pipermail/haskell/2010-November/022387.html
07:01:11 <revenantphx> > (\(IO a) -> print a) $ sequence [return 9, return 9, return 9]
07:01:12 <lambdabot>   Not in scope: data constructor `IO'
07:01:18 <revenantphx> gr
07:01:26 <revenantphx> How do I get it OUT OF THE MONAD >_<
07:01:36 <jmcarthur> not like that :P
07:01:58 <elliott> revenantphx: you can't cheat.
07:02:05 <identity_> I'm using StateT over IO and a tuple with zippers as the context for a brainfuck program. I'm kind of out of ideas as to how to statefully discover the end of the instruction buffer without it being a 'failure'.. Maybe would probably be good for it or some such, but I can't really think of a way to thread it in. Any suggestions?
07:02:08 <revenantphx> awwww :|
07:02:08 <jmcarthur> :t print =<< sequence [return 9, return 9, return 9]
07:02:10 <lambdabot> IO ()
07:02:17 <elliott> > fmap print $ sequence [return 9, return 9, return 9]
07:02:18 <lambdabot>   No instance for (GHC.Show.Show (f (GHC.IOBase.IO ())))
07:02:19 <lambdabot>    arising from a us...
07:02:22 <elliott> :t fmap print $ sequence [return 9, return 9, return 9]
07:02:23 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => f (IO ())
07:02:27 <elliott> er, wait, no :D
07:02:28 <revenantphx> :t ($)
07:02:29 <lambdabot> forall a b. (a -> b) -> a -> b
07:02:35 <jmcarthur> elliott: that could work if you join the result
07:02:38 <elliott> > mapM print =<< sequence [return 9, return 9, return 9]
07:02:38 <revenantphx> :t (.)
07:02:39 <lambdabot>   <IO [()]>
07:02:39 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:02:41 <elliott> > mapM print =<< sequence [return 9, return 9, return 9]
07:02:42 <lambdabot>   <IO [()]>
07:02:44 <elliott> that one's nicest I think
07:02:50 <elliott> well
07:02:50 <jmcarthur> that's not what revenantphx was trying to do i think
07:02:52 <elliott> > mapM_ print =<< sequence [return 9, return 9, return 9]
07:02:53 <lambdabot>   <IO ()>
07:02:58 <revenantphx> I'm just messing arround.
07:03:01 <elliott> jmcarthur: oh, indeed.
07:03:15 <Jafet> > fmap ((++"\n").show) [return 9, return 9, return 9]
07:03:16 <lambdabot>   No instance for (GHC.Show.Show (m t))
07:03:16 <lambdabot>    arising from a use of `GHC.Show.sh...
07:03:26 <elliott> revenantphx: but hey, you can do that: print . unsafePerformIO $ sequence [return 9, return 9, return 9]
07:03:26 <jmcarthur> revenantphx: anyway, i think what you wanted there was (=<<) or (>>=)
07:03:31 <elliott> revenantphx: you're welcome, use it in all your programs.
07:03:35 <elliott> in fact, use it in every function if youc an
07:03:36 <jmcarthur> NOOOOOOOO
07:03:41 <elliott> i tend to structure my functions like:
07:03:46 <elliott> f = unsafePerformIO . return $ ...
07:03:50 <jmcarthur> @slap elliott 
07:03:50 <elliott> keeps me on my toes
07:03:50 * lambdabot pulls elliott  through the Evil Mangler
07:03:59 <elliott> mwahahahahaa
07:04:12 <Jafet> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html
07:04:23 <identity_> elliott: And you come here when your stuff crashes, right? To explain how much shit the IO monad is?
07:04:28 <elliott> oh man, hackage has acme now? \o/
07:04:37 <elliott> identity_: absolutely! (the IO monad is rubbish, but for entirely different reasons :))
07:04:58 <Phantom_Hoover> The IO monad sucks as well?
07:05:07 <identity_> The IO monad is necessary. If Haskellers were let modify the world at will, we would all be doomed
07:05:08 <elliott> Jafet: well, considering that haskell's evaluation semantics have no concept of time, clearly "now" is in fact constant
07:05:31 <elliott> identity_: who said i proposed that :)
07:05:33 <Jafet> What Does Aristotle Do?
07:05:38 <jmcarthur> "necessary" is a strong word for IO
07:05:38 <elliott> Jafet: *Would, surely
07:05:53 <elliott> jmcarthur: yeah, if conal was in here that would have been fun >:)
07:06:06 <elliott> no mortal would survive the resulting carnage
07:06:20 <Jafet> elliott: surely Plato would have disagreed
07:06:24 <elliott> 18<Jafet> http://hackage.haskell.org/packages/archive/acme-now/1.0.0.1/doc/html/src/Acme-Time-Now.html <-- I like how the title of this page starts with "scr/Acme" rather than "src/Acme"
07:06:27 <elliott> bug in hackage maybe?
07:06:31 <Zvpun> hey, I am very new to haskell and in hugs "1:[0]" says [1,0] whereas "[0]:1" says cannot infer instance. Could you help a bloody newb?
07:06:34 <jmcarthur> is elliott conal's alter ego?
07:06:37 <jmcarthur> ;)
07:06:37 <elliott> well, whatever part of hackage pretty-prints the haskell code to html
07:06:58 * hackagebot OpenGLRaw21 1.1.0.0 - The intersection of OpenGL 2.1 and OpenGL 3.1 Core  http://hackage.haskell.org/package/OpenGLRaw21-1.1.0.0 (JakeMcArthur)
07:06:58 <elliott> jmcarthur: you can't tell it's me! i have a goatee!!
07:07:00 <jmcarthur> Zvpun: the second argument to (:) expects a list
07:07:08 * elliott 's goatee falls off
07:07:15 <jmcarthur> Zvpun: (:) :: a -> [a] -> [a]
07:07:18 <Zvpun> jmcarthur: I was trying to find some reference for operator : but could not find it.
07:07:26 <Zvpun> jmcarthur: thank you.
07:07:38 <jmcarthur> Zvpun: you can always try ":t (:)" in ghci
07:07:40 <Phantom_Hoover> Haskell documentation is a strange and terrifying thing for mere mortals...
07:07:42 <jmcarthur> for future reference
07:07:58 <nostrand> what's the best way to represent mutable matrices with Vector, as a Vector of  Vectors or as a single vector with som helpers for getting the right indices?
07:08:02 <jmcarthur> Phantom_Hoover: whatchu talkin' 'bout?
07:08:28 <jmcarthur> type signatures are way better documentation than what you normally get in other languages by default (basically nothing)
07:08:32 <Zvpun> jmcarthur: how can I change it to get [0] ? 1 -> [0, 1]?
07:08:49 <Phantom_Hoover> jmcarthur, ah, but type signatures are strange and terrifying for mere mortals!
07:09:27 <jmcarthur> Zvpun: \xs y -> xs ++ [y]    -- warning, if xs is long that will be slow
07:09:48 <jmcarthur> Phantom_Hoover: i do not share that opinion, as i am a mere mortal and seem to get by
07:10:13 <Phantom_Hoover> jmcarthur, you're clearly not a mere mortal, then!
07:10:19 <jmcarthur> i am too!
07:10:26 <jmcarthur> if you cut me, i bleed!
07:10:46 <Phantom_Hoover> That doesn't imply you're /mortal/, just /vulnerable/.
07:10:51 <Zvpun> jmcarthur: thank you were much (imho you are not a mere mortal though)
07:10:55 <Zvpun> *very
07:11:07 <Phantom_Hoover> You'll have to decapitate yourself to demonstrate conclusively your mortality.
07:11:19 <Phantom_Hoover> Actually, you'd need to die.
07:11:26 <jmcarthur> lol, i was just about to say "* jmcarthur hangs his head"
07:11:33 <Zvpun> wait, this is Star Trek TNG
07:12:17 <Jafet> nostrand: the best way is to use hmatrix?
07:13:07 <Phantom_Hoover> Weird, GHCi says I don't have Control.Monad.State.
07:13:12 <jmcarthur> nostrand: repa uses vector underneath it. check that out
07:13:12 <Phantom_Hoover> This troubles me somehow.
07:13:50 <nostrand> Jafet, jmcarthur: so using Vector for that isn't that nice or what?
07:13:59 <jmcarthur> nostrand: repa *does* use vector for that
07:14:26 <jmcarthur> nostrand: vector-static is unmaintained, but it also has a limited way to nest unboxed vectors
07:14:38 <jmcarthur> i'm assuming your difficulty is nesting unboxed vectors...
07:14:41 <nostrand> jmcarthur: repa wants a new version of GHC for performance =/. Yeah, i thought so, maybe i should check the source =)
07:14:44 <jmcarthur> boxed vectors nest fine
07:15:08 <jmcarthur> nostrand: repa actually just uses dph underneath, but dph as it exists in HEAD uses vector
07:15:28 <nostrand> jmcarthur: i thought of a Vector of unboxed Vectors =)
07:16:21 <elliott>   (\(_,bs,x) -> (x, bs)) .
07:16:21 <elliott>   maximumBy (\(i,_,_) (j,_,_) -> compare i j) .
07:16:21 <elliott>   catMaybes .
07:16:21 <elliott>   map (\r -> sab (lhs r) t >>= \(i,bs) -> Just (i,bs,rhs r)) $ rs
07:16:26 <elliott> i think this is the point at which I rewrite this function
07:16:32 <jmcarthur> nostrand: well, repa does the whole thing as a single vector and does offset indexing and stuff. vector-static forces the lengths of vectors to have a known length, which makes it easy to nest them inside a single vector
07:17:32 <jmcarthur> elliott: i tend to avoid (,,) because there are no good functions to use it pointfree :\
07:17:52 <nostrand> jmcarthur: thanks =)
07:18:02 <elliott> jmcarthur: patches to make above function point-free welcome :D
07:18:17 <jmcarthur> elliott: i'm just trying to figure out what it does!
07:18:59 <elliott> jmcarthur: picks the best rewrite rule and returns the RHS of it, and the list of bindings caused by placeholders in its LHS
07:19:03 <elliott> sab :: VTerm -> CTerm -> Maybe (Integer, [Rule])
07:19:06 <elliott> this function is bestsab :: [Rule] -> CTerm -> (CTerm, [Rule])
07:19:11 <elliott> sab is just called in it, as you can see (if you can see :))
07:19:20 <elliott> sab = specificity and bindings :p
07:19:23 <jmcarthur> yeah
07:19:27 <jmcarthur> okay
07:19:43 <jmcarthur> so that doesn't really help me figure out the code ^_^
07:19:49 <Jafet> conal and his three-letter brain benders
07:20:34 <elliott> i refuse to do anything to stop the increasing trend of people thinking i'm conal.
07:20:52 <Jafet> and stick-on goatee
07:20:59 <jmcarthur> @pl \r -> sab (lhs r) t >>= \(i,bs) -> Just (i,(bs,rhs r))
07:21:00 <lambdabot> ap ((>>=) . flip sab t . lhs) ((`ap` snd) . (. fst) . ((Just .) .) . flip ((.) . (,)) . flip (,) . rhs)
07:21:04 <jmcarthur> okay bad idea
07:21:09 <elliott> it's not stick-on, it's just liable to fall off!
07:21:26 <jmcarthur> @pl \r -> sab (lhs r) t >>= \(i,bs) -> Just (i,(rhs r,bs))
07:21:27 <lambdabot> ap ((>>=) . flip sab t . lhs) ((`ap` snd) . (. fst) . ((Just .) .) . flip ((.) . (,)) . (,) . rhs)
07:21:31 <elliott> jmcarthur: i thought you point-free freaks would love something like that :D
07:21:47 <elliott> i can rearrange the order of sab's return tuple btw
07:21:51 <jmcarthur> elliott: only when it helps readability!
07:21:52 <elliott> also its arguments
07:22:48 <Jafet> Oh, you're really not conal.
07:23:10 <jmcarthur> yeah he doesn't really act like conal at all ;)
07:23:48 <elliott> yeah i'm far too cool for that!
07:23:51 <jmcarthur> elliott: i don't feel like messing with this. i have my own dang code
07:23:55 * elliott furiously presses goatee back on
07:23:56 <tg_> hey now, conal is pretty cool.
07:24:04 <elliott> i'm kidding :)
07:24:21 <tg_> but if you're not talking denotational semantics
07:24:25 <tg_> then he wants nothing to do with you!
07:29:08 <Zvpun> after some trail and fail I concluded that a+1 should read (a+1) in the following example: "range a b = if (a == b) then [a] else [a] ++ range (a+1) b" This is because 1 is fromInt 1? I am confused is a literal number like 1 special?
07:29:20 <quicksilver> Zvpun: no.
07:29:25 <elliott> 1 is fromInteger 1, actually
07:29:32 <quicksilver> Zvpun: it is because of the way infix operators are parsed
07:29:36 <elliott> but what quicksilver said
07:29:46 <quicksilver> nothing to do with fromInteger or literals
07:29:59 <quicksilver> "f a+b c" is (f a) + (b c)
07:30:25 <Zvpun> Thank you
07:33:02 <Zvpun> I tried to change it to "range a a = [a]" but that complains about repeated variable a in pattern, so I conclude that I have to compare a==b myself?
07:33:20 <quicksilver> Zvpun: correct.
07:33:26 <quicksilver> patterns don't do equality matching.
07:33:58 <Zvpun> would you change my rework of [a..b]? Is it bad somehow?
07:34:43 <Jafet> elliott: (snd *** snd.fst) . maximumBy (compare `on` fst `on` fst) . catMaybes . map (ap ((>>=) . flip sab t . lhs) ((Just .) . flip (,) . rhs) $ rs
07:34:56 <Jafet> Or something like that; follow the type errors and find your destiny
07:35:12 <engla> Zvpun: the succ function works on any Enum
07:35:37 <elliott> Jafet: er. wow. :)
07:35:47 <elliott> ok, first thing i'll flip sab so you don't have to
07:35:55 <elliott> hmm, or maybe not
07:38:27 <zygoloid> @type \lhs rhs -> (snd *** snd.fst) . maximumBy (compare `on` fst `on` fst) . catMaybes . map (ap ((>>=) . flip ?sab t . lhs) ((Just .) . flip (,) . rhs)) $ ?rs
07:38:28 <lambdabot> forall a b b1 a1 b2 a2 a3. (Ord a1, ?sab::a2 -> Expr -> Maybe (a1, b2), ?rs::[a3]) => (a3 -> a2) -> (a3 -> ((a, b), b1)) -> (b2, b)
07:39:55 * Jafet files that under "quality abuses of implicit variables"
07:41:19 <sm> good morning #haskell
07:42:18 <elliott> good afternoon sm
07:45:59 <aristid> it's always morning on the internet
07:46:01 <aristid> good morning sm
07:48:02 * sm bringing a little local colour to irc
07:53:58 <kmc> good morning :D
07:54:13 <d-snp> morning :)
07:55:21 <d-snp> I have to learn how haskell does IO using monads for a meeting tomorrow, anyone know what a good tutorial on that is?
07:55:53 <d-snp> hmm http://en.wikibooks.org/wiki/Haskell/Understanding_monads sounds good
07:56:27 <kmc> "monads" are only incidental to how Haskell does IO
07:56:28 <unkanon> I'd love to be in that meeting
07:56:46 <kmc> IO is one particular example of a monad, and an unusual one at that
07:56:58 <Scala> Am I wrong in thinking of >>= as essentially using callbacks?  dosomething >>= callback(dosomething's result)
07:57:00 <tg_> unkanon: i know, right? my meetings are boring
07:57:05 <kmc> what's important is that Haskell does IO by gluing together "IO recipes"
07:57:13 <Scala> except it can do some extra stuff before the callback function gets called as defined in the monad
07:57:17 <unkanon> tg_: yeah nobody ever mentions any monads in my meetings
07:57:20 <kmc> a recipe describes how you *could* do IO, but merely evaluating the recipe doesn't "do" anything
07:57:34 <kmc> Scala, d-snp: http://haskell.org/haskellwiki/Introduction_to_IO
07:57:35 <sipa> Scala: in the sense that that's how you would do something similar in imperative languages, yes
07:58:08 <Scala> sipa: It seems that's how it works within the IO monad, is it a fair generalization for other monads too?
07:58:12 <kmc> d-snp, where "monad" comes into it is this:  the functions (>>=) and return, used to glue together IO actions, can be used to glue together other things too
07:58:41 <kmc> "monad" means "a type for which (>>=) and return are defined"
07:59:03 <sipa> Scala: in a list monad you don't really have callbacks
07:59:05 <kmc> so if you're only looking at IO, why care that there are other instances?  why care about the abstraction or its weird name?
07:59:12 <sm> if anyone who can edit the topic is around, it might be good to insert a haskell.org status notice
07:59:20 <kmc> Scala, there's very little you can say about all monads; basically just what the laws say
07:59:36 <Scala> Gotcha, bind and return
07:59:47 <kmc> the lazy trivial monad will entirely ignore the right-hand arg to >>=
07:59:54 <kmc> other monads will call it more than once, or conditionally
07:59:58 <d-snp> unkanon: :P it's for a research project
08:00:04 <d-snp> meeting with a professor :P
08:00:06 <theorbtwo> Well, and the little bit of syntatic chancery that 'do' does.
08:00:19 <Zvpun> Jesus christ, haskell is really different. I have just written my first working isPrime function, please comment: isPrime2 n = all (/= 0) (map (n `mod`) [2 .. n-1])
08:00:47 <unkanon> d-snp: nevertheless!
08:01:09 <jon_of_arc> Does a dog have the monad nature?
08:01:19 <tg_> jon_of_arc: mu
08:01:27 <byorgey> Zvpun: from a style point of view, looks nice
08:01:43 <byorgey> Zvpun: of course there are more efficient ways to test primality
08:01:45 <kmc> Zvpun, looks pretty good.  you can make it do less work by using more maths
08:02:02 <kmc> Zvpun, i'd try writing the same thing as a list comprehension, just so you can see both styles
08:02:04 <Scala> One last question. I'm looking at some examples of 'lift', and it says the type for lift would be-- lift :: (Monad m) => m a -> t m a -- What's the => mean and is (Monad m) simply saying that there is a type m going into the function which is a monad?
08:02:12 <Zvpun> well i forgot to add that i wrote it to learn haskell so i am not much into math but more into understanding howto use haskell
08:02:33 <byorgey> Scala: type class constraints go on the left of => and the type goes on the right.
08:02:34 <Zvpun> kmc: i have to google that, thanks.
08:02:35 <kmc> Scala, if you don't know what => means, then you should study other stuff before you run into monads
08:02:43 <kmc> Scala, => is used to write the context of a type class
08:02:45 <roconnor> @pl \f x -> fmap f (duplicate x)
08:02:46 <lambdabot> (. duplicate) . fmap
08:02:47 <kmc> err
08:02:49 <byorgey> Scala: so that says lift has type  m a -> t m a,  where m is constrained to be a type which has a Monad instance
08:02:50 <ManateeLazyCat> Except TH, have any way get the function name? I'm build "data Keymap = Keymap (Map Key Fun)", I want get the name of 'Fun' when i compile program.
08:02:51 <kmc> the type class context of a function
08:03:03 <kmc> ManateeLazyCat, http://mainisusuallyafunction.blogspot.com/2010/11/obtaining-name-of-function-in-haskell.html
08:03:07 <kmc> hack city :D
08:03:15 <ManateeLazyCat> kmc: Thanks a lot! :)
08:03:35 <kmc> Scala, so you should learn how to work with some type classes like Eq and Show before you encounter Monad and MonadTrans
08:03:35 <roconnor> ManateeLazyCat:  no no, don't thank kmc
08:03:38 <roconnor> it is a trap
08:03:39 <MrAI> Why/When is functional programming better than imperative programming? My Answer: When recursion and correctness are mandatory.
08:03:46 <Scala> kmc: I don't have any problems learning about monads though
08:03:49 <ManateeLazyCat> roconnor: Better idea?
08:03:55 <Scala> until I run into this
08:03:55 <tg_> MrAI: probably not good enough :(
08:04:08 <Scala> kmc: I'll look into type classes now though
08:04:14 <roconnor> nope
08:04:22 <MrAI> tg_ Yep hard to put it into words :)
08:04:54 <ManateeLazyCat> roconnor: But i need "get the name of fun" then generate string in Map in compile time.
08:05:12 <kmc> MrAI, FP helps with correctness, but so do static types.  and those are orthogonal features; most popular functional languages are dynamically typed
08:05:15 <ManateeLazyCat> roconnor: I don't want change String value everytime function change name.
08:05:33 <ManateeLazyCat> roconnor: I think some GHC API can do that and don't need TH help.
08:05:33 <kmc> MrAI, basically Haskell is special in a lot of ways and i wouldn't lump them all in with "functional programming"
08:05:48 <MrAI> kmc: I see
08:06:03 <kmc> Scala, "Monad" is a type class.  so, if you don't know type classes, you are not learning about monads
08:06:18 <jon_of_arc> MrAI: agree with kmc here. One of my favourite things about it is the way it helps me avoid recursion (via higher-order functions)
08:06:28 <roconnor> ManateeLazyCat: your template haskell tack seems good
08:06:32 <dancor> i'm not sure how easy haskell would be to use if i was trying to prove my programs correct
08:06:56 <ManateeLazyCat> roconnor: But TH will waste compile time
08:06:58 <MrAI> jon_of_arc: like fold and map?
08:07:03 <Scala> kmc: Then I understand type classes and I simply haven't learned about =>
08:07:14 <ManateeLazyCat> roconnor: And TH is not easy to read by other people
08:07:20 <roconnor> dancor: you can build a data type of balanced red-black trees in haskell
08:07:29 <ManateeLazyCat> roconnor: I want write clean code let other people read.
08:07:30 <kmc> not really possible Scala.  unless you've used them in another language, such as your namesake :D
08:07:46 <roconnor> ManateeLazyCat: have a look at kmc's link and tell me what you think :)
08:07:56 <ManateeLazyCat> roconnor: Ok. :)
08:07:58 <kmc> my code is very clean :D
08:07:59 <jon_of_arc> MrAI: yes, that sort of thing
08:08:02 <kmc> its mode of operation is not
08:08:13 <dancor> ManateeLazyCat: calling out to "nm" seems pretty crazy..
08:08:21 <roconnor> kmc: you are the author of that monstrosity? :D
08:08:31 <Scala> kmc: Haha, well it's not like it's a difficult concept
08:08:56 <dancor> roconnor: sorry what is the relevance of the red-black trees
08:08:58 <ManateeLazyCat> roconnor: He read symbol name from object file?
08:09:31 <roconnor> I think so
08:10:42 <kmc> roconnor, yep :D
08:10:48 <roconnor> dancor: because your data type can only represent balanced trees you have an automatic proof of that all your operations produce balanced trees
08:10:51 <kmc> note that the post is tagged "donttrythisathome"
08:10:59 <dancor> roconnor: ah right
08:11:00 <roconnor> dancor: and at least that aspect of your program must be correct.
08:11:50 <dancor> but haskell seems much more practically-oriented; i'm not sure i've ever seen a (non-trivial..) haskell program proved correct actually
08:12:25 <roconnor> is the stacks of xmonad proved correct?
08:12:34 <kmc> dancor, some Haskell programs are generated from Coq proofs
08:12:47 <dancor> kmc: that's true
08:12:51 <jmcarthur> it's difficult to prove entire programs correct. much easier to prove libraries correct
08:12:52 <kmc> like the meldable-heap package
08:13:05 <kmc> roconnor, not iirc, but heavily property-tested
08:13:21 <roconnor> kmc: IIRC there was some theorem proving done
08:13:30 <roconnor> and even perhaps bugs found.
08:13:39 <elliott> Is there a shorter way to do (id *** snd)?
08:13:39 <dancor> haskell seems to have no (general) machinery to allow you to prove it correct as you develop it
08:13:49 <dancor> whereas other languages do
08:13:49 <kmc> Haskell makes it very natural to "prove" a lot of structural well-formedness by how you define types.  but it's hard to prove much beyond that
08:13:54 <roconnor> @type (id *** snd)
08:13:56 <lambdabot> forall b a b1. (b, (a, b1)) -> (b, b1)
08:13:59 <dancor> kmc: right
08:14:01 <kmc> however, even this level is worlds ahead of what most people are used to
08:14:10 <kmc> which leads to somewhat overblown claims by Haskell beginners
08:14:14 <roconnor> @type (second snd)
08:14:15 <lambdabot> forall a c d. (d, (a, c)) -> (d, c)
08:14:22 <roconnor> elliott: second snd
08:14:38 <elliott> roconnor: thank you :)
08:14:56 <kmc> roconnor, interesting, do you have a link?
08:14:58 <dancor> are there any systems where you can like develop proofs as you code (in special comments or something)?
08:15:03 <roconnor> kmc: no
08:15:16 <ManateeLazyCat> roconnor: I have read, it's a hacking way. :)
08:15:21 <roconnor> :D
08:15:38 <dancor> like to prove a function is total if all the functions it makes use of are
08:15:50 <ManateeLazyCat> roconnor: Use nm get offset, then use offset obtain symbol name from symbol table.
08:15:51 <kmc> perhaps the NSA paid Galois to make a mil-spec high-assurance tiling window manager, with certified information boundaries between classified and unclassified workspaces
08:16:35 <ManateeLazyCat> kmc: Workspace is not cool, session manager is cooler. :)
08:16:47 <elliott> ManateeLazyCat: you're the manatee developer right? does it support XEmbed so you can run it as a window manager? ;-)
08:17:04 <ManateeLazyCat> elliott: Yes.
08:17:12 <ManateeLazyCat> elliott: Manatee don't need WM
08:17:20 <elliott> ManateeLazyCat: ok, wasn't expecting *that* answer... :) what about key binding clashes?
08:17:25 <elliott> or does it use windows key prefix or something?
08:17:36 <ManateeLazyCat> http://haskell.org/haskellwiki/Manatee
08:17:38 <roconnor> MrAI: Oh, functional programs are easier to reason about.  I'm not sure if this is why functional programming is better than imperitive programming though.
08:17:42 <yitz> kmc: then again, perhaps they didn't. but should have.
08:17:47 <elliott> ManateeLazyCat: so you can run arbitrary X applications inside it? cool
08:17:57 <ManateeLazyCat> elliott: Yes.
08:18:04 <elliott> i might try it out :)
08:18:06 <ManateeLazyCat> elliott: But i won't do that.
08:18:06 <MrAI> roconnor: Not an easy question to answer :D
08:18:14 <ManateeLazyCat> elliott: It's new design
08:18:22 <ManateeLazyCat> elliott: It's not Windows Manager.
08:18:39 <elliott> ManateeLazyCat: right, but it's always likely you'll need to run some programs not included in it
08:18:39 <ManateeLazyCat> elliott: Before you play it, watch my video http://www.youtube.com/watch?v=weS6zys3U8k first. :)
08:18:52 <elliott> so being able to run X programs in it is nice
08:18:56 <ManateeLazyCat> elliott: I will create it for Manatee design
08:19:20 <ManateeLazyCat> elliott: Well, it's MVC design, and almost all GUI/X program is not MVC design
08:20:04 <ManateeLazyCat> elliott: If you embedded other program, you can't get "Unlimited Split power" like my video.
08:20:06 <elliott> ManateeLazyCat: right, but if you need to use program (whatever) not currently in manatee, it's useful to be able to run it in a manatee "window"
08:20:41 <ManateeLazyCat> elliott: Do you know MVC design? Or model-view split design?
08:20:56 <elliott> yes
08:21:01 <ManateeLazyCat> elliott: That's mean you just need one buffers, then you can get unlimited view of this buffer.
08:21:18 <ManateeLazyCat> elliott: Then you can use Manatee's Window display thosev view with *any* layout you want.
08:21:38 <ManateeLazyCat> elliott: Then you get powerful *integrated environment*.
08:22:00 <elliott> ManateeLazyCat: yep, I agree the advantages are great; I'm just thinking that running it as the root window would be impractical if you can't at least use old X programs if you need to
08:22:05 <ManateeLazyCat> elliott: And MVC design need change application code, and almost all GUI application don't support MVC.
08:22:40 <MrAI> Should you use a higher order function over recursion always?
08:22:56 <kmc> MrAI, no
08:22:57 <ion> Manatee seems to do what all window managers should do in the first place: tiling and tabbing. Partially overlapping windows you have to arrange manually are so 1970s. :-)
08:22:57 <ManateeLazyCat> elliott: But embedded those program will *break* manatee's framework
08:23:06 <elliott> MrAI: only if it's more readable that way :)
08:23:26 <ManateeLazyCat> ion: I will add "session manager* in the feature.
08:23:28 <elliott> ManateeLazyCat: break it how?
08:23:38 <MrAI> elliott: But a program should be programmed with efficiency in mind more so than readability, no?
08:23:44 <kmc> no MrAI
08:23:48 <kmc> totally incorrect
08:23:57 <kmc> usually, developer time is far more expensive than machine time
08:24:10 <kmc> code for readability, then optimize the parts you need to optimize (and use the old version as a spec / test)
08:24:16 <MrAI> I see
08:24:17 <elliott> MrAI: Higher-order functions tend to be more readable than recursion! But it's only suitable if the program is more readable that way.
08:24:26 <kmc> MrAI, also, i'm not sure why you think map and foldr are faster than explicit recursion
08:24:38 <elliott> MrAI: GHC is Really Smart, to a near approximation; don't worry about efficiency until it becomes a program, design for elegance and readability.
08:24:45 <MrAI> kmc: Im thinking of the overhead recursion comes with
08:24:48 <kmc> err
08:24:51 <elliott> MrAI: you do realise map is a recursive function?
08:24:53 <ManateeLazyCat> elliott: In current GTK+ framework, once you use GtkSocket embedded a X program, you can use another GtkSocket embedded it again.
08:24:54 <elliott> and foldr too
08:24:58 <kmc> you're aware that map and foldr are implemented with recursion?
08:25:01 <elliott> ManateeLazyCat: ah
08:25:04 <MrAI> elliott: I get you
08:25:08 <dolio> map and foldr are subject to fusion.
08:25:19 <ManateeLazyCat> elliott: Every sub-process have standalone GTkSocket to provide sandbox features
08:25:19 <dolio> Your custom-written recursive functions aren't.
08:25:26 <elliott> dolio: indeed
08:25:33 <kmc> MrAI, and why do you think recursion has an overhead compared to other function calls?
08:25:34 <elliott> but recursion itself isn't exactly a problem in haskell! :)
08:25:48 <ManateeLazyCat> elliott: So you can't share *one* X program in two or more GtkSocket
08:25:50 <MrAI> kmc: Imperative thinking ;)
08:25:58 <elliott> ManateeLazyCat: that's a shame
08:26:06 <kmc> MrAI, that has nothing to do with "imperative".  good imperative languages support recursion too
08:26:07 <ManateeLazyCat> elliott: I even embedded Emacs and vi in Manatee, but last i remove it.
08:26:37 <kmc> basically i think: use a common HOF if your recursion pattern fits it.  if not, then use explicit recursion.  but if you're writing a lot of explicitly recursive functions, then maybe you should write a *new* HOF, customized to your problem / data type
08:26:43 <ManateeLazyCat> elliott: If X program can share in many GtkSocket, i even don't need develop editor, just embedded Emacs or Vi in it.
08:27:14 <ManateeLazyCat> elliott: Embedded X program is pretty easy, but you can't do split action, then you can mix X program in integrated environment.
08:27:17 <MrAI> kmc, elliott: So when should you be concerned with efficiency? Or is it just not an issue?
08:27:26 <elliott> ManateeLazyCat: embedding emacs sounsd a bit ugly though, what with its own window management :)
08:27:30 <elliott> MrAI: whenever your program runs too slowly.
08:27:36 <elliott> MrAI: and the fix won't be to get rid of recursion :-)
08:27:50 <ManateeLazyCat> elliott: yes, i have play it before, how to say, it's perfect if i just use one Emacs window.
08:28:03 <ManateeLazyCat> elliott: It can't work share Emacs with two windows.
08:28:08 <elliott> I'd use Emacs as a window manager if it supported XEmbed nicely :)
08:28:13 <ManateeLazyCat> elliott: Current GTK+/X framework don't support that.
08:28:17 <MrAI> elliott: I see :D
08:28:20 <elliott> ManateeLazyCat: yeah
08:29:10 <ManateeLazyCat> elliott: If current GTK+/X framework support that, i won't develop Manatee, i just need develop WM to contain those X program like Manatee do now.
08:29:16 <MrAI> kmc: I was always taught something recursively could be done procedurally, given the extra overhead that comes with recursion its always better to go with the procedural approach
08:30:11 <ion> What extra overhead?
08:30:16 <ManateeLazyCat> elliott: That's why i rewrite everything, otherwise i can't reach my target
08:30:19 <MrAI> of memory and so forth
08:30:38 <unkanon> doesn't haskell do TCO?
08:30:42 <unkanon> so there's no overhead
08:30:48 <copumpkin> unkanon: depends if you use tail calls :)
08:30:53 <MrAI> TCO?
08:30:53 <ion> mrai: http://en.wikipedia.org/wiki/Tail_call
08:31:00 <unkanon> but if you do, then haskell does its part?
08:31:05 <unkanon> and optimize the call away?
08:31:08 <copumpkin> unkanon: if you do, it does the right thing, but laziness also makes it less relevant
08:31:23 <copumpkin> foldl' is conventional tail recursion in a simple package
08:31:23 <unkanon> MrAI: tail call optimization
08:31:30 <elliott> hmm, what's the name for the list induction combinator ala maybe?
08:31:36 <copumpkin> elliott: foldr
08:31:36 <dolio> The typical evaluation model in Haskell doesn't associate function calls with stack usage.
08:31:38 <elliott> wait it's just ... right
08:31:39 <thoughtpolice> tail calls are a little special in haskell because of lazy evaluation. functions are evaluated 'outside-in', not 'inside-out' so tail calls have different properties. normally you want to wrap your actual explicit recursion up into a function though
08:31:41 <kmc> MrAI, it can be done procedurally, by emulating the recursive call stack explicitly.  so you save nothing and probably thwart a non-terrible language's recursion optimization
08:31:42 <dolio> So the question is kind of meaningless.
08:31:43 <elliott> i was wrong, I actually want
08:31:51 <elliott> foo [] x y = x, foo _ x y = y
08:31:58 <elliott> @hoogle [a] -> b -> b -> b
08:31:59 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
08:31:59 <lambdabot> Text.Regex.Base.RegexLike MR :: a -> a -> a -> [a] -> Array Int a -> MatchResult a
08:31:59 <lambdabot> Language.Haskell.TH ForallT :: [Name] -> Cxt -> Type -> Type
08:32:00 <ManateeLazyCat> elliott: I think there have some program in next step : "Mail Client", "Terminal Emulator", "IDE"
08:32:07 <copumpkin> elliott: maybe . listToMaybe
08:32:07 <MrAI> kmc: Im with you
08:32:08 <kmc> MrAI, you should question what you learn in school
08:32:10 <copumpkin> or you know what I mean
08:32:21 <elliott> ManateeLazyCat: a shell would be nicer than a terminal emulator, if you just implement control codes and not cursor control
08:32:23 <MrAI> kmc: Oh I do :D Too much, lol
08:32:28 <kmc> MrAI, you should be concerned with efficiency when your program turns out to be too slow ;P
08:32:30 <elliott> ManateeLazyCat: because you could use all the editing commands before sending off the line
08:32:38 <elliott> copumpkin: or just a case statement :P
08:32:42 <kmc> i think picking the right data structure up front makes sense
08:32:46 <copumpkin> elliott: pff!
08:32:50 <kmc> but contorting your code up front usually doesn't
08:32:59 <MrAI> kmc: But the slow is most likely to be because of the algorithm im using, rather than the recursion im using
08:33:01 <kmc> again: developer time is more expensive than machine time
08:33:03 <kmc> yeah MrAI
08:33:09 <roconnor> ion: I've never used a tiling manager before, but I don't see the appeal.  Can you (or anyone else) elighten me?  I don't mind overlapping windows.  I tab between them usually without trouble.
08:33:16 <kmc> and haskell makes it easy to implement a slow algorithm
08:33:24 <kmc> (often also easy to implement a fast one)
08:33:31 <roconnor> and I don't waste space with windows that are the wrong aspect ratio for their contents
08:33:44 <dancor> kmc: and hard to tell the difference? :)
08:33:49 <elliott> <roconnor> and I don't waste space with windows that are the wrong aspect ratio for their contents <-- this is the single reason I don't use tiling WMs
08:33:52 <elliott> well, one of two reasons
08:34:01 <elliott> the other is that none of them behaves exactly as I'd like :)
08:34:04 <ManateeLazyCat> elliott: Once i implement Terminal, i can embedded Emacs in it.
08:34:13 <elliott> ManateeLazyCat: oh my :)
08:34:21 <ManateeLazyCat> elliott: Because my temrinal is MVC design, so i can split Emacs with many window.
08:34:35 <ManateeLazyCat> elliott: You know my http://www.emacswiki.org/emacs/MultiTerm ?
08:34:40 <ManateeLazyCat> elliott: Something like htat.
08:34:49 <ManateeLazyCat> elliott: Embedded Emacs in Emacs, with split window.
08:34:49 <exDM69> roconnor: I have always used a floating window manager but recently I would have wanted some tiling. when you do a certain task repeatedly (such as coding every day), having all your windows conviniently next to each other would be a bonus
08:35:08 <exDM69> roconnor: KDE's new Kwin wm has optional tiling support, I'd like to give it a try
08:35:17 <elliott> ManateeLazyCat: sounds, uh, fun :D
08:35:29 <ManateeLazyCat> elliott: Once i finish "MVC design" terminal emulator, i can use them in different window and don't need change any code of Emacs/vi
08:35:30 <dancor> ManateeLazyCat: why don't you just rewrite gnu screen (fixing its concurrency bugs)
08:35:37 <dolio> I occasionally accidentally press the button combination to turn on kwin's tiling support...
08:35:42 <dolio> It messes up the sizes of all my windows.
08:35:54 <thoughtpolice> haven't there already been at least 1 or 2 screen rewrites? tmux anyone?
08:35:56 <ManateeLazyCat> dancor: Watch http://www.youtube.com/watch?v=weS6zys3U8k
08:36:02 <dancor> ok
08:36:06 <Botje> en detach++ or something
08:36:21 <thoughtpolice> apparently tmux is completely awesome, but i still use screen out of habit which probably makes me stoopid.
08:36:24 <ManateeLazyCat> dancor: You will know what's the difference between Manatee and other WM or "gnu screen"
08:36:32 <ManateeLazyCat> dancor: Select 720p HD version
08:37:11 <ManateeLazyCat> elliott: Not just Emacs or Vi, any program can running in Terminal emulator, i can make it running in Manatee, then use "integrate" power of Manatee
08:37:16 <copumpkin> ManateeLazyCat: is that a pirated PDF of RWH? :P
08:37:18 <osfameron> Manatee?
08:37:34 <Botje> copumpkin: ISTR you could download the source, no?
08:37:36 <ManateeLazyCat> osfameron http://www.youtube.com/watch?v=weS6zys3U8k
08:37:50 <copumpkin> Botje: you can view it for free online, but I didn't think any PDFs were freely available of it
08:38:11 <elliott> copumpkin: it could be a bought PDF
08:38:14 <elliott> just sayin'
08:38:22 <copumpkin> elliott: I thought they only started selling it today
08:38:25 <copumpkin> or yesterday
08:38:32 <elliott> the book or the pdf?
08:38:36 <copumpkin> the pdf
08:38:36 <elliott> the book has been out for a while :P
08:38:39 <elliott> right, perhaps
08:38:45 <elliott> beats me
08:38:50 <ManateeLazyCat> Hi guys, if anyone ask "What's the Manatee?" can you help me post http://www.youtube.com/watch?v=weS6zys3U8k ? I not always online
08:39:01 <copumpkin> I guess if you google RWH pdf it's the first result
08:39:19 <elliott> copumpkin: "[PDF] Rainwater Harvesting (RWH)"
08:39:27 <ManateeLazyCat> copumpkin: You can download pdf everywhere. :)
08:39:29 <copumpkin> I meant with the expanded title
08:39:36 <roconnor> @what+ Manatee http://www.youtube.com/watch?v=weS6zys3U8k
08:39:37 <copumpkin> ManateeLazyCat: oh, I'm sure :P
08:39:37 <lambdabot> I know nothing about manatee.
08:39:38 <elliott> ManateeLazyCat: dons will come and get you!
08:39:47 <copumpkin> my question is whether the authors approve of you being able to download the pdf everywhere :)
08:39:49 <elliott> while you sleep... be afraid...
08:39:54 <ManateeLazyCat> elliott: I pay for Manatee to dons. :)
08:40:15 <elliott> I warn you, dons has no concept of forgiveness.
08:40:20 <ManateeLazyCat> copumpkin: I have 20GB pdf book in my disk.
08:40:21 <elliott> :p
08:40:34 <ManateeLazyCat> elliott: :)
08:40:38 <kmc> mine is bigger
08:40:39 <osfameron> ManateeLazyCat: I'm actually not quite sure that youtube helps?
08:40:52 <osfameron> it looks like you're browsing the web
08:40:53 <copumpkin> ManateeLazyCat: just saying, you might want to avoid advertising that you're pirating the book written by prominent members of the community
08:41:01 <ManateeLazyCat> osfameron: http://hackage.haskell.org/package/manatee
08:41:14 <copumpkin> @remember kmc mine is bigger
08:41:15 <lambdabot> Okay.
08:41:35 <dolio> Mine's louder.
08:41:37 <elliott> osfameron: browsing the web with HASKELL!
08:42:11 <ManateeLazyCat> copumpkin: Many chinese friend buy RWH book just because watch my video
08:42:22 <ManateeLazyCat> copumpkin: They think that's the best Haskell book. :)
08:43:19 <dolio> If only he were Japanese instead. He could get the evil bird book.
08:44:11 <kmc> thanks copumpkin
08:44:22 <copumpkin> kmc: anytime!
08:44:40 <dolio> http://www.amazon.co.jp/å…¥é–€Haskellâ€•ã¯ã˜ã‚ã¦å­¦ã¶é–¢æ•°åž‹è¨€èªž-å‘äº•-æ·³/dp/4839919623/ref=sr_1_5?ie=UTF8&qid=1291135398&sr=8-5
08:45:32 <ManateeLazyCat> copumpkin: Has many people translate RWH to Chinese to bring Haskell's best book in China.
08:45:34 <kmc> while the existence of the free web version doesn't *legally* give you the right to a free pdf version, i think it's *somewhat* an ethical justification for getting the pdf
08:45:51 <kmc> the ethics of piracy are based on the unknowable counterfactual of "if i couldn't get this for free, would i pay for it"
08:46:03 <ManateeLazyCat> copumpkin: But i can tell you my pdf is *free* web version. :)
08:46:54 <Jafet> The book is different from the free HTML version, though
08:47:01 * roconnor isn't sure of what ethics motives people to *not* share with their friends.
08:47:04 <kmc> different in content?
08:47:07 <Jafet> At least, I assume so, having not read the printed book
08:47:23 <kmc> i thought it was more or less the same content, nicely typeset as a real book
08:47:36 <ManateeLazyCat> osfameron: http://hackage.haskell.org/package/manatee
08:47:40 <Jafet> Well, the HTML one doesn't look complete
08:47:58 <Jafet> I remember seeing unexpected ghci errors in it
08:48:04 <elliott> roconnor: because zomg copyright!
08:48:23 <ManateeLazyCat> osfameron: You should watch finish my video, then you know it's not just browsing the web.
08:48:26 <elliott> i disagree with kmc for what it's worth, but i'm a crazy radical who opposes copyright on principle :)
08:48:59 <roconnor> elliott: me too
08:49:10 <osfameron> ManateeLazyCat: short attention span - it looked a bit like xmonad
08:49:26 <ManateeLazyCat> download pdf file /= hurt author, reverse, many people will buy book in shop if they find pdf is great
08:49:36 <osfameron> is the intention to provide a VM for interested programmers to start coding Haskell without having to install everything on their own system?
08:49:37 <ManateeLazyCat> osfameron: Drop to *last minutes*
08:50:16 <ManateeLazyCat> osfameron: I will, it's not my highest mission now.
08:50:49 <ManateeLazyCat> osfameron: I think someone can use VirtualBox install PuppyLinux or some LiveCD, then install Manatee in it.
08:51:40 <ManateeLazyCat> copumpkin: As i know, i have many friend buy RWH after watch my video.
08:51:48 <osfameron> I'm failing to understand what it's for (given I already have OSX/Ubuntu + terminal + vim)
08:52:31 <ManateeLazyCat> osfameron: Don't use any exist software compare it. :)
08:52:50 <ManateeLazyCat> osfameron: You can consider it's is Super Emacs, but can do everything in it. :)
08:52:55 <elliott> osfameron: it's like Emacs except it's designed from the start to do advanced non-editing tasks
08:52:57 <elliott> at least that's my impression
08:53:06 <elliott> with a more GTKy interface than typical emacs ways of doing things
08:53:16 <elliott> osfameron: so it's an OS in a box :P
08:53:36 <kmc> just get it running on the House kernel
08:53:46 <ManateeLazyCat> kmc: Linux Kernel is better. :)
08:54:46 <elliott> ManateeLazyCat: it's not written in Haskell!
08:54:49 <elliott> Q.E.D.
08:55:01 <ManateeLazyCat> elliott: :)
08:55:28 <ManateeLazyCat> elliott: Many Emacs friend know what i'm doing after watch my video. :)
08:56:25 <roconnor> how do we write CoKleisli composition?
08:56:28 <roconnor> =>=  ?
08:56:34 <roconnor> and =<= ?
08:56:49 <osfameron> ah, the browser/etc. processes are all running in emacs panes?
08:56:50 <roconnor> so ugly
08:56:58 <elliott> osfameron: s/emacs/Manatee/
08:57:11 <elliott> ManateeLazyCat: Tell me when Manatee can boot itself. :-)
08:57:31 <ManateeLazyCat> I explain what's is "session layout", it's mean you just need some buffer and session layout, then you can those buffer build any layout you like, Example "Mail layout" "Programming layout" "Music layout", and you don't need any more buffers.
08:57:57 <ManateeLazyCat> elliott: Current is 0.1.2, i think 0.1.4
08:58:08 <elliott> ManateeLazyCat: boot itself = run as OS :-)
08:58:46 <ManateeLazyCat> elliott: So you mean don't need any other program help?
08:59:07 <ManateeLazyCat> elliott: Just "Linux Kernel + Manatee" ?
08:59:50 <elliott> ManateeLazyCat: Implement a kernel too!
09:00:02 <elliott> All you need is some assembly, enough to implement the C library functions GHC uses in its output :-)
09:00:22 <ManateeLazyCat> elliott: My policy from outside to inside.
09:01:09 <ManateeLazyCat> elliott: Once GTK+ can running in many different backend, i think someday, we can build Haskell render backend for GTK+ ,then build GHC code base in it. :)
09:02:31 <ManateeLazyCat> elliott: Well, all code is Haskell is awesome, but i think right way is not just use Haskell, i think right way is build Haskell environment mix other awesome library and don't care which language those library use.
09:02:40 <MrAI> Is it possible to run a recursive call in haskell with a timer between each recursion? Question -> Bool
09:02:58 <elliott> MrAI: but that question doesn't have a simple boolean answer!
09:03:07 <MrAI> elliott :D
09:03:31 <ManateeLazyCat> elliott: Have you watch video?
09:04:15 <elliott> ManateeLazyCat: yes
09:04:25 <elliott> it made sense but only because I knew what manatee was already
09:04:26 <ManateeLazyCat> I'm uploading new video without Owl city's song, for germany people. :)
09:05:12 <ManateeLazyCat> elliott: That video save much words, i don't repeat "What's Manatee" everyday. :)
09:05:25 <ManateeLazyCat> s/don't/don't need
09:05:29 <quicksilver> ManateeLazyCat: iav;dw
09:05:32 <quicksilver> :)
09:05:58 <ManateeLazyCat> Someone tell lambdabot "What's Manatee?"
09:06:10 <ManateeLazyCat> It's painful type those everyday.
09:06:23 <elliott> quicksilver: incandescent automotive vehicle; drive wildly?
09:06:35 <quicksilver> elliott: excellent advice
09:06:39 <ManateeLazyCat>    @remember  can work?
09:06:46 <augur> a manatee is a large aquatic animal from the south of florida and frmo china
09:06:51 <elliott> it's @know+ or something
09:06:55 <elliott> remember is quotes i believe
09:07:06 <elliott> augur: ah yes, the mystical country of Frmo China
09:07:25 <augur> oh god elliott's here too
09:07:36 <elliott> i am glad i inspire such a reaction
09:07:39 <quicksilver> @where+ manatee http://hackage.haskell.org/package/manatee http://www.youtube.com/watch?v=weS6zys3U8k
09:07:39 <lambdabot> Done.
09:07:53 <quicksilver> @where manatee
09:07:53 <lambdabot> http://hackage.haskell.org/package/manatee http://www.youtube.com/watch?v=weS6zys3U8k
09:08:04 <ManateeLazyCat> quicksilver: Thanks! :)
09:08:07 <quicksilver> I like the way the URLs are the same length.
09:08:13 <quicksilver> I still refuse to watch the video.
09:08:22 <elliott> almost worth switching to monospace and resizing my window to see that, quicksilver
09:08:22 <elliott> almost.
09:08:23 <ManateeLazyCat> quicksilver: Why?
09:08:43 <quicksilver> ManateeLazyCat: if I want to go and see a film, I will go to the cinema. Otherwise video is a very inefficient way of conveying information.
09:09:09 <quicksilver> ManateeLazyCat: I can read a 50-page HTML document in 90 seconds, skipping to the bits that interest me and noting key points to consider later.
09:09:16 <quicksilver> a video I have to watch at the speed the author chose.
09:09:46 <ManateeLazyCat> quicksilver: You can download it then use mplayer watch it as your speed! :)
09:09:58 <unkanon> quicksilver: for that I use VLC and speed up the video to 3.0x
09:10:08 <quicksilver> sure, but it's still not the same.
09:10:59 <unkanon> quicksilver: yeah but it helps some
09:10:59 <elliott> quicksilver: Manatee is like Emacs except that it has rich GTK+ based UIs inside each pane and more advanced/convenient "window management" capabilities. It has a WebKit-based browser, a multimedia player, an IRC client, etc. <-- summarised the video for you
09:11:08 <elliott> can someone just add that to the know thing so we can shut up about this already :P
09:11:26 <monochrom> until video has a navigation UI like text, I still swear by text.
09:12:14 <quicksilver> elliott: I think that's not really needed, most of that content is on the hackage page or the home page
09:12:19 <quicksilver> or should be added.
09:12:20 <ManateeLazyCat> elliott: Excellent explain. :)
09:12:21 <monochrom> so called lecture videos are particularly time-wasting
09:12:50 <unkanon> monochrom: I liked SPJ's 3 hour lecture on haskell 
09:13:05 <unkanon> he's a very enthusiastic speaker
09:13:21 <ManateeLazyCat> unkanon: I want to watch also, link?
09:13:52 <unkanon> ManateeLazyCat: http://blip.tv/file/324976
09:14:00 <ManateeLazyCat> unkanon: Thanks. :)
09:14:17 <unkanon> ManateeLazyCat: part 2: http://blip.tv/file/325646
09:14:19 <unkanon> ManateeLazyCat: np
09:14:25 <ManateeLazyCat> Oh, in GFW list.
09:14:40 <revenantphx> Hm yeah.
09:14:42 <revenantphx> Now that I think about it.
09:14:55 <ManateeLazyCat> I think manatee-proxy will coming soon.
09:14:55 <revenantphx> The IO Monad isn't to protect haskellers from the outside world...
09:14:59 <revenantphx> It's exactly the opposite.
09:15:05 <ManateeLazyCat> Or named manatee-fighting-gfw.
09:15:54 <pkrumins> quicksilver: wow 50 page doc in 90secs? you serious?
09:16:11 <benmachine> pkrumins: skimreading is an art
09:16:24 <ManateeLazyCat> pkrumins: quicksilver has super speed and fast mind. :)
09:16:35 <monochrom> well-written doc has section titles etc to help you skip skip skip fast-forward
09:16:43 <pkrumins> that's awesome
09:17:05 <monochrom> even without those, you can just ctrl-f it
09:17:09 <elliott> i read war and peace in five minutes... "peace" took the longest, that word was hell to get through
09:17:13 <elliott> *rimshot*
09:17:15 <monochrom> there is no ctrl-f for video
09:17:24 <unkanon> ba-dum-ching!
09:17:26 <unkanon> lol
09:17:34 <ManateeLazyCat> elliott: I need off now, join ##manatee, all link of Manatee at topic. :)
09:17:37 <elliott> isn't it more *tish* than *ching*? :)
09:17:46 <unkanon> you could argue that, yes
09:17:57 <unkanon> I hear a chee
09:18:07 <benmachine> chish?
09:19:18 <sdj> ba-da-bum-chee
09:19:45 <sdj> danish style
09:20:08 <pkrumins> boom de yada
09:20:15 <elliott> sdj: your name is way too chose to spj
09:20:43 * ManateeLazyCat I remember i join #haskell for question "obtaining-name-of-function-in-haskell", but bla bla ...... need coding...
09:20:57 <sdj> which is?
09:21:06 <elliott> sdj: are you seriously asking who spj is? :)
09:21:26 <sdj> indeed
09:21:45 <monochrom> people seriously ask who John Backus is, too
09:22:06 <elliott> sdj: http://en.wikipedia.org/wiki/Simon_Peyton_Jones
09:22:10 <sdj> ah
09:22:13 <elliott> he's the reason you're in here :P
09:22:30 <jro> % cabal configure -> Setup.hs:3:7: Not in scope: `defaultMainWithHooks'
09:22:35 <sdj> I have something to live up to then :-)
09:22:56 <jro> main = defaultMainWithHooks hooks where hooks = simpleUserHooks { runTests = runTests' }
09:23:17 <monochrom> you lack an import
09:23:23 <jro> I try to hook runtests to setup
09:23:26 <jro> oh, thanks
09:27:22 <Zvpun> "isPrime p = notElem 0 [ p `mod` n | n <- [2 .. x]] where x = floor (sqrt p)" says Instance of (Floating Integer, RealFrac Integer) required for definition of isPrime. Could you please help me fix this issue.
09:28:02 <quicksilver> Zvpun: (sqrt (fromIntegral p))
09:28:23 <quicksilver> Zvpun: you can't call sqrt directly on integers.
09:28:30 <quicksilver> > sqrt (4 :: Int)
09:28:31 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
09:28:31 <lambdabot>    arising from a use of...
09:28:42 <quicksilver> > sqrt (fromIntegral (4 :: Int))
09:28:43 <lambdabot>   2.0
09:28:45 <jro> how do I know from which package I have to import to get system?
09:28:58 <quicksilver> jro: hoogle is a good way to find out
09:29:14 <quicksilver> jro: http://www.haskell.org/hoogle/?hoogle=system
09:30:11 <unkanon> benmachine: yes, chish
09:33:34 <Zvpun> quicksilver: is there a difference between fromIntegral and fromInteger?
09:34:06 <jro> thanks quicksilver :-) cabal configure, cabal build and cabal test works like a charm now :-)
09:35:40 <quicksilver> Zvpun: Yes. The former works on any integral type, e.g. Int, Word, etc etc.
09:35:45 <burp> :t fromInteger
09:35:46 <lambdabot> forall a. (Num a) => Integer -> a
09:35:49 <quicksilver> Zvpun: the latter, only on the specific type 'Integer'
09:35:51 <burp> :t fromIntegral
09:35:52 <lambdabot> forall a b. (Integral a, Num b) => a -> b
09:35:53 <kmc> @src fromIntegral
09:35:54 <lambdabot> fromIntegral = fromInteger . toInteger
09:36:08 <MrAI> Haskellwiki: "For example, in Java one can write a function that accepts two arguments of any possible type. However, Haskell goes further by allowing a function to accept two arguments of any type so long as they are both the same type" Why is this better? It sounds more restricting to me
09:36:52 <burp> MrAI: I don't understand
09:36:55 <benmachine> MrAI: you can do both
09:37:13 <MrAI> http://www.haskell.org/haskellwiki/Parametric_polymorphism Its on there
09:37:26 <benmachine> MrAI: it's just an example
09:37:38 <benmachine> MrAI: you can accept two arguments of any type, or two arguments of the same type
09:37:44 <benmachine> MrAI: or two arguments one of which is a list of the other
09:37:59 <kmc> MrAI, it's saying the language is better because it allows you, if you choose, to impose an extra restriction on the user
09:38:00 <benmachine> or whatever you like
09:38:04 <kmc> that being the point of static typing
09:38:28 <MrAI> Ah ok
09:38:40 <jro> can't you do that with generics in java?
09:38:47 <kmc> i think so
09:39:17 <kmc> MrAI, and Haskell will let you do more stuff inside a function of type a -> [a] -> Foo, compared to a -> b -> Foo
09:39:19 <jro> well, not for functions, but semantically identical
09:39:24 <kmc> so you get something for having placed the restriction
09:40:11 <MrAI> kmc I see
09:41:09 <jro> I try to write QuickCheck test case, but I understand that this is bad: prop_monotonic :: Double -> Double -> Double -> Property								
09:41:34 <jro> prop_monotonic time distance predictByTime = time > 0.0 && distance > 0.0 && predictByTime > time ==>
09:42:35 <jro> since this gets just any doubles and exhausts random number in test cases
09:42:56 <jro> any pointers how to solve this properly?
09:43:53 <benmachine> jro: I was under the impression that ==> was good about that sort of thing, and retook the test if the precondition failed, but I could be wrong
09:44:14 <jro> prop_monotonic: [Arguments exhausted after 51 tests]
09:44:17 <benmachine> jro: why not, instead of requiring predictByTime > time, just take predictByTime > 0 and add time to it?
09:55:04 <jro> benmachine: that was good solution I think
09:55:06 <jro> prop_monotonic time distance predictByTime = absptime > epsilon && abstime > epsilon && absdistance > epsilon ==>
09:55:18 <jro> 	where 
09:55:19 <jro> 		abstime = abs time
09:55:24 <jro> and so on
09:55:43 <benmachine> :)
09:57:26 <jro>   prop_monotonic: [OK, passed 20000 tests]
09:57:28 <jro> :-)
09:57:31 <crutcher> Hey, anyone familiar with attoparsec and Data.Enumerator? I think I found a bug in attoparsec-enumerator's Data.Attoparsec.Enumerator.iterParser
09:57:59 <crutcher> And I'd appreciate another set of eyes to glance at the code
10:00:00 <crutcher> http://hackage.haskell.org/packages/archive/attoparsec-enumerator/latest/doc/html/src/Data-Attoparsec-Enumerator.html#iterParser
10:00:23 <crutcher> I think it doesn't handle empty ByteStrings in the stream correctly, since attoparsec treats them as EOF
10:01:50 <mee> Re: that polymorphism page, what's an example of an illegal type signature? I can't seem to find that a) GHC rejects or b) can't be written as the composition of two obviously OK functions
10:03:19 <zygoloid> @type let x :: (a ~ (a -> a)) => a; x = undefined in x
10:03:20 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
10:03:20 <lambdabot>       Expected type: a -> a
10:03:20 <lambdabot>       Inferred type: a
10:15:54 * hackagebot blaze-builder 0.2.0.2 - Efficient construction of bytestrings.  http://hackage.haskell.org/package/blaze-builder-0.2.0.2 (SimonMeier)
10:16:36 <roconnor> @tell twanvl http://www.reddit.com/r/science/comments/cce1x/quantum_weirdness_wins_again_entanglement_clocks/c17ecdn?context=3
10:16:36 <lambdabot> Consider it noted.
10:23:48 <sproingie> comment 10 on that article sums it up pretty well, just have to add in "it's both heads and tails til you open it"
10:24:01 <sproingie> still no extra information getting passed
10:25:57 <roconnor> sproingie: I think twanvl's statement that it has a 50% probability of being either heads or tails is more accurate that saying it is both heads and tails
10:27:07 <jro> roconnor, I disagree
10:27:17 <sproingie> well till you open it it's just not defined at all
10:28:40 <roconnor> sproingie: but you know something, it is either heads or tails.  You have no reason to beleive any one is more like than any other, hence 50-50.
10:28:54 <jro> it is completely described by the integral over all possible paths in the phase-space
10:29:19 <roconnor> jro: are we talking about pennies?
10:29:25 <elliott> i can't make heads or tails of this discussion
10:29:26 <sproingie> it's just that when you've got them entangled, one determines the other
10:29:32 <sproingie> the universe uses lazy evaluation
10:29:49 <jro> roconnor, any quantum mechanical object
10:32:49 <roconnor> sproingie: yes, that is even more accurate.  50% chance of this one being heads and the other being tails, and a 50% change of this one being tails and the other one being heads.
10:34:02 <sproingie> not all that weird to think of it that way, it's just the idea that it "becomes heads and instantly causes the other to become tails" that suggests "spooky action at a distance"
10:34:32 <dolio> I don't think that's the only thing.
10:34:43 <dolio> Can't you do manipulations of one that affect the other?
10:35:08 <sproingie> i think the entanglement is broken when the property is measured
10:35:17 <dolio> I don't mean measurements.
10:35:21 <roconnor> sproingie: some people are stuck thinking that correlation is causation.
10:35:29 <jro> if the observer "knows his universe" then he surely gets pure state 
10:35:52 <FunctorSalad> isn't that "becomes" just an information gain?
10:36:00 * hackagebot attoparsec-enumerator 0.2.0.2 - Convert an Attoparsec parser into an iteratee  http://hackage.haskell.org/package/attoparsec-enumerator-0.2.0.2 (JohnMillikin)
10:36:02 <jro> thinking that phase factor squared is probability is measurement is not proper way to think imo
10:36:04 <sproingie> frankly the whole idea of "it becomes heads" is spooky enough for me :)
10:36:12 <FunctorSalad> but this is #haskell-blah :o
10:36:30 <roconnor> FunctorSalad: ah, sorry
10:37:02 <FunctorSalad> roconnor: uh I wasn't personally annoyed, more excusing myself for possibly escalating the quantumery
10:37:07 <dolio> sproingie: I mean more like, you can apply a unitary transformation (if that's the right term) to one, and the same thing happens to the other.
10:37:20 <dolio> It's been a long time since I studied this, though.
10:37:28 <roconnor> dolio: I don't think that happens.
10:38:05 <dolio> I thought something weird like that was possible, but maybe it's just the poor explanation this gets typically.
10:39:00 <jro> dolio, if you think the spin of single particle and say that "it must evolve throuhg unitary transformations" you're in trouble
10:39:23 <unkanon> is this #haskell?  :D
10:39:24 <mee> zygoloid: sorry, can you explain the syntax for me? The only '~' I can find in the report is the irrefutable pattern tilde, which I can't make sense of in the context of a type signature.
10:39:31 <roconnor> There is nothing strange going on until you bring Bell's inequality into play, and bell's inequality is kinda complicated/subtle
10:42:17 <unkanon> fmap should just be called liftF, amirite people?
10:43:32 <ndrsndrs> mee: it's type equality (with -XTypeFamilies)
10:43:48 <aristid> unkanon: no, there's nothing wrong with the name fmap
10:45:03 <unkanon> aristid: isn't fmap really just a function that "lifts a function into a Functor" ?
10:45:10 <aristid> unkanon: sure.
10:45:15 <unkanon> aristid: where did fmap come from? (the name)
10:45:20 <unkanon> is that from mathematics too?
10:45:21 <aristid> functor map? not sure
10:45:26 <unkanon> yeah
10:45:43 <unkanon> why not monad map instead of liftM then?
10:45:48 <ndrsndrs> mee: `a ~ b => c` mean that a and b need to be the same type; most useful with type families (e.g. `put 5 :: (MonadState m, StateType m ~ Int) => m ()` using monads-tf)
10:45:55 <unkanon> and applicative map instead of liftA ?
10:46:21 <aristid> unkanon: no idea. i'd be fine with mmap and amap
10:46:55 <mee> ndrsndrs: thanks, I at least understand why it's illegal now
10:46:59 <unkanon> aristid: I'd be fine with all of them with the same notation, whichever it is
10:47:12 <unkanon> aristid: I'm not complaining though, just stating that fmap stands out
10:47:22 <unkanon> or the liftXs stand out, whatever way
10:47:34 <aristid> unkanon: well, you can use <$>
10:47:39 <aristid> which is the same for all
10:47:44 <aristid> or use . from my package
10:47:47 <aristid> @hackage functors
10:47:48 <lambdabot> http://hackage.haskell.org/package/functors
10:47:52 <unkanon> I always have to look up what <$> really is
10:48:15 <unkanon> I know it's what you use before using several <*> :)
10:48:50 <aristid> <$> is fmap
10:49:35 <unkanon> why do you say that that is "the same for all" ? it works for applicatives and monads just the same, is that it?
10:49:49 <aristid> unkanon: in my package functors, you can do something like this: (+) . cos & sin, which is the same as liftA2 (+) cos sin
10:50:20 <aristid> unkanon: fmap also works for applicatives and monads just the same, if they have a well-behaved Functor instance
10:50:49 <aristid> sometimes you use liftM tho, to avoid getting that pesky redundant Functor constraint. which is a limitation of haskell, not the model
10:51:22 <unkanon> aristid: wow, I get that warning about the Functor constraint all the time, that's the only reason I disabled my beloved -Wall
10:52:26 <unkanon> what's more idiomatic for say, Lists? to use fmap to lift a function or to use liftM?
10:52:30 <aristid> there's a warning about that?
10:52:36 <aristid> unkanon: for lists, just use map
10:53:26 <unkanon> well yeah, you're right...
10:53:38 <unkanon> aristid: yes, let me see if I can find it, hold on
10:54:40 <morgan> ciao
10:55:02 <unkanon> aristid: found it, here is a snippet of my ghci session: http://hpaste.org/41957/functor_constraint_warning
10:55:36 <aristid> let (.:) = fmap . fmap
10:55:47 <unkanon> yeah but I couldn't do that in ghci
10:55:54 <aristid> i should note that you can find (.:) in the package functors (sorry for the relentless advertising)
10:56:05 * hackagebot convertible-text 0.3.0.8 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.8 (MichaelSnoyman)
10:56:08 * hackagebot data-object 0.3.1.6 - Represent hierachichal structures, called objects in JSON.  http://hackage.haskell.org/package/data-object-0.3.1.6 (MichaelSnoyman)
10:56:20 <unkanon> aristid: I'm a newbie, what do you mean by that? how do I get a package?
10:56:25 <unkanon> did you create that package?
10:56:28 <aristid> yes :)
10:56:33 <aristid> cabal install functors
10:56:37 <unkanon> oh I see
10:56:40 <aristid> and then just import Data.Functor.Syntax
10:56:49 <unkanon> I'll do that but I'd like to learn how to make it work in ghci first
10:56:59 <unkanon> I don't understand why it won't accept my definition
10:57:00 <aristid> :set -XNoMonomorphismRestriction
10:57:13 <unkanon> do I really have to do that to make it work?
10:57:17 <aristid> forall a b (f :: * -> *) (g :: * -> *). 
10:57:22 <aristid> this part is totally unnecessary
10:57:30 <aristid> just leave it out, and ghci should be happy
10:57:42 <unkanon> I tried that too, ddn't I?
10:57:43 <aristid> but -XNoMonomorphismRestriction is much easier
10:57:56 <unkanon> yeah I did
10:57:58 <unkanon> right after
10:58:06 * hackagebot data-object-json 0.3.1.5 - Serialize JSON data to/from Haskell using the data-object library.  http://hackage.haskell.org/package/data-object-json-0.3.1.5 (MichaelSnoyman)
10:58:08 * hackagebot data-object-yaml 0.3.3.3 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.3.3 (MichaelSnoyman)
10:58:10 * hackagebot hamlet 0.6.0.3 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.6.0.3 (MichaelSnoyman)
10:58:12 * hackagebot json2yaml 0.2.3 - Utility to convert a file from JSON to YAML format.  http://hackage.haskell.org/package/json2yaml-0.2.3 (MichaelSnoyman)
10:58:14 * hackagebot mime-mail 0.0.0.3 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.0.0.3 (MichaelSnoyman)
10:58:21 <aristid> michael snoyman is a spammer
10:58:35 <lispy1> heh
10:58:44 <lispy1> aristid: blame the bot not the uploader :)
10:58:47 <unkanon> aristid: let (.:) = fmap . fmap :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
10:58:56 <unkanon> ghci didn't like that
10:59:08 <unkanon> (I will use the -X "cheat" as a last resort )
10:59:11 <mauke> let (.:) x = (fmap . fmap) x
10:59:16 * hackagebot persistent 0.3.1.2 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.3.1.2 (MichaelSnoyman)
10:59:18 * hackagebot persistent-postgresql 0.3.1.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.3.1.1 (MichaelSnoyman)
10:59:20 * hackagebot web-encodings 0.3.0.5 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.5 (MichaelSnoyman)
10:59:22 * hackagebot web-routes-quasi 0.6.1.3 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.1.3 (MichaelSnoyman)
10:59:24 * hackagebot yesod-auth 0.2.0.3 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.2.0.3 (MichaelSnoyman)
10:59:30 <BONUS> lol
10:59:51 <companion_cube> maybe he found a HDD he lost one year ago, and want to commit everything
10:59:54 <aristid> let (.:) :: (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b); (.:) = fmap . fmap
10:59:59 <aristid> ^ unkanon
11:00:17 <aristid> unkanon: but -XNoMonomorphismRestriction is no cheat.
11:00:21 <unkanon> mauke: but that's not pointless, it's ugly :P
11:00:35 <zygoloid> eww. <<$>> = fmap . fmap; <<<$>>> = fmap . fmap . fmap, ... :)
11:00:45 <pkrumins> :t fmap . fmap
11:00:46 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
11:00:48 <aristid> zygoloid: (.:)! :P
11:00:51 <pkrumins> what's the use of double fmap?
11:00:58 <unkanon> aristid: thanks!
11:01:07 <zygoloid> aristid: (.) = fmap is icky. generalizing based off that is double-icky :)
11:01:22 <zygoloid> @where sec
11:01:22 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
11:01:23 <unkanon> aristid: is that -X the one that haskellers like? that they didn't like that there was such a restriction in the first placE?
11:01:32 <zygoloid> pkrumins: ^^ read that for background :)
11:01:52 <aristid> pkrumins: (=<<) = join .: fmap, where (.:) = fmap . fmap :)
11:02:49 <unkanon> I still don't understand why (.) = fmap but it's time to get back to work now
11:02:50 <aristid> zygoloid: i like (.) = fmap, somehow :)
11:02:52 <ajnsit> I just came up with an arrow definition that looks like this - data Proc m a b = Proc (a -> m (Proc m a b , b)) -- basically an arrow that takes a value and returns an action that when run gives a continuation arrow and a result
11:02:55 <ajnsit> I am wondering if something like this has a name
11:03:18 <aristid> unkanon: (.) = fmap works because instance Functor (e ->) where fmap = (.)
11:03:59 <jro> what editors you like on OS X?
11:04:04 <unkanon> aristid: I'll ponder over that and I'll try to make (.) become fmap via lambda calculus
11:04:08 <MrAI> :t Inn
11:04:09 <lambdabot> Not in scope: data constructor `Inn'
11:04:21 <MrAI> :t unInn
11:04:21 <c_wraith> :t In
11:04:22 <lambdabot> Not in scope: `unInn'
11:04:22 <zygoloid> aristid: join .: fmap means nothing to me.  (join .) . fmap  is much clearer. :)
11:04:22 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
11:04:33 <lispy1> jro: I pretty much just stick to emacs for haskell.  On OSX that's either aqua emacs, carbon emacs, or emacs23, or the a console version of emacs
11:04:38 <MrAI> :t unIn
11:04:39 <lambdabot> Not in scope: `unIn'
11:04:41 <MrAI> :t In
11:04:42 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
11:04:48 <zygoloid> aristid: this is probably mostly familiarity, but i'm familiar with standard haskell where (.) is just composition
11:04:54 <aristid> zygoloid: i think join .: fmap is much clearer
11:05:04 <zygoloid> (generalized (.) makes code which uses (.) much harder to understand, imo)
11:05:08 <aristid> zygoloid: well (.:) = (.) . (.) would work for join .: fmap too
11:05:37 <aristid> zygoloid: but when .: also works on functions that return lists, and such things, it just gets much nicer IMO :)
11:06:28 <unkanon> hold on, to say (.) = fmap doesn't mean anything
11:06:38 <unkanon> whose fmap are we talking about? each functor defines their own
11:06:44 <zygoloid> aristid: i'll be honest: i've never tried writing code with (.) = fmap. and the reason for that is that i think i'd find the code far too hard to read
11:06:59 <mauke> unkanon: all of them
11:07:12 <zygoloid> but you're not the first person to tell me that they use (.) = fmap and don't have that problem, so maybe i'm just wrong
11:07:13 <aristid> zygoloid: i don't really care about (.) = fmap, either. but (.:) = fmap.fmap is very useful.
11:07:24 <unkanon> zygoloid: you mean you've never tried writing code with (.) = fmap in mind, right?
11:07:45 <zygoloid> unkanon: no, i mean hiding Prelude.(.), and using (.) = fmap instead
11:07:53 <mauke> (Prelude..)
11:07:55 <unkanon> mauke: ok so if I want to try and derive fmap from (.) which fmap should I choose to make it easy? :)
11:08:02 <mauke> unkanon: huh?
11:08:05 <unkanon> zygoloid: oh
11:08:12 <aristid> zygoloid: i don't actually use (.) = fmap that much. most of the time i use <$>. it's all about the (.:)
11:08:33 <unkanon> I'm lost, I thought you guys meant that (f . g) x = f (g x) === fmap
11:08:57 <mauke> no, we literally mean (.) = fmap
11:09:00 <aristid> polymorphism breaks equational reasoning
11:09:16 <unkanon> that's really strange
11:09:20 <zygoloid> mauke: if others want to live in the world of caleskel, i think i should be allowed to live in the hypothetical world of -XQualifiedOperators ;)
11:09:39 <mauke> > succ . "uncanon"
11:09:40 <lambdabot>   "vodbopo"
11:09:52 <zygoloid> *-XNewQualifiedOperators
11:09:55 <unkanon> mauke: you broke (.) ! :)
11:10:01 <aristid> zygoloid: well, just because others like to drink alcohol doesn't mean marijuana is allowed.
11:10:18 <aristid> unkanon: it's Caleskell
11:10:30 <mauke> > (* 2) . ord . "unkanon"
11:10:32 <lambdabot>   [234,220,214,194,220,222,220]
11:10:37 <unkanon> I'm really lost now...
11:10:39 <aristid> unkanon: http://hackage.haskell.org/packages/archive/functors/0.1/doc/html/src/Data-Functor-Syntax.html#.
11:10:48 <unkanon> you guys are making me unlearn haskell
11:10:58 <unkanon> I'll look into it, aristid 
11:11:08 <aristid> it's a single line of code, lol
11:11:43 <unkanon> I gotta go now unfortunately, but I definitely need to come back to this conversation
11:12:23 <unkanon> see you guys later
11:12:42 <aristid> k
11:13:04 <zygoloid> aristid: how do you generalize (.:) to three functors?
11:13:17 <aristid> zygoloid: (.::) = fmap . fmap . fmap
11:13:30 <ajnsit> mauke: wow! how does succ . "uncanon" even work?
11:13:39 <aristid> ajnsit: by defining (.) = fmap
11:13:41 <mauke> ajnsit: (.) = fmap
11:13:47 <ajnsit> ah okay
11:13:51 <c_wraith> :t (.)
11:13:51 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:13:52 <aristid> ajnsit: do you understand why fmap succ "uncanon" works?
11:14:00 <mauke> which is only what we've been talking about the whole time
11:14:01 <zygoloid> aristid: that seems so much less clean than ($), (<$>), (<<$>>), (<<<$>>>) 
11:14:20 <ajnsit> aristid, Yeah :)
11:14:21 <aristid> zygoloid: <<<$>>> looks ugly
11:14:32 <copumpkin> <<<<<<<<<<<<<<<<<<$>>>>>>>>>>>>>>>>
11:14:54 <aristid> copumpkin: did you count the < and >?
11:15:00 <aristid> <<<<<<<<<<<<<<<<<<
11:15:05 <aristid> >>>>>>>>>>>>>>>>
11:15:06 <ajnsit> but does lambdabot do (.) = fmap by default?
11:15:07 <aristid> no
11:15:12 <aristid> ajnsit: lambdabot does
11:15:25 <aristid> ajnsit: we call it "Caleskell", which Cale does not like at all
11:15:47 <ajnsit> Caleskell??
11:15:52 <ajnsit> First time I've heard of it
11:16:07 <lispy1> ajnsit: person who made the change (.) = fmap is named Cale
11:16:31 <ajnsit> ah okay
11:16:36 <lispy1> I think Cale was right to want to change it, but putting the change in the Prelude was wrong.
11:16:38 <Utkarsh> Why would I be getting "<interactive>:1:0: Not in scope: `sort'" in ghci? Do I have to include some module or anything?
11:16:51 <lispy1> ?hoogle sort
11:16:51 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
11:16:52 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
11:16:52 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
11:16:58 <Cale> lispy1: hm?
11:16:59 <unkanon> Utkarsh: :m +Data.List
11:17:03 <lispy1> Utkarsh: you may need to import Data.List
11:17:05 <Cale> lispy1: I didn't put the change in the Prelude.
11:17:29 <aristid> Cale: i guess lispy1 wants it to be in some qualified import?
11:17:34 <Utkarsh> lispy1: ah thanks :)
11:17:38 <lispy1> Cale: I know you didn't modify the Prelude, but by importing it unqualified and hiding the prelude version, that's effectively what happened :)
11:17:59 <mauke> unkanon: that's harder to type than 'import Data.List'
11:18:35 <unkanon> mauke: isn't that new syntax?
11:18:42 <mauke> huh?
11:19:01 <unkanon> oh no, the new one is the one that allows you to do qualified imports
11:19:07 <unkanon> in ghci
11:19:07 <aristid> mauke: :m +Data.List is much easier to type oO
11:21:36 <c_wraith> aristid, I find : and + to be annoying to type. :)
11:21:45 <Cale> mauke: import Data.List in ghci is new
11:21:48 <aristid> c_wraith: which keyboard layout?
11:21:55 <c_wraith> letters are *much* easier for me to type.
11:21:59 <unkanon> mauke: I remember seeing a ticket saying that someone made qualified imports work in ghci and that made it to the latest ghc release
11:22:02 <c_wraith> usa standard qwerty
11:22:18 <unkanon> Cale: ah, I thought so
11:22:19 <c_wraith> "import" in ghci has worked since 6.10.4, I think
11:22:20 <lispy1> dvorak!
11:22:30 <c_wraith> what's new is qualified import
11:22:41 <aristid> c_wraith: are your fingers very clumsy? :)
11:23:05 <c_wraith> arisit: the shift key takes coordination that I'd rather not bother with.  and both : and + require using shift
11:23:20 <c_wraith> err, I fail at typing your name, sorry
11:23:33 <sinelaw> I'm with c_wraith 
11:23:48 <sinelaw> though for IRC nicks you can use tab usually
11:23:51 <sinelaw> ;)
11:23:57 <c_wraith> yeah, don't know how I got that one wrongh
11:26:31 <tim_> can somebody help a newbie to chose the right packages in order to work with quickcheck? Leksah displays a lot of Modules, but I never know what modules to import and what to put into the cabal file :-(
11:27:17 <FunctorSalad> tim_: Test.QuickCheck reexports all the basic things iirc
11:27:54 <tim_> do I need the QuickCheck package or test-framework-quickcheck?
11:28:18 <FunctorSalad> QuickCheck
11:28:26 <tim_> ok I'll try it
11:28:33 <tim_> thanks so far :-)
11:28:56 <FunctorSalad> (watch out for the versions, the 1.2 version is still relatively widespread and incompatible with 2.X)
11:29:03 <nominolo> preflex: seen chrisdone
11:29:04 <preflex>  chrisdone was last seen on #haskell 13 days, 7 hours, 3 minutes and 40 seconds ago, saying: oh well, I can just use that one now
11:29:06 <jro> test-framework looks good
11:29:09 <jro> http://batterseapower.github.com/test-framework/
11:29:23 <FunctorSalad> so you may well have both 1.2 and 2.X installed
11:32:42 <tim_> @FunctorSalad I have a version conflict:  Following an example from Realworld Haskell, I need TestOptions, but I get   Could not find module `Test.QuickCheck.Batch':       It is a member of the hidden package `QuickCheck-1.2.0.1'. 
11:32:42 <lambdabot> Unknown command, try @list
11:33:22 <FunctorSalad> tim_: I don't know where the equivalent in 2.4 is, but here's the docs http://hackage.haskell.org/package/QuickCheck
11:34:29 <FunctorSalad> (you're getting that error because the module exists in 1.2.0.1 but not in the 2.X you have installed, and you have 1.2.0.1 hidden)
11:34:33 <tim_> I'm afraid that TestOptions are no longer inside QuickCheck, otherwise Leksah should find it
11:34:52 <unkanon> tim_: did you read the comments on RWH? often people will say in the comments what changed since the book was edited
11:35:01 <__name__> hey!
11:35:14 <tim_> ok I'll try
11:35:20 <__name__> in case anyone has the required permissions: the â€œcode generator for GHC based on LLVMâ€ link is broken on http://haskell.org/.
11:45:31 <RayNbow> roconnor: "lector" itself isn't a verb, right?
11:45:45 <unkanon> RayNbow: it's a noun in latin
11:45:50 <copumpkin> reader
11:45:53 <unkanon> one who reads / gathers
11:46:29 * roconnor beleives what unkanon says
11:46:50 <unkanon> I know some latin, you can believe me :)
11:47:32 <medfly> http://en.wiktionary.org/wiki/lector#English
11:47:34 <medfly> just sayin'
11:47:38 * RayNbow knows that the verb is legere (inf.; lego 1st sg.)
11:47:45 <unkanon> lego, legis, legit, legimus, legitis, legunt = I read, you read, he reads...
11:48:29 <RayNbow> heh, I can no longer conjugate Latin verbs
11:48:39 <tim_> When deinstalling a package, is there a better way then to unregister it from ghc and then manually delete it from cabal? I guess so, but I don't know...
11:48:43 <unkanon> I hate the 4th conjugation but I can make do
11:49:12 * RayNbow should still have some Latin textbooks somewhere hidden in his room
11:49:29 <RayNbow> but Latin isn't something I use every day
11:49:49 * unkanon has 6 latin books in his bookshelf of 40ish only books
11:50:23 <tim_> FunctorSalad: When deinstalling a package, is there a better way then to unregister it from ghc and then manually delete it from cabal?
11:50:43 <dolio> No.
11:50:52 <tim_> thx
12:01:10 <alvivi> Maybe someone can help me... A C function which register a callback have to be defined as safe? or just the callback function wrapper have to be defined as safe ? 
12:02:00 <c_wraith> alvivi, you should use safe unless you know *exactly* what *all* the consequences of using unsafe are.  In other words, if you have to ask, you want safe.
12:02:01 <Twey> It's not safe
12:03:20 <revenantphx> How is "safe" defined anyhow.
12:03:27 <revenantphx> I see unsafePerformIO, but how is it "unsafe"
12:03:32 <revenantphx> :t unsafePerformIO
12:03:33 <lambdabot> Not in scope: `unsafePerformIO'
12:04:10 <jmcarthur> revenantphx: unsafePerformIO is unsafe because it thwarts the usual guarantees of the type system
12:04:18 <revenantphx> how so?
12:04:31 <alvivi> c_wraith: Thanks, I'm going to follow your advice ^^
12:04:32 <Cale> revenantphx: It's unsafe for several reasons. What it does is to cause the evaluation of its result to carry out the given IO action, and evaluate to the result of that action.
12:04:33 <jmcarthur> revenantphx: it allows you to make impure functions with pure type signatures
12:04:50 <revenantphx> Oh right, I see.
12:05:07 <Cale> First of all, IO actions are allowed to produce different results based on their order, but there is no guarantee about what order expressions are evaluated in by the compiler.
12:05:36 <Cale> Moreover, if you combine it with IORefs (mutable cells), you can completely break the type system
12:05:43 <c_wraith> revenantphx, alvivi and I were specifically talking about safe and unsafe in the context of FFI foreign imports, which has to do with how the RTS handles foreign calls.
12:05:43 <revenantphx> 0.o
12:05:49 <Cale> It's possible to write a function of type a -> b
12:06:00 <revenantphx> Cale: that does... a lot of side effects?
12:06:19 <Cale> Actually, not so many side effects even, just a little writing to a memory cell
12:06:41 <c_wraith> it's not thread safe!  it could be even worse than unsafeCoerce! :)
12:06:42 <jmcarthur> revenantphx: a function of type a -> b is essentially unsafeCoerce
12:07:08 <Cale> unsafeCoerce x = unsafePerformIO (do writeIORef r x; readIORef r) where r :: IORef a; r = unsafePerformIO (newIORef undefined)
12:07:30 <alvivi> like const? :P
12:07:37 <Cale> So, we make a polymorphic IORef, called r
12:07:40 <jmcarthur> const?
12:07:42 <aristid> @hoogle writeIORef
12:07:42 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
12:07:44 <Cale> r :: IORef a
12:07:49 <jmcarthur> alvivi: what does const have to do with it?
12:07:51 <revenantphx> :t unsafeCoerce
12:07:52 <lambdabot> Not in scope: `unsafeCoerce'
12:07:59 <Cale> and so we can write any type of value to that IORef, and read any other type
12:08:11 <revenantphx> Oh shit. It's C style casting :O.
12:08:14 <revenantphx> The world will now end.
12:08:16 <Cale> yes
12:08:17 <jmcarthur> revenantphx: right
12:08:23 <alvivi> only the type: const undefined :P
12:08:32 <revenantphx> void * basically :P
12:08:35 <revenantphx> Hahaha, C casting and pure functions don't mix.
12:08:37 <Cale> You get segfaults and undefined behaviour and that sort of thing if you abuse this.
12:08:38 <jmcarthur> :t const undefined
12:08:39 <lambdabot> forall a b. b -> a
12:08:46 <jmcarthur> alvivi: the const is unnecessary there ;)
12:08:51 <c_wraith> :t undefined :: (a -> b)
12:08:52 <lambdabot> forall a b. a -> b
12:08:54 <jmcarthur> :t undefined :: a -> b
12:08:55 <lambdabot> forall a b. a -> b
12:08:58 <jmcarthur> bah!
12:09:15 <Cale> In fact, an IOHCC entry used unsafeCoerce on a ByteString to cast to a function value which it then applied :)
12:09:20 <alvivi> lol
12:09:58 <Cale> (Only worked in one particular version of GHC though)
12:10:03 <kmc> i did that once
12:10:10 <kmc> actually not with unsafeCoerce
12:10:29 <c_wraith> doesn't the LLVM library do something like that?
12:10:29 <revenantphx> Yay. Now when I type "hackage pckname" in safari, it goes to the hackage page
12:10:48 <kmc> ByteString -> ForeignPtr -> Ptr -> FunPtr -> function
12:11:54 <tim_> I have base-3 on my system and get often warnings for it. Can I safely unregister?
12:12:18 <saml> [a,b,c,d,e],  [c,d,e,f,g,h]  ==>  [a,b,c,d,e,f,g,h]    is there a name for this kind of merge?
12:12:38 <saml> overlapping two lists back to front
12:12:38 <Cale> tim_: I wouldn't...
12:12:45 <tim_> ok thx
12:12:51 <Cale> tim_: You could probably do it...
12:13:05 <Cale> tim_: But you might end up reinstalling GHC :P
12:13:14 <Twey> tim_: Just set --preference="base >= 4" maybe
12:13:29 <tim_> where is this setting made?
12:14:02 <Twey> Well, with the -- it's a command-line argument to cabal-install
12:14:39 <Twey> â€˜preference: base >= 4â€™ in ~/.cabal/config
12:15:27 <unkanon> tim_: you mean merge and remove duplicates? or merge but not the duplicates?
12:15:53 <tim_> unkanon: no, I don't want to merge
12:16:26 <tim_> I just thaught the warning could actually mean something to me
12:16:32 <unkanon> tim_: it looks to me like you merged two lists but avoided duplicates
12:16:41 <unkanon> oh sorry
12:16:46 <unkanon> saml: I meant you ^
12:17:01 <tim_> lol
12:17:10 <unkanon> tim_: sorry
12:17:19 <tim_> np
12:19:20 <tim_> I'm confused about the duality of cabal and ghc-pkg - I don't understand the intention behind that ... why is a package not removed when I unregister it?
12:20:27 <dolio> ghc-pkg just tracks all the things that have been installed. It and cabal and whatnot are not full-fledged package managers.
12:20:34 <tim_> and I don't know how to handle different versions ... sometimes I can't even install because constraints are not satisfied
12:21:02 <dolio> Unregistering deletes it from the database, but it doesn't know what all files belong to that package, and doesn't delete anything.
12:21:24 <dolio> Doesn't delete any files on disk, that is.
12:21:47 <tim_> Ok, as long as I can be sure nobody will still read the remaining unregistered files, I don't care
12:22:11 <kmc> cabal is more like 'make + make install' than like a package manager
12:23:19 <kmc> but it's aware of dependencies and can fetch stuff from the web
12:23:21 <kmc> so it's halfway
12:23:46 * dcoutts_ intends that the cabal-install prog will become more like a package manager
12:24:02 <kmc> tim_, handling different versions should mostly just work
12:24:11 <kmc> unless the same library or exe depends on two versions of some other library
12:24:12 <dcoutts_> but the Cabal lib and the Setup.hs interface will remain like make + make install
12:24:39 <chadz> anyone use the hxt 9 and get around the syntax issues with proc foo -> do ?
12:24:48 <kmc> it would be great to integrate more with linux distro package managers
12:25:06 <chadz> i have "getItems = atTag "item" >>> proc x -> do ..." and it tusn into a  parse error on input `->'
12:25:25 <tim_> trying to install test-framework-quickcheck2  I have a confilict:  cabal: dependencies conflict: ghc-6.12.1 requires array ==0.3.0.2 however array-0.3.0.2 was excluded because ghc-6.12.1 requires array ==0.3.0.0
12:25:48 <kmc> even if Debian doesn't package the library i want, i could have cabal build a .deb locally and install it
12:25:52 <kmc> is there anything like that currently?
12:26:41 <chadz> kmc: arch ahs a cabal2arch tool
12:27:24 <kmc> i find it silly to have a package manager for each OS and a package manager for each language, but this problem extends far beyond Haskell
12:27:30 <saml> unkanon, yah. it's like overlapping two lists.    [a,b,c], [a,b,d]  ==>  [a,b,c,a,b,d]  (no overlap).      [a,b,c], [a,b,c,d] ==> [a,b,c,d]     ([a,b,c] overlaps)
12:28:33 <unkanon> saml: that's what I thought. you're lookign for a standard function that does that? I dn't think there is one, but if there is it'll probably be in Data.List
12:28:41 <unkanon> saml: and if there isn't it should be easy to build one
12:29:30 <burp> cabal can build .deb's by itself? o0
12:29:36 <dcoutts_> kmc: yep, several distros have cabal->native tools
12:29:45 <dcoutts_> burp: no, they're separate tools
12:30:11 <dcoutts_> the distros have a lot of custom QA standards, it's better for them to maintain those tools rather than having that code in cabal
12:30:32 <dcoutts_> and it's not always fully automatable, especially the QA
12:30:32 <chadz> dcoutts_: given those tools, i don't know why the hackage page doesn't just generate the distro packages automatically
12:30:42 <dcoutts_> because that's what the distros do
12:31:00 <dcoutts_> and as I mentioned, it's not necessarily fully automatic
12:31:25 <chadz> i suppose. 
12:31:31 <jro> what pkg tools you use in os x?
12:31:42 <dcoutts_> we would not want to usurp the position of the distro teams, and make their life hell by providing native packages that don't quite integrate properly
12:31:54 <burp> macports
12:32:09 <jro> I installed ghc using port, then http zlib manuall to get cabal working
12:32:12 <burp> or there is something new, homebrew
12:32:43 <dcoutts_> kmc: aye, it's not an ideal situation, but we did design the .cabal format with translation in mind, so it's not necessary to use a custom language specific package manager
12:33:00 <dcoutts_> tim_: check out the Cabal FAQ
12:33:37 <tim_> yes ok
12:33:42 <dcoutts_> oh, it's not been moved to the new server yet
12:36:00 <unkanon> saml: > overlap [1,2,3] [2,3,4]
12:36:06 <unkanon> > overlap [1,2,3] [2,3,4]
12:36:07 <lambdabot>   [1,2,3,4]
12:36:39 <saml> @src overlap
12:36:40 <lambdabot> Source not found. Maybe you made a typo?
12:36:41 <unkanon> > ((nub .) . (++)) [1,2,3] [2,3,4]
12:36:42 <lambdabot>   [1,2,3,4]
12:36:49 <unkanon> that's the src
12:37:02 <unkanon> overlap = (nub .) . (++)
12:37:11 <saml> >  ((nub .) . (++))  "a.b.c.d.e"  "c.d.a"
12:37:12 <lambdabot>   "a.bcde"
12:37:31 <saml> i would expect "a.b.c.d.e.c.d.a"
12:38:09 <unkanon> I don't get it then :P
12:38:27 <aristid> saml: .:!
12:38:34 <danr> but nub does not add a period at the 10th character in a string :)
12:38:43 <aristid> > (nub .: (++)) "a.b.c.d.e"  "c.d.a"
12:38:44 <lambdabot>   "a.bcde"
12:39:02 <aristid> saml: nub removes all duplicate characters
12:39:02 <unkanon> .: = .).   :)
12:39:19 <aristid> saml: more than one . is therefore not to be expected :)
12:42:05 <chadz> so, anyone use hxt9 know how to get the proc style syntax working in a typical filter-ish function?
12:52:50 <dolio> chadz: I'm not sure what you mean, exactly. I think I remember how to write proc-style stuff, though.
12:54:19 <chadz> dolio: hmm, i think hxt just no longer supports the proc _ -> style
12:54:34 <dolio> Does it still use arrows?
12:54:57 <chadz> yeah
12:55:18 <dolio> proc is just sugar for writing arrows.
12:55:24 <chadz> except you no longer have to include the HXT.Arrow include
12:55:34 <chadz> hmm
12:55:43 <dolio> proc x -> ... is similar to lambda.
12:56:00 <chadz> might just need an include then.. Control.Arrow ?
12:56:05 <dolio> f -< x is similar to application
12:56:37 <dolio> And y <- e is like naming results, where the 'do' is similar to 'let'.
12:56:57 <proq> what package is nub in?
12:57:02 <copumpkin> Data.List
12:57:03 <unkanon> Data.List
12:57:05 <dolio> It requires an extention. Arrows or something.
12:57:30 <dolio> Yes, {-# LANGUAGE Arrows #-}
12:57:51 <chadz> yeah, i stuck that in my file and it's still not working :/
12:58:38 <chadz> oh, it had to be above the module Main...
12:58:39 <chadz> fml
13:19:14 <nejucomo> I need to understand classes better.
13:19:44 <nejucomo> Can I define:  class C a => C b where foo :: b -> a
13:20:47 <nejucomo> That is, given any two (different) instances of a class, it defines an injection from one type to the other?
13:22:12 <alpounet> a typeclass must introduce a new identifier 
13:22:57 <copumpkin> seems like for that, you'd want class C a b where convert :: a -> b
13:23:02 <copumpkin> or inject or something
13:23:05 <alvivi> some like  class C b where foo :: C a => a -> b ?
13:23:11 <alpounet> moreover what you want would more be like : class Convertable a b where foo :: a -> b
13:26:58 <nejucomo> I see.
13:27:09 <tim_> thx for helping ... bye
13:28:41 <nejucomo> I believe the type alvivi proposes is what I want:  For any instance C a, it must be able to convert to any instance C b:  class C src where convert :: C dst => src -> dst
13:29:20 <copumpkin> you can't convert "between instances"
13:29:25 <nejucomo> The meta-problem is that I don't know whether or not this is possible in Haskell (perhaps with GHC extensions).
13:29:48 <copumpkin> how would you even convert between them, since you handle them in isolation?
13:34:04 <byorgey> nejucomo: you could do something like   class C a where toRep :: a -> Rep; fromRep :: Rep -> a
13:34:12 <byorgey> where Rep is an appropriate type
13:34:36 <byorgey> then you could have   convert :: C a, C b => a -> b ;  convert = fromRep . toRep
13:35:05 <nejucomo> Yeah, I think I'm going to end up roping in Dynamic somehow.
13:36:02 <FunctorSalad> seems like one will need a linear algebra package to derive Arbitrary nicely ;)
13:36:06 <FunctorSalad> for mutually recursive types
13:36:13 <byorgey> my 'Rep' suggestion had nothing to do with Dynamic
13:36:45 <FunctorSalad> to calculate the convergence and expected size of the generated value
13:37:13 <alpounet> byorgey, awesome post about species by the way
13:37:26 <copumpkin> nejucomo: why not my suggestion?
13:37:30 <byorgey> the only way you will be able to convert between any two instances of C is if you have one "central" representation which can be used as an intermediary
13:37:40 <byorgey> alpounet: thanks
13:38:12 <FunctorSalad> I guess another way would be to just randomly partition the size parameter over the recursive positions of a constructor
13:39:14 <FunctorSalad> oh well, it has probably been done already anyway
13:41:49 <byorgey> FunctorSalad: this is a solved problem =)
13:42:01 <FunctorSalad> byorgey: where?
13:42:04 <dons> ?seen tommd
13:42:04 <lambdabot> Unknown command, try @list
13:43:22 <nejucomo> Sorry copumpkin, busy now, back later.
13:43:43 <FunctorSalad> I think one would want an auxilliary "RandomLeaf" class first that only makes non-recursive values
13:43:48 <byorgey> FunctorSalad: for example, see "Fast and sound random gener-
13:43:48 <byorgey> ation for automated testing and benchmarking in objective Caml.
13:43:58 <byorgey> by Canou and Darasse
13:44:36 <FunctorSalad> ah. but no generic Arbitrary? (there's one for 'regular', but as the name suggests, it isn't for mutually recursive types ;))
13:44:39 <byorgey> but the techniques have been known in the combinatorial analysis community for quite some time, IIUC
13:45:26 <byorgey> it hasn't yet been implemented in Haskell as far as I know
13:45:54 <FunctorSalad> I think you'd just make a matrix containing, at (i,j), the expected number of type j children for a random value of type i
13:46:13 <FunctorSalad> and look at its eigenvalues
13:57:30 <DDave> Good evening, can somebody help me to understand 1 line of Haskell? I have an assignment to do but unfortunately I cannot understand what the _ in  "\_ n -> n + 1" means.. here's the link: http://pastebin.com/vPhRtT3W
13:57:42 <opqdonut> it's just an unused parameter
13:57:45 <c_wraith> DDave, it's an anonymous function
13:57:47 <opqdonut> to the lambda expression
13:57:54 <DDave> Oh.. just an unused parameter? oh my..
13:57:58 <DDave> Thanks a lot
13:58:18 <d-snp> hey, I'm learning haskell IO in the wiki it says: Ordinary Haskell evaluation doesn't cause this execution to occur. A value of type (IO a) is almost completely inert
13:58:19 <c_wraith> oh, I misread the question.  yeah, _ means "I'm not going to use this value"
13:58:31 <d-snp> can anyone explain what they mean by that?
13:58:47 <DDave> c_wraith, thanks a lot, I'm going to finish my assignment now :)
13:58:56 <jmcarthur> d-snp: it means that something of type (IO a) is a data representation of side-effects for the runtime to carry out
13:59:03 <c_wraith> d-snp, It means that evaluating an expression is not the same as executing it
13:59:10 <FunctorSalad> th suggestion: use record syntax for the AST ADTs to allow people to write more forwards-compatible code
13:59:16 <blubsala> question: . to $ is like >=> to >>= ?
13:59:35 <FunctorSalad> (for when fields are added in the future)
13:59:39 <jmcarthur> d-snp: that is, evaluating something of type (IO a) is pure in the same way that evaluating a String full of source code is pure
13:59:45 <Zao> d-snp: You can juggle around IO actions almost in any way you want without them being "sequenced".
13:59:45 <c_wraith> blubsala, yes, though I'd say it's more like <=< is to =<<
14:00:15 <d-snp> Zao: ok, so does that say something about the order in which it is executed then?
14:00:28 <Zao> > length $ replicate 4 [print "lol", print "huhu"]
14:00:30 <lambdabot>   4
14:00:37 <d-snp> is it lazily evaluated like normal haskell expressions?
14:00:46 <jmcarthur> d-snp: the runtime orders IO based on your use of (>>=)
14:00:53 <Zao> d-snp: They are executed when used with >> and >>= in the IO monad.
14:01:00 <jmcarthur> d-snp: the runtime is the interpreter of the IO "source code"
14:01:05 <Zao> (or with do notation, which is sugar for that)
14:01:28 <jmcarthur> d-snp: the runtime will force bits of the "source code" as it needs it, but that evaluation is not what causes the side effects
14:01:52 <Zao> @type do { x <- getContents; print x }
14:01:54 <lambdabot> IO ()
14:02:17 <dixie> @type 1/0
14:02:19 <lambdabot> forall t. (Fractional t) => t
14:02:23 <Zao> That is roughly equivalent to  (getContents >>= \x -> print x)
14:02:35 <dixie> @type [1..]
14:02:37 <lambdabot> forall t. (Num t, Enum t) => [t]
14:02:47 <ion> Isnâ€™t it exactly equivalent?
14:02:48 <jmcarthur> @undo do { x <- getContents; print x }
14:02:48 <lambdabot> getContents >>= \ x -> print x
14:02:53 <Zao> >>= which performs the monadic action on the left, and feeds the result to the action on the right.
14:02:58 <Zao> (roughly)
14:03:05 <dixie> @type (map (\x -> 1/x) [1..])
14:03:07 <lambdabot> forall a. (Fractional a, Enum a) => [a]
14:03:31 <Zao> @pl getContents >>= \x -> print x
14:03:31 <lambdabot> print =<< getContents
14:03:47 <dixie> @type (sum $ map (\x -> 1.0/x) [1..])
14:03:49 <lambdabot> forall a. (Fractional a, Enum a) => a
14:03:57 <Zao> @. pl undo do { x <- getContents; print x }
14:03:58 <lambdabot> print =<< getContents
14:04:11 <d-snp> @type putStrLine
14:04:13 <lambdabot> Not in scope: `putStrLine'
14:04:18 <d-snp> @type putStrLn
14:04:20 <lambdabot> String -> IO ()
14:04:39 <d-snp> @type getLine
14:04:40 <lambdabot> IO String
14:04:48 <d-snp> hmm
14:05:10 <c_wraith> > [getLine, getLine, getLine]
14:05:11 <lambdabot>   [<IO [Char]>,<IO [Char]>,<IO [Char]>]
14:05:38 <Zao> @type sequence
14:05:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:05:56 <c_wraith> > sequence [getLine, getLine, getLine]
14:05:56 <lambdabot>   <IO [[Char]]>
14:06:33 <d-snp> I will probably understand this better if I learn what a monad is right?
14:06:52 <Zao> Depends on whose explaination you use.
14:07:27 <d-snp> yours? :P
14:07:35 <Zao> I don't have any good ones.
14:08:01 <c_wraith> I'd argue that the answer is no.
14:08:02 <d-snp> jmcarthur's confused me a bit too :\
14:08:06 <Zao> The formal definition is something like: "it has >>= and stuff".
14:08:10 <c_wraith> In fact, this isn't really about monads at all.
14:08:34 <c_wraith> monads happen to be the name of the interface IO uses, but that's a superficial detail
14:08:57 <c_wraith> The important part is that an IO action does nothing by itself...  It has to be bound into main somehow to do anything.
14:09:15 <opqdonut> I suggest learning to use IO before trying to learn Monads in general
14:09:36 <Zao> I'm leaving the answers for people who aren't on horribad mobile internet.
14:10:06 <djahandarie> I suggest we provide an interface to IO besides the monad operators and eliminate the confusion
14:10:07 <unkanon> d-snp: do this: main = getLine >>= putStr and try to understand it. I found it to be a good start
14:10:07 <c_wraith> I think the best viewpoint is that IO actions are descriptions of things to do.  actually executing them is the job of the runtime, and outside the scope of the language.
14:10:24 <unkanon> djahandarie: like the request lists of yore?
14:10:44 <djahandarie> Huh?
14:10:51 <unkanon> before monads
14:11:01 <unkanon> haskell used some strange request lists deal for IO
14:11:07 <DDave> Can somebody look at this error? I'm not very familiarized with lambda functions: http://pastebin.com/tVWsaTrR
14:11:11 <unkanon> it was harder than using monads :P
14:11:15 <djahandarie> I just mean exposing functions like bindIO
14:11:29 <djahandarie> Maybe with some easier to understand name
14:11:30 <jmcarthur> d-snp: :(
14:11:40 <c_wraith> DDave, foldl takes an argument you're not providing...  the value to start with
14:11:42 <unkanon> fuzzy warm thing, that's a good name
14:11:42 <d-snp> no problem jmcarthur :P you tried well ;)
14:11:55 <djahandarie> chrisdone!
14:11:59 <jmcarthur> d-snp: can you identify what you found confusing?
14:12:00 <djahandarie> Where ya been
14:12:00 <byorgey> @type foldl
14:12:02 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:12:02 <d-snp> the thing you tried to explain is what I really want to get..
14:12:11 <d-snp> what the difference between evaluating and executing is I guess
14:12:11 <Zao> @type foldl1
14:12:12 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
14:12:17 <chrisdone> has anyone done any web / app extension with haskell? I think that could be quite nice
14:12:17 <lambdabot> chrisdone: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:12:40 <jmcarthur> d-snp: my intent was just to show that IO actions are just data and they are not interpreted by evaluation
14:12:41 <djahandarie> Web / app extension?
14:13:06 <djahandarie> (The word recipe is often used)
14:13:08 <chrisdone> I'm thinking that I could allow custom tutorials on tryhaskell.org with tutorials written in Haskell that actually get compiled an run
14:13:27 <unkanon> d-snp: evaluation is what the haskell interpreter does to reduce expressions; execution is what the runtime does to run the program (I think?)
14:13:30 <jmcarthur> d-snp: evaluation in haskell has no observable effects. for example, (1+2)+3  and  3+3  mean the same thing
14:13:33 <DDave> c_wraith, I added the value to start with: foldl (\_ n -> n+1) 0 li but its still not working..apparently a is a rigid type variable
14:14:06 <c_wraith> DDave, need more of the context than your previous snippet supplies to tell you where that's coming form
14:14:08 <c_wraith> err, *from
14:14:13 <Botje> DDave: you want foldl (\n _ -> n + 1) 0 li
14:14:22 <c_wraith> Oh, Botje is right
14:14:25 <chrisdone> e.g. in the Tutorial monad, which could be continuation-based and let you write:
14:14:26 <chrisdone> do say "hi, enter a list"
14:14:26 <chrisdone>    line <- getLine
14:14:26 <chrisdone>    ...
14:14:27 <Botje> or foldr (\_ n -> n+1) 0 li :)
14:14:29 <chrisdone> but really this is actually sending responses to and from the browser via ajax
14:14:33 <byorgey> DDave: notice the first argument of foldl is of type (a -> b -> a), that is, it should take the accumulator value and the next element of the list ,and produce a new accumulator value
14:14:38 <dancor> maybe Monad should have been Chainable
14:14:41 <DDave> Botje, that just solved my problem.. however I am now totally lost
14:14:49 <Botje> DDave: why? :)
14:15:00 <djahandarie> dancor, except it means more than that
14:15:12 <DDave> Im sure im missing something, but why do I have to change the parameter order in the lambda function?
14:15:15 <dancor> djahandarie: what else
14:15:26 <djahandarie> dancor, the monad laws
14:15:32 <DDave> I think I need to study that chapter again.. byorgey thanks for the explanation
14:15:41 <Botje> DDave: look at the types of foldl and foldr
14:15:45 <Botje> @type foldl
14:15:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:15:48 <Botje> @type foldr
14:15:49 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:15:54 <chrisdone> dancor: what does "chainable" mean?
14:15:55 <djahandarie> I don't get (m >>= f) >>= g == m >>= (\x -> f x >>= g) from the word "Chainable"
14:16:30 * hackagebot archiver 0.2 - Archive supplied URLs in WebCite & Internet Archive  http://hackage.haskell.org/package/archiver-0.2 (GwernBranwen)
14:16:36 <Botje> in foldl, the first parameter a is your accumulator and the second is an element from the list
14:16:51 * dancor has never come across a chain of non-associative links :)
14:16:52 <DDave> the element is b right?
14:16:54 <Botje> whereas foldr has the list element on the first and accumulator on second element
14:17:52 <DDave> oh.. okay
14:18:04 <DDave> Now im starting to understand it, thanks a lot for your help
14:18:29 <dons> hey all. big news...
14:18:41 <Botje> DDave: cool! have fun :)
14:18:45 <Botje> dons: you got your phd?
14:18:49 <DDave> Botje, thank you :)
14:18:49 <dons> http://www.reddit.com/r/programming/comments/ee4vq/galois_releases_the_haskell_lightweight_virtual/ 
14:18:56 <dons> Botje: already did that.
14:18:59 <Botje> ah.
14:19:07 <dons> no, this is bigger. haskell on bare metal is released!
14:19:08 <Botje> my second guess was going to be "RWH: the movie"
14:19:15 <Eduard_Munteanu> Oh boy, so many different versions of the same functions... a map in Prelude, a mapM in Control.Monad, a mapM in Data.Traversable...
14:19:20 <djahandarie> dons, nice!
14:19:46 <Zao> Eduard_Munteanu: Be happy you have a decent base at all. I'm coding against Standard ML and its basis.
14:19:55 <ion> dons: Interesting
14:19:57 <pkrumins> serious business
14:20:01 <Eduard_Munteanu> Ah, never tried ML.
14:20:12 <Eduard_Munteanu> But I guess this mess needs to be sorted out at some point.
14:20:31 <djahandarie> dons, who was behind this?
14:20:35 <dons> djahandarie: galois.
14:20:36 <Zao> Who ever needed Sets or Maps anyway? :D
14:20:37 <Botje> dons: okay, that's coold :)
14:20:42 <Botje> -d
14:20:43 <dons> we've been using it internally for a few years now
14:20:44 <djahandarie> dons, yes, more specifically I mean of course ;)
14:20:47 <dons> so finally it goes live
14:20:49 <pkrumins> dons: you own the galois, right?
14:20:51 <dons> adam wick is the project lead.
14:20:56 <dons> pkrumins: hmm. no. i'm an employee
14:21:05 <pkrumins> ah
14:21:10 <revenantphx> So, I'm curious to try this... how does one go about writing a parser in haskell for a network stream?
14:21:11 <pkrumins> thought you were the owner.
14:21:33 <revenantphx> Which would do something like call a function with the packet as the parameter.
14:21:52 <revenantphx> It'd be forked running continuously I assume.
14:21:59 <revenantphx> Binary protocol btw.
14:22:50 <Zao> I wonder whether FreeBSD has decent Xen, heh.
14:23:00 <thoughtpolice> whoa
14:23:02 <thoughtpolice> HalVM released!
14:23:14 <thoughtpolice> only like, 3 years after I originally heard about it being released ;)
14:23:15 <Twey> Eduard_Munteanu: map and mapM are not the same function
14:23:48 <Twey> Eduard_Munteanu: fmap and map and liftM are the same function, and mapM in Monad and Traversable are the same function
14:24:12 <chrisdone> The state of the art in debugging HaLVMs is unfortunately "printf debugging". <Sheepishly looks at feet.>
14:24:12 <chrisdone> haha
14:24:21 <djahandarie> fmap and map and liftM are only the same function on lists of course
14:24:29 <Eduard_Munteanu> Twey: arguably mapM works for lists.
14:24:34 <opqdonut> fmap and liftM should be the same, right?
14:24:43 <revenantphx> So ah, anything about binary network protocols?
14:24:45 <opqdonut> for a well-behaved Monad instance
14:24:55 <djahandarie> Right
14:24:56 <Eduard_Munteanu> Since lists are monads.
14:25:04 <magicman> :t mapM
14:25:05 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:25:15 <opqdonut> revenantphx: there are libraries for parsing binary data
14:25:19 <opqdonut> and creating
14:25:25 <opqdonut> for example Data.Binary might be relevant
14:25:28 <Twey> Eduard_Munteanu: Mmm, don't think it's the same thing
14:25:30 <Twey> :t mapM
14:25:31 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
14:25:32 <chrisdone> dons: that is pretty damn cool. what are you doing with it at galois?
14:25:46 <Twey> Eduard_Munteanu: It works on lists of lists.
14:25:49 <revenantphx> opqdonut: that's for handling data itself.
14:25:54 <revenantphx> I'm wondering about protocol/parser stuff.
14:25:59 <magicman> > (mapM (\x -> [x,x]) [1,2,3], map (\x -> [x,x]) [1,2,3])
14:26:00 <lambdabot>   ([[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]],[[1,1],[...
14:26:00 <Eduard_Munteanu> Hm, that's a point.
14:26:03 <Twey> But largely coincidentally.
14:26:06 <revenantphx> I saw these, 
14:26:14 <revenantphx> @hackage attoparsec
14:26:14 <lambdabot> http://hackage.haskell.org/package/attoparsec
14:26:15 <revenantphx> @hackage binary-protocol
14:26:15 <lambdabot> http://hackage.haskell.org/package/binary-protocol
14:26:16 <magicman> Different result, still.
14:26:32 <opqdonut> seems you know more than me, sorry :)
14:26:51 <dons> chrisdone: OS rapid prototyping
14:27:04 <magicman> of course, mapM f l == sequence (map f l), and sequence for [] is not the identity;.
14:27:05 <unkanon> what does galois do other than release awesome stuff?
14:27:07 <magicman> -;
14:27:09 <Eduard_Munteanu> Also Data.Traversable doesn't seem to have a mapM_. I suppose I'll do mapM_ ... >> return ()
14:27:14 <dons> unkanon: just be awesome.
14:27:30 <unkanon> dons: wow, that's my dream job then :)
14:28:49 <unkanon> dons: but really, is it a research company or something? (I should be looking that up, I know)
14:29:37 <dons> computer science R&D, for re.
14:29:39 <dons> hire.
14:29:49 <unkanon> gotcha. cool stuff.
14:30:07 <blubsala> is it possible, that there are more than one instances of a monad for a type, like there are more than one possible instances for a monoid for a type ( like * and + for integers)
14:30:52 <arcatan> sure, but they have to be wrapped, similarly to Sum and Product monoids
14:30:54 <Twey> blubsala: Yes
14:31:07 <Twey> blubsala: Theoretically
14:31:21 <Twey> blubsala: I don't know of any data-type with more than one sensible monad instance
14:32:02 <copumpkin> galois.com is so down that even downforeveryoneorjustme.com crashes trying to tell me if it's down or not
14:32:08 <pastorn> ok, so i have a handle
14:32:18 <pastorn> and i want to do safe reading/writing to it
14:32:25 <pastorn> so i'm putting it in a TMVar
14:32:34 <copumpkin> dons: are people aware?
14:32:44 <arcatan> Twey: well, Either has two sensible instances :)
14:32:54 <kmc> [] has more than one Applicative instance
14:32:58 <Twey> arcatan: Does it?
14:33:02 <blubsala> so i have to learn for every new data type which is a monad how it "works"
14:33:07 <pastorn> thinking i'll grab the handle from the TMVar whenever i want to do something, but then the problem i have is that i'll have this:
14:33:15 <unkanon> blubsala: yes.
14:33:33 <arcatan> Twey, the left- and right-leaning ones?
14:33:33 <kmc> pastorn, sounds ripe for contention-based livelock, since IO can take a relatively long time
14:33:46 <kmc> maybe TMVar doesn't have this problem the way TVar does?
14:33:53 <Twey> arcatan: I don't think you can write the left-
14:34:23 <pastorn> do { h <- atomically (readTMVar hVar); l <- hReadLine h; atomically (putTMVar hVar h) }
14:34:35 <kmc> is that the only place you use that var?
14:34:54 <kmc> why use STM?
14:35:04 <arcatan> Twey: why so?
14:35:14 <pastorn> kmc: to protect my Handle
14:35:16 <Twey> arcatan: Try itâ€¦
14:35:29 <kmc> pastorn, wouldn't ordinary MVar work the same way?
14:35:30 <Twey> Monad requires kind * -> *
14:35:35 <unkanon> dons: btw congrats on/thanks for a wonderful book.
14:35:48 <kmc> you probably should use "withMVar" rather than read + put
14:35:54 <kmc> also read doesn't take, does it?
14:35:58 <unkanon> dons: I'll be buying the paperback soon
14:36:16 <pastorn> kmc: well, i guess my problem is that hReadLine is blocking
14:36:25 <pastorn> hmm... wait
14:36:29 <pastorn> i think i have it
14:36:32 <kmc> for thread-safe output, i would just close the handle into one thread, and send it messages through a Chan.  the plumbing is a bit harder for input, but tractable
14:36:37 <d-snp> is there somehere I could easily read the source of how IO works? or perhaps an article about how it works internally?
14:36:56 <kmc> Chan (String -> IO ()) or even (String -> IO ()) -> IO ()
14:36:56 <revenantphx> I'm confused.
14:36:56 <revenantphx> http://hackage.haskell.org/packages/archive/binary-protocol/1.0/doc/html/Control-Monad-BinaryProtocol.html
14:37:04 <revenantphx> How is this handling the possibility that the data ISN'T THERE
14:37:15 <pastorn> kmc: is there no risk of having a context switch while doing input to a thread doing output?
14:37:17 <kmc> d-snp, the way IO works is not part of the Haskell language
14:37:17 <arcatan> Twey: hmm, you're right
14:37:35 <kmc> d-snp, it's implemented differently in each Haskell implementation
14:37:40 <kmc> you could read the source to GHC.IO
14:37:42 <pastorn> kmc: i was thinking initialize :: Handle -> IO (ByteString -> IO (), IO ByteString)
14:37:45 <d-snp> hmm
14:38:01 <kmc> GHC's strategy is to provide impure (side-effecting) functions as primitives, and then wrap them into monadic actions (carefully) and expose that
14:38:12 <kmc> pastorn, ah, so you want a read/write pair
14:38:16 <pastorn> yes
14:38:19 <kmc> this makes more sense then
14:38:35 <kmc> does using STM give you different behavior wrt blocking IO?
14:38:42 <d-snp> kmc: is there an implementation that does it radically different?
14:38:53 <d-snp> btw thanks for the links you gave me :)
14:38:54 <chrisdone> dons: you're writing actual operating systems in Haskell?
14:38:59 <kmc> d-snp, i'm not aware of one, but it's possible
14:39:03 <unkanon> is there a non-GHC implementation of haskell, even?
14:39:07 <pastorn> well, i don't want to enter a blocking read operation if i don't have something to rea
14:39:11 <unkanon> complete, I mean.
14:39:15 <Cale> unkanon: a few
14:39:22 <Cale> Depending on what you call Haskell
14:39:25 <unkanon> Cale: can you throw some names?
14:39:29 <kmc> d-snp, you could implement it like this: http://hpaste.org/41968/gadt_io
14:39:47 <unkanon> I call what ghc let's me write "haskell" :)
14:39:47 <Cale> Hugs, yhc, (is jhc complete yet?)
14:39:49 <kmc> and then the RTS has a separate (non-Haskell) component which pattern-matches those structures and executes IO
14:40:07 <kmc> i don't know how JHC handles IO, but it is complete at least for small programs
14:40:15 <Eduard_Munteanu> Great, ByteString isn't Traversable, now what...
14:40:22 <kmc> its approach of whole-program-compilation is not so scalable though
14:40:47 <kmc> Hugs being an interpreter, I would guess does something more direct than GHC's impure function + wrapper solution
14:40:49 <kmc> but i don't know
14:41:25 <kmc> of note, GHC's approach means that unsafePerformIO is an ordinary function you can write by importing some GHC internals
14:41:33 <kmc> the GADT approach or similar would require it to be an additional primitive
14:41:53 <chrisdone> djahandarie: I added SQL to hpaste
14:42:09 <djahandarie> chrisdone, sweet, thanks :D
14:42:11 <tg_> #: galios.com is down for anyone?
14:42:16 <tg_> I get a timeout
14:42:20 <djahandarie> tg_, down for copumpkin!
14:42:23 <unkanon> tg_: yes, everyone
14:42:28 <tg_> ok.
14:42:37 <tg_> i wanted to read about HaLVM, but alas not now
14:42:38 <chrisdone> tg_: seems to be hanging for me
14:42:54 <chrisdone> tg_: don't worry, here's a link to the wiki: http://halvm.org/wiki/wiki/SupportedSystems
14:43:01 <unkanon> tg_: http://halvm.org/wiki/
14:43:15 <tg_> slow, but not timing out. thanks.
14:44:09 <chrisdone> NEW HASKELL.ORG!
14:44:10 <chrisdone> http://haskell.org/haskellwiki/Haskell
14:44:11 <Eduard_Munteanu> Could somebody explain why ByteString's unpack is allegedly O(n)?
14:44:18 <chrisdone> dons: wooo!
14:44:33 <dons> mirror, http://corp.galois.com/blog/2010/11/30/galois-releases-the-haskell-lightweight-virtual-machine-halv.html 
14:44:34 <tg_> chrisdone: why does that site connect to galios.com?
14:44:42 <c_wraith> Eduard_Munteanu, it creates a cons cell for each byte.
14:44:44 <tg_> i keep reversing i and o
14:44:59 <tg_> chrisdone: but that site is also hanging on galois.com...
14:45:25 <tg_> <p><b>Recent Package Updates</b> <a href="http://haskell.org/haskellwiki/Hackage_statistics" class="external text" title="http://haskell.org/haskellwiki/Hackage_statistics" rel="nofollow"><img src="http://galois.com/~dons/images/hackage-daily.png" 
14:45:28 <tg_> that's where
14:45:29 <chrisdone> tg_: it has some links and feeds  here and there
14:45:31 <chrisdone> yeah
14:46:09 <Eduard_Munteanu> c_wraith: ok, but could that be subject to fusion? I'm trying to determine whether unpack hurts performance.
14:46:28 <pastorn> ah
14:46:30 <pastorn> hWaitForInput
14:46:35 <elliott> halvm: omg yes
14:46:40 <pastorn> kmc: ^^^^
14:46:52 <thoughtpolice> elliott: i know, right? been waiting for years :)
14:47:05 <thoughtpolice> and just the other day I was looking at mirage - ocaml on xen - and wondering "why don't we have that?!"
14:47:17 <Eduard_Munteanu> c_wraith: or IOW, if I find a way to do what 
14:47:20 <elliott> hmm what's it written in, C?
14:47:25 <revenantphx> So does anyone in here know anything about Control.Monad.BinaryProtocol
14:47:32 <kmc> new haskell.org, nice
14:47:33 <Eduard_Munteanu> ... what I want without unpack, should I attempt to?
14:47:36 <kmc> looks like a real language now :D
14:47:54 <thoughtpolice> kmc: it finally went live?
14:48:00 <elliott> i like the new homepage
14:48:03 <elliott> well-organised
14:48:03 * thoughtpolice checks
14:48:08 <c_wraith> Eduard_Munteanu, with or without fusion, if you need to touch all the bytes, the overall algorithm is going to be O(n).  fusion is just a constant-factor improvement
14:48:09 <thoughtpolice> yep, sure did.
14:48:24 <thoughtpolice> GHC 7, halvm, new haskell.org design. now we need the new hackage 2 server and hackage redesign to hit
14:48:38 <unkanon> and a package manager
14:48:47 <unkanon> (I'm just echoing what everybody says really)
14:48:51 <elliott> um, cabal?
14:49:08 <unkanon> elliott: I see many people complaning about cabal
14:49:10 <geheimdienst> cue ivanm with his blog post "repeat after me: cabal is not a package manager" ...
14:49:18 <dcoutts_> yet :-)
14:49:24 <chrisdone> nice, the web development section looks real nice now: http://haskell.org/haskellwiki/Web/Frameworks
14:49:33 <Eduard_Munteanu> And now somebody says something about Nix...
14:49:40 <elliott> I heard Nix is written in pure functions
14:49:47 <elliott> and packages only fresh kitten babies
14:49:47 <dcoutts_> Nix has good Cabal support :-)
14:49:51 <mee> rss.png seems to have run off with the old homepage
14:49:53 <unkanon> what's nix?
14:50:02 <arcatan> a package manager
14:50:10 <elliott> chrisdone: that's misleading! The clean design makes people think web development of any kind is going to be smooth and nice.
14:50:10 <Eduard_Munteanu> a distribution
14:50:13 <unkanon> a proper one?
14:50:16 <elliott> no, that's NixOS
14:50:18 <elliott> Nix is the package manager
14:50:32 <elliott> unkanon: it's purely functional and immutable and stuff. also with NixOS it handles configuration too.
14:50:41 <elliott> http://nixos.org/
14:50:47 <unkanon> I heard about nixos but never about nix
14:50:58 <sipa1024> yet written in c++
14:50:59 <elliott> nix is the package manager nixos is based on :P
14:51:02 <elliott> sipa1024: it is?
14:51:12 <sipa1024> i think so
14:51:16 <Eduard_Munteanu> Purely functional.
14:51:17 <unkanon> oh wow
14:51:40 <medfly> GIANT AD LOOK
14:51:57 <arcatan> GIANT AARDVARK
14:51:58 <chrisdone> elliott: haha. smooth like a baby hedgehog's back
14:52:17 <elliott> hedgehogs are misleading, they look cute and fuzzy
14:52:20 <elliott> and cuddly
14:52:21 <elliott> NOT SO
14:52:26 <elliott> wow, nix is really written in C++
14:52:33 <elliott> now why is that...
14:52:34 <Eduard_Munteanu> c_wraith: is there any reason why I should avoid unpack? There seems to be a warning about pack
14:53:10 <medfly> why not
14:53:14 <c_wraith> Eduard_Munteanu, use it if you need it.  *shrug*
14:53:18 <unkanon> why not C is the question
14:53:30 <unkanon> why use the horrible ++ they added to little old C
14:53:47 <Eduard_Munteanu> I assume I could go through the whole file (what I actually want) without 'unpack'
14:54:05 <Eduard_Munteanu> But I'm trying to figure out the bottleneck here.
14:54:05 <elliott> more like, why not haskell
14:54:10 <dcoutts_> elliott: simply the preference of the original author
14:54:19 <elliott> dcoutts_: but it's so much like Haskell itself :)
14:54:22 <unkanon> elliott: well yes
14:54:29 <dcoutts_> elliott: most of the other contributors are haskell people, but the original author is not really
14:54:43 <elliott> strange, i'd have expected them to be a fan
14:54:47 <kadoban> is there a function that will round a Double to x decimal places? (for printing)
14:54:53 <dcoutts_> elliott: this is probably also why it does not use static typing
14:55:06 <elliott> dcoutts_: what, statically-typed packages?
14:55:06 <dcoutts_> kadoban: see the Numeric module
14:55:11 <kadoban> ty
14:55:12 <elliott> dcoutts_: or the Nix language itself :P
14:55:17 <unkanon> elliott: there's a task for ya: rewrite nix(os) in haskell
14:55:23 <elliott> unkanon: so tempted to!
14:55:23 <dcoutts_> elliott: the nix language (and thus the package descriptions)
14:55:41 <elliott> but i already have my own linux distribution project with its own package manager, I don't have time for *two* :P
14:55:42 <chrisdone> > printf "%.2f\n" pi
14:55:43 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:55:43 <lambdabot>    `Text.Printf.PrintfType ...
14:55:57 <chrisdone> > printf "%.2f\n" 3.141592654
14:55:57 <dcoutts_> elliott: no, don't do that, lets put nix-style package handling into cabal :-)
14:55:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:55:58 <lambdabot>    `Text.Printf.PrintfType ...
14:56:04 <chrisdone> > printf "%.2f\n" (3.141592654::Double) -- ?
14:56:05 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:56:05 <lambdabot>    `GHC.Show.Show a'
14:56:05 <lambdabot>      a...
14:56:10 <chrisdone> oh, forget it
14:56:15 <elliott> dcoutts_: eagerly awaiting HsCoreUtils v1
14:56:17 <elliott> (please nobody do this)
14:56:43 <unkanon> :t printf
14:56:44 <lambdabot> forall r. (PrintfType r) => String -> r
14:56:56 <chrisdone> kadoban: printf can do this for printing, but lambdabot is stupid so I can't easily exhibit its behaviour
14:57:07 <chrisdone> http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Text-Printf.html#v%3Aprintf
14:57:12 <unkanon> > show $ printf "%.2f" 3.14159265
14:57:13 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:57:13 <lambdabot>    `GHC.Show.Show a'
14:57:13 <lambdabot>      a...
14:57:32 <kadoban> ah, i get you.  thanks
14:57:48 <unkanon> I don't understand how printf only takes one parameter...
14:58:14 <chrisdone> unkanon: it's polymorphic so that it can take many, it's quite clever
14:58:30 <chrisdone> see the instance: (PrintfArg a, HPrintfType r) => HPrintfType (a -> r)
14:58:38 <Twey> > printf "%.2f" 6.28318530 -- http://tauday.com/ :Ã¾
14:58:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:58:39 <lambdabot>    `Text.Printf.PrintfType ...
14:58:43 <chrisdone> well, (PrintfArg a, PrintfType r) => PrintfType (a -> r)
14:59:25 <unkanon> chrisdone: yeah I still have to read about variadic functions in haskell
14:59:29 <chrisdone> unkanon: see that this can essentially go on forever because `r` itself is an instance of PrintfType
14:59:50 <unkanon> > show $ printf "%.2f" (3.14159265 :: Double)
14:59:51 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:59:51 <lambdabot>    `Text.Printf.PrintfType ...
15:00:02 <unkanon> > printf "%.2f" (3.14159265 :: Double)
15:00:03 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:00:03 <lambdabot>    `GHC.Show.Show a'
15:00:03 <lambdabot>      a...
15:00:03 <chrisdone> first one to figure out how to get printf to work gets a prize!
15:00:20 <chrisdone> > (printf "%.2f" (3.14159265 :: Double)) :: String
15:00:21 <lambdabot>   "3.14"
15:00:22 <unkanon> chrisdone: I can see a glimpse of how it works, yeah :)
15:00:22 <c_wraith> any unfold experts around?  I keep running into this problem trying to use unfoldr:
15:00:24 <c_wraith> > let collatz = unfoldr (\x -> case x of { 1 -> Nothing ; _ | even x -> Just (x, x `div` 2) ; _ -> Just (x, x * 3 + 1) }) in collatz 23
15:00:25 <chrisdone> yaaay
15:00:25 <lambdabot>   [23,70,35,106,53,160,80,40,20,10,5,16,8,4,2]
15:00:26 <chrisdone> I win!
15:00:35 <unkanon> congratz!
15:00:46 <chrisdone> @vixen what prize do I get?
15:00:47 <lambdabot> let's don't talk about that
15:00:55 <chrisdone> D:<
15:01:04 <c_wraith> The problem is basically, "I want to output an element at the same time I detect termination"
15:01:04 <romildo> Is there a function in the standard library to combine two predicates with the conectives OR or AND? Something like "(==1) `orP` (==3)".
15:01:37 <c_wraith> romildo, no, but you could do it quickly with liftM2 (||)
15:01:44 <c_wraith> :t liftM2 (||)
15:01:46 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
15:02:02 <c_wraith> in the function monad :)
15:02:22 <ion> I expect it to return a function of the correct type and arity based on the format parameter. Iâ€™ll have to take a look at the definition of PrintfType to see how the typing works out, since the type of the function varies based on the format string.
15:02:53 <romildo> c_wraith, thanks. I was not aware that a function is monad.
15:03:07 <c_wraith> ion: types need to be known at compile-time in haskell, so that only works if you're working in TH.  and there are, indeed, TH versions of printf
15:03:12 <unkanon> does printf really need to be that complicated? couldn't it just take a list as it's second parameter? I always wondered that ever since I learned C
15:03:18 <chrisdone> ion: of course, it varies only in how you specify it, you will still get runtime errors if your string is wrong
15:03:57 <Cale> ion: It's sort of weakly-typed
15:03:57 <unkanon> no need to be variadic I think
15:03:58 <chrisdone> unkanon: with a list you'd need an existential constructor or worse
15:03:58 <c_wraith> :t liftM2 (||) :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)
15:03:59 <lambdabot> forall a. (a -> Bool) -> (a -> Bool) -> a -> Bool
15:03:59 <Twey> unkanon: The arguments are heterogeneous
15:03:59 <chrisdone> [Number 1,String "a"] or [Existential 1,Existantial "a"]
15:04:01 <unkanon> chrisdone: oh for the different types, right?
15:04:06 <chrisdone> right
15:04:07 <unkanon> Twey: right right..
15:04:13 <unkanon> okay pretend I never said that
15:04:16 <Cale> (Of course, not really, but it doesn't statically parse the format string.)
15:04:35 <chrisdone> > (printf "%s" (3.14159265 :: Double)) :: String
15:04:35 <lambdabot>   "*Exception: Printf.printf: bad argument
15:04:43 <unkanon> brb
15:04:49 <chrisdone> not the most descriptive of errors
15:05:28 <chrisdone> @yow
15:05:28 <lambdabot> Couldn't find fortune file
15:05:38 <chrisdone> "bad file"
15:05:58 <Twey> Very insightful
15:07:40 <chrisdone> Cale: are you using ghc 7?
15:08:58 <dixie> hmm, I'm curious. The ghc --make -threaded requires the /par/ antotation or does the some optimization for mutli-threading run by default? It seems that my problem can make busy two cores without that `par`
15:09:12 <dixie> problem=program
15:09:45 <chrisdone> dixie: what is your program doing?
15:11:40 <dixie> chrisdone: crawling the webpages using the shpider and collect unique URLs in Data.Set
15:13:28 <chrisdone> IIRC things involving IO can be shifted between OS threads by the scheduler, but I don't have a link about it
15:13:51 <benmachine> there's a parallel GC
15:14:37 <chrisdone> benmachine: does it run in parallel for linear jobs?
15:14:48 <chrisdone> or single-threaded programs?
15:14:53 <thoughtpolice> if you build with -threaded, then the RTS can re-schedule blocking IO actions onto different OS threads
15:15:00 <benmachine> chrisdone: iono
15:15:11 <thoughtpolice> i.e. so one forkIO thread that blocks doesn't block all GHC threads on that OS threads
15:22:58 <abstractstone> Is anyone high up on the haskell wikibook?
15:23:44 <abstractstone> There is 1 pending change awaiting review
15:24:47 <elliott> so when's -XDependentTypes coming :)
15:25:09 <copumpkin> elliott: never, probably :)
15:25:25 <elliott> copumpkin: stop lying! my dreams will come true one day!
15:25:39 <copumpkin> elliott: have you programmed with dependent types? they're not all fun and games :)
15:25:39 <c_wraith> I really want an unfold variant that lets you specify "output this result, then stop"
15:25:54 <elliott> copumpkin: yes, I have, and I know they're 99% pain :)
15:26:07 <elliott> copumpkin: Something like Ur's half-way approach seems excellent for everything but theorem provers. Have you seen it?
15:26:14 <copumpkin> yeah
15:26:20 <thoughtpolice> i wonder when (if?) byorgey's GHC changes that 'collapse' type and value level functions like she does will hit
15:26:30 <thoughtpolice> i think those proposed changes hit a pretty good sweet spot
15:26:40 <copumpkin> thoughtpolice: by highlighting him, you may find out, stand by!
15:26:46 <thoughtpolice> i know, right :)
15:26:57 <elliott> thoughtpolice: I did factorial in the type system once.
15:27:04 <thoughtpolice> let's hope it's soon. full blown dependent types are a little much. ur is a pretty good compromise
15:27:06 <elliott> Here -- http://ehird.blogspot.com/2010/01/computing-fib3-in-haskells-type-system.html
15:27:16 <djahandarie> I've been bugging byorgey for source for months now!
15:27:19 * djahandarie bugs byorgey more
15:27:21 <elliott> IIRC I broke my Show instance somehow while writing that post...
15:27:27 <elliott> But it still works, you just can't see it working :)
15:27:36 <elliott> Oh, fib too, it seems.
15:27:48 <thoughtpolice> i think one biproduct of ur's approach is that some well-typed programs that are 'too polymorphic' will fail to compile, but that's not exactly a deal-breaker
15:27:57 <copumpkin> elliott: now write ackermann :)
15:27:59 <thoughtpolice> it would really be nice to see a language like Ur, only adapted to some different domain
15:28:08 <elliott> copumpkin: hmm, is that actually forbidden?
15:28:13 <elliott> I don't recall type families very well :)
15:28:31 <elliott> thoughtpolice: Ur is "meant" to be general, and Ur/Web be only one expression of it, it seems
15:28:39 <elliott> but I doubt other Ur languages will appear any time soon
15:28:51 <thoughtpolice> yes, i think that's the idea, except Ur/Web seems pretty ingrained into the compiler, runtime and everything :)
15:28:53 <Ziphilt> how does one combine pattern matching and guards? i know there are ways, but i have not seen enough examples
15:29:13 <thoughtpolice> elliott: so yeah it'll probably be a while
15:29:20 <elliott> Ziphilt: each pattern match gets its own set of guards, the end
15:29:30 <elliott> thoughtpolice: yeah :/
15:29:38 <elliott> Ziphilt: well, those are the facts of it; actually using it left as an exercise to the reader :)
15:30:03 <Ziphilt> i want to know how to do it withot getting a syntax error
15:30:09 <Ziphilt> *without
15:30:25 <elliott> thoughtpolice: still, the approach is more encouraging than Coq, which isn't useful for writing full programs at all
15:30:38 <elliott> thoughtpolice: (neither is Agda, but it isn't any good at proving theorems either ;-))
15:30:51 <Ziphilt> >rule c:ns
15:30:51 <Ziphilt> >  |
15:30:51 <Ziphilt> doesn't work; what does?
15:30:52 <lambdabot>   <no location info>: parse error on input `|'
15:31:08 <elliott> Ziphilt: that should be (c:ns)
15:31:13 <Ziphilt> okay
15:31:30 <thoughtpolice> yeah, Coq is rather hard to write actual programs in, although it has lots of libraries of proofs and whatnot. agda on the other hand is more haskellish, but the proof burdens seem a hell of a lot higher
15:31:43 <Ziphilt> that works then; thanks
15:31:55 <thoughtpolice> there are people out there I'm sure who think that haskell should eventually just become a lazy version of Coq, but I'd rather steal good ideas from dependent types, rather than go all the way there
15:32:29 <thoughtpolice> things like the collapsing of type-functions and value-functions (and datatypes) are one good step there
15:32:36 <elliott> thoughtpolice: well Agda is about as hard as Coq to apply to programs, and proving things in it requires godly expertise :)
15:32:42 <elliott> since it's without any hand-holding at all
15:32:47 <thoughtpolice> yeah
15:32:54 <elliott> also IIRC agda's system has been proven inconsistent quite a few times and it's bit of a hodge-podge
15:33:01 <elliott> whereas if you're proving things you want something like coq's small core calculus
15:33:15 <elliott> (agda is, however, an interesting and important research project)
15:33:19 <elliott> (just not something i'd _use_)
15:33:54 <thoughtpolice> yeah, coq's core calculus is insanely simple, which is kind of the idea so you can have a hand-verified implementation of the core, and then everything else is built on those sound foundations (like normal math)
15:34:26 <thoughtpolice> in terms of theorem provers, HOL Light also has an amazingly small and easy to understand core
15:34:55 <elliott> thoughtpolice: ever tried printing a large factorial in Coq using nat?
15:34:56 <elliott> not fun :)
15:35:03 <elliott> it sorta breaks down with actual numbers ;-)
15:35:08 <thoughtpolice> heh
15:35:25 <djahandarie> People run their dependently-typed programs now?
15:35:40 <elliott> djahandarie: Heck no! I just meant printing it in Proof General :-)
15:36:18 <thoughtpolice> i will say numbers are just ugly with idris, coq, whatever you're using. i realize they're inductively defined peano naturals, but damn, after 3 levels of 'nat' it gets pretty ugly fast
15:36:48 <copumpkin> use glguy and my binary number implementation in agda :)
15:36:54 <copumpkin> we have loads of fun proofs about them
15:36:58 <Ziphilt> i am trying to make my Gol simulator look nice, and a square font would be just excellent. google search gets me not what i mean. nothing in Ubuntu repo. i know Dwarf Fortress does that, but those are images. anyone know of a square font?
15:37:26 <djahandarie> copumpkin, there was something like type-level binary numbers in Haskell too right?
15:37:36 <elliott> Ziphilt: have you considered drawing pixels? :-)
15:37:41 <copumpkin> djahandarie: probably, but that's different
15:37:57 <elliott> copumpkin: yeah but then you have to use agda! :0
15:37:58 <Ziphilt> so far i want to only deal with the terminal
15:37:58 <elliott> *:)
15:38:09 <copumpkin> https://github.com/pumpkin/bitvector/blob/master/Data/BitVector.agda
15:38:13 <elliott> so you might have working naturals but good luck using them in a proof :P
15:38:17 <abstractstone> Anyone know anything about Epigram?
15:38:30 <elliott> abstractstone: I know a bit
15:38:35 <Ziphilt> but i could mess around with FontForge and make a really simple one
15:38:36 <elliott> not too much though :)
15:38:38 <unkanon> abstractstone: that it's like cayenne and coq?
15:38:39 <abstractstone> I need example code to get started
15:38:47 <djahandarie> Neat, I can actually read Agda now
15:38:51 <elliott> abstractstone: well Epigram 1 is deprecated and Epigram 2 doesn't have the high-level language written
15:38:54 <elliott> so you can't! :)
15:38:57 <Ziphilt> i think someone wauld have done this already
15:39:01 <Ziphilt> *would
15:39:49 <abstractstone> I'm after some more .pig files than come in /test
15:39:55 <elliott> abstractstone: although it looks like they've got enough of a "language" (proof command line) to do sort: http://www.e-pig.org/epilogue/?p=690
15:40:00 <elliott> abstractstone: well is it epigram 1 or 2?
15:40:05 <abstractstone> 2
15:40:06 <elliott> i don't think anyone even knows epigram 1 any more
15:42:59 <abstractstone> couldn't get this completed http://proggit.pastebin.com/VDBPQhVs
15:43:18 <elliott> abstractstone: as I said, it's in the proof checker, not .pig
15:43:24 <elliott> Cochon
15:52:29 <jmcarthur> does anybody know of a good way to generate random values of a GADT, e.g. with Arbitrary?
15:52:38 <jmcarthur> a general technique or anything
15:52:40 <elliott> jmcarthur: oh my :)
15:54:27 <pastorn> aoue
15:54:29 <jmcarthur> in particular, i'm using a GADT to encode a simple HOAS language and would like to be able to generate random, well-typed expressions in that language
15:55:03 <c_wraith> why does the general arbitrary approach not work?
15:55:25 <c_wraith> Just pick a constructor, and generate an arbitrary set of arguments for it.
15:55:41 <jmcarthur> the question is which constructor to pick
15:55:55 <c_wraith> is it dependent on the context?
15:57:57 <jmcarthur> okay, here's the GADT i'm attempting this with: http://hpaste.org/41972/simple_gadt
15:58:48 <jmcarthur> i'm not even 100% sure what instance(s) to write. while it would be awesome if i could write instance Arbitrary a => Arbitrary (Exp a), i'm a little doubtful
15:59:14 <jmcarthur> likely i need to write several instances for whatever concrete types i want to support in the long run (just Bool in this case, but others later)
15:59:16 <c_wraith> Ah, I see.  I think you just might need to turn on Flexible Instancecs
15:59:19 <c_wraith> err, Instances
15:59:33 <c_wraith> But I see the problem now
15:59:35 <jmcarthur> and then it gets even tougher once i start supporting functions in this language
15:59:41 <jmcarthur> how would i do Exp (a -> b)?
16:01:08 <jmcarthur> for example, for the (Exp Bool) instance, a valid constructor is App... now i have to come up with a type for 'a' out of the blue and also generate something with type Exp (a -> Bool)
16:01:50 <jmcarthur> and if i pick a concrete type right there... well, i'm going to have to handle all sorts of silly combinations of types
16:02:44 <jmcarthur> (i'm not actually using Arbitrary in this case, but it serves as good common ground for talking about this i think)
16:05:07 <revenantphx> cabal and hackage are nice to have.
16:05:15 <revenantphx> Makes it way easier to find a piece of code/module to sue.
16:05:39 <unkanon> why are you suing them?  :P
16:06:26 <revenantphx> using*
16:06:40 <revenantphx> So, could I write up my packets as data objects that are instances of Binary?
16:07:13 <revenantphx> (Binary, to me, seems basically to be a typeclass for binary encoding/decoding)
16:10:27 <jmcarthur> huh http://www.galois.com/blog/2010/11/30/galois-releases-the-haskell-lightweight-virtual-machine-halvm/
16:10:30 <revenantphx> http://hackage.haskell.org/packages/archive/acme-dont/1.1/doc/html/Acme-Dont.html
16:10:31 <revenantphx> hahaha.
16:11:17 <aristid> revenantphx: i actually see a use case for that :D
16:11:24 <revenantphx> What? XD
16:11:52 <revenantphx> I love the description on cpan.
16:11:53 <revenantphx> "Note that the code in the don't block must be syntactically valid Perl. This is an important feature: you get the accelerated performance of not actually executing the code, without sacrificing the security of compile-time syntax checking."
16:12:35 <ManateeLazyCat> New version HaskellWiki is awesome, same style as hackage.
16:13:17 <revenantphx> Bookmar bar...
16:13:20 <revenantphx> Unicode'd http://cl.ly/0i2H1n0c052S3r1D2s1s
16:13:34 <revenantphx> ï£¿ is for Objective-C stuff, lambda is for haskell.
16:14:19 <pastorn> http://hpaste.org/41974/aretherebugsinhere ??
16:15:01 <unkanon> revenantphx: that's pretty
16:15:07 <pastorn> could someone who knows a bit about threads & STM have a quick glance... i'm afraid i might be doing something stupid in there
16:15:13 <geheimdienst> revenantphx: j?
16:16:37 <revenantphx> dunno.
16:16:44 <revenantphx> Have you tried running it?
16:17:22 <revenantphx> Oh god. I just saw it.
16:17:23 <revenantphx> TMVar
16:17:26 <revenantphx> It's both isn't it.
16:17:36 <revenantphx> It's an MVar in the STM monad.
16:17:38 <revenantphx> Oh crap.
16:17:43 * revenantphx runs away.
16:18:01 <pastorn> revenantphx: i'm too scared
16:18:22 <revenantphx> tbh, why is it both?
16:18:28 <revenantphx> And what is this supposed to DO?
16:19:13 <pastorn> it should give back two functions, one for putting data on the handle and one for recieving (blocking)
16:19:21 <pastorn> without any conflicts
16:19:35 <pastorn> like one reading while the other is writing, or two writing at the same time
16:19:45 <revenantphx> So... this is socketpipe()
16:19:49 <revenantphx> Basically.
16:19:53 <pastorn> i have no clue
16:19:55 <revenantphx> Oh, you input a handle.
16:19:57 <revenantphx> Nmd.
16:20:15 <revenantphx> Oh I see. Neat :\
16:20:24 <revenantphx> So the TMVar is to prevent both from happening at once?
16:20:37 <pastorn> maybe this is all for naught, maybe the Handle type already does this for me :/
16:20:44 <revenantphx> The question I have to be honest is why are you using STM.
16:20:53 <pastorn> revenantphx: type TMVar a = TVar (Maybe a) -- basically
16:21:11 <revenantphx> I don't see the point, wouldn't an MVar lock be enough?
16:21:26 <revenantphx> take it when you're reading or writing, put it back when you're done, have the other block while waiting.
16:21:38 <pastorn> it probably could, but i'm trying to stick to STM as my only thread-y thing here
16:21:48 <revenantphx> And yet you have MVars (TMVars tho)
16:22:05 <revenantphx> I'm pretty sure your mvar is redundant.
16:22:23 <pastorn> i figured it might be...
16:22:26 <ManateeLazyCat> Haha, Galois releases the Haskell Lightweight Virtual Machine (HaLVM)! Haskell without an OS! 
16:22:29 <revenantphx> I don't know shit though.
16:22:46 <revenantphx> Let me think :\
16:23:02 <jmcarthur> yeah some of my former coworkers are going to be amazed by this (kernel developers)
16:23:11 <revenantphx> What is it? I'm still confused?
16:23:19 <jmcarthur> HaLVM?
16:23:23 <revenantphx> Yes.
16:23:32 <jmcarthur> it's the ghc runtime ported to run on bare xen
16:23:40 <jmcarthur> no real OS
16:23:40 <revenantphx> What is bare xen?
16:23:41 <ManateeLazyCat> revenantphx: I think it's Virtual Machine that written in Haskell .:)
16:23:46 <jmcarthur> xen is a hypervisor
16:23:52 <revenantphx> ManateeLazyCat: And does nothing but haskell XD?
16:24:01 <ManateeLazyCat> revenantphx: I think so.
16:24:05 <revenantphx> ....so its the ghc runtime... and pretty much nothing else.
16:24:12 <revenantphx> A system that is ONLY. HASKELL. EVER.
16:24:16 <revenantphx> :|
16:24:20 <jmcarthur> yeah, it's basically as though it was haskell on raw hardware (aside from xen, of course)
16:24:26 <revenantphx> Neat.
16:24:40 <unkanon> should make it easy to build an OS
16:24:50 <ManateeLazyCat> revenantphx: Yes, i know you mean, a real system should not just run Haskell code, but also run other code through FFI. :)
16:25:00 <revenantphx> Oh god. Soon the haskellers will write their own OS
16:25:13 <hpc> revenantphx: already happened
16:25:17 <revenantphx> 0.o
16:25:21 <hpc> House, iirc
16:25:22 <unkanon> which one?
16:25:26 <ManateeLazyCat> revenantphx: Maybe we can build Manatee on HaLVM . :)
16:25:26 <unkanon> never heard of it
16:25:27 <revenantphx> :|
16:25:36 <revenantphx> It'd be cool to write a server to run on that.
16:25:42 <hpc> http://programatica.cs.pdx.edu/House/
16:25:45 <revenantphx> Save a lot of resources.
16:26:02 <ManateeLazyCat> hpc: House still active? 
16:26:16 <hpc> last modified sep 2009
16:26:21 <unkanon> it looks... ugly :/
16:26:27 <unkanon> but impressive
16:26:47 <unkanon> it even renders comic sans, that's all I really need in an OS
16:26:51 <hpc> it's written in haskell; what do you expect? :P
16:26:55 <ManateeLazyCat> hpc: It's powerful if i can build Manatee on House. :)
16:26:58 <hpc> (that's an image viewer)
16:27:12 <unkanon> it looks like a slide show program
16:27:16 <djahandarie> I think the House team stopped to go build Habit... at least I think it was the same people
16:27:22 <djahandarie> Could be wrong though
16:27:24 <ManateeLazyCat> hpc: Then Haskell core, and Haskell application. :)
16:27:38 <revenantphx> Soon, Haskell will exist as a country.
16:27:46 <revenantphx> A giant floating metal country over the south pacific.
16:27:53 <revenantphx> With NO. MUTABLE. STATE.
16:27:57 <revenantphx> Get it?
16:28:01 <revenantphx> No mutable state?
16:28:06 <revenantphx> As in the government doesn't change XD?
16:28:11 <revenantphx> Yeah that was a bad joke.
16:28:12 <pastorn> @slap revenantphx 
16:28:12 * lambdabot slaps revenantphx
16:28:28 * revenantphx deserves it.
16:28:32 <companion_cube> with lambdabot as governor ?
16:28:42 <companion_cube> @vixen can lambdabot rule the world ?
16:28:42 <lambdabot> i'll hafta plead the fifth on that one.
16:28:54 <revenantphx> @vixen Can you rule the world?
16:28:54 <lambdabot> let me answer that later, okay?
16:29:03 <hpc> lambdabot is the puppet dictator
16:29:07 <revenantphx> No no.
16:29:19 <revenantphx> We'll take the brains of all of the simons and oleg, and connect them to a supercomputer.
16:29:21 <revenantphx> (running haskell)
16:29:28 <revenantphx> Among others.
16:30:45 * ManateeLazyCat Uploading new video without sound track, poor Germany people can't watch viedo include Owl City.
16:31:43 <revenantphx> dd if=/dev/zero of=/owl/city bs=512
16:31:57 <companion_cube> hey, it's a side effect !
16:32:12 <revenantphx> That's not haskell.
16:33:01 <medfly> lol
16:33:55 <revenantphx> bl
16:37:42 <pokoko222> need to talk some computer vision people anyone here?
16:38:08 <pastorn> computer vision? image analysis?
16:38:55 <pokoko222> yep
16:39:00 <pokoko222> have done any?
16:39:12 <pastorn> not me
16:39:47 <pokoko222> i better say image processing, computer vision sounds scary
16:41:00 <unkanon> you should say electronic eyeballs
16:41:07 <unkanon> to be more shocking
16:41:48 <pokoko222> image processing is like the baby steps after some years in it you can go to computer vision indeed
16:42:25 <unkanon> they have squeak running on bare metal as well
16:42:46 <unkanon> which I must say looks a lot nicer out of the box than any other language could do :) (since they have an IDE)
16:42:59 <unkanon> the IDE being part of the language and all that
16:43:06 <pokoko222> troll
16:43:18 <ManateeLazyCat> juhp_: Hey. :)
16:43:32 <Quadrescence> > product [1..10]
16:43:36 <juhp_> ManateeLazyCat: hi
16:43:42 <Quadrescence> Cale: is lambdabot borken
16:43:47 <unkanon> pokoko222: you got here too late. we were talking about haskell running on bare metal
16:43:52 <unkanon> I'm not trolling :)
16:44:15 <pokoko222> ah ok :D
16:44:43 <Cale> Quadrescence: not sure. Looks like the network is having a bit of trouble though.
16:44:48 <unkanon> pokoko222: I wish I could help with the computer vision stuff
16:45:14 <Quadrescence> @botsnack
16:45:19 <Quadrescence> :(
16:45:50 <ManateeLazyCat> juhp_: I just release new version make Manatee core more robust, it won't crash even you use older manatee extension package send invalid DBus message to manatee-core.
16:46:33 <ManateeLazyCat> juhp_: manatee-core will ignore if DBus message is not correct format, but won't crash. :)
16:49:20 <pastorn> Hmm... what can you do from Xen?
16:49:31 <pastorn> like... how do you do graphics?
16:50:07 <unkanon> pastorn: Xen probably gives the guest language an API?
16:52:09 <unkanon> halvm would have to have documentation on how to make the API calls
16:52:17 <unkanon> that's what I'm guessing
16:52:36 <juhp_> ManateeLazyCat: nice!
16:52:46 <juhp_> ManateeLazyCat: any workaround for ghc7 yet? :)
16:53:03 <ManateeLazyCat> juhp_: Looks Igloo still in fixing
16:53:20 <ManateeLazyCat> juhp_: Best waiting next Haskell platform, ghc-7 still have many bugs.
16:53:32 <juhp_> ok
16:53:42 <ManateeLazyCat> juhp_: I'm now working "mix pdynload in Manatee"
16:53:45 <ManateeLazyCat> @package pdynload
16:53:57 <ManateeLazyCat> lambdabot gone
16:54:04 <ManateeLazyCat> juhp_: http://hackage.haskell.org/package/pdynload-0.0.3
16:58:51 <ManateeLazyCat> QinGW: Join ##manatee :)
16:59:16 <kmc> since Xen can run a full unmodified OS, i'd suppose that doing graphics from HaLVM would be like talking to a graphics card directly
16:59:21 <kmc> but it may provide a nice API in addition
16:59:28 <ManateeLazyCat> QinGW: æœ€è¿‘æ€Žä¹ˆæ ·ï¼Ÿ
17:03:05 <unkanon> I need some help with computing the height of a tree, but not too much help please
17:03:13 <unkanon> this is exercise 8 of chapter 3 of RWH
17:03:14 <unkanon> http://hpaste.org/41975/tree_height
17:03:41 <unkanon> that's what I have. what I don't know how to do is how to walk two branches of a tree at the same time
17:03:41 <hpc> unkanon: the height of a node is the larger of the heights below it, plus one
17:03:54 <hpc> do a depth first search
17:04:32 <unkanon> okay that first statement makes a lot of sense
17:05:02 <hpc> http://en.wikipedia.org/wiki/Depth-first_search
17:05:21 * unkanon is reading
17:06:51 <unkanon> hpc: okay I will try and solve it from here. thanks!
17:10:46 <unkanon> hpc: depth-first search looks a lot like the left-hand rule for walking a maze (the algorithm)
17:12:58 <pastorn> unkanon: i think you should be able to create depth just using 1, +, max and depth
17:13:03 <pastorn> (and 0)
17:13:24 <tromp> :t guard
17:13:29 <unkanon> take a look at what I already have at the tree_height link above
17:13:33 <unkanon> pastorn: ^
17:13:43 <unkanon> tromp: lambdabot is offline
17:13:52 <tromp> so i figured:(
17:14:11 <pastorn> unkanon: why are you using an accumulator?
17:14:20 <pastorn> are your trees really that big?
17:14:52 <pastorn> unkanon: it should only be two lines...
17:14:59 <unkanon> pastorn: I don't know, tail calls just seemed easier to reason about in this exercise
17:15:40 <unkanon> pastorn: the whole solution should only be two lines?
17:16:21 <pastorn> unkanon: reload that paste
17:16:50 <unkanon> pastorn: no! I can't see the solution :)
17:16:56 <pastorn> @type max
17:16:58 <unkanon> I'm trying to learn :)
17:17:05 <pastorn> max :: Ord a => a -> a -> a
17:17:09 <pastorn> use that
17:17:56 <unkanon> pastorn: lol I really can't see how max will help :/ (still thinking)
17:18:25 <pastorn> unkanon: which subtree is largest here? Node { nElem = (), nL = Node () Empty Empty, nR = Empty }
17:18:33 <pastorn> nL or nR?
17:18:41 <unkanon> nL
17:18:52 <pastorn> so what's the height of that tree?
17:18:59 <unkanon> 2
17:19:08 <pastorn> why is it 2?
17:19:13 <tromp> i'd say 1
17:19:21 <unkanon> that's convention really
17:19:24 <pastorn> tromp: quiet you
17:19:31 <tromp> i like an empty tree to have height 0 :)
17:19:35 <mee> I'm curious what the performance of HalVM vs. GHC-in-vm is
17:19:51 <unkanon> pastorn: hold on, I'll brb
17:25:55 <pastorn> unkanon: well?
17:26:08 <ManateeLazyCat> Bye all.
17:33:17 <d-snp> > getLine
17:33:29 <d-snp> > 1 + 1
17:33:31 <d-snp> oh
17:33:59 <d-snp> lets just fire up ghci :P
17:34:31 <c_wraith> ghci has different behavior than lambdabot for getLine.  ghci executes IO actions.  lambdabot just prints a representation of them
17:35:08 <djahandarie> "A representation" is overkill. It just prints "IO"
17:35:17 <d-snp> I was wondering, if I wrap a call to getLine inside a function to always return a string
17:35:23 <d-snp> it works like any other haskell function right?
17:35:41 <jmcarthur> it would return an IO String
17:36:45 <d-snp> but I can fetch the String from the IO String right?
17:36:52 <c_wraith> getLine isn't a function.
17:36:54 <c_wraith> It's a value
17:37:14 <d-snp> ohhh
17:38:06 <d-snp> hmm, and putStrLn ?
17:38:12 <c_wraith> that's a function.
17:38:18 <djahandarie> Having lambdabot here would sure be illustrative right now
17:38:21 <d-snp> but you pass it an io stream?
17:38:34 <djahandarie> putStrLn :: String -> IO ()
17:38:37 <djahandarie> You pass it a String
17:38:38 <c_wraith> But calling the function doesn't result in performing IO
17:38:44 <jmcarthur> functions are values too
17:38:47 <d-snp> I have ghci running so if you want to show me something please do :)
17:38:50 <FunctorSalad> djahandarie: now that you say it, wouldn't it be nice if it used an gadt io type
17:38:53 <jmcarthur> just not the other way around :)
17:39:21 <hpc> d-snp: let foo = putStrLn "this is a test"
17:39:23 <hpc> :t foo
17:39:23 <djahandarie> FunctorSalad, that'd be interesting
17:39:25 <hpc> foo
17:39:27 <hpc> foo
17:39:49 <FunctorSalad> iirc there's one of hackage; the challenge would be building lambdabot :p
17:40:01 <djahandarie> We really need a new bot
17:40:07 <jmcarthur> d-snp: with IO, you never extract the value from it. instead you transform your pure functions to accept things in IO. you don't have to write all your functions using IO though. we have other functions to lift them into IO for you, e.g. (>>=)
17:40:53 <jmcarthur> d-snp: for example, (>>= putStrLn) has type IO String -> IO ()
17:41:03 <jmcarthur> d-snp: that's why you can feed getLine to it
17:41:09 <jmcarthur> :t getLine
17:41:15 <d-snp> so the error I get from this: Prelude> let bar = getLine ++ " says hello"
17:41:16 <jmcarthur> doh
17:41:18 <djahandarie> getLine :: IO String
17:41:21 <dancor> @hoogle dsuSort
17:41:23 <d-snp> is because getLine doesn't return a real string?
17:41:28 <dancor> hm
17:41:34 <djahandarie> dancor, you're making this hard for me!
17:41:38 <jmcarthur> d-snp: getLine is an action, not a String
17:42:17 <jmcarthur> d-snp: what you have to do instead is make (++ " says hello") accept an argument in IO (which in the process makes its result an IO action as well)
17:42:49 <dancor> :3
17:42:49 * hackagebot atom 1.0.8 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.8 (LeePike)
17:43:25 <jmcarthur> d-snp: there are shorter, less obvious-to-beginner ways, but here's how i'd have a beginner do it:    getLine >>= \ln -> return (ln ++ " says hello")
17:43:51 <blackh> d-snp: 'main' returns an IO action, which is what your program does.  The Haskell code describing your program is a composition of IO's and pure functions using >>= and return ('do' being syntactic sugar).
17:44:05 <kmc> main *is* an IO action
17:44:09 <pastorn> d-snp: http://hpaste.org/41977/functions_are_just_values
17:44:13 <jmcarthur> d-snp: so basically it means "run the getLine action, then return the result of applying this pure function to the value you got out of getLine"
17:44:21 <blackh> Oops - main _is_ an IO action!
17:44:24 <kmc> @where Introduction_to_IO
17:44:36 <kmc> @wiki Introduction to IO
17:44:46 <c_wraith> kmc, those don't work without \bot
17:44:47 <kmc> http://haskell.org/haskellwiki/Introduction_to_IO
17:44:50 <dancor> @botslack
17:44:50 * hackagebot copilot 0.28 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-0.28 (LeePike)
17:44:52 <kmc> d-snp, ^^^^
17:44:56 <d-snp> kmc: you already gave me that link, I read it :)
17:45:00 <kmc> ah, ok :)
17:45:08 <kmc> yes, the type "IO String" is not very much like the type "String"
17:45:17 <kmc> in particular it doesn't have a string inside
17:45:42 <kmc> it has instructions for how to perform some IO and produce a string
17:45:54 <kmc> and the only way to get your instructions performed is to name them "main"
17:46:03 <roconnor> http://r6research.livejournal.com/23705.html
17:46:08 <kmc> however you can glue together instructions using (>>=)
17:46:10 <djahandarie> kmc, I think it's fine to think "it has a string inside" while you're building the recipe
17:46:21 <jmcarthur> i'll ask one more time since the channel seems a little more active now... does anybody know of a good way to make an Arbitrary instance for a HOAS GADT? i'm trying to work with something like this as a warmup: http://hpaste.org/41972/simple_gadt
17:46:22 <djahandarie> "If someone were running this, they would have a String at this point"
17:46:23 <kmc> i don't think it is
17:46:27 <kmc> right
17:46:31 <roconnor> ^^ Lenses Are Exactly the Coalgebras for the Selection Comonad 
17:46:33 <jmcarthur> or instances
17:46:34 <kmc> but getLine doesn't have a string inside
17:46:46 <kmc> in "getLine >>= \x -> ..." it's x that has the string
17:46:53 <d-snp> hmm, so what >>= does is, it does the io operation, with whatever it returns it calls the lambda you gave it, and then it returns the result of that lambda as another io object
17:46:57 <kmc> "perform getLine, call the result a string x"
17:47:00 <kmc> yes d-snp 
17:47:11 <kmc> >>= turns a recipe and a function-producing-recipes into a bigger compound recipe
17:47:15 <jmcarthur> well, more than that, it also executes the resulting IO action
17:47:27 <jmcarthur> well, since you were talking in terms of execution
17:47:30 <kmc> yeah
17:48:04 <kmc> there's two questions here: "what does the function (>>=) return" and "what IO does the IO action (m >>= f) describe"
17:48:14 <kmc> what the function (>>=) returns is an IO action
17:49:02 <blackh> You could say that Haskell is a meta-language for describing programs that perform I/O.
17:49:25 <unkanon> pastorn: sorry for the delay
17:49:27 <aavogt> it's meta-programs all the way down!
17:49:31 <d-snp> :P
17:49:50 <unkanon> aavogt: turtles!
17:50:11 <aavogt> blackh: what does that indirection actually buy you?
17:50:26 <unkanon> where do people hear that turtles story? I heard that on the QI tv show
17:51:08 <blackh> aavogt: It buys you the ability to make a large part of your program referentially transparent.
17:51:10 <d-snp> now say I would commit some horrendous act of heresy, and made a function somehow that executed the IO action it gets, and returns the value without IO?
17:51:17 <d-snp> would this be impossible or would it break things?
17:51:20 <pastorn> holy shit... i thought i'd make a simple example and now i'm stuck in type hell
17:51:34 <unkanon> d-snp: it would break things
17:51:48 <blackh> d-snp: We don't mention "unsafePerformIO" in this channel. :)
17:51:52 <unkanon> d-snp: you'd no longer be able to trust the type system, for one
17:52:05 <d-snp> because haskell relies on functions to return the same result based on the same input right?
17:52:09 <blackh> Watch me get kicked for evening saying the filthy word!
17:52:18 <kmc> sigh it's not really that scary
17:52:22 <jmcarthur> d-snp: there is a... i hesitate to call it "function"... *thing* called unsafePerformIO that does what you say
17:52:32 <d-snp> :P
17:52:55 <unkanon> d-snp: I think unsafePerformIO is meant only to make FFI funtions safe
17:52:56 <kmc> d-snp, it's impossible to write unsafePerformIO without help from your Haskell implementation
17:52:58 <jmcarthur> unsafePerformIO has its uses. i actually use it quite a bit, but i am strongly against beginners using it
17:53:01 <kmc> however it's provided by the FFI Addendum
17:53:13 <blackh> d-snp: Basically you can't cheat, because the compiler assumes referential transparency.  The classic example is unsafePerformIO sin_ where 'sin_' is an FFI call to the C "sin" function.  That would be the correct way to use it.
17:53:15 <kmc> see RWH for some use cases in the world of FFI
17:53:38 <d-snp> right, because you should only use it on things that are actually functions
17:53:54 <jmcarthur> unsafePerformIO is intended for wrapping up unobservable side effects into pure values
17:53:58 <d-snp> or that you just hope are really functions :P
17:54:12 <unkanon> it's a way to tell the compiler "I personally guarantee this function is pure, however I still need to do IO to grab the result of it"
17:54:22 <c_wraith> blackh: except you can bind c's sin function to a type without IO in it directly.  Need something with pointers, like...  string functions.
17:54:35 <aavogt> blackh: what parts aren't referentially transparent after you move the unpleasantness somewhere else without dealing with it?
17:54:43 <unkanon> pastorn: so let's say the depth of that tree you gave me is two
17:54:46 <jmcarthur> unkanon: not only that. it could also be an implementation that self-optimizes as you use it, for example. the internals may change, but the observable value may not
17:54:51 <blackh> c_wraith: I didn't know you could do that.
17:55:00 <unkanon> pastorn: you now want me to tell you how I figured that out, but programmatically, right?
17:55:11 <unkanon> pastorn: that's exactly what I can't yet do :)
17:55:38 <unkanon> jmcarthur: oh so there are genuine uses of unsafePerformIO without FFI?
17:55:50 <blackh> aavogt: I don't quite understand your question.
17:55:51 <jmcarthur> unkanon: yes
17:56:10 <c_wraith> unkanon, have you seen most of edwardk's crazy hacks?  :)
17:56:13 <unkanon> jmcarthur: is there an off-the-cuff example?
17:56:24 <unkanon> c_wraith: no but now I want to
17:56:29 <pastorn> d-snp: http://hpaste.org/41978/functions_are_just_values_wor
17:56:29 <c_wraith> look at edwardk's lub, or unamb, etc
17:56:30 <jmcarthur> unkanon: the speculation package is a simple example i think
17:56:35 <jmcarthur> c_wraith: those are conal's
17:56:37 <pastorn> d-snp: ^^^ my paste works now :)
17:56:42 <c_wraith> err, so they are.  whoops
17:56:45 <d-snp> pastorn: haha ok :P
17:56:46 <aavogt> blackh: if your model of IO is that it describes how an unspecified interpreter is to work, what parts of the language remain non-referentially transparent?
17:56:49 <c_wraith> speculation is edwardk, though
17:57:05 <unkanon> c_wraith: ok looking up conal lub, unamb...
17:57:08 <aavogt> err, what the interpreter takes as input
17:57:17 <djahandarie> speculation is whack
17:57:28 <aavogt> the output being implementation defined
17:57:29 <jmcarthur> whack?
17:57:37 <revenantphx> It helped me to think of the IO monad and function purity a bit like Lisp, but thats just me.
17:57:47 <blackh> aavogt: Err.. sorry, I still don't understand your question.
17:57:54 <djahandarie> Took awhile for me to really understand what the hell was going on in there sort of "whack".
17:57:58 <revenantphx> As in, it all macros out to something, and during that macroing out, functions are referentially transparent.
17:58:03 <revenantphx> That is, they can be substituted in.
17:58:07 <revenantphx> But at the end, it's not...
17:58:17 <unkanon> jmcarthur: speculation as in Data.Foldable.Speculation?
17:58:21 <revenantphx> It's like the haskell code evaluates out to something entirely different.
17:58:32 <revenantphx> This seems to me to be pretty limited as a metaphor though
17:58:32 <djahandarie> unkanon, the speculation package
17:58:37 <pastorn> unkanon: you lookad at the base and said "i have 1 level here"
17:58:40 <revenantphx> @hackage speculation
17:58:49 <aavogt> blackh | aavogt: It buys you the ability to make a large part of your program referentially transparent.
17:58:53 <djahandarie> http://hackage.haskell.org/package/speculation
17:59:10 <aavogt> blackh: is the whole program the 'large part' or is something not referentially transparent at that point?
17:59:10 <jmcarthur> unkanon: now that i look at it i disagree with the use of unsafePerformIO in it
17:59:11 <pastorn> ten you looked at tL and tR and thought "ok, tL is 1, and tR is 0, but the tree is as high as the hightest subtree from here"
17:59:18 <unkanon> djahandarie: thanks
17:59:24 <blackh> aavogt: Oh right.  The stuff that's in IO is not referentially transparent.
17:59:40 <unkanon> pastorn: but the only way to look at tL is to walk it
17:59:48 <pastorn> unkanon: indeed
17:59:54 <jmcarthur> unkanon: the result is still pure, but i would have preferred that unsafeIsEvaluated be in IO and the speculation implementation be under unsafePerformIO
17:59:56 <jmcarthur> whatever
17:59:57 <unkanon> pastorn: my problem is, sometimes I look at both branches and they both seem non-empty
18:00:05 <pastorn> Node _ tL tR -> 1 + max (height tL) (height tR)
18:00:13 <jmcarthur> unkanon: unamb may be a cooler example anyway
18:00:35 <unkanon> jmcarthur: wow that's really complex. yeah I'll look at unamb, I am familiar with amb so I wonder what unamb does :P
18:00:41 <c_wraith> http://conal.net/blog/posts/functional-concurrency-with-unambiguous-choice/
18:00:46 <pastorn> unkanon: get it?
18:00:48 <c_wraith> that's conal's explanation of unamb
18:01:13 <unkanon> :t max
18:01:14 <jmcarthur> unkanon: unamb basically evaluates two values in parallel and gives you the one that finishes first. it has the precondition that they must evaluate to the same value if they are not _|_
18:01:39 <ndrsndrs> <fake_lambdabot> max :: Ord a => a -> a -> a
18:01:48 <Eduard_Munteanu> Oh goddamn it it's waaaay tooo slow.
18:02:08 <unkanon> pastorn: uhm...
18:02:11 <jmcarthur> unkanon: it can be used to implement things like parallel or, such that   <really long computation> `por` True  returns quickly
18:02:12 <pastorn> unkanon: max :: (Ord a) => a -> a -> a
18:02:23 <pastorn> unkanon: max x y = if x > y then x else y
18:02:31 <unkanon> pastorn: no I get that part :)
18:02:37 <jmcarthur> unkanon: lub is even cooler, but really just relies on unamb, iirc
18:02:50 <unkanon> pastorn: what I'm wondering is, since I created the Tree type I'm working on, it doesn't really derive from Ord :)
18:03:33 <pastorn> no, it's not the tree that you run max on
18:03:38 <pastorn> it's (height someTree)
18:03:50 <pastorn> so it's the height of it, which is an Int
18:04:18 <unkanon> pastorn: oh!
18:04:24 <aavogt> blackh: the model of IO is like http://lukepalmer.wordpress.com/2008/03/29/io-monad-the-continuation-presentation/ ?
18:04:31 <unkanon> pastorn: ok let me write some, I think I get it now :)
18:04:40 <d-snp> should I interpret Functor as 'Enumerable' ?
18:04:52 <aavogt> blackh: I mean the GADT version on that page
18:05:14 <pastorn> d-snp: you should consider it as the 'forEachInThisContainer' class
18:05:23 <c_wraith> d-snp, functor is more like "updateContents"
18:06:40 <d-snp> so.. does that mean a functor works like map or can be mapped?
18:06:44 <Eduard_Munteanu> Could it be that non-lazy ByteStrings are faster?
18:07:06 <adnap> Are there any good graph data structures already implemented in Haskell?  I need to be able to have cycles.  Particularily, I'm trying to implement a winged edge data structure.
18:07:35 <d-snp> functor foo applies foo to every element in functor?
18:07:43 <blackh> aavogt: I don't understand. Are you explaining something to me, or getting me to explain something to you?
18:08:22 <aavogt> blackh: I don't understand what is referentially transparent with such model of IO
18:08:25 <Eduard_Munteanu> d-snp: not all functors are like lists
18:08:40 <pastorn> d-snp: it runs some function over some container
18:08:46 <pastorn> d-snp: try this in ghci:
18:08:51 <pastorn> fmap length getLine
18:09:04 <pastorn> also these:
18:09:12 <pastorn> fmap (+1) (Just 0)
18:09:16 <pastorn> fmap (+1) Nothing
18:09:27 <Eduard_Munteanu> Maybe you should look at the functor axioms and see how much leeway you have.
18:09:48 <blackh> aavogt: Well, the "RealWorld" thing is just a trick, really.  It just make IO "fit" into a referentially transparent world.
18:10:14 <unkanon> pastorn: I was really complicating that problem :)
18:10:19 <unkanon> pastorn: thanks a lot
18:10:23 <d-snp> hmm thanks pastorn 
18:11:20 * pastorn is a karma whore
18:11:21 <aavogt> blackh: it seems that all IO is referentially transparent going by that GADT, but the model only covers part of what IO is
18:12:32 <adnap> Is Data.Graph in the containers package the most widely used graph data structure?  Does it suit most purposes, or are there any specific limitations I should know about?
18:14:18 <unkanon> pastorn: there should be a karma system indeed
18:14:21 <adnap> I guess there is also the FGL package...
18:14:39 <pastorn> unkanon: there is, when lambdabot works :)
18:15:05 <pastorn> i think mine's extremely negative... me and ivanm was at war for a while...
18:15:12 <pastorn> preflex: seen ivanm
18:15:12 <preflex>  ivanm was last seen on #haskell 15 hours, 7 minutes and 50 seconds ago, saying: romildo: sounds like it's something that is implemented in all of them, but there's no real guarantees
18:15:49 <unkanon> pastorn: oh it's something like nickname++ ?
18:15:50 <blackh> aavogt: I was just talking about the fact that IO enables you to express things like "modifyIORef xRef (1+)", which is not referentially transparent.  From my point of view, this constitutes "part of your Haskell program".  You could argue that IO actions are not Haskell programs, but that's just semantics.
18:15:58 * hackagebot Etage 0.1.3 - A general data-flow framework  http://hackage.haskell.org/package/Etage-0.1.3 (MitarMilutinovic)
18:16:05 <pastorn> unkanon: something like that
18:18:44 <danharaj> IO is referentially transparent
18:19:12 <Axman6> giving IO actions the same arguments twice is very difficult though
18:19:41 <Saizan> especially since they are not functions
18:20:11 <Saizan> the State RealWorld model is broken, don't use it :)
18:25:38 <Saizan> the idea anyhow, is that, aside from breaking the IO abstractness, you can always inline the definition of IO actions and get the same program, which will perform the same side effects
18:28:54 <Saizan> note that in "do x <- foo; .." foo is not the definition of x
18:33:43 <Eduard_Munteanu> Is it possible my distro's (Gentoo) binary GHC+libs is killing performance?
18:34:31 <Eduard_Munteanu> dev-lang/ghc-6.12.3 +binary
18:35:03 <Azrael-> GHCi is now printing the result of evaluating [1..] to my terminal, thus heating up my laptop, thus keeping me warm.
18:35:19 <MrAI> lol
18:35:23 <revenantphx> :t (<-)
18:35:25 <unkanon> lol that's pretty funny
18:35:46 <djahandarie> revenantphx, not a function
18:35:47 <Azrael-> I guess I really am getting into the way of solving all my problems with functional programming. :)
18:35:52 <MrAI> haha
18:35:53 <proq> ha ha, I do that too (not with [1..] though)
18:36:08 <Azrael-> Do you have a shorter nonterminating snippet?
18:36:17 <jmcarthur> Azrael-: look at that! pure code can cause side effects after all!
18:36:21 <Eduard_Munteanu> ./burnK7 :P
18:36:27 <Eduard_Munteanu> (from cpuburn)
18:36:28 <mee> jmcarthur++   ;)
18:36:32 <MrAI> lol!
18:36:43 <Eduard_Munteanu> Heh, good point.
18:36:49 <proq> Azrael-: no, I just do random tasks that I know will be cpu intensive
18:36:53 <MrAI> Oh gosh im feeling all geeky now - Im getting haskell jokes :s
18:37:07 <Azrael-> I don't have any tasks to do. I suppose I could calculate pi or primes or something but that's been done before.
18:37:26 <revenantphx> so, one question
18:37:27 <revenantphx> http://hackage.haskell.org/packages/archive/binary/0.4.1/doc/html/Data-Binary.html
18:37:33 <revenantphx> in the example instance shown there
18:37:45 <revenantphx> The types of s, e1 and e2 are inferred from their use in return?
18:38:23 <MrAI> I feel so dirty.... = ((sum (sumfirst (positions r1 (0,0)))) == (sum (sumfirst (positions r2 (0,0))))) &&
18:38:23 <MrAI>  ((sum (sumsecond (positions r1 (0,0)))) == (sum (sumsecond (positions r2 (0,0)))))
18:38:41 <revenantphx> 0.o
18:38:42 <revenantphx> ew.
18:38:43 <MrAI> ...I know I probably have too many () lol
18:38:45 <revenantphx> Parentheses...
18:39:21 <MrAI> But it works :) haha
18:40:08 <Eduard_Munteanu> revenantphx: s, e1 and e2 are parameters to the OpE constructor.
18:40:22 <Eduard_Munteanu> revenantphx: does that answer it?
18:40:29 <revenantphx> Well, yes.
18:40:35 <revenantphx> And following from that.
18:40:48 <revenantphx> If you were to have another case there
18:40:58 <revenantphx> similar to how it's used in the Drinks example.
18:41:11 <revenantphx> Could you have multiple type-inferred routines like that?
18:41:22 <revenantphx> simply, is the type system smart enough to follow through the case?
18:41:29 <revenantphx> And figure out what you intend to use stuff for?
18:42:15 <Eduard_Munteanu> revenantphx: I'm not sure I follow. The instance is written for a particular type, which has known constructors.
18:42:37 <Eduard_Munteanu> So whenever those data constructors are called, their parameters must fit.
18:42:56 <revenantphx> Right.
18:43:01 <revenantphx> You see the drinks example?
18:43:04 <Eduard_Munteanu> Yes.
18:43:08 <revenantphx> Say Tea and Wine had additional parameters.
18:43:18 <revenantphx> If they had gets in their cases then
18:43:25 <revenantphx> would the type system be able to infer their types?
18:43:59 <Eduard_Munteanu> revenantphx: the type would be the same anyway, Main.Drinks.
18:44:12 <revenantphx> Yes, but what if it has multiple constructors.
18:44:13 <Eduard_Munteanu> It doesn't depend on that 'case'
18:44:26 <Eduard_Munteanu> revenantphx: it does have multiple constructors.
18:44:29 <revenantphx> I think you misunderstand.
18:44:51 <Eduard_Munteanu> type Drinks a = Coffee | Tea | Beer a | ...
18:44:54 <Eduard_Munteanu> erm
18:44:55 <revenantphx> Say that you do multiple gets allowing type inferrance like the example prior.
18:44:57 <Eduard_Munteanu> data Drinks a = Coffee | Tea | Beer a | ...
18:45:01 <revenantphx> for each of the different drink types.
18:45:21 <revenantphx> And then in each case of the case statement, you have a routine like that.
18:45:32 <Eduard_Munteanu> Yes, but those drink types aren't Haskell types.
18:45:32 <revenantphx> And then call the constructor.
18:45:37 <revenantphx> >_<
18:45:39 <revenantphx> nevermind.
18:45:46 <revenantphx> I think I have the answer myself.
18:45:49 <revenantphx> I'll figure out the hard way.
18:46:25 <FunctorSalad> the beer can contain arbitrary objects? :o
18:46:36 <Eduard_Munteanu> revenantphx: I'm not sure what your assumption is, "Coffee" isn't a type
18:46:54 <revenantphx> That's not my assumptions
18:46:55 <revenantphx> *sigh*
18:47:02 <revenantphx> Just... nevermind.
18:48:16 <FunctorSalad> Azrael-: it's cold, consider forkIO (print [1..]) 
18:48:22 <alej> I have a vague, subjective question and only #haskell can help me!
18:48:46 <alej> should I get purely functional data structures or pearls of functional algorithm design? (not both, for now)??
18:48:48 <Azrael-> FunctorSalad, unfortunately I'm not well-versed in Haskell to know what that does.
18:48:49 <revenantphx> @quote fugue
18:49:04 <Azrael-> Will it use more CPU time than just [1..]?
18:49:09 <FunctorSalad> Azrael-: launch the printing in a different thread, so you can have *all* your cores at 100% ;)
18:49:17 <FunctorSalad> if you issue it several times
18:49:17 <Azrael-> Aha! Excellent.
18:49:26 <revenantphx> XD
18:49:37 <revenantphx> Better yet, why not run 48 parallel instances on your GPU as well.
18:49:40 <revenantphx> That thing gets much hotter.
18:49:49 <revenantphx> And burn some discs while you're at it.
18:49:53 * Eduard_Munteanu recommends cpuburn for cold nights
18:49:56 <Azrael-> Whereabouts is forkIO?
18:50:03 <alej> Control.Concurrent
18:52:56 <Azrael-> This is slightly toastier.
18:53:46 <unkanon> or maybe buy a heater? :P
18:53:50 * Eduard_Munteanu cracks an egg open on top of Azrael-'s lappy
18:53:59 <alej> nobody can recommend a book for me? :(
18:54:03 <Azrael-> Not *that* toasty in here, Eduard_Munteanu.
18:55:08 <unkanon> alej: I haven't read any of those :/
18:55:14 <FunctorSalad> I'd be scared about damaging this laptop when running both cores at 100% for any amount of time, though
18:55:24 <djahandarie> FunctorSalad, same :(
18:55:24 <djahandarie> Well
18:55:28 <djahandarie> My laptop would just shut off
18:55:33 <alej> unkanon: ok :/
18:56:28 <winxordie> alej: I can recommend purely functional as good by itself, but I haven't read the other.
18:58:34 <Eduard_Munteanu> Really?
18:58:49 <Eduard_Munteanu> My laptop broke some time ago... guess it was Gentoo at fault :P
18:59:08 <alej> winxordie: hmmmmmmmmmm ok
18:59:10 <Eduard_Munteanu> (they replaced its motherboard)
18:59:58 <Azrael-> Spending an English winter in a top floor room in a listed building with flimsy windows and a dodgy heater isn't fun.
19:00:31 <Azrael-> Anyway, I'm off to bed now.
19:00:39 <Azrael-> It's 3am, I have to be places at 9am.
19:00:40 <gienah> alej: I have not read pearls of functional algorithm design either, bird is such an excellent author though it is bound to be awesome
19:00:47 <Azrael-> (Places related to Haskell in fact)
19:01:06 <Azrael-> I wish you all the best in your future endeavours, gentlemen.
19:01:31 <djahandarie> Enjoy
19:02:04 <alej> hrmm
19:06:38 <alej> thanks dudes
19:12:47 <unkanon> wow I hadn't realized how reliant I became on lambdabot
19:13:00 <unkanon> I really need an offline version of it
19:13:11 <unkanon> either that or ghci needs @src, @pl...
19:14:15 <pastorn> unkanon: you can have her all to yourself
19:14:19 <pastorn> check hackage
19:14:30 <pastorn> though i think actually buliding her is quite the task...
19:14:44 <unkanon> I'll look into it one day
19:14:47 <unkanon> what I'd really love
19:14:57 <unkanon> would be to be able to use it ithin ghci like I use hoogle
19:15:00 <pastorn> when you have Time Over (TM)
19:15:18 <unkanon> I usually say when I get a Round Tuit :)
19:15:18 <pastorn> there's GOA (Ghc On Acid)
19:15:29 <pastorn> don't know exactly what that provides, though
19:15:36 <unkanon> hmm
19:18:26 <FunctorSalad> not ghci on acid?
19:19:17 <revenantphx> One question, are haskell values always big endian?
19:19:27 <unkanon> anybody have an offline lambdabot handy? lol
19:19:30 <revenantphx> I noticed Binary says encoding should occur big endian.
19:19:41 <revenantphx> unkanon: http://www.haskell.org/haskellwiki/Lambdabot
19:20:05 <pastorn> revenantphx: that's probably platform-specific
19:20:14 <mauke> revenantphx: Haskell values have no endianness
19:21:23 <pastorn> revenantphx: if you're using Data.Binary you can mess around with endianness if you want
19:21:56 <kmc> the Haskell spec says almost nothing about internal in-memory representation
19:22:14 <revenantphx> "Values are always encoded in network order (big endian) form, and encoded data should be portable across machine endianess, word size, or compiler version."
19:22:23 <revenantphx> Alright, just curious.
19:22:26 <kmc> if you're asking how GHC actually does it
19:22:29 <revenantphx> No no.
19:22:35 <kmc> Int and Word are native machine types, and will have native endianness
19:22:40 <revenantphx> Right.
19:22:49 <revenantphx> So then put/get have some magic that flips them?
19:22:53 <revenantphx> Source Int
19:23:03 <revenantphx> For primitive types?
19:23:44 <kmc> unless they're using some unsafeCoerce# dark magic, then there's no way to observe the bytes of an Int to begin with
19:23:59 <kmc> you'd just use arithmetic
19:24:39 <Eduard_Munteanu> Ok, so here's this program that reads stuff and processes it sequentially, and I profiled its heap. Memory consumption goes up and down quite often.
19:24:59 <Eduard_Munteanu> I'm beginning to think this is also why it's about 10x times slower than an equivalent C code
19:25:13 <Eduard_Munteanu> I'm using ByteStrings. Any idea what would cause this?
19:25:29 <lars9> img, HaLVM!!
19:25:36 <lars9> s/i/o/
19:25:49 <Eduard_Munteanu> (the program does Shannon-Fano compression: builds a tree, then looks up codes for symbols)
19:26:16 <kmc> Eduard_Munteanu, which sort of heap profile did you runV
19:26:18 <kmc> run?*
19:26:20 <Eduard_Munteanu> kmc: -hc
19:26:56 <lars9> hey anyone tried that HaLVM?
19:27:09 <revenantphx> How could I check how strings are 'put' with Binary?
19:27:13 <revenantphx> @source String
19:27:18 <revenantphx> something along those liens.
19:27:26 <kmc> read the source to the binary library
19:27:27 <kmc> off hackage
19:27:33 <kmc> hackage's haddocks have source links
19:27:35 <revenantphx> ah right, the little source links.
19:27:46 <kmc> Eduard_Munteanu, did you try -hd and -hy?
19:28:13 <revenantphx> Oh right, String is an array of Char
19:28:23 <Eduard_Munteanu> kmc: not yet, lemme look...
19:28:32 <revenantphx> So... it'd be Ix?
19:29:44 <Eduard_Munteanu> revenantphx: Ix? That represents types of indices.
19:29:55 <Eduard_Munteanu> It's a typeclass, not a type.
19:29:59 <revenantphx> Ah right. >_<
19:30:05 <revenantphx> I can make my own instance for String I guess.
19:30:08 <revenantphx> There isn't an existing one.
19:30:16 <revenantphx> Arrays are:
19:30:16 <revenantphx> instance (Binary i, Ix i, Binary e) => Binary (Array i e) where
19:30:22 <revenantphx> I'm kind of confused by that...
19:31:05 <revenantphx> It's just saying it has to be an array of something indexable (which is also Binary)... and then 'e'
19:31:10 <pastorn> revenantphx: when storing a list of binary values it first stores the length then it stores the reverse of the list
19:31:30 <revenantphx> Oh, since lists are cons'd or something similar?
19:31:31 <pastorn> it does the reverse because that's quicker to restore
19:31:38 <pastorn> (i think)
19:31:41 <revenantphx> Well I'll need my own string version then.
19:31:51 <revenantphx> Put Int16 length and then each character... in unicode.
19:31:52 <revenantphx> erp.
19:32:08 <mauke> "in unicode" is meaningless
19:32:15 <mauke> you want a UTF
19:32:22 <revenantphx> UTF-8 in this case.
19:32:26 <pastorn> revenantphx: why would you want to do your own version? you already have a good implementation of Binary for Char
19:32:37 <revenantphx> pastorn: For Char, not [Char]
19:32:42 <revenantphx> I want it to encode specifically for my needs.
19:32:43 <pastorn> yes you have
19:32:54 <revenantphx> There is [Char], but it doesn't do what I want :P.
19:32:57 <pastorn> do you want to read your file later?
19:33:02 <revenantphx> It's not a file, it's network.
19:33:15 <pastorn> then why do you want to do it in some magic special way?
19:33:17 <revenantphx> Gotta comply with the protocol (no matter how god awful it is :D)
19:33:21 <revenantphx> Not magic :\.
19:33:28 <revenantphx> I just want to encode strings differently.
19:33:38 <revenantphx> Int16 length followed by bytes in *forward* order.
19:33:51 <pastorn> well, you can just traverse that yourself
19:33:57 <pastorn> mapM put myString
19:33:58 <revenantphx> I don't make the protocol.
19:34:00 <pastorn> done
19:34:01 <revenantphx> Exactly.
19:34:11 <Eduard_Munteanu> kmc: interesting, -hd shows (:) and W8# (I assume that's Word8 unboxed) are the biggest offenders.
19:34:11 <revenantphx> No problem :P
19:34:30 <revenantphx> can I hide an instance declaration?
19:34:36 <revenantphx> in an import with a hiding statment?
19:34:48 <mauke> no
19:35:00 <mauke> instances infest everything
19:35:12 <revenantphx> Well, then how will I make a custom String encoding :\
19:35:14 <revenantphx> Would it be fine to make a type synonym or something for String?
19:35:23 <revenantphx> I guess it'd have to be newtype so it doesn't alias back?
19:35:40 <mauke> why do you have to use instances at all?
19:35:53 <mauke> isn't there a Put monad for this kind of stuff?
19:35:55 <revenantphx> Because I want to try encoding this way... >_>
19:36:03 <revenantphx> It's all educational.
19:36:22 <revenantphx> I'm just thinking I can encapsulate the encoding behavior into an instance and it'd be quite nice and convenient.
19:36:50 <pastorn> revenantphx: you can use the SPECIALIZE pragma
19:36:56 <revenantphx> oh dear, pragmas.
19:37:00 <mauke> oh god
19:37:29 <revenantphx> Lets see if creating a new instance declaration will error everything
19:38:03 <Eduard_Munteanu> Can Haskell forget some previously computed values only to find out later they need to be recomputed?
19:38:23 <kmc> Haskell can Eduard_Munteanu
19:38:25 <revenantphx> Argh, yeah...
19:38:30 <revenantphx> (All instance types must be of the form (T t1 ... tn)
19:38:30 <kmc> but GHC never will
19:38:30 <revenantphx>          where T is not a synonym.
19:38:30 <revenantphx>          Use -XTypeSynonymInstances if you want to disable this.)
19:38:31 <kmc> afaixk
19:38:42 <Eduard_Munteanu> Ah, that was my hypothesis...
19:38:46 <kmc> Haskell only need have non-strict semantics; it doesn't have to be lazy at all
19:39:22 <pastorn> revenantphx: of course you'll need TypeSynonymInstances :p
19:39:31 <Eduard_Munteanu> Yeah, it could do speculative evaluation.
19:39:33 <pastorn> but i'm telling you, you should really use SPECIALIZE
19:39:41 <revenantphx> what is this SPECIALIZE TT_TT
19:39:42 <kmc> or i think even call-by-name, which would duplicate work
19:39:45 <revenantphx> It's a pragma, I'm scared.
19:40:00 <pastorn> revenantphx: if you have something, say Map Int a
19:40:16 <pastorn> then SPECIALIZE could optimize your tree for just *that* key type
19:40:35 <kmc> though in this case it should be noted that Data.IntMap is far more efficient than a Map specialized to Int
19:40:42 <kmc> it's a completely different data structure
19:40:43 <pastorn> or perhaps you could store your [Bool] as [Word8]
19:40:52 <ManateeLazyCat> My new Twitter background : http://www.flickr.com/photos/48809572@N02/5222835668/lightbox/
19:40:59 <pastorn> kmc: plz...
19:41:24 <kmc> plz wat?
19:41:56 <revenantphx> Is there a built in string length function :\?
19:41:57 <danderson> plzzzzzzz!
19:42:04 <kmc> revenantphx, same as length of any other list
19:42:10 <kmc> length "foobar"
19:42:16 <kmc> Eduard_Munteanu, sometimes people do things in GHC Haskell to deliberately prevent sharing
19:42:16 <revenantphx> Ah right, length
19:42:17 <revenantphx> fuck me.
19:42:23 <kadoban> i installed a library with hackage, but when i try to link a program using that with the -prof flag, i get: http://hpaste.org/41979/prof_problem  is this a problem with the package, or do i need to do something?
19:42:28 <kmc> this is one of the uses of functions of type () -> T
19:42:34 <ManateeLazyCat> brb
19:42:48 <kmc> you need to install the profiling libraries kadoban 
19:42:57 <pastorn> revenantphx: but seriously, if you're doing network protocol stuff why are you using Strings to begin with?
19:43:03 <kadoban> kmc: how do i do that? :/
19:43:06 <pastorn> shouldn't you be using ByteString from the get go?
19:43:08 <kmc> kadoban, put this is ~/.cabal/config:
19:43:09 <kmc> library-profiling: True
19:43:24 <kmc> then you'll need to cabal install --reinstall NumberSieves
19:43:29 <kmc> and maybe some of its dependencies
19:44:08 <kmc> i kinda wish that cabal-install / Haskell Platform asked you whether you're a developer
19:44:20 <kmc> and if so changed some defaults like profiling libs, building haddock for everything ,etgc
19:44:25 <kmc> i am not good at typing today
19:44:42 <kadoban> kmc: yay, thanks.  worked like a charm
19:45:39 <Eduard_Munteanu> Is there a way to disable GC completely?
19:46:01 <revenantphx> pastorn: there are strings within the protocol.
19:46:03 <revenantphx> That I need to encode.
19:46:14 <revenantphx> and decode :\
19:46:18 <revenantphx> So, String is fine.
19:49:09 <adu> does anyone know of some good determinant algorithms?
19:49:17 <pastorn> revenantphx: i'd say there are two ways to approach this
19:49:26 <revenantphx> :\
19:49:31 <pastorn> revenantphx: eiter you wrap the string type; 
19:49:38 * hackagebot husk-scheme 1.1 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-1.1 (JustinEthier)
19:49:38 <pastorn> data WrappedString = WS String
19:49:47 <pastorn> and make an instance for that
19:50:12 <pastorn> *or* you make a special functions just for just strings - getString/putString
19:50:21 <revenantphx> mm.
19:50:24 <revenantphx> One moment please.
19:50:30 <Eduard_Munteanu> adu: hmatrix uses GSL for some stuff so I think it's good.
19:50:42 <adu> ah GSL
19:50:45 <pastorn> revenantphx: what is this for?
19:50:47 <Eduard_Munteanu> adu: otoh, are you asking for something to implement yourself?
19:50:53 <revenantphx> pastorn,just for fun
19:50:55 <revenantphx> one moment please.
19:51:09 <pastorn> revenantphx: then how is the data you want to send encoded?
19:51:18 <pastorn> do you have a datatype containing your data?
19:51:19 <adu> Eduard_Munteanu: yeah, well I'm trying to do it for arbitrarily large matrices
19:51:33 <revenantphx> this is a single data type present in many packets
19:51:38 <revenantphx> big endian short as string length, and then the UTF-8 bytes.
19:51:40 <Eduard_Munteanu> adu: standard determinant algos should work for that.
19:51:50 <revenantphx> Just trying to give it a put/get routine I can use easily.
19:51:52 <adnap> I've written a program in c and a program in haskell which both draw triangles to the screen.  The Haskell program uses GPipe.  I'm trying to test the performance of GPipe.  Can anyone with enough familiarity check to see if the programs constitute a valid comparison?
19:51:53 <revenantphx> Now, one moment please.
19:52:28 <adu> Eduard_Munteanu: i'm having trouble with 'concat'
19:52:31 <Eduard_Munteanu> They generally use factorisations like LU, Householder to reduce the matrix to a simpler form.
19:52:46 <pastorn> revenantphx: ok, then it's easy
19:53:04 <Eduard_Munteanu> (like an upper triangular form)
19:53:12 <Eduard_Munteanu> adu: what trouble?
19:53:31 <revenantphx> One... moment...please...
19:53:39 <revenantphx> This is a pretty damn simple set of three words.
19:53:39 <adnap> http://hpaste.org/paste/41980/triangles#p41981
19:53:49 <MrAI> Ive just come accross a defintion where there is a list on the left side of the :: - Does this make a difference? 
19:54:08 <MrAI> e.g. test sx :: [a] -> (Int,Int)
19:54:55 <adu> Eduard_Munteanu: laugh if you want, but I'm generating C code for fixed sized matrices: http://hpaste.org/41982/matrix_code_generation
19:54:59 <Eduard_Munteanu> MrAI: not really, the whole expression on the left must have the type on the right
19:55:46 <MrAI> I see. Does it make a difference to how I call it? Can I just ignore it and assume its there for easier reading?
19:55:56 <revenantphx> pastorn: this compiles at least: http://hpaste.org/41983/stringencode
19:56:01 <Eduard_Munteanu> Wow, why?
19:56:04 <Cale> MrAI: wait, were there commas in that?
19:56:10 <pastorn> revenantphx: do { l <- getWord16be; cs <- replicateM l getWord8; let bs = Data.ByteString.pack cs; return bs }
19:56:16 <Eduard_Munteanu> adu: I mean, are you sure that works?
19:56:21 <revenantphx> ignore the get method for now.
19:56:31 <Cale> MrAI: f, g :: t  as a declaration means that both f and g have type t
19:56:35 <Eduard_Munteanu> There's no standard formula like for 3x3 matrices for the rest.
19:56:37 <revenantphx> Thanks for that, helpful.
19:56:39 <MrAI> Nope no ,
19:56:40 <adu> Eduard_Munteanu: why wouldn't it work?
19:56:43 <Eduard_Munteanu> (at least not one that's that easy to compute)
19:56:54 <pastorn> revenantphx: don't do an instance of for string, do an instance for packet
19:57:00 <MrAI> Just: test xs :: [a] -> (Int,Int)
19:57:05 <Cale> MrAI: foo x y :: t  as an expression means the same thing as  foo x y  except that it forces the type to be t.
19:57:09 <revenantphx> pastorn: the point is I'm trying to make it out of teeny modules.
19:57:12 <adu> Eduard_Munteanu: the standard formula for arbitrary size matrices is adjugate/cofactors
19:57:17 <revenantphx> why *not* do an instance for string?
19:57:18 <Cale> But it can't occur at the top level.
19:57:24 <Cale> (only in an expression)
19:57:34 <adu> Eduard_Munteanu: for matrix inversion that is
19:57:37 <revenantphx> I agree I should wrap string here, but just wondering.
19:57:39 <Eduard_Munteanu> adu: yeah, I mean no easy formula. That's terribly inefficient.
19:57:40 <Kaidelong> MrAI: all that says is that "text xs" is of type "[a] -> (Int,Int)"
19:57:59 <adu> Eduard_Munteanu: yes, which is why I would like to make it faster
19:58:12 <Cale> adnap: Just a warning: there are tabs in this code. You should configure your text editor to replace tabs with spaces automatically.
19:58:14 <pastorn> revenantphx: because you will never have *only* a string sent over the socket,
19:58:17 <MrAI> So when I write an expression do I need to include the xs part? Or is "text a =" good enough?
19:58:25 <pastorn> revenantphx: you'll always have packages
19:58:29 <revenantphx> pastorn: no but due to the nature of the Get/Put mondas, I can break it up.
19:58:36 <adu> Eduard_Munteanu: I want to just call this program with (./gen 6000) and get a 6000x6000 matrix invert function
19:58:42 <Cale> adnap: Other than that -- how does the performance compare?
19:58:43 <Eduard_Munteanu> adu: the simplest thing is Gaussian elimination I think. You make zeros in the lower left triangle, then the determinant is the product of the diagonal elements.
19:58:45 <revenantphx> So within the parsing for each packet I can just use get/put
19:58:50 <pastorn> and within yor instance of Binary Package, you can do you string storage in whatever way you feel like
19:58:54 <revenantphx> The whole point is that they're composable.
19:59:08 <pastorn> revenantphx: but you said that breaking it up would cause trouble
19:59:15 <revenantphx> What?...
19:59:15 <Cale> adnap: If it's poor, I'd start by looking at that  concat [tri0 x dx ++ tri1 x dx | x <- [1, (1 - dx)..(-1 + dx)]]
19:59:18 <revenantphx> when?
19:59:29 <revenantphx> If I did I'm sorry, that's not what I said :\.
19:59:30 <pastorn> revenantphx: since storing a list will reverse it
19:59:33 <revenantphx> Oh, yes
19:59:37 <pastorn> revenantphx: exactly
19:59:38 <adu> Eduard_Munteanu: I believe that Gaussian elimination uses more adds/muls than expansion by cofactors, but this belief might be unfounded
19:59:40 <revenantphx> Which is why I'll have my own way to encode these.
19:59:48 <pastorn> revenantphx: EXACTYL
19:59:48 <revenantphx> I could do newtype MyString = String tbh
19:59:48 <Cale> Even though tri0 x dx is a short list, ++ isn't free.
19:59:59 <revenantphx> And my point is why not modularize my encoding.
20:00:01 <pastorn> revenantphx: instance Binary Package where
20:00:05 <Eduard_Munteanu> adu: it is unfounded, matrix inversion is known to be tougher than calculating the determinant.
20:00:09 <revenantphx> What if the same string encoding is used outside of packets.
20:00:10 <Cale> adnap: But I wouldn't expect it to hurt too much :)
20:00:13 <revenantphx> In other things as well.
20:00:16 <revenantphx> Such as a file format.
20:00:17 <pastorn> revenantphx: because your data is a special case
20:00:21 <Eduard_Munteanu> adu: and the adjugate matrix amounts to inversion.
20:00:26 <revenantphx> But within the scope of this problem, it's not.
20:00:28 <adu> Eduard_Munteanu: oh, yes for sure
20:01:02 <pastorn> revenantphx: if you have to do that then i'd reccomend a wrapped String
20:01:07 <MrAI> :t choose
20:01:20 <pastorn> one that encodes only that string
20:01:26 <pastorn> *that kind of
20:02:04 <Kaidelong> @type choose
20:02:16 <revenantphx> Have you not been reading?
20:02:20 <revenantphx> I just said I'll newtype it.
20:02:26 <revenantphx> newtype would work for this right?
20:02:32 <revenantphx> An exact clone with a unique identity?
20:02:41 <adu> o wow hpaste is helpful!
20:02:42 <pastorn> yes
20:02:44 <Cale> adnap: Also, your Haskell program seems to be doing a bunch of vector transformations?
20:02:48 <Eduard_Munteanu> adu: also I'm not sure you're calculating the adjugate in an efficient manner. (I don't think it is ever calculated directly)
20:03:08 <adu> Eduard_Munteanu: right, my code is slightly broken right now
20:03:17 <revenantphx> wait... erk
20:03:21 <adnap> Cale: Hey, sorry to get back to you so slowly.
20:03:42 <adnap> Cale: GPipe performs horribly compared to the C program.
20:04:00 <revenantphx> If I do newtype MyString = MyString String
20:04:02 <adnap> Cale: I get 17 fps for haskell and 480 fps for C.
20:04:04 <adu> Eduard_Munteanu: genMatrixCofactor is supposed to output a single add/mull expression that will calculate a single entry in the cofactor matrix
20:04:09 <revenantphx> then I can't use MyString in existing methods String works with :\
20:04:16 <adnap> Cale: That's with 10000 triangles.
20:04:43 <revenantphx> using TypeSynonymInstances and plain old type might be best.
20:04:44 <Cale> adnap: Well, looking closer at it, I suspect the problem is transform
20:04:56 <revenantphx> If I do that then 
20:04:58 <revenantphx> show $ "hello" :: MyString
20:05:01 <revenantphx> works perfectly fine
20:05:03 <Cale> adnap: btw, are you compiling this with -O2?
20:05:09 <adnap> Cale: With GPipe, you have to set up the model-view matrix manually.
20:05:24 <adnap> Cale: Compiling with O2 makes no difference.
20:05:36 <adnap> Cale: The performance is similar.
20:06:25 <adu> adnap: 480 fps is very good
20:06:30 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/hmatrix/0.10.0.0/doc/html/Numeric-LinearAlgebra-Algorithms.html#2
20:06:35 <Eduard_Munteanu> det there ^
20:07:06 <adnap> adu: Yeah, but that's the C program!
20:07:12 <adnap> adu: The haskell program is 17 fps.
20:07:17 <Eduard_Munteanu> It seems to be using a LU decomposition.
20:08:57 <adu> Eduard_Munteanu: that doesn't help me at all, that just calls C stuff i think
20:09:25 <LordBrain> anyone use vim as an ide on windows? I want a good solution for using the taglist plugin, which usually uses ctags
20:09:54 <Chaze> i never realized fib could be approximated with an exponential funcition. will this work even for large n?
20:09:58 <Chaze> let fib start fibstart n = fibstart * exp ((log a)* (n-start)) where a = 2 / (-1 + (sqrt 5))
20:10:02 <revenantphx> pastorn: http://hpaste.org/41984/custom_string_encoding
20:10:07 <revenantphx> This is what I came up with.
20:10:23 <LordBrain> searching around i found there is a :ctags command in ghci, but it seems to send all the output to a file called tags, and the taglist script in vim wants to get the stdout
20:10:26 <revenantphx> I'm aware the get can be simplified.
20:10:32 <Eduard_Munteanu> adu: yeah the LU decomposition itself seems to be a C call. But it's there if you need a good known implementation. Or look up LU decomposition and see how you can do it yourself.
20:10:39 <copumpkin> preflex: seen wli
20:10:39 <preflex>  wli was last seen on #haskell-blah 63 days, 10 hours, 3 minutes and 41 seconds ago, saying: boshhead: Instead of making the derivatives match up to the n-th order at a single point (Taylor series) you can use several points, or both ends of an interval, or similar.
20:10:49 <Eduard_Munteanu> adu: it's similar to Gaussian elimination
20:11:06 <adnap> Is there an implementation of Gauss Seidel on Hackage somewhere?
20:11:24 <LordBrain> nobody?
20:11:24 <adnap> I've checked out hmatrix too, but it only has like LU decomp.
20:11:32 <pastorn> revenantphx: seems good, but are you sure that the encoding will be correct?
20:11:37 <adnap> I didn't see any iterative algorithms.
20:11:50 <revenantphx> "-- Char is serialised as UTF-8"
20:11:54 <revenantphx> Says the source.
20:11:56 <adnap> I needs ta solve a big-ass matrix.
20:11:58 <revenantphx> So, that's cool.
20:12:02 <revenantphx> adnap: Data.Tensor?
20:12:15 <revenantphx> Probably not helpful, just data tyeps
20:12:42 <revenantphx> "Data.MarkovChain" convenient.
20:12:49 <LordBrain> use my nick if you respond, i'll be in another window.
20:12:49 <adnap> Data.Vec has types and so does hmatrix.
20:13:19 <adnap> vec is for low dimensional stuff, and hmatrix is for big matrices.
20:13:45 <adnap> But it would be crazy to solve a REALLY big matrix using LU.
20:13:50 <Eduard_Munteanu> adnap: have you looked at hmatrix?
20:13:59 <adnap> Eduard_Munteanu: Yeah, that's what I was talking about,.
20:14:16 <adnap> Eduard_Munteanu: I said it doesn't have any iterative algorithms for solving matrices.
20:15:16 <Eduard_Munteanu> IIRC Gauss Seidel is based on the LU decomposition.
20:15:27 <Eduard_Munteanu> and hmatrix seems to do something like that
20:15:44 <adu> Eduard_Munteanu: actually GSL is pretty good
20:16:00 <Eduard_Munteanu> Anyway, they're probably sparse matrices or packed in some way.
20:16:30 <adnap> Eduard_Munteanu: Gauss Seidel is based on the Jacobi method.
20:16:44 <adnap> I guess that does LU decomp though.
20:17:19 <adnap> I can't remember much.
20:18:36 <adnap> Yeah, the "remainder" in Gauss Seidel is decomposed into L and U.
20:19:11 <adnap> Anyone know what gives with my GPipe program though?!  wtf
20:20:25 <adu> Eduard_Munteanu: it looks like GSL only has det/inv defined for LU matrices
20:20:40 <Cale> adnap: Well, it looks like you may be recomputing those transformation matrices for every vertex, unless the compiler was sufficiently smart to lift those definitions up.
20:20:52 <Cale> (the way it's written, anyway
20:20:53 <Cale> )
20:21:45 <Eduard_Munteanu> adu: well you can obtain the LU decomposition
20:21:50 <Cale> adnap: I'm just rebuilding my dependency chain for profiling.
20:22:33 <Eduard_Munteanu> adu: that is for any matrix, there isn't a type of matrices called LU
20:23:35 <adu> hrm, Doolittle, Crout
20:24:08 <Eduard_Munteanu> Yeah, those are particular forms.
20:25:15 <adu> LDU might be better
20:25:25 <adu> LDU is basically eigensystem decomposition
20:25:49 <adnap> Cale: That's something I'm not clear on with programs in haskell.  If you call the same function a bunch of times, is it always recomputing things?
20:25:51 <Cale> LDU
20:25:55 <Cale> oops
20:26:00 <adu> lower-diagonal-upper
20:26:18 <Eduard_Munteanu> How so? I thought SVD gave that.
20:26:27 <Eduard_Munteanu> I mean the eigenvalues.
20:26:32 <adnap> Cale: Also, do you need to resort to IO to save computations?
20:26:38 <adu> I would assume in such a way that (LD)U is Doolittle-style and L(DU) is Crout-style
20:27:00 <byorgey> adnap: yes, and no, respectively.
20:27:11 <Cale> adnap: yes, it's always recomputing functions unless you go out of your way to memoise them
20:27:18 <byorgey> adnap: if you give something a name and then use the name multiple times, it will only be computed once
20:27:57 <Cale> The where clause of a function counts as part of its body, so if you give it different parameters, the things in the where clause will be recomputed.
20:28:19 <adu> Eduard_Munteanu: SVD is an example of LDU
20:28:20 <Cale> (or even the same parameters)
20:28:42 <Cale> I'm not sure I see the equivalence of LDU and eigensystem decomposition.
20:29:23 <adu> perhaps its the other way around
20:29:24 <Cale> (is what I was going to say before)
20:29:46 <adu> PDP^-1 is what i was thinking of
20:29:49 <revenantphx> Okay, so pastorn, that didn't work.
20:29:53 <revenantphx> Overlapping instances error.
20:30:04 <Cale> yeah, LDU has a diagonal matrix in the middle, but that's where the similarities end :)
20:30:09 <adnap> byorgey: What do you mean by a name?  I could consider a function a "name" for a computation.
20:30:35 <adu> ack too many decomps
20:30:46 <Cale> LDU is like LU factorisation, but pulling out some factors from L and U to make the diagonal entries 1
20:31:43 <adu> PDP^-1 is eigensystem decomp
20:31:47 <Cale> (and I don't think the entries of D have much to do with the eigenvalues of the original transformation)
20:31:48 <Cale> yeah
20:31:56 <adnap> I'm not sure I understand how to go about ensuring that things don't get recomputed.
20:32:01 <revenantphx> Anyone have any ideas how I can make this a "unique" type while retaining my ability to use it with string types?
20:32:48 <Cale> adnap: You could write  transform (width:.height:.()) = let ... in \vertex -> ...
20:33:03 <adnap> Cale: So, things in lets get saved?
20:33:18 <ddarius> adnap: And sure enough the -function- is shared.
20:33:25 <adnap> Also, if I define things as "constant" functions, do those get saved?
20:33:32 <Cale> yes
20:33:34 <pastorn> revenantphx: paste the complete code along with the error
20:33:37 <revenantphx> If I newtype it, then I lose access to all of the List functions.
20:33:49 <Cale> adnap: More importantly, the result of applying transform to its first parameter is a function which can be shared.
20:34:10 <Cale> adnap: So when you map that function over a list, the matrices inside it get evaluated once
20:34:19 <revenantphx> http://hpaste.org/41986/custom_encoding
20:34:20 <Cale> and not for each vertex
20:34:36 <pastorn> revenantphx: yep
20:34:36 <adnap> Well, that's what's already happening.
20:34:40 <revenantphx> The instances overlap, simple and clean.
20:34:46 <revenantphx> I just don't know what to do...
20:34:53 <revenantphx> If I newtype string, I lose the List library functions.
20:35:00 <revenantphx> (which are convenient!)
20:35:15 <adnap> I was mapping transform over the PrimitiveStream.
20:35:28 <Cale> adnap: Right, I saw that :)
20:35:42 <pastorn> revenantphx: seriously? just do a Binary instance for MCPacket and be done with it
20:35:51 <pastorn> i can't se any downside to that
20:36:06 <adnap> Cale: So, how is it that I'm recomputing the transform unnecessarily?
20:36:18 <Cale> adnap: Which is why I suggested trying this splitting after the first parameter, because you're partially applying transform there, and it would be good if that partial application could save some work.
20:36:21 <revenantphx> pastorn: rage, I've said I want to do it for the string >_<
20:36:23 <revenantphx> I have my reasons.
20:36:35 <revenantphx> Besides, I have to use that string over and over and over.
20:36:50 <revenantphx> that string encoding/decoding*
20:36:57 <pastorn> revenantphx: so what? you'll only use one function to pack it, then another to unpack it
20:37:05 <revenantphx> Explain what you mean?
20:37:06 <Cale> adnap: Currently, it looks like \(width:.height:.()) -> \vertex -> let modelMat ... ; ... ; vertex' = ... in (vertex', ())
20:37:17 <adnap> Cale: You mean "splitting" width and height?
20:37:32 <adnap> Cale: As in, do that in the function that fmaps?
20:37:33 <Cale> So we want to push the \vertex inside the let/in
20:37:34 <pastorn> revenantphx: there will only be one point in your program which will pack and send an MCPacket and only one which will recieve an MCPacket, right?
20:37:45 <revenantphx> Right.
20:37:55 <pastorn> revenantphx: then all you are seing are non-problems
20:37:56 <revenantphx> well, I don't know yet.
20:38:19 <revenantphx> Let me just get an answer in this regard...
20:38:23 <pastorn> revenantphx: code that runs >> worrysome wallowing
20:38:33 <revenantphx> can I make it so that MCString exists as a synonym to String, that is however unique.
20:38:47 <Cale> So that once the function is applied to its first parameter, it evaluates to a let expression, those things inside the let expression go on the heap, and are shared by applications of the function in the 'in' part of the let.
20:39:25 <pastorn> revenantphx: if you have type A = B and then have an instance of A where you already have an instance of B then haskell won't be able to use your new instance
20:40:36 <adnap> Cale: I've simply removed the split and replaced it with "size".  Originally, the transforms depended on the size though because I was doing a perspective transform.
20:41:11 <revenantphx> pastorn: right.
20:41:19 <revenantphx> Hence the want for something which is not a synonym, but a "clone"
20:41:20 <Eduard_Munteanu> revenantphx: I suppose you could make that a monad to make it difficult to accidentally use in IO
20:41:31 <adnap> Cale: I hope I've understood what you meant.  Unfortunately, this doesn't change the performance.
20:41:42 <Eduard_Munteanu> Oh, I might've totally misunderstood that.
20:41:45 <pastorn> revenantphx: can't do it
20:41:50 <revenantphx> darn :P
20:41:58 <pastorn> revenantphx: but you can with SPECIALIZE
20:42:02 <revenantphx> :O
20:42:20 <pastorn> but i'm not sure how specialize likes typeclasses
20:42:44 <adnap> Cale: Are you saying that because I originally split size, each invocation of transform with fmap results in a recomputation of... something?
20:42:50 <pastorn> but first, write correct functions for your string thingy
20:42:54 <pastorn> (and test)
20:43:01 <Cale> adnap: I mean you need to split the parameters of the lambda and insert the let in between them.
20:43:16 <Eduard_Munteanu> pastorn: didn't it eliminate dictionary passing overhead with typeclasses?
20:43:32 <Cale> adnap: (The where block of course desugars into a let expression)
20:43:33 <Eduard_Munteanu> at least for stuff in the same compilation unit
20:43:54 <pastorn> then, when you have putMCString, i think it's something like {-# SPECIALIZE get :: Get String, getMCString #-}
20:43:55 <adnap> Cale: Yeah, that's what I'm having trouble with.  You understand what it breaks down to.
20:44:08 <Cale> adnap: Another option is to move those definitions out of the definition of the function altogether
20:44:13 <adnap> Cale: Is there a tutorial on this?  How would I even know what the compiler does?
20:44:16 <Cale> (for modelMat, etc.)
20:44:40 <Cale> Well, you could read the STG machine paper...
20:45:05 <Cale> http://www.ncc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
20:45:10 <adnap> I don't know what you mean when you say "insert the let in between them".
20:45:16 <adnap> Especially since I can't see a let!
20:45:19 <revenantphx> pastorn: why the comma?
20:45:36 <pastorn> revenantphx: dude, i was pulling that syntax out of my ass
20:45:39 <pastorn> rtfm
20:45:43 <Cale> adnap: where and let are really the same thing
20:45:44 <revenantphx> It's pretty accurate
20:45:56 <revenantphx> It's just SPECIALIZE <type signature>
20:45:59 <adnap> Cale: Okay, that's reasonable.
20:46:01 <Cale> adnap: It's just that syntactically, where is part of declaration syntax and scopes over guards
20:46:28 <adnap> Cale: Yeah, even though I have none in my function.
20:46:54 <Cale> adnap: So what you currently have looks like  transform = \size vertex -> let modelMat = identity ... in (vertex',())
20:46:55 <adnap> Cale: So, I could reference things from my where with functions that have like | | otherwise etc.
20:47:04 <Cale> yeah
20:47:19 <adnap> Cale: And things in the first part of the let get saved, right?
20:47:50 <pastorn> revenantphx: also: tested your code with Data.ByteString.putStrLn ?
20:48:00 <revenantphx> I'm going to in a second
20:48:01 <Cale> functions are not memoised, and all the work done computing anything on the right hand side of the -> is not shared between invocations of the function
20:48:02 <revenantphx> as soon as it compiles :P
20:48:11 <adnap> Cale: Oh
20:48:13 <Cale> However!
20:48:18 <adnap> Cale: So I need to get the matrices out of the let
20:48:31 <pastorn> revenantphx: don't worry about specialize until you know that your function is correct :)
20:48:32 <Cale> transform = \size -> let modelMat = identity ... in \vertex -> (vertex',())
20:48:37 <Cale> consider this version
20:48:42 <revenantphx> To check I need to compile :P
20:48:45 <Cale> now when we apply transform to a size parameter
20:48:45 <adnap> I see
20:49:06 <adnap> Cale: Yeah, done in the partial application with fmap
20:49:15 <Cale> right
20:49:26 <adnap> Cale: So, we're mapping let modelMat ... in \vertex -> ..
20:49:28 <Cale> that expands to a let expression which shares the definitions of those things
20:49:44 <Cale> between calls to the function that it produces
20:49:59 <adnap> Cale: Yeah, that makes sense.
20:50:28 <adnap> Cale: So, I fail to see what I can optimize since the matrices are shared among vertices.
20:50:40 <revenantphx> just found something about "7.9.8. SPECIALIZE instance pragma"
20:50:41 <Cale> But as you currently have it, they're not
20:50:42 <revenantphx> reading this 0.o
20:50:53 <pastorn> revenantphx: that's the one
20:50:56 <Cale> Only if you push the lambda for vertex inward will it do that.
20:51:00 <revenantphx> that's for instances
20:51:06 <revenantphx> looks promising
20:51:13 <Cale> (inside the let)
20:51:23 <adnap> Cale: What you just said is a little vague.  What do you mean?
20:51:32 <Cale> I mean make it like my example there:
20:51:36 <Cale> transform = \size -> let modelMat = identity ... in \vertex -> (vertex',())
20:51:47 <Cale> See how the parameters to transform are split up now?
20:51:56 <Cale> size is outside the let and vertex is inside
20:52:12 <revenantphx> sadly that doesn't fix it pastorn.
20:52:26 <pastorn> revenantphx: then just make one for the whole message!
20:52:29 <pastorn> srsly bro!
20:52:32 <adnap> Cale: I thought all that was already happening with the compiler.
20:52:40 <pastorn> when do you EVER want to do stuff with an encoded string?
20:52:48 <Cale> To be honest, I'm not sure that this will do anything for performance. The compiler on -O2 does a lot of lifting of constant definitions
20:52:49 <revenantphx> IN LIKE 15 DIFFERENT PACKETS.
20:52:55 <pastorn> lolz
20:52:58 <pastorn> why?
20:53:03 <revenantphx> Because it's there :\
20:53:06 <revenantphx> Why else?
20:53:13 <revenantphx> I need to read the string and use it.
20:53:14 <pastorn> what is it even you're doing? RFC or something pl0x
20:53:17 <adnap> Cale: Are you saying I need to explicitly modify the transform function so that it looks how you've described?
20:53:18 <Cale> However, doing this kind of transformation is risky
20:53:20 <Cale> yes
20:53:22 <revenantphx> No no, just nevermnd.
20:53:32 <revenantphx> I'll handle it, since you're apparently incapable of helping people much.
20:53:37 <Cale> If the compiler did this everywhere, it could really damage the space performance of a lot of programs
20:54:01 <Cale> So it's sometimes a bit conservative about how much it'll lift definitions out.
20:54:02 <pastorn> revenantphx: come on, i want to know what you are doing, do you have some documentation somewhere?
20:54:07 <adnap> Cale: I thought you said that it already did this internally.  I thought you said that the where actually becomes a let that looks how you've described.
20:54:12 <revenantphx> There's no official documentation.
20:54:18 <revenantphx> Private protocol.
20:54:22 <revenantphx> I'm just screwing with it.
20:54:25 <Cale> adnap: It becomes the let that I *first* described
20:54:27 <pastorn> what's it for?
20:54:33 <Cale> adnap: The one with both the lambdas outside the let
20:54:33 <revenantphx> minecraft.
20:54:49 <revenantphx> I need to build a quick bot to screw with my friend.
20:55:02 <adnap> Cale: Ohhh
20:55:26 <revenantphx> pastorn: I warn you, it's terrible
20:55:27 <revenantphx> http://mc.kev009.com/wiki/Protocol
20:55:33 <Cale> adnap: That's the most conservative thing to do memory-wise -- throw away all the local definitions after each application of the function because you don't know if it'll ever be called again, and those take up space.
20:55:34 <revenantphx> It's a horribly written protocol tbh.
20:55:49 <revenantphx> Apparently the author's never heard of framing at all.
20:55:54 <Cale> adnap: But recomputing them is expensive.
20:56:09 <adnap> Cale: So, currently I'm mapping \vertex -> let ...
20:56:16 <Cale> yeah
20:56:20 <adnap> Cale: And those things in the let DON'T get saved.
20:56:24 <Cale> right
20:56:38 <Cale> each time the lambda is applied, they're going to be recomputed
20:56:46 <adnap> Cale: So, I need to move the matrices into the function where I'm applying fmap.
20:57:08 <pastorn> revenantphx: you're doing Chat Message (0x03) ?
20:57:09 <Cale> adnap: You just need to restructure the transform function a bit
20:57:20 <revenantphx> pastorn: 0, 1, and 2
20:57:21 <revenantphx> to start.
20:57:37 <Cale> transform size = let ... in \vertex -> (toGPU ..., ())
20:57:43 <revenantphx> Not dealing with the monstrosity that is packet 5.
20:57:57 <revenantphx> Should be somewhat easy with monads though... anyhow.
20:57:59 <Cale> adnap: It's something to try anyway :)
20:58:00 <adnap> Cale: That is weird.  So there is actually a HUGE difference between let in where in this regard?
20:58:11 <adnap> Cale: *let and where
20:58:16 <revenantphx> I need a routine for each of the basic data types basically.
20:58:17 <revenantphx> "UTF-8 string. Prefixed by a short containing the length of the string"
20:58:25 <Cale> adnap: Well, let can be a little more flexible in that regard...
20:58:44 <adnap> Cale: But let will ensure that my computations get saved.
20:58:48 <Cale> adnap: Actually, you could use where as well...
20:59:02 <adnap> Cale: I could?
20:59:20 <Cale> transform size = \vertex -> (toGPU ..., ()) where ...
20:59:42 <Cale> should work
20:59:54 <Cale> though it's less obvious why you're writing it like that :)
21:00:03 <pastorn> revenantphx: if i wanted to do that i'd do a constructor for each kind of message, then just write a binary instance that one
21:00:08 <Cale> With the let, it's easier to see that you want the let to be in the way :)
21:00:22 <revenantphx> ...what?
21:00:28 <Cale> (if that makes sense)
21:00:29 <revenantphx> I'm trying to define the building blocks and work up from ther.e
21:00:37 <revenantphx> Hence the want for a string action.
21:00:40 <pastorn> revenantphx: maybe two types, data ClientToServer = ... data ServerToClient = ...
21:01:08 <adnap> Cale: Yeah
21:01:38 <Cale> That seems to double performance on my machine
21:01:43 <adnap> Cale: Reallly?
21:01:46 <Cale> So we still have a long way to go
21:01:47 <adnap> Cale: Not weith me
21:01:50 <revenantphx> pastorn: i will later.
21:01:52 <revenantphx> This is a simple test.
21:01:55 <Cale> er, hmm
21:01:58 <revenantphx> To see if I can do this in this style.
21:02:04 <revenantphx> But yeah, that's going to be a necessity of course.
21:02:07 <Cale> actually, unfair comparison, hang on :)
21:02:11 <revenantphx> I've already implemented this in Objective-C.
21:02:13 <adnap> Cale: I have transform size = let ... in \vertex -> toGPU
21:02:17 <revenantphx> (dear god buffer management is terrible XD)
21:02:43 <adnap> Cale: Actually, it's: transform size = let ... in \vertex -> (toGPU ..., ())
21:03:04 <revenantphx> hngh, even the OverlappingInstances extension isn't helping.
21:03:12 <revenantphx> Mine should be more specific and so be ok.
21:03:35 <Cale> Yeah, no, sorry :)
21:03:38 <Cale> hmm
21:03:54 <adnap> Cale: Okay, here's something I'm thinking
21:04:02 <Cale> oh, we really don't want to do those multiplications every time too
21:04:06 <adnap> Cale: GPipe is built on OpenGL, which has an explicit matrix stack.
21:05:15 <adnap> Cale: Why wouldn't it save things like transformations?  Is it that there is no way of knowing that I'm applying the exact same transform?
21:06:40 <Cale> adnap: I don't think the Vec library has anything to do with OpenGL
21:06:43 <Cale> whatsoever
21:06:56 <adnap> Cale: But I'm calling toGPU with the same matrix
21:07:07 <Cale> oh hmm
21:07:27 <Cale> Yeah, there is some interesting typeclass magic here.
21:07:51 <adnap> I could always e-mail the creator!
21:07:58 <pastorn> revenantphx: here you go, after some visual block funny times: http://hpaste.org/41987/minecraftprotocolconstructors
21:08:10 <revenantphx> Oh ah, thanks
21:08:24 <revenantphx> Wait, ampersand in the constructors?
21:08:30 <revenantphx> And why are there slashes in there? D:
21:08:39 <pastorn> revenantphx: i'm too lazy to read all the bullshit and add the stuff that's in each
21:08:47 <revenantphx> figured.
21:08:54 <revenantphx> I didn't really need you to do that.
21:08:57 <pastorn> revenantphx: s/ & /And/g
21:09:01 <revenantphx> I need to get OverlappingInstances to work.
21:09:03 <revenantphx> >_<
21:09:03 <pastorn> revenantphx: took less than a minute
21:09:09 <pastorn> revenantphx: no you don't
21:09:15 <revenantphx> Yar, I do :P
21:09:20 <revenantphx> It's for fun.
21:09:25 <pastorn> seriously, what are youg going to do with an encoded string?
21:09:35 <pastorn> you can't manipulate it in any meaningful way!
21:09:35 <revenantphx> Send it.
21:09:46 <revenantphx> no no, the point is to decode the encoded string into normal haskell string.
21:09:49 <revenantphx> And then have fun with it.
21:09:58 <pastorn> exactly
21:10:04 <revenantphx> Which is what my instance DOES.
21:10:12 <pastorn> as i said, what you have here is a non-problem
21:10:13 <revenantphx> I just need it to override the existing [a] instance.
21:10:27 <revenantphx> It is a problem because it doesn't compile >:|
21:10:53 <pastorn> just make two functions getMCString/putMCString, which does exactly what you want them to do, then use that throughout your code
21:11:12 <revenantphx> ...yeah I could do that.
21:11:17 <revenantphx> But it's not as much fun >_<
21:11:19 <Cale> adnap: Yeah, I just realised that it's kinda scary that it might actually be communcating with the GPU while evaluating the body of that lambda each time?
21:11:25 <revenantphx> I like seeing "iftM3 LoginRequest get get get"
21:11:30 <pastorn> revenantphx: as i said, you don't actually want to do that, what you want to do is implement instances of Binary for those datatypes (once extended)
21:11:32 <revenantphx> It's so purty :3
21:12:08 <Cale> adnap: I have no idea what toGPU actually means
21:12:10 <adnap> Cale: I think GPipe makes shaders on the fly and compiles them.
21:12:26 <revenantphx> I can implement an instance of binary for MCPacket iself though.
21:12:32 <revenantphx> No need to do an individual one for each.
21:12:35 <revenantphx> DRY.
21:12:38 <pastorn> revenantphx: instead you'll have 'liftM4 LoginRequest mcString mcString get get'
21:12:43 <revenantphx> booooh.
21:12:45 <pastorn> *getMCS
21:12:45 <adnap> Cale: GPipe is actually some guy's thesis.  I actually came across the paper he wrote once.  Maybe I could find it again and figure out what's going on.
21:13:09 <revenantphx> Oh, I forgot some fields there XD
21:13:38 <revenantphx> anyways >->
21:13:50 <revenantphx> I can do that yes, but it would be nicer to have an instance on string.
21:13:54 <pastorn> revenantphx: you could do a nice hack
21:13:54 <adnap> Cale: Unfortunately, I don't know very much about graphics hardware or optimization.
21:13:56 <revenantphx> I know it's a non-problem.
21:13:59 <revenantphx> :O
21:14:01 <pastorn> implement your own typeclass
21:14:01 <revenantphx> tell me!
21:14:06 <pastorn> MCBin
21:14:11 <revenantphx> oh shit...
21:14:15 <pastorn> Which has the correct encodings for all your stuff
21:14:26 <revenantphx> Then I break the ability to use it with the existing stuff that uses Binary though :\
21:14:28 <ddarius> The Binary class should only be used when you don't care about the representation.
21:14:29 <pastorn> just rebinding stuff
21:14:53 <adnap> Cale: What kind of fps are you getting on your machine?
21:14:59 <ddarius> It's completely inappropriate to use it for a given wire format.
21:15:01 <revenantphx> ddarius: then what do I use when I do care >_<
21:15:14 <revenantphx> ddarius: then please enlighten me, cause it seems pretty nice so far :P
21:15:20 <Cale> ~27
21:15:40 <ddarius> revenantphx: Your code apparently doesn't compile.  That doesn't seem very nice.
21:15:43 <pastorn> ddarius: i've used the Binary class when i wrote a java class file loader
21:15:46 <pastorn> was pretty sweet
21:15:50 <revenantphx> Well, thats something I can remove which is a non issue.
21:15:58 <revenantphx> Otherwise it does, so the issue is....
21:16:01 <revenantphx> ?
21:16:03 <Cale> adnap: For some reason the .prof file is empty every time I try to run this with profiling.
21:16:22 <ddarius> You should use the combinators in the binary package, just not the class itself.
21:16:49 <revenantphx> ?...
21:17:13 <adnap> Cale: Man, I need to learn how to profile Haskell programs.  I've never had any reason to so far though.  I haven't written any large programs and I've only been programming in Haskell for about 8 months.
21:17:16 <pastorn> revenantphx: look inside Data.Binary.Get and Data.Binary.Put
21:17:30 <pastorn> revenantphx: then use them to make instances for CTSPackage and STCPackage
21:17:39 <Cale> adnap: It's usually pretty easy -- compile with -prof -auto-all and then run the program with +RTS -p
21:18:04 <Cale> adnap: and inspect the resulting foo.prof file to see how much time and allocation each function did
21:18:14 <adnap> Cale: Oh, neato.
21:18:15 <revenantphx> hm :\
21:18:30 <revenantphx> The one nagging issue I've been thinking of this entire time is...
21:18:35 <revenantphx> what if there isn't enough data.
21:18:48 <adnap> Cale: Will that include all the functions called by the functions I'm calling and so on?  How "deep" does it go?
21:19:01 <pastorn> revenantphx: you mean if you don't recieve enough data from the server when it's transmitting?
21:19:02 <revenantphx> One of the largest flaws in this protocol is that for a lot of packets, you can't know the size of a packet until you're done parsing.
21:19:05 <Cale> adnap: It relies on having profiling versions of the libraries installed, which can be a bit annoying (sometimes have to reinstall things with cabal install --reinstall -p foo
21:19:07 <Cale> )
21:19:23 <revenantphx> They're dynamically sized without the total size being prefixed.
21:19:23 <adnap> Cale: I imagine I'm calling a ton of GPipe functions behind the scenes.
21:19:38 <revenantphx> Forces you to be really clever with buffers or rely on blocking reads.
21:19:39 <pastorn> revenantphx: how is that relevant to you?
21:19:54 <pastorn> revenantphx: you'll have blocking reads
21:20:04 <Cale> Well, I think it's just for the modules that go into your executable directly.
21:20:04 <pastorn> also: this is haskell, we don't care about buffers
21:20:14 <Cale> (but the libraries still need to be compiled specially)
21:20:20 <revenantphx> pastorn: true.
21:20:26 <revenantphx> Now, I'm stuck on this till it works.
21:20:32 <revenantphx> I'd like to figure out how to do it :P.
21:20:36 <revenantphx> Even if I won't use it.
21:20:51 <revenantphx> Matching instances:
21:20:51 <revenantphx>       instance (Binary a) => Binary [a] -- Defined in Data.Binary
21:20:52 <revenantphx>       instance [overlap ok] Binary MCString -- Defined at amityhs.hs:9:9-23
21:20:55 <revenantphx> says overlap ok >_<
21:21:13 <revenantphx> And I have OverlappingInstances enabled.
21:27:04 <Cale> adnap: aha, got it
21:27:19 <Cale> adnap: Just needed to add a callback to make the thing exit normally on a keypress
21:27:28 <Cale> Now I can has profile :)
21:27:46 <Cale>     frameBuffer          Main                                                1081          86  95.4   96.3     0.0    0.0
21:27:47 <pastorn> revenantphx: http://hpaste.org/paste/41987/somo_data_added_to_mc_protocol#p41988
21:27:58 <revenantphx> ?....
21:28:03 <revenantphx> Ok, great, thanks?
21:28:23 <pastorn> whoops... still something wrong at line 33
21:28:45 <revenantphx> https://gist.github.com/723008
21:28:49 <revenantphx> this is okay as a compromise....
21:28:53 <Cale> adnap: So ~95% of the time and allocation done in your program is in framebuffer (and not in its children somehow)
21:28:55 <revenantphx> but I still like having 'get' alone :\
21:29:58 <pastorn> revenantphx: that's exactly what i wanted you to do all along
21:30:01 <adnap> Cale: Hm...
21:30:09 <revenantphx> Then help me do it >_<
21:30:10 <adnap> Cale: Painting fragments?
21:30:12 <pastorn> but use my giant data type declarations instead
21:30:19 <pastorn> revenantphx: dude, it's boring stuff :p
21:30:21 <revenantphx> I ant this to work: https://gist.github.com/723013
21:30:22 <adnap> Cale: Does that suggest an issue with GPipe?
21:30:43 <pastorn> revenantphx: but using the datatypes you can probably generate code using some clever search/replace
21:30:59 <revenantphx> ...I'm not following you.
21:31:03 <revenantphx> I just want THAT code to compile.
21:31:28 <revenantphx> If it would recognize that instance (Binary a) => Binary [a] is less specific than instance Binary MCString it'd all be good.
21:31:35 <revenantphx> But apparently it can't figure that out TT_TT
21:31:42 <Cale> adnap: Yeah, I dunno. It doesn't even attribute any time to paintSolid
21:32:08 <Cale> (though, paintSolid is a constant, so perhaps it only counts the time to work out which function it is)
21:32:21 <pastorn> revenantphx: i think you should be using Data.Word.Word8 instead of Int8
21:32:43 <adnap> Cale: What about paintColor?
21:32:45 <revenantphx> Spec says signed.
21:32:46 <revenantphx> :\
21:33:04 <Cale> okay, yeah, if I turn paintSolid into a function binding, it gets all the weight
21:33:10 <adnap> Cale: So, you added a GLUT key callback to close the window on esc or something?
21:33:10 <revenantphx> I mean, the source shows it's pretty much the same, buteh
21:33:12 <pastorn> oh, cool
21:33:17 <Cale> So paintColor is probably the culprit
21:33:22 <revenantphx> Anyways... I'd love to have it compile :)
21:33:43 <adnap> Cale: I need to get profiling working too so I can send this to the GPipe guy.
21:33:45 <Cale> adnap: yeah
21:34:23 <Cale> adnap: I also had to reinstall a lot of libraries with -p
21:34:41 <adnap> Cale: Oh, so you have to explicitly ask cabal for profile versions?
21:34:42 <Cale> keyboardMouseCallback $= Just (\k ks m p -> when (ks == Down) (exitWith ExitSuccess >> return ()))
21:34:49 <Cale> yeah, somehow
21:34:57 <Cale> I think there's a way to set it in your config
21:35:16 <Cale> yeah...
21:35:24 <Cale> library-profiling: True
21:35:35 <Cale> in ~/.cabal/config
21:35:49 <Cale> will ensure that it always installs profiling versions
21:35:49 <adnap> thanks
21:35:54 <lars9> Why the benchmark of K-Nucleotide is so poor for Haskell? on programming language shootout
21:36:01 <lars9> that's the only one poor
21:36:23 <revenantphx> I've come to the conclusion OverlappingInstances just isn't working in ghci.
21:36:24 <revenantphx> :|
21:36:54 <pygmalion> this makes me feel dirty: http://pastie.org/private/ld9goqnuc199oecnjerq is it immediately apparent that i can eliminate some of those cases?
21:37:09 <pastorn> revenantphx: https://gist.github.com/723008 loads perfectly for me
21:37:15 <revenantphx> 0.0
21:37:17 <revenantphx> seriously?
21:37:22 <revenantphx> ghci version?
21:37:29 <pastorn> *Main> encode (KeepAlive)
21:37:31 <revenantphx> Oh
21:37:31 <pastorn> Chunk "\NUL" Empty
21:37:32 <revenantphx> yeah
21:37:35 <revenantphx> that one loads fine.
21:37:50 <revenantphx> try this though
21:37:51 <revenantphx> https://gist.github.com/723008
21:37:52 <revenantphx> not so much.
21:39:40 <mtnviewmark> Yikes - why do that?
21:39:42 <mtnviewmark> the first was better
21:39:59 <revenantphx> I'm just curious if it can be done, it's prettier in execution :\
21:40:03 <mtnviewmark> if you don't want to have a newtype for MCString
21:40:14 <revenantphx> If I newtype it it works...
21:40:21 <revenantphx> except then I can't use string/list functions on MCString
21:40:39 <mtnviewmark> then it is clearer to have explicit get/put for it
21:40:44 <pastorn> revenantphx: just give it up! you won't make this work unless you mess with SPECIALIZE
21:40:50 <revenantphx> SPECIALIZE didn't even fix it!
21:40:51 <pastorn> and what's worse is - YOU DON'T NEED IT
21:40:55 <revenantphx> true ture :P
21:41:01 <pastorn> artard
21:41:23 <revenantphx> no u
21:41:27 <mtnviewmark> I thing think liftM Handshake getMCStr is really clear coding
21:41:43 <mtnviewmark> whereas    lifM Handshake get   leaves you wondering....
21:42:04 <revenantphx> I guess
21:42:08 <pastorn> revenantphx: conisdered Applicative?
21:42:13 <mtnviewmark> ("Hmmm.. it's a String... but did they really mean the default Binary encoding for String? really?)
21:42:24 <ddarius> I don't see what SPECIALIZE has to do with this at all.
21:42:30 <revenantphx> lets just drop that
21:42:37 <revenantphx> I'm using specialized functions, case closed.
21:43:03 <mtnviewmark> a MCString is serialized on the wire as a 16-bit length followed by what? that many 32 values?
21:43:09 <mtnviewmark> 32-bit values?
21:43:14 <pastorn> ddarius: what would be useful would be to overload the the instances of get/put for String
21:43:25 <pygmalion> :r
21:43:26 <ddarius> SPECIALIZE is about performance.  I'm pretty sure it has no effect on type resolution or semantics.
21:43:28 <pygmalion> sorry!
21:43:33 <pastorn> pygmalion: not in here you don't!
21:43:35 <revenantphx> mtnviewmark: UTF-8 characters.
21:43:46 <mtnviewmark> ah - well that code won't do that I don't think
21:43:55 <revenantphx> Char 's get/put say it will do utf-8
21:43:57 <mtnviewmark> not sure, actually
21:43:59 <ddarius> pastorn: Why would that be useful?
21:44:01 <mtnviewmark> ah
21:44:01 <revenantphx> I checked that.
21:44:29 <mtnviewmark> So, the issue is that Binary provides two separate things: a set of nice monads for get/put...
21:44:32 <pastorn> revenantphx: you probably need to convert any strings you have into bytestrings first, to make sure that you have the correct length
21:44:37 <mtnviewmark> ... AND a default set of instances for standard types
21:44:47 <revenantphx> one moment, hold up
21:44:49 <revenantphx> er, in a case statement
21:44:56 <pastorn> revenantphx: consider a string that contains 2-byte characters, then (length str) isn't what you want to do
21:44:57 <mtnviewmark> but that are mostly useless unless you are implementing a protocol purely for use between Haskell processes
21:44:58 <revenantphx> can I do unboxing of types?
21:45:07 <revenantphx> pastorn: this is true.
21:45:55 <mtnviewmark> in most cases where you are trying to implement a protocol (or file format) from some spec (even your own), you've got a particular set of mappings for the standard types for that protocol/format ---
21:46:07 <revenantphx> Right.
21:46:15 <mtnviewmark> So, String in DNS, for example, serializes differently than a String in HTTP
21:46:28 <mtnviewmark> Binary doesn't quite support this case
21:46:42 <ddarius> The Binary class isn't intended to support this case.
21:46:56 <mtnviewmark> attoparsec might be better suited, but I like the dual get/put defined together nature of Binary
21:47:05 <revenantphx> yeah, thats my thoughts
21:47:11 <revenantphx> one quick thing
21:47:23 <magicman> Isn't it still possible to construct Get and Put values and manually use the appropriate run functions for them?
21:47:23 <revenantphx> Is there any way to get output from encode (bytestring) to show... hex?
21:47:27 <mtnviewmark> perhaps something inspired by that Haskell Symposium paper on dual paser/formatter systems... but applied to attoparsec would be nice
21:47:29 <magicman> Are those run functions exposed?
21:47:30 <revenantphx> Instead of a string.
21:47:37 * magicman looks.
21:47:45 <mtnviewmark> magicman - yeah, that's what I do when I use Binary (or Cerial)
21:48:12 <revenantphx> hey, guys
21:48:24 <magicman> Right.
21:48:28 <revenantphx> print ByteString as hex how?
21:49:07 <ddarius> I believe there's a ByteString concatMap.
21:49:17 <ddarius> That would probably be the easiest, most efficient way.
21:49:45 <revenantphx> yep there is.
21:49:50 <revenantphx> How would I map it?
21:50:06 <revenantphx> or rather, what would I map
21:50:34 <pastorn> revenantphx: there's a showHex
21:50:48 <revenantphx> where/
21:50:52 <pastorn> hoogle it
21:50:56 <revenantphx> @hoogle showHex
21:52:02 <mtnviewmark> for example... that uses Binary... here's a encoder/decoder for the LLSD binary wire protocol: http://hg.secondlife.com/llsd/src/ab26307d0db8/haskell/Network/Format/LLSD/Binary.hs
21:52:22 <revenantphx> LLSD?
21:52:53 <revenantphx> anyways cool, ill bookmark that
21:53:07 <revenantphx> So er, not having any luck with showHex
21:53:23 <revenantphx> it returns HowS
21:53:25 <revenantphx> ShowS*
21:53:27 <mtnviewmark> LLSD is a structured data interchange format used by virtual worlds
21:53:51 <revenantphx> guess: Linden Labs Structured Data
21:54:56 <mtnviewmark> :-)
21:55:16 <adu> mtnviewmark: sounds fun
21:55:19 <revenantphx> Trying to put together concatMap, showHex, encode ...
21:55:23 <revenantphx> blergh
21:55:30 <Kaidelong> @instances MonadPlus
21:55:32 <FunctorSalad> long lsd is loooooooong
21:55:38 <mtnviewmark> when we put it before the IETF, we took out the company name - and just left it being called "LLSD", with no explaination given in the draft
21:56:11 <mtnviewmark> "like, man, I was trippin' for DAYS!!!!"
21:56:19 <adu> mtnviewmark: also sounds like VOS and metaverse
21:57:30 <adu> mtnviewmark: don't tell me you've never heard of them
21:57:47 * mtnviewmark used to work at Linden Lab....
21:57:58 * mtnviewmark has heard of them....
21:58:01 <revenantphx> blargggh
21:58:08 <adu> :)
21:58:15 <revenantphx> cant figure out how to print byte string as hex
21:58:22 <revenantphx> trying concatMap (flip showHex) (encode (Handshake "hello"))
21:58:23 <mtnviewmark> what are you trying to do, revenantphx
21:58:25 <lars9> any haskeller on twitter? let me follow please :)
21:58:28 <adu> revenantphx: interesting
21:58:32 <revenantphx> convert string to hex >+<
21:58:40 <adu> lars9: what's twitter?
21:58:53 <copumpkin> lars9: lots! check my list on http://twitter.com/#!/copumpkin/lists/haskell
21:59:01 <copumpkin> or actually dons has an even more complete list I think
21:59:09 <pastorn> adu: it's something young people use... ignore him
21:59:10 <lars9> adu: tweeting twitter
21:59:14 <mtnviewmark> like   hex :: ByteString -> String
21:59:25 <mtnviewmark> where you have two characters for each byte, that is what you want?
21:59:32 <adu> pastorn: :)
21:59:33 <lars9> copumpkin: i can not find dons' twitter
21:59:39 <copumpkin> lars9: donsbot
21:59:53 <lars9> copumpkin: wow
21:59:59 <revenantphx> shoul be concatMap (flip showHex "") (encode (Handshake "hello"))
22:00:00 <revenantphx> I think
22:00:02 <revenantphx> but it doesnt work
22:00:22 <revenantphx> flip showHex "" :: (Integral a) => a -> String which is what I want
22:00:44 <magicman> You need to turn that String into another ByteString again for it to work with concatMap.
22:00:49 <Kaidelong> are there any instances of MonadPlus where m+ is commutative?
22:01:02 <magicman> At least, for the ByteString version of concatMap, which you are using :)
22:01:04 <mtnviewmark> :info showHex
22:01:07 <revenantphx> adsfadsads
22:01:13 <revenantphx> I just want to convert byteString to hex!
22:01:18 <revenantphx> string of hex
22:01:24 <revenantphx> like 00 01 00 00 0a 0b
22:01:24 <revenantphx> etc
22:01:47 <mtnviewmark> right - so you can't just Bytestring.Map because you want to change the form along the way
22:02:08 <magicman> pack . flip showHex "" -- try this, instead of just flip showHex ""
22:03:02 <mtnviewmark> So do a foldl
22:03:10 <magicman> foldl is the new barrel roll.
22:03:18 <copumpkin> lars9: wow?
22:04:05 <mtnviewmark> foldr (\b s -> showHex b ++ s) []  (encode (Handshake "hello"))
22:04:24 <mtnviewmark> where is showHex from?
22:04:26 <lars9> copumpkin: the 'good' wow, not warcraft wow
22:04:33 <mtnviewmark> actually, in this case foldr is what you want I think
22:04:45 <magicman> showHex :: Integral a => a -> ShowS
22:04:53 <Kaidelong> gasp!
22:04:59 <mtnviewmark> which lib is that in?
22:05:00 <Kaidelong> where is lambdabot? =(
22:05:01 <copumpkin> lars9: ah :) yeah, most of the people I follow are from the haskell community (and adjacent ones) and there's plenty of interesting things
22:05:19 <revenantphx> that fails mtnviewmark
22:05:22 <magicman> base. In the Numeric module.
22:05:41 <revenantphx> the problem is showHex returns a function that appends.
22:05:43 <lars9> copumpkin: great
22:05:55 <magicman> prepends
22:06:01 <revenantphx> oh right
22:06:02 <revenantphx> I dunno thne
22:06:04 <magicman> "foldr showHex"
22:06:06 <revenantphx> I'm tired :|
22:06:08 <magicman> That should work.
22:06:11 <magicman> Hopefully <_<
22:06:14 <magicman> >_>
22:06:20 <mtnviewmark> Data.ByteString.foldr showHex []
22:06:23 <mtnviewmark> that is what you want
22:06:24 <revenantphx>     Couldn't match expected type `String'
22:06:24 <revenantphx>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
22:06:29 <revenantphx> anyways, im gonna go to sleep.
22:06:35 <mtnviewmark> no no
22:06:37 <mtnviewmark> that is it 
22:06:40 <mtnviewmark> I have it runnign
22:06:54 <revenantphx> Anyways,
22:07:01 <magicman> Yeah, you want the ByteString version of foldr, not the list version :)
22:07:01 <revenantphx> do you recommend I use binary or attoparsec?
22:07:05 <magicman> G'night, though :)
22:07:43 * ddarius wonders at the topology of the space of programming language communities.
22:07:55 <revenantphx> It seems like attoparsec is a bit overkill to me :P
22:08:05 <revenantphx> I almost never want by-character work.
22:08:20 <revenantphx> anyways
22:08:21 <revenantphx> gnight
22:08:27 <mtnviewmark> > Data.ByteString.foldr showHex [] (Data.ByteString.pack [91, 95, 102, 102])
22:09:10 <copumpkin> ddarius: I started having fun plotting the twitter view of it, before I quit grad school
22:09:23 <revenantphx> "10000000568656c6c6f"
22:09:25 <revenantphx> awesome :A
22:09:40 <copumpkin> ddarius: as you probably remember, actually :)
22:09:49 <mtnviewmark> mind you - showHex sucks.... as it doesn't always do the same size 
22:10:27 <mtnviewmark> > showHex 5
22:10:35 <mtnviewmark> yields "5" not "05"
22:10:40 <mtnviewmark> or "0005"
22:10:42 <revenantphx> night then
22:10:45 <mtnviewmark> laters
22:11:07 <copumpkin> why not use printf?
22:11:20 <copumpkin> > printf "%02x" 5 :: String
22:11:29 <copumpkin> :(
22:12:06 <mtnviewmark> I think you've answerd your own question there
22:12:55 <FunctorSalad> did he? lambdabot absence doesn't seem like a good reason ;)
22:13:24 <mtnviewmark> oh - just saying that it is sort of ugly 
22:13:25 * Kaidelong has come to the conclusion that there isn't a commutative mplus out there by default
22:13:49 <mtnviewmark> showHexPadded :: (Integral a) => Int -> a -> ShowS
22:13:54 <mtnviewmark> that would be SO useful
22:14:04 <mtnviewmark> would make r's problem be simple
22:14:21 <mtnviewmark> B.foldr (showHexPadded 2) [] someBinaryThing
22:14:35 <FunctorSalad> you can easily define it in terms of printf :p
22:14:51 <FunctorSalad> sorry I'm a bit of a printf(-th) fanboy
22:15:03 <mtnviewmark> yes, yes you are!
22:16:19 <copumpkin> Kaidelong: probably not, and the only one I can think of that would fit would be data Const a = Const
22:16:23 <Kaidelong> variadic functions make me cry when I see people put them in libraries
22:16:59 <FunctorSalad> :t ghci> :t printf
22:16:59 <FunctorSalad> printf :: String -> ExpQ
22:17:04 <Kaidelong> copumpkin: that makes sense
22:17:09 <FunctorSalad> not variadic ;)
22:17:23 <copumpkin> Kaidelong: it seems like a commutative one would need to "merge" the "payloads" of the two operands in some way, but since they're universally quantified, it has no information to do so
22:17:29 <Kaidelong> well Graphics.Rendering.Plot.Simple has a variadic function in it
22:18:31 <Kaidelong> copumpkin: so in haskell there are no commutative data structures that work on any type, other than points that only hold a single value of the type?
22:18:56 <copumpkin> Kaidelong: "any type" could include functions, hyperfunctions, or empty types
22:19:02 <copumpkin> it seems pretty hard to know what to do with all of them
22:19:32 <FunctorSalad> hyperfunctions? :o
22:19:54 <copumpkin> something like newtype F a b = F b a -> b
22:19:57 <copumpkin> I've heard it called that
22:20:08 <FunctorSalad> hmm
22:20:13 <copumpkin> strange things with negative recursion
22:20:20 * ddarius often uses variadic functions for binders.
22:20:35 <Kaidelong> unrelated to hypercomputing I hope
22:21:40 <lars9> this lines are too long, any suggestions on formating? http://hpaste.org/41991/longline
22:22:43 <Kaidelong> put stuff under the = signs, indented
22:22:57 <Kaidelong> and for the data decl, align the | with the =
22:23:39 <lars9> Kaidelong: lemme try
22:23:41 <copumpkin> long line is long
22:23:46 <copumpkin> FunctorSalad: amirite?
22:23:52 <Kaidelong> if omnibranch is too long too you could put deriving on a new line, indented
22:25:50 <FunctorSalad> copumpkin: very. http://en.wikipedia.org/wiki/Long_line_%28topology%29
22:26:03 <copumpkin> oh I love that article
22:26:47 <FunctorSalad> yeah, especially "but much longer."
22:31:40 <lars9> it works for data delcaration, but put =xxxx in second line make code messier
22:48:24 <adnap> I'm trying to install packages with profiling libraries, and when I try to install one in particular, cabal always gives me another that I need.  Ultimately, it tells me that I need profiling libraries for "base", and when I try that, it says it's "impossible".
22:55:21 <adnap> Ah, it looks like I have to get ghc from my package manager with profiling enabled.
22:58:56 <lispy1> adnap: specifying constraints on base is broken as a "feature"
22:59:21 <lispy1> adnap: but yeah, it sounds like you just need to use your package manager to get the profiling libs for the basic install.
22:59:53 <adnap> lispy1: I've got it figured out now.  The only annoyance is that I try to tell cabal to install something with profiling, and then it spends a bunch of time compiling shit, only to tell me that I first need profiling for something else.
23:00:20 <adnap> lispy1: Is there a way to make it just auto-install anything it might complain about?
23:00:39 <lispy1> adnap: nope, I think that's been requested
23:00:46 <adnap> lispy1: Okay
23:01:00 <adnap> lispy1: Also, why does it have to compile from scratch when a compile fails initially?
23:01:03 <lispy1> adnap: you might check here: http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
23:01:36 <lispy1> adnap: I'm not sure how that part works.  I feel like I've seen it not start from scratch and that I've had it start from scratch other times.
23:02:01 <adnap> lispy1: Hm... mine always starts with [1 of X].
23:02:09 <adnap> lispy1: Ah well
23:02:17 <lispy1> adnap: oh
23:02:20 <adnap> lispy1: Give it like 10 minutes and I'll probably finally have what I want.
23:02:31 <lispy1> adnap: I thought you meant starting from scratch with the dependencies.
23:02:35 <ajnsit> how can I use the (.) operator in a module that also imports Control.Category?
23:02:36 <ajnsit> ghci gives me "ambiguous occurance"
23:03:00 <lispy1> ajnsit: Well, you could give the full name
23:03:13 <lispy1> ajnsit: but, I don't think GHCI supports qualified imports
23:03:37 <mtnviewmark> adnap - it recompiles because it reconfigures
23:03:42 <L29Ah> ghc7 does
23:03:44 <adnap> oh
23:03:53 <mtnviewmark> since the package "landscape" has changed, it does a configure -- 
23:04:07 <mtnviewmark> and it doesn't attempt to save intermediates across a configure
23:04:25 <adnap> And there's no way to tell in advance that a certain package will be necessary before it starts the install.
23:04:40 <mtnviewmark> no - there is
23:04:49 <adnap> mtnviewmark: How is that?
23:05:04 <mtnviewmark> the problem is there is no way for it to know that a library that is installed *doesn't* have profiling versions
23:05:16 <adnap> mtnviewmark: Right
23:05:26 <adnap> mtnviewmark: And why not?  That's annoying.
23:05:30 <mtnviewmark> so - it says "okaydokie A depends on B, and B is installed ... configure A and build.... DANG link failed"
23:05:42 <lispy1> adnap: cabal trusts/uses ghc's package database
23:05:56 <adnap> Why doesn't ghc's package database maintain more information then?
23:05:57 <mtnviewmark> so then you *reinstall* B to have profiling --- and now it sees that A's package landscape has changed
23:06:09 <mtnviewmark> it is a known problem with the ghc-pkg database -
23:06:21 <adnap> oh
23:06:21 <mtnviewmark> it doesn't track profiling libs
23:06:28 <mtnviewmark> that will change in the nearish future
23:06:32 <adnap> woo
23:06:36 <mtnviewmark> and *then* cabal can get smarter about this
23:06:44 <lispy1> IMO, someone could make a package management system on top of cabal.  People are just afraid to :)
23:06:46 <adnap> I did notice that the haskell site got sexier.
23:06:50 <adnap> That's some progress.
23:06:55 <adnap> lol
23:07:40 <adnap> lispy1: I don't know if I'm in favor of that.
23:08:05 <adnap> lispy1: Unless people are willing to abandon it later for the sake of cleanliness.
23:08:30 <adnap> Is cabal built on top of anything?
23:09:07 <mtnviewmark> ghc-pkg
23:09:26 <mtnviewmark> well - and whatever other compilers use for pkg-management
23:09:27 <adnap> Oh, I've never installed anything with ghc-pkg.
23:09:41 <adnap> I've only used it to remove things and check what I have installed.
23:09:52 <lispy1> adnap: well, I would like if cabal knew which haskell binaries i had installed and if my packages had profiled versions or not.  Or which configuration options I built them with.
23:10:02 <adnap> lispy1: me too
23:10:41 <ajnsit> lispy1, sorry I got disconnected, did you answer my question?
23:10:42 <lispy1> Some people have suggested that cabal should do nix style package management, but I haven't studied nix
23:11:09 <lispy1> (2010-11-30 23:02:33) lispy1: ajnsit: Well, you could give the full name
23:11:10 <lispy1> (2010-11-30 23:02:47) lispy1: ajnsit: but, I don't think GHCI supports qualified imports
23:11:26 <adnap> You could almost right a simple script on top of cabal for certain things like this.
23:11:29 <adnap> *write
23:11:43 <ajnsit> I even tried "Prelude.(.)" but even that doesn't work
23:11:48 <adnap> Just snag the string that cabal gives you and issue another command.
23:11:48 <ajnsit> it gives a syntax error
23:12:21 <Cale> ajnsit: It would be (Prelude..)
23:12:25 <Cale> (awkwardly)
23:12:32 <mtnviewmark> well, see, cabal doesn't really manage packages
23:12:48 <ajnsit> Cale, ah thanks Cale
23:12:56 <mtnviewmark> cabal is a uniform interface to configuring and building packages --- but managing the installed packages is left to the compiler/tool-chain
23:12:56 <lispy1> cabal is awkwardly positioned.  It's not a package manager and it's not a build system.
23:13:15 <Cale> ajnsit: Probably best to try to avoid the Prelude's (.) operator if you're importing Control.Category though.
23:13:28 <Cale> ajnsit: You can  import Prelude hiding ((.))   to do that.
23:14:02 <Cale> (The one in Control.Category is a generalisation of function composition anyway)
23:14:10 <pastorn> ajnsit: you'll also want to hide 'id'
23:14:12 <adnap> Cale: I'm installing all the packages with profiling libs that I suppose you had to install a while ago.
23:14:18 <adnap> Cale: There's so many!
23:14:19 <lispy1> mtnviewmark: yes, I was thinking cabal should probably delegate to some special (to be written tool) for guidance with its install plans.  This hypothetical tool could then look through OS package managers to see what libraries are available and etc.
23:14:26 <Cale> adnap: yeah
23:15:05 <adnap> Cale: Plus, did you already have all of the opengl libraries and mesa and such?
23:15:08 <Cale> adnap: Make sure when you install Vec to specify 0.9.7 as well. If you're installing QuickCheck-2.1.something for it then you probably got Vec-0.9.8
23:15:14 <adnap> Cale: I did that already.
23:15:15 <Cale> Yeah.
23:15:15 <ajnsit> pastorn, yeah but I was having the most trouble with (.)
23:15:27 <ajnsit> It is also incredibly hard to google for!
23:15:59 <pastorn> ajnsit: hehe :
23:16:00 <pastorn> :)
23:18:11 <adnap> Oh crap
23:18:34 <adnap> Cale: Why do I get all these "ambiguous occurences" when I try to compile with profiling, but not ordinarily?
23:18:56 <adnap> Cale: It's like all of this stuff in Vec is also in GPipe or something.
23:19:13 <adnap> Cale: I'm seeing stuff like Graphics.GPipe.Vec4
23:19:31 <adnap> Cale: I guess it exports a bunch of stuff for convenience or something?
23:19:39 <pastorn> adnap: it does
23:19:52 <adnap> pastorn: whyyyy  that's so awful
23:20:15 <pastorn> well, if you like 50 lines of import statements, then so be it
23:20:23 <adnap> I do
23:20:25 <adnap> :)
23:20:30 <pastorn> you can state those import lines as well, it doesn't matter
23:20:51 <pastorn> if it's the same functions/types and you take different paths to it, it won't create conflicts :)
23:20:59 <adnap> But surely I can get this to compile without changing my code, since it somehow magically knows how to distinguish these two things when I compile normally.
23:23:39 <Chaze> i'm a little lost: takeWhile "unique"
23:23:45 <adnap> Cale: Did you end up importing Vec as qualifed?
23:23:49 <Chaze> kinda like nub, but working on infinite lists
23:25:44 <ddarius> nub works on infinite lists
23:27:23 <Chaze> yeah, but i don't exactly want nub
23:27:42 <Chaze> i want to take elements, until i pick out one element, that i took out before
23:28:49 <ddarius> If your elements are ordered, the easiest thing would probably be a fold with a set.
23:28:55 <pastorn> Chaze: use Data.Set, adding each element you find and check in the Set at each iteration
23:28:58 <McManiaC> yeah! new wiki layout :)
23:37:01 <magicman> > foldr (\x xs -> x : takeWhile (/=x) xs) [1,2,3,4,5,1,6,7,8,10,4]
23:39:23 <magicman> Erp, but with more []
23:46:27 <Chaze> magicman: doesn't work with infinite lists i guess
23:50:38 <magicman> Example list?
23:51:05 <magicman> I tried it with [1..] and cycle [1..5], and it worked fine.
23:51:24 <Chaze> weird, it does in fact work
23:51:26 <Chaze> i don't get why
23:51:51 <magicman> That is essentially the same as:
23:52:17 <magicman> f list = case list of { [] -> []; (x:xs) -> x : takeWhile (/=x) f xs}
23:52:38 <magicman> So no matter the input, it produces at least *some* output.
23:52:49 <magicman> [] for the empty list, and x:<stuff> for a nonempty list.
23:53:22 <magicman> ... except with more parentheses >_>
23:53:26 <magicman> I fail at typing today v_v
23:53:42 <magicman> "takeWhile (/=x) (f xs)" <- that <_<
23:54:30 <magicman> You understand why takeWhile works for infinite lists?
