00:00:15 <Schalken> pelotom: So newtype Nat = [Word8]?
00:00:16 <pelotom> make a newtype based on that and then go to town
00:00:50 <pelotom> this may have been done by someone already, I'd look around
00:01:51 <Schalken> pelotom: So the question I then have is: Is this the most efficient implementation of an unsigned unbounded integer? Is it indeed the way Integer is implemented underneath?
00:02:51 <pelotom> Schalken: that is something I'm not qualified to answer :)
00:04:09 <pelotom> actually, probably [Word32] or [Word64] might be the best choice, depending on how much you care about the footprint of small values
00:04:44 <pelotom> and maybe you want to use an array instead of a list
00:04:54 <pelotom> but again this is all speculation on my part :)
00:08:17 <Schalken> pelotom: I guess these are all the questions I was hoping to have answered, unless there is an unbound natural number type somewhere that is already as fast as it can be (which was my original question I guess) :P
00:09:27 <pelotom> Schalken: sorry I can't be more helpful
00:09:44 <Schalken> pelotom: Thanks for your help.
00:15:12 <sm> yay, new game code to look at
00:15:21 <sm> http://joyridelabs.de/game/code/
00:15:48 <Saizan> Schalken: in ghc Integer is implemented through the GMP library, it also exposes a natural type i think copumpkin is working on binding that too
00:15:56 <Saizan> @src Integer
00:15:56 <lambdabot> data Integer = S# Int#
00:15:56 <lambdabot>              | J# Int# ByteArray#
00:16:27 <Saizan> quite lower level than a list or an array of word8
00:16:49 <ClaudiusMaximus> there is also http://hackage.haskell.org/packages/archive/Crypto/latest/doc/html/Data-LargeWord.html (up to Word256 but should be possible to increase it, though last time i checked it was missing some useful functions)
00:16:59 <Saizan> a [WordN] is extremely space inefficient
00:18:13 <Saizan> Schalken: the easiest route is probably to make a newtype over Integer, and expose only safe functions
00:18:17 <ClaudiusMaximus> eg, the Num instance for LargeWord only defines (+) and fromInteger
00:19:28 <Schalken> ClaudiusMaximus: Isn't that illegal?
00:19:55 <Schalken> ClaudiusMaximus: Surely you have to define all methods to instantiate a class?
00:20:09 <Axman6> nope
00:20:26 <Axman6> it'll complain, but since you can make anything = undefined, it doesn't make much sense to enforce it
00:20:51 <pelotom> Axman6: he's trying to make something that can't throw exceptions at runtime
00:22:43 <Axman6> well, Integer seems to be what he wants
00:23:06 <Jonno_FTW> when should I use Int over Integer in haskell?
00:23:27 <pelotom> use coq, which has a built-in nat type, and then extract to haskell ;)
00:23:54 <Axman6> Jonno_FTW: when you know you won't need more than 2^{32,64} values, and when you need speed
00:24:08 <Schalken> Jonno_FTW: When you care about efficiency more than totality.
00:24:41 <Saizan> module Natural (Nat, add, fromWord64, ..) where newtype Nat = Nat Integer; add (Nat n) (Nat m) = Nat $ n + m; fromWord64 w = Nat $ fromIntegral w; ...
00:24:58 <Jonno_FTW> > 2^ 65 :: Int
00:24:59 <lambdabot>   0
00:25:07 <Saizan> then you've to decide what to do with subtract :)
00:25:23 <Jonno_FTW> why would it return 0 and not an error?
00:25:40 <Axman6> sub (Nat a) (Nat m) = Nat $ max (n-m) 0
00:25:44 <Axman6> uh, that a should be n
00:25:49 <pelotom> just make any operation that goes below zero wrap around... you'll get the semantics of an unsigned int in C :)
00:25:50 <arcatan> it doesn't check bounds, it just overflows
00:25:57 <Saizan> Jonno_FTW: checking for overflow would probably defeat the performance point
00:26:07 <Jonno_FTW> hmm
00:26:15 <Axman6> pelotom: wrapping around doesn't make much sense when using unbounded numbers...
00:26:26 <pelotom> ah right, unbounded
00:26:34 <pelotom> forgot about that
00:26:38 <Axman6> > 2^130
00:26:39 <lambdabot>   1361129467683753853853498429727072845824
00:26:43 <Axman6> > 2^1300
00:26:44 <lambdabot>   218270158179048338634576816030122467154780744523798645158845871038736274495...
00:26:45 <Axman6> >_>
00:26:46 <Jonno_FTW> > 2^ 65 :: Integer
00:26:47 <lambdabot>   36893488147419103232
00:27:06 <pelotom> 2^2^2
00:27:09 <pelotom> > 2^2^2
00:27:10 <lambdabot>   16
00:28:02 <Axman6> > a^7
00:28:03 <lambdabot>   a * a * (a * a) * (a * a * a)
00:28:28 <pelotom> zuh?
00:28:36 <Axman6> > a^13
00:28:37 <lambdabot>   a * a * (a * a) * (a * a * (a * a)) * (a * a * (a * a) * a)
00:28:42 <pelotom> :t a
00:28:43 <lambdabot> Expr
00:28:45 <Axman6> @src (^)
00:28:45 <lambdabot> x ^ 0            =  1
00:28:45 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
00:28:45 <lambdabot>   where f _ 0 y = y
00:28:45 <lambdabot>         f x n y = g x n
00:28:45 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
00:28:47 <lambdabot>                       | otherwise = f x (n-1) (x*y)
00:28:49 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
00:29:47 <TryingToLearnHas> hello
00:30:06 <kfish> hello TryingToLearnHas! kell!
00:30:12 <guest2425> hello
00:30:17 <guest2425> I have a question
00:30:33 <pelotom> congratulations! you're the 2425th guest!
00:30:57 <Axman6> guest2425: ask away
00:30:58 <guest2425> pelotom: thank you
00:31:18 <guest2425> Axman6: huh
00:31:35 <Axman6> what's your question?
00:31:40 <guest2425> I have a question
00:31:50 <guest2425> but is very long
00:32:34 <guest2425> i need to write the following
00:32:36 <guest2425>   -- Terminate if there are no children or if the goal is one of the children.
00:32:50 <guest2425> I have this   (\ (Node _ children) ->  null)
00:32:55 <pelotom> guest2425: paste big stuff at http://hpaste.org
00:33:03 <pelotom> and then give us the link
00:33:32 <guest2425> how i do the this part or if the goal is one of the children.?
00:34:33 <guest2425> pelotom: I been working but I am stuck 
00:34:42 <cheater99> it depends on how your data structure works
00:34:48 <pelotom> guest2425: we need more context to help you
00:35:00 <guest2425> ok
00:35:33 <cheater99> for example: > 2 `elem` [1, 2, 8]
00:35:33 <cheater99> True
00:37:07 <pelotom> guest2425: can you post more complete code at http://hpaste.org?
00:37:29 <Axman6> s/complete/relevant parts of/
00:37:35 <guest2425> ok
00:38:25 <guest2425> pelotom: is very long http://hpaste.org/41341/question
00:38:59 <guest2425> I need to add this or if the goal is one of the children
00:39:10 <guest2425> pelotom: I need to add this or if the goal is one of the children
00:40:05 <pelotom> guest2425: ok, you left out the most relevant thing which is the data structure
00:40:18 <guest2425> ok
00:40:58 <guest2425> pelotom: dont understand
00:41:22 <guest2425> what you mean
00:41:25 <pelotom> guest2425: where is the definition for the tree?
00:41:39 <pelotom> data Tree = ...
00:42:05 <guest2425> this data Tree  a = EmptyTree | Node a  [Tree a]  deriving (Show, Read, Eq)	
00:42:44 <pelotom> guest2425: ok, so "EmptyTree" is the leaf constructor
00:42:44 <guest2425> pelotom : data Tree  a = EmptyTree | Node a  [Tree a]  deriving (Show, Read, Eq)	
00:42:51 <guest2425> yes
00:43:20 * Axman6 would call Node x [] the leaf, and EmptyTree should only ever appear if the tree is empty, but ok
00:44:08 <pelotom> guest2425: so you want to add an equation matching the EmptyTree and one matching an empty list of children
00:44:09 <guest2425> Axman6: I need to take care of the empty trees as well
00:44:37 <TryingToLearnHas> I have a question:  #41342
00:44:55 <Axman6> that looks like a number to me :\
00:45:33 <guest2425> TryingToLearnHas: copy the link
00:45:40 <guest2425> not just the the number
00:45:55 <guest2425> Axman6: correct?
00:46:00 <Axman6> yup
00:46:18 <TryingToLearnHas> o : http://hpaste.org/41342/mapreduce
00:46:21 <guest2425> Axman6: he or she is new
00:46:38 <TryingToLearnHas> thanks
00:46:59 <pelotom> looks like you guys are doing the same assignment ;)
00:47:21 <guest2425> pelotom: not that I know
00:47:29 <Axman6> heh, more of you. we've had about 10 people in the ladst month looking for help with this assignment
00:47:55 <guest2425> Axman6: is crazy
00:47:59 <TryingToLearnHas> haha its gaining popularity
00:48:18 <guest2425> pelotom: what do you suggest?
00:48:50 <pelotom> guest2425: what specifically are you having trouble with?
00:48:51 <Axman6> whoever wrote that "mapReduce" function needs to be shot, it's horrible
00:49:06 <TryingToLearnHas> my prof.
00:49:17 <TryingToLearnHas> if u want to go ahead
00:49:20 <pelotom> guest2425: the termCond argument?
00:49:22 <Axman6> well, his code's ugly
00:49:28 <guest2425> yes
00:49:50 <pelotom> guest2425: so can you read the type so you know what's expected there?
00:49:57 <guest2425> ok
00:50:01 <guest2425> pelotom:
00:50:28 <guest2425> pelotom: but I dont know how to catch this part --or if the goal is one of the children.
00:51:34 <pelotom> guest2425: so the type of termCond must be "a -> Bool"
00:51:38 <guest2425> pelotom: I have this  (\ (Node _ children) ->  null) which only will check  this part  Terminate if there are no children
00:51:42 <guest2425> yes
00:52:08 <guest2425> pelotom: (\ (Node _ children) ->  null) :: Tree t -> [a] -> Bool
00:52:28 <TryingToLearnHas> how about this written by the same prof:   http://hpaste.org/paste/41342/recursionengine#p41343
00:52:43 <guest2425> pelotom: is that all what I need?
00:53:00 <pelotom> guest2425: that will check that the tree's children are empty
00:53:17 <guest2425> ok
00:53:34 <guest2425> how can i do this part or if the goal is one of the children.
00:53:35 <pelotom> guest2425: so the second part is to see if the children contain the goal
00:53:40 <guest2425> yes
00:53:55 <pelotom> guest2425: write a function which searches for the goal in the children
00:54:17 <guest2425> outside that main function
00:54:18 <guest2425> ?
00:54:21 <pelotom> or just use a built-in one
00:54:37 <guest2425> like search
00:54:40 <pelotom> or using "let" or "where"
00:54:47 <pelotom> :t find
00:54:48 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
00:55:13 <pelotom> :t elem
00:55:14 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
00:55:21 <pelotom> that might be what you want ;)
00:56:09 <Axman6> TryingToLearnHas: yeah, it's pretty bad too. probably aimed to make it easier for begineers, but i'd rather it was easier to read than be so long that you get lost in it
00:57:22 <guest2425> pelotom: like this  (\ (Node _ children) -> null || children  `elem` graph ) like that 
00:57:53 <guest2425> TryingToLearnHas: wrong class wrong professor man sorry 
00:58:47 <pelotom> guest2425: that doesn't look like it would type check to me... what's "graph"?
00:59:05 <TryingToLearnHas> <guest2425> remember  'elem' takes 2 args
00:59:09 <pelotom> you need to provide an argument to 'null'
01:00:37 <guest2425> (\ (Node _ children) -> children -> null || children  `elem` ??? )
01:00:49 <guest2425> pelotom: (\ (Node _ children) -> children -> null || children  `elem` ??? )
01:01:44 <pelotom> guest2425: (\(Node _ children) -> null children || goal  `elem` children )
01:01:58 <pelotom> you want to search for the goal amongst the children
01:02:03 <guest2425> ok thank you
01:03:02 <pelotom> guest2425: I highly recommend you try compiling this stuff as you go instead of just guessing
01:03:08 <pelotom> the compiler will help you out a lot
01:03:15 <guest2425> ok
01:03:19 <guest2425> pelotom:
01:03:23 <guest2425> pelotom: thank you
01:03:44 <pelotom> you're welcome
01:05:05 <pelotom> TryingToLearnHas: (goal  `elem` children) is the same as (elem goal children)
01:05:11 <TryingToLearnHas> what is this goal your talking about  pelotom and guest2425?
01:05:23 <TryingToLearnHas> what is its purpose
01:05:52 <pelotom> TryingToLearnHas: it's something that's being searched for in a tree, apparently
01:06:11 <TryingToLearnHas> yes an element correct?
01:06:18 <TryingToLearnHas> or an Node 
01:06:47 <pelotom> TryingToLearnHas: it's searching for an element, and returning paths to the element
01:07:02 <guest2425_> pelotom: I am getting this error message http://hpaste.org/paste/41341/question_2#p41344
01:07:27 <pelotom> guest2425_: that's because "< the shortest of the xss >" is not valid haskell :P
01:07:31 <pelotom> you need to fill that part in
01:07:38 <guest2425_> oh man
01:07:42 <guest2425_> hahahaha
01:07:44 <guest2425_> hahahaha
01:07:56 <Axman6> heh
01:08:00 <guest2425_> pelotom: dont call me anything
01:08:04 <guest2425_> please
01:08:30 <pelotom> no shame in being unfamiliar with the syntax ;)
01:08:53 <guest2425_> hahaha
01:11:06 <pelotom> aw, this nikki and the robots game is linux and windows only :(
01:11:06 <Jafet> Is the online version of RWH outdated, or less copy-edited, or something like that?
01:11:40 <pelotom> Jafet: it's pretty outdated in a lot of places :(
01:12:09 <pelotom> well, sorry, you're asking about vs. the printed copy... I don't know
01:12:35 <Jafet> Well, I've never read a print copy either, so I wouldn't know if it's the same.
01:13:11 <quicksilver> Jafet: I don't think the final copy-editing phase made it back to the online version.
01:13:14 <quicksilver> Jafet: (I'm not sure)
01:13:25 <cheater99> does haskell have infinitely nested data structures?
01:13:37 <Jafet> Well, I'm talking about things like storing a 13-digit integer in an Int, which isn't portable
01:13:39 <pelotom> Jafet: fortunately the comments seem to help in a lot of places, even though they haven't been incorporated yet
01:13:55 <Jafet> (And some other very minor inaccuracies.)
01:14:12 <pelotom> cheater99: yes?
01:14:16 <cheater99> ok
01:14:29 <pelotom> > [1..]
01:14:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:14:35 <cheater99> that's not nested.
01:14:49 <cheater99> i'm thinking for example about a tree with infinitely many levels.
01:14:51 <pelotom> cheater99: what do you call nested?
01:15:08 <cheater99> that means, there's a chain of nodes such that each node has a sub node.
01:15:17 <pelotom> cheater99: that's an infinite unary tree
01:15:26 <pelotom> that's what a list is
01:15:32 <quicksilver> cheater99: lists are nested, actually.
01:15:41 <cheater99> what about something that isn't unary?
01:15:48 <cheater99> say, an infinite binary tree
01:15:49 <quicksilver> cheater99: it's just the [...] syntax makes them look like they're not.
01:16:04 <cheater99> quicksilver: aha
01:16:09 <quicksilver> data BinTree a = Leaf a | Branch (BinTree a) (BinTree a)
01:16:24 <quicksilver> (that's with values at the leaves, other variations are possible)
01:16:31 <guest2425> pelotom: any suggestion for the fill in
01:16:34 <Axman6> data Tree a = Tree a [Tree a]
01:17:33 <cheater99> in haskell syntax, is white space significant?
01:17:34 <pelotom> guest2425: think through what you want to do
01:17:40 <cheater99> or can i do what ever i want with my indents and line breaks?
01:17:54 <pelotom> guest2425: you're trying to find the shortest path, right?
01:18:08 <guest2425> yes
01:18:14 <pelotom> guest2425: you have a list of paths, of which one of them must be the shortest, and you want to return it
01:18:31 <guest2425> yes
01:18:44 <quicksilver> cheater99: white space is signifiicant in some limited contexts, specifically layout blocks
01:18:49 <pelotom> guest2425: so what do you think would be a good way to do that?
01:18:58 <guest2425> sortBy
01:19:06 <cheater99> quicksilver: what is a layout block?
01:19:21 <guest2425> pelotom: sortBy
01:19:38 <quicksilver> cheater99: http://www.haskell.org/onlinereport/lexemes.html#sect2.7
01:19:58 <pelotom> guest2425: sounds good, so what's your attempt?
01:20:09 <pelotom> write some code and share it
01:20:42 <Jafet> data Tree a = Tree a (Tree a) (Tree a); cw n = let a = numerator n; b = denominator n in Tree (a % b) (cwTree (a % (a+b)) (cwTree ((a+b) % b)); cwTree = Tree (1 % 1)
01:21:14 <Jafet> (Sadly, the default Show instance will not print all of the tree.)
01:21:51 <guest2425> pelotom: sortBy lenght
01:23:07 <pelotom> :t sortBy -- guest2425, look at this signature
01:23:07 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
01:23:14 <Jafet> :t comparing length
01:23:15 <lambdabot> forall a. [a] -> [a] -> Ordering
01:24:01 <pelotom> :)
01:24:06 <guest2425> pelotom: that is what i need
01:26:17 <pelotom> guest2425: Jafet gave you a big hint
01:30:47 <TryingToLearnHas> is sortBy a built-in fn
01:30:50 <TryingToLearnHas> ?
01:32:31 <Jafet> @index sortBy
01:32:32 <lambdabot> Data.List
01:33:45 <pelotom> :t sortBy (comparing length)
01:33:46 <lambdabot> forall a. [[a]] -> [[a]]
01:33:48 <Jafet> I wonder if ghc's sortBy is Schwartzian.
01:34:01 <guest2425> pelotom: like this compare `on` length
01:34:04 <pelotom> it almost reads like english!
01:34:05 <Jafet> Probably not, as Implicit Sharing Is Bad.
01:34:46 <gal_bolle> is there a way to 'cabal install --reinstall --enable-library-profiling hfoobar' recursively (ie, reinstall any dependency i have installed without profiling)?
01:34:54 <pelotom> :t compare `on` length
01:34:55 <lambdabot> forall a. [a] -> [a] -> Ordering
01:35:02 <haskell-novice> http://hpaste.org/41347/school
01:35:16 <haskell-novice> my magic function doesnt work
01:36:02 <Axman6> well, you're suing + instead of :
01:36:24 <guest2425> pelotom: am i ok
01:36:57 <haskell-novice> there has to be something else, how do i track an 'index' if I just push x with : to the list wont it add the x element itself and not its index?
01:36:59 <dmead> haskell-novice, they aren't arrays
01:37:19 <dmead> haskell-novice, you have to have a counter
01:37:37 <Jafet> Well, python's lists are arrays
01:37:42 <dmead> haskell-novice, list don't support random access, and it's not an index
01:38:02 <guest2425> pelotom: Like this http://pastebin.com/rQMKEEFA
01:38:21 <dmead> haskell-novice, you're using a linked list of ints
01:39:15 <pelotom> guest2425: you're getting there, but that doesn't compile does it?
01:39:27 <guest2425> no
01:39:36 <dmead> :t null
01:39:36 <lambdabot> forall a. [a] -> Bool
01:39:41 <guest2425> pelotom: no
01:39:48 <dmead> i didn't know null was in the prelude
01:39:51 <Jafet> That code isn't even valid, haskell-novice. What does x represent?
01:39:59 <Jafet> :t minimum -- guest
01:40:00 <lambdabot> forall a. (Ord a) => [a] -> a
01:40:19 <dmead> @hoogle findindicies
01:40:19 <haskell-novice> it should have been x !! 0 not just x
01:40:19 <lambdabot> No results found
01:40:35 <Jafet> Though by accident, head . sort works just as well in haskell
01:40:57 <pelotom> guest2425: I really recommend using ghci to try things out with the type checker
01:40:58 <engla> hi all, where do I put parantheses in this to make it more clear? (maybe it doesn't matter?)   mcons p q = p >>= \x -> q >>= \y -> return (x:y)
01:41:18 <dmead> haskell-novice, you should look here
01:41:26 <dmead> haskell-novice, http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-List.html#16
01:41:33 <pelotom> guest2425: or just type expressions in here, prefixed with ">", and they'll get evaluated
01:41:42 <Jafet> haskell-novice: what if x is []? Think about it.
01:41:43 <pelotom> guest2425: or prefix with ":t" to see the type
01:42:03 <dmead> :t 1
01:42:03 <lambdabot> forall t. (Num t) => t
01:42:03 <Jafet> haskell-novice: then try to think about pattern-matching into x.
01:42:07 <dmead> :t [1]
01:42:08 <lambdabot> forall t. (Num t) => [t]
01:42:28 <pelotom> :t let xss = [[1,2,3,4],[1,2],[1,2,3]] in Just (compare `on` length xss )
01:42:28 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Int'
01:42:28 <lambdabot>     In the second argument of `on', namely `length xss'
01:42:28 <lambdabot>     In the first argument of `Just', namely `(compare `on` length xss)'
01:42:35 <Saizan> engla: that's pretty clear, it'd be "mcons p q = p >>= (\x -> q >>= (\y -> return (x:y)))" anyhow
01:42:47 <engla> Saizan: thank you
01:42:52 <Jafet> @do mcons p q = p >>= \x -> q >>= \y -> return (x:y)
01:42:52 <lambdabot> mcons p q = do { x <- p; y <- q; return (x : y)}
01:43:05 <pelotom> guest2425: so the goal is (1) to get that to compile, and (2) to match the signature of the function you're trying to build
01:43:13 <Lissomort> where is mistake in statement of "do"? : main = do putStrLn "Put your name:" \n first <- getLine ?
01:43:13 <guest2425> yes
01:43:25 <pelotom> guest2425: the signature you're trying to achieve is [[a]] -> Maybe a
01:43:30 <dmead> is somebody teaching a haskell class or something?
01:43:36 <dmead> or starting to give homework?
01:43:40 <Saizan> engla: btw, that's equivalent to "mcons p q = liftM2 (:) p q"
01:43:41 <guest2425> :t otherwise = Just (compare `on` length xss )
01:43:42 <lambdabot> parse error on input `='
01:44:01 <guest2425> :t  Just (compare `on` length xss )
01:44:01 <lambdabot> Not in scope: `xss'
01:44:02 <Jafet> pelotom: <yoda> do or not do there is no try
01:44:23 <Jafet> pelotom: in the extreme case, purely guessing to satisfy a signature is cargo cult programming.
01:44:34 <Saizan> Lissomort: is "first" aligned with putStrLn ?
01:44:41 <Jafet> Not much of an achievement, to me.
01:44:48 <guest2425> lamdaboot:
01:45:03 <TryingToLearnHas> how to u use the Maybe a 
01:45:05 <TryingToLearnHas> ?
01:45:09 <pelotom> Jafet: purely guessing, yes... educated guessing though is a good way for a beginner to get acquainted with the type system imho
01:45:25 <Jafet> Ok. I disagree.
01:45:26 <pelotom> and the way you go from purely guessing to educated guessing is by making a lot of guesses
01:45:37 <guest2425> oh my god
01:45:46 <guest2425> I will be educated later on
01:45:54 <guest2425> thanks to you guys
01:46:00 <guest2425> thank you
01:46:07 <pelotom> guest2425: you're really close
01:46:12 <pelotom> guest2425: study the types
01:46:19 <pelotom> guest2425: it's like putting together a puzzzle
01:46:25 <Lissomort> yes
01:46:26 <pelotom> puzzle* :)
01:46:49 <Saizan> Lissomort: ah, you also need something else after "first <- getLine", it's assuming that if you bound the name first you're going to use it
01:46:53 <guest2425> pelotom: at NOT the end puzzle
01:47:07 <Saizan> Lissomort: and anyhow it wouldn't know that's the result of that do-block otherwise
01:47:20 <guest2425> pelotom
01:47:32 <guest2425> pelotom: my compiler does work 
01:47:40 <Lissomort> that I can't understand. how can I finish Do-block?
01:47:43 <Saizan> Lissomort: if you still have problems paste your code and the error you're getting on a pastebin site and link that here
01:47:56 <guest2425> how can I ask lambdoot to tell me the function type
01:47:57 <Saizan> Lissomort: e.g. return ()
01:48:06 <guest2425> that I have so far
01:48:08 <pelotom> guest2425: ":t"
01:48:17 <pelotom> guest2425: ":t <expression>"
01:48:25 <guest2425> ok
01:48:38 <guest2425> how about the function
01:48:43 <guest2425> the all function
01:49:06 <TryingToLearnHas> : Just
01:49:16 <TryingToLearnHas> :t Just
01:49:16 <lambdabot> forall a. a -> Maybe a
01:49:19 <guest2425> :t <shortest xss | null xss = Nothing| otherwise = Just (compare `on` length xss )>
01:49:20 <lambdabot> parse error on input `<'
01:49:45 <guest2425> :t  shortest xss | null xss = Nothing| otherwise = Just (compare `on` length xss )
01:49:46 <lambdabot> parse error on input `|'
01:49:52 <guest2425> huh
01:50:02 <Jafet> lambdabot emulates ghci.
01:50:03 <guest2425> pelotom: what is wrong?
01:50:27 <guest2425> but that is my function
01:50:37 <Jafet> :t let shortest [] = Nothing; shortest xss = Just (compare `on` length xss)
01:50:38 <lambdabot> <no location info>:
01:50:38 <lambdabot>     not an expression: `let shortest [] = Nothing; shortest xss = Just (compare `on` length xss)'
01:50:41 <Jafet> :t let shortest [] = Nothing; shortest xss = Just (compare `on` length xss) in shortest
01:50:42 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Int'
01:50:42 <lambdabot>     In the second argument of `on', namely `length xss'
01:50:42 <lambdabot>     In the first argument of `Just', namely `(compare `on` length xss)'
01:51:01 <pelotom> guest2425: you have to use "let" in here
01:51:06 <guest2425> ok
01:51:11 <pelotom> and you still have a syntax error
01:51:27 <guest2425> oh man
01:51:30 <pelotom> a type error I mean
01:51:33 <guest2425> I give up
01:51:36 <pelotom> you're very close!
01:51:50 <Jafet> I'm not sure if that is "close".
01:52:00 <guest2425> ok
01:52:04 <TryingToLearnHas> :t sortBy
01:52:04 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
01:52:34 <Jafet> guest: (compare `on` length xss) is equivalent to (on (compare) (length xss)).
01:52:41 <guest2425> :t let shortest [] = Nothing; shortest xss = Just (compare `on` length) xss
01:52:41 <lambdabot> <no location info>:
01:52:42 <lambdabot>     not an expression: `let shortest [] = Nothing; shortest xss = Just (compare `on` length) xss'
01:53:37 <guest2425> i dont want this (compare `on` length xss) is equivalent to (on (compare) (length xss)).
01:53:44 <Jafet> Please, ignore pelotom's advice and stop guessing madly. Think about what your code is supposed to do and how it should do it.
01:53:57 <guest2425> ok
01:54:17 <Jafet> Given a list of things, how do you find the smallest thing in it?
01:54:31 <guest2425> with the min
01:54:36 <guest2425> :t min
01:54:37 <lambdabot> forall a. (Ord a) => a -> a -> a
01:54:56 <Jafet> That's possible. How would you use min to do that?
01:56:03 <TryingToLearnHas> Jafet: wouldn't be the min. of the length?
01:56:16 <zygoloid> :t minBy
01:56:17 <lambdabot> Not in scope: `minBy'
01:56:34 <guest2425> Jafet: I dont understand this (compare `on` length xss) is equivalent to (on (compare) (length xss)).
01:56:35 <zygoloid> :t minimumBy
01:56:35 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
01:56:40 <TryingToLearnHas> :t min length xs
01:56:40 <lambdabot> Not in scope: `xs'
01:57:00 <guest2425> why the on is before the compare
01:57:02 <Jafet> guest: it means they are just different ways to write the same thing.
01:57:18 <guest2425> oh ok
01:57:23 <TryingToLearnHas> :t minimum xs
01:57:24 <lambdabot> Not in scope: `xs'
01:57:30 <TryingToLearnHas> :t minimum 
01:57:31 <lambdabot> forall a. (Ord a) => [a] -> a
01:57:51 <zygoloid> > minimumBy length (words "hello #haskell!")
01:57:52 <lambdabot>   Couldn't match expected type `[a] -> GHC.Ordering.Ordering'
01:57:52 <lambdabot>         against...
01:58:04 <zygoloid> > minimumBy (comparing length) (words "hello #haskell!")
01:58:05 <lambdabot>   "hello"
01:58:20 <TryingToLearnHas> :t Just ( minimum xs)
01:58:21 <lambdabot> Not in scope: `xs'
01:58:22 <guest2425> Jafet: I have to fix this part correct shortest xss = Just (compare `on` length) xss'
01:58:27 <Jafet> Whoosh, there went an excellent opportunity to deprogram someone of guess-programming!
01:58:58 <guest2425> minimumBy (comparing length) (length xss)
01:59:02 <guest2425> like that
01:59:12 <pelotom> Jafet: go for it, the pupil is in your hands
01:59:30 <guest2425> Jafet: Like that minimumBy (comparing length) (length xss)
01:59:38 <zygoloid> guest2425: no, not quite like that.
01:59:44 <guest2425> oh man
02:00:02 <zygoloid> guest2425: minimumBy takes two arguments: firstly, a way of comparing values, and second, a list of values
02:00:35 <guest2425> :t minimum (comparing length) (length xss)
02:00:36 <lambdabot> Not in scope: `xss'
02:01:07 <guest2425> minimumBy (comparing length)  xss
02:01:28 <guest2425> Jafet: minimum (comparing length)  xss
02:01:32 <guest2425> :t minimum (comparing length) (length xss)
02:01:32 <lambdabot> Not in scope: `xss'
02:01:50 <guest2425> :t minimumBy (comparing length)  xss
02:01:51 <lambdabot> Not in scope: `xss'
02:02:01 <guest2425> :t minimumBy (comparing length)  
02:02:02 <lambdabot> forall a. [[a]] -> [a]
02:02:03 <TryingToLearnHas> :t shortest xss     | null xss = Nothing    | otherwise = Just (compare `on` length) xss'
02:02:04 <lambdabot> parse error on input `|'
02:02:19 <zygoloid> guest2425: do you understand why lambdabot is having trouble with that?
02:02:20 <guest2425> i got it
02:02:24 <TryingToLearnHas> why is there an error on the "| "
02:02:38 <zygoloid> TryingToLearnHas: because lambdabot wants an expression and that's a declaration
02:03:13 <zygoloid> (that code defines a function called shortest, but doesn't produce a value which has a type for it to print)
02:03:16 <guest2425> Jafet: am I ok
02:03:36 <pelotom> guest2425: you're on the right track, so now you have a sorted list
02:03:48 <Jafet> guest: no, you're still guessing madly...
02:03:54 <pelotom> guest2425: and you want the shortest list in the sorted list of lists
02:04:00 <guest2425> yes
02:04:03 <Jafet> I'll stop now, though.
02:04:09 <zygoloid> pelotom: guest2425 did not use sort
02:04:35 <pelotom> ah, oops
02:04:37 <zygoloid> guest2425: can you explain why you think that code is correct?
02:04:48 <guest2425> forall a. [[a]] -> [a]
02:05:02 <guest2425> Shortest shortest :: [[a]] -> Maybe [a]
02:05:14 <guest2425> zygoloid: thats why
02:05:16 <guest2425> ?
02:05:38 <zygoloid> guest2425: ok, good. the code has the right type. why does it do the right thing?
02:05:58 <pelotom> close to the right type...
02:06:02 <TryingToLearnHas> why can't guest2425 just sort the minimum of the list of list? pelotom or zygoloid
02:06:23 <zygoloid> pelotom: fair point.
02:06:24 <TryingToLearnHas> :t Just
02:06:24 <dmead> > [[2,3,4,3,1],[5,4,3,2],[5,2,2,3,33]]
02:06:25 <lambdabot> forall a. a -> Maybe a
02:06:25 <lambdabot>   [[2,3,4,3,1],[5,4,3,2],[5,2,2,3,33]]
02:06:37 <dmead> >map (sort) [2,3,4,3,1],[5,4,3,2],[5,2,2,3,33]]
02:06:42 <dmead> > map (sort) [2,3,4,3,1],[5,4,3,2],[5,2,2,3,33]]
02:06:42 <lambdabot>   <no location info>: parse error on input `,'
02:06:43 <zygoloid> TryingToLearnHas: sure, that's one way of doing it.
02:06:50 <dmead> > map (sort) [[2,3,4,3,1],[5,4,3,2],[5,2,2,3,33]]
02:06:50 <lambdabot>   [[1,2,3,3,4],[2,3,4,5],[2,2,3,5,33]]
02:06:57 <pelotom> TryingToLearnHas: the way you phrased that is not quite right...
02:07:07 <Jafet> dmead: you can hook up with lambdabot in private too, she's cool like that
02:07:08 <zygoloid> pelotom: actually, Ord [a] is resolved immediately, so the type is right after all
02:07:18 <dmead> Jafet, groovy baby
02:07:32 <zygoloid> actually, forget what i'm saying, there never was an Ord constraint
02:07:42 <haskell-novice> http://hpaste.org/41348/school
02:07:46 * zygoloid just woke up and hasn't had a coffee yet
02:07:47 <pelotom> zygoloid: it's missing the Maybe, I meant
02:07:54 <guest2425> :t minimum (comparing length)  
02:07:55 <lambdabot>     Couldn't match expected type `[a]'
02:07:55 <lambdabot>            against inferred type `[a1] -> [a1] -> Ordering'
02:07:55 <lambdabot>     In the first argument of `minimum', namely `(comparing length)'
02:08:07 <guest2425> :t minimumBy (comparing length)  
02:08:08 <lambdabot> forall a. [[a]] -> [a]
02:08:09 <zygoloid> pelotom: i was looking at: "shortest :: [[a]] -> Maybe [a]"
02:08:25 <TryingToLearnHas> y use comparing
02:08:30 <zygoloid> though perhaps i misunderstood
02:08:32 <TryingToLearnHas> :t comparing
02:08:33 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
02:08:38 <pelotom> zygoloid: yes, and what he has now is forall a. [[a]] -> [a]
02:08:59 <zygoloid> pelotom: i was assuming e'd put the whole lot together and got a function :: [[a]] -> Maybe [a]. but perhaps not?
02:09:06 <guest2425> :pelotom like this  | otherwise = Just minimumBy (comparing length)  xss
02:09:21 <guest2425> pelotom: like this otherwise = Just minimumBy (comparing length)  xss
02:09:41 <TryingToLearnHas> :t minimumBy
02:09:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
02:09:45 <zygoloid> TryingToLearnHas: well, minimumBy wants a function which compares two values and determines what order they go in
02:10:22 <zygoloid> TryingToLearnHas: comparing takes a function which maps a value to some sort of score, and uses it to determine what order two values go in
02:10:38 <zygoloid> so minimumBy (comparing foo) finds the minimum value in a list, when ordered by foo
02:10:43 <pelotom> guest2425: that's almost it
02:11:01 <guest2425> pelotom: I need sometin else?
02:11:08 <pelotom> guest2425: does that compile?
02:11:45 <guest2425> no
02:12:14 <pelotom> guest2425: keep in mind that function application is left-associative.. do you know what that means?
02:13:03 <guest2425> like (3+4) * 5
02:13:47 <guest2425> so how my function is read 
02:13:51 <guest2425> in Haskell 
02:13:58 <guest2425> otherwise = Just minimumBy (comparing length)  xss
02:13:58 <pelotom> it means that this: (a b c d e) has invisible parentheses like this ((((a b) c) d) e)
02:14:32 <guest2425> so I have the order incorrect
02:14:51 <pelotom> guest2425: so that means you're getting (Just minimumBy) (comparing length) xss
02:15:02 <pelotom> guest2425: the order is fine, the associativity is wrong
02:15:10 <pelotom> guest2425: just add explicit parentheses to fix it
02:15:46 <lars9> hah
02:16:10 <lars9> finally compiles
02:16:18 <guest2425> pelotom: how about this otherwise = Just (minimumBy (comparing length)  xss)
02:16:32 <pelotom> guest2425: how about it? does it compile?
02:16:40 <guest2425> i cant tested
02:16:51 <pelotom> ?
02:17:12 <guest2425> yeah hold on
02:18:12 <TryingToLearnHas> :t Just (minimumBy (comparing length)  xss)
02:18:13 <lambdabot> Not in scope: `xss'
02:18:46 <pelotom> @let xss = [[1,2,3,4],[1,2],[1,2,3]]
02:18:47 <lambdabot>  Defined.
02:19:00 <pelotom> :t Just (minimumBy (comparing length)  xss)
02:19:01 <lambdabot> forall a. (Num a) => Maybe [a]
02:19:11 <TryingToLearnHas> :t shortest xss     | null xss = Nothing    | otherwise = Just (minimumBy (comparing length)  xss)
02:19:12 <lambdabot> parse error on input `|'
02:19:20 <TryingToLearnHas> huh
02:19:38 <pelotom> TryingToLearnHas: use "let"
02:19:45 <guest2425> pelotom: i am ok
02:19:59 <guest2425> ?
02:20:04 <TryingToLearnHas> :t shortest xss     | null xss = Nothing    | otherwise let = Just (minimumBy (comparing length)  xss)
02:20:05 <lambdabot> parse error on input `|'
02:20:27 <guest2425> @let xss = [[1,2,3,4],[1,2],[1,2,3]]
02:20:27 <lambdabot>  <local>:3:0:
02:20:28 <lambdabot>      Multiple declarations of `L.xss'
02:20:28 <lambdabot>      Declared at: <local>...
02:20:28 <pelotom> :t let shortest xss     | null xss = Nothing    | otherwise = Just (minimumBy (comparing length)  xss) in shortest
02:20:29 <lambdabot> forall a. [[a]] -> Maybe [a]
02:20:29 <TryingToLearnHas> on the 1st bar? 
02:20:41 <pelotom> beh
02:20:48 <TryingToLearnHas> ok hahah
02:20:54 <guest2425> I got it
02:20:54 <Lissomort> who can help with error in this code http://pastebin.ru/315513?
02:20:57 <guest2425> I got it
02:21:13 <guest2425> pelotom: i got it
02:21:29 <pelotom> :t let shortest xss     | null xss = Nothing    | otherwise = Just (minimumBy (comparing length)  xss) in shortest xss
02:21:30 <lambdabot> forall a. (Num a) => Maybe [a]
02:21:36 <pelotom> > let shortest xss     | null xss = Nothing    | otherwise = Just (minimumBy (comparing length)  xss) in shortest xss
02:21:37 <lambdabot>   Just [1,2]
02:22:03 <TryingToLearnHas> still get errors 
02:22:14 <TryingToLearnHas> :t let shortest xss     | null xss = Nothing    | otherwise = Just (minimumBy (comparing length)  xss) in shortest
02:22:15 <lambdabot> forall a. [[a]] -> Maybe [a]
02:22:24 <guest2425> no
02:22:33 <TryingToLearnHas> I tried on the ghci
02:23:05 <guest2425> TryingToLearnHas: just this function TryingToLearnHas
02:23:06 <pelotom> TryingToLearnHas: you may be missing some imports
02:23:30 <TryingToLearnHas> hmmm ok
02:24:10 <guest2425> pelotom: Thank you
02:24:24 <guest2425> I need to work in a report I am working psssssss
02:24:36 <guest2425> pelotom: I need to work in a report I am working psssssss
02:24:56 <guest2425> Pelotom: Thank you again
02:24:57 <pelotom> guest2425: np, good luck
02:26:06 <Lissomort> who can help with error in code, plz http://pastebin.ru/315513 ?
02:27:00 <quicksilver> Lissomort: general, it helps to also paste the error
02:27:08 <ManateeLazyCat> Lissomort: What error?
02:27:31 <Lissomort> oh, yeah, an error - Last generator in do {...} must be an expression 
02:27:47 <quicksilver> you must have the indentation wrong, I think
02:27:49 <Lissomort> I can't understand how to change the statement of DO 
02:28:02 <quicksilver> because what you have there looks OK
02:28:14 <Axman6> are you using tabs?
02:28:18 <quicksilver> (that's the error when the last line of your do block is an  "a <- b" line, but that's not what you have)
02:28:29 <quicksilver> yes, he is
02:28:38 <Lissomort> yeah, I'm using tabs
02:28:46 <zygoloid> well, i don't know of any PHP interpreter which can run haskell...
02:28:57 <Axman6> tabs are bad...
02:29:00 <pelotom> I was gonna say... php??
02:29:11 <Axman6> yeah, why is there <?php around the code?
02:29:14 <ManateeLazyCat> Lissomort: Why have <?php ?> ?
02:29:58 <Lissomort> i don't now, it our rus server wrote php tags 
02:30:00 <zygoloid> Postulated Haskell Preprocessor?
02:30:28 <zomg> ... :D
02:31:01 <guest2425> pelotom: from which module I get miminumBy
02:32:12 <Lissomort> its can be error only in bad tabs?
02:33:08 <pelotom> guest2425: let me show you a great website for this kind of question: http://www.haskell.org/hoogle/
02:33:48 <ClaudiusMaximus> > let a<?b = b ; a?>b = a ; infix 5 <? ; infix 6 ?> ; some = error "huh" ; php = "haskell" ; code = repeat "o" ; in some<?php?>code
02:33:49 <lambdabot>   "haskell"
02:35:38 <pelotom> @index minimumBy
02:35:38 <lambdabot> Data.List
02:35:42 <guest2425> ok thank you
02:35:45 <pelotom> guest2425: you can also do that
02:36:27 <guest2425> thank you again
02:45:49 <exDM69> is there an easy way to install Cabal and cabal-install into your home directory? I need to setup an environment to my home directory on a school computer (no root access)
02:46:18 <dcoutts__> exDM69: yes, and ghc too
02:46:20 <exDM69> or actually I need to tell my teacher how to do it in order for him to evaluate my course work which I coded with Haskell
02:47:08 <exDM69> we do have GHC 6.12.1 so no need for that
02:47:16 <exDM69> HTTP >=4000.0.2 && <4001, zlib >=0.4 && <0.6
02:47:21 <exDM69> but that is missing for cabal-install
02:47:31 <exDM69> sort of a chicken and egg scenario
02:48:10 <luite> there used to be a bootstrap.sh file in the source distribution of cabal-install
02:48:23 <luite> not sure if that's still the case
02:48:26 <Jafet> You could just send him the runtime, or link it statically.
02:48:49 <Jafet> Unless he insists on compiling it himself, that is.
02:48:53 <exDM69> Jafet: static linking sounds like a good idea
02:49:22 <dcoutts__> luite: yep, still is
02:49:34 <Jafet> There are some caveats with distributing runtimes, though
02:50:00 <exDM69> Jafet: how do I build a statically linked lib using cabal?
02:50:07 <exDM69> some magic flags for configure?
02:50:26 <dcoutts__> --ghc-options=-static ought to work I think
02:50:28 <Jafet> I've never done it, I've just heard it done
02:50:49 <dcoutts__> exDM69: but actually you don't need to do that at all
02:51:01 <Jafet> If you're linking shared libraries statically, the result is bound to be grotesque, too
02:51:04 <dcoutts__> exDM69: ghc-compiled progs link all Haskell code statically anyway
02:51:29 <dcoutts__> exDM69: it's only the C libs that are linked dynamically, and unless you're using anything fancy that'll all just work
02:51:50 <Jafet> dcoutts: the ghc runtime is statically linked?
02:52:46 <dcoutts__> Jafet: yep
02:53:01 <dcoutts__> Jafet: run ldd on any of your compiled haskell progs
02:53:12 <dcoutts__> you'll only see C libs as dynamic dependencies
02:53:21 <Jafet> Oh. I suppose that's why they're rather large.
02:53:28 <dcoutts__> yes
02:53:49 <dcoutts__> there's also support now for shared libs, but it's not the default
02:54:34 <Jafet> Does ghc still use random symbol names? That would remove some of the advantage of shared libs.
02:55:19 <exDM69> why isn't "cabal configure" installing my build time dependencies? is that a flag too?
02:55:27 <guest2425> pelotom: I getting this error message   parse error on input `in'
02:56:05 <Jafet> That's a well-known bug in cabal
02:56:14 <TryingToLearnHas> guest2425 take the in shortest part 
02:56:16 <TryingToLearnHas> out
02:56:27 <guest2425> ok
02:57:04 <TryingToLearnHas> only use the in with let clause
02:57:13 <guest2425> oh man
02:57:14 <guest2425> ok
02:58:54 <guest2425> Jafet: I am getitng this error message http://pastebin.com/UAZcAHuY
02:59:08 <gal_bolle> i'm trying to do profiling, and i would like to put a cost center on a bind in do notation
02:59:37 <gal_bolle> if i add {-# BogusPragma "bogus" #-}, it compiles
02:59:59 <ManateeLazyCat> How to indent cabal documentation?
03:00:02 <gal_bolle> but if i add {-# SCC "bla" #-}, ghc complains about do notabation
03:00:09 <gal_bolle> notation
03:00:21 <gal_bolle> http://hpaste.org/41349/scc__and_donotations
03:00:46 * ManateeLazyCat pasted "manatee.cabal" at http://paste2.org/get/1082423
03:00:55 <ManateeLazyCat> I want indent cabal documentation in keyword 'description' for manatee.cabal ^^^
03:02:23 <nostard> nub is O(n²) right? Is there a similar function which doesn't preserve the order in nlogn?
03:02:41 <ziman> Set.toList . Set.fromList
03:03:15 <Jafet> map head . group . sort
03:04:05 <Jafet> However, nub is superior because it works over infinite lists.
03:04:09 <nostard> ziman: yeah, thought of that. Which would be the fastest? Ah, Criterion to the help :D. (i suspect the first)
03:04:16 <Jafet> > nubBy (((>1).).gcd) [2..]
03:04:17 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
03:04:22 <nostard> Jafet: i dont have inifinite lists here so =)
03:04:28 <nostard> Jafet: but that is cool
03:04:50 <Jafet> (In theory, you can use sort to implement faster nub over an infinite list.)
03:06:41 <Jafet> ((sort? I mean Set))
03:06:52 <Saizan> (i was wondering how)
03:08:14 <ManateeLazyCat> Beginning . in cabal is mean newline?
03:08:30 <nostard> the fastes in my case would probably be using an array and count sort :D
03:08:45 <ManateeLazyCat> I found download-curl.cabal add many . in keyword description to newline documentation.
03:12:42 <ManateeLazyCat> Looks . and > use indent tag for .cabal file.
03:14:14 <wjt> ManateeLazyCat: why does gtk2hs contain a fork of c2hs?
03:14:33 <wjt> ManateeLazyCat: which is not even compatible with the upstream version?
03:14:40 * wjt was fixing bugs in upstream at the weekend
03:14:47 <ManateeLazyCat> wjt: Because gtk2hs add some tools generate code automatic.
03:15:00 <wjt> why can't these fixes be merged upstream?
03:15:13 <ManateeLazyCat> wjt: Possible, just haven't time do that.
03:15:17 <wjt> fair enough
03:15:31 <wjt> daf and I got some way through binding gobject-introspection at the weekend
03:16:45 <wjt> but not as far as we'd hoped — the repository-reading library is nasty
03:16:58 <ManateeLazyCat> wjt: Yes, if gobject-introspection finish, it's make our life easier. 
03:17:45 <ManateeLazyCat> wjt: IMO. gobject-introspection is standard Interface to binding C library, and better than current solution of gtk2hs.
03:18:12 <nostard> in ghci, when i use ":l file.hs" it's interpreted? How can i load a compiled module?
03:18:14 <ManateeLazyCat> wjt: But do not expect we can generate gtk+ binding automatically. 
03:18:24 <ManateeLazyCat> nostard: :m module
03:18:41 <wjt> ManateeLazyCat: I expect that we can generate most of the binding automatically, but we'll definitely have to have a way to add additional code to have more Haskell-y APIs
03:18:46 <nostard> ManateeLazyCat: thanks =)
03:19:12 <nostard> ManateeLazyCat: even for those i made myself?
03:19:13 <ManateeLazyCat> wjt: Yes.
03:20:26 <ManateeLazyCat> nostard: If you want load module that haven't install. So use ":l file.hs" load file, then use ":m module" load module.
03:20:46 <nostard> ManateeLazyCat: ok
03:21:07 <ManateeLazyCat> nostard: If package has install, just need type ":m module".
03:21:20 <ManateeLazyCat> nostard: ghci will search file in ghc database to load.
03:21:50 <nostard> ManateeLazyCat: yeah, but it's no package, just a module in the current directory.
03:21:57 <dcoutts__> exDM69: what did you mean about build time dependencies?
03:22:28 <nostard> ManateeLazyCat: thanks =)
03:22:34 <ManateeLazyCat> nostard: You're welcome.
03:22:56 <exDM69> dcoutts__: when running cabal configure in my project dir, I get complaints about missing the parsec library but it won't get installed automatically
03:23:02 <exDM69> dcoutts__: shouldn't it do that?
03:23:30 <dcoutts__> exDM69: ah, you're thinking of the install command, it does everything, configure; build etc are just local commands
03:23:31 <ManateeLazyCat> wjt: Because some GTK+ code have very complicated and you can't trust gobject-introspection fully.
03:23:50 <wjt> ManateeLazyCat: oh, if the gobject-introspection info can't be trusted, then it should be fixed
03:23:50 <ManateeLazyCat> wjt: Of course, gobject-introspection is best way to binding GTK+ code.
03:24:29 <exDM69> dcoutts__: is there a command which would download and install the dependencies?
03:24:36 <ManateeLazyCat> wjt: Yep, i found some GTK+ documentation said need unref return gobject, but code is not like documentation. 
03:24:44 <exDM69> dcoutts__: without having to do cabal install "parsec >= 3" manually
03:25:23 <ManateeLazyCat> wjt: So you're working on gobject-introspection ?
03:25:35 <wjt> ManateeLazyCat: i was at the weekend, yeah, at the Gnome summit
03:25:36 <ManateeLazyCat> wjt: Work together with Matt?
03:25:47 <ManateeLazyCat> wjt: Very good.
03:25:47 <wjt> ManateeLazyCat: i contacted him; he said he didn't actually get anywhere, so had no code
03:25:56 <Saizan> exDM69: running "cabal install" would
03:26:13 <ManateeLazyCat> wjt: Oh, i suppose Matt have write some code.
03:26:23 <Saizan> exDM69: with no package name, i mean
03:28:14 <exDM69> Saizan: no cabal configure / cabal build needed?
03:28:32 <ManateeLazyCat> wjt: I suggestion you stick your gobject-introspection on upstream c2hs, and not gtk2hs fork c2hs.
03:29:04 <wjt> ManateeLazyCat: that was what i was doing :)
03:29:10 <wjt> thanks for clarifying
03:29:10 <ManateeLazyCat> wjt: Nice.
03:29:30 <ManateeLazyCat> wjt: I hope someday we can use your code replace the tools of gtk2hs.
03:30:11 <ManateeLazyCat> wjt: Current, i use Emacs help binding gtk2hs, but you know, it's painful. :)
03:31:04 <ManateeLazyCat> wjt: Have any open repository? I'm interested it, maybe i can help. :)
03:32:27 <Saizan> exDM69: no
03:49:48 * hackagebot cmdargs 0.6.2 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.2 (NeilMitchell)
03:49:50 * hackagebot hamlet 0.6.0.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.6.0.1 (MichaelSnoyman)
03:50:48 * hackagebot http-enumerator 0.2.1 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.1 (MichaelSnoyman)
03:50:50 * hackagebot mime-mail 0.0.0.2 - Compose MIME email messages.  http://hackage.haskell.org/package/mime-mail-0.0.0.2 (MichaelSnoyman)
03:50:52 * hackagebot yesod 0.6.1.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.1.1 (MichaelSnoyman)
03:51:54 * hackagebot yesod-auth 0.2.0.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.2.0.1 (MichaelSnoyman)
03:54:31 <Zhuangzi> @hoogle (a -> a) -> (a -> a) -> a -> a
03:54:31 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
03:54:31 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
03:54:31 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
03:55:08 <engla> is it possible to use a let, where or similar construct to make some definitions that are only visible to *two* top-level functions (that are visible)
03:55:50 <djl> no, I don't believe you can
03:56:40 <ClaudiusMaximus> > let (f, g) = (h 1, h 2) where h = id in f
03:56:41 <lambdabot>   1
03:56:51 <ClaudiusMaximus> you can use (f, g) = ... at the top level too
03:57:16 <Axman6> Have i told anyone lately how much i love BONUS? I've never seen zippers used for anything more complex than lists, and understood it. BONUS makes it seem obvious that you'd get to the same conclusion he has. awesomesause
03:58:51 <BONUS> :o)
03:58:51 <lambdabot> BONUS: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:58:55 <Zhuangzi> > let un f g a = f (g (f a)) in un reverse (dropWhile isSpace) "hello "
03:58:55 <Zhuangzi> :t let un f g a = f (g (f a)) in un
03:58:55 <Zhuangzi> is this function or something more general than it defined anywhere? category theoretically, what would you call `reverse' where reverse . reverse = id? 
03:58:56 <lambdabot>   "hello"
03:58:56 <lambdabot> forall t t1. (t -> t1) -> (t1 -> t) -> t -> t1
03:59:05 * Axman6 gives BONUS a cuddle
03:59:34 <BONUS> haha. glad people liked that
03:59:53 * hackagebot binarydefer 1.2.1 - Binary serialization with deferred loading  http://hackage.haskell.org/package/binarydefer-1.2.1 (NeilMitchell)
04:00:56 <quicksilver> neilmitchell++ # he might not have time to IRC any more but he has time to upload :)
04:01:14 <Axman6> he does quite a bit of work i'd be interested to talk to him about
04:01:34 <quicksilver> you could email him. He's a pretty friendly guy IME>
04:01:36 <Zhuangzi> `un' kind reminds me of Functor's map, but, not quite
04:01:42 <BONUS> whenever you see a hackagebot announcement it's a good reminder that someone out there is being productive and you're just slacking off on irc :)
04:01:57 <quicksilver> :)
04:02:25 <BONUS> hackagebot announcements always make me feel a bit guilty
04:02:33 <Axman6> heh
04:03:41 <Axman6> well, my latest idea for a package i think has flopped. i was trying to reimplement dons' stream fusion stuff, using specialised Step data structures for each type in the stream (using type families), but it doesn't seem to add anything to the speed of the code
04:04:13 <quicksilver> when stream fusion is working well, those data structures don't exist anyway do they?
04:04:41 <Axman6> yeah
04:04:53 <Axman6> hence why mt attempts to make it faster failed.
04:04:58 <Zhuangzi> ski: ping
04:05:16 <Axman6> but, worth exploring. still need to do some proper benchmarking, but even lists are faster than what i ended up with so far :\
04:05:50 <Axman6> i did learn an interesting eway to use type families though 
04:06:35 <ClaudiusMaximus> Zhuangzi: reminds me a little of the functions here: http://www.haskell.org/haskellwiki/TV#IO
04:07:12 <astroboy> Is there a way to use the option -Wall without the missing type signature checking?
04:07:44 <Axman6> good boys write type signatures before writing the function
04:07:45 <Axman6> :P
04:07:54 <ClaudiusMaximus> astroboy: -fno-warn-missing-signatures perhaps
04:08:17 <astroboy> ClaudiusMaximus: thanks
04:08:35 <BONUS> i wonder if there's a tool that goes over your code and just adds type signatures for your top level functions
04:10:13 <luite> could be useful to have in haskell-mode for emacs
04:11:08 <quicksilver> haskell-mode for emacs can do that
04:11:16 <quicksilver> althouhg you have to hit a keybinding for each top-level function
04:11:23 <quicksilver> I don't think there is a command to do them all.
04:11:38 <luite> doing them one by one is more sensible imho :)
04:12:58 <quicksilver> point your cursor at the definition
04:13:01 <Zhuangzi> ClaudiusMaximus: something like that, yeah. I'm seeing if I can define a functor instance
04:13:05 <quicksilver> and then C-u C-c C-t <RET>
04:18:36 <lars9> is there a good vim plugin for haskell?
04:18:46 <Zao> There's the haskell-mode one, that's decent.
04:19:24 <lars9> there are more than one with that name
04:19:33 <Zao> Had projects been up, http://www.google.se/url?sa=t&source=web&cd=1&ved=0CBoQFjAA&url=http%3A%2F%2Fprojects.haskell.org%2Fhaskellmode-vim%2F&ei=ro3aTPO9Ks6bOtzZmMEJ&usg=AFQjCNFPzoD_jH0MI-sfIuzXkChULr4QXQ&sig2=8WekKZhxmBAiDsQU691L3Q
04:19:45 <Zao> http://projects.haskell.org/haskellmode-vim/
04:19:51 <Zao> (dear Google, stop raping my URLs)
04:21:27 <lars9> Zao: can you open that url now?
04:21:45 <lars9> Zao: forever loading
04:21:49 <Zao> Nope, my "had projects been up" qualification still holds.
04:22:27 <Zhuangzi> Zao: needs more quotation
04:23:03 <lars9> Zao: tried again, still cannot load
04:23:20 <Zao> lars9: That's the definition of "being down", which is, "not up".
04:23:24 <Zhuangzi> lars9: he means "projects", the subdomain isn't up
04:25:24 <lars9> oops...
04:25:53 <Cheery> I read through that paper about three instruction machine, G-machine and template instantiation
04:26:31 <lars9> aur/vim-haskell 1.2.1-1 (21) Updated with for in standalone deriving.
04:26:43 <lars9> Zao: is it this package?
04:26:54 <Zao> No idea, I won't touch Arch.
04:27:25 <Zao> lars9: No, that's just highlighting.
04:30:08 <lars9> Zao: i see...
04:30:34 <Zao> I'd check on it later when the sysapes have resurrected the server.
04:31:43 <Cheery> three-instruction-machine -thing were a bit harder to understand. but it was pretty easy to understand G-machine and templete instationer
04:31:54 <lars9> should be this one: aur/vim-scripts-haskellmode 20100622-1 (13) Collection of plugins to aid Haskell programming in Vim.
04:32:29 <Zao> Hopefully it fetches from a mirror that's not down then :D
04:32:52 <Cheery> G-machine: unwind the spine, hit the supercombinator, run series of instructions for the combinator and continue
04:35:13 <Zhuangzi> ClaudiusMaximus: I'm unable to define a Functor instance. :-(
04:36:53 <Cheery> all of those were graph reduction engines. But is there an implementations that output machine instructions that replace graph reduction?
04:38:14 <Zhuangzi> data Un f a = Un (a -> a) a
04:38:21 <Botje_> Unf Unf!
04:38:22 <Zhuangzi> let fmap' g (Un f a) = Un f (f (g (f a))) in let (Un _ a) = fmap' (dropWhile isSpace) (Un reverse "hello ") in a
04:38:25 <Zhuangzi> => "hello"
04:38:35 <int-e> Cheery: "replace" in what sense? I mean graph reductions reduce to allocation of new nodes and an occasional pointer update, which can be implemented in machine code.
04:39:20 <Cheery> int-e: well think about targetting opencl
04:39:22 <Zhuangzi> The problem is that Un is `a -> a', whereas fmap is `a -> b', and I cannot think of a way to work around this.
04:39:32 <Cheery> int-e: that's what I wonder here. :)
04:40:06 * hackagebot derive 2.4 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.4 (NeilMitchell)
04:40:10 <Axman6> Zhuangzi: you really want data Un a = Un (a -> a) a
04:40:25 <Axman6> the f there isn't needed or used at all
04:40:47 <Zhuangzi> Axman6: well, it's used in `fmap'
04:40:56 <Zhuangzi> (fmap')
04:41:04 <Cheery> int-e: weren't aware it reduces that much.
04:41:06 <Axman6> Zhuangzi: not the f in the _type_ Un f a
04:41:14 <int-e> Cheery: oh. then you're after recovering loops from recursion and similar stuff. I don't know whether there's any implementation doing that, jhc perhaps? ghc is bad at it; the only way it happens, as far as I understand it, is as a peephole optimisation in native code generation.
04:41:48 <Zhuangzi> Axman6: I know, the `f' is just a placeholder so that I can use the Un constructor
04:41:55 <Cheery> int-e: sounds hard.
04:42:09 <Zhuangzi> Axman6: How do you define Un so that I can write this? (Un reverse "hello ")
04:42:16 <Cheery> int-e: I guess there's other approach that might work better then.
04:42:16 <int-e> Cheery: But I'm not an expert on this.
04:42:20 <Axman6> Zhuangzi: the f on the left the = is completely useless
04:42:35 <Zhuangzi> Axman6: So how do you define Un so that I can write this? (Un reverse "hello ")
04:42:50 <Axman6> data Un a = Un (a -> a) a is exactly the same, and doesn't carry a useless extra type with it
04:43:00 <Axman6> Zhuangzi: exactly how i wrote it
04:43:58 <Axman6> what data Un a = Un (a-> a) a says is: make a datatype which has an a in it, and the _values_ of the Un a type contain a function which takes an a and returns an a, and also an a
04:44:10 <Zhuangzi> Nevermind, that was an oversight. I understand basic type declarations.
04:44:24 <Axman6> good :) just making sure you did understand
04:44:25 <Zhuangzi> I'm trying to define a Functor instance.
04:44:56 <Zhuangzi> I don't think it's possible though. Nevermind.
04:45:07 <Axman6> sure it is
04:45:13 <Zhuangzi> How?
04:45:38 <Axman6> instance Functor Un where fmap f (Un g x) = Un (g . f . g $ x)
04:45:40 <aristid> fmap f (Un e x) = Un id (f . e $ x)
04:46:09 <Axman6> uh
04:46:09 <Zhuangzi> Couldn't match expected type `Un b' against inferred type `a -> Un a' In the expression: Un (g . f . g $ x) In the definition of `fmap': fmap f (Un g x) = Un (g . f . g $ x) In the instance declaration for `Functor Un'
04:46:14 <Axman6> instance Functor Un where fmap f (Un g x) = Un g (g . f . g $ x)
04:46:21 <aristid> Axman6: why two g?
04:46:29 <Axman6> forgot to put the function back in the constructor
04:46:30 <aristid> Axman6: and why not Un id?
04:46:30 <Zhuangzi> Couldn't match expected type `b' against inferred type `a' `b' is a rigid type variable bound by the type signature for `fmap' at <no location info> `a' is a rigid type variable bound by the type signature for `fmap' at <no location info> In the first argument of `Un', namely `g' In the expression: Un g (g . f . g $ x) In the definition of `fmap': fmap f (Un g x) = Un g (g . f . g $ x)
04:46:39 <Axman6> aristid: because i saw what he was after earlier
04:46:41 <aristid> Axman6: i think my version makes more sense :P
04:46:43 <Axman6> but... mine won't work
04:46:51 <aristid> Zhuangzi: have you tried my version?
04:46:59 <Axman6> yeah, i think yours is better
04:47:26 <Axman6> Zhuangzi: you're right, if you want the behaviour you're after, you can't define fmap
04:47:44 <Zhuangzi> aristid: it compiles, but it's not the right behaviour. it can't be `id'
04:48:54 <Zhuangzi> aristid: the point of the Functor is to contain some `a', but only provide access to `(f a)'
04:50:06 <Zhuangzi> Axman6: I suppose I could just define un f g = f . g . f
04:50:28 <Axman6> aye
04:50:31 <Zhuangzi> I could put it in Data.Function for now.
04:50:33 <Axman6> much better idea ;)
04:50:57 <Zhuangzi> Unless someone has a better name for it?
04:51:25 <Zhuangzi> maybe `with'
04:51:30 <Zhuangzi> > let with f g = f . g . f in with reverse (dropWhile isSpace) "hello "
04:51:31 <lambdabot>   "hello"
04:52:11 <Zhuangzi> I don't know. That's why I was asking about what kind of function f.f=id is.
04:52:21 <aristid> Zhuangzi: well, if you don't want to apply the function, you need data Un a b = Un (a -> b) a
04:52:44 <aristid> and then simply fmap f (Un g a) = Un (f . g) a
04:55:05 <Zhuangzi> I do want to apply it.
04:55:17 <Zhuangzi> Where's ski when you need him?
04:56:14 <edlinde> Hi all, when you have the => symbol in a type signature thats for typeclasses yeah?
04:56:28 <edlinde> was wondering if you could have multiple occurences of the => symbol?
04:56:32 <aristid> Zhuangzi: ah, you want to enclose it
04:56:41 <aristid> Zhuangzi: sorry i thought you wanted to apply the f only on one side
04:56:55 <edlinde> I have seen that syntax but I am not sure I got it... does this mean the type belongs to multiple typeclasses?
04:57:11 <Zhuangzi> edlinde: you mean (F a, G a) => ...?
04:57:31 <edlinde> nah it was more like => Eq => something
04:57:54 <edlinde> I cannot find that code now.. will have to dig it up.. its just that I am reading up on typeclasses now in LYAH
04:58:00 <edlinde> so the thought came up
05:03:10 <edlinde> so guys, when I say "data ... something" I am creating a TYPE?
05:03:24 <edlinde> and when I say "class something..." I am creating a new TYPE CLASS?
05:03:29 <edlinde> did I get that right?
05:03:32 <BONUS> yeah
05:03:34 <Starfire> Yes.
05:03:37 <edlinde> cool
05:03:44 <edlinde> so whats "instance... "?
05:03:45 <BONUS> only usually we use lowercase to describe them
05:03:59 <BONUS> instance is saying: ok now this type is part of this type class
05:04:09 <edlinde> yep BONUS I was just laying exphasis on it .. just like your name :)
05:04:11 <Zao> edlinde: An instance declaration declares an instance of a type class.
05:04:16 <Axman6> edlinde: instancs says that a type implements that class
05:04:29 <edlinde> ah ok so the instance is really just the link between the type and the typeclass
05:04:35 <edlinde> ok cool gotcha
05:05:03 <Axman6> Int is an instance of Num, because somewhere in the Prelude is instance Num Int where ...
05:05:30 <Zao> class ASDF a where f :: a -> a     instance ASDF Int where f x = x * x
05:06:12 <edlinde> but when I say "data... something... " I can append say "derives from (Eq, Show)...etc yeah?
05:06:22 <edlinde> do I then still have to make instances?
05:06:34 <edlinde> or is that data... derives doing it for me implicitly?
05:06:42 <hpc> edlinde: GHC will automatically make instances if it knows how, when you do deriving
05:06:43 <Axman6> only some classes are derivable
05:06:46 <Zao> Deriving generates instances through machinery.
05:06:52 <hpc> edlinde: if it doesn't know how, it freaks out and dies
05:06:58 <Axman6> heh
05:07:05 <edlinde> ok
05:07:27 <Zao> Deriving Eq generates an instance that does a field-wise Eq test.
05:07:29 <edlinde> Is LYAH accurate? I mean is it good to read it completely?
05:07:40 <hpc> edlinde: LYAH is the best damn tutorial ever made
05:07:40 <Zao> Deriving Ord generates a lexicographic ordering over the fields in order.
05:07:42 <Zao> etc.
05:07:47 <edlinde> it looks good to me
05:07:49 <hpc> i still read it
05:08:01 <BONUS> edlinde: i dont think there's any multiple use of => in LYAH
05:08:03 <edlinde> someone said Real World Haskell is better to read AFTER reading through this tute
05:08:07 <BONUS> if there is then it's shirley an error
05:08:16 <medfly> sure, blame shirley
05:08:18 <Zao> Deriving typically builds on your fields to having instances it can use to construct a more complex one.
05:08:31 <hpc> RWH sort of expects you to know the basics already
05:08:40 <edlinde> ok
05:08:45 <zygoloid> BONUS++  periodic karma for LYAH
05:08:49 <BONUS> haha
05:08:51 <edlinde> yeah even LYAH is quite a lot to cover really
05:08:54 <hpc> i use RWH as a reference if i ever need to learn something new
05:09:08 <hpc> like databases, since about a week ago
05:09:25 <edlinde> I mean I will refer to it now that I know where to roughly find things... but I seem to notice that Haskell gives you lots and lots of ways to do the same things
05:09:28 <Axman6> oo, must remember to bring my RWH to japan
05:09:46 <hpc> personally, i suggest your next step after LYAH is to write lots of programs and lurk #haskell
05:09:52 <zygoloid> BONUS: how's the dead tree edition going, by the way?
05:10:04 <hpc> then read through sigfpe when you feel like making your head spin with abstract nonsense :D
05:10:06 <BONUS> pretty much done!
05:10:09 <BONUS> out in january
05:10:13 <Jafet> > ((1,undefined) == (2, undefined), (undefined, 1) == (undefined, 2))
05:10:13 <lambdabot>   (False,*Exception: Prelude.undefined
05:10:20 <BONUS> we're going to kill lots and lots of trees hopefully
05:10:23 <edlinde> sorry is the type an instance of a typeclass?
05:10:23 <zygoloid> \o/
05:10:24 <Jafet> Is that guaranteed?
05:10:40 <hpc> edlinde: yes
05:10:53 <edlinde> hmm its just that I found something confusing in LYAH then
05:11:02 <edlinde> he defined a type as 
05:11:03 <zygoloid> Jafet: yes, (==) for (,) is the derived Eq; it compares left-to-right and short-circuits.
05:11:03 <edlinde> data TrafficLight = Red | Yellow | Green
05:11:16 <edlinde> then he says
05:11:17 <edlinde> It defines the states of a traffic light. Notice how we didn't derive any class instances for it.
05:11:32 <BONUS> yes
05:11:34 <edlinde> so I was like... do you derive class instances for a type?
05:11:45 <hpc> edlinde: you make values of a type with a constructor; you make a type with a type constructor and type variables; you make a type an instance of a class to get lots of convenient functions for free
05:12:17 <earthy> hpc: lots of convenient function *names* and sometimes fitting behaviour
05:12:26 <BONUS> when you do stuff like data Foo a = Bar a deriving (Show), you derived the Show instance for that type
05:12:41 <edlinde> so in this example what did the author mean by  "Notice how we didn't derive any class instances for it."?
05:12:54 <earthy> there's no 'deriving' clause
05:13:01 <BONUS> because instead of deriving, the instances are then manually implemented
05:13:07 <earthy> so the TrafficLight, by default, is not a member of any typeclass
05:13:13 <earthy> and then what BONUS said. :)
05:13:18 <edlinde> ah ok its the other way round
05:13:46 <zygoloid> Jafet: see the h'10 report, chapter 11.1 (which has exactly this as an example). chapter 9 specifies that Eq for (,) is the derived one.
05:13:53 <edlinde> we dont derive class instances FROM it ... we use this type to derive from some typeclass
05:14:25 <edlinde> and since we ommitted the deriving clause... then this type isn't attached to any typeclass yeah?
05:14:31 <BONUS> yeah
05:14:34 <edlinde> k
05:14:41 <Jafet> zygoloid: ah, ok
05:14:46 <sipa> you have classes and types, those are things that are defined completely independently
05:14:58 <tonkman> how do I set quickcheck to use my own generator
05:14:58 <sipa> and instances are the links between them
05:15:23 <tonkman> for example if I want to test if one function works with only ['a'..'z'] chars
05:15:48 <paolino> tonkman: make a property
05:16:42 <tonkman> ah, ok
05:17:20 * hackagebot uniplate 1.6 - Help writing simple, concise and fast generic operations.  http://hackage.haskell.org/package/uniplate-1.6 (NeilMitchell)
05:17:30 <paolino> tonkman: quickCheck $ elements ['a'..'z'] >>= return . f
05:18:04 <paolino> tonkman: property $ elements ['a'..'z'] >>= return . f
05:18:08 <paolino> sorry
05:18:12 <Axman6> >>=? not =>> or whatever it is properties use?
05:18:18 <Axman6> ah
05:19:49 <paolino> @hoogle quickCheck
05:19:49 <lambdabot> Test.QuickCheck quickCheck :: Testable a => a -> IO ()
05:19:49 <lambdabot> package QuickCheck
05:19:49 <lambdabot> module Debug.QuickCheck
05:21:02 <paolino> @type property
05:21:03 <lambdabot> forall prop. (Testable prop) => prop -> Property
05:22:12 <paolino> mh, maybe I got it wrong ..
05:23:37 <paolino> quickCheck $ elements ['a'..'z'] >>= return . f -- should do
05:24:47 <zygoloid> @check elements ['a'..'z'] >>= return . isAlpha
05:24:48 <lambdabot>   No instance for (Test.QuickCheck.Testable
05:24:48 <lambdabot>                     (Test.QuickCh...
05:25:17 <paolino> :t \f -> quickCheck $ elements ['a'..'z'] >>= return . f
05:25:18 <lambdabot> forall a. (Testable a) => (Char -> a) -> IO ()
05:26:15 <zygoloid> "No instance for (Test.QuickCheck.Testable (Test.QuickCheck.Gen.Gen GHC.Bool.Bool))" <-- lie?
05:26:19 <paolino> :t \f -> fmap f <$> quickCheck (elements ['a'..'z'])
05:26:20 <lambdabot>     Couldn't match expected type `f a' against inferred type `()'
05:26:20 <lambdabot>       Expected type: IO (f a)
05:26:20 <lambdabot>       Inferred type: IO ()
05:27:24 <paolino> :t \f -> fmap (fmap f) <$> quickCheck (elements ['a'..'z'])
05:27:25 <lambdabot>     Couldn't match expected type `f1 (f a)' against inferred type `()'
05:27:25 <lambdabot>       Expected type: IO (f1 (f a))
05:27:25 <lambdabot>       Inferred type: IO ()
05:27:39 <aristid> @let fmap2=fmap.fmap
05:27:40 <lambdabot>  Defined.
05:28:18 <Axman6> :t \f -> quickcheck $ f <$> elemnents ['a'..'b']
05:28:19 <lambdabot> Not in scope: `quickcheck'
05:28:19 <lambdabot> Not in scope: `elemnents'
05:28:36 <Axman6> :t \f -> quickCheck $ f <$> elements ['a'..'b']
05:28:37 <lambdabot> forall b. (Testable b) => (Char -> b) -> IO ()
05:29:22 <paolino> :t \f -> fmap (f <$>) $ quickCheck (elements ['a'..'z'])
05:29:23 <lambdabot>     Couldn't match expected type `f a' against inferred type `()'
05:29:23 <lambdabot>       Expected type: IO (f a)
05:29:23 <lambdabot>       Inferred type: IO ()
05:29:30 <paolino> bah, I stop
05:29:40 <Axman6> :t wuickCheck
05:29:41 <lambdabot> Not in scope: `wuickCheck'
05:29:43 <Axman6> :t quickCheck
05:29:44 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
05:30:41 <paolino> :t (*2) `fmap` id 1
05:30:42 <lambdabot> forall a (f :: * -> *). (Num a, Num (f a), Functor f) => f a
05:35:18 <Axman6> paolino: i don't quite think you get what fmap is supposed to do
05:35:54 <paolino> well, I thought function application was a functor or something
05:36:13 <aristid> :t (*2) `fmap` id $ 1
05:36:14 <lambdabot> forall a. (Num a) => a
05:36:18 <Axman6> is it, but fmap for functions is (.)
05:36:33 <Axman6> @src (->) fmap
05:36:33 <lambdabot> fmap = (.)
05:36:45 <paolino> :)
05:36:53 <aristid> in fact, for lambdabot, (.)=fmap
05:37:15 <hpc> (+2) . Just 5
05:37:18 <hpc> > (+2) . Just 5
05:37:19 <aristid> :t (.)
05:37:19 <lambdabot>   Just 7
05:37:20 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:37:40 <MasseR> Is there a function to go through enums so that they start over if goes over. Like for example with `data Dir = N | E | S | W` and I'd want to go "N -> E -> S -> W -> N -> .."
05:37:59 <hpc> :t succ
05:38:00 <lambdabot> forall a. (Enum a) => a -> a
05:38:07 <hpc> succ True
05:38:09 <hpc> > succ True
05:38:10 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
05:38:28 <paolino> > succ False
05:38:29 <lambdabot>   True
05:38:48 <hpc> MasseR: if you don't mind an Eq constraint, succ' x | x == maxBound = minBound | otherwise = succ x
05:38:50 <emilmeln> > let f x = if x == maxBound then minBound else succ x
05:38:50 <lambdabot>   not an expression: `let f x = if x == maxBound then minBound else succ x'
05:39:37 <MasseR> hpc: Thanks. I'll just make succ' :P
05:39:49 <Jafet> > cycle [minBound .. maxBound] :: [Bool]
05:39:50 <lambdabot>   [False,True,False,True,False,True,False,True,False,True,False,True,False,Tr...
05:40:13 <Jafet> hpc: or a Bounded constraint.
05:40:34 <hpc> it might be fun to make typeclass Toroid, to see what comes of it
05:40:42 <paolino> @src Bounded
05:40:42 <lambdabot> class  Bounded a  where
05:40:42 <lambdabot>     minBound, maxBound :: a
05:40:59 <hpc> given a sufficiently interesting interface specification, of course
05:41:45 <Kul> how to write merge function to merge 2 lists also sort it out in ascending manner
05:42:06 <Axman6> Kul: how do you think you'd do it?
05:42:25 <Kul> Merge [] [] = []
05:42:34 <Axman6> looks like a good start
05:42:36 <Kul> merge xs [] = xs
05:42:49 <Kul> merge [] ys = ys
05:42:52 <paolino> if xs is sorted
05:42:55 <Kul> bt what next ? 
05:43:27 <Axman6> well, i'll start you off: merge (x:xs) (y:ys) = ...
05:43:48 <paolino> :t compare
05:43:49 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
05:44:02 * Axman6 would just use (<)
05:44:03 <hpc> :t fix sort
05:44:04 <lambdabot> forall a. (Ord a) => [a]
05:44:19 <Kul> (x:xs) (y:ys) = if x ? y
05:44:26 <Kul> (x:xs) (y:ys) = if x ? y then
05:44:44 <Axman6> mane ? <
05:44:46 <Axman6> make*
05:45:12 <paolino> > fix sort :: [Int]
05:45:15 <lambdabot>   mueval-core: Time limit exceeded
05:45:18 <Kul> Sorry
05:45:22 <Kul> (x:xs) (y:ys) = if x < y then
05:45:45 <Axman6> so, what do you want to do if x is less than y?
05:46:05 <Kul> x :  merge  xs 
05:46:14 <Kul> (y:ys)
05:46:21 <Kul> x :  merge  xs (y:ys)
05:46:25 <Axman6> but what happened to the other list you're merging, (y:ys?)
05:46:30 <Axman6> )?*
05:46:36 <Axman6> looks good to me
05:46:42 <Kul> else 
05:47:12 <Kul> y : merge ys (x : xs)
05:47:34 <Kul> ?
05:47:36 <Axman6> sure, that'll work
05:47:57 <Axman6> i'd make it maege (x:xs) ys, but they're really the same in this case
05:49:14 <hpc> i think one is easier to recognize and optimize, when it compiles
05:49:21 <Kul> http://www.heypasteit.com/clip/P4X
05:49:58 <Kul> axman6 its not working
05:50:21 <Axman6> x mer: merge xs (y : ys)?
05:50:22 <hpc> is there a compile error?
05:50:26 <Axman6> what's mer?
05:50:44 <Axman6> also, i think your indentation might be wrong
05:51:32 <edlinde> just with this instance defn "instance (Eq m) => Eq (Maybe m) where " .... can we have say two => signs
05:51:41 <edlinde> to add more class constraints?
05:51:53 <Zao> edlinde: I think you use a comma or something.
05:51:54 <Kul> oops
05:52:01 <Kul> M such an idiot 
05:52:02 <edlinde> also how do you do multiple inheritance?
05:52:08 <Axman6> edlinde: (Eq a, Ord a) =>
05:52:20 <edlinde> Axman6: is that multiple inheritance?
05:52:21 <Zao> Inheritance?
05:52:25 <Zao> edlinde: There's no inheritance.
05:52:28 <Axman6> edlinde: what do you mean by multiple inheritance? 
05:52:28 <Zao> It's a term from silly languages.
05:52:34 <edlinde> hmmm
05:52:40 <edlinde> ok wonder what the haskell term is for it
05:52:42 <edlinde> :)
05:52:49 <Axman6> what do you want?
05:52:52 <Zao> A type may have instances for several type classes.
05:52:57 <edlinde> as in my typeclass belongs as a subclass to many other type classes?
05:53:00 <Zao> A type class may have more than one constraint.
05:53:00 <BONUS> there is no equivalent concept in haskell
05:53:22 <BONUS> but yeah, a type class can have several constraints
05:53:36 <edlinde> ok so a type class can have several constraints 
05:53:49 <BONUS> like: class (Eq a, Show a) => MyClass a where ...
05:53:50 <paolino> which are not inherited, they are asked
05:54:02 <edlinde> but say I want a type to derive from multiple typeclasses using say the instance clause.. not deriving (a,b,c)... 
05:54:10 <edlinde> how do you do that?
05:54:22 <hpc> edlinde: write one instance, then the other
05:54:28 <hpc> instance foo blah where baz
05:54:43 <hpc> instance quux blah where gobldegook
05:54:51 <edlinde> ah ok so you write multiple instances for each different typeclass you would like to associate your type to
05:55:03 <Kul> axman6 "ERROR file:c:\test.hs:3 - Syntax error in input (unexpected `=')"
05:55:16 <edlinde> ok now on to functors
05:55:17 <edlinde> ;)
05:55:19 <edlinde> thanks guys
05:55:20 <Axman6> somewhere in the preluse, you'll (hopefully) find these lines, instance Show Int where ... instance Eq Int where... instance Num Int where
05:55:53 <edlinde> Axman6: sorry what did you imply by (Eq a, Ord a) => ?
05:56:01 <hpc> "somewhere in the prelude" meaning between all the preprocessor directives and documentation
05:56:13 <edlinde> BONUS: you use the same thing class (Eq a, Show a) => MyClass a where
05:56:19 <paolino> edlinde: that those instances are present
05:56:22 <paolino> for a
05:56:41 <Kul> axman6 "ERROR file:c:\test.hs:3 - Syntax error in input (unexpected `=')"
05:56:49 <Kul> Axman6 "ERROR file:c:\test.hs:3 - Syntax error in input (unexpected `=')"
05:56:58 <edlinde> but if I make a new typeclass with the class command... is that saying that I am linking this typeclass to Eq and Show?
05:57:02 <Axman6> i saw it the first two times...
05:57:10 <paolino> edlinde it reads "if ais instance of Eq and Ord then ....
05:57:19 <Axman6> Kul: is the code you have exactly what you pasted there?
05:57:28 <Kul> yea
05:57:41 <hpc> Kul: start by looking on the line it says the error was on
05:57:47 <edlinde> paolino: right I think I get it... its saying that only is a is an instance of Eq and Ord it can be used in Myclass yeah?
05:57:49 <Kul> http://www.heypasteit.com/clip/P4Y
05:57:58 <nlogax> what does this mean, in the haskell 2010 grammar? http://paste.pocoo.org/show/6ge9BX58JI3gTBnJ3Ii9/ first time i enountered a `→' inside another `→'
05:58:00 <edlinde> *if a is..
05:58:11 <paolino> edlinde: yes, a constraint on a
05:58:15 <edlinde> ok cool
05:58:21 <Axman6> Kul: you can't have the definition of merge indented
05:58:32 <Axman6> remove all the spaces/tabs before each merge line
05:58:40 <edlinde> I should start by thinking of everything to the left of the "=>" as a constraint
05:58:50 <edlinde> thanks for your time paolino 
05:58:54 <hpc> nlogax: fundeps, it looks like; i am not well versed in that sort of deep magic though
05:58:58 <lars9> @hoogle MaybeT
05:58:58 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
05:59:06 <hpc> MaybeT is /awesome/
05:59:07 <edlinde> paolino: are functors a pain to understand ? ;)
05:59:15 <lars9> @hoogle liftIO
05:59:15 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
05:59:16 <Axman6> edlinde: not at all
05:59:21 <edlinde> kewl
05:59:23 <hpc> it just doesn't have mzero, or Nothing analog
05:59:34 <Axman6> edlinde: you know how map works on lists right?
05:59:34 <Kul> okay dtas fine
05:59:37 <edlinde> it seems to be the last thing in the Types and Typeclasses in LYAH
05:59:39 <Kul> Thanks Its working now! 
05:59:40 <edlinde> yeh
05:59:41 <edlinde> I do
05:59:41 <tonkman> why quickCheck $ elements [1] >>= return . prop_euclid
05:59:43 <tonkman> fails
05:59:52 <tonkman> but prop_euclid 1 1 1 return true
06:00:05 <edlinde> Axman6: I know map yeah... 
06:00:10 <Axman6> edlinde: well, imagine there's a map for Maybe a, how would you define it? mapMaybe f x = ///
06:00:13 <Axman6> ...*
06:00:29 <edlinde> dunno
06:00:32 <paolino> tonkman: how many args prop_euclid has ?
06:00:45 <edlinde> would probably need a new function yeah
06:00:52 <hpc> edlinde: consider a list and a function; map applies the function to the "inside" of the list
06:00:53 <nlogax> hpc: hmm, but this is from here: http://www.haskell.org/onlinereport/haskell2010/haskellch8.html#x15-1560008.4.2 
06:00:53 <tonkman> three
06:00:54 <edlinde> to pattern match with Maybe a and get the a out
06:00:54 <tonkman> prop_euclid :: (Integral a) => a -> a -> Int -> Bool
06:00:57 <hpc> what's the "inside" of the Maybe?
06:01:08 <paolino> :t \prop_euclid -> quickCheck $ elements [1] >>= return . prop_euclid
06:01:09 <lambdabot> forall t a. (Testable a, Num t) => (t -> a) -> IO ()
06:01:23 <edlinde> hpc: a
06:01:46 <hpc> nlogax: ah, then it's a specification of syntax
06:01:51 <edlinde> hpc: what do you mean by "inside" of a list? I thought map just applies a function to every element in the list
06:02:09 <nlogax> hpc: yep. but it's the first time that's been used, and i see no explanation :)
06:02:12 <hpc> edlinde: that's the "inside"; whatever is in the list
06:02:18 <edlinde> ok
06:02:32 <tonkman> paolino: so what is the problem?
06:02:37 <nlogax> so i don't know how to translate it for my PEG
06:02:46 <paolino> :t \prop_euclid -> quickCheck $ replicateM 3 (elements [1]) >>= \[x,y,z] -> return (prop_euclid [x,y,z])
06:02:47 <lambdabot> forall t b. (Testable b, Num t) => ([t] -> b) -> IO ()
06:02:50 <hpc> there's also the "context", which is the idea of there being multiple things, and how many of them
06:02:57 <tonkman> I have to pass two other arguments
06:03:00 <paolino> :t \prop_euclid -> quickCheck $ replicateM 3 (elements [1]) >>= \[x,y,z] -> return (prop_euclid x y z)
06:03:00 <lambdabot> forall t b. (Testable b, Num t) => (t -> t -> t -> b) -> IO ()
06:03:09 <hpc> map changes the "inside" but not the "context", because the length is unchanged
06:03:20 <hpc> in the case of Maybe, the "context" is the presence or lack of a thing
06:03:35 <Axman6> edlinde: so, can you see a parttern here? we want to be able to apply functions from a to be on things inside other things
06:03:52 <Axman6> this is what fmap does, and the things that contain the a's are functors
06:03:59 <paolino> tonkman: it shouldn't compile with one arg
06:04:17 * Axman6  -> sleep
06:04:41 <ManateeL`> I think it's time to release my project : Manatee.
06:04:52 <paolino> goodnight
06:06:19 <hpc> edlinde: walk me through your thoughts so i can give you a nudge towards the solution
06:06:39 <emilmeln> hpc: What's the context in case of "fmap = (.)"?
06:07:08 <hpc> emilmeln: save that until you understand simpler cases; functions are really hard to grok
06:07:38 <hpc> you already understand the list functor
06:07:40 <hpc> fmap = map
06:07:59 <hpc> so perhaps a Maybe can be thought of as a list of either zero or one elements?
06:08:05 <paolino> @instances Functor
06:08:06 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:08:58 <hpc> emilmeln: so what's map f []?
06:09:24 <paolino> > 1 `fmap` (2,0)
06:09:25 <lambdabot>   (2,1)
06:09:31 <emilmeln> hpc: I already understand all these "contexts" and know how functors work, but the context for function composition is a dark place.
06:09:37 <Zhuangzi> @hoogle ((a -> b) -> b -> c) -> (a -> b) -> a -> c
06:09:37 <lambdabot> No results found
06:09:40 <hpc> ah, k
06:09:45 <Zhuangzi> @pl \f x -> f x . x
06:09:45 <lambdabot> ((.) =<<)
06:09:49 <paolino> emilmeln: ((->) r)
06:09:52 <hpc> so, you have f :: a -> b
06:10:05 <hpc> which we can write as f :: (->) a b
06:10:19 <hpc> or, f :: ((->) a)     b -- spacing mine
06:10:40 <hpc> so the "inside" of a function is the result it gives
06:10:55 <hpc> how do we apply a function to the result of a function? why, function composition!
06:11:02 <emilmeln> hp: Oh, I've just got it!
06:11:04 <hpc> (f . g) x = f (g x)
06:11:12 <emilmeln> hpc: Thanks a lot.
06:11:36 <Zhuangzi> hpc: know where there's a \f g -> f g . g?
06:11:45 <hpc> there's an infix version of fmap called (<$>)
06:11:48 <emilmeln> > f :: ((->) a)     b
06:11:48 <emilmeln> This was really helpful.
06:11:49 <lambdabot>   Could not deduce (GHC.Show.Show a, SimpleReflect.FromExpr b)
06:11:49 <lambdabot>    from the co...
06:12:02 <hpc> this turns out to be so useful that for lambdabot, we made (.) = fmap instead
06:12:07 <paolino> the point is that f . g still goes from a to something if g was going from a to something
06:12:13 <hpc> to save keystrokes, and blow newbies' minds
06:12:27 <hpc> :t \f g -> f g . g
06:12:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (f a -> a -> b) -> f a -> f b
06:12:54 <Zhuangzi> I've finally got: trim = co (bi reverse) (dropWhile isSpace)
06:13:02 <Zhuangzi> I'm happy with bi f g = f . g . f
06:13:07 <Zhuangzi> (as in bijection)
06:13:26 <hpc> :t \f g -> f . g . f
06:13:27 <lambdabot> forall a b. (a -> b) -> (b -> a) -> a -> b
06:13:36 <hpc> heh, nifty
06:13:49 <Zhuangzi> but I don't like co f g = f g . g, because 'co' is "copy-and-compose"
06:14:04 <paolino> :t ap
06:14:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:14:05 <Zhuangzi> I'm thinking there's a much more general way to do these things than defining cute little functions
06:14:22 <hpc> :t with
06:14:23 <lambdabot> Not in scope: `with'
06:14:24 <Zhuangzi> for some reason I thought about ap and then disregarded it. duh
06:14:27 <emilmeln> All we need is find an application for this function :)
06:14:39 <Zhuangzi> hpc: lol, I called it `with' originally. I prefer bi :p
06:14:45 <hpc> @hoogle (a -> b) -> (b -> a) -> a -> b
06:14:45 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
06:14:45 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
06:14:45 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
06:15:18 <hpc> Zhuangzi: i might have to start using that
06:15:21 <Zhuangzi> no, ap isn't right..
06:15:26 <hpc> it assumes f is its own inverse though
06:15:26 <Zhuangzi> hpc: bi? :-)
06:15:39 <Zhuangzi> yeah, that's why it's called 'bi', as in bijection, involution
06:15:57 <Zhuangzi> maybe 'inv' is better
06:16:02 <Zhuangzi> has to be short! :P
06:16:10 <hpc> perhaps class Bijective a b where func :: a -> b; cofunc :: b -> a
06:16:40 <hpc> bi :: Bijective a b => (b -> b) -> a -> a
06:16:59 <Zhuangzi> ah, to bring it into the type system
06:17:09 <Zhuangzi> I like it
06:17:31 <hpc> then you have the Bijective law: func . cofunc = cofunc . func = id
06:17:35 <Zhuangzi> yeah
06:17:54 <Zhuangzi> where should it go?
06:17:55 <Zhuangzi> what module
06:18:15 <lars9> in math the form f * g = id if g = f^(-1) is very common, is there any related concept in haskell about it?
06:18:59 <hpc> lars9: not automagically, since a computational proof isn't always possible; it's probably percolating in the minds of most people here though
06:19:27 <hpc> whoa, i am awesome: http://hackage.haskell.org/packages/archive/TypeCompose/0.6.4/doc/html/Data-Bijection.html
06:19:42 <emilmeln> class BijectiveM m a b where funcM :: a -> m b; cofuncM :: b -> m a ? Seems like a usable type class...
06:19:51 <Zhuangzi> bah, I looked at type compose before on the wiki but didn't see it
06:20:08 <hpc> though they do it with data...
06:20:29 <arcatan> i bet if you looked at some QuickCheck tests, there'd be lots of properties which say f . g = id for many functions
06:20:47 <Zhuangzi> :t bimap
06:20:48 <lambdabot> Not in scope: `bimap'
06:20:54 <Zhuangzi> :t Data.Bijection.bimap
06:20:55 <lambdabot> Couldn't find qualified module.
06:21:04 <Zhuangzi> @slap herself
06:21:04 <lambdabot> Come on, let's all slap herself
06:21:11 <Zhuangzi> damn.
06:21:13 <lars9> (--->) :: Arrow ~> => Bijection ~> a b -> Bijection ~> c d -> (a ~> c) :<->: (b ~> d)
06:21:26 <lars9> wt*... can it be any longer
06:22:43 <hpc> inBi is what you would be looking for
06:23:12 <hpc> personally, i would go with the typeclass approach, so you aren't wrapping and unwrapping from data
06:23:37 <hpc> plus, Bijection a b => foo looks nicer than whatever mess that package has going on
06:24:07 <ader111> in parsec I am trying to match a :variableName. The idea is that I have an Sql like syntax with :variable inside so that I can replace them with actual values
06:24:28 * hpc -> class
06:25:01 <Zhuangzi> hpc: yus, the data wrapping/unwrapping isn't what I'm after
06:26:58 <Zhuangzi> hpc: Control.Function? Control.Category.Function? ._.
06:28:11 <Zhuangzi> actually the class doesn't help
06:28:23 <Zhuangzi> for what do I implement Bijective?
06:29:15 <Zhuangzi> for Bijective [a] [b] it could be reverse or just id
06:30:41 <Zhuangzi> I'm left with newtype wrapping
06:30:46 * hackagebot manatee-core 0.0.1 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.1 (AndyStewart)
06:31:48 * hackagebot manatee-anything 0.0.1 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.1 (AndyStewart)
06:31:50 * hackagebot manatee-browser 0.0.1 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.1 (AndyStewart)
06:31:52 * hackagebot manatee-editor 0.0.1 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.1 (AndyStewart)
06:31:54 * hackagebot manatee-filemanager 0.0.1 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.1 (AndyStewart)
06:31:56 * hackagebot manatee-pdfviewer 0.0.1 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.1 (AndyStewart)
06:33:19 <EvanR-work> :o
06:33:21 <aristid> ManateeLazyCat: putting everything on hackage?
06:33:28 <ManateeLazyCat> aristid: Yes.
06:33:28 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
06:33:46 * hackagebot manatee-mplayer 0.0.1 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.1 (AndyStewart)
06:33:48 * hackagebot manatee-ircclient 0.0.1 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.1 (AndyStewart)
06:33:51 * hackagebot manatee-processmanager 0.0.1 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.1 (AndyStewart)
06:33:53 * hackagebot manatee-imageviewer 0.0.1 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.1 (AndyStewart)
06:33:55 * hackagebot manatee-reader 0.0.1 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.1 (AndyStewart)
06:34:05 <EvanR-work> :O
06:34:08 <ManateeLazyCat> aristid: I think it's time to share my project.
06:34:14 <ManateeLazyCat> EvanR-work: Never end. :)
06:34:19 <EvanR-work> lol
06:34:28 * EvanR-work is washed away 
06:34:38 <Zhuangzi> By the time hackagebot's finished listing these, ManateeLazyCat will have written five more packages.
06:34:57 * hackagebot manatee 0.0.1 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.1 (AndyStewart)
06:34:58 <ManateeLazyCat> Zhuangzi: https://patch-tag.com/r/AndyStewart/
06:35:10 <ManateeLazyCat> EvanR-work: Ok, now all manatee package upload finish.
06:35:31 <ManateeLazyCat> Enjoy all. :)
06:36:03 <ManateeLazyCat> After install gtk2hs-0.12.0 (I have release it), just install above package with the sequence i post.
06:36:12 <ManateeLazyCat> Then type command "manatee" to play it. :)
06:36:43 <ManateeLazyCat> @package manatee
06:36:43 <lambdabot> http://hackage.haskell.org/package/manatee
06:36:52 <tab> ManateeLazyCat: cool !
06:37:00 <EvanR-work> manatee is an OS written in haskell?
06:37:05 <ManateeLazyCat> I have write detail document (include install manual) at http://hackage.haskell.org/package/manatee
06:37:11 <ManateeLazyCat> EvanR-work: Yes.
06:37:38 <tab> it's more like an desktop environment i think
06:37:53 <EvanR-work> yeah and emacs is a text editor
06:37:54 <ManateeLazyCat> tab: It's new software.
06:38:12 <tab> ManateeLazyCat: but you still use Xorg and gtk (on unix)
06:38:15 <ManateeLazyCat> tab: It's not *desktop* environment, 
06:38:44 <ManateeLazyCat> tab: Yes, now i want build all generic software first, then deep in...
06:39:16 <ManateeLazyCat> My project just beginning, so don't expect too much, i release it just because it's framework is stable now.
06:39:23 <tab> sure
06:39:25 <EvanR-work> a replacement for xorg would be interesting
06:39:28 <ManateeLazyCat> And hope more people write cool extension for it.
06:39:35 <quicksilver> it's an application framework in, sort-of, the same kind of sense as eclipse or lotus notes.
06:39:48 <lars9> ManateeLazyCat: hi any screenshot?
06:39:54 <quicksilver> cooperating modules/applications
06:39:54 <tab> EvanR-work: wayland ?
06:39:56 <ManateeLazyCat> Let's build real-world software in Haskell !
06:39:59 <quicksilver> lars9: http://www.flickr.com/photos/48809572@N02/
06:40:10 <lars9> quicksilver: thanks
06:40:11 <ManateeLazyCat> lars9: http://goo.gl/MkVw
06:40:32 <ManateeLazyCat> Editor still basic, because haven't time perfect it.
06:40:39 <lars9> ManateeLazyCat: awesome!
06:40:49 <ManateeLazyCat> But now i think i can focus my time on IDE and terminal extension.
06:40:54 <EvanR-work> btw what font do you use for chinese?
06:41:26 <ManateeLazyCat> EvanR-work: WenYuanYi font.
06:41:34 <EvanR-work> ah that one
06:41:42 <EvanR-work> theres a bitmap version right?
06:41:57 <quicksilver> ManateeLazyCat: will you announce to haskell-cafe?
06:42:18 <ManateeLazyCat> quicksilver: Yep, i'm writing documentation now. :)
06:42:45 <EvanR-work> this looks pretty good
06:42:58 <EvanR-work> it doesnt require gnome right
06:43:07 <ManateeLazyCat> EvanR-work: No, it's base on Google Droid font : http://wenq.org/forum/viewtopic.php?f=4&t=764
06:43:53 <ManateeLazyCat> I hate fix bugs, i spend one month make core stable enough. Oh, my god, i can write new extension now. :)
06:43:54 <EvanR-work> ManateeLazyCat: manatee
06:44:13 <EvanR-work> wenyuanyi is a community effort i thought
06:44:19 <EvanR-work> theres a webapp to draw glyphs
06:44:29 <ManateeLazyCat> EvanR-work: Yes.
06:44:49 <EvanR-work> manatee doesnt require gnome right, its 'lightweight'? ;)
06:45:08 <kalven> what's the latest haskell-mode version?
06:45:11 <ManateeLazyCat> EvanR-work: I use MicroHei -- a OpenSource font of WenYuanYi.
06:45:22 <ManateeLazyCat> EvanR-work: WenYuanYi build many *free* font.
06:45:29 <EvanR-work> right
06:45:34 <ManateeLazyCat> EvanR-work: Yes, don't need gnome or any desktop environment.
06:45:52 <EvanR-work> 'manatee develop' ?
06:45:56 <EvanR-work> extension?
06:46:15 <ManateeLazyCat> EvanR-work: Manatee is multi-processes framework to build GTK+ application.
06:46:49 <ManateeLazyCat> EvanR-work: An extension mean you can use gtk2hs write any application you want, and manatee provide framework to draw your application, and protected your application in sandbox.
06:47:16 <ManateeLazyCat> EvanR-work: So my aim is build a fast, safe, flexibility Haskell environment let haskeller hacking it.
06:47:18 <EvanR-work> what do the screen shots show, extensions?
06:47:30 <EvanR-work> or applications built on the framework?
06:47:56 <ManateeLazyCat> EvanR-work: goo.gl/MkVw
06:48:17 <ManateeLazyCat> EvanR-work: http://www.flickr.com/photos/48809572@N02/5031811365/lightbox/ this is framework
06:49:24 <ManateeLazyCat> EvanR-work: I think perfect combination is Manatee ++ XMOnad.
06:49:55 <Saizan> ManateeLazyCat: is there something i need to do after "cabal instal manatee-pdfviewer" ? 
06:50:08 <Saizan> saizan@astarte:~$ manatee-pdfviewer --help
06:50:08 <Saizan> manatee-pdfviewer: Prelude.read: no parse
06:50:12 <Saizan> i get that :)
06:50:20 <ManateeLazyCat> Saizan: cabal install manatee-core manatee-anything manatee-browser manatee-editor manatee-filemanager manatee-imageviewer manatee-ircclient manatee-mplayer manatee-pdfviewer manatee-processmanager manatee-reader manatee
06:50:31 <ManateeLazyCat> Saizan: manatee-core is basic protocol and toolkit package.
06:50:48 <EvanR-work> what browser does it use
06:50:48 <Saizan> ManateeLazyCat: do i have to install all of them if i just want to use the pdfviewer?
06:50:51 <ManateeLazyCat> manatee-anything is input/search plugin for manatee, like QuickSliver for Mac.
06:50:54 <quicksilver> EvanR-work: webkit-gtk
06:51:09 <ManateeLazyCat> Saizan: You can just install manatee-core manatee-anything manatee-pdfviewer manatee.
06:51:20 <ManateeLazyCat> Saizan: So you just can use manatee-pdfviewer
06:52:02 <ManateeLazyCat> Saizan: After you install "manatee-core manatee-anything manatee-pdfviewer manatee", you can type the filepath of your pdf, then type RETURN, will show your PDF documentation.
06:52:18 <ManateeLazyCat> Saizan: I build a config file to read extension in runtime.
06:52:25 <EvanR-work> quicksilver: is that a haskell library or not haskell related
06:52:36 <tab> EvanR-work: not haskell related
06:52:43 <ManateeLazyCat> EvanR-work: I use webkit engine.
06:53:00 <quicksilver> EvanR-work: it is not haskell related except insofar as there is a binding for it
06:53:00 <EvanR-work> i can customize the browser with haskell?
06:53:02 <tab> EvanR-work: it's what powering google chrome and safari, and all new browser on linux (midori, uzbl) ..
06:53:15 <quicksilver> EvanR-work: (can you really be on the internet without knowing what webkit and gtk are? ;)
06:53:18 <ManateeLazyCat> @package webkit
06:53:19 <lambdabot> http://hackage.haskell.org/package/webkit
06:53:21 <ManateeLazyCat> EvanR-work: ^^^^^
06:53:36 <EvanR-work> i know what webkit and gtk are, i was asking about this sequence of characters "webkit-gtk"
06:53:45 <EvanR-work> not that i use gtk much
06:54:20 <tab> EvanR-work: just the integration of webkit into gtk stuff
06:54:26 <quicksilver> the official name is "WebKit/GTK+", I think, I was just conveniently forming a compound noun.
06:54:52 <EvanR-work> is the manatee browser easily hackable with haskell
06:54:57 <EvanR-work> hackskellable
06:55:04 <ManateeLazyCat> Saizan: After you entry in pdf-viewer, you can type "j" or "k" to scroll page.
06:55:17 <ManateeLazyCat> Saizan: Like vim's keystroke. :)
06:55:28 <ManateeLazyCat> EvanR-work: manatee-browser.
06:55:45 <EvanR-work> i would love to have direct control of my browser
06:55:49 <ManateeLazyCat> EvanR-work: Yes, 
06:55:58 <ManateeLazyCat> EvanR-work: It's your browser, that write from scratch.
06:56:04 <EvanR-work> haha
06:56:20 <EvanR-work> javascript?
06:56:38 <ManateeLazyCat> EvanR-work: Well, i just finish core framework, all sub-module framework still not finish.
06:56:56 <ManateeLazyCat> EvanR-work: But that's why i release it, i hope some professional help me.
06:57:07 <ManateeLazyCat> EvanR-work: I haven't time finish *all* extension.
06:57:13 <EvanR-work> you are a pro now
06:57:40 <ManateeLazyCat> EvanR-work: Now just framework finish, still have long way to perfect detail.
06:58:12 <ManateeLazyCat> Saizan: manatee-pdfviewer or manatee-browser, all those are *extension* to manatee-core.
06:58:50 <ManateeLazyCat> Saizan: And those extension can't work standalone, must running in manatee framework.
06:58:51 <Jafet> A browser without javascript doesn't sound that scary anymore, these days...
06:59:17 <ManateeLazyCat> Jafet: I know, i just haven't time finish javascript framework for browser sub-module
06:59:22 <Jafet> But I guess manatee is still using webkit like he used to (right?)
06:59:25 <Saizan>  ManateeLazyCat i see
06:59:33 <EvanR-work> i certainly avoid js in my own pages
06:59:45 <ManateeLazyCat> Saizan: But you can't choose don't install other extension.
07:00:24 <ManateeLazyCat> Saizan: In search interface, when you type file, it will try to search all software for current file. if not found manatee default extension, it will try to call software in your system.
07:00:39 <ManateeLazyCat> Saizan: You even can install "manatee-core manatee-anything manatee" don't install any extension.
07:01:16 <lars9> :t msum
07:01:17 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
07:01:36 <ManateeLazyCat> Saizan: When you type pdf filepath, it will search all pdf viewer in your system, and you can type "M-/" to choose those pdf viewer, but then manatee not like integrated environment, more like "application launcher" .:)
07:01:44 <EvanR-work> > msum [Just 3, Just 5]
07:01:45 <lambdabot>   Just 3
07:01:52 <EvanR-work> > msum [Just 3, Just 5, Nothing]
07:01:53 <lambdabot>   Just 3
07:01:55 <ManateeLazyCat> Jafet: Yes.
07:02:05 <EvanR-work> > msum [Nothing, Just 3, Just 5]
07:02:06 <lambdabot>   Just 3
07:02:09 <ManateeLazyCat> Jafet: Just haven't finish deep features like popup browser.
07:02:31 <EvanR-work> > msum [Nothing, Just (), Just ()]
07:02:32 <lambdabot>   Just ()
07:02:33 <lars9> :t msum [[a]]
07:02:34 <lambdabot> [Expr]
07:02:55 <EvanR-work> :t msum [[undefined]]
07:02:56 <lambdabot> forall a. [a]
07:03:20 <lars9> :t sum [[undefined]]
07:03:21 <lambdabot> forall a. (Num [a]) => [a]
07:03:39 <ManateeLazyCat> Ok, i think best to write in haskell-cafe.
07:03:54 <EvanR-work> lars9: well now you propose a list with a Num instance
07:04:00 <EvanR-work> > [] + []
07:04:01 <lambdabot>   No instance for (GHC.Num.Num [a])
07:04:01 <lambdabot>    arising from a use of `e_1' at <intera...
07:04:05 <lars9> > msum [[1..4], [5..9]]
07:04:06 <lambdabot>   [1,2,3,4,5,6,7,8,9]
07:04:20 <lars9> EvanR-work: oh it should be concat
07:04:37 <EvanR-work> or mconcat
07:04:38 <lars9> :t concat
07:04:39 <lambdabot> forall a. [[a]] -> [a]
07:04:47 <EvanR-work> :t mconcat [[undefined]]
07:04:47 <lambdabot> forall a. [a]
07:04:48 * ManateeLazyCat pasted "keymap" at http://paste2.org/get/1082724
07:04:48 <ManateeLazyCat> Saizan: Above is keymap use in manatee-anything (search interface when you open manatee). 
07:04:57 <lars9> @index msum
07:04:58 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:05:20 <ManateeLazyCat> Saizan: Unfortunately, still not support customize option now, i think i will add customize system in the future version.
07:05:38 <lars9> EvanR-work: mconcat is not in control.monad?
07:05:42 <EvanR-work> Data.Monoid
07:05:58 <Saizan> ManateeLazyCat: i managed to run the pdf-viewer :) though "j" and "k" don't seem to do anything
07:06:18 <ManateeLazyCat> Saizan: You have in pdfviewer?
07:06:28 <lars9> @instances Monoid
07:06:29 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
07:06:37 <lars9> @instances Monad
07:06:38 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
07:07:01 <ManateeLazyCat> Saizan: Or your pdf documentation just open page?
07:07:08 <lars9> @instances MonadPlus
07:07:09 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
07:08:11 <lars9> EvanR-work: the msum in this http://en.wikibooks.org/wiki/Haskell/Monad_transformers is really awesome
07:08:23 <ManateeLazyCat> Saizan: Can you see pdf documentation in pdfviewer?
07:08:31 <tonkman> how do I apply seq for "somef a b c"
07:08:32 <lars9> EvanR-work: 1st msum
07:08:54 <tonkman> I want to evaluate all arguments, a, b, c
07:09:01 <Saizan> ManateeLazyCat: i see the pdf i choose in what seems like a pdfviewer, it says Mode (Pdf) Page at the bottom left
07:09:18 <ManateeLazyCat> Saizan: "j" and "k" can't work?
07:09:40 <tonkman> somef returns wrong answer, but not with number values
07:09:56 <ManateeLazyCat> Saizan: Yes, when you in extension, i will add name of current mode at statusbar.
07:10:12 <ManateeLazyCat> Saizan: "j" and "k" for scroll page line.
07:10:17 <Saizan> ManateeLazyCat: no, they don't work, i can scroll with the mouse though
07:10:18 <lars9> EvanR-work: here: "value <- msum $ repeat getValidPassword", really inspiring to me
07:10:25 <ManateeLazyCat> Saizan: " " and "b" for scroll screen page.
07:10:33 <quicksilver> tonkman: a `seq` b `seq` c `seq` somef a b c
07:10:37 <ManateeLazyCat> Saizan: "j/k" scroll line.
07:10:54 <ManateeLazyCat> Saizan: "n/p" to jump next/previous page.
07:11:00 <Saizan> ManateeLazyCat: ah, i see
07:11:22 <ManateeLazyCat> Saizan: So maybe scroll too little you haven't notice it?
07:11:41 * ManateeLazyCat pasted "pdf viewer keymap" at http://paste2.org/get/1082749
07:11:45 <ManateeLazyCat> Saizan: Above is keymap for pdf viewer.
07:11:58 <ManateeLazyCat> Saizan: So works now?
07:12:04 <tonkman> still a wrong answer
07:12:08 <tonkman> same as before
07:12:16 <quicksilver> tonkman: seq never changes the answer.
07:12:30 <quicksilver> tonkman: it only finds some _|_ earlier, or changes space behaviour.
07:12:35 <quicksilver> tonkman: what are you trying to do?
07:13:04 <ManateeLazyCat> Saizan: Try type "M-t" in manatee.
07:13:05 <quicksilver> ManateeLazyCat: you should make keymaps discoverable in some universal way
07:13:18 <quicksilver> ManateeLazyCat: so there is always a way to find out what keys are active in the current extension.
07:13:21 <ManateeLazyCat> quicksilver: Yes, i'm working on customize system
07:13:23 <tonkman> Im trying to map powerMod over a list of big ints
07:13:32 <tonkman> or integers
07:13:41 <quicksilver> tonkman: can you show us some code which doesn't work?
07:13:43 <ManateeLazyCat> quicksilver: Customize system will read all customize option (include keymap) and show with graphics interface.
07:13:50 <quicksilver> tonkman: (and an explanation of what you expect)
07:14:00 <JohnnyL> http://dpaste.com/273225/      <-- bug in GHC
07:14:06 <ManateeLazyCat> quicksilver: And i have plan show current keymap when you type C-? something.
07:14:18 <quicksilver> ManateeLazyCat: to me, keymaps seem to be a lower-level idea than customisation in general. But the C-? something sounds good :)
07:14:20 <Saizan> ManateeLazyCat: none of those keybindings seem to work in the pdfviewer
07:14:38 <quicksilver> JohnnyL: no, it is not.
07:14:47 <tonkman> quicksilver: a minute, I edit it bit
07:14:48 <lars9> sounds like Haskell OS http://lambda-the-ultimate.org/node/299
07:15:03 <dblhelix> JohnnyL: doesn't seem a bug to me
07:15:04 <ManateeLazyCat> Saizan: Do you install gtk-serialized-event ?
07:15:16 <dblhelix> JohnnyL: don't you miss at least one comma in your snippet?
07:15:33 <ManateeLazyCat> Saizan: gtk-serialized-event use to pass GTK+ event between processes.
07:15:53 <Saizan> ManateeLazyCat: the haskell package is installed, maybe i lack something on the C side?
07:16:03 <ppavelV6> hi list
07:16:09 <ManateeLazyCat> Saizan: gtk-serialized-event is pure haskell. :)
07:16:10 <JohnnyL> http://dpaste.com/273440/
07:16:11 <dblhelix> > Data.List.elemIndex 4 [1, 2, 3, 45]
07:16:12 <JohnnyL> ^^ bug
07:16:12 <lambdabot>   Nothing
07:16:26 <dblhelix> > Data.List.elemIndex 4 [1, 2, 3, 4, 5]
07:16:27 <lambdabot>   Just 3
07:16:45 <ManateeLazyCat> Saizan: Do you saw highlight box (color is orange) around pdfviewer?
07:17:03 <Saizan> ?type Data.List.elemIndex
07:17:04 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
07:17:11 <ManateeLazyCat> quicksilver: Just haven't time fix all those detail, but i will consider, thanks for your suggestion. :)
07:17:15 <dblhelix> JohnnyL: no bug :)
07:17:23 <paolino> bugged
07:17:25 <JohnnyL> dblhelix: ok, if you say so.
07:17:38 <Saizan> JohnnyL: check the documentation for elemIndex, it doesn't do what you think it does
07:17:40 <dblhelix> JohnnyL: that's the spirit :)
07:17:43 <paolino> it return the index
07:17:44 <JohnnyL> ok
07:17:45 <ManateeLazyCat> Saizan: Do you use XMonad?
07:17:46 <JohnnyL> :)
07:17:49 <Saizan> ManateeLazyCat: yep
07:18:11 <ManateeLazyCat> Saizan: I haven't test Manatee with XMonad.
07:18:16 <tonkman> quicksilver: http://hpaste.org/41352/rsatest
07:18:42 <tonkman> lines 2-10 are not important
07:18:49 <Saizan> ManateeLazyCat: ah, that might be it, the keys work in the search menu though
07:18:58 <ManateeLazyCat> Saizan: Manatee use DBus to pass message or GTK+Event to sub-processes (that pdfviewer running). 
07:19:10 <roconnor> Is (Const Foo) a monad?
07:19:43 <pumpkin> what's the definition of Const?
07:19:46 <ManateeLazyCat> Saizan: Then i think GTK+Event haven't pass to sub-process, even Daemon process (search menu running) have handle it.
07:19:48 <dblhelix> JohnnyL: just out of curiosity ;-), what result did you expect from, say, elemIndex 4 [1, 2, 3, 45] ?
07:19:56 <pumpkin> data Const a b = Const a?
07:20:02 <roconnor> newtype Const a b = Const { getConst :: a }
07:20:25 <dblhelix> roconnor: I suppose it is
07:20:26 <pumpkin> return :: b -> Const a b
07:20:39 <pumpkin> depends if Foo can be constructed, I guess :P
07:20:42 <ManateeLazyCat> Saizan: Do you have gnome ?
07:20:47 <roconnor> er
07:20:51 <ManateeLazyCat> Saizan: I'm sure Gnome can work
07:20:51 <tonkman> quicksilver: any idea?
07:20:52 <roconnor> pumpkin: where Foo is a monoid
07:20:55 <roconnor> I forgot to add
07:20:59 <pumpkin> then I think so
07:21:04 <Saizan> ManateeLazyCat: no
07:21:10 <quicksilver> tonkman: that code is fine. your problem is somewhere else.
07:21:11 <dblhelix> return x = Const mempty
07:21:20 <quicksilver> tonkman: I have no idea what cryptmsg will be
07:21:46 <lars9> @index listT
07:21:47 <lambdabot> Language.Haskell.TH.Lib, Language.Haskell.TH
07:21:47 <tonkman> [14348907,46824634,24300000]
07:21:53 <McManiaC> is there a difference between "instance Foo Bar" and "instance Foo Bar where"? will the first version derive everything (if possible)?
07:22:05 <dblhelix> roconnor: ah, wait: how would you define (>>=) ?
07:22:05 <Saizan> McManiaC: no
07:22:13 <roconnor> dblhelix: I don't think it is possible
07:22:23 <dblhelix> roconnor: you're right, I suppose
07:22:26 <pumpkin> roconnor: that sounds like basically a Writer that has no value
07:22:27 <Saizan> "Const a >>= _ = Const a" ?
07:22:44 <Saizan> not so useful
07:22:53 <fryguybob> > elemIndex 4 ([1,2,3,18446744073709551620] :: [Int])
07:22:53 <lambdabot>   Just 3
07:22:57 <ManateeLazyCat> Saizan: I doubt "system dbus daemon process" not running in XMOnad. 
07:23:03 <tonkman> if I set the variables in ghci like let n = ...
07:23:06 <dblhelix> Saizan: type checks, now prove the monad laws ;-)
07:23:13 <ManateeLazyCat> Saizan: Ok, i try install XMonad to test manatee. :)
07:23:15 <quicksilver> tonkman: I don't believe you.
07:23:24 <tonkman> and type decrypt dExp n cryptmsg, it wont work
07:23:25 <ManateeLazyCat> Saizan: Thanks for your report
07:23:30 <quicksilver> tonkman: I don't believe you.
07:23:33 <tonkman> should I paste whole code?
07:23:36 <quicksilver> tonkman: yes.
07:23:41 <Saizan> ManateeLazyCat: i had to run manatee inside dbus-launch
07:23:56 <Saizan> ManateeLazyCat: np
07:24:45 <ManateeLazyCat> Saizan: But mouse event is not use DBus, so you still can use mouse view pdf documentation. :)
07:25:18 <Saizan> dblhelix: "return x >>= f = f x" fails.
07:25:25 <Saizan> ManateeLazyCat: yeah :)
07:25:39 <ManateeLazyCat> Saizan: Render correctly?
07:25:42 <tonkman> quicksilver: http://hpaste.org/41353/the_code_that_works
07:25:51 <lars9> > liftM (+1) $ Just 3
07:25:51 <lambdabot>   Just 4
07:25:52 <tonkman> there are two modules
07:26:20 <Saizan> ManateeLazyCat: some lines are mangled actually
07:26:52 <ManateeLazyCat> Saizan: Do you install package poppler-data ?
07:27:02 <ManateeLazyCat> Saizan: poppler-data is for render Unicode font.
07:27:08 <lars9> :t lift
07:27:09 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
07:27:17 <ManateeLazyCat> @package manatee-pdfviewer
07:27:18 <lambdabot> http://hackage.haskell.org/package/manatee-pdfviewer
07:27:26 <dblhelix> Saizan: what about Const x >>= f = Const (x `mappand` runConst (f undefined)) ?
07:27:26 <quicksilver> tonkman: what was your test message?
07:27:28 <Jiten> code.haskell.org appears to be timing out for me.
07:27:38 <dblhelix> Saizan: maybe parametricity is helping us out here?
07:27:39 <quicksilver> tonkman: the one which produces "[14348907,46824634,24300000]"
07:27:45 <dblhelix> Saizan: oh wait, it doesn't
07:27:53 <Jiten> does it work for someone?
07:27:54 <paolino> tonkman , possible there is an Int/Integer mismatch ?
07:27:54 <ManateeLazyCat> Saizan: http://hackage.haskell.org/package/manatee-pdfviewer i have write documentation how to fix garbled in pdf documentation
07:28:09 <dblhelix> Saizan: f is not required to be polymorphic in its input type...
07:28:20 <ManateeLazyCat> Saizan: Install poppler-data and change font (you must have that) in /etc/fonts/conf.d/
07:28:20 <ManateeLazyCat> 49-sansserif.conf
07:28:33 <ManateeLazyCat> Saizan: /etc/fonts/conf.d/49-sansserif.conf 
07:28:48 <quicksilver> tonkman: ah, "asd" I worked it out ;)
07:29:04 <ManateeLazyCat> Saizan: Keystroke "M-t" and "M-T" can work for you?
07:29:06 <lars9> @hoogle IO a -> a
07:29:06 <lambdabot> Foreign unsafePerformIO :: IO a -> a
07:29:07 <lambdabot> Data.ByteString.Internal inlinePerformIO :: IO a -> a
07:29:07 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
07:29:30 <tonkman> "asd" it is :)
07:29:59 <lars9> @hoogle IO String -> String
07:30:00 <lambdabot> Network.URI normalizeCase :: String -> String
07:30:00 <lambdabot> Network.URI normalizeEscape :: String -> String
07:30:00 <lambdabot> Network.URI normalizePathSegments :: String -> String
07:30:01 <Saizan> ManateeLazyCat: no
07:30:25 <tonkman> paolino: possibly
07:30:34 <ManateeLazyCat> Saizan: Hmm, i think DBus message not receive by sub-processes. 
07:31:07 <ManateeLazyCat> Saizan: I suggest you install "webkit manatee-browser"
07:31:09 <ppavelV6> is there any way to "force" floating out with ghc? i have a code like f n data = map (convertor n) data, where convertor is complex on first argument but not on second (preparing a matrix then multiplying a vector)
07:31:12 <quicksilver> tonkman: I think it's something do with what paolino says yes
07:31:31 <ManateeLazyCat> Saizan: Then you can type url in search interface, and open it in browser.
07:31:39 <ManateeLazyCat> Saizan: And mouse always work. :)
07:31:46 <tonkman> I try to chance all Integrals to Integers
07:31:59 <ManateeLazyCat> Saizan: Ok, i will install Xmonad after i post to haskell-cafe. 
07:32:07 <ManateeLazyCat> Saizan: I will let you know if i fix it. 
07:32:12 <Saizan> ManateeLazyCat: ok, cheers :)
07:32:38 <ManateeLazyCat> Saizan: BTW, do you like the design of "search interface" ?
07:33:02 <quicksilver> tonkman: If you set "default (Int)" then both examples break, which is at least consistent.
07:33:07 <ManateeLazyCat> Saizan: Search and type "M-/" to select command to execute it. 
07:33:37 <quicksilver> tonkman: so the problem is that "decrypt" can run with generalised type Integer (and when you give it plain numeric literals, it will)
07:34:18 <quicksilver> tonkman: but something else is using Int and forcing the type to Int
07:34:36 <ezyang> Say I have an inplace set of GHC binaries, and I'd like to compile some Hackage package with it and then use it for another test program. What's the easiest way to do this? 
07:34:51 <quicksilver> tonkman: "toNums" is the culprit
07:34:55 <Saizan> ManateeLazyCat: i'd expect double-click to do the same as M-N
07:35:02 <tonkman> oh, I see
07:35:04 <tonkman> fuuu...
07:35:11 <payo> where should i go to learn how to output grafx? ima make a game
07:35:16 <payo> with haskell
07:35:43 <Saizan> ManateeLazyCat: also, Locate starts by listing the files of my home, but in Search: i still have to start my paths from /, that's a bit counterintuitive
07:36:20 <quicksilver> tonkman: "	where i = liftM ((+1) . fromIntegral) $ elemIndex m chars
07:36:24 <ManateeLazyCat> Saizan: You can type ~/something
07:36:29 <quicksilver> tonkman: as the last time of toNums, and change the type to Integer
07:36:36 <quicksilver> tonkman: this numeric defaulting sure is annoying :(
07:37:10 <tonkman> thanks, end of my project was near
07:37:55 <Saizan> ManateeLazyCat: i see
07:38:11 <ManateeLazyCat> If you want search home directory, you can type File directly
07:38:38 <roconnor> @type (|||)
07:38:39 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
07:38:45 <ManateeLazyCat> Saizan: Don't need type parent directory, manatee will know you you want search from current directory.
07:39:23 <Saizan> ManateeLazyCat: anyhow i think it needs to respond to the mouse better, though i like to start most of my programs from the shell so i'm probably not your ideal user :)
07:39:46 <ManateeLazyCat> Saizan: Yes, i will add mouse event.
07:40:15 <ManateeLazyCat> Because I haven't add Mouse support in gtk-serialized-event
07:40:45 <ManateeLazyCat> Saizan: I will add mouse event after i finish it in gtk-serialized-event
07:41:08 <payo> anyone know where i can go to start learning how to input from gamepad/keyboard and output fullscreen grafx cross-platform including linux, mac, windows, with haskell?
07:41:13 <ManateeLazyCat> Saizan: Now, key event send by DBus, mouse event send by XEmbedded protocol that build in GTK+
07:41:29 <paolino> manatee for hackage test
07:41:45 <ManateeLazyCat> paolino: Infact, not test, it's stable, just not perfect.
07:42:07 <ManateeLazyCat> paolino: Yes, i want more people's feedback to perfect it. :)
07:42:29 <paolino> ManateeLazyCat: eh, installing manatee is installing half hackage
07:42:55 <ManateeLazyCat> paolino: You can choose just install extension you like.
07:43:06 <ManateeLazyCat> paolino: You don't need install all extensions.
07:43:19 <paolino> mh, and reinstalling gtk2hs , grr
07:43:39 <ManateeLazyCat> paolino: mantee use newest version gtk2hs : gtk2hs-0.12.0
07:44:06 * ManateeLazyCat I work for gtk2hs is for my project, it's primary reason.
07:44:08 <lars9> which package is good for args handling?
07:44:27 <dcoutts__> lars9: basic GetOpt is ok
07:44:31 <byorgey> lars9: cmdargs
07:44:38 <dcoutts__> or there are other packages on hackage
07:44:49 <ManateeLazyCat> lars9: http://hackage.haskell.org/package/cmdargs
07:44:52 <lars9> dcoutts__ byorgey thanks
07:45:06 <lars9> ManateeLazyCat: thanks:)
07:45:07 <paolino> simpleargs
07:45:34 <ManateeLazyCat> Saizan: We can write manatee extension and install by cabal, then use it and don't need restart manatee. :)
07:46:05 <roconnor> @src (<<<) (->)
07:46:05 <lambdabot> Source not found. I've seen penguins that can type better than that.
07:46:12 <roconnor> @src (->) (<<<)
07:46:12 <lambdabot> Source not found. That's something I cannot allow to happen.
07:46:27 <ManateeLazyCat> paolino: Just manatee-core manatee-anything manatee must install, other package you can choose you like. :)
07:47:08 <byorgey> roconnor: ?
07:47:09 <lars9> FileManip's page says: "DEPRECATED. Use the filemanip package (all lowercase) instead.", but filenamip is not found on hackage, am i missing something? http://hackage.haskell.org/package/FileManip-0.3.3.1
07:47:16 <ManateeLazyCat> paolino: You can use it as standalone program, such as editor, and you can use it like integrated environment that mix everything in a uniform interface.
07:47:32 <byorgey> lars9: http://hackage.haskell.org/package/filemanip  ?
07:47:43 <paolino> lars9 cabal update ?
07:48:04 <lars9> byorgey: oops, you can find something google cannot
07:48:45 <byorgey> lars9: hehe, don't bother using google to search hackage
07:49:00 <byorgey> just go to http://hackage.haskell.org/packages/archive/pkg-list.html  and do a text search on the page
07:49:06 * hackagebot cmdargs 0.6.3 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.3 (NeilMitchell)
07:49:08 * hackagebot SoccerFun 0.4 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.4 (JanRochel)
07:49:10 * hackagebot SoccerFunGL 0.4 - OpenGL UI for the SoccerFun framework  http://hackage.haskell.org/package/SoccerFunGL-0.4 (JanRochel)
07:49:22 <byorgey> lars9: look at that, a new version of cmdargs! =)
07:50:31 <paolino> hackagebot flooding today
07:52:57 <lars9> byorgey: awesome
07:54:14 <roconnor> Ah no! Could not deduce (Applicative m) from the context (Monad m)
08:01:24 <byorgey> roconnor: dang, that's the worst error =(
08:01:34 <byorgey> roconnor: I have a vision of a future utopia where those errors shall be no more
08:08:32 * ManateeLazyCat pasted "intro manatee" at http://paste2.org/get/1082824
08:08:43 <ManateeLazyCat> Above intro clear enough?
08:08:55 <pumpkin> ManateeLazyCat: I saw manatees last weekend
08:09:12 <ManateeLazyCat> pumpkin: Hehe. :)
08:09:32 <ManateeLazyCat> pumpkin: http://hackage.haskell.org/package/manatee
08:09:43 <pumpkin> ah, nice :)
08:10:01 <quicksilver> pumpkin: I saw pumpkins the weekend before last.
08:10:45 <ManateeLazyCat> pumpkin: I'm posting on haskell-cafe, hope will bring some developer help me develop manatee. :)
08:12:15 * hackagebot oeis 0.2.2.1 - Interface to the Online Encyclopedia of Integer Sequences  http://hackage.haskell.org/package/oeis-0.2.2.1 (BrentYorgey)
08:12:52 <quicksilver> ManateeLazyCat: More likely it will get you a long an divergent off-topic thread. Or entirely warnocked.
08:12:55 <quicksilver> ;)
08:13:07 <ManateeLazyCat> quicksilver: Tha's i want.
08:13:29 <ManateeLazyCat> quicksilver: Build a new system that haskell community haven't try. :)
08:14:03 <byorgey> ManateeLazyCat: looks interesting!
08:14:17 <ManateeLazyCat> byorgey: Screenshot at http://goo.gl/MkVw
08:14:28 <byorgey> yup, I'm looking at the screenshots now
08:15:19 <ManateeLazyCat> quicksilver: I have 2000 TODO need finish, i can't finish all those myself, not technology, is time problem. :)
08:15:58 <Cheery> Is haskell still using spineless tagless G-machine?
08:16:21 <quicksilver> GHC, not really.
08:16:26 <quicksilver> but a close descendendant.
08:16:47 <quicksilver> it still has a stage called "stg" but it isn't proper stg any more.
08:16:56 <Cheery> how does it differ?
08:17:01 <ManateeLazyCat> quicksilver: I hope haskeller interested my project, and contribute extension.
08:17:24 <ManateeLazyCat> quicksilver: If someday extension too many like firefox's one, i will build extension center......
08:17:25 <quicksilver> Cheery: In detail I don't know. It is no longer entirely tagless and I'm not sure it's completely spineless.
08:17:36 <quicksilver> ManateeLazyCat: I hope that too.
08:18:00 <ManateeLazyCat> quicksilver: If we can use Haskell/GTK+ build all software we need, then we working on Haskell kernel.
08:18:10 <EvanR-work> invertebrate reduction machine
08:18:13 <ManateeLazyCat> quicksilver: And just Haskell code running my box.
08:20:02 <Cheery> playing with thing like this: http://paste.pocoo.org/show/289016
08:20:18 <mornfall> ManateeLazyCat: Do you use yi?
08:20:31 <ManateeLazyCat> mornfall: I use it one years ago.
08:20:35 <ManateeLazyCat> mornfall: Not my need.
08:20:42 <ManateeLazyCat> mornfall: So i create my own one.
08:20:52 <ManateeLazyCat> mornfall: BTW, my project not just editor.
08:21:09 <ManateeLazyCat> mornfall: I'm emacs fans before. :)
08:22:16 * hackagebot safe 0.3 - Library for safe (pattern match free) functions  http://hackage.haskell.org/package/safe-0.3 (NeilMitchell)
08:23:09 <EvanR-work> pattern matching is unsafe?
08:24:52 <Saizan> maybe it's lacking a "failure"
08:25:36 <dschoepe> EvanR-work: It provides replacements for partial functions like Prelude.head
08:26:15 <EvanR-work> safeHead = listToMaybe
08:26:16 <EvanR-work> i suppose
08:26:21 <EvanR-work> @src listToMaybe
08:26:21 <lambdabot> listToMaybe []        =  Nothing
08:26:21 <lambdabot> listToMaybe (a:_)     =  Just a
08:28:05 <mornfall> ManateeLazyCat: I sort of had hopes for yi. Probably still do.
08:28:16 <mornfall> I however do need something usable over ssh, which rules out GTK.
08:28:33 <EvanR-work> you can use gtk over ssh ;)
08:28:37 <mornfall> EvanR-work: No.
08:28:59 <ManateeLazyCat> mornfall: My program can.
08:29:04 <ManateeLazyCat> mornfall: But in TODO list.
08:29:10 <ManateeLazyCat> mornfall: Something like RPC
08:30:07 <ManateeLazyCat> mornfall: Because my program is multi-processes framework, you can run daemon program (control process) in local box, and running real program in remote box, and control through ssh.
08:30:28 <ManateeLazyCat> mornfall: But this perhaps not the highest task in my TODO list.
08:30:41 <EvanR-work> its called X ;)
08:30:47 <mornfall> EvanR-work: X is ... slow.
08:31:00 <ManateeLazyCat> mornfall: Anyway my framework is open, if you want, you can build any program in it.
08:31:16 <ManateeLazyCat> mornfall: We can use some technology compress data.
08:31:25 <EvanR-work> mornfall: you had that typed into the input box and were waiting for me to say that, werent you ;)
08:31:32 <ManateeLazyCat> mornfall: And render graphics in local when receive compress data.
08:31:37 <EvanR-work> and you couldnt respond to ManateeLazyCat until i ddi
08:31:45 <mornfall> EvanR-work: Not really. : - P
08:32:23 <mornfall> ManateeLazyCat: Well, it never worked very well on the GUI level.
08:32:33 <ManateeLazyCat> mornfall: I'm not say use GUI>
08:32:49 <ManateeLazyCat> mornfall: I build temrinal emulator in it, then do everything in it.
08:33:01 <mornfall> (As in X, VNC, rdesktop... they all start to suck horribly at some point of not enough bandwidth...)
08:33:15 <ManateeLazyCat> mornfall: GUI need high-speed network to support it, and not fast enough.
08:33:39 <ManateeLazyCat> mornfall: But GUI remote control is not impossible 
08:33:48 <EvanR-work> X and rdesktop should be fast
08:33:53 <EvanR-work> faster than vnc at least
08:34:20 <ManateeLazyCat> EvanR-work: Have many crazy extension idea lying in my TODO list.
08:34:35 <EvanR-work> since they dont necessarily transfer pixels
08:34:35 <ManateeLazyCat> EvanR-work: Hope i can fix it someday....
08:34:51 <ManateeLazyCat> EvanR-work: Yes, even pixels is possible.
08:34:58 <ManateeLazyCat> EvanR-work: Some like RPC 
08:35:31 <ManateeLazyCat> EvanR-work: But need some good compress technology compress graphics data.
08:35:32 <EvanR-work> lossy desktop video compression is interesting
08:35:58 <ManateeLazyCat> EvanR-work:  2Mb bandwidth is enough
08:36:07 <EvanR-work> vnc and png are lossless, leading to bloated transfer
08:36:20 <finnomenon> hi
08:36:21 <EvanR-work> 2M is out of the question
08:37:37 <EvanR-work> you should be able to do it over a 100KHz carrier ;)
08:37:54 * ManateeLazyCat pasted "todo list" at http://paste2.org/get/1082863
08:37:55 <ManateeLazyCat> Above is new Task i need to finish. :)
08:38:08 <ManateeLazyCat> And have many lower task haven't post....
08:38:13 <Jafet> Temporal compression can do much better than that. See how video codecs work.
08:38:21 <ManateeLazyCat> Finish above tasks first.
08:38:33 * Jafet puts on a 10 Mbps video file...
08:38:58 <EvanR-work> yeah desktops should be able to be compressed a lot
08:39:39 <Jafet> I once tried playing a video game over local ethernet. It didn't go well
08:40:12 <EvanR-work> i tried a 320x240 framebuffer graphics game on the lan, i got about 3fps, pretty good
08:40:23 <EvanR-work> over the internet, 0.05 fps
08:40:32 <Jafet> (By comparison, a large screen today can nearly saturate a whole DVI link)
08:41:35 <ManateeLazyCat> Ok, finish haskell-cafe mail, and see what happen....
08:42:30 <mornfall> Jafet: We'll just wait till average home internet pipe has the bandwidth of DVI, then. :)
08:43:31 <ManateeLazyCat> I think i should re-install XMOnad to test.
08:43:46 <EvanR-work> im waiting for XMonoid
08:44:00 <mornfall> Why not XAlgebra.
08:44:28 <Jafet> mornfall: by then we'll have even bigger screens...
08:44:43 <Jafet> Clearly, only terminals are the sustainable future
08:45:01 <EvanR-work> its punctuated equilibrium, it took 50 years before TVs gained any sort of upgrade in quality
08:45:07 <Saizan> we should just design programs so that you can put an internet connection between the part doing the actual work and the part that renders the gui
08:45:17 <EvanR-work> soon we will get to the max resolution people are willing to uselessly buy
08:45:27 <hpc> Saizan: you mean use X? :P
08:45:32 <Jafet> Saizan: we already have such a design, and it's called X11.
08:45:42 <Saizan> how come it's so slow then?
08:45:49 <EvanR-work> its not slow
08:46:01 <Jafet> Because it's written in C
08:46:15 <EvanR-work> its slow for framebuffer graphics but not desktop apps
08:46:19 <hpc> lol, only on #haskell
08:46:21 * Saizan didn't see anyone challenge mornfall assertion earlier
08:46:27 <hpc> "it's slow because it is written in C"
08:46:53 <EvanR-work> people use to do all their work on 'x terminals'
08:47:04 <EvanR-work> on the equivalent of a lan
08:47:16 <Jafet> hpc: graphics, like all other computer intensive tasks, should be as lazy as it is possible to get away with
08:47:18 <Saizan> also, i don't think X does what i meant, it probably still transfers information about what should appear on the windows, right?
08:47:20 <EvanR-work> now known as thin clients
08:47:23 <mornfall> EvanR-work: It's slow for desktop apps because they do push a lot of pixels.
08:47:37 <mornfall> Just think of the animated transitions.
08:47:44 <EvanR-work> well thats the apps problem
08:47:44 <mornfall> X has no inherent support for that.
08:47:48 <mornfall> EvanR-work: I see. :)
08:47:50 <Jafet> Saizan: but the X server and window and compositing managers decide what is actually drawn.
08:47:55 <Jafet> (To a large extent)
08:48:01 <EvanR-work> screw compositing and pixels
08:48:09 <mornfall> Yeah, screw pixels. Make more of them!
08:48:17 <sipa1024> early x11 applications worked pretty well over network, because x11 was designed as a network protocol; but currently all extra layers do computation on the client side, and send pixels to the server, which it is slow :)
08:48:23 * hackagebot hlint 1.8.3 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.3 (NeilMitchell)
08:48:25 <Jafet> Be careful, you might turn some of them dead
08:48:29 <hpc> heh, i can just imagine the bugs; "my program only crashes if i look at it!"
08:48:32 <Veinor> bleh. i want to release a version of askitter to cabal, but i keep changing the API
08:48:52 <mornfall> sipa1024: Obviously, since the X11 protocol can't do fancy graphics. And people want fancy graphics.
08:49:01 <EvanR-work> hpc: indeed if you write a game loop, and you dont take into account the time it could take to render with network X, it could fail but only if you use network X
08:49:16 <sipa1024> mornfall: indeed, basically the way they handled that problem was inherently not what the protocol was designed for
08:49:40 <mornfall> sipa1024: Well, you would imagine DisplayPostScript would fix that. Guess what.
08:49:43 <edlinde> Do I need to know about Applicative Functors and Monoids before I start to read about what Monads are?
08:49:43 <mornfall> (It didn't.)
08:49:52 <sipa1024> hmm
08:49:53 <Saizan> Jafet: ok, but i meant that you should just transfer the raw data the application needs, the "server" shouldn't care about the interface at all
08:49:58 <edlinde> I want to skip a chapter in LYAH (for now) and then get back to it
08:50:01 <Jafet> opengl also has a client-server protocol. Given that it is optional, and any interface involving sockets that is optional is never used by programmers as a rule, barely any programs support it.
08:50:08 <conal> edlinde: you don't need to. but it'd be an easier path.
08:50:09 <hpc> edlinde: don't skip chapters of LYAH
08:50:12 <EvanR-work> edlinde: no but you should look at those anyway because they are cool
08:50:13 <Veinor> edlinde: what hpc said
08:50:21 <mornfall> Jafet: OpenGL is kinda postscript, too. :)
08:50:29 <conal> edlinde: Monoid and Applicative are simpler than Monad and will prepare you for learning Monad.
08:50:39 <edlinde> ok
08:50:46 <hpc> they are also arguably even more awesome than Monad
08:50:47 <mornfall> Jafet: And opengl still needs wagons of texture data anyway.
08:51:03 <EvanR-work> hpc: hence the need for XMonoid or XApplicativeFunctor
08:51:03 <conal> amen to more awesome.  with their simplicity comes generality
08:51:09 <hpc> EvanR-work: :D
08:51:18 <Veinor> XMonoid?
08:51:37 <EvanR-work> yes, mempty is a blank screen
08:51:45 <EvanR-work> mappend is compositing
08:51:47 <tab> mornfall: not in wireframe or plain color rendering ;)
08:52:00 <mornfall> conal: Just don't forget that with generality comes loss of detail.
08:52:10 <Jafet> Support the developers, order your copy of XMonadPlus today
08:52:15 <hpc> Applicative is a neat interface to parallel computations
08:52:29 <mornfall> On one end lies the set of everything and on the other the set of nothing.
08:52:43 <ManateeLazyCat> Saizan: Manatee is MVC design, any extension can running and don't need render it.
08:52:48 <conal> We could design a successor to X (and to NeWS) in the spirit of Landin's ISWIM.
08:52:51 <mornfall> It's all about picking the right set inbetween.
08:53:29 <hpc> ManateeLazyCat: it is also webscale :D
08:53:37 <Jafet> Sometimes using Functor feels like using the set of right sets, which isn't necessarily itself a right set
08:53:52 <sophacles> hi all, does anyone know if any work has been done to embed rbac and/or capabilities based security into types, with a goal of utilizing the type system to help enforce security?
08:53:55 <ManateeLazyCat> hpc: Yes, mean that you even can develop non-GUI program in it.
08:54:03 <conal> and use functional image synthesis as in Pan but updated to target GPUs.  i'm working on the graphics part of that project now
08:54:28 <ManateeLazyCat> hpc: Of course, you can use GUI render data when you want see it. Otherwise switch current buffer to backend to finish other job.
08:54:34 <mornfall> GPUs. Are we back to Cray yet? :)
08:55:36 <conal> i see low-cost supercomputers (GPUs etc) as a tremendous opportunity for pure functional programming.
08:56:02 <Jafet> Quick, pre-port concurrent haskell to larrabee
08:56:07 <mornfall> conal: I have heard the same to be said of multicores.
08:56:32 <conal> mornfall: indeed. not as much so as GPUs, but getting there.
08:56:50 <hpc> also, multicore is better supported atm
08:57:08 <conal> wow. i have a group of five or so deer running/hopping back & forth across the hillside out my window.
08:57:14 <Jafet> conal, what API are you using for the GPUs?
08:57:22 <conal> playing a chse-me game.
08:57:41 <sm_> conal: nice :)
08:57:46 <conal> (chase-me)
08:57:56 <ManateeLazyCat> Some code in https://patch-tag.com/r/AndyStewart/manatee/snapshot/current/content/pretty/Manatee not neat, please let me know if you have any code suggestion. Thanks!
08:57:57 <conal> yeah.  i love those guys.
08:59:08 <conal> Jafet: for now i'm using OpenGL and a haskell-embedded language & compiler that generates GLSL.
08:59:28 <conal> Jafet: an updated version of Pan and Vertigo (see my home page)
09:00:08 <Jafet> Hmm. GLSL isn't as expressive as the new languages, but it's an accepted standard
09:00:50 <conal> Jafet: exactly.  i'd like to learn OpenCL and/or CUDA. looking for a partner who knows it, and an initial learning project .
09:00:56 <Jafet> They seemed to have rolled OCL out without its shoelaces on, so to speak. None of the vendors seem happy about supporting it.
09:01:17 <hpc> OpenCL isn't going to be nice to use for a while
09:01:35 <conal> my goal is to tame the complexity of GPU programming to the point that kids can do it for fun.
09:01:37 <hpc> CUDA is extremely popular, and ATI can't support OpenCL well yet
09:01:45 <ManateeLazyCat> Bye all, i need test XMonad now. :)
09:02:08 <conal> hpc: does CUDA run on ATI??
09:02:17 <hpc> no; CUDA is NVidia only
09:02:18 <conal> i thought cuda was nvidia-only.
09:02:46 <hpc> i suppose what i am saying is: "there isn't a good GL yet"
09:02:51 <conal> hpc: ah. so ATI supports neither OpenCL well nor CUDA at all?
09:03:05 <hpc> NVidia has fantastic support for both
09:03:11 <hpc> which is pretty funny, when you think about it
09:03:55 <EvanR-work> cathedral vs the bazaar, when are we going to be able to put graphics in the hands of the people
09:03:58 <Jafet> ATI tried to peddle its Stream thingy, but failed.
09:03:59 <conal> yeah. and which suggests to me that OpenCL is a better choice than CUDA, since other HW vendors do or will support the former but not the latter. i guess.
09:04:06 <EvanR-work> rather than attending nvidia or ati hq on sundays
09:04:43 <conal> has anyone here programmed OpenCL?
09:05:13 <ManateeLazyCat> conal: Face detect?
09:05:25 <ManateeLazyCat> conal: http://hackage.haskell.org/package/HOpenCV
09:05:36 * conal looks
09:06:01 <conal> oh -- by sinelaw
09:06:08 <ManateeLazyCat> conal: OpenCL?
09:06:16 <ManateeLazyCat> conal: Looks OpenCV
09:06:20 <ManateeLazyCat> conal: Sorry
09:06:21 <conal> ManateeLazyCat: HOpenCV
09:06:29 <hpc> if this is any indication of the rest of OpenCL... http://www.khronos.org/files/opencl-1-1-quick-reference-card.pdf
09:06:38 <conal> oh.
09:08:09 <Veinor> man, i wish there was a nice way to do record types with the same name for fields
09:08:30 <EvanR-work> User.name File.name
09:08:35 <conal> i've been intimidated by the complexity of cuda & opencl, which is why reluctant to learn it on my own. on the other hand, that taming that complexity with an elegant functional/denotative API would be a great contribution.
09:08:41 <Veinor> because i have two things that I want to give 'page' fields
09:09:02 <EvanR-work> use qualified imports
09:09:23 <conal> hpc: holy crap that's a scary API.
09:09:47 <Veinor> EvanR-work: but they also only make sense in the same module
09:09:53 <Veinor> :/
09:10:20 <conal> hpc: and thanks.  i hadn't seen that opencl ref card
09:10:22 <osaunders> I wrote this: https://github.com/olliesaunders/TVec/blob/master/TVec.hs
09:10:46 <[swift]> opencl and cuda are horrible, but they're a great improvement on the state of GPGPU before they arrived
09:10:47 <EvanR-work> Veinor: mmm theres something to be said about one main data type per module
09:11:01 <Veinor> possibly
09:11:11 <EvanR-work> you can have a group module which reexports those two
09:11:16 <EvanR-work> so everything else can import one thing
09:11:25 <conal> [swift]: yeah. and it's easier to grow complexity than to tame it (without losing expressiveness).
09:11:26 <Veinor> the context is that I'm writing a twitter api, and i'm using data types to represent possible options
09:11:30 * hackagebot derive 2.4.1 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.4.1 (NeilMitchell)
09:11:49 <conal> Complexity grows incrementally. Regaining simplicity requires a revolution.
09:11:53 <conal> and deep insight.
09:12:46 <conal> and good taste.
09:12:50 <hpc> sometimes regaining simplicity is just a matter of losing expressiveness
09:13:05 <Veinor> but... friendsTimeline TimelineOptions { includeRTs = True } seems verbose
09:13:09 <[swift]> conal: i've seen some work on mapping parallel computations onto arbitrary memory hierarchies that offers some hope that opencl and friends might be replaced by something better. the problem with the opencl, as i understand it, is that its just too close to the hardware still
09:13:16 <EvanR-work> Veinor: yeah
09:13:18 <conal> hpc: that way is guaranteed to work. but not what i'm after.
09:13:50 <Veinor> EvanR-work: defaultTimelineOptions, technically, since i want default options
09:14:03 <Veinor> or possibly timelineOptions { includeRTs = True }
09:14:09 <conal> [swift]: yeah, i bet.
09:14:10 <EvanR-work> Timeline.defaultOptions
09:14:14 <Veinor> yeah
09:14:24 <Veinor> that makes some sense
09:14:41 <conal> hpc: guaranteed to work in that the empty api is simple, but at the cost of some loss of expressiveness.
09:14:48 <Veinor> or I could do data Options = TimelineOptions { ... } | SearchOptions { ... }
09:15:10 <EvanR-work> and someone who is going to customize options is going to say somethingAlotShorter = defaultOptions { foo=bar, baz=quux }
09:15:21 <Veinor> then I wouldn't have record field name conflict, but it'd mean you could pass search options to timeline API calls
09:15:52 <EvanR-work> thats not good
09:16:01 <EvanR-work> obviously they are different data types
09:16:06 <Veinor> yeah
09:16:28 <beginer1> how to define a data type for tree where every top has 0, 1 or 2 children and every top has data list containing numbers  
09:16:37 <conal> hpc: but maybe i missed your point.
09:16:40 <beginer1> maybe some link?
09:16:58 <Veinor> so... one module for TimelineOptions, one module for SearchOptions, etc?
09:17:12 <hpc> conal: like, at some point, you have too much expressiveness, and losing some of it will not make you any worse off
09:17:25 <Veinor> that seems a bit much, especially since I wouldn't be able to actually do anything other than declare types in those modules
09:17:27 <EvanR-work> data Top = Zero [Integer] | One Top [Integer] | Two Top Top [Integer]
09:17:41 <EvanR-work> Veinor: there is no shortage of modules, use them
09:18:00 <beginer1> thank you
09:18:03 <EvanR-work> they are there for naming stuff, exactly your problem
09:18:27 <Veinor> I think I will
09:18:49 <Veinor> so... a sample call would be timelineOptions Timeline.defaults { includeRTs = True } 
09:18:51 <conal> hpc: ah. i think i'm starting to get it. like lots of raw jangly mechanism.
09:18:53 <Veinor> or maybe Timeline.defaultOptions
09:19:06 <EvanR-work> whats the type of timelineOptions
09:19:29 <conal> hpc: and a higher-level (eg denotative) packaging might not have use for some of that low-level mechanism.
09:19:33 <Veinor> er, friendsTimeline Timeline.defaults { includeRTs = True }
09:19:49 <EvanR-work> ok makes more sense
09:19:51 <hpc> conal: a good example would be HDBC: i don't need to be able to fetch a row as [SqlValue], [(String, SqlValue)], or Map String SqlValue
09:20:01 <Veinor> yeah
09:20:02 <hpc> just [(String, SqlValue)] will do fine
09:20:28 <EvanR-work> hpc: or in the case of hdbc, [SqlValue]
09:20:47 <conal> hpc: thanks. now i want to re-examine and refine my thinking about simplifying w/o losing expressiveness.
09:21:24 <hpc> :D
09:21:48 <hpc> (the best programmer is half mathematician, half engineer?)
09:22:11 <EvanR-work> and half masochist
09:22:26 <EvanR-work> you always gotta have three halves
09:22:33 <aristid> EvanR-work: that rules out half mathematician though, because no mathematician allows three halves
09:22:35 <hpc> indeed
09:22:56 <hpc> aristid: 5/4 people have trouble with fractions
09:22:57 <aristid> you could add another half sportsman, because they always give 150%
09:22:58 <Veinor> EvanR-work: is it possible for a module to reexport other modules qualified?
09:23:11 <conal> so far glsl has been pretty friendly to work with (generating from a high-level functional language), but i'm stuck at wanting dynamic tessellation. "geometry shaders" (awful name) are almost there but i don't think it'll ever show up.
09:23:16 <hpc> Veinor: man, i wish
09:23:29 <EvanR-work> Veinor: apparently not
09:23:38 <Veinor> basically, how can I get this to work without forcing users to say import Web.Twitter.Types.Timeline as Timeline, etc
09:23:40 <aristid> conal: can you approximate?
09:23:58 <conal> i think even the iphone 3gs hardware can do dynamic tessellation, but the opengl es 2.0 api can't get at it.
09:23:58 <EvanR-work> wow you have a deep heirarchy
09:24:03 <conal> aristid: approximate?
09:24:14 <Veinor> EvanR-work: or even just Web.Twitter.Timeline as Timeline
09:24:21 <conal> aristid: do you mean using static tessellation instead of dynamic?
09:24:32 <EvanR-work> if they need to use both options types they need to do two qualified imports
09:24:37 <aristid> conal: yeah, use something that looks hopefully good enough. what graphics people always do.
09:25:27 <conal> aristid: i want intelligent allocation of rendering muscle, which is time- and view-dependent.
09:26:11 <conal> aristid: my models are continuous in time & space and they know their derivatives, so i have the info needed to intelligently focus gpu computation.
09:26:16 <hpc> tessellation is an incredible trick; i am in awe of the person who came up with it
09:26:23 <aristid> conal: except the gpu doesn't let you
09:26:42 <conal> aristid: worse. the gpu would do it but the api doesn't let me.
09:26:57 <aristid> conal: heh.
09:27:00 <hpc> conal: isn't OpenGL up to 3.2 now?
09:27:08 <monochrom> type-directed name resolution makes me sick. next April's Fool I shall propose type-directed parentheses insertion or something similarly ridiculous.
09:27:11 <hpc> whoa, 4.1
09:27:14 <aristid> hpc: mine goes to 11
09:27:23 <hpc> aristid: no, that's X
09:27:23 <conal> lol
09:27:25 <hpc> :P
09:28:05 <hpc> man, googling OpenGL is such a depressing eneavor
09:28:16 <hpc> first result is the homepage, reporting version 4.1
09:28:23 <hpc> third result is docs for 2.1
09:28:34 <conal> speaking of X and opengl, i was serious about a successor based on ISWIM (Haskell).
09:28:54 <roconnor> @hoogle Alternative
09:28:54 <lambdabot> Control.Applicative class Applicative f => Alternative f
09:28:54 <lambdabot> Language.Haskell.ParseMonad alternative :: Lex a v -> Lex a (Lex a v)
09:29:03 <Cheery> darn it. my graph reducer is not working. :E
09:29:06 <roconnor> @hoogle (f a)
09:29:06 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
09:29:06 <lambdabot> Text.Regex.Base.RegexLike getAllTextSubmatches :: AllTextSubmatches f b -> f b
09:29:06 <lambdabot> Text.Regex.Base.RegexLike getAllTextMatches :: AllTextMatches f b -> f b
09:29:16 <EvanR-work> monochrom: what?
09:29:24 <EvanR-work> share the knowledge
09:30:41 <conal> hpc: hey.  looks like geometry shaders are first class in opengl 3.2 http://www.opengl.org/wiki/Geometry_Shader .  thanks for the tip.
09:30:43 <hpc> monochrom: type-directed typeclasses :D
09:31:05 <EvanR-work> whats ridiculous, whats the solution
09:31:20 <conal> i wonder how long until opengl es has them.
09:31:29 <conal> for phones & tablets.
09:31:47 <hpc> 'es'?
09:31:47 <osaunders> hpc: There isn't up to date docs?
09:31:57 <EvanR-work> hpc: the spanish version of opengl
09:32:11 <osaunders> Embedded systems.
09:32:22 <conal> hpc: the pared-down opengl that runs on small devices.
09:32:24 <osaunders> Embedded something, at lest.
09:32:28 <hpc> osaunders: i am sure there are, but more people are still using 2.1, despite a bump of two whole versions
09:32:31 <EvanR-work> embedded spanish
09:32:35 <aristid> conal: looks like i have opengl 2.1 on my desktop
09:32:42 <aristid> er laptop
09:32:44 <hpc> enterprise sasquach
09:32:47 <osaunders> hpc: Ah OK, good.
09:32:49 <conal> aristid: what os?
09:32:54 <aristid> conal: lunix
09:33:00 <EvanR-work> hpc: because every program ever made is written against it
09:33:27 <aristid> conal: which opengl do you have?
09:33:37 <hpc> EvanR-work: one would expect more people to update...
09:34:13 <conal> aristid: on iOS, it's 2.0 es.  on my mac, i don't know.
09:34:18 <EvanR-work> assuming more people have hardware that supports it
09:34:20 <aristid> hpc: you can't update the hardware so easily
09:34:41 <aristid> conal: if it were linux you could run glxinfo to test, but i don't know the command for os x
09:34:44 <quicksilver> conal: AFAIK OSX is on 2.1
09:34:47 <osaunders> I want to say «class Foo x where length :: Int» but it is illegal because «length» doesn't mention «x». Any idea how I can get round that?
09:34:59 <quicksilver> your card might support later opengl functionality through extensions though.
09:35:15 <conal> i shifted my focus to iOS programming when the 3gs came out since it has programmable shader hardware. but it's been awfully painful to live on a mac and do haskell graphics & guis.
09:35:23 <aristid> conal: ok, looks like you have 2.1: http://developer.apple.com/graphicsimaging/opengl/capabilities/
09:35:26 <quicksilver> osaunders: a dummy parameter?
09:35:26 <hpc> ....wait
09:35:32 <EvanR-work> osaunders: how would haskell know which length implementation to use
09:35:37 <hpc> does apple's phone support a more recent OpenGL than their computers?
09:35:39 <quicksilver> osaunders: otherwise how would the compiler know which length to use?
09:35:45 <quicksilver> hpc: yes.
09:35:54 <hpc> .....BWAHAHAHAHAHAHA!
09:36:03 <osaunders> Ah
09:36:07 <quicksilver> hpc: apple is a phone company.
09:36:08 <EvanCarroll> But their computers support flash.
09:36:13 <EvanCarroll> Go figure.
09:36:18 <conal> aristid: yeah. 2.1.
09:36:19 <quicksilver> they make a few computers aimed at people who want to write apps for their phones
09:36:24 <hpc> EvanCarroll: not anymore :P
09:36:28 <hpc> they don't ship with flash now
09:36:35 <aristid> conal: so no geometry shaders for you :P
09:36:35 <EvanR-work> really??
09:36:37 <quicksilver> don't ship with != don't support.
09:36:47 <conal> aristid: right.
09:36:57 <luite> yeah it's a bit annoying that you need OS X to develop for iOS :(
09:37:11 <hpc> quicksilver: "is out to make obsolete" == "don't support" imo
09:37:27 <aristid> conal: wait, actually.. i see EXT_geometry_shader4 in the list.
09:37:27 <EvanCarroll> you say that now, isn't iphone4 supposed to get flash some day
09:37:28 <EvanCarroll> or something
09:37:33 <aristid> conal: is that something else?
09:37:38 <conal> i'm considering bailing on mac. i don't know if graphics or guis will ever work for haskell + mac.
09:37:41 <EvanR-work> osaunders: maybe class Foo x where length :: x -> Int
09:37:54 <Veinor> EvanR-work: i don't like this idea of 'you have to import qualified each module that you need'
09:38:00 <osaunders> conal: I could be wrong but I thought if that if you run a later version of OGL than your GPU supports the newer features will be done in software.
09:38:07 <EvanR-work> Veinor: thats not what i suggested
09:38:08 <conal> aristid: it might be enough. apparently 3.2 makes geometry shaders core, but they can still be supported by earlier apis.
09:38:17 <edlinde> guys I need some help understand applicative functors... they are a bit complicated :(
09:38:21 <Veinor> where by 'each module' I meant 'each module containing the option type'
09:38:31 <conal> edlinde: ask away!
09:38:32 <EvanR-work> you dont have to do it in that case either
09:38:32 <Veinor> EvanR-work: ?
09:38:37 <Veinor> so how do you do it?
09:38:37 <aristid> conal: now you just need to check the list of extensions supported by the iPhone 3GS ;)
09:38:49 <EvanR-work> Veinor: it depends on the importing module
09:38:52 <edlinde> LYAH says if we map "multi-parameter" functions over a functor, we get a functor with functions in it
09:38:56 <edlinde> I think I get this part
09:39:07 <edlinde> then we have an example like
09:39:08 <edlinde> let a = fmap (*) [1,2,3,4]  
09:39:09 <Veinor> well, what I'd really, really like is that the user can say import Web.Twitter and then get everything they need
09:39:14 <edlinde> fmap (\f -> f 9) a  
09:39:14 <edlinde> [9,18,27,36] 
09:39:25 <edlinde> this fmap part is a bit confusing
09:39:42 <EvanR-work> Veinor: yeah, then you can use a namespace on each field name, and they have no control over the granularity
09:39:47 <EvanR-work> which a lot of libs do
09:39:53 <edlinde> can I think of fmap reducing to a map when its applied to a list?
09:40:01 <Veinor> yes
09:40:06 <Veinor> fmap on a list is map
09:40:10 <edlinde> ok
09:40:12 <edlinde> hmm
09:40:14 <EvanR-work> Veinor: have you thought of making an Option datatype, and the various options types are maps frmo Options to values
09:40:21 <osaunders> @instances Functor
09:40:22 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:40:24 <Veinor> EvanR-work: such as?
09:40:41 <EvanR-work> Veinor: instead of field names, use constructors of the option type
09:40:46 <osaunders> @src fmap
09:40:46 <lambdabot> Source not found. I am sorry.
09:40:51 <edlinde> so 'a'  in this case is basically holding a list of functions like (multiply to 1 ?) (multiply to 2 ?)
09:40:56 <conal> edlinde: does LYAH really say "map ... functions over a functor"?
09:41:00 <edlinde> where the other arg will be supplied later on
09:41:06 <Veinor> like... data Option = IncludeRTs Bool | Count Integer | ...
09:41:07 <EvanR-work> now you have less assurance that the user wont use invalid options, but its not as bad as say PHP
09:41:08 <Veinor> ?
09:41:15 <EvanR-work> you could do that
09:41:26 <osaunders> edlinde: Yes
09:41:30 <EvanR-work> now Options is a list of Option rather than a map
09:41:35 <Veinor> that'd make my code a pain in the ass to write
09:41:39 <EvanR-work> why?
09:41:40 <Veinor> but it's an idea
09:41:45 <edlinde> hmm ok
09:41:52 <BONUS> yeah, it says we map them but not as in map the function
09:42:11 <edlinde> whats the easiest way of thinking of a functor?
09:42:13 <Veinor> 12:39:14       <EvanR-work> Veinor: yeah, then you can use a namespace on each field name, and they have no control over the granularity                                                                                
09:42:17 <Veinor> I'm still not sure what you meant by this
09:42:22 <BONUS> but map the verb. the typesetting makes it easier to infer that
09:42:34 <Veinor> could you show me an example?
09:42:37 <EvanR-work> Veinor: since you probably want only one instance of IncludeRTs this is why i suggested a map
09:42:39 <conal> edlinde: better would be to start with Monoid, and then Applicative, and then Monad
09:42:59 <Veinor> well, most things only make sense for one option type. there are a couple, however, that make sense for multiple ones.
09:43:13 <EvanR-work> so the value is a list of values rather than one value
09:43:14 <EvanR-work> for those
09:43:26 <BONUS> conal: why? to me it seems easier to explain that applicatives are functors with pure and <*> and monads are applicatives with >>= (or join)
09:43:27 <Veinor> what?
09:43:45 <EvanR-work> if an option can have multiple values, make multiple values rather than multiple options
09:43:45 <edlinde> conal: I just want to know how to think of fmap in layman's terms... to me it just looks like... you have a function and a list of say things like [Just 1, Just 2...] then you will end up with [Just f 1, Just f 2...]
09:43:53 <Veinor> oh, no, options can't have multiple values
09:44:01 <EvanR-work> ok then i didnt understand what you said
09:44:16 <conal> BONUS: because the question "what is a Monoid" is easier to answer than "what is an applicative functor".
09:44:17 <c_wraith> edlinde, that's actually a double fmap.
09:44:27 <EvanR-work> what is a monoid, really
09:44:31 <BONUS> edlinde: did you read the whole section about functors?
09:44:35 <edlinde> so it seems like fmap works on what is "inside"
09:44:36 <Veinor> I'm saying that, say, both searching and getting a user's timeline both use the option "page"
09:44:41 <edlinde> yeah
09:44:43 <sproingie> main problem to me would seem to be that the map function itself only works on lists
09:44:50 <EvanR-work> Veinor: in my latest suggestion it would be Page
09:44:52 <Veinor> right
09:45:01 <conal> BONUS: and do you really use the word "functor" to refer to values rather than just to type constructors? i'd hate to see that confusion spread.
09:45:25 <Veinor> so, friendsTimeline "username" [Page 8, IncludeRTs True]
09:45:30 <BONUS> conal: i've done a lot of revising and correcting of such issues for the print edition
09:45:41 <edlinde> so what about my definition earlier on for fmap?
09:45:41 <BONUS> and one of these days im going to merge those revisions and corrections back to the web
09:45:43 <edlinde> sound ok?
09:45:59 <conal> BONUS: such as "map ... functions over a functor"
09:46:18 <Veinor> and then somewhere I'd write a big thing that maps (Page x) to ("page", show x), (IncludeRTs b) to ("include_rts", map toLower b)
09:46:20 <Veinor> etc.
09:46:22 <BONUS> conal: yeah, stuff like that gets changed into: map functions over a functor value
09:46:28 <conal> BONUS: or "we get a functor with functions in it"
09:46:48 <edlinde> yeah these sentences are a bit confusing to be honest :)
09:46:53 <conal> BONUS: better, thanks.
09:47:00 <arcatan> didn't the use to be a package called monads-fd?
09:47:06 <Veinor> it's not a bad idea, btu I don't get what that gains me over data Options = TimelineOption { ... } | SearchOption { ... }
09:47:07 <BONUS> yeah that was a rather stupid thing of me to write. actually, im gonna rectify that sooner rather than later
09:47:35 <edlinde> ok in the meanwhile can I get a quick idea of how to think about fmap?
09:47:46 <Veinor> although... the Options datatype would need to make sure that I got every option combination
09:47:50 <edlinde> when applied to a normal list of integers or something its just map
09:47:57 <conal> BONUS: i see such wide-spread confusion about "monad" (e.g. "pass in a monad"), and i'd love it if lyah reversed the trend.
09:47:58 <Veinor> whereas the Option type would just need a list
09:48:06 <conal> BONUS: starting with simpler type classes.
09:48:27 <osaunders> edlinde: Yes
09:48:36 <osaunders> What is your question?
09:48:40 <BONUS> conal: yeah, in the sections about applicatives and monads the terms "applicative value" and "monadic value" are used for values. just the functors part was a stupid oversight which im gonna fix
09:48:51 <conal> BONUS: and i wonder if there's a simpler & clearer alternative to "functor value", which still sounds a bit funny.
09:48:53 <EvanR-work> Veinor: [Page 8]...
09:48:58 <conal> BONUS: .. in my ears.
09:49:02 <edlinde> someone said if I applied fmap a function to [Just a, Just b, ...] and get [Just f a, Just f b...] then I have done a double fmap?
09:49:07 <edlinde> I didn't get that part osaunders 
09:49:14 <conal> BONUS: ah, cool.
09:49:25 <Veinor> edlinde: yeah. fmap f [Just a] = [f (Just a)]
09:49:36 <hpc> :t (<*>)
09:49:37 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:49:38 <BONUS> conal: yeah, i thought about that, but ultimately saying "a value whose type is an instance of Functor" every time gets a bit weird
09:49:39 <Veinor> fmap (fmap f) [Just a] = [fmap f (Just a)] = [Just (f a)]
09:49:51 <edlinde> I mean my understanding of fmap is that it unwraps the elements in the list and will apply the function to the inner part... like the a in Just a
09:49:52 <hpc> :t fmap fmap
09:49:53 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
09:49:56 <edlinde> am I right ?
09:49:56 <conal> BONUS: yeah, it does. i mean looking for something better than that.
09:49:58 <c_wraith> > fmap (fmap (+ 5)) [Just 1, Nothing, Just 7]
09:49:59 <lambdabot>   [Just 6,Nothing,Just 12]
09:50:10 <conal> BONUS: you could start a conversation on haskell-cafe.
09:50:11 <Veinor> edlinde: in this case, the 'inner part' of the list is the Just a
09:50:18 <Veinor> fmap only goes 'inside' one layer
09:50:23 <conal> BONUS: someone might have an improvement.
09:50:32 <BONUS> hmm, maybe yeah. but functor value i think is pretty descriptive
09:50:35 <osaunders> edlinde: And then it wraps it up afterwards.
09:50:37 <Veinor> EvanR-work: ?
09:50:38 <BONUS> and unambiguous
09:50:41 <osaunders> :t fmap
09:50:42 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:50:47 <edlinde> ok so fmap will go in one level
09:50:57 <EvanR-work> Veinor: i wouldnt use a list of options since [Page 8, Page 9] doesnt make sense, does it?
09:50:58 <hpc> more fmaps go in further
09:51:00 <osaunders> In one level?
09:51:04 <conal> BONUS: you've used adjectives "applicative" & "monadic", but a noun "functor"
09:51:06 <Veinor> true
09:51:19 <Veinor> so what would you recommend instead of a list of options?
09:51:19 <hpc> what would be the adjective of functor?
09:51:29 <Vanadium> functoriffic
09:51:29 <EvanR-work> Veinor: a map from options to option values?
09:51:31 <lars9> anyone using leksah?
09:51:35 <conal> hpc: exactly
09:51:44 <Vanadium> functoral
09:51:44 <edlinde> so I cannot do something like this yeah ... fmap (+1) [Just 1, Just 2] ?
09:51:45 <osaunders> lars9: Couldn't get it to compile
09:51:51 <edlinde> it didn't work on Prelude 
09:51:52 <conal> and what would be the noun of applicative
09:51:54 <Veinor> EvanR-work: okay, so what would an API call look like
09:51:56 <sproingie> functorious
09:51:57 <Veinor> edlinde: right, that doesn't typecheck
09:52:06 <sipa1024> :t fmap (+1) [Just 1, Just 2]
09:52:07 <lambdabot> forall t. (Num (Maybe t), Num t) => [Maybe t]
09:52:09 <hpc> conal: applicative functor, of
09:52:10 <BONUS> conal: yeah, that's also my issue with the term. but i think "functor value" is good enough, even if it isn't perfect
09:52:11 <EvanR-work> Veinor: api call?
09:52:12 <hpc> of course
09:52:12 <Veinor> because it'd evaluate to [1 + Just 1, 2 + Just 2]
09:52:18 <conal> hpc: yeah. so inconsistent.
09:52:19 <osaunders> > fmap (fmap (+1)) [Just 1, Just 2]
09:52:20 <lambdabot>   [Just 2,Just 3]
09:52:26 <Veinor> EvanR-work: basically, how do I give the end user a nice way to construct the maps?
09:52:30 <BONUS> functorish value, haha
09:52:35 <BONUS> monadish value
09:52:42 <sproingie> mote!
09:52:43 <Veinor> edlinde: and 1 + Just 1 doesn't typecheck
09:52:45 <edlinde> osaunders: gotcha
09:52:46 * hpc coins "monadular"
09:52:50 <conal> BONUS: i understand these language issues are tricky, and "good enough" is always tempting.
09:52:53 <sipa1024> Veinor: unless you have instance Num a => Num (Maybe a)
09:52:54 <edlinde> aha
09:53:01 <Veinor> sipa1024: yes but that'd be a very silly isntance
09:53:02 <edlinde> I think its clearer now... will get back to LYAH
09:53:04 <edlinde> :)
09:53:05 <edlinde> thanks
09:53:06 <EvanR-work> Veinor: any way to combine values
09:53:08 <Veinor> no problem
09:53:12 <sipa1024> Veinor: would it? :)
09:53:20 <EvanR-work> f . g . h
09:53:21 <EvanR-work> a + b + c
09:53:23 <Veinor> sipa1024: what's 1 + Nothing?
09:53:28 <sipa1024> Veinor: Nothing
09:53:28 <EvanR-work> mconcat [list]
09:53:47 <sipa1024> > Just 5 + Just 3
09:53:48 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
09:53:48 <lambdabot>    arising from a use of...
09:53:51 <sipa1024> meh!
09:54:01 <conal> Veinor: not a silly instance at all. there's a general patten for Num instances, and Maybe fits it well.
09:54:09 <EvanR-work> Veinor: you could use a list for that purpose, but that would be just to define the structure
09:54:12 <sipa1024> i think so too
09:54:15 <conal> Veinor: all applicative functors fit that pattern.
09:54:19 <Veinor> EvanR-work: hm. anyway, I need to go to class.
09:54:23 <hpc> conal: isn't there an extension that can derive Functor like that?
09:54:26 <Veinor> thanks for your advice :D
09:54:32 <conal> Just 5 + Just 3 == Just 8
09:54:43 <Veinor> hpc: I'm pretty sure there is
09:54:45 <conal> @hackage applicative-numbers
09:54:45 <lambdabot> http://hackage.haskell.org/package/applicative-numbers
09:54:53 <Veinor> anyway, classtime. o/
09:54:58 <EvanR-work> > fmap (+) (Just 5) (Just 3)
09:54:59 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe t1 -> t'
09:54:59 <lambdabot>         against inf...
09:55:18 <EvanR-work> > (<*>) (+) (Just 5) (Just 3)
09:55:19 <lambdabot>   Couldn't match expected type `a -> a'
09:55:19 <lambdabot>         against inferred type `Data.M...
09:55:22 <EvanR-work> :(
09:55:31 <conal> hpc: it's Num not Functor i'm talking about deriving.
09:55:43 <hpc> oh, derp
09:56:36 <conal> this Applicative-as-Num business is very powerful. for instance, it explains automatic differentiation.
09:56:51 <conal> which was an epiphany for me
09:56:59 <EvanR-work> :t (<*>)
09:57:00 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:57:07 <conal> see http://conal.net/papers/beautiful-differentiation/
09:58:23 <EvanR-work> > (<*>) (+3) (Just 3) (Just 5)
09:58:24 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
09:58:24 <lambdabot>         against inferred type ...
09:58:33 <EvanR-work> > (<*>) (+3) (Just 3)
09:58:34 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
09:58:34 <lambdabot>         against inferred type ...
09:59:05 <conal> EvanR-work: so close. keep trying!
09:59:21 <EvanR-work> :t (+3)
09:59:22 <lambdabot> forall a. (Num a) => a -> a
09:59:29 <EvanR-work> :t (Just 3)
09:59:30 <lambdabot> forall t. (Num t) => Maybe t
09:59:53 <BONUS> @src concat
09:59:53 <lambdabot> concat = foldr (++) []
10:00:13 <EvanR-work> > (+3) <*> Just 5
10:00:14 <lambdabot>   Couldn't match expected type `(a -> b) -> a'
10:00:14 <lambdabot>         against inferred type ...
10:00:20 <BONUS> heh, strange that Caleskell doesnt have concat = mconcat
10:00:39 <manateeUser> Night all, need sleep. (Manatee Irc Client)
10:02:29 <EvanR-work> > (3+) <$> Just 5
10:02:30 <lambdabot>   Just 8
10:03:26 <EvanR-work> > (+) <$> Just 3 <*> Just 5
10:03:27 <lambdabot>   Just 8
10:03:27 <Cheery> hm.
10:04:06 <EvanR-work> > Just (+3) <*> Just 5
10:04:07 <lambdabot>   Just 8
10:04:15 <Cheery> just came to mind. is there a profanity kicker?
10:04:25 <conal> EvanR-work: you got there. :)  see also liftA2
10:04:38 <Ke> Cheery: people mention C++ all the time
10:04:39 <EvanR-work> :t liftA2
10:04:40 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
10:05:10 <EvanR-work> Cheery: no but we talk about female body parts a lot since they are supported by haskell
10:05:43 <EvanR-work> conal: i was about to invent this
10:05:54 <Cheery> okay.
10:05:55 <EvanR-work> > liftA2 (+) (Just 3) (Just 5)
10:05:56 <lambdabot>   Just 8
10:06:01 <conal> EvanR-work: :)
10:06:21 <EvanR-work> > liftA2 (+) (Just 3) Nothing
10:06:22 <lambdabot>   Nothing
10:06:36 <EvanR-work> look, php arithmetic
10:06:52 <conal> EvanR-work: you can do similarly for all of the other methods in Num and most of the methods in the other numeric classes.
10:07:16 <conal> EvanR-work: and you only ever use Applicative operations, so you can do the same for all applicative functors, not just Maybe.
10:07:39 <conal> which is what the applicative-numbers package on hackage does.
10:07:54 <EvanR-work> so numeric class + applicative = applicative arithmetic
10:08:02 <paolino> I have a traversable instance and a list of values and a function , if the traversable was a list I would use zipWith with them. Is there a natural function for the traversable ?
10:08:05 <edlinde> Dont get what this line in LYAH means
10:08:06 <edlinde> A better way of thinking about pure would be to say that it takes a value and puts it in some sort of default (or pure) context—a minimal context that still yields that value.
10:08:19 <conal> EvanR-work: yeah :)
10:08:19 <edlinde> I understand the type is pure :: a -> f a 
10:08:28 <EvanR-work> > pure (+3) <*> Just 9
10:08:29 <lambdabot>   Just 12
10:08:48 <edlinde> I have't looked at <*> yet :)
10:09:04 <edlinde> what does it mean to put something in a pure context??
10:09:18 <EvanR-work> it puts it in the functor context
10:09:22 <EvanR-work> in this case Maybe
10:09:31 <edlinde> I mean isn't pure just returning an applicative functor with a inside it?
10:09:45 <conal> edlinde: applicative functors aren't values.
10:10:16 <EvanR-work> edlinde: better not think of f a or Monad m => m a as containers
10:10:20 <EvanR-work> in my opinion
10:10:24 <conal> edlinde: but i think i know what  you mean.  what BONUS is calling an "applicative value"
10:11:12 <edlinde> its just that these definitions keep changing around.. its a bit confusing
10:11:28 <EvanR-work> haskell has rich terminology ;)
10:11:40 * EvanR-work gets promoted to the pr department
10:11:50 <edlinde> so in a -> f a 
10:11:53 <edlinde> whats f a ?
10:12:01 <edlinde> an applicative value?
10:12:04 <conal> edlinde: a type
10:12:40 <EvanR-work> example above was Maybe Integer
10:13:01 <osaunders> Damn, typed length lists really suck in Haskell.
10:13:06 <edlinde> I still don't get how "f a" would be a type?
10:13:11 <edlinde> I thought "a" was a type?
10:13:19 <EvanR-work> f is a type function or type constructor
10:13:28 <edlinde> yeah ok
10:13:32 <EvanR-work> f :: * -> *
10:13:40 <edlinde> and isn't a the type passed in to it?
10:13:45 <conal> edlinde: 'a' is a type. so is 'f a'. so is 'a -> f a'. 
10:13:50 <EvanR-work> f is applied to a
10:13:54 <EvanR-work> to yield, f a
10:14:08 <osaunders> a is applied to f.
10:14:17 <edlinde> ok so "f a" is a concrete type?
10:14:20 <osaunders> ... to yield f a.
10:14:22 <EvanR-work> erm thats the opposite of how i know it
10:14:29 <edlinde> and so is a a concrete type too?
10:14:31 <EvanR-work> apply functions, not arguments
10:14:41 <edlinde> coz we said "f :: * -> *" ?
10:14:53 <EvanR-work> a :: *
10:14:57 <EvanR-work> i think
10:15:07 <tommc> Is there any way a user can provide annotations to the compiler, to help sort out a diamond dependency? ie A depends on C.1, B depends on C.2 and D depends on [A,B]. 
10:15:14 <osaunders> EvanR-work: Yeah, so when you "apply to" the function is the object of the sentence i.e. comes second.
10:15:17 <conal> edlinde: avoiding 
10:15:23 <edlinde> ok I think osaunders and EvanR-work are contradicting each other
10:15:24 <edlinde> :)
10:15:36 <conal> edlinde: postponing this discussion of f is why i suggest starting with Monoid.
10:15:49 <conal> edlinde: if you get Monoid & Functor, then Applicative is easy.
10:15:49 <EvanR-work> osaunders: i said, is applied to
10:15:59 <edlinde> conal: point taken
10:16:04 <osaunders> EvanR-work: Yeah, that's why you were wrong.
10:16:13 <EvanR-work> i dont think so
10:16:14 <edlinde> I am sure it could have been written in a simpler way 
10:16:20 <dstcruz> ... any ManU fan here?
10:16:29 <osaunders> EvanR-work: You said f is applied to a. But you can't apply a.
10:16:44 <EvanR-work> you are right on both counts, without me being wrong
10:16:54 <osaunders> If you could you would get: a f
10:16:59 <osaunders> Whatever, it doesn't matter.
10:17:09 <osaunders> I disagree with that last statement.
10:17:19 <Cheery> > let skipper list f = case list of [] -> []; (x:y:xs) -> y:x:skipper xs f in skipper "ocdlf cu!k" skipper
10:17:20 <lambdabot>   "cold fuck!"
10:17:20 <EvanR-work> when you apply something1 to something2, something1 is applied to something2
10:17:26 <dstcruz> I've been digging back into my Algorithms material, and have been watching the MIT Algos class. I'm having a hard time seeing how some these algorithms would work OK with a language like haskell.
10:17:38 <edlinde> ok let me get the hang of how it all works and I will let you guys know :)
10:17:41 <EvanR-work> its always to something2
10:17:42 <dstcruz> Take for instance quicksort, seems like optimal requires a random number
10:17:46 <edlinde> hehe
10:18:05 <EvanR-work> indirect objects for the win
10:18:15 <dstcruz> even though, for every imput, the function would produce the same output, now quicksort has to be in a monad?
10:18:42 <dstcruz> or has to accept an extra parameter of "seed"?
10:18:50 <EvanR-work> dstcruz: to make use of a random number generator you need to 'take from' a stream
10:19:08 <osaunders> EvanR-work: If I apply 1 to (+1) I get 2. But I can't apply (+1) to 1. Function must come second.
10:19:28 <ezyang> To answer the question I asked oh so many hours ago, passing --package-db and --with-ghc to Setup configure did the trick. 
10:19:34 <osaunders> Hm, I dunno, maybe not.
10:19:43 <EvanR-work> > (+1) 1
10:19:44 <lambdabot>   2
10:19:52 <EvanR-work> i applied it to 1, it worked
10:19:54 <dstcruz> most of the cool algorithms need randomness, and I don't know haw that would be handled in haskell, without adding to the signature of the function
10:20:11 <osaunders> Yeah, I would say you applied (+1) just then.
10:20:28 <EvanR-work> dstcruz: a seed would be a minimum
10:20:31 <EvanR-work> addition
10:21:07 <EvanR-work> a function with given inputs cant produce different outputs for those inputs on different evaluations
10:21:16 <EvanR-work> so you need to add at least one more input
10:21:18 <osaunders> But I see that you're way of looking at it isn't "wrong". I just didn't realize you could say it the other way round and still be correct. I kind of don't like that you can because it is really confusing.
10:21:26 <EvanR-work> osaunders: i did
10:21:30 <EvanR-work> i applied (+1)
10:21:32 <EvanR-work> to something
10:21:38 <EvanR-work> it was applied
10:21:40 <EvanR-work> to something
10:21:52 <osaunders> You just said you applied 1.
10:21:56 <osaunders> Now you're saying you applied (+1).
10:21:56 <EvanR-work> no i didnt
10:22:05 <EvanR-work> i said i applied it to 1
10:22:13 <lispy1> > 1 1
10:22:14 <lambdabot>   Ambiguous type variable `t' in the constraint:
10:22:14 <lambdabot>    `GHC.Num.Num t' arising f...
10:22:15 <osaunders> Oh right
10:22:22 <EvanR-work> english sucks
10:22:22 <osaunders> Yeah that's still the opposite of how I think of it.
10:22:31 <lispy1> > 1 1 :: Int
10:22:32 <lambdabot>   1
10:22:39 <lispy1> I just applied 1 to 1
10:22:49 <sipa1024> i tend to use 'apply f to x' or 'pass x to f'
10:22:58 <osaunders> lispy1: thanks for making it more complicated!
10:23:02 <lispy1> :)
10:23:05 <dstcruz> so, I guess that means that I could not seamlesly replace the implementation of "sort" without giving away the fact that I need a source of randomness, or some seed?
10:23:26 <EvanR-work> ni devas uzi nur esperanton
10:23:32 <osaunders> EvanR-work: Yeah, English does suck.
10:23:40 <sipa1024> dstcruz: indeed, unless you use evil unsafePerformIO
10:23:40 <aristid> EvanR-work: you get demoted from pr
10:23:43 <EvanR-work> lol
10:24:03 <dstcruz> would unsafePerformIO be a bad choice in this type of instance?
10:24:21 <dstcruz> where the output will not change based on the IO, but the algo might?
10:24:40 <EvanR-work> dstcruz: you are saying that your sort is probabilistic? it has a different result on different iterations of the algorithm for the same inputs?
10:25:03 <aristid> write a monad for probabilistic algorithms! \o/
10:25:07 <dstcruz> no, it produces the same output, but the algorithm uses randomness to be optimal
10:25:14 <aristid> hmm
10:25:19 <EvanR-work> how about using a random number generator inside the algorithm
10:25:24 <EvanR-work> but the seed is constant
10:25:35 <aristid> sounds like a plan
10:25:41 <EvanR-work> it may be slightly less than optimal, but its random anyway
10:26:16 <dstcruz> I could do that, but then the signature goes from: sort :: [x] -> [x] to some kind of sort :: [x] -> MonadyThing [x]
10:26:22 <EvanR-work> no it doesnt
10:26:46 <aristid> EvanR-work: while demoted from pr, you now get a honorary position for "rescuing pureness"
10:27:00 <dstcruz> ?? can you explain a bit?
10:27:00 <lambdabot> Plugin `compose' failed with: Unknown command: ""
10:27:03 <EvanR-work> sort :: [x] -> [x], sort = runWhateverMonadIfYouWish,OrNot
10:27:15 <EvanR-work> erm
10:27:21 <EvanR-work> runWhateverMonad action
10:27:27 <EvanR-work> action :: m [x]
10:27:44 <aristid> @hoogle random
10:27:45 <lambdabot> package random
10:27:45 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
10:27:45 <lambdabot> module System.Random
10:27:45 <dstcruz> that doesn't "taint" the calling function?
10:27:51 <EvanR-work> no
10:27:56 <EvanR-work> :t runRandom
10:27:57 <lambdabot> Not in scope: `runRandom'
10:27:59 <aristid> dstcruz: no, because you provide the seed yourself
10:28:09 <aristid> EvanR-work: standard random stuff is not monadic
10:28:14 <osaunders> EvanR-work: Just curious now, if I say apply f to g, what would you write that as in Haskell?
10:28:22 <aristid> f g
10:28:24 <EvanR-work> f g
10:28:40 <EvanR-work> dstcruz: running a monad is typically of the form m a -> a
10:28:41 <osaunders> Yeah
10:28:46 <osaunders> I'd say g f
10:28:56 <aristid> osaunders: no. that would not be haskell
10:28:57 <dstcruz> heh, I think I see what you are saying, I should use "42" in my function :)
10:29:08 <EvanR-work> yeah
10:29:13 <aristid> dstcruz: 42 is an excellent seed :)
10:29:17 <osaunders> aristid: Why is that not Haskell?
10:29:20 <sproingie> 7 is the most random number
10:29:30 <aristid> osaunders: because in haskell, you put the applied function first: f g
10:29:38 <EvanR-work> no, 7 has a zero percent chance of being chosen
10:29:54 <aristid> the joy of random numbers :D
10:30:06 <osaunders> aristid: OK, you weren't here for the whole conversation prior.
10:30:20 <aristid> EvanR-work: [7,8) is the most random interval!
10:30:21 <osaunders> Also I meant for people to assume f and g are both functions.
10:30:24 <EvanR-work> aristid: he says the applied function is not f
10:30:33 <dstcruz> Study this I need.  Thanks!
10:30:44 <aristid> osaunders: are you trying to redefine the word "apply"?
10:30:45 <dstcruz> ... on to finishing the HWN for today
10:31:18 <dstcruz> (and try to watch the Man-U vs. Man City game out of the corner of my eye :))
10:31:45 <osaunders> aristid: No, I'm trying to find its definition.
10:31:45 <dstcruz> Have you guys seen the "median of medians" algo?
10:31:56 <osaunders> g2g
10:31:59 <dstcruz> those guys have to be in touch with the oracle themselves
10:32:01 <dstcruz> yikes
10:32:13 <EvanR-work> i apply my hands to osaunders and cure his affliction
10:33:34 <EvanR-work> by the power of my devote purity
10:33:45 <EvanR-work> and lack of spelling ability
10:34:46 <Cheery> hm.
10:35:19 <kadoban> not sure if this is a really dumb question, but i have this program: main = interact id.  i run it, and as soon as i enter a line, it starts spitting it back out.  how does it do that? shouldn't interact wait for the entire String to be available first, or something?
10:35:29 <Cheery> haskell implementation requires a garbage collector with write barriers.
10:35:42 <Vanadium> kadoban: No. <:)
10:36:08 <ezyang> iinteract is line buffered, iirc. 
10:36:12 <Vanadium> How would it know when to stop?
10:36:12 <kadoban> Vanadium: i guess just chalk it up to compiler magic? or is there some way i can understand how that works?...
10:36:25 <Vanadium> kadoban: It uses evil interleaved IO
10:36:26 <Vanadium> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/System-IO.html#interact
10:36:44 <Vanadium> getContents gives it a string that is only read in as it is evaluated
10:37:05 <Vanadium> so it can start printing the string before all of it is available
10:37:08 <kadoban> oh, right...yeah, okay that does make sense
10:37:15 <kadoban> haha, i guess it was a dumb question, thanks
10:37:16 <sipa1024> lazyness at its best
10:37:20 <Vanadium> Not a dumb question
10:37:26 <Vanadium> Everybody hates crazy IO like that
10:37:44 <kadoban> ya, i kind of forgot about laziness there for a minute somehow
10:38:07 <Cheery> ^C d comes out as a [] ?
10:39:14 <aristid> Vanadium: as they say: just use iteratees :)
10:39:35 <Vanadium> Is there an iteratees for dummies article?
10:39:58 <roconnor> Is there a way to make a monoid out of an arbitrary binary operation and neutral element.  Ie. does there already exists a MonoidDict a = MonoidDict a (a -> a -> a) type?
10:41:11 <roconnor> wait, maybe that doesn't work
10:41:37 <Aune> > 1 1 :: Int
10:41:38 <lambdabot>   1
10:43:18 <Guest72742> Hello I have a problem dealing with extendedRecursionEngine
10:43:31 <Guest72742> Can anyone help me!!!! :)
10:43:35 <pumpkin> what is that?
10:44:58 <Guest72742> It's similar to mpReduce
10:45:05 <Guest72742> *mapReduce
10:45:42 <mauke> that's ... nice?
10:46:10 <ezyang> What is an extendedRecursionEngine.... 
10:46:40 <Guest72742> Can I paste the code
10:46:44 <pumpkin> Guest72742: put yourself in our position: (strange shows up) "hey! can you tell me about booblywidgets?" "they're like french toast"
10:46:55 <pumpkin> Guest72742: hpaste.org :)
10:47:14 <ezyang> heh, extendedrecursionengine has six results 
10:47:39 <djahandarie> Oh god
10:47:41 <pumpkin> looks like he asked on stackoverflow too :P
10:47:49 <djahandarie> This is from that one class isn't it
10:47:50 <pumpkin> or someone else in his class
10:48:09 <djahandarie> Where all the teacher has taught is some morphism
10:48:09 <pumpkin> lol, someone else already pasted the code ;) Guest72742 : http://hpaste.org/41341/question
10:49:13 <pumpkin> I'm sure edwardk could give extendedRecursionEngine a fancier name
10:49:19 <djahandarie> There is one
10:49:21 <djahandarie> I forget its name
10:49:28 <djahandarie> It isn't a crazy name either
10:49:29 <Guest72742> okay here's the problem I'm trying to do http://hpaste.org/41354/extendedrecursionengine
10:49:38 <pumpkin> that Bool in the signature is not very common
10:49:52 <pumpkin> most things would probably use a Maybe or some underlying functor
10:49:56 <edlinde> wow this Foldable stuff is some powerful shit
10:49:57 <edlinde> :)
10:50:07 <edlinde> can do quite a lot of damage with it ;)
10:50:21 <Guest72742> That person is probabily in my class
10:52:59 * hackagebot redis-hs 0.0.12 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.0.12 (WillLangstroth)
10:54:26 <Guest72742> pumpkin are you able to help them
10:54:55 <kmc> good morning #haskell
10:55:12 <Guest72742> I need help with ? part
10:55:32 <pumpkin> kmc: good morning!
10:55:35 <beginer1> if I have example list [(1,2,3), (3,2,1), (-1,2,4)] how can I sort ir by the third element (in this case it should be [(3,2,1), (1,2,3), (-1,2,4)])
10:55:40 <pumpkin> Guest72742: have you tried it first?
10:55:52 <Guest72742> yes
10:55:57 <Guest72742> I'm stuck
10:56:01 <kmc> beginer1, sortBy (comparing (\(_,_,x) -> x))
10:56:07 <kmc> comparing from Data.Ord, sortBy from Data.List
10:56:22 <Guest72742> I think the first question mark is this: null children || goal `elem` children
10:56:27 <Guest72742> but I'm not too sure
10:57:28 <pumpkin> that looks right, given the english above it
10:58:15 <roconnor> @hoogle MaybeT
10:58:15 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:58:28 <kmc> @hackage MaybeT
10:58:28 <lambdabot> http://hackage.haskell.org/package/MaybeT
10:58:37 <kmc> also transformers has it
10:58:53 <Guest72742> :t (\ (Node _ children) -> null children || goal `elem` children )
10:58:54 <lambdabot> Not in scope: `goal'
11:00:06 <Guest72742> why is my goal not in scope
11:01:33 <Guest72742> pumpkin is that okay what I have right now
11:01:34 <Guest72742> ?
11:02:31 <pumpkin> seems reasonable
11:03:09 <Guest72742> but I still get an error 
11:03:11 <EvanR> mapReduce...
11:03:29 <djahandarie> pumpkin, I think this is some variation of a hylomorphism
11:04:14 <roconnor> @type \f x -> (<*>) <$> f <*> x
11:04:15 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Applicative f1) => f1 (f (a -> b)) -> f1 (f a) -> f1 (f b)
11:04:49 <beginer1> is this lieke this?      sortBy (comparing (\(_,_,x) -> [[length value] ++ [maximum value] ++ [minimum value]]  ++ aa TreeSort))
11:05:44 <djahandarie> pumpkin, It seems to be a hylomorphism with a natural transformation in it, but I'm really not sure about the bool
11:06:10 <pumpkin> the bool seems like a representation of the underlying functor that the operation runs over the fixed point of
11:06:35 <kmc> beginer1, [[x] ++ [y] ++ [z]] is just [[x,y,z]]
11:06:48 <pumpkin> (a -> Bool, a -> b) is sort of like an unsafe Maybe
11:06:58 <kmc> otherwise you might be onto something but i cant' really tell what you're trying to do
11:06:58 <beginer1> but import Data.List import Data.Ord data Tree a = Nil | Node { --izveido koka strukturu 					left  :: Tree a,                     value :: a,                     right :: Tree a } deriving (Show, Eq)  koks :: Tree [Int] koks = Node (Node Nil [1, 2, 4, 8, -2] Nil) [2, 8, 3, 11, 12, -10] (Node Nil [3, 4, 1, -3] Nil) --aizpilda koku  aa(Node left value right) = --nodod norades uz zariem un vertibu 	if (left == Nil) then ( 		if (righ
11:07:01 <pumpkin> "don't call me unless the function returns True)
11:07:02 <beginer1> but
11:07:10 <djahandarie> Hm yeah
11:07:18 <kmc> sortBy takes a comparison function, and you can use "comparing" to build a comparison function given a "projection" function for your data
11:07:26 <adnap> Are packages on this list http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/unix with 0's in all columns, in fact, not reverse dependencies of Unix?
11:07:33 <kmc> > sortBy (comparing snd) [(1,2), (5,1), (3,0)]
11:07:33 <lambdabot>   [(3,0),(5,1),(1,2)]
11:07:36 <kmc> > sortBy (comparing fst) [(1,2), (5,1), (3,0)]
11:07:37 <lambdabot>   [(1,2),(3,0),(5,1)]
11:08:05 <beginer1> but if I need the thir element? 
11:08:26 <Guest72742> pumpkin, if the first part is okay, can you help me with the second part
11:08:33 <beginer1> sortBy (comparing snd) [(1,2,3), (5,1,6), (3,0,8)] this would still work?
11:08:40 <kmc> beginer1, then you use a function to extract the third element
11:08:44 <kmc> \(_,_,x) -> x
11:12:21 <beginer1> if (left == Nil) then ( 		if (right == Nil)  		then sortBy(comparing (\(_,_,x) -> x)[[length value] ++ [maximum value] ++ [minimum value]]  		else sortBy(comparing (\(_,_,x) -> x)([[length value] ++ [maximum value] ++ [minimum value]] ++ aa right) 	)  gives parse error on input `else'
11:13:04 <EvanR> you should really think about rewriting these nested if statements
11:15:14 <beginer1> how should I rewrite them?
11:16:43 <Guest72742> Please, can anyone help me with this   http://hpaste.org/41355/allpathsto
11:17:21 <Guest72742> I think the first question mark is this: (\ (Node _ children) -> null children || goal `elem` children )
11:18:00 <Guest72742> and I'm definitely not too sure about the second question mark:  (\ parent pathss ->  ? ) 
11:18:07 <EvanR> beginer1: use pattern matching
11:21:16 <byorgey> Guest72742: the first one looks good to me
11:22:07 <Guest72742> byorgey, so can you help me with the second part
11:22:18 <Guest72742> I really don't know how to approach this part
11:23:11 <byorgey> Guest72742: what is the type of allPathsTo?
11:23:24 <byorgey> there are no types anywhere and it is making me squeamish
11:23:46 <Guest72742> this is the type: 
11:23:47 <Guest72742> allPathsTo :: (Eq a) => Tree a -> a -> [[(a, a)]]  -- Recall: Path = [Link] and Link = (a, a). So: allPathsTo :: (Eq a) => Tree a -> a -> [Path a]  
11:24:06 <byorgey> ok, I see
11:25:06 <byorgey> so the reduceFn is supposed to take a parent node (which is of type a, right)? and a list of lists of Paths, and combine them into the final answer, a list of Paths
11:25:09 <byorgey> right?
11:25:33 <byorgey> the list of lists of Paths is coming from processing the child trees -- each child tree results in a list of paths to the goal node
11:26:34 <Guest72742> Yes
11:27:07 <roconnor> what pramga disables the monomorphism restriction?
11:27:14 <byorgey> NoMonomorphismRestriction
11:27:16 <pumpkin> NoMonomorphismRestriction
11:27:26 <roconnor> LANGUAGE NoMonomorphismRestriction ?
11:27:27 <aristid> NoMonomorphismRestriction
11:27:38 <aristid> roconnor: NOOOOOOOOOOOOOOOOOOOOOOOOOOO you destroyed the beautiful row
11:27:52 <sipa1024> {-# LANGUAGE NoMonomorphismRestriction #-}
11:27:53 <sipa1024> nah
11:28:05 <aristid> sipa1024: sure
11:28:50 <byorgey> Guest72742: ok, so let's do an example.  suppose parent = 2, and  pathss = [ [ [(4,5), (5,6)], [(4,6)] ], [ [(8,9), (9,1), (1,6)] ] ]
11:28:55 <roconnor> hmm
11:28:55 <sipa1024> i'm not sure however whether this counts as a pramga
11:29:02 <pumpkin> it is
11:29:10 <pumpkin> anything {-# ... #-} is
11:29:22 <byorgey> Guest72742: so there were two paths to the goal (6) found under the child tree whose root was 4, and one path to the goal found under the child with root 8
11:29:27 <roconnor> looks like the monomorphism restriction wasn't causing my type to be infered less generally
11:29:39 <byorgey> Guest72742: what should the result of reduceFn be in this case?
11:29:43 <roconnor> must be the stupid polymorphic recursion.
11:30:09 <pumpkin> roconnor: is it in a let?
11:30:28 <roconnor> pumpkin: it is in a where clause
11:30:36 <pumpkin> same thing, I think
11:30:44 <roconnor> probably
11:30:51 <pumpkin> as of GHC 7 (or maybe 6.12), it doesn't get generalized as before
11:30:53 <roconnor> pumpkin: whats up with inference in let/where clauses?
11:31:11 <roconnor> pumpkin: I have ghc 6.10.4
11:31:11 <Saizan> only if you've GADTs on
11:31:14 <pumpkin> oh okay :)
11:32:32 <roconnor> pumpkin: so if I define a polymorphic function in a where clause, can't i use it in two different ways in the body?
11:32:48 <roconnor> > let myid a = a in (myid "foo", myid 7)
11:32:48 <lambdabot>   ("foo",7)
11:32:56 <roconnor> hmm
11:32:58 <applicative> have you tried supplying a signature in the where clause?
11:33:01 <pumpkin> roconnor: if you want to, you just add a type signature
11:33:04 <roconnor> applicative: ya, it works.
11:33:05 <pumpkin> roconnor: but that's only in GHC 7 I think
11:33:07 <djahandarie> The monomorphism restriction only turns off when you have GADTs on? What the hell?
11:33:19 <roconnor> turning off the MMR didn't help me
11:33:47 <roconnor> (which is sort of good here becuase i don't think the MMR ought to apply here)
11:34:08 <applicative> with where clauses is it so to speak trying to make inferences before it gets to the where?
11:34:15 <Saizan> djahandarie: heh, no, sort of the opposite
11:34:23 <Guest72742> byorgey, Is the reduceFn (4,6)
11:34:49 <byorgey> Guest72742: No, it needs to be a list of paths
11:35:05 <Saizan> djahandarie: in ghc 7, with GADTs on, definitions in let/where don't get generalized
11:35:17 <roconnor> > let {mylist1 a = a:mylist2 a; mylist2 a = a:mylist1 a} in (head (mylist1 "foo"), head (mylist1 7))
11:35:17 <djahandarie> Ah okay
11:35:17 <lambdabot>   ("foo",7)
11:35:18 <Saizan> djahandarie: i.e. they act as if the MR applied unconditionally to them
11:35:40 <byorgey> Guest72742: sorry, I have to go, hopefully someone else can continue helping you
11:35:55 <djahandarie> byorgey, don't go until you've sent me the link to that github that I'm sure you're hiding somewhere
11:35:57 <Saizan> so it's even more invasive than MR, but just for let/where
11:35:58 <Guest72742> okay thank you
11:36:06 <byorgey> djahandarie: =P
11:38:15 <alpounet> Saizan, what's the rationale for that ?
11:40:32 <Guest72742> Can anyone help me with this problem: http://hpaste.org/paste/41355/addpathsto#p41356
11:40:50 <Guest72742> I'm stuck with the second one which is: (\ parent pathss ->  ? )
11:41:06 <Guest72742> I'm not too sure how to approach this part
11:41:26 <roconnor> oh crap, now I have to use Scoped Type Variables to write this signature
11:41:43 <pumpkin> Guest72742: you're basically asking us to solve the whole problem for you :P you ask one part after another
11:41:46 <pumpkin> how hard have you tried?
11:42:14 <Guest72742> very hard, hours and hours pumpkin
11:42:26 <EvanR-work>  /topic haskellers for hire
11:42:30 <pumpkin> heh
11:42:33 <pumpkin> gotta run :)
11:44:00 <EvanR-work> is there an applicative instance for something that 'does nothing' or is just normal function application
11:44:34 <EvanR-work> s/or/i.e./
11:46:33 <EvanR-work> @instances Applicative
11:46:33 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
11:46:40 <EvanR-work> @instance Applicative
11:46:40 <lambdabot> Maybe you meant: instances instances-importing
11:47:20 <aristid> EvanR-work: :P
11:47:30 <quintessence> @instances Id
11:47:31 <lambdabot> Couldn't find class `Id'. Try @instances-importing
11:47:42 <aristid> EvanR-work: and of course there is an Applicative instance for Identity
11:47:57 <EvanR-work> @src Identity
11:47:57 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
11:47:59 <aristid> Identity being in transformers
11:48:09 <EvanR-work> whats Id
11:48:17 <aristid> Id is another name for Identity
11:48:28 <aristid> used by monadLib for example
11:49:00 <EvanR-work> > Id 8 >> Id 9
11:49:00 <lambdabot>   Not in scope: data constructor `Id'Not in scope: data constructor `Id'
11:49:17 <roconnor> > Identity 8 >> Identity 9
11:49:18 <lambdabot>   No instance for (GHC.Show.Show (Control.Monad.Identity.Identity t))
11:49:18 <lambdabot>    aris...
11:49:23 <roconnor> > runIdentity (Identity 8 >> Identity 9)
11:49:24 <lambdabot>   9
11:49:31 <roconnor> > runIdentity (Identity 8 *> Identity 9)
11:49:32 <lambdabot>   No instance for (Control.Applicative.Applicative
11:49:32 <lambdabot>                     Contro...
11:49:55 <roconnor> oh right I defined my own applicative instance for identity
11:50:29 <EvanR-work> basically im thinking of applicative identiy
11:51:39 <EvanR-work> Functor Monad and Applicative are for data types of kind * -> * right
11:51:42 <EvanR-work> and Monoid for *
11:51:59 <quintessence> the GHC docs for Applicative says there's an instance Applicative Id, but Id isn't linked to anything
11:52:55 <beginer1> how can I add +2 to every value?     map(2+)[value]
11:53:08 <beginer1> is giving error
11:53:33 <Saizan> alpounet: that it's a pain to do generalization inside a case expression over a GADT, due to the type equality constraints that you get out of it
11:54:14 <EvanR-work> > map (+2) [1,2,3]
11:54:15 <lambdabot>   [3,4,5]
11:54:18 <alpounet> ok, thanks
11:54:25 <EvanR-work> > map(+2)[1,2,3]
11:54:26 <lambdabot>   [3,4,5]
11:54:37 <dominikh> > map(2+)[1,2,3]
11:54:38 <EvanR-work> interesting
11:54:38 <lambdabot>   [3,4,5]
11:54:41 <kmc> beginer1, you probably mean «map (2+) value» not «map (2+) [value»
11:55:12 <kmc> beginer1, you don't use [brackets] every time you use a list in any way.  you use brackets to add another layer of list nesting
11:55:12 <EvanR-work> > Just6
11:55:13 <lambdabot>   Not in scope: data constructor `Just6'
11:55:33 <EvanR-work> > Just(6)
11:55:34 <lambdabot>   Just 6
11:55:53 <beginer1> thank you!
11:55:55 <EvanR-work> >Just(6)
11:56:31 <EvanR-work> > maybe(2)(`div`4)Just(6)
11:56:32 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe a'
11:56:32 <lambdabot>         against inferred ...
11:56:46 <EvanR-work> > maybe(2)(`div`4)(Just$6)
11:56:47 <lambdabot>   1
11:57:36 <EvanR-work> > maybe(2)(`div`4)Nothing
11:57:37 <lambdabot>   2
11:58:15 <EvanR-work> in haskell we dont like blank useless newlines, i propose we also eschew blank useless whitespace
11:58:43 <monochrom> all of my blank spaces and newlines are useful
11:58:44 <sipa1024> and i guess we should all just write @pl-like code?
11:59:11 <EvanR-work> well yeah
11:59:14 <EvanR-work> thats a given
11:59:43 <EvanR-work> and use these http://hackage.haskell.org/packages/archive/data-aviary/0.2.3/doc/html/Data-Aviary-Birds.html
12:00:38 <sipa1024> is there a converter to these?
12:02:42 <EvanR-work> yes, but you havent written it yet
12:03:32 <kmc> i like blank useless newlines EvanR-work
12:03:55 <EvanR-work> i dont see them very often in function definitions
12:05:09 <EvanR-work> two newlines in a row
12:07:47 <newprog> hello everyone i would like to get some info about this programming language haskell who can help me?
12:07:55 <kmc> @where LYAH
12:07:55 <lambdabot> http://www.learnyouahaskell.com/
12:07:57 <kmc> @where RWH
12:07:57 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:08:08 <kmc> also: http://haskell.org/
12:08:34 <newprog> does haskel produce any obj file?
12:08:45 <kmc> haskell is a language, a specification.  it does not produce anything
12:08:45 <EvanR-work> ghc -c foo.hs
12:08:52 <kmc> GHC is a compiler for Haskell, which can produce object files
12:08:58 <kmc> it is a native-code, ahead-of-time compiler
12:09:09 <kmc> and is the Haskell implementation used by the vast majority of users
12:09:13 <kmc> though there are several other implementations
12:09:14 <EvanR-work> ahead-of-its-time compiler
12:09:55 <newprog> ok thanks guys 
12:09:57 <applicative> newprog, but there is also e.g. the Hugs interpreter, which doesn't make object files... 
12:10:38 <kmc> and YHC, which outputs platform-independent bytecode
12:10:45 <kmc> and UHC can output javascript now
12:11:04 <EvanR-work> more interesting is haskell the language
12:11:05 <applicative> crazy, man.
12:12:01 <djahandarie> GHC can output Javascript too!
12:12:29 * hackagebot snap-core 0.2.16 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.16 (GregoryCollins)
12:16:31 * hackagebot snap-server 0.2.16 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.16 (GregoryCollins)
12:22:52 <tonkman> would someone paste an example code about use of win32 gui
12:22:59 <tonkman> google code search finds nothing
12:24:40 <tonkman> or link from somewhere
12:26:02 <theonewhoisone_> I have another question, if you don't mind my butting in
12:26:43 <tonkman> I think that no one is answering
12:26:52 <theonewhoisone_> ok well I'll give it a shot anyway
12:26:55 <theonewhoisone_> I suppose
12:27:03 <theonewhoisone_> I have the following code:
12:27:04 <theonewhoisone_> module Main where
12:27:04 <theonewhoisone_> import qualified Data.Map as Map
12:27:04 <theonewhoisone_> main = do
12:27:05 <theonewhoisone_>     let mp = Map.fromList $ map (\x -> (x, x*x)) [1 .. 16]
12:27:05 <theonewhoisone_>     print mp
12:27:25 <aristid> SORRY, WE ARE ON VACATION LEAVE. PLEASE LEAVE A MESSAGE. BEEP.
12:27:26 <theonewhoisone_> when I compile it, it gives me some linker errors
12:27:29 <theonewhoisone_> lol
12:27:29 <djahandarie> theonewhoisone_, http://hpaste.org for longer pastes btw
12:27:36 <theonewhoisone_> ok thx
12:27:39 <djahandarie> What compiler?
12:27:57 <theonewhoisone_> ghc
12:28:09 <theonewhoisone_> 6.10.3
12:28:10 <aristid> which version?
12:28:40 <aristid> THANK YOU. YOUR QUESTION IS RECORDED AND WILL BE ANSWERED AS SOON AS VACATION LEAVE IS FINISHED.
12:29:02 <kmc> theonewhoisone_, ghc --make
12:29:13 <kmc> when you invoke ghc yourself you should always use --make
12:29:18 <kmc> it will be the default in ghc 7
12:29:33 <Botje_> kmc: yay!
12:29:34 <theonewhoisone_> ohoho
12:29:37 <theonewhoisone_> that was easy
12:29:37 <Botje_> six letters of typing saved!
12:29:41 <Botje_> my wrists thank you!
12:29:55 <stepcut>  Botje_: only if you remember not to type them
12:29:56 <aristid> Botje_: alias g=ghc --make
12:30:07 <djahandarie> Botje_, and over thousands of instances of this question no longer asked!
12:30:12 <djahandarie> Think of all that typing saved!
12:30:22 <theonewhoisone_> um, double thanks everybody
12:30:26 <theonewhoisone_> back to the keyboard
12:30:26 <theonewhoisone_> later
12:30:33 <djahandarie> doublewelcome
12:30:52 <Botje_> actually, i do cabal build so the point is moot :]
12:31:01 <aristid> alias c=cabal
12:31:05 <aristid> alias cb=cabal build
12:31:07 <aristid> alias i=ghci
12:31:28 <ajnsit> I just installed Haskell on my iphone!
12:31:37 <applicative> tonkman, what are you calling 'win32 gui' ? 
12:31:39 <ajnsit> I can't believe it was even possible!
12:31:50 <stepcut> ajnsit: nice!
12:32:02 * kmc wonders how you can install a document
12:32:08 <djahandarie> ajnsit, what is 'Haskell' in this context?
12:32:13 <EvanR-work> kmc: it involves the registry
12:32:26 <tonkman> simple gui to recieve a string
12:32:36 <ajnsit> djahandarie, I mean hugs
12:32:40 <EvanR-work> and some private files in system/win32/system32/
12:32:43 <tonkman> I want it to be native
12:32:48 <ajnsit> http://argaldo.wordpress.com/2008/09/20/hugs98-on-the-iphone/
12:33:11 <EvanR-work> tonkman: no you dont, you want it to be windows
12:33:23 <tonkman> yes, and native
12:34:33 <monochrom> oh, hugs, nice
12:34:45 <EvanR-work> http://img.brothersoft.com/screenshots/softimage/r/resource_hacker-60545-5.jpeg this is not native, its windows
12:34:50 <aristid> don't people also use ghc on the iphone now?
12:34:57 <monochrom> you can now script your iphone in haskell
12:35:15 <monochrom> yes, ghc is on the iphone too
12:35:19 <tonkman> by native I mean "no installations needed"
12:35:26 <ajnsit> monochrom, I don't know about scripting the iphone, but I can interact with hugs on the terminal
12:35:27 <EvanR-work> as long as youre on windows?
12:35:36 <tonkman> yes
12:35:37 <EvanR-work> thats not what native means usually in gui stuff
12:35:46 <monochrom> haskell is the finest scripting language in the solar system
12:35:49 <quintessence> EvanR-work: that's what people mean by "native" in the windows world though
12:35:50 <tonkman> ok, but you got my point
12:36:01 <EvanR-work> so you want a windows gui
12:36:09 <tonkman> yeah
12:36:13 <EvanR-work> whats the problem with the api youre using
12:36:19 <applicative> it has a field for typing in a string; then what?
12:36:34 <tonkman> nothing, win32 libraries are just cryptic
12:36:38 <EvanR-work> yes
12:36:50 <ajnsit> monochrom, well I don't know what libraries are available to the hugs instance
12:36:55 <djahandarie> monochrom, what about beyond the solar system?
12:37:01 <ajnsit> it may not be able to access anything on the phone at all
12:37:24 <monochrom> they use agda beyond the solar system
12:37:28 <EvanR-work> you want to use them so i guess you should be prepared for that
12:37:52 <applicative> tonkman, have you looked at e.g. http://hackage.haskell.org/package/HGL  I don't know if it builds....
12:37:53 <tonkman> well, i have time
12:38:19 <tonkman> MY FUCKING GOD
12:38:22 <tonkman> how simple is that
12:38:35 <tonkman> that must build
12:39:20 <daedra> hi there, I have the LC   [2*x | x <- [0..], x <= 10]   but it does not finish by closing the right bracket, why is that?
12:39:30 <kmc> what do you mean?
12:39:33 <kmc> > [2*x | x <- [0..], x <= 10]
12:39:37 <lambdabot>   mueval-core: Time limit exceeded
12:39:43 <daedra> is it still testing each x <= 10?
12:39:46 <kmc> yes
12:40:00 <kmc> it doesn't know that, once x is greater than 10, it will never again be less than or equal
12:40:08 <tonkman> applicative: thank you
12:40:09 <daedra> ok
12:40:13 <kmc> > [2*x | x <- takeWhile (<= 10) [0..] ]
12:40:14 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20]
12:40:20 <kmc> this is basically the difference between filter and takeWhile
12:40:23 <tonkman> you just saved 10^9 hours of work
12:40:28 <kmc> and list comprehension desugars using filter
12:40:50 <kmc> of course there's simpler ways to write this
12:40:55 <applicative> tonkman, notice http://hackage.haskell.org/package/hgl-example as well, see if that compiles, it might get you started
12:40:55 <kmc> > map (2*) [0..10]
12:40:56 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20]
12:41:00 <kmc> > [0,2..20]
12:41:00 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20]
12:41:53 <djahandarie> > (2*).[0..10]
12:41:54 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20]
12:41:55 <daedra> kmc: oh sure, I was just trying it out
12:42:31 <kmc> heh djahandarie
12:44:14 <tonkman> HGL compiled
12:44:39 <orlandu63> djahandarie: does that only work with lambdabot?
12:44:42 <djahandarie> orlandu63, yes
12:45:03 <orlandu63> okay, just checking
12:45:11 <fryguybob> > (2*) `fmap` [0..10]
12:45:12 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20]
12:45:51 <applicative> tonkman, in general, you might check out http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/Win32-2.2.0.2 and similarly with HGL-3.2.0.2
12:47:11 <sm> morning all
12:47:49 <roconnor> hmm, I'm using rank3 polymorphism
12:48:19 <djahandarie> I don't think I've ever actually made anything above rank2
12:48:21 <sm> doesn't cabal have apple framework options ? can't find them in --help
12:49:22 <stepcut> I wonder why there is no, mapParsecT :: (m a -> n b) -> ParsecT s u m a -> ParsecT s u m b
12:50:33 * stepcut peeks at the MonadReader instance for ParsecT
12:52:40 <Cheery> I plan writing a structural computer code editor in whatever language I find fit for it.
12:53:09 <stepcut> I guess the type would be a bit ugly,
12:53:10 <stepcut> mkPT $ \s -> local f (runParsecT p s)
12:53:13 <stepcut> oops
12:53:23 <stepcut> mapParsecT :: (Monad m, Monad n) => (m (Consumed (m (Reply s u a))) -> n (Consumed (n (Reply s u b)))) -> ParsecT s u m a -> ParsecT s u n b
12:53:23 <stepcut> mapParsecT f p = mkPT $ \s -> f (runParsecT p s)
12:54:00 <Cheery> I will need ability to measure text dimensions, show text, pictures, colors and lines on the screen. catch user text input and respond on it.
12:54:13 <Cheery> I'd also need some mutable data structures 
12:54:18 <Cheery> for graphical output
12:54:39 <djahandarie> You don't need mutable data structures for graphical output
12:54:56 <c_wraith> the framebuffer!
12:55:01 <c_wraith> it needs to be mutable!
12:55:14 <c_wraith> (not strictly true, actually)
12:55:28 <Cheery> I'm not entirely sure I need that possibility
12:55:51 <roconnor> I never thought I'd ever write a rank 3 polymorphic function
12:55:56 <roconnor> *never
12:55:59 <roconnor> er
12:56:00 <yrlnry> Yeah, what if the framebuffer is actually a laser printer?
12:56:00 <roconnor> ya
12:56:16 <djahandarie> roconnor, what is it for?
12:56:17 <Cheery> but now. you guys have these things in haskell ready, so I could just write the damn app instead of typing bunch of text/rect engine code for opengl first?
12:56:33 <aristid> roconnor: and there you are. on the totally outdated ghc 6.10.3, even
12:56:35 <Cheery> correct?
12:56:38 <c_wraith> wow.  I use rank-2 polymorphism sometimes, but I've never even been forced to consider rank-3
12:56:49 <roconnor> djahandarie: I'm trying to generalize uniplate to mutually recursive data types
12:57:01 <djahandarie> Cool
12:57:17 <roconnor> aristid: I'm not *that* out of date
12:57:19 <mreh> does Parsec not return a failure when there is unconsumed input?
12:57:19 <Cheery> c_wraith: map operations on functions.
12:57:23 <roconnor> ghc 6.10.4 :D
12:57:31 <mreh> the parse function forexample
12:57:45 * hackagebot epass 0.1.1 - Baisc, Erlang-like message passing supporting sockets.  http://hackage.haskell.org/package/epass-0.1.1 (AndreasBaldeau)
12:57:53 <aristid> roconnor: ok, that's better of course
12:58:17 <djahandarie> Cheery, there is a lot of stuff in Haskell, but all of it might not work for you. You should be ready to get your hands dirty if you are going to do anything heavily graphical
12:58:17 <Cheery> anyway. the editor can be done in whatever language I choose to. but I ask whether you've already got a module that provides me something more than a crude opengl interface?
12:58:45 * hackagebot websockets 0.1.2.5 - Server-side WebSocket protocol handshake and communication.  http://hackage.haskell.org/package/websockets-0.1.2.5 (SinisaBidin)
12:59:37 <Cheery> hmm.. no. not wanting to do half javascript/haskell aps
12:59:55 <Cheery> either one, not both
13:00:06 <djahandarie> Huh? Who mentioned Javascript?
13:00:19 <Cheery> hackagebot
13:00:24 <djahandarie> It's a bot
13:00:28 <dcoutts__> sm: yep, you can list framework deps in a .cabal file, like the C lib deps
13:00:40 <applicative> Cheery, I remember a simple editor illustration using wx
13:00:53 <djahandarie> You can look into functional reactive programming. But this will be an adventure before you get to a point where you can do something neat with it. Personally I'd just use a gui toolkit or opengl for a text editor
13:01:32 <mreh> is there an empty symbol I need to put at the end of my parsers?
13:01:33 <applicative> Cheery, here it is.  http://hackage.haskell.org/package/wxhnotepad
13:01:35 <mreh> isn't it assumd
13:01:39 <sm> dcoutts__: thanks.. and is there an --extra-framework-dirs or similar ? I'm having a really hard time finding docs for this incidentally
13:02:09 <dcoutts__> sm: ah, hmm, I'm not sure if there is
13:02:10 <djahandarie> There are pure interfaces to opengl, like graphics-drawingcombinator
13:02:13 <monochrom> parsec has eof to test for end of input
13:02:24 <djahandarie> Cheery, maybe that would be nice enough for your usage, dunno
13:02:27 <mreh> aha
13:02:32 <mreh> monochrom: thanks
13:02:45 <Cheery> djahandarie: pure.. as in they're modified and not resemble opengl?
13:02:51 <dcoutts__> sm: there's a field in the .cabal file but I don't think there's a command line extra for frameworks, there should be for the same reasons we have it for ordinary libs
13:02:54 <Cheery> if so. that might be indeed enough
13:03:03 <djahandarie> Cheery, as in they are pure, not in the IO type.
13:03:04 <dcoutts__> sm: a ticket would be appropriate
13:03:07 * sm thinks Cheery might like manatee/gtk2hs/cairo
13:03:15 <djahandarie> Cheery, if you don't know Haskell don't start here
13:03:16 <sm> dcoutts__: ok, thanks
13:03:20 <tonkman> I get Warning: "Module `Prelude' is deprecated" when I compile HGL
13:03:22 <djahandarie> You will be punching yourself
13:03:29 <tonkman> "You are using the old package `base' version 3.x."
13:03:38 <tonkman> Im sure I have base-4
13:03:52 <monochrom> but cabal chooses base-3 for you
13:03:58 <tonkman> why
13:04:02 <Cheery> djahandarie: I repick the pieces what I will need. knew haskell already once
13:04:04 <tonkman> where can i chance that
13:04:14 <monochrom> for fear of old packages incompatible with base-4
13:04:25 <Cheery> djahandarie: well I look up at them.
13:04:39 <djahandarie> monochrom, the HGL package specifically requires 3.*
13:04:46 <djahandarie> Err, tonkman*
13:04:48 <monochrom> oh I see.
13:04:49 * hackagebot snap-server 0.2.16.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.16.1 (GregoryCollins)
13:04:58 <applicative> Cheery, needless to say, it's in the structural part of  "structural computer code editor " that Haskell will be especially friendly, I think.
13:05:37 <tonkman> djahandarie: Im gettin errors when compiling hgl programs
13:05:41 <djahandarie> Cheery, Functional Reactive Programming (FRP) is definitely the extreme attack to any graphics needs and still needs a lot of work. But it's neat. Kind of like a research project
13:05:47 <applicative> tonkman, is it just a warning?  don't worry
13:05:50 <Cheery> applicative: wxhnotepad is a bit on the ready text-notepad -side.. that is simply controlled by haskell.
13:06:12 <tonkman> like undefined reference to `HGLzm3zi2zi0zi2_GraphicsziHGLziUtils_getKey_closure'
13:06:31 <djahandarie> tonkman, are you using 'ghc' to compile your programs?
13:06:36 <tonkman> I thought that it might originate from those compiling errors
13:06:38 <tonkman> yes
13:06:42 <djahandarie> Use ghc --make
13:06:48 <Cheery> my app would have its own display mechanism that doesn't need text except in symbols and such.
13:06:55 <tonkman> oh :)
13:07:28 <djahandarie> Okay I have wasted too much time on here. bbl
13:07:46 <monochrom> oh, so "hgl programs" does not mean programs coming from the HGL package
13:07:50 <Cheery> djahandarie: one question.
13:08:00 <aristid> Cheery: too late.
13:08:18 <applicative> Cheery, I'm not following, is someone going to edit in it?
13:08:23 <Cheery> well I ask it anyway. you know about a font lib that works with the gl module?
13:09:06 <Cheery> applicative: I've had earlier tests here somewhere. trying to catch a screenshot for you. that explains a whole bit of things.
13:09:48 <Cheery> those have been written in python, except I've hit the issue of having generally poor graphics handling routines there.
13:10:51 * hackagebot snap-server 0.2.16.2 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.16.2 (GregoryCollins)
13:13:23 <EvanR-work> snap is developing at the rate of several versions per day
13:13:30 <EvanR-work> they are almost as fast as manteelazycat
13:13:39 <c_wraith> heh.  I found a bug
13:13:57 <c_wraith> gcollins wanted to get the fix out immediately, but has accidently broken each try :)
13:14:15 <EvanR-work> extreme programming!
13:14:47 <c_wraith> (well, to be fair, one of my co-workers found it.  I just reported it and then fixed it...  By restoring some previous code.)
13:16:09 <Cheery> http://img186.imageshack.us/img186/5786/cseditor.png
13:16:28 <Cheery> applicative: here you got
13:16:53 <Cheery> I've had different development routes. another started representation centric, other started input centric
13:17:13 <Cheery> you see they lack each others features. :)
13:18:17 <Cheery> applicative: both are text based, but my friend noted how nice algebraic expressions would be in graphic vs. textmode so I decided to get on with opengl
13:18:31 <Cheery> not beginner with opengl, but I dislike it.
13:19:13 <roconnor> @pl (\proj -> eta . proj)
13:19:13 <lambdabot> (eta .)
13:20:43 <Cheery> applicative: you understand what I'm after here now?
13:20:52 <djahandarie> @pl (\reduce -> eta reduce)
13:20:53 <lambdabot> eta
13:20:54 <mercury^> :t proj
13:20:55 <lambdabot> Not in scope: `proj'
13:20:56 * djahandarie giggles
13:21:00 <djahandarie> Wait why am I back here
13:21:02 <mercury^> Oh.
13:21:16 * djahandarie disappears into the darkness again
13:21:28 <applicative> Cheery, no, I'm having trouble, but it's probably me... 
13:22:09 <Cheery> applicative: its going to show AST from programs, which you can edit with keyboard macros.
13:22:21 <Cheery> save and load
13:22:27 <Cheery> and compile
13:22:45 <EvanR-work> thats pretty hardcore
13:23:05 <EvanR-work> you know, in that environment i think your biggest inefficiency would be typing out names of variables
13:23:24 <EvanR-work> if the tree is now a tree rather than sequence of tokens, variable names should not be sequence of characters
13:23:30 <EvanR-work> represent variable names some other way
13:24:24 <Cheery> EvanR-work: that may be correct view.
13:25:39 <deech> Hi al,
13:25:46 <tonkman> Im still not getting HGL hello world to work
13:26:16 <tonkman> It compiles "ghc --make Main", but when I run it, nothing happens
13:26:20 <EvanR-work> Cheery: chinese han characters
13:26:21 <deech> Hi all, I just found the Lambada project which claims to integrate Haskell and Java. Does anyone know where I can get sources?
13:26:38 <tonkman> when double clicking, command prompt appears
13:26:44 <Cheery> EvanR-work: what do they look like and how do you do them?
13:26:54 <EvanR-work> Cheery: just dont infringe on The Matrix too much, youll get sued
13:27:08 <EvanR-work> (they use japanese as far as i know, so youre good)
13:27:21 <EvanR-work> Cheery: do them?
13:28:15 <Cheery> yeah. like.. what are the pieces used to construct them?
13:28:23 <Cheery> (graphically)
13:28:30 <Cheery> and how would you like to type them in.
13:29:25 <EvanR-work> Cheery: well you do strokes, abstract forms used in chinese dictionaries
13:29:44 <EvanR-work> you can type them in using a qwerty system based on those strokes
13:29:47 <EvanR-work> like texting
13:30:18 <EvanR-work> its called wubi
13:30:44 <tonkman> runghc Main, works but windows freezes
13:31:25 <Cheery> EvanR-work: you know a chinese dictionary that has all those strokes?
13:31:38 <EvanR-work> heres one for traditional characters
13:31:49 <EvanR-work> http://www.zhongwen.com/
13:32:40 <Cheery> preferrably I'd also like vector shape paths for them. but I can make them fast if there's only couple of them
13:33:49 <EvanR-work> Cheery: a font rendering engine can do it for you
13:34:26 <Cheery> but then the benefits would end up being limited to input
13:35:12 <EvanR-work> its not likely you can put in a chinese character that is not in unicode
13:35:20 <EvanR-work> i mean, would want to
13:36:48 <applicative> tonkman, I can't compile hgl-examples since it has a nonexistent dependency
13:37:06 <tonkman> I noticed
13:37:20 <applicative> tonkman, but one file is sound, pasted here:  http://hpaste.org/41361/hgl_example
13:37:52 <applicative> then further down the page I import it for a moronic hello world .  I'm using x11, so maybe there's a windows problem
13:38:07 <Cheery> graphics-drawingcombinators seem fine for me
13:38:34 <Aune> @@ΩΩΩłŁ€¢®®þÞ←¥↓↑→ıœŒþÞºªºß§ðÐđđªªħĦjJĸ&łŁøØæÆ´××|¦«<»>©©“‘”’nNµºß§º,
13:38:46 <tonkman> when I start Main.exe from command prompt, it totally freezes
13:39:11 <EvanR-work> Cheery: i was just talking about variable names
13:39:12 <tonkman> could try reinstalling ghc and everything
13:39:13 <applicative> you are doing  ghc --make helloworld.hs -o helloworld.exe
13:39:18 <tonkman> yes
13:40:21 <Cheery> EvanR-work: yep.
13:40:24 <EvanR-work> chinese has the advantage of being a single character, a single syllable, and most people can read them ;)
13:40:27 <applicative> tonkman, curses.  wish i had more windows wisdom.  it could be very simple. 
13:40:42 <EvanR-work> and there are a lot of them
13:41:05 <Cheery> EvanR-work: I consider there might be easily renderable nice-looking form of graphic symbols you could type in.
13:41:30 <EvanR-work> my suggest is lacking which one of those?
13:41:33 <EvanR-work> suggestion
13:41:52 <Cheery> well. with chinese characters I'd need unicode font rendering engine
13:42:02 <EvanR-work> that already exists
13:42:11 <EvanR-work> someone was just talking about one
13:42:53 <Cheery> yes it does. though I'd rather minimize the amount of mechanisms you need. :)
13:43:01 <applicative> tonkman, and you evidently don't have problems compiling and running regular command line executables? ...  like main = putStrLn "hello world" 
13:43:04 <EvanR-work> as an end user?
13:43:18 <Cheery> as a developer.
13:43:24 <EvanR-work> im not developing it
13:43:49 <EvanR-work> all users already have font rendering engines
13:44:04 <EvanR-work> freetype
13:44:10 <Cheery> sure they have.
13:44:27 <Cheery> just that they are very complex stuff.
13:44:27 <tonkman> applicative: everything else works
13:44:46 <Cheery> though your suggestions brought up some ideas. :)
13:44:48 <EvanR-work> Cheery: the interface is simplified for you by graphics libraries
13:44:56 <EvanR-work> and only you would have to deal with that
13:45:15 <roconnor> aww, you can't have a type name and a class name be the same?
13:45:15 <Cheery> true. still it doesn't change the thing that its there.
13:45:45 <EvanR-work> well, since its haskell, ill probably be able to replace whatever you do with chinese after the fact ;)
13:45:58 <Cheery> so if I can find a mechanism that can let me leave font rendering engine out, I might consider it. :)
13:46:02 <pumpkin> roconnor: nope :/
13:46:19 <EvanR-work> Cheery: well you can make your own bitmap font
13:46:38 <tonkman> applicative: this might be a linking problem
13:46:44 <tonkman> at least it seems like one
13:46:48 <Cheery> yep. though no unicode that way. and such bitmap font would be ugly.
13:46:56 <EvanR-work> why no unicode?
13:47:19 <EvanR-work> you certainly cant draw them all yourself, so it would be automated. the automation just has to not mess with the encoding
13:47:24 <Cheery> because I wouldn't bother to type in that many characters into a character map. ^^
13:47:49 <Cheery> yeah. my friend has proposed that approach
13:48:00 <Cheery> it'd solve one other problem
13:48:04 <applicative> tonkman, sorry, I'm clueless. usually when making an executable with "ghc --make ..."  linking failures prevent making the executable
13:48:24 <Cheery> the font appearance varies over different platforms
13:48:28 <djahandarie> Most folks here are on Linux/Mac
13:48:28 <Cheery> if you use system fonts
13:48:38 <djahandarie> I think applicative is the only person I ever see help with Windows problems actually :P
13:48:45 <EvanR-work> well you usually dont have chinese as part of the system fonts, so you could use your font .ttf of course
13:48:49 <EvanR-work> of choice
13:49:27 <JohnnyL> What's the secret behind *not* having to learn all of Haskell's functions?
13:50:11 <tonkman> after runGraphics I can print to console
13:50:17 <tonkman> but not after openWindow
13:50:22 <Cheery> how do I install a package from hackageDB?
13:50:27 <applicative> djahandarie, there are several genuine windows experts around from time to time, tonkman could do with some advice from one
13:50:43 <Cheery> nvm. I look it up
13:51:05 <EvanR-work> cabal install foo
13:51:27 <tonkman> I hate these weird bugs
13:52:34 <djahandarie> JohnnyL, there aren't many functions in the Prelude
13:52:53 <cts> JohnnyL: Do you know Hoogle?  That's a good way to find functions one needs.
13:53:17 <djahandarie> But beyond those, usually just use Hoogle or Hayoo and read the type signatures
13:53:21 <Cheery> cts: does Hoogle find also ones in third party libs?
13:53:35 <applicative> Cheery, there is a method for adding them
13:53:37 <djahandarie> Hoogle is picky about what it indexes. Hayoo indexes everything in Hackage.
13:53:43 <lispy1> JohnnyL: Developing an understanding for the implications of types helps a lot
13:53:51 <EvanR-work> none of you read his question, he wants to *not* learn them
13:54:02 <EvanR-work> if he looks them up to use them, he will learn them
13:54:02 <monochrom> re-invent all functions. then there is nothing to learn.
13:54:19 <EvanR-work> yes, implement these functions yourself
13:54:24 <EvanR-work> most of them are trivial anyway
13:54:25 <applicative> the names are nonsense, he knows; he wants to think only of the types
13:54:33 <lispy1> JohnnyL: you could also hire an experienced Haskell programmer to do the work for you
13:54:34 <applicative> @type reverse
13:54:35 <lambdabot> forall a. [a] -> [a]
13:54:40 <Vanadium> @type unsafePerformIO
13:54:40 <lambdabot> Not in scope: `unsafePerformIO'
13:54:45 <Vanadium> @type unsafeCoerce
13:54:46 <lambdabot> Not in scope: `unsafeCoerce'
13:54:50 <EvanR-work> IO a -> a
13:54:54 <Cheery> yay. waiting for drawingcombinators install
13:54:59 * applicative didn't mean that kind of type
13:55:21 <JohnnyL> I suppose it's alot like linux, just alot of memorize and reading.
13:55:23 <c_wraith> @type Unsafe.Coerce.unsafeCoerce
13:55:24 <lambdabot> forall a b. a -> b
13:55:42 <EvanR-work> i make a strict distinction between learning and memorizing
13:55:50 <EvanR-work> everything i ever memorized i forgot
13:55:57 <EvanR-work> i still know some of the stuff i learned
13:56:03 <applicative> the association of the reverse function with the word "reverse" is a matter of memorization
13:56:05 <lispy1> JohnnyL: another approach: Pick one haskell function (perhaps randomly), and make sure you always ignore how it works.  That way you can say you never learned all of the haskell functions and you can cite your counter example
13:56:15 <EvanR-work> applicative: learning
13:56:30 <EvanR-work> you cant forgot it
13:56:53 <Cheery> ftgl failed to install
13:57:01 <applicative> > let seeIfEvanCanRememberThisxhshajjdhdhfggeyuhfjsjksk = reverse in seeIfEvanCanRememberThisxhshajjdhdhfggeyuhfjsjksk "hi"
13:57:01 <lambdabot>   "ih"
13:57:05 <EvanR-work> Cheery: you probably dont have the C library
13:57:08 <djahandarie> Cheery, do you have the ftgl dev libs?
13:57:51 <Cheery> djahandarie: no. I started to wonder at it after googling up what the heck is ftgl
13:58:27 <EvanR-work> Cheery: my-distro-installer install ftgl
13:58:31 <applicative> JohnnyL, anyway the prelude list functions are pretty easy... dropWhile, takeWhile, reverse, head, tail, etc.
13:59:00 <Cheery> this thing needs opengl context.
13:59:14 <Cheery> proposes SDL, you have better ways?
13:59:28 <EvanR-work> what *are* your requirements?
13:59:42 <EvanR-work> anything graphical is going to pull in tons of shared libs
13:59:48 <EvanR-work> except for linux framebuffer
14:00:19 <Cheery> I'd consider EGL if there were libs for nvidia cards on my system.
14:00:38 <EvanR-work> if you are not using opengl directly, but using a lib, whats the difference
14:00:55 <applicative> tonkman, i have to go.  good luck. i think there will be someone who knows about hgl + win32 on here at some point. 
14:01:01 <Cheery> well.. I expect some haskell-stuff, that is not bound on sdl.
14:01:09 <Cheery> EvanR-work: if there's not, well.. SDL is okay
14:01:48 <Cheery> not too interested on sdl events. :)
14:02:36 <djahandarie> There are no dependencies in Haskell that should be pulling SDL for that lib, Cheery 
14:02:44 <djahandarie> It must just be your distro doing some weird stuff and wanting it
14:03:45 <Cheery> http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/0.3/doc/html/Graphics-DrawingCombinators.html
14:04:06 <Cheery> or hm.. wait thats old version
14:04:09 <JohnnyL> lispy1: #lisp called , it wants it's attitude back.
14:04:39 <djahandarie> Cheery, yes, a very old version
14:04:41 <djahandarie> He's on 1.4.1 now
14:04:47 <Saizan> there was a paper linking a modified (>>=) with type M a -> (a -> M b) -> M (a,b) to the dependent sum/product (Sigma), anyone remembers it? it was about [de]serialization
14:05:16 <Cheery> modules provide documentation along them when installed?
14:05:31 <Cheery> if so, how to access it?
14:05:57 <Cale> Cheery: yeah, if you have haddock installed, and the documentation option is turned on.
14:06:08 <Cale> (It's always accessible on the web regardless)
14:07:04 <Cale> In ~/.cabal/config there's an option  documentation: True  which you can uncomment to produce documentation for packages installed by cabal
14:07:17 <Cale> (If it's not there, you can just add it somewhere near the top)
14:08:25 <Cheery> djahandarie: it still requires SDL
14:08:27 <Cale> The documentation for all locally-installed packages shows up in ~/.cabal/share/doc/index.html
14:08:34 <Cheery> but heck! i'll install that
14:09:10 <djahandarie> Cheery, it shouldn't be.
14:09:14 * FunctorSalad finds it pretty useful to have a script that takes the package name as the first arg and opens that package's local docs in a browser
14:09:44 <Cheery> djahandarie: I looked up example from latest package. used SDL
14:09:58 <Cheery> doesn't 'require' it. but needs SDL or equivalent
14:10:08 <djahandarie> Right. SDL isn't a dependency
14:10:31 <EvanR-work> Cheery: haskell does not have native graphics
14:10:49 <EvanR-work> and native graphics just means it would use opengl for instance behind the scenes, supported by the platform
14:11:08 <EvanR-work> Cheery: did you install ftgl yet?
14:11:14 <Cheery> EvanR-work: yep
14:11:20 <EvanR-work> ok whats the problem?
14:11:34 <Cheery> EvanR-work: nothing right now.
14:12:27 <Cheery> can you show me then how to type in chinese? I'm interested about that anyway
14:13:09 <Cheery> since you mentioned it, I remember to leave in enough customization for that one.
14:14:11 <daedra> hey, how come :t []  (type of [])  gives  [a]? What is a here?
14:14:16 <daedra> > :t []
14:14:16 <lambdabot>   <no location info>: parse error on input `:'
14:14:30 <daedra> well ghci does :P
14:14:48 <EvanR-work> Cheery: you just install scim or another input method front end
14:15:12 <EvanR-work> first learn chinese, then learn pinyin or wubi, then ???, then profit
14:16:43 <djahandarie> You can type in Chinese by typing stuff into Google Translate and hitting the Translate button
14:17:47 <JohnnyL> EvanR-work: Now I know where my underwear has gone!
14:20:11 <daedra> In GHCI, :t []  gives  [] :: [a]. What is the [a] here?
14:20:55 <EvanR-work> JohnnyL: that is a disturbing proclamation! why is it addressed to me!
14:21:07 <EvanR-work> daedra: anything
14:21:09 <dqd> daedra: It means list of any type.
14:21:13 <daedra> I expected :t () to similarly give () :: (a)... but it gives ()
14:21:17 <daedra> oh ok
14:21:23 <EvanR-work> @src ()
14:21:23 <lambdabot> data () = ()
14:21:30 <EvanR-work> @src (a,b)
14:21:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:21:33 <EvanR-work> @src (,)
14:21:34 <lambdabot> Source not found.
14:21:42 <daedra> @src []
14:21:42 <lambdabot> data [] a = [] | a : [a]
14:21:54 <daedra> oooh
14:22:14 <daedra> now that.. I have no idea what that means
14:22:15 <EvanR-work> [a] is list of values of some type a. () is ().
14:22:19 * hackagebot jort 1.0.0 - JP's own ray tracer  http://hackage.haskell.org/package/jort-1.0.0 (JeanPhilippeBernardy)
14:22:34 <sipa1024> daedra: both () and [] are valid value-level expressions and type-level expressions
14:22:35 <djahandarie> daedra, that'd be the definition of a list
14:22:49 <EvanR-work> [] is only valid type level with something in it
14:22:52 <sipa1024> daedra: () is the unit type, with () as only value
14:23:30 <stepcut> ?seen lambdabot
14:23:30 <lambdabot> Unknown command, try @list
14:23:59 <sipa1024> daedra: [a], which is syntactic sugar for ([] a), is the type of lists of value a, with [] a possible value of it
14:24:36 <djahandarie> daedra, data List a = Nil | Cons a (List a)
14:24:43 <djahandarie> That may be an easier-to-read definition
14:25:39 <djahandarie> Just replace List a with [a] and you have how Haskell does it (except you can't do it like that since there is no circumfix notation)
14:26:16 <EvanR-work> circumfix!
14:26:33 * JohnnyL watches lispy1 grab his balls and run for the hills!
14:26:39 <daedra> djahandarie: yep
14:26:40 <daedra> thanks :)
14:27:43 <aristid> @quote ennobunktor
14:27:43 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
14:28:11 <daedra> I'm currently learning from Learn You A Haskell For Great Good
14:28:29 <dget> Hi, I'm trying to import a module in GHCi, but can't because it's a hidden module in its package. how do I get around this?
14:28:33 <daedra> is there a bunch of exercises out there that I could do
14:28:44 <daedra> (and that you recommend)?
14:28:59 <aristid> daedra: doesn't learn you a haskell have exercises too?
14:29:05 <BONUS> no, sadly :)
14:29:13 <BONUS> good exercises are really hard to come up with
14:29:24 <BONUS> but maybe i'll try and come up with some one of these days
14:29:32 <daedra> aristid: maybe.. I haven't seen any yet
14:29:39 <JohnnyL> You set us up the bomb?
14:29:54 <aristid> oh
14:30:11 <BONUS> what you say
14:30:20 <aristid> daedra: well then fetch your ghci, a text editor, and try out everything in lyah, and everything that comes to mind
14:30:22 <EvanR-work> JohnnyL that is insulting
14:30:39 <JohnnyL> EvanR-work: what ?
14:30:40 <EvanR-work> the exactly translation is .... set up us the bomb
14:30:50 <Cale> dget: You can get the source code of the package and load it from there.
14:30:51 <JohnnyL> hahaha
14:30:55 <aristid> EvanR-work: of what?
14:31:01 <EvanR-work> no one knows
14:31:05 <daedra> make your time.
14:31:21 <BONUS> daedra: have you tried project euler? it's fun for a time
14:31:30 <djahandarie> aristid, 機関士：何者かによって、爆発物が仕掛けられたようです。
14:31:33 <daedra> oh yes
14:31:35 <EvanR-work> ah
14:31:38 <daedra> I'll check that out
14:31:46 <djahandarie> aristid, "Someone has planted an explosive" would be a better translation
14:32:00 <aristid> djahandarie: i don't get the joke
14:32:00 <BONUS> also on google code jam you have exercises of varying difficulties
14:32:10 <EvanR-work> Engineer: by someone, it seems bomb-making
14:32:15 <djahandarie> aristid, you haven't heard of "ALl your base are belong to us"?
14:32:19 <EvanR-work> thanks google
14:32:20 <EvanR-work> thanks
14:32:21 <fengshaun> daedra, programmingpraxis.com is also good
14:32:26 <aristid> djahandarie: yes. and?
14:32:29 <lispy1> JohnnyL: I hope I didn't take their attitude.  It's much nicer here and I'd hate to bring negativity.
14:32:35 <djahandarie> aristid, okay, then there is no joke.
14:32:42 <dget> Cale: aha, thanks!
14:32:42 <djahandarie> It's just a shitty translation that became a meme.
14:32:54 <JohnnyL> lispy: No probs, I'm just playing with you.
14:33:04 <JohnnyL> I am bored.
14:33:14 <EvanR-work> djahandarie: the original meme
14:33:15 <djahandarie> lispy1, you always end up going back to lispy, huh
14:33:21 <sipa1024> JohnnyL: try writing a haskell interpreter in lambdabot
14:33:24 <sipa1024> that would be cool!
14:33:32 <djahandarie> lambdabot already has a haskell interpreter
14:33:38 <aristid> djahandarie: these memes can be pretty boring at times
14:33:49 <sipa1024> no no, i don't mean a haskell interpreter for lambdabot
14:33:52 <int80_h> implement a JVM in lambdabot!
14:33:54 * int80_h ducks
14:33:55 <sipa1024> i mean *in*
14:33:58 <EvanR-work> aristid: memes are better served with a youtube video and a soundtrack
14:34:11 <aristid> EvanR-work: never gonna give you up *sing*
14:34:14 <EvanR-work> possibly starring comentary from hip teens
14:34:25 <pygmalion> i'm working on a Complex number parser with ReadP for an assignment, and i'm having some issues with the "newtype" keyword. the commented out newtype line at the top of the paste is what we are supposed to be considering, but that won't compile http://pastebin.com/pMbyeUys
14:35:12 <djahandarie> @hoogle parse
14:35:12 <lambdabot> Text.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
14:35:12 <EvanR-work> man, haskell assignment designers really know how to bore
14:35:12 <lambdabot> Text.ParserCombinators.Parsec.Prim parse :: Stream s Identity t => Parsec s () a -> SourceName -> s -> Either ParseError a
14:35:12 <lambdabot> Network.URI parseAbsoluteURI :: String -> Maybe URI
14:35:19 <djahandarie> @hoogle parseFile
14:35:19 <lambdabot> Language.Haskell.ParseMonad parseFilename :: ParseMode -> String
14:35:19 <lambdabot> Language.Haskell.Parser parseFilename :: ParseMode -> String
14:35:31 <Cheery> (.data+0x108): undefined reference to `SDLzm0zi6zi2_GraphicsziUIziSDLziGeneral_quit_closure'
14:35:32 <byorgey> pygmalion: newtype is only for things that wrap a single value with a single constructor
14:35:42 <byorgey> pygmalion: so newtype Complex = Complex Double Double  won't work
14:35:50 <EvanR-work> @src Complex
14:35:50 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
14:35:55 <byorgey> pygmalion: you'll have to do   data Complex = Complex Double Double
14:36:00 <JohnnyL> You got a big car, have a lot money.. women? wanna get high? try this: http://youtubeeconomy.blogspot.com/2010/11/gimmie-pizza-p-i-z-z-slow-motion.html
14:36:08 <byorgey> pygmalion: or you could do  newtype Complex = Complex (Double, Double)
14:36:21 <byorgey> @where ops
14:36:21 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:36:31 --- mode: ChanServ set +o pumpkin
14:36:32 --- mode: ChanServ set +o mauke
14:36:32 --- kick: JohnnyL was kicked by mauke (JohnnyL)
14:36:33 <pumpkin> what?
14:36:46 <pumpkin> he actually has been in here for a while
14:36:50 <djahandarie> Yeah
14:36:57 <djahandarie> Not sure why he randomly said that
14:36:58 --- mode: pumpkin set -o pumpkin
14:37:05 <mauke> hence no ban
14:37:18 <aristid> byorgey: you're not in that list of ops?
14:37:26 <byorgey> apparently not
14:37:26 <pygmalion> byorgey: the assignment had that line exactly. i guess he made a typographical error. would data change anything about the way the parser should be written?
14:37:30 <Cheery> good night
14:37:46 <byorgey> pygmalion: yes, probably just a mistake,  and no, it will not change anything.
14:37:53 <byorgey> night Cheery 
14:38:12 <pygmalion> byorgey: perfect thanks. okay now i debug the parser itself... i may be back! thanks :)
14:38:20 <EvanR-work> how unusual
14:38:20 <Watermind> was looking at this: http://www.haskell.org/haskellwiki/Prime_numbers
14:38:28 <byorgey> pygmalion: ok, great =)
14:38:32 --- mode: mauke set -o mauke
14:38:43 <lispy1> djahandarie: my work computer keeps calling me lispy1 but my home computer calls me lispy and I don't feel like using screen to fix it
14:39:10 <EvanR-work> thatll teach JohnnyL to active his periodic random inane comments script in #haskell
14:39:29 <JohnnyL> why was I kicked?
14:39:32 <byorgey> suppose I have a set of vectors spanning an (n-1)-dimensional hyperplane, and two other vectors not lying in the hyperplane
14:39:46 <Watermind> in the 2nd version, a span is used to avoid testing if p mod n /= 0   on n <= p^2
14:39:48 <Watermind> which makes sense
14:39:52 <byorgey> how can I check whether they line on the same side of the hyperplane or not?
14:39:55 <byorgey> *lie
14:39:57 <mauke> JohnnyL: sending something that looks like spam
14:40:07 <JohnnyL> mauke: it's not , it's a funny!
14:40:25 <mauke> and completely non sequitur
14:40:28 <Watermind> but why is the head of the 2nd list in the result of the span ignored?
14:40:48 <Watermind> -- >  where (h,~(_:t)) = span (< p*p) xs
14:40:53 <pumpkin> JohnnyL: if you want to talk about off-topic stuff, #haskell-blah, but that just looked like spam
14:40:57 <Cale> Watermind: Because we know that it can't be prime, since it's p*p
14:41:06 <JohnnyL> mauke: It was my Jim Morrison intro.
14:41:21 <JohnnyL> sorry
14:41:36 <Watermind> Cale: ouch, that was stupid... 
14:41:58 <Watermind> Cale: thanks
14:43:01 <Cale> Watermind: no problem
14:43:38 <EvanR-work> JohnnyL: its funny because they usually tolerate a lot worse crap in here
14:43:54 <markspezzano_> Hi all..I'm getting a strange error when installing some packages .... namely Fibon bechmarking suite. But it complains with others also. I've tried to muck around with ghc-pkg with little success. Has anyone had the problem of "unusable due to missing or recursive dependencies" when installing via cabal? How do I fix this. I can post some of the output if that helps. Thanks.
14:44:30 <Cale> markspezzano_: Yeah, you'll probably have to pastebin the output.
14:44:40 <dcoutts__> markspezzano_: check you don't have broken packages, use ghc-pkg check to see
14:44:54 <dcoutts__> markspezzano_: if you do, you'll need to reinstall those ones
14:45:17 <JohnnyL> EvanR: They probably saw the intro and said 'oh no, not again!' (Later turning into a sperm whale and a bowl of petinas) and didn't go to the link!
14:45:49 <markspezzano_> how do I know which ones are broken? Some come up in red and others in blue, but most are in green (default colour in my terminal window)
14:45:56 <baguasquirrel> is there any place I can go to for the changelogs to a package? say, HTTP 4000.1.0?
14:46:00 <monochrom> red is broken
14:46:19 <Cale> ghc-pkg check gives coloured output now?
14:46:36 <monochrom> in fact ghc-pkg list already gives coloured output
14:46:37 <markspezzano_> well none are in red. I fixed those.
14:46:57 <JohnnyL> petunias
14:47:03 <markspezzano_>  Cabal-1.8.0.6-ec9be469687b5a514f4b7e8e2b8343c7 is unusable due to missing or recursive dependencies:
14:47:04 <markspezzano_>       process-1.0.1.3-1209536e5ce8f43dc64e390034356d63
14:47:04 <markspezzano_>     (use -v for more information)
14:47:27 <FunctorSalad> Cale: IIRC list does
14:47:53 <FunctorSalad> blue=hidden,red=broken or the other way around
14:47:55 <Cale> markspezzano_: Do you have one of those packages installed locally?
14:47:59 <arcatan> baguasquirrel: there's CHANGES file in the HTTP tarball
14:48:11 <baguasquirrel> arcatan: thanks man
14:48:14 <Cale> markspezzano_: Cabal and process are both packages that come with GHC and should be part of your global install.
14:48:31 <arcatan> baguasquirrel: and if that's not enough, here's the git commit history: https://github.com/haskell/HTTP/commits/master
14:48:47 <markspezzano_> probably.... is that bad? I just do a cabal install Fibon to install the Fibon benchmarking suite.
14:49:30 <shapr> EvanR-work: If we've been tolerating lots worse here in #haskell, then it's time for a crackdown.
14:49:32 <int80_h> how can I use ghci to inspect bindings? Even though ghci says I have loaded a module, it says "out of scope" when I try to see what a particular binding looks like.
14:49:32 <monochrom> markspezzano_: when you "ghc-pkg list" you probably see one or two directory names like "..../package.conf.d". do you mind packing up both directories and uploading them somewhere for me? I can't debug your problem now but I'm writing an article on these things and I need a problematic setup ready-made.
14:51:13 <monochrom> int80_h: see http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/interactive-evaluation.html#ghci-scope for the exact semantics of scope and :load and :module
14:51:37 <int80_h> thanks :)
14:51:37 <monochrom> don't rely on urban legend
14:51:40 <FunctorSalad> EvanR-work: AFAIK we never tolerated spam, and I second that it looked like spam to me
14:51:46 <FunctorSalad> (no, I hadn't clicked either)
14:52:09 <Aune> can someone recommend a good introduction to combinatorics?
14:52:14 <EvanR-work> haskell crackdown
14:53:05 <JohnnyL> lmao
14:53:17 <Cale> Aune: Every introduction I know of is a two-element subset of {good, introductory, widely available}
14:53:35 <djahandarie> Aune, introductory combinatorics by brualdi is a decent book
14:54:14 <monochrom> I like Peter J. Cameron's "Combinatorics: ...." book
14:54:39 <JohnnyL> Cale, Are there any hardware-cpus who mnemonics implement SKI using combinatories?
14:54:50 <JohnnyL> s/who/whose
14:55:10 <Aune> I am googling them now
14:55:14 <Cale> JohnnyL: I don't know about SKI specifically. There have been CPUs in the past which operated using combinatory logic.
14:55:17 <djahandarie> I think Algner's A course in Enumeration was a good book, but not introductory
14:55:22 <JohnnyL> Cale, interesting
14:55:34 <Cale> (I think BCKW)
14:55:57 <shapr> JohnnyL: Have you seen the Reduceron?
14:58:34 <JohnnyL> shapr: No, I have yet to google anything regarding hardware and combinatorics. thought i'd ask here.
14:59:21 <shapr> JohnnyL: Ah, it's best to google first, otherwise people may start asking you if you've tried google first.
14:59:43 <EvanR-work> not to be confused with combinational logic
14:59:46 <EvanR-work> vs sequential logic
14:59:58 <djahandarie> This channel is like a computer science and maths-related academic paper searcher
15:00:03 <shapr> EvanR-work: Oh hey, how's your Haskell project going?
15:00:37 <EvanR-work> i should probably keep working on that
15:00:41 <EvanR-work> currently stalled
15:00:47 <shapr> EvanR-work: Got any source online?
15:00:55 <EvanR-work> no not yet
15:00:57 <Cale> I really need to write books about lots of things...
15:01:12 <shapr> I'm thinking of resurrecting Fermat's Last Margin.
15:01:22 <djahandarie> Cale, do you have any papers published?
15:01:30 <Cale> djahandarie: No.
15:02:05 <Cale> Well... there might be something with my name on it, since I helped the guy who wrote it solve the problem. I forget where that was.
15:02:42 <monochrom> what is Fermat's Last Margin?
15:02:55 <djahandarie> Cale, you think of an idea, I'll write it. ;)
15:03:05 * djahandarie sees the money pouring in alrea- oh wait, no I don't.
15:03:13 <shapr> monochrom: It's basically a wiki that uses darcs to store annotations for research papers.
15:03:51 <shapr> monochrom: The advantage is that you can get annotations from other people too.
15:04:03 <djahandarie> Cale, by the way, I think your website went down ages ago and never came back up
15:04:09 <Cale> Well, really I'd like David Jackson to publish his course notes on combinatorics as a book.
15:04:14 <EvanR-work> shapr: are you actually interested or are you evaluating my non-troll status
15:04:19 <shapr> EvanR-work: Both.
15:04:19 <Cale> djahandarie: Yeah, I know about that.
15:04:26 <EvanR-work> im not sure i like this
15:04:43 <shapr> EvanR-work: You could write more code. That clearly demonstrates non-troll status.
15:04:45 <monochrom> ah, no wonder "margin"
15:04:53 <shapr> monochrom: Yes, exactly!
15:05:03 <EvanR-work> thats the last reason i would write code
15:05:10 <shapr> EvanR-work: Good to know :-)
15:05:20 <Cale> djahandarie: I just have to go downstairs and bring the machine up again. Really I have to duplicate the webserver onto my new machine, but I've been procrastinating that, since it's an annoying bunch of work.
15:05:32 <djahandarie> Virtualize it!
15:06:11 <Cale> Ugh, don't make me think about virtual machines. I have enough trouble dealing with VMware :P
15:06:43 <int80_h> so, I've read the reference to ghci and how it handles scope in respect to :load and :m. However, from what I understand, :load puts everything that you loaded in scope. Yet when I do :load main.lhs and then try to print the contents of a binding, it still says "out of scope". So what am I doing wrong?
15:06:55 <EvanR-work> i think ill just make your crackdown easier and leave
15:06:56 <Cale> I suppose that has more to do with the fact that I'm using VMware for an unsupported guest OS, but whatever :)
15:07:10 <monochrom> no, :load puts the first argument into scope only, IIRC
15:07:26 <ketil> int80_h, I think if you compile the file first, only exported functions are available.
15:07:45 <ketil> try removing any .o and .hi files?
15:08:31 <int80_h> ah okay I will remove the .o and .hi files
15:10:37 <int80_h> still getting out of scope. This is a binding in main, btw. I am using :load, and removed the .hi and .o files
15:11:06 <monochrom> does the prompt look like "*Main>"?
15:11:17 <shepheb> anyone familiar with Yesod's Persistent layer? I need to store an undirected graph and I'm wondering the best way to pull it off.
15:11:18 <monochrom> emphasis on the *
15:11:28 <int80_h> yeah it is "*Main"
15:11:40 <int80_h> yeah it is "*Main>", I mean
15:12:06 <monochrom> strange
15:12:07 <kmc> int80_h, did you use -fforce-recomp?
15:12:13 <kmc> that will make it ignore the .o files basically
15:12:31 <int80_h> I will try that
15:13:38 <int80_h> I need to actually run main in order to get access to bindings right? That's what I have been doing.
15:14:44 <int80_h> so I can use functions, but I cannot print let bindings. Is that supposed to be that way?
15:14:46 <monochrom> what is binding, really?
15:14:53 <monochrom> yes
15:15:26 <int80_h> so if I want to inspect a [[Char]], I have to write a function to process it?
15:15:28 <BeginnerAtHaskel> hello can anyone help me with this: http://hpaste.org/41356/addpathsto
15:15:55 <monochrom> you could move a binding to the top level, or you could use the debugger
15:16:16 <int80_h> it's in main, that's not top level?
15:16:26 <monochrom> not top level
15:16:42 <int80_h> okay where's a good document on the debugger?
15:16:46 <int80_h> I will try that
15:16:46 <monochrom> top level means not under someone else's let, not under someone else's where
15:17:06 <monochrom> I think http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/ghci-debugger.html is quite ok
15:17:39 <int80_h> thanks. This is the largest thing I have done in haskell and I want to make sure I have a good debugging technique sorted out before I go on.
15:21:19 <BeginnerAtHaskel> hello can anyone help me with this: http://hpaste.org/41356/addpathsto thanks in advance
15:21:54 <Cale> int80_h: Using a debugger is usually my last resort in how I approach bugs.
15:24:11 <guest2425> hello
15:24:28 <Cale> guest2425: hello!
15:24:45 <Cale> BeginnerAtHaskel: Many people can probably help
15:25:03 <djahandarie> Oh god
15:25:08 <guest2425> Cale: is this ok in Haskell shortestPath graph from to = shortest (allPathsTo (reachableFrom graph from) to)'
15:25:17 <guest2425> Cale: is this ok in Haskell shortestPath graph from to = shortest (allPathsTo (reachableFrom graph from) to)
15:25:23 <djahandarie> Someone needs to teach this teacher how to teach
15:25:30 <pumpkin> lol, another one?
15:25:33 <djahandarie> I'm pretty sure every student in his class has come in here to ask for help by now
15:25:39 <djahandarie> pumpkin, another two.
15:25:43 <guest2425> i know huh
15:25:56 <BeginnerAtHaskel> Cale yes but who can help me understand it
15:26:13 <Cale> djahandarie: If I was teaching Haskell, I would actively be telling my students to come to #haskell
15:26:30 <int80_h>  Cale: how would you go about inspecting the contents of a let binding, without the debugger?
15:26:42 <Cale> int80_h: I would look in the source code :)
15:26:56 <djahandarie> Cale, but for a different motive... to learn beyond what is taught in the class, rather than to try and learn what was taught in the class poorly
15:26:56 <Cale> int80_h: (A strange thing to do, I know ;)
15:27:11 <Cale> djahandarie: Well, one would hope :)
15:28:25 <Cale> :t let extendedRecursionEngine termCond termFn reduceFn mapFn wayAheadFn x = recursiveFn x where recursiveFn y | termCond y = termFn y | otherwise = reduceFn (mapFn y) (map recursiveFn (wayAheadFn y)) in extendedRecursionEngine
15:28:26 <lambdabot> forall a b t. (a -> Bool) -> (a -> b) -> (t -> [b] -> b) -> (a -> t) -> (a -> [a]) -> a -> b
15:29:06 <BeginnerAtHaskel> Cale: ok
15:29:19 <Cale> BeginnerAtHaskel: I'm just trying to understand it myself first ;)
15:29:20 <BeginnerAtHaskel> :t let extendedRecursionEngine termCond termFn reduceFn mapFn wayAheadFn x = recursiveFn x where recursiveFn y | termCond y = termFn y | otherwise = reduceFn (mapFn y) (map recursiveFn (wayAheadFn y)) in extendedRecursionEngine
15:29:21 <lambdabot> forall a b t. (a -> Bool) -> (a -> b) -> (t -> [b] -> b) -> (a -> t) -> (a -> [a]) -> a -> b
15:29:31 <Cale> It's a bit ridiculous to start out that way.
15:29:45 <djahandarie> Cale, it's like a hylomorphism with a natural transformation
15:29:51 <monochrom> "a bit" is a gross understatement
15:30:02 <djahandarie> Cale, the a -> Bool being some hacked up form of Maybe
15:30:30 <Cale> Usually I'd strive to use a composite of a bunch of smaller, more general higher order functions, rather than starting out with a contraption like that.
15:31:27 <monochrom> it was called "mapReduce" a few weeks ago. probably someone was delusional about "map reduce".
15:31:31 <djahandarie> dolio made a version of it
15:31:51 <djahandarie> I remember it had (map f *** k . head) in it
15:31:59 <endojelly> man. combining states and continuations...
15:32:01 <monochrom> hahaha
15:32:07 <Cale> Let's refactor it into a tree producer, a map, and a fold over that tree.
15:33:02 <monochrom> http://www.google.ca/search?q=site%3Ahpaste.org+mapReduce  enjoy!
15:33:04 <BeginnerAtHaskel> ok
15:33:30 <Cale> BeginnerAtHaskel: It looks like you already have a Tree type, how is it defined?
15:33:44 <Cale> (Just want to know if it's the right one to be useful here)
15:34:08 <Cale> Oh, it's the one from Data.Tree, it seems
15:34:18 <Cale> That'll be fine :)
15:34:56 <BeginnerAtHaskel> Cale:  data Tree  a = EmptyTree | Node a  [Tree a]  deriving (Show, Read, Eq)	
15:35:11 <Cale> okay, close enough :)
15:36:18 <stroan_> are there any particularly good resource on template haskell?
15:36:57 <dolio> \f g p k h -> uncurry (flip $ foldr h) . (map f *** k . head) . break p . iterate g
15:37:07 <luc_t> Q with bytestring. trying to convert String to ByteString, using pack.  but ghc complaints:  about matching Char and GHC.Word.Word8 ???
15:37:12 <BeginnerAtHaskel> its a tree that can have more than 2 children at any depth, so not binary 
15:37:27 <kmc> stroan_, not that i've found :/  you will spend n+1 hours pouring over the API docs and typing things in ghci
15:37:29 <BeginnerAtHaskel> or leaves
15:37:39 <kmc> stroan_, the original TH paper is good, but GHCi is not faithful in implementation
15:37:42 <kmc> mostly it's missing useful things :/
15:37:52 * dolio disappears.
15:38:57 <stroan_> Yeah, I'm reading the paper now
15:39:00 <pumpkin> quick, catch him before he disappears
15:39:06 <stroan_> I'm trying to figure out how to declare datatypes
15:39:23 <kmc> stroan_, to quote a decl?
15:39:28 <stroan_> explanations of the nitty and of the gritty are both lacking
15:39:28 <kmc> or to generate one with AST combinators?
15:39:35 <stroan_> generate one
15:40:39 <kmc> hmm
15:40:43 <monochrom> I wonder if http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/template-haskell.html is a good start. It has further links.
15:40:48 <kmc> stroan_, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/template-haskell-2.4.0.1/Language-Haskell-TH-Syntax.html
15:41:00 <kmc> stroan_, start with "data Dec = ..."
15:41:32 <kmc> and realize that most of these ctors have a lowercase version which is monadically lifted
15:42:20 <kmc> i.e. «ListE :: [Exp] -> Exp» vs «listE :: [Q Exp] -> Q Exp»
15:43:06 <stroan_> cheers. I will continue to bash at this
15:43:29 <kmc> stroan_, good luck, i've done a bit of TH so maybe i can help if you get stuck
15:43:48 <kmc> in my experience it takes about 10x as long to write TH as it does to write the same number of lines of plain Haskell
15:44:25 <luc_t> anybody with bytestring pack ?
15:44:44 <monochrom> the hope is that N lines of TH expands to 100N lines of haskell so your pain is repaid.
15:44:47 <aristid> kmc: can TH write typeclass instances?
15:44:57 <kmc> think so
15:45:08 <aristid> because that is the main chore i encounter
15:45:31 <kmc> monochrom, or it expands to N lines of boilerplate and you use it M times
15:45:34 <aristid> or at least which i encounter and perceive as such
15:45:38 <kmc> but arguably M >> N to justify the complexity
15:45:41 <aristid> given that human perception is flawed
15:47:10 <stroan_> I came across a few documents on TH, and my immediate reaction was "wow- I can do so much with this", and then I sit down to do something, and not quite so
15:47:34 <stroan_> open projects need to start giving medals to people who write good docs
15:48:07 <pumpkin> any .edu people in here willing to download a pdf for me? :) :)
15:48:29 <lispy1> pumpkin: I thought you were a .edu person
15:48:33 <monochrom> will not happen. programmers are obsessed over source code and belief that source code has complete information. the whole "open-source" hints at it. why just open the source?
15:48:43 <pumpkin> lispy1: I quit!
15:48:58 <lispy1> pumpkin: Oh wow.  I hadn't heard
15:49:09 <stroan_> good docs make me so happy...
15:49:23 <pumpkin> lispy1: that's why I brought up the galois jobs question a while back :)
15:50:17 <monochrom> I write good docs. Extreme case: http://www.vex.net/~trebla/haskell/forwardconstraint/ForwardConstraint.html  Note how program code is just 1/10 of it
15:50:49 <stroan_> excellent :) I wrote a module like that in work the other day. 90% docs.
15:51:01 <ray> monochrom: even in the pedantic sense you need source code, compiler source code, target machine specifications
15:51:04 <stroan_> it's satisfying
15:51:36 <monochrom> programmers expect other programmers to reverse-engineer specification from implementation
15:52:12 <ray> you could call that illiterate programming if you want because it's like the opposite of literate programming
15:54:03 <monochrom> it is beyond illiterate. illiterate just says they can't write natural language. but they can't write formal (using logic and math) specifications either.
15:54:50 <proq> I would call it obfuscated programming, since it is near impossible to write code and be illiterate
15:55:06 <proq> or spec-obfuscated... dunno
15:55:57 <anonym> monochrom: no illiterate dumb programmers expect other programmers to do that
15:56:14 <ray> i'm biased of course, but i wish programs read like math papers
15:56:30 <tg_> can we reserve the word illiterate for the 1/3 of the globe which actually is so?
15:56:31 <osaunders> EvanR: I spoke to a few other people and they all agreed that you were right. I was the weird one. Sorry for being a dick about it.
15:57:20 <tromp__>  monochrom: is ForwardConstraint on Hackage?
15:57:31 <monochrom> no
15:58:01 <tromp__> is it available?
15:58:15 <tromp__> ah yes, 
15:58:17 <monochrom> on that web page. look for a link called "source code"
15:59:21 <monochrom> I am on the way of developing a fandom.
15:59:38 <tromp__> how efficient is it for solving sudoku?
16:00:23 <monochrom> I don't know, haven't tried. list is ok but not the most efficient. I suspect some logict version is better.
16:02:56 <shepheb> still wondering how to do an undirected graph in Yesod' Persistent layer. 
16:08:03 * hackagebot SoccerFun 0.4.1 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.4.1 (JanRochel)
16:08:05 * hackagebot SoccerFunGL 0.4.1 - OpenGL UI for the SoccerFun framework  http://hackage.haskell.org/package/SoccerFunGL-0.4.1 (JanRochel)
16:13:29 * Botje_ giggles at the last name
16:14:07 <tg_> fungal?
16:17:33 <roconnor> anyone use Manatee?
16:18:16 <pumpkin> I'm sure manateelazycat does
16:23:15 <stroan_> kmc: got TH making data types. wasn't too bad, once I got my head around it. http://hpaste.org/41363/th_data_declaration
16:28:47 <mm_freak> to unregister all packages it suffices to delete ~/.ghc, right?
16:29:15 <aavogt> did you forget globally installed packages?
16:29:39 <mm_freak> all user-installed packages i mean
16:30:05 <mm_freak> i did "cabal upgrade yesod", which screwed up quite a few things
16:30:19 <aavogt> that's worked for me in the past
16:30:29 <aavogt> the rm -r ~/.ghc
16:30:31 <mm_freak> yes, but i get duplicate symbol errors
16:30:36 <mm_freak> ah, ok
16:30:38 <mm_freak> thank you
16:33:06 <luc_t> help !! I cannot convert a constant in bytestring. ghc keep on complaning about word8 vs cChar. how do I encode a constant in the cide ?
16:33:30 <luc_t> code`
16:34:28 <aavogt> luc_t: is the encoding of non-ascii characters important?
16:34:57 <luc_t> aavogt no, just plain englich
16:35:12 <aavogt> @hoogle Word8 -> Char
16:35:13 <lambdabot> Data.ByteString.Internal w2c :: Word8 -> Char
16:35:13 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:35:13 <lambdabot> Prelude show :: Show a => a -> String
16:35:52 <luc_t> ok will try . what was wrong with pack ?
16:36:12 <djahandarie> luc_t, have you seen Data.ByteString.Char8?
16:36:30 <djahandarie> I didn't fully understand your question by it may help.
16:36:32 <djahandarie> but*
16:36:45 <luc_t> wait: @hoogle Char -> Word8
16:36:59 <luc_t> @hoogle Char -> Word8
16:36:59 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
16:36:59 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:36:59 <lambdabot> Prelude error :: [Char] -> a
16:37:17 <djahandarie> Ignore the second two. :P
16:37:26 <luc_t> @hoogle String ->ByteString
16:37:27 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:37:27 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
16:37:27 <lambdabot> Prelude read :: Read a => String -> a
16:37:42 <aavogt> using that other bytestring module instead expects Char where Word8 is normally
16:38:16 <luc_t> I tried pack "--" but ghc complaint about "--" being char
16:38:21 <djahandarie> luc_t, hoogle is also online at http://www.haskell.org/hoogle/, by the way
16:38:25 <djahandarie> luc_t, you are importing the wrong module.
16:38:35 <djahandarie> @hoogle pack
16:38:35 <lambdabot> Data.ByteString pack :: [Word8] -> ByteString
16:38:35 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
16:38:35 <lambdabot> Data.ByteString.Lazy pack :: [Word8] -> ByteString
16:38:42 <djahandarie> Notice how there are different versions
16:38:49 <djahandarie> You want the Char8 version if you are packing a String
16:39:23 <aavogt> @hackage utf8-string if it should have had that encoding
16:39:23 <lambdabot> http://hackage.haskell.org/package/utf8-string if it should have had that encoding
16:39:53 <luc_t> well using Text.CSV.ByteString
16:41:14 <gds> Is Data.ByteString.Char8.pack any different from pack $ map c2w ?
16:41:15 * hackagebot contstuff 0.5.1 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.5.1 (ErtugrulSoeylemez)
16:41:47 * gds is just randomly curious.
16:43:00 <gds> (where perhaps I actually meant ((Data.ByteString.Char8.pack) == (Data.ByteString.pack $ map c2w)) ?  )
16:45:04 <aavogt> gds: efficiency maybe, considering the style here http://hackage.haskell.org/packages/archive/bytestring/latest/doc/html/src/Data-ByteString-Char8.html#pack
16:45:22 <aavogt> you'd expect them to be the same otherwise
16:45:56 <gds> Ah, cool :)
16:55:26 <luc_t> aavogt thx, it worked ( after some prelude hiding )
16:56:40 <aavogt> imports hiding things are a bit more fragile than qualified imports, not that it matters with the Prelude
16:56:57 <dobblego> @hoogle lookupBy
16:56:57 <lambdabot> No results found
16:57:18 <aavogt> @type find
16:57:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:57:27 <dobblego> yeah but...
16:57:43 <dobblego> fmap snd
17:00:07 <aavogt> write it in terms of foldr then?
17:01:02 <dobblego> http://paste.pocoo.org/show/289235/
17:01:10 <dobblego> feels ick
17:01:12 <pumpkin> x = (NSString ## alloc :> Nil) # initWithBytesNoCopy undefined :> length 5 :> encoding NSASCIIStringEncoding :> freeWhenDone True :> Nil
17:01:15 <pumpkin> strongly typed objc in haskell
17:01:19 <ivanm> hooray, I got my copy of Pearls of Functional Algorithm Design yesterday! \o/
17:01:44 <ivanm> ... though I found a few errors/missing assumptions in the first chapter already :(
17:02:09 <ivanm> pumpkin: :o you're co-less!
17:02:52 <pumpkin> yep
17:03:30 <pickles> (random question) why does IRC make you type a '#' before a channel name?
17:03:41 <JohnnyL> I am finding that the answer to my previous question is just base smaller neccessary functions off of foldr/l , map, filter and other such generic creatures.
17:03:48 <dobblego> > "random" == "off-topic"
17:03:48 <lambdabot>   False
17:04:20 <pickles> dobblego: is there a meta-irc channel?
17:04:23 <ivanm> pickles: *shrug* they had to differentiate channel names from normal text somehow?
17:04:35 <dobblego> pickles, #freenode perhaps
17:04:37 <ivanm> preflex: seen Axman6
17:04:37 <preflex>  Axman6 was last seen on #haskell 11 hours and 20 seconds ago, saying: * Axman6  -> sleep
17:04:38 <JohnnyL> > "random" != "off-topic"
17:04:39 <lambdabot>   Not in scope: `!='
17:04:45 <JohnnyL> > "random" \= "off-topic"
17:04:45 <dobblego> JohnnyL, http://blog.tmorris.net/haskell-beginner-exercises-with-tests/ might be fun
17:04:45 <lambdabot>   Not in scope: `\='
17:04:47 <ivanm> @type (/=)
17:04:48 <lambdabot> forall a. (Eq a) => a -> a -> Bool
17:04:52 <JohnnyL> ack
17:04:53 <JohnnyL> right
17:05:01 <JohnnyL> > "random" (/=) "off-topic"
17:05:02 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
17:05:02 <lambdabot>         against inferred type ...
17:05:06 <JohnnyL> lol
17:05:12 <daedra>  > fromIntegral (length [1,2,3,4]) + 3.2
17:05:23 <daedra> hmm..
17:05:28 <nkpart> pumpkin: your cocoa calls in haskell interest me greatly. where can I learn more?
17:05:35 <daedra> fromIntegral (length [1,2,3,4]) + 3.2
17:05:35 <JohnnyL> daedra: thats what she said!
17:05:54 <pumpkin> nkpart: I'm experimenting with various ideas for representing objc in haskell right now :) I'll post some more soon
17:05:54 <dobblego> daedra, the first space character fails to trigger
17:05:57 <daedra> how do I get lambdabot to evaluate some stuff?
17:06:05 <pumpkin> nkpart: trying to see how painful common things would be with this arrangement
17:06:38 <pumpkin> this representation doesn't care about overlapping selectors
17:06:38 <ivanm> pumpkin: as in the C-based language that Apple loves?
17:06:40 <pumpkin> unlike the other one
17:06:40 <daedra> > fromIntegral (length [1,2,3,4]) + 3.2
17:06:41 <lambdabot>   7.2
17:06:43 <daedra> aha
17:06:43 <aavogt> dobblego: a better question is why isFooError is separate from fooError
17:06:47 <pumpkin> ivanm: yeah, we need to write bindings to it
17:06:54 <pumpkin> but the paradigm is so different that it's hard to interface with it
17:06:55 <daedra> GHCI fails to evaluate fromIntegral (length [1,2,3,4]) + 3.2
17:07:03 <pumpkin> as in, I'd like bindings to common apple libraries
17:07:08 <ivanm> pumpkin: are you using the old bindings someone started a while back or starting from scratch?
17:07:13 <pumpkin> from scratch
17:07:16 <pumpkin> playing with ideas
17:07:18 <ivanm> daedra: I think it's trying to do the + first
17:07:18 <dobblego> aavogt, the assoc-list puts them together
17:07:22 <pumpkin> cause the hoc stuff wasn't very pretty
17:07:28 <ivanm> pumpkin: *nod*
17:07:35 <ivanm> pumpkin: how are you doing it? FFI via C?
17:07:39 <pickles> (random - related to topic) how about an EDSL in Haskell that outputs assembly lang code for the higher level code of the EDSL, thereby by-passing any sort of lexing/parsing step of a compiler?
17:07:43 <nkpart> hopefully it's not like that out of necessity
17:07:51 <pumpkin> ivanm: I'm ignoring the FFI aspect of it for now, as that part is fairly straightforward
17:07:53 <ivanm> pickles: we have something like that already
17:07:57 <ivanm> can't recall the name though...
17:07:58 <pickles> orly...
17:08:01 <pumpkin> I mostly just want to make a nice higher-level interface that's strongly typed
17:08:08 <ivanm> pumpkin: *nod*
17:08:09 <daedra> this is the error GHCI spews http://haskell.pastebin.com/VWsjQZ6D
17:08:27 <ivanm> how straight-foward is it though? I mean, isn't that why hoc died (being a PITA to get the bindings done)?
17:08:30 <daedra> when I load a .hs file containing fromIntegral (length [1,2,3,4]) + 3.2
17:08:48 <dobblego> daedra, x = fromIntegral (length [1,2,3,4]) + 3.2 -- put this in the file
17:09:11 <daedra> oh
17:09:38 <daedra> I must assign it
17:09:50 <nkpart> I'd settle for a Language.ObjC package atm
17:10:44 <pumpkin> nkpart: that's mostly about writing a parser
17:10:46 <pickles> ivanm: if you recall the name, would you kindly let me know? I would like to look at it
17:10:58 <pumpkin> you could probably take the language.c package and modify its parser
17:11:02 <ivanm> wow, why is ghc thinking daedra is using TH? because it's a statement and not a binding?
17:11:06 <pumpkin> since objc is a strict superset of objc
17:11:22 <pumpkin> ivan: as of ghc 6.12, top-level expressions are considered TH splices
17:11:27 <pumpkin> I quite like it
17:11:34 <ivanm> pumpkin: ahhhh
17:11:38 <ivanm> even without enabling the extension?
17:11:41 <aavogt> but that's a bug to be enabled then
17:11:50 <ivanm> isn't that kinda bad (implicit extension enabling)?
17:12:08 <aavogt> clearly a strategy to make the new feature known
17:12:13 <JohnnyL> there are user defined infix levels in 2010, correct?
17:12:24 <aavogt> yes
17:12:34 <JohnnyL> kool
17:12:46 <pumpkin> ivanm: dunno :)
17:12:48 <pumpkin> I guess so
17:13:11 <daedra> so "An instance declaration" means   x = ...
17:13:30 <daedra> ?
17:13:36 <aavogt> > let (+) = (Prelude.+); (*) = (Prelude.*); infixl 1 *; infixl 2 + in 1 + 2 * 3
17:13:37 <lambdabot>   9
17:14:10 <LegendaryPenguin> why does fix (1:) give a list back
17:14:17 <dobblego> @type fix
17:14:18 <lambdabot> forall a. (a -> a) -> a
17:14:23 <aavogt> substitute the definition of fix
17:14:24 <dobblego> @type (1:)
17:14:25 <lambdabot> forall t. (Num t) => [t] -> [t]
17:14:58 <aavogt> LegendaryPenguin: pencil and paper can help
17:15:18 <LegendaryPenguin> 1:(1:) isnt a list tho
17:15:30 <aavogt> it keeps going
17:15:37 <LegendaryPenguin> doesnt it have to end with []
17:15:39 <ivanm> @src fix
17:15:40 <lambdabot> fix f = let x = f x in x
17:15:44 <ivanm> LegendaryPenguin: no, lists can be infinite
17:15:49 <aavogt> you get    1:fix (1:) ...
17:15:50 <ivanm> > repeat 1
17:15:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:15:52 <ivanm> > [1..]
17:15:53 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:15:54 <monochrom> LegendaryPenguin: http://www.vex.net/~trebla/haskell/fix.xhtml
17:16:07 <daedra> I got a bit worried then.. 
17:16:16 <daedra> since GHCI really does repeat 1
17:17:21 <LegendaryPenguin> its still weird.. like why zeroes = 0 : zeroes gives a list back
17:18:13 <ivanm> LegendaryPenguin: why shouldn't it?
17:18:13 <jaredj> hoogle dead? :(
17:18:25 <LegendaryPenguin> how does it know its a list 
17:18:25 <jaredj> 500 internal server error
17:18:25 <ivanm> @hoogle fix
17:18:25 <lambdabot> Data.Function fix :: (a -> a) -> a
17:18:25 <lambdabot> Control.Monad.Fix fix :: (a -> a) -> a
17:18:26 <lambdabot> module Control.Monad.Fix
17:18:34 <ivanm> wow, didn't realise @hoogle used the website...
17:18:37 <gds> @type (:)
17:18:40 <lambdabot> forall a. a -> [a] -> [a]
17:18:44 <ivanm> jaredj: use hayoo then
17:18:46 <ivanm> @where hayoo
17:18:47 <dobblego> LegendaryPenguin, 1:(1:) will not type-check
17:18:49 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
17:19:13 <gds> LegendaryPenguin: it's the : that makes the list.
17:19:17 <jaredj> http://www.hiyoooo.com/
17:19:26 <jaredj> thx 
17:19:51 <jaredj> instant search ftw
17:19:52 <ivanm> jaredj: no, hayoo, not hiyoooo ;)
17:19:54 <LegendaryPenguin> how does it know the second parts a valid list
17:20:16 <ivanm> LegendaryPenguin: OK, let's type check out "zeroes = 0 : zeroes" by hand
17:20:29 <ivanm> let us refer to the type of zeroes as `a'
17:20:53 <ivanm> we thus have that: a == typeOf "0 : zeroes"
17:21:00 <mm_freak> LegendaryPenguin: (:) is a function, which expects an element and a list of elements…  it's result is a list…  because 'zeroes' is the result of (:), it must be a list, so it's itself a valid second argument to (:)
17:21:09 <ivanm> the : operator has type "b -> [b] -> [b]"
17:21:23 <ivanm> the 0 has type "Num b => b"
17:21:49 <ivanm> for simplicities sake, let's just say it's Int
17:21:50 <monochrom> it is the same question for all recursions. "f n = n * f(n-1)" why does f have the right type?
17:21:54 <ivanm> and for the type-checking to work, the zeroes on the RHS must be of type [Int]
17:22:16 <ivanm> so we have that "0 : zeroes" is of type [Int]
17:22:27 <ivanm> so again, we have that zeroes (on the LHS) is of type [Int]
17:22:53 <monochrom> you also need to accept that type can be inferred without executing the code
17:23:38 <gds> I wonder if it would help to consider the case of "this = 0 : that"
17:23:41 <kmc> i'm having trouble with cabal-install on Ubuntu Karmic, after following these instructions for Haskell Platform: http://davidsiegel.org/haskell-platform-in-karmic-koala/
17:23:49 <kmc> my problem is here: http://hpaste.org/41366/cabal_on_ubuntu_karmic
17:24:06 <kmc> i'm the maintainer for crystalfontz; does this mean my package is broken? i'm confused about why base-4.2.0.0 is being excluded
17:24:07 <LegendaryPenguin> so it just assumes it ends with a []?
17:24:10 <gds> If we know the type of 0 and (:), there's only one type that'll work for either "this" or "that".
17:24:20 <LegendaryPenguin> so that it compiles
17:24:23 <mm_freak> LegendaryPenguin: no, it doesn't have to assume that
17:24:25 <monochrom> [] is not assumed.
17:24:37 <mm_freak> infinite lists are perfectly fine
17:24:43 <monochrom> for the second time, types can be inferred without executing the code.
17:24:53 <aavogt> kmc: can't you relax the dependency on array?
17:25:17 <ivanm> kmc: is that with cabal-install?
17:25:20 <mm_freak> just execute it by hand:  we know that haskell is referentially transparent, and we know this:  zeroes = 0 : zeroes
17:25:22 <ivanm> oh, right, it is
17:25:25 <aavogt> cabal install cannot get you a different ghc (which seems to be the only way to get a different base)
17:25:32 <mm_freak> this means that you can replace any occurence of 'zeroes' by '0 : zeroes'
17:25:33 <monochrom> compiler totally does not go "let me plug in some fake values to discover types".
17:25:33 <kmc> aavogt, cabal-install has no dep on array.  maybe one of its deps does
17:25:39 <ivanm> kmc: if the package just says "base", then I believe cabal-install still defaults to base < 4
17:25:44 <kmc> ah, crc16-table (also by me) does
17:25:48 <kmc> all my packages are base >= 3 && < 5
17:25:55 <aavogt> kmc: your crystalfontz, not cabal-install
17:26:03 <mm_freak> zeroes = 0 : zeroes = 0 : (0 : zeroes) = 0 : (0 : (0 : zeroes)) = …
17:26:07 <kmc> aavogt, what do you mean?
17:26:17 <aavogt> kmc | aavogt, cabal-install has no dep on array.  maybe one of its deps does
17:26:36 <kmc> oh wtf this is old haskell-platform
17:26:39 <aavogt> you already have cabal-install installed, and it's working, so it's deps can be ignored
17:26:55 <kmc> aavogt, sorry, that was a typo.  i meant crystalfontz has no dep on array
17:27:18 <kmc> anyway i thought i had installed the ghc 6.12.1 version of hp but apparently not
17:27:22 <kmc> so i will work on fixing that...
17:27:48 <ivanm> kmc: might as well get the 6.12.3 version then
17:28:15 * ivanm just compiles & installs new versions of ghc and then uses cabal-install when using uni machines
17:29:59 <monochrom> David Siegel's instructions are redundant. haddock, happy, alex are not needed a priori. checkinstall is not needed.
17:30:45 <kmc> checkinstall is nicer than sudo make install, on debian, right?
17:30:48 <monochrom> shameless plug: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml is better
17:30:49 <kmc> it will make an actual package
17:31:22 <kmc> i will follow those instructions monochrom
17:32:01 <aavogt> monochrom: editline shouldn't be needed with ghc-6.12, should it?
17:32:42 <ivanm> nope
17:32:51 <ivanm> shouldn't be needed as of 6.10.4 IIRC
17:33:07 <ivanm> monochrom: who is David Siegel?
17:33:33 <aavogt> siegel has a blog
17:33:34 <monochrom> I don't know.
17:34:06 <ivanm> then why are you saying his instructions are redundant?
17:34:06 <monochrom> I will find out who needs editline and update my page.
17:34:38 <kmc> "You may buy a computer with GHC pre-installed…"  :D
17:34:43 <monochrom> I don't know "Joel" but I will still recommend his unicode advice.
17:35:04 <kmc> i ate hors d'œuvres at joel's office once
17:35:20 <monochrom> I don't know "ESR" but I will still criticize his bazaar article
17:35:22 <kmc> haha
17:35:32 <stepcut> I had dinner with ESR once
17:35:41 <kmc> i don't know Paul Graham but i will still agree with him on some things, yet consider him largely a self-important blowhard
17:35:57 * kmc walks off to #haskell-blah
17:35:58 <ivanm> monochrom: well, I kind of meant "why are you mentioning him"
17:36:12 <ray> every paul graham essay contains an ad-hoc, informally specified implementation of a good idea
17:36:17 <stepcut> ray:  :)
17:36:18 <monochrom> because a url of his instruction appeared
17:36:26 <kmc> @remember ray every paul graham essay contains an ad-hoc, informally specified implementation of a good idea
17:36:26 <lambdabot> Good to know.
17:36:55 <ivanm> lol
17:38:39 <aavogt> hmm, there should be a way to tell cabal that "doesn't work with ghc < x", rather than just this   tested-with  field
17:40:12 <ivanm> aavogt: version specification?
17:40:32 <aavogt> ivanm: is there such a thing?
17:40:46 <ivanm> well, you can specify which versions of base it works with...
17:41:06 <ivanm> and there's some way you can state what to do with different versions of ghc
17:41:09 * aavogt doesn't mean depending on the ghc package
17:41:46 <ivanm> neither do I
17:41:53 <ivanm> there was a discussion about this on -cafe recently IIRC
17:42:03 <pumpkin> there's impl
17:42:05 <aavogt> ivanm: I mean how there's a   tested-with field, but no   tested-but-failed-with
17:42:20 <ivanm> pumpkin: that's what I meant
17:42:48 <ivanm> aavogt: my guess, is that if it is known to fail with that version of GHC then you shouldn't let it _build_ on that version of GHC ;)
17:43:28 <monochrom> haskell platform 2009.2.0.2 has editline binding, this is why editline-dev is needed
17:43:49 <ivanm> but nothing since
17:43:52 <aavogt> the idea is to fail more helpfully
17:44:24 <monochrom> haskell platform 2010.* drops editline
17:44:42 <ivanm> aavogt: rather than writing in the .cabal file "I know it fails on this version of ghc", why don't you specify the dependency versioning such that it won't even _try_ to build on that version?
17:44:51 <ivanm> monochrom: and there was much rejoicing!
17:45:15 <aavogt> ivanm: how would you do that in kmc's case?
17:46:19 <monochrom> depending on base version is kind of wrong or unreadable if the real dependency is on ghc version because "I need the new overlapping-instance algorithm"
17:47:27 <ivanm> monochrom: true
17:47:45 <ivanm> can the impl stuff be used to specify which version of ghc is needed, or just different deps based on version?
17:47:49 <ivanm> preflex: seen dcoutts
17:47:50 <preflex>  dcoutts was last seen on #ghc 8 days, 4 hours, 35 minutes and 53 seconds ago, saying: and it's now moderately mature
17:47:55 <ivanm> preflex: seen dcoutts_
17:47:55 <preflex>  dcoutts_ was last seen on #ghc 1 day, 6 hours, 31 minutes and 14 seconds ago, saying: the ghc rts header files have the details
17:48:11 <monochrom> I suppose impl is right for "I really want ghc 7"
17:48:20 <ivanm> wait, duh, he'll probably be asleep now
17:48:35 <ivanm> monochrom: I'm not sure if impl lets you say "this _needs_ ghc 7"
17:49:01 <monochrom> if impl(not ghc 7) abort
17:49:14 <ivanm> oh, didn't know about abort
17:49:21 <monochrom> no, I made up "abort"
17:49:27 <ivanm> heh
17:49:40 <ivanm> though that sounds a little hacky (even if it existed) because there's no way of saying up-front that it needs ghc-7
17:50:21 <mm_freak> for the first time template haskell has really bitten me
17:50:38 <kmc> omnom
17:50:55 <mm_freak> if you ever get very weird missing instance errors when using yesod, remember to put the mkYesod /before/ the Yesod instance
17:51:04 <ivanm> kmc: stop biting and eating mm_freak!
17:51:45 <shepheb> mm_freak: I've got a Persistent question if you're willing. need to represent an undirected graph in a sane way.
17:52:27 <ivanm> shepheb: use an FGL graph and just duplicate each edge? :p
17:52:44 * ivanm goes back to trying to work out how to define and manipulate planar graphs
17:53:15 <shepheb> ivanm: not really the kind of problem I'm trying to solve. more of a wiki like system of links between pages.
17:53:34 * shepheb looks for an example of a wiki in yesod...
17:53:51 <ivanm> well, just saying "how to represent an undirected graph" doesn't specify any constraints you might have on it ;-)
17:53:58 <mm_freak> shepheb: well, i think you need at least two tables for that
17:54:01 <ivanm> s/how/need/
17:54:30 <jaredj> i have a 2d array of enums. i want to find out how many matches there are between adjacent elements. Data.Foldable doesn't give me an idea of "here", and the Comonad instance doesn't appear to let me fold the array up. suggestions?
17:54:33 <mm_freak> shepheb: but i'm not sure how to represent compound keys in persist
17:55:28 <mm_freak> shepheb: if you're lucky, persist supports lists:  [$persist| Node\n  nodePaths [NodeId] |]
17:55:38 <jaredj> (it's actually a representation of a quilt. and if it were general enough i bet it would be an undirected planar graph...)
17:55:56 <ivanm> jaredj: what data structure are you using? Data.Array ?
17:55:58 <shepheb> if I were using straight SQL, I'd have a Node table and Link table with node_from and node_to columns, and create one row in each direction for each link. but that's a very relational way to do it.
17:55:59 <jaredj> yes
17:56:12 <ivanm> how are you defining the concept of a "match"? == ?
17:56:26 <mm_freak> shepheb: persist is not really non-relational
17:56:48 <ivanm> jaredj: shift the array left and do a comparison, then do the same with a shift right, up and down
17:56:55 <jaredj> ivanm: for each of (above, below, left, right), try to go one in that direction; compare with here
17:57:01 <jaredj> ....
17:57:13 <mm_freak> shepheb: it gives you type safety, automatic migration, an SQL wrapper and other stuff, but you still have a relational representation, AFAI see
17:57:24 <ivanm> right, from memory Data.Array has a function to map over the indices
17:57:32 <ivanm> then get the elements (even as a list)
17:58:06 <jaredj> yees
17:58:10 <ivanm> i.e. shift it with: \ (x,y) -> ((x-1) `mod` maxX, y)
17:58:22 <jaredj> so forget "here"
17:58:38 <ivanm> yeah
17:58:43 <ivanm> just do relative comparisons
17:58:47 <jaredj> okok
17:59:08 <shepheb> mm_freak: hm. well, the main use case is displaying a page (node) it needs to include a list of every node it's linked to, including the titles of those nodes.
17:59:12 <ivanm> then get the elems, and do something like length . filter match . zip
17:59:24 <shepheb> which is classic INNER JOIN territory
17:59:40 <jaredj> cool. i was trying to learn about comonads. but then i figured out they may not quite fit
17:59:57 <kfish> they cofit
18:00:05 <jaredj> ahh. i counderstand
18:00:14 <ivanm> kfish: heh
18:00:23 <monochrom> I cocur
18:00:33 <jaredj> pfttchch
18:00:38 * ivanm wishes people would get over the cojoke
18:00:54 * geheimdienst wishes for a coke
18:01:01 <monochrom> tell coca cola to get over coca cola first
18:01:02 <jaredj> aw. but it's co-new
18:04:14 <shepheb> I guess I'm going to end up creating Node and Link entities and doing the join in Haskell. unfortunate, because now I've got N+1 queries instead of just 1 expensive one
18:05:10 * ivanm contemplates being naughty and using ! instead of Map.lookup for functions that the user should never be able to see
18:05:14 <shepheb> well, that or cache the titles... then the update becomes the expensive one. that's probably premature optimization though
18:06:16 <mm_freak> shepheb: persist doesn't support joins, from what i've read in the docs last time
18:06:31 <shepheb> hence why I need to implement it in Haskell
18:06:33 <mm_freak> the author claims that joins generally reduce performance
18:07:06 <shepheb> I fear this case of a many-many relationship is one of the exceptions to that "generally"
18:07:41 <mm_freak> dunno…  i haven't benchmarked it
18:07:49 <mm_freak> but honestly i wouldn't care too much
18:08:03 <mm_freak> theoretically you would execute all those queries in a single runSql*
18:08:16 <shepheb> even for a modest value like n=10, I suspect an INNER JOIN to be faster than n+1 separate queries.
18:08:19 <mm_freak> so the implementation might decide to use a JOIN instead of individual queries
18:08:27 <shepheb> hmm, that's true. that might make it perfectly fine.
18:08:44 <shepheb> I need to learn more about Persistent, it seems
18:09:15 <mm_freak> well, just remember that runSql* represents a transaction (and is indeed implemented as an SQL transaction)
18:09:45 <mm_freak> i don't think that JOIN would give you higher performance here
18:09:54 <mm_freak> there are other corners, where you can care for performance
18:12:00 <mm_freak> note also that a JOIN generally returns a lot of redundant data
18:12:04 <shepheb> I don't care about making it as fast as possible, n is unlikely to exceed 50. the caching option would solve the problem (and replace it with a cache expiration problem when the page titles change, but so be it)
18:12:31 <pathickey> Hi - I'm having an issue with Text.JSON but I think the issue is that I cant reason about why an operator works different ways in different parts of a function.
18:13:04 <shepheb> SELECT nodeId, name FROM Link INNER JOIN Node ON Link.node_to = Node.nodeId WHERE node_from = 17; doesn't return anything redundant.
18:13:18 <pathickey> I defined (!) = flip varFromObj as shorthand, and it works in one part of my code but not another.
18:13:24 <pathickey> code here: http://hpaste.org/41367/valfromobj_issue
18:13:45 <shepheb> mm_freak: anyway, I'll implement it and then see if it's fast enough.
18:14:00 <mm_freak> shepheb: you could run a benchmark
18:14:23 <mm_freak> shepheb: in any case, even if you experience a performance loss, it'll be just a constant factor
18:14:33 <mm_freak> asymptotically it will still behave like a JOIN
18:14:55 <mm_freak> just make sure that you do everything inside of a single runSql*
18:15:25 <mm_freak> then that factor won't be very large, if not even smaller than 1 in some cases
18:15:40 <ivanm> pathickey: what's jv?
18:15:50 <aavogt> pathickey: define (!) as      a ! b = valFromObj b a
18:15:54 <shepheb> mm_freak: I suppose so
18:16:07 <aavogt> you're running into the monomorphism restriction it seems
18:16:19 <pathickey> jv is a JSObject JSValue from Text.JSON
18:16:37 <ivanm> the error doesn't seem to be about the usage of ! per-se...
18:16:43 <ivanm> maybe a fixity problem?
18:17:02 <ivanm> maybe try giving (!) an explicit type signature as well
18:17:26 <pathickey> aavogt's solution type-checked.
18:17:45 <aavogt> well you don't need both a signature, and explicitly named arguments
18:18:04 <aavogt> there's also  -XNoMonomorphismRestriction, if it continues to annoy
18:18:10 <ivanm> aavogt: aaahhh, the dreaded MMR
18:18:12 <ivanm> always forget that one
18:18:23 <ivanm> (probably because I tend to write type-sigs before I write implementations)
18:18:29 <pathickey> How is that related to the definition of flip, then?
18:18:41 <kmc> "monomorphism restriction": About 2,540 results
18:18:45 <monochrom> static linking using ld is indeed getting expensive
18:18:47 <kmc> "dreaded monomorphism restriction": About 1,410 results
18:19:06 <Eduard_Munteanu> Heh.
18:19:11 <ivanm> pathickey: it isn't
18:19:12 <kmc> "wonderful monomorphism restriction": No results found
18:19:19 <ivanm> kmc: lol
18:19:20 <Eduard_Munteanu> :))
18:19:30 <ivanm> monochrom: I've heard things about the gold linker...
18:19:32 <monochrom> yikes, it's taking 300M and more to just link cabal-install! on ubuntu maverick
18:19:34 <aavogt> pathickey: it's because the (!) looks like a constant, so the type isn't generalized
18:19:36 <ivanm> if by "expensive" you mean time
18:19:41 <ivanm> oh, size
18:19:55 * hackagebot manatee 0.0.2 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.2 (AndyStewart)
18:20:17 <pathickey> ok. I guess that sort of intended behavior is useful other times?
18:20:24 <aavogt> the definition   (!) a = flip valFromObj a -- gets around that
18:20:26 <monochrom> ok it finishes. I was scared. I feared it felt into an infinite loop due to new ubuntu maverick software
18:20:52 <pathickey> ok, i see what you mean
18:21:07 <monochrom> but also note that it takes a while to use 300M at all. moreover I did it in a virtual machine with just 512M memory so it thrashed.
18:21:11 <aavogt> it's useful for making performance more predictable
18:21:42 <ivanm> pathickey: there is some corner case for which it is apparently useful
18:22:00 <monochrom> yes, normally I do it in native linux having 3G and not caring mere 300M :)
18:22:13 <aavogt> ivanm: it's not as mysterious as you suggest :)
18:22:30 <ivanm> monochrom: what does the usage of mobile internet have to do with memory usage? :p
18:22:52 <ivanm> aavogt: I said it was mysterious?
18:23:05 <aavogt> some corner case
18:24:07 <ivanm> I just meant that I couldn't remember what it was, but the general consensus nowadays (with the "let's remove the MMR" proposals for Haskell') is that it doesn't pop up that much IIRC
18:24:48 <kmc> the corner case is that typeclass polymorphic values might be implemented as functions (from class dictionaries)
18:25:01 <kmc> > let x = 2+2 in (x :: Int, x :: Double)
18:25:02 <lambdabot>   (4,4.0)
18:25:20 <aavogt> that it trips people up, or that it makes values that look like constants get recomputed?
18:25:39 <kmc> syntactically, you expect sharing of x, but actually it computes twice: once with (+) :: Int -> Int -> Int and once with (+) :: Double -> Double -> Double
18:26:02 <kmc> aavogt, if i understand your question, the latter: that's why MMR only applies to things which are *syntactically* a pattern bind and not a function bind
18:26:54 <aavogt> kmc: the question is whether ivanm recalls the good half or the bad half not popping up often
18:27:05 <kmc> so it's sort of a small concession to making performance reasoning easier for beginners
18:27:16 <ivanm> the reason for MMR not popping up often
18:27:20 <kmc> but i think performance reasoning is so hard anyway that the language ugliness is not justified
18:27:45 <kmc> an experienced haskeller would suspect polymorphism, add a monomorphic type sig, and watch it fail
18:27:58 <Eduard_Munteanu> I still don't understand how the MR stuff works, given a type sig fixes performance issues.
18:28:07 <kmc> Eduard_Munteanu, what do you mean?
18:28:07 <Eduard_Munteanu> I mean, is it so difficult the compiler can't infer it?
18:28:43 <Eduard_Munteanu> kmc: in at least some cases a type signature solves the performance issue.
18:28:45 <aavogt> there are other constructs where that's the case
18:28:56 <ivanm> @type unfoldr
18:28:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
18:28:58 <kmc> MMR isn't about the compiler not being able to infer something; it's about deliberately inferring something less general because you think the programmer meant that
18:29:04 <aavogt> -XRank2Types comes to mind
18:29:09 <kmc> it's an ugly perlish sort of "do what i mean", which is not how Haskell's generally designed
18:29:21 <jmcarthur> the reason for the MR is because some people felt that it would be confusing if the same term represented different data when used as different types
18:29:24 <Eduard_Munteanu> aavogt: well those can't be inferred really.
18:29:25 <kmc> Eduard_Munteanu, cases where a type sig fixes a performance issue are unrelated to MR
18:29:49 <kmc> that's typically a polymorphic function that's only used at one type, where specialization enables lots of inlining
18:29:56 <kmc> if that's the case then MR *didn't* fire
18:30:40 <Eduard_Munteanu> Hm. Why did I think there was a connection? I've seen people talking about MR when a similar problem showed up...
18:30:46 <kmc> you typically wouldn't write that as a pattern bind, anyway
18:30:55 <kmc> if your decl looks like "f x = ..." then MR will not come into play
18:31:02 <kmc> only if it looks like "p = ..." where p a pattern
18:31:35 <Eduard_Munteanu> Oh, I see.
18:31:46 <kmc> because you'd expect the latter to share, but not the former
18:31:57 <kmc> (uninformed rumors about "automatic memoization" notwithstanding)
18:32:13 <aavogt> ivanm: well how do you really know when the MR is applied such that it helps?
18:32:24 <pathickey> is any function written point free going to have this issue?
18:32:26 <ivanm> ... good point
18:32:42 <kmc> pathickey, yes but there's a number of solutions
18:32:48 <kmc> you can just put a type signature on
18:32:54 <aavogt> you'd have to -XNoMR, and hope to notice performance issues
18:32:58 <kmc> that's probably good form anyway
18:33:07 <kmc> maybe -Wall warns about MR?
18:33:16 <kmc> it warns about missing sigs at top level
18:33:23 <pumpkin> > foldr f z [a, b, c]
18:33:24 <lambdabot>   f a (f b (f c z))
18:33:32 <pumpkin> > foldl f z [a, b, c]
18:33:33 <lambdabot>   f (f (f z a) b) c
18:33:35 <kmc> btw you can write a polymorphic function and then tell GHC to generate specializations for it
18:33:45 <kmc> with {-# SPECIALIZE #-} and more recently with {-# RULES #-}
18:33:46 <aavogt> there's -fwarn-monomorphism-restriction at least
18:34:24 <kmc> specialization can be a Big Win for numeric code
18:34:41 <kmc> inline typeclass dictionary ⇒ strictness analyze ⇒ unbox
18:35:07 <Eduard_Munteanu> Would that basically do the same thing as "remove all type inference except for trivial stuff"? By trivial stuff I mean things that are easily decideable, and should cover most of what's inside functions.
18:35:11 <kmc> you get a tight loop of machine-level arithmetic instructions, where before you had a morass of indirect jumps
18:35:18 <kmc> Eduard_Munteanu, would what?
18:35:28 <manateeUser> hello
18:35:28 <manateeUser> /quit
18:35:38 <Eduard_Munteanu> kmc: well not remove, warn "hey, I had to infer this, maybe it isn't what you expect"
18:35:45 <manateeUser> hi
18:36:05 <Eduard_Munteanu> I was asking about any flag like -fwarn-...
18:36:34 <kmc> Eduard_Munteanu, so you want more general inference warnings?
18:36:34 <Eduard_Munteanu> I'd pretty much want to annotate everything that could be ambiguous, moreso for top level functions.
18:37:04 <Eduard_Munteanu> kmc: yeah, and ^
18:37:07 <kmc> what do you mean by "ambiguous"?  typeclass ambiguity like (show.read) is an error
18:37:25 <kmc> unless defaulted, and -fwarn-type-defaults exists and is in -Wall and is a very good idea
18:37:28 <aavogt> @type show . read
18:37:29 <lambdabot> String -> String
18:37:36 <aavogt> defaulting!
18:37:42 <kmc> > (show . read) "()"
18:37:43 <lambdabot>   "()"
18:37:44 <kmc> > (show . read) "3"
18:37:45 <lambdabot>   "*Exception: Prelude.read: no parse
18:38:22 * kmc gets pissed when GHCi defaults things to Any
18:38:42 <kmc> Any is the worst type
18:39:23 <kmc> @check \xs -> xs == reverse xs
18:39:24 <lambdabot>   "OK, passed 500 tests."
18:39:34 <stepcut> heh
18:39:58 <Eduard_Munteanu> Hm, perhaps what I asked for is too strong, like that would produce extraneous warnings when not annotating numbers.
18:40:05 <kmc> Eduard_Munteanu, so, warn on defaulting, warn on MMR
18:40:21 <aavogt> warn on type inference
18:40:28 <Eduard_Munteanu> -Wall?
18:40:30 <kmc> Eduard_Munteanu, i don't think it would... if i write f :: Int -> Int, then use (f 3), the 3 literal is fully specified
18:40:31 <Eduard_Munteanu> I sure hope so.
18:40:53 <kmc> remember that type inference propagates information forwards and backwards in time, wrt runtime control flow
18:40:56 <monochrom> warning: humanity detected
18:41:21 <kmc> how much slower is it to build everything with -dcore-lint -dcmm-lint -dstg-lint?
18:41:53 <ivanm> monochrom: damn, you mean we haven't gotten rid of them all yet?
18:42:56 <Eduard_Munteanu> kmc: I wonder, for example, if type inference does well for choosing Double vs Float.
18:43:13 <kmc> in my little test case it takes 3x as long, plus finds a bunch of errors (!)
18:43:16 <Eduard_Munteanu> kmc: like when doing an 'if' based on such a value in a function Int -> Int.
18:43:22 <monochrom> always choose Double. easy. :)
18:43:31 <kmc> Eduard_Munteanu, it won't arbitrarily choose one over the other, except for the "defaulting" mechanism
18:43:36 <Eduard_Munteanu> monochrom: yeah, I know, but maybe I forget to annotate some parts.
18:43:41 <Eduard_Munteanu> kmc: oh.
18:43:42 <kmc> and you get a warning there
18:44:05 <Eduard_Munteanu> Oh, okay, I'm feel better now.
18:44:10 <Eduard_Munteanu> *feeling
18:44:15 <pygmalion> Wrote a double parser and now trying to write a complex number parser based off it (this is all with ReadP), but having some trouble. http://pastebin.com/5uykQ0C0
18:44:22 <monochrom> what errors do you get with -dcore-lint -dcmm-lint -dstg-lint?
18:44:41 <kmc> monochrom, big ones
18:44:52 <monochrom> do you mean ghc generates wrong code?
18:44:56 <kmc> i don't know
18:45:01 <kmc> i did not yet read the warnings
18:45:04 <kmc> to know if they're a problem
18:45:10 <kmc> Eduard_Munteanu, http://hpaste.org/41368/defaulting
18:45:13 <monochrom> alright
18:45:33 <kmc> Eduard_Munteanu, it seems you conceive of type inference as a rather ad-hoc process
18:45:43 <kmc> it may reassure you to read the TaPL chapter about type inference for the simply-typed lambda calculus
18:46:02 <kmc> it is a simple, elegant, and conceptually well-founded algorithm
18:46:26 <kmc> Haskell adds significant complexity, but the core idea of the algorithm is the same
18:46:28 <Eduard_Munteanu> kmc: I see.
18:46:31 <kmc> for that, see "Typing Haskell in Haskell"
18:46:33 <Eduard_Munteanu> kmc: I know it's not arbitrary.
18:46:47 <kmc> defaulting *is* arbitrary and ugly
18:46:50 <kmc> but also gets a warning :)
18:46:58 <Eduard_Munteanu> kmc: it just has a lot of leeway in case of polymorphism, and value promotion
18:47:19 <monochrom> I read that chapter. Pretty easy and nice. The best part is it omits treating record types, which is perfect with Haskell.
18:47:20 <kmc> there's not much leeway for polymorphism, at least until you get to extensions with undecidable typing
18:47:21 <Eduard_Munteanu> Actually promoting literals is the biggest problem.
18:47:51 <Eduard_Munteanu> Because it seems to me, to the compiler '3' could be a number of things.
18:48:10 <monochrom> (I skipped the unification algorithm. I read it elsewhere in the past and implemented the slow version in haskell already. My code is always more readable than someone else's pseudocode. :) )
18:48:18 <Eduard_Munteanu> 3 is an Int, an Integer, a Float, a Double, what not.
18:48:22 <pygmalion> :r
18:48:29 <kmc> the literal 3 always stands for «fromInteger (3 :: Integer)»
18:48:31 <monochrom> reloaded
18:48:35 <kmc> which has type «(Num a) => a»
18:48:36 <pygmalion> thanks monochrom hah
18:48:49 <Eduard_Munteanu> kmc: oh!
18:48:50 <kmc> this type is unified with other stuff by the same inference algorithm as everything else
18:49:15 <Eduard_Munteanu> Thanks, that explains it.
18:49:37 <Eduard_Munteanu> I thought it was something more like in C, where if I'm not mistaken, there are promotion rules and such.
18:49:52 <Eduard_Munteanu> (hardcoded in the standard)
18:50:05 <monochrom> this is why we love haskell so much
18:52:00 <kmc> similarly, 2.5 is shorthand for «fromRational (5 % 2 :: Rational)» or such
18:52:10 <kmc> where type Rational = Ratio Integer
18:52:23 <Eduard_Munteanu> Hm, have I spotted a connection: would any value that isn't exported, and whose polymorphic type is never specialized, be removed/deforestated?
18:52:41 <kmc> possibly
18:53:32 <aavogt> this is the haskell version of whether a tree falling in a forest makes a sound if nobody hears it?
18:53:39 <kmc> if the code is small, and it gets specialized at every use site, GHC could omit generating the polymorphic version
18:53:43 <kmc> i'm not sure if it actually does
18:53:58 <kmc> a big polymorphic function may not get specialized by default
18:54:03 <kmc> i'm not sure if that's tied into whether it's inlined
18:54:17 <kmc> conceptually at least, inlining ⇒ constant folding of class dictionary ⇒ specialization
18:54:41 <Eduard_Munteanu> I see.
18:54:45 <Eduard_Munteanu> aavogt: heh, sorta.
18:54:47 <kmc> now, that covers ad-hoc (class) polymorphism.  is there ever a case where purely parametric polymorphism is slower than the specialized version?
18:55:37 <Eduard_Munteanu> kmc: the specialized version could be unboxed.
18:55:55 <aavogt> kmc: it's a trade of space for time
18:56:09 <Eduard_Munteanu> Shouldn't polymorphic types be always boxed?
18:56:24 <magicman> What is the recommended constraint on base for .cabal packages these days?
18:56:31 <kmc> yes, types instantiating type variables must be boxed
18:56:47 <kmc> but, if your function is purely parametric, what could it be doing that would benefit from unboxing
18:56:59 <kmc> for example, is there a case where length could get faster if specialized to [Int] ?
18:57:21 <monochrom> I recommend base >= 4 && < 5
18:57:36 <kmc> if you're feeding already unboxed data into a polymorphic function, the boxing penalty could be an issue
18:57:40 <kmc> but otherwise?
18:57:49 <magicman> Thanks :)
18:58:01 <monochrom> but dons has a package with base<10 and I think it's ok too
18:58:14 <kmc> haha
18:58:25 <kmc> HTTP < 9000
18:58:36 <ivanm> monochrom: it's highly un-recommended though
18:58:41 <monochrom> HTTP version numbers are crazy
18:58:59 <kmc> one day in the distant future, our hyperintelligent robot descendants will bump the version of base to 11
18:59:01 <Eduard_Munteanu> kmc: the specialized version might also benefit from deforestation I suppose.
18:59:03 <kmc> and all hell will break loose
18:59:04 <ivanm> monochrom: dons at one stage had ghc-core with base < 5 ... and it then broke when 6.10.1 came out :s
18:59:16 <mm_freak> can i tell cabal to rebuild, when a non-haskell file changes?
18:59:38 <Eduard_Munteanu> But that varies.
18:59:39 <stepcut> monochrom: I think that is because the version numbers used to be date based starting with the year..
18:59:46 <monochrom> yes you have to actually estimate yourself how sensitive your code is to the future
18:59:47 <ivanm> mm_freak: nothing obvious that I can see
18:59:54 <ivanm> unless you do cabal install --reinstall or something
19:00:06 <ivanm> stepcut: yeah; I have the same issue with graphviz
19:00:07 <stepcut> though this really takes the cake, http://packages.debian.org/source/sid/haskell-http
19:00:18 <stepcut> version, 40000009-2
19:00:20 <monochrom> ghc-core is likely to be way more sensitive than binary-search, for example, for obvious reasons
19:00:29 <ivanm> stepcut: lol
19:00:41 <mm_freak> ivanm: i mean for a project i'm working on…  i have some data files included via TH, so when they change, the project needs to be rebuilt
19:00:55 <Eduard_Munteanu> kmc: hm sorry, that doesn't answer your example :/
19:01:06 <ivanm> mm_freak: right, in that directory "cabal install --reinstall" looks like the only thing that'll do it
19:01:10 <monochrom> so for example binary-search saying base<100 is still fine IMO
19:01:17 <ivanm> without a "cabal clean && cabal install"
19:01:29 <mm_freak> ivanm: i don't want to install at all, just rebuild
19:01:44 <ivanm> monochrom: I thought base was going to be deprecated soon in favour of haskell<version> packages again...
19:01:53 <monochrom> onoes
19:01:54 <ivanm> mm_freak: cabal clean && cabal configure && cabal build ?
19:02:03 <Eduard_Munteanu> ivanm: how is silent breakage better than just releasing a "bump base" version?
19:02:06 <monochrom> predicting the future is dangerous business
19:02:08 <ivanm> monochrom: yeah, I'm not so sure it's a good idea
19:02:12 <mm_freak> ivanm: no way to tell cabal that dependency?
19:02:17 <ivanm> Eduard_Munteanu: hmmmm....
19:02:18 <Eduard_Munteanu> Or not silent, but at least cryptic.
19:02:31 <ivanm> mm_freak: "cabal build" is basically a shortcut for ghc --make
19:02:32 <monochrom> there exists cabal clean --save-configure
19:02:33 <srobertson> http://hpaste.org/41369/overlapping_instances_issue <- i'm having a problem with overlapping instances in the 'random-fu' library. any advice / reference URLs?
19:02:39 <ivanm> so if you can get ghc to honour it...
19:02:47 <mm_freak> ivanm: ok, thanks
19:02:52 <ivanm> monochrom: oh? didn't know about that...
19:02:54 <Eduard_Munteanu> I'd rather see "you need base < 4" instead of some long error msg if I didn't know Haskell
19:03:13 <Eduard_Munteanu> Compared with getting away a few times.
19:03:27 <Eduard_Munteanu> (well perhaps most times, but still)
19:05:52 <Eduard_Munteanu> Grr, I gnarled at ivanm for nothing, monochrom said that, sorry.
19:06:13 <pygmalion> anyone have any ReadP experience?
19:06:29 <ivanm> pygmalion: ummm, kinda...
19:06:32 <ivanm> not much though
19:06:43 <pygmalion> Wrote a double parser and now trying to write a complex number parser based off it (this is all with ReadP), but having some trouble. http://pastebin.com/5uykQ0C0
19:08:18 <Eduard_Munteanu> data is probably better there
19:08:21 <ivanm> is GeneralizedNewtypeDeriving an OK extension to use?  I was hoping to be able to have this module not use any extensions, but I don't really want to bother manually defining three Enum instances over newtypes over Ints :s
19:08:35 <guest2425> I am getting this error message Not in scope: type constructor or class `Path'
19:08:37 <guest2425> ?
19:08:39 <Eduard_Munteanu> Also yeah, Generalized^ might do that, I'm unsure.
19:08:48 <ivanm> pygmalion: why not use Data.Complex?
19:09:00 <pygmalion> ivanm: class assignment
19:09:15 <ivanm> Eduard_Munteanu: it will; I'm just a bit irritated that I have to use an extension for it
19:09:18 <ivanm> pygmalion: ahhh
19:09:28 <ivanm> wait, and they're making you use ReadP rather than ReadS?
19:09:44 <Eduard_Munteanu> Then you should probably stick with 'data', using newer extensions might not go well with your instructor.
19:09:47 <pygmalion> ivanm: yessir
19:10:08 <Eduard_Munteanu> or a reasonable type synonym.
19:10:16 <ivanm> Eduard_Munteanu: ummm, what extensions is pygmalion using?
19:10:39 <ivanm> I don't recall ReadP needing any extensions, just that it was GHC-specific
19:10:42 <Eduard_Munteanu> ivanm: I just suggested he should look into GeneralizedNewtypeDeriving for that.
19:10:58 <ivanm> I thought that was aimed at me...
19:11:10 <Eduard_Munteanu> Grr nevermind, it's a bad advice, it won't work.
19:11:19 <ivanm> especially since it doesn't apply in his case
19:11:22 <pygmalion> Eduard_Munteanu: good haha because I had no idea where you were going with it
19:11:23 <Eduard_Munteanu> Yeah.
19:11:44 <ivanm> he isn't using a newtype for starters...
19:11:47 <Eduard_Munteanu> I just saw the deriving line and thought that was his problem.
19:12:20 <pygmalion> Anyway I'm getting an error  http://pastebin.com/gQckKuGq
19:12:20 <Eduard_Munteanu> (he tried as per his comment, but then I saw the newtype wouldn't work)
19:13:22 <guest2425> I am getting this error message Not in scope: type constructor or class `Path'
19:13:49 <pygmalion> guest2425: you'll need to post your code to hpaste.org for us to be able to help you
19:13:58 <guest2425> oh ok
19:15:06 <ivanm> grrr @ pointedlist
19:15:08 <monochrom> I prefer the psychologist approach. "is it not normal? why do you think it is not normal?"
19:15:16 * ivanm contemplates dumping it and just using Seq
19:15:32 <guest2425> pygmalion: Here you go http://pastebin.com/6HLsg7zv
19:15:53 <ivanm> pygmalion: in case you care, we generally use camelCase for Haskell
19:16:10 <pygmalion> ivanm: for function names?
19:16:20 <ivanm> yeah
19:16:28 <ivanm> guest2425: because you haven't defined what Path is
19:16:44 <ivanm> also, is there any particular reason for you to be defining a new graph type?
19:17:02 <guest2425> ivanm: I am confuse
19:17:08 <guest2425> http://haskell.org/hoogle/?hoogle=Path - Look in here
19:17:16 <guest2425> so many differents choices
19:17:17 <ivanm> guest2425: but you haven't imported it
19:17:25 <ivanm> what are _you_ wanting Path to be?
19:17:32 <Eduard_Munteanu> pygmalion: hm, I think it gets the Double from double_parse
19:17:44 <ivanm> especially since you're re-defining Graph, etc.
19:17:45 <guest2425> I trying to look for the shortest Path
19:17:54 <Eduard_Munteanu> pygmalion: perhaps you should fmap show to that beforehand
19:18:02 <ivanm> guest2425: oh, and having constraints of (Eq a, Show a) in your data definition are a bad idea
19:18:02 <guest2425> ivanm: I trying to look for the shortest Path
19:18:10 <ddarius> "why do you think you think it is not normal?"
19:18:12 <ivanm> guest2425: but you haven't said what a Path _is_!
19:18:15 <Eduard_Munteanu> all_complex = full_complex_parse +++ only_real_parse +++ only_imag_parse
19:18:28 <pygmalion> Eduard_Munteanu: what do you mean? sorry. where beforehand?
19:18:36 <guest2425> ivanm: How can I fix that problem
19:18:43 <ivanm> guest2425: define Path
19:18:50 <Eduard_Munteanu> The first looks like it evaluates to ReadP Complex, and the rest to ReadP Double
19:18:55 <guest2425> ivanm: How
19:19:04 <ivanm> guest2425: well, what is Path?
19:19:11 <ivanm> you're the one using it...
19:19:23 <ivanm> guest2425: is there any particular reason you're not using Data.Graph or Data.Graph.Inductive?
19:19:26 <pygmalion> Eduard_Munteanu: ah true i see what you mean. so I need return $ real_part ++ " " ++ "0" etc.
19:20:19 <guest2425> ivanm: The prof defining all the definitions
19:20:29 <ivanm> guest2425: did he tell you to use Path?
19:20:32 <Eduard_Munteanu> pygmalion: mm, no... I think you need to change 'only_{real,imag}_parse'
19:20:34 <guest2425> we were suppose to fill the blank
19:20:51 <Eduard_Munteanu> :t (+++)
19:20:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
19:20:58 <ivanm> guest2425: also, who is this prof? because if he defined Graph like that then he writes horrible code
19:21:00 <guest2425> ivanm: No but My program is complainign
19:21:03 <pygmalion> Eduard_Munteanu: yeah that's what I meant. change the return lines in those. no?
19:21:07 <guest2425> dont know why do
19:21:13 <ivanm> guest2425: OK, let's step back a bit: why are you using Path?
19:21:37 <guest2425> I not suppose to use it
19:21:50 <Eduard_Munteanu> pygmalion: yes. I think you need to 'show' them before returning.
19:21:50 <ivanm> if you're not supposed to use it, then why are you using it?
19:22:10 <Eduard_Munteanu> I'm don't know ReadP, but that would be my guess.
19:22:29 <guest2425> ivanm: this is just crazy
19:22:37 <ivanm> what is?
19:22:41 <pygmalion> Eduard_Munteanu: as in "return $ (show real_Part) ++ " " ++ (show imag_part)" ?
19:23:14 <pygmalion> Eduard_Munteanu: yeah that makes sense-- they need to be strings before they can be ++'d
19:23:38 <Eduard_Munteanu> pygmalion: hm, that doesn't look good. You need "return $ show real_part" and "return $ show imag_part" separately
19:23:45 <Eduard_Munteanu> each where it belongs.
19:24:21 <pumpkin> VarE or ConE if I need to refer to an existing value?
19:24:31 <pygmalion> Eduard_Munteanu: confused again. let me paste what i have now and you take a look and tell me where i need to move it?
19:24:49 <pygmalion> Eduard_Munteanu: http://pastebin.com/zsbcG4CZ
19:24:56 <Eduard_Munteanu> pygmalion: I meant lines 26 and 31 in the previous.
19:24:58 * Eduard_Munteanu looks
19:25:01 <ivanm> pumpkin: hmmm?
19:25:04 <pumpkin> in TH
19:25:12 <pumpkin> if I want to say make an expression "undefined"
19:25:17 <pumpkin> I guess I could use lift
19:25:22 <ivanm> I think ConE is only for constructors
19:25:36 <Eduard_Munteanu> pygmalion: that looks okay now, does it compile?
19:25:41 <ivanm> so VarE
19:25:52 <Eduard_Munteanu> (at least wrt types)
19:26:04 <pygmalion> Eduard_Munteanu: yes it compiles. unfortunately, something is wrong in my parsing because i'm getting a "no parse" exception
19:26:17 <pygmalion> (with my test suite)
19:28:10 <kmc> i think (lift undefined) will be a expansion-time error
19:28:23 <ivanm> preflex: seen sw17ch
19:28:23 <preflex>  sw17ch was last seen on #haskell 40 days, 20 hours, 14 minutes and 51 seconds ago, saying: lol
19:28:39 <kmc> you could use:  varE 'undefined
19:28:42 <pumpkin> kmc: type is polymorphic, it doesn't like it
19:28:48 <kmc> or [| undefined |]
19:28:51 <pumpkin> :r
19:28:52 <Eduard_Munteanu> pygmalion: hm, I'm unsure, try using ghci to show you and backtrack the exception's location
19:29:03 <kmc> well, you have to decide which type to try and fail to lift
19:29:44 <cads> hey, what is a type constructor like  [ _ ]  or f _ called?
19:31:05 <pygmalion> Eduard_Munteanu: yup, thanks for your help
19:31:13 <Eduard_Munteanu> Does Haskell allow that on types?
19:31:30 <cads> @type fmap
19:31:31 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
19:31:51 <pathickey> this one is a newbie question: I have a string of LogEntry, which is either a LCall (Call Enter "foo"), LCall (Call Exit "foo"), or LAction _
19:31:54 <Eduard_Munteanu> cads: that's a kind, the * stuff
19:32:10 <Eduard_Munteanu> cads: it's not a placeholder really
19:32:15 <cads> yeah, I'm thinking it's a kind of functor or something
19:32:25 <Eduard_Munteanu> cads: it is  a functor
19:32:26 <pathickey> I want to collect this into a data structure like data Stmt = SCall String [Stmt] | SAction Action
19:33:08 <pathickey> where I fill the SCall string with the name from my LCalls, and the list with all calls/actions that happened between Enter foo and Exit foo
19:33:15 <Eduard_Munteanu> cads: it's not like _ at value-level
19:33:27 <pathickey> I know i should be using a parser to do this sort of thing, but I dont understand how to use Parsec for anything other than text.
19:35:34 <kmc> cads, what do you mean by [_]?
19:35:47 <kmc> [T] is sugar for ([] T).  it's built-in sugar, no way to define similar things
19:35:57 <kmc> [] is also special in that its name would normally be illegal
19:36:25 <cads> kmc, I mean that the underscore should be replaced with any type, I guess I should have been specific that I meant at type level
19:36:47 <cads> kmc, ah, I wondered about that
19:37:10 <kmc> though iirc GHC really allows the syntax «data [] a = a : [] a | []»
19:37:17 <kmc> by exemption, when package name is 'base'
19:38:03 <kmc> so you mean the type constructor which, give a type t, returns the type [t]?
19:38:11 <kmc> if you had type level lambdas you could write λt. [t]
19:38:16 <cads> right
19:38:16 <kmc> but it's also called simply []
19:38:21 <kmc> > [1,2,3] :: [] Int
19:38:22 <lambdabot>   [1,2,3]
19:38:29 <kmc> anyway, what do you mean by "what is it called"?
19:38:35 <cads> I think that in Hask these things are functors
19:38:48 <kmc> it's a type constructor; it's an instance of numerous classes such as Functor, Applicative, Monad, Foldable, Traversable, ...
19:38:52 <cads> but I'm wondering about the haskell jargon for them
19:38:58 <kmc> not every type constructor is a functor, however
19:39:03 <kmc> you have to be able to implement fmap
19:39:19 <kmc> newtype C t = MkC (t -> Int)
19:39:24 <kmc> no sane fmap for that; it's a contravariant functor
19:39:45 <kmc> @djinn (a -> b) -> (b -> Int) -> (a -> Int)
19:39:45 <lambdabot> Error: Undefined type Int
19:39:47 <kmc> ;P
19:40:12 <kmc> cads, so "type constructor" or "one-argument type constructor" or "type constructor of kind * -> *"
19:40:22 <cads> cool
19:40:24 <kmc> (the latter is a bit more specific, as it says the argument must itself be a type"
19:40:29 <kmc> i'm not sure if you're looking for something more specific
19:41:21 <Axman6> ]/win 22
19:42:00 <cads> I understand that I can't think about them as instances of the functor type class. Any f :: * -> * seems like it would be a morphism between two types in the category Hask. I don't know if this is true for your example of a contravariant functor, however.
19:42:34 <cads> oh wait
19:43:12 <kmc> to be a morphism, it has to map arrows as well as objects
19:43:14 <kmc> the arrows are functions
19:43:16 <cads> hask is the category of types and functions between them.
19:43:20 <kmc> yes
19:43:38 <kmc> sorry, to be a functor, it has to map morphisms as well as objects
19:43:50 <kmc> (arrow is often a synonym for morphism but can be confusing due to the type class of the same name)
19:44:11 <kmc> in Haskell the map on objects (types) is the tycon itself, and the map on morphisms (functions) is fmap
19:44:23 <cads> for a moment I thought that hask was a category of type categories with functors between them as its arrows
19:45:34 <kmc> there is also a "category of endofunctors"
19:45:48 <kmc> famously used to confuse beginners as to what a monad is
19:46:05 <cads> yeah, because of someone's unfortunate statement :)
19:46:07 <ivanm> I thought a monad was a zygohistoric premorphism or something like that...
19:46:13 <ivanm> @quote wadler monad
19:46:13 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
19:46:28 <ivanm> @quote zygohistoric
19:46:28 <lambdabot> No quotes match. Are you on drugs?
19:46:31 <ivanm> bah
19:46:33 <cads> haha
19:46:36 <ivanm> @quote morphism
19:46:36 <lambdabot> kmc says: Zagen, you'll need a zygohistomorphic prepromorphism from the bifunctorial Kleisli category of username-password pairs to a combinatory arrow calculus of php scripts
19:46:37 <kmc> i think the objects of the endofunctor category of Hask would be types that are instances of Functor, and the morphisms would be natural transformations
19:47:04 <kmc> and i've heard it said that you can model natural transformations thus:  data Nat f g = MkNat (forall a. f a -> g a)
19:47:22 <Eduard_Munteanu> ivanm: ))
19:47:25 <Eduard_Munteanu> :))
19:47:41 <pumpkin> kmc: why not newtype or just type?
19:47:47 <kmc> hmm
19:48:00 <kmc> i forgot whether newtype works with polymorphic components
19:48:01 <kmc> it should though
19:48:03 <pumpkin> it does
19:48:06 <pumpkin> unless you have a dictionary
19:48:36 <kmc> right
19:48:51 <Eduard_Munteanu> kmc: what's a tycon?
19:48:53 <kmc> it is unfortunate how the dictionary-passing implementation of classes has pervaded our syntax
19:48:56 <kmc> Eduard_Munteanu, type constructor
19:49:01 <Eduard_Munteanu> Oh.
19:49:04 <kmc> err, i meant semantics
19:49:09 <kmc> syntax to a lesser degree
19:51:03 <pumpkin> edwardk: damn :P
19:52:18 <cads> kmc, hah, I'm sure I'll understand the endofunctor thing eventually
19:52:55 <pumpkin> cads: a functor within hask
19:53:07 <pumpkin> taking types to types and preserving functions between them
19:53:14 <kmc> every instance of Functor is an endofunctor in Hask
19:53:19 <kmc> which just means it's a functor from Hask to itself
19:53:35 * pumpkin ponders writing a Functor of a data family
19:53:42 <kmc> because for Functor F, if T is a Haskell type then (F T) is also a Haskell type
19:53:45 <cads> the only part I can't visualize are the natural transforms between functors
19:54:05 <kmc> and if f :: A -> B is a Haskell function, then fmap f :: F A -> F B is also a Haskell function
19:54:08 <ManateeLazyCat> Why i write `PATH=$PATH:~/.cabal/bin` in .cabal file, but haddock got "PATH=$PATH:~.cabalbin", where the / ?
19:54:16 <kmc> the more general classes in category-extras relax this
19:54:32 <kmc> so fmap looks more like (a ~> b) -> (f a ~~> f b)
19:54:48 <kmc> where (~>) and (~~>) are the tycons for the morphisms of two different categories, neither of which need be Hask
19:55:51 <ivanm> ManateeLazyCat: in the description?
19:55:59 <ManateeLazyCat> ivanm: Yes.
19:56:03 <ivanm> because of Haddock markup
19:56:12 <ivanm> use: ~\/.cabal\/bin
19:56:20 <ivanm> ManateeLazyCat: also, it's better to use $HOME rather than ~
19:56:37 <ManateeLazyCat> ivanm: Yes, i have write HOME, but some user copy that.
19:56:43 <ManateeLazyCat> ivanm: Thanks 
19:56:47 <ivanm> np
19:56:54 <ManateeLazyCat> ivanm: @package manatee
19:57:00 <ManateeLazyCat> @package manatee
19:57:00 <lambdabot> http://hackage.haskell.org/package/manatee
19:57:02 <ManateeLazyCat> ivanm: ^^^^
19:57:03 <ivanm> yeah, I saw you had released that
19:57:11 <ivanm> I'll have a looksie this weekend; a tad busy right now
19:57:20 <ivanm> (trying to get a planar graph library done)
19:57:44 <ManateeLazyCat> ivanm: I found my documentation still hard to haskell newbie.
19:57:49 <ksf> capri is a witness of cabal's most evil failure.
19:58:02 <ksf> cabal-install's, that is.
19:58:07 <pumpkin> ?
19:58:08 <ManateeLazyCat> ivanm: Something like how to install cabal and don't use sudo with cabal.
19:58:24 <ivanm> ksf: which failure in particular?
19:58:52 <ksf> messing up.
19:58:57 <pumpkin> Axman6: I'm doing objc in haskell!
19:59:03 <guest2425_> hello
19:59:12 <pumpkin> TacticalGrace: I have a new objc user-level approach :P
19:59:15 <guest2425_> I am getting an error message 
19:59:28 <guest2425_> please guide me http://pastebin.com/atdQfyi4
19:59:36 <ksf> well, basically you don't have easy enough control over package versions.
20:00:05 <guest2425_> ,
20:00:15 <ksf> the project-private package database is generally a good idea, but it could use some more sharing.
20:00:22 <ManateeLazyCat> ivanm: I found '>' is use for command display in cabal's description documentation, and '.' for indent.
20:00:41 <ivanm> ManateeLazyCat: not quite
20:00:52 <ivanm> ManateeLazyCat: it matches Haddock markup with one exception: you can't have blank lines
20:00:57 <ivanm> if you want a blank line, put a . there
20:01:13 <ManateeLazyCat> ivanm: Yes, i see.
20:01:26 <ivanm> guest2425_: you probably need another layer of mapping
20:01:35 <ManateeLazyCat> ivanm: Thanks for explain, it's mark crazy me some minutes. :)
20:01:43 * int80_h is secretly an endofunctor by night.
20:01:47 <ivanm> ManateeLazyCat: heh, yeah, it's a little undocumented
20:01:54 <ivanm> int80_h: that's nice...
20:01:58 <ivanm> :p
20:02:08 <cads> kmc, I'm still trying to understand constructors of kind *->*, and I think I have identified some circularity in my thinking.. can I try to explain it?
20:02:18 <kmc> cads, i've got to go now, but i'll be back later
20:02:36 <guest2425_> ivanm: how?
20:02:44 <cads> kmc, okay
20:02:51 <pumpkin> cads: they're functions between types
20:02:55 <pumpkin> they take a type and return a type
20:03:09 <guest2425_> m
20:03:24 <ivanm> guest2425_: since the line numbers in the error message don't match up with the actual paste, it's hard to tell
20:03:32 <guest2425_> why I show guest2425 [476b5294@gateway/web/freenode/ip.71.107.82.148] has quit [Ping timeout: 265 seconds]
20:03:43 <ivanm> because you're now guest2425_
20:03:49 <ivanm> wow, we currently have 3 guests here...
20:04:17 <guest2425_> but it shows quit
20:04:17 <int80_h> I'm more of a hanger-on
20:04:36 <cads> pumpkin, I feel like that's just another turtle down :)
20:04:54 <cads> what are functions between types?
20:05:04 <cads> just a kind of relation between types?
20:05:12 <guest2425_> ivanm: this is the line with the error message  (\ parent pathss -> map (\path -> parent : path) pathss)  --- Error Message 
20:05:14 <ivanm> guest2425_: *sigh* you now have a different nickname
20:05:20 <guest2425_> no
20:05:23 <ManateeLazyCat> ivanm: Thanks for your help, fix now.
20:05:27 <pumpkin> cads: it takes a type and returns a type, like a value-level function
20:05:27 <guest2425_> which one?
20:05:35 <pumpkin> cads: you can think of it as a relation but that doesn't buy you anything here
20:05:37 <ivanm> guest2425_: you now have an underscore on the end
20:05:51 <guest2425_> oh ok
20:05:57 <guest2425_> nice i guess
20:06:02 <ivanm> guest2425_: as for your error: try using concatMap instead of map
20:06:11 * ivanm bangs his head against his desk
20:06:28 <ivanm> dammit, too many values are being passed around when creating the dual...
20:06:57 <guest2425_> no that doesnt work
20:07:05 <guest2425_> ivanm: doesnt work
20:07:20 <ivanm> *shrug*
20:07:40 <ivanm> sorry, but your paste is too convoluted and I'm too busy atm to help any more
20:08:11 <int80_h> guest2425 : try the beginners or haskell cafe mailing lists.
20:08:17 <guest2425_> ivanm:can I make a new paste?
20:08:31 <cads> pumpkin, so it says nothing about how you're going to do things between the values contained in the types. f :: * -> * simply associates a unique type to each type.
20:08:31 <ivanm> sure
20:08:39 <guest2425_> ok
20:08:42 <cads> pumpkin, sorry for being quite basic :)
20:08:55 <pumpkin> cads: yeah, that's fine. There's no requirement to operate on both types and their values
20:09:07 <int80_h> cads, I'm very basic and pump[kin has helped me many many times.
20:09:31 <pumpkin> if I have a function F :: * -> * that takes Int to Bool, so F Int = Bool, then if I write x :: F Int; x = True, that typechecks
20:09:48 <pumpkin> of course, I'm talking about general type functions there, which isn't the case here
20:14:02 <ManateeLazyCat> ivanm: I'm crazy now, many Chinese friend ask me how to play manatee. :)
20:14:11 <ivanm> ManateeLazyCat: cool!
20:15:05 <Rotaerk> ManateeLazyCat, that statement alone makes me afraid of you
20:15:21 <Adamant> oh the huge manatee!
20:15:24 <Adamant> :P
20:15:28 <pumpkin> manatees are so cute
20:15:34 <ManateeLazyCat> Rotaerk: Why ?
20:15:40 <lars9> how to write merge :: (Ord a) => [[a]] -> [a] neatly?
20:15:48 <ivanm> lars9: concat
20:15:49 <ivanm> :p
20:16:02 <lars9> ivanm: oh i mean mergesort
20:16:13 <ivanm> yeah, I know
20:16:23 <ivanm> lars9: is this homework?
20:16:29 <pumpkin> of course it is
20:16:34 <lars9> ivanm: i have no school
20:16:54 <ManateeLazyCat> ivanm: Today is busy mail day, my finger on the fly. :)
20:17:03 <pumpkin> s/is/isn't/
20:17:06 <ivanm> Rotaerk: if you meant that because of how he said it, you should be aware that ManateeLazyCat uses an automatic Chinese -> English translator, so you can't take what he says literally
20:17:18 <Rotaerk> ahh haha
20:17:19 <ivanm> lars9: so why are you wanting to write mergesort then?
20:17:33 <ivanm> that's the only reason I can think of...
20:17:40 <ManateeLazyCat> Rotaerk: Yes, i have automatic translate module in my irc client.
20:17:55 <ManateeLazyCat> Rotaerk: Write your mother language and translate to English (or any other language).
20:18:03 <lars9> ivanm: i want to use haskell in my own experiment
20:18:18 <ivanm> ... experiment?
20:18:29 <lars9> ivanm: my code looks like C, that's not what i want from using haskell..
20:18:32 <cads> pumkin, so when we say  Class Functor f where fmap :: (a -> b) -> f a -> f b, we are defining a whole class of type functions f which are constrained to be able to support the function fmap, which does let you do value level things between the types?
20:18:41 <ivanm> lars9: but why not use the pre-existing sort function?
20:18:51 <pumpkin> cads: yeah, pretty much
20:19:10 <lars9> ivanm: because those sorted lists are 1G per list, and sorted by other machines
20:19:35 <pumpkin> lars9: you want to write a sort function that's better than the standard one?
20:19:56 <pumpkin> lars9: if you have huge stuff, I'd use Vector, and dolio's fancy sorting algorithms on it
20:20:01 <pumpkin> it'll use a lot less space and will be faster
20:20:30 <ivanm> yeah, no way will you get a better sorting function (unless it's specialised based upon the datatype) using lists
20:21:19 <ManateeLazyCat> ivanm: My Chinese friends said my English is not so good make he confuse my documentation at haskell-cafe.
20:21:37 <lars9> pumpkin: 9 machines are sorting a huge data set using qsort + local mergesort, then stream to a merger machine
20:21:56 <pumpkin> yeah, I'm asking why not just use the usual list sort?
20:22:19 <pumpkin> :t sort
20:22:20 <lambdabot> forall a. (Ord a) => [a] -> [a]
20:22:22 <ivanm> lars9: oh, doing mapReduce?
20:22:36 <ivanm> I would think that using lists for that would be a bad idea...
20:22:36 <lars9> pumpkin: list + lazy evaluation makes perfect sense on the merger machine...
20:22:46 <ivanm> aren't there lazy vectors?
20:22:52 <ivanm> or is that an oxymoron...
20:23:07 <pumpkin> pity merge :: (a -> a -> Ordering) -> [a] -> [a] -> [a] isn't exported from Data.List
20:23:17 <pumpkin> there are lazy vectors
20:23:17 <ivanm> ManateeLazyCat: I find  your English understandable as long as remember that it's translated; then again, I deal with a fair number of people from non-English backgrounds...
20:23:27 <pumpkin> @hackage data-ordlist
20:23:27 <lambdabot> http://hackage.haskell.org/package/data-ordlist
20:23:33 <ivanm> yeah; so using a lazy vector would probably be better
20:23:44 <pumpkin> lars9: check mergeall in there
20:23:55 <lars9> let me check
20:23:56 <lars9> thanks
20:23:58 <pumpkin> lars9: however, that assumes the heads are ordered
20:24:03 <pumpkin> lars9: which probably isn't true for you
20:24:13 <pumpkin> so you want foldr merge [], probably
20:24:27 <cads> pumpkin, thanks for the explanation
20:25:28 <lars9> laziness is not mentioned in http://hackage.haskell.org/package/vector ...
20:25:39 <pumpkin> why do you want laziness here?
20:26:00 <ivanm> pumpkin: I'm guessing because the final dataset is too big to fit in RAM
20:26:18 <pumpkin> sorting on something larger than RAM is tricky
20:26:19 <ManateeLazyCat> ivanm: I need to learn English harder, my English is too bad that cause I can not express well what I mean to others. Unfortunately, most of my time for programming. 
20:26:20 <dget> if I have a ByteString, say "Foobar: Unpredictable text" - what's the best way to find the value of the unpredictable text?
20:26:23 <pumpkin> making it lazy isn't sufficient
20:26:56 <ivanm> dget: first of all, if it's text, use Text, not ByteString
20:27:02 <lars9> ManateeLazyCat: your project seems huge, are you working on it alone and just for fun?
20:27:18 <ManateeLazyCat> lars9: Yes, now just me.
20:27:19 <ivanm> lars9: he has a tribe of gnomes working on it for him
20:27:20 <ivanm> :p
20:27:52 <pathickey> Is there a tutorial for using Parsec with non-string inputs? For example, I have a list of data with a structure like Enter a | Exit a | Statement b
20:27:57 <ManateeLazyCat> ivanm: Yes, i need perfect gtk2hs first.
20:27:58 <dget> ivanm: I'm working with ByteStrings because of the library I'm working with
20:28:14 <ManateeLazyCat> ivanm: Fortunately, gtk2hs perfect for me now .:)
20:28:20 <pathickey> I want to collect the statements before Enter foo and Exit foo.
20:28:27 <lars9> ManateeLazyCat: cool...
20:28:40 <ManateeLazyCat> lars9: Yes, i do it just for fun.
20:28:52 <ManateeLazyCat> lars9: Not for money or other dirty thing.
20:29:09 <lars9> ManateeLazyCat: awesome
20:29:21 <ManateeLazyCat> lars9: I hope more people can join us. :)
20:29:48 * ManateeLazyCat Send mail to my emacs friend, Chinese friend, build a Team! 
20:29:56 <ManateeLazyCat> BTW, ##manatee is irc client for manatee.
20:30:37 <lars9> i hope i can use haskell as well as you
20:30:40 <lars9> :)
20:30:53 <ManateeLazyCat> lars9: I'm not super haskell guy.
20:31:02 <ManateeLazyCat> lars9: I just finish some gtk2hs code.
20:31:29 <lars9> you worked on gtk2hs?
20:31:30 <ManateeLazyCat> lars9: Someone like dcoutts_ dons Saizan Cabal ivanm is super guy. :)
20:31:31 <ivanm> @pl (\ fn -> (snd fn, mkNI fn))
20:31:32 <lambdabot> liftM2 (,) snd mkNI
20:31:35 <lars9> i mean as author
20:31:50 <ManateeLazyCat> lars9: No, i'm not author, but i'm current active developer for gtk2hs.
20:31:57 <ManateeLazyCat> lars9: Axel is author of gtk2hs
20:31:57 <ivanm> ManateeLazyCat: I don't think that translated too well, since Cabal isn't a person...
20:32:08 <lars9> ManateeLazyCat: i see, cool
20:32:23 <ManateeLazyCat> ivanm: I remember someone nick is Ca... somethi
20:32:40 <lars9> and they could be girl
20:32:46 <lars9> :p
20:33:01 <ManateeLazyCat> ivanm: Is Cale, i remember
20:33:05 <monochrom> Cale is super book
20:33:18 <lars9> is there any female author in linux world?
20:33:32 <ManateeLazyCat> lars9: Yes,
20:33:46 <ManateeLazyCat> lars9: Author of Pugs
20:34:08 * ivanm tries to work out if monochrom deliberately made a mistake or not...
20:35:09 <pumpkin> ivanm think so i
20:35:42 <ManateeLazyCat> I hope someday i can reach the high-level of dons or dcoutts_
20:35:56 <ivanm> OK, how do I use a library that uses fclabels? do I need to enable TH?
20:36:01 <ivanm> because ghci is bitching...
20:36:22 <pumpkin> you shouldn't need to
20:36:32 <pumpkin> can I see?
20:37:01 <TacticalGrace> pumpkin: How does it look like?
20:37:34 <pumpkin> http://hpaste.org/41370/new_objc
20:37:48 <ivanm> Couldn't match expected type `a -> b'
20:37:48 <ivanm>            against inferred type `PointedList a1
20:37:48 <ivanm>                                   fclabels-0.4.2.1:Data.Record.Label.:-> a1'
20:37:53 <pumpkin> I'm not a fan of the type annotations in there
20:37:56 <ivanm> gah, meant to remove line breaks... :s
20:37:58 <pumpkin> haven't decided if I need them yet
20:38:28 <ivanm> pumpkin: if that's meant to be nicer than HOC, I shudder to think what it is like...
20:38:42 <pumpkin> ivanm: there's not that much noise in there :/
20:38:59 <TacticalGrace> pumpkin: not, not much noise
20:39:01 <pumpkin> it's strongly typed though
20:39:01 <tensorpudding> hmm, fisher-yates shuffle in haskell is not very fast
20:39:04 <dobblego> would someone with a decent ~/.haskeline file please post it?
20:39:07 <TacticalGrace> How do you get the symbols into Haskell?
20:39:27 <ivanm> dobblego: I just use the defaults :s
20:39:27 <TacticalGrace> pumpkin: Might be worthwhile sketching at http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC
20:39:35 <dobblego> ivanm, you mean, no file?
20:39:46 <pumpkin> TacticalGrace: I've been abstracting away from the low-level details as before :) mostly just been trying to think of fun ways of representing it in haskell
20:39:47 <ivanm> yup
20:39:57 <TacticalGrace> pumpkin: ic
20:40:01 <pumpkin> TacticalGrace: so the code doesn't actually run
20:40:39 * hackagebot manatee 0.0.3 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.3 (AndyStewart)
20:40:41 <ManateeLazyCat> Hope above install documentation is clear for everyone (even haskell newbie).
20:41:02 <pumpkin> oh actually, I can kill the type annotations
20:41:16 <dobblego> ivanm, I tried that once but I was unable to use control character keys e.g. CTRL-Right
20:41:19 <TacticalGrace> pumpkin: at http://hackage.haskell.org/trac/ghc/wiki/ObjectiveC we have a bullet list after "We also have some basic ideas for type-safe usage of Objective-C above the FFI layer:" — it would fit there (from the level of abstraction)
20:41:39 <pumpkin> yeah, I added that :)
20:41:45 <ivanm> dobblego: oh, I then use ghci within emacs mostly
20:42:04 <TacticalGrace> pumpkin: hehe
20:42:13 <pumpkin> I'm going to write it on the wiki once I get something more substantial
20:42:17 <ManateeLazyCat> Have lunch, brb
20:42:25 <ivanm> OK, using _focus from pointedlist works, but focus gives an fclabels-based type error :s
20:42:26 <pumpkin> issues are that everything is in IO :/
20:42:31 <pumpkin> but can't really avoid it at this level
20:42:31 <TacticalGrace> pumpkin: why not put it there right away
20:42:40 <TacticalGrace> pumpkin: it's fine to evolve stuff on the wiki
20:42:46 <pumpkin> fair enough :) I'll do it in a bit
20:43:01 <pumpkin> I also explored the other approach I already wrote up on the wiki a bit more
20:43:02 <TacticalGrace> obcj messaging must be in IO (or similar)
20:43:05 <pumpkin> I prefer this one
20:43:05 <ivanm> does something special need to be done with :-> kind constructor values?
20:43:08 <TacticalGrace> got tons of side effects after all
20:43:11 <pumpkin> yeah
20:43:28 <TacticalGrace> C ffi is in IO, too
20:43:35 <TacticalGrace> so, I wouldn't worry about that
20:43:48 <pumpkin> well, the issue is more that parameters need to be pure right now
20:43:54 <pumpkin> the receiver can be in IO with the (#) operator
20:43:57 <ivanm> oh, the :-> is a cosntructor...
20:43:58 <pumpkin> or pure with (##)
20:44:06 <ivanm> grrr.....
20:44:09 <pumpkin> ivanm: me?
20:44:21 <pumpkin> oh
20:44:25 <TacticalGrace> pumpkin: that seems fine, to me, too
20:44:26 <ivanm> heh
20:44:41 <TacticalGrace> pumpkin: you will bind results from other objc messaging using <-
20:44:41 <pumpkin> TacticalGrace: I have an idea to deal with that not too uglily too
20:44:48 <TacticalGrace> pumpkin: which gives you a pure value
20:44:51 <pumpkin> yeah
20:44:52 <TacticalGrace> to pass to the next msg
20:45:15 <TacticalGrace> I wouldn't try to get extra nesting in Haskell (extra over objc)
20:45:18 <pumpkin> but it's nice to be able to do something like [moo blah:[oi zomg:5 oink:[x y]] baa:5]
20:45:29 <pumpkin> I'll see how pleasantly I can do it
20:45:30 <TacticalGrace> the closer to objc syntax the objc msg'ing is, the better
20:45:50 <TacticalGrace> pumpkin: ok
20:45:57 <pumpkin> I currently would need to pull the [oi zomg ...] stuff into a separate bind
20:46:01 <pumpkin> and the [x y]
20:46:04 <TacticalGrace> yeah
20:46:10 <pumpkin> which makes me uncomfortable
20:46:16 <pumpkin> since it's pretty common to want to compose these things
20:46:46 <TacticalGrace> yep, I see what you mean
20:46:49 <ivanm> OK, my planar graph module now lets you get the dual of a graph... but as yet there is no way to actually _create_ the graph, let alone manipulate it :p
20:47:32 <ivanm> preflex: seen Cale
20:47:32 <preflex>  Cale was last seen on #haskell 5 hours, 12 minutes and 21 seconds ago, saying: okay, close enough :)
20:48:07 <pumpkin> TacticalGrace: I really look forward to actual cocoa bindings in haskell :P
20:48:17 <pumpkin> this will be one level below the ideal haskell API on it
20:48:27 <Cale> hi
20:48:47 <TacticalGrace> pumpkin: I do really want these bindings, too!
20:48:52 <ManateeLazyCat> Cale: Hey
20:49:24 <pumpkin> TacticalGrace: how hard would a foreign import objc be? I've read the design docs on it, and I could easily have my TH spit out connections to it
20:49:28 <pumpkin> but in GHC itself
20:49:39 <ivanm> hey Cale
20:50:14 <TacticalGrace> pumpkin: the "Pragmatics" seubsection has three ways of doing it
20:50:25 <ivanm> Cale: waddaya think of this? http://hpaste.org/41371/start_of_a_planar_graph_type
20:50:31 <TacticalGrace> (1) is pretty easy, I think
20:50:39 <TacticalGrace> (2) requires more work in GHC
20:50:42 <TacticalGrace> and (3) even more
20:50:55 <ivanm> it's loosely based upon the data structure Brendan McKay uses in plantri, which is meant to be one of the fastest planar-graph generators around
20:50:59 <ManateeLazyCat> Cale: Are you super book? :)
20:51:13 <TacticalGrace> in the meantime, I actually think that (1) might be the best anyway as it's main disadvantage is performance
20:51:26 <Cale> ivanm: Interesting!
20:51:32 <Cale> ManateeLazyCat: I don't know what that means.
20:51:38 <TacticalGrace> but we could (in a second step) use LLVM to JIT the binding code
20:51:45 <TacticalGrace> to alleviate the performance issue
20:52:03 <ivanm> Cale: I just have to work out how to deal with adding, deleting, etc. nodes nad edges; which involves trawling through the C code :s
20:52:10 <ManateeLazyCat> Cale: monochrom said "Cale is super book". :)
20:52:15 <ivanm> I was thinking about FFI'ing, but brendan's stuff has a funny license :s
20:52:22 <ivanm> ManateeLazyCat: I think that was a typo; "super cool" maybe?
20:52:31 <ManateeLazyCat> ivanm: really? 
20:52:34 <ManateeLazyCat> ;p
20:52:54 <ManateeLazyCat> ivanm: How possible?
20:53:10 <ivanm> I'd say about 65% possible
20:53:10 <guest2425> hello
20:53:10 <ivanm> ;)
20:53:23 <pumpkin> TacticalGrace: ah yeah
20:53:35 <pumpkin> TacticalGrace: we could actually be mostly correct and statically look up the IMPs 
20:53:52 <pumpkin> maybe foreign import objc static :P
20:54:07 <pumpkin> by statically, I mean the runtime looks it up once at startup and uses that
20:54:25 <pumpkin> to avoid dynamic selector lookup
20:54:26 <TacticalGrace> right
20:55:11 <jaredj> @pl \(x,y) -> f x y
20:55:11 <lambdabot> uncurry f
20:55:28 <djahandarie> pumpkin, wat'cha workin' on?
20:55:42 <pumpkin> djahandarie: strongly typed representations of objective c messaging in haskell
20:55:57 <pumpkin> another question is what the hell should NSArray or NSDictionary operations work on?
20:56:06 <TacticalGrace> pumpkin: once we know exactly what we want from the forign decls, I can have a stab at implementing them in GHC
20:56:08 <pumpkin> I have some ideas for fast/safe casting
20:56:11 <djahandarie> Cool. What is this going to be used for?
20:56:16 <ivanm> I think I've done more hacking on this planar graph library the past two days than I've hacked the past two months...
20:56:17 <ivanm> \o/
20:56:22 <pumpkin> djahandarie: bindings to mac os libraries!
20:56:26 <pumpkin> so we can be super awesome on mac os
20:56:28 <djahandarie> Oh wow
20:56:33 <djahandarie> Overdue
20:56:37 <pumpkin> TacticalGrace: yeah!
20:56:37 <guest2425> ivanm: here is more clean http://pastebin.com/t8wpJ23c
20:56:44 <ManateeLazyCat> ivanm: Maybe i can write some ivanm graphics-client for your graphics library. :)
20:56:55 <TacticalGrace> pumpkin: I have done part of the C FFI code and might remember how it all works, once I look at it again
20:57:02 <guest2425> ivanm: I did a new paste code
20:57:03 <ivanm> ManateeLazyCat: what graphics library?
20:57:04 <pumpkin> ah :)
20:57:10 <ivanm> guest2425: hold your horses, I'm looking!
20:57:17 <guest2425> oh ok
20:57:19 <ManateeLazyCat> ivanm: I remember you have some beautiful graphics library to scan cabal 
20:57:21 <pumpkin> TacticalGrace: there's also been a foreign import prim added since then, so I guess it's more modular these days
20:57:21 <ivanm> ManateeLazyCat: I'm dealing with _graph_ libraries, not _graphics_ libraries!
20:57:29 <pumpkin> or maybe was from the start?
20:57:32 <ivanm> ManateeLazyCat: that just used pandoc and graphviz
20:57:37 <TacticalGrace> pumpkin: it was always modular
20:57:40 <pumpkin> another library I'm writing uses foreign import prim!
20:57:44 <pumpkin> ah okay
20:57:51 <ManateeLazyCat> ivanm: I add some gtk+ widget wrap it. :)
20:57:52 <ivanm> pumpkin: that reminds me: I noticed you wanted to be part of my graph SIG
20:57:57 <pumpkin> ivanm: I do!
20:57:57 <ivanm> so what are _you_ bringing to the table? :p
20:58:06 <pumpkin> ivanm: nothing you're interested in, don't worry ;)
20:58:11 <TacticalGrace> ivanm: lol
20:58:13 <pumpkin> I'm interested in a graph database
20:58:28 <ivanm> cool
20:58:29 <pumpkin> disk-based, obviously
20:58:43 <ivanm> oh, I figured it'd be sphere-based...
20:58:47 <ivanm> :p
20:59:04 <ivanm> (sorry, being too much stuff dealing with planar graphs on the sphere vs the unit disk lately)
20:59:38 <pumpkin> :)
20:59:44 <pumpkin> but yeah, I'm looking forward to it
20:59:50 <pumpkin> but I have a bunch of projects I'm working on concurrently
21:00:12 <ivanm> guest2425: sorry, I still can't work out what you're doing there
21:00:27 <ddarius> foreign import prim "and" proper
21:00:28 <ivanm> try adding explicit type signatures to allpathsTo
21:00:41 <guest2425> ivanm: I need to find the shortest path
21:00:42 <ivanm> guest2425: but that line is obviously wrong
21:00:51 <ddarius> pumpkin: Why the heck are you using foreign import prim?
21:00:51 <ivanm> and I have to head off now
21:00:59 * pumpkin barfs at "FlockDB is an open source distributed, fault-tolerant graph database for managing data at webscale"
21:01:04 <ivanm> pumpkin: so, are you gainfully employed now?
21:01:34 <pumpkin> ddarius: writing a binding to GMP's natural type cause using Integer for arbitrary-precision naturals makes me itchy
21:01:49 <pumpkin> a basic version of it is on github, but it's pretty lame right now
21:02:06 <pumpkin> ivanm: yeah, but haven't started work yet
21:02:22 <ivanm> which explains why you have time to hack on obj-C stuff? :p
21:02:38 <ddarius> Useless, useless obj-c stuff.
21:02:47 <pumpkin> :(
21:02:49 <djahandarie> ddarius, yo. Am I crazy regarding thinking an indexed monad isn't actually on endofunctors?
21:03:00 <ivanm> anyway, I'm off
21:03:01 <ivanm> bye all
21:04:38 <djahandarie> "ddarius, so you have  m s1 s2 a -> (a -> m s2 s3 b) -> m s1 s3 c  . Doesn't this mean there are two functors from C -> C where a,b \in C? But the functors can't be composed, so they aren't actually endo (And if they aren't endo then it can't be a category object in End(C))" is what I said
21:05:21 <guest2425> i need help please
21:05:31 <ddarius> djahandarie: The functor is m s1 s2 :: * -> *
21:06:00 <guest2425> please help http://pastebin.com/t8wpJ23c
21:07:33 <djahandarie> Wouldn't there be a different function from C to C for each pair of s1 s2?
21:07:36 <djahandarie> functor*
21:07:46 <guest2425> hello
21:07:58 <ddarius> djahandarie: Usually, yes.
21:08:45 <djahandarie> But those functors can't be composed unless the types match up properly
21:09:03 <ddarius> djahandarie: They're both functors from * -> *.
21:10:22 <djahandarie> Wouldn't it be like s1 x * -> s2 x *? Hm.
21:10:33 <guest2425> please help http://pastebin.com/t8wpJ23c
21:11:38 <djahandarie> Okay I think I'm confused now
21:14:09 <kmc> cads, i'm back, if your question from before still stands
21:19:35 <Evious> Are there any interesting projects that use Harpy?
21:20:25 <blackdog> anyone got a current hackage mirror?
21:20:44 <guest2425> :t   (\ parent pathss -> map () pathss)
21:20:44 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `()'
21:20:44 <lambdabot>     In the first argument of `map', namely `()'
21:20:45 <lambdabot>     In the expression: map () pathss
21:21:34 <guest2425> :t  (\ parent pathss -> map (\path -> parent : path) pathss)
21:21:34 <lambdabot> forall a. a -> [[a]] -> [[a]]
21:22:10 <blackdog> is anyone going to be upset if i just scraped hackage.haskell.org?
21:22:44 <kmc> do you have to scrape? there's a machine-readable upload log and machine-readable cabal files for each package
21:23:26 <blackdog> scraping's the wrong word. something like  for f in `cabal list | grep \* | cut -f 2 -d \ `; do cabal fetch $f; done
21:25:19 <blackdog> kmc: just had a vague recollection of someone putting some work into automating local mirrors a bit more faithfully
21:28:14 <kmc> cool
21:28:17 <kmc> tell me if you find it?
21:28:34 <guest2425> kmc: can you help me out
21:28:56 <kmc> probably
21:28:58 <kmc> what's your question?
21:29:09 <guest2425> is a long question
21:30:03 <guest2425> kmc: this one http://pastebin.com/nzJNLSG8
21:30:23 <guest2425> kmc: I am getting that error message
21:32:20 <ddarius> djahandarie: You are right that a category object in the category End(C) wouldn't really work out, at least not nicely (or for arbitrary C.)  Better is probably a category enriched in End(C).
21:33:02 <kmc> urg
21:33:04 <ddarius> You could then internalize that construction and get a category object, but it wouldn't be in End(C).
21:33:06 <kmc> this extendedRecursionEngine nonsense
21:33:15 <guest2425> kmc: I know
21:33:26 <kmc> you should ask your professor to come to #haskell for a chat about it
21:33:38 <kmc> maybe we can talk them out of it, or maybe it's actually a great way to teach haskell and they can convince us
21:33:39 <kmc> anyway
21:33:59 <guest2425> kmc: that will be the best ever
21:34:15 <guest2425> kmc: him vs haskell channel
21:34:17 <guest2425> hahaha
21:34:58 <quintessence> guest2425: extendedRecursionEngine doesn't look like the sort of function a sane person would write, much less use (but don't tell him I said that!)
21:35:07 <guest2425> ok
21:35:09 <guest2425> hahahaha
21:35:10 <djahandarie> ddarius, hmm, okay. For the reason I said?
21:35:17 <SubStack> a recursion ENGINE eh?
21:35:19 <guest2425> he is not normal i guess
21:35:27 <SubStack> isn't haskell a recursion engine?
21:35:29 <djahandarie> quintessence, it's an ugly form of a powerful pattern
21:35:44 <kadoban> err, what numeric type do i want if i have to do `mod` and integer division? can't seem to get it right
21:35:59 <djahandarie> quintessence, a hylomorphism being the pattern
21:36:01 <SubStack> a haskell is a program that translates mathematics into computer programs
21:36:06 <Axman6> quintessence: i've told plenty of the students from that class they should shoot the lecturer for such ugly code
21:37:23 <kadoban> oh, nevermind, was using wrong operator..
21:37:45 <jaredj> the / vs `div`?
21:38:07 <kmc> @djinn (a -> Bool) -> (a -> b) -> (t -> [b] -> b) -> (a -> t) -> (a -> [a]) -> a -> b
21:38:07 <lambdabot> Error: Undefined type []
21:38:13 <djahandarie> はははは
21:38:15 <djahandarie> Whoops
21:38:16 <djahandarie> hahahaha
21:38:17 <kmc> @djinn List ()
21:38:17 <lambdabot> Error: Undefined type List
21:38:22 <djahandarie> Doesn't work kmc
21:38:33 <djahandarie> No recursive types
21:38:33 <kadoban> yeah, i forgot about div...hehe
21:38:39 <kmc> ah, right :/
21:38:47 <ddarius> djahandarie: A category object would have two objects, an object of objects and an object of arrows.  So a category object in End(C) would have two endofunctors.  You would have to encode the entirety of all arrows into one endofunctor.
21:40:15 <guest2425> kmc: any idea
21:40:19 <jaredj> guest2425: i'd start by giving names to all the lambdas you pass to extendedRecursionEngine
21:40:59 <guest2425> ok
21:41:04 <jaredj> comment out whatever doesn't work, run ghci on the remaining, and :t everything to see if it has the type you expect
21:41:37 <guest2425> jaredj: it has names
21:41:58 <jaredj> wha
21:42:16 <jaredj> no i mean all the lambdas in the definition of allPathsTo
21:42:17 <pygmalion> anyone have decent knowledge of parser writing with ReadP?
21:43:23 <quintessence> djahandarie: ah, I see (after looking it up) how that's kind of like a hylomorphism.  It just has enough extra parameters that what it does is no longer apparent from the type.
21:43:51 <Axman6> pygmalion: why not use something nicer like parsec?
21:44:16 <ManateeLazyCat> Qiqi can you heard me?
21:44:22 <pygmalion> Axman6: assignment unfortunately
21:44:35 <djahandarie> ddarius, okay.
21:44:39 <guest2425> jaredj: what u mean?
21:44:50 <guest2425> *you
21:45:36 <jaredj> guest2425: you call the engine with a number of anonymous functions (\someargs -> athing)
21:46:14 <guest2425_> hello
21:46:19 <jaredj> olleh
21:46:20 <djahandarie> quintessence, yeah, it's like a hylomorphism with a natural transformation and some butchered maybe construct in it. None of which makes it any more powerful than a hylomorphism anyways
21:46:25 <guest2425_> kmc: Any guide
21:46:39 <kmc> guest2425_, no, sorry, it's too much for me to absorb
21:46:53 <guest2425_> i know
21:47:09 <ddarius> Seeing as how a language of hylomorphisms is Turing complete...
21:47:17 <guest2425_> kmc: for me too
21:47:18 <Eduard_Munteanu> Moreover it's a hylo that's not broken into digestible pieces
21:47:55 <ManateeAuthor> Any other manatee user at here?
21:48:03 <Eduard_Munteanu> And piling it up like that ruins all the fun and makes little sense
21:50:47 <guest2425_> kmc; I am getting crazy
21:50:59 <guest2425_> kmc: i am getting crazy
21:51:27 <LegendaryPenguin>  i need help, to develop a steam engine
21:51:28 <djahandarie> Repetition is a sign of craziness.
21:51:45 <djahandarie> LegendaryPenguin, maybe #trains would be better? :P
21:52:55 <jaredj> wait, guest2425_ - map (\path -> ...) pathss doesn't make sense
21:52:56 * kmc is quite disappointed to find nobody there
21:53:31 <guest2425_> jaredj: why?
21:53:48 <jaredj> if pathss is a [[Path]], and you map a function over it, the parameter to that function will be a [Path], not a Path
21:54:06 <guest2425_> ok
21:54:24 <guest2425_> jaredj: so i have that wrong
21:54:44 <guest2425_> ?
21:54:53 <jaredj> so if you said (\ parent pathss -> map (map (\path -> parent:path)) pathss)
21:55:09 <jaredj> i think it would typecheck. not sure if it would work
21:55:10 <guest2425_> yes
21:55:49 <ksf_> what's the story with epigram2 vs. idris?
21:55:56 <jaredj> that's what i've got, i have to sleep now, good luck
21:56:00 <ksf_> edwinb seems to be on the epigram team, too
21:56:13 <guest2425_> jaredj: why 2 maps
21:56:13 <djahandarie> I really like idris
21:56:20 <pumpkin> ksf: different goals
21:56:32 <djahandarie> Epigram is far more.. experimental
21:56:55 <jaredj> pathss is a [[Path]]. map a function f over it, f gets parameters of type [Path]
21:57:08 <ManateeAuthor> ivanm: Looks some user have use Manatee successful. :)
21:57:14 <jaredj> map (map f) over it, and f will get parameters of type Path
21:57:24 <guest2425_> ok
21:57:35 <guest2425_> jaredj: still not working
21:57:39 <jaredj> aw.
21:57:56 <jaredj> that's all i got
21:57:59 * jaredj off to bed
21:58:08 <ManateeAuthor> Bye all. :)
21:58:17 <ksf_> idris needs layout syntax and a module system
21:58:41 <djahandarie> idris needs to be a GHC extension
21:59:02 <ksf_> ...and I'm not at all comfortable with that :/:: switch.
21:59:36 <ksf_> can't we make lists use (,) when we're dependently typed, anyway?
22:01:07 <kmc> another dependently typed language?
22:01:08 <kmc> cool
22:01:25 <pumpkin> ksf_: how so?
22:01:26 <ksf_> why the ghc extension thing?
22:02:13 <djahandarie> It was a joke. Idris is very similar to Haskell and I'd like to just go ahead and use Haskell + dependent types. ;)
22:02:24 <ksf_> pumpkin, aren't lists arbitrary deeply nested tuples with the constraint that each car has the same type?
22:03:23 <ksf_> gragh /me hates yacc-style parsers
22:03:24 <pumpkin> ksf_: it's more of a data Moo a b = Moo a b | Nil, data List a = Fix (Moo a)
22:03:37 <pumpkin> but you can't write Fix in most DT languages
22:03:43 <pumpkin> at least not directly
22:03:51 <Eduard_Munteanu> What type system is that? Still something in the way of Martin-Lof?
22:04:02 <ksf_> it seems to have basic type inference
22:04:06 <pumpkin> what I just wrote is valid Haskell
22:04:13 <Eduard_Munteanu> I mean Idris.
22:04:15 <pumpkin> agda has type inference
22:04:20 <pumpkin> or fancy unification, at least
22:04:40 <ksf_> ...as in some definitions in the examples lack type decls
22:05:27 <Eduard_Munteanu> Well, maybe complete type inference is unsound.
22:05:46 <ksf_> ugh it's got a static list of operators
22:05:57 <ksf_> I bet it's undecidable.
22:06:07 <ksf_> ...dependent types being what they are.
22:06:11 <kmc> the reason you can't write Fix in DT languages is that they want a sound logic
22:06:33 <kmc> but you could do DT programming with an unsound logic, as long as you evaluate proofs at runtime, i.e. no type erasure
22:06:33 <Eduard_Munteanu> It's already undecideable fo rank-N
22:06:38 <ddarius> They can be sound with Fix, though it does take a little more work.
22:06:41 <Eduard_Munteanu> *for
22:06:45 <kmc> the cost/benefit tradeoff is different
22:06:47 <kmc> ddarius, how so?
22:07:38 <ksf_> hmmm mixfix syntax
22:08:25 <ddarius> The only threat of unsoundness due to non-termination (i.e. fix) is that you do something (like write to an array) based on a non-proof.  As you said, normalize your proofs and you won't have unsoundness.
22:08:34 <ksf_> if_then_else_ True c a = c
22:08:40 <ksf_> if_then_else_ False c a = a
22:09:11 <ddarius> (Though you could certainly have unsoundness without fix as well.)
22:09:17 <kmc> ddarius, it seems unsound at the C-H level too
22:09:19 <kmc> though*
22:09:35 <kmc> you can write terms whose types are not valid sentences of logic
22:09:39 <kmc> they just fail to have normal forms
22:09:55 * kmc resolves to maybe say C-H-dB
22:10:09 <ManateeLazyCat> Very cool, some friend has help me test Manatee in Gnome, works fine with all modules.
22:10:40 <ManateeLazyCat> Now figure out why XMOnad can't work, i doubt dbus-daemon and dbus-launch not running in XMOnad.
22:11:04 <ManateeLazyCat> Then cause Manatee can't send/receive DBus message, anyway install XMonad to test.
22:15:29 <ksf_> gragh what am I thinking about, the obvious solution is of course to normalise syntax to sexprs.
22:16:24 <ksf_> (fixty (Int) (define solution 42))
22:17:43 <endojelly> I spent the whole night messing around with continuations
22:18:02 <kmc> :D
22:18:04 <kmc> in Haskell?
22:18:17 <endojelly> yep!
22:18:22 <endojelly> continuation monad
22:18:27 <kmc> fun times
22:18:36 <kmc> did you write Peirce's Law?
22:18:46 <endojelly> which is somehow even worse because the types can get pretty unwieldy
22:18:53 <endojelly> heheh, no
22:19:31 <endojelly> well, I did, in types
22:19:32 <kmc> try it ;)
22:19:34 <kmc> yeah
22:19:52 <kmc> rather, did you try writing the Law of Excluded Middle using callCC aka Peirce's Law?
22:20:05 * hackagebot vector-fftw 0.1 - A binding to the fftw library for one-dimensional vectors.  http://hackage.haskell.org/package/vector-fftw-0.1 (JudahJacobson)
22:20:15 <endojelly> kmc, I didn't, did you?
22:20:19 <ksf_> endojelly, re-implement the continuation section of Advanced Programming Language Design?
22:20:21 <kmc> yeah
22:20:28 <kmc> it's a cute trick, want me to show you?
22:20:40 <endojelly> ksf_, don't know that, but I did re-implement continuations etc.
22:20:42 <endojelly> kmc, yeah!
22:21:01 <kmc> so you know what i'm talking about with Curry-Howard Isomorphism applied to callCC, Peirce's Law, etc.?
22:21:06 <endojelly> ksf_, and tried a good lot with them, came across some really strange things 8)
22:21:10 <endojelly> kmc, yes!
22:21:27 <endojelly> kmc, I know a bit of Agda, so I know what CHI is
22:21:36 <kmc> so let's ignore Cont monad for a sec, and pretend we have first-class continuations
22:21:43 <kmc> LEM would be Either a (a -> b)
22:22:14 <kmc> for every proposition a, either a is true, or a is false (in which case it proves everything)
22:22:25 <razvandimescu> multiply x 1 = x
22:22:25 <razvandimescu> multiply x y = x+multiply x y-1
22:22:25 <razvandimescu> why does this function return a stack overflow
22:22:37 <endojelly> kmc, okay, yeah
22:22:47 <kmc> and this isn't constructively valid
22:23:01 <kmc> but Peirce's Law aka callCC is an axiom which gives us classical logic
22:23:08 <kmc> so, let's invoke it:
22:23:17 <kmc> callCC $ \k → ...
22:23:21 <kmc> we've captured the continuation k
22:23:33 <kmc> now, we assert that a is false:
22:23:44 <kmc> callCC $ \k → Right $ \x → ...
22:23:44 <ksf_> endojelly, http://www.nondot.org/sabre/Mirrored/AdvProgLangDesign/  chapter 2 page 43ff
22:23:55 <kmc> "a is clearly false, if it were true you could..."
22:24:00 <ksf_> (or rather 17ff)
22:24:06 <kmc> callCC $ \k → Right $ \x → k . Left $ x
22:24:13 <kmc> "a is clearly false, if it were true you could go back in time and claim it's true instead!"
22:24:27 <kmc> :t callCC $ \k -> return . Right $ \x -> k . Left $ x
22:24:28 <lambdabot> forall b (m :: * -> *) a. (MonadCont m) => m (Either a (a -> m b))
22:24:37 <endojelly> heh
22:24:42 <endojelly> that's neat
22:24:44 <kmc> :D
22:24:48 <kmc> it's real cheeky
22:25:42 <endojelly> cool
22:26:00 <ksf_> razvandimescu, because you're building up a term like a + b + c + d + multiply ...
22:26:10 <endojelly> ksf_, thanks, I'll take a look!
22:26:45 <ksf_> to evaluate the first +, it has to go down the whole rabbithole.
22:28:43 <markspezzano_> I'm running Mac OS X Snow Leopard. I've done a "sudo cabal install gtk --global" on my system, and it warns me that "file was built for unsupported file format which is not the architecture being linked (i386)". What does this refer to?
22:28:47 <ksf_> you want to introduce an accumulator.
22:29:48 <markspezzano_> I can't link anything to gtk
22:30:05 <ksf_> multiply x y = mult y acc where mult 1 acc = acc, mult n acc = mult (n-1) (acc+n)
22:31:06 <ksf_> (if there's a haskell tutorial which doesn't explain this that tutorial ought to be fixed)
22:33:05 <Eduard_Munteanu> That forgets 'x'.
22:33:22 <ksf_> yeah.
22:33:29 <ksf_> it's (acc + x)
22:33:35 <ksf_> and the first call is mult y 0
22:34:10 <ksf_> still, I did _mean_ the right thing .oO( ... )
22:35:24 <Eduard_Munteanu> markspezzano_: hm, perhaps you ended up with an x86-64 lib, or PPC? I'm not really familiar with Mac, but perhaps you could readelf the resulting file and see what it is.
22:35:43 <ksf_> or mult y x and stop at two.
22:36:11 <Eduard_Munteanu> Yeah, an accumulator is really needed here.
22:36:26 <Eduard_Munteanu> Or he could use a fold.
22:36:34 <ksf_> or *
22:36:35 <Eduard_Munteanu> (fold' )
22:36:45 <Eduard_Munteanu> Heh
22:36:48 <ksf_> @src foldl'
22:36:48 <lambdabot> foldl' f a []     = a
22:36:48 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
22:37:20 <ksf_> ' won't be necessary though, as + by itself is strict.
22:37:35 <ksf_> but yes, fold does the accumulating.
22:37:50 <endojelly> + is strict?
22:37:59 <ksf_> at least for primitive types, yes.
22:38:05 <endojelly> ah
22:38:06 <markspezzano_> Eduard_Munteanu: yeah I thought that might be the case...x86-64 bit library. Don't know how to fix it. I just did an install as per usual for gtk but it's stopping me from installing tools like threadscope and hp2any-manager etc
22:38:20 <endojelly> I was getting worried %)
22:38:30 <ksf_> it might make sense to make it lazy for peano numbers, with infinity = succ infinity and everythnig.
22:39:00 <Eduard_Munteanu> markspezzano_: are you using the platform?
22:39:06 <markspezzano_> yes
22:39:25 <endojelly> speaking of peano numbers, it would be nice to have some rudimentary support for them at type level
22:39:59 <Eduard_Munteanu> endojelly: well you kinda do
22:40:03 <endojelly> supporting literals and at least + as a type family
22:40:11 <Eduard_Munteanu> Oh, heh.
22:40:26 <endojelly> Eduard_Munteanu, that's what I'm getting at: some syntactic sugar
22:41:10 <ksf_> wait according to bool.idr idris does have mixfix.
22:41:10 <endojelly> right now, if I'm not mistaken, I'm doing the old "data Zero; data Suc n; type One = Suc Zero; type Two = Suc One..." thing a lot... 8)
22:41:19 <Eduard_Munteanu> Speaking of that, pseudo-arbitrary Peanos would be nice...
22:41:33 <Eduard_Munteanu> As in having TH or something generating all your used Peanos.
22:41:51 <endojelly> but peano number types are really useful, even in real life.
22:41:56 <ksf_> Eduard_Munteanu, there's fromIntegral
22:42:14 <Eduard_Munteanu> ksf_: for Peanos? :))
22:42:20 <ksf_> just imlement all the Num shebang for them.
22:42:35 <endojelly> just yesterday I encoded the duration of a monad into a type
22:42:35 <Eduard_Munteanu> endojelly: yeah, it eliminates bounds checking at compile time for example AFAIK
22:43:04 <ksf_> or even better, just do a hardware-accelerated Natural type with a view that gives you the succ thing.
22:43:09 <endojelly> it wouldn't type check if the sum of its components' duration was off
22:43:41 <Eduard_Munteanu> ksf_: well how would you write 628 and get Succ . Succ . Succ <628 times> . Zero without rank-2 types?
22:43:51 <ksf_> oh you're speaking about the type level.
22:43:55 <endojelly> yes
22:43:57 <Eduard_Munteanu> Well of course.
22:44:06 <Eduard_Munteanu> The other Peanos aren't that fun :P
22:44:17 <ksf_> there's a hackage package implementing base-10 arithmetic on the type level.
22:44:34 <Eduard_Munteanu> Up to what number? :D
22:44:47 <ksf_> so you go (I1 .: I4 .: ()) or something.
22:45:15 <endojelly> that's cool, but some compiler support would be nice
22:45:21 <ksf_> YES IT WOULD
22:45:29 <ksf_> it's an open feature request for ages now
22:45:37 <endojelly> I don't want the whole dependent types after all 8)
22:45:54 <Eduard_Munteanu> Hm, I wonder how .: looks like wrt types
22:45:59 <ksf_> another thing is typecast and typeeq
22:46:06 <ksf_> make that :.
22:46:12 <endojelly> ksf_, what is that?
22:46:20 <ksf_> a valid type-level operator.
22:46:39 <endojelly> what does it do?
22:46:46 <ksf_> usually something list like.
22:46:47 <Eduard_Munteanu> Is it type-level?
22:47:01 <endojelly> ksf_, know, I mean typecast and typeeq
22:47:05 <endojelly> not :.
22:47:07 <ksf_> yes, sure, it starts with an uppercase . (i.e. :)
22:47:32 <endojelly> ksf_, and I mean 'no' instead of 'know' 8)
22:48:33 <ksf_> endojelly, it's a oleg hack used to select different typeclasses by type equality, which gets rid of a shebang of overlappingInstances stuff.
22:48:58 <endojelly> sounds interesting
22:49:00 <Eduard_Munteanu> Hm, how do these work? You have a class like (.:), defined a bit like 'class (.:) a b' ?
22:49:06 <ksf_> but maybe a typeclass/typefun overhaul is a better idea than adding that hack to the compiler itself.
22:49:25 <endojelly> anyway. have to take a show and go to work. laters.
22:49:46 <endojelly> a shower, not a show. what's wrong with my typing today...
22:49:46 <ddarius> You really, really don't want to use Peano numbers for pretty much anything.
22:49:48 <ksf_> it's also and foremost, utterly unportable because it relies on how the typechecker resolves constraints.
22:50:24 <ksf_> Eduard_Munteanu, nah they're just semantic sugar for tuples.
22:50:37 <ksf_> data Tup a b = a :. b 
22:50:39 <Rotaerk_> I'm going nuts with point-free style...
22:50:44 <Rotaerk_> approaching the point of unreadability
22:51:13 <Eduard_Munteanu> Rotaerk_: what don't people do to touch (.) (.)
22:51:27 <Rotaerk_> lol
22:52:41 <Eduard_Munteanu> ksf_: oh, I assumed it went in typeclass constraints.
22:53:44 <Eduard_Munteanu> ksf_: so basically how would that ever resolve to a Peano? Unless you mean take it as 'Add a b' and leave it at that.
22:55:24 <Eduard_Munteanu> I'd at least like to have an equality operator for that.
22:56:36 <ksf_> well, the point is _not_ to use peano.
22:56:44 <Eduard_Munteanu> :)
22:56:48 <ksf_> but you could easily do a mapping via type families.
22:57:15 <Eduard_Munteanu> What else then? I've seen a few things on Hackage that use them, for stuff like bounds checking for example
22:57:48 <ksf_> "idris: Nothing to rename"  is all idris ever says here.
22:57:48 <Eduard_Munteanu> Hm, I think type families make sense.
22:58:19 <ksf_> ...no repl no nothing.
22:59:18 <Eduard_Munteanu> ksf_: how far is Idris really? The mission statement is quite a lot for a dependently-typed _programming_ language.
22:59:45 <ksf_> well I had a version running once, and it was quite useable.
23:00:27 <Eduard_Munteanu> ksf_: are they going for a total language like Agda or not? It's not really clear to me.
23:00:45 <Eduard_Munteanu> Usable total _programming_ languages sounds like a lot.
23:01:34 <ksf_> idris is not like agda because it comes with a theorem assistant.
23:03:10 <ksf_> the bug must be in ivor, the idris source doesn't contain that string.
23:11:55 <Eduard_Munteanu> > head []
23:11:56 <lambdabot>   *Exception: Prelude.head: empty list
23:12:14 <Eduard_Munteanu> Hm... the bug must be in Prelude, I never typed that message :P
23:12:48 <ksf_> well, that's a charm, idris bails out as soon as it comes across a proof script.
23:19:25 <shepheb> I was a little surprised to see the page on Type Families on the wiki use the word "legit"
23:20:23 <shepheb> "Data and newtype instance declarations are only legit when an appropriate family declaration is in scope - just like class instances require the class declaration to be visible."
23:21:22 * hackagebot manatee 0.0.4 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.4 (AndyStewart)
23:24:55 <Cale> http://www.youtube.com/watch?v=zE5wBUINsfo :)
23:25:03 <Cale> (Magnet related, not Haskell)
23:25:35 <Rotaerk_> http://rotaerk.pastebin.com/JCVYeuTj  >_<
23:27:03 <Saizan> Rotaerk_: is that sintax for type signatures still allowed?
23:27:29 <Rotaerk_> this is F#
23:28:06 <Rotaerk_> << is .
23:50:29 * hackagebot buildbox 1.3.0.0 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.3.0.0 (BenLippmeier)
23:51:29 * hackagebot buildbox-tools 1.3.0.0 - Tools for working with buildbox benchmark result files.  http://hackage.haskell.org/package/buildbox-tools-1.3.0.0 (BenLippmeier)
23:55:30 * hackagebot buildbox-tools 1.3.0.1 - Tools for working with buildbox benchmark result files.  http://hackage.haskell.org/package/buildbox-tools-1.3.0.1 (BenLippmeier)
23:55:32 * hackagebot buildbox 1.3.0.1 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.3.0.1 (BenLippmeier)
