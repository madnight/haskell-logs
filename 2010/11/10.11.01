00:09:09 <ManateeLazyCat> blekko.com is awesome, just search *real* useful page for you. :)
00:21:39 <lars9> it's a little bit off topic, but how can i let my irssi identify my ID automatically? i need to /msg NickServ every time...
00:22:44 <shachaf> lars9: You might have better luck asking in #irssi, where it's not off-topic.
00:23:04 <lars9> shachaf: you are right, thanks
00:25:42 <kmc> or it's explained on the first google result for:  irssi nickserv
00:28:03 <xiackok_> @hoogle find
00:28:03 <lambdabot> Data.ByteString find :: (Word8 -> Bool) -> ByteString -> Maybe Word8
00:28:03 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
00:28:03 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
00:57:26 <cads_> hey, what's it mean that my Tree type has kind * -> *, and why does this prevent me from being able to instantiate it as a member of Eq?
00:58:00 <wce> /?
00:58:03 <cads_> I have Tree a = EmptyTree | Node a [Tree a]
00:58:38 <cads_> and I'm trying to do   instance Eq (Tree a) where EmptyTree == EmptyTree = True
00:58:48 <cads_> just to start building the equality function
00:59:21 <cads_> oh, wait
00:59:26 <cads_> one sec
00:59:34 <cads_> the error might be from something else.
01:00:10 <cads_> it was.
01:02:38 <mornfall> What's Node 0 [EmptyTree] in that case? :)
01:03:29 <cads_> Node 0 [] = Node 0 [EmptyTree] = Node 0 [EmptyTree, EmptyTree] = ...
01:03:59 <cads_> but the first form is the normal form
01:05:18 <Saizan> cads_: Tree :: * -> *, means that Tree constructs a type that can have values if you provide it a likewise argument
01:05:50 <cads_> and I was using it like this :  treeMax :: Ord a => Tree
01:06:09 <cads_> where I meant to say treeMax :: Ord a => Tree a -> a
01:06:38 <cads_> it was one of three changes I made, but I forgot about it, so I assumed the error had to do with the equals definition
01:06:42 <cads_> ever do that?
01:06:47 <xiackok_> how can i use maybe function? 
01:06:57 <Nibble> xiackok_: afaik, maybe is a type
01:07:14 <Saizan> cads_: yeah, it happens :)
01:07:18 <cads_> xiackok_,  Maybe "you can", or maybe Nothing
01:07:20 <xiackok_> Nibble, i know but there is a maybe function
01:07:34 <Saizan> > maybe 0 (+1) (Just 4)
01:07:35 <lambdabot>   5
01:07:40 <Saizan> > maybe 0 (+1) Nothing
01:07:40 <lambdabot>   0
01:07:44 <xiackok_> Saizan, thanks
01:07:55 <cads_> oh nice
01:08:01 <dmead> :t maybe
01:08:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
01:08:09 <dmead> smeh
01:08:40 <cads_> it's like some kind of groovy demaybfying function that probably has a name in CT
01:08:56 <cads_> de-maybefying*
01:09:16 <dmead> :t indent
01:09:17 <lambdabot> Not in scope: `indent'
01:09:32 <lars9> how to do sed-like string substitude in haskell?
01:09:55 <Saizan> cads_: it's the catamorphism, even it's a bit weird since Maybe is not a recursive type
01:11:22 <cads_> hmm, it has a closely analagous type to the list fold
01:11:36 <lars9> i need 'backward reference' like s/(1.3)(a.c)/\2\1/
01:11:48 <cads_> just replace the Maybe contstructor with []
01:12:11 <lars9> \2 refers to (a.c), \1 refers to (1.3)
01:12:17 <cads_> Saizan, is the catamorphism universal or free in some way?
01:12:28 <cads_> actually, lemme look it up
01:14:58 <Saizan> well, you know that all functions of type "Maybe a -> b" can be written as "maybe n j" for some n and j
01:14:58 <FunctorSalad_> cads_: it's the mediating arrow for the universal property of Maybe
01:15:21 <cads_> it's the unique homomorphism from an initial algebra into another algebra
01:15:29 <FunctorSalad_> cads_: for fixed A, let F X := 1 + A
01:15:35 <cads_> oh cool
01:16:22 <FunctorSalad_> hmm. wait ;)
01:16:37 <FunctorSalad_> I'm confused by the non-recursiveness ;)
01:16:44 <FunctorSalad_> Maybe is supposed to be an F-algebra now
01:17:19 <FunctorSalad_> a right, the algebra law (of type F (Maybe A) -> (Maybe A))) is basically just the identity
01:18:09 <FunctorSalad_> so anyway, the universal property is that for every (F Y -> Y), there's a unique F-algebra morphism from above algebra to the (F Y -> Y) algebra
01:18:18 <FunctorSalad_> which is given by 'maybe'.
01:19:12 <FunctorSalad_> as you already said essentially ;)
01:21:24 <Saizan> it's confusing  because "F Y -> Y" here reduces to "(1 + A) -> Y"
01:21:46 <FunctorSalad_> yes :) which is isomorphic to the pair of args to maybe
01:22:17 <FunctorSalad_> morally, at least ;)
01:22:49 <FunctorSalad_> nothing is every quiet isomorphic in seq land
01:22:52 <FunctorSalad_> *ever
01:28:32 <cads_> haha
01:29:37 <SeriouslyLaugh> Any ops, mods, founders, or admins in the house?
01:30:01 <Saizan> SeriouslyLaugh: called?
01:30:06 <SeriouslyLaugh> I'm an op in #reddit and i'm working off a list of reddit based channels to add to a "master list" that people can reference in irc.reddit.com.  I'd like to add this channel if its ok with you guys. 
01:31:23 <c_wraith> If people are looking for a channel about haskell, this is the place to be.  *shrug*
01:31:40 <SeriouslyLaugh> You can see the list here: http://www.reddit.com/r/irc/comments/dzeg0/
01:32:04 <SeriouslyLaugh> We get a lot of people asking, "What are some other channels that redditors frequent?"
01:32:26 <SeriouslyLaugh> So I figured I'd compile a list
01:32:56 <Saizan> the last time #haskell was advertised on reddit it wasn't a completely nice experience :)
01:33:19 <SeriouslyLaugh> no worries, I can remove you from the list if you would like
01:33:34 <cads_> hey, what should I write a data declaration as if I want a tree that can either be the empty tree, the single node tree, or the rooted tree that contains a number of either rooted or single node subtrees?
01:34:33 <c_wraith> so the reason you can't use the obvious formulation is that you don't want empty children of the rooted case?
01:35:15 <cads_> yeah, I've writting a sanitizing function that's called in the function's eq instance to make sure things are equivalent
01:35:25 <Saizan> SeriouslyLaugh: join #haskell-ops and ask there, so others will be able to give an opinion when they are active
01:35:52 <c_wraith> heh.  I wish I knew type hackery well enough to answer that.  I bet there is a type-level answer, though.
01:36:02 <cads_> and I'm thinking of calling sanitize from functions like size, which are sensitive to stuff like that otherwise
01:36:03 <SeriouslyLaugh> OK thanks Saizan 
01:36:17 <SeriouslyLaugh> take care guys
01:36:44 <blackdog> there's a haskell-ops channel?
01:36:51 <Saizan> yep
01:36:54 <blackdog> jeez, i thought we were all happy little indians
01:37:17 <dagle> Monads, not indians.
01:37:32 <blackdog> indians -> chiefs as monads -> +
01:37:33 <blackdog> ?
01:37:58 <dagle> Monads -> Functors ?
01:39:21 <Saizan> cads_: data NonEmptyTree a = Node a [NonEmptyTree a]; data Tree a = Empty | NE (NonEmptyTree a)
01:39:41 <Saizan> cads_: or you can merge those in a single GADT
01:40:49 <cads_> I just tried to write data Tree2 a = EmptyTree | Rootnode a [Rootnode a [Rootnode a [ Roo...]]
01:41:28 <cads_> I stopped myself at the second "Rootn..."
01:41:40 <cads_> and said, "Damn"
01:41:43 <Saizan> :D
01:43:35 <cads_> so now I'd pattern match against    NE (Node a []) and Ne(Node a children)
01:43:50 <cads_> how would merging work?
01:44:00 <FunctorSalad_> you can avoid the extra pattern match with the gadt Saizan mentioned
01:44:55 <Saizan> i was thinking of "data Tree k a where EmptyTree :: Tree Empty a; Node :: a -> [Tree NonEmpty a] -> Tree NonEmpty a
01:45:14 <FunctorSalad_> data Tree a phantom where { Node :: a -> [Tree NonEmpty] -> Tree NonEmpty; Empty :: Tree phantom }
01:45:24 <FunctorSalad_> data NonEmpty
01:45:40 <FunctorSalad_> data Tree a phantom where { Node :: a -> [Tree a NonEmpty] -> Tree a NonEmpty; Empty :: Tree a phantom }
01:45:44 <FunctorSalad_> corrected
01:46:03 <Saizan> that allows for "Node x [Empty]"
01:46:28 <FunctorSalad_> oh true. need another empty type data Empty
01:46:38 <FunctorSalad_> hmm
01:48:18 <cads_> Saizan, can you break that down informally into its working parts?
01:48:23 <FunctorSalad_> should have just read what you wrote before sending my own decl ;)
01:48:38 <cads_> oh
01:48:56 <cads_> you're declaring the types of the constructors
01:49:02 <Saizan> cads_: basically it marks the two constructors with different type level tags
01:49:15 <FunctorSalad_> what is merging here?
01:49:35 <Saizan> cads_: so you can exclude the unwanted one in the recursive occurrence
01:51:19 <cads_> oh, and the node constructor still carries node data in the first argument
01:51:21 <Saizan> by merge above i simply meant construct a single type that's isomorphic to the two i had given
01:51:33 <Saizan> cads_: yep
01:53:20 <lars9> quicksilver: hi
01:53:57 <shachaf> Is this function defined anywhere? f True x = x; f False _ = Nothing
01:54:21 <shachaf> @hoogle Bool -> a -> Maybe a
01:54:22 <lambdabot> Control.Exception assert :: Bool -> a -> a
01:54:22 <lambdabot> Control.OldException assert :: Bool -> a -> a
01:54:22 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
01:55:08 <Lemmih> shachaf: guard cond >> return x
01:55:15 <cads_> how would the pattern matches look like now.... before, I commonly pattern matched on 3 clauses:  f EmptyTree =, f (Node a []) =,f (Node a children) =, for example
01:55:49 <cads_> will the notation look different?
01:56:26 <FunctorSalad_> Saizan: I meant the 'merge' operation cads_ was asking about
01:56:48 <siim> is there a way to get data type's information to some variable. e.g. :t MyData <- I want this information to be saved 
01:56:54 <cads_> I mean, EmptyTree would still seem to match correctly
01:56:56 <FunctorSalad_> cads_: pattern matches on GADT look the same, but something funny is going on behind the scenes
01:57:09 <FunctorSalad_> a pattern match branch brings type-level equalities into scope
01:57:35 <shachaf> Lemmih: Oh, if only we had monad comprehensions.
01:57:35 <Lemmih> siim: show . typeOf.
01:57:40 <shachaf> Then you could write [x | cond]
01:57:54 <shachaf> I guess you can do listToMaybe [x | cond]
01:58:01 <FunctorSalad_> if you have f :: Tree k a -> Tree k a, then in the "f Empty" branch, you get the additional type context "k ~ EmptyTree"
01:58:16 <FunctorSalad_> assuming the Empty ctor has type "Tree EmptyTree a"
01:58:46 <Lemmih> siim: typeOf is from Data.Typeable.
01:59:08 <siim> thanks
02:00:22 <FunctorSalad_> cads_: a good way to understand this is the equality gadt: data Equal a b where Refl :: Equal c c
02:00:39 <FunctorSalad_> cads_: try to write a function cast :: Equal a b -> a -> b
02:00:43 <FunctorSalad_> :)
02:06:28 <cads_> gah
02:08:14 <cads_> do I need to declare Empty or NonEmpty as data types or so?
02:13:19 <FunctorSalad_> yes
02:14:12 <FunctorSalad_> you could as well use Int and Handle, but it'd be a bit obfuscated ;)
02:14:22 <FunctorSalad_> (they're just tokens)
03:03:16 <kayuri> Hi all. 
03:03:53 <kayuri> I've got an issue installing haddock-2.8.1 on Mac OS X. Could anybody point me to the right solution?
03:04:43 <solistic> kayuri: I'll try
03:04:57 <kayuri> Here is what I've got from cabal: 
03:05:20 <kayuri> cabal: cannot configure haddock-2.8.1. It requires ghc >=6.12 && <6.14
03:05:25 <kayuri> There is no available version of ghc that satisfies >=6.12 && <6.14
03:05:39 <kayuri> But ghc --version shows: The Glorious Glasgow Haskell Compilation System, version 6.12.3
03:06:06 <kayuri> Does it mean that I need 6.13? 
03:06:27 <dcoutts_> kayuri: no, it means your ghc library package is messed up
03:06:32 <solistic> kayuri: what says ghc-pkg list |grep ghc
03:07:53 <kayuri> (ghc-6.12.3)
03:07:58 <kayuri> (ghc-binary-0.5.0.2)
03:08:03 <kayuri> ghc-prim-0.2.0.0
03:09:08 <kayuri> This was for /Library/Frameworks/GHC.framework/Versions/612/usr/lib/ghc-6.12.3/package.conf.d:
03:09:30 <solistic> kayuri: hm, I think dcoutts_ is right, I'm no sure if I have the expertise to helpe you here :(
03:09:31 <kayuri> And for ~/.ghc/i386-darwin-6.12.3/package.conf.d:
03:09:43 <kayuri> I've got nothing
03:10:03 <dcoutts_> kayuri: run ghc-pkg check
03:11:07 <kayuri> That is what I've tried to do. But it does nothing. :(
03:12:32 <kayuri> With --verbose=2 it shows me only two lines with using cache: and paths I put above.
03:13:11 <dcoutts_> kayuri: if ghc-pkg thinks the ghc package is ok, then cabal should do the same, it uses the same info
03:16:52 <kayuri> Heh, but that is what I don't understand. Could it be because I have two package confs? I guess one is from the haskell-platform package.
03:18:22 <Saizan> it's normal to have 2 package confs, a global and a user one
03:18:44 <Zao> Yes.
03:19:01 <Saizan> a possible problem could be if cabal is finding some other ghc-pkg, from a different ghc installation
03:19:22 <Zao> nvm, misread Saizan's statement as a question.
03:20:16 <kayuri> OK, I don't know why but cabal install haddock, worked just fine :)
03:20:35 <dcoutts_> kayuri: what did you do before?
03:20:40 <dcoutts_> when it did not work?
03:20:54 <kayuri> I tried just to fetch, and it failed to configure it.
03:21:11 <kayuri> I did nothing except ghc-pkg check.
03:21:33 <kayuri> Anyway, thanks a lot for your help ;)
03:22:30 <meandyour1> hola. como estas todos?
03:25:47 <newbie> hello
03:25:50 <newbie> !list
03:26:11 <sipa> @help
03:26:11 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:26:37 <astroboy> I'm trying to compile the llvm examples but I get a linking error: http://hpaste.org/41023/llvm_linking_troubles
03:36:12 * osfameron has to write a story with a new magic system for his writing class homework.  I've written a system based on Monads... I'm wondering if I should post to haskell-cafe@ asking for homework help? ;-)
03:36:32 <Entroacceptor> new magic system?
03:37:09 <osfameron> as in, create the mechanics of a system of magic (how it works, what powers it, effects, limitations, etc.)
03:37:13 <tibbe> If I want to abstract over `Map a b` and (a -> b), can I do that with a type class?
03:37:33 <tibbe> (I actually want to abstract over Map Text Text and Text -> Text)
03:38:11 <Lemmih> tibbe: Yes.
03:38:25 <tibbe> Lemmih: what would the type class look like?
03:39:51 <tibbe> I tried:
03:39:51 <tibbe> class Context a where 
03:39:52 <tibbe>     lookup :: a -> T.Text -> T.Text
03:40:00 <merijn> Morning, my lambda loving friends.
03:40:04 <Lemmih> tibbe: class Map a b where map :: a -> b
03:40:08 <Entroacceptor> osfameron: I want to get see the finished work, maybe spawn a new RPG ruleset :)
03:40:28 <tibbe> Lemmih: but what if a and b are fixed?
03:41:01 <Lemmih> tibbe: class Map a where map :: a Text Text
03:43:09 <tibbe> Lemmih: and given a Text, how do I apply the map function?
03:43:18 <tibbe> map f someKey doesn't work
03:43:59 <merijn> To continue my streak of off-topic type theory: Am I correct in understanding that ECC's strong sum types are used to describe pairs whose second item can depend on the first item of the pair?
03:44:22 <tibbe> Lemmih: should that be: map :: a Text Text -> Text -> Text ?
03:44:43 <Lemmih> tibbe: It depends on what you want.
03:45:02 <Lemmih> tibbe: What you pasted above with 'lookup' looks like a perfectly good solution.
03:46:05 <tibbe> Lemmih: I can use lookup to get a 'a Text Text' but I have no way to apply that to a value of type Text
03:46:15 <tibbe> class Context a where 
03:46:15 <tibbe>     lookup :: a T.Text T.Text -> T.Text -> T.Text
03:46:18 <tibbe> lets me
03:46:48 <osfameron> Entroacceptor: well, if you're interested, https://docs.google.com/document/edit?id=10gb22lw0W1MDV5KLUF3FEjaIXAgoLv0lx7wJUDiYI3E&hl=en&authkey=CLDQ3poD  lemme know if you think it's worth posting to haskell-cafe@ ;-)
03:47:36 <Lemmih> tibbe: Lets you what? That code would work just fine.
03:47:39 <Entroacceptor> osfameron: I don't know about the eqiquette for -cafe
03:47:48 <tibbe>     renderFrag (Var x _) = lookup ctxFunc x
03:47:50 <tibbe> Lemmih: ^^
03:48:08 <Lemmih> tibbe: That looks good.
03:48:20 <tibbe> Lemmih: doesn't work with lookup :: a Text Text
03:48:36 <Lemmih> tibbe: No, of course not.
03:48:43 <tibbe> Lemmih: right
03:48:54 <tibbe> Lemmih: but could it be made to work with that definition of lookup?
03:48:59 <tibbe> or is that definition wrong?
03:49:21 <tibbe> I want to make [(Text, Text)] and (Text -> Text) instance of my type class
03:49:31 <tibbe> so the user can provide the Context as either a function or a "map"
03:49:44 <Lemmih> tibbe: It's not wrong. It just doesn't do what you want.
03:50:09 <Lemmih> tibbe: Use 'a T.Text T.Text -> T.Text -> T.Text' and you'll be fine.
03:50:12 <tibbe> Lemmih: ok
03:50:34 <tibbe> Lemmih: alright, now how do I make [(,)] an instance? it seems to require type level lambdas
03:51:00 <Lemmih> tibbe: Your original solution also works, btw, if you enable the right extension.
03:51:50 <Lemmih> tibbe: You can either use a newtype or use the -XFlexibleInstances extension.
03:52:03 <tibbe> instance Context [(,)] where
03:52:04 <tibbe> ??
03:52:10 <tibbe> and FlexibleInstances?
03:52:28 <tibbe>     `(,)' is not applied to enough type arguments
03:52:28 <tibbe>     Expected kind `*', but `(,)' has kind `* -> * -> *'
03:52:29 <tibbe>     In the instance declaration for `Context [(,)]'
03:52:30 <Lemmih> tibbe: newtype AssocList a b = AssocList [(a,b)]; instance Context AssocList where ...
03:54:14 <Entroacceptor> osfameron: mh, I like it
03:54:31 <osfameron> yay! ;-)
03:54:45 <tibbe> Lemmih: having to use a newtype kinda ruins it though
03:55:22 <osfameron> Entroacceptor: I don't suppose it's especially accurate on the FP side of things, but what there is seems to work quite well with Magic, I hoped
03:55:24 <Lemmih> tibbe: Then use: class Context a where lookup :: a -> Text -> Text
03:55:46 <tibbe> the reason i wanted this is because 'substitute "Hi, $name!" [("name", "Lemmih")]' is shorter than 'substitute "Hi, $name!" $ flip lookup [("name", "Lemmih")]'
03:56:50 <tibbe> Lemmih: ah, and that requires FlexibleInstances, I see
04:12:57 <Mitar> there is really no floating-point mod operator in haskell?
04:16:02 <merijn> Mitar: mod as in modulo?
04:16:19 <Mitar> remainder of devision
04:16:19 <Mitar> yes
04:16:40 <merijn> Mitar: Why would that exist in any language? That makes no sense whatsoever
04:16:58 <merijn> Floating point division doesn't have a remainder...
04:17:53 <Lemmih> > let fmod x y = x - n * y where n = fromIntegral $ floor (x/y) in fmod 10 3.1
04:17:54 <lambdabot>   0.6999999999999993
04:18:20 <Lemmih> My memory might be flawed but I think it goes something like that.
04:19:02 <Mitar> i have two floating-point angles in radians, and i would like to get difference between them in [0, 2pi] range
04:19:20 <Mitar> so my idea was to compute difference, add 2pi and mod by 2pi
04:19:41 <zygoloid> > Data.Fixed.mod' 4.1 2.8 -- Mitar
04:19:41 <lambdabot>   1.2999999999999998
04:21:06 <quicksilver> merijn: real math "modulo 2pi" makes as much sense as integer math "modulo 7"
04:21:18 <tibbe> Does FlexibleInstance affect type inference?
04:21:27 <tibbe> I have a type I thought should be inferred automatically but isn't
04:21:32 <quicksilver> and real math "modulo 2pi" has a natural interpretation as a representation of S1 on R
04:21:46 <quicksilver> which is what Mitar is doing.
04:22:44 <zygoloid> tibbe: no, i don't believe it affects anything other than the rules for which instances are accepted
04:23:31 <zygoloid> (you can import instances which can only be defined with FlexibleInstances, even if your module is not compiled with FlexibleInstances enabled)
04:24:43 <Lemmih> tibbe: The first argument to 'lookup' can't be inferred.
04:24:54 <tibbe> Lemmih: that's what I'm seeing
04:25:01 <tibbe> No instance for (Context [(t, t1)])
04:25:10 <tibbe> Even though I'm passing: [("name", "Joe")]
04:25:24 <tibbe> If I add [("name" :: Text, "Joe" :: Text)] it works
04:25:27 <Lemmih> tibbe: Using OverloadedStrings I take it?
04:25:31 <tibbe> I'm using OverloadedStrigns
04:25:33 <tibbe> yes
04:25:52 <tibbe> do I need a functional dependency?
04:26:22 <quicksilver> you need a different language.
04:26:26 <Lemmih> tibbe: Nope, you can't get around that.
04:26:33 <quicksilver> it will never "guess" which IsString instance you want
04:26:37 <tibbe> Lemmih: that's unfortunate.
04:26:38 <quicksilver> based on what other instances are handing around
04:26:48 <tibbe> :(
04:26:54 <quicksilver> instance selection is never directed by the presence of other instances
04:27:10 <tibbe> I guess I need to give up on my nice string interpolation syntax
04:27:17 <tibbe> I had it down to "Hello, $name!\n" % [("name", "Joe")]
04:27:38 <tibbe> but I can't get that to work without type annotations, which ruins the niceness
04:27:52 <quicksilver> is it really worth having short strings as Text?
04:27:59 <quicksilver> String is pretty good for short strings isn't it?
04:28:09 <quicksilver> especially short strings which are only used once
04:28:16 <tibbe> quicksilver: the short string gets spliced into the template
04:28:22 <tibbe> quicksilver: which is a lazy Text
04:28:52 <tibbe> quicksilver: besides, String is not very good for Unicode as it doesn't define many interesting functions (like toLower)
04:29:26 <Jafet> > let pf x b = let d = floor (x/b) in (d, x-b*fromIntegral d); showAtBase b n = splitAt (floor(log n/log b)+1) $ dropWhile (==0) $ unfoldr (\x -> let (i,r) = pf x b in Just (i,r*b)) n in text $ (\(i,f) -> (show=<<i) ++ "." ++ (show=<<(take (floor(53*log 2))f)) ++ "...") $ showAtBase (exp 1) pi -- merijn: pi in base e
04:29:27 <lambdabot>   10.101002020002111120020101120001010202...
04:30:40 <Lemmih> > toLower 'Λ' == 'λ'
04:30:41 <lambdabot>   True
04:30:48 <Lemmih> tibbe: toLower seems to work fine.
04:33:18 <quicksilver> you could have instance (IsString a) => Context [(a,a)], I think
04:33:34 <quicksilver> but basically, overloaded literals are fundamentally incompatible with overloaded functons.
04:33:37 <byorgey> > map toLower "Λ" == "λ"
04:33:38 <lambdabot>   True
04:33:51 <quicksilver> because what you really want is for the compiler to 'guess the best', and it can't do taht.
04:34:27 <quicksilver> I always had misgivings about the overloaded literals in OverloadedStrings
04:34:33 <merijn> Jafet: But base X is not the same as mod X
04:34:41 <Jafet> Overload fixity too, and all will be well
04:36:31 <merijn> Anyhoo, to try my type theory question again: Am I correct that the goal of ECC's strong sum types is to describe pairs where second item's type can depend on the first item of the pair?
04:39:02 <FunctorSalad_> quicksilver: which misgivings? It's very practical for alternative string types, at least (though I haven't checked how it deals with non-ASCII for BS)
04:39:02 <Jafet> merijn: only because you have a narrow preconception of mod. pf in that snippet above might define a generalization of mod
04:39:14 <FunctorSalad_> quicksilver: but it is possible to abuse it ;)
04:40:21 <byorgey> merijn: I'm not familiar with ECC, do you have a link?
04:40:23 <sipa> > map toLower "Λ"
04:40:24 <lambdabot>   "\955"
04:40:25 <FunctorSalad_> (I guess a sign of that would be when you start manipulating the input strings programmatically ;))
04:40:42 <FunctorSalad_> @ty "bah"
04:40:43 <lambdabot> [Char]
04:41:34 <merijn> byorgey: Luo's Extended Calculus of Constructions, paper is here: http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.40.5883
04:41:37 <quicksilver> FunctorSalad_: the misgivings I just outlined.
04:41:55 <FunctorSalad_> ah
04:42:01 <quicksilver> FunctorSalad_: that overloading on literals (i.e. return type) and overloading on function argument type is fundamentally incompatible
04:42:13 <quicksilver> inherently ambiguous, it therefore requires annotations
04:42:15 <byorgey> merijn: pairs like you describe (where the type of the second item can depend on the first item) are often known as "Sigma types", or "dependent sums", or sometimes (confusingly) "dependent products"
04:42:26 <merijn> Jafet: I concede modulo could be generalized like that
04:42:31 <quicksilver> and the annotations are more verbose than a simplyname conversion functor.
04:42:34 <FunctorSalad_> quicksilver: but that seems to be a general typeclass thing. like read . show
04:42:41 <quicksilver> FunctorSalad_: it is, yes.
04:42:48 <FunctorSalad_> (not the fault of the syntactic extension)
04:42:49 <byorgey> actually, I guess it's "dependent sums" which is confusing
04:43:00 <quicksilver> FunctorSalad_: it is a general typeclass thing from which I deduce the following guideline "Do Not Overload Literals"
04:43:00 <merijn> byorgey: Ah, those are the same I think
04:43:18 <FunctorSalad_> byorgey: haha yes. "well, they're actually more like products. and the products are actually more like functions" ;)
04:43:28 <merijn> byorgey: The paper also names "strong sum types" as "capital sigma-types".
04:43:35 <FunctorSalad_> (understanding it as "binary" once and "indexed" the other time)
04:43:42 <quicksilver> FunctorSalad_: ... you will note that the only overloaded literals in the language standard is Num, and they are only workable due to the massive hack ^W^W feature called 'defaults'
04:44:07 <FunctorSalad_> :)
04:44:11 <merijn> byorgey: Which I'll take as an indication that I understood it correctly :>
04:44:52 <quicksilver> putStrLn ("hello world" :: Text)
04:45:03 <FunctorSalad_> quicksilver: hmm I wonder whether the 'guess the best' you mentioned should actually be implemented ;)
04:45:05 <quicksilver> I mean, I guess it has the merit of being specific.
04:45:13 <FunctorSalad_> with goodness annotations
04:45:19 <quicksilver> but why not just say T.putStrLn "hello world"
04:45:26 <quicksilver> or putStrLn (t "hello world")
04:45:37 <byorgey> merijn: yes, I assume the dependency is the meaning of the "strong" part; presumably "weak" sum types would be like Haskell's Either
04:45:46 <quicksilver> neitehr of which requires overloaded literals.
04:45:55 <byorgey> although I have not read it (but I probably should)
04:46:01 <quicksilver> actually, the first one does.
04:46:11 <quicksilver> FunctorSalad_: "guess the best" is incompatible with the open world assumption thouhg.
04:46:34 <FunctorSalad_> as long as you don't want pseudorandom semantics at least, I guess ;)
04:46:53 <FunctorSalad_> (it'd be brittle against compiler changes too)
04:46:57 <quicksilver> right.
04:47:06 <FunctorSalad_> (if the "goodness" is heuristic)
04:47:19 <quicksilver> I suppose if they were in fact all semantically equivalent and the consequence of guessing wrong was only space/time issues
04:47:23 <merijn> byorgey: But haskell's Either uses the (*,[]) rule (* -> * -> * : []), which is already in the CoC, so that wouldn't be an extension.
04:47:30 <quicksilver> then perhaps it wouldn't be a disaster
04:50:40 <zygoloid> you can get string literals to default to Text by turning on ExtendedDefaultRules and adding a 'default (Text)' statement to your module
04:50:40 <quicksilver> on the other hand, if the space/time issues didn't matter, why are you bothering with Text?
04:50:55 <quicksilver> and if they did matter, well, it would matter.
04:51:05 <quicksilver> zygoloid: that's a good point, I forgot about ExtendedDefaultRules
04:51:11 <quicksilver> I'm not sure if that's a good solution or not.
04:51:22 <quicksilver> maybe that's a good solution to tibbe's requirements, at least
04:51:24 <quicksilver> tibbe: did you see that?
04:51:47 <quicksilver> zygoloid: ExtendedDefaultRules got a bad name for me when they started defaulting stuff to (), which is just stupid.
04:52:01 <quicksilver> zygoloid: I therefore blocked them out of my mind, forgetting there might be more sane ways to use them :)
04:52:26 <zygoloid> yeah. the default default list seems to be a hack to make ghci work better, and nothing else ;(
04:52:56 <quicksilver> () is such an atypical type, too, so it's really annoying to default to it.
04:53:02 <quicksilver> @check \x y -> x == y
04:53:03 <lambdabot>   "OK, passed 500 tests."
04:54:39 <FunctorSalad_> well, it seems like one of the least arbitrary types
04:55:02 <FunctorSalad_> I agree it's terrible for QC though
04:55:42 <zygoloid> Void seems less arbitrary than (). that'd at least stop quickcheck from passing spuriously ;)
04:55:58 <quicksilver> is Void an instance of Eq?
04:56:23 <quicksilver> :t let f x = (x :: Void == x) in t
04:56:23 <FunctorSalad_> you can't derive Eq for it for some reason
04:56:23 <lambdabot> Not in scope: type constructor or class `Void'
04:56:28 <zygoloid> is Void defined somewhere canonical, even?
04:56:31 <quicksilver> nope
04:56:36 <zygoloid> FunctorSalad_: presumably simply because it's not h'98?
04:56:50 <quicksilver> there is quite a lot of non-h98 stuff you can derive Eq for
04:56:54 <zygoloid> newtype Void = Void Void deriving Eq ?
04:56:56 <FunctorSalad_> zygoloid: hmm :)
04:57:04 <FunctorSalad_> I meant for the empty data decl
04:57:09 <byorgey> It's H'10 now though!
04:57:20 <quicksilver> I think I prefer "data Void"
04:57:23 <quicksilver> I'm not sure why
04:57:32 <byorgey> it's more obvious.
04:57:50 <quicksilver> newtype Void = Void Void has a coinductive member, doesn't it?
04:57:53 <zygoloid> me too, but you can't derive Eq etc for 'data Void' ;)
04:57:54 <FunctorSalad_> we once had a discussion here whether x == x = True or x == x = undefined in Void and someone actually had a convincing argument
04:57:55 <quicksilver> Void (Void (Void (Void (Void....)
04:57:58 <FunctorSalad_> but I forgot what it was :)
04:58:31 <quicksilver> FunctorSalad_: forall a :: Void, a == a is a provable statement.
04:58:43 <quicksilver> (because there are no 'a :: Void' so it's vacuously true)
04:59:02 <FunctorSalad_> uh, bottom?
04:59:12 <zygoloid> quicksilver: that answers the question for the strict fragment of haskell. but it doesn't specify how strict (==) itself should be
04:59:19 <FunctorSalad_> by using an ex quantifier you're going to the metalevel
04:59:19 <Jafet> Bottom is not a value of any type.
04:59:22 <quicksilver> agreed.
04:59:26 <FunctorSalad_> universal, even o_o
04:59:34 <quicksilver> Jafet: but it is the denotation of some terms
04:59:42 <FunctorSalad_> in denotational semantics, it usually is
04:59:45 <FunctorSalad_> @Jafet
04:59:45 <lambdabot> Unknown command, try @list
04:59:53 <quicksilver> Jafet: and within that conflict lies many of the misunderstandings of haskell
04:59:56 * zygoloid thinks it's more useful for (==) on Void to be _|_, since that means it's the right default for quickcheck.
05:00:03 <quicksilver> FunctorSalad_: denotation /= value
05:00:08 <quicksilver> that's the point, in some sense
05:00:19 <Jafet> Hm, it seems disorienting if you suddenly decide that (==) for Void should compare denotations
05:00:20 <quicksilver> (unless you choose to redefine one of those words...)
05:00:21 <zygoloid> (properties on a 'general' type should pass if they don't depend on any properties of the type at all)
05:00:41 <zygoloid> Jafet: you could argue it should compare normal forms ;)
05:00:57 <Jafet> > 0^0
05:00:57 <byorgey> hmm, when I try  newtype Void = Void Void  I get an error
05:00:58 <lambdabot>   1
05:01:01 <Jafet> Pah
05:01:24 <byorgey> oh, it's because I wrote  'newytpe' =P
05:01:26 <Entroacceptor> @check \x y -> (x::String)== y 
05:01:27 <lambdabot>   "Falsifiable, after 0 tests:\n\"\\923495\"\n\"\\872836\\254194\"\n"
05:01:55 <Jafet> Those aren't even supposed to be valid Strings.
05:02:09 <Jafet> > 0x110000
05:02:09 <lambdabot>   1114112
05:02:14 <Jafet> Okay, maybe they are.
05:03:05 <zygoloid> > toEnum 1114112 :: Char
05:03:05 <lambdabot>   *Exception: Prelude.chr: bad argument
05:03:11 <zygoloid> ^^ you can't construct an out-of-range Char
05:03:13 <FunctorSalad_> > ord maxBound
05:03:14 <lambdabot>   1114111
05:04:12 * FunctorSalad_ wonders what characters are legal in legal names
05:04:22 <FunctorSalad_> I mean, like, names in real life ;)
05:04:39 <zygoloid> i don't know of any countries who have moved to full unicode for legal names ;)
05:04:51 <FunctorSalad_> "it is my right to use an out-of-range Char in my child's name!"
05:05:00 * zygoloid can imagine there'd be vulnerabilities in various gov't software
05:05:21 * zygoloid waits for someone to post the inevitable xkcd link
05:05:30 <Jafet> Some chinese people invent new characters for their children, which is all fine until the government tries to punch it into a computer
05:05:31 <mornfall> :D
05:05:33 <quicksilver> I wonder if there are, in fact, laws about which characters you can use in names.
05:05:35 <FunctorSalad_> "drop database" isn't a character
05:05:49 <koala_man> not until unicode 7
05:05:54 <FunctorSalad_> :)
05:06:00 <quicksilver> can you legally, in the UK, name someone with a polish name using a stroked L, for example?
05:06:07 <quicksilver> I expect you can.
05:06:16 <quicksilver> can you legally name them in the klingon alphabet? Probably not.
05:06:17 <mornfall> quicksilver: Probably none, but the person making the birth certificate may tell you there ain't that character on his keyboard or something.
05:06:20 <quicksilver> btu I wonder who says so.
05:06:50 <Jafet> Are you really going to spend a good part of your life teaching your child how to use the klingon alphabet
05:07:27 <merijn> Jafet: There's people on this planet...
05:07:46 <Jafet> Be nice if you could name someone with an invalid UTF-8 byte sequence
05:07:54 <FunctorSalad_> merijn: reality stranger than fiction?
05:08:12 <Jafet> merijn, lojban? *cough*
05:10:23 <Jafet> "Hi, my name is double-UTF8-encoded little-endian byte order mark Robert, but you can just call me Bob."
05:11:37 <FunctorSalad_> :set nobomb
05:13:04 <FunctorSalad_> anyway, I wasn't aware that there's any distinction of 'value' and 'denotation', quicksilver 
05:13:26 <FunctorSalad_> (or actually, I don't know what exactly a 'value' is)
05:13:34 <zygoloid> "Hi, my name is GREEK SMALL LETTER LAMBDA U+03BB, but you can call me 3bobby"
05:14:04 <FunctorSalad_> I think bottom is a fine element, haskell just enforces monotonicity
05:14:04 <quicksilver> FunctorSalad_: I don't really know either.
05:14:13 <FunctorSalad_> (which explains why you can't pattern match against bottom etc)
05:14:29 <quicksilver> FunctorSalad_: but what I meant is that a value is a (mythical) thing in your object language
05:14:42 <FunctorSalad_> if Void was really empty, it should be impossible to construct a function into it
05:14:49 <FunctorSalad_> (random example)
05:14:50 <quicksilver> so when you write formulae about variables like a :: Int and so on, those are taking values.
05:15:01 <FunctorSalad_> (except *out* of Void)
05:15:11 <quicksilver> when you actually *interpret* them in a semantics, you're using a denotation.
05:15:28 <quicksilver> so value is a (woolly) proof-theoretic or type-theoretic notion, not a semantic one.
05:15:34 <quicksilver> I'm not sure if I'm making a useful point or not.
05:15:43 <FunctorSalad_> :)
05:16:02 <byorgey> "value" is often used to mean "well-typed normal form", i.e. it is an operational rather than denotational notion
05:16:48 <zygoloid> would that imply that _|_ is not a value, since it has no normal form?
05:17:02 <byorgey> indeed
05:17:07 <FunctorSalad_> quicksilver: there's probably some funny way to translate such formulae from Set to general categories with some structure, and then interpret that in whatever subcategory of PoSet is appropriate for haskell
05:17:21 <ibid> _|_ is not a value in an operational setting
05:17:24 <zygoloid> i could live with that. [0..] :: Integer not being a value would be unfortunate though.
05:17:27 <ibid> in a denotational setting is
05:17:31 <byorgey> _|_ is the denotation of some terms but it is not a value.
05:17:41 <ibid> +it
05:17:50 <byorgey> but yes, it depends on how you are using the words =)
05:18:11 <FunctorSalad_> (interpret variables as morphisms from the context to the domain of the variable etc)
05:18:25 <byorgey> zygoloid: why?
05:18:43 <zygoloid> why would it be unfortunate, or why would it not be a value?
05:18:49 <byorgey> why unfortunate
05:20:20 <zygoloid> because [0..] :: [Integer] seems reasonable operationally (as codata)
05:20:24 <ibid> zygoloid: [0..] is an operational value if you allow infinite values
05:20:35 <ibid> zygoloid: it's all about how you define the words :)
05:20:44 <FunctorSalad_> [0..] doesn't have bottom denotation anyway, does it
05:20:56 <FunctorSalad_> 'head' of it is not undefined
05:21:10 <FunctorSalad_> oh wait, that's nonstrictness ;)
05:22:23 <FunctorSalad_> but it's not observationally equivalent to bottom, anyway
05:22:34 <siim> Why isn't 'read' working with "Mydata 1 2" where MyData = MyData{ x::Int, y::Int } (it gives parse error); Howerver if I declare MyData this way: (MyData = MyData Int Int) read works perfectly?
05:22:57 <FunctorSalad_> siim: it expects record syntax
05:23:09 <FunctorSalad_> (I guess)
05:23:20 * zygoloid wonders why the derived Read doesn't accept either syntax
05:23:31 <FunctorSalad_> I was just guessing :)
05:23:37 <zygoloid> FunctorSalad_: your guess is correct
05:24:22 <zygoloid> there's the same weirdness with Read for String accepting "\"foo\"" but rejecting "['a']" (iirc ghc accepts both as an extension)
05:24:53 <FunctorSalad_> ghci> fromString [chr 1000] :: ByteString 
05:24:53 <FunctorSalad_> "\232"
05:24:55 <FunctorSalad_> that's pretty bad
05:25:12 <FunctorSalad_> shouldn't it use utf-8 instead?
05:25:20 <hpc> > 0o232
05:25:21 <lambdabot>   154
05:25:27 <zygoloid> > 1000 `mod` 256
05:25:28 <lambdabot>   232
05:25:41 <zygoloid> FunctorSalad_: which ByteString module did you import?
05:25:52 <FunctorSalad_> zygoloid: strict
05:26:08 <zygoloid> .Char8 or .UTF8?
05:26:13 <FunctorSalad_> the utf8 bytestring doesn't define its own type, just operations on it
05:26:16 <FunctorSalad_> AFAIK
05:27:25 <zygoloid> FunctorSalad_: i cannot reproduce your results. I get "\207\168"
05:27:29 <Funktorsalat> zygoloid: disco :(
05:27:31 <Funktorsalat> <zygoloid> .Char8 or .UTF8?
05:27:33 <Funktorsalat> <FunctorSalad_> the utf8 bytestring doesn't define its own type, just operations on it
05:27:35 <Funktorsalat> <FunctorSalad_> AFAIK
05:27:42 <Funktorsalat> so it couldn't make any diff for fromString
05:27:44 <Funktorsalat> I mean the IsString method, sorry :)
05:27:48 <Funktorsalat> fromString from .UTF8 works, yes
05:28:05 <Funktorsalat> just saying the IsString instance should use that, not pack
05:30:03 <dom96> Why is it fromString and not pack in .UTF8?
05:30:32 <ketil> fromString is in class IsString, isn't it?
05:30:39 <zygoloid> Funktorsalat: why should the ByteString /type/ assume the content is UTF-8?
05:30:52 <zygoloid> i don't think truncating is a sensible default either, fwiw
05:31:12 <Funktorsalat> zygoloid: because it's the de facto standard and any encoding is better than silent truncation? ;)
05:31:12 <Etherael> Is there a single authoritative Doc source for base haskell?
05:31:13 <zygoloid> but the ByteString type is supposed to be agnostic about the encoding of its content
05:31:27 <Etherael> + book recommendations anyone?
05:31:32 <Funktorsalat> zygoloid: yes, but OTOH IsString is supposed to be pragmatic ;)
05:31:34 <dom96> Wouldn't naming the function pack make it more portable with .Char8, i.e easier to change between the two?
05:31:40 <merijn> Etherael: The standard probably, but that's not really conducive to learning
05:31:48 <Funktorsalat> ketil: both
05:31:51 <merijn> Etherael: I take it you just started learning?
05:32:00 <Funktorsalat> ketil: (IsString method and function in .UTF8)
05:32:07 <hpc> the haddock for base, perhaps?
05:32:10 <zygoloid> Funktorsalat: well, perhaps if you're writing UTF-8 ByteString constants you're supposed to write them /in/ UTF-8? :)
05:32:17 <ketil> Funktorsalat, so two different fromStrings?
05:32:19 <hpc> if you're going to learn, don't start with docs though
05:32:40 <Etherael> merijn: Yep, first experience with functional programming, have been doing the other stuff for quite a long time, I figured the best way to grok the difference was to reverse engineer project euler haskell s olutions, I have a list but they look extremely foreign to me so I figured I might need some docs to make sense of them.
05:32:40 <zygoloid> Funktorsalat: (playing devil's advocate somewhat here, UTF-8 seems like a better compromise than truncation to me too)
05:32:48 <Funktorsalat> zygoloid: now *I'd* argue encoding-independence ;) I feed ghci Chars, not bits
05:32:52 <merijn> Etherael: For learning I would recommend starting with Learn You a Haskell (website only)
05:32:57 <hpc> ^
05:33:04 <merijn> Etherael: http://learnyouahaskell.com/
05:33:09 <hpc> also, pick a simple but interesting project to work on
05:33:21 <Etherael> eulers are simple and interesting. :)
05:33:23 <hpc> something small-to-medium sized, so you have to learn multiple things to complete it
05:33:27 <dom96> Or is the function named fromString just to differentiate between Utf8 and non-utf8 better?
05:33:36 <merijn> Then look at the more advanced chapters of "Real World Haskell", you could also start with Real World Haskell for the basics, but I preferred LYAH's style
05:33:48 <Etherael> longer term I have plans to do fingerprinting / matching of song files via the hubris ruby haskell gem
05:34:41 <Etherael> I'll start with lyah, thanks for the tip.
05:34:44 <merijn> Etherael: The examples at Project Euler are probably a lot more abstruse then needed :p
05:35:13 <Etherael> merijn: The first one I'm seeing looks like a stepped solution to the old gauss method, strikes me as kinda weird.
05:35:18 <Etherael> but Maybe I'm just misreading.
05:35:40 <Etherael> http://www.haskell.org/haskellwiki/Euler_problems/1_to_10 <-- 1 that is iterate through and add manually right?
05:36:53 <merijn> Etherael: That's what I meant, those examples are really hard to read if you don't get the syntax yet :p
05:37:14 <hpc> there's a nicer example of that you might like better
05:37:24 <hpc> you make a list from 1 to 1000, filter it, then sum it
05:38:22 <hpc> foo = sum . filter (tooEarlyToThink) $ [1..999]
05:38:24 <Etherael> merijn: actually it must be using the gauss method, I'm guessing, based on the reference to  3 + 5 - 15.
05:38:33 <hpc> yeah, 1-999 because "less than"
05:38:44 <dom96> oh, i see. fromString uses pack.
05:39:44 <Funktorsalat> zygoloid: what if the utf8 encoded literal is an invalid utf8 string? ;)
05:39:58 <Etherael> hugs is like a haskell console right? is there any caveats with entering code there, I seem to get "Syntax error in input (unexpected `=') in response to the euler examples
05:40:05 <Funktorsalat> (hmm, is that even possible? confused)
05:40:09 <Etherael> simple stuff like basic arithmetic works just fine though
05:40:15 <hpc> hugs is not recommended, and there are limits to what it can do
05:40:29 <Funktorsalat> assuming my sauce is utf8
05:40:31 <hpc> dunno about hugs, but ghci is like being inside a giant 'do' block
05:40:37 <merijn> hpc: "where tooEarlyToThink n = (mod n 3) == 0 && (mod n 5) == 0"?
05:40:49 <hpc> you want to use let...in i think
05:40:53 <merijn> Etherael: I prefer ghci which comes with GHC
05:40:59 * hackagebot regular-extras 0.2.1 - Additional functions for regular: arbitrary,  coarbitrary, and binary get/put.  http://hackage.haskell.org/package/regular-extras-0.2.1 (JosePedroMagalhaes)
05:41:07 <hpc> merijn: yes
05:41:42 <Razz_DK> Could someone give me a hint as to why this doesn't type check: http://hpaste.org/41024/monad_instance
05:41:44 <Etherael> got ghc and ghci but they give the same error as hugs, must be doing something newbish. I'll just continue with lyah till I can write hello world at least, sorry to bug you and thanks for the direction.
05:41:48 <merijn> Etherael: Oh, of course
05:42:09 <merijn> Etherael: Writing "=" in ghci/hugs will try to define a function, but I'm not sure you can do that :p
05:42:11 <Razz_DK> The error is expected Either String State, inferred State -> Either String State
05:42:30 <hpc> Etherael: here's a trick that might make it easier
05:42:47 <merijn> Etherael: Easier is to create a simple module in which you write your functions and importing it into ghci using ":m path/to/file"
05:42:53 <hpc> Etherael: modify a .hs file, and when you want to load it in an interpreter, use :r
05:42:59 <hpc> or that
05:43:31 <Etherael> when you sawhen you say :r do you mean that's some clever vim command that knows to invoke haskell on the file?
05:43:45 <merijn> Etherael: No, that's a ghci command
05:44:05 <hpc> ghci uses vim-ish commands
05:44:58 <Etherael> but you say "modify a hs file" is this ref to some editor I'm not aware of or there's some file mode in ghci or.. ?
05:45:11 <merijn> Etherael: Just any editor you like
05:45:17 <lars9> there are so many regex packages, which one should we use?
05:45:37 <hpc> lars9: parsec ;)
05:45:53 <hpc> the regex packages are generally kinda crap
05:45:59 <hpc> case in point:
05:46:01 <hpc> :t (=~)
05:46:02 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
05:46:32 <Funktorsalat> gfoldl vs (=~)! fight!
05:46:51 <Funktorsalat> hpc: that doesn't say anything about the implementations though
05:46:51 <cathper> I have a list, say, [l_1..l_n] and an Ingegral s, and wants to split it into [l_1..l_k] and [l_k+1..l_n] such that sum [l_1..l_k] is maximal and < s.
05:46:56 <hpc> (=~) uses look-ahead optimization!
05:47:00 <hpc> it's not very effective...
05:47:00 <Funktorsalat> it's the fault of regex-base or whereever that thing is defined
05:47:03 <Razz_DK> If I have x' = State -> Either String State, how can I get the 'Either String State'? My attempts until now have been unsuccessful
05:47:19 <Razz_DK> http://hpaste.org/41024/monad_instance
05:47:34 <cathper> Tried reading Data.List.Split, but that didn't help me much.
05:47:43 <Funktorsalat> hpc: huh? (=~) doesn't use anything, it's a method
05:47:51 <Funktorsalat> algorithm depends on the instance
05:48:01 <lars9> hpc: what if i need a sed-like string substitution?
05:48:07 <hpc> Funktorsalat: crappy joke on your "fight!" line
05:48:14 <Funktorsalat> oops :)
05:48:15 <merijn> Etherael: .hs is just the extension for Haskell source. Just create a file with something like this: http://dpaste.com/268411/ and load it with :m
05:48:21 <Etherael> ah I see what you mean, edit in vim, load console :l file, :r to reload
05:48:30 <merijn> Etherael: yeah
05:48:33 <cathper> Actually I just want k.
05:48:52 <hpc> lars9: i don't think haskell's regexes can handle s/// anyway
05:48:59 <hpc> what with strings never mutating
05:50:48 <lars9> i mean i need a substritute :: String -> String -> String, and it can do sed-like regex replacement
05:50:55 <merijn> Etherael: Then you can interactively call functions you defined in your file, provided you don't get cryptic compile errors ;p
05:51:50 <cathper> find_a xs (y:ys) | sum (xs ++ y) > s = length xs
05:51:51 <cathper>                  | otherwise         = find_a (xs++y) ys
05:52:11 <cathper> When I s/k/a/. Better ideas?
05:52:47 <HugoDaniel> hi
05:53:24 <lars9> oh crap, archlinux's AUR has no Text.Regex.Parsec package
05:53:40 <hpc> @hoogle parsec
05:53:40 <lambdabot> package parsec
05:53:40 <lambdabot> module Text.Parsec
05:53:40 <lambdabot> module Text.ParserCombinators.Parsec
05:53:55 <hpc> parsec is strictly more powerful than regexes
05:53:58 <hpc> you will like it
05:54:13 <exDM69> parsec is great
05:54:17 <hpc> it's also a monad, so you can do more things with it that regexes could imagine
05:54:31 <Etherael> Got the first euler solution working now... I see it and damn, I love that it's done in so little code o_O 
05:54:37 <Etherael> it really is the gaussian method
05:55:52 <lars9> isn't parsec more complicated than regex?
05:56:08 <hpc> not once you start using it
05:56:24 <hpc> regexes are pretty complicated too, to someone just being introduced to them
05:56:45 <hpc> "wtf is this! s/\/(.*)\//$1/g"
05:56:46 <lars9> i know sed & vim very well...
05:56:52 <lars9> i can do most things with them
05:57:07 <sipa> hpc: it removes slashes
05:57:16 <hpc> sipa: i know, but a newbie might not
05:57:25 <merijn> hpc: Looks like a regex written by some idiot who doesn't know you can use other separators :p
05:57:30 <lars9> that's to remove all '\' ...
05:57:31 <sipa> ah, right, i though it was a question :)
05:57:45 <sipa> lars9: no to remove /
05:57:46 <hpc> merijn: :D
05:57:47 <merijn> "s#/(.*)/#$1/g" :p
05:57:58 <lars9> sipa: yep /
05:57:58 <merijn> Eh, fail
05:58:00 <merijn> #g
05:58:26 <lars9> i like the backward reference very much
05:58:43 <hpc> yeah, it's a pretty shitty regex
05:59:06 <earthy> plus, it's a perl regex
05:59:15 <earthy> the backref would be spelled \1 in sed and vim :)
05:59:33 <lars9> how can you not like regex, it's a great tool
05:59:39 <Razz_DK> How would one implement a state monad where the result of a stateful computation is Either String State?
05:59:48 <hpc> i like regexes, they just are not at all well done in haskell
06:00:12 <hpc> Razz_DK: you wouldn't; for one, you have a kind error
06:00:41 <lars9> i leart state monad, but never used it myself, so i've forgoten
06:00:46 <Razz_DK> hpc: what exactly do you mean, you would have it like Either Error State?
06:01:08 <hpc> Razz_DK: State :: * -> * -> *
06:01:26 <EnglishGent> hi all
06:01:27 <hpc> Razz_DK: you need to give it a parameter for what it's internal state is, and it's "return type"
06:01:47 <hpc> you could do State a String
06:01:59 <hpc> for some value of a, which is your state
06:02:13 <Razz_DK> hpc: State in my case is a datatype, sry should have clarified that
06:02:16 <hpc> oh
06:02:27 <hpc> then yes, Either String State should be fine
06:03:02 <Razz_DK> hpc: Ok, I'm just having a bit of trouble with bind, it doesn't type check and I'm not sure how to fix it
06:03:06 <Razz_DK> hpc: http://hpaste.org/41024/monad_instance
06:03:45 <hpc> iirc, you need "instance Monad (Rip a)"
06:04:18 <Razz_DK> hpc: i have newtype Rip a = Rip ( State -> Either String State)
06:04:34 <Razz_DK> hpc: so that should be taken care of
06:04:40 <ski> Razz_DK : that looks ok .. almost
06:04:50 <ski> you need to fit `a' in there, as well
06:05:26 <ski> if you *didn't* bother with the `Either String' part .. how would you make the state monad, then ?
06:05:50 <hpc> oh lol
06:05:57 <hpc> perhaps "Either a State"
06:06:13 * ski suspects not
06:06:14 <Razz_DK> ski: So even if I have newtype Rip a = Rip ( .. ) I need to have: instance Monad (Rip a) where ... ?
06:06:28 <ski> i'm not sure what you're asking about
06:06:54 <ski> if you want to be able to use the monadic operations, and the `do'-syntax, then *yes* you need to make `instance Monad ...'
06:07:16 <ski> though you don't want `instance Monad (Rip a) where', you want `instance Monad Rip where'
06:07:32 <Razz_DK> Well, my bind function is not type checking as it wants Either String State but gets State -> Either String State... Let me just post the code and error that should clarify things a bit
06:07:36 <ski> `Rip a' will not be the monad .. just `Rip' itself will be a monad
06:08:11 <ski>   newtype Rip a = Rip ( State -> Either String State)  -- you need to fix this, by inserting `a' somewhere
06:08:19 <gspr_> Hi! Maybe someone here can give me a hint to un-stick my brain. I've started building my first "real" Haskell project, which has so far involved building up a typeclass framework for simple algebraic properties (groups, rings, fields, modules, etc., essentially reinwenting the whe..., ehm, numeric-prelude). Now I feel I've painted myself into a corner, though! Example: the type Integer forms a group, so we can add and subtract Integers, and ther
06:08:32 <Razz_DK> ski: http://hpaste.org/paste/41024/monad_instance_extended#p41025
06:08:44 <gspr_> I suspect I need a nudge in some direction :)
06:08:49 <ski> gspr_ : .. cut off at ".. so we can add and subtract Integers, and ther"
06:08:58 <gspr_> ski: Oops
06:09:03 <gspr_> I'll continue...
06:09:28 <gspr_> Example: the type Integer forms a group, so we can add and subtract Integers, and there is a 0. Great. But now I want to go about introducting the notion of a free group over a generating set.
06:09:41 <gspr_> My brain gets completely stuck. The only "idea" I've come up with so far is to use Template Haskell to generate each free group type I need. Surely there must be an elegant solution?
06:09:46 <gspr_> ski: better now? :)
06:10:17 <gspr_> I'm not asking for a solution btw, just some hints to nudge me in the right direction
06:11:19 <sipa> gspr_: associated types or functional dependencies?
06:11:21 <ski> i'm not sure .. but i'd try to define a type `FreeGroup :: * -> *', such that `FreeGroup a' is a group for every type `a' (maybe assuming equality on `a' ?)
06:11:52 <ski> Razz_DK : one small thing, to begin with
06:11:56 <ski> if you change
06:11:58 <ski>   newtype Rip a = Rip ( State -> Either String State )
06:12:00 <ski> into
06:12:04 <Funktorsalat> ski: haven't read the cxt, but you'd need equality to reduce to normal form
06:12:13 <sipa> class Set (GeneratingSet a) => FreeGroup a where type GeneratingSet a :: *
06:12:18 <ski>   newtype Rip a = MkRip { runRip :: State -> Either String State }
06:12:22 <Funktorsalat> without that requirement you could just do type FreeGroup a = [Either a a]
06:12:46 <ski> (that's more or less the same as defining a function `runRip :: Rip a -> (State -> Either String State)', btw)
06:12:54 <ski> then you can simplify
06:13:01 <ski>   do x      <- t s
06:13:04 <gspr_> ski: That sounds like a good start - thanks
06:13:07 <ski>      Rip x' <- return $ f x
06:13:13 <ski>      x'
06:13:15 <ski> into just
06:13:20 <ski>   do x      <- t s
06:14:00 <Razz_DK> ski: but then don't you forget the function 'f' you're binding to ?
06:14:13 <ski>      runRip (f x)
06:14:19 <ski> well, something like that, anyway
06:14:25 <ski> (you have type problems, i see)
06:14:34 <Razz_DK> ski: I have :p
06:14:44 <ski> probably the last line will look more like
06:14:47 <ski>      runRip (f x) s2
06:14:57 <Etherael> is there a haskell pastebin?
06:15:00 <Razz_DK> s2 being \s2 ... ?
06:15:02 <ski> for some `s2', which you haven't written in there, yet
06:15:05 <ski> no
06:15:08 <Funktorsalat> ah, gspr_ asked the question
06:15:21 <Funktorsalat> gspr_: data FreeGroup a = FG [Either a a] ?
06:15:32 <ski> Razz_DK : another general thing
06:15:37 <ski>   do ...
06:15:41 <ski>      Rip x' <- return $ f x
06:15:44 <ski>      ...
06:15:47 <ski> can be replaced by
06:15:49 <ski>   do ...
06:15:53 <Funktorsalat> where Lefts represent inverses of generators, Rights plain generators
06:15:58 <ski>      let Rip x' = f x
06:16:00 <ski>      ...
06:16:03 <ski> which is simpler
06:16:08 <Razz_DK> right
06:16:13 * hackagebot bbdb 0.1 - Ability to read, write, and examine BBDB files  http://hackage.haskell.org/package/bbdb-0.1 (HenryLaxen)
06:16:16 <Etherael> http://hpaste.org/41026/why_x_and_not_y
06:16:21 <sipa> Etherael: hpaste.org
06:16:25 <ski> this holds when `Rip' is the only constructor of your datatype
06:16:30 <Funktorsalat> gspr_: the group operation then is simply list concatenation, if you're fine with omitting normalization
06:16:41 <Funktorsalat> er, s/omitting/deferring/
06:16:54 <Razz_DK> ski: thx :-)
06:16:55 <Funktorsalat> for that you'd need Eq a
06:16:56 <Etherael> Both work fine as far as I can see, but the first one looks needlessly complex / verbose by comparison?
06:17:13 <gspr_> Funktorsalat: interesting!
06:17:26 <paolino> hello , is there something like HList for the alternative part of datatypes ?
06:17:27 <ski> Razz_DK : when `Rip' is *not* the only constructor, then using `Rip .. <- return (...)' will implicitly call `fail' when the match fails, but `let Rip .. = ...' will instead generate an error for you
06:17:48 <ski> Razz_DK : but in your case, you have only one constructor, so using `let' is ok. and is nicer
06:17:56 <Funktorsalat> gspr_: though you could just make your own ADT instead of reusing [] and Either, if you prefer
06:18:04 <ski> Razz_DK : however, defining a `runRip' function is even nicer than `let', i think
06:18:10 <Razz_DK> ski: ok
06:18:14 <Funktorsalat> but with the latter you don't have to rewrite utility functions
06:18:31 <ski> (Razz_DK : since you can shorten two lines into one, and it's still readable)
06:19:00 <hpc> @where pastebin
06:19:00 <lambdabot> http://rafb.net/paste
06:19:08 <hpc> @where+ pastebin hpaste.org
06:19:09 <lambdabot> It is stored.
06:19:21 <hpc> @where+ pastebin http://hpaste.org
06:19:22 <lambdabot> Done.
06:19:30 <hpc> should probably make it a full link...
06:20:07 <Kaidelong> out of curiousity, is there something particularly wrong with pastebin or codepad?
06:20:18 <gspr_> Funktorsalat: I can feel my brain getting unstuck now. Thanks :)
06:20:21 <paolino> I'd like to add a constraint to 'a' in MonadWriter [a] so that I can "tell" my own datatype 
06:20:22 <Kaidelong> oh, I guess this way it gets tied to the channel
06:20:36 <hpc> there used to be a pastebot
06:20:46 <ski> Funktorsalat : yeah .. so with normalization it works only for discrete sets (which is not surprising)
06:20:54 <Icewing> If you use (a, Bool) instead of Either a a, you don't have to rewrite such things like not, which makes inverting very simple.
06:21:06 <Funktorsalat> ski: discrete?
06:21:36 <ski> Funktorsalat : that a set is discrete means that we have a decidable equality on it
06:21:51 <ski> (that's constructive mathematics)
06:22:13 <Funktorsalat> ok. not the topological meaning, though there seems to be some connection
06:22:26 <ski> Razz_DK : anyway, you basic problem here is that your type `Rip' is slightly wrong
06:22:55 <Funktorsalat> (equality is decidable on topologically discrete subsets of R, when using CReals, I guess)
06:23:10 <ski> Razz_DK : have you (successfully) defined a basic state monad, without supporting errors (which i suppose is what `Either String' is for, right ?)
06:23:26 <Razz_DK> ski: yeah the string would be an error
06:23:57 <ski> so, are you able to write a state monad, *without* handling any errors ?
06:23:58 <Razz_DK> ski: but why doesn't it support errors?
06:24:03 <Funktorsalat> maybe that's even an 'iff'
06:24:15 <ski> Razz_DK : this is just a simplification, to get the state part of it right, to begin with
06:24:16 <Funktorsalat> (decidable equality -> topo. discrete)
06:24:25 <Razz_DK> ski: I've done so previously with a maybe monad, that worked just fine
06:24:32 <ski> Razz_DK : hopefully, after you've done that, you'll see how to add the errors back correctly
06:24:33 <greap> I just did a fresh install of the haskell platform, and ghc doesn't seem to be finding my cabal installed packages.
06:24:45 <greap> Is there an environment variable I need to set?
06:25:01 <Funktorsalat> greap: it probably overwrote the package db
06:25:03 <ski> Razz_DK : well, i'm asking about state here, not `Maybe' (`Maybe' is basically errors, except there's only one possible error : `Nothing')
06:25:11 <Funktorsalat> just reinstall them
06:25:19 <dcoutts_> greap: all the packages that are registered will be listed by "ghc-pkg list"
06:25:31 <Razz_DK> ski: yeah, but I've defined the state monad using Maybe earlier, now, however, I need explicit errors
06:25:32 <dcoutts_> greap: if they're not listed, then (re)install them
06:25:51 <ski> Funktorsalat : semi-decidable universal quantifier <=> compactness :)
06:26:04 <dolio> Funktorsalat: The reverse probably holds, too, in that every set has a designated topology, which determines the decidability of its equality relation.
06:26:06 <greap> Oh that's weird it is listed.
06:26:26 <Funktorsalat> fun
06:26:37 <greap> dcoutts_: I should have mentioned that it is on a fresh system too.
06:26:48 <dolio> And all computable functions are continuous functions between the sets with the designated topology.
06:26:52 <Funktorsalat> ski: hmm? of Foo -> Bool functions?
06:27:02 <Funktorsalat> (I mean the body of the quantifier)
06:27:09 <ski> Funktorsalat : semi-decidable apartness <=> Hausdorff
06:27:38 <dcoutts_> greap: if you need more help you'll need to give more details, e.g. log of the command you ran and the error it gives, ghc-pkg list output etc
06:28:11 <ski> Funktorsalat : and semi-decidable existential quantifier <=> overtness (but classical speaking, every topology is overt, so ..)
06:28:20 <Funktorsalat> dolio: hmm, "discrete" only applies to subsets of topological spaces though, so I don't see an obvious way to generalize it from CReal
06:28:33 <dolio> So, Bool is a 2-element set with the discrete topology.
06:28:52 <ski> Razz_DK : could you paste your earlier definition of state monad (with or without `Maybe') ?
06:29:09 <dolio> Whereas 'truth values' is the Sierpinski space, which has two points, but a different topology.
06:29:23 <zygoloid> Funktorsalat: (re ages ago): I can turn that argument around. the current IsString instance is surjective, the UTF8 one would not be.
06:29:28 <ski> Funktorsalat : `forall_A,exists_A :: (A -> Sierpinski) -> Sierpinski'
06:29:32 <greap> dcoutts_: Yep. I'll make a paste somewhere.
06:29:41 <Funktorsalat> oh wait, I'm stupid, "discrete" can be defined intrinsically too
06:29:54 <Funktorsalat> (every subset is open)
06:30:28 <ski> Funktorsalat : `data Sierpinski = Terminated' .. so each function from `A -> Sierpinski' either terminates, which means the property holds, or doesn't terminate, which means we have no idea (if we can't *reason* us to that it doesn't terminate)
06:31:36 <Funktorsalat> ok, so not Bool :)
06:32:06 <Razz_DK> ski: http://hpaste.org/paste/41024/old_instance#p41027
06:32:14 <ski> Funktorsalat : using (total functions to) `Bool' would be decidable properties
06:32:35 <ski> Funktorsalat : using (partial functions to) `Sierpinski' models semi-decidable / observable properties
06:32:36 <Funktorsalat> ski: yeah, but initially you only talked about the universal quantification being semi-dec :)
06:33:01 <Funktorsalat> *nod* I've seen that part about Sierpinski
06:34:24 <ski> Funktorsalat : you should read some of Martín Escardó's "Synthetic topology of data types and classical spaces" at <http://www.cs.bham.ac.uk/~mhe/papers/entcs87.(pdf|(ps|dvi)[.gz])>, 2004-11
06:34:57 <ski> @where impossible
06:34:58 <lambdabot> <http://math.andrej.com/2007/09/28/seemingly-impossible-functional-programs/>,<http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/>
06:35:04 <ski> (and those, if you haven't seen them)
06:35:45 <ski> (also, Paul Taylor's Abstract Stone Duality is related)
06:36:53 <EvanR-work> sounds like a bait and switch
06:37:20 <EvanR-work> like this talk i went to about 'differentiating non differentiable functions'
06:38:45 <greap> Agh, never mind. The cabal package NumberSieves had changed it's module path since I'd used it last.
06:38:45 <Kaidelong> EvanR-work: that sounds interesting actually and personally I've thought about that problem a lot, IE if things are really non-differentiable or if perhaps they're just not deterministically differentiable as in you can differentiate parts of them but not the whole thing
06:39:01 <ski> Razz_DK : ok, looking
06:39:12 <Razz_DK> ski: thx
06:39:42 <Razz_DK> ski: it worked, now I just need to switch Maybe with Either String State (or Either a State)
06:39:56 <EvanR-work> Kaidelong: from what i remember, the 'kicker' was that we have maximize or minimize applications in mind, and how to accomplish that if the function is not differentiable
06:40:04 <ski> Razz_DK : yes, that old one looks fine
06:40:25 <Razz_DK> ski: ok
06:40:53 <ski> (Razz_DK : you're using the `do'-notation and `return' for `Maybe', instead of using `Just' and `case'ing on it .. but that's fine, as long as you understand what `return' and the `do'-notation does for you, in the `Maybe' case)
06:40:59 <Kaidelong> EvanR-work: for a function which is entirely non-differentiable is it useful to think about optimizing it?
06:41:16 <Razz_DK> ski: I understand that
06:41:21 <EvanR-work> Kaidelong: useful or do you mean isnt nonsense
06:41:25 <ski> Razz_DK : now note how you *use* `a' on the right-hand-side in `newtype Rip a = Rip ( State -> Maybe (a, State) )'
06:41:29 <EvanR-work> such functions do i have maxima
06:41:33 <EvanR-work> s/i//
06:41:39 <Razz_DK> ski: yeah
06:41:44 <Kaidelong> but that doesn't mean there is a way to find them deterministically
06:41:45 <ski> Razz_DK : but in your later `newtype Rip a = Rip ( State -> Either String State )', you have forgotten to *use* `a'
06:42:07 <Razz_DK> ski: I noticed that yeah, so I'm guessing it would be better to use State -> Either a State?
06:42:24 <ski> Razz_DK : the fixed version of this later `Rip' should look very similar to the older one, except that you want to use `Either' of course
06:42:53 <EvanR-work> Kaidelong: well i dont remember the details
06:43:10 <ski> Razz_DK : `State -> Either a State' would mean that, given a state, you *either* get a return value of type `a', *or* a new state
06:43:34 <Kaidelong> EvanR-work: I figure the real art would be working with functions which are piecewise compositions of individually differentiable functions
06:43:36 <Razz_DK> ski: yeah, I was building on that actually, I'm just having problems fixing bind because now I'm ending up with x' being State -> Either a State, and I need just the Either
06:43:46 <ski> Razz_DK : i was assuming that what you wanted was : given a state, you get *either* an error, or a return value of type `a', *together* with a new state
06:43:53 <EvanR-work> Kaidelong: the applied side of things... yeah...
06:44:17 <Kaidelong> but if you had something like white noise
06:44:18 <Razz_DK> ski: So Either String (a, State) you mean
06:44:24 <Kaidelong> it would never actually be differentiable
06:44:29 <Kaidelong> ever
06:44:45 <ski> Razz_DK : well, what would the whole definition of `Rip' be, with this ?
06:44:46 <EvanR-work> Kaidelong: that may not even be continuous
06:45:02 <Kaidelong> is white noise not continuous?
06:45:12 <EvanR-work> i figure its a random function
06:45:13 <Razz_DK> ski: newtype Rip a = Rip ( State -> Either String (a, State) )
06:45:18 <Kaidelong> we could define it as ignoring its argument and returning a random value
06:45:23 <EvanR-work> yes then no
06:45:28 <EvanR-work> not continuous
06:46:05 <EvanR-work> theres no limit you can take to get the differences to go to zero
06:46:08 <Funktorsalat> I think 'white noise' is something which's fourier transform is a constant
06:46:16 <Funktorsalat> you can't literally take the inverse fourier transform of that
06:46:31 <Funktorsalat> (there are only approximations)
06:46:50 <EvanR-work> you could define a probablistic calculus or something ;)
06:46:59 <EvanR-work> the probability of being continuous is zero
06:47:17 <Kaidelong> so that means that doing a fourier transform on white noise gets you more white noise?
06:47:34 * Kaidelong has a book on fourier transforms but hasn't gotten around to that one yet
06:47:48 <EvanR-work> no it should give you a flat function
06:48:00 <Kaidelong> hmm, oh, like 0?
06:48:06 <EvanR-work> that would be rather boring
06:48:17 <EvanR-work> silent noise!
06:48:20 <EvanR-work> deep
06:48:33 <Kaidelong> I suppose that means white noise has an undefined fundamental pitch?
06:48:38 <Kaidelong> which makes perfect sense
06:48:45 <EvanR-work> ... no pitch
06:48:49 <EvanR-work> its noise!
06:49:22 <Kaidelong> exactly
06:50:00 <Funktorsalat> uh I'm rusty with this but I'm pretty sure the inverse fourier transform of the constant function of R simply doesn't exist ;)
06:50:31 <Jafet> If you're a perfect black body...
06:50:56 <Funktorsalat> (the expression would fail to converge, even pointwise)
06:51:30 <Kaidelong> well you'd end up with an infinitely long composition of sine waves won't you?
06:51:35 <Funktorsalat> yeah
06:51:37 <EvanR-work> so even the process of calculating it is chaotic! ;)
06:52:06 <Funktorsalat> Kaidelong: (which is fine, as long as the coefficients go to zero quickly enough. which they don't, with a constant ;))
06:52:09 <dankna> http://hpaste.org/41028/huh -- I'm getting "No instance for..." for an MPTC instance that I know is defined.  I reduced the problem to about a page of code, which is shown here.
06:52:50 <Kaidelong> Funktorsalat: I remember that, basically you get a taylor series out of the fourier transform normally, right? And that makes up a waveform
06:53:04 <Kaidelong> but in this case the series diverges
06:53:12 <Kaidelong> and is not a taylor series
06:53:29 <Funktorsalat> Kaidelong: there are different flavours of the transform (discrete, continuous)
06:54:04 <Saizan> dankna: atomToColumns doesn't make sense as a method of DatabaseAtom (unless you add a fundep), because its type doesn't mention 'collection'
06:54:09 <revenantphx> This channel is always so... science-y. I wonder how many people in here are post-docs.
06:54:28 <dankna> Saizan: oh - well there actually is a fundep, but I removed that when I reduced.  Let me check something...
06:54:28 <Funktorsalat> Kaidelong: I meant that the idea of white noise *starts* with the transformed function, which is assumed to be a constant (on R, with the continuous transform, or on Z, with the discrete one)
06:54:28 <ski> Razz_DK : sorry, someone was talking to me a short while
06:54:41 <ski> Razz_DK : yes, that looks great !
06:55:01 <Saizan> dankna: the fundep you need is "value -> collection"
06:55:17 <dankna> Saizan: I left it out by mistake, thank you for catching that :)
06:55:19 <dankna> it works now
06:55:27 <Saizan> np
06:55:31 <Razz_DK> ski: thx :-)
06:55:36 <Razz_DK> ski: and, np
06:56:16 <Razz_DK> ski: though, how do I get the (a, State), do I use 'case x of Left .. Right' or?
06:57:23 <db4n> Good morning, Haskellers.
06:57:38 <sm> good morning db4n 
06:57:52 <sm> revenantphx: yes it is, new topics welcome :)
06:57:53 <dankna> good morning
06:58:10 <Funktorsalat> Kaidelong: not entirely sure what the relation to taylor serieses is, but IIRC the fourier transform applies to more general functions than analytic ones
06:58:23 <Funktorsalat> at least if you only demand convergence in L2-norm or so
06:58:34 <dankna> revenantphx: yeah, I like it sciency, haha
06:58:44 <revenantphx> I don't mind one bit ^_^
06:58:54 <revenantphx> Admittedly, I sometimes just read conversations in here, heh.
06:58:55 <db4n> Is there someplace I can ask about library installation probs?  regex-posix doesn't seem to work, and I'm having trouble installing and/or importing regex-pcre.
06:59:11 <revenantphx> Oh, I got an internship at U of Pitt, I'm writing ant behavior algorithms.
06:59:12 <revenantphx> It's fun.
06:59:15 <dankna> fun!
06:59:19 <dankna> indeed, sounds it
06:59:21 <revenantphx> I'm going to rewrite them in haskell in my free time.
06:59:26 <dankna> haha cool cool
06:59:26 <revenantphx> They're a tad stateful though.
06:59:33 <Funktorsalat> Kaidelong: but anyway, I meant that no actual function will have a constant as its transform :)
06:59:33 <dankna> are they really?
06:59:38 <sm> db4n: this is one such place. Are you on windows ?
06:59:39 <dankna> I would have thought ants were nigh unto stateless
06:59:43 <revenantphx> They could be expressed in haskell.
06:59:54 <revenantphx> There are pheromone amounts, whether ants have food, etc
06:59:58 <dankna> hmm okay
07:00:11 <revenantphx> But since each N(t) is directly based on N(t-1) i'm sure you could do it.
07:00:17 <Funktorsalat> hehe. funny thought (ants being stateless)
07:00:17 <revenantphx> there's no state between time steps.
07:00:43 <revenantphx> I've got it running in C right now.
07:00:46 <dankna> the year that the ICFPC was the ant programming, I believe the only per-ant state was location, whether it has food (now that you mention it), and program counter
07:01:07 <revenantphx> My ants have a pointer to their location.
07:01:10 <revenantphx> I'm using linked lists.
07:01:22 <revenantphx> With some fun struct/union polymorphism type stuff.
07:01:29 <dankna> gotcha
07:01:33 <revenantphx> feel free to criticize:
07:01:33 <revenantphx> http://github.com/DylanLukes/Ants
07:01:53 <revenantphx> It's working with a Y shaped system
07:01:56 <dankna> looks short and sweet, I approve
07:02:01 <revenantphx> one end has a colony ,the other too are food sources.
07:02:23 <lars9> god please show me a working example of regex substitution in haskell...
07:02:24 <revenantphx> A previous study showed ants using two distinct pheromones oscillate between sources (if they are exactly equal)
07:02:30 <dankna> !  is this some new C99 syntax (heh... C99 was eleven years ago and I'm calling it new :( )
07:02:35 <revenantphx> which syntax?
07:02:38 <dankna> you have a union with fields that aren't named
07:02:42 <revenantphx> Oh, yeah
07:02:44 <revenantphx> anonymous unions.
07:02:48 <dankna> how are they accessed?
07:02:50 <EvanR-work> lars9: nah, just use normal replace
07:02:54 <revenantphx> by the name of their fields.
07:03:06 <ski> Razz_DK : using `case ... of Left err -> ... ; Right (a,s2) -> ...' is one way, yes
07:03:12 * dankna looks in the other file for an example
07:03:13 <revenantphx> lemme give you a good example, it's REALLY useful
07:03:25 <dankna> please do
07:03:29 <Razz_DK> ski: isn't that nice though, what would be a nicer way of defining it?
07:03:38 <EvanR-work> dankna: yeah but c99 still isnt the standard ;)
07:03:44 <dankna> EvanR: haha fair
07:04:00 <dankna> shouldn't there be a C2010 in the works?  ISO is required to review all its standards every 10 years
07:04:00 <db4n> sm yes, Windows.  Let me try re-installing regex-posix, I'll get back to you.  
07:04:06 <revenantphx> C1X
07:04:09 <dankna> ah!  cool
07:04:10 <ski> Razz_DK : you could use the `Monad' instance of `Either String' -- like you earlier used the `Monad' instance of `Maybe'
07:04:29 <lars9> EvanR-work: why ghc has no builtin regex lib?
07:04:30 <sm> I would make sure to use the latest regex-posix, also try re-installing regex-compat after installing it
07:04:37 * dankna still has his C9X polo shirt - at the time I was fortunate enough not only to be employed in computing, but at a company that was active in standards :)
07:04:42 <Kaidelong> Funktorsalat: so basically white noise isn't a function?
07:04:50 <EvanR-work> lars9: because regex arent as think as people useful they are
07:04:50 <revenantphx> here dankna
07:04:51 <revenantphx> http://gist.github.com/658217
07:04:52 <Kaidelong> that'd make sense given that it can't return a value
07:04:53 <Razz_DK> ski: not entirely sure how, you mean using Rip x' <- return $ f x?
07:04:56 <dankna> lookin'
07:05:06 <dankna> that's pretty sweet,
07:05:08 <revenantphx> In this example, if I do myStruct.x and myStruct.r, they are exactly equivalent.
07:05:21 <Funktorsalat> Kaidelong: I don't think so. though WP has it as a random process http://en.wikipedia.org/wiki/White_noise#White_random_process_.28white_noise.29
07:05:24 <lars9> EvanR-work: what do you use instead?
07:05:29 <EvanR-work> lars9: for what?
07:05:29 <dankna> well, assuming the representations of the two structs are equivalent, anyway
07:05:31 <revenantphx> Basically the addition of anonymous unions/structs (nested) allows for polymorphism within sturctures.
07:05:34 <revenantphx> dankna: of course.
07:05:35 <ski> Razz_DK : no i mean the  (a, s') <- t s  stuff
07:05:41 <dankna> which probably isn't guaranteed, but is something you can rely on in practice
07:05:42 <dankna> yeah
07:05:42 <Kaidelong> well can't return a deterministic value
07:05:50 <dankna> okay, but
07:05:50 <revenantphx> dankna: I can here, since they're the same size.
07:05:59 <revenantphx> Basically an anonymous union of structs provides different access schemes.
07:06:02 <dankna> yes, fair
07:06:05 <revenantphx> The names can even overlap
07:06:05 <dankna> now in your other example
07:06:07 <dankna> oh I see
07:06:07 <revenantphx> As I showed earlier.
07:06:15 <dankna> I was going to say you had structs with fields with the same name
07:06:15 <revenantphx> The first one is redundant.
07:06:16 <Razz_DK> ski: that would work ?
07:06:18 <dankna> but you put them in the same order as well
07:06:20 <revenantphx> The cool thing is.
07:06:30 <revenantphx> node->prev == node->pathB
07:06:31 <ski> Razz_DK : yes, `Either e' is a monad, too
07:06:37 <revenantphx> nodeB*
07:06:55 <revenantphx> It basically lets me use a nicer set of names for the same data ;)
07:06:58 <dankna> right, hm!
07:06:59 <dankna> nice.
07:07:01 <revenantphx> I've got a NodeType thing there too.
07:07:03 <revenantphx> Introspection.
07:07:06 <lars9> EvanR-work: sed like substitution
07:07:06 <dankna> yes I see that
07:07:07 <Razz_DK> ski: using that I get 'no instance for Monad (Either String)'
07:07:08 <ski> Razz_DK : i.e., instead of `case t s of Left err -> Left err; Right (a,s2) -> ..a..s2..', use `do (a,s2) <- t s; ..a..s2..' (replacing the `;'s with newlines and indentation, of course)
07:07:10 <revenantphx> Who says you can't do OO in C!
07:07:21 <dankna> yeah, haha
07:07:30 <EvanR-work> lars9: thats a solution, not a problem
07:07:31 <ski> Razz_DK : you need to import it, try `import Control.Monad.Error'
07:07:34 <revenantphx> Look at early C++ and current Objective-C...
07:07:38 <Razz_DK> ok
07:07:39 <dankna> the type-field-and-union trick is pretty much used in all large C programs, I'd think
07:07:45 <db4n> What if I want to use both regex-compat and regex-pcre for some reason?  Is there a way to do that?
07:07:56 <revenantphx> dankna: variant records.
07:07:59 <revenantphx> They're invaluable.
07:08:05 <dankna> indeed so
07:08:08 <EvanR-work> revenantphx: i do OO in C, and never touch stupid ad-hoc ad-hoc polymorphism
07:08:16 <revenantphx> EvanR-work: ?
07:08:26 <lars9> EvanR-work: i'm writing a command line tool, with which uses may need regex subst. in it
07:08:44 <EvanR-work> ah the union trick is for implementation inheritance, also unnecessary ;)
07:08:52 <revenantphx> ...?
07:09:11 <Razz_DK> ski: Ambiguous module name `Control.Monad.Error'
07:09:23 <revenantphx> This is just to have a single generic struct of uniform size to represent unary, binary and ternary nodes.
07:09:29 <revenantphx> It makes things a lot simpler.
07:09:50 <lars9> EvanR-work: it's called 'fordo', usage: fordo *.bmp -c convert {} {s/bmp$/jpg/}
07:10:05 <McManiaC> http://hpaste.org/41030/mtl how do you fix this? :(
07:10:06 <EvanR-work> lars9: you defined the problem to require regex as a solution, i cant really do much with that
07:10:32 <Funktorsalat> I'd say 'encode the tagged union as its elimination function instead' but that's probably a pain without closures (in C)
07:10:33 <EvanR-work> in your example i would just invoke sed 
07:10:41 <EvanR-work> its already written
07:10:46 <revenantphx> Funktorsalat: I have closures available.
07:10:46 <lars9> oh
07:10:57 <revenantphx> Funktorsalat: Apple's block implementation at least.
07:11:04 <revenantphx> Which would qualify as closures.
07:11:24 <dankna> it irks me how you have to explicitly use a type qualifier to mark the variables captured by the closure in Apple's implementation,
07:11:29 <Funktorsalat> revenantphx: ah. then you can just encode Either as its either
07:11:30 <dankna> but obviously to stay C-compatible it has to be that way
07:11:42 <lars9> how to invoke a program, and return its output? like invoke :: String -> IO String ?
07:11:44 <revenantphx> Funktorsalat: I don't follow.
07:11:45 <revenantphx> dankna: Not quite
07:11:54 <ski> Razz_DK : hm, that's strange
07:11:58 <dankna> not so?
07:12:06 <revenantphx> The __block specifier is for special case stuff.
07:12:10 <Funktorsalat> revenantphx: Either a b is basically the same as "(a -> r) -> (b -> r) -> r"
07:12:13 <revenantphx> Namely where you want the contents to be modified.
07:12:16 <Razz_DK> ski: yeah, don't know why that would clash
07:12:26 <Funktorsalat> (in impure languages, you don't even need the r, actually)
07:12:31 <revenantphx> It tells the compiler to attach the variable to the blocks struct by reference, not by value.
07:12:31 <EvanR-work> lars9: System.Posix maybe
07:12:35 <dankna> oh, you can access it read-only?
07:12:36 <dankna> I see
07:12:40 <revenantphx> Apple's blocks are generated at compile time.
07:12:43 <dankna> right
07:12:43 <ski> possibly you have several conflicting monad libraries installed
07:12:47 <Funktorsalat> so you can just use something like "(a -> ()) -> (b -> ()) -> ()"
07:12:54 <lars9> EvanR-work: what should the type be?
07:12:54 <revenantphx> I did some stuff a couple months ago,
07:12:56 <revenantphx> constructed them manually.
07:13:00 * ski tried to recall how to tell GHC to use a specific one
07:13:11 <revenantphx> dankna: You can always modify pointer types of course.
07:13:13 <EvanR-work> lars9: looks fine in principle, i dont know what the real types are
07:13:14 <lars9> EvanR-work: i mean the 'invokeCommand' function
07:13:15 <dankna> well yeah
07:13:20 <revenantphx> so if you close over int *p = &a;
07:13:21 <EvanR-work> lars9: its called exec in C
07:13:22 <revenantphx> then you can change a.
07:13:23 * Razz_DK tries it on another machine for second
07:13:26 <revenantphx> Just not p
07:13:32 <dankna> nodnod
07:13:57 <revenantphx> Mike Ash made an amazing little piece of code, that lets you convert a block literal int oa function pointer
07:14:04 <revenantphx> so you can pass blocks into any function taking a callback.
07:14:07 <EvanR-work> lars9: or... system
07:14:10 <dankna> oooh!
07:14:13 <aleator> Gah. It seems practically very difficult to make hGetLine for bytestring that doesn't assume \n as delimeter
07:14:14 <dankna> that's pretty sweet
07:14:14 <EvanR-work> man system
07:14:16 <lars9> EvanR-work: let me try
07:14:16 <ski> Razz_DK : try `import "mtl" Control.Monad.Error', then
07:14:18 <revenantphx> It does some stuff with FFI to create a bridge function.
07:14:20 <dankna> he must have used assembly for that trick?
07:14:28 <revenantphx> FFI/mprotect
07:14:31 <dankna> oh nice
07:14:47 <revenantphx> http://github.com/mikeash/MABlockClosure
07:14:48 <dankna> I know I know his name, but I forget what else he's done
07:14:50 <revenantphx> It's really excellent.
07:14:57 <dankna> cool.  definitely going in my toolkit.
07:14:59 <revenantphx> example:
07:15:00 <revenantphx> atexit(BlockFptr(^{ ...do something, no captured variables so it's a global block... }));
07:15:33 <McManiaC> http://hpaste.org/41030/mtl no idea on how to fix this? anybody?
07:15:48 <revenantphx> Well, time for physics class.
07:15:50 <Razz_DK> ski: that works, including the '-XPackageImports' flag
07:15:52 <revenantphx> Bye bye.
07:16:21 <dankna> MrManiaC: if it were me, because I am insane, I would endeavour to get everything working with mtl 2.0
07:16:48 <Funktorsalat> ghci> :i hSetNewlineMode 
07:16:48 <Funktorsalat> hSetNewlineMode :: Handle -> NewlineMode -> IO ()
07:16:48 <McManiaC> dankna: you *did* see how many packages that were? :P
07:16:49 <dankna> if dcoutts were here he'd probably say "oh that's caused by xyz misconfiguration, it's not really advisable but you can make it work by doing ghi"
07:16:52 <dankna> but I am not dcoutts
07:16:55 <Funktorsalat> ^^^^ @ aleator 
07:16:59 <dankna> I did.  You did see my comment that I'm insane? :)
07:17:40 <ski> Razz_DK : ok. also note that you can specify that flag by adding `{-# LANGUAGE PackageImports #-}' to the top of your source file
07:17:49 <Razz_DK> Ok, thx :-)
07:18:01 <dankna> let me digress for a moment to say that I /love/ the concept of the {-# LANGUAGE #-} flag
07:18:14 <dankna> that information belongs in the source file, not in the build system
07:18:21 <Funktorsalat> yes
07:18:36 <dcoutts_> McManiaC: try: cabal install --dry-run
07:18:38 <Funktorsalat> you can watch it fail in haskell too if someone puts it in the .cabal and you try to ghci it :p
07:18:47 <dcoutts_> McManiaC: and decide if you want to use mtl 1 or 2
07:18:50 <dankna> indeed
07:19:22 <dankna> oh cool, I summoned him
07:19:25 <dcoutts_> Funktorsalat: actually it belongs in both
07:19:46 <dcoutts_> dankna: ;-)
07:20:21 <dankna> dcoutts: really?  in both?  hmm....  maybe so, I guess.  you're saying that the build system needs to know so it can determine things like which compilers can build this package.
07:20:25 <Funktorsalat> dcoutts_: that's fine with me too
07:20:36 * hackagebot bson 0.0.4 - BSON documents are JSON-like objects with a standard binary encoding  http://hackage.haskell.org/package/bson-0.0.4 (TonyHannan)
07:20:41 <dcoutts_> dankna: exactly, it's a dependency
07:20:49 <dankna> gotcha.  okay.  I agree, then.
07:21:25 <McManiaC> dcoutts_: hm, cabal install just reinstalls everything
07:21:34 <McManiaC> (even though I tried to avoid cabal install, but meh)
07:22:07 <dcoutts_> McManiaC: that'll be because it's picking mtl 2 and most your packages are currently using mtl 1, if you pick mtl 1 then it'll just recompile the ones that currently use mtl2
07:22:20 <dcoutts_> McManiaC: if you add -v it'll say why it's rebuilding each one
07:22:29 <McManiaC> yep
07:22:46 <Etherael> anyone have a useful answer to this one ; http://hpaste.org/41026/why_x_and_not_y
07:22:48 <dcoutts_> dankna, Funktorsalat: note that cabal-1.10 has new fields: default-extensions and other-extensions, the latter is for extensions listed in LANGUAGE pragmas but not used by all modules.
07:22:56 <dankna> oh nice
07:23:45 <merijn> Etherael: I don't think that list comprehension at the end works
07:23:58 <Etherael> merijn: It seems to
07:25:04 <merijn> hmm, lemme see if I can do this clearer
07:26:13 <Etherael> as in I can run gaussian 3 5 10000 in ghci and get 23341668
07:28:16 <EvanR-work> does it make business sense to use haskell for project(s). consider it from the manager perspective and the haskell developer perspective
07:28:27 <EvanR-work> if they are different for a given company
07:28:28 <dankna> so.  I have 1654 lines of code which I suspect could be reduced to more like 300 lines if I wrote some Template Haskell.  but that would take a day or two and be completely impenetrable once I was done.  should I do it? :(
07:28:35 <earthy> evanr-work: it depends
07:28:41 <dankna> EvanR: they are absolutely different, and yes it depends
07:28:49 <EvanR-work> dankna: not if you run the company
07:29:03 <dankna> EvanR: okay.  fair.  well, consider the difficulty of hiring Haskell programmers.
07:29:09 <EvanR-work> yes
07:29:15 <dankna> I think that's really the overriding concern.  you and I know that Haskell has adequate library support.
07:29:18 <EvanR-work> i think im the only one in louisiana
07:29:19 <earthy> evanr-work: if you can find enough developers to develop and maintain the code, then it probably does make business sense.
07:29:21 <dankna> (by the way, if you're hiring, I'm available :D)
07:29:40 * hackagebot mongoDB 0.8.1 - A driver for MongoDB  http://hackage.haskell.org/package/mongoDB-0.8.1 (TonyHannan)
07:29:40 <earthy> as those capable of doing haskell tend to be capable of doing good work in any language
07:29:45 <ray> haskell programmers for sale enquire within
07:29:48 <dankna> that's very true too, what earthy just said
07:29:57 <EvanR-work> earthy: hmmm interesting assertion / insight
07:29:58 <dankna> (off-topic: klein bottle for sale - inquire within)
07:30:33 <earthy> plus, when developing a system, in this day and age you're talking not just haskell, but probably some front-end as well
07:30:37 <EvanR-work> i dont run a company, but i thought about it. custom software and we use haskell
07:30:45 * dankna nods
07:30:48 <EvanR-work> at this point im the developer in someone elses company
07:30:56 <EvanR-work> what about that aspect of it
07:30:57 <earthy> which may well be html+css+javascript, or java
07:31:12 <dankna> I do think there's actually something to be said for the Google approach:
07:31:13 <ray> haskell developers start at $7
07:31:19 <dankna> they have something like three allowed languages for the entire company
07:31:26 <dankna> and all their source is kept in one giant repository
07:31:32 <dankna> across all projects
07:31:33 <earthy> if you're the developer, do mention haskell, but don't try to force it on the employer
07:31:54 <EvanR-work> i have never discussed haskell with the big man
07:31:56 <dankna> the benefit there is that everything is held to a higher standard
07:32:02 <scree> I understood google had about 8 internal domain-specific languages as well
07:32:06 <EvanR-work> but we do use it
07:32:13 <dankna> I won't say it makes their code more reusable, because intuitively I think that would be untrue
07:32:24 <dankna> now, the downside is that the language they picked is Java :(
07:32:27 <ray> i'm good at DSLs (description of sandwich languages) in Hamskell
07:32:30 <earthy> writing code is hard in any language, and the chance that you already have a language that all developers are comfortable with is good
07:32:42 <dankna> scree: that may be, but they don't talk about it if so :)
07:32:42 <earthy> (all developers at the employers')
07:32:45 <EvanR-work> dankna: higher standard because its google or because they enforce a language
07:33:05 <earthy> then again, I'm biased. we have perl, C, C++, Java, CDL3 and Haskell code in our current codebase
07:33:12 <dankna> the latter, I think.  everything has to play nice in one namespace.  everything is potentially something somebody else will look at, so you take more pride in your work.
07:33:17 <earthy> not to mention the bits of shell and makefile
07:33:32 <EvanR-work> dankna: hmm
07:33:41 <dankna> and a thousand years from now, the programmer-archaeologists will find it MUCH easier to read than they will Microsoft's code
07:34:00 <earthy> standardising on one or at most a few languages *is* sensible
07:34:02 <merijn> dankna: Meh, the MS code isn't that bad
07:34:05 <EvanR-work> java? haskell? google? what will they find easier?
07:34:14 <gspr_> Is there anything like a type-level lambda in Haskell? Say I have a parametrized type  Foo a b  and want  Foo _ b  to be an instance of say Functor, is there anything like  instance Functor (\b -> Foo a b)?
07:34:19 <earthy> gspr: no.
07:34:28 <dankna> haha I didn't say it was bad, just that it is very much tied to the present day
07:34:38 <gspr_> earthy: :-(
07:34:38 <dankna> the context of what languages it uses and all that
07:34:43 <ray> standardizing on languages with those silly object system baggage sucks
07:34:46 <roconnor> gspr_: you can write type combinators
07:34:57 <gspr_> roconnor: What are they?
07:35:18 <roconnor> newType Flip f a b = Flip { unFlip : f b a }
07:35:20 <earthy> anyway, back to my haskelly bitbanging.
07:35:21 <dankna> EvanR: I have no opinion on whether Haskell or Java will be more readable to people a thousand years from now.  I know only that there will be people trying to read both :)
07:35:35 <EvanR-work> dankna: i just didnt understand what you were saying would be easier
07:35:58 <Jafet> Java will probably be more readable, since it is more redundant and survives bitrot better
07:35:59 <EvanR-work> mono culture code, or google code
07:36:00 <roconnor> gspr_: still, type level lambdas would have been nice
07:36:00 <dankna> oh, okay.  I was saying Google's way of having relatively few languages across the entire company would be easier than everybody else's way of treating each project as totally independent.
07:36:08 <gspr_> roconnor: Hmm, ok thanks :)
07:36:09 <Jafet> Unless we embark on a project to engrave the haskell report into stone
07:36:28 <dankna> Jafet: hahaha, well, we ought to do that :D
07:36:48 <EvanR-work> haskell 2298
07:37:07 <dankna> Jafet: note that I imagine the standards these things are based on will have survived, but that won't be much comfort when the problem you're confronted with is "okay, THIS code was written in 2010 so THAT concept hadn't been invented yet, so this data structure is a crude grasping towards it..."
07:37:08 <EvanR-work> engage
07:38:00 <EvanR-work> "look at these quaint 21st century zippers"
07:38:04 <dankna> hehe
07:38:04 <dankna> yeah
07:38:21 <dankna> awwww they were using quantum mechanics for their computers, how CUTE!
07:38:24 <ray> i disagree, i think object system concepts will be ARCH 502 ancient programming concepts
07:38:34 <Jafet> In 2298, computer anthropology was beginning... "oh crap, someone set up us the BOM"
07:38:39 <merijn> Etherael: I'd write something like this: http://hpaste.org/41031/new_gaussian (you'd have to fix the variables to something sensible, I don't know the math behind what you're doing so couldn't come up with good names)
07:38:43 <dankna> Jafet: hah
07:38:43 <EvanR-work> lol
07:38:56 <shapr> Is there a lib on Hackage that makes generating animated GIF images easy?
07:39:03 <ray> only grad students in computer archaeology will know java
07:39:15 <dankna> :t String -> [String] -> IO ()
07:39:16 <lambdabot> parse error on input `->'
07:39:18 <dankna> @hoogle String -> [String] -> IO ()
07:39:19 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
07:39:19 <lambdabot> Prelude writeFile :: FilePath -> String -> IO ()
07:39:19 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
07:39:32 <dankna> @hoogle String -> [String] -> IO Int
07:39:33 <lambdabot> Foreign.C.Error throwErrnoPath :: String -> FilePath -> IO a
07:39:33 <lambdabot> Foreign.C.Error throwErrnoPathIfMinus1 :: Num a => String -> FilePath -> IO a -> IO a
07:39:33 <lambdabot> Foreign.C.Error throwErrnoPathIf :: (a -> Bool) -> String -> FilePath -> IO a -> IO a
07:39:36 <dankna> bah
07:39:37 <ray> their parents will tell them to get a real job as a cyberdoctor or something
07:39:48 <EvanR-work> or cyberlawyer
07:39:53 <dankna> I was looking for the interface to system() so I could jokingly answer shapr with it
07:39:53 <ray> but they will love decoding ancient java programs too much
07:40:16 <dankna> anyway, I don't know of such a library, shapr
07:40:18 <Funktorsalat> @ty system
07:40:19 <lambdabot> Not in scope: `system'
07:40:19 <EvanR-work> ray: we should send them a time capsul explaining that they should let this be lost to time
07:40:26 <dankna> hehe
07:40:35 <Funktorsalat> dankna: System.Process.{system,rawSystem}
07:40:39 <dankna> ah, yes, that
07:40:40 <sipa> "and don't get it, professor, apparently this variable's value *changes* over time... :S"
07:41:19 <dankna> I imagine someday we'll need meta-software that converts from obsolete languages into modern ones
07:41:30 <dankna> actually, that sort of thing already exists; I was employed to write some during highschool :)
07:41:33 <ray> dissertation: on enterprise javabeans in ancient programming
07:41:35 <merijn> Don't we call that compilers?
07:41:37 <dankna> but we'll need it to be much more robust
07:41:46 <ray> no
07:41:46 <dankna> well, it's a type of compiler, yes
07:41:55 <ray> compilers go in the other direction
07:41:59 <dankna> but the goal is to produce maintainable output
07:42:00 <dankna> hahaha
07:42:01 <dankna> true
07:42:01 <merijn> ray: How so?
07:42:11 <ray> from modern into obsolete
07:42:16 <dankna> well, the Dragon Book definition is that a compiler is simply any translator
07:42:20 <Etherael> merijn: Why would you do it that way as opposed to the way I did it? is there something wrong with that way?
07:42:20 <merijn> Compilers are just language to language translation regardless of origin
07:42:29 <Jafet> @remember merijn <dankna> someday we'll need meta-software that converts from obsolete languages into modern ones <merijn> Don't we call that compilers?
07:42:30 <lambdabot> I will remember.
07:42:39 <hard_shooter> Couldn't match type "Maybe Int" against inferred type "Int"
07:42:39 <merijn> Etherael: Save both, try and read them a month from now :p
07:42:41 <dankna> ha, I'm in the quotebase now
07:42:44 <dankna> @quote dankna
07:42:44 <Etherael> merijn: Basic math behind it is gaussian's shortcut for the sum of all numbers between x and y.
07:42:44 <lambdabot> merijn says: <dankna> someday we'll need meta-software that converts from obsolete languages into modern ones <merijn> Don't we call that compilers?
07:42:45 <hard_shooter> How can I solve that ?
07:42:46 <dankna> @quote dankna
07:42:46 <lambdabot> merijn says: <dankna> someday we'll need meta-software that converts from obsolete languages into modern ones <merijn> Don't we call that compilers?
07:42:51 <ray> @quote
07:42:51 <lambdabot> z0MB13 says: who can say hello to me as a md5 or decipher what kind of technique can be used to remove the password
07:42:59 <sipa> does someone have a BASIC-2-Haskell compiler?
07:43:09 <Funktorsalat> %remember <dankna> ha, I'm in the quotebase now
07:43:09 <dankna> sipa: now I want to write one!
07:43:20 <Etherael> merijn: I can't actually read yours but I imagine that's because I don't know haskell that well yet, but basically you're saying my version would work just fine, but just looks "strange" ?
07:43:39 <merijn> :t zipWith
07:43:39 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:44:01 <Funktorsalat> I understand 'compiler' as something that translates from high to low
07:44:15 <dankna> I don't think it's useful to add the high-to-low distinction
07:44:17 <dankna> reason being
07:44:17 <Funktorsalat> seems like a useful distinction
07:44:17 <Etherael> the gaussian thing is the way you can do sum [1..100] like 50*101
07:44:34 <dankna> the low-to-high direction has all the same parts - parser, type system, code generator
07:44:35 <Etherael> because 100+1 = 101 99+2 = 101 98+3 = 101 etc etc
07:44:45 <merijn> Etherael: zipWith takes a function and two lists as arguments, then it applies that function to the items in both lists. Example: "zipWith (+) [1,2,3,4] [1,2,3,4]" -> [2,4,6,8]
07:44:46 <EvanR-work> compiler is a translator between two languages
07:44:46 <dankna> and if "compiler" only means the other direction, then there is no name for this general concept
07:44:52 <hard_shooter> Couldn't match type 'Maybe Int' against inferred type 'Int' How can I solve that ?
07:44:53 <sipa> decompiler?
07:44:56 <EvanR-work> compilers are functions
07:44:58 <Funktorsalat> dankna: uh, but a huge additional part
07:45:00 <Funktorsalat> for the decompiler
07:45:00 <EvanR-work> they are composable
07:45:07 <dankna> mm
07:45:14 <EvanR-work> they arent necessarily invertible
07:45:16 <dankna> you're thinking of assembly-to-C decompilers
07:45:21 <dankna> I'm thinking more along the lines of C-to-Haskell decompilers
07:45:25 <merijn> I think there some people working on better reverse engineering software at university here
07:45:40 <dankna> or C-to-Z where Z is a language that hasn't been written yet
07:45:50 <Funktorsalat> (at least if you want to produce *nice* high-level code, not quasi-assembly embedded in the higher lang)
07:45:55 <Etherael> merijn: Hmm, ok, thankyou :) I'd better get some shuteye now, more fun tomorrows.
07:46:03 <Funktorsalat> you'd need a heuristic module to re-fold unfolded stuff
07:46:12 <dankna> yes that's true
07:46:19 <EvanR-work> producing 'nice' code is an orthogonal issue
07:46:21 <merijn> Etherael: In your original code you had several lists consisting of multiplying with 1-z. So I just abstracted that away into a function which multiplies an element with 1-z
07:46:35 <dankna> but that's just an optimizer in reverse
07:46:47 <dankna> I don't mean "oh it's just an optimizer in reverse, its implementation is easy"
07:46:50 <merijn> dankna: I'm hereby introducing the term "pessimizer"
07:46:57 <dankna> merijn: duly noted :D
07:47:08 <Jafet> merijn: Mel K claims prior art.
07:47:12 <Funktorsalat> dankna: hehe
07:47:30 <Etherael> merijn: *forehead smack* my code is manually summing, it's not using the proper multiplication jump at all, I thought it was overly slow for 1000 * 1000 * 1000 upper limit. THat's why the other code does what it does, I just kinda mentally skipped that part.
07:47:31 <merijn> Jafet: On the internet no one can hear you plagiarize :>
07:47:36 <EvanR-work> the compilation process may lose information whether its high to low, low to high or sideways
07:47:43 <dankna> er
07:47:45 <EvanR-work> and it will add extra info from nowhere
07:47:58 <dankna> on the Internet everyone can hear you plagiarize....  although it can be hard over the din
07:48:21 <dankna> I agree with what Evan is saying
07:48:37 <merijn> dankna: No one on the internet pays enough attention to notice >.>
07:48:41 <dankna> point.
07:48:56 <Funktorsalat> it still seems like completely different things to me
07:48:57 <merijn> And according to my spellchecker "internet" is not a proper English word...
07:49:03 <Funktorsalat> you can find similarities between anything ;)
07:49:08 <Funktorsalat> raven/desk
07:49:12 <dankna> actually
07:49:13 <earthy> merijn: then your spellchecker is not very up to date :)
07:49:15 <dankna> that particular example
07:49:28 <dankna> nobody has ever found a good similarity that I've ever found plausible as the one Carroll had in mind
07:49:37 <Etherael> gaussian 3 5 (1000 * 1000 * 1000) using my method pushed cpu to 100% for more than 10 minutes, with the euler version the answer is 100% instnat.
07:49:48 <Etherael> silly summing.
07:50:12 <Funktorsalat> dankna: "poe wrote on both? or was that someone else's solution
07:50:24 <dankna> nice one, but I dunno
07:50:30 <dankna> I'll have to chew on that one
07:50:31 <ski> hard_shooter : match on the `Maybe' ?
07:50:47 <dankna> bear in mind that the character who gave the riddle didn't know who Poe was because he was in a different universe
07:50:56 <merijn> Etherael: Yes, its generating the list and summing it separately for each list. If you do it in the where clause like the original example its only done once
07:50:57 <dankna> okay so.  we shall have to agree to disagree, Funktor.  change of subject time!  Fermat probably didn't have a proof for his theorem.  discuss.
07:51:14 <Jafet> That's okay, literature can be dynamically scoped
07:51:26 <dankna> hahaha okay
07:51:34 <Etherael> merijn: The terseness of the example made it hard to wrap my head around the fact that it is still basically doing plain old for loop, almost.
07:51:38 <Funktorsalat> dankna: I'm embarassed to admit that I don't even know whether it's temporally possible
07:51:42 <Funktorsalat> I'm starting to doubt it
07:51:52 <Funktorsalat> (I mean in the actual universe, not the fictional)
07:52:20 <dankna> hmm not sure
07:52:33 <merijn> Etherael: Well, its using recursion, but with tail call optimization that's not too different from a for loop
07:52:35 <dankna> let me check
07:52:42 <dankna> Poe - 1809 to 1849
07:52:48 <Funktorsalat> nvm, it is
07:52:50 <dankna> Carroll - 1832 to 1898
07:52:51 <dankna> overlap
07:53:01 <Funktorsalat> is "<dankna> I'll have to chew on that one" a reference too?
07:53:06 <dankna> no
07:53:09 <Etherael> merijn: the ranges with step is quite alien, nifty feature though [x,y..z]
07:53:21 <dankna> I just say "chew" to mean "think about over a period of time"
07:53:24 <EvanR-work> :t fromThenTo
07:53:25 <lambdabot> Not in scope: `fromThenTo'
07:53:27 <Funktorsalat> "<dankna> nobody has ever found a good similarity that I've ever found plausible as the one Carroll had in mind" <-- uh so which one did he have?
07:53:32 <Jafet> :t enumFromThenTo
07:53:33 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
07:53:42 <Funktorsalat> oh, I think I was fantasizing an "as" into that sentence
07:53:45 <merijn> Etherael: It takes the first two or three values and tries to extrapolate the rest of the sequence
07:53:47 <Jafet> > [1,3..20] == enumFromThenTo 1 3 20
07:53:48 <lambdabot>   True
07:53:48 <Funktorsalat> "as plausible as the one"
07:53:52 <roconnor> wow, turning off my wireless card reduced my power consumption by 13%
07:54:04 * roconnor left his power cord at home
07:54:07 <Etherael> merijn: Yeah I get it, I just haven't seen a feature like that before, and I've wished for one many times. ;)
07:54:19 <merijn> Etherael: You can do many more interesting things too
07:54:30 <Jafet> roconnor: imagine the reduction in your lifetime cancer risk
07:54:36 <EvanR-work> roconnor: whatever happened to the radio best practice 'use as little power necessary to carry out communication' xD
07:54:37 <dankna> I don't think he did have one in mind, I think he deliberately constructed the riddle to have no good answer
07:54:41 <dankna> thereby making it memorable
07:54:46 * roconnor imagines almost none
07:54:46 <dankna> because people have tried to answer it ever since
07:54:59 * EvanR-work stabs Jafet for saying microwaves cause cancer
07:55:18 <dankna> yeah, I didn't say "as plausible as the one", I said "plausible as the one" :)
07:55:21 * roconnor starts feeling cold now
07:55:22 * EvanR-work then directs a xray beam at him
07:55:30 <dankna> thank you!
07:55:35 <Funktorsalat> dankna: the wiki agrees
07:55:36 <dankna> I had that argument with a family member recently
07:55:42 <Jafet> Aren't those still considered radio waves?
07:55:43 <dankna> "ummmm microwaves don't cause cancer.  they'll COOK you"
07:55:44 <Etherael> merijn: Last question before bedtime, why 3 / 2 = 1.5 but 3 `div` 2 = 1 
07:55:47 <dankna> "but they won't give you cancer"
07:55:51 <Etherael> merijn: Forces int instead of float or something?
07:55:59 <Jafet> :t 3/2
07:56:00 <lambdabot> forall t. (Fractional t) => t
07:56:03 <Jafet> :t div 3 2
07:56:04 <lambdabot> forall t. (Integral t) => t
07:56:11 <roconnor> I'd like to disable one of the cores, but I think I'll have to reboot to do that
07:56:12 <EvanR-work> dankna: they also may burn your food
07:56:12 <merijn> Etherael: Pretty sure `div` is division with a remainder
07:56:16 <roconnor> so I'll do that at lunch
07:56:16 <dankna> true enough!
07:56:23 <EvanR-work> which is jsut as unhealth as burning it on the stove
07:56:26 <merijn> Etherael: i.e. integer division
07:56:34 <EvanR-work> dont eat burned food
07:56:38 <Funktorsalat> they can produce strangelets too
07:56:50 <Funktorsalat> nom nom nom
07:56:52 <Etherael> frac vs integral, hmm, I can see I'm going to be having some fun with this type system.
07:56:58 <dankna> lol
07:57:00 <alej> haha
07:57:03 <EvanR-work> stragelets? i dont think so
07:57:06 <alej> :t fromIntegral
07:57:07 <lambdabot> forall a b. (Integral a, Num b) => a -> b
07:57:35 * dankna imagines "Stranges" and "Strangelets" being in the frozen-food section of the supermarket
07:58:12 <Jafet> "do not consume if vacuum bubble is broken"?
07:58:25 <dankna> haha
07:59:31 <EvanR-work> now that microwave cancer is out of the bag in here, i totally expect someone to denounce the moon landings
07:59:59 <dankna> sigh, I hope not
07:59:59 <Funktorsalat> dankna: WP even redirects "strange matter nuggets" or something like that to it
08:00:10 <Funktorsalat> (that's why I had clicked in the first place :D)
08:00:26 <tg_> don't trust anything about strangelets
08:00:31 <dankna> amusement, yeah, actually I was looking at that the other day.  what probably happened was that someone was discussing it in here and I clicked.
08:00:40 <tg_> I had to double take when I saw this in #haskell (instead of #lhc or #cern)
08:01:02 <Funktorsalat> er, "strange quark nugget"
08:01:13 <tg_> yeah, whatever it is, they don't exist as far as we know
08:01:23 <dankna> isn't it kind of like
08:01:29 <EvanR-work> and they wouldnt be created by microwaves
08:01:42 <dankna> the same way we know there's very little antimatter in the universe: if there were, somewhere we would be seeing a REALLY BIG explosion?
08:01:43 <tg_> no, and they almost surely won't be created by the LHC (because they weren't created by the RHC)
08:01:43 <EvanR-work> were talking classical electromagnetism here
08:01:54 <dankna> ah, but can they be created by GHC
08:01:56 <tg_> S/RHC/RHIC/
08:02:04 <EvanR-work> dankna: well.. what about gamma ray bursts ;)
08:02:13 <EvanR-work> astronomy topic
08:02:19 <dankna> fortunately, we have this thing which protects us from gamma ray bursts
08:02:21 <dankna> called an atmosphere
08:02:31 <dankna> it doesn't always (cf. power outages caused by solar activity)
08:02:32 <tg_> hehe. In #lhc and #cern, we have a few loonies who come in worried about stranglets killing the earth
08:02:33 <EvanR-work> yes but maybe its some antimatter hitting something xD
08:02:33 <dankna> but usually
08:02:45 <Funktorsalat> tg_: I'm not saying they exist. I just wanted to find out what those nuggets are
08:02:46 <dankna> it's not energetic enough for that, I don't think
08:02:47 <Funktorsalat> ;)
08:02:54 <EvanR-work> its gamma rays
08:02:56 <tg_> And, unsprisingly, it's hard to explain why something can't happen using CKM mixing matrices and Feynman diagrams, when they don't know anything about them.
08:03:08 <dankna> and even if it is, I'm just saying there are no antimatter planets out there
08:03:10 <tg_> Funktorsalat: you got strangelet nuggets from McDonalds this morning?
08:03:11 * maurer_ grumbles. Text.Disassembler.X86Disassembler does not disassemble all ops used by a gcc produced binary of void main(){}
08:03:20 <EvanR-work> dankna: not anymore xD
08:03:29 <dankna> yes, exactly :D
08:03:38 <tg_> EvanR-work: and there never were
08:03:47 * EvanR-work looks around, hope were not an antimatter planet ;)
08:03:51 <dankna> because planets didn't form until quite a long time after the universe did
08:04:01 <tg_> matter/antimatter asymmetry was resolved very early in this Universe (I prefer Universe A)
08:04:01 <Entroacceptor> EvanR-work: you wouldn't feel the difference
08:04:41 <dankna> ("We'll replace your brain with a computer.  Nobody will know the difference."  "/I'll/ know."  "No you won't.  You'll be programmed not to.")
08:05:15 <EvanR-work> alternatively, program your brain to think its a computer
08:05:22 <dankna> nice trick
08:05:24 <tg_> EvanR-work: mine already does
08:05:31 <EvanR-work> when im writing php yes
08:05:33 <Funktorsalat> tg_: is it actually known that there's less antimatter than matter?
08:05:46 <Funktorsalat> rather than the antimatter just being somewhere else
08:06:03 <dankna> Funktor: according to my undergrad astronomy prof, who's apparantly some bigwig in astro circles, yes it is known, and for basically the reason I gave
08:06:16 <dankna> there would be a boundary zone somewhere in the universe with very high energy liberation
08:06:16 <EvanR-work> Funktorsalat: theres an assumption of sameness over the entire universe
08:06:18 <dankna> and we observe no such thing
08:06:28 <EvanR-work> so since galaxies are exploding
08:06:33 <EvanR-work> theres no antimatter anywhere
08:06:36 <Funktorsalat> dankna: why would it necessarily collide?
08:06:37 <EvanR-work> arent*
08:06:58 <tg_> Funktorsalat: we "know" that the universe was almost 50/50 matter-antimatter very early in the BBM, and we know that that ratio is almost 99-1 now
08:07:08 <dankna> because everything collides eventually?
08:07:15 <EvanR-work> big rip!
08:07:22 <tg_> no, we think everything will drift away (big freeze)
08:07:30 <dankna> big freeze is my understanding, yes
08:07:33 <tg_> but at the beginning of the BBM, everything was in the same place
08:07:39 <dankna> actually it's even weirder than heat death
08:07:41 <Funktorsalat> dankna: "eventually" maybe, but many things fly around each other for a long time without doing so
08:07:44 <EvanR-work> use tiplerian omega point to avoid a big freeze
08:07:53 * hackagebot conductive-base 0.1 - a library for livecoding and real-time musical applications  http://hackage.haskell.org/package/conductive-base-0.1 (RenickBell)
08:07:55 <dankna> the universe is expanding faster than the speed of light, and the rate of its expansion is increasing
08:08:07 <tg_> the last time there was matter/antimatter symmetry was before quarks were unfrozen
08:08:09 <dankna> so eventually everything will be too far apart for there to be anything interesting
08:08:18 <tg_> so, at about 10^10 K
08:08:24 <dankna> assuming we don't figure out how to change that before then, which is my personal suspicion :)
08:08:27 <tg_> when the universe was in thermal equilibrium at around 10^10 K
08:08:48 <EvanR-work> 10 GK xD
08:08:49 <dankna> Funktor: conceded.  I suspect there's an actual mathematical answer to the objection you raise, but I don't know it.
08:09:19 <tg_> Funktorsalat: to be more specific, in the big freeze model, it's the expansion of spacetime which ultimate stops collisions
08:09:29 <dankna> gigakelvin is my new favorite word
08:09:33 <tg_> s/ultimate/ultimately/
08:09:43 <EvanR-work> giga dollars
08:09:43 <dankna> whenever somebody says "what's the word?" I will confidently proclaim "gigakelvin!"
08:09:51 <EvanR-work> gigabuck
08:10:00 <lars9> in my main, i need to invoke a command on a list of files, invoke :: String -> String -> IO(); why i can not "map (invoke cmd) files" in main's do block directly?
08:10:04 <dankna> already taken - the Illuminati game
08:10:17 <EvanR-work> 1.21 jiggawatts
08:10:29 <dankna> lars9:
08:10:30 <dankna> :t map
08:10:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:10:40 <dankna> notice that that's (a -> b) not (a -> IO b)
08:10:43 <dankna> :t mapM_
08:10:44 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:10:54 <lars9> :t mapM
08:10:55 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:10:59 <dankna> you want mapM_ (because you don't want the result of the invocation; if you did it would be mapM)
08:11:17 <phil> how could you write a list comprehension [ e | x <- e1, y <- e2] without using a list comprehension?  Is there an easy way to create all tuples (x,y) where x in e1, y in e2?
08:11:29 <lars9> mapM_ discards all results of invoke?
08:11:37 <dankna> correct
08:11:39 <EvanR-work> phil: LC
08:11:42 <lars9> thanks
08:11:45 <EvanR-work> oh nevermind
08:11:47 <dankna> this avoids constructing a list of results which you don't need
08:11:48 <dankna> welcome
08:11:54 * hackagebot conductive-clock 0.1 - a library for displaying musical time in a terminal-based clock  http://hackage.haskell.org/package/conductive-clock-0.1 (RenickBell)
08:11:56 * hackagebot conductive-hsc3 0.1 - a library with examples of using Conductive with hsc3  http://hackage.haskell.org/package/conductive-hsc3-0.1 (RenickBell)
08:12:02 <EvanR-work> phil: [(x,y)| ?
08:12:20 <EvanR-work> theres list monad
08:12:21 <Entroacceptor> EvanR-work: he doesn't want to use a LC
08:12:24 <Funktorsalat> tg_: I wasn't the one who raised the 'ultimately' :) was just saying that antimatter and matter galaxies (or whatever unit) may just have been circling each other without colliding so far
08:12:29 <Entroacceptor> can't you just zip?
08:12:38 <phil> ah, zip
08:12:38 <EvanR-work> you would not get them all with zip
08:12:45 <Funktorsalat> tg_: of course, maybe there'd be some other technique to detect antimatter if it existed in large amounts
08:12:54 * hackagebot conductive-song 0.1 - a library of functions which are useful for composing music  http://hackage.haskell.org/package/conductive-song-0.1 (RenickBell)
08:12:57 <Entroacceptor> > zip [1, 2, 3] [3, 4, 5]
08:12:57 <paolino> is there a template haskell function to create class synonims ? (if it's possible with TH)
08:12:57 <lambdabot>   [(1,3),(2,4),(3,5)]
08:13:14 <Entroacceptor> oh, right
08:13:16 <phil> hm, that's not enough
08:13:26 <tg_> Funktorsalat: yeah. We feel pretty confident that there are no large scale antimatter structures
08:14:40 <tg_> actually the next shuttle launch will take up the AMS
08:14:42 <tg_> @google AMS
08:14:44 <lambdabot> http://www.ams.org/
08:14:44 <lambdabot> Title: American Mathematical Society
08:14:51 <tg_> @google alphamagnetic spectrometer
08:14:52 <lambdabot> http://en.wikipedia.org/wiki/Alpha_Magnetic_Spectrometer
08:14:52 <lambdabot> Title: Alpha Magnetic Spectrometer - Wikipedia, the free encyclopedia
08:14:54 <EvanR-work> cartesian [1,2,3] [3,4,5]
08:14:55 <Funktorsalat> :)
08:15:00 <tg_> which will probably resolve this issue for good
08:15:13 <dankna> oh cool
08:15:14 <Funktorsalat> they got sick of the mathematicians belittling them? ;)
08:15:24 <kmc> > liftA2 () "abc" "def" -- phil
08:15:25 <lambdabot>   Couldn't match expected type `a -> b -> c'
08:15:25 <lambdabot>         against inferred type `()'
08:15:31 <tg_> Funktorsalat: TO SPACE!
08:15:32 <kmc> > liftA2 (,) "abc" "def"
08:15:33 <lambdabot>   [('a','d'),('a','e'),('a','f'),('b','d'),('b','e'),('b','f'),('c','d'),('c'...
08:15:59 <companion_cube> :t liftA2
08:15:59 <kmc> zip would give you [ e | x <- e1 | y <- e2]  (GHC extension)
08:16:00 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
08:16:38 <Jafet> :t return
08:16:39 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
08:17:23 <Jafet> What we need is a class DWIM
08:17:45 <lars9> :src map
08:17:52 <lars9> @:src map
08:17:52 <lambdabot> map _ []     = []
08:17:53 <lambdabot> map f (x:xs) = f x : map f xs
08:18:00 <paolino> anyone using TH who knows if it can write typeclass synonyms ?
08:18:12 <dankna> I am almost certain it can, paolino
08:18:17 <lars9> @:src mapM
08:18:17 <lambdabot> mapM f as = sequence (map f as)
08:18:24 <lars9> @:src mapM_
08:18:24 <lambdabot> mapM_ f as = sequence_ (map f as)
08:18:44 <paolino> dankna: ok, then I approach TH , thanks
08:18:49 <lars9> @:src sequence
08:18:49 <lambdabot> sequence []     = return []
08:18:49 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:18:49 <lambdabot> --OR
08:18:49 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:19:09 <Raelifin1> How do I quickly add two tupples? (1,3) + (4,8) == (5,11) for example.
08:19:16 <EvanR-work> Raelifin1: use Complex instead
08:19:34 <EvanR-work> > (1:+0) + (0:+1)
08:19:35 <lambdabot>   1.0 :+ 1.0
08:19:45 <dankna> > fmap (+) (1,3) (4, 8)
08:19:46 <lambdabot>   Couldn't match expected type `(t1, t2) -> t'
08:19:46 <lambdabot>         against inferred type ...
08:19:54 <dankna> > fmap (+) [(1,3), (4, 8)]
08:19:55 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, t1) -> (t, t1))
08:19:55 <lambdabot>    arising fro...
08:19:58 <dankna> oh well, fmap isn't magical
08:20:05 <EvanR-work> > (1,1) + (3,2)
08:20:06 <lambdabot>   (4,3)
08:20:09 <dankna> lol
08:20:14 <EvanR-work> smooth ;)
08:20:14 <alej> haha
08:21:18 <Raelifin1> I'm confused. do I use fmap or +?
08:21:29 <EvanR-work> just add them
08:21:34 <EvanR-work> @instances Num
08:21:34 <lambdabot> Double, Float, Int, Integer
08:21:35 <Raelifin1> + doesn't seem to work in GHCi
08:21:43 <Raelifin1>  No instance for (Num (t, t1))
08:21:43 <Raelifin1>       arising from a use of `+' at <interactive>:1:0-12
08:21:43 <Raelifin1>     Possible fix: add an instance declaration for (Num (t, t1))
08:21:43 <Raelifin1>     In the expression: (3, 2) + (5, 6)
08:21:43 <Raelifin1>     In the definition of `it': it = (3, 2) + (5, 6)
08:22:03 <EvanR-work> Raelifin1: make a Num instance for pairs of Num
08:22:22 <Raelifin1> Ah, ok. How do I do that?
08:22:29 <Raelifin1> Sorry. I'm a total newb.
08:22:35 <EvanR-work> @src Num
08:22:35 <lambdabot> class  (Eq a, Show a) => Num a  where
08:22:35 <lambdabot>     (+), (-), (*)           :: a -> a -> a
08:22:35 <lambdabot>     negate, abs, signum     :: a -> a
08:22:35 <lambdabot>     fromInteger             :: Integer -> a
08:22:40 <EvanR-work> hmm
08:22:51 <EvanR-work> you need + * and negate, i think
08:22:54 <EvanR-work> maybe more
08:22:56 <roconnor> heh http://en.wikipedia.org/wiki/Paramorphism isn't very detailed
08:23:29 <phil> EvanCarroll,  how do I get cartesian "in scope"? do you have to "include" something to use the function?
08:23:32 <phil> argh
08:23:34 <phil> EvanR-work, 
08:23:34 <dankna> tg_: what is alpha-magnetism?  I can't find much on it
08:23:41 <dankna> @google "alpha magnetism"
08:23:42 <lambdabot> http://www.magnet.fsu.edu/education/teachers/curricula/documents/maglabalpha-expedition14.pdf
08:23:42 <lambdabot> Title: MagLab Alpha: Magnetism and Temperature
08:23:49 <mm_freak> EvanR-work: you need all, except 'negate' or (-)
08:23:50 <EvanR-work> phil: i took the liberty of naming what you wanted to do, you provide the implementation ;)
08:23:56 <EvanR-work> mm_freak: oh
08:24:04 <phil> oh
08:24:15 <phil> I thought you pointed out a built in function
08:24:16 <EvanR-work> a few were suggested above
08:24:22 <EvanR-work> LC and liftA2
08:24:46 <phil> I thought I'd try cartesian first since liftA2 has a really strange name :)
08:24:56 <phil> not very descriptive
08:25:04 <EvanR-work> thats why you name it something else
08:25:12 <EvanR-work> and give a different interface
08:27:06 <Jafet> where abs a = if a < 0 then negate a else a :: (Ord a) => a
08:27:40 * Jafet checks if that's legal with -fglasgow-exts first. You can never be too sure
08:28:06 <Funktorsalat> needs Num too
08:28:25 <Funktorsalat> oh nvm.
08:28:42 <tejas> hello guys
08:29:02 <EvanR-work> does deriving Num work?
08:29:18 <kmc> Raelifin1, EvanR-work, I think making a Num instance for (,) is probably a bad idea
08:29:37 <EvanR-work> lambdabot disagrees
08:29:38 <Funktorsalat> EvanR-work: for newtypes
08:29:43 <tejas> can anyone suggest agood book on studying haskell for a beginner
08:29:46 <kmc> lambdabot has lots of things which are bad ideas
08:29:48 <kmc> tejas, RWH or LYAH
08:29:49 <kmc> @where RWH
08:29:49 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
08:29:51 <kmc> @where LYAH
08:29:51 <lambdabot> http://www.learnyouahaskell.com/
08:30:16 <EvanR-work> * kind of doesnt make sense
08:30:21 <Funktorsalat> pointwise (*) is kinda questionable yes
08:30:48 <Funktorsalat> at least there are other sensible ones, like the complex number one
08:31:14 <kmc> if you want to do math on pairs of numbers, those pairs stand for something
08:31:17 <EvanR-work> to add pairs make a funny operator
08:31:20 <kmc> like complex numbers, or vectors, etc.
08:31:25 <EvanR-work> .+
08:31:30 <kmc> you should make a new type Complex or Vector
08:31:34 <kmc> (or find a library that has them ;D)
08:31:55 <tejas> whats the use of haskell
08:32:01 <kmc> tejas, writing computer programs
08:32:07 <kmc> it is a general purpose language, it can be used for many things
08:32:23 <tejas> can you provide with some examples
08:32:30 <kmc> http://www.haskell.org/haskellwiki/Haskell_in_industry
08:32:39 <Jafet> > fix ((0:) . scanl (+) 1)
08:32:40 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
08:32:40 <kmc> you can really write most any program you want
08:32:52 <EvanR-work> it is used to search through an infinite set in finite time
08:33:12 <EvanR-work> very handy in the industry
08:33:27 <tejas> great
08:33:45 <EvanR-work> im trying to joke
08:33:45 <tejas> so what software is used to code haskell in
08:33:51 <kmc> what?
08:34:13 <EvanR-work> text editors
08:34:19 <EvanR-work> interactive interpreter
08:35:40 <tejas> any specific software like there's turbo c for c and java sdk for java like that
08:35:50 <EvanR-work> ghc
08:36:02 <kmc> to run Haskell code you need a compiler or an interpreter
08:36:07 <djahandarie> Does anyone have a link to a good paper or something on how DPH works in-depth?
08:36:09 <kmc> the most popular by far is GHC
08:36:11 <kmc> it's a nice compiler
08:36:15 <Entroacceptor> tejas: but there is leksah as an IDE
08:36:19 <tejas> where can i download that is it open source
08:36:20 <kmc> tejas, what you probably want to download is Haskell Platform
08:36:32 <kmc> tejas, http://hackage.haskell.org/platform/
08:36:46 <kmc> it doesn't have an IDE, but you could install leksah if you like
08:36:54 <kmc> but most people just use command line + whatever text editor they like
08:38:27 <bonii> I tried to do a import "mtl" Control.Monad, it gives me  Failed to load interface for `Control.Monad': It is a member of the hidden package `base-3.0.3.2'. error 
08:38:34 <bonii> I am using a Fedora box 
08:38:44 <bonii> I installed ghc-mtl
08:39:23 <tejas> leksah
08:39:37 <ski> hard_shooter : did you solve your `Maybe' problem ?
08:41:04 <sm> is leksah really ready for production/newcomer use ?
08:41:22 <djahandarie> sm, last I checked it wasn't bad
08:41:32 <djahandarie> Although you should be familiar with how basic Haskell stuff works
08:41:33 <djahandarie> modules etc
08:41:45 <sm> good to know
08:42:06 <kmc> bonii, Control.Monad is not in mtl
08:42:14 <kmc> also why are you using package-qualified imports in the first place?
08:42:39 <zygoloid> presumably to mix mtl and transformers in the same module?
08:42:50 <kmc> ok, i would like to confirm that
08:42:56 <kmc> like ghc says, Control.Monad is in base
08:45:16 <bonii> http://hpaste.org/41033/foo, I am trying to get this monad to work
08:45:25 <bonii> Its giving me "No instance for (Monad (Either String))" error 
08:47:50 <dankna> could you also hpaste the full text of the error?
08:49:09 <kmc> bonii, import Control.Monad.Instances
08:49:14 <kmc> should not require a package qualifier
08:50:00 <bonii> kmc: Yeah I removed
08:50:15 <bonii> kmc: I still get the problem "No instance for (Monad (Either String))"
08:50:34 <bonii> kmc: My monad is newtype Rip a = Rip (State -> Either String (a,State))
08:50:47 <dankna> bonii: could you also hpaste the full text of the error.
08:51:07 <hard_shooter> ski: yeah
08:51:45 <hard_shooter> I have to use Just 12 instead of 12
08:52:22 <kmc> looks like the Monad (Either e) instance disappeared in mtl 2
08:52:24 <bonii> dankna: http://hpaste.org/41034/error
08:52:50 <dankna> I don't understand why there /would/ be an instance for Monad (Either e) -- Either has a kind of * -> *
08:52:54 <IIcke> A newbie question: I am starting to do real stuff in haskell, but I am very slow coding, and I must focus a lot in the code (specially in the types and parameters of functions) to advance... becomes it easier with the time?
08:52:55 <kmc> to be replaced by 'transformers'?
08:52:57 <dankna> er, Either e has a kind of * -> *
08:53:05 <kmc> dankna, that's the correct kind fo a monad
08:53:07 <dankna> yes, it becomes easier with time
08:53:08 <MrAI> IIcke: Yes
08:53:09 <kmc> IIcke, yes
08:53:12 <bonii> do I need to define instance of Either ?
08:53:12 <dankna> oh, yes, I suppose it is, isn't it.  hmm.
08:53:14 <IIcke> moreover, it is difficult for me to read the code I wrote yesterday
08:53:15 <kmc> like most things
08:53:36 <kmc> you could put some code on hpaste.org and we could help you with style
08:53:46 <EvanR-work> IIcke: also over time, it will become more difficult to write php code
08:53:57 <EvanR-work> because you spend all your time making sure the types match up, in your head
08:53:59 <dankna> EvanR: haha
08:54:04 <dankna> so true
08:54:11 <kmc> bonii, looks like transformers provides that instance in Control.Monad.Trans.Error
08:54:20 <jmcarthur> the Either monad instance is in Control.Monad.Instances now, in base
08:54:27 <IIcke> ok, I thought that maybe it has something to do with a lack of intelligence, or focus, that I had :P
08:54:29 <kmc> in base 4.3
08:54:29 <jmcarthur> and it's the correct one instead of that lame Error one
08:54:42 <kmc> IIcke, well, focus is important
08:54:45 <MrAI> I know (a,b) is a pair. [] is the lists. I know lists can be infinite. How do I define a function to take in a list of pairs?
08:54:56 <IIcke> oh, thanks, kmc, I will use that suggestion in my next script :)
08:54:57 <bonii> kmc: I need to install it 
08:54:58 <MrAI> I was thinking something like [(a,b)..] but is wrong
08:55:12 <kmc> > [(1,2), (3,4)]
08:55:13 <lambdabot>   [(1,2),(3,4)]
08:55:19 <kmc> is a list of pairs
08:55:21 <bonii> import Control.Monad.Trans.Error gives me module not found error
08:55:29 <kmc> are you asking how to write the type signature for it MrAI?
08:55:32 <jmcarthur> :t [(1,2), (3,4)]
08:55:33 <lambdabot> forall t t1. (Num t, Num t1) => [(t, t1)]
08:55:39 <kmc> or how to write a pattern matching such values?
08:56:09 <Jafet> instance (Enum a, Enum b) => Enum (a,b)
08:56:17 <MrAI> Ive learnt: lists, pairs, tuples, types and functions: foldr foldl max snd fst. How would I do it with just those?
08:56:48 <EvanR-work> hrm thats a weird list of things to learn
08:56:59 <MrAI> Im following a good tutorial ive found
08:57:00 <EvanR-work> data structures, types, and functions
08:57:02 <kmc> MrAI, do what?
08:57:04 <MrAI> http://www.cs.utah.edu/~hal/docs/daume02yaht.pdf
08:57:04 <EvanR-work> there you go
08:57:08 <Jafet> It looks turing complete
08:57:18 <bonii> kmc: where can I find documentation to install what so that I can import Control.Monad.Trans.Error ?
08:57:20 <MrAI> Excercise 3.6
08:57:26 <kmc> bonii, cabal install transformers
08:58:36 <kmc> MrAI, ok, so a list of pairs is a list
08:58:41 <kmc> do you know how to get the second element of a list?
08:58:50 <kmc> start there, ignoring that it's a list of pairs
08:59:04 <MrAI> yes
08:59:07 <MrAI> snd
08:59:14 <kmc> no
08:59:19 <kmc> that gets the second element of a pair
08:59:21 <zygoloid> so the Control.Monad.Instances instance Monad (Error e) has fail _ = Left undefined? ;(
08:59:23 <kmc> how do you get the second element of a list?
09:00:12 * hackagebot rpm 0.0.1 - Cozy little project to question unruly rpm packages.  http://hackage.haskell.org/package/rpm-0.0.1 (EricStolten)
09:00:38 <tg_> nice
09:01:17 <ski> (bonii : you too are doing this `Rip' monad .. ?)
09:01:19 <MrAI> I thought I did kmc
09:01:23 <MrAI> two secs
09:01:32 <bonii> yes 
09:01:39 <bonii> ski: Yes
09:01:52 <ski> hard_shooter : ok. i thought you were doing the reverse, passing `Just 12' where `12' was expected
09:03:40 <EvanR-work> Rip monad? Rest in Peace?
09:03:57 <sipa> Monad the Ripper
09:04:12 <EvanR-work> is rip the dual of zip or something
09:04:27 <MrAI> kmc: head (tail [1,2,3])
09:04:31 <MrAI> head (tail [1,2,3])
09:04:37 <ski> > head (tail [1,2,3])
09:04:38 <lambdabot>   2
09:05:21 <ski> > head (tail (tail (tail "abcdefg")))  -- it gets tedious
09:05:22 <lambdabot>   'd'
09:05:33 <MrAI> Is there an easier way ski?
09:05:36 <ski> yes
09:05:44 <ski> a slightly simpler way is
09:05:47 <MrAI> absolute location?
09:05:48 <[swift]> [1, 2, 3] !! 2
09:05:57 <MrAI> Ah ok
09:05:57 <ski> > head (drop 3 "abcdefg")
09:05:58 <lambdabot>   'd'
09:06:02 <ski> but
09:06:07 <ski> > "abcdefg" !! 3
09:06:08 <lambdabot>   'd'
09:06:09 <ski> is even simpler
09:06:14 <ski> > drop 3 "abcdefg"
09:06:15 <lambdabot>   "defg"
09:06:48 <MrAI> I see
09:06:58 <ski> (also, note that if you're using `(!!)' with large indices, then you probably shouldn't be using lists, but some other data structure)
09:07:22 <EvanR-work> :t (!)
09:07:23 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
09:07:38 <ski> (when you use `(!!)', it has to traverse the list from the start .. the larger index you use, the longer it has to walk)
09:07:52 <MrAI> Thanks
09:09:20 <EvanR-work> walking 100 or several hundred steps isnt in principle bad on fast computers, but im thinking theres a detrimental effect on cache locality of reference
09:09:25 <kmc> yeah, they said everything i wanted to say ;)
09:09:30 <ski> as EvanR-work hinted at, if you want to use large indices, then arrays are one possible solution
09:09:32 <EvanR-work> then again i dont know how ghc code in general avoids that, nevermind ;)
09:09:48 <kmc> i find the array API clunky.  i think Map / IntMap are a nice choice
09:09:56 <ski> though an array needs to exist all at once, in memory, while that doesn't hold for lists
09:10:06 <ski> yeah, `Map's are nice
09:10:07 <kmc> you can update them with good sharing, which isn't the case for Array
09:10:54 <kmc> also note that both (!!) and head can throw exceptions at runtime
09:10:58 <kmc> if the list is too small
09:10:59 <EvanR-work> the choice between Array and Map should be one of semantic clarity, if its a lookup table with small numeric keys, array. if its a dictionary-like dynamic storage structure, Map
09:11:15 <kmc> i see no problem using Map for small numeric keys
09:12:03 <EvanR-work> id rather use the thing indicative of its purpose
09:12:09 <dankna> what is the coverage condition of a functional dependency?  I"m getting an error that it's failing
09:12:22 <kmc> EvanR-work, i'd rather use the thing whose API i like more
09:12:24 <dankna> I see the suggestion to turn on undecidable instances, but I want to know whether I really am using that feature or not first
09:12:38 <kmc> as a semantic idea "map" is very vague, it would include functions and arrays too
09:12:55 <shapr> But seriously, is there a Haskell graphics lib that will let me build animated GIFs on a byte level?
09:12:55 <EvanR-work> so its more general
09:13:08 <dankna> shapr: bytestring.  the GIF standard is not that complicated.
09:13:16 <kmc> of course you can build a map or an array, and then build a closure of its lookup function
09:13:21 <kmc> thereby making a function
09:13:25 <dankna> shapr: other than that I don't think there is one, no
09:13:31 <EvanR-work> kmc: the use case for an array (immutable) is pretty low, maybe you just dont like exceptions
09:13:41 <kmc> perhaps lookup tables should not be array or map at all, perhaps they should be memoized functions
09:13:56 <Jafet> dankna: dithering and palettes, oh my
09:14:19 <EvanR-work> yes use nice interface
09:14:23 <dankna> Jafet: granted, but he just wants to generate them - he can ignore those issues
09:14:34 <shapr> dankna: Yah, point... but I was hoping for something higher level.
09:14:35 <Jafet> shapr: you could make some ffi binding to netpbm or imagemagick
09:14:36 <EvanR-work> imagemagick exists
09:15:13 <dankna> shapr: I know that libgd can't do it, heh.  imagemagick maybe, as people are saying.
09:15:41 <EvanR-work> the mplayer of images ;)
09:15:42 <shapr> dankna: Yah, I just tried libgd
09:15:48 <Jafet> Imagemagick does it, but abysmally (I suspect memory leakage somewhere...)
09:16:00 <Jafet> It once put my system into swap
09:17:18 * hackagebot lhs2TeX-hl 0.1.1.0 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.1.0 (AlessandroVermeulen)
09:17:35 <shapr> Jafet: Eh, Travis Goodspeed has a cool blog post from 7am, and there's a contest for first person to submit a script to turn a bunch of Hex into an animated GIF... http://travisgoodspeed.blogspot.com/ I wanted to use Haskell
09:18:19 <EvanR-work> ffi to libgif now! ;)
09:18:25 <EvanR-work> or giflib
09:18:32 <Jafet> I won't go near those horrible things
09:18:38 <Jafet> http://adrinael.net/hr.gif
09:18:52 <shapr> Jafet: ack, ptui!
09:18:57 <EvanR-work> lol
09:19:13 <Jafet> But yeah, imagemagick works fine on typical small inputs
09:20:12 <ManateeLazyCat> Can someone help me adjust the words of my resume? My English not always best. Thanks
09:21:34 <Vanadium> http://stackoverflow.com/questions/753190/programmatically-generate-video-or-animated-gif-in-python -- the accepted answer there is to make pngs and use imagemagick's convert.exe :V
09:21:37 <EvanR-work> write a template haskell program to rephrase a resume
09:21:39 * ManateeLazyCat pasted "My resume" at http://paste2.org/get/1066805
09:21:41 <ManateeLazyCat> My resume at above .
09:22:03 <ManateeLazyCat> Plase someone help me adjust the words of resume.
09:22:10 <dankna> it should be "J2ME games", not "J2ME game"
09:22:30 <ManateeLazyCat> dankna: Ok, thanks.
09:22:51 <lars9> hmm.... haskell's string has no replace function...
09:22:52 <Vanadium> conversely it should probably be "Emacs expert"
09:23:02 <ski> hm, someone was wondering why the "`" symbol was used in Haskell to infixify an identifier
09:23:03 <shapr> Vanadium: That's good to know, thanks!
09:23:08 * shapr hugs Vanadium 
09:23:16 * Vanadium cheers shapr on
09:23:17 <ski> augustss : would you happen to know ?
09:23:20 <ManateeLazyCat> Vanadium: I just convert by Google.
09:23:22 <shapr> Vanadium++ # for awesomeness above and beyond the question
09:23:26 <dankna> ManateeLazyCat: it's traditional for the experience section in a resume to be a list of jobs you've held.  since yours is instead a list of projects you've worked on, you should make this clear with a sentence or two at the start of the section.
09:23:31 <ManateeLazyCat> Vanadium: So want you guys help me adjust it.
09:24:15 <EvanR-work> ski: every other character was taken? :)
09:24:23 <djahandarie> augustss, oh by the way, why did the examples file in the djinn darcs do something with a type-level fix? It doesn't seem that djinn has ever supported it
09:24:39 <ski> EvanR-work : yeah, i'm guessing it was non-taken, and not too visually distracting
09:25:19 <dankna> ManateeLazyCat: "Extension of the famous are" doesn't make grammatical sense.  I suspect you meant "My best-known Emacs extensions are:"
09:25:33 <ManateeLazyCat> dankna: Ok, thanks.
09:25:46 * ski idly wonders whether ManateeLazyCat is currently chatting here in Chinese
09:25:48 <dankna> did you see my suggestion about the experience section, above?
09:26:01 <lars9> what a shame, even c++'s string has more functions implemented
09:26:05 <EvanR-work> his client auto translates into english
09:26:11 <ManateeLazyCat> ski: I use ERC now, not use my irc client. :)
09:26:28 <EvanR-work> lars9: than what
09:27:01 <lars9> EvanR-work: Data.String...
09:27:18 <dankna> lars9: that's because a Haskell string is a list.  everything in Data.List also works on them.
09:27:21 <EvanR-work> well, String is a list of Char, so you can use any list operation
09:27:23 <ski> ManateeLazyCat : ok :)
09:27:37 <EvanR-work> also i do like the routines in Data.String.Utils (missingH)
09:27:49 <Vanadium> imagemagick is kind of scary
09:28:12 <ManateeLazyCat> dankna: yes.
09:28:21 * hackagebot lhs2TeX-hl 0.1.1.1 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.1.1 (AlessandroVermeulen)
09:28:29 <lars9> no trim, no split, no replace...
09:28:30 <djahandarie> copumpkin, how does the bifunctor in category-extras handle the covariant/contravariant issue?
09:28:43 <ManateeLazyCat> dankna: You mean split "Job section" and "Project section" ?
09:28:54 <EvanR-work> lars9: Data.String.Utils
09:29:21 <lars9> EvanR-work: mine has no this package
09:29:31 <EvanR-work> so, install it
09:29:39 <EvanR-work> http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html
09:29:43 <lars9> but i installed utily-ht, it provides Data.List.HT
09:30:11 <dankna> ManateeLazyCat, yes, definitely do that
09:30:13 <EvanR-work> eh well this page has everything you just named
09:30:14 <djahandarie> God why is this definition so complex
09:30:31 <EvanR-work> strip (trim), split, and replace
09:30:36 <ManateeLazyCat> dankna: Ok, thanks for your suggestion, adjusting.....
09:30:45 <lars9> EvanR-work: archlinux's AUR has utility-ht, so i just installed it..
09:30:53 <EvanR-work> i would use cabal
09:30:56 <EvanR-work> not AUR
09:31:16 <lars9> EvanR-work: i haven't used my first cabal yet, so i'll save it
09:31:34 <EvanR-work> cabal install missingh, i think
09:32:26 <dankna> ManateeLazyCat: you should also have an education section listing where you went to college, if you did (if you didn't, it's permissible to leave it out)
09:32:28 <Jafet> trim = join (.) (reverse . dropWhile isSpace); replace from to str = if null str then str else let n = length from in if take n str == from then to ++ replace from to (drop n str) else head str : replace from to (tail str)
09:33:03 <EvanR-work> Jafet: thats basically whats in the that missingH module
09:33:12 <ManateeLazyCat> dankna: I teach myself, i never study in college.
09:33:15 <lars9> Jafet: that replace is too slow
09:33:19 <Jafet> Yeah, except less inefficient
09:33:31 <Jafet> lars9: write a faster one!
09:33:32 <dankna> ManateeLazyCat: oh well.  it makes getting a job much harder, although perhaps it shouldn't.
09:33:47 <lars9> Jafet: I did that in C++ for practice
09:33:55 <lars9> but not in haskell yet
09:33:56 <EvanR-work> lars9: lazy evaluation means simpler algorithms you think are slow may not be
09:34:10 <EvanR-work> lars9: if you want high performance replace, you dont want String anyway
09:34:12 <jmcarthur> or vice versa, of course
09:34:24 <EvanR-work> you want Data.ByteString.Search
09:34:31 <lars9> EvanR-work: Jaffet's alg is O(M*N) right?
09:34:40 <ManateeLazyCat> dankna: Well, it's just a job. :)
09:34:50 <dankna> ManateeLazyCat, true true
09:34:56 <lars9> oh, maybe i'll try bytestring
09:35:21 <EvanR-work> i dont know exactly what O means in haskell very often
09:35:25 <kmc> bytestring is a string of bytes, not characters
09:35:33 <kmc> Data.Text is a packed format for characters
09:35:35 <kmc> 'text' package
09:36:14 <EvanR-work> ah Data.Text
09:36:18 <djahandarie> It'd be nice if you could make any type variable infix
09:36:37 <Jafet> There's also the question of how you consider strings equal
09:37:19 <djahandarie> (Category r, Category t) => a `r` b -> (p a c) `t` (p b c)    is easier to read than the alternative, I think
09:37:36 <djahandarie> It makes it a lot easier to imagine Hask there at least
09:37:57 <EvanR-work> lars9: M*N sort of thing is not uncommon in any string processing automaton
09:37:58 <lars9> Jafet: at least rabin-karp should be implemented
09:38:09 <EvanR-work> you basically want to stay out of exponential and things are peachy
09:38:24 <EvanR-work> quadratic etc may not matter much since search strings are typically short
09:38:55 <lars9> yeah but rabin-karp or kmp are O(M+N)
09:39:06 <Jafet> I am not referring to the algorithm. Although, unicode collation rules would probably make certain algorithms less convenient than others
09:39:31 <EvanR-work> lars9: to throw more names around Data.ByteString.Search is labeled Boyer-Moore
09:40:07 <Cale> It's actually surprisingly easy to do KMP with lazy evaluation
09:40:26 <Jafet> Building a suffix tree and searching it is O(M+N), too!
09:40:29 <Cale> There's a lovely blog entry about it... http://twan.home.fmf.nl/blog/haskell/Knuth-Morris-Pratt-in-Haskell.details
09:41:32 <lars9> Cale: that's very interesting
09:42:06 <djahandarie> So it seems like category extras assumes that your functors will all be covariant
09:42:23 <djahandarie> If I'm reading these types correctly
09:42:48 <pumpkin> there's Contrafunctor for those that aren't
09:43:09 <djahandarie> But Bifunctor doesn't seem to have any reference to Contrafunctor
09:43:18 <djahandarie> It's just PFunctor and QFunctor which are both covariant
09:43:48 <Blkt> good evening everyone!
09:44:56 <Cale> djahandarie: If you're looking for difunctors (like Hom), see the type of dimap
09:45:11 <dolio> djahandarie: You can have contravariant functors by making r an opposite category.
09:45:20 <Cale> You can apparently just use a constraint like  Bifunctor f (Dual k) k k => ...
09:47:20 <djahandarie> A difunctor? Is that a bifunctor where the arguments are opposite in variance?
09:47:21 <dolio> A lot of presentations of category theory have no mention of "contravariant" functors.
09:47:25 <Cale> djahandarie: yeah
09:47:33 <djahandarie> Hmmm
09:47:45 <dolio> There are just functors, either from C -> D for covariant, and C^op -> D for contravariant.
09:47:52 <djahandarie> I see
09:48:35 <djahandarie> Could it also be C -> D^op ?
09:48:35 <EvanR-work> @src (.)
09:48:35 <lambdabot> (f . g) x = f (g x)
09:48:35 <lambdabot> NB: In lambdabot,  (.) = fmap
09:49:05 <dolio> Yes, it could.
09:49:12 <Cale> Yeah, that's equivalent
09:49:33 <dolio> For every F : C -> D, there's F^op : C^op -> D^op, which is 'the same'.
09:49:40 <dolio> And C^op^op = C.
09:50:55 <EvanR-work> is there such a thing as a tagged union in haskell
09:51:02 <ManateeLazyCat> Thanks all for help! :)
09:51:12 <dolio> Either is a tagged union.
09:51:34 <djahandarie> So how would you work with opposite categories in Haskell?
09:51:47 <EvanR-work> so any data with one argument per constructor?
09:52:01 <dolio> newtype Dual (~>) a b = Dual (b ~> a)
09:54:17 <EvanCarroll> hrm
09:54:34 <EvanCarroll> I've never seen a ~> in my life.
09:54:50 <EvanCarroll> is that a haskell thing? or did you just invent it?
09:55:09 <Zao> It's common.
09:55:10 <shapr> EvanCarroll: arrows syntax
09:55:16 <EvanCarroll> but with the ~ ?
09:55:20 <shapr> Yup
09:55:26 <EvanCarroll> does any language impliment it natively?
09:55:28 <EvanR-work> it looks funny in xterm ;)
09:55:52 <Cale> EvanCarroll: It's just an infix type constructor variable
09:56:25 <EvanCarroll> Right, you could use anything though, I'm specifically specifically of ~> not what it is doing
09:56:54 <EvanCarroll> I just think that looks neat, and its simple (non-Unicode), and I've never seen it in another language
09:57:44 <EvanR-work> EvanCarroll: looks neat depending on your font ;)
09:57:53 <EvanR-work> ~ is raised to the top in some fonts
09:58:03 <EvanCarroll> yea, I noticed that with the xterm reference
09:58:12 <EvanR-work> any term really
09:58:21 <EvanCarroll> gnome-terminal++
09:58:28 <EvanR-work> no never
09:58:33 <djahandarie> Why can
09:59:13 <djahandarie> Oh hey, nevermind, answered my own question. Guess it's a good thing I didn't finish typing it out :P
09:59:45 <Saizan> but now we'll never know!
10:00:12 <EvanR-work> Saizan: imagine how many questions never even get that far
10:00:28 <shapr> So, it looks like the pngload hackage has a real datatype for PNGs.
10:00:49 <evanton> I want an offline copy of http://book.realworldhaskell.org/read/, is there a better way to get it than spidering the site? Like downloading a tarball with HTML for example? Because I don't see anything like that
10:01:01 <shapr> evanton: I think someone made PDFs at one point.
10:01:30 <EvanCarroll> http://fldit-www.cs.uni-dortmund.de/~peter/RealWorldHaskell.pdf
10:03:11 <evanton> EvanCarroll: I downloaded the pdf, I open in in evince, when clicking on a chapter link it tells me "Unable to open external link"
10:03:18 <aristid> EvanCarroll: um that's just a printout of the website?!
10:03:42 <aristid> here you can read for free: http://book.realworldhaskell.org/
10:04:10 <christastrophe> does haskell (or GHC rather) provide an interface to the Posix kill(2) call?
10:04:16 <evanton> aristid: I want an offline copy and I wonder if I can avoid spidering the site to get it
10:04:24 <EvanR-work> System.Posix maybe
10:04:45 <aristid> evanton: just buy the book :P
10:05:33 <ManateeLazyCat> EvanR-work: Where the package binding libgif? :)
10:05:58 <EvanR-work> i postulated its existence
10:06:00 <djahandarie> Cofree sure is cool
10:06:19 <ManateeLazyCat> EvanR-work: Do you want image-viewer? 
10:06:27 <EvanR-work> no
10:06:37 <evanton> aristid: is this what I'm getting for trying to be nice? :) ok, I'll spider the site
10:06:37 <EvanR-work> someone else wants to make gifs
10:06:37 <christastrophe> looking at the 6.12.2 docs for System.Posix, I don't see anything equivalent. System.Posix.Process would seem like the logical place for it, but that deals mainly with starting and stopping sub processes.
10:07:09 <ManateeLazyCat> EvanR-work: Oh, if you want image-viewer, here is a pure Haskell one : http://www.flickr.com/photos/48809572@N02/4947462492/lightbox/ :)
10:07:13 <ski> pumpkin : i've seen "opfunctor" used for "contrafunctor" .. i think it's a slightly better term, at least
10:07:19 <aristid> evanton: huh? i just think you should support the authors if you want an offline copy
10:07:24 <ski> ("contrafunctor" is misleading)
10:07:32 <EvanCarroll> EvanR-work: that's all there is, legally afaik.
10:07:33 <djahandarie> That does sound nicer
10:07:50 <pumpkin> ski: how so? it seems like a pretty legit abbreviation of contravariant functor?
10:07:53 <EvanR-work> EvanCarroll: not me!
10:08:14 <EvanR-work> EvanR-work: you meant to tab complete the other... oops
10:08:17 <EvanCarroll> evanton: Oreilly does sell a PDF iirc, and the presentation 
10:08:31 <EvanCarroll> or to aristid 
10:08:33 <ski> pumpkin : it suggests that "cofunctor" is a legit abbreviation of "covariant functor" .. and that's nonsense !
10:08:37 <EvanCarroll> to many Evan(s)
10:08:51 <christastrophe> ah! System.Posix.Signals.signalProcess
10:09:11 <ski> pumpkin : the "co" in "co" vs. "contra" is completely different from the one in "coproduct" vs. "product", e.g.
10:09:21 <djahandarie> I think cofunctor is actually short for contravariant functor along with contrafunctor
10:09:38 <ski> djahandarie : even worse, then :)
10:09:43 * christastrophe pats self on back for actually reading the documentation :)
10:09:51 <pumpkin> ski: yeah
10:09:58 <evanton> aristid: I'm not a native english speaker, but I think should != must. and the idea of having a free online copy but making it harder to get an offline copy just baffles me
10:10:28 <EvanR-work> evanton: well wget recursive isnt that hard
10:10:38 <EvanR-work> or browser save as
10:10:48 <aristid> evanton: what does not being a native speaker have to do with ethics?
10:11:08 <aristid> evanton: if you want to spider it, i won't stop you
10:11:42 <evanton> EvanR-work: wgetting sites is generally not very nice, so that's my last option
10:12:48 <evanton> aristid: it's not about ethics, it's about common sense. when I'm reading the book onlike, my browser still downloads parts of it. I'm just looking for a convenient way to download everything in one step :)
10:12:59 <aristid> wget -R
10:13:11 <aristid> i mean wget -r
10:13:11 <EvanR-work> evanton: not nice to who?
10:13:13 <EvanCarroll> Newbs that don't syncronize to the whole internet.
10:13:23 <EvanCarroll> EvanR-work: The tubes.
10:13:37 <evanton> EvanCarroll: it is technically not nice
10:13:41 <EvanR-work> tim berners lee?
10:13:49 <EvanR-work> ah, not easy to use
10:13:57 <EvanR-work> well wget is pretty easy
10:14:02 <EvanR-work> like most command line situations ;)
10:14:22 <evanton> EvanR-work: I don't have a problem with using wget, I even know about httrack, you seem to miss the point totally
10:14:30 <EvanR-work> yes
10:14:54 <EvanR-work> i dont know why people prefer pdf, its nazism
10:14:58 <evanton> I was just expecting to download a single tarball containing html and images
10:15:04 <christastrophe> damn signalProcess doesn't work in the way I would like it ... bummer
10:15:08 <EvanR-work> well wget can be pipped to tar
10:15:14 <EvanR-work> and then you can untar it and read it
10:15:24 <EvanR-work> piped*
10:15:33 <evanton> it would still send one HTTP GET request for each file
10:15:37 <EvanR-work> so i still miss the point
10:15:43 <christastrophe> or does it...
10:15:45 <evanton> I don't have a problem doing that tho
10:15:53 <EvanR-work> good
10:16:07 <EvanR-work> google sends about 1381 http requests per search
10:16:10 <EvanR-work> now a days
10:16:30 <aristid> evanton: what do you expect? do you expect them to give you an official tarfile to download? that would not be in their business interest
10:16:57 <Kaidelong> (!) = Data.Vector.Generic.!
10:17:00 <Kaidelong> as far as I can tell
10:17:06 <Kaidelong> this is how you use a qualified operator
10:17:09 <Kaidelong> but I get a parse error
10:17:28 <aristid> Kaidelong: (Data.Vector.Generic.!)
10:17:36 <aristid> you need to paren qualified operators too
10:18:49 <EvanR-work> aristid: business oriented programming in haskell! ;)
10:19:02 <aristid> EvanR-work: why not?
10:19:14 <EvanR-work> aristid: i didnt think it supported that
10:19:18 <aristid> EvanR-work: i think haskell is good for business, too :)
10:19:32 <EvanR-work> did you hear my question about business sense of haskell?
10:19:32 <ski> @quote enterprise
10:19:32 <lambdabot> monochrom says: every name is fine with me. ... <monochrom> no, I lied. every non-enterprise-ready name is fine with me.
10:19:37 <ski> @quote enterprise
10:19:37 <lambdabot> ryan[WTF] says: it's enterprise quality if it runs everything in a big try/catch
10:19:48 <ski> @quote enterprise.industry
10:19:48 <lambdabot> slava says: Because top enterprise industry analysts recommend that managers need to focus on Agile methodologies, SOA, B2B and Yoneda's lemma in today's rich Internet application-driven environment.
10:19:48 <lambdabot>  Don't get left behind by the AJAX craze by missing out on call center outsourcing and Yoneda's lemma!
10:19:54 <ski> there we go
10:20:15 <EvanR-work> i need to post that on the wall in here
10:20:21 <EvanR-work> big time
10:20:46 <ManateeLazyCat> EvanR-work: Have people want buy Haskell IDE? Open Source. :)
10:21:10 <EvanR-work> i like the way you think ManateeLazyCat 
10:21:33 * EvanR-work thinks Zend with a lambda slapped on the side
10:21:44 <ManateeLazyCat> EvanR-work: Maybe someone can buy a beer for me . :)
10:22:10 <shapr> evanton: You could create an unofficial tarfile for Real World Haskell and email the authors. I doubt they'd mind.
10:23:02 <EvanR-work> ManateeLazyCat: also a great idea
10:23:06 <EvanR-work> remote buying someone a beer
10:23:18 <EvanR-work> all that needs to be solved is getting to beer to them
10:23:37 <ManateeLazyCat> EvanR-work: Infact, if someone happy with my program, that's enough, don't need more. :)
10:23:54 <roconnor> class Category (~>) => RealCategory (~>) where
10:23:56 <roconnor>     ($) :: (a ~> b) -> (a -> b)
10:24:00 <EvanR-work> ManateeLazyCat: beerware
10:24:04 <roconnor> ^^ is RealCategory familiar to anyone?
10:24:11 <EvanR-work> replace GPL with that license
10:24:29 <elitheeli> hi,
10:24:56 <ManateeLazyCat> EvanR-work: Hehe. :) I prefer CocoColaWare. :)
10:25:10 <EvanR-work> ManateeLazyCat: gah, no never
10:25:15 <elitheeli> when working with mutable arrays, what does one typically use for a return value from functions that just want to take in an array and change some things?
10:25:54 <EvanR-work> elitheeli: the changed array?
10:26:06 <elitheeli> but the caller would already have that array, right?
10:26:14 <EvanR-work> then IO ()
10:26:18 <ManateeLazyCat> EvanR-work: If have a pure Haskell IE (Intergated Environment, include IDE, but not just for development), do you like?
10:27:05 <EvanR-work> ManateeLazyCat: probably not because i use vim. also i dont have any money, a company, or even an it department
10:27:32 <Entroacceptor> I wonder if you could make a business out of letting people send beer to others over the internet?
10:27:38 <EvanR-work> Entroacceptor: ...
10:27:41 <Entroacceptor> like amazon, just with beers instead of books
10:27:49 <EvanR-work> pay attention!
10:28:05 <EvanR-work> or dont *runs to patent office*
10:28:06 <ManateeLazyCat> EvanR-work: If it include "terminal emulator" in it, then you can use vi in termianl, then ... ?
10:28:17 <dolio> roconnor: So, RealCategories are wide subcategories of Hask?
10:28:32 <roconnor> dolio: I don't know
10:28:40 <EvanR-work> ManateeLazyCat: yes but that already exists doesnt it?
10:28:40 <roconnor> I found it in the comments of http://twan.home.fmf.nl/blog/haskell/cps-functional-references.details
10:29:18 <dolio> They have all the same objects, and every morphism in the RealCategory is a function.
10:30:07 <ManateeLazyCat> EvanR-work: http://farm3.static.flickr.com/2628/3952175905_9295a7421a_o.png
10:30:43 <EvanR-work> wow nice screen
10:30:58 <ManateeLazyCat> EvanR-work: I include "terminal emulator" in my first version, last i remove it.
10:31:11 <ManateeLazyCat> EvanR-work: For rewrite new "terminal emulator" to support MVC design.
10:31:26 <roconnor> dolio: functional references (aka lenses) are a non-trival example of this "RealCategory"
10:31:41 <ManateeLazyCat> EvanR-work: More screenshot at : http://www.flickr.com/photos/48809572@N02/
10:31:52 <roconnor> dolio: every lens can be interpreted as a funcution by looking at the getter function
10:32:57 <EvanR-work> ManateeLazyCat: whats it called?
10:33:08 <ManateeLazyCat> EvanR-work: Integrated Lived Environment.
10:33:17 <ManateeLazyCat> EvanR-work: Named "manatee" for my girl. :)
10:33:24 <EvanR-work> Lived?
10:33:35 <EvanR-work> is this in haskell?
10:33:38 <ManateeLazyCat> EvanR-work: Integrated Environment, but not just for Develop.
10:33:41 <Nibble> EvanR-work: it is indeed
10:33:44 <ManateeLazyCat> EvanR-work: yes, all Haskell. :)
10:33:52 <Nibble> EvanR-work: look at his repo at patch-tag
10:34:03 <Nibble> to make it even cooler
10:34:07 <Nibble> it has sandbox features
10:34:10 <ManateeLazyCat> EvanR-work: https://patch-tag.com/r/AndyStewart/
10:34:15 <EvanR-work> thats pretty cool
10:34:17 <dolio> roconnor: Perhaps equivalent to a wide subcategory, then. Maybe that's even too much, though.
10:34:31 <ManateeLazyCat> Nibble: Yep, sandbox is most important feature in it. :)
10:34:36 <EvanR-work> i have to go to lunch
10:34:40 <Entroacceptor> ManateeLazyCat: btw., do you have docs for it?
10:34:53 <Entroacceptor> it's running for me, but I'm not sure it's running correctly
10:34:55 <ManateeLazyCat> Entroacceptor: 99% time on programming.
10:35:12 <ManateeLazyCat> Entroacceptor: I suggest you pull newest one.
10:35:23 <dolio> That might be invoking the axiom of choice, though.
10:35:33 <ManateeLazyCat> Entroacceptor: I do many refactory work recently, ready to release first version. :)
10:35:53 <ManateeLazyCat> Entroacceptor: When you run it, you will seen "search" interface.
10:36:36 <ManateeLazyCat> Entroacceptor: Then type "file name, application name, irc, url...." to open in your mind. :)
10:36:44 <Entroacceptor> for example, the feed reader doesn't load some websites
10:37:07 <ManateeLazyCat> Entroacceptor: Maybe block my GFW or similar filter system.
10:37:55 <ManateeLazyCat> Entroacceptor: You can change ReaderBuffer.hs content for your own feed. :)
10:38:10 <Entroacceptor> no, it's no firewall
10:38:20 <Entroacceptor> yeah, I should do that :)
10:38:23 <ManateeLazyCat> Entroacceptor: I'm now working on "Customize system".
10:39:01 <ManateeLazyCat> Entroacceptor: Then you can customize it with "graphics interface" or Haskell script, and save your favourious config. :)
10:40:02 <ManateeLazyCat> Entroacceptor: Now, i haven't time write documentation, you can quick hacking extensionKeymap in every extension. :)
10:40:06 <ski> roconnor : hm, any category which `Set' is concrete over ?
10:40:10 <edlinde> hi, with the following code does `vplus` in backticks mean its an INFIX function?
10:40:10 <edlinde> vplus :: (Num t) => Vector t -> Vector t -> Vector t  
10:40:10 <edlinde> (Vector i j k) `vplus` (Vector l m n) = Vector (i+l) (j+m) (k+n) 
10:40:22 <ManateeLazyCat> Entroacceptor: Just try every keystroke and see what happen. :)
10:40:36 <Entroacceptor> ManateeLazyCat: that's the problem, sometimes they do stuff, sometimes not
10:40:42 <db4n> Text.Regex.matchRegex (mkRegex "^[:blank:]*$") "    "
10:40:53 <db4n> How do you eval an expression?
10:41:03 <ManateeLazyCat> Entroacceptor: When first startup reader, it will update feed.
10:41:08 <edlinde> anyone?
10:41:14 <ManateeLazyCat> Entroacceptor: It just show page after feed fetch complete.
10:41:15 <Entroacceptor> f3 works only if I'm in the text box at the top
10:41:36 <ManateeLazyCat> Entroacceptor: Pull newest code. :)
10:41:54 <ManateeLazyCat> Entroacceptor: I think it's global keymap bug in old version. :)
10:42:11 <ManateeLazyCat> Entroacceptor: I have fix (infact, many issues) in recently patches.
10:42:16 <db4n> > Text.Regex.matchRegex (mkRegex "^[:blank:]*$") "    "
10:42:17 <lambdabot>   Not in scope: `Text.Regex.matchRegex'Not in scope: `mkRegex'
10:42:30 <ManateeLazyCat> Entroacceptor: Well, perfect way is fetch feed page for offline view in reader.
10:42:34 <db4n> > Text.Regex.matchRegex (Text.Regex.mkRegex "^[:blank:]*$") "    "
10:42:35 <lambdabot>   Not in scope: `Text.Regex.matchRegex'Not in scope: `Text.Regex.mkRegex'
10:43:09 <ManateeLazyCat> Entroacceptor: There still have Webkit API haven't finish, i will add offline feature in manatee-reader. Then you just need download once, and can re-read news when network disconnect. :)
10:43:36 <Entroacceptor> :)
10:44:11 <ManateeLazyCat> Entroacceptor: In newest version, you don't need re-compile everything, example, you modified ReaderBuffer.hs, you just need do "./repos.sh install manatee-reader".
10:44:49 <ManateeLazyCat> Entroacceptor: Infact, if you don't modified manatee-core, you can running manatee always, and re-compie/re-launch manatee-reader don't need restart manatee. :)
10:45:42 <ManateeLazyCat> Entroacceptor: That's mean, you can like Emacs, modified extension code, and don't need restart manatee to run new version code.
10:45:50 <Entroacceptor> ManateeLazyCat: that's cool
10:46:10 <Entroacceptor> but with gtk2hs-darcs building leksah doesn't work
10:46:13 <maurer_> Is code.haskell.org broken for others, or just me?
10:46:40 <Entroacceptor> maurer_: remember http://downforeveryoneorjustme.com/ :)
10:46:46 <ManateeLazyCat> Entroacceptor: If i have time perfect 'pdynload' package, i even can hot-swapping manatee-core.
10:47:00 <ManateeLazyCat> Entroacceptor: But i think best to release first version, and perfect later.:)
10:47:05 <Entroacceptor> maurer_: down for me, too
10:47:15 <maurer_> Damn.
10:47:32 <Kaidelong> "Could not deduce (Functor m) from the context (MonadRandom m)"
10:47:36 <Kaidelong> first time I've ever seen that
10:47:50 <ManateeLazyCat> Entroacceptor: yep, i know, we fix a "null pointer" bug in gtk2hs that perhaps broken leksah.
10:47:51 <Kaidelong> adding Monad m as a constraint doesn't help either
10:48:17 <ManateeLazyCat> Entroacceptor: Well, after i finish last refactory job, i will release next gtk2hs and help fix Leksah. :)
10:48:23 <mm_freak> Kaidelong: in haskell a Monad is not necessarily a Functor
10:48:41 <mm_freak> if you use both monad and functor functions, you need both Monad and Functor constraints
10:49:09 <Kaidelong> that's nice
10:49:20 <Kaidelong> hmm, but are MonadRandoms ever not functors?
10:49:30 <Kaidelong> I suppose I'd have to look at it
10:49:33 <ManateeLazyCat> Entroacceptor: Now, re-launch new version code, need close/re-open tab, i'm developing "reloadTab" function, just press reload keystroke can update current extension. :)
10:50:02 <Cale> It should be considered a bug if any Monad does not also have an instance of Functor though.
10:50:06 <ManateeLazyCat> Entroacceptor: In newest version, I enable "Google Suggest" in search interface. :)
10:50:13 <Cale> It's trivial to add one with  instance Functor Foo where fmap = liftM
10:50:42 <Cale> It should also be considered a bug if the Functor instance isn't semantically identical to that one.
10:50:56 <aristid> Cale: it would be very nice if haskell supported automatical instance declarations like that
10:51:01 <mm_freak> Kaidelong: it's not really nice, but it's the state of things, unfortunately
10:51:06 <Cale> (Though in most cases, it's pretty hard to write anything else)
10:51:27 <ski> Kaidelong : or use `liftM' instead of `fmap', if possible
10:51:51 <mm_freak> or don't use monad functions, if you don't need to
10:51:55 <ManateeLazyCat> Entroacceptor: When you first time startup manatee, the "search interface" is "global search".
10:52:09 <Cale> aristid: It would be nice, yeah.
10:52:14 <Kaidelong> ski: Okay
10:52:16 <mm_freak> unlike Monad, Applicative is a subclass of Functor
10:52:26 <Cale> aristid: The details of it are complicated though.
10:52:36 <ManateeLazyCat> Entroacceptor: When you open any tab, you can type "M-f" to got "local search", same algorithm as "global search", but different position for tab. :)
10:52:42 <Entroacceptor> :)
10:52:52 <Cale> It would be nice, as a start, if Monad were at least a subclass of Functor, if not Applicative
10:53:19 <ManateeLazyCat> Entroacceptor: Newest tips: when you type M-' close some tab, you can use C-' undo "close action", like Google Chrome's "undo close tab" .:)
10:53:21 <mm_freak> of Applicative, yes, otherwise you would run into the same problem, when mixing Applicative functions with Monad functions
10:53:35 <ManateeLazyCat> Entroacceptor: Well, too many tips, i think i best to write some Wiki page after i release it. :)
10:53:49 <Entroacceptor> ManateeLazyCat: yes, documentation would be very nice 
10:54:01 <Entroacceptor> and I can't hit C-', I have to C-S-#
10:54:05 <ManateeLazyCat> Entroacceptor: My English is bad. :)
10:54:25 <Entroacceptor> that's what opensource is for ;)
10:54:43 <Entroacceptor> gtg
10:54:55 <ManateeLazyCat> Entroacceptor: After "Customised System" finish, you can customise it with your favorites keymap. :)
10:55:18 <ManateeLazyCat> Entroacceptor: About "Customize System", i plan build DSL language to customize option.
10:55:31 <Entroacceptor> afk o/
10:56:02 <ManateeLazyCat> Entroacceptor: Default, manatee-customize read your config file and render with "Graphics customize interface" (keyboard constrol), then anyone can play it.
10:56:31 <ManateeLazyCat> Entroacceptor: Of course, power user can modified Haskell code directly, just like Emacs do.
10:57:25 <ManateeLazyCat> Entroacceptor: I also working on dynamic plugin, you can play new extension after cabal install complete, and don't need restart manatee.
10:57:53 <ManateeLazyCat> Entroacceptor: Then anyone can write *new* extension in 5 minutes, and play/share it, like firefox. :)
10:58:57 <ManateeLazyCat> Entroacceptor: manatee-mplayer work for you?
10:59:24 <ManateeLazyCat> Entroacceptor: Search music directory and do "M-/" select "play directory" :)
11:00:43 <roconnor> Twan van Laarhoven is a genius
11:01:06 <twanvl> I am?
11:01:22 <roconnor> yes
11:01:37 <twanvl> that's good to know
11:01:42 <ManateeLazyCat> Entroacceptor: Best extension now is : manatee-ircclient and manatee-reader.
11:01:43 <roconnor> at least with regards to FunList
11:01:55 <ManateeLazyCat> Entroacceptor: Otherwise extension still in toy state.
11:02:10 <ManateeLazyCat> Entroacceptor: Newest manatee-pdfviewer support "smooth scroll".
11:02:36 <ManateeLazyCat> Entroacceptor: Maybe you need upgrade newest 'poppler' code to fix "memory leak".
11:03:09 <roconnor> twanvl: your FunList is exactly what Uniplate needs in order to be type safe
11:03:10 <ManateeLazyCat> Entroacceptor: In newest gtk2hs-base packages fix many "memory leak".... :)
11:03:38 <ManateeLazyCat> Entroacceptor: Ok, i'm flood you, send mail to me if you have any question about manatee. :)
11:03:58 <twanvl> roconnor: nice, I never knew that
11:05:42 <roconnor> twanvl: what was your motivation for FunList?
11:06:18 <twanvl> I think it was something with functional references, but I don't recall what exactly
11:06:23 <roconnor> ya
11:06:46 <roconnor> there is a connection between Uniplate and lenses that is so strong, I can't believe it wasn't mentiond in the Uniplate paper
11:06:55 <ski> twanvl> :i FunList
11:07:10 <roconnor> uniplate :: (a -> ([a],[a] -> a))
11:07:13 <roconnor> or even better
11:07:22 <roconnor> biplate :: (a -> ([b],[b] -> a))
11:07:30 <roconnor> twanvl: does biplate look familiar?
11:07:30 <ManateeLazyCat> When GHC-7 offline version relase? I seen RC version has released. :)
11:07:34 * ski isn't sure what uniplate is about ..
11:07:53 <ski> roconnor : that's `Lens a [a]' and `Lens a [b]', respectively
11:08:15 <roconnor> except there is a restriction on biplate that the length of the list input to the function in the second position has to be the same as the lenght of the first part of the result.
11:08:26 <ski> oh
11:08:38 <ski> it is trying to "mark several places" in a structure ?
11:08:45 <roconnor> ski: yes
11:08:51 * ski had another idea for that, a while ago :)
11:08:56 <roconnor> ski: but this is exactly the structure that FunList makes
11:09:00 <twanvl> roconnor: this seems to explain where I got the idea: http://twan.home.fmf.nl/blog/haskell/non-regular2.details
11:09:02 <roconnor> data FunList a b
11:09:04 <roconnor>     = Done b
11:09:05 <roconnor>     | More a (FunList a (a -> b))
11:09:25 <ski> instead of
11:09:29 <ski>   a -> ([b],[b] -> a)
11:09:31 <ski> use
11:09:35 <ski>   a -> exists f. Functor f *> (f b f b -> a)
11:10:24 <ski> so if there's only two `b's in your particular `a', you can have `f = Pair', where `data Pair a = P a a', e.g.
11:10:34 <ski> er, missing a comma
11:10:37 <ski>   a -> exists f. Functor f *> (f b,f b -> a)
11:10:47 <twanvl> ski: I would suggest at least Traversable instead of Functor
11:11:10 <ski> so, the only thing the user knows about `f' is that it is a `Functor', so the number of `b's passed back must be the same
11:11:28 <ski> twanvl : yeah .. that could be good, if that's what you want
11:11:54 <ManateeLazyCat> Nibble: BTW, manatee successful install in your box? :)
11:11:59 * ski was only thinking about "parallel-update", at the time
11:12:26 <ManateeLazyCat> ski: I like parallel update. :)
11:12:33 <ski> if you want to express "subtract average", i suppose you need `Traversable"
11:13:03 <zygoloid> ski: have you persuaded any compiler to implement *> yet? :)
11:13:14 <ski> nah :)
11:13:26 * ski looks at `FunList'
11:13:54 <ski> .. oh
11:13:54 <twanvl> I think (exists. Functor f => (f b,f b -> a)) is isomorphic to ((b -> b) -> a), since there is nothing else you can do with it but fmap
11:14:12 <ManateeLazyCat> Okay, coding time. Bye all. :)
11:14:35 <ski> hm, you might be right
11:14:52 <ski> (s/Functor f =>/Functor f *>/)
11:15:16 * ski is trying to understand how/where `FunList' would be used
11:15:53 <twanvl> what does "Functor f *>" mean?
11:16:40 <ski> `->' : `(,)' :: `=>' : `*>'
11:16:45 <roconnor> twanvl: exists is to pairing as forall is to functions
11:17:05 <ski> so `Functor f *> ..f..' means that it contains its own instance for `Functor f'
11:17:30 <ski> as opposed to `Functor f => ..f..', which means that *you* (the caller/user) have to provide the `Functor f' instance
11:17:31 <dolio> ski: As I recall, FunList a b ~ exists n. (Vec n a, Vec n a -> b).
11:17:32 <twanvl> ah, that makes sense
11:17:33 <edlinde> data Maybe a = Nothing | Just a
11:17:43 <edlinde> is this a predefined type in Haskell?
11:17:49 <roconnor> dolio: yes
11:17:51 <mauke> @index Maybe
11:17:51 <lambdabot> Data.Maybe, Prelude
11:17:55 <edlinde> to indicate whether something was found or not?
11:18:06 <roconnor> twanvl: so FunList is ismorphic to type ApplicativeFunList a b = forall f. Applicative f => (a -> f a) -> f b  ?
11:18:09 <ski> dolio : oh, of course .. this makes sense
11:18:14 <edlinde> mauke: when do you use a Maybe?
11:18:25 <ski> edlinde : yes, e.g. that
11:18:28 <mauke> edlinde: when I need it
11:18:33 <ski> also sometimes used for "optional" arguments
11:18:46 <roconnor> twanvl: ah, that is what you say at the bottom of the post
11:19:05 <edlinde> ski: ok so I saw an example of a Map where this was being used to indicate whether something was found in the map or not
11:19:09 <roconnor> that means that uniplate is related to this applicative stuff
11:19:16 <edlinde> ski: would that be a valid use of Maybe?
11:19:43 <ski> yes
11:19:47 <ski> that's a common use
11:20:06 <edlinde> ski: Its just that I was reading about "Either" - left or right 
11:20:09 <edlinde> and it came up
11:20:29 <edlinde> was a but confusing as to when I would use the combination of either and maybe
11:20:45 <edlinde> in LYAH there is a locker example that I was going through
11:20:49 <ski> roconnor : i don't follow how you reach `ApplicativeFunList'
11:21:02 <roconnor> that means uniplate :: b -> forall f. Applicative f => (a -> f a) -> f b
11:21:19 <roconnor> ski: http://twan.home.fmf.nl/blog/haskell/non-regular2.details explains ApplicativeFunLIst
11:21:36 <ski> ok
11:21:52 <edlinde> ski: do you make use of Either a lot?
11:21:55 <roconnor> rearraging we get uniplate :: Applicative f => (a -> f a) -> (b -> f b)
11:22:16 <shapr> Looks like HTk has a GIF datatype. I wonder why it's not cabalized?
11:22:35 <roconnor> which is similar to http://twan.home.fmf.nl/blog/haskell/cps-functional-references.details 's implemenation of a lens as type RefF a b = forall f. Functor f => (b -> f b) -> (a -> f a)
11:23:12 <ski> edlinde : yeah .. when i need to :)
11:24:58 <ski> roconnor,twanvl : this sounds really cool, ty for mentioning it :D
11:26:18 <edlinde> ski: I want to try and code something in Haskell, I want to read in from a file a bunch of index positions like say  (3,5,7) and this should equate to  00010101  in binary bit array. where we have a 1 for every position mentioned 
11:26:48 <edlinde> I then want to be able to do binary operations like XOR, OR etc on this binary string
11:27:00 <mauke> why not use a number?
11:27:04 <edlinde> was wondering if this is possible to do in haskell? and what I should be using?
11:27:12 <ski> are your binary strings sparse ?
11:27:21 <edlinde> yes 
11:27:45 <edlinde> I know the range of values that numbers in the file can take
11:27:52 <edlinde> for example from say 0-9 
11:28:22 <edlinde> so I want to have 10-bit binary vectors from each line I read in from the file
11:28:40 <edlinde> I know I can do this easily in C ... but I want to learn how to do things like that in Haskell 
11:29:02 <dagle> edlinde: Sounds like you want to program C in haskell.
11:29:03 <mauke> only 10 bits? that can't be sparse
11:29:22 <edlinde> mauke: ok that was just an example
11:29:34 <mauke> will you have more than 1000 bits?
11:29:36 <edlinde> dagle: so you suggesting to do that exercise in C?
11:29:43 <edlinde> no mauke 
11:29:53 <mauke> so I'd use an Integer
11:29:55 <edlinde> well lets say maybe
11:30:00 <edlinde> ok
11:30:13 <edlinde> can you do bitwise XOR,OR,AND etc on integers?
11:30:30 <alej> Data.Bits I tihnk?
11:30:33 <alej> or is that Int
11:30:56 <edlinde> I notice ski hasn't said much
11:30:58 <edlinde> :)
11:31:01 <alej> Data.Bits has those operations defined for Num
11:31:38 <Lemmih> edlinde: Yes you can.
11:31:58 <edlinde> so I can in theory read in the positions from the file and generate bit vectors from them?
11:32:03 <edlinde> using Data.Bits?
11:32:24 <edlinde> should I read in the positions as a list? or tuple?
11:33:13 <ski> edlinde : someone was talking to me .. and others seem to give good suggestions :)
11:33:31 <edlinde> hehe fair enough
11:33:44 <ski> a list (or maybe some custom type ?), i think
11:33:54 <ski> not a tuple
11:34:16 <ski> (unless you know statically that you'll always have exactly `n' ones, for some value of `n')
11:34:22 <edlinde> ok its just a bit confusing as to how I can then convert this list of positions into it's equivalent binary string or Bits string
11:34:44 <edlinde> no I think list would be the way to go .. you are right
11:34:52 <edlinde> tuple wouldn't work in this case
11:36:07 <edlinde> and also you said I cannot have a hash table in Haskell yeah?
11:36:19 <edlinde> I mean the data is immutable so I can only use a Map?
11:37:37 <ski> @hoogle HashTable
11:37:37 <lambdabot> module Data.HashTable
11:37:37 <lambdabot> Data.HashTable data HashTable key val
11:37:59 <edlinde> ah awesome
11:38:00 <edlinde> nice 
11:38:13 <Lemmih> edlinde: You /can/ use a hashtable but you really don't want to.
11:38:15 * ski has never used that
11:38:31 <edlinde> why not?
11:38:35 <edlinde> are there alternatives?
11:38:38 <roconnor> twanvl: so the idea is that forall f. Functor f => (b -> f b) -> (a -> f a) is a lens and forall f. ApplicativeFunctor f => (b -> f b) -> (a -> f a) is a ...?
11:38:47 <companion_cube> is there a weak hashtable somewhere ?
11:38:55 <ski> @hoogle [(k,v)] -> HashTable k v
11:38:56 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
11:38:56 <lambdabot> Data.Array.IArray (//) :: (IArray a e, Ix i) => a i e -> [(i, e)] -> a i e
11:38:56 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
11:38:57 <edlinde> say you wanted to do some sort of frequency counter ... how would you do that?
11:38:57 <companion_cube> if someone wants to do hashconsing ?
11:38:59 <buntfalke> Why are there so many .c files in the ghc/rts/ folder? Is this for performance reasons? Hmmm...
11:39:03 <Lemmih> edlinde: Data.Map is superior in nearly all aspects.
11:39:14 <ski> right, `HashTable' is mutable, in `IO'
11:39:37 <ski> edlinde : usually you want to avoid `IO', when you don't need it
11:39:40 <edlinde> Lemmih: ok can I do something like... I have already got some key in my hash that matches, so increment the value by 1
11:39:41 <edlinde> ?
11:39:59 <Rembane> edlinde: sort, group, zip basically.
11:40:02 <Lemmih> edlinde: Yes.
11:40:24 <Lemmih> edlinde: You make a new map with the increased value.
11:40:35 <edlinde> so in a Map I can basically lookup a key and "increment" the value field by 1 -> to do a frequency count?
11:40:52 <mauke> insertWith (+) k 1 map
11:40:56 <Lemmih> buntfalke: It's not really feasible to write the RTS in anything but C.
11:40:57 <edlinde> isn't that more expensive?
11:41:37 <Cale> edlinde: Changing one value in a Map is an operation which is logarithmic in the size of the Map
11:41:37 <Lemmih> edlinde: Don't concern yourself with that. Deal with it if it becomes a problem (and it won't).
11:42:04 <buntfalke> Lemmih: Why not have a a defined interface which abstracts from every communication to the C world, write that in C, and do the rest through it?
11:42:08 <edlinde> ok is the map some sort of tree structure behind the scenes?
11:42:14 <mauke> edlinde: yes
11:42:18 <edlinde> ah ok gotcha
11:42:19 <Cale> edlinde: This is because a Map is internally a balanced tree, and only vertices surrounding the path to the root need be replaced, and the rest of the structure is shared.
11:42:21 <edlinde> then it should be fine
11:42:32 <edlinde> ok that makes sense thena
11:42:46 <edlinde> as long as the entire map doesn't get copied :)
11:42:49 <edlinde> ok thanks
11:44:28 <Lemmih> buntfalke: What? The stuff in the RTS is very tightknit and has to be very fast.
11:46:09 <Lemmih> buntfalke: How much do you know about the RTS?
11:46:09 <buntfalke> Okay, so it is performance after all :-)
11:46:45 <buntfalke> Very little. Essentially, all I know is what it's there for.
11:47:11 <buntfalke> In the first place i wondered why ghc isnt mostly selfhosting like gcc et cetera.
11:47:35 <Lemmih> buntfalke: Not just performance. No one really knows how to write the RTS in a high-level langauge.
11:48:05 <buntfalke> That question in turn arose from: "Why can't there simply be a -fno-hosted switch for ghc to produce standalone code somehow."
11:48:34 <Lemmih> Standalone code?
11:48:42 <buntfalke> like kernel code
11:49:07 <djahandarie> So, what's considered the hip Haskell webapp framework/library these days? Still snap? Or yesod?
11:49:53 <sm> yesod for most needs, snap if you only want a performance-focussed http server
11:50:01 <Lemmih> buntfalke: That's what they did with House: http://programatica.cs.pdx.edu/House/
11:50:01 <buntfalke> Lemmih: Well. Can't there be a defined interface to the c world, which is implemented in c, then binded via ffi (for instance) and which does whatever we need in a nice haskellish fashion to implement - say - the RTS?
11:50:13 <buntfalke> yes, i know house, hop, kinetic, et cetera
11:50:49 <Lemmih> buntfalke: I don't understand your question.
11:51:10 <Lemmih> buntfalke: You know Haskell uses automatic memory management, right?
11:52:03 <Lemmih> buntfalke: That means we need a garbage collector. Writing such a garbage collector in Haskell is hard. Writing it in C is easy.
11:52:53 <FauxFaux> I frequently find myself writing basecases of a [] = []; or a b = b; -- is there a shorthand for either?
11:52:53 <Lemmih> (for academic meanings of the words "hard" and "easy")
11:52:57 <buntfalke> Hmm...maybe I should simply try to do it, to see why it is hard. I can't really imagine the obstacles (though, sure, i bet they are there)
11:53:41 <Lemmih> buntfalke: How would you implement the GC in Haskell?
11:54:05 <Lemmih> FauxFaux: id?
11:54:20 <jmcarthur> i've implemented a gc in haskell, but it was not intended to gc haskell itself
11:54:30 <jmcarthur> it was just for experimentation
11:54:43 <Lemmih> jmcarthur: That's where the problem lies.
11:55:43 <sm> on another topic.. hi Lemmih, are you still maintaining hssdl ?
11:56:10 <jmcarthur> it would be cool if FFI stuff was actually a DSL that compiled down to native code instead of being managed by the RTS at all
11:56:40 <jmcarthur> i bet there's a feasible API that could make that workable, waiting to be discovered
11:56:41 <Lemmih> sm: Oh right, you sent me a patch.
11:56:46 <manateeUser> Good night all. :)
11:56:47 <Lemmih> jmcarthur: What FFI stuff?
11:56:58 <jmcarthur> Lemmih: all of it, that is
11:57:07 <jmcarthur> "the FFI"
11:57:11 <sm> Yeah. I've been spending time on getting to work on OSX leopard. Status: mostly working. What are the prospects for polishing up remaining installation hassles ?
11:57:23 <raceRider> fastest way to check for the existence of a character in a string value? Char->String->Bool
11:57:31 <mauke> @hoogle Char->String->Bool
11:57:32 <lambdabot> Prelude elem :: Eq a => a -> [a] -> Bool
11:57:32 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
11:57:32 <lambdabot> Data.List elem :: Eq a => a -> [a] -> Bool
11:57:33 <Lemmih> jmcarthur: The RTS doesn't have much to do with the FFI.
11:57:41 <sm> I assume you're still interested in the project
11:57:42 <jmcarthur> Lemmih: what i mean is when you "write C in haskell"
11:58:18 <jmcarthur> it's essentially stuff that could just be written in C and bound as a single function instead of binding to several C functions
11:58:25 <Lemmih> jmcarthur: When did I say that? (:
11:58:30 <sm> and by the way, thank you, once installed it's great
11:58:50 <jmcarthur> Lemmih: you didn't. the quotes were meant to imply that others have said it in the past
11:59:02 <jmcarthur> i'm not really trying to be exactly on topic here :)
11:59:32 <buntfalke> Lemmih: let's stick to malloc/realloc/free for a moment. say if i got that in haskell, a GC wouldn't be too hard anymore (i assume). now, to implement those, I'd need to be able to issue the appropriate syscalls. The minimal set of syscalls to do so is propably only sbrk or something like it, so i would abstract from it via FFI to haskell and do the rest in haskell
12:00:37 <buntfalke> Lemmih: In a similar fashion, i'd proceed with all tasks the rts needs to perform, hopefully ending up with a single libCtoHaskell which I need to FFI in to get the job done. where would that fail?
12:00:45 <jmcarthur> but anyway, what made me think of it is that an API like that *might* make it possible to write parts of the RTS as a haskell DSL. it could maybe enforce a sort of phase-distinction, for lack of a better word
12:00:58 <jmcarthur> basically the DSL would have to be interpreted by the compiler though
12:01:51 <EvanR-work> sbrk is pretty minimal
12:01:53 <Lemmih> buntfalke: The RTS is needed to execute Haskell code. If the RTS needs Haskell to run and Haskell needs the RTS to run, you're in a bind.
12:02:05 <EvanR-work> since ghc can return memory to the system, im thinking its got to be using mmap
12:02:30 <Lemmih> buntfalke: I don't think you fully comprehend what role the RTS plays.
12:02:52 <buntfalke> Lemmih: No, cause I could take the existing RTS to execude GHC to build the new RTS. it's like bootstrapping GCC. you need a couple of "generations", but at some point you're done
12:03:05 <buntfalke> Lemmih: No, I surely dont :-)
12:03:14 <jmcarthur> oh buntfalke is also thinking of something with phase distinction
12:03:50 <Lemmih> buntfalke: You need the code to execute Haskell. You cannot bootstrap your way out of it.
12:03:58 <buntfalke> As I said before - i dont /doubt/ you're right - i just cannot see it, for lack of understanding
12:04:35 <EvanR-work> Lemmih: you could define the interpreter to execute on itself
12:04:44 <EvanR-work> but nothing would terminate ;)
12:05:32 <Lemmih> buntfalke: You might find it helpful to read about the eval/apply evaluation model.
12:08:13 <Lemmih> sm: Thanks, applied.
12:08:22 <buntfalke> Hmmm...so the GC would need itself to do the job in the end. How exactly is that a problem...hm.
12:09:21 <buntfalke> Lemmih: you happen to have a reference handy already? on eval/happy?
12:09:23 <Lemmih> buntfalke: To execute Haskell code you need a working GC. To get a working GC you need to execute Haskell code. Deadlock.
12:09:59 <dagle> I think the problem is that you need a GC for the GC.
12:10:12 <Lemmih> buntfalke: I thought there was something about on the wiki. Hm. The paper by SPJ is a bit dry.
12:10:29 <EvanR-work> gc gc itself!
12:10:41 <dagle> Then you need a gc gc gc!
12:10:51 <EvanR-work> no thats the point of the gc of itself
12:11:02 <EvanR-work> closed loop
12:11:08 <dagle> Aha.
12:12:18 <Raelifin1> If I have a data type which has many parameters, and I want a copy of that type with just one parameter changed, is there a syntactically pretty way to do it?
12:12:28 <magicman> > fix gc
12:12:29 <lambdabot>   Not in scope: `gc'
12:12:32 <magicman> Aww :(
12:12:39 <buntfalke> well. assuming the mere startup of the RTS wouldnt excause memory already, once we're up and running, it could be self-cleaning, no? I just don't get the point...
12:13:06 <mauke> buntfalke: I don't see how
12:13:23 <EvanR-work> Raelifin1: refactor the types
12:13:23 <mauke> if your garbage collector allocates memory, you're pretty much screwed, no?
12:14:36 <monochrom> if you use the record syntax for your data type, you can change one parameter easily. example: "data Me = We{ dexter :: Bool, sinister :: Char }", now you can write "y = x{dexter=False}"
12:14:56 <Raelifin1> Ah, I think that's what I was looking for.
12:15:12 <buntfalke> mauke: No, because you do not have to have the parallel background cleanup job running right from the start. When you start executing, first have one thread fork away to start do that, next have the rest continue starting. so the only period where there's no cleanup taking place is until that fork. what point do i miss?
12:15:48 <buntfalke> well anyway. i'll figure it out some day.
12:15:49 <buntfalke> :-)
12:15:50 <mauke> buntfalke: the part where the cleanup allocates memory
12:16:20 <Lemmih> buntfalke: The RTS is not something that runs in the background.
12:17:26 <buntfalke> mauke: well, then allocate enough memory at first to have the RTS fit in using C.
12:17:56 <EvanR-work> sounds like java! ;)
12:18:00 <buntfalke> after that first exceptional allocation, you're fine.
12:18:20 * dcoutts_ doesn't think this GC/FFI/RTS discussion makes any sense 
12:18:24 <EvanR-work> hello world, ok, allocate 50M of rts
12:18:27 <buntfalke> Well. I don't see why that's so bad. it's just bootup code. like the few assembly lines in every kernel.
12:18:32 <Lemmih> buntfalke: That is actually an option although it is completely in feasible.
12:18:44 <buntfalke> hmm.
12:18:46 <buntfalke> :/
12:19:35 <buntfalke> Lemmih: Why? Wether the RTS allocates it's memory itself using it's c files, or wether it's done the way i just proposed - the result is the same, no?
12:20:17 <Lemmih> dcoutts_: There's a lot of confusion going around but the idea of writing parts of the RTS in a higher level language than C is interesting.
12:20:50 <dcoutts_> Lemmih: ah that's what they're talking about
12:21:18 <buntfalke> Well. That's where it all at least.
12:22:02 <Lemmih> buntfalke: Let's focus on the GC. The other parts of the RTS are irrelevant for now.
12:22:20 <dcoutts_> it'd need to be a level where you have control over resources
12:22:39 <buntfalke> Lemmih: Okay. So say I'd allocate enough for the GC to fit in once at the beginning using C. Why is that a silly idea?
12:22:58 <dmwit> Is there a canonical use case example for Either other than as modeling errors or exceptions?
12:23:10 <Lemmih> buntfalke: The GC might use an arbitrary amount of memory.
12:23:26 <dcoutts_> dmwit: I don't think canonical, there are too many diverse uses for there to be a canonical one imho
12:23:44 <buntfalke> Lemmih: Only with time. The amount of memory it needs until it is first called by someone should be static and finite.
12:23:48 <EvanR-work> dmwit: whenever you need one of two possible results
12:24:02 <Lemmih> buntfalke: It doesn't need /any/ memory until it is run.
12:24:23 <dmwit> hm
12:25:00 <dmwit> Enumerations, I suppose, are another common use case.
12:25:09 <dmwit> (I guess I'm really talking about sum types in general, not just Either, here.)
12:25:37 * ski thinks light-weight variants would be useful ..
12:25:53 <EvanR-work> dmwit: thats like everything in haskell, Maybe, [], etc
12:25:55 <buntfalke> Lemmih: Well. I take C. I allocate x MiB for the GC code fit's in. now some function needs memory, it calls the GC to do the job. the GC talks to the beforementioned FFI interface to issue an abstracted-from syscall to get the needed memory. it will now do the same if it needs memory itself. problem solved.
12:26:11 <dmwit> EvanR-work: Non-recursive sum types...
12:26:21 <dmwit> I don't think there are actually that many.
12:26:32 <ski> (also sum/variant types is not the same as algebraic data types)
12:26:32 <EvanR-work> in the standard library? well i use them all the time
12:26:36 <dmwit> Maybe is one, as you say.
12:26:55 <EvanR-work> whether or not defined already
12:27:19 <EvanR-work> its good when you want to be more expressive in your api
12:27:23 * dmwit ponders what the inr lens would do for 1 + A
12:27:28 <Lemmih> buntfalke: The GC cleans the heap. It isn't responsible for memory allocations.
12:28:05 <EvanR-work> well, a sane gc exposes an allocation mechanism
12:28:22 <buntfalke> Lemmih: all it you need is a place for the GC code itself to reside in. once you got that loaded, all further haskell code can call upon it. so get some memory for it using C, to work around the problem.
12:28:23 <EvanR-work> i guess youre talking about lowest level of 'allocation'
12:28:26 <EvanR-work> brk
12:28:30 <dcoutts_> buntfalke, Lemmih: it's pretty clear you could use a higher level language than C for implementing a GC, the question is what are the essential features and what are the features you'd not want in such a language.
12:28:30 <ski> dmwit : using `LensM a b = a -> Maybe (b,b -> a)' ?
12:28:58 <dmwit> LensM a b = exists s. (a -> State s b, b -> State s a)
12:29:00 <dmwit> plus some laws
12:29:39 <dmwit> Lens a b = exists s. { putr :: a -> State s b, putl :: b -> State s a, missing :: s } -- more accurate
12:29:44 <Lemmih> dcoutts_: We're talking about using Haskell to implement the GC.
12:30:11 <EvanR-work> youd have to have a haskell that didnt need a gc first
12:30:28 <dcoutts_> Lemmih: right, that's pretty silly given that you need automatic memory management for so many features in Haskell. Something FPish but a bit lower level otoh is quite plausible.
12:30:45 <Lemmih> dcoutts_: Right! That's what I'm trying to explain.
12:30:48 <dcoutts_> e.g first order FP without let
12:31:33 <jmcarthur> EvanR-work: or a DSL that is treated specially by the compiler
12:31:34 <dcoutts_> Lemmih: right, not just silly but also pretty pointless :-)
12:31:35 <dmwit> I guess I'll go with exceptions (possibly in the form of Maybe) for this explanation.
12:31:44 <jmcarthur> which could be embedded inhaskell
12:31:47 <jmcarthur> *in haskell
12:32:15 <Lemmih> buntfalke: Things don't work that like. You do not need to load the code manually.
12:32:53 <EvanR-work> i dont like the terminology exceptions to mean normal an expected results of a function, as in Nothing
12:34:16 <buntfalke> Lemmih: hmm, Well. Thanks for the patience so far... I propably better give up at it for now and read further first :-)
12:34:23 <EvanR-work> exceptional errors i think should only occur as a result of microcontrollers exploding, usual environment is missing, tcp error
12:34:33 <dmwit> well
12:34:34 <EvanR-work> moon crashes into the earth
12:34:42 <EvanR-work> and the program shouldnt normally handle any of it
12:34:48 <dmwit> "error" instead of "exception"?
12:34:49 <EvanR-work> unless it wants to
12:35:07 <Lemmih> dcoutts_: Btw, in LHC I'm using Haskell to generate the GRIN that implements the GC. I think that's the closest one can get to writing the GC in Haskell.
12:35:09 <dmwit> No, I guess you're claiming "error" isn't the right term either.
12:35:25 <EvanR-work> dmwit: well, key in a Data.Map not found isnt really an error
12:35:31 <dmwit> right
12:35:43 <dcoutts_> Lemmih: right, makes sense, you're generating a language that has a clear operational model wrt allocations
12:35:44 <dmwit> Okay, that's a great example of Maybe.
12:35:52 <Lemmih> buntfalke: Good luck. Playing around with these systems is a lot of fun.
12:36:12 <EvanR-work> dmwit: exceptional error is a good term, for something
12:36:16 <dmwit> ...that's a really wonderful example, actually.
12:36:25 <EvanR-work> something programs shouldnt normally handle
12:36:33 <EvanR-work> since theres too many could happen
12:36:36 <buntfalke> Lemmih: thanks :-)
12:36:52 <sm> Lemmih: thanks (for applying). Did you see my questions above ? I asked at a bad time
12:37:24 <Lemmih> sm: I must have missed it.
12:37:48 <EvanR-work> dmwit: a parser could legitimately report an 'error' with the input
12:38:22 <dmwit> Yes, that was the kind of thing I was thinking of.
12:38:22 <EvanR-work> and its not exceptional
12:38:55 <sm> basically, are you still the maintainer (yes, obviously) and able/interested in going further ? What are the prospects for polishing up remaining installation hassles ? I have been putting time into getting it working on OSX leopard, and it's almost but not quite there. And, once installed it's great - thank you
12:39:43 <dmwit> So, if we had a lens from (X <-> X+Y), where we're thinking of Y as describing errors, it would have to try to produce a sane X in error-condition Y sometimes. inl in particular would just look in its past and return the last error-free X it saw.
12:39:44 <Lemmih> sm: Yes and yes. The installation hassles on mac? You're welcome. (:
12:39:48 <dmwit> Does this seem like sane behavior to you?
12:40:21 <EvanR-work> no
12:40:42 <EvanR-work> but i dont know lenses
12:40:48 <dmwit> hm
12:40:56 <EvanR-work> scrambling to do *something* in the case of an error sounds like php
12:40:59 <dmwit> I asked the wrong question. =)
12:41:27 <dmwit> "Can you imagine a more sane behavior?" would be better.
12:41:41 <dmwit> Well, you're free to write a lens that results in an X+Y type, of course.
12:41:49 <EvanR-work> yes
12:41:57 <dmwit> But we'd like to provide some ways of doing something with sums -- e.g., handling errors.
12:43:09 <sm> Lemmih: one is you need to prepend LDFLAGS=-L/opt/local/lib to cabal install SDL-gfx --extra-lib-dirs=.... etc. I haven't seen this documented anywhere, indeed there's no website for hsSDL beyond the very stale wiki page
12:43:36 <dcoutts_> Lemmih: I was wondering if the sdl packages need ./configure scripts any more?
12:43:59 <pumpkin> dcoutts_: did you get my @ask?
12:44:07 <dcoutts_> pumpkin: no
12:44:08 <pumpkin> oh I guess it was to dcoutts minus the _
12:44:18 <dmwit> Anyway, at least the context of "errors" gives me some language to use to describe the lens -- even if it the lens I'm describing seems odd in some cases. =)
12:44:37 <EvanR-work> arent lenses for accessing data
12:44:58 <pumpkin> dcoutts_: was just wondering what it took to get Tuegel's cabal test stuff. I've compiled cabal and cabal-install HEAD and it still says that "test-suite" is an unrecognized directive
12:44:59 <Lemmih> dcoutts_: Really? Go on.
12:45:08 <EvanR-work> in a data structure
12:45:28 <sm> Lemmih: the other, which I haven't been able to solve, is /Users/simon/.cabal/lib/SDL-0.6.2/ghc-6.12.3/HSSDL-0.6.2.o: unknown symbol `_SDL_FreeSurface' errors when linking (during cabal build or ghci), but links fine via ghc --make
12:45:30 <dmwit> They can be.
12:45:35 <dmwit> But what if they could do more??
12:45:52 <dmwit> What if they could convert between two data structures?
12:46:16 <dcoutts_> Lemmih: if it's just for checking if C libs exist then it's not necessary and I think cabal produces better error messages for that now than configure scripts. It also respects the --extra-lib-dirs flag.
12:46:50 <dcoutts_> pumpkin: it's in Cabal HEAD or 1.10 branch, the 1.10 branch works with cabal-install HEAD
12:47:03 <EvanR-work> dmwit: converting in an error prone way?
12:47:08 <EvanR-work> fix the data structures ;)
12:47:10 <dcoutts_> pumpkin: sounds like you're using the wrong syntax
12:47:15 <pumpkin> dcoutts_: hmm, interesting. I must've done something interesting
12:47:23 <EvanR-work> parsing is done on text, which is a poor data structure
12:47:27 <pumpkin> dcoutts_: oh, I couldn't find any documentation on it so I was going by his video presentation at icfp :P
12:47:39 <dmwit> EvanR-work: You don't always get to choose the data structures -- e.g. when you're getting data from somebody else in a format different from the one you want to use.
12:47:47 <dcoutts_> pumpkin: I think the syntax in his slides are right
12:48:00 <pumpkin> hmm, I copied it straight from the video
12:48:06 <pumpkin> I'll try again on this computer
12:48:11 <EvanR-work> dmwit: if someone else is you in another module, then id say it could be a exception
12:48:17 <EvanR-work> since you can fix it
12:48:18 <Lemmih> dcoutts_: The configure script calls SDL_CONFIG (sdl-config or sdl11-config) to get libs and cflags.
12:48:31 <dmwit> EvanR-work: That's my point. Someone else might not be you in another module.
12:48:38 <Lemmih> sm: Hm, that is very weird. Too bad I don't have a mac.
12:48:41 <EvanR-work> dmwit: yeah so i would crash and burn
12:48:54 <EvanR-work> "this isnt supposed to happen, if it does, find Bob and berate him"
12:48:56 <dcoutts_> Lemmih: so I see, does that ever return anything other than -lSDL? I note that -lpthreads is unnecessary since SDL links to pthreads.
12:49:18 <dcoutts_> Lemmih: it's also possible to do that in the Setup.hs
12:49:39 <dmwit> EvanR-work: For one use case, there's several standard formats for storing DNA data. They don't all have the same kinds of information of them.
12:49:59 <dmwit> EvanR-work: What if your collaborator has gigs of data in one format, and you've got gigs of data in another format... and you want to work together?
12:50:12 <dmwit> You don't just throw your hands up in disgust and blame it on Bob.
12:50:31 <dcoutts_> pumpkin: feel free to post your example .cabal file
12:51:11 <Lemmih> dcoutts_: The path to the SDL header files is needed. We get that with --cflags.
12:51:14 <pumpkin> dcoutts_: I'll make sure it isn't (obviously) PEBKAC first, but need to finish setting up this computer
12:51:34 <dcoutts_> Lemmih: there are other examples around that use foo-config style programs, lemme find you one
12:52:28 <dmwit> anyway
12:53:23 <EvanR-work> dmwit: you gotta agree on a common format
12:53:47 <dmwit> I've got programs that munge one format. You've got programs that munge another program. Those programs took man-years to build and test.
12:53:52 <dmwit> What now?
12:54:07 <dmwit> Do you spend one week writing a conversion program, or do you spend man-years rewriting the mungers?
12:54:18 <tg_> fund a superset of the two formats
12:54:20 <tg_> convert
12:54:28 <dmwit> Yes, exactly. You convert.
12:54:46 <zomg> I'm not sure if it should be called a man-year
12:54:49 <zomg> more like a nerd-year
12:54:50 <tg_> use lenses?
12:54:57 <dmwit> tg_: Bingo!
12:55:02 <dmwit> =D
12:55:28 * dmwit sticks his tongue out at EvanR-work
12:57:03 <dmwit> Anyway, yeah, there are actually lenses for converting between genomic data formats. So that's really cool.
12:57:30 <dmwit> And I really believe lenses are a good idea.
12:57:43 <dmwit> Whether lenses that operate on sum types are a good idea, I'm not as confident about.
12:57:50 <tg_> well
12:57:52 <dmwit> But I think at least it's an idea worth exploring. =)
12:57:55 <tg_> you can't mitigate the cost of conversion
12:58:12 <tg_> speaking of lenses
12:58:20 <tg_> I was going to say earlier (but didn't) when the rpm package on hackage appeared
12:58:44 <tg_> that Haskell would be a good language to rewrite puppet (currently in a DSL parsed by ruby)
12:58:57 <tg_> they already have an augeas backend
12:58:59 <tg_> which uses lenses
12:59:04 <dcoutts_> Lemmih: take a look at HDBC-postgresql or HDBC-mysql, see also ccLdOptionsBuildInfo from Cabal's D.S.Configure module.
12:59:28 <sbrg> www.learnyouahaskell.com 
12:59:33 <sbrg> www.realworldhaskell.org
12:59:35 <sbrg> = same length
12:59:38 <sbrg> mind = blown.
12:59:52 <dmwit> tg_: Only "cute cat" could be a worse name (in terms of Google-ability) than "puppy". Link me to some more info?
13:00:09 <dmwit> (I'm very interested in lenses, in case you couldn't tell. =)
13:00:21 <tg_> i actually worked on a project that I called puppy
13:00:28 <tg_> for puppet
13:00:35 <dmwit> oh, puppet
13:00:35 <tg_> a git/ldap based backend
13:00:39 <dmwit> I feel like an idiot.
13:00:43 <sm> Lemmih: http://gist.github.com/658752 is a small test that reproduces (the symptom of) my SDL issue. I assume this succeeds on your platform. If there's another  OSX+macports+SDL user out there, I'd appreciate your trying it
13:00:50 <tg_> rightfully so.
13:00:53 <tg_> why do you feel like an idiot?
13:00:54 <tg_> lol
13:01:17 <dmwit> I misread "puppet" as "puppy". =P
13:01:17 <dcoutts_> Lemmih: btw, what's the reason for the pthreads hack?
13:01:49 <EvanR-work> dmwit: no you dont spend forever on a full feature conversion suite
13:02:06 <Lemmih> dcoutts_: You know, I don't remember.
13:02:08 <tg_> dmwit: check out puppet
13:02:16 <tg_> and/or augeas (which if you like lenses I reckon you know about)
13:02:29 <dmwit> Yeah, I was aware of augeas.
13:02:45 <EvanR-work> dmwit: i dealt with this in midi files, you have your sequence structure, and you have zillions of midi files
13:02:53 <EvanR-work> you read in the midi file the best you can
13:03:04 <EvanR-work> no way to deal with every possibility
13:03:09 <EvanR-work> i think wav files are the same way
13:03:13 <EvanR-work> best effort
13:03:28 <dcoutts_> Lemmih: if you remember or find out then perhaps it's something we need to do globally rather than on a per-package basis
13:03:38 <EvanR-work> anyway this is a parsing problem not a conversion problem
13:03:52 <dcoutts_> Lemmih: I bet that most uses of -lpthreads are wrong for Haskell bindings
13:03:53 <dmwit> Perhaps you're right. Perhaps it will turn out that nobody wants sum types when writing lenses. But if they're not available, we'll never know, and we've already worked out how to deal with them.
13:03:56 <EvanR-work> you define your language, and its a subset of the stupid file formats
13:03:58 <tg_> isn't this a ... rendering... problem?
13:03:58 <dmwit> The only question now is how to explain them.
13:04:47 <tg_> you're discussing comparing midi content to wav content?
13:04:50 <EvanR-work> dmwit: so this is about sum types in lenses
13:04:52 <dmwit> As for your "best effort" statement: that is exactly what the injection lenses does. I'll probably even use that term in the explanation.
13:05:00 <EvanR-work> which must have a two way signature
13:05:06 <dmwit> Yes.
13:05:21 <EvanR-work> so we now stop talking about errors ;)
13:05:31 <tg_> EvanR-work: you can get the wav -> [intermediate] stage, and use the tagging tech that's out there
13:05:35 <dmwit> eh?
13:05:48 <EvanR-work> why are we talking about errors if its a question sum types in lenses
13:05:55 <tg_> I don't know how you get from that -> midi
13:06:19 <EvanR-work> tg_: i was not relating wav to mid other than the file formats are screwy
13:06:19 <dmwit> The top two uses of sum types seem to me to be errors and enumerations.
13:06:25 <Lemmih> dcoutts_: What does it buy me to implement the configure script in Haskell? (other than the smug satisfaction of eating my own dog food, of course.)
13:06:29 <dmwit> We've got a nice way to do the latter, so I won't bother with that.
13:06:54 <EvanR-work> so you have a nice way to deal with sum types in general?
13:06:55 <sm> Lemmih: just working on more platforms ?
13:06:58 <EvanR-work> or only one particular use of them
13:07:43 <tg_> dmwit: what are you trying to do, ultimately?
13:07:46 <tg_> I haven't been following so closely
13:07:59 <dmwit> We've got equivalents of (+++), either, Left, and Right.
13:08:04 <sm> ie currently use of configure prevents SDL installation on mac and windows
13:08:27 <dmwit> :t (+++) -- just to make sure I said the right one
13:08:28 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
13:08:30 <sm> without special knowledge, I mean
13:08:33 <dmwit> yep
13:08:53 <Lemmih> sm: How so?
13:08:57 <dmwit> tg_: I'm trying to work out how to motivate and explain "inl" in the lens paper I'm working on (you can see a draft at dmwit.com).
13:09:45 <aristid> damn, i don't know how to deal with the monads-fd vs monads-tf solution, and just using monadLib doesn't work anymore :/
13:09:56 <sm> Lemmih: on mac, it breaks unless you know the incantation I just told you about. On windows, you don't have configure unless you're a hacker
13:10:36 <dcoutts_> Lemmih: it means the behaviour and error messages are consistent, it means it respects the --extra-lib-dirs flag.
13:10:49 <dcoutts_> Lemmih: oh and it might help with windows too
13:12:07 <tg_> dmwit: oh, you wrote this paper?
13:12:42 <dmwit> I'm one of three, yeah.
13:12:43 <tg_> dmwit: how long ago was the this first available (say, on reddit)?
13:12:53 <dmwit> oh, um.
13:13:14 <dmwit> I would guess at least Benjamin put it on his website the same day we submitted it.
13:13:17 <dmwit> so...
13:13:41 <dmwit> two, three months?
13:13:53 <tg_> yeah, ok..
13:13:59 <Lemmih> sm: Would implementing the same code in Haskell make it work on mac?
13:14:02 <tg_> I think I have read some (if not most) of this paper
13:14:27 <tg_> i'll read it again and see if I have anything to contribute
13:14:39 <tg_> to your 'inj' thing
13:14:47 <dmwit> Well... cool!
13:15:27 <sm> I think it would help, pure haskell solutions are always more platform-robust. It would avoid this particular blocker (configure not aware of cabal's full build options).
13:16:00 <sm> I would point you to the trac issue for that last, btw, but I can't find it
13:17:05 <tg_> dmwit: I'm a physicist too, so hopefully I won't make mistakes with analogies with tensors and optics, lol.
13:17:16 <dcoutts_> sm: do you know what goes wrong and why?
13:17:26 <dmwit> =)
13:17:30 <sm> yes, we discussed it the other day remember
13:17:38 * dcoutts_ does not recall
13:17:46 <Lemmih> sm: Alright then. I'll be eagerly awaiting the patches. (:
13:17:51 <sm> configure doesn't know about --extra-lib-dirs
13:17:53 <dmwit> tg_: I guess most physicists deal with tensors that have much more than just tensor structure, right?
13:18:18 <tg_> dmwit: sure. metricity. all kinds of symmetries
13:18:18 <dcoutts_> sm: I don't see how that related to the gist you posted.
13:18:30 <dmwit> tg_: But if you're used to drawing wiring diagrams, your intuitions in that space should steer you well here, too.
13:18:39 <dcoutts_> sm: the --extra-lib-dirs is about failing at configure time, but that bug was about linking later
13:18:46 <sm> dcoutts_: we were discussing two separate issues
13:18:52 <dcoutts_> ok
13:19:32 <dmwit> (I was just asking a few days ago whether there was a nice text representation for wiring diagrams, actually.)
13:20:24 <tg_> dmwit: not that I'm aware of, nor would I be.
13:20:44 * dmwit nods sadly
13:21:06 <sm> Lemmih: I'm not the one to start a SDL strike force, but it feels like a good idea. I think a lot of folks are beating their head against it individually, and that effort is getting wasted for lack of a central place to gather/disseminate information
13:21:56 <EvanR-work> sdl works great, on linux ;)
13:22:02 <EvanR-work> solution use linux
13:22:03 <EvanR-work> end
13:22:20 <EvanR-work> (actually it works great on anything but osx)
13:22:21 <christastrophe> hmm. any chance I could get an assist with a type error: http://hpaste.org/41040
13:23:18 <sipa> christastrophe: what's the type of readPid ?
13:23:33 <sipa> damn, i'm blind
13:23:46 <dmwit> christastrophe: return (return Nothing)
13:23:57 <dmwit> wait
13:24:12 <dmwit> No, that's not right.
13:24:14 <dmwit> What's the error?
13:24:26 <christastrophe> sipa: FilePath -> IO (Maybe ProcessID)    -- I think
13:24:46 <christastrophe> dmwit: I added it to the paste... http://hpaste.org/41041
13:24:49 <dmwit> So you did.
13:25:10 <dmwit> Okay.
13:25:32 <dmwit> So, "handle" is polymorphic in what kind of exceptions it handles.
13:25:46 <dmwit> Because you've used _, it can't guess which kind of exception it's supposed to be handling.
13:26:20 <EvanR-work> that is a weird mechanism
13:26:33 <EvanR-work> seems magical
13:26:54 <dmwit> You can give "handle" a more specific type, as in (handle :: IOException -> blah -> IO blah2).
13:27:09 <dmwit> sorry
13:27:23 <dmwit> (handle :: (IOException -> IO a) -> IO a -> IO a)
13:27:55 <christastrophe> dmwit: where should that type signature go?
13:28:26 <EvanR-work> they can go in let and in where
13:28:30 <dmwit> case exists of { True -> (handle :: ...) (\_ -> ...) (...) }
13:28:32 <EvanR-work> in addition to the normal place
13:28:33 <dmwit> for example
13:28:53 <sm> and speaking of SDL[-mac] strikeforce, if http://www.haskellers.com/news/6/ is a good idea that could be a place for it
13:29:40 <dmead> hey channel
13:29:46 <dRbiG> what does (in short words) '$' do in haskell? have seen it but not got far enough through any reading to find it described
13:30:03 <dmead> i'm having a problem with ghci chasing my import stantments, it can't seem to find files in the same directory as the source file i'm trying to load
13:30:11 <Zao> @src ($)
13:30:11 <lambdabot> f $ x = f x
13:30:19 <dmead> using -v says it tries the correct file name, but i suspect it's in the wrong directory
13:30:26 <Zao> It's function application with low precedence.
13:30:28 <dmead> is there a way to get ghci into a specific directory?
13:30:34 <Zao> :cd maybe?
13:30:44 <dmead> Zao: cd didn't do it
13:31:42 <christastrophe> dmwit: alright, its building now. makes the code a bit ugly, but its working, thanks
13:31:55 <dRbiG> Zao: may i think of it as an evaluation delayer?
13:32:27 <Zao> dRbiG: You can think of it as a way to get rid of excess parenthesis.
13:32:51 <Zao> a $ b c $ d e == a (b c (d e))
13:33:03 <Zao> (where == is equals, not Haskell ==, heh)
13:33:04 <jmcarthur> i wish it was left associative though
13:33:32 <dmwit> christastrophe: To prettify it, you can define a top-level handleIO = handle, and give it a less polymorphic type than handle.
13:34:16 <christastrophe> dmwit: I did just that, though I called it handle' -- I think I like your naming more
13:36:09 <mee> dRbiG: I like to think of it as a sort of dual to parens, since (using Zao's example) a $ b c $ de   is like   (a)( (b c)(d e) ). I doubt this holds up to any scrutiny, but it helped gel the usage rules for me.
13:36:47 <Cale> dRbiG: I recommend avoiding chaining more than one $ in a row. Whenever you have f $ g $ h $ x, you can always write that as f . g . h $ x, which is nicer to work with because (.) is associative: (f . g) . h = f . (g . h)
13:36:58 <Cale> (so there are effectively more subexpressions that way)
13:38:17 <Cale> It makes it easier to refactor, and puts the emphasis a little more on the manner in which functions are being combined, which is good for functional programming :)
13:39:53 <dmead> @hoogle Match
13:39:54 <lambdabot> Language.Haskell.TH data Match
13:39:54 <lambdabot> Language.Haskell.TH Match :: Pat -> Body -> [Dec] -> Match
13:39:54 <lambdabot> Language.Haskell.TH.Syntax data Match
13:41:33 <dRbiG> Cale, mee, Zao - thx! :) 
13:42:14 <EvanR-work> Cale: im not convinced!
13:43:01 <Cale> EvanR-work: Also, the less code which exists that abuses the associativity of $, the easier it will be to change.
13:43:13 <Cale> A left-associative $ would be strictly more useful.
13:43:33 <Cale> (and $! along with it, of course!)
13:44:41 <Palmik> hmm... why is not (g . (h x)) the same as (g . h $ x) ?
13:44:56 <Palmik> I see now
13:44:58 <Palmik> np :D
13:45:17 <mauke> precedence
13:48:40 <pygmalion> I'm trying to work with a binary search tree of association lists and I have a datatype "data AST k v = Empty | ANode (k,v) (AST k v) (AST k v)"
13:48:59 <pygmalion> can someone look at my insert function and tell me if it seems to work? i'm having trouble
13:54:59 <Razz_DK> Looking for some advice, I have a state in which I have a mapping from table-names to tables (Maps), now I'm unsure as to wether or not using a Map is best. A state transition may update the table. Maps seem to need a function for updating a specific key, or am I missing something?
13:55:36 <c_wraith> Razz_DK, look at "alter"
13:55:52 <c_wraith> :t M.alter
13:55:52 <lambdabot> forall a k. (Ord k) => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
13:56:07 <c_wraith> well, one of the variants of alter
13:56:41 <c_wraith> Oh, that'd work just fine.
13:57:08 <djahandarie> Razz_DK, the update function also allows you to delete an element, which is why Maybe is involved
13:57:25 <Razz_DK> ok, thx :-)
13:57:30 <c_wraith> Just be aware that it's not strict, and *will* result in building up thunks badly.
13:57:30 <djahandarie> You can use adjust if you don't care about that
13:57:45 <c_wraith> ah, adjust is what I was initially thinking of.
13:58:43 <Razz_DK> ok, so what might be a more efficient data structure to use in that case?
13:59:07 <c_wraith> But in any case, both of those functions have a significant issue:  If used repeatedly, and you're not careful, they will build up long chains of thunks.
14:00:42 <shapr> pumpkin: Did you ever find a Haskell datatype for pcap?
14:01:27 <aristid> is RWS popular?
14:01:45 <c_wraith> aristid, it's rather uncommon to want all three of those.
14:01:51 <djahandarie> Reader Writer State?
14:01:54 <aristid> c_wraith: yeah it would seem so
14:01:54 <djahandarie> Yeah
14:02:03 <djahandarie> ReaderT StateT is fairly common though
14:02:04 <pumpkin> shapr: nope, but I started working on something related to it. There's already a binding to libpcap but it's low-level. I have hope for a scapy for haskell :)
14:02:04 <aristid> but transformers has that
14:02:18 <aristid> the problem is, should i write an instance of my class for it
14:02:39 <c_wraith> eh, might as well.  It's not going to hurt anything
14:02:52 <shapr> pumpkin: I want to help!
14:03:11 <aristid> c_wraith: right, it's a bit of effort but maybe it helps me understand my class a bit better, so there's a benefit
14:03:40 <c_wraith> aristid, so, downside is writing a bit of code.  upside is learning a bit more.  go for it. :)
14:03:59 <EnglishGent> hi pumpkin :)
14:05:46 <shapr> pumpkin: I'm particularly interested because I need a tool to post-process pcap files, and I'd rather do it in Haskell. Digium has written at least one VoIP protocol, so...
14:06:34 <jmcarthur> shapr: trying to haskellize digium?
14:06:57 <shapr> jmcarthur: Of course... parse pcap, post-process Asterisk source with Language.C, got any other ideas?
14:07:20 <jmcarthur> i'm not very familiar with the things asterisk needs to do
14:07:24 <jmcarthur> just basics
14:07:55 <shapr> I'd love to give a talk on STM to some of the devs here.
14:07:56 * shapr sighs
14:08:48 <jmcarthur> is asterisk's configuration format a full programming language?
14:10:35 <jmcarthur> just wondering if a haskell dsl would be appropriate, even if it just generates code
14:11:08 <aristid> hmm, there are two nice monad transformers in monadLib that transformers lacks: ExceptionT and ChoiceT
14:11:09 <jmcarthur> if it's fully programmable then a haskell dsl would probably be really nice
14:12:04 <aristid> i guess LogicT is similar to ChoiceT
14:12:44 <aristid> hmm no, ChoiceT is much simpler
14:13:22 <EvanR-work> Cale: so the truth comes out
14:13:46 <EvanR-work> you just want to change the standard library under everyones feet, and thats why everyone uses (.) ;)
14:14:06 <EvanR-work> i feel betrayed
14:14:55 <shapr> jmcarthur: Asterisk's configuration format is... painful.
14:15:05 <jmcarthur> shapr: :D
14:15:08 <jmcarthur> opportunity
14:15:54 <shapr> jmcarthur: We should talk about this at some point, I'm not convinced there's space for opportunity in this case. Will you be at the knitting & type theory meeting tomorrow evening?
14:16:01 <EvanR-work> because i dont see how $ $ $ $ is less refactorable than . . . 
14:16:08 <jmcarthur> shapr: i don't know enough about asterisk to say
14:16:16 <jmcarthur> shapr: dunno if i will be there or not. maybe :)
14:16:27 <aristid> EvanR-work: because you can't extract subexpressions so easily
14:16:40 <aristid> EvanR-work: because it als has dependencies to the rightmost expression
14:16:43 <aristid> -als+all
14:16:51 <pumpkin> shapr: ah, I'm not at that stage yet unfortunately, just exploring the design space when I get some time
14:17:06 <Cale> EvanR-work: Consider "f $ g $ h $ x". The substring f $ g is (likely) meaningless.
14:17:09 <djahandarie> It'd be neat if we had seminars in here every once in awhile
14:17:13 <pumpkin> EnglishGent: hi :)
14:17:16 <shapr> jmcarthur: I would be quite interested in discussing this with you sometime soon. I see that a DSL would be useful for Asterisk, but...
14:17:21 <Cale> EvanR-work: But f . g is an actual function
14:17:48 <EvanR-work> Cale: and if you move f . g somewhere else in the same big expression, its likely a type error
14:17:48 <Cale> It's easier to think about in pieces, and easier to hack apart into smaller bits.
14:17:50 <shapr> I'm still looking for any example code for uses of Language.C... otherwise I guess I'll be writing example code soon.
14:18:08 <Cale> EvanR-work: No, you can just hack that out and make it into a new definition with no trouble.
14:18:13 <Cale> But f $ g, you can't.
14:18:21 <aristid> is this ListT a real monad? http://hackage.haskell.org/package/List-0.4.0 - afaik people here complain that the ListT in transformers is not good
14:18:24 <EvanR-work> you can also move it out and do s/$/./ with no trouble
14:18:41 <djahandarie> aristid, I don't think it's possible.
14:18:41 <aristid> EvanR-work: but if you use the conventional form you don't need s/$/./g
14:18:52 <shapr> Speaking of which, does anyone know where I could find a collection of common C coding errors that I could use to test a lint-like using Language.C ?
14:18:59 <aristid> djahandarie: look at the package first, it seems to use a trick
14:19:15 <EvanR-work> this seems like a marginal situation
14:19:24 <EvanR-work> to base an entire culture on
14:19:52 <djahandarie> aristid, it'd have to be doing something really weird. The issue is with []
14:19:54 <mauke> http://www.gimpel.com/html/bugs.htm
14:19:58 <EvanR-work> i would go more to the 'its more functional' to do composition
14:20:05 <EvanR-work> that cale said second
14:20:06 <Cale> aristid: No, ListT m is only a monad if m is a commutative monad
14:20:16 <jmcarthur> shapr: http://cwe.mitre.org/
14:20:31 <shapr> jmcarthur: Awesome!
14:20:37 <Cale> EvanR-work: Well, using composition more keeps you in the right mindset for functional programming. That's probably the main thing.
14:20:38 <aristid> Cale: have you looked at the package? it has a class for list-like things, and does not use lists directly in ListT
14:20:49 <Cale> aristid: Oh, you're not talking about MTL?
14:20:58 <aristid> Cale: i linked the package...
14:21:03 <aristid> http://hackage.haskell.org/package/List-0.4.0
14:21:08 <Cale> aristid: I'm somewhat distracted :)
14:21:19 <Nibble> aristid: you are questioning my authoritaah?
14:21:29 <aristid> Nibble:huh?
14:21:31 <EvanR-work> and $ everywhere makes the code look like php
14:21:32 <jmcarthur> shapr: the top 25 is probably the first place to look there: http://cwe.mitre.org/top25/index.html#Listing
14:21:49 <Cale> aristid: ah, okay, hmm
14:21:55 <jmcarthur> hard to lint many of those though
14:22:04 <aristid> i'm looking for an alternative to monadLib's ChoiceT
14:22:08 <EvanR-work> careful choice walks the fine line between $$$ php and ((())) scheme
14:22:13 <aristid> logict seems to be a bit of overkill
14:22:14 <Cale> aristid: Yeah, I don't know, but I would be wary about the monad associativity axiom.
14:22:20 <Cale> LogicT is great
14:22:38 <Cale> It works well, and it's pretty easy to use, and comes with some additional useful combinators
14:22:42 <jmcarthur> shapr: i referred to this list a lot for a project i did a little work on at pikewerks (was actually going to use Language.C for it, but it ended up not working out)
14:22:50 <aristid> Cale: ChoiceT is a lot simpler though
14:23:08 <aristid> hmm, or does ChoiceT violate associativity too?
14:23:30 <Cale> I don't know
14:23:43 <Cale> I think it's not supposed to
14:23:54 <shapr> jmcarthur: Oh, so YOU have used Language.C !
14:23:56 <Cale> But in what way is it simpler?
14:24:01 <Cale> The implementation?
14:24:07 <Cale> The interface is pretty well identical.
14:25:03 <aristid> http://hackage.haskell.org/packages/archive/monadLib/3.6.2/doc/html/src/MonadLib.html#ChoiceT
14:25:10 <aristid> it's just a simple ADT
14:25:14 <jmcarthur> shapr: no, i only thought about it :P
14:25:25 <jmcarthur> and played with parsing a couple things. that's about it
14:26:02 <aristid> Cale: LogicT on the other hand i don't understand
14:26:07 <aristid> the implementation, that is
14:28:29 <Funktorsalat> iirc it's just the same old a + b ~ (a -> r) -> (b -> r) -> r trick
14:28:30 <jmcarthur> shapr: apparently chazzm has had dreams about haskell now :P
14:28:36 <jmcarthur> he's infected
14:28:40 <Funktorsalat> (I do mention that a lot lately don't I... maybe I'll make a shirt)
14:30:17 <shapr> jmcarthur: When did that happen?
14:30:26 * jmcarthur shrugs
14:30:40 <Funktorsalat> ... obfuscated with type syns ;)
14:30:42 <Funktorsalat> type SK r a = a -> r -> r
14:30:42 <Funktorsalat> type FK a = a
14:30:46 <jmcarthur> the lambda calculus and evaluation order "lecture" maybe?
14:31:40 <hpc> Funktorsalat: that's rude :D
14:31:54 <Funktorsalat> hpc: didn't mean to
14:32:04 <Funktorsalat> but come on, the FK one ;)
14:32:23 <hpc> yeah
14:32:36 <hpc> ooh, alternatively
14:32:39 <hpc> type FK a b = a
14:33:16 <hpc> add specialized types by hand for hilarity
14:37:54 <shapr> jmcarthur: Oh right, I only caught the tail end of that one.
14:45:00 <Razz_DK> I'm currently trying to print the state so I can see the effect my functions have on it, however, the tables which are stored as part of the state are giving me problems wrt. show. A table is defined as a tuple of a function and a value, now ghc is screaming about not having an instance for showing the function. How can I resolve this?
14:45:29 <mauke> don't try to print functions
14:46:20 <gtklocker> O hai
14:47:04 <gtklocker> I see many people using Haskell, but I find it... confusing... or it's my idea?
14:47:33 <mauke> what's confusing you?
14:47:39 <gtklocker> hm, the code
14:47:43 <mauke> heh
14:47:45 <EvanR-work> gtklocker: i find php python javascript c++ confusing
14:47:52 <gtklocker> it seems like it's not straightforward
14:47:57 <Axman6> C and 
14:47:58 <mauke> if you were meant to understand it, it wouldn't be called "code"!
14:48:08 <Axman6> C and Haskell are the only languages i don't find confusing
14:48:08 <gtklocker> Well.
14:48:19 <gtklocker> I've been searching for a good start with haskell.
14:48:28 <sproingie> LYAH is good
14:48:29 <gtklocker> Any tutorial/book you have to propose me?
14:48:31 <Axman6> gtklocker: on the contrary, it's extremely straightforward
14:48:31 <mauke> preflex: ? lyah
14:48:31 <preflex>  http://learnyouahaskell.com/
14:48:45 <gtklocker> preflex: feels good
14:48:54 <solistic> gtklocker: Yet an other haskel tutorial!
14:49:06 <gtklocker> In parallel, I learn C, from the K&R boot
14:49:08 <gtklocker> book*
14:49:32 <mauke> http://mauke.ath.cx/stuff/c/ifalse.c STRAIGHTFORWARD
14:49:35 <gtklocker> Well, the only reason I'd like to learn haskell, is because it's flexible
14:49:36 <Rembane> gtklocker: It is a lot easier to just learn one language at a time.
14:49:53 <gtklocker> Rembane: indeed
14:49:56 <EvanR-work> haskell code consists of function applications and function definitions. when you see a function application without its corresponding definition, you dont know what it does and are forced to ask or read what it does. in php you dont have to ask because everything is spelled out in a giant for loop step by step in a source file 20000 lines long
14:50:18 <EvanR-work> maybe thats why you are confused
14:50:55 <solistic> gtklocker: www.cs.utah.edu/~hal/docs/daume02yaht.pdf
14:51:04 <mauke> preflex: quote primal
14:51:04 <preflex>  <primal> do u guys find urselves declaring a lot of functions in php... i feel like i don't need them since each php page is sort of like a separate function...
14:51:33 <EvanR-work> indeed you dont need them
14:51:35 <zomg> ;x
14:51:48 <zomg> After my boss stopped coding, our PHP code became much more tolerable ;>
14:52:02 <hpc> zomg: zomg
14:52:52 <clp8> mauke: that is an incredible quote
14:53:34 <EvanR-work> yes
14:54:10 <EvanR-work> thats how we usually operate, functions are considered unnecessary or too much for the current problem
14:54:45 <EvanR-work> then when the framework proposes you use object methods, its groundbreaking and a best practice
14:55:00 <EvanR-work> though still quite coarse grained
14:55:54 <gtklocker> excellent tut
14:55:56 <gtklocker> bookmarked
14:56:12 <Axman6> don't bookmark it, read it!
14:56:42 * EvanR-work throws down his patent on bookmarks and demands a settlement from gtklocker 
14:57:28 <gtklocker> I read the introduction
14:57:38 <gtklocker> I think it'll be ok to read after learning C.
14:58:27 <Axman6> you know that can take years right?
15:00:42 <EvanR-work> learn haskell first
15:00:46 <EvanR-work> then youll be better prepared for C
15:01:11 <Entroacceptor> don't
15:01:27 <gtklocker> EvanR-work: hm?
15:01:30 <gtklocker> really?
15:01:33 <Ke> I think there are very few people that learned declarative programming before learning imperative programmin
15:01:38 <EvanR-work> yes
15:01:43 <EvanR-work> gtklocker can be one of them
15:01:57 <Ke> doing that might make you insane, or wrose
15:02:00 <Ke> worse
15:02:11 <EvanR-work> or worse, incredibly good at what you do
15:02:12 <maurer_> Axman6: Learning C does not take years.
15:02:24 <Entroacceptor> but don't try to learn them both at the same time
15:02:26 <hpc> EvanR-work: oh god, no! anything but that!
15:02:43 <sipa> only 21 days: http://abstrusegoose.com/249
15:02:49 <maurer_> Clearly, we should reccomend he learn a logic language first. What could go wrong?
15:02:49 <Entroacceptor> and I really don't think that learning haskell makes you a better C programmer
15:02:49 * hackagebot network 2.2.3.1 - Low-level networking interface  http://hackage.haskell.org/package/network-2.2.3.1 (JohanTibell)
15:03:00 <EvanR-work> Entroacceptor: better prepared to learn it
15:03:04 <Entroacceptor> maybe a sadder programmer if he has to do C after that :)
15:03:49 <EvanR-work> Entroacceptor: a more realistic programmer ;)
15:04:33 <EvanR-work> how do you think cobol programmers operate these days
15:04:39 <maurer_> Entroacceptor: I've actually come up with some nice techniques for keeping state manageable in C by coding in haskell.
15:04:50 <EvanR-work> not by admiring the system and being happy about their job ;)
15:06:28 <EvanR-work> maurer_: you can get by surprisingly well with structures considered immutable and using automatic allocation instead of malloc
15:06:56 <EvanR-work> but youd never think of that if you didnt fear imperative programming
15:09:22 <camio> Yay, I just implemented a Hindley Milner type inference engine in 156 lines of Haskell! http://hpaste.org/41043/hindley_milner_type_inference. I welcome any comments on the code.
15:14:14 <maurer_> EvanR-work: Not even just that. One of my favorites that showed up when working with State is a block function that performs an action effectively in a sandbox
15:14:39 <maurer_> Many fuck-ups in C come from not saving/restoring variables properly/in the right place, and having a block function that effectively enforces this is useful.
15:15:44 <EvanR-work> you mean making a new block without a new function
15:15:52 <maurer_> No.
15:16:58 <maurer_> e.g. http://hpaste.org/41044/block
15:17:38 <EvanR-work> thats not C
15:18:18 <aristid> can mtl 2.0 be used on ghc 6.12?
15:18:34 <aristid> it's a base library, so you shouldn't normally upgrade?
15:19:11 <EvanR-work> maurer_: this seems weird
15:21:34 <EvanR-work> is it that you want to run a state inside of a state
15:21:41 <EvanR-work> without using runState
15:22:23 <hpc> it looks a bit nicer than runState, imo
15:22:33 <hpc> and extends to other monads
15:23:30 <hpc> :t let block m = do   s <- get;   a <- m;   put s;   return a in block
15:23:30 <lambdabot> forall s (m :: * -> *) b. (MonadState s m) => m b -> m b
15:24:32 <dRbiG> :q
15:24:52 <dRbiG> pff, ;)
15:28:59 * hackagebot cryptohash 0.6.1 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.6.1 (VincentHanquez)
15:42:59 <aristid> hackagebot, go!
15:43:11 * hackagebot transformers-compose 0.1 - Arrow-like / category-like composition for transformers.  http://hackage.haskell.org/package/transformers-compose-0.1 (AristidBreitkreuz)
15:44:05 <Entroacceptor> aristid: :D
15:44:45 <enthropy> next thing you know, we'll have joke packages on hackage.... oh wait
15:45:02 <aristid> i don't upload joke packages :P
15:45:09 <aristid> <- dead serious package maker
15:45:36 <hpc> aristid only uploads web-scale mongoDB driver solution synergy packages!
15:45:45 <enthropy> @hackage pony
15:45:45 <lambdabot> http://hackage.haskell.org/package/pony
15:47:05 <aristid> hpc: indeed!
16:03:18 <silver> enthropy, awesome horse
16:04:35 <dagle> I think the Author is the best part of that package.
16:05:32 <dmwit> "Don Stewart"?
16:05:58 <dagle> Yes. 
16:07:04 <dagle> If it was written by some random kid it wouldn't be as funny.
16:08:59 <lispy1> My only complaint with the pony package is that if I run: watch can-i-have-a-pony, it doesn't animate
16:10:05 <alex404_> Is the built in pure random number generator so slow compared to some of the impure ones?
16:10:53 <Entroacceptor> but it's broken
16:10:57 <Lemmih> alex404_: It's also slow compared with other pure random number generators.
16:11:02 <Entroacceptor> I get an unicorn, not a pony
16:11:39 <alex404_> Lemmih: What's the best pure random number generator?
16:11:41 <dagle> Entroacceptor: You should be happy that you got a pony.
16:11:52 <Entroacceptor> dagle: but it is no pony!!!!
16:11:54 <alex404_> Lemmih: Where speed is the most important thing
16:12:04 <dagle> Entroacceptor: I mean a unicorn!
16:12:58 <Entroacceptor> so Haskell beats Python in that regard, too? http://djangopony.com/ ;)
16:14:18 <hpc> :D
16:15:06 <Lemmih> alex404_: http://hackage.haskell.org/package/mersenne-random-pure64 probably.
16:15:11 <ddarius> lispy1: Clearly you need to submit a patch.
16:16:33 <lispy1> Entroacceptor: the django "pony" has wings.
16:16:48 <lispy1> ddarius: Indeed
16:21:09 <alex404_> Lemmih: My main issue is that I'd like to be able to parallelize a certain operation (which I merely have to map over some values), and random values based on mutable arrays seem like they'd be prohibitive. That that seem like a reasonable inference?
16:21:14 <kwuxalot> does Python have the equivalent of union types?
16:21:44 <wlangstroth> django has a pink pony Pegasus?
16:22:00 <kwuxalot> an object or dictionary is like a record (sum type?) where you can have everything in the collection, as opposed to just one thing in the collection
16:22:03 <Lemmih> alex404_: Yeah.
16:22:07 <ddarius> There's a reasonably nice encoding into any single-dispatch class-based OO language, but you don't get pattern matchng.
16:22:23 <alex404_> Lemmih: Cheers.
16:23:15 <kwuxalot> ddarius: was that in response to my vague question? Basically looking for an easy way to express exclusive OR
16:25:53 <jmcarthur> kwuxalot: a record is a product type
16:26:06 <kwuxalot> jmcarthur: yeah, that's the word I was looking for
16:26:18 <jmcarthur> kwuxalot: Either is a sum type
16:26:36 <wlangstroth> \quit
16:26:44 <kwuxalot> Union types go hand in hand with pattern matching
16:26:49 <ddarius> interface Either<A,B> { C either<C>(Func<A,C> f, Func<B,C> g); };  class Left<A> : Either<A,B> { private A _a; public Left(A a) { _a = a; }; C either<C>(Func<A,C> f, Func<B,C> g) { return f(_a); } }; // similarly for Right.
16:27:25 <Axman6> ...o.O
16:27:27 <Axman6> ow :(
16:27:30 <Lemmih> ddarius: What a beauty!
16:27:52 <kwuxalot> but why do dynamically typed languages seem to be biased towards product types as opposed to sums?
16:28:16 <ddarius> kwuxalot: The "dynamic" "type" in them is a giant sum.
16:29:04 <ddarius> Also, Either A A ~ (Bool, A)  so if you only have one "A" then you can always just use a tag, not that even that type consideration matters in a dynamically typed language.
16:29:14 <Rotaerk> too bad you can't close the type Either from further inheritance
16:29:30 <ddarius> Rotaerk: There are plenty of ways of doing that.
16:29:42 <Rotaerk> don't think so
16:30:33 <kwuxalot> ddarius: you could represent a union type as two constraints
16:30:38 <Rotaerk> either you can't derive from T at all, or you can inherit from T any number of times
16:31:02 <Rotaerk> but that's probably the easiest way to do discriminated unions in C#
16:31:06 <Rotaerk> in spite of that flaw
16:31:42 <Rotaerk> and then combine that with a pattern matching library and it's fairly nice, for C#
16:32:06 <kwuxalot> ddarius: basically an assertion
16:32:45 <kwuxalot> ddarius: a conveniently named assertion to support pattern matching
16:35:01 <elliotstern> What's the most idiomatic way in haskell to find the inverse of a function with a few possible inputs (in this case, 16)?  In particular, I'm reversing an s-box for my crypto class; we have to perform a linear cryptanalysis attack on a toy example of a block cipher
16:35:34 <elliotstern> I can think of a few ways of doing it, but what's the most "haskellian"?
16:36:07 <elliotstern> I've got a list of the possible inputs lying around, if that helps
16:36:30 <maurer_> g x = let m = Map.fromList $ zip (map f inputs) inputs in m ! x
16:36:33 <maurer_> is what I'd do.
16:37:15 <maurer_> Someone else may have a better idea.
16:38:49 <kwuxalot> elliotstern: I'd look at a function with limited domain as a map, so to inverse map -> list, then zip it with a flipped fromList
16:39:57 <kwuxalot> elliotstern: invert_map :: (Ix a, Ix b) => Map a b -> Map b a
16:45:42 <kwuxalot> @hoogle Map a b -> Map b a
16:45:42 <lambdabot> Data.Map mapWithKey :: (k -> a -> b) -> Map k a -> Map k b
16:45:42 <lambdabot> Data.Map map :: (a -> b) -> Map k a -> Map k b
16:45:42 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
16:46:10 <kwuxalot> :t flip Data.Map.map
16:46:10 <lambdabot> forall a b k. M.Map k a -> (a -> b) -> M.Map k b
16:55:33 <elliotstern> What's the best way to force haskell to memoize (i.e. hold onto) the Map
16:55:36 <elliotstern> ?
16:55:49 <sipa> what do you mean?
16:55:57 <mauke> what do you mean by "the Map"?
16:55:58 <writer> elliotstern, exhibit state ;)
16:56:10 <writer> memoize lookups I guess
16:56:17 <tromp> :t (=<<)
16:56:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:58:59 <aristid> hmm, cabal could use rsync to download the package list
17:01:02 <mjcmirr> elementary question (I think): using current Haskell Platform, why does "import Data.Time.LocalTime(LocalTime); a = LocalTime undefined undefined" produce a "Not in scope" error for the LocalTime constructor, even though "import Data.Time.LocalTime; a = LocalTime undefined undefined" works?
17:01:42 * hackagebot websockets 0.1.2.2 - Implements the WebSocket protocol.  http://hackage.haskell.org/package/websockets-0.1.2.2 (SinisaBidin)
17:02:04 <mauke> mjcmirr: you may need (LocalTime(..))
17:02:06 <Lemmih> mjcmirr: You only imported the type. Try: import Data.Time.LocalTime (LocalTime(LocalTime))
17:02:12 <mauke> or that
17:04:56 <mjcmirr> mauke, Lemmih: great, thanks!  I see this now (http://www.haskell.org/onlinereport/haskell2010/haskellch5.html#x11-1010005.3)-- thanks again!
17:10:32 <jimmyjazz14> I am having the same issue as talked about in the following thread: http://www.haskell.org/pipermail/beginners/2010-September/005289.html
17:11:07 <jimmyjazz14> I was wondering if anyone could shine some light on how one might use Network.HTTP without the Overlapping instances error happening
17:11:26 <jimmyjazz14> if its not possible what might be a good alternative to Network.HTTP
17:11:27 <jimmyjazz14> ?
17:33:58 <pc> elliotstern: i'd say, build a list of (x, f x) then lookup
17:38:51 <aristid> @tell ManateeLazyCat thank you for your auto-complete-mode extension thingie for haskell
17:38:51 <lambdabot> Consider it noted.
17:39:04 <aristid> i hope he will join with that nickname :D
17:39:26 <aristid> also, emacs users should check this out: http://www.emacswiki.org/emacs/auto-complete-extension.el
17:40:07 <pc> switched to vim yesterday, but i'll give it a look :p
17:42:49 <blackdog> aristid: is that completing statically, or is it invoking ghc to parse your files?
17:44:21 <aristid> blackdog: it uses hoogle
17:44:38 <aristid> blackdog: you can also tell it to use words (without parsing) from the current buffer
17:50:25 <blackdog> aristid: interesting. there's a tension there - I quite like the approach ghc-mod takes, but there's probably room for a less structured tool too.
18:08:07 * hackagebot xml-monad 0.3 - Monadic extensions to the xml package.  http://hackage.haskell.org/package/xml-monad-0.3 (AristidBreitkreuz)
18:12:20 <aristid> @hoogle finally
18:12:20 <lambdabot> Control.Exception finally :: IO a -> IO b -> IO a
18:12:20 <lambdabot> Control.OldException finally :: IO a -> IO b -> IO a
18:12:20 <lambdabot> Control.Exception.Base finally :: IO a -> IO b -> IO a
18:29:15 * hackagebot scgi 0.3.3 - A Haskell library for writing SCGI programs.  http://hackage.haskell.org/package/scgi-0.3.3 (StephenBlackheath)
18:33:22 <dbelange> What is universal coalgebra good for in the theory of computation?
18:34:23 <dolio> They model processes, or potentially infinite structures.
18:36:00 <monochrom> such as oo
18:37:50 <dolio> Yes, although for that to really make sense, it helps to stop thinking of objects as intrinsically mutable entities.
18:38:03 <dolio> And think about mutability in a more State like way.
18:38:35 * camio just discovered -XUnicodeSyntax. Yay!
18:39:57 <monochrom> \∩/
18:40:48 <kfish> camio, can we do this now?: http://bother.kfish.org/wiki/HaskellUTF8
18:41:45 <camio> No, doesn't look like it :(
18:42:04 <camio> I can't even do a putStrLn "?" :/
18:42:23 <camio> That's supposed to be a lambda
18:42:28 <kfish> heh
18:42:36 <kfish> not even with Data.Text and OverloadedStrings?
18:43:32 <camio> * Exception: <stdout>: hPutChar: invalid argument
18:43:47 <camio> character is not in the code page ??
18:44:08 <camio> I can make the string, but cannot print it looks like.
18:44:33 <camio> Arg, Haskell sucks :-P
18:44:59 <camio> Though, it's better than it used to be :)
18:45:10 <kfish> ah, for that you probably need to convert to the terminal's encoding
18:45:21 <kfish> not sure how much of that has changed since http://blog.kfish.org/2007/10/survey-haskell-unicode-support.html :)
18:45:35 <kfish> i thought Data.Text handled much of that now ...
18:46:48 <camio> thanks for the link
18:47:29 <kfish> np, i'd be interested to know the current state of support (that was from 2007 :)
18:51:23 * hackagebot hp2pretty 0.3 - generate pretty graphs from heap profiles  http://hackage.haskell.org/package/hp2pretty-0.3 (ClaudeHeilandAllen)
18:51:54 <blackdog> kfish: you hiring for tsuru interns now?
18:52:27 <kfish> blackdog, yes we are
18:52:46 <kfish> how are you doing?
18:53:08 <blackdog> ah, not bad. is sorta tempting, but my gf's just started her PhD, so no tokyo for a little while:)
18:53:42 <blackdog> trying to convince my boss that snap+haskell is a good way to build iPhone backend servers
18:53:52 <blackdog> 'sgotta be better than ruby, anyway.
18:56:22 <unkanon> lol, I love the simplicity of the source for $
18:56:34 <unkanon> f $ x = f x
18:56:39 <unkanon> obviously!!
19:00:32 <monochrom> you need to configure your OS to get unicode to work for ghc, because ghc and the I/O routines actually trust (mistrust) your setup as your true intention.
19:01:28 <kfish> blackdog, :)
19:01:35 <monochrom> for example, on linux, your environment variables must indicate you want utf-8 rather than latin1
19:01:50 <Martty> blackdog: hey hey mama said the way you move 
19:02:24 <monochrom> not sure what to do on windows, but definitely certain people's lazy choice of "cp437" or something will not work.
19:05:24 <camio> monochrom: I'm making progress with "chcp 65001", but now get the character output correctly and then "permission denied" for the next character.
19:05:32 <aristid> unkanon: wouldn't you love this even more? ($) = id
19:06:19 <unkanon> aristid: hmm not sure i understand that
19:06:48 <aristid> unkanon: well, let's take f $ 5
19:06:59 <aristid> that is supposed to call f with the argument 5, right?
19:07:36 <unkanon> ?src liftM
19:07:36 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:07:46 <unkanon> aristid: yes
19:08:09 <aristid> so it is the same as f 5. similarly, f $ 1 + 2 is the same as f (1 + 2)
19:08:24 <FunctorSalad> <unkanon> lol, I love the simplicity of the source for $
19:08:24 <FunctorSalad> <unkanon> f $ x = f x
19:08:32 <FunctorSalad> makes you want to cut out the unnecessary $ eh? ;)
19:08:52 <aristid> unkanon: so, written differently, ($) f 5 = f 5
19:09:24 <aristid> because operators are always just normal functions
19:09:36 <Martty> > ($) sqrt 2
19:09:36 <lambdabot>   1.4142135623730951
19:09:39 <Martty> worst ever
19:10:11 <aristid> unkanon: it follows that ($) f = f
19:10:23 <aristid> which is the definition of id
19:10:32 <aristid> ($) just has a more restrictive type
19:10:46 <FunctorSalad> > ($) ($ 2) sqrt
19:10:46 <lambdabot>   1.4142135623730951
19:11:21 <aristid> > let ($$$) a b = "I want money!" in 4 $$$ 5
19:11:22 <lambdabot>   "I want money!"
19:12:23 <FunctorSalad> @let x € f = fmap f x
19:12:24 <lambdabot>  Defined.
19:13:04 <unkanon> aristid: hmm i think i get is now that you put it that way
19:13:17 <aristid> @let €€ = fmap . fmap
19:13:17 <lambdabot>   Parse error: VarSym "\8364\8364"
19:13:24 <aristid> @let (€€) = fmap . fmap
19:13:25 <lambdabot>  Defined.
19:13:27 <FunctorSalad> @let f ³ x = f (f (f x))
19:13:28 <lambdabot>   Illegal character ''\179''
19:13:33 <FunctorSalad> fu :p
19:13:45 <FunctorSalad> sorry.
19:14:15 <tg_> get a room, you two!
19:14:42 <aristid> :t concat €€ zipWith
19:14:43 <lambdabot> Not in scope: `??????'
19:14:48 <FunctorSalad> lol
19:14:50 <aristid> @let (€€) = fmap . fmap
19:14:51 <lambdabot>  <local>:8:0:
19:14:51 <lambdabot>      Multiple declarations of `L.€€'
19:14:51 <lambdabot>      Declared at: <loc...
19:14:57 <aristid> :t concat L.€€ zipWith
19:14:58 <lambdabot> Not in scope: `L.??????'
19:15:02 <aristid> wtf
19:15:03 <aavogt> @vixen in private?
19:15:04 <lambdabot> i'll hafta plead the fifth on that one.
19:15:56 <aristid> :t let (€€) = fmap.fmap in concat €€ zipWith
19:15:57 <lambdabot>     Couldn't match expected type `[[a]]'
19:15:57 <lambdabot>            against inferred type `[b] -> [c]'
19:15:57 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
19:16:10 <aristid> :t let (€€€) = fmap.fmap.fmap in concat €€€ zipWith
19:16:11 <lambdabot> forall a a1 b. (a1 -> b -> [a]) -> [a1] -> [b] -> [a]
19:17:27 <aristid> FunctorSalad: this is quite tempting. an easy-to-type unicode operator for fmap and fmap.fmap and fmap.fmap.fmap and...
19:17:43 <FunctorSalad> the ³ ?
19:17:48 <aristid> no, the €€€
19:18:06 <aristid> at least on my keyboard that's extremely easy to type
19:19:10 <FunctorSalad> I use to be able to type it with AltGreek + e but now it has become + 5 somehow
19:20:28 <FunctorSalad> hmm why not one for liftM2 btw
19:20:44 <FunctorSalad> oh, that wouldn't work without parens
19:37:49 <MigX> The snap framework looks pretty sweet
19:38:34 <ramb0> Hey! I have a doubt. How can I load a package into GHCi ? For example, i want to be able to use "chr" and "ord" from Data.Char "locally"
19:40:15 <blackdog> ramb0: :m +Data.Char
19:42:56 <ramb0> Thanks blackdog !! :) i couldn't find it on google :(
19:43:55 <blackdog> ramb0: http://learnyouahaskell.com/modules
19:44:16 <blackdog> the real world haskell book uses it extensively too.
19:44:39 <blackdog> so, anyone know who Daniel Gorin is? I'm having some trouble building hint, and he seems to be the maintainer.
19:44:47 <Darkone> Is there anything like "catch" for non IO? I want to debug some values reaaaal quick
19:45:04 <mikeg> hehe i just realized why "n `elem` [0,8..]" was making my machine crash
19:45:05 <ramb0> That's very usefull, blackdog !
19:45:13 <Darkone> Like, add a "catch" type thing to a few lines telling me where my error is.
19:45:48 <Darkone> The error message when I run it fro mthe command line says it's a read error
19:46:01 <Darkone> But I have a dozen or so reads in my little program :(
19:46:55 <Darkone> Anyone happen to know about that? :X
19:47:11 <blackdog> ramb0: no worries:)
19:47:22 <Saizan> Darkone: the spoon package maybe
19:47:53 <dolio> Why didn't readMaybe make it into the libraries?
19:48:05 <Darkone> I just want to add some stuff like "blahblahmyfunction `catcherror` (\_ -> Read error in line ... )"
19:48:36 <Saizan> Darkone: why don't you change the calls to read instead?
19:49:04 <Darkone> Saizan, ? I have some really simple code. Like:  tunings = read $ myarray ! 26
19:49:23 <Darkone> I have quite a few of these, and added some extras, merged some stuff, etc.
19:49:38 <Darkone> Unfortuantely, the cmd line error isn't very informative
19:49:40 <developernotes> I am trying to do through some haskell examples, there appears to be a difference between what I can type within ghci and what is loaded from a script file directly.
19:49:46 <Darkone> Prelude.read: no parse
19:50:06 <developernotes> Is there a way for me to define a type alias within ghci?
19:50:09 <blackdog> developernotes: yep. in ghci, you have to bind variables with "let"
19:50:09 <Saizan> Darkone: use the safe package, it has versions of read that can print more informative errors
19:50:22 <developernotes> I am trying something like type Account = String, but it errors.
19:50:35 <blackdog> and type info has to be done in a file
19:50:37 <developernotes> I thought let might work in front of it but it doesn't.
19:50:41 <Darkone> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/safe
19:50:45 <Darkone> This one?
19:50:59 <blackdog> developernotes: short answer: type information has to be done in a file.
19:51:02 <Saizan> Darkone: also, iirc your code, i'm not sure why you've read and show everywhere rather than parsing things up front and then stick to numbers
19:51:06 <Saizan> Darkone: yep
19:51:40 <developernotes> ah...interesting, maybe a silly question, but is there some reason that ghci is both limiting as well as different than what can be loaded from a file?
19:51:50 <blackdog> developernotes: not a silly question :)
19:52:07 <blackdog> basically, the type checker wants to run over the whole universe as it knows it
19:52:14 <blackdog> it doesn't really cope well with incremental typechecking
19:52:23 <Saizan> Darkone: readNote in particular
19:52:56 <developernotes> blackdog: interesting, you would think the type checker would be able to evaluate what has been provided in the ghci session, like a repl.
19:53:07 <developernotes> ah well, more for me to learn.  :-)
19:53:19 <developernotes> blackdog: thanks for the info.
19:53:33 <blackdog> developernotes: ghci itself is more like an extended IO loop - for instance, you can run "readFile "/etc/passwd"" and it'll actually go and read the file
19:53:57 <blackdog> if you assigned that to a variable at the top level in a script, that'd just be an IO action defined at the top level
19:54:00 <blackdog> it wouldn't actually be run.
19:54:14 <unkanon> ?src <-
19:54:14 <lambdabot> Source not found.
19:54:22 <developernotes> blackdog: so it would be a thunk?
19:54:25 <Saizan> developernotes: there isn't a fundamental reason why a REPL couldn't accept type/data declarations, in fact other haskell ones did
19:54:59 <Saizan> developernotes: the most problematic part is that you need to be able to give multiple decls at once, in case they are mutually recursive
19:55:23 <developernotes> Saizan: hmm....interesting
19:55:27 <unkanon> what's this "  <-  " in the source of liftM ?
19:55:30 <unkanon> ?src liftM
19:55:31 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
19:55:45 <Saizan> unkanon: it's part of the do-notation
19:55:47 <blackdog> developernotes: yes, but that's not the difference :)
19:55:54 <Saizan> ?undo do { x1 <- m1; return (f x1) }
19:55:55 <lambdabot> m1 >>= \ x1 -> return (f x1)
19:56:02 <blackdog> developernotes: it's a thunk, but of type "IO String"
19:56:02 <Saizan> that's what it desugars to ^^^
19:56:23 <unkanon> Saizan: thanks, i'll feed that to my brain :)
19:56:37 <blackdog> so if I'm not already in an IO context, I can't "run" it - I can pass it around, but i can't actually execute it
19:57:58 <developernotes> blackdog: so you would need to request the contents of what you had assigned, in order for it to be evaluated?
19:58:21 <blackdog> developernotes: in the right context, yes.
19:58:47 <blackdog> i'm trying to separate the concepts of laziness, and using the type system to enforce constraints
19:58:50 <blackdog> they're quite orthogonal
19:59:14 <blackdog> so i could write "foo = <big expensive computation on the natural numbers>" at the top level of a haskell file
19:59:26 <blackdog> it might take a thousand years to compute fully, but it doesn't require outside input
19:59:42 <blackdog> if i don't use 'foo', i don't pay for it.
20:00:05 <blackdog> but, if i write "foo = readFile bar", that's quite a short, simple program
20:00:17 <blackdog> but i still can't run it inside a function that says that it's pure.
20:00:28 <blackdog> and it's the type system enforcing that. did that make any sense?
20:01:08 <developernotes> but foo doesn't contain the textual value of the file bar after that line is executed, correct?  Not until you do something with foo where it has to be realized?
20:01:08 <adu> yes, they are
20:01:09 <lambdabot> adu: You have 2 new messages. '/msg lambdabot @messages' to read them.
20:01:52 <adu> o crap totally forgot about sbahra 
20:01:58 <developernotes> blackdog: yes
20:02:11 <blackdog> developernotes: foo then has a value of type IO String
20:02:34 <blackdog> if I want the actual string, I have to explicitly run that in an IO context somewher
20:03:01 <blackdog> GHCI muddies the distinction a bit, because it's quite happy to act as either an IO context or a pure context at the top level
20:03:14 <developernotes> blackdog: okay, so thunks define a specific type, in this case IO String?
20:03:43 <developernotes> where do you define an IO context to run it?
20:03:48 <blackdog> developernotes: let's go to PM.
20:05:17 <adu> blackdog: yes, once it is in IO, there's no unsafe way to get it out
20:05:38 <adu> but (>>=) lets you do things with (IO String)
20:05:46 <blackdog> adu: no _safe_ way :)
20:06:23 <adu> actually, i meant non-unsafe, so yes, safe
20:08:23 <ramb0> Can anyone give me an example of how yo use "xor" from Data.Bits between two ints? Like xor 4 10 ?
20:09:13 <blackdog> adu: double negatives are not that easy :P
20:09:42 <Saizan> > xor 4 10 :: Int
20:09:43 <lambdabot>   14
20:09:53 <ramb0> Thanks!
20:10:28 <adu> blackdog: actually, it would have been a triple negative, if I had said it correctly
20:10:39 <adu> "there's no non-unsafe way"
20:10:57 <blackdog> adu: that's too not un-hard.
20:12:01 <adu> anyways, I think laziness would work even in a scripting/procedural language
20:12:19 <unkanon> let's not keep not stop doing that
20:12:22 <adu> i think laziness is also orthogonal to "functional"
20:12:57 <unkanon> adu: what do you mean by orthogonal? I do not think it means what you think it means
20:13:01 <penelope> "pure"?
20:13:41 <ClaudiusMaximus> suppose i have:  data A = A{ b :: B, c :: C, d :: D, ... }   with Ord instances for B, C, D : what's a nice way to express a comparator for A given something like [Ascending ByC, Descending ByD, Ascending ByD]
20:14:04 <adu> unkanon: in the mathematical sense it means normal, or a fancy kind of perpendicular, or their inner products defined by convolutions satisfy a certain property, or, ....
20:14:17 <blackdog> adu: there's a presentation by SPJ on that
20:14:35 <blackdog> suggesting that once you have laziness, you're more or less forced to purity
20:14:42 <blackdog> "wearing the hairshirt"
20:16:03 <mikeg> Is there a list of GHC macro/constants? I'd like to print the GHC version info in a Haskell string
20:16:03 <penelope> lazyness -> manual sequencing of state -> monads
20:16:36 <adu> penelope: how so?
20:16:52 <blackdog> mikeg: ghc-paths might be helpful
20:17:10 <blackdog> oh, that only gives you the path it's installed into :/
20:17:23 <mikeg> well, i could probably extract from that
20:17:40 <penelope> Once you have lazyness, you have to contend with out of order execution
20:17:57 <penelope> The natural way to do that, is to pass the state around
20:18:13 <penelope> Which leads you to monads.
20:18:31 <adu> that's a poor argument
20:19:05 <adu> there are other ways of dealing with out-of-order execution
20:19:32 <unkanon> adu: right, and because it means "perpendicular", in computer science when we say that two concepts are orthogonal to each other, we usually mean that one concept doesn't affect the other, or is independent from the other
20:19:33 <Cale> Out of order evaluation, of course.
20:19:41 <Cale> Execution is something else :)
20:20:30 <Cale> The fact that IO actions form a monad is not really very important compared with the fact that they're values of a separate type at all.
20:21:57 <penelope> We use a monad for IO actions in order to sequence their evaluation?
20:23:05 <adu> penelope: ocaml has lazy evaluation and lack of purity
20:23:14 <blackdog> adu: it's not pervasive, though.
20:23:16 <penelope> OCaml is laze?
20:23:30 <adu> penelope: no, it has lazy, strict is default
20:23:56 <pumpkin> penelope: I use applicative a lot more than I use monad
20:24:29 <blackdog> you can implement streams in scheme too, but I don't think there are any languages with default dynamic types and default lazy evaluation
20:24:34 <alex404_> I heart <$>
20:24:40 <adu> http://caml.inria.fr/pub/docs/manual-ocaml/manual021.html#toc73
20:24:51 <penelope> Ok. So, should we do something like declare all our scheme of OCaml functions lazy, it would be difficult to get our operations on external state in order, no?
20:24:52 * blackdog carefully covers his arse in case someone points out Data.Dynamic
20:25:01 <penelope> Scheme or
20:25:42 <adu> blackdog: Data.Dynamic isn't default
20:26:59 <blackdog> adu: exactly, that's why i included the 'default' qualifier;)
20:29:02 <penelope> But isn't that the difference between a strict and lazy language? After all, haskell has strictness annotations.
20:29:45 <penelope> Should we place those on all function arguments, we could probably dispense with the IO monad?
20:29:46 <adu> and ocaml has laziness annotations
20:30:01 <FunctorSalad> "The problem with Haskell is that it's a superb language for solving the sort of problems its designers foresaw. Unfortunately it makes it almost impossible to do things they didn't expect; you're too trapped in the rigours of the Haskell way of doing things. [...] Heck, even doing i/o at all isn't really supported very well."
20:30:15 * FunctorSalad cries
20:30:23 <adu> penelope: now you're confusing the two things blackdog was talking about
20:30:38 <djahandarie> FunctorSalad, ouch, who said that? Harrop?
20:30:39 <penelope> I'm not very bright.
20:31:13 <FunctorSalad> djahandarie: http://tech.slashdot.org/article.pl?sid=08/09/19/1230237 (don't ask me why I'm reading this; I felt brave)
20:33:18 <penelope> But I thought the problem with lazyness and state was the difficulty of ordering the change in state.
20:33:41 <blackdog> FunctorSalad: oh wow, it's not often you see something that's so precisely and exactly wrong.
20:33:54 <djahandarie> FunctorSalad, ugh, now I'm reading it, thanks a lot. :P
20:34:08 <FunctorSalad> djahandarie: maybe s/brave/masochistic :p
20:34:53 <FunctorSalad> the one argument I can let pass is that something involving fibonacci is not brilliant evidence for practical usefulness
20:34:55 <FunctorSalad> ;)
20:35:23 <developernotes> I am getting a parse error when I attempt to load this from a file: http://pastie.org/1265798, any thoughts?
20:36:35 <Charles_> hello
20:36:36 <blackdog> i've never seen a language have so many misspellings before
20:36:53 <blackdog> i mean, ok, sometimes perl gets "pearl" and we all have a bit of a laugh
20:37:04 <blackdog> but Haskel and Hascal actually seem more common than the right one.
20:37:22 <penelope> developernotes: That's for typing in a monad repl, e.g., ghci
20:38:09 <developernotes> penelope: ah, so in the file I just don't use let?
20:38:21 <penelope> Yep.
20:38:42 <developernotes> penelope ah, okay - thanks
20:39:30 <FunctorSalad> blackdog: I assumed 'Hascal' is a joke
20:39:37 <FunctorSalad> comparing it to Pascal
20:40:05 <penelope> Hey, it's techworld. That means some exposure to the PHB.
20:40:22 <FunctorSalad> this other guy argues that since he's never heard of hackage, the haskell community must suck at marketing and he would hence never risk his project (as a project manager) with it
20:40:44 <FunctorSalad> =)
20:40:48 <penelope> He's never heard of Q either.
20:40:51 <blackdog> FunctorSalad: i think that does make sense, in a weird sort of way.
20:40:57 <developernotes> Is there an easy way to look up what module a function is defined within, for example putStrLn?
20:41:11 <blackdog> a lot of software construction in industry is concerned with limiting the worst possible case
20:41:16 <FunctorSalad> blackdog: I thought it was bizarrely "the-universe-revolves-around-me"
20:41:54 <blackdog> choosing to use Haskell in a production app is a ballsy, "fire-me-if-i'm-wrong" sort of move
20:42:02 <penelope> developernotes: if it's already included, :browse is nice
20:42:32 <blackdog> if you have no strong opinions, then current developer uptake is a decent proxy for how easy it's going to be to get replaceable cogs to keep working on it.
20:43:14 <penelope> developernotes: If it's not, you'll want to get hoogle working on your box. http://www.haskell.org/haskellwiki/Hoogle
20:43:18 <FunctorSalad> blackdog: well yes, I agree with that
20:44:13 <developernotes> penelope: thanks.
20:44:32 <FunctorSalad> but it's also an attitude that would prevent any progress, ever. since everything starts out with just its creator(s) knowing it :)
20:44:50 <blackdog> FunctorSalad: Yep. it's a free-rider problem.
20:45:26 <blackdog> which does suggest that in a way, evangelism is the wrong way to go about things - what we need is a few awesome sites/apps that would be hellishly difficult to build in anything else.
20:45:55 <FunctorSalad> *nod*
20:46:00 <blackdog> (I mean active proselytisation, btw - passive evangelism like being awesome to people who come to the channel is an excellent idea and we should keep doing it.)
20:46:28 <blackdog> i was hoping hubris might help there, but i'm having trouble finding ruby web apps that actually need speeding up in the application server layer
20:46:50 <blackdog> usually when a web app is slow, it just means that the database queries are awful, or that the caching strategy is broken.
20:47:49 <blackdog> and i'm still not sure if that just means that people instinctively avoid web app ideas that require non-trivial computation on the server side. it's a hard problem.
20:49:13 <unkanon> blackdog: i'd say the app doesnt need to be hellishly difficult to write in any other language, just insanely easy to write in haskell as compared to other languages
20:49:23 <Saizan> you'd need a domain where it doesn't make sense to precompute most of the information you're going to present
20:49:30 <developernotes> blackdog: ITA software does non-trivial computations on the server, but they were using CL.
20:49:44 <penelope> I think the problem with ruby are scale down, and scale up.
20:50:09 <blackdog> developernotes: yes, ITA is a good example. hm. maybe i need to try something like route planning
20:50:24 <blackdog> unkanon: there's a big activation energy to get over when you're trying to convince project managers
20:50:27 <penelope> Scale up: you need to reduce the hit on the database
20:50:38 <blackdog> if you can come up with a prototype over a weekend, it could work, i guess.
20:51:41 <unkanon> blackdog: true, but there are different kinds of managers. my manager tries untested stuff all the time
20:56:01 <developernotes> another silly question, when I've got two variables that are both lists, I noticed I am not able to just use putStrLn to print them, is there an easy way to do this?
20:56:22 <Veinor> print
20:56:31 <Veinor> @srch print
20:56:31 <lambdabot> print x = putStrLn (show x)
20:58:17 <developernotes> Veinor: I have the following in a file: http://pastie.org/1265829, but the print causes an error.
20:58:52 <Veinor> you want main = print a
20:59:52 <Cale> penelope: Lazy evaluation actually refers to a particular evaluation order, and while we could abuse the knowledge of that order and include lots of primitives whose evaluation causes effects, there would indeed be a lot of unhappy and confusing things which could happen if those primitives were used in the wrong way.
21:00:33 <developernotes> Veinor: ok - now it is compiling, but ghci is just sitting in the prompt now with *Main>
21:00:44 <developernotes> Veinor: it didn't print a
21:00:48 <Cale> penelope: Instead, Haskell doesn't define the evaluation order at all, except to say that it is "non-strict", which is a little different in meaning from just not being strict -- it means that any evaluation order with the same results as lazy evaluation is okay.
21:01:29 <Cale> penelope: So, parts of the program can be made strict by the compiler if it can prove it's okay.
21:01:30 <Veinor> developernotes: well, you defined the function 'main' as 'print a'
21:01:35 <Veinor> so run 'main' in ghci and it'll print a
21:02:37 <developernotes> Veinor: ah - ok.
21:02:45 <Cale> penelope: This gives the compiler lots of freedom to optimise things better, but it also means that effects attached to evaluation don't have a predetermined order at all.
21:04:01 <developernotes> Veinor: so is there a way to load the script so that when a perform a :l lists.hs it actually prints right away? I tried main = print a followed by another line with just main but that didn't work.
21:04:09 <Cale> penelope: So what we do instead is simply to encode the effects we want performed (and the sequence they occur in) as values of an appropriately constructed type, and the effects described by the value main are then carried out.
21:04:16 <Cale> (Which we call execution)
21:04:57 <Cale> Note that execution (the carrying out of effects described by these values of type IO t) is then separate from evaluation (the reduction of expressions into values)
21:05:29 <Cale> So it no longer matters exactly how evaluation occurs, as long as it produces appropriate results.
21:05:56 <Cale> penelope: does that help?
21:07:06 <Cale> To say that this IO type constructor is a monad is just specifying a shape of part of the API for how we can combine our descriptions of effects into larger ones.
21:07:22 <Veinor> developernotes: no, I don't think you can do that
21:07:42 <developernotes> Veinor: ok - thanks
21:07:42 <unkanon> how do i ask lambdabot for the source of " seq " as the one used in foldl' ?
21:07:45 <unkanon> ?src seq
21:07:45 <lambdabot> Source not found.
21:07:47 <unkanon> doesnt work
21:07:55 <shachaf> developernotes: Why do you want that?
21:08:46 <developernotes> shachaf: just writing a script as I learn, would like to be able to output values of assignments as I go along.
21:09:12 <shachaf> developernotes: You can run them with runghc.
21:09:33 <developernotes> shachaf: ok, looking into that now....
21:09:56 <shachaf> developernotes: ghci is specifically meant to be interactive.
21:10:06 <developernotes> gotcha...
21:12:42 <developernotes> shachaf: that works well, thanks for the pointer.
21:14:01 <kmc> unkanon, seq has magical implementation
21:14:06 <kmc> you can define it for specific types
21:14:11 <Veinor> yeah, seq is magical
21:14:11 <kmc> seqBool :: Bool -> a -> a
21:14:14 <kmc> seqBool True x = x
21:14:16 <kmc> seqBool False x = x
21:14:23 <unkanon> kmc: it's a primitive, eh?
21:14:27 <kmc> basically yes
21:14:35 <Veinor> yep.
21:14:47 <kmc> the one with the full type «a → b → b» can't be written in Haskell
21:14:47 <unkanon> hmm too bad, i'd be amazed if it could be done functionally in haskell
21:15:01 <kmc> because you can't pattern-match all algebraic types at once, or any function type
21:15:13 <shachaf> unkanon: You can do it with a type class for any particular type you might want.
21:15:20 <kmc> not for functions, really
21:15:34 <shachaf> Ah, I suppose.
21:15:38 <unkanon> i was thinking for functions :)
21:15:38 <kmc> for any algebraic type where you can see at least one constructor
21:15:40 <kmc> not including newtypes
21:16:08 <kmc> now i wouldn't be surprised if seq has GHC Haskell source, in terms of some GHC primitive ops
21:16:37 <kmc> actually it appears not, it's in GHC.Prim which has no Haskell source
21:17:03 <Veinor> i thought ghc was written in haskell
21:17:08 <kmc> ;P
21:17:14 <Veinor> :D
21:17:52 <unkanon> kmc: how did you find out that it's in GHC.Prim?
21:18:01 <unkanon> just curious
21:18:08 <kmc> ghc -e ':i seq'
21:18:21 <unkanon> ok, thanks!
21:19:09 <kmc> or the same cmd from ghci
21:19:59 <unkanon> cool
21:20:18 <unkanon> got go now, night guys
21:23:01 * hackagebot filemanip 0.3.5.1 - Expressive file and directory manipulation for Haskell.  http://hackage.haskell.org/package/filemanip-0.3.5.1 (BryanOSullivan)
21:44:07 * hackagebot text-icu 0.6.3.0 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.6.3.0 (BryanOSullivan)
21:51:52 <leimy> > (,,) <$> (+4) <*> (+3) <*> (*200) $ 100
21:51:52 <lambdabot>   (104,103,20000)
22:05:56 <kmc> there are singleton unboxed tuples in GHC?
22:06:00 <kmc> addrToHValue# :: Addr# -> (#a#)	
22:08:29 <lars9> when doing my 1st cabal install, i see this: Warning: No 'build-type' specified. If you do not need a custom Setup.hs or
22:08:32 <lars9> ./configure script then use 'build-type: Simple'.
22:08:45 <lars9> where should i specify build-type?
22:11:31 <Saizan> lars9: inside the .cabal file, among the fields at the start
22:12:26 <lars9> Saizan: thanks, how can i edit cabal file when doing cabal install? it's automatic..
22:13:50 <Saizan> lars9: oh, if you're just installing someone else's package then you don't need to fix it
22:14:38 <Saizan> the installation should continue
22:15:11 <lars9> Saizan: Text/Regex/Parsec/String.hs:29:17: Could not find module `Data.IntMap':
22:15:30 <lars9> but in fact, i can import Data.IntMap in ghci
22:15:31 <Saizan> but in general you can use "cabal unpack packagname" to get the source
22:16:08 <Saizan> lars9: ah, that probably means it lacks containers in the "build-depends" field in the .cabal
22:16:20 <Saizan> lars9: which package is this?
22:16:51 <lars9> Saizan: regex-parsec. but i have had that package, because i can see it in ghci..
22:18:38 <Saizan> uhm, regex-parsec is quite old, and never got updated to work with ghc >= 6.8
22:19:42 <Saizan> lars9: the problem is not that you don't have Data.IntMap installed, but that regex-parsec.cabal doesn't ask for Data.IntMap's package (which is "containers"), so Cabal won't use it during compilation
22:20:02 <lars9> Saizan: oh i see, then i'll just choose another regex pkg
22:21:42 <pelotom> what's the blessed regex lib?
22:21:49 <lars9> dunno
22:22:04 <lars9> why http://www.haskell.org/haskellwiki/Regular_expressions said regex-posix is *very* slow?
22:22:30 <lars9> if it's a wrapper of posix regex lib, then it should be as fast as c lib?
22:23:01 <lars9> _crap_
22:23:45 <pelotom> I think that just means "posix-style" regex
22:24:39 <pelotom> but I could be wrong
22:25:10 <Saizan> lars9: it's saying that the C lib itself is very slow compared to the others
22:25:21 <Saizan> or some others at least
22:25:48 <Saizan> though i guess it's also a matter of what features are supported
22:26:19 <lars9> Saizan: oops, another example that haskell is faster than c?
22:27:06 <donri> Depends how you use either, don't it?
22:27:20 <Saizan> lars9: i think it's a matter of algorithms here, mostly
22:27:44 <Saizan> there are many different ways to implement a regex engine
22:27:47 <lars9> Saizan: yeah, maybe algorithms and supported features matters
22:28:13 <Saizan> (well, don't know about many, but at least quite different ways :)
23:03:38 <FunctorSalad> :O did you know? (<$) is actually a method of Functor
23:04:17 <FunctorSalad> with a default, but still
23:07:12 <kmc> :O
23:07:23 <kmc> mind = blown
23:07:35 <kmc> that must be recent-ish
23:07:55 <Saizan> yeah, only in ghc 7, bet
23:08:10 <kmc> i have it on 6.12.1
23:08:52 <FunctorSalad> maybe not that mind-blowing, but somehow it surprised me
23:08:57 <Saizan> :O
23:29:24 <pelotom> hi, I'm reading this: http://book.realworldhaskell.org/read/using-databases.html
23:31:13 <pelotom> I'm surprised by this: http://hpaste.org/41046/hdbc_stuff
23:32:41 <Saizan> why?
23:32:43 <pelotom> hm, no wait, I guess this makes sense
23:33:31 <pelotom> I was going to say I couldn't believe the conn wasn't wrapped in IO, but I see now that <- is unwrapping it
23:33:40 <pelotom> sorry :)
23:33:40 <Saizan> yeah
23:35:16 <pelotom> I hadn't seen that use of <- outside of do notation... I take it that's exclusively for ghci?
23:36:47 <Veinor> well, ghci is basically running 'inside the IO monad'
23:36:56 <Veinor> which is why you need to use let
23:37:13 <Veinor> but yeah, you can't use <- outside of a do-block like that
23:37:15 <pelotom> ah, interesting
23:42:44 <pelotom> and also why you can't make data declarations in ghci, I suppose
23:55:06 <adsfasdf> what is this?
23:55:10 <adsfasdf> i dont get it
23:57:33 <Jonno_FTW> what don't you get?
23:59:15 <pelotom> adsfasdf: it's a place where you can ask questions about haskell
