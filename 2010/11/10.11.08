00:13:06 <lars9> is haskell read as h-a-s-k-el or h-ah-s-k-l or something else?
00:13:21 <codolio> Haskle
00:16:02 <lars9> codolio: h-a-s-kl ? the 'a' is like the one in 'at'?
00:16:33 <codolio> It sounds like hassle, only with a sk.
00:16:59 <lars9> codolio: i see, thanks
00:36:20 <20QACH08C> the imlib2 binding does not contain "imlib_render_image_on_drawable". is it not supposed be there?
00:59:43 * hackagebot seal-module 0.1 - Template Haskell support for global configuration data  http://hackage.haskell.org/package/seal-module-0.1 (JoachimBreitner)
01:07:38 <winmike> hi
01:08:10 <winmike> how can i do mutiple calls in a row? i have "| otherwise          = itemDepth t1 p" and also want to call itemDepth t2 p in otherwise
01:08:42 <Zao> winmike: What do you want to do with the results?
01:08:54 <Zao> It's rather pointless to evaluate an expression if you don't need the value.
01:09:10 <Zao> (assuming you're talking about pure code and not IO)
01:09:23 <winmike> Zao, ah yes - your are right :(
01:09:34 <winmike> Zao, havent considered that *g*
01:09:46 <kmc> it's also pointless to evaluate IO actions if you won't use them
01:10:03 <kmc> evaluating an IO action is a different thing from executing it and actually performing the action (you might still throw out the *result*, though)
01:10:40 <Zao> kmc: Note that I never talked about "evaluating IO"
01:10:50 <Zao> The IO disclaimer was for the whole discussion.
01:10:56 <kmc> yeah, i'm not correcting you Zao, just clarifying
01:10:58 <kmc> i know you know etc
01:11:05 <kmc> winmike, don't think in terms of "do this, then do that"
01:11:09 <kmc> think in terms of "this equals that"
01:11:12 * Zao raises his fists in an amusing way
01:11:16 <edgimar> Can somebody shed some light  on when you use the <+> arrow? (i.e. what its typical uses are -- I know its definition).
01:11:22 <kmc> factorial of 0 is 1
01:11:29 <kmc> not "to compute factorial of 0, make a 1 and return it"
01:12:10 <sipa> :t <+>
01:12:11 <lambdabot> parse error on input `<+>'
01:12:26 <kmc> edgimar, arrow? and what's the context, what module?
01:12:29 <edgimar> Seems to be defined in Control.Arrow.
01:12:38 <edgimar> But I see it also in xmonad.hs.
01:12:46 <kmc> well, it's not an Arrow -- an Arrow is a type
01:12:55 <kmc> and it's likely the xmonad definition has nothing to do with Control.Arrow
01:14:35 <edgimar> kmc: that may be true.  But I don't really know where to find details on how it's implemented for xmonad -- I see things like "xmonad $ myConfig {manageHook = manageDocks <+> myManageHook <+> manageHook myConfig}", and would like to understand what it means.
01:14:49 <kmc> edgimar, you would look through the xmonad docs
01:14:57 <kmc> http://hackage.haskell.org/package/xmonad
01:15:28 <kmc> it's in XMonad.ManageHook
01:15:30 <edgimar> ah, thank you.
01:15:32 <kmc> (<+>) :: ManageHook -> ManageHook -> ManageHook
01:15:35 <kmc> "Compose two ManageHooks."
01:15:38 <edgimar> Yes, I found it. 
01:16:20 <kmc> also i'm confused why you said "I know its definition" then
01:16:26 <kmc> especially if you were thinking of the Arrow operator
01:16:34 <kmc> which is in a type class, and therefore defined differently for every type
01:17:55 <edgimar> I saw the following, perhaps it wasn't exactly a 'definition'... : class ArrowZero a => ArrowPlus a where (<+>) :: a b c -> a b c -> a b c
01:18:35 <kmc> yeah, that defines the class ArrowPlus, and gives a type signature for (<+>), but does not actually give the code for (<+>)
01:18:40 <kmc> that would be in each individual instance
01:18:50 <edgimar> mind you I am (obviously) far from a haskell expert...
01:19:01 <kmc> just like «f :: Int -> Int; f x = x+1»
01:19:17 <kmc> the first half is a type signature; the second half defines what the function actually does
01:19:32 <kmc> are you interested in learning more Haskell?
01:19:37 <kmc> this is the place to be ;)
01:19:48 * hackagebot seal-module 0.1.0.1 - Template Haskell support for global configuration data  http://hackage.haskell.org/package/seal-module-0.1.0.1 (JoachimBreitner)
01:20:57 <edgimar> sure.  I've browsed through some online guides -- and started by just playing around with my xmonad config -- xmonad is partly what lured me in.
01:21:12 <_mpu> what is the meaning of ArrowPlus ?
01:21:14 <winmike> sorry - stupid question ;) is there also some real world use for haskell or just vor university and private use?
01:21:29 <kmc> winmike, it's a general purpose language; you can write any kind of program in it
01:21:36 <kmc> does "real world" mean "money-making"?
01:21:45 <winmike> yes - the question is if i would ;)
01:21:48 <kmc> http://haskell.org/haskellwiki/Haskell_in_industry
01:21:50 <winmike> i wouldnt - i think ;)
01:21:58 * ManateeLazyCat pasted "simpleUserHooks test" at http://paste2.org/get/1078943
01:21:58 <ManateeLazyCat> I write some print code in hook of simpleUserHooks (Steup.hs), like above. But looks can't work, any tips? :)
01:22:43 <kmc> it's been used by Google, Facebook, a bunch of investment banks, by Galois for a bunch of high-security government stuff, etc.
01:23:49 * hackagebot haskell-src-exts 1.9.6 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.9.6 (NiklasBroberg)
01:24:05 <winmike> kmc, i'm too stupid for haskell ;)
01:24:07 <kmc> wow there's a bunch more of these
01:24:14 <kmc> companies since i last checked
01:24:18 <ManateeLazyCat> kmc: Google use Haskell for what? I'm curious
01:24:25 <kmc> ManateeLazyCat, it's linked
01:24:31 <kmc> they wrote a paper
01:24:40 <kmc> winmike, i doubt it, the main thing is you need to stick with it for a long time
01:24:44 <ManateeLazyCat> kmc: Can you give me some link about those papers? Thanks,
01:24:49 <kmc> ManateeLazyCat, see above
01:24:55 <kmc> http://k1024.org/~iusty/papers/icfp10-haskell-reagent.pdf
01:25:13 <kmc> winmike, some people expect that learning a new language is just learning new syntax for Java or Python or whatever
01:25:16 <kmc> Haskell is not like that
01:25:21 <kmc> and it can be really frustrating in the beginning
01:25:31 <kmc> when all you know how to do is trivial math puzzles and even that is an uphill battle
01:25:38 <earthy> not just in the beginning. :)
01:25:58 <kmc> well once you know it well, Haskell is frustrating for other reasons
01:26:08 <kmc> foremost that writing correct code is frustrating and hard
01:26:11 <kmc> in any language
01:26:20 <kmc> and Haskell pushes more of the frustration up front
01:26:22 * earthy nods
01:26:37 <kmc> and of course it's not a perfect language, there's plenty of legit annoyances that don't go away
01:26:42 <earthy> the frustration is at an entirely different level when compared to java
01:26:46 <kmc> or become worse once the "omg quicksort is so short" glow wears off
01:26:57 <ManateeLazyCat> Ah, got it, you need set 'build-type' with `Custom` in your .cabal file, otherwise simpleUserHooks can't work.
01:27:02 <winmike> http://codepad.org/bBUOayje does anybody know how i can make flatten adds the current depth of the n value too?
01:27:25 <kmc> add to what?
01:28:04 <kmc> to track depth you'd probably want an extra parameter
01:28:16 <winmike> current result is [22,3,11,1,2] - i want [[22,X],[3,X],[11,X],[1,X],[2,X]] where X is the depth of the item
01:28:29 <kmc> are you sure you want 2-elem lists, rather than tuples?
01:28:42 <winmike> or tuples - also ok
01:28:46 <kmc> probably better
01:28:53 <frerich7> winmike: I think Haskell is very good for articulating solutions at a certain class of programming problems: well-defined problems whose implementations need to be stable and maintainable. Unfortunately, in my experience, "real world" projects are quite volatile so all the "up front" frustration Haskell gives (because it's so good at detecting problems in your code) is sometimes (often?) not worth it beacuse you're
01:28:54 <frerich7>  going to throw everything away in favor of something else.
01:28:55 <kmc> anyway, you can pass the depth around
01:28:59 <ManateeLazyCat> kmc: Nice paper, thanks for share. :)
01:29:16 <kmc> you could just add an extra arg to flatten
01:29:18 <kmc> or make it internal:
01:29:30 <kmc> flatten = go 0 where { go d (Leaf n) = ...; go d (Node n l r) = ... }
01:29:35 <kmc> you'd make a recursive call to (go (d+1))
01:29:49 <winmike> frerich7, we have to use it at university. and they always give also coding execirces that i've never seen before in any other problems
01:30:04 <winmike> kmc, extra argh sounds goot
01:30:09 <winmike> good
01:30:11 <winmike> ups ;)
01:30:59 <kmc> frerich7, i think it depends where the volatility comes from.  Haskell has been used successfully by small internal R&D teams where the change in requirements is due to letting the problem statement settle more naturally
01:31:10 <kmc> being really precise up front is a big win there
01:31:40 <kmc> it's not so good when the volatility is from the customer (or other business concerns) changing their mind
01:32:12 <frerich7> Yes, that's my impression as well.
01:32:40 <kmc> in fact there's many groups, and individual people, who use Haskell at the mockup or prototype stage as a driver of idea-refinement, then something else to implement
01:32:53 <kmc> of course you may find that your 200 line prototype actually solves the problem you need to solve
01:33:16 <kmc> i hear google had some of those, then rewrote them as 2000+ lines of Java anyway, because Java Is Supported
01:33:17 <tab> kmc: and the other ways around too (prototype in X, and stable software in haskell)
01:33:24 <kmc> tab, interesting
01:33:48 <kmc> i've definitely moved a project from Python to Haskell for reasons of performance
01:34:02 <kmc> and i could see doing it once the Python program reaches the size where dynamic typing is infeasible
01:34:03 <tab> it happened where i work, we throw away a ruby daemon and replaced it by haskell
01:34:08 <tab> threw*
01:34:08 <kmc> but these days i start out in Haskell ;)
01:34:12 <kmc> interestincg
01:34:59 <ManateeLazyCat> kmc: There is a problem, only a few companies use Haskell, it's a bit hard to find haskell job. 
01:35:11 <tab> also, haskell isn't that bad to do sequential IO code ..
01:35:22 <tab> never dropping the IO monad
01:35:27 <kmc> yeah
01:36:22 <kmc> half of what makes Haskell good is just little stuff that they got right
01:36:28 <kmc> not having to do with big ideological decisions
01:36:47 <tab> they are interesting too
01:37:08 <kmc> your sequential IO code can benefit from first-class functions, polymorphism, type inference, etc
01:37:32 <tab> yep. type inference is the big winner here
01:37:36 <kmc> these are not controversial ideas for functional programming radicals, they're good ideas from 40+ years ago which are widely ignored
01:38:42 <kmc> anyway less rant, more sleep
01:38:43 <kmc> ttyl
01:39:03 <winmike> kmc, you mean something like http://codepad.org/eKQOaPh6 ?
01:40:51 <winmike> doesnt work :(
01:42:40 <winmike> kmc, sorry flatten l x+1 :D as i said - too stupid for haskell ;)
01:44:00 <winmike> how can i remove the dummy parameter in flatten? is there a way? http://codepad.org/8CeUatQw
01:44:14 <winmike> without building another dummy function ;)
01:50:38 <Maddas> I think part of the reason Haskell got so many little things right is actually their focus on purity. Not that it's strictly because of purity, but having some model to adhere to forces you to do things right and removes one source of sloppy decision making due to laziness :-)
01:51:04 <earthy> winmike: well, you want flatten to have type Tree -> [(Integer,Integer)] right?
01:51:39 <earthy> then flatten t = flatten' t 0  where  flatten' ...
01:51:45 <winmike> earthy, flatten + the depth of the element
01:52:12 <winmike> earthy, no way without a dummy function?
01:52:22 <earthy> it's not dummy, now is it?
01:52:50 <earthy> there is an initialization that needs to be specified
01:53:01 <winmike> hmm i see
01:54:18 <winmike> in next life i will understand all the stuff ;))
02:01:30 <bababobo> wow
02:02:52 <TheMonoid> Is Judah Jacobson here?
02:03:35 <TheMonoid> Or somebody who's familiar with Haskeline?
02:07:01 <TheMonoid> On Windows 7, I get crash when press "Ctrl-l"
02:08:13 <TheMonoid> I confirm that's a bug in Haskeline, even with "getInputChar", when press "Ctrl-L", it would crash
02:12:03 <Saizan> http://trac.haskell.org/haskeline/ <- you should report it here
02:32:17 <Saizan> seal-module looks great
02:32:52 <Mitar> ?
02:33:06 <Saizan> http://hackage.haskell.org/packages/archive/seal-module/0.1.0.1/doc/html/Language-Haskell-SealModule.html
02:33:37 <Saizan> abstract over things at the declaration level with some simple TH
02:35:32 <turiya> can someone point me to a simple source and compilation procedure for haskell FFI?
02:35:42 <Saizan> works only for values though, we need something similar for types
02:39:13 <Saizan> ..we can use a zero-arg type family as the dummy
02:44:07 * Eduard_Munteanu came back
02:44:14 <Eduard_Munteanu> ... so quiet in here.
02:52:43 <Saizan> monday morning, belhac, ..
02:55:03 <Eduard_Munteanu> Hm, wasn't there a #haskell-math? It's empty. :(
02:55:11 <h-cell> I have a 3 - 4 - 5 triangle and would like to compute the angle in degrees between the sides of length 3 and 4. obviously the answer is 30 degrees, but haskell seems to have problems with that. can anyone explain?
02:55:13 <h-cell> > acos (4/sqrt(3^2+4^2)) * (180/pi)
02:55:14 <lambdabot>   36.86989764584401
02:55:45 <h-cell> *4 and 5
02:55:46 <Eduard_Munteanu> > acos 0
02:55:47 <lambdabot>   1.5707963267948966
03:01:48 <Saizan> h-cell: if the angle between the 4-side and the 5-side was 30° then the angle between 3-side and 5-side would be 60° (the other one is 90°), so you'd have half of an equilateral triangle, but 2*3 /= 5
03:01:54 <Eduard_Munteanu> h-cell: sin 30 = sin pi / 6 = 1 / 2 => 3 / 5 = 1 / 2
03:02:40 <Eduard_Munteanu> Which is a contradiction.
03:03:35 <Cale> h-cell: You're thinking of a different triangle.
03:04:00 <Cale> (not a (3,4,5) triangle)
03:04:02 <quicksilver> these are the not the triangles you are looking for.
03:04:46 <Cale> Specifically, the (1/2, sqrt(3)/2, 1) triangle, probably.
03:05:26 <Eduard_Munteanu> Yeah, (3,4,5) is remarkable, but not in that way.
03:05:56 <Cale> > acos (sqrt 3 / 2) * (180/pi)
03:05:57 <lambdabot>   30.000000000000004
03:06:24 <Eduard_Munteanu> Not very sure, but I think it is one of the few solutions to Fermat's theorem.
03:06:33 <Cale> ?
03:06:56 <Cale> Fermat's last theorem is about x^n + y^n = z^n where n >= 3.
03:07:28 <Cale> Triples (x,y,z) where x^2 + y^2 = z^2 are called Pythagorean triples, and there are infinitely many of them
03:07:28 <opqdonut> (3,4,5) is merely a pythagorean triple
03:07:44 <Eduard_Munteanu> Ah, so it's not really that unique, my bad.
03:07:49 <opqdonut> infinitely many with integer values, even
03:08:02 <Cale> right
03:08:09 <Cale> Integer values in both cases
03:08:22 <shachaf> It's not particularly interesting with non-integer values. :-)
03:08:41 * shachaf wonders if it's true of rationals.
03:08:44 * Eduard_Munteanu too
03:08:45 <paolino> > filter (\(x,y,z) -> x ^ 2 + y ^ 2 == z ^ 2) $ [1..20]  >>= \x -> [1..20] -> \y -> [1..20] -> return (x,y,z)
03:08:46 <lambdabot>   <no location info>: parse error on input `->'
03:09:15 <paolino> > filter (\(x,y,z) -> x ^ 2 + y ^ 2 == z ^ 2) $ [1..20]  >>= \x -> [1..20] >>= \y -> [1..20] >>= \ z ->  return (x,y,z)
03:09:16 <Eduard_Munteanu> I think if so, it'd make them interesting because they're constructible.
03:09:16 <lambdabot>   [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(8,15,17),(9,12,15),(12,5,13),...
03:09:34 <Eduard_Munteanu> or at least constructible if those irrationals can't be related.
03:10:07 <Eduard_Munteanu> So that would be a point of interest.
03:10:10 <sipa> > [ (m*m-n*n,2*m*n,m*m+n*n) | n <- [0..], m <- [n+1..] ]
03:10:11 <lambdabot>   [(1,0,1),(4,0,4),(9,0,9),(16,0,16),(25,0,25),(36,0,36),(49,0,49),(64,0,64),...
03:10:19 <sipa> > [ (m*m-n*n,2*m*n,m*m+n*n) | n <- [1..], m <- [n+1..] ]
03:10:20 <lambdabot>   [(3,4,5),(8,6,10),(15,8,17),(24,10,26),(35,12,37),(48,14,50),(63,16,65),(80...
03:10:30 * hackagebot wumpus-core 0.37.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.37.0 (StephenTetley)
03:10:36 <Cale> sipa: You'll need to do something to diagonalise
03:10:45 <sipa> indeed
03:11:10 <_mpu> > [(x, y, z) | x <- [1..20], y <- [1..20], z <- [1..20], x^2 + y^2 = z^2]
03:11:11 <lambdabot>   <no location info>: parse error on input `='
03:11:19 <_mpu> > [(x, y, z) | x <- [1..20], y <- [1..20], z <- [1..20], x^2 + y^2 == z^2]
03:11:20 <lambdabot>   [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(8,15,17),(9,12,15),(12,5,13),...
03:11:29 <Cale> I had a Haskell file where I constructed all the primitive triples using an enumeration of the positive rational numbers
03:11:30 <Eduard_Munteanu> Heh. That's brute force.
03:11:51 <Cale> But I can't find it at the moment. I think it's on my other machine which is off right now.
03:11:55 <sipa> > [ (m*m-n*n,2*m*n,m*m+n*n) | m <- [1..], n <- [0..m-1] ]
03:11:56 <lambdabot>   [(1,0,1),(4,0,4),(3,4,5),(9,0,9),(8,6,10),(5,12,13),(16,0,16),(15,8,17),(12...
03:12:21 <Eduard_Munteanu> I wonder, is evaluation order firmly defined in that comprehension?
03:12:41 <sipa> Eduard_Munteanu: the order of the result is
03:13:31 <Eduard_Munteanu> sipa: I mean, how does Haskell know not to try y = 1, z = 1 and x...
03:13:32 <Eduard_Munteanu> crap
03:13:41 <Eduard_Munteanu> I just saw the lists aren't infinite.
03:14:06 <sipa> if the second one were infinite, you'd never see the second element of the first list
03:14:14 <sipa> (that's what happened in my earlier attempt)
03:14:20 <Eduard_Munteanu> Yeah, I guessed that would be shaky.
03:15:51 <Eduard_Munteanu> Okay, since #haskell-math isn't available...
03:16:03 <Eduard_Munteanu> What would you recommend for plotting 2D graphs?
03:16:12 <Eduard_Munteanu> gnuplot, chart, something else?
03:16:34 <_mpu> I found gnuplot nice, when I had to plot graphs
03:16:56 <Eduard_Munteanu> (of course, I'm talking about the bindings/packages on Hackage)
03:17:18 <Eduard_Munteanu> _mpu: I see. I could go with that, it seems safe.
03:18:59 <h-cell> Eduard_Munteanu: thanks for the help. I got pythagorean triple confused with 30-60-90 triange. 
03:19:59 <Eduard_Munteanu> That doesn't sound like a sexy triangle :P
03:20:47 <Eduard_Munteanu> (admittedly they're always short because of the 180 degrees rule :D)
03:38:03 <_mpu> @pl \x -> [x]
03:38:03 <lambdabot> return
03:43:40 <dixie> hmmm, how to get full path of the executable being executed? Something like System.Environment.getProgName but with full pathname.
03:44:12 <Zao> Which full pathname?
03:44:18 <Zao> There may be zero, one or many.
03:44:42 <dixie> e.g. when I execute the d:/prog/something.exe
03:45:19 <dixie> I would like to see complete relative or full pathname (which has been used in invocation).
03:46:11 <Saizan> dixie: http://hackage.haskell.org/trac/ghc/ticket/3199
03:49:38 <dixie> Saizan: thanks. I'm not very familiar with the process behind GHC and Libraries development. 
03:50:05 <dixie> Is the conclusion that the current behavior should be kept as it is but new library / function should be introduced?
03:50:25 <Saizan> i think there has been no conclusion
03:51:12 <dixie> anyway, there is an example how to do it using FFI
03:52:11 <quicksilver> argv[0] is not the full path name, afaik
03:52:18 <quicksilver> argv[0] is just what the user typed.
03:52:19 <Vanadium> WinAPI has a function like GetModuleFileName, anyway, and linux has /proc/self/exe, right?
03:52:38 <Vanadium> argv[0] can be pretty useless with aliases or crazy temporary PATH settings
03:52:51 <sipa> or symlinks
03:52:52 <quicksilver> it's really not a sensible thing to want to know
03:53:01 <quicksilver> there are all kinds of whays of executing programs
03:53:18 <quicksilver> if you want to know what directory your executable is in you're probably asking the wrong question.
03:53:27 <sipa> something like /proc/self/exe in linux will give you ghci if you're running in ghci
03:53:30 <dixie> Yes. I understood now. 
03:53:32 <sipa> is that what you want?
03:53:54 <quicksilver> (executables which change behaviour when you move them around the disk are a bit surprising)
03:54:39 <dixie> This is very simple utility application and I would like to put the configuration files along with executable. It used on windows.
03:55:39 <quicksilver> I would put the config file in the standard windows place (Documents and Settings? is it?).
03:56:44 <dixie> quicksilver: Sorry, the correct name would be "application related data" like a templates. 
03:57:36 <quicksilver> well, I'm not being very helpful. I don't know how to do what you want, I'm afraid :)
03:57:54 <quicksilver> I still personally think that's poor behaviour, but that's not the reason I don't know the answer.
03:58:33 <dixie> quicksilver: I agree that for wide deployed application it would make sense to do it according the standard rules, e.g. installation. 
03:59:21 <dixie> This is something very quicky, and dirty solution is ok ... like using a getFullProgName from that ticket (FFI).
03:59:40 <Vanadium> quicksilver: There is a scheme of portable applications that you can put on an USB drive to take with you and they will run out of the box and not drop/expect files on the system drive.
03:59:44 <Eduard_Munteanu> Grr he might have a point...
04:00:01 <Eduard_Munteanu> Which 'share' would you be looking for in Unixes?
04:00:13 <Eduard_Munteanu> For lib or bin it works in other ways.
04:00:13 <Vanadium> It is a worthwhile use case even if it should not be the default behaviour for stuff you actually install in /usr/bin
04:01:19 <Eduard_Munteanu> I'd rather have it be $EXEC_PATH stripped of '/bin', which gives you a prefix to share/
04:01:34 <quicksilver> Vanadium: sure. That's a valid point.
04:01:52 <Eduard_Munteanu> That or whatever $PREFIX you supplied to ./configure, but still, that would be hardcoded and wouldn't work if not installed.
04:02:20 <quicksilver> Vanadium: although it feels like a corner case to me, because most machines you have access to should not permit running executables off USB sticks
04:02:46 <sipa> why not?
04:02:59 <Eduard_Munteanu> quicksilver: noexec is weak, he could just copy and run it.
04:03:20 <Eduard_Munteanu> And it rather makes sense in other places.
04:03:24 <sipa> in that case you might add that you shouldn't be able to run self-compiled binaries either
04:04:43 <quicksilver> sipa: that's right, you should.
04:04:55 <quicksilver> sipa: and if you *can* run self-compiled binaries, what's the point of your USB stick?
04:04:56 <Eduard_Munteanu> (you really can't)
04:05:24 <sipa> quicksilver: if i'm not allowed to run self-compiled binaries, a computer is worthless to me :)
04:05:36 <quicksilver> sipa: but you wouldn't bother with the USB stick, either.
04:05:43 <Eduard_Munteanu> At least not in Unix DAC.
04:05:46 <quicksilver> there are two cases : either you have privileges to run your own stuff or you don't.
04:05:47 <Vanadium> I am not using the USB stick to break someone's system.
04:05:52 <Vanadium> :<
04:06:01 <quicksilver> if you have privileges to run your own stuff, why would you bother with the USB stick?
04:06:10 <sipa> to transfer things?
04:06:13 <Eduard_Munteanu> I can always simply write an executable, which I'll own by default, and whose permissions I can change.
04:06:14 <sipa> large things?
04:06:18 <quicksilver> if you don't then the USB stick shouldn't help unless the system is poorly design.
04:06:20 <Eduard_Munteanu> and I can simply chmod +x it
04:06:23 <quicksilver> sipa: that's not what we're talking about!
04:06:34 <quicksilver> sipa: we're talking about Vanadium's suggestion of an application designed to run off a USB stick.
04:07:19 <Vanadium> (games, web browsers, diagnostics/spyware removal tools, ...)
04:07:57 <Eduard_Munteanu> Here's a question for you... does any Linux application work correctly if (1) it uses a $PREFIX/share/ directory and accesses that data and (2) you move it around without recompiling?
04:08:12 <Maddas> @pl f x = x + 1
04:08:12 <lambdabot> f = (1 +)
04:08:21 <Eduard_Munteanu> If so I guess there must be some way of getting the path.
04:08:49 <Vanadium> No, they tend not to.
04:08:59 <Vanadium> PREFIX is a compile time setting <:)
04:09:33 <Eduard_Munteanu> Yeah, I didn't try much in that way. Though quite a few autoconf-based apps work without 'make install'.
04:10:12 <Eduard_Munteanu> And they surely have data files somewhere, not just binaries and libs (you could argue those are found via LD_LIBRARY_PATH or something like that)
04:10:47 <quicksilver> Eduard_Munteanu: almost all software compiled in the normal Linux "./configure" model has hardcoded paths.
04:10:53 <quicksilver> this is, basically, a security policy decision
04:11:01 <quicksilver> although it is applied to software which has no security implications too
04:11:06 <quicksilver> just because it's easier to be consistent.
04:11:18 <Eduard_Munteanu> Yeah, it makes sense.
04:11:23 <Vanadium> quicksilver: It really bugs me for some reason, though
04:11:31 <Vanadium> I do not think I understand the security implications.
04:11:37 <sipa> it stems from the philosophy that each file has a designated location
04:11:46 <Eduard_Munteanu> I use --prefix=~/foo a lot, but I don't bother messing with that after installing.
04:11:58 <sipa> but you can decide how to map those locations to physical disks
04:12:15 <quicksilver> Vanadium: you don't want an attacker to be able to change the way software behaves by tricking a privileged user into running it against a non-standard config file
04:12:29 <quicksilver> Vanadium: you assume the attacker doesn't have write privileges to the standard config location.
04:21:01 <astroboy> I am trying to include just the SourcePos data type from Parsec, like that: "import Text.ParserCombinators.Parsec (SourcePos(..))" but ghc keeps on telling me "Not in scope: data constructor `SourcePos'"
04:22:05 <Adamant> Vanadium: relative paths can be abused for all sorts of interesting trickery
04:25:16 <Adamant> also, path operators like .. and . can be used for all sorts of nonsense
04:27:34 * hackagebot hint 0.3.3.1 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.1 (DanielGorin)
04:31:33 <quicksilver> astroboy: SourcePos is a datatype not a constructor
04:31:47 <quicksilver> astroboy: that error message tells me you must be using it in a way which makes it look like a constructor
04:31:52 <quicksilver> astroboy: a.k.a. "wrongly".
04:39:27 <Eduard_Munteanu> Does occasional use of "x <- return $ ..." look like bad style to you?
04:39:31 <PietJanssen> currently checking some combined type declarations but I dont understand how this one works:
04:39:34 <PietJanssen> Main> :type id id :: a -> a
04:39:40 <PietJanssen> Main> :type curry curry :: ((a,b) -> c) -> a -> b -> c
04:39:47 <PietJanssen> Main> :type curry id curry id :: a -> b -> (a,b)
04:40:01 <PietJanssen> how come curry id is a -> b -> (a,b) ?
04:40:12 <PietJanssen> i do understand the other onces like uncurry zip etc
04:40:18 <Jafet> Eduard: yes, because it can either be rewritten with let or it is dirty code
04:40:23 <PietJanssen> *ones
04:41:18 <PietJanssen> does anyone understand my question? :)
04:41:26 <Eduard_Munteanu> Jafet: I'm not sure I can use 'let' when it depends on another '<-' bound value, unless you mean making it a function and passing that as an arg.
04:42:08 <hpc> :t curry id
04:42:09 <lambdabot> forall a b. a -> b -> (a, b)
04:42:31 <hpc> :t curry ?id
04:42:32 <lambdabot> forall a b c. (?id::(a, b) -> c) => a -> b -> c
04:42:43 <PietJanssen> yeah thats what it says but I dont see how that one works
04:42:49 <hpc> id :: (a, b) -> (a, b)
04:42:50 <Jafet> Eduard: "depends on"? Which monad is this?
04:43:02 <PietJanssen> :t id
04:43:02 <lambdabot> forall a. a -> a
04:43:03 <hpc> c = (a, b), so curry id = a -> b -> (a, b)
04:43:07 <PietJanssen> thats from a to a
04:43:52 <PietJanssen> i dont understand that lsat one hpc , c = (a, b), I understand that
04:44:06 <PietJanssen> but how can curry id be a -> b -> (a, b)
04:44:07 <PietJanssen> ?
04:44:19 <hpc> PietJanssen: curry f :: a -> b -> c
04:44:26 <hpc> c = (a, b)
04:44:28 <hpc> substitute
04:44:38 <Eduard_Munteanu> Jafet: say I use something like this: 'func = do { a <- getSomeValue; b <- return $ NonMonadicFunction a; ... }
04:44:41 <PietJanssen> hm
04:44:45 <PietJanssen> but 
04:44:46 <PietJanssen> :t curry
04:44:47 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
04:44:53 <Eduard_Munteanu> Jafet: how would you get around that?
04:44:56 <PietJanssen> curry starts with (a, b) to some c
04:45:03 <PietJanssen> you use the id as argument for that
04:45:16 <hpc> PietJanssen: yes; how does id fit the type (a, b) -> c?
04:45:27 <Jafet> Eduard_Munteanu: do { a <- getSomeValue; let b = nonMonadicFunction a; ... }
04:45:30 <PietJanssen> thats the part I dont see hpc  :)
04:45:30 <Eduard_Munteanu> *nonMonadicFunction for pedantry
04:45:33 <hpc> :D
04:45:43 <PietJanssen> since id = a -> a
04:46:02 <Eduard_Munteanu> Jafet: oh, so lets are scoped depending on their position, never thought of that, thanks.
04:46:07 <hpc> PietJanssen: id :: a -> a; *we don't know what the a is*
04:46:17 <hpc> PietJanssen: so we look at the type of curry for more information
04:46:35 <Eduard_Munteanu> Jafet: (as in it brings the right binding within their scope)
04:46:46 <hpc> PietJanssen: it says (a, b) -> c; so now we have a function from a thing to itself, that has to take a tuple as its argument
04:46:57 <hpc> PietJanssen: and (a, b) -> (a, b) is the solution
04:47:14 <Jafet> Eduard: study the desugaring of do
04:47:33 <Jafet> @undo do { a <- getmonadic; let b = nonmonadic a; return b }
04:47:33 <lambdabot>  Parse error at "}" (column 54)
04:47:38 <Eduard_Munteanu> I suppose that desugars to: getSomeValue >>= (\a -> (let b = nonMonadicFunction a in ...))
04:47:38 <Jafet> What
04:47:49 <PietJanssen> so the a from id should result the (a,b) as input for curry
04:47:49 <Jafet> Pretty much
04:48:01 <Jafet> @undo do { a <- getmonadic; let b = nonmonadic a; return b; }
04:48:01 <lambdabot>  Parse error at ";" (column 53)
04:48:03 <Eduard_Munteanu> Jafet: yeah, only the 'let' was a mystery, now I get it.
04:48:09 * Jafet gives up
04:48:19 <Eduard_Munteanu> Jafet: thanks, I understand it anyway now.
04:48:24 <hpc> PietJanssen: indeed
04:48:34 <PietJanssen> I see
04:48:38 <Saizan> @undo do { a <- getmonadic; let {b = nonmonadic a}; return b; }
04:48:38 <lambdabot> getmonadic >>= \ a -> let { b = nonmonadic a} in return b
04:49:00 <Jafet> Oh, okay
04:49:02 <hpc> @src curry
04:49:03 <lambdabot> curry f x y = f (x, y)
04:49:45 <hpc> PietJanssen: you can also look at the source, but learning how to read types is worth the initial hassle
04:50:03 <PietJanssen> i already got the source opened but that didnt make more sense to me :)
04:50:11 <hpc> heh
04:50:22 <PietJanssen> prelude has zero comments :(
04:50:31 <PietJanssen> at least my version has nothing :p
04:50:34 <hpc> yeah, prelude is definitely not for human consumption
04:50:44 <Jafet> @where prelude
04:50:44 <lambdabot> http://www.haskell.org/onlinereport/standard-prelude.html
04:50:45 <pkrumins> @src uncurry
04:50:45 <lambdabot> uncurry f p = f (fst p) (snd p)
04:50:52 <pkrumins> @src fst
04:50:52 <lambdabot> fst (x,_) =  x
04:50:57 <pkrumins> @src snd
04:50:57 <lambdabot> snd (_,y) =  y
04:50:58 <hpc> pragmas and flags everywhere
04:51:12 <PietJanssen> i do understand that part sort of though
04:51:26 <hpc> :t uncurry
04:51:27 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
04:51:35 <PietJanssen> but i have troubles understanding how the resulkting type will be with like uncurry zip
04:51:43 <hpc> :t zip
04:51:44 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
04:51:48 <hpc> :t uncurry zip
04:51:48 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
04:51:56 <hpc> whoa, that's a neat trick
04:52:14 <hpc> :t curry unzip
04:52:15 <lambdabot>     Couldn't match expected type `(a, b)'
04:52:15 <lambdabot>            against inferred type `[(a1, b1)]'
04:52:15 <lambdabot>     In the first argument of `curry', namely `unzip'
04:52:20 <hpc> :t curry zip
04:52:21 <_mpu> flip is also tricky :)
04:52:21 <lambdabot>     Couldn't match expected type `(a, b)' against inferred type `[a1]'
04:52:21 <lambdabot>     In the first argument of `curry', namely `zip'
04:52:21 <lambdabot>     In the expression: curry zip
04:52:25 <_mpu> :t flip
04:52:25 <pkrumins> hpc how would you use tht trick?
04:52:25 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:52:27 <PietJanssen> i do understand the uncurry zip though how that works, but most of the others I dont :p
04:52:35 <pkrumins> oh i see
04:52:40 <pkrumins> uncurry zip == unzip??
04:52:44 <pkrumins> :t unzip
04:52:44 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
04:52:51 <pkrumins> :t uncurry zip
04:52:52 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
04:52:58 <pkrumins> hmm no
04:53:07 <hpc> uncurry zip is like flipping the constructors
04:53:07 <PietJanssen> no its the reverse of unzip
04:53:18 <pkrumins> :t zip
04:53:18 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
04:53:22 <pkrumins> :t uncurry unzip
04:53:22 <lambdabot>     Couldn't match expected type `b -> c'
04:53:23 <lambdabot>            against inferred type `([a], [b1])'
04:53:23 <lambdabot>     In the first argument of `uncurry', namely `unzip'
04:53:27 <hpc> :t unzip . uncurry zip
04:53:28 <lambdabot> forall a b. ([a], [b]) -> ([a], [b])
04:53:39 <pkrumins> id!
04:53:42 <pkrumins> :t id
04:53:43 <lambdabot> forall a. a -> a
04:55:29 <hpc> :t flip id
04:55:30 <lambdabot> forall a b. a -> (a -> b) -> b
04:56:01 <hpc> huh, no functor constraint
04:56:03 <hpc> :t flip
04:56:04 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:56:37 <_mpu> :t flip . curry
04:56:38 <lambdabot> forall a b a1. ((a1, a) -> b) -> a -> a1 -> b
04:57:14 <Eduard_Munteanu> Why would flip need a Functor constraint?
04:57:18 * hpc is very confused as to how flip id typechecks
04:57:24 <hpc> Eduard_Munteanu: caleskell
04:57:28 <Eduard_Munteanu> Oh.
04:58:15 <hpc> oh i see
04:58:22 <hpc> :t ($)
04:58:22 <lambdabot> forall a b. (a -> b) -> a -> b
04:58:24 <Jafet> flip id x y = (id y) x = y x = flip ($) x y
04:58:34 <hpc> it's taking that meaning for id
04:58:35 <_mpu> flip constrains id to have the type (a -> b) -> a -> b
04:58:41 <Eduard_Munteanu> What would the functor be? :/
04:58:46 <Eduard_Munteanu> (->) somehow?
04:58:48 <hpc> @src flip
04:58:48 <lambdabot> flip f x y = f y x
04:58:51 <Jafet> instance Functor ((->) t)
04:58:53 * hackagebot hylolib 1.3.1 - Tools for hybrid logics related programs  http://hackage.haskell.org/package/hylolib-1.3.1 (GuillaumeHoffmann)
04:59:01 <Eduard_Munteanu> Ah, it makes sense.
04:59:13 <hpc> Eduard_Munteanu: fmap = (.)
04:59:19 <Jafet> That Functor instance is like monads on steroids.
04:59:29 <Eduard_Munteanu> I suppose seeing a Category variant of that makes sense too.
04:59:40 <hpc> isn't there an applicative instance too?
04:59:44 <Eduard_Munteanu> (Category cat) => cat a b -> cat b a ?
04:59:50 <hpc> @instances Applicative
04:59:50 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
05:00:01 <hpc> @instances-importing Control.Applicative Applicative
05:00:02 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
05:00:03 <Jafet> @instances-importing Functor
05:00:03 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:00:14 <Jafet> Uh, which is which
05:00:28 * hpc looks this up
05:01:24 <Jafet> Monad generalizes to Functor, so the smaller list is for Applicative
05:02:17 <hpc> @src (->) (<*>)
05:02:17 <lambdabot> (<*>) f g x = f x (g x)
05:02:32 <hpc> @src (->) fmap
05:02:32 <lambdabot> fmap = (.)
05:02:43 <hpc> @src (.)
05:02:43 <lambdabot> (f . g) x = f (g x)
05:02:44 <lambdabot> NB: In lambdabot,  (.) = fmap
05:02:59 <hpc> huh
05:03:04 <hpc> sneaky
05:03:39 <hpc> @pl \f g x -> f x $ g x
05:03:40 <lambdabot> ap
05:03:45 <hpc> pah
05:04:23 <_mpu> :t ap
05:04:24 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:04:42 <Eduard_Munteanu> :t flip
05:04:43 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
05:05:03 <Eduard_Munteanu> :t liftM
05:05:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
05:05:32 <hpc> :t liftM `asTypeOf` flip
05:05:33 <lambdabot>     Occurs check: cannot construct the infinite type:
05:05:33 <lambdabot>       b = (a1 -> a1) -> b
05:05:33 <lambdabot>     Probable cause: `flip' is applied to too many arguments
05:05:43 <hpc> aw, that would have been neat
05:06:39 <Eduard_Munteanu> :t ap `asTypeOf` (flip . return)
05:06:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
05:06:40 <lambdabot>     Probable cause: `.' is applied to too many arguments
05:06:40 <lambdabot>     In the second argument of `asTypeOf', namely `(flip . return)'
05:06:51 <Eduard_Munteanu> grr
05:07:02 <Eduard_Munteanu> :t ap `asTypeOf` (liftM . return)
05:07:03 <lambdabot>     Occurs check: cannot construct the infinite type: b = m (a1 -> b)
05:07:03 <lambdabot>       Expected type: m b
05:07:03 <lambdabot>       Inferred type: m (m (a1 -> b))
05:07:43 <Eduard_Munteanu> That would've been weird.
05:08:11 <hpc> this is the part where we try and come up with as many differently worded typecheck errors as we can?
05:09:02 <Eduard_Munteanu> Yes, type checking is rich... at least in vocabulary.
05:09:43 <Eduard_Munteanu> @hoogle asTypeOf
05:09:43 <lambdabot> Prelude asTypeOf :: a -> a -> a
05:09:52 <hpc> asTypeOf = const
05:10:00 <hpc> it's a clever trick
05:10:01 <Eduard_Munteanu> Yeah.
05:10:10 <Eduard_Munteanu> Didn't think it was in Prelude.
05:10:22 <Eduard_Munteanu> :t seq
05:10:23 <lambdabot> forall a t. a -> t -> t
05:10:33 <Eduard_Munteanu> It's seq with same types right?
05:10:37 <Eduard_Munteanu> *some sort of
05:10:49 <Eduard_Munteanu> forcing type inference to behave a certain way.
05:11:04 <hpc> seq = const id, if you ignore strictness
05:11:19 <hpc> or flip const
05:11:30 <hpc> 1 `asTypeOf` 2
05:11:33 <hpc> > 1 `asTypeOf` 2
05:11:34 <lambdabot>   1
05:11:37 <hpc> > 1 `const` 2
05:11:38 <lambdabot>   1
05:11:41 <hpc> > 1 `seq` 2
05:11:42 <lambdabot>   2
05:11:48 <Eduard_Munteanu> 1 `asTypeOf` 2.0
05:11:52 <Eduard_Munteanu> > 1 `asTypeOf` 2.0
05:11:52 <lambdabot>   1.0
05:11:56 <Eduard_Munteanu> Got it.
05:12:13 <quicksilver> it mostly exists because h98 doesn't have scoped type variables
05:12:25 <quicksilver> however, it is sometimes a nicer way to write things than an annotation
05:12:29 <quicksilver> if the annotation is hideous.
05:12:40 <Eduard_Munteanu> quicksilver: yeah, I think it's the Haskell wiki article on that extension where I've met asTypeOf briefly.
05:13:14 <PietJanssen> hpc, ive been checking some further and now Im stuck again :(
05:13:15 <PietJanssen> we have
05:13:20 <PietJanssen> :t map
05:13:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:13:23 <PietJanssen> :t zipWith
05:13:24 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:13:24 <PietJanssen> and
05:13:28 <PietJanssen> :t map zipWith
05:13:29 <lambdabot> forall a b c. [a -> b -> c] -> [[a] -> [b] -> [c]]
05:13:43 <Eduard_Munteanu> PietJanssen: why stuck?
05:13:53 <PietJanssen> once again I dont see how that works :(
05:14:00 <PietJanssen> I must be horrible with this lol
05:14:02 <Eduard_Munteanu> Ah, the latter...
05:14:40 <hpc> PietJanssen: it seems what you are having trouble with is currying
05:14:48 <Eduard_Munteanu> PietJanssen: replace zipWith's type in the first arg of map
05:15:05 <hpc> a -> b -> c == a -> (b -> c)
05:15:29 <PietJanssen> yes
05:15:45 <Eduard_Munteanu> (rather -> associativity to be pedantic, it's not currying per se)
05:16:05 <hpc> so turn zipWith into a function from 'a' to 'b', and see what that a and b are
05:16:10 <hpc> then fill it into map's type
05:16:24 <PietJanssen> zipWith is the argument of map, so when you replace zipWiths type in the first arg of map you have to replace the (a -> b) with ?
05:16:50 <Eduard_Munteanu> Make an a -> b from a -> (b -> c)
05:17:10 <Eduard_Munteanu> Let's reword it...
05:17:18 <Eduard_Munteanu> Make an t -> u from a -> (b -> c)
05:17:21 <PietJanssen> sound like a good plan since I dont understand that :p
05:17:40 <Eduard_Munteanu> What's t and what's u in terms of a, b and c?
05:17:55 <PietJanssen> id say that t is a and u is (b->c)
05:18:00 <PietJanssen> but I probably got that wrong :p
05:18:04 <hpc> PietJanssen: do you know how haskell pattern matches yet?
05:18:05 <Eduard_Munteanu> It's fine.
05:18:21 <PietJanssen> i understand pattern maching, hpc 
05:18:36 <hpc> PietJanssen: for example, (x:xs); x is one thing, but xs can be more things
05:18:54 <PietJanssen> yeah, i understand that, or (x:_) etc 
05:19:00 <PietJanssen> thats not really a problem
05:19:06 <hpc> so the definition of (->) we will say is data (->) a b = fooblah
05:19:09 <PietJanssen> but I have hard troubles understanding how this works
05:19:28 <hpc> it looks a lot like a tuple, does it not?
05:19:37 <hpc> data (,) a b = (a, b)
05:19:40 <PietJanssen> yes it looks like tuples
05:19:45 <hpc> so what if b is another tuple?
05:20:02 <PietJanssen> youd have (a, (b, c))
05:20:06 <hpc> indeed
05:20:16 <hpc> now, the cool thing about (->) is you don't need the parenthesis
05:20:25 <hpc> so you could theoretically say a, b, c
05:20:34 <hpc> or a -> b -> c
05:20:50 <hpc> but it can still be a -> b
05:20:54 <hpc> for certain values of b
05:21:13 <hpc> making sense so far?
05:21:30 <PietJanssen> ehm 
05:21:41 <PietJanssen> last part not so much
05:21:43 <PietJanssen> last 4 lines or so :p
05:21:46 <hpc> heh
05:22:13 <hpc> > @let snd2 = \(a, b) -> b
05:22:14 <lambdabot>   <no location info>: parse error on input `@'
05:22:17 <hpc> @let snd2 = \(a, b) -> b
05:22:18 <lambdabot>  Defined.
05:22:28 <Eduard_Munteanu> ',' or '->' it doesn't matter, it's still a type constructor
05:22:31 <PietJanssen> i understand that 
05:22:36 <hpc> alright, so
05:22:41 <hpc> > snd2 (1, (2, 3))
05:22:42 <lambdabot>   (2,3)
05:22:46 <PietJanssen> yes
05:22:57 <hpc> if we pretend (,) = (->)
05:23:09 <hpc> snd2 (1 -> (2 -> 3)) = (2 -> 3)
05:23:39 <PietJanssen> aha I still understand it :)
05:23:42 <hpc> so let's look at the type of snd2
05:23:46 <hpc> :t snd2
05:23:47 <lambdabot> forall t t1. (t, t1) -> t1
05:23:51 <astroboy> how do I convert an Integer to an Int32
05:23:59 <hpc> oho! so we know t is 1
05:24:07 <hpc> so what's t1?
05:24:33 <Eduard_Munteanu> > fromIntegral (1293 :: Integer) :: Int32
05:24:33 <lambdabot>   1293
05:24:39 <Eduard_Munteanu> :t fromIntegral (1293 :: Integer) :: Int32
05:24:40 <lambdabot> Int32
05:25:02 <Eduard_Munteanu> (not sure it's the most elegant way though)
05:25:05 <PietJanssen> hpc: that t1 is?
05:25:06 <Eduard_Munteanu> astroboy: ^
05:25:16 <hpc> PietJanssen: t1 is (2, 3)
05:25:20 <astroboy> Eduard_Monteanu: thanks
05:25:43 <hpc> if we pattern match into (a, b), a is 1, and b is (2, 3)
05:26:01 <PietJanssen> ah with the sample of (1 -> (2 -> 3)) right?
05:26:18 <hpc> indeed
05:26:30 <PietJanssen> alright, I understand that
05:26:50 <PietJanssen> so the , can be read as a ->
05:26:51 <PietJanssen> ?
05:26:56 <hpc> yes
05:27:20 <PietJanssen> i see
05:27:30 <PietJanssen> but with the map zipWith then
05:27:32 <PietJanssen> you have
05:27:33 <PietJanssen> :t map
05:27:34 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
05:27:36 <PietJanssen> :t zipWith
05:27:37 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
05:27:40 <PietJanssen> and
05:27:42 <PietJanssen> :t map zipWith
05:27:43 <lambdabot> forall a b c. [a -> b -> c] -> [[a] -> [b] -> [c]]
05:27:55 <hpc> ignore map zipWith for now;
05:28:07 <hpc> well, ignore the answer lambdabot gives anyway
05:28:18 <PietJanssen> hehe
05:28:20 <hpc> so we are applying zipWith to map
05:28:32 <PietJanssen> yes
05:28:33 <hpc> so, we need to squeeze zipWith into (a -> b)
05:28:40 <PietJanssen> so the zipWith is the argument for the map function
05:28:51 <nostard> really annoying when you ask for help and your connection goes down ><
05:29:00 <hpc> so, let's put some parens and commas in the type of zipWith
05:29:29 <hpc> (a, b, c), ([a], [b], [c])
05:29:37 <hpc> so we have a pair
05:29:41 <hpc> of (a, b, c)
05:29:48 <hpc> and ([a], [b], [c])
05:29:52 <PietJanssen> yes I still understand that
05:30:05 <hpc> so we pattern match this
05:30:09 <hpc> (a, b)
05:30:17 <hpc> so a is the first part
05:30:20 <hpc> b is the second part
05:30:29 <hpc> a = (a, b, c)
05:30:38 <hpc> b = ([a], [b], [c])
05:30:54 <PietJanssen> i see
05:31:08 <hpc> now we fill in for the 'a' and 'b' in the rest of map
05:31:13 <hpc> ([a], [b])
05:31:37 <hpc> this i leave as an exercise
05:31:48 <PietJanssen> and you get the rest as that
05:31:52 <PietJanssen> I understand that part indeed
05:32:26 <PietJanssen> but hpc, why did you rewrite zipWith to (a, b, c) and ([a], [b], [c])
05:32:33 <PietJanssen> and not something else
05:32:46 <Eduard_Munteanu> PietJanssen: there are indeed multiple possibilities.
05:32:51 <PietJanssen> why the seperation at (a -> b -> c) vs the other part?
05:32:52 <Eduard_Munteanu> PietJanssen: but only one matches on a t -> u
05:33:23 <hpc> PietJanssen: the same reason that we can't turn ((a, b), c) into (a, (b, c))
05:33:38 <Eduard_Munteanu> PietJanssen: the rest would only fit t -> u -> v, or t -> u -> v -> w pattern matches
05:34:10 <Eduard_Munteanu> (t is always the same, a -> b -> c, or (a, b, c) like hpc says)
05:34:10 <PietJanssen> oh wait because you go from (a->b) to [a] -> [b]
05:34:15 <PietJanssen> you have to match the a and b
05:34:25 <hpc> PietJanssen: exactly
05:34:28 <PietJanssen> with the other output
05:34:31 <PietJanssen> oh I see
05:34:57 <PietJanssen> my book descriped this part in like 3-4 words so I had no clue how it worked lol
05:36:07 <PietJanssen> now it does make a lot more sense indeed
05:36:12 <PietJanssen> much appreciated
05:36:17 <hpc> so the next step is to figure out what a and b are, yes?
05:36:26 <hpc> then put them in the second part where they all belong
05:37:41 <PietJanssen> yeah youll get the [a -> b -> c] -> [[a] -> [b] -> [c]] part, because the a is (a, b, c) and b = [a], [b], [c], which is resulted to [a -> b -> c] -> [[a] -> [b] -> [c]]
05:37:52 <hpc> huzzah!
05:37:55 <osaunders> Is there any form of flip for types?
05:38:10 <Eduard_Munteanu> osaunders: type constructors, or how?
05:38:28 <hpc> Eduard_Munteanu: newtype F a b c = F (a c b)
05:38:45 <Eduard_Munteanu> osaunders: ^
05:38:46 <Eduard_Munteanu> :)
05:39:05 <osaunders> OK
05:39:06 <osaunders> Thanks
05:39:14 <hpc> so PietJanssen: you have learned yourself a type inference :D
05:39:25 <PietJanssen> nice :) 
05:39:31 <PietJanssen> you should write books hpc :p
05:39:35 <hpc> i should
05:39:41 <PietJanssen> you describe it 100 times better then the book I got here
05:39:41 <quicksilver> I'd buy one!
05:39:47 <Eduard_Munteanu> @let newtype F a b = F (b a)
05:39:47 <lambdabot>  Invalid declaration
05:40:18 <Eduard_Munteanu> @let newtype F a b c = F (a c b)
05:40:18 <lambdabot>  Invalid declaration
05:40:31 <hpc> i am rolling my own website atm; i think i will blog tutorials on it, perhaps
05:40:38 <Eduard_Munteanu> anyway, I was trying to look at its kind, but I already guess what it looks like.
05:41:07 <hpc> :k let newtype F a b = F (b a) in F
05:41:08 <lambdabot> parse error on input `let'
05:41:13 <hpc> D:
05:41:26 <hpc> that syntax for :k would be /awesome/
05:41:36 <Eduard_Munteanu> Yeah.
05:42:04 <osaunders> :l Int
05:42:08 <osaunders> :k Int
05:42:09 <lambdabot> *
05:42:22 <hpc> :k StateT
05:42:22 <lambdabot> * -> (* -> *) -> * -> *
05:42:33 <Eduard_Munteanu> I suppose it's * -> * -> (* -> *) ?
05:42:51 <hpc> Eduard_Munteanu: that's just * -> * -> * -> *
05:43:01 <hpc> yay for associativity :D
05:43:13 <Eduard_Munteanu> hpc: yeah though it makes more sense as some sort of a -> b -> (b -> a) at kind level
05:43:38 <Eduard_Munteanu> erm (a -> b) -> (b -> a)
05:44:22 <Eduard_Munteanu> Or am I saying something stupid here? :)
05:44:32 <hpc> heh, no
05:44:43 <hpc> your kind is correct
05:44:51 <hpc> the kind for mine would be uglier
05:45:03 <hpc> (* -> * -> *) -> * -> * -> *
05:45:23 <hpc> except it is more correct, i think
05:45:30 <Eduard_Munteanu> Yeah, that had 3 params.
05:45:34 <hpc> :t \f x y -> f y x
05:45:35 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> t -> t1 -> t2
05:46:18 <Eduard_Munteanu> hpc: apparently I had that thought too... "you can't reverse a function", but I don't think it allows that
05:46:58 <Eduard_Munteanu> So which is correct? :)
05:47:02 <hpc> mine :P
05:47:49 <Eduard_Munteanu> hpc: hm yes it's truly a flip.
05:47:51 <hpc> because F (->) a b <=> b -> a
05:48:16 <hpc> or something
05:49:06 <hpc> F (,) a b <=> (b, a) -- this is a bit easier to grok
05:49:09 <hpc> yay tuples
05:49:23 <Eduard_Munteanu> My F a (-> b) <=> (-> b) a, though it's not a flip
05:49:31 <Eduard_Munteanu> So I guess you're right.
05:49:46 <Eduard_Munteanu> even if it can be used as such
05:50:00 <hpc> yours /looks/ like a flip
05:50:22 <hpc> actually, yours is probably more like flip id
05:50:35 <aristid> :t flip id
05:50:35 <lambdabot> forall a b. a -> (a -> b) -> b
05:50:57 <hpc> only with more params, or something
05:52:03 * Eduard_Munteanu wonders if we could get some kind-safety and write (*_a -> *_b) -> (*_b -> *_a) :P
05:52:21 <Eduard_Munteanu> I think Agda has some hierachy like that.
05:52:27 <hpc> haha
05:52:31 <Eduard_Munteanu> infinite IIRC.
05:52:45 <hpc> yeah, the tower of type has to stop somewhere
05:52:55 <hpc> otherwise you have to worry about sortedness of kinds, etc
05:53:18 <Eduard_Munteanu> hpc: yeah, I don't mean infinite types, just arbitrarily high.
05:53:29 <Saizan> the plan is to add datakinds to GHC haskell
05:53:36 <hpc> oh god
05:53:40 <Saizan> but to avoid the tower by using * :: *
05:53:48 <hpc> huh
05:54:43 <Saizan> the idea is that haskell is inconsistent anyway
05:54:50 <aristid> Saizan: datakinds? what is that?
05:55:03 <hpc> heh, it is a bit inconsistent
05:55:19 * hpc would prefer a simpler, more consistent type system
05:55:28 * hpc doubts it is possible though
05:55:30 <Saizan> aristid: e.g. have a Nat kind, and have Z and S types of kind Z :: Nat; S :: Nat -> Nat
05:56:01 <Eduard_Munteanu> hpc: are you referring to something in particular that makes it inconsistent?
05:56:04 <Saizan> in fact, the idea is to let you automatically lift ADTs to the type level
05:56:42 <aristid> Saizan: hmm, i would want a built-in nat kind :)
05:57:07 <Saizan> i think they'd also add numeric literals at that point, at least
05:57:08 <aristid> seen a talk by mark jones about Habit and they have that
05:57:21 <aristid> they also have more crazy kinds
05:57:34 <aristid> area <- a kind for memory layouts. wtf :)
05:57:36 <hpc> Habit is neat; i will use it, probably
05:57:46 <aristid> hpc: is it released somewhere?
05:57:50 <hpc> not yet
05:58:19 <hpc> the lack of bottom could make it a better theory language than haskell
05:58:28 <hpc> perhaps
05:58:30 <Eduard_Munteanu> I sure hope Haskell gets closer to Agda, though I suppose any heavy usage of such features would quickly alienate users.
05:58:36 <aristid> hpc: the lack of laziness probably makes it harder to use
05:58:47 <hpc> oh right, it is strict :(
05:59:00 <aristid> Eduard_Munteanu: but the nat kind would be pure awesome.
05:59:51 <Eduard_Munteanu> aristid: are you envisioning some sort of dependent types, i.e. functors (?) Nat -> * ?
06:00:09 <aristid> Eduard_Munteanu: no
06:00:22 <aristid> Eduard_Munteanu: pure type-level would be good enough :)
06:00:51 <hpc> eeeew: http://hpaste.org/41279/eeeew
06:01:06 <hpc> from QuickCheck
06:01:20 <Eduard_Munteanu> Yeah, though "Good luck explaining monads" would quickly turn into "good luck explaining kinds to newbies"
06:01:28 <hpc> lol
06:01:29 <Eduard_Munteanu> :)
06:01:49 * hpc endorses making the simple stuff consistent
06:01:59 <hpc> for example, make tuples native haskell
06:02:03 <Eduard_Munteanu> Types of types is too "matrix" for them.
06:02:05 <hpc> they /can be made native/
06:02:15 <hpc> but they are currently a compiler hack
06:02:37 <Eduard_Munteanu> Type-dependent tuples :)
06:02:38 <hpc> also, we will get awesome stuff for free
06:02:47 <hpc> like we only need one tuple definition
06:02:47 <Eduard_Munteanu> *dependent-type
06:02:55 <hpc> then we can say a, b, c
06:02:58 <hpc> and it will associate
06:03:26 <aristid> hpc: hmm, getting more crazy we might want a nat sort
06:03:58 <Eduard_Munteanu> Are sorts to kinds like kinds to types, or something of that sort?
06:04:26 <hpc> Eduard_Munteanu: yes
06:04:41 <hpc> value -> type -> kind -> sort -> who the hell knows
06:04:54 <Eduard_Munteanu> I see.
06:05:02 <aristid> i broke reddit :(
06:05:34 <quicksilver> aristid++ # excellent work.
06:05:35 <astroboy> How do I get a value out of a monad?
06:05:43 <quicksilver> depends on the monad.
06:05:50 <quicksilver> quite often, you don't.
06:06:28 <Eduard_Munteanu> If kind functions are functors, then sort functions work on Cat?
06:06:30 <aristid> @quote IO.String
06:06:30 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
06:06:46 <hpc> XD
06:06:52 <astroboy> Example: I am using the state monad and it works really well
06:07:01 <astroboy> but at the end I want to return the final value
06:07:05 <Zao> What part of the sciences is the co- in codata, comonad, etc from?
06:07:09 <Zao> CT?
06:07:10 <astroboy> to use it in non monadic functions
06:07:20 <quicksilver> astroboy: use 'runState' or 'evalState' or 'execState'
06:07:23 <Saizan> Zao: yep
06:07:34 <Eduard_Munteanu> Zao: monad is from CT, so comonads are still from CT :)
06:07:39 <quicksilver> to "run" your state monad action with an initial state, and collect the final state and/or return value.
06:07:40 <astroboy> quicksilver: thanks a lot
06:07:53 <quicksilver> Zao, Saizan : I think it's older than that
06:08:10 <quicksilver> I think it was used in abstract algebra + algebraic geometry
06:08:15 <quicksilver> (cochain complexes)
06:08:18 <Saizan> Zao: co- roughly means "the same thing in the opposite category"
06:08:21 <quicksilver> ...which, roughly, is where CT came from.
06:08:33 <Eduard_Munteanu> Um, that should be functors Cat -> Cat.
06:08:49 <geheimdienst> Cat -> Lolcat
06:08:58 <Eduard_Munteanu> :)
06:09:21 <Eduard_Munteanu> Yeah, way too much CaTheory for me...
06:10:47 <Eduard_Munteanu> Coinduction probably doesn't come from CT, and neither codata I suppose.
06:11:15 <Eduard_Munteanu> I don't really know what the latter is, but I suppose it's related to coinduction.
06:13:16 <Saizan> it fits very well the meaning of co- from CT though
06:14:52 <Zao> What about coprime?
06:15:10 <byorgey> those are just primes with the arrows reversed, of course
06:15:19 <Eduard_Munteanu> :)
06:15:26 <quicksilver> that's a different sense of 'co-'
06:15:34 <quicksilver> it means 'mutually'
06:15:38 <quicksilver> as in 'cohabiting'
06:15:44 <quicksilver> or 'cooperating'
06:16:12 <lars9> what should i learn after LYAH? monad transformer step by step good?
06:16:31 <quicksilver> coinduction, I believe, arises in the study of LFP and GFP models of languages, chain theory and posets etc.
06:16:32 <Zao> cow-orker
06:16:48 <quicksilver> that whole area is defintely 'post-CT' and very much CT influenced.
06:17:29 <Eduard_Munteanu> AFAICT coinduction is something that makes sense when studying total languages, or that's what I gathered.
06:17:31 <dblhelix> Eduard_Munteanu: categorically, codatatypes are terminal coalgebras; so, in that sense, codata does "come from CT"
06:17:46 <Nibble> If I am in a IO Monad, and want the function to evaluate to a string
06:17:48 <Eduard_Munteanu> Ah, nice to know.
06:18:03 <Nibble> I would just add -> String and a return varname?
06:18:08 <Eduard_Munteanu> Nibble: no
06:18:10 <Eduard_Munteanu> Nibble: you can't
06:18:28 <Eduard_Munteanu> Nibble: if you're in IO, you stay in IO.
06:18:43 <Eduard_Munteanu> Nibble: the only way such a function can return a string, is being something -> IO String
06:18:55 <Nibble> :/
06:19:02 <Eduard_Munteanu> which you can bind with '<-' in the caller
06:19:13 <Nibble> oh right
06:19:16 <Nibble> that is what I wanted
06:19:17 <Nibble> thanks
06:19:38 <Eduard_Munteanu> for example: a <- getSomeString; doSomethingWithString a
06:19:44 <Eduard_Munteanu> where getSomeString :: IO String
06:20:02 <Eduard_Munteanu> there you can use return on a real String.
06:20:31 <lars9> what is coinduction? google dict doesnt know it
06:21:05 <quicksilver> fairly hard to explain without quite a lot of background material.
06:21:07 <Eduard_Munteanu> It goes the other way around than induction, it only makes a difference in total languages.
06:21:32 <Eduard_Munteanu> I can't say it much better than this, perhaps you could look on Wikipedia, or in some Coq tutorials/info
06:21:51 <quicksilver> I disagree with the link to total languages.
06:22:08 <quicksilver> Adding coinductive support to total languages is a way to increase their expressitivity.
06:22:09 <lars9> i want to be practical, to use it in daily tasks :D
06:22:24 <quicksilver> in a sense, you are using it whenever you use an infinite list in haskell
06:22:27 <quicksilver> (or similar structure)
06:22:27 <Eduard_Munteanu> quicksilver: I mean it basically reduces to induction in non-total languages
06:22:34 <quicksilver> Eduard_Munteanu: it doesn't.
06:22:40 <quicksilver> it's a totally different logical notion.
06:22:41 <Eduard_Munteanu> lars9: it makes little sense in Haskell AFAICT.
06:22:55 <dblhelix> the tricky thing ins that, in Haskell, data and codata coincide
06:22:58 <Eduard_Munteanu> quicksilver: ok, does it make any sense in Haskell?
06:23:12 <quicksilver> Eduard_Munteanu: haskell is a programming language; coinduction is a logical technique.
06:23:13 <Eduard_Munteanu> I mean like dblhelix says.
06:23:13 <lars9> Eduard_Munteanu: i mean im trying to make haskell used in my daily life
06:23:27 <quicksilver> Eduard_Munteanu: you are asking if apples make any sense in car engines.
06:23:45 <ray> aren't there languages where data and codata have different types
06:23:57 <byorgey> lars9: in that case you might be interested in reading Real World Haskell
06:23:59 <byorgey> @where rwh
06:24:00 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
06:24:04 <Eduard_Munteanu> quicksilver: yeah, I'm aware it's probably wrong from a theoretic point of view, perhaps I've been too pragmatic wrt Haskell
06:24:06 <ray> or is that just an idea someone kicked around
06:24:13 <quicksilver> we can understand inductive definitions as being well-formed definitions in a model which is well-founded, or has least fixed points.
06:24:14 <hpc> rwh is pretty good at introducing useful things
06:24:19 <dblhelix> ray: Agda makes such a distinction
06:24:27 <byorgey> you can even read it online for free
06:24:38 <hpc> it doesn't go into detail on certain (ahem database) topics though
06:24:44 <quicksilver> conversely (co-versely?) you can give coinductive definitions and such things make sense if your models are guaranteed to have greatest fixed points.
06:24:51 <ray> ah thanks
06:24:52 <lars9> byorgey: i've read that, but it's every general and now i use RWH as a example set
06:25:28 <byorgey> lars9: oh, ok. so you've read LYAH and (parts of) RWH?
06:25:29 <Eduard_Munteanu> quicksilver: doesn't haskell do, if you measure that by definedness?
06:25:52 <quicksilver> haskell's data types are, in effect, read co-inductively.
06:25:56 <lars9> byorgey: yeah, and used haskell in small programs
06:26:12 <quicksilver> if you read the definition of the list type as an inductive definition, there would be no infinite lists.
06:26:22 <Eduard_Munteanu> quicksilver: I figure _|_ doesn't count as a least fixed point right?
06:26:27 <lars9> byorgey: what i want to do know is to make my haskell code more haskelly, now they read like C
06:26:30 <byorgey> lars9: probably the best way to learn more at this point is to try it in bigger programs. =)
06:26:30 <quicksilver> it does count as a least fixed point, yes.
06:26:47 <quicksilver> the purpose of _|_ is, from one perspective, to serve as a least fixed point.
06:27:01 <quicksilver> so that all (appropriately continuous) functions have least fixed points.
06:27:10 <Eduard_Munteanu> quicksilver: so we've got both least and greatest fixed points, but the least is a bit meaningless?
06:27:21 <ray> bottom is the least element in the partial ordering on values used to define terms like "least fixed point"
06:27:26 <quicksilver> I don't think it's meaningless.
06:27:36 <ray> it's meaningful enough
06:27:45 <quicksilver> but for data types, haskell doesn't give you access to the least.
06:27:51 <Eduard_Munteanu> ray: yes, I understand that.
06:27:51 <byorgey> lars9: ah.  then maybe you would be interested in reading some functional pearls, and perhaps the Typeclassopedia
06:27:57 <quicksilver> data List a = Nil | Cons a (List a)
06:28:03 <quicksilver> the l.f.p. of this is all finite lists.
06:28:14 <quicksilver> but haskell has no type which is all finite lists.
06:28:21 <byorgey> lars9: try to read as much beautiful Haskell code as you can.
06:28:38 <quicksilver> however, haskell still uses the l.f.p defintion of recursive functions.
06:28:42 <EvanR-work> data [a] = [] | a:[a]
06:28:45 <ray> mix beautiful and practical in about a 2:1 ratio
06:28:46 <EvanR-work> @src []
06:28:46 <lambdabot> data [] a = [] | a : [a]
06:28:50 <byorgey> lars9: another good way to learn is to take small pieces of code that you think can probably be made more beautiful and ask about them in here
06:28:53 <EvanR-work> \o/
06:29:09 <ray> not that beautiful excludes practical
06:29:11 <byorgey> lars9: people are usually quite helpful regarding suggestions for improving the style of your code
06:29:45 <EvanR-work> ray: mix beautiful and practical in a phi:1 ratio
06:29:52 <EvanR-work> or 1:phi as the case may be
06:29:55 <Eduard_Munteanu> quicksilver: hm, I thought the l.f.p of just about anything in Haskell was _|_
06:30:17 <Eduard_Munteanu> After all, it's the least defined.
06:30:25 <lars9> byorgey: thanks for these good suggestions, all are useful
06:30:30 <sipa> (gadt) constructor names can contain numbers, right?
06:30:31 <byorgey> Eduard_Munteanu: but it isn't necessarily a fixed point
06:30:32 <Eduard_Munteanu> and f _|_ = _|_ forall x
06:30:37 <ray> remember, haskell is nonstrict
06:30:41 <Eduard_Munteanu> (forall _|_
06:30:42 <quicksilver> Eduard_Munteanu: not-so.
06:30:49 <quicksilver> Eduard_Munteanu: let f === (1:)
06:30:55 <Eduard_Munteanu> blah, I'm tired :), forall f :))
06:31:04 <ray> and what nonstrict basically means is that that is not true
06:31:04 <quicksilver> Eduard_Munteanu: (1:_|_) =/= _|_
06:31:14 <quicksilver> and, indeed, fix (1:) is not _|_
06:31:20 <quicksilver> > fix (1:)
06:31:21 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:31:32 <Jafet> > let f = const undefined in f 42
06:31:33 <lambdabot>   *Exception: Prelude.undefined
06:31:36 <Eduard_Munteanu> quicksilver: hm, mixing that with what ray says, it makes sense.
06:31:40 <Eduard_Munteanu> Thanks.
06:31:41 <Jafet> > let f = (`const` undefined) in f 42
06:31:42 <lambdabot>   42
06:31:46 <quicksilver> no problem.
06:32:02 <quicksilver> even strict languages have non-_|_ fixed points
06:32:30 <aristid> quicksilver: but fix needs to be defined differently in them?
06:32:41 <turiya> can anyone tell me how to compile a simple ffi code? the code is here : http://hpaste.org/41283/testffih,  http://hpaste.org/41284/testffic, http://hpaste.org/41285/testffihs
06:32:42 <aristid> @src fix
06:32:42 <lambdabot> fix f = let x = f x in x
06:32:44 <Eduard_Munteanu> Call by value languages define it differently.
06:32:47 <Eduard_Munteanu> At least according to TAPL.
06:33:01 <EvanR-work> i tried defining fix in javascript, worked fine. unless you use it for something
06:33:04 <EvanR-work> 'too much recursion'
06:33:11 <aristid> lol
06:33:16 <EvanR-work> must be strict evaluation
06:33:21 <ray> you're thinking of Y probably
06:33:21 <quicksilver> aristid: strict languages typically permit these non-_|_ f.p.s in function types only
06:33:22 <Jafet> @vixen how much recursion can you take?
06:33:22 <lambdabot> i sure can
06:33:31 <aristid> EvanR-work: and you tell me you don't want to implement pointless experiments like git-finance :P
06:33:34 <Eduard_Munteanu> Although I'm not sure call by value equates strict.
06:33:44 <quicksilver> aristid: so you can use essentially the same definition if you force 'x' to be a function.
06:33:48 <ray> @vixen can i find your least fixed point?
06:33:48 <lambdabot> you sure can
06:33:50 <quicksilver> you might have to write it slightly differently.
06:33:50 <aristid> quicksilver: hmm.
06:34:03 <lars9> oh yeah, new chrome can act as pdf reader. it can replace the awkward xpdf now
06:34:04 <quicksilver> q.v. SML forbids "value-recursion"
06:34:10 <quicksilver> but permits "function recursion"
06:34:21 <quicksilver> this is the manifestation of fix only working for function types.
06:34:24 <Eduard_Munteanu> lars9: xpdf? Use something like evince
06:34:30 <aristid> value recursion is probably one of the neat things that laziness buys you
06:34:37 <quicksilver> yes.
06:34:54 <quicksilver> in fact, it's probably everything, in a sense.
06:35:00 * Eduard_Munteanu wishes TAPL was written wrt lazy semantics
06:35:05 <Eduard_Munteanu> rather than call by value.
06:35:05 <quicksilver> value recursion is equivalent to nonstrict values.
06:35:26 <quicksilver> (laziness itself is a further requirement about sharing, normally)
06:36:10 <quicksilver> you can do value recursion in ML by making everything a function "\() -> "
06:36:12 <aristid> quicksilver: hmm, is endless recursion a way to encode _|_ for strict languages in function types?
06:36:15 <lars9> Eduard_Munteanu: all basing on libpurple, no big difference
06:36:19 <quicksilver> aristid: yes.
06:36:27 <aristid> quicksilver: well with \() -> you lose the memoization
06:36:34 <quicksilver> it's a real pain to do that, of course, but you can do it.
06:36:40 <quicksilver> aristid: yes. nonstrict but not lazy :)
06:36:47 <Jafet> lars9: libpurple is an internet chat library, libpoppler is a pdf library
06:37:11 <Eduard_Munteanu> :)
06:37:13 <lars9> Jafet: lol, got me
06:37:20 <Jafet> PDFs suck.
06:37:28 <quicksilver> I wonder what chrome's PDF renderer is, codewise
06:37:29 <Eduard_Munteanu> PSs rule?
06:37:30 <lars9> Jafet: better than word
06:37:32 <edon> i have types t1, t2, i want to make another type u which can have values from any of the types t1 and t2, can this be done without introducing new type constructors for u (data U = Ut1 t1 | Ut2 t2)? I'm ending up with too many wrappers
06:37:43 <Philippa> Eduard_Munteanu: it's understandable, CBV is still what's applicable to most programming languages. That said, if what you're interested in is type systems it doesn't matter much anyway
06:37:48 <roconnor> edon: Either t1 t2
06:37:59 <Jafet> At least word has some concept of a document, rather than a printed page
06:38:21 <Eduard_Munteanu> Philippa: yeah I guess it isn't that much of a difference.
06:38:23 <ray> pdfs are what i compile my latex into
06:38:44 <aristid> roconnor: with sort-level nats, you can introduce Variant 3 t1 t2 t3 :D
06:38:52 <lars9> Jafet: oh god, i hate word
06:39:26 <aristid> oh word, i hate god
06:39:26 <edon> roconnor: i wrote only two types for brevity, and that wraps them too (Left, Right)
06:39:32 <Eduard_Munteanu> .tex do have that concept too
06:39:52 <sipa> you're comparing an editable document format with a vector image format, not word with pdf
06:40:02 <Jafet> Call by value and call by name are merely evaluation strategies. With mutation, you can implement call by name with call by value -- (defun (delay x) (nil . (lambda () x))) (defun (force x) (setcdr x (x)) x) (or something along those lines)
06:40:34 <Eduard_Munteanu> I see.
06:40:36 <Eduard_Munteanu> Lithp?
06:40:40 <Eduard_Munteanu> :)
06:40:57 <roconnor> aristid: I'm lazy: Either t1 (Either t2 (Either t3 Void))
06:40:58 <ray> hey remember when you could expect MIT second-years to know that
06:40:59 <Jafet> Pthunky Parenth
06:41:00 <ray> :)
06:41:17 <Nibble> Where is Stewart?
06:41:18 <lars9> the language used in "Why functional programming matters" is so similar to haskell
06:41:27 <lars9> named miranda or something like it
06:41:38 <ray> name rings a bell
06:41:42 <EvanR-work> also in implementation of functional programming languages
06:41:53 <Jafet> ray: so where does one look now, seniors?
06:41:54 <pumpkin> a true mathematician: http://www.youtube.com/watch?v=sYqXlRQrBN4#t=1m27s
06:41:56 <ray> it might be ML-descended or something
06:42:00 <Eduard_Munteanu> Nibble: dons?
06:42:06 <EvanR-work> at the time miranda was the big thing
06:42:12 <EvanR-work> haskell supplanted it
06:42:19 <aristid> roconnor: you don't get nice constructors that way
06:42:32 <ray> jafet: people who care enough to watch the free sicp lectures and read the free book
06:43:26 <roconnor> aristid: why you hating Right . Right . Right . Left foo?
06:43:30 <roconnor> looks like a peano number to me
06:43:57 <aristid> roconnor: maybe because i don't like peano numbers without a usability wrapper? :D
06:44:02 <quicksilver> roconnor: I use a preprocessor so I can write that as <+++-$foo
06:44:10 <quicksilver> roconnor: makes all my code look like brainfuck.
06:44:19 <Eduard_Munteanu> How do you read that? Sorta like Piano but more like Pee-ah-no?
06:44:30 <EvanR-work> moe nads
06:44:32 <roconnor> Eduard_Munteanu: I read it the same way as I read Piano
06:44:41 <Eduard_Munteanu> I see.
06:44:43 <quicksilver> I say 'Peano' the way some people (americans, posh english people) read 'piano'
06:44:54 <quicksilver> (not the way I personally read piano, though)
06:45:07 <quicksilver> pee-ARR-no vs. pee-ann-o
06:45:10 <aristid> Peeno :D
06:45:16 <EvanR-work> beano
06:45:37 <aristid> EvanR-work: haha sounds like something a lambdacat would say
06:45:39 <Eduard_Munteanu> Hm, considering he's Giuseppe Peano (?), I could read it like in my native language, I guess Peh-ah-no
06:45:41 <ray> i pronounce it peano
06:45:56 <ketil> To me there's a distinction, I'd use an 'e' as in 'bet', vs an 'i' as 'pea'.  But I'm not a native English speaker. :-)
06:46:12 <aristid> Eduard_Munteanu: is your language pronounced similarly to italian?
06:46:16 <EvanR-work> Eduard_Munteanu: as far as i know thats the right one and the most popular
06:46:18 <Eduard_Munteanu> aristid: yes
06:46:34 <EvanR-work> pe a no
06:46:47 <Eduard_Munteanu> Yeah, just like it's writen.
06:46:50 <Eduard_Munteanu> *written
06:46:51 <EvanR-work> lol
06:47:04 <aristid> Pe a no number <- the two words don't fit together
06:47:17 <Eduard_Munteanu> EvanR-work: english does have context-sensitive pronounciation for letters, we don't :)
06:47:18 <EvanR-work> web 2.0 it -> pe a number
06:47:25 * hackagebot amqp 0.2.4 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.4 (HolgerReinhardt)
06:47:57 <Eduard_Munteanu> e is the same everywhere
06:47:58 <EvanR-work> Eduard_Munteanu: yes 'said just like its written' is a joke in enlish
06:48:00 <EvanR-work> g
06:48:11 <Eduard_Munteanu> Oh :)
06:48:14 <PietJanssen> yey again for me getting stuck again :p \o/
06:48:15 <Ke> c.h.o still down
06:48:18 <PietJanssen> :t uncurry id
06:48:19 <lambdabot> forall b c. (b -> c, b) -> c
06:48:58 <PietJanssen> :t curry
06:48:59 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:49:01 <PietJanssen> :t id
06:49:02 <lambdabot> forall a. a -> a
06:49:04 <PietJanssen> eh
06:49:04 <aristid> hmm, the Exception system feels pretty type-unsafe :(
06:49:08 <PietJanssen> :t uncurry
06:49:09 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:49:10 <PietJanssen> :t id
06:49:11 <lambdabot> forall a. a -> a
06:49:22 <PietJanssen> the input for uncurry is (a -> b -> c)
06:49:33 <PietJanssen> so id should match the (a -> b -> c)
06:49:38 <PietJanssen> but how come
06:49:40 <_mpu> it does
06:49:47 <PietJanssen> :t uncurry id
06:49:47 <EvanR-work> a = b -> c
06:49:48 <lambdabot> forall b c. (b -> c, b) -> c
06:50:03 <PietJanssen> match (a -> b, a) -> c
06:50:08 <quicksilver> PietJanssen: important to understand that (a -> b -> c) is, actually, (a) -> (b -> c)
06:50:28 <quicksilver> PietJanssen: so if you want (a) -> (b -> c) to match the type of id which is (x) -> (x)
06:50:39 <quicksilver> PietJanssen: then you have to decide x = a and x = b -> c
06:50:46 <Eduard_Munteanu> I'm puzzled that even typechecks... :/
06:51:12 <PietJanssen> but if (a -> b -> c) matches (a) -> (b -> c)
06:51:17 <EvanR-work> Eduard_Munteanu implementing a type checker sounds insane for this reason ;)
06:51:31 <PietJanssen> then I still wonder how that result is
06:52:17 <PietJanssen> :t uncurry id
06:52:18 <lambdabot> forall b c. (b -> c, b) -> c
06:52:18 <roconnor> aristid: how would you write members of  Variant 3 t1 t2 t3?
06:52:21 <PietJanssen> same appkies sort of to
06:52:23 <PietJanssen> :t curry id
06:52:24 <lambdabot> forall a b. a -> b -> (a, b)
06:52:25 <PietJanssen> though
06:52:28 <Eduard_Munteanu> > (uncurry id) (id, 5)
06:52:29 <lambdabot>   5
06:52:30 <PietJanssen> shounds weird to me
06:52:45 <PietJanssen> sounds weird
06:52:45 <PietJanssen> xD
06:53:07 <aristid> roconnor: hmm, ok, i haven't really fully thought that out
06:53:11 <Eduard_Munteanu> > (uncurry id) ((+1), 5)
06:53:12 <lambdabot>   6
06:53:13 <EvanR-work> PietJanssen: b -> c is the left input
06:53:29 <PietJanssen> for which one?
06:53:35 <PietJanssen> :t uncurry
06:53:36 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:53:37 <aristid> :t uncurry id .: curry id
06:53:38 <lambdabot> forall c b. (b -> c) -> b -> c
06:53:44 <EvanR-work> PietJanssen: the 'a'
06:54:11 <PietJanssen> hm?
06:54:18 <PietJanssen> id is a -> a
06:54:21 <EvanR-work> yes
06:54:31 <EvanR-work> so a = b->c
06:54:31 <PietJanssen> so the input of id is (b->c) -> (b-c)?
06:54:37 <PietJanssen> why is that?
06:54:51 <EvanR-work> a -> a    given  (a -> b -> c)
06:54:53 <Eduard_Munteanu> Oh, it makes sens.e
06:54:59 <sipa> > id (+)
06:55:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a -> a)
06:55:00 <lambdabot>    arising from a use...
06:55:06 <Eduard_Munteanu> I was looking it a bit the other way around.
06:55:20 <Eduard_Munteanu>  :t uncurry
06:55:25 <roconnor> @type id (+)
06:55:26 <lambdabot> forall a. (Num a) => a -> a -> a
06:55:30 <PietJanssen> but why is a = b -> c?
06:55:48 <Eduard_Munteanu> forall t u v. (t -> u -> v) -> (t, u) -> v
06:55:49 <roconnor> > succ . succ . pred `id` 17
06:55:50 <lambdabot>   Precedence parsing error
06:55:50 <lambdabot>      cannot mix `L..' [infixr 9] and `GHC.Base.id'...
06:55:53 <sipa> PietJanssen: it can be - it does not need to be
06:55:56 <roconnor> damn
06:55:59 <PietJanssen> the input for uncurry is (a -> b -> c)
06:56:02 <Eduard_Munteanu> Now you can't mix em up...
06:56:05 <EvanR-work> since b->c is on the right hand side of the first arg to uncurry
06:56:14 <PietJanssen> so doesnt that mean that id should return the (a -> b -> c)?
06:56:18 <roconnor> > map (`id` 17) [succ, pred]
06:56:18 <lambdabot>   [18,16]
06:56:24 <Eduard_Munteanu> t = a, u -> v = b
06:56:40 <roconnor> > succ `id` 17
06:56:41 <lambdabot>   18
06:56:42 <Eduard_Munteanu> t = a, u -> v = a
06:57:51 <PietJanssen> EvanR-work: if thats on the right side, what should be applied to the left side?
06:58:19 <EvanR-work> applied to the left side?
06:59:26 <PietJanssen> i dont see how you can go from uncurry id to (a->b, a) -> b, that would require c to be 'b' and a to be 'a->b' and b to be 'a' I think?
06:59:40 <EvanR-work> how about writing id as
06:59:42 <EvanR-work> t -> t
06:59:44 <EvanR-work> and uncurry as
06:59:52 <EvanR-work> (a -> b -> c) -> (a,b) -> c
07:00:03 <EvanR-work> then calculate the type of uncurry id
07:00:04 <PietJanssen> yes thats how I write them too
07:00:46 <EvanR-work> (a -> b -> c) -> (a,b) -> c applied to t -> t
07:01:02 <PietJanssen> yes
07:01:14 <PietJanssen> so that would require t to be (a -> b -> c) i think?
07:01:18 <EvanR-work> so what is a and b in terms of t
07:01:30 <EvanR-work> no t -> t is (a -> b -> c)
07:01:58 <EvanR-work> a -> (b -> c)
07:01:58 <Eduard_Munteanu> You should ask what is a, b, c in terms of t and u, not the other way around.
07:02:03 <EvanR-work> whats u
07:02:04 <Eduard_Munteanu> I already did that mistake :)
07:02:23 <EvanR-work> ah, c -> u
07:02:32 <EvanR-work> oops i didnt mean ->
07:02:32 <PietJanssen> so id is a ->  ( b -> c) ?
07:02:33 <EvanR-work> lol
07:02:46 <EvanR-work> PietJanssen: i just rewrite the a -> b -> c
07:02:56 <EvanR-work> nothing changes except maybe you see how it matches t -> t
07:03:11 <EvanR-work> t = a, t = b->c
07:03:22 <PietJanssen> thats the part I dont get really, getting from a t to a -> b -> c
07:03:33 <EvanR-work> what?
07:03:46 <ray> (b -> c) -> (b -> c)
07:03:48 <Eduard_Munteanu> (note that equality thingy is not symmetric)
07:03:50 <PietJanssen> especially since you have to match the values on the otherside too to get the (a -> b,a) -> b out of it
07:04:02 <Eduard_Munteanu> (it's more of a "is bound by")
07:05:26 <ray> you can remove parens on the right to get (b -> c) -> b -> c
07:05:30 <EvanR-work> Eduard_Munteanu: i was saying, 'can be replaced with'
07:05:34 <PietJanssen> I have really no idea lol
07:05:44 <PietJanssen> t has to match in for a -> b -> c
07:05:58 <Cheery> are there haskell implementations in other languages?
07:06:09 <EvanR-work> PietJanssen: no
07:06:16 <PietJanssen> not?
07:06:19 <ray> and that type can unify
07:06:24 <ray> :t uncurry
07:06:25 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:06:26 <Eduard_Munteanu> PietJanssen: imagine 'id' get some concrete types, what types does uncurry get given that situation?
07:06:50 <PietJanssen> the resulting type of id?
07:07:01 <byorgey> Cheery: you mean Haskell compilers written in languages other than Haskell?  Not that I am aware of.
07:07:30 <Liskni_si> byorgey: wasn't hugs written in something else?
07:07:34 <Eduard_Munteanu> PietJanssen: make id concrete, let uncurry be polymorphic
07:07:34 <EvanR-work> PietJanssen: do you agree that a = t, and b -> c = t ?
07:07:46 <byorgey> Liskni_si: was it?  I don't know
07:08:04 <ray> therefore uncurry id :: ((b -> c), b) -> c
07:08:05 <EvanR-work> then after application you remove the left of -> in uncurry and get
07:08:05 <PietJanssen> EvanR-work: I dont understand how you get those values
07:08:16 <EvanR-work> (a, b) -> c
07:08:24 <EvanR-work> (t, b) -> c
07:08:29 <EvanR-work> (b -> c, b) -> c
07:08:32 * Eduard_Munteanu has to go, bye...
07:08:47 <PietJanssen> is it because you always choose the first variable as before
07:08:57 <PietJanssen> and the latter variables as the rest, the latter 't' ?
07:09:15 <ray> 't' can be a function type
07:09:19 <arcatan> meh, why trac.haskell.org doesn't work
07:09:22 <ray> it can be any type
07:09:31 <byorgey> Liskni_si: huh, you're right, it appears to be written in C
07:09:38 <ray> the only requirement is that all the 't's are the same
07:09:44 <Cheery> byorgey: exactly
07:09:54 <Cheery> byorgey: I mean.. there's lisp implementations too
07:10:07 <ray> so if you apply id to a function :: a -> b
07:10:08 <byorgey> Cheery: apparently Hugs is written in C, which I didn't know before.
07:10:11 <Cheery> their meaning is not to be alternatives but explain the ideas and concepts
07:10:15 <ray> the result has type a -> b
07:10:34 <ray> and in this case id :: (a -> b) -> (a -> b)
07:10:48 <PietJanssen> so if it would be a -> (b -> c)?
07:10:57 <PietJanssen> for the id
07:10:59 <ray> this is the same as id :: (a -> b) -> a -> b
07:10:59 <EvanR-work> PietJanssen: you applied u -> v to w, so i just did u = w, since u and w both have other forms ( in terms of -> ) i look the left sides of the two -> and equated them, and the right sides and equated them yielding two more equations
07:11:09 <ray> and that matches a -> b -> c
07:11:44 <PietJanssen> ehm
07:11:47 <adimit> is code.haskell.org weirdly slow for anyone else? I can't get any sources down from there :-(
07:12:05 <EvanR-work> t -> t, a -> (b -> c)
07:12:06 <ray> rename the variables to get (b -> c) -> b -> c and let a = b -> c
07:12:33 <PietJanssen> <EvanR-work> t -> t, a -> (b -> c)
07:12:35 <EvanR-work> t=a t=b->c
07:12:38 <PietJanssen> I can somewhat see that
07:12:45 <quicksilver> PietJanssen: there is no rule about first variable first. The point is that (->) is a binary type constructor; it takes two parameters.
07:12:57 <quicksilver> PietJanssen: (a -> b -> c) *is* (a) -> (b -> c)
07:13:04 <quicksilver> that's simpley what it means.
07:13:09 <PietJanssen> alright
07:13:13 <quicksilver> (it's an arbitrary convention, but it is what it means)
07:13:35 * hackagebot xml-monad 0.4 - Monadic extensions to the xml package.  http://hackage.haskell.org/package/xml-monad-0.4 (AristidBreitkreuz)
07:13:37 <PietJanssen> so we have (a) -> (b -> c) as input of the uncurry function?
07:13:57 <EvanR-work> thats the definition of uncurry, you are giving something of type t->t as input
07:14:03 <Cheery> byorgey: I've read peyton jones books about haskell, though the time I read them I understood badly how it all works
07:14:14 <PietJanssen> aha
07:14:22 <PietJanssen> so when I have that there
07:14:24 <Cheery> terrible syntax and bad understanding about the language has this far made me to ignore haskell
07:14:24 <arcatan> I'm trying to generate haddock documentation for a module that uses quasiquotation and it's failing with an error about GHCi not finding a symbol
07:14:36 <PietJanssen> how can I get this to (a -> b, a) -> b
07:14:41 <PietJanssen> because there is no c left now?
07:14:41 <arcatan> https://gist.github.com/667791 here's a simple example and the error message
07:14:47 <EvanR-work> those a and b are now in a different context
07:14:54 <arcatan> does anyone know how to make that work?
07:15:00 <EvanR-work> i was using lambdabots letters
07:15:05 <EvanR-work> :t uncurry id
07:15:06 <lambdabot> forall b c. (b -> c, b) -> c
07:15:54 <PietJanssen> yeah but when you have the (a) -> (b -> c), how does this fit into the uncurry?
07:16:14 <EvanR-work> PietJanssen: if you apply uncurry to something of type (a -> b -> c), what is the type of the result?
07:16:16 <quicksilver> arcatan: haddock didn't support QQ for a while
07:16:33 <quicksilver> arcatan: I don't know which version it went into
07:16:45 <arcatan> quicksilver: i'm using the latest version, 2.8.1
07:16:54 <quicksilver> hmm. Probably not that then.
07:17:24 <PietJanssen> EvanR-work:  that would result in (a,b) -> c
07:17:34 <EvanR-work> ok
07:18:08 <EvanR-work> now use equations t=a and t=b->c and youll give what lambdabot shows above
07:18:17 <EvanR-work> s/give/get/
07:18:31 <PietJanssen> let me see
07:19:29 <EvanR-work> ignore this calculation im about to do
07:19:37 <EvanR-work> :t undefined
07:19:38 <lambdabot> forall a. a
07:19:43 <EvanR-work> :t uncurry undefined
07:19:43 <lambdabot> forall a b c. (a, b) -> c
07:19:59 <sipa> :t curry undefined
07:20:00 <lambdabot> forall a b c. a -> b -> c
07:20:59 <EvanR-work> im wondering how the type checker decides which way to 'simplify' the equations...
07:21:11 <PietJanssen> EvanR-work: if t =a and t = b -> c, how to fit this in the (a,b) -> c case? I mean, if the first a would be 'a', the second b would be 'b->c' , but what about c?
07:21:24 <EvanR-work> c is c
07:21:34 <EvanR-work> b is b
07:21:37 <EvanR-work> a is t
07:21:44 <EvanR-work> (and also a)
07:21:59 <taylanub> and that's where the universe implodes
07:22:03 <PietJanssen> but then you have (a, b->c) -> c, which is not the same as lambdabot 
07:22:19 <EvanR-work> how did b go to b->c
07:22:23 <EvanR-work> b != b->c
07:22:42 <PietJanssen> but how can t be a AND b->c at the same time>
07:22:59 <PietJanssen> the > is a ? :)
07:23:00 <EvanR-work> things can have more than one name
07:23:04 <quicksilver> PietJanssen: because you don't know what 'a' and 'b -> c' are yet
07:23:07 <quicksilver> you're unifying
07:23:13 <quicksilver> a,b,c can be anything (a priori)
07:23:23 <quicksilver> so we come to the conclusion that t = a = b->c
07:23:31 <quicksilver> so the type is (b -> c) -> (b -> c)
07:23:56 <PietJanssen> but it could also mean that t = a -> a?
07:24:17 <EvanR-work> it could, t could also be w -> j -> p
07:24:30 <quicksilver> PietJanssen: well, it's true that t = a -> a
07:24:35 <quicksilver> PietJanssen: but, a = b -> c
07:24:38 <PietJanssen> hm so if a = (b->c), and b = b so c = c
07:24:50 <quicksilver> so (b -> c) -> (b -> c) is a 'more detailed' description
07:24:52 <quicksilver> more defined.
07:25:01 <quicksilver> of course b = b, yes.
07:25:04 <lars9> how to merge 1000 sorted list efficiently? normally a heap is suggested, what do we use in haskell?
07:25:15 <sipa> :t sort
07:25:16 <lambdabot> forall a. (Ord a) => [a] -> [a]
07:25:21 <Zao> Bi-iteration?
07:25:21 <PietJanssen> then you get ((b->c), b) -> c
07:25:27 <EvanR-work> PietJanssen quicksilver you just mixed up the name scheme
07:25:27 <PietJanssen> if I understand correctly
07:25:34 <EvanR-work> PietJanssen: t != a -> a
07:25:43 <quicksilver> sorry.
07:25:45 <EvanR-work> i used t to be in the type of id, t -> t
07:25:48 <PietJanssen> why EvanR-work ?
07:25:53 <EvanR-work> t is anything
07:26:06 <quicksilver> I did mix up the names
07:26:12 <PietJanssen> i see
07:26:15 <quicksilver> well I think it was names i used some while back
07:26:19 <quicksilver> but noe the ones you were using.
07:26:25 <PietJanssen> haha :)
07:26:28 <EvanR-work> probably, now we have three schemes
07:26:35 <PietJanssen> lol 
07:26:46 <PietJanssen> i can see that step, and it works indeed
07:26:55 <PietJanssen> but Im still a bit unclear how we got the b->c
07:27:16 <EvanR-work> i made up a rule about matching the two sides of two -> type expressions
07:27:35 <EvanR-work> if you have a -> b and thats the same as c -> d then a = c and b = d
07:27:39 <PietJanssen> is it because id is a -> a, and in the uncurry its a -> b -> c, so a -> (b -> c), so when compared, you have that the last a is equal to (b -> c)
07:27:39 <PietJanssen> ?
07:28:01 <EvanR-work> PietJanssen: you are overloading the letter a there
07:28:42 <PietJanssen> but thats how I see it, thats wrong then? :P
07:28:51 <PietJanssen> maybe I didnt made it 100% clear though what I meant :p
07:28:59 <wlangstroth> I see there was no love for the name "redis-hs", but I couldn't think of what else to call it
07:29:12 <EvanR-work> if id is a -> a, and uncurry is t -> (b -> c), compare you get a = t, a = b->c
07:29:30 <PietJanssen> yes that is what I meant EvanR-work 
07:29:38 <PietJanssen> i meant the part of a
07:29:42 <PietJanssen> not a itselves
07:29:43 <EvanR-work> you could have said
07:30:00 <EvanR-work> id is a -> a, and uncurry is (a -> (a -> a)) -> (a, a) -> a ;)
07:30:11 <EvanR-work> some of those a arent the same
07:30:31 * EvanR-work imagines a lambda calculus made especially for this
07:30:47 <PietJanssen> lol
07:30:51 <PietJanssen> just for you :)
07:31:07 <PietJanssen> but that makes sense indeed
07:31:39 <WatermelonStorm> Hi.
07:31:40 <EvanR-work> :t uncurry3
07:31:40 <lambdabot> Not in scope: `uncurry3'
07:32:22 <WatermelonStorm> printLn "Hello, world."
07:32:24 <WatermelonStorm> D'aw.
07:32:39 <EvanR-work> :t printLn "foo"
07:32:40 <lambdabot> Not in scope: `printLn'
07:32:46 <WatermelonStorm> So I thought.
07:32:49 <EvanR-work> :t putStrLn "foo"
07:32:50 <lambdabot> IO ()
07:33:42 <WatermelonStorm> Blame me for assuming that Haskell used "printLn".
07:33:50 <EvanR-work> i do
07:34:26 <EvanR-work> @let printLn = putStrLn
07:34:28 <lambdabot>  Defined.
07:34:34 <Jafet> :t (>> putStrLn []) . print
07:34:34 <EvanR-work> :t printLn "foo"
07:34:35 <lambdabot> forall a. (Show a) => a -> IO ()
07:34:35 <lambdabot> IO ()
07:35:04 <Jafet> Well, printLn doesn't sound all that useful.
07:35:28 <WatermelonStorm> Heh, I would like to learn Haskell for great good.
07:35:35 <sipa> @let printLn x = print x >> putStrLn ""
07:35:36 <lambdabot>  <local>:17:0:
07:35:36 <lambdabot>      Multiple declarations of `L.printLn'
07:35:36 <lambdabot>      Declared at: <l...
07:35:58 <Jafet> @undef
07:36:00 <WatermelonStorm> :t "Coal"
07:36:01 <lambdabot> [Char]
07:36:09 <Jafet> There, I just raised the entropy of the universe
07:36:15 <Jafet> @let printLn x = print x >> putStrLn ""
07:36:16 <lambdabot>  Defined.
07:36:44 <sipa> @pl \x -> print x >> putStrLn ""
07:36:44 <lambdabot> (>> putStrLn []) . print
07:36:58 <EvanR-work> @unpl (>> putStrLn []) . print
07:36:58 <lambdabot> (\ d -> (print d) >> (putStrLn []))
07:37:15 <EvanR-work> @pl (\ d -> (print d) >> (putStrLn []))
07:37:16 <lambdabot> (>> putStrLn []) . print
07:37:28 <EvanR-work> periodic orbit
07:37:37 <EvanR-work> or fixed point
07:43:43 <copumpkin> dcoutts: you around?
07:45:33 <copumpkin> dcoutts_: if I need to build a simple c program with no special command-line arguments to generate files for a cabal build, is there a simple way to do that? or should I do a build-type: custom and run gcc manually in the haskell file?
07:46:43 * hackagebot random-fu 0.1.3 - Random number generation  http://hackage.haskell.org/package/random-fu-0.1.3 (JamesCook)
07:48:30 <dcoutts__> copumpkin: oh you mean you've got a build tool for generating Haskell modules?
07:48:40 <dcoutts__> that happens to be written in C
07:48:44 <copumpkin> well, I'm actually just running the mkGmpDerivedConstants.c
07:48:46 <copumpkin> to get the header file :)
07:49:02 <copumpkin> but I need it before I can build my cmm
07:49:16 <dcoutts__> copumpkin: so currently there's no support for using pre-processors defined in the same package (though someone is actively working on it)
07:49:26 <copumpkin> I'd like to put as much of the control in cabal's hands as possible
07:49:28 <copumpkin> ah
07:49:41 <dcoutts__> copumpkin: and secondly there's no support for main functions being in C modules (there's a ticket)
07:49:59 <copumpkin> ah, I don't really need that, since I'm just making a library
07:50:01 <dcoutts__> copumpkin: so sorry, you'll have to use a custom setup for the moment
07:50:50 <copumpkin> is there a more reliable way to call a c compiler in the cabal API than explicitly building a command-line?
07:52:02 <dcoutts__> copumpkin: um, no, sorry
07:52:06 <copumpkin> okay :)
07:53:00 <Saizan> using gccProgram might make sense though
07:53:19 <copumpkin> aha
07:53:32 <copumpkin> yeah, that's the kind of thing I was looking for
08:08:47 <copumpkin> dcoutts__: quick other question: can I ask cabal to ask ghc to compile a .cmm file?
08:08:54 <copumpkin> or do I need to put that in the custom build too?
08:09:15 <dcoutts__> copumpkin: oh, hmm, lemme check...
08:09:36 <copumpkin> I looked in the integer-gmp package and couldn't even figure out who was building the .cmm file there
08:12:25 <copumpkin> I tried putting it in c-sources but that didn't appear to work
08:16:54 * hackagebot threads-pool 0.1 - A library to operate with pool of haskell's IO threads  http://hackage.haskell.org/package/threads-pool-0.1 (IlyaPortnov)
08:18:29 <copumpkin> hmm
08:18:38 <copumpkin> why would you want a pool of haskell threads?
08:20:08 <portnov> i wanted to give them tasks and receive results.
08:20:58 <portnov> for example, run pool of 3 threads, and create 10000 tasks to run them in queue, and receive results from another queue
08:21:01 <copumpkin> I mostly thought of thread pools as being a way of avoiding expensive spawning costs
08:21:17 <copumpkin> but haskell threads are super cheap
08:21:26 <portnov> to not run 10000 threads at once
08:21:31 <copumpkin> but I'll take a look and stop talking out of my ass
08:21:35 <copumpkin> :)
08:21:45 <portnov> that tasks could be not cheap at all
08:22:25 <vegai> they haven't been supercheap if you used -threaded
08:22:36 <vegai> at least when I last benched that. Perhaps it has changed recently
08:22:42 <copumpkin> vegai: they should be...
08:22:48 <copumpkin> since forkIO doesn't actually fork an OS thread
08:22:55 <portnov> for example, think about running `make' on the project which consist of 10^6 files: do you want to run 10^6 threads to compile them?
08:23:08 <copumpkin> portnov: your assumption seems to be that threads are expensive
08:23:21 <portnov> tasks could be expensive
08:23:26 <vegai> copumpkin: well, at least they used a lot more than without -threaded
08:23:33 <portnov> threads themself are not, off course.
08:23:36 <vegai> this was ghc 6.8
08:23:42 <vegai> or perhaps 61.0
08:23:44 <vegai> 6.10
08:24:57 <hpc> so quick question, which i feel sort of silly asking
08:25:03 <hpc> say i have f :: Maybe a
08:25:11 <hpc> and g :: MaybeT m a
08:25:20 <hpc> how to i lift f into g?
08:26:16 <bos> dcoutts_: moin
08:26:41 <sipa> :t moin
08:26:42 <lambdabot> Not in scope: `moin'
08:26:44 <roconnor> @unpl (\h -> h id) . (.)
08:26:44 <lambdabot> (\ g d -> g d)
08:28:05 <hpc> :t fmap return
08:28:06 <lambdabot> forall a (m :: * -> *) (f :: * -> *). (Monad m, Functor f) => f a -> f (m a)
08:28:11 <hpc> oho!
08:28:15 <hpc> nvm :D
08:29:13 <portnov> :t liftM return
08:29:14 <lambdabot> forall a1 (m :: * -> *) (m1 :: * -> *). (Monad m, Monad m1) => m1 a1 -> m1 (m a1)
08:29:32 <hpc> eh, <$> is prettier
08:31:22 <hpc> exploiting fail is fun!
08:31:32 <EvanR-work> fail is
08:31:42 <copumpkin> > fix ("fail is " ++)
08:31:43 <lambdabot>   "fail is fail is fail is fail is fail is fail is fail is fail is fail is fa...
08:31:57 <copumpkin> > fix ("fail is monic " ++)
08:31:58 <lambdabot>   "fail is monic fail is monic fail is monic fail is monic fail is monic fail...
08:31:59 <hpc> fail is such a hack, but fail = const Nothing is wonderful
08:32:18 <hpc> it's like perl, only without as much dollar sign
08:32:30 <EvanR-work> bling operator
08:33:19 <sipa> Haskell: print $ a + 5
08:33:30 <sipa> Perl:   print  $a + 5
08:33:43 <EvanR-work> coinsidence?
08:33:53 <hpc> coincidence, even
08:34:05 <EvanR-work> coincidence
08:34:10 <EvanR-work> coincidence
08:34:12 <EvanR-work> coincidence
08:34:17 <EvanR-work> coincidence
08:34:32 <sipa> > fix ("coincidence\n" ++)
08:34:32 <EvanR-work> runs shred on spelling region of the brain
08:34:33 <lambdabot>   "coincidence\ncoincidence\ncoincidence\ncoincidence\ncoincidence\ncoinciden...
08:35:00 <EvanR-work> or just switches to spanish
08:35:30 <hpc> could not open file /brain/language/spelling for editing: insufficient privileges
08:35:37 <hpc> :P
08:36:02 <EvanR-work> sudo
08:36:29 <WatermelonStorm> EvanR is not in the sudoers file. This incident will be reported.
08:37:03 <EvanR-work> !throw computer out window
08:38:07 <copumpkin> dcoutts__: any hints about where to look, or ideas about who actually builds gmp-wrappers.cmm in integer-simple? there's no reference to that filename anywhere in the package
08:38:32 <dcoutts__> copumpkin: sorry, got distracted
08:38:44 <copumpkin> no problem, I'm just puzzled :)
08:39:54 <copumpkin> can't even see how to get GHC to build a cmm file by hand
08:42:03 <astroboy> I know is quite a big file, but could someone help me with this: http://hpaste.org/paste/41286/error . the error is at line 69, and the ghc error message is at the bottom
08:42:07 <Saizan> if integers-gmp builds with cabal you could pass -v to see the invocations
08:42:50 <copumpkin> Saizan: it won't build here, so I assume it assumes it's living in a GHC build
08:43:47 <Saizan> astroboy: the problem is semOp
08:44:02 <Saizan> astroboy: it passes a String to throwError
08:44:35 <astroboy> Saizan: aaahhh
08:44:46 <astroboy> why did it report at line 69??? I was going crazy!
08:44:49 <dcoutts__> copumpkin: I think the ghc build system for that one just cheats
08:45:26 <copumpkin> dcoutts__: I figured :/ do you know how I can ask GHC to build the cmm file? so I can stick it in my custom build steps, at least?
08:45:40 <copumpkin> I tried doing ghc blah.cmm but it seems to think it needs to pass it to gcc
08:45:42 <dcoutts__> copumpkin: probably just ghc -c foo.cmm -o foo.o
08:45:47 <copumpkin> oh
08:46:02 * hackagebot cil 0.1.0 - An interface to CIL.  http://hackage.haskell.org/package/cil-0.1.0 (TomHawkins)
08:46:14 <copumpkin> hmm
08:47:14 <Saizan> astroboy: i think it's because of the type signature, but icbw
08:47:15 <copumpkin> maybe it is just a syntax error
08:47:21 <copumpkin> I guess cmm syntax changed recently, maybe
08:48:52 <astroboy> Saizan: it works, great
08:48:54 <astroboy> well it compiles
08:51:31 <adarshaj> Hi, Need a small help regarding Random number generation.
08:51:47 <adarshaj> I just want a random number from 0 to 4 , how do I generate it?
08:52:23 * adarshaj tried to follow wiki and is clueless now! :(
08:52:25 <hpc> adarshaj: random = 4 -- the average outcome of a fair die roll :P
08:52:29 <opqdonut> :t randomRIO (0,4)
08:52:30 <lambdabot> forall t. (Num t, Random t) => IO t
08:52:44 <opqdonut> that's an IO action that gives you a random number from 0 to 4
08:53:00 <adarshaj> does it prompt the user to input something ?
08:53:03 <opqdonut> no
08:53:19 <adarshaj> opqdonut: guess that is what I want then! thank you soo much!
08:53:58 <opqdonut> :)
08:54:39 <EvanR-work> hpc: indeed, i heartily suggest that method
08:54:53 <EvanR-work> its better than some alternatives
08:55:16 <adarshaj> hpc: EvanR-work: He.. he.. yeah very simple indeed ;)
08:55:41 <EvanR-work> such as seeding a generator with a random number and taking the first element
08:56:48 <hpc> "how do we make a random number generator? well first, we need a random number generator"
08:57:26 <EvanR-work> thats my preferred method
08:58:40 <hpc> "and then we assume a spherical cow, so we can sound smarter than we are"
08:58:53 <EvanR-work> think of it as a black box that spits out numbers, inside of which is a gerbil throwing a fair die
08:59:42 <EvanR-work> then how does the die work?
08:59:47 <EvanR-work> see previous explanation
08:59:47 <shapr> Has anyone considered cabalizing the UniForM workbench? http://www.informatik.uni-bremen.de/uniform/wb/
08:59:58 <EvanR-work> its gerbils all the way down
09:00:02 <shapr> EvanR-work: Have you cabalized anything?
09:00:11 <EvanR-work> yes
09:00:19 <EvanR-work> but im not very adept
09:00:32 <shapr> EvanR-work: Oh, what did you cabalize?
09:00:41 <EvanR-work> some game i think
09:00:46 <EvanR-work> i didnt upload it
09:00:49 <EvanR-work> to hackage
09:00:55 <shapr> Oh, too bad. I'd like to see a good example.
09:01:03 <shapr> And you're often active here, so I thought I'd ask you questions.
09:01:20 <EvanR-work> im not the most prolific haskeller
09:04:04 <shapr> EvanR-work: Are you working on some fun code?
09:04:17 <Cheery> is there a "write yourself a haskell" -tutorial?
09:04:56 <lispy1> Cheery: yes
09:05:04 <hpc> Cheery: sure, it's a very popular book: "Write Your Own GHC in Just 21 Years"
09:05:06 <hpc> :P
09:05:28 <lispy1> Cheery: http://research.microsoft.com/en-us/um/people/simonpj/papers/pj-lester-book/
09:05:31 <EvanR-work> shapr: a web app
09:05:43 <shapr> EvanR-work: Oh cool, got a prototype online?
09:06:00 <EvanR-work> no, i dont have internet ;)
09:06:04 <EvanR-work> or a remote server
09:06:42 <lispy1> Cheery: that book tells you everything you need to know to get a toy haskell running from scratch :)
09:07:38 <Cheery> lispy1: appreciating the author. Thank you from the reference.
09:08:48 <Cheery> hpc: just letting you know that sounds horrible.
09:08:57 <hpc> :D
09:09:22 <EvanR-work> to build ghc, first install ghc
09:11:50 <aristid> EvanR-work: those instructions are your ass (_|_)
09:12:32 <EvanR-work> paradigm shift in functional programming literature
09:12:40 <EvanR-work> bottom will now we referred to as ass
09:12:57 <aristid> that's what she said
09:13:28 <EvanR-work> and to make it more interesting, 2tuples will be referred to as titties
09:13:43 <shapr> EvanR-work: c'mon man, this is a family channel.
09:13:54 <EvanR-work> normal application will be replaced with (.)(.)
09:14:04 <EvanR-work> shapr: he started it
09:14:08 <hpc> :t (.)(.)
09:14:09 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
09:14:12 <shapr> EvanR-work: be nice
09:14:51 <aristid> shapr: no juvenile jokes in #haskell? :D
09:14:58 <EvanR-work> since when!
09:15:06 <shapr> aristid: I don't mind once a week or so... but past that, take it to -blah
09:15:20 <EvanR-work> blah is not family?
09:15:31 <shapr> Definitely not.
09:15:52 <aristid> i wish records were more first-class in haskell
09:16:06 <aristid> i'm finding myself write typeclasses just to overcome their limitations
09:16:47 <shapr> I wish typeclasses could have their granularity changed somehow.
09:17:04 <EvanR-work> records are poor mans Data.Map FieldName Dynamic
09:17:40 * ski . o O ( `Map1 Key Value' )
09:17:42 <Cheery> you know why I dislike haskell? because it shows up as an entirely terrible linenoise, similar how factor and forth does
09:17:45 <aristid> EvanR-work: haha
09:17:57 <EvanR-work> @src Map1
09:17:57 <Cheery> but guess why I look into it and be on this channel then?
09:17:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:18:06 <aristid> Cheery: to troll?
09:18:13 <shapr> I dislike Haskell because I can't limit the length of a list by assigning it a certain type.
09:18:16 <aristid> @quote troll
09:18:17 <lambdabot> qwe1234 says: stfu, troll.
09:18:19 <Cheery> aristid: that's good guess. half yes
09:18:27 <aristid> @quote IO.String
09:18:27 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
09:19:00 <ski> EvanR : `newtype Map1 key value = MkMap1 [exists i. (key i,value i)]', for a simplistic association-list implementation
09:19:09 <shapr> I dislike Haskell because it has not yet taken over the world, and I still have to deal with source code in other languages.
09:19:12 <EvanR-work> Cheery: many people dont understand style, much like in C C++ PHP JS python perl lua java and c#
09:19:39 <EvanR-work> all you can do it strive for better in your own work
09:19:58 <Cheery> I looked into xmonad and realised it has damn nice configuration mechanism, except that syntax looks like garbage.
09:20:36 <EvanR-work> ski: ah
09:21:02 <EvanR-work> existentials to the rescue
09:21:06 <Cheery> it also crashed down pretty fast if I did something wrong. and were easy to configure
09:21:34 <Cheery> fortunately for the syntax I think there's something I can yet do. :)
09:21:44 <Cheery> get rid of it in whole ^^
09:22:20 <ski> EvanR-work : the idea being that with `class Eq1 f where eq1 :: forall i j. f i -> f j -> Maybe (Equal i j)', `instance Eq1 Key' will represent a "heterogenous" equality on a GADT `Key', and then `Value' can also index on the same thing
09:22:30 <Cheery> there's another thing I'm interested about. That's exceptions.
09:22:45 <Cheery> been getting tired to C and python way of doing this
09:23:19 <EvanR-work> well then dont use exceptions at all
09:23:28 <Cheery> most errors not reported. some errors drop down the system.
09:23:52 <Cheery> python way of doing it hides the possible errors a method might give
09:24:43 <EvanR-work> IO exceptions do the same thing
09:25:04 <EvanR-work> there are way to identify possible failures using the type of the function / action
09:25:17 <Cheery> well my point is.. I think its fundamentally bad behavior.
09:25:33 <Cheery> since programs should be designed in a way that its clear what happens when things do not happen
09:25:36 <EvanR-work> IO and IO errors are fundamentally bad
09:25:48 <ski> EvanR-work : anyway, the key operation would be `lookup1 :: forall key value i. Eq1 key => Map1 key value -> (key i -> Maybe (value i))'
09:26:16 <EvanR-work> ski: whats i again?
09:26:20 <shapr> Cheery: Hey, be nice, calling something garbage is a purely emotional description.
09:26:21 <ski> any type
09:27:01 * ski GCs the channel of emotional descriptions
09:27:31 <EvanR-work> now that the gc sweep is over
09:27:33 <shapr> ski: and if that doesn't work, I have the hammer.
09:27:58 <Cheery> shapr: yeah, though there's certain similarity between /dev/random output and catenation of *.hs or perl files.
09:27:59 <EvanR-work> the maybe monad is a very happy way to do pure errors
09:28:23 <ski> EvanR-work : you had `Data.Map FieldName Dynamic', presumably you wanted (in a specific context) that each value in `FieldName' would only be associated to values of a specific type
09:28:25 <EvanR-work> use /dev/urandom
09:28:42 --- mode: ChanServ set +o shapr
09:28:48 <shapr> Cheery: No really, be nice.
09:28:56 <EvanR-work> ski: that would be nice, but i knew that it didnt fullful that
09:29:42 <ski> EvanR-work : so, you'd instead do `data FieldName :: * -> * where F0 :: FieldName Int; F1 :: FieldName Foo; ...', so then `Map1 FieldName Identity' would always map `F0' to an `Int', &c.
09:29:59 <Cheery> shapr: you think its not nice to say in haskell channel negative things about the language?
09:30:00 <ski> (well, to an `Identity Int', but it amounts to the same thing)
09:30:17 <Cheery> shapr: maybe not.
09:30:29 <Cheery> shapr: but should I be quiet because it's not nice?
09:30:39 <shapr> Cheery: I think it is not useful to make purely emotional statements that cannot help anyone or anything improve.
09:30:40 <EvanR-work> shapr: this is unusually intolerant of trolls
09:30:50 <shapr> EvanR-work: I've been busy.
09:30:58 <quicksilver> the point is not that it's not nice, but it just wasn't a useful comment. "line noise" "garbage"
09:31:15 <quicksilver> you're very welcome to be critical in a useful way
09:31:17 <EvanR-work> now quicksilver is doing it, better ban him! ;)
09:31:37 <EvanR-work> ski: what is the function key
09:31:40 <shapr> Cheery: If you say "I perceive single character symbolic operators to be difficult for reading comprehension." then we have something useful to discuss.
09:31:51 <ski> EvanR-work : `key' is any type function. `Identity' in my example
09:32:09 <EvanR-work> oh type constructor
09:32:34 <monochrom> I predict that all discussions of "is single character symbolic operator readable" eventually become purely emotional.
09:32:45 <shapr> Cheery: If you say "I am not accustomed to languages where small changes in inputs produce large changes in output." this is also useful data.
09:32:52 <EvanR-work> purely emotional programming
09:33:02 <ski> EvanR-work : you may wonder why not simplify it to `newtype Map1 key = MkMap1 [exists value. (key value,value)]', so you get simply `Map1 FieldName' then, instead of `Map1 FieldName Identity'
09:33:04 <shapr> EvanR-work: will get people removed from this channel.
09:33:26 <EvanR-work> no side-logic
09:34:10 <shapr> Cheery: Haskell has many flaws, but a positive and energetic community is one of the strengths of the language.
09:34:35 <ski> EvanR-work : however, i think the more general variant has potential of being useful, so you can reuse the same "field names"/"keys"/"labels" in different maps, where you don't *need* to associate them with the same types in each different kind of such map
09:34:45 <EvanR-work> ski: im still trying to understand the simpler one
09:34:53 <ski> ok
09:34:57 <EvanR-work> key value is like, a field name
09:35:04 <shapr> Cheery: What do you think of what I said?
09:35:06 <ski> yes
09:35:27 <Cheery> shapr: yay. its nice to be positive.
09:35:27 <EvanR-work> so balance :: Account Integer ?
09:35:57 <EvanR-work> lookup1 m1 balance
09:36:12 <EvanR-work> Maybe Integer
09:36:27 <aristid> @hoogle lookup1
09:36:27 <lambdabot> No results found
09:36:35 <ski> in `[exists value. (key value,value)]', each first part of the association pair will have type `key value' for some type `value', the idea being that by inspecting the constructor of the GADT `key', you can rediscover what `value' was used in that particular association pair, and so you rediscover what type of thing goes into the second part
09:36:35 <Cheery> shapr: its the overall look of the things I critisize anyway. That stuff might come from the plentifulness of syntactic constructions
09:37:04 <zygoloid> i'm a bit surprised to see haskell's concrete syntax being bashed -- the semantics can be non-obvious, but i've generally found the concrete syntax to be very clean and simple compared to c++ or perl; on a par with python, even.
09:37:05 <Cheery> shapr: but then, without them haskell would look more horrible
09:37:25 <aristid> > fix $ (1:) . (1:) . (zipWith (+) <*> tail)
09:37:26 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
09:37:42 <EvanR-work> python has a lot of syntax
09:37:43 <ski> EvanCarroll : `Account' being an example of `key' ?
09:37:45 <aristid> Cheery: does that look horrible to you? :>
09:37:49 <EvanR-work> ski: yes
09:38:02 <ski> s/EvanCarroll/EvanR-work/
09:38:19 <ski> EvanR-work : so, yes to your question
09:38:33 <EvanR-work> is the name Account suggesting i dont understand something
09:38:41 <EvanR-work> doesnt seem like much of a key
09:38:45 <ski>   m1 :: Map1 Account , balance :: Account Integer |- lookup1 m1 balance :: Maybe Integer
09:38:57 * ski has no idea
09:39:11 <ski> EvanR-work : you invented the name `Account', here :)
09:39:15 <shapr> Cheery: So, how could it be improved?
09:39:17 <EvanR-work> Map1 Account can only have Accounts?
09:39:31 <aristid> what is this Map1 thing?
09:39:44 <EvanR-work> a record
09:39:48 <ski> aristid : an idea of mine that i'm trying to explore
09:39:54 <Cheery> shapr: I am going to try the graphical programming card.
09:39:55 <EvanR-work> with existential stuffs
09:40:08 <Cheery> shapr: stepping out of text mode.
09:40:24 <EvanR-work> Cheery: shapr: abstract syntax tree is a tree, not a text file. suggestive?
09:40:27 * hackagebot redis-hs 0.0.8 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.0.8 (WillLangstroth)
09:40:45 <Cheery> EvanR-work: exactly. 
09:41:00 <ski> aristid : simple variant is `newtype Map1 key = MkMap1 [exists value. (key value,value)]', more general variant (which is the one i'm actually considering) is `newtype Map1 key value = MkMap1 [exists i. (key i,value i)]'
09:41:42 <ski> aristid : short description : a kind of map, where the type of values can depend on the actual keys used (roughly)
09:41:43 <Cheery> been studying this for a while, I see there's plentiful graphical ways to represent programs and expressions. they cannot be used basicly because we write programs straight into text files.
09:41:46 <aristid> ski: the second variant makes more sense :)
09:41:46 <quicksilver> haskell is in "good" company having lots of syntactical constructs though... it is comparable to most other propgramming languages.
09:42:11 <ski> aristid : the first variant is basically `Map1 key Identity', in terms of the second one
09:42:11 <quicksilver> in common use only lisp has fewer, and many of the more popular languagse could be argued to have more.
09:42:11 <aristid> ski: but that is not valid haskell the way it is
09:42:31 <aristid> quicksilver: haskell is relatively light on syntactic constructs, i think
09:42:37 <quicksilver> aristid: exactly.
09:42:53 <ski> aristid : no, you'll need to make `data Association1 key value = forall i. MkAssociation1 (key i) (value i)',&c.
09:43:06 <nlogax> i just wrote a PEG for JS, more or less just copying the grammar from the haskell report. was surprised at how small it was
09:43:16 <aristid> ski: are you going to actually do that?
09:43:33 <ski> how do you mean ?
09:43:34 <JohnnyL>  In : sum (takeWhile (<10000) (filter odd (map (^2) [1..])))   does each map iteration get checked by the outer odd filter?
09:43:35 <Cheery> aristid: it looks horrible to me. if you ask particulars, first thing is I do not understand what it does by just glancing at it.
09:43:42 <ski> that's what i'm actually experimenting with, yes
09:43:53 <Cheery> aristid: but there's things I'm missing, forgotten from the last time I wrote haskell myself
09:44:03 <ski> (i just prefer presenting the idea, using the `exists' syntax)
09:44:06 <Cheery> aristid: precedence of operators
09:44:25 <EvanR-work> JohnnyL: filter happens first
09:44:35 <iveqy> hi, i'm having type problems. When doing an assignment a function should have type [PhrasePair] -> Phrase -> Phrase. I don't understand what that means och my solution has Maybe char, char etc. as types. Where can I learn more?
09:44:35 <aristid> Cheery: there are enough parentheses to give little doubt as to the precedence
09:44:45 <aristid> Cheery: and ghci can show you the exact precedence if in doubt
09:45:13 <EvanR-work> JohnnyL: the first iteration of filter will end up evaluating the entire map, and then it should be like that forever
09:45:24 <EvanR-work> well
09:45:28 <EvanR-work> there is only one iteration of filter
09:45:33 <ski> EvanR-work : anyway, you suggested `m1 :: Map1 Account' (or `m1 :: Map1 Account Identity' in the general variant) and `balance :: Account Integer'
09:45:35 <EvanR-work> the end
09:45:43 <Cheery> aristid: yep. is <*> applied or given as an argument?
09:45:56 <JohnnyL> EvanR-work: OK
09:46:00 <aristid> Cheery: <*> is an operator
09:46:17 <ski> EvanR-work : this means that `Account' is a type of "field-names", indexed by the type of values each field name is supposed to be associated with
09:46:28 <aristid> Cheery: now if you don't know what <*> does, it will be hard to know what the whole expression does
09:46:37 <aristid> Cheery: but now it's time for dinner :P
09:46:58 <Cheery> aristid: say.. how man such operators there are in haskell?
09:47:01 <Cheery> *many
09:47:09 <EvanR-work> infinite
09:47:10 <ski> EvanR-work : and `balance :: Account Integer' (which presumably (but not necessarily) is really a data constructor of `Account') would be a "field-name" which must be associated to values of type `Integer'
09:47:13 <quicksilver> Cheery: they are just functions.
09:47:19 <quicksilver> Cheery: they are user-defined in general.
09:47:32 <quicksilver> or defined by libraris, or whatever.
09:47:58 <quicksilver> the Prelude defines some common ones (all the standard maths stuff, plus . and $ for functions, ++ and : for lists, no doubt some others I forget)
09:48:26 <ski> aristid : any more questions/comments ?
09:48:33 <EvanR-work> ski: so a give map1 must have zero or one Account Integers
09:48:45 <ski> no
09:49:02 <ski> it must have zero or one `balance' field
09:49:10 <EvanR-work> oh
09:49:21 <EvanR-work> what distinguishes them
09:49:32 <ski> but there could possibly be many field-names / keys / labels, which all are to be associated with `Integer's
09:49:39 <Cheery> quicksilver: when does one want to define a new operator?
09:50:14 <EvanR-work> when it will be easier to read and hard to confuse with common other operators
09:50:29 <EvanR-work> hint redefining + is no
09:50:34 <ski> EvanR-work : `instance Eq1 FieldName', giving you `eq1 :: forall i j. FieldName i -> FieldName j -> Maybe (Equal i j)', which is supposed to be an equality (sortof), distinguishes them
09:50:52 <quicksilver> Cheery: whenever you think it looks nicer, basically.
09:51:01 <paolino> Cheery: when it's a binary function and it is supposed to appear often
09:51:03 <quicksilver> Cheery: operators are a tradeoff. They're most unintuitive.
09:51:09 <quicksilver> Cheery: but they are brief.
09:51:14 <EvanR-work> ah, Eq1
09:51:22 <EvanR-work> what does the 1 indicate
09:51:22 <quicksilver> and infix syntax "looks nicer" for some kinds of expression.
09:51:23 <Cheery> paolino: but for binary function you've got `function` -notation
09:51:32 <EvanR-work> it must be a common meaning across all your stuff
09:51:42 <quicksilver> Cheery: yes, and `function` is also very useful
09:51:52 <ski>   class Eq1 f
09:51:55 <ski>     where
09:52:03 <ski>     eq1 :: forall i j. f i -> f j -> Maybe (Equal i j)
09:52:13 <Cheery> "supposed to appear often" is also a bit weird. since a bit more expressive function name shouldn't be lot more work anyway
09:52:45 <paolino> it's less work to read it
09:53:04 <Cheery> paolino: yes, long as you do not forget the operator
09:53:15 <ski> EvanR-work : you have `Typable :: * -> constraint',`Typable1 :: (* -> *) -> constraint',`Typable2 :: (* -> * -> *) -> constraint',&c.
09:53:18 <Cheery> then you later open the file and get WOOT. :)
09:53:20 <EvanR-work> Cheery: :info (+) in the interpreter
09:53:26 <paolino> Cheery : this is another point of haskell
09:53:46 <EvanR-work> or just look at the type of that operator
09:53:50 <EvanR-work> :t (***)
09:53:50 <ski> EvanR-work : i was just thinking that `Map :: * -> * -> *',`Map1 :: (* -> *) -> (* -> *) -> *',&c. might be a useful analogy
09:53:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
09:53:58 <paolino> @type (<*>)
09:53:59 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
09:54:18 <EvanR-work> ski: oh
09:54:52 <EvanR-work> Cheery: the types reveal a lot about stuff
09:54:58 <Cheery> I think I'd expect a special operator when there's an interest in doing a new language construct
09:55:23 <ski> EvanR-work : so the `1' is mostly to suggest that this is like `Map', but working on key and value types of kind `* -> *', rather than of kind `*'
09:55:29 <Cheery> so whenever there's an operator, the code would yield a new concept thats yet unknown to me.
09:55:35 <EvanR-work> in php they attempt to write paragraphs to explain the operation of the procedures, partly because they have to, and partly because they dont have a very expressive type system
09:56:03 <EvanR-work> Cheery: 'function' is not a new language construct
09:56:20 <paolino> Cheery: any haskeller sooner or later hits <*>, and will not redefine it because it's enough general to express something important, but <*> is still a function
09:56:25 <EvanR-work> ski: yeah i see that. what is Equal i j?
09:56:50 <JohnnyL> EvanR: It only calls filter once because of Haskell's lazyness?
09:56:54 <ski> EvanR-work : e.g. `data Equal :: * -> * -> * where Refl :: forall a. Equal a a'
09:57:10 <EvanR-work> JohnnyL: i need to read your expression again
09:57:28 <JohnnyL>  sum (takeWhile (<10000) (filter odd (map (^2) [1..])))  
09:57:43 <EvanR-work> JohnnyL: sum and take while arent operating on new lists each time
09:57:49 <EvanR-work> its suming one list
09:57:52 <Cheery> JohnnyL: that is pretty easy to understand.
09:57:53 <EvanR-work> takeWhile is taking from one list
09:57:55 <JohnnyL> right.
09:58:03 <EvanR-work> filter is filtering one list
09:58:18 <EvanR-work> and [1..] is one list
09:58:29 <JohnnyL> I am trying to see how it works underneath. How many times an outer function get processed for each data item.
09:58:43 <EvanR-work> the data items dont exist
09:58:50 <EvanR-work> sum happens first
09:59:10 <cts> Hi!  Is there a set of exercises for Haskell learners to try ones new skills on?
09:59:12 <cts> I read lyah, and it has a lot of examples, but I'd like to have more training.
09:59:14 <EvanR-work> to carry out the sum it gets numbers one by from from takeWhile
09:59:16 <ski> EvanR-work : basically, if a call to `eq1 :: forall f i j. Eq1 f => f i -> f j -> Maybe (Equal i j)' returns `Nothing' then the two arguments are supposed to be unequal (but it might be that the types `i' and `j' are still equal), but if it returns `Just Refl', then that not only tells you that the two arguments are supposed to be equal, but also that the types `i' and `j' are actually the same type
09:59:19 <EvanR-work> one by one
09:59:30 <ski> EvanR-work : and this can be very important
09:59:44 <shapr> cts: Have you tried Project Euler or Ninety Nine Haskell Problems?
10:00:13 <Cheery> JohnnyL: that routine takes a list put to power of two. gives you a sum of odd numbers that are smaller than 10000
10:00:15 <EvanR-work> ski: whats Refl?
10:00:21 <cts> shapr: No, thank you!  I'll have a look at that.
10:00:24 <JohnnyL> EvanCarroll: Ok , so sum gets called once but it processed for every valid data item.
10:00:31 <ski> JohnnyL : `filter' is only called once, from there, but possibly `filter' is recursive, in which case it will probably call itself many times, recursively
10:00:31 <EvanR-work> JohnnyL: no..
10:00:35 <JohnnyL> Cheery, thanks not my question.
10:00:44 <EvanR-work> JohnnyL: nothing is calling anything, sum xs is evaluated like so
10:00:47 <EvanR-work> @src sum
10:00:47 <lambdabot> sum = foldl (+) 0
10:00:49 <JohnnyL> ski: ah ok
10:00:58 <ski> EvanCarroll : `Refl' is the (only) constructor of `Equal'
10:01:05 <Cheery> JohnnyL: okay.
10:01:17 <JohnnyL> Cheery: thanks anyway though. :)
10:01:19 <EvanR-work> ski: interesting. so why is this not Bool
10:01:25 <Cheery> well getting to study this tutorial. :)
10:01:43 <Cheery> (So I can get on to writing an interesting software)
10:01:47 <JohnnyL> ski: thats what I had though. :)
10:01:48 <JohnnyL> thought
10:01:58 <ski> EvanR-work : using `Bool' would not tell the type system that the types `i' and `j' have to be the same, in the branch that matches the result of the `lookup1' call with `Just Refl'
10:02:02 <EvanR-work> JohnnyL: sum basically does + for each data item
10:02:19 <EvanR-work> but the items are computed lazilly
10:02:43 <JohnnyL> EvanR: if I put a head as teh first call.. It would only grab one data item. correct?
10:02:58 <EvanR-work> JohnnyL: head instead of sum?
10:03:02 <EvanCarroll> JohnnyL: You know, if you irssi, or xChat then tab completion would take into account recent activity ;)
10:03:04 <JohnnyL> (ie. it wouldn't call successively)
10:03:25 <paolino> JohnnyL: compute only the first, if possible
10:03:43 <astroboy> Saizan: I have a similar problem again: http://hpaste.org/41292/errort_troubles
10:04:03 <EvanR-work> JohnnyL: head takeWhile filter map (pseudo haskell) would only process enough to get at most 1 thing
10:04:18 <ski> EvanR-work : the implementation of `lookup1', using `eq1' is simple : `lookup1 (MkMap1 []) _ = Nothing; lookup1 (MkMap1 (MkAssoc1 key value:assocs)) key0 = case eq1 key0 key of Nothing -> lookup1 (MkMap1 assocs) key0; Just Refl -> Just value'
10:04:24 <EvanR-work> it may have to iterate through some numbers [1..] to get there, and it may never terminate
10:04:36 <JohnnyL> so there is a data "path" that gets traversed by rules in the outer function(s) in accordance to what data it benig fetched from.
10:04:37 <EvanR-work> but then it stops
10:04:37 <ski> EvanR-work : using `Maybe (Equal i j)', instead of `Bool' is what makes that type-check
10:04:54 <JohnnyL> being
10:04:59 <EvanR-work> ski: yes, so its a type-binary bool
10:05:29 <EvanR-work> JohnnyL: just try evaluating your expression by hand using the definitions of the functions as given by lambdabot, and lazy evaluation
10:05:38 <EvanR-work> but use head rather than sum
10:05:58 <EvanR-work> sum is strict
10:05:58 <ski> (EvanR-work : obviously, in a serious implementation, one would not use a single-linked list, but the basic same idea applies, i believe)
10:06:18 <JohnnyL> EvanR: ok
10:06:54 <ksf> http://xkcd.com/816/
10:08:00 <EvanR-work> lol
10:08:24 <JohnnyL> that means that strictness overrides any lazyily produced functions.
10:08:45 <astroboy> Could someone guess what is going on here: http://hpaste.org/41292/errort_troubles ? the ghc error is at the end of the page
10:09:00 <Azrael-> @src List.transpose
10:09:01 <lambdabot> Source not found. My pet ferret can type better than you!
10:09:09 <Azrael-> @src transpose
10:09:09 <lambdabot> transpose []             = []
10:09:09 <lambdabot> transpose ([]   : xss)   = transpose xss
10:09:09 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
10:09:24 <EvanR-work> JohnnyL: strict is related to termination, i just gave you head so youd finish sooner ;)
10:10:25 <JohnnyL> EvanR: Thats what 'she' said! :)
10:10:30 <EvanR-work> >_<
10:10:35 <ski> (EvanR-work : i'm not sure what you mean by "type-binary bool" ..)
10:10:41 <EvanR-work> ski: nevermind
10:10:45 <Cheery> its funny that I disagree most about negative critique in google
10:10:52 <Cheery> (about haskell)
10:11:12 <SubStack> google has haskell haters?
10:11:26 <Cheery> SubStack: google search brings up haskell haters
10:11:42 <Cheery> http://www.google.fi/search?sourceid=chrome&ie=UTF-8&q=haskell+in+python
10:11:47 <EvanR-work> they are all over freenode
10:11:48 <SubStack> I thought google only hired elitest ivy-leaguers
10:11:54 <SubStack> oh
10:11:58 <SubStack> :p
10:12:37 <EvanR-work> either its a channel where most people have no clue about functional programming and theres one or two people there who know/like haskell, or its a channel full of people who are sort of familiar with it, never really used it, and collectively hate it
10:12:54 * shapr shrugs
10:12:56 <EvanR-work> or its #haskell
10:12:57 <Cheery> http://www.jelovic.com/articles/why_people_arent_using_haskell.htm <- I've gotten haskell has everything that guy is talking about
10:13:03 <shapr> The way I see it, people should use what they like to use.
10:13:13 <shapr> Whether that's Haskell or something else.
10:13:20 <monochrom> Can we change subject please?
10:13:27 <paolino> :t catchError
10:13:28 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
10:13:30 <shapr> But here on #haskell, the point is to improve the language by learning and coding and discussion.
10:13:41 <shapr> Hating is for other places, and I will enforce that.
10:13:45 <SubStack> I hate haskell, just less than most languages
10:14:20 <EvanR-work> shapr you sure are enforcing a lot today
10:15:15 <Cheery> shapr: you've got haskell_negative channel for this kind of stuff?
10:15:20 <EvanR-work> ski: would this formulation allow nicer 'updates' ?
10:16:43 <EvanR-work> Cheery: most negative stuff from outside is ill founded, so you should bring it up here so you have be corrected ;)
10:16:50 <paolino> :t \f -> catchError f return
10:16:51 <lambdabot> forall (m :: * -> *) a. (MonadError a m) => m a -> m a
10:16:59 <EvanR-work> can be*
10:17:18 <Cheery> shapr: don't worry, I don't get on here every day. :) This is the Cheery's "be negative" -day.
10:17:29 <ski> EvanR-work : you'd get `modify1 :: forall key value. Eq1 key => (forall i. key i -> value i -> value i) -> (Map1 key value -> Map1 key value)', i think
10:17:31 <lars9> 2:00am here, not a good time to debug...
10:17:38 <shapr> Cheery: It's okay, I have those days too. Major krapula days, mostly.
10:17:51 <paolino> astroboy: (MonadError a m) => m a -> m a, is not correct
10:18:33 <astroboy> paolino: ? what is wrong?
10:18:39 <cba-isaac> Greetings Haskell folk!! I am looking for a resource/tutorial on list manipulation in Haskell (for the beginner with a background in Java type languages). Can someone point me in the right direction? Google makes me sad.
10:18:40 <ski> EvanR-work : .. maybe you had something else in mind ?
10:18:40 <EvanR-work> ski: thats already nicer than update syntax for one field
10:18:54 <EvanR-work> since you can partially evaluate it
10:19:03 <shapr> cba-isaac: I would suggest Real World Haskell or Learn You a Haskell for getting started with Haskell!
10:19:09 <ski> EvanR-work : well, that's not really syntax at all, just an library operation
10:19:13 <paolino> astroboy: in your code 'a' is () but you have MonadRandom (SemError) m 
10:19:14 <EvanR-work> right
10:19:35 <EvanR-work> cba-isaac: i found this
10:19:38 <paolino> astroboy: so () /= SemError
10:19:51 <ski> EvanR-work : imo, both pointful and pointless ways to describe updates (and selections) are needed
10:19:52 <astroboy> paolino: I don't see "MonadRandom (SemError) m" in my code...
10:20:01 <EvanR-work> i cant find it..
10:20:08 <monochrom> http://tryhaskell.org/ is interactive haskell exercises, many of them are list manipulations
10:20:36 <ski> EvanR-work : in any case, the current record update syntax sucks for nested records, as i'm sure you are aware of
10:20:48 <astroboy> paolino: what do I do wrong? ghc says I infer SemError somewhere but I can't see where...
10:20:51 <paolino> astroboy: you have an action catchError f return
10:21:15 <EvanR-work> ski: personally ive never used nested records
10:21:23 <paolino> astroboy: line 48
10:21:23 <kstt> are http://trac.haskell.org and http://code.haskell.org down for ever or will they come back come day ? :)
10:21:34 <astroboy> paolino: yes, what's wrong about that?
10:21:45 <paolino> :t \f -> catchError f return
10:21:46 <lambdabot> forall (m :: * -> *) a. (MonadError a m) => m a -> m a
10:21:58 <proq> that "why people aren't using haskell" article makes me want to *not* post code snippets  ;P
10:21:59 <ski> EvanR-work : i'm not sure how common they are, generally, but when you need them, you need them, and it shouldn't be clumsy to operate on them, imo
10:22:12 <proq> why wouldn't want to lose the "haskell is for research types" image, now, would we?
10:22:20 <proq> *we wouldn't
10:22:32 <paolino> astroboy see the 'a' types in the constraint and in the type
10:22:40 <shapr> cba-isaac: There's lots of good stuff learning resources linked from http://www.haskell.org/
10:22:41 <EvanR-work> cba-isaac: i cant find this useful page with questions about how to do stuff on lists with the corresponding function as answer, but theres this
10:22:42 <astroboy> paolino: yes but semSL should return SemMonad ()
10:22:44 <EvanR-work> http://www.cse.unsw.edu.au/~en1000/haskell/inbuilt.html
10:22:45 <shapr> cba-isaac: Do you have any specific questions?
10:22:47 <ski> EvanR-work : i also think that the conflation between record fields and record selection functions is unfortunate
10:22:54 <paolino> astroboy: your f is m ()
10:23:01 <nostrand> are there people who knows Haskell but don't like it?
10:23:10 <astroboy> paolino: oohh the problem is that a has to be an error?
10:23:13 <shapr> nostrand: Yes, there are.
10:23:14 <EvanR-work> ski: whats the difference?
10:23:20 <paolino> astroboy: so a == ()
10:23:22 <nostrand> shapr: really?
10:23:24 <shapr> nostrand: But you wouldn't find them here on #haskell, they would be doing something else :-)
10:23:35 <astroboy> paolino: I see, so semSL should return an error?
10:23:42 <shapr> nostrand: Sure, I know several really smart people who believe that non-strictness is a dead end for programming languages.
10:23:47 <shapr> nostrand: I just don't agree with them :-)
10:24:08 <nostrand> shapr: i mean except Harrop :P
10:24:08 <paolino> astroboy: this is a solution , but I don't think this is what you want
10:24:20 <shapr> nostrand: Heh, I'm not convinced he knows Haskell that well.
10:24:24 <monochrom> I am not sure why you people have this fetish fascination with people who don't like haskell. They exist, and I agree to disagree with them, end of story. What more is there to discuss? Can we please move on and do real work?
10:24:33 <nostrand> shapr: haven't found so much criticism against Haskell, any links?
10:24:33 <ski> EvanCarroll : if we say `data Person = P {name :: Name,age :: Age}', then this, and the `P {name = ...,age = ...}' and `somePerson {name = ...,age = ...}' suggests that `name' and `age' (and their respective expressions) have types `Name' and `Age', respectively
10:24:34 <paolino> astroboy: return is not an handler
10:24:37 <ski> argh
10:24:37 <astroboy> paolino: maybe I just misunderstood how that monad works, is the logic behind my code correct?
10:24:49 <ski> s/EvanCarroll/EvanR-work/
10:24:54 <EvanR-work> nostrand: ive been collecting anti haskell propaganda for several months
10:24:57 <paolino> :t return
10:24:58 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:24:59 <EvanR-work> none of it is online though
10:25:07 <paolino> :t catchError
10:25:08 <lambdabot> forall (m :: * -> *) a e. (MonadError e m) => m a -> (e -> m a) -> m a
10:25:10 <nostrand> EvanR-work: then it doesn't exist ;)
10:25:23 <shapr> nostrand: Nothing that comes to mind immediately. But the basis of most interesting arguments is that non-strictness is either too expensive, or too hard to understand compositionally.
10:25:47 <shapr> nostrand: Other arguments are that Haskell is so unlike C that people will have difficulty learning Haskell.
10:25:48 <ski> EvanR-work : but, when we say `name somePerson' and `age somePerson', then suddenly `name' and `age' has type `Person -> Name' and `Person -> Age' instead .. this is schizophrenia, if you ask me
10:25:51 <EvanR-work> i thought lazy increases composibility
10:26:03 <astroboy> paolino: oh right, so I should have some function that accepts an error and returns something
10:26:06 <FunctorSalad> yeah me too EvanR-work 
10:26:14 <shapr> EvanR-work: To some degree yes, but it's hard to reason about overall laziness once you start to stick code together.
10:26:19 <nostrand> shapr: yeah, because C is very easy to learn...
10:26:29 <shapr> nostrand: hah, yes... I never have learned C well :-/
10:26:34 <paolino> atroboy, that is an exception handler, yes
10:26:41 <EvanR-work> ski: right
10:26:44 <EvanR-work> i didnt notice that
10:26:51 <nostrand> shapr: i never learned it at all =)
10:27:01 <astroboy> paolino: ok I put "\e -> return ()" and it works. I don't get what is the usefulness of handling the error in that way, since when you use the runErrorT you should get the error anyway
10:27:16 <proq> obj-C takes some time to learn compared to C, but that hasn't stopped hundreds of thousands of people
10:27:35 <paolino> astroboy: I don't know why I catch it
10:27:49 <paolino> s/I/you
10:27:56 <nostrand> sometimes i would like to have a dialect of Haskell which is strict and non-pure, wouldn't really be haskell though
10:28:09 <EvanR-work> C is very easy to learn??
10:28:14 <FunctorSalad> how about this? http://c2.com/cgi/wiki?HaskellLanguage       "* Sounds like it isn't a RealProgrammingLanguage"
10:28:17 <FunctorSalad> ;)
10:28:22 <ski> EvanR-work : if you go for a library approach a la functional references, lenses, fc-labels, accessors, then we scrap the field `name :: Name' view in favour of the `name :: Person :> Name' view, so this is a syntax-less approach (which is currently workable)
10:28:28 <proq> EvanR-work: to basic things, yes
10:28:33 <EvanR-work> people may have different definitions of learn for C and haskell
10:28:42 <shapr> nostrand: You should try writing one! Or maybe try F# or OCaml? I've heard they're interesting.
10:29:09 <EvanR-work> proq: you can write C code in IO pretty easily
10:29:31 <nostrand> shapr: yeha i know of O'Caml, but it's really annoying compared to Haskell(no typeclasses etc), så i rahter wrestle the monads =)
10:29:34 <EvanR-work> you can even use { } ; syntax ;)
10:29:46 <shapr> nostrand: I can understand that. I feel the same way.
10:30:04 <ski> EvanR-work : a syntax-ful approach could be to instead favour `data Person = .. { ... , name :: Name , ...} ..', but then, to access, we'd use `somePerson.name' (OO-style) or `#name somePerson' (the ML syntax) for accessing the fields
10:30:46 <nostrand> shapr: and i don't udnerstand how to use the interpreter in a good way. Whenever the source loads a module it won't work in the interpreter
10:31:34 <ski> EvanR-work : .. and making sure that one could update nested things, in a natural way
10:31:40 <EvanR-work> just type expressions to see them evaluated, if they evaluate to an IO action, it is executed. you can use do syntax to collect the result of an IO action
10:31:58 <nostrand> shapr: and the community around Haskell is pretty amazing =)
10:32:11 <EvanR-work> x <- launchMisslesAndCountRemaining
10:33:00 <EvanR-work> ski: meh, nested records doesnt appeal to me, with or without a special language to update leaves
10:33:23 <EvanR-work> it feels like microsoft word
10:33:35 <ski> EvanR-work : sometimes you want to factor common parts of datastructures
10:33:44 <EvanR-work> yes
10:33:53 <EvanR-work> so concatenation of records make sense
10:34:05 <EvanR-work> union1
10:34:08 <ski> not necessarily
10:34:32 <ski> you might want a `Foo' record which contains *two* `Bar' records, in two different fields, e.g.
10:34:38 <shapr> nostrand: I do very much enjoy the Haskell community.
10:34:50 <EvanR-work> ski: right, no i dont think i would
10:35:23 <EvanR-work> i look at these in php all day and they are pointless
10:35:45 <EvanR-work> all i see are opportunities to use algebraic data
10:35:50 <ski> i think it depends on the data
10:36:04 <EvanR-work> in particular i 'invented' anonymous data syntax
10:36:06 <ski> sometimes variantful data are appropriate, sometimes recordful
10:36:17 <ski> sometimes both would work, but trade-off differently
10:36:18 <EvanR-work> so you can define constructors inline if they are only used there
10:37:12 <ski> EvanR-work : yeah, that's often known as "light-weight variant types"
10:37:19 <ski> (e.g. OCaml has this)
10:37:23 <tonkman> is there any good haskell editor for windows
10:37:29 <sproingie> emacs
10:37:37 <tonkman> notepad++s color scheme sucks
10:37:52 <sproingie> if it's just the color scheme that's not hard to edit
10:38:07 <sproingie> emacs+flymake is freakin awesome
10:38:10 <tonkman> yeah I know, but im lazy as hsakell
10:38:26 <ski> find someone to force you ?
10:38:34 <sproingie> tonkman: seq changeColorScheme
10:38:41 <EvanR-work> tonkman: im into ed these days
10:39:05 <tonkman> when I had linux I used vim
10:39:08 <tonkman> vim was superior
10:39:19 <tonkman> when compared to notepad++
10:39:26 <EvanR-work> ed is superior
10:39:43 <sproingie> seq makeMeASandwich
10:40:08 <ski> @google standard editor
10:40:08 <lambdabot> http://www.gnu.org/fun/jokes/ed.msg.html
10:40:08 <lambdabot> Title: Ed, man! !man ed- GNU Project - Free Software Foundation (FSF)
10:40:47 <cba-isaac> Is there a Console.Print() equivalent in Haskell? Or what is the best way to go about dumping function states at each point during function execution
10:40:52 * ski doesn't recall lambdabot reporting titles (at least not the last few years) ..
10:41:01 <tonkman> print?
10:41:05 <ski> @hoogle trace
10:41:06 <lambdabot> Debug.Trace trace :: String -> a -> a
10:41:06 <lambdabot> Network.HTTP.Base TRACE :: RequestMethod
10:41:06 <lambdabot> module Debug.Trace
10:41:23 <ski> cba-isaac : if it's just for debugging, use `Debug.Trace.trace' to output strings
10:41:25 <sproingie> @src Debug.Trace.trace
10:41:26 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:41:32 <sproingie> @src trace
10:41:32 <lambdabot> trace string expr = unsafePerformIO $ do
10:41:32 <lambdabot>     hPutStrLn stderr string
10:41:32 <lambdabot>     return expr
10:42:09 <sproingie> unsafeLaunchMissiles $ do return expr
10:42:29 <EvanR-work> :t unsafePerformIO makeMeASandwich
10:42:30 <lambdabot> Not in scope: `unsafePerformIO'
10:42:30 <lambdabot> Not in scope: `makeMeASandwich'
10:42:36 <EvanR-work> Sandwich
10:42:57 <EvanR-work> pure (ly evil) sandwich
10:43:04 <EvanR-work> lunch
10:43:15 <ski> cba-isaac : oh .. and if you're already in `IO', you can of course use `print' or `putStr'/`putStrLn'
10:44:12 <cba-isaac> it seems like those are only for strings? does that work if I want to dump list contents?
10:45:13 <maurer_> cba-isaac: Then use print.
10:46:40 <ski> cba- .. *doh*
10:47:03 <ski> (was going to mention `trace (show ...) ...')
10:50:15 * hackagebot happstack-helpers 0.52 - Convenience functions for Happstack.  http://hackage.haskell.org/package/happstack-helpers-0.52 (ThomasHartman)
10:59:20 * hackagebot polynomial 0.6 - Polynomials  http://hackage.haskell.org/package/polynomial-0.6 (JamesCook)
11:23:20 <roconnor> that polynomial package looks nice
11:24:27 <kadoban> how can i get the code for prelude functions? like say i want to see how length is implemented?
11:24:45 <roconnor> @src lenght
11:24:45 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:24:53 <roconnor> @src length
11:24:53 <lambdabot> Source not found.
11:24:58 <roconnor> :(
11:25:00 <kadoban> hehe
11:25:32 <ccasin> kadoban: in the docs there is a little "Source" link to the right of functions
11:25:37 <ccasin> see:  http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html#v:length
11:25:54 <kadoban> ah, that'll work.  thanks much
11:26:40 <ccasin> In this particular case, the source shown is not especially enlightening
11:26:52 <ccasin> at least, in the sense that this is not what a normal haskell programmer would write
11:27:14 <sproingie> @src Prelude.length
11:27:14 <lambdabot> Source not found. You untyped fool!
11:27:19 <sproingie> blah
11:27:41 <roconnor> > let length = foldl' (const succ) 0 in length (replicate 6 undefined)
11:27:42 <lambdabot>   *Exception: Prelude.undefined
11:28:02 <roconnor> > let length = foldl' (flip const succ) 0 in length (replicate 6 undefined)
11:28:02 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
11:28:29 * hackagebot csound-expression 0.0.1 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.0.1 (AntonKholomiov)
11:41:07 <EvanR-work> why do compiler implementors insist on messages such as "Occurs check:"
11:41:14 <EvanR-work> do they think theyre funny?
11:41:29 <EvanR-work> use plain text
11:41:44 <Saizan> most early haskell users probably easily understood that
11:41:51 <nlogax> what would it be in plain text? 
11:41:55 <EvanR-work> no idea!
11:41:55 * geheimdienst doesn't
11:41:57 <nlogax> honest question, i have no idea what that means
11:41:59 <nlogax> :D
11:42:40 <Saizan> the occurs check is a part of the unification algorithm, when unifying a variable x with some term t, it checks that x doesn't occur in t
11:42:48 <Veinor> Occurs check probably means 'checking whether the type occurs in itself'
11:42:51 <Veinor> yeah
11:44:27 <EvanR-work> isnt that a case where you rename 
11:44:42 <Saizan> no
11:45:03 <Saizan> you're thinking of substitution
11:45:55 <EvanR-work> oh
11:46:15 <EvanR-work> there should be a down to earth presentation of the type checker
11:46:26 <Saizan> in some contexts is acceptable to omit the occurs check, e.g. prolog implementations do for the sake of performance, but here it's needed to avoid infinite types
11:47:46 <Saizan> learn a little of logic programming, then you can read the inference rules :)
11:47:59 <geheimdienst> Williard Pantomoff Occurs (1837-1901) was a politician and financier who drew up the "New Cheque Of Pennesylvania". After his death, it came to be referred to simply as the "Occurs Check", and is still in use today ...
11:48:33 <EvanR-work> lol
11:48:36 <nostrand> haha
11:48:46 <EvanR-work> Saizan: that violates the down to earth part
11:49:19 <Saizan> prolog is not that esoteric
11:50:56 <engla> in a newtype declaration like newtype Test a = Test a  where do I put constraints on a? (Eq a)
11:51:10 <engla> sorry for the basic question
11:51:21 <EvanR-work> maybe you shouldnt 
11:51:31 <EvanR-work> rather put constraints on the operations on Test
11:51:43 <engla> ok
11:52:01 <engla> yeah the interpreter says I should do it on >>= but I can't find the syntax to do that
11:52:06 <Saizan> you'll have to also put the constraints on the operations anyway
11:52:17 <engla> ok
11:52:36 <engla> I'm just programming stuff for the learn you a haskell.. tutorial 
11:52:40 <engla> which is really good
11:52:45 <Saizan> if that (>>=) is supposed to be the one from the Monad class you can't though
11:53:05 <EvanR-work> maybe hes making a monad transformer
11:53:10 <Saizan> if it's a standalone operator it's fine though
11:55:09 <engla> it's in the monad instance
11:55:30 <engla> in the tutorial there is an example for calculating probabilities "nondeterministically"
11:55:48 <engla> so to flatten stuff properly in the >>= operation I want to compare the elements
11:56:18 <Saizan> you won't be able to
11:57:09 <Saizan> the type signature of the method of Monad won't let you assume anything about the type arguments
11:57:46 <engla> ok my code is here, mostly from the tutorial: http://paste.pocoo.org/show/288030/
11:57:47 <Saizan> there are libs for so called "restricted monads" for when one needs that
11:57:59 <engla> I want to apply the flattensame  inside >>=
11:58:12 <engla> and the tutorial is here: http://learnyouahaskell.com/for-a-few-monads-more#making-monads
11:58:16 <engla> ok
11:58:19 <engla> so maybe it's not possible then
11:58:56 <Saizan> yeah, flatten is fine, but flattensame isn't
11:59:26 <Saizan> though you can apply flattensame manually to e.g. flipThree
11:59:36 <engla> yeah it works fine
12:00:05 <Saizan> this restriction is a bit unfortunate, but it also simplifies a lot of things
12:00:17 <engla> can I put a constraint on a in Prob a?
12:00:18 <engla> hm ok
12:00:36 <engla> yeah I'm learning as you understand, doing these excercises Im not so good with monads yet etc
12:00:58 <engla> it's not a trivial concept to understand (what it's good for)
12:03:24 <Saizan> http://www.haskell.org/haskellwiki/Monads_as_computation#Motivation <- here it's explicitly motivated
12:03:34 <Cale> :)
12:04:59 <Cale> engla: Basically, the monad class is a particular shape into which a lot of libraries fit. Recognising that something is a monad gives us all the stuff in Control.Monad for free. (As well as do-notation.)
12:11:05 <engla> mystifying. thanks for the help
12:11:38 <sproingie> unfortunately, no one can be told what Monad is.  you have to see it for yourself.
12:12:20 <Cale> engla: Well, this is just to suggest that perhaps the best way to understand what monads are is just to look at a lot of examples of monads.
12:12:54 <Cale> The abstraction in the middle is very simple, but also quite abstract.
12:13:03 <sproingie> abstract abstraction is abstract
12:13:37 <aristid> after all, monads are just monoids in the category of endofunctors
12:14:06 <Cale> That's actually not a terrible way to look at them, but you need to understand that terminology first ;)
12:14:25 <Cale> Which will probably carry you pretty far afield from Haskell :)
12:14:27 <sproingie> of course when you do understand the terminology, you don't need the explanation
12:15:34 <aristid> Cale: i don't really understand "category of endofunctors", but the parallel between Data.Monoid.Monoid and Monad became more obvious after looking at uncurry mappend
12:15:41 <Cale> I don't know about that. You could understand about monoid objects and monoidal categories and the monoidal category of endofunctors on a category without having been introduced to monads yet.
12:16:13 <Cale> Monads are easy to learn once you know that stuff (but that's not the easiest way to learn about monads)
12:16:33 <aristid> the easiest way is to learn examples of monads
12:16:38 <Cale> aristid: Do you know what a monoidal category is?
12:16:51 <aristid> Cale: no:)
12:18:01 <aristid> Cale: ok, a monoidal category seems to be a category with a functor similar to uncurry mappend :D
12:18:24 <aristid> or bifunctor? itsa complicated
12:18:25 <sproingie> the channel 9 talk on monads is very illustrative as to how they're monoids
12:18:30 <Cale> Okay, so it's a category with a bifunctor, usually written with the tensor product sign ⊗, which is like a generalised version of the Cartesian product, and it has an identity (up to isomorphism), which is like a stand-in for a one-element set.
12:18:47 <sproingie> it gets a little confusing when he talks about the a -> m b and starts erasing stuff
12:19:15 <sproingie> but rewatch it a couple times and it'll click
12:19:37 <Cale> So A ⊗ 1 ~= A, and (A ⊗ B) ⊗ C ~= A　⊗　(B　⊗　C), where the isomorphisms are canonical
12:19:38 <aristid> Cale: and with monads, the "generalised cartesian product" magically becomes functor composition
12:20:26 <Cale> Right, so the category of endofunctors on any given category (and natural transformations between them) is a monoidal category, where the tensor product is composition and the identity object is the identity functor.
12:20:41 <sproingie> i think we just hit the MEGO factor for newbies here :)
12:20:47 <Cale> and this is actually a strict monoidal category, the isomorphisms there are actually equalities
12:21:14 <EvanR-work> lego my mego
12:22:56 <Cale> and a monoid object in a monoidal category is an object M with arrows eta: 1 -> M and mu: M ⊗ M -> M, which make a couple of diagrams commute
12:23:47 <ski> Cale : re that "Monads_as_computation" link, i'd be happier if you used `=' rather than `==' when expressing the monad laws (since the class `Eq' is irrelevant to the discussion, we want semantic equality, here)
12:23:48 <Cale> If we take the monoidal category to be the category of sets, with the product being the Cartesian product, and 1 being an arbitrary one-element set, then this is just the same thing as a monoid.
12:24:07 <Cale> ski: Oh, I didn't realise that I had used ==
12:24:31 <RichardBarrell> Perhaps you actually want to use three-line =.
12:24:32 <aristid> Cale: and with monads, 1 is like the a in m a?
12:24:34 <Cale> Uh, weird.
12:24:43 <Cale> Maybe someone else edited this.
12:25:46 <litb> hello all
12:25:51 <litb> haskell is an ML language too, right?
12:25:52 <Cale> (Or maybe I was just not my usual self while writing it, I don't know)
12:26:06 <Cale> litb: ML is an ancestor of sorts, yeah.
12:26:22 <Cale> litb: Miranda is a closer relative.
12:26:47 <zecrazytux> hi
12:26:58 <litb> oh
12:27:29 <RichardBarrell> The type system is very ML-like, as is the syntax.
12:27:45 <RichardBarrell> The semantics differ in a few ways.
12:28:07 <monochrom> haskell is not an ml language. but haskell and ml are friends.
12:29:06 <RichardBarrell> ML is strictly evaluated - parameters to functions are evaluated before calling the function. Haskell is lazily evaluated - parameters are evaluated when they're needed.
12:30:03 <EvanR-work> is ocaml closer to ml than haskell?
12:30:10 <Cale> EvanCarroll: yes
12:30:19 <Cale> Er, EvanR-work 
12:30:24 <EvanR-work> >_<
12:30:27 <Veinor> > "ml" `isSuffixOf` "ocaml"
12:30:28 <lambdabot>   True
12:30:29 <Cale> Stupid tab completion ;)
12:30:31 <Veinor> > "ml" `isSuffixOf` "haskell"
12:30:32 <lambdabot>   False
12:31:01 <Cale> Tab completion should prioritise based on who talked more recently.
12:31:03 <RichardBarrell> The other big difference is that Haskell is pure, where ML isn't. In ML, you can perform I/O in functions. In Haskell, functions cannot do any I/O.
12:32:03 <mauke> Cale: it does in irssi AFAIK
12:32:15 <Cale> Yeah, instead, Haskell has a separate type whose values are descriptions of I/O to be performed.
12:32:50 <Cale> Ah, it turns out X-Chat has the option, but it wasn't the default setting.
12:32:51 <adarshaj> hey, I have a question, how do I extract Int out of (IO Int) ??
12:33:04 <Cale> adarshaj: Inside a do-block for another IO action
12:33:10 <mauke> adarshaj: why do you think IO Int contains an Int?
12:33:15 <Cale> If you write v <- x
12:33:22 <Cale> and x :: IO Int
12:33:25 <Cale> then v :: Int
12:33:35 <adarshaj> Cale: I did that, but won't work
12:33:51 <Cale> v <- x should be read as "run the action x, producing the result v"
12:34:06 <Cale> adarshaj: You can then use v in the remainder of the do-block
12:34:14 <Cale> and the do-block as a whole will be another IO action
12:34:26 <adarshaj> Cale: Oh! may be I am missing that!
12:34:33 <copumpkin> adarshaj: IO Int contains an Int no more than the string "int f() { return 5 + 6; } " contains an Int :)
12:35:01 <copumpkin> any cabal-install experts around? I am thoroughly confused
12:35:03 <adarshaj> copumpkin: oh, k.. I get it now.. 
12:35:15 <EvanR-work> adarshaj: wait did you really ask that or
12:35:23 <EvanR-work> did you read
12:35:30 <EvanR-work> @quote io
12:35:30 <lambdabot> ghc says: the eta-reduction property does not hold
12:35:36 <EvanR-work> dang where is it
12:36:00 <ski> (Cale : fwiw, i'd also s/(Monad m) =>/Monad m =>/, but ymmv ;)
12:36:05 <monochrom> You will soon accept that just because "Int" appears in a type doesn't mean you can extract an Int from that type.
12:36:31 <EvanR-work> Maybe Int
12:36:45 <EvanR-work> monochrom: is it true that you 'may' be able to extract an Int ;0
12:36:49 <copumpkin> (->) Int ()
12:37:00 <copumpkin> definitely can't get an Int out of that one
12:37:04 <monochrom> In fact with the infinite type "US_Economy = Money -> US_Economy", not only you can't extract money from it, but also you have to keep putting in money and it just asks for more.
12:37:08 <zecrazytux> I a newbie trying to approach Haskell... I read a some tutorials but they did not tell about structures like that:   Name { AnotherName = YetAnotherName, ... }... what is it ? I'm quite confused...
12:37:20 <adarshaj> monochrom: ha.. ha.. good one!
12:37:21 <mauke> zecrazytux: a record type
12:37:21 <c_wraith> zecrazytux, that's record syntax
12:37:30 <Saizan> copumpkin: what part confuses you?
12:37:57 <zecrazytux> mauke, c_wraith: thanks :) i'm RTFMing right now ;)
12:38:55 <copumpkin> Saizan: well, I installed GHC 7 RC2 for various reasons, and then when I tried cabal configure on the package I'm writing, it said it can't satisfy constraint 1.8.0.6 on cabal. In my .cabal file there's no mention of it, so I do cabal configure -v and see that it's passing my Setup.hs a hardcoded reference to 1.8.0.6. So I update to cabal-install HEAD and it still seems to be passing the 1.8.0.6 hardcoded cabal version for cabal configure
12:39:00 <copumpkin> and I can't find where in the source it's doing that :(
12:40:00 <Saizan> copumpkin: cabal --version ?
12:40:26 <copumpkin> Saizan: http://hpaste.org/41297/cabal_weirdness
12:40:55 <copumpkin> looks hardcoded?
12:42:24 <copumpkin> oh okay
12:42:30 <copumpkin> it was in my own dist folder
12:42:37 <copumpkin> but I couldn't run cabal clean
12:42:49 <EvanR-work> is ocaml closer to ml than haskell is to miranda!?
12:43:27 <monochrom> undecidable
12:43:42 <EvanR-work> NP complete
12:43:45 <Veinor> compute the levenshtein distances
12:46:55 <EvanR-work> is there a histogram function
12:47:11 <EvanR-work> Eq a => [a] -> Map a Integer
12:47:33 <EvanR-work> guess it needs to be Ord for the Ma
12:48:03 <Zao> EvanR-work: Insert into a map with default 1, otherwise increment?
12:48:11 <mauke> @hoogle insertWith
12:48:11 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
12:48:11 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
12:48:11 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
12:48:19 <Zao> Assuming that you want an integer-wide bucket.
12:48:40 <mauke> foldl' (\x -> M.insertWith (+) x 1) M.empty
12:48:43 <mauke> :t foldl' (\x -> M.insertWith (+) x 1) M.empty
12:48:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = M.Map a a1
12:48:45 <lambdabot>       Expected type: a
12:48:45 <lambdabot>       Inferred type: M.Map a a1
12:48:45 <Saizan> ?type M.fromListWith (+) . flip zip [1,1..]
12:48:46 <lambdabot> forall a k. (Num a, Ord k, Enum a) => [k] -> M.Map k a
12:49:05 <mauke> :t foldl' (\z x -> M.insertWith (+) x 1 z) M.empty
12:49:06 <lambdabot> forall b a. (Num a, Ord b) => [b] -> M.Map b a
12:49:15 <monochrom> change insertWith to insertWith' if you like
12:49:18 <ski> @type Data.Array.IArray.accumArray  -- hm
12:49:20 <lambdabot> forall e e' i (a :: * -> * -> *). (Data.Array.Base.IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
12:49:49 <EvanR-work> amazing
12:50:13 <EvanR-work> @faq can haskell count stuff
12:50:13 <lambdabot> The answer is: Yes! Haskell can do that.
12:50:20 <monochrom> histogram = M.toAscList . foldl' (\x -> M.insertWith' (+) x 1) M.empty  will appear in the next version of Prelude.Twitter
12:50:38 <mauke> that looks like a type error
12:50:42 <litb> is the   Foo => syntax just sugar displayed by the demangler, or is it real haskell code?
12:51:11 <EvanR-work> if you put a signature, and k needs to be in Ord, then you need to be Ord k =>
12:51:21 <EvanR-work> need to put Ord k =>
12:51:27 <litb> i mean.   forall b a . (Foo a, Baz b) =>  ... things
12:51:38 <ski> "demangler" ?
12:51:47 <monochrom> "(Foo a, Baz b) => " is real haskell code
12:51:50 <EvanR-work> the benevolent demangler
12:52:13 <ski> litb : the `forall b a . ' part there is an extension (and GHC shouldn't present that, unless it's really needed)
12:52:14 <EvanR-work> an interesting name for the compiler
12:52:30 <litb> EvanR-work: does a   Ord k => f :: k -> k   mean that  i can only apply "f" to Ords ?
12:52:41 <EvanR-work> yes
12:52:42 <litb> or does it mean there is some more type checking done when defining f?
12:52:48 <EvanR-work> f :: Ord k => k -> k
12:52:54 <litb> oh
12:53:05 <EvanR-work> @src Ord
12:53:05 <lambdabot> class  (Eq a) => Ord a  where
12:53:05 <lambdabot>     compare      :: a -> a -> Ordering
12:53:06 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:53:06 <lambdabot>     max, min         :: a -> a -> a
12:53:09 <kmc> litb, you can put unnecessary class constraints on a function
12:53:17 <kmc> :t let f :: (Ord a) => a -> a; f x = x in f
12:53:18 <lambdabot> forall a. (Ord a) => a -> a
12:53:23 <litb> ski: oh
12:53:34 <kmc> if you leave off a necessary constraint, it's an error
12:53:40 <kmc> but if you leave off the signature entirely, it wil be inferred
12:53:52 <litb> so that says  "given an a that is a Eq, Ord a is a ..." 
12:54:21 <EvanR-work> then a is in Ord if a has 
12:54:24 <EvanR-work> all those operations
12:54:37 <ski> litb : "for an `a' to be `Ord', it has to be `Eq' first, and then it also needs to support the following : .."
12:54:49 <ymasory> hi. why isn't 'ord' in scope automatically? isn't that how i convert a Char into an Int?
12:55:02 <EvanR-work> Data.Char
12:55:05 <litb> oh so signatured functions are't inferred?
12:55:07 <EvanR-work> because its often not needed
12:55:17 <ski> ymasory : `import Data.Char'
12:55:20 <kmc> ymasory, you can use fromEnum
12:55:28 <kmc> ord is just a type-restriction of fromEnum
12:55:28 <litb> or is it that everything that is mentioned prior to the => isn't inferred, and everything else is inferred?
12:55:42 <mauke> litb: what do you mean by "inferred"?
12:56:04 <kmc> litb, if you put a signature on a function, the compiler will check that what you wrote matches what it infers
12:56:11 <kmc> basically
12:56:16 <litb> mauke: hmm dunno 
12:56:18 <kmc> this is true both for class constraints and for the rest of the type
12:56:22 <ymasory> ski, kmc: thank you
12:56:42 <ski> litb : either you give a whole type signature, in which case it'd better be correct (but doesn't need to be as general as possible); or you don't give a type signature, in which case it will be inferred (except a few special cases that really require an explicit type signature)
12:57:03 <nus> litb, classes are not types.
12:58:29 * ski sometimes thinks that one ought to be able to say things like `IArray :: (* -> * -> *) -> * -> constraint'
12:59:13 <ski> (.. we already allow partial application of classes, in `deriving' clauses)
12:59:53 <litb> nus: oh
13:00:06 <litb> classes are meta types i think
13:00:16 <ski> not really
13:00:21 <ski> kinds are "meta types"
13:00:34 <kmc> classes are sets of types, sort of
13:00:49 <ski> classes are collections of types, or better, relations over types
13:00:50 <kmc> Int, Char, Bool, ... ∈ Eq
13:01:11 <litb> oh
13:01:27 <kmc> and the proof that Int ∈ Eq is a function (==) :: Int -> Int -> Bool
13:01:28 <kmc> which we can use
13:01:51 <litb> i think this is provided by an instance declaration
13:01:56 <kmc> yes
13:01:56 <ski> yes
13:03:24 <litb> so if i write   foo x y = x * y   it can't know what class this is about. what if multiple classes have defined "op*". how does it infere that? will it build a list of possible sets, and choose the correct set once the function "f" is actually applied?
13:03:33 <litb> s,f,foo,
13:03:37 <kmc> 'what if multiple classes have defined "op*"' -- they can't
13:03:45 <kmc> or rather, it would be an ambiguity error when you use (*)
13:03:59 <kmc> just like if two modules defined a function f and you import both
13:04:01 <kmc> you'd have to qualify
13:04:02 <kwuxalot> Hmm, can't join #python... I presume someone here knows what the difference between putting an assignment in the class body as opposed to an __init__ method?
13:04:08 <litb> oh
13:04:23 <kmc> kwuxalot, i'd guess that in the former case, you get one variable shared by all the instances
13:04:32 <kmc> but you might want to join #python.  why can't you?
13:04:44 <kwuxalot> kmc: it's +r... but I don't know how to get permission
13:04:53 <kmc> kwuxalot, probably by registering your nick with nickserv
13:04:57 <kwuxalot> It is
13:05:02 <kmc> ok
13:05:08 <EvanR-work> litb: different classes can define the same operation as the same time. different data types can define the same constructor at the same time. different modules can have their same-named functions imported at the same time unqualified
13:05:14 <EvanR-work> ...
13:05:25 <EvanR-work> i just said can instead of cant three times in a row
13:05:29 <engla> (reading backlog) I love how you guys followed up my "monads are mysterious" with totally geeky conversations about category over monoids and other completely opaque terminology
13:05:32 <mauke> kwuxalot: you're not identified
13:05:54 <EvanR-work> i give up on chat, forever
13:05:59 <litb> i thought now you would say "but using them results in ambiguity" xD
13:06:13 <proq> kwuxalot: you have to type /msg nickserv identify your-password
13:06:16 <kwuxalot> mauke: yeah I just realized that. I should make irssi log me in automatically
13:06:17 <kmc> engla, yeah, well don't confuse the existence of some math with the idea that the math is necessary for practical programming
13:06:34 <litb> EvanR-work: i see now
13:06:57 <mauke> kwuxalot: just set a server password
13:07:17 <litb> so it inferres the most generic class for a given operator application. if classes can be derived from each other, this would need a topological sort, i think
13:07:55 <EvanR-work> theres only one operator at a given time
13:07:59 <EvanR-work> with that name
13:08:01 <kmc> each operator belongs to one specific class
13:08:05 <kmc> (*) belongs to Num
13:08:10 <kmc> (==) belongs to Eq
13:08:15 <EvanR-work> associated with one class at a time
13:08:32 <litb> ah
13:08:40 <EvanR-work> dont redefine the standard ones and youre good
13:08:40 <monochrom> classes cannot be derived from each other. when you use (*) you already ask for Num. this is not c++, no guesswork needed.
13:08:42 <engla> I guess I will understand later but.. there are like two levels of haskell. I mean, the basic list operations are really useful and handy. Then all of them (filter, map, fold etc) are duplicated on a higher plane for Monads. does haskell need both?
13:09:01 <litb> if i use == and * both in the sam function on a and b, it alsoimplies both Num and Eq then, i think
13:09:10 <kmc> engla, you could write code using the Identity monad, but the syntax would be uglier
13:09:14 <litb> instead of implying Num only?
13:09:25 <monochrom> @type \x -> x==x && x*x==x
13:09:25 <lambdabot> forall a. (Num a) => a -> Bool
13:09:33 <kmc> litb, it implies Num, and everything in Num is already in Eq, because the definition of Num says so
13:09:34 <kmc> @src Num
13:09:34 <lambdabot> class  (Eq a, Show a) => Num a  where
13:09:34 <lambdabot>     (+), (-), (*)           :: a -> a -> a
13:09:34 <lambdabot>     negate, abs, signum     :: a -> a
13:09:34 <lambdabot>     fromInteger             :: Integer -> a
13:09:34 <EvanR-work> litb: its just additional constraints
13:09:40 <kmc> see first line
13:09:51 <litb> oh i see now. this makes sense!
13:09:54 <kmc> note also that whether something is an operator syntactically (composed of symbols, used infix), and whether something is overloaded in a class, are two independent properties
13:10:13 <kmc> 'abs' is written as a normal prefix function, but is overloaded
13:10:22 <kmc> (++) is an operator but not in a class
13:10:31 <litb> i coded with haskell long ago but forgot so many things
13:10:39 <monochrom> @type \x -> x == read "h"
13:10:40 <lambdabot> forall a. (Read a, Eq a) => a -> Bool
13:11:11 <litb> wait. why does  x need to be Readable ?
13:11:22 <monochrom> because of read
13:11:32 <EvanR-work> :t read
13:11:33 <lambdabot> forall a. (Read a) => String -> a
13:11:33 <litb> doesn't it just compare x with a string ?
13:11:51 <monochrom> is read "h" a string?
13:11:55 <litb> wow i see now!
13:12:06 <EvanR-work> said the blind man
13:12:08 <litb> it asks x to convert to a [Char]
13:12:16 <monochrom> no
13:12:37 <Watermind> is there a name for the kind of recurion (co-recursion?) you do in  fibs = 1 : 1 : zipWith (+) fibs (tail fibs)  ?
13:12:52 <EvanR-work> tree recursion
13:12:59 <Watermind> thanks EvanR-work
13:13:09 <EvanR-work> i almost just made that up
13:13:33 <litb> @code Read
13:13:33 <lambdabot> Maybe you meant: more todo vote
13:13:37 <EvanR-work> i saw that in C books under 'double recursion'
13:13:42 <monochrom> just say general recursion or general co-recursion
13:13:44 <litb> @src Read
13:13:44 <lambdabot> class Read a where
13:13:44 <lambdabot>   readsPrec    :: Int -> ReadS a
13:13:44 <lambdabot>   readList     :: ReadS [a]
13:13:44 <lambdabot>   readPrec     :: ReadPrec a
13:13:44 <lambdabot>   readListPrec :: ReadPrec [a]
13:13:54 <ski> Watermind : i suppose you might call it "data recursion"
13:14:01 <litb> wow i had no idea
13:14:12 <EvanR-work> @src read
13:14:12 <lambdabot> read s = either error id (readEither s)
13:14:12 <bos> Watermind: it's corecursion
13:14:19 <ski> EvanR-work : i think "double recursion" is something else
13:14:21 <nus> litb, guesswork is good *after* you read textbooks.
13:14:23 <litb> i thought Show is for  foo -> string and read is from string -> foo
13:14:26 <EvanR-work> @src readEither
13:14:26 <lambdabot> Source not found. Wrong!  You cheating scum!
13:14:35 <EvanR-work> ski: what else
13:14:37 <litb> ah yes, *that* was the direction! oh god i'm blind
13:14:51 <Watermind> EvanR-work: ah that is not what I meant... the fact that it is double, I was refering to the list being defined from itself, as in   ones = 1:  ones, sorry I was not very specific
13:15:09 <EvanR-work> thats just recursion
13:15:11 <Watermind> ski: I see
13:15:30 <litb> nus: oh i see now -.- i have the hutton "programming in haskell" book on my shelf
13:15:43 <litb> i should read it for real. 
13:16:04 <Watermind> bos: I thought it would also be corecursion if you were using, say, an integer seed to generate a list... is it?
13:16:31 <mee> Watermind: fyi, in Bird/Moor, recursion like Num = Zero | succ (Num) is referred to as 'structural recursion', but I'm not sure if that's applicable to your example
13:16:57 <ski> mee : it doesn't
13:17:18 <Watermind> EvanR-work: yeap, but I was wondering if there were that was used when a structure is defined by recursion to itself
13:17:38 <EvanR-work> bottomless data!
13:18:09 * ski suggests "data recursion"
13:18:11 <mee> ski: ah. thanks
13:18:16 <Watermind> ski: yeap sounds good
13:18:20 <ski> "corecursion" or "coinduction" is also sensible
13:18:28 <ski> (as bos suggested)
13:19:21 <ski> EvanR-work : <http://en.wikipedia.org/wiki/Double_recursion>
13:19:45 <Watermind> ski: I am bit confused about the exact meaning of corecursion though, for instance    f n xs = n : f (n+1) xs ... would that be corecursion ?
13:19:54 <ski> that's basically doing well-founded recursion on a lexicographically ordered pair of naturals
13:20:25 <monochrom> too many names and too few notions
13:20:30 <Watermind> :S
13:20:56 <monochrom> ski means double recursion is well-founded recursion on a lexicographically ordered pair of naturals
13:21:01 <ski> Watermind : i think so. but it wouldn't be "data recursion", apart from the sense in which functions are data
13:21:13 <Watermind> ski: exactly
13:21:57 <EvanR-work> data is like functions
13:22:21 <EvanR-work> new concept
13:25:41 <ski> mee : to be more helpful, "structural recursion" is when you define a recursive data type like e.g. `data Tree a = Leaf a | Branch (Tree a) (Tree a)' and then define a function `f (Leaf a) = ..a..; f (Branch l r) = ..(f l)..(f r)..'
13:28:42 <b0fh_ua> Hello! Can somebody please help me with this issue: http://pastebin.com/ybFyYyPy
13:29:19 <bos> b0fh_ua: you have two libraries using different, incompatible versions of parsec
13:29:20 <litb> pattern matching recursion
13:29:27 <mee> ski: oh, the name makes more sense than I realized
13:29:33 <b0fh_ua> so what is the solution?
13:30:07 <b0fh_ua> how to force ghc to use parsec 2.1 ?
13:30:28 <HaskellElephant> Have you guys seen the video from Haskell Implementor's workshop by Ben Lippmeier, where he wishes that he would someday be able to pick up a piece of software, like it, and afterwords be surprised to see that it is made with Haskell  ( rather then say "Oh wow look, software made with Haskell!".) Well that just happened to me and I wanted to share with you, that lo and Behold Hedgewars has made their server using Haskell!! I didn't know, but there
13:30:37 <HaskellElephant> http://code.google.com/p/hedgewars/source/browse/#hg/gameServer%3Fstate%3Dclosed
13:30:39 <monochrom> imperative way (setting global variables): ghc-pkg hide parsec-3.xxx  you have to find out and fill in xxx
13:31:36 <b0fh_ua> doesn't make any sense - what if I want to use version 3.1 later?
13:31:46 <monochrom> ghc-pkg expose
13:31:51 <b0fh_ua> and why does cabal uses version 2.1 ?
13:32:05 <monochrom> pseudo-question
13:32:16 <kadoban> my computer grinds to a halt if i do "foldl (\x y -> x + 1) 0 [1..]"  i think i know why, but my real question is, how can i just have it give up instead of using an infinite amount of memory?  ulimit (on linux) doesn't seem to be working...
13:32:36 <mauke> ulimit works fine here
13:32:40 <monochrom> there are also functional ways (no setting mutable variables) but they require more typing.
13:33:32 <kadoban> mauke: well damn, maybe i'm using it wrong...man page for it sure blows
13:33:59 <monochrom> the functional ways involve "ghc -package ..." or writing your myproject.cabal file
13:34:49 <monochrom> actually ghc -hide-package parsec-3.xxx may do. (similarly ghci)
13:36:38 * hackagebot csound-expression 0.0.2 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.0.2 (AntonKholomiov)
13:41:47 <bos> kadoban: you can manually set a limit on heap and stack size using ghc runtime options
13:45:28 <kadoban> bos: oh, you can?  do you know the options offhand? i didn't see them in the man page.  got ulimit working, but that'd be preferable
13:45:55 <zecrazytux> to access a field from a record, that fieldname(recordinstance), right ?
13:46:01 <bos> kadoban: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html
13:46:07 <kadoban> ty
13:46:39 <bos> kadoban: look for "-K" and "-M"
13:47:36 <sipa> zecrazytux: just fieldname record
13:47:56 <sipa> the fieldname is a function that extracts that value from the record
13:48:13 <kadoban> cool, works great
13:50:23 <zecrazytux> i'm lost :'(
13:51:10 <EvanR-work> zecrazytux: you dont need parens
13:51:42 <EvanR-work> and instance is terminology related to type classes, not record values
13:54:03 <engla> Cale: ah, so you wrote the text about monads that you linked me to. very nice!
13:56:28 <Cale> engla: Yeah, that someone else happened to link you to just before I showed up actually ;)
13:56:30 <joe3> let write _ = appendFile "test" "a" in mapM_ write $ [1..4000]
13:56:34 <joe3> > let write _ = appendFile "test" "a" in mapM_ write $ [1..4000]
13:56:35 <lambdabot>   <IO ()>
13:56:42 <joe3> is there a better way to do the above?
13:56:59 <joe3> i tried mapM_ (appendFile "test" "a") $ [1 .. 4000]
13:57:10 <joe3> but get a type error
13:57:14 <joe3> > mapM_ (appendFile "test" "a") $ [1 .. 4000]
13:57:15 <lambdabot>   Couldn't match expected type `a -> m b'
13:57:15 <lambdabot>         against inferred type `GHC....
13:57:39 <monochrom> appendFile "test" (replicate 4000 'a')
13:57:50 <zecrazytux> EvanR-work: yes, I understood that you told me :) - but I don't figure out how to use the cmdargs module. It seems to me that it returns a record, but I can't print a field 
13:58:07 <joe3> monochrom: cool, thanks.
13:58:19 <EvanR-work> zecrazytux: well, do you have the documentation for the record
13:58:25 <EvanR-work> print (fieldName record)
13:58:49 <EvanR-work> joe3: i would do forM_
13:59:30 <EvanR-work> and i would open a file once before and use it
14:00:31 <joe3> EvanR-work: sounds good, thanks.
14:00:34 <zecrazytux> EvanR-work: thank you very much !
14:00:52 <zecrazytux> EvanR-work: I was missing the ()
14:01:15 <zecrazytux> well, I put them at the wrong place
14:01:59 <zecrazytux> but as the compiler does not raise a syntaxic error but a type mismatch error, I couldn't figure it out
14:03:01 <EvanR-work> zecrazytux: in cases like that try the simplest possible expressions in the interpreter, and figure out the types yourself before hand and make sure the compiler agrees
14:03:13 <EvanR-work> if it doesnt, figure out what you dont understand
14:03:19 <Cheery> hm.
14:03:26 <EvanR-work> you can also ask it what the types are
14:03:30 <Cheery> miranda code looks quite similar to haskell
14:03:51 <stepcut> Cheery: I think you mean Haskell code looks quite similar to Miranda
14:04:06 <EvanR-work> yeah that miranda is such a ripoff
14:04:27 <Cheery> stepcut: well I meant it commutative.
14:04:57 <monochrom> source code looks quite similar to ascii
14:05:18 <paolino> -XUnicodeSyntax
14:06:00 <Cheery> EvanR-work: miranda is that similar language?
14:06:34 <Philippa> my code doesn't usually look much like miranda code
14:06:48 * hackagebot darcs-fastconvert 0.2 - Import/export git fast-import streams to/from darcs.  http://hackage.haskell.org/package/darcs-fastconvert-0.2 (PetrRockai)
14:06:57 <EvanR-work> miranda was a proprietary lazy functional language which haskell is based on
14:07:18 <Philippa> though not the only language that haskell derives from by any means
14:07:36 <monochrom> people keep forgetting gofer
14:07:41 <Philippa> IIRC, it was the proximal ancestor for one of the two styles that the syntax deliberately lets you interleave
14:07:50 <Cheery> well the first example I saw is exactly like haskell
14:07:52 <Philippa> I forget what gofer's exact relationship to haskell is, it's been complex :-)
14:08:18 <Philippa> miranda didn't have monads, and I write a lot of monadic-or-applicative code because I've got a lot of good use cases for a bit of careful embedding
14:08:43 <EvanR-work> did miranda have side effects?
14:08:48 <kmc> does miranda have type classes?
14:08:51 <edwardk> gofer started as an educational haskell
14:08:53 <Cheery> Philippa: monads are just a way to bring in side-effectful code.
14:09:08 <kmc> Cheery, that's not an accurate description of monads in Haskell...
14:09:10 <edwardk> kmc: nah, type classes were a wadler innovation during the haskell design process
14:09:13 <kmc> ok
14:09:18 <Cheery> I remember they were rather simple too.
14:09:40 <Cheery> kmc: ah. I consfuse IO monad and monads then. :)
14:09:44 <kmc> yeah Cheery
14:09:50 <ketil> Hm - haskell didn't have monads either, early on, did it? I thought "interact" was the way to do IO, but maybe that was Miranda or Gofer?
14:10:09 <Philippa> Cheery: with respect, no they're not
14:10:10 <lispy1> ketil: IIRC, before monads we had CPS
14:10:40 <Cheery> Philippa and all. so what's monad purpose?
14:10:50 <kmc> Cheery, the IO type represents descriptions of IO to perform at a later stage.  you need an API for gluing together such descriptions.  it so happens that this API is useful for lots of other things, and the generic API is named 'monad'
14:10:56 <Philippa> Whatever you want to use them for, duh :-)
14:11:04 <kmc> but the fact that IO is a monad is secondary
14:11:05 * ski thinks monads is a way to bring in effectful code ..
14:11:12 <Philippa> but mostly, they're a nice structure to build an embedded language around. For example, the language of IO, or a constraint language
14:11:14 <Cheery> Philippa: I told purpose, not where I can use them. :)
14:11:20 <kmc> you could do IO in essentially the way it's done in Haskell, without ever noticing that there's this generic API
14:11:45 * ketil thinks monads is computation in a context.
14:11:48 <kmc> IO is an atypical example of a monad, and has lots of unusual properties
14:12:04 <edwardk> miranda lacks side effects -- in theory. in practice, the unix api has a bunch of stuff like system :: [char] -> ([char], [char], num)
14:12:22 <edwardk> http://www.cs.kent.ac.uk/people/staff/dat/miranda/manual/31/1.html
14:12:32 <monochrom> People waste too much time on "original" purpose / intention.
14:12:39 <Philippa> ski: effectful from which POV, though? Reader is perfectly pure...
14:13:07 <ski> Philippa : "effectful" as opposed to "*side*-effectful"
14:13:19 <Philippa> right. I embed stuff that can reasonably be described as pure from the right angle and which is most sensibly viewed as an embedded language /rather/ than as a bunch of effects
14:13:19 <Cheery> I remember something like that monad was a container, but I remember that was just a half-truth.
14:13:20 <monochrom> Not even today's state of Haskell (both language and community) was the "original" purpose.
14:13:36 <kmc> Cheery, don't focus on "what is Monad, really"
14:13:38 <Cheery> anyway seems like programming haskell doesn't require knowing what a monad is.
14:13:38 <kmc> learn the use cases
14:13:39 <Philippa> monochrom: a long, long way from it, yeah. Especially re monads
14:13:47 <kmc> then you will see what they have in common
14:13:53 <ski> Philippa : ok. is there a difference ?
14:13:58 <kmc> which is a very general sort of structure, not much to grab onto
14:13:59 <edwardk> besides "IO is not a monad" ;)
14:14:40 <Philippa> ski: it can make a big difference if you're getting your head around a constraint system instead of just unifying everywhere :-)
14:14:43 <ski> (well, `seq' is not playing nice ..)
14:14:46 <kmc> some monads are containers, like Maybe and []
14:15:00 <Cheery> kmc: I gotten its a generic concept. :) and hard to explain. maybe thats all what I need to remember about it now.
14:15:10 <Philippa> edwardk: I suspect someone'll find a fair way to say IO is not not a monad, too
14:15:17 <kmc> it's hard to explain because people expect there to be more than there is
14:15:23 <ski> Philippa : if you're arguing for having a "declarative" semantics of the system, rather than just an operational one, i'm all for that
14:15:24 <edwardk> Philippa: =)
14:15:26 <kmc> a monad is anything implementing the Monad interface
14:15:44 <EvanR-work> i dont see Maybe as a container
14:15:54 <edwardk> kmc: with or without the laws?
14:15:59 <Philippa> ...give or take. There's a lot of room for quibbling about the monad laws and what they should use as equality
14:16:07 <EvanR-work> if thats a container, then everything is a container
14:16:15 <monochrom> @quote really.*array
14:16:16 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
14:16:17 <danharaj> 1 + X
14:16:21 <danharaj> totally a container :p
14:16:21 <kmc> with the laws, but in practice i don't care too much aboutthem
14:16:26 <edwardk> EvanR-work: hence the power of functors!
14:16:29 <EvanR-work> Reader is a container holding a function that takes a context and produces a value in that context
14:16:40 <Philippa> edwardk: there're plenty of sensible uses for things that're monads given certain preconditions or up to certain operations, too
14:16:51 <kmc> an approximate definition is "a monad is anything implementing (>>=)"
14:16:51 <sproingie> APL on the other hand does dare to ask ask "what are arrays, really"
14:16:53 <edwardk> Philippa: sure. i use Omega all the time
14:16:54 <EvanR-work> Maybe >>= is a control structure
14:17:08 <danharaj> Well >>= in general is a control structure
14:17:20 <danharaj> but it can be seen as being determined by the structure of a container type.
14:17:27 <EvanR-work> >>= hides many moving parts!
14:17:34 <sproingie> Reader is a context around a function that produces a new value in that context
14:17:34 <Philippa> Cheery: it can be useful if you do find a sufficiently general explanation, but only if it really works for you. Tbh, I find the insistance that you shouldn't find one a bit annoying, but it shouldn't be the first thing you do unless you get lucky and someone hands you one that works for you right there and then
14:17:37 <monochrom> don't forget to return
14:17:49 <sproingie> which is pretty much how to describe any monad
14:18:14 <kmc> yeah, and Cheery if you're looking for an explanation of "what are monads really", besure to first read:
14:18:17 <kmc> @where burrito
14:18:17 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
14:18:24 <Cheery> Philippa: yeah. I think worrying too much about what is a monad sort of throws you out of coding haskell
14:18:29 <kmc> yep
14:18:32 <sproingie> actually just read LYAH which describes them well
14:18:43 <danharaj> The best way to learn anything is to use it.
14:18:48 <EvanR-work> containers sounds imperative
14:18:49 <monochrom> @quote really.*array
14:18:50 <lambdabot> nlogax says: because people don't go "but what are arrays, *really*???" about JS or whatever. i can use monads, i can use JS arrays..
14:19:00 <EvanR-work> since you often cant 'take out' or 'put in' 'containers'
14:19:00 <monochrom> (to repeat)
14:19:01 <sproingie> LYAH takes its sweet time getting to monads, but by the time you get there you wonder what the fuss was about
14:19:04 <Philippa> EvanR-work: that's because you're used to hearing it in a context like Java where it means "mutable data structure"
14:19:45 <EvanR-work> people do consider the question of 'what are js arrays really' in ##javascript
14:20:03 <monochrom> that is sad. or hilarious.
14:20:07 <sproingie> APL also treats arrays in pretty unusual ways
14:20:29 <EvanR-work> it doesnt help that half of 'arrays' in js are really objects with fields labeled as indexes
14:20:39 <edwardk> yeah i was going to say, 'what is an array' is a fairly fundamental thing in javascript. ;) since they weren't in the original language, and were sort of an ad hoc extension
14:20:49 <monochrom> the last thing you want to do is to ask "what are ___, really?" of an OO language, really.
14:21:06 <Philippa> EvanR-work: a bit like what's an array in C, only not?
14:21:08 <EvanR-work> c2wiki confirms that
14:21:17 <sproingie> Philippa: it's a pointer except when it's not
14:21:25 <Philippa> monochrom: especially not "what are objects, really?"
14:21:39 <edwardk> especially since you index them with the numerical value type... that is actually always a float, which is somewhat disturbing, and the length property is somewhat magical
14:21:48 <sproingie> C is the language that lets you do 2[foo]
14:22:19 <Philippa> yeah, with results that're possibly much nastier than 0[foo]
14:22:48 <sproingie> under the surface it ain't much more typed than forth
14:23:03 <EvanR-work> 2 is an array
14:23:11 <EvanR-work> in C there is one data structure: ...
14:23:12 <mauke> C arrays aren't pointers :-(
14:23:20 <sproingie> mauke: until you pass them
14:23:26 <mauke> sproingie: no
14:23:36 <mauke> function calls are irrelevant
14:23:38 <mauke> this is C
14:23:46 <sproingie> madness?  this is C!
14:24:00 <monochrom> @quote monochrom einstein
14:24:00 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
14:24:16 <sproingie> doh
14:24:39 <Cheery> huh?
14:24:48 <Cheery> BLASHEMY!
14:25:02 <Cheery> (sorry if misspelled)
14:25:15 <sproingie> blashemy, eh?
14:25:26 <paolino> miss pelled
14:25:27 <Cheery> if I believe that then cows fly.
14:25:38 <Cheery> ;)
14:25:42 <mauke> flies cow
14:26:08 * Cheery 's coding the catapult
14:26:11 <Cheery> just in case.
14:26:27 <EvanR-work> we need to break the C barrier
14:26:39 <sproingie> jette le vache!
14:26:40 <Cheery> still not done so?
14:26:42 <EvanR-work> with OS2 Warp
14:26:49 <Cheery> I thought ghc were only 10x away from C barrier
14:26:58 <Cheery> .. 5 years ago
14:27:24 <Cheery> youre still slower than C?
14:28:14 <dobblego> class N f where plusAssociative :: f a -> f a -> f a -- what is the name of this without the zero, monad,applicative constraint? semigroupM?
14:28:35 <mauke> magma?
14:30:06 <paolino> @src Monoid
14:30:07 <lambdabot> class Monoid a where
14:30:07 <lambdabot>     mempty  :: a
14:30:07 <lambdabot>     mappend :: a -> a -> a
14:30:07 <lambdabot>     mconcat :: [a] -> a
14:30:36 <sproingie> magma, the solution to kittens and nobles and elves!
14:30:40 <EvanR-work> a magma is a less fully featured lava
14:31:15 <wjt> Does anyone know why Gtk2HS contains a fork of c2hs?
14:31:16 <Cheery> sproingie: thought magma only works on nobles
14:31:19 <Cheery> kittens climb up
14:31:23 <sproingie> i prefer drowning rooms for nobles
14:31:33 <Cheery> elves do something tricky and woosh
14:31:43 <dobblego> elves it is, thanks
14:31:43 <sproingie> Cheery: dwarf fortress reference
14:32:19 <sproingie> just put your trading post on your obsidian farm
14:33:16 <sproingie> the great thing about noble drowning rooms is that the one job nobles will do is pull levers.  so you assign them their own suicide lever.
14:35:11 <dcoutts__> wjt: yes, historical reasons, not especially interesting. I can tell you the details if you're interested (or if you want to fix it)
14:38:00 <xplo99> hello all
14:38:15 <dobblego> class N f where plusAssoc :: f a -> f a -> f a; point :: a -> f a
14:38:27 <dobblego> !seen edwardk 
14:39:03 <ski> preflex: xseen edwardk
14:39:04 <preflex>  edwardk was last seen on freenode/#haskell 17 minutes and 25 seconds ago, saying: especially since you index them with the numerical value type... that is actually always a float, which is somewhat disturbing, and the length property is somewhat magical
14:39:48 <dobblego> edwardk, what is the name (category-extras?) of this type-class class N f where plusAssoc :: f a -> f a -> f a; point :: a -> f a
14:40:31 * ski wonders which laws dobblego imagines should hold, there ..
14:41:30 <dobblego> associativity for plus and something else between point and plus that requires some caffeine
14:41:36 <dobblego> the caffeine law if you will
14:42:14 <ski>   plusAssoc (point a0) (point a1) = plusAssoc (point a1) (point a0)  -- .. maybe ?
14:42:37 <copumpkin> plusComm ? :P
14:42:39 <dobblego> yeah, but not necessarily plusAssoc a b = plusAssoc b a
14:42:54 <copumpkin> plusPointComm
14:44:21 * edwardk looks around at the mention of his name and skims the log
14:44:32 <edwardk> dobblego: FunctorPlus
14:44:33 <ski>   sumAssoc as0 = sumAssoc as1  <=  permutation as0 as1  -- then
14:45:04 <ski> edwardk : but it's not even a `Functor' !?
14:45:13 <dobblego> edwardk, zero is not necessary nor is fmap
14:45:17 <edwardk> ski: i missed that part =)
14:45:19 <arcatan> hmm, is there easy way to lift when to Monad m => m Bool -> m () -> m ()
14:45:28 <arcatan> :t when
14:45:29 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:45:42 <dobblego> arcatan, Control.Monad.Tools on hackage has that (but I've been meaning to write something more comprehensive)
14:46:01 <dobblego> @hayoo whenM
14:46:02 <lambdabot> Unknown command, try @list
14:46:21 <edwardk> dobblego: i have no name for that one, pchiusano wanted some kind of pointed semigroup a few months back, where the point wasn't necessarily a unit. i gave him that name 'pointed semigroup' -- he went away unhappy and then hired me
14:46:33 <dobblego> edwardk, haha
14:46:49 <dobblego> say g'day to em all for me
14:46:59 <edwardk> dobblego: will do
14:47:05 <dobblego> PointedSemigroup is the best I could come up with too
14:47:09 <mauke> :t \x y z -> x >>= (\k -> when k y z)
14:47:10 <lambdabot>     Couldn't match expected type `m b' against inferred type `()'
14:47:10 <lambdabot>     In the expression: when k y z
14:47:10 <lambdabot>     In the second argument of `(>>=)', namely `(\ k -> when k y z)'
14:47:21 <mauke> :t \x y -> x >>= (\k -> when k y)
14:47:22 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
14:47:30 <mauke> @pl \x y -> x >>= (\k -> when k y)
14:47:30 <edwardk> but note you have a higher kinded pointed semigroup, because of the a parameter
14:47:30 <lambdabot> (. flip when) . (>>=)
14:47:35 <arcatan> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:whenM seems to be popular
14:47:50 <dobblego> edwardk, right, but the Pointed part kind of implies that
14:48:03 <edwardk> nah, it could just be a distinguished element
14:48:34 <ski> @type flip ((=<<) . flip when)
14:48:34 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
14:48:42 <edwardk> point :: m -- without the laws picking it out for you
14:48:46 <ski> @type \when -> flip ((=<<) . flip when)
14:48:47 <lambdabot> forall a (m :: * -> *) b a1. (Monad m) => (a -> a1 -> m b) -> m a -> a1 -> m b
14:49:01 <copumpkin> :t (. flip when) . (>>=)
14:49:02 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m () -> m ()
14:49:26 <edwardk> the motivating example for paul was that he had a lot of monoid or semigroup like things that needed to be able to track gaps in the data.. and he didn't like my assertion that they should be reducers from Maybe a instead of a =)
14:49:30 <ski> @hoogle (a -> b -> m c) -> (m a -> m b -> m c)
14:49:30 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:49:30 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
14:49:30 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
14:50:06 <hpc> :t join . liftM2
14:50:07 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
14:50:32 <hpc> er
14:50:48 <hpc> :t \f -> join $ liftM2 f
14:50:49 <lambdabot> forall a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> m a2 -> m r
14:50:56 <hpc> pah
14:51:27 <dobblego> edwardk, one example is newtype N a = N (a, [a]) which is not a Monoid
14:52:09 <ski> @type ((join .) .) . liftM2
14:52:10 <lambdabot> forall (m :: * -> *) a a1 a2. (Monad m) => (a1 -> a2 -> m a) -> m a1 -> m a2 -> m a
14:52:10 <edwardk> dobblego: *nods*
14:52:39 <edwardk> dobblego: but then what do you do on plus? there isn't a canonical choise for what to do with the extra head
14:53:22 <dobblego> N (a, as) ++ N (b, bs) = N (a, as ++ b:bs) ?
14:53:51 <ski> (`N' being non-empty lists, i take it)
14:54:07 <dobblego> yeah though I just press whatever key I happen to loo kat :)
14:54:08 <jmcarthur> edwardk: is this what he was talking about while we were at legal seafood?
14:54:43 <edwardk> jmcarthur: i think it came up then
14:54:44 * ski idly wonders what illegal seafood would be ..
14:55:05 <jmcarthur> ski: i wondered that too :P
14:55:43 <edwardk> ski: "Legal" in that context is actually a last name =)
14:56:38 <ski> ("sorry mate, but your urchin is an illegal alien, we'll have to take him to the station and grill him")
14:56:53 <jmcarthur> dobblego: well, newtype N a = N (a, [a]) can be a Monoid if a is a Monoid, but i guess that isn't what paul was going for
14:56:57 <hpc> "don't glaze me, bro"
14:57:15 <dobblego> jmcarthur, right
14:57:36 <dobblego> jmcarthur, Paul mentioned this to me as well and I come across this occasionally too
14:58:13 <jmcarthur> hmm... it could also be a Monoid if you treat it as a nonempty list structure
14:58:15 <ski> edwardk : that .. makes even less sense to me :/
14:58:16 <Twey> edwardk: And this is why we have capitalisation >.>
14:58:25 <dolio> There's no identity non-empty list.
14:58:30 <edwardk> actually i stand corrected. it was a reference to "legal stamps" =)
14:58:32 <jmcarthur> oh duh :)
14:58:48 <jmcarthur> dolio: but it works for the Semigroup case at least
14:58:57 <dolio> Yes.
14:59:28 <dolio> jmcarthur: I was about to say the same thing you did. I just caught myself at the last moment.
14:59:35 <jmcarthur> heh
14:59:41 <dobblego> jmcarthur, http://hackage.haskell.org/package/Semigroup http://hackage.haskell.org/package/NonEmptyList
15:02:05 <mreh> http://hpaste.org/paste/41303/working#p41304
15:02:13 <mreh> is there a more idiomatic way of doing this?
15:02:57 <mreh> the nature of <|> makes it tricky to do
15:03:29 <Philippa> does parsec 3 have a <|>-alike that uses try on the LHS yet?
15:03:33 <Philippa> I should RTFM I guess :-)
15:05:17 <mreh> I'd only just seen there was a parsec3 today
15:05:24 <mreh> hadn't had time to properly investigate
15:05:47 <ddarius> Philippa: No.
15:05:48 <mreh> it works though
15:06:22 <ski> @hoogle optional
15:06:23 <lambdabot> Control.Applicative optional :: Alternative f => f a -> f (Maybe a)
15:06:23 <lambdabot> Text.Parsec.Combinator optional :: Stream s m t => ParsecT s u m a -> ParsecT s u m ()
15:06:23 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
15:06:37 <mreh> aha
15:07:11 <ski>   a <- fromMaybe 0 `liftM` optional accidentalParser
15:07:13 <ski> i think
15:07:58 <mreh> @hoogle option
15:07:58 <lambdabot> Text.Html option :: Html -> Html
15:07:58 <lambdabot> Text.Parsec.Combinator option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
15:07:58 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
15:08:03 <ski> (using the `Control.Applicative' one, i.e. .. which i hope parsec supports, now)
15:08:21 <mreh> effectively the same as yours
15:08:54 <ski> ah .. i see
15:14:09 <ozataman> Hey all. I wanted to ask a design question. Say you are designing something like a web server with a Request -> Response cycle. you want your application to do i18n dynamically, which means you will have a collection of .po/.yaml/etc. files with large amounts of translations statically sitting in some folder. Obviously, you would like to load this once and keep using the mappings from the memory for performance reasons. What would be the best way to desi
15:14:09 <ozataman> this into your app? Say if one is using a framework like Snap or Happstack. A reader Monad? Memoization inside a top-level function? Some kind of type hackery (as in the functional pearl: implicit configurations)?
15:15:43 <RichardBarrell> Reader Monad sounds like the least crazy way to handle that, to me.
15:16:09 <EvanR-work> ozataman: use pastebin for essay questions, the middle of your text was deleted
15:16:42 <EvanR-work> your broken client sent two pieces but incorrectly 'guessed' the max message size
15:17:04 <RichardBarrell> ozataman: "What would be the best way to desi" <you got cut off here> "this into your app?"
15:17:10 <EvanR-work> ozataman: an mvar with a reference to the cache would work fine
15:17:14 <ozataman> EvanR-work: thanks for pointing out. here's my question: http://pastebin.com/66y4Svat
15:17:34 <EvanR-work> if you need to update it
15:17:42 <EvanR-work> if its constant use a reader with the lookup table
15:17:53 <ozataman> EvanR-work: would that be high performance? the data would likely not change in this use case
15:18:16 <EvanR-work> well you cant design it probabilistically
15:18:20 <aavogt> this memoization inside a top-level function option needs more explanation
15:18:27 <EvanR-work> without the quantum monad
15:18:38 <ozataman> EvanR-work: To me, one of the key benefits of using Haskell for web development would be speed. I would certainly not want to sacrifice that...
15:18:56 <EvanR-work> i would first like the non broken ness
15:19:04 <EvanR-work> that most web frameworks are
15:19:08 <proq> ozataman: development speed or runtime speed?
15:19:09 <EvanR-work> arent
15:19:13 <ozataman> EvanR-work: Yeah, very true. And agreed
15:19:27 <ozataman> proq: Runtime speed. Development speed would be nice too!
15:20:24 <ozataman> proq: But I am somewhat assuming a high development speed with Haskell given its nature once the underlying components are developed. 
15:20:56 <ozataman> EvanR-work: What do you mean by "probabilistically"? You mean lazy-loading the translations based on some chance of lookup?
15:21:34 <ozataman> aavogt: The top-level memoization is explained here: http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
15:22:33 <ozataman> aavogt: Essentially, if you define a function without any parameters inside of a, say, "where" block, its value gets memoized for sub-sequent references to it
15:22:56 <EvanR-work> ozataman: design requirements equalling "probably wont need to be updated"
15:23:08 <kmc> that's not a function,then
15:23:10 <kmc> not necessarily
15:23:29 <ozataman> EvanR-work: Right.. No need to update it during runtime.
15:23:45 <ozataman> kmc: Sorry - I might have used a misnomer there. 
15:24:35 <EvanR-work> ozataman: so its very probably
15:24:42 <EvanR-work> P = 1
15:24:47 <EvanR-work> youre good
15:26:31 <ozataman> Is the Reader monad memoized internall? Or is it actually copied for each chaining with (>>=)?
15:26:54 <kmc> what do you mean?
15:27:10 <kmc> http://hackage.haskell.org/packages/archive/mtl/2.0.1.0/doc/html/src/Control-Monad-Reader.html
15:27:21 <kmc> err that's not very useful
15:27:26 <kmc> ah, mtl 2
15:27:35 <kmc> http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/src/Control-Monad-Trans-Reader.html
15:27:47 <EvanR-work> ozataman: why would it copy?
15:27:52 <ozataman> kmc: Well, for example in this case if I load a large amount of data into the reader monad, will that data have to be copied over and over for each Request -> Response cycle and garbage collected?
15:28:12 <kmc> no, and that's nothing to do with memoization i don't think
15:28:16 <ozataman> EvanR-work: Isn't that how pass-by-value semantics work in Haskell?
15:28:22 <EvanR-work> no
15:28:25 <kmc> in haskell when you say "let y = x" you are at most copying a pointer
15:28:45 <kmc> (in GHC Haskell i should say)
15:28:52 <ozataman> so the reader monad really loads once and never touches the data throughout the execution?
15:29:20 <kmc> if i say "let n = .... in f n + g n + h n", n isn't copied three times for the three calls
15:29:25 <EvanR-work> if you load the data from a file on each request it has no choice but to gc the old version...
15:29:49 <EvanR-work> anyway have you looked at direct-fastcgi
15:29:49 <mauke> ozataman: there is no pass by value, and nothing is ever copied
15:30:07 <EvanR-work> that sucker is fast
15:30:26 <kmc> with immutable data you don't need to copy things very often
15:31:29 <ozataman> So in other words the data buried inside a ReaderT never gets copied as once chains the tranformer stack with (>>=)?
15:31:41 <ozataman> (for example, that is)
15:31:49 <EvanR-work> why would it need to be
15:31:55 <ozataman> as one*
15:32:09 <ozataman> EvanR-work: Oh I don't know - I'm just trying to understand 
15:32:12 <kmc> no it doesn't, but i'm wondering why you think it would
15:32:14 <EvanR-work> where is that idea coming from
15:32:30 <kmc> copying data in Haskell involves explicitly invoking a constructor
15:32:30 <sipa> using >>= yoou combine a chain of actions into one action, that is effectively a wrapped function inside
15:32:33 <kmc> copy (Just x) = Just x
15:32:36 <kmc> that's a copy
15:32:37 <sipa> and data is passed to this function
15:32:39 <kmc> copy v = v -- is not a copy
15:32:41 <ozataman> I see. I think I was making a faulty assumption that everything gets copied each time you call any function!
15:32:44 <kmc> even if v is a Maybe type
15:32:58 <kmc> ozataman, yeah, that would be incredibly wasteful, and totally unnecessary, since data is immutable
15:33:04 <kmc> it would however make garbage collection trivial!
15:33:46 <Eduard_Munteanu> That would look like region inference, wouldn't it?
15:33:50 <EvanR-work> say that the function is applied to data rather than being passed data like some sort of nightmarish machine ;)
15:34:07 <zachk> is there an easy to use symbolic differnetiation library on hackage ? 
15:34:21 <Eduard_Munteanu> (I underline _like_)
15:34:25 <ozataman> thanks for the clarification! this makes a lot more sense now :)
15:34:29 <kmc> :)
15:34:31 <mauke> > deriv (^2) x
15:34:31 <lambdabot>   1 * x + x * 1
15:34:51 <ozataman> so my initial question can really be easily solved with a reader monad
15:34:56 <mauke> > deriv (1 / sin) x
15:34:56 <lambdabot>   1 * negate (1 * cos x * recip (sin x) * recip (sin x))
15:35:12 <ozataman> load it once, and use "ask" to query whenever you need to. it won't be wasteful really in any way
15:35:13 <mauke> well played
15:35:32 <mauke> ozataman: the reader monad is just sugar for function parameters
15:35:52 <mauke> ozataman: call a function once and use the parameter whenever you need to
15:35:55 <EvanR-work> ozataman: make a wrapper to ask for a specific translation
15:36:10 <Eduard_Munteanu> mauke: would there be anything like that for ADTs, or do I misunderstand what's behind the zipper libs?
15:36:32 <mauke> Eduard_Munteanu: huh?
15:36:51 <Eduard_Munteanu> mauke: I wonder if type differentiation works automatically too
15:37:28 <Eduard_Munteanu> 1 + A T^2 -> 2 A T for example
15:37:33 <mauke> oleg probably did that
15:37:49 <Eduard_Munteanu> Oh, heh.
15:39:55 <ozataman> We really need a good web development framework
15:40:00 <ozataman> :)
15:40:08 <SubStack> with websockets!
15:40:11 <zachk> @src deriv 
15:40:12 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
15:40:18 <zachk> where do i get deriv 
15:40:34 <Eduard_Munteanu> @hoogle deriv
15:40:34 <lambdabot> Language.Haskell.Lexer KW_Deriving :: Token
15:40:41 <Eduard_Munteanu> Um, not that.
15:41:07 <SubStack> actually I want web frameworks that are just collections of processes all talking rpc
15:41:45 <SubStack> written in lots of languages, haskell included
15:42:34 <Zao> SubStack: Smells like Mongrel2's approach.
15:43:33 <SubStack> nah
15:43:43 <Adamant> Mongrel2 uber alles
15:43:48 <Adamant> except Haskell
15:43:51 <sproingie> what does mongrel2 use for rpc?
15:44:00 <ozataman> It would be great if we had a batteries-included web library or framework. Something that has authentication, session management, i18n, templating, etc. figured out. Definitely does not need to be as bloated as Rails, but something with which you can build large/scalable applications.
15:44:16 <SubStack> I'll port my own rpc system in the next few months
15:44:19 <sproingie> i don't find rails very bloated.  i find it lacks basic stuff i need.
15:44:22 <SubStack> it's continuation-based so it should be a good fit
15:44:24 <shapr> ozataman: Have you tried happstack or snap?
15:44:47 <ozataman> shapr: I actually like snap - but it needs some higher level utilities to be built
15:45:06 <shapr> Like what?
15:45:09 <ozataman> shapr: Snap is what I had in mind when I asked about i18n
15:45:12 <sproingie> i gotta admit the new ORM in rails, i forget the name, is impressive looking.  looks like the author actually knows his shit
15:45:30 <sproingie> which is more than i could say about ActiveRecord
15:45:42 <shapr> ozataman: Do you think that's all Snap needs to be batteries-included?
15:46:10 <ozataman> sproingie: actually the new ORM looks pretty much like monadic chaining. Kind of like a Writer monad that adds stuff as you're chaining and interprets/executes at the end.
15:47:01 <sproingie> ozataman: suffice to say he looked at sqlalchemy and actually improved on it
15:47:04 <ozataman> shapr: Oh, well I would say at least authentication, all the cross-site protection stuff, i18n, a good way to maintain DB connection
15:47:13 <Mitar> @pt (\n -> (block . dissolve $ n) `finally` putMVar dissolved ())
15:47:13 <lambdabot> Maybe you meant: ft pl
15:47:26 <Mitar> @pl (\n -> (block . dissolve $ n) `finally` putMVar dissolved ())
15:47:26 <lambdabot> (`finally` putMVar dissolved ()) . block . dissolve
15:47:57 <sproingie> ozataman: that and python 3.0 being so moribund and ruby's future is actually looking bright again
15:48:40 <arcatan> how ruby's future is looking bright?
15:48:48 <shapr> arcatan: It's written in Haskell now.
15:48:54 <sproingie> arcatan: rails got an injection of smart
15:49:03 * ddarius has, in fourteen years of personal programming, never desired a web framework.
15:49:36 <sproingie> not everyone writes web apps
15:49:46 <sproingie> i sure don't
15:50:06 <ddarius> sproingie: I do professionally.
15:50:35 <sproingie> my guess is you reuse your own code and possibly rewrite some of that code for reuse
15:50:42 <sproingie> so you wrote your own framework
15:51:02 <monochrom> I write some javascript for some of my web pages to make them more fun.
15:51:12 <sproingie> if you don't, then well, each site being a unique snowflake sure keeps things interesting at least
15:52:11 <ozataman> ddarius: it doesn't have to be a web "framework" but at least a set of well thought-out libraries would really help. Standing on the shoulders of giants helps :)
15:53:09 <ozataman> shapr: why were you asking about Snap?
15:53:35 <wlangstroth> rails doesn't really need to be smart, it just needs to do yer basic site
15:53:35 <arcatan> > sqrt 2
15:53:36 <lambdabot>   1.4142135623730951
15:54:10 <shapr> ozataman: It seems to me that you know what's needed, you're likely the best candidate to go forth and fix stuff!
15:54:28 <ozataman> shapr: :) I actually do want to help
15:54:30 <sproingie> wlangstroth: sure but it should do so wihtout being droolingly stupid like the way the old ActiveRecord was
15:54:34 <shapr> ozataman: Awesome!
15:54:43 <zachk> maybe you guys that want a haskell web framework should check out atomo (#atomo) i dunno its a small language written in haskell that can dip into haskell and the guy has a webserver in it and the web pages themselves are written in atomo :) 
15:54:50 <shapr> sproingie: Hey, highly emotional judgements go to -blah or elsewhere.
15:54:51 <ozataman> shapr: I will see if I can stretch my understanding of the underlying stuff to make some of the needed contributions
15:54:59 <shapr> ozataman: Great idea!
15:56:07 <sproingie> zachk: got a url for atomo?
15:56:13 <sproingie> my searches pull up a .net thing
15:57:21 <aavogt> @hackage atomo
15:57:21 <lambdabot> http://hackage.haskell.org/package/atomo
15:57:59 <sproingie> whoah someone else who's heard of slate
15:58:45 <wlangstroth> sproingie: have you ever looked at the code for rails? There's drool all over the place.
15:59:25 <sproingie> wlangstroth: stuffing half the functionality onto Object is a charming touch
15:59:28 <ddarius> sproingie: I use the .NET framework professionally.  I web applications because I'm paid to do so.  At home, I don't write web applications and have never wanted to, though if I did want a web application framework, I'd probably write one from scratch.
15:59:31 <monochrom> atomo looks like postfix haskell XD
15:59:43 <sproingie> wlangstroth: didn't say it got a smart makeover, just an injection of it :)
15:59:50 <sproingie> smartagen
15:59:56 <kmc> atomo is just Blub with weird syntax
16:00:34 <zachk> whats blub 
16:01:01 <RichardBarrell> zachk: hypothetical, not-very-powerful programming language.
16:01:19 <shapr> sproingie, wlangstroth: Seriously, emotional judgements go elsewhere, yah?
16:01:20 <ymasory> hi all: why does ghci say my constructor is out of scope when functions in the same file work fine?
16:01:21 <kmc> blub is the perfect programming language.  it has all the features you need, without all that weird shit nobody understands
16:01:30 <RichardBarrell> zachk: it's a metasyntactic variable, like "foo" or "bar", except that it always stands in for the name of a programming language.
16:01:35 <kmc> ymasory, in the prompt, is the file loaded with a * before it?
16:02:28 <ymasory> kmc: i changed the prompt to ghci, let me change it
16:02:34 <kmc> ok well anyway
16:02:43 <kmc> ghci will load the compiled .o files if they exist and are up to date
16:02:58 <sproingie> blub is like "leaky abstraction", a good metaphor that, coming from joel, has to be applied to everything
16:03:03 <monochrom> someone asked "is haskell oo" and I said yes, for example False is an object and "not False" is using the method "not" of that object. people then asked "what about gcd 4 5", and I said ever heard of multiple dispatch?
16:03:05 <sproingie> joel on programming is like a burrito
16:03:15 <kmc> and then you can only see the exported stuff
16:03:29 <kmc> one solution is: ghci -fforce-recomp
16:03:30 <ymasory> kmc: it just says *main after i :l the file
16:03:33 <kmc> will interpret everything
16:03:39 <kmc> ok, is the main module the one with the constructor?
16:03:50 <sproingie> @faq can haskell do OOP?
16:03:51 <lambdabot> The answer is: Yes! Haskell can do that.
16:03:55 <wlangstroth> sproingie: "charming" is the right word
16:03:55 <ymasory> i'm not using any explicity modules
16:03:59 <ymasory> *explicit
16:04:04 <kmc> blub wasn't joel's metaphor, though
16:04:06 <shapr> sproingie: Don't make me turn this channel around.
16:04:06 <kmc> does he use it a lot?
16:04:08 <ymasory> the functions don't seem to require it
16:04:09 <kmc> also remember that types and values have different namespaces
16:04:14 * shapr snickers
16:04:24 <kmc> so a name might be in scope as a type but not a value constructor
16:04:54 <sproingie> oh right blub is graham
16:05:32 <ymasory> thanks kmc
16:05:32 <aavogt> @faq does haskell have 6 namespaces?
16:05:32 <lambdabot> The answer is: Yes! Haskell can do that.
16:05:47 <kmc> six?
16:05:58 <monochrom> 6.0034, to be exact
16:06:14 <sproingie> i looked and saw the beast with six namespaces...
16:06:29 <ymasory> i'm still working on figuring out all the things haskell can do
16:06:39 * ddarius wants shapr to turn the channel around.
16:06:40 <sproingie> binding, type, constructor, module ... 
16:06:41 <monochrom> that may take infinite time
16:06:45 <ymasory> https://github.com/ymasory/Lang-Chart/blob/master/langchart.org
16:06:46 <sproingie> what's the other two?
16:06:51 <ymasory> suggestions for rows welcome
16:06:53 <ddarius> shapr: By the way, did you leave your Charlie card with edwardk?
16:07:21 <shapr> ddarius: I don't think so. I think it's at home, why? And yes, this channel needs either turning around or abandoning.
16:07:48 <shapr> Might be time to get out the banhammer again.
16:08:10 <ddarius> shapr: edwardk gave me an extra one he had.  I was wondering if it might be yours.
16:08:29 <sproingie> i'd say someone has a case of the Mondays, but i think that would bring on said banhammer
16:08:35 <kmc> omnom charlie card
16:08:42 <shapr> sproingie: Feel free to say that on #haskell-blah :-)
16:09:14 <aavogt> sproingie: type is split up as type variable, type constructor and type classes
16:09:45 <kmc> classes and type ctors are in the same namespace aren't they?
16:09:48 <sproingie> oh right type classes and type variables
16:09:49 <aavogt> but it's sort of misleading to say six, because they overlap somewhat: http://www.haskell.org/onlinereport/intro.html
16:09:50 <kmc> 'error:class Num used as a type'
16:10:09 <aavogt> section 1.3
16:10:10 <aavogt> 1.4
16:10:19 <sproingie> i consider type variables to share the same namespace as the type tho
16:10:51 <Mitar> @pl (\(Growable l) -> takeMVar . getNeuronDissolved $ l)
16:10:51 <lambdabot> (line 1, column 13):
16:10:51 <lambdabot> unexpected "l"
16:10:51 <lambdabot> expecting operator or ")"
16:11:24 <Mitar> ???
16:11:47 <Mitar> it compiles here
16:12:05 <Mitar> @pl (\(Growable l) -> takeMVar . id $ l)
16:12:05 <lambdabot> (line 1, column 13):
16:12:05 <lambdabot> unexpected "l"
16:12:05 <lambdabot> expecting operator or ")"
16:12:24 <Mitar> @pl (l -> takeMVar . id $ l)
16:12:24 <lambdabot> (line 1, column 4):
16:12:24 <lambdabot> unexpected ">"
16:12:24 <lambdabot> expecting variable, "(", operator or ")"
16:12:31 <Mitar> @pl (\l -> takeMVar . id $ l)
16:12:31 <lambdabot> takeMVar
16:12:33 <shapr> Mitar: Hey, try that on #haskell-overflow?
16:12:37 <Mitar> ok ;-)
16:12:44 <kmc> or you can private-message lambdabot
16:12:49 <Mitar> aha
16:12:55 <Mitar> where can i get a list of commands it supports?
16:13:02 <lispy1> ?list
16:13:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:13:05 <Mitar> thanks
16:13:29 <lispy1> Mitar: you can also install lambdabot locally and play with it offline if you like
16:13:31 <lispy1> ?version
16:13:31 <lambdabot> lambdabot 4.2.2.1
16:13:31 <lambdabot> darcs get http://code.haskell.org/lambdabot
16:13:45 <lispy1> also on hackage, cabal install lambdabot
16:13:51 <Mitar> i do not understand why it has different prefixes for different commands, like ?, @, > ...
16:14:18 <mauke> "> " is a shortcut for "@run"
16:14:24 <mauke> "?" is the same as "@"
16:21:54 <lispy1> ?run 1 + 1
16:21:55 <lambdabot>   2
16:22:00 <lispy1> @run 1 + 1
16:22:01 <lambdabot>   2
16:22:02 <lispy1> > 1 + 1
16:22:03 <lambdabot>   2
16:23:14 <mauke> @eval lave@
16:31:11 <tomh> hey guys, any of you done F#?
16:35:12 <Mitar> if I have block . takeMVar this is quaranteed to exit only if mvar is filled and not if there will be any exception?
16:37:18 <dnm> tomh: Yes.
16:37:40 <tomh> dnm, I was wondering how the compilation speed of F# compares to haskell?
16:37:49 <tomh> can you tell me anything about it?
16:40:30 <kmc> Mitar, takeMVar blocks until the mvar is filled
16:41:07 <Mitar> even if exception comes?
16:41:27 <Mitar> i would like to make at the end of main function sure that all threads have finished
16:41:32 <Mitar> so i first send kill to all threads
16:41:38 <Mitar> and then i wait for them to fill mvar
16:42:05 <Mitar> but when each of threads is killed it sends an exception back to main thread
16:42:15 <Mitar> and it seems that exception kills that waiting at the end
16:42:20 <kmc> why would it send an exception back?
16:42:23 <kmc> you've coded that?
16:42:26 <Mitar> yes
16:42:39 <kmc> ok
16:42:49 <Mitar> so that if they finish prematurelly they kill also the main threads which kills then everything else and exits
16:43:18 <kmc> well, you could kill those threads with a special new type of exception
16:43:22 <kmc> which they won't bounce back to the main thread
16:43:26 <roconnor> @seen edwardk
16:43:26 <lambdabot> Unknown command, try @list
16:43:26 <preflex>  edwardk was last seen on #haskell 1 hour, 44 minutes and 55 seconds ago, saying: actually i stand corrected. it was a reference to "legal stamps" =)
16:43:29 <Mitar> true
16:43:55 <zecrazytux> map func list    <---- is it possible to give extra parameters to func() ?
16:43:56 <Mitar> but is there a catch/handle which catches everything except some type of an exception ;-)
16:44:07 <Cale> zecrazytux: map (func x y z) list
16:44:07 <Eduard_Munteanu> zecrazytux: yes
16:44:08 <dnm> tomh: Not really. It'd depend on the project and the code.
16:44:14 <zecrazytux> brillant !
16:44:17 <zecrazytux> thank you :)
16:44:39 <dnm> tomh: You'd have to try something roughly equivalent in both and benchmark it on your system.
16:44:41 <tomh> dnm, yeah true, but does it feel quick like haskell?
16:44:43 <Eduard_Munteanu> zecrazytux: but should end up func x y z :: a -> a or something like that
16:45:07 <Eduard_Munteanu> if you understand currying.
16:45:07 <dnm> tomh: Compilation speed hasn't been an issue for me with F# yet.
16:45:20 <dnm> tomh: The most honest thing here is "I don't notice."
16:45:25 <tomh> ok
16:45:37 <dnm> tomh: YMMV
16:45:44 <tomh> ymmv?
16:45:57 <Eduard_Munteanu> Your mileage may vary
16:46:01 <tomh> ok
16:46:08 <dnm> "Your mileage may vary." You may get different results than me.
16:46:14 <zecrazytux> Eduard_Munteanu: is that doable with mapM to ?
16:46:22 <tomh> im just orienting for haskell alternatives
16:46:25 <Eduard_Munteanu> zecrazytux: with every function.
16:46:25 <dnm> Do you have a large codebase in Haskell you're looking to port?
16:46:35 <tomh> no not really
16:46:38 <zecrazytux> great :)
16:46:45 <Eduard_Munteanu> zecrazytux: suppose you pass some function another functin that should take a single argument
16:47:00 <dobblego> BFPG is sponsored by Microsoft and we've had a couple of F# talks -- though mostly Haskell
16:47:00 <tomh> im just looking for a language where I can use some of my FP knowledge but which has some demand in the industry :P
16:47:07 <kmc> Mitar, you can make a list of 'Handler's, the last one for SomeException
16:47:12 <dobblego> tomh, Java 
16:47:13 <dnm> Ah.
16:47:18 <Eduard_Munteanu> zecrazytux: you can always make a function that takes three arguments, apply two arguments to it and end up with one that takes a single argument
16:47:23 <kmc> you can use FP knowledge in most languages
16:47:33 <dnm> dobblego: Where's the "B" in BFPG?
16:47:36 <Eduard_Munteanu> zecrazytux: that's why it works with map and everything else
16:47:37 <tomh> well yeah..thats possible
16:47:44 <dobblego> dnm, Brisbane (Australia)
16:47:44 <SubStack> tomh: javascript!
16:47:46 <Mitar> kmc: http://hpaste.org/41305/thread_cleaning
16:47:48 <tomh> but it would be nicer if it was as close to haskell as possible :)
16:47:49 <Mitar> it looks like that
16:47:50 <dnm> dobblego: Ah, nice.
16:48:04 <tomh> SubStack, as second language its nice, but I miss static typing :)
16:48:21 <dnm> I'm not sure how many die-hard Haskell fans like ML-based languages, but I like ML and F#.
16:48:21 <SubStack> jslint can do some static analysis I think
16:48:38 <zecrazytux> Eduard_Munteanu: sounds good, but I need to practice a bit more :) that's my first try to haskell :)
16:48:46 <Eduard_Munteanu> tomh: is Haskell your first? :)
16:48:47 <dobblego> I miss laziness and a useful type system when I use F#
16:48:48 <tomh> let me check jslint
16:48:54 <SubStack> also this http://stackoverflow.com/questions/534601/are-there-any-javascript-static-analysis-tools 
16:48:58 <tomh> Eduard_Munteanu, haskell is my first FP yes
16:49:03 <Eduard_Munteanu> zecrazytux: you're on the right track then :)
16:49:19 <Eduard_Munteanu> tomh: ah, makes more sense :)
16:49:35 <SubStack> there's erlang too but you're in the same boat with regards to types
16:49:42 <SubStack> it's a bit more functional though
16:49:44 <tomh> yeah
16:50:00 <SubStack> or if not more functional, less impure
16:50:17 * danharaj sends out the conal signal
16:50:43 <conal> ?
16:51:01 <danharaj> haha! yes magic works. I was wondering if there is a version of the Reactive library that uses relative time instead of absolute time?
16:52:00 <conal> danharaj: i don't think there is
16:52:12 <pickles> danharaj: according to monochrom the other day, everyone is a pokemon so you should have summoned him differently
16:52:37 <pickles> but, whatever works :)
16:52:55 <danharaj> conal: sounds like something for me to do. Shouldn't be hard since your paper sketches a few of the differences between absolute and relative semantics.
16:52:57 <tomh> conal, do you know what the latest status is for FRP in games?
16:53:33 <dnm> tomh: Not to drag this channel off topic, but F# people hang out in ##fsharp (I'm there too).
16:53:46 <tomh> cool, ill drop by sometime :)
16:54:02 <conal> tomh: i haven't heard of anything lately.
16:54:04 <dnm> You'd be welcome to lurk and ask questions. It is much, much less populated than here though, so sometimes everyone is idling.
16:54:19 <tomh> ok
16:54:39 <conal> i don't think we've really gotten frp right yet. pain points show up with non-trivial apps.
16:54:44 <tomh> latest thing ive seen in FRP was elenare or somethign similalary named
16:54:45 <jmcarthur> :(
16:54:56 <tomh> conal, im planning to do my master thesis on FRP
16:55:06 <dnm> #haskell happens to be the most populated channel I'm on right now. Wild. Take that niche-osity!
16:55:15 <conal> tomh: oh! where?
16:55:21 <tomh> uu
16:55:28 <conal> nice!
16:55:38 <tomh> in the context of games
16:55:38 <conal> tomh: under whom?
16:55:47 <tomh> sean and johan most likely
16:55:50 <danharaj> forgive me, but which is UU?
16:55:55 <tomh> university of utrecht
16:55:58 <danharaj> snap
16:56:01 <conal> tomh: good for you!
16:56:02 <danharaj> congrats.
16:56:06 <tomh> hehe thanks 
16:56:23 <conal> i'd love to visit uu for a while sometime.  i always enjoy that bunch.
16:56:48 <tomh> well I bet you are more than welcome here :)
16:57:56 <conal> :)
16:58:17 <tomh> so I heard you were basically the one who invented FRP right? :>
16:59:09 <medfly> Fibre-reinforced plastic
16:59:21 <tomh> hehe
16:59:27 <danharaj> Since a huge chunk of FRP is giving a denotational semantics to behaviour over time, I think the more appropriate verb might be discover :p
16:59:36 <conal> tomh: yeah. in 1994. first as ActiveVRML. then switched to a haskell-embedding once i found haskell.
16:59:37 <danharaj> because math is discovered </trollbait>
16:59:56 <sproingie> wow i remember vrml
17:00:07 <tomh> ah thats pretty long ago
17:00:36 <conal> tomh: i was extending the ideas i'd played with in the form of TBAG when I was at Sun Microsystems from 1990-1994.  TBAG was about constraint-functional programming for 3D & interactive animation.
17:01:10 <dnm> Ah, constraints
17:01:13 <tomh> ok, I haven't read back that far about FRP yet 
17:01:28 * dnm misses constraints, but knows them more from the logic-oriented side of things.
17:01:56 <conal> as for constraints, i was inspired by steele, gosling, and borning, when i was a grad student at cmu. fond memories.
17:02:43 <tomh> hehe that research probably goes way back even till before I was born :p
17:02:43 <conal> with tbag, i got the idea to apply a generic local-propagation constraint engine to functions of time.
17:02:53 <conal> :)
17:03:26 <conal> and those functions of time yielded pure values for types like 3D geometry, colors, points, synthetic images, sound, etc.
17:03:27 <tomh> what Im planning to look into is how FRP can be used if you have external environments such as box2d 
17:04:18 <conal> at sun, the work was mostly in common lisp & scheme.  my lisp/scheme programming style was purely functional and very influenced by lots of ML programming in grad school.
17:04:42 <tomh> ah then haskell must have been a nice upgrade :)
17:05:03 <kmc> scheme is a nice language too
17:05:21 <conal> tomh: yeah, haskell was the best fit. though the others were awfully fun also.
17:05:24 <dnm> tomh: Interesting that you're into FRP and games. I'm working on some games projects and I'm looking at various functional techniques as well, including FRP.
17:05:52 <tomh> well i'm not into FRP that much yet, but I liked some stuff what I saw in scala
17:06:02 <dnm> Mostly I'm limited by what I can do on various platforms, PC being the easiest (because in theory I can do anything).
17:06:04 <tomh> they had some nice combinators dealing with events
17:06:06 <danharaj> conal: I haven't had a chance to read the improving values paper you reference in push-pull. Is it an adequate intuition that 'improving' values are bounded monotonic sequences of time values?
17:06:12 <conal> i just remembered this post on frp history: http://conal.net/blog/posts/early-inspirations-and-new-directions-in-functional-reactive-programming/
17:07:16 <tomh> dnm, my idea is to have it run on mobile :>
17:07:32 <conal> danharaj: that's the basic idea. though more general than time values. any ordered type.
17:07:33 <tomh> but still need to constraint my topic a bit
17:07:54 <dnm> Wow. Yeah, that's a pretty limited environment, even today (though way less so than even five years ago).
17:08:23 <dnm> I think you may have less memory budget concerns on mobile but possibly more power budget concerns than I will with consumer consoles. ;]
17:08:24 <tomh> yeah, so my FRP lib needs to be 1) fast 2) functional 3) integrate with external (native) libraries :)
17:08:30 <conal> danharaj: and they have a precise denotation: the limit of that sequence. it's important that the type itself be abstract, to allow various implementation styles.
17:08:42 <danharaj> conal: ah, so in essence it is the completion of a linear order.
17:09:26 <conal> tomh: great.  there's a paper that might help you with part 3: http://conal.net/papers/padl99/
17:09:32 <danharaj> conal: by the usual construction, that is.
17:09:56 <ddarius> tomh: Good luck.
17:10:07 <tomh> conal, thanks, I have been looking for information about that for a while
17:10:09 <conal> tomh: it's about using an imperative retained-mode back-end to implement functional animation
17:10:11 <tomh> ddarius, thanks :)
17:10:29 <dnm> I remember Fran.
17:10:31 <dnm> Wow.
17:10:33 <dnm> Memory lane.
17:10:41 <danharaj> tomh: usually when you list 3 conditions like that, the caveat is "choose 2" :D
17:10:43 <conal> dnm: :)
17:10:53 <conal> i got to thinking about that paper again recently in the context of javascript & dom.
17:11:06 <tomh> conal, which means using an imperative language to implement FRP or?
17:11:15 <tomh> danharaj, hopefully not :)
17:11:49 <danharaj> tomh: choose two is the easy answer. I'm sure you'll get your cake and eat it too.
17:12:21 <ray> you can't eat your cake unless you have it anyway
17:12:39 <tomh> well ill be implementing a game, if its not fast enough or it doesn't work with box2d I dont consider it a good library :)
17:12:53 <tomh> and if its a pain to implement the game then its not good either
17:13:38 <dnm> I wonder if I still have an old MSR Fran download somewhere. Just ran across this in my old bookmarks, still works! (MSR link in there doesn't though): http://www.haskell.org/fran/fran.html
17:13:46 <tomh> but I guess along the way I will discover that my big ambitions are not possible at all :P
17:14:05 <conal> tomh: more about having low-level resources such as sprites that get allocated and used for a while. almost all other fran/frp implementations build up geometry etc from scratch at every time sample. the trick is to make this major change to the implementation architecture without any impact at all on the API or semantics.
17:14:41 <tomh> ah ok
17:14:52 <conal> tomh: i got hundreds of frames per second while running in Hugs on a 90s PC.
17:15:06 <dnm> tomh: Totally off-topic, but a goodly number of years ago (not too many; I think circa 2002?), there was a guy making a (2D) game library in Clean, including a demo platformer game.
17:15:08 <tomh> sounds good :)
17:15:35 <conal> tomh: that paper derives the implementation using simple algebraic reasoning.
17:15:36 <tomh> but I think physics is a different story than graphics
17:15:58 <danharaj> physics should be straightforward, actually. the reactive model is very naturally suited towards dynamical systems
17:16:17 <tomh> dnm, I have seen that project
17:16:27 <tomh> danharaj, not if its in an external environment
17:16:48 <tomh> if you have an external environment modify all your values
17:16:57 <tomh> in a foreign function way
17:17:07 <danharaj> tomh: is there a box2d binding for haskell?
17:17:09 <tomh> I bet that gives you some stuff to think about how to encode that :)
17:17:18 <tomh> yeah, well i've seen bullet
17:17:27 <tomh> which is basically box2d but 3d
17:17:56 <danharaj> tomh: I think a fruitful place to start would be trying to write a legacy adapter for Reactive and Bullet.
17:18:10 <danharaj> Reactive does have that provision at least in some form.
17:18:46 <tomh> mm
17:19:12 <tomh> which library do you mean with reactive?
17:19:20 <danharaj> http://hackage.haskell.org/package/reactive
17:19:24 <danharaj> reactive, of course :D
17:19:25 <tomh> http://haskell.org/haskellwiki/Reactive?
17:19:27 <tomh> ah
17:21:07 <tomh> sounds like a good place
17:21:09 <tomh> to start 
17:21:10 <Eduard_Munteanu> What's the best option these days to start with FRP? Grapefruit, Reactive, something else?
17:21:30 <conal> Eduard_Munteanu: i really don't know.
17:21:31 <Eduard_Munteanu> Mostly FRP related to GUIs or such stuff.
17:22:14 <Eduard_Munteanu> I guess FRP is still young...
17:22:26 <danharaj> Reactive does not have GUI attached to it yet, I think.
17:22:29 <tomh> well my impression is that it is older than me :D
17:22:56 <danharaj> tomh: perhaps it is prenatal :p
17:23:27 <tomh> hehe
17:23:46 <tomh> ok well time to sleep
17:23:49 <tomh> 2:23 am
17:23:53 <danharaj> nn
17:23:55 <tomh> laters
17:26:02 <joe3> forM_ [1..4000]  (\x -> appendFile "test" "a")
17:26:11 <joe3> I can write the above line as: appendFile "test" (replicate 4000 'a')
17:26:30 <joe3> just curious on if I can do the forM_ piece without the lambda code..
17:26:57 * hackagebot redis-hs 0.0.9 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.0.9 (WillLangstroth)
17:28:36 <Eduard_Munteanu> The 'replicate' variant _might_ be better for IO.
17:28:51 <joe3> yes, sure.
17:29:37 <joe3> i am just trying to learn haskell and the lambda in the forM_ is a hack to disguise the fact that ghci is not allowing the direct use of appendFile.
17:29:42 <ddarius> You can use const instead of a lambda abstraction.
17:29:49 <joe3> just wanted to check if thery was any was it is possibel
17:30:28 <ddarius> The lambda is not a hack.  Being able to omit the lambda in that case would be a hack.
17:30:43 <ddarius> Incidentally, you could use replicateM_
17:31:09 <joe3> ddarius: oh, interesting observation
17:31:15 <joe3> and very insightful too.
17:32:24 <Eduard_Munteanu> Hm, why isn't ghci allowing appendFile directly?
17:32:38 <pumpkin> Cale: can we have a lambdabot in #agda ?
17:32:50 <Cale> pumpkin: sure
17:32:57 <ddarius> Eduard_Munteanu: I'm going to bet on user error.
17:32:59 <Cale> lambdabot: @join #agda
17:33:14 <pumpkin> Cale: thankee!
17:33:23 <joe3> forM_ [1..4000]  (appendFile "test" "a")
17:33:26 <joe3> Couldn't match expected type `t -> m b' against inferred type `IO ()'
17:35:26 <monochrom> why do you insist on calling appendFile 4000 times, instead of just one call and write everything at once? do you love inefficient algorithms?
17:35:48 <joe3> monochrom: i am just learning how the functions interface together.
17:35:51 <danharaj> pff efficiency?
17:36:13 <ddarius> monochrom: This is #haskell, where versions of Fibonacci with exponential time complexity are the norm.
17:36:38 <ddarius> pumpkin: In Boston yet?
17:36:44 <pumpkin> ddarius: nah, I've been slacking
17:36:48 <pumpkin> will probably be there later this week
17:37:08 <Draconx|Laptop> monochrom, is appendFile not implemented using O_APPEND?
17:37:43 <monochrom> Draconx|Laptop: appendFile is also implemented using open and close, too. do you like to open-close 4000 times?
17:39:06 <monochrom> whoever suggested forM_ for this earlier today was brainless. clearly it should be replicateM_ 4000 (appendFile "test" "a")
17:39:11 <Draconx|Laptop> monochrom, sure, but you only suffer a constant penalty.
17:39:39 <ddarius> What's a factor of three between friends?
17:39:50 <Eduard_Munteanu> :)
17:40:55 <joe3> monochrom: i am a beginner. not knowing haskell does not make me brainless. just learning by experimenting and feedback like yours from earlier is exceptionally helpful.
17:41:24 <monochrom> You are not brainless. I am talking about someone else. Whoever told you to use forM_.
17:41:24 <RichardBarrell> Draconx|Laptop: syscalls are a pretty big penalty.
17:50:11 <kmc> whether or not an app-level write results in a syscall is unclear
17:50:16 <kmc> there are usually multiple layers of buffering
17:52:12 <ddarius> Down with buffering buffers!
17:54:42 <ymasory> what's a good way to find out where a function is declared
17:54:46 <ymasory> like 'chr' for example
17:54:53 <Makoryu> :info
17:55:09 <ymasory> excellent thank you
17:55:09 <Makoryu> ymasory: ...I'm assuming you're in ghci
17:55:21 <Makoryu> There's also Hoogle and such, if you're not
17:55:24 <ymasory> yes, it worked GHC.Base
17:55:47 <ymasory> hm wait that doesn't tell me what specifically to import
17:56:11 <monochrom> @hoogle chr
17:56:11 <lambdabot> Data.Char chr :: Int -> Char
17:56:11 <lambdabot> Text.PrettyPrint.HughesPJ Chr :: Char -> TextDetails
17:56:11 <lambdabot> Network.Browser chRealm :: Challenge -> String
17:56:13 <Makoryu> ymasory: I seem to recall chr being from Data.Char, actually
17:56:14 <Makoryu> Welp
17:56:24 <monochrom> I suggest Data.Char
18:08:09 * hackagebot iproute 1.2.0 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.0 (KazuYamamoto)
18:14:43 * ddarius suggests unsafeCoerce.
18:14:52 <Veinor> > fix error
18:14:53 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:15:00 <Veinor> never not funny
18:15:24 <ddarius> > fix unsafeCoerce
18:15:25 <lambdabot>   Not in scope: `unsafeCoerce'
18:16:00 <jmcarthur> fix unsafeCoerce == fix id?
18:16:26 <jmcarthur> i guess both are _|_ anyway
18:16:44 <Veinor> well, fix forces the type of unsafeCoerce to be (a -> a)
18:16:47 <jmcarthur> yeah
18:16:50 <Veinor> and presumably unsafeCoerce :: a -> a is id
18:16:56 <jmcarthur> one would hope
18:17:16 <Veinor> if it isn't, something's wrong
18:17:34 <Eduard_Munteanu> Hm, iproute2/tc bindings and all that could be useful at some point, /me remembers it in case he ever needs to generate Linux QoS rules...
18:18:14 <Eduard_Munteanu> Maybe it's better than 'bash'-ing them.
18:19:14 <Cale> Yeah, probably the only thing which can really be assumed of unsafeCoerce is that any composite of unsafeCoerces which start and end at the same type result in the identity.
18:20:39 <ddarius> I wouldn't assume that.
18:27:35 <baguasquirrel> is there a call that replace the chained fmaps? e.g. (fmap . fmap . fmap . ...)
18:27:56 <hpc> :t fmap . fmap . fmap
18:27:57 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
18:28:10 <hpc> baguasquirrel: at some point, the fmaps stop nesting, iirc
18:28:31 <hpc> at like, 10 or something
18:28:34 <baguasquirrel> so liftM2, liftM3, liftM4 ... they did somethign similar...
18:28:35 <Eduard_Munteanu> :)
18:28:53 <baguasquirrel> yea that's acceptable.. if the code needs 10 freaking arguments then it needs to be refactored
18:29:31 <baguasquirrel> meh...  time to dig into the libraries
18:30:01 <Eduard_Munteanu> baguasquirrel: are you by chance using nested monads without transformers?
18:30:05 <baguasquirrel> no
18:30:10 <baguasquirrel> so there's this trick...
18:30:18 <baguasquirrel> suppose you have some f :: a -> b -> c -> d
18:30:23 <baguasquirrel> and some other g :: d -> e
18:30:37 <baguasquirrel> you could do (fmap . fmap . fmap) f g
18:30:48 <hpc> ew, don't do that
18:30:55 <Eduard_Munteanu> What for?
18:31:01 <baguasquirrel> so the idea is that you want to do g .f
18:31:07 <hpc> do \a b c -> g . f a b $ c
18:31:15 <baguasquirrel> but instead it'd be like g `fmap3` f
18:31:19 <hpc> or something less ick
18:31:22 <Eduard_Munteanu> LOL
18:31:24 <kmc> why would they stop nesting?
18:31:51 <baguasquirrel> I'm not sure if they would... is there a restriction on the number of function args?
18:31:56 <hpc> kmc: i forget the reason; i just vaguely remember seeing (fmap fmap .... x10) = (fmap fmap ....x8) or something like that
18:32:49 <hpc> something like deeper fmaps interpreting each fmap in a different way that makes it shallower
18:33:44 <baguasquirrel> I guess the problem I'm having is that I want a generic (.) operator. maybe the solution isn't chained fmaps
18:34:09 <hpc> yes; fmapX10 is a shorter type signature than fmapX8
18:34:28 * hpc will spare the channel the spam, as it is a tangent
18:36:13 <kmc> weird
18:36:24 <Eduard_Munteanu> I think the guys at Erlang tried it there, it happened when they reached a critical spot of 12-13 fmaps, if I'm not mistaken.
18:36:44 <jmcarthur> wat
18:36:49 <Eduard_Munteanu> Corporate research, heavy stuff.
18:37:09 <pumpkin> ick, the gmp mpn API is so ugly
18:37:47 <Eduard_Munteanu> Perhaps for Haskell, it's lower.
18:38:54 * hpc is curious as to exactly how fmap stops getting deeper, but isn't OCD enough to evaluate by hand
18:39:13 <pumpkin> integers are a choice! users of integers are all going to hell! only the naturals are natural
18:39:18 <jmcarthur> i'm making ghci very unhappy right now
18:39:19 <Eduard_Munteanu> It probably reaches a singularity.
18:39:32 <Eduard_Munteanu> And you can't see beyond the event horizon without breaking causality.
18:39:34 <jmcarthur> this takes a very long time to type check: fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
18:39:39 <hpc> pumpkin: integers go both ways?
18:39:49 <pumpkin> hpc: yeah, eww!
18:39:54 <jmcarthur> finally finished
18:40:08 <ddarius> pumpkin: Kronecker would be proud of you.
18:40:17 <Eduard_Munteanu> We don't have their clusters.
18:40:29 <jmcarthur> wow it took a lot of memory too
18:40:34 <jmcarthur> yay exponential type checking
18:40:58 <pumpkin> ddarius: I'm sure!
18:41:05 * hpc is loving his laptop's i7
18:41:12 <ddarius> Superexponential.
18:41:17 * pumpkin is loving his laptop's ssd
18:41:21 <baguasquirrel> yea, that is kinda ugly
18:41:30 <Eduard_Munteanu> jmcarthur: grr, you're serious... why does that happen?
18:41:31 <jmcarthur> pumpkin: i want one...
18:41:40 <pumpkin> jmcarthur: they're fairly cheap in the latest macbook airs :)
18:41:40 <jmcarthur> Eduard_Munteanu: type inference is not a very efficient algorithm
18:41:46 <pumpkin> my favorite laptop by far!
18:41:49 <hpc> can it be optimized?
18:41:57 <baguasquirrel> there's just some annoying parsing functions that take a lot of parameters
18:41:58 <pumpkin> hpc: nope, sorry!
18:41:59 <jmcarthur> pumpkin: i can't make myself buy a machine that doesn't even have a cd tray...
18:42:02 <baguasquirrel> I'm just trying to refactor it
18:42:07 <hpc> poo
18:42:13 <jmcarthur> hpc: afaik it's inherent
18:42:13 <baguasquirrel> and trying to figure out the best way to do so
18:42:20 <pumpkin> jmcarthur: I was happy to not have to carry one around, since I've used one maybe twice since I bought my other laptops
18:42:31 <pumpkin> (the ones that did have drives)
18:42:32 <hpc> ahaha, ghci is outputting the signature as it goes
18:42:41 <baguasquirrel> the kicker is that there's little overlap
18:42:42 <hpc> and whoa scroll
18:42:48 <pumpkin> everything else feels like a brick now by comparison
18:42:54 <baguasquirrel> so this isn't something I'd throw the reader monad at
18:43:01 <jmcarthur> pumpkin: i also can't stand the one-huge-button touch pads on macbooks nowadays
18:43:03 <maurer_> http://hpaste.org/41308/runintime
18:43:16 <pumpkin> jmcarthur: I didn't like it for the first twenty minutes I used it :P
18:43:19 <maurer_> This function will frequently take a long time to execute. What am I doing wrong?
18:43:22 <jmcarthur> pumpkin: it especially sucks for running linux because you have to go through a lot of hoops to make right-click-dragging not suck
18:43:24 <pumpkin> now I actually kind of like it
18:43:26 <maurer_> It seems like I should have a literal upper bound.
18:43:34 <pumpkin> jmcarthur: this is why you use mac os with it!
18:43:35 <Eduard_Munteanu> Damn asymptotes, "who needs 'em".
18:43:35 <pumpkin> :P
18:44:03 <jmcarthur> pumpkin: i was a mac guy for most of my life. it took a lot to make me switch over to linux. i don't have much desire to switch back
18:44:05 * pumpkin tries to decide how tight he wants his naturals to be
18:44:18 <jmcarthur> that sounds kinkier than i think it should
18:44:22 <pumpkin> ;)
18:44:30 <hpc> ahaha
18:44:32 <pumpkin> should I allow the high-order limbs to ever be 0?
18:44:49 <pumpkin> it's a little more math to do so
18:44:56 <hpc> pumpkin: no anatomy is complete without an enormous continuation ;)
18:44:57 <pumpkin> or rather, to prevent it
18:45:18 <jmcarthur> hpc: quit looking at pumpkin's monads
18:46:18 <pumpkin> :O
18:46:23 * jmcarthur paintstakingly creates a purely functional data structure using IORefs
18:46:36 <jmcarthur> *painstakingly, even
18:46:37 <pumpkin> so far I have an addition function that I've done one simple test on
18:46:39 <pumpkin> that it passed
18:46:43 <pumpkin> but it's hard to run any more tests on it
18:46:52 <pumpkin> maybe I'll write a Natural -> Integer to test it more easily
18:47:31 <jmcarthur> Int is to Integer as Word is to ??
18:47:38 <hpc> ByteString
18:47:39 <monochrom> indeed, it's almost like proving PA consistency by PA consistency
18:47:49 <jmcarthur> hpc: where's my Num instance?
18:48:01 <hpc> over there, behind the fence
18:48:04 <hpc> ignore the signs
18:48:25 <jmcarthur> Word has no signs
18:48:39 <hpc> then use OpenOffice ;)
18:48:40 <monochrom> Word has VB
18:48:47 * jmcarthur facepalms
18:48:52 <pumpkin> jmcarthur: Natural!
18:49:00 <pumpkin> jmcarthur: that's what I'm writing :)
18:49:01 <jmcarthur> pumpkin: but where is it?!
18:49:05 <pumpkin> on my text editor
18:49:06 <jmcarthur> pumpkin: ah!
18:49:10 <monochrom> Int is to Integer as Word is to Pandoc
18:49:13 <jmcarthur> please finish it and hackage it!
18:49:19 <pumpkin> yep, that's the goal :)
18:49:23 <pumpkin> I'm going to make a nice lazy one too
18:49:25 <pumpkin> on top of this one
18:49:27 <jmcarthur> monochrom: i wish i could punch people over the internet
18:49:36 <pumpkin> it'll be a bit like a difference list of GMP naturals
18:49:44 <monochrom> please don't punch me
18:50:02 <pumpkin> so adding should be pretty fast, I hope
18:50:22 <pumpkin> then maybe some nice benchymarkies
18:50:31 <jmcarthur> pumpkin: so you aren't doing the quickie newtype wrapper around Integer trick i suppose
18:50:33 <jmcarthur> :)
18:50:46 <pumpkin> jmcarthur: nope, the low-level mpn interface in GMP
18:50:51 <jmcarthur> alright cool
18:51:04 <pumpkin> which is surprisingly ugly
18:51:09 <pumpkin> I thought 5 was supposed to make it prettier
18:51:15 <monochrom> do you have an unsigned integer type in GMP?
18:51:15 <pumpkin> one of the main reasons I was looking forward to 5
18:51:15 <jmcarthur> Word should be named Nat instead
18:51:24 <pumpkin> monochrom: yeah, all the other GMP types are built on top of it
18:51:29 <pumpkin> it's this mpn thing I'm talking about
18:51:33 <pumpkin> multi-precision natural
18:52:00 <pumpkin> all the low-level machine-specific asm code in gmp is accessed through this interface
18:52:06 <monochrom> so for example a GMP integer is a sign and a GMP natural?
18:52:12 <pumpkin> more or less
18:52:21 <pumpkin> although not quite that simple iirc
18:52:31 <monochrom> I see.
18:53:24 <ddarius> jmcarthur: Years ago I considered setting up a service to do just that.
18:53:59 <monochrom> a service to rename Word to Nat?
18:54:01 <jmcarthur> to do just what?
18:54:13 <ddarius> Punch people over the Internet.
18:54:17 <jmcarthur> haha
18:54:19 <hpc> monochrom: not just that; it is polymorphic over everything!
18:54:20 <monochrom> please don't punch me
18:54:36 <hpc> monochrom: need to have cats renamed "emo puppies"?
18:54:40 <hpc> it can do that!
18:54:44 * pumpkin prods monochrom 
18:55:05 <monochrom> I guess eventually the service became "rename monad to fuzzy thing"
18:56:59 <codolio> Once pumpkin figures out how to bind to naturals, he can bind all the missing Integer functions.
18:57:51 <monochrom> what do you plan to do with (-) :: Natural -> Natural -> Natural?
18:58:25 <pumpkin> codolio: I did a couple of them ages but the patch still hasn't made its way into integer-gmp
18:58:35 <pumpkin> the bit-test one was handy
18:58:36 <codolio> Bah.
18:58:46 <pumpkin> since testing bits is fairly expensive on Integer right now
18:59:10 <codolio> You mean, like the Data.Bits stuff?
18:59:12 <pumpkin> monochrom: haven't quite decided yet. My idealist approach was to omit it completely
18:59:14 <pumpkin> yeah
18:59:14 <ddarius> unsafeCoerce to UArray Bool (after doing the case)
18:59:28 <pumpkin> monochrom: but that clearly won't aid adoption
18:59:32 <Eduard_Munteanu> @hoogle Data.Bits
18:59:32 <lambdabot> module Data.Bits
18:59:32 <lambdabot> Data.Bits class Num a => Bits a
18:59:32 <lambdabot> Data.Bits bitSize :: Bits a => a -> Int
18:59:34 <pumpkin> any suggestions
18:59:35 <pumpkin> ?
19:00:07 <Eduard_Munteanu> Is it that useful to do bitwise ops on Integer?
19:00:18 <ddarius> Eduard_Munteanu: Why wouldn't it be?
19:01:11 <RyanRN> Hi all, I have a quick question about generating syntax for another language (in this case C++) from Haskell.  I do this all the time when I'm writing compilers or other tools and I'm always torn as to how much structure to make it vs. simply pasting together strings.  If it's coming out the back of a compiler there's already a well-defined IL, so it's usually straightforward to translate that into text.  But if it's just for som
19:01:34 <Eduard_Munteanu> ddarius: dunno, I always also did some serialization when operating on bits, and it tended to depend on the actual representation. So I stuck with well determined fixed-sized stuff.
19:01:41 <RyanRN> "how structured to make it" that is ;-)
19:01:58 <hpc> Eduard_Munteanu: you can do little-endian Integer -> [Bool], and work from there
19:02:39 <jmcarthur> RyanRN: truncated after " But if it's just for som"
19:02:40 <pumpkin> for now even my addition is broken
19:02:45 <pumpkin> so don't hold your breaths
19:02:50 <Eduard_Munteanu> hpc: I see.
19:02:53 <RyanRN> Oh sorry, I'm an IRC newb… I guess there's a message length max
19:02:57 <jmcarthur> yes
19:02:59 <RyanRN> But if it's just for some one-off project it feels like overkill to define some minilanguage just to emit C++ code, but at the same time I hate to paste strings (or Docs) together.  Are there any nice packages for this on Hackage?  Or other examples of nice interfaces for spitting out C-ish code?
19:03:23 <jmcarthur> RyanRN: there's Language.C for C, but i know of nothing readymade for C++
19:03:35 <hpc> C++ would be a lot harder than C
19:03:38 <ddarius> Eduard_Munteanu: You can use Integers as sets.
19:03:42 <jmcarthur> yeah it would be really hard
19:03:59 <hpc> it almost makes Haskell look easy
19:04:10 <jmcarthur> hpc: it makes haskell look trivial, IMO
19:04:11 <Eduard_Munteanu> ddarius: hm, that makes sense, just like C-like bitsets.
19:04:14 <hpc> or, god forbid, perl
19:04:20 <Eduard_Munteanu> but on arbitrarily high numbers.
19:04:36 <RyanRN> Yes, covering all of C++ would certainly be hard… usually it's just a fraction I need.  I would just like to write expressions in an embedded minilang that spit out the text rather than doing lots of <+> myself (e.g. prettyclass).  Thanks a lot.
19:04:42 <jmcarthur> RyanRN: i have found that there isn't usually a big penalty for using an explicit AST in haskell
19:05:16 <jmcarthur> RyanRN: embedded languages are pretty easy to write :)
19:05:17 <monochrom> if you emit special c++, perhaps it is not much more work than c.
19:05:28 <RyanRN> Right… not much time/effort to just define an AST type and then generate that, introducing an extra step before going to text.
19:05:33 <jmcarthur> yeah, emitting is also much easier than parsing
19:05:48 <pumpkin> does cmm support string literals or some form of debug output?
19:06:15 <RyanRN> Righto, emitting is all I'm doing, just trying to think a little bit about what a nicer way to do it would be.  Thanks jmcarthur.  Language.C should be an inspiration at least.  I'll check it out.
19:06:27 <jmcarthur> RyanRN: Language.C is quite complex actually
19:06:40 <jmcarthur> RyanRN: it's a full parser and everything with a complete AST
19:06:46 <jmcarthur> way overkill
19:06:54 <jmcarthur> (i suspect, at least)
19:07:05 <monochrom> of course you won't even need to learn its parsing part
19:07:15 <jmcarthur> yeah, but even the AST is probably more complex than necessary
19:07:16 <RyanRN> oh, ok!  looking at the docs now… it's not just the pretty-printer… it's for parsing and analysis
19:07:41 <monochrom> you only need the AST and the pretty-printer
19:08:05 <monochrom> which is like saying "n + 1"
19:08:40 <RyanRN> So what I've done the last couple times I did this was just use a few plain old functions to capture common patterns — function apps, braces and indenting, etc.  While stopping a little short of making a proper AST.  (which would be slightly involved, even for the subset of C++ in this case). 
19:08:42 <jmcarthur> RyanRN: embedded languages are nice also because you can use overloading to make it look just like normal haskell, e.g. making an instance of Num and such
19:08:45 <monochrom> the value of this investment is few things can go wrong
19:08:49 <monochrom> err
19:08:53 <monochrom> the value of this investment is fewer things can go wrong
19:09:52 <RyanRN> jmcarthur:  Absolutely true regarding embedded languages… I hate reading any large pieces  of syntax written in ML or Haskell in a App(Lambda(Var("A")) (Var""A")) (Const (Int 3))) style… eek.  
19:10:20 <monochrom> moving from string to AST eliminates string literal escaping problems aka injection vulnerability eg http://xkcd.com/327/
19:10:21 <jmcarthur> RyanRN: yeah. for lambda calculus in particular: HOAS FTW! :)
19:10:29 <RyanRN> One small advantage of scheme… at least your quoted ASTs are no less readable than normal programs.  But can do fine with embedding or template haskell modulo the usual concerns about "if" not being overloaded, etc.
19:11:00 <jmcarthur> i wish more of haskell syntax was overloadable
19:11:15 <monochrom> and then, if you want to do more work for more profit, moving the AST from ADT to GADT eliminates some type errors in the emitting code
19:11:32 <jmcarthur> sometimes a GADT is a *lot* of work
19:11:59 <monochrom> yeah, not universally worth the money spent.
19:12:02 <jmcarthur> i was messing with a GADT representation for typed de bruin terms recently. substitution sucked
19:12:15 <jmcarthur> de bruijn? i always mix up the spelling
19:12:16 <RyanRN> Fair point re: GADT… a haskell specific benefit
19:12:52 <monochrom> err, eliminates some type errors in the emitted code
19:13:11 * monochrom makes many type errors today!
19:13:16 <jmcarthur> GADTs for emitted code is, again, easier than for code you are manipulating directly
19:13:17 <RyanRN> the spelling doesn't seem very phonetic in english ;-)
19:13:33 <jmcarthur> OMGADT
19:13:50 <ddarius> Substitution usually sucks.
19:14:17 <RyanRN> simon pj and daan leijen showed me a cool trick where you can use GADTs and phantom types to enable certain AST variants in only certain phases of a compiler — I hope I can remember it the next time I need it.
19:14:21 <jmcarthur> true. i should have said it sucked harder than usual
19:14:44 <RyanRN> (sort of similar to the effect of http://lambda-the-ultimate.org/node/1589)
19:17:16 <monochrom> with normal ADT AST like "data Exp = Plus Exp Exp | And Exp Exp | I Int | B Bool" you can accidentally have Plus (I 4) (B True) which is not nice. You can outlaw that with a suitable GADT.
19:17:36 <ddarius> You can also outlaw that without a GADT.
19:17:45 <jmcarthur> type classes are a fun way to do it
19:18:07 <DrSyzygy> ddarius: Without a GADT and without more than one datatype building into the expression type?
19:18:28 <ddarius> DrSyzygy: Yes, if I'm parsing what you are saying correctly.
19:18:34 <monochrom> is that by splitting into one type for bool expressions, one type for int expressions, etc?
19:18:45 <jmcarthur> class Exp e where plus :: e Int -> e Int -> e Int ; and :: e Bool -> e Bool -> e Bool ; int :: Int -> e Int ; bool :: Bool -> e Bool
19:19:04 <jmcarthur> then your interpreter is an instantiation of that class
19:19:18 <jmcarthur> tougher to do deep analysis and stuff, but for emitting it's great
19:19:45 <jmcarthur> and of course you can instantiate it with a GADT for analysis if you want, too...
19:20:13 <RyanRN> Nice, thanks
19:20:33 <DrSyzygy> How mainstream are GADTs?
19:20:40 <pumpkin> I use them all the time
19:20:44 <jmcarthur> GADTs are not uncommon
19:20:46 <DrSyzygy> Do I get the syntax by ghc flags, or is it part of H98?
19:20:47 <jmcarthur> i use them all the time as well
19:20:52 <jmcarthur> it's not H98
19:20:54 <pumpkin> DrSyzygy: GHC flags
19:20:57 <DrSyzygy> Aight.
19:21:06 <ddarius> DrSyzygy: They are popular and reasonably well understood.  They are definitely not Haskell 98.  They are relatively new to Haskell.
19:21:09 <jmcarthur> -XGADTs
19:21:13 <jmcarthur> {-# LANGUAGE GADTs #-}
19:21:18 <DrSyzygy> ddarius: Comprehensive answer. 
19:21:20 <DrSyzygy> jmcarthur: Thanks!!
19:22:13 <pumpkin> I'd love them in 2012
19:22:32 <pumpkin> but I doubt they'll make it
19:22:33 <ddarius> That ain't happening, but I see them being in some future standard of Haskell.
19:22:34 <Eduard_Munteanu> Do they stand any chance of getting in H' in 2012?
19:22:37 <Eduard_Munteanu> Oh.
19:23:06 <ddarius> I don't even expect multiparameter type classes to be in 2012, but I would love to be surprised.
19:23:34 <Eduard_Munteanu> Is this conservatism or are there technical issues with them?
19:23:51 <Eduard_Munteanu> (not that conservatism is bad)
19:25:00 * Eduard_Munteanu also finds it awkward not to have MPTC considering how many users are out there.
19:25:09 <jmcarthur> conservatism isn't bad unless you prefer to take "avoid success at all costs" to heart
19:25:11 <pumpkin> what's an expression of how much space addition will take, in terms of bit size and value of the addends?
19:25:28 <jmcarthur> in terms of bit size and... value?
19:25:36 <ddarius> pumpkin: max(n,m) + 1
19:25:43 <ddarius> Where n and m are the bit sizes.
19:25:47 <kmc> will the addition of mptc be delayed until the addition of fundeps and asstypes, and perhaps a decision of one over the other?
19:25:48 <pumpkin> ddarius: but the +1 isn't always necessary, and I'd prefer to be tight
19:26:02 <ddarius> Then you'd need to depend on the actual values.
19:26:03 <Eduard_Munteanu> Asstypes? :)
19:26:07 <kmc> yep
19:26:11 <kmc> class-associated types
19:26:14 <monochrom> the +1 is necessary for worst-case analysis
19:26:15 <Eduard_Munteanu> Oh.
19:26:20 <pumpkin> yeah, I included the values
19:26:42 <ddarius> kmc: Yes.
19:26:49 <pumpkin> monochrom: but for various reasons I need to make sure that the high-order limb/bit is nonzero
19:26:55 <pumpkin> it makes things easier down the line
19:27:24 <Eduard_Munteanu> jmcarthur: yeah, it isn't bad, I was just curious if there was something wrong at all with these extensions.
19:27:29 <kmc> i suppose... if the consensus is on asstypes, then mptc are orthogonal
19:27:34 <kmc> but people will want fundeps anyway
19:27:37 <kmc> lots of code uses them
19:27:50 <jmcarthur> funasstypes
19:28:36 <pumpkin> I guess it isn't possible to make a tight bound without actually computing the sum
19:29:09 <ddarius> pumpkin: You can avoid computing the whole sum in most cases, but yeah, in the worst-case you'll pretty much be doing the summation.
19:29:24 <monochrom> 11111 + 1
19:29:31 <ddarius> monochrom: Indeed.
19:29:48 <pumpkin> meh, shortening ByteArray# is painful
19:30:01 <pumpkin> maybe I should start carrying additional information around again
19:30:04 <pumpkin> like an offset into it
19:30:07 <monochrom> BA#
19:30:17 <dolio> Associated types are noticeably less powerful unless you include the equality constraint stuff that GHC has somehow.
19:30:27 <kmc> mm, right
19:30:28 <dolio> And I'm not sure everyone could get behind that.
19:30:42 <Eduard_Munteanu> Where would I look for a reference on asstypes? Or are they somehow implemented by type families, as Google suggests?
19:30:46 <kmc> they are
19:30:53 <kmc> read the GHC manual section on type families
19:30:54 <pumpkin> they're exactly a type family
19:31:00 <Eduard_Munteanu> I see, thanks.
19:31:04 <pumpkin> that happens to be loosely tied to a class
19:31:05 <kmc> an associated type [synonym] is just a type [synonym] family that's associated with a class
19:31:18 <Eduard_Munteanu> Oh.
19:32:03 <ddarius> dolio: The equality constraint stuff seems pretty well understood and is also one of the keys to GADTs, so I see them being added eventually, but probably after MPTCs are added. (Assuming the process works at all.)
19:32:08 <dolio> Of course, depending on how exactly you decide fundeps should work, they might work a lot like equality constraints.
19:32:19 <jmcarthur> there are things i like and dislike about both asstypes and fundeps
19:32:32 <ddarius> I'm strongly in favor of keeping both.
19:32:47 <pumpkin> me too
19:32:57 <pumpkin> the implementation of one could be in terms of the other
19:33:00 <pumpkin> once they're equivalent
19:33:12 * ddarius really needs to implement his "local modules" idea in GHC or something.
19:33:13 <kmc> i doubt ghc will lose either, but a language standardization process may want to be more conservative
19:33:18 <ddarius> Or at least as a hacky preprocessor.
19:34:00 <dolio> Well, the problem with implementing one in the other is that you can't, with the way they both work currently.
19:34:20 <ddarius> dolio: Which isn't too relevant for a potential future standard.
19:34:52 <dolio> Fundeps don't introduce type equalities, even when you might think they should.
19:34:56 <dolio> In return, they're allowed to overlap.
19:35:21 <dolio> Well, it's relevant in that you have to decide how they should actually work. And whether they should continue to work differently, etc.
19:38:21 <dolio> I sort of presume that SPJ will push for fundeps to work more like their implementation in type families would work.
19:38:46 <dolio> If it comes to that.
19:38:55 <ddarius> I suspect that's the way most people will lean.
19:39:17 <dolio> And I'm fine with that, because overlapping instances are obviously evil.
19:40:20 <dolio> At that point, which you include in the standard probably becomes irrelevant. They're just sugar for one another.
19:41:33 * hackagebot dbmigrations 0.3 - An implementation of relational database "migrations"  http://hackage.haskell.org/package/dbmigrations-0.3 (JonathanDaugherty)
19:44:40 <kmc> the standard sets a norm for which code people should actually write
19:45:42 <dolio> I'd probably expect it to mention both, their inter-implementation, and allow implementations to choose which is primitive.
19:45:58 <dolio> If it's even meaningful for them to do so.
19:48:40 <int80_h> good day people
19:48:40 <payo> hey, im doing a tutorial
19:48:45 <payo> is there something wrong with this code?
19:48:46 <payo> if name == "Simon" or "John" or "Phil" then
19:48:52 <payo> i also tried ||
19:49:06 <pumpkin> name == "Simon" || name == "John" || name == "Phil"
19:49:14 <payo> ahhhh
19:49:16 <payo> ok
19:49:17 <pumpkin> or name `elem` ["Simon", "John", "Phil]
19:49:26 <pumpkin> with the missing quote
19:49:32 <geheimdienst> > name `elem` ["Simon", "John", "Phil"] 
19:49:32 <lambdabot>   Not in scope: `name'
19:49:41 <int80_h> I'm trying to map a function over a list, but the function takes a string as a first argument. Can I use map, or is there another function for this kind of problem?
19:50:04 <int80_h> map funcFoo "string [list]
19:50:10 <int80_h> map funcFoo "string" [list]
19:50:16 <int80_h> something like that
19:50:20 <kmc> int80_h, it's a two-arg function?
19:50:23 <kmc> map (f "foo") list
19:50:33 <int80_h> kmc: thanks!
19:50:42 <kmc> > map (f 1) [a,b,c]
19:50:43 <lambdabot>   Ambiguous type variable `b' in the constraints:
19:50:43 <lambdabot>    `SimpleReflect.FromExpr ...
19:50:45 <kmc> :/
19:52:05 <kmc> int80_h, if you apply only some of a function's arguments, what you get back is a function to take the remaining arguments
19:52:44 <kmc> in truth, all functions have a single argument
19:52:47 <kmc> and may return a function to take another argument, etc.
19:54:05 <payo> yea its called curried funtions or partial application
19:54:22 <payo> curried functions would be the ones that take multiple args
19:56:46 <int80_h> kmc: thanks again :)
19:57:47 <deech> Hi all, I've been reading code from the transformers package and they use ~ in a way I haven't seen before
19:58:06 <ddarius> You should have read the Gentle Introduction.
19:58:21 * pumpkin tries to think of a good representation for naturals
19:58:32 <pumpkin> what metadata do I need to carry around, hmm!
19:58:33 <deech>  for example : do ~(a, w) <- listen m; return (a, f w)
19:58:51 <zecrazytux> hum... i've compiled a basic app with -threaded, and try to run it with -N2 but it says "unknown RTS option: -N2"
19:58:51 <ddarius> pumpkin: Why do you need to carry around metadata?
19:59:07 <deech> 'listen' however returns ((a, w), s', w)
19:59:24 <pumpkin> ddarius: well, lots of the mpn functions don't like leading zeroes on the operands, and I don't want to be shrinking the bytearrays
19:59:50 <pumpkin> ddarius: so second best seems to be to remember where the most significant limb sits, to avoid computing it every time
19:59:52 <deech> Just wondering how you can pattern-match a 3-tuple into a 2-ple
20:00:02 <zecrazytux> am i missing something ?
20:00:18 <pumpkin> zecrazytux: did you force recompilation?
20:02:30 <zecrazytux> I think so... i'm using cabal, and cabal build -v shows that I added -threaded
20:02:50 <kmc> deech, you can't pattern-match a 3-tuple against a 2-tuple
20:03:04 <kmc> deech, ~p is a lazy, irrefutable version of p
20:03:28 <kmc> it always succeeds, and does not force any evaluation, until the variables bound by p are forced
20:03:34 <kmc> > case Nothing of Just _ -> ()
20:03:35 <lambdabot>   *Exception: <interactive>:1:133-160: Non-exhaustive patterns in case
20:03:37 <kmc> > case Nothing of ~(Just _) -> ()
20:03:38 <lambdabot>   ()
20:03:41 <kmc> > case Nothing of ~(Just v) -> v
20:03:42 <lambdabot>   *Exception: <interactive>:1:133-162: Irrefutable pattern failed for pattern...
20:04:04 <payo> anyone know how to disable tabs in Notepad++
20:04:05 <payo> ?
20:04:07 <zecrazytux> pumpkin: well, something must have been kept in cache, I deleted dist/ and rebuilt it, and it doesn't complain anymore...
20:04:09 <payo> i think they cause errors
20:04:16 <zecrazytux> pumpkin: thanks for the hint
20:04:27 <kmc> deech, as to the other question, whatever 'listen' returns needs to be a monadic value; it's the *result* of that value which is matched against (a,w)
20:04:30 <pumpkin> zecrazytux: changing build settings won't rebuild modules
20:04:33 <pumpkin> so yeah, you need to clean
20:04:38 <pumpkin> or force recompilation
20:04:46 <kmc> because that's just sugar for:  listen m >>= \(~(a,w)) -> ...
20:05:19 <Cale> payo: http://stackoverflow.com/questions/455037/notepad-tabs-to-spaces -- the second answer here, perhaps
20:05:29 <deech> kmc: I see but in my example one of the values is being forced by applying f to it like (a,f w)
20:05:39 <kmc> that doesn't necessarily force w
20:05:45 <payo> kayy
20:05:49 <kmc> only if f forces its argument
20:06:00 <deech> Oh
20:07:20 <deech> kmc: As to your point about listen returning a monadic value, the last line inthe listen function is : return ((a, w), s', w)
20:07:50 <deech> So whatever the monad it's returning a triple.
20:07:55 <kmc> right
20:08:04 <kmc> then there's some missing piece here
20:08:17 <deech> Which is being irrefutably matched to (a,w)
20:08:37 <kmc> that should be a type error
20:08:42 <kmc> > case (1,2,3) of ~(a,b) -> ()
20:08:43 <lambdabot>   Couldn't match expected type `(t, t1, t2)'
20:08:43 <lambdabot>         against inferred type `(...
20:09:31 <deech> I'm quoting line 175 of Lazy.hs in the transformers package.
20:09:48 <kmc> which module?
20:10:10 <kmc> Control.Monad.Trans.Writer.Lazy ?
20:10:41 <kmc> the listen i see there is defined as:  listen m = WriterT $ do { ~(a, w) <- runWriterT m; return ((a, w), w) }
20:11:02 <tg_> if the big bang, at the very beginning, is thought to be infinitely dense (or just very very very .... very ... dense), then it's going to be infinitely hot until either: space expands OR the things inside don't interact with each other)
20:11:04 <tg_> err
20:11:15 * tg_ walks out of the room, very slowly
20:11:27 <deech> I have pasted the relevant portion here: http://hpaste.org/41309/transformers
20:11:39 <kmc> oh RWST not Writer
20:11:58 <deech>  Control.Monad.Trans.RWS.Lazy
20:12:23 <kmc> oh i see
20:12:35 <kmc> deech, note that the "do" block in "listen" is wrapped in the RWST constructor
20:12:59 <deech> Yes
20:13:06 <kmc> RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
20:13:21 <kmc> so, the action inside that constructor has type m (a, s, w)
20:13:27 <kmc> sorry
20:13:37 <kmc> m ((a, w), s, w)
20:13:49 <deech> Ok
20:13:54 <kmc> and the the constructor transforms a function of type
20:13:57 <kmc> r -> s -> m ((a,w), s, w)
20:14:04 <kmc> into a value of type RWST r w s m (a, w)
20:14:06 <kmc> as promised
20:14:08 <kmc> by the type sig
20:16:20 <deech> So what is the ~(a,w) in listens?
20:17:17 <jmcarthur> all ~(a,w) means is "bind a and w without forcing the tuple until either a or w is forced"
20:18:00 <jmcarthur> or at least that's what it means operationally
20:19:12 <deech> right, I was wondering how it is being used in the context of the 'listens' function : http://hpaste.org/41309/transformers
20:19:19 <kmc> deech, the (a,w) in listens is just binding the (a,w) prdouced by that RWST action
20:19:22 <jmcarthur> in other words, "don't do anything. i just want these names"
20:19:32 <kmc> the fact that it's an irrefutable pattern is a secondary detail
20:20:35 <deech> Does it have to do with how the Monad instance for RWST is defined?
20:21:09 <kmc> sort of
20:21:27 <kmc> because it's sugar for
20:21:30 <kmc> listen m >>= \(a,w) -> ...
20:21:33 <kmc> ignoring the ~ again
20:21:34 <ymasory> hi is there a built-in function for counting the number of occurrences of an element in a list?
20:21:48 <kmc> ymasory, count p = length . filter p
20:21:54 <kmc> but maybe there's something direct in Data.List
20:22:06 <kmc> deech, and so that invokes (>>=) from the RWST Monad instance
20:22:27 <ymasory> thanks kmc
20:22:55 <deech> Wait I get it now ... in the definition of "m >>= k" for RWST, 'k' is applied to the 'a' of (a,s,w)
20:23:34 <deech> and the 'a' itself is a tuple, so '<-' does unpack a tuple.
20:23:57 <deech> cool
20:29:49 <ymasory> oh wait that requires an explicit predicate
20:29:52 <ymasory> oh well
20:30:29 <deech> kmc: Thanks ... I appreciate the help.
20:34:44 <int80_h> :q
20:35:56 <kmc> E37: No write since last change (add ! to override)
20:41:35 <deech> Reading Control.Monad.Trans.RWS.Lazy and Control.Monad.Trans.RWS.Strict it appears that both modules are identical except that Lazy uses irrefutable pattern-matching ~(a,b) and Strict uses the regular kind. Was it really necessary to replicate most of the code? 
20:46:24 <Axman6> deech: ~(a,b) is lazy pattern matching i thinkk
20:46:43 <Axman6> -k
20:46:59 <deech> Axman6: It is. I was just amazed that both modules are identical line-for-line except the '~'.
20:47:25 <deech> Seems like a crazy amount of boilerplate.
20:48:08 <Axman6> heh, indeed
20:50:09 <deech> Normally I'm amazed by how terse Haskell is, here it seems much more verbose. Weird.
20:50:22 <Eduard_Munteanu> How is that lazier than the non-'~' version?
20:50:25 <monochrom> If you find a way to factor out "just the strictness but nothing else", I like to know too.
20:51:15 <monochrom> Meanwhile, enjoy the fact that you now know exactly the difference between the Strict version and the Lazy version.
20:51:37 <djahandarie> monochrom, TH could surely do it
20:52:26 <deech> monochrom: I'm not trying to bad-mouth the author's code. 
20:52:27 <danharaj> I think the problem is that strictness annotations really exist on top of the lambda calculus rather than within it, so you can't manipulate it like you could 'ordinary' code.
20:52:51 <danharaj> Which isn't that much of a problem in practice.
20:53:13 <djahandarie> Is there a lambda calculus with embeded strictness semantics?
20:53:23 <danharaj> I don't know. I don't think it would be very natural.
20:53:24 <monochrom> I wouldn't call it a crazy amount of boilerplate.
20:53:37 <monochrom> In fact I wouldn't even call it boilerplate.
20:53:48 <Eduard_Munteanu> CPP defines could surely do it, I don't know about TH.
20:53:50 <danharaj> There's also the fact that strictness annotations are fine tuned, there isn't a regular structure for TH to exploit, unless you want to make everything strict.
20:54:02 <danharaj> Or is there? I haven't used TH
20:55:37 <djahandarie> I know that there has been strictness analysis / transformation that was done with TH 
20:55:58 <monochrom> I guess you could CPP it.
20:56:28 <danharaj> maybe there should be a flag that tells GHC to ignore strictness annotations
20:56:37 <danharaj> so that you can have both versions built from the same code
20:56:51 <djahandarie> That seems like a fairly ugly hack
20:56:56 <danharaj> yeah probably
20:57:21 <danharaj> I think laziness/strictness is an ugly aspect of Haskell though ;)
20:57:34 <djahandarie> What do you like then?
20:57:52 <danharaj> I don't know, it is an ugly thing that can't be ignored.
20:58:01 <djahandarie> lol
20:58:03 <danharaj> I think part of it could be dealt with if Haskell distinguished data and codata.
20:58:33 <deech> danharaj: It seems like an ugly aspect of any language. I don't know how many times I've found myself wanting infinite lists in strict languages.
20:59:37 <danharaj> deech: yeah, languages need to allow you to have both, Haskell lets you.
20:59:46 <danharaj> But then Haskell has to let you fine tune it, hence the ugliness.
20:59:46 <monochrom> yeah, you can only move this ugliness elsewhere. working around lack of nonstrictness is ugly.
21:00:21 <danharaj> I don't know how bad a strict by default, but lazy annotations available, language would be.
21:00:31 <danharaj> It would have different performance characteristics from Haskell, to be sure.
21:01:00 <deech> danharaj: Well I work in Java, so I'd be happy with closures right about now.
21:01:03 <danharaj> heh
21:02:10 <deech> I think Clojure tries to be both without the user having to deal with it. It has immutable lazy data structures, but is strict and has ref's.
21:08:02 <monochrom> I think I like this way: http://homepages.inf.ed.ac.uk/wadler/topics/recent.html#lazyinstrict
21:08:44 <monochrom> which is what all of you said, I suppose. :)
21:10:19 <deech> I don't see it on that page.
21:10:29 <danharaj> http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html
21:10:40 <danharaj> I think it's the first item?
21:10:50 <monochrom> darn
21:11:45 <monochrom> yes, language-design.html, first item, "how to add ... without even being odd"
21:31:21 <lars9> how is continuation implemented, with an individual stack for each cont.?
21:31:52 <kmc> in Haskell?
21:31:58 <Cale> You mean the continuation monad?
21:32:01 <kmc> there's no special continuation values in Haskell
21:32:22 <Cale> It's just functions (a -> r) -> r
21:32:29 <kmc> the Cont monad is syntactic sugar for a continuation-passing-style transform, which is something you can do in any language with functions
21:32:40 <lars9> in scheme, lisp etc
21:32:49 <kmc> the compiler / whatever doesn't know anything about continuations
21:33:01 <kmc> different scheme compilers are free to take different approaches to implementing scheme's first-class continuations
21:33:15 <kmc> they can use a CPS transform, or something else
21:33:50 <lars9> is Monad.Cont 1st class cont.?
21:33:59 <kmc> not really
21:34:05 <kmc> it's just sugar for a continuation passing style transform
21:34:40 <lars9> kmc: i see, it seems transformer is important, i've not leart it yet
21:35:00 <kmc> you can read the source to the Cont monad
21:35:03 <kmc> it is very short
21:35:07 <kmc> though mind-bending
21:35:59 <dobblego> does there exist Eq a, Foldable f => f a -> f a -> Bool ?
21:36:43 <kmc> pointwise?
21:36:47 <lars9> kmc: talking about source, can you understand how this short code implements memoization in haskell? http://hackage.haskell.org/packages/archive/MemoTrie/0.4.9/doc/html/Data-MemoTrie.html
21:37:17 <lars9> there is a 'Source' link
21:39:12 <kmc> maybe later
21:39:14 <kmc> busy now, sorry
21:39:24 <lars9> kmc: sure
21:40:02 <lars9> @hoogle on
21:40:02 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
21:40:02 <lambdabot> Text.PrettyPrint.HughesPJ OneLineMode :: Mode
21:40:02 <lambdabot> Text.Parsec.Char oneOf :: Stream s m Char => [Char] -> ParsecT s u m Char
21:40:31 <dobblego> @type \a b -> Data.Foldable.toList a == Data.Foldable.toList b
21:40:31 <lambdabot> forall (t :: * -> *) a (t1 :: * -> *). (Data.Foldable.Foldable t, Data.Foldable.Foldable t1, Eq a) => t a -> t1 a -> Bool
21:42:14 <kmc> :t (==) `on` Data.Foldable.toList
21:42:15 <lambdabot> forall (t :: * -> *) a. (Eq a, Data.Foldable.Foldable t) => t a -> t a -> Bool
21:42:19 <kmc> :t F.toList
21:42:20 <lambdabot> Couldn't find qualified module.
21:42:20 <dobblego> indeed
21:43:41 <dcoutts__> Gracenotes: hia, we made some progress on the hackage server at BelHac
21:46:17 <bblum> hey guys, is there a way to go from Word32 to Int, like the opposite of fromIntegral?
21:46:33 <Saizan> bblum: fromIntegral works in both directions
21:46:45 <Saizan> > fromIntegral (10 :: Word32) :: Int
21:46:46 <lambdabot>   10
21:47:12 <bblum> ohh, i see
21:47:19 <bblum> missed that, i guess
21:47:20 <bblum> thanks!
21:47:24 <Saizan> np
21:50:51 <bblum> oh, hm
21:51:20 <bblum> i have a Word32, and i want to do a 32-bit signed comparison against 0 to see if it's negative
21:51:34 <bblum> but turning it into an Int doesn't work because Int is 64 bits...
21:51:45 <bblum> the best i can come up with is comparing it against INT_MIN, which, ugh
21:51:54 <Saizan> Int32 ?
21:51:54 <bblum> any idea?
21:51:57 <bblum> hm
21:52:29 <bblum> that looks to work
21:53:11 <bblum> i guess explicitly annotating the type is the best way to go
21:55:58 <Gracenotes> dcoutts__: woo!
21:56:06 <dcoutts__> :-)
21:56:35 <dcoutts__> Gracenotes: tested importing all the old data from hackage and we worked on the mirror client
21:57:39 <Gracenotes> did you encounter the out-of-memory error at some point? (not doing revdeps circumvents it, but not doing other things would probably too..)
21:58:45 <Gracenotes> oh hm http://downforeveryoneorjustme.com/code.haskell.org
21:59:33 <stepcut> Gracenotes: yeah.. for days
22:00:19 <Gracenotes> I did try that last friday.. no success
22:02:15 <djahandarie> Gracenotes, hackage is going well?
22:04:53 <Gracenotes> djahandarie: peachy, though not much hacking in october
22:05:46 <djahandarie> I should really send you some of the stuff I've been sitting on rather than just sitting on it
22:06:06 <Gracenotes> keeping it warm, though? :)
22:06:59 <Hugglesworth> Is there any reason that a haskell script would be doing math differently between a 64 and a 32 bit system?
22:07:09 <Gracenotes> sorry, mixed metaphors. but nice
22:07:32 <Hugglesworth> I'm getting the right answer, but my bud is getting the wrong answer. the entire thing is deterministic and we're using the same values
22:07:49 <Enigmatic> Hugglesworth: integer or floating point?
22:08:11 <Hugglesworth> I'm using both (/) and div, so there's at least some floats
22:08:23 <Hugglesworth> inputs and outputs are both whole
22:08:52 <Cale> Which one of you has a 64 bit machine, and are you using Int?
22:08:57 <Cale> (Or Integer)
22:09:09 <Hugglesworth> I'm using the 64 bit machine
22:09:16 <Hugglesworth> I'm using Int
22:09:25 <Cale> Is it easy to switch the program to Integer?
22:09:36 <Hugglesworth> https://github.com/raposalorx/dozdate/blob/master/dozdate.hs -- here's the short script. I've already been yelled at about the non-haskell-ness of it
22:09:39 <Cale> (Integer is arbitrary precision)
22:09:42 <Hugglesworth> no clue, I'd have to try
22:10:05 <Cale> Yeah, shouldn't be hard
22:10:33 <Cale> Replace each occurrence of Int with Integer, and see if that works :)
22:10:45 <Hugglesworth> it does
22:10:52 <Hugglesworth> compiles and works as before
22:11:00 <Hugglesworth> I'll throw it to my friend
22:11:03 <Cale> It'll be machine independent that way
22:12:30 <Hugglesworth> so it could be cutting off the Ints that are more than 4-bytes?
22:12:42 <Hugglesworth> (if there are any...)
22:13:21 <Eduard_Munteanu> Hugglesworth: not sure what you mean... Integer has no size limitation.
22:13:24 <ymasory> is there a version of ! for associative maps that lets me provide a default value in case the key is not found?
22:13:37 <Hugglesworth> Eduard_Munteanu: I was using Int
22:13:43 <dobblego> ymasory, findWithDefault
22:13:59 <dobblego> ymasory, also, lookup returns Maybe (then fromMaybe)
22:15:16 <ymasory> thank you
22:16:07 <Gracenotes> associative maps? are those [(a, b)]?
22:16:59 <pygmalion> what's the best way to take an integer i.e. 123 and return a list of integers [1,2,3]?
22:17:05 <pygmalion> is there a built in function for the purpose?
22:17:11 <dobblego> map read
22:17:22 <dobblego> > map read "123" :: [Int]
22:17:22 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
22:17:22 <lambdabot>         against inferred ty...
22:18:00 <dobblego> > map ord "123" :: [Int]
22:18:01 <lambdabot>   [49,50,51]
22:18:04 <dobblego> blah
22:18:07 <dobblego> > map digitToInt "123" :: [Int]
22:18:08 <lambdabot>   [1,2,3]
22:18:10 <dobblego> yeah that :)
22:18:21 <dobblego> > map digitToInt "123"
22:18:22 <lambdabot>   [1,2,3]
22:19:08 <Hugglesworth> Cale: that looks like it might have fixed it; thanks mate.
22:19:14 <pygmalion> is there a built in function for the purpose?
22:19:18 * Hugglesworth huggles Cale
22:19:18 <pygmalion> whoops sorry
22:19:28 <pygmalion> thanks dobblego 
22:19:36 * payo scans Hugglesworth
22:19:41 * payo for life signs
22:19:56 <pygmalion> :q
22:20:02 <pygmalion> ah fail
22:20:35 <kmc> E37: No write since last change (add ! to override)
22:21:26 <Enigmatic> :q!
22:21:28 <Enigmatic> :P
22:47:52 <payo> hey, howcome this returns a type error:
22:47:55 <payo> tailsGTfive [[n]] = [[tail x:xs] | [x:xs] <- [[n]], x > 5]
22:48:18 <payo> error says 'couldnt match expected type Int against inferred type [a]
22:48:20 <payo> '
22:48:56 <kmc> too many []  brackets
22:49:05 <kmc> each introduces a new level of list nesting, is that what you want?
22:49:09 <payo> yea
22:49:26 <Saizan> you're applying tail to x
22:49:33 <payo> its supposed to take a list of lists of int and return a list of lists of the tails of those lists where the head is greater than 5
22:49:34 <Saizan> but x is a number
22:49:35 <payo> oh i see
22:50:16 <Saizan> are you aware that the [[n]] patter matches only a singleton list of a singleton list?
22:50:24 <payo> no...
22:50:32 <payo> im trying to do an example in a tutorial so...
22:50:59 <Saizan> i think you're a bit confused on how pattern matching works for lists
22:51:05 <payo> still it shouldnt be giving a type error 'expected type Int but inferred type [a]'
22:51:10 <payo> yea im rather confused about it
22:51:31 <McManiaC> how do you undo unrecorded changes in darcs?
22:51:33 <payo> its my first programming language and im learning haskell, but its rather complicated
22:51:47 <Saizan> in types [[a]] means "the type of lists of lists of a"
22:52:06 <Saizan> but at the value level [x] builds a singleton list where x is the only element
22:52:25 <Saizan> it's syntactic sugar for (x:[])
22:52:41 <Veinor> a monkey with an x on its head
22:52:43 <Saizan> maybe you should stick to using only (:) and [] at the value level for a while
22:53:02 <Saizan> payo: which tutorial/book are you following?
22:53:17 <McManiaC> Veinor: lol
22:53:21 <payo> um... lemme see
22:53:34 <payo> http://en.wikibooks.org/wiki/Haskell/List_processing
22:53:44 <payo> this is the best tutorial for beginners i've been able to find..
22:53:58 <McManiaC> !lyah
22:54:04 <payo> tailsGTfive [[n:ns]] = [[tail (x:xs)] | [x:xs] <- [[n:ns]], x > 5] 
22:54:21 <McManiaC> @where lyah
22:54:21 <lambdabot> http://www.learnyouahaskell.com/
22:54:31 <Saizan> yeah, we usually recommend lyeah
22:54:32 <shachaf> Veinor: Or is it a dead monkey with nostrils?
22:54:35 <Saizan> *lyah
22:55:05 <Saizan> payo: it seems you think you're required to put as many brackets as they appear in the type, but it doesn't work like that
22:55:46 <Saizan> payo: what should 'n' represent there? the first list or the first element of the first list?
22:56:03 <Saizan> probably the latter as n is usually for numbers
22:56:04 <payo> first element of the first list
22:56:08 <Eduard_Munteanu> It's actually 3 levels deep in the argument match
22:56:12 <payo> well its actually a list of lists
22:56:18 <payo> its a list of lists of Ints
22:56:30 <payo> so the type declaration is [[Int]] -> [[Int]]
22:56:43 <Saizan> "tailsGTfile ((n:ns):nss) = ..." -- it should look like this then
22:56:53 <Saizan> ns will be the rest of the first list
22:57:01 <Saizan> and nss will be the other lists
22:57:01 <Eduard_Munteanu> [[n:ns]] :: [[[a]]]
22:57:18 <payo> lawl this is complicated 
22:57:36 <Saizan> > let f ((n:ns):nss) = (n,ns,nss) in f [[1,2,3],[4,5,6],[]]
22:57:37 <lambdabot>   (1,[2,3],[[4,5,6],[]])
22:58:01 <Saizan> payo: only at the start :)
22:58:03 <Eduard_Munteanu> payo: well usually you combine other simpler stuff to achieve what you want
22:59:09 <Eduard_Munteanu> But I guess that's just an exercise. Real life is easier :)
22:59:16 <Saizan> maybe read the part of http://www.learnyouahaskell.com/ where it explains lists/pattern matching too, it helps to get multiple perspectives
23:13:18 <FillinG> Yup bros, my name str8 cold chilli Tomek B I repp north Phoenix, fill me/ i'ma try 2 be's a rappa n shit, here's some hot beatz: http://www.youtube.com/watch?v=0kL9wv3kMSU <-- CHECK THIS HOT SHIT AND TELL ME WHAT U THINK, FEEL ME?
23:14:10 --- mode: ChanServ set +o Saizan
23:15:04 --- mode: Saizan set -o Saizan
23:17:27 <Eduard_Munteanu> We should have a lightsaber sound whenever somebody +o's himself.
23:17:49 <Eduard_Munteanu> That's how I picture it.
23:18:17 <Saizan> heh, i left the sound effects in my other robe
23:18:23 * geheimdienst lights his saber. uh ... now what?
23:18:48 <Eduard_Munteanu> Zzzzuum...
23:18:48 <Saizan> http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf <- btw, this design is pretty great
23:23:22 <Saizan> it wouldn't work for the "default instance" use case though
23:23:39 <Saizan> but that doesn't work so well with OverlappingInstances either
23:42:02 * geheimdienst read the paper's abstract with interest, tried to understand what the paper is about but failed
23:47:21 <Saizan> basically if currently you want to write a function with overlapping patterns at the type level, your only choice is FunctionalDependencies + OverlappingInstances (type families won't help)
23:48:18 <Saizan> the problem is that OverlappinInstances make it hard to reason about your program because you can get different instances picked for the same types via the module system or higher rank polymorphism
23:48:51 <Saizan> also, they aren't even expressive enough, forcing you into subtle and ugly encodings of backtracking
23:49:18 <Saizan> the paper introduces a different extension that solves both those problems
23:49:37 <geheimdienst> okay, sounds plausible
23:49:42 <geheimdienst> thanks for the summary
23:50:27 <Saizan> np
23:53:17 <Saizan> now, if only i could find the implementation..
