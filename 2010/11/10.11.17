00:00:06 <ksf> everything can be done in O(infinity)
00:00:12 <HWSOD> kmc: uhh yes they do. what was I thinking of..
00:00:14 <dankna> infinity isn't a number
00:00:19 <Eduard_Munteanu> ilab: hm yes, I was actually looking for a least O(), that's not really equivalent to theta.
00:00:24 <dankna> but I take your point
00:00:33 <ClaudiusMaximus> thanks everyone, i think i'll give up trying to optimize this algorithm, as clearly exponential output requires exponential time, and that's indeed hellish; i did get it to be ~100x faster than it was before yesterday, so I'm happy enough
00:00:36 <lars9> if there is no {...} after "module MyModule" all classes, types and functions will be exported?
00:00:38 <HWSOD> dankna yes it is.
00:00:49 <dankna> ohhhh no, I'm not getting drawn into this
00:00:49 <kmc> lars9, it's ( ) not { } but yes
00:01:01 <lars9> kmc: thanks
00:01:01 <ilab> There's tons of open problems where an algorithm is suspected to be asymptotically tight to its upper bound, but agood enough lower bound has not yet been established.
00:01:12 <dankna> it's a quantity but it's not an actual number; that's my position, which is all I'm saying on the subject :)
00:01:23 <monochrom> what is a number, really?
00:01:32 <HWSOD> ?
00:01:38 <lars9> ClaudiusMaximus: is it a permutation?
00:01:39 <ksf> numbers are what you count on your fingers.
00:01:45 <Eduard_Munteanu> Is there a name for the least O()? I could give a definition at least.
00:01:47 <Jafet> @src Num
00:01:47 <lambdabot> class  (Eq a, Show a) => Num a  where
00:01:47 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:01:47 <lambdabot>     negate, abs, signum     :: a -> a
00:01:47 <lambdabot>     fromInteger             :: Integer -> a
00:01:53 <ksf> er what you measure by fingers.
00:02:06 <ClaudiusMaximus> lars9: Lavaurs' Algorithm
00:02:07 <ksf> it's an equally vain question as time.
00:02:09 <kmc> ∞ is not a number, but ω and ℵ₀ are
00:02:24 <HWSOD> kmc: fair enough.
00:02:32 <kmc> different types too :)
00:02:46 <Jafet> ∞ is not not a number, 0/0 is not a number
00:02:56 <kmc> ℵ looks so much better in the non-monospace font...
00:03:02 <Eduard_Munteanu> Say x is O_min(f(n)) iff \forall g(n) such that x is O(g(n)) -> g(n) >= f(n)
00:03:04 <lars9> wowo, ClaudiusMaximus' secret blog: http://claudiusmaximus.goto10.org/cm/2010-11-13_lavaurs_algorithm.html
00:03:07 <kmc> > 0/0
00:03:07 <lambdabot>   NaN
00:03:08 <ilab> Eduard)Munteanu: in math you'd say that's the supremum
00:03:20 <pelotom_> is there a transfinite data type in haskell? :P
00:03:33 <Eduard_Munteanu> ilab: yeah, but how does that fit with asymptotic complexity notation?
00:03:44 <lars9> ClaudiusMaximus: looks awesome
00:04:02 <pelotom_> Eduard_Munteanu: Ω?
00:04:22 <HWSOD> jafet: okay you convinsed me.
00:04:28 <Eduard_Munteanu> I think Ω only differs in strictness of the inequality sign
00:04:32 <kmc> pelotom_, you can define naturals and then write ω
00:04:47 <ClaudiusMaximus> lars9: :)
00:04:51 <kmc> @let ω = fix (In . Just)
00:04:52 <lambdabot>  Defined.
00:04:59 <Jafet> Not sure of what I convinced you, but okay.
00:05:04 <ilab> Eduard_Munteanu: usually you just say the upper bound is asymptotic
00:05:09 <Eduard_Munteanu> erm, no, it's reversed in omega
00:05:11 <kmc> here we use the isomorphism Nat ~ Mu Maybe
00:05:12 <kmc> :t ω
00:05:13 <lambdabot> parse error on input `??'
00:05:25 <kmc> φ you lambdabot
00:05:30 <monochrom> hahaha
00:05:42 <HWSOD> What set is Mu?
00:05:43 <monochrom> @remember kmc φ you lambdabot
00:05:43 <lambdabot> Good to know.
00:05:53 <kmc> @src Mu
00:05:53 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
00:05:54 <Jafet> @vixen φ
00:05:55 <lambdabot> People think I'm weird...   do you?
00:05:58 <kmc> @kind Mu
00:05:59 <lambdabot> (* -> *) -> *
00:06:00 <monochrom> @type L.ω
00:06:01 <lambdabot> parse error on input `L.??'
00:06:14 <kmc> it seems @type is allergic to Unicode
00:06:29 <pelotom_> this Mu stuff is hard for me to decode
00:06:44 <kmc> pelotom_, do you know how "fix" works at value level?
00:06:51 <Jafet> > typeOf ω
00:06:52 <lambdabot>   No instance for (Data.Typeable.Typeable (L.Mu Data.Maybe.Maybe))
00:06:52 <lambdabot>    arising...
00:06:56 <ksf> ooooh hopscotch hasing is even more ingenious once you break through the obfuscation barrier.
00:07:04 <pelotom_> kmc: yeah
00:07:13 <Eduard_Munteanu> ilab: yeah it made me unhappy, that's why I kinda tacitly accepted theta was a better pick usually
00:07:14 <kmc> http://www.vex.net/~trebla/haskell/fix.xhtml is a great explanation of fix btw
00:07:18 <xplat> yeah, fix S is more similar to ω*
00:07:19 <kmc> pelotom_, Mu is like that at type level
00:07:30 <kmc> data Mu f = In (f (Mu f))
00:07:32 <ksf> though I must admit the obfuscation is most likely not on purpose. it's just badly explained.
00:07:37 <kmc> fix f = f (fix f)
00:07:44 <pelotom_> kmc: right, I sort of knew that, and yet it still evades comprehension a little bit :)
00:07:54 <kmc> aside from the ctor "In" (needed because Haskell has isorecursive types and not equirecursive types), they're very close
00:07:57 <kmc> so for example
00:07:58 <ilab> Eduward_Munteanu: but theta implies an asmyptotic lwoer bound as well
00:08:00 <ksf> never attribute to obfuscation what can equally well be explained by lacking literacy.
00:08:10 <kmc> data ListF a list = Nil | Cons a list
00:08:16 <kmc> type List a = Mu (ListF a)
00:08:25 <kmc> data NatF n = Zero | Succ n
00:08:29 <kmc> type Nat = Mu NatF
00:08:37 <kmc> note that both ListF and NatF are non-recursive types
00:08:50 <kmc> but List and Nat are recursive
00:08:50 <pelotom_> kmc: so "list" there is a type function?
00:08:57 <kmc> yeah, it's just a type synonym
00:09:03 <Eduard_Munteanu> ilab: yeah, but in case there exists a theta, it's more accurate to speak of that instead of O. It's also the best O like I defined it.
00:09:16 <kmc> that's Haskell 98, you don't need type families or anything
00:09:30 <pelotom_> kmc: I mean the lower-case "list" type argument to ListF
00:09:35 <kmc> oh, sorry
00:09:47 <kmc> it has kind *
00:09:58 <kmc> as evidenced by it being used as the type of a constructor field
00:10:05 <kmc> so i'd say it's not a type function
00:10:10 <kmc> data ListF a list = Nil | Cons a list
00:10:14 <kmc> data List a = Nil | Cons a (List a)
00:10:24 <kmc> so the variable "list" stands for the type that's being defined
00:10:41 <kmc> just like:  fix $ \self n -> if n == 0 then 1 else n * self (n-1)
00:10:46 <kmc> self stands for the function being defined
00:10:54 <kmc> in both cases they're arbitrarily named variables
00:11:38 <Axman6> anyone know how to make ghc use -fllvm by default in a .cabal/config file? flags: -fllvm ... doesn't seem to work
00:11:44 <HWSOD> kmc: you mean hopscotch hashing? For some reason I thought you meant hazing like in a frat.
00:11:57 <monochrom> something about ghc-options
00:13:07 <monochrom> oops, ghc-options is for project.cabal files. I don't know what to do in .cabal/config
00:13:16 <Axman6> hmm
00:13:43 <kmc> what
00:13:56 <kmc> what did i say about hazing
00:14:27 <kmc> pelotom_, makes sense?
00:14:31 <monochrom> <ksf> ooooh hopscotch hasing is ...
00:14:53 <HWSOD> You typod hashing to hasing I readod hasing to hazing.
00:15:10 <monochrom> you also typod ksf to kmc
00:15:29 <Axman6> monochrom: heh, if you're ever wondering, just rename the .cabal.config file, and run cabal-install, and it'll make a new default one, with all the things it supports
00:16:13 <HWSOD> god, am I bad with names..
00:17:04 <lars9> is llvm really good? i compared clang with gcc on some of my algorithm-practice programs, gcc -O2 outperforms clang
00:17:25 * monochrom secretly renames to momochron to confuse everyone
00:18:05 <ksf> gcc-llvm alledgedly is en par.
00:18:06 <Jafet> chronomom
00:18:15 <ksf> so it's the C-specific stuff clang isn't as good as.
00:18:15 <monochrom> or even better, someone should call himself/herself momochron and start arguing with me
00:18:21 <geheimdienst> mom'o'chron
00:19:03 <geheimdienst> monochrom, that's been done. about 60% of this channel is pseudonyms for geheimdienst
00:19:04 * ddarius suspects "momochron" would hash differently in xchat thus appearing quite different than "monochrom."
00:19:43 <lars9> ksf: sorry what is en par? :)
00:19:53 <monochrom> ddarius is right but about 60% of this channel is still at irssi or something
00:20:46 <Axman6> lars9: depends which optimisations you turn on with llvm if it'll produce awesome code. right now clang's main goal is to be a drop in replacement for gcc which is better for the programmer
00:20:56 <ksf> lars9, something even more elitistic than "per se"
00:21:12 <ksf> read it as "head-on-head"
00:21:36 <monochrom> is it like "on par"?
00:21:55 <ksf> my french's too good to use that.
00:21:57 <lars9> is it english?
00:22:16 <monochrom> is "us$ and cdn$ are en par" right?
00:22:16 <ksf> au contraire.
00:22:36 <kmc> "on par with ..." is fairly standard english, would not be considered pretentious i think
00:22:41 <flux> fun fact: perse means ass in Finnish.
00:22:43 <kmc> i don't know about spelling it "en"
00:22:49 <Axman6> urgh, is there seriously no way to specify in .cabal/config what flags to pass to ghc?
00:22:55 <kmc> http://blog.sendapatch.se/2010/february/this-might-seem-silly-git-pull.html
00:23:09 <geheimdienst> saying on par is en vogue
00:23:32 * ksf shudders at the thought of an american pronouncing that "en"
00:23:57 <Axman6> "wtf is npar?
00:23:58 <Axman6> "
00:24:06 <ksf> shure it sounds a bit like "on", but don't forget the nasality.
00:24:15 <ksf> sure, even.
00:24:45 <geheimdienst> Axman6: tried "--ghc-option=-abc" ?
00:25:05 <Axman6> sure, but i don't want to have to do that everytime i use cabal-install
00:25:16 <Axman6> i want it in the .caba./config file
00:25:19 <Axman6> l*
00:25:40 <monochrom> perhaps "flags: --ghc-option=-abc" is worth a try
00:25:54 <Axman6> maybe, but it interprets -- as a comment
00:25:58 <geheimdienst> yeah, sorry, i meant putting it in the config file. i thought any command line option could be put in the conf file ...?
00:26:01 <monochrom> oh oops
00:26:01 <Axman6> but, i'll try
00:26:19 <ksf> try ghc-options:
00:26:23 <ksf> try ghc-options: -abc
00:26:26 <monochrom> yes, .cabal/config lacks doc
00:26:46 <Axman6> ksf: tried that
00:27:13 <ksf> write a wrapper script passing --ghc-option=-abc
00:27:23 <Axman6> yeah, i was just going to define an alias
00:27:44 <monochrom> cabal = cabal -v
00:28:03 <monochrom> cabal = fix -v
00:29:46 <Axman6> alias cab="~/.cabal/bin/cabal --ghc-options=\"-fllvm -O2\""
00:29:58 <geheimdienst> the misleading thing is that comments in the cabal config file are "-- something", which looks awfully close to a command line option
00:32:32 <ksf> llvm backend will look even better when someone gets around to use its link-time optimisation.
00:33:20 <ksf> in the end, it'd be great if ghc can link-time optimise even .so's
00:33:25 <Axman6> hmm, well this isn't looking good, cab install cabal-install fails
00:33:33 <ksf> ...although that would mean completely abandoning the C abi.
00:33:37 <Eduard_Munteanu> ksf: you mean like inlining via the linker?
00:33:43 <Eduard_Munteanu> That would be nice.
00:34:02 <ksf> supercompilation, if possible.
00:34:13 <Axman6> cab install snap-server seems to be doing better...
00:34:21 <ksf> dunno how much amendable generated code can be to such stuff, though.
00:34:53 <ksf> last time I tried (pre-release) cabal-install didn't work with ghc7
00:34:57 <Eduard_Munteanu> That's usually the realm of native code -> native code JITs.
00:35:47 <ksf> are there any advantages over say llvm -> native jiting?
00:36:39 <Eduard_Munteanu> Ah, if you've got LLVM IR, I'd rather work with that
00:36:46 <ksf> I'd wager native->native supercompilation is infeasible due to utter lack of information.
00:37:14 <kmc> native->native tracing JIT works
00:37:18 <kmc> and is a lot like supercompilation
00:37:22 <kmc> talk to edwardk about that
00:37:29 <Eduard_Munteanu> I think edwardk said something about that.
00:37:41 <ksf> a ghc core->native jit should probably be small enough to be shippable
00:37:41 <kmc> he made an amd64 tracing jit
00:37:44 <kmc> it's online somewhere
00:37:45 <Eduard_Munteanu> Yeah.
00:37:57 <kmc> core is still quite a functional language
00:37:58 <kmc> perhaps stg
00:38:10 <kmc> or cmm or llvm
00:38:11 <lars9> i noticed that the fraction of asian developers in opensource world is significantly smaller than fraction of poplution
00:38:25 <ksf> well you'd still want to do quite high-level optimisations
00:38:28 <Eduard_Munteanu> Still, I'd preserve a healthy dose of skepticism and rather stick to jitting some IR if possible.
00:38:47 <ski> kmc : `(\n -> f n) \in O(\n -> n)'
00:39:15 <ksf> lars9, it's also a language issue.
00:39:23 <qwebirc56958> > In $ Cons 12 $ In $ Cons 4 $ In $ Cons 9 $ In Nil :: List Int
00:39:24 <lambdabot>   Not in scope: type constructor or class `List'Not in scope: data constructo...
00:40:11 <Eduard_Munteanu> ksf, kmc: IIRC, this was his stuff...  https://github.com/ekmett/jitplusplus 
00:40:49 <ksf> yep he complained about the removal of 3dnow from future processors in one of my reddit threads...
00:41:49 <Eduard_Munteanu> Aren't there other means of doing vectorized integer stuff on recent CPUs than 3DNow?
00:42:10 <ksf> 3dnow is float.
00:42:14 <ksf> mmx was integer
00:42:25 <ksf> yes, there are
00:42:26 <Eduard_Munteanu> Oh. I thought it was a mere extension of MMX.
00:42:39 <Eduard_Munteanu> Well, SSE is pretty strong these days.
00:42:43 <ksf> well it's about the same as mmx, just for floats. both got superseded by sse
00:43:11 <ksf> he said he used those registers to relieve pressure, 'cos usual code isn't using them.
00:43:35 <HWSOD> does "\first last -> [first..last]" have a standard name?
00:43:46 <ksf> :t enumFromTo
00:43:47 <lambdabot> forall a. (Enum a) => a -> a -> [a]
00:43:49 <Eduard_Munteanu> x86-64 has 16 xmm registers anyway.
00:43:53 <ksf> it even has a _desugaring_.
00:44:05 <pelotom_> kmc: why the ctor name "In"?
00:44:14 <Axman6> Mu
00:44:17 <Axman6> @src MU
00:44:19 <Axman6> @src Mu
00:44:24 <Axman6> lambdabot!
00:44:29 <Eduard_Munteanu> The major problem I've seen is there's no practical way of loading constants into xmm registers in older SSE instruction sets at least.
00:44:40 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
00:44:40 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
00:44:41 <Eduard_Munteanu> (not directly, you have to go through the stack)
00:44:46 <ksf> data Mu f = In (f (Mu f))  
00:45:09 <pelotom_> Axman6: I know, why "In" and "out" though?
00:46:00 <Eduard_Munteanu> Is that Mu stuff a hylomorphism thingy?
00:46:16 <Eduard_Munteanu> I think I remember it from somewhere.
00:46:33 <pelotom_> Eduard_Munteanu: alls I know is it's a type-level fixpoint combinator
00:46:56 <Eduard_Munteanu> I see.
00:46:59 <pelotom_> where i come from, we don't know too much 'bout hylowhatsits
00:47:11 <Eduard_Munteanu> :)
00:48:13 <Eduard_Munteanu> "We don't take kindly to your types around here!"
00:48:25 <dankna> .... wow
00:48:35 <pelotom_> now, Skeeter...
00:48:41 <Eduard_Munteanu> :)
00:49:16 <kmc> pelotom_, i don't know really.  there's an isomorphism between "Mu f" and "f (Mu f)" and you name the two directions of this
00:49:24 <kmc> i guess "in" and "out" are good names for directions
00:49:33 <kmc> like "wrap" and "unwrap" or whatever else
00:49:50 <pelotom_> kmc: ok
00:49:50 <ksf> like "tortillia" and "eat"
00:49:56 <kmc> exactly like that
00:52:21 * ksf decides to use lolcode for example code if he should ever write a paper, just to annoy academics.
00:52:38 <pelotom_> kmc: I'm guessing there's not much use for Mu outside of a theoretical context?
00:52:49 <ksf> oh there definitely is.
00:52:51 <Eduard_Munteanu> OH NOES
00:53:19 <dankna> hmmm
00:53:37 <dankna> dare I release this code without understanding why it suddenly fixed itself when I changed something that shouldn't have mattered?
00:54:21 <Eduard_Munteanu> I remember that's the exact reason Linus didn't want a kernel debugger.
00:54:43 <pelotom_> ksf: like...
00:54:44 <dankna> really?
00:55:18 <Eduard_Munteanu> Yeah, he feared this kind of approach might end up being counterproductive.
00:55:45 <ksf> pelotom_, if e.g. you want to attach stuff to your stuff.
00:55:57 <ksf> or use the same kind of leaves in a tree and a list.
00:56:04 <ksf> or graph.
00:56:05 <kmc> pelotom_, by writing recursive types in that form, we make it easier to derive generic traversals, etc
00:56:13 <kmc> see the "multirec" library and associated paper
00:56:16 <kmc> anyway, i must sleep now
00:56:17 <kmc> ttyl all :)
00:56:18 <pelotom_> oh, interesting
00:56:24 <dankna> fair
00:56:29 <pelotom_> laters
00:56:42 <ksf> it's quite a perfect fit for stuff like data-reify
00:57:06 <pelotom_> I'll have to hunt down this paper and add it to my hoard
00:57:54 <pelotom_> aaand got it :)
00:58:09 <ksf> we're bound to get a kernel console, though.
00:58:40 <Eduard_Munteanu> KGDB is in already IIRC.
00:58:52 <ksf> well, or at least a blue tux of death, because the kernel can snatch control of the framebuffer with kms in place.
00:59:45 <ksf> panics are quite nonexistant, these days, though.
01:00:03 <Eduard_Munteanu> Actually with KMS panics could be more informative given high resolutions.
01:00:47 <ksf> linux should just re-boot with proper arguments and then write the barfage to disk.
01:01:12 <ksf> ...have a minimal fail-safe kernel stored in initrd.
01:01:14 <Eduard_Munteanu> ksf: I think some of that is quite doable with kexec
01:01:40 <Eduard_Munteanu> You can load a kernel to be ran on panic
01:01:43 <ksf> ...or, even simpler, just write it to swap.
01:02:10 <Eduard_Munteanu> It's just relocated in RAM in some other place.
01:05:08 <ski> @wiki Indirect_composite
01:05:08 <lambdabot> http://www.haskell.org/haskellwiki/Indirect_composite
01:05:12 <ski> pelotom : ^
01:05:14 <pelotom_> great dijkstra quote: 'when judging the relative merits of programming languages, some still seem to equate "the ease of programming" with the ease of making undetected mistakes'
01:05:39 <ksf> too true.
01:05:48 <pelotom_> ski: thx
01:05:58 <ksf> I'm writing a lot of `plusPtr`s today.
01:06:05 <opqdonut> :)
01:06:17 <ksf> can't touch that code without a long stick and binoculars.
01:07:16 <ksf> it's interesting how haskell's slightly verbose pointer arithmetic blends with its otherwise more concise syntax, though.
01:08:37 <ksf> and how every kind of loop turns out to be let go foo bar = ...; go 0 baz
01:09:41 <ski> pelotom : cf. <http://www.haskell.org/wikisnapshot/DecoratingStructures.html>
01:12:40 <ski> s/pelotom/pelotom_/
01:13:37 <pelotom_> ski: cool, that makes sense, especially the examples in the first link
01:18:37 <pelotom_> source of that dijkstra quote if anyone's interested: http://www.cs.utexas.edu/users/EWD/transcriptions/EWD06xx/EWD667.html
01:21:29 <geheimdienst> @remember dijkstra when judging the relative merits of programming languages, some still seem to equate "the ease of programming" with the ease of making undetected mistakes
01:21:29 <lambdabot> It is forever etched in my memory.
01:22:12 <pelotom_> here's another gem: 'When all is said and told, the "naturalness" with which we use our native tongues boils down to the ease with which we can use them for making statements the nonsense of which is not obvious.'
01:26:48 <pelotom_> :t fix
01:27:07 <pelotom_> pfft
01:27:21 <ski> @botsmack
01:27:22 <lambdabot> forall a. (a -> a) -> a
01:27:22 <lambdabot> :)
01:27:34 <ski> that appeared to help :)
01:27:50 <pelotom_> that's a new one :)
01:31:00 <pelotom_> :k Mu
01:31:01 <lambdabot> (* -> *) -> *
01:40:53 <ivanm> anyone on here know much about planar graphs?
01:47:15 <quicksilver> ivanm: a bit. probably not enough to answer your question. But if you dont' ask it we'll never know :)
01:48:00 <gds> Anyone know why Control.Monad.State is in both mtl and monads-fd?
01:48:08 <gds> Is one package deprecated or something?
01:48:28 <dankna> @hackage monads-fd
01:48:28 <lambdabot> http://hackage.haskell.org/package/monads-fd
01:48:32 <tibbe> gds: monads-fd simply reexport mtl-2
01:48:36 <quicksilver> well, monads-fd is intended as an optional replacement for mtl yes
01:48:37 <dankna> yes, it is, use mtl instead
01:48:50 <dankna> according to that page
01:48:50 <tibbe> gds: what dankna said
01:48:59 <gds> ok, cheers.
01:49:01 <quicksilver> s/is/was/;
01:49:10 <gds> I should probably tell ghc to ignore it then :)
01:49:24 <quicksilver> (monads-fd was an attempt to factor out the functional dependency part of the mtl; the effort is superseded by mtl-2)
01:49:35 <gds> dankna: Thanks :)
01:49:46 <dankna> sure :)
01:49:50 <ivanm> quicksilver: do you know if it makes sense to have multiple connected components when considering planar graphs?
01:49:56 <ivanm> or should it always remain connected?
01:50:09 <quicksilver> it makes perfectly reasonable "sense"
01:50:14 <ivanm> (in particular, the concept of an outer face becomes difficult to define if there's more than one component)
01:50:26 <quicksilver> although certainly a lot of work or theorems are about the single-component case
01:50:54 <ivanm> yeah, I just wasn't sure; I couldn't thinky of any real reason why there shouldn't be, apart from making it difficult to construct the dual
01:51:11 <quicksilver> of course, if your graph is defined extrinsically it may not be a priori obvious how many components it has
01:51:26 <quicksilver> so you have to countenance that case
01:51:30 <quicksilver> until you've managed to prove it
01:55:14 * gds does "ghc-pkg hide monads-fd", and idly wonders if there would be any way of telling cabal-install to do the same when installing it...
01:55:31 <gds> Or if that would be a Bad Thing for reasons I haven't yet figured out.
02:04:18 <Mitar> what is a good practice of exporting of types and data constructors from a module to be used in your other modules, but not to be exported to users?
02:04:57 <quicksilver> My.Project.Internals, perhaps?
02:22:19 <Mitar> i am using StateT to make a monad for my library I then use
02:22:54 <Mitar> how can i export only name/type of this monad and not its internalls (so that it is not visible that it is a statet monad?)
02:23:48 <dankna> declare a type synonym like
02:24:02 <dankna> type Mitar = StateT MitarState
02:24:10 <dankna> and then put Mitar, but not Mitar(..), in the export list
02:24:16 <quicksilver> newtype better
02:24:25 <dankna> or what qs says, yes
02:24:32 <quicksilver> using type synonyms for abstraction doesn't work very well
02:24:48 <Mitar> yes, i get in haddock documentation whole type
02:24:58 <dankna> I hadn't actually realized a newtype would work in this situation until quicksilver just said it
02:25:00 <dankna> cute trick
02:25:12 <quicksilver> I don't think that's a trick :)
02:25:18 <dankna> well, whatever it is, it's cute
02:25:19 <Mitar> i am not sure that Mitar(..) works on types?
02:25:20 <quicksilver> I think it's essentially the entire purpose of newtype
02:25:30 * dankna nods
02:25:30 <quicksilver> Mitar: well you should be sure. it does.
02:25:45 <quicksilver> Mitar(..) means the type Mitar and all its constructors.
02:25:56 <quicksilver> Mitar() means the type Mitar but none of it's constructors
02:25:56 <Mitar> but for type synonim?
02:26:14 <Mitar> type Foo = something, you cannot export Foo(..)?
02:26:20 <quicksilver> on type synonyms I would *guess* it's referring to the constructors of the underlying type
02:26:23 <quicksilver> but I don't know
02:26:26 <quicksilver> because I never use type synonyms
02:26:30 <quicksilver> they are, IMO, utterly useless.
02:26:41 <Mitar> they are good for self-documentating code
02:26:41 <dankna> you're right, actually, you cannot export Foo(..) in that situation
02:26:57 <dankna> I like synonyms, but I'm relatively new to the language
02:27:14 <dankna> I find them useful for documentating things, yes
02:27:17 <dankna> er
02:27:20 <dankna> spell that correctly
02:27:22 <quicksilver> Mitar: yes, they're not bad for documentation as long as you recognise it's only documentation not safety
02:27:45 <Mitar> yes
02:27:59 <quicksilver> on the other hand if our tools (ghci?) supported documentation better (like, say, elisp and docstrings) then that would be a better solution :)
02:28:11 <quicksilver> ...to that particular part of the problem.
02:28:29 <dankna> when you have a 600-line function and using a newtype would add more lines to it, you sometimes are willing to give up a little safety for brevity :)
02:28:32 <quicksilver> they're also mildly useful as 'macros' just to make it an unwieldy type take up fewer characters.
02:28:48 <dankna> yes, it really needs to be that long.  yes, I consider it readable, relatively; it's a bunch of sub-functions in a let.
02:29:50 <dankna> I actually think docstrings and type-synonyms-as-documentation are orthogonal
02:29:55 <dankna> I think there's a place for both
02:30:07 <dankna> but I'm a big, big believer in self-documenting code
02:32:41 <ksf> " For lack of space, we provide the detailed description and code in the appendix, and postpone the description of the resize () method, which is rather straightforward, to the full version of the paper."
02:32:56 <ksf> DUR HUR THEN WHY DOES YOUR BLEEDING LIBRARY NOT CONTAIN IT EITHER
02:38:13 <ksf> idea A+, execution C-.
02:41:15 <ivanm> quicksilver: (from before; I was afk for a bit): well, I was going to have smart extenders to ensure you only kept building the graph as a planar one
02:41:19 <Mitar> is there a way to export from a module everything from a given module and some things from another module?
02:41:50 <ivanm> but if I allow multiple components, I'm going to have to work out how to allow edges between them (I was originally going to say that an edge is allowed only if it splits a face)
02:42:11 <ivanm> Mitar: module Foo (module Bar, module Baz) where ...
02:42:37 <Mitar> but how can i export all things from module Foo too (without listing them explicitly)
02:46:38 <Saizan> Mitar: add "module Foo" to the list
02:47:45 <Mitar> so module Foo (module Foo, module Bar) where .. ?
02:52:40 <ivanm> Mitar: you could always try it... ;-)
02:53:12 <Mitar> ;-)
02:53:24 <Mitar> i am, in parallel ;-)
02:55:57 <ivanm> heh
03:01:51 <quicksilver> Mitar: I believe you can't.
03:02:02 <quicksilver> Mitar: once you've started writing an export list you have to list everything.
03:02:09 <quicksilver> you could use another module just to re-export
03:03:08 <ksf> this. code. is. bogous.
03:03:52 <ksf> oh wait
03:05:35 <ksf> someone shoot whoever is responsible for c++'s variable declarations that look just like function calls
03:06:05 <ksf> @karma- c++
03:06:05 <lambdabot> c++'s karma lowered to -1.
03:06:32 * hackagebot file-embed 0.0.3.1 - Use Template Haskell to embed file contents directly.  http://hackage.haskell.org/package/file-embed-0.0.3.1 (MichaelSnoyman)
03:06:36 <tab> ksf: just shooting the one responsible for c++ would do ;)
03:06:54 <miclorb> he has a difficult to spell name to avoid detection and assasination
03:07:14 <quicksilver> ksf: has anyone ever developed code which compiles correctly and does two entirely different things based on forcing one of the two interpreations of that syntax?
03:07:16 <engla> if he has a common name, he'll make it difficult for everyone with the no-fly list
03:07:33 * hackagebot web-encodings 0.3.0.4 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.4 (MichaelSnoyman)
03:08:04 <Axman6> i wrote some C code that would segfault on linux and have a bus error on OS X
03:08:11 <Axman6> this was intentional too
03:08:52 <Jafet> @karma- c
03:08:52 <lambdabot> c's karma lowered to 2.
03:09:00 <theorbtwo> Axman6: I do that reasonably often in order to get gdb to break.
03:09:08 <Axman6> heh
03:09:35 <Axman6> this was for a lab at uni using memory protection, and signal handling
03:09:59 <Saizan> quicksilver: "module Foo (module Foo, module Bar) where ...." exports both everything defined in Foo and everything exported by Bar
03:10:09 <jacobian> Supposing I'm in the Maybe monad and I want to translate a result to the list monad 
03:10:19 <jacobian> Is there an idiom for that? 
03:10:44 <Axman6> depends what sort of result you want to get
03:10:52 <Saizan> ?type maybe [] (:[]) 
03:10:52 <lambdabot> forall a. Maybe a -> [a]
03:10:55 <Axman6> :t maybeToList
03:10:56 <lambdabot> forall a. Maybe a -> [a]
03:11:31 <jacobian> thanks
03:13:12 <jacobian> maybe is the fold eh?
03:13:13 <Axman6> hmm, compiling with ghc7 and the llvm backend seems to be extremely slow...
03:13:23 <Axman6> jacobian: huh?
03:13:41 <jacobian> maybe :: forall b a. b -> (a -> b) -> Maybe a -> b
03:13:53 <Axman6> i guess it is
03:14:46 <arcatan> @source sum
03:14:46 <lambdabot> sum not available
03:16:33 <Axman6> huh, that should work
03:16:45 <Axman6> i believe it's just foldl (+) 0
03:16:58 <Axman6> note it's not defined in the ptrlude as foldl'
03:17:12 <arcatan> yeah
03:17:23 <arcatan> meh, is haskell.org broken again?
03:22:57 <ksf> calloc?
03:23:09 <ksf> do I really have to clear memory myself?
03:23:11 <ksf> haskell sucks.
03:23:42 * hackagebot alex 2.3.4 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-2.3.4 (SimonMarlow)
03:23:52 <ksf> what's the point in using an allegedly "concise" language when you have to do the most basic things yourself?
03:24:16 <Axman6> ?
03:24:30 <quicksilver> Saizan: nice.
03:24:45 <ksf> there's no equivalent to calloc in Foreign.Marshal.Alloc.
03:24:56 <ksf> ...which sets the alloced memory to zero.
03:25:44 <HugoDaniel> ghc 7 is out!!!
03:25:46 <HugoDaniel> gr8!
03:29:29 <HugoDaniel> is it ok to update ?
03:30:30 <Axman6> i have... but ghc updates usually make me rage very hard
03:30:43 <HugoDaniel> yes, indeed :/
03:31:07 <HugoDaniel> ok, im going to update, and dive in the all the cabal mud that will follow
03:31:21 <HugoDaniel> btw
03:31:34 <HugoDaniel> is learning assembly a good investment nowadays ?
03:31:36 <Axman6> yeah, i am too
03:31:46 * hackagebot happy 1.18.6 - Happy is a parser generator for Haskell  http://hackage.haskell.org/package/happy-1.18.6 (SimonMarlow)
03:31:58 <ksf> learn llvm
03:32:07 <Axman6> HugoDaniel: i think learning a RISC assembly is a good idea, it helps you think about how computers work
03:32:13 <Axman6> LLVM may be a good choice
03:32:35 <Axman6> so, is anyone else using ghc 7 with llvm yet?
03:32:38 <ksf> arm, too.
03:32:42 <HugoDaniel> ok, thanks :)
03:32:53 <Mitar> how can I use liftIO then when i used newtype to encompass my StateT-based type?
03:32:53 * Axman6 likes SPARC
03:33:47 * hackagebot gd 3000.6 - A Haskell binding to a subset of the GD graphics library  http://hackage.haskell.org/package/gd-3000.6 (ChrisDone)
03:33:58 <vegai> Axman6: really? Why? 
03:34:34 <Axman6> liking SPARC? it like sparc machines, and i thought their assembly was quite nice to work with
03:36:28 <quicksilver> Mitar: by deriving MonadIO for your newtype
03:36:43 <HugoDaniel> ill look into llvm
03:36:45 <HugoDaniel> many thanks
03:36:51 <quicksilver> Mitar: or by providing a function equivalent to liftIO if you prefer.
03:37:01 <quicksilver> (perhaps with a more restricted type or something)
03:38:02 <Mitar> any example of how can I derive that?
03:39:23 <quicksilver> newtype MitarType a = MkMitarType (StateT IO a) deriving (MonadIO)
03:40:18 <Mitar> oo
03:40:20 <Mitar> just that?
03:40:50 <Mitar> ;-)
03:40:52 <quicksilver> {-# LANGUAGE GeneralizedNewtypeDeriving -}
03:40:59 <yiannis_t> quicksilver: :O
03:41:04 <yiannis_t> you nailed it dude! :
03:41:05 <yiannis_t> )
03:41:15 <quicksilver> ?
03:41:23 <yiannis_t> simple and clear
03:41:50 <Axman6> he did not nail it, he forgot a #
03:41:51 <Mitar> ok, i needed (Monad, MonadIO) not just MonadIO to put there
03:42:37 * quicksilver nods
03:46:03 <Mitar> hm, this newtype hiding gives me more and more problems ;-) not modify function also does not work anymore on it
03:46:35 <Mitar> s/not/now/
03:46:38 <quicksilver> Mitar: come on you must surely have worked out the solution to that.
03:46:47 <Mitar> a wrapper function?
03:46:55 <quicksilver> deriving (Monad,MonadIO,MonadState s)
03:46:59 <Mitar> aaaaaaa
03:47:05 <Mitar> that is crazy ;-)
03:47:13 <Mitar> that LANGUAGE flag is crazy
03:47:15 <quicksilver> it's normaly not the correct design.
03:47:25 <quicksilver> you don't normally want to export to your users the entire structure of your state
03:47:34 <Mitar> that is true
03:47:36 <quicksilver> better to set up some primitives which are natural for your API, not your implementation.
03:47:43 <Mitar> true
03:47:55 <Mitar> but how do i access my state in those primitives?
03:48:14 <quicksilver> by calling modify on the 'underlying' StateT IO ...
03:48:29 <lars9> ehh... still can not think of how to use state/reader/writer in my own programs
03:48:33 <quicksilver> if you expose all details then the newtype has not gained you much abstraction
03:48:55 <Mitar> i agree
03:49:01 <Mitar> is there some tutorial for this?
03:49:07 <Mitar> probably is a common thing
03:49:29 <Axman6> lars9: writer is the only one i can think of using, but never have
03:50:07 <lars9> Axman6: writer for what? logging?
03:50:13 <Axman6> yeah
03:50:20 <quicksilver> I think cale wrote something about the right way to use monad transformers
03:50:24 <Axman6> i'm quite happy to have explicit state
03:50:47 <lars9> Cale is not in channel
03:51:07 <quicksilver> I can't find it and haskell.org being down doesn't help
03:52:09 <lars9> using monad is much harder than learning it
03:52:38 <Axman6> really?
03:52:43 <lars9> quicksilver: hi could please show me how to use Arrow's loop?
03:52:47 <quicksilver> no.
03:52:53 <Axman6> i found it to be completely backwards to that
03:53:13 <yiannis_t> quicksilver: if you find that please post it! monad transformers has been a pain in the ass
03:53:21 <quicksilver> lars9: in my opinion it's bad manners to ask a directed question in a help IRC channel that is not part of an ongoing conversation.
03:53:36 <quicksilver> lars9: if you have a question to ask, ask it generally, and anyone who can answer and chooses do, will do so.
03:53:36 <yiannis_t> http://dl.dropbox.com/u/6228981/transformations.jpg
03:53:52 <quicksilver> yiannis_t: lol :)
03:54:20 <quicksilver> @tell Cale did you write a tutorial or an email about using monad transformer stacks with newtypes and sensible primitive defintions? I couldn't google it.
03:54:20 <lambdabot> Consider it noted.
03:54:28 <lars9> quicksilver: i see, learning irc manners & monads simutaneously
03:54:38 <quicksilver> good luck with both :)
03:55:49 <lars9> yiannis_t: how can lambdabot responds like that, amazing
03:56:03 <vegai> like what?
03:56:20 <lars9> < lambdabot> Consider it noted.
03:56:39 <lars9> right after < yiannis_t> http://dl.dropbox.com/u/6228981/transformations.jpg
03:57:11 <Axman6> lars9: it wasn't right after that, quicksilver gave lambdabot a command
03:57:51 <geheimdienst> in #haskell and a few other channels, if it starts with "@", it's a command to lambdabot
03:57:56 <lars9> Axman6: i see, lambda cannot be so good at natural language
03:58:01 <geheimdienst> @quote lolcats
03:58:01 <lambdabot> geheimdienst says:  i totally didn't realize that leksah = reverse haskel. i thought leksah was what the lolcats said for lexer
03:58:16 <Axman6> lambdabot does almost no natural language processing
03:58:28 <Axman6> @vixen how much do you love lars9?
03:58:28 <lambdabot> love is a powerful word...
03:58:32 <yiannis_t> lambdabot rulez guyz! :P
03:58:32 <quicksilver> @vixen can you process natural language?
03:58:32 <lambdabot> i sure can
03:58:45 <quicksilver> @vixen is Axman6 spreading lies about you?
03:58:45 <lambdabot> what about me?
03:58:51 <Axman6> @vixen you mean you aren't sure if you love lars9?
03:58:52 <geheimdienst> that's what she said
03:58:52 <lambdabot> oh, but only if, right?
03:58:59 <vegai> @vixen can you processes lonely guys?
03:58:59 <lambdabot> i sure can
03:59:42 <markelos> I am the rightful owner of transformations.jpg :D
04:00:01 <chrisdone> anyone know where I can find a mirror of ghc 7? I kinda need it right now and the site's down for a change
04:00:32 <Axman6> it worked for me not too long ago :\
04:00:48 <vegai> chrisdone: just a moment...
04:01:10 <pkrumins> If the code throws 'SomeException e', how do I print 'e' as a String?
04:01:31 <vegai> chrisdone: http://new-www.haskell.org/ghc/dist/7.0.1/
04:01:43 <vegai> seems to be responsive
04:02:08 <lars9> reminds me of a bbs chat robot made by my friend 10 years ago, it was extremely intelligent at converstation. but eventually we found in fact it just randomly match ppl up into pairs, and filters away all words like I/you/name...
04:02:35 <lars9> s/filter/substitude/
04:02:42 <pkrumins> can do it with omegle now
04:02:54 <chrisdone> vegai: thanks!
04:02:58 <quicksilver> lars9: yes, that's not unlike the way you play grandmaster level chess by pairing off opponents :)
04:03:20 <quicksilver> it's a generic but sometimes amazing looking trick.
04:03:37 <pkrumins> like derren brown did
04:04:10 <pkrumins> quicksilver: http://www.youtube.com/watch?v=evZmpsl3jI0
04:04:25 <ivanm> what's a good synonym for "wherever", as in "put this edge wherever it can go" ?
04:04:49 <pkrumins> ivanm: everywhere
04:05:05 <lars9> quicksilver: yeah, that guy is a genius so we did doubt at first
04:05:47 <ivanm> pkrumins: hmmm... well, my other two constructors are BeforeEdge and AfterEdge; "Everywhere" doesn't quite fit :s
04:06:01 <quicksilver> Anywhere?
04:06:37 <ivanm> gah, I obviously haven't had enough sleep; I was thinking of Anywhere before but forgot it :s
04:06:48 <geheimdienst> Before | After | Any
04:15:05 <cathper> Is http://haskell.org down?
04:15:11 <yiannis_t> cathper: yeap
04:16:02 <lars9> @quote afp
04:16:02 <lambdabot> No quotes match. Listen, broccoli brains, I don't have time to listen to this trash.
04:16:16 <lars9> @where evolotion
04:16:16 <lambdabot> I know nothing about evolotion.
04:16:21 <lars9> @where evolution
04:16:22 <lambdabot> http://www.willamette.edu/~fruehr/haskell/evolution.html
04:18:27 <aristid> @hoogle until
04:18:28 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
04:18:47 <aristid> interesting function
04:21:05 <Jafet> > until (\x -> x^2-2 < 1e-9) (\x -> (x + 2/x)/2) 1
04:21:06 <lambdabot>   1.0
04:21:17 <Jafet> > until (\x -> abs (x^2-2) < 1e-9) (\x -> (x + 2/x)/2) 1
04:21:17 <lambdabot>   1.4142135623746899
04:23:00 * hackagebot hjsmin 0.0.3 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.3 (AlanZimmerman)
04:23:31 <chrisdone> damnn it
04:23:35 <chrisdone> I was writing a javascript minifier
04:24:18 <Mitar> in newtype MyType a = MkMyType (StateT MyState IO a) deriving (Monad, MonadIO, MonadState s) I think it is OK that I derive MonadState if I do not expose MyState constructors, then users still cannot change or look into internals
04:25:22 <chrisdone> oh well, I can just use that one now
04:25:36 <quicksilver> Mitar: sure.
04:25:51 <quicksilver> Mitar: it's fine; it just might be nicer to expose specific primitives.
04:26:07 <quicksilver> Mitar: for example, people can then use 'get' to store old states and 'put' to put them back; do you want them to be able to do that?
04:26:15 <Mitar> hmm, no
04:26:27 <Mitar> but my question is how I do manipulate state in primitives itself?
04:26:42 <quicksilver> I answered that already ;)
04:27:02 <quicksilver> a bit briefly, sure, but which part don't you follow?
04:27:24 <hpc> i think he is asking about general mutation
04:27:33 <quicksilver> I don't.
04:27:44 <quicksilver> I think he's asking about wrapping and unwrapping the MkMyType constructor.
04:28:09 <quicksilver> but it's no different from any other constructor...
04:28:36 <quicksilver> (all deriving MonadState does is mechanically write methods which morally wrap/unwrap the constructors)
04:28:37 <Mitar> but I have to to myModify function which unwrapps MkMyType?
04:28:43 <quicksilver> yes.
04:28:59 <quicksilver> in order to write your own primitives you have to know your own type internals
04:29:05 <quicksilver> you only have to do that for the primitives though
04:29:08 <quicksilver> and then you just use them
04:29:09 <Mitar> so I cannot make it use general modify function, but prevent users to use it?
04:29:28 <ivanm> gah! I have a function where too many things have to be updated!
04:29:41 <quicksilver> it's clumsy trying to hide instances
04:29:45 <quicksilver> possible, but clumsy.
04:29:46 <ivanm> trying to work out how to split it up into logical sections is getting to be a right royal PITA :s
04:29:47 <quicksilver> I wouldn't bother.
04:30:02 * hackagebot SoccerFun 0.4.2 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.4.2 (JanRochel)
04:30:04 * hackagebot SoccerFunGL 0.4.2 - OpenGL UI for the SoccerFun framework  http://hackage.haskell.org/package/SoccerFunGL-0.4.2 (JanRochel)
04:30:09 <ivanm> quicksilver: you can hide instances? :o
04:30:24 <quicksilver> how hard is it to write myModify f = MkMyType (modify f)
04:30:40 <ivanm> the only way I can think of to do that is to not expose both the types and the class...
04:30:41 <quicksilver> ivanm: yes, by putting the instances in a separate module and not re-exporting that.
04:30:55 <ivanm> aren't they implicitly exported though?
04:31:06 <quicksilver> yes. You can't export anything form the module that uses them
04:31:24 <quicksilver> so all your "private" code which uses the "secret" instances must not be in the same module as the type
04:31:27 <ivanm> i.e. instances are defined in Bar, Foo has "import Bar()", then doesn't Foo also export those instances?
04:31:36 <quicksilver> ivanm: yes, so you don't put them in bar.
04:31:48 * ivanm is confused
04:31:53 <quicksilver> well, you don't import them into Foo
04:32:01 <quicksilver> you only import them into another private module
04:32:03 <ivanm> quicksilver: then how do you use them?
04:32:04 <lars9> ArrowLoop is explained here: http://onthebalcony.wordpress.com/2007/02/19/my-evolution-as-a-haskell-programmer/
04:32:11 <ivanm> don't they all get implicitly imported and exported everywhere?
04:32:33 <ivanm> even then, haddock is too helpful and tells the reader about how exported data types are instances of hidden internal classes, etc. :@
04:32:35 <lars9> with examples
04:32:40 <quicksilver> AFAIK they only get implicitly export if you import them into the module that exports the type
04:32:47 <quicksilver> but as I say, it's not worth doing.
04:32:50 <quicksilver> so don't ;)
04:35:53 <quicksilver> lars9: looks like a good article although I didn't read it carefully
04:38:31 <lars9> im reading it. usage of arrow is not talked a lot on internet, most web pages i can find are about definitions & manuals.
04:38:51 <quicksilver> yes.
04:38:58 <quicksilver> there are very few good examples of arrow usage.
04:39:07 <quicksilver> almost all the examples are just functions, which is stupid.
04:39:24 <quicksilver> that's just using the arrow combinators as a neat library for manipulating tuples and functions.
04:39:33 <quicksilver> nothing wrong with that, but it's a very boring example of an 'Arrow'.
04:40:07 <quicksilver> I also find the conveyor belt analog on the wikibook rather unsatisfying although I can't put my finger on why, exactly.
04:40:18 <quicksilver> HXT is a better example of arrow processing
04:40:23 <quicksilver> as are the arrow parsers
04:40:28 <lars9> yeah, by definition, *** &&& etc can be implemented with simple functions, so i guess the power of arrow should be beyond that
04:40:34 * quicksilver nods
04:47:06 <diabolo_> hello everybody
04:47:29 <diabolo_> i'm back with my depth first search question
04:48:24 <diabolo_> I may be mentally challenged, or maybe i've been brainwashed to think c/java but I just don't get how do make it work recursively
04:48:45 <diabolo_> anyone with a few minutes to spare trying to enlighten me?
04:49:36 <lars9> diabolo_: dfs in tree?
04:50:18 <diabolo_> lars9, in a graph
04:50:54 <lars9> undirectional?
04:51:09 <diabolo_> undirected
04:51:31 <Saizan> mh, the usual problem is that you've to keep a set of the already visited nodes to avoid looping
04:51:42 <diabolo_> which means I have to track the visited nodes, but I don't know of I can make that work with the recursion
04:51:53 <Saizan> you surely can
04:52:38 <diabolo_> yesterday someone suggested this : visit next valid visited start = Tree start $ map (visit next valid (start:visited)) $ filter (not . (`elem` visited)) $ filter valid $ next start
04:52:54 <lars9> dfs :: GraphNode -> Set GraphNode -> ... ?
04:53:41 <diabolo_> in this example the resulting tree contains each node multiple time since the different branching of the recursion don't share the visited set i guess
04:53:59 <lars9> also return updated Set
04:54:18 <Saizan> diabolo_: yeah, you need mapAccumL instead of map
04:54:49 <Saizan> diabolo_: so that you can thread the updated visited to the next branch
04:55:46 <Saizan> ?type mapAccumL
04:55:47 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
04:57:26 <AnAdorableNick> co'o -cl
04:57:29 <Saizan> visit next valid visited start = fmap (Tree start) $ mapAccumL (visit next valid) (start:visited) $ filter (not . (`elem` visited)) $ filter valid $ next start
04:57:48 <Saizan> which i would write as:
04:58:11 <Saizan> visit next valid visited = fmap (Tree start) . mapAccumL (visit next valid) (start:visited) . filter (not . (`elem` visited)) . filter valid . next
04:58:18 <Saizan> oops
04:58:26 <Saizan> visit next valid visited start = fmap (Tree start) . mapAccumL (visit next valid) (start:visited) . filter (not . (`elem` visited)) . filter valid . next $ start
05:00:01 <diabolo_> Saizan, I think I already said that the other day but you rock
05:00:33 <ksf> foreign import ccall "strings.h ffs" c_ffs :: CInt -> CInt
05:00:37 <ksf> that part works flawlessly.
05:00:44 <ksf> ffs = fromIntegral . ffs . fromIntegral
05:00:55 <ksf> that one doesn't, and I feel like an idiot for posting this here.
05:01:35 <diabolo_> i'll just need a few minutes/hours/day/months to actually understand
05:02:00 <Saizan> heh :D
05:02:06 <Saizan> ?src mapAccumL
05:02:06 <lambdabot> mapAccumL _ s []        =  (s, [])
05:02:06 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
05:02:06 <lambdabot>    where (s', y ) = f s x
05:02:06 <lambdabot>          (s'',ys) = mapAccumL f s' xs
05:02:24 <geheimdienst> ksf, is ffs recursively calling itself ...?
05:02:50 <ksf> ffs, yes.
05:03:14 <ksf> (YES THAT'S ACTUALLY A C LIBRARY FUNCTION)
05:04:22 <Botje> haha, cool
05:04:24 <Botje> ksf++
05:05:32 <diabolo_> Saizan, thanks, i will play around a bit with a solution to see what i can make of it
05:06:25 <diabolo_> i think it's a better starting point that the "use mapM with a State monad ! classic!" i got yesterday
05:06:58 <silver> @hoogle ffs
05:06:59 <lambdabot> System.Posix.Types type FileOffset = COff
05:06:59 <lambdabot> Language.Haskell.ParseMonad getOffside :: Lex a Ordering
05:06:59 <lambdabot> Text.Regex.Base.RegexLike type MatchOffset = Int
05:08:19 <Saizan> diabolo_: mapAccumL is exactly mapM for the State monad after you remove the State newtype, btw :)
05:08:58 <Saizan> diabolo_: though from mapAccumL source it should be clearer how the set of visited nodes gets threaded around
05:09:28 <frerich8> I recently looked at a function which took a list, processed the first element of the list and then called itself recursively on the remained of the list. This was all nice and clean and tail-recursive. Now I wonder: would it be beneficial for ghc's parallelization capabilities if this function would have been called in a 'divide and conquer' fashion (calling itself recursively on the first half and on the second
05:09:28 <frerich8>  half)? This means that the recursion depth is lower, but it's not perfectly tail recursive anymore. Would such a refactoring help ghc with parallelizing the execution?
05:09:43 <Saizan> diabolo_: which is incarnated by s,s',s'' there, in its various versions as it gets updated
05:09:50 <frerich8> (and of course it means that you have to compute the length of the list in advance)
05:10:08 <diabolo_> Saizan, yeah that's what I figured since they mentioned the same thing yesterday (it was actually mapAccumR), but right now haskell is still pretty much witchcraftery to me
05:13:12 <diabolo_> what would be the best way to learn the language? read existing code? try to code stuff and come here asking questions? books? all of the above? other?
05:13:33 <Saizan> you surely need a tutorial/book
05:14:40 <Saizan> and have faith in the fact that there actually almost no magic in what's happening most of the time
05:14:48 <geheimdienst> diabolo_: i guess that's a question of what suits you best. personally, i learned by making a mess of my xmonad config file :-)
05:15:03 <geheimdienst> do check out LYAH, however:
05:15:03 <quicksilver> I believe I learn ML from a book and haskell by osmosis, experimentation, and the intertubes.
05:15:05 <geheimdienst> @where lyah
05:15:06 <lambdabot> http://www.learnyouahaskell.com/
05:15:09 <Saizan> i.e. State doesn't hide a mutable cell somewhere, it's done by normal functions and arguments passing
05:15:14 <quicksilver> but ML is a very solid grounding for haskell.
05:16:32 <diabolo_> ok, I got Real World Haskell but I haven't really pushed into it yet
05:18:01 <Saizan> frerich8: if each element requires roughly the same time to process i don't think splitting the list like that would help much, though you might need to divide it in chunks of some fixed size, so that each thread/spark has enough to chew on
05:18:10 <ksf> frerich8, have a look at Control.Parallel.Strategy or whatsit called.
05:18:36 <ksf> also, dph.
05:19:06 <Saizan> frerich8: you still need so-called "parallel annotations" or things from dph, ghc won't automatically parallelize
05:20:46 <Saizan> frerich8: though your description was a bit vague, if you're doing something like a map-reduce then such a splitting would make sense, it's used even in non-parallel settings by finger trees
05:21:32 <Saizan> though in a bottom-up fashion rather than top-down
05:22:09 <frerich8> Saizen: Ah well - I was just wondering about how much ghc would try to analyze (and rewrite!) code when told to parallelize. I wondered - maybe it can tell that the work done per list element is easily more expensive than counting the number of elements in the list, so it would rewrite the code to use a divide-and-conquer approach instead of a plain tail-recursive algorithm.
05:22:32 <frerich8> I was wondering whether it's worth rewriting the code to use D&C at all - maybe the ocmpiler can do that automagically.
05:25:18 <Saizan> GHC doesn't attempt such an analysis afaiu
05:27:52 <Saizan> iirc there's been some research on that in the past and it wasn't promising, so they are focusing on the rest :)
05:28:57 <hpc> @hoogle [Maybe a] -> [a]
05:28:57 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
05:28:58 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
05:28:58 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
05:37:49 <yitz> haskell.org down again?
05:39:26 <engla> not at the moment
05:41:10 <yitz> wasn't responding for me before, but now ok. thanks.
05:46:27 <yitz> preflex: seen Cale
05:46:28 <preflex>  Cale was last seen on #haskell 6 hours, 37 minutes and 42 seconds ago, saying: I wonder if the guy who got 100% is in here
05:47:02 <yitz> preflex: seen mauke 
05:47:03 <preflex>  mauke was last seen on #perl 11 hours, 5 minutes and 31 seconds ago, saying: I think the first exploit I've ever seen was in C and started with 'void main()'
05:47:20 <finnomenon> 100% of what?
05:47:57 <geheimdienst> finnomenon: the discussion was about some exam at someone's college
05:48:02 <yitz> finnomenon: dunno. see channel logs for 6 hrs 40 min. ago
05:49:09 <finnomenon> ok, thanks
05:54:56 <Phyx-> > fun
05:54:57 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Base.String -> a)
05:54:57 <lambdabot>    arising f...
05:55:06 <hpc> :t fun
05:55:07 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
05:55:09 <Phyx-> > fun "hi"
05:55:10 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:55:10 <lambdabot>    `SimpleReflect.FromExpr ...
05:55:17 <Phyx-> > fun "hi" :: Int
05:55:17 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Types.Int)
05:55:17 <lambdabot>    arising from a us...
05:55:22 <Phyx-> > fun "hi" :: String
05:55:23 <lambdabot>   No instance for (SimpleReflect.FromExpr GHC.Base.String)
05:55:23 <lambdabot>    arising from a ...
05:55:25 <hpc> > fun "Just 6"
05:55:25 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:55:25 <lambdabot>    `SimpleReflect.FromExpr ...
05:55:32 <hpc> wow, that's annoying
05:55:35 <Phyx-> lol
05:55:53 <hpc> @instances-importing FromExpr
05:55:53 <lambdabot> Couldn't find class `FromExpr'. Try @instances-importing
05:55:58 <hpc> D:
05:55:59 <quicksilver> > fun "Just 6" :: Expr
05:56:00 <lambdabot>   Just 6
05:56:01 <Phyx-> > fun "Just 6" :: Maybe 6
05:56:02 <Phyx-> er
05:56:02 <Phyx-> > fun "Just 6" :: Maybe Int
05:56:02 <lambdabot>   No instance for (SimpleReflect.FromExpr
05:56:03 <lambdabot>                     (Data.Maybe.May...
05:56:03 <lambdabot>   Only unit numeric type pattern is valid
05:56:23 <Phyx-> lol
05:56:34 <Phyx-> hmm 3pm
05:57:06 <Phyx-> time for breakfast
05:57:53 <quicksilver> > (fun "Just 6") x
05:57:54 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:57:54 <lambdabot>    `GHC.Show.Show a'
05:57:54 <lambdabot>      a...
05:57:58 <quicksilver> > (fun "Just 6") x :: Expr
05:57:59 <lambdabot>   Just 6 x
05:59:17 <Phyx-> that seems like a fairly pointless function
05:59:23 <hpc> @src fun
05:59:24 <lambdabot> Source not found. Maybe if you used more than just two fingers...
06:00:20 <Phyx-> i mean, instead of converting to an Exp and then interpreting, might aswell just interpret the string
06:01:30 <quicksilver> Phyx-: it's not interpreting anything.
06:01:45 <quicksilver> > (fun "Happy Happy Joy Joy") x :: Expr
06:01:46 <ehamberg> unkanon: i made a vim plugin for showing the type of the expression under the cursor once. it worked, but was crude. if you're interested i can see if i can dig it up again.
06:01:46 <lambdabot>   Happy Happy Joy Joy x
06:02:05 <quicksilver> > (fun "<++++This@Is@Not@Haskell@Syntax+++++>") x :: Expr
06:02:06 <lambdabot>   <++++This@Is@Not@Haskell@Syntax+++++> x
06:02:32 <Jafet> :t fun
06:02:33 <lambdabot> forall a. (SimpleReflect.FromExpr a) => String -> a
06:02:34 <Phyx-> quicksilver: i never said it did
06:02:53 <int-e> > text "This is not text."
06:02:54 <lambdabot>   This is not text.
06:03:07 <dblhelix> int-e: Ah, deep. ;-)
06:03:31 <hpc> :t text
06:03:31 <lambdabot> String -> Doc
06:03:49 <Phyx-> :t toConstr
06:03:49 <lambdabot> forall a. (Data a) => a -> Constr
06:05:16 <Phyx-> looks like i'm lagging again
06:05:33 * hackagebot bytestring 0.9.1.8 - Fast, packed, strict and lazy byte arrays with a list interface  http://hackage.haskell.org/package/bytestring-0.9.1.8 (IanLynagh)
06:06:32 <Phyx-> hello?
06:06:47 <Phyx-> @ping
06:06:48 <lambdabot> pong
06:07:34 * hackagebot haskell2010 1.0.0.0 - Compatibility with Haskell 2010  http://hackage.haskell.org/package/haskell2010-1.0.0.0 (IanLynagh)
06:07:38 <sipa> pang
06:14:36 * hackagebot persistent 0.3.1.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.3.1.1 (MichaelSnoyman)
06:22:26 <Mitar> for sure there is a version of bracket which uses for "release resource" phase an updated value from in-between computation?
06:22:40 <Mitar> and not original value from "acquire resource" phasE?
06:26:15 <ClaudiusMaximus> i looked for one, but then realized the in-between computation may fail (the point of using bracket is to catch the errors afaik?) so you'd not be ensured a new value
06:29:15 <endojelly> http://haskellorg.wordpress.com/2010/11/15/the-haskell-org-committee-has-formed/
06:29:25 <endojelly> congrats! good idea
06:30:11 <dankna> oh - cool.  that IS a good idea.
06:31:56 <copumpkin> man, the shootout guy is in a bad mood today
06:32:00 <dankna> oh?
06:32:04 <copumpkin> http://www.reddit.com/r/programming/comments/e6o24/ghc_701_the_fastest_release_yet_of_the_optimising/c15s3sb
06:32:10 <copumpkin> or yesterday
06:32:40 <Mitar> claudiusmaximus: yes, but if it exits normally then why not use new value, if it is available
06:35:39 <dankna> concur - bad mood
06:42:28 <burp> mhm, where is 7.0.1 changelog?
06:43:09 <int-e> release notes, http://new-www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html ?
06:43:10 <burp> oh got them
06:43:14 <burp> yes thanks ;)
06:45:17 <burp> "The full Haskell import syntax can now been used to bring modules into scope in GHCi" oh nice!
06:45:25 <dankna> oh!  nice
06:46:05 <jercos> Hello, beautiful people ;) I'm trying to pick up haskell after living a sorrow-filled live of imperitive programming, and while some of Haskell makes perfect snese to me (for example, list comprehensions), I'm struggling a bit to put the rest of the pieces together. (Current working environment, GHCi 6.12.1)
06:46:36 <sipa> jercos: anything in particular?
06:46:36 <Jafet> jercos: cut the generic sob story. Are you working with a book?
06:46:38 <Phyx-> beautiful people? is my webcam on again...
06:47:08 <jercos> Right now I'm just looking for a simple random number, and what I've come to so far isn't working for me. Any hints as to why "Prelude System.Random> newStdGen >>= \gen -> random gen" would tell me I'm mixing up IO b with (a, StdGen)?
06:47:09 <dankna> I'm beautiful!  Yay.
06:47:19 <burp> "GHC now defaults to --make mode, i.e. GHC will chase dependencies for you automatically by default. "
06:47:23 <burp> ah and shorter ghc commandline :P
06:47:38 <Phyx-> and how do you do the inverse?
06:47:40 <Phyx-> --nomake?
06:47:56 <int-e> or unmake?
06:47:58 <burp> dunno, must be something like that :D
06:48:47 <burp> "GHCi now understands layout in multi-line commands"
06:48:48 <Phyx-> They didn't mention much in the log about the new Typechecker
06:48:51 <burp> good release
06:48:53 <merijn> Is there an overview of haskell2010 vs haskell98 differences somewhere?
06:49:22 <Jafet> jercos, because that's an IO action, and must have an IO result.
06:49:37 <Jafet> jercos: for example, returning IO (a, StdGen).
06:49:53 <Phyx-> burp: i like the full import syntax support for ghci
06:50:43 <Phyx-> is there like an overview somewhere of which bugs were fixed in this release?
06:52:41 <jercos> Ah, well, you're merely hilighting the depth of what I don't know in a way there, in that you might as well be speaking greek. I don't know what piece of the jigsaw puzzle I've misplaced, yet you're telling me that a curved edge doesn't line up with a sawtooth pattern.
06:53:05 <merijn> Is today full-prose day?
06:53:37 <fryguybob> merijn: I don't know about overview, but details are here: http://hackage.haskell.org/trac/haskell-prime/query?status=new&status=assigned&status=reopened&state=accepted&milestone=Haskell+2010&order=priority
06:53:38 <sipa> For a fact i say unto thee, that truly today is that day.
06:53:39 <dankna> jercos: Are you working from a book or other tutorial?
06:53:44 <Jafet> Verily, good sir; this seemeth a fine day to be indulgent in loquaciousness.
06:53:51 <jercos> Bit of a habit I picked up from #xkcd-signal on foonetic, turned into a habit on entering a new channel >.>
06:53:57 <int-e> hmm, there is no opposite to --make. you can use -E, -C, -S, -c, which will disable --make, but I see no equivalent for linking.
06:54:14 <int-e> (As far as I can see. I may have missed something, obviously.)
06:54:29 <jercos> dankna: picking up bits and pieces from several. Most of them seem to run me into a conceptual barrier at some point.
06:54:33 <ojisan> forsooth, your words doth have the the truth
06:54:39 <Jafet> ghc 7.0.1 still recompiles purely based on the source file contents?
06:55:42 <merijn> jercos: Which ones? Did you check out "Learn You A Haskell" and "Real World Haskell"? (Preferably in that order, imo)
06:55:44 <ojisan> what was the name of the overflow IRC?
06:55:54 <sipa> overflow irc?
06:55:56 <Zao> -blah?
06:55:57 <dankna> #haskell-blah
06:56:02 <Zao> Or the "the channel is full, lol" one?
06:56:31 <Zao> 02:15 < kmc> could you maybe go to #haskell-overflow?
06:56:37 <Zao> Or so my logs tell me.
06:56:42 <int-e> we had #haskell-blah for off-topic and #haskell-overflow for long technical discussion
06:56:52 <jercos> merijn: Learn you a Haskell was the one I started with.
06:56:56 <Zao> Not to mention -in-depth if you like idling.
06:57:31 <dankna> at one point the topic in -blah mentioned something like "Many of the participants here have been severely traumatized by Haskell, and discussion of it here is therefore considered rude."  Which pretty much explains the difference between them.
06:57:32 <merijn> Zao: Naah, #epigram/coq/agda are for idling :p
06:58:44 <jercos> Data types, list comprehensions, guards, pattern matching, all makes perfect sense. I thought I had some conceptual grasp on monads, but every aspect I think I've grasped seems to turn 90 degrees in a direction I didn't know existed whenever it comes to IO.
06:58:58 <dankna> well, yeah, monads are a bit hard
06:59:11 <merijn> jercos: Best not think of monads while dealing with IO and vice versa\
06:59:25 <dankna> the explanation that helped me is that what they fundamentally do is redfined "the semicolon", which is to say, what it means to perform one thing after another
06:59:58 <jercos> merijn: So IO is a monad, but forget about that it's really just IO? ;)
07:00:02 <Jafet> Monads are to IO what Taco Bell is to burritos.
07:00:12 <merijn> jercos: For now, yes
07:00:21 <dankna> Jafet: are you sure you don't mean that the other way around?
07:00:34 * dankna does not consider Taco Bell burritos particularly good
07:01:51 <Jafet> MonadT outlet stores have always left me dissatisfied.
07:01:55 <dankna> haha
07:02:19 <jercos> I get the way do notation breaks down into binding operations and lambdas... But every time I've gone to deal with IO my brain just starts to want to jump out one ear.
07:03:07 <Saizan> the brain has to hurt initially
07:03:07 <jercos> Thankfully, not both ears, so it's reasonably easy to replace it when I'm ready to move on.
07:03:23 <dankna> yes, I see how that's convenient
07:03:44 <Jafet> Then consider using a pure interface first, such as mkStdGen.
07:04:09 <Jafet> (Remember to wear a spacesuit, to shield yourself from the inevitable state of sin.)
07:04:52 <dankna> (anything that doesn't seem to make sense is probably an in-joke, just so you are aware)
07:05:58 <merijn> dankna: Pffft, zygohistro prepromorphisms are intuitively obvious
07:06:25 <dankna> true true
07:12:01 <ManateeLazyCat> Compare 1 vs 10 curl threads (Size 3872164 bytes) : 1 thread - 34s, 5 threads - 20s , 10 threads - 25s
07:12:20 <ManateeLazyCat> If threads too little or too much, download speed will slow down
07:12:48 <ManateeLazyCat> Very funny...
07:13:24 <ManateeLazyCat> Multi-threads curl library finish, integrate to graphics interface....
07:13:34 <dankna> ...
07:14:49 <Jafet> Are other systems engineers as mad as manatee? I haven't had the fortune to meet one
07:15:09 <dankna> well, English isn't his first language, in fairness
07:16:20 <Jafet> He seems very erudite, either way
07:16:21 <merijn> Jafet: I thought (systems) engineers were mad by default
07:16:49 <Mitar> is it possible to document each filed of data type constructor with haddock?
07:16:51 * hackagebot SoccerFun 0.4.3 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.4.3 (JanRochel)
07:17:16 <merijn> And haskell isn't helping me either, the better I understand it the more I'm prone to bursts of maniacal cackling
07:17:17 <dankna> Mitar: yes.  the syntax might be --^ documentation goes here, after the field, but I'm not certain
07:17:59 <Jafet> ...the dutch and their strange CS education ideas
07:18:33 <dankna> huzzah and forsooth!  my parser generator works.  well, passes the simplest possible test, at least.
07:18:59 <Mitar> dankna: i get a syntax error
07:19:02 <exDM69> dankna: what sort of pareser generator?
07:19:05 <merijn> Jafet: Lasting (bad) influence by Dijkstra :p
07:19:20 <Mitar> "parse error on input"
07:19:23 <dankna> Mitar: hmmm, not sure, check haddock's docs
07:19:36 <Mitar> i am
07:19:37 <Mitar> ;-)
07:19:41 <Mitar> and there is no example for that
07:19:49 <Mitar> it seem only per constructor you can do that
07:20:15 <Mitar> what is strange because for records you can do for each field
07:20:39 <Jafet> soccerAI field state = do { if pos field /= pos state then goto (pos state - pos field)
07:21:10 <dankna> exDM69: LALR(1) with several modes of operation
07:21:18 <dankna> basic, GLR, unification, and GLR-and-unification
07:21:28 <dankna> so far only the basic mode is working :)
07:21:38 <dankna> but the rest is A Simple Matter of Implementation, tm, pat. pending
07:24:33 <jercos> Oh hey, Learn you a Haskell neatly tells me in explicit detail how to do what I wanted to do, only hidden under IO. How very sneaky!
07:25:00 <jercos> Thanks for the elbows in the right direction :)
07:25:13 <quicksilver> lyah++
07:35:34 <jercos> Ahhhh, there we go. my barrier was the flow of IO monads in binding, because I need to return IO as part of the binding function. Or whatever the right terminology is.
07:35:41 <jercos> Prelude Random> newStdGen >>= \x -> putStrLn $ show $ fst (random x :: (Int, StdGen))
07:35:44 <jercos> 436471052268982357
07:35:47 <jercos> :D
07:36:24 * jercos does the "conceptual barrier partially broken" victory dance
07:40:55 <xplat> dankna: LALR with unification?  how does that work?
07:41:55 <dankna> xplat: LALR is the algorithm used to generate the parse table; unification is a feature supported by the code that runs the automaton
07:42:05 <xplat> the only unification-during-parsing i'm familiar with is the feature structure unification used in HPSG and some other NL syntactic theories
07:42:26 <dankna> cool, then this is hopefully relatively original work on my part
07:42:31 <dankna> I'm familiar with HPSG, yes
07:44:20 <dankna> what I am thinking is that the lexer will return a feature structure for each terminal, which will be unified with the feature structures for each particular type of terminal and treated as being any of those which it unifies successfully with
07:44:52 <dankna> well, actually a list of feature structures, to account for single words with multiple meanings
07:45:47 <dankna> each nonterminal will also have a feature structure associated with it, which will be unified with the result of the user-provided reduction rule
07:46:03 <dankna> hence it's my intention that this could be used for HPSG-style and also TAG-style things, although I'm less familiar with the latter
07:46:14 <dankna> and the former is what I'm planning to use it with
07:46:44 <dankna> since you know some theory, I'm curious what you think of this - whether it sounds like a reasonable thing to do, and whether it sounds like it adds anything novel
07:47:28 <xplat> i feel like it's a reasonable thing to do with GLR, maybe not as much with LALR
07:47:30 <dankna> I confess I haven't finished the HPSG book, but I don't believe it specifies how the grammar is to be parsed (for that matter I don't think TAG does either), only the general nature of it
07:47:50 <dankna> you mean, with non-GLR LR parsing
07:48:15 <dankna> LALR is the algorithm used to construct the parse table; GLR is the confusingly-named algorithm to execute it.  (it should really be named generalized shift-reduce)
07:48:48 <dankna> it doesn't matter for GLR's purposes whether the parse table comes from LALR(1) or SLR(1) or even LR(0)
07:49:17 <dankna> but yes, I think I may not support non-generalized parsing with unification
07:49:22 <dankna> as I can't think of a use-case for it
07:51:10 <dankna> since my application is merely an English-like programming language and not an attempt at modeling English in any sort of linguistically-solid detail, I'm not too concerned with what grammar formalism it corresponds to; I'm just using HPSG as a starting point because the book has a very nice explanation of how to model various phenomena and why they're done the way they are
07:51:34 <Twey> Argh, it's a COBOL!
07:52:05 <dankna> the TAG documentation is ... I can't say not as verbose, because it's just as many words, but it's like a page on each specific production of their high-coverage grammar, whereas HPSG is like a chapter on each production of their low-coverage grammar
07:52:17 <xplat> Twey: oh, come on, at least extend enough credit to say Applescript
07:52:19 <dankna> haha, no, hopefully not a COBOL
07:52:22 <dankna> nor an Applescript
07:52:31 <dankna> I've given a lot of thought to the deficiencies of Applescript, actually
07:52:44 <Twey> dankna: 1) It's intended to be English-like
07:52:48 <dankna> hehehe
07:53:04 <dankna> well, but, unless you're familiar with Inform 7, I don't think you can say that an English-like language is automatically bad
07:53:16 <dankna> Inform 7 has a Smalltalk object model
07:53:35 <dankna> "A person is a kind of thing, having a name, which is a string.  An employee is a kind of person, having a salary, which is an integer."
07:53:49 <quicksilver> I don't think applescript's flaws lie in its natural language model, precisely
07:53:53 <xplat> HPSG is definitely more approachable than TAG, even outside that one book
07:53:59 <quicksilver> (although they're not completely unrelated to it either)
07:54:10 <dankna> xplat: good to have that impression confirmed
07:54:28 <dankna> quicksilver: well, I think its flaws are somewhere in how its natural-language model relates to its data model
07:54:46 <dankna> quicksilver: applescript has no model for complicated data structures other than those implemented in other languages and exported to it
07:55:12 <dankna> quicksilver: furthermore, there's exactly one valid syntax for any given command, whereas a very important property of natural language is the ability to say the same thing in different ways for readability's sake
07:55:42 <Twey> dankna: I'm passing familiar with it.  Natlang-like programming languages were an interest of mine for a while.
07:55:52 <quicksilver> dankna: exactly one valid syntax isn't quite true
07:55:57 <dankna> Twey: cool
07:56:06 <quicksilver> dankna: (item 1 of x) and (the first item of x), say
07:56:27 <dankna> quicksilver: well, yeah, but that example is in the minority.
07:56:34 <quicksilver> but I agree with your basic point
07:56:39 <quicksilver> it's the opacity of the data model
07:56:40 <dankna> more typically you have to say insert bullet in foot left of self
07:56:45 <dankna> yeah
07:56:54 <Twey> I've eventually come to the conclusion that any such thing is going to be restrictive, verbose, and unpleasant, though, from both a programming-language *and* a natural-language point of view.  The things a programming language needs to express are simply not the same as the things a human language needs to express.
07:57:05 <quicksilver> it's not clear that for certain kinds of operation to be possible, the underlying type has to support them
07:57:12 <quicksilver> but there is no way of even documenting that
07:57:17 <quicksilver> because there are no words for it!
07:57:24 <dankna> quicksilver: right, perceptive point
07:57:57 <quicksilver> and some operations are fast, implying they are using underlying optimisations or indices, whilst isomorphic operations are slow
07:58:07 <quicksilver> and you can't understand why the optimisations or indices don't exist in the second case
07:58:09 <dankna> Twey: well, I aspire to show that your second sentence is wrong and that your first sentence merely describes efforts to date and not what's possible :)
07:58:29 <dankna> quicksilver: yes, absolutely.  string manipulation in it is horrible in that respect.
07:58:36 <quicksilver> I don't remember finding hypercard so frustrating
07:58:42 <quicksilver> but it was less faithfully natural language
07:58:48 <quicksilver> (and that was a long time ago, so I don't remember it very well)
07:59:08 <dankna> hypercard was fairly nice, but yes, it basically used English vocabulary with a C-esque grammar
07:59:37 <Twey> *shrug* Good luck.  Come and tell me when you've failed.  :þ
07:59:56 <dankna> Twey: I might have said the same as you, before I7, but I really find it quite an impressive work and at the very least I must attempt to duplicate it :)
08:00:03 <dankna> I shall!
08:00:04 <quicksilver> dankna: a specific example that bit me recently is that "get the first message of Inbox whose message-id is <foo@bar.123>" is extremely slow - it does a linear search through all messages comparing message ids.
08:00:16 <dankna> quicksilver: ouch!
08:00:27 <dankna> quicksilver: of course, you can run into the same problem in SQL
08:00:36 <quicksilver> dankna: whereas it's clear that Mail.app can access messages directly by message ID (try typing 'open message://<foo@bar.123>' in the shell)
08:00:50 <quicksilver> dankna: of cuorse. In any language. But in those other languages you can hope to understand why.
08:01:04 <quicksilver> in applescript I found no framework for understanding what would be fast and what would be slow
08:01:06 * hackagebot SoccerFun 0.4.4 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.4.4 (JanRochel)
08:01:10 <quicksilver> except cargo-culting examples
08:01:16 <quicksilver> and searchign scarce forum posts
08:01:18 <dankna> well, it's the "get ... whose ..." construct.  it's slow because it implies linear search no matter what, I believe.
08:01:44 <dankna> there is no mechanism in the ABI for the application to optimize it into a different type of query, because the scripting engine simply sees a list
08:02:07 * hackagebot SoccerFunGL 0.4.4 - OpenGL UI for the SoccerFun framework  http://hackage.haskell.org/package/SoccerFunGL-0.4.4 (JanRochel)
08:02:24 <quicksilver> dankna: I imagined that might be the case
08:02:46 <dankna> ideally access to complicated data structures would go through an SQL-style query planner
08:02:52 * quicksilver nods
08:02:58 <dankna> I'm not doing anything so ambitious, at least not for version one
08:03:14 <dankna> but I'm also not making everything be a list when it shouldn't, either
08:04:08 <dankna> instead I'm basically treating everything as a record
08:04:34 <dankna> it's my hope that container types can be implemented on top of this rather than requiring special grammatical support
08:05:06 <dankna> then you'll know what the efficiency considerations are because you'll be referring directly to the index, not to the abstract collection, because there will be no abstract collection
08:05:58 <quicksilver> dankna: have you seen YQL?
08:06:10 <dankna> "get the message with message-id <foo@bar.123> from the message-id hash of Inbox."
08:06:11 <dankna> more verbose, yes, but closer to the metal
08:06:23 <dankna> I wouldn't want to implement any sort of "get ... where ..." idiom without a planner
08:06:29 <dankna> no, I have not, and now I have to :) do you have a link?
08:06:43 <quicksilver> http://developer.yahoo.com/yql/
08:06:51 <quicksilver> it's not natural language, it's apropos of general query languages
08:06:55 <quicksilver> it's pretty bizarre.
08:06:56 <dankna> that's cool
08:07:13 <dankna> another thing I might consider doing is embedding the SQL grammar in my English grammar
08:07:33 <dankna> but it's not clear how to integrate that with the object model really
08:08:20 <dankna> hmmmm, YQL looks interesting, although bizarre as you say
08:08:24 <lars9> LINQ?
08:09:06 <dankna> ah - I had to look that up.  that's a framework for embedding SQL into .NET languages?
08:09:08 <dankna> orthogonal
08:09:58 <lars9> yep.
08:10:18 <lars9> another work embeds SQL into haskell
08:10:32 <dankna> well, I think that has its place
08:11:07 <lars9> it works like, if you apply map/filter/folder.. on lists, it's translated to sql and execute in db, then return results to haskell
08:11:16 <dankna> oh, that's fairly neat
08:11:25 <dankna> but
08:11:32 <dankna> what about transactions
08:12:03 <dankna> doing each operation in its own separate transaction is not really acceptable; for that you really need some more explicit support
08:12:12 <lars9> how to use Writer together with State? I want to log every change of state
08:12:12 <mlesniak> What is the best option for a Hashmap when I'm in the IO-Monad anyway? I could use Data.Map, but maybe having a "real" mutable data structure is better, performance-wise?
08:12:25 <dankna> mlesniak: use Data.Map :)
08:12:26 <quicksilver> LINQ carries the type structure of your SQL database into C#
08:12:47 <quicksilver> (by having access to your database schema at compile time)
08:12:51 <quicksilver> that's a neat system.
08:12:55 <dankna> hmm, okay.  right.  that is neat.
08:13:25 <quicksilver> there are haskell things which do that kind of thing but they all require a more explicit 'slurp the schema' step I think
08:13:26 <mlesniak> dankna: Tought so, but there should be an impure implementation of a map, especially for this situations
08:13:33 <lars9> quicksilver: i'll like it only if it supports other DBs
08:13:38 <dankna> mlesniak: implement one :)
08:14:01 <mlesniak> dankna: way too lazy (pun intended) ;)
08:14:02 <quicksilver> and I am not aware of anything which translates map/filter/foldr into SQL.
08:14:05 <dankna> ha
08:14:18 <quicksilver> (for haskell)
08:14:33 <lars9> mlesniak: a better methodology is to just use whatever you have now, and improve it only when it turns out to be a bottleneck
08:15:13 <mlesniak> lars9: quite right
08:15:42 <quicksilver> mlesniak: for some use cases the sharing of an immutable Map is a bigger win than the mutation of a truly mutable one.
08:15:51 <quicksilver> not every case clearly.
08:15:56 <lars9> quicksilver: i've deleted that slides and can hardly remember its name...
08:15:58 <mlesniak> quicksilver: yep, sounds reasonable
08:16:55 <mlesniak> btw: I have no idea about what exactly your guys are talking about, but when I read database and foldr and such, I remember a talk from  Jeroen Weijers titled Database Coprocessor for Haskell on IFL 2010. Maybe that's useful
08:17:04 <quicksilver> mlesniak: haskelldb?
08:17:12 <kmc> mlesniak, there's nothing "hash" about Data.Map.  but the "hashmap" package provides hash tries with pure functional update, based on IntMap
08:17:31 <mlesniak> kmc: ok
08:17:36 <quicksilver> mlesniak: actually I meant that for lars9 
08:17:38 <dankna> mlesniak: thanks for the thought :) I'm talking about designing an English-like programming language (using Haskell as the implementation language), and how it might integrate with databases.
08:17:40 <quicksilver> lars9: haskelldb, probably?
08:18:18 <quicksilver> but that's a DSL for specifying SQL queries
08:18:24 <quicksilver> it doesn't turn list operations into SQL operations
08:19:08 <lars9> quicksilver: no, a recent paper
08:19:16 <kmc> natural languages are terrible for giving precise instructions
08:19:36 <absentia> which raises the question.. which is preferable:
08:19:38 <dankna> kmc: I'm not convinced of that
08:19:51 <absentia> (1) preceise instructions, or (2) ability to easily instruct a computer?
08:20:00 <xplat> yeah, it seems like a sql-like planner-based model is more preferable for NL-like languages than a close-to-the-metal model
08:20:01 <mlesniak> kmc: http://blog.stephenwolfram.com/2010/11/programming-with-natural-language-is-actually-going-to-work/ *laughs*
08:20:04 <quicksilver> lars9: OK. There is a danger that recent papers describe things which don't, actually, exist ;)
08:20:06 <absentia> I'm 100% conviced #2 is preferable.
08:20:08 <mlesniak> I'm not sure that will work, too
08:20:16 <dankna> xplat: absolutely
08:20:22 <dankna> xplat: but harder to implement :)
08:20:48 <lars9> quicksilver: http://www-db.informatik.uni-tuebingen.de/publications that IFL 2010 paper
08:21:13 <lars9> quicksilver: i read it very briefly for its idea, not details though
08:21:14 <dankna> I have to laugh at the thought that Wolfram Alpha is anything revolutionary in NLP, too
08:21:45 <quicksilver> http://www-db.informatik.uni-tuebingen.de/research/ferry
08:22:01 <quicksilver> dankna: did you read about the IBM "Jeopardy!"-playing machine?
08:22:05 <dankna> I did not!
08:22:14 <xplat> mathematica was pretty nifty, but after that success wolfram got sort of a big head and became kind of cranky
08:22:33 <quicksilver> lars9: OK, again, it's not translating the list combinators.
08:22:43 <quicksilver> lars9: it's defining new combinators (which happen to have the same names)
08:22:47 <quicksilver> still, it's interesting work.
08:23:05 <quicksilver> does it actually exist, though?
08:23:14 <quicksilver> I don't see a download link on that research page
08:23:16 <dankna> well, defining combinators which have the same names is what I assumed he meant when he said it was translating them, actually
08:23:17 <quicksilver> I smell vapour.
08:23:36 <lars9> quicksilver: the authors mentioned a bug they encountered somewhere
08:23:36 <dankna> I mean, how else would you translate them - you'd have to hook in with Template Haskell or something, and it would be nasty
08:23:42 <lars9> *a bug of haskell
08:23:48 <quicksilver> dankna: they use quasiquoting
08:23:55 <quicksilver> and define something which looks rather like list comprehensions
08:23:56 <quicksilver> it seems
08:23:58 <lars9> or a limitation, dunno
08:23:58 <dankna> haha okay
08:24:26 <quicksilver> "Our Ferry/Haskell library will be available in open source form soon."
08:24:43 <lars9> quicksilver: i was looking for data parallel papers, and that one turns out not 
08:25:51 <quicksilver> dankna: http://www.nytimes.com/2010/06/20/magazine/20Computer-t.html?_r=1
08:25:56 <quicksilver> dankna: long article.
08:26:01 <quicksilver> it doesn't talk much about the NLP part.
08:26:08 <quicksilver> but the machine does do NLP, among other things.
08:26:28 <quicksilver> (it's a remarkably well written article, considering it's written by a journalist)
08:27:00 <dankna> quicksilver: interesting; giving it a look.
08:27:17 <lars9> dah... 8 pages
08:27:54 <quicksilver> lars9: not if you use safari it isn't ;)
08:28:53 <dankna> oh hey!  right!  the reader button :)  *clicks it*
08:29:44 <lars9> quicksilver: i chose to watch that video
08:29:53 <quicksilver> we all make choices
08:30:01 <quicksilver> I wish all the videos on the web would die in a cleansing fire
08:30:03 <quicksilver> but that's just me
08:30:30 <dankna> I wish speech-to-text tech were better so I could read a transcript of a video
08:30:37 <dankna> instead of watching it
08:30:49 <dankna> or more precisely, so I could skim the transcript for two seconds and then NOT read it
08:31:07 <lars9> i still dont like these "AI" works, they are just trying to pretent to be human
08:32:38 <dankna> well, yes, and I think answering Jeopardy questions is more showy than useful
08:32:50 <quicksilver> dankna: exactly (about video transcripts)
08:32:59 <therp> is there any maintenance for haskell.org? It seems to be down quite often the last few days
08:33:05 <quicksilver> about jeopardy questions: well, yes, in itself it's much more showy than useful
08:33:16 <quicksilver> but the interesting territory which may be traversed in building a solution
08:33:21 <quicksilver> *that* may turn out to be useful ;)
08:33:24 <lars9> behind the screen, ppl are just trying to use Markov/SVM/Regression/K-Means.../Supervised/Unsupervised learning etc to mimic human brain
08:33:29 <dankna> therp: it's unscheduled downtime if that's the question; but there is a migration to a new server in progress at some point
08:33:37 <quicksilver> lars9: pretending is good enough, if it works.
08:33:46 <dankna> quicksilver: yes, that is true enough
08:33:49 <therp> dankna: ok thanks :(
08:33:55 <copumpkin> lars9: ?
08:34:00 <copumpkin> who's pretending to be human?
08:34:03 <dankna> me!
08:34:04 <quicksilver> copumpkin: me.
08:34:10 <dankna> serves you right for not holding a Turing Tribunal
08:34:11 <copumpkin> :)
08:34:12 <quicksilver> copumpkin: were you fooled?
08:34:21 <quicksilver> copumpkin: you're pretending to be a gourd, but for the record, I'm not fooled.
08:34:30 <quicksilver> you're quite clearly coniferous.
08:34:30 <copumpkin> quicksilver: nah, you look shiny and liquid
08:34:31 <lars9> oops
08:34:35 <dankna> he's pretending to be a cogourd
08:34:36 <copumpkin> lol
08:36:38 <lars9> maybe the good side of these works is to attract public interests and get more fundings for scientific research:)
08:37:10 <dankna> that's true too
08:38:54 <quicksilver> well IBM are doing it to get commercial customers
08:39:06 <lars9> i don't think computer can ever understand natural language before we can understand how natural brain works:)
08:39:09 <quicksilver> they're hopign to get big public sector interest (health, government)
08:39:24 <quicksilver> actually private works too.
08:39:29 <dankna> oh it clearly makes sense for IBM to do things like this
08:39:43 <dankna> it helps maintain their position as a company that does serious research
08:39:46 <dankna> in the public eye
08:40:02 <dankna> given that I'm not clear on what IBM actually makes money from these days, that's kinda important :)
08:40:37 <dankna> anyway, I'm not interested -- well, I won't say not interested, as it's a fascinating problem, but I'm not intending to work on understanding full-blown natural language
08:40:37 <kmc> they still sell mainframes by the truckload
08:40:58 <quicksilver> kmc: 1 mainframe is a truckload.
08:41:02 <kmc> indeed
08:41:03 <dankna> I'm interested in how we can take elements of natural language and mix them with synthetic languages to useful result
08:41:16 <dankna> lol
08:41:41 <quicksilver> as far as I know IBM make most of their money from services not hardware these days
08:42:16 <lars9> i dont see the possibility for computer to understand chinese, chinese grammer is fuzzy, chinese words are full of cultural references ... : it's anti-computer:)
08:42:43 <dankna> lars9: I don't know Chinese, but I've never heard any sound explanation of how it's more like that than English is.  English is pretty fuzzy too though.
08:42:59 <dankna> neologisms in particular are hard
08:43:13 <dankna> especially when the meaning of the new word can only be untangled with cultural context
08:43:36 <quicksilver> dankna: cultural lolcat is cultural
08:43:38 <dankna> good examples are not coming to mind, but I'm sure you get the idea
08:43:40 <dankna> yeah, that.
08:43:46 <dankna> the entire lol- construction
08:44:09 <dankna> I saw a site called lolgays and swiftly understood what it was because I was familiar with the concept of lolcats
08:44:18 <dankna> I can but imagine how bizarre it would seem to a computer :)
08:44:27 <dankna> "But but, the captions are saying things that have no point!"
08:44:29 <lars9> well, in chinese, there is no do->did, he-she, is-are
08:45:00 <quicksilver> I'm not sure snowcloning is computational unfeasible
08:45:06 <lars9> the order sometimes does not matter, for example: AABB sometimes means ABAB
08:45:07 <dankna> and as you mention, the "Adj noun is adj" construction
08:45:15 <quicksilver> it's just one among a number of tricky things
08:45:55 <dankna> that's true, snowcloning in general can probably be done, but learning new snowclones that aren't programmed in...
08:46:07 <lars9> not clear border between noun and adj
08:46:21 <dankna> and I'm completely sure it's computationally feasible, for a very simple reason: the human brain is just as limited by the laws of computation as a computer is
08:46:23 <lars9> *no
08:46:29 <dankna> if WE can do it, a computer can do it - in principle, if we can figure out how
08:46:50 <dankna> lars9: well, that does sound difficult
08:47:20 <lars9> and some components are often omitted, depends on customs
08:47:36 <dankna> well, English has omitted components too - most languages do
08:48:01 <lars9> in english "i like to be beautiful" and "i like beautiful things", in chinese they are "i like beautiful"
08:48:03 <xplat> yeah, English is as weird as other languages are [weird].
08:49:00 <lars9> no way to interpret without context, and it's very common
08:49:05 <dankna> lars9: I presume that Chinese is your first language?  I take no position on the specific claims you are making, although they sound reasonable, but I think everyone thinks of their own language as inherently bizarre and stranger than all others.
08:49:26 <quicksilver> what "Watson" does, which is interesting as an idea, is essentially comprehending things by searching a huge huge corpus of documents and looking for similar constructs.
08:49:38 <quicksilver> that's almost exactly what you would do if your *goal* was to understand snowclones.
08:49:53 <xplat> in English you can say 'i love chinese' and it can mean language are food.  a 'cotton sack' can be made of cotton or used for holding cotton.
08:50:03 <dankna> Whereas in fact there is hidden logic, rules which native speakers follow without even knowing they exist, while second-language speakers have to learn them explicitly.  My favorite example of that is the rule for the order in which a chain of adjectives goes in English.
08:50:04 <xplat> ('or' not 'are')
08:50:05 <quicksilver> it's also quite a feasible idea - storage keeps getting bigger and faster, and searching and indexing are quite well understood.
08:50:19 <dankna> quicksilver: yeah, I finished the Watson article now
08:50:30 <dankna> and I agree, it's a powerful idea
08:50:43 <dankna> xplat: good examples
08:50:50 <quicksilver> what watson is capable of now, will be possible in a mobile phone in 10 years time.
08:50:57 <dankna> well, maybe 20
08:51:14 <xplat> dankna: i couldn't even figure out what the rule is for adjective chains, although i came up with some heuristics i seemed to use
08:51:17 <quicksilver> I bet it's close to 10 than 20 ;)
08:51:29 <dankna> xplat: hang on, I found a good reference on that rule once, give me a sec
08:51:32 <dankna> perhaps :)
08:51:46 <lars9> dankna: yeah, i am biased, as everyone does :D
08:51:49 <dankna> http://www-users.cs.york.ac.uk/susan/cyc/a/adj.htm
08:52:02 <quicksilver> colourless green cat dreams furiously.
08:52:05 <dankna> opinion, size, age, shape, color, nationality, material, purpose
08:52:34 <dankna> Colorless green cat is colorless.  And green.
08:53:29 <quicksilver> colourless green cat is actually a butterfly dreaming (furiously) than he is a colourless green cat.
08:53:34 <dankna> haha
08:53:35 <dankna> nice
08:54:11 <lars9> dankna: but my opinion comes with some reasons, 1. the only Logogram language alive (http://en.wikipedia.org/wiki/Logogram) 2. seperation of writing/speaking languages.
08:54:50 <dankna> how is Japanese not a logogram language?
08:54:51 <yrlnry> Is there a standard name for    cond b x y = if b then x else y?
08:54:59 <dankna> the separation of written and spoken languages is indeed a good point
08:55:13 <lars9> dankna: oh, the hanji in Japanese are actually chinese characters
08:55:23 <xplat> if eskimos have 100 words for snow, #haskell users have a hundred words for 'colorless green cat'
08:55:33 <dankna> lars9: well, I'm aware of that.  okay.  fair.
08:55:36 <lars9> hanji = han ji = 'chinese' 'char'
08:55:41 <dankna> yes, I know :)
08:55:57 <copumpkin> lars9: they're typically called kanji in japanese
08:56:00 <copumpkin> or hanzi in chinese :P
08:56:04 <JimmyRcom> in haskell is it best to just say "<i>" ++ italicizedData ++ "</i>"? in erlang it was stressed always better to do ["<i>",italicizedData,"</i>"] and then flatten the list.
08:56:05 <copumpkin> kanzi?
08:56:06 <lars9> copumpkin: yep
08:56:12 <dankna> I won't get into the politics of who really deserves credit; the point is taken that they are of common descent
08:56:34 <quicksilver> yrlnry: @pointless calls it if' 
08:56:57 <quicksilver> yrlnry: cond is normally used for [(Bool,a)] -> a, or something like that
08:57:01 <dankna> JimmyRcom: I personally do the former; I don't know why Erlang would have a preference
08:57:09 <dankna> JimmyRcom: possibly some efficiency issue
08:57:09 <xplat> all languages separate writing and speaking registers, chinese is just an outlier on a continuum linguistically (although it's a difference of kind culturally)
08:57:13 <Taejo> JimmyRcom: the important thing is to avoid ("<i>" ++ italicizedData) ++ "</i>"
08:57:26 <yrlnry> quicksilver:  thanks.
08:57:30 <yrlnry> :t if'
08:57:31 <lambdabot> Not in scope: `if''
08:57:36 <quicksilver> JimmyRcom: I personally use concat ["<i>",italicizedData,"</i>"]
08:57:46 <quicksilver> JimmyRcom: because I find the , less offensive than ++
08:57:51 <dankna> ah, and what Taejo said, because doing it the way he shows would be slower
08:58:05 <quicksilver> and I prefer the way [...,..,...] indents and the brackets balance in an editor
08:58:09 <dankna> since a string in Haskell is a linked list of characters, append is not O(1)
08:58:13 <quicksilver> JimmyRcom: these are basically stupid aesthetic reasons.
08:58:41 <dankna> if you are dealing with very large strings, you may find the bytestring module to your liking
08:58:55 <kmc> bytestring is a string of bytes, not of characters
08:59:03 <dankna> yes, indeed
08:59:07 <kmc> if you are dealing with text, you may find the text package to your liking
08:59:11 <dankna> oh, haha, yeah
08:59:15 <xplat> bytestring is an array of bytes, or a list of arrays of bytes, depending which kind
08:59:16 <JimmyRcom> thanks dankna, taejo, quicksilver. 
08:59:53 <dankna> we used to have a bot in another channel which would randomly say things like "YOU'RE a list of arrays of bytes!" in response to things like that
09:00:10 <xplat> Data.Text is bytestrings wrapped to understand characters
09:00:20 <dankna> it was somewhat obnoxious, but pretty funny the first time
09:00:23 <xplat> dankna: we always did that by hand where i'm from
09:00:26 <dankna> haha okay
09:00:28 <JimmyRcom> I think it said to always use it in erlang probably because "iolists" combining binary and strings are traversed more efficiently internally than converting and concatenating in erlang
09:00:56 <dankna> so an Erlang peculiarity then.  gotcha.
09:03:51 <Twey> copumpkin: ‘Kanzi’/‘kanji’ are both valid romanisations for the Japanese in different systems.  ‘Kanzi’ is the official ‘Japan style’ sanctioned by the government; ‘kanji’ is the ‘Hepburn style’ often favoured by English-speakers and materials targetted at them because it attempts to express Japanese in terms of English phonetics.
09:03:59 <copumpkin> Twey: yeah, I know
09:04:08 <copumpkin> my japanese textbook used zi
09:04:26 <Twey> Oh, okay.  You put a question-mark, so I thought you might be confused.
09:04:40 <lars9> if I want to log state change of a State Monad, do I have to use Monad Transformers?
09:04:44 <copumpkin> oh, no, I'm just dumb
09:04:57 <xplat> yeah, my textbook used zi too
09:05:07 <applicative> is there a simple way of turning something like (a -> IO Bool) into IO (a -> Bool)?  Why am I in such a muddle
09:05:23 <applicative> sorry, IO (a -> IO Boo)
09:05:37 <copumpkin> return?
09:05:38 <Saizan> lars9: that'd be the usual way
09:06:24 <xplat> the problem with systems other than hepburn is you can't even come up with a heavily-accented-but-close pronunciation unless you studied japanese
09:06:33 <lars9> Twey copumpkin : we can understand both k/h z/j, like accent of different places
09:06:37 <applicative> sorry, what I want to do is somehow mix filter  with doesFileExist with  getDirectoryContents
09:06:45 <applicative> for example
09:06:54 <lars9> Saizan: i notice a RWS monad, does it work?
09:07:04 <copumpkin> lars9: nah, we just keep it there for looks
09:07:07 <MasseR> applicative: filterM?
09:07:20 <applicative> @type filterM 
09:07:21 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
09:08:00 <applicative> right, that solves this problem of course. 
09:08:20 <Saizan> lars9: it works, afaiu it's easy to get space leaks with it though, but i don't know the detials
09:08:45 <applicative> but I think I was looking for some way to use a quasi applicative style, in a more general way,
09:09:01 <lars9> Saizan: thanks lemme check more docs
09:09:18 <xplat> if you want to log all changes of state you might want to make your own MonadState that logs automatically
09:09:49 <applicative> lots of functions are of the form (a -> IO b) , I want to find corresponding IO (a -> b) functions.  
09:10:19 <dankna> not possible in general
09:10:29 <lars9> xplat: append state change into states? sounds wierd..
09:10:58 <applicative> why not? I'm blocked by idiocy
09:11:41 <byorgey> @ask dmead what's the presentation about?  I normally play bridge on Monday nights.
09:11:41 <lambdabot> Consider it noted.
09:12:30 <dankna> well, because ...
09:12:39 <xplat> like, [s] -> (a, [s]), get = head &&& id, put x = const () &&& (x:)
09:12:43 <byorgey> applicative: a -> IO b  lets you decide what IO actions to run based on the a.  IO (a -> b) means you have to decide which IO actions to run before you get out an (a -> b) function
09:12:43 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
09:12:50 <applicative> i feel like I should be able to define  getFileNames dir  with doesFileExist and getDirectoryContent
09:13:00 <dankna> thank you, that's what I would have said if I had been smart enough, byorgey :)
09:13:45 <copumpkin> applicative: why would getDirectoryContents return files that don't exist?
09:13:50 <dankna> and you can, with filterM.  getFileNames = getDirectoryContent >>= filterM doesFileExist
09:13:58 <quicksilver> copumpkin: they could be directories
09:14:03 <dankna> I think doesFileExist - yeah, directories
09:14:08 <xplat> or dead symlinks
09:14:16 <applicative> sorry, i mean something a -> IO Bool 
09:14:25 <copumpkin> getDirectoryContents >=> filterM doesFileExist
09:14:38 <applicative> something FilePath -> IO Bool
09:15:11 <copumpkin> applicative: that's what filterM does
09:15:49 <applicative> yes, but I feel like I have a more general problem I keep hitting on.  I will look at the filterM source. 
09:15:59 <xplat> lars9: with that MonadState you could even add an unput function ...
09:16:09 <copumpkin> applicative: well, you could probably do it with a MonadPlus on the outer "list"
09:16:27 <copumpkin> or MonadZero, if it existed
09:17:18 <shepheb> :t (>=>)
09:17:19 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
09:17:40 <lars9> xplat: yeah, that's like using state for logging. but state usually means something more important.
09:17:47 <byorgey> shepheb: it's flipped function composition, but with effects!
09:17:56 <shepheb> byorgey: so I see
09:18:06 <byorgey> NEW AND IMPROVED, now with 100% MORE EFFECTS
09:18:08 <applicative> copumpkin, yes, lists are distracting me a bit here.  
09:18:24 <xplat> applicative: you have hit on a general problem.  if you want to do something with pure combinators 'in a monad' you have to reimplement them, because a monad has weaker algebraic properties and so the regular definitions become ambiguous in a monad
09:18:44 <byorgey> shepheb: if you like category theory I could tell you some other fancy words about it.  But otherwise I won't bother ;)
09:19:04 <shepheb> byorgey: fire away
09:19:26 <byorgey> shepheb: well, (<=<) (the unflipped version) is just composition in the Kleisli category for the monad m
09:19:59 <byorgey> shepheb: return :: a -> m a  is the identity arrow for a.
09:20:05 <applicative> is there a natural IO (a -> IO b) -> IO (a -> b)  I feel that inside the monad i should be able to do something like this
09:20:06 <byorgey> shepheb: and the monad laws state precisely that this is a category.
09:20:41 <applicative> it's easy to get an IO a -> IO b out of it.
09:20:51 <xplat> (since we're throwing around these words, the problem is that the kliesli category of a monad doesn't inherit all the laws that hold in the underlying category Hask)
09:21:28 <byorgey> applicative: no, you still have the same problem.  the first version gets to decide on some IO effects depending on an a.  The second version has to decide on all the IO effects up front before it ever sees an a.
09:22:13 <applicative> byorgy, I am thinking
09:22:33 <xplat> applicative: you can tell whether types involving monads are inhabited by using modal logic
09:22:58 <byorgey> xplat: oh, please explain, I've never heard of that before!
09:23:01 <xplat> applicative: interpret '->' as 'implies', and the monad constructor as 'possibly'
09:23:22 <applicative> Box (a -> Box a)  wont give me Box ( a -> b) ?
09:23:27 <quicksilver> ISTR that's not right.
09:23:38 <xplat> so 'a -> IO b' becomes 'if a, then possibly b'
09:23:39 <quicksilver> none of the standard modalities has the rules you want for a monad
09:23:58 <applicative> oh of course, never looked into this analogy
09:24:03 <Eduard_Munteanu> "Possibly"?
09:24:11 <copumpkin> applicative: you want ((->) r) to be traversable, it seems?
09:24:25 <copumpkin> :t sequenceA
09:24:26 <lambdabot> Not in scope: `sequenceA'
09:24:30 <copumpkin> :t Data.Traversable.sequenceA
09:24:31 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Data.Traversable.Traversable t, Applicative f) => t (f a) -> f (t a)
09:24:33 <applicative> Diamond (a -> Diamond b) doesn't give you Diamond (a -> b) 
09:24:36 <applicative> or does it
09:24:43 <Eduard_Munteanu> That to me, looks like applying the reasoning to Maybe.
09:24:53 <copumpkin> applicative: just think of Maybe
09:24:56 <copumpkin> a -> Maybe b
09:25:01 <copumpkin> Maybe (a -> b)
09:25:01 <quicksilver> http://blog.sigfpe.com/2006/11/from-l-theorem-to-spreadsheet.html
09:25:08 <quicksilver> ^^ sigfpe shows the rules aren't right.
09:25:26 <quicksilver> or perhaps someone else does in the comments
09:25:30 <quicksilver> I don't remember, I read that a long time ago.
09:25:33 <copumpkin> applicative: the only way it could give the total function a -> b is by verifying that the function a -> Maybe b is Just x for all inputs
09:25:58 <applicative> yes, this is helping
09:26:04 <copumpkin> instance Enumerable r => Traversable ((->) r) where
09:26:06 <xplat> quicksilver: sigfpe was mixing in general recursion, which always destroys logic
09:26:23 <copumpkin> applicative: however, it's inefficient as hell
09:27:08 <quicksilver> xplat: but ashley points out that no standard modality satisfies fmap
09:27:15 <quicksilver> xplat: and yet, fmap is a theorem of monads.
09:28:04 <quicksilver> read ashley's comments, anyhow ;)
09:28:07 <quicksilver> maybe I simplified.
09:28:36 <applicative> somehow, i keep thinking something is possible, though these examples show I keep formulating it too generally. 
09:29:24 <xplat> ah, hm.  yet moggi seems to think there's a modality involved and i trust moggi more.
09:30:44 <quicksilver> xplat: in a very general sense of modality, I believe.
09:30:47 <applicative> copumpkin, I think traverse is indeed the place I"m in
09:30:58 <quicksilver> xplat: not that "this is one of the standard axiom schemes like S4 or S5"
09:31:09 <quicksilver> xplat: but in the sense that any unary connective in a logic is a modality.
09:31:30 <copumpkin> not even sure my instance would work
09:31:33 <copumpkin> but it does for Maybe
09:33:51 <xplat> anyway, despite whether modal logic justifies it or not, m (a -> m b) -> m (a -> b) is not nontriially inhabited
09:33:59 <xplat> nontrivially
09:34:40 <xplat> (you of course have undefined and unsafeCoerce)
09:35:42 <applicative> we have all these functions like fmap which raises a -> b to f a -> f b , and (=<<) shifting a -> m b into ma -> m b , and ap etc shifting m (a -> b) into m a -> m b
09:35:49 <xplat> just think, what would it do for putStrLn?
09:36:45 <xplat> hand 'return putStrLn' to your function and what would you expect to get out?
09:37:59 <copumpkin> an unsafePerformIO application!
09:38:02 <quicksilver> return (const ()) !
09:38:48 <xplat> copumpkin: ha, pretty much
09:38:53 <applicative> yes, i see this -- probably not well enough -- but there is another feature of the contexts I imagine I can do this in, which I cant put my finger on
09:39:57 <applicative> how about IO (IO (a -> IO b) ) can't I flatten that out somehow?  
09:40:15 <xplat> so, what, liftM (unsafePerformIO .)?
09:40:35 <copumpkin> is lambdabot dead?
09:40:41 <copumpkin> applicative: you can do it for a comonad
09:40:57 <copumpkin> actually, maybe you can't even do that
09:41:03 <applicative> i will think about that.  the cases I am always thinking of really are where unsafePerformIO wouldn't feel wrong....
09:41:38 <copumpkin> applicative: it feels very wrong here, to me
09:41:49 <copumpkin> there are places where it doesn't feel wrong, but this isn't one of them
09:41:59 <xplat> if unsafePerformIO wouldn't feel wrong to you in that directory-filtering case, your sense of wrongness needs calibration
09:42:04 <copumpkin> what would [a -> [b]] -> [a -> b] even do?
09:42:05 <HugoDaniel> has anyone tried ghc 7 ?
09:42:08 <applicative> sorry, yes, i still think this isn't because i'm ont making my characteristic problem clear.  
09:42:10 <HugoDaniel> does it rock the house ?
09:42:44 <copumpkin> directory filtering can be done easily with filterM
09:42:50 <copumpkin> which is what it's designed for :P
09:42:53 <applicative> I mean my cases feel like unsafePerformIO (return x)
09:44:30 <copumpkin> I don't see it
09:45:03 <copumpkin> unless you want applicative'sFunction (return putStrLn) to do return (const ()) as quicksilver said
09:45:16 <copumpkin> but () is different, and you can't do it in general
09:47:00 <xplat> yeah, that's all because () is final in the unlifted category
09:47:41 <xplat> so there's a generic element of a -> () and it's the only possible one
09:48:24 <xplat> for a -> b you have to go to the lifted category even to get generic elements, and then they're not unique
09:48:47 <xplat> although they are almost unique
09:49:27 <xplat> undefined and \x -> undefined don't act very different
09:50:00 <Twey> xplat: You can do (\x -> undefined) y and not explode
09:50:10 <xplat> although that's because haskell is lazy, they DO act very different in a strict language
09:51:14 <xplat> as Twey observed
09:52:04 <xplat> > const () (undefined :: () -> ()) ()
09:52:05 <lambdabot>   Couldn't match expected type `() -> t' against inferred type `()'
09:52:13 <xplat> er
09:52:19 <xplat> > const () $ (undefined :: () -> ()) ()
09:52:20 <lambdabot>   ()
09:52:41 <xplat> > const () $ ((\x -> undefined) :: () -> ()) ()
09:52:42 <lambdabot>   ()
09:52:52 <Twey> > length [undefined 5]
09:52:53 <lambdabot>   1
09:53:00 <Twey> Harumph
09:58:54 <jmcarthur> *sigh* everywhere i look now i see opportunities for my code to be improved if only haskell had completely lazy evaluation :\
09:59:01 <dankna> heh
09:59:42 <copumpkin> jmcarthur: like what?
10:00:13 <xplat> completely lazy?  like the super-lazy 'if' conal was talking about on his blog?
10:00:50 <jmcarthur> xplat: no. this would be somewhere between call-by-need and optimal evaluation
10:01:13 <xplat> i need to read about optimal evaluation sometime ...
10:01:13 <jmcarthur> xplat: if you know what "full laziness" is then complete laziness is a step beyond that
10:01:49 <jmcarthur> i just thought of a cool example. in computer graphics we often use 4x4 matrices for affine transformations. one typically stores a matrix directly and models composition of affine transformations as a matrix multiply. with completely lazy evaluation, this would be done for us already whenever we use function composition to combine affine transformations
10:02:29 <jmcarthur> copumpkin: ^^
10:03:11 <jmcarthur> so you could have affine transformations just be normal functions instead of having a specialized matrix representation
10:03:13 <xplat> http://www.lsv.ens-cachan.fr/Publis/PAPERS/PDF/sinot-wrs07.pdf ?
10:03:36 <jmcarthur> xplat: if that's the natural semantics paper then that's it
10:04:04 <jmcarthur> xplat: there's been some other research too. a thesis called "Lazy Specialization". it gets a couple things wrong, IMO, but it has a cool test
10:04:25 <jmcarthur> xplat: i think there is also some research into getting completely lazy evaluation in UHC *crosses fingers*
10:04:52 <xiackok_> hi everyone
10:04:53 <jmcarthur> xplat: actually i think the UHC effort is toward optimal evaluation... which i think shows a bit less promise, personally
10:05:13 <xplat> michael jonathan thyer?
10:05:17 <jmcarthur> xplat: optimal evaluation as it is understood currently is very complex. lots of bookkeeping
10:05:20 <jmcarthur> yes
10:05:39 <yrlnry> I have a type constructor  data Heap a = Null | Node .......  deriving Eq.   I tried  isempty = (== Null), and ran afoul of the monomorphism restriction.  Declaring isempty :: Heap a -> Bool does not solve the problem.  But evaluating isempty should not require that a be an instance of Eq.  
10:05:57 <yrlnry> Any comments or remarks?
10:06:25 <xiackok_> is anybody try to install happs-tutorial 0.9.4?
10:07:57 <xplat> that's not the monomorphism restriction.  or not only it.
10:08:13 <copumpkin> yrlnry: you're using (==)
10:08:17 <copumpkin> isEmpty Null = True
10:08:17 <orlandu63> yrlnry: (Eq a) => Heap a -> Bool ?
10:08:21 <copumpkin> isEmpty _ = False
10:08:32 <copumpkin> (==) is a method of the Eq typeclass
10:08:54 <xplat> {isEmpty Null = True; isEmpty _ = False}
10:09:10 <copumpkin> he doesn't need Eq
10:09:50 <yrlnry> Yeah, it's DMR if I omit the declaration entirely, and a different error, which I didn't read (BOOO) if I do include the declaration.
10:10:10 <yrlnry> And here I thought I was being so clever by using (== Null) instead of definition by two cases.
10:10:10 <xplat> i mean, unless you wanted to implement a special Eq instance for heaps that only cares about the shape, and that sounds like a bad idea
10:10:20 <yrlnry> Thanks folks.
10:10:27 <xiackok_> when i was tried running happs-tutorial it giving error
10:10:33 <xiackok_> like that:
10:10:33 <xiackok_> xiackok@xiackok-debian:~/Belgeler/Programlama/Haskell/Web/hasppstack-tutorial$ happs-tutorial 5001 True True
10:10:33 <xiackok_> happs-tutorial: ./foreigncharsInclude.st: hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
10:11:01 <xiackok_> how can i solve this problem
10:12:32 <Twey> yrlnry: Alternatively, data Heap a = Maybe (Heap a), and use isNothing
10:12:34 <Twey> Er
10:12:42 <Twey> yrlnry: Alternatively, data Heap a = Heap (Maybe (Heap a)), and use isNothing
10:12:58 <yrlnry> OH THE SUFFERING
10:13:09 <xplat> yrlnry: if you like pointfree that much there's always 'type Heap a = Mu (Maybe `O` HeapNode)'
10:13:17 <Twey> Hehe
10:13:28 * Twey wishes we had a type-level $
10:13:32 <yrlnry> xplat:  That's a great idea, thanks!
10:13:34 <Eduard_Munteanu> Pointfree in types? Heh.
10:13:39 <alex404_> If I
10:14:04 <yrlnry> alex404_:  yes.
10:14:10 <xplat> Twey: yes, oh so much.  really, it was clever defining $ as a function, but it ought to be syntax
10:14:23 <alex404_> If I'm building vectors and I use (generate n fun1 ++ genreate m fun2) this is just as effecient as (generate (n+m) wacky fun)?
10:14:25 <jmcarthur> Eduard_Munteanu: TypeCompose and category-extras have a lot of relevant things for that
10:14:27 <alex404_> yrlnry: :P
10:14:27 <sproingie> $ is fine as a function at the function level
10:14:33 <sproingie> i like being able to map it
10:14:36 <copumpkin> O bugs the hell out of me
10:14:41 <copumpkin> just the name
10:14:46 <Eduard_Munteanu> Hm, I think I've seen Mu there, but never paid attention.
10:14:56 <xplat> then not only could you use it in types, you could do things like 2 * $ 1 + 3
10:14:56 <Eduard_Munteanu> (there as in category-extras)
10:15:08 <Twey> xplat: 's true
10:15:13 <jmcarthur> copumpkin: i use polymorphic function composition when i can, and that means i can use the nice unicode composition operator :D
10:15:42 <roconnor> @type floor
10:15:43 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
10:15:48 <sproingie> having arbitrary functions at type-level would be nice, probably take a whole new language
10:15:59 <jmcarthur> sproingie: agda :)
10:16:06 <xplat> sproingie: whenever you map $ you can just map id instead, it's the same function with a magic name
10:16:07 <jmcarthur> (or other dependently typed languages)
10:16:13 <Eduard_Munteanu> jmcarthur: does that automatically work with UnicodeSyntax, or you have to define it?
10:16:21 <sproingie> xplat: hm true and the precedence doesn't enter in to it
10:16:22 <roconnor> instance RealFrac CReal where
10:16:22 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
10:16:23 <roconnor>   properFraction x@(CR x') = (fromInteger n, x - fromInteger n) where n = x' 0
10:16:30 <roconnor> ^^ this is a very bad instance
10:16:31 <jmcarthur> Eduard_Munteanu: it's like a "lowercase" type variable. no definition needed
10:16:35 <sproingie> xplat: but so much can be done with functions that requires syntax in other languages :)
10:16:37 <jmcarthur> Eduard_Munteanu: needs TypeOperators, though
10:16:40 <yrlnry> Who invented the ($) trick?
10:19:53 <Martty> banks
10:20:29 <jmcarthur> i should be a little more clear on what i said about affine transformations. i doubt completely lazy evaluation would see the associativity of matrix multiplication all by itself. i just mean that the potential actually exists
10:20:58 <jmcarthur> given perhaps a hint to the runtime that an operator is associative, it would definitely happen
10:22:07 <xplat> associativity of matrix multiplication follows from associativity of function composition in your representation, doesn't it?
10:22:31 <applicative> xplat, is there a good treatment of such a topic as ": you can tell whether types involving monads are inhabited by using modal logic"
10:23:26 <jmcarthur> xplat: hmm...
10:23:56 <xplat> applicative: i've heard 'types and programming languages' covers that sort of thing, although there are soem coq and agda-related expositions that concentrate on that aspect more
10:24:58 <xplat> it's all tied together through the curry-howard correspondence (or curry-howard isomorphism, although the isomorphism is technically too specific to encompass modal variants)
10:25:06 <jmcarthur> (+1) . (+2)  =  \x -> (+1) ((+2) x)   ...  i'm not entirely sure that without a hint at the associativity of (+) that this could be optimized to  \x -> x+3
10:26:12 * hackagebot hmatrix 0.10.0.1 - Linear algebra and numerical computation  http://hackage.haskell.org/package/hmatrix-0.10.0.1 (AlbertoRuiz)
10:27:32 <xplat> oic, you'd need to know the associativity of the underlying primitives to rewrite (+1) . (+2) to (+ (2+1))
10:27:41 <jmcarthur> right
10:27:55 <xplat> but it should propagate up to matrix multiplication from there
10:28:00 <jmcarthur> still, completely lazy evaluation at least makes such an optimization possible
10:28:03 <jmcarthur> yeah i think so
10:28:10 <jmcarthur> once you have (+) and (*) or something
10:28:36 <jmcarthur> dunno. need to think on it more
10:28:38 <c_wraith> This sounds vaguely like the full-laziness-transform optimization that sometimes causes space leaks in ghc
10:28:45 <jmcarthur> c_wraith: it's a step further
10:28:54 <jmcarthur> c_wraith: and yes, it would need to be controlled
10:29:28 <xplat> according to the abstract of the one paper it's equivalent to partial evaluation in power
10:29:37 <xplat> not wuite sure what that means, though
10:29:43 <jmcarthur> c_wraith: i think the conversation conal and i had yesterday hints at a possibility for fixing such space leaks (unevaluation)
10:29:57 <jmcarthur> xplat: it's actually more powerful
10:30:02 <jmcarthur> xplat: completely lazy, that is
10:30:19 <jmcarthur> xplat: it can partially evaluate functions that are dynamically constructed, not just statically
10:34:08 <xplat> ah, so more like multi-staged partial evaluation
10:34:27 <xplat> rather than the simple version
10:35:56 <jmcarthur> i'm not sure what you mean by multi-staged
10:36:19 <jmcarthur> it's like lazy partial evaluation
10:37:59 <xplat> well, probably multi-staged partial evaluation : complete laziness :: higher-order functions : laziness
10:38:38 <xplat> on the right sides we have 'same power, less programmer-side bookkeeping'
10:40:12 <xplat> multi-staged PE lets you construct functions and PE them at runtime, but in general you have to schedule this by hand, much like with a strict higher-order language you can make your own thunks
10:40:37 <jmcarthur> ah
10:41:01 <jmcarthur> okay, then you could say this is lazy multi-staged partial evaluation, if i understand correctly
10:44:37 <xplat> kinda, yeah
11:06:09 <jordandanford> Has anyone here had success with the plugins package?
11:10:20 <mm_freak> someone should propose optionally adding the "qualified" keyword /after/ the module name in import lines
11:10:26 <mm_freak> import Data.Map qualified as M
11:12:42 <opqdonut> how about after "as" too?-)
11:12:52 <opqdonut> import Data.Map as qualified M
11:13:26 <opqdonut> or in the end? "import Data.Map as M, qualified" or in the beginning? "qualified import Data.Map as M"?
11:13:29 <opqdonut> :)
11:13:58 <opqdonut> maybe even allow multiple qualified keywords: qualified import qualified Data.Map as qualified M, qualified
11:16:13 <monochrom> oh, pokoko has been here!
11:16:58 <aristid> monochrom: is he that famous?
11:17:55 <monochrom> famous for short attention span
11:32:56 <ziman> @quote attention.span
11:32:56 <lambdabot> No quotes match. That's something I cannot allow to happen.
11:34:21 <ziman> @quote interested
11:34:21 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
11:38:56 <magicman> @unmtl Cont Bool
11:38:56 <lambdabot> err: `Cont Bool' is not applied to enough arguments, giving `/\A. (A -> Bool) -> Bool'
11:39:00 <magicman> @unmtl Cont Bool a
11:39:00 <lambdabot> (a -> Bool) -> Bool
11:40:09 <solistic> Is there a way to have an anonymous constructor for an newtype?
11:40:38 <opqdonut> in what way anonymous?
11:40:50 <endojelly> I suspect lambdaific
11:41:09 <endojelly> embedded in types instead of explicit newtype decls
11:41:13 <monochrom> usually you use "Cont r (your return type)" and leave r polymorphic (until you runCont)
11:41:19 <endojelly> (yeah, lambdaific isn't a word.)
11:42:11 <monochrom> lambdaific is terrific!
11:42:21 <solistic> I just have the problem that I get a warning about an unused data constructor for my mtl-constructed custom monad
11:44:22 <jmcarthur> solistic: you mean that at no point do you construct anything of that type? and you don't export the constructor?
11:44:50 <solistic> yes
11:45:04 <jmcarthur> solistic: then, well, what's the point of the newtype?
11:45:42 <monochrom> you can probably just delete the type and transitively all functions mentioning that type, and observationally no one would know the difference.
11:45:51 <applicative> maybe solistic feels more secure wrapping it up; i understand...
11:46:16 <jmcarthur> applicative: but it sounds like it serves no purpose in his library/program right now
11:46:25 <solistic> jmacarthur: newtype Foobar a = Foobar { runFoobar :: StateT ProgramState MPD a } deriving (Monad, Functor, MonadIO, MonadState ProgramState, MonadError SomeOtherMonad, MonadMPD)
11:46:38 <solistic> jmacarthur: that is about what I use
11:46:39 <jmcarthur> solistic: so how do you construct something of type Foobar a?
11:46:59 <monochrom> or rather, how do users obtain it
11:47:26 <solistic> mortberg: good question, they do not obtain it, they only run it
11:47:48 <solistic> mortberg: sry, was for monochrom 
11:47:48 <jmcarthur> oh i see the issue here...
11:48:05 <jmcarthur> solistic: you are exposing MonadState and all that instead of creating your own "accessors"
11:48:09 <applicative> is there a reason not to just use the abbreviative newtype Foo a = StateT ProgramState MPD a 
11:48:18 <jmcarthur> solistic: if you are doing that then you might as well just use a type alias instead of a newtype
11:48:28 <applicative> type i mean,
11:48:29 <jmcarthur> applicative: ?
11:48:32 <applicative> an alias
11:48:32 <jmcarthur> oh
11:48:50 <monochrom> type aliases are non-abstract once exported
11:49:09 <solistic> jmacarthur: but than it is not hidden, right?
11:49:12 <applicative> It sounded like the ugliness of StateT ProgramState MPD might be the problem
11:49:13 <jmcarthur> solistic: if you want to hide the implementation behind an opaque type like that then you need to expose specialized functions for manipulating it. exposing all those instances just makes the newtype useless
11:50:16 <solistic> hmm, I'll think about that
11:54:48 <oscar_boykin> I have a purely (I believe) numerical code that is spending about 1/3 of its time on system calls (95% of which to rt_sigprocmask)
11:55:18 <oscar_boykin> I can't figure out why it would, and since this code will run for a month on the full size version of the problem, I would like to get than 1/3 back if possible.
11:56:21 <mm_freak> opqdonut: there is a good reason for this
11:56:58 <mm_freak> opqdonut: when having multiple imports, i can't really sort my imports alphabetically, because then the qualified imports are very ugly inbetween
12:02:25 <jmcarthur> oscar_boykin: are you using some sort of FFI library or something?
12:03:14 <jmcarthur> oscar_boykin: hmm... maybe it has something to do with multithreading?
12:03:17 <oscar_boykin> jmcarthur: not intentionally.
12:03:50 <oscar_boykin> oscar_boykin, I wondered about that, but I'm doing anything explicit and it is only using one core.
12:03:55 <jmcarthur> oscar_boykin: btw, the new llvm backend is supposed to be pretty good for numerical code. have you tried it?
12:04:01 <oscar_boykin> jmcarthur; (woops...)
12:04:22 <oscar_boykin> jmcarthur, no.  I'm being lazy and using ghc packaged with ubuntu
12:04:27 <jmcarthur> ah
12:04:50 <jmcarthur> oscar_boykin: i've heard that heavily numerical code is seeing like 25% performance increases from the llvm backend in ghc 7, just btw
12:05:38 <oscar_boykin> jmcarthur, I'll consider that.  That would be worth it.  I assume it can generate static code fine (I am going to send this to a bunch of computers which I cannot install any runtime on)
12:05:51 <jmcarthur> yeah, it's just plain binary code output
12:06:37 <jmcarthur> oh i misunderstood what you meant, but i think that's not an issue either
12:06:47 <oscar_boykin> could "import Debug.Trace" cause it?  Re-running now to see if I still see it...
12:07:04 <jmcarthur> i don't think merely importing a module should do something like that...
12:07:36 <jmcarthur> oscar_boykin: you could always try profiling to see what functions are stealing your time
12:08:01 <oscar_boykin> jmcarthur, I've tried that.
12:08:19 <oscar_boykin> the only functions are absolutely trivial.  It's pretty baffling to me.
12:08:25 <jmcarthur> oscar_boykin: what packages is this dependent on?
12:08:49 <oscar_boykin> containers to get Set
12:09:20 <oscar_boykin> 17% of my allocations, for instance, are in the following function
12:09:36 <oscar_boykin> ruFold base acc h k = base*acc + ((k - h) `mod` base)
12:09:42 <oscar_boykin> ruFold :: Int -> Int -> Int -> Int -> Int
12:10:11 <oscar_boykin> I know Haskell is supposed to be tough, but how can such a trivial function account for 17% of my allocations?  That is totally unclear to me.
12:10:28 <jmcarthur> that seems silly to me too (and i don't think haskell is all that tough :P)
12:10:42 <jmcarthur> oscar_boykin: now... what's *using* that function?
12:10:53 <monochrom> what are the types?
12:10:58 <jmcarthur> monochrom: all Int
12:11:35 <jmcarthur> monochrom: "<oscar_boykin> ruFold :: Int -> Int -> Int -> Int -> Int"
12:11:53 <oscar_boykin> toRUDot base = foldl2' (ruFold base) 0
12:12:04 <jmcarthur> foldl2'?
12:12:34 <jmcarthur> lists with at least 2 elements?
12:12:38 <oscar_boykin> hold, I'm trying to find the paste (it's a strict fold over two lists)
12:12:42 <jmcarthur> oh
12:12:50 <jmcarthur> so... a zip followed by a fold?
12:12:53 <monochrom> list would cause allocation
12:13:12 <oscar_boykin> http://hpaste.org/41508
12:13:22 <oscar_boykin> right
12:13:27 <tux_mark_5> hello
12:13:40 <tux_mark_5> is there a way to "use" an unexported constructor?
12:13:48 <oscar_boykin> foldl2' uses 0.0% of my memory now, so I *think* that means it is okay
12:13:51 <jmcarthur> okay i'm not a fan of that foldl2' function, but i guess that's unimportant
12:14:28 <oscar_boykin> jmcarthur, (it's a cut and paste from Real World Haskell with a slight modification)
12:14:49 <jmcarthur> wow
12:14:56 <oscar_boykin> I love beautiful code too, but getting an actual result from my code would be cool too.  It used to be a fold over a zip.
12:14:57 <jmcarthur> i'm still not a fan
12:15:10 <jmcarthur> you mean it's actually faster this way?
12:15:34 <oscar_boykin> me neither.  It sucks that I have to babysit the compiler.  It would be cool if I could just express mathematically what I want and the compiler handle it.
12:15:51 <oscar_boykin> yes, and allocates less.
12:15:55 <jmcarthur> ...
12:16:01 <pygmalion> having some IO trouble... error at the bottom of the paste of anyone would be so kind as to take a look for me http://hpaste.org/41568/io_help
12:16:11 <jmcarthur> okay i'm gonna experiment with this function myself. i kind of have trouble believing this
12:16:48 <copumpkin> a fold and a zip don't work?
12:16:50 <Botje> pygmalion: you can only do s <- move ... if move returns an IO something
12:17:01 <copumpkin> foldl' that is
12:17:15 <jmcarthur> copumpkin: oscar_boykin claims that this is faster...
12:17:21 <Botje> pygmalion: you want "let s = move b i" instead
12:17:24 <oscar_boykin> copumpkin, they "work" but the code needs to run for a few months on about 500 computers.  I need all the performance I can get, and it was faster when I did this.
12:17:31 <pygmalion> Botje: ahhh okay thanks! so simple...
12:17:35 <copumpkin> faster? :o
12:17:46 <jmcarthur> oscar_boykin: btw, do you think maybe this problem would be a good candidate for vector?
12:17:53 <jmcarthur> that would get you a huge speedup if it is
12:18:00 <jmcarthur> especially with ghc 7 and the llvm backend
12:18:04 <oscar_boykin> jmcarthur, I do, in principle, but the lists are very small
12:18:09 <oscar_boykin> There are just many of them.
12:18:12 <oscar_boykin> MANY of them.
12:18:22 <oscar_boykin> So, in this example, the lists are length 2.
12:18:25 <copumpkin> how small?
12:18:25 <copumpkin> oh
12:18:28 <jmcarthur> 2?!
12:18:30 <oscar_boykin> In the real example, they are length 6
12:18:32 <jmcarthur> why even use a fold
12:18:34 <jmcarthur> ah
12:18:35 <copumpkin> oh all same length?
12:18:35 <oscar_boykin> (sorry 5)
12:18:43 <copumpkin> use a Vector or repa
12:18:46 <copumpkin> since it's a regular shape
12:18:48 <jmcarthur> yeah
12:18:58 <jmcarthur> sounds like a good candidate for either package
12:19:18 <jmcarthur> either way, i'm still having trouble accepting that this foldl2' function is faster that foldl' composed with zip
12:19:22 <jmcarthur> so i'm gonna experiment
12:19:23 <oscar_boykin> jmcarthur, I know, and I've considered it.  I do appreciate the help.
12:19:43 <oscar_boykin> jmcarthur, I just thought the low hanging fruit of getting rid of 1/3 of time being spent on sys calls could be easy to fix.
12:19:44 <jmcarthur> oscar_boykin: what would be some good test data? anything i can generate or paste in?
12:20:03 <monochrom> perhaps GC calls rt_sigprocmask
12:20:13 <copumpkin> oscar_boykin: optimizing list functions for high-performance stuff seems like a bit of a waste of time to me
12:20:24 <jmcarthur> oscar_boykin: monochrom brings up a good point. have you looked at your GC costs?
12:20:39 <oscar_boykin> jmcarthur, yes.  They are about 2%
12:20:47 <jmcarthur> ah that's good and low
12:20:58 <oscar_boykin> this is what's bothering me:
12:21:00 <oscar_boykin> real	6m17.724s
12:21:01 <oscar_boykin> user	4m19.932s
12:21:01 <oscar_boykin> sys	1m50.719s
12:21:17 <oscar_boykin> Why am I spending almost 2 minutes on sys calls?
12:21:18 <monochrom> at least I can't think of how else FFI-free, MVar-free, [Int] code leads to rt_sigprocmask apart from lots of cons cells and therefore lots of GC
12:21:33 <monochrom> exception-free, too
12:21:46 <oscar_boykin> monochrom, exception free (in any explicit use case).
12:21:48 <oscar_boykin> I am using Set
12:22:02 <jmcarthur> oscar_boykin: is this code and test data okay to share with others, or is it proprietary?
12:22:09 <oscar_boykin> I don't know the internals of Set.
12:22:18 <jmcarthur> Set is pure haskell afaik
12:22:21 <oscar_boykin> Yeah, it's an ugly mess, but here is a recent version:
12:22:23 <monochrom> Set is also pretty pure, FFI-free MVar-free exception-free etc
12:22:45 <oscar_boykin> https://github.com/johnynek/MUB-Search/blob/master/MUB-Search2.hs
12:23:07 <oscar_boykin> It is a scientific code designed to search for a particular structure (and not find it, actually).
12:23:17 <oscar_boykin> A student wrote some of it, I am trying to get it finished.
12:23:42 <jmcarthur> oscar_boykin: so i should be able to just build this and run it with some command line arguments?
12:24:14 <oscar_boykin> there is a Makefile.
12:24:36 <oscar_boykin> It should build, but you'd need to generate the inputs to that program with another program in that same repo.
12:25:28 <jmcarthur> "-O -O2 -optc-O2 -optc-O3"    ha
12:25:55 <oscar_boykin> yeah, I know, they grew somewhat organically, I guess.  I don't know where it came from...  :)
12:25:57 <jmcarthur> "-O2 -optc-O3" would be fine :P
12:26:21 <jmcarthur> and even that... surely the version of ghc you are using is using the native code gen instead of via C
12:26:58 <oscar_boykin> I know, I turned that on to see if it helped, it didn't, it got turned back off, but I guess I (and Nathan) never removed -optc-
12:27:32 <jmcarthur> ah
12:28:20 <jmcarthur> oscar_boykin: okay, so how do i generate the test data and run the program on it?
12:28:46 <oscar_boykin> to generate input use:
12:28:55 <oscar_boykin> ./FundamentalNeighbors 3 5 0 527 0 > fn-3-5-0-527-0
12:29:10 <oscar_boykin> ./FundamentalNeighbors 3 5 1 527 0 > fn-3-5-1-527-0
12:29:59 <BarkLeyPuPPerZ> does parsing trees or XML or what have you require recursion to be done easily?
12:30:24 <oscar_boykin> ./Simplify fn-3-5-0-527-0 2 > fn-3-5-0-527-0_simp
12:30:39 <oscar_boykin> then you are ready to go:
12:30:45 <oscar_boykin> MUB-Search2 3 32 fn-3-5-0-527-0 fn-3-5-1-527-0 fn-3-5-0-527-0_simp 1 33 0
12:31:03 <jmcarthur> how long does this typically take?
12:31:05 <jmcarthur> for you
12:32:29 <revenantphx> Reading the definition of cons kind of blew my mind a bit.
12:32:38 <diracdelta> hi, if I'm attempting to read from the terminal on a per-character basis (getChar in the terminal needs a newline) what is the correct way of obtaining the characters?
12:32:46 <revenantphx> I really need to stop being surprised when things ALWAYS END UP BEING PROCEDURES/FUNCTIONS in functional langauges.
12:33:13 <BarkLeyPuPPerZ> functions are a mythology
12:33:20 <jmcarthur> oscar_boykin: is this the one that takes roughly 6 minutes for you?
12:35:05 <revenantphx> diracdelta: idk in haskell, but in C you need to enable "raw" IO. 
12:35:31 <revenantphx> Basically it keeps stdin from buffering input until it receives a \n
12:35:54 <Lemmih> diracdelta: Disable buffering with hSetBuffering
12:36:16 <diracdelta> thank you :)
12:36:53 <revenantphx> Lemmih < more helpful than me
12:37:24 <monochrom> what is the definition of cons?
12:37:48 <revenantphx> https://gist.github.com/704025
12:38:07 <revenantphx> basically a cons pair is actually a procedure.
12:38:27 <revenantphx> Well, not basically... it just is.
12:38:51 <diracdelta> revenantphx: Where did you read the definition? Was this in SICP?
12:38:57 <revenantphx> yes.
12:38:58 <monochrom> interesting
12:39:29 <revenantphx> Well, I suppose you could implement it other ways I suppose, but this version is very neat.
12:40:42 <monochrom> when all you have are objects, everything is an object. when all you have are functions, everything is a function. when all you have is a hammer, everything looks like a thumb.
12:41:02 <shachaf> revenantphx: But to implement it this way you need numbers as a primitive.
12:41:35 <revenantphx> shachaf: right.
12:41:50 <shachaf> revenantphx: Numbers are complicated. So you should do it without numbers. :-)
12:41:58 <revenantphx> shachaf: what? TT_TT
12:42:10 <jmcarthur> try church encoding :)
12:42:19 <yiannis_t> jmcarthur: +1
12:42:20 <diracdelta> (define (cons x y) (lambda (m) (m x y)))
12:42:21 <yiannis_t> : )
12:42:22 <shachaf> Yep.
12:42:23 <monochrom> he means functions over numbers are less complicated than numbers.
12:42:43 <revenantphx> diracdelta: heh.
12:42:56 <monochrom> moreover scott encoding is even simpler than church encoding
12:43:43 <revenantphx> i see >_>
12:43:55 <revenantphx> The lambda calculus notation is a tad foreign to me.
12:44:42 <revenantphx> ah, yeah diracdelta, that appears not half a page later.
12:44:44 <monochrom> also (define (cons x y) (lambda (m) (m x y))) is closer to scott encoding than church encoding
12:44:52 <revenantphx> they show (define (cons x y) (lambda (m) (m x y)))
12:45:34 <revenantphx> and then (define (car z) (z (lambda (p q) p)))
12:45:51 <revenantphx> (define (cdr z) (z (lambda (p q) q))) for cdr then?
12:45:54 <jmcarthur> revenantphx: isn't that just a million times more wild than the number version? :)
12:46:01 <revenantphx> jmcarthur: it is pretty neat.
12:46:27 <revenantphx> the idea of encoding data types into functions makes my head go *ker-pop* a bit.
12:46:32 <shachaf> revenantphx: Did you get to the part where they take away (define) yet? :-)
12:46:42 <revenantphx> shachaf: ...oh fuck.
12:46:51 <jmcarthur> revenantphx: i think the usual presentation of data structures as functions is more confusing than necessary
12:47:09 * shachaf isn't actually sure if SICP does it that way. _The Little Schemer_ does.
12:47:14 <revenantphx> Well, I'm dedicated to getting this fully read through by september next you.
12:47:18 <revenantphx> year*
12:47:52 <revenantphx> We have to do what's basically an independent study for advanced computer science (mostly because they're too lazy to write a curriculum)
12:48:08 <jmcarthur> @src foldr
12:48:08 <lambdabot> foldr f z []     = z
12:48:08 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
12:48:12 <revenantphx> And I wanted to try my hand at writing a basic interpreted language.
12:48:18 <revenantphx> oh shit its folds again.
12:48:23 <shachaf> revenantphx: You should implement Scheme. :-)
12:48:30 <revenantphx> shachaf: that's done by the end of SICP
12:48:34 <shachaf> Ah, right.
12:48:41 <revenantphx> SICP implements Scheme in a register machine written in scheme.
12:48:59 <revenantphx> whoa, GHC 7!
12:49:10 <jmcarthur> lol
12:49:10 <revenantphx> to the download-mobile!
12:49:27 <revenantphx> rawr, the brew install is out of date.
12:49:29 <jmcarthur> it's likely to break a lot of things. be wary
12:49:32 <monochrom> implement GHC 7 in javascript written in scheme
12:49:50 <revenantphx> implementing scheme in javascript would be cool :P
12:50:06 <revenantphx> (writing webpages in scheme for shits and giggles mainly)
12:50:15 <jmcarthur> oscar_boykin: it's still going. should i be concerned?
12:50:20 <shachaf> revenantphx: Write a compiler from Scheme to JS instead.
12:50:31 <monochrom> ghc 7 for linux is 113MB compressed, 8x0MB uncompressed. it may blow your disk quota first.
12:50:36 <shachaf> revenantphx: So you don't have to write actual code in that painful language.
12:50:47 <revenantphx> shachaf: touche!
12:51:28 <revenantphx> Oh god, Alyssa P. Hacker.
12:51:32 <revenantphx> This never ends well.
12:51:42 <revenantphx> (what's the pun in her name supposed to be anyhow)
12:52:25 <revenantphx> I don't get why she's writing all of this complex electrical engineering software in scheme... but sure.
12:52:34 <jmcarthur> why not?
12:52:47 <FauxFaux> Internet says "A Lisp Hacker" but I don't get it.
12:52:52 <revenantphx> ah, yeah I see that.
12:53:06 <Botje> "Alice" could be a nickname for "Alyssa"
12:53:16 <Botje> (that *is* pretty bad)
12:54:12 <revenantphx> Botje: I think Alice P. Hacker would have been a better name.
12:54:26 <Botje> too obvios
12:54:30 <revenantphx> I guess?
12:54:33 <Botje> *obvious
12:54:36 <oscar_boykin> jmcarthur, what is still going? FundamentalNeighbors is pretty quick
12:54:41 <jmcarthur> oscar_boykin: okay, i just ^Ced it.   "1190.07s user 7.31s system 91% cpu 21:54.67 total"
12:54:46 <oscar_boykin> jmcarthur, MUB-Search2 is the faster one.
12:54:47 <jmcarthur> oscar_boykin: no, MUB-Search2
12:54:51 <jmcarthur> ...
12:54:53 <oscar_boykin> jmcarthur, sorry slower....
12:55:01 <jmcarthur> yeah, that was MUB-Search2
12:55:05 <revenantphx> jmcarthur: okay, just spoil it for me.
12:55:09 <jmcarthur> oscar_boykin: anyway, those were my timings
12:55:15 <revenantphx> jmcarthur: what do you do once they take away define?
12:55:25 <oscar_boykin> jmcarthur, thanks for the help...
12:55:29 <jmcarthur> revenantphx: ask monochrom 
12:55:35 <revenantphx> oh right, monochrom 
12:55:42 <mauke> I'd use lambda
12:55:44 <jmcarthur> oscar_boykin: so it doesn't look like it's really doing the same things for me...
12:55:55 <revenantphx> mauke: everything is lambdas XD?
12:56:03 <mauke> yes
12:56:09 <revenantphx> the loss of names might make that a bit annoying though.
12:56:21 <roconnor> @type approxRational
12:56:22 <lambdabot> forall a. (RealFrac a) => a -> a -> Rational
12:56:25 <mauke> (lambda (I got names here) ...)
12:56:31 <oscar_boykin> oscar_boykin, well, there could be two reasons, one: I've been hacking on the code left and right (and you have a slightly different version), two, I'm using ghc from Ubuntu 10.10, which might be different from your environment
12:56:32 <jmcarthur> oscar_boykin: what version of ghc are you using? maybe an upgrade would fix it?
12:56:41 <jmcarthur> oscar_boykin: i tested with ghc 6.12.3
12:56:50 <oscar_boykin> n 6.12.1
12:56:56 <roconnor> @src approxRational
12:56:56 <lambdabot> Source not found. It can only be attributed to human error.
12:57:02 <jmcarthur> not a major version then
12:57:16 <jmcarthur> maybe it's a silly ubuntu thing
12:57:44 <oscar_boykin> jmcarthur, maybe.  Thanks for the help.  I'll look into an upgrade.  I've gotten lazy in my old age.  Is there an apt-source for a more recent ghc?
12:58:08 <jmcarthur> no idea
12:58:12 <jmcarthur> i'm not an ubuntu guy
12:58:56 <oscar_boykin> jmcarthur, I do appreciate your time.  Thank you very much for running the code and your comments.  I must go now. 
12:59:37 <jmcarthur> oscar_boykin: you're welcome. i hope you get it worked out
13:00:48 <revenantphx> Botje: Ben Bitdiddle is just a BAD name
13:00:49 <revenantphx> period.
13:01:14 <Botje> =)
13:10:48 <camio> > let x = x in x
13:10:52 <lambdabot>   mueval-core: Time limit exceeded
13:11:01 <revenantphx> hm
13:11:05 <revenantphx> if you do(define one-through-four (list 1 2 3 4))
13:11:16 <camio> Why doesn't that, let x = x in x, produce a stack overflow?
13:11:16 <revenantphx> then why does evaluating 'one-through-four' result in (1 2 3 4)
13:11:18 <copumpkin> this is #haskell :)
13:11:33 <jmcarthur> camio: it's self-referential. that means that in memory it's just a pointer to itself
13:11:53 <revenantphx> pro-hax0r foiled again by pointers
13:12:42 <Botje> revenantphx: (define (list . arguments) arguments)
13:12:47 <Botje> if you know that syntax yet.
13:12:53 <Botje> list simply constructs a list out of its arguments
13:13:07 <monochrom> I don't know why I'm asked to take away define. But I would inline everything. For recursive definitions, there is the Y combinator.
13:13:39 <aristid> wtf "If you can compose fns regardless of type, you don't need monads #clojure"
13:14:38 <maurer_> So, after profiling a program that uses parsec due to runtime concerns, I found 50% of the time is being taken up by makeTokenParser
13:15:01 <maurer_> However, the entire execution path there is pure, and the result ends up in the CAF of a module.
13:15:11 <maurer_> Is there any way I can inform GHC that it should compute this, and store the computed thunk?
13:17:49 <Lemmih> maurer_: At compile time?
13:18:33 <maurer_> Lemmih: That was my hope.
13:18:36 <diracdelta> Lemmih: Hi, I tried using hSetBuffering stdin NoBlocking, but this was unsucessful, getChar still bocks.
13:18:52 <diracdelta> Lemmih: er.. blocks
13:19:15 <monochrom> there is no NoBlocking
13:19:20 <sipa> NoBlocking or NoBuffering ?
13:19:32 <sipa> buffering != blocking
13:19:58 <Lemmih> diracdelta: Works for me.
13:20:06 <Lemmih> diracdelta: Are you sure there's anything to read?
13:20:08 <monochrom> If you use NoBuffering, getChar will wait for one key (of course) but that's all.
13:20:40 <Lemmih> diracdelta: (I assume you meant NoBuffering)
13:20:53 <Lemmih> maurer_: Not really.
13:21:05 <diracdelta> monochrom: I used noBuffering, and first checked if there was anything to read. It still doesn't process input until a newline is entered. I'm going to check my other computer (not windows) and see if that's the issue
13:21:24 <revenantphx> Botje: why the . ?
13:21:32 <monochrom> should not happen. have you saved the source code file etc.
13:21:44 <revenantphx> Botje: some way of indicating variable length?
13:21:55 <revenantphx> (I wondered about that for procedures like + and -
13:21:57 <revenantphx> )
13:22:11 <Botje> revenantphx: yes. arguments before the . are bound normally, the rest is bound to the variable after the dot
13:22:19 <revenantphx> oooh
13:22:22 <revenantphx> gotcha
13:24:34 <sipa> diracdelta: to do that you need to change settings of the terminal your program is receiving stdin from
13:24:38 <sipa> i think
13:25:31 * hackagebot lhs2TeX-hl 0.1.2.0 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.2.0 (AlessandroVermeulen)
13:25:49 <sipa> diracdelta: running "stty -cooked" will do
13:26:13 <sipa> no idea if there's a standard way/library/... to do it from haskell
13:27:17 <monochrom> isn't cooked mode exactly line-buffered and backspace works etc?
13:27:23 <diracdelta> monochrom: it seems to be a windows issue. it works as expected on my mac
13:28:10 <diracdelta> sipa: thanks, I'll look into how the cmd terminal handles this
13:28:16 <sipa> monochrom: cooked != -cooked :)
13:28:23 <sipa> or i should say /= here :)
13:28:27 <monochrom> damn minus sign
13:28:45 <sipa> and the manpage tells me -cooked is the same as raw
13:28:48 <sipa> that's more cleart
13:28:50 <sipa> clear
13:28:51 <monochrom> But NoBuffering effectively kills cooked mode already.
13:29:34 <sipa> ?
13:31:42 <monochrom> well, play with http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#12 some day
13:37:38 * hackagebot HDBC-odbc 2.2.3.1 - ODBC driver for HDBC  http://hackage.haskell.org/package/HDBC-odbc-2.2.3.1 (JohnGoerzen)
13:44:20 <ddilinger> new to learning haskell, doing a few project euler problems.  I've noticed that my run times can very greatly for some of the early brute force attempts(4-7s), is it normal for the same algorithm to run at such different speeds(7s is almost 2x 4s)
13:44:30 <pygmalion> i'm working on some IO and i need someone to point me in the right direction as to how best to implement a quit command. http://hpaste.org/41579/io_help
13:46:01 <Cale> ddilinger: huh... maybe?
13:46:01 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:46:17 <Cale> ddilinger: It depends on what data you supply
13:46:28 <ddilinger> Cale: the input data is the same for every run
13:46:44 <ddilinger> Cale: lemme paste on that can take 4s or 7s
13:46:55 <Cale> Maybe it just has something to do with other stuff going on with your machine at the same time?
13:47:28 <ddilinger> could be, but i re-wrote a version in C for the same algorithm and it runs +- 5%
13:47:37 <Cale> Compiled Haskell programs are usually fairly deterministic, performance-wise, unless you're using lots of parallelism or something.
13:47:58 <Cale> Can I see the program?
13:48:20 <Cale> Maybe we could try benchmarking it with criterion :)
13:48:25 <Lemmih> pygmalion: You seem to have a handle on it.
13:49:44 <ddilinger> http://hpaste.org/41580/euluer_14
13:50:10 <ddilinger> that one finds the longest sequence presented in the Collatz Problem with a starting number under 1,000,000
13:53:40 <ddilinger> i also cant explain why, but changing the seq' guard to x < 10000 for the list lookup causes it to take lots more time, but x<500 (rather than not at all) shaves about 1s 
13:54:15 <xiackok_> @hoogle <|>
13:54:16 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
13:54:16 <lambdabot> Text.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
13:54:16 <lambdabot> Text.ParserCombinators.Parsec.Prim (<|>) :: Monad m => ParsecT s u m a -> ParsecT s u m a -> ParsecT s u m a
13:54:43 <Cale> Whoa... this looks time-intensive
13:55:07 <Cale> !! is always something to watch out for:  xs !! n  takes O(n) steps to compute
13:55:08 <copumpkin> not really
13:55:13 <copumpkin> oh
13:55:23 <copumpkin> I thought you meant the problem itself :)
13:55:29 <ddilinger> really? i thought xs !! n was how you memoize things
13:55:56 <Cale> Well, it can be... if those things take much more than linear time to compute :)
13:56:12 <copumpkin> ddilinger ! is better for memoizing ;)
13:56:18 <Cale> Or, if you're going to access those things in linear order
13:56:21 * copumpkin nudges
13:56:35 <Cale> Lists are not meant for random access
13:57:07 * ddarius proposes that (!!) is removed from the Prelude.
13:57:25 <ddilinger> well, the idea was that was the number 184984 will take 160 steps to compute, but its first result is 92492 and that has already been calculated to be 159, so instead of walking 159 more steps just get it from the list
13:57:34 <ddilinger> going to have to see what the diff is with !! vs !
13:57:34 <djahandarie> Can anyone intuite Luke Palmer's latest post for me a little?
13:57:42 <ddilinger> google doesn't like to search for symbols :P
13:57:50 <copumpkin> djahandarie: did you get the original escardó one?
13:58:10 <djahandarie> Oh, I remember this now
13:58:15 <djahandarie> Hold on, nevermind
13:58:15 <Cale> ddilinger: ! is the corresponding operation for arrays
13:58:24 * djahandarie reads more
13:58:25 <Lemmih> Haskell'11: (!!) = error "Lists are not meant for random access, silly goose"
13:58:27 <copumpkin> djahandarie: there's a blog post on andrej's blog
13:58:29 <djahandarie> Yeah
13:58:36 * copumpkin subtracts one blog from that sentence
13:58:46 <ddilinger> ahh, is !! accesing a linked list that it has to walk?
13:58:51 <Cale> ddilinger: yeah
13:58:51 <sipa> yes
13:58:53 <djahandarie> Blog blog blog post blog?
13:59:17 <Cale> ddilinger: So if you turn collatzCount into an array, that would help a good deal -- it's already finite which is good.
13:59:41 <Cale> :t listArray
13:59:42 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
13:59:42 <djahandarie> If there was a proper noun "Blog" then we could construct infinitely long sentences with the word "blog"
13:59:46 <Cale> :t listArray (0,500)
13:59:47 <lambdabot> forall t e. (Num t, Ix t) => [e] -> Array t e
13:59:51 <jordandanford> Has anyone had success using the plugins package?
14:00:11 <Cale> ^^ apply that function to collatzCount to get an  Array Integer Integer
14:00:34 <Cale> (Or Array Int Integer, if you prefer)
14:00:43 <ddilinger> hmm, ok trying out thanks
14:00:54 <ivanm> Cale: do you know of a way of finding the dual of a planar graph with multiple connected components?
14:00:56 <Cale> import Data.Array  to use the array library
14:01:26 <roconnor> @hoogle Monoid
14:01:26 <lambdabot> module Data.Monoid
14:01:26 <lambdabot> Data.Monoid class Monoid a
14:02:16 <djahandarie> ivanm, isn't there more than one?
14:02:26 <Cale> ivanm: What's the difference between that and the case where there's only one connected component?
14:02:55 <Cale> ivanm: Just don't forget about the outer face :)
14:03:55 <Cale> I suppose you could solve each of them separately, and then just identify all the vertices corresponding to the outside of each shape.
14:04:51 <Cale> Ah, I see why it's different. You can't get to every edge on the outer face by walking from vertex to vertex in the graph.
14:09:17 <luite> but what is the outside of a graph? :) (that is, if you have a planar graph without an actual embedding)
14:10:37 <Cale> Oh, actually, hmm. It's not just the outside. It's the faces whose removal results in a disconnected space that we're worried about.
14:12:06 <Cale> (that is, the faces between components)
14:12:35 <roconnor> @instances Monoid
14:12:36 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:12:58 <roconnor> Seq?
14:13:03 <Cale> Of course, this is all *really* happening on a sphere, so there's not really an *outside* as such ;)
14:13:30 <Cale> I'm not sure what things the @instances plugin imports.
14:13:47 <ivanm> Cale: did my question to you about 15 minutes ago go through? (since my net was playing up)
14:14:05 <Cale> ivanm: oh
14:14:06 <Cale> heh
14:14:13 <Cale> ivanm: I hadn't realised that you were gone
14:14:21 <ddarius> @innstances-importing Data.Sequence Monoid
14:14:22 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Seq a, Sum a, [a]
14:14:38 <ivanm> Cale: I quite possibly wasn't actually gone :s
14:14:48 <ivanm> (in that I was still listed as being signed in)
14:15:05 <roconnor> ddarius: horray
14:15:40 <Gracenotes> is the standard list hard-coded? because I think L.hs imports Data.Sequence..
14:15:50 <Cale> ivanm: So if we take any pair of connected components of the graph, say A and B, then B has to lie entirely inside one of the faces of A.
14:16:15 <Gracenotes> > Seq.empty
14:16:16 <lambdabot>   fromList []
14:16:18 <Cale> ivanm: and its outer face is then identified with the corresponding face of A
14:16:50 <Cale> (if that's meaningful)
14:16:56 <ivanm> Cale: right; so I have to a) identify all the connected components, and b) choose one as the main component and choose one of its faces as the outer face ?
14:17:13 <Cale> ivanm: Well, remind me what we're encoding here :)
14:17:41 <Cale> (Like, what does "planar graph" mean in this context exactly)
14:17:43 <ivanm> planar graphs, though probably more on the sphere rather than the plane
14:17:44 <luite> ivanm: note that dual graphs are not unique (unless you've fixed an embedding), even if you only have one connected component
14:18:02 <ivanm> luite: they're not? in what way?
14:18:10 <Cale> I know that ivanm is encoding some of the information about the embedding
14:18:21 <Cale> But maybe not enough to deal with multiple connected components.
14:18:24 <ivanm> this is a semi-recent draft: http://hpaste.org/41552/current_planar_graph_draft
14:18:54 <luite> ivanm: do you have a planar graph (a graph that can be embedded in the plane), or a planar graph with one particular embedding (often called a plane graph)?
14:19:22 <Cale> luite: He has a planar graph together with orientations of the edges incident on each vertex
14:19:29 <ivanm> luite: hmmm.... good question :p
14:19:41 <ivanm> but yeah, more the former
14:19:46 <ivanm> hey dcoutts__ 
14:19:59 <dcoutts__> @arr!
14:19:59 <lambdabot> Aye
14:20:06 <djahandarie> @arr
14:20:07 <lambdabot> Ahoy mateys
14:20:15 <dcoutts__> @yarr!
14:20:15 <lambdabot> Smartly me lass
14:20:24 <djahandarie> @. vixen arr
14:20:24 <lambdabot> there are a lot of weirdos on here
14:20:34 <luite> Cale: I guess I missed part of the discussion :)
14:20:37 <Cale> luite: That is, he has a cycle corresponding to each vertex, which specifies the order in which they meet the vertex as you travel clockwise around the vertex.
14:20:50 <djahandarie> @. . elite vixen arr
14:20:50 <lambdabot> Plugin `compose' failed with: Unknown command: "VixEN"
14:20:55 <djahandarie> lol damn
14:20:55 <luite> ah
14:22:13 <yiannis_t> Cale: quicksilver said earlier that you have something written about Monad Transformers. do you? : )
14:22:16 <dfkjjkfd> @djinn ((((a->r)->r)->r)->r)->(a->r)->r
14:22:16 <lambdabot> f a b = a (\ c -> c b)
14:22:36 <yiannis_t> Cale: i mean examples of usage etc
14:22:44 <Cale> yiannis_t: I do, but apparently my webserver is having trouble atm.
14:23:06 <Cale> I'll have to go downstairs and plug a monitor into it at some point.
14:23:33 <yiannis_t> i c! no prob man
14:23:56 <luite> Cale: but that isn't enough information to make the dual graph unique
14:24:16 <ivanm> luite: when is the dual graph not unique?
14:24:34 <Cale> luite: yeah, because it doesn't specify how each of the connected components embed into the faces of the others
14:24:44 <luite> ivanm: when you can choose different embeddings leading to nonisomorphic dual graphs :p
14:24:51 <Cale> It's enough to make the dual of any one connected component unique
14:24:58 <ivanm> luite: as in different surfaces?
14:25:01 <luite> Cale: even with a single connected component it's not unique
14:25:06 <Cale> luite: oh?
14:25:21 <Cale> luite: You can determine the face structure quite easily from that.
14:25:46 <luite> hmm, I may have overlooked something
14:26:04 <ivanm> I was going to have "safeAddEdge", etc. functions, but I'm not sure how to make them deal with multiple components; maybe it's easier to ignore those cases :s
14:26:17 <Cale> You can think of what's being encoded as a pair of permutations, say, sigma and rho on the set of edge-ends (two per edge). Sigma simply swaps the ends of each edge (that is, it's just a bunch of 2-cycles)
14:26:32 <ivanm> (in that case, should safeDeleteEdge refuse to split components?)
14:26:52 <Cale> rho has cycles which send each edge-end to the next one (counterclockwise, say) incident on that vertex
14:27:14 <Cale> By alternating between sigma and rho, you can walk around a face.
14:27:34 <ivanm> Cale: that's basically what I'm doing
14:28:05 * hackagebot hs-bibutils 4.12 - Haskell bindings to bibutils, the bibliography  conversion utilities.  http://hackage.haskell.org/package/hs-bibutils-4.12 (AndreaRossato)
14:28:19 <Cale> and that determines the faces of the graph, and for a single connected component, their adjacency is easy 
14:28:27 <Cale> "easy" ;)
14:28:48 <ivanm> for given definitions of "easy" ;-)
14:29:01 <dobblego> does Data.Map maintain insertion order with an index?
14:29:14 <Cale> But for more connected components, I suppose this information really isn't enough to specify a unique embedding.
14:29:25 <ivanm> dobblego: what do you mean?
14:29:27 <ivanm> Cale: yeah :s
14:29:30 <roconnor> @kind All
14:29:31 <lambdabot> *
14:29:44 <Cale> Suppose we have a planar graph consisting of the disjoint union of a triangle, a square and a pentagon
14:29:55 <dobblego> I mean Data.Map.elemAt n m will return the insertion that occurred the nth from empty
14:30:09 <ivanm> I might just assume that the graph is a single component
14:30:20 <Cale> Then there are a few inequivalent ways in which we can embed them. We can either nest them all, or we can put them side by side.
14:31:00 <ivanm> (actually, my current implementation should treat each component individually)
14:31:45 <dobblego> > M.elemAt 0 $ M.insert "def" 24 $ M.insert "abc" 42 M.empty
14:31:46 <lambdabot>   ("abc",42)
14:32:53 <dobblego> is there some guarantee about this function?
14:32:58 <Philonous> Is there some documentation on the general design of YI (the editor)? The haddock pages are dreadfully frugal
14:34:01 <Cale> dobblego: It retrieves the nth least element.
14:34:15 <dobblego> Cale, least being Ord?
14:34:17 <Cale> yeah
14:34:26 <dobblego> well that's a bugger
14:34:48 <Cale> What did you want it to do?
14:34:51 <dobblego> I have data X = X [(K, V)] (Map K V) so that I can maintain insertion order -- was hoping for something better
14:36:16 <dobblego> it just feels clumsy
14:37:07 * sm finds an easy way to embed support files for yesod.. awesome
14:37:30 <sipa> maybe X (Map K Int) (Map Int V)
14:37:54 <dobblego> I don't need random access, just "the last inserted"
14:38:02 <Cale> dobblego: Well, if you think about it, the list is exactly the information you were missing...
14:38:12 <dobblego> Cale, I did think about it, but I have OCD :)
14:38:15 <Cale> Or if you only need the last inserted, you could just pick that one element out.
14:38:25 <shepheb> is there a yesod channel?
14:38:31 <luite> Cale: I guess you're right :) I was just thinking about changing it in ways that only change the choice the of outer face
14:38:34 <dobblego> oh yeah, after getting the last inserted, I might need the last before that
14:38:42 <dobblego> i.e. it *is* a list
14:38:47 * dstcruz wonders if I should quote FunctorSalad this week ;)
14:39:00 <sipa> what do you need those elements for, to be able to remove them?
14:39:21 <dstcruz> magicman: just saw your blip about HWN grepping the logs, you are right, that's all I'm currently doing
14:39:29 <sipa> maybe [(K,V,Map K V)] is possible
14:39:52 <dobblego> sipa, yes
14:40:10 <Cale> dobblego: So it's not really a waste. Remember that in memory, you'll probably end up with some sharing between the elements of the list and the elements of the Map :)
14:40:44 <dobblego> Cale, I understand it's not a waste -- but I do think it feels clumsy (perhaps I should write a data structure specific to these operations)
14:41:21 <Cale> Well, yeah, you do need some abstraction to ensure that the list remains consistent with the Map.
14:41:45 <dobblego> the Map will only ever have the least recent insert, deleted
14:41:57 <Cloe> hi, im trying to concatinate a existing list of lists into one single list ie [[1],[2],[3]] -> [1,2,3]. my attempt was cat (x:xs) = x ++ xs cat xs, but didnt quite work
14:42:06 <dobblego> Cloe, for homework?
14:42:16 <Cale> Cloe: it's really close
14:42:26 <danharaj> Cloe: what is the type error you get?
14:42:30 <Cale> Cloe: You just have an extra spurious xs in there on your right hand side
14:42:31 <Botje> ask yourself what "xs cat xs" means
14:43:00 <Cale> xs cat xs means to apply the function xs to the parameters cat and xs
14:43:08 <Cale> (which will always be a type error)
14:43:15 <Cale> (almost always anyway :)
14:43:25 <Cloe> oh ok
14:43:27 <danharaj> (in Hindley Milner at least :p)
14:43:32 <Cale> In this case, it's more immediately a type error because xs is a list
14:43:39 <sm> what's the difference between ByteString and ByteString.Char8, really ? The latter's haddock says "provides an instance of IsString for the ByteString type, enabling you to use string literals" but the former also has that instance
14:44:09 <Cloe> Cale: im guessing im missing something between xs and cat
14:44:16 <ben> Char8 mainly has functions to convert between String and ByteString by truncating most unicode codepoints
14:44:23 <Cale> sm: The functions in the ByteString.Char8 module use the Char type for elements of the list (but only the least 256 members of that type)
14:44:42 <Cale> sm: The actual datastructure is the same, and you can use both modules at once
14:44:45 <ben> It is basically a bad idea unless you are working with a messed up string to begin with.
14:44:57 <Cale> Cloe: Not missing something
14:45:08 <Cale> Cloe: You have too much. Why is that first xs there?
14:45:24 <Cale> cat xs will be the concatenation of the remainder of the list already
14:45:40 <sm> hm. I'm trying to use the right one to conform with file-embed, which uses both internally
14:47:03 <sm> not grasping it with brilliant clarity, I'll try again when more awake. Thanks
14:48:09 <Cale> sm: The .Char8 module just has more functions for working with the same datastructure, using Char in place of Word8
14:49:13 <Cloe> Cale: thx, (cat (x:xs) = x ++ cat xs)seems to compile now, but i still get an error when using it with a list of lists
14:49:17 * sm flips the haddocks back and forth like an astronomer.. aha, I see "Breaking into lines and words" added in the latter
14:49:32 <Cale> Cloe: Did you forget to define cat for the empty list?
14:49:36 <sm> and also Transforming -> Transformating :)
14:50:31 <hpc> "Transforminating" :P
14:50:41 <Cloe> Cloe: no, i put cat [] = 0
14:51:11 <Twey> 0?  o.@
14:51:32 <Twey> What is the type of cat?
14:52:25 * Botje tries to think up a type involving Meow and Purr
14:52:30 <Cloe> Twey: a list, and yeah, i got it now thx
14:52:49 <Twey> Botje: Hehe
14:53:30 <Gracenotes> I just encoded a catameowrphism in your endogmorphism
14:53:55 <monochrom> @remember Gracenotes I just encoded a catameowrphism in your endogmorphism
14:53:55 <lambdabot> I will never forget.
14:53:55 <Cloe> Cale: the error was in my empty list def. thanks :)
14:54:26 <merijn> Sounds like its time to bring up lambdacats again? :p
14:54:59 <Gracenotes> oh yes please. the originals have been recovered, right?
14:55:32 <merijn> Yeah
14:55:37 <merijn> @where lambdacats
14:55:37 <lambdabot> http://tinyurl.com/lambdacats
15:00:11 <acemo> nice lambdacats
15:07:13 <igstan> guys, I'm trying to install the haskell platform on a debian system, but the compilation seems to take forever. is this normal?
15:07:38 <Botje> there should be packages for the haskell platform
15:08:21 <igstan> there are two, one marked as testing and one as unstable, but I decided to build it myself
15:08:58 <revenantphx> I guess I'll try asking in here.
15:09:12 <revenantphx> I'm trying to set up an isolated unix environment to do some testing with, inside virtualbox or vmware.
15:09:24 <revenantphx> 1) What's a good CLI-only distro to use
15:09:36 <revenantphx> 2) Does anyone have experience with ssh'ing into the virtual network of either of these?
15:10:19 <fengshaun> revenantphx: that's a bit way off-topic!
15:10:25 <revenantphx> fengshaun: yeaaaaaah.
15:10:31 <revenantphx> The goal is potentially haskell related...?
15:10:34 <revenantphx> (not really)
15:10:37 <teratorn> revenantphx: openbsd, ubuntu server.... ssh <virtual ip>
15:10:49 <revenantphx> teratorn: thanks, I was considering openbsd
15:11:14 <revenantphx> Do you think there'd be any point to using a 64bit build?
15:11:19 <revenantphx> version*
15:11:22 <teratorn> not really
15:11:27 <teratorn> needs more ram
15:11:38 * revenantphx has 8GB
15:11:40 <revenantphx> :)
15:11:50 <revenantphx> Well, on my laptop that's not too bad.
15:11:59 <revenantphx> My old computer had 2GB and I kept running out.
15:12:31 <teratorn> obsd 4.8 has ghc 6.12.3 all packaged up
15:12:54 <revenantphx> Well, one thing I'd like, is to be able to access the files from OS X easily.
15:13:02 <revenantphx> both vmware and vbox use virtual HD files.
15:13:16 <revenantphx> So at this point I'm looking at using FUSE/SSH to mount the virtual drive.
15:13:25 <revenantphx> Better idea maybe?
15:13:25 <teratorn> should work fine
15:14:10 <teratorn> obsd has drivers for vmware, but not vbox... but it still runs find under vbox at least in my experience
15:14:23 <teratorn> not counting X support
15:14:42 <revenantphx> I'm not looking for any gui
15:14:52 <revenantphx> I basically just want the cli/server version.
15:15:03 <revenantphx> This is *just* to have an easy isolated environment
15:29:26 <companion_cube> @djinn a -> b -> ((b -> forall c.c) -> (a -> forall c.c))
15:29:26 <lambdabot> f _ a b _ = b a
15:29:36 <companion_cube> niiiiiiice
15:31:27 * hackagebot NXT 0.1 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1 (MitarMilutinovic)
15:32:06 <companion_cube> @djinn a -> forall c.c
15:32:06 <lambdabot> -- f cannot be realized.
15:36:37 <Mitar> my first haskell library ;-)
15:36:57 <djahandarie> Congrats
15:37:21 <Mitar> how fast does hackagedb generates the haddock documentation?
15:37:52 <djahandarie> I think it's a daily cron
15:37:59 <djahandarie> That's just by observation though
15:47:45 <sipa> is there some type-level library/... that allows you to do something like TMap here: TMap f (a,b) is (f a, f b), TMap f (Maybe a) = Maybe (f a), ...
15:53:03 <simplesi`>  /quit
15:59:52 <roconnor> what do you call a category where each Hom-set has a monoid structure?
16:01:00 <monochrom> I only know that if each Hom-set is a CPO, they call it an O-category.
16:01:25 <monochrom> or at least that's what one book does.
16:01:41 <monochrom> I'm wondering about the cheesyness of saying M-category. :)
16:02:06 <roconnor> that sounds like an already existing structure
16:02:15 <monochrom> yeah, seems taken
16:06:04 <revenantphx> Note to self: NEVER place '\a' in your PS1
16:06:25 <ddarius> It's possible that "abelian category" has been generalized to that case.
16:08:49 <Twey> revenantphx: Haha
16:08:59 <revenantphx> >_>
16:09:17 * ddarius is pretty a \a would do nothing on his computer.
16:09:20 <ddarius> +sure
16:09:33 <Twey> revenantphx: MODULES=(!pcspkr !pcspkr !pcspkr) # DIE DIE DIE
16:09:38 <Twey> — my rc.conf
16:09:47 <revenantphx> ...what? XD
16:10:22 <djahandarie> roconnor, I usually don't get such questions answered in #math . Might just be my bad luck though
16:10:52 <roconnor> djahandarie: that's why I tried here first.
16:11:06 <ddarius> #math sucks.  #not-math is better, but still sucky.
16:11:24 <djahandarie> I've never actually ventured into #not-math
16:11:30 * djahandarie takes the opportunity
16:11:32 <jmcarthur> sipa: what you asked for looks like something i would just use type families for
16:11:45 <jmcarthur> sipa: unless i misunderstood you
16:11:46 <Cale> roconnor: A category enriched over the category of monoida.
16:11:46 <sipa> jmcarthur: i know, i could easily do it myself
16:11:48 <Cale> monoids*
16:12:11 <sipa> but i wondered if it existed - some library that does things like map, but on the type level
16:12:17 <roconnor> Cale: really?
16:12:32 <Cale> roconnor: Assuming, that is, that composition of homomorphisms is a monoid map.
16:12:38 <djahandarie> Well that sucked.
16:12:51 <roconnor> Cale: oh
16:13:04 <roconnor> Cale: I presume so, but I haven't thought about that
16:14:04 <Cale> The category of monoids is a monoidal category with the Cartesian product monoid and the trivial monoid being the identity for that.
16:14:20 <Cale> hmm
16:15:29 <thom_logn> why does ghci freakout when I type let myfmap = fmap (\x -> x*x)
16:15:33 <Cale> So, for each pair of objects A,B in our enriched category, we have a monoid Hom(A,B)
16:15:53 <Cale> and for each A, we have a monoid hom  id_A: I -> Hom(A,A), which is the only possible thing it could be
16:16:05 <Cale> (Where I is the one element monoid)
16:16:32 <Cale> and for each three objects, A,B,C, we need a monoid map  Hom(B,C) x Hom(A,B) -> Hom(A,C)
16:16:45 <roconnor> hmm
16:16:46 <dons> thom_logn: by freak out, you mean: "reports an error" ?
16:17:12 <thom_logn> yes mbiguous type variable `f' in the constraint:, etc
16:17:39 <dons> mm
16:17:43 <dons>    Ambiguous type variable `f' in the constraint:
16:17:43 <dons>       (Functor f) arising from an expression type signature
16:17:48 <roconnor> now that I think about it I maybe I don't have identity elements for my monoid for every hom set
16:17:56 <roconnor> only for hom(A,A) sets
16:18:12 <roconnor> oh no it is okay
16:18:21 <roconnor> I have identity elements for every hom set
16:18:35 <Cale> (You'd better, or they wouldn't be monoids ;)
16:18:46 <zygoloid> thom_logn: monomorphism restriction, i guess.
16:18:56 <Cale> Though I suppose you could have a category enriched over semigroups
16:19:02 <roconnor> it is similar to how the Kleisli category for MonadPlus has a monoid structure for each hom set
16:19:20 <thom_logn> I figured it would create a function I coild call with different fmappable thing
16:19:29 <dons> thom_logn: :set XNoMonomorphismRestriction
16:19:32 <zygoloid> thom_logn: give it an explicit type signature and it should
16:20:49 <zygoloid> thom_logn: alternatively, add the point back in: let myfmap xs = fmap (\x -> x*x) xs
16:21:44 <thom_logn> thanks
16:24:09 <Cale> Apparently if we replace monoids here by Abelian groups, then we get something called a preadditive category, and a ring is a preadditive category with exactly one object. :)
16:24:30 <roconnor> Cale: my monoid isn't commutative 
16:24:55 <Cale> Yeah, I just thought that was cute :)
16:25:07 <revenantphx> hngh
16:26:14 <Cale> I can just imagine a book with "We define a _ring_ as a one-object category enriched over the category of Abelian groups."
16:28:21 <roconnor> oh crap I don't have a monoid operation
16:28:36 <roconnor> no wonder I was having trouble coming up with it's exact definition.
16:32:41 <ddarius> Cale: Assuming you're familiar with enriched category theory, that would give you a notion of ring homomorphism for free.
16:32:49 <ddarius> (As well as several other things.)
16:33:05 <fxr> do we have any plan for bytestring builders? or should I use blaze-builder?
16:33:13 <mercury^> Cale: Unless you want preadditive categories too, it is shorter to define a ring as a monoid in the category of groups in the category of groups.
16:36:21 <Cale> mercury^: Monoid object in the category of Abelian groups
16:36:39 <mercury^> That's what I said.
16:37:08 <Cale> right :)
16:37:40 <Cale> Oh, but you do need to be cautious about the manner in which it's a monoidal category
16:38:19 <Cale> (You need tensoring over Z as the monoidal structure, with Z as the identity)
16:39:11 <revenantphx> hurray :D
16:39:12 <revenantphx> It's all set up
16:39:26 <revenantphx> OpenBSD in my virtualbox... ssh working nicely.
16:39:56 <revenantphx> There is one thing I'm wondering though...
16:40:14 <Cale> (Hmm, are we using the same monoidal structure for the other construction?)
16:40:18 <revenantphx> at the moment I'm ssh'ing through the local ip, but that could change, so I'm wondering if there's another way?
16:40:31 <monochrom> my cpu doesn't have vt-x etc. my virtualbox cannot do *bsd.
16:41:05 <revenantphx> vt-x?
16:41:08 <mercury^> Cale: for which one? Groups in groups?
16:41:16 <thunderfest> Any wizards interested in helping me build a monadic parser? 
16:41:35 <revenantphx> oh, I'm on an i7 so I'm clear on that I suppose.
16:41:45 <Cale> For one-object categories enriched over Ab.
16:42:01 * monochrom decides to hate intel
16:42:01 <ddarius> thunderfest: cabal install parsec
16:42:09 <Cale> We could choose (Ab,\otimes_Z,Z) or (Ab,x,1)
16:42:25 <revenantphx> monochrom: why?
16:42:29 <monochrom> are you ssh'ing from your virtual openbsd? to your virtual openbsd?
16:42:35 <revenantphx> to the virtual openbsd
16:42:52 <revenantphx> er, brb
16:43:03 * ddarius needs to work on getting a real Win7 install working under virtualbox.
16:43:14 <revenantphx> I have a partition with Win7 on it.
16:43:19 <revenantphx> For my work.
16:43:26 <thunderfest> ddarius: I know, but I have to write my own for a class assignment, I have what I feel to be an ok start but I'm struggling finish it.
16:43:30 <revenantphx> Soooo much nicer than previous versions to say the least but...
16:43:30 <mercury^> Cale: I believe it has to be the tensor product also.
16:43:34 <monochrom> if you use "bridged networking", you can ssh from anywhere to the virtual machine, apart from firewall blocking.
16:43:41 <revenantphx> monochrom: I do use bridged.
16:43:41 <ddarius> revenantphx: Win2k was the best.
16:43:54 <revenantphx> I used 2k for like 5 years > >
16:44:05 <revenantphx> monochrom: I just want to be able to ssh from this local machine anyhow
16:44:12 <revenantphx> the issue is that the ip of the virtualbox can change
16:44:20 <revenantphx> is there any way to ssh via hostname?
16:44:37 <revenantphx> er, windowserver is freezing up... imma restart
16:44:37 <revenantphx> br
16:44:56 <ddarius> He didn't even have time to finish "brb"
16:46:35 <monochrom> "host-only networking" allows you to ssh from host machine to virtual machine too (but not from anywhere else). but you do get more control over assigning ip.
16:47:07 <monochrom> "host-only networking" allows you to ssh from host machine to virtual machine too (but not from anywhere else). but you do get more control over assigning ip.
16:48:18 <revenantphx> okay...
16:48:23 <revenantphx> oh, sorry. Yeah.
16:48:36 <revenantphx> explain a bit more monochrom ?
16:49:09 <revenantphx> how can I choose the ip to assign?
16:49:27 <monochrom> I don't know. I haven't used it. The manual has it somewhere.
16:49:59 <hpc> it looks like host-only mode makes your computer's software fake the presence of a computer at an address, or more likely with a given host name
16:50:31 <sipa> is there a way to say something like "instance (forall x. Foo a x) => Bar a where ..." ?
16:50:36 <hpc> so it wouldn't matter what you give it; it generates something that probably won't collide with anything
16:50:43 <thom_logn> trying to understand fmap. How would I make the following work? fmap (Just *3) $ [Just 9]
16:50:59 <thom_logn> oops, meant fmap (*3) $ [Just 9]
16:51:20 <hpc> thom_logn: http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors
16:51:29 <hpc> oh, that
16:51:32 <thom_logn> I've been reading it
16:51:36 <hpc> :t fmap fmap
16:51:37 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
16:51:57 <hpc> > let ff = fmap fmap in ff (*3) [Just 9]
16:51:58 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe t]'
16:51:58 <lambdabot>         against inferre...
16:52:16 <hpc> > let ff = fmap . fmap in ff (*3) [Just 9]
16:52:17 <lambdabot>   [Just 27]
16:52:30 <hpc> :t fmap fmap fmap
16:52:31 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:52:33 <thom_logn> htanks
16:52:36 <thom_logn> thanks
16:53:02 <hpc> (somewhat tangental, but still neat if lyah hasn't mentioned it yet: fmap = (.))
16:55:14 <thom_logn> *sigh* my functor foo is far too weak
16:55:59 <jmcarthur> :t fmap.fmap
16:55:59 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
16:56:18 <hpc> thom_logn: in this specific case, you might also like catMaybes
16:56:27 <hpc> > catMaybes [Just 5, Nothing, Just 3]
16:56:28 <lambdabot>   [5,3]
16:56:44 <hpc> this makes the fmapping a bit less "yo dawg"
16:57:14 <thom_logn> <interactive>:1:0: Not in scope: `catMaybes'
16:57:24 <hpc> it's in Data.Maybe
16:57:26 <hpc> iirc
16:57:36 <thom_logn> k thnks
16:57:42 <thom_logn> afk
17:01:17 <Phyx-> > fmap.fmap id $ [Just 5, Nothing, Just 3]
17:01:18 <lambdabot>   Couldn't match expected type `a -> a1' against inferred type `[a2]'
17:01:33 <Phyx-> :t  fmap.fmap id
17:01:33 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a -> a1) -> f a -> f a1
17:01:39 <Phyx-> :t  (fmap.fmap id)
17:01:40 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a -> a1) -> f a -> f a1
17:01:47 <Phyx-> :t  fmap.(fmap id)
17:01:48 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a -> a1) -> f a -> f a1
17:01:56 <Phyx-> :t  fmap.fmap
17:01:57 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:02:12 <Phyx-> hrm
17:02:18 <kilimanjaro> :t fmap.fmap.fmap.fmap.fmap.fmap.fmap.fmap
17:02:19 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) (f6 :: * -> *) a b (f7 :: * -> *). (Functor f, Functor f1, Functor f2, Functor f3, Functor f4, Functor
17:02:19 <lambdabot> f5, Functor f6, Functor f7) => (a -> b) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 a))))))) -> f (f1 (f2 (f3 (f4 (f5 (f6 (f7 b)))))))
17:02:37 <Igloo> You probably want fmap (fmap id)
17:02:49 <Phyx-> :t  fmap (fmap id)
17:02:49 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (f a) -> f1 (f a)
17:03:04 <Phyx-> :t (fmap.fmap)
17:03:05 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
17:03:08 <aavogt> :t (fmap.fmap) id [Just 5, Nothing])
17:03:09 <lambdabot> parse error on input `)'
17:03:14 <aavogt> :t (fmap.fmap) id [Just 5, Nothing]
17:03:15 <lambdabot> forall a. (Num a) => [Maybe a]
17:03:32 <Phyx-> >  fmap (fmap id) [Just 5, Nothing, Just 3]
17:03:33 <lambdabot>   [Just 5,Nothing,Just 3]
17:03:54 <Phyx-> Igloo: i don't get it though
17:04:03 <Phyx-> if (fmap.fmap) has that type
17:04:15 <Phyx-> why does applying it to id expect another id
17:04:21 <Phyx-> err function
17:04:31 <Igloo> Phyx-: (fmap . fmap) id   would also work
17:05:01 <Phyx-> I.. basically tried every non working variant
17:05:02 <Phyx-> lol
17:07:39 <thom_logn> trying to learn haskell makes me feel old
17:08:01 <kilimanjaro> thom_logn, why?
17:09:33 <thom_logn> I still can't quite grok fmapping as a computational context even though I know it's got something to do with finction composition. Plus I hate the word Endofunctor that I keep running across
17:10:57 <thom_logn> I've read most of learn you a haskell a couple of times now but it still feels like jello in my head
17:11:36 <teratorn> write programs to learn about programming
17:12:08 <thom_logn> My project isnt far from that LOL
17:13:18 <mauke> fmapping isn't composition; it's "do this for every element in a collection"
17:17:25 <monochrom> > fmap not [True,True,False,True]
17:17:26 <lambdabot>   [False,False,True,False]
17:17:35 <monochrom> > fmap not (Just True)
17:17:36 <lambdabot>   Just False
17:17:42 <monochrom> > fmap not Nothing
17:17:43 <lambdabot>   Nothing
17:17:46 <revenantphx> monochrom: ssh is quite fast locally ^_^
17:17:47 <Twey> > not . Just True
17:17:48 <lambdabot>   Just False
17:17:50 <revenantphx> (not surprisingly)
17:18:24 <monochrom> there you have enough examples to intuit fmap
17:18:24 <Veinor> it's not just true, it's false!
17:20:54 <monochrom> actually there are two more examples showing another perspective.
17:21:24 <monochrom> to read a line and return its length: fmap length getLine
17:22:18 <pelotom> > length <$> getLine
17:22:19 <lambdabot>   <IO Int>
17:23:13 <monochrom> to parse something into a number (assume a monadic parser for this called parseInt) but then you want to return that number squared instead of that number itself: fmap (^ 2) parseInt
17:23:21 <Twey> thom_logn: (<$>) = fmap = (.) -- though that last one is λb-specific
17:28:50 <Phyx-> Twey: i hate that instance
17:29:09 <Twey> What instance?
17:29:31 <Phyx-> or rather, I'm in the camp that argues that (.) shouldn't be fmap in lambdabot
17:29:39 <Twey> Oh, that's not an instance
17:30:00 <monochrom> (.) is not a type class method
17:30:01 <Twey> I think we should propagate it to the Prelude, personally, and remove map and fmap
17:30:07 <Phyx-> i know, i was refering to the instance of (->a) of Functor that makes it possible
17:30:09 <Twey> And <$>
17:30:09 <aavogt> but if the instance didn't exist the (.) would never be right
17:30:23 <Twey> And liftM, and liftA
17:30:28 <rryan> http://snapframework.com/blog/2010/11/17/snap-0.3-benchmarks  really impressive benchmarks for pong and file there. are there any for normal web-app workloads like do a db query and then render a template ? 
17:30:58 <Twey> rryan: #snapframework maybe?  gcollins is usually there
17:31:17 <Twey> Also, haha Ruby.
17:31:37 <rryan> yea, wrong channel :) sorry
17:32:03 <ddarius> Down with intuition!  Up with purely axiomatic development.
17:32:14 <Twey> Hear hear!
17:32:46 * monochrom generates intuition from axioms anyway
17:33:38 <Twey> Intuition is a learned response
17:34:29 <monochrom> yeah, people underestimate the power of that.
17:34:48 <Freak> Hall Leute
17:35:39 <monochrom> "what is the intuition behind <*>?" answer: here are 1000 exercises on <*>, they constitute the intuition.
17:36:20 <ddarius> You'd have all the examples simply by exhaustion by then.
17:36:22 <Twey> It's just like fmapping two functors together.
17:36:58 <Twey> Hm, come to think of it
17:37:12 <Twey> Is there a Functor that is *not* Applicative?  Surely, right/
17:37:13 <Twey> ?**
17:37:13 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
17:37:34 <Twey> Why can't I think of one?  >.>
17:37:47 <monochrom> that one is harder. I don't know either.
17:38:29 <jmcarthur> @instances Functor
17:38:29 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:38:31 <jmcarthur> @instance Applicative
17:38:32 <lambdabot> Maybe you meant: instances instances-importing
17:38:39 <Twey> It seems like anything that is a Functor over a should also work for a = (b -> c)
17:38:39 <jmcarthur> @instances Applicative
17:38:40 <lambdabot> Couldn't find class `Applicative'. Try @instances-importing
17:38:51 <jmcarthur> @instances-importing Control.Applicative Applicative
17:38:52 <lambdabot> ((,) a), ((->) a), Const m, IO, Maybe, WrappedArrow a b, WrappedMonad m, ZipList, []
17:39:01 <monochrom> I have only recently known a way to generate non-monad applicatives. take two monads. they're functors and applicatives too. do functor-composition. some cases give you non-monad applicatives.
17:39:32 <Twey> jmcarthur: But they all *could* be Applicative, right?
17:39:41 <ddarius> (,) a is a functor but not an applicative functor.  What would pure do??
17:39:50 <Twey> Ah, right, pure
17:39:52 * ddarius doesn't know how two question marks got there.
17:40:05 <monochrom> ah nice. I shall remember that.
17:40:11 <Twey> ddarius: Clearly it's because you were VERY!! EXCITED!!!!
17:40:25 <ddarius> My secret was to look at comonads.
17:40:40 <jmcarthur> i have a suspicion that Maybe would not be Applicative if it was strict
17:40:45 <jmcarthur> let's see...
17:41:19 <jmcarthur> ddarius: (,) a is an applicative functor if a is a monoid
17:41:32 <ddarius> Not only an applicative functor, but a monad.
17:41:35 <jmcarthur> right
17:41:43 <pelotom> the next question is, are there any pointed functors which are not applicative?
17:41:48 <jmcarthur> but yes, in the case that a is not a monoid...
17:41:57 <pelotom> (in haskell)
17:42:01 <ddarius> You get a comonad but not an applicative functor.
17:42:08 <revenantphx> I'm scared to ask what a monoid is.
17:42:22 <ddarius> revenantphx: You shouldn't be.  You use them all the time.
17:42:25 <revenantphx> :O
17:42:27 <pelotom> revenantphx: it's easy, monoids are just categories with 1 object
17:42:30 <sm> question: do folks generally use the hackage stability field to describe the overall lifecycle status of the project.. or the status within the current major release number ?
17:42:35 <revenantphx> categories?
17:42:39 <ddarius> revenantphx: The archetypical example is your bread and butter.
17:42:40 <monochrom> has assoicative binop and an identity. like ++ and [] for lists.
17:42:47 <Makoryu> Fucking categories. How do they work?
17:42:52 <Twey> Hahaha
17:42:52 <revenantphx> like, Num and shit?
17:43:04 <Twey> revenantphx: Num is at least two monoids
17:43:05 <sipa> revenantphx: a monoid is something that has an 'empty' value, and a way to combine two values to a 'sum' one
17:43:05 <revenantphx> Well, shit isn't a category, I'm pretty sure.
17:43:05 <djahandarie> It suddenly got very vulgar in here
17:43:09 <pelotom> revenantphx: don't mind me
17:43:20 <Makoryu> Your mom got vulgar in here.
17:43:21 <Aune> monochrom: can you point me to the "1000 exercises on <*>" I need to build some intuition
17:43:22 <revenantphx> gotcha.
17:43:26 <jmcarthur> for strict Maybe, pure f <*> pure _|_ = _|_ even if f is not strict, so strict Maybe isn't an applicative functor
17:43:48 <jmcarthur> the law is   pure f <*> pure x = pure (f x)
17:43:51 <Twey> revenantphx: 1 and (*) are a monoid, as are 0 and (+)
17:44:01 <revenantphx> I... see?
17:44:03 <revenantphx> :t 1
17:44:04 <lambdabot> forall t. (Num t) => t
17:44:11 <pelotom> Num doesn't require anything to be a monoid... where's the identity element?
17:44:17 <ddarius> fromInteger 0
17:44:20 <revenantphx> :t (*)
17:44:21 <lambdabot> forall a. (Num a) => a -> a -> a
17:44:46 <Twey> revenantphx: (*) is a binary operation.  1 is an identity element: if you provide it as one of the arguments, the operation returns the other argument unchanged.
17:44:56 * sm opts for the former
17:44:57 <Twey> Ditto 0/(+).
17:45:08 <jmcarthur> by extension, strict Either is not an applicative functor either
17:45:14 <monochrom> exercise 0: suppose f2 :: String -> String -> String. what does f2 <$> getLine <*> getLine do?
17:45:19 <Twey> 3 + 0 = 3.  5 * 1 = 5.
17:45:33 <monochrom> exercise 1: suppose f3 :: String -> String -> String -> String. what does f3 <$> getLine <*> getLine <*> getLine do?
17:45:48 <revenantphx> Twey: still not seeing what "a monoid" is.
17:45:49 <Aune> Ooooh, that looks nice
17:45:51 <monochrom> exercise 2: suppose f4 :: String -> String -> String -> String -> String. what does f3 <$> getLine <*> getLine <*> getLine <*> getLine do?
17:45:56 <Twey> monochrom: Hmm, I sense an opportunity to use Template Haskell…
17:46:04 <monochrom> there are 997 more similar exercises.
17:46:05 <Twey> revenantphx: That is what a monoid is — that's all it is
17:46:15 <pelotom> revenantphx: http://en.wikipedia.org/wiki/Monoid
17:46:19 <Twey> revenantphx: A monoid is a type that has a binary operation and an identity element.
17:46:28 <revenantphx> Okay.
17:46:29 <monochrom> No, Twey, these are free samples of "1000 exercises on <*>"
17:46:32 <Twey> revenantphx: Like (*) and 1.
17:46:43 <revenantphx> So a list could be a monoid, with ++ and []
17:46:44 <jmcarthur> an *associative* binary operation
17:46:49 <Twey> revenantphx: And indeed it is
17:46:49 <monochrom> Pay me $1000 to get the complete set of 1000 exercises.
17:47:02 <pelotom> along with some rules about how they work
17:47:04 <Twey> > [1, 2] `mappend` [3, 4]
17:47:05 <lambdabot>   [1,2,3,4]
17:47:05 <jmcarthur> > "foo" `mappend` "bar"
17:47:06 <lambdabot>   "foobar"
17:47:19 <jmcarthur> > "foo" `mappend` ("bar" `mappend` baz)
17:47:20 <lambdabot>   Not in scope: `baz'
17:47:28 <jmcarthur> > "foo" `mappend` ("bar" `mappend` "baz")
17:47:29 <lambdabot>   "foobarbaz"
17:47:36 <jmcarthur> > ("foo" `mappend` "bar") `mappend` "baz"
17:47:36 <lambdabot>   "foobarbaz"
17:47:45 <Twey> pelotom: I don't think there are any monoid laws other than those implied in ‘identity element’, are there?
17:47:56 <jmcarthur> Twey: associativity
17:48:01 <revenantphx> so a monoid defines mappend and memtpy
17:48:04 <Aune> I think Ill pass on the other 997 exercises then
17:48:07 <Twey> jmcarthur: Oh, right
17:48:10 <revenantphx> so, a binary operation and an identity element.
17:48:23 <jmcarthur> revenantphx: it must be an associative binary operation
17:48:24 <Twey> monochrom: Can I get exercise 1000 first?  I want to see how it ends before I decide to buy.
17:48:30 <revenantphx> jmcarthur: what do you mean?
17:48:42 <jmcarthur> revenantphx: (a * b) * c = a * (b * c)
17:48:49 <monochrom> It is too long to fit in this margin.
17:48:51 <revenantphx> oh, that associative.
17:48:56 <jmcarthur> right
17:49:07 <Twey> monochrom: You can hpaste, I don't mind.
17:49:32 <djahandarie> It'd be nice if there were a bunch of quickcheck props that were automatically run against instances of typeclasses
17:49:39 <revenantphx> I have to say, regardless of haskell itself, choosing to *try* to learn haskell has been incredibly enlightening.
17:49:48 <revenantphx> leading to this room, and many pdfs :D
17:49:56 <revenantphx> pdfs full of theory and mind-breaking stuff.
17:49:58 <djahandarie> God I hate PDFs
17:49:59 <jmcarthur> you believe you have failed to learn haskell? :(
17:49:59 <Twey> Heh.  Yes, many, many PDFs.
17:50:06 <revenantphx> jmcarthur: no no, I just havent learned nearly enough
17:50:07 <Twey> Oh, how I hate the PDFs.
17:50:17 <monochrom> I like PDFs.
17:50:17 <revenantphx> Because I don't have time right now.
17:50:19 <jmcarthur> revenantphx: nobody learns "enough"
17:50:24 <djahandarie> revenantphx, you were real active for a day or two then disappeared
17:50:32 <jmcarthur> i don't mind PDFs
17:50:35 <revenantphx> djahandarie: yes, because I went on vacation
17:50:43 <revenantphx> djahandarie: and then I came back and had a lot of school >_>
17:50:47 <djahandarie> Haskell is my vacation!
17:50:54 <revenantphx> djahandarie: from what?
17:50:54 <aavogt> djahandarie: does reify give you instances?
17:51:25 <djahandarie> aavogt, huh?
17:51:39 <revenantphx> djahandarie: and it was more like a week, week and ah alf
17:52:10 <revenantphx> I was quiet for a good period because I was engrossed in lyah and rwh
17:52:30 <revenantphx> I finally got some time to continue (hopefully finish) SICP. I'm overjoyed.
17:52:35 <djahandarie> aavogt, are you talking about data-reify?
17:52:38 <aavogt> djahandarie: template haskell
17:52:50 <monochrom> like a catepillar to a butterfly. hey, metamorphism!
17:52:59 * aavogt just verified that it only seems to give you the class definition
17:53:05 <monochrom> err, metamorphosis or something!
17:53:08 <djahandarie> Ah
17:53:10 <djahandarie> I don't do much TH
17:53:17 <aavogt> when you  $(reify ''Functor >>= stringE . show)
17:53:22 <Twey> Haha
17:53:41 <Twey> I haven't quite grasped the zygohistomorphic prepromorphisms yet… *meta*morphisms sound terrifying!
17:53:48 <djahandarie> Haha
17:54:15 <djahandarie> There are generalized morphisms
17:54:21 <djahandarie> metamorphisms do sound scarier though
17:54:48 <pelotom> isn't that what butterflies do?
17:54:56 <djahandarie> Welcome to 10 lines ago
17:55:15 <pelotom> damn, late to the party :P
17:55:19 <Twey> Heheh
17:55:26 <monochrom> the correct word for butterfly is metamorphosis
17:55:26 <Twey> Someone needs to read more Kafka
17:55:38 <bench1> a newbie question, typically when is  #haskell channel most crowded? 
17:55:38 <sproingie> last time i studied metamorphisms, i woke up as a cockroach
17:55:44 <pelotom> fuckin' butterflies, how do they work?
17:55:44 <monochrom> but this is just because biologists fear morphisms.
17:55:45 <Twey> Thankee
17:55:53 <bench1> in the afternoon (US time) or in the evening?
17:56:10 <Twey> bench1: Umm, I don't know.  It's usually Busy Enough.
17:56:13 <aavogt> there are/were statistics generated from the logs somethewe
17:56:16 <aavogt> somewhere
17:56:20 <djahandarie> Somewhere...
17:56:31 <pelotom> The Metamorphism, by Franz Captcha
17:56:33 <djahandarie> Was it chrisdone who did it?
17:56:41 <djahandarie> I mean
17:56:42 <Twey> bench1: There are a lot of Haskellers in Europe, so I'd say probably earlier is better.
17:56:44 <djahandarie> Chrisdoneit!
17:56:54 <monochrom> #haskell is most crowded when someone says he/she doesn't get haskell
17:56:55 <Twey> bench1: It's currently around two o'clock in the morning here, for example.
17:57:05 <djahandarie> Or when someone asks about monads
17:57:08 <Twey> Heh.
17:57:30 <djahandarie> Because then there are all the people trying to explain it and all the people bitching about monads
17:57:59 <bench1> Twey, so afternoon is better then, it's 6pm now PST
17:58:39 <pelotom> this channel is basically never quiet from what I've seen
17:58:48 <djahandarie> There are a lot of haskellers in Europe, but I don't think they're around here as much as the US people
17:58:55 <pelotom> #scala is comparatively a ghost town
17:59:26 <djahandarie> Honestly, almost all of the people who help in here on a regularly basis are in Northern America
17:59:34 <djahandarie> regular*
17:59:37 <kilimanjaro> pelotom, part of that is lambdabot
17:59:51 <aavogt> bench1: there's this http://www.cse.unsw.edu.au/~dons/irc/haskell-09.html
18:00:39 <pelotom> kilimanjaro: how so?
18:00:57 <kilimanjaro> I mean, re: "this channel is basically never quiet from what I've seen"
18:01:41 <djahandarie> Aw man, I'm not even on that page :(
18:01:56 <djahandarie> Then again I think I said a total of like 3 lines in here in 2009 so that probably makes sense
18:01:59 <aavogt> it's a year old
18:02:01 <pelotom> it's not like lambdabot starts talking to itself when everyone else gets quiet...
18:02:13 <Twey> pelotom: … as far as you know…
18:02:19 <monochrom> hehehe
18:02:24 <xiackok_> @hoogle Pool
18:02:24 <lambdabot> module Foreign.Marshal.Pool
18:02:24 <lambdabot> Foreign.Marshal.Pool data Pool
18:02:24 <lambdabot> Foreign.Marshal.Pool pooledMalloc :: Storable a => Pool -> IO (Ptr a)
18:02:28 <mm_freak> hmm
18:02:33 <mm_freak> i don't get haskell
18:02:38 <monochrom> hahaha
18:02:38 <kilimanjaro> pelotom, yes, but people use it in contexts where there is no ambient conversation
18:02:51 <aavogt> djahandarie: well you just run a script over some logs to generate that
18:02:57 <pelotom> mm_freak: it's basically a space burrito
18:03:07 <djahandarie> Beat me to it pelotom lol
18:03:21 <monochrom> mm_freak: the 3rd language you learn is the best language
18:03:46 <mm_freak> monochrom: turbo pascal 2.0 is the best language?
18:03:53 <roconnor> > log 10
18:03:54 <lambdabot>   2.302585092994046
18:04:04 <monochrom> I concur!
18:04:06 <roconnor> > log (exp 1)
18:04:07 <lambdabot>   1.0
18:04:15 <monochrom> though it's really 4.0 in my case
18:05:13 <dmead> hey channel, why doesn't ghci chase files in the same directory you're trying to compile?
18:05:13 <lambdabot> dmead: You have 1 new message. '/msg lambdabot @messages' to read it.
18:05:39 <mm_freak> dmead: what do you mean?  imports?
18:05:39 <monochrom> eh? ghci does chase files in the same directory for me
18:05:58 <mm_freak> because then it does, but don't forget --make
18:05:59 <monochrom> what is your secret method of breaking ghci?
18:06:12 <mm_freak> monochrom: sort [1..]
18:07:02 <pelotom> > isSorted [1..]
18:07:03 <lambdabot>   Not in scope: `isSorted'
18:07:30 <monochrom> @let isSorted [] = True; isSorted (x:xs) = True
18:07:31 <lambdabot>  Defined.
18:07:36 <monochrom> > isSorted [1..]
18:07:37 <lambdabot>   True
18:07:51 <lars9> is it safe to install ghc7 now? will it break some packages i've installed?
18:08:16 <monochrom> you will reinstall all packages. every new version of ghc requires this
18:08:53 <jmcarthur> lars9: you can have multiple versions of ghc side by side, but they won't share packages
18:08:55 <dmead> @seen byorgy
18:08:55 <lambdabot> Unknown command, try @list
18:08:55 <preflex>  Sorry, I haven't seen byorgy
18:09:00 <jmcarthur> lars9: if you replace one with the other you must reinstall your packages
18:09:05 <monochrom> but http://groups.google.com/group/comp.lang.haskell/msg/a38908521c5a6e6b will help you keep old ghc versions so you don't lose anything
18:09:25 <djahandarie> You know
18:09:40 <djahandarie> I think I've actually only been learning Haskell for a year now
18:10:02 <djahandarie> Considering I have had literally almsot no active in IRC channel before jan 01
18:10:39 <lars9> imran_sr: monochrom: will the packages still compile?
18:11:04 <monochrom> some packages are incompatible with ghc 7
18:12:58 <lars9> anyone tested xmonad and xmobar?
18:13:06 <lars9> * with ghc7
18:17:44 <lars9> nevermind, arch has no ghc7's package now, i'll just wait
18:18:18 <kmc> lars9, you should probably wait until Haskell Platform to get ghc7, if you want a smooth experience
18:19:37 <lars9> kmc: yep. no hurry.
18:19:44 * ddarius doesn't like to think about how long he's been in #haskell.
18:19:54 <blueonyx> hi, is there a configure flag to build the haskell platform without glut?
18:22:08 <kmc> ./configure --without-GLUT
18:22:09 <kmc> perhaps?
18:22:30 <ddarius> ./configure --DWIW
18:22:55 <kmc> blueonyx, if you follow the "Build from cabal" instructions at http://hackage.haskell.org/platform/linux.html
18:23:01 <kmc> then you can edit the cabal file first
18:23:35 <blueonyx> --DWIW and --without-GLUT aren't recognized
18:26:49 <monochrom> DWIW is a joke. it means do what is wise.
18:26:52 <sproingie> ./configure --with-pony
18:27:07 <jmcarthur> i read it as "do what i want"
18:27:40 <sproingie> i sometimes add --dwim flags to my programs to enable extra behavior
18:27:58 <blueonyx> isnt there a configure option which lists all features/packages?
18:28:05 <monochrom> --help
18:28:35 <blueonyx> no, it only says --without-FEATURE but not what FEATURE may look like
18:29:58 <sproingie> it should list available features afterward assuming they were correctly set up in the autoconf recipe
18:33:26 <blueonyx> okay i'll install the glut package, thank anyhow :/
18:39:19 <turiya> how to make a hidden module (such as Data.Packed.Internal.Vector) visible?
18:40:58 <soiamso> turiya: Data.Packed may has a export discription.
18:42:37 <turiya> soiamso: hmm, how do i change that?
18:45:49 <soiamso> turiya: go to there(source) and add the Internal package you want
18:46:13 <turiya> soiamso: oh.. thanks
18:46:53 <soiamso> turiya: expose ?
18:48:27 <turiya> soiamso: i will try what you have suggested.. what expose?
18:48:32 <xiackok_> @hoogle Mail.Mime
18:48:32 <lambdabot> No results found
18:49:32 <soiamso> turiya: expose the module, in the module discription
18:52:22 <turiya> soiamso: ok
18:54:12 <kmc> hi Boxo :)
18:54:17 <Boxo> yo kmc
18:54:30 <kmc> you have:  Foo $ \x -> return x
18:54:33 <kmc> simpler:  Foo return
18:54:41 <Boxo> so you wanted to critique http://pastebin.ca/1994955 and http://pastebin.ca/1995163
18:54:53 <Boxo> yeah, that's for clarity
18:55:07 <kmc> "if x == True then ..."  ⇒ "if x then ..."
18:55:27 <kmc> hmm, i don't think it's more clear, but perhaps that depends on your audience
18:55:43 <kmc> you can also factor out "return" from your last line in newcomb2
18:55:45 <Boxo> There True and False really stand for something other than booleans, so...
18:55:55 <kmc> return (if action then box1 else box1+box2)
18:56:00 <kmc> ah, then you should probably make a new type
18:56:07 <Boxo> meh, boilerplate
18:56:17 <kmc> but you're already writing the boilerplate "== True"
18:56:24 <kmc> might as well make it meaningful and machine-checked
18:56:54 <Boxo> it also lets me write general strategies for games where actions are Bools
18:57:09 <Boxo> like _coinflip_
18:57:32 <Boxo> Really, all of this is for clarity, if you think it's not actually clearer... maybeit's not...
18:57:57 <kmc> i don't follow... (== True) :: Bool -> Bool.  (x == True) will never be more general than x
18:58:08 <kmc> :t (== True)
18:58:09 <lambdabot> Bool -> Bool
18:58:29 <ddarius> kmc: It could fix the type, but if already would do that, so that doesn't apply in this case.
18:58:53 <ddarius> At any rate, x == True is ugly as sin.
18:59:07 <Boxo> False stands for two-box. Would I write "if not action then ..." to check for two-boxing?
18:59:30 <Boxo> "if action == False" is clearer
18:59:45 <kmc> yeah
18:59:57 <kmc> i think (x == False) adds clarity but (x == True) is just noise
19:00:10 <kmc> but i'd rather use:  data Choice = OneBox | TwoBox
19:00:16 <jmcarthur> (not x)?
19:00:29 <kmc> also in other places you use "case ... of True -> ... False -> ..." which might also be better
19:00:32 <jmcarthur> x == False seems strange to me
19:00:39 <kmc> i kinda dislike if/then/else, though it has some convenience
19:00:53 <kmc> this looks like pretty cool code
19:00:59 <kmc> representing decision problems in Haskell
19:01:12 <jmcarthur> i'm a fan of bool :: a -> a -> Bool -> a in place of if-then-else
19:01:13 <Boxo> yeah, I'm hyped up about it
19:01:16 <kmc> you mentioned diagrams, do you have plans to extract diagrams from the code?
19:01:27 <Boxo> Nope
19:01:56 <Boxo> Anyway, how would you extract a diagram from a function (Double -> Int), for example?
19:02:33 <kmc> Boxo, not very easily.  but you could instead provide a combinator library that allows the user to build values, which can be extracted either to functions or to diagrams
19:02:52 <kmc> an "embedded domain-specific language"
19:03:00 <kmc> there's various techniques for this in Haskell
19:03:04 <kmc> (and in general)
19:03:07 <Boxo> It would need stuff like a datatype for mathematical expressions
19:03:25 <kmc> yep
19:03:30 <Boxo> Pretty lofty. But it's separable from this core code, so I can totally do it later
19:03:43 <kmc> data Expr = Lit Integer | Add Expr Expr | ....; instance Num Expr where { fromInteger = Lit; (+) = Add; ... }
19:08:31 <roconnor> @hoogle LineBuffer
19:08:32 <lambdabot> System.IO LineBuffering :: BufferMode
19:08:32 <lambdabot> System.Console.Editline.Readline getLineBuffer :: IO String
19:08:44 <roconnor> @hoogle NoBuffer
19:08:44 <lambdabot> System.IO NoBuffering :: BufferMode
19:08:53 <roconnor> @hoogle BufferMode -> IO ()
19:08:54 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
19:08:54 <lambdabot> Prelude print :: Show a => a -> IO ()
19:08:54 <lambdabot> System.IO print :: Show a => a -> IO ()
19:11:40 <turiya> soiamso: i have the source now, where should i expose the module?
19:12:14 <soiamso> turiya: module section, and import section
19:13:13 <turiya> in configure.hs?
19:16:04 <lars9> any tool can visualize the graph of function calls?
19:17:13 <monochrom> perhaps http://hackage.haskell.org/package/hood and http://hackage.haskell.org/package/GHood
19:18:27 <lars9> monochrom: thanks
19:19:54 <xiackok_> @hoogle SqliteReader
19:19:54 <lambdabot> No results found
19:29:28 <ivanm> preflex: seen Cale
19:29:28 <preflex>  Cale was last seen on #haskell 2 hours, 47 minutes and 20 seconds ago, saying: We could choose (Ab,\otimes_Z,Z) or (Ab,x,1)
19:31:54 <ivanm> @ask Cale any suggestions on how to have Show and Read instances for planar graphs?  there seem to be a few formats that Brendan McKay's software uses, but they deal with unlabelled graphs only and have a maximum size :s
19:31:54 <lambdabot> Consider it noted.
19:40:25 <lars9> @where lambdor
19:40:25 <lambdabot> I know nothing about lambdor.
19:40:36 <lars9> @google lambdor
19:40:36 <lambdabot> No Result Found.
19:41:20 <lars9> suggest: add http://lambdor.net/ to reference of pratical FRP & arrows.
19:45:15 <ivanm> lars9: @where+ is what you want
19:49:21 <lars9> ivanm: how to check its syntax?
19:49:29 <ivanm> @help where+
19:49:29 <lambdabot> where+ <key> <elem>. Define an association
19:50:01 <lars9> @where+ lambdor http://lambdor.net/
19:50:01 <lambdabot> Okay.
19:50:10 <lars9> @where lambdor
19:50:10 <lambdabot> http://lambdor.net/
19:50:14 <lars9> cool
19:55:08 <ivanm> I wanted to release an initial version of my planar-graph library for people to look at... except I need to wait for someone else to release an updated version of their library with some patches I wrote for it :s
19:55:40 <copumpkin> you can still give us a link to the source repo
19:58:01 <ivanm> yeah, I'm trying to do that now
19:58:39 <ivanm> dammit, why doesn't darcs let me put it to my home space on c.h.o?
19:58:52 <ivanm> it keeps bitching that it can't resolve the hostname :s
20:00:07 <ivanm> it doens't help that the version of darcs here is only 2.2.0, and I can't build a new one myself because of the various C library headers I'd need :s
20:01:47 <ivanm> copumpkin: http://hpaste.org/41590/initial_version_of_planargrap
20:02:17 <dstcruz> I guess I better not use @remember to find quotations from people in the channel. Seems to easy to make someone else say something :( Any ideas?
20:02:31 <ivanm> dstcruz: hmmm?
20:02:33 <dstcruz> ... talking about HWN ussage of @remember for quotes
20:02:43 <copumpkin> dstcruz: doesn't really happen that often though
20:02:55 <copumpkin> and occasionally someone will @remember something from a mailing list or other source
20:02:57 <ivanm> I don't think I've ever seen @remember be abused
20:03:03 <jmcarthur> @remember dstcruz I didn't say this!
20:03:04 <lambdabot> Okay.
20:03:15 <dstcruz> I've trusted it so far, but I'm afraid of having someone say something they totally didn't say.
20:03:20 <ivanm> dstcruz: however, you should probably check for @forget (or whatever it is) that happens soon afterwards in case someone needs/wants to edit it
20:03:23 <jmcarthur> @forget dstcruz I didn't say this!
20:03:24 <lambdabot> Done.
20:04:02 <dstcruz> jmcarthur: is there a way to get lambabot to tell me about @remembers between 2 dates? along with @forgets?
20:04:22 <jmcarthur> ideal would be for lambdabot to have a web page that lists quotes or something. a lot of other bots do that
20:04:23 <ivanm> jmcarthur: wow, you sure do talk a lot... :p
20:04:30 <lars9> @help remember
20:04:30 <lambdabot> quote <nick>
20:04:30 <lambdabot> remember <nick> <quote>
20:04:30 <lambdabot> Quote somebody, a random person, or save a memorable quote
20:04:44 <ivanm> dstcruz: not AFAIK; also, that would require for lambdabot to be online and functioning, and to @flush before dying
20:04:46 <jmcarthur> ivanm: are you grepping my name or something?
20:04:48 <lars9> @quote
20:04:48 <lambdabot> JelloBiafra: says: The conveniences you demanded are now mandatory.
20:05:04 <dstcruz> jmcarthur: see http://bit.ly/aZcX2j 
20:05:06 <ivanm> jmcarthur: dstcruz just released a new HWN, and you were the third-most active person here
20:05:09 <ivanm> only after lambdabot and kmc
20:05:25 <jmcarthur> :o
20:05:32 <ivanm> dstcruz: wait, you did a new HWN... and didn't mention GHC 7.0.1? :o
20:05:41 <copumpkin> edwardk: did you figure out the search/every thing?
20:06:03 <jmcarthur> okay i officially talk too much then ^_^
20:06:23 <dstcruz> it's comforting to know we can find you around in time of trouble!
20:06:26 <ivanm> gah, just realised I forgot to export a couple of functions; good thing I didn't upload planar-graph then ;-)
20:06:40 <copumpkin> ivanm: it's right up there at the top, http://snapplr.com/2bz2
20:07:13 <ivanm> whoops; I was expecting it to be in the announcements section :s
20:07:18 <ivanm> my apologies dstcruz
20:07:55 <jmcarthur> i typo a lot. i bet a large portion of my "utterances" were typo corrections :$
20:08:05 <dstcruz> ivanm: I think I would have gotten shot! Even though it happened after the time period the newsletter "covers".
20:08:13 <ivanm> heh
20:08:26 <ivanm> copumpkin: anyway, waddaya think about the API of planar graphs?
20:08:28 <dstcruz> I have a pretty pie chart of all the talk :)
20:08:46 <copumpkin> ivanm: sorry, exhausted! forgot to look at it :P
20:08:50 <ivanm> heh
20:09:01 <ivanm> I did forget to export EdgePos(..), mapNodes and mapEdges
20:09:29 <ivanm> it's in no way perfect yet; for starters I want "safe" adding and deletion functions that attempt to preserve planarity
20:10:00 <ivanm> and I probably need to die more gracefully in places (e.g. if trying to delete a non-existent node, don't throw an error)
20:10:01 <kmc> i'm number 1
20:10:07 <ivanm> kmc: 2, not 1
20:10:10 <ivanm> @botsnack
20:10:10 <lambdabot> :)
20:10:13 <kmc> number 1 human
20:10:48 <ivanm> prove you're human!
20:10:54 <ivanm> and prove that lambdabot _isn't_! :p
20:10:54 <dstcruz> lol!
20:11:17 <dstcruz> lambdabot, are you human?
20:11:26 <dstcruz> ... silence...
20:11:39 <copumpkin> ivanm: looks nice :)
20:11:43 <ivanm> copumpkin: :D
20:11:49 <aavogt> @vixien are you humane?
20:11:49 <copumpkin> I'm not in a very critical mood though!
20:11:49 <lambdabot> yes, i am
20:12:07 <ivanm> I don't know how correct it is; I have the sneaking suspicion that I get the clockwise/anti-clockwise stuff mixed around sometimes
20:12:25 <copumpkin> ivanm: quickcheck!
20:12:32 <ivanm> I'm hoping to make a "proper" initial release this weekend, then try to actually use it next week and see what it's missing
20:12:51 <ivanm> copumpkin: yeah, I think QC might be too much or confusing for this though
20:12:52 <copumpkin> does dual . dual = id ?
20:13:07 <ivanm> ummm, there will probably be some corner cases where that won't happen
20:13:22 <ivanm> and it won't be id for the simple fact that the IDs will probably be different
20:13:22 <ddarius> copumpkin: If money isn't an issue, which college in the greater Boston area should I physically attend?
20:13:31 <ivanm> so == will return False
20:14:30 <ivanm> copumpkin: I need to find a proper Show/Read instance (or at least a pretty-printer) and actually try using it to see if it operates properly, rather than QC it
20:15:48 <copumpkin> ddarius: aside from the obvious "MIT" answer, maybe NEU? not really sure. I don't actually know much about the colleges around here apart from the common knowledge
20:16:18 <copumpkin> I've never even been to NEU though
20:16:33 <kmc> ddarius, what kind of program?
20:16:59 <copumpkin> man, it sure is windy tonight
20:17:02 <edwardk> ddarius: what are you looking for out of the program?
20:17:02 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
20:17:28 <edwardk> augur: you rang?
20:17:34 <augur> hey
20:17:48 <augur> i hear you might be able to point me in the correct direction for something
20:17:51 * copumpkin looks around guiltily
20:17:57 <augur> :3
20:18:11 <edwardk> until 'something' becomes more specific i will have to answer that with a distinct 'maybe' =)
20:18:19 <ddarius> At this point it would just be a few (undergraduate) CS classes to supplement my main (online) college to take full advantage of my GI Bill, though I probably follow it up with beginning a Master's program there after getting my Bachelor's.
20:18:52 <augur> edwardk: :p
20:19:00 <augur> edwardk: #haskell-blah?
20:19:20 <dmead> @seen byorgy
20:19:20 <lambdabot> Unknown command, try @list
20:19:21 <preflex>  Sorry, I haven't seen byorgy
20:19:24 <dmead> @list
20:19:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
20:19:34 <ivanm> preflex: seen byorgey
20:19:34 <preflex>  byorgey was last seen on #haskell 10 hours, 56 minutes and 36 seconds ago, saying: xplat: oh, please explain, I've never heard of that before!
20:20:29 <dmead> how do you send a message with lambdabot?
20:20:31 <dmead> anybody?
20:20:34 <edwardk> ddarius: i have to admit i rather like the northeastern folks quite a bit. between matthias and mitch wand, olin shivers, etc. its a pretty strong program
20:20:48 <ivanm> dmead: @tell <nick> <msg>
20:20:55 <dmead> thanks
20:21:24 <edwardk> but both NEU and MIT both have the problem that their undergraduate programs both kinda miss the point of having types lying around ;)
20:21:45 <dmead> edwardk, what specifically do you mean?
20:22:03 <dmead> and whats happening, etc etc
20:22:16 <kmc> i've been talking to MIT EE/CS people, and they say the school has almost no PL classes anymore
20:22:24 <kmc> SICP isn't taught except during IAP
20:22:42 <edwardk> dmead: meaning that both programs don't really bother to think about types. At MIT you learn to think about types in your graduate program if at all.
20:22:48 <copumpkin> kmc: kind os ad :(
20:23:19 <edwardk> and NEU is scheme-centric to the point that types seem superfluous to very influential people inside of their program. its macros macros macros.
20:24:25 <edwardk> if you're just looking to pick up a few classes though, NEU is probably a pretty good bet
20:24:30 <dmead> that seems odd
20:26:02 <edwardk> dmead: and re: how i'm doing? quite well, actually =)
20:26:10 <ddarius> Now all I have to do is figure out if any courses are offered at a time that I could actually take them.
20:26:14 <dmead> good good
20:30:40 <diracdelta> Hi, I'm looking at bug #806 and #2189. Is anyone familiar with the Haskell IO subsystem?
20:31:05 <ddarius> edwardk: Do you have talks (or a date for that matter) lined up for the next Boston Haskell thing?  (I guess I should subscribe to that group at some point...)
20:32:36 <edwardk> ddarius: i have the talks lined up, but not the date. the date it was going to be, i'll be in new york
20:32:41 <kmc> diracdelta, are you talking about GHC?
20:32:56 <ddarius> edwardk: What's the not copumpkin talk?
20:33:07 <djahandarie> copumpkin talk!
20:33:15 <djahandarie> copumpkin cotalk
20:33:26 <djahandarie> Or would that be pumpkin cotalk
20:33:45 <edwardk> ddarius: well, i was looking for something to pair with copumpkin, but i also have david spivak who plans to come out and talk about databases as categories and runar volunteered to talk about how
20:33:57 <copumpkin> and how!
20:34:05 <edwardk> scalaz and the haskell-prelude/category-extras relate
20:34:20 <edwardk> because of some of the tricky encodings needed to get that stuff over into scala
20:34:38 <kmc> kickass
20:34:46 <edwardk> (not that spivak has to go far, he's a mathematician over at mit)
20:34:52 <kmc> i was sad i missed the copumpkin / ddarius power hour
20:34:54 <djahandarie> That sounds interesting
20:34:56 <djahandarie> kmc, you didn't
20:35:07 <copumpkin> kmc: I was sad I missed it too
20:35:12 <djahandarie> Only the ddarius power half-hour
20:35:31 <ddarius> David Spivak's talk would be interesting, though the one video I saw of him presenting it, it wasn't... the best presentation, but I think those slides were finished like half an hour before the talk.
20:35:37 <ivanm> anyway, I'm going to head off home... bye all!
20:35:43 <kmc> see ya ivanm
20:36:12 <djahandarie> kmc, what you did miss is a chance to see me!
20:36:37 <diracdelta> kmc: yeah, my pardon
20:36:47 <diracdelta> kmc: sorry for walking away there
20:37:03 <diracdelta> kmc: so yes, I'm talking about ghc
20:37:29 <diracdelta> kmc: apparently there's issues with the way that they're handling IO on windows.
20:37:54 <kmc> djahandarie, you made it out? cool
20:38:00 <kmc> diracdelta, i see
20:38:20 <kmc> i don't know much about the GHC IO manager, or about Windows
20:38:31 <kmc> i can explain how the IO monad is implemented in terms of primops, but not much below that layer
20:39:04 <diracdelta> kmc: That sounds interesting (and probably relevant), do you have a reference link for that?
20:39:29 <kmc> i doubt it's relevant
20:39:35 <kmc> you can look at the source for GHC.IO
20:39:36 <Boxo> Is there a library that has a probability distribution monad that can deal with continuous distributions as well as discrete ones..?
20:39:44 <kmc> or is it GHC.Types
20:40:02 <kmc> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
20:40:12 <kmc> basically IO is built out of impure, side-effecting functions
20:40:20 <kmc> but GHC passes through this parameter of type (State# RealWorld)
20:40:24 <kmc> which has no runtime meaning at all
20:40:30 <kmc> but which sets up the data dependencies correctly
20:40:37 <kmc> in order to sequence those side effects according to (>>=)
20:40:45 <quintessence> Is there a way to import hiding instance declarations?  hmatrix-static declares an instance (... some constraints ...) => Eq (a s t), which kind of breaks things.
20:41:08 <kmc> quintessence, that's terrible
20:41:15 <ddarius> quintessence: No, there isn't.
20:41:23 <edwardk> ddarius: well, he's had a few opportunities to polish the talk since then
20:41:32 <ddarius> edwardk: That's what I'm hoping.
20:41:34 <kmc> "this library defines equality for all 2-ary type constructors"
20:41:39 <kmc> madness
20:41:47 <kmc> i'm guessing the author didn't understand instance resolution
20:41:56 <kmc> to be fair it's not explained very well, from the sources i've seen
20:42:28 <kmc> or is the idea that the user should use OverlappingInstances?
20:43:17 <quintessence> I'm not sure.  The instances in question just lifts from the underlying matrix/vector implementation without the phantom types
20:43:53 <quintessence> but the relation between the statically-checked ones and the underlying ones is through a type family (associated with another class) and not a newtype
20:44:31 <quintessence> and -XOverlappingInstances doesn't stop GHCi from complaining about, say, (0, 0) == (0, 0)
20:46:52 <djahandarie> If I remember the categories/databases talk correctly, it seemed like the idea wasn't entirely fleshed out, not just the slides
20:46:56 <djahandarie> Wait
20:47:00 <djahandarie> There was another video that I never watched though
20:47:18 <edwardk> i spent some time talking to him about it. there is some interesting stuff there
20:47:46 <edwardk> my knee jerk reaction was pretty skeptical
20:49:03 <pelotom> edwardk: skeptical that it's a category or skeptical that that's a useful way to think about it?
20:49:08 <ddarius> djahandarie: There's a paper from a while ago that's reasonably good.
20:49:15 <edwardk> peletom: that it was useful
20:49:45 <pelotom> yeah, I wasn't sure it was useful either
20:49:58 <pelotom> it was more like, oh, cool, yeah, that makes sense
20:50:26 <ksf> are the shootout rules "only stuff that comes with ghc" or "only stuff that comes with the platform"?
20:50:34 <edwardk> peletom: well there are some rather neat ways to model queries with it. not sure that those are all that useful from an actual computational perspective though
20:50:47 <djahandarie> ksf, I think it's just like "whatever"
20:50:56 <djahandarie> You need to get him to install it though
20:51:20 <djahandarie> I imagine he wouldn't install a package made just for the shootout or something like that
20:51:27 <djahandarie> I'm not entirely sure what the process is
20:51:31 <pelotom> edwardk: what about from a usability perspective?
20:52:47 <edwardk> pelotom: like i said, there is some interesting stuff there. i'm not about to go through and try to actually put the ideas there into practice though =)
20:54:30 <ksf> djahandarie, well... forgive me if I don't trust you on that.
20:55:27 <ksf> well, and even the platform comes without vector.
20:56:17 <edwardk> roman's little small vector post is a lot of fun
20:56:20 <djahandarie> dons's word on vector was "Ask him nicely"
20:56:24 <djahandarie> edwardk, yeah I liked that
20:57:11 <edwardk> djahandarie: the zipWithF implementation is a nice little brain teaser
20:57:12 <ksf> and there's another reason against going for vector instead of raw Ptrs, now, which is that I might just come up with a veritable Data.HashTable replacement.
20:57:39 <ksf> at least single-threadedly.
20:57:41 <djahandarie> ksf, have you seen blackh's latest knucleotide?
20:57:51 <ksf> yep
20:58:02 <ksf> it's the old hashtable, implemented with vector.
20:58:09 <ksf> I'm working on a hopscotch one.
20:58:13 <djahandarie> Nice
20:58:32 <ksf> aka "it's the cache misses, dummies"
20:58:46 <kmc> why reject a package made just for the shootout, when the shootout solutions are custom code anyway?
20:58:57 <djahandarie> kmc, code size?
20:58:58 <kmc> unless there's some idea that the shootout profiles standard library data structures
20:59:05 <kmc> ah, yes, it should be included in the code size
20:59:12 <ksf> then they wouldn't disallow IntMap
21:00:35 <kmc> they disallow IntMap? or you mean they say it's not a hash table
21:00:47 <ksf> http://hpaste.org/41592/bogohopscotch    <- that's how a hopscotch hash looks like before actually doing hopscotching, btw.
21:01:02 <ksf> ...note the interleaving of buckets.
21:01:32 <ksf> first field hopinfo, second key, third the bucket the entry actually hashed to, fourth a value.
21:03:32 <ksf> the next step is to limit the bitmask to 4 bits, which means relocating other elements so that everything still fits within 4 buckets of its hash value.
21:03:43 <ksf> ...which means constant lookup times.
21:04:12 <ksf> worst-case, that is.
21:05:23 <ksf> insert is worst-case linear, where n is tunable (higher n allows for mindbogglingly full tables), modulo the usual resizing problem hashes have.
21:05:43 <Boxo> :r
21:05:48 <Boxo> whoops
21:06:24 <djahandarie> ksf, do any of the other languages use this for that benchmark?
21:07:38 <ksf> what, a modern hashtable?
21:08:19 <djahandarie> Specifically hopscotch hashing
21:08:29 <ksf> it's from 2008, maybe some implementations have it by now.
21:09:52 <ksf> afaik the shootout guys defined hashtable as "something with a hash function and a big array", which hopscotch quite obviously is.
21:16:59 <wolfspaw> how do i represent a empty char? im playing with ghci and it does not accept ''   , i tried other things like '\0' but it prints \0 then
21:18:04 <ddarius> wolfspaw: What would "an empty char" mean?
21:19:09 <kmc> there's no such thing as an empty char
21:19:24 <kmc> though i'm sure there's a variety of unicode characters which have zero width
21:19:29 <wolfspaw> it says "lexical error in string/character literal at character '\''" .  Im playing with some easy challenges and the one im at it i have to get alphabetical characters from an enormous text with things like "@#%@#!@!$"
21:19:52 <kmc> > filter isAlpha "@#%@a#!bc@!d$e"
21:19:53 <lambdabot>   "abcde"
21:20:01 <wolfspaw> so i maded a quick code, a function that takes a char and returns the char if its an elem from a..z , else i want it to return nothing @_@
21:20:23 <kmc> wolfspaw, then you should return (Maybe Char)
21:20:25 <kmc> and use this function:
21:20:27 <kmc> :t catMaybes
21:20:28 <lambdabot> forall a. [Maybe a] -> [a]
21:20:35 <Gracenotes> if you want to return nothing, then picking an ad-hoc special return value is probably a bad idea
21:20:36 <wolfspaw> "nothing"  i mean, is '', because if i return anything it prints tons of spaces
21:20:38 <kmc> or, return a String which is either empty or a single char
21:20:47 <kmc> wolfspaw, '' is not a valid Haskell expression
21:20:52 <wolfspaw> hm, ok @_@
21:20:54 <wolfspaw> thanks
21:20:56 <Gracenotes> I mean, I know it's standard to return -1 in C if something goes wrong, but Haskell's type system lets you do better
21:21:02 <kmc> there's no such thing as an "empty Char", in Haskell or C or Python
21:21:08 <Gracenotes> (or return NULL, or set an error code, ...)
21:21:08 <kmc> you can use an empty string vs. a one-element string
21:21:11 <kmc> or you can use (Maybe Char)
21:21:36 <Gracenotes> well, python's string vs. char distinction... ehhhhh..
21:22:06 <kmc> yeah true
21:22:46 <kmc> but there's no i such that "foobar"[i] == ""
21:23:05 <wolfspaw> kmc i ended using filter, its great and a lot more simple of what i was making xD
21:23:45 <Gracenotes> yep. Haskell has nice elegant ways to do list processing
21:23:47 <ksf> #haskell is the world's leading code compression algorithm.
21:24:10 <kmc> :)
21:24:15 <MoALTz_> i thought that was J
21:24:18 <Gracenotes> ..we just don't make list processing the name of our language. because lists are.. well...
21:24:33 <Gracenotes> not that exciting?
21:24:48 <wolfspaw> xD
21:26:08 <djahandarie> And also not central to anything
21:26:26 <Gracenotes> disregard crude control structures, acquire point-free data manipulation
21:27:34 <kmc> Haskell's data structures are control structures
21:30:15 <Gracenotes> It is better to have 100 functions operate on one data structure than 10 functions on 10 data structures. < epigram in programming #9.
21:39:25 * ddarius wants 100 functions that operate generically over any number of data structures and are built from 10 or less "core" functions.
21:41:09 <beek> sounds like you have a fun night ahead of you.
21:42:00 <kmc> "What can we do with such a well-plated boiler?"
21:43:42 <danharaj> data structures have naturally associated control structures and vice versa
21:49:03 <pygmalion> is there an easy/non-hackish way to remove the [, ], and commas from the "show" of a list?
21:49:04 <guest2425> hello
21:49:06 <ddarius> @hackage lambdabot
21:49:06 <lambdabot> http://hackage.haskell.org/package/lambdabot
21:50:52 <Zao> pygmalion: Consider map show?
21:51:04 <Zao> > map show [9001..9003]
21:51:05 <lambdabot>   ["9001","9002","9003"]
21:51:12 <Zao> > concatMap show [9001..9003]
21:51:13 <lambdabot>   "900190029003"
21:51:24 <pygmalion> Zao: ah brilliant, thanks
21:51:35 <Zao> > intercalate " " . map show $ [9001..9003]
21:51:36 <lambdabot>   "9001 9002 9003"
21:51:49 <pygmalion> :t intercalate
21:51:50 <lambdabot> forall a. [a] -> [[a]] -> [a]
21:51:54 <pygmalion> :t intersperse
21:51:55 <lambdabot> forall a. a -> [a] -> [a]
21:52:03 <Zao> @src intercalate
21:52:03 <lambdabot> intercalate xs xss = concat (intersperse xs xss)
21:52:16 <pygmalion> ah
21:52:21 <kmc> :t intercalate " " . map show
21:52:22 <lambdabot> forall a. (Show a) => [a] -> [Char]
21:53:03 <mtnviewmark> the mnemonic for remembering which is which is that inter**C**alate has to **C**oncat things together
21:54:03 <kmc> > concat$zipWith replicate(fix((0:).scanl(+)1))['a'..]
21:54:04 <lambdabot>   "bcddeeefffffgggggggghhhhhhhhhhhhhiiiiiiiiiiiiiiiiiiiiijjjjjjjjjjjjjjjjjjjj...
21:54:50 <mtnviewmark> is that some sort of Haskeller's football cheer?
21:56:20 <kmc> yep
21:56:30 <lars9> > foldM (\x->[0..x]) 0 [1..5]
21:56:30 <ddarius> @google foobar
21:56:31 <lambdabot>   Couldn't match expected type `b -> m a'
21:56:31 <lambdabot>         against inferred type `[a1]'
21:56:31 <lambdabot> http://www.foobar2000.org/
21:56:32 <lambdabot> Title: foobar2000
21:56:49 <kmc> (\x->[0..x]) ≡ enumFromTo 0
21:56:50 <ddarius> @google "First class patterns"
21:56:50 <lambdabot> No Result Found.
21:57:18 <ddarius> > showHex (ord '"') ""
21:57:19 <lambdabot>   "22"
21:57:41 <kmc> @. elite nixon
21:57:41 <lambdabot> I r3J3C7 7H3 CYnIC41 vi3w +hA+ poLI7iCs Is a diRTY BU$IN3SS.
21:58:00 <lars9> > foldM (\x y->[x..y]) 0 [1..5]
21:58:01 <lambdabot>   [0,1,2,3,4,5,1,2,3,4,5,2,3,4,5,3,4,5,4,5,1,2,3,4,5,2,3,4,5,3,4,5,4,5,2,3,4,...
21:58:23 <kmc> \x y->[x..y] ≡ enumFromTo
21:58:36 <kmc> > foldM enumFromTo 0 [1..5]
21:58:37 <lambdabot>   [0,1,2,3,4,5,1,2,3,4,5,2,3,4,5,3,4,5,4,5,1,2,3,4,5,2,3,4,5,3,4,5,4,5,2,3,4,...
21:58:42 * kmc ponders
21:58:52 <lars9> kmc: awesome
21:59:03 <kmc> > length $ foldM enumFromTo 0 [1..5]
21:59:04 <lambdabot>   132
21:59:08 <kmc> :t foldM
21:59:09 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:59:35 <kmc> . o O ( (a -> b -> [a]) -> a -> [b] -> [a] )
22:00:16 <guest2425> Hello I am getting this error message can you guys help me out http://pastebin.com/DhXJqAg2
22:06:21 <guest2425> :t data List a = Empty |  a :-: List a deriving (Read, Eq, Ord) 	 
22:06:22 <lambdabot> parse error on input `data'
22:07:57 <pygmalion> there has to be a better way to insert spacing for aesthetics than this? http://hpaste.org/41593/better_way_to_insert_spacing
22:08:03 <guest2425> Hello I am getting this error message can you guys help me out http://pastebin.com/DhXJqAg2
22:08:17 <kmc> pygmalion, long line is long
22:08:50 <kmc> pygmalion, you can use "where" attached to your definition
22:09:06 <kmc> > take 32 ' '
22:09:06 <Cale> pygmalion: use concat, split each element of the list to concat onto separate lines
22:09:06 <lambdabot>   Couldn't match expected type `[a]'
22:09:07 <lambdabot>         against inferred type `GHC.Types...
22:09:07 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
22:09:11 <kmc> errrr
22:09:13 <kmc> > replicate 32 ' '
22:09:14 <lambdabot>   "                                "
22:10:02 <pygmalion> ah yes kmc. Cale, not sure what you mean?
22:10:02 <kmc> pygmalion, there's also Text.Printf
22:10:30 <pygmalion> i figured i'd write it all out and cut it up/ abstract it with where after i had it right
22:10:33 <kmc> pygmalion, will have example
22:10:35 <kmc> ah
22:10:47 <kmc> instead of writing a ++ b ++ c ++ ....
22:10:50 <kmc> write concat [a, b, c]
22:11:24 <pygmalion> ah i see... slick. will do. thanks.
22:11:58 <kmc> there's also Text.Printf
22:13:01 <kmc> also you can abstract out (intercalate " | " . map show)
22:13:06 <supe> hi
22:13:25 <kmc> hi supe
22:13:31 <supe> I hear that Haskell 2010 is quite different to the older versions.
22:13:37 <kmc> supe, it's not
22:13:48 <kmc> not very different from Haskell 98, anyway
22:13:57 <kmc> supe, http://www.haskell.org/pipermail/haskell/2009-November/021750.html
22:14:05 <kmc> mostly these extensions have been supported by GHC for many years
22:14:08 <supe> But I heard you can't have the n-plus-k-patterns anymore
22:14:11 <Cale> pygmalion: http://hpaste.org/paste/41593/a_little_nicer#p41595
22:14:17 <kmc> and they're conservative syntactic things mostly
22:14:25 <kmc> supe, that's true... GHC still supports them though
22:14:30 <supe> GHC?
22:14:37 <kmc> GHC is the haskell compiler that nearly everyone uses
22:14:44 <supe> Okay
22:14:47 <kmc> it supports many extensions above and beyond the standard Haskell language
22:14:58 <guest2425> Cale: Hi I am getting this error message can you help me out http://pastebin.com/DhXJqAg2
22:14:59 <kmc> in Haskell 2010 mode (the default in GHC 7) it will support n+k patterns using the NPlusKPatterns extension
22:15:05 <Cale> n+k patterns were never a big deal :)
22:15:20 <kmc> supe, GHC also supports ViewPatterns which in some sense generalize n+k patterns
22:15:27 <kmc> > let f (succ -> n) = n in f 4
22:15:28 <lambdabot>   5
22:15:29 <pygmalion> Cale: ooh. much nicer! thanks!
22:15:41 <pygmalion> :r
22:15:48 <pygmalion> ah sorry
22:16:01 <supe> I was told last-night from a fellow student just completing his CS degree, that I should learn 3 languages. A low-level language like C, a high-level language like Java or C#, and a mathematical language like Haskell. I currently know Processing and C++. Thoughts?
22:16:14 <kmc> Java is not a high-level language
22:16:19 <Cale> guest2425: What's the type of null?
22:16:22 <kmc> and the "Haskell is mathematical" thing is overblown
22:16:23 <supe> kmc: I'm only quoting
22:16:28 <kmc> sure
22:16:31 <guest2425> Cale: Boolean
22:16:34 <Cale> guest2425: oh?
22:16:37 <guest2425> :t null
22:16:38 <lambdabot> forall a. [a] -> Bool
22:16:38 <kmc> supe, you should definitely learn C and Haskell
22:16:40 <Cale> guest2425: Is it True or False?
22:16:42 <kmc> probably Scheme or Clojure as well
22:16:50 <kmc> Java is unfortunately quite useful to get a job
22:16:50 <Cale> guest2425: Are you using the null from the Prelude?
22:16:56 <kmc> C# is like a better Java except with Microsoft lock-in
22:16:58 <mlh> depends how deeply, but I guess you might want to havea look at lisp or scheme
22:17:02 <guest2425> Cale: yes
22:17:12 <supe> kmc: I'm just finishing my first year of an IT Degree at Uni. Which 3 languages should I try and be proficient in for the next 2-3 years?
22:17:20 <kmc> what are your goals supe?
22:17:29 <guest2425> Cale: for me I am suppose to said (\xs -> Empty) 
22:17:36 <mlh> maybe prolog or forth to expand the mind, not that they're useful for most people
22:17:40 <kmc> get a job? understand the machine? understand computation in the abstract?
22:17:55 <supe> kmc: To be able to write efficiently, no matter which language I use
22:17:59 <Cale> err, is this all the same error message from GHC?
22:18:15 <Cale> Or have you chopped it up and pasted together two different error messages?
22:18:16 <mlh> efficient or fast :-) and efficient for whom or what
22:18:39 <kmc> supe, C, Haskell, Scheme, Python
22:18:47 <kmc> will give you a pretty good variety of ideas
22:18:50 <kmc> plus practical skills
22:19:12 <kmc> you could substitute Clojure for Scheme; it's arguably more practical and lets you use the Java platform without the terrible Java language
22:19:27 <kmc> but Scheme has this excellent textbook SICP, which is free online
22:19:36 <kmc> i recently learned that MIT no longer teaches a course using SICP :/
22:19:40 <pygmalion> Cale or kmc: what sort of conditional statements can i use within a where clause? 
22:19:47 <Cale> kmc: I think they still do.
22:19:48 <kmc> pygmalion, ?
22:19:56 <kmc> Cale, recent MIT CS grad told me no today
22:20:02 <Cale> kmc: It's just no longer the first course?
22:20:02 <kmc> except there's "zombie 6.001" during IAP
22:20:07 <kmc> taught by former TAs
22:20:18 <kmc> pygmalion, i think "statement" is probably the wrong word
22:20:18 <Cale> I thought they only changed the course number, huh.
22:20:27 <kmc> Cale, Caltech did that.  CS 1 → CS 4
22:20:36 <kmc> CS 1 is now the fun useful Python class for everyone
22:20:45 <kmc> CS 4 is like the old CS 1 but harder, for CS majors and interested folk only
22:21:03 <kmc> pygmalion, what goes in a "where" clause is a sequence of declarations, like you'd have at top level or in "let"
22:21:10 <kmc> so stuff like "f n = g (n+1)"
22:21:13 <ksf> python!
22:21:14 <pygmalion> kmc: yeah certainly. what i'm trying to do is determine which row is displayed on top based on the current player.
22:21:16 <kmc> the right hand side of that = is an expression
22:21:22 <ksf> they could equally well use scratch for that purpose.
22:21:24 <kmc> and you can use "if" and "case" in an expression
22:21:28 <pygmalion> kmc: i just wrote all the io for this so i'm stuck in monad land and sort of confused
22:21:30 <pygmalion> hah
22:21:33 <supe> kmc: C, Haskell, Clojure and Python... how about Assembly and SCALA, what are your thoughts about learning those?
22:21:52 <kmc> supe, learn assembly after C, learn how the compiler produces assembly from your C
22:22:01 <ksf> scala might be useful if you need to deal with the jvm
22:22:05 <kmc> but so is clojure
22:22:21 <kmc> assembly is weird, there's not much to the language itself, it's so low level
22:22:21 <ksf> well but scala is more haskellish.
22:22:32 <kmc> learning assembly is about learning how to make do with little abstraction
22:22:36 <ksf> assembly is great, you can do all kinds of punk with it.
22:22:52 <ksf> yep. definitely get a good assembler. like nasm.
22:23:07 <ksf> ...don't go for non-turing complete macro systems.
22:23:15 <supe> Such as MASM?
22:23:32 <ddarius> Assembly is fun.
22:23:32 <ksf> I remember masm/tasm, and compared to nasm, they're just pain.
22:23:41 <ddarius> Though CPS and continuations kind of ruin it.
22:23:50 <supe> So I should learn languages in this order? - 1) C, 2) Assembly, 3) Haskell, 4) Clojure 5) Python - and can Haskell be replaced with SCALA as the 3rd language I learn?
22:24:03 <jmcarthur> my recommendation: don't just pick a few languages and go. pick one language, learn it, then pick another, learn it, then pick another, etc. you'll end up doing that anyway, and you'll be happier knowing that in the first place
22:24:28 <mtnviewmark> I've only flipped through it but may I suggest http://www.amazon.com/Elements-Computing-Systems-Building-Principles/dp/026214087X
22:24:29 <djahandarie> Replace Clojure with Scala, not Haskell
22:24:43 <jmcarthur> so you should start with the one you think seems the most appealing to you at first, then you are allowed to change your mind as you go
22:24:50 * djahandarie recommends Haskell
22:25:01 <mtnviewmark> It goes through a computer from one end to the other, touching on electronics, logic, register systems, assembly, C, and finally higher level langauges.
22:25:04 <djahandarie> If you don't know any languages yet, I'd definitely recommend Haskell
22:25:09 * ksf looks for some telling nasm source.
22:25:13 <ksf> there.
22:25:14 <supe> jmcarthur: Well I'll see what's on the agenda for next year, in terms of class
22:25:16 <ksf>     writef "Displaying in a %dx%d area%n", [screenWidth], [screenHeight]
22:25:22 <supe> djahandarie: I know C++ :P
22:25:33 <jmcarthur> supe: my point is that i don't like agendas, i think ;)
22:25:42 <supe> ;)
22:25:47 <ksf> I had to write all the formatting in plain asm, but that's what you end up with.
22:26:04 <supe> What about Higher-Level Assembly?
22:27:27 <kmc> supe, Python is the easiest of those
22:27:37 <kmc> i'd start there, you'll get a lot of practical skills quickly
22:27:37 <danharaj> burn
22:27:53 <kmc> then do C and Haskell in either order or concurrently
22:27:55 <ksf> kmc, supe, http://hpaste.org/41596/assembly
22:28:01 <djahandarie> 意骨ティン吐けを鵜べ〒ぇえあしえ
22:28:03 <djahandarie> Gah
22:28:08 <djahandarie> Stupid IME
22:28:08 <supe> kmc: Okay, to #python then, I'll enquire as to the best tutorial/book
22:28:11 <kmc> ok
22:28:14 <kmc> enjoy good luck etc.
22:28:19 <djahandarie> Yep enjoy
22:28:24 <guest2425> Cale: Are you there?
22:28:32 <ksf> all that proc/args/colals/if/writef/ stuff is macro-powered.
22:28:32 * ddarius thinkshe can get @google a bit more reliable.
22:28:54 <djahandarie> think she or thinks he?!?!?! We'll never know
22:29:13 <Cale> guest2425: Yes. I think something strange has happened when you copy/pasted that error message. It looks like two error messages that have been spliced together.
22:29:19 <ddarius> It was actually thin kshe
22:29:24 <djahandarie> A bit of a meta-comment, I really think Haskell would be an amazing learning language given the right sort of tutorial
22:29:35 <kmc> djahandarie, yes, i've thought about writing this tutorial
22:29:41 <djahandarie> Me too!
22:29:47 <mtnviewmark> well, now that you mention it.... 
22:29:48 <kmc> i guess Haskell School of Expression is supposed to work that way?
22:29:49 <kmc> i never read it
22:29:55 <mlh> it's not just the tutorial, its the environment/ide
22:30:17 <mtnviewmark> I'm working on a tutorial aimed at early programmers
22:30:19 <djahandarie> kmc, that teaches functional programming
22:30:21 <mlh> you'd want to be more constraining and more helpful than what you get right now
22:30:23 <mtnviewmark> and people with only minimal programming
22:30:45 <djahandarie> And honestly
22:30:45 <mtnviewmark> it starts up as a webserver with an integrated development environment
22:30:50 <guest2425> Cale: I can use null to check if the list is empty correct?
22:30:53 <mtnviewmark> and lets you code web pages quickly in haskell
22:30:58 <djahandarie> A tutorial like this would need to be so crazy different from everything else
22:31:04 <djahandarie> Especially in terms of lingo
22:31:04 <mtnviewmark> it has an integrated tutorial
22:31:09 <Cale> guest2425: You can use it to check if a proper Haskell list is empty.
22:31:10 <ksf> oh, call is a macro, too.
22:31:16 <Cale> guest2425: But not a list of your list type.
22:31:17 * ddarius used QBASIC's environment as an editor, not even a glorified editor.  Other than that every language I've learned, except C#, has been with a plain text-editor.
22:31:21 <ksf> pushing arguments by hand is so 50's.
22:31:45 <guest2425> Cale: ok So In that case Empty should be the correct way for me to check
22:31:53 <Cale> guest2425: ?
22:31:58 <mtnviewmark> I think it could be easily tailored for first programmmers to
22:31:59 <mtnviewmark> too
22:32:12 <ddarius> ksf: If a call macro works then you aren't using registers enough!
22:32:16 <Cale> guest2425: Empty is a value of type List a
22:32:29 <guest2425> Cale: termination Condition  is when the list is empty
22:32:59 <Cale> guest2425: So you want to write a function which takes a value of type List a, and determines if it is Empty or not.
22:33:06 <ksf> ddarius, yep. I decided on the vanilla C calling convention.
22:33:22 <guest2425> Cale: yes that is my termination condition
22:33:25 <ksf> also, when coding assembly you don't want your registers to be spilled.
22:33:48 <Cale> guest2425: Empty is not an example of such a function.
22:34:25 <guest2425> Cale: What will be a check for Empty list 
22:34:45 <mtnviewmark> I'm assuming that guest2425, you have something like     type List a = Empty | Cons a (List a)
22:35:14 <mtnviewmark> is that right?
22:35:18 <guest2425> mtnviewmark: No 
22:35:26 <guest2425> mtnviewmark: data List a = Empty |  a :-: List a deriving (Read, Eq, Ord)  
22:35:55 <motolep> what does the "cons" in lists stand for? "construct"?
22:36:09 <mtnviewmark> ah, yes, my bad  s/type/data/ in my earlier line
22:36:11 <Cale> motolep: yeah
22:36:14 <mtnviewmark> and then, yes, basically the same thing
22:36:21 <Cale> motolep: It's traditional :)
22:36:50 <motolep> Cale: the very first constructor :)
22:36:55 <Cale> guest2425: myNull Empty = True; myNull (x :-: xs) = False
22:37:32 <ddarius> Getting lambdabot takes a bit.
22:39:12 <guest2425> Cale: myNull Empty = True :  myNull (x :-: xs) = False
22:39:53 <mtnviewmark> well, if we want to be traditional:   data List a = Nil | Cons { car :: a, cdr :: List a }
22:39:59 <mtnviewmark> :-)
22:40:35 <darvin> hello
22:40:59 <mtnviewmark> guest2425: sometimes one might choose to write that as    myNull Empty = True; myNull _ = False
22:41:12 <motolep> mtnviewmark: don't forget cdaddr :)
22:41:26 <ksf> that's not traditional. you can't do the traditional cadr-thing in haskell.
22:41:40 <mtnviewmark> in some circumstances the _ meaning "and everything else" is more clear, in others, enumerating the other constructors is more clear
22:41:44 <ksf> lisp isn't about lists but tuples.
22:41:52 <darvin> i have question about ghci interpreter: how to declare type of function? where i can found documentation about differences beetwen ghci interpreter and haskell compiler?
22:42:00 <mtnviewmark> cadr = car . cdr
22:42:08 <shachaf> darvin: let f :: ...; f = ...
22:42:08 <ksf> ghci is basically a do block.
22:42:13 <ddarius> :t let car = head; cdr = tail in cdr . car . cdr . cdr 
22:42:14 <lambdabot> forall a. [[a]] -> [a]
22:42:24 <ksf> mtnviewmark, cdar?
22:42:27 <soiamso> darvin:  :{ .........  }:  
22:42:33 <motolep> ksf: why aren't haskell lists tuples?
22:42:58 <ksf> because then they wouldn't be monomorphic, couldn't be infinite etc.
22:43:06 <mtnviewmark> :t let car = head; cdr = tail; cdar = cdr . car in cdar
22:43:07 <lambdabot> forall a. [[a]] -> [a]
22:43:12 <darvin> shachaf: thanks, of course! ))
22:43:21 <guest2425> ok  thanks 
22:43:30 <guest2425> Cale: thank you
22:43:53 <mtnviewmark> darvin: you can write the type as a normal annotation on a let binding in ghci
22:43:56 <guest2425> mtnviewmar: Thank you
22:44:21 <mtnviewmark> let f a = [a + 7] :: Int -> [Int]
22:44:38 * ksf can't believe that his code works, it's so much shorter than the C++ code.
22:45:04 <ksf> ...and the c++ source doesn't even include printing stuff etc.
22:46:10 <ksf> http://hpaste.org/41597/hopscotch   <-- can anyone find any bugs?
22:47:04 <darvin> mtnviewmark: got it thanks
22:47:18 <mtnviewmark> ksf: In one project, where I implemented the same library in C++ and in Haskell
22:47:31 <mtnviewmark> the line counts were C++: 9700, Haskell: 2750
22:47:48 <ddarius> Cale: Want a small, completely untested, not even compiled patch that slightly cleans up Search.hs and should make it work better?
22:47:52 <motolep> ksf: magic = 0xdeadbeef... everyone knows the value of magic is 0xfeedface
22:47:56 <mtnviewmark> The Haskell one included a full verifier and pretty printer as well, both of which the C++ one lacked
22:48:14 <Cale> ddarius: Search.hs?
22:48:23 <ksf> motolep, I stole that one from Data.HashTable.
22:48:24 <Cale> ddarius: Oh, in lambdabot?
22:48:25 <ddarius> Cale: The Search plugin that provides @google.
22:48:28 <mtnviewmark> these were production quality libraries, too
22:48:37 <ksf> advice on hash functions is welcome.
22:48:41 <Cale> ah, sure...
22:48:50 <Cale> I have a bunch of patches that I have to remember to apply...
22:48:59 <ksf> ...I think I broke the golden ratio by going from Int to Word
22:49:01 <Cale> Really you should send it to gwern probably :)
22:49:31 <guest2425> Cale: why is myNull is showing not in scope
22:50:08 <guest2425> Cale: I copy myNull to my file
22:50:56 <ksf> guest2425, if you compile with --make and after that start the thing with ghci functions may be missing because they've been optimised away.
22:51:03 <ksf> just delete *.o, in that case.
22:51:54 <guest2425> ksf: no I dont compile with --make
22:52:04 <mtnviewmark> did you :reload in ghci?
22:52:19 <guest2425> yes
22:52:22 <mtnviewmark> (we're guessing here - since we don't know how you run this)
22:52:43 <guest2425> Yes I understnad
22:52:58 <mtnviewmark> paste the file for us to look at
22:53:22 <guest2425> mtnviewmark: this is what I do, I create a file with extension hs I put all functions in there 
22:53:52 <guest2425> mtnviewmark: and then I click in the file using WinGHCi
22:54:11 <mtnviewmark> ah - I don't know WinGHCi at all...
22:55:30 <guest2425> mtnviewmark: nevermind
22:55:36 <guest2425> mtnviewmark: I got it
23:03:45 <pygmalion> i'm having a weird syntax issue while trying to abstract some repeated tasks into functions http://hpaste.org/41599/huh
23:05:24 <RayNbow`TU> pygmalion: monomorphism restriction
23:05:46 <RayNbow`TU> http://www.haskell.org/haskellwiki/Monomorphism_restriction
23:06:15 <RayNbow`TU> the solution is either to explicitly give your aS function a type
23:06:21 <RayNbow`TU> or use the following definition instead:
23:06:36 <RayNbow`TU> aS xs = intercalate " | " . map show $ xs
23:06:46 <ddarius> (or just turn off the monomorphism restriction)
23:07:05 <pygmalion> RayNbow`TU: ah so if i don't eta reduce i won't have the problem
23:08:33 <kmc> right.  MMR only applies to definitions of the form "f = ..." not "f x = ..."
23:08:38 <ksf> the restriction is of questionable value, especially when the functions are so short they'd be inlined+specialised, anyway.
23:08:38 <RayNbow`TU> right, or you could also use ddarius' suggestion
23:08:38 <kmc> it's a syntactic criterion
23:08:49 <kmc> or give it a type signature
23:08:53 <kmc> three fixes
23:09:14 <pygmalion> cool! good to know. learn something new everyday. what is the perceived benefit of this monomorphism restriction?
23:09:30 <ksf> none.
23:09:35 <ksf> but that's just mnsho.
23:09:35 <kmc> i can explain the rationale
23:09:39 <kmc> > let x = 2 + 2 in (x :: Double, x :: Int)
23:09:40 <lambdabot>   (4.0,4)
23:09:57 <kmc> pygmalion, you might expect on syntactic grounds that the computation 2+2 is performed once
23:10:00 <kmc> after all it's let-bound
23:10:06 <kmc> but x gets the inferred type (Num a) => a
23:10:26 <ksf> ahhh but not in ghc7 with monomorphic lets
23:10:40 <kmc> and your Haskell implementation is free to perform that computation twice
23:10:54 <kmc> because it's free to implement type classes by passing in a record of methods
23:10:58 <kmc> which effectively makes x a function
23:11:14 <ddarius> It's free to perform that computation twice, just cuz.
23:11:25 <kmc> well yeah because the report says little about operational details
23:11:28 <kmc> but anyway
23:11:33 <pygmalion> kmc: ah okay i see. thanks. very clear explanation.
23:11:46 <kmc> it's an attempt to make performance more syntactically transparent
23:12:07 <kmc> which i think is ill-advised, not that it's a bad goal in principle, but that performance reasoning for Haskell beginners is already such a lost cause
23:12:19 <kmc> and so you shouldn't also confuse them with this ugly special case in the type system
23:14:39 <kmc> yeah in GHC 7 let bindings are monomorphic, for a different reason, but only when you've turned on GADTs or TypeFamilies
23:15:00 <guest2425> mtnviewmark: I am getting another error message 
23:15:20 <kmc> (or explicitly turned on MonoLocalBinds of course)
23:15:53 <kmc> and that applies to let bindings regardless of which decl syntax you use, but (like MMR) can be overridden with a type sig
23:16:32 <guest2425> I am getting this error message please help http://pastebin.com/fQDQX7jR
23:16:41 <guest2425> mtnviewmark: I am getting another error message http://pastebin.com/fQDQX7jR 
23:17:11 <guest2425> Cale: I am getting this error message http://pastebin.com/fQDQX7jR
23:17:21 <kmc> guest2425, don't spam
23:17:29 <guest2425> kmc: hahaha
23:17:46 <kmc> guest2425, and it's rude to pick people who are already not helping you and highlight them
23:18:17 <kmc> Cale, did you forward my λb patch to gwern, or should i?
23:18:58 <ksf> guest2425, start adding type signatures to pin it down
23:19:27 <Cale> kmc: I forwarded it :)
23:19:46 <kmc> cool, thanks
23:19:55 <ksf> anyway, :-: takes two arguments but wayAheadFn is called with one.
23:20:20 <ksf> ...which is exactly whet the type error says.
23:20:55 <guest2425> ksf: Couldn't match expected type `List t'
23:21:08 <guest2425> ksf:  against inferred type `List (List t) -> List (List t)'
23:22:39 <ksf> exactly. it takes one argument too much.
23:23:43 <guest2425> ksf: way ahead function is suppose to all values in a list
23:25:38 <ksf> ...I suggest you work through lyah until you're more comfortable with haskell
23:26:15 <kmc> which involves actually doing small exercises
23:26:28 <kmc> to learn something, you need to attempt a task which is only a little beyond your current ability
23:27:00 <kmc> over and over
23:28:02 <guest2425> kmc: you are talking to me?
23:28:06 <kmc> yes
23:29:09 <guest2425> kmc: ok I am doing HW so I am reading the book, but the book dont have any high high high high level functions so what would you recomemd me to read to do my HW
23:29:30 <kmc> read the book, more carefully, do more exercises
23:30:05 <kmc> if you google "haskell exercises" you will find a ton of stuff
23:30:08 <kmc> not all of it is useful of course
23:30:19 <kmc> i like the labs at http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
23:33:04 <kmc> you could also bug your professor, TAs, etc.
23:33:07 <kmc> other students in the class
23:33:36 <kmc> it seems like you're in over your head
23:34:12 <guest2425> kmc: what this means it seems like you're in over your head
23:34:22 <kmc> like you're attacking a problem which is too hard
23:34:28 <kmc> like you need to try something easier first
23:34:37 <guest2425> kmc: oh ok
23:34:38 <kmc> and i don't mean solving it by guessing
23:34:43 <kmc> but by really understanding the code
23:34:51 <kmc> learn how to use types to guide your programming in a systematic way
23:35:39 <kmc> this channel is great for specific questions.  if your code is a total guess and you can't explain why it should work, there's not a lot we can do
23:37:06 <kmc> guest2425, http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html also has a ton of links at the bottom
23:37:20 <guest2425> kmc: so thats mean dont come to the channel anymore
23:37:28 <kmc> no i didn't say that
23:37:41 <kmc> but you are kind of using up good will
23:38:06 <kmc> tackle a problem that's at your skill level, and think systematically
23:38:13 <kmc> when you get stuck, explain your thought process
23:38:36 <ksf> http://www.c2.com/cgi/wiki?RubberDucking
23:38:38 * ksf ducks
23:38:51 <kmc> guest2425, i get that you're doing homework... unfortunately this might be one of those cases where school gets in the way of learning
23:39:54 <guest2425> kmc: ok I will read this link http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
23:40:02 <Cale> guest2425: It really seems (at least to us) like you're just guessing randomly at a lot of things. That's just not going to work when you're programming. Rather than fighting with error messages from the compiler, you might actually step away from the computer and try to write your complete function on paper first, and get it into a state where you're reasonably sure it'll work before typing it in.
23:40:44 <guest2425> Cale: ok
23:40:50 <guest2425> Cale: Thank you
23:42:51 <guest2425> Cale: I get worry because I have a due date in the homework which is due tonite, so i feel Desperate and running out time, so I don’t know what to do 
23:52:28 <guest2425> kmc: After I am done reading all the stuff in the link I will be able to do my HW just like you guys by looking at it
23:53:46 <guest2425> TryingToLearnHas: hello same boat
