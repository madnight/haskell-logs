00:00:12 <Xilon> You can ask the mailing list to orphan it (I'm assuming this is AUR)
00:00:28 <Xilon> Gah wrong channel
00:00:34 <A1kmm> the package involved is typehash
00:01:18 <gienah> I guess with ghc7 I have to compile everything with use flags -doc as dev-haskell/haddock-2.8.1 does not seem to work with ghc7?
00:01:30 <gienah> sorry wrong window
00:11:37 <ddarius> Removing relevant context for entertainment value: "It's main drawback is that it is not computable."
00:11:43 <ddarius> -'
00:12:41 <Veinor> haha
00:19:46 <lars9> Cale: are you here?
00:23:30 <lars9> pastorn: i found the bug, i used ns' instead of ns'' by mistake in line 30, otherwise it will work...
00:28:17 <ddarius> I recommend using the names of women rather than prims to enumerate auxillary variables: x, xKate, xHitomi, xNatasha, xZheng, xMaria
00:29:36 <lars9> ddarius: lol
00:29:55 <lars9> ddarius: is Zheng women name?
00:30:25 <pastorn> i'm having trouble with GHC7 + cabal-install
00:30:49 <pastorn> i installed ghc with --prefix=/home/me/.ghc/
00:31:17 <pastorn> but now when i run $ sh bootstrap.sh # for cabal-install i get this_
00:31:21 <pastorn> Setup: At least the following dependencies are missing:
00:31:23 <pastorn> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
00:33:36 <Lissomort> How to import the extralibs from lib\extralibs directory into project, using Haskell Platfrom?
00:33:47 <ddarius> "When three very different definitions (or properties) turn out to define the same object, then this is usually taken in Mathematics to mean that this object is objectively important."
00:33:56 <Axman6> preflex: seen conal
00:33:56 <preflex>  conal was last seen on #haskell 4 days, 8 hours, 44 minutes and 44 seconds ago, saying: the pages i get pointed to then point offsite.
00:35:29 <Lissomort> How to import the extralibs from lib\extralibs directory into project, using Haskell Platfrom?
00:36:10 <ddarius> "Also M divided by the uniform measure 2^{-\ell(x)} is the maximal semicomputable supermartingale."
00:37:13 <mjrosenb> i have written a line of haskell
00:37:18 <mjrosenb> and i have no clue how it works
00:37:23 <mjrosenb>  let l =  fix ((1:) . concatMap (\x ->  [x,1-x])); in fix $ (2:) . map (\n -> ((findIndices (take n l`isPrefixOf`) $ tails $ l)!!2)`div`3)
00:37:31 <pastorn> holy shit
00:38:01 <mjrosenb> as far as i can tell
00:38:04 <basti_> i don't have a clue either ;)
00:38:08 <mjrosenb> there is no good reason for it to work
00:38:19 <basti_> what does it do?
00:38:26 <mjrosenb> also, i wonder if it would be nicer without the let
00:38:37 <lars9> @pl fix ((1:) . concatMap (\x ->  [x,1-x])); in fix $ (2:) . map (\n -> ((findIndices (take n l`isPrefixOf`) $ tails $  l)!!2)`div`3)
00:38:37 <lambdabot> (line 1, column 40):
00:38:37 <lambdabot> unexpected ";"
00:38:37 <lambdabot> expecting variable, "(", operator or end of input
00:38:52 <mjrosenb> > take 10 $ let l =  fix ((1:) . concatMap (\x ->  [x,1-x])); in fix $ (2:) . map (\n -> ((findIndices (take n l`isPrefixOf`) $ tails $ l)!!2)`div`3)
00:38:53 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024]
00:39:04 <lars9> @pl fix $ (2:) . map (\n -> ((findIndices (take n l`isPrefixOf`) $ tails $  l)!!2)`div`3)
00:39:04 <lambdabot> fix ((2 :) . map ((`div` 3) . (!! 2) . ($ tails l) . findIndices . isPrefixOf . flip take l))
00:39:08 <lars9> wow
00:39:14 <lars9> you are close to @pl 
00:39:34 * ddarius prefers @pls output.
00:39:38 <Lissomort> How to import the extralibs from lib\extralibs directory into project, using Haskell Platfrom?
00:39:40 <lars9> @pl \f g u z w g -> s s g w f z w
00:39:41 <lambdabot> const . const . flip flip id . (liftM2 flip .) . flip . (flip .) . flip (flip . flip (s s))
00:40:32 <mjrosenb> but pl did not remove the let.
00:43:02 <ddarius> Yes!  People often want educators to teach from simplest examples first.  We should require them to teach in order of algorithmic complexity!
00:43:16 <pastorn> mjrosenb: http://hpaste.org/41897/readable
00:44:45 <mjrosenb> pastorn: i know where the numbers are coming from, i just don't know why it is getting those numbers per se.
00:48:42 <remy_o> (findIndices (take n l`isPrefixOf`) $ tails $ l) : this looks up for where l repeats itself
00:49:08 <lars9> in which blog can we paste some source code?
00:50:47 <mjrosenb> remy_o: yes, it find the second place where it repeats itself
00:51:48 <mjrosenb> remy_o: and the nth number in the list is the second time the first n-1st numbers in the sequence repeat themselves
00:54:18 <remy_o> so you want to understand this fix ((1:) . concatMap (\x ->  [x,1-x]))
00:54:37 <mjrosenb> remy_o: i've seen the sequence
00:54:46 <mjrosenb> looks sort of like random gibberish to me
00:54:56 <mjrosenb> but obviously has some neat patterns
00:55:13 <remy_o> i guess the n-th term is the sum of binary digits of n mod 2
00:55:30 <remy_o> http://en.wikipedia.org/wiki/Gray_code
00:57:39 <remy_o> patterns in the Gray code repeats every 2^n
01:00:02 <augur> anyone have any cool ideas they'd like to spread?
01:00:10 <remy_o> mjrosenb: are you still here ? 
01:01:05 <mjrosenb> remy_o: yeah.
01:01:31 <mjrosenb> remy_o: i suspect what i am looking for is a formal proof.
01:02:20 <mjrosenb> there is also this: et l =  fix ((1:) . concatMap (\x ->  max [x,1-x] [1-x])); in fix $ (2:) . map (\n -> ((findIndices (take n l`isPrefixOf`) $ tails $ l)!!2))
01:02:26 <mjrosenb> err
01:02:27 <remy_o> mjrosenb: the statement is "l !! n is the sum of binary digits of (n+1) mod 2"
01:02:38 <lars9> do you haskellers follow each other on twitter? i want to follow some, who want to share?
01:02:41 <mjrosenb> let l =  fix ((1:) . concatMap (\x ->  max [x,1-x] [1-x])); in fix $ (2:) . map (\n -> ((findIndices (take n l`isPrefixOf`) $ tails $ l)!!2))
01:02:43 <remy_o> mjrosenb: since l is defined as a fixed point, you prove that by induction
01:04:00 <remy_o> http://en.wikipedia.org/wiki/Thue%E2%80%93Morse_sequence
01:04:56 <remy_o> mjrosenb: oh, fooling around on Wikipedia gives this : http://en.wikipedia.org/wiki/Lindenmayer_system
01:05:28 <remy_o> explains everything you need
01:05:58 <lars9> ok, the complete code for BFS in Directed Infinite Graph: http://hpaste.org/41898/bfs_in_directed_infinite_graph
01:08:09 <mjrosenb> remy_o: iirc, this is not actually an l-system.
01:10:35 <ddarius> augur: Have you read all the works of E. T. Jaynes and David Hestenes?
01:11:16 <augur> no what
01:32:52 <lars9> @hoogle iterateM
01:32:53 <lambdabot> No results found
01:32:58 <pastorn> is it just me or does this make no sense?
01:33:00 <pastorn> Setup: At least the following dependencies are missing:
01:33:02 <pastorn> base >=4 && <3 && >=1 && <5, filepath >=1 && <1.2
01:33:30 <pastorn> the <3 part
01:33:43 <pastorn> doesn't that make it impossible for this to build?
01:33:52 <lars9> pastorn: that's a heart
01:34:39 <panopticon> you need to show more love if you want it to build
01:40:12 <panopticon> i have to ask, as someone who has just started learning haskell, but has previous exp with programming (in c, python ..), is "learn you a haskell" a good place to start or not?
01:40:26 <panopticon> and if not, what should i use as a learning tool?
01:40:28 <mjrosenb> panopticon: i have heard good things about it in general.
01:41:05 <mathijs> Hi all, I would like to fork a process to run a IO action. I know about forkProcess, which is what I want, but that is broken when running with +RTS -N. Also, I would like to run the IO action on a different host (same architecture and libs installed)...
01:42:52 <mathijs> since the IO action I want to run, is somewhere in my program/lib, I guess it must be possible to create some very basic Main app, link it to the object(lib/program, .o / .so) and pass it some strange reference.
01:44:23 <mjrosenb> mathijs: sounds like you want an rpc library.
01:44:35 <mathijs> so what I'm after is a function IO a -> BinRefThing. where BinRefThing is something that allows a program that's linked to the same objects(or loads the same shared libs) to call the IO a action
01:46:25 <mathijs> mjrosenb: nah, not fully. I want to build this RPC layer myself. Whenever I call "specialFork myAction", it will need to start a new process, open some connection to the current process, and run code.
01:47:09 <mathijs> so basically I can start this new process and connect it to the current one for rpc. Now all I need is a way to tell the new process what code to run. 
01:47:37 <nooodl> does putStr not immediately print results or something?
01:48:14 <Xilon> Probably like with most print functions, it gets buffered
01:48:32 <nooodl> http://hpaste.org/41899/celsius
01:48:58 <nooodl> this reads a number then prints "Celsius: Fahrenheit: ..." :(
01:49:03 <c_wraith> yeah, IO is line-buffered by default
01:49:12 <c_wraith> that means that until it gets a newline, it won't print anything.
01:49:27 <c_wraith> Either flush stdout, change the buffering mode, or add a newline
01:49:47 <nooodl> i'm probably better off flushing stdout
01:50:15 <pww> so "shit" won't get flushed (because it doesn't have a \n)?
01:50:22 <pww> until you flush the stream?
01:50:30 <c_wraith> in line-buffered mode, yes
01:53:04 <nooodl> adding "hFlush stdout" worked
01:57:25 <nooodl> while we're at it, does the result look like a good haskell program: http://hpaste.org/41900/celsius
02:03:42 <McManiaC> whats the policy on haskell reddit? what do you have to do to get your link up there? are the moderators that picky or are they just slow?
02:09:33 <augur> McManiaC: how do you mean
02:10:29 <McManiaC> I sent two links, the first on 2 days ago, the second yesterday
02:10:38 <McManiaC> I see a couple of other links accepted in the mean time
02:12:20 <augur> yours probably just fell beyond the fold
02:12:29 <augur> theres no "acceptance" process afaik
02:13:22 <McManiaC> "fold"?
02:15:26 <dancor> how do you do things like sum all divisors of large numbers at gmp speed?  i don't see a gmp binding on http://hackage.haskell.org/packages/archive/pkg-list.html#cat:math
02:16:14 <Twey> GHC numbers use GMP by default; I assume that you should be able to just do the operation on a number type
02:16:29 <Twey> Maybe with some careful application of strictness
02:16:45 <McManiaC> augur: should I resend them? or just be patient?
02:17:01 <paolino1> integer-gmp is mentioned in depedencies, but has no link
02:17:01 <augur> the fold, like, the trackback limit
02:17:05 <dancor> @hoogle factor
02:17:05 <lambdabot> No results found
02:17:07 <augur> i bet your links are there, just some pages back
02:17:44 <paolino1> like ghc-prim
02:17:55 <McManiaC> augur: no they arent
02:18:15 <augur> whats your username
02:18:36 <McManiaC> McManiaC
02:18:44 <paolino1> dancor: http://darcs.haskell.org/packages/integer-gmp/
02:19:16 <augur> weird
02:19:25 <dancor> paolino1: ty
02:19:35 <paolino1> :t cmpInteger#
02:19:36 <lambdabot> Not in scope: `cmpInteger#'
02:20:45 <mjrosenb> does ghc do anything special for rendering a number into a string with show?
02:21:27 <paolino1> Prelude> :m GHC.Integer.GMP.Internals
02:21:27 <paolino1> Prelude GHC.Integer.GMP.Internals>
02:21:30 <mjrosenb> iirc, gmp has a to-string like function
02:21:40 <mjrosenb> but it is not lazy.
02:23:15 <paolino1> :t GHC.Integer.GMP.Internals.divExactInteger#
02:23:17 <lambdabot> Couldn't find qualified module.
02:24:02 <paolino1> with ghci I cannot hask :t of a name ending in #, but lambdabot seems to parse it
02:24:19 <paolino1> s/hask/ask
02:25:45 <Johnny_> hello, could someone please help me with very basic haskell? its the first time im trying to learn the language but im having big difficulties
02:26:01 <paolino1> everyone here
02:26:08 <Johnny_> what i have to program is a function that checks whether 3 numbers are all different from each other and then gives back the term "true", else "false"
02:26:15 <Johnny_> what ive tried so far is:
02:26:24 <Johnny_> threeDiff :: Int->Int->Int->Bool  threeDiff : if a /= b && a /= c && b/=c 	then TRUE 	else FALSE
02:26:52 <paolino1> you can put them in a list
02:26:58 <Johnny_> at first i had "threediff x = if (...) but he told me, c is undefined
02:27:20 <Twey> Johnny_: What book are you using?
02:27:40 <Johnny_> currently just a pdf called "yet another haskell tutorial" and...
02:27:44 <Twey> Ah
02:27:49 <Twey> @where lyah
02:27:49 <lambdabot> http://www.learnyouahaskell.com/
02:27:52 <Twey> ^ try this one
02:27:55 <Johnny_> another pdf from a german university
02:28:00 <Twey> It'll introduce you to the basic syntax and so on
02:28:30 <Twey> (threeDiff :: Int -> Int -> Int -> Bool; threeDiff a b c = a /= b && a /= c && b /= c)
02:28:49 <paolino1> your threediff has one argument x, you want 3 args
02:28:56 <paolino1> a b c
02:28:59 <McManiaC> threeDiff a b c = (a ==) `all` [b,c]
02:29:00 <McManiaC> :D
02:29:08 <paolino1> :)
02:29:12 <Twey> Yeah, there are nicer ways to do it, too
02:29:46 <paolino1> we'd use all
02:29:50 <Twey> Definitions are written with ‘=’, not ‘:’; arguments need to be mentioned by name (hence your ‘not defined’ error); the boolean values are True and False, not TRUE and FALSE
02:29:50 <paolino1> :t all
02:29:52 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
02:30:14 <Twey> Oh, you also got it backwards, McManiaC
02:30:26 <Twey> Hm
02:30:30 <McManiaC> backwards?
02:30:31 <Twey> And inside-out :þ
02:30:38 <Twey> Yours checks whether they're all the same
02:30:45 <Twey> It's meant to check whether they're all different :þ
02:30:51 <McManiaC> oh :>
02:30:52 <Twey> (i.e. the same value does not occur more than once)
02:30:57 <paolino1> right
02:31:01 <McManiaC> ok
02:31:06 <McManiaC> sorry then :D
02:31:21 <Johnny_> damnit now he tells me that "main" is already loaded.. mom (using hugs)
02:31:21 <Twey> I'm not sure there is a nicer way to do that.
02:31:41 <McManiaC> Johnny_: use ghci
02:31:46 <Twey> Johnny_: 1) Stop using hugs
02:32:02 <Johnny_> yeah ive seen that most people recommend hugs, its just that our professor told us specifically to use hugs.. but maybe ill ignore him
02:32:06 <Johnny_> aeh
02:32:08 <Johnny_> recommend ghci
02:32:18 <Twey> GHC is the one that people actually use.
02:32:27 <Johnny_> stupid prof :D
02:32:32 <McManiaC> I thought hugs wasn't developed anymore :>
02:32:37 <paolino1> :t group
02:32:37 <Twey> Hugs is the one that was used for teaching for a short while when GHC's error messages were particularly horrible.
02:32:38 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
02:32:46 <Johnny_> hm
02:33:14 <paolino1> @info nub
02:33:15 <lambdabot> nub
02:33:22 <Twey> Ah, yeah, nub
02:33:22 <paolino1> @src nub
02:33:22 <lambdabot> nub = nubBy (==)
02:33:30 <paolino1> @src nubBy
02:33:30 <lambdabot> nubBy eq []             =  []
02:33:30 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
02:33:43 <Twey> threeDiff a b c = length (nub [a, b, c]) == 3
02:34:23 <Johnny_> what does nub do?
02:34:31 <Twey> Johnny_: Removes duplicates from a list
02:34:39 <Twey> > nub [1, 2, 3, 4, 3, 4, 5]
02:34:40 <lambdabot>   [1,2,3,4,5]
02:34:43 <Johnny_> oh
02:34:45 <Johnny_> thanks
02:34:57 <nooodl> i don't get @src nubBy ;(
02:34:59 <Twey> But you have more basic problems to worry about
02:35:06 <paolino1> it's O (n^2) 
02:35:13 <nooodl> oh, wait, now i do, it's kind of weird though
02:35:58 <paolino1> nooodl: how would you do it ?
02:35:59 <Twey> nooodl: nubBy of an empty list is an empty list; nubBy of a list with at least one element is that element plus the nubBy of that list with all instances of that element removed
02:37:13 <nooodl> paolino1 i'd probably check the amount of times each element is in the list
02:37:20 <nooodl> that's probably really inefficient :)
02:37:23 <paolino1> what kind of recursion is that, has it a morphism strange name ?
02:37:42 <Twey> Hm
02:37:58 <Johnny_> when i want to download ghci, it tells me that i should download "haskell platform" instead and that it only supports up to vista, but i use windows 7. should i ignore it nonetheless or use haskell platform?
02:38:22 <McManiaC> haskell platform works perfectly on win7
02:38:27 <Johnny_> k
02:38:43 <Twey> paolino1: I think it might be a paramorphism
02:39:21 <Twey> Oh, no, maybe not
02:41:51 <paolino1> nooodl: not different in complexity
02:42:56 <nooodl> i tried that but it removed *all* elements occuring more than once :/
02:50:48 <paolino1> the complexity can be reduced , in the average case
02:51:35 <paolino1> first duplicate element results in False
02:52:20 <Twey> Oh, for this particular case… yes
02:52:31 <paolino1> also length goes thru one more time
02:54:07 <Johnny_> how do i tell ghci where my little "progams" are located so that i can load them?
02:55:13 <paolino1> I launch ghci in the same folder
02:55:17 <Twey> allDiff [] = True; allDiff (x : xs) = allDiff' x xs where allDiff' _ [] = True; allDiff' y xs@(x : xt) = notElem y xs && allDiff' x xt
02:55:23 <Twey> Maybe?
02:55:33 <paolino1> yes
02:56:21 <Twey> Johnny_: Just use :l /path/to/file.hs
02:58:25 <paolino1> let aD xs = let aD' ys xs = if null xs then True else let (x:xs') = xs in if x `elem` ys then False else aD' (x:ys) xs' in aD' [] xs in aD [1,4,4,5,6,7]
02:58:38 <paolino1> > let aD xs = let aD' ys xs = if null xs then True else let (x:xs') = xs in if x `elem` ys then False else aD' (x:ys) xs' in aD' [] xs in aD [1,4,4,5,6,7]
02:58:39 <lambdabot>   False
02:59:38 <paolino1> Twey: are all those morphism names due to purity ?
03:00:55 <Twey> paolino1: Errr… no?
03:01:39 <paolino1> if we admit updates , there is no way to classify recursions , I mean
03:03:53 <paolino1> maybe it is just not important to study them, without the constraint of purity
03:08:07 <Johnny_> thanks guys, i got the first task done :)
03:09:44 <Twey> paolino1: They just are pure patterns
03:10:19 <Twey> If you introduce impurity you're not really naming recursion patterns any more
03:11:56 * pastorn has been put in dependency hell by Cabal + ghc 7
03:20:44 <paolino1> yes , at least with quickcheck it does strange
03:21:59 <paolino1> I got ghc and ghc-pkg back to 6.12.3 soon
03:29:23 <Johnny_> what does the error "possibly incorrect indentation" mean? 
03:29:43 <sipa> since indentation is relevant in haskell
03:29:51 <sipa> if you mess it up, it may not mean what you want
03:30:02 <sipa> some errors that typically arise from this give that warning
03:32:20 <AmunRa> http://en.wikibooks.org/wiki/Haskell/Indentation
03:33:08 <paolino1> have infix notation a fixed precedence , and associate right ?
03:33:42 <pastorn> dcoutts: you still maintaining cabal-install?
03:34:05 <sipa> paolino1: it depends, there are some priority levels
03:34:16 <sipa> and associativity can differ between operators
03:34:26 <nooodl> if you define your own operator, what precedence does it have
03:34:35 <sipa> whatever you choose
03:34:40 <paolino1> sipa I mean `fmap`
03:34:54 * hackagebot HTTP 4000.1.1 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.1.1 (GaneshSittampalam)
03:34:58 <Twey> I think it's 9 by default?
03:35:06 <Twey> You can change it, though
03:36:02 <nooodl> oh, "infixl"
03:36:17 <Twey> infix, infixl, infixr
03:36:29 <sipa> If no fixity declaration is given for `op` then it defaults to highest precedence and left associativity
03:37:15 <paolino1> oh , is `fmap` left associative ?
03:37:29 <paolino1> right, it is
03:38:01 <paolino1> left associative means I need parenthesis on a chain of `fmap`
03:39:31 <paolino1> mh, does it make sense to have `fmap` left associative ?
03:40:08 <paolino1> :t fmap
03:40:09 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
03:41:02 <paolino1> :t \x y z -> x `fmap` y `fmap` z
03:41:03 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
03:41:29 <Saizan> :t \x y z -> fmap (x . y) z
03:41:31 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
03:41:49 <Saizan> :t \x y z -> x . y <$> z
03:41:50 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
03:44:16 <writer> http://xwhy.comicgenesis.com/
03:49:53 <Jafet> @src (<$>)
03:49:54 <lambdabot> f <$> a = fmap f a
03:50:04 <Jafet> Figures
03:50:31 <shachaf> What did you expect? :-)
03:51:09 <Jafet> A fixity declaration
03:51:26 <shachaf> Jafet: Ah.
03:51:29 <shachaf> ghci will tell you.
03:51:38 <shachaf> infixl 4 <$>
03:51:58 <Jafet> Yeah, but my, er, fingers are strained and so typing alt-tab isn't as convenient
03:52:31 <Jafet> Looks like I left that out of my (.) in ghci.conf
03:53:05 <Jafet> .oO(If (.) is <$>, should it still be infixr 9?)
03:53:31 <aristid> paolino1: you don't need parenthis on a chain of fmap, because a functor law says that all functors must be associative
03:54:15 <shachaf> Which is true even across functors, I think.
03:54:15 <Jafet> Unfortunately, the tribunal is overflowing in monad cases right now
03:55:43 <aristid> shachaf: at least if one of them is (e ->)
03:56:28 <shachaf> aristid: Could it type-check otherwise?
03:56:48 <aristid> hmmm
03:57:06 <yiannis_t> meres
03:57:24 <aristid> :t \a b -> [fmap (fmap a b), fmap (fmap a) (fmap b)]
03:57:25 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> [f a1 -> f b]
03:57:37 <aristid> shachaf: no :)
03:57:47 <shachaf> aristid: There you go. :-)
03:58:42 <aristid> i guess "associativity" is not the right name for this, then
03:59:33 <aristid> what i mean is: (a <$> b) <$> c = a <$> (b <$> c)
03:59:51 <Jafet> Yeah, that's called associativity
03:59:54 <FauxFaux> @pl (a <$> b) <$> c
03:59:54 <lambdabot> a <$> b <$> c
04:00:23 <Jafet> @pl (a * b) * c
04:00:24 <lambdabot> a * b * c
04:00:45 <shachaf> @pl (a - b) - c
04:00:46 <lambdabot> a - b - c
04:00:49 <shachaf> @pl a - (b - c)
04:00:49 <lambdabot> a + b - c
04:01:12 <shachaf> Huh?
04:01:17 <Jafet> @pl \x y -> y * x
04:01:17 <lambdabot> (*)
04:01:21 <aristid> Jafet: well, but it depends on (e ->) being a functor instance
04:01:33 <Jafet> shachaf: oh boy
04:01:40 <shachaf> > let (a,b,c) = (1,2,3) in [a - (b - c), a + b - c]
04:01:42 <lambdabot>   [2,0]
04:01:48 <aristid> shachaf: looks like you found a bug in @pl?
04:01:53 <Jafet> aristid: lucky then for us that it is!
04:02:04 <aristid> Jafet: phew!
04:02:53 <aristid> without it, you would write (a . b) <$> c = a <$> (b <$> c)
04:03:30 <Jafet> Well, that happens to be one of the functor laws
04:03:50 <Saizan> it's useful to keep (.) and (<$>) with separate fixities, like i showed above
04:05:18 <aristid> Jafet: that's what i mean!
04:05:33 <aristid> Saizan: where?
04:05:35 <shachaf> @let map = fmap
04:05:36 <lambdabot>  Defined.
04:06:09 <aristid> :t map
04:06:10 <lambdabot>     Ambiguous occurrence `map'
04:06:10 <lambdabot>     It could refer to either `L.map', defined at <local>:4:0
04:06:10 <lambdabot>                           or `Prelude.map', imported from Prelude at State/L.hs:3:0-36
04:06:14 <Jafet> @unlet
04:06:16 <lambdabot>  Defined.
04:06:16 <aristid> shachaf: thank you...
04:06:26 <aristid> :t (.:)
04:06:26 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:06:33 <aristid> lovely.
04:06:34 <shachaf> @ty map
04:06:35 <lambdabot>     Ambiguous occurrence `map'
04:06:35 <lambdabot>     It could refer to either `L.map', defined at <local>:4:0
04:06:35 <lambdabot>                           or `Prelude.map', imported from Prelude at State/L.hs:3:0-36
04:06:36 <shachaf> @undef
04:06:44 <aristid> :t (.:)
04:06:45 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
04:06:52 <aristid> :t map
04:06:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
04:12:15 <Saizan> aristid: \x y z -> x . y <$> z
04:14:16 <aristid> Saizan: which has the same type as x <$> (y <$> z)
04:14:56 <Saizan> yes, but that's uglier :)
04:14:56 <aristid> or, in Caleskell, x . y . z
04:15:32 <Saizan> ?type \x y z -> x . y . z
04:15:34 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
04:15:36 <aristid> or even x <$> y <$> z, which is however the same as x . y <$> z
04:16:36 <Saizan> :t \f x y -> f . x <*> y
04:16:37 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
04:16:48 <Saizan> :t \f x y z -> f . x <*> y <*> z
04:16:50 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
04:17:03 <Saizan> ok, we could do without <$> :)
04:17:05 <Jafet> If <$> is ., what one-symbol operator would <*> be?
04:17:37 <aristid> is there a free ascii operator?
04:17:53 <aristid> otherwise we have to resort to unicode
04:18:09 <Saizan> the most fitting would be $, which would also make sense if we had a transparent identity functor
04:18:20 <Saizan> (though that would be a pain for instance resolution)
04:20:03 <Jafet> Hm, why wouldn't overlapping instances work?
04:20:13 <Axman6> &?
04:20:53 <Saizan> well, you can't make an instance for a type synonym at all, currently :)
04:21:07 <Botje> -XTypeSynonyms to the rescue!
04:21:17 <Saizan> ok
04:21:31 <Axman6> > let f & x = f <*> x in Just (+1) & Just 7
04:21:32 <Saizan> you can't make an instance for a type synonym when it would make a difference to do so
04:21:33 <lambdabot>   Just 8
04:21:39 <Axman6> hey, it works
04:22:02 <mux> is there no way to have a type function mapping both individual types to other types (like 1:1), but also types from a type-class to one type (like N:1) ?
04:22:04 <Saizan> and if you could, i'm afraid you'd often need type annotations
04:22:20 <Axman6> f . x & y & z sort of reads as apply f to x and y and z, i like that
04:22:34 <Saizan> mux: no
04:22:56 <Jafet> Axman6: but that's no fun, we want to rape and pillage ghc until we get to do it with $
04:23:09 <Saizan> mux: you can approximate with fundeps in a quite twisty way
04:23:39 <mux> that's the kind of type hackery I keep willing to have in haskell
04:23:47 <aristid> :t (&)
04:23:48 <lambdabot> Not in scope: `&'
04:24:07 <aristid> > let (&) = (<*>) in \a b c -> a . b & c
04:24:08 <lambdabot>   Precedence parsing error
04:24:08 <lambdabot>      cannot mix `L..' [infixr 9] and `&' [infixl 9...
04:24:21 <aristid> > let (&) = (<*>); infixl 5 (&) in \a b c -> a . b & c
04:24:21 <lambdabot>   <no location info>: parse error on input `('
04:24:29 <aristid> > let (&) = (<*>); infixl 5 & in \a b c -> a . b & c
04:24:30 <lambdabot>   Overlapping instances for GHC.Show.Show
04:24:30 <lambdabot>                              ((a ->...
04:24:36 <aristid> :t let (&) = (<*>); infixl 5 & in \a b c -> a . b & c
04:24:37 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
04:24:43 <aristid> :t let (&) = (<*>); infixl 5 & in \a b c d -> a . b & c & d
04:24:44 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
04:25:29 <Saizan> mux: maybe you don't want typeclasses at all
04:26:40 <mux> Saizan: maybe; in that specific case I wanted to play having a class of types that are cocercible to integrals. in the end I would like to have Char mapped to Int via the 'ord' function, but also have all the types in Integral mapped to themselves
04:27:15 <mux> or maybe have Integral types mapped to themselves and Enum types mapped to Int via fromEnum
04:37:36 <IR5012> Hi!!!! can you plz VOTE ME in this site??? http://www.lifelessserious.gr/player2.php?id=4AOj1590UKu44syA&t=kallitexnikes_anhsuxies_sto_sxoleio thnx!!!
04:39:02 <Axman6> thanks freenode staff...
04:40:23 <opqdonut> "spam is off topic", quite civil!
04:42:55 <Botje> let's see if those guys have an abuse@
04:43:47 <Jafet> ghc doesn't allow declaring a partially applied type synonym as an instance
04:44:00 <Jafet> type Identity a = a; instance Functor Identity where
04:47:05 <Botje> neh
04:47:13 <Botje> I reported that person to abuse@ and webmaster@
04:47:18 <Botje> let's see if they respond
04:47:47 <Botje> my success rate is only like 3 out of 8 so far, but punishing spammers is so worth it :)
04:47:52 <Mitar> there should be some shortcut for: a x = a1 x >>= a2
04:47:53 <Mitar> ?
04:48:05 <Mitar> @pl a x = a1 x >>= a2
04:48:05 <lambdabot> a = (a2 =<<) . a1
04:48:08 <Botje> that's >=> i think
04:48:15 <Mitar> :t a x = a1 x >>= a2
04:48:16 <lambdabot> parse error on input `='
04:48:22 <Mitar> :t a1 x >>= a2
04:48:23 <lambdabot> Not in scope: `a1'
04:48:23 <lambdabot> Not in scope: `a2'
04:48:26 <Botje> :t (>=>)
04:48:27 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
04:48:43 <Botje> :t undefined >=> undefined
04:48:45 <lambdabot> forall a (m :: * -> *) c. (Monad m) => a -> m c
04:48:51 <Botje> Mitar:  ^ ^
04:49:08 <Mitar> thanks
04:51:15 <Jafet> Hrm, so how would the identity functor instance be declared in haskell?
04:52:22 <Jafet> (<*>) :: (a -> b) -> a -> b
04:54:29 <Jafet> Uh actually <*> is in Applicative
04:55:23 <Cale_> right
04:55:54 <Cale_> But that would be the right type for fmap as well.
04:56:10 <McManiaC> :t <*>
04:56:11 <lambdabot> parse error on input `<*>'
04:56:16 <McManiaC> :t (<$>)
04:56:17 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:56:21 <McManiaC> :t (<*>)
04:56:22 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
04:56:40 <Cale_> If f is the identity, then those degenerate into the same thing.
04:56:49 <McManiaC> indeed
04:56:49 <McManiaC> :)
04:57:04 <Jafet> In that case fmap = (<$>) = (<*>) = (.) = ($)
04:57:23 <Jafet> "Error: declaring this instance will make your code way too generic"
04:57:40 <McManiaC> hehe
04:57:42 <McManiaC> yeah
05:00:50 <Botje> sigh.
05:01:03 <Botje> those lifelessserious guys are a bunch of incompetent twits
05:01:11 <Botje> both abuse@ and webmaster@ bounced :(
05:01:40 <McManiaC> ^^
05:04:07 <aristid> is it blasphemy to see haskell as similar in spirit to APL?
05:05:31 <Twey> aristid: Probably
05:05:37 <Twey> aristid: I don't see the similarity, really
05:06:05 <Jafet> Well, haskell operators must be punctuation
05:06:22 <Jafet> ...not that the unicode planes are short on punctuation
05:07:05 <Saizan> they can be symbols too
05:07:29 <Botje> .oO(snakes on a unicode plane)
05:07:55 <Jafet> I've had enough of these motherfucking memes
05:09:07 <Botje> :)
05:16:59 <Cale> Botje: Maybe try abuse@vps.net (might be their ISP though)
05:17:36 <nlogax> ugh, i suck.. if i have http://paste.pocoo.org/show/1X9Ar2x6mvFUQPrB2SPN/ , can i sneak some forkIO into `listen`, to make it handle each message in a separate thread?
05:18:41 <Botje> yeah, i think so.
05:18:43 <Cale> nlogax: Sure, probably?
05:18:59 <Botje> if anyone knows greek and can dig up an abuse address at lessserious.gr, i'm happy to send them a mail
05:19:00 <Cale> nlogax: It would help to see more of your program to have some idea of what's going on :)
05:19:33 * hackagebot genprog 0.1 - Genetic programming library  http://hackage.haskell.org/package/genprog-0.1 (JanSnajder)
05:20:07 <Cale> nlogax: You could perhaps stick the entire end of the do-block after the s <- ... into a forkIO
05:20:22 <McManiaC> nlogax: you'll have to re-setup the "ReaderT" monad for the new thread
05:20:42 <nlogax> Cale: it is here: https://github.com/nlogax/norby/blob/master/src/IRC.hs#L45 , i got the Net type from a tutorial, not really familiar with monad transformers yet :P
05:20:44 <Cale> Oh, right, this is in ReaderT...
05:20:57 <Cale> Transforming the IO monad is silly.
05:21:03 <McManiaC> nlogax: but be careful with forever and forkio... you want to block somewhere. :)
05:21:28 <Cale> (some people really like to do it though)
05:22:36 <Cale> nlogax: So you want to handle processing of each message in a separate thread, but you'll probably also want to collect the replies back in the original thread. For that you can use a Chan, for instance.
05:23:00 <Cale> McManiaC: Well, the hGetLine can block
05:23:10 <McManiaC> Cale: not if it's forked into another thread
05:23:35 <McManiaC> oh, we're talking about "eval msg"
05:23:46 <Cale> McManiaC: Right, you wouldn't want to put that in the forkIO :)
05:24:18 <nlogax> Cale: cool, i'll check out Chan :)
05:24:43 <nlogax> yeah, i just don't want someone's > sum [1..] to block everything else until mueval gives up
05:25:06 <Cale> nlogax: If you're going to do lots of threading, I would unravel the monad transformer usage. ReaderT Bot IO a is basically the same thing as  Bot -> IO a
05:25:44 <Cale> The other option is to push on and write a forkNet or something :)
05:25:54 <Cale> Which is certainly doable...
05:26:26 <Cale> I think the syntactic cost of using ReaderT over IO is at least as bad as passing parameters explicitly in most cases though.
05:26:53 <Cale> (You just end up with lots of liftIO instead of an extra parameter being passed around)
05:27:42 <Botje> couldn't you abuse GHC's dynamic scoping for that?
05:27:55 <Cale> You mean implicit parameters?
05:27:58 <Botje> yes
05:27:59 <Cale> You could.
05:28:18 <Cale> This is sort of the use case for them, though I don't much care for those either :)
05:28:19 <Botje> okay
05:28:40 <McManiaC> http://npaste.de/mh/ :>
05:28:41 <nlogax> you're probably right, Cale. in the tutorial where i stole it from, there was a `io = liftIO`, and `io` all over the place :)
05:28:43 <Botje> i think they're sort of nice :P
05:28:54 <McManiaC> never used it in a real world application though
05:29:22 <ClaudiusMaximus> wow, i never seen code this GC-heavy before :/:   Productivity   8.4% of total user
05:29:34 <McManiaC> this + constraint synonyms (or whatever it's called) would be awesome :)
05:30:19 <ClaudiusMaximus> (it also blew a 100MB stack, after 15mins of runtime...)
05:30:49 <McManiaC> constraint MyApp = ?x :: Int, ?y :: Int, ?f :: Int -> Int -> Int; foo :: MyApp => Int; foo = ?f ?x ?y
05:30:53 <McManiaC> :D
05:31:58 <Jafet> {-# LANGUAGE CommonLisp #-}
05:49:06 <lars9> how to get a char, without printing it?
05:49:34 <Zao> "get"?
05:49:40 <Twey> 'a' -- a char
05:49:56 <Zao> lars9: If you're talking about terminal echo, use a library to disable that.
05:50:54 <lars9> it's like getch in windows
05:51:02 <Twey> See System.IO.hSetEcho in that case
05:51:11 <lars9> Twey: let me try, thanks
05:51:26 <Twey> lars9: I have no idea what ‘getch in Windows’ is like :þ
05:52:13 <lars9> Twey: but you got it, hSetEcho works
05:58:56 <lars9> to test an algorithm, i need a tool to draw some lines & squares etc with colors and line-width. what is the easiest way? its not final result so i dont want to spend too much time on it:)
06:00:12 <Jafet> Dump a pnm image
06:02:07 <lars9> the squares and lines are dynamic, changes like 1 time per second
06:02:27 <lars9> so i want to be able to watch it
06:03:33 <Jafet> Dump an svg animation
06:03:44 <Jafet> Actually I don't know any program that renders an svg animation
06:04:33 <lars9> hmmm, what if i want to see it at runtime?
06:05:00 <Watermind> how do you usually import Control.Category
06:05:02 <Watermind> i.e.
06:05:07 <Watermind> what do you hide, qualify etc
06:05:19 <Watermind> asking because of the overloading with (.) and id
06:05:21 <Jafet> Then you'd use some graphics package
06:05:34 <Watermind> I was thinking import (.) and id qualified 
06:05:44 <Watermind> and the rest non qualified
06:05:47 <Watermind> if possible
06:07:42 <crutcher> does anyone know why hoogle is down?
06:09:01 <Watermind> import Control.Category hiding (id, (.))      and     import qualified Control.Category (id, (.))
06:09:06 <Watermind> is the the usual way to do it?
06:09:53 <Watermind> or do you do the opposite and hide the prelude id and (.)
06:09:55 <Watermind> ?
06:09:58 <Jafet> Won't Category.id and Category.(.) be generalizations of Prelude.id and Prelude.(.)?
06:10:12 <Jafet> It depends on which version you want to use, then
06:10:28 <Watermind> yes, the drawback would be that error messages become more complicated
06:10:43 <Watermind> to be honest I'll be using Arrows 
06:10:52 <Watermind> I just need Category to define their instances
06:11:42 <Jafet> I always stop reading ghc error messages past the line number
06:32:59 <unkanon> Jafet: so true... why are ghc error messages so impenetrable?
06:34:43 <paolino> because ghc is working hard on sources
06:36:25 <unkanon> I don't get it, can you rephrase that?
06:37:52 <paolino> compiling haskell is probably a complex task, and showed errors are often decontextualized 
06:39:09 <Baughn> I haven't been paying attention.. the canonical monad transformer package is now mtl again?
06:39:31 <remy_o> most frequently, ghc will stop because types do not match, and types for complex expressions may be extremely involved
06:40:15 <unkanon> hmm I see... the choice of words could still be better I think
06:40:29 <paolino> sure 
06:41:44 <paolino> also having a bigger context printed is not going to help without a visualization tool
06:42:14 <Saizan> Baughn: mtl-2 is a re-export of transformers and monads-fd, so i guess so, i don't know if you're supposed to start depending on the latter two directly though
06:42:16 <jmcarthur> Baughn: mtl and transformers are essentially the same now
06:42:24 <unkanon> paolino: I don't think I know what a visualization tool is
06:43:06 <sm> ghc error messages are a bit scary, but it's worth learning to read more from them, they actually do make sense
06:43:16 <sm> and are quite precise
06:43:29 <sm> as long as you define types for everything
06:43:34 <paolino> something to show the expression and signatures involved in the error and the path to understand the typechecking failure
06:43:43 <sm> so if in doubt, try specifying more types
06:43:50 <remy_o> it usually get better when you explicitly declare more types and use more intermediate variables, as sm says
06:44:13 <unkanon> sm: I always define types for everything (I have -Wall set so it forces me to) so now I'm learning how to decipher ghc error messages
06:44:20 <unkanon> sm: there should be a tutorial on that :)
06:44:32 <sm> good idea, if you write it I'll help you
06:44:35 <paolino> remy_o: which ghc could do for us
06:44:42 <Cale> Usually if you read GHC's error messages carefully, they make sense.
06:45:23 <unkanon> sm: ok, I will start doing that locally and I'll show you when I have something upon which to start the tutorial on
06:46:10 <Cale> Sometimes they indicate a problem with the way that you've reasoned about the code, and they can be rather mysterious in those cases.
06:46:22 <remy_o> paolino: you would end up with "found type Alice where expected type is IO [Either Bob (Maybe Charlie)] where Bob = [String] and Charlie = ... ?
06:46:46 <paolino> right
06:47:02 <sm> when you have something maybe put it on http://ietherpad.com/ and all of #haskell can help. Then probably move it to the wiki. Also worth searching for an existing doc first
06:47:17 <unkanon> sm: I'm searching now
06:47:42 <paolino> remy_o: and there is where something visual would make the difference
06:47:54 <mux> Cale: btw, I've noticed that GHC 7.0.1 says that an import is "redundant" when it's just "useless"; not sure if this is new in 7 but I find this slightly misleading
06:47:57 <remy_o> paolino: but yeah, one could define a max complexity for terms involved in GHC error messages, so that when types exceed the threshold, they get split in smaller terms...
06:48:41 <remy_o> or output ASCII-art syntactic trees ? 
06:49:00 <unkanon> yes, one can be visual while still in the command line
06:49:08 <paolino> remy_o: the problem is also linking the types to the expression in the source
06:49:34 <hpc> heh, compiler output as ascii tree would be awesome
06:49:55 <Igloo> mux: I'm not sure what your distinction between "redundant" and "useless" is
06:49:59 <sm> paolino: ghc prints the expressions and the line and column number.. you can set up emacs to jump from there to the source
06:51:01 <Renze> good afternoon!
06:51:18 <mux> Igloo: it seems to me "redundant" would only make sense if there were two important instance, but I may be completely wrong, I'm nto a native english speaker
06:51:41 <paolino> sm: then I have to give signatures to random expressions around the error , where part or all of them have been already computed for the error
06:51:52 <sm> package author tip: document your build flags in the description, since hackage doesn't show them which can be quite confusing
06:52:07 <Renze> anybody around with Windows and Cygwin experience?
06:52:12 <sm> eg Chart has a hidden dependency on gtk 
06:52:19 <mux> like, if you don't use any functions from some module, it's useless to import the module; if you do use some of the functions but import it two times, it's redundant
06:52:43 <sm> paolino: sometimes, but with practice it gets much easier to spot the problem
06:52:46 <hpc> mux: you are quite correct
06:53:07 <hpc> mux: other languages (even java) make the distinction between the two
06:53:19 <paolino> sm, if moving the mouse on the sources after the compilation , pops up the signatures of expressions I would be happy
06:53:21 <mux> ah, I was afraid the meaning of the french word "redondant" was actually different than english's redundant
06:55:00 <paolino> sm, it would help to understand ghc typechecking errors in the end :)
06:55:30 <sm> paolino: yes, they are worth some study :)
06:55:49 <sm> but I don't mean to say the ui couldn't be improved further. That would be awesome.
06:58:31 <paolino> also rolling mousewheel to select the level of the traceback inside ghc when it stops typechecking, and see the involved expressions highlighted
07:00:15 <unkanon> here's an example of what I'm talking about
07:00:26 <unkanon> not to bash ghc error messages, really
07:00:34 <sm> paolino: that level of control is ide-specific, leksah would be a place for that
07:01:10 <unkanon> "No instance for (Num [Int]) arising from the literal `3' at <interactive>:1:21"
07:01:31 <unkanon> I would rather read " the literal '3' is not an instance of Num [Int]"
07:01:51 <Jafet> I'm sure the ghc developers welcome patches in that regard
07:02:17 <paolino> 3 is not a [Int] maybe
07:02:31 <unkanon> Jafet: are you sure? maybe they like the way it's worded now for some reason
07:02:50 <unkanon> paolino: if we take it too far we may be considered heretics :P
07:02:59 <remy_o> unkanon: a literal is not something in particular, it can be interpreted with many different types
07:03:32 <Jafet> And yes, you can declare an instance Num [Int] (like the rest of that error message would very helpfully and cheerily point out)
07:03:45 <revenantphx> It's probably being interpreted as Num [Int] due to its context :\
07:03:54 <Jafet> > ((+) * (-)) 1 2
07:03:55 <lambdabot>   -3
07:04:11 <sipa> unkanon: more correct would be "The inferred type for '3', [Int], is no instance of Num"
07:04:31 <remy_o> unkanon: what did you type ??
07:04:33 <sipa> but that's not too far from what it actually says either
07:04:43 <burp> is anyone aware of a network packet parser? I'm mainly interested in IP/TCP
07:04:53 <unkanon> sipa: right, it's not much improvement
07:04:58 <unkanon> remy_o: I'll show ya, hold on
07:05:03 <burp> otherwise the libpcap bindings are too low level
07:06:20 <unkanon> remy_o: http://hpaste.org/41905/error1
07:07:10 <opqdonut> would you say that O(log n/loglog n) is significantly better than O(log n)
07:07:11 <jutaro> fuck uz all
07:07:13 <jutaro> wiejfR§QgvbHntu
07:07:38 <burp> depends on n :P
07:07:40 <opqdonut> I've written the latter in a paper when the analysis could've proven the former too
07:08:06 <remy_o> unkanon: i agree this is confusing, Num doesn't seem to have anything to do with the problem
07:08:19 <jutaro> bjvk hn, fuck
07:08:40 <jutaro> fuck ui
07:08:42 <sipa> remy_o: except for the fact that an integer constant is of type Num a => a
07:08:47 <unkanon> remy_o: right. so the best error message (best as in "most to the point") would be something like "3 is not an [Int]" like someone suggested
07:08:49 <Jafet> opqdonut: not if the constant for the former is larger than the constant for the latter by a factor of log log n
07:09:11 <Jafet> > log (log 2^32))
07:09:13 <lambdabot>   <no location info>: parse error on input `)'
07:09:15 <Jafet> > log (log 2^32)
07:09:16 <lambdabot>   -11.728413458613261
07:09:24 <opqdonut> indeed
07:09:26 <Jafet> > log (log (2^32))
07:09:28 <lambdabot>   3.099222982218062
07:09:39 <remy_o> sipa: oh well, that explains the problem
07:09:46 <opqdonut> maybe I'll keep it as O(log n)
07:10:11 <Jafet> Well, if they're the same algorithm, give the exact bound
07:10:20 <unkanon> sipa: how would you rephrase that erro message to make it more tothe point while still retaining that Num info bit?
07:10:28 <Jafet> That way you prevent other snobby researchers from snatching it under your feet
07:11:14 <Phyx-> whoops, i broke it
07:11:25 <sipa> unkanon: "Integer literal '3' cannot be of inferred type [Int], since no instance (Num [Int]) exists" ?
07:11:57 <Jafet> You could patch ghc so that any type error sends the programmer into Kafka's penal colony machine.
07:12:29 <unkanon> sipa: I still think that's too complicated for the error at hand
07:13:08 * hackagebot iteratee-compress 0.1.2 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.1.2 (MaciejPiechotka)
07:14:01 <remy_o> unkanon: no, because 3 can indeed be a [Int]
07:14:13 <unkanon> remy_o: how?
07:14:15 <remy_o> unkanon: if you say "instance Num [Int] where fromInteger n = [fromInteger n]"
07:14:31 <remy_o> unkanon: then typing 3 where a [Int] is expected gives a [3]
07:14:39 <remy_o> unkanon: i'm just confused with the right syntax
07:14:46 <unkanon> is that a monkeypatch?
07:14:52 <sipa> no
07:15:05 <unkanon> why would anyone define that?
07:15:24 <sipa> the language should not prevent someone from doing it
07:15:33 <Cale> unkanon: Maybe to have lists behave like formal power series.
07:15:37 <remy_o> unkanon: you might want to use arithmetic operations with many types
07:15:44 <sipa> 3 is a constant of type Num a => a
07:15:50 <Jafet> Extensible literals is explicitly allowed. See the vector-spaces package for some abuses
07:15:57 <Cale> In fact, that instance can be really quite useful.
07:16:03 <sipa> and by default instances Num Int and Num Integer exist, among other
07:16:04 <sipa> s
07:16:15 <Renze> cygwin says (while installing unix-2.4.1.0 manually): http://hpaste.org/41906/cygwinunix, does anyone know how to solve this problem? I'm using Windows and following this: http://bit.ly/e4HQlt 
07:17:06 <remy_o> unkanon: as Cale says, if you want to represent polynomials/power series as lists, you want them to be a Num instance, and you need 3 to be interpreted as [3] if needed
07:17:09 <Jafet> Renze: it looks like gcc died
07:17:25 <unkanon> Cale, remy_o, sipa: I guess now I understand why the error message used the word "arise" as in "no instance for Num [Int] arising from the literal 3
07:17:38 <unkanon> it is indeed precise, as Cale pointed out
07:17:50 <sipa> it is, it may be confusing to beginners
07:18:15 <sipa> but it's hard to give the same error in a more concise way without being incorrect
07:18:16 <Renze> Jafet: how can I fix that? Another try doesn't work unfortunately
07:18:27 <unkanon> I'm going back on my ghci session and looking at all the errors I ignored before :P
07:18:36 <unkanon> sipa: I see that now
07:19:11 * hackagebot iteratee-compress 0.1.2.1 - An enumerators for compressing and decompressing streams  http://hackage.haskell.org/package/iteratee-compress-0.1.2.1 (MaciejPiechotka)
07:19:37 <Jafet> Renze: no idea, try another gcc?
07:19:55 <Jafet> I have no idea if the unix package is supposed to work in cygwin, either.
07:20:13 <Renze> I think I found it, another warning says WARNING: unrecognized options: --with-hc (should be ghc of course)
07:20:45 <Renze> Yes it is, there is something called `./configure` over there
07:21:23 <Jafet> configure is a shell script and can, in theory, do whatever it pleases
07:22:13 <Renze> that's right, but cabal said I should use cygwin, so I assume that it should work properly
07:22:53 <unkanon> Renze: if you have a lot of RAM (4GB+) I recommend virtual box+ ubuntu
07:23:09 <unkanon> feel free to hate me, I hated when people recommended I switch to linux
07:23:16 * hackagebot iteratee-parsec 0.0.5 - Package allowing parsec parser initeratee  http://hackage.haskell.org/package/iteratee-parsec-0.0.5 (MaciejPiechotka)
07:23:19 <unkanon> until I eventually did :)
07:24:12 <Saizan> iiuc, cabal is just saying you need msys or cygwin to run the configure script
07:24:37 <Renze> I won't hate you ;) but I'm using Windows for a reason: I'm really not compatible with another OS. I will learn it some day in the next couple of months, but it's a lack of time that stops me from doing it... (and on my laptop I only have 2.5GB)
07:25:20 <unkanon> Renze: I totally understand that. No use in forcing it if you really have no time, you'll end up frustrated that way
07:25:24 <Jafet> Bear in mind that Windows is really not compatible with another OS either
07:26:58 <Rutix> Renze I use windows too but i don't really have problems :o
07:27:42 <Rutix> Ow wait never mind i didnt read fully up ;)
07:31:18 * hackagebot iteratee-parsec 0.0.6 - Package allowing parsec parser initeratee  http://hackage.haskell.org/package/iteratee-parsec-0.0.6 (MaciejPiechotka)
07:36:04 <Saizan> maybe .cabal files should have a "supported-platforms" field
07:42:57 <aristid> :t flip
07:42:58 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
07:43:10 <aristid> @src flip
07:43:10 <lambdabot> flip f x y = f y x
07:43:51 <unkanon> @type Prelude.flip
07:43:52 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
07:44:06 <unkanon> why is Prelude.* always more readable?
07:44:20 <mux> because this is #haskell :-)
07:44:20 <Saizan> more specific
07:44:39 <mux> or maybe it should be renamed #caleskell
07:45:20 <Saizan> (even if too much specificity can be less readable as well)
07:45:33 <unkanon> but :t flip doesn't even look like :t Prelude.flip
07:45:43 <unkanon> the arity is different
07:45:49 <Saizan> that's not a problem
07:45:59 <Renze> no, because of the use of flip
07:46:00 <Saizan> take f = (e ->) and they'll unify
07:46:09 <burp> if I have the 8 bytes of a double value, would you convert them to a Double? Is there an easier way than using the foreign interface (Foreign.Storable) and writing the byte positions of a double?
07:46:17 <unkanon> Saizan: oh :)
07:46:21 <burp> erm question is, how would you ;)
07:46:36 <Renze> you won't use flip if you really need to switch x and y, but if you need to switch x and another argument which is coming from e.g. another function
07:47:06 <Renze> that's what the flip says, prelude.flip says the "normal" interpretation
07:47:07 <Saizan> burp: you could use Data.Binary.Get and Data.Binary.Put, not sure how nicer that is :)
07:47:14 <unkanon> right
07:47:57 <Saizan> anyhow @src flip gives the source for Prelude.flip, not for the generalized one
07:48:53 <Funktorsalat> it'd be cool if @src could return arbitrary source of bot-installed things
07:48:58 <unkanon> Saizan: where's the source for the generalized one?
07:49:03 <Funktorsalat> or maybe it'd be spammy.
07:49:33 <unkanon> @let abcd a b = b . a
07:49:34 <lambdabot>  Defined.
07:49:35 <unkanon> @src abcd
07:49:36 <lambdabot> Source not found. :(
07:49:37 <unkanon> ?
07:49:39 <unkanon> :)
07:49:55 <unkanon> it's got the memory of a goldfish
07:50:03 <Renze> lol.
07:50:13 <remy_o> Saizan: I don't understand how the generalized flip can be defined
07:50:19 <ManateeLazyCat> Hi all, here is Manatee video : http://www.youtube.com/watch?v=weS6zys3U8k
07:50:23 <ManateeLazyCat> Select 720p
07:50:25 <Saizan> unkanon, remy_o: http://code.haskell.org/lambdabot/State/Pristine.hs
07:50:30 <remy_o> Saizan: my native idea is that you need a function a -> f a
07:50:54 <Saizan> flip f x = fmap ($ x) f
07:51:05 <Saizan> ?type let flip f x = fmap ($ x) f in flip
07:51:05 <ManateeLazyCat> You will know what's the Manatee after watch http://www.youtube.com/watch?v=weS6zys3U8k
07:51:06 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
07:51:24 <mux> ManateeLazyCat: hi there :-)
07:51:52 <ManateeLazyCat> mux: Look http://www.youtube.com/watch?v=weS6zys3U8k with 720p (HD)
07:52:06 <mux> I'm watching it
07:52:08 <remy_o> ?type fmap ($ x)
07:52:10 <lambdabot> forall b (f :: * -> *). (Functor f) => f (Expr -> b) -> f b
07:52:15 <Funktorsalat> > flip [0..] "meow"
07:52:17 <lambdabot>   No instance for (GHC.Enum.Enum ([GHC.Types.Char] -> b))
07:52:17 <lambdabot>    arising from a u...
07:52:17 <burp> hm yes, Data.Binary might be good
07:52:22 <ManateeLazyCat> mux: Select 720p, otherwise not clear enough. :)
07:52:24 * hackagebot wumpus-core 0.40.0 - Pure Haskell PostScript and SVG generation.  http://hackage.haskell.org/package/wumpus-core-0.40.0 (StephenTetley)
07:52:27 <Funktorsalat> > flip [1,2,3] "meow"
07:52:29 <lambdabot>   [1,2,3]
07:52:40 <Funktorsalat> more lambabot 'features' ;)
07:53:07 <ddilinger> wheres it getting that flip from?
07:53:24 * hackagebot wumpus-basic 0.13.0 - Common drawing utilities built on wumpus-core.  http://hackage.haskell.org/package/wumpus-basic-0.13.0 (StephenTetley)
07:53:26 * hackagebot wumpus-microprint 0.12.0 - Microprints - "greek-text" pictures.  http://hackage.haskell.org/package/wumpus-microprint-0.12.0 (StephenTetley)
07:53:41 <mux> ManateeLazyCat: I've been considering writing GtkApplication; it seems we lack those, don't we?
07:53:57 <Funktorsalat> > flip [f,g] x
07:53:58 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:53:58 <lambdabot>    `GHC.Show.Show b'
07:53:58 <lambdabot>      a...
07:54:04 <Funktorsalat> > flip [f,g] (x::Expr)
07:54:05 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:54:06 <lambdabot>    `GHC.Show.Show b'
07:54:06 <lambdabot>      a...
07:54:24 * hackagebot wumpus-tree 0.11.0 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.11.0 (StephenTetley)
07:54:38 <pradeep> hai sir...this is pradeep...cna i ask 1 doubt regarding java..??
07:55:26 <ManateeLazyCat> mux: GtkApplication in GTK+ 3.0
07:55:38 <mux> uhoh
07:56:27 <ManateeLazyCat> mux: If GTK+ 3.0 stable version not include newest Linux, you can't use it even have binding in gtk2hs.
07:56:38 <burp> ah well, Data.Binary uses an other way of Double encoding/decoding
07:56:45 <Saizan> pradeep: you should join #java for that
07:56:47 <ManateeLazyCat> mux: Best wait popup Linux version include GTK+3.0, then we binding it. :)
07:56:51 <mux> ManateeLazyCat: I'm not even using Linux, that's not the problem ;-)
07:57:03 <mux> but if it's GTK+ 3.0, I'll wait a bit.
07:57:13 <ManateeLazyCat> Good. :)
07:57:37 <Funktorsalat> you mean some particular distro using gtk 3.0?
07:57:40 <unkanon> anybody knows who hosts tunes.org/~nef~//logs/haskell/ ?
07:58:20 <remy_o> > flip [(+ 2), (+ 3)] 5
07:58:21 <lambdabot>   [7,8]
08:00:01 <hpc> o.O
08:00:15 <aristid> :t flip [(+ 2), (+ 3)]
08:00:16 <lambdabot> forall a. (Num a) => a -> [a]
08:00:55 <augur> wtf
08:00:57 <hpc> that looks a lot like (fs (<*>) pure 5)
08:00:58 <ManateeLazyCat> mux: If don't want watch all, you can drop to Last position see the power of Manatee 
08:01:06 <hpc> :t flip
08:01:07 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:01:40 <remy_o> :t fmap ($ (x::a))
08:01:41 <lambdabot>     Couldn't match expected type `a' against inferred type `Expr'
08:01:41 <lambdabot>       `a' is a rigid type variable bound by
08:01:41 <lambdabot>           an expression type signature at <interactive>:1:12
08:02:51 <remy_o> Saizan: oh, I understand, (Functor f, x :: a) => (fmap ($ x) :: f a) but that's anti-mathematical to me
08:03:28 <dixie> > 1/0
08:03:29 <lambdabot>   Infinity
08:03:36 <dixie> > (1/0)*2
08:03:37 <lambdabot>   Infinity
08:04:06 <orlandu63> @type const <*> pure undefined
08:04:07 <lambdabot> forall b. b -> b
08:05:28 <aavogt> remy_o: what does the ::   to the left of the =>  mean for you?
08:05:46 <Saizan> ?type fmap ($ ?x)
08:05:46 <opqdonut> typing assumption
08:05:47 <lambdabot> forall a b (f :: * -> *). (?x::a, Functor f) => f (a -> b) -> f b
08:06:00 <opqdonut> yep
08:06:31 <remy_o> Saizan: well, it's rather that, but equally counter-intuitive, although true...
08:07:07 <aavogt> "(Functor f, x :: a) => (fmap ($ x) :: f a)" still doesn't make sense with that definition
08:07:27 <aavogt> as in, doesn't fmap need another argument?
08:07:45 <Saizan> aavogt: the right type is the one lambdabot just gave
08:08:09 <Phyx-> is.. there a test suite for cabal?
08:08:42 <Saizan> remy_o: it's not immediately obvious at first if you're new to the (e ->) Functor/Monad, and flip is maybe not the best name in this generalized form
08:08:46 <unkanon> > flip [(+ 2), (+ 3)] 5
08:08:47 <lambdabot>   [7,8]
08:08:53 <unkanon> that doesn't work the same in my ghci
08:09:04 <Saizan> of course
08:09:07 <orlandu63> unkanon: lambdabot's flip is generalized
08:09:17 <orlandu63> @type flip
08:09:19 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:09:22 <orlandu63> and do :type flip in ghci
08:09:23 <hpc> :t \x -> fmap ($ x)
08:09:23 <remy_o> Saizan: i don't know a Haskell functor that doesn't have an obvious (a -> f a) function
08:09:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
08:09:35 <Saizan> Phyx-: see the tests directory
08:09:47 <Saizan> remy_o: ((,) x)
08:10:04 <hpc> :t \fs x -> fmap ($ x) fs
08:10:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
08:10:16 <hpc> ^ is lambdabot flip
08:10:29 * hackagebot functors 0.1 - (.:) and friends, syntax for Functor and Applicative.  http://hackage.haskell.org/package/functors-0.1 (AristidBreitkreuz)
08:11:09 <Phyx-> Saizan: ah ok, i naively tried cabal test and nothing happened, which is why i asked :P
08:11:20 <Funktorsalat> normal flip takes a c-indexed product of (a->b)-functions and applies each element to the given 'a', yielding a c-indexed product of bs
08:11:39 <Funktorsalat> trying to 'splain the connection with bot flip ;)
08:11:41 <remy_o> Saizan: you mean something like "Either a" ?
08:12:08 <aavogt> > fmap (+1) ('a',3)
08:12:09 <lambdabot>   ('a',4)
08:12:30 <Saizan> remy_o: data Pair a b = Pair a b; instance (Pair a) where fmap f (Pair x y) = Pair x (f y)
08:12:56 <Saizan> remy_o: you can't write a function of type forall a b. a -> Pair b a
08:13:10 <unkanon> aavogt: that makes no sense to my newbie brain
08:13:11 <roconnor> optilector comonad 
08:13:15 <remy_o> Saizan: yes, for the (Pair a) functor, flip makes sense
08:13:18 <roconnor> multioptor comonad
08:13:29 <aavogt> unkanon: it's the same as Saizan's Pair
08:13:30 <remy_o> it's (a->b,c) -> a -> (b,c)
08:13:52 <unkanon> whose fmap is that?
08:15:04 <Phyx-> Saizan: lol, the tests only work on unix systems. bleh
08:15:07 <roconnor> optolector comonad
08:16:00 <Saizan> roconnor: what's that?:D
08:16:23 <roconnor> I'm still trying to pick a new name for the costate comonad
08:16:46 <roconnor> a task that weighs heavilly on my shoulders
08:17:32 <Twey> roconnor: What does it do?
08:17:42 <Funktorsalat> so 'optolector' is a proposed name for 'costate'?
08:17:58 <roconnor> Funktorsalat: one of several I have
08:18:44 <Cale> roconnor: What's wrong with Costate?
08:18:54 <roconnor> I have on my list: selector, aculector, oxylector, elector, eclector, optilector, optolector, multioptor
08:19:14 <Cale> I don't understand why most of those would be appropriate ;)
08:19:28 <Cale> My choice would probably be pointed function comonad.
08:20:34 <Funktorsalat> is that (s->s,a) or something?
08:20:34 <endojelly> why am I only working on my project thesis every few days :(
08:20:39 <roconnor> Cale: oxy- and acu- mean pointed
08:20:40 <endojelly> (it's about agda)
08:20:53 <roconnor> lector means gathering
08:21:10 <Cale> "pointed" also means pointed ;)
08:21:20 <Saizan> endojelly: (what in particular?)
08:21:29 <roconnor> I don't like the stupidly long names given to comonads.
08:21:35 <Funktorsalat> "Lector is a Latin term for one who reads, whether aloud or not"
08:21:41 <endojelly> Saizan, deletion in left leaning red black trees
08:21:41 <roconnor> the stream-with-position comonad
08:22:07 <Funktorsalat> I don't like 'lector' so much, it seems a bit obscurant since the word isn't used for anything else in the field (AFAIK)
08:22:10 <Saizan> endojelly: ah, cool
08:22:23 <Funktorsalat> so it's not deducible what it is, I mean
08:22:48 <roconnor> Funktorsalat: it also means gather
08:23:12 <roconnor> Funktorsalat: isn't used for anything else in what field?
08:23:18 <endojelly> Saizan, I try to make it as comprehensible as possible, so I'm going into a lot of details
08:23:42 <Funktorsalat> roconnor: haskell ∪ logic ∪ type theory ∪ category theory?
08:23:52 <Funktorsalat> (maybe I just don't know it, obviously)
08:24:03 <Saizan> at least it won't clash :)
08:25:25 <Funktorsalat> so *is* the thing we're talking about Foo s a = Foo (s -> s) a?
08:25:30 <roconnor> Funktorsalat: is collect or collection used in the field?
08:25:35 <roconnor> Funktorsalat: yes
08:25:50 <Funktorsalat> roconnor: I don't get that question :)
08:26:05 <Funktorsalat> as an exactly defined term?
08:26:15 <roconnor> Funktorsalat: is "collect" or "collection" used in the field?  You said "lector" isn't used for anything else in the field.
08:26:50 <Funktorsalat> I meant that fact together with the fact that its translation isn't well-known makes it obscure
08:27:05 <Funktorsalat> 'collection' is kinda obvious to english speakers
08:27:12 <Funktorsalat> (I assume your q is rhetorical)
08:27:22 <roconnor> not rhetorical
08:27:42 <roconnor> I don't understand what you mean by lector not being used in the field.  The stem is used in many words
08:27:57 <roconnor> and some of these many words we use in our field.
08:28:16 <Funktorsalat> ah. I didn't make the connection
08:28:24 <Phyx-> cabal.exe: Package unix-2.4.1.0 can't be built on this system. <-- on msys but it doesn't tell me why not
08:28:28 <Phyx-> anyone have any ideas?
08:28:33 <Funktorsalat> (hmm... the 'nection' comonad? ;))
08:29:08 <Funktorsalat> roconnor: just saying it because comonads are already considered very scary (I think)
08:29:27 <Funktorsalat> so a word one never heard would add to the intimidation ;)
08:29:31 <hpc> comonads could use the lyah treatment
08:29:47 <phrackSipsin> has anybody ever used the haskell bindings for supercollider and know of any good tutorials? Or of a good overview of supercollider itself, in the abstract?
08:29:53 <roconnor> Funktorsalat: Fair.  Though I have selector and elector in my list.
08:31:02 <roconnor> Funktorsalat: a new word would be easier to google though.
08:31:23 <roconnor> though maybe "elector + comonad" would be easy to google too.
08:31:49 <Funktorsalat> why 'elector'?
08:32:13 <Funktorsalat> that only seems obvious to me if s = a
08:32:20 <lars9> what's this syntax: module MyModule ( MyType(..) ) ? the .. pary
08:32:22 <lars9> *part
08:32:42 <Funktorsalat> roconnor: is it a special case of the reader comonad?
08:32:49 <roconnor> Funktorsalat: this comonad is a collection of a's in various locations labeled by s.
08:32:58 <Funktorsalat> (or is the 'duplicate' somehow different)
08:33:00 <roconnor> with one location picked out.
08:33:24 <Funktorsalat> I only see a single 'a'
08:33:39 <roconnor> there are many a's, one for each s.
08:33:46 <Funktorsalat> my def wasn't right then?
08:33:58 <roconnor> Funktorsalat: oh the Foo you wrote is wrong
08:34:00 <roconnor> sorry
08:34:07 <Funktorsalat> Foo s a = Foo (s -> a) s then?
08:34:12 <roconnor> yes
08:34:14 <Funktorsalat> ok that makes more sense ;)
08:34:14 <roconnor> my bad
08:34:21 <Phyx-> anyone here use windows?
08:34:26 <roconnor> I glaced at what you wrote and it looked right :D
08:34:29 <roconnor> *glanced
08:35:11 <Funktorsalat> roconnor: 'position comonad'?
08:37:15 <roconnor> I don't mind it so much, but the problem is all comonad have a position aspect to them.  
08:37:23 <polarina> Why can I not find the documentation for Language.Hasekell.TH on Hackage?
08:37:35 <roconnor> All comonads are more or less a selected value in some sort of context
08:37:53 <roconnor> the thing that differs between the comonads is what exactly that context is
08:38:16 <roconnor> in this case the context is a bunch of A's indexed by S's.
08:38:31 <roconnor> and the only structure is whatever structure S might have.
08:38:53 <roconnor> soo Foo Nat because the horribly named "stream-with-position" comonad
08:40:28 <roconnor> optolectic means something like "to chose from a gathering"
08:40:30 <Funktorsalat> I see the problem, but it really isn't much of a stream for type without a clear total order :)
08:41:02 <roconnor> yes, it is specifically "Foo Nat" that is a stream
08:41:25 <roconnor> but "foo s" isn't in general stream like
08:42:02 <roconnor> (optolectic also could mean something like "to choose from a reading")
08:42:41 <Funktorsalat> 'costate' is far from obvious too but neat
08:42:45 <Phyx-> does anyone know where this cabal.exe: dependencies conflict: ghc-6.12.1 requires Cabal ==1.8.0.2 however' if coming from?
08:43:06 <Funktorsalat> (State s = (s ->) . (,s))
08:43:07 <roconnor> 'costate' certainly is not a lie
08:43:25 <roconnor> "elector" means something like "from a gathering"
08:43:25 <Funktorsalat> (CoState s = (,s) . (s ->))
08:43:26 <Funktorsalat> :)
08:43:51 <roconnor> "selector" means something like "apart from a gathering"
08:52:06 <roconnor> I like opt- better because it conveys a selecting-one-ness that elector and selector don't quite have
08:52:48 <roconnor> but then again comonad already has a selecting-one-ness built into it
08:59:23 <McManiaC> http://n-sch.de/hdocs/rebindable-if/Rebindable-If.html
08:59:30 <McManiaC> :)
09:01:16 <roconnor> opt- also means eye...
09:11:26 <ManateeLazyCat> G'night all! :)
09:22:47 <paolino> McManiaC: what is that, if is polymorphic ?
09:23:17 <McManiaC> I wrote a whole blog post about it: http://blog.n-sch.de/2010/11/27/rebindable-if-then-else-expressions/
09:23:20 <McManiaC> :D
09:23:26 <paolino> "if" is polymorphic ?
09:23:34 <McManiaC> with that extension, yeah
09:23:46 <sipa> now it is polymorphic too :)
09:24:04 <sipa> (if a then b else c) can be of any type
09:25:39 <mreh> I've just tried to recompile with -static -fforce-recomp and the binary is still the same size
09:25:54 * Funktorsalat has a stupidly simple generics scheme in mind: TH functions to translate ADTs to (,)-Either-form
09:26:01 <Funktorsalat> what am I missing?
09:26:39 <Funktorsalat> it wouldn't be as powerful as syb or so, but enough for many things, I think
09:26:52 <Funktorsalat> (for typeclasses which have inductive instances for (,) and Either)
09:27:01 <paolino> McManiaC: how does it work ? I see you use the extension in the example not in the Rebindable.If module
09:27:49 <McManiaC> paolino: with RebindableSyntax the if expression takes whatever "ifThenElse" function is in scope
09:28:02 <sipa> Funktorsalat: that would transform data Foo = Foo1 | Foo2 to Either () () ?
09:28:09 <McManiaC> paolino: but of course I dont need that extension to define such a function :)
09:28:12 <Funktorsalat> sipa: yeah
09:28:34 <sipa> Funktorsalat: and Bool too to Either () () ?
09:28:39 <Funktorsalat> . o O ( TFSG ( "the, frankly, simple, generics" ) )
09:28:52 <Funktorsalat> sipa: sure, Bool = True | False
09:29:46 <sipa> Funktorsalat: ok, image i have a data Dir = Left | Right, and data Bool = True | False, and both are instances of a single type class
09:29:52 <sipa> how will you distinguish them?
09:30:01 <sipa> *imagine
09:30:30 <Funktorsalat> sipa: why would you want to? e.g. to derive a serializer
09:30:31 <roconnor> Cale: googling shows that Ross Geoghegan uses the term "pointed function" for a function between pointed sets.
09:30:37 <sipa> Funktorsalat: eg. Show?
09:30:39 <Funktorsalat> (where the type is usually determined from context)
09:30:47 <roconnor> not that this alone makes me dismiss such a term.
09:31:09 <Funktorsalat> sipa: well yes, 'Show' would need to know about ctor names
09:31:42 <sipa> and where would it get those from?
09:31:56 <sipa> if you transform both to the same type
09:32:13 <Funktorsalat> that'd be a separate TH function
09:32:27 <Funktorsalat> but many classes don't even seem to need the names
09:32:47 <Funktorsalat> Eq, Ord, Monoid, serializers, ..
09:33:14 <Funktorsalat> though Monoid doesn't work for Either in general I guess
09:33:39 <Funktorsalat> hmm... instance (Monoid a, Monoid b) => Monoid [Either a b] though :)
09:33:43 <Funktorsalat> (free product)
09:33:48 <Cale> roconnor: Well, yeah...
09:34:41 <sipa> Funktorsalat: you could transform data a = B c d | E f g ... into a (TypeRep a, Either (c,d) (f,g))
09:35:02 <sipa> so you can still pattern-match on something representing the type constructor
09:35:17 <mightybyte> @seen edwardk
09:35:17 <preflex>  edwardk was last seen on #haskell 14 hours, 11 minutes and 14 seconds ago, saying: preflex: xseen jbapple
09:35:17 <lambdabot> Unknown command, try @list
09:35:25 <roconnor> Eric Goubault and Samuel Mimram also use pointed function to mean a function (actually a homomorphism) between pointed sets
09:35:59 <Funktorsalat> sipa: that wouldn't have to be part of the eitheri-tuplifier though
09:36:13 <Funktorsalat> (do you mean type reps from Typeable?)
09:37:21 <sipa> hmm, not sure that would work
09:37:31 <sipa> i guess it would
09:38:04 <Funktorsalat> sipa: instance (Typeable a, Typeable b, Show' a, Show' b) => Show' (a,b)
09:38:35 <Funktorsalat> hmm maybe not quite like that ;)
09:38:55 <Funktorsalat> (for showing the tuple you don't need the ctor names, yes)
09:40:52 <Cale> roconnor: pointed function is definitely also used for functions between pointed sets which preserve the point
09:46:31 <burp> hm, can I hide single class instances on import?
09:47:00 <sipa> i don't think so
09:47:05 <c_wraith> No, you can't hide instances at all
09:47:36 <c_wraith> if you import a module that contains an instance, directly or transitively, you get that instance
09:48:40 <burp> hm, I wanted to write my own "Binary Double" instance for the Data.Binary package
09:48:58 <burp> so if there is no way to hide the original one, I can't use it
09:49:01 <sipa> maybe you want to use a newtyped wrapper type around it
09:49:02 <polarina> burp, newtype MyDouble = Double
09:49:26 <burp> hm yes newtype sounds good
09:49:33 <burp> was using some Data wrapper for now
09:51:11 <datenwolf> There's this OpenGL with Haskell tutorial there: http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
09:51:21 <datenwolf> Unfortunately it has a (common) beginner mistake:
09:52:05 <burp> polarina: not sure this works 
09:52:12 <unkanon> datenwolf: don't leave us hanging
09:52:17 <datenwolf> The projection matrices are set in the Reshape callback. However all OpenGL rendering state should be done in the Display function. 
09:52:18 <burp> "The constructor of a newtype must have exactly one field      but `Double' has none"
09:52:37 <sipa> burp: newtype MyDouble = MyDouble Double
09:52:53 <sipa> you need a constructor as well, which polarina forgot to mention, i think
09:53:01 <burp> ok :)
09:53:07 <datenwolf> I now wonder: The window dimensions, required to determine the projections, are delivered by Reshape. What's the most elegant way to pass them to Display?
09:54:07 <sipa> burp: you also may want to have a deriving (Eq,Ord,Num) and the necessary language extensions, so you don't need to write each other instance yourself for MyDouble
09:54:58 <opqdonut> generalized newtype deriving rocks
09:55:21 <lars9> @hoogle abort
09:55:21 <lambdabot> Foreign.C.Error eCONNABORTED :: Errno
09:55:21 <lambdabot> Test.QuickCheck.Batch TestAborted :: Exception -> TestResult
10:09:01 <astroboy> If I have defined a data type with the record syntax, is there a way to modify just one element of it?
10:09:38 <Funktorsalat> astroboy: a { b = c }
10:09:54 <Funktorsalat> (where a is a value of the type of the record, b is the field name)
10:10:15 <astroboy> Funktorsalat: thanks
10:11:00 <astroboy> if I have b as a variable inside a function would it work anyway?
10:12:14 <Funktorsalat> no, b must be the literal field name
10:12:28 <Funktorsalat> there's the 'fclabels' package for first-class record updaters
10:13:40 <astroboy> Funktorsalat: mhm ok... thanks
10:16:04 <McManiaC> lol: http://sl.pastebin.com/dA9Aczg7
10:20:02 <paolino> oh, associativity of  <$> seems changed in 7.0.1 
10:20:17 <aristid> paolino: what is it now?
10:20:39 <paolino> :t path <$> extrude "ciao" <$> left t' 
10:20:39 <paolino> path <$> extrude "ciao" <$> left t' :: Maybe [String]
10:20:40 <lambdabot> Not in scope: `extrude'
10:20:40 <lambdabot> Not in scope: `t''
10:20:50 <paolino> this is 6.12.3
10:20:54 <aristid> paolino: :info (<$>)
10:21:08 <sipa> :info (<$>)
10:21:30 <paolino> *Main Control.Applicative> :t path <$> extrude "ciao" <$> left t' 
10:21:30 <paolino> <interactive>:1:6:
10:21:30 <paolino>     No instance for (Functor ((->) (Zipped Integer)))
10:21:30 <paolino>       arising from a use of `<$>'
10:21:36 <paolino> this is 7.0.1
10:22:17 <paolino> *Main Control.Applicative> :info <$>
10:22:17 <paolino> (<$>) :: Functor f => (a -> b) -> f a -> f b
10:22:17 <paolino>   	-- Defined in Data.Functor
10:22:17 <paolino> infixl 4 <$>
10:22:38 <aristid> paolino: import Control.Monad.Instances!
10:23:07 <aristid> paolino: infixl 4 <$> is 6.12.3?
10:23:25 <paolino> both
10:23:25 <sipa> does that depend on the compiler?
10:24:19 <djahandarie> It doesn't
10:25:07 <djahandarie> It could have changed in base, or they entirely changed how infix operators worked, but I highly doubt this. A lot of things would have broken
10:25:17 * djahandarie doesn't have a 7.0.1 to test
10:25:54 <paolino> ok, now I need  import Control.Monad.Instances to make it work
10:26:11 <paolino> this is not fair :)
10:27:15 <aristid> paolino: well, i think the difference is that some module used to indirectly import Control.Monad.Instances for you
10:27:19 <aristid> and now it does not anymore
10:27:31 <paolino> Control.Applicative
10:27:43 <paolino> or Data.Maybe
10:27:51 <aristid> yeah
10:28:28 <alvivi> What is the most elegant way to wrap a C function like int get_inf(char *request, void *data)? There are almost 30 different requests and another 6 different types of return values.  
10:29:04 <paolino> aristid: most of my code will break for this
10:29:29 <aristid> paolino: just import Control.Monad.Instances everywhere.
10:29:42 <paolino> Just
10:30:47 <djahandarie> Just go back to using 6.12.3. 7.0.1 isn't even in Haskell Platform yet
10:30:58 <polarina> Why all the synonyms such as {type LitQ = Q Lit} in Language.Haskell.TH?
10:35:40 <mreh> @src Result
10:35:41 <lambdabot> Source not found. :(
10:36:07 <Funktorsalat> hint to get stuff working with 7.0.1: delete 'containers < 0.4' constraints
10:36:56 <mreh> woo LLVN
10:36:58 <mreh> LLVM
10:37:16 <mreh> that's almost an roman numeral
10:42:36 <aavogt> polarina: it looks prettier: that's only one word to type
10:43:37 <opqdonut> alvivi: I'd start with making an ADT of the requests and return values
10:43:55 <aavogt> the more serious explanation is that such is the style that whoever wrote TH chose
10:46:29 <alvivi> opqdonut: But, then I have to create a function for each return value type?
10:47:24 <opqdonut> yes
11:00:35 <Funktorsalat> LitQ is also easier to type than QLit somehow
11:00:56 <aavogt> maybe it's just habit now
11:01:22 <aavogt> @hoogle lame
11:01:23 <lambdabot> Language.Haskell.TH LamE :: [Pat] -> Exp -> Exp
11:01:23 <lambdabot> Language.Haskell.TH.Syntax LamE :: [Pat] -> Exp -> Exp
11:01:23 <lambdabot> Language.Haskell.TH lamE :: [PatQ] -> ExpQ -> ExpQ
11:01:58 <aavogt> @hoogle viewp
11:01:58 <lambdabot> No results found
11:02:58 <unkanon> is TH fairly modern? no haskell books mentionit, etc
11:03:14 <unkanon> modern, recent, you now what I mean 
11:03:19 <aavogt> unkanon: lots of books are newer than it
11:03:30 <unkanon> lots of haskell books?
11:03:32 <aavogt> it started roughly 2002? I think
11:04:00 <Twey> Recent but still unstable AIUI
11:05:16 <unkanon> it reminds me of some ML-ish language I forgot the name, that has a function that you can pass it the syntax of the language you want to create, and it will give you the AST for it, or something like that
11:05:38 <msieradzki> how do I get cabal-install for 7.0.1?
11:05:42 <unkanon> I remember reading the slides for a presentation on that language
11:05:50 <aavogt> unkanon: LYAH, RWH, programming in haskell
11:05:57 <Twey> unkanon: Nemerle, maybe?
11:06:23 <unkanon> Twey: I don't think so, isn't Nemerle the one tied with .Net? It wasn't that...
11:06:48 <unkanon> aavogt: right
11:06:50 <aavogt> msieradzki: if you use your older cabal install (the one that worked with 6.12.3) and change the ghc in your PATH, stuff seems to work
11:06:51 <Twey> Yeah
11:08:08 <nejucomo> Hoogle seems down.  Is there something like: a -> [a -> b] -> [b]   ?
11:08:22 <aavogt> @type map . id
11:08:23 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
11:08:37 <aavogt> @type map . flip id
11:08:39 <lambdabot> forall b a. a -> [a -> b] -> [b]
11:08:51 <nejucomo> Thanks.
11:08:56 <nejucomo> :t id
11:08:57 <lambdabot> forall a. a -> a
11:09:05 <nejucomo> :t map . flip
11:09:06 <lambdabot> forall a (f :: * -> *) b. (Functor f) => f (a -> b) -> [a] -> [f b]
11:09:14 <nejucomo> :i id
11:09:43 <nejucomo> hm…  I don't understand the need to id yet.
11:09:54 <orlandu63> @type flip map
11:09:56 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
11:10:05 <orlandu63> oh wait nevemrind
11:10:23 <aavogt> ?ty flip id
11:10:24 <lambdabot> forall a b. a -> (a -> b) -> b
11:10:42 <msieradzki> aavogt, I had one from distro and now I switched to 7.0.1 package and cabal install 0.8.2
11:11:16 <aavogt> msieradzki: I have the same cabal-install, using version 1.8.0.6 of the Cabal library
11:11:17 <nejucomo> :t id
11:11:18 <lambdabot> forall a. a -> a
11:11:22 <nejucomo> :t flip id
11:11:23 <lambdabot> forall a b. a -> (a -> b) -> b
11:11:32 <nejucomo> :t flip
11:11:33 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:11:56 <orlandu63> @type (flip (<*>) . pure)
11:11:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => a -> f (a -> b) -> f b
11:13:36 <msieradzki> how do I get contents of darcs cabal install repo without darcs
11:13:47 <pkrumins> > map . flip id [1,2,3]
11:13:48 <lambdabot>   Overlapping instances for GHC.Show.Show
11:13:49 <lambdabot>                              (([t] ...
11:13:57 <pkrumins> > id [1,2,3]
11:13:59 <lambdabot>   [1,2,3]
11:14:12 <pkrumins> > flip . id [1,2,3]
11:14:13 <lambdabot>   No instance for (GHC.Num.Num (f (a -> b)))
11:14:13 <lambdabot>    arising from a use of `e_1123...
11:14:19 <pkrumins> > flip $ id [1,2,3]
11:14:20 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> [b])
11:14:20 <lambdabot>    arising from a use of...
11:14:23 <pkrumins> shrug
11:14:36 <nejucomo> Is there a Functor instance for (a -> b) ?
11:14:47 <sipa> @instances Functor
11:14:48 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
11:15:05 <sipa> so, yes
11:15:53 <djahandarie> No.
11:15:59 <djahandarie> The instance is for (a ->)
11:16:15 <djahandarie> Not (a -> b). It doesn't even have the correct kind
11:17:12 <aavogt> msieradzki: you can just ask ex. wget  to download the whole repo recursively
11:17:23 <msieradzki> -r I guess
11:17:27 <msieradzki> just found that out
11:21:39 <nejucomo> What I really want is an expression which is true only if all predicates against a value are true: t -> [t -> Bool] -> Bool
11:21:52 <nejucomo> Is this defined somewhere?
11:22:32 <c_wraith> :t all
11:22:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
11:22:51 <c_wraith> wait.
11:22:57 <c_wraith> you want something different.
11:23:56 <nejucomo> I just wrote: allPreds preds v = all [p v | p <- preds]
11:24:01 <orlandu63> @type all . zipWith ($) . repeat
11:24:02 <lambdabot>     Couldn't match expected type `Bool' against inferred type `[b]'
11:24:03 <lambdabot>     In the first argument of `(.)', namely `zipWith ($)'
11:24:03 <lambdabot>     In the second argument of `(.)', namely `zipWith ($) . repeat'
11:24:04 <nejucomo> But I'm sure there's some crazy zero point form.
11:24:14 <c_wraith> :t \x -> foldr ((&&) . ($ x)) False
11:24:15 <lambdabot> forall a. a -> [a -> Bool] -> Bool
11:24:26 <c_wraith> err, except for being wrong, that's close :)
11:24:30 <c_wraith> :t \x -> foldr ((&&) . ($ x)) True
11:24:32 <lambdabot> forall a. a -> [a -> Bool] -> Bool
11:24:54 <aavogt> no, all is good
11:25:03 <aavogt> @ty \x -> all ($ x)
11:25:04 <lambdabot> forall a. a -> [a -> Bool] -> Bool
11:25:24 <ziman> @unpl \x -> all ($ x)
11:25:24 <lambdabot> \ x -> all (\ a -> a x)
11:25:31 <ziman> @pl \x -> all ($ x)
11:25:31 <lambdabot> all . flip id
11:25:47 <nejucomo> :t all id [p v | p <- preds]
11:25:48 <lambdabot> Not in scope: `preds'
11:26:13 <nejucomo> :t \preds v -> all id [p v | p <- preds]
11:26:13 <lambdabot> forall t. [t -> Bool] -> t -> Bool
11:26:15 <aavogt> :t all id [p ?v | p <- ?preds]
11:26:16 <lambdabot> forall t. (?v::t, ?preds::[t -> Bool]) => Bool
11:26:32 <aavogt> :t and [p ?v | p <- ?preds]
11:26:33 <lambdabot> forall t. (?v::t, ?preds::[t -> Bool]) => Bool
11:26:44 <nejucomo> What are: ? and ::
11:26:46 <nejucomo> brb
11:28:37 <aavogt> @tell nejucomo ? is an implicit parameter, so instead of writing \x -> f x, you can write  f ?x, then it picks the ?x with the right type bound outermost. A better explation is probably in the ghc manual for -XImplicitParams
11:28:37 <lambdabot> Consider it noted.
11:29:21 <Funktorsalat> outermost?
11:29:30 <Funktorsalat> > let ?x = 1 in let ?x = 2 in ?x
11:29:31 <lambdabot>   2
11:29:47 <ziman> :t let ?x = 1 in let ?x = 2 in ?x
11:29:48 <lambdabot> forall t. (Num t) => t
11:30:10 <aavogt> @tell nejucomo innermost
11:30:10 <lambdabot> Consider it noted.
11:30:34 <aavogt> Funktorsalat: I meant one thing and said the other
12:03:09 <nejucomo> Why does this give me an "occurs check" failure?  http://codepad.org/VG8Gmuh2
12:03:10 <lambdabot> nejucomo: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:03:19 <nejucomo> There's still something I don't understand about class instances.
12:04:19 <aavogt> what's the class here?
12:09:30 <monochrom> I don't think it's a class instance problem. What's the type of testParse?
12:18:19 <burp> hm, libpcap has a callback handler, so it calls a function for each packet of data it received. I want to parse this data with Data.Binary, but the data in one packet might be incomplete
12:18:41 <burp> somehow I need to concatenate all received packets
12:18:56 <burp> any ideas? Control.Concurrect.Chan?
12:20:48 <maurer_> Does anyone know if there's a way using the LLVM bindings to generate a call that is not typesafe? The "call" operation seems to require the function to be typed, and if I am writring a compiler, the types of many of these functions will not be known until runtime.
12:21:16 <maurer_> Other than the "Call" operation, everything I'm doing can just be done with (Function a) => a, so I've been looking for some sort of unsafe version of call
12:33:39 <burp> basically I want to construct a lazy bytestring out of the single callback calls
12:37:24 <burp> hm, I feed a Chan with the callback function
12:38:01 <burp> and then just append all bytestrings in getChanContents
12:38:16 <burp> sounds reasonable to me
13:02:02 <burp> yeah, put them in a chan and concatenate them into a lazy bytestring with fromChunks
13:02:54 <R3v4n> hey guys.. i can i convert an int to an integer?
13:03:05 <R3v4n> how can i...
13:03:14 <lispy_> R3v4n: fromEnum
13:03:14 <burp> with fromIntegral
13:03:21 <lispy_> :t fromEnum
13:03:22 <lambdabot> forall a. (Enum a) => a -> Int
13:03:31 <lispy_> oops, yeah don't listen to me :)
13:03:37 <burp> :t fromIntegral
13:03:38 <lambdabot> forall a b. (Integral a, Num b) => a -> b
13:03:56 <burp> > fromIntegral (1 :: Int)  :: Integer
13:03:57 <lambdabot>   1
13:04:13 <lispy_> Actually, I wish fromEnum was type forall a. (Enum a, Integral b) => a -> b
13:04:29 <R3v4n> thanks
13:13:57 * hackagebot wumpus-tree 0.11.1 - Drawing trees  http://hackage.haskell.org/package/wumpus-tree-0.11.1 (StephenTetley)
13:14:45 <Manifesto> whats the command inside lambdabot to show the src of modules other than prelude?
13:16:15 <Saizan> @source Data.List
13:16:16 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
13:20:10 <Manifesto> sweet, thanks
13:22:25 <Nopik> hi all
13:23:39 <Nopik> suppose that i have some custom data type like Expr = Value Int | Plus Expr Expr | Minus Expr Expr  then some functions working on those values, like eval (or something which takes expression and draws a graph)
13:24:10 <Nopik> now, if my program is fairly complex, have gui and such, how most easily I can allow users to extend my datatypes? is that possible at all?
13:25:17 <Nopik> maybe via using instances instead?
13:26:17 <FunctorSalad_> Saizan: is @source new?
13:26:46 <FunctorSalad_> @source Text.XML.HXT.Arrow.XmlArrow
13:26:46 <lambdabot> Text.XML.HXT.Arrow.XmlArrow not available
13:30:28 <aavogt> Nopik: what sort of extension do you have in mind? Perhaps the data should contain the way it should be eval'd (ie. OO)
13:31:15 <Nopik> aavogt: yeah, i was considering that as well
13:31:44 <aristid> for all fans of (.:): http://hackage.haskell.org/packages/archive/functors/0.1/doc/html/Data-Functor-Syntax.html
13:32:02 <Nopik> aavogt: my program is supposed to work on abstract syntax trees (displaying them, allowing for modifications, translating to code). i want the user to be able to add new types of the nodes to the tree
13:32:30 <Nopik> aavogt: so, when new type of node will appear, a number of related entities need to be defined, like the way it should be calculated, displayed, translated etc.
13:33:03 <aavogt> so maybe the   data Node = Node { calculated, displayed, translated :: .. }
13:36:03 <Nopik> hm, interesting
13:36:40 <Nopik> though the amount of operation types might increase as well ;) yet, it is not so probable, especially if i'll be carefull
13:37:20 <aavogt> the other way (maybe this is nicer for people implementing), is to use typeclasses and have    data Node = forall a. Class a => Node a
13:37:57 <Nopik> aavogt: yeah, this is what i've got so far myself.. it might get easier
13:39:06 <Nopik> aavogt: forall is some valid construct or it is just a pseudocode?
13:39:23 <aavogt> with -XExistentialQuantification
13:40:22 <Nopik> ok, i'll check that
13:40:56 <aavogt> it'll give same result as the other Node definiton (which is more direct) nearly all the time
13:41:57 <Nopik> ok
13:42:21 <Nopik> thanks & bye
13:49:34 <lispy_> From within the a .cabal file can you do things conditionally based on the version of a package that cabal is picking?
13:49:56 <lispy_> I want to do conditional compilation based on the version of mtl that cabal selects
13:50:27 <lispy_> if impl(mtl > 1) ... or something like that
13:53:09 <aavogt> lispy_: add flags, such that one branch requires one version and the other needs a different version
13:54:00 <aavogt> so    if flag(old_mtl) { build-depends: mtl == 1.*; ... }
13:54:50 <aavogt> if cabal can't satisfy the depends in one branch, it'll try the flag off (at least if you didn't demand the flag being set one way)
13:56:15 <lispy_> aavogt: and have a later if flag(old_mtl) { cpp-options: -DMTL1 } ...
13:56:18 <lispy_> aavogt: ?
13:56:42 <aavogt> lispy_: cabal generates CPP macros for you
13:56:42 <ivanm> lispy_: yet another different nick? :p
13:56:50 <lispy_> ivanm: aye
13:56:58 <lispy_> aavogt: Hmm...Is that documented somewhere?
13:57:37 <aavogt> easiest is to   cabal configure, then look at    dist/build/autogen/cabal_macros.h
13:58:28 <aavogt> build systems seem to be the least covered in terms of introductory documentation
13:59:03 * aavogt was struggling to use scalaz
13:59:05 <ivanm> because by the time you get up to using a proper build system as opposed to ghc --make, you should be able to work out wtf stuff means yourself?
13:59:30 <aavogt> you don't need --make anymore!
13:59:39 <monochrom> ghc 7 has implicit --make
13:59:48 <monochrom> but do add --make to ghc 6.*
14:00:19 <monochrom> for non-toy projects you should cabalize and therefore specify list of packages you need, even base-4.
14:01:28 * aavogt wonders whether there's more breakage because versions get specified, or because they are left out
14:05:22 <lispy_> aavogt: So, cabal defines this for me: http://dpaste.com/280916/
14:05:39 <lispy_> aavogt: How would the CPP look?
14:05:59 <lispy_> #if VERSION_mtl < 2  /* This is ideally how I would write it */
14:06:40 <monochrom> if packages you need obeys the package versioning policy, there is little breakage with versions specified. normally 5.5.1 -> 5.5.2 means new things added but old things not deleted, 5.5 -> 5.6 means old things deleted, so most of the time you say you want "haha >= 5.5 && < 5.6". Unless you fear that 5.5.1 adds an instance that conflicts with yours.
14:07:25 <monochrom> err, "haha >= 5.5.1 && < 5.6", and "unless you fear that 5.5.1->5.5.2 adds an instance that conflicts with yours"
14:09:29 <monochrom> some famous packages such as base don't follow this policy. but they follow their own predictable policies, so you can still cope.
14:11:40 <ivanm> how does base not follow the policy?
14:12:01 <ivanm> and adding an instance for a pre-existing type requires major-version bump IIRC (see what happened with QC recently)
14:12:46 <aavogt> it has violated that policy before
14:13:26 <aavogt> or maybe the example I'm thinking of is (old-)time, where some formatting changed between bugfix versions
14:13:52 <aavogt> which caused issues with hdbc at least
14:15:26 <aavogt> this thread http://www.haskell.org/pipermail/haskell-cafe/2010-April/076693.html
14:16:06 <revenantphx> Hm, I have an interesting problem to solve. :\
14:16:33 <revenantphx> Well, nevermind for now I guess.
14:17:13 <monochrom> behavioral changes should be regarded as delete-old-and-add-new, of course
14:17:29 <pakbaz> too many people
14:17:59 <revenantphx> monochrom: How would I want to handle something like this:
14:18:01 <monochrom> this is why I couldn't care less about "meaningful" identifiers. they are never meaningful.
14:18:02 <ivanm> pakbaz: what about too many people?
14:18:09 <revenantphx> I have some amount of raw data, out of white packets can come.
14:18:13 <revenantphx> I may not have all of it though.
14:18:25 <pakbaz> this channel is crowded
14:18:26 <revenantphx> I may have enough for 1.5 packets or someting.
14:18:26 <monochrom> mnemonics, sure.
14:18:29 <ivanm> monochrom: ideally, a change like that would have a different type or something so that it is obvious that it no longer does exactly the same...
14:18:39 <ivanm> pakbaz: and yet there are only 5 of us talking at this time ;-)
14:19:09 <aavogt> > 6 / 637
14:19:10 <lambdabot>   9.419152276295133e-3
14:21:07 <monochrom> iteratee or enumerator allows writing code to cope with having just 1.5 packets and waiting for the rest. enumerator is a simpler variant of iteratee
14:21:54 <monochrom> if this channel is crowded, I'm not sure what you make of #ubuntu. maybe you call that a neutron star.
14:23:44 <pakbaz> I should check it out.
14:24:39 <pakbaz> Wow
14:24:55 <ivanm> yeah, this is nothing atm
14:24:56 * lispy_ fights with cabal
14:25:14 <ivanm> wait until there are 3 or 4 different conversations going at the same time, with several people involved in more than one of them :p
14:25:26 <lispy_> can you get cabal to printout what value it picked for the flags?
14:25:37 <dixie> hmm. how to canonize URL ? something like http://localhost/java/legal/../technotes/tools/../../technotes/tools/../../technotes/tools/../../technotes/tools/../../technotes/tools/../../technotes/tools/index.html 
14:25:45 <monochrom> you now understand what it is like during the early moments of big bang and quark-gluon plasma etc. :)
14:25:57 <lispy_> --flags=-old_mtl  <-- that means old_mtl is false?
14:27:28 <ivanm> yup
14:29:58 <lispy_> oh, I think I have it working now
14:31:07 <hpc> dixie: start by splitting by '/'
14:31:25 <hpc> dixie: you can replace /./ with nothing, and /foo/../ with /
14:31:38 <hpc> other rules are possible, i think
14:31:51 <ivanm> and // with /
14:31:54 <pkrumins> that's not a good way
14:31:55 <revenantphx> What's the proper data type for a large block of bytes?
14:31:59 <pkrumins> use proper module
14:31:59 <revenantphx> raw data in other words.
14:32:02 <ivanm> revenantphx: bytestring
14:32:03 <pkrumins> URI
14:32:08 <ivanm> if it's _really_ big, use the lazy one
14:32:15 <revenantphx> It's not *that* big.
14:32:22 <pkrumins> use URI::URL there
14:32:25 <ivanm> pkrumins: assuming, of course, that there's a canonicalisation function
14:32:26 <revenantphx> 1kb maximum
14:32:31 <ivanm> pkrumins: Haskell, not perl ;-)
14:32:35 <pkrumins> oops
14:32:38 <pkrumins> wrong channel
14:32:38 <ivanm> :D
14:32:48 <pkrumins> thought this was #perl
14:32:49 <pkrumins> sorry
14:33:05 <geheimdienst> > uRI :: URL
14:33:06 <lambdabot>   Not in scope: type constructor or class `URL'Not in scope: `uRI'
14:33:11 <hpc> hehe
14:33:11 <geheimdienst> > URI :: URL
14:33:12 <lambdabot>   Not in scope: type constructor or class `URL'Not in scope: data constructor...
14:33:15 <hpc> :t (::)
14:33:16 <lambdabot> parse error on input `::'
14:33:31 <dibblego> is labelled pattern matching a short-hand for if fieldOf x == y then ... or does it generalise further?
14:34:18 <dixie> hpc: I'll try that. I expected something already within Network.URL or Network.URI :)
14:34:25 <ivanm> dibblego: as in "foo Bar {x = 2} = ... " ?
14:34:31 <dibblego> ivan, yes
14:34:37 <dibblego> ivanm, 
14:34:38 <ivanm> then yeah, that's basically it
14:34:41 <hpc> dixie: there probably is; i just assume there isn't by default
14:34:53 <ivanm> note that you don't have to match on all the fields
14:34:58 <dibblego> righto ta
14:35:09 <hpc> mostly because i am not very good at remembering libs
14:39:17 <Jiten> dixie: I'm not entirely sure but normalizePathSegments in Network.URI sounds like it might be what you want.
14:40:29 <revenantphx> Is there a shorthand for
14:40:42 <revenantphx> import Data.Int, import Data.Word, import Data.ByteString
14:40:46 <Jiten> dixie: ok, just tested it, that's it.
14:41:13 <lispy_> revenantphx: nope
14:41:17 <pastorn> revenantphx: you could always make a madule that just reexports stuff
14:41:24 <revenantphx> ....?
14:41:28 <pastorn> revenantphx: but you can't export qualified stuff
14:41:29 <dixie> great. thanks.
14:41:40 <revenantphx> I'm just wondering if theres a import Data.(Int, Word, ByteString) type thing
14:41:42 <revenantphx> that's all.
14:42:10 <Jiten> there's also 2 other normalize functions in there. Handy if you want to only visit each URL just once :)
14:42:14 <pastorn> module MyData (module Data.Word, module Data.Int, module Data.ByteString) where; import Data.Word; import Data.Int; import Data.ByteString
14:42:18 <dixie> Jiten: I checked both Network.URL and Network.URI but I overlooked this one. 
14:42:40 <lispy_> revenantphx: that might be a good extension to the language, but it doesn't currently exist
14:43:26 <Cale> http://www.flickr.com/photos/cgibbard/ -- new construction :)
14:43:57 <ion> Neat
14:44:13 <djahandarie> Cale, nice
14:46:54 <lispy_> Cale: nice.  Those are fun.  A bunch of us at work have those
14:48:01 <he2> huhu
14:48:14 <he2> hi eoc` 
14:48:25 <Cale> lispy_: :)
14:48:47 <Cale> lispy_: Take pictures of your constructions! :)
15:01:14 <unkanon> what am I missing here to avoid liftM3?
15:01:16 <unkanon> > (+) <$> (Just 5) <*> (Just 6) <*> (Just 4) <*> (Just 3)
15:01:17 <lambdabot>   Just 11
15:01:33 <unkanon> > (Just (+)) `ap` (Just 5) `ap` (Just 6) `ap` (Just 4)
15:01:35 <lambdabot>   Just 11
15:01:40 <unkanon> I meant this last line
15:02:22 <Twey> Sorry?
15:02:27 <Twey> You don't need any of those brackets
15:02:33 * hackagebot multirec-alt-deriver 0.1.2 - Alternative multirec instances deriver  http://hackage.haskell.org/package/multirec-alt-deriver-0.1.2 (DanielSchuessler)
15:02:36 <Twey> In either line (apart from the operator section)
15:02:43 <unkanon> isn't ap used to avoid having to write liftM8 etc?
15:02:56 <Twey> ap = (<*>)
15:02:58 <Twey> Just on monads
15:03:20 <unkanon> right
15:03:30 <unkanon> but see
15:03:47 <unkanon> liftM3 (+) Just 5 Just 6 Just 4
15:03:51 <unkanon> > liftM3 (+) Just 5 Just 6 Just 4
15:03:52 <lambdabot>   Couldn't match expected type `a3 -> t -> t1 -> t2'
15:03:53 <lambdabot>         against inferred...
15:03:55 <Twey> (you need the brackets there)
15:04:05 <unkanon> > liftM3 (+) (Just 5) (Just 6) (Just 4)
15:04:06 <lambdabot>   Just 11
15:04:13 <Twey> er
15:04:16 <unkanon> ??
15:04:24 <Twey> That works because of a crazy Num instance in λb
15:04:41 <Twey> Normally, (+) takes only two arguments, so you can't apply it to three
15:04:50 <unkanon> oh...
15:05:06 <Twey> λb has an instance like this:
15:05:36 <Twey> > ((2 +) * (1 +)) 3
15:05:37 <lambdabot>   20
15:06:08 <unkanon> what's lambda-b?
15:06:12 <Twey> lambdabot
15:06:16 <aavogt> > ((2 +) * (1 +)) x :: Expr
15:06:17 <lambdabot>   (2 + x) * (1 + x)
15:07:04 <unkanon> ok, then why doesn't this work:
15:07:05 <unkanon> > liftM3 (++) (Just "5") (Just "6") (Just "4")
15:07:06 <lambdabot>   Couldn't match expected type `a3 -> r'
15:07:06 <lambdabot>         against inferred type `[GHC....
15:07:15 <unkanon> @more
15:07:24 <shachaf> For the same reason (++) "5" "6" "4" doesn't work.
15:07:34 <shachaf> liftM3 isn't magic.
15:07:36 <unkanon> so it's not like a fold?
15:07:52 <unkanon> I don't know why I was thinking it was like a fold...
15:07:54 <shachaf> No. It just lifts a function.
15:08:08 <unkanon> ok then
15:08:21 <unkanon> @let sum3 x y z = x + y + z
15:08:22 <lambdabot>  Defined.
15:08:28 <unkanon> > liftM3 (sum3) (Just "5") (Just "6") (Just "4")
15:08:29 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
15:08:30 <lambdabot>    arising from a use of `L....
15:08:31 <unkanon> oops
15:08:39 <unkanon> > liftM3 (sum3) (Just 5) (Just 6) (Just 4)
15:08:41 <lambdabot>   Just 15
15:08:52 <unkanon> ok now I want to make this work with <*>
15:09:13 <unkanon> > (sum3) <*> (Just 5) <*> (Just 6) <*> (Just 4)
15:09:14 <lambdabot>   Couldn't match expected type `(a -> b) -> a -> b'
15:09:15 <lambdabot>         against inferred ...
15:09:17 <alej> > sum3 <$> Just 5 <*> Just 4 <*> Just 3
15:09:18 <lambdabot>   Just 12
15:09:21 <unkanon> > (sum3) <$> (Just 5) <*> (Just 6) <*> (Just 4)
15:09:22 <lambdabot>   Just 15
15:09:41 <unkanon> ok, hmm..
15:10:14 <unkanon> > (Just sum3) <*> (Just 5) <*> (Just 6) <*> (Just 4)
15:10:15 <lambdabot>   Just 15
15:10:16 <shachaf> unkanon: You don't need to keep adding those parentheses. (Function) application binds tightest.
15:10:18 <unkanon> oh I get it
15:10:43 <unkanon> shachaf: I add the parentheses so that I don't have to fight with the precedence while I'm learning :)
15:13:12 <unkanon> @src <$> works but @src <*> doesn't, weird.
15:13:13 <lambdabot> Source not found. There are some things that I just don't know.
15:13:23 <unkanon> I mean those with parentheses
15:13:52 <hpc> @src <$>
15:13:53 <lambdabot> f <$> a = fmap f a
15:14:02 <hpc> @src .
15:14:03 <lambdabot> (f . g) x = f (g x)
15:14:03 <lambdabot> NB: In lambdabot,  (.) = fmap
15:14:11 <hpc> @src fmap
15:14:12 <lambdabot> Source not found. Just try something else.
15:14:32 <hpc> unkanon: you can view source of (<$>) because it isn't part of the applicative typeclass
15:14:34 <unkanon> should <*> be fmap id?
15:14:44 <hpc> :t fmap id
15:14:45 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
15:14:49 <unkanon> because ap is liftM2 id
15:14:51 <hpc> fmap id = id
15:15:01 <hpc> liftM2 /= fmap
15:15:04 <unkanon> hmm then no
15:15:12 <unkanon> yeah but they do similar things... maybe?
15:15:44 <hpc> you can implement (<*>) from Monad, but not from Functor
15:15:48 <hpc> @src ap
15:15:48 <lambdabot> ap = liftM2 id
15:17:20 <unkanon> liftM lifts a function to work with monadic values, and fmap lifts a function to work with values inside functors, and in that way they are similar, right?
15:17:30 <companion_cube> yeah
15:17:42 <companion_cube> since most monads are functors, i think
15:18:36 <hpc> there's a proposal going around to have Monad require Functor
15:18:44 <unkanon> that's a good thing, no?
15:18:44 <hpc> iirc
15:18:56 <hpc> not all monads are functors, and for somewhat dumb reasons
15:19:03 <djahandarie> companion_cube, theoretically all monads are functors.
15:19:14 <djahandarie> companion_cube, but talking about Haskell type classes, not all Monads are Functors
15:19:16 <unkanon> aren't all monads in the stdlibs functors anyway?
15:19:17 <companion_cube> yes, but in fact, this is not enforced
15:19:53 <unkanon> @type (<*>)
15:19:54 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
15:20:04 <hpc> @src (->) (<*>)
15:20:05 <lambdabot> (<*>) f g x = f x (g x)
15:20:07 <djahandarie> If there isn't a trivial Functor definition from your Monad definition then your Monad is broken anyways.
15:20:24 <djahandarie> (Broken in the sense that your Monad instance isn't an actual monad.)
15:20:30 <hpc> you can write (<*>) with fmap and join, i think, but then you have a monad constraint as well
15:20:36 <djahandarie> We need different words for talking about this stuff...
15:20:39 <unkanon> hpc: what does that mean? what you did there with @src
15:20:46 <hpc> unkanon: specifies an instance
15:20:54 <unkanon> oh like when I do
15:20:59 <unkanon> @src [] fmap
15:20:59 <lambdabot> fmap = map
15:21:01 <unkanon> ok
15:21:02 <hpc> unkanon: (<*>) is defined in a typeclass, so different types have different bodies
15:21:08 <hpc> @src Maybe fmap
15:21:09 <lambdabot> fmap _ Nothing       = Nothing
15:21:09 <lambdabot> fmap f (Just a)      = Just (f a)
15:21:50 <unkanon> what instance is (->) ? how doyou readthat out loud? functor?
15:22:03 <unkanon> sorry, I'm being light on my space key for some reason
15:22:47 <hpc> unkanon: (->) is function
15:22:54 <hpc> when read out loud
15:23:58 <unkanon> well yes, but that's a bit weird. I read @src [] fmap as "give me the source of fmap as defined for lists". how do you read @src (->) (<*>) ?
15:25:48 <hpc> "give me the source of applicative whatever-it-is, as defined for functions"
15:26:39 <unkanon> hmm
15:27:02 <unkanon> so <*> is defined for each Applicative, but <$> is defined once for all Functors?
15:27:37 <sipa> :src (<$>)
15:27:39 <sipa> @src (<$>)
15:27:39 <lambdabot> f <$> a = fmap f a
15:27:48 <sipa> yes
15:27:51 <pkrumins> @src fmap
15:27:52 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:27:56 <pkrumins> :t fmap
15:27:57 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:28:07 <sipa> fmap is defined in the function instance
15:28:43 <unkanon> Functor instance you mean?
15:28:54 <pkrumins> i think fmap is language construct
15:28:57 <pkrumins> it doesnt hae source
15:29:08 <unkanon> yeah it does
15:29:13 <hpc> use the source, luke
15:29:18 <unkanon> @src Maybe fmap
15:29:18 <lambdabot> fmap _ Nothing       = Nothing
15:29:19 <lambdabot> fmap f (Just a)      = Just (f a)
15:29:21 <sipa> unkanon: Functor i mean indeed
15:29:23 <pkrumins> oh right!
15:29:24 <unkanon> @src [] fmap
15:29:24 <lambdabot> fmap = map
15:29:24 <unkanon> etc
15:29:26 <unkanon> sipa: :)
15:29:30 <pkrumins> fmap is defined for type classes
15:29:32 <ddarius> pkrumins: Haskell has relatively few language constructs and even most of those can be desugared into simpler things.
15:29:44 <Zao> Boo, the GHC bindist depends on GLIBC_2.9 :(
15:29:44 <ddarius> fmap is a method in the Functor type class.  There is nothing at all special about it.
15:29:53 <guy127917> hi, i wonder if someone might quickly help me. im looking for a function of type [a] -> [b] -> (a -> b -> c) -> [c] (same as zipWith) which returns the list of type c as the result of executing the function on each element of list a with each element of b
15:29:55 <pkrumins> yeah right.
15:29:57 <guy127917> basically a cross product
15:30:06 <sipa> ["case","class","data","default","deriving","do","else","forall" ,"if","import","in","infix","infixl","infixr","instance","let","module" ,"newtype","of","qualified","then","type","where","_" ,"foreign","ccall","as","safe","unsafe"]
15:30:16 <sipa> those are haskell keywords
15:30:16 <ddarius> guy127917: liftM2
15:30:43 <ddarius> forall isn't Haskell 98 or Haskell 2010.
15:30:51 <sipa> and neither are the FFI things
15:31:02 <ddarius> The FFI is Haskell 2010 and Haskell 98 + FFI.
15:32:36 <ziman> > let f if = id if in f 3
15:32:37 <lambdabot>   <no location info>: parse error on input `if'
15:32:55 <ziman> > let f if = id in f 3 3
15:32:57 <lambdabot>   <no location info>: parse error on input `if'
15:33:47 <hpc> sipa: that doesn't include reserved symbols like '='?
15:35:14 <sipa> hpc: i get it from here: http://hackage.haskell.org/packages/archive/hscolour/1.15/doc/html/src/Language-Haskell-HsColour-Classify.html
15:35:18 <guy127917> I dont see how liftM2 does what I'm looking for- it doesnt take lists as parameters?
15:35:29 <hpc> ah
15:35:39 <sipa> :t liftM2
15:35:40 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
15:35:40 <copumpkin> guy127917: it can take any monadic values
15:35:44 <Twey> guy127917: It takes motes as parameters
15:35:49 <Twey> guy127917: [] is a monad
15:36:06 <guy127917> ah
15:36:07 <sipa> @djinn [a] -> [b] -> (a -> b -> c) -> [c]
15:36:07 <lambdabot> Error: Undefined type []
15:36:54 <geheimdienst> > liftM2 (+) [1,2,3] [8,9,10]
15:36:55 <lambdabot>   [9,10,11,10,11,12,11,12,13]
15:36:59 <unkanon> @hoogle [a] -> [b] -> (a -> b -> c) -> [c]
15:37:00 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
15:37:00 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
15:37:00 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
15:37:04 <unkanon> sipa: djinn doesn't know lists
15:37:16 <Philonous> Twey, Is "mote" official parlance for "value with monadic type"? (I have no Idea, just inferred it from the type)
15:38:06 <Twey> Philonous: mjd_ suggested it
15:38:08 <Twey> http://blog.plover.com/prog/haskell/monad-terminology.html
15:38:33 <geheimdienst> guys, am i using liftM2 correctly? it seems it doesn't have the behavior of zipWith. it goes through the second list _for each_ elemente of the first list
15:38:52 <Twey> geheimdienst: liftM2 ≠ zipWith
15:38:59 <Twey> geheimdienst: Unless on ZipLists
15:39:17 <Twey> (that's the whole point of ZipLists, actually: they have the zipWith Applicative instance)
15:40:17 <jmcarthur> geheimdienst: liftA2 on ZipList would do what you want
15:40:24 <geheimdienst> so actually liftM2 isn't exactly what guy127917 was looking for
15:40:35 <geheimdienst> i see. thanks guys
15:41:57 <Twey> Hm, does ZipList have a Monad instance?  I don't remember
15:42:25 <jmcarthur> no
15:42:37 <guy127917> it definitely works for what i wanted
15:42:38 <jmcarthur> it can't be a monad unless it has static length
15:42:55 <ddarius> ZipLists aren't monads.
15:43:04 <guy127917> not sure i understand why a list is a monad though
15:43:40 <Philonous> Twey, Ah, I see. I'd prefer "mobit", just for the sound of it, but what the hell, "mote" it is.
15:43:43 <ddarius> geheimdienst: He spcifically said "cross product."
15:43:53 <ddarius> Philonous: "Mote" it isn't.
15:44:44 <Philonous> ddarius, It's not?
15:44:59 <ion> guy127917: List comprehensions are syntactic sugar for the monadic use of lists.
15:45:17 <ion> Most would agree they are useful.
15:45:56 <ddarius> Philonous: MJD is hardly the authority on diction in the Haskell community.
15:46:03 <djahandarie> I don't see why the hell we can't just agree on a word, it'd make things much clearer
15:46:29 <ddarius> djahandarie: We have agreed on a term "monadic value" is probably by far the most common.
15:46:40 <jmcarthur> why do we need a word? what makes a value special just because its type is formed in part by a type constructor which happens to form a monad?
15:46:52 <guy127917> i think i need to look at list comprehension a bit closer
15:47:04 <Philonous> ddarius, Yes, but it's quite a mouthful 
15:47:28 <unkanon> jmcarthur: can you elaborate on the static length thing?
15:47:44 <guy127917> the list comprehension page on the wiki seems to explain it though
15:47:45 <djahandarie> jmcarthur, why come up with a word for any construct?
15:47:48 <guy127917> cheers guys
15:47:48 <hpc> unkanon: unless the length is kept constant, you can't guarantee the monad laws
15:47:57 <djahandarie> jmcarthur, I could state all the monad laws instead of say "monad" every time I wanted to talk about one
15:48:01 <jmcarthur> djahandarie: my point is that it seems that this is making something special which is not special
15:48:02 <djahandarie> saying*
15:48:15 <jmcarthur> not special to me, at least
15:48:22 <djahandarie> jmcarthur, I think it's refered to enough to warrent a word for it
15:48:28 <unkanon> hpc: and the length of a list is always kept constant?
15:48:55 <hpc> unkanon: no; regular lists build permutations
15:49:14 <jmcarthur> unkanon: these are all monads:  data Two a = Two a a ; data Three a = Three a a a ; data Four a = Four a a a a
15:49:15 <hpc> unkanon: ziplists match first to first, second to second, etc; the former can satisfy the laws just fine by itself
15:49:27 <jmcarthur> unkanon: and they share semantics with ZipLists of those lengths
15:50:44 <jmcarthur> unkanon: join on those is basically taking the diagonal. that is, the first element of the result is the first element of the first element of the input. the second element of the result is the second element of the second element of the input. etc.
15:51:39 <unkanon> I see, but I thought zipLists are not Monads for some other reasons besides the length, namely that it doesn't satisfy the identity law ?
15:53:47 <unkanon> this is a bit over my head honestly
15:53:56 <jmcarthur> unkanon: it turns out the making the length static fixes that issue
15:54:26 <jmcarthur> i'm not sure which law(s) it doesn't satisfy with dynamic length though
15:54:58 <unkanon> the law that says you compose a function with id and you should get the same result or something?
15:56:20 <ddarius> unkanon: The reason the length issue is a problem is because it leads to the monad laws failing.  Otherwise length is neither here nor there with regards to being a monad.
15:57:06 <unkanon> but doesn't list have a variable length? and so it shouldn't be a monad?
15:59:26 <jmcarthur> that's not how it work
15:59:30 <jmcarthur> list has different semantics
15:59:34 <jmcarthur> *how it works
15:59:39 <ddarius> Again, length has nothing to do with being a monad in and of itself.
16:01:21 <unkanon> ok. I'll save this conversarion and come back to it in the near future
16:01:32 <Cale> The monad laws can be stated nicely in a memorable way in terms of return and <=<
16:02:14 <unkanon> return and <=< ? I've never heard that pair
16:02:35 <unkanon> Cale: you have the floor :)
16:02:48 <Cale> They are that: (1) return <=< f = f  (2) f <=< return = f  (3) (f <=< g) <=< h = f <=< (g <=< h)
16:03:02 <Cale> :t (<=<)
16:03:02 <hpc> @src <=<
16:03:02 <lambdabot> Source not found. It can only be attributed to human error.
16:03:02 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:03:09 <hpc> @src >=>
16:03:09 <lambdabot> Source not found. Where did you learn to type?
16:03:15 <hpc> pah
16:03:16 <magicman> @src (<=<)
16:03:16 <lambdabot> Source not found. I've seen penguins that can type better than that.
16:03:18 <magicman> :-/
16:03:19 <Cale> (f <=< g) x = f =<< g x
16:03:21 <unkanon> @src [] (<=<)
16:03:22 <lambdabot> Source not found. stty: unknown mode: doofus
16:03:50 * hackagebot kit 0.5 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.5 (NickPartridge)
16:04:08 <unkanon> hmm...
16:04:40 <Cale> (If you want to say it in a fancy way, the monad laws are saying that the Kleisli category satisfies the laws to be a category.)
16:06:33 <unkanon> http://haskell.org/haskellwiki/Pronunciation  doesn't teach how to pronounce <=<
16:06:50 <Cale> <=< is Kleisli composition
16:07:10 <Cale> It's analogous to (.), but monadic
16:07:22 <copumpkin> omnomadic
16:07:25 <Cale> (in the sense that return is analogous to id, but monadic)
16:08:15 <Cale> and just as id . f = f and f . id = f, and f . (g . h) = (f . g) . h, we have similar laws for return and (<=<), and those are the monad laws.
16:08:41 <unkanon> Cale: can you provide a trivial and contrived usage example of <=< with Maybe and adding up numbers inside Just ?
16:09:06 <ddarius> instance Monad m => Category (Kleisli m) where id = Kleisli return; (.) = (<=<)
16:09:21 <ddarius> + more un/wrapping
16:10:09 <Cale> > let dict = [(1,2),(2,3),(3,4)]; next x = lookup x dict in next <=< next $ 1
16:10:10 <lambdabot>   Just 3
16:10:15 <Cale> > let dict = [(1,2),(2,3),(3,4)]; next x = lookup x dict in next <=< next <=< next $ 1
16:10:15 <lambdabot>   Just 4
16:10:22 <Cale> > let dict = [(1,2),(2,3),(3,4)]; next x = lookup x dict in next <=< next <=< next <=< next $ 1
16:10:23 <lambdabot>   Nothing
16:11:09 <Cale> (Is that contrived enough?)
16:11:19 <unkanon> I'll tell you in a minute
16:11:32 <unkanon> gotta ask lambdabot some questions :)
16:11:38 <ddarius> Cale: That could be used for a very simple DFA.
16:14:53 <unkanon> Cale: I fully understand the code now
16:15:00 <unkanon> but not the wonders of <=< :)
16:15:24 <unkanon> it's like you created a "next of the next" function
16:15:44 <unkanon> in that sense I can see it being like a (.)
16:15:53 <Cale> unkanon: yeah
16:16:25 <Cale> I have two functions  Integer -> Maybe Integer, and I can compose them together to get a function of the same type.
16:17:57 <unkanon> > let dict = [(1,2),(2,3),(3,4)]; next x = lookup x dict in join (liftM next (next 1))
16:17:58 <lambdabot>   Just 3
16:18:06 <unkanon> so that's the trouble that <=< saves me
16:18:47 <Cale> > let dict = [(1,2),(2,3),(3,4)]; next x = lookup x dict in next =<< next 1
16:18:48 <lambdabot>   Just 3
16:18:54 <Cale> > let dict = [(1,2),(2,3),(3,4)]; next x = lookup x dict in next =<< next =<< next 1
16:18:55 <lambdabot>   Just 4
16:19:15 <Cale> Now suppose you want to abstract that away, and make it points-free.
16:19:23 <romildo> How does one download an image file in a Haskell program?
16:20:01 <hpc> the same way you download any other file
16:20:04 <unkanon> Cale: hmm there's little difference that I see between =<< and <=<
16:20:14 <Cale> romildo: Maybe the download or download-curl package?
16:20:25 <hpc> unkanon: compare \x -> f (g x) to (f . g)
16:20:32 <Cale> unkanon: The difference between =<< and <=< is the same as the difference between $ and .
16:20:35 <romildo> Cale, I will look at them.
16:20:41 <hpc> unkanon: now compare \x -> f =<< g x to (f >=> g)
16:21:03 <Cale> You mean f <=< g
16:21:06 <hpc> or more readibly, \x -> do y <- g x; x y
16:21:09 <hpc> yes, that
16:21:25 <hpc> and f y, not x y
16:22:03 <hpc> it's a way to combine the unreadability of unsugared monadic code and the unreadability of point-free code!
16:22:03 <unkanon> Cale: but $ doesn't even compose anything, and you composed with <=<
16:22:07 <hpc> huzzah!
16:22:26 <dfkjjkfd> is it possible to recover =<< from <=<?
16:22:32 <unkanon> hpc: and I'll need some more type to think about those comparisons 
16:22:38 <ddarius> dfkjjkfd: Of course.
16:23:03 <dfkjjkfd> i guess i should have thought about that before asking
16:23:42 <hpc> unkanon: try playing around with it in ghci on your own; get something simple that typechecks and see what it does
16:24:15 <unkanon> hpc: yeah that's what I'm doing now, this is very interesting stuff, I can feel my brain tickle
16:24:29 <ddarius> :t \m k -> (const m >=> k) ()
16:24:30 <lambdabot> forall (m :: * -> *) b c. (Monad m) => m b -> (b -> m c) -> m c
16:24:56 <dfkjjkfd> thanks
16:24:59 <hpc> :t \m k -> (const m . k) ()
16:25:00 <lambdabot> forall a a1. a -> (() -> a1) -> a
16:25:20 <hpc> huh
16:25:27 <mauke> const m (...) is m
16:25:35 <ddarius> hpc: You'll figure it out.  I have faith in you.
16:25:54 <hpc> ddarius: quiet you; :D
16:26:20 <Philonous> :t (>=>) id
16:26:21 <lambdabot> forall (m :: * -> *) b c. (Monad m) => (b -> m c) -> m b -> m c
16:26:25 <unkanon> I don't have <=< in ghci, how do I get it?
16:26:34 <unkanon> I've already :m Monad
16:26:37 <mauke> import Control.Monad
16:26:56 <unkanon> oh it had to have that Control. first
16:27:13 <copumpkin> did someone let ncatlab.org expire?
16:27:21 <unkanon> the thing is that the type sig for (<=<) is so spread out with a b and c
16:28:43 <Cale> unkanon: Other way around
16:28:50 <Cale> unkanon: <=< is analogous to composition
16:28:58 <Cale> unkanon: =<< is analogous to application
16:29:12 <ddarius> copumpkin: Did you notice that the Catsters teased us with a single video release a few months ago.
16:29:56 <Cale> I did
16:30:24 <unkanon> Cale: that's exactly what you said before
16:30:26 <copumpkin> I didn't :o
16:30:41 <unkanon> 19:20:05 < Cale> unkanon: The difference between =<< and <=< is the same as the difference between $ and .
16:30:47 <Cale> unkanon: Right
16:30:50 <unkanon> :)
16:30:55 <Cale> unkanon: <unkanon> Cale: but $ doesn't even compose anything, and you composed with <=<
16:31:07 <unkanon> right, I'm stupid
16:33:07 <arkonten> Say that I have a type "data D a b = A a | B b" (i.e. it has type * -> * -> *). Is there any way I can get something equivalent to it being an instance of Control.Applicative (or even Functor)?
16:35:23 <Cale> arkonten: Well, you can have  instance Functor (D a) where fmap f (A x) = A x; fmap f (B y) = B (f y)
16:36:10 <Cale> There will be similar instances of Applicative and Monad
16:37:22 <hpc> (for reference, this is how Either gets its instances)
16:39:08 <arkonten> Cale: but then fmap doesn't apply f on A x..?
16:39:39 <Cale> arkonten: Right, it couldn't.
16:40:11 <mauke> > fmap (+ 2) (Left "foo")
16:40:12 <lambdabot>   Left "foo"
16:40:37 <arkonten> I see.. that's unfortunate
16:40:43 <Cale> arkonten: You could create a class for bifunctors
16:41:14 <Cale> class Bifunctor f where bimap :: (a -> b) -> (c -> d) -> f a c -> f b d
16:41:18 <hpc> or make an instance where right and left are the same type
16:41:31 <Cale> Well, to do that, you'd need a newtype wrapper
16:41:46 <Cale> (to make the right and left types equal)
16:41:56 <hpc> yeah
16:42:07 <Cale> instance Bifunctor D where bimap f g (A x) = A (f x); bimap f g (B y) = B (g y)
16:42:09 <unkanon> Cale: =<< and <=< are really similar. in a way, though, there isn't much difference between $ and . either
16:42:14 <aavogt> type level lambdas, if they only existed
16:42:49 <Cale> unkanon: Note that the choice of operator associativity in both cases is conspiring to hide the difference.
16:43:06 <Eduard_Munteanu> Is there a standard function/idiom for breaking a list (rather a ByteString more specifically) into fixed-sized chunks? I'm looking for something like foo :: Int -> [a] -> [[a]]
16:43:36 <roconnor> Eduard_Munteanu: it is often called chunk
16:43:36 <Eduard_Munteanu> This is for parsing a binary file.
16:43:42 <roconnor> @hoogle chunk
16:43:42 <lambdabot> Data.ByteString.Lazy.Internal chunk :: ByteString -> ByteString -> ByteString
16:43:43 <lambdabot> Data.ByteString.Lazy.Internal Chunk :: ByteString -> ByteString -> ByteString
16:43:43 <lambdabot> Network.HTTP.Base chunkedTransfer :: BufferOp a -> IO (Result a) -> (Int -> IO (Result a)) -> IO (Result ([Header], a))
16:43:44 <arkonten> Cale: hpc: Thanks guys! I'll try out either of them!
16:43:46 <Cale> unkanon: It's  next =<< (next =<< (next 1)), but it's ((next <=< next) <=< next) 1
16:43:48 <roconnor> :(
16:44:06 <Cale> er, or maybe not on that second one
16:44:17 <unkanon> Cale: aren't . and $ really the same thing with different fixities?
16:44:23 <Cale> yeah, <=< is infixr
16:44:25 <unkanon> and so the same for <=< and =<< ?
16:44:32 <roconnor> Eduard_Munteanu: anyhow check out http://hackage.haskell.org/package/split
16:44:34 <mauke> wat
16:44:37 <Eduard_Munteanu> roconnor: Chunks seem to be bytes in Bytestrings.
16:44:38 <Cale> unkanon: (next <=< (next <=< next)) 1
16:44:40 * Eduard_Munteanu looks.
16:44:42 <Cale> unkanon: Absolutely not
16:44:48 <Cale> unkanon: They have different types.
16:44:53 <Cale> :t (.)
16:44:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:44:58 <Cale> heh, well
16:45:12 <Cale> (a -> b) -> (e -> a) -> (e -> b) for the standard instance ;)
16:45:14 <roconnor> Eduard_Munteanu: this library is for lists. I only refer you to it to see names of functions.
16:45:19 <copumpkin> :t (P..)
16:45:20 <lambdabot> Couldn't find qualified module.
16:45:26 <copumpkin> :(
16:45:30 <Cale> and ($) :: (a -> b) -> a -> b
16:45:45 <Eduard_Munteanu> roconnor: thanks, I found 'chunks'. Still looking for a ByteString equivalent, though I could do chunks . unpack
16:46:26 <Cale> unkanon: ($) takes a function and a value to which it can be applied and applies the function to the value
16:46:38 <Cale> unkanon: (.) takes two functions and composes them into another function
16:47:10 <Eduard_Munteanu> erm, 'chunk'
16:47:14 <unkanon> but both do things that I could to simply with ()
16:47:31 <mauke> unkanon: no, you couldn't
16:47:50 <mauke> x = sqrt . abs
16:47:53 <Cale> unkanon: Write (f . g) with only parens
16:48:01 <mauke> do that with ( ) and without .
16:48:03 <unkanon> f (g x)
16:48:08 <Cale> bzzt
16:48:13 <Cale> x isn't in scope
16:48:18 <unkanon> well yeah
16:48:36 <unkanon> x a = sqrt (abs a)
16:48:40 <unkanon> there ya go :)
16:48:51 <mauke> that does more than add parens
16:48:58 <mauke> you introduced a completely new variable 'a'
16:49:29 <unkanon> but the users of x would do the same (add a new variable) as soon as they used my function
16:49:35 <unkanon> except if they passed it around I guess
16:49:44 <unkanon> I think I see a glimpse of the point of (.)
16:49:49 <mauke> map (sqrt . abs) [-5 .. 5]
16:50:04 <unkanon> yeah that is a hard one to replace with parentheses
16:50:22 <nostrand> map (\x -> sqrt ( abs x) ) [-5..5
16:50:32 <unkanon> yes, I was going to do that
16:50:35 <Cale> Yeah, you need to insert a lambda :)
16:50:46 <unkanon> I was just typing it
16:50:48 <nostrand> which i think is much less readable =)
16:51:01 <unkanon> but nevertheless, . and $ are just sugar
16:51:03 <unkanon> for parentheses
16:51:06 <unkanon> and variables
16:51:08 <unkanon> and lambdas
16:51:12 <mauke> heh, "and variables and lambdas"
16:51:13 <unkanon> wow, a bunch of stuff really
16:51:20 <mauke> unkanon: what operator isn't?
16:51:23 <Cale> unkanon: So is everything
16:51:30 <nostrand> and haskell is just sugar for machine code ;)
16:51:41 <Eduard_Munteanu> I'm not sure I like code like this... a0 = map (readA0 . B.pack) . chunk 5 . B.unpack . B.take alen . B.tail $ bs
16:51:47 <sipa> nostrand: no, that's C
16:51:54 <Cale> Eduard_Munteanu: I do!
16:51:55 <unkanon> okay, so every operator is sugar for lambdas and variables and parentheses
16:51:58 <nostrand> sipa: :P
16:52:02 <hpc> machine code is sugar for voltages
16:52:15 <Cale> Eduard_Munteanu: Except for the awful qualified names, but those are hard to avoid
16:52:19 <sipa> and haskell is sugar for a lambda calculus machine :p
16:52:31 <Saizan> Eduard_Munteanu: those pack/unpack seem quite wasteful
16:52:31 <Eduard_Munteanu> Cale: aw, ok, I'll leave it like this then. I was about to turn it into imperative code :)
16:52:36 <nostrand> yeah, you're right sipa 
16:52:56 <Saizan> Eduard_Munteanu: you could write a bytestring chunk with a simple loop and splitAt
16:53:06 <Cale> Eduard_Munteanu: Well, you could introduce moar function definitions to break that up if it makes sense.
16:53:09 <sipa> nostrand: however, ghc is able to convert it into sugar for voltages ;)
16:53:12 <Eduard_Munteanu> Saizan: I kinda wanted to use 'chunk', but if there's a better approach... Basically I'm decoding tuples of (Word8, Word32)
16:53:19 <nostrand> sipa: =)
16:53:46 <Eduard_Munteanu> and I'm also using Data.Binary
16:55:06 <Eduard_Munteanu> Saizan: hm yeah, I'll try to do that.
16:55:06 <unkanon> mauke, Cale: ok, (.) might be awesome but $ is really just sugar for parentheses alone, come on now :)
16:55:18 <Cale> unkanon: ($) is still a function
16:55:24 <unkanon> yes I know
16:55:25 <hpc> ($) is magnificent section material
16:55:37 <Cale> > zipWith ($) [(+2),(*2),(^2)] [5,6,7]
16:55:37 <jmcarthur> unkanon: you can still pass ($) around as a value. it's not mere sugar
16:55:38 <lambdabot>   [7,12,49]
16:55:39 <hpc> > map ($ 5) [(+2), (*3)]
16:55:40 <lambdabot>   [7,15]
16:55:44 <unkanon> but every use of $ can be replaced by parentheses without needing extra lambdas and variables
16:55:48 <ddarius> (f $) the best section of them all
16:55:50 <mauke> unkanon: see above ^
16:55:54 <jmcarthur> unkanon: not every use. see cale's zipWith example
16:56:01 <Cale> unkanon: We just gave you two examples :P
16:56:21 <unkanon> yes I'm familiar with the zipwith example, that's the only one I know that passes ($) around
16:56:33 <Cale> Mind you, $ has another name. You could always replace it with id
16:56:33 <monochrom> now you know one more
16:56:46 <jmcarthur> unkanon: there are infinitely many such cases. come on
16:56:47 <hpc> Cale: not always; try doing it in my example
16:56:57 <hpc> :t (`id` 5)
16:56:58 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
16:57:00 <unkanon> > zipWith (id) [(+2),(*2),(^2)] [5,6,7]
16:57:01 <lambdabot>   [7,12,49]
16:57:03 <hpc> oh, i suppose you can
16:57:03 <Cale> > map (`id` 5) [(+2), (*3)]
16:57:04 <lambdabot>   [7,15]
16:57:09 <unkanon> Cale: done :)
16:57:13 <hpc> sneaky
16:57:13 <forall> haha lambda bot just mesaged me
16:57:24 <hpc> hahaha
16:57:26 <ddarius> Incidentally, (f $) is non-trivial.
16:57:28 <unkanon> haha
16:57:30 <sipa> ha
16:57:36 <sipa> skell?
16:57:40 <Cale> :t (runST $)
16:57:41 <lambdabot> forall a. (forall s. ST s a) -> a
16:57:47 <jmcarthur> hahahaskell
16:57:52 <Cale> hmm :)
16:58:05 <Cale> .oO(Is that really supposed to work?)
16:58:07 <jmcarthur> wtf
16:58:10 <jmcarthur> :t runST
16:58:11 <lambdabot> forall a. (forall s. ST s a) -> a
16:58:13 <Eduard_Munteanu> Aw crap, it sucks when you don't have constructors to pattern-match on. What to do, what to do... view patterns?
16:58:20 <jmcarthur> oh i misread it
16:58:28 <jmcarthur> :t \f -> (f $)
16:58:29 <lambdabot> forall a b. (a -> b) -> a -> b
16:58:32 <Eduard_Munteanu> Like for instance, matching an empty bytestring.
16:58:35 <mauke> :t id runST
16:58:35 <jmcarthur> it's just using ($) as id
16:58:36 <lambdabot> forall a. (forall s. ST s a) -> a
16:58:38 <unkanon> jmcarthur: I'm not arguing, just learning :)
16:58:42 <hpc> Eduard_Munteanu: guards!
16:58:44 <sipa> @pl \f -> (f $)
16:58:44 <lambdabot> id
16:58:48 <mauke> :t id id runST
16:58:50 <lambdabot>     Cannot match a monotype with `(forall s. ST s a) -> a'
16:58:50 <lambdabot>     Probable cause: `id' is applied to too many arguments
16:58:50 <lambdabot>     In the expression: id id runST
16:58:58 <hpc> foo x | notEmpty x = bar
16:59:03 <mauke> :t id (id runST)
16:59:04 <lambdabot> forall a. (forall s. ST s a) -> a
16:59:13 <hpc> :t id id id runST
16:59:13 <Eduard_Munteanu> hpc: hm, yes, that seems better, thanks.
16:59:14 <lambdabot>     Cannot match a monotype with `(forall s. ST s a) -> a'
16:59:14 <lambdabot>       Expected type: ((forall s. ST s a) -> a) -> t
16:59:15 <lambdabot>       Inferred type: a1 -> a1
16:59:30 <unkanon> mind you, I understand the zipWith ($) example but I don't understand why id works also
16:59:41 <copumpkin> hpc: that's pretty
16:59:53 <hpc> unkanon: here's a somewhat informal proof
17:00:01 <hpc> f $ x = f x
17:00:07 <hpc> ($) f x = f x
17:00:17 <hpc> ($) = \f -> \x -> f x
17:00:30 <hpc> ($) = \f -> f -- made pointfree
17:00:36 <hpc> id = \x -> x
17:00:42 <sipa> (a $ b) === (($) a b) === ((($) a) b) === (a b), this means that (($) a) === a
17:01:10 <unkanon> hpc: that is a really cool proof
17:01:17 <unkanon> sipa: I'm still digesting yours
17:01:26 <hpc> his is mine, compressed
17:01:27 <sipa> hpc's is more clear :)
17:01:28 <ddarius> Too bad it fails.
17:01:34 <mauke> ($) :: (a -> b) -> a -> b
17:01:37 <mauke> ($) :: (a -> b) -> (a -> b)
17:01:43 <mauke> ($) :: c -> c where c = a -> b
17:02:17 <unkanon> sipa: his is more believable, with yours it's harder to believe step 3 -> step 4
17:02:19 <ddarius> You youngin's and your belief in eta reduction.
17:02:35 <hpc> i did say informal ;)
17:03:07 <unkanon> hpc: ok I now understand that ($) is id
17:03:12 <unkanon> but id is so abstract still
17:03:30 <unkanon> I still don't understand why zipWith (id) should work (assuming I had never seen $)
17:03:31 <sipa> i think mauke's explanation is the clearest one :)
17:03:57 <hpc> mauke's explanation uses types, which is a better habit to get into
17:03:59 <sipa> $ is id, but restricted to function arguments
17:04:05 * hackagebot multirec-alt-deriver 0.1.3 - Alternative multirec instances deriver  http://hackage.haskell.org/package/multirec-alt-deriver-0.1.3 (DanielSchuessler)
17:04:10 <unkanon> yeah mauke's is really simple
17:04:15 <mauke> "function arguments" is a weird way to say "values"
17:04:16 <ddarius> mauke's explanation doesn't claim that ($) is id.
17:04:44 <sipa> true, it could be undefined too
17:04:46 <geheimdienst> i guess mauke showed that ($) is a special case of id
17:05:05 <sipa> mauke showed that ($)'s type is special case of id's type
17:05:07 <ddarius> All he showed was that ($)'s type is an instance of id's type.
17:05:23 <ddarius> ($)'s type is also an instance of unsafeCoerce's type.
17:05:48 <monochrom> zipWith id [f,g] [x,y] = [id f x, id g y] = [f x, g y]
17:06:32 <unkanon> monochrom: oh!
17:06:32 <mauke> unkanon: can you (without using ghci or lambdabot) derive the type of 'flip id'?
17:06:42 <sipa> disregarding unsafeThings, is there a formal way to prove that only id and (bottom) are values of type a -> a ?
17:06:57 <sipa> (or am i wrong?)
17:07:00 <ddarius> sipa: No because that's false.
17:07:03 <unkanon> mauke: I thought flip could only be used with functions of arity 2
17:07:04 <alvivi> There isn't any unsigned Int32 in GHC?
17:07:08 <ddarius> sipa: There id, undefined, and const undefined.
17:07:12 <ddarius> +is
17:07:14 <unkanon> monochrom: I get it now, thanks!
17:07:19 <sipa> ddarius: you're right
17:07:32 <sipa> but how do you prove that?
17:07:32 <mauke> unkanon: id is a function of arity 2
17:07:33 <ddarius> And yes, it can be proven formally given a model of Haskell's semantics.
17:07:41 <unkanon> :t id
17:07:43 <lambdabot> forall a. a -> a
17:08:10 <unkanon> mauke: no it ain't *confused*.
17:08:28 <monochrom> @quote monochrom 17
17:08:28 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
17:08:38 <mauke> unkanon: then where exactly does typechecking 'flip id' fail?
17:08:43 <unkanon> mauke: I thought flip only worked for functions that take 2 args, that's what i mean
17:08:57 <hpc> mauke: which flip?
17:08:59 <hpc> :t flip id
17:09:00 <lambdabot> forall a b. a -> (a -> b) -> b
17:09:08 <mauke> prelude
17:09:18 <hpc> :t Prelude.flip
17:09:19 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
17:09:20 <sipa> unkanon: as mauke said
17:09:34 <sipa> unkanon: ($) :: (a -> b) -> (a -> b)  is the same as (a -> b) -> a -> b
17:09:45 <unkanon> yes
17:09:56 <sipa> so it takes 2 arguments, right?
17:09:58 <sipa> at least, it can
17:10:04 <unkanon> yes
17:10:04 <mauke> unkanon: in zipWith f, what's the arity of f?
17:10:08 <unkanon> but id can't
17:10:13 <sipa> sure id can
17:10:22 <unkanon> > id 5
17:10:23 <lambdabot>   5
17:10:27 <unkanon> > id 5 5
17:10:28 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:10:29 <lambdabot>    `GHC.Num.Num t' arising f...
17:10:33 <sipa> > id (+10) 5
17:10:33 <lambdabot>   15
17:10:34 <unkanon> how can id take 2 args?
17:10:44 <unkanon> but it's not taking 2 args there
17:10:50 <unkanon> > (id (+10)) 5
17:10:51 <lambdabot>   15
17:10:54 <unkanon> see ?
17:10:59 <mauke> wat
17:11:02 <sipa> what should i see?
17:11:03 <unkanon> id is only taking one arg
17:11:10 <unkanon> namely +10
17:11:11 <mauke> unkanon: all functions only take one arg
17:11:14 <sipa> in haskell, all functions only take one arg
17:11:19 <unkanon> yes that I know
17:11:21 <sipa> but the result might be another function
17:11:31 <sipa> f a b is exactly the same as (f a) b
17:11:31 <unkanon> but I didn't know you couldgo the other way and say that every function could take 2 args
17:11:34 <monochrom> <sipa> so it takes 2 arguments, right?
17:11:37 <mauke> unkanon: you can't
17:11:37 <unkanon> yes yes :)
17:11:40 <shachaf> unkanon: No function can take 2 arguments.
17:11:45 <sipa> 02:09:32 < sipa> at least, it can
17:12:10 <monochrom> <sipa> in haskell, all functions only take one arg
17:12:12 <shachaf> sipa: "takes 2 arguments" has no meaning.
17:12:17 <unkanon> right
17:12:20 <unkanon> that's why I'm confused
17:12:23 <sipa> yes, i've been confusing
17:12:24 <monochrom> I wonder which part of "only" implies "can take 2"
17:12:31 <shachaf> s/sipa/unkanon/
17:12:59 <alej> i think it might be helpful to work out how the compiler infers the type of the expression flip id
17:13:01 <sipa> unkanon: but passing to arguments to a function is really just passing one argument to the result of applying one argument to the function
17:13:03 <shachaf> unkanon: "a b c" is *always* the same as "(a b) c". It's just the way application associates.
17:13:05 <unkanon> > flip id 5
17:13:07 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> b)
17:13:07 <lambdabot>    arising from a u...
17:13:07 <hpc> i suppose you could take "number of arguments" to be the church numeral expressed by a function?
17:13:16 <unkanon> I don't even see how flip id makes any sense...
17:13:18 <mauke> > flip id 5 sqrt
17:13:19 <lambdabot>   2.23606797749979
17:13:30 <mauke> unkanon: the same way zipWith id does
17:13:31 <unkanon> sipa: shachaf: yes I know
17:13:35 <sipa> unkanon: id is a -> a, right?
17:13:39 <unkanon> yes
17:13:45 <sipa> so if you pass id a function
17:13:45 <hpc> unkanon: consider the type of id applied to a function
17:13:49 <sipa> the results is a function?
17:14:06 <shachaf> unkanon: If you want a more interesting example, look at printf.
17:14:06 <sipa> unkanon: agree?
17:14:07 <unkanon> sipa: yes
17:14:16 <mauke> shachaf: oh god, no
17:14:22 <ddarius> I would say that it is crucial to understand how the compiler assigns types.
17:14:32 <sipa> unkanon: so you can pass an argument to the result of applying id to a function?
17:14:38 <unkanon> > flip id (5 sqrt)
17:14:39 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> b)
17:14:39 <lambdabot>    arising from a u...
17:14:48 <unkanon> wow
17:15:01 <sipa> > (id f) x
17:15:02 <lambdabot>   Ambiguous type variable `a' in the constraints:
17:15:02 <lambdabot>    `GHC.Show.Show a'
17:15:02 <lambdabot>      a...
17:15:10 <mauke> unkanon: that's trying to call 5 with the argument sqrt
17:15:18 <unkanon> sipa: yes if the arity of that function is >2
17:15:24 <monochrom> both type and evaluation are important. I have only shown evaluation.
17:15:25 <sipa> unkanon: no
17:15:26 <mauke> unkanon: what exactly do you mean by "arity"?
17:15:36 <sipa> unkanon: take sqrt
17:15:46 <unkanon> arity = how many args a function takes (disregarding currying)
17:15:54 <mauke> unkanon: all functions take exactly one argument
17:15:58 <unkanon> I know :)
17:16:02 <mauke> unkanon: what exactly do you mean by "arity", then?
17:16:16 <unkanon> I can't reason when I think of functions as only taking one arg
17:16:20 <monochrom> by "arity" everyone means the number 1, ok?
17:16:31 <Eduard_Munteanu> Do you still like this? http://hpaste.org/41917/stuff
17:16:32 <mauke> unkanon: but that's what you have to do to grok this
17:16:33 <shachaf> unkanon: That's why you're confused. :-)
17:16:36 <sipa> unkanon: if you define arity as how many times you can pass a value to it, then id has indeterminate arity
17:16:43 <Eduard_Munteanu> I think the imperative-style equivalent would've been much more readable.
17:16:43 <sipa> it could be 1, or 2, or 3, or ...
17:16:48 <unkanon> flip id should be :: (b -> c) -> c -> b
17:16:58 <copumpkin> unkanon: :O
17:17:00 <mauke> unkanon: why?
17:17:06 <hpc> mauke: take a recursive definition; arity 0 is a value without (->) in its type; arity n is a function that returns a value of arity (n - 1)
17:17:08 <copumpkin> I'd like a function like that!
17:17:15 <sipa> unkanon: look
17:17:15 <Eduard_Munteanu> (not actually tested)
17:17:17 <sipa> :t sqrt
17:17:18 <lambdabot> forall a. (Floating a) => a -> a
17:17:22 <hpc> copumpkin: i would to!
17:17:22 <sipa> :t (id sqrt)
17:17:23 <lambdabot> forall a. (Floating a) => a -> a
17:17:31 <monochrom> > id head [id head [id head]] (id head [True])
17:17:32 <sipa> unkanon: what you expected?
17:17:32 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
17:17:32 <lambdabot>         against inferred type ...
17:17:38 <monochrom> hrm!
17:17:56 <monochrom> > id head [id head [id head [id]]] (id head [True])
17:17:57 <lambdabot>   True
17:18:05 <Eduard_Munteanu> Hah, I'd like a (a -> b) -> (b -> a) too :)
17:18:21 <unkanon> lol
17:18:25 <hpc> does unsafeCoerce count?
17:18:29 * monochrom writes paper "fun with id" and submits to JFP
17:18:40 <nostrand> can criterion be used to plot comparisons of functions for a range of args?
17:18:46 <Eduard_Munteanu> I don't think so. That says "give me any function and I'll invert it".
17:18:47 <unkanon> I'm going back and reading a little
17:18:52 <Eduard_Munteanu> That's impossible.
17:19:03 <unkanon> id is a -> a
17:19:19 <unkanon> flip is (a -> b -> c) -> b -> a -> c
17:19:30 <sipa> unkanon: but instanciate a as (b -> c), and you get (b -> c) -> (b -> c), or (b -> c) -> b -> c
17:19:37 <mauke> sipa: too many steps at once
17:19:37 <shachaf> > invert ord 65
17:19:39 <lambdabot>   Couldn't match expected type `t1 -> t'
17:19:39 <lambdabot>         against inferred type `GHC.T...
17:19:42 <monochrom> > (id :: (Int->String) -> (Int->String)) show 45
17:19:42 <lambdabot>   "45"
17:19:51 <mauke> unkanon: what is the fully parenthesized type of flip?
17:20:03 <dibblego> is there a package for load-testing a website?
17:20:06 <shachaf> > invert ord 65
17:20:07 <unkanon> flip id is ((a->a) -> b -> c) -> b -> (a->a) -> c ?
17:20:07 <lambdabot>   'A'
17:20:18 <Eduard_Munteanu> :t invert
17:20:19 <lambdabot> forall t t1. t -> t1 -> Char
17:20:31 <mauke> unkanon: no
17:20:35 <hpc> > invert 1 2
17:20:36 <lambdabot>   Not in scope: `invert'
17:20:39 <Eduard_Munteanu> Some unsafe magic ?
17:21:06 <roconnor> come vote in my costate renaming survey: http://www.reddit.com/r/haskell/comments/ed184/survey_new_name_for_the_costate_comonad/
17:21:07 <monochrom> I'm sure someone secretly defined "invert x y = 'A'" to fool you
17:21:08 <Eduard_Munteanu> Like figuring out what arguments have been applied?
17:21:38 <unkanon> mauke: I don't understand sipa's deriving
17:21:40 <Eduard_Munteanu> Hah.
17:21:41 <monochrom> This is a common con trick.
17:21:44 <mauke> unkanon: what is the fully parenthesized type of flip?
17:22:17 <unkanon> well -> associates to the right
17:22:35 <shachaf> > let f = const True in invert f (f 5)
17:22:37 <lambdabot>   5
17:22:50 <shachaf> > let f = const True in invert f (f 6)
17:22:52 <lambdabot>   6
17:22:57 <unkanon> mauke: (a -> (b -> c)) -> (b -> (a -> c))
17:23:08 <mauke> that looks good
17:23:21 <unkanon> I got one thing right at last :)
17:23:25 <unkanon> what next?
17:23:55 <mauke> unkanon: now we consider (flip :: (a -> (b -> c)) -> (b -> (a -> c))) (id :: d -> d)
17:24:13 <mauke> (that's flip id annotated with types)
17:24:13 <unkanon> ok
17:24:19 <unkanon> yes
17:24:30 <mauke> the next step is checking the function args
17:24:41 <mauke> i.e. we need to compare (a -> (b -> c)) and (d -> d)
17:24:50 <mauke> to figure out if we're allowed to pass id to flip
17:25:11 <mauke> are you with me?
17:25:14 <unkanon> yes
17:25:52 <unkanon> oh...
17:26:03 <unkanon> d is a and the other d is b -> c ?
17:26:07 <mauke> yes
17:26:14 <mauke> but it's really the same d :-)
17:26:24 <mauke> a = d = b -> c
17:26:32 <unkanon> I have to think about that
17:27:10 <unkanon> so how do we replace the type variables now?
17:27:22 <unkanon> (d -> d) -> ... ?
17:27:28 <unkanon> how do I replace b alone?
17:27:34 <mauke> you don't
17:27:51 <unkanon> (d -> d) -> (b -> (a -> c)) 
17:27:54 <unkanon> that's it?
17:27:59 <mauke> b -> c is more specific than a or d, so we replace all instances of a/d with b -> c
17:28:35 <unkanon> (b -> c -> b -> c) -> (b -> (a -> c)) 
17:28:43 <unkanon> (b -> c -> b -> c) -> (b -> (b -> c -> c)) 
17:28:50 <mauke> (flip :: ((b -> c) -> (b -> c)) -> (b -> ((b -> c) -> c))) (id :: (b -> c) -> (b -> c))
17:29:01 <mauke> don't forget the parens
17:29:19 <unkanon> ok so now we have that
17:29:50 <mauke> now we're done
17:29:53 <sipa> look at the type of id here
17:30:05 * augur flips mauke
17:30:15 <mauke> the types match exactly, and the result type of flip id is b -> ((b -> c) -> c)
17:30:50 <sipa> unkanon: id has type (b -> c) -> (b -> c) in this instance, but can you remove some parenthesis?
17:30:54 <unkanon> yes, flip id is (b -> ((b -> c) -> c))
17:31:10 <unkanon> sipa: the last pair
17:31:20 <mauke> oh yeah, now we can deparenthesize again
17:31:44 <mauke> id :: (b -> c) -> b -> c; flip id :: b -> (b -> c) -> c
17:32:05 <sipa> yes, so because of the type inference, d = b -> c, and id has become a function of "arity 2" (in the sense that it can take two function application)
17:32:11 <augur> is this going to lead to flip id being some applicator
17:32:38 <unkanon> that's crazy that id became that!
17:32:41 <monochrom> > flip id True not
17:32:42 <lambdabot>   False
17:33:00 <mauke> once you grok 'flip id', you understand currying/partial application
17:33:19 <shachaf> unkanon: Note the definition of ($): ($) :: (a -> b) -> a -> b; ($) = id
17:33:27 <unkanon> mauke: I thought I understood those but apparently not
17:33:30 <augur> mauke: i dont grok flip id but i grok currying :D
17:33:34 <roconnor> CI
17:33:43 <unkanon> shachaf: that's really cool
17:33:49 <mauke> augur: I don't believe you
17:33:57 <augur> thats your problem :3
17:34:14 <unkanon> it still blows my mind that we turned id into (b -> c) -> b -> c
17:34:26 <pkrumins> :t id
17:34:27 <lambdabot> forall a. a -> a
17:34:31 <augur> id is always (b -> c) -> b -> c
17:34:33 <pkrumins> :t flip id
17:34:34 <lambdabot> forall a b. a -> (a -> b) -> b
17:34:36 <augur> when applied to a b -> c
17:34:36 <mauke> but that's what currying is about
17:34:39 <shachaf> unkanon: Is it strange that id :: Maybe a -> Maybe a?
17:34:43 <sipa> unkanon: if you apply id to a function, you still have a function, so you can still apply it to something :)
17:34:52 <monochrom> > let you_will = ("you will " ++) in flip id "understand" you_will
17:34:53 <lambdabot>   "you will understand"
17:34:55 <augur> mauke: currying isn't entirely about that
17:34:57 <unkanon> shachaf: that isn't strange, no
17:35:01 <shachaf> unkanon: Look at it as id :: ((->) b c) -> ((->) b c)
17:35:06 <shachaf> It's just another type.
17:35:18 <monochrom> module Yoda where yoda = flip id ...
17:35:21 <augur> monochrom: talk like yoda, you do
17:35:36 <augur> :|
17:35:41 <augur> stop reading my mind
17:35:42 <monochrom> haha
17:35:44 <unkanon> well if id is really that then how do you partially apply id by itself?
17:35:50 <monochrom> no, you read mine!
17:35:55 <augur> anyway, mauke, you can understand currying long before you understand flip id
17:36:04 <mauke> augur: I don't believe you
17:36:10 <sipa> unkanon: what do you mean with 'partially apply' ?
17:36:12 <augur> mauke: curry did it.
17:36:26 <wavewave> has anyone used bindings-gsl ?
17:36:27 <mauke> augur: did Curry understand flip id?
17:36:38 <augur> mauke: probably not!
17:36:42 <unkanon> sipa: if id is (b -> c) -> b -> c then how do we make it only take a (b -> c) ?
17:36:44 <monochrom> perhaps Curry understood flip id first but didn't tell you.
17:36:47 <mauke> augur: I think he probably did
17:36:50 <unkanon> and return a function that...
17:36:52 <unkanon> oh...
17:36:57 <sipa> unkanon: look
17:37:01 <monochrom> perhaps Curry understood nothing but just mechanically calculated it all out.
17:37:02 <sipa> :t sqrt
17:37:02 <lambdabot> forall a. (Floating a) => a -> a
17:37:03 <augur> currying is just taking a function of tuples and turning it into a higher order function
17:37:06 <augur> theres nothing magical to currying
17:37:09 <monochrom> like, define "understand"
17:37:10 <sipa> :t id sqrt
17:37:11 <lambdabot> forall a. (Floating a) => a -> a
17:37:23 <sipa> > (id sqrt) 5
17:37:23 <lambdabot>   2.23606797749979
17:37:28 <sipa> > id sqrt 5
17:37:29 <lambdabot>   2.23606797749979
17:37:33 <unkanon> yes that I understand
17:37:41 <unkanon> because function application is left associative
17:37:56 <shachaf> unkanon: You don't have a problem with "id sqrt"?
17:38:00 <unkanon> nope
17:38:03 <shachaf> unkanon: That's the same (b -> c) -> b -> c thing.
17:38:06 <unkanon> it returns sqrt
17:38:12 <sipa> yes
17:38:21 <sipa> i'm not sure i understand your question
17:38:23 <shachaf> @src flip
17:38:24 <lambdabot> flip f x y = f y x
17:38:36 <shachaf> flip id x y = id y x = (id y) x = y x
17:38:42 <shachaf> What's different about that?
17:38:43 <unkanon> what's the advantage of saying id is (b -> c ) -> b -> c instead of a -> a ?
17:38:55 <unkanon> because there's no difference
17:38:59 <sipa> there is
17:39:02 <shachaf> unkanon: No advantage -- that's the point. a -> a is more general.
17:39:11 <sipa> (b -> c) -> b -> c is more specific than a -> a
17:39:51 <mauke> augur: that definition of currying doesn't explain flip id
17:40:03 <augur> mauke: it doesnt have to
17:40:08 <mauke> IMHO it does
17:40:10 <augur> flip id has nothing to do with currying as a concept
17:40:16 <pkrumins> can anyone show an example where flip id is useful?
17:40:26 <pkrumins> or some cool thing with flip id
17:40:29 <pkrumins> that illustratesit
17:40:29 <augur> flip it is merely an interesting thing that you can do
17:40:35 <djahandarie> pkrumins, useful for golfing
17:40:42 <mauke> augur: you think of currying as a method of transforming functions; I also include the results of the transformation
17:40:42 <unkanon> flip id is really hard to grok
17:40:43 <djahandarie> In case you don't feel like typing $
17:40:44 <shachaf> > map ($ 5) [succ,pred,(*2)]
17:40:45 <lambdabot>   [6,4,10]
17:40:46 <pkrumins> can you apply it on a toy example?
17:40:48 <unkanon> I'm still thinking about it
17:40:58 <augur> mauke: ok? that doesnt change anything
17:41:11 <mauke> > flip id "pkrumins" reverse
17:41:13 <lambdabot>   "snimurkp"
17:41:24 <augur> mauke: so what?
17:41:35 <pkrumins> so it flipped reverse and id
17:41:39 <pkrumins> em
17:41:45 <sipa> > let fi = flip id in (5 `fi` sqrt)
17:41:46 <lambdabot>   2.23606797749979
17:41:47 <pkrumins> so it flipped reverse and "pkrumins"
17:41:49 <sipa> tadaa!
17:41:59 <pkrumins> applied id on reverse which yielded reverse
17:42:03 <pkrumins> then applied reverse on pkruins
17:42:04 <shachaf> @let (|>) = flip id
17:42:06 <lambdabot>  Defined.
17:42:07 <pkrumins> and we got snimurkp
17:42:13 <shachaf> > 5|>sqrt
17:42:15 <lambdabot>   2.23606797749979
17:42:22 <pkrumins> > id reverse "pkrumins"
17:42:23 <lambdabot>   "snimurkp"
17:42:30 <sipa> > id 5 |> id sqrt
17:42:31 <lambdabot>   2.23606797749979
17:42:49 <pkrumins> > id 5 |> id id
17:42:50 <lambdabot>   5
17:42:55 <magicman> > 5 |> sqrt
17:42:56 <lambdabot>   2.23606797749979
17:43:02 <sipa> > id 5 |> (|> sqrt)
17:43:03 <lambdabot>   2.23606797749979
17:43:14 <unkanon> :t flip id
17:43:15 <augur> (\f x y -> f y x) (\g -> g) = \x y -> (\g -> g) y x = \x y -> y x
17:43:16 <lambdabot> forall a b. a -> (a -> b) -> b
17:43:17 <augur> big fuckin deal
17:43:56 <sipa> > (5 |> id) |> (|> sqrt)
17:43:57 <lambdabot>   2.23606797749979
17:43:58 <pkrumins> :t id flip
17:43:59 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
17:44:05 <djahandarie> Using «flip id» in any of these cases is just a useless golf of «flip ($)»
17:44:19 <sipa> of course, ($) is just id here
17:44:29 <sipa> that's what the whole discussion started with :)
17:44:34 <mauke> did you mean: id is just ($) here
17:44:50 <sipa> mauke: that's more correct indeed
17:44:59 <unkanon> > filter (isPrefixOf "x") |> sort |> nub |> length $ ["xa", "xb", "d"]
17:45:00 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
17:45:00 <lambdabot>                           ...
17:45:00 <sipa> ($) is always id, but id isn't always ($)
17:45:33 <augur> this is such a stupid discussion
17:45:39 <djahandarie> Not really true either due to the fixity of ($) anyways
17:46:15 <unkanon> @let (|>>) = f . x
17:46:16 <lambdabot>  <local>:2:12:
17:46:16 <lambdabot>      Couldn't match expected type `f a' against inferred type ...
17:47:20 <unkanon> id isn't always ($)? but vice versa always holds? what kind of equality is that?
17:47:39 <mauke> specialization
17:47:40 <sipa> unkanon: id applied to a function is the same as ($)
17:48:23 <sipa> (id) 5 works, but ($) 5 doesn't
17:48:39 <sipa> while (id) sqrt and ($) sqrt are the same
17:49:25 <unkanon> but ($ 5) is the same as (id 5) ?
17:49:30 <unkanon> it's only a precedence issue
17:49:37 <augur> no, unkanon
17:49:41 <augur> :t ($)
17:49:43 <lambdabot> forall a b. (a -> b) -> a -> b
17:49:45 <djahandarie> ($ 5) is a section
17:49:50 <ivanm> @type ($5)
17:49:51 <lambdabot> forall a b. (Num a) => (a -> b) -> b
17:49:53 <ivanm> @type (id 5)
17:49:55 <lambdabot> forall t. (Num t) => t
17:50:02 <augur> notice that ($) is specifically a function-taker
17:50:04 <djahandarie> There are different syntax rules for infix operators
17:50:06 <mauke> unkanon: (($) 5) is the same as flip ($) 5
17:50:07 <augur> whereas id is an anything taker
17:50:13 <mauke> er
17:50:15 <mauke> fuck
17:50:19 <mauke> unkanon: ($ 5) is the same as flip ($) 5
17:50:28 <mauke> ($) 5 is ($) 5
17:51:07 <augur> mauke: this seems liess about currying and more about partial application for infixes
17:52:08 <djahandarie> augur, was ‘augury’ your blog by the way?
17:52:18 <augur> yes
17:52:24 <unkanon> augur: I can see the function-taker thing now
17:52:30 <djahandarie> Neat post then. Though I didn't really understand it. :P
17:52:41 <augur> unkanon: thats why its an assymmetric "equality"
17:52:52 <augur> because its not equality, its type membership
17:53:07 <sipa> its implementation is equal
17:53:10 * djahandarie suspects it has something to do with himself not being a semanticist
17:53:17 <augur> ($) is an instance of the same type as id, and has identical behavior in a certain range of conditions
17:53:34 <augur> namely, in those conditions where id's arguments are the same type as ($)'s
17:54:09 <augur> the difference is that id's more general type allows it to take arguments that ($) cant, and therefore the behaviors diverge when the types diverge
17:54:34 <augur> where behavior here is strictly a result of the type system
17:54:49 <unkanon> I see, I'll have to read this whole thing again
17:54:50 <augur> and not a fact about the algorithm involved, as sipa's comment implies
17:55:00 <augur> unkanon: just think of it like this
17:55:05 <augur> suppose i define two functions
17:55:10 <augur> plusNum and plusInt
17:55:17 <augur> plusInt adds two integers
17:55:28 <augur> it doesnt add rationals
17:55:34 <augur> plusNum adds both integers and rationals
17:55:54 <augur> as long as you give both functions integers, their behavior is identical
17:56:08 <augur> but if you give them rationals, one fails on type check, the other succeeds happily
17:56:08 <unkanon> so id would be the Num kin?
17:56:10 <unkanon> kind
17:56:15 <augur> other way around
17:56:21 <augur> er yes sorry
17:56:23 <augur> :p
17:56:42 <unkanon> so id is the Num then?
17:56:50 <augur> id is like plusNum, in that it does everything ($) does, and then some
17:57:17 <augur> just like how plusNum does everything plusInt does, and some more
17:57:24 <unkanon> I get it
17:57:37 <augur> good!
17:58:20 <unkanon> I'm going back now and reading some more on that flip id thing
17:58:36 <augur> theres nothing to read up on
17:58:40 <augur> mauke is pulling a fast one on you
17:58:44 <augur> unkanon: just look
17:58:49 <mauke> hah
17:58:54 <augur> flip = \f x y -> f y x
17:58:58 <augur> id = \g -> g
17:59:05 <unkanon> yes
17:59:21 <augur> so flip id = (\f x y -> f y x) (\g -> g) = \x y -> (\g -> g) y x = \x y -> y x
18:00:01 <augur> flip id x y = id y x = y x
18:00:24 <augur> you dont have to think about how flipping "id" words
18:00:37 <unkanon> wait
18:00:40 <augur> waiting
18:00:48 <mauke> uh, isn't that exactly how flipping id works?
18:00:52 <unkanon> why did (\g -> g) disappear there? I don't know that rule in lambda calculus
18:01:02 <augur> apply it to y
18:01:02 <mauke> unkanon: beta reduction
18:01:08 <augur> (\g -> g) y = y
18:01:35 <augur> mauke: yes, its "how flipping id" works, except its a clear and concise explanation, instead of your batshit insane and confusion rendition
18:01:38 <unkanon> ok I'll take it on faith now
18:01:40 <augur> confusing**
18:01:46 <augur> unkanon: no, dont do that
18:01:59 <augur> just remember the rules for how you apply a lambda
18:02:03 <mauke> augur: could you please be less of an ass?
18:02:11 <augur> mauke: alas, i cannot
18:02:18 <mauke> I'm not out to annoy or infuriate you
18:02:30 <augur> unkanon: (\x -> M) N = M[x := N] right?
18:02:41 <augur> that is, M, with x replaced by N
18:03:09 <augur> well here, x ~ g, M = g, and N = y, so (\g -> g) y = g[g := y] = y
18:03:33 <augur> or in less lambda terms, id y = y
18:05:25 * unkanon thinking
18:05:34 <MrAI> data Tree a = Leaf a | Node (Tree a) (Tree a), ordered :: Ord b => Tree b -> Bool , What would ordered (Leaf x) = ???
18:06:02 <mauke> MrAI: huh?
18:06:14 <shachaf> MrAI: Is this a homework question?
18:06:14 <MrAI> Split the line by ,
18:06:18 <MrAI> Nope
18:06:21 <MrAI> Learning haskell
18:06:23 <shachaf> MrAI: What's ordered supposed to do?
18:06:26 <augur> MrAI: T = X + T*T
18:06:30 <mauke> MrAI: that makes no sense
18:06:31 <MrAI> Tell you if its an ordered tree
18:06:41 <mauke> oh, I see
18:06:48 <mauke> True
18:06:52 <shachaf> MrAI: Well -- is a Leaf ordered?
18:06:54 <jmcarthur> unkanon: the disappearing (\g -> g) was beta reduction. you may not have expected it if you are used to only evaluating to WHNF because for WHNF you don't evaluate under lambdas
18:06:57 <MrAI> I thought that
18:07:18 <MrAI> No a Leaf isnt.
18:07:26 <augur> byorgey: i still think inverse species is a great idea
18:07:28 <shachaf> MrAI: If it's not, then it should be False.
18:07:55 <MrAI> It isnt false or true.
18:08:16 <unkanon> augur: thanks, I'll be reading over that again soon (my wife won't stop talking now)
18:08:35 <shachaf> MrAI: If you're learning Haskell, you should figure out this problem in some other context before doing it in Haskell. :-)
18:09:56 <unkanon> jmcarthur: what do you recommend I read to get up to speed on lambda calculus and be able to understand what you just said?
18:10:05 <MrAI> ordered (Leaf x) = True or False doesnt work. I guess as you say shachaf - back to the paperwork solution
18:10:16 <shachaf> MrAI: Why doesn't it work?
18:10:24 <wavewave> I am looking for a fast gaussian normal distribution generator. 
18:10:37 <shachaf> MrAI: I think the first step to solving this problem is understanding it. :-)
18:10:39 <wavewave> does anyone know it?
18:10:40 <mauke> in my opinion every subtree of an ordered tree should be ordered
18:10:46 <monochrom> @type ordered
18:10:47 <lambdabot> Not in scope: `ordered'
18:10:55 <monochrom> what is "ordered" supposed to do?
18:11:01 <sipa> wavewave: knuth's polar method
18:11:03 <mauke> monochrom: tell you if a tree is ordered
18:11:04 <MrAI> tree1 = Node (Leaf 3) (Leaf 8) answer is determined by where I put ordered(Leaf x) = False or true
18:11:12 <augur> unkanon: i can give you some links
18:11:18 <unkanon> augur: please do
18:11:31 <copumpkin> MrAI: there's a very obvious answer
18:11:37 <shachaf> MrAI: I'd suggest you start by defining an ordered tree.
18:11:39 <monochrom> think of lists. is [1] ordered? yes.
18:11:56 <shachaf> copumpkin: To defining ordered? It's not completely obvious, I think.
18:11:57 <MrAI> Ive got: ordered (Node l r) = if(ordered(l) < ordered(r)) then True else False
18:12:05 <copumpkin> shachaf: it has to be, really
18:12:06 <monochrom> maybe [3,1] is not ordered but both [1] and [1,3] are.
18:12:14 <monochrom> also [] is ordered.
18:12:15 <mauke> MrAI: that looks wrong
18:12:16 <unkanon> mauke: and what do I read to know how to substitute the types like you did in the flip id explanation (I appreciate the patience, I've already saved that to a file to read again later when my wife is less chatty)
18:12:18 <shachaf> copumpkin: What has to be?
18:12:30 <augur> unkanon: type stuff is more complicated
18:12:33 <MrAI> I see
18:12:38 <copumpkin> shachaf: it has to be a certain value, because of how you have to define the ordered on the inner nodes (namely, the identity for them)
18:12:39 <augur> yo should get a hold of the untyped lambda calculus first
18:12:40 <MrAI> brb :D
18:12:57 <wavewave> sipa : thanks. by googling knuth's polar method, I found a package random-fu
18:12:58 <shachaf> copumpkin: You mean ordered (Leaf _) is obvious?
18:13:03 <copumpkin> shachaf: yeah
18:13:09 <copumpkin> just like product [] = 1 is
18:13:11 <shachaf> copumpkin: Yes -- I was referring to the more interesting case. :-)
18:13:18 <mauke> unkanon: hmm, something about hindley-milner type inference?
18:14:01 <monochrom> yo lambda is so fat...
18:14:25 <jmcarthur> unkanon: i don't have an especially good link to explain things like WHNF or anything, but here is a slightly related paper that i like to mention to people interested in some of the underpinnings of functional programming: http://www.cs.kent.ac.uk/people/staff/dat/miranda/ctfp.pdf
18:14:43 <augur> monochrom: i can give lambda a denotation :)
18:14:43 <jmcarthur> unkanon: basically it's a brief overview of the field, not going into much detail on any one front
18:15:01 <jmcarthur> *of the basics of the field
18:15:33 <unkanon> jmcarthur: ok thanks
18:15:38 <unkanon> mauke: i'll google that
18:15:39 <jmcarthur> unkanon: the brevity can be a bad thing too i guess, since it doesn't explain *everything*, but i really enjoyed that paper
18:16:10 <pygmalio1> i'm having a type issue with map that i can't figure out. http://hpaste.org/41918/type_error i want to map that move function across all of the values in the allowedMoves list
18:17:16 <shachaf> Oh, wait, that tree wasn't what I thought it was.
18:17:28 <shachaf> There are only values at the leaves.
18:18:25 <jmcarthur> pygmalio1: "evalPosition depth (getCurPlayer mancala) (move mancala)" already has all of its arguments full there
18:19:21 <jmcarthur> pygmalio1: also, "map (evalPosition depth (getCurPlayer mancala) (move mancala)) (allowedMoves mancala)" has all of its arguments full as well, so it doesn't make sense to be on the right side of (.)
18:19:31 <jmcarthur> on either side of (.), for that matter
18:19:32 <MrAI> Yes shachaf
18:20:32 <MrAI> Ah the question actually says that Leaf's are true, lol.
18:20:48 <MrAI> data Tree a = Leaf a | Node (Tree a) (Tree a)
18:20:49 <MrAI> ordered :: Ord b => Tree b -> Bool
18:20:49 <MrAI> ordered (Leaf x) = True
18:20:49 <MrAI> ordered (Node l r) = if(ordered(l) < ordered(r)) then True else False
18:20:50 <jmcarthur> pygmalio1: also, you are binding both arguments in the definition of lookahead but still using (.) as though there is another unbound argument
18:20:51 <MrAI> oops
18:20:59 <MrAI> Maybe that was too many lines to paste :s
18:22:05 <MrAI> That isnt correct :s
18:22:33 <mauke> MrAI: why are you using < on Bools?
18:22:49 <MrAI> haha good question
18:23:08 <shachaf> MrAI: Where is this question coming from?
18:23:10 <jmcarthur> @instances Ord
18:23:11 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
18:23:42 <jmcarthur> > liftA2 (<) `join` [False, True]
18:23:43 <lambdabot>   [False,True,False,False]
18:25:33 <shachaf> > liftA2 (<=) `join` [False,True]
18:25:34 <lambdabot>   [True,True,False,True]
18:25:48 <MrAI> Why cant I use <  on bool then?
18:25:49 <shachaf> So (<=) is implication?
18:26:18 <shachaf> MrAI: You can. But I don't think you understand whatever algorithm you're trying to implement very well.
18:26:18 <Eduard_Munteanu> I'm using :set -fbreak-on-exception in GHCi to debug, but :trace shows nothing useful. Any ideas?
18:26:21 <Veinor> shachaf: yes, which is kind of confusing
18:26:28 <shachaf> Veinor: The arrow goes in the wrong direction. :-(
18:26:50 <Veinor> reverse logic!
18:26:58 <Eduard_Munteanu> It just says _exception :: e = _
18:28:04 * shachaf declares that False > True.
18:28:12 <Eduard_Munteanu> Aw crap, non-monadic parsing is crappy.
18:28:13 <shachaf> Is there any reason it should be otherwise?
18:28:38 <Eduard_Munteanu> I should just rewrite the whole thing in IO.
18:28:39 <jmcarthur> > fromEnum False > fromEnum True
18:28:40 <lambdabot>   False
18:28:44 <pygmalio1> jmcarthur: how can i make the mapped value go to be the second argument to move?
18:28:58 * shachaf declares that map fromEnum [False,True] = [1,0]
18:29:03 <shachaf> Is there any reason it should be otherwise?
18:29:14 <jmcarthur> established convention?
18:29:24 <mauke> shachaf: 0 = False in lambda calculus
18:29:24 <shachaf> jmcarthur: Process exit status. :-)
18:29:31 <jmcarthur> ha
18:29:49 <shachaf> And strcmp in C.
18:30:03 <mauke> > (sort ["False", "True"], sort [1, 0])
18:30:04 <lambdabot>   (["False","True"],[0,1])
18:30:19 <shachaf> mauke: That's stretching it.
18:30:32 <mauke> strcmp doesn't return Bool
18:30:44 <shachaf> True.
18:30:53 <jmcarthur> pygmalio1: i don't understand your question
18:30:57 <mauke> shachaf: how about compatibility with C and every language based on it?
18:31:02 <Manifesto> @source Data.Bits
18:31:03 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
18:31:22 <jmcarthur> mauke: to play shachaf's side, we have C types in the FFI for a reason :)
18:31:23 <shachaf> mauke: As I said, process exit status.
18:31:33 <mauke> shachaf: process exit status is not a boolean
18:31:43 <pygmalio1> jmcarthur: so what i want is for each i in allowedMoves mancala (which is a list of ints), to run "move mancala i"
18:31:46 <shachaf> mauke: True. But we were talking about fromEnum.
18:31:51 <mauke> shachaf: bitwise ops treat 0 as false and 1 as true
18:31:51 <pygmalio1> as the last argument to evalPosition
18:32:13 <jmcarthur> pygmalio1: map (move mancala) (allowedMoves mancala)
18:32:17 <garslo> Is it possible to write (/) (f x) (g x) point-free?
18:32:30 <shachaf> As Tolstoy said, successful booleans are all alike; every unsuccessful boolean is unhappy in its own way.
18:32:31 <pygmalio1> jmcarthur: oh i see so embed the map more. duh. thanks.
18:32:35 <shachaf> (I think that's how it went.)
18:32:45 <shachaf> s/happy/successful/
18:32:45 <jmcarthur> garslo: that's already point free :P
18:32:52 <jmcarthur> garslo: which variables do you want to remove?
18:32:58 <garslo> jmcarthur: er, remove the x
18:32:59 <garslo> :)
18:33:12 <jmcarthur> garslo: so the function is \x -> (/) (f x) (g x)?
18:33:15 <shachaf> garslo: liftM2 (/)
18:33:16 <mauke> liftM2 (/) f g
18:33:21 <jmcarthur> @pl \x -> (/) (f x) (g x)
18:33:22 <lambdabot> liftM2 (/) f g
18:33:30 <garslo> jmcarthur: yes. Ok cool. 
18:34:22 <Eduard_Munteanu> Do you still think this is better than just doing it in IO and using hGet? http://hpaste.org/41919/stuff2 
18:34:29 <Eduard_Munteanu> It looks really spagetti to me.
18:34:33 <wavewave> sipa : I checked the speed of random-fu package. It's pretty fast but still 4 times slower than a C code using gsl_ran_gaussian
18:34:36 <Eduard_Munteanu> And it's hell to fix.
18:35:04 <Eduard_Munteanu> Especially I don't like the head + tail + drop stuff.
18:35:28 <wavewave> I used mersenne-pure64 library
18:35:31 <pygmalio1> jmcarthur: hmm but the issue then is that evalPosition is supposed to take a single MancalaBoard but if i run map on move, i return a [MancalaBoard]
18:36:40 <jmcarthur> pygmalio1: map (evalPosition depth) <thing giving you a [MancalaBoard]>
18:37:04 <jmcarthur> pygmalio1: and since you have something of the form (map f . map g) you can shorten it to (map (f . g)) instead
18:37:31 <jmcarthur> pygmalio1: so that would give you:   map (evalPosition depth . move mancala) (allowedMoves mancala)
18:37:48 <pygmalio1> jmcarthur: ahhh i see. the beauty of abstraction. thanks very much again.
18:37:53 <jmcarthur> np
18:45:33 <Eduard_Munteanu> Is it okay to cons to a list using forM_ and modifyIORef? Or do you have a better suggestion?
18:46:36 <Eduard_Munteanu> An array might be better I think.
19:04:31 <Cale> Eduard_Munteanu: Well, cons is O(1). You can use a list as a stack.
19:09:03 <davidL> > case () of { () | 0 <- 0 -> 0 ; _ -> 1 }
19:09:03 <lambdabot>   0
19:12:55 <Eduard_Munteanu> Cale: yeah, but I'll need to reverse it afterwards I think.
19:13:08 <jmcarthur> reversing isn't inherently bad
19:13:10 <Eduard_Munteanu> Cale: because I want the elements in the same order as I read them.
19:13:23 <jmcarthur> there's also DList or Seq
19:13:28 <Eduard_Munteanu> Hm, yeah, I could try that. I ran into problems because my element type is not Storable :/
19:13:42 <Eduard_Munteanu> Oh yes, Seq, I'll use that.
19:13:47 <Eduard_Munteanu> Thanks.
19:14:16 <jmcarthur> honestly though, building and reversing a list could still be faster than using Seq
19:14:24 <jmcarthur> i haven't measured it
19:20:30 <Eduard_Munteanu> Good. Now this looks much better than the functional, non-monadic variant.
19:21:04 <Eduard_Munteanu> No more take this, drop that, just benefit from IO statefulness.
19:22:19 <Eduard_Munteanu> http://hpaste.org/41920/stuff2
19:23:33 <ddarius> > case () of () | 0 <- 0 -> 0 -> 0 -- won't work because lambdabot is missing an extension (and it needs parentheses...)
19:23:33 <lambdabot>   <no location info>: parse error on input `->'
19:23:55 <ddarius> > case () of () | 0 <- (0 -> 0) -> 0 -- won't work because lambdabot is missing an extension
19:23:56 <lambdabot>   Pattern syntax in expression context: 0 -> 0
19:24:10 <ddarius> Er I guess I need to move that left some.
19:27:28 <ddarius> Eduard_Munteanu: That code looks like C and the pattern of the loop you are mimicking is captured by foldl, in this case, presumably foldM.
19:29:38 <Eduard_Munteanu> ddarius: would a fold improve it?
19:30:13 <Eduard_Munteanu> I just want to avoid doing lots of takes and drops, and having the file cursor manipulated in hGet gives me that.
19:30:33 <Cale> Eduard_Munteanu: Yeah, another trick (which is secretly the same as the DList suggestion) is to simply replace lists with functions that add elements to the beginning of a list. So the empty list is replaced by id, the one element list [x] is replaced by (x:), and (++) is replaced with (.)
19:31:02 <Cale> (If you're just doing lots of plain ol' concatenation, at least)
19:31:28 <Cale> It won't help with splitting like Seq will, but the constant factors involved are smaller.
19:31:48 <Eduard_Munteanu> I need a Seq for buildATree anyway.
19:35:53 <ddarius> Eduard_Munteanu: It would avoid the need for an IORef and thus the code to make it and read it, and it would simplify the body.  It would also communicate to the reader the pattern you are using rather than requiring them to reverse engineer it.
19:36:43 <ddarius> :t foldM
19:36:43 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
19:37:51 <ddarius> Actually, even foldM seems inappropriate as you aren't even using the input list.
19:38:13 <ddarius> You should replace your forM_ with replicateM_ at the very least, especially as I think you have an off-by-one error.
19:41:00 <Eduard_Munteanu> ddarius: hm, replicateM_ sounds better. And no, it's not off-by-one, alen is actually the length minus 1.
19:41:18 <Eduard_Munteanu> so 0..alen is okay, if that's what you were referring to.
19:43:59 <ddarius> a0 <- foldM (\a0 _ -> (\ch freq -> a0 |> (decode ch, fromIntegral $ decode (freq :: Word32))) <$> B.hGet ih 1 <*> B.hGet ih 4) S.empty
19:44:05 <ddarius> [0..alen]
19:47:16 <ddarius> :t let foldNatM 0 z s = return z; foldNatM n z s = do z' <- s z; foldNatM (n-1) z' s in foldNatM
19:47:17 <lambdabot> forall t b (m :: * -> *). (Monad m, Num t) => t -> b -> (b -> m b) -> m b
19:48:28 <ddarius> foldNatM (alen + 1) S.empty $ \a0 -> (\ch freq -> a0 |> (decode ch, fromIntegral (decode freq :: Word32))) <$> B.hGet ih 1 <*>  B.hGet ih 4 
19:49:00 <Eduard_Munteanu> Hm, I didn't know about foldNatM
19:49:11 <ddarius> It doesn't exist in the libraries as far as I know.
19:49:14 <Eduard_Munteanu> Err, sorry.
19:50:25 <ddarius> (That definition should also probably be a little stricter in z.)
19:50:43 <deech> Hi all, I was reading about uniqueness types and was wondering if such a thing was possible in Haskell. The ST Monad seems to come pretty close.
19:51:03 <ddarius> The ST monad doesn't do anything like uniqueness typing.
19:51:43 <deech> ddarius: only in the sense that it looks pure from the outside but uses mutable structures on the inside.
19:52:17 <deech> ddarius: my understanding of uniqueness typing isn't deep. I just saw a ref to in in Wikipedia and it seemed cool.
19:53:25 <ddarius> deech: Uniqueness typing allows the compiler to know that a pure usage of an array can be optimized in place.  This can be done without uniqueness typing, but it's far less effective without programmer input.  ST just gives you mutation, albeit localized, with all the usual caveats.
19:55:02 <deech> oh I see. So if you know nothing else needs the array you can in-place modify it. 
19:55:17 <ddarius> Yes.  And GHC could do this today but doesn't.
19:55:53 <deech> Maybe I'm not seeing things lazily but it seems like quite an optimization.
19:56:15 <ddarius> It is, but it's a very fragile optimization.
19:56:24 <ddarius> This is why uniqueness types are explicit and enforced in Clean.
19:56:59 <revenantphx> So ddarius 
19:57:21 <revenantphx> I'm suffering from an inability to think of this problem correctly.
19:59:05 <Eduard_Munteanu> I think having uniqueness types would provide some nice guarantees in Haskell.
19:59:40 <ddarius> At any rate, the stylized usage of uniquely type variables needed to get a large chunk of code to compile to in-place code is pretty much as bad as using monads, so while there are some cool aspects to uniqueness types, the gain isn't as big as it might be.
20:00:06 <ddarius> Eduard_Munteanu: It wouldn't add any semantic guarantees at all.
20:00:17 <Eduard_Munteanu> ddarius: you could have IO thread Unique around I think.
20:00:34 <ddarius> Eduard_Munteanu: Which doesn't change anything as IO is abstract in Haskell.
20:01:46 <Eduard_Munteanu> I was under the impression it could still help enforce referential transparency and help strictness analysis :/
20:02:41 <ddarius> I'm not sure it really interacts with strictness much at all and Haskell is a referentially transparent language, it's not going to be -more- referentially transparent with uniqueness types.
20:03:04 <Eduard_Munteanu> Like if ST were to use Unique behind the scenes, the compiler could reliably tell some value is strict.
20:03:35 <ddarius> However, it is possible you could do something clever, capability-like by using uniqueness.  So it could be used to provide guarantees that way.
20:03:49 <ddarius> Eduard_Munteanu: I have no idea how you are even making that connection.
20:07:53 <Eduard_Munteanu> Suppose the state was uniqueness typed and (>>=) took care of getting a new value for you. Then the compiler could tell "hey, we can safely be strict in the state".
20:08:33 <Eduard_Munteanu> I suppose you could also have add a RealWorld to ST and have IO that way.
20:08:40 <Eduard_Munteanu> Am I off track too much?
20:09:26 <revenantphx> What's a good project I can do in Haskell to learn it a bit better?
20:09:30 <revenantphx> Like something I can do in an afternoon.
20:09:37 <revenantphx> With some heavy googling.
20:10:41 <ddarius> Eduard_Munteanu: It's no more or less "safe" to be strict in a unique variable.
20:12:05 <Eduard_Munteanu> Hm, I thought it was rather easy to break referential transparency, even if not explicitly messing with unsafe*.
20:12:21 <ddarius> Eduard_Munteanu: Um, that would mean Haskell wasn't a pure language.
20:14:08 <Eduard_Munteanu> Well it's IO that can make it impure, IO isn't a language feature per se, it's a lib/compiler thingy that can break if misused.
20:14:32 <Eduard_Munteanu> I was under the impression a Unique type could be used to prove safety.
20:14:57 <ddarius> IO doesn't make Haskell impure.
20:17:31 <revenantphx> Is there a better way to manage state than passing it around with most functions calls TT_TT?
20:17:49 <revenantphx> I'm seriouslt considering having a function that forks off a thread or something, and allows access to it.
20:17:53 <revenantphx> As some kind of pseudo-state.
20:18:07 <Eduard_Munteanu> revenantphx: would Reader do it for you?
20:18:09 <revenantphx> Not 100% sure how/if that'd work, but it's a neat idea.
20:18:43 <revenantphx> idk :\
20:18:51 <revenantphx> anyways, Eduard_Munteanu, you know any good afternoon haskell projects?
20:19:06 <revenantphx> I'm thinking IRC client.
20:19:26 <Eduard_Munteanu> Um, I wouldn't consider that "afternoon".
20:19:34 <revenantphx> Very basic :P
20:21:36 <revenantphx> @hackage netwrok
20:21:37 <lambdabot> http://hackage.haskell.org/package/netwrok
20:24:50 <koninkje> awesome typo
20:25:13 <ddarius> Via LtU: http://arxiv.org/abs/1010.5023
20:32:31 <revenantphx> :t write
20:32:33 <lambdabot> forall (a :: * -> * -> *) w. (ArrowWriter w a) => a w ()
20:32:39 <revenantphx> :t Prelude.write
20:32:40 <lambdabot> Not in scope: `Prelude.write'
20:32:47 <revenantphx> :t System.IO.write
20:32:48 <lambdabot> Not in scope: `System.IO.write'
20:32:57 <augur> djahandarie: so
20:32:59 * revenantphx is desperately hoping that scary arrow related thing isn't the default one.
20:33:05 <augur> what did you understand and what did you not understand
20:33:20 <ddarius> revenantphx: Default what?
20:33:25 <revenantphx> write method
20:33:31 <revenantphx> hPutStrLn might be best for IRC though.
20:33:33 <ddarius> revenantphx: write what to what?
20:33:36 <revenantphx> Except I need "\r\n"
20:33:44 <revenantphx> To write to an irc connect.
20:33:55 <revenantphx> Oh well, I'll make my own method that attaches \r\n
20:34:03 <ddarius> If you want to output a String to a Handle, use hPutStr.
20:34:33 <monochrom> hSetNewlineMode h NewlineMode{outputNL=CRLF}
20:34:45 <revenantphx> ah, great
20:34:57 <revenantphx> But maybe I don't want to change behavior for everything :P.
20:35:10 <revenantphx> I can just have a sendIRC function that printf's with \r\n or something
20:35:47 <monochrom> for irc you want to change behaviour for all handles that talk to irc servers
20:35:48 <ddarius> revenantphx: Or you could just change it back when you're done, except you probably won't be using the handle for anything else, so I don't see what the problem is.
20:36:11 <revenantphx> Hm. How can I just make it "reset to what it was" though?
20:36:23 <monochrom> hSetNewlineMode h NewlineMode{outputNL=LF}
20:36:24 <ddarius> At any rate, it would probably benefit you to browse through the library documentation rather than guessing at things randomly.
20:36:34 <revenantphx> ddarius: this is true.
20:37:20 <monochrom> alternatively if you don't read the docs yourself, at least heed the advice given here rather than try to argue
20:37:27 <revenantphx> Hm, I guess it'd be easiest here.
20:37:30 <monochrom> if you have read the docs, you may argue.
20:37:41 <revenantphx> One question, if you change the newline mode...
20:37:49 <revenantphx> is that change only within the current scope/function?
20:37:55 <monochrom> the stance of possessing no knowledge and still arguing is illogical.
20:38:01 <revenantphx> Sorry >_<
20:39:25 <byorgey> revenantphx: no, it is global.  (which is why it's in the IO monad.)
20:39:44 <monochrom> it changes one handle at a time
20:39:54 <ddarius> Hence the need to pass it a handle.
20:42:21 <revenantphx> oh, its only that handle
20:42:24 <revenantphx> what was I thinking...
20:42:27 <revenantphx> not much apparently.
20:43:04 <monochrom> you were thinking that the call would cause changes to everything on your LAN
20:44:44 <revenantphx> monochrom: no, I was thinking within the program, nmd 
20:45:18 <monochrom> aim high. change all programs within the blast radius of 3 miles :)
20:45:28 <revenantphx> hehe
20:45:35 <ddarius> 3 miles is pretty mild.
20:45:46 <revenantphx> :canis.esper.net 461 aHaskellIRCBot USER :Not enough parameters
20:45:46 <revenantphx> :canis.esper.net 451 * aHaskellIRCBot :Register first.
20:45:48 <revenantphx> darn it.
20:45:51 <ddarius> It would not be hard to create a program that changed almost every internet connected computer.
20:45:59 <revenantphx> Same issue I had with ruby one a while back.
20:46:08 <revenantphx> NICK/USER/JOIN is all sending before it's ready...
20:46:16 <revenantphx> or is it just that freenode requires registration...
20:46:30 <monochrom> no, freenode doesn't require registration
20:46:42 <monochrom> but "canis.esper.net" doesn't sound like freenode
20:46:45 <Adamant> ddarius: only if the computer wanted to be changed. it would still be possible to create a program that changed almost every internet connected computer, but it would not be particularly easy
20:46:47 <ddarius> It looks like your USER string is incorrect, namely that it does not have enough parameters, but I'm just guessin'.
20:47:10 <ddarius> Adamant: I was not assuming cooperation.
20:47:29 <Adamant> unless you use "all Windows versions" as "almost every internet connected computer"
20:47:43 <ddarius> Adamant: You have a lot of faith in Linux.
20:48:07 <revenantphx> ddarius: 
20:48:08 <revenantphx> https://gist.github.com/719591
20:48:08 <Adamant> ddarius: I don't, but I have a broad definition of computer
20:48:18 <monochrom> There are too few Linux-running computers. I have no faith in Linux.
20:48:21 <ddarius> Adamant: That's still internet connected?
20:48:26 <Adamant> ddarius: yes
20:48:30 <revenantphx> User is 'nick mask * : real name' right?
20:48:38 <Adamant> smartphones are computers in my book
20:48:49 <ivanm> monochrom: :o
20:48:52 <Adamant> etc. etc.
20:48:55 <monochrom> USER trebla ignored0 ignored1 :Albert Lai
20:48:56 <ddarius> revenantphx: Why don't you check the dancer ircd documentation and/or the IRC RFCs.
20:49:03 <revenantphx> :anthony.freenode.net 451 * :You have not registered
20:49:20 <ddarius> Adamant: I don't see smartphones being any more secure than desktops.
20:49:22 <monochrom> "You have not registered" is just FYI only, shouldn't abort.
20:49:31 <revenantphx> Yeah, USER not enough params
20:49:45 <Adamant> ddarius: not any more secure, but getting zero-days on the whole range of things you would need to pop would take some real effort
20:50:08 <ddarius> Adamant: It's extremely unlikely that I would need zero-days.
20:50:38 <Adamant> there's a decent subset of fully patched computers these days.
20:51:48 <ddarius> Adamant: The question is the intersection between computer systems with no zero-day exploits available and well-maintained computers.
20:52:21 <Adamant> alright
20:52:49 <ddarius> At any rate, I think I will write a worm to end all worms.  It will simply parse bugtraq and co. and dynamically add exploits to itself.
20:53:00 <revenantphx> ddarius: hahah
20:53:30 <revenantphx> And it will be in haskell so it'll take an additional week for analysts to read the source :3
20:53:47 <ddarius> There wouldn't really be much source in that case.
20:54:19 <revenantphx> true.
20:54:28 <revenantphx> Plan:
20:54:31 <revenantphx> 1) Write said worm
20:54:36 <monochrom> it will take an additional week to read the machine code. have you seen GHC-generated machine code lately? it's a lot of fun.
20:54:49 <revenantphx> 2) Give it to IOCCC winner.
20:54:59 <revenantphx> oh true, compiled :P
20:55:04 <revenantphx> I saw it briefly.
20:55:23 <revenantphx> Obfuscated Perl Contest...
20:55:26 <revenantphx> isn't that redundant?
20:55:40 <Adamant> no, if you subset Perl it can be fairly readable
20:55:44 <Adamant> barring regexs
20:55:47 <monochrom> I'm wondering if virus analysts know CPS or equivalent
20:55:56 <ddarius> I'm sure they do.
20:56:09 <Adamant> monochrom: I've seen them work out Haskell and OCaml programs
20:56:13 <Adamant> before
20:56:18 <Adamant> but yes, they hate them
20:56:20 <monochrom> neato
20:56:36 <Adamant> however, if enough people do them, they will just add toolchain support for their analysis tools
20:56:42 <Adamant> and it will get a lot easier
20:56:42 <revenantphx> How does #haskell feel about CPS?
20:56:49 <ddarius> Assembly level reverse engineering is actually pretty fun.
20:56:49 <monochrom> love
20:56:55 <revenantphx> I don't mind it one bit.
20:56:57 <ddarius> CPS takes all the joy out of assembly.
20:57:05 <revenantphx> I dunno at the assembly level :P
20:57:28 <revenantphx> In Objective-C I use it with blocks for error handlers.
20:57:38 <Adamant> some of the reversing tools these days are pretty impressive
20:57:38 <ddarius> Most of the cool things you can do in assembly are much less impressive if you understand CPS.
20:57:44 <revenantphx> I write my functions so I can pass in a block to execute if an error occurs.
20:57:54 <revenantphx> ddarius: how does it apply at an asm level?
20:58:02 <revenantphx> Do you have an example? ;\
20:58:04 <revenantphx> :\*
20:59:27 <ddarius> Typical assembly is pretty much written in CPS, and much of the fun control flow tricks that you can do in assembly but can't in C or Java, say, are easily explicated using CPS.
21:01:53 <revenantphx> ddarius: Like what? The only asm control flow I'm aware of it jumping >_>
21:01:54 <ddarius> Pass-in-code-stream is still a fun thing to do in assembly though.
21:02:25 <ddarius> revenantphx: Control flow constructs from high-level language have to compile to -something-.
21:02:50 <revenantphx> ddarius: Well yeah :\
21:03:05 <revenantphx> I just always thought of them compiling to conditional jumps...
21:03:24 <revenantphx> And function cals
21:04:05 <revenantphx> dammit XD
21:04:09 <revenantphx> I forgot a space in a string
21:05:18 <revenantphx> haha!
21:05:22 <revenantphx> it's in!
21:05:30 <revenantphx> dw, I won't test the bot in here.
21:05:52 <monochrom> what's the usual format of x86 asm on linux? I mean how to add comments.
21:06:15 <revenantphx> something like
21:06:21 <revenantphx> mov ax, bx ;oh hey a comment
21:06:26 <monochrom> thanks
21:06:46 <revenantphx> but in that case, bx -> ax
21:06:53 <revenantphx> It's always src, dest
21:06:56 <revenantphx> Dunno why.
21:07:07 <revenantphx> AT&T syntax has it reversed I believe.
21:07:10 <revenantphx> and uses % everywhere
21:07:18 <revenantphx> It depends on the assembler...
21:07:33 <monochrom> they fought a hundred-year war on that
21:08:26 <revenantphx> Should I use hSelect for multiplexing in haskell
21:08:33 <ddarius> Not really.  AT&T syntax is nicer for compilers, Intel is nicer for humans.  Almost all assemblers support Intel syntax now, usually exclusively.
21:08:54 <revenantphx> Or is there a more "haskelly" way.
21:09:01 <revenantphx> hSelect is fine for me...
21:09:08 <ddarius> You should use threads.
21:09:17 <revenantphx> gotcha >_>
21:09:43 <revenantphx> So I could have a function which writes to stdout from a TChan, and have all sorts of threads write to that
21:11:03 <ddarius> Yes.
21:11:29 <monochrom> I do exactly that.
21:11:49 <ddarius> As do I, though I've usually used Chan.
21:12:00 <ddarius> (But then, STM wasn't around most of the time I've used Haskell.)
21:12:19 <revenantphx> The "shunt everything into a queue to serialize" is very nice to me...
21:12:21 <revenantphx> sometimes too nice.
21:13:00 <monochrom> if you use an event loop, you will find yourself wanting many more mutable variables
21:13:50 <ddarius> and also causing physical harm to yourself
21:14:12 <monochrom> so even with programs that talk to gtk, we tend to transform it to multi-threading
21:14:42 <revenantphx> The main issue I'm seeing here is "I have a few variables being passed to most of the functions"
21:14:57 <revenantphx> In this case, a handle, a chan, and maybe more stuff later.
21:18:24 <ddarius> You are pretty much not going to be able to avoid passing something around, but you can use a Reader monad to hide that if you care.
21:18:36 <tomberek> anyone familiar with the function loeb as in sigpfe's post: http://blog.sigfpe.com/2006/12/tying-knots-generically.html
21:18:47 <revenantphx> What I've been doing is sticking the repeated state into a tuple with a type synonym
21:18:56 <ddarius> revenantphx: Use a record.
21:18:59 <revenantphx> record?
21:19:10 <ddarius> revenantphx: Read the Gentle Introduction to Haskell.
21:19:28 <ddarius> tomberek: You are not going to get any responses with that question.
21:20:00 <tomberek> ddarius: um....
21:20:15 <revenantphx> Oh, and one other thing ddarius
21:20:26 <revenantphx> :t printf
21:20:28 <lambdabot> forall r. (PrintfType r) => String -> r
21:20:35 <revenantphx> 0.o....
21:20:36 <revenantphx> magic
21:20:50 <revenantphx> Anyhow, is there a function like Printf, except it JUST does formatting, no printing?
21:21:03 <mauke> yes. printf.
21:21:04 <tomberek> ddarius: what's a better way to ask?
21:21:22 <revenantphx> "The return value is either http://users.skynet.be/jyp/html/base/Data-Char.html#t%3AString or (http://users.skynet.be/jyp/html/base/System-IO.html#t%3AIO a)."
21:21:24 <revenantphx> WHAT?
21:21:39 <mauke> what are you reading?
21:21:45 <revenantphx> http://users.skynet.be/jyp/html/base/Text-Printf.html
21:21:56 <revenantphx> return type is either String or (IO a)
21:21:57 <revenantphx> 0.o
21:22:03 <mauke> "The return value is either String or (IO a)."
21:22:16 <revenantphx> Yeah.
21:22:26 <monochrom> it uses type class to enable that
21:22:27 <revenantphx> type system magic again?
21:22:29 <revenantphx> oh.
21:22:42 <ivanm> dammit, I've been tripped up by the order of foldr and foldl again :s
21:22:53 <monochrom> it's like "read". you could imagine "the return type is () or Bool or Char or Int or ..."
21:22:55 <ivanm> I was using foldrs everywhere, then I switched to foldl because I thought the resulting order was wrong...
21:23:05 <ivanm> and it looks like the order was correct the first time :s
21:23:22 <monochrom> when you get to use printf, you will appreciate this flexibility.
21:23:31 <revenantphx> yay. that was easy
21:23:32 <ivanm> (though I do need the "application order" of foldl, in that the first value is applied first; it just means the order of returned results are wrong :s)
21:23:47 <revenantphx> wait... hm.
21:23:59 <revenantphx> https://gist.github.com/719610
21:24:02 <mauke> ivanm: huh?
21:24:08 <revenantphx> s on line 51 is not getting displayed.
21:24:23 <revenantphx> But the messages for sendIRC (46) are.
21:24:26 <revenantphx> :\
21:24:41 <revenantphx> ACT
21:24:45 <revenantphx> I didn't fork in forkForever
21:24:47 <revenantphx> ACK*
21:24:48 <monochrom> «ByteString.pack (printf "%d %d" 5 4)» --- works.  «do ... putStrLn "the answer is:"; printf "%d %d" 5 4 ...» --- works.
21:24:51 <mauke> \r\n is wrong; should be \13\10
21:25:14 <mauke> hmm
21:25:25 <revenantphx> awesome, it works.
21:25:36 <revenantphx> mauke: >_>
21:25:54 <revenantphx> darn, it's ghosted.
21:26:10 <ivanm> mauke: using my planar graph library, where the edges are stored in clockwise order around a node; I'm wanting to create them in anti-clockwise order though for this specific function :s
21:26:44 <revenantphx> how does this look right now?
21:26:45 <revenantphx> https://gist.github.com/719612
21:27:37 <revenantphx> ddarius: Ctrl-F reveals records are never mentioned in a gentle introduction
21:28:29 <mauke> > "\^^"
21:28:30 <lambdabot>   "\RS"
21:28:32 <mauke> > "\^""
21:28:34 <lambdabot>   <no location info>:
21:28:34 <lambdabot>      lexical error in string/character literal at chara...
21:28:43 <mauke> > "\^:"
21:28:45 <lambdabot>   <no location info>:
21:28:45 <lambdabot>      lexical error in string/character literal at chara...
21:28:55 <mauke> > "\^\"
21:28:56 <lambdabot>   "\FS"
21:29:10 <revenantphx> ...what are you doing
21:29:22 <mauke> breaking my tokenizer
21:30:04 <mauke> also '\n' == '\10', always
21:30:17 <monochrom> revenantphx: http://www.haskell.org/tutorial/moretypes.html#sect6.2
21:30:25 <mauke> > nub "\n\10\LF\cJ"
21:30:27 <lambdabot>   <no location info>:
21:30:27 <lambdabot>      lexical error in string/character literal at chara...
21:30:32 <mauke> > nub "\n\10\LF\^J"
21:30:33 <lambdabot>   "\n"
21:31:23 <revenantphx> Oh, record syntax.
21:31:29 <revenantphx> I knew about that, how does it help me :\
21:31:37 <revenantphx> I mean, I see how it helps me with my existing method.
21:31:41 <revenantphx> But it's not a new way to do it.
21:31:53 <monochrom> it helps refute your <revenantphx> ddarius: Ctrl-F reveals records are never mentioned in a gentle introduction
21:32:02 <revenantphx> True >_<
21:32:14 <monochrom> perhaps think of it as helping ddarius
21:32:16 <revenantphx> they're called field labels though, not records
21:32:45 <monochrom> "Field names are not restricted to types with a single constructor (commonly called `record' types)"
21:32:55 <monochrom> ctrl-f for that
21:33:18 <revenantphx> Oh... the pdf isn't ocr'd
21:33:19 <revenantphx> fail.
21:33:48 * ivanm wishes that . and $ were available in type sigs
21:34:12 <mauke> type Dollar a = a
21:34:36 <ivanm> heh
21:34:42 <ivanm> doesn't really help for some reason...
21:34:47 <ddarius> tomberek: Unless you really do just want to know who is familiar with the Lb function for a survey or something, I don't know a better way to ask what you want to ask, because -I don't know what you want to ask-.
21:34:49 <ivanm> since that would just bring in _more_ parens!
21:35:12 <mauke> type Dollar a b = a b
21:35:22 <mauke> [] `Dollar` ()
21:35:42 <ivanm> you can infix in type sigs? :o
21:35:55 <ddarius> With an extension.
21:35:59 <ivanm> ahhhh
21:36:28 <tomberek> ddarius: there are two versions of the Lob, one uses a where.  I am uncertain as to the effect of that 'where' and what difference it would make if it was a 'let'. I've tested it and I see differences, but I'm not sure what it means.
21:36:44 <ivanm> tomberek: well, where is just syntactic sugar for wheres...
21:43:12 <ddarius> I'm not sure what you are considering the "two versions" of Lb.
21:43:46 <tomberek> ddarius: sigfpe defines it thus: loeb x = fmap (\a -> a (loeb x)) x
21:44:05 <tomberek> ddatius: a commenter defines:  loeb' x = result where          result = fmap (\a -> a result) x
21:47:10 <ddarius> The difference is that where (in most implementations) shares the result.  That is all.
21:48:29 * hackagebot relit 0.1.1 - Literal for regular expression  http://hackage.haskell.org/package/relit-0.1.1 (KazuYamamoto)
21:49:12 <tomberek> ddarius: and i also made a version that uses let, the three seem to have different run times..... Why is this sharing important? Commenter implies that without the where, the structure keeps getting created, but with a where it becomes truly circular.   And a let seems (with superficial testing) even faster than using where
21:49:52 <Kerah> Hi, is anyone talking french ?
21:50:06 <ddarius> There should be a #haskell.fr or #haskell_fr. 
21:50:29 <Kerah> Everybody is sleeping there :p
21:52:31 <_POD__> ~/quit
21:52:38 <_POD__> oops
22:04:44 <lars9> what's the meaning of Typeable?
22:05:08 <dmead> @hoogle typeable
22:05:08 <lambdabot> module Data.Typeable
22:05:09 <lambdabot> Data.Typeable class Typeable a
22:05:09 <lambdabot> Data.Typeable class Typeable1 t
22:05:35 <dmead> http://www.haskell.org/ghc//docs/6.12.1/html/libraries/base-4.2.0.0/Data-Typeable.html
22:06:20 <lars9> dmead: i've read that but not quite understand
22:06:46 <dmead> it puts everything into a typclass so casting is easier
22:07:34 <tomberek> ddarius: hey, sorry my internet crashed
22:08:31 <lars9> dmead: i only know there is class casting in c++ and java, but not in haskell
22:15:21 <revenantphx> :t forM_
22:15:22 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
22:15:23 <revenantphx> :t forM
22:15:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
22:15:41 <revenantphx> So... forM_ ignores what's returned... but what IS returned in just forM.
22:16:21 <revenantphx> is m [b] the result of every iteration?
22:16:37 <lars9> why there is no iterateM ?
22:16:52 <revenantphx> forM is apparently mapM swapped which is defined as sequence . map f
22:17:07 <lars9> forM = flip mapM
22:17:16 <lars9> :t forM
22:17:17 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
22:17:19 <lars9> :t mapM
22:17:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
22:17:23 <revenantphx> Yep.
22:17:49 <revenantphx> nite.
22:18:32 <lars9> forM files hGetLine returns lines in each file; forM_ ... returns nothing.
22:18:44 <lars9> in fact it does return ()
22:18:47 <lars9> which is nothing
22:19:07 <lars9> :t replicateM
22:19:08 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
22:19:21 <lars9> @hoogle m a -> m [a]
22:19:21 <lambdabot> Control.Applicative many :: Alternative f => f a -> f [a]
22:19:22 <lambdabot> Control.Applicative some :: Alternative f => f a -> f [a]
22:19:22 <lambdabot> Text.ParserCombinators.ReadP many :: ReadP a -> ReadP [a]
22:20:03 <lars9> @hoogle (a -> m a) -> (a -> m [a])
22:20:04 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
22:20:04 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
22:20:04 <lambdabot> Control.Monad filterM :: Monad m => (a -> m Bool) -> [a] -> m [a]
22:20:27 <lars9> yep, there is no iterateM
22:20:51 <osaunders> Everything you do is a balloon
22:22:06 <lars9> @hoogle repeatM
22:22:06 <lambdabot> No results found
22:23:50 <sgtarr> hi.
22:23:55 <osaunders> hi
22:31:40 * hackagebot ui-command 0.5.4 - A framework for friendly commandline programs  http://hackage.haskell.org/package/ui-command-0.5.4 (ConradParker)
23:04:33 <lars9> when we stacks StateT, WriterT, ReaderT, ErrorT...etc together, how can we access inner layers' monads?
23:05:06 <lars9> for example if if StateT is in the most inside layer, how to access 'get', 'put'?
23:05:49 * hackagebot special-functors 1.0.0.1 - Control.Applicative, Data.Foldable, Data.Traversable (compatibility package)  http://hackage.haskell.org/package/special-functors-1.0.0.1 (HenningThielemann)
23:06:14 <mauke> you just use get and put
23:07:57 <lars9> mauke: dont need to run other monad transformers first?
23:08:21 <lars9> mauke: what if there are a StateT, a ReaderT, then a StateT?
23:15:25 <c_wraith> :t lift -- lars9
23:15:27 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
23:16:00 <c_wraith> :t lift get
23:16:00 <mee> doesn't lift go the other way?
23:16:01 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadState a m, MonadTrans t) => t m a
23:16:15 <c_wraith> no, that's the question he's asking
23:16:43 <c_wraith> :t lift . lift $ get
23:16:44 <lambdabot> forall a (t :: (* -> *) -> * -> *) (m :: * -> *) (t1 :: (* -> *) -> * -> *). (MonadTrans t, Monad (t1 m), MonadTrans t1, MonadState a m) => t (t1 m) a
23:22:58 <dmead> how do you tell haddock to link to source?
23:23:32 <mtnviewmark> --hyperlink-source
23:23:38 <dmead> thanks
23:24:16 <mtnviewmark> though, if you're invoking from cabal
23:24:26 <dmead> i'm just invoking haddock
23:24:32 <mtnviewmark> brave!
23:24:36 <dmead> --hyperlink-source doesn't seem to be an option
23:24:44 <mtnviewmark> oh - silly me
23:24:46 <mtnviewmark> right
23:24:57 <mtnviewmark> that is ONLY if you are invoking from cabal or your Setup.hs
23:25:23 <mtnviewmark> if you do it that way, then cabal will build the source .html files for you as well
23:25:53 <dmead> yea i would, but i've already got git working
23:25:56 <mtnviewmark> invoking haddock directly can be tricky - as it needs to really know the compilation environment
23:26:21 <dmead> it works, i just assumed there'd be a switch to put the nice source links on the right side
23:26:47 <mtnviewmark> well, there is a switch for haddock to add the links, but haddock doesn't produce the source .html files
23:26:51 <mtnviewmark> that is a different utility
23:27:19 <dmead> do you know which one?
23:27:29 <mtnviewmark> hscolour
23:27:45 <mtnviewmark> haddock's flags are --source-base, --source-module, and/or --source-entity
23:27:59 <dmead> ahhh
23:28:01 <dmead> right
23:28:01 <dmead> thanks
23:28:02 <mtnviewmark> and have to be set to that haddock can generate a link to where the source ends up
23:28:06 <dmead> i just found that
23:28:37 <mtnviewmark> hence- I always build haddock via cabal
23:28:44 <dmead> gotcha
23:29:14 <mtnviewmark> (I know - seems crazy to have a tool that can only really be invoked via the build system...)
23:29:33 <mtnviewmark> (and, I often wonder if the hscolour functionality shouldn't just be pulled into haddock...)
23:29:57 <mtnviewmark> (since, in practice, no other source formatter is ever used)
23:30:04 <dmead> probably!
23:30:14 <dmead> but this is the unixy way of doing things
23:31:07 <mtnviewmark> only there is so much convention that has to agree between the two tools (so that URLs can be autogenerated), that it is perhaps, only one possible tool...
23:31:10 <mtnviewmark> anyway - 
23:31:13 <mtnviewmark> bed time for me
23:31:13 <mtnviewmark> laters
23:31:17 <dmead> cu
23:40:42 <wavewave> hi. how slow is the haskell math function compared to C?
23:40:58 <wavewave> for example, exp, sin, cos.. 
23:41:25 <wavewave> it seems about 10 times in my current program. 
23:41:59 <ddarius> They get compiled to the same code.
23:52:55 <lars9> can GADT replace existential type?
23:53:06 <copumpkin> yes
23:54:51 <rothwell> 'lo. is there anything available for writing literate haskell programs that gives me niceties such as numbered headings and the like, that isn't LaTeX?
23:56:11 <lars9> copumpkin: which one is prefered now?
23:56:31 <copumpkin> lars9: doesn't really matter
23:56:43 <copumpkin> GADT feels more generally consistent
23:56:54 <copumpkin> but it all ends up in the same bucket in the end
23:57:08 <lars9> copumpkin: i see
