00:02:17 * ksf wants TH to be able to lift arbitrary functions (e.g. in an ADT). I'm even willing to obey the current stage restrictions.
00:02:32 <lars9> what's new in ghc7: http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
00:02:57 <zack> how does <- work again?
00:03:07 <lars9> seems cool. but there is no arch package for ghc7 now
00:03:36 <ksf> which might be due to the fact that ghc7 isn't released yet and arch isn't as cool as gentoo.
00:03:43 <ivanm> zack: a <- m; ... === m >>= \ a -> ...
00:03:43 <Eduard_Munteanu> Hm, I might try getting a 6.10 GHC platform, that's what the installer wants.
00:03:59 <ksf> (not that I'd install ghc7 system-wide, yet)
00:04:08 <lars9> ksf: save energy, leave gentoo
00:04:09 <ksf> lars9, just download one of the snapshots.
00:04:37 <Eduard_Munteanu> lars9: there's a 'binary' use flag for GHC.
00:05:12 <lars9> ksf Eduard_Munteanu: sorry i didnt know gentoo can do that...
00:06:08 <zack> ivanm: sorry, that was more confusing. in english that would be let be something in m?
00:06:13 <Eduard_Munteanu> Where do I see the contents of the platform for previous releases?
00:06:15 <Mitar> mtl package does not compile on GHC 7?
00:06:53 <zack> let a*
00:06:54 <ivanm> zack: given a monadic value m, do { a <- m; f a} is equivalent to m >>= \ a -> f a
00:07:37 <zack> ah
00:07:37 <zack> ok
00:07:47 * ksf wonders noone has yet made a binary gentoo repo
00:07:57 <ksf> ...a public one, that is.
00:08:06 <Eduard_Munteanu> ksf: there are binary spinoffs of Gentoo.
00:08:15 <Eduard_Munteanu> ksf: like Sabayon
00:08:27 <Eduard_Munteanu> or Funtoo IIRC
00:08:33 <ivanm> ksf: because such a thing would suck
00:08:41 <ivanm> it kinda goes against the whole point of gentoo
00:08:42 <Eduard_Munteanu> But I'm not sure how much you can mix and match those with regular Gentoo.
00:08:49 <dolio> What's the point if I can't compile everything with -ffast-math?
00:08:54 <ivanm> doesn't stop someone from bringing the suggestion up every now and then on the forums though
00:08:58 <ksf> the whole point of gentoo is that you _can_ compile yourself, easily.
00:09:03 <ivanm> Eduard_Munteanu: exactly
00:09:18 <ksf> dolio, your programs will run flawlessly?
00:09:20 <ksf> damn ricers.
00:09:22 <ivanm> ksf: right, but if you use a pre-built binary you're dependent upon whichever system libs, USE flags, etc. the person who built it had
00:09:43 <ivanm> note the problems with the ghc binary used for bootstrapping whenever gmp or something gets updated
00:09:58 <dolio> I'll drive into a brick wall at 200mph, thanks.
00:10:03 <ksf> I don't think my system libs actually differ from a lot of other gentoo installs out there.
00:10:09 <Eduard_Munteanu> Prebuilt binaries should be statically linked.
00:10:27 <ksf> nah there's nixos for that.
00:11:43 <ivanm> ksf: yeah, nix sounds really interesting in that way
00:12:01 <Eduard_Munteanu> Ok, so anybody knows what version of GHC Haskell Platform 2010.1.0.0 has?
00:12:13 <ksf> it'd be nice if cabal could do that kind of stuff.
00:12:51 <ksf> the one thing I absolutely hate about gentoo is the abysmal speed of python/portage.
00:13:24 <Eduard_Munteanu> ksf: it ain't *that* bad. And there's also Paludis.
00:13:41 <Eduard_Munteanu> I tried it once.
00:13:43 <ksf> Eduard_Munteanu, just compare equery to fquery. it's astonishing.
00:14:31 <ksf> portage calculating deps always takes ages.
00:14:47 <Eduard_Munteanu> Yeah.
00:14:55 <ksf> ...and that's not due to disk IO, it's slow even when everything is in RAM.
00:15:25 <ivanm> I use paludis, but I don't notice it being that much faster
00:15:31 <ksf> the only thing that makes cabal slow is compiling Setup.hs
00:15:33 <ivanm> mainly because it's more thorough AFAICT
00:15:44 <ksf> ...which, usually, isn't even necessary.
00:16:03 <ivanm> ksf: we were contemplating interpreting it for ebuilds, but that requires an arch on which ghci works :s
00:16:23 <lispy> If nix is so great how come it's only at version 0.16 and no one is using it?  Fedora/RHEL/Centos, Debian/Ubuntu and Suse continue to have their own package managers.  Perl, python, CL, etc all have their own package managers. 
00:16:43 <ksf> it seems to be gaining.
00:16:58 <ksf> rpm and deb are basically the same, glorified tgzs
00:17:14 * Eduard_Munteanu found it, just browse the folder the download link points to
00:18:22 <ksf> portage does a good job of supporting all of those. there's even a script to generate texlive ebuilds, by now.
00:18:28 <Eduard_Munteanu> Good, 2009.2.0.2 has GHC 10.4
00:18:35 <Eduard_Munteanu> *6.10.4
00:18:43 <ksf> can't really blame upstream for doing their own stuff, haskell.org is doing it too.
00:20:01 <Eduard_Munteanu> Well haskell.org doesn't actually do package management. It just lets anybody slap a package on Hackage, and then cabal downloads it.
00:20:10 <Eduard_Munteanu> Not much of a reviewing/testing process.
00:20:26 <Eduard_Munteanu> *cabal install
00:21:05 <ksf> it's mostly a non-end-user repository, after all.
00:21:07 <Eduard_Munteanu> In an ideal world, I think CPAN and cabal install shouldn't exist.
00:22:00 <Eduard_Munteanu> ksf: well most end-users are developers, as far as Haskell goes, really :)
00:22:59 <ksf> as far as e.g. gentoo goes, it's sensible only to have the packages stuff like xmonad and darcs depend on in the main repo, in addition to plain ghc.
00:24:31 <ksf> (I'm infinitely grateful for the developers' wisdom to keep a binary in ~/.xmonad, btw, as I regularily break things so that I couldn't recompile it)
00:37:52 <Mitar> how can i make a derived instance of typed of type family memeber?
00:41:01 <ivanm> you mean type families?
00:41:03 <ivanm> you can't AFAIK
00:50:23 <payo> hey does anybody know a really good SDL tutorial with haskell?
00:50:33 <payo> or just a good one is fine too
00:51:08 <ivanm> not off the top of my head
00:51:13 <ivanm> @hoogle haskell sdl tutorial
00:51:13 <lambdabot> No results found
00:51:20 <ivanm> @hoogle haskell sdl
00:51:21 <lambdabot> No results found
00:51:30 <ivanm> @hoogle haskell
00:51:30 <lambdabot> Text.Parsec.Language haskell :: TokenParser st
00:51:30 <lambdabot> Text.ParserCombinators.Parsec.Language haskell :: TokenParser st
00:51:31 <lambdabot> package haskell-src
00:51:38 <ivanm> gah, I meant google, not hoogle...
00:51:42 <ivanm> @google haskell sdl tutorial
00:51:42 <lambdabot> No Result Found.
00:51:45 <ivanm> @google haskell sdl
00:51:47 <lambdabot> http://hackage.haskell.org/package/SDL
00:51:47 <lambdabot> Title: HackageDB: SDL-0.6.2
00:57:05 <payo> okay well now i know that i need to get the package and where to get it
00:57:18 <payo> which is step 1
01:02:59 <Cathy_Wayne> do you know what is the best to use as IDE to easy manage project on linux , Eclipse ? Is there NetBeans plugin ?
01:05:09 <ivanm> Cathy_Wayne: you mean a Haskell plugin for NetBeans?
01:05:22 <Cathy_Wayne> ivanm: yes .
01:05:36 <Cathy_Wayne> ivanm: or eclipse plugin is better ? or something else ? :)
01:05:36 <ivanm> not that I know of
01:05:42 <Cathy_Wayne> ivanm: sad ...
01:05:54 <ivanm> if you want an IDE, there's Leksah, and a plugin is available for Eclipse
01:06:08 <ivanm> but most people just use a text editor, typically emacs or vim
01:06:12 <Cathy_Wayne> ivanm: Liksah is really hard to understand
01:06:21 <ivanm> a few use gedit, kate, kdevelop, yi, etc.
01:06:32 <ivanm> Cathy_Wayne: *shrug* I believe they're working on documentation
01:06:38 <ivanm> preflex: seen hamishmack
01:06:38 <preflex>  hamishmack was last seen on #haskell 23 days, 6 hours, 33 minutes and 15 seconds ago, saying: Modius: When I have time
01:06:39 <Cathy_Wayne> ivanm: I want compile button etc )
01:06:49 <ivanm> C-c C-l
01:06:54 <ivanm> just load it up in ghci!
01:08:04 <Cathy_Wayne> ivanm: hm... so if I want to use Kate I open edit then how to compile ? go to terminal ? find this directory and ghc ? this is hard )
01:08:38 <Cathy_Wayne> ivanm: myabe eclipse then is just for me ? :)
01:09:08 * nus- wnats DWTM button
01:12:17 <paolino> Hello,I have a question on Traversable and zip
01:13:49 <Eduard_Munteanu> Oh, FFS, why does the gtk2hs-0.10.1 installer want an *exact* version of GHC?
01:14:05 <Eduard_Munteanu> paolino: go ahead and just ask it.
01:14:25 <paolino> with toList and mapAccumL on traversables it is possible to mimic a zipWith, but there is nothing that prevent to zip different places as toList destructure the traversable
01:15:00 <Saizan> Eduard_Munteanu: if it's a binary installer that's how GHC works
01:15:49 <paolino> I guess a zipper should be good to zip structures. I wonder if there is something in between
01:18:55 <Saizan> well, even in the original zipWith you've to make up for the fact that the two lists might be of different shape
01:19:25 <paolino> it is nice to note that zip exists only for list because they cannot be destructured more
01:19:31 <paolino> Saizan, right
01:22:44 <nus> @google Scrap your zippers
01:22:45 <lambdabot> No Result Found.
01:22:53 <Eduard_Munteanu> Saizan: thanks, I think I finally solved it by using an older platform
01:23:19 <Jafet> > zip "your" "scrappers"
01:23:20 <lambdabot>   [('y','s'),('o','c'),('u','r'),('r','a')]
01:25:21 <Eduard_Munteanu> Good, also the older platform no longer has broken mingw
01:27:06 <paolino> the type system is a nice trip given for free from haskell programming
01:28:22 <Eduard_Munteanu> Hm, I might as well post a mingw howto on the wiki.
01:28:28 <nus> https://www.cs.indiana.edu/~adamsmd/papers/scrap_your_zippers/
01:28:51 <Eduard_Munteanu> Ehm, Wine rather than mingw
01:31:06 <nus> Eduard_Munteanu, what are you using Wine for?
01:31:57 <Eduard_Munteanu> nus: crosscompiling stuff for Windows.
01:32:38 <nus> Eduard_Munteanu, Haskell stuff?
01:33:44 <paolino> > let zW g r = snd . mapAccumL (\(x:xs) y -> (xs,g x y)) (toList r) in zW (,) "your" "scrapper"
01:33:45 <lambdabot>   Not in scope: `toList'
01:33:56 <Eduard_Munteanu> nus: yeah. I want to do my assignments in Haskell, and the instructor wants binaries. *sigh*
01:34:20 <Jafet> Ship it with hugs
01:35:03 <Eduard_Munteanu> Jafet: I'm not sure he'd know how to run them. It seems easier if it's a mere .exe
01:35:32 <Eduard_Munteanu> Jafet: also, I might depend on other packages.
01:36:14 <Eduard_Munteanu> We're not doing anything Haskell at school.
01:37:07 <Eduard_Munteanu> The official languages for these assignments is C or Matlab (but most use the latter), although he said it's okay to use other languages as well.
01:38:04 <Jafet> Numerical analysis?
01:38:25 <Jafet> The hugs suggestion was obviously not serious, although you really could wrap your code in a batch file if you wanted
01:39:10 <Eduard_Munteanu> Jafet: not exactly, compression algorithms. The first homework was calculating entropies and such (I used Chart to plot), but next one is Shannon-Fano compression.
01:39:29 <Eduard_Munteanu> And I figure trees are more elegant and easier to manipulate in Haskell than C or, god forbid, Matlab.
01:40:11 <Jafet> Matlab, at least, is okay for numerical analysis.
01:40:43 <Eduard_Munteanu> Yes, there are lots of algos already implemented. But the type system really sucks.
01:40:54 <Eduard_Munteanu> A lot moreso than C.
01:42:22 <Jafet> Bah, someone should design a universal compression method already
01:43:29 <nus> > const 42
01:43:30 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> t)
01:43:30 <lambdabot>    arising from a use of `...
01:44:49 <Eduard_Munteanu> Jafet: also Matlab is a bit functional.
01:45:27 <Jafet> (If there exists an encoding method for a string xs to a string of length l, xs can be encoded with the universal method with length O(1) + l.)
01:47:39 <Eduard_Munteanu> Jafet: doesn't that amount to perfect compression plus a constant factor?
01:48:18 <quicksilver> Jafet: you need to be a bit more careful with definitions to set that up.
01:48:58 <quicksilver> Jafet: for any fixed string xs you can design the stupid encoding which takes "xs" to a '0', and leaves everythign else unchanged except a prepended '1'.
01:48:59 <Jafet> What do you find is careless?
01:48:59 <payo> anyone know how to run a program +arguments in Cygwin?
01:49:09 <payo> im looking for the answer but its hard to find
01:49:36 <quicksilver> so there is an encoding method (for any fxied string) which encodes in in length 1.
01:49:46 <Jafet> Sure. You can encode that stupid encoding into U in O(1). Except the big-O constant is the size of xs.
01:50:10 <lars9> what viewer can view .ps directly? i used to ps2pdf then xpdf
01:50:10 <payo> wait i got it...
01:50:16 <Eduard_Munteanu> payo: I didn't get it.
01:50:28 <quicksilver> but your universal argument says you can repeat that procedure for every single strng
01:50:30 <Eduard_Munteanu> lars9: evince
01:50:36 <quicksilver> lars9: ghostview (gv)
01:51:01 <Eduard_Munteanu> evince also can copy&paste text
01:51:05 <lars9> quicksilver: not in arch's repo..
01:51:28 <lars9> Eduard_Munteanu: xpdf can do that too.
01:51:35 <Eduard_Munteanu> Oh.
01:51:46 <Eduard_Munteanu> Well, at least it has a saner interface than xpdf.
01:51:54 <Jafet> quicksilver: yeah. It's not the same O() every time.
01:52:11 <Jafet> Er, O(1)
01:52:12 <lars9> sometimes, some old pdf is displayed very coarse, do you have that problem?
01:52:38 <Eduard_Munteanu> lars9: hm, I'm not sure.
01:52:46 <Jafet> Sounds like you're reading a raster scan with overlaid OCR. Paper publishers do that a lot.
01:52:59 <Eduard_Munteanu> lars9: the only serious problem I had was some lines appeared very very thin, almost invisible.
01:53:03 <Jafet> (And remember tex didn't exist until recently)
01:53:05 <quicksilver> xpdf does a very poor job with bitmapped fonts
01:53:25 <quicksilver> such as those produced by Tex -> ps -> ps2pdf
01:53:41 <quicksilver> acroread + apple preview do much better
01:54:24 <payo> what directory should cabal.exe be in in order to use it?
01:54:39 <Eduard_Munteanu> payo: I'd think in $PATH
01:54:57 <payo> it's telling me GHC is not installed, but its right there in C:/2010.2.0.0/bin
01:55:01 <payo> i dont know what $PATH is
01:55:10 <ksf> try "echo $PATH"
01:55:28 <Eduard_Munteanu> payo: why are you using Cygwin?
01:55:40 <ksf> also, export PATH=/cygrdive/c/2010.2.0.0/bin:$PATH
01:55:56 <lars9> quicksilver: maybe i'll try mac sometime. i just like archlinux too much
01:55:58 <payo> im using Cygwin because i got an error installing the SDL package with cabal
01:55:59 <Eduard_Munteanu> s/cygrd/cygdr/
01:55:59 <ksf> cygdrive, even.
01:56:19 <payo> the error said the script uses ./something and to install cygwin
01:56:26 <ksf> cygwin is the only reason windows is remotely useable...
01:56:44 * Saizan prefers msys
01:56:55 <bastl> How do i refer to an infix function in an qualified module ?
01:57:11 <ksf> with the most unintuitive syntax ever.
01:57:15 <augur> anyone know of this sorting algorithm: items -> buckets; bucket keys -> sort bucket keys -> sorted items
01:57:16 <augur> ?
01:57:20 <ksf> (which I don't remember)
01:57:23 <Saizan> bastl: you mean an operator?
01:57:46 <bastl> a constructor, I want to pattern match on it.
01:58:01 <Saizan> i thought it was e.g. import qualified Data.Map; .. Data.Map.!
01:58:17 <Saizan> a constructor can be an operator :)
01:58:25 <lars9> augur: what's that? i cannot get it..
01:58:53 <Saizan> i meant those identifiers made of symbols
01:59:00 <Saizan> for constructors they start with :
01:59:14 <bastl> i have "data Decl = (:=) Char Expression | ... "
01:59:15 <Eduard_Munteanu> payo: I reckon you could try msys' bash
01:59:23 <bastl> in module X
01:59:36 <Eduard_Munteanu> payo: or go ahead with Cygwin, but mind it's really old stuff, IDK if it's maintained anymore.
01:59:40 <bastl> pattern-match looks like X.(:=) ?
01:59:56 <augur> lars9: instead of sorting a whole list, you sort the list into buckets (counts of instances), then you sort the (unique) list of instances, and then expand out the items
02:00:23 <Saizan> either "foo (X.(:=) a b) = .." or "foo (a X.:= b) = .."
02:00:40 <bastl> neither work for me
02:00:50 <lars9> augur: is that radix sort?
02:00:55 <augur> lars9: dont know
02:00:59 <bastl> oh, i misread the latter.
02:01:09 <lars9> augur: only works on numbers?
02:01:21 <augur> lars9: works on anything with == and > defined
02:01:38 <augur> no, its not radix sort.
02:02:14 <lars9> augur: merge sort?
02:02:24 <Saizan> bastl: the former should have been (X.:=), sorry
02:02:31 <lars9> augur: there are not too many sorting algs.
02:02:48 <augur> lars9: its really a preprocessing and postprocessing step not a real algo
02:03:08 <bastl> yup, that works.
02:03:13 <bastl> thanks Saizan
02:04:09 <augur> lars9: i dont know how to code this in haskell, but in ruby it'd be something like   list.inject({}) { |counts, x| counts[x] = (counts[x] || 0) + 1; counts }.to_a.sort { |(x,nx),(y,ny)| nx <=> ny }.bind { |(x,nx)| [x]*nx }
02:05:07 <payo> alright i followed the export suggestion, but cabal is still giving me an error
02:05:21 <lars9> ehh... i would be able to understand it if it's in python
02:05:23 <payo> http://img828.imageshack.us/img828/8242/27019850.png
02:05:29 <payo> thats the error in that image there
02:05:48 <nus> payo, read this: http://mirror.seize.it/hsSDL/hssdl/WIN32
02:06:05 <augur> lars9: its basically just count the instances of each thing, sort the uniques, then multiply the number of each thing to its original count
02:06:13 <nus> payo, you need SDL-devel-mingw32
02:06:57 <payo> okay, i'll read that and try again this time installing SDL-devel-mingw32
02:07:24 <augur> lars9: also sorry that shouldve been x <=> y not nx <=> ny
02:07:43 <Eduard_Munteanu> Also note you have to be careful not to bring Cygwin's stuff in unnecessarily into executables. You might not need its whole POSIX layer for Haskell work.
02:08:43 <lars9> augur: sorry i dont know ruby... but there should be no sorting algorithms we dont know...
02:08:48 <augur> bah
02:09:11 <knobo``> How do I make a type an instance of Data?
02:11:09 <quicksilver> knobo: just derive it.
02:12:27 <knobo> quicksilver: but i use a type from a library.
02:12:34 <lars9> augur: do you mean you are sorting a list of items, according to the their times of appearance?
02:12:49 <ksf> knobo, then standalone derive it.
02:13:25 <knobo> I probably have to implement gfoldl, gunfold, toConstr and dataTypeOf
02:13:35 <ksf> nope, you don't.
02:13:35 <quicksilver> standalone derive it.
02:13:49 <ksf> -XDeriveDataTypeable and -XStandAloneDeriving
02:13:56 <quicksilver> although if it's an opaque type, it's probably immoral to derive Data on it.
02:14:54 <knobo> ksf: Is there some documentation for that?
02:15:46 <ksf> in the ghc manual, yes.
02:15:56 <new11> @pl f xs cond = filter (not cond) xs
02:15:57 <lambdabot> f = flip (filter . not)
02:18:26 <lars9> augur: hi there?
02:18:30 <knobo> ksf: is it just to add those parameters, and it should work by it self?
02:18:52 <knobo> i still get "No instance for (Data Message) ...."
02:18:53 <ksf> yep.
02:19:02 <lars9> augur: try this: (sortBy (comparing length) . group . sort) l, where l is your list.
02:19:35 <ksf> well you have to deviving instance ... somewhere, of course.
02:19:48 <lars9> > (sortBy (comparing length) . group . sort) [1,2,3,4,2,2,3,2,4]
02:19:49 <lambdabot>   [[1],[3,3],[4,4],[2,2,2,2]]
02:20:12 <lars9> > (map (\l->(head l, length l)) . sortBy (comparing length) . group . sort) [1,2,3,4,2,2,3,2,4]
02:20:13 <lambdabot>   [(1,1),(3,2),(4,2),(2,4)]
02:22:26 <quicksilver> knobo: google for "standalone deriving"
02:22:56 <knobo> thanx
02:24:45 <Eduard_Munteanu> quicksilver: lol, immoral
02:25:06 <Eduard_Munteanu> It's unamerican
02:25:40 <quicksilver> I'm unamerican.
02:25:48 <quicksilver> but very moral.
02:25:50 <Jafet> "You may not derive our Data to any person or entity in Iran, Syria, Cuba..."
02:26:04 <Eduard_Munteanu> quicksilver: yeah, I didn't mean one implies the other.
02:27:40 <Eduard_Munteanu> Heh, Jafet 
02:39:05 <aleator> Hi, Using TH, how should I write [d|$(mkName "myFun") x y z = x+y+z|]?
03:08:46 <lars9> ls
03:10:24 <Jafet> . .. Faxes
03:14:10 <payo> anyone know what this means in this image?
03:14:11 <payo> http://img827.imageshack.us/img827/1141/47225304.png
03:14:22 <payo> 'Construct not supported' line
03:14:59 <payo> the 'Construct' is line 58 of SDL.cabal
03:15:08 <quicksilver> I think it probably means wrong version of cabal
03:15:14 <payo> which is... Include-Dirs: C:\SDL-1.2.14\include
03:15:32 <payo> oh really? >=| frustrating
03:15:49 <Funktorsalat> aleator: something like [FunD (mkName "myFun") [Clause [VarP x_1,VarP y_2,VarP z_3] (NormalB (InfixE (Just (InfixE (Just (VarE x_1)) (VarE GHC.Num.+) (Just (VarE y_2)))) (VarE GHC.Num.+) (Just (VarE z_3)))) []]] ;)
03:15:58 <Adamant> Jafet: nothing was certain in the 90's except Death and those
03:16:00 <ksf> don't use include-dirs with absolute paths.
03:16:09 <Funktorsalat> aleator: that's not valid code though; it's just the 'show' instance of Dec
03:16:13 <ksf> pass such things on the command line
03:16:21 <Funktorsalat> (replace the x_1 with mkName "x" etc)
03:16:37 <Jafet> Adamant: nah, it's a bash quotes reference
03:16:56 <payo> ksf: im following this guide here
03:16:56 <payo> http://mirror.seize.it/hsSDL/hssdl/WIN32
03:17:31 <payo> how would i implement the Include in command line in the command 'runghc Setup.lhs configure'?
03:17:44 <payo> in windows cmd program thing?
03:18:20 <lars9> @hoogle listenOn
03:18:20 <lambdabot> Network listenOn :: PortID -> IO Socket
03:18:34 <ksf> --extra-include-dirs=PATH
03:18:53 <Funktorsalat> aleator: maybe better: valD (varP (mkName "myFun")) (normalB [| \x y z -> x+y+z |]) []
03:19:05 <ksf> cabal configure --help
03:19:14 <payo> so --extra-include-dirs=C:\SDL-1.2.14\lib
03:19:15 <payo> ?
03:19:25 <ksf> yep.
03:19:32 <ksf> well you might have to escape \
03:19:32 <lars9> is haskell's Network using select or epoll?
03:19:36 <aleator> Funktorsalat: I'm trying to avoid writing too much lisp in my code, so I'm after something that I could splice in place of identifiers.
03:19:44 <payo> escape \?
03:20:02 <ksf> because \t would be a tab, you have to write \ \\ in bash.
03:20:23 <ksf> blame microsoft and hysteric raisins for using \ as a path separator.
03:20:26 <payo> and the --extra stuff comes after 'runghc Setup.lhs configure'
03:20:30 <payo> heh
03:20:41 <ksf> yep
03:20:50 <payo> so just replace all instances of \ with \\?
03:20:55 <ksf> yep.
03:21:00 <payo> ah okay, ima try it...
03:21:03 <ksf> or put everything between ""
03:21:08 <ksf> or ''
03:21:27 <Funktorsalat> aleator: well in an expression context you could splice $(varE (mkName "blah")) and so on, but the 'f' in 'f x y z' is not of any of the types of things that can be spliced
03:21:37 <emilmeln> Doesn't Windows allow you to use the usual '/' seps?
03:21:41 <Funktorsalat> it's just the first arg of FunD
03:22:45 <aleator> Hmm.. I'll then just try to live with it.
03:24:23 <lars9> @hoogle loop
03:24:23 <lambdabot> Control.Arrow loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
03:24:23 <lambdabot> Data.Graph.Inductive.Example loop :: Gr Char ()
03:24:23 <lambdabot> Data.Graph.Inductive.Example loop' :: IO (SGr Char ())
03:25:00 <Funktorsalat> aleator: I'd go with the valD and expression splice
03:28:36 <payo> ksf:
03:28:37 <payo> <payo> hey, what if i want to do Include-Dirs: C:\SDL-1.2.12\include
03:28:38 <payo> <payo> Extra-Lib-Dirs: C:\SDL-1.2.14\lib
03:28:38 <payo> <payo> both of those?
03:28:38 <payo> <payo> how would i specify that in command line?
03:28:38 <payo> <payo> neither of those 'constructs' are supported
03:28:38 <payo> <payo> er actually they're both 1.2.14 just pasted from different locations
03:28:53 <payo> or anyone who knows how to specify those lines in command line...
03:29:11 <payo> on Win32
03:29:21 <payo> -_-
03:29:55 <ksf>     --extra-include-dirs=PATH      A list of directories to search for header
03:29:55 <ksf>                                    files
03:29:55 <ksf>     --extra-lib-dirs=PATH          A list of directories to search for external
03:29:55 <ksf>                                    libraries
03:30:25 <payo> okay i'll just append them both in sequence
03:32:33 <payo> kay now its complaining that the package has a ./configure script which requires a unixy environment
03:32:42 <payo> should i just ignore that or try again in Cygwin?
03:33:07 <ksf> hmmm.
03:33:14 <ksf> I'd say you should install a unix.
03:33:34 <payo> alright, whats the equivalent command line commands in Cygwin?
03:33:38 * hackagebot flock 0.2.2 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.2.2 (ErikHesselink)
03:34:01 <payo> or i could just install linux on my computer (which would require me to purchase a CD-ROM drive lawl)
03:34:07 <ksf> replace c:\ with /cygdrive/c and you're done
03:34:12 <payo> kayyy
03:34:22 <ksf> nah.
03:34:40 <ksf> you can install linux on ntfs, on the same partition.
03:34:46 <quicksilver> you don't need a CDROM drive to install linux, but that is a tangent if ever I saw one.
03:35:05 <ksf> I think there's even an ubuntu windows installer
03:35:11 <payo> so replace all instances of \\ with /?
03:35:16 <ksf> yep
03:35:22 <payo> *phew* that should be it
03:36:51 <ksf> http://www.ubuntu.com/desktop/get-ubuntu/windows-installer
03:37:50 <lars9> quicksilver: i always install with usbkey
03:38:04 <quicksilver> quite.
03:38:18 <ksf> I always install via tgz
03:38:53 <lars9> ksf: lol, how can bare metal recognize tgz?
03:39:17 <ksf> boot the machine, shove all data from the 2nd system partition to another disk, unpack the gentoo base tgz in the empty partition, then chroot.
03:40:36 <ksf> anyway, windows users can just install all the stuff on their ntfs partition, linux reads+writes+boots off of it just fine.
03:41:16 <lars9> dons' blog: http://donsbot.wordpress.com/
03:43:27 <lars9> he lives on haskell now, how good it is...
03:43:33 <payo> okay, now im getting a warning that the /lib and /include directories don't exist
03:43:42 <payo> but they do!
03:44:02 <payo> ./runghc setup.lhs configure --extra-include-dirs=/cygdrive/c/SDL-1.2.14/include --extra-lib-dirs=/cygdrive/c/SDL-1.2.14/lib
03:44:08 <payo> that's the exact command i entered
03:44:40 <payo> and those directories are real...
03:44:49 <lars9> payo: just get a virtualbox, it saves your time
03:49:04 <payo> ima play around with these directory names see if i can get it to work...
03:49:30 <Saizan> payo: i think you should pass the real ones rather than the cygdrive things
03:50:20 <Saizan> the mess with cygdrive is the main reason i prefer msys, you can use the provided utilities directly from cmd.exe
03:50:21 <payo> okay i did it by typing c://
03:50:26 <ksf> I think he should get himself an operating system
03:50:33 <Funktorsalat> Saizan: :D I think he has just been told to use the cygdrive ones
03:50:40 <Funktorsalat> (disclaimer: I have no idea either wa)
03:50:43 <Funktorsalat> *way
03:51:06 <payo> but now it says SDL is not installed as an error. but the whole point of this is supposed to be *to install SDL???*
03:51:28 <ksf> well, the haskell bindings, not sdl itself.
03:52:03 <payo> heh
03:55:04 <payo> im gonna register to SDL forums and start a topic on this
03:55:26 <payo> i'll download Ubuntu if needed...
03:59:54 <turiya> is there any advantage of implementing matrices as functions on the plane..
04:00:24 <ksf> you can make them continuous
04:00:56 <aleator> matrices as in linear transforms?
04:01:25 <turiya> yes, addition and subtraction would work the expected way
04:04:14 <Saizan> Funktorsalat: clearly that advice was wrong
04:06:13 <Saizan> payo: btw, http://jpmoresmau.blogspot.com/2010/05/haskell-sdl-on-windows-check-hacking.html
04:08:03 <alpounet> payo, just have to install SDL (the C library) separately, before trying to install the haskell binding
04:09:32 <Funktorsalat> turiya: the two reps are pretty equivalent as long as all your functions are linear trafos and you have a chosen basis
04:09:46 <Funktorsalat> you can recover one from the other
04:10:45 <Funktorsalat> I'm assuming your functions would be closures of the form "multMatrixVector someMatrix" here
04:11:22 <Funktorsalat> composing such functions may lead to a less efficient representation than multiplying the matrices though
04:11:43 <Funktorsalat> (or maybe more efficient in some simple cases? :))
04:11:53 <Funktorsalat> like identity functions
04:12:33 <quicksilver> function composition doesn't get the benefit of memoization if you use it twice
04:12:45 <quicksilver> matrices, being a concrete representation, do.
04:13:58 <bremner> higher order memoization, cool.
04:14:55 <new11> how do you prove such a property:  "and (map cond (filter cond xs) == True" for all xs
04:15:01 <payo> alpounet: OK I've got the C++ runtime libraries, but they are in a zip file. How do I install them? may sound like a silly question but i need them to be recognized as installed
04:17:13 <payo> ive got the runtime libraries and the C++ 2005 version too
04:18:10 <payo> oh i have to compile this with a C++ compiler huh. i see what u did there
04:18:27 <Funktorsalat> quicksilver: yeah, but OTOH the identity function (say) is cheaper as a function than a matrix
04:18:34 <payo> sorry guys im just totally new to all this stuff. almost done with lyah and thats all i know about programming
04:18:47 <Funktorsalat> (and a composition of a few of them is still cheaper)
04:19:00 <turiya> Funktorsalat, so the "functional" representation is a disadvantage
04:19:11 <Funktorsalat> same may hold for scalings etc
04:19:40 <Funktorsalat> turiya: I guess that for dense matrices, yes
04:21:59 <turiya> Funktorsalat, i dont know much about memoization but i wanted to know the better way of handling matrices..
04:22:59 <turiya> would using lists for matrices be too computationally expensive?
04:25:06 <Funktorsalat> turiya: a 3x3-matrix (say) is a fixed bunch of 9 numbers, while when you use functions directly, you get a tree (for binary operations) or linked list (for unary ones) of closures. e.g., functionPlus f g = \x -> f x + g x will produce a function that is represented as a closure with two pointers (to the summand functions)
04:26:02 <Funktorsalat> which will get more expensive in both space and time required for application after several operations
04:27:03 <Funktorsalat> turiya: yes, I think a list would be a bad choice over an array (but I'm not an expert with haskell linear algebra algorithms :))
04:27:43 <luite> I want to do some linear programming with hmatrix-glpk, which depends on glpk and lapack. I've already installed the required cabal packages, and my program runs fine when compiled. but when running from ghci, I get this: can't load .so/.DLL for: glpk (addDLL: could not load DLL)
04:27:59 <luite> the required blas/lapack dll files are somewhere in the PATH
04:28:31 <dcoutts_> luite: do the names match exactly?
04:28:33 <turiya> Funktorsalat, thanks for the info, even though i did not understand much :)
04:29:23 <luite> dcoutts_: wait, I just realized that this might be because of the glpk library and not blas/lapack :)
04:30:15 <dcoutts_> luite: see ghc-pkg field ${pkgname} extra-libraries, if it lists foo then ghc looks for foo.dll
04:30:41 <dcoutts_> luite: some C libs have different names for their import .lib and their .dll, e.g. foo.lib but foo-0.dll
04:31:23 <payo> alright ima install ubuntu... thanks to those who suggested it
04:33:03 <luite> dcoutts_: hmm, extra-libraries: glpk  (for hmatrix-glpk), but I only have a static libglpk.a (built with mingw)
04:33:16 <dcoutts_> luite: ah, well there you go
04:33:46 <dcoutts_> luite: so you can build statically linked .exes but not use it in ghci
04:33:47 <luite> isn't it possible to make ghci load the static lib? executables are also linked statically
04:34:24 <dankna> and you can't load executablees in ghci either
04:34:27 <dcoutts_> luite: not in ghc-6.12 I think, you can try linking the whole .a into a single .o
04:34:57 <luite> oh I'm using 7.0.0.20101111
04:34:59 <dankna> my understanding is that static libraries have discarded some information that dynamic libraries have retained
04:35:11 <dcoutts_> luite: I think ghci-7 might have .a loading, but it's only designed for Haskell code, C code might have funny relocations that ghci's linker does not grok
04:35:14 <dankna> and that therefore there is no trick with the linker to make them loadable dynamically
04:35:40 <luite> dcoutts_: how can I try it? add the .a to the ghci command line?
04:35:45 <dcoutts_> luite: right
04:35:53 <dcoutts_> dankna: not really, it just has to be done differently
04:35:57 <dankna> hmm okay
04:36:28 <dcoutts_> dankna: shared libs are designed to be able to be loaded quickly without copying everything around and doing a full link
04:36:34 <dankna> hmm okay
04:36:38 <luite> hmm, it still tries to load the dll file, don't know if that's expected
04:37:14 <dcoutts_> luite: yes because the package still says it should, you'd need to change the package description
04:37:51 <dcoutts_> luite: ghc-pkg descriptions have a special extra-ghci-libraries field which if used overrides the extra-libraries field
04:38:11 <dcoutts_> luite: you could try specifying the full path and name of the .a lib in there
04:38:36 <luite> ok, I'll give it a try
04:42:18 <new11> how do we prove such a property:  "and (map cond (filter cond xs) == True" for all xs
04:43:02 <Jafet> @check (\xs -> all cond (filter cond xs))
04:43:02 <lambdabot>   Not in scope: `cond'Not in scope: `cond'
04:43:11 <Jafet> @check (\cond xs -> all cond (filter cond xs))
04:43:11 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
04:43:11 <lambdabot>    arising fro...
04:43:21 <Jafet> Weak.
04:46:29 <companion_cube> imperative programming is hell...
04:47:59 <Entroacceptor> companion_cube: no, it is not
04:48:29 * companion_cube currently tries to bind two imperative (java) solvers together...
04:48:51 <companion_cube> so complicated
04:49:21 <Jafet> One jni to rule them all
04:51:25 <companion_cube> the point is just about how awful spaghetti code can be :)
04:52:21 <alpounet> payo, put them wherever you want
04:52:50 <alpounet> just tell cabal where they are through the --extra-lib-dirs and --extra-include-dirs (or something like that) options 
04:53:39 <luite> dcoutts_: does ghc-pkg cache the package registration information somehow? I edited the package registration file, but it still doesn't show anything when I query the field with ghc-pkg field hmatrix-glpk extra-ghci-libraries
04:53:51 <dcoutts_> luite: yes
04:54:08 <dcoutts_> luite: if you edit the files directly (naughty) then you need to ghc-pkg recache
04:54:48 <luite> dcoutts_: according to some trac post, it isn't possible to specify this in the .cabal file, and I didn't know another way :)
04:55:11 <dcoutts_> luite: official method is: ghc-pkg describe foo > foo.pkg; vi foo.pkg; ghc-pkg update foo.pkg
04:55:31 <luite> ah thanks :)
04:55:42 <luite> except that it's emacs instead of vi, of course ;)
04:56:04 <Jafet> M-x term vi
04:57:18 <ketil> @djinn [a] -> a
04:57:18 <lambdabot> Error: Undefined type []
04:57:32 <ketil> Can I ask djinn for list types?
04:58:55 <hpc> list is a recursively defined type; djinn doesn't really like those
04:59:18 <luite> dcoutts_: it says that the file cannot be found, so I guess it still tries to add .dll to the filename
05:00:44 <dcoutts_> luite: sigh, the problem is we can't leave the extra-ghci-libraries blank since then the extra-libraries is used
05:01:09 <dcoutts_> luite: perhaps put some ordinary thing in there like c :-) then specify the .a on the ghci command line
05:01:57 <Jafet> @hoogle [a] -> a
05:01:58 <lambdabot> Prelude head :: [a] -> a
05:01:58 <lambdabot> Prelude last :: [a] -> a
05:01:58 <lambdabot> Data.List head :: [a] -> a
05:02:10 <Jafet> None of them total, of course.
05:02:18 <dcoutts_> luite: arguably, a full path ought to be used directly, we should probably report it
05:04:34 <Entroacceptor> companion_cube: I've tried to understand HStringTemplate, and didn't manage to, because of so much spaghettiesque stuff
05:06:38 <luite> dcoutts_: I made it load libgmp-10.dll instead and tried to specify the .a on the command line, but now it doesn't know the symbols. perhaps it cannot load the .a after all?
05:07:07 <companion_cube> Entroacceptor, well, here it's more about taking two plates of spaghetti and merging them
05:07:10 <companion_cube> \o/
05:07:25 <dcoutts_> luite: ok, the next trick then is to try linking the .a to be a .o file
05:08:12 <dcoutts_> luite: ld -o foo.o --whole-archive foo.a
05:10:24 <luite> dcoutts_: hmm, around a million undefined references to the sqrt function. adding -lm to the line doesn't help
05:10:47 <dcoutts_> luite: linker order matters
05:11:29 <luite> I tried adding -lm at various places in that command line, although I'm not sure if that's what you mean :)
05:11:54 <dcoutts_> luite: ok, then I think we have to abandon and send the details of what we tried to the ghc users list and ask for advice
05:12:46 <luite> dcoutts_: ok, I'll do that tonight. thanks for the help so far :)
05:12:53 <dcoutts_> np
05:28:51 <luite> dcoutts_: I have a temporary solution now, I extracted the .a and relinked it as a dll, with gcc -shared -o glpk.dll *.o
05:49:51 <lars9> i have a question about STM, in the one-producer-multi-consumer case, if many consumer threads are acquiring a product, will rollback happen frequently?
05:57:42 <dcoutts_> luite: ah great
05:57:57 <dcoutts_> luite: so I bet it could work in the direct ghci foo.a case too then, just details
06:03:09 <foo-nix> yesterday around 2100hGMT I asked a question in this channel, someone answered as my xchat was flashing, but the log was flushed :( COuld some check his log for what was said to me?
06:04:25 <ManateeLazyCat> ragloublog: Are you there?
06:04:54 <ManateeLazyCat> @hoogle catch
06:04:55 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
06:04:55 <lambdabot> Control.Exception catch :: Exception e => IO a -> (e -> IO a) -> IO a
06:04:55 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
06:10:38 <zygoloid> foo-nix: your question re: pan went unanswered, at least in this channel.
06:13:04 <qooo> ManateeLazyCat: hi are you student?
06:13:24 <ManateeLazyCat> qooo: No.
06:13:36 <ManateeLazyCat> qooo: I'm free programmer
06:13:57 <qooo> ManateeLazyCat: because i saw you have done a lot of programming in haskell. 
06:14:06 <qooo> ManateeLazyCat: do you use it in your work?
06:14:28 <ManateeLazyCat> qooo: I haven't job.
06:14:48 <qooo> ManateeLazyCat: many ppl only use haskell for study and research
06:15:03 <ManateeLazyCat> qooo: I have money support my project in short time.
06:15:37 <qooo> ManateeLazyCat: you mean your manatee project is sponsored by company?
06:16:42 <ManateeLazyCat> qooo: My project provide a fact: Haskell can do everything you want, and can do better!
06:17:02 <qooo> ManateeLazyCat: yea, impressive
06:17:14 <ManateeLazyCat> qooo: I want build real world program bring more user join Haskell community
06:17:14 <ManateeLazyCat> qooo: Not just professional or doctor etc. :)
06:17:51 <ManateeLazyCat> qooo: No
06:17:51 <ManateeLazyCat> qooo: Haven't any company support Manatee.
06:17:51 <ManateeLazyCat> qooo: Just me.
06:18:08 <qooo> ManateeLazyCat: maybe you can try to apply dons' company :D
06:19:23 <ManateeLazyCat> qooo: No haskell job can't stop i use Haskell, like "Real World Haskell" said : Code you can believe!
06:19:23 <ManateeLazyCat> qooo: I believe Haskell is right choose for *real world* project.
06:19:23 <ManateeLazyCat> qooo: And my project provide my choose is right. :)
06:19:24 <ManateeLazyCat> qooo: Maybe, now i just want coding and coding.....
06:20:04 <ManateeLazyCat> qooo: Manatee is my dream project, i'm not develop it for money, i develop for my faith.
06:20:38 <ManateeLazyCat> My faith is : Haskell not just good language for research, it's also awesome language to build everything!
06:21:32 <qooo> ManateeLazyCat: thumb up for your faith :)
06:28:51 <Maxdamantus> Hm. Does anyone know how Haskell implementations usually manage variables? Does every unevaluated expression (or function) carry around a list of references it requires (ie, variables (potentially) used under the scope of the expression), or does it keep a list of levels of scope where each level has that list, or ..?
06:29:00 <ManateeLazyCat> ragloublog: From your yesterday report, i modified code of manatee-anything to protected search algorithm won't crash all manatee-anything process, so if any search throw exception, other search still can work continue. 
06:29:14 <ManateeLazyCat> ragloublog: Of course manatee core can't crash in any situation....
06:29:41 <Botje_> Maxdamantus: values are graphs that reference other graphs they need
06:29:46 * hackagebot csound-expression 0.0.3 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.0.3 (AntonKholomiov)
06:30:04 <quicksilver> Maxdamantus: your first suggestion is the more accurate description.
06:30:11 <quicksilver> there is scope or levels of scope
06:30:24 <quicksilver> but thunks do indeed store pointers to other thunks they will need 
06:30:27 <Maxdamantus> levels seems hard on GC.
06:30:37 <joe6> i am thinking of using haskell to generate asm code (similar to Harpy) for a microcontroller with program memory size = 8Kilobytes and ram of 256 bytes. I guess using the haskell backend and converting the code to asm code is a dead-end and i doubt that haskell program code can fit within 8kilobytes. If I look at using haskell as a code generator, I think Harpy is an option and am wondering if anyone is aware of any other alternatives..
06:30:43 <quicksilver> variables is a poor name
06:30:49 <quicksilver> a variable is a syntactic notion
06:31:01 <Maxdamantus> Yeah, dunno what to call them.
06:31:08 <quicksilver> thunks :)
06:31:11 <Maxdamantus> Right.
06:31:14 * Maxdamantus searches.
06:32:14 <kmc> joe6, did you look at 'atom'?
06:32:24 <kmc> there are articles online about using atom to program Arduino
06:33:20 <kmc> Maxdamantus, in GHC, a function value or a thunk will contain two things
06:33:36 <kmc> 1) an info pointer, pointing to some static data including the function code as well as metadata for GC, etc.
06:33:52 <engla> ManateeLazyCat: you're a real haskell fanatic
06:34:02 <kmc> 2) the free variables of the function/thunk, which are usually pointers to other heap objects
06:34:04 <ManateeLazyCat> engla: Yep.
06:34:20 <Maxdamantus> Alright.
06:34:20 <kmc> GHC calls all of these things "closures" -- functions, thunks, constructors, and other stuff like partial-application nodes
06:34:20 <engla> ManateeLazyCat: btw, doesn't " all rights reserved" in your source code files directly conflict with the licensing text that directly follows it (using GPL)
06:34:40 <ManateeLazyCat> engla: ?
06:34:41 <kmc> Maxdamantus, i recommend "Implementing lazy functional languages on stock hardware: the Spineless Tagless G-machine"
06:34:52 <ManateeLazyCat> engla: My licence documentation is wrong?
06:34:52 <kmc> Maxdamantus, then "How to make a fast curry"
06:34:58 <joe6> kmc: thanks, will check out atom.
06:35:00 <kmc> Maxdamantus, then http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
06:35:28 <Maxdamantus> Simon Peyton Jones, hm. That's the C-- guy I think.
06:35:48 <kmc> also a main developer of GHC and designer of Haskell
06:36:17 <engla> ManateeLazyCat: You have a copyright notice in your manatee source code (I'm just looking quickly), and it says "all rights reserved", then goes on with the usual free software/GPL header. Isn't the "all rights reserved" thing contradictory and out of place?
06:36:21 <kmc> they invented C-- for the GHC backend; it's supposed to be a general IL like LLVM but never caught on outside GHC, i think
06:36:24 <ray> no
06:36:27 <engla> ManateeLazyCat: https://patch-tag.com/r/AndyStewart/manatee/snapshot/current/content/pretty/Manatee/Environment.hs
06:36:30 <ray> that's how copyright works
06:36:42 <Maxdamantus> C-- was invented for GHC?
06:36:47 <kmc> yeah, he's saying "i reserve all rights, but i promise you can use it under these terms"
06:36:52 <kmc> Maxdamantus, afaik
06:37:01 <ray> try reading the preamble to the gpl sometime!
06:37:13 <engla> ManateeLazyCat: probably it doesn't matter. I'm just asking.
06:37:13 <kmc> Maxdamantus, is it used anywhere else?
06:37:29 <ManateeLazyCat> engla: I copy GLP3 documentation.
06:37:36 <Maxdamantus> Not sure. Can't think of anything.
06:37:49 <engla> ManateeLazyCat: ok, I'll look there
06:38:10 <ManateeLazyCat> engla: Please let me know if any wrong with my licence documentation. Thanks.
06:38:12 <Maxdamantus> It does seem to be a project fairly seperate from GHC.
06:40:16 <pkrumins> Hi guys, any ideas why this wouldn't work: 1. let port = fromIntegral (read portStr :: Int) 2. sock <- connectTo host $ PortNumber port. I get Couldn't match expected type `PortNumber' against inferred type `Int' error.
06:40:50 <pkrumins> so port is Int, and I thought I could construct a (PortNumber Int)
06:41:04 <pkrumins> not sure what I am constructing there but in another program I have PortNumber 6000 and it works
06:41:22 <pkrumins> and now I thought of making port configurable, and when port is Int, it gives that error.
06:41:25 <pkrumins> any help appreciated.
06:41:48 <pkrumins> and portStr is from [host, portStr] <- getArgs
06:41:49 <Botje_> @hoogle PortNumber
06:41:49 <lambdabot> Network PortNumber :: PortNumber -> PortID
06:41:49 <lambdabot> Network data PortNumber
06:41:49 <lambdabot> Network.BSD data PortNumber
06:41:55 <Botje_> @hoogle connectTo
06:41:56 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
06:41:56 <lambdabot> Network.CGI.Compat connectToCGIScript :: String -> PortID -> IO ()
06:41:57 <applicative> are you overdoing it using both 'fromIntegral' and assigning a type to read portStr
06:42:13 <applicative> @type fromIntegral
06:42:14 <lambdabot> forall a b. (Integral a, Num b) => a -> b
06:42:28 <pkrumins> @type read
06:42:29 <lambdabot> forall a. (Read a) => String -> a
06:42:39 <pkrumins> @type show
06:42:40 <lambdabot> forall a. (Show a) => a -> String
06:42:59 <pkrumins> okay, so what do you suggest I do?
06:43:08 <Botje_> does it work if you do "connectTo host $ PortNumber $ read portstr" ?
06:43:09 <applicative> I can't remember, but  should port = (read portStr :: Int) be all you need?
06:43:20 <pkrumins> Botje_: let me try.
06:43:23 <Botje_> if so, the fromIntegral is the culprit
06:43:23 <pkrumins> applicative: will try your solution too.
06:43:34 <quicksilver> Maxdamantus: as I understand the history, people involved in GHC (including SPJ) were involved in C--; but not everyone involved in C-- was involved in GHC; the idea of a portable assembly is a good one.
06:43:48 <quicksilver> Maxdamantus: so, C-- wasn't really "for" GHC. But as far as I know it's the main user of it nonetheless.
06:43:55 <quicksilver> modulo the irritating detail that Cmm is not C--
06:43:59 <pkrumins> applicative: still the same error, since port is Int
06:44:10 <pkrumins> and haskell can't construct PortID via PortNumber from Int.
06:44:15 <pkrumins> Botje_: now trying your solution
06:44:17 <ManateeLazyCat> engla: "all rights reserved" conflict GPL3 ?
06:44:29 <ManateeLazyCat> engla: I don't think so.
06:44:37 <Botje_> yeah, then that won't work either
06:44:47 <pkrumins> @type 5
06:44:48 <lambdabot> forall t. (Num t) => t
06:44:58 <pkrumins> @type PortNumber 5
06:44:59 <lambdabot> Not in scope: data constructor `PortNumber'
06:45:01 <engla> ManateeLazyCat: I have no idea, but it sounds contradictory. I mean it has no big importance since you don't have to assert anything to have copyright
06:45:04 <pkrumins> @type (PortNumber 5)
06:45:05 <lambdabot> Not in scope: data constructor `PortNumber'
06:45:10 <pkrumins> > PortNumber 5
06:45:11 <lambdabot>   Not in scope: data constructor `PortNumber'
06:45:35 <luks_> Hi, I want to access bluetooth via haskell on a mac. Any Ideas where I could start? bluez (linux only?)?
06:45:46 <Botje_> pkrumins: PortNumber $ PortNum port
06:45:56 <pkrumins> Botje_: trying!
06:46:03 <pkrumins> Botje_: also pawings! ^_^
06:46:05 <Botje_> luks_: bluecove is nice, but java only. be warned, bluetooth on macosx sucks balls.
06:46:10 <gds> ManateeLazyCat: ray said "that's how copyright works" - he thinks you're doing it right.
06:46:10 <gds>  
06:46:11 <applicative> @hoogle HostName
06:46:11 <lambdabot> Network type HostName = String
06:46:11 <lambdabot> Network.BSD type HostName = String
06:46:11 <lambdabot> Network.Socket type HostName = String
06:46:16 <Botje_> pkrumins: pawings to you as well, dear haskell kit.
06:46:32 <pkrumins> Botje_: pinger.hs:15:44: Not in scope: data constructor `PortNum'
06:46:40 <pkrumins> PortNum doesn't seem to be a data constructor!
06:46:44 <applicative> @hoogle PortId
06:46:44 <lambdabot> Network data PortID
06:46:52 <pkrumins> doesn't take an argument, see!
06:46:56 <gds> ManateeLazyCat: But you may not have noticed, because the channel is busy, and he didn't mention your name ;)
06:46:59 <Botje_> which variant of network are you using, exactly?
06:47:13 <pkrumins> I am using just Network, Botje_.
06:47:32 <pkrumins> well I just want to use `handle <- connectTo <host> <port>`
06:47:40 <pkrumins> the <host> part is clear, it's String, no problems with that
06:47:42 <ManateeLazyCat> gds: I just login in, what's talk about ray? :)
06:47:49 <pkrumins> but <port> is the real trouble.
06:47:55 <pkrumins> @hoogle connectTo
06:47:55 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
06:47:55 <lambdabot> Network.CGI.Compat connectToCGIScript :: String -> PortID -> IO ()
06:48:23 <pkrumins> type HostName = String
06:48:28 <luks_> why is bluetooth on mac so bad in your opinion?
06:48:53 <pkrumins> Integral!
06:49:01 <pkrumins> there is a constructor for PortNumber via Integral
06:49:03 <pkrumins> but not via Int
06:49:45 <pkrumins> aww     Class `Integral' used as a type
06:49:51 <pkrumins> it's a whole class!
06:49:58 <gds> ManateeLazyCat: While you and engla were talking about licences at 14:36 GMT , ray was agreeing with you. But he didn't mention either your name or engla's, so neither of you noticed.
06:50:07 <pkrumins> oh, but there is Integral Int
06:50:14 <gds> ManateeLazyCat: It is now 14:49 GMT :)
06:50:24 <ManateeLazyCat> gds: Oh, I found it.
06:50:31 <pkrumins> so daamn, where am I headed, PortNumber $ Integral (read portStr :: Int)
06:50:33 <pkrumins> trying this
06:50:36 <ManateeLazyCat> gds: A little busy here, haven't notice ray. :)
06:50:37 <luks_> Botje_: Why is bluetooth on mac so bad in your opinion?
06:50:48 <gds> ManateeLazyCat: Sure - it's a busy channel :)
06:50:59 <ManateeLazyCat> gds: So my documentation is right?
06:51:00 <zygoloid> pkrumins: isn't PortNum an instance of Read?
06:51:06 <pkrumins> nope
06:51:10 <pkrumins> or
06:51:14 <pkrumins> i dont think so
06:51:29 <gds> ManateeLazyCat: I don't understand copyright - it seems to me that ray thinks your documentation is right.
06:51:36 <zygoloid> if not, use: connectTo host (fromIntegral $ read foo)
06:51:40 <ManateeLazyCat> gds: Ok, thanks
06:51:45 <ManateeLazyCat> ray: Thanks too. :)
06:51:52 <gds> np:)
06:51:58 <pkrumins> zygoloid: trying
06:52:49 <applicative> luks_ I take it you saw.  http://code.haskell.org/blues/
06:52:54 <pkrumins> umm
06:52:56 <pkrumins> zygoloid: 
06:52:56 <pkrumins>     No instance for (Num PortID)
06:52:57 <pkrumins>       arising from a use of `fromIntegral' at pinger.hs:14:31-61
06:53:40 <applicative> luks, looks like it hasn't been updated for a while, and wasn't hackaged, so maybe it's unsound.
06:53:48 <zygoloid> oops, you'll still need the PortNumber constructor in there somewhere.
06:54:57 <pkrumins> What exactly is plain number 99
06:54:59 <pkrumins> is it Int?
06:55:10 <luks_> applicative: yes (AF_BLUETOOTH :: Family) what is this ecatly?
06:55:18 <pkrumins> cause `handle <- connectTo host $ PortNumber 99` works just fine
06:55:18 <Maxdamantus> Its type is inferred.
06:55:40 <pkrumins> but as soon as I do `handle <- connectTo host $ PortNumber port`, where port :: Int, it fails.
06:56:29 <Maxdamantus> :t 99 :: Int
06:56:30 <lambdabot> Int
06:56:41 <Maxdamantus> :t 99.0 * (99 :: Int)
06:56:41 <lambdabot>     No instance for (Fractional Int)
06:56:41 <lambdabot>       arising from the literal `99.0' at <interactive>:1:0-3
06:56:42 <lambdabot>     Possible fix: add an instance declaration for (Fractional Int)
06:56:59 <pkrumins> :t 99
06:56:59 <lambdabot> forall t. (Num t) => t
06:57:13 <pkrumins> :t 99 :: Real
06:57:14 <luks_> applicative: uups no I got this wrong; this looks interesting
06:57:14 <lambdabot>     Class `Real' used as a type
06:57:14 <lambdabot>     In the type `Real'
06:57:14 <lambdabot>     In an expression type signature:
06:57:16 <foo-nix> zygoloid, kk, thanx :)
06:57:40 <qooo> how to check the times of rollback in my STM program?
06:57:56 * hackagebot manatee-core 0.0.2 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.2 (AndyStewart)
06:57:59 * hackagebot manatee-anything 0.0.2 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.2 (AndyStewart)
06:58:01 * hackagebot manatee-browser 0.0.2 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.2 (AndyStewart)
06:59:00 <pkrumins> :t PortID
06:59:01 <lambdabot> Not in scope: data constructor `PortID'
06:59:09 <pkrumins> :m Network
06:59:11 <pkrumins> :t PortID
06:59:12 <lambdabot> Not in scope: data constructor `PortID'
06:59:20 <pkrumins> :m Network :t PortID
06:59:29 <Maxdamantus> :t Network.PortID
06:59:30 <lambdabot> Not in scope: data constructor `Network.PortID'
06:59:57 * hackagebot manatee-editor 0.0.2 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.2 (AndyStewart)
06:59:59 * hackagebot manatee-filemanager 0.0.2 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.2 (AndyStewart)
07:00:00 <pkrumins> PortNumber :: PortNumber -> PortID
07:00:01 * hackagebot manatee-imageviewer 0.0.2 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.2 (AndyStewart)
07:00:03 * hackagebot manatee-ircclient 0.0.2 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.2 (AndyStewart)
07:00:05 * hackagebot manatee-mplayer 0.0.2 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.2 (AndyStewart)
07:00:07 <pkrumins> how should I read this type signature?
07:00:14 <pkrumins> PortNumber is a PortNumber that returns a PortID?
07:00:46 <pkrumins> some major confusion here!
07:01:53 <Phyx-> : (<*>)
07:01:58 * hackagebot manatee-pdfviewer 0.0.2 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.2 (AndyStewart)
07:02:00 * hackagebot manatee-processmanager 0.0.2 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.2 (AndyStewart)
07:02:02 * hackagebot manatee-reader 0.0.2 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.2 (AndyStewart)
07:02:03 <Phyx-> :t (<*>)
07:02:04 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
07:02:04 * hackagebot manatee 0.0.6 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.6 (AndyStewart)
07:02:10 <ManateeLazyCat> Enjoy all. 0.0.2 just refactory version and no new features add, more stable...
07:02:43 <Phyx-> :t \f a b -> f <$> a <*> b
07:02:44 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
07:02:50 <dblhelix> pkrumins: what type signature?
07:03:08 <pkrumins> dblhelix: the PortNumber :: PortNumber -> PortID
07:03:15 <pkrumins> dblhelix: `:t PortNumber`
07:04:18 <dblhelix> pkrumins: there are multiple ways to identify a port in the network package
07:04:23 <dblhelix> one of them is by port number
07:04:50 <dblhelix> the data constructor PortNumber injects a value of type PortNumber into the type PortID
07:05:16 <dblhelix> pkrumins: so, the first occurrence of PortNumber is the name of the data constructor, the second is the name of the type
07:05:28 <dblhelix> pkrumins: I can see that that's a little confusing
07:05:52 <pkrumins> oh i see!
07:06:00 * zygoloid pities the fool who put types and values in different namespaces ;)
07:06:01 <dblhelix> :t PortNumber 88
07:06:02 <lambdabot> Not in scope: data constructor `PortNumber'
07:06:13 <ManateeLazyCat> @tell ragloublog Please try newest version manatee, now other search can works well even some search crash.
07:06:14 <lambdabot> Consider it noted.
07:06:25 <Phyx-> zygoloid: I like it when a Type comes together...
07:06:32 <dblhelix> :t Network.PortNumber 88
07:06:32 <lambdabot> Network.PortID
07:07:22 <pkrumins> so PortNumber constructed a new type PortID?
07:07:25 <ManateeLazyCat> @tell ragloublog Well, i think my AnythingLocate.hs can't work well in your box, best to report detail let me fix it,  thanks! 
07:07:25 <lambdabot> Consider it noted.
07:07:46 <dblhelix> pkrumins: not a new type, but a value of the existing type PortID
07:07:57 <pkrumins> oh right.
07:08:04 <pkrumins> that's what i meant, just said incorrectly
07:08:12 <dblhelix> pkrumins: okay
07:08:25 * applicative is Haskelling on Windows for the first time... this is going to take a while...
07:09:34 <Phyx-> applicative: lol, why?
07:09:44 <Jafet> winghci hangs if you have an error in your ghci.conf. Endless fun.
07:10:00 <pkrumins> dblhelix: now the question that would solve my today's problem. Given a String, how do I end up with a PortID? :)
07:10:15 <pkrumins> dblhelix: tried everything, like PortNumber (read str :: Int)
07:10:30 <pkrumins> dblhelix: and PortNumber $ fromIntegral (read str :: Int)
07:11:43 <quicksilver> :t Network.PortNumber $ fromIntegral (read "345" :: Int)
07:11:44 <lambdabot> Network.PortID
07:12:21 <pkrumins> holy crap!
07:12:28 <pkrumins> trying that again
07:12:57 <pkrumins> it worked.
07:13:10 <pkrumins> thanks!
07:13:12 <Phyx-> :t Network.PortNumber
07:13:13 <lambdabot> Network.Socket.Internal.PortNumber -> Network.PortID
07:13:33 <pkrumins> :t Network.PortID
07:13:34 <lambdabot> Not in scope: data constructor `Network.PortID'
07:13:40 <pkrumins> :t Network.PortID 5
07:13:40 <lambdabot> Not in scope: data constructor `Network.PortID'
07:13:52 <quicksilver> PortID is not a constructor.
07:13:54 <pkrumins> i wonder why I can look up the type of PortNumber, but not of PortID
07:14:01 <quicksilver> because PortID is not a constructor.
07:14:03 <pkrumins> quicksilver: so it's just type?
07:14:07 <quicksilver> PortID is a type.
07:14:17 <pkrumins> i see!
07:14:21 <quicksilver> PortNumber is a constructor (of the PortID type)
07:14:27 <quicksilver> PortNumber is also a type.
07:14:31 <quicksilver> this is probably a bad design choice.
07:15:00 <dblhelix> so, how are port numbers printed?
07:15:18 <pkrumins> got to add your own show thing
07:15:27 <dblhelix> > show (88 :: Network.PortNumber)
07:15:28 <lambdabot>   Not in scope: type constructor or class `Network.PortNumber'
07:15:29 <pkrumins> an instance of PortID for Show type constructor
07:15:36 <pkrumins> or something
07:15:40 <pkrumins> not sure how to say that
07:15:53 <pkrumins> type class
07:16:20 <Darkovsky> Urgghh
07:16:35 <Darkovsky> What does Floor demand of me? Sacrificial goats? :(
07:17:11 <Darkovsky> How do I go about applying floor to a float or double? It doesn't seem to want to work.
07:17:35 <pkrumins> :t 60*1e6
07:17:36 <lambdabot> forall t. (Fractional t) => t
07:17:43 <Jafet> :t floor
07:17:43 <pkrumins> :t (read 60*1e6 :: Int)
07:17:44 <lambdabot>     No instance for (Num String)
07:17:44 <lambdabot>       arising from the literal `60' at <interactive>:1:6-7
07:17:44 <lambdabot>     Possible fix: add an instance declaration for (Num String)
07:17:44 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:17:51 <Darkovsky> Well, RealFrac Int now.
07:17:55 <pkrumins> i wonder how to convert Fractional to Int
07:18:10 <Darkovsky> speed = read $ myarray ! 11 :: Int      ... |speed > 0 && speed < 1500000 = floor  (1.25 * speed)
07:18:12 <dblhelix> > floor 5.4
07:18:13 <lambdabot>   5
07:18:17 <lars9> how to profile the frequency of rollback when running a STM program?
07:18:25 <dblhelix> Darkovsky: doesn't seem that hard:
07:18:27 <dblhelix> > floor 3.14
07:18:28 <lambdabot>   3
07:18:28 <Jafet> What on earth are you trying to floor?
07:18:31 <pkrumins> > fromIntegral 5
07:18:32 <lambdabot>   5
07:18:35 <pkrumins> > fromIntegral 5*1.0
07:18:36 <lambdabot>   5.0
07:18:39 <pkrumins> > fromIntegral 5*1.0 :: Int
07:18:40 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
07:18:40 <lambdabot>    arising from the lit...
07:18:45 <pkrumins> > fromIntegral 5*1e6 :: Int
07:18:46 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
07:18:46 <lambdabot>    arising from the lit...
07:19:00 <pkrumins> > floor $ fromIntegral 5*1e6
07:19:01 <lambdabot>   5000000
07:19:03 <pkrumins> aha
07:20:01 <pkrumins> not really...
07:20:06 <Maxdamantus> > floor $ 5*1e6
07:20:06 <lambdabot>   5000000
07:20:15 <pkrumins> :t floor 5*1e6
07:20:15 <Darkovsky> Jafet, basically
07:20:15 <lambdabot> forall b. (Integral b, Fractional b) => b
07:20:17 <Maxdamantus> :t 5
07:20:17 <lambdabot> forall t. (Num t) => t
07:20:19 <pkrumins> still not Int
07:20:21 <Maxdamantus> :t fromIntegral 5
07:20:22 <pkrumins> :t floor $ 5*1e6
07:20:22 <lambdabot> forall b. (Num b) => b
07:20:23 <lambdabot> forall b. (Integral b) => b
07:20:25 <Darkovsky> I read an int
07:20:25 <pkrumins> :t floor 5*1e6
07:20:26 <lambdabot> forall b. (Integral b, Fractional b) => b
07:20:30 <Darkovsky> Say, 500000
07:20:31 <quicksilver> Darkovsky: floor is working fine on your Double, no doubt
07:20:32 <pkrumins> :t floor 60*1e6
07:20:33 <lambdabot> forall b. (Integral b, Fractional b) => b
07:20:41 <quicksilver> Darkovsky: the problem is that the return type of floor is integral
07:20:49 <quicksilver> and you're trying to stuff it into a non-integral type, I imagine.
07:21:22 <Jafet> 500000 is (Num a) => a, and floor takes (RealFrac a) => a.
07:21:46 <pkrumins> > fromIntegral 5*1e6
07:21:46 <lambdabot>   5000000.0
07:21:55 <pkrumins> any ideas how to cast this to just Int?
07:21:57 <dblhelix> But the floor of 500000 isn't that interesting to calculate, right?
07:21:57 <pkrumins> get rid of .0
07:22:02 <Darkovsky> Okay, it reads a number, like 500000 from a file
07:22:13 <Jafet> > floor $ fromIntegral 5 * 1e6
07:22:14 <lambdabot>   5000000
07:22:14 <Darkovsky> It multiplies it by 1.25 if it meets certain expectations
07:22:25 <pkrumins> :t floor $ fromIntegral 5 * 1e6
07:22:26 <lambdabot> forall b. (Integral b) => b
07:22:32 <Jafet> Darkovsky: and what is the type of that 500000?
07:22:35 <pkrumins> :t (floor $ fromIntegral 5 * 1e6) :: Int
07:22:36 <lambdabot> Int
07:22:37 <Darkovsky> I try to floor that, to force it into a nice, neat, number.
07:22:38 <pkrumins> :D
07:22:51 <Darkovsky> Jafet, can be anything you want. I've tried Int, Float, Double, so far.
07:23:00 <quicksilver> Darkovsky: I just told you the answer.
07:23:06 <Maxdamantus> pkrumins: btw, fromIntegral 5*1e6 is (fromIntegral 5)*1e6
07:23:11 <quicksilver> floor works fine on Double and Float
07:23:23 <quicksilver> the problem is where you are trying to put the result.
07:23:28 <Jafet> Darkovsky: obviously not. You can't multiply an Int with 1.25.
07:23:29 <pkrumins> Maxdamantus: oic.
07:23:38 <quicksilver> the result of floor is integral.
07:23:39 <pkrumins> > (fromIntegral 5)*1e6
07:23:40 <lambdabot>   5000000.0
07:23:46 <pkrumins> > floor (fromIntegral 5)*1e6
07:23:46 <lambdabot>   Ambiguous type variable `b' in the constraints:
07:23:46 <lambdabot>    `GHC.Real.Integral b'
07:23:46 <lambdabot>   ...
07:23:47 <quicksilver> that is likely to be your problem.
07:23:49 <pkrumins> > floor $ (fromIntegral 5)*1e6
07:23:50 <lambdabot>   5000000
07:23:54 <pkrumins> :t floor $ (fromIntegral 5)*1e6 
07:23:55 <lambdabot> forall b. (Integral b) => b
07:24:00 <pkrumins> :t floor $ (fromIntegral 5)*1e6  :: Int
07:24:00 <lambdabot> Int
07:24:04 <Jafet> pkrumins, done spamming?
07:24:09 <quicksilver> pkrumins: this is quite spammy, perhaps you could experiment in ghci or query?
07:24:13 <pkrumins> right.
07:24:34 <Darkovsky> process myarray = myarray // [(11,show $ fromIntegral fixspeed)]
07:25:48 <Darkovsky> No instance for (Integral Double) arising from a use of 'floor' at...
07:25:59 <quicksilver> can you paste your code to a pastebin, Darkovsky ?
07:26:05 <Darkovsky> Yea...
07:26:09 <Darkovsky> It was working before :/
07:26:11 <quicksilver> although have told you the answer twice.
07:26:15 <applicative> Phyx- I came by a Windows laptop, so I figured what the heck.  Maybe I can give better advice here! -- if we leave out my error-proneness-in-general
07:26:18 <quicksilver> the problem is not with the parameter to floor, but the result
07:26:21 <quicksilver> the result of floor is integral.
07:26:36 <quicksilver> you probably just need to fromIntegral the result.
07:27:12 <dRbiG> (fromIntegral (floor 1.25)) * 5e5
07:27:14 <applicative> Phyx- I was also hoping to be able to instruct writers how to install Pandoc on Windows, as I'm forever doing on Macs
07:27:17 <dRbiG> or whatever
07:27:40 <Darkovsky> There we go.
07:27:48 <Darkovsky> Had to fromIntegral it in the function
07:28:05 <Darkovsky> Forgot about functions needing to return same type in both cases.
07:28:30 <Darkovsky> My |otherwise = speed   would return something other than an integral.
07:28:34 * quicksilver nods
07:28:39 <quicksilver> good :)
07:28:45 * applicative could do with a #haskell-windows at the moment
07:28:47 <Darkovsky> So show $ fromIntegral fixspeed  wasn't helping.
07:33:55 <Phyx-> applicative: ah ok
07:34:05 <Phyx-> i've never used pandoc
07:35:05 <applicative> it's awesome, at least if you write a lot
07:35:41 <Phyx-> what should I be thinking of? Javadoc or Sandcastle and Oxygen?
07:37:44 <applicative> No, it's just a command line program that parses several formats and writes out to about 15.  The main business is the Markdown parser, which has sound extensions to standard markdown; so it you write in it, you can get latex, rtf, odt, etc etc
07:38:16 <gds> applicative: How is it at maths?
07:38:29 <applicative> latex math can be incorporated just as in latexx
07:38:31 <applicative> latex
07:39:00 <applicative> if it is in amsmath, it can also be parsed and included in HTML as 'mathml' or whatever -- don't know about that aspect much
07:39:11 * gds nods
07:39:15 <gds> Might be interesting.
07:39:27 <gds> Will check it out later :)
07:39:33 <applicative> there are several ways of rendering math in html, one is just to make links to the google service that renders latex automatically
07:39:37 <Phyx-> yeah, sounds interesting
07:39:46 <applicative> I mean, pandoc supports several ways
07:39:56 <luite> you can directy use latex math in html if you use mathjax
07:40:01 <luite> (or jsmath)
07:40:13 <applicative> it also supports jsmath and mathjax, these are command line options
07:40:35 <luite> unfortunately, mathjax runs really slowly in mobile safari on my ipad... makes reading mathoverflow a pain :(
07:40:57 <Zhuangzi> Is there a way to specify to GHC to "just type check"?
07:41:06 <gds> What I'd /really/ like is a way to write my stuff in something less painful that latex, and still be able to generate conference-compliant latex papers from my personal source later....
07:41:16 <applicative> oh really.   maybe people should be using the google renderer instead
07:41:41 <Phyx-> Zhuangzi: via the ghc-api I know it can be done, not sure if it can via the executable
07:42:15 <applicative> luite, mathjax is some pretty heavy duty javascript.  it's amazing really. 
07:42:16 <Zhuangzi> Phyx-: Sure, I recall that Scion can do it. But I have trouble getting Scion to even function half of the time.
07:42:43 <Phyx-> Zhuangzi: not talking about Scion though, that wraps the API, it's about 5 calls to only typecheck
07:42:59 <luite> applicative: it may be fixed in a later mathjax version. I think that the problem is that mobile safari doesn't support opentype web fonts, only svg, so it renders many characters as bitmaps
07:43:03 * fryguybob happily uses pandoc on windows.
07:43:37 * applicative is happily using  pandoc on windows starting today.
07:43:46 <Zhuangzi> Phyx-: I don't feel like writing it myself.
07:43:48 * applicative isn't sure how happy he is with windows.
07:44:06 <applicative> fryguybob, what editor do you use for pandoc?
07:44:20 <Phyx-> Zhuangzi: ghc -fno-code -c , would do it i think
07:44:48 <applicative> fryguybob, i mean on windows
07:44:48 <Phyx-> -fno-code probably implies -c since no code is generated anyway
07:44:52 <ManateeLazyCat> Any people use Manatee? Can tell me which design you can't understand? I will draw some picture to explain framework. Thanks!
07:45:21 <fryguybob> applicative: Whatever I have on hand.  Usually Visual Studio or Notepad++.
07:45:41 <Zhuangzi> Phyx-: Ah, thanks.
07:46:13 <applicative> fryguybob, I see.  I am just now downloading visual studio 2008 from my school.... only 8 hours to go....
07:46:18 <luite> I still don't really understand what Manatee is for (but that might have something to do with the fact that I'm on windows and can't install it due to missing libraries) :)
07:46:34 <Phyx-> applicative: 8 hours??
07:46:39 <Phyx-> what are you on? dailup?
07:47:13 <applicative> Phyx-, it's a university.  and not CMU, that's a few blocks away....
07:47:16 <Maxdamantus> I was trying to build it through cabal to see what it was, but it errored on manatee-core: Manatee/Toolkit/Widget/NotebookTab.hs:29:35: Not in scope: type constructor or class `Spinner'
07:47:38 <Phyx-> applicative: I usually get speeds around 1.0mb/s from my uni
07:47:41 <Phyx-> or more
07:47:57 <luite> wireless?
07:47:58 <fryguybob> applicative: I like that Notepad++ keeps a single instance with tabs and lets me open a new tab from the command line.  Beyond that support for different line endings and converting tabs to spaces are the only real features that I use.
07:48:39 <Phyx-> luite: no, I was talking home -> them
07:49:30 <luite> ah
07:49:49 <luite> that's faster than my home connection :)
07:49:51 <applicative> Phyx-, 91Kb/s  and 3.3 gigabytes.  I'm not sure which to be more offended by
07:50:08 <Phyx-> which version of visual studio?
07:50:20 <luite> xcode is around the same size
07:50:30 <luite> and vs is much better, so it's more quality per byte ;)
07:50:45 <Jiten> how does one use the if then else structure in monadic code? I can't figure it out.
07:50:48 <applicative> fryguybob, the line endings are going to kill me.  
07:51:03 <Phyx-> well, depending on which version, you'll have alot of non-coder things, like unit testing, UML diagrams modelers etc
07:51:32 <Phyx-> applicative: both visual studio and notepad++ can use the line endings you want
07:51:41 <applicative> Phyx-, visual studio 2008.  I heard the newer one has better F# integration, maybe I could learn a bit about that, dunno. 
07:52:03 <Phyx-> yeah, F# became a "first class" language in 2010
07:52:21 <roconnor>  does UHC support multparameter type classes?
07:52:28 <byorgey> Jiten: the same way as you use it anywhere else.  Are you having problems with the types, or with the indentation?
07:52:43 <applicative> Phyx-, yeah, i see that about line endings.  I just wish I didn't have to think about them, we'll see if I can aquire half-competence.
07:52:46 <Jiten> byorgey: probably indentation.
07:52:58 <ManateeLazyCat> luite: Yes, Manatee design for Linux
07:53:02 <Jiten> that's what the compiler complains about in one case.
07:53:21 <Jiten> I'll make a paste.
07:53:34 <Phyx-> applicative: I don't know how VS handles them exactly.. notepad++ defaults to the platform line ending, but if it detects a file with for instance unixe line ending that file is switched to unix, so it just continues using that
07:53:45 <Phyx-> I think visual studio does the same
07:53:53 <byorgey> Jiten: yeah, do-blocks + if-then-else indentation can be tricky until you get used to it
07:54:31 <applicative> Phyx, yes, I noticed that things treat the line endings as the treat the text encoding. 
07:54:42 <Phyx-> :t (.)
07:54:43 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:54:56 <quicksilver> byorgey: in the new version of GHC, they broke it, so that what a newbie expects will work, but the syntax now has an added special case making it even harder to explain and understand. \o/
07:54:57 <Jiten> this is the attempt that gives the indentation error. How do I fix it? http://hpaste.org/41404/if_then_else_in_monad
07:54:57 <Phyx-> who redefined (.) again
07:55:26 <Phyx-> quicksilver: awww why? :(
07:55:26 <byorgey> quicksilver: ah yes, I remember that now...
07:55:29 <applicative> Phyx- everyone knows that (.) is fmap on lambdabot, did it revert
07:55:32 <quicksilver> Jiten: your else needs to be more indented.
07:55:40 <quicksilver> Jiten: because 'else' is not a statement
07:55:48 <quicksilver> Jiten: 'else' is part of the 'if' expression.
07:55:55 <Phyx-> applicative: it seems confusing, atleast for a beginner following like RWH
07:56:19 <Jiten> ah, yes, now it stopped complaining. Thank you
07:56:41 <Phyx-> :t let (f . g) x = f (g x) in (.)
07:56:42 <lambdabot> forall t t1 t2. (t -> t1) -> (t2 -> t) -> t2 -> t1
07:57:35 <Phyx-> what's the ghc naming convention for type variable names? when does it use a b c.. etc or just number one letter like just now?
07:57:49 <applicative> Phyx-, yes.  My complaint is I have to think too hard about the Functor instance, it isn't that natural.
07:58:36 <fryguybob> applicative: VS will warn you that line endings are inconsistent on opening a file and offer to make them consistent.  Notepad++ seems to just live with inconsistent line endings.
07:58:58 <Phyx-> fryguybob: are you sure that's a VS feature?
07:59:08 <byorgey> Phyx-: when typechecking things that were given explicit type signatures, it tries hard to keep the same names for things (adding numerical endings if necessary to disambiguate)
07:59:52 <fryguybob> Phyx-: I get the warning all the time due to some poorly crafted tools.
07:59:59 <Phyx-> byorgey: aha, makes sense
08:00:14 <Phyx-> fryguybob: yes, but I remember posts by the VS team that it's not a VS feature, but a plugin
08:00:34 * applicative feels very close to the ghc when it gives polymorphic types using his own ridiculous variables
08:00:34 <Phyx-> atleast in VS2010, it's part of the powertools extensions
08:01:54 <applicative> I take it that cabal and Hackage can handle any line-endings?
08:02:00 <Phyx-> I wish put code in my head and evaluate... 
08:02:14 <applicative> I remember the BOM causing a disaster with the HaTeX package.  
08:04:14 <fryguybob> Phyx-: I'm on vanilla VS2008.
08:04:21 <Phyx-> hm I've been thinking of making a cabal-install-api, for when you want to use cabal-install as a library, but I wonder if that would only be useful for me...
08:04:34 <Phyx-> fryguybob: are you sure? check your extensions manager
08:06:23 <Phyx-> fryguybob: oh wait, do you get it as dialog or a menu-ish bar?
08:06:52 <fryguybob> Phyx-: The dialog.
08:07:32 <Phyx-> fryguybob: ah ok, then that one is most likely part of it. my bad
08:10:42 <Phyx-> lol, friend: "Is that Haskell?", me: "yeah", friend: "Get that far away from me"
08:11:46 <unkanon> I remember reading something about haskell, it was a comment by a slashdotter, and he was showing some haskell code to a friend
08:11:51 <exDM69> yeah, that's a common attitude of blub programmers
08:12:15 <unkanon> and he wrote the code and ran it and it worked, and his friend didnt understand how, and his friend said "but you didnt tell it anything specific"
08:12:20 <unkanon> and the guy said "Exactly"
08:12:35 <unkanon> i've been looking again for that quote but can never find it
08:13:39 <Phyx-> I remember absolutely HATING haskell when I was first taught it... what happened...
08:14:14 <EvanCarroll> it overcomes its host, like a goa'uld
08:14:48 <Phyx-> does it also kill it's host once it leaves?
08:14:57 <vegai> I tend to hate Haskell for a few months after finishing a project with it :P
08:15:26 <EvanCarroll> Phyx-: Occassionally.
08:15:34 <Phyx-> well, I remember coming in the lecture hall and being told "yeah, forget everything you know about programming so far"
08:15:42 <applicative> I love haskell more and more the more I use it; I just hate myself for loving it.
08:15:45 <djahandarie> I think that's the wrong way to put it
08:15:46 <Phyx-> my first reaction was "WTF, what is this crap"
08:15:55 <vegai> Phyx-: good reaction
08:15:59 <djahandarie> Why would you forget everything else about programming? That's a stupid request
08:16:08 <vegai> indeed
08:16:17 <Phyx-> well, forget everything you know about java
08:16:20 <vegai> unless of course you only learned about basic before
08:16:24 <Phyx-> since that was the language they gave :(
08:16:32 <applicative> well, the lecturer presumably didn't think it was really possible. 
08:16:51 <Phyx-> vegai: that's the general assumption, the class before it was a imperative programming / java course
08:16:51 <Maxdamantus> They do Haskell in a 300-level course here.
08:17:06 <djahandarie> I don't think they do any Haskell in my uni
08:17:19 <djahandarie> They do Lisp in the AI course though
08:17:34 <Maxdamantus> I think they use Prolog in some AI courses.
08:17:35 <applicative> Maxdamantus, what country are you in
08:17:39 <Phyx-> I think Clips is one of the most underated languages
08:17:41 <Maxdamantus> applicative: New Zealand.
08:18:04 <exDM69> I did a Haskell project for my AI course. the prof doesn't know any haskell so he is in somewhat of a mess to try to evaluate it
08:18:23 <Botje_> poor bastard :)
08:18:33 <exDM69> but he knows his prolog, lisp and ml so I guess he'll be fine off (despite my use of ST monads, etc)
08:18:42 <sproingie> clips is awesome, shame most of the language bindings to it have been left to rot
08:19:00 <sproingie> i have a perl project that could have used it but the perl bindings are hopeless
08:19:03 <exDM69> I really should push my latest logic programming interpreter to GitHub
08:19:16 <Phyx-> sproingie: yeah, I absolutely loved clips
08:19:20 <exDM69> but I have to write a README for it in order to make it useful for anyone
08:19:39 <exDM69> I did the docs in finnish for my prof
08:19:40 <applicative> exDM69, have you designed your own language?
08:19:43 <Phyx-> I think I still have some code fo it laying around
08:19:46 <exDM69> applicative: sure, many languages
08:19:51 <sproingie> i learned COOL before i ever looked at CLOS
08:19:56 <Phyx-> sproingie: I was thinking of eventually providing a new tool support for it
08:20:05 <exDM69> applicative: the latest one was a variant of the logic programming language presented in SICP
08:20:06 <sproingie> so i thought COOL was the awesomest OOP system eveh
08:20:28 <applicative> oh I see. 
08:20:50 <exDM69> applicative: http://www.pasteall.org/16774  here's a sample of doing some Peano arithmetic with it
08:20:59 <sproingie> i keep thinking of doing a rete engine in perl
08:21:41 <sproingie> make it match on hashes instead of tuples
08:22:34 <applicative> exDM69, I see, so a very lispy prolog
08:23:10 <exDM69> applicative: yeah, as I said it's a variant of the SICP logic language. although the SICP variant is a bit more useful since it's homoiconic and has an FFI to lisp
08:23:31 <exDM69> but this was merely to study the principles of logic language interpretation, not doing lisp tricks
08:23:38 <applicative> i see. but you've composed the interpreter in haskell, did you say?
08:23:47 <exDM69> applicative: yes, that's true
08:24:01 <exDM69> applicative: damnit, I might aswell GitHub it right away
08:24:39 <applicative> i'm sure google translate will do an excellent job putting finnish docs into english.....
08:24:45 <Phyx-> *sigh* what's the mode again that you can't get PM'ed on freenode?
08:24:56 <alexis> hi here.
08:25:00 <applicative> hi alexis
08:25:13 <Phyx-> some guy keeps pming me wanting me to give him the code to paste to make his program work
08:25:17 <Phyx-> hi alexis 
08:25:29 <dankna> just use /ignore
08:25:31 <dankna> it's simpler
08:25:39 <Phyx-> lol, true..
08:25:40 <applicative> alexis, what is your intended type? what is your expected type?
08:25:42 <alexis> I want to learn a bit haskell, any idea of a micro application which could help me interesting concepts ?
08:25:42 <Phyx-> forgot about ignore :/
08:25:58 <ManateeLazyCat> Bye all, night! :)
08:26:01 <ManateeLazyCat> sleep....
08:26:05 <Zhuangzi> alexis: implement an interface to Wordnik's API
08:26:14 <applicative> alexis, what sorts of things are you interested in. 
08:26:17 <Rembane> alexis: http://projecteuler.net/
08:26:44 <alexis> Rembane: good idea the project euler :)
08:26:52 <applicative> alexis, parser combinators will take you to interesting concepts, but some find them dull.
08:27:27 <Rembane> alexis: It rocks!
08:27:37 <exDM69> applicative: https://github.com/rikusalminen/slolog
08:27:45 <alexis> applicative: well, hard to say in what I'm intereted :/
08:27:56 <exDM69> applicative: there, the most interesting part is in SloLog/Query.hs
08:28:27 <alexis> applicative: I'm looking to parser combinators
08:30:00 <applicative> alexis, they are pleasing because the problem is clear enough, and you get sucked into the fancy typeclasses like 'functor' or  'monad' or 'applicative' fairly naturally.
08:31:34 * Phyx- hates being stuck. I've been stuck on 1 thing for a month, the other for 2 weeks
08:33:59 <applicative> alexis, it was just a thought.   I remember there is a very simple parser library at http://www.cs.nott.ac.uk/~gmh/Parsing.lhs  -- doesn't bother with subtleties about errors, bytestrings, etc. 
08:35:58 <applicative> alexis, there is explanatory material on http://www.cs.nott.ac.uk/~gmh/book.html   but like I said, i mention it because parsing is one of the things that supernatural in haskell
08:36:21 <alexis> wow, the wikipedia article is not so easy to catch ;)
08:36:45 <led> heh
08:36:54 <led> always weird to log in and see your supervisors page being bandied about
08:37:08 <mreh> supernatural?
08:37:41 * dankna has, on a related note, just gotten his replacement for Happy, named Joy, to the stage where it's generating LALR(1) follow sets.
08:37:44 * Maxdamantus thinks parsing is quite natural in Haskell.
08:37:54 <applicative> i mean, among the things that are very natural.  ....
08:38:06 <monochrom> haha
08:38:12 <led> parsing is a snap in haskell :p
08:38:20 <mreh> I can't get my parsec to work :(
08:38:32 <monochrom> parsing is supernatural (magical, miraculous) in haskell!
08:38:42 <dankna> I don't really like Parsec, honestly.  If backtracking is acceptable, then sure, it's a pretty abstraction...
08:39:00 <mreh> "p `sepBy` spaces" is going to confuse a trailing space with a separator and fail isn't it?
08:39:03 <monochrom> I backtrack all the time.
08:39:06 <dankna> but there are many purposes for which it's not acceptable, and I think it's a bad idea to be selling an abstraction that doesn't scale
08:39:11 <mreh> use try
08:39:25 <alexis> applicative: thx, the lectures slides are clearer
08:39:28 <jmcarthur> NoSQL is web scale!
08:39:28 <quicksilver> dankna: don't you mean "if not backtracking is acceptable" ?
08:39:36 <quicksilver> dankna: otherwise I'm not following your comment ;)
08:39:43 <applicative> alexis, 'parser combinators' is just the fancy word for the functions you use.  the concept 'combinator' is a bit fuzzy in haskeller's jargon, but it seems to apply to very abstract functions, 'higher order functions' etc
08:39:47 <monochrom> I not backtrack all the time, too.
08:39:53 <jmcarthur> Relational databases are not web scale!
08:39:58 <jmcarthur> Parsec is not web scale!
08:40:13 <dankna> unless something has changed, Parsec is a backtracking parser.  and fundamentally has to be because of the way you specify things in it.
08:40:31 <mreh> i wish sepBy would backtrack :(
08:40:33 <applicative> jmcarthur, what can we do to become webscale, what is webparsec 
08:40:48 <jmcarthur> i don't see the problem with that. if you really need a highly optimized parser then you are probably aware of Parsec's limitations anyway.
08:41:09 <applicative> i use frisby myself....
08:41:33 <jmcarthur> i'm not a huge fan of having to wrap so many things in try when using parsec though
08:41:51 <jmcarthur> but i suppose that means i am using the backtracking anyway
08:42:01 <jmcarthur> so it's not wasted at least
08:42:12 <alexis> what's this syntax ? inp  case inp of
08:42:24 <dankna> it's a question of O(n-or-so) vs O(n!)
08:42:30 <dankna> it's not a question of "highly optimized"
08:42:35 <jmcarthur> dankna: sure. and when have you suffered from it?
08:42:47 <companion_cube> alexis, this is pattern matching on inp ?
08:42:53 <Philippa> you can always define something as \l r -> try l <|> r, anyway
08:42:56 <dankna> I don't use parsec, so I haven't suffered from it, but I notice a distinct lack of example parsers of large grammars
08:43:05 <monochrom> what is "Parsec is a backtracking parser", really? If you do (char 'x' >> char 'y') <|> (char 'x' >> char 'x') in Parsec and give it input "xx", it doesn't backtrack, it just sticks with the first branch and declares error.
08:43:08 <jmcarthur> dankna: and there's a reason, of course
08:43:08 <applicative> alexis, there are two things, there.  the lambda notation, \inp -> inp * inp  is the squaring function
08:43:11 <dankna> for example, where are the parsers for C, Java, and so on
08:43:19 <applicative> alexis, then there is the 'case .... of 
08:43:24 <applicative> jargon,   
08:43:40 <quicksilver> dankna: I think the opposite.
08:43:40 <jmcarthur> dankna: wouldn't those need backtracking anyway?
08:43:42 <Philippa> dankna: when someone's got the spare time and/or the use case
08:43:44 <dankna> monochrom: well, strictly I mean something about LL(1) or something, but I didn't think this was the room to bring in formalisms
08:43:49 <dankna> jmc: no, they are in LR(1)
08:43:52 <companion_cube> dankna, who needs to parse java in haskell ?
08:43:52 <jmcarthur> ah
08:43:53 <alexis> companion_cube: I mean, for the "case" thing. we can do this by defining two times the function, isnt it ?
08:43:53 <quicksilver> dankna: by design parsec is *not* a backtracking parser
08:43:55 <jmcarthur> i didn't know
08:44:00 <alexis> the rest of the function being
08:44:01 <applicative> alexis, you are permitted to use a unicode greek lambda instead of \ to form lambda abstracts
08:44:03 <Philippa> and LR(1) != LL(1)
08:44:06 <monochrom> no dankna, look at my example, try it.
08:44:06 <quicksilver> dankna: ..which is why I found your comment so mystifying.
08:44:07 <alexis> []  []
08:44:09 <companion_cube> alexis, yes, but it's not always a named function
08:44:15 <alexis> (x:xs)  somth else
08:44:19 <wires> question: I tend to run cabal install -fhighlighting pandoc, this -f option, can I add that to ~/.cabal/config somehow?
08:44:23 <quicksilver> the thing that trips most people up about parsec is precisely the fact that it does not backtrack.
08:44:30 <jmcarthur> i need to read up on my parsing lingo again. i haven't done this stuff in a while
08:44:47 <applicative> alexis, is there also another case, namely [] -> something yet else?
08:44:55 <Philippa> there's a fundamental difference between LR and LL parsing, and LR parsing and parser combinators don't go well together. But you can also do a lot with reasonable performance with LL parsing
08:44:57 <dankna> quicksilver: hmm...  but try backtracks, doesn't it?
08:45:02 <alexis> applicative: nope
08:45:06 <Philippa> yes, try gives you limited backtracking
08:45:08 <quicksilver> dankna: yes, but try is the only place that does.
08:45:12 <quicksilver> dankna: that's "the point"
08:45:19 <dankna> yes, but you need it for anything not in LL, heh
08:45:21 <applicative> alexis, then it's a partial function, it will err for empty lists.  
08:45:23 <monochrom> try backtracks. no try no backtrack.
08:45:25 <led> @free f :: forall a. ((r -> (s -> (a, s))) -> (s -> (a, s))) -> s -> (r -> (a, s)) -> (a, s)
08:45:25 <lambdabot> (forall f1 f2. (forall x. $map_Pair k h . f1 x = f2 (g x) . h)               =>                $map_Pair k h . p f1 = q f2 . h) => $map_Pair k h . f3 = f4 . g => $map_Pair k h (f p y f3) = f q (h y)
08:45:25 <lambdabot> f4
08:45:26 <companion_cube> so you can choose to backtrack or not
08:45:36 <Philippa> sure, just like LR parsers need it for anything not in LR(1)
08:45:38 <dcoutts_> wires: no, not yet sorry
08:45:53 <dankna> yes, but in practice, there are very few grammars not in LR(1).  even SQL, classically very hard to parse, is.
08:45:57 <mreh> is the reason it's only efficient for LL(1) grammars because try is so crappy
08:45:58 <alexis> companion_cube: ah okay, that's for lambda functions, so.
08:46:15 <dankna> unless you're parsing, like, English or something, in which case you are an expert on parse theory anyway
08:46:17 <sm> Philippa: would you have an example of well-known grammars that are LR and LL respectively ?
08:46:17 <alexis> 'cause the function doesnt have a name.
08:46:18 <companion_cube> yes alexis, that's why in your example it's just after a \inp -> 
08:46:20 <Philippa> mreh: no, it's because it's monadic
08:46:23 <monochrom> My example has no try. It doesn't backtrack. O(n) not O(n!)
08:46:37 <mreh> only do
08:46:40 <Philippa> sm: IIRC Wirth tended to try for LL(1) and Python does
08:46:44 <mreh> heh
08:46:45 <dankna> lol, yoda quote
08:46:54 <alexis> companion_cube: okay, thx
08:46:57 <Philippa> a lot of C-derived languages are LR(1) or 'mostly' LR(1)
08:47:03 <mreh> dankna: haskell has both :)
08:47:12 <sm> I see thanks
08:47:13 <applicative> alexis, in any event, you can use case expressions to work through cases.  case foo of [] -> True ; (x:xs) -> False  -- that
08:47:18 <Philippa> mreh: you could make try + the applicative fragment go faster
08:47:20 <dankna> mreh: if you refer to Happy, yes, I'm aware of it and use it frequently, heh
08:47:39 <sproingie> so parsec does backtrack if you use 'try'?
08:47:40 <applicative> is a definition of the function 'null' which is true of empty lists, false of others.  There are usually several ways of expressing these things.
08:47:45 <Philippa> sproingie: yes
08:47:47 <dankna> sproingie: that's what try does - it backtracks
08:47:50 <sproingie> makes sense
08:47:50 <alexis> applicative: okay, good to know.
08:48:18 <sproingie> that's probably a good way to go actually, keeps you honest that you're going to try something else if that doesnt match
08:48:33 <dankna> it does seem like a nice idea to have it neatly separated out like that, yes
08:48:34 <wires> dcoutts_: okay, thanks.. so another question: I install a package (hakyll) which depends pandoc (and installs this automatically), but I need to pass -fhighlighting to pandoc. Can I somehow do this?
08:48:36 <quicksilver> dankna: there are choices about how you turn a language into a grammar.
08:48:42 <dankna> quicksilver: certainly
08:48:43 <sproingie> rather than depend on whatever random order you tossed every rule in
08:48:47 <Philippa> sproingie: depends on your POV. Some consider it a premature optimisation and prefer non-backtracking hints instead
08:48:55 <applicative> > let myNull lst = case lst of [] -> True; (x,xs) -> False in myNull [1,2,3]  
08:48:56 <lambdabot>   Couldn't match expected type `[t]' against inferred type `(a, b)'
08:48:57 <quicksilver> dankna: C++, for example, is not context-free, let alone LR or LL
08:48:58 <alexis> applicative: in the slides you've given to me, the author makes heavy use of the lambda syntax, just to define functions, if I'm right. any explanation of why ? (http://www.cs.nott.ac.uk/~gmh/chapter8.ppt)
08:49:00 <dankna> quicksilver: however, frequently you are interested in the AST and not only in whether the language has some correct parse
08:49:05 <applicative> uh oh what a moron
08:49:19 <wires> cabal install -fhighlighting hakyll doesn't work btw
08:49:21 <applicative> > let myNull lst = case lst of [] -> True; (x:xs) -> False in myNull [1,2,3]  
08:49:22 <lambdabot>   False
08:49:34 <quicksilver> dankna: however, it's quite possible to parse it as some simpler language and then do a second parser to resolve the problem cases.
08:49:34 <Philippa> alexis: taste?
08:49:36 <monochrom> this is sounding like "all programs written in haskell take exponential time because here is one way to write an exponential-time algorithm"
08:49:36 <sshc> Is there any documentation on the "default" keyword?
08:49:37 <sproingie> Philippa: eh i see 'try' as something one should eventually aim to use less of
08:49:45 <Philippa> applicative: I'm pretty sure Graham's not a moron
08:49:53 <sshc> I want to have a default type for a class
08:49:55 <dankna> quicksilver: sure, but that approach is dramatically harder to maintain
08:49:55 <sproingie> tho truth be told i'd probably sprinkle 'try' all over the place
08:50:01 <alexis> Philippa: okay :) I'm not to that yet
08:50:16 * sproingie <- regex junkie
08:50:19 <Philippa> dankna: a lot less so than you'd think. Just spit out a computation from your first stage parser
08:50:21 <dankna> I'm not trying to be argumentative here... well, maybe a little
08:50:23 <applicative>   haha, Philippa, it was me not Hutton who wrote (x,xs) for (x:xs)
08:50:35 <dcoutts_> wires: hmm, that's annoying. I think it's probably not possible at the moment then with cabal install, you'd have to use cabal unpack; cabal configure; cabal build; cabal install --only
08:50:38 <quicksilver> dankna: ... so you think C++ should be parsed directl in one pass? Because if so, it's a counterexample to your suggestion that "there are very few grammars not in LR(1)"
08:50:41 <Philippa> applicative: fair enough, missed the context on that bit
08:51:01 <wires> dcoutts_: alright, let me try that. thanks a lot!
08:51:05 <Philippa> haskell technically /needs/ a second operator pass
08:51:12 <applicative> Philippa, I was illustrating case expressions for alexis
08:51:14 <dcoutts_> wires: see we don't record which flags installed packages use, so cabal cannot work out what flags to pick to re-use the installed one
08:51:16 <mreh> http://www.ditl.org/pagotherperson.php?348&PHPSESSID=d1021a8f2cb93274a47c1262dc847453#ref1
08:51:25 <dankna> quicksilver: well, I'd be interested in example constructions in C++ that can't be parsed as LR-plus-context for things like names that need to be known in advance and such
08:51:29 <Philippa> applicative: sure, np
08:51:29 <dankna> like typedefs or whatever
08:51:39 <dcoutts_> wires: and we don't yet have flag constraints exposed in the command line UI
08:51:45 <Philippa> dankna: technically parsing depends on typechecking in C++
08:51:47 <wires> dcoutts_: but if a dependency is already available, why is it reinstalled?
08:51:54 <dankna> I also am not familiar with how C++'s metalanguage works, so that may introduce another pass
08:52:02 <Philippa> been too long since I looked at it for me to produce an example though
08:52:24 <dcoutts_> wires: it's complicated, sometimes it is necessary to reinstall, so it keeps the option open and tries to use installed ones as much as possible
08:52:26 <sshc> How do I specify a default type for a class?
08:52:56 <Philippa> incidentally, I've done the spit-out-the-second-pass thing in a parsec parser. Banged my head a few times getting the types right, but after that pretty straightforward
08:52:58 <wires> dcoutts_: okay, I believe you that it's complicated :-)
08:53:13 <dankna> Philippa: depends on typechecking?  hmm...  in what way?
08:54:00 <wires> dcoutts_: it might not be a bad idea to give some way to configure -f options in the config. also useful for upgrades, boostrapping a fresh system, etc
08:54:00 <Philippa> dankna: it can determine the grammatical role of identifiers in some contexts
08:54:15 <wires> dcoutts_: anyway, thanks for your help
08:54:18 <dankna> well, I'm glad it worked for you, of course.  but I don't think it would be nearly as easy for a third party to modify and update as a single-pass parser of any variety.
08:54:33 <dankna> hmm, okay
08:54:43 <quicksilver> A single-pass parser for C++ would be a rat's nest.
08:54:43 <Philippa> (but it's been years since I saw the details and the last time I wrote any C++ was a VM to run UMIX for the ICFP contest)
08:54:50 <quicksilver> I would wager that none exists.
08:55:03 <Phyx-_> hrm
08:55:10 <Philippa> dankna: I should work on the factoring slightly, but after that? Document cleanly and anyone who's good with parsec'll be fine
08:55:17 <quicksilver> If one did exist, it would probably cost the life of the one who wrote it; it would be much *harder* for any third party to maintain.
08:55:20 <dcoutts_> wires: right, if we had a flag constraint on the command line then it'd also be possible to specify in the saved config file
08:55:44 <Philippa> quicksilver: you missed out the bit where running it summons beings from the beyond
08:56:01 <dankna> I hope that's true, of course.  I'm still kind of baffled that people don't want the more powerful /and/ simpler abstraction of being able to specify a grammar directly as BNF...
08:56:12 <Philippa> it's not more powerful
08:56:13 <wires> dcoutts_: I'm not sure I understand you: I can pass -f during cabal install , it is just not passed to a dependency down the line
08:56:21 <dcoutts_> wires: e.g. like how we have --constraint='pandoc >= 2' we could have --constraint='pandoc +highlighting'
08:56:21 <Philippa> far from it
08:56:36 <Philippa> (also, EBNF at minimum, thanks)
08:56:41 <dankna> well, yes, EBNF
08:56:46 <dcoutts_> wires: right, the feature flags apply just to the packages you list on the command line, not deps
08:56:52 <quicksilver> dankna: I think we're at cross purposes, somewhat.
08:57:04 <quicksilver> dankna: you can't specify C++ in BNF or EBNF
08:57:05 <dankna> quicksilver: hmm....  that would explain things, perhaps.
08:57:07 <Philippa> PEGs are at least in the same ballpark as EBNF there, and parsec gives you higher-order PEGs
08:57:14 <quicksilver> not propertly, not the language proper.
08:57:17 <wires> dcoutts_: oh ok, like that. for me a simple "cabal install hakyll -fhightlighting pandoc" or something would work (meaning it would install hakyll and pass -f to pandoc)
08:57:32 <quicksilver> all EBNF can do is some kind of concrete syntax tree which can be post-processed to actually make C++
08:57:40 <quicksilver> it's full of context, back-references, and side-conditions.
08:57:48 <dcoutts_> wires: mm, actually that might just work, use --dry-run to see what it'll do
08:57:49 <wires> dcoutts_: automatically passing down to deps is probably not what you want...
08:57:56 <dcoutts_> wires: indeed
08:57:58 <quicksilver> and I don't think C++ is particularly unusual here, although it's probably the worst.
08:58:24 <Philippa> you can't parse haskell operators in one pass
08:58:26 <dankna> I do think C++ is fairly unusual.  To prove my point I think I may try writing a grammar of Perl sometime...
08:58:31 <Philippa> not completely accurately
08:58:36 <quicksilver> dankna: ah, well, perl is worse.
08:58:41 <sproingie> perl is the worst in its own special way
08:58:45 <quicksilver> dankna: to parse perl you need to embed a full perl interpreter.
08:58:49 <dankna> haha
08:58:51 <dankna> point taken
08:58:53 <quicksilver> because it can't be parsed without executing it.
08:59:06 <dankna> the same is technically true of Common Lisp, I guess
08:59:16 <dankna> it has a concept called a read-time macro
08:59:17 <sproingie> you can't properly parse perl without running perl
08:59:17 <sproingie> thanks to the ambiguity of "indirect object" syntax
08:59:19 <sproingie> i can't recall, what else requires running perl to parse?
08:59:21 <flaggy> hello, I'm interested in parsing an e-mail and extracting the plain text part of it (already correctly decoded) and, in the absense of such part, the html text part. Is there a good library for that?
08:59:27 <Phyx-> dcoutts_: quick question, would a patch rewriting cabal-install's hardcoded putStrLn's to a configurable function be acceptable? That way I can choose where to send it and format the output
08:59:53 <dcoutts_> Phyx-: the API is going to be tricky
09:00:10 <dcoutts_> Phyx-: my plan in that area is to introduce a full-on scripting monad
09:00:12 <quicksilver> sproingie: whatever  / 25 ; # / ; die "this dies!";
09:00:22 <Philippa> dankna: the fun thing is, parsec /can actually parse something like that/
09:00:25 <quicksilver> sproingie: (thanks to randalschwartz for that gem)
09:00:42 <dankna> but I mean, these non-context-free issues can very commonly be handled by adding additional state to the parser and making the lexer and/or the reduction rules inspect that state
09:00:58 <sproingie> quicksilver: i thought that was just a special case in the parser and didn't require executing perl to parse
09:01:02 <Philippa> parsec can parse the case where the input contains grammar rules to be applied to subsequent input
09:01:09 <dankna> not having parsed C++ myself I don't have an opinion on whether it's possible there.  I do know that it is somewhat of a kitchen-sink language and wouldn't be surprised to find that it's not sufficient.
09:01:12 <dcoutts_> Phyx-: how would you do it, it'd need an extra var passed everywhere, like the current Verbosity
09:01:21 <sproingie> quicksilver: oh right it depends on how 'whatever' is defined
09:01:25 <quicksilver> sproingie: right.
09:01:35 <Philippa> and yeah, but once you've got that far, it's not EBNF any more
09:01:38 <dankna> hmmmmm..... you know, that's actually a very interesting point, Philippa
09:01:40 <Phyx-> dcoutts_: Yeah, one that holds a function, much like the GHC-API. I'm kinda stuck at the moment trying to read back in all error and warnings produced by cabal-install. but since there's no shared structure to them it's hard to determine where one begins and where the other ends
09:01:41 <quicksilver> dankna: yes, of course you can do that
09:01:53 <quicksilver> dankna: but then it's no longer a general LL/LR/EBNF or whatver parser generator
09:02:07 <dankna> well, I guess what I was attempting to say in the first place is that LR-plus-state is a prettier abstraction than PEG-plus-state
09:02:09 <quicksilver> dankna: instead it's a ratnest customer parser framework with a way to modify state at parse time.
09:02:22 <sproingie> lisp's situation by comparison is far less dire -- at least it can parse forms out without running lisp
09:02:25 <sproingie> quite trivially in fact
09:02:35 <dcoutts_> Phyx-: aye, so that's going to be rather invasive, hardly less invasive than using a proper monad (and getting rid of the Verbosity arg everywhere)
09:02:35 <Philippa> dankna: matter of taste. Also, parsec is more than PEG-plus-state, but yeah
09:02:50 <dankna> um, LR parser generators have been doing the state trick for decades and although it may technically violate layers of abstraction it is fairly comprehensible
09:03:03 <Philippa> it's standard in the field, certainly
09:03:16 <sproingie> ah yes parser state ... like MOO's "dollars_up++"
09:03:27 <sproingie> used to differentiate $foo and foo[$]
09:03:28 <Philippa> have you spent as long with parsec as you have with LR parsers, though?
09:03:49 <dcoutts_> Phyx-: what are you working on ooi where you need to collect the warnings/messages?
09:03:54 <dankna> no, I have to admit that I haven't
09:04:50 <Phyx-> dcoutts_: same as last time, msbuild, I would like to give back accurate feedback on why a build failed.
09:04:56 <dankna> I do think we are at cross purposes somehow
09:04:58 <Philippa> FWIW, I'm open to the argument that relatives such as polyparse are prettier
09:04:59 <aristid> it would be nice if cabal update would not download the entire list every time
09:05:15 <dcoutts_> aristid: yep, got time to work on it? I've got a plan if you do
09:05:25 <Phyx-> dcoutts_: currently because warnings start with "warning:" it detects those (only the first line) but it doesn't see errors at all
09:05:25 <Philippa> yeah, I think the stronger argument you have is "I want to parse LRish grammars, LL-derived systems are the wrong abstraction for me"
09:05:31 <dankna> I'm basically saying the approach I advocate is prettier and more maintainable
09:05:38 <dcoutts_> Phyx-: remind me about what you're doing with msbuild
09:05:47 <dankna> that's also true, yes
09:05:51 <aristid> dcoutts_: how much time?
09:06:17 <dcoutts_> aristid: probably a day or two in total for a reasonable implementation
09:06:18 <Philippa> I still disagree about prettier in general, and maintainability depends a lot on who's doing it. Modulo the culture issue, I'm not convinced
09:06:33 <dankna> I mean, I said this already, but I just think there's something wrong about giving such prominence to an abstraction that can't handle certain things
09:06:52 <Philippa> there /is/ the related issue that you tend to get your specs in a relative of BNF rather than PEG
09:06:55 <dankna> Parsec and its relatives are almost always the tools that come up when newbies ask how to parse things in Haskell, and in tutorials
09:07:00 <dcoutts_> aristid: the idea is to use the tar format uncompressed and to usually just append to the tarball, so clients only have to download the tail of the file.
09:07:03 <Philippa> why not? You're suggesting the same
09:07:12 <aristid> dcoutts_: how about using rsync? :)
09:07:16 <dankna> well, yes, I suppose I am, but it's at least the best known
09:07:20 <dcoutts_> aristid: no good, has to be http
09:07:24 <Philippa> there are always tradeoffs. Parsec is a nice demonstration of things that can be done in Haskell that can't be done with, say, C
09:07:28 <Phyx-> dcoutts_: I'm using it to provide a way to build projects in visual studio with cabal. It's used as a intermediary to cabal-install. in that it returns properties inside a .cabal file and also builds, configures and cleans projects by invoking cabal-install. But when a build fails, i want to be able to return the full message back to the user in the error dialog
09:07:35 <dcoutts_> aristid: if some checksum fails then we fall back to downloading the whole thing
09:07:46 <aristid> dcoutts_: hmm, rsync would be very nice for this though :)
09:07:53 <quicksilver> dankna: do you have any evidence that parsec doesn't work on large realistic grammars?
09:08:00 <quicksilver> I'm not saying it's going to win any speed contests
09:08:04 <dcoutts_> aristid: aye but people need to deploy archives on dump http servers
09:08:07 <dankna> my main evidence is the lack of libraries implementing such
09:08:11 <dcoutts_> dump/dumb
09:08:12 <quicksilver> but from what I understand it is actually reasonable performance-wise.
09:08:22 <Philippa> dankna: time/effort/lack of need
09:08:31 <dankna> there's always a need for parsers :)
09:08:54 <dcoutts_> Phyx-: ok, cool yes. So using a proper monad would be ideal for IDEs/GUIs to collect messages and present them sensibly formatter.
09:08:55 <Philippa> sure, so write some for us?
09:08:58 <dankna> and time/effort would just make my case for me
09:09:02 <dankna> I actually have that on my agenda
09:09:12 <Philippa> not really: it just means nobody needed it badly enough for it to be worthwhile
09:09:13 <aristid> dcoutts_: ok i guess it would be possible to hack something like rsync that works with dumb static http servers, but..
09:09:36 <dankna> I've written a parser for sqlite's dialect of SQL using Happy - I forget whether I've released it yet or not, I may have decided I wanted to keep it easily modifiable for a little longer, but it's on the docket
09:09:40 <Philippa> dcoutts, for example, ought to have a fair idea where my own time/effort thresholds lie
09:09:48 <Philippa> cool
09:09:54 <quicksilver> dankna: Language.Java parses Java using parsec
09:10:02 <quicksilver> dankna: that's a moderately sizeable grammar.
09:10:05 <dankna> I've got various others on the docket to serve as practical examples for Joy, my own framework, when it's ready
09:10:13 <dankna> true, it is, and that impresses me
09:10:17 <wires> dcoutts_: Ha! "cabal install hakyll -fhighlighting pandoc" and this works
09:10:17 <Philippa> most of the parsers I've been writing are for haskell-like syntax. Given that I can handle the operators, the rest's cake
09:10:27 <wires> dcoutts_: thanks!
09:10:30 <Phyx-> dcoutts_: I'll try and come up with something and submit it to the mailing list for further review then before I implement it. I would much rather this be in the tool itself then in a "custom" version I made.
09:10:35 <Philippa> parsec 3, incidentally, can be rigged up to implement the nasty part of the layout rule literally
09:10:37 <dcoutts_> aristid: it's more work for people to set up, it's actually relatively heavyweight in terms of cpu usage etc, append only and http range GETs is fairly lightweight and has the advantage of working with http
09:10:39 <aristid> Fetching a hashed repository would be faster.  Perhaps you could persuade
09:10:39 <aristid> the maintainer to run darcs optimize --upgrade with darcs 2.4.0 or higher?
09:10:51 <Philippa> that is, the bit where it (subject to appropriate layout state) /may/ insert a ; on parse error
09:10:52 <aristid> says the server about the cabal darcs repo
09:11:01 <dankna> the layout rule is indeed nasty
09:11:40 <Philippa> not only that, it can do it with a nice, clean separation: the parser makes a quick call to the layout engine sitting in an underlying monad, and continues
09:12:01 <dankna> well, that's absolutely a good thing
09:12:15 <dcoutts_> Phyx-: right, ok. If you're interested, my plan was to use the "poor man's concurrency monad" approach, but without the concurrency :-) ie have the monad produce a data structure and then have a separate interpreter.
09:12:17 <Philippa> so, I *know* parsec works well for a language like Haskell
09:12:18 <aristid> dcoutts_: well, the http-only rsync variant would involve pre-generating the checksums on the server before uploading, and uploading the list as a file, so the client can do all the logic. but that's probably not worth the effort
09:12:30 <Philippa> (I haven't done haskell itself in it, mind)
09:12:55 <quicksilver> the parsing framework underlying language.haskell and haskell-src-exts is a "parsec-like" combinator library isn't it?
09:13:00 <quicksilver> even though it isn't actually parsec.
09:13:11 <aristid> dcoutts_: http://darcs.haskell.org/cabal/ ?
09:13:36 <Philippa> quicksilver: never looked
09:13:46 <Saizan> iirc haskell-src-exts uses happy
09:13:56 <dcoutts_> aristid: you probably want to use http://darcs.haskell.org/cabal-branches/cabal-1.10 and http://darcs.haskell.org/cabal-install
09:14:19 <Phyx-> dcoutts_: ah ok, that sounds good.
09:14:24 <aristid> dcoutts_: are those also so painfully slow? and did i mention that i like git? :P
09:14:34 <dcoutts_> aristid: :-)
09:14:39 <dankna> it uses Happy, cf. http://hackage.haskell.org/packages/archive/haskell-src-exts/1.9.6/haskell-src-exts.cabal
09:14:43 * quicksilver nods
09:14:46 <quicksilver> yes, sorry
09:14:48 <quicksilver> it does
09:14:49 <quicksilver> win 22
09:14:52 <dcoutts_> aristid: we'll upgrade darcs eventually on that server and then switch to hashed repos for faster download
09:15:22 <dcoutts_> aristid: so what I was thinking of is actually much simpler, you just append to the 00-index.tar on the server, rather than rewriting the file (tar format supports this)
09:15:25 <sm> yes please
09:15:42 <dcoutts_> aristid: then the client just fetches the tail of the file that they don't already have using a GET range request
09:15:49 <aristid> dcoutts_: sure. you still need a list of checksums, of course
09:15:57 <dcoutts_> aristid: no, just one, that's the nice thing
09:16:03 <aristid> huh?
09:16:16 <dcoutts_> aristid: just need to make sure we have the same index on the client as on the server
09:16:33 <dankna> I thought the rsync protocol did something funny when it found a checksum that didn't match
09:16:35 <monochrom> Philippa: your parsec 3 technique of helping layout from the underlying monad is neat! cunning!
09:16:40 <dankna> to detect blocks which are intact but merely offset
09:16:46 <aristid> dcoutts_: so the client just assumes that he has a correct partial version and checks the end result?
09:17:10 <applicative> alexis, sorry I crashed.  Hutton uses the form:  myFunction = \x -> ....x...., rather than myFunction x = ...x.... , which are both legitimate, since he's emphasizing that a parser is always a function
09:17:18 <aristid> dankna: yeah it uses rolling checksums
09:17:23 <aristid> dankna: it's very cool :)
09:17:26 <dankna> yeah, it is cool
09:17:32 <Philippa> monochrom: also one of the motivating examples for building the lib :-)
09:17:36 <dankna> I haven't been following your conversation as I was embroiled in my own :)
09:17:48 <dankna> but doesn't that make your approach for rsync-over-http not work?
09:17:50 <dcoutts_> aristid: right, and if it's wrong, then abandon and download the whole .tar.gz
09:17:58 <applicative> alexis, and, since 'a parser of things is a function from strings to lists of pairs of things and strings', he writes  myFunction = 
09:18:00 <aristid> dankna: no, because the client can do the rolling checksums
09:18:02 <Philippa> Malcolm came up with the best description thereof, though: "backtracking lexer"
09:18:04 <dankna> oh, okay
09:18:05 <dankna> cool then
09:18:13 <applicative> myFunction = \input -> ... input.... 
09:18:26 <dcoutts_> aristid: so when the .tar is used in an append-only way, then we get incremental updates, if it's changed elsewhere then we get the whole thing afresh
09:18:33 <aristid> dankna: i think the rsync algorithm is flexible enough to have the rolling checksums done on either side
09:19:20 <dcoutts_> aristid: see what I mean?
09:19:26 <aristid> dcoutts_: yes.
09:19:45 <dcoutts_> aristid: so the most tricky bit is how we communicate the checksum of the whole file
09:19:45 <dankna> oh, gotcha
09:19:51 <alexis> applicative: true, i was smiling while understanding that
09:19:51 <aristid> dcoutts_: i'm not sure if that's optimal when you have many complete rewrites of the tar files, for compaction reasons or such
09:20:07 <JohnnyL> how does one write a multi processor app using Haskell?
09:20:18 <alexis> applicative: in fact, since I've discovered it, haskell makes me smile as I was smiling while discovering python :)
09:20:26 <JohnnyL> (an app that spans multiple machines)
09:20:30 <dcoutts_> aristid: right, it's not optimal if there are many rewrites, but in practice the index is actually append only, there are no deletions
09:20:31 <applicative> alexis, that's what forces the case ... of [] -> this; case x:xs of -> that language on him.  if you were just defining a function, the natural thing would be to say what it is in the two cases on separate lines (with some qualifications)
09:20:34 <aristid> dcoutts_: and to work well, the method also needs a http sevrer that supports gzip compression, right?
09:20:52 <dcoutts_> aristid: not essential
09:20:58 <aristid> or wait, gzip is probably deactivated on partial downloads
09:21:10 <dcoutts_> aristid: but the archive format would need both the .tar and .tar.gz versions
09:21:32 <dcoutts_> aristid: that probably depends on the server
09:22:43 <dcoutts_> aristid: http has a md5 header however most servers do not support it, apache does but does not cache it anywhere so it's slow, so people do not tend to enable it
09:23:16 <dcoutts_> and we cannot use the ETAG because we don't know it on the client side
09:23:46 <dcoutts_> so it might need to be embedded in the index itself, e.g. a trailing entry in the tar file
09:23:52 <aristid> dcoutts_: hmm, i guess it would be nice to have file systems with md5/sha1/... support embedded
09:24:11 <dcoutts_> aye, or just if apache would look for file.md5 or something
09:24:31 <dcoutts_> which is another option of course
09:24:40 <aristid> with some significant drawbacks
09:24:45 <dcoutts_> 00-index.tar.md5
09:25:03 <dcoutts_> aristid: significant?
09:25:04 <aristid> and 00-index.tar.gz.md5
09:25:22 <dcoutts_> I think you'd only need the 00-index.tar.md5 one
09:25:31 <aristid> dcoutts_: well if apache would do that generically, the danger of serving broken checksum headers would be high
09:25:47 <jmcarthur> JohnnyL: well, here's one way: http://hackage.haskell.org/package/DSTM
09:26:01 <dcoutts_> aristid: sure, it'd have to be a config option, or have apache manage them itself, looking at timestamps etc
09:26:02 <JohnnyL> jmcarthur: k
09:26:32 <aristid> dcoutts_: timestamps suck. cryptographic hashes are supposed to replace them :)
09:26:42 <turiya> is haskell suited for linear algebra applications?
09:26:44 <jmcarthur> JohnnyL: but of course there are lots of different ways that one might want to distribute work. DSTM is really just a way to share state across multiple machines
09:26:47 <JohnnyL> jmcarthur: transpancy, nice.
09:26:47 <aristid> but i'm getting too hypothetical
09:26:48 <dcoutts_> aristid: since it's only when you're doing a range GET that you need to check the checksum, we don't need to bother when we GET the whole .tar.gz
09:27:05 <JohnnyL> transparency
09:27:21 <dcoutts_> hmm, but perhaps the same append-only trick works with the compressed .tar.gz
09:27:29 <dcoutts_> it depends on properties of gzip compression
09:27:36 <dcoutts_> would not work with bzip for example
09:27:37 <aristid> dcoutts_: or at least not we don't really need it. there is non-zero, but negligible, risk, that the download could have an otherwise undetected error :)
09:27:40 <jmcarthur> JohnnyL: i've not used DSTM, so can't really vouch for it. i've only heard of it
09:27:58 <dcoutts_> aristid: aye
09:28:50 <JohnnyL> jmcarthur: ok
09:29:46 <aristid> dcoutts_: heh, just found http://hackage.haskell.org/trac/hackage/wiki/SourceGuide - is it still reasonably accurate? :D
09:32:37 <dcoutts_> aristid: yes, but only covers the Cabal library, not the cabal-install program
09:33:17 <dcoutts_> aristid: and all this update stuff is done in the cabal-install program
09:33:27 <aristid> dcoutts_: i see.
09:33:32 <dcoutts_> using the HTTP library and the Browser module
09:34:15 <dcoutts_> might be easier to prototype on it's own, using HTTP lib and copying bits of code from the couple existing cabal-install modules that do http stuff
09:34:39 <turiya> are the main advantages of 'stateful' programming speed and less memory consumption?
09:35:45 <dcoutts_> aristid: http://hackage.haskell.org/trac/hackage/ticket/428
09:35:46 <JohnnyL> jmcarthur: I'll bet the future of Haskell will be server applications.
09:36:00 <aristid> dcoutts_: ok i think i'll start trying this in a few hours
09:36:04 <jmcarthur> JohnnyL: why?
09:36:06 <dcoutts_> aristid: cool
09:36:08 <monochrom> no. the main advantage is mirroring status quo hardware
09:36:38 <dcoutts_> aristid: will save loads of bandwidth worldwide :-) but more usefully will mean people can update more frequently
09:36:38 <sjoerd_visscher> I'm trying to build GHC head, which worked fine before, but now I'm getting a lot of Illegal bang-pattern errors
09:36:42 <JohnnyL> jmcarthur: concurrency,stateless, 'safe' memory, interpreter..etc.etc..
09:37:20 <jmcarthur> JohnnyL: why are those so specific to server applications though? seems to me that *most* applications can benefit from haskell's pros
09:37:25 <dcoutts_> turiya: those are the advantages of a statefull implementation, not necessarily of programming. e.g. ghc compiles Haskell to fast stateful low level code.
09:37:39 <monochrom> in the same sense that "is the main advantage of bribing in russia speed and less hassle? no, the main advantage is perpetuating the bribing culture"
09:38:33 <JohnnyL> jmcarthur: it's true... but the learning ramp (imho) for Haskell is quite long. I agree with most, but the market is splintered with all sorts of different software architectures.
09:38:49 <jmcarthur> turiya: there isn't really an advantage to stateful programming except that compiler implementors have an easier time mapping it to current hardware... which isn't really that big of a deal, IMO
09:39:31 <monochrom> see also http://article.gmane.org/gmane.comp.lang.haskell.cafe/22537/
09:39:33 <jmcarthur> turiya: and even that is not universally true
09:39:35 <aristid> dcoutts_: given that you're probably not around when i start hacking, i guess the idea of creating a stand-alone prototype is good
09:39:39 <turiya> dcoutts_, monochrom: what type of hardware would suit a language like haskell better?
09:39:54 <alexis> do you see anything wrong with that ?
09:39:55 <alexis> sum_list (head:tail) = head + sum_list(tail)
09:40:09 <dcoutts_> aristid: right, and we can integrate later
09:40:19 <alexis> the interactive parser complains about "="
09:40:40 <aristid> jmcarthur: i think haskell can shine more easily on the server, because it needs less integration with non-haskell libraries there :D
09:40:42 <Cale> turiya: Something with much higher memory bandwidth, but possibly simpler processing.
09:40:57 <Cale> turiya: Take a look at the Reduceron
09:41:02 <jmcarthur> turiya: for example, the fact that shader languages are imperative is a bit of a disaster. the hardware has a lot of state, but the shaders aren't really allowed to manipulate much of it anyway, so a less stateful shader language would probably be easier to implement
09:41:03 <dcoutts_> turiya: something like this: http://www.cray.com/products/XMT.aspx
09:41:37 <Cale> turiya: An FPGA running at 90 MHz can compete with modern machines and compilers :)
09:41:57 <turiya> i am trying to implement a simple matrix addition and i see it is easiest to do this with foreignptr's, which unfortunately bring the IO monad into the picture..
09:41:59 <applicative> alexis, are you typing it inside the interpreter. then you need 'let'
09:42:09 <Cale> (though not so favourably yet that you'd really go out and get one for anything but research and fun)
09:42:16 <jmcarthur> turiya: ouch. i'd say you should look for a different solution
09:42:22 <applicative> alexis, this function needs another case, for the empty list, else it won't terminate....
09:42:28 <jmcarthur> turiya: i disagree with that being the easiest way to do that in haskell
09:42:47 <alexis> applicative: yep
09:42:57 <Cale> Yeah, you should definitely not need ForeignPtrs for that unless you're interfacing with some external matrix library
09:43:03 <jmcarthur> turiya: for example, in repa, matrix addition is just (+)... and if you want to complain that that's cheating, its implementation is zipWith (+)  :P
09:43:03 <conal> roconnor: ping
09:43:07 <turiya> jmcarthur, are there any alternatives besides using lists?
09:43:12 <jmcarthur> turiya: tons
09:43:23 <Cale> turiya: How about using actual Haskell arrays? (Haskell has arrays as well)
09:43:26 <applicative> > let sum_list (head:tail) = head + sum_list (tail) ; sum_list [] = 0 in sum_list [1,2,3]
09:43:27 <lambdabot>   6
09:43:34 <applicative> alexis ^^^
09:43:38 <jmcarthur> turiya: if you really want to stick with the traditional array way of doing it, you could use a nice array library (such as array or vector)
09:43:46 <aristid> Cray still exists?
09:43:59 <jmcarthur> turiya: repa is a bit experimental, but very fast (uses arrays under the hood) and pretty high level
09:44:10 <jmcarthur> turiya: there are also bindings to fast C libs out there. e.g. hmatrix
09:45:03 <jmcarthur> turiya: you could even (and i'm not necessarily endorsing it) use IntMaps
09:45:04 <applicative> alexis, in ghci you can drop the "in ..."  and it will store the definition of sum_list for the session.  lambdabot oneliners are always let f = blah in f 17  
09:45:17 <jmcarthur> IntMap could be an interesting way to do sparse matrices...
09:45:59 <c_wraith> Huh.  I didn't realize manateelazycat had such an english-sounding name.
09:46:05 <turiya> jmcarthur: if I am using C bindings, does it not necessarily mean that I should be programming within the IO monad?
09:46:12 <jmcarthur> there's also, of course, the normal array version of sparse matrices, which is a common example used to demonstrate nested data parallel haskell
09:46:16 <jmcarthur> turiya: no
09:46:24 <dcoutts_> aristid: Cray mostly use amd64 these days, plus their custom interconnect, but yes they still exist
09:46:26 <applicative> c_wraith, it's his english name, he has a chinese one as well.  
09:46:28 <jmcarthur> @hackage hmatrix
09:46:28 <lambdabot> http://hackage.haskell.org/package/hmatrix
09:46:35 <c_wraith> turiya, depends on what the semantics of the library you're binding too are.
09:46:39 <c_wraith> applicative, ah, that makes sense.
09:46:40 <Cale> turiya: http://vimeo.com/15832032
09:46:40 <arcatan> c_wraith: I've understood in China people typically have a western name in addition to their chinese one
09:47:09 <applicative> it was the tradition in Hong Kong in the old days, I know.  evidently it has moved inland....
09:47:20 <monochrom> but not a western family name
09:47:30 <Phyx-> I'm constantly surprised how the most effective debugger is pen & paper..
09:47:46 <monochrom> for example I am "Albert Lai" but not "Albert Mendellason" :)
09:47:53 <aristid> dcoutts_: and their interconnect gives them an advantage?
09:48:03 <dcoutts_> aristid: yep
09:48:06 <applicative> monocrom, right, i never knew of cases like that either.
09:48:13 <turiya> jmcarthur, Cale: ok, but all the bindings (X11, SDL) I have used till date forced me to do the stuff in IO monad
09:48:33 <Cale> turiya: Yeah, that's natural.
09:48:33 <dcoutts_> aristid: plus building big systems and packing the whole thing with reasonable programming tools
09:48:35 <jmcarthur> turiya: those are doing a lot of inherently IO things
09:48:44 <applicative> monochrom, is his last name unusually unpronouncable?  i can't remember what it looks like
09:48:45 <dcoutts_> aristid: but the interconnect is the secret sauce really
09:48:54 <jmcarthur> turiya: not all C bindings perform IO operations (except under the hood)
09:49:02 <aristid> dcoutts_: does GHC run well on these? :D
09:49:05 <monochrom> I haven't seen his Chinese family name.
09:49:41 <Cale> turiya: A higher-level binding to SDL or X11 would let you get away with writing more code not in IO (to describe the graphics that you want to put on the screen before actually doing it), but would ultimately require some IO actions to really commit the stuff to display.
09:49:42 <dcoutts_> aristid: sadly I don't think many people have tried, I tried when I was an intern there ~9 yrs ago, didn't get too far ;-)
09:49:56 <aristid> DAMN, acrobat reader is painfully slow
09:50:05 <applicative> maybe he didn't say.  he said it was pointless to transliterate his name once, when people attacked him, since we wouldn't be able to make anything of it
09:50:33 <Cale> turiya: If something does actual input or output, it needs to have IO somewhere in its type.
09:50:35 <dcoutts_> aristid: but in principle I don't think it'd be so hard, especially since they mostly use 64bit x86 these days
09:50:55 <turiya> jmcarthur, Cale: i understand a bit now.. what is the reduceron (sorry, i dont have flash installed currently)
09:50:55 <monochrom> who! who dared to attack ManateeLazyCat!
09:51:00 <aristid> dcoutts_: right, only thing would be supporting the interconnect from haskell i guess
09:51:06 <dcoutts_> aristid: the hard thing would be the programming model, treating it like SMP won't work so well
09:51:21 <dcoutts_> aristid: one could use MPI, we're working on a binding, about to release it
09:51:28 <Cale> turiya: It's an FPGA implementation of a hardware architecture for functional programming languages (and Haskell especially)
09:51:54 <aristid> dcoutts_: is MPI a good fit for haskell?
09:52:43 <dcoutts_> aristid: not yet clear :-) but MPI is basically the way to program weird fast interconnects (infiniband etc), since the makers provide the drivers
09:53:10 <turiya> Cale: oh great, i hope before such hardware becomes common in a few years time
09:53:12 <Cale> turiya: They have an FPGA running at 96 MHz, which sounds slow, but it does a reduction step every clock cycle using parallel memory transactions.
09:53:13 <dcoutts_> aristid: anyway, it's not clear that MPI is a good fit for Fortran or C  ;-)
09:53:22 <alexis> applicative: thx :)
09:53:28 <alexis> gtg, see you
09:53:39 <monochrom> I believe in message passing and disbelieve in shared memory for distributed computing.
09:53:40 <aristid> Cale: and then it suddenly does not sound slow anymore
09:53:50 <aristid> monochrom: a true believer you are
09:54:12 <aristid> i believe in the importance of ease of programming.
09:54:17 <dcoutts_> monochrom: despite it's name, MPI doesn't seem to be very good for message passing
09:54:31 <alpounet> Cale, i did work during an internship around an FPGA (was with C++ though)
09:54:37 <alpounet> the performances are quite impressive
09:54:45 <monochrom> that's too bad.
09:55:46 <Cale> I'm also pretty excited about the mid-range future of memristor processors. They seem like they'd be absolutely ideal for graph reduction.
09:56:11 <applicative> alexis, see you, i should go too.    our friends are always here to explain things....
09:57:02 <Cale> (A crossbar array of memristors can act as a memory, but can also compute logical implication, which makes it computationally complete.)
09:58:19 <dcoutts_> Cale: the reduceron is indeed impressive, though it's unclear if it could scale up to speeds where it'd be competitive. Though if someone fabed a version it could be a very low power cpu which might be competitive.
09:58:51 <dcoutts_> problem as I understand it is about the memory latency
09:58:57 <turiya> jmcarthur: what's repa?
09:59:00 <monochrom> \/ for classical implication!
10:00:02 <applicative> @hackage repa
10:00:02 <lambdabot> http://hackage.haskell.org/package/repa
10:00:11 <roconnor> conal: ack
10:00:34 <pozic> Is there any language which has hard real-time parallel semantics? 
10:01:45 <conal> roconnor: hi. i just read the haskell-cafe thread "serialization of (a -> b) and io a", and i thought of you. have you read the thread?
10:02:01 <turiya> what is the lambdabot?
10:02:02 <roconnor> nope, let me check it out
10:02:17 <applicative> turiya, what it sounds like... 
10:02:21 <conal> k
10:02:27 <applicative> turiya, it's main business is to evaluate expressions.
10:02:31 <applicative> > 1 + 1
10:02:31 <lambdabot>   2
10:02:48 <applicative> turiya, and to supply types
10:02:52 <Cale> :t scanl
10:02:53 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:02:54 <applicative> @type foldr
10:02:55 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:03:08 <applicative> .. like Cale says...
10:03:10 <gds> turiya: It does everything. It's modular, and people have written a lot of modules for it. You can download it with cabal install.
10:03:34 <gds> @google lambdabot
10:03:35 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
10:03:35 <lambdabot> Title: Lambdabot - HaskellWiki
10:04:04 <turiya> cool..
10:04:05 <Cale> (The code is a bit of a mess by now though :)
10:04:06 <roconnor> conal: I don't really read -cafe so I rely on people like you to point me to interesting stuff
10:04:39 <applicative> @faq could a haskell bot make breakfast lunch and dinner for me, and also correct my syntax?
10:04:40 <lambdabot> The answer is: Yes! Haskell can do that.
10:04:46 <conal> roconnor: i only scan titles  on haskell-cafe these days
10:05:02 <gds> @quote lambdabot
10:05:03 <lambdabot> lambdabot says: is annoying
10:05:11 <lispy1> Cale: actually, I tried to install lambdabot fresh from hackage the other day, looks like there are some issues with the build deps and OldExceptions
10:05:35 <roconnor> conal: I sometimes scan authors.
10:05:35 <applicative> turiya, you can open a private conversation with lambdabot.  
10:05:45 <Cale> lispy1: Yeah, I don't really maintain that package, (maybe that's gwern?)
10:05:50 <turiya> applicative: how?
10:06:00 <lispy1> Cale: ah.  I host it, you run it, and gwern maintains it?
10:06:08 <lispy1> Distributed services :)
10:06:18 <Cale> Yeah, something like that...
10:06:28 <gds> turiya: type "/query lambdabot"
10:06:41 <Cale> gwern seems to mostly package it. We don't really have a maintainer for the code itself anymore.
10:07:05 <applicative> turiya, a link to the commands is given by 
10:07:08 <applicative> @list
10:07:08 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
10:07:11 <conal> roconnor: this thread reminded me of your quest for a sound denotational footing for IO, and how i see the haskell community as continuing to drift further from that possibility.
10:07:29 <Cale> (Which is probably okay, since lambdabot is big and complicated enough, and someone should probably write a new IRC bot :)
10:07:59 <aristid> Cale: but! it would be very difficult finding an appropriate name
10:08:01 <conal> roconnor: how, in a sense, IO serves as a haven from equational reasoning etc.
10:09:30 <applicative> a haven...?  
10:09:42 <pozic> applicative: think of boats
10:10:05 <conal> applicative: a place to escape to.
10:10:12 <applicative> I saw a quotation from A. Tang, something like "Debug.Trace is a refreshing desert in the oasis of referential transparency"
10:10:15 <wjt> StateT ImOnABoat IO a ?
10:10:22 <conal> applicative: hah!
10:10:33 <pozic> conal: how often have you used equational reasoning in a commercial environment?
10:10:44 <roconnor> @quote oasis
10:10:44 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
10:11:07 <applicative> yes, that must be where i saw it
10:11:18 <pozic> conal: (I don't mean the informal kind.)
10:11:20 <conal> pozic: thousands of time.  why do you ask?
10:11:38 <pozic> conal: because there are no tools to do so and therefor suspect it is false. :)
10:11:39 <applicative> i'm very sorry I did not learn about Haskell while she was around....
10:12:03 <roconnor> pozic: isn't most equational reasoning informal?  (though by formal I usually think of Agda, and what I think of as informal most people think of as formal.)
10:12:16 <pozic> conal: only recently Haskell and Isabelle have integration, etc., but nobody wants to pay for that, AFAIK.
10:12:20 <monochrom> every time you have "k = do{b;c}" and you reason that "do { x<-a; k } = do { x<-a; do {b; c} } = do { x<-a; b; c }" you use equational reasoning.
10:12:27 <roconnor> applicative: where is she now?
10:12:30 <conal> roconnor: do you see what i mean? about invoking IO as a way to allow equal values to serialize differently?
10:13:07 <monochrom> (aside: you use monad laws too)
10:13:31 <monochrom> every time you think you know what a program does, you use equational reasoning. there is no escape.
10:13:31 <applicative> roconnor, don't know;  there were a few posts about the Pugs Era not long ago  
10:13:36 <conal> pozic: what motivates you to change the topic from equational reasoning to mechanized equational reasoning?
10:13:55 <pozic> conal: equational reasoning by a human is rather sloppy. 
10:13:58 <Cale> monochrom: I agree with that.
10:14:04 <conal> pozic: and?
10:14:08 <pozic> (and thus doesn't count)
10:14:24 <conal> seriously?
10:14:34 <gds> Heh.
10:14:35 <dcoutts_> pozic: pah, be gone doubter :-)
10:14:39 <pozic> Haskell is not special, because the same kind of reasoning can be applied to every other language. 
10:14:48 <Cale> monochrom: However, what conal is unsatisfied about and roconnor is looking for is a more complete formalisation of the laws governing the primitives of IO.
10:14:50 <monochrom> but I agree. exterminate all humans. \/  <-- the bot rejoices
10:14:55 <pozic> It's just that you have to check certain properties (which can be trivially automated).
10:14:59 * dcoutts_ should chuck in his PhD if non-mechanized proofs are no good
10:15:03 <gds> I went to a seminar over summer, where someone described Dijkstra's first concurrent garbage collector...
10:15:09 <gds> He proved it correct...
10:15:13 <pozic> dcoutts_: so, should Dijkstra ;)
10:15:14 <gds> Submitted for publication...
10:15:20 <gds> then someone found a bug.
10:15:28 <gds> Threw the guy for a bit...
10:15:37 <gds> This blew my mind - if he can get it wrong, so can I :)
10:15:45 <gds> Now I'm hunting for mechanised proof-checking :)
10:15:52 <Cale> Completely formalising the semantics of IO is hard, perhaps in part because there are a lot of external things that are hard to specify.
10:16:20 <dcoutts_> Cale: my approach would be not to specify the external things, just your possible interactions with the external things
10:16:53 <conal> and if one did formalize the semantics of IO, then wouldn't IO lose its usefulness as a sin bin? as in that serialization thread?
10:16:56 <Cale> It's also not really clear what the primitives of IO are in the first place.
10:17:13 <dcoutts_> conal: perhaps not, since it'd still be non-deterministic
10:17:25 <monochrom> denotating side effects outside worlds etc has been done, by proliferation of moar environment parameters.
10:17:28 <conal> Cale: yep. also by design. IO is extensible in its primitives.
10:17:36 <Cale> conal: Right.
10:17:52 <roconnor> conal: I'm looking now.  But remember that serializtion doesn't break equational reasoning,  It only breaks extensionality.  If you do constructive type theory like me, you will find that you don't assume extenstionality most of the time anyways.
10:17:55 <monochrom> (I mean it is done but ugly and I don't like it either)
10:18:17 <pozic> As sort of a deepter question one could ask whether everything that can be formalized is actually interesting. 
10:18:19 <roconnor> conal: there is a consistent axiom call the church turning thesis that extends constructive type theory and allows serialization of (some) functions.
10:18:25 <pozic> deeper*
10:18:31 <Cale> I think of IO as a pretty careful compromise with the reality of existing computing.
10:18:39 <roconnor> conal: this axiom is, however, inconistent with the axiom of extensionality.
10:19:44 <conal> dcoutts_: interesting. perhaps serialize could yield *any* string that deserializes into the (denotationally) same value.
10:20:04 <aristid> Cale: how would I/O be done in your dream computing world?
10:20:05 <Cale> "Let's take this mess and package it up into a bundle with as many algebraic laws as we can reasonably get without fundamentally reworking everything, and let people build more specific and refined things on top of that."
10:20:18 <Cale> aristid: That's the thing, I don't know. :)
10:21:07 <pozic> aristid: every action obviously needs to have its exact effects documented with it.
10:21:09 <Cale> aristid: For some specific subsets of IO, there are known ways to do better.
10:21:12 <dcoutts_> conal: oh I see, you mean using non-determinism and the semantics is the set of possibilities
10:21:35 <pozic> aristid: so, e.g. the exact time it takes to do something within a certain range with a certain probability and so on.
10:21:42 <conal> dcoutts_: yes. non-det = Set
10:22:13 <conal> dcoutts_: that's the connection i was making.
10:22:18 <dcoutts_> right
10:22:32 <pozic> aristid: it would be better if it would be expressed in the most up to date laws of physics.
10:22:57 <dcoutts_> conal: like I imagine that the semantics of an IO program is the set of possible traces of events/observations/interactions
10:23:07 <dcoutts_> ie CSP trace semantics
10:23:45 <aristid> pozic: sounds tedious :)
10:23:49 <pozic> dcoutts_: isn't that the eons old interpretation?
10:23:54 <dcoutts_> what's inviting about that approach is you can actually prove things with CSP, refinement etc
10:23:55 <dcoutts_> pozic: sure
10:24:29 <pozic> aristid: yes, but that's what people should be working on. 
10:24:58 <pozic> Nobody does, of course, because it's too big. There are some people who work on models of it, but they are extremely simplified.
10:24:59 <dcoutts_> pozic: though I've not actually seen anyone try to apply CSP to explain Haskell IO
10:25:23 <aristid> pozic: they should... in your dream world :P
10:25:48 <pozic> aristid: right.
10:27:12 <pozic> I saw a presentation by Wolfram where he was computing universes. I thought about doing the same thing (and many other people also have done so before him) and that's another 'bigger picture' that lots of people seem to be missing. 
10:27:31 <pozic> Of course, there is no direct return on investment... ;)
10:28:04 <roconnor> conal: this church-turing axiom, which states forall f:nat -> nat, exists e : Nat, forall n : Nat, {e}(n) = f(n) is well studied, and has a realizer of type (Nat -> Nat) -> Nat
10:28:22 <roconnor> conal: however seralization is much weaker
10:28:34 <applicative> pozic, a thing once 'formalized' does often cease to be interesting, I wonder if it is the process of doing it, and the idea of it, and the insight that shows how it can be done, that tends to be 'deep'
10:28:38 <roconnor> whatever it's axiom is, is realized by (Nat -> Nat) -> IO Nat
10:28:50 <roconnor> and that might provide a lot more flexablity.
10:29:11 <roconnor> I'm not sure
10:29:35 <pozic> applicative: those are wet-ware questions which already have been answered by some AI people.
10:30:10 <applicative> pozic, take frege discovering how to write 'for all x ( F x -> G x) ' and so on.
10:30:17 <alexis> back
10:31:06 <applicative> pozic, if you're stuck with boole and venn, it will seem like a miracle, which it was.  now we yawn
10:31:46 <pozic> applicative: how do you feel about higher-order logic when compared to predicate logic? 
10:32:15 <applicative> pozic, don't know what to say
10:32:31 <pozic> applicative: if you look at the real-world applications of higher-order logic I don't think there are any (other than humans saving some time), but for machines there are no advantages, AFAIK.
10:32:39 <gds> If anyone's interested in trace semantics, they may also be interested in this guy's stuff: http://www.cl.cam.ac.uk/~jpw48/
10:32:47 <gds> Unifying models of data flow, with Tony Hoare.
10:32:52 <applicative> pozic, speaking of frege, his notation was higher order from the beginning.  non-higher order logic was invented later
10:32:57 <gds> I've seen a couple of talks on the stuff - looks very cool to me.
10:33:53 <pozic> applicative: his Wikipedia entry doesn't contain any reference to higher-order logic. 
10:34:33 <applicative> pozic it isn't surprising,
10:35:33 <Cale> Unrealistic dream: Ship myself and 1080^2 = 1166400 neodymium magnet spheres into space and spend a few years constructing 1080 different icosahedral constructions from sets of 1080 magnets, and then snap those together into yet another construction with icosahedral symmetry (up to identification of the subunits :)
10:35:48 <pozic> applicative: stanford agrees with you; good enough for me :)
10:36:17 <Cale> (It'd probably never hold up under gravity)
10:38:20 <pozic> applicative: I think we are more going into a direction in which we might find truly creative algorithms/theorems. That is, things that can only be proved by enumeration. The stuff that didn't require computation was relatively speaking low-hanging fruit. 
10:39:04 <pozic> applicative: have you seen the Mandelbulb for example?
10:39:32 * roconnor finds that large lego structures dont' hold up to the imprefections in the manufacturing of lego.
10:40:13 <zygoloid> roconnor: you mean, like building houses? :)
10:40:44 <sproingie> ever see the mythbusters ep with the giant lego ball?
10:41:09 <zygoloid> http://jalopnik.com/5350457/mega+gallery-james-mays-lego-house-nearly-complete
10:41:30 <roconnor> yes
10:42:18 <sproingie> that looks suspiciously like a wood frame building with lego walls
10:42:46 <zygoloid> sproingie: the wooden frame isn't holding the load. they were required to add one, just in case
10:43:22 <sproingie> i guess having a wall of legos fall on you could be hazardous
10:44:07 <zygoloid> wouldn't be fun if it collapsed while you were on the 1st (US: 2nd) floor
10:44:53 <pozic> In a decade you can print your house in 3d.
10:45:07 <pozic> By a decade, I mean never ;)
10:45:08 <zygoloid> you can today, if you're ok doing it one brick at a time ;)
10:45:26 <pozic> zygoloid: that's not printing. 
10:45:57 <mahogny> I think building a machine for house printing would be easy. but it wouldn't be cost-effective. I know the current prices :S
10:45:59 <zygoloid> if i print a book, i still expect some assembly steps afterwards
10:46:15 <applicative> pozic, sorry wandered off wondering how i could exhibit the higher-orderedness of Begriffschrift, but you can see it easily on p. 55 of the text on scribd here http://www.scribd.com/doc/15392943/Begriffsschrift-Frege
10:46:28 <pozic> mahogny: yes, but think of the savings once it works.
10:46:34 <applicative> pozic, Quine also mentions it there on page 5, in his introductory remarks
10:46:51 <mahogny> pozic, the price is in the manufacturing
10:47:23 <mahogny> ordinary wood is very cheap!
10:48:02 <pozic> mahogny: quality wood as used in house construction was quite expensive. 
10:48:20 <mahogny> damn. lego is expensive. we've tried to build lab equipment with it but it just doesn't have any economy
10:48:56 <pozic> mahogny: did you try reprap.org?
10:49:04 <mahogny> pozic, hm. when we built our summer place is wasn't expensive at all. but then we live in a forest country; might make a difference
10:49:25 <pozic> mahogny: that _might_ be a reason ;)
10:49:30 <mahogny> no, I'm interested in getting one of those :) or build my own from scratch, I need similar CNC machines for some projects
10:56:29 <rovar_> is there a graph oriented database (or simply something that serializes graph oriented data to disk) for haskell?
10:59:59 <djahandarie> rovar_, not sure, but I think there is some interest in one
11:00:07 <djahandarie> Someone was mentioning exactly that yesterday (was it you?).
11:03:23 <roconnor> @type minBound
11:03:24 <lambdabot> forall a. (Bounded a) => a
11:06:40 <cozachk> how do i convert a Ratio to a Double ? 
11:06:48 <roconnor> fromRational
11:07:03 <roconnor> toFrac
11:07:05 <roconnor> hmm
11:07:09 <roconnor> @type fromRational
11:07:09 <lambdabot> forall a. (Fractional a) => Rational -> a
11:07:17 <roconnor> @type toFrac
11:07:18 <lambdabot> Not in scope: `toFrac'
11:07:20 <Cale> realToFrac would work
11:07:24 <roconnor> @type realToFrac
11:07:25 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
11:07:32 <roconnor> realToFrac is good
11:07:47 <roconnor> too bad I never remember it's name
11:07:58 <roconnor> *its
11:10:21 <razvandimescu> how can i declare a list like this? [[1],2]
11:10:51 <mauke> razvandimescu: no
11:10:58 <pacak> razvandimescu: you can't
11:11:10 <led> Heh, GHCi types it out as (Num t, Num [t]) => [[t]]
11:11:14 <led> So, not really sensible
11:11:21 <mauke> > [[1],2]
11:11:22 <lambdabot>   No instance for (GHC.Num.Num [t])
11:11:22 <lambdabot>    arising from a use of `e_112' at <inte...
11:11:40 <mauke> sort of sensible
11:11:40 <pacak> razvandimescu: maybe you should try something like ((1), 2)
11:11:58 <mauke> you could write a Num [t] instance that would turn 2 into [2]
11:12:04 <led> True
11:12:06 <mauke> pacak: that's the same as (1, 2)
11:12:41 <led> If you wrote a Num [t] instance to turn n into [n] then the list that you'd end up with is [[1], [2]]
11:12:48 <led> ...amirite? :/
11:12:56 <monochrom> yes
11:12:58 <razvandimescu> well that's not what i want
11:13:06 <pacak> mauke: For (1, 2) - yes, but if he wants more elements - he will get them
11:13:07 <led> Ergo the not being sensible ;)
11:13:13 <razvandimescu> i wanted to simulate a structure a folders
11:13:23 <led> Ah
11:13:27 <monochrom> design a tree data structure
11:13:31 <led> Tree then
11:13:35 <pacak> razvandimescu: import Data.Tree
11:13:36 <monochrom> or use Data.Tree
11:13:36 <led> Lists aren't your game there
11:13:37 <razvandimescu> and that's how a folder would be translated into a list
11:13:51 <led> It doesn't make sense to use a list structure
11:14:08 <led> Since the types aren't homogeneous - a list of a type and a type are different
11:14:12 <led> Use a tree
11:14:41 <razvandimescu> k, i'll see how i can declare a tree, thanks
11:14:59 <led> Just look at the library Data.Tree
11:15:11 <monochrom> don't use the habit of C programming i.e. shoehorn everything into an old data structure
11:15:42 <esteth> Hey folks. I'm trying to translate a program I've written in python into haskell. It's a solver for the 0-1 knapsack problem, and it's already defined recursively, except I use a piece of semi-global state to memoize the intermediate results. How do I deal with memoiation in haskell? lazy infinite lists?
11:15:43 <led> All you'll need is Tree a = Node a [Tree] | Leaf a
11:15:54 <monochrom> it can always be done and it is always more ugly than Gdel numbering
11:17:14 <led> For some reason I associate memoisation with the reader monad
11:17:21 <led> That's probably entirely wrong though :P
11:17:37 <mreh> can Parsec handle recursively defined backtracking parsers
11:17:42 <monochrom> When I was young I learned how to shoehorn the heap into BASIC arrays.
11:18:10 <mauke> led: the reader monad is function parameters
11:18:29 <mauke> Reader = (->)
11:18:29 <monochrom> yes parsec can
11:19:04 <monochrom> esteth: you may use array or list again
11:19:16 <mreh> It feels like it backtracking to the top of the stack
11:19:51 <led> mauke: ah, cheers
11:20:00 <Cale> esteth: You could do that, but there's a fancy library you could use called data-memocombinators
11:20:15 <Cale> http://hackage.haskell.org/package/data-memocombinators
11:21:34 <esteth> Cale: I took a look at that, but I was hoping there was a DIY solution, since I'm trying to learn to think in haskell while I'm doing this, and I don't understand the implementation of data.memocombinators
11:21:39 <mreh> :t parse
11:21:40 <lambdabot> Not in scope: `parse'
11:21:59 <Cale> esteth: Okay, so let's take a look at your function.
11:22:48 <monochrom> the dynamic programming algorithm for knapsack has this usage pattern: you build array version 1, then you build array version 2 based on version 1, then version 1 is no longer needed. if you are careful and have mutable array, you can in-place change version 1 to version 2. if you don't have mutable, you can still build version 2, then just throw away version 1.
11:23:21 <Cale> esteth: Probably you have two parameters: an amount of remaining weight, and a list of items which can be chosen from, yeah?
11:24:35 <esteth> Cale: I can post the source in python that I have, if you'd like. I have a list of items to chose from, a number of items I can chose at this level of the recursion, and a maximum weight
11:24:46 <pacak> s
11:24:54 <monochrom> see also http://thread.gmane.org/gmane.comp.lang.haskell.cafe/25273/ and http://thread.gmane.org/gmane.comp.lang.haskell.cafe/26091/focus=26100
11:25:12 <Cale> I meant your unmemoised Haskell code, but that's actually enough information.
11:25:29 <djahandarie> @seen Twey
11:25:29 <lambdabot> Unknown command, try @list
11:25:29 <preflex>  Twey was last seen on ##javascript 1 day, 1 hour, 13 minutes and 9 seconds ago, saying: Apparently, image needs to be escaped in the Mozilla search bar o.@
11:25:38 <Cale> So what we want is a datastructure which can store every possible response to this function for varying parameters.
11:26:25 <Cale> esteth: So you have both a maximum number of items that you can choose, and a maximum weight?
11:26:28 <pozic> (and probably doesn't use a lot of memory)
11:26:48 <Cale> Well, it should be an infinite structure, but we're never going to use it all. :)
11:27:04 <esteth> the number of items is just an artefact of the way I implemented it. The problem doesn't have a limit on the number of items, only on the weight
11:27:09 <Cale> okay
11:28:20 <esteth> So some kind of infinite list of lists? or will lists mess up my complexity?
11:28:24 <Cale> Let's start with building a memo tree for a single positive integer.
11:28:36 <Cale> (or non-negative one, actually)
11:28:59 <monochrom> I timed list vs immutable array for this. list is faster.
11:29:25 <monochrom> but I'm invisible anyway.
11:29:46 <Cale> That is, imagine we have a function  f: Integer -> a  and we want to memoise it on nonnegative values by making a tree of all the possible results. We can binary encode non-negative Integer values, and use them as paths in a binary tree.
11:30:44 <esteth> That makes enough sense
11:32:41 <Cale> Anything that we can invent a binary encoding for can be memoised like that.
11:33:15 <ricree> if I have an IO do block that depends on functions that return Maybes, is there a good way to do it without lots of nested indentations from case blocks?
11:34:24 <Cale> esteth: Since we then have a constant tree value, as it's computed, so long as it remains in scope, it will be retained in memory, and we can look up the values (which will only be computed as they're needed)
11:35:30 <Cale> ricree: Well, you could use MaybeT, but that's usually a bit excessive.
11:35:58 <Cale> ricree: You can invent a combining function, perhaps something like...
11:36:14 <Cale> IO (Maybe a) -> IO b -> (a -> IO b) -> IO b
11:36:29 <Cale> But that won't really save you from indenting :)
11:37:35 <Cale> How do you want to handle the Nothing cases?
11:37:48 <pumpkin> error "SCREW YOU"
11:37:52 <pumpkin> seems reasonable
11:37:53 <esteth> Cale: That all makes sense, but how would you define the tree? Maybe I'm just being silly.
11:38:14 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
11:38:26 <Cale>   deriving (Eq, Ord, Show, Read)
11:39:13 <Cale> Now...
11:39:23 <Cale> memoTree :: (Integer -> a) -> Tree a
11:40:13 <Cale> actually...
11:40:14 <esteth> Right, the Tree structure was obvious enough, it's memoTree I was having difficulty with. 
11:40:18 <Cale> Let's do this in steps :)
11:40:26 <Cale> mapTree :: (a -> b) -> Tree a -> Tree b
11:40:34 <ricree> Cale: I basically just want it to be done doing IO.  This particular function starts with a wx file dialog, so if the dialog gives me Nothing, I don't want to do anything.  There's a handful of other similar cases later on
11:41:03 <Cale> mapTree f = g where g Tip = Tip; g (Branch x l r) = Branch (f x) (g l) (g r)
11:41:28 <Cale> numberTree :: Tree Integer
11:41:52 <ricree> I might just try breaking up the function some more.  It doesn't really attack the root of my problem, but it should at least help keep things readable
11:44:00 <esteth> Cale: Right. mapTree accepts a function from a -> b, and a tree of a, and gives me a tree of b's
11:44:40 <esteth> Isn't ricree's problem almost the definition of the problem MaybeT exists to solve? You want a sequence of computations in another monad, where if one fails, the whole series fails?
11:49:11 <Cale> okay, so we'll define a tree of positive Integers now:
11:49:23 <Cale> posTree = Branch 1 (mapTree (\n -> 2*n) posTree)
11:49:23 <Cale>                    (mapTree (\n -> 2*n + 1) posTree)
11:49:35 <Cale> and if we want things to start at 0...
11:49:45 <Cale> numberTree = map (subtract 1) posTree
11:50:03 <Cale> mapTree, rather
11:50:26 <Cale> We could also just have defined:
11:50:58 <Cale> numberTree = Branch 0 (mapTree (\n -> 2*n + 1) numberTree)
11:50:58 <Cale>                       (mapTree (\n -> 2*n + 2) numberTree)
11:51:19 <esteth> eek. My understanding just fell apart
11:51:47 <Cale> Well, we're just arranging natural numbers according to their binary encoding.
11:52:10 <Cale> So, look at posTree, I think it's the easiest to understand...
11:53:06 <esteth> so the left branch of posTree is postree itself, where each element is multiplied by two?
11:53:10 <Cale> yes
11:53:33 <esteth> Right, just got it
11:54:05 <Cale> lookupPath (Branch x l r) [] = x
11:54:05 <Cale> lookupPath (Branch x l r) (False:vs) = lookupPath l vs
11:54:05 <Cale> lookupPath (Branch x l r) (True :vs) = lookupPath r vs
11:54:36 <Cale> This function is really incomplete -- we're assuming that the tree is infinite here.
11:55:01 <Cale> (So we'll never run into a Tip)
11:55:08 <esteth> Yep
11:55:22 <Cale> (This will be the case for our Integer memo trees anyway)
11:55:40 <Cale> If you want to be safer, you might just remove the Tip case from the tree type altogether.
11:55:58 <esteth> it gets the number with binary encoding equal to the given list, so [true] is 1, [true, false] is 2, etc...
11:56:09 <esteth> I thought about that, if I'm only dealing with infinite trees anyway
11:56:57 <Cale> Well... there's an implicit 1 at the most significant bit of our expansion, with posTree. With numberTree, we've subtracted 1.
11:57:21 <Cale> ghci> lookupPath posTree [True, False]
11:57:22 <Cale> 5
11:57:35 <esteth> right
11:57:39 <Cale> (and with numberTree, that would be 4)
11:58:20 <Cale> So now we can map the function we want to memoise over numberTree to get an appropriate memo tree
11:58:31 <ymasory> how can i get my own personal lambdabot so i can do things like @src on my own computer?
11:58:46 <Cale> and we just need a function for converting numbers to appropriate lists of Boolean values to get the path to look down.
11:58:47 <nlogax> it's on hackage
11:59:04 <Cale> ymasory: @src is just using a text file
11:59:14 <Cale> ymasory: I could just give you that text file if you like
11:59:39 <esteth> Cale: Right, that makes perfect sense :)
11:59:52 <Cale> (It's not even the real source code in many cases)
12:00:30 <ymasory> Cale: what do you mean it's just using a text file?
12:01:41 <Cale> ymasory: I mean there's a text file in lambdabot's configuration directory on the server, and when you use @src foo, it just looks for an appropriate part of that text file (after a line with foo on it) and gives you that.
12:01:48 <monochrom> heh, disenchantment time
12:01:53 <esteth> Cale: Thanks for all the help! <3
12:02:12 <Cale> esteth: No problem... so now that you understand that, I can probably explain how data-memocombinators does it :)
12:02:57 <ymasory> thanks Cale
12:03:11 <Cale> esteth: It uses just one clever trick, but it's a really clever trick. :)
12:03:45 <Cale> So, let's ignore memoising integer functions for now, and just worry about functions of a boolean parameter.
12:04:03 <esteth> Right. f: Boolan -> a
12:04:11 <esteth> s/Boolan/Boolean
12:04:17 <Cale> The memocombinators library has a type synonym type: Memo a = forall r. (a -> r) -> (a -> r)
12:04:23 <Cale> er, tsk,
12:04:27 <Cale> type Memo a = forall r. (a -> r) -> (a -> r)
12:04:36 <Cale> (put the : in the wrong place)
12:05:07 <Cale> So, this means that a value of type  Memo a  is just a thing which transforms one function of a parameter of type a, to another (which is hopefully memoised somehow)
12:05:23 <esteth> Gotcha
12:05:27 <Cale> So, we're about to look at  Memo Bool
12:05:54 <Cale> bool g = cond (g True) (g False)
12:05:58 <Cale>   where
12:06:05 <Cale>     cond t f True = t
12:06:09 <Cale>     cond t f False = f
12:07:07 <esteth> right. It's an if-else statement, effectively
12:07:21 <esteth> oh wait
12:07:38 <Cale> So, the trick that's being used here is that lazy evaluation specifies that each parameter to a function is evaluated at most once.
12:07:59 <engla> ymasory: you can /query lambdabot  for private sessions
12:07:59 <Cale> So cond (g True) (g False)  is a function which does the same thing as g
12:08:24 <Cale> But, since (g True) and (g False) are parameters to cond, they'll be evaluated at most once, and retained.
12:08:52 <esteth> oh
12:08:58 <esteth> that's pretty clever
12:09:20 <Cale> Yeah
12:10:19 <Cale> A more elaborate version of this allows us to turn a memoiser for functions of one value into a memoiser for functions of lists of that type of value. The tree here is sort of implicit in the structure of the functions involved:
12:10:26 <Cale> list :: Memo a -> Memo [a]
12:10:27 <Cale> list m f = table (f []) (m (\x -> list m (f . (x:))))
12:10:29 <Cale>     where
12:10:31 <Cale>     table nil cons [] = nil
12:10:33 <Cale>     table nil cons (x:xs) = cons x xs
12:10:48 <Cale> But the trick is the same as the one for the Bool case
12:11:00 <Cale> We memoise what the function gives for an empty list
12:11:32 <Cale> and we memoise what it does for a nonempty list
12:12:54 <Cale> That's pretty subtle, but once we have that, the rest is pretty easy.
12:13:09 <Cale> Because now we have a way to memoise lists of boolean values
12:13:15 <esteth> mm, Think i've got it :)
12:13:21 <Cale> and so anything we can convert to binary strings is memoisable
12:13:24 <Kaidelong> g(f) = f(f) can't be typed in haskell it seems, how would you type it?
12:14:00 * tg_ types g(f) = f(f)
12:14:06 <tg_> and replies, using a keyboard
12:14:14 <Cale> Kaidelong: You need what are called equirecursive types to make that typecheck. Haskell has isorecursive types though (newtype), which you can use instead.
12:14:44 <mauke> > let g :: forall b. (forall a. a -> b) -> b; g f = f f in 42
12:14:44 <lambdabot>   42
12:15:12 <Cale> or you could make it so polymorphic that it doesn't matter ;)
12:15:38 <mauke> > let g :: forall b. (forall a. a -> b) -> b; g f = f f in g (const 42)
12:15:39 <lambdabot>   42
12:16:26 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
12:16:30 <Kaidelong> mauke: I was wondering what the type of functions that can be applied to themselves was, that looks like a workaround
12:16:51 <mauke> Cale's version is more precise
12:17:08 <jmcarthur> :k Mu
12:17:09 <lambdabot> (* -> *) -> *
12:17:14 <jmcarthur> :t Mu
12:17:15 <lambdabot> Not in scope: data constructor `Mu'
12:17:19 <jmcarthur> :t Fix
12:17:19 <lambdabot> Not in scope: data constructor `Fix'
12:17:23 <jmcarthur> what's the constructor?
12:17:25 <djahandarie> :t In
12:17:25 <jmcarthur> :t Roll
12:17:26 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
12:17:26 <lambdabot> Not in scope: data constructor `Roll'
12:17:28 <Cale> :t let g f = outR f f in g
12:17:29 <lambdabot> forall a. Rec a -> a
12:17:30 <jmcarthur> ah
12:17:46 <TheKingsRaven> Can you have thre functions where the output of A is the input to B & C and the output of B is the other input to C? Like (a -> b -> c) (f -> b -> a) (x -> y -> b)
12:17:50 <jmcarthur> ha, Roll would be quite wrong
12:17:52 <SuperDuper> hello, how can i convert integer to Data.ByteString.Lazy.UTF8 ? i know i can do fromString $ show somenumber but it just seems stupid
12:18:01 <TheKingsRaven> er pasted that out of order. 
12:18:24 <TheKingsRaven> I planned to say hello first, never mind.
12:18:37 <mauke> ap C B . A
12:18:55 <Cale> esteth: But in principle, data-memocombinators could also just have used an explicit tree. GHC tends to be better at optimising plain functions though, so there's probably an advantage to doing it the way that it does.
12:18:58 <ymasory> what is the result of a <- statement? i'm trying to understand why it can't be the final line of a do block
12:19:19 <jmcarthur> @djinn (a -> b) -> (b -> c) -> (b -> c -> d) -> a -> d
12:19:20 <lambdabot> f a b c d = c (a d) (b (a d))
12:19:20 <mauke> ymasory: there is no result because <- statements don't really exist
12:19:20 <Kaidelong> look how it gets translated
12:19:35 <jmcarthur> @. @pl @djinn (a -> b) -> (b -> c) -> (b -> c -> d) -> a -> d
12:19:35 <lambdabot> Plugin `compose' failed with: Unknown command: "@pl"
12:19:41 <jmcarthur> @. pl djinn (a -> b) -> (b -> c) -> (b -> c -> d) -> a -> d
12:19:41 <lambdabot> f = ap ((.) . flip . (ap .) . flip (.)) (flip (.))
12:19:41 <Cale> ymasory: do { v <- x ; <stmts> } translates to x >>= \v -> do { <stmts> }
12:19:43 <mauke> ymasory: do { v <- X; ... } is the same as X >>= \v -> do { ... }
12:19:46 <jmcarthur> yuck
12:19:48 <Kaidelong> <- just becomes a lambda expression
12:19:53 <esteth> ymasonry: a <- b translates to b >>= (\a -> ...) I think
12:20:11 <ymasory> i see, thanks everyone
12:20:24 <Kaidelong> haskell doesn't have any statements either
12:20:30 <Cale> Kaidelong: Yes it does ;)
12:20:39 <Cale> Kaidelong: The parts of a do-block are called statements
12:20:51 <Cale> (but apart from that, it doesn't ;)
12:20:56 <jmcarthur> Cale: but at least they desugar to expressions
12:20:59 <Cale> yeah
12:21:14 <djahandarie> Pretty pointless definition of statement really
12:21:27 <djahandarie> A statement which desugars to an expression is an expression in my book
12:21:35 <jmcarthur> the whole idea of do notation is to pretend to be an imperative language
12:21:42 <pumpkin> yo mama
12:22:16 * pumpkin is experimenting with a graph GADT!
12:22:38 <Saizan> :O
12:22:42 <jmcarthur> pumpkin: :o
12:22:46 <pumpkin> :o indeed!
12:22:51 <djahandarie> :o (For the dramatic effect)
12:22:55 <Cale> djahandarie: But the statements in a do block don't actually individually desugar into expression
12:22:56 <Cale> s
12:22:57 <pumpkin> THAT IS RIGHT
12:23:01 <jmcarthur> what invariants does the GADT guarantee?
12:23:09 <Cale> djahandarie: Only the whole do-block does.
12:23:12 <pumpkin> jmcarthur: usage invariants! :P
12:23:19 <jmcarthur> *sigh*
12:23:23 <pumpkin> lol
12:23:24 <Cale> (or final segments of it)
12:23:37 <pumpkin> jmcarthur: it's a way of annotating different representations of the graph based on what you need to do with it
12:24:08 <Cale> If they could desugar into expressions directly, then we probably wouldn't have do-notation at all.
12:24:09 <jmcarthur> pumpkin wins at being vague
12:24:31 <djahandarie> Cale, true. I guess the single lines could be considered statements. In the end the entire do block is translated into an expression though, so the statements don't exist for long
12:24:38 <Cale> Right
12:24:59 <Kaidelong> why can't you accumulate an expression over them statement by statement?
12:25:00 <pumpkin> jmcarthur: well, you specify (as a type) what you need to do (efficiently) with your graph (look up incoming edges, look up outgoing edges, modify edges, modify nodes, restructure the graph) 
12:25:02 <jmcarthur> do notation is an imperative language that gets compiled to haskell
12:25:05 <pumpkin> that's represented in the type
12:25:09 <Kaidelong> oh, context of the do block
12:25:11 <jmcarthur> pumpkin: ah!
12:25:14 <pumpkin> and there's a generic conversion function
12:25:20 <pumpkin> between the various underlying structures
12:25:23 <jmcarthur> pumpkin: so the types show you what operations will be efficient
12:25:26 <pumpkin> yep
12:25:31 <jmcarthur> nice
12:25:37 <djahandarie> pumpkin, I was working on reverse yesterday and having a hell of a time
12:25:56 <pumpkin> djahandarie: hah, did you figure it out? without all the shit I had in my SHE version
12:26:05 <djahandarie> Not yet
12:26:09 <djahandarie> I feel like I'm getting close though
12:26:24 <djahandarie> I keep on wanting to do dependently-typed things
12:26:27 <jmcarthur> i am taking a break from completely lazy evaluation to make a functor composition library
12:26:40 <pumpkin> jmcarthur: :O
12:26:58 <jmcarthur> it's mostly yak shaving :\
12:27:22 <jmcarthur> but i'm hoping to actually have monad composition on hackage soon
12:28:10 <sm> those yaks do get hairy!
12:28:20 <pumpkin> monad composition!
12:28:26 <pumpkin> how do you guarantee the result is a monad?
12:28:32 <jmcarthur> this might turn into a bit of a "transformer" library. i might make a module that provides transformers that internally just use my existing monad composition
12:29:02 <pumpkin> :o
12:29:17 <jmcarthur> pumpkin: there are a few type classes you can choose from to instantiate for various functors that gives you the ability to create different monads depending on what composition you use. those type classes have some laws on them
12:29:28 <pumpkin> ooh
12:29:47 <jmcarthur> pumpkin: http://web.cecs.pdx.edu/~mpj/pubs/composing.html
12:30:03 <pumpkin> ah, I'll check that out
12:30:09 <jmcarthur> pumpkin: i might have to create some new type classes though, unless i want to depend on category-extras or something...
12:30:15 <jmcarthur> like Pointed
12:30:28 <jmcarthur> is there a Pointed on hackage that doesn't come with category-extras baggage?
12:30:54 <rovar_> djahandarie,  I didn't mention the graph database thing yesterday, but it's good that there is interest.. i'll start mucking around with a prototype 
12:31:35 <jmcarthur> i also might want to have a CommutativeMonad type class (necessary to compose [] with commutative monads and yield well-behaved monads)
12:32:04 <jmcarthur> i'm not a big fan of how ListT works
12:35:59 <kmc> jmcarthur, would that differ from Monad concretely or only in the implicit laws?
12:41:33 <jmcarthur> kmc: it would just be in the implicit laws
12:41:50 <kmc> yeah
12:41:58 <kmc> it is nice to have the programmer certify in code that they've checked the laws
12:42:11 <jmcarthur> do { x <- a ; y <- b ; <stuff> }  =  do { y <- b ; x <- a ; <stuff> }
12:42:20 <kmc> there's some Movement in the Java world to have empty interfaces with meaningful names for this reason
12:42:26 <kmc> something oriented programming
12:42:44 <kmc> ah it's "Explicit Programming" i think
12:42:45 <dibblego> the Java guys do it at work, but only on gut instinct
12:42:47 <jmcarthur> why does programming have to be oriental?
12:43:22 <dibblego> unfortunately one of their laws is that "Optional" (Maybe) can only have two implementations, "Empty and Full"
12:43:34 <jmcarthur> :(
12:43:37 <kmc> jmcarthur, so "class (Monad m) => CommutativeMonad m" with no body?
12:43:43 <jmcarthur> kmc: yeah
12:43:45 <Twey> dibblego: Isn't that a Boolean?  :
12:43:51 <jmcarthur> kmc: unless you can think of a method that would be good to add to it
12:43:53 <dibblego> Twey, Maybe
12:43:57 <jmcarthur> i can't
12:44:03 <Twey> dibblego: They're missing FileNotFound
12:44:08 <dibblego> Twey, and that law is easily enforced in the Java type system
12:45:47 <Twey> Aye.
12:46:22 <dancor> is it possible to make a form of Data.Array.Repa that doesn't assume the elements are numeric?
12:46:58 <dancor> or is there a non-numeric multi-dimensional array lib with slicing?
12:49:27 <jmcarthur> dancor: Repa doesn't assume the elements are numeric anyway. you just have to make some crazy type class and data family instances
12:49:42 <jmcarthur> and i suspect the plan is to support more data types in the future
12:50:26 <dancor> jmcarthur: ya i wasn't sure if the Elt instance can be faked
12:51:12 <jmcarthur> dancor: i've written Elt instances, but it was a pain in the ass
12:51:32 <Guest86956> Hello, could someone explain to me when I should use let inside a do function en when to use <-?
12:51:53 <Guest86956> (I'm sorry; I am still new to Haskell)
12:51:55 <dancor> seems a bit low-level
12:52:04 <jmcarthur> dancor: it is
12:52:10 <mauke> Guest86956: IMHO you shouldn't use 'do' at all
12:52:28 <jmcarthur> ooh the tough treatment
12:52:34 <kmc> Guest86956, you use "<-" when you need to execute an action and get the result
12:52:41 <kmc> you use "let" when you are just naming a value without executing it
12:52:47 <Guest86956> Oh thanks kmc
12:52:56 <jmcarthur> i use do for IO, and sometimes for other types
12:53:03 <kmc> "let foo = getChar" does not get any char, it just makes a local alias for getChar
12:53:18 <Guest86956> Oh I see, thanks!
12:53:26 <dancor> i usually use do unless i'm golfing
12:53:28 <mauke> I seriously think not using 'do' makes things easier to understand
12:53:49 <Guest86956> but if I want to execute IO then I have to use do right?
12:53:54 <kmc> no
12:53:56 <jmcarthur> mauke: i agree... but sometimes it is nonetheless easier to *read* with do notation, especially when the idea is imperative like IO
12:54:01 <kmc> Guest86956, 'do' is just syntactic sugar
12:54:10 <Guest86956> oh?????? :|
12:54:11 <kmc> do { x <- a; b }  ===  a >>= (\x -> b)
12:54:18 <kmc> @undo do { x <- a; b }
12:54:18 <lambdabot> a >>= \ x -> b
12:54:39 <Guest86956> uhm, I actually don't understand that part...
12:54:47 <morricone> is there a help function for lamdabot?
12:54:53 <mauke> jmcarthur: this is just for learning, of course. you're free to use 'do' if you know what it does
12:54:56 <kmc> Guest86956, the core of IO is this operator (>>=).  "a >>= f" means "execute the action a, get the result x, apply the function (f x), and execute the action it returns"
12:54:59 <dancor> @help undo
12:55:00 <lambdabot> undo <expr>
12:55:00 <lambdabot> Translate do notation to Monad operators.
12:55:04 <kmc> that is, "a >>= f" is itself an action which does all that
12:55:15 <kmc> Guest86956, any Haskell tutorial should explain (>>=)
12:55:22 <jmcarthur> mauke: then we have no disagreement at all
12:55:29 <morricone> thx
12:55:34 <kmc> i try to write things points-free but if i have a lambda on the RHS of (>>=) then i think "do" is usually better
12:55:52 <Guest86956> @kmc okay thanks, I will try to read more... =)
12:55:52 <lambdabot> Maybe you meant: ghc rc src
12:56:16 <jmcarthur> kmc: that is also my main criterion
12:56:31 <jmcarthur> i hate using lambdas :)
12:56:35 <kmc> so for example "getChar >>= print" is valid because getChar is an action producing Char, and print is a function which takes that Char and returns another action
12:56:47 <Guest86956> oh I see...
12:56:55 <jmcarthur> i prefer the right-to-left combinators
12:56:58 <kmc> and that expression "getChar >>= print" is itself an action
12:57:04 <jmcarthur> but i won't try and confuse Guest86956 with them right now
12:57:18 <kmc> the only action which is ever actually executed is the one you name "main"
12:57:22 <kmc> or one you type at the ghci prompt
12:57:30 <Guest86956> I see
12:57:35 <kmc> but actions are values like any other, and so you can build them dynamically by calling functions etc.
12:59:01 <Guest86956> okay then for now I think I'm stuck with do until I dig a bit deeper XD, it's kind of hard to grasp atm.
13:01:50 <morricone> when is code.haskell.org supposed to be online again?
13:03:53 <conal> maybe we'd be less tempted to use "do" for non-imperative uses if we had monad comprehensions back.
13:04:37 <Cale> conal: I actually find that when list comprehensions get large enough, I turn them into do-notation.
13:04:39 * conal is cranky about the imperativeness of the word "do" in the general Monad setting
13:05:05 <Cale> I'd like to have both syntaxes
13:05:31 <Cale> It doesn't bother me so much that the keyword is 'do'. Every monad we can construct in Haskell has a computational interpretation.
13:05:45 <shachaf> Do monad comprehensions always have implicit return?
13:05:57 <aristid> shachaf: yes
13:06:02 <Cale> shachaf: Yeah, the part before the | is what's returned
13:06:13 <shachaf> That seems a bit unfortunate.
13:06:14 <conal> Cale: do you think of Maybe as *do*ing?
13:06:20 <Cale> conal: I can.
13:06:26 <kmc> Guest86956, do you understand first-class functions?  do you understand type classes?
13:06:38 <conal> Cale: sure, if you try. so can i.
13:06:52 <conal> Cale: or even think of "computation" (whatever that is) as *do*ing.
13:07:10 <Cale> conal: Usually in a setting where the Maybe monad is appropriate, it's not unnatural even.
13:07:27 <aristid> shachaf: well, it's not a real problem, because >>= return is id
13:07:33 <conal> Cale: honestly, aren't you rationalizing?
13:07:47 <kmc> Guest86956, you might like to read http://haskell.org/haskellwiki/Introduction_to_IO
13:07:52 <conal> Cale: i mean, don't you think "do" was chosen for the comfort of imperative programmers' thoughts?
13:07:56 <shachaf> aristid: What do you mean?
13:08:02 <pumpkin> is it possible to export only some methods of a typeclass?
13:08:03 <Cale> You have a chain of tasks which may or may not succeed.
13:08:07 <kmc> yes pumpkin 
13:08:10 <pumpkin> cool
13:08:10 <kmc> Data.Array.MArray does it iirc
13:08:18 <kmc> makes it hard to write instances externally
13:08:33 <aristid> shachaf: do a; b without a return at the end is the same as do a; x <- b; return x
13:08:37 <conal> Cale: "task" is a bit of a stretch (rationalization) for you, isn't it? it is for me.
13:08:45 <Cale> conal: Something had to be chosen. I can't really think of a better word.
13:08:52 <aristid> shachaf: and you can translate the latter directly into monad comprehension syntax
13:08:53 <Cale> Not really...
13:09:11 <conal> Cale: ah. that's a different matter (something had to be chosen).
13:09:14 <shachaf> aristid: Ah, fair enough. But it seems less natural.
13:09:19 <Cale> The example in my head right now is a chain of lookups.
13:09:22 <aristid> shachaf: then use do :)
13:09:30 <Cale> :t lookup
13:09:31 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:09:34 <Cale> ^^ those
13:09:44 <shachaf> > concat [[x,y] | x <- [1,2], y <- [3,4]]
13:09:44 <lambdabot>   [1,3,1,4,2,3,2,4]
13:09:50 <Cale> Where the result of previous lookups are being used to compute future ones.
13:10:22 <conal> Cale: sure. a chain. but overlaying the notion of "task" is what surprises me. one could overlay that notion onto everything mathematical/functional/denotative if one wanted. i just wouldn't expect that overlay anywhere but in a rationalization.
13:10:35 <aristid> > [z | x <- [1,2], y <- [3,4], z <- [x,y]]
13:10:36 <lambdabot>   [1,3,1,4,2,3,2,4]
13:10:39 <aristid> shachaf: :)
13:10:47 <conal> just to be clear, by "rationalization", i mean a way to hold onto a belief/practice rather than to arrive at one.
13:10:52 <Cale> It's sort of an empty word.
13:11:08 <Cale> Every expression is operationally a task.
13:11:10 <shachaf> aristid: An extra name? That cost is too high to bear.
13:11:23 <conal> Cale: operationally.
13:11:24 <aristid> shachaf: ok i guess using join is easier
13:11:30 <aristid> shachaf: but i would simply use do-syntax
13:11:36 <shachaf> I suppose.
13:11:46 <conal> Cale: which is another matter as well.
13:11:54 <Cale> What word would you have chosen?
13:11:59 <Cale> bind?
13:12:09 <Cale> Even that's a verb :)
13:12:20 <conal> Cale: yeah. watch out for verbs!
13:12:22 <conal> :)
13:12:23 <shapr> Cale: What's the definition of the swing function?
13:12:28 <aristid> conal: i think do is good because it means almost nothing :)
13:12:30 <Cale> But verbs are all nouns anyway.
13:12:37 <jmcarthur> i would have said function
13:12:50 <conal> aristid: and what it does mean is at odds with the heart of our programming paradigm.
13:13:01 <djahandarie> 'desugar' ;)
13:13:10 <aristid> conal: hmm. how about "combine"?
13:13:16 <Cale> swing f c a = (f ($ a)) c
13:13:22 <conal> aristid: maybe.
13:13:49 <aristid> that's at least not a devastating "never", so i should be proud :D
13:13:58 <djahandarie> Stepping back for a second, having monad comprehensions back would be nice
13:14:04 <djahandarie> Although another confusing thing for learners
13:14:16 <aristid> :t let swing f c a = (f ($ a)) c in swing
13:14:16 <lambdabot> forall a b t t1. (((a -> b) -> b) -> t -> t1) -> t -> a -> t1
13:14:23 * shachaf thinks the [] syntax for monad comprehensions is pretty confusing.
13:14:33 <kmc> "sequence" or "chain"?
13:14:34 <Cale> Let's go with 'meow'. We're in a sense "conCATenating" these values, so to express it, we'll use meow syntax.
13:14:43 <kmc> haha
13:15:17 <aristid> @quote ennobunktor
13:15:17 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
13:15:29 <aristid> (no, i don't get tired of pulling that quote. ever.)
13:15:37 <conal> so, is there any word that captures what we really mean by "do" (which is not doing)? we can explore. i bet there's a lot of creativity & insight in this room.
13:16:01 <jmcarthur> i have no problem seeing a Maybe computation as a composition of functions which each may have nothing useful to return, and i think that aside from the terminology baggage do notation is a fine syntax for it
13:16:08 <conal> i guess we mean something like: here comes some monad sugar 
13:16:15 <aristid> sugar
13:16:18 <djahandarie> conal, hence 'desugar' :)
13:16:21 <djahandarie> Or sugar
13:16:29 <aristid> djahandarie: the "de" just makes it scary.
13:16:31 <conal> djahandarie: too general.
13:16:39 <aristid> the warm fuzzy things should not be made scarier
13:16:40 <kmc> would "proc" be better? it's already a GHC keyword ;)
13:16:43 <conal> djahandarie: since, it's a specific desugaring
13:16:44 <kmc> by the way, we get by without sugar for Applicative
13:16:49 <jmcarthur> do notation is like arrow notation without the right hand side. it should obviously be called "arro" ;)
13:17:03 <aristid> kmc: well, i think infix sugar for Applicative would be lovely
13:17:23 <Cale> There's another reason that I sort of don't mind 'do', and it has to do with the fact that we're in a Cartesian closed category and are using lambdas implicitly anyway. I don't associate abstract monads with "doing", but monads in Hask, sure.
13:18:11 <conal> sometimes two design bugs cancel out. another bug is the specialness/hardwiredness of monad sugar.
13:18:31 <jmcarthur> at least that can be mitigated with NoImplicitPrelude
13:18:36 <djahandarie> I wouldn't associate monads in Hask with 'doing' more than anything in Hask
13:18:42 <conal> maybe looking for a more general approach to sugar (macros) would lead to a better angle on "do".
13:18:51 <conal> djahandarie: exactly!
13:18:55 <Cale> It's a lot harder to say how, oh, the completion of a metric space functor has anything to do with "doing" in the same way...
13:19:26 <Cale> djahandarie: Well, sure.
13:19:50 * pumpkin stopped using GADTs and moved to data families
13:19:55 <conal> Cale: are your implicit lambdas operational ones? ie are you shifting to talking about implementation?
13:20:16 <conal> pumpkin: blog!
13:20:34 <conal> pumpkin: seriously. i'm curious about what you've been learning & playing with.
13:20:37 <djahandarie> pumpkin, for your graph thing, or just entirely? :P
13:20:38 <pumpkin> I keep meaning to set one up, but coding is more fun than setting up a blog (I don't mind writing as much)
13:20:42 <pumpkin> graph thing :P
13:20:49 <pumpkin> but I tend to use GADFs quite often too
13:20:53 <pumpkin> which is a big of a combo of both
13:21:02 <pumpkin> conal: I'll try to throw something together in the next couple of days :)
13:21:04 <Cale> Well, not really. In order to define >>= and thus any analogue to do-notation, we need the category to be Cartesian closed
13:21:20 <conal> pumpkin: cool. i suspect you've discovered something i want to learn.
13:21:37 <pumpkin> let's hope so :)
13:21:54 <pumpkin> I have so many things I want to write about, but nowhere to write!
13:22:00 <pumpkin> man, life is tough
13:22:07 <pumpkin> I have most of it ready in hakyll
13:22:12 <pumpkin> just need to get over the final hump :P
13:22:37 <conal> pumpkin: i'm glad you're toying with hakyll. it intrigues me also.
13:23:06 <Cale> and the lambda calculus is really a notation for CCCs
13:23:09 <pumpkin> what I'm doing now is an exercise in combinatorics
13:24:48 <jmcarthur> Cale: why is a CCC associated with "doing"?
13:25:31 <djahandarie> Cale, wouldn't that mean like the category of small categories would also be 'doing'?
13:25:44 <Cale> djahandarie: In a funny way, yeah.
13:25:49 <conal> jmcarthur: that's what i'm wondering as well. (though 'how' rather than 'why')
13:26:34 <Cale> Whenever we have lambda calculus, we have beta equivalence, and that gives us a sort of operational reduction.
13:28:07 <djahandarie> I'm not really sure CCC is the problem abstraction to focus on
13:28:14 <djahandarie> Or if there is an abstraction that exists for 'doing' at all
13:28:19 <djahandarie> proper*
13:29:18 <jmcarthur> i'm not sure that i see how the existence of an operational semantics makes something inherently operational
13:29:43 <jmcarthur> or perhaps i am construing things into something you don't intend (the "inherently" part of that)
13:30:05 <Cale> Well, if we have some nice structure, we might as well take advantage.
13:30:31 <Cale> It's like, if you have a vector space, sure, you can forget that it's a vector space and call it a monoid or a set.
13:30:45 <Cale> But usually you wouldn't do that.
13:31:19 <Cale> An operational semantics is always in addition to whatever other structure we might have.
13:31:38 <monochrom> not sure it is not so much "doing" as "morphisms  certain objects"
13:31:45 <Cale> and basically amounts to imposing a direction on commuting polygons
13:32:08 <conal> Cale: i see how operational structure is handy to exploit for an implementation. less compelling to me as a means of characterizing a language itself.
13:32:12 <jmcarthur> i'm not good at seeing what amounts to an equivalence relation as "doing" though
13:32:38 <Cale> So that you don't just have some commutative triangle, you have a commutative triangle which is directed in one of two possible ways.
13:32:45 <conal> or a data type for that matter. i know i'm biased toward denotative. which is why i like functional programming.
13:33:23 <conal> i wonder sometimes how much my denotational bias blinds me to understanding other people's perspectives.
13:34:07 <Cale> I guess it's sort of like we have a 2-category where the Hom-categories are partial orders (or at least preorders)
13:34:14 <jmcarthur> any opinion has that effect
13:34:30 <djahandarie> I'd think most people in here are denotationally biased anyways, so you might just be compounding the problem by asking in here ;)
13:34:30 <conal> jmcarthur: i hope i'm not talking about opinion here.
13:34:39 <jmcarthur> conal: do you not see your bias as a kind of opinion?
13:34:40 <conal> jmcarthur: rather, a preference.
13:34:59 <conal> jmcarthur: no, i don't. i see it as a preference.  a focus.  an enjoyment.
13:35:28 <Cale> Oh, I guess there are two adjoints here...
13:35:37 <jmcarthur> conal: the definition of opinion i'm using is "a personal view, attitude, or appraisal"
13:35:51 <Cale> We can forget that the arrows have an evaluation map, but that's not quite what being denotational means.
13:36:06 <djahandarie> Cale, a hom category being a category that is determined by a pair of objects from a 2-category?
13:36:29 <jmcarthur> conal: okay, i see the distinction
13:36:33 <Cale> djahandarie: Yeah -- instead of sets of arrows between any pair of objects, you have a category of them
13:37:02 <conal> jmcarthur: view, attitude, or appraisal of what. that's a key question for me. if an appraisal of what's good, better, right/wrong, etc, ie *external* to myself, then i'd call it an opinion. and i have little use for them.
13:37:17 <mornfall> Hm. c.h.o broken again?
13:37:45 <conal> jmcarthur: didn't mean to beat a dead horse here. you probably already got what i meant.
13:37:52 <Cale> We want the other adjoint (I hope it's an adjunction), which is to treat equivalent arrows as lying over the same arrow in the denotational semantics.
13:38:36 <jmcarthur> conal: i'd say that a bias is a manifestation of an attitude/appraisal of something, even if it originally derives from mere preferences
13:38:39 <djahandarie> Cale, I understand all the terms here, but you've lost me. :P
13:39:08 <jmcarthur> at least if i'm understanding these definitions (which i'm looking up) conventionally
13:39:13 <Cale> That is, whenever there's a reduction (2-arrow) f => g, we want both f and g to be sent to the same arrow in our denotational semantics.
13:39:21 <conal> jmcarthur: could be i made a poor choice in "bias". maybe "focus" would have worked better.
13:40:13 <jmcarthur> that lines up more closely to your asertion of preference over opinion, i think, yes
13:40:18 <Cale> This might not be an adjunction... it's at least a functor. It's probably an adjunction if our language is strongly normalising or something.
13:40:18 <jmcarthur> *assertion
13:40:35 <conal> jmcarthur: i like to see how far the denotative perspective can go. and the best way i know how to find out is to stick with it, and resist temptations to take operational ways out. which is what i dislike about IO -- it's such an easy out.
13:42:09 <conal> jmcarthur: in contrast, the strength of the old Stream I/O model was its awkwardness. a thorn in the flesh. a constant reminder to keep looking for something better.
13:42:54 <jmcarthur> conal: i like the attitude that IO is a "sin bin" for precisely that reason
13:43:02 <conal> jmcarthur: in contrast, monadic IO is comfortable without answering the original question of how to relate to I/O denotatively.
13:43:11 <jmcarthur> and it's why i like to call it that even as i use it in my own code
13:43:15 <conal> jmcarthur: for which reason?
13:43:15 <Cale> If you take the ordinary arrows in the 2-category (the objects of the Hom categories) to be expressions in the language, and the arrows between them to be reduction steps, then I think it works :)
13:43:28 <byorgey> mornfall: seems so
13:43:35 <jmcarthur> conal: it makes it feel like something i want to minimize using
13:44:02 <conal> jmcarthur: ah yeah. for me too. it's an admission that for this part of my code, i don't know what i'm talking about. i'm not on firm denotative ground.
13:44:14 <conal> jmcarthur: ooh! we could rename "IO" to "Sin".
13:44:19 <Cale> I wonder if other people have looked at operational semantics in this way...
13:44:23 <Cale> It seems pretty natural.
13:44:28 <jmcarthur> conal: i've already done that in a few toy projects :)
13:44:53 <byorgey> conal++   -- renaming IO to Sin =)
13:45:01 <conal> jmcarthur: :) !  a humble reminder of where we are and that we're striving for something better.
13:45:05 <conal> byorgey: :D
13:45:19 <Cale> The syntax of your language is expressed by arrows in some free category that then gets extended to a 2-category whose second level of arrows express possible reductions or equivalences.
13:45:41 * jmcarthur washes his sin away in the blood of denotative programming
13:46:04 * conal passes the wafers around
13:47:39 <jmcarthur> come to think of it, we do use IO for a lot more than just I/O
13:47:47 <jmcarthur> IO is misnamed anyway
13:47:54 <conal> jmcarthur: totally! it's a big bin
13:47:57 <Cale> Do we?
13:48:26 <Cale> We certainly *can* use IO for more than I/O.
13:48:28 <jmcarthur> Cale: of course we could define I/O however we want, but i don't really see how IORef has anything to do with I/O, for example
13:48:34 <Cale> I'm not sure if we actually do.
13:49:01 <pumpkin> concurrency isn't necessarily IO either
13:49:36 <Cale> I suppose we could introduce another monad for concurrency together with a projection down to IO.
13:49:53 <aristid> Cale: a monad transformer
13:49:56 <Cale> Though there's not much point in concurrency without IO
13:50:02 <aristid> sure is
13:50:04 <kmc> but we already have pure parallelism
13:50:06 <aristid> `par`
13:50:12 <kmc> aristid, that's not concurrency
13:50:17 <dancor> there is STRef
13:50:19 <Cale> The only point of concurrency without IO is to get parallelism, and we have other ways to express that.
13:50:20 <kmc> (it is in the implementation, but not visible to users)
13:50:35 <aristid> kmc: uh, i don't really know the difference between those words
13:50:36 <jmcarthur> a lot of the FFI is only I/O from certain points of view (pointer dereferencing, allocation, etc.)
13:50:46 <pumpkin> there's a case to be made for concurrency minus IO with mutability
13:50:53 <kmc> aristid, concurrency refers to the *semantics* of multiple things happening at once
13:51:05 <kmc> parallelism is an implementation strategy for using multiple computation units
13:51:08 <pumpkin> mutability gives you shared state, maybe message passing
13:51:15 <edlinde> on the ghci prompt, if I wanted the output of a function to be stored in a variable ... how do I do this?
13:51:17 <kmc> par gives you parallelism without visible concurrency -- the semantics are unchanged
13:51:20 <aristid> kmc: ok, then pure concurrency makes no sense
13:51:26 <sipa1024> edlinde: let x = 5*3
13:51:27 <kmc> forkIO gives you concurrency without parallelism, if you have a single core box
13:51:27 <pumpkin> then your concurrent monad (that only does concurrency primitives and communication) can be projected to IO
13:51:38 <edlinde> thanks sipa1024 
13:51:41 <aristid> kmc: or wait. is unamb something like pure concurrency?
13:51:57 <Cale> aristid: The difference between concurrency and parallelism is a bit like the difference between having multiple queues in front of a counter at a fast-food restaurant, and having multiple workers behind the counter.
13:52:01 <kmc> aristid, no, it has deterministic semantics
13:52:06 <jmcarthur> forkIO gives you interleaving if you only have one OS thread, actually. that's concurrency if you squint
13:52:08 <kmc> assuming you meet the precondition
13:52:29 <Cale> With multiple queues in front of the counter, people might get served in a different order
13:52:34 <aristid> kmc: there's no way to implement unamb without parallelism/concurrency/no-idea-which-word-to-use
13:52:50 <kmc> aristid, sure, but we were talking about APIs and semantics, not implementation
13:52:51 <Cale> With multiple workers behind the counter, people get served faster, but in the same order.
13:53:03 <jmcarthur> aristid: i wouldn't say that at all
13:53:03 <kmc> there's also no way to implement par on UNIX without concurrency, but as the programmer we usually shouldn't care
13:53:10 <kmc> that's hidden by the RTS
13:53:12 <mornfall> They broke the internet. :(
13:53:27 <aristid> kmc: but you normally get the same semantics with par as without
13:53:52 <kmc> yeah
13:53:54 <aristid> mornfall: NOOO
13:53:55 <jmcarthur> aristid: as an example, there could be an implementation which simply interleaves the reduction of both arguments. that is neither concurrency nor parallelism
13:53:57 <kmc> unamb is different from par in this way
13:54:13 <aristid> jmcarthur: i think that is concurrency :)
13:54:14 <kmc> unamb has somewhat magical semantics, but they are not the semantics of communicating concurrent processes
13:54:14 <mornfall> Oh. It's just c.h.o's httpd that went nuts. I can ssh there.
13:54:23 <jmcarthur> aristid: it's not observable, so it's not concurrency
13:54:42 <aristid> jmcarthur: this is confusing :P
13:55:02 <jmcarthur> aristid: concurrency is not semantics preserving. that's the entire point of concurrency, in fact
13:55:04 <mornfall> Igloo: Do you have restart rights on c.h.o's httpd?
13:55:26 <Cale> http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.115.6107&rep=rep1&type=pdf -- it seems that someone else *did* have my idea :)
13:55:27 <kmc> aristid, put it this way: we could modify GHC to allow pattern-matching against , and then implement unamb without using concurrency
13:55:28 <aristid> jmcarthur: unamb creates new semantics, too
13:55:30 * hackagebot split 0.1.2.2 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.2.2 (BrentYorgey)
13:55:43 <kmc> implementing that pattern-matching construct would require concurrency in the RTS, as does implementing par
13:55:47 <jmcarthur> aristid: i tend to think of concurrency as being an abstraction that allows you to write multiple agents in a single system
13:55:50 <Cale> (and took it a bit further)
13:56:00 <jmcarthur> aristid: unamb doesn't introduce multiple agents as far as i'm aware
13:56:08 <Cale> That's good, because it's an obvious idea. I would hope that someone else would have thought of it :)
13:56:09 <aristid> hmm
13:56:17 <aristid> parallel pattern matching, interesting
13:56:50 <Cale> Well, implementing par could be done using only parallelism in the RTS, but then...
13:57:02 <kmc> Cale, chicken and egg? ;)
13:57:08 <Cale> Yeah :)
13:57:34 <Cale> multiprocessors ultimately implement parallelism in nondeterministic concurrent way
13:57:50 <Cale> But maybe our hardware design could be better :)
13:57:58 <kmc> they implement some pure parallelism too
13:57:58 <Roklobsta> unless syncronised
13:58:08 <kmc> hmm, i think out of order execution is a good example of pure parallelism
13:58:12 <Cale> (still, probably going to be some concurrency at the level of physics :)
13:58:25 <kmc> because it's invisible at the machine code level
13:58:32 <Cale> yeah
13:58:37 <_Cactus_> hi
13:58:44 <Adamant> yeah, but OOO has run out of steam
13:58:44 <Cale> In fact, that's exactly what it is
13:58:59 <Adamant> which is why we have to get explicit at this point
13:59:14 <Cale> Maybe we could pump some more steam into OOE by adding explicit pure parallelism to our instruction set somehow.
13:59:21 <kmc> Cale, sounds like VLIW
13:59:53 <Adamant> VLIW tends to only survive as an internal format
13:59:58 <Adamant> for a processor
14:00:37 <Ke> radeonHD is vliw
14:00:47 <Ke> so it is very much alive
14:00:51 <Adamant> ah, GPUs are an exception though
14:00:53 <Cale> Hello _Cactus_
14:01:04 <Adamant> they can yoink around the ISA for those much much more
14:01:44 <kmc> Adamant, and even the high-level language... half of GLSL will just mysteriously fail on any given GPU
14:01:59 <kmc> maybe it's better now, i last did serious GPU programming in 2007
14:02:33 <Roklobsta> ti dsp are vliw
14:02:39 <conal> in the 1980s, warren burton did some wonderful exploration of how to harness parallelism while protecting the semantics of the nondeterminism of scheduling. i think he used a phrase something like "indeterminate behavior with determinate semantics".
14:03:15 <_Cactus_> I need help with doing IO via lazy bytestrings
14:03:28 <jmcarthur> _Cactus_: just ask your question :)
14:03:43 <conal> i bet now is a great time for a revival of warren burton's ideas.
14:03:56 <jmcarthur> i'm not sure i'm familiar with this
14:04:24 <Roklobsta> i wonder what sort of cpu architecture could be designed that is better suited for pure functional langs.
14:04:28 <conal> jmcarthur: "improving values" was one of the pieces.
14:04:39 <jmcarthur> Roklobsta: well, there's the Reduceron
14:04:54 <Roklobsta> transputer?
14:04:55 <_Cactus_> here's what I do: I open a zip file with Codec.Archive.LibZip.withAchive, then select a large number of files from the archive and load them into [Word8]s using LibZip's fileContents. I then create lazy bytestrings from these files because I'm reading them via Data.Binary.
14:05:15 <mornfall> Gosh. Cabal, I hate you.
14:05:25 <mornfall> Why you force base 3 on me? Why oh why...
14:05:27 <_Cactus_> the problem is it leaks huge amounts of space, I guess it's too lazy
14:05:54 <_Cactus_> the actual code is in http://github.com/gergoerdi/language-java-classfile in two modules
14:06:42 <jmcarthur> _Cactus_: what functions should i look for?
14:06:53 <conal> in the 1980s, FP researchers were looking at some wonderful questions, including functional operating systems and functional I/O (not just avoiding the questions as in monadic IO).
14:07:08 <jmcarthur> oh nevermind, i looked in the wrong file
14:07:14 <conal> i gather there were high expectations (hype) and corresponding disappointment.
14:07:20 <_Cactus_> jmcarthur: testJar in Main.hs and parseClasses in Language/Java/Classfile.hs
14:07:57 <Adamant> Roklobsta: I suspect that's a path not worth bothering with
14:08:19 <Adamant> given the expense of designed new CPUs and GPUs and getting them into production
14:08:31 <Adamant> this is why they don't make new Lisp Machines.
14:08:35 <Roklobsta> adamant: what do you mean?
14:08:39 <_Cactus_> jmcarthur: getClass_ does some funky knot-tying, that's why it needs all the bytestrings together
14:08:54 <Roklobsta> oh.  off the top of my head i was thinking gpu or fpga for modern times.
14:09:14 <Adamant> Roklobsta: it costs literally billions to get a new CPU or GPU design to market, which means that it has to be reasonably general
14:09:17 <jmcarthur> _Cactus_: have you tried heap profiling?
14:09:36 <_Cactus_> jmcarthur: I wouldn't know where to start, tbh
14:09:44 <Adamant> and not overly optimized for a particular language group, beyond those language groups that most of it's current work in being done in
14:10:08 <jmcarthur> _Cactus_: http://book.realworldhaskell.org/read/profiling-and-optimization.html  http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/prof-heap.html
14:10:17 <edlinde> can someone give me an idea for a function that does string splitting permutations like
14:10:19 <edlinde> perm "bell"
14:10:19 <edlinde> [("","bell"),("b","ell"),("be","ll"),("bel","l"),("bell","")]
14:10:19 <Roklobsta> adamant: i know.  i recall seeing photos of the 'supercomputer' nvidia uses to verify their designs.
14:10:54 <edlinde> I want to be able to list all different ways of splitting a string.. what should I be looking at? any suggestions? Can this be done with a list comprehension?
14:11:37 <Adamant> given how inefficient FPGA's inherently are compared to ASICs, you tend to lose all your gains from clever implementations
14:11:42 <edlinde> i don't need the code, just some tips :)
14:11:46 <bos> edlinde: tails
14:11:47 <Adamant> as well
14:11:52 <bos> > tails "pants"
14:11:52 <lambdabot>   ["pants","ants","nts","ts","s",""]
14:11:56 <_Cactus_> jmcarthur: will profiling work if I have to kill the program because it's eating up all my memory?
14:12:05 <bos> edlinde: very similar to what you need
14:12:14 <_Cactus_> jmcarthur: or should I do the profiling wih a much smaller .jar file?
14:12:16 <hpc> perm = heads &&& tails?
14:12:16 <shachaf> > liftM2 zip inits tails "bell"
14:12:16 <Roklobsta> adamant: but it won't cost billions and billions (apologies to carl sagan)
14:12:17 <lambdabot>   [("","bell"),("b","ell"),("be","ll"),("bel","l"),("bell","")]
14:12:19 <jmcarthur> _Cactus_: i'm not sure. you could try reducing the size of the problem if it doesn't work
14:12:24 <hpc> ah, or that
14:12:33 <hpc> :t heads &&& tails
14:12:34 <lambdabot> Not in scope: `heads'
14:12:40 <hpc> :t inits &&& tails
14:12:41 <lambdabot> forall a. [a] -> ([[a]], [[a]])
14:12:41 <bos> inits
14:12:44 <jmcarthur> _Cactus_: or you could pass some RTS flags to make it bail out if it runs out of heap
14:12:52 <jmcarthur> (limit your heap size, i mean)
14:12:56 <Adamant> Roklobsta: truth. as a project it's totally fun, I bet. if you want it manufactured, though, designing one is not your main problem
14:13:12 <edlinde> shachaf: did your solution work with lambda bot?
14:13:24 <shachaf> edlinde: What do you mean?
14:13:47 <edlinde> this --> lambdabot:   [("","bell"),("b","ell"),("be","ll"),("bel","l"),("bell","")]
14:14:09 <edlinde> whats liftM2
14:14:13 <shachaf> edlinde: Yes, that was the response to my "> " line.
14:14:18 <shachaf> @ty liftM2
14:14:19 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:14:32 <edlinde> its a monad?
14:14:39 <shachaf> The (r ->) monad.
14:14:47 <edlinde> we haven't done those unfortunately :(
14:15:07 <edlinde> have to think of a non-monad solution
14:15:09 <_Cactus_> jmcarthur: do I have to reinstall every cabal package so that they include profiling info?
14:15:14 <shachaf> edlinde: Don't worry, they're warm and fuzzy.
14:15:29 <shachaf> edlinde: And "zip", "inits", and "tails" are all the ingredients you need.
14:15:34 <Roklobsta> actually, i wonder how well haskell would work with one of these new fangled 8 core ti dsps with VLIW.
14:15:38 <Cale> edlinde: He only used liftM2 in an innocuous way, you can just use lambda
14:15:39 <jmcarthur> _Cactus_: eek. yeah, that's the only way it will work. in the future you can arrange for cabal to always install those by default by modifying your .cabal/config file
14:15:52 <Cale> liftM2 f g h x = f (g x) (h x)
14:16:03 <edlinde> shachaf: thanks .. will look into it
14:16:04 <shachaf> edlinde: Is this homework?
14:16:19 <edlinde> shachaf: yeah thats why I want to try it out a bit
14:16:23 <Guest86956> I have another question, but this is kind of nooby. I got something like this: Position {px = someFloat, py = someFloat}, how can I actually construct Position? because Position {px = 3.0, py = 2.0} doesn't work
14:16:29 <edlinde> shachaf: don't know haskell enough though
14:16:35 <kmc> Guest86956, "doesn't work"?
14:16:38 <kmc> what does it do
14:16:43 <Roklobsta> homework?  does any uni actually teach haskell?
14:16:46 <kmc> Roklobsta, i doubt general purpose Haskell code would translate nicely to DSP.  it might be a wicked backend for Repa or DPH, though
14:16:56 <Guest86956> well actually I want to create a Position type
14:16:57 <Guest86956> value
14:16:59 <kmc> Roklobsta, lots of them teach it, some require it for intro CS students
14:17:03 <jmcarthur> Roklobsta: many do. especially the ones i didn't go to
14:17:18 <kmc> we've had a lot of people doing homework in here recently
14:17:32 <jmcarthur> i think a few teachers made their students aware of #haskell
14:17:37 <Roklobsta> hmmm. i wish i was a uni student now.  all i got in 1992 was a dose of Ada.
14:18:05 <kmc> Haskell was pretty young in 1992
14:18:06 <hpc> Roklobsta: no you don't; they use java now, and the ones that don't use python
14:18:09 <hpc> it's horrible
14:18:20 <kmc> yeah, pointers and recursion are now advanced graduate level topics ;P
14:18:27 <kmc> back in my day bitch whine moan
14:18:29 <shachaf> kmc: Weren't they using Miranda back then, though?
14:18:36 <jmcarthur> mine used C
14:18:37 <kmc> shachaf, fsvo "they"
14:18:58 <kmc> from what i can tell, Miranda was never 1/10 as popular as Haskell is today
14:18:59 <jmcarthur> and the engineering students did C++...
14:19:01 <hpc> CS has become an engineering degree now, i have found
14:19:13 <shachaf> kmc: Sure, but it was much more focused on education, wasn't it?
14:19:15 <hpc> it's like majoring in physics and being taught how to build a bridge
14:19:19 <jmcarthur> hpc: software engineering, mainly. :(
14:19:20 <_Cactus_> jmcarthur: I think what would work is if every bytestring was parsed one by one first, i.e. all the Data.Binary.Get stuff would run in sequence, thus, only one bytestring is "live" at any one time. The knot-tying is then done after the zipfile is closed.
14:19:31 <_Cactus_> jmcarthur: the only question is, how do I force this order of execution?
14:19:46 <kmc> hpc, yeah, and software engineering in industry is mostly about memorizing workarounds for Java and C++ design flaws
14:19:58 <sshc> What should I add to the .cabal file if I use .hs-boot files?
14:20:10 <jmcarthur> _Cactus_: i'm sorry, i didn't look so deeply at your code after i saw all the parsing stuff. i don't really feel like analyzing it that deeply right now
14:20:26 <hpc> kmc: it's gotten to the point where i try and mention CS being not sciency enough, and they don't know what the hell i am talking about
14:20:37 <hpc> kmc: all they know is that CS is where they learn to engineer software
14:20:40 <_Cactus_> jmcarthur: yeah, I should probably write a smaller version that doesn't do any actual parsing
14:20:57 * hpc feels so alone at this huge uni
14:21:05 <kmc> hpc, transfer to a small uni then
14:21:17 <jmcarthur> hpc: CS is what you go into to get a programming job, duh
14:21:19 <hpc> kmc: then there's even fewer people :P
14:21:31 <_Cactus_> jmcarthur: but you can probably skip straight to line #367 and not miss much:)
14:21:36 <hpc> and less probability of finding someone who understands CS how it should be
14:21:40 <sipa1024> hpc: "computer science is as much about computers as astronomy is about telescope" ... it may have been true in Dijkstra's time, but it's not anymore :)
14:22:03 <hpc> i am actually tempted to switch my major to math
14:22:12 <jmcarthur> sipa1024: i prefer Dijkstra's view
14:22:20 <sipa1024> so do i
14:22:31 <sipa1024> the rest is software engineering
14:22:35 <Roklobsta> hpc: they'll just make you do everything in matlab.
14:22:39 <tomh> hey guys, do you typically add type signatures to your haskell code?
14:22:43 <hpc> Roklobsta: oh god no
14:22:47 <jmcarthur> tomh: always
14:22:52 <jmcarthur> tomh: it's great documentation
14:22:59 <hpc> tomh: always
14:23:13 <Roklobsta> hpc: or fortran if your math lecturers are geriatric enough.
14:23:15 <sipa1024> but my university calls it computer science, but it's really mostly software engineering
14:23:18 <jmcarthur> tomh: it also helps you make sure you're getting what you meant to write
14:23:21 <Roklobsta> hpc: my numerical analysis course was fortran based.
14:23:26 <sshc> What should I add to the .cabal file if I use .hs-boot files?
14:23:26 <tomh> ok
14:23:32 <hpc> it's also a nice way to ensure you don't go crazy with types
14:23:40 <tomh> I was just wondering, in the f# community they don't seem to do it
14:23:53 <hpc> if a type is too painful to type, simplify it somehow
14:23:56 <hpc> case in point:
14:23:58 <hpc> :t (=~)
14:24:00 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
14:24:08 <tomh> O_o
14:24:11 <jmcarthur> what's that package with the insane types?
14:24:23 <hpc> F# isn't that great a language
14:24:38 <hpc> it's like Haskell minus the good parts
14:24:50 <tomh> lots of languages are haskell minus the good parts :)
14:25:03 <tomh> but yeah, there are more jobs available for f# programmers I guess
14:25:19 <Roklobsta> like python is a haskell monad
14:25:32 <kmc> jmcarthur, session types?
14:25:38 <jmcarthur> ah, i think that's it
14:25:42 <kmc> fucking hate (=~)
14:25:56 <jmcarthur> http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
14:25:59 <sshc> What should I add to the .cabal file if I use .hs-boot files?  Other-Source-Files?
14:26:01 <hpc> kmc: even the implementation sucks
14:26:05 <jmcarthur> it hurts
14:26:12 <ddarius> Last I checked, software engineering wasn't about computers either.
14:26:28 <jmcarthur> tomh: don't have type signatures like these: http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
14:26:42 <hpc> kmc: annotate the type to one of String, (huge-ass tuple), [String], etc
14:26:47 <jmcarthur> ddarius: yeah, it's about paperwork ;)
14:27:00 * ddarius wouldn't actually assume that there are more F# jobs than Haskell jobs.
14:27:13 <Rembane> Isn't it about managing programmers?
14:27:14 * hpc would like to see a regex monad that works similarly to parsec
14:27:45 <tomh> damn awefull types, who made that :D
14:28:21 <jmcarthur> tomh: it says Matthew Sackman :P
14:28:52 <jmcarthur> tomh: from what i hear, the types are horrible but the API is otherwise fine
14:29:02 <jmcarthur> i've been too afraid to try it though
14:29:16 <edlinde> I tried something like " zip (inits x) (tails x)"
14:29:18 <edlinde> and it fails
14:29:24 <edlinde> but I don't see whats wrong with that
14:29:26 <Roklobsta> ok, i am standing at the edge of the haskell pool.  before i dive in, what is the best single reference/book/website to use to get started?
14:29:45 <edlinde> will paste the error I get
14:29:48 <tomh> ok
14:30:16 <hpc> @where lyah
14:30:16 <lambdabot> http://www.learnyouahaskell.com/
14:30:20 <hpc> Roklobsta: ^
14:30:23 <byorgey> Roklobsta: it depends on your background.  What other languages do you know best?  What sort of mathematical background do you have?
14:30:27 <edlinde> http://pastie.org/1293869
14:30:35 <byorgey> Roklobsta: and why do you want to learn Haskell?
14:31:09 <Roklobsta> i have an electronics eng degree but i have been an embedded (8bit/dsp) C monkey most of my career.  so OO languages have passed me by....
14:31:27 <byorgey> edlinde: weird.  Your definition of cuts is fine, looks like something is wrong with your installation
14:31:31 <Rembane> Roklobsta: http://book.realworldhaskell.org/
14:31:31 <hpc> yeah, start with learnyouahaskell
14:31:37 <hpc> or that
14:31:53 <edlinde> byorgey: I done an "import List" at the start
14:31:55 <kmc> Roklobsta, i won't recommend one single reference, look at LYAH and RWH and see which you like better
14:31:59 <kmc> they're very different in style and focus
14:32:03 <ddarius> Roklobsta: If you did want to do some OO and still wanted to target an embedded domain, the Virgil language looks interesting.
14:32:21 * kmc does AVR programming in C++
14:32:36 <edlinde> if not I get : Not in scope: `inits'
14:32:37 <kmc> though C++ is hardly an "OO language"
14:32:37 <Roklobsta> i want to learn haskell as something new to learn.  i only have time for one new lang at the moment.  java, .net etc are a turn off and i am sick of for loops.
14:32:42 <mornfall> Anyone knows what this means?
14:32:42 <mornfall>     xmonad-contrib-0.9.1-204b93d518e3f0da74022d739def0449 is unusable due to missing or recursive dependencies:
14:32:45 <byorgey> edlinde: how did you install GHC?  Did you install the Haskell Platform?  Or through your OS package manager? Or...?
14:32:48 <mornfall>       xmonad-0.9.1-3bcbf4b347f5d4374c3a98f9dfd2146e
14:32:51 <ddarius> If I wanted to get paid to do embedded programming using an OO language, C++ is what I'd use.
14:33:06 <mornfall> ghc-pkg check doesn't say anything (just succeeds).
14:33:11 <ddarius> Even if OO wasn't required, C++ or assembly is most likely what I'd use.
14:33:16 <kmc> Roklobsta, Haskell sounds right then.  it's *actually* different, not just new syntax for the same ideas
14:33:16 <djahandarie> Does lambdabot have TypeCompose?
14:33:19 <Roklobsta> ok, I'll get into LYAH and RWH.
14:33:19 <djahandarie> :t arZip
14:33:20 <lambdabot> Not in scope: `arZip'
14:33:29 <byorgey> djahandarie: I don't think so...
14:33:34 <ddarius> And we don't have for loops at all.
14:33:47 <edlinde> byorgey: to be honest I cannot remember how I did it... its on macosx
14:33:57 <edlinde> byorgey: you really think its something wrong with ghci
14:34:00 <kmc> there's parts of C++ that are "clearly an improvement on C" and others that are "useful in specific situations" and others that are "oh god what were they smoking"
14:34:01 <_Cactus_> jmcarthur: OK I finally got it recompiled with everything with profiling info
14:34:04 <edlinde> I can exit and try again
14:34:19 <ddarius> kmc: I agree
14:34:27 <Roklobsta> c++ isn't so hot for limited ROM systems.  Like 128K.  The last project I worked on stretched C enough as it is.
14:34:33 <byorgey> edlinde: it is definitely not anything wrong with your code.  it is failing to load a shared library.
14:34:54 <mornfall> Gosh. Removing the system-wide xmonad fixed the problem.
14:35:01 <mornfall> :(((
14:35:18 <kmc> Roklobsta, C++ code can be cleaner source than C without being any larger in binary image
14:35:22 <kmc> you just have to know what features to avoid
14:35:28 <kmc> there's no STL for avr-g++ anyway
14:35:41 <kmc> this is kinda OT so we can continue in #haskell-blah if you like
14:35:42 <edlinde> byorgey: so what do you suggest I do?
14:35:46 <Roklobsta> kmc: besides the compiler was only C (for an 8051)
14:36:02 <_Cactus_> jmcarthur: can you help me understanding the results?
14:36:18 <jmcarthur> _Cactus_: which profiling method did you use?
14:36:42 <_Cactus_> 'space profiling' from the RWH link you gave me
14:36:52 <_Cactus_> with a small input
14:36:54 <edlinde> byorgey: any ideas?
14:37:07 <jmcarthur> _Cactus_: using -hc, you mean?
14:37:07 <byorgey> edlinde: just a minute
14:37:15 <edlinde> byorgey: ok
14:37:22 <_Cactus_> jmcarthur: yes
14:37:43 <jmcarthur> _Cactus_: what do you see?
14:37:52 <_Cactus_> it shows huge amounts used by a mapM, the rest seems OK
14:38:24 <byorgey> edlinde: what version of ghc do you have?
14:38:30 <jmcarthur> _Cactus_: i assume you rebuilt everything with -prof -auto-all -caf-all ?
14:38:49 <edlinde> byorgey: is there a command to check?
14:38:57 <_Cactus_> jmcarthur: I changed cabal's default and reinstalled everything, hopefully that's enough
14:38:59 <byorgey> edlinde: just type  ghc --version  at the command prompt
14:39:22 <edlinde> byorgey: version 6.10.4
14:39:24 <jmcarthur> _Cactus_: i mean your code
14:39:33 <byorgey> edlinde: I found this: http://chukyohackers.blogspot.com/2010/03/mac-os-x-106-snow-leopardghc.html
14:39:38 <_Cactus_> jmcarthur: I've uploaded the .ps to http://gergo.erdi.hu/files/Main.ps
14:39:39 <_Cactus_> jmcarthur: yes
14:39:47 * jmcarthur downloads
14:39:52 <byorgey> edlinde: it's in Japanese, but if you scroll down you'll see some commands listed
14:39:59 <byorgey> edlinde: cd /Library/Frameworks/ ...
14:40:00 <byorgey> and so on
14:40:04 <_Cactus_> thanks
14:40:07 <byorgey> run those two commands and see if that fixes it =)
14:40:09 <MasseR> I have a function of type "ErrorT String IO String", and a method which returns Either String String, can I somehow get the inner Either to work like the outer ErrorT? (So that I won't have to case check for Left/Right values)
14:40:15 <edlinde> byorgey: is this the same lib that screwed up yeah?
14:40:18 <edlinde> the unix something
14:40:20 <MasseR> For example "liftIO $ try getLine"
14:40:21 <byorgey> yep
14:40:28 <byorgey> edlinde: I found it by Googling for your error message
14:40:32 <edlinde> ok
14:40:32 <jmcarthur> _Cactus_: can you link me to your code again?
14:40:32 <Roklobsta> kmc: i actaully want to write a server that monitors and interacts with up to several hundred computers running agents and have a web interface for it.  Haskell seems like a good a choice as any.
14:40:43 <_Cactus_> https://github.com/gergoerdi/language-java-classfile/blob/master/Main.hs
14:40:50 <_Cactus_> jmcarthur: I assume the mapM is the one in line 45
14:40:57 <kmc> that sounds good Roklobsta; you can spawn hundreds of thousands of threads in GHC Haskell no problem
14:41:39 <Twey> Threads  they're actually processes (but not OS threads, *or* processes)
14:41:58 <jmcarthur> _Cactus_: have you tried any of the other profiling methods mentioned in RWH?
14:42:06 <jmcarthur> _Cactus_: i'm curious what types and constructors are being allocated
14:42:15 <Twey> Erlang has a lot of stuff built in for that kind of thing, too (distributed Haskell isn't quite as nice yet, library-wise; whether it's worth it for the better language depends on you)
14:42:26 <jmcarthur> _Cactus_: but here's my suspicion:
14:42:52 <_Cactus_> jmcarthur: just a moment (it takes quiet a while to run it even on a 4-meg .jar file)
14:42:59 <jmcarthur> _Cactus_: that graph is shooting up at the very beginning. it looks like that filecontents action is strict IO. that means it's loading everything at once
14:43:16 <edlinde> byorgey: that seems to have worked! :)
14:43:20 <edlinde> thanks byorgey 
14:43:25 <byorgey> edlinde: hooray! glad I could help =)
14:43:29 <jmcarthur> _Cactus_: so what you will want to do is load each file from the archive one at a time and parse them separately
14:43:59 <jmcarthur> _Cactus_: this might be a good case for interleaved IO, like iteratee or enumerator. or you could just do it manually
14:44:26 <jmcarthur> _Cactus_: load and parse them one at a time, is what i mean
14:44:57 <_Cactus_> are you still interested in the cons grpah?
14:45:03 <_Cactus_> jmcarthur: I've uploaded the .ps to http://gergo.erdi.hu/files/Main-cons.ps
14:45:13 <jmcarthur> _Cactus_: i'll look, but i'm pretty sure about my judgement
14:45:21 <jmcarthur> _Cactus_: that spike is clearly before you have done any parsing
14:45:40 <_Cactus_> OK
14:46:19 <_Cactus_> can I still have the full list of all the bytestings at once?
14:46:54 <_Cactus_> since I don't need their actual content at once
14:47:06 <jmcarthur> _Cactus_: well, you could, but you'd need to use unsafeInterleaveIO
14:47:15 <jmcarthur> that's not my favorite way to do these things, but it's easy
14:47:33 <_Cactus_> jmcarthur: what would be the nicest way?
14:47:57 <jmcarthur> _Cactus_: streams <- mapM (unsafeInterleaveIO . fileContents []) classfiles     -- the easy way, which may be good enough
14:47:59 <_Cactus_> jmcarthur: the problem of course comes from that I can't call getClass for each file separately
14:48:17 <_Cactus_> but I'm interested in the nice way:)
14:48:29 <jmcarthur> _Cactus_: the harder but more controllable way is to interleave manually or to use something like iteratee or enumerator
14:49:13 <jmcarthur> _Cactus_: you could probably also save some memory by using a function that gives you a ByteString to begin with instead of [Word8], if you can find or write something like that
14:49:17 <_Cactus_> can I use iteratee/enumerator if the zip library's fileContents is strict, or would I need to change libzip as well?
14:49:24 <jmcarthur> _Cactus_: but the biggest problem there is preloading everything at once
14:49:49 <jmcarthur> _Cactus_: i think you could get away with a strict fileContents unless these are very large files
14:50:13 <jmcarthur> but i don't know
14:50:15 <jmcarthur> anyway i g2g
14:50:18 <jmcarthur> good luck
14:50:25 <_Cactus_> thanks for your help
14:50:27 <_Cactus_> bye
14:56:01 <sshc> http://hackage.haskell.org/package/OpenGL-2.4.0.1 reports that OpenGL 3.2 is supported, but http://hackage.haskell.org/packages/archive/OpenGL/2.4.0.1/doc/html/Graphics-Rendering-OpenGL.html only says that 2.1 is supported.  Which is it?
14:57:30 <jmcarthur> sshc: i'm pretty sure it's the former
14:58:05 <jmcarthur> sshc: i'd just make sure it has the functionality you need and not worry about the version number
14:58:43 <amalloy> silly question here: i'm not a haskeller, but i'm tweaking a tool that works with haskell code. what's the usual file extension for haskell programs?
14:58:52 <jmcarthur> amalloy: hs or lhs
14:59:03 <amalloy> jmcarthur: thanks
14:59:12 <jmcarthur> amalloy: there are also other variants though
14:59:16 <jmcarthur> amalloy: hsc, for example
14:59:53 <jmcarthur> amalloy: that one is for a certain preprocessor for writing bindings to C
15:00:13 <sm> MonadIO is now provided by mtl, mtl-tf, monadIO, and probably others, my app and libs are using different ones, and it's not working
15:00:42 <sm> I think I wish ghc could report the package of the types it's talking about in compile errors
15:01:16 <sm> eg in "No instance for (Control.Monad.IO.Class.MonadIO (InputT IO)) arising from a use of `liftIO'"
15:01:29 <aristid> sm: the one true MonadIO is in transformers
15:01:36 <aristid> sm: and mtl 2.0 imports transformers now
15:01:56 <aristid> monads-fd is also a stub for mtl 2.0 now
15:02:04 <sm> I've got that installed too. Ok thanks, I'll try to force everything in that direction
15:02:11 <aristid> :)
15:02:47 <sm> maybe what I need here is a mtl upgrade
15:02:53 <tomberek> any category theory / morphism artists out there?
15:03:03 <jmcarthur> artists, heh
15:03:09 <sm> or is that going to take me straight to hell ? guess we'll see
15:03:13 <tomberek> yeah, i checked edwardk, but no response
15:03:24 <aristid> tomberek: this place is where they hang out. but i'm not one of them :)
15:03:30 <jmcarthur> tomberek: i'm no category theory artist, but i'm curious about what you want to talk about
15:03:34 <aristid> preflex: seen edwardk
15:03:34 <preflex>  edwardk was last seen on #haskell 4 days, 5 minutes and 3 seconds ago, saying: actually i stand corrected. it was a reference to "legal stamps" =)
15:04:14 <tomberek> jmcarthur, I have an idea I've been thinking about, a fold that traverses a mutually recursive structure
15:04:30 <tomberek> then using ATs to generalize to more than 2
15:04:38 <jmcarthur> interesting
15:05:10 <jmcarthur> i suppose you're just wondering if there is a name for it?
15:05:16 <jmcarthur> i of course have no idea :)
15:05:35 <tomberek> well, i need some help putting the idea into proper words and into haskell
15:06:24 <jmcarthur> tomberek: how do you hope it will work? does it require some sort of Mu but for mutual recursion?
15:06:37 <tomberek> jmcarthur:  I am not well versed in Mu
15:06:51 <jmcarthur> :t In
15:06:52 <lambdabot> forall (f :: * -> *). f (Mu f) -> Mu f
15:07:51 <tomberek> jmcarthur: but the idea is a structure that looks like this.    A  then B then A then B  (eg: A set of lists of sets of lists)
15:08:31 <jmcarthur> tomberek: so something like  newtype Mutual f g = Mutual (f (Mutual g f))  ?
15:09:12 <tomberek> jmcarthur: um... perhaps, I'm not savy yet, so I don't know
15:09:22 <tomberek> how would that be used?
15:09:43 <jmcarthur> tomberek: that's essentially something like   Mututal f g = f . g . f . g . f . g . f . g ...
15:10:16 <jmcarthur> hmm... that notation shows me that it's the same as Mu (f . g)
15:10:35 <tomberek> hm.... perhaps if I explain the origin of the idea
15:11:11 <alpounet> hi people
15:11:27 <tomberek> jmcarthur: I was thinking about Graphs and FGL.  FGL uses a Context as the base unit of induction
15:11:34 <aristid> :t In IO
15:11:35 <lambdabot> Not in scope: data constructor `IO'
15:11:45 <aristid> :t In []
15:11:46 <lambdabot> Mu []
15:11:50 <aristid> > In []
15:11:51 <lambdabot>   In []
15:11:54 <aristid> hmmm
15:12:03 <jmcarthur> > In [In []]
15:12:04 <lambdabot>   In [In []]
15:12:12 <tomberek> jmcarthur: but, I was thinking of alternately dealing with Nodes and Edges
15:12:17 <alpounet> @src Mu
15:12:17 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
15:12:18 <jmcarthur> :t In [In []]
15:12:19 <lambdabot> Mu []
15:12:26 <jmcarthur> :t In [In [In []]]
15:12:27 <lambdabot> Mu []
15:12:29 <jmcarthur> :t In [In [In [In []]]]
15:12:29 <lambdabot> Mu []
15:12:36 <jmcarthur> tomberek: i see
15:12:45 <alpounet> :t fix In
15:12:46 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
15:12:46 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
15:12:46 <lambdabot>       Expected type: f (Mu f)
15:12:51 <alpounet> :t fix In []
15:12:52 <lambdabot>     Couldn't match kind `(* -> *) -> *' against `* -> *'
15:12:52 <lambdabot>     When matching the kinds of `Mu :: (* -> *) -> *' and `f :: * -> *'
15:12:52 <lambdabot>       Expected type: f (Mu f)
15:13:31 <jmcarthur> :t fix (In . [])
15:13:32 <lambdabot>     Couldn't match expected type `Mu f -> f (Mu f)'
15:13:32 <lambdabot>            against inferred type `[a]'
15:13:32 <lambdabot>     In the second argument of `(.)', namely `[]'
15:14:06 <tomberek> jmcarthur: then I though, what about something like data A = A Int B;   data B = B Double A
15:14:24 <tomberek> jmcarthur: or even extending it to have a repeating chain of three types
15:15:01 <alpounet> like cycle
15:15:03 <alpounet> but for types
15:15:07 <tomberek> yep
15:15:26 <tomberek> alpounet: I was thinking of a way to break out of the Context thinking
15:15:40 <alpounet> yeah
15:15:52 <alpounet> not very nice to use
15:16:05 <tomberek> keep alternating the 'type' of the induction/recursion
15:17:15 <aristid> :t In Just
15:17:16 <lambdabot>     Couldn't match expected type `Mu ((->) a)'
15:17:16 <lambdabot>            against inferred type `Maybe a'
15:17:16 <lambdabot>       Expected type: a -> Mu ((->) a)
15:17:28 <aristid> :t In Nothing
15:17:29 <lambdabot> Mu Maybe
15:17:33 <aristid> > In Nothing
15:17:34 <lambdabot>   In Nothing
15:17:35 <tomberek> jcmarthur: does that make sense?
15:17:41 <aristid> > In (Just 1)
15:17:42 <lambdabot>   No instance for (GHC.Num.Num (L.Mu Data.Maybe.Maybe))
15:17:42 <lambdabot>    arising from the l...
15:17:49 <aristid> > In (Just undefined)
15:17:50 <lambdabot>   In (Just (In *Exception: Prelude.undefined
15:17:59 <jmcarthur> tomberek: yeah, makes sense and sounds reasonable
15:18:10 <jmcarthur> tomberek: and you're just looking for the type of a fold over that?
15:18:10 <tomberek> alpounet: this sort of fold would allow for an easy way to express neural network evaluation
15:18:13 <aristid> > fix (In . Just)
15:18:14 <lambdabot>   In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (J...
15:18:26 <aristid> > fix (Just . In)
15:18:27 <lambdabot>   Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just (In (Just ...
15:18:37 <jmcarthur> aristid: Mu Maybe is basically lazy natural numbers :)
15:18:46 <tomberek> alpounet, and then applying a different one to 'reverse graph' would be back prop
15:18:59 <aristid> jmcarthur: similar to peano representation?
15:19:03 <jmcarthur> aristid: yeah
15:19:12 <alpounet> yeah aristid 
15:19:15 <alpounet> 'isomorphic'
15:19:16 <aristid> \o/
15:19:18 <jmcarthur> aristid: succ = In . Just ; zero = In Nothing
15:19:21 <alpounet> Nothing => zero
15:19:23 <alpounet> arg
15:19:26 <alpounet> jmcarthur's too fast
15:19:42 <jmcarthur> :t In Nothing
15:19:43 <lambdabot> Mu Maybe
15:19:45 <jmcarthur> :t In . Just
15:19:46 <lambdabot> Mu Maybe -> Mu Maybe
15:19:47 <alpounet> tomaw, that sounds really nice
15:19:54 <alpounet> tomberek*
15:20:02 <alpounet> but hm
15:20:05 <tomberek> it's just an idea i got while driving
15:20:08 <alpounet> how would you represent a graph with that ?
15:20:32 <aristid> in which module is Mu?
15:20:35 <aristid> @hoogle Mu
15:20:35 <lambdabot> Text.Html multiple :: HtmlAttr
15:20:35 <lambdabot> Text.XHtml.Frameset multiple :: HtmlAttr
15:20:35 <lambdabot> Text.XHtml.Strict multiple :: HtmlAttr
15:20:43 <aristid> lambdabot: no no, all wrong
15:20:45 <tomberek> alpounet: well, look at lists:   data List a = Empty | Cons a (List a)
15:20:57 <jmcarthur> it sounds like a graph zipper more than a graph :)
15:21:30 <ksf> tomberek, what about updates?
15:21:31 <tomberek> alpounet:  FGL is trying to work the    data Graph a b = Empty | Cons (Context a b) (Graph a b)
15:22:15 <jmcarthur> ksf: i suspect the idea is to have a somewhat comonadic use of this, so the structure wouldn't change
15:22:20 <tomberek> ksf: I would probably still use standard implementation,, this would just be an interface to write folds, refolds, etc
15:22:28 <ksf> ah.
15:22:45 <tomberek> ksf: that is also an idea, i currently use comonadic evaluation to do neural networks
15:23:46 <ksf> there's reason to use something different than IntMap as your backend when the code is finished, but not using IntMap in the beginning is premature optimisation.
15:23:50 <mreh> how could it be possible that my cabal project compiles and executes without a Main function
15:24:03 <edlinde> hi all, can someone please help me understand this solution
15:24:03 <edlinde> ablist = [ x ++ [y] | x <- "" : ablist, y <- [ 'a','b'] ]
15:24:07 <jmcarthur> mreh: ... and executes?
15:24:08 <ksf> with a main function in a Main module? 
15:24:10 <mreh> because it's compiling as if no changes were made to the project, and just returns immediately
15:24:24 <edlinde> *Main> take 10 ablist 
15:24:24 <edlinde> ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb"]
15:24:27 <ksf> messed mtimes?
15:24:28 <aavogt> is it a library?
15:24:48 <edlinde> I see how its generating an infinite list of "a" and "b" 
15:24:51 <mreh> I've specified a Main module, but it's not executing the contense
15:24:57 <mreh> it's an executable
15:25:26 <edlinde> why is there the  x <- "" : ablist?
15:25:33 <monochrom> I'm afraid you are not speaking coherently
15:25:38 <edlinde> I know the ablist is a recursive call to the function itself
15:25:40 <tomberek> ksf: the same way that FGL doesn't actually use the induction with Contexts, I wouldn't actually use this induction internally, it would be a way to think of folds differently,, but then I though of generalizing to mutually recursive structures
15:25:54 <edlinde> can someone just help me understand this please?
15:26:06 <mreh> I'm trying to work out why my changes aren't reflected in my compiled program
15:26:40 <monochrom> I see. perhaps clean and re-configure and re-build?
15:27:08 <monochrom> err, clean and re-configure and re-build and re-install, to be complete
15:27:12 <ksf> > take 10 $ map (flip (showIntAtBase 2 ("ab" !!)) "") [1..]
15:27:13 <lambdabot>   ["b","ba","bb","baa","bab","bba","bbb","baaa","baab","baba"]
15:27:22 <ksf> > take 10 $ map (flip (showIntAtBase 2 ("ba" !!)) "") [1..]
15:27:22 <lambdabot>   ["a","ab","aa","abb","aba","aab","aaa","abbb","abba","abab"]
15:27:57 <mreh> cleaning did the trick
15:28:00 <ksf> > take 10 $ map (flip (showIntAtBase 2 ("ab" !!)) "") [0..]
15:28:01 <lambdabot>   ["a","b","ba","bb","baa","bab","bba","bbb","baaa","baab"]
15:28:02 <mreh> strange bug
15:28:28 <mreh> we'll probably never get to the bottom of it
15:28:41 <ksf> well, your's is trinary, on close look.
15:29:40 <tomberek> alpounet: also, I'm not sure if we should go into this idea, but.....   With hypergraphs, the concept of nodes and edges are interchangeable. But even with that perspective, the concept still needs two types of things, where one points to the other, and vice versa
15:30:06 <nostard> can i exit an forM_ early or would i be better of with manual recursion?
15:30:28 <ksf> > let ablist = [ x ++ [y] | x <- ablist, y <- "ab" ] in take 10 ablist
15:30:30 <mreh> for is the same as map?
15:30:32 <lambdabot>   mueval-core: Time limit exceeded
15:30:36 <mreh> :t for
15:30:37 <lambdabot> Not in scope: `for'
15:30:38 <ksf> > let ablist = [ x ++ [y] | x <- "":ablist, y <- "ab" ] in take 10 ablist
15:30:39 <lambdabot>   ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb"]
15:30:44 <ksf> huh.
15:31:14 <ksf> ah.
15:31:49 * ksf hates list comprehensions
15:32:01 <aavogt> nostard: use ContT
15:32:17 <aavogt> I mean you can consider it
15:32:32 <mreh> :t replicate
15:32:33 <lambdabot> forall a. Int -> a -> [a]
15:32:33 <ksf> nostard, nope, you can't.
15:32:35 <ksf> :t forM
15:32:36 <aristid> > let ablist = do x <- "":ablist; y <- "ab"; return (x ++ [y]) in ablist
15:32:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
15:32:36 <alpounet> tomberek, i'm affraid that doesn't make it nicer to use for writing hnn next gen though :P
15:32:36 <lambdabot>   ["a","b","aa","ab","ba","bb","aaa","aab","aba","abb","baa","bab","bba","bbb...
15:32:45 <ksf> it always goes down the whole list.
15:32:45 <aristid> > let ablist = do x <- "":ablist; y <- "ab"; x ++ [y] in ablist
15:32:46 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
15:32:46 <lambdabot>         against inferred ty...
15:32:46 <mreh> :t replicateM 3 [a,b]
15:32:47 <lambdabot> [[Expr]]
15:32:47 <ksf> :t while
15:32:48 <lambdabot> Not in scope: `while'
15:32:50 <nostard> hehe, thanks. I will look into it =)
15:32:51 <ksf> :t whileM
15:32:52 <lambdabot> Not in scope: `whileM'
15:32:56 <nostard> ksf: thanks =)
15:33:00 <djahandarie> aristid, it isn't in a module, it's only defined by lambdabot
15:33:27 <tomberek> alpounet: not true,,   axon -> dendrite -> axon  etc
15:33:27 <aristid> djahandarie: there SHOULD be a module for something as fundamental :)
15:33:39 <ksf> I once wrote a function to emulate C's for, and it turned out to be a mess of references.
15:33:47 <alpounet> tomberek, i was talking about hypergraphs :p
15:33:52 <ksf> :t filterM
15:33:53 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
15:33:57 <djahandarie> aristid, well, there might be somewhere
15:34:09 <djahandarie> I don't think there is a module JUST for that of course
15:34:34 <ksf> you might want to do filterM foo xs >>= mapM bar
15:34:37 <ksf> :t mapM
15:34:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
15:34:47 <ksf> (that's just forM with arguments reversed)
15:35:03 <tomberek> alpounet: ah, we can start with hypergraphs defined in this more abstract way, then keep adding restrictions until we have normal graphs (sounds like constraint programming)
15:35:24 <ksf> nostard, or just use a pure filter, ymmv.
15:36:06 <alpounet> hm
15:36:20 <ksf> ghc will get rid of the intermediate list and fuse both functions into a loop.
15:36:51 <ksf> :t takeWhile
15:36:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:36:52 <nostard> ksf: i'm in ST, and for every x i want to either mutate an array or exit
15:36:57 <ksf> might be interesting, too.
15:37:21 <tomberek> alpounet: hence my need to get in touch with edward kmett and figure out a rigorous way to express this mutual recursion (or whatever it is)
15:38:07 <djahandarie> Other people in here know category theory / maths if you feel like asking
15:38:13 <ksf> nostard, well, get a list of all the elements, then cut the list off based on the element's values, then change the elements, then write the list back.
15:38:41 <aristid> tomberek: probably category-extras already contains your morphism ;)
15:39:07 <tomberek> djahandarie: I'm hoping someone overhears and can interject
15:39:16 <tomberek> @aristid : probably true
15:39:16 <lambdabot> Unknown command, try @list
15:39:17 <ksf> ...supposing that linear search is the fastest way to get to the crucial element.
15:40:04 <ksf> otoh, if you're just starting out with haskell, you shouldn't be using ST
15:40:13 <nostard> ksf: that won't work. I'm searching a list for duplicates. Because the elements are in a small range i can cross them of in an array. Whenever an element already has been crossed of there must be a duplicate.
15:40:27 <ksf> (unless you plan to forever use haskell as a glorified imperative language)
15:40:51 <ksf> @src nub
15:40:51 <lambdabot> nub = nubBy (==)
15:40:56 <ksf> @src nubBy
15:40:56 <lambdabot> nubBy eq []             =  []
15:40:56 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:41:03 <wferi> Hi! Do tuple sections exists, so that one can do map (1,) [2,3,4] => [(1,2),(1,3),(1,4)]?
15:41:12 <tomberek> @aristid : I did a quick look, and I think Control.Morphosm.Meta.Erwig might be it (promising because he wrote FGL)
15:41:12 <lambdabot> Unknown command, try @list
15:41:21 <jmcarthur> wferi: no, but you can say ((,) 1)
15:41:24 <Rembane> wferi: zip!
15:41:36 <tomberek> aristid: but I can't quickly decipher it
15:41:47 <jmcarthur> > zip (repeat 1) [2,3,4]
15:41:48 <lambdabot>   [(1,2),(1,3),(1,4)]
15:41:51 <ksf> ...that's utterly inefficient, there. the ghc prelude uses a sensible algorithm.
15:41:54 <jmcarthur> i actually prefer the map version to that ^^
15:42:00 <wferi> jmcarthur Rembane: thanks. :)
15:42:01 <aristid> tomberek: :)
15:42:06 <ksf> wferi, -XTupleSections
15:42:13 <jmcarthur> oh!
15:42:16 <wferi> hmm
15:42:17 <jmcarthur> i forgot that existed
15:42:26 <ksf> very sensible extension.
15:43:00 <wferi> I wonder why these were left out originally...
15:43:15 <wferi> even if one-tuples are missing
15:43:19 <ksf> too much time spend on discussing the lexical syntax of comments.
15:43:26 <wferi> :/
15:43:37 <nostard> ksf: i use Haskell because that's the language i prefer =). It's easy to first do something easy and later on improve the algoritms =)
15:44:02 <nostard> ksf: nub is a lot slower, so no =)
15:44:39 <ksf> well, then you probably want to use a recursion
15:44:56 <nostard> k. thanks =)
15:45:08 <nostard> or swtich to O'Caml? ;)
15:45:20 <ksf> ...because it's usually easier to do than figuring out a complex recursive case from the get-go.
15:45:38 <nostard> hehe
15:46:30 <ksf> ocaml, unlike haskell, is designed to make your life hard. just have a look at the syntax
15:46:34 <ksf> (/me is ranting)
15:46:40 <ksf> (otoh, I'm right)
15:47:38 <JohnnyL> > .4
15:47:39 <lambdabot>   <no location info>: parse error on input `.'
15:47:40 <JohnnyL> fail
15:48:00 <nostard> ksf: yeah, that's why i use Haskell, even though it might be less suited for imperative stuff
15:48:16 <aristid> JohnnyL: why? i mean . is more important as an operator than for floating point numbers that you're too lazy to begin with a 0
15:48:29 <kmc> haskell is a good imperative language
15:48:42 <aristid> > let (.)=(+) in 1 .4
15:48:43 <lambdabot>   5
15:48:43 <ksf> certainly a more readable one than c++
15:48:51 <jmcarthur> JohnnyL: stop saying the same thing over and over again
15:48:54 <jmcarthur> it's trollish
15:48:55 <JohnnyL> aristid: how hard is it for a compiler to tell the difference in context between a compose and a decimal point?
15:49:06 <kmc> you lose some of the benefits, but it's still worlds ahead of most popular languages in terms of abstraction, readability, conciseness, good implementations, etc.
15:49:12 <jmcarthur> JohnnyL: it's not hard to tell the difference. the thing is that *they mean different things*
15:49:20 <jmcarthur> JohnnyL: and we've already explained this to you
15:49:28 <jmcarthur> and you keep complaining like it mattersw
15:49:30 <jmcarthur> *matters
15:49:40 <sproingie> wait til he discovers negative numbers
15:49:40 <ksf> JohnnyL, one word: instance (Num a) => (-> a)
15:49:46 <aristid> sproingie: lol!
15:49:59 <aristid> > 1 . 2 . 3 $ 4
15:50:00 <lambdabot>   1
15:50:13 <kmc> the GHC manual describes tuples sections as "Python-like" which i would say is surprisingly wrong
15:50:39 <sproingie> nothing about tuples is python-like
15:50:47 <nostard> ksf: yep, by a lot
15:50:49 <aristid> kmc: i think tuple sections are very much Haskell-like
15:50:54 <sproingie> except maybe that they're immutable.  which is true of everything.
15:51:22 <kmc> Haskell tuples and Python tuples are both immutable containers with heterogeneous element types
15:51:26 <xpika> to install a new GHC to re-install all ghc-pkgs?
15:51:27 <kmc> using substantially the same syntax
15:51:29 <monochrom> where is shapr when we need him to banish whiners
15:51:38 <kmc> @get-shapr
15:51:39 <lambdabot> shapr!!
15:51:45 <sproingie> apt-get shapr
15:51:55 <sproingie> cabal install shapr
15:51:56 <jmcarthur> i could do it. i just want to give JohnnyL a chance to clean up
15:51:56 <nostard> kmc: but an ML-language with typeclasses would be nice =) (or strict impure haskell :P)
15:51:59 <monochrom> oh god, there is a function for that
15:52:08 <JohnnyL> > -4
15:52:09 <lambdabot>   -4
15:52:13 <kmc> JohnnyL, i think you and tolkad should start a GHC Bug Fan Club
15:52:13 <aristid> @get-monochrom
15:52:14 <lambdabot> Unknown command, try @list
15:52:20 <kmc> yeah nostard
15:52:25 <JohnnyL> > .4 + 0.4
15:52:26 <lambdabot>   <no location info>: parse error on input `.'
15:52:29 <JohnnyL> FAILZ
15:52:36 <kmc> shut up JohnnyL
15:52:36 --- mode: ChanServ set +o jmcarthur
15:52:37 <aristid> JohnnyL: wherein YOU fail.
15:52:55 <sproingie> haskell's getting trolled a lot lately
15:53:06 --- mode: jmcarthur set +q *!*@ool-18b87a54.dyn.optonline.net
15:53:10 --- mode: jmcarthur set -o jmcarthur
15:53:24 <aristid> sproingie: i guess "avoiding success" helps against trolls :D
15:53:28 * kmc always reads "ChanServ gives channel operator status" as the sound of a shotgun being cocked
15:53:55 <sproingie> i could write a trigger that did that
15:54:03 <sproingie> (heh trigger)
15:54:40 <jmcarthur> i used to have a gunshot sound when people get kicked
15:55:17 <jmcarthur> i got kind of old when a channel i frequent gained a bot with a !roulette command
15:55:20 <jmcarthur> *it got
15:55:39 <monochrom> that is indeed godawful
15:55:53 <jmcarthur> it was actually the default for the client i used at the time...
15:55:59 <aristid> hahaha
15:56:05 <jmcarthur> colloquy :(
15:56:08 <aristid> some clients have funny defaults
15:56:15 <monochrom> I mean !roulette is godawful
15:56:21 <jmcarthur> monochrom: ah
15:56:28 <jmcarthur> well this wasn't a very formal channel by any stretch
15:56:34 <aristid> monochrom: but a client with a shotgun sound on kick as a DEFAULT is godawful too
15:56:41 <jmcarthur> it was local friends and such
15:56:48 <aristid> !roulette
15:56:49 <PsiOmega> a1ristid presses the trigger and.. 4BANG!
15:56:53 <monochrom> the default is godawful but funny
15:56:55 <aristid> oO
15:56:58 <jmcarthur> wat
15:57:04 <jmcarthur> there's a roulette bot here
15:57:12 <jmcarthur> it just can't kick you :P
15:57:15 <aristid> jmcarthur: without +o fortunately
15:57:46 <monochrom> @roulette
15:57:46 <lambdabot> Unknown command, try @list
15:57:54 <monochrom> \/
15:58:26 <aristid> preflex: roulette
15:59:12 <jmcarthur> it would have been better if the client made a gun cocking sound when somebody got ops
15:59:15 <kmc> secret bots!
15:59:21 <jmcarthur> followed by a bang when they kick somebody
15:59:30 <kmc> where do they come from?
16:00:05 <jmcarthur> kmc: from ##OpenGL apparently
16:01:24 <aristid> !help
16:01:38 <aristid> ok, no bot is stupid enough to react to that :D
16:04:04 <tomberek> jmcarthur: are you able to explain all the Mu/Nu fixpoints, etc?  I can reason it out with some time, but something hasn't 
16:04:09 <tomberek> clicked
16:04:13 <aristid> @src Nu
16:04:13 <lambdabot> Source not found. :(
16:04:16 <aristid> :t Nu
16:04:17 <lambdabot> Not in scope: data constructor `Nu'
16:04:22 <aristid> tomberek: what is Nu?
16:04:26 <aristid> :k Nu
16:04:27 <lambdabot> Not in scope: type constructor or class `Nu'
16:04:56 <aristid> :k Eq
16:04:56 <tomberek> aristid: i thought I saw it in category-extras onces
16:04:57 <lambdabot> Class `Eq' used as a type
16:05:02 <tomberek> once
16:05:17 <aristid> tomberek: but what is it?
16:05:18 <monochrom> lambdabot has Mu
16:05:41 <monochrom> newtype Mu f = Mu (f (Mu f))
16:06:08 <monochrom> a general recipe for many recursive types
16:06:54 <ClaudiusMaximus> what would be a good datastructure for a closed non-self-intersecting loop of line segments, where i need to update small neighbourhoods of the midpoint of the longest segment (subdivision)?
16:07:30 <monochrom> data X = ... X ... could be modelled as type X = Mu XF; data XF f = ... f ...
16:07:59 <aristid> monochrom: somehow i think GADT syntax would be nicer for that :D
16:08:06 <tomberek> aristid: data Nu f=forall a.Nu a (a->f a)
16:08:47 <aristid> data Nu f where Nu :: forall a. a -> (a -> f a) -> Nu f
16:09:45 <djahandarie> Mu = Nu in Hask
16:10:06 <djahandarie> No need to distinguish them
16:11:25 <monochrom> my use of the letter "f" is mis-suggestive. data XF a = ... a ...
16:12:12 <aristid> djahandarie: tomberek's Nu is wrong, then?
16:13:35 <djahandarie> No, I think it's fine, just that it can be derived from Mu I'm pretty sure
16:13:47 <tomberek> djahandarie: http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
16:13:52 <tomberek> that's where i found that
16:14:12 <tomberek> but I can't claim to grok it, some help would be much appreciated
16:15:19 <tomberek> @src fix
16:15:19 <lambdabot> fix f = let x = f x in x
16:16:24 <aristid> is that more efficient than fix f = f (fix f), btw?
16:18:08 <djahandarie> tomberek, do you understand how the general Fix works in that document?
16:18:26 <kmc> aristid, it is iirc
16:18:28 <tomberek> i'm playing with it now,, it just seems repeated applications
16:18:44 <int80_h> for purposes of getting name/value pairs from a URI, why do people choose TagSoup + other string functions versus pcre or other regex libraries?
16:18:56 <aristid> kmc: why?
16:19:25 <kmc> aristid, consider length . take 10000 $ fix ('x':).  i think the "let" version will use constant heap space, while fix f = f (fix f) will unfold to 10000 (:) cells, unless fusion occurs
16:19:35 <int80_h> or just screen scraping in general. All the examples I see use PArsec,TagSoup and other string functions. I've yet to see one example using regex, and I wonder why.
16:19:54 <tomberek> djahandarie: it's when they are used as data types that really throws me
16:20:11 <kmc> aristid, i'm not 100% sure.  does it make sense?
16:20:21 <aristid> kmc: i'm not sure
16:20:25 <djahandarie> tomberek, you mean when they are used on the type-level?
16:21:12 <tomberek> newtype Fix f=Fix (f (Fix f))    -- I read this as a data type which contains the function applied to itself
16:21:26 <Botje_> s/function/functor
16:21:28 <tomberek> itself == datatype
16:21:38 * hackagebot copilot 0.26 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-0.26 (LeePike)
16:21:43 <djahandarie> tomberek, f is a type, not a function
16:21:58 <tomberek> erg
16:22:19 <tomberek> so it's an infinite type?
16:22:39 <int80_h> no ideas? I didn't pick regex because I think they are hideous and a maintainenece nightmare. Am I being reasonable?
16:22:44 <djahandarie> It's a recursive type
16:23:01 <djahandarie> Like data List a = Nil | Cons a (List a)
16:23:05 <tomberek> newtype Fix Double = Fix ( Double (Fix Double))  which keeps expanding to Fix (Double (Fix (Double (Fix Double)))) ?
16:23:25 <tomberek> ok, List I understand
16:23:27 <int80_h> but I've got a co-worker causing me to second-guess my choices. Not sure I have good reasons beyond "don't like regex".
16:23:33 <djahandarie> Double would have the wrong kind
16:23:45 <tomberek> arg!
16:24:06 <kmc> regex are hideous and a maintainence nightmare
16:24:13 <int80_h> I knew it!
16:24:20 <djahandarie> You can only use Fix on types that are recursive
16:24:24 <int80_h> I'm right then. :)
16:24:25 <kmc> any attempt to make a nice combinator library for describing regular languages in Haskell?
16:24:32 <djahandarie> Err
16:24:53 <djahandarie> Think of how you change a recursive function to one that uses fix
16:25:10 <djahandarie> It's the exact same process but on the type level now
16:25:29 <aristid> kmc: something parsec-like but Applicative is too powerful, right?
16:26:23 <kmc> *shrug*
16:26:31 <djahandarie> tomberek, from data List a = Nil | Cons a (List a) to data ListF f a = Nil | Cons a f; type List = Fix ListF
16:26:36 <kmc> if it's no prettier than applicative Parsec, no point
16:27:02 <tomberek> ok,I think
16:27:06 <int80_h> kmc, I have a design choice to make that led my co-worker to say "use pcre". Right now, the uri strings I am parsing all begin with the name/value pair I need. If I assume this to always be the case I can just do head [list] and get it. But who knows what changes will be made in the future. On the other hand, I was reading a TagSoup tutorial that suggested not trying to design for the future because you just can't predict what people will do, and to just
16:27:24 <kmc> isn't there a URI library?
16:27:48 <int80_h> if I design for how things are today, I use a simple head call and I'm done. If not I will need to use find which complicates matters.
16:27:54 <int80_h> there is?
16:28:06 <int80_h> I used TagSoup to get me most of the way
16:28:10 <kmc> look at Network.URI in the network package
16:28:18 <kmc> http://hackage.haskell.org/packages/archive/network/2.2.3.1/doc/html/Network-URI.html
16:28:50 <djahandarie> And also, it's somewhat easier to understand Mu when you define it as newtype Mu f = In { out :: f (Mu f) }
16:28:51 <kmc> it doesn't do the key/value pairs i think :/
16:28:54 <djahandarie> Less parenthesis
16:29:02 <djahandarie> Fewer parentheses*
16:29:27 <int80_h> yeah I don't think the network package is for screen scraping.
16:29:34 <kmc> if it works
16:29:55 <kmc> hmm, Network.CGI.formDecode?
16:29:59 <kmc> :t Network.CGI.formDecode
16:30:00 <lambdabot> Couldn't find qualified module.
16:30:08 <djahandarie> tomberek, if you understand Fix, it's easy to understand the definitions of Mu and Nu they give there
16:30:18 <djahandarie> (But normally, we define Mu to be what Fix is in that document)
16:30:41 <tomberek> djahandarie, how does that expand with an actual type and/or value?
16:30:52 <kmc> anyone else know if what i said above about two different fix definitions is correct?
16:30:55 <djahandarie> What is "that"?
16:31:02 <tomberek> Fix
16:36:08 <djahandarie> tomberek, take data ListIntF f = Nil | Cons Int f; type ListInt = Fix ListInt;   :t Nil is ListF f.  :t Cons 5 Nil would be ListF (ListF f).  :t Cons 5 (Cons 2 Nil) would be ListF (ListF (ListF f))
16:36:15 <djahandarie> etc
16:36:38 <djahandarie> Err sorry, that would be all ListIntF f, obviously
16:36:50 <djahandarie> (No ListF here)
16:37:32 <tomberek> hm.... so fix gives you a way to define recursive functions, Fix gives you a way to define recursive types?
16:37:45 <djahandarie> Yes
16:38:15 <tomberek> awesome... so now, is there a variant of this that works with mutually recursive functions (and then a newtype that does it for types?)
16:40:01 <djahandarie> General mutual recursion?
16:40:13 <tomberek> yeah
16:40:14 <djahandarie> Oleg has something like that
16:40:18 <tomberek> is this even close?
16:40:18 <tomberek> something like fix1 f g = (f . g) fix f g
16:40:34 <tomberek> fix1 f g = (f . g) $ fix f g
16:40:38 <djahandarie> You'd want to do it with a list
16:40:53 <dolio> fix1 f g = fix (f . g)?
16:41:25 <djahandarie> fix' :: [[a->b]->a->b] -> [a->b]; fix' f = sa (\x -> map ($ x) f); sa = f = f g where g = f g
16:41:32 <djahandarie> Err
16:41:36 <djahandarie> fix' :: [[a->b]->a->b] -> [a->b]; fix' f = sa (\x -> map ($ x) f); sa f = f g where g = f g
16:42:15 <Phyx->  :t magic
16:42:22 <Phyx-> did botty die:
16:42:23 <Phyx-> ?
16:43:20 <Phyx-> @seen lambdabot 
16:43:20 <lambdabot> Unknown command, try @list
16:43:20 <preflex>  lambdabot was last seen on #haskell 13 minutes and 20 seconds ago, saying: Couldn't find qualified module.
16:43:21 <tomberek> um.. would that work right?
16:43:32 <Phyx-> :t i
16:43:33 <lambdabot> Expr
16:43:38 <Phyx-> ah, I had a space
16:43:50 <tomberek> why use the list like that?
16:44:29 <dolio> The standard way to get mutual recursion is to recognize that 'let f = ... ; g = ...' is the same as 'let (f, g) = (..., ...)'.
16:44:48 <aristid> @src [] mfix
16:44:48 <lambdabot> mfix f = case fix (f . head) of
16:44:48 <lambdabot>            []    -> []
16:44:48 <lambdabot>            (x:_) -> x : mfix (tail . f)
16:44:57 <dolio> That turns a pair of mutually recursive functions into a single recursive tuple definition.
16:45:02 <jmcarthur> newtype (f :. g) a = Compose { decompose :: f (g a) } ; type MutualFix f g = Mu (f :. g)
16:45:54 <djahandarie> Then call it like this fix' [fa, fb] where {fa = \[x, y] a -> {something with a, then call y}; fb = \[x, y] a -> {something with a, then call x} }
16:46:21 <djahandarie> tomberek, you need a list for mutual recursion with any number of terms
16:46:35 <tomberek> makes sense
16:46:52 <tomberek> but I'll need to human-parse that.....
16:48:09 <tomberek> djahandarie: your example would alternate between fa and fb?
16:48:29 <djahandarie> Yes
16:48:54 <djahandarie> Doing this on the type level may be harder...
16:48:54 <tomberek> and somethink like [fa,fb,fc] would cycle through them?
16:49:10 <djahandarie> It depends on how you call them inside the function
16:49:24 <djahandarie> It can model any mutual recursion at all
16:49:31 <djahandarie> Not just cycling the functions
16:50:51 <ksf> what's the sense in allowing build-depends on a library in the same .cabal file when cabal goes on ahead an re-builds all the libraries' files, anyway?
16:51:11 <tomberek> would this sort of concept be applicable to folding a graph? it's alternating nodes refer to edges which refer to nodes etc.
16:51:35 <djahandarie> I'd just use explicit recursion for that
16:51:38 <jmcarthur> ksf: Cabal-version: >= 1.8
16:51:42 <djahandarie> The fix would just obfuscate it
16:52:19 <monochrom> use a visual language that shows you the graph as a graph, not as ascii plain text file
16:52:19 <ksf> nah I'm doing that.
16:52:27 <tomberek> djahandarie: ok, but as a theoretical basis?
16:52:42 <jmcarthur> ksf: well i have managed to make it use the built library in my executable...
16:52:49 <djahandarie> Sure, fsvo 'theoretical'
16:52:53 <jmcarthur> ksf: oh, there's another thing
16:53:09 <aavogt> you shouldn't list your modules/have them in the include path
16:53:09 <ksf> the trick is using a separate source dir
16:53:12 <jmcarthur> ksf: for the library, HS-source-dirs: lib
16:53:13 <jmcarthur> yeah
16:53:23 <ksf> ...but now I get a linker error
16:53:26 <jmcarthur> and for the executable, a different one (i use src)
16:53:30 <jmcarthur> ?
16:53:38 <ksf> might be due to build vs. install, though.
16:53:44 <jmcarthur> i never had to install it
16:54:13 <ksf> er yes, my bad, incomplete export list.
16:54:13 <monochrom> the redundant building is a know shortcoming of current cabal. they will improve it.
16:54:22 <ksf> that is, other-modules.
16:54:32 <jmcarthur> ah
16:54:35 <tomberek> djahandarie: would this sort of alternating recursion be a valid way to look at graphs? An alternate to the Contexts of FGL?
16:54:38 <aavogt> monochrom: they have
16:54:54 <monochrom> nice
16:54:58 <jmcarthur> yay, i have implemented MaybeT and ReaderT in terms of my monad composition library now
16:55:08 <ksf> now it works
16:55:13 <jmcarthur> i'm trying to implement all of transformers with it to demonstrate that it's just as powerful
16:55:40 <jmcarthur> (assuming it is indeed just as powerful, of course)
16:56:40 <djahandarie> tomberek, I'm not sure
16:56:55 <djahandarie> jmcarthur, nice
16:57:18 <tomberek> that's the idea I started with
16:57:24 <jmcarthur> i'm not yet sure how to go about ContT
16:57:42 <joe6> i am reading through the lyah, just got lost with the functor. is there a simpler definition of functor?
16:57:49 <jmcarthur> i'm not sure that i can do it
16:58:29 <ksf> one can't do simpler than lyah. that's lyah's definition, and there's no simpler one than that.
16:58:52 <djahandarie> joe6, simpler than class Functor f where fmap :: (a ->b) -> f a -> f b?
16:59:00 <djahandarie> That's pretty simple.
16:59:02 <aavogt> you can show concrete types instead of f
16:59:16 <djahandarie> ...wouldn't be much of a Functor then would it?
16:59:16 <monochrom> what you need is more examples, not more empty words
16:59:17 <ksf> I'm pretty sure lyah does that.
16:59:26 <joe6> djahandarie: i understood that. I got lost when he started defining functor with "instance Functor"
16:59:37 <joe6> I think I need read up on "instance"
16:59:43 <djahandarie> Yes, learn type classes
16:59:44 <monochrom> you need to know type classes
16:59:52 <unkanon> joe6: google Typeclassopedia
16:59:54 <kmc> joe6, yes, Functor is a type class, you cannot understand Functor if you don't understand type classes
17:00:03 <unkanon> joe6: that's the best definition of functor i've seen
17:00:04 <kmc> start with like Eq and Show and Ord
17:00:04 <djahandarie> unkanon, I think that assumes you know type classes
17:00:19 <unkanon> joe6: i'm sure others will agree
17:00:19 <joe6> thanks guys. will check it out.
17:00:20 <kmc> yeah Typeclassopedia is an intro to some of the more abstract "control-flow" classes
17:00:33 <kmc> Typeclassopedia is a good read but you definitely should understand Eq and Show first
17:00:37 <unkanon> djahandarie: yes
17:00:48 <ksf> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102
17:01:16 <aavogt> is it possible to use ContT (and have it do something useful) without  callCC?
17:01:42 <djahandarie> joe6, I recommended to just follow LYAH in order, it tells you everything you need to know and that's it
17:01:50 <kmc> yes; ContT is not abstract, so you can implement callCC yourself
17:02:23 <ksf> abstract?
17:02:33 <kmc> abstract data type = type with constructors hidden
17:02:44 <unkanon> i have a weird question: i like to try and code a functions definition before looking at its code (so i've done that for map,filter, fold, head, etc). but i wasted some time until i found out that i'd never be able to write seq (because it's a primitive)
17:02:46 <monochrom> you write like ConT (\k -> ...)
17:02:46 <ksf> the moment we get an abstract keyword is the moment people are going to stand against a wall.
17:03:01 <kmc> unkanon, you can write it for specific algebraic types
17:03:01 <unkanon> how do I know without looking at the source if something has a source or not?
17:03:09 <kmc> seqBool True x = x; seqBool False x = x
17:03:20 <kmc> unkanon, in GHCi ":i seq"
17:03:24 <kmc> it says "-- Defined in GHC.Prim"
17:03:28 <kmc> that module has no Haskell source
17:03:50 <kmc> however, a lot of things that are primitive wrt standard Haskell, like IO, do have source and are implemented by GHC-specific hacks
17:03:59 <kmc> for example data Int = GHC.Types.I# GHC.Prim.Int#   -- Defined in GHC.Types
17:04:07 <kmc> of course that's not in the Haskell spec; it is a GHC detail
17:04:20 <unkanon> kmc: that's my question. for instance, i want to try and code the function repeat by myself, but I don't want to waste my time if it's a primitive
17:04:26 <unkanon> but I don't want to see the source either
17:04:28 <monochrom> why seq is not writable in (haskell 2010 minus seq minus !) is an advanced question. don't worry if you don't can't guess it yourself yet.
17:04:30 <kmc> you can definitely code repeat
17:04:31 <unkanon> because I want to ave a shot at it
17:04:40 <kmc> very little is actually primitive
17:04:45 <kmc> you can just ask here
17:04:58 <unkanon> kmc: ok then :)
17:05:09 <unkanon> so I will now try to write repeat
17:05:16 <ksf> seq, par, the usual Int, Float etc, IO and its >>=
17:05:38 <Phyx-> :t sizeOf
17:05:38 <lambdabot> Not in scope: `sizeOf'
17:05:39 <unkanon> monochrom: i'll come back to that question when I feel more prepared :)
17:05:39 <ksf> the rest is most likely implemented somewhere 
17:05:43 <Phyx-> :t sizeOf
17:05:44 <lambdabot> Not in scope: `sizeOf'
17:05:50 <kmc> the most fundamental primitives are lambda, function application, recursive "let", "case", recursive "data"
17:05:59 <kmc> (and the constructors you get from "data")
17:06:10 <Phyx-> @hoogle sizeOf
17:06:10 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
17:06:10 <lambdabot> Network.Socket.Internal sizeOfSockAddr :: SockAddr -> Int
17:06:10 <lambdabot> Network.Socket.Internal sizeOfSockAddrByFamily :: Family -> Int
17:06:33 <unkanon> kmc: does ghci have a lambdabot's :src command?
17:06:34 <kmc> then there's the IO system, which amounts to primitives which are IO actions or functions returning IO actions; a system for gluing them together (which is (>>=)), and a system for making the "main" action run
17:06:39 <unkanon> kmc:  I promise I won't cheat
17:06:44 <kmc> unkanon, no.  but you can private message lambdabot
17:06:49 <tomberek> repeat a = fix (a:)  would that work?
17:06:57 <kmc> :t \x -> fix (x:)
17:06:57 <lambdabot> forall a. a -> [a]
17:06:58 <unkanon> kmc: yeah I've been doing that
17:06:59 <kmc> :t fix . (:)
17:07:00 <lambdabot> forall a. a -> [a]
17:07:05 <Phyx-> how rude
17:07:17 <Phyx-> My connection was removed to the server
17:07:20 <Phyx-> :t Foreign.Storable.sizeOf
17:07:21 <lambdabot> forall a. (Foreign.Storable.Storable a) => a -> Int
17:07:35 <Phyx-> Foreign.Storable.sizeOf (5 :: CInt)
17:07:38 <Phyx-> > Foreign.Storable.sizeOf (5 :: CInt)
17:07:39 <lambdabot>   Not in scope: `Foreign.Storable.sizeOf'Not in scope: type constructor or cl...
17:07:51 <djahandarie> Note that @src lies a lot. I dodnesn't actually look up the sourcees a lot
17:07:58 <djahandarie> And wow, my connection is lagging bad
17:08:04 <Phyx-> what the.... > and :t use different scoping?
17:08:07 <kmc> also lambdabot has weird definitions of some things
17:08:19 <Phyx-> yeah
17:08:21 <Phyx-> like (.)
17:08:21 <djahandarie> Phyx-, yes.
17:08:38 <Phyx-> djahandarie: well.. that's.. confusing
17:08:39 <Phyx-> lol
17:08:43 <djahandarie> :t Unsafe.Coerce.unsafeCoerce
17:08:44 <lambdabot> forall a b. a -> b
17:09:07 <Phyx-> right
17:09:10 <djahandarie> > Unsafe.Coerce.unsafeCoerce (print 5) :: Int
17:09:11 <lambdabot>   Not in scope: `Unsafe.Coerce.unsafeCoerce'
17:09:39 <engla> I've implemented something simple in haskell, a recursive adt min heap, using a zipper. I'm new to haskell and if anyone has any code comments I'll hear anything http://paste.pocoo.org/show/290704/
17:09:59 <hpc> wow, you are new to haskell and understand zippers?
17:10:04 <djahandarie> Heh, it's funny that someone says that is easy after the LYAH for it comes out.
17:10:19 <djahandarie> Before the LYAH post, that was a pretty advanced topic
17:10:38 <Phyx-> there's a LYAH post on zippers?
17:10:43 <hpc> yeah, it is the most recent
17:11:06 <djahandarie> engla, make a module and ditch all the 'h's
17:11:24 <djahandarie> engla, and find a nicer way to do those nested ifs
17:11:30 <engla> zippers seem cool to me, I've never seen it other languages
17:11:30 <Phyx-> I have to admit, i haven't actually ever read a LYAH post
17:11:47 <djahandarie> engla, they don't exist in other languages as zippers
17:11:55 <hpc> Phyx-: worth it, even if you understand it all
17:11:55 <djahandarie> There is a mutable version of them called pointer reversal
17:11:58 <engla> djahandarie: hm yeah I'll have to think about the ifs. I don't see it right now
17:12:09 <hpc> if only to better understand how to explain it to newbies
17:12:16 <unkanon> kmc: got it, is this cheating?  myRepeat x = [x,x..]
17:12:25 <tomberek> engla, I like it
17:12:30 <Phyx-> hpc: I have read RWH though
17:12:32 <kmc> unkanon, it only works for instances of Enum
17:12:34 <kmc> :t \x -> [x,x..]
17:12:35 <lambdabot> forall t. (Enum t) => t -> [t]
17:12:39 <unkanon> tomberek:  myRepeat x = [x,x..]
17:12:39 <hpc> :t \x -> [x,x..]
17:12:40 <lambdabot> forall t. (Enum t) => t -> [t]
17:12:43 <hpc> lol
17:12:49 <kmc> unkanon, it's a clever hack though
17:12:51 <unkanon> kmc: oh...
17:12:55 <tomberek> unkanon: what kmc said
17:13:07 <kmc> unkanon, think recursively.  what's the first element of "repeat x"?  and what are the rest of the elements?
17:13:08 <hpc> :t \x -> fix (x:)
17:13:09 <lambdabot> forall a. a -> [a]
17:13:09 <engla> tomberek: thanks.
17:13:43 <djahandarie> [x,x..] desugars to enumFromThen x x
17:13:53 <Phyx-> Am I the only one that reads something, understands it, then forgets it in 2-3 weeks?
17:13:55 <engla> I think there are some too many functions that don't take all arguments (for edge cases where the call is an error), I don't know what people do in such cases normally (except make it all use Maybe
17:14:03 <unkanon> djahandarie: i see
17:14:08 <hpc> Phyx-: not in the slightest; it is how all students think
17:14:15 <Phyx-> lol
17:14:29 <djahandarie> Phyx-, that happens for me with everything except computer science stuff
17:14:44 <[swift]> i find i only really retain stuff that i actually do something with
17:15:03 <[swift]> i used to try to integrate everything interesting i learned into some sort of project to leverage that, but in graduate school i just haven't had time anymore
17:15:13 <Phyx-> djahandarie: I'd remember what the topic is and a general overview, but I'd have forgotton the finer points
17:15:28 <djahandarie> Grad students do _work_?
17:15:48 <joe6> i could never get into haskell but for the help I received from this irc. Just curious, do most of you do this out of your passion or are companies sponsoring a lot of experts on this channel?
17:15:53 <Phyx-> [swift]: yeah, exactly, Like zippers. I learned them, implemented one using multirec
17:15:54 <hpc> djahandarie: do you know how far away the good coffee shops are? professors have to teach, you know :P
17:15:55 <Entroacceptor> djahandarie: they're the only ones that do anything of interest, in fact.
17:15:57 <Phyx-> then just forgot it
17:16:01 <joe6> i really like haskell and am grateful for your help.
17:16:01 <monochrom> I write study notes. Interestingly, after writing study notes, I remember better without reading the study notes.
17:16:20 <Phyx-> djahandarie: I hope not... if they do, I'm in trouble
17:16:24 <djahandarie> joe6, burning passion!
17:16:31 <joe6> and my programs look a lot better in haskell.
17:16:37 <engla> monochrom: that's like me. I mostly don't read my notes again.
17:16:39 <monochrom> I will eventually forget (just takes longer) but then the study notes save me.
17:16:51 <[swift]> monochrom: that _does_ help, but its still not as good as using the knowledge
17:16:59 <hpc> joe6: just wait until you get /good/ at it :D
17:17:01 <ksf> joe6, passion
17:17:07 <djahandarie> Phyx-, are you a grad student? :P
17:17:08 <Entroacceptor> monochrom: there's actually a reason for that
17:17:13 <monochrom> Yeah, unfortunately, life is too short for using all knowledge you know.
17:17:16 <Phyx-> yeah, I also fine that stuff I've written down stayed in there longer
17:17:18 <Entroacceptor> if you read them too quickly afterwards, your brain gets lazy
17:17:19 <ksf> this channel is sponsoring companies to write good code.
17:17:24 <djahandarie> Haha
17:17:26 <[swift]> i've come to view my classes as serving only one real purpose: to make me aware of the existence of things, so maybe i can go back and learn more about them when i need to use them
17:17:56 <djahandarie> That and a way to practice learning stuff and then forgetting it after a given period of time
17:18:03 <djahandarie> You can become a professional forgetter
17:18:05 <Phyx-> djahandarie: yeah, i'll  be done in ~4 months
17:18:17 <[swift]> lol i should put that on my business card
17:18:18 <djahandarie> Phyx-, what area?
17:18:22 <Phyx-> not looking forward to working :/
17:19:07 <Phyx-> djahandarie: mostly functional programming, compiler theory, type systems etc
17:19:11 <Entroacceptor> meh, anyone got a working fan for an samsung laptop?
17:19:14 <djahandarie> Nice
17:19:15 <ksf> the learning comes from applying the heard, not the heard stuff. at least if you're not an expert in the area, in which case you can apply in-head.
17:19:21 <joe6> so functor has a different interpretation of fmap based on the type of the list elements that it is acting upon.
17:19:43 <ksf> for some values of "interpretation", yes.
17:19:52 <hpc> it's polymorphic
17:19:59 <djahandarie> My favorite learning technique is teaching
17:20:06 <hpc> it's like saying id returns a different value if you give it a different input :P
17:20:19 <ksf> the definition of functor comes with laws that tell you how it behaves by just looking at the type.
17:21:25 <ksf> ...an instance not satisfying those is broken in the same way a readFile function that launches missiles would be broken.
17:21:33 <djahandarie> People should package quickcheck props with their type classes
17:21:37 <joe6> so, ((->) r) is the type of a function?
17:21:47 <Phyx-> any better, not necissarily safer way of writing "fapp s (v, b) = (fromJust $ appAll s v, fromJust $ appAll s b)"
17:21:53 <hpc> joe6: it's part of a function
17:21:54 <djahandarie> joe6, that is *not* the instance you want to start with
17:22:13 <hpc> ((->) r) a would be the same as "r -> a"
17:22:17 <hpc> but yeah, start with Maybe
17:22:40 <joe6> hpc: djahandarie: yes, i understand Maybe and IO usage with functor fmap
17:22:46 <Phyx-> :k (->)
17:22:47 <lambdabot> ?? -> ? -> *
17:22:50 <joe6> and tried it out ghci.
17:23:24 <hpc> joe6: try list next
17:23:44 <hpc> the function instance is hard to grok
17:23:57 <djahandarie> Phyx-, you can use the Bifunctor instance for (a, b) :P
17:23:59 <joe6> what is "grok"?
17:24:13 <joe6> hpc: thanks, trying it out with list
17:24:18 <ksf> http://www.sbin.org/doc/jargon/G/grok.html
17:24:24 <hpc> it's a fabricated word from a sci-fi novel; it has since become popular enough to almost be a word
17:24:43 <djahandarie> I never knew it was fabricated
17:24:46 <hpc> it roughly means "to understand so deep it is intuitive"
17:25:09 <kmc> joe6, ((->) r) is a type constructor, like Maybe.  it is not a full type.  it's still "waiting for"  type argument
17:25:14 <hpc> so like, a 4 year old groks walking; people grok talking; you probably grok irc
17:25:20 <kmc> (((->) r) a) and (Maybe a) are types
17:25:25 <monochrom> no, fmap depends on the "container" type not the element type.
17:25:34 <kmc> (((->) r) a) would be much more often written (r -> a)
17:25:36 <alex404__> Does anyone else shadow relevant variables in where function definitions? Is this considered bad style?
17:25:50 <kmc> alex404__, what do ghc -Wall and hlint say?
17:26:08 <hpc> alex404__: i wouldn't do it; the worst i have done is shadowing id in some sql code
17:26:13 <aavogt> ksf: how about http://hpaste.org/41412/for for breaking with forM_?
17:26:22 <alex404__> kmc: Well they don't like it
17:26:34 <hpc> you can push it with do x <- something; x <- somethingElse x; ...
17:26:38 <hpc> but bleh
17:26:44 <alex404__> Fair enough
17:26:53 <alex404__> I just like being able to cut my functions out of the where bindings if I have to
17:27:03 <alex404__> And I find it clarifies things sometimes...
17:27:03 <djahandarie> Phyx-, you could also liftM2 (.) first second
17:27:17 <hpc> where bindings are only really useful if you need the scoping
17:27:27 <hpc> if you can pull it out to its own function, you should
17:27:29 <djahandarie> Or use fmap and flip
17:27:40 <ksf> aavogt, yes.
17:27:51 <alex404__> hpc: Fair enough.
17:28:05 * hackagebot thrist 0.2 - Type-threaded list  http://hackage.haskell.org/package/thrist-0.2 (GaborGreif)
17:28:10 <Phyx-> djahandarie: liftM2 (.) ? you mean (,) ?
17:28:15 <hpc> that said, everything i just said is wrong; do what looks best :P
17:28:23 <ksf> actually, a mildly constrained version of ConT resembling vanilla sanely-structured programming would make sense.
17:28:40 <Phyx-> :t liftM2 (.)
17:28:40 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
17:28:41 <alex404__> ;)
17:28:53 <djahandarie> Phyx-, nope, that's (\f -> first f . second f)
17:29:14 <hpc> :t first
17:29:14 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
17:29:25 <ksf> I bet we could use something like "bar": to do labels.
17:29:27 <hpc> :t \f -> first f . second f
17:29:28 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
17:29:30 <Phyx-> djahandarie: ah, I did not know that
17:29:34 <Phyx-> handy
17:29:39 <aristid> @pl \f -> first f . second f
17:29:39 <lambdabot> liftM2 (.) first second
17:29:47 <aristid> lambdabot: you're genius
17:29:55 <hpc> ahaha
17:29:58 <djahandarie> Years of training with @pl, Phyx-
17:30:00 * aavogt wonders about defining those 'control structures' with quasiquote patterns
17:30:06 <Phyx-> djahandarie: lol
17:30:22 <djahandarie> You could also do liftM2 fmap first second  if you feel particularly like annoying whoever reads your code
17:30:23 <aavogt> ksf: what is "bar" in that context?
17:30:35 <ksf> aavogt, have a look at http://hackage.haskell.org/packages/archive/BASIC/0.1.5.0/doc/html/Language-BASIC.html
17:30:38 <aristid> djahandarie: liftM2 (.) is a nice trick
17:30:41 <ksf> aavogt, a label.
17:30:55 <ksf> like in "goto bar" or "break bar"
17:31:04 <aristid> :t liftM2 fmap
17:31:05 <lambdabot> forall a b (f :: * -> *) (m :: * -> *). (Functor f, Monad m) => m (a -> b) -> m (f a) -> m (f b)
17:31:19 <djahandarie> :t liftM2 (Prelude..)
17:31:20 <lambdabot> forall b c a (m :: * -> *). (Monad m) => m (b -> c) -> m (a -> b) -> m (a -> c)
17:31:26 <Phyx-> :t check
17:31:27 <lambdabot> Not in scope: `check'
17:31:33 <Phyx-> :t quickCheck
17:31:33 <monochrom> two for-loops goto a bar...
17:31:33 <lambdabot> forall prop. (Testable prop) => prop -> IO ()
17:31:39 <hpc>  >=>
17:31:43 <djahandarie> haha monochrom
17:31:47 <hpc> crap, wrong keyboard
17:31:51 <hpc> :t (>=>)
17:31:52 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
17:31:56 <Phyx-> :t quickCheck (\a b -> a . b = fmap a b)
17:31:57 <lambdabot> parse error on input `='
17:31:59 <Phyx-> wait..
17:32:02 <Phyx-> :t quickCheck (\a b -> a . b == fmap a b)
17:32:03 <djahandarie> Sweet damn I need to fix my internet
17:32:03 <lambdabot>     Overlapping instances for Show (a -> b)
17:32:03 <lambdabot>       arising from a use of `quickCheck' at <interactive>:1:0-37
17:32:03 <lambdabot>     Matching instances:
17:32:37 <aavogt> ksf: how do you make sure that you're jumping to a label that actually exists then?
17:32:40 <aristid> :t liftM2 fmap :: Functor f => (a -> b -> c) -> (a -> f b) -> (a -> f c)
17:32:41 <lambdabot> forall a b c (f :: * -> *). (Functor f) => (a -> b -> c) -> (a -> f b) -> a -> f c
17:32:45 <aristid> woot
17:32:49 <hpc> Phyx-: try enumerating functions :P
17:32:52 <djahandarie> Phyx-, the functor instance of ((->) a) defines fmap = (.), so that definitely works. :P
17:32:59 <ksf> aavogt, you don't.
17:33:04 <djahandarie> And you can use @check on lambdabot
17:33:08 <ksf> arguably, that's not the best we can do.
17:33:22 <djahandarie> Okay, it's getting too hard to type messages without being able to see them... SSH gone wrong. Will be back later
17:33:22 <Phyx-> djahandarie: yes i know, We were discussing it earlier that using (.) = fmap in lambdabot is confusing
17:33:33 <Phyx-> @check id
17:33:33 <lambdabot>   "Arguments exhausted after 0 tests."
17:33:35 <ksf> $(label "foo")
17:33:39 <Phyx-> lol
17:33:44 <Phyx-> @check id == \x.x
17:33:44 <lambdabot>   Parse error at ".x" (column 9)
17:33:48 <Phyx-> @check id == \x->x
17:33:49 <lambdabot>   No instance for (GHC.Classes.Eq (a -> a))
17:33:49 <lambdabot>    arising from a use of `GHC.Cla...
17:34:00 <Phyx-> @check fmap
17:34:00 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> b)
17:34:00 <lambdabot>    arising from a use of `...
17:34:14 <ksf> expands to label :: Label (F :. O :. O :. ())
17:34:22 <Phyx-> I wonder what it's overlapping with
17:34:33 * hpc imagines an instance of Eq for functions where (==) = some function of quickCheck...
17:34:36 <Phyx-> [id..id]
17:34:41 <djahandarie> Phyx-, numinstances
17:34:43 <Phyx-> >[id..id]
17:34:46 <djahandarie> I think
17:34:48 <Phyx-> > [id..id]
17:34:49 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a))
17:34:49 <lambdabot>    arising from a use of `e_1' at ...
17:34:59 <Phyx-> that one was silly
17:35:08 <Phyx-> but it used to have a fun Show for functions
17:35:18 <hpc> > id
17:35:22 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:35:26 <lambdabot>    arising from a use of `...
17:35:28 <djahandarie> I know, it was nice
17:35:33 <hpc> what was it?
17:35:42 <aavogt> it could still be done, if somebody modified vector space or whatever it's called
17:36:16 <Phyx-> hpc: well, id would print out {} -> {}
17:36:17 <joe6> when the functor class is for list data types, why do we use functor class to define fmap on a Maybe datatype?
17:36:18 <Phyx-> for instance
17:36:31 <joe6> or on functions?
17:36:44 <joe6> i mean 2 functions as args
17:36:47 <hpc> joe6: polymorphism and generality
17:36:58 <hpc> and repetitive redundancy :P
17:37:56 <joe6> i can understand creating fmap on a list of Maybe datatypes but just on one Maybe datatype seems weird.
17:38:26 <hpc> joe6: say you need newtype Wrapped a = Wrapped a
17:38:33 <hpc> you could say:
17:38:39 <ksf> the Functor class isn't "for lists"
17:38:45 <hpc> instance Functor f => Functor (Wrapped f) where
17:39:00 <monochrom> the Fuctor class is for everyone
17:39:02 <Phyx-> if that the right kind?
17:39:07 <Phyx-> :k Functor
17:39:08 <lambdabot> Class `Functor' used as a type
17:39:09 <ksf> it's to mess with the right-most type variable in a higher-kinded type.
17:39:30 <hpc> while leaving the "context" intact
17:39:33 <Phyx-> hpc: shouldn't that just be Functor Wrapped where
17:39:42 <hpc> (length of a list, Nothing, Right/Left, etc)
17:39:50 <hpc> Phyx-: er, yes
17:39:54 <hpc> shush
17:40:04 <Phyx-> lol
17:40:08 <ksf> with Either a b, you mess with the b.
17:40:43 <ksf> though the functor concept generalises, somewhere in category-extras there's bifunctor which lets you mess with both Left and Right
17:41:00 <Phyx-> the more I try to fix my code, the more I break it
17:41:04 <hpc> there's also other typeclasses that depend on Functor
17:41:07 <hpc> like applicative
17:41:13 <ksf> (OR MONAD)
17:41:15 <ksf> GRRRR
17:41:20 <hpc> (YESSS!)
17:41:35 <hpc> lousy Either ruining our fun
17:41:57 <ksf> huh?
17:42:01 <ksf> why would it?
17:42:11 <hpc> isn't that the reason functor isn't a requirement for monad?
17:42:23 <ksf> no, it's hyserical raisins.
17:42:30 <ksf> hysterical, even.
17:42:40 <aavogt> grape crazies
17:42:59 <aavogt> this thing called backwards-compatibility
17:43:04 <Phyx-> lies... grapes can never be crazy
17:43:08 <ksf> is overrated.
17:43:20 <Phyx-> since when does GHC care about backwards-compatibility?
17:43:30 <hpc> since...just now?
17:43:47 <kmc> GHC is mostly Haskell 98 compatible and has been for... 12 years? almost?
17:44:05 <hpc> that's how long h98 has lasted :P
17:44:26 <ksf> well, possibly ghc 8 will do it unless you say -XH98 or -XH2010
17:44:41 <hpc> the new spec is just under a year old, and is mostly compatible with h98
17:44:43 <Phyx-> well, I rememeber when 6.10 came out and they broke up two classes. I think it was Alternative and Applicative, can't remember
17:44:48 <Phyx-> that broke alot
17:45:03 <ksf> the exception madness.
17:45:06 <aavogt> breaking every module using Control.Exception is not as bad as breaking (nearly) every module making Monaad instances
17:45:11 <ksf> that was base4/ghc 6.10
17:45:15 <ksf> time, too.
17:45:40 <monochrom> because Control.Exception was never in Haskell 98
17:45:43 <hpc> aavogt: it would only be a whole lot of typing; nothing serious :P
17:45:48 <kmc> Monad and Functor are in H98, though
17:45:55 <ksf> well, but _adding_ functor instances is backwards-compatible.
17:46:01 <kmc> there's vaguely an upgrade path for Control.Exception, yes?
17:46:11 <kmc> there was the OldException module and maybe a package that provided it as Control.Exception?
17:46:11 <ksf> so we should just spec it for h' and warn people to fix their code in time.
17:46:17 <kmc> base3-compat is gone in 7.0 right?
17:46:22 <ksf> yep
17:46:29 <Phyx-> eek, almost 3am
17:46:37 <hpc> ksf: the people that don't update their code probably don't update their GHC either
17:46:48 <hpc> (myself included... <.<)
17:46:49 <ksf> there's also the outermost bang pattern thing that breaks e.g. every single happy grammar.
17:48:19 <ksf> people (and distros) are quite likely to upgrade as soon cabal defaults to dynamic linking, I think.
17:49:50 <ksf> we could use that version to spout warnings (Warning: instance declaration for Monad Foo without accompying declarations Functor Foo and Applicative Foo. THIS WILL BREAK IN GHC X.Y FIX YOUR CODE NOW)
17:50:37 <aavogt> look at the base-4 switch though
17:50:52 <aavogt> a good portion of hackage still needs base-3
17:51:01 <ksf> most just pretends to.
17:51:22 <ksf> at least all the stuff I tried with ghc7.
17:51:47 <aavogt> is there a cabal install for ghc-7?
17:52:07 <Heffalump> the existing cabal install works fine with it
17:52:39 <djahandarie> cfricke, Haskell in Japan? :)
17:52:41 * Heffalump has got darcs building against base 4 now, so a decent set of core libraries has made the switch
17:52:54 <ksf> ghc isn't on hackage
17:53:42 <cfricke> djahandarie: !
17:53:54 * aavogt tried the cabal-install (or one of them) from   darcs.haskell.org
17:54:20 <cfricke> I've been detected.
17:54:46 <djahandarie> Hehe
17:55:27 <djahandarie> 
17:55:45 <aavogt> Heffalump: you had to bump versions in the bootstrap.sh then?
17:56:13 <Heffalump> actually, I didn't rebuild cabal install against GHC7, I just used the one I already had.
17:56:19 <Heffalump> so now I see what you were asking about.
17:56:21 <tomberek> djahandarie: i've been playing with that fix' you wrote, trying to get the hang of it, trying to convert things to work with it, so far so good
17:56:42 <djahandarie> It's oleg's fix, I think
17:56:46 <djahandarie> I didn't come up with it :P
17:56:51 <tomberek> but what would be the point of using that or even original fix in actual code?
17:56:52 <tomberek> oh
17:56:53 <joe6> will I get haskell after understanding functors -> monoids -> monads?
17:57:05 <joe6> i feel that I am missing something fundamental.
17:57:05 <djahandarie> tomberek, no point since you can encode recursion directly
17:57:17 <joe6> and hopefully that will be cleared once I get to monads?
17:57:32 <joe6> i can write a haskell program using types, etc.. but want to "get it"?
17:57:45 <cfricke> Now if I just knew who you might be.
17:57:51 <tomberek> so it's just to do it with lambda calculus? a trick we borrowed for fun from lisp?
17:58:11 <joe6> s/I/anyone/?
17:58:18 <ksf> joe6, does assembly have the lambda nature?
17:58:36 <monochrom> haha
17:58:53 <joe6> ksf: do you mean asm code?
17:58:57 <aristid> tomberek: you can use fix to write point-free recursive code :)
17:59:15 <tomberek> aristid: is that worth the effort?
17:59:18 <ksf> you must shed your imperative past to enter the pure realm of lambda.
17:59:22 <ksf> then, you will be enlightened.
17:59:27 <aristid> > fix $ (1:) . (1:) . (zipWith (+) <*> tail)
17:59:28 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
17:59:32 <kilimanjaro> unemployed*
17:59:38 <aristid> tomberek: effort? using fix is not hard
17:59:52 <aristid> tomberek: and making stuff point-free is a popular game here
18:00:17 <joe6> ksf: i learnt lisp just to get lambda. I can use lambda functions in a program. I understand the syntactical portions of lambda. I am thinking currying is more fundamental and important than lambda?
18:00:30 <tomberek> that's true... though isn't encoding recursion directly more readable?
18:00:51 <kmc> joe6, you can't compare the two features
18:00:56 <kmc> currying is not a language feature; it's a convention
18:01:07 <kmc> a convention for how to represent multi-argument functions
18:01:07 <monochrom> explicit recursion is more readable and more inconvenient.
18:01:13 <kmc> and you can do it in any language with first-class functions
18:01:28 <kmc> but Haskell is set up so that the syntax for curried functions is nicer than the syntax for non-curried functions
18:01:36 <kmc> and the standard libs follow the curried convention
18:02:05 <kmc> joe6, i wouldn't expect there to be one moment where you "get Haskell"
18:02:11 <ksf> joe6, cleanse yourself of the defilements of set-car!
18:02:12 <kmc> it takes a long time to learn, there will be lots of breakthroughs
18:02:25 <joe6> kmc: yes, no set-car! for me.
18:02:38 <joe6> I just wanted to learn lisp after starting to use haskell.
18:02:43 <ksf> kmc and me are strictly distinct.
18:03:00 <ksf> (and no you're not the first one to confuse us)
18:03:01 <joe6> sorry about that.
18:03:24 <ksf> there's write yourself scheme in 48 hours
18:03:38 <aristid> tomberek: optimally you would use neither fix nor explicit recursion
18:04:05 <ksf> there's rwh to get you up to speed on idiomatic haskell, don't miss the monad.reader and have a look at the xmonad source.
18:04:06 <kmc> joe6, i can provide a long list of concepts i'd expect a Haskell expert to understand, but they don't come in a nice sequential path
18:04:20 <joe6> kmc: what are they?
18:04:25 <tomberek> aristid: you use the proper fold or map or whatever, right?
18:04:26 <aristid> ksf: rwh omits many important idioms :)
18:04:33 <aristid> tomberek: that's the idea:)
18:04:36 <kmc> joe6, too long to type out today ;)
18:04:41 <joe6> kmc: oh, ok.
18:04:47 <ksf> ...that's what the monad reader is for.
18:04:59 <tomberek> aristid: well, I'm trying to work out the background of my 'mfold' (mutual fold)
18:05:02 <aristid> ksf: typeclassopedia!
18:05:05 <kmc> joe6, it's mostly not going to be structures from abstract algebra with funny names
18:05:19 <kmc> joe6, it's mostly going to be like "hunting down space leaks" and "concurrency" and stuff like that
18:05:24 <aristid> tomberek: ok for background i'm not the right person at all :D
18:05:33 <aristid> preflex: seen dcoutts_
18:05:33 <preflex>  dcoutts_ was last seen on #ghc 5 hours, 17 minutes and 37 seconds ago, saying: :-) taraa!
18:05:41 <ksf> I'd rather say it's program architecture.
18:05:43 <aristid> preflex: seen dcoutts
18:05:43 <preflex>  dcoutts was last seen on #ghc 10 days, 4 hours, 53 minutes and 46 seconds ago, saying: and it's now moderately mature
18:05:48 <joe6> kmc: ok, thanks.
18:05:52 <kmc> joe6, you could start by understanding every GHC language extension
18:05:52 <tomberek> aristid: hehe, neither am I, but I'm making slow progress
18:06:02 <kmc> and also understanding roughly how GHC compiles Haskell to machine code
18:06:19 <kmc> and by 'start' i mean ... ;)
18:06:21 <ksf> and have a look at e.g. the hlist paper.
18:06:24 <joe6> kmc: ok, thanks. will check them out.
18:06:30 <kmc> yes, read everything oleg wrote ;)
18:06:38 <kmc> joe6, i don't think this is the best way to learn and use haskell
18:06:47 <ksf> though absolutely don't expect to understand anything oleg writes on the first try.
18:06:48 <kmc> but you were interested in how to "get haskell" or to obtain some specific level of mastery
18:07:24 <kmc> i mean if you feel like you're missing something fundamental, maybe you could explain why you feel that way
18:08:12 <aristid> kmc: he should also start with iteratees
18:08:18 <joe6> kmc: "best way to learn and use haskell" -- do you mean not to learn haskell by reading the papers?
18:08:34 <kmc> i didn't say to read papers above
18:08:39 * gds is currently reading The Typeclassopedia.
18:08:43 <kmc> joe6, to learn and use haskell, read and write haskell programs
18:08:43 <gds> I think that's helping me.
18:08:56 <kmc> that will provide an ample supply of new concepts to learn
18:09:02 <joe6> kmc: like lisp, you get it once you understand the paranthesis and listen to the sicp videos on eval and apply.
18:09:03 <ksf> the royal road to haskell is throwing away lots of your past haskell sources in disgust.
18:09:09 <kmc> which you then chase down through google, IRC, papers, GHC manual, etc etc etc
18:09:29 <ksf> joe6, read the STG papers.
18:09:31 <kmc> joe6, there's a lot more to lisp than that.  and i wouldn't expect Haskell to be so conceptually simple as Scheme
18:09:44 <ksf> that, and something about hindley-milner types.
18:09:57 <kmc> yeah, if you want to understand type theory, read TaPL and then a bunch of papers
18:10:08 <ksf> which gives you lazines+the type system, which are pretty fundamental
18:10:12 <ksf> (and different to lisp)
18:10:29 <ksf> in particular, unification.
18:10:34 <kmc> joe6, there's a lot of ideas central to Haskell, not a single core idea like eval/apply
18:11:48 <joe6> ok, thanks a lot for your input.
18:11:52 <kmc> no problem :)
18:12:16 <ksf> joe6, http://docs.google.com/viewer?a=v&q=cache:EXN28GiIdAMJ:www.dcc.fc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf&pli=1
18:13:09 <ksf> there's been stuff going on on the backend side since that was written, but it gets the gist of what's being done across really good.
18:14:15 <kmc> i would read that, then "how to make a fast curry"
18:14:24 <kmc> the former is probably a necessary prereq, much more detail
18:14:32 <kmc> but the model in the latter is simpler and closer to what GHC really uses these days
18:14:55 <ben> I think Haskell's biggest selling point is how apt the community is to make puns in the titles to serious writeups.
18:15:03 <kmc> and then http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode which i am currently working through
18:15:06 <Twey> Heheh.
18:15:08 <ksf> you shouldn't eat curry made by any british, it's going to be pink.
18:15:13 <kmc> joe6, of course you might be only interested in the semantics of Haskell, not its implementation
18:15:17 <djahandarie> ben, :P
18:15:20 <kmc> but it's probably best to know both
18:15:21 <Twey> Curry is *meant* to be pink!
18:15:45 <ksf> ...and it's going to taste like dish water.
18:15:58 <ddarius> Nepalese curry all the way
18:16:04 <ksf> but despair not, there's something worse than english food, and that is english football.
18:16:12 <tg_> guffaw!
18:16:50 <Twey> Heheh.
18:19:53 <ddarius> ben, That's just Wadler's biggest selling point.
18:20:19 <ben> Yeah, but I am honestly not in the market for Wadlers.
18:20:28 <ddarius> That's a shame.
18:20:49 <monochrom> Wadler started all the puns.
18:20:54 <dolio> Maybe you'd be interested in a McBride.
18:21:51 <bremner>  Darl is looking for work.
18:21:59 <dolio> Hah.
18:22:31 <dolio> Is he, though?
18:25:22 <tomberek> djahandarie: playing with fix2a f g = f (fix2b f g) and fix2b f g = g (fix2a f g)   is helping me get some of the concepts arranged
18:26:50 <djahandarie> I'm not entirely sure why you're doing this yet, except for understanding the code better, I suppose :P
18:27:19 <djahandarie> Using Mu is useful because then you can manipulate things with the base type
18:27:44 <tomberek> yep, making that 2 function fix helped me test my 'code reasoning'
18:27:48 <tomberek> hm... Mu
18:27:57 <alex404__> Is there any significant overhead to memozing functions or can I liberally sprinkle them around whenever I want to do some dynamic programming?
18:28:21 <djahandarie> I keep on calling that type the "base type", but it's not a formal name. I'm just not sure of the formal name.
18:29:06 <kmc> tomberek, that's equivalent i think to:  fix2 f g = f (fix2 g f)
18:29:19 <tomberek> kmc?
18:29:23 <kmc> > let fix2 f g = f (fix2 g f) in fix2 ('x':) ('y':)
18:29:23 <lambdabot>   "xyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxyxy...
18:29:42 <tomberek> oh, yeah, i see
18:29:49 <tomberek> the swap occurs in the same call
18:30:35 <tomberek> > let fix3 f g h = f ( fix3 g h f) in fix3 ('x':) ('y':) ('z':)
18:30:36 <lambdabot>   "xyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxyzxy...
18:30:42 <tomberek> nice!
18:31:30 <tomberek> data Fix2 f g = Fix2 (f (Fix2 g f))  is this the type level version?
18:34:49 <tomberek> .
18:36:26 <kmc> think so
18:36:35 <kmc> could that be a newtype? i think so
18:36:47 <tomberek> how does one use the type-level Fix,Mu,Nu,Fix2?
18:37:30 <tomberek> kmc: yep, newtype works
18:37:38 <kmc> data ListF a list = Nil | Cons a list; type List a = Mu (ListF a)
18:38:13 <kmc> data NatF t = Zero | Succ t; type Nat = Mu NatF
18:38:31 <kmc> note that NatF is isomorphic to Maybe; this means that Mu Maybe is isomorphic to the naturals
18:38:51 <orlandu63> how do i specify which package to prefer in the case of having ambiguous module names?
18:38:52 <kmc> :t let f 0 = Nothing; f n = Just . In $ f (n-1) in f
18:38:53 <lambdabot> forall t. (Num t) => t -> Maybe (Mu Maybe)
18:38:57 <kmc> orlandu63, in your cabal file
18:39:09 <kmc> :t let f 0 = In Nothing; f n = In . Just $ f (n-1) in f
18:39:09 <orlandu63> kmc: is that the simplest way?
18:39:10 <lambdabot> forall t. (Num t) => t -> Mu Maybe
18:39:17 <tomberek> kmc: i'm trying a Fix2 version
18:39:17 <kmc> orlandu63, in terms of least overall headache, yes
18:39:31 <kmc> otherwise, you can screw around with ghc's -package and -hide-package flags and/or -XPackageQualifiedImports
18:39:35 <kmc> but cabal is the correct way
18:39:56 <kmc> if you're just testing stuff in ghci though, you might use the flags or even ghc-pkg hide
18:44:35 <orlandu63> heh, weird: runhaskell -hide-package packagename doesn't work, but -hide-packagepackagename works
18:46:11 <tomberek> newtype Fix2 f g = Fix2 (f (Fix2 g f));  data A c = A Int c; data B c = B Int ;c  type C = Fix2 A B   --Is this the right way to do fix2 at type-level?
18:46:39 <kmc> guess so?
18:46:42 <kmc> what are you trying to do?
18:46:53 <orlandu63> thanks, kmc 
18:46:56 <tomberek> kmc: just playing at the moment, learning
18:47:20 <kmc> then i don't know how to answer the "is it right" question
18:47:38 <kmc> you should probably try to build some terms of type C
18:48:33 <tomberek> data A c = A Int c; data B c = B Char;c  type C = Fix2 A B   -- is this 'C' alternating Int and Char?       @kmc: how does one go about that?
18:48:40 <int80_h> I have a [[String]], and I want to use Map or something like it to get inside the inner list to work on it. Is there a common solution to this kind of problem?
18:48:46 <kmc> to write a term?
18:49:06 <tomberek> kmc: I'm not sure what the constructors would be
18:49:17 <kmc> well, to write a term of some algebraic type T, choose one of its constructors, and apply it to fields of appropriate types
18:49:18 <kmc> ok
18:49:24 <kmc> well you defined A and B with constructors each
18:49:30 <tomberek> yeah
18:49:34 <kmc> and Fix2 has a constructor
18:49:37 <kmc> and C is a synonym for Fix2 A B
18:49:44 <kmc> so you'd pick a Fix2 constructor
18:49:44 <tomberek> hm, i'm on it
18:49:46 <kmc> :)
18:50:12 <monochrom> int80_h: it's usually like map (map not) [[False], [True,False,True], []]
18:50:12 <Entroacceptor> int80_h: yes, map.
18:51:33 <monochrom> or map (map toLower) ["HELLO", "MOAR CAPS"]
18:52:04 <Entroacceptor> :t map
18:52:04 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
18:52:52 <int80_h> ah!
18:58:33 <dysinger> Is there a way to get cabal-install installed on ghc 7 from darcs ?
18:58:41 <dysinger> I get an error & bombs out
19:00:20 <tomberek> kmc:   data A c = NilA | A Int c;data B c = NilB | B Char c     --I had to add Nils to have a base.  Then I can make :t Fix2 (A 1 (Fix 2 (B 'a' (Fix2 NilA))))
19:00:56 <kmc> tomberek, you could avoid nils if you build cyclic data, or use "undefined"
19:00:59 <kmc> but otherwise, yes
19:01:20 <kmc> anyway, cool :)
19:01:48 <tomberek> kmc: ok, let me see what else i can make
19:01:59 <kmc> :D
19:02:15 <kmc> tomberek, when this gets boring you might look at the "multirec" library and the paper that comes with it
19:02:23 <kmc> "Alexey Rodriguez, Stefan Holdermans, Andres Lh, Johan Jeuring. Generic programming with fixed points for mutually recursive datatypes. ICFP 2009."
19:02:38 <tomberek> oh jeez
19:02:45 <kmc> it goes into advantages of this style, one advantage is that it's easier to build generic traversals
19:03:14 <tomberek> kmc: well, that was my goal, to write a mfold.. a fold for mutually recursive types
19:03:40 <kmc> cool :D
19:03:59 <kmc> does this mean you're approaching the event horizon of ICFP papers?
19:04:53 <tomberek> kmc: i can read them and understand the gist, but certain details elude me.
19:06:26 <tomberek> hey, the paper defines :  data Fix2 f g = In2 (f (Fix2 f g) (Fix2 g f)     so I must have messed something up
19:11:51 <kmc> tomberek, i meant, if the publication date of the ideas you've also come up with is increasing at a rate faster than unity
19:12:19 <kmc> tomberek, they probably have something else in mind
19:12:26 <kmc> it's not as if the name "Fix2" has one unambiguous meaning
19:12:37 <tomberek> ah,, yeah, problem is that my ability to translate the idea into a comprehensible and workable has a VERY LARGE constant
19:13:34 <tomberek> kmc: they have a generic fold that i'm reading about now, but I'm starting to lose comprehension
19:13:55 <kmc> yeah, that paper is fairly intense
19:13:59 <kmc> you'll need a good grasp of GADTs too
19:14:03 <kmc> don't know how familiar you are with those
19:14:57 <tomberek> i've played with them a little, it's the kinds and kind sup phi and *subAST that is throwing me for a loop
19:19:16 <lars9> how is the document generated? like http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Ix.html#t%3AIx
19:19:22 <ksf> @pl foo >>= return . fmap f
19:19:22 <lambdabot> fmap f `fmap` foo
19:19:42 <kmc> lars9, haddock
19:20:21 <tomberek> kmc: actually, reading the Related work revealed that my idea is 20 years behind.
19:20:34 <lars9> kmc: thanks, is it something like doxegen?
19:20:36 <ksf> IMMA GOING TO USE THAT AND NOT CARE ABOUT PEOPLE WHOSE MONADS ARENT FUNCTORS
19:20:56 <kmc> lars9, kinda.  i like it better than doxygen, but they handle different languages
19:21:09 <kmc> Haskell is a good language for this kind of docs because hyperlinked types tell you a lot
19:21:53 <lars9> kmc: i see, thanks:)
19:23:07 <kmc> when you upload packages to hackage they automatically get haddocked and if your comments aren't good then people will make fun of you
19:25:09 <amalloy> i'm testing a program that evaluates haskell code, but i don't know anything about haskell. can someone give me a simple program that generates non-tiny output? anything over 300 characters is fine
19:26:22 <kmc> amalloy, a full program, which prints to stdout?
19:26:45 <amalloy> kmc: it can just return the value
19:26:51 <amalloy> or evaluate to it, rather
19:26:52 <kmc> [1..1000]
19:27:01 <tomberek> hehe
19:27:01 <kmc> > [1..1000]
19:27:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
19:27:19 <amalloy> kmc: thanks! that was easy
19:27:36 <ksf> main = putString (replicate 300 'x')
19:28:08 <amalloy> kmc: hey, haven't seen you in #clojure for a while. give up on it?
19:29:06 <kmc> amalloy, not give up permanently, just doing other stuff
19:29:11 <kmc> i bounce from project to project, you know :)
19:29:17 <amalloy> bah!
19:29:27 <amalloy> real programmers do one thing at a time. multithreading is an illusion
19:30:00 <ksf> more than two things, at least.
19:30:09 <ksf> ...consciously.
19:31:41 <int80_h> so I have this, lookup "resourceId" findR. It only finds the first tuple to match. What can I do to have it iterate through the entire list?
19:31:43 <ksf> there's a sudden drop in short-term memory reliability and thus task switching speed for more than two tasks at a time, which they attributed to the fact that we only got 2 hemispheres.
19:32:23 <tomberek> kmc: have you read through Everything Is Everything Revisited: Shapeshifting Data Types with Isomorphisms and Hylomorphisms   Paul Tarau?
19:32:23 <ksf> int80_h, filter (=="resourceId") xs
19:32:25 <int80_h> I tried using map but I couldn't get it right and I don't think it's what I want
19:32:30 <kmc> no tomberek
19:32:32 <kmc> sounds interesting
19:32:46 <kmc> "Everything Is Everything Revisited" would be a good name for a psytrance album
19:32:53 <djahandarie> lol
19:32:55 <int80_h> xs is a [(x,y)] however
19:32:56 <Roklobsta> ksf: going by that - then according to my wife i have 0 hemispheres.
19:32:56 <djahandarie> psytrance ftw
19:33:06 <tomberek> kmc: it's interesting
19:35:38 <int80_h> ksf: findR is a [(x,y)]. Not sure how I can use filter in this case. Can I not use something meant to operate on tuples?
19:35:55 <int80_h> I *could use filter+fst+map I suppose
19:36:17 <int80_h> :t find
19:36:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
19:36:28 <int80_h> :t lookup
19:36:29 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:36:30 <kmc> :t filter (\(x,y) -> x == "resourceId")
19:36:31 <lambdabot> forall t. [([Char], t)] -> [([Char], t)]
19:36:44 <kmc> :t filter ((=="resourceId") . fst)
19:36:45 <lambdabot> forall b. [([Char], b)] -> [([Char], b)]
19:37:07 <int80_h> six of one, half dozen of the other. I dig.
19:39:51 <int80_h> map (filter (== 'resourceId') . fst) findR
19:40:01 <int80_h> ^ this yields a lexical error
19:41:12 <JoeyA> "resourceId"
19:41:47 <int80_h> type error now
19:42:12 <int80_h> findR is a [(String,String)]
19:42:23 <kmc> int80_h, yes, you're using ' rather than "
19:42:26 <kmc> ' is for single chars only
19:42:32 <JoeyA> filter ((== "resourceId") . fst)
19:42:44 <JoeyA> or, use lookup :-)
19:42:48 <int80_h> JoeyA, no map?
19:42:57 <int80_h> lookup only finds the first match
19:43:04 <JoeyA> filter traverses the list
19:43:13 <int80_h> not sure how to use lookup to find the rest
19:43:34 <JoeyA> > filter ((== "foo") . fst) [("foo", 5), ("bar", 6), ("foo", 7)]
19:43:35 <lambdabot>   [("foo",5),("foo",7)]
19:43:39 <int80_h> filter worked!
19:44:01 <int80_h> gotcha, thanks again
19:44:06 <JoeyA> Has anyone here used a TI-89 calculator?
19:44:24 <kmc> i have
19:44:54 <JoeyA> I wrote a lambda expression evaluator for the TI-89.  It draws from Haskell, but it's dynamically typed and rather limited.
19:45:00 <kmc> cool
19:45:08 <JoeyA> Also, sum (1..200) takes 1 second
19:45:16 <kmc> is it lazy or eager?
19:45:20 <JoeyA> lazy
19:45:26 <kmc> lexically scoped?
19:45:27 <JoeyA> and garbage collection doesn't always work
19:45:30 <JoeyA> yes, lexically scoped
19:45:31 <kmc> heh
19:45:37 <kmc> you wrote it in ti-basic?
19:45:43 <JoeyA> In C (TIGCC)
19:45:45 <kmc> ah
19:46:04 <kmc> wonder if you can get yhi to  build in tigcc
19:46:06 <JoeyA> I took some liberties
19:46:10 <JoeyA> \x x*x
19:46:13 <JoeyA> instead of \x -> x*x
19:46:18 <kmc> (being the interpreter for yhc's bytecode)
19:47:18 <JoeyA> if you want to play around with it, I'll be happy to host it :-)
19:47:25 <int80_h> is there a function that finds duplicate Ints in a [Int]?
19:47:50 <JoeyA> By the way, since it doesn't use static types, the Y combinator works with it.
19:47:59 <int80_h> I suppose if there were it would be in Data,List right?
19:48:07 <JoeyA> probably
19:48:11 <JoeyA> nub removes duplicates
19:48:13 <int80_h> I'll go look
19:48:19 <int80_h> ah!
19:48:23 <int80_h> there you go. thanks
19:48:28 <int80_h> :t nub
19:48:29 <lambdabot> forall a. (Eq a) => [a] -> [a]
19:48:29 <JoeyA> but it's O(n^2), bear in mind
19:48:31 <djahandarie> But it's inefficient for what you want
19:48:39 <djahandarie> :t sort
19:48:40 <lambdabot> forall a. (Ord a) => [a] -> [a]
19:48:42 <djahandarie> :t group
19:48:43 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
19:48:47 <djahandarie> Maybe these two would be more useful
19:48:48 <JoeyA> > (map head . group . sort) [1,5,2,1,3,5]
19:48:49 <lambdabot>   [1,2,3,5]
19:48:51 <kmc> :t S.toList . S.fromList
19:48:52 <lambdabot> forall a. (Ord a) => [a] -> [a]
19:49:00 <JoeyA> Indeed
19:49:15 <JoeyA> Is that one lazy, though?
19:49:21 <int80_h> you need to use head with map?
19:49:24 <kmc> prob not
19:49:25 <JoeyA> > (S.toList . S.fromList) [1..]
19:49:28 <lambdabot>   mueval-core: Time limit exceeded
19:49:29 <JoeyA> nope
19:49:55 <int80_h> > (head . group . sort) [1,5,2,1,3,5]
19:49:56 <lambdabot>   [1,1]
19:50:02 <ymasory> hi all. learn you a haskell says value constructors are just functions. but in that case wouldn't True/False be functions despite starting with upper-case letters?
19:50:05 <int80_h> > (map . group . sort) [1,5,2,1,3,5]
19:50:06 <lambdabot>   Couldn't match expected type `a -> b'
19:50:06 <lambdabot>         against inferred type `[[a1]]'
19:50:20 <kmc> ymasory, they are functions in most ways but are distinguished lexically
19:50:22 <int80_h> > map (group . sort) [1,5,2,1,3,5]
19:50:22 <lambdabot>   No instance for (GHC.Num.Num [a])
19:50:22 <lambdabot>    arising from a use of `e_1152135' at <...
19:50:26 <djahandarie> int80_h, you "need to" do whatever makes your types check
19:50:37 <int80_h> I see, yeah I have run into that
19:50:43 <kmc> they are functions in terms of type and what you can do with them
19:50:48 <kmc> except you can also pattern-match against them
19:50:57 <ymasory> kmc: so am i crazy in thinking all of haskell's literals are sort of functions too?
19:50:58 <int80_h> I have code that is there for not other reason than, if I leave it out, the type don't match
19:51:09 <tomberek> ymasory: yes, they are functions that take no arguments and return Ture and False respectively
19:51:12 <kmc> ymasory, and actually, 0-argument constructors aren't functions
19:51:13 <JoeyA> :let fastNub :: Ord a => [a] -> [a]; fastNub xs = loop xs S.empty where {loop [] _ = []; loop (x:xs) set = if x `S.member` set then loop xs set else x : loop xs (S.insert x set)
19:51:22 <JoeyA> @let fastNub :: Ord a => [a] -> [a]; fastNub xs = loop xs S.empty where {loop [] _ = []; loop (x:xs) set = if x `S.member` set then loop xs set else x : loop xs (S.insert x set)
19:51:22 <lambdabot>   Parse error: EOF
19:51:25 <tomberek> erg
19:51:27 <JoeyA> aw shaddup
19:51:28 <int80_h> oh snap!
19:51:33 <JoeyA> (I was talking to Haskell)
19:51:34 <kmc> there's no such thing as a 0-argument function; every function has exactly one argument
19:51:47 <kmc> so True and False are not functions
19:51:49 <int80_h> I knows, I was referring to the Parse Error ;)
19:51:49 <ymasory> ah interesting
19:51:51 <djahandarie> (In Haskell)
19:51:54 <ymasory> so what are they exactly?
19:51:54 <kmc> you can tell if something's a function by looking at its type
19:51:58 <JoeyA> :let fastNub :: Ord a => [a] -> [a]; fastNub xs = loop xs S.empty where {loop [] _ = []; loop (x:xs) set = if x `S.member` set then loop xs set else x : loop xs (S.insert x set)}
19:52:01 <kmc> ymasory, they're just values of type Bool
19:52:08 <kmc> 'x' is a value of type Char
19:52:15 <JoeyA> @let fastNub :: Ord a => [a] -> [a]; fastNub xs = loop xs S.empty where {loop [] _ = []; loop (x:xs) set = if x `S.member` set then loop xs set else x : loop xs (S.insert x set)}
19:52:16 <lambdabot>  Defined.
19:52:18 <JoeyA> yay!
19:52:26 <kmc> a value is a function iff its type is A -> B for some types A,B
19:52:36 <JoeyA> fastNub $ [1,2,3,1,5] ++ [100..]
19:52:43 <JoeyA> > fastNub $ [1,2,3,1,5] ++ [100..]
19:52:44 <lambdabot>   [1,2,3,5,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,11...
19:52:48 <kmc> cool
19:52:55 <JoeyA> > fastNub $ [1,2,3,1,5] ++ cycle [100]
19:52:56 <ymasory> i guess i'm just a little confused since value constructors with parameters are function or function-like, but then with no parameters it drops down to "just a value"
19:52:58 <lambdabot>   mueval-core: Time limit exceeded
19:53:04 <kmc> ymasory, why is that confusing?
19:53:10 <JoeyA> Anyway, that's the "nub" I recommend :-)
19:53:11 <kmc> functions are values too, of course
19:53:19 <JoeyA> Is there a way to foldrize it, by the way?
19:53:30 <ymasory> yeah true
19:53:38 <kmc> "Just" is a value of type "a -> Maybe a", which means it's a function
19:53:49 <kmc> "Nothing" is a value of type "Maybe a", which means it's not a function
19:54:06 <kmc> ymasory, when you define data types in GADT syntax (supported by a GHC extension) then this becomes clearer
19:54:17 <kmc> data Maybe a where { Nothing :: Maybe a; Just :: a -> Maybe a }
19:54:48 <ymasory> thanks kmc
19:54:51 <kmc> :D
19:54:52 <kmc> no problem
19:55:03 <ymasory> i think maybe we'll resume this line if it's still unclear to me in a week
19:55:09 <kmc> ok
19:55:16 <ymasory> that book is great, but it's a lot of information :)
19:55:51 <ymasory> speaking of which, how does BONUS like to get typo reports?
19:55:52 <kmc> ymasory, are you perhaps thinking of the term "constructor" as it's used in OOP?
19:56:03 <ymasory> trying not to
19:56:05 <osaunders> kmc: Is that a legal definition of Maybe?
19:56:05 <kmc> ok
19:56:09 <kmc> osaunders, with -XGADTs
19:56:14 <osaunders> Ah, OK.
19:56:30 <kmc> ymasory, in most OOP languages you would have 0-argument constructor functions, which might do some internal initialization
19:56:41 <kmc> but Haskell data is not like that; the data itself has no behavior baked in
19:56:56 <kmc> so there's no need for initialization code, hence no need for a function body
19:57:05 <kmc> operationally, all a constructor does is take args and store them somewhere
19:57:31 <kmc> and if there's no args, then there's effectively just one value hanging out there
19:58:06 <JoeyA> Can unsafeInterleaveIO be implemented with unsafePerformIO?
19:58:16 <ymasory> and what does haskell call the thing that does the storing? like what would you call 'a' in the 'let a = Person "ymasory"'
19:58:23 <kmc> a variable
19:58:33 <JoeyA> unsafeInterleaveIO = return . unsafePerformIO  ?
19:58:34 <kmc> JoeyA, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/System-IO-Unsafe.html
19:58:52 <JoeyA> Yep, I got it
19:58:56 <kmc> but not in GHC
19:58:56 <JoeyA> unsafeInterleaveIO f = return (unsafePerformIO f)
19:58:57 <ymasory> i guess in OO terms i'd say that 'a' is a variable pointing to an object
19:59:03 <ymasory> what is 'a' pointing to in haskell?
19:59:08 <kmc> a value
19:59:08 <new11> @check (\cond xs -> all cond (filter cond xs))
19:59:09 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
19:59:09 <lambdabot>    arising fro...
19:59:15 <JoeyA> so it doesn't work in GHC?
19:59:22 <kmc> except the "pointing to" part is invisible to the user
19:59:26 <JoeyA> As in, it might perform it twice or something?
19:59:30 <kmc> 'a' is a value, or stands for a value
19:59:38 <kmc> actually it stands for an expression that can be later forced to a value
19:59:40 <int80_h> > (map . group . sort) [1,5,2,1,3,5]
19:59:41 <lambdabot>   Couldn't match expected type `a -> b'
19:59:41 <lambdabot>         against inferred type `[[a1]]'
19:59:42 <kmc> though in this case there's no computation to be done
19:59:43 <int80_h> > (map . group . sort) [1,5,2,1,3,5]
19:59:44 <lambdabot>   Couldn't match expected type `a -> b'
19:59:44 <lambdabot>         against inferred type `[[a1]]'
19:59:49 * hackagebot sized-types 0.2.7.20101112 - Sized types in Haskell.  http://hackage.haskell.org/package/sized-types-0.2.7.20101112 (AndyGill)
19:59:52 <new11> @check (\cond xs -> all cond (filter cond xs))
19:59:53 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> GHC.Bool.Bool)
19:59:53 <lambdabot>    arising fro...
19:59:57 <kmc> JoeyA, don't know.  it might be for efficiency only
20:00:10 <ksf> the thing that's pointed to is also called a thunk
20:00:23 <kmc> in the case where it's a suspended computation, yeah
20:00:28 <kmc> but that's arguably an implementation detail
20:00:36 <ksf> ...which is either a computation or its result.
20:00:38 <djahandarie> :t (Prelude..)
20:00:39 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
20:00:42 <djahandarie> :t map
20:00:42 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:00:46 <kmc> we like to think of values, equations, and substituting equals for equals
20:00:51 <djahandarie> :t group
20:00:51 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
20:00:55 <djahandarie> int80_h, see those types
20:00:56 <ymasory> it seems like a case class without a body in scala, if that's a familiar analogy
20:01:00 <djahandarie> It should be clear why it can't compose
20:02:24 <kmc> JoeyA, see GHC.IO; seems there's no haddock for it though
20:02:44 <kmc> ymasory, dimly familiar, and i think it's accurate
20:03:01 <kmc> Scala attempts to merge a system of algebraic data and pattern matching with a system of OOP classes and objects
20:03:13 <kmc> they do a decent job, but it's definitely more complicated than either taken alone
20:03:28 <int80_h>  djahandarie : it is now
20:03:31 <kmc> so your analogy feels backwards to me, but i understand that's where you're coming from
20:04:29 <djahandarie> int80_h, also, now you should see why both 'map head' and 'head' in the first spot type-check.
20:04:30 <ymasory> yeah, scala is a useful bridge to this
20:04:50 <djahandarie> int80_h, but, 'head' alone is pretty useless in your case
20:05:30 <Aune> If I have an epimorphism om groups f: G --> L with kernel N, is G isomorphic to the product of L and N?
20:06:59 <Aune> Anyone know where to look for information on this?
20:12:51 <Jafet> Aune: right place, wrong time
20:13:14 <djahandarie> Aune, well, the quotient group G / N would be naturally isomorphic to the image of f, which is a subgroup of L
20:14:11 <tomberek> @src foldl
20:14:11 <lambdabot> foldl f z []     = z
20:14:11 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
20:15:11 <byorgey> djahandarie: if it's an epimorphism the image of f *is* L, right?
20:19:53 <ddarius> If Grp had exponents this would be trivial, though it isn't that hard to begin with.
20:21:35 <djahandarie> byorgey, aye, what I say should hold for any group homomorphism
20:27:44 <lars9> is Array a hash map internally?
20:28:34 <ddarius> No.
20:28:45 <aavogt> @src Ix
20:28:45 <lambdabot> class (Ord a) => Ix a where
20:28:45 <lambdabot>     range           :: (a,a) -> [a]
20:28:45 <lambdabot>     index           :: (a,a) -> a -> Int
20:28:45 <lambdabot>     inRange         :: (a,a) -> a -> Bool
20:28:45 <lambdabot>     rangeSize       :: (a,a) -> Int
20:28:48 <ddarius> Unless you view it as a "hash map" with a trivial hashing function.
20:29:26 <ksf> argh the hash issue
20:29:50 * ddarius is tired of languages calling complex data structures "arrays" or "lists" or calling lists arrays.
20:30:39 <djahandarie> All my lists are actually judy arrays.
20:30:48 <djahandarie> How tired are you now?
20:31:03 <ddarius> djahandarie: You're not a language.
20:31:11 <djahandarie> Foiled
20:31:25 <lars9> if it's not hashmap inside, will a large range cause waste of space?
20:31:40 <ksf> if your data is sparse, definitely.
20:31:52 <ddarius> lars9: It will behave just like you'd expect an array to behave.
20:31:54 <ksf> what you're looking for is a Map
20:32:18 <ksf> Array is just a quite thin interface on top of a chunk of memory
20:32:54 <lars9> let me test
20:39:00 <Aune> Im back, internet crashed
20:40:09 <Aune> can you repeat what you said byorgey and ddarius
20:41:20 <byorgey> Aune: djahandarie noted that the quotient group G / N would be naturally isomorphic to the image of f
20:41:45 <byorgey> but if I'm recalling correctly what epimorphism means in this context, the image of f is L
20:42:03 <Aune> yes, it is onto
20:42:51 <byorgey> so I think that answers your question in the affirmative although I am not 100% sure
20:43:55 <Aune> ok, any idea about how one would go about to try to prove this?
20:50:47 <koninkje> what was the question?
20:51:29 * koninkje thinks it sounds suspiciously like something proved earlier this semester
20:51:35 <Aune> wait, I think Im being stupid... If  f:G --> L onto with kernel H then L * H isomorphic to H * (G/H) which is trivialy isomorphic to G
21:08:59 <Cale> Aune: What was the original question?
21:09:08 <Cale> <Aune> If I have an epimorphism om groups f: G --> L with kernel N, is G isomorphic to the product of L and N?
21:09:29 <Cale> No, not in general.
21:10:14 <Cale> Consider D_6, and the epimorphism onto Z_3.
21:10:18 <Aune> why not?
21:10:26 <Cale> Or D_3 if you prefer
21:10:43 <Cale> (depending on whether you use subscripts of n or 2n on your dihedral groups)
21:11:25 <Cale> D_3 isn't isomorphic to Z_3 x Z_2, but there's an epi onto Z_3 with kernel isomorphic to Z_2.
21:11:45 <Cale> (It's a semidirect product.)
21:11:55 <Cale> That's actually still nicer than the general case.
21:12:25 <Aune> Ok
21:12:32 <Cale> Er, actually...
21:12:48 <Cale> You might always get a semidirect product.
21:14:41 <Aune> Im not entierly certain how to interpret that
21:19:38 <Cale> Aune: Which part? I'm actually unsure it's true that G would be a semidirect product of N and a subgroup isomorphic to L.
21:20:10 <Aune> So, in the general case it is not true that that the direct product of H and G/H is isomorphic to G.
21:20:30 <Cale> Oh, of course it's true... that follows from the splitting lemma. We have a short exact sequence 1 -> N -> G -> L -> 1
21:21:09 <Cale> But right, taking groups apart is easier than putting them back together again ;)
21:21:17 * hackagebot netlist 0.2 - Netlist AST  http://hackage.haskell.org/package/netlist-0.2 (PhilipWeaver)
21:21:26 <Cale> In fact, this a major problem with group theory as it stands.
21:21:52 <Cale> We have lots of information about how to take groups apart into factors, but very little is known about how to put the groups back together again once you've done that :P
21:21:54 <Aune> But it MIGHT be true that the semidirect product of H and G/H are isomorphic to G in those cases. 
21:21:58 <Cale> Yes
21:23:18 * hackagebot netlist-to-vhdl 0.2 - Convert a Netlist AST to VHDL  http://hackage.haskell.org/package/netlist-to-vhdl-0.2 (PhilipWeaver)
21:24:06 <Aune> Looking at this: http://en.wikipedia.org/wiki/Semidirect_product  it seems that
21:25:13 <Aune> "There exists a homomorphism G  H which is the identity on H and whose kernel is N." implies G is the semidirect product of  N and H
21:25:18 <Cale> Actually, I've checked now, it's always true. If you have an epimorphism G -> L with kernel N, then there's a short exact sequence of homomorphisms 1 -> N -> G -> L -> 1 (exact means that the composite of any pair of adjacent homs in the sequence composes to the constant hom), and the splitting lemma says that you get such a short exact sequence iff G is a semidirect product of N and L
21:25:49 <Cale> Right.
21:37:14 <joe6> /quit/quit
21:39:21 <meditans> Hi, I have a question about general functional-programming style
21:40:05 <meditans> it's happening to me that the better i learn Haskell the worst i manage to structure my programs
21:40:30 <meditans> an example: a program that plays a card game
21:40:48 <meditans> data structure for cards, decks, are just perfect
21:41:20 <meditans> but how have I to structure the entire flow? Where exactly comes in the IO Monad for random numbers?
21:42:05 <byorgey> don't use the IO monad for random numbers, use the Random monad
21:42:10 <meditans> could you suggest me a reading to fix this problems?
21:42:13 <byorgey> from the MonadRandom package
21:42:33 <byorgey> keep everything pure as long as possible, and bring in IO only at the very end
21:42:42 <meditans> but it still returns the result wrapped into the IO Monad, doesn't it?
21:43:11 <byorgey> what does?
21:43:29 <meditans> i mean, could i write a function, say shuffle :: Deck -> Deck
21:43:31 <Cale> meditans: Well, you'd write some computation in the Random monad which would compute, say, a whole random deck, and then you'd possibly run it from IO.
21:43:42 <Cale> shuffle :: Deck -> Random Deck
21:44:00 <Cale> (Or, iirc, it was Rand Deck)
21:44:18 <meditans> ah.. got it, i'm going to study that monad
21:44:34 <Cale> Oh, or maybe Rand StdGen Deck
21:44:41 <meditans> but could you addres me towards a general purpose reading about structuring functional programs?
21:44:54 * ddarius decides to make one called Rndom just to make things difficult.
21:44:56 <Cale> (or, more polymorphically,  (RandomGen g) => Rand g Deck
21:45:57 <JoeyA> Is there any case where foldl is better than foldl', except maybe in code golf?
21:45:59 <Cale> meditans: A common approach to take is to try to come up with a language in which you'd like to express your problem, construct some syntax for that language in some fashion, embedded in your functional programming language somehow, along with an interpreter which solves the problem.
21:46:19 <Cale> So, we reduce every problem to the problem of writing an interpreter ;)
21:46:39 <meditans> could you make a specific example?
21:46:55 <Cale> Sure. Let's consider a program for dealing with recipes for food.
21:47:37 <meditans> ok
21:47:38 <Cale> You'll want a language with primitives that consist of basically the various ingredients you could use.
21:47:52 <Cale> and combining functions which do various things to them (mix, bake, etc.)
21:47:58 <ddarius> JoeyA: Theoretically, yes, but practically, no.
21:48:09 <tomberek> JoeyA i think foldl' is almost always better
21:48:35 <Cale> and then you could have various 'interpreters' for this language which do useful things with the recipes, like compute calories, or print an English language description of how to make it
21:49:14 <Cale> For a program that plays card games, perhaps some sort of language for expressing the rules of card games would be appropriate.
21:49:40 <Cale> (especially in the case of solitaire games, of which there are many minor variations with common structure)
21:49:42 <ddarius> Does your interpreter count the calories burned mixing?
21:49:49 <Cale> ddarius: :)
21:49:58 <Cale> ddarius: baking would be even harder :)
21:50:14 <drhodes> mutable cake
21:50:19 <meditans> cale: got the point.. i will think about
21:50:33 <tomberek> odd coincidence, I just finished a batch of cookies and a six pack... how many calories did I burn with that?
21:50:42 <Cale> meditans: I'm not saying that this is necessarily how you should do it, but it's one major approach which is worth considering.
21:51:07 <Cale> meditans: Programs written in this way tend to be much more flexible to changes in design requirements.
21:51:45 <meditans> have you an example in mind where I can see this approach in real code?
21:52:20 <Cale> meditans: Well, there was a paper and an excellent talk about using this approach with financial contracts.
21:52:31 <Cale> There are some libraries on Hackage too...
21:52:42 <JoeyA> class MutableCakeIterator extends AbstractMutableCakeIterator
21:52:50 <Cale> http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/1.4.1/doc/html/Graphics-DrawingCombinators.html -- this is a nice example
21:53:09 <Cale> http://hackage.haskell.org/packages/archive/data-memocombinators/0.4.0/doc/html/Data-MemoCombinators.html -- another really nice example (by the same guy even ;)
21:54:12 <Cale> Oh, of course you'll want to look at Parsec, which is a library for building parsers from simpler parsers (turns out to be much nicer than using regular expressions in most if not all cases)
21:55:12 <Cale> Let me get that talk...
21:55:26 <meditans> sure, thanks :)
21:55:31 <Cale> http://ulf.wiger.net/weblog/2008/02/29/simon-peyton-jones-composing-contracts-an-adventure-in-financial-engineering/
21:56:46 <Cale> There's also Lava, a library for constructing descriptions of digital circuits, which can then do stuff with the descriptions like simulating the circuit, or it can emit VHDL code which one can then use to program an FPGA with it.
21:57:26 <meditans> thanks a lot.. i'm going to listen to it :)
22:00:47 <ddarius> I don't think I've ever actually watched that talk, which is insanity because an SPJ talk would be entertaining even if you didn't care at all about the content.
22:01:04 <Cale> Oh, and cryptol, a language which has actually grown to the point of being a separate language from Haskell (but very closely related), used for expressing cryptographic algorithms in such a way that they can then be tested directly, converted to VHDL, C, or Haskell code, and it can check the specification given against another implementation.
22:05:03 <Cale> meditans: I can't give you the code for it, but in my work on this iPhone game, I have a domain specific language and a simple "interpreter" for it used to express user interface widgets in the game in a compositional manner.
22:06:24 <Cale> The language primitives are expressed as a GADT (not really for any fundamental reason apart from the fact that it helped to organise my thoughts about what was primitive as I designed the library.)
22:06:42 <Cale> Well, primitives and primitive combiners.
22:12:43 <funkyjunkyrobot> howdy
22:20:08 <mm_freak> we call functions like (a -> b) -> (a -> b) higher order functions  what do we call functions like Monad m => m a -> m a?
22:20:24 <mm_freak> in other words, what's the generalization of "higher order function" to arbitrary monads?
22:26:20 <funkyjunkyrobot> i need help sorting a list of list of ints
22:27:05 <Jonno_FTW> funkyjunkyrobot: map sort xs ?
22:27:23 <Jonno_FTW> or do you want to sort them differently?
22:27:40 <funkyjunkyrobot> well basicaly i need to sort them in different ways
22:27:52 <Jonno_FTW> perhaps sort $ map sort xs
22:28:27 <Jafet> I would finish listening to robot's question first
22:28:55 <Jonno_FTW> ok
22:28:57 <funkyjunkyrobot> so it's a list of list of ints so it always has 3 ints in an element and the 1st, 2nd, 3rd element sin a sub list have different meaning size, shape, weight. and i want to be able to sort by either size, shape, or weight, or any combination of them. like if they are same size, then sort by weight next
22:29:03 <mm_freak> arbitrary suggestions and code examples aren't very helpful, Jonno_FTW 
22:29:32 <Jonno_FTW> sorry
22:29:33 <mm_freak> funkyjunkyrobot: sortBy
22:29:49 <mm_freak> using that function you can supply your own comparison function
22:29:55 <funkyjunkyrobot> ahh
22:29:58 <Jafet> funkyjunkyrobot, consider using a tuple instead.
22:30:12 <mm_freak> > sortBy (compare `on` snd) [(1,2), (1,4), (2,3)]
22:30:13 <lambdabot>   [(1,2),(2,3),(1,4)]
22:30:14 <Jafet> Lists are intended to contain objects with the "same meaning".
22:30:29 <funkyjunkyrobot> well i don't need a tuple cuz they are all ints
22:30:38 <mm_freak> funkyjunkyrobot: it's not about needing
22:30:42 <funkyjunkyrobot> ok
22:30:48 <mm_freak> tuples are more suitable
22:31:00 <mm_freak> or would you represent a pair of coordinates as a list?
22:31:07 <mm_freak> they have the same type, too
22:31:39 <funkyjunkyrobot> ok, i see what your saying
22:31:55 <funkyjunkyrobot> let me play with those ideas for a bit , thanks
22:32:00 <funkyjunkyrobot> :)
22:32:12 <mm_freak> have fun =)
22:33:38 <mm_freak> funkyjunkyrobot: you might want to use an ADT for this:  data Figure = Figure { figSize :: Double, figShape :: Shape, figWeight :: Double }
22:33:53 <mm_freak> and:  data Shape = Point | Circle | Star
22:34:21 <funkyjunkyrobot> hmm
22:34:21 <mm_freak> that gives you more type safety and more readable code
22:34:42 <funkyjunkyrobot> basicaly i'm working on an assignment
22:34:47 <funkyjunkyrobot> and it is kinda of confining
22:35:34 <funkyjunkyrobot> we are fed these lists of lists of ints [ [1,20,34],[0,1,22],[1,33,2] ] for example
22:35:55 <funkyjunkyrobot> the first number in the sub list is the shape of a train track, 1 = straight, 0 = curved
22:36:14 <funkyjunkyrobot> and the 2nd is weight, and the 3rd is strength rating
22:36:24 <funkyjunkyrobot> and i cannot change that they are in lists
22:36:58 <funkyjunkyrobot> and we are also fed orders as lists of characters
22:37:02 <mm_freak> stupidRepresentationToHaskellRepresentation :: [[Double]] -> [Figure]
22:37:03 <mm_freak> ;)
22:37:09 <funkyjunkyrobot> so we may get a list like this
22:37:46 <funkyjunkyrobot> [s,w,m]  sugesting it is sorted by size, then weight, then material strength
22:37:50 <funkyjunkyrobot> hmm
22:37:50 <Jafet> mm_freak: homeworkToHaskell
22:38:26 <funkyjunkyrobot> i know it must be anoying to hear homework questions all the time :(
22:38:40 <Zeiris_> :t (<+>)
22:38:41 <lambdabot>     Ambiguous occurrence `<+>'
22:38:41 <lambdabot>     It could refer to either `Control.Arrow.<+>', imported from Control.Arrow at State/L.hs:5:0-19
22:38:41 <lambdabot>                           or `Text.PrettyPrint.HughesPJ.<+>', imported from Text.PrettyPrint.HughesPJ at State/L.hs:53:0-46
22:38:44 <funkyjunkyrobot> it's not a haskell class it's just the teacher threw haskell at us and thought we'd be able to pick it up quick
22:38:50 <mm_freak> stupidOrderingToHaskellOrdering :: [String] -> [FigureOrdering]
22:39:09 <mm_freak> data FigureOrdering = ByShape | ByWeight | BySize
22:39:43 <mm_freak> figureOrdering ByShape = compare `on` figShape
22:39:44 <mm_freak> etc.
22:40:07 <mm_freak> orderFigures o = sortBy (figureOrdering o)
22:40:31 <mm_freak> learn to express problems in haskell first, then it will be much easier to solve them in haskell
22:40:47 <mm_freak> haskell is a lot about expression and language
22:40:55 <koninkje> :t (Control.Arrow.<+>)
22:40:56 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowPlus a) => a b c -> a b c -> a b c
22:41:02 <koninkje> huh
22:41:09 <funkyjunkyrobot> i know, it looks so elegant but it's hard to wrap my head around
22:41:46 <mm_freak> well, the code samples don't solve your problem, but they give you some hints as to what it will look like, when you solve it properly =)
22:41:55 <mm_freak> at least that's /one/ way to solve it properly
22:42:01 <funkyjunkyrobot> yeah
22:42:35 <mm_freak> first thing you should do is:  convert the list of lists you get into a better representation
22:42:36 <funkyjunkyrobot> so if i define a byShape then if i get two shapes that are equal can i have it then look at the weight?
22:42:52 <funkyjunkyrobot> to decide order?
22:43:09 <mm_freak> yes, you can
22:43:20 <mm_freak> or, if you're lazy, you can just sort multiple times
22:43:40 <mm_freak> at least, if you use a stable sorting method
22:44:02 <Jafet> GHC's sort is stable, but hs98's isn't I think
22:44:08 <ClaudiusMaximus> :t mconcat [comparing snd, comparing fst] 
22:44:09 <lambdabot> forall a b. (Ord b, Ord a) => (a, b) -> (a, b) -> Ordering
22:44:11 <funkyjunkyrobot> i'm using ghc
22:44:29 <mm_freak> ClaudiusMaximus: ah yes, good point
22:45:51 <funkyjunkyrobot> ok, well i do need some time to process this 
22:46:24 <funkyjunkyrobot> i don't understand some basics like `on` or the Ordering as a type
22:46:34 <funkyjunkyrobot> is Ordering a type?
22:46:39 <funkyjunkyrobot> or is that defined by me
22:47:03 <jmcarthur> @src Ordering
22:47:03 <lambdabot> data Ordering = LT | EQ | GT
22:47:20 <jmcarthur> :t on
22:47:21 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
22:47:22 <jmcarthur> @src on
22:47:22 <lambdabot> (*) `on` f = \x y -> f x * f y
22:47:41 <jmcarthur> :t compare
22:47:42 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
22:47:43 <jmcarthur> :t comparing
22:47:44 <Jafet> I love that definition
22:47:44 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
22:47:49 <jmcarthur> @src comparing
22:47:49 <lambdabot> Source not found. Where did you learn to type?
22:47:54 <jmcarthur> poo
22:48:22 <jmcarthur> Jafet: people don't use operators as variables very often
22:48:44 <funkyjunkyrobot> thanks
22:48:53 <ksf> any haskell list sort should be stable as it just doesn't make sense to use anything but mergesort.
22:49:05 <jmcarthur> ksf: i think the report uses insertion sort
22:49:07 <Jafet> GHC's used to be a stable (?) quicksort
22:49:08 <jmcarthur> still stable
22:49:21 <Jafet> Does hs98 require it to be stable?
22:49:22 <ksf> quicksort on lists?
22:49:44 <jmcarthur> Jafet: if the report's sort is stable then i would expect that any implementation must also be stable
22:49:48 <Jafet> Yeah, quicksort is easier to write than mergesort even. And easier to dos, of course.
22:49:52 <jmcarthur> ksf: why not?
22:50:02 <ksf> because quicksort relies on mutation
22:50:07 <jmcarthur> oh this again
22:50:11 <Jafet> jmcarthur: hrm, seems audacious to me to infer that sort of thing
22:50:16 <jmcarthur> some say it does. some say it doesn't
22:50:41 <Jafet> if ksf then let partitionsort = quicksort in
22:50:44 <ksf> I agree with the standard saying sort is stable, though.
22:50:44 <jmcarthur> Jafet: the report gives source code for the standard functions. i would expect implementations to at least guarantee the same behavior as the implementations given in the report
22:51:27 <Jafet> Okay. I didn't know the report worked like that.
22:51:39 <Jafet> I guess it's better than using english in a sense
22:52:09 <jmcarthur> Jafet: in fact, this is the reason that sum is still defined with foldl instead of foldl
22:52:14 <jmcarthur> *instead of foldl'
22:53:22 <jmcarthur> but it's okay in practice. GHC with optimizations can strictify it most times it's a good idea to
22:53:38 <ksf> h2010's prelude should be mergesort, anyway, as it was copied verbatim from the ghc sources.
22:54:25 <ksf> I doubt they refactored it to be less efficient.
22:56:50 <ddarius> Taking the Report definition of sort too normatively would be rather restrictive.
22:59:27 <ddarius> In fact, I'm pretty sure merge sort is not semantically equivalent to insertion sort.
23:01:39 <Jafet> Well, insertion sort isn't lazy, for one thing
23:02:25 <ksf> non-stability would be a major semantic issue
23:03:05 <ksf> I doubt differences in laziness, in particular more laziness would be an issue.
23:03:32 <Jafet> @src sort
23:03:33 <lambdabot> sort = sortBy compare
23:03:37 <Jafet> @src sortBy
23:03:37 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
23:03:46 <Jafet> @src insertBy
23:03:47 <lambdabot> insertBy _   x [] = [x]
23:03:47 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
23:03:47 <lambdabot>                                  GT -> y : insertBy cmp x ys'
23:03:47 <lambdabot>                                  _  -> x : ys
23:04:23 <Zeiris_> Where can I find documentation on using the Text-Regex-Base/TDFA libraries? I'm utterly mystified by the signatures of =~ and =~~, and random typing isn't fixing it.
23:04:47 <ksf> you just shouldn't, use a proper parsing library.
23:05:06 <Zeiris_> That would be overkill for what I want to do.
23:05:14 <ksf> no it isn't.
23:05:25 <Zeiris_> (Generate a graphviz module dependency graph based on module:func( calls in Erlang.
23:05:28 <Zeiris_> )
23:05:51 <Zeiris_> Yes, yes it is. I've been down this road before. "Oh, you want to take some input from a user? Here, use Parsec!"
23:05:56 <ksf> if you don't want the whole parsec shebang, use attoparsec. 
23:06:04 <Zeiris_> *drowns in fifty different library variations*
23:06:11 <ksf> there's two.
23:06:18 <Jafet> I usually use ReadP
23:06:42 <Zeiris_> As much as I love parsec, I strongly doubt it will produce shorter, simpler, or better code in this case.
23:06:51 <ksf> or, actually, uulib. which could use a more beginner-friendly interface but when it comes to usage it beats everything out there.
23:07:00 <Jafet> @hoogle (=~)
23:07:00 <lambdabot> Text.Regex.Posix.Wrap (=~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
23:07:00 <lambdabot> Text.Regex.Posix.Wrap (=~~) :: (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target, Monad m) => source1 -> source -> m target
23:07:23 <ksf> using regexen that can parse more than regular grammars is immoral, anyway.
23:07:41 <Zeiris_> This is gonna end with me having to read a paper ain't it.
23:07:56 <ksf> the nice thing of an applicative interface is that you get your data in a useable form with minimum fuzz.
23:08:00 <Jafet> That signature doesn't look too overwhelming.
23:08:02 <Zeiris_> Goddamn it, it's friday night and I'm tired, can't I just write a simple regex using that nifty-looking =~ operator and be done :'(
23:08:43 <ddarius> =~ is a monstrosity.
23:08:52 <Jafet> I have no idea what it does mean, though.
23:09:20 <Zeiris_> It means using type classes to implement generic interfaces doesn't seem to work out :[
23:10:19 <ddarius> =~ is a monstrosity because it's insane, not because it uses type classes to implement "generic interfaces."  The interface is completely ad-hoc.
23:10:37 <ksf> Zeiris_, http://hpaste.org/41415/webidl
23:10:49 <ksf> a uu-lib based parser for webidl to give you the gist of the usage.
23:10:57 <ksf> no "try" necessary, anywhere.
23:11:10 <ksf> ...error correction comes for free.
23:11:31 <Saizan> http://hackage.haskell.org/packages/archive/regex-compat/0.93.1/doc/html/Text-Regex.html <- if you're ok with regex-posix this interface is less insane.
23:11:55 <Jafet> Yeah, you can always use the regular regular expression interface.
23:12:10 <Zeiris_> ksf, I remember reading a paper (or possibly more than one) about the uu parser. It sounded fun and all, but... All I want to do is find occurances of "[a-z]:[a-z]" in a file. Is this really the nail for the parser combinator hammer?
23:12:39 <ksf> why not?
23:12:52 <ksf> a regex compiler isn't less heavyweight.
23:13:01 <ksf> readP would be.
23:13:15 <Zeiris_> The resulting code though - people who've never seen Haskell before can glance at a simple regex and know what it does.
23:14:52 <Jafet> You are writing this code for people who've never seen Haskell before?
23:16:46 <Zeiris_> No, but when people who haven't seen it much end up seeing it, I'd like 'em to go "oh he finds some files, regexes through them, then stores the results in a map which he then dumps to disk in graphviz format". I don't know what the uu-lib equivalent of that regex would be, but I doubt it's as clear in purpose.
23:16:57 <ddarius> My grip grows stronger.
23:17:42 <adu> Zeiris_: sounds like standard reengineering to me
23:18:12 <Zeiris_> Well, the main problem is that the problem is best suited for a perl script :)
23:19:03 <ksf> let az = pList . pSym $ ('a','z') in (,) <$> az <* pSym ':' <*> az
23:19:15 <ksf> ...supposing you want to capture the strings.
23:19:25 <adu> doesn't =~ do both searching and replacing depending on the rvalue?
23:19:47 <ksf> replace (,) with whatever you like.
23:20:48 <adu> Zeiris_: load some perl6 from pugs :)
23:22:38 <ksf> then you call exec on that thing and get a parse result, with a lazy list of corrections needed to get to it.
23:23:20 <Zeiris_> Reading uulib docs to figure out where exec is atm :( I hate to admit it, but that's about as readable as a regex.
23:24:02 <ksf> the best thing is that it won't blow up into your face as soon as it gets even slightly complicated.
23:24:25 <Zeiris_> The best thing is it has a haddock docs without docs, just type signatures.
23:24:33 <ksf> yeah.
23:24:46 <Saizan> btw, that's more like "[a-z]*:[a-z]*" than "[a-z]:[a-z]"
23:24:48 <ksf> ...that's why I gave you my paste.
23:24:57 <ksf> oh, yes.
23:24:58 <Zeiris_> :)
23:26:03 <Zeiris_> Is there anything with a high level overview of what each module in uulib does?
23:26:18 <ksf> don't copy my tokenising approach, though.
23:26:26 <ksf> you only need UU.Parsing
23:26:56 <Zeiris_> Aaah.
23:30:08 <Zeiris_> How do I handle skipping over text I'm uninterested in, and getting multiple results? Are there things besides parseIO I should be looking at?
23:31:12 <lars9> Is Array the only data structure which support recursive lazy evaluation?
23:32:11 <ksf> Zeiris_, are you looking at uulib or uu-parsinglib?
23:32:25 <Zeiris_> The first :\
23:32:59 <ksf> the latter is the new version with the cool paper
23:33:17 <Zeiris_> And documentation besides the paper! :D
23:33:18 <ksf> ...but the module I mentioned disappears in 2.5.3
23:34:02 <ksf> just use the top-level package.
23:34:04 <kilimanjaro> :t fst
23:34:05 <lambdabot> forall a b. (a, b) -> a
23:34:08 <kilimanjaro> :t snd
23:34:09 <lambdabot> forall a b. (a, b) -> b
23:34:14 <kilimanjaro> hmmmmmmmmmmmm
23:34:30 <ksf> you need pSym, things out of Derived like pList, the appicative-like combinators, and exec.
23:34:35 <Rhisa> Is it true?
23:35:07 <ksf> where's exec
23:35:21 <Quadrescence> :t mapAccumL
23:35:22 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
23:35:29 <Rhisa> In another channel someone was doing ASCII art and it got messed up. So he got mad and said that this channel wouldn't stand for it, that the person he is angry at is lucky to be in that channel: http://www.lulzbrigade.com/node/762
23:35:30 <Quadrescence> ah
23:35:39 <Rhisa> Oh crap, Quadrescence hi.
23:35:47 <ksf> oh, I copied it out of the examle.
23:35:59 * Rhisa nervous twiddles thumbs, "I thought you were going to come here to.. you know.."
23:37:30 <Zeiris_> @search exec
23:37:30 <lambdabot> Unknown command, try @list
23:38:16 <Zeiris_> ksf, which version/module is exec in?
23:38:25 * ksf would like to point out the fact that he's using a proportional font, because multi-line ascii art doesn't belong into IRC
23:39:05 <ksf> Zeiris_, in the code I pasted. I copied that out of the examples.
23:39:23 <ksf> just use run from UU.Examples, I think.
23:40:49 <Zeiris_> So, skipping until a match occurs is handled by error correction?
23:40:53 <Quadrescence> :t mapM_
23:40:54 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
23:41:36 <ksf> well, you could probably do that. but I'd judge it dirty.
23:41:53 <ksf> pAnyChar = pSym (\(_::Char) -> True, "any character", undefined::Char) 
23:42:30 <ksf> put pList_ng pAnyChar at the beginning and you're done.
23:42:37 <ksf> ...and before eof.
23:45:31 <Zeiris_> With pList_ng being... A non-greedy combinator. Huh.
23:45:42 <Zeiris_> That's kinda neat. How efficient will this be compared to a regex though?
23:46:18 <lars9> is there any data structure other than Array (assume as SomeMap) which stores key->value pairs and supports recursive evaluation: somemap = fromList [(x, if x==0 then ... else somemap!(x+1)) | x<-[1..100]] ?
23:46:54 <ksf> unless you use error-correction uu is speedy.
23:47:00 <Saizan> lars9: an immutable Trie
23:47:20 <Saizan> lars9: or a list
23:47:45 <Saizan> http://hackage.haskell.org/package/MemoTrie
23:48:17 <lars9> Saizan: do you understand how MemoTrie works? its source code is simple but i can not understand
23:48:47 <Saizan> also, what you wrote there should work even with Data.Map
23:49:52 <Saizan> the Trie has the advantage that, at least in theory, can handle unbounded domains
23:50:36 <lars9> Saizan: yeah, it does work on map..
23:51:26 <Saizan> it'll work with any container that is not strict on the values, which is most of them
23:52:44 <Saizan> http://conal.net/blog/posts/elegant-memoization-with-functional-memo-tries/ <- this is the author explaining MemoTrie
23:53:13 <ddarius> > let a = listArray (0,10) (3:[a!(i-1) | i <- [1..10]] in a
23:53:14 <lambdabot>   <no location info>: parse error on input `in'
23:53:25 <ddarius> > let a = listArray (0,10) (3:[a!(i-1) | i <- [1..10]]) in a
23:53:26 <lambdabot>   array (0,10) [(0,3),(1,3),(2,3),(3,3),(4,3),(5,3),(6,3),(7,3),(8,3),(9,3),(...
23:54:19 <lars9> Saizan: i read that post, but it does not explain how MemoTrie works, am i right?
23:54:27 <ddarius> > let a = listArray (0,10) (1:[2*(a!(i-1)) | i <- [1..10]]) in a
23:54:28 <lambdabot>   array (0,10) [(0,1),(1,2),(2,4),(3,8),(4,16),(5,32),(6,64),(7,128),(8,256),...
23:54:31 <Saizan> lars9: it does..
23:55:56 <Saizan> it's a bit terse on why it works
23:56:15 <Saizan> you could read the linked papers maybe
23:57:15 <lars9> yeah, it seems only the paper explains
23:57:44 <ddarius> Silly authors, thinking that people will read what they write.
