00:00:36 <raceRider> so I have to generate an id for the newMap; BTW, I'm totally new to state and don't know that would be implemented
00:01:10 <Lemmih> Generate an id for the newMap?
00:01:58 <dancor> raceRider: it might help if you post more code
00:02:01 <Lemmih> Btw, what we're talking about isn't particular to Data.Map. It is how everything is done in Haskell.
00:02:09 <raceRider> the var newMap, the left hand side of let expression. Can that be constant for each invocation.
00:03:00 <raceRider> I'm just playing with ghci right now, with no code but snippets that I put on hpaste. sorry.
00:06:48 <Saizan> raceRider: just use recursion
00:10:03 <Saizan> e.g. "foo themap ((k,v):kvs) = let newmap = insert k v themap in foo newmap kvs; foo themap [] = themap;" now if you evaluate "foo empty xs" you'll create (length xs) intermediate maps, but you only named two of them.
00:11:21 <Saizan> (the recursive call should be "(foo $! newmap) kvs" actually, since you want to be strict there otherwise you get a stack overflow)
00:14:13 <raceRider> Saizan, yes indeed the strict is what I need. Didn't know how to phrase the question. Thanks.
00:15:06 <Saizan> ..it doesn't seem related to your original question
00:16:04 <Axman6> raceRider: where are you learning haskell from?
00:16:37 <Saizan> http://hpaste.org/41188/datamap <- about this you could use shadowing to get an effect similar to altering kvPairs, which you won't though
00:16:50 <raceRider> because I was not using the right haskell terminology: the pairs are being built using !! indexes and I want them strict 
00:16:59 <Saizan> "kvPairs <- return $ insert 5 'x' kvPairs"
00:17:21 <Axman6> raceRider: i don't thik you're using those words correctly...
00:17:56 <Axman6> think*
00:18:22 <Axman6> raceRider: may i suggest you have a look at a tutorial that explains the basic concepts behind haskell, like:
00:18:28 <Axman6> @where lyah
00:18:28 <lambdabot> http://www.learnyouahaskell.com/
00:19:21 <raceRider> yeah, I was looking at that especially the Data.Map section. But of course at the cost of not understanding the earlier stuff. 
00:20:16 <Axman6> time to understand the earlier stuff ;)
00:31:27 <tonkman> does someone know any tutorial using win32 gui library
00:31:37 <tonkman> or example code or anything that uses it
00:55:46 <Funktorsalat> code.haskell.org appears to be down
01:21:57 <solistic> Does anybody now of a framework to test the external behavior of a programm, say to make assertions lik `cp --foo` == "cp: unrecognized option '--foo'"
01:22:06 <solistic> (dose not have to be haskell-specific)
01:22:35 <solistic> s/now/know
01:25:03 <Jafet> You don't need to test that... just use getopt
01:26:07 <solistic> Jafet: I may still fail on certain conditions, right?
01:27:07 <Jafet> You fail... conditions? What does that mean?
01:28:05 <solistic> Jafet: say if a port is not a number
01:28:22 <solistic> Jafet: or if there are unexpected 'file' arguments left..
01:29:54 <Jafet> If you really want to test that stuff, there is expect
01:33:16 <solistic> Jafet: do you mean "expect - A program that can automate interactive applications"
01:34:21 <solistic> Jafet: and yes, I want to test that, I typed it already more then once, so it should be automated ;)
01:34:39 <Jafet> If it also mentions that you need to learn a weird string hacking language named tcl, then you're at the right plac
01:34:40 <Jafet> e
01:36:09 <solistic> Jafet: yes, it does, thx
01:41:20 <portnov> hi all
01:42:06 <portnov> Q: how do I get file modification time? I'm looking for portable and not-deprecated way.
01:43:13 <Saizan> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/directory-1.0.1.1/System-Directory.html#v%3AgetModificationTime <- ?
01:44:56 <portnov> Saizan: good, but it returns ClockTime type from «old-time» package, which is marked as deprecated :/
01:51:54 <pelotom> I seem to see the term "morally" used in a particular way in computer science writing... can someone explain what that means precisely?
01:52:12 <pelotom> e.g. in the comment by Shan under this post: http://www.randomhacks.net/articles/2007/03/05/three-things-i-dont-understand-about-monads
01:53:53 <Veinor> pelotom: I think it means 'if it doesn't hold you're doing something immoral'
01:54:35 <pelotom> immoral in what sense? using it inappropriately?
01:54:41 <Veinor> yeah
01:54:46 <pelotom> hm, ok
01:54:48 <Veinor> like using unsafePerformIO is immoral
01:54:58 <Veinor> that's just a guess, anyway
01:55:46 <pelotom> so could "morally" means, "assuming a perfectly pure world"
01:55:54 <Saizan> no
01:56:37 <Saizan> morally's meaning here is not tied to purity
01:56:48 <pelotom> Saizan: what does it mean?
01:57:45 <Saizan> some similar, but more general, "assuming a world not disturbed by implementation/lowlevel details"
01:58:21 <Saizan> in fact i think that specific post is referring to seq
01:58:56 <pelotom> hm, that still sounds very amorphous
01:59:11 <Saizan> with seq you can observe differences that are normally disregarded
01:59:21 <Saizan> yeah, morally is not a technical term
01:59:55 <pelotom> Saizan: what's an example?
02:01:29 <Saizan> e.g. in many cases one would expect \_ -> undefined to be observationally equal to undefined, but (\ _ -> undefined) `seq` () == (); and undefined `seq` () == undefined
02:01:56 <pelotom> Saizan: ah
02:02:24 <pelotom> Saizan: so in that case it means "regarding the language minus bottom"?
02:02:25 <Jafet> Immoral is when you look at it and are tempted to say an immoral word
02:02:41 <pelotom> the language minus contradictions
02:02:47 <Saizan> pelotom: as i said, i'd guess "minus seq"
02:03:05 <Veinor> Jafet: I like that
02:03:12 <Veinor> "oh, unsafeCoerce!"
02:03:23 <Saizan> since the laws still hold with bottom
02:03:32 <pelotom> fair enough
02:03:47 <pelotom> what is the environment monad, and unique supply?
02:04:03 <Saizan> evironment is another name for Reader
02:04:09 <pelotom> ah
02:04:21 <pelotom> that certainly makes sense that it would be commutative
02:05:11 <Saizan> and unique supply is a monad with an action unique :: m UniqueId such that every call to unique will give you a different UniqueId
02:05:55 <Saizan> where you don't really care about the precise identity of that id, just that it's unique
02:06:03 <pelotom> I see
02:06:08 <Saizan> if you're moral enough :)
02:07:29 <pelotom> so is this talk of "morality" mostly limited to haskell theorists? :)
02:07:39 <pelotom> buncha puritans
02:09:26 <Jafet> See no RealWorld#, hear no RealWorld#, speak no RealWorld#
02:11:44 <Saizan> it seems a term appropriate in every context where you've intensional and extensional equalities that disagree
02:13:05 <Saizan> or more than one equality anyway
03:14:04 <Taejo> is there a common name for mapHead f (x:xs) = (f x):xs
03:14:53 <Saizan> no afaik
03:14:59 <Jafet> @pl \f (x:xs) -> f x:xs
03:15:00 <lambdabot> (`ap` tail) . (. head) . ((:) .)
03:15:09 <Jafet> @pl \(x:xs) -> f x:xs
03:15:09 <lambdabot> ap ((:) . f . head) tail
03:15:35 <Taejo> since when does pl support pattern matching?
03:15:38 <Jafet> That's not really a map, anyway
03:18:01 <Saizan> Taejo: it always supported some very limited form of them
03:19:13 <Jafet> @pl \(a,b,c) -> a+b+c
03:19:13 <lambdabot> (line 1, column 6):
03:19:13 <lambdabot> unexpected ","
03:19:13 <lambdabot> expecting letter or digit, operator or ")"
03:19:13 <lambdabot> ambiguous use of a non associative operator
03:27:46 <Taejo> in haskell-mode in emacs, how do I interrupt ghci?
03:30:14 <tonkman> what would be the best way to write diophantine equation solver for haskell?
03:36:22 <nus> Taejo, C-c C-c (C-h m shows what keyboard shortcuts are defined)
03:36:30 <Taejo> thanks
03:46:06 <ajnsit> anyone heard of Ask?
03:46:31 <ajnsit> I was doing a web search on haskell and found this page (http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=49) that mentions "Ask - a total fragment of haskell". It sounded interesting but I can't find any thing else in a google search
03:50:58 <ajnsit_> Hi did anyone reply to my question about "Ask"? Sorry I my router restarted for some reason
03:53:32 <cizra> Hi. I have a list [[a, b ...], [a1, b1 ...], ...] I want to calculate stuff on the new list [a, a1, ...]. Is there an easy way to "rotate" the list of lists?
03:54:04 <cizra> (at times I feel C arrays would be easier (= ... hey, I can emulate C arrays with !!.
03:54:14 <Taejo> > transpose ["abc", "def"]
03:54:15 <lambdabot>   ["ad","be","cf"]
03:55:26 <cizra> ha!
03:56:46 <cizra> Thanks!
04:01:14 <pkrumins> hey guys, has anyone gotten Network package to work under Windows?
04:19:55 <pkrumins> i have a suggestion - Haskell's windows installation should include msys as well
04:20:16 <pkrumins> for example, cabal install network can never succeed because it runs ./configure
04:20:35 <pkrumins> so cabal says i need either cygwin or mingw+msys
04:21:11 <pkrumins> but since windows installation of haskell already ships with mingw, it seems reasonable to throw in msys
04:21:21 <pkrumins> so that users did not have to install cygwin themselves.
04:25:24 <Jonno_FTW> is code.haskell.org down?
04:25:36 <Ke> seems to be
04:25:42 <Jonno_FTW> ;__;
04:34:52 <dschoepe> Jonno_FTW: ssh is still up, if you have an account
04:35:02 <Jonno_FTW> I don't have an account
04:56:59 <boegel> @getshapr
04:57:00 <lambdabot> shapr!!
05:00:01 <lars9> @src retry
05:00:01 <lambdabot> Source not found. Do you think like you type?
05:00:08 <lars9> :t retry
05:00:09 <lambdabot> Not in scope: `retry'
05:12:49 <lars9> :t for
05:12:50 <lambdabot> Not in scope: `for'
05:13:07 <Jafet> :t forM
05:13:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:14:02 <lars9> @src for
05:14:02 <lambdabot> Source not found. You speak an infinite deal of nothing
05:14:07 <lars9> @index for
05:14:07 <lambdabot> bzzt
05:14:27 <lars9> hoogle for
05:14:27 <lars9> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
05:14:30 <lars9> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
05:14:47 <lars9> there is something bot doesnt know
05:15:36 <Jafet> @hoogle for
05:15:36 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
05:15:36 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
05:15:36 <lambdabot> Test.QuickCheck forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
05:16:16 <hpc> what's the difference between for and for_?
05:16:34 <hpc> (more specifically, why the change from Foldable to Traversable)
05:17:30 <Jafet> The return type
05:17:32 <olsner> hpc: for returns (t b) - for_ discards the result and returns ()
05:17:36 <Jafet> :t forM
05:17:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
05:17:38 <Jafet> :t forM_
05:17:38 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
05:17:52 <hpc> olsner: i mean, look at the typeclases; they are different
05:18:16 <olsner> I guess because traversable contains the stuff required to construct that (t b)
05:18:22 <matthiasgoergens> hi.  how could one translate the rules of, say, Magic the Gathering into haskell idioms?  I wonder whether there's a good way to fit the game's rules into Haskell type-system.  I have some ideas, but they basically boil down to a transliteration of the naive imperative version.
05:18:25 <olsner> while for_ only needs to destruct the input sequence
05:18:59 <matthiasgoergens> (The problem is that the game allows lots of special rules, where everything can in theory have effects on nearly everything else.)
05:20:53 <hpc> matthiasgoergens: that's probably what you have to do
05:21:24 <hpc> do it in something like Java, then when you find yourself thinking "this would be so much easier if function pointers weren't so ugly", switch to haskell
05:21:26 <matthiasgoergens> the game does have some common vocabulary, though.
05:21:30 <hpc> yo will understand the problem better
05:21:39 <hpc> *you
05:21:45 <matthiasgoergens> i.e. concepts that recur, and you can probably abstract those out.
05:22:27 <matthiasgoergens> hpc, yes, just going ahead and trying might be a good idea to find out.
05:23:34 <hpc> the problem with MTG is it has so much /stuff/ that you can't really know ahead of time how nicely your code will work, once you start to pull in more of the rules
05:23:51 <matthiasgoergens> yes.
05:24:05 <hpc> there are some good starting places though, like the various phases and the stack
05:24:09 <matthiasgoergens> actually, i am more interested in pocket civ, but since MTG is much better known, and has similar problems, i asked about it. ;o)
05:24:37 <matthiasgoergens> or perhaps the way to go is to write an [e]DSL
05:24:41 <hpc> if pocket civ is anything like regular civ, it will be significantly easier than MTG
05:25:08 <lars9> so strange, google "haskell Control.Concurrent.STM" can not find its doc, only find STM.TVar, STM.xxx etc
05:25:09 <matthiasgoergens> that just helps you to make the implementation of your cards look like the text printed on actual cards.
05:27:07 <lars9> oops, it appears to be Control.Monad.STM, not Concurrent.STM
05:27:11 <lars9> my mistake
05:51:37 <pkrumins> any ideas why windows installation installs ghc to path with spaces?
05:51:59 <pkrumins> c:\program files\haskell platform\...
05:52:04 <pkrumins> why not just c:\ghc
05:52:18 * hackagebot arrow-list 0.1.0 - List arrows for Haskell.  http://hackage.haskell.org/package/arrow-list-0.1.0 (SebastiaanVisser)
05:53:27 <arcatan> pkrumins: my guess: c:\program files is where programs are supposed to be installed on windows
05:54:13 <pkrumins> that's really bad for cross platform programs
05:56:28 <bayer> hi there, i am trying to override "compare" from the Ord class in order to compare two weighted paths the way i want to (short snippet here: git://gist.github.com/665392.git) When I do a "compare path1 path2" i always get path1 although the weight of path2 is smaller. can someone tell me what i do wrong?
05:57:12 <matthiasgoergens> bayer, let me look at the source you gave..
05:57:26 <bayer> thx matthiasgoergens 
05:58:31 <Jafet> pkrumins: if by cross platform you mean platform dependent...
05:58:41 <matthiasgoergens> please have a look at `on' from Data.Function
05:58:52 <matthiasgoergens> you could replace your compare by:
05:58:58 <matthiasgoergens> compare = compare `on' snd
05:59:15 <Jafet> :t comparing
05:59:16 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:00:21 <Saizan> you could have linked the webpage rather than the repo..
06:01:07 <novicio> Hello! Can anybody recommend a book for me to learn Haskell, at least the basics? I only know very little Java.
06:01:18 <matthiasgoergens> bayer, but for me it already works.
06:01:34 <bayer> cool, there is a new function to discover every day :)
06:01:36 <matthiasgoergens> novicio, I'd recommend "Real World Haskell" by default.
06:01:50 <Saizan> bayer: run "compare (Path path1) (Path path2)"
06:02:04 <matthiasgoergens> ok.
06:02:11 <Saizan> bayer: otherwise you're using the Ord instance for tuples, not the one for Path
06:02:27 <novicio> matthiasgoergens, thanks for your answeg. This book is good for people with not much knowledge in programming?
06:02:39 <bayer> outch....
06:02:42 <arcatan> novicio: http://learnyouahaskell.com/ might be better if you don't know much about programming
06:02:42 <Saizan> novicio: "learn you a haskell" 
06:02:56 <bayer> should have seen that, thx Saizan 
06:03:24 <matthiasgoergens> novicio, sorry, i don't know, if it's good if you don't know much about programming, yet.  so better listen to arcatan. ;o)
06:03:56 <matthiasgoergens> bayer, yes, always check the types.  types are your friend. ;o)
06:03:56 <novicio> matthiasgoergens, nevertheless thanks!
06:04:18 <novicio> arcatan, Saizan, thank you very much for the recommendation!
06:04:40 <bayer> matthiasgoergens, i realized that, but i have to get used to it first :)
06:05:08 <wuxb> hello everyone. why truncate 1.9999999999999999999999 returns 2 ::Integer . while  truncate 1.99 returns 1
06:05:14 <bayer> so thx guys!
06:05:34 <matthiasgoergens> bayer, to actually us `on` you need: compare = compare `on` (snd.unPath)
06:05:40 <matthiasgoergens> where unPath (Path a) = a
06:06:05 <matthiasgoergens> (i just checked the types myself. ;o)
06:06:37 <ezyang> Do I have to code up a datatype for myself if I want a strict list? 
06:08:44 <srobertson> hlint suggested replacing a lambda expression with Control.Arrow.second, which makes sense, but I hadn't looked into arrows yet as I didn't realize they were that common. So, what are the common techniques that "every Haskeller worth his/her salt should know"? Is there a list?
06:12:13 <wuxb> is there any infinite representation for float-point values?
06:13:30 <Jafet> > showCReal 1000 pi
06:13:30 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
06:14:38 <Saizan> srobertson: you could check the typeclassopedia
06:16:00 <Saizan> > 1.9999999999999999999
06:16:01 <lambdabot>   2.0
06:16:03 <srobertson> Saizan: ah, yes, i started reading that when i got started a couple months ago but it was way over my head at the time. i'll have another go.
06:16:11 <Saizan> wuxb: ^^^
06:16:38 <wuxb> :)
06:16:47 <Saizan> > 1.999999999999999999 == 2
06:16:48 <lambdabot>   True
06:17:14 <Saizan> floiating point numbers are silly like that :)
06:17:51 <wuxb> there is no CReal type?
06:19:31 <wuxb> I think that is Reasonable, infinite float-point like (1/3) has infinite length
06:19:38 <srobertson> > last $ takeWhile (\n -> read ("1." ++ replicate n '9') < (2.0::Double)) [1..]
06:19:39 <lambdabot>   15
06:19:50 <Saizan> CReal is defined in the numbers package
06:20:10 <Saizan> the only problem is that for non-trivial computations it doesn't have good performance
06:20:30 <Jafet> > 20 - exp pi + pi :: CReal
06:20:31 <lambdabot>   0.0009000208105242327335570153309555039311
06:20:43 <Saizan> another option is Rational, if you don't need irrationals
06:21:14 <Saizan> > 1/3 :: Rational
06:21:15 <lambdabot>   1 % 3
06:21:49 <wuxb> Rational looks good
06:25:16 <wuxb> Saizan: thx a lot!
06:25:23 <Saizan> np
06:44:21 <lars9> @hoogle fork
06:44:21 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
06:44:21 <lambdabot> Control.Concurrent forkOS :: IO () -> IO ThreadId
06:45:49 <Funktorsalat> lars9: maybe you're looking for: http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Process.html#v:forkProcess
06:45:55 <Funktorsalat> :)
06:46:21 <Nibble> Cabal can't install yi
06:46:33 <Nibble> mtl-2.0.0.0 was excluded because vty-4.4.0.0.1 requires mtl >=1.1.0.0 && <1.2
06:47:05 <Nibble> ideas?
06:47:30 <dcoutts__> Nibble: try using mtl 1.x
06:47:40 <dcoutts__> --constraint='mtl < 2'
06:48:50 <Nibble> dcoutts__: not working, vty requires mtl above 1.1 and under 1.2
06:50:51 <dcoutts__> Nibble: right, that's what I suggested, use 1.1
06:50:59 <dcoutts__> 1.1.x for some value of x
06:51:13 <lars9> Funktorsalat: let me check, thanks
06:51:24 <lars9> Nibble: is yi alive?
06:51:59 <Nibble> lars9: no idea
06:53:28 <lars9> Nibble: #yi
06:54:13 <lars9> Nibble: and dons is there
06:57:14 <Nibble> dcoutts_: the problem is that yi requires mtl 2
07:01:25 <siim> How do I show/print str if type of str is: `str :: BrowserAction t String'? (Network.HTTP)
07:03:30 <Saizan> something of type "BrowserAction t String" is not a string, it's kind of a program you can run to get a String
07:03:56 <Saizan> and it's not really showable in any sensible way
07:04:05 <evanton> I'm reading Real World Haskell, chapter 4, paragraph "A simple command line framework". The indentation in that example is not obvious to me. Are there any indentation guidelines for haskell code? (I have python some background, maybe this is the reason)
07:04:36 <srobertson> siim: 'browse str'
07:05:17 <siim> thanks
07:10:42 <siim> I tried to show cookies: getCookies >>= (some magic) ... and after that show some values
07:11:07 <Twey> evanton: Things that are indented more are subservient to things that are indented less.
07:12:43 * hackagebot language-java-classfile 0.1 - Parser for Java .class files  http://hackage.haskell.org/package/language-java-classfile-0.1 (GergoErdi)
07:13:00 <evanton> Twey: I'm used to the convention where indentation is consistent (python), so a two space indent then much more spaces indent next line confuses me
07:16:02 <kingping> Hello.
07:16:04 <Twey> evanton: The amount of indentation doesn't matter, only its relative position
07:17:09 <Twey> evanton: E.G. in that ‘main’, the ‘where’ is indented two spaces under ‘main’, then the body of the do-block is indented two lines under the ‘mainWith’ (to which it belongs)
07:17:13 <Twey> Er, two spaces**
07:17:39 <evanton> Twey: do haskel coding standards suggest some consistent coding standars, or this is not relevant at all?
07:18:02 <kingping> Functor typeclasses are always expected to get one concrete type, right?
07:18:08 <Twey> evanton: http://urchin.earth.li/~ian/style/haskell.html
07:18:13 <kingping> s/typeclasses/instances/
07:18:46 <kingping> I mean (* -> *)
07:18:59 <Funktorsalat> yes
07:19:13 <kingping> :D
07:19:27 <Funktorsalat> if you want two, that's called a BiFunctor
07:19:39 <Funktorsalat> it probably is in category-extras
07:19:45 <kingping> Hmm
07:20:53 <dons> ?bug
07:20:53 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
07:21:04 <evanton> Twey: that one says about not using tabs, but doesn't advice on the length of indentation in spaces and doesn't say if indentation has to be consistent
07:21:31 <Twey> evanton: Of course it has to be consistent
07:21:32 <kingping> So in 'Making your own types ant Typeclasses' of Learn You a Haskell for for Great Good with BiFunctor I just could carry data Barry t k p = Barry { yabba :: p, dabba :: t k } once and make it an instance of a Functor typeclass ?
07:21:37 <Twey> There are many ways in which something can be consistent, though.
07:21:41 <kingping> @Funktorsalat
07:21:41 <lambdabot> Unknown command, try @list
07:21:59 <evanton> Twey: I mean consistent as in "use exactly X spaces for every next level of indentation"
07:22:00 <Twey> evanton: Personally I prefer two-spaces as the minimum indentation level
07:22:27 <Funktorsalat> kingping: uh, if t is a functor
07:22:31 <Twey> evanton: Like I said before, it's not how many spaces you use that's important, it's what you line up with on the previous line
07:22:37 <evanton> following such conventions is really language agnostic, makes the diff smaller at least
07:22:52 <kingping> @info Functor
07:22:52 <lambdabot> Functor
07:23:08 <kingping> @kind Int
07:23:09 <lambdabot> *
07:23:17 <kingping> @kind Maybe
07:23:18 <lambdabot> * -> *
07:23:41 <evanton> Twey: well, maybe I could add to my initial question "from a human's perspective", because what you said makes sense "from haskell compiler's perspective" :)
07:24:04 <Twey> evanton: Er, it's exactly the same from a human perspective.
07:24:37 <Funktorsalat> I'm glad two isn't the minimum :o or at least I was before I found out about > in vim
07:24:47 <Funktorsalat> sometimes you need to squeeze in another level
07:25:50 <kingping> I wonder where Functor comes from, whether it is related to maths.
07:26:05 <Funktorsalat> yes
07:26:17 <Twey> kingping: Vaguely
07:26:42 <kingping> !google BiFunctor
07:26:45 <Funktorsalat> Twey: hmm I'd say rather literally, but it's a special case
07:26:45 <IIcke> kingping, I suppose it comes from category theory
07:27:16 <Funktorsalat> http://en.wikipedia.org/wiki/Functor
07:27:43 <Twey> Funktorsalat: Hence ‘vaguely’ ;)  What we mean by a ‘functor’ in Haskell is not what… those people… mean by ‘functor’ in mathematics, conceptually
07:28:15 <Twey> It's a particular type of functor, yes, but that makes it not a functor (because the generality is the main part of the mathematical definition)
07:28:31 <kingping> "In category theory, a branch of mathematics, a functor is a special type of mapping between categories...." :-)
07:28:36 <Funktorsalat> Twey: ok, in that sense ;)
07:29:00 <Funktorsalat> I just meant it's (more or less) literally an instance of the math concept
07:29:11 <Funktorsalat> except Hask isn't actually a category etc ;)
07:29:36 <Twey> But an instance and a concept are not the same thing
07:30:00 <Twey> Maybe is a Monad, but that doesn't mean that Monads are the same thing as Maybes
07:30:56 <Funktorsalat> (maybe it is when equipped with this moral equivalence)
07:31:08 <kingping> "our biggest mistake [in designing Haskell was u]sing the scary term "monad" rather than "warm fuzzy thing" :-)
07:31:18 <Nibble> kingping: lol
07:31:22 <Twey> Heh.
07:32:15 <Saizan> Twey: though "it's a specialization of" is a quite precise way in which Functor comes from maths, not vague :)
07:32:30 <aristid> kingping: "warm fuzzy thing" would not really have been better :D
07:32:50 <Saizan> too much to type
07:33:19 <kingping> aristid: These are Simon P. J.'s words, not mine :-)
07:33:20 <Twey> A.K.A. WFTs
07:33:39 <aristid> IO as a WFT
07:33:41 <aristid> WTF!
07:33:47 <Twey> Saizan: True.  Perhaps ‘indirectly’ would have been better.
07:33:51 <Funktorsalat> well we partially fixed that bug with monica the monad http://www.janeysaur.com/monad-aka-warm-fuzzy-thing
07:34:58 <kingping> .]
07:35:38 <JohnnyL> What db do you guys normally use with Haskell? Also, what web framework?
07:37:17 <kingping> JohnnyL: I've heard http://snapframework.com/ is growing.
07:37:32 <kingping> Haven't used it though.
07:37:34 <Twey> As long as you don't need file uploads.
07:39:25 <JohnnyL> kingping: thanks looks good.
07:39:41 <kingping> Wow, quite nice growing http://snapframework.com/blog/2010/10/27/snap-0.2.15-released
07:39:43 <aristid> JohnnyL: there's also yesod http://docs.yesodweb.com/
07:40:11 <kingping> 50% throughput.
07:40:49 <JohnnyL> aristid: wow, looks good too.
07:43:05 <Nibble> dcoutts__: I see not what you meant with constraint thingie
07:43:23 <Nibble> With help of it, I managed to install mtl 1.1 while still having mtl 2 installed
07:43:25 <Nibble> I think
07:43:39 <Nibble> but the issue when installing yi remains
07:43:51 <dcoutts__> Nibble: you need to use the constraint when installing yi
07:44:05 <dcoutts__> cabal install yi --dry-run --constraint='mtl < 2'
07:44:21 <aristid> it would be cool if hackage could show download numbers
07:44:27 <aristid> so i know whcih is most popular
07:44:31 <dcoutts__> aristid: new server does
07:44:43 <aristid> dcoutts__: when will it go live?
07:45:03 <dcoutts__> aristid: we're at the hackathon at the moment and have a table of people working on it
07:45:09 <aristid> cool
07:45:13 <aristid> where is the hackathon?
07:45:18 <dcoutts__> Ghent
07:46:00 <Saizan> someone who can resurrect code.haskell.org at that table perhaps?:)
07:46:01 <Nibble> dcoutts__: looks like I need to install vty and monads-fd separately for cabal to realize it needs to apply the constraint on those too
07:46:13 <aristid> ah, belgium
07:46:30 <aristid> i wish everybody will migrate to mtl 2.0 very soon :D
07:46:35 <dcoutts__> Nibble: no, you need to apply the constraints simultaneously, installing separately may not help
07:46:50 <Nibble> dcoutts__: it seem to be the only fix, since your way didn't work
07:47:03 <dcoutts__> Nibble: cabal install yi --dry-run --constraint='mtl < 2' --constraint='monads-fd < 0.1.0.3'
07:47:33 <aristid> it's DLL hell :(
07:47:50 <Funktorsalat> another way might be to delete the mtl upper bound from the offending package and maybe fix a few incompatibilities ;)
07:48:28 <Funktorsalat> (namely, use of Cont, State etc. constructors to ContT Identity etc)
07:48:51 <Nibble> hmm
07:49:07 <Nibble> it doesn't want to install all those dependencies
07:49:14 <aristid> Funktorsalat: yeah but you have to do that from the bottom of the dependency tree up
07:49:29 <Nibble> In order, the following would be installed:
07:49:37 <Nibble> and a shitload of dependencies
07:49:44 <Nibble> and it doesn't give me an option to install
07:49:46 <Funktorsalat> aristid: yes
07:49:59 <Funktorsalat> (only for packages that actually need mtl<2 though, obviously)
07:50:43 <Nibble> :/
07:51:22 <stepcut> JohnnyL: http://www.happstack.com/ as well
07:52:41 <Saizan> Nibble: if you don't pass --dry-run it will actually install them
07:53:31 <ManateeLazyCat> We plan to update gtk2hs darcs to darcs2 format, it's impossible apply darcs1 patch after we upgrade darcs format, please send to gtk2hs list if you still have darcs1 patch lying around. Thanks.
07:53:49 <Nibble> darcs2?
07:53:52 <Nibble> is there a new darcs?
07:54:11 <ManateeLazyCat> If no patch or bug report, i will update to darcs2 format and release gtk2hs-0.12.0 today.
07:54:19 <Saizan> we're at darcs-2.5
07:54:32 <ManateeLazyCat> Saizan: What do you mean 2.5?
07:54:37 <Saizan> the darcs2 format has been around for a while
07:55:09 <Saizan> ManateeLazyCat: i was just answering Nibble's question
07:55:13 <damex> 3rd day as code.haskell.org down?
07:55:23 <dcoutts__> Nibble: that's what the --dry-run flag does, remove that flag and it'll install
07:55:24 <ArkAnGiCIA> Hi.
07:55:35 <ManateeLazyCat> Saizan: I mean darcs patch format, to hashed-format or darcs1-format.
07:55:59 <Saizan> ManateeLazyCat: yeah, i know
07:56:02 <ManateeLazyCat> Nibble: Darcs patch have three format: darcs-1, hashed-format, darcs-2
07:56:35 <ManateeLazyCat> Nibble: hashed-format can compatible darcs-1 or darcs-2, but darcs-2 repository can't apply darcs-1 patch
07:58:00 <ManateeLazyCat> Nibble: Which OS do you use?
07:58:10 <Nibble> ManateeLazyCat: linux, arch linux
07:58:29 <ManateeLazyCat> Nibble: Can you pull gtk2hs darcs test ? If ok, it's same as gtk2hs-0.12.0
07:58:46 <Nibble> ManateeLazyCat: sure, how to?
07:59:03 <ManateeLazyCat> Nibble: darcs get http://code.haskell.org/gtk2hs
07:59:32 <Nibble> Il be right on it
07:59:37 <ManateeLazyCat> Nibble: Then switch gtk2hs directory do command "./bootstrap.sh"
07:59:49 <Nibble> darcs is going slow
07:59:56 <turiya> can somebody tell me why i get an error in my code, even when all the types are correct? the code is at http://hpaste.org/41209/if_then_else_in_do
08:00:38 <ManateeLazyCat> turiya: What error?
08:00:49 <ManateeLazyCat> Nibble: darcs get http://code.haskell.org/gtk2hs --lazy
08:01:01 <turiya>  Couldn't match expected type `IO ()'
08:01:01 <turiya>            against inferred type `(Ptr Word8 -> IO b) -> b1'
08:01:11 <ManateeLazyCat> Nibble: Above command just pull patches you need (ignore patches that just need for developer)
08:01:16 <WalterMundt> where is a good guide on just how indentation in haskell works semantically?  I'm having issues with 'The last statement in a 'do' construct must be an expression' errors and am not sure how to track 'em down
08:01:46 <WalterMundt> at the highligted line in http://haskell.pastebin.com/cEJQvUrC
08:02:08 <Nibble> ManateeLazyCat: it is working on it
08:02:15 <ManateeLazyCat> Nibble: Thanks.
08:02:44 <ManateeLazyCat> Nibble: gtk2hs-0.12.0 will be an exciting version. :)
08:02:50 <Nibble> ManateeLazyCat: I heard so :P
08:02:58 <Nibble> ManateeLazyCat: that means you can release your enviroment?
08:03:09 <ManateeLazyCat> Nibble: Yes, I'm working on it.
08:03:27 <ManateeLazyCat> Nibble: I perhaps help other people move to gtk2hs-0.12.0
08:03:41 <ManateeLazyCat> Nibble: My environment will release before 11-15
08:03:45 <Nibble> ManateeLazyCat: neat :)
08:04:35 <ManateeLazyCat> Nibble: I'm working on "Graphics customize system" and "extension system" to make other people can write their own extension easily. :)
08:04:45 <stepcut> turiya: that is not how you use withForeignPtr
08:04:54 <ManateeLazyCat> Nibble: After then i will release it isnce it's not perfect now. :)
08:04:55 <Nibble> ManateeLazyCat: "Identifying repository http://code.haskell.org/gtk2hs format"
08:04:57 <Saizan> WalterMundt: try like this http://haskell.pastebin.com/VQ2fzeeg
08:05:00 <stepcut> turiya: withForeignPtr :: ForeignPtr a -> (Ptr a -> IO b) -> IO b
08:05:11 <Nibble> ManateeLazyCat: noone demands perfect
08:05:34 <Nibble> but if people just could move to newer versions of stuff this shit would be so much easier -___- now I have to pull in tons of old crap
08:05:39 <ManateeLazyCat> Nibble: Yep, because, i haven't so much time to perfect every detail, so release it and let people join is better idea. :)
08:06:03 <stepcut> turiya: withForeignPtr fptr $ \ptr -> drawPixels (Size (fromIntegral width) (fromIntegral height)) (PixelData Luminance UnsignedByte ptr)
08:06:46 <WalterMundt> Saizan: no luck, same error
08:06:51 <turiya> oh..thanks stepcut, i just changed to the do notation and did not make that adjustment..
08:07:20 <stepcut> turiya: no problem
08:07:36 <Nibble> what is this whole deal with mtl2?
08:08:00 <stepcut> mtl is dead, long live mtl!
08:08:01 <Saizan> WalterMundt: you also like a do on line 15
08:08:06 <ezyang> @pl \f -> f f 
08:08:06 <lambdabot> join id
08:08:10 <Saizan> WalterMundt: s/like/lack/
08:08:18 <WalterMundt> saizan: spotted that, didn't help
08:08:25 <ezyang> :t \f -> f f 
08:08:26 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
08:08:26 <lambdabot>     Probable cause: `f' is applied to too many arguments
08:08:26 <lambdabot>     In the expression: f f
08:08:33 <ezyang> bah 
08:08:37 <WalterMundt> also, don't think one is needed on 13
08:08:37 <JohnnyL> what is the list comprehension for going from 100 to 1 in steps of 7?
08:08:53 <ezyang> > [100,93,...1] 
08:08:54 <lambdabot>   A section must be enclosed in parentheses thus: (... 1)Not in scope: `...'
08:09:05 <ezyang> > [100,93..1] 
08:09:06 <funkyjunkyrobot> hi guys, i'm new to haskell and i was wondering what text editor is good for os x. should i use vi or is there a gui based one
08:09:06 <lambdabot>   [100,93,86,79,72,65,58,51,44,37,30,23,16,9,2]
08:09:30 <Nibble> btw
08:09:36 <JohnnyL> ezyang: wow nice. Is there another way to do that?
08:09:45 <Nibble> is there any work going on in the departement of speeding up compilation
08:10:03 <Heffalump> Nibble: mostly that happens by GHC producing faster binaries
08:10:06 <ezyang> enumFrom? 
08:10:17 <Heffalump> but essentially, no
08:10:23 <WalterMundt> saizan: still, is there anywhere that shows how haskell parses intentation?  I don't understand it in enough detail to troubleshoot and it bothers me.  What's the precise equivalence between indentation and using braces and semicolons?
08:10:27 <WalterMundt> er, indentation
08:10:34 <JohnnyL> ezyang: thanks
08:10:36 <Itkovian> BelHac pictures at http://www.flickr.com/photos/itkovian/sets/72157625199352725/with/5150737575/ 
08:10:39 <Saizan> WalterMundt: the haskell report has it
08:10:42 <ManateeLazyCat> When ghc 7 release? If is tomorrow, we perhaps make gtk2hs waiting ghc 7 to test . :)
08:10:47 <Saizan> @where report
08:10:47 <lambdabot> http://www.haskell.org/onlinereport/
08:10:55 <WalterMundt> *looks up*
08:10:57 <ezyang> You'd actually prolly need enumFromThenTo 
08:11:09 <Saizan> WalterMundt: btw, i'd start to think the error is coming from somewhere else
08:11:58 <Heffalump> ManateeLazyCat: are you testing with the RC?
08:12:07 <ezyang> :t flip flip 
08:12:08 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
08:12:18 <WalterMundt> saizan: I'm doing to try switching to braces-and-semicolons and then pulling them out in stages until something breaks
08:12:19 <ezyang> :t flip 
08:12:20 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:12:24 <ezyang> srsly 
08:12:24 <Igloo> ManateeLazyCat: Certainly not tomorrow
08:12:26 <ManateeLazyCat> Heffalump: Someone report gtk2hs can't working on ghc-7 RC
08:12:39 <ManateeLazyCat> Heffalump: But I don't want test RC version.
08:12:49 <Saizan> WalterMundt: also, the inner if/then/else could be converted to guards
08:13:12 <ManateeLazyCat> Heffalump: We just change gtk2hs code if have new GHC official version release.
08:13:35 <WalterMundt> saizan: ooh, I wasn't sure about that, still learning the language and the only place I've seen guards described is at the top level
08:14:24 <JohnnyL> ezyang: I was trying to do it like this: [x | x <- reverse [1..100], x `mod` 7 == 0]
08:14:28 <Saizan> WalterMundt: they work similarly for case expressions
08:14:54 <ezyang> guards in cases are quite useful. 
08:15:14 <ManateeLazyCat> Emacs crash, i missing something?
08:15:22 <WalterMundt> indeed, I can see that
08:15:42 * ManateeLazyCat Emacs is garbage...
08:16:38 <funkyjunkyrobot> what do u guys use for an editor?
08:17:23 <Funktorsalat> mmm guards ;) case foo of { (x,y) | Just (bar -> z) <- x -> putStrLn "nom nom nom" }
08:17:25 <WalterMundt> can I use guards when defining a function with multiple equations in a let or where?
08:17:29 <Nibble> ManateeLazyCat: darcs failed
08:17:39 <Nibble> darcs failed:  Not a repository: http://code.haskell.org/gtk2hs (Failed to download URL http://code.haskell.org/gtk2hs/_darcs/inventory: Failure when receiving data from the peer)
08:17:43 <ManateeLazyCat> code.haskell.org down?
08:18:02 <Nibble> ManateeLazyCat: indeed
08:18:09 <ManateeLazyCat> Nibble: Wait, I have mirror repository on patch-tag.com
08:18:10 <Nibble> this shit can't be happening to me -___-
08:18:22 <ManateeLazyCat> Nibble: darcs get http://patch-tag.com/r/AndyStewart/gtk2hs-sync-mirror
08:18:46 <ManateeLazyCat> Nibble: Above address is my mirror repository to avoid c.h.o down. :)
08:18:47 <ezyang> :t flip flip 
08:18:48 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
08:19:08 <Nibble> ManateeLazyCat: that worked better
08:19:26 <ManateeLazyCat> Nibble: If patch-tag.com can work, gtk2hs main repository can works too.
08:19:42 <ManateeLazyCat> Nibble: path-tag.com's code is same as gtk2hs main repository at c.h.o
08:20:14 <Funktorsalat> > flip flip undefined 'a' `seq` 'b'
08:20:14 <lambdabot>   Couldn't match expected type `f (a -> b)'
08:20:15 <lambdabot>         against inferred type `GH...
08:20:16 <Nibble> why reinvent the wheel with cabal? let distributions pack their own stuff
08:20:25 <has> how I can use an If stament inside a function's argument? something like: function (if x then 1 else 2)
08:20:30 <Funktorsalat> > (flip . flip) undefined 'a' `seq` 'b'
08:20:31 <lambdabot>   'b'
08:20:36 <Nibble> has: use pattern matching
08:20:38 <Funktorsalat> see, seq breaks everything :|
08:20:40 <Nibble> f x y = x * y
08:20:44 <Nibble> f 1 y = y
08:20:50 <Nibble> f 2 y = 2 * y
08:21:20 <Nibble> has: understand?
08:21:30 <ezyang> flip . flip is a bit different from flip flip 
08:21:37 <ezyang> :t (flip . flip) 
08:21:38 <lambdabot> forall a b a1. (a -> a1 -> b) -> a -> a1 -> b
08:21:48 <Funktorsalat> oh indeed
08:21:59 <has> Nibble: that's not what I want, it is something like this: (calling a function) f (if even n then x else p)
08:22:25 <Nibble> has: well
08:22:46 <Nibble> that functionality can't be found in arguments, you have to do it inside the function
08:22:48 <Nibble> AFAIK
08:22:57 <lars9> why there is a parser error in line 26? http://hpaste.org/41210/parseerror   anyone can help figure out? thanks
08:23:14 <Saizan> has: have you tried just like that?
08:23:51 <Saizan> > (\n x p -> (+1) (if even n then x else p)) 3 2 1
08:23:52 <lambdabot>   2
08:24:12 <ManateeLazyCat> Hi all gtk2hs, if you can get gtk2hs darcs code from http://code.haskell.org/gtk2hs, please use mirror repository "darcs get http://patch-tag.com/r/AndyStewart/gtk2hs-sync-mirror" Thanks! :)
08:24:22 <ManateeLazyCat> s/can/can't
08:24:26 <has> Saizan: yes
08:24:42 <has> It doesn't work
08:24:47 <Saizan> lars9: the outer if lacks an else
08:25:05 <Saizan> has: it worked for me just above, can you put the code and the error you're getting on a pastebin?
08:25:17 <Nibble> ManateeLazyCat: darcs: /home/felix/.darcs/cache/patches/0000000342-d822c976af6a5f551d6d7cb2c3c0806def704f5ec052b246a70c8d97c5a7789c-new_4cf646b774be499af25b8201858994b: getSymbolicLinkStatus: does not exist (No such file or directory)
08:25:19 <has> sure, wait a moment
08:25:39 <Nibble> But it seems to have got its hands on a few files
08:26:02 <Eduard_Munteanu> Hi.
08:26:09 <ManateeLazyCat> Nibble: Are you *pull* code from mirror repository?
08:26:09 <Saizan> lars9: also the inner if else should be indented at least a space
08:26:16 <Nibble> ManateeLazyCat: yes.
08:26:22 <Nibble> But I have a fair amount of files
08:26:34 <ManateeLazyCat> Nibble: gtk2hs main repository is "darcs1 format", mirror repository is "hashed format"
08:26:52 <WalterMundt> saizan: the issue was that the if was parsed as part of the let expr, since it was at the same level as the word 'build'
08:26:55 <Nibble> I don't know what the difference is
08:26:56 <ManateeLazyCat> Nibble: Best use command "darcs get" command for a clean pull. :)
08:27:28 <WalterMundt> which naturally confused things quite a bit.  I was also able to simplify by using params of build instead of strefs for curGenes and curScore
08:27:31 <Nibble> ManateeLazyCat: I used the exact comand you wrote before
08:27:43 <Nibble> but it seems I have a few files on my hdd now
08:27:43 <ManateeLazyCat> Nibble: Can you try again?
08:27:46 <Nibble> ManateeLazyCat: sure
08:27:51 <ManateeLazyCat> Thanks.
08:28:00 <Nibble> now it worked
08:29:00 <ManateeLazyCat> Nibble: You can hit "Ctrl-C" for a *lazy* get. :)
08:29:26 <has> Saizan: nevermind, error of mine. I was using the "/" operator with an Integer
08:29:40 <Nibble> has: afaik, use div on those.
08:30:13 <Saizan> WalterMundt: d'oh, i should've spotted that :)
08:30:23 * ManateeLazyCat Re-compile gtk2hs darcs code to test again....
08:30:31 <has> using div works, I'm a novice
08:31:09 <lars9> Saizan: hi, isnt the inner if else already indented?
08:31:32 <WalterMundt> saizan: your link to the haskell report got me pointed in the right direction
08:32:58 <WalterMundt> and that's version 3 of 4 of the DP algo i'm playing with.  I'm doing it in 4 ways (lazy array, intmap, stuarray, and some kind of st map) to compare and learn different styles
08:33:10 <Saizan> lars9: well, in older ghc's you had to indent the else a little more than the if it belongs to, because you're continuing the same expression, newer ghc's changed the rule somewhat within do blocks so that might not be necessary anymore
08:33:26 <aavogt> does anybody use dyre here? I'm running into issues where it doesn't run my fallback config when I use a broken config
08:33:37 <JohnnyL> what database do you guys use (for a typical SQL based db) for Haskell?
08:33:39 <WalterMundt> (the map and array versions are different algorithms for the same problem; functional vs st is just a difference in the way of expressing the algo)
08:34:43 <ManateeLazyCat> aavogt: dyre will re-compile new binary file in other directory.
08:34:51 <Eduard_Munteanu> JohnnyL: for small projects, unless you want to bother with an actual server, you can try SQLite.
08:35:05 <lars9> Saizan: but after adding an else to outer if, the inner if/else is still reported to be error
08:35:13 <Eduard_Munteanu> Though it scales up nicely to bigger, mid-sized stuff I hear.
08:35:28 <Saizan> lars9: can you paste the new code?
08:35:34 <aavogt> ManateeLazyCat: ghc is unable to produce my new binary
08:36:10 * hackagebot QuickCheck 2.4 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.4 (NickSmallbone)
08:36:15 <Cloe> im trying to create a function that would output either 0 or 1 using inputs  from 0 up to any number, the first 10 falues 1-10 should output 0, 11-20 should output 1, 21-30 should output 1, 31 to 40  should output 0 and so on. my goal is to map this function onto a large list of integers and create different types of londitudional waves. thank you
08:36:20 <aavogt> it'd rather have my old configuration run rather than nothing: after all it's awkward to fix a window manager configuration when you don't have a window manager running
08:37:23 <aavogt> Cloe: so your input looks like     [((1,10),0),((11,21),1)] and so on?
08:37:35 <Cloe> * correction: "the first 10 falues 1-10 should output 0, 11-20 should output 1, 21-30 should output 0, 31 to 40  should output 1 and so on."
08:37:35 <ManateeLazyCat> aavogt: Now i use my own code, i use dyre before, AFAIK, dyre will produce new binary file on other place.
08:37:38 <bayer> is there a way to represent the positive infinite in haskell?
08:37:50 <ManateeLazyCat> aavogt: You still can you use your old binary file if config is wrong.
08:38:00 <companion_cube> > 1/0
08:38:01 <lambdabot>   Infinity
08:38:07 <ManateeLazyCat> aavogt: But i don't know the detail of newest dyre.
08:38:39 <bayer> thx :)
08:38:40 <Cloe> aavogt: yeah
08:38:58 <aavogt> this indicates some limitation in haskell or the people who use it, that everybody reimplements what a library offers
08:39:30 <JohnnyL> Eduard_Munteanu: ok, how about mysql?
08:39:34 <zygoloid> Cloe: do you have an approach in mind?
08:39:53 <stepcut> JohnnyL: happstack-state / MACID
08:40:49 <Cloe> Cloe: i was thinking of using the modulo function
08:41:01 <Cloe> zygoldoid: i was thinking of using the modulo function
08:42:05 <ManateeLazyCat> aavogt: IIRC, dyre will generate new state file on temp directory (getTemporaryDirectory), and generate new binary file at dyre's cache file.
08:42:07 <Eduard_Munteanu> JohnnyL: it's okay too, but you'll have to setup a MySQL server.
08:42:10 <lars9> Saizan it's fixed after adding a space before every 'else'. emacs's tab's auto indent is wrong ...
08:42:13 <zygoloid> Cloe: sounds reasonable. it's called "mod" in haskell.
08:42:24 <ManateeLazyCat> aavogt: So new binary file infact at dyre's cache directory.
08:42:30 <Eduard_Munteanu> JohnnyL: in contrast, with SQLite you just open a single file.
08:42:50 <ManateeLazyCat> aavogt: If ghc recompile successful, it will relaunch binary file in cache directory.
08:44:24 <Eduard_Munteanu> JohnnyL: though the bindings themselves seem to be alright in both cases.
08:44:28 * ManateeLazyCat pasted "My own reload library." at http://paste2.org/get/1075468
08:44:29 <ManateeLazyCat> aavogt: BTW, above is my simple "recompile-relaunch 'all project' library" .  
08:44:29 <Eduard_Munteanu> *Haskell bindings
08:44:58 <ManateeLazyCat> aavogt: dyre use for recompile-reload single config file, my library use for reload 'all project' . :)
08:45:53 <rothwell> 'lo. quick question: http://paste.lisp.org/display/116310 - what's the correct definition to derive MonadState? can't quite seem to get it...
08:47:15 <Saizan> rothwell: ... deriving (CMS.MonadState [Integer])
08:47:56 <rothwell> that's what i thought, but i get: "Cannot derive well-kinded instance of form `CMS.MonadState [Integer] (S ...), Class `CMS.MonadState' expects an argument of kind `* -> *'
08:48:35 <bayer> what library do i need to import to get infinity?
08:49:13 <ManateeLazyCat> bayer: What do you mean?
08:49:23 <Saizan> rothwell: oh, right, you can't make S a monad, it's not parametrized
08:49:31 <Nibble> bayer: well, there is [1..]
08:49:32 <lars9> Saizan: there is a type inference error about line 69, please help ... http://hpaste.org/paste/41210/stillerror#p41211
08:49:41 <rothwell> Saizan: ah, right...
08:49:52 <Saizan> rothwell: newtype S a = S (State [Integer] a) could
08:50:21 <bayer> i want to initialize some values with infinity, and later check if some other values are smaller 
08:50:28 <mauke> lars9: remove the type signature from fetchAndMerge
08:50:35 <mauke> bayer: 1/0
08:51:10 <Saizan> lars9: yeah, comment out line 59
08:51:24 <lars9> Saizan: mauke ok thanks
08:51:47 <JohnnyL> Eduard_Munteanu: k thanks
08:51:48 <lars9> Saizan: now it compiles
08:52:13 <Cloe> zygoloid: thanks
08:52:28 <lars9> Saizan: but the space before 'else' is so weird..
08:52:28 <Eduard_Munteanu> bayer: there are ways around that usually... what algorithm is that?
08:52:32 <bayer> 1/0 is not a valid integer, right?
08:52:41 <rothwell> Saizan: ah, got it
08:52:42 <rothwell> thanks
08:52:44 <mauke> infinity is not a valid integer
08:52:53 <bayer> Eduard_Munteanu, i want to step through a graph
08:52:54 <mauke> Integer is an unbounded type
08:52:55 <rothwell> brain not quite used to working with kinds, yet
08:53:01 <bayer> mauke, i see!
08:53:36 <bayer> Eduard_Munteanu, find a path between two nodes that is cheaper than a given X
08:53:40 <aavogt> ManateeLazyCat: dyre lets you add ghc flags, such as  -i   so you can use multiple source files
08:54:00 <aavogt> though by default it includes the dir where your config is
08:54:17 <ManateeLazyCat> aavogt: I guess author has add that in newest version. :)
08:54:26 <Saizan> lars9: i usually indent like this http://pastebin.com/Nju93SsX
08:54:49 <bayer> mauke, and because Integer is unbounded i need infinity
08:54:58 <identity_> I hate if expressions and indenting them
08:55:02 <bayer> or some way around
08:55:08 <Eduard_Munteanu> bayer: you could have costs in your graph be represented by an ADT like data Cost = Infinity | Cost Integer
08:55:19 * hackagebot QuickCheck 2.4.0.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.4.0.1 (NickSmallbone)
08:55:37 <mauke> bayer: infinity is a bound
08:55:47 <Eduard_Munteanu> bayer: then you can even make an Ord instance for that to compare.
08:55:53 <bayer> Eduard_Munteanu, hmmm.. that makes sense
08:56:05 <bayer> mauke, i dont get that point
08:56:06 <ArkAnGiCIA> infinity ?
08:56:23 <mauke> for all x. x < infinity
08:56:31 <mauke> that's an upper bound
08:57:09 <bayer> ok, if you put it like that.... 
08:57:10 <mauke> or you could do it C-style and use -1 to represent "no limit" :-)
08:57:17 <ManateeLazyCat> Nibble: Do you have Windows? It's perfect to test gtk2hs on Windows before release. :)
08:57:19 * hackagebot regions 0.8 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.8 (BasVanDijk)
08:57:20 <Eduard_Munteanu> ArkAnGiCIA: yes, weighted graphs are usually represented by <numeric costs iff there is a path; infinity if there isn't>
08:57:27 <Eduard_Munteanu> *between two nodes
08:58:15 <Eduard_Munteanu> Yeah, if you don't expect to use truly negative weights then -1 is okay. But it's still a constant, so why not use a proper ADT.
08:58:19 <bayer> ok, that helped, thx guys!
08:58:21 * hackagebot regions-monadstf 0.3.1.4 - Monads-tf instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadstf-0.3.1.4 (BasVanDijk)
08:58:23 * hackagebot regions-mtl 0.3.1.4 - mtl instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-mtl-0.3.1.4 (BasVanDijk)
08:58:25 * hackagebot regional-pointers 0.5 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.5 (BasVanDijk)
08:58:27 * hackagebot safer-file-handles 0.9 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.9 (BasVanDijk)
08:58:29 * hackagebot safer-file-handles-bytestring 0.1.0.3 - Extends safer-file-handles with ByteString operations  http://hackage.haskell.org/package/safer-file-handles-bytestring-0.1.0.3 (BasVanDijk)
08:59:04 <ArkAnGiCIA> j=-1
08:59:31 * hackagebot safer-file-handles-text 0.1.0.4 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.1.0.4 (BasVanDijk)
08:59:33 * hackagebot usb-enumerator 0.2 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.2 (BasVanDijk)
08:59:36 * hackagebot usb-safe 0.11 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.11 (BasVanDijk)
08:59:42 <lars9> Saizan: hi is there a ghc extension for this if/else problem?
09:00:00 <lars9> Saizan: because my emacs indent else at the same level as if, and i dont want to change it
09:00:38 <ManateeLazyCat> lars9: What's your need?
09:01:03 <Saizan> lars9: it seems so http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
09:01:59 <lars9> Saizan: hi is this implemented already?
09:02:14 <Saizan> lars9: that page says so
09:02:21 * hackagebot containers-unicode-symbols 0.3.0.2 - Unicode alternatives for common functions and operators  http://hackage.haskell.org/package/containers-unicode-symbols-0.3.0.2 (RoelVanDijk)
09:02:23 * hackagebot ls-usb 0.1.0.7 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.7 (RoelVanDijk)
09:02:26 <Eduard_Munteanu> I wonder if there could be a true 'return' in Haskell, though that would suck to desugar.
09:02:31 <lars9> Saizan: let me try
09:02:46 <Eduard_Munteanu> (a return that alters flow control)
09:02:52 <mauke> Eduard_Munteanu: continuations :-)
09:03:01 <Eduard_Munteanu> Yeah, I suppose call/cc can do that.
09:03:11 <ManateeLazyCat> Nibble: You should try newest manatee after you install gtk2hs darcs, manatee current state is very close to release state. :)
09:03:25 * hackagebot usb-id-database 0.4.0.4 - A database of USB identifiers  http://hackage.haskell.org/package/usb-id-database-0.4.0.4 (RoelVanDijk)
09:03:40 <Nibble> ManateeLazyCat: not right now, kinda bussy :P
09:03:49 <lars9> Saizan: oops: cabal: The package concurrent-0.1 requires the following language extensions
09:03:52 <lars9> which are not supported by ghc-6.12.3: DoAndIfThenElse
09:04:32 <Itkovian> dcoutts: hmm, should simply providing --package-db=mynonexistingpackagedbfile just work to get the set of dependencies that match a given set of constraints?
09:04:57 <Saizan> lars9: it seems you need ghc 7
09:05:54 <lars9> Saizan: does it exist?
09:06:13 <Saizan> lars9: it's still in prerelease, but yes
09:07:13 <lars9> Saizan: i see, thanks
09:09:08 <ManateeLazyCat> Saizan: ghc-7 can save memory when link big project?
09:09:21 <Saizan> ManateeLazyCat: i don't know
09:09:25 <ManateeLazyCat> Saizan: ghc-6.12.3 almost kill my box when link big project. 
09:11:47 <lars9> ManateeLazyCat: me too. my 1G ram is often exhausted when installing haskell packages
09:12:15 <allbery_b> isn't that usually split-objs?
09:12:33 <identity_> lars9: 1 gigabyte? My god. How do you get by?
09:12:43 <ManateeLazyCat> lars9: My 2G RAM eat by ghc when i use it link my project
09:13:06 <Saizan> do you use the new linker?
09:13:18 <ManateeLazyCat> lars9: I'm sure ghc will eat more memory if i have more. :)
09:13:24 <lars9> identity_: it's enough for most time :)
09:13:27 <ManateeLazyCat> Saizan: new linker?
09:13:59 <Saizan> ManateeLazyCat: http://en.wikipedia.org/wiki/Gold_(linker)
09:14:11 <Eduard_Munteanu> I remember emerging GHC on Gentoo without the 'binary' USE flag took longer than anything.
09:14:50 <Eduard_Munteanu> This on a Phenom II quad core and 6GiB RAM, that sucked. I think it was about 90 mins at least.
09:14:58 <BorisL> I try to install snap-server, but cabal gives this error http://hpaste.org/41212/snap_installation_error
09:16:20 <Eduard_Munteanu> Now I generally use the 'binary' USE flag.
09:16:27 <dcoutts__> BorisL: so which bit of the error doesn't make sense?
09:16:48 <lars9> Eduard_Munteanu: use arch
09:17:37 <Eduard_Munteanu> Arch is nice too. I use it on my devel KVM VMs.
09:18:29 <BorisL> I think that the problem is that cabal tries to use mtl-2.0.0.0 instead of mtl-1.* I don't know how to tell it to use specific version
09:18:45 <dcoutts__> BorisL: right, --constraint='mtl < 2'
09:19:13 <ManateeLazyCat> Saizan: Do you use Glod linker in your system? ;p
09:19:15 <Eduard_Munteanu> Both Arch and Gentoo seem to have nice Haskell support, at least better than average.
09:19:25 <ManateeLazyCat> Saizan: It looks experimental
09:19:53 <Saizan> ManateeLazyCat: i tried it for a while when i had too little ram for what i wanted to build
09:20:11 <mauke> cursed by a dyslexic god, everything he touched turned into glod
09:20:19 <mauke> (glod glodson, a dwarf)
09:20:26 <ManateeLazyCat> Saizan: Glod linker always work?
09:20:35 <Ke> dyslexic dog
09:20:37 <ManateeLazyCat> Saizan: If can't work, just fast is not enough. :)
09:20:55 <Saizan> ManateeLazyCat: it worked for me, though i guess there's a reason why it's still in beta
09:21:25 <lars9> is LLVM's linker faster?
09:21:34 <zygoloid> llvm doesn't have a linker
09:21:38 <ManateeLazyCat> Saizan: I check Debain documentation : It currently fails to link some applications and libraries (i.e. won't link usable kernels).
09:21:47 <BorisL> now I get cabal: cannot configure monads-fd-0.1.0.3. It requires mtl ==2.*. Snap dependencies require two mtl versions
09:21:47 <lars9> zygoloid: clang's ?
09:22:00 <zygoloid> lars9: doesn't have a linker. it uses ld or gold
09:22:18 <Heffalump> BorisL: try a constraint on monads-fd too
09:22:41 <rothwell> mauke: the executables it produces are small and bad tempered
09:22:45 <lars9> zygoloid: i see, how about its compiler? independent?
09:23:04 <ManateeLazyCat> BorisL: "sudo ghc-pkg hide monads-fd"
09:23:35 <aavogt> hiding it doesn't make it go away
09:23:44 <stepcut> ManateeLazyCat: that won't help. hide does not hide things from cabal. 
09:23:58 <zygoloid> lars9: i'm not sure i understand the question. clang is part of the llvm project.
09:24:12 <tarrasch> Hello, Is there any good tutorial on arrows, in particular I'm trying to convert (for practice) desugarize do-notation. This in particular: http://hpaste.org/41213/converting_arrow_donotation
09:24:55 <Eduard_Munteanu> @src (-<)
09:24:55 <lambdabot> Source not found. Maybe you made a typo?
09:25:04 <aavogt> it's syntax
09:25:10 <tarrasch> Yep
09:25:14 <BorisL> I hid monads-fd, but the error is the same
09:25:20 <Eduard_Munteanu> Oh.
09:25:30 <zygoloid> tarrasch: http://www.haskell.org/arrows/sugar.html
09:25:43 <dcoutts__> BorisL: right, hiding makes no difference to what choices cabal makes
09:25:48 <zygoloid> though beware that's somewhat out of date
09:26:23 <tarrasch> zygoloid, I see ...
09:26:58 <dcoutts__> BorisL: try: cabal install snap-server --dry --constraint='mtl < 2' --constraint='monads-fd < 0.1.0.3'
09:27:10 <dcoutts__> BorisL: --dry-run flag means it will not actually do it
09:27:11 <tarrasch> I've always heard that Applicative is much newer in haskell than Monads, when did they come, respectively?
09:27:42 <ManateeLazyCat> Saizan: Looks gold-linker much fast, i will try it, thanks for tips. :)
09:28:57 <BorisL> I got a list of packages to be installed. No errors. Before that command I executed "ghc-pkg unregister --user monads-fd-0.1.0.3" like in cabal FAQ
09:30:55 <dcoutts__> BorisL: ok, sounds fine
09:31:50 <Heffalump> we really need automated stuff to push people to update dependencies aggressively
09:33:59 <BorisL> installed successfully. Thanks, Duncan
09:34:08 <aavogt> @type arr (\v -> if v < 0 then Left v else Right v) >>> (arr (, True) ||| arr (, False)) >>> arr (\(v,n) -> if n then -v else v)
09:34:09 <lambdabot> parse error on input `True'
09:34:13 <sjoerd_visscher_> Is there a way to catch pattern matching failures at runtime without using do notation?
09:34:22 <aavogt> sjoerd_visscher_: list comprehensions
09:34:32 <aavogt> -XPatternGuards too
09:34:46 <sjoerd_visscher_> aavogt: thanks!
09:34:58 <zygoloid> spoon!
09:34:58 <aavogt> or even using more standard constructions where you're allowed many patterns, like case
09:34:59 * zygoloid ducks
09:35:24 <aavogt> > (,1) 2
09:35:24 <lambdabot>   <no location info>: parse error on input `1'
09:35:48 <aavogt> @type arr (\v -> if v < 0 then Left v else Right v) >>> (arr (\x -> (x, True)) ||| arr (\x -> (x, False))) >>> arr (\(v,n) -> if n then -v else v)
09:35:49 <lambdabot> forall a (cat :: * -> * -> *). (Num a, Ord a, ArrowChoice cat) => cat a a
09:36:10 <tarrasch> aavogt, ah, you solved it?
09:36:22 <aavogt> it's probably not how it's desugared
09:36:43 <aavogt> there's a preprocessor on hackage that can do it too I think
09:36:50 <tarrasch> why does lambdabot also mention "(cat :: * -> * -> *)" ?
09:37:23 <aavogt> for your convenience, it tells you the kind of cat
09:38:01 <aavogt> which is the type for a type constructor here: it could say    a :: *   too
09:38:23 <aavogt> the reason is probably some extension included in  -fglasgow-exts
09:38:31 <tarrasch> Ah ok. Thanks
09:39:07 <tarrasch> Impressive it's so smart and chooses 'cat' and not just 'a' and call the other 'b'
09:39:33 <aavogt> @type (>>>)
09:39:34 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
09:40:11 <aavogt> somebody picked cat as a type variable in there ^^
09:41:29 <tarrasch> ah ok, it just uses the default name that the class was defined with, makes sense.
09:42:08 <aavogt> @type flip (undefined :: variable -> type -> reuse)
09:42:08 <lambdabot> parse error on input `type'
09:42:23 <aavogt> @type flip (undefined :: variable -> typee -> reuse)
09:42:23 <lambdabot> forall variable a b. a -> variable -> b
09:43:00 <aavogt> @type let a = (undefined :: variable -> typee -> reuse) in flip a
09:43:01 <lambdabot> forall variable a b. a -> variable -> b
09:49:53 <sjoerd_visscher> What is the shortest way to write this: \l -> case l of (a:as) -> Just (a, as); otherwise -> Nothing
09:50:15 <sjoerd_visscher> I now have this: \l -> do (a:as) <- Just l; Just (a, as)
09:51:06 <sjoerd_visscher> I'd like to write it as \(a:as) -> (a, as) if there was a way to catch the error
09:52:00 <mauke> sjoerd_visscher: 'otherwise' is wrong there
09:53:22 <sjoerd_visscher> oh right, \l -> case l of (a:as) -> Just (a, as); _ -> Nothing
09:53:32 <mauke> uncons cons nil list = case list of [] -> nil; x : xs -> cons x xs
09:53:53 <mauke> uncons ((Just .) . (,)) Nothing
09:53:59 <mauke> hmm
09:54:32 <sjoerd_visscher> and uncons (\_ _ -> Nothing) (Just ())
09:56:09 <sjoerd_visscher> but that become uglier with data types with more constructors
09:57:37 <Ziphilt> i am confused with installing packages for haskell on my linux system: should i use the package manager or Cabal? both? does it matter?
09:57:46 <identity_> Ziphilt: preferably cabal
09:58:12 <Ziphilt> i am trying to install Yi from Cabal
09:58:28 <Ziphilt> it fails upon not finding Gtk2Hs, but i installed that by Cabal
09:58:29 <identity_> Cabal uses hackage. Hackage is the most up to date source of packages from hackage, naturally :P 
09:58:41 <Ziphilt> what could be wrong?
09:58:56 <identity_> Ziphilt: Paste the errors and someone will help you. I would try to take a crack at it but I'm making dinner atm
09:59:06 <identity_> (in a pastebin, not in the irc channel)
09:59:06 <Ziphilt> okay
09:59:14 <ManateeLazyCat> Saizan: Wow, i have try gold-linker, below is difference : "ld compile/link time" : 9m48.786s, "gold compile/link time" : 6m49.543s. Compile time is same, so gold-link same 3m link time for me! :)
09:59:17 <mauke> wait, gtk2hs can be installed with cabal now?
09:59:25 <ManateeLazyCat> mauke: Of course.
09:59:57 <ManateeLazyCat> Ziphilt: Install gtk2hs-buildtools package first.
10:00:08 <ManateeLazyCat> Ziphilt: "cabal install gtk2hs-buildtools gtk"
10:00:16 <funkyjunkyrobot> i am trying to make a function that takes a list of of a list of ints [[a]] and output the list with the first list moved to the end of the list  not sure how to reference an inner list
10:00:29 <Ziphilt> ManateeLazyCat: i just installed that by downloading the tar.gz from hackage and installing it by cabal
10:00:40 <ManateeLazyCat> Saizan: Gold-linker it's really surprise to me. :)
10:00:52 <Ziphilt> oh maybe i did not get the "gtk" package
10:00:53 <Ziphilt> brb
10:01:27 <ManateeLazyCat> Ziphilt: BTW, I will hang here, if everything is fine, we will release newest gtk2hs today. :)
10:02:40 <ManateeLazyCat> Saizan: I will use gold-linker as my default linker, thank for share it. :)
10:02:51 <sina> Hi everyone
10:03:44 <sina> I have a question in Haskell. I am willing to take an input of a String and return the function with the name of that String. is it possible?
10:04:16 <Ziphilt> if cabal is told to install something multiple times, does it just recompile?
10:04:26 <mauke> sina: no
10:04:29 <Ziphilt> i thought i installed gtk2hs-buildtools already
10:05:26 <sina> Hi mauke. Is there any way to do that? I mean I have x = "ABC" and I have function y which takes a string and returns a String. now I want to say y x and want y to call and return function x
10:05:32 <ManateeLazyCat> Ziphilt: If you reinstall gtk package, you need re-compile all gtk2hs-base package.
10:05:55 <ManateeLazyCat> Ziphilt: Example, if you re-install gtk package from hackage, you need re-compile Yi again (if you use Yi)
10:06:15 <dcoutts__> Ziphilt: cabal will not recompile if it's already installed (and is usable)
10:06:32 <mauke> sina: see Data.Map
10:06:33 <Eduard_Munteanu> sina: you don't make much sense... how does y look like?
10:06:40 <mauke> sina: make a map from strings to functions
10:07:23 <sshc> Does unsafeUseAsCString work with lazy bytestrings or strict bytestrings?
10:07:30 <ManateeLazyCat> Ziphilt: Of course, you can use '--reinstall' flag to focus cabal re-install some package.
10:08:16 <ManateeLazyCat> sshc: I think is strict bytestring.
10:08:32 <Ziphilt> http://fpaste.org/g9sD/ is what i get when i try to install yi
10:08:44 <Ziphilt> <ManateeLazyCat> Ziphilt: "cabal install gtk2hs-buildtools gtk"
10:08:47 <sina> mauke: I don't understand about making that Map. Eduard_Muneanu : well I have functions called like ab , cd , ef , gh (for example) and each represent a String. (for example "ABCD"). now I want to have another function that when I call the function and the name of the other function, it return the String in the other function
10:08:47 <ManateeLazyCat> sshc: Generic, use unsafeUseAsCString to convert ByteString to CString.
10:08:47 <Ziphilt> this does not work
10:09:00 <Ziphilt> shall i paste that output too?
10:09:16 <sshc> ManateeLazyCat: I don't understand your last sentence
10:09:22 <Heffalump> dmwit: you around?
10:09:27 <ManateeLazyCat> Ziphilt: gtk2hs-buildtools is not install correctly or you haven't add ~/.cabal/bin in your PATH.
10:09:47 <sshc> ManateeLazyCat: If I'm using a lazy bytestring, should I convert it to a strict bytestring (with fromChunks) before I can use it as a CSTring?
10:09:49 <EvanR> sina: you cant directly test 'name of function'
10:09:52 <Ziphilt> i think i added ~/.cabal/bin to my path, i'll confirm
10:09:59 <ManateeLazyCat> sshc: I think not.
10:10:00 <EvanR> but you can pass "ab" "cd" etc to a function
10:10:08 <ManateeLazyCat> sshc: I think It don't care it.
10:10:12 <Ziphilt> damn, it left upon restart
10:10:20 <Ziphilt> i am using the Fish shell
10:10:27 <sina> EvanR: what do you mean?
10:11:03 <EvanR> sina: you said you wanted a function to use ab or cd or ef, and the name of a function to compute its result
10:11:07 <sshc> ManateeLazyCat: You mean it works with either lazy or strict bytestrings?
10:11:16 <sshc> Or with both, rather?
10:11:18 <ManateeLazyCat> sshc: Yes, IIRC.
10:11:37 <ManateeLazyCat> sshc: Either lazy or strict can work, IIRC.
10:11:58 <ManateeLazyCat> sshc: You need careful unsafeUseAsCString, it's not safe.
10:12:19 <EvanR> sina: can you explain what you want better
10:12:31 <sina> EvanR: basically, I want the function y for example to do some process on the given String. and I have like 10 functions each representing a String. I want to give y only the name of one of those functions and it be able to get that result
10:12:40 <ManateeLazyCat> sshc: When you use unsafeUseAsCString, ByteString and CSTring shares same pointer.
10:12:45 <mauke> what do you mean by "function representing a String"?
10:13:01 <mauke> do you even know what "function" means?
10:13:02 <ManateeLazyCat> sshc: If your C code touch CString, you should use useAsCString and not unsafeUseAsCString
10:13:16 <sina> EvanR: for example. I want to call y "stringA" and want y to call function stringA and do some work on that stringA
10:13:38 <sshc> ManateeLazyCat: Ah, I was unaware of useAsCString
10:13:39 <sina> mauke: like, stringA = "ABC" stringB = "DEF"
10:13:48 <sshc> ManateeLazyCat: And apparently it only works with Strict bytestrings:
10:13:49 <sshc>    Couldn't match expected type `Data.ByteString.Internal.ByteString'
10:13:49 <sshc>            against inferred type `Data.ByteString.Lazy.Internal.ByteString'
10:13:49 <sshc>     In the first argument of `unsafeUseAsCString', namely
10:13:55 <ManateeLazyCat> sshc: Of course, if you sure C code won't touch CString, use unsafeUseAsCString, it's save memory than useAsCSTring
10:13:55 <mauke> sina: there are no functions in that code
10:14:02 <Eduard_Munteanu> Reflection?
10:14:25 <sshc> ManateeLazyCat: intl.h's gettext will touch it, but it won't modify it
10:14:25 <ManateeLazyCat> sshc: Oh, my bad, wrong memory in my mind. :)
10:14:25 <sina> mauke: call it a constant
10:14:33 <EvanR> sina: stringA isnt a function
10:14:38 <sshc> ManateeLazyCat: (Right?)
10:14:42 <mauke> sina: so what are you trying to do?
10:14:52 <EvanR> just use stringA normally
10:15:13 <ManateeLazyCat> sshc: I don't know the detail, you can try unsafeUseAsCString first, if some strange behaviour happened, then switch to useAsCSTring.
10:15:36 <ManateeLazyCat> sshc: Yes, from unsafeUseAsCString's behaviour, it's just work with strict bytestring.
10:15:40 <paolino> is possible to write a monad instance for "newtype Bifu m f a = Bifu {runBifu :: m (f a)}" when m and f are monads ?
10:15:46 <sina> EvanR: mauke: if I want to convert a String to a function/constant name, is it possible?
10:15:59 <EvanR> you want "stringA" ?
10:16:02 <mauke> sina: what does that mean?
10:16:08 <EvanR> or "ABCD"
10:16:14 <sshc> Thanks
10:16:21 <ManateeLazyCat> sshc: I have binding some GIO library before, and unsafeUseAsCString crazy me some time, strange behaviour disappear after i switch to useAsCString.
10:16:25 <Eduard_Munteanu> sina: y "doSomething" = doSomething   -- ?
10:16:39 <ManateeLazyCat> sshc: So you must test C binding after you use unsafeUseAsCString . :)
10:16:42 <EvanR> thats the opposite direction Eduard_Munteanu 
10:16:49 <EvanR> but could be what he wants nontheless
10:16:54 <Eduard_Munteanu> I'm clueless :)
10:17:20 <EvanR> i might want f stringA = "stringA", f stringB = "stringB" 
10:17:23 <EvanR> er he might
10:17:36 <EvanR> which is not right
10:17:56 <sina> EvanR: mauke: I will call y "stringA" and want y to call stringA. for example stringA = "ABC" , and I call y "stringA" and then I want to get "ABC"
10:18:00 <sshc> ManateeLazyCat: Can I pass CString to a function that expects "const char *"?
10:18:10 <ManateeLazyCat> sshc: Yes.
10:18:13 <mauke> sina: so why aren't you using a map?
10:18:30 <ManateeLazyCat> sshc: In C, "constr char *" is CString (byte string)
10:18:46 <ManateeLazyCat> sshc: So you need convert ByteString to CString to avoid encoding problem.
10:18:56 <EvanR> fromList [("stringA", "ABC")]
10:19:05 <Ziphilt> i seem to be hopelessly lost
10:19:08 <sina> mauke: how can I do that?
10:19:18 <Ziphilt> i made sure ~/.cabal/bin is in my path
10:19:20 <Taejo> is trac.haskell.org down?
10:19:23 <mauke> sina: by writing code
10:19:29 <sshc> Is CString "const char *" or just "char *", or bothH?
10:19:35 <ManateeLazyCat> sshc: Remember, don't convert String to CString directory (withCString) until you sure C library use CString as UTF-8 explicitly.
10:19:38 <sina> EvanR: I cannot use something like that. I must use the variables. its not for a personal project.
10:19:41 <mauke> sshc: Ptr CChar
10:19:51 <mauke> sshc: the FFI doesn't care about const
10:19:57 <Ziphilt> gtk2hs-buildtools seems to have installed correctly, but that doesn't change the errors in trying to install the other packages
10:20:01 <ManateeLazyCat> mauke: CString == Ptr CChar
10:20:01 <paolino> sina you can use guards
10:20:03 <sshc> Thanks, mauke 
10:20:08 <sshc> (Also, I can't use unsafeUseAsCString because it's not always null terminated)
10:20:09 <mauke> sina: what is this for?
10:20:13 <EvanR> f "stringA" = "ABCD"
10:20:19 <ManateeLazyCat> Ziphilt: Make sure ~/.cabal/bin/ in your PATH environment.
10:20:22 <sina> so I need to use stringA stringB ... cannot make tuples ("stringA","ABC") ...
10:20:28 <mauke> sina: why?
10:20:46 <sina> paolino: so the only way is to make a if else, right?
10:20:49 <ManateeLazyCat> Ziphilt: If it not in ~/.cabal/bin, cabal still can't found tools provide by gtk2hs-buildtools even you have install it.
10:21:01 <EvanR> haskell does not know the variable names at runtime, your project is out of luck sina 
10:21:03 <sina> mauke: its an assignment.
10:21:04 <Heffalump> is community down?
10:21:56 <dschoepe> Heffalump: it's httpd is, yes.
10:22:00 <EvanR> sina: and if wouldnt work
10:22:03 <mauke> sina: what does the assignment say?
10:22:05 <Ziphilt> ManateeLazyCat: it is definitely in the path now
10:22:14 <Ziphilt> but no luck still
10:22:24 <EvanR> sina: you cant use "stringA", your requirement was to use stringA the variable name directly
10:22:35 <ManateeLazyCat> sshc: If C code CString is encoding unsure, then binding ByteString, if CString is UTF-8 encoding, binding String.
10:22:41 <sina> mauke: I am given a set of constants (stringA, stringB) . I need to use them in the code. and the person is just going to call the name.
10:22:54 <ManateeLazyCat> sshc: Because on Haskell side, type 'String' always UTF-8.
10:23:08 <EvanR> f stringA works
10:23:12 <ManateeLazyCat> Ziphilt: Paste your newest error.
10:23:17 <mauke> sina: is the assignment text online?
10:23:22 <sina> EvanR: I am not sure about that. although that is what I just decided to do. even if I lose marks, I'm not going to make a massive if/else thing :)
10:23:41 <EvanR> sina: just paste the assignment exactly
10:24:25 <Ziphilt> http://fpaste.org/yfa9/
10:24:36 <Ziphilt> ManateeLazyCat: the problem is now cairo, it seems
10:24:39 <sshc> ManateeLazyCat: I thought String was always UTF-16?
10:24:46 <sshc> I thought Char's were 16 bits wide
10:24:51 <EvanR> thats Java
10:24:55 <sina> mauke: EvanR: I will just go with calling the names directly. thanks for the help. the assignment is not online and its massive. if I get into a big problem, I will upload it. otherwise, I better try to do it myself :) cause I need to learn.
10:25:22 <mauke> sshc: String is not in any encoding
10:25:31 <mauke> it's a list of unicodepoints
10:25:35 <ManateeLazyCat> Ziphilt: Well, you need install glib too.
10:25:51 <Eduard_Munteanu> @src Char
10:25:51 <lambdabot> data Char = C# Char#
10:26:01 <Eduard_Munteanu> @src Char#
10:26:01 <lambdabot> Source not found. I feel much better now.
10:26:05 <Ziphilt> ManateeLazyCat: cabal doesn't know how to install dependencies?
10:26:09 <EvanR> why is the src of Char even in there
10:26:10 <ManateeLazyCat> Ziphilt: Install gtk package from hackage by "cabal install gtk", then it will install it's depend (glib, pango, cairo)
10:26:28 <Eduard_Munteanu> > maxBound ('c' :: Char)
10:26:28 <ManateeLazyCat> Ziphilt: I guess you download gtk.tar.gz package and install local?
10:26:29 <lambdabot>   No instance for (GHC.Enum.Bounded (GHC.Types.Char -> a))
10:26:29 <lambdabot>    arising from a ...
10:26:34 <dschoepe> Ziphilt: the non-haskell-glib headers
10:26:45 <EvanR> > maxBound :: Char
10:26:46 <lambdabot>   '\1114111'
10:26:57 <Ziphilt> dschoepe: that clears it up, thanks
10:26:59 <mauke> 21 bits
10:27:13 <ManateeLazyCat> Ziphilt: Try "cabal install glib pango cairo gio gtk"
10:27:32 <Ziphilt> ManateeLazyCat: i think i am missing C headers, collecting those now
10:28:10 <ManateeLazyCat> Ziphilt: Oh, yes, i missing thta.
10:28:17 <ManateeLazyCat> Ziphilt: Cairo's C library.
10:30:45 <sina> guys, can I have something like this (this is not related to my discussion above)  type x = (String,String,String)->(Int,Int,Int)
10:30:59 <EvanR> type X = 
10:31:09 <sina> sorry X.
10:31:29 <monochrom> yes
10:31:30 <sina> if so, how can I use the (Int,Int,Int) part in the program?
10:31:32 <ManateeLazyCat> sina: Yes.
10:31:54 <dschoepe> sina: by giving the thing of type X a triple of Strings
10:31:54 <monochrom> X is now a function type. Write an actual function. Give it actual parameters.
10:31:58 <EvanR> > (\(s1,s2,s3) -> (length s1, length s2, length s3)) ("one","two","three")
10:31:59 <lambdabot>   (3,3,5)
10:32:00 <Ziphilt> ManateeLazyCat: found what i think are ALL the headers i need, i'll tell you if cabal works in a minute
10:32:18 <ManateeLazyCat> Ziphilt: Great.
10:32:34 <EvanR> > let (_,_,x) = (\(s1,s2,s3) -> (length s1, length s2, length s3)) ("one","two","three") in x
10:32:35 <lambdabot>   5
10:33:02 <sina> I mean in the actual function. like I have functionA thingWithTypeX = ...
10:33:05 <monochrom> Soon you will accept that just because a type expression contains a substring "Money" doesn't mean you can extract money from it.
10:33:07 <ManateeLazyCat> EvanR: Or sina  want 'read' ?m 
10:33:36 <ManateeLazyCat> monochrom: Good point. :)
10:33:45 <mauke> <dschoepe> sina: by giving the thing of type X a triple of Strings
10:33:46 <monochrom> In fact, sometimes it is the contrary. The type expression "Money -> ()" means you have to put in money and get nothing.
10:34:06 <mux> this type is economically unsound
10:34:08 <sina> mauke: I know how to call the function. I dont know how to make the function :D
10:34:15 <monochrom> US_Economy :: Money -> ()
10:34:25 <EvanR> sina: f (s,r,t) = (?,?,?)
10:34:26 <mauke> sina: you don't have to make the function
10:34:35 <mauke> according to your description
10:34:37 <EvanR> f :: X
10:35:12 <sina> EvanR: thanks. that was what I was looking for.
10:35:19 <monochrom> tron :: Coin -> Master_Control_Program
10:35:21 <lysgaard> Is there a zipWith for maps. That zips the values of equal keys in two maps with a function?
10:36:06 <ManateeLazyCat> @hoogle curry
10:36:06 <lambdabot> Prelude curry :: ((a, b) -> c) -> a -> b -> c
10:36:06 <lambdabot> Data.Tuple curry :: ((a, b) -> c) -> a -> b -> c
10:36:06 <lambdabot> Prelude uncurry :: (a -> b -> c) -> (a, b) -> c
10:36:28 <ManateeLazyCat> @hoogle zipWithKey
10:36:28 <lambdabot> No results found
10:36:33 <Ziphilt> Preprocessing library gtk-0.11.2... takes a hella long time, i almost thought it was hanged
10:36:50 <ManateeLazyCat> Ziphilt: No, wait it.
10:37:01 <Ziphilt> understandable, it's huge
10:37:07 <Ziphilt> i did wait, and it continued
10:37:18 <ManateeLazyCat> Ziphilt: gtk2hs darcs is bigger (next version)
10:37:37 <monochrom> The great thing about "I have proved termination" still doesn't tell you how long to wait.
10:40:09 <EvanR> if you give every possible answer, sina either must get it, or not be legitimate
10:40:13 <astroboy> I wrote a parser for a programming language in Parsec. Now I'm doing semantics analysis on the abstract syntax tree, what's the best way to keep track of the position in the file while traversing the tree? is there any other way other then hard coding positions into the tree?
10:40:22 <ManateeLazyCat> I have test gold-linker some minutes, really good, save much time for me. :)
10:40:36 <lysgaard> ManateeLazyCat: Think I found it, intersectienWith =)
10:40:38 <EvanR> astroboy: thats not really hard coding is it
10:40:38 <ManateeLazyCat> Shame not know gold-linker before.
10:40:43 <Ziphilt> astroboy i hear zippers do that
10:41:00 <Ziphilt> if i understand what you are asking
10:41:04 <ManateeLazyCat> lysgaard: Great, i remember have it, but forgot function name. :)
10:41:28 <astroboy> EvanR: well yes it is, becase I would have to store the position in the file in the tokens of the AST or something like that
10:41:29 <EvanR> astroboy: if theres no file position information in the tree, you can keep track of it
10:41:47 <EvanR> in some of the nodes maybe
10:41:59 <astroboy> yeah... I feared it was the only way
10:42:17 <EvanR> if theres no file position information in the tree, you cant keep track of it
10:42:35 <EvanR> unless you have a 'newline' token?
10:42:52 <astroboy> whell maybe using a monad to go trough the tree
10:43:00 <EvanR> trees dont have lines
10:43:08 <EvanR> generally
10:43:23 <Ziphilt> ManateeLazyCat: Yi installed and probably working, now to learn how to use it!
10:43:23 <astroboy> EvanR: yes but if I follow the tree with a monad
10:43:30 <EvanR> and?
10:43:32 <Ziphilt> thanks all
10:43:34 <EvanR> so you can keep a node coun
10:43:40 <astroboy> yes
10:43:51 <EvanR> is there one token per line?
10:43:57 <astroboy> no but my idea is
10:44:06 <astroboy> the monad has a tree with just positions
10:44:16 <astroboy> of the same structure of the tree with the actual information
10:44:32 <astroboy> so I follow the tree and the monad tree at the same time
10:44:34 <EvanR> well before travesing i would zip those trees
10:44:44 <astroboy> so when I want the position I "ask" the monad
10:44:47 <EvanR> then i traverse one tree
10:44:55 <astroboy> in this way I would hide all the position stuff
10:45:08 <astroboy> actually I would just output the position in "fail"
10:45:12 <EvanR> you dont want to hide it, you want to use it
10:45:25 <EvanR> fail? uhg
10:45:25 <monochrom> astroboy: GHC itself does exactly include line numbers etc. in every node in ASTs.
10:45:43 <astroboy> monochrom: ok, so I guess it's the best way :P. it seemed ugly to me
10:45:54 <EvanR> its a syntax tree
10:46:01 <EvanR> newlines are part of the syntax
10:46:04 <astroboy> no
10:46:04 <monochrom> Oh, they use a polymorphism trick to make it less ugly.
10:46:10 <astroboy> not in my language
10:46:16 <EvanR> aparently they are
10:46:33 <astroboy> no they're not, as they are not in C and loads of language
10:46:51 <astroboy> and anyway
10:46:54 <EvanR> if i put a new line in the middle of a string literal in C, it fails
10:47:00 <EvanR> unless i put \ before it
10:47:13 <astroboy> EvanR: I am talking about the abstract syntax tree. I am not producing tokens
10:47:55 <monochrom> define AST node type like "data MyNode p = CaseInt Int p | CasePlus (MyNode p) (MyNode p) p | ...".  The type parameter p is then instantiated to line-number record in actual use, e.g., "data LineNumber = LN { filename::String, linenumber::Int }", then you use "MyNode LineNumber"
10:48:03 <EvanR> a separate line number tree makes sense, but since its the same structure, it would be easier to combine them, and the monad can either query the current token or the current postiion
10:48:43 <astroboy> That's an example of the ast I have: Program [Declare Int32 "x",Assign "x" (Int 42),Return (Var "x")]
10:48:46 <EvanR> combine the separate trees before traversing
10:48:54 <sinelaw> aloha
10:49:47 <astroboy> monohrom: that was the initial idea, but it looks ugly to me :P. not a tragedy anyway
10:49:57 <monochrom> ah, heh.
10:50:04 <astroboy> and I would have to remove the positions before code generation anyway
10:50:27 <sshc> Does Data.Text store strings in Word16 arrays in big endian or little endian?
10:50:48 <EvanR> @src Text
10:50:48 <lambdabot> Source not found. Just try something else.
10:51:22 <EvanR> sshc: shouldnt you only be worried about encoding text or decoding input into text?
10:51:24 <monochrom> removal of LineNumber just requires MyNode to be a Functor instance, then fmap (const ()) :: MyNode LineNumber -> MyNode ()  XD
10:51:56 <astroboy> monochrome: yes of coure
10:51:58 <astroboy> *course
10:52:05 <sshc> Ah, "The Text type's internal representation is UTF-16, using the platform's native endianness."
10:52:23 <EvanR> hopefully you dont use that information for anything ;)
10:52:30 <monochrom> it is ugly but we mitigate it by slapping a lot of unnecessary category theory on it. :)
10:52:50 <ManateeLazyCat> sshc: Text -> CString is also good solution too. :)
10:53:41 <astroboy> also, it's a pain because I have to extract the position from the parsec parser
10:54:05 <sshc> EvanR: I need to safely and efficiently pass a Data.Text.Text to c_gettext, which :: CString -> IO CString
10:54:14 <monochrom> Ah! I forgot that parsec's tokenizer doesn't really help that.
10:54:22 <astroboy> i'll probably have to create a new monad for that, with a different return function
10:55:04 <EvanR> sshc: which wants it in utf8?
10:55:18 <sshc> EvanR: Doesn't gettext needs to know the endianness?
10:55:27 <EvanR> not in utf8
10:55:53 <sshc> EvanR: With utf16?
10:55:59 <EvanR> it even accepts utf16?
10:56:13 <ManateeLazyCat> sshc: If you binding CString, best use ByteString. 
10:56:27 <ManateeLazyCat> sshc: And binding function don't need care encoding problem.
10:56:38 <sshc> Ah, I should convert it to a ByteString
10:56:40 <ManateeLazyCat> sshc: It's duty of user.
10:56:59 <EvanR> i.e. the duty of sshc 
10:57:06 <ManateeLazyCat> sshc: So 'Text -> ByteString -> CString' ? why not just 'ByteString -> CString'.
10:57:26 <astroboy> this is annoying, doesn't parsec provide something to make that easier?
10:57:37 <ManateeLazyCat> sshc: You just need use 'ByteString -> CString', then let user do 'Text -> ByteString' or 'String -> ByteString'.
10:58:08 <ManateeLazyCat> sshc: Because C code use *byte string*, C code don't care encoding problem.
10:59:42 <stepcut> ManateeLazyCat: that doesn't make sense.. the C code can not do anything with a string of bytes unless it knows what format they are in
10:59:53 <EvanR> stepcut: yeah it can
11:00:00 <ManateeLazyCat> stepcut: No.
11:00:01 <EvanR> most unix code does that ;)
11:00:07 <stepcut> EvanR: :)
11:00:24 <ManateeLazyCat> stepcut: And you don't need care that.
11:00:41 <stepcut> EvanR: most unix doesn't do anything with it, it just treats it opaquely :p
11:00:43 <monochrom> instead of C code, you should talk about the programmers behind.
11:01:18 <monochrom> some programmers (ignorant ones) pretend it's all ascii, that's how they unify byte string with text.
11:01:29 <EvanR> stepcut: moves it around, measures the amount of it, prints it to the screen ;)
11:01:41 <EvanR> just hope its in utf8 or it will look weird!
11:01:42 <stepcut> EvanR: amount in what units ?
11:01:45 <EvanR> bytes
11:01:46 <ManateeLazyCat> monochrom: System.FilePath System.Directory use withCString always. 
11:01:49 <monochrom> enlightened programmers are exactly like what you say, they need to know encoding before they agree the byte string is meaningful at all
11:02:10 <stepcut> EvanR: so, yes, it does that all treating the bytes pretty opaquely
11:02:22 <EvanR> yes
11:02:41 <EvanR> unless youre dealing with the ascii - utf8 legacy stuff
11:02:44 <EvanR> thats what i was referring to
11:03:11 <ManateeLazyCat> I use ByteString as low-level communicate string, i just need decode it when i need *display* it.
11:03:28 <ManateeLazyCat> So low-level library always work even it don't the encoding of string.
11:03:54 <stepcut> ManateeLazyCat: there are many possibly ways to encoding Text into a string of bytes. gettext is going to use those bytes to lookup a value in the translation table. But if you are using a different encoding that what gettext expects, then it is not going to find a match, yes ?
11:03:56 <EvanR> gettext seems to need to know the encoding though, or not?
11:04:06 <monochrom> that is just an decode-encode fusion optimization
11:05:37 <ManateeLazyCat> stepcut: No, bytestring don't care the encoding of string. 
11:05:44 <dmwit> Heffalump: pong
11:05:45 <ManateeLazyCat> stepcut: It just search *bytes*
11:05:54 <stepcut> ManateeLazyCat: the bytestring does not, but the C function that is using the bytestring cares
11:06:28 <EvanR> stepcut: i guess you were emphasizing text strings in C... you know... the code can 'do something' just fine if its supposed to be an array of bytes ;)
11:06:43 <EvanR> crypto
11:06:59 <monochrom> @quote monochrom Dilbert
11:06:59 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
11:07:25 <ManateeLazyCat> stepcut: Until C code need some encoding string speical.
11:07:28 <stepcut> ManateeLazyCat: yes exactly. The gettext is going to use the *bytes* to look something up. But since there are muliple different ways to represent a string as bytes, everyone needs to use the same representation, or the values won't be found
11:08:12 <EvanR> liskov for the lose
11:08:17 <stepcut> EvanR: yes -- because the discussion was about how to pass Text to a function that needs CString ..
11:08:38 <EvanR> stepcut: you gotta agree on an encoding
11:08:50 <stepcut> EvanR: that is what I am saying...
11:09:02 <EvanR> the fact that text uses utf16 internally is irrelevant
11:09:42 <EvanR> if theres an efficiency factor, you want to avoid an encode decode process, you have to use bytestring everywhere and keep it in the agreed encoding, is what ManateeLazyCat is saying
11:09:42 <stepcut> right, ManateeLazyCat said, "Because C code use *byte string*, C code don't care encoding problem.", which is what I am disagreeing with 
11:10:56 <EvanR> C code doesnt even use byte strings ;)
11:10:57 <stepcut> EvanR: right, that is different
11:11:13 <EvanR> char arrays
11:11:20 <stepcut> EvanR: yeah
11:11:25 <EvanR> an insane concept
11:11:29 <ManateeLazyCat> stepcut: Except some C code need some encoding (e.g. UTF8) explicitly
11:12:10 <ManateeLazyCat> stepcut: Yes, even some C code use "byte string", it's still have special encoding.
11:12:27 <ManateeLazyCat> stepcut: It's depend the implementation of C code.
11:13:09 <EvanR> uint8_t bs[]
11:15:18 <ManateeLazyCat> I hate disorder encoding environment.
11:24:34 <ManateeLazyCat> I need sleep now, if anyone have problem with gtk2hs darcs, leave message to me. Of course, any successful feedback are welcome. :)
11:25:53 <ManateeLazyCat> Thanks! :)
11:26:57 <ManateeLazyCat> I guess Axel working on convert darcs2-format and writing documentation. :)
11:27:07 <ManateeLazyCat> Ok, night all. :)
11:27:17 <taktoa> I have a strange problem with cabal
11:27:29 <taktoa> often, when I try to install a package
11:27:35 <taktoa> it gives me this error:
11:27:35 <taktoa> http://hpaste.org/41215
11:27:51 <taktoa> I've googled and googled and found nothing
11:28:42 <taktoa> I'm considering reinstalling the haskell platform
11:29:03 <taktoa> but I want to make sure there aren't any easier options before I try that
11:29:50 <Rotaerk> you've only googled and googled?   you should google and google and *google*.
11:30:31 <aristid> and also google
11:31:01 <Heffalump> dmwit: was just wondering about your HTTP patch - why did you change an existing function rather than adding a new one?
11:31:08 <tonkman> I also recommend googling
11:31:08 <Heffalump> (given the compatibility issues)
11:31:10 <taktoa> my brother works for google, should I ask him :P?
11:31:29 <aristid> taktoa: what does "cabal info Cabal" print?
11:32:33 <taktoa> http://hpaste.org/41216/
11:32:43 <taktoa> ^ that's the result of cabal info Cabal
11:33:45 <taktoa> hmm... I'm now running cabal install Cabal
11:34:00 <taktoa> apparently, I'm using version 1.8.0.2
11:34:06 <taktoa> instead of 1.8.0.6
11:34:08 <aristid> taktoa: what's your PATH?
11:34:21 <Heffalump> dmwit: obviously changing the function is right if that's the natural interface, but it doesn't really feel like it; the flag feels like a hack that could equally be handled by a separate function.
11:34:30 <taktoa> /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
11:34:46 <aristid> taktoa: add $HOME/.cabal/bin to the front of the path
11:35:11 <taktoa> how do you change the PATH again
11:35:18 <taktoa> export <something>
11:35:20 <taktoa> right?
11:35:39 <Vanadium> export PATH=$HOME/.cabal/bin:$PATH
11:35:47 <taktoa> thanks
11:36:46 <mauke> why export it?
11:37:07 <mauke> it's probably already exported, and only the shell cares anyway
11:37:14 <mauke> hmm, not true
11:37:26 <Vanadium> I have no idea what export does, but it never seemed to hurt and was sometimes necessary.
11:37:27 <mauke> it has to affect child processes, so it's already exported
11:37:40 <mauke> 'export' marks it as an environment variable
11:37:40 <Eduard_Munteanu> 'FOO=bar ./program' is just like exporting for a single command
11:37:44 <Vanadium> Oh.
11:37:49 <mauke> otherwise it's just an internal shell variable
11:37:51 <Eduard_Munteanu> Although I'm not sure if that works for path resolution.
11:37:56 <Vanadium> I did not realise that was a distinction.
11:38:18 <Eduard_Munteanu> like 'PATH=foo program', I'm not sure it alters the path where program is searched for.
11:39:01 <Funktorsalat> seems like it
11:39:04 <Funktorsalat> PATH=/ ls
11:39:06 <Funktorsalat> not found
11:39:22 <Funktorsalat> in zsh anyway
11:39:27 <Nibble> Funktorsalat: zsh ftw
11:39:28 <Eduard_Munteanu> Ah, makes sense then. Still, I assume bash-completion doesn't work correctly.
11:39:42 <Eduard_Munteanu> s/correctly/as intended/
11:40:01 <taktoa> thanks, that worked
11:40:42 <Funktorsalat> Nibble: hmm yes, I like it as far as shells go ;)
11:41:28 <Eduard_Munteanu> Hm, I thought about trying it sometime, didn't have a chance.
11:41:37 <Funktorsalat> the syntax is so ridiculously overloaded it's good again :D
11:41:51 <Funktorsalat> (for globbing, variable expansion etc)
11:41:54 <Eduard_Munteanu> What was that Haskell shell again?
11:42:42 <Eduard_Munteanu> I think somebody was working on stuff like that.
11:43:07 <aristid> Eduard_Munteanu: ghc
11:43:13 <aristid> ghci i mean
11:43:13 <Eduard_Munteanu> Heh.
11:43:33 <Eduard_Munteanu> aristid: nah, some sort of Haskellish shell that can be reasonably used as such.
11:43:33 <Funktorsalat> Eduard_Munteanu: there's hashell but it seems to be abandoned
11:43:39 <Eduard_Munteanu> Oh.
11:43:55 <Funktorsalat> Eduard_Munteanu: and there's HSH
11:44:02 <Funktorsalat> (which is a haskell lib, not a shell)
11:44:05 * Eduard_Munteanu looks them up
11:44:35 <Funktorsalat> it has a module with functions named after common commands :)
11:44:56 <Funktorsalat> ('cd' is better than 'setCurrentDirectory' for shelly use I think :o)
11:46:03 <Saizan> (are you sure?)
11:47:18 <Eduard_Munteanu> Hm... I'm not sure I'll change my login to /usr/bin/ghci yet :)
11:47:46 <Eduard_Munteanu> ghci + hsh look interesting though
11:48:12 <Eduard_Munteanu> Hashell looks really old
11:49:02 <Eduard_Munteanu> Ah, >GHC 6.4, not that bad though.
11:49:50 <Saizan> the other day i had to delete some files with names starting with -, "rm *" failed since they were parsed as options, mapM removeFile (getDirectoryContents ".") worked perfectly
11:49:59 <mauke> rm -- *
11:50:01 <mauke> lern2unix
11:50:29 <mauke> rm ./* also would have worked, though
11:50:58 <Saizan> thanks, i knew there was a solution, i just went with what seemed more reasonable though
11:51:18 <Funktorsalat> echo * | cat | cat | cat | cat | cat | xargs rm --
11:51:24 <mauke> your definition of reasonable is weird
11:51:31 <mauke> also, mapM_
11:51:46 <unkanon> are we talking about a functional shell?
11:51:54 <Funktorsalat> hmm maybe s/echo/print -l/ there :o
11:52:11 <mauke> perl -e 'unlink glob "*"' :-)
11:54:02 <unkanon> quick question, how do I make this work by using a monad to make the (++) work inside the lists? ->  zipWith (++) "abc" "abc"
11:54:13 <unkanon> I know how to make it work with a lambda
11:54:32 <mauke> huh?
11:55:08 <unkanon> i wanna get ["aa","bb","cc"]
11:55:27 <EvanR> > 'a' ++ 'b'
11:55:27 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
11:55:28 <lambdabot>    arising from a use o...
11:55:34 <EvanR> > 'a':'b':[]
11:55:35 <lambdabot>   "ab"
11:55:37 <Funktorsalat> > zipWith ((++) `on` return) "abc" "abc"
11:55:38 <lambdabot>   No instance for (Data.Monoid.Monoid (m GHC.Types.Char))
11:55:38 <lambdabot>    arising from a u...
11:56:01 <Funktorsalat> > zipWith ((++) `on` (:[])) "abc" "abc"
11:56:02 <lambdabot>   ["aa","bb","cc"]
11:56:04 <EvanR> unkanon: ++ works on lists, not characters
11:56:17 <EvanR> (:[]) <- the coolest function
11:56:18 <mauke> unkanon: how is this related to monads?
11:56:21 <unkanon> EvanR: i know, that's why i want to use a monad to make it work, no?
11:56:40 <EvanR> unkanon: list monad? ++ works on lists true, not chars
11:56:48 <EvanR> concat works on lists, not chars
11:56:53 <unkanon> mauke: i was hoping it would be able to lift char into [char] and make ++ work somehow
11:57:04 <mauke> (:[]) does that
11:57:04 <EvanR> return 'a' :: String
11:57:12 <EvanR> > return 'a' :: String
11:57:12 <lambdabot>   "a"
11:57:18 <mauke> and for lists, return = (: [])
11:58:01 <unkanon> mauke: if ^ is true then why didn't Funktorsalat 's code above work?
11:58:10 <Funktorsalat> caleskell ;)
11:58:18 <Funktorsalat> polymorphic (++)
11:58:23 <Funktorsalat> the intermediate type is ambiguous
11:58:25 <mauke> > zipWith ((++) `on` return) "abc" "abc" :: [String]
11:58:26 <lambdabot>   ["aa","bb","cc"]
11:58:27 <Funktorsalat> @ty (++)
11:58:28 <lambdabot> forall m. (Monoid m) => m -> m -> m
11:58:37 <Funktorsalat> (or the return type, even)
11:58:46 <unkanon> ?src on
11:58:46 <lambdabot> (*) `on` f = \x y -> f x * f y
11:59:29 <unkanon> lol, so with on and return, that code is literally this:  zipWith (\a b -> [a] ++ [b]) "abc" "abc"
11:59:42 <Funktorsalat> yes
11:59:55 <EvanR> zipWith (\a b -> a:b:[]) "abc" "abc"
11:59:57 <EvanR> > zipWith (\a b -> a:b:[]) "abc" "abc"
11:59:58 <lambdabot>   ["aa","bb","cc"]
12:00:04 <mauke> \a b -> [a,b]
12:00:11 <unkanon> well, i learned something
12:00:14 <EvanR> > zipWith (\a b -> [a,b]) "abc" "abc"
12:00:14 <lambdabot>   ["aa","bb","cc"]
12:00:38 <MrN_> list sections!
12:00:48 <MrN_> and why is my nick not aristid
12:02:08 <dmwit> Heffalump: Hm, maybe so.
12:02:44 <dmwit> Seems like there'd be some fair amount of code duplication then, though.
12:04:04 <EvanR> hotaru2k3 just jumped across the room
12:05:27 <unkanon> is the source of "on" using (*) just so that the left hand side be easy to read?
12:05:30 <unkanon> ?src on
12:05:30 <lambdabot> (*) `on` f = \x y -> f x * f y
12:05:37 <unkanon> sorry, right hand side
12:05:52 <EvanR> @src on
12:05:52 <lambdabot> (*) `on` f = \x y -> f x * f y
12:06:07 <EvanR> thats an interesting way to define a function
12:06:12 <mauke> unkanon: yes
12:06:18 <EvanR> formal operator
12:08:45 <Bussiness> Hi all
12:08:45 <unkanon> mauke: ok so they could've used : g 'on' f = \x y-> g(f x, f y)
12:09:00 <Bussiness> Who want to do some bussines with Haskell
12:09:00 <mauke> no
12:09:04 <EvanR> g (f x) (f y)
12:09:10 <Bussiness> Who want to do some bussines with Haskell??
12:09:11 <EvanR> you C head
12:09:15 <Bussiness> ping me
12:09:19 <Bussiness> in private
12:09:19 <mauke> also it's `on`, not 'on'
12:09:37 <mauke> on g f x y = g (f x) (f y)
12:10:19 <endojelly> mauke, oh you bet it's `on`, and you just got `served`.
12:10:23 <dmwit> Heffalump: going afk for a few hours
12:10:32 <funkyjunkyrobot> hi all, i'm new to haskell and i'm having some trouble making my first function
12:10:47 <funkyjunkyrobot> I"m getting this error : Occurs check: cannot construct the infinite type: a = [a]
12:10:50 <unkanon> EvanR: right right, that's it
12:11:06 <mauke> funkyjunkyrobot: that means you used a list as its element or vice versa
12:11:08 <funkyjunkyrobot> i want to move the head of a least to the last position
12:11:14 <Bussiness> ok I guess I need to be more specific, I have a job offer if you interest please let me know, the only requisite is that you need to know Haskell but that question in this channel is irrelevant
12:11:19 <mauke> funkyjunkyrobot: you probably did xs ++ x
12:11:25 <funkyjunkyrobot> yeah
12:11:31 <mauke> and that's wrong
12:11:34 <funkyjunkyrobot> :(
12:11:34 <mauke> ++ concats two lists
12:11:36 <mauke> x is not a list
12:11:43 <funkyjunkyrobot> ohhh
12:11:45 <funkyjunkyrobot> i see
12:12:00 <endojelly> funkyjunkyrobot, so, do you know what you have to do instead?
12:12:00 <unkanon> Bussiness: you misspelled business
12:12:06 <EvanR> Data.Sequence would support this more efficiently
12:12:19 <funkyjunkyrobot> let me think about it for a bit.
12:12:28 <Bussiness>  unkanon: I know 
12:12:34 <Bussiness> is a kool new name
12:12:47 <endojelly> funkyjunkyrobot, what do you need
12:12:50 <Bussiness> for Business
12:13:01 <unkanon> mauke: wow you're right, i thought i could use '' but it has to be ``
12:13:14 <mauke> '' is for Chars
12:13:19 <funkyjunkyrobot> well i want to take a list of lists and move the first list to the end based on it's value
12:13:22 <Bussiness> unkanon: Are you interest in the offer?
12:13:24 <endojelly> unkanon, ' is not reserved, you can use it in symbol names
12:13:46 <endojelly> funkyjunkyrobot, no, I mean, what do you need to make that work
12:13:51 <unkanon> endojelly: oh that's right, that's an allowed character for defining symbols
12:14:06 <unkanon> Bussiness: already have a job
12:14:09 <funkyjunkyrobot> put a list symbol around it?
12:14:12 <EvanR> ' cant be first in the name
12:14:26 <funkyjunkyrobot> = [xs ++ x]
12:14:32 <Bussiness> unkanon: is one day job
12:14:35 <endojelly> funkyjunkyrobot, it's not really called a list symbol but I think you're meaning the right thing
12:14:35 <unkanon> EvanR: yeah i can imagine how the grammar definition for symbols is :)
12:14:39 <endojelly> funkyjunkyrobot, aaah, nope
12:14:42 <endojelly> funkyjunkyrobot, close
12:15:03 <endojelly> funkyjunkyrobot, we have established thaty xs ++ x doesn't make sense
12:15:06 <EvanR> > let a'b = () in a'b
12:15:07 <lambdabot>   ()
12:15:23 <EvanR> > let can't = () in can't
12:15:24 <lambdabot>   ()
12:15:31 <endojelly> funkyjunkyrobot, why doesn't it make sense?
12:15:32 <funkyjunkyrobot> hmm, i don't know why exactly tho
12:15:44 <funkyjunkyrobot> because the ++ operator works on lists
12:15:48 <funkyjunkyrobot> and x is an element
12:15:50 <unkanon> EvanR: yeah, the LYAH define conanO'Brien
12:15:52 <endojelly> funkyjunkyrobot, what are it's arguments?
12:15:55 <EvanR> lol
12:15:57 <endojelly> funkyjunkyrobot, its arguments
12:15:58 <endojelly> type
12:16:00 <endojelly> typo
12:16:04 <endojelly> typo typo %)
12:16:14 <funkyjunkyrobot> it's armuments are a list and a list
12:16:21 <funkyjunkyrobot> so is xs a list, but x is not?
12:16:25 <Bussiness> *arguments
12:16:35 <unkanon> funkyjunkyrobot: that's it
12:16:38 <funkyjunkyrobot> ok
12:16:42 <endojelly> funkyjunkyrobot, yeah. x is in an element of said list.
12:16:46 <Bussiness> So nobody??????
12:16:48 <funkyjunkyrobot> so i need xs ++ [x]
12:16:48 <endojelly> funkyjunkyrobot, so you see why it doesn't work?
12:16:53 <endojelly> funkyjunkyrobot, you got it
12:16:56 <unkanon> funkyjunkyrobot: yes!
12:16:58 <funkyjunkyrobot> :) yay!
12:17:00 <unkanon> :)
12:17:07 <funkyjunkyrobot> i'm gona try it now , thank you so much
12:17:42 <endojelly> funkyjunkyrobot, so now you've hopefully learned: look what the functions that you're using really want. if it's different from what you have, see if you really got the right functions, and if you have, think how you can get what they want out of what you have.
12:17:59 <endojelly> funkyjunkyrobot, you're gonna get a grasp of all that 'type' stuff pretty quickly.
12:18:18 <funkyjunkyrobot> ok
12:18:22 <funkyjunkyrobot> thx
12:18:33 <endojelly> funkyjunkyrobot, (in case that isn't clear: operators are just functions, too)
12:18:44 <funkyjunkyrobot> i got that much
12:20:26 <lucasicf> hello people
12:23:01 <EvanR> > map (++) (tails [1,2,3,4,5])
12:23:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [t])
12:23:02 <lambdabot>    arising from a use ...
12:23:20 <EvanR> doh
12:25:40 <ddarius> > concat . tails $ [1..5]
12:25:41 <lambdabot>   [1,2,3,4,5,2,3,4,5,3,4,5,4,5,5]
12:26:49 <EvanR> > let cart xs = [(x,y)|x<-xs, y<-xs] in cart [1..5]
12:26:50 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(2,1),(2,2),(2,3),(2,4),(2,5),(3,1),(3,2),(3...
12:27:30 <ddarius> > transpose . tails $ [1..5]
12:27:31 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5]]
12:29:15 <JohnnyL> what do you guys use for an editor?
12:29:25 <nostrand> JohnnyL: Emacs
12:29:28 <Bussiness> notepad ++
12:29:31 <ddarius> vim
12:29:38 <syntaxglitch> SciTE
12:29:41 <Colours> TextMate
12:29:45 <EvanR> atomic force probe on the hdd platters
12:29:52 <aristid> > tails [1..5]
12:29:53 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
12:30:04 <unkanon> aristid: that's what i was about to do
12:30:15 <aristid> transpose . tails == init . tails? :D
12:30:35 <JohnnyL> EvanR: hahah
12:30:41 <aristid> > tails []
12:30:42 <lambdabot>   [[]]
12:30:48 <aristid> > transpose [[]]
12:30:49 <lambdabot>   []
12:31:09 <unkanon> i use textmate but i'm slowly switching to emacs
12:31:15 <unkanon> JohnnyL: ^
12:31:18 <monochrom> I use emacs for most of my haskell work
12:31:21 <EvanR> i use yerbamate
12:31:28 <unkanon> i drink yerbamate!
12:31:42 <monochrom> sometimes vim for an edit distance of <= 5
12:31:56 <Bussiness> monochrom: emacs have a debugger???
12:32:01 <monochrom> no
12:32:06 <Bussiness> oh
12:32:07 <monochrom> I have a debugger.
12:32:12 <Bussiness> which?
12:32:14 <EvanR> does haskell have a debugger
12:32:16 <EvanR> no
12:32:21 <EvanR> you dont need one!
12:32:27 <monochrom> monochrom OS version 2.4
12:32:36 <syntaxglitch> GHCi has a debugger, but it's not terribly useful
12:32:39 <Bussiness> thats you!!!!
12:33:03 <unkanon> haskell doesnt need a debugger, it only needs better explained error messages :P
12:33:14 <Bussiness> monochrom: thats you!!!!!!!!!!!!!!
12:33:15 <syntaxglitch> conventional approaches to debugging really don't fit well with lazy evaluation
12:33:50 <monochrom> If I have to comprehend some retard's 1000-line code, I will need a debugger.
12:34:09 <syntaxglitch> my usual debugging approach is to promote subexpressions to top-level functions temporarily and run them in GHCi
12:34:27 * ddarius uses conventional debuggers mostly as a glorified printf debugging.
12:34:47 <syntaxglitch> oh yeah, there is that
12:34:50 <lucasicf> what are the best application area to use functional programming? i've learned haskell this year and a professor of mine was telling it's very good to concurrency
12:34:53 <Eduard_Munteanu> Curiously I don't see anybody using Yi :D
12:35:06 <syntaxglitch> I've occasionally use unsafePerformPrintfDebugging
12:35:21 <Bussiness> what is YI????
12:35:27 <Bussiness> Yi????
12:35:29 <monochrom> My own code, first of all I keep it so simple it obviously has no problem, and secondly I comment it so well that a year later I can read the comment to see what's my rationale.
12:35:36 <EvanR> ????
12:35:43 <Eduard_Munteanu> Bussiness: an editor written in Haskell.
12:35:46 <EvanR> Bussiness has a ???? key on the keyboard
12:35:47 <unkanon> monochrom: so you write literate haskell then?
12:35:47 <EvanR> very useful
12:35:57 <monochrom> Not always literate.
12:36:00 <Eduard_Munteanu> EvanR: I wonder what Unicode codepoint is that :D
12:36:17 <Eduard_Munteanu> (not that I use Yi, just Vim)
12:36:21 <syntaxglitch> lucasicf, depends on your definition of "best"
12:36:21 <EvanR> i dont know but you can input it with an input method
12:36:30 <Bussiness> EvanR : funny lol
12:36:30 <EvanR> shift / / / /
12:36:47 <monochrom> But see for example the comment for the "euclid" function in http://www.vex.net/~trebla/haskell/calculator/Calculator.hs
12:36:56 <Eduard_Munteanu> Looks a lot like an Emacs combo :P
12:36:56 <lucasicf> that's not exactly best... but areas that functional programming is good
12:36:57 <EvanR> in windows
12:37:08 <EvanR> maybe mac
12:37:21 <syntaxglitch> if you mean "easiest given current tools" I think writing a compiler is a pretty common example
12:37:45 <lucasicf> i liked to program in haskell, i realized some advantages compared to imperative 
12:37:49 <monochrom> I completely disbelieve that source code has all the information. source code has only, say, the last 20% of all the information.
12:37:49 <unkanon> monochrom: gotcha
12:38:12 <lucasicf> that's just what i'm writing, a compiler
12:38:26 <ddarius> monochrom: Why don't you just reference Elements?
12:38:34 <lucasicf> and i think if i tried to write it with C, i'd have much more headaches
12:38:47 <monochrom> The explanation in Elements sucks.
12:38:48 <EvanR> the problem with haskell being good at implementing compilers is, after you learn haskell you see no point in implementing any further compilers for anything else
12:38:57 <ddarius> monochrom: That's true.
12:39:10 <EvanR> nullifying that feature (except maybe for ghc)
12:39:12 <unkanon> EvanR: lispers say the same about lisp ;)
12:39:22 <lucasicf> yes
12:39:30 <EvanR> the difference is lisp is crap
12:39:37 <syntaxglitch> EvanR, no, the next you implement is an Agda compiler
12:40:12 <monochrom> Not to impeach Euclid, but his was written in a time when "invariant" was not quite known, for example. And oh, highschool algebra too.
12:40:25 <Eduard_Munteanu> Quick history question... what was GHC written into? I think GHC was the first or a descendent thereof.
12:40:40 <unkanon> c-- ?
12:41:00 <Eduard_Munteanu> I doubt it, I think that's used only as a backend for the compiler itself.
12:41:02 <monochrom> And oh, I do invite you to play with my http://www.vex.net/~trebla/homework/extended-euclid.html
12:41:07 <syntaxglitch> if memory serves me, GHC has been self-hosting for longer than it's been plausibly able to do so
12:41:09 <ddarius> Eduard_Munteanu: GHC was written in Haskell and compiled by HBC.
12:41:29 <ddarius> GHC has never been written in another language.
12:41:31 <Eduard_Munteanu> Oh, since the very beginning, I see.
12:41:34 <syntaxglitch> I seem to recall one of the Simons saying something about how early versions had to recompile themselves a few times until it hit some sort of fixed point and everything finally worked
12:41:44 <ddarius> HBC was boot-strapped via LML.
12:41:56 <Eduard_Munteanu> I see.
12:42:35 <funkyjunkyrobot> hi all, i am having trouble understanding how lists work. mainly how to address them.
12:42:48 <EvanR> use indirect addressing
12:42:48 <medfly> :t (!!)
12:42:49 <lambdabot> forall a. [a] -> Int -> a
12:42:52 <funkyjunkyrobot> so i am taking in a list of a list of ints [[int]]
12:43:03 <EvanR> you want an array instead
12:43:09 <EvanR> :t (!)
12:43:10 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
12:43:36 <funkyjunkyrobot> well not quite it's more basic than that
12:43:50 <syntaxglitch> don't use (!!)
12:43:52 <syntaxglitch> seriously
12:43:59 <syntaxglitch> it shouldn't even exist, it's a terrible idea
12:44:12 <funkyjunkyrobot> my lists are formatted like [[1,2,3],[1,2,3],[1,2,3]]
12:44:19 <funkyjunkyrobot> so a list of lists with 3 elements in them
12:44:28 <EvanR> why not use an array then
12:44:34 <EvanR> 3x3
12:44:36 <funkyjunkyrobot> i want to check the first number in a sub list to see if it's a one or zero
12:44:44 <tg_> syntaxglitch: is this a universally agreed maxim, or your well-founded opinion?
12:44:53 <mauke> EvanR: tuple!
12:45:02 <EvanR> :t thr
12:45:02 <lambdabot> Not in scope: `thr'
12:45:03 <Eduard_Munteanu> funkyjunkyrobot: by array, EvanR also means two dimensional arrays
12:45:04 <EvanR> :t thd
12:45:05 <lambdabot> Not in scope: `thd'
12:45:10 <funkyjunkyrobot> k
12:45:19 <funkyjunkyrobot> and i want to use xs to describe it
12:45:29 <funkyjunkyrobot> so xs is a a list right
12:45:40 <funkyjunkyrobot> so i want to know about this xs convention
12:45:49 <funkyjunkyrobot> whats the head and whats the tail
12:45:57 <EvanR> your original data structure more often would be called xss
12:45:58 <funkyjunkyrobot> or should i make it (x:xs)
12:46:27 <syntaxglitch> tg_, Haskell lists are sequential data structures, like a linked list. Using (!!) to get the Nth element traverses the entire list up to that point
12:46:35 * monochrom trolls with "you address lists with 'dear sirs/madams', make sure it's plural"
12:46:42 <funkyjunkyrobot> my lists represent train tracks essentialy and a curved peice stat with a zero and a straight peice stats with a one
12:46:46 <funkyjunkyrobot> i want to count the curves
12:46:58 <EvanR> syntaxglitch: so are hard disks, doesnt stop us from using them like random access xD
12:47:16 <ddarius> EvanR: Hard disks are sequential.
12:47:17 <syntaxglitch> There's not anything inherently wrong with (!!) as such, it's just that its existence combined with the ubiquity of lists in Haskell makes people think writing code that way is a good idea
12:47:18 <Heffalump> anyone know what's wrong with the web server on community?
12:47:22 <ddarius> s/are/aren't
12:47:46 <monochrom> random access means hierarchical logarithmic access.
12:47:58 <syntaxglitch> I've seen questions on Stack Overflow where people were iterating through a list of ints and indexing a list using (!!)
12:48:33 <EvanR> funkyjunkyrobot: sounds like you want a 3x3 array of train tracks
12:48:35 <EvanR> not numbers
12:49:00 <monochrom> I don't mind using (!!) as a first attempt or as part of the specification. I do it all the time.
12:49:24 <EvanR> well a 2d !! sounds annoying
12:49:25 <funkyjunkyrobot>  countCorners:: [[int]] -> int
12:49:26 <funkyjunkyrobot>  countCorners [] = 0
12:49:26 <syntaxglitch> Which is why I always tell people to never use (!!), anyone who knows what they're doing to use (!!) properly knows better than to listen to me say not to use it
12:49:26 <funkyjunkyrobot>  countCorners (x:sx) if x==0 then 1 + countCorners xs
12:49:26 <funkyjunkyrobot>  
12:49:49 <syntaxglitch> for instance, people like monochrom :P
12:49:55 <funkyjunkyrobot> but i know this is wrong :(
12:50:18 <funkyjunkyrobot> just not sure how to reference a sub list correctly
12:50:19 <Eduard_Munteanu> LOL?
12:50:19 <monochrom> There is also the economical consideration of why you would improve it for little benefit. It's just toy homework.
12:50:43 <EvanR> > let count = length .: filter in count (>0) [3,4,0,0,2]
12:50:44 <lambdabot>   3
12:50:52 <Eduard_Munteanu> funkyjunkyrobot: did you mean that sx / xs distinction?
12:51:09 <funkyjunkyrobot> i don't understand what that means 
12:51:11 <syntaxglitch> anyway, personally I tend to jump straight to using Data.IntMap if I expect to be indexing into a collection
12:51:13 <EvanR> funkyjunkyrobot: in this case, just count the things in the flat version
12:51:30 <monochrom> Yeah, Data.IntMap is pretty easy to use too.
12:51:34 <EvanR> > let count = length .: filter in count (>0) (concat [[3,4,0],[0,2,7],[3,3,2]])
12:51:35 <lambdabot>   7
12:52:10 <syntaxglitch> It's also easy to switch back and forth between lists and IntMaps if necessary, and they're simpler to use than arrays for quick hacking
12:52:38 <funkyjunkyrobot> so what is that doing evan?
12:52:45 <funkyjunkyrobot> whats the .: operator doing?
12:52:54 <EvanR> its composing length and filter
12:53:05 <EvanR> to define a counting function
12:53:19 <Eduard_Munteanu> @src (.:)
12:53:19 <lambdabot> Source not found. I am sorry.
12:53:27 <EvanR> (.).(.)
12:53:45 <arcatan> ((.).(.)) :: (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:53:50 <Eduard_Munteanu> Is that some @let used on lambdabot?
12:54:07 <Eduard_Munteanu> :t (.:)
12:54:08 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:54:29 <Eduard_Munteanu> @hoogle (.:)
12:54:29 <lambdabot> No results found
12:54:42 <EvanR> sorry its proprietary math operation
12:54:53 <EvanR> requires a license and subscription
12:54:58 <Eduard_Munteanu> :)
12:55:18 <funkyjunkyrobot> where can i sign up!!!
12:55:23 <funkyjunkyrobot> :P
12:55:51 <EvanR> its open source though, see above
12:55:58 <EvanR> i wonder if its patented
12:56:13 <unkanon> problem is, .: is ungoogleable
12:56:18 <EvanR> see also .:: .:: and .::: ;)
12:56:25 <arcatan> @djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:56:25 <lambdabot> f a b c d = a (b c d)
12:56:27 <EvanR> er .::: and .::::
12:56:29 <funkyjunkyrobot> so all of that is kind of over my head
12:56:30 <Eduard_Munteanu> @let (.:) = undefined
12:56:31 <lambdabot>  <local>:23:0:
12:56:31 <lambdabot>      Multiple declarations of `L..:'
12:56:31 <lambdabot>      Declared at: <local>...
12:56:36 <unkanon> that's starting to look like tetris
12:56:43 <Eduard_Munteanu> They just dropped support for it :P
12:56:50 <Eduard_Munteanu> Grr...
12:56:53 <EvanR> > let count = length .: filter in count (>0) (concat [[3,4,0],[0,2,7],[3,3,2]])
12:56:54 <lambdabot>   7
12:56:59 <funkyjunkyrobot> i want to kick my teacher for giving us an assignment in a language that needs some time to understand and giving us only a week to do it in
12:57:19 <funkyjunkyrobot> *cry*
12:57:29 <arcatan> z-omg, lambdabot independently came up with .:
12:57:31 <Eduard_Munteanu> funkyjunkyrobot: yeah, that's stupid, and only averts people from Haskell
12:57:34 <EvanR> funkyjunkyrobot: refering to a 2d matrix made of lists is just a matter of two !!
12:58:08 <funkyjunkyrobot> i like haskell so far but doing some thing i think should be simple requires a whole new way of thinking and it doesn't come over night 
12:58:22 <EvanR> use matlab instead
12:58:43 <funkyjunkyrobot> will it compile using ghc......
12:58:47 <funkyjunkyrobot> fal
12:58:48 <funkyjunkyrobot> fail
12:59:00 <Eduard_Munteanu> :t fail
12:59:01 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
12:59:03 <Eduard_Munteanu> :P
12:59:17 <arcatan> will it blend?
12:59:18 <funkyjunkyrobot> lol it is defined :)
12:59:33 <arcatan> > fail "this is failure"
12:59:34 <lambdabot>   No instance for (GHC.Show.Show (m a))
12:59:34 <lambdabot>    arising from a use of `M5249243773...
12:59:38 <syntaxglitch> funkyjunkyrobot, sheesh, you were given an assignment to write in Haskell without any expectation of previous knowledge of the language?
12:59:43 <eb4890> :t win
12:59:44 <lambdabot> Not in scope: `win'
12:59:54 <medfly> sounds pretty bad :-/
12:59:58 <medfly> Haskell takes some getting used to
13:00:00 <Eduard_Munteanu> @let phail = fail . ("PHAILURE: " ++)
13:00:02 <lambdabot>  Defined.
13:00:05 <funkyjunkyrobot> it's a programming language concepts course. it's designed to make u good at picking up new languages quickly
13:00:08 <unkanon> really now, guys, where is the source of .:  ?
13:00:14 <EvanR> funkyjunkyrobot: lol
13:00:21 <Eduard_Munteanu> > phail "oh noes" :: IO ()
13:00:22 <lambdabot>   <IO ()>
13:00:26 <funkyjunkyrobot> yeah i know....
13:00:27 <EvanR> unkanon: (.).(.)
13:00:33 <funkyjunkyrobot> super rough
13:00:35 <medfly> funkyjunkyrobot, I would think that all that goal took is some programming 
13:00:35 <syntaxglitch> funkyjunkyrobot, at least makes some sense at least, even if it's pretty harsh to get tossed in the deep end like that
13:00:36 <Eduard_Munteanu> @undefine phail
13:01:00 <funkyjunkyrobot> we study the structure of languages mostly
13:01:11 <funkyjunkyrobot> we even wrote our own language for dealing with this stupid train track
13:01:13 <unkanon> EvanR: oh ok
13:01:28 <funkyjunkyrobot> a xml style language and a compiler for it
13:01:30 <unkanon> @unpl (.).(.)
13:01:30 <lambdabot> (\ i b c f -> i (b c f))
13:01:37 <EvanR> syntaxglitch: hopefully they covered python php perl js c# java d vb all in the first week
13:01:45 <funkyjunkyrobot> yep
13:01:47 <funkyjunkyrobot> of course
13:01:53 <unkanon> lol
13:02:04 <EvanR> since they arent really that different
13:02:15 <Eduard_Munteanu> It just sucks the first contact with a pure functional language like Haskell is an assignment you have to get done by the next week.
13:02:16 <syntaxglitch> EvanR, huh? what does PHP have to do with programming language concepts?
13:02:19 <funkyjunkyrobot> next we do logical languages all in one lump
13:02:41 <EvanR> syntaxglitch: the first week should be conventional imperative oop-attempt languages
13:02:55 <EvanR> and how we dont even need to spend time on 'picking them up'
13:03:13 <syntaxglitch> EvanR, I was trying to make a joke about how crappy PHP is :P
13:03:16 <EvanR> oh
13:03:21 <eb4890> funkyjunkyrobot: countCorners (x:sx) if x==0 then 1 + countCorners xs <--- (x: sx) should be (x:xs) 
13:04:11 <syntaxglitch> anyway yeah, seems like some simpler ML variant would have been a better choice for the assignment than Haskell? Ah well.
13:04:13 <funkyjunkyrobot> hmm
13:04:23 <funkyjunkyrobot> why sx?
13:04:31 <funkyjunkyrobot> thats referencing the tail right
13:04:39 <unkanon> funkyjunkyrobot: so that thing about counting the curves of a track, does that have anything to do with turning a sphere inside out?
13:04:42 <funkyjunkyrobot> ohh crap i typed that
13:04:52 <eb4890> Yup. 
13:04:55 <funkyjunkyrobot> lol
13:05:27 <funkyjunkyrobot> don't see a sphere being turned inside out tho.
13:05:44 <EvanR> a general count function... takes a predicate and a list, and gives a number
13:05:58 <EvanR> then just provide the predicate and the list
13:06:03 * syntaxglitch descides to teach a course on programming languages, first assignment is writing a ray-tracer in Coq, it's due in four days, have fun
13:06:07 <unkanon> funkyjunkyrobot: 'cause i remember watching a video about how to turn a sphere inside out and they taught how to count curves but it wasn't that straightforward
13:06:11 <funkyjunkyrobot> basicaly each track is a list of 3 ints, first describes shape, 2nd describes weight, 3rd describes material strength
13:06:21 <funkyjunkyrobot> i'm only interested in the first element, the shape at the moment
13:06:33 <unkanon> oh i see
13:06:35 <funkyjunkyrobot> so given that they are sub lists i don't know how to refrence an element of a sub list
13:06:45 <EvanR> > map head [[1,2,3],[9,9,9],[6,4,2]]
13:06:46 <lambdabot>   [1,9,6]
13:07:07 <aristid> syntaxglitch: but don't wonder when they call you a Cow
13:07:10 <aristid> *Coq
13:07:16 <eb4890> funky: To do it the way you are are doing. Look up guards and have a case for it when it isn't a curve and one for when it is. Rather than an if statement.
13:07:21 <funkyjunkyrobot> let me check that out :)
13:07:25 <eb4890> Have you covered map/folds ?
13:07:29 <EvanR> count (/=0) . map head
13:07:34 <funkyjunkyrobot> k
13:08:11 <funkyjunkyrobot> kool that helps me flatten it out
13:08:16 <funkyjunkyrobot> no
13:08:35 <funkyjunkyrobot> i do understand the guards tho
13:08:45 <funkyjunkyrobot> however checking weather it is or isn't is the problem for me
13:09:07 <Eduard_Munteanu> syntaxglitch: lol
13:09:12 <eb4890> Map does the function to each member of the list. So in this case head to each sublist.
13:09:14 <EvanR> what guards?
13:09:46 <Eduard_Munteanu> That's really really mean.
13:09:49 <funkyjunkyrobot> so looking at this function countCorners :: [[int]] -> int
13:09:51 <funkyjunkyrobot> ountCorners (x:sx) if x==0 then 1 + countCorners xs
13:09:52 <funkyjunkyrobot>  
13:09:57 <funkyjunkyrobot> the case that it is a list
13:10:07 <funkyjunkyrobot> i know using x to reference the head of a sub list is wrong
13:10:10 <EvanR> > map (!!1) [[1,2,3],[3,2,1],[0,0,0]]
13:10:11 <lambdabot>   [2,2,0]
13:10:14 <EvanR> > map (!!2) [[1,2,3],[3,2,1],[0,0,0]]
13:10:15 <lambdabot>   [3,1,0]
13:10:16 <unkanon> funkyjunkyrobot: EvanR solved your problem
13:10:24 <EvanR> > map (!!0) [[1,2,3],[3,2,1],[0,0,0]]
13:10:25 <lambdabot>   [1,3,0]
13:10:36 <syntaxglitch> funkyjunkyrobot: by the way, Stack Overflow is also a good place for getting help with Haskell if you have a more complicated question and/or noone's around on IRC
13:10:51 <funkyjunkyrobot> yeah i know he solved it
13:10:54 <eb4890> unkanon: He did, but I think it better if FJR solved it with things he understands.
13:11:01 <EvanR> yes
13:11:03 <funkyjunkyrobot> but i don't want a solution, i want to understand
13:11:08 <ddarius> It wouldn't be hard to write a simple ray-tracer in Coq.  Four days would certainly be adequate.
13:11:11 <funkyjunkyrobot> cuz there is much more to do :)
13:11:30 <funkyjunkyrobot> this map function will come in handy for sure
13:11:45 <EvanR> now you know map
13:11:53 <EvanR> you should have been shown that on day 0
13:12:01 <funkyjunkyrobot> he never mentioned it
13:12:04 <EvanR> lol
13:12:07 <syntaxglitch> ddarius, for you, sure
13:12:08 <Eduard_Munteanu> ddarius: at post-doc school? Sure :)
13:12:26 <ddarius> In fact, write a ray-tracer that provably approximates the model (for a relatively simple class of models) would be kind of interesting.
13:12:37 <ddarius> s/approximates/approximates within some given bound/
13:12:48 <syntaxglitch> that's kind of why I picked that for the joke, it's completely plausible for someone who knows Coq but hilariously absurd as an introduction to functional programming
13:13:20 * arcatan goes on to read about ray tracers and download Coq
13:13:41 <funkyjunkyrobot> but really my question still hasn't been answered as far as given the input of [[int]] so say [[1,2,3],[4,5,6],[7,8,9]] what does x:xs mean like is x = [1,2,3] and xs = [[4,5,6],[7,8,9]] ?
13:13:49 <syntaxglitch> ddarius, what about a coinductive stream of better approximations? that might be fun
13:14:11 <eb4890> FJR: Yup.
13:14:24 <Eduard_Munteanu> funkyjunkyrobot: yes
13:14:49 <Eduard_Munteanu> :t Cons
13:14:50 <lambdabot> Keyword
13:14:53 <unkanon> > let (x:xs) = [[1,2,3],[4,5,6],[7,8,9]] in x
13:14:54 <lambdabot>   [1,2,3]
13:14:54 <Eduard_Munteanu> :t List
13:14:55 <lambdabot> Not in scope: data constructor `List'
13:15:00 <Eduard_Munteanu> :t Nil
13:15:01 <lambdabot> Not in scope: data constructor `Nil'
13:15:06 <EvanR> the hell is Cons
13:15:19 <funkyjunkyrobot> so this in function was never explained either
13:15:25 <Eduard_Munteanu> I was going to try to explain him in terms of the List ADT.
13:15:46 <syntaxglitch> funkyjunkyrobot, what have you looked at as far as Haskell tutorials go? a quick skim through Learn You a Haskell might be helpful if you haven't done that already
13:15:47 <EvanR> funkyjunkyrobot: pattern matching involves giving variables and constructors
13:15:58 <unkanon> funkyjunkyrobot: let <.. this is a local scope ..> in
13:15:58 <EvanR> like x, :, and xs
13:16:10 <EvanR> :t (:)
13:16:11 <lambdabot> forall a. a -> [a] -> [a]
13:16:23 <funkyjunkyrobot> > let (x:xs) = [[1,2,3],[4,5,6],[7,8,9]] in xs
13:16:24 <lambdabot>   [[4,5,6],[7,8,9]]
13:16:27 <funkyjunkyrobot> hmm
13:16:51 <EvanR> so x is a and xs is [a]
13:16:51 <EvanR> > let Just x = x in Just 9
13:16:52 <lambdabot>   Occurs check: cannot construct the infinite type:
13:16:52 <lambdabot>    t = Data.Maybe.Maybe t
13:16:59 <EvanR> what
13:17:06 <Eduard_Munteanu> Anyways, lists look like data List a = Nil | Cons a (List a); except in standard notation Cons is (:) and Nil is [].
13:17:11 <EvanR> i just went insane
13:17:22 <syntaxglitch> confusingly, [] is both Nil and List
13:17:25 <Eduard_Munteanu> So [5,6,9] is Cons 5 (Cons 6 (Cons 9 []))
13:17:30 <funkyjunkyrobot> ok
13:17:37 <funkyjunkyrobot> right
13:17:45 <funkyjunkyrobot> can i use the keyword Nil
13:17:55 <Eduard_Munteanu> So it's easy to see (:) is just pattern matching something like Cons x xs.
13:18:08 <Eduard_Munteanu> funkyjunkyrobot: that's just []
13:18:16 <funkyjunkyrobot> well is it deconstructin instead of contructing
13:18:31 <unkanon> EvanR: how do you do that Just example right?
13:18:31 <Eduard_Munteanu> funkyjunkyrobot: exactly.
13:18:35 <syntaxglitch> funkyjunkyrobot, if you want to write a list as explicit constructors, [1,2,3] is (1:2:3:[])
13:18:54 <Nopik> hi.. i'm trying to use parsec, but when I added 'import Parsec', ghc cant find it (cabal claims that it is installed), i added -package parsec cmd arguments to parsec, it says that it tries to locate Parsec.hi, but cant find
13:18:55 <EvanR> > let f (Just x) = x in f (Just 9)
13:18:55 <arcatan> let (x:[]) = [1] = in x
13:18:56 <lambdabot>   9
13:19:03 <Nopik> any idea what i'm doing incorrectly?
13:19:05 <EvanR> > let f (Just x) = x in f Nothing
13:19:05 <lambdabot>   *Exception: <interactive>:1:137-150: Non-exhaustive patterns in function f
13:19:16 <funkyjunkyrobot> lambdabot hates u 
13:19:20 <syntaxglitch> Nopik, isn't it Text.Parsec?
13:19:34 <unkanon> EvanR: funny, that looks right
13:19:34 <Nopik> let me see
13:19:36 <Eduard_Munteanu> Some x:xs could be decomposed further into x:x':xs'
13:20:11 <funkyjunkyrobot> ok thats along the lines of what i want to understand
13:20:12 <Eduard_Munteanu> The rule is the last thing is a list, and all others are elements.
13:20:21 <unkanon> EvanR: oh it doesnt work because the value constructor doesnt match
13:20:21 <Nopik> syntaxglitch: yeah, it works, thanks!
13:20:29 <funkyjunkyrobot> so the prime is that a function
13:20:33 <funkyjunkyrobot> do i need to use it
13:20:34 <EvanR> unkanon: yes
13:20:40 <unkanon> EvanR: cool
13:20:41 <Eduard_Munteanu> funkyjunkyrobot: no, it's a notation.
13:20:44 <syntaxglitch> funkyjunkyrobot, no, it's just part of the identifier
13:20:53 <funkyjunkyrobot> ok
13:21:21 <Eduard_Munteanu> funkyjunkyrobot: the idea is x denotes an element, and xs denotes "some other x-es"
13:21:37 <EvanR> > let f (Just x) = x; f Nothing = 4 in f Nothing
13:21:38 <lambdabot>   4
13:21:39 <funkyjunkyrobot> so x:x:xs is the first 2 elements?
13:21:50 <funkyjunkyrobot> or is it the first element of x if x is also a list
13:22:08 <EvanR> > let f x:y:xs = (x,y) in f [9,4,2]
13:22:09 <lambdabot>   <no location info>: Parse error in pattern
13:22:11 <Eduard_Munteanu> funkyjunkyrobot: and iterating/recursing over a list is natural for such a decomposition. At each step you're removing its head, using it and recursing over the "rest"
13:22:11 <funkyjunkyrobot> i need to just play with some code to try and process all this gold u gurus have been feeding me
13:22:16 <EvanR> > let f (x:y:xs) = (x,y) in f [9,4,2]
13:22:16 <lambdabot>   (9,4)
13:22:22 <EvanR> funkyjunkyrobot: yeah, use ghci
13:22:27 <funkyjunkyrobot> i am currently
13:22:48 <EvanR> > let f (x:y:xs) = (x,y) in f [9]
13:22:49 <lambdabot>   *Exception: <interactive>:1:133-150: Non-exhaustive patterns in function f
13:23:16 <Eduard_Munteanu> > let sumList [] = 0; sumList (x:xs) = x + sumList xs; in sumList [1,2,3]
13:23:17 <lambdabot>   6
13:24:22 <funkyjunkyrobot> > let f (x:x:xs) = x in f [[1,2],[3,4]]
13:24:23 <lambdabot>   Conflicting definitions for `x'
13:24:23 <lambdabot>  In the definition of `f'
13:24:33 <identity_> Hmm. I've managed to confuse myself a bit. What would the type signature for a monad ReaderT String IO and WriterT [String] IO [String] look like? 
13:25:04 <EvanR> funkyjunkyrobot: cant define variable as two things
13:25:04 <Eduard_Munteanu> funkyjunkyrobot: use unique identifiers, or _
13:25:09 <funkyjunkyrobot> how would i get just the one out?
13:25:11 <identity_> Do I even need two transformers if I want to lift to IO?
13:25:23 <Eduard_Munteanu> > let f (_:x:_) = x in f [[1,2],[3,4]]
13:25:23 <lambdabot>   [3,4]
13:25:31 <EvanR> identity_: maybe you want RWST IO
13:25:39 <maurer_> ±/msg lambdabot @unmtl WriterT [String] IO [String]
13:25:41 <maurer_> err
13:25:44 <funkyjunkyrobot> hmm
13:25:51 <funkyjunkyrobot> i want to reference just 1
13:25:54 <identity_> EvanR: Hmm?
13:25:54 <EvanR> funkyjunkyrobot: ... which one
13:25:55 <Eduard_Munteanu> > let f (_:(_:x:_):_) = x in f [[1,2],[3,4]]
13:25:55 <lambdabot>   4
13:25:58 <funkyjunkyrobot> so the first element of the first sub-list
13:26:00 <maurer_> @unmtl WriterT [String] IO [String]
13:26:00 <lambdabot> IO ([String], [String])
13:26:08 <maurer_> So yeah, that's what the type signature would look like
13:26:15 <maurer_> The other one isn't a complete type, do you mean
13:26:23 <maurer_> @unmtl ReaderT String IO ()
13:26:23 <lambdabot> String -> IO ()
13:26:41 <EvanR> > let f [[_,_],[_,x]] = x in f [[1,2],[3,4]]
13:26:41 <Eduard_Munteanu> > let f ((x:_):_) = x in f [[1,2],[3,4]]
13:26:42 <lambdabot>   4
13:26:42 <lambdabot>   1
13:26:46 <identity_> maurer_: Hmm
13:26:59 <Eduard_Munteanu> '_' simply means "don't care".
13:27:30 <maurer_> identity_: What are you trying to do?
13:27:56 <identity_> maurer_: I want to run a computation that needs IO, from which I can read state and report errors
13:27:59 <funkyjunkyrobot> > let f [[x,_]:_] = x in f [[1,2],[3,4]]
13:28:00 <lambdabot>   No instance for (GHC.Num.Num [a])
13:28:00 <lambdabot>    arising from a use of `e_11234' at <in...
13:28:11 <identity_> I'm not sure how to stitch reader(T) with writer(T)
13:28:13 <identity_> and IO
13:28:37 <maurer_> identity: Technically you could do WriterT ReaderT, but you should probably just do StateT.
13:28:55 <identity_> maurer_: I thought about that as well
13:28:58 <identity_> Maybe I should
13:29:02 <identity_> but what is this RWS stuff?
13:29:06 <EvanR> well Writer acts a little different from State, you could put a writer api on top of state
13:29:06 <identity_> read/write/state?
13:29:09 <Funktorsalat> yes
13:29:10 <Eduard_Munteanu> identity_: yes
13:29:15 <aristid> identity_: it's just a combination of the three
13:29:15 <identity_> I see
13:29:20 <aristid> pretty pointless if you ask me
13:29:42 <maurer_> I can see the point--you get typed gaurantees that you aren't mutating some variables, and aren't reading others.
13:29:44 <Eduard_Munteanu> If it handles lifting internally it isn't really pointless. Does it?
13:30:02 <identity_> It does sound like I would be reimplementing it
13:30:04 <identity_> to an extent, anyway
13:30:08 <aristid> Eduard_Munteanu: only if you ever ever need reader+writer+state in that combination
13:30:10 <identity_> just the "rw" part
13:30:16 <EvanR> lifting is usually handled anyway
13:30:19 <aristid> Eduard_Munteanu: it's much more common to have just 2 of the three i think
13:30:23 <EvanR> by MonadClasses
13:30:25 <Eduard_Munteanu> Yeah.
13:30:35 <Funktorsalat> just use () :)
13:30:48 <Funktorsalat> (and yes, it saves lifts)
13:30:51 <identity_> aristid: Which is why rws sounds strange. I don't need state, and I don't want to use just StateT because i
13:30:58 <identity_> I'm not 'supposed to be able' to mutate state
13:31:02 <identity_> not all of it, anyway
13:31:03 <Funktorsalat> over a stack of individual trafos
13:31:15 <EvanR> you cant mutate the state if its type is ()
13:31:35 <aristid> of course you can
13:31:37 <funkyjunkyrobot> so when we say let f (patter) what is that meaning in terms of f is f arbitrary or is it a function or a name?
13:31:39 <EvanR> nah
13:31:40 <aristid> () has two values after all
13:31:43 <EvanR> bah
13:31:46 <Funktorsalat> @unmtl RWS r w () a
13:31:46 <lambdabot> r -> () -> (a, (), w)
13:31:47 <aristid> :D
13:31:52 <Funktorsalat> @unmtl RWS r w Void a
13:31:52 <lambdabot> r -> Void -> (a, Void, w)
13:31:56 <Funktorsalat> content now? :p
13:31:57 <Funktorsalat> ;)
13:32:02 <aristid> Funktorsalat: mucho better
13:32:04 <identity_> :info Void
13:32:09 <identity_> ah, doesn't do that
13:32:11 <identity_> Where is Void from?
13:32:17 <Funktorsalat> newtype Void = Void (forall a. a)
13:32:24 <identity_> Ah.
13:32:27 <EvanR> Funktorsalat: f is the name of the definition
13:32:35 <aristid> Funktorsalat: but i think if ReaderT + WriterT is too slow, i'd just roll my own ReaderWriter
13:32:37 <Funktorsalat> I don't think it's in one of the common libs
13:32:38 <Eduard_Munteanu> funkyjunkyrobot: in Haskell there isn't much difference between values and functions, really.
13:32:54 <EvanR> functions are values
13:33:06 <EvanR> some values arent functions
13:33:18 <geheimdienst> a value is a function with 0 args ...?
13:33:23 <EvanR> never!
13:33:38 <EvanR> functions all have 1 parameter
13:34:21 <Funktorsalat> haskell values are much like 0-ary functions in other langs, yes. with the twist that they overwrite themselves with something that just returns the computed value, after they're called
13:34:42 <aristid> Funktorsalat: haskell values are like memorised 0-ary functions :D
13:34:56 <geheimdienst> Funktorsalat: yeah, that's pretty much my understanding. thanks for confirming
13:34:56 <funkyjunkyrobot> i need to go out side and get some fresh air i feel like breaking stuff atm
13:35:03 <Eduard_Munteanu> I think he associates functions with things constructed with (->)
13:35:12 <funkyjunkyrobot> yes i do
13:35:15 <aristid> funkyjunkyrobot: fresh air is unhealthy
13:35:20 <Eduard_Munteanu> funkyjunkyrobot: not you
13:35:23 <funkyjunkyrobot> i get malformed function errors
13:35:25 <Eduard_Munteanu> EvanR.
13:35:33 * geheimdienst so far counts 1x "never!" and 1x "yes, much like 0-ary functions" :-) please keep discussing
13:36:19 <funkyjunkyrobot> i live in nebraska, our air is pretty decent here. we got trees and only large city has like 750,000 people in it
13:36:29 <EvanR> map is a function returning a function, map even is a function, map even xs is a list
13:37:07 <EvanR> possibly infinite
13:37:14 * Eduard_Munteanu remembers memes like... "I'm going to the mountain side... climb at 3000ft... breath in fresh ozone..." :))
13:37:18 <comak> @hoogle runError
13:37:18 <lambdabot> Control.Monad.Error runErrorT :: ErrorT e m a -> m (Either e a)
13:37:18 <geheimdienst> EvanR, yeah ... i'd say (map) has 2 args, (map even) has 1, (map even xs) has 0 args
13:37:28 <Eduard_Munteanu> Makes me go wtf.
13:37:58 <EvanR> geheimdienst: 0 args makes me think of lambda wrappers in javascript or something, which must be unwrapped by doing expr();
13:38:05 <geheimdienst> isn't ozone, like O3 ... so it clearly is 50% more healthy than oxygen (O2)
13:38:05 <EvanR> which is not how haskell works
13:38:29 <Eduard_Munteanu> geheimdienst: definitely! :)
13:38:45 <monochrom> hahaha
13:39:22 <monochrom> C2H5OH must be even more healthy then
13:40:05 <EvanR> expr; //js 0ary function
13:40:07 <EvanR> expr(); //js value
13:40:08 <geheimdienst> yeah but that has only one O. and the other gunk with C and H looks unhealthy to me :-)
13:40:23 <aristid> monochrom: very healthy
13:40:23 <EvanR> caf --haskell function / value ?
13:40:37 <EvanR> no point in calling it a function since you never use it as such
13:40:57 <sina> Guys, I want to have a function that takes a b c and add 1 to c. if c gets 26, it make it 0 and add one to b. if b gets 26 then it make it 0 and add 1 to a . like a calendar. what should I do ?
13:41:06 <monochrom> H2O is healthy. C2H5OH > H2O
13:41:09 <geheimdienst> EvanR, yes, i see your point now. but the expr / expr() distinction is only because javascript isn't lazy, is it?
13:41:14 <EvanR> right
13:41:18 <aristid> EvanR: well, values can be recursive
13:41:20 <Eduard_Munteanu> monochrom: you won't believe how many people buy air ionizers and things that make ozone... the trouble is it neither smells god nor is it healthy.
13:41:25 <Eduard_Munteanu> s/god/good/
13:41:30 <aristid> EvanR: that's something people normally associate with functions
13:41:31 <EvanR> js has to have a facility for explicitly 'running' functions
13:42:14 <EvanR> aristid: yeah, haskell data seems to have computational aspects to it
13:42:16 <geheimdienst> EvanR, exactly, and haskell does not 'run' functions
13:42:30 <monochrom> in soviet haskell, functions run you
13:42:37 <Eduard_Munteanu> I think it smells like chlorine mostly.
13:42:42 <EvanR> geheimdienst: also in haskell functions are totally different from js anyway
13:42:43 <Eduard_Munteanu> Or bleach.
13:42:47 <sina> Guys, I want to have a function that takes a b c and add 1 to c. if c gets 26, it make it 0 and add one to b. if b gets 26 then it make it 0 and add 1 to a . like a calendar. what should I do ?
13:42:52 <aristid> @remember monochrom in soviet haskell, functions run you
13:42:52 <lambdabot> Nice!
13:43:01 <aristid> monochrom: a bit lame but i laughed :P
13:43:02 <Eduard_Munteanu> Hehe.
13:43:39 <geheimdienst> in soviet russia, you confuse monads
13:43:53 <monochrom> I am not sure what is "make it 0 and do this other thing". seems redundant, just do the other thing.
13:44:16 <aristid> geheimdienst: no @remember for you!
13:44:29 <monochrom> yeah you have to say soviet haskell
13:44:43 <writer> lol
13:44:54 <geheimdienst> aristid: no worries, in soviet russia, i remember lambdabot's quotes
13:45:00 <monochrom> hahaha
13:45:00 <aristid> :D
13:45:13 <monochrom> @remember geheimdienst in soviet russia, i remember lambdabot's quotes
13:45:13 <lambdabot> It is forever etched in my memory.
13:45:16 <EvanR> geheimdienst: so you could also say 'data is functions'... but seriously... im not into 'everything is a function' cultism
13:45:41 <monochrom> I'm only into "everything is a value" for haskell.
13:45:45 <Eduard_Munteanu> That's too much along the burrito analogy to be useful.
13:46:03 <sina> monochrom: like when in time, seconds gets 60, I want it to return minute 1, second 0. so I get for example (hour,minute,second) and want to perform a function to return the time +1 second.
13:46:23 <EvanR> the burrito analogy? is there an actual link to it?
13:46:34 <geheimdienst> @google burrito monad
13:46:34 <lambdabot> No Result Found.
13:46:41 <syntaxglitch> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
13:46:44 <EvanR> class MonadBurrito
13:47:00 <aristid> where burrito :: m Burrito
13:47:03 <funkyjunkyrobot> i am still having trouble with my count corners
13:47:12 <funkyjunkyrobot> i want to cover the case of an empty list
13:47:14 <funkyjunkyrobot> countCorners:: [[int]] -> int
13:47:15 <funkyjunkyrobot> countCorners [[]] = 0
13:47:22 <ddarius> burrito :: m (m (m Burrito))
13:47:27 <EvanR> funkyjunkyrobot: you do?
13:47:36 <EvanR> i thought it was a fixed 3x3 
13:47:45 <funkyjunkyrobot> it is fixed i guess i can ignore it
13:47:54 <ddarius> EvanR: That's 3x3 for small values of 3.
13:48:14 <EvanR> we should have type safety to guard against those
13:48:15 <funkyjunkyrobot> well it's not so much fixed like that tho
13:48:17 <syntaxglitch> although I think the canonical explanation for monads these days comes from this article: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
13:48:33 <funkyjunkyrobot> there can be alot of sub lists of size 3
13:48:42 <funkyjunkyrobot> so the train track can have more then 3 peices
13:48:44 <EvanR> oh
13:49:02 <EvanR> > map (!!0) []
13:49:02 <lambdabot>   []
13:49:03 <funkyjunkyrobot> but each piece has 3 attribues
13:49:15 <funkyjunkyrobot> ahh
13:49:24 <funkyjunkyrobot> k, but i want it to give me a zero
13:49:28 <syntaxglitch> although I think the funniest part of that post is when Wadler linked to it on his blog and asked if anyone could point him to a good monad tutorial
13:49:31 <funkyjunkyrobot> it has to return an int
13:49:38 <EvanR> > (length .: filter) (undefined) []
13:49:38 <lambdabot>   Not in scope: `.:'
13:49:41 <aristid> EvanR: (!!0) is just head, no?
13:49:44 <EvanR> god dammit
13:49:46 <aristid> @let (.:) = fmap.fmap
13:49:47 <lambdabot>  Defined.
13:49:48 <aristid> FIXED
13:49:48 <EvanR> aristid: yes
13:49:48 <geheimdienst> syntaxglitch: lol
13:49:54 <EvanR> > (length .: filter) (undefined) []
13:49:55 <lambdabot>   0
13:50:05 <aristid> @let count = length .: filter
13:50:06 <lambdabot>  Defined.
13:50:12 <aristid> > count undefined []
13:50:13 <lambdabot>   0
13:50:21 <EvanR> no matter what the predicate is (even an error) the number of things in the empty list that satisfies it in zero
13:50:30 <funkyjunkyrobot> k
13:50:32 <EvanR> is
13:50:37 <monochrom> sina: http://hpaste.org/41217/carry
13:50:53 <aristid> @let count' p = p `seq` count p
13:50:54 <lambdabot>  Defined.
13:51:00 <aristid> > count' undefined []
13:51:01 <lambdabot>   *Exception: Prelude.undefined
13:51:04 <aristid> \o/
13:51:09 <Eduard_Munteanu> EvanR: I think byorgey referenced the burrito analogy as a bad example of "I GOT THE MONADS AFTER ALL" blog posts.
13:51:35 * Eduard_Munteanu concocted a pot of coffee
13:51:41 <funkyjunkyrobot> > (length .: filter) (undefined) []
13:51:42 <lambdabot>   0
13:51:43 <aristid> it's become a true meme in the haskell universe
13:51:47 <Eduard_Munteanu> Ha, so we've got MonadBurrito.
13:51:51 <sina> monochrom: thanks a lot. can we do it without @ (cause I am not allowed to use @) ?
13:52:02 <EvanR> Eduard_Munteanu: i am sort of interested now in monad tutorials and burritos and things. i cant seem to put myself in the context of understanding/misunderstanding monads in this way
13:52:11 <monochrom> write out the full "(x,y,z)" in place of t
13:52:14 <aristid> sina: you're not allowed to use @?!
13:52:23 <monochrom> and delete "t@" of course
13:52:39 <aristid> is it just me or do "you're not allowed to use the power of the language" assignments suck?
13:52:43 <monochrom> and re-align things nicely so the parser is unconfused
13:52:45 <Eduard_Munteanu> EvanR: I think everybody is imagining a fancy way of describing the monad as a wrapper.
13:53:03 <EvanR> ah
13:53:07 <EvanR> a container or something
13:53:12 <syntaxglitch> Eduard_Munteanu, he made up the burrito thing as a deliberately bad analogy, yes
13:53:15 <monochrom> most of the "____ not allowed" homeworks suck, yes. depending on ____
13:53:15 <aristid> Eduard_Munteanu: hmm i don't have any analogy for monads, is that unusual?
13:53:18 <sina> aristid: I have an assignment to make an Enigma machine!! and this is part of that rotor thing if you know about Enigma
13:53:21 <Funktorsalat> it's much like a term algebra actually!
13:53:26 <Eduard_Munteanu> syntaxglitch: ah lol, I thought somebody actually used that.
13:53:29 <sina> monochrom: thanks :)
13:53:39 <Eduard_Munteanu> aristid: not really.
13:53:44 <monochrom> "foldl not allowed, write your own recursion" is bearable for a while (but not too long)
13:54:02 * ddarius would simply outlaw foldl forevermore.
13:54:03 <Eduard_Munteanu> aristid: like byorgey says, understanding desugaring and how those monad laws play is more important than an analogy devoid of understanding
13:54:05 <unkanon> ?src foldl
13:54:05 <lambdabot> foldl f z []     = z
13:54:05 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
13:54:08 <aristid> monochrom: that makes at least some sense
13:54:10 <unkanon> done :)
13:54:23 <syntaxglitch> Eduard_Munteanu, it would have been kind of rude to pick someone's actual monad tutorial to show why monad tutorials suck
13:54:28 <monochrom> but really, "if-then-else not allowed", "pattern matching not allowed" etc are stupid.
13:54:35 <Funktorsalat> ddarius: in favour of foldl'...?
13:54:37 <Eduard_Munteanu> Ah, I kinda see.
13:54:44 <syntaxglitch> but the burrito thing isn't objectively more stupid than some that people have used seriously
13:55:04 <Eduard_Munteanu> Spacesuits? I think that was serious.
13:55:04 <unkanon> there's one about spacesuits!
13:55:08 <monochrom> "do-notation not allowed, write out the >>=" and ">>= not allowed, write out the do-notation" has some value for a while, too (but not too long)
13:55:11 <unkanon> Eduard_Munteanu: jinx!
13:55:19 <EvanR> spacesuits
13:55:19 <Eduard_Munteanu> :)
13:55:31 <aristid> monochrom: I think we have some pattern there
13:55:32 <EvanR> so that was the predecessor of burritos
13:55:38 <unkanon> yes
13:55:45 <geheimdienst> let's be constructive and instead of dissing monad tutorials, write a tutorial on how to write a good monad tutorial
13:55:45 <EvanR> class MonadSpacesuit
13:55:47 <unkanon> i believe that was the motivation for burritos
13:55:47 <Eduard_Munteanu> Well they're not really stupid, it's just that shortcuts usually don't work.
13:55:57 <aristid> monochrom: it makes sense where you need some exercise to understand two ways of expressing the same?
13:56:00 <monochrom> I sometimes give out some "___ not allowed" homework too. But I make sure they are easy. I know how annoying they can become.
13:56:03 <EvanR> f :: a -> SpaceSuit (Burrito a)
13:56:13 <unkanon> lol
13:56:15 <Eduard_Munteanu> EvanR: that should be a SpaceSuitT :P
13:56:24 <syntaxglitch> well, I suppose monads are just a way of overloading burrito operators in an endospacesuit category, and that's really all there is to say on the matter
13:56:27 <aristid> Eduard_Munteanu: then it would be SpaceSuitT Burrito a
13:56:27 <funkyjunkyrobot> so my main goal with part one of this assignment is  this
13:56:30 <ddarius> geheimdienst: That's easy.  Don't write a monad tutorial.
13:56:33 <funkyjunkyrobot> Part One: 
13:56:33 <funkyjunkyrobot> isOval :: [[Int]] -> Bool 
13:56:33 <funkyjunkyrobot> Your ﬁrst task is to develop the function isOval and use it to verify that the 
13:56:34 <funkyjunkyrobot> list of lists given representing a track is indeed an oval track. An oval has four 
13:56:34 <funkyjunkyrobot> curved pieces separated by four sides composed of 0 or more straight pieces 
13:56:34 <funkyjunkyrobot> with opposing sides of the same size. The function will return True or False, 
13:56:34 <EvanR> SpaceSuitT Burrito IO a
13:56:34 <funkyjunkyrobot> to partOneOutput.
13:56:41 <Eduard_Munteanu> Well, yeag.
13:56:53 <Eduard_Munteanu> s/g/h/
13:56:59 <funkyjunkyrobot> example oval track
13:57:01 <funkyjunkyrobot> % 3x2 oval track, listing begins at top-left curve: 
13:57:01 <funkyjunkyrobot> % /\ 
13:57:02 <funkyjunkyrobot> % || 
13:57:02 <funkyjunkyrobot> % \/ 
13:57:02 <funkyjunkyrobot> [ [0,4,4], [0,6,8], [1,10,20], [0,6,6], [0,12,10], [1,15,15] ] 
13:57:17 <monochrom> Generally I price homework quality over homework quantity. The students get the point, then I'm done. My purpose is not to ensure students have no time left for other courses!
13:57:18 <mauke> nice spam
13:57:22 <hpc> haha
13:57:22 <syntaxglitch> I think conventional wisdom is that the only good standalone monad tutorial is sigfpe's
13:57:31 <unkanon> funkyjunkyrobot: people would prefer if you used a pastie ;)
13:57:39 <funkyjunkyrobot> whats that?
13:57:45 <Eduard_Munteanu> monochrom: you're teaching?
13:57:55 <monochrom> I sometimes teach. Not currently.
13:58:00 <Eduard_Munteanu> I see, nice.
13:58:11 <ddarius> monochrom: Then how are they going to learn time management or sacrifice or prioritization?
13:58:13 <unkanon> funkyjunkyrobot: hpaste.org
13:58:15 <funkyjunkyrobot> i'm not looking for  answers i didn't mean to spam that i have just been asking alot and thought it might help if u knew what i was working with
13:58:25 <Eduard_Munteanu> ddarius: the army?
13:58:27 <unkanon> funkyjunkyrobot: paste your stuff there and paste the link there, so that it doesnt pollute the chat here
13:58:35 <funkyjunkyrobot> ok i can do that
13:58:37 <funkyjunkyrobot> thanks
13:58:47 <unkanon> :)
13:59:07 <Eduard_Munteanu> syntaxglitch: yeah, sigfpe has a nice style of explaining things, quite balanced.
13:59:14 <ddarius> Eduard_Munteanu: That would work and would teach other things as well.
13:59:20 <unkanon> link?
13:59:26 <monochrom> Actually my high-quality, low-quantity homework is already likely hard enough to take a lot of their time.
13:59:32 <Eduard_Munteanu> unkanon: /topic
13:59:33 <syntaxglitch> monochrom, isn't part of your duty as a teacher to prepare people for the real world? Loading them down with pointless, tedious bullshit is an integral part of that
13:59:41 <unkanon> oh
13:59:57 <Eduard_Munteanu> @where hpaste
13:59:57 <lambdabot> http://hpaste.org/
14:00:09 <monochrom> Moreover, my questions are mostly proof questions. They can certainly sacrifice and gamble on how detailed they want their proofs to be.
14:00:16 <aristid> lambdabot: why did i click on that?!
14:00:56 * Eduard_Munteanu looks if wgetpaste groks hpaste
14:01:07 <monochrom> So! In fact in addition to sacrifice and priority, they also learn risk management! "if I omit this step, how many marks do I risk losing, vs how much time do I win back"
14:02:01 <monochrom> my duty as a teacher is to lure students into grad school!
14:02:06 <unkanon> BTW, referencing a previous subject, here's how to google for ".:"  : haskell "f g x y = f (g x y)"
14:02:19 <ddarius> monochrom: That seems undesirable for all.
14:03:10 <EvanR> unkanon: theres not much to google given the definition 
14:03:24 <EvanR> @unpl (.) . (.)
14:03:25 <lambdabot> (\ i b c f -> i (b c f))
14:03:26 <unkanon> EvanR: i can find some people talking about it
14:03:29 <EvanR> @unpl (.) (.)
14:03:29 <lambdabot> (\ b c e f -> b c (e f))
14:03:33 <monochrom> ok, my duty as a teacher is to inspire students to say this real world is wrong and they want to right it
14:03:40 <unkanon> EvanR: i mean, they talk about giving .: a name and so on
14:03:48 <EvanR> a name?
14:03:53 <unkanon> and they say (.) . (.) is the boob operator
14:04:00 <unkanon> yeah, that .: should have a name
14:04:03 <EvanR> isnt (.) (.) the book operator
14:04:03 <unkanon> or something like that
14:04:07 <EvanR> boob
14:04:12 <unkanon> i thought so too
14:04:15 <EvanR> @unpl (.) . (.) . (.)
14:04:15 <lambdabot> (\ l b c f i -> l (b c f i))
14:04:18 <aristid> EvanR: (.)(.) is not as useful as (.).(.)
14:04:20 <funkyjunkyrobot> ok more apropriatly here is my homework i am working on http://hpaste.org/41218/train_track_problem_1 can anyone tell me where a good starting point is or things i should consider
14:04:32 <Taejo> :t (.)(.)
14:04:32 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
14:04:33 <aristid> :t (.)(.)(.)
14:04:34 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
14:04:45 <EvanR> @unpl (.) (.) (.)
14:04:45 <lambdabot> (\ c e f i -> c (e f i))
14:04:50 <EvanR> the total recall operator
14:04:52 <ddarius> monochrom: Ah, so you're a mathematical physicist.
14:04:53 <unkanon> EvanR: yeah if you google you will find that people think (.) . (.) is very useful
14:04:58 <Funktorsalat> EvanR: I was waiting for that.
14:04:59 * Eduard_Munteanu goes watch a movie...
14:05:01 <funkyjunkyrobot> so far all i have thought of is that i want to make sure there are 4 curved peices, and if it starts on a straight track i want to move them to the end so i can start on a curved path
14:05:03 <aristid> (.)(.)(.) is the triple boobie operator
14:05:17 <Eduard_Munteanu> Total Recall style? :)
14:05:18 <EvanR> unkanon: we already told you that
14:05:26 <EvanR> Eduard_Munteanu: old
14:05:36 <Eduard_Munteanu> Indeed.
14:05:43 <unkanon> EvanR: and google confirms it
14:05:48 <monochrom> hahaha Total Recall style
14:06:06 <syntaxglitch> enough about that, let's make juvenile jokes about Coq instead
14:06:12 <syntaxglitch> that's always fresh and interesting
14:06:22 <monochrom> @quote monochrom coq
14:06:22 <lambdabot> monochrom says: Ask Coq. Don't rely on head.
14:06:28 <monochrom> like that? :)
14:06:29 <aristid> syntaxglitch: indeed
14:06:39 <mauke> preflex: quote . coq
14:06:51 <preflex>  no quotes found
14:06:54 <aristid> @quote coq
14:06:54 <lambdabot> br1 says: me tiene emputecido el coq del orto
14:06:59 <mauke> preflex: quote . Coq
14:07:00 <EvanR> > (.)(.)(.) length map even [1,2,3,4,5,6]
14:07:01 <lambdabot>   6
14:07:04 <preflex>  <kmc> Coq is a useful tool but sometimes it gets pretty hard
14:07:10 <monochrom> hehehehe
14:07:17 <Eduard_Munteanu> :))
14:07:19 <unkanon> hahahaha
14:07:21 <aristid> that one really is good
14:07:33 <mauke> preflex: quote . Coq
14:07:37 <geheimdienst> what use would this tool be, exactly, if it didn't sometimes get hard?
14:07:38 <preflex>  <kmc> i'll show you my Coq if you show me yours
14:07:58 <aristid> geheimdienst: it could always be easy to use. like the iPad.
14:07:59 <ddarius> geheimdienst: Um, how 'bout making things easy?
14:08:14 <endojelly> I don't know, I only get Coq out if I want to do something really thoroughly.
14:08:23 <arcatan> what's up with #haskell today, so many juvenile jokes...
14:08:26 * syntaxglitch sighs
14:08:33 <Funktorsalat> @quote fmap
14:08:33 <lambdabot> ddarius says: fmap: Because getting functions to the values is half the battle.
14:08:37 <aristid> arcatan: syntaxglitch started by mentioning coq
14:08:52 <arcatan> before that already
14:09:02 <Funktorsalat> actually it started earlier with odd compositions of the composition operator.
14:09:02 <mauke> @quote fmap.fmap
14:09:02 <lambdabot> No quotes match. That's something I cannot allow to happen.
14:09:09 <aristid> (.:) is getting ever more popular
14:09:15 <aristid> @quote fmap . fmap
14:09:15 <lambdabot> No quotes for this person.
14:09:25 <aristid> @quote fmap.*fmap
14:09:25 <lambdabot> No quotes match. You speak an infinite deal of nothing
14:09:29 <arcatan> i shall name composition composition operator
14:09:30 <syntaxglitch> you mean by making a snide remark about Coq in reference to other juvenile jokes already being made
14:09:50 <aristid> arcatan: in honesty, i'd call it "binary composition"
14:10:17 <arcatan> ie. linker
14:10:18 * geheimdienst points out that he finds it juvenile to look down on juvenile jokes
14:10:21 <aristid> syntaxglitch: well, you could phrase it that way
14:10:31 <ddarius> > let (∴) = (.) . (.) in (negate ∴ (+)) 3 5
14:10:32 <lambdabot>   -8
14:10:39 <endojelly> to be fair, if you name your language Coq you're asking for a juvenile joke every now and then.
14:10:45 <syntaxglitch> geheimdienst, it's more that they're juvenile, obvious, and stale
14:11:02 <endojelly> you don't call your language boobee, do you?
14:11:13 <Funktorsalat> endojelly: but they have a good explanation! they were practically forced to call it like that because there's a tradition of naming theorem provers after animals
14:11:19 <aristid> > let (€) = fmap; (€€) = fmap.fmap in (negate €€ (+)) 3 5
14:11:19 <lambdabot>   -8
14:11:31 <Funktorsalat> (that's actually the faq entry :))
14:11:32 <geheimdienst> syntaxglitch: you've got a point. however different things are obvious to different people ...
14:11:39 <ddarius> Like the nimble automath.
14:11:44 <syntaxglitch> I mean, seriously, I'll totally be okay with it if someone actually thinks up a NEW joke about Coq
14:11:49 <sina> How can I convert a list of three to a triple?
14:11:54 <endojelly> Funktorsalat, and there wasn't an animal which didn't sound like a genital? not coq or boobie (you know, the bird)
14:11:57 <unkanon> > (negate . (+)) 3 5
14:11:58 <lambdabot>   -8
14:11:59 <aristid> Funktorsalat: they basically had no choice!
14:12:00 <unkanon> aristid: ^
14:12:11 <hpc> syntaxglitch: Coq snowflake?
14:12:34 <mauke> > (negate . (+)) x y
14:12:34 <lambdabot>   negate (x + y)
14:12:39 <aristid> unkanon: that uses the evil Num instance
14:12:43 <unkanon> aristid: oh nevermind i get it now
14:12:50 <hpc> did i just make a pun so nerdy it went over #haskell's head?
14:12:51 <funkyjunkyrobot> can anyone tell me why this is a malformed class assertion? countCorners:: (int a) => [[a]] -> a
14:12:54 <mauke> > (negate (+)) x y
14:12:55 <lambdabot>   negate (x + y)
14:13:06 <ddarius> hpc: No, it just wasn't funny.
14:13:10 <unkanon> aristid: is the Num instance also evil because it doesn't allow me to overload + to work on strings?
14:13:12 <hpc> ddarius: ah, much better then
14:13:12 <mauke> funkyjunkyrobot: 'int' is not a valid class name
14:13:15 <sina> How can I convert a list of three to a triple? like [a,b,c] to (a,b,c)
14:13:17 <aristid> unkanon: wtf
14:13:23 <EvanR> funkyjunkyrobot: also Int isnt a class
14:13:23 <azaq23> funkyjunkyrobot: Int is a type, not a typeclass.
14:13:32 <Eduard_Munteanu> > \a:b:c:xs -> (a, b, c)    [1,3,5]
14:13:33 <lambdabot>   <no location info>: parse error on input `:'
14:13:36 <aristid> Integral is a class
14:13:39 <Eduard_Munteanu> > \(a:b:c:xs) -> (a, b, c)    [1,3,5]
14:13:40 <lambdabot>   Couldn't match expected type `t1 -> t'
14:13:40 <lambdabot>         against inferred type `(t2, ...
14:13:49 <Eduard_Munteanu> > (\(a:b:c:xs) -> (a, b, c)) [1,3,5]
14:13:50 <aristid> Eduard_Munteanu: paren it
14:13:50 <lambdabot>   (1,3,5)
14:13:57 <Eduard_Munteanu> sina: ^
14:14:05 <sina> what is xs?
14:14:07 <EvanR> funkyjunkyrobot: really the data for your train tracks is not Num nor Integral, its more like TrainTrackParts (type, not a class)
14:14:11 <Eduard_Munteanu> aristid: yeah, I thought I could cut corners
14:14:11 <aristid> sina: xs is ignored
14:14:21 <EvanR> you would not add track track parts, nor would you divMod them
14:14:45 <EvanR> you could use numbers for that in C but haskell has more expressive power
14:14:47 <Eduard_Munteanu> sina: of course you should rather make a function
14:14:48 <unkanon> aristid: someone here explained one day that Num is not well written and one of the reasons was it took (+) for itself
14:15:09 <syntaxglitch> there are many, many reasons why Num is ill-considered
14:15:17 <geheimdienst> sina: in haskell, we often use "x" for the first value in a list and "xs" for the rest of the list
14:15:21 <Eduard_Munteanu> Mostly math-theoretical I guess.
14:15:23 <EvanR> wanting to use + for anything else is absuive
14:15:31 <endojelly> what would be a better place for +? monoid?
14:15:39 <EvanR> ++ for monoid
14:15:54 <syntaxglitch> Using + for anything that behaves like addition would be fine
14:15:58 <hpc> there's two monoids for Num
14:16:01 <sina> geheimienst: thanks for the explanation.
14:16:03 <syntaxglitch> Not eveything you can sensibly add is sensibly an instance of Num
14:16:05 <unkanon> concat is like addition
14:16:08 <aristid> > (negate (const (+))) 1 2 3
14:16:09 <lambdabot>   -5
14:16:12 <aristid> \o/
14:16:13 <Eduard_Munteanu> Obviously not for multiplication.
14:16:17 <geheimdienst> sina, you're welcome
14:16:19 <EvanR> @src Num
14:16:19 <lambdabot> class  (Eq a, Show a) => Num a  where
14:16:20 <lambdabot>     (+), (-), (*)           :: a -> a -> a
14:16:20 <lambdabot>     negate, abs, signum     :: a -> a
14:16:20 <lambdabot>     fromInteger             :: Integer -> a
14:16:26 <endojelly> why not + instead of ++?
14:16:29 <EvanR> vector *
14:16:35 <tibbe> dons: quick check: the new version of network will just be included in the HP right?
14:16:49 <sina> Eduard_Munteanu: is there any way simpler to do this? I mean I don't know if I can cons multiple time (not supposed to know at least)
14:16:52 <Eduard_Munteanu> endojelly: perhaps so that lists could have Num instances?
14:16:56 <aristid> > (negate (\a b c d e f g -> a + b + c + d + e + f + g))) a b c d e f g :: Expr
14:16:57 <lambdabot>   <no location info>: parse error on input `)'
14:17:04 <aristid> > (negate (\a b c d e f g -> a + b + c + d + e + f + g)) a b c d e f g :: Expr
14:17:05 <lambdabot>   negate (a + b + c + d + e + f + g)
14:17:08 <hpc> :t negate
14:17:09 <lambdabot> forall a. (Num a) => a -> a
14:17:13 <ddarius> concat maps to sum via the unique mediating monoid homomorphism from the free monoid to the monoid of natural numbers (or integers or rationals or reals) under addition.
14:17:23 <hpc> lol, forgot the function num instance
14:17:37 <endojelly> Eduard_Munteanu, ist that really so useful that it warrants that?
14:17:37 <Eduard_Munteanu> sina: not really, you have to deconstruct the list somehow.
14:17:57 <Eduard_Munteanu> endojelly: well, not really, I was guessing. Perhaps zipWith is better for that.
14:18:01 <endojelly> Eduard_Munteanu, I think in most situations I'm fine in doing zipWith
14:18:05 <geheimdienst> sometimes it's difficult to tell if people are being serious or jocular ("just a monoid in the category of ...")
14:18:06 <Eduard_Munteanu> Yeah.
14:18:07 <sina> Eduard_Munteanu: ok I see. thanks. I have to figure another way.
14:18:09 <ddarius> Furthermore, the naturals under addition can be viewed as the free monoid over one generator and in that representation, concat is sum.
14:18:27 <unkanon> geheimdienst: ...endofunctors!
14:18:38 <Eduard_Munteanu> sina: you could decompose it into three functions that each fill a part of the triple, but it's silly.
14:19:04 <arcatan> is free monoid like a free group in its freeness?
14:19:29 <ddarius> arcatan: Yes.
14:19:37 <Eduard_Munteanu> sina: like the first takes x:xs into (x, 0, 0), then the second xs -> y:ys -> (x, y, 0) etc. using an accumulator.
14:19:40 <Funktorsalat> thus sum is just the free monoid functor applied to the mediating arrow of the terminality of ()
14:19:41 <Eduard_Munteanu> But it sucks.
14:19:59 <Funktorsalat> which isn't actually terminal due to _|_ crap
14:20:12 <endojelly> ddarius, so, with addition, natural numbers behave like a monoid?
14:20:24 <geheimdienst> @quote Funktorsalat sum is just the free monoid functor applied to the mediating arrow of the terminality of ()
14:20:24 <lambdabot> No quotes for this person. My mind is going. I can feel it.
14:20:31 <ddarius> endojelly: They are a monoid under addition, yes.
14:20:37 <geheimdienst> @remember Funktorsalat sum is just the free monoid functor applied to the mediating arrow of the terminality of ()
14:20:38 <lambdabot> Okay.
14:20:46 <Eduard_Munteanu> sina: it would be nice to check if the length of the list corresponds.
14:20:49 <endojelly> :info Monoid
14:20:49 <sina> Eduard_Munteanu: I will find a way I guess. thanks. let me see what I can do myself
14:20:58 <sina> Eduard_Munteanu: good idea
14:21:02 <endojelly> :i Monoid
14:21:06 <Eduard_Munteanu> sina: or just say you looked up the syntax.
14:21:31 <aristid> Funktorsalat: are you making this stuff up? or is that actually more than gibberish?
14:21:46 <Funktorsalat> aristid: I think it's kinda correct
14:22:07 <funkyjunkyrobot> I finaly got my count corners to work :)
14:22:09 <aristid> Funktorsalat: wtf :)
14:22:10 <geheimdienst> "i looked up the syntax ... in a language reference called '#haskell'. it's pretty cool, it even supports natural-language queries"
14:22:30 <aristid> geheimdienst: it's the future
14:22:42 <Funktorsalat> aristid: actually that 'free monoid functor' is imply the list functor in haskell
14:22:56 <funkyjunkyrobot> can i poste my function on here or so i need to pasty it?
14:22:56 <ddarius> For what Funktorsalat said, it would actually be length when we view [()] as a natural number.
14:22:57 <fengshaun> has any haskell representative claimed the Haskell page on facebook yet?
14:23:04 <endojelly> geheimdienst, it's implementation is also called interesting. it uses a varying cluster of highly parallelized organic computers
14:23:08 <funkyjunkyrobot> i want some feed back
14:23:17 <hpc> @where pastebin
14:23:18 <lambdabot> http://hpaste.org
14:23:21 <Funktorsalat> ddarius: hmm you're right
14:23:22 <ddarius> :t map (const ())
14:23:23 <endojelly> geheimdienst, sorry, quite interesting, not called
14:23:23 <Eduard_Munteanu> Representative? :)
14:23:23 <lambdabot> forall a. [a] -> [()]
14:23:27 <Nibble> guys
14:23:39 <endojelly> geheimdienst, and its instead of it's. shouldn't chat while reading.
14:23:44 <Nibble> This channel has to be the most awesome ever
14:23:54 <Nibble> about a computer language
14:24:00 <unkanon> why?
14:24:08 <Nibble> unkanon: first of all
14:24:12 <Nibble> check in #php or something like that
14:24:14 <Nibble> user number
14:24:17 <funkyjunkyrobot> http://hpaste.org/41219/funkyjunkyrobot
14:24:17 <unkanon> 'cause it scrolls so fast I can barely absorb what i'm learning?
14:24:24 <Eduard_Munteanu> Nibble: considering it's not your average language, I have to admit it's way too popular.
14:24:26 <Nibble> I bet #haskell have a lot more users
14:24:29 <aristid> :t (() <$)
14:24:30 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
14:24:31 <geheimdienst> those highly parallelized organic computers, however, sound more impressive than they are. they are really just mass produced by unskilled labor
14:24:40 <aristid> Funktorsalat: that is my length :)
14:24:46 <Nibble> also, this is the only channel you see stuff like that in.
14:24:53 <Nibble> like that above ^
14:24:57 <Nibble> oh
14:24:59 <Nibble> last reason
14:25:05 <Nibble> I hang here.
14:25:06 <unkanon> Nibble: what exactly?
14:25:15 <Funktorsalat> aristid: yes. I'm not fully lucid
14:25:27 <syntaxglitch> :t fmap fix return
14:25:28 <ddarius> geheimdienst: Most people practice the only manual part of that process quite a bit.
14:25:28 <lambdabot> forall a. a -> a
14:25:38 <Nibble> unkanon: stuff I write
14:25:39 <Funktorsalat> @forget
14:25:39 <lambdabot> Incorrect arguments to quote
14:25:41 <Nibble> and that I hang here
14:25:42 <ddarius> geheimdienst: They are certainly amateur's at least.
14:25:47 <unkanon> Nibble: oh of course, lol
14:25:48 <Nibble> makes this channel great.
14:25:53 <Funktorsalat> @forget FunctorSalad.free.monoid
14:25:54 <lambdabot> Incorrect arguments to quote
14:26:00 <Funktorsalat> @FU
14:26:00 <lambdabot> Maybe you meant: . ? @ bf do ft id pl rc v wn
14:26:12 <Funktorsalat> ahem
14:26:18 * Eduard_Munteanu really goes watch that movie now...
14:26:27 <unkanon> what? there shouldn't be a forget command...
14:26:30 <mietek> Module `Control.Exception' does not export `onException'
14:26:41 <mietek> Why would this happen?
14:26:48 <ddarius> @help rc
14:26:48 <lambdabot> rc name. Read a file of commands (asynchonously). FIXME: better name.
14:27:01 <monochrom> there was an onException at all?
14:27:07 <mauke> @rc lambdabot
14:27:07 <lambdabot> Not enough privileges
14:27:07 <geheimdienst> ddarius: yes, but i am distinctly uncomfortable with expressing that using the word "manual" ... literally "by hand" ...
14:27:17 <mietek> monochrom: when I :browse Control.Exception, it's still there
14:27:19 <syntaxglitch> okay, enough of this nonsense, back to learning agda
14:27:59 <Funktorsalat> phew managed to delete it
14:28:16 <mietek> Ah, my bad.
14:28:19 <mietek> base >= 3
14:28:36 <geheimdienst> Funktorsalat: why do you insist on deleting it ...? i thought it was quite funny
14:28:37 <monochrom> I see, yeah.
14:28:49 <Funktorsalat> geheimdienst: it was wrong :(
14:29:03 <Funktorsalat> I'm very embarassed
14:29:05 <unkanon> @quote monochrom einstein
14:29:05 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
14:29:16 <hpc> hahaha
14:29:24 <unkanon> haha, just reading some old logs here
14:30:10 <syntaxglitch> @quote syntaxglitch fix not
14:30:10 <lambdabot> syntaxglitch says: <Kleene> hey al check this out <Kleene> > fix not <lambdabot> mueval-core: Time limit exceeded <Church> well crap
14:30:35 <unkanon> Funktorsalat: how did you manage it?
14:30:37 * geheimdienst informs funktorsalat that the lambdabot quote list is not and is not meant to be a glossary of absolute, unassailable facts
14:30:49 <unkanon> Funktorsalat: just @forget Funktorsalat monoid ?
14:30:53 <Funktorsalat> unkanon: uh you have to enter the whole quote
14:31:04 <unkanon> Funktorsalat: oh ok, good to know
14:32:19 * ddarius needs to bleach his sheets, or simply buy new sheets.
14:32:38 <unkanon> @quote geheimdienst leksah
14:32:38 <lambdabot> geheimdienst says:  i totally didn't realize that leksah = reverse haskel. i thought leksah was what the lolcats said for lexer
14:36:08 <endojelly> ddarius, why?
14:36:20 <geheimdienst> ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
14:36:45 <monochrom> heh
14:37:01 <endojelly> geheimdienst, where in germany are you, btw?
14:37:29 <geheimdienst> northern part, hannover
14:37:42 <endojelly> ah
14:37:48 <geheimdienst> why?
14:37:49 <aristid> geheimdienst: so why were you not at belhac?
14:37:55 <unkanon> geheimdienst: ennobunktors lol that's really cute
14:38:04 <endojelly> i'm from munich, was just wondering if i might know you.
14:38:22 <monochrom> @remember geheimdienst ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
14:38:22 <lambdabot> It is stored.
14:38:34 <aristid> @quote ennobunktor
14:38:34 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
14:38:38 <aristid> \o/
14:39:53 <unkanon> if haskell's category theory background was explained in lolcat i think it would go down a lot smoother
14:39:56 <geheimdienst> aristid: good question, i seriously considered going, but then my laptop broke shortly before it, and they botched the repair, and i decided that it was too much stress all in all
14:40:44 <geheimdienst> endojelly: hm ... you're not by chance the man from the gulaschnacht who gave the hardcore talk on applicative and so forth ...? i think he was from munich, too
14:42:57 <endojelly> geheimdienst, no, I'm not that knowledgeable. I somehow know what Applicative is but giving a talk about it would be dangerous 8) would be interested in knowing who that was, though
14:44:33 <aristid> geheimdienst: if i had been aware of it earlier, i might have gone :D
14:45:00 <funkyjunkyrobot> i am getting a parse error on line 7 of this code and don't know why http://hpaste.org/41220/parse_error
14:45:18 <stepcut> otherwise = ...
14:45:51 <funkyjunkyrobot> awesome, thx
14:45:54 <endojelly> geheimdienst, was it that talk? http://entropia.de/wiki/GPN10:Monaden
14:46:06 <geheimdienst> endojelly: http://entropia.de/wiki/GPN10:Monaden lists him as Franz Pletz
14:46:10 <geheimdienst> er, yeah :)
14:46:15 <endojelly> geheimdienst, yeah I know that guy
14:46:23 <stepcut> funkyjunkyrobot: no problem
14:46:24 <geheimdienst> he was from TUM or LMU or something
14:46:32 <endojelly> geheimdienst, we're at the same uni, sometimes see him at parties and such
14:46:39 <endojelly> geheimdienst, LMU actually
14:49:35 <endojelly> geheimdienst, oh, he's actually here, he's fpletz
14:49:55 <geheimdienst> preflex: seen fpletz
14:50:11 <preflex>  fpletz was last seen on #haskell 6 days, 23 hours, 22 minutes and 43 seconds ago, saying: Twey: yup, was just made in our laboratory at our local hackerspace :)
14:50:34 <funkyjunkyrobot> having trouble with types. anyone know what i am not understanding about types with and error like this? http://hpaste.org/41221/couldnt_match_expected_type
14:51:13 <hpc> funkyjunkyrobot: look at line 7; what's the order of operations?
14:52:04 <blubbi_> hi
14:52:06 <funkyjunkyrobot> i expect it to call itself again with the list generated from switch when switch takes the current list in as an argument
14:52:24 <monochrom> did you know that "x y z" means "(x y) z"
14:52:39 <blubbi_> is projects.haskell.org down? or is it just for me?
14:52:44 <funkyjunkyrobot> so i need parentesis around the 2nd half
14:52:46 <funkyjunkyrobot> let me try that
14:53:28 <hpc> funkyjunkyrobot: another trick is to exploit "f $ x = f x", which associates the right way
14:53:35 <geheimdienst> funkyjunkyrobot: start reading the error message in line 11. so the place to look at is "switch" in line 7. then "inferred type" means "ghc found out by looking at the source that 'switch' has the type [a1] -> [a1]"
14:53:37 <hpc> funkyjunkyrobot: x $ y z = x (y z)
14:53:54 <endojelly> funkyjunkyrobot, there's another problem in your code, unrelated to that one, but you'll see by yourself
14:54:08 <blubbi_> or is there another place where one can get haskell-vim?
14:54:52 <funkyjunkyrobot> so i can use that dollarsign between the call to switch
14:55:27 <endojelly> funkyjunkyrobot, that or paqrantheses are the common ways to do it, yeah
14:55:38 <endojelly> funkyjunkyrobot, let if you wanna be superexpressive.
14:55:49 <geheimdienst> funkyjunkyrobot: yes. i think of the dollar as "put $ where the '(' would be, then you can leave out the ')'"
14:56:01 <funkyjunkyrobot> nice
14:56:07 <funkyjunkyrobot> still doesn't solve my problem
14:56:15 <funkyjunkyrobot> i think it has something to do with the switch itself
14:56:21 <endojelly> funkyjunkyrobot, do you get the same error or another?
14:56:24 <funkyjunkyrobot> but it gets past that error
14:56:26 <funkyjunkyrobot> another
14:56:35 <endojelly> funkyjunkyrobot, yeah. as I said, I spotted another error in your code
14:56:44 <endojelly> funkyjunkyrobot, which has much more directly to do with types
14:56:55 <endojelly> funkyjunkyrobot, see if you can figure it out, otherwise we're glad to help.
14:57:05 <funkyjunkyrobot> yeah, so switch takes in a list of "some type" a
14:57:16 <funkyjunkyrobot> that type a is suposed to be another list made of ints
14:57:27 <endojelly> funkyjunkyrobot, well, the problem is not in switch
14:57:28 <funkyjunkyrobot> so i want the a to represent a list
14:57:36 <funkyjunkyrobot> ok
14:57:49 <endojelly> funkyjunkyrobot, and your switch looks fine, I think. it works for all lists. yes.
14:58:07 <funkyjunkyrobot> ok
14:58:20 <funkyjunkyrobot> so the type of my startWithcurve is off
14:58:27 <funkyjunkyrobot> shold it be of type [[a]]
14:58:36 <endojelly> funkyjunkyrobot, you are aware that type variables exist only in the context of one function? (actually it's more complicated but for ease of explanation...)
14:59:09 <funkyjunkyrobot> so this "a" doesn't carry over from one function to the next, even if i nest them in each other
14:59:42 <endojelly> funkyjunkyrobot, what do you mean by nesting?
14:59:59 <funkyjunkyrobot> calling switch from startWithcurve
15:00:08 <endojelly> funkyjunkyrobot, the thing is... look at your startWithCurve function. what is its type, according to your code?
15:00:12 <funkyjunkyrobot> probly not nesting at all enh
15:00:33 <funkyjunkyrobot> takes a list and returns a list
15:00:39 <endojelly> funkyjunkyrobot, a list of what
15:00:48 <funkyjunkyrobot> some type "a"
15:01:02 <endojelly> funkyjunkyrobot, so it should work with *every* type, right?
15:01:06 <funkyjunkyrobot> yeah
15:01:18 <endojelly> funkyjunkyrobot, now look at what your function does. is that true?
15:01:26 <endojelly> funkyjunkyrobot, what are you doing with values of that type?
15:01:29 <funkyjunkyrobot> well i have a zero in there..
15:01:38 <endojelly> funkyjunkyrobot, you have a zero in there!
15:01:39 <funkyjunkyrobot> does that force it to be num
15:01:51 <funkyjunkyrobot> well i check if the head == 0
15:02:08 <endojelly> funkyjunkyrobot, and you are checking if something is equal. that at least means it must be an instance of Eq! (like Num, yes)
15:02:29 <funkyjunkyrobot> ok, i see the problem now atleast
15:02:50 <funkyjunkyrobot> now how to say that a is a list of Nums
15:03:00 <endojelly> funkyjunkyrobot, so two things, one stronge than the other: because of ==, the type is not so general anymore. worse, because of == 0, it must be Num.
15:03:13 <funkyjunkyrobot> right
15:03:20 <endojelly> funkyjunkyrobot, why do you want the type of startWithCurve to be so generic?
15:03:36 <funkyjunkyrobot> cuz i'm a total nub
15:03:41 <funkyjunkyrobot> :(
15:03:49 <endojelly> funkyjunkyrobot, it isn't. we just saw that it only works with Nums. give it a more specific type
15:03:54 <funkyjunkyrobot> i'm only working with lists of ints... it doesn't have to be generic
15:03:58 <Heffalump> can anyone give me some git help?
15:04:17 <endojelly> funkyjunkyrobot, so what could you use instead of 'a'?
15:04:30 * Heffalump is either suffering from NIH or is too stupid to use it
15:04:30 <funkyjunkyrobot> [[int]]
15:04:43 <endojelly> funkyjunkyrobot, great. except that it's Int not int. but yeah.
15:04:54 <funkyjunkyrobot> ohh yeah, i've had that error before too
15:05:08 <funkyjunkyrobot> my brain is fried so hard trying to learn haskell over night :(
15:05:19 <funkyjunkyrobot> i'm just being dumb
15:05:59 <endojelly> funkyjunkyrobot, overnight is hard if you've never come across functional programming at all.
15:06:07 <funkyjunkyrobot> never
15:06:23 <Veinor> time to leah
15:06:24 <funkyjunkyrobot> as if thinking recursively wasn't enough.....
15:06:29 <Veinor> ... stupid keys not working
15:06:46 <Veinor> Heffalump: what's the git problem
15:06:58 <endojelly> funkyjunkyrobot, oh and try to interpret the error message everytime.
15:07:10 <endojelly> funkyjunkyrobot, like now, look at it again and see if you can make out its meaning.
15:07:35 <funkyjunkyrobot> yeah, that has been extreamly difficult for me
15:07:53 <funkyjunkyrobot> i will try. it's hard to tell where to look
15:08:34 <endojelly> funkyjunkyrobot, you have to get used to them, yeah. hope you're using ghci at least?
15:08:42 <funkyjunkyrobot> yep
15:08:48 <endojelly> ok
15:08:55 <funkyjunkyrobot> only useful advice my professor gave me was to use ghci
15:09:16 <funkyjunkyrobot> and then he went out of town thursday and is unreachable
15:09:17 <Heffalump> Veinor: I have a patch that I think was produced with git-format-patch (it has index lines in each hunk). When I try to git apply it, I just get told it doesn't apply, and there's a message about "space before tab" on a particular line of the patch. When I inspect the patch that doesn't seem to be true.
15:09:28 <syntaxglitch> funkyjunkyrobot, for whatever it's worth I think you're doing pretty well under the circumstances
15:09:37 <funkyjunkyrobot> thx
15:10:00 <funkyjunkyrobot> without all of you, and the learnyouahaskell.com i'd be in bad spot right now
15:10:18 <endojelly> funkyjunkyrobot, yeah, you're responding to the clues. so you do think about it.
15:10:43 <syntaxglitch> I've seen people struggle for weeks and not seem to get even as far as you have
15:10:58 <funkyjunkyrobot> and i apreciate the clues rather then spoon feeding. cuz i'm struggling with the easy part. and it has 3 more harder parts tot he assignment. if i don't get all of this easy stuff then i'm doomed
15:12:04 <endojelly> funkyjunkyrobot, if the only hard thing about the hard part is that you have to know the easy stuff first, then it's not really hard after you got the easy stuff, right?
15:12:14 <Heffalump> Veinor: actually, never mind. It's possible the patch actually does have the corruption described.
15:12:19 <funkyjunkyrobot> thats what i'm hope'n for
15:12:28 <endojelly> then again, maybe your professor gave you stuff that people who know the basics would consider 'hart'. doubt that, though
15:12:40 <endojelly> hard
15:13:40 <funkyjunkyrobot> i have the assignment on a pdf if ur interested to look at it it's a short assignment, but it's mostly thinking that takes the longest not the coding
15:13:54 <endojelly> funkyjunkyrobot, I am
15:14:01 <syntaxglitch> funkyjunkyrobot, also I sympathize because I've decided to spend this weekend learning a new language that most people would consider "difficult" :D
15:14:18 <endojelly> though I have to get the laundry right now, so paste the link and I'll look at it later.
15:14:22 <syntaxglitch> sure, I'm curious what else is in there
15:14:27 <funkyjunkyrobot> k
15:14:45 <endojelly> (don't hope that I will solve your homework for you, though that doesn't seem to be what you want anyway)
15:15:00 <endojelly> syntaxglitch, which one?
15:15:07 <syntaxglitch> endojelly, agda
15:15:10 <endojelly> syntaxglitch, hah
15:15:19 <endojelly> syntaxglitch, I had to learn that too :D
15:15:28 <syntaxglitch> I'm just doing it for fun
15:15:40 <endojelly> syntaxglitch, totally sympathize. am now writing my project thesis about it and my diploma thesis will probably be about it, too.
15:15:42 <funkyjunkyrobot> it's not but it'd just help if i didn't have to explain my end goal
15:15:45 <endojelly> syntaxglitch, what did you learn it for?
15:16:11 <funkyjunkyrobot> https://my.unl.edu/@@/B0EB73BD6B77F1D298D62B4EE2C61557/courses/1/CSCE322001.1108/content/_3665919_1/3v7.pdf tell me if u can get that or if only i can access that link
15:16:23 <funkyjunkyrobot> else i'll have to post it elsewhere
15:16:30 <syntaxglitch> endojelly, I'm learning agda for the same reason I learned haskell, because it sounds fun
15:16:42 <syntaxglitch> that's really the short and long of it
15:16:57 <endojelly> syntaxglitch, cool. it is, it's really interesting and it's fun playing around with it
15:17:17 <syntaxglitch> that, and I finally realized just how silly some of the type hackery I was doing in Haskell really was
15:17:23 <endojelly> funkyjunkyrobot, hmm, it says it's redirecting me and seems to timeout afterwards
15:17:28 <funkyjunkyrobot> ok
15:17:31 <endojelly> syntaxglitch, heheh
15:17:33 <funkyjunkyrobot> maybe i can just send it to ya
15:17:37 <syntaxglitch> and that I should learn to stop worrying and love the dependent types
15:17:59 <endojelly> syntaxglitch, in my case, learning agda caused me to attempt some really silly type hacks in haskell
15:18:37 <geheimdienst> funkyjunkyrobot: i get a page asking me for my user and password
15:18:46 <funkyjunkyrobot> ok
15:18:51 <syntaxglitch> endojelly, at one point I started writing a type-level interpreter for something roughly equivalent to System F
15:18:52 <funkyjunkyrobot> well maybe i can put it someplace else
15:19:01 <funkyjunkyrobot> i can send it to u directly if u want
15:19:02 <syntaxglitch> I think that's when I finally looked in a mirror and realized what I had become
15:19:05 <endojelly> syntaxglitch, in agda or haskell?
15:19:05 <Heffalump> Veinor: no, I am still confused. gnu patch applies the patch file fine (with fuzz) but git apply objects
15:19:13 <syntaxglitch> endojelly, Haskell of course
15:19:30 <syntaxglitch> in agda there'd be no reason to specify "type-level"
15:19:32 <endojelly> syntaxglitch, ah. because I did something system Fish in Agda: http://ejelly.net/Types/Types.html
15:19:35 <funkyjunkyrobot> did u get the file send request?
15:19:48 <Veinor> Heffalump: I dunno then :/
15:20:01 <endojelly> syntaxglitch, I would now do it slightly differently, though, more akin to the lambda cube
15:20:04 <Veinor> system fish, you say? :O
15:20:11 <endojelly> Veinor, heheh
15:20:13 <endojelly> system F-ish
15:20:16 <endojelly> didn't notice that.
15:20:23 <aristid> i think i like yesod
15:20:28 <syntaxglitch> system Fish, heh
15:20:37 * hackagebot concurrentoutput 0.2.0.1 - Ungarble output from several threads  http://hackage.haskell.org/package/concurrentoutput-0.2.0.1 (JoachimBreitner)
15:20:43 <syntaxglitch> as opposed to adding dependent types, which would be system Rooster I expect
15:20:44 <endojelly> funkyjunkyrobot, DCC ist always stupid, try to upload it somewhere. your private webspace, for example
15:20:58 <Veinor> yeah, i've had dcc problems even with a public IP
15:21:02 <syntaxglitch> funkyjunkyrobot, I think you can also upload PDFs to google docs
15:21:09 <endojelly> syntaxglitch, pahah.
15:21:42 <endojelly> anyway, laundry! later
15:21:45 <pelotom> what are the major ways Agda is different from, say, Coq?
15:22:09 <syntaxglitch> pelotom, beats me! I just started learning Agda and know very little about other dependently typed languages
15:22:10 <pelotom> I've heard it's more geared towards programming rather than abstract mathematical proofs
15:22:29 <syntaxglitch> it seems to be fine for either or both
15:22:58 <pelotom> I'd like to see an in-depth comparison of coq, agda and epigram
15:23:05 <syntaxglitch> I fully intend to treat it like a programming language and nothing has stopped me yet! other than giant boilerplate crap for using the "FFI"
15:23:11 <kmc> Coq has the very theoretically sound dependently typed functional program / proof-term language, and on top of that an ugly ad-hoc imperative implicitly scoped "tactics" language
15:23:18 <kmc> Agda lacks the latter
15:23:34 <kmc> so your proofs are explicit terms rather than semi-implicit recipes for searching for a proof
15:23:55 <pelotom> kmc: yeah, the tactic language has never seemed very attractive to me
15:24:03 <funkyjunkyrobot> ok sorry bout that i got it uploaded to my webspace
15:24:04 <kmc> it's useful...
15:24:06 <funkyjunkyrobot> http://www.cse.unl.edu/~jsukup/3v7.pdf
15:24:15 <kmc> Coq proofs are only readable by stepping through them
15:24:18 <ibt> what's with code.haskell.org being down?
15:24:24 <kmc> you could write the explicit proof term in Coq too
15:24:34 <pelotom> kmc: but Gallina leaves quite a bit to be desired as a functional language
15:24:35 <funkyjunkyrobot> afk for 10min
15:24:45 <kmc> proof terms are unreadable for a different reason: they're huge
15:24:52 <pelotom> yeah
15:25:40 <kmc> anyway Coq and Agda are a lot of fun
15:25:47 <kmc> an interactive proof assistant is a very compelling toy / puzzle game
15:25:55 <Saizan> proof terms written by an human are usually readable because one will use some layers of abstraction
15:26:00 <pelotom> kmc: yeah, coq is maddeningly fun
15:26:04 <Saizan> normalized ones are quite unreadable though
15:26:14 <pelotom> kmc: have you tried epigram?
15:26:17 <kmc> no
15:27:38 <Heffalump> Veinor: is there any way to recreate the repo state the patch was made against?
15:27:40 <pelotom> how about omega, anyone tried that?
15:27:52 <Heffalump> ibt: the machine is up, but the web server isn't responding. No idea why.
15:28:13 <Veinor> Heffalump: sorry, I really don't know a lot about git
15:28:58 * pelotom wishes he had time to explore all these nifty languages more
15:29:44 <geheimdienst> Heffalump: i forgot the exact syntax, but there is a way to check out an old state of a repo. "git checkout ^^HEAD" is the, dunno, commit before commit before the last commit
15:30:02 <geheimdienst> use "gitk" to get an overview of what's going on ...
15:30:31 <Heffalump> geheimdienst: but how do I identify what state the patch is against?
15:30:36 <kmc> pelotom, i've read about it
15:30:45 <kmc> it's not dependently-typed
15:30:58 <kmc> there was someone else here with a toy n-levels pure-type-system language
15:31:00 <sid137> Hi everyone.. mind if I ask a noob Haskell question?
15:31:11 <kmc> but in general they're pretty rare, i'd like to see more in that space
15:31:16 <kmc> sid137, go ahead, that's why we're here :)
15:31:24 <pelotom> kmc: yeah, it's got an infinite hierarchy of types but no higher levels depending on lower levels?
15:31:37 <dmwit> Heffalump: If you're asking about git, the question is ill-formed. Patches can have parents, but they aren't inherently identified with a state of the repository (unfortunately).
15:31:48 <sid137> thanks :)  So i'm reading "Programming in Haskell", trying an excercise, which asks the type of this function:   twice f x
15:31:51 <Heffalump> ah. (Btw, it's your patch I'm having trouble with :-)
15:31:51 <sid137> = f (f x )
15:31:52 <geheimdienst> Heffalump: i don't know ... aren't there any long-ass sha1 hex numbers at the beginning of the patch? those would identify a git commit. otherwise, ask the guy that gave you the patch
15:31:53 <sid137> twice f x
15:31:53 <sid137> = f (f x )
15:32:05 <dmwit> Heffalump: ah
15:32:16 <dmwit> Heffalump: Would you like me to redo it against a different repository...?
15:32:16 <sid137> and when I try it, I get (a -> a) -> a -> a
15:32:25 <sid137> and I don't understand why..
15:32:37 <Heffalump> might the From line in the .patch file be a commit id?
15:32:59 <dmwit> Oh, you're wondering how to apply it?
15:33:01 <mauke> sid137: what did you expect instead?
15:33:03 <Heffalump> dmwit: perhaps, though right now I'd like to understand this; might actually learn something.
15:33:06 <dmwit> "git am" is the command you're looking for, if so.
15:33:21 <Heffalump> dmwit: that refuses, claiming it doesn't apply on line 348 of Network/TCP.hs
15:33:32 <sid137> well, I don't kno w what to expect, because we don't know what the return type of f a is
15:33:48 <mauke> sid137: yes, we do
15:33:55 <mauke> it's the same type as x
15:33:55 <pelotom> sid137: well you know that the return type of f must be compatible withe input type, right?
15:34:03 <sid137> how do we know that?
15:34:08 <mauke> sid137: f (f x)
15:34:11 <dmwit> Heffalump: Okay, hold on, I've got to find the relevant bits of information again.
15:34:35 <pelotom> sid137: you defined it as "twice f x = f (f x)"
15:34:36 <sid137> ah.. I think I see.. since we can apply f (f x), we know that (f x) is the same as x
15:34:40 <sid137> okm I see..
15:34:40 <Heffalump> I could just apply the patch with gnu patch, so this isn't crucial
15:34:43 <pelotom> sid137: same type, yes
15:34:56 <sid137> so then...hmm
15:35:15 <dmwit> Heffalump: Yes, the From line is probably the "parent" patch in this case.
15:35:24 <sid137> ok.. I gete it now
15:35:30 <pelotom> @let twice f = f . f
15:35:31 <lambdabot>  Defined.
15:36:10 <dmwit> err, no
15:36:32 <Heffalump> it doesn't seem so; git show xxx reports bad object
15:37:01 <dmwit> No, e5f1d16ff456... seems to be the 0001-prevent-infinite-loop-when-reading-EOF patch itself
15:37:05 <sid137> so since we know (f x) :: x, we knowo that twice, takes a function of type x:  twice f :: (a -> a), and then curries that with the arg x, to get (a -> a) -> a
15:37:09 <sid137> right?
15:37:13 <Heffalump> I see.
15:37:17 <Heffalump> so there is no parent info?
15:37:42 <Jonny> Hello
15:38:00 <Heffalump> I notice there is some kind of index info for each file.
15:38:18 <geheimdienst> Heffalump: you could double-check you actually have the newest state of the repo. maybe you're applying to an old commit ...
15:38:42 <dmwit> I will admit that I don't understand everything I want to understand about git. =P
15:38:47 <Heffalump> geheimdienst: I'm fairly sure I do
15:38:49 <dmwit> But let's see...
15:39:02 <Jonny> Can anyone help with an error please? In this script http://pastebin.com/FMdAEzDG   I receive the error: Instance of Integral Float required for definition of apply
15:39:06 <Heffalump> if I get stuck with this for too much longer I'm switching back to darcs ;-)
15:40:15 <dmwit> Heffalump: The parent is 1d4197f6343cb
15:40:38 <geheimdienst> Heffalump: good call :) i found darcs to be much clearer. git to me is a confused jumble of too many concepts, too many commands, switches that kind of do what the other command does ...
15:41:03 <Heffalump> geheimdienst: glad to hear it :-)
15:42:07 <Heffalump> dmwit: ok, that applies now.
15:42:14 <identity_> I never looked at darcs, but I really like git
15:42:17 <Heffalump> So perhaps that error was just git's way of saying "doesn't apply cleanly"
15:42:22 <identity_> + github interface etc is pretty sweet.
15:42:44 <dmwit> Seems so.
15:43:29 <Heffalump> and after all that, it doesn't even maintain the patch with correct attribution. Gah.
15:43:37 * pelotom is building UHC from github #excited
15:43:37 <Heffalump> so I shouldn't have bothered.
15:43:43 <dmwit> heh
15:43:47 <dmwit> It doesn't matter, anyway.
15:44:03 <Heffalump> I didn't think you'd particularly mind, I was just trying to do things the "right way"
15:44:08 <dmwit> yeah
15:44:28 <Heffalump> anyway, I probably would still rather change it to a separate function, but I wanted to dig around the code first.
15:44:33 * dmwit isn't even sure he sent the patch "the right way"
15:44:37 <dmwit> So it may not be your fault.
15:44:59 <Heffalump> (git also mentions that it introduces a whitespace error, but given how the repo is riddled with tabs, I don't really blame you!)
15:45:45 <dmwit> My favorite part of the bug is the sentence on the ticket that goes, like, "It works on Linux by accident."
15:45:45 <Jonny> Can anyone help with my error please?
15:45:48 <dmwit> haha
15:45:59 <Heffalump> :-)
15:46:05 <Heffalump> I'd really like to be able to reproduce the bug reliably.
15:46:10 <dmwit> Jonny: Without even looking, I'm guessing it's a (/) vs. `div` problem.
15:46:21 <dmwit> Heffalump: Windows in a VM -> reliable reproduction
15:46:50 <dmwit> Heffalump: Or just stick a print in the function that I changed. It should only print once when the bug is fixed, but even on Linux it prints a whole lot of times.
15:47:16 <dmwit> (This is how I tested my fix, as I was trying to fix in Linux where I'm more comfortable.)
15:47:25 <Heffalump> ah, that's useful, thanks
15:47:56 <Jonny> dmwit: Actually I've worked out its a ^ problem
15:48:04 <funkyjunkyrobot> i'm extremely stuck with my homework. anyone want to help me think of a direction to move in?
15:48:12 <Jonny> but I don't know how else I can write ^ to work with floats
15:48:17 <dmwit> :t (**)
15:48:17 <lambdabot> forall a. (Floating a) => a -> a -> a
15:48:24 <dmwit> :t (^^) -- ?
15:48:25 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
15:50:36 <geheimdienst> funkyjunkyrobot: give us some clues about the homework question?
15:50:53 <funkyjunkyrobot> ok
15:50:56 <funkyjunkyrobot> http://www.cse.unl.edu/~jsukup/3v7.pdf
15:51:05 <funkyjunkyrobot> i'm on part one trying to detect if a given track is oval
15:51:26 <funkyjunkyrobot> my process so far is first to check if it has 4 curves. i've succeded in that.
15:52:17 <funkyjunkyrobot> then i decided i wanted to start with a curve, because if i start with a straight peice i may end up wrapping back around and that sounds complicated, so by starting with a curve all my straight sides will be well defined
15:52:44 <funkyjunkyrobot> so i have a function to push straight pieces to the end untill i get a curved piece
15:52:50 <funkyjunkyrobot> at the head
15:53:33 <funkyjunkyrobot> now i'm looking at a list with 4 curves and i need to get the lengths of sides 1, 2, 3,and 4 and make sure side1 == side3 and side2 == side4
15:53:39 <Heffalump> dmwit: great, thanks, I see that too. Not sure how to turn it into a test, but at least I now can see the problem.
15:54:40 <funkyjunkyrobot> so i was thinking about making a list of the locations of the curves, knowing they are seperated by sides and using the locations of the curves to define the lengths of the sides
15:55:15 <funkyjunkyrobot> i'm just not able to think in haskell yet. and i'm not sure what objective i should start working toward
15:55:34 <osaunders> Can anybody suggest a way of making this cleaner? Particularly those nested ifs. http://hpaste.org/41224/any_cleaner
15:55:50 <Heffalump> dmwit: so why does this happen with some URLs and not others?
15:57:28 <kmc> osaunders, nested 'if' can be replaced by this trick:   case () of _ | a -> ... | b -> ...
15:57:37 <kmc> for a,b,c,... arbitrary boolean expressions
15:57:55 <Veinor> osaunders: move the nested ifs into a new function with guards
15:57:56 <kmc> or you can define a function in your "where" using guards an call it
15:58:24 <osaunders> Veinor: OK, I'll try that.
16:00:10 <sid137> kmc++
16:01:14 <Vanadium> That tripped my C++ highlight.
16:03:23 <Saizan> @remember Vanadium That tripped my C++ highlight.
16:03:23 <lambdabot> It is forever etched in my memory.
16:03:35 <luc_t> when cabal install happstack (after cabal upgrade gitit) , it breaks at [22 of 26] Compiling Happstack.Server.SimpleHTTP ( src/Happstack/Server/SimpleHTTP.hs, dist/build/Happstack/Server/SimpleHTTP.o )
16:03:35 <luc_t> src/Happstack/Server/SimpleHTTP.hs:578:38:
16:03:36 <luc_t>     Could not deduce (Functor m)
16:03:36 <luc_t>       from the context (FilterMonad Response (WebT m), Monad m)
16:03:36 <luc_t>       arising from a use of `fmap'
16:03:37 <luc_t>                    at src/Happstack/Server/SimpleHTTP.hs:578:38-45
16:03:37 <luc_t>     Possible fix:
16:03:38 <luc_t>       add (Functor m) to the context of the instance declaration
16:03:38 <luc_t>     In the first argument of `($)', namely `fmap lft'
16:03:38 <luc_t>     In the second argument of `($)', namely
16:03:39 <luc_t>         `fmap lft $ getFilter (runErrorT $ unWebT m)'
16:03:39 <luc_t>     In the second argument of `($)', namely
16:03:39 <luc_t>         `ErrorT $ fmap lft $ getFilter (runErrorT $ unWebT m)'
16:03:40 <luc_t> cabal: Error: some packages failed to install:
16:03:50 <Heffalump> luc_t: get a pastebin
16:03:53 <Saizan> luc_t: use a pastebin 
16:04:02 <Heffalump> luc_t: but likely you've got a problem with mtl 2
16:04:11 <Heffalump> try cabal install happstack --constraint 'mtl < 2'
16:04:14 <luc_t> sorry newby to irc
16:04:16 <Saizan> luc_t: also, never use cabal upgrade
16:04:24 <stepcut> luc_t: sorry, I am going to push a patch for that tomorrow
16:04:38 <baguasquirrel> Heffalump: thanks for that bit
16:04:43 <baguasquirrel> I had trouble there too
16:04:44 <stepcut> luc_t: it's just a one line fix, but you can do as Heffalump suggests for now
16:05:13 <stepcut> that line just needs to use liftM instead of fmap
16:05:39 <luc_t> thx guy, my first try on irc, but what a timely answer thx  :) 
16:06:09 <stepcut> luc_t: there is a #happs channel that is happstack specific as well
16:06:29 <luc_t> and does it try to recompile haxml and hslogger etc every time, even when i tried and recompile them succe sucessfully separately ?
16:07:09 <geheimdienst> funkyjunkyrobot: hm let's see ... i think i would attack it by taking the input list and getting everything between the first 0 (curve) and the second 0, then between the second 0 and the third, and so on. so you end up with [ [], [[1,10,20]], [], [[1,15,15]] ] for your example, i.e. a side of length 0, one of length 1, one of length 0, and finally one of length 1
16:07:21 <geheimdienst> just as some inspiration
16:07:40 <funkyjunkyrobot> yep, thats what i'm working toward
16:07:58 <baguasquirrel> hmm, why would that line not work?
16:08:04 <baguasquirrel> aren't liftM and fmap analogous?
16:08:12 <Heffalump> baguasquirrel: yes, but they have different class constraints
16:08:29 <Heffalump> and in this case there's been a change in the underlying constraints for the Functor instance of monad transformers in mtl
16:08:46 <baguasquirrel> ah ic
16:08:46 <Heffalump> where previously the constraint was Monad m => Functor (FooT m), now it's Functor m => Functor (FooT m)
16:08:52 <McManiaC> I want to change 2 bytes in a binary file, is there any other way than reading the whole file, processing it byte by byte and then write it again?
16:09:09 <Heffalump> McManiaC: there are seek commands in the file IO api
16:09:30 <McManiaC> file IO api?
16:09:38 <Heffalump> as in System.IO
16:09:39 <Cale> > showCReal 100 pi
16:09:40 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
16:09:45 <funkyjunkyrobot> so i could get the lengths of those elements then
16:09:46 <Heffalump> @type hSeek
16:09:47 <lambdabot> Not in scope: `hSeek'
16:09:52 <funkyjunkyrobot> or sub lists
16:09:58 <geheimdienst> so i guess you want to look at the section "list operations" in http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html and get a feel for that. try using ghci for trying out the functions takeWhile, dropWhile, and break
16:10:07 <Heffalump> @type System.IO.hSeek
16:10:08 <lambdabot> GHC.IOBase.Handle -> GHC.Handle.SeekMode -> Integer -> IO ()
16:10:35 <geheimdienst> this should get you started towards breaking up that input list into sides
16:11:27 <funkyjunkyrobot> thx for that, i haven't seen this page before
16:11:47 <geheimdienst> oh really? it's very essential. something to bookmark
16:11:51 <geheimdienst> :)
16:12:04 <McManiaC> Heffalump: could I somehow directly change those two values if I'd know their location (as in a hex editor)?
16:12:38 <Heffalump> McManiaC: yes, seek to the location, write the new bytes
16:12:43 <Heffalump> having opened the file in write mode
16:12:53 <Heffalump> that's what a hex editor would do too
16:12:58 <funkyjunkyrobot> wow!
16:13:12 <funkyjunkyrobot> take is useful
16:13:22 <LegendaryPenguin> checking if it is an oval.. isnt that real easy
16:13:37 <funkyjunkyrobot> u would think so, but i'm so not get'n it
16:13:55 <Heffalump> I think you probably need to open it in ReadWriteMode
16:14:04 <funkyjunkyrobot> another student was bragging in class about doing it in 2 lines.... so yeah it's probly really easy
16:14:11 <LegendaryPenguin> oh
16:14:16 <Heffalump> certainly not WriteMode (which would truncate the file); perhaps AppendMode.
16:14:17 <LegendaryPenguin> did he put everything on 2 lines
16:14:40 <funkyjunkyrobot> i duno he didn't show his code or anything
16:14:51 <McManiaC> Heffalump: kay, I'll try :)
16:14:51 <funkyjunkyrobot> he may have called other functions
16:15:18 <Heffalump> do back up your file first :-)
16:15:26 <funkyjunkyrobot> i've been thinking about this now for 2 days so i'm sure it's easy but i'm a total noob to haskell
16:15:34 <geheimdienst> don't get scared by the word "oval", it's all 90° curves and straight lines. by "oval" we're talking about checking a form with 4 lines if a the lengths of its opposing sides agree
16:15:56 <funkyjunkyrobot> yeah and they can be zero
16:16:02 <funkyjunkyrobot> just to get that out there
16:16:53 <LegendaryPenguin> so 4 corners, and even number of straights
16:16:57 <LegendaryPenguin> right?
16:17:09 <funkyjunkyrobot> so i've got a function to give me the location of a curve, then i want to chop the list and find the next location. and do that till i have all the curve locations. then i figure their difference is the lengths
16:17:24 <funkyjunkyrobot> not really
16:17:34 <funkyjunkyrobot> so lets think of it as side 1, 2, 3, 4
16:17:42 <geheimdienst> LegendaryPenguin: in the given example, yes. wouldn't hurt to make the program robust enough to handle more than 4 corners (just saying "no i don't like that track")
16:17:48 <luc_t> another funny cabal stuff . how do I pastebin ?
16:18:07 <geheimdienst> @where paste
16:18:07 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
16:18:08 <LegendaryPenguin> oh, nm
16:18:18 <funkyjunkyrobot> if side1=2, side2=4,side3=4,side4=2 then no that wouldn't work, yet we have even sides
16:18:49 <LegendaryPenguin> well side1 and side 3 and side 2 and 4 have to be the same length
16:18:55 <funkyjunkyrobot> yep
16:19:11 <funkyjunkyrobot> i can't store those values in variables can i?
16:19:17 <funkyjunkyrobot> haskell doesn't do that right?
16:20:18 <luc_t> thx http://hpaste.org/41225/cabal_install_gitit 
16:20:23 <geheimdienst> you can think of it like this: haskell has variables, but you can only write to them *once*. if you know java, it's a little like using the 'final' keyword on a variable
16:20:44 <funkyjunkyrobot> ok, i know java and yeah i can picture that
16:21:04 <ddarius> Except that it would require a somewhat statement oriented syntax, it would be nice if Haskell had single-assignment variables.
16:21:07 <kmc> they're like variables in math
16:21:08 <luc_t> i have gitit working on the machine date june, juste refreshed cabal
16:21:14 <funkyjunkyrobot> so using the let function if i call that in the middle of a function so say let side1 = ... then i can use side1 later?
16:21:32 <kmc> my 2¢ is that learning Haskell by analogy to Java is likely to be frustrating
16:21:36 <geheimdienst> (this is because haskell takes the stance that overwritable or "mutable" variables cause more harm than they help)
16:21:41 <funkyjunkyrobot> i agree with kmc
16:21:52 <funkyjunkyrobot> yeah
16:21:59 <m3ga> i'm on Linux, ghc 6.12.3 from Debian. System.Directory.canonicalizePath [] is giving me a non-empty string. whats up with that?
16:22:25 <geheimdienst> kmc, i meant just this one issue of single-assignment variables
16:22:26 <Veinor> what string is it giving you?
16:22:33 <funkyjunkyrobot> it's all about a function being consistent. if it's result is such and such now it has to be later as well , if u change a dependent variable it is not consistent later, so the fundamentals break down
16:22:51 <luc_t> ps: my previous happs build was sorted
16:23:05 <luc_t> now issue when rebuilding gitit
16:23:40 <geheimdienst> yeah, we say that functions are "pure" in haskell
16:23:43 <Veinor> m3ga: oh weird... it gives me a nonempty character too
16:24:13 <m3ga> Veinor: you also on debian?
16:24:19 <Veinor> ubuntu, but yeah
16:24:30 <m3ga> lemme try freebsd
16:25:08 <Veinor> os x produces the current directory, which is expected behavior
16:25:41 <Veinor> okay, it's reading from uninitialized memory
16:25:41 <magicman> Fedora <something>: ~\abc\def, where I currently can't be bothered to find out which exact character codes they are <_<
16:26:10 <Veinor> if I load System.FilePath.Posix, it works fine
16:26:41 <funkyjunkyrobot> i'm at scholl right now. i'm gona take off and i'll be home and back on here in like 40 minutes. see you all later and thanks for everything.
16:27:24 <nus> luc_t, what does 'ghc-pkg check' say?
16:27:52 <geheimdienst> dudes! canonicalizePath [] gives me "\134\176\SI\182\197\188!\183\241;#\183\157\176\SI\182\146\176\SI\182\253;#\183\185\136\b\t\137v\b\t\t<#\183," :-o
16:28:15 <geheimdienst> what manner of witchcraft is this. what's \SI anyway ...
16:28:24 <nus> ascii
16:28:30 <ddarius> > ord '\SI'
16:28:30 <lambdabot>   15
16:28:42 <m3ga> yeah, all a bit weird!
16:28:55 <m3ga> freesd result is pretty nutty as well
16:29:04 <geheimdienst> is the \abc notation an octal number or hex?
16:29:09 <m3ga> octal
16:29:13 <m3ga> i think
16:29:15 <ddarius> Decimal
16:29:21 <ddarius> > '\15'
16:29:21 <lambdabot>   '\SI'
16:29:31 <m3ga> yes, decimal
16:29:33 <nus> what'd be 8 doing in *octal* number?
16:29:46 <m3ga> yeah, yeah, brain fart
16:29:49 <geheimdienst> thanks. that means what i pasted is not even ascii chars, they are mostly > 127
16:30:09 <m3ga> freebsd gives : "\243@\232\181}\136d\CAN}\b\136)\241\163\129)\229\163\129)\137\b\136)\SOH\135V)Q\251\ETX\t\149\b\136)\214[\129)\ty\130)\253\163\129)\241\v\EOT\t\169\b\136)\DC1\164\129)\ENQ\164\129)\181\b\136)\181rV)Q\251\ETX\t\193\b\136)\203~"
16:30:31 <Veinor> it's loding from uninitialized memory, I'm pretty sure
16:30:46 <geheimdienst> maybe the function gets some strange buffer from C and reads it
16:30:56 <geheimdienst> veinor, exactly ...
16:31:11 <luc_t> nus: http://hpaste.org/41226/ghcpkg_check 
16:31:48 <m3ga> ill raise a bug on the ghc bug tracker
16:32:27 <Veinor> canonicalizePath "." seems to do the right thing though
16:32:29 <Veinor> which is good
16:35:04 <luc_t> nus :  also http://hpaste.org/41227/ghcphk_check
16:35:26 <geheimdienst> my speculation is this: canonicalizePath calls realpath, which for "" gives an EINVAL with the result string being undefined. haskell forgets to check errno and takes the undefined string
16:35:52 <lars9> :t Signal
16:35:53 <lambdabot> Not in scope: data constructor `Signal'
16:36:04 <lars9> :t Op
16:36:05 <lambdabot> Not in scope: data constructor `Op'
16:37:05 <McManiaC> Heffalump: what do I use after "seeking" to the position? I used hPutStr and now everything got 0'ed and only my written values are non-zero
16:37:08 <nus> luc_t, you can run cabal in two ways: --user and --global
16:37:47 <nus> luc_t, you've got two conflicting versions of the same package in the two package directories
16:37:56 <luc_t> nus :  what should i do ?
16:40:20 <nus> luc_t, cabal install --global gitit ?
16:42:39 <McManiaC> Heffalump: http://npaste.de/pK/ my current code
16:43:03 <JimmyRcom> can case expressions have guards?
16:43:42 <aristid> JimmyRcom: the patterns can
16:47:13 <luc_t> nus: went cray: http://hpaste.org/41228/cabal_install_global_gitit  it went and recompile happstaks, haxml agin, and lots others and failed , becaiuse of permisison denied. i suppose not root. thi s
16:47:42 <luc_t> nus: oops . this is ghc that needs directory 1.1.0.1 so i gues is root
16:48:11 <luc_t> any way, thx, over for now
16:48:53 <m3ga> http://hackage.haskell.org/trac/ghc/ticket/4480
16:49:33 <McManiaC> how do you use hPutBuf from System.IO ?
16:54:26 <JohnnyL> hm, ghc at 3 percent cpu on idle
16:54:51 <MrDimwit64> hello
16:57:20 <MrDimwit64> does anyone know a function to make a string uppercase?
16:58:13 <rryan> uppercaseString = map Data.Char.toUpper
16:58:14 <rryan> ?
16:58:23 <unkanon> > map toUpper "hello"
16:58:24 <lambdabot>   "HELLO"
16:59:13 <graphov> Hello! I've some cabal dependency troubles. I'm trying to cabal install yesod-auth package but it depends on pureMD5 and cryptocipher wich both depend on incompatible versions of crypto-api. Actually it seems that pureMD5 can be built against newer crypto-api but how to make cabal know that fact? Hackage version is bound to loder one. Just fixing .cabal file by hand and then installing it doesn't help...
16:59:43 <graphov> s/loder/older/
17:00:13 <unkanon> ^ if that's not a reason to dislike package managers with shared dependencies, I don't know what is
17:00:31 <unkanon> sorry I can't help but I feel your pain
17:12:27 <McManiaC> Heffalump: nevermind, I had to use ReadWriteMode with "withBinaryFile" :)
17:16:51 <unkanon> lambdabot used to take :t, what happened?
17:17:25 <geheimdienst> :t map
17:17:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:18:02 <unkanon> I just tried exactly that privately with lambdabot and it doesnt do anything
17:18:49 <unkanon> so weird
17:19:47 <Veinor> I don't think lambdabot takes :t in PMs for some reason
17:19:50 <kmc> lambdabot's :t and > work only here
17:20:06 <unkanon> kmc: well, > works privately
17:20:08 <kmc> oh really?
17:20:10 <unkanon> i should know
17:20:14 <unkanon> i've been abusing lambdabot
17:20:18 <unkanon> for the past hour
17:20:21 <kmc> hehe
17:20:38 <geheimdienst> i find that disgusting
17:20:40 <unkanon> @type map
17:20:41 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:20:46 <unkanon> oh, that works privately
17:20:46 * geheimdienst pats lambdabot on the head soothingly
17:21:30 <unkanon> it's like :t is a shotcut for @type that only works here
17:21:52 <unkanon> s/shotcut/shortcut/
17:25:09 <JohnnyL> how do you determine where a class constraint originates from within an expression?
17:26:08 <osaunders> > f <$> [1,2,3]
17:26:09 <lambdabot>   Ambiguous type variable `b' in the constraints:
17:26:09 <lambdabot>    `SimpleReflect.FromExpr ...
17:28:34 <engla> I wonder why I can't use examples off the web immediately
17:28:43 <kmc> what kind?
17:28:44 <engla> I'm trying to learn haskell
17:29:12 <engla> well I read that a function definition is just   s [] = 0  (newline)  s (x:xs) = x + s xs
17:29:21 <engla> but this doesn't work when I put it into haskell
17:29:30 <EvanR> ghci has some limitations
17:29:36 <EvanR> do
17:29:41 <Cale> engla: What Haskell implementation, and where are you putting it?
17:29:46 <EvanR> let s [] = 0; s (x:xs) = x + s xs
17:29:50 <Cale> engla: Put the definition into a file, and load it.
17:30:18 <Cale> For example, if you put it into Foo.hs, and you're using ghci, you can just run  ghci Foo.hs  to load the program, and test it.
17:30:35 <Cale> :r from ghci will reload the file whenever you change it
17:30:38 <engla> I have ghc
17:31:53 <engla> ok with let first it works in ghci. But not when saved in a file and then :load from ghci
17:32:07 <engla> I really don't understand and I'm frustrated that the examples I find simply don't work
17:32:12 <kmc> it should work in a file
17:32:21 <kmc> can you paste your file at hpaste.org?
17:32:22 <geheimdienst> what's the error message?
17:32:31 <kmc> maybe you're doing something wrong, but this is not a case of broken examples
17:32:39 <kmc> perhaps incomplete instructions on *how* to run the examples
17:32:45 <engla> testfile.hs:2:0: parse error (possibly incorrect indentation)
17:33:12 <dmwit> Heffalump: Some URLs happen to end a reading block just before a newline or something like that.
17:33:18 <engla> the file is simply EvanR's single line
17:33:28 <kmc> engla, don't use "let" like that in a file
17:33:30 <dmwit> Heffalump: I forget the details. Anyway it's either just before the final newline or just after, or maybe just before the EOF or so.
17:33:32 <kmc> you'd use what you originally had:
17:33:38 <kmc> s [] = 0
17:33:38 <kmc> s (x:xs) = x + s xs
17:33:41 <dmwit> Heffalump: The URLs it works for are mostly coincidences, is what I'm saying.
17:33:48 <engla> kmc: see this is inconsistent.. T_TTTTTT
17:33:51 <kmc> engla, no it's not
17:33:58 <kmc> there's a simple rule, which you haven't learned yet
17:34:06 <kmc> the GHCi prompt is not like a file top level
17:34:12 <kmc> the GHCi prompt is like an IO "do"-block
17:34:29 <kmc> you can do "c <- getChar" in ghci
17:34:34 <engla> yeah I don't know the io do block either what it is .. -- I just want to start learning haskell
17:34:34 <kmc> which you definitely can't do at the top of a file
17:34:41 <kmc> (except in JHC ;)
17:34:57 <kmc> ok engla
17:35:00 <kmc> what are you using to learn?
17:35:09 <engla> I've even developed a really bad mood at this point, all because of this. but I'll try not to harm anyone
17:35:14 <engla> I got a book from a friend
17:35:25 <kmc> which book?
17:35:35 <kmc> we recommend LYAH and RWH
17:35:36 <kmc> @where LYAH
17:35:36 <engla> Programming in haskell   / Graham Hutton
17:35:36 <lambdabot> http://www.learnyouahaskell.com/
17:35:37 <kmc> @where RWH
17:35:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
17:35:49 <kmc> Hutton's book is good too, but if you find it frustrating, check out the others
17:35:55 <engla> ok thanks
17:36:04 <kmc> from skimming LYAH, looks like it's explicit about what you enter into ghci and what you put in a file
17:36:15 <engla> good :-)
17:37:11 <unkanon> engla: if it helps any, I always fight with ghci (and other such tools) so don't let that be an obstacle to your learning
17:37:56 <kmc> Haskell is difficult to learn, and some things won't make sense right away.  but i promise, there's almost always a clean system of rules for understanding what's going on
17:37:58 <Eduard_Munteanu> Don't despair, like kmc suggests, perhaps getting multiple angles is better.
17:38:08 <funkyjunkyrobot> RoAr! haskell!!!!
17:38:26 <engla> should I use ghci or not?
17:38:29 <Andy> Quick question, I am trying to use some functions inside the definition of another function - when I do that individually for just one function it works fine, but when I try to combine them with the dot . which says this, after that, this after that etc then it doesn't work - any idea what I'm missing out?
17:38:40 <funkyjunkyrobot> i'm also trying to learn and ghci is helping alot
17:38:42 <unkanon> engla: i started only using files
17:38:52 <dmwit> Andy: How about pasting some code that you're trying? hpaste.org is nice, for example.
17:38:53 <kmc> Haskell has a much cleaner and more internally consistent language design than any other language i know
17:39:11 <Andy> dmwit, thanks - I will do that then, just a sec :)
17:39:12 <dmwit> Well, cleaner than any other practical programming language.
17:39:53 <kmc> it's remarkable too because (despite popular opinion) Haskell holds a pragmatic, compromise position in the design space
17:42:08 <kmc> engla, what i've always done (from beginning through now) is to write code in files, then load them in ghci and play around with it
17:42:40 <Andy> So hopefully this will make my problem clearer - apologies if it looks like I am doing a completely stupid mistake but I am new to Haskell :) http://hpaste.org/41229/matrix_multiplication
17:42:43 <engla> ok I understant, it seems to work
17:42:51 <kmc> 666 users again
17:43:10 <engla> how do I display a number from a script? just a basic question
17:43:14 <kmc> engla, print
17:43:28 <kmc> engla, but you should avoid IO entirely to start out with
17:43:31 <kmc> that's where ghci is handy
17:43:35 <kmc> Andy, look at the definition of (.):
17:43:36 <kmc> @src (.)
17:43:36 <lambdabot> (f . g) x = f (g x)
17:43:36 <lambdabot> NB: In lambdabot,  (.) = fmap
17:43:48 <dmwit> Andy: Perhaps you meant "dotp (...) . transpose $ yss".
17:44:00 <dmwit> Andy: Though "head xss head yss" looks ill-formed to me, if that's Prelude.head.
17:44:06 <kmc> and also ill-advised
17:44:09 <engla> kmc: ok so IO is hard? maybe that's where my experiments go wrong. I just want to output the result of the calculation
17:44:11 <kmc> as a beginner, pretend "head" does not exist
17:44:17 <kmc> you should pattern-match
17:44:21 <kmc> multMat (x:xs) (y:ys) = ...
17:44:40 <kmc> engla, it's not really hard, just different from what you might know from other languages
17:44:46 <Andy> Alright, thank you very much - I will try fix this then :)
17:44:54 <kmc> you can't just stuff IO effects into any function
17:45:11 <kmc> you have to build and glue together "IO recipes", which are values like any other
17:45:20 <kmc> then eventually you name some recipe "main" and that's what your program does when it's run
17:45:23 <kmc> http://haskell.org/haskellwiki/Introduction_to_IO
17:45:28 <engla> ah ok I'll trust you and wait
17:46:49 <kmc> engla, i started learning from http://www.cs.caltech.edu/courses/cs11/material/haskell/index.html
17:46:52 <kmc> which has some good exercises
17:46:57 <kmc> and doesn't do IO until exercise 4
17:47:04 <kmc> Lab 4
17:47:28 <dmwit> :t (=~)
17:47:29 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
17:47:56 * kmc vomits all over
17:48:26 <ddarius> dmwit: Even it if wasn't Prelude's head, it is self-application rarely works out.
17:48:49 <ddarius> Not just beginners should pretend that head doesn't exist.
17:48:55 <dmwit> Awww, there's only regexen for text? =/
17:49:13 <engla> thanks for the help, now the examples work
17:49:27 <Andy> Well speaking of not using head, is it not appropriate to make use of it when you want to do just one thing to the head and one thing to the tail? Is it not appropriate then? Or is it better to pattern match?
17:49:33 <ddarius> dmwit: Haskerl had arbitrary list regular expressions.
17:49:58 <ddarius> Andy: Why wouldn't you pattern match in that case?
17:50:00 <dmwit> Andy: Sounds like a perfect case for pattern matching.
17:50:11 <pelotom> Andy: it's only appropriate if you absolutely know the list is not empty
17:50:17 <dmwit> Andy: (But probably even better would be to use map, filter, or foldr.)
17:51:42 <Andy> Thanks for the advice - yeah what you all say makes sense. About foldr, I've only started looking at that recently and it's rather confusing but looks very helpful
17:53:33 <eugenn> > :t foldr
17:53:34 <lambdabot>   <no location info>: parse error on input `:'
17:53:59 <eugenn> :t foldr
17:54:00 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
17:54:58 <eugenn> > foldr (+) 0 [1,2,3,4,5]
17:54:59 <lambdabot>   15
17:56:03 <JohnnyL> :t foldr (*) 1 [1,2,3,4,5]
17:56:04 <lambdabot> forall a. (Num a) => a
17:56:04 <dmwit> > foldr (flip (:)) [] [1..5]
17:56:05 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
17:56:31 <eugenn> :t foldl
17:56:32 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
17:56:38 <dmwit> > foldr (\x xs -> xs ++ [x]) [] [1..5]
17:56:39 <lambdabot>   [5,4,3,2,1]
17:56:56 <dmwit> bah, who cares about efficiency ;-)
17:57:30 <Boxo> foldr (#) z [a,b,c] = a # (b # (c # z))
17:58:07 <pelotom> > foldl (\xs x -> x:xs) [] [1..5]
17:58:07 <Boxo> foldr turns (a:(b:(c:[]))) to (a#(b#(c#z)))
17:58:07 <lambdabot>   [5,4,3,2,1]
17:58:08 <kmc> > foldr (+) 0 [a,b,c]
17:58:08 <lambdabot>   a + (b + (c + 0))
17:58:15 <Veinor> foldr replaces : with the operator and [] with z
17:58:34 <dmwit> > foldr f z [a,b,c]
17:58:35 <lambdabot>   f a (f b (f c z))
17:58:36 <pelotom> ?
17:58:45 <pelotom> > foldl (\xs x -> x:xs) [] [1..5]
17:58:45 <lambdabot>   [5,4,3,2,1]
17:58:57 <ezyang> >foldr (#) z [a,b,c] 
17:59:01 <dmwit> \xs x -> x:xs === flip (:)
17:59:05 <ezyang> aw, I broke lambdabot 
17:59:13 <dmwit> ezyang: needs moar space (after the >)
17:59:18 <ezyang> > foldr (#) z [a,b,c] 
17:59:19 <lambdabot>   <no location info>: parse error on input `)'
17:59:26 <ezyang> bah, right, # is not a valid op. 
17:59:32 <ddarius> ezyang: It is.
17:59:44 <ddarius> > let ( # ) = (+) in 3 # 5
17:59:45 <lambdabot>   8
17:59:52 <Boxo> > foldr (+) z [a,b,c]
17:59:53 <lambdabot>   a + (b + (c + z))
17:59:57 <ezyang> classy. 
18:00:13 <dmwit> > let a # s = concat [show a, " # (", s, ")"] in foldr (#) z [a,b,c]
18:00:14 <lambdabot>   <no location info>: parse error on input `)'
18:00:26 <Boxo> > foldr (>^>^>^) z [a,b,c]
18:00:27 <lambdabot>   Not in scope: `>^>^>^'
18:00:39 <ddarius> ezyang: It attempts to match the expression as an unboxed tuple which is why it is surprised by the early closing parenthesis.
18:00:43 <dmwit> > let a # s = concat [show a, " # (", s, ")"] in foldr ( # ) z [a,b,c]
18:00:44 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
18:00:44 <lambdabot>         against inferred ty...
18:00:47 <aristid> :t let (#) = (+) in 1 # 2
18:00:48 <lambdabot> parse error on input `)'
18:00:49 <dmwit> What's up with (#)?
18:00:58 <pelotom> > foldl (flip (:)) [] [1..5]
18:00:58 <aristid> dmwit: it's just not a legal operator
18:00:59 <lambdabot>   [5,4,3,2,1]
18:01:07 <dmwit> aristid: It is, see above.
18:01:12 <ddarius> aristid: Both he and I have demonstrated that it is.
18:01:19 <dmwit> aristid: ( # ) seems fine, but (#) doesn't.
18:01:19 <ddarius> I just explained why it misparses.
18:01:25 <dmwit> ah
18:01:30 <dmwit> I missed that, thanks for pointing it out. =)
18:01:39 <kmc> it's probably valid until you turn on -XMagicHash or -XUnboxedTuples
18:01:41 <BluePeppers> beginner question here, I can't see anything wrong with the code I've written, but i'm getting a type error. Could someone have a look at it please. http://hpaste.org/raw/41230/takewhile
18:01:53 <ddarius> kmc: It's valid even with MagicHash.
18:01:53 <kmc> what's the error BluePeppers
18:02:02 <dmwit> BluePeppers: needs more arguments to takeWhile' on line 3
18:02:08 <kmc> yeah
18:02:18 <BluePeppers> dmwit, ah thanks. Now i feel stupid :)
18:02:27 <kmc> you'll need a [] case too
18:02:33 <kmc> BluePeppers, you might rewrite it as takeWhile' p = go where ...
18:02:37 <dmwit> To be fair, that's probably an "infinite type" error, and I find those particularly unhelpful.
18:02:47 <kmc> then you can use 'p' within the bodies of 'go' without passing it everywhere
18:02:54 <ddarius> dmwit: We could get rid of them...
18:03:00 <dmwit> No, please.
18:03:11 <dmwit> I prefer an unhelpful error to an unhelpful compiler.
18:03:13 <BluePeppers> kmc, I shall look into it
18:04:37 * ddarius doesn't find "infinite type" errors less helpful then others, but then I usually just look at the line number and ignore the error message not because they are bad, they aren't, but simply because I can usually immediately see the error once I know that an error is there.
18:06:37 <aristid> i don't ignore error messages, but often i don't really analyse them, instead taking them as clues as to which kinds of errors have led to that error message in the past
18:08:01 * syntaxglitch has always found GHC's errors to be reasonably straightforward, honestly
18:09:26 <kmc> GHC's suggestions are pretty crap, though
18:10:05 <aristid> syntaxglitch: i learned my error message parsing techniques from C++ with GCC, compared to which GHC's error messages are just wonderful :)
18:10:51 <JohnnyL> http://dpaste.com/271621/
18:11:06 * syntaxglitch buries aristid until fifty pages of cryptic STL template errors
18:11:40 <malouin> I have an installer error when trying to install haskell platform from the .dmg distribution on OS X 10.6.4, the suspicious line in the installer log is blah blah ./postflight: blah blah line 2: /usr/bin/ghc-pkg: No such file or directory
18:11:44 <malouin> what do I do?
18:11:46 <aristid> syntaxglitch: ah, now i suddenly feel at home
18:12:27 <syntaxglitch> aristid, you should try doing some type-level metaprogramming
18:12:33 <aristid> syntaxglitch: i have.
18:12:43 <syntaxglitch> you can get some really awesome errors that way
18:12:50 <aristid> yup
18:12:56 <aristid> or do you mean in haskell?
18:13:04 <syntaxglitch> yeah, I meant in Haskell
18:13:12 <aristid> oh, i have only done that in c++ :)
18:13:22 <syntaxglitch> turn on MPTC, overlapping + undecidable instances, and some other extensions
18:13:28 <syntaxglitch> and start writing program in instance contexts
18:13:32 <kmc> JohnnyL, i isn't of type Ord
18:13:34 <kmc> Ord is not a type
18:13:50 <aristid> syntaxglitch: i have written some pretty complex instance contexts if that counts
18:14:01 <kmc> i is a type variable, which could be instantiated to any of a number of different types.  Ord is a constraint on which types you can instantiate it to
18:14:06 <kmc> "only types with comparison"
18:14:11 <aristid> syntaxglitch: at least complex for me :)
18:14:17 <Eduard_Munteanu> Well just programming in instances doesn't count as type-level programming
18:14:19 <kmc> but terminology aside, i don't understand the question
18:14:23 <syntaxglitch> aristid, probably not as complex as I've written
18:14:34 <aristid> syntaxglitch: haha, virtual penis
18:14:43 <syntaxglitch> it's not something to be proud of :(
18:15:00 <ddarius> syntaxglitch: Actually it is surprising how good the error messages can be in Haskell type level programming.
18:15:09 <Eduard_Munteanu> Technically it counts as such whenever data and computations lie in the type system; i.e. everything is done at compiletime
18:15:21 <kmc> there was a paper on how to do your type-level programming in order to improve error messages
18:15:27 <kmc> Boost has a bunch of such things for C++
18:16:22 * syntaxglitch used the trick of writing error messages as type names, then failing to find an instance for that type to show the error
18:16:23 <Eduard_Munteanu> Could somebody call C++ System F-omega and not be too very far off?
18:16:34 <ddarius> Eduard_Munteanu: No.
18:16:43 <Eduard_Munteanu> I see.
18:16:59 <Eduard_Munteanu> Because there is some resemblance in some advanced C++ features.
18:17:29 <kmc> C++ is almost dependently typed
18:17:30 <pelotom> C++ doesn't have higher-kinded types, does it?
18:17:36 <kmc> pelotom, template templates!
18:17:42 <pelotom> kmc: really?
18:17:43 <kmc> i think you can do that actually
18:17:45 <ddarius> kmc: No more or less than Haskell.
18:17:48 <syntaxglitch> Eduard_Munteanu, and of course programming in instance contexts is type level programming, why wouldn't it be?
18:17:51 <cizra> !seen martijn
18:18:03 <cizra> hmmm, what was the command?
18:18:15 <kmc> ddarius, templates can have value parameters, subject to stage restrictions.  so it's like She or the upcoming GHC features to invisibly lift compile-time data into  the type system
18:18:15 <Eduard_Munteanu> syntaxglitch: I don't really see why.
18:18:30 <aristid> kmc: yeah template templates exist
18:18:42 <syntaxglitch> Eduard_Munteanu, either fundeps or type families basically give you functions from types to types, what more do you want?
18:18:44 <Eduard_Munteanu> So is that purely adhoc dependent typing?
18:18:57 <Eduard_Munteanu> Like "we don't care if it's a consistent, established theory"?
18:18:57 <ddarius> C++ has template templates, but it doesn't have stuff like higher rank types, e.g. you couldn't do something like runST in it.  On the other hand, C++'s template system is very unstructured, powerful but unstructured, and so you can embed polymorphism in it, but it doesn't really represent polymorphism.
18:19:02 <pelotom> wow, I thought java generics were about on par with C++ templates... I was way wrong
18:19:23 <aristid> pelotom: indeed
18:19:23 <Eduard_Munteanu> syntaxglitch: well, not using values in those computations?
18:19:32 <ddarius> kmc: As I said, no more or less than Haskell.
18:19:38 <ddarius> (Which is to say, not at all.)
18:19:40 <malouin> ah, I see.  These are steps in the OS X installation instructions, not three different options.  This was unclear to me.  Thanks!
18:19:52 <Eduard_Munteanu> syntaxglitch: I expect types to be values in type-level programming.
18:19:59 <aristid> ddarius: template<int p> struct p; does not take a value?
18:20:00 <syntaxglitch> Eduard_Munteanu, er, yes, I'm talking about instance contexts.
18:20:09 <Eduard_Munteanu> Ah, then it sounds like it.
18:20:29 <ddarius> aristid: When I can do, cin>>i; p<i> then it will be dependent typing.
18:20:40 <syntaxglitch> Eduard_Munteanu, as in "instance (program goes here ...) => Something Whatever"
18:21:03 <aristid> ddarius: but in haskell i can't even do matrix<4,4>
18:21:05 <Eduard_Munteanu> syntaxglitch: oh, a la TypeEq and HList magic and all that stuff, makes sense now
18:21:27 <ddarius> aristid: Sure you can, you just can't use 4 because that's not valid type syntax.
18:21:42 <ddarius> You can do matrix<D4 DZ, D4 DZ> or some such.
18:21:44 <syntaxglitch> Eduard_Munteanu, yes
18:22:17 <aristid> ddarius: allowing a 4 there would be a useful extension IMO, even if it is not really dependent typing
18:22:47 <ddarius> aristid: Just because C++ templates have a few more base types doesn't make it either a) more expressive than Haskell, or b) dependently typed.  It certainly is convenient I will admit.
18:22:53 <ddarius> But it is fairly minor.
18:23:09 <Eduard_Munteanu> Actually that would be an extension automatically defining all used Peano numbers, right?
18:23:22 <ddarius> You don't want to use Peano numbers.
18:24:07 <kmc> pelotom, yeah, Java generics is much closer to a sane type-erasure implementation of polymorphism with bounded quantification
18:24:14 <Eduard_Munteanu> ddarius: oh, I'm not aware of other representations
18:24:26 <syntaxglitch> Eduard_Munteanu, lists of bits is one obvious way
18:24:27 <ddarius> Eduard_Munteanu: Sure you are.
18:24:33 <kmc> C++ templates are a macro preprocessor that mutated and escaped from the lab
18:24:42 <alpounet> kmc, with that ugly to-Object conversion behind our back
18:24:50 <alpounet> sure, that's sanity
18:24:55 <EvanR> lol
18:24:57 <aristid> Eduard_Munteanu: Integer is a more efficient representation of integers than peano numbers, albeit not at the type-level
18:25:00 <Eduard_Munteanu> But surely C++ isn't dependently typed as in it can't really take runtime values in those templates, only constants I think.
18:25:13 <alpounet> Eduard_Munteanu, it can't take anything from runtime
18:25:41 <alpounet> but passing constants is already quite handy
18:25:46 <Eduard_Munteanu> Though I admit I'm confused about what dependent types really look like.
18:25:52 <alpounet> e.g for <aristid> ddarius: but in haskell i can't even do matrix<4,4>
18:25:57 <pelotom> this discussion reminds me of this Q on SO: http://stackoverflow.com/questions/3181766/how-far-to-go-with-a-strongly-typed-language/3370710#3370710
18:26:01 <Eduard_Munteanu> Is it still statically-typed if it depends on runtime values?
18:26:20 <ddarius> Eduard_Munteanu: Yes.
18:26:31 <pelotom> and makes me think my comment in response to the followup question may have been not completely right
18:27:03 <aristid> pelotom: your comment is right.
18:27:11 <Eduard_Munteanu> ddarius: hm, there must be some catch, must those computations be total in the type system or something?
18:27:16 <aristid> pelotom: there's no way, C++ templates will ever get dependent types
18:27:17 <pelotom> heh, ok
18:27:24 <Eduard_Munteanu> as in provably something?
18:29:47 <Eduard_Munteanu> I'm asking because it seems dependent typing mockups like those used for bounds checking actually offer some guarantees at runtime. If types behaved like ordinary values I assume there would be none.
18:30:22 <Eduard_Munteanu> Ok... slow down...
18:30:39 <zygoloid> aristid: depends what you call a dependent type. they already have non-type template parameters, and with constexpr in c++0x that might apply to lots of types soon
18:31:28 <ddarius> If you consider things that aren't dependent types to be dependent types, then you are free.
18:31:31 * hackagebot pureMD5 2.1.0.3 - A Haskell-only implementation of the MD5 digest (hash) algorithm.  http://hackage.haskell.org/package/pureMD5-2.1.0.3 (ThomasDuBuisson)
18:31:51 <aristid> zygoloid: ddarius very much insists that that is not dependent typing, and i'm sure he is right about that.
18:32:06 <alpounet> he is
18:32:12 <alpounet> but that's not *that* far
18:32:33 <alpounet> and it opens some quite nice possibilities
18:33:07 <syntaxglitch> trickery involving compile-time computations with things that look like values, but where all types are known before run-time, have nothing to do with dependent types
18:33:46 <unkanon2> i'm trying to wrap my head around the way types (and modules?) work in haskell i guess. how can Either and Maybe and [] etc all have different fmap's?
18:33:51 <Eduard_Munteanu> syntaxglitch: I see.
18:34:02 <aristid> syntaxglitch: heh you could run the compiler each time you have a value and want a type for it :D
18:34:12 <Eduard_Munteanu> unkanon2: there's a Functor instance for each
18:34:26 <syntaxglitch> aristid, that would be something like staged compilation, take a look at MetaOCaml
18:34:33 <syntaxglitch> it's actually a neat idea
18:35:09 <unkanon2> Eduard_Munteanu:  but how does the compiler know which fmap i'm calling? how is the scope acting there? is it somewhat OO-ish?
18:35:18 <Eduard_Munteanu> I'm a bit baffled how dependent types are supposedly useful in proof systems and such stuff, if they have anything to do with runtime.
18:35:30 <aristid> syntaxglitch: type-safe eval
18:35:32 <Eduard_Munteanu> unkanon2: suppose you call fmap on something.
18:35:34 <pelotom> C++ already has staged compilation :)
18:35:46 <aristid> pelotom: but not the way syntaxglitch means
18:35:55 <Eduard_Munteanu> unkanon2: that something has a type, which in turn is an instance of Functor.
18:35:58 <unkanon2> c++ is dead, people, just let it die ;)
18:36:08 <zygoloid> aristid: sure, c++ doesn't have dependent types today (nor in 0x), but i think it's shortsighted to say it will definitely never have them
18:36:10 <aristid> unkanon2: it is not dead and it will not be dead anytime soon.
18:36:15 <pelotom> Eduard_Munteanu: with dependent types, you maybe don't know exactly what you'll get, but you can prove certain properties about what you'll get
18:36:35 <aristid> zygoloid: it would just be against the most fundamental principles of c++ (yes, they exist)
18:36:50 <unkanon2> aristid: it ain't growing either :/ (as a community)
18:37:15 <isaacd> Who knows something about trac.haskell.org, which has been down for maybe a day? It has haskell-platform information I want to access. (dons?)
18:37:15 <unkanon2> Eduard_Munteanu: so the right fmap will be chosen depending on the arguments passed to it?
18:37:17 <aristid> unkanon2: sure, but that's different from dying
18:37:19 <zygoloid> unkanon2: there are plenty of industries where it's not showing any signs of shrinking either
18:37:26 <pelotom> Eduard_Munteanu: and they don't have anything to do with runtime... the dependent propositions can in fact be thrown out before runtime
18:37:30 * ddarius agrees with aristid about dependent typing in C++.
18:37:37 <Eduard_Munteanu> unkanon2: yes, of course.
18:37:40 <unkanon2> zygoloid: oh i'd never deny that
18:38:08 <pelotom> sorry, the terms proving dependent propositions can be thrown out
18:38:09 <unkanon2> Eduard_Munteanu: is it fair if I compared that to overloading a function (fmap in this case?)
18:38:17 <syntaxglitch> dependent types would interfere with the ability to write segfaults and buffer overruns, thus violating a core principle of C++
18:38:21 <Eduard_Munteanu> unkanon2: somewhat.
18:38:29 <aristid> syntaxglitch: yes, that's basically it ;)
18:38:54 <zygoloid> they'd obviously need to be optional, error-prone and feel bolted-on
18:39:02 <unkanon2> Eduard_Munteanu: ok, I want to make sure I'm on the right track.
18:39:02 <Eduard_Munteanu> unkanon2: but Haskell has no adhoc overloading like in C++
18:39:06 <isaacd> C++ could have dependent types as yet another feature that you can OPTIONALLY use! (because of zero-overhead principle "you only pay for what you use)
18:39:06 <pelotom> zygoloid: haha
18:39:19 <JohnnyL> kmc: thats fine. But you just gave me an answer that has nothing to do with the question.
18:39:23 <Eduard_Munteanu> Though type families do something like that AFAICT
18:39:26 <aristid> i have this tendency to write type classes with only a single function. is that a sign of poor design? :)
18:39:29 <unkanon2> Eduard_Munteanu: right, it's all resolved in compile time, is that what you mean?
18:39:32 <isaacd> it would be like "some classes are dependent" or something funny like that.
18:39:41 <isaacd> (templates, or so)
18:40:05 <Eduard_Munteanu> unkanon2: the specific fmap code is figured out at compile-time, yeah
18:40:27 <Eduard_Munteanu> unkanon2: because the type of the argument is always figured during compilation.
18:40:56 <unkanon2> Eduard_Munteanu: ok, that i knew, i just didn't know that "which" fmap was chosen based on the type of the argument
18:41:26 <aristid> isaacd: the "you only pay for what you use" principle is part of why there are still some niches where c++ reigns
18:41:27 <unkanon2> Eduard_Munteanu: because , for instance, the type of "return" is not chosen based on the type of the argument
18:41:29 <kmc> JohnnyL, in fact I said that i didn't understand your question
18:41:36 <ddarius> aristid: You could use Clean.
18:41:46 <isaacd> aristid: yes.
18:41:47 <pelotom> unkanon2: it is
18:41:56 <ddarius> Actually, I could see C++ getting something simply like DML, potentially by accident.
18:41:56 <Eduard_Munteanu> unkanon2: why not?
18:41:57 <pelotom> unkanon2: well, not on the type of the argument
18:42:09 <pelotom> unkanon2: it's chosen based on the context in which you use it
18:42:10 <unkanon2> Eduard_Munteanu: because of this:
18:42:17 <unkanon2> > return 9 :: [] Int
18:42:17 <lambdabot>   [9]
18:42:19 <Eduard_Munteanu> The compiler can always figure out the monad.
18:42:21 <JohnnyL> kmc: then why did you attempt to answer it?
18:42:23 <unkanon2> > return 9 :: [] Maybe
18:42:24 <lambdabot>   `Data.Maybe.Maybe' is not applied to enough type arguments
18:42:24 <lambdabot>  Expected kind `...
18:42:33 <unkanon2> > return 9 :: Maybe Int
18:42:33 <kmc> JohnnyL, i didn't
18:42:33 <lambdabot>   Just 9
18:42:36 <aristid> ddarius: well there are other reasons why c++ continues being used for, say, game engines (at least the core)
18:42:39 <pelotom> @t return 9
18:42:39 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:42:41 <Eduard_Munteanu> unkanon2: '::' is not some sort of cast, it is a type annotation.
18:42:42 <unkanon2> Eduard_Munteanu: so i passed 9 to both returns
18:42:49 <JohnnyL> kmc: you wasted my time and your time.
18:42:52 <pelotom> @type return 9
18:42:53 <lambdabot> forall t (m :: * -> *). (Num t, Monad m) => m t
18:42:55 <kmc> great have a nice day
18:42:57 <unkanon2> Eduard_Munteanu: it's the same argument but a different return was picked
18:43:00 <Eduard_Munteanu> unkanon2: except the compiler used different returns just because of your annotation.
18:43:10 <zygoloid> mm, most likely if c++ gets dependent types it'll be an unintended consequence of some other interesting design decision, like the nonsense of template metaprogramming
18:43:15 <Eduard_Munteanu> unkanon2: no it isn't
18:43:34 <kmc> JohnnyL, i explained that your terminology was wrong, in hopes that it would help you ask a better question
18:43:36 <unkanon2> Eduard_Munteanu: it's not the same 9 being passed to return?
18:43:37 <kmc> i don't think that's a waste of time
18:43:40 <kmc> it happens here a lot
18:43:49 <aristid> zygoloid: heh, like, c++ now gets eval, and by incidence you can hack dependent types into that
18:43:52 <ddarius> aristid: I'm not arguing that C++ is dying.
18:44:10 <Eduard_Munteanu> unkanon2: the whole expression is different wrt types
18:44:19 <JohnnyL> kmc: well, in that case... How do you determine the class constraint of any part of a function?
18:44:26 <kmc> determine from what information?
18:44:26 <aristid> ddarius: then we have no disagreement, awesome.
18:44:28 <Eduard_Munteanu> unkanon2: and that's what matters, since return :: a -> m a
18:44:36 <JohnnyL> kmc: yes. thats what I asked.
18:44:37 <ddarius> aristid: I used C++ for many years and still reach for it upon occasion.
18:44:47 <kmc> JohnnyL, then i will give a smartass answer and you should explain why it's incorrect:
18:44:50 <kmc> use :t within ghci
18:44:52 <kmc> to get the type
18:44:55 <ddarius> C++ is probably in my top 5 favorite languages.
18:44:55 <kmc> that determines the class constraint
18:44:59 <Eduard_Munteanu> unkanon2: the monad in question depends on whether it's Maybe or []
18:45:03 <JohnnyL> kmc: are you a newb?
18:45:07 <kmc> C++ is my #1 favorite esolang.  it's so beautiful that nobody gets the joke
18:45:07 <unkanon2> Eduard_Munteanu: but all I'm trying to understand is, how is the right return being chosen? not based on the argument, right? then based on what?
18:45:10 <kmc> JohnnyL, no
18:45:20 <JohnnyL> kmc: fell when a child?
18:45:27 <pelotom> unkanon2: based on the full context in which you are using it
18:45:28 <kmc> smoked lots of crack
18:45:30 <zygoloid> JohnnyL: your question is unclear. please be polite.
18:45:32 <Eduard_Munteanu> unkanon2: based on the whole expression.
18:45:46 <JohnnyL> zygoloid: go read a book.
18:45:52 <kmc> ahem
18:45:57 <kmc> JohnnyL, determine from what information?
18:46:01 <kmc> from the source code?
18:46:06 <JohnnyL> kmc: you didn't see my paste?
18:46:07 <kmc> from having the program loaded in ghci?
18:46:07 <kmc> what
18:46:16 <kmc> this one http://dpaste.com/271621/ ?
18:46:17 * EvanR loads JohnnyR for balance
18:46:20 <Eduard_Munteanu> unkanon2: if I say return 5 :: [] Int, the compiler knows m is [] and a is Int.
18:46:22 <unkanon2> Eduard_Munteanu: ok, and is the right fmap also chosen based on the whole expression or just the argument passed to it?
18:46:41 <Eduard_Munteanu> unkanon2: therefore the Monad instance that applies is the one for []
18:46:46 <kmc> JohnnyL, none of us understand your question.  i'm sorry that we're all stupid.  you should try to re-ask it in different terms, instead of getting angry
18:46:49 <orlandu63> i think johnnyr is trolling. he was being rude in #snapframework as well.
18:46:53 <kmc> ok cool
18:47:01 <ddarius> EvanR: Does JohnnyR have the sense not to be insulting to the people from which he is asking help?
18:47:08 <JohnnyL> orlandu63: explain that.
18:47:13 <Eduard_Munteanu> :t fmap
18:47:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:47:20 <orlandu63> JohnnyL: no
18:47:27 <JohnnyL> orlandu63: why not?
18:47:39 <kmc> this is about to become bs personal drama
18:47:41 <Eduard_Munteanu> unkanon2: as you can see fmap's arguments provide all that's needed to infer types.
18:47:41 <JohnnyL> orlandu63: i wanted them that alchohol was bad for them.
18:47:47 <EvanR> ddarius: he insults at the end rather than the beginning
18:47:51 <JohnnyL> 'to know'
18:48:02 <Eduard_Munteanu> unkanon2: the result's type can easily be inferred by the compiler from that
18:48:19 <unkanon2> Eduard_Munteanu: that I understand
18:48:25 <JohnnyL> orlandu63: Explain yourself or go away.
18:48:26 <unkanon2> Eduard_Munteanu: i guess what I don't understand is, what if I wanted to use return in the middle of a function, how would I tell the compiler which one I want (from which monad)?
18:48:26 <Eduard_Munteanu> unkanon2: compare that with 'return :: a -> m a': given an argument of type a, what monad are we talking about?
18:48:43 <unkanon2> Eduard_Munteanu: monad m
18:48:53 <kmc> JohnnyL, orlandu63 how about you take this personal fight out of the channel?
18:48:53 <Eduard_Munteanu> unkanon2: either the function's type signature makes some sense of it, or you really need a signature on that expression
18:49:05 <JohnnyL> kmc: ok
18:49:17 <pelotom> unkanon2: you tell the compiler which one you want by how you use it... and if it needs more help you can give specific type ascriptions (:: Foo) to help it
18:49:22 <unkanon2> Eduard_Munteanu: oh! so I can put signatures on expressions? I didn't know that, that makes a lot more sense
18:49:54 <Eduard_Munteanu> unkanon2: for example, say you have f :: String -> IO String, f x = return (x ++ "foo")
18:49:55 <EvanR> suddenly orlandu63 and JohnnyL get into a brawl resulting in one of them flying out of a shattering window near the front door to #haskell
18:50:12 <JohnnyL> EvanR: hahaha
18:50:13 <Eduard_Munteanu> unkanon2: it's obvious here what monad 'm' in return refers to.
18:50:31 <pelotom> @type defenestrate
18:50:32 <lambdabot> Not in scope: `defenestrate'
18:50:56 <unkanon2> Eduard_Munteanu: it's obvious to me that it's String
18:51:00 <unkanon2> Eduard_Munteanu: but...
18:51:06 <Eduard_Munteanu> unkanon2: it's IO
18:51:13 <unkanon2> Eduard_Munteanu: what if instead of x ++ "foo" there you had x ++ y ?
18:51:36 <Eduard_Munteanu> unkanon2: simple, take it from the definitions...
18:51:41 <Eduard_Munteanu> @src Monoid
18:51:41 <lambdabot> class Monoid a where
18:51:41 <lambdabot>     mempty  :: a
18:51:41 <lambdabot>     mappend :: a -> a -> a
18:51:41 <lambdabot>     mconcat :: [a] -> a
18:51:53 <Eduard_Munteanu> unkanon2: x ++ y :: String
18:52:09 <zygoloid> @type (Prelude.++)
18:52:10 <pelotom> @type let {x = undefined; y = undefined} in x ++ y
18:52:10 <lambdabot> forall a. [a] -> [a] -> [a]
18:52:11 <lambdabot> forall a. (Monoid a) => a
18:52:21 <Eduard_Munteanu> unkanon2: return some_string :: m String, but since we know m is IO from f's type sig, the result is IO String.
18:52:56 <Eduard_Munteanu> (++) is mappend
18:53:09 <Eduard_Munteanu> So there's no difference.
18:53:19 <Eduard_Munteanu> The point is if x is a String, y has to be too.
18:53:21 <zygoloid> Eduard_Munteanu: only in Caleskell
18:53:48 <Eduard_Munteanu> :t (++)
18:53:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
18:53:58 <Eduard_Munteanu> zygoloid: grr yeah, but I'm not referencing that.
18:54:02 <zygoloid> @type (Prelude.++)
18:54:03 <lambdabot> forall a. [a] -> [a] -> [a]
18:54:43 <Eduard_Munteanu> unkanon2: the bottom line is, f's type sig already tells the type. There are cases when that doesn't happen, and then you must annotate your values.
18:54:53 <aristid> the nice thing about the caleskell version of (++) is that you can derive it for newtypes
18:55:05 <unkanon2> Eduard_Munteanu: ok let me go over that a bit. i appreciate the help. gotta go nowhave dinner with the wife. thanks!
18:55:29 <EvanR> is there some sense in which return for monads must 'do nothing' ?
18:55:35 <EvanR> is there some sort of identity law
18:55:38 <aristid> on a related note, String _should_ be a newtype around lists instead of a type synonym :)
18:55:41 <zygoloid> aristid: yeah. i think http://hackage.haskell.org/trac/ghc/ticket/3339 is a good compromise here
18:55:56 <pelotom> EvanR: it means "do nothing to the pure value"
18:56:07 <pelotom> just embed it in the context
18:56:07 <Eduard_Munteanu> aristid: I kinda agree with that.
18:56:37 <EvanR> pelotom: well doing thing only seems to make sense in context of combining monadic actions with >> or >>=
18:56:46 <funkyjunkyrobot> w00t finaly got my isOval done :)
18:56:47 <Eduard_Munteanu> I wonder if it's possible to make GHC not expand type synonyms in error messages.
18:57:18 <Eduard_Munteanu> EvanR: I think so.
18:57:20 <EvanR> > "string" + "number"
18:57:21 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
18:57:21 <lambdabot>    arising from a use of `GH...
18:57:23 <Eduard_Munteanu> the first monad axiom
18:57:27 <EvanR> hrm thats supposed to say String
18:57:30 <EvanR> Eduard_Munteanu: ah
18:57:36 <funkyjunkyrobot> if anyone wants to see it and give me some advice i'd be all ears, i can send u the hpaste in a message so as to not post possible solutions on here
18:57:37 <pelotom> EvanR: exactly... it means it's an identity with respect to bind
18:58:14 <EvanR> return a >>= f === f a
18:58:18 * EvanR contemplates
18:58:23 <kmc> EvanR, the monad laws are clearest in terms of (>=>)
18:58:34 <kmc> f >=> return  ≡  return >=> f  ≡  f
18:58:46 <pelotom> kmc: yes
18:58:49 <pelotom> that
18:58:49 <kmc> (a >=> b) >=> c  ≡  a >=> (b >=> c)
18:59:07 <EvanR> :t (>=>)
18:59:07 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
18:59:09 <JohnnyL> what part(s) of a function determine what the class contraints of said function are?
18:59:17 <Eduard_Munteanu> I think only the third law makes a real difference in terms of Kleisli arrow compositions.
18:59:17 <kmc> iow, when types match, (>=>) is an associative operator, and 'return' is its identity
18:59:29 <aristid> @src (>=>)
18:59:30 <lambdabot> Source not found. You untyped fool!
18:59:32 <kmc> which is the same as saying that m is a monad if (Kleisli m) is a category
18:59:38 <aristid> lambdabot: no, YOU are the untyped fool
18:59:39 <alpounet> JohnnyL, the functions it calls
19:00:01 <djahandarie> aristid, on the type level ;)
19:00:04 <pelotom> iow, monads form a category where objects are types and arrows are (>=>)
19:00:04 <kmc> newtype Kleisli m a b = Kleisli (a -> m b); instance Category (Kleisli m) where { id = return; (.) = (<=<) }
19:00:13 <alpounet> JohnnyL, look :
19:00:15 <aristid> djahandarie: ?
19:00:19 <alpounet> :t \a b -> a + b
19:00:20 <lambdabot> forall a. (Num a) => a -> a -> a
19:00:22 <JohnnyL> alpounet: yeah, but how do you determine?
19:00:26 <kmc> JohnnyL, how you use the values
19:00:27 <djahandarie> aristid, she's untyped on the type level
19:00:29 <alpounet> JohnnyL, here, i use "+"
19:00:32 <kmc> for example, if the body of my function calls 'show' on 'x'
19:00:33 <JohnnyL> Yes, I'm quite familiar with :t
19:00:34 <alpounet> and "+" is part of the Num typeclass
19:00:38 <kmc> then it will have a Show constraint on x's type
19:00:53 <EvanR> this suggests a certain form return could possible take
19:00:58 <JohnnyL> alpounet: beautiful thanks!
19:00:58 <EvanR> for a given monad
19:01:12 <alpounet> JohnnyL, that way, it infers the type 'a' must implement the Num typeclass
19:01:15 <aristid> kmc: when people say Monads are Monoids, do they mean that mzero = return and mappend = (>=>)?
19:01:22 <alpounet> just because i use "+"
19:01:42 <EvanR> if you restrict all the monadic actions to a single type
19:01:45 <JohnnyL> alpounet: how does it determine a series of class constraints?
19:01:47 <kmc> aristid, "a monad is a monoid object in the category of endofunctors"
19:01:52 <pelotom> monads are monoids in the category of endofunctors :)
19:01:55 <copumpkin> aristid: no, but that also works
19:02:04 <alpounet> JohnnyL, every single time you'll use a fonction declared in a typeclass, it will add a typeclass constraint
19:02:18 <alpounet> it basically does this for all the functions you call withing a function
19:02:22 <aristid> kmc: the problem with that explanation is that i have no clue what it means
19:02:23 <alpounet> within*
19:02:34 <JohnnyL> alpounet: wow, interesting.
19:02:41 <alpounet> JohnnyL, example :
19:02:41 <kmc> aristid, right, i'm getting there 
19:02:49 <kmc> but first i have to remind myself what the category of endofunctors is
19:02:51 <alpounet> :t \a b -> show $ a+b
19:02:52 <lambdabot> forall a. (Num a) => a -> a -> String
19:03:02 <kmc> the objects of the category of endofuctors are endofunctors?
19:03:03 <alpounet> hm
19:03:07 <alpounet> Num implies show
19:03:09 <alpounet> bad example
19:03:10 <kmc> and the morphisms are natural transformations, i guess
19:03:21 <alpounet> ok JohnnyL see this :
19:03:23 <pelotom> kmc: yes
19:03:33 <EvanR> what happens if you define a Monad instance where return doesnt do nothing
19:03:48 <alpounet> :t \a b -> (show a, a == b) -- JohnnyL 
19:03:49 <lambdabot> forall a. (Show a, Eq a) => a -> a -> (String, Bool)
19:03:55 <pelotom> and functor composition is the monoidal operator of the category
19:04:04 <aristid> EvanR: return never does anything, it's just a value :)
19:04:04 <kmc> anyway a monoid object of a category C is an object M together with morphisms μ : M × M → M and η : 1 → M
19:04:07 <djahandarie> Didn't maclane say something like that?
19:04:08 <Eduard_Munteanu> EvanR: I'm not sure that's valid Haskell, it would look like a data without constructor
19:04:09 <alpounet> JohnnyL, here I call "show", which is declared in the "Show" typeclass
19:04:11 <alpounet> and ==
19:04:12 <pelotom> http://stackoverflow.com/questions/3870088/a-monad-is-just-a-monoid-in-the-category-of-endofunctors-whats-the-problem
19:04:15 <alpounet> which is declared in the Eq typeclass
19:04:28 <Eduard_Munteanu> EvanR: if return = id.
19:04:33 <djahandarie> ... guess he did
19:04:42 <alpounet> JohnnyL, it just basically infers "hey, it uses these two stuffs, so the type must implement both typeclasses"
19:04:54 <Eduard_Munteanu> EvanR: plus it's an infinite type a = m a
19:05:02 <EvanR> were missing the heuristic context where monadic values are considered to do something ;)
19:05:32 <EvanR> return could definitely do something
19:05:47 <kmc> aristid, so then let C = the category of endofunctors
19:05:53 <EvanR> consider a Writer where return appended undefined to the accumulator
19:06:06 <alpounet> JohnnyL, got it ?
19:06:07 <JohnnyL> alpounet: really appreciate that. Now it makes sense!
19:06:16 <alpounet> ok, great :)
19:06:17 <Eduard_Munteanu> EvanR: I think so. But (>>=) / join should do the opposite transformation in a sense.
19:06:23 <kmc> err, i wrote × above
19:06:23 <JohnnyL> alpounet: yeah. thanks again.
19:06:30 <kmc> but i didn't mean the cartesian product
19:06:33 <kmc> or i thought i did, but that's wrong
19:06:40 <kmc> i meant the operation of the category C
19:06:45 <kmc> i think?
19:06:49 <kmc> now i'm confused again
19:07:01 <Eduard_Munteanu> I think some sort of UMP makes sense for monads.
19:07:08 <pelotom> kmc: right, it's the monoidal operator of a monoidal category... which in the case of Set is cartesian product
19:07:09 <EvanR> UMP?
19:07:20 <Eduard_Munteanu> Universal Mapping Property.
19:07:24 <pelotom> kmc: in the case of Endo(C) it's functor composition
19:07:38 <Eduard_Munteanu> as in some sort of UMP is expressed by monad laws.
19:08:01 <Martty> hmm monads as endofunctors have an annoying resemblance to lineal transformations
19:08:25 <aristid> kmc: if i understand stack overflow right, the parallel is between mappend :: a -> a -> a and join :: a (a x) -> a x
19:08:40 <Veinor> hm. so, if i have a function that corresponds to an API call with optional parameters
19:08:46 <aristid> kmc: so the × is (->) in one case and ... type composition in the other
19:08:53 <Veinor> how should I handle that. a [(String, String)] of key/value pairs
19:08:54 <Veinor> ?
19:09:25 <pelotom> aristid: × is cartesian product for set monoids and functor composition for monads
19:09:27 <zygoloid> aristid: it helps if you think of uncurry mappend :: (a, a) -> a
19:09:40 <EvanR> if >>= involves some sort of combination operation like mappend in writer... it means return must involve the identity element such as mempty
19:09:48 <aristid> zygoloid: ack.
19:09:48 <zygoloid> and const mempty :: () -> a ;)
19:10:00 <JohnnyL> alpounet: In the samlle I pasted.. Ord is constrained by the <= operation and Num is added to the constraint by the n-1 operation.
19:10:03 <JohnnyL> sample
19:10:24 <alpounet> can you give me the link please ?
19:10:32 <pelotom> it's confusing because there are 2 levels of monoids at work... a monoidal object lives in a monoidal category
19:10:43 <JohnnyL> zygoloid: thats looks like a four eyed fish with a twisted vagina.
19:10:50 <pelotom> http://en.wikipedia.org/wiki/Monoid_(category_theory)
19:11:02 <JohnnyL> posing in front of a flower! hahahaha
19:11:57 <monochrom> teach a man a fish...
19:12:04 <JohnnyL> http://dpaste.com/271653/
19:13:05 <Eduard_Munteanu> JohnnyL: not all Num's are literal numbers.
19:13:21 <Eduard_Munteanu> :t (<=)
19:13:21 <lambdabot> forall a. (Ord a) => a -> a -> Bool
19:13:35 <aristid> so haskell's monoid is much much too specific for category theorists?
19:13:46 <JohnnyL> Eduard_Munteanu: thanks. I'm sure there is more with Integral, Integer, Int, Num, etc etc ,etc.
19:13:48 <Eduard_Munteanu> if the first a is some random Num, then then the second a must be the same random Num.
19:13:52 <syntaxglitch> everything is too specific for category theorists
19:13:58 <pelotom> aristid: just a little too specific :)
19:14:02 <syntaxglitch> making things less specific is pretty much what category theory is about
19:14:05 <kmc> maybe http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Monoidal.html aristid
19:14:06 <Eduard_Munteanu> JohnnyL: yeah, but don't mix types with typeclasses.
19:14:15 <Eduard_Munteanu> JohnnyL: Num is a typeclass, Int is a type.
19:14:17 <kmc> Eduard_Munteanu, careful, he already bit my head off for saying that
19:14:26 <kmc> now i've got to wait for a new one to grow back
19:14:27 <JohnnyL> Eduard_Munteanu: oh ok
19:14:28 <Eduard_Munteanu> :)
19:14:28 <kmc> very time consuming process
19:14:35 <pelotom> this explains the connection nicely in terms of haskell: http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html
19:15:08 <Eduard_Munteanu> JohnnyL: typeclasses denote a collection of types
19:15:19 <Eduard_Munteanu> (colloquialy)
19:15:46 <syntaxglitch> anyway, the monoid operation in join is basically the same as the one for (a -> a), except for the type constructor (m :: * -> *), isn't it?
19:15:55 <Eduard_Munteanu> JohnnyL: the bottom line is you can't compare n with 0.
19:15:59 <pelotom> syntaxglitch: I think cat theory is about making things only as specific as they need to be, and never more... very similar to haskell :)
19:16:00 <JohnnyL> Eduard_Munteanu: Don't you mean soliloquy?
19:16:24 <Eduard_Munteanu> JohnnyL: because n could be any Num, while 0 is a certain Num
19:16:33 <EvanR> :t 0
19:16:34 <lambdabot> forall t. (Num t) => t
19:16:36 <EvanR> wrong! ;)
19:16:37 <Eduard_Munteanu> @wn soliloquy
19:16:38 <lambdabot> *** "soliloquy" wn "WordNet (r) 2.0"
19:16:38 <lambdabot> soliloquy
19:16:38 <lambdabot>      n 1: speech you make to yourself [syn: {monologue}]
19:16:38 <lambdabot>      2: a (usually long) dramatic speech intended to give the
19:16:38 <lambdabot>         illusion of unspoken reflections
19:16:41 <ddarius> Actually, monads are not usually described by universal properties.  There are ways to, but they are very abstract and indirect.  Monads are not unique in the typical settings one works in.
19:16:51 <Eduard_Munteanu> Mm, no.
19:16:56 <aristid> kmc: i can't translate idl and idr to mempty and mappend
19:17:28 <pelotom> ddarius: I've been curious if adjunctions in and of themselves have any useful applications in programming
19:17:29 <sina> Guys, is there any way to trace what happens in prelude?
19:17:46 <ddarius> pelotom: Sure.
19:18:22 <Eduard_Munteanu> :t idl
19:18:23 <lambdabot> Not in scope: `idl'
19:18:43 <Eduard_Munteanu> Hm I actually thought for a second there would be a grupoid typeclass :)
19:19:43 <pelotom> ddarius: example?
19:19:54 <ddarius> classs (Category hom) => Groupoid hom where iso :: hom a b -> hom b a, that would be tricky to actually instance though.
19:20:45 <ddarius> Er a -> b -> (hom a b, hom b a) might be more correct and explicit
19:21:15 <sina> I have this code which is supposed to get numbers a, b, c and if c gets more than 25 it make c 0 and add 1 to b and same for b. can anyone find why its not working ? :(
19:21:18 <sina> http://hpaste.org/41233/
19:22:00 <ddarius> pelotom: It depends on what level you want to apply them.  Certainly they are useful in formal computer science.  More practically, you can make an Adjunction type class, but it is only mildly useful since most adjunctions (even limited to one's that would be relevant) require having more interesting categories which is awkward or impossible in Haskell.
19:22:15 <ddarius> We use specific cases of adjunction all the time, e.g. curry/uncurry.
19:22:42 <ddarius> Then there's Burstall's "Computational Category Theory" which shows another perspective that is more useful but less elegant.
19:22:48 <pelotom> ddarius: right, plus every adjunction gives rise to a monad, so in a lot of cases you'll just use that
19:22:58 <ddarius> pelotom: No.
19:23:02 <Eduard_Munteanu> ddarius: gr, I think it's really tricky after all... do groupoids even have unique idl and idr? I don't think so. They're only closed under the operation.
19:23:08 <pelotom> no?
19:24:08 <EvanR> @src Read
19:24:08 <lambdabot> class Read a where
19:24:08 <lambdabot>   readsPrec    :: Int -> ReadS a
19:24:08 <lambdabot>   readList     :: ReadS [a]
19:24:08 <lambdabot>   readPrec     :: ReadPrec a
19:24:08 <lambdabot>   readListPrec :: ReadPrec [a]
19:24:21 <ddarius> pelotom: Every adjunction gives rise to a comonad too, why would we "just use the monad" rather than "just use the comonad."  An adjunction is more informative than a monad or comonad; more flexible, and more fundamental.
19:24:22 <Eduard_Munteanu> As far as I could tell, associativity was required for at least idl = idr = unique
19:24:39 <ddarius> And at any rate, an adjunction and a monad are different things.
19:25:01 <Eduard_Munteanu> Um and yeah, no guarantee there exist those ids.
19:25:20 * Eduard_Munteanu guesses it's not much use after all :/
19:25:29 <sina> Guys, I have this code which is supposed to get numbers a, b, c and if c gets more than 25 it make c 0 and add 1 to b and same for b. can anyone find why its not working ? :( http://hpaste.org/41233/ (it works for only c and not b)
19:25:43 <ddarius> The curry/uncurry adjunction gives rise to the state monad, but we don't (and couldn't) use the state monad to curry and uncurry things.
19:25:57 <pelotom> ddarius: I suppose so, but it seems less wieldy to work with in, for example, haskell's type system
19:26:51 <Eduard_Munteanu> @src Category
19:26:51 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
19:27:24 <Eduard_Munteanu> @hoogle Category
19:27:24 <lambdabot> module Control.Category
19:27:24 <lambdabot> Control.Category class Category cat
19:27:24 <lambdabot> Data.Char data GeneralCategory
19:27:37 <pelotom> I haven't tried writing code using haskell's Category package, do people find it useful?
19:27:54 <aristid> pelotom: do you mean category-extras?
19:28:01 <pelotom> aristid: yeah
19:28:19 <aristid> pelotom: i think only very very few people use it
19:28:47 <Eduard_Munteanu> Control.Category and category-extras are different.
19:28:58 <aristid> i wish there was a tool for hackage to make queries like "list packages depending on category-extras"
19:29:05 <aristid> Eduard_Munteanu: sure, the former is in base
19:30:11 <syntaxglitch> aristid, http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/category-extras-0.53.5
19:30:18 <syntaxglitch> someone else wished for the same tool
19:30:23 <syntaxglitch> and then created it
19:30:54 <ddarius> pelotom: While category-extras is reasonably powerful, it is almost completely unusable.
19:30:56 <pelotom> so it's used by FRP
19:31:25 <pelotom> ddarius: is that a limitation of the library or the language?
19:31:31 <aristid> syntaxglitch: pretty short list. but a very cool tool :)
19:31:42 <aristid> pelotom: at least partially of the library
19:31:45 <Eduard_Munteanu> I think it's a limitation of patience.
19:31:49 <ddarius> pelotom: Neither, really.
19:31:54 <Eduard_Munteanu> WTH knows about Yoneda's lemma anyway? :P
19:32:03 <ddarius> Though limitations of the language do make it worse than it needs to be.
19:32:08 <Eduard_Munteanu> Still it's in category-extras.
19:32:13 <pelotom> Eduard_Munteanu: not me... it's on my mental list of Things To Learn About though :)
19:32:17 <ddarius> Eduard_Munteanu: Yoneda's lemma is simple and -very- useful.
19:32:29 <sina> Can anyone help me with a code problem? :(
19:32:51 <Eduard_Munteanu> Don't get me wrong, I have a vague idea about it, but not much.
19:33:18 <dmwit> sina: You're calling (head rest). Is there any reason for you to believe that rest will definitely have a head?
19:33:32 <ddarius> While Yoneda's lemma is very important for a varienty of things, a corollary of it is used essentially constantly by categorists.
19:34:02 <sina> dmwit: I guess. cause otherwise it would match the pattern above. right?
19:34:16 <dmwit> sina: no
19:34:24 <sina> dmwit: right :D
19:34:43 <Eduard_Munteanu> How should I look at Control.Category? I'm still a bit puzzled by the typeclass.
19:34:44 <ddarius> That the Yoneda embedding is full and faithful lets you prove A ~ B from Hom(C, A) ~ Hom(C, B) (natural in C) which is how many categorical derivations go.
19:34:46 <sina> dmwit: I'm not getting any error. just that its not working fine for the second argument
19:35:08 <dmwit> sina: "rest" is not matched against any pattern anywhere. Why would you think it will match against the pattern above?
19:35:13 <sina> dmwit: its supposed to turn (1,25,25) to (2,0,0)
19:35:19 <kmc> Eduard_Munteanu, the constraint (Category (~>)) says that (~>) is the type constructor for morphisms in some category
19:35:33 <kmc> the objects of that category are Haskell types; you can't change this with the base Control.Category
19:35:41 <kmc> id :: a ~> a
19:35:42 <dmwit> sina: I understand what you tried to do, what you've done, and what you should have done. I'm trying to point you at your error. =)
19:35:50 <kmc> (.) :: (b ~> c) -> (a ~> b) -> (a ~> c)
19:36:11 <Eduard_Munteanu> kmc: I don't see anything like that there: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Category.html
19:36:18 <aristid> the obvious candidates for (~>) being (->) and Arrows
19:36:35 <aristid> Eduard_Munteanu: cat is (~>)
19:36:36 <kmc> indeed, Arrow is a subclass of Category
19:36:39 <kmc> Eduard_Munteanu, read cat as (~>)
19:36:43 <sina> dmwit: I know this rest is going one step ahead. and then it will not match the pattern h:[] . so I'm thinking how to make it right now !
19:36:44 <Eduard_Munteanu> Oh.
19:36:46 <kmc> cat a a ≡ a ~> a
19:36:52 <kmc> easier to read this way
19:37:01 <aristid> kmc: are there other well-known instances of base Category?
19:37:02 <Eduard_Munteanu> So basically Category has only one meaningful instance?
19:37:04 <ddarius> As a very simple example, Hom(C,AxB) ~(by a definition of x) Hom(C,A)xHom(C,B) ~(this is true in Set) Hom(C,B)xHom(C,A) ~ Hom(C,BxA) =>(Yoneda) AxB ~ BxA
19:37:16 <aristid> Eduard_Munteanu: no, many. all Arrows, for example
19:37:16 <kmc> Eduard_Munteanu, how does that follow?
19:37:28 <Eduard_Munteanu> kmc: yeah, that's how I used to read it, by I couldn't figure why the 'cat' there.
19:37:42 <kmc> cat is a (variable for a) binary type constructor
19:37:45 <kmc> easier to read infix
19:38:00 <kmc> the categories familiar to most Haskell programmers are (->) and (Kleisli m) for each monad m
19:38:10 <kmc> though we don't use Control.Category with the latter very much
19:38:22 <osaunders> Putting functions in records, a good idea?
19:38:23 <kmc> but if you want to write (.) instead of (<=<) and id instead of return, that's the way forward :)
19:38:27 <kmc> osaunders, great idea
19:38:32 <Eduard_Munteanu> Ah then I suppose it makes sense, thanks.
19:38:47 <ddarius> Control.Category was made to factor Arrow.
19:38:53 <Eduard_Munteanu> osaunders: look at Reader
19:38:54 <kmc> osaunders, too much Haskell code is designed around a baroque system of types and type classes, when a simple function-containing record would do
19:39:10 <dmwit> sina: By the way, when you've got yourself a solution, you might enjoy taking a look at http://conal.net/blog/posts/adding-numbers/
19:39:21 <dmwit> (But I recommend waiting until you've got a solution.)
19:39:30 <Eduard_Munteanu> @src Reader
19:39:31 <lambdabot> Source not found. I've seen penguins that can type better than that.
19:39:53 <Eduard_Munteanu> :t runReader
19:39:54 <lambdabot> forall r a. Reader r a -> r -> a
19:40:01 <Eduard_Munteanu> anyway, that's a record in fact
19:40:03 <sina> dmwit: I cant find a solution :( 
19:40:21 <dmwit> sina: I believe in you! =)
19:41:08 <EvanR> Eduard_Munteanu: i like my reader to just be a function
19:41:39 <EvanR> r -> a
19:41:55 <Eduard_Munteanu> EvanR: heh, it is, but runReader works like a constructor.
19:42:04 <EvanR> yeah
19:42:08 <Eduard_Munteanu> (r -> a) -> Reader r a
19:42:13 <sina> dmwit: any solution ? I don't know anything about monads, etc.  I need some way simple to make this work :(
19:42:35 <dmwit> If you are asking whether I will solve it for you, then the answer is a flat "no".
19:42:47 <dmwit> If you have a more specific question, I'll be happy to help, though.
19:42:55 <EvanR> Eduard_Munteanu: runReader could be just (flip $)
19:42:57 <dmwit> (It's just that this has very much the flavor of a homework question.)
19:42:59 <EvanR> er
19:43:03 <EvanR> :t flip ($)
19:43:04 <lambdabot> forall a b. a -> (a -> b) -> b
19:43:07 <sina> dmwit: I need some hint. not a solution basically.
19:43:24 <dmwit> My hint is not to use head.
19:43:32 <dmwit> We've got this beautiful pattern-matching stuff. Use it.
19:43:37 <Eduard_Munteanu> sina: you're still on that list to triple conversion stuff?
19:44:33 <EvanR> l2tr [x] = (x, undefined, undefined)
19:44:34 <sina> Eduard_Munteanu: I tried not to use that triple converting thing. now I want to work on a list instead. and still on this thing :(
19:44:51 <pelotom> I notice that in monads-fd Reader is just a type alias to ReaderT r Identity, does this work in general to prevent having to implement everything all over again for your monad transformer?
19:45:27 <EvanR> pelotom: if you have a very simple Reader like i just described, a ReaderT isnt really very much 
19:45:33 <sina> Is there any way to trace what happens inside the program?
19:45:35 <EvanR> stuff has to take at least one line anyway
19:45:38 <Eduard_Munteanu> sina: if you want to convert a list to a triple, then those type sigs are really wrong
19:45:42 <sina> I mean looking at the flow of the program
19:46:05 <pelotom> EvanR: but it's still repetition... in a more complex monad it might get annoying
19:46:06 <dmwit> sina: Try reducing it by hand. It's easier than you might think.
19:46:07 <Eduard_Munteanu> sina: if OTOH you want to convert a triple to a list, it's trivial, just cons all elements.
19:46:09 <EvanR> sina: theres understanding lazy evaluation and playing computer on paper
19:46:25 <ddarius> pelotom: If you have a transformer T, then T Identity is a non-transformer version if that's what you mean, and all the stuff will lift.
19:46:27 <EvanR> pelotom: no because the T version usually doesnt add any functionality
19:46:32 <dmwit> sina: It will almost certainly be simpler than understanding what the debugger is doing (assuming you have little experience with Haskell).
19:47:05 <pelotom> ddarius: that's what I mean... does that work in all cases (I assume it does)?
19:47:25 <pelotom> make your non-transformer monad just an alias to the transformer composed with identity
19:47:26 <sina> Eduard_Munteanu: no, I'm trying to make that a b c +1 thing without triple list.
19:47:39 <sina> dmwit: EvanR: will try my best now
19:47:49 <EvanR> pelotom: meh, forget transformers ;)
19:48:01 <pkrumins> hey has anyone had a problem where Network module listens on IPv6 address instead of the IPv4 one?
19:48:06 <ddarius> pelotom: If it doesn't then you don't have a transformer.
19:48:14 <pkrumins> there this one bug report about that and that's all.
19:48:39 <EvanR> Network module has a lot of shortcomings
19:48:49 <pkrumins> http://hackage.haskell.org/trac/ghc/ticket/2391
19:48:52 <EvanR> basically you need to use sockets directly for anything more than ultra basic
19:49:00 <pelotom> EvanR: what do you do in place of transformers?
19:49:11 <pelotom> everything in IO?
19:49:14 <Eduard_Munteanu> You can just use the regular monad directly.
19:49:16 <pkrumins> EvanR, pesky! my stuff is actually ultra basic.
19:49:23 <Eduard_Munteanu> If you don't need multiple monads that is.
19:49:36 <pkrumins> it's just Network picks IPv6's 0:0:0...0 to listen on, not 0.0.0.0
19:49:38 <EvanR> pkrumins: unfortunately ipv6 is not ultra basic is many systems
19:49:43 <pelotom> Eduard_Munteanu: yes, I mean when you need the functionality of multiple monads
19:49:45 <EvanR> or, not considered basic
19:49:58 <pkrumins> so i can't connect to my server from an external network, which is all ipv4
19:50:24 <EvanR> pkrumins: ipv6 listening isnt ultra basic. for example on some systems you cant listen on both ipv6 and ipv4 at the same time
19:50:29 <EvanR> windows xp, netbsd
19:50:30 <pkrumins> EvanR: i'll try disabling ipv6 on that machine.
19:50:40 <pkrumins> cause i don't really need it
19:51:04 <EvanR> you really should be able to connect in your case
19:51:14 <pkrumins> i can connect from localhost
19:51:22 <pkrumins> but not from anywhere else
19:51:34 <EvanR> pelotom: no
19:51:42 <pkrumins> messing around it a bit more
19:54:12 <pelotom> EvanR: no?
19:54:22 <EvanR> one monad at a time
19:54:52 <EvanR> at most
19:56:16 <pelotom> EvanR: what happens when you want more than what a single monad provides?
19:56:26 <EvanR> impossible!
19:56:57 <pelotom> heh
19:57:11 <EvanR> you can make a specialized one
19:57:30 <EvanR> maybe you dont want to implement it, but thats what you were discussing ;)
19:57:39 <Cale> pelotom: Like what?
19:57:57 <Cale> There are certainly libraries which don't fit into the monad API.
19:58:03 <Cale> They're just not monad-shaped.
19:58:12 <pelotom> it seems like if some combination of transformers will do what your custom monad would do, why not use that and not have to reinvent everything?
19:58:17 <Cale> But maybe another sort of abstraction applies to them, like applicative functors
19:58:45 <pelotom> Cale: I'm not disputing that
19:59:40 <EvanR> at work we use php (ok, ready?). sometimes the issue comes up about whether or not to make a user-defined function
20:00:03 <EvanR> i think its trivial and good, some people dont agree, saying 'its not complex enough for that' or 'dont make your own framework'
20:00:18 <Cale> If you have a bunch of monads, there are lots of ways that they could be related to one another. There's nothing preventing you from using more than one monad in a given piece of code. If I understand your question correctly, it's a bit like asking "what happens when you want more than what a single library provides?"
20:00:29 <JohnnyL> Hey Cale, ltns.
20:00:32 <EvanR> instead hammering a framework provided solution into the code, or just writing lots of inline php for loops
20:00:44 <aristid> Cale: maybe he's asking for monad transformers?
20:00:44 <Cale> For example, lots of code uses both lists and Maybe.
20:01:03 <pelotom> I'm talking *about* monad transformers :P
20:01:03 * ddarius thinks what pelotom said has been misread.
20:02:04 <Cale> Monad transformers are just another way of constructing particular monads.
20:02:23 <pelotom> Cale: yes, that's a good way of putting it. with less boilerplate.
20:02:39 <pelotom> it can't construct *all* monads, but it can construct some useful ones
20:03:06 <Cale> Right
20:03:30 <pelotom> EvanR: you lost me with the PHP stuff :P
20:03:56 <EvanR> Cale makes a good point about 'composing' monads without transformers
20:04:16 <EvanR> by just using them when appropriate
20:04:49 <Boxo> > [fst (random $ mkStdGen n) :: Bool | n <- [0..20]]
20:04:50 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
20:04:52 <Boxo> Why is that?
20:05:14 <EvanR> Boxo: rng's are not designed to be used that way
20:05:32 <aristid> EvanR: btw. i have written a package for composing monads (monadic values) in a different way :>
20:05:35 <Boxo> ... why nor?
20:05:41 <Boxo> s/nor/not
20:05:43 <EvanR> the fact that they often are ( as in phps way of seeding rngs on every request ) is very disturbing
20:05:43 <aristid> @hackage transformers-compose
20:05:44 <lambdabot> http://hackage.haskell.org/package/transformers-compose
20:05:50 <Boxo> How should I generate my bools..?
20:05:57 <EvanR> Boxo: by seeding only once
20:05:58 <dmwit> :t unfoldr
20:05:58 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:06:13 <dmwit> > randoms :: [Bool] -- this way, for example, Boxo
20:06:13 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
20:06:13 <lambdabot>         against inferred typ...
20:06:23 <dmwit> > randoms (mkStdGen 0) :: [Bool] -- this way, for example, Boxo
20:06:24 <lambdabot>   [True,True,True,False,False,True,True,True,True,False,True,False,False,Fals...
20:06:28 <Vanadium> It does seem a bit peculiar that the first random for 20 sequential seeds returns the same value
20:06:28 <Boxo> I'm actually only trying to generate one bool, but it was always True
20:06:36 <Boxo> they all return True!
20:06:39 <EvanR> Boxo: apparently you arent making one bool
20:06:46 <EvanR> if they are 'all' true
20:06:50 <ddarius> Boxo: You tested all four billion of them?
20:06:59 <pelotom> aristid: how does yours work?
20:07:00 <EvanR> ddarius: they are true up to about the 60000th
20:07:08 <Boxo> Ok, I have many places where I need a single bool, I don't need a list of bools
20:07:14 <Vanadium> @check random . mkStdGen
20:07:14 <lambdabot>   No instance for (Test.QuickCheck.Testable
20:07:14 <lambdabot>                     (a, System.Ra...
20:07:17 <ddarius> There is no requirement that the seed produce nicely distributed numbers.
20:07:19 <EvanR> Boxo: all those places need to share the same generator
20:07:29 <EvanR> thats how RNGs work
20:07:46 <Boxo> Yes, I seed the whole thing with an mkStdGen
20:07:47 <EvanR> its like you generated True (randomly) and passed it to all those places
20:07:56 <EvanR> not what you wanted
20:08:41 <Vanadium> How do I get longer errors from @check?
20:08:44 <EvanR> Boxo: where are you getting these seeds?
20:09:01 <Boxo> Okay, since randoms works, the problem is that StdGens made with mkStdGen always return True. The hack to fix it is to "refresh" the generator once before using it...
20:09:16 <EvanR> no
20:09:20 <ddarius> Boxo: You shouldn't be seeding more than once.
20:09:22 <Boxo> EvanR: I have a testing function that I give and Int to to seed mkStdGen with
20:09:27 <Boxo> ddarius: I'm not!
20:09:29 <EvanR> where are you getting the Int from
20:09:38 <Boxo> I make it up...
20:09:51 <EvanR> oh, do you misunderstand how a generator works?
20:09:57 <Boxo> apparently!!
20:10:05 <EvanR> it gives the same sequence of numbers each time for a given seed
20:10:10 <EvanR> the sequence is a function of the seed
20:10:53 <Boxo> I know that
20:11:11 <EvanR> the sequence is also psuedo random
20:11:14 <ddarius> (Actually, I think StdGen is 64-bit so there's a -lot- more than four billion potential seeds.)
20:11:17 <EvanR> pseudo
20:11:22 <Vanadium> @check \i -> let g = mkStdGen i ; (b, g') = random g in b :: Bool
20:11:22 <lambdabot>   "OK, passed 500 tests."
20:11:28 <Vanadium> Sorry that does seem a bit off
20:11:34 <EvanR> its not
20:11:44 <EvanR> and i suspect its like that for many real life generators
20:11:58 <Boxo> Yeah, the only problem seems to be that mkStdGen n always yields True in the lower end of n, I can work around that...
20:11:59 <ddarius> Again, there's no requirement that there are nice randomness properties as a function of the seed.
20:12:04 <EvanR> if the first element is not always something, then its at least not very random
20:12:05 <Cale> > map (fst . randomR (False,True) . mkStdGen) [0..100]
20:12:06 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,True...
20:12:15 <Cale> ^^ I think that's what he means
20:12:42 <EvanR> Boxo: its not always True
20:12:57 <EvanR> its just not very random, despite your choice of seed
20:13:04 <ddarius> For example, it would be quite acceptable for the first bit to be determined by the high bit of the seed, which would (for a 32-bit seed) make the low -2 billion- numbers return True.
20:13:04 <sina> dmwit: the second variable is now sorted. now the first variable turns 26. http://hpaste.org/paste/41233/#p41235
20:13:08 <Vanadium> > head $ filter (not . fst . random . mkStdGen) [0..]
20:13:09 <lambdabot>   53668
20:13:09 <dmwit> > fst . random . mkStdGen $ maxBound :: Bool
20:13:10 <lambdabot>   True
20:13:13 <Boxo> Evan: fine, but it's weirdly often true
20:13:19 <EvanR> Boxo: its not weird
20:13:21 <dmwit> > fst . random . mkStdGen $ minBound :: Bool
20:13:22 <lambdabot>   True
20:13:30 <EvanR> you are using the generator incorrectly
20:13:34 <Eduard_Munteanu> Any good PRNG should at least look random, i.e. have a certain distribution
20:13:52 <EvanR> Eduard_Munteanu: yes but were not testing the generator here
20:13:55 <ddarius> Eduard_Munteanu: For the love of Christ, yes, but NOT as a function of the SEED.
20:14:00 <Cale> @check fst . random . mkStdGen
20:14:00 <lambdabot>   Add a type signature
20:14:12 <Cale> @check \x -> fst . random . mkStdGen $ x :: Bool
20:14:12 <lambdabot>   "OK, passed 500 tests."
20:14:14 <EvanR> a slice of all possible sequences is not guaranteed to be even remotely random
20:14:16 <Cale> @check \x -> fst . random . mkStdGen $ x :: Bool
20:14:17 <lambdabot>   "OK, passed 500 tests."
20:14:17 <dmwit> sina: You know, this would be a lot easier for you if you stored your digits in the other order.
20:14:21 <pelotom> @type getStdGen
20:14:21 <Eduard_Munteanu> Function of seed?
20:14:22 <lambdabot> IO StdGen
20:14:26 <dmwit> e.g. least-significant first
20:14:43 <Eduard_Munteanu> Oh, I get what you mean, yeah
20:15:12 <EvanR> ddarius: we can deal with it because we are smart, but in php the rng is seeded at the start of each request (on your behalf). i think a large number of websites use this and think its random
20:15:12 <Vanadium> Where does getStdGen get the generator from/what is it seeded with?
20:15:18 <EvanR> ddarius: pretty bad
20:15:26 <EvanR> there is large scale misunderstanding of this aspect of RNGs
20:16:02 <Vanadium> Why is it not random :I
20:16:15 <Eduard_Munteanu> Cryptographically no PRNG is random :)
20:16:33 <EvanR> well, crypto rngs come close
20:16:37 <dmwit> > map fst . randomR (0,1) . mkStdGen $ [0..20]
20:16:38 <lambdabot>   Couldn't match expected type `[(a, b)]'
20:16:38 <lambdabot>         against inferred type `(t, ...
20:16:48 <sina> dmwit: I know. just want to not use sort
20:16:52 <dmwit> > map (fst . randomR (0,1) . mkStdGen) [0..20]
20:16:53 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
20:16:57 <aristid> pelotom: mine works by composing the nearest ReaderT
20:16:58 <dmwit> sina: What does sort have to do with this?
20:17:02 <Eduard_Munteanu> Yeah, though those collect entropy from various sources rather than do math :)
20:17:07 <Vanadium> dmwit: It got up to 50ksomething
20:17:07 <aristid> pelotom: sorry for the delay, was watching a video
20:17:16 <Cale> This seems sort of bad. :P
20:17:16 <dmwit> > map (fst . random . mkStdGen) [0..20] :: [Int]
20:17:17 <lambdabot>   [-117157315039303149,7917908265643496962,-2493721835987381530,5541392136091...
20:17:30 <unkanon2> Eduard_Munteanu: actually i think there are cryptographically secure prngs
20:17:32 <Vanadium> Why do I have to make a lambda to make @check not throw a type error, anyway
20:17:34 <EvanR> Cale: i brought this up several times up to this point ;)
20:17:37 <dmwit> > map (fst . randomR (0,2) . mkStdGen) [0..20] :: [Int]
20:17:37 <lambdabot>   [2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2]
20:17:46 <dmwit> > map (fst . randomR (0,3) . mkStdGen) [0..20] :: [Int]
20:17:47 <lambdabot>   [1,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3]
20:17:58 <Boxo> > let refresh g = let (_,g') =  random g :: (Bool, StdGen) in g'
20:17:59 <lambdabot>   not an expression: `let refresh g = let (_,g') =  random g :: (Bool, StdGen...
20:18:08 <Eduard_Munteanu> unkanon2: hm, that would be interesting.
20:18:11 <Eduard_Munteanu> I don't see how though.
20:18:15 <Cale> @let refresh g = let (_,g') =  random g :: (Bool, StdGen) in g'
20:18:16 <lambdabot>  Defined.
20:18:31 <EvanR> Boxo: anyway. if your program is keeping a counter or something to increment a seed, instead put the generator in that location
20:18:35 <EvanR> problem solved
20:18:45 <Boxo> > [fst (random $ refresh $ mkStdGen n) :: Bool | n <- [0..20]]
20:18:46 <lambdabot>   [True,False,True,True,False,True,False,False,True,False,True,True,False,Tru...
20:19:07 <Vanadium> Man I am just going to stop using random numbers
20:19:09 <Vanadium> this is pretty dumb
20:19:13 <Eduard_Munteanu> :t randomRIO
20:19:14 <lambdabot> forall a. (Random a) => (a, a) -> IO a
20:19:16 <unkanon2> Eduard_Munteanu: i'm pretty sure there's something on wikipedia about that, but right now the discussion here is more interesting :)
20:19:18 <Boxo> No, it wasn't keeping a counter, I wasn't doing anything stupid :<
20:19:21 <EvanR> Boxo and Vanadium are trolling?
20:19:25 <Eduard_Munteanu> @hoogle random
20:19:25 <lambdabot> package random
20:19:25 <lambdabot> System.Random random :: (Random a, RandomGen g) => g -> (a, g)
20:19:25 <lambdabot> module System.Random
20:19:28 <EvanR> Boxo: [1..20] is a counter
20:19:40 <Vanadium> EvanR: bluh bluh bluh
20:20:05 <Boxo> EvanR: That line isn't used anywhere in my program
20:20:19 <EvanR> Boxo: whats the problem with your program then?
20:20:21 <sina> dmwit: is there anything wrong here? newhead = if h == 25 then 0 else h+1 . cause now if I use newhead, if the number be 25, it remains 25 !
20:20:26 <dmwit> Boxo: Just bite the bullet and track a StdGen in your program. It's not that hard.
20:20:29 <Boxo> I just want to be able to give different ints to my function in ghci as seeds and have random-looking behaviour
20:20:46 <dmwit> sina: Error: h is not in scope!
20:20:51 <EvanR> Boxo: then use that int as the position in a random sequence
20:20:55 <EvanR> with seed 0
20:21:17 <EvanR> *the first element of all sequences is not a random sequence*
20:21:27 <sina> dmwit: this is in a "where" clause
20:21:32 <Vanadium> Is the second element of all sequences?
20:21:34 <pelotom> State is a good way to keep a StdGen tucked away
20:21:35 <EvanR> no
20:21:41 <Vanadium> > randoms (mkStdGen 0)
20:21:41 <lambdabot>   [-117157315039303149,-8854136653200549331,-2598893763451025729,-21049421333...
20:21:46 <dmwit> sina: Better paste some more context, then.
20:21:46 <Vanadium> > randoms (mkStdGen 0)::[Bool]
20:21:47 <lambdabot>   [True,True,True,False,False,True,True,True,True,False,True,False,False,Fals...
20:22:41 <dmwit> :t getRandom
20:22:42 <lambdabot> forall (m :: * -> *) a. (MonadRandom m, Random a) => m a
20:22:45 <EvanR> Vanadium: there is no reason to think it is well distributed
20:22:49 <Boxo> Here's my code http://pastebin.com/RRmnQVge
20:22:49 <sina> dmwit: http://hpaste.org/paste/41233/#p41237
20:22:54 <Boxo> My problem looks solved now though
20:22:54 <dmwit> Boxo: randomRIO ?
20:23:02 <Eduard_Munteanu> I misunderstood the cryptographically secure PRNG idiom... it doesn't actually increase entropy.
20:23:13 <EvanR> dmwit: 'seeded by IO when the runtime starts' is the same problem
20:23:21 <dmwit> Boxo: randomIO >>= functionThatNeedsARandomBool, for example
20:23:23 <Eduard_Munteanu> If so, it's certainly possible.
20:23:33 <Eduard_Munteanu> *actually purport to
20:23:39 <dmwit> EvanR: No, it isn't. Because he'll be running several things in ghci in sequence, and IO will track the generator for him.
20:23:48 <EvanR> Eduard_Munteanu: entropy isnt the issue, crypto rngs and normal *good* rngs have the same randomness
20:23:56 <EvanR> dmwit: ah
20:24:07 <EvanR> sounds like he is rebooting ghci
20:24:30 <ddarius> EvanR: You may find this old thread involving a much younger me entertaining, and by "entertaining" I mean "very frustrating."
20:24:35 <Vanadium> I am not sure I understand what the problem is with php seeding the rng on each request
20:24:37 <EvanR> Eduard_Munteanu: the only difference is your ability to predict the numbers based on extra information
20:24:39 <Eduard_Munteanu> EvanR: yes, both should look as random.
20:24:54 <dolio> What is PHP seeding with?
20:25:00 <Eduard_Munteanu> Yeah.
20:25:00 <dmwit> sina: This is horribly complicated. I think you should rethink your approach a bit.
20:25:09 <EvanR> dolio: the system time or a random number from linux
20:25:12 <Boxo> If you still care, the function (<|>) was where I was having a problem; it was always choosing the first option. using refresh fixed it.
20:25:22 <EvanR> dolio: but 'random seed' does not ensure random first element
20:25:34 <Vanadium> What does ensure random first element
20:25:39 <EvanR> nothing
20:25:46 <EvanR> stop resetting your generator
20:25:49 <Vanadium> well that sounds pretty useless as far as random numbers go
20:25:56 <Eduard_Munteanu> EvanR: if the first element is almost always the same, I doubt that provides information on the other hand.
20:26:19 <Eduard_Munteanu> in an information theoretic sense.
20:26:27 <sina> dmwit: basically, it checks if the head of the tail of the given list is 26. if so, it adds 1 to the current head
20:26:34 <Eduard_Munteanu> But it could be weak depending on what they're using it for.
20:26:48 <EvanR> Eduard_Munteanu: eh? i was referring to for example a lag 1024 mwc generator, amazing properties right, but you just need to know what the algorithm is and look at any consequtive 1024 outputs to be able to guess the next one
20:26:48 <Eduard_Munteanu> s/almost//
20:27:46 <EvanR> for crypto generators you know the algorithm but still cant guess the next number no matter how many bytes you see
20:28:05 <EvanR> even if you know some of the internal state
20:28:20 <Adamant> assuming it works correctly
20:28:21 <Adamant> but yeah
20:28:38 <Eduard_Munteanu> EvanR: I was just saying, maybe reseeding like that doesn't actually decrease entropy of the output.
20:28:53 <EvanR> theres usually no proof or even design choices to ensure that it doesnt
20:29:11 <EvanR> so by default its not a random sequence
20:29:43 <EvanR> i havent actually ever heard of someone making an rng which is random in the seed dimension, but i dont know
20:30:06 <Eduard_Munteanu> Oh, that's another thing, no.
20:30:08 <Vanadium> I still do not get it. How do I go get a single random bool, then?
20:30:20 <dmwit> Boxo: For what it's worth, the "correct" solution is to change from running such a program several times to having the program loop several times, passing along the (modified) generator each time.
20:30:24 <sina> dmwit: there seem to be a strange problem here. as in here where newhead = if h == 25 then 0 else h+1 , if h be 25, it returns 25. if I change 0 to h+1 it returns 26 !!! is it a computer issue ?! :-s
20:30:27 <Eduard_Munteanu> EvanR: I thought you were complaining about reseeding "every once in a while".
20:30:34 <EvanR> Eduard_Munteanu: that too
20:30:43 <EvanR> if youre serious, you dont
20:30:44 <ddarius> Vanadium: By consulting a running random number generator or a physical source of "randomness."
20:30:46 <dmwit> Vanadium: If you want a truly random bit, you must use hardware -- e.g. check a Geiger counter.
20:30:51 <EvanR> you save your generator state and restore it later
20:31:15 <Vanadium> I am fine with pseudo-random
20:31:26 <EvanR> Vanadium: great! then just keep a single good generator running
20:31:34 <Vanadium> I just need one bool!!
20:31:38 <EvanR> too bad
20:31:47 <EvanR> flip a coin
20:31:48 <Eduard_Munteanu> EvanR: suppose you have lots of entropy at hand, not enough for everything, but you still want to make use of it. You're basically suggesting "hey, use a single quanta of entropy forever"
20:31:55 <Vanadium> My program does not have any coins
20:32:03 <EvanR> Eduard_Munteanu: for a good generator thats all you need
20:32:28 <dmwit> Vanadium: Your computer has something similar. /dev/random gathers entropy from the user.
20:32:53 <ddarius> Vanadium: How would you "randomly" choose the seed?  You need an external source of randomness or a running random number generator to do that.
20:32:57 <Eduard_Munteanu> EvanR: that could be incredibily weak in a crypto sense, all an attacker needs to guess is something the size of the seed.
20:33:02 <EvanR> yes
20:33:20 <EvanR> for crypto you want to continually add randomness
20:33:27 <EvanR> just in case
20:33:34 <Eduard_Munteanu> Yes, for true crypto it's all entropy generally.
20:33:38 <Eduard_Munteanu> Like when generating keys.
20:33:41 <ddarius> Vanadium: No matter what, if you want your program to behave differently each time it runs, it needs to get some information from outside.
20:33:41 <Vanadium> The thing that I cannot wrap my head around is that apparently the first bool I am taking is not random ¯\(O_o)/¯
20:33:44 <EvanR> Eduard_Munteanu: not on BSD
20:34:01 <Eduard_Munteanu> No?
20:34:02 <EvanR> its a single long running generator
20:34:07 <dmwit> Vanadium: None of the bools you are taking are random.
20:34:12 <EvanR> but you can add entropy if you want
20:34:13 <Vanadium> pseudo so
20:34:23 <Vanadium> Sensibly distributed, I guess
20:34:38 <EvanR> Eduard_Munteanu: its a security issue to not let anyone have the full generator state
20:34:43 <dmwit> There's no distribution. It's deterministic.
20:35:11 <Eduard_Munteanu> EvanR: but I suppose gpg still takes 100% entropy and not PRNG crap :)
20:35:28 <EvanR> if by 100% entropy you mean only use /dev/random, that will quickly run out
20:35:33 <pelotom> @t newStdGen
20:35:34 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
20:35:37 <Eduard_Munteanu> at least here, generating a 4096 bit key takes a while and lots of mouse movement.
20:35:40 <pelotom> @type newStdGen
20:35:41 <lambdabot> IO StdGen
20:35:46 <Eduard_Munteanu> EvanR: indeed.
20:35:51 <dmwit> :t newStdGen -- the shortcut, pelotom
20:35:51 <lambdabot> IO StdGen
20:35:56 <EvanR> Eduard_Munteanu: not enough to do crypto
20:36:16 <sina> dmwit: fixed the issue. but the code looks really complicated :D
20:36:27 <pelotom> dmwit: thx
20:36:47 <Adamant> Intel and such just need to re-add a HWRNG
20:36:50 <Eduard_Munteanu> EvanR: AFAIK, assymetric keys are always true random, then through that channel, the symmetric block ciphers are negotiated based on PRNG output, if I'm not mistaken.
20:36:57 <Adamant> they had one in there for a while
20:37:13 <Adamant> HWRNG + AES and SHA3 support = goodness
20:37:48 <EvanR> Eduard_Munteanu: its not clearly defined whether the output of the long running PRNG which was originally seeded by /dev/random is more or less 'truely random' than /dev/random is
20:37:54 <dmwit> > let increment [] = [1]; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in increment [25, 25, 13]
20:37:55 <lambdabot>   [0,0,14]
20:38:09 <EvanR> your mouse movements are definitely not random
20:38:10 <Eduard_Munteanu> EvanR: I think it surely is.
20:38:12 <Eduard_Munteanu> Oh.
20:38:18 <dolio> > let bool :: Int -> Bool ; bool = fst . random . mkStdGen ; f (l, r) False = l `seq` r `seq` (l+1, r) ; f (l, r) True = l `seq` r `seq` (l, r+1) in foldl' f (0,0) . map bool $ [1..1500000]
20:38:19 <dmwit> sina: This does not have to be a complicated function.
20:38:21 <lambdabot>   (748645,751355)
20:38:29 <Eduard_Munteanu> EvanR: that's true, but they still contain lots of entropy.
20:38:46 <Eduard_Munteanu> EvanR: like timing, imperfect movements etc.. I doubt those are predictable.
20:38:47 <EvanR> its subjective
20:38:59 <EvanR> if i dont know the crypto rng state, its also random
20:39:20 <Eduard_Munteanu> Yes, but only the state and the initial seed.
20:39:36 <Eduard_Munteanu> That's like, say, 4 bytes?
20:39:50 <EvanR> if you take the direct concatenation of entropy sources, even like thermal sensors, then its very much less random than the good rng
20:40:02 <EvanR> Eduard_Munteanu: 4 bytes? no
20:40:09 <EvanR> a good rng has a large amount of state
20:40:11 <sina> dmwit: what I've done is this: http://hpaste.org/paste/41233/#p41238 which works fine. but I dont know how to make it less complicated
20:41:00 <dmwit> sina: As I suggested above, it will be much simpler if you store the digits in the other order.
20:41:04 <Eduard_Munteanu> EvanR: as a probability distribution yeah, it looks less random
20:41:05 <EvanR> a 4 byte state repeats after at most 2^32 bits
20:41:07 <dmwit> sina: Still, I'm glad you've got something that works for you. =)
20:41:44 <EvanR> or, outputs
20:42:11 <dmwit> sina: (The "increment" function above, for example, is how I would write it.)
20:42:11 <sina> dmwit: is this code inefficient? or is just complicated?
20:42:28 <EvanR> i think im going to drink beer
20:42:42 <dmwit> sina: It's complicated, and not very lazy.
20:42:46 <EvanR> and try not to complain about misconceptions of RNGs to the bartender
20:42:52 <dmwit> The efficiency is probably fine if you're always going to demand the whole list, though.
20:42:54 <Eduard_Munteanu> :)
20:43:02 <ddarius> To underscore EvanR's statement, consider the Mersenne Twister.  In the typical configuration it has a period of 2^19937 - 1 and thus at an absolute minimum must have a state space containing 19,937 bits.
20:43:21 <ddarius> EvanR: Again, if you feel like getting even more worked up, check that link from earlier.
20:43:28 <EvanR> ddarius: i missed it... *scroll*
20:43:42 <funkyjunkyrobot> is haskell.org down for anyone else?
20:43:53 <ddarius> EvanR: Oh, no you didn't, I forgot to actually paste the link
20:44:02 <EvanR> lol
20:44:09 <ddarius> EvanR: http://www.programmersheaven.com/mb/x86_asm/144483/144812/re-random-numbers/?S=B10000
20:44:27 <funkyjunkyrobot> is there a good debugger for haskell?
20:44:36 <EvanR> ddarius: OUCH this site is ..
20:44:52 <geheimdienst> http://downforeveryoneorjustme.com/haskell.org <- uh-oh
20:44:56 * EvanR begins removing page elements with debug tools
20:45:08 <ddarius> EvanR: It wasn't as bad 9 years ago, but ...
20:45:25 <ddarius> EvanR: Anyway, just follow that thread.
20:45:27 <sina> dmwit: (25,25,13) is supposed to change to 25 25 14. only 25 25 25 will become 0 0 0. and we cannot pass 26
20:45:29 <funkyjunkyrobot> haha, cool that site is great
20:45:50 <dmwit> > let increment [] = [1]; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in increment [13, 25, 25] -- sina, it's in the other order
20:45:51 <lambdabot>   [14,25,25]
20:45:58 <dmwit> > let increment [] = [1]; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in increment [25, 25, 25]
20:45:58 <funkyjunkyrobot> is there a good debugger for haskell though?
20:45:59 <lambdabot>   [0,0,0,1]
20:46:05 <EvanR> ddarius: which one are you xD
20:46:25 <EvanR> darius
20:46:42 <stepcut> I'm pretty good at debugging haskell
20:46:43 <djahandarie> That isn't his name
20:46:46 <dmwit> funkyjunkyrobot: It's built into ghci. Check the manual.
20:46:47 <djahandarie> That's my name!!
20:46:53 <funkyjunkyrobot> cool
20:46:57 <djahandarie> He's just stealing it for his nick for reasons I don't know
20:46:57 <sina> dmwit: got it now :)
20:47:25 <sina> > let increment [] = []; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in increment [25, 25, 25]
20:47:26 <lambdabot>   [0,0,0]
20:48:20 <sina> > let reverse (increment [] = []; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in reverse (increment [1,25,25]))
20:48:21 <Eduard_Munteanu> > 19937 `div` 8
20:48:21 <lambdabot>   <no location info>: parse error on input `='
20:48:22 <lambdabot>   2492
20:48:42 <sina> > let increment [] = [1]; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in increment [25, 25, 25]
20:48:42 <lambdabot>   [0,0,0,1]
20:48:44 <Eduard_Munteanu> ddarius: yeah, that looks good...
20:48:54 <sina> > let reverse (increment [] = []; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in reverse (increment [1,25,25]))
20:48:55 <lambdabot>   <no location info>: parse error on input `='
20:49:25 <sina> > let increment [] = []; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in reverse (increment [1,25,25])
20:49:26 <lambdabot>   [25,25,2]
20:50:01 <sina> > let increment [] = []; increment (25:xs) = 0 : increment xs; increment (x:xs) = (x+1) : xs in reverse (increment [25,24,25])
20:50:02 <lambdabot>   [25,25,0]
20:50:41 <sina> dmwit: is reversing twice more inefficient than what I'm doing now?
20:50:50 <sina> isn't*
20:51:07 <dmwit> sina: Probably. I recommend that you don't reverse twice.
20:51:36 <sina> what about reversing once vs my own version ?
20:51:41 <EvanR> ddarius: meh, recommending twister ;) ill let it pass since it was 8 years ago ;)
20:51:54 <EvanR> in the dark ages
20:54:22 <Eduard_Munteanu> BTW, the reason most OSes save PRNG state more likely pertains to a lack of entropy after bootup.
20:54:55 <Eduard_Munteanu> And anyway, I suppose they're using it for stuff like TCP sequence numbers than anythign that is truly crypto.
20:54:58 * EvanR face smack
20:56:02 <EvanR> you are overemphasizing the role of entropy of generation of random numbers
20:56:22 <EvanR> you dont need entropy to generate random numbers
20:56:35 <EvanR> you just need a generator that doesnt reset on a regular basis
20:56:49 <Adamant> EvanR: for the purposes it was designed for, what's better than Twister?
20:56:59 <Eduard_Munteanu> EvanR: "random" is very very much dependent on the application. If you're looking to do math or simulations, PRNGs are really cool.
20:57:02 <dolio> Wait, that guy was proposing to generate random numbers by, what, reading from ports in order?
20:57:04 <Adamant> (non-crypto use)
20:57:07 <EvanR> MWC
20:57:16 <sina> is there any better way to call a function 2 times than doing y y ?
20:57:31 <pelotom> dolio: that's what it looked like
20:57:40 <dolio> Wow.
20:57:42 <pelotom> "because the memory state of DOS is highly random"
20:57:54 <EvanR> Adamant: marsaglia also has a newsgroup post about how to put together several trivially simple yet robust generators into one that is 'at least as good as the components' for crypto use
20:58:02 <Eduard_Munteanu> dolio: lol
20:58:15 <EvanR> where the user decides how they go together
20:58:20 <jmcarthur> sina: what do you even mean "call a function"?
20:58:39 <jmcarthur> sina: what you just typed isn't even well typed
20:58:44 <EvanR> Adamant: the main gripe about twister is its complex and slower than necessary
20:58:44 <jmcarthur> :t \y -> y y
20:58:45 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:58:45 <lambdabot>     Probable cause: `y' is applied to too many arguments
20:58:45 <lambdabot>     In the expression: y y
20:58:57 <Adamant> EvanR: ah, right
20:59:06 <geheimdienst> @remember jmcarthur what you just typed isn't even well typed
20:59:06 <lambdabot> It is stored.
20:59:11 <jmcarthur> geheimdienst: :P
20:59:14 <Adamant> so this fixes the complexity and slowness arguments
20:59:16 <geheimdienst> ;-)
20:59:17 <Adamant> what about quality?
20:59:18 <pelotom> actual quote: "If you think about it, memory is quite random (more so in true DOS than a DOS box because winbloze zeroes a lot of the memory) so by loading values from it as pointers and regular values and XOR them, you get someting good going on if you loop with the last retrieved pointer and do so enough times."
20:59:21 <jmcarthur> i realized what i said after i hit return
20:59:55 <jmcarthur> pelotom: the funny thing is that's probably even slower than just using a known prng algorithm
21:00:06 <Vanadium> > id id 5
21:00:06 <lambdabot>   5
21:00:14 <pelotom> jmcarthur: yeah, a lot slower
21:00:14 <EvanR> Adamant: i tested my own lag 1024 mwc against twister in dieharder
21:00:16 <Vanadium> seems well-typed enough
21:00:18 <ringzero> Hello - new to haskell. Any pointers to implementations of pairing-based cryptography in haskell? 
21:00:33 <Adamant> pairing how
21:00:40 <Vanadium> make sure to use a lot of entropy
21:00:42 <jmcarthur> Vanadium: okay fine :P
21:00:42 <EvanR> just ran them through the same tests
21:00:45 <ddarius> dolio: As well as using the "random" numbers from some ports to load a value into a pointer and then reading whatever is there.
21:00:56 <Eduard_Munteanu> ringzero: do you mean asymmetric crypto?
21:01:06 <ringzero> yes, based on elliptic curves. 
21:01:10 <Eduard_Munteanu> Oh.
21:01:12 <pelotom> jmcarthur: from darius' followup: "the running time of your algorithm was at least an order of magnitude slower (I didn't time it, but when the rand() version finishes immediately after you start the program whereas I could take a piss before your finished"
21:01:16 <ringzero> Perhaps the Weil, Tate or Ate pairings.
21:01:20 <sina> jmcarthur: for example, I want to apply a function as many times as a length of a string. for example, if "ABC" is 3, then I want to call functionX something 3 times like this: funcionX (functionX (functionX something)) . 
21:01:21 <jmcarthur> Vanadium: but it seemed to me that sina was wanting to be able to do it with *any* function, not just id
21:01:30 <Adamant> ah, I don't know about Haskell's elliptic curve support
21:01:34 <Eduard_Munteanu> There are some really cool algos there.
21:01:43 <jmcarthur> sina: iterate and (!!) might be what you want
21:02:00 <Eduard_Munteanu> IIRC some of which aren't easily solvable even by QC.
21:02:01 <jmcarthur> sina: or iterate and zip maybe
21:02:15 <pelotom> somebody on the internet is WRONG!!
21:02:28 <bos> someone writing bad PRNG code?
21:02:40 <jmcarthur> :t \xs f x -> snd . last . zip xs $ iterate f x
21:02:41 <lambdabot> forall a b. [a] -> (b -> b) -> b -> b
21:02:48 <jmcarthur> sina: like that maybe ^^
21:02:50 <dolio> I don't think "bad" really captures it.
21:02:56 * Eduard_Munteanu looks up...
21:03:01 * bos throws in the towel on the haskell platform package inclusion process.
21:03:15 <sina> jmcarthur: what does iterate do?
21:03:24 <bos> dolio: ah, sounds like fun.
21:03:25 <jmcarthur> > iterate (+2) 0   -- sina 
21:03:26 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
21:03:30 <Eduard_Munteanu> Argh, they are, I'm confusing with others.
21:03:32 <ddarius> pelotom: That was shortly before I left that forum.  Stuff like that and starting Haskell just made it not worth my while.
21:03:42 <jmcarthur> @src iterate
21:03:42 <lambdabot> iterate f x =  x : iterate f (f x)
21:03:59 <ddarius> bos: This ancient thread if you are interested: http://www.programmersheaven.com/mb/x86_asm/144483/144812/re-random-numbers/?S=B10000 
21:04:16 <sina> jmcarthur: how to stop iterate then? cause it seems to be infinite
21:04:19 <jmcarthur> sina: ah actually what i did was wrong. it would only apply the function length-1 times
21:04:27 <jmcarthur> sina: the zip was meant to stop it
21:04:36 <jmcarthur> > zip [1..5] $ iterate (+2) 0
21:04:37 <lambdabot>   [(1,0),(2,2),(3,4),(4,6),(5,8)]
21:05:11 <sina> jmcarthur: I'm not allowed to use $ :(
21:05:16 <Veinor> ... what
21:05:20 <jmcarthur> sina: just don't use it then?
21:05:26 <ddarius> Veinor: id is just too powerful a function.
21:05:31 <dolio> Heh, "The idea of my generator was to find good random numbers, not guarantee complete safety while producing crummy numbers." Who cares if I fry hardware. I need random numbers!
21:05:52 <jmcarthur> > let ntimes n f x = iterate f x !! n in ntimes 4 (*2) 1
21:05:53 <lambdabot>   16
21:06:36 <jmcarthur> sina: why would be allowed to use iterate but not ($)?
21:06:39 <Boxo> > (\xs f -> foldr (.) id [f | _ <- xs]) "abc" (+1) 0
21:06:40 <lambdabot>   3
21:06:53 <EvanR> dolio: the poster is incomprehensible
21:07:10 <Eduard_Munteanu> sina: just tell the teacher you've been looking on the wiki or the docs.
21:07:37 <Eduard_Munteanu> sina: did he specifically teach you a number a functions? And did he tell you not to use anything else?
21:07:53 <sina> jmcarthur: ok thanks :) is it not possible to do a foldl to do the iteration? (I'm working on an assignment. not supposed to know $)
21:08:05 <jmcarthur> @src iterate
21:08:06 <lambdabot> iterate f x =  x : iterate f (f x)
21:08:24 <Eduard_Munteanu> "You don't need no docs, just this 90-mins sloppy presentation is all Haskell's about"
21:08:36 <jmcarthur> sina: maybe a scanl, but not a simple foldl that i can think of
21:09:03 <jmcarthur> sina: you could use foldl to do a version that only applies it n times, just not to generate a list of such iterated applications
21:09:36 <jmcarthur> sina: and even then you'd have to do some odd list things
21:09:57 <jmcarthur> like replicate
21:10:01 <jmcarthur> @src replicate
21:10:01 <lambdabot> replicate n x = take n (repeat x)
21:10:02 <sina> Eduard_Munteanu: it is not the end of the semester, so we have to use what we know already. so, if using simple commands we make the program, it makes him more happy I guess. or at least he will not have the chance to mark me down.
21:10:10 <Boxo> > let ntimes n f = foldl (.) id (take n $ repeat f) in ntimes 4 (*2) 1
21:10:11 <lambdabot>   16
21:10:18 <jmcarthur> @src repeat
21:10:18 <lambdabot> repeat x = xs where xs = x : xs
21:10:34 <EvanR> if they want a course to teach haskell, and they want to assign a professor who doesnt know haskell, they could at least ask him to not come up with arbitrary ridiculous restrictions 
21:10:40 <jmcarthur> Boxo: take n . repeat == replicate ;)
21:10:44 <sina> jmcarthur: thanks a lot. I will take a look to see what I can do. and try to do it without iterating.
21:10:47 <jmcarthur> == replicate n, i mean
21:10:50 <Eduard_Munteanu> Jesus, now this is why I hate lectures... some things aren't really meant to work that way.
21:11:02 <EvanR> 'accomplish the goal however you want!'
21:11:04 <Boxo> jmcarthur: yep thats better
21:11:14 <EvanR> 'because i surely dont know how'
21:11:16 <Eduard_Munteanu> He barely teaches anything and then gives an assignment.
21:11:54 <Eduard_Munteanu> When a link to the docs plus a tip to visit this channel would've been lots better.
21:12:18 <pelotom> wait, ($) is off-limits?
21:12:23 <sina> Eduard_Munteanu, I know. the thing is that they say they want us to work on part no1, then no2, then no3, etc. to finish the project. however, if we wanted to do the project without this part by part thing, I would have loads of problems to deal with.
21:12:25 <dolio> EvanR: If you think about it, you should always be able to tell whether a Turing machine will halt or not.
21:12:39 <pelotom> how utterly bizarre
21:13:13 <Eduard_Munteanu> sina: yeah, I understand the situation.
21:13:14 <pelotom> are you allowed to use function application at all? this could be tricky...
21:13:38 <Eduard_Munteanu> But by the ended you and him will both wish you wrote it AFTER learning the material.
21:13:39 <jmcarthur> sina: you could always define these functions yourself
21:13:41 <Eduard_Munteanu> *end
21:14:15 <Eduard_Munteanu> sina: a combination of lets and moving stuff around into other functions can easily account for ($) use
21:15:40 <sina> I wouldn't have loads... :D Eduard_Munteanu: there must be an easier solutions I guess. ugly but using simple commands. I will try to see what I can do. thanks all and thanks jmcarthur
21:16:51 <Eduard_Munteanu> zip [1..5] $ iterate (+2) 0      <=>     let foo = iterate (+2) 0 in zip [1..5] foo
21:17:09 <Eduard_Munteanu> or parenthesis.
21:17:31 <Eduard_Munteanu> like zip [1..5] (iterate (+2) 0)
21:17:38 <jmcarthur> sina: you wouldn't have "loads"?
21:18:12 <jmcarthur> oh that wasn't in response to me
21:19:11 <sina> what is this error ? *** Exception: Prelude.(!!): index too large :(
21:19:35 <Eduard_Munteanu> sina: the index is out of the list's bounds...
21:19:41 <roconnor> > [1]!!1
21:19:42 <lambdabot>   *Exception: Prelude.(!!): index too large
21:19:44 <roconnor> > [1]!!0
21:19:45 <lambdabot>   1
21:20:28 <sina> oh, right. thanks.
21:21:38 <Eduard_Munteanu> @pl \x y -> x y
21:21:38 <lambdabot> id
21:22:27 <Veinor> @pl \x y z -> x
21:22:27 <lambdabot> const . const
21:22:33 <Veinor> @unpl const const
21:22:33 <lambdabot> (\ _ b _ -> b)
21:22:37 <Eduard_Munteanu> Nvm, I was expecting it to be more convoluted.
21:22:51 <EvanR> haha
21:23:01 <EvanR> @unpl id
21:23:01 <lambdabot> (\ a -> a)
21:23:03 <funkyjunkyrobot> :) haskell rocks
21:23:13 <EvanR> @faq can haskell rock
21:23:13 <lambdabot> The answer is: Yes! Haskell can do that.
21:23:35 <Eduard_Munteanu> EvanR: yeah, I figured sina could use the boobies operator or some wild combination of that in case function application wasn't allowed :P
21:23:37 <m3ga> anyone know how to add a pre-commit hook in darcs?
21:23:44 <EvanR> Eduard_Munteanu: lol
21:23:49 <m3ga> #darcs is silent :-(
21:23:59 <Eduard_Munteanu> EvanR: credits go to pelotom for asking that
21:24:57 <EvanR> problem with boobies is that
21:25:12 <EvanR> if they look like boobies they must be applied prefix
21:25:24 <EvanR> defeating the purpose in case you cant use application
21:25:45 <Eduard_Munteanu> Eventually something is applied, yeah, it can't be 100% pointfree
21:26:07 <Eduard_Munteanu> Even when simply composing functions.
21:26:14 <Eduard_Munteanu> :t (.)
21:26:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:26:40 <ddarius> 3 + 4 is still applying (+) to 3.
21:27:11 <EvanR> > map `(.)(.)` length tails [1,2,3]
21:27:12 <lambdabot>   <no location info>: parse error on input `('
21:27:53 <Eduard_Munteanu> map `(.).(.)` length tails [1,2,3]
21:27:56 <Eduard_Munteanu> > map `(.).(.)` length tails [1,2,3]
21:27:57 <lambdabot>   <no location info>: parse error on input `('
21:28:14 <EvanR> no
21:28:14 <Eduard_Munteanu> > map (.) (.) length tails [1,2,3]
21:28:15 <lambdabot>   Couldn't match expected type `[a -> b]'
21:28:15 <lambdabot>         against inferred type `(a1 ...
21:28:26 <Eduard_Munteanu> Grr....
21:28:31 <Eduard_Munteanu> > map ((.) (.)) length tails [1,2,3]
21:28:31 <lambdabot>   Couldn't match expected type `[f (a -> b)]'
21:28:31 <lambdabot>         against inferred type `...
21:28:36 <EvanR> if you learn haskell this is what you have to look forward to on saturday night
21:28:55 <Eduard_Munteanu> :)
21:30:00 <EvanR> > let boobs = (.)(.) in map `boobs` length tails [1,2,3]
21:30:01 <lambdabot>   Couldn't match expected type `[a]'
21:30:01 <lambdabot>         against inferred type `[a1] -> [...
21:30:10 <EvanR> > let boobs = (.)(.) in (map `boobs` length) tails [1,2,3]
21:30:11 <lambdabot>   [3,2,1,0]
21:34:12 <Veinor> haha
21:34:35 <pelotom> @let boobs = (.)(.)
21:34:36 <lambdabot>  Defined.
21:34:57 <pelotom> boobs (*) 2 length "boobies"
21:35:02 <pelotom> > boobs (*) 2 length "boobies"
21:35:03 <lambdabot>   14
21:35:07 <EvanR> @let totalRecall = (.)(.)(.)
21:35:08 <lambdabot>  Defined.
21:35:11 <Eduard_Munteanu> :))
21:35:15 <pelotom> lol
21:35:20 <pelotom> makes me wish I had 3 hands!
21:35:36 <Eduard_Munteanu> Makes me wish I had two... nvm.
21:35:48 <EvanR> "you have first hand experience with this?" "first hand, second hand... and third hand"
21:36:35 <EvanR> (about the alien girls with three boobs)
21:37:11 <pelotom> EvanR: yeah, I got the reference ;)
21:37:26 <pelotom> TWO WEEKS!
21:37:41 <pelotom> what an incredible piece of cinema
21:39:31 <pelotom> @let twoChicksAtTheSameTime = boobs . boobs
21:39:32 <lambdabot>  Defined.
21:40:36 <Adamant> @let office = "office"
21:40:37 <lambdabot>  Defined.
21:40:47 <Adamant> @let space = "space"
21:40:48 <lambdabot>  Defined.
21:40:56 <Adamant> @let IBelieveThatWouldGetYourAssKicked = office ++ space
21:40:57 <lambdabot>  <local>:12:0:
21:40:57 <lambdabot>      Not in scope: data constructor `IBelieveThatWouldGetYourA...
21:41:04 <Adamant> ah, dangit
21:41:05 <Eduard_Munteanu> :D
21:41:16 <Adamant> @let iBelieveThatWouldGetYourAssKicked = office . space
21:41:16 <lambdabot>  <local>:12:45:
21:41:16 <lambdabot>      Ambiguous occurrence `space'
21:41:16 <lambdabot>      It could refer to eith...
21:41:23 <Adamant> meh
21:41:28 <Eduard_Munteanu> close
21:41:38 <Adamant> yeah, space is already definied
21:46:25 <sina> Guys, what is this problem? Non-exhaustive patterns in function ... ? it is basically function [] (_,_,_) (_,_,_) = []
21:47:07 <Eduard_Munteanu> sina: it means you're not covering all possible cases.
21:47:29 <Eduard_Munteanu> sina: the list might be non empty
21:47:42 <sina> oh right, I haven't considered (h:[]) !
21:47:57 <Eduard_Munteanu> sina: that's not all.
21:48:09 <Eduard_Munteanu> sina: h:[] is simply [h]
21:48:13 <stepcut> sina: or (h:i:[])
21:48:55 <Eduard_Munteanu> sina: _usually_, there's a pattern for [] and a pattern for (x:xs). That covers all cases.
21:49:12 <sina> I'm doing pattern for (h:t) and [] 
21:49:27 <Eduard_Munteanu> sina: that's ok.
21:49:54 <sina> so, what is wrong with the compiler ? :( surely theres something wrong with my code :D
21:50:08 <Eduard_Munteanu> sina: paste the code.
21:51:37 <sina> Eduard_Munteanu: http://hpaste.org/41239/ I guess the code is well complicated :-s
21:53:14 <Eduard_Munteanu> sina: hm...
21:53:20 <Eduard_Munteanu> Is that 'or' causing problems maybe?
21:53:21 <Eduard_Munteanu> :t or
21:53:22 <lambdabot> [Bool] -> Bool
21:53:40 <stepcut> nope
21:53:45 <stepcut> it is far more devious
21:53:52 <stepcut> he mispelled the last case
21:53:57 <stepcut> engimeEncodeMessage 
21:54:04 <stepcut> too many eeeees 
21:54:13 <sina> Eduard_Munteanu: dont think so. cause Im using it in another function.
21:54:25 <sina> stepcut: nice :D
21:54:34 <stepcut> also, engimeEncodeMessage
21:54:58 <stepcut> maybe you need a synonym for enigma that is easier to spell?
21:55:17 <stepcut> you have problems with a -> e, and with ig -> gi :p
21:55:45 <stepcut> maybe, riddle or soemthing
21:55:48 <stepcut> something
21:56:11 <sina> 5AM here. and I'm stuck with this thing...
21:56:25 <dominikh> could be worse. 6AM here
21:56:36 <Eduard_Munteanu> 7 :)
21:56:45 <Eduard_Munteanu> (almost)
21:56:54 <ManateeLazyCat> HI all. :)
21:57:02 * Eduard_Munteanu *waves*
21:57:14 <sina> what you guys working on then ? cause I need to deliver the project on monday
21:57:34 <Eduard_Munteanu> Nothing really here, just wasting nighttime.
21:57:40 <dominikh> same
21:58:20 <sina> stepcut: thanks for noticing the typo. I'm quite good in finding these, but it seems I'm quite tired right now. saved me lots of time debugging !! :) cheers
21:58:29 <stepcut> :)
21:58:46 <sina> Ok, I have an engima machine ready :D
21:59:18 <stepcut> I have made typos enough times myself to spot the issue :)
22:00:05 <dominikh> spotting typos in texts of others is easier than finding them in your own ones
22:02:19 <stepcut> dominikh: yeah, but in the case, when it looked like the patterns were all correctly matched, I explicitly thought that there must be a typo, and then looked to find it. So that helped
22:02:56 <dominikh> stepcut: what I said still holds true, though ;)
22:03:03 <stepcut> :)
22:05:55 <Eduard_Munteanu> I figure other top-level values can't be used / interfere with pattern matching, can they?
22:06:25 <Eduard_Munteanu> like that 'or' in there.
22:19:26 <Mitar> is it possible to redefine class instance?
22:20:58 <stepcut> Mitar: no..
22:21:23 <stepcut> Mitar: you mean, like a different, Show instance for Bool, for example?
22:21:52 <Mitar> yes
22:22:02 <Mitar> but for my classes
22:22:12 <Mitar> so that if i include one module, i have one class instance
22:22:19 <Mitar> if i include another, i have another
22:22:32 <Mitar> but that the second class instance builds on first ;-)
22:22:54 <Eduard_Munteanu> Mitar: are you talking about 'class' declarations or 'instance' declarations?
22:23:05 <Mitar> instance declarations
22:23:32 <Mitar> like, you would have multiple functions in class declaration
22:23:57 <Mitar> and i would like that in particular instance only one function is redefined and everything else stays the same as original instance
22:24:04 <Mitar> and then it would depend which module i include
22:24:09 <Mitar> that one would be in effect
22:25:16 <Eduard_Munteanu> Mitar: are you trying to mimick OOP?
22:25:23 <Mitar> probably ;-)
22:25:27 <Mitar> or just code reuse ;-)
22:25:53 <stepcut> Mitar: can't do that -- it would lead to insanity
22:26:06 <Mitar> and what is best practice?
22:26:08 <Eduard_Munteanu> Mitar: well you don't have to, you could just break one typeclass into multiple typeclasses.
22:26:32 <Eduard_Munteanu> Mitar: typeclasses in Haskell do not correspond to C++/Java classes.
22:27:12 <Eduard_Munteanu> and one typeclass can "inherit" another like this...
22:27:29 <Eduard_Munteanu> class (Bar a) => Foo a        -- Foo inherits Bar
22:28:03 <Eduard_Munteanu> which actually means "instances of Foo must also be instances of Bar"
22:28:27 <Mitar> yes, but then i cannot use that in functions which except only Foo
22:29:04 <Eduard_Munteanu> Br, I'm tired, Bar puts a constraint on a.
22:29:25 <Eduard_Munteanu> Mitar: then put another constraint on it.
22:29:50 <Eduard_Munteanu> Mitar: on the function I mean.
22:31:04 <sina> Guys, I have "type Sample = (String,String,String)->(Int,Int,Int)" and when I declare in type: function :: Sample -> result , and in the function I write: function (a,b,c) (d,e,f) = ... I get an error on type :(
22:32:06 <Eduard_Munteanu> sina: (a -> b) -> c isn't the same as a -> (b -> c) == a -> b -> c
22:32:18 <Eduard_Munteanu> sina: now you have the former
22:34:06 <Eduard_Munteanu> :t curry
22:34:07 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:34:14 <sina> Eduard_Munteanu: I don't understand . in the function, I cannot do : function ((a,b,c) (d,e,f))
22:35:14 <Eduard_Munteanu> sina: the type synonym there makes the signature of function expand to function :: ((String,String,String) -> (Int,Int,Int)) -> result
22:35:27 <Eduard_Munteanu> sina: that is, something that takes a function and returns something.
22:36:24 <Eduard_Munteanu> sina: so you don't / can't have two arguments for function that way, just one.
22:36:46 <sina> I need a type synonym or a data type that I can give (String,String,String) (Int,Int,Int) . what is the best way to do that?
22:37:34 <stepcut> ((String,String,String), (Int,Int,Int)) ?
22:39:25 <Eduard_Munteanu> Or a trivial tongue-in-cheek solution would be...
22:39:48 <Eduard_Munteanu> type MyType = (String,String,String) -> (Int,Int,Int) -> result
22:39:53 <Eduard_Munteanu> function :: MyType
22:39:54 <Eduard_Munteanu> :)
22:40:32 <sina> and what will I be able to pass to that function?
22:40:43 <Eduard_Munteanu> sina: to stepcut's, a pair.
22:41:02 <Eduard_Munteanu> sina: to mine, two arguments like you did
22:41:09 <sina> stepcut: that makes it a bit hard to pass variables to.
22:41:32 <sina> I basically have Char -> Sample -> Char . and in another function its String -> Sample - > String
22:41:55 <Eduard_Munteanu> sina: you can curry it
22:41:59 <Eduard_Munteanu> :t curry
22:41:59 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
22:42:03 <sina> so, should I make the whole thing a -> (String,String,String) -> (Int,Int,Int) -> a ?
22:42:21 <sina> what is curry ?
22:42:44 <Axman6> look at its type, and you tell us
22:42:46 <Eduard_Munteanu> sina: it transforms a function that takes a pair into a function that takes two arguments.
22:42:52 * Eduard_Munteanu ruined it
22:43:21 <Eduard_Munteanu> Bah, I should sleep.
22:43:26 <Eduard_Munteanu> Bye.
22:43:49 <sina> well, how to use it? :-s
22:44:01 <sina> Thanks a lot for helping Eduard. have a great sleep :)
22:48:53 <cma`> anyone have experience applying to CS grad school in the US?
22:58:36 <ksf_> Any sufficiently good coder is lazy enough to roll a bug-ridden, dynamically-type, impure and slow implementation of half of Haskell in all of his dysfunctional programs.
22:58:48 <ksf_> *roll out
22:59:05 <ksf_> +d
23:02:04 <SubStack> i do that.
23:02:42 <SubStack> laziness for node.js for instance
23:03:11 <ksf_> you can quote that as ksf's n+1th rule.
23:03:29 <ksf_> n+1th because I lost track of how many I tried to enmeme.
23:05:15 <Veinor> enmeme?
23:05:18 <Veinor> :P
23:09:45 <pankaj66866> this is awesome so many people on haskell irc
23:10:18 <Axman6> and they're all awesome!
23:10:23 <Axman6> go team!
23:11:18 <pankaj66866> This is the first time i m on this channel ... i didnt know that haskell is so active
23:11:46 <markwatson> Same here
23:11:55 <pankaj66866> Hmmmm....
23:12:40 <pankaj66866> sure looks like a good language
23:13:00 <pankaj66866> i mean the live haskell is awesome http://tryhaskell.org/#3
23:13:25 <markwatson> panka, it's not a good language it's like the best ever
23:13:47 <Axman6> pankaj66866: you should try out lyah:
23:13:50 <Axman6> @where lyah
23:13:50 <lambdabot> http://www.learnyouahaskell.com/
23:14:10 <dominikh> lyah is really nice so far
23:14:34 <pankaj66866> Its too early too say that ... i m from java world ... <Axman>
23:14:44 <dominikh> have to be honest though, I am only learning Haskell to have an edge over the other students at university (we are covering Haskell in a course)
23:14:59 <pankaj66866> <lamdabot> thanks for the link
23:15:08 <Axman6> lambdabot is a bot ;)
23:15:14 <dominikh> as the name.. suggests :P
23:15:18 <pankaj66866> Oh ....
23:15:49 <Axman6> dominikh: it was a university course that got me interested in haskell, and i've never looked back
23:17:03 <dominikh> Axman6: I'm failing to see what you'd use Haskell for, other than mathematical stuff (and xmonad...)
23:17:13 <dominikh> and since I really do not like math.. ;)
23:17:15 <pankaj66866> You guys are really active i dont see such a crowd in comp.lang.c
23:17:27 <Axman6> and writing compilers, and financial systems, and high ssurance systems and.. i could go on
23:17:34 <Axman6> assurance*
23:17:47 <Axman6> i don't like maths very much either
23:18:18 <pankaj66866> The facebook guys are using it for some high profile computing work thats what got me interested to have a look at this language
23:18:34 <Axman6> but my knowing of haskell has just gotten me an internship in Tokyo for three months writing haskell for a financial company
23:18:55 <pankaj66866> Hmmm ... <Axman6> impressive
23:19:36 <Axman6> dominikh: you should look at all the stuff Galois are doing with it. they've done work for various comercial and government agencies, including NASA
23:20:27 <dominikh> interesting
23:20:42 <Mitar> @pl max (abs $ (cos direction) * (positionY - targetY) - (sin direction) * (positionX - targetX)) offset
23:20:42 <lambdabot> max (abs (cos direction * (positionY - targetY) - sin direction * (positionX - targetX))) offset
23:21:30 <Axman6> you can't make something pointfree if it doesn't have any points (ie, arguments)
23:22:36 <luc_t> gents, I need help, I have broken my cabal stuff , probably by doing a cabal upgrade, now I have plenty of pkg-check issues ( still 6.12.3). how can I restart clean ? I tried and removed the .cabal file at user level , but not good enough. or is it because I tried and used the old cabal exe to boostrap the process again ? How can I clean the mess from scratch ?
23:22:41 <Mitar> ;-) i am just trying to see if i can get rid off all those ( )  ... i do not really like that (cos direction) thing, why there is not cos(direction) so that it would look more like mathematical notation
23:24:27 <luc_t> and to to make sure it is clean before i restart ? is pkg_check good enough ?
23:26:46 <Vicfred> Hello cjf and welcome to #haskell
23:32:14 <luc_t> any help to clean the cabal user base ?
23:35:04 <Axman6> luc_t: you can just remove .cabal if you want to remove everything installed with cabal-install, but that may also delete cabal-install
23:37:44 <luc_t> Axman6 thx , I didi that, unfortunately I have no cabal anymore. sO I tried using the old exe, to restart the process,  but not good enough. I also still have pkg_check issue even when no more .cabal . should I pastebin them ? or any idea how to restart from clean ?  5macOs)
23:48:49 <Jonno_FTW> @src unwords
23:48:49 <lambdabot> unwords [] = ""
23:48:49 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
23:49:43 <Jonno_FTW> > concatMap (++" ") $ words "thiese are some words"
23:49:44 <lambdabot>   "thiese are some words "
23:51:31 <ddarius> The typical mathematical notation for sine and cosine are exactly, cos x 
23:51:44 <Veinor> ddarius: ?
23:52:52 <ddarius> [01:22] <Mitar> ;-) i am just trying to see if i can get rid off all those ( )  ... i do not really like that (cos direction) thing, why there is not cos(direction) so that it would look more like mathematical notation
23:53:05 <Veinor> ah
23:53:11 <Jonno_FTW> > filter (\x-> not $ "http" `isPrefixOf` x) $ words "this are some link http://link.com"
23:53:11 <lambdabot>   ["this","are","some","link"]
23:53:15 <ddarius> And furthermore you can write f(x) in Haskell.  It's unnecessary, but it will always work.
23:53:29 <Mitar> you can?
23:53:38 <Veinor> > succ 2
23:53:38 <lambdabot>   3
23:53:40 <Veinor> > succ (2)
23:53:40 <lambdabot>   3
23:53:41 <flux> mitar, (x) is the same as x
23:53:46 <Mitar> true
23:53:51 <Mitar> but priority is not the same
23:54:00 * hackagebot http-enumerator 0.2.0.4 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.0.4 (MichaelSnoyman)
23:54:05 <Mitar> > succ 2 * 4
23:54:06 <lambdabot>   12
23:54:20 <flux> mitar, well, you need to decide what you mean
23:54:25 <Mitar> i have to find some other example ;-)
23:54:33 <flux> mitar, I doubt foo(x) will ever give unexpected results..
23:54:43 <flux> (unless your expectations vary from mine, of course ;-))
23:54:44 <Mitar> foo(x)^2?
23:54:54 <Mitar> > succ(2)^2
23:54:55 <lambdabot>   9
23:54:59 <ddarius> That will behave just like foo x ^ 2
23:55:00 <Mitar> hmm
23:55:09 <flux> function application has high precedency
23:55:11 <ddarius> Application always binds tightest.
23:56:36 <Mitar> i always had problems with show and ++
23:56:55 <Mitar> so i got used to adding () around everything
23:58:01 <ddarius> Mitar: You shouldn't have had any problems.  I suspect you had problems with ($) and (++).
23:58:08 <[swift]> > show $ "a" ++ "b" ++ "c"
23:58:09 <lambdabot>   "\"abc\""
23:58:09 <Mitar> hmm, maybe
23:58:20 <luc_t> hm , i reinstall the platform and still pkg_check gives me issues . where is the file of registered package ? ( i did cleaned .cabal)
23:58:26 <Mitar> more like
23:58:37 <Mitar> > "a" ++ show "b" ++ "c"
23:58:38 <lambdabot>   "a\"b\"c"
23:58:42 <Mitar> hmm, also works
