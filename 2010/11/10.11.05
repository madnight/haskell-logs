00:23:25 <ManateeLazyCat> Axel is converting gtk2hs darcs to darcs2 format, after that, we will relase gtk2hs-0.12.0 today. Still have bug need report? We will fix it before release new version. Thanks! :)
00:23:25 <lambdabot> ManateeLazyCat: You have 1 new message. '/msg lambdabot @messages' to read it.
00:25:04 <ManateeLazyCat> @tell aristid auto-complete elisp extension just little trick, i will show you what is wonderful code-completion . :)
00:25:04 <lambdabot> Consider it noted.
01:06:11 <Razz_DK> Need some advice: I'm writing an interpreter which will evaluate a set of statements for each element on the list of inputs. However, I want to put the current input value in the State and then evaluate the statement. How would I go about applying this to all the input values?
01:08:18 <augur> anyone know about computer vision?
01:08:34 * Razz_DK has heard of it :-P
01:09:01 <Saizan> Razz_DK: mapM?
01:10:20 <Razz_DK> Saizan: right, but how do I take the current value of the input and put it in the state and _then_ call a function to evaluate all necessary statements with that (current) state?
01:10:53 * Razz_DK is not sure on the necessary structure for doing such a thing
01:12:37 <Saizan> mapM (\i -> do put i; evaluate statements) inputs ?
01:13:04 <Saizan> these are wild guesses of course
01:13:35 <Razz_DK> hmm, yeah that should work :-P, thx
01:13:42 * Razz_DK is a bit new to haskell and state in haskell
01:16:30 <Axman6> Razz_DK: it's not real state, be careful!
01:19:01 <Razz_DK> Axman6: yeah, thx :-)
01:25:17 <Razz_DK> To be honest, there is still one thing in the given solution that is missing: how do I pass the initial state to it? In the same function the initial state is constructed and this will in essence be the aggregator for the eventual output.
01:28:24 <Axman6> Razz_DK: use runState foo init (i think)
01:28:42 <c_wraith> runState just remvoes the newtype wrapper.
01:28:45 <pelotom> :t runState
01:28:45 <lambdabot> forall s a. State s a -> s -> (a, s)
01:28:45 <Axman6> @hoogle State s a -> s -> s
01:28:46 <lambdabot> Control.Monad.State.Lazy execState :: State s a -> s -> s
01:28:46 <lambdabot> Control.Monad.State.Strict execState :: State s a -> s -> s
01:28:46 <lambdabot> Control.Monad.State.Lazy evalState :: State s a -> s -> a
01:28:55 <pelotom> >t runState
01:28:56 <c_wraith> @src State
01:28:56 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:29:00 <pelotom> blah
01:29:02 <Axman6> :t runState
01:29:03 <lambdabot> forall s a. State s a -> s -> (a, s)
01:29:06 <pelotom> @type runState
01:29:07 <lambdabot> forall s a. State s a -> s -> (a, s)
01:29:10 <Axman6> :t execState
01:29:11 <lambdabot> forall s a. State s a -> s -> s
01:29:17 <Razz_DK> thx :-)
01:29:30 <c_wraith> As you can see, runState really does just remove the wrapper, exposing the underlying function s -> (a, s)
01:29:43 <c_wraith> that's how I remember what order the arguments to runState go in :)
01:29:51 <Razz_DK> :-)
01:31:15 <pelotom> this comment is hilarious: http://www.reddit.com/r/programming/comments/e0qqc/learn_you_a_haskell_zippers/c14g7r1
01:33:21 <Zeiris> The haskell-erlang FFI is broken :(
01:41:17 <Zeiris> AHHAHA i TAKE IT BACK erlang-haskell FFI works :D
01:41:32 <Zeiris> The error handling is non-existent and messages cryptic, but I just got some kind of response!
01:50:10 <FunctorSalad_> pelotom: from that thread: "Clojure has zippers, and it's the common way of navigating through XML structures." \\\\ do we have that? :p
01:50:30 <FunctorSalad_> not a Q specifically to you obviously
01:51:29 <pelotom> I dunno, I've never dealt with xml in haskell
01:51:46 <pelotom> seems like a great use case
01:51:56 <FunctorSalad_> yeah
01:57:55 <FunctorSalad_> "This is how Yukari is said to have invaded the moon - by manipulating the border between truth and lies, as applied to the reflection of the moon on a pond, she was able to make the reflection of the moon into a manifestation of the actual moon, and so send her Haskell nomad army onto it."
01:58:03 <FunctorSalad_> (who is yukari?)
01:59:20 <Veinor> what the
02:01:11 <FunctorSalad_> pretty clever actually :)
02:01:54 <FunctorSalad_> it just takes the freedom to state something it admits in the previous sentence is a lie, in indicative form
02:02:53 <FunctorSalad_> or actually it admits it's just a 'manifestation' of the actual moon
02:03:13 <FunctorSalad_> nevermind me
02:04:02 <pelotom> wtf?
02:04:16 <pelotom> :)
02:05:43 <Jafet> @quote reddit
02:05:43 <lambdabot> samlee says: [via Reddit] haha those ghc options are longer than actual program
02:05:47 <pelotom> that guy is looney tunes
02:12:52 <pelotom> FunctorSalad_: apparently Yukari is the "youkai of boundaries": http://touhou.wikia.com/wiki/Yukari_Yakumo
02:21:24 <Veinor> oh, a touhou reference
02:23:00 <RayNbow`TU> http://www.haskell.org/haskellwiki/Video_presentations#Commercial_users  <--  hmm, the link to the Paradise talk is dead... :/
02:26:00 <lars9> :src forever
02:26:03 <Toxaris> At the Haskell symposium a month ago, the talks where videotaped. Are these vidoes available somehow?
02:26:06 <lars9> @src forever
02:26:07 <lambdabot> Source not found. I feel much better now.
02:26:31 <lars9> @src Control.Monad.forever
02:26:31 <lambdabot> Source not found. My mind is going. I can feel it.
02:27:17 <companion_cube> :)
02:27:58 <lars9> > forever $ putStr "hi"
02:27:59 <lambdabot>   Ambiguous type variable `b' in the constraint:
02:27:59 <lambdabot>    `Data.Typeable.Typeable b...
02:28:27 <quicksilver> that's an odd error message.
02:28:44 <quicksilver> @type forever $ putStr "hi"
02:28:45 <lambdabot> forall b. IO b
02:28:49 <quicksilver> A bit more useful.
02:29:50 <lars9> > forM [1..10] $ print
02:29:51 <lambdabot>   <IO [()]>
02:30:03 <lars9> > forM_ [1..10] $ print
02:30:04 <lambdabot>   <IO ()>
02:30:31 <lars9> > forM_ [1..10] print
02:30:32 <lambdabot>   <IO ()>
02:30:52 <pelotom> > forever [9]
02:30:53 <lambdabot>   *Exception: stack overflow
02:31:29 <lars9> wow, it does overflow ^_^
02:31:41 <Saizan> depends on the monad
02:32:01 <lars9> i thought bot can prevent that
02:33:29 <pelotom> > let i1ab = forever ["young"]
02:33:30 <lambdabot>   not an expression: `let i1ab = forever ["young"]'
02:34:16 <pelotom> > let i1ab = forever "young"
02:34:17 <lambdabot>   not an expression: `let i1ab = forever "young"'
02:34:21 <lars9> is modifySTRef ST efficient? i mean in the same order of assignment in c/java
02:34:28 <kalven> hah
02:34:42 <pelotom> > let iwannabe = forever "young"
02:34:43 <lambdabot>   not an expression: `let iwannabe = forever "young"'
02:34:47 <pelotom> fooey
02:34:51 <quicksilver> lars9: modifySTRef is only changing a pointer.
02:35:23 <quicksilver> which is certainly the same order of magnitude as assignment, 
02:35:33 <quicksilver> however the function you apply may or may not be fast.
02:35:33 <lars9> quicksilver: is it implemented in a pure way internally?
02:35:46 <quicksilver> I'll tell you a secret.
02:35:58 <quicksilver> the haskell compiler runs programs on a conventional CPU
02:36:05 <quicksilver> therefore, it does mutation all the time
02:36:13 <quicksilver> purity is a property of the language, not the implementation.
02:36:23 <quicksilver> the implementation does whatever it wants to get the correct behaviour
02:36:37 <pelotom> *covers ears* LIES!
02:37:16 <paolino> @let iwannabe = forever "young"
02:37:18 <lambdabot>  Defined.
02:37:18 <Philippa> in fact, it /can't/ be implemented in a way that doesn't produce heat :-)
02:37:35 <silver> > iwannabe
02:37:37 <lambdabot>   *Exception: stack overflow
02:37:44 <silver> > take 2 iwannabe
02:37:45 <lambdabot>   *Exception: stack overflow
02:37:49 <quicksilver> (one of) the basic operational steps in (many/most popopular implementations of) lazy languages implementaiton is thunk-updating, which is inherently a mutation concept.
02:38:01 <lars9> yeah, i'll change my question, can ST be implemented with a pure core of haskell language set?
02:38:05 <quicksilver> lars9: no.
02:38:11 <quicksilver> although for rather annoying reasons.
02:38:30 <quicksilver> if you restrict the types of the references you're allowed to create it works fine.
02:38:42 <quicksilver> but 'newSTRef' which can create a new reference of any type, is tricky.
02:38:50 <pelotom> @let i wanna be = forever "young"
02:38:51 <lambdabot>  Defined.
02:38:53 <quicksilver> this isn't really a purity thing; it's an annoying expressitivity gap.
02:39:14 <pelotom> > i "am" "old"
02:39:14 <quicksilver> if you restricted newSTRef to work on a finite set of types (any finite set of types) you could do it.
02:39:15 <lambdabot>   Ambiguous occurrence `i'
02:39:15 <lambdabot>  It could refer to either `L.i', defined at <local...
02:39:25 <lars9> pelotom: even a bot knows that you can not be forever "young"
02:39:27 <quicksilver> or bound it by an appropriate typeclass.
02:39:46 <Saizan> or you could go wild with unsafeCoerce
02:39:49 <quicksilver> Typeable sort-of works but arguably Typeable itself is cheating.
02:39:52 <pelotom> I put the "young" in ironic quotes, it should be able to detect irony
02:40:04 <quicksilver> Saizan: the question was "...pure core of haskell language set"
02:40:32 <lars9> quicksilver: oh really, with a pure core ST s Int can be implemented?
02:40:36 <hape_> Hi, HaRe (Haskell Refactorer) means, it needs "hint-0.3.2.3" - currently I have 0.3.3.0 installed (cabal info hint). Now when I try  "cabal install hint-0.3.2.3"  he says  "...libHSCabal-1.8.0.2.a: could not read symbols: Malformed archive..."  What could I do?
02:41:57 <lars9> quicksilver: how can a pure core modify the value associated with a name?
02:42:18 <Saizan> quicksilver: right, and "pure core" is not so well defined
02:42:19 <quicksilver> lars9: I didn't say ST s Int.
02:42:29 <quicksilver> lars9: I said you'd have to restrict the type of newSTRef.
02:42:53 <quicksilver> lars9: you wouldn't 'modify' anything - you'd just keep around a Data.Map (or similar structure)
02:43:13 <pelotom> hape_: did you install HaRe thru cabal or by making it per the instructions?
02:43:15 <quicksilver> and keep creating new versions of that map in the normal pure immutable way.
02:43:25 <quicksilver> Saizan: true :)
02:43:45 <Saizan> hape_: sounds like your installation of the Cabal library is screwed up
02:44:52 <lars9> quicksilver: lets say newSTRef Int, then how can modifySTRef aVar aFunction change the value of aVar?
02:45:24 <quicksilver> lars9: your implementation maintains a Map RefID Int for the STRef Ints
02:45:40 <quicksilver> lars9: where 'RefID' is some private type of your implementation used to distinguish different references.
02:45:51 <quicksilver> when something wants to 'change' a reference you just generate the new Map
02:45:59 <quicksilver> in which that reference is mapped to a new value.
02:46:59 <lars9> oh so it's like Monad, after every modifySTRef, the var is not changed, but env changed?
02:47:20 <quicksilver> I'm afraid I can't make any sense of that question.
02:47:22 <quicksilver> "like Monad"
02:47:23 <hape_> Saizan: When the Cabal Library is screwed up, I should purge it somehow I guess...
02:47:24 <quicksilver> ST is a monad, yes
02:47:32 <quicksilver> our pure implementation of it will still be a monad.
02:47:35 <quicksilver> that would be the point.
02:48:01 <lars9> quicksilver: or like generating random number using State Monad, internal state is changed
02:48:11 <quicksilver> yes, like that.
02:48:13 <lars9> after gnerating a random number
02:48:16 <quicksilver> nothing is really mutated.
02:48:20 <Saizan> hape_: you might need to reinstall ghc if it's the Cabal that came with it
02:48:29 <quicksilver> it's just an abstraction around functions/parameter passing
02:49:07 <lars9> quicksilver: i see, and since updating a Map is O(LogN), it shoulbe be efficient when number of STRef is not too large
02:49:11 <hape_> Saizan: ok I should try this
02:54:59 <quicksilver> lars9: right.
03:01:21 <_mpu> @pl (\x -> f (g x 3))
03:01:21 <lambdabot> f . flip g 3
03:04:20 <_mpu> > square 3
03:04:21 <lambdabot>   Not in scope: `square'
03:04:36 <_mpu> @pl (\x -> x * x)
03:04:36 <lambdabot> join (*)
03:04:53 <danr> > (*) <*> 3
03:04:54 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
03:04:54 <lambdabot>    arising from a use of `...
03:05:22 <_mpu> @pl (\(x, y) -> (f x, g y))
03:05:22 <lambdabot> f *** g
03:05:39 <_mpu> :t (***)
03:05:40 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
03:06:21 <_mpu> :t join
03:06:21 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:08:18 <RayNbow`TU> hmm
03:08:25 <RayNbow`TU> > let x = 3 :: Int -> Int in x undefined
03:08:26 <lambdabot>   3
03:11:37 <Azrael-> > let x = x in x
03:11:41 <lambdabot>   mueval-core: Time limit exceeded
03:11:50 <lars9> @pl \(_,x,_) -> x
03:11:50 <lambdabot> (line 1, column 6):
03:11:51 <lambdabot> unexpected ","
03:11:51 <lambdabot> expecting letter or digit, operator or ")"
03:11:51 <lambdabot> ambiguous use of a non associative operator
03:12:18 <lars9> @pl (\(_,x,_) -> x)
03:12:19 <lambdabot> (line 1, column 7):
03:12:19 <lambdabot> unexpected ","
03:12:19 <lambdabot> expecting letter or digit, operator or ")"
03:12:19 <lambdabot> ambiguous use of a non associative operator
03:15:31 <quicksilver> lars9: @pl doesn't do triples.
03:15:39 <quicksilver> its parser doesn't even cope
03:15:53 <quicksilver> (but if it did, it would be no use - there are no triple destructors in the standard lib)
03:16:24 <quicksilver> I must admit, personally, I find (\(_,x,_)->x) is just about the most sensible way to write that function.
03:18:15 <dancor> class HasASecondPart a where getSecondPart
03:18:47 <dancor> i guess you still have to define the function
03:19:18 <_mpu> which module holds join ?
03:20:07 <quicksilver> Control.Monad
03:20:12 <dancor> _mpu: ghci ":i join" says.. ya
03:20:12 <quicksilver> @index join
03:20:12 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
03:20:53 <dancor> _mpu: http://www.haskell.org/ghc/docs/6.12-latest/html/users_guide/ghci-commands.html
03:21:22 <lars9> quicksilver: got it, thanks
03:22:13 <_mpu> thanks
03:22:27 <_mpu> :t join
03:22:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
03:22:53 <dancor> i guess there is no list of lambdabot commands with descriptions, might just have to grab the source
03:23:13 <dancor> @yhjulwwiefzojcbxybbruweejw test
03:23:14 <lambdabot> Just 'J'
03:31:26 <Botje> O_o
03:43:42 <Razz_DK> I'm kinda stuck on building an interpreter. I've defined a datatype State containing a couple of values and a monad for preserving the state throughout execution. Now I have list of statements that need to be evaluated, each might update the state. And the statements need to be evaluated given an input value. Where do I set the initial state so all following computations can go on? My monad is defined like this: newtype Rip a = Rip ( State -> Either String (a
03:44:45 <lars9> does "module Bracketed (parseArg) where" imply that parseArg is the only function exposed from this module? other functions are hidden?
03:44:50 <sipa> -> Either String (a[...]
03:44:56 <sipa> Razz_DK: your sentence was cut off
03:45:07 <sipa> lars9: yes
03:45:12 <lars9> sipa: thanks
03:45:48 <sipa> you can list functions/values, types and constructors as exported
03:46:00 <sipa> class instances are always exported i believe
03:46:01 <bastl> For a presentation I need strong short arguments for "pure functions". I have: Composition, Testing and Distribution. Anything else ??
03:48:25 <lars9> sipa: what is "class instances"? the definition of a class, or "Instance Eq MyType where"?
03:48:38 <sipa> lars9: the second
03:48:42 <Razz_DK> newtype Rip a = Rip ( State -> Either String (a, State) ) (with State  handmade).
03:49:11 <sipa> lars9: classes can be exported/hidden as well
03:49:14 <merijn> bastl: Distribution already covers concurrency?
03:49:52 <bastl> i thought so, but that seems not to be clear.
03:50:03 <lars9> sipa: i see, so i just need to export MyType, then everyone knows it's an instance of Eq?
03:50:07 <alpounet> bastl, I would suggest putting an emphasis on the fact that it "forces" to separate data types and algorithms on them on one side, and making this interact with the world on the other side
03:50:15 <sipa> lars9: indeed
03:50:19 <lars9> sipa: thanks
03:50:59 <merijn> alpounet: Not everyone would agree that's actually an argument for pure functions
03:51:25 <bastl> merijn: i htink the point is the "it forces"
03:51:36 <bastl> you can do it woithout, but you dont have to.
03:51:37 <alpounet> yeah, that's not precisely about them but somehow is close
03:52:19 <merijn> bastl: Yes, but the OO heathens think separation of data types and algorithms is a bad thing, so depending on who the presentation is for it might not be a sensible argument
03:52:35 <bastl> exactly :-)
03:52:57 <bastl> but I dont want to convince anyone. I just want a good presentation :-)
03:53:19 <Vanadium> At least the C++ OO faction is perfectly fine with putting the algorithms elsewhere
03:53:30 <Vanadium> They have a separate <algorithms> header!
03:54:14 <ville> Vanadium: the algorithms are actually from the generic programming faction, not the OO faction.
03:55:48 <lars9> and template in c++ is too weak
03:56:52 <lars9> plus, currently cpp has no support for annonymous lambda, so foreach(...) is really hard to use in cpp.
03:57:23 <knobo> where can I find out what  DeriveDataTypeable means?
03:57:42 <ville> Enter the next standard, coming to compiler near you and already available at select compilers.
03:57:46 <lars9> after learning haskell, i really dislike cpp's functional part anymore
03:58:18 <teratorn> http://www.physorg.com/news/2010-10-celebrates-25th-anniversary.html
03:58:29 <Vanadium> ville: With C++0x's extended for-loops, when would you use for_each anymore?
03:58:34 <teratorn> remember kids, you too can spend 6 years of your life and destroy computer science
03:58:46 <ville> Then again I don't like anonymous lambdas at all.
03:58:49 <lars9> ville: you still can not compose functions like map (f.g.h) 
03:59:19 <Vanadium> You can probably get relatively close with boost.bind
03:59:39 <quicksilver> knobo: it is an extension which permits 'deriving Data' and 'deriving Typeable'
03:59:46 <Vanadium> The fact that the implementation of bind is slightly less straightforward than that of . is irrelevant, hopefully
04:00:04 <lars9> mimiced is not as good as built-in
04:00:15 <quicksilver> knobo: http://haskell.org/ghc/docs/6.12.2/html/users_guide/deriving.html#deriving-typeable
04:00:30 <quicksilver> Vanadium: irrelevant until you get an error message :)
04:00:31 <Vanadium> @src (.)
04:00:31 <lambdabot> (f . g) x = f (g x)
04:00:31 <lambdabot> NB: In lambdabot,  (.) = fmap
04:00:56 <Vanadium> quicksilver: I spent about half an hour last night poking at a friend's attempt to pass a bind-constructed functor along to another generic function
04:00:56 <quicksilver> not that GHC's error messages are great, but C++ error messages when using a many-layered template library are ouch.
04:00:58 <knobo> thanx
04:01:22 <teratorn> quicksilver: c++ is Enterprise what are you talking about
04:01:47 <teratorn> quicksilver: the fact that you don't appreciate a 3-page error message just shows your ignorance
04:01:59 <quicksilver> enterprises don't use templates
04:02:00 <quicksilver> ;)
04:02:13 <quicksilver> enterprises generally use C++ features from 1979.
04:02:22 <quicksilver> game companies, perhaps, 1984.
04:02:39 <teratorn> but seriously, if I ever find a time machine the first thing I'm doing is going back and breaking Stroustrups fingers
04:03:02 <lars9> i think a good language should let user focus on what they care about, haskell is really good at that.
04:04:27 <Vanadium> teratorn: Please do not, I would rather have C++ than be stuck with C for, well, what C/C++ are popular for
04:05:29 <Razz_DK> How does one make a function that will update a state given a set of statements? How does it get the initial state? Should I pass it to the function or?
04:05:38 <teratorn> C is great, and now there is Vala, or Obj-C if you like that sort of thing
04:05:58 <Razz_DK> statements being a tree structure I need to parse and alter state given certain situations
04:06:08 <lars9> is there any practice to use haskell in distributed system? a claim point of purity is it's easy to get concurrency 
04:06:30 <Vanadium> But I like the C++ sort of thing :)
04:06:46 <Saizan> Razz_DK: a very simple way would be to take it as an argument and return the updated version as part of the result of the function
04:06:55 <Vanadium> The whole RAII thing where you can turn a lot of stuff into mindless-to-use value types is more fun than writing 'new' every other line
04:07:17 <teratorn> Vanadium: I kinda like C++ too, but I recognize that sick, masochistic part of my ego, and fight against it
04:07:17 <Razz_DK> Saizan: ok
04:07:33 <Saizan> Razz_DK: some experience with this style would probably help you learn, even if it might get tedious
04:08:10 <lars9> personally i prefer python + c. initially all in python and then convert the threshold part to a pure piece of c code
04:08:32 <teratorn> I mean, C++ is just really a _terrible_ language... http://yosefk.com/c++fqa/defective.html
04:08:49 <Razz_DK> Saizan: the state may be alterede by other function too, (monadic) functions that don't 'take' a state as an argument how do I make sure those have access to the current state/
04:08:59 <teratorn> if it never existed something better would have filled the gap
04:09:27 <teratorn> lars9: yeah that's a pretty good strategy
04:09:45 <quicksilver> Vanadium: but then the problem with RAII is that it's a leaky abstraction, and you find yourself needing to understand the plumbing more often than you'd like; i.e. the promise of being 'mindless' isn't entirely fullfilled.
04:10:03 <quicksilver> Vanadium: for example, STL containers of RAII value types probably don't work.
04:10:22 <Saizan> Razz_DK: unless you're in IO state doesn't really get mutated, the State monads merely hides the passing of the state as an argument behind the scenes
04:10:48 <quicksilver> Vanadium: and correct understanding of constructor, copy constructor, move constructor, and operator=, is, well, something that requires a couple of coffees and a following wind ;)
04:10:50 <Saizan> Razz_DK: you can expose that fact with runState
04:11:06 <Razz_DK> Saizan: right, thx
04:11:21 <Vanadium> quicksilver: A couple of coffees and a following mind is probably conductive to picking up any wortwhile language
04:11:38 <quicksilver> Vanadium: sure. But I think you see my point.
04:12:05 <quicksilver> Vanadium: the more you have to understand the four different senses of construction, the less mindless your RAII pattern is.
04:12:29 <Vanadium> The point is that I just declare a variable somewhere. The other guy, who wrote the type, has to keep those straight, not me.
04:12:56 <quicksilver> until you try to put it in an STL container.
04:13:06 <quicksilver> or, in some cases, even pass it to a function.
04:13:24 <Vanadium> The other guy would probably advertise whether this type is copyable.
04:13:32 <Vanadium> It is like an informal typeclass!
04:13:38 <FunctorSalad_> c++ sounds very scary.
04:14:01 <Vanadium> C++ is a very elaborate exercise to let people define types that are as easy to use as C's ints
04:14:25 <Vanadium> Somewhere along the way, the "easy to use" thing probably got dropped in favour of a bunch of "wouldn't it be cool if" considerations.
04:14:56 <aristid> ah, another funny c++ discussion
04:14:56 <lambdabot> aristid: You have 1 new message. '/msg lambdabot @messages' to read it.
04:15:20 <FunctorSalad_> Vanadium: ah yes, I read that in the history of programming languages "bolted everything he's ever heard of onto C"
04:15:39 <quicksilver> Vanadium: I think two two remarks "like an informal typeclass!" and "probably got dropped in favour of a bunch of "wouldn't it be cool if" considerations" between them actually say a lot of what I was trying to say ;)
04:15:57 <quicksilver> however, this is drifting off-topic :)
04:16:22 <FunctorSalad_> we have zeh #haskell-blah
04:16:27 <Vanadium> quicksilver: I think my original point is that C++ is pretty good at what it is trying to be, and in some of the places that C++ wants to be good I would probably rather use C++ than not, even if haskell was theoretically an option
04:16:52 <Vanadium> Hopefully that will change as I get more comfortable with Haskell.
04:17:09 <teratorn> there isn't any sane reason to ever use C++ for anything, except maybe if you work in the video game industry
04:17:17 <teratorn> for new development, I mean
04:17:26 <Starfire> I think the worst things about C++ are the nonexistent module system and the horrible error messages.
04:17:54 <Vanadium> The horrible error messages are probably mostly a consequence of the template duck typing
04:18:29 * frerich6 wonders what happened that the quality of discussions in this channel degraded all of a sudden
04:19:07 <Vanadium> Jeez, excuse me.
04:19:09 <geheimdienst> frerich6: i came in 3 minutes ago. does that correlate ...?
04:19:16 <quicksilver> frerich6: not enough people asking interesting haskell questions?
04:19:29 <quicksilver> although programming language ponderings are not really that badly off-topic
04:19:39 <frerich6> geheimdienst: It correlates, but I don't think there's a causality :-)
04:20:01 <Vanadium> It is probably more fun to get mad at C++ than spend the entire time being all "yeah, that haskell, sure is cool, huh"
04:23:58 <frerich6> Ok, so here's a Haskell question: I recently saw a mail in the haskell-cafe mailinglist archives which pointed out an XSLT (a language for transforming XML documents) implementation in Haskell (part a thesis done in 2001). I was wondering - is there a Haskell framework which can *replace* XSLT?
04:25:12 <frerich6> I like XSLT for the declarative approach to specifying transformations, but the language (at least in earlier versions) isn't very powerful. I imagine having a Haskell module which allows specfying transformations for XML documents would be much more potent.
04:25:18 <frerich6> I couldn't find anything like that up to now.
04:25:33 <quicksilver> frerich6: yes.
04:25:45 <quicksilver> frerich6: haxml and hxt can both do the kind of things that XSLT can do.
04:30:36 <frerich6> quicksilver: Hmm - are you aware of any example code which uses either to translate an XML document into something else - a task which XSLT was designed to be used for?
04:34:15 <Saizan> you'd probably have to implement the equivalent of XSLT dispatch on tags on top of those if you want to go that style
04:35:28 <quicksilver> frerich6: http://www.ibm.com/developerworks/xml/library/x-matters14.html
04:35:42 <quicksilver> and the references section of that column
04:36:05 <quicksilver> HXT actually has direct XSLT support, but that's not what you're after.
04:36:26 <frerich6> quicksilver: That looks interesting - now I wonder: how did you find that page? :-)
04:36:34 <quicksilver> I googled 'haxml xslt'
04:36:41 <quicksilver> although I have read that page before, in fact
04:36:46 <quicksilver> so I recognised it when it came up.
04:36:54 <frerich6> Hm I think I used those key words as well but maybe I overlooked that hit.
04:36:57 <frerich6> How embarrasing.
04:37:50 * zygoloid thinks this channel would benefit from less time spent bashing c++
04:38:07 <geheimdienst> zygoloid: let's not drag bash into this
04:39:18 <quicksilver> frerich6: HXT views itself as an enhanced HaXML, but the HaXML author continues to maintain HaXML which make some different design tradeoffs.
04:39:34 <quicksilver> the haxml author used to be a regular visitor to this channel but less so, recently
04:39:38 <quicksilver> @seen malcolmw
04:39:38 <lambdabot> Unknown command, try @list
04:39:38 <preflex>  malcolmw was last seen on #ghc 101 days, 14 hours and 13 seconds ago, saying: full sigs would be my preference
04:42:45 <frerich6> quicksilver: Thank you a lot for that link; the small example discussed in the article is exactly the kind of Haskell program I Was after. The links at the bottom of the page are useful, too.
04:43:15 <quicksilver> good :)
04:43:20 <quicksilver> a small example is worth 1000 words.
04:49:04 <gal_bolle> hi all, is console-program usable/alive? Its patch-tag repository gives an happstack error. Is it preferred over cmdargs?
04:51:52 <arcatan> gal_bolle: i've never used console-program, but cmdargs has been very nice to use for my simple needs and it at least is alive
04:52:26 <gal_bolle> thanks
05:01:06 <ketil> Okay.  Hackage complains that if I use Cabal >= 1.6, I need to use "section syntax".  And please see the documentation.
05:01:37 <gal_bolle> it seems community.haskell.org is down
05:02:05 <ketil> Google is, as usual, not giving any relevant results for things like "cabal documentation section syntax" and similar.
05:02:29 <arcatan> how can community.haskell.org be always down?
05:03:41 <lispy> arcatan: good question.  I think one of the maintainers is out of town at the moment
05:03:45 <quicksilver> ketil: http://www.haskell.org/ghc/docs/6.12.2/html/Cabal/index.html ?
05:03:54 <Saizan> ketil: i think the current docs show only the section syntax
05:04:24 <ketil> Okay. naive as I am, I searched for 'section' in the docs, but it isn't there.
05:05:09 <ketil> So this is just something I'm supposed to *know*?  After cabal working for ages, it suddenly breaks, and the error message points to documentation that doesn't , well document.  
05:05:12 <Saizan> http://www.haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html#configurations <- e.g. like there, with the separate Library/Executable sections
05:05:13 * ketil is frustrated.
05:05:33 <arcatan> ketil: could you paste you .cabal file?
05:06:16 <quicksilver> ketil: the word section appears many times in http://www.haskell.org/ghc/docs/6.12.2/html/Cabal/authors.html#library
05:06:32 <quicksilver> ketil: admittedly, some uses are, annoyingly, about the structure of the docoument
05:06:40 <quicksilver> but the ones that aren't, are the correct sense of 'section'
05:31:39 <Saizan> the error message should probably avoid mentioning sections: "you need to use the new syntax"
05:49:47 <jkramer> Ahoy
05:51:00 <jkramer> I'm looking for a module that helps me mapping hashes [(String, String)] to records and back
05:51:23 <jkramer> More specifically, I want to map records loaded with Database.MongoDB to native haskell records
05:51:31 <jkramer> Is there anything like that?
05:51:34 <zomg> I wrote a function to do that
05:51:44 <zomg> but it's specific to the type of record I use, and not generic
05:52:05 <zomg> I don't know if you can make it generic since I'm kinda noob'ish in Haskell =)
05:52:47 <jkramer> I've tried writing something generic, but the label names of haskell records not being adressable is a problem :)
05:53:03 <ketil> Hm.  Remove : after 'Executable', and indent stuff following it seems to suffice.  (And move build-depends into the executable section, but only for one of the executables?)
05:55:42 <EvanR> arg generic is the word of the day!
05:59:57 <Jonno_FTW> is there any guides on writing plugins for lambdabot ?
06:00:31 <Axman6> the code of other plugins should serve as a good guide
06:01:14 <Jonno_FTW> but I'm not that good at reading them
06:01:15 <zomg> jkramer: quick googling seems to indicate that the labels aren't first class and thus wouldn't be addresable in any general way
06:01:19 <zomg> I could be wrong though
06:01:20 <Jonno_FTW> to be able to find out what's going on
06:09:38 <jkramer> zomg: That's what I meant, that's the problem :)
06:11:29 <paolino> is there a function for TH that renames the names in an Exp like the rename in the TH.Lib which renames the names in a Pat ?
06:13:26 <paolino> I wonder if there is something wrong with it
06:16:34 <paolino> yes, there is
06:23:26 <Paranoid_> Hello all, I am new to Functional Programming and trying to work through the basics from the Richard Bird book. I am just seeking some advice as to a certain exercise I am looking at (I am not asking for an answer to the exercise). The exercise asks us to define a function remdups such that adjacent duplicates from lists are removed. I have successfully done so apart from a minor detail, that it does not work unless I set the e v
06:24:05 <Axman6> unless you do what?
06:24:07 <Paranoid_> Note: remdups must be defined using foldr or foldl - I am using foldr
06:24:44 <Paranoid_> unless I say foldr g [0] xs, it won't work - but ideally I want to simply say [] instead of [0]
06:25:17 <Axman6> i'd use foldl, and reverse if you're allowed to
06:25:40 <Axman6> :t foldl
06:25:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
06:26:34 <Axman6> something like, foldl (\(x:xs) y -> if x == y then x:xs else y:x:xs) [].... ok, i see why that won't work. but it'll work if you define that as a function in a where clause
06:26:42 <Paranoid_> I am allowed and that's what I will do unless I can't figure this out with foldr, but the exercise says that this can be done both with foldr and foldl, so I would like to figure it out both ways
06:28:59 <Paranoid_> The error I get when I set the e value to [] instead of [0] when I try to apply the function to a list is that it is a non-exhaustive pattern in function g (which I have defined with a where clause)
06:36:26 <Paranoid_> Having a look at foldl, I think I will still have the same problem.. The thing is that in my 'where' clause I take two arguments, one is x and the other is (y:xs), hence when I try to get the head element (y) of an empty list that will be an undefined value, hence a non-exhaustive pattern - so I still need to give the 'e' value as a non-empty list otherwise I can not use my where clause for g.
06:37:08 <ketil> is source-repository not a legal cabal field?
06:38:19 <EvanR-work> non exhaustive pattern doesnt sound right
06:38:46 <EvanR-work> @src head
06:38:46 <lambdabot> head (x:_) = x
06:38:46 <lambdabot> head []    = undefined
06:38:50 <EvanR-work> > head []
06:38:51 <lambdabot>   *Exception: Prelude.head: empty list
06:39:33 <Paranoid_> hmm, so this might not be my problem then otherwise I would get the 'empty list' error?
06:39:36 * hackagebot flower 0.6.3 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.6.3 (KetilMalde)
06:39:46 <Jafet> All bottoms equally stink.
06:39:59 <EvanR-work> Paranoid_: head gives that error, failing to match [] gives another error
06:40:11 <EvanR-work> i recommend handling []
06:40:27 <EvanR-work> even if you think its impossible, at least put an error "this is impossible, right"
06:40:40 <Paranoid_> I've thought about that, but isn't the purpose of using foldr/foldl to avoid handling things like [] individually? Or at least that's the impression I have
06:40:55 <EvanR-work> some functions handle [] for you
06:40:59 <Jafet> Heh, evanr, didn't you give an opposite opinion some time ago?
06:40:59 <EvanR-work> > catMaybes []
06:41:00 <lambdabot>   []
06:42:18 <EvanR-work> i havent found a good reason to undefined, error, or not handle every pattern yet
06:42:45 <EvanR-work> but if you think its impossible to happen, the proof should be at most 1 line of code away
06:42:52 <EvanR-work> not in another module somewhere
06:43:16 <EvanR-work> thats a problem we have in php, 'thats impossible' really depends on the behavior of another system thats completely not on the screen
06:43:24 <EvanR-work> and couldnt fit on one screen anyway
06:43:54 <Paranoid_> Alright, I'll give this a shot then with handling []
06:43:57 <Paranoid_> Thank you :)
06:45:49 <EvanR-work> > concat []
06:45:50 <lambdabot>   []
06:45:52 <EvanR-work> > sum []
06:45:53 <lambdabot>   0
06:45:56 <EvanR-work> > tails []
06:45:56 <lambdabot>   [[]]
06:46:01 <EvanR-work> > transpose []
06:46:01 <lambdabot>   []
06:46:21 <EvanR-work> > (():) []
06:46:22 <lambdabot>   [()]
06:49:34 <EvanR-work> Jafet: this is all well and good. but what do you do if you have to has an ffi library, and later your program segfaults :(
06:49:43 <EvanR-work> have to use*
06:49:59 <EvanR-work> no amount of nazism can save you from bad C code or bindings :(
06:50:02 <Jafet> I definitely preferred have to has
06:50:46 <quicksilver> I can have to has cheezburger?
06:52:33 <damex> hi, hope i can get any support ... i was trying to get working utf8 with xmonad<=>xmobar and english = fine, fr/ru or other lang = fine. but whan there are appears to be asian laguages - it covers with something _non_human_ or "????". i was done everything like here http://www.haskell.org/haskellwiki/Xmonad/Config_archive/John_Goerzen%27s_Configuration and succ~ googled only that result wich same
06:52:34 <damex> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24590#62
06:53:14 <EvanR-work> damex: is your asian encoded in utf8
06:53:19 <damex> yea
06:53:31 <damex> must be ... i was tryed wiki for example
06:53:34 <geheimdienst> does your font have the necessary characters?
06:53:39 <EvanR-work> if you see squares then you must be missing font support
06:54:12 <geheimdienst> just for testing, try some font that has lots and lots of characters, e.g. charis sil
06:54:14 <damex> i need to use pure japan font?
06:54:21 <EvanR-work> you need to use fontconfig
06:54:33 <EvanR-work> that is, have a japanese font, chinese font, korean font, available
06:54:37 <damex> http://fastpic.ru/view/11/2010/1105/178af39cb3db0a4653e67aab776cc066.png.html
06:54:40 <EvanR-work> it will be used for those texts
06:54:42 <damex> its like that
06:54:58 <damex> i have nearly full set of asian fonts XD
06:55:13 <EvanR-work> oh this is xmonad
06:55:55 <EvanR-work> does that even use fontconfig ;)
06:55:59 <damex> oh i can change layout ...
06:56:35 <damex> how to find that?
06:56:41 <nus> damex, what does #xmonad say?
06:57:06 <EvanR-work> damex: maybe related
06:57:08 <EvanR-work> http://osdir.com/ml/xmonad@haskell.org/2010-04/msg00123.html
06:57:17 <damex> thx will try
06:57:35 <EvanR-work> Dec 01, 2009 xmonad is sloppy about strings and encoding.
06:57:38 <EvanR-work> http://code.google.com/p/xmonad/issues/detail?id=348
06:59:13 <damex> #xmonad always silent :(
06:59:49 <dons> hmm
07:03:11 <arnihermann> I'm getting a compiler error on "newtype Fix f = In (f (Fix f))"
07:03:18 <arnihermann> `f' is applied to too many type arguments
07:03:30 <arnihermann> but this seems fairly standard and well documented practise
07:03:49 <arnihermann> does this need a language extension?
07:03:59 <EvanR-work> what is the kind of f
07:04:10 <EvanR-work> * probably
07:04:29 <arnihermann> yes
07:04:55 <EvanR-work> then it cant be applied to any type
07:05:01 <aristid> :k Mu
07:05:01 <arnihermann> it needs to be * -> * ?
07:05:01 <lambdabot> (* -> *) -> *
07:05:07 <arnihermann> ah
07:05:12 <arnihermann> easy fix
07:05:14 <arnihermann> thanks
07:05:26 <arnihermann> or maybe not
07:05:54 <EvanR-work> Mu is type level fix it seems
07:06:00 <arnihermann> right
07:06:11 <EvanR-work> @src Mu
07:06:11 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
07:06:24 <arnihermann> ok
07:06:25 <arnihermann> fixed it
07:06:29 <arnihermann> thanks
07:06:40 <EvanR-work> thats what you wrote
07:06:44 <Axman6> hey dons, i've been playing around with some of your stream fusion stuff, by implementing it using specialised step datatypes using type families. i was wondering if you'd be able to take a quick squiz, and maybe provide any insight into whether you'd expect to see any performance improvements, or whether current stream fusion can't really be beaten http://hpaste.org/41170/specialised_stream_fusion
07:07:11 <damex> http://code.google.com/p/xmonad/issues/detail?id=348 that patches for xmonad-contrib ? am i right?
07:07:18 <damex> that was link above
07:09:23 <aristid> @src fix
07:09:23 <lambdabot> fix f = let x = f x in x
07:10:10 <EvanR-work> :t let fix f = f (fix f) in fix
07:10:11 <lambdabot> forall t. (t -> t) -> t
07:10:19 <EvanR-work> fix f = f (fix f)
07:10:40 <EvanR-work> aristid: is the @src version better somehow?
07:11:25 <aristid> EvanR-work: no, i like yours better
07:12:49 <Jafet> Hm, what's fix in sk?
07:14:08 <EvanR-work> S S K (S (K (S S (S (S S K)))) K)
07:14:10 <aristid> EvanR-work: but maybe the let version is more efficient?
07:14:25 <EvanR-work> aristid: thats what im wondering, that would suck ;)
07:14:58 <damex> i have more question ... is code.haskell.org in that state = fine? it have around 500~ping and nothing seems like getting from darcs rep's, placed there.
07:15:34 <Jafet> :t let s = ap; k = const in s s k (s (k (s s (s (s s k)))) k)
07:15:35 <lambdabot>     Occurs check: cannot construct the infinite type: a = m (a -> b)
07:15:35 <lambdabot>       Expected type: m (a -> b)
07:15:35 <lambdabot>       Inferred type: a
07:15:41 <aristid> damex: use github :P
07:15:57 <damex> ._.
07:16:45 <Jafet> :t let s = liftA2 id; k = const in s s k (s (k (s s (s (s s k)))) k)
07:16:47 <lambdabot>     Occurs check: cannot construct the infinite type: b = f (b -> c)
07:16:47 <lambdabot>       Expected type: f (b -> c)
07:16:47 <lambdabot>       Inferred type: b
07:17:33 <EvanR-work> Jafet: isnt a non recursive fix not possible in haskell
07:18:26 <Jafet> Oh, I thought you were demonstrating one
07:18:43 <Jafet> But sk is untyped though
07:18:48 <EvanR-work> yes
07:18:55 <EvanR-work> how convenient for it ;)
07:20:18 <Axman6> :t ap
07:20:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
07:21:28 <EvanR-work> :t liftM
07:21:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:21:57 <roconnor> EvanR-work: if you define the right data type you can write a non-recursive fix in Haskell
07:22:10 <roconnor> newtype Mu a = Roll { unroll :: Mu a -> a }
07:22:18 <EvanR-work> i was about to say that, but jafet confused me
07:22:34 <Jafet> @src Mu
07:22:34 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
07:22:55 <roconnor> ya
07:22:57 <Jafet> Hrm, that one looks more appropriate
07:22:58 <roconnor> my Mu is wrong
07:23:08 <roconnor> well
07:23:10 <roconnor> it is a bad name I mean
07:23:11 <copumpkin> your Mu can still do it
07:23:12 <EvanR-work> how is it not recursive ;)
07:23:23 <copumpkin> zomg not positive
07:23:24 <roconnor> EvanR-work: fair point
07:23:39 <roconnor> we've just moved the recursion to the type level
07:24:05 <roconnor> copumpkin: if we used only postive stuff we couldn't define fix non-recursively
07:24:13 <copumpkin> I know :)
07:26:05 <lars9> @src (***)
07:26:06 <lambdabot> f *** g = first f >>> second g
07:26:19 <lars9> @src (>>>)
07:26:19 <lambdabot> Source not found. I feel much better now.
07:26:26 <damex> aristid: may i get right links for xmonad+contrib+extras+xmobar at the github ?
07:26:26 <lars9> :t (>>>)
07:26:27 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
07:26:43 <Jafet> @pl \f g -> \(a, b) -> (f a, g b)
07:26:43 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
07:26:49 <lars9> :t (***)
07:26:50 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:27:02 <aristid> damex: no idea :)
07:27:14 <Jafet> I find your lack of arrows disturbing, lambdabot.
07:28:04 * zygoloid ponders if impredicativity helps to nonrecursively define fix (can you hide the infinite type inside a forall?)
07:28:38 <fryguybob> @vixen do you lack arrows?
07:28:38 <lambdabot> yes i do
07:29:31 <zygoloid> @vixen what's your opinion on arrow's impossibility theorem?
07:29:31 <lambdabot> let's don't talk about that
07:36:39 <aristid> preflex: seen BONUS
07:36:39 <preflex>  BONUS was last seen on #haskell 23 hours, 28 minutes and 42 seconds ago, saying: cool! see ya!
07:37:23 * sipa sees BONUS right now
07:37:34 <copumpkin> wow, BONUS is a real person?
07:37:35 * EvanR-work sees dead people
07:38:00 <geheimdienst> i guess by "seen" preflex means "said something"
07:38:40 <unkanon> what is preflex?
07:38:54 <Zao> @botsnack
07:38:54 <lambdabot> :)
07:38:58 <Zao> Another bot.
07:39:07 <Zao> For when lambdabot is out frolicking in the fields.
07:39:14 <unkanon> hmm
07:40:11 <lispy1> copumpkin: hey, you're a real pumpkin, right?
07:40:20 <copumpkin> yep
07:40:32 <lispy1> I should change my nick to cohuman
07:40:34 <copumpkin> :)
07:41:08 <lispy1> Would an android be a cohuman?
07:41:38 <geheimdienst> isn't an android a coiphone?
07:42:12 <lispy1> koi phone?  Carp calling plan?
07:42:43 <mietek> Is Patai here?
07:43:01 <lispy1> preflex: seen patai
07:43:01 <preflex>  patai was last seen on #haskell 2 years, 23 days, 5 minutes and 20 seconds ago, saying: Hi, I have a problem with laziness and profiling. Description at http://pastebin.com/f4b9284af
07:43:13 <raceRider> what's an easy way to find which package provides what import module. Say I see import Control.Monad.State, how can I quickly find which package provides that module? Module names and package names on hackage don't seem to map easily. 
07:43:16 <zygoloid> wouldn't a coiphone imbue trends with humanity?
07:43:26 <mietek> lispy1: hmm
07:43:31 <mietek> preflex: seen cobbpg
07:43:31 <preflex>  Sorry, I haven't seen cobbpg
07:43:47 <lispy1> ?remember zygoloid wouldn't a coiphone imbue trends with humanity?
07:43:47 <lambdabot> I will never forget.
07:44:00 <aristid> cool, that pastebin still exists
07:45:22 <geheimdienst> jayne bb, jayne cobb
07:46:39 <lispy1> raceRider: Probably the easiest way is to use hoogle, but that assumes the necessary packages are indexed by hoogle
07:46:56 <lispy1> raceRider: the more complete way is to look at the .cabal file and do a linear search through the dependencies
07:47:14 <damex> how did i can remerge something from ****-9999 ebuild without rechecking its data from repository?
07:47:32 <geheimdienst> raceRider: try searching on http://hackage.haskell.org/packages/archive/pkg-list.html
07:47:49 <raceRider> lispy1, to look at the .cabal file, is there a way to search all cabal files without downloading them? 
07:48:05 <damex> miss chat
07:48:06 <damex> XD
07:48:09 <lispy1> raceRider: Oh, I mean the .cabal file of the project you're building
07:48:10 <geheimdienst> also, on haddock documentation pages the top left tells you what package you're in
07:48:11 <damex> sry
07:48:45 <geheimdienst> raceRider: you probably have already downloaded all *.cabal files :) they're in the file 00-index.tar.gz inside your .cabal/packages directory (iirc)
07:49:29 <jmcarthur> this is how OO programmers attempt to control state?  http://www.sandywalsh.com/2010/11/state-creep.html
07:50:03 <raceRider> geheimdienst, is there a cabal command for that other than the list command
07:50:14 <EvanR-work> the most common form of state is the boolean
07:50:18 <jmcarthur> duh
07:50:23 <jmcarthur> booleans mean state
07:50:37 <EvanR-work> ok i thought when he said state is more than just data, he was on to something
07:50:39 <EvanR-work> but...
07:50:47 <dcoutts__> raceRider: what do you really want?
07:51:11 <jmcarthur> stuff like this is how you get design pattern explosion
07:52:10 <jmcarthur> wow, he suggest replacing finite state machines with petri nets
07:52:14 <jmcarthur> *suggests
07:52:19 <EvanR-work> ok i see state machines, theres some hope
07:52:32 <EvanR-work> ok never mind
07:52:35 <jmcarthur> lol
07:52:46 <jmcarthur> this can't be for real
07:52:53 <raceRider> dcoutts, I see import statement in some code online. I want to try it out in ghci. But ghci complains the lib is not available. Then I have to figure out the exact cabal package name to to install. Sometimes I get many hits and don't know which one to install.
07:53:20 <EvanR-work> bookmarked
07:54:16 <EvanR-work> jmcarthur: he/she suggests*
07:54:20 <dcoutts__> raceRider: ah ok, mapping from module name to the package name
07:54:31 <EvanR-work> equal opportunity brain damage
07:54:47 <raceRider> dcoutts, yes, precisely.
07:54:57 <geheimdienst> raceRider: do you have package documentation (html) on your hard drive? if so, you shouuld have a file ~/.cabal/share/doc/index.html
07:55:04 <dcoutts__> raceRider: right, that's not so easy at the moment.
07:55:20 <dcoutts__> geheimdienst: but he doesn't have the package installed yet, he wants to know which one to install
07:55:31 <EvanR-work> on the design aspect, the red links make me think they are broken
07:55:38 <dcoutts__> raceRider: I think using the search on the hackage website is probably the easiest way
07:55:40 <EvanR-work> and i dont want to click them
07:55:53 <dcoutts__> raceRider: otherwuse, you can unpack the 00-index.tar.gz and then use grep -R
07:56:05 <quicksilver> geheimdienst: if it's already installed on your maching, you can find it with ghc-pkg find-module
07:56:09 <geheimdienst> what's wrong wich the package search ...? http://hackage.haskell.org/packages/archive/pkg-list.html
07:56:18 <quicksilver> geheimdienst: I presume that the OP is wondering which one to install.
07:56:34 <raceRider> dcoutts, I think you are right about no easy way at the moment. Grep'ing is an option. I'll try that. 
07:56:58 <geheimdienst> quicksilver, cool, didn't know about find-module. thanks
07:58:04 <EvanR-work> on an urelated wtf matter, i want to append a sequence of consecutive numbers to an sql query result set
07:58:19 <EvanR-work> and apparently the solution is to use @x := @x + 1
07:58:20 <raceRider> dcoutts, how hard would it be for ghci or ghc error about lib missing to offer possible package names from hackage. Then I can follow through. Or have a one-to-many map of package names and module names on hackage itself for easy searching.
07:58:56 <Kaidelong> so just to check that I understand this (category theory here):
07:59:03 <Kaidelong> All monoids are monads because:
07:59:12 * jmcarthur attempts to politely inform the author why the article made me "wtf" but isn't sure where to start
07:59:15 <Kaidelong> all monoids are either the unit or a product
07:59:38 <Kaidelong> when you multiply together products, you get new products
08:00:00 <raceRider> geheimdienst, that's the best option you provide not doubt. I 'm just looking for  a single list of package names and the modules they provide. Right now, with hackage one has to click on every module name to find the package name to download.
08:00:00 <geheimdienst> jmcarthur: what's the first thing you object to?
08:00:07 <EvanR-work> mappend = >>
08:00:14 <Kaidelong> so in a sense a "product of products" is "join"
08:01:00 <nostard> hi, i want to save things to a file, eg. a list or something, is there an easy way?
08:01:02 <Kaidelong> so it comes down to something like all monoids are lists and all lists are monads
08:01:49 <Vanadium> writeFile "myfilename" (show [1..10])
08:01:50 <Jafet> > show [[], [(1, "a really"), (2, "complicated list here")]]
08:01:51 <lambdabot>   "[[],[(1,\"a really\"),(2,\"complicated list here\")]]"
08:02:51 * copumpkin finds it rather curious that cgi is in the haskell platform
08:03:37 <nostard> Valodim: ok, so just: writeFile fn $ show x? =)
08:04:03 <nostard> Valodim: and to read it later on i use read?
08:04:05 * Jafet still writes little servers in haskell using cgi
08:04:06 <Kaidelong> so then you'd have mu as multiplication and eta as multiplication with unit?
08:04:17 <Jafet> Not using cgi, though
08:04:23 <McManiaC> whats the extension that allows group by statements in list comprehensions?
08:04:23 <Jafet> Er, CGI
08:04:35 * geheimdienst vaguely recalls that cale hosts haddock docs of lotsa packages, but cale.yi.org seems to be down ...
08:04:43 <Jafet> Errr, the CGI module on hackage
08:04:53 <copumpkin> Jafet: still, the cgi package uses strings, and the most common application of it (with an html generator) isn't possible directly with the platform cause no html generator lib is included
08:05:04 <copumpkin> but even then, it seems nichey
08:05:21 <EvanR-work> opengl is nichey!
08:05:27 <Jafet> Dunno then, I always made html manually
08:05:29 <EvanR-work> in haskell at least
08:05:58 <Jafet> Obviously the shady cabal has determined otherwise, evanr
08:06:05 <geheimdienst> "when in doubt, throw it in?"
08:06:26 <geheimdienst> supposing it's stable enough and doesn't cause trouble
08:06:52 <Jafet> It does raise eyebrows "wtf, 200 MB"
08:07:23 <fxr> how can I write a parser for a rule like this,considering I have text and crlf already : discard-text := *(*text CRLF) *text 
08:07:24 <Jafet> Such is the long tail
08:07:37 <EvanR-work> most people even think one about a download being 200M?
08:07:39 <EvanR-work> once
08:07:47 <EvanR-work> games take like 10G these days
08:07:59 <EvanR-work> 200M is the new 1.44M
08:08:15 <geheimdienst> well, games are an exception, they have boatloads of videos and graphics and stuff
08:08:19 <Jafet> I had to download it over a 10k/s line a few days ago, and I did
08:08:25 <Zao> EvanR-work: Well, you have the popular trend of transfer caps on internet connections.
08:08:30 <Zao> EvanR-work: At least in the US and AU.
08:08:38 <Jafet> @google kkrieger
08:08:40 <lambdabot> http://www.theprodukkt.com/kkrieger
08:08:40 <lambdabot> Title: .theprodukkt
08:08:43 <EvanR-work> haha
08:09:09 <lars9> is vexorian iwhat
08:09:17 <geheimdienst> btw, ghc is "installed size: 470 mb" on my system ...
08:09:19 <jmcarthur> geheimdienst: "Once you get beyond two linked booleans  Extract to Class"
08:09:20 <lars9> sorry typo
08:09:34 <EvanR-work> ive been playing captive for atari ST, fit in way under 700k, 65000 or so missions, youll never finish
08:09:36 <jmcarthur> geheimdienst: the facts before it are true, so i can't disagree with them, but they are misleading, IMO
08:09:43 <lars9> what's the time complexity of Data.List's sort?
08:10:06 <EvanR-work> > sort [1..100]
08:10:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:10:09 <EvanR-work> > sort [1..10000]
08:10:10 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
08:10:13 <fxr> lars9: it uses mergesort, which is nlogn
08:10:14 <EvanR-work> > sort [1..10000000]
08:10:19 <lambdabot>   mueval: ExitFailure 1
08:10:19 <Jafet> It's a bit sad though, they're 10G these days and most still don't ship with a storyline
08:10:38 <jmcarthur> geheimdienst: in that the article seems to be implying that booleans and ifs are inherently bad, and that they are necessarily the embodiment of state
08:10:40 <EvanR-work> Jafet: you have to draw the line somewhere
08:11:07 <lars9> fxr: with O(n) space?
08:11:07 <Saizan> fxr: many (many text >> crlf) >> many text ? 
08:11:22 <EvanR-work> state is data, data on its own isnt that bad, and is something we cant do without
08:11:29 <EvanR-work> so how is state different from data?
08:11:40 <EvanR-work> its boolean?
08:12:21 <Jafet> jmcarthur: unless you're going to post your message in the form of a petri net with no booleans or enums, I suggest moving on.
08:12:28 <EvanR-work> lol
08:12:34 <Saizan> fxr: that discards the text though, if you need it you'll have to use many (many text >>= \xs -> crlf >> return xs) >>= \xss -> many text >>= \xs -> return (xss, xs)
08:12:38 <Jafet> Some people don't want to be rescued.
08:13:23 <EvanR-work> i should follow up with an improvement on the PN idea, model the state transition and locking of the program as a VHDL node list
08:13:59 <EvanR-work> or a feynman diagram
08:14:27 <EvanR-work> or the mandelbrot set
08:15:03 <fxr> Saizan: thanks, that's what I have written. But sometimes the direct imlementation of a bnd definition yields unwanted results.
08:15:07 <geheimdienst> jmcarthur: well, he does say "The most common form of state is the Boolean" ... state meaning "one state of an FSM". sounds reasonable to me ...?
08:15:43 <EvanR-work> a boolean could indicate a fsm in one of two states
08:15:52 <Saizan> fxr: usually one just needs to watch out for left recursion
08:15:58 <Saizan> fxr: or meta rules i guess
08:16:27 <geheimdienst> as for ifs being bad, i guess he's aiming at "don't write a jillion ifs, cause you'll get jillions^jillions of code paths, which becomes untestable quickly"
08:16:48 <fxr> Saizan: do we have any parser library which transforms the definition to an optimized dfa?
08:16:56 <EvanR-work> depending on what the ifs *do* you could get a combinatorially exploding state machine
08:17:11 <EvanR-work> it assumes ifs have the effect of writing to variables
08:17:40 <EvanR-work> serious untangling of concepts needed
08:20:55 <Saizan> fxr: uu-parsinglib tries to be more clever, in general one has to make a tradeoff between the flexibility of the api and the ability to autooptimize, i don't know of anyone that guarantees a dfa
08:21:11 <neena> is the snap-server package on cabal broken? I get http://wo.ai.ki/~neena/cabal.txt
08:21:56 <fxr> Saizan: does uu-parsinglib supports incremental parsing?
08:22:30 <copumpkin> how is it even possible to guarantee a DFA unless you stick to regular expressions (the real ones)?
08:24:34 <Saizan> fxr: i'm not sure about being able to accepting the input in chunks, but it will start producing the result without having consumed the whole input
08:25:18 <copumpkin> is there an accepted way to produce results lazily while still being able to fail, btw?
08:25:30 <djahandarie> That recent paper by simon pj is interesting
08:25:31 <fxr> uhm, I have written bunch of rfcs with attoparsec, do you think I need to consider using uu-parsinglib?
08:25:43 <zygoloid> copumpkin: iteratee? *ducks*
08:25:54 <copumpkin> parse :: String -> (ParseError -> r) -> (ParseResult -> r) -> r ?
08:26:03 <Saizan> copumpkin: error correction seems decent
08:26:17 <copumpkin> Saizan: I mean as a general technique for things that definitely fail
08:26:23 <copumpkin> but you want to stay pure, yet lazy
08:26:29 <copumpkin> zygoloid: ew
08:26:40 <djahandarie> iteratee definitely fails
08:26:45 <djahandarie> ;-)
08:26:48 <zygoloid> copumpkin: that type looks somewhat reminiscent of cps'd iteratee :)
08:27:21 <aristid> can everything be cps'd?
08:27:37 <fxr> aristid: in a CPS'd world, yes.
08:27:52 <Saizan> if you want lazy it has to start producing part of the result without knowing if it'll fail, so when you get an error you can't just maginally return an 'r'
08:27:54 <jmcarthur> geheimdienst: it just seems to me that the author confused state and conditionals
08:27:55 <zygoloid> copumpkin: replace your Mu with Mu . Either Error ?
08:28:10 <Saizan> since you're already in the middle of some other structure
08:28:20 <jmcarthur> geheimdienst: exponential blowup of your conditionals sucks, but it's not state
08:28:22 <EvanR-work> jmcarthur: state is something that affects the business logic of the app
08:28:23 <copumpkin> zygoloid: I mean for an arbitrary data type that isn't constructed explicitly from a fixpoint of a functor
08:28:32 <Saizan> Mu . Either Error makes sense
08:28:51 <zygoloid> copumpkin: are you prepared to change the result data type?
08:28:58 <jmcarthur> EvanR-work: sure, but a conditional is actually one of the *least* common forms of state, in my experiences
08:28:59 <copumpkin> ideally no :P
08:29:07 <zygoloid> that's tricky then :)
08:29:12 <EvanR-work> i dont see how a conditional is state at all
08:29:16 <EvanR-work> im just explaining the blog to you
08:29:19 <jmcarthur> well, a boolean
08:29:28 <jmcarthur> eh that's fine
08:29:29 <copumpkin> Saizan: you can't magically return an R?
08:29:37 <copumpkin> Saizan: isn't my type a bit like callCC?
08:29:40 <EvanR-work> i havent fully comprehended it yet though
08:29:40 <copumpkin> that's what I was getting at
08:29:45 <jmcarthur> i also think i see where the author is coming from. i just think there's some confusion
08:29:59 <Saizan> copumpkin: callCC and lazyness don't mix, that's what i was getting at :)
08:30:16 <copumpkin> ah, I see what you mean
08:30:26 <EvanR-work> rather than a mismatch type confusion, it seems to be to be a mashup, mixin, potpourri type confusion
08:31:36 <copumpkin> is there a generics library out there that can take an existing type and give you a version with all fields replaced with Maybe of the original type?
08:31:38 <copumpkin> :P
08:35:31 <EvanR-work> jmcarthur: it seems similar to switch-on-type anti pattern when you dont have pattern matching or dynamic dispatch
08:35:33 <copumpkin> newtype Moo = Moo { unMoo :: forall m . Monoid m => (Integer -> m) -> m }
08:35:37 <EvanR-work> expanded to all if statements
08:35:42 <geheimdienst> i agree that the blog post is confused. i don't think the example code makes clear what his problem is. apart from that he just seems to say "use a proper FSM, it might make things clearer as you get more and more states" and "when stuff starts to get concurrent, look at petri nets"
08:35:49 <copumpkin> oh nevermind
08:36:13 <geheimdienst> (paraphrasing the bold paragraphs)
08:37:16 <jmcarthur> geheimdienst: yeah concurrency wasn't really mentioned. it seems that the author meant to imply that petri nets are good general replacements for complex FSMs...
08:37:44 <jmcarthur> which is weird :)
08:37:51 <EvanR-work> variables or methods that return a bool, that may have a different value if queried again
08:38:09 <EvanR-work> ok so you have to use an if statement
08:38:15 <EvanR-work> but dont you have to use an if anyway
08:38:20 <EvanR-work> to pattern match on the bool
08:38:20 * hackagebot multirec 0.5 - Generic programming for families of recursive datatypes  http://hackage.haskell.org/package/multirec-0.5 (AndresLoeh)
08:38:22 * hackagebot zipper 0.3.1 - Generic zipper for families of recursive datatypes  http://hackage.haskell.org/package/zipper-0.3.1 (AndresLoeh)
08:38:23 <EvanR-work> without patterns
08:38:24 <jmcarthur> it's an if somewhere
08:38:40 <jmcarthur> even if its captured by dynamic dispatch
08:38:47 <EvanR-work> so its not a state issue
08:38:52 <EvanR-work> its a branch issue
08:39:04 <EvanR-work> a case expression
08:39:11 <EvanR-work> the heart of computing! ;)
08:39:30 <jmcarthur> you mean the bane of OOP?
08:40:19 <geheimdienst> jmcarthur: you're right, the magic word "concurrent" is absent from the last bold paragraph. that's bad. i assumed we're dealing with concurrency when he moved three nodes of the diagram over to a new employee alice
08:41:05 <EvanR-work> jmcarthur: id say the heart of oop is careful management of writing to states
08:41:36 <jmcarthur> geheimdienst: it was a bad example of a FSM to begin with because it dealt with multiple processes
08:42:00 <EvanR-work> if you use no side effects oop, then i guess youre left with a lack of pattern matching
08:42:00 <jmcarthur> implying "transitions" from one process to another...
08:42:51 <jmcarthur> EvanR-work: i don't think the heart of OOP has much to do with states at all, personally
08:43:02 <EvanR-work> theres different kinds of oop
08:43:05 <jmcarthur> EvanR-work: where is the state inthe coalgebraic model of OOP, for example
08:43:09 <jmcarthur> EvanR-work: yes, there are
08:43:14 <jmcarthur> *in the
08:43:43 <roconnor> @pl ($ id)
08:43:43 <lambdabot> ($ id)
08:43:52 <geheimdienst> today on #haskell: somebody might be wrong on the internet, as evidenced by a new post on some dude's blog. the combined brainpower of #haskell is applying itself to the exact qualifications of why the dude is wrong. stay tuned for a full exegesis.
08:44:06 <EvanR-work> lol
08:44:10 <geheimdienst> Declaring the Internet Wrong One Blog Post at a Time. ;-)
08:44:28 <EvanR-work> reddit on a smaller scale
08:45:01 <EvanR-work> jmcarthur: isnt this the sort of thing youd post on reddit? if not haskell reddit, functional programming or something
08:45:31 <jmcarthur> EvanR-work: not me, anyway
08:45:38 <jmcarthur> EvanR-work: maybe it should have been #haskell-blah though
08:45:49 <wjt> is it possible to ask GHC which version of a package it's picking when I use ghc --make?
08:46:43 <wjt> i'm writing a test case for gtk2hs, and want to verify that it's building against the darcs head version I just installed (rather than the debian-packaged version)
08:46:44 <geheimdienst> after 3am, #haskell and -blah tend to curl up pretty closely together
08:46:54 <geheimdienst> and remember that it's always 3am somewhere
08:47:22 <sproingie> to me OOP has to do not so much with state but scope.  i'd say the existence of C++ despite the protestations of alan kay means there's no final authority on what OO means
08:49:45 <roconnor> what is the blog post in question.
08:49:48 <roconnor> ?
08:50:00 <geheimdienst> roconnor, sandywalsh.com/2010/11/state-creep.html
08:55:16 <EvanR-work> the cardelli object calculus seems inline with the business concept of oop
08:55:44 <Eduard_Munteanu> That post looks a bit too abstract for its own good.
09:08:07 <monochrom> there is no final authority but there is a final coalgebra
09:09:25 <empt> hi, I'm experienced Smalltalker and looking for short but real world in depth tutorial, and which would you recommend?
09:09:46 <Jafet> @where rwh
09:09:46 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:10:20 <empt> thanks Jafet, is there a shorter thing?
09:10:38 <quicksilver> {short}{real world}{in depth}
09:10:44 <quicksilver> that's quite a lot of important qualifiers ;)
09:10:53 <quicksilver> I don't think *anything* I'm aware of meets all three.
09:10:58 <monochrom> pick two.
09:11:01 <empt> sorry but I'm serious
09:11:05 <quicksilver> I don't doubt it.
09:11:10 <quicksilver> I'm just telling you it don't exist.
09:11:18 <Jafet> You said you were experienced in smalltalk, so I ignored the short qualifier
09:11:22 <quicksilver> RWH is real world and in depth, but not short.
09:11:24 <lispy1> empt: you might look around the haskell.org wiki
09:11:44 <quicksilver> LYAH is good, has moderate depth and is moderately short
09:11:51 <quicksilver> but is not real world.
09:11:51 <empt> Yes I browsed through the site
09:12:28 <EvanR-work> a pamphlet on the main theorems of type theory is short in depth and not real world ;)
09:12:29 <empt> How about a general intro to haskell, 64p
09:12:33 <monochrom> perhaps a lib's source code serves as a short real world in depth tutorial. http://hackage.haskell.org/package/hxt
09:12:54 <empt> thx monochrom
09:14:35 <monochrom> or http://hackage.haskell.org/package/yesod
09:15:27 <lars9> is String lazy by default, but ByteString not lazy?
09:15:50 <empt> Thanks so I'd better go RWH 
09:15:52 <dankna> String is [Char], which is indeed lazy
09:16:00 <monochrom> String is lazy. there is no non-default. ByteString has two kinds. there is no default.
09:16:21 <dankna> Data.ByteString is strict.  Data.ByteString.Lazy is also strict for most operations, but not for concatenation.
09:16:53 * HugoDaniel is dead
09:16:58 <monochrom> people should not ask loaded questions.
09:17:08 * HugoDaniel is dead
09:17:20 <lars9> dankna monochrom thanks
09:17:23 <dankna> sure
09:17:26 <monochrom> long live the HugoDaniel
09:25:58 <Kaidelong> do you have a monad with sets in category theory?
09:26:05 <Kaidelong> I know you don't in haskell
09:26:06 <damex> but rly ... is someone going to fix code.haskell.org?
09:28:28 <quicksilver> Kaidelong: Yes. The Powerset functor is a monad.
09:28:35 <quicksilver> (from Set -> Set)
09:28:56 <quicksilver> actually it's mentioned here : http://en.wikibooks.org/wiki/Haskell/Category_theory
09:32:45 <Kaidelong> oooh, so basically a set is the union of its powerset, and a union of a set and its empty set is the set you started with
09:33:02 <Kaidelong> so all sets can be seen as big Us
09:33:10 <Kaidelong> of sets
09:33:24 <Kaidelong> so sets are both monads and monoids
09:33:44 <Kaidelong> (looking at the link you gave me and inferring from there)
09:33:53 <quicksilver> "sets are monads" is a bit meaningless in CT.
09:34:04 <quicksilver> a monad is about a functor between two categories
09:34:05 <EvanR-work> monoid seems obvious 
09:34:16 <Kaidelong> I was just trying to grasp this lecture that said that all monoids are monads
09:34:23 <Kaidelong> I think I'm starting to get it now though
09:34:32 <quicksilver> are you sure they said that?
09:34:42 <quicksilver> they're more likely to have said 'all monads are monoids'
09:34:59 <Kaidelong> something like that, for any monoid you can form a monad out of it using operations general to all monoids
09:35:10 <quicksilver> I don't think that's true.
09:35:16 <quicksilver> not an interesting one, anyway.
09:35:17 <wjt> so .. how do i actually add my email address to CC on the gtk2hs trac? i have a tickybox for adding the mailing list, but no form field to add myself
09:35:57 <quicksilver> it's a an error of category.
09:36:02 <quicksilver> Monad needs 'more stuff' than monoid.
09:36:09 <quicksilver> a monoid is a simple algebraic construct.
09:36:29 <quicksilver> a monad is a property of a functor between two categories
09:37:06 <Kaidelong> hmm, well the monoids have a closed product, right?
09:37:36 <quicksilver> yes.
09:37:53 <Kaidelong> and all monoids can be turned into a product of some set of objects and the unit
09:38:17 <quicksilver> all monoids can be expressed in generator/relation form
09:38:21 <quicksilver> if that's what you're trying to say.
09:38:25 <Kaidelong> which basically would mean you can always write them in some form x * y * z * unit...
09:38:26 <quicksilver> (not uniquely, though)
09:38:38 <Kaidelong> which is analogous to x ++ y ++ z ++ []
09:39:06 <quicksilver> yes.
09:39:12 <quicksilver> well, not quite.
09:39:25 <quicksilver> [x] ++ [y] ++ [z] ++ [] is unique
09:39:32 <quicksilver> because lists are the free monoid
09:39:44 <Kaidelong> oh?
09:39:46 <quicksilver> general monoids are not free, and therefore may not have a unique form like that.
09:39:58 <quicksilver> they'll have a form, but not a unique one necessarily.
09:40:15 <quicksilver> and infinite monoids may need an infinite set of generators.
09:40:29 <Kaidelong> are natural numbers a free monoid?
09:40:35 <quicksilver> or they may not, and it may be hard to prove.
09:40:44 <Kaidelong> with + and *\
09:40:50 <Kaidelong> I think they should be
09:40:54 <quicksilver> monoids only have one operation, not two.
09:40:59 <Kaidelong> I meant
09:41:06 <Kaidelong> you have a monoid with naturals and +
09:41:11 <Kaidelong> and a monoid with naturals and *
09:41:33 <quicksilver> the first one is the free monoid on {1}
09:41:41 <EvanR-work> * is just replicated + !
09:41:44 <quicksilver> the second is the free monoid on {2,3,5,7,11,....}
09:41:46 <Kaidelong> the second is not, then?
09:41:48 <Kaidelong> oh
09:41:52 <Kaidelong> oh of course!
09:41:52 <quicksilver> and you have to exclude 0 from the second.
09:42:27 <Kaidelong> prime factorizations
09:42:36 <Kaidelong> each integer has a unique one
09:42:46 <quicksilver> right.
09:42:46 <Kaidelong> natural, I mean
09:43:10 <quicksilver> naturals with 0 is still a monoid, of course, but not free any more.
09:43:51 <dolio> It isn't free anyway.
09:44:00 <dolio> Because 2 * 3 = 3 * 2, etc.
09:44:05 <dolio> 2 * 3 * 2 = 2 * 2 * 3
09:44:10 <monochrom> "monoids want to be free"
09:44:28 <EvanR-work> bound monoids
09:44:31 <quicksilver> dolio: apologies.
09:44:34 <quicksilver> "free commutative"
09:44:36 <Kaidelong> so free monoids are never abelian?
09:44:56 <quicksilver> Kaidelong: it's free abelian, but not 'free'
09:46:41 <lispy1> What is the definition of free that you're using?
09:46:49 <Kaidelong> so basically a free monoid is where there is one "simplest form" for all instances of the monoid?
09:47:03 <quicksilver> I'm not sure simplest is a good word.
09:47:14 <lispy1> well defined?
09:47:23 <quicksilver> a free monoid on the generators {a,b,c} is the monoid of all words you can write with a,b,c
09:47:30 <quicksilver> including the empty word (which is the unit)
09:47:30 <dolio> The free monoid on {1} (naturals, +) is abelian. But that's a coincidence.
09:47:35 <dolio> In general they aren't.
09:47:43 <quicksilver> under concatenation.
09:47:44 <monochrom> "free X" is constrained by the axioms (all equational) of X and no more.
09:47:58 <bos> the free hemorrhoid under compression.
09:48:09 <quicksilver> another monoid "is a free monoid" if it's isomorphic to one of these
09:48:31 <quicksilver> so proving something is free is equivalent to finding it's generators and proving each element can be *uniquely* expressed using those.
09:48:50 <djahandarie> lol bos
09:49:34 <dolio> lispy1: A monoid M is free if it's isomorphic to F S, where S is a set, and F is left adjoint to the forgetful functor U : Mon -> Set.
09:49:34 <Kaidelong> okay, so then a monoid that isn't free would be one where for some product A ++ B ++ C ... etc there is more than one object that the product maps to?
09:50:09 <lispy1> dolio: hmm...I have too many gaps in my knowledge to understand that definition.
09:51:06 <quicksilver> Kaidelong: well, as dolio points out, N under * is not free because 2*3 = 3*2
09:51:28 <Kaidelong> yeah, and products are themselves objects, in a monoid, right?
09:51:28 <quicksilver> Kaidelong: but it is "abelian free" because an abelian free monoid ignores the order of the operation.
09:51:44 <quicksilver> yes, a monoid has an operation * :: M x M -> M
09:51:54 <quicksilver> so the result of applying * to two members of M is a member of M.
09:52:41 <quicksilver> lispy1: the free construction is "start with this set of elements. Add new elements precisely when the definition forces you to, but no more. Assume two elements are equivalent if the axioms force you to, but that's all".
09:53:31 <quicksilver> lispy1: so, the free monoid on {a} starts with "e" (all monoids must have an identity, that's a law), and "a" (I just gave us that). Then you get "a*e" but the laws say that is just "a", and "a*a" which is a new element.
09:53:46 <quicksilver> it's not immediately obvious that's a sensible thing to do.
09:53:47 <Kaidelong> just guessing here, but would the interesting thing about monoids be that each morphism can be mapped to an object?
09:54:09 <Kaidelong> IE for every morphism A -> B there is object associated with it
09:54:16 <lispy1> quicksilver: thanks
09:54:24 <quicksilver> and it's a (deep? maybe not) theorem of algebra that "free" always makes sense for a certainly particular kind of definition.
09:54:30 <Kaidelong> and then for a free monoid that object is uniquely associated with it
09:54:30 <lispy1> quicksilver: and a*a*a is a new element too?
09:54:34 <quicksilver> right.
09:54:44 <EvanR-work> Kaidelong: i thought that was a property of all categories
09:54:52 <Kaidelong> was it?
09:54:56 <quicksilver> lispy1: actually (a*a)*a and (a*a)*a, but the associative law tells you that's one new element not two.
09:54:59 <Kaidelong> what about the category of n by n matrices?
09:55:03 <Kaidelong> matrices aren't integers
09:55:05 <quicksilver> Kaidelong: Monoids dont' have morphisms.
09:55:25 <quicksilver> Kaidelong: so I don't understand what you mean by "the interesting thing about monoids is this thing about morphisms"
09:55:28 <quicksilver> monoids don't have them.
09:56:27 <quicksilver> lispy1: if you had a simpler theory without the associative law, those would be two new elements.
09:56:35 <Kaidelong> not even id then?
09:56:41 <Kaidelong> so they're not a category?
09:56:50 <quicksilver> I don't know how to answer that one.
09:56:56 <quicksilver> there is a way to consider a monoid a category.
09:57:00 <quicksilver> but that's not what monoids *are*
09:57:29 <quicksilver> monoids *are* a set, with a distinguished identity object and a binary operation and a couple of laws.
09:57:39 <quicksilver> They are, in the most basic sense "a simpler idea" than categories.
09:58:02 <EvanR-work> semigroups!
09:58:04 <quicksilver> however, it's certainly true that you can put them in a categorical context and say "a monoid is a category with only one element"
09:58:14 <quicksilver> EvanR-work: magmas, actually. semigroups are still associative.
09:58:28 <EvanR-work> who named this stuff?
09:58:35 <dolio> Every monoid gives rise to infinitely many categories, really. Which should tell you something.
09:58:38 <quicksilver> mad frenchmen, in the most part.
09:58:52 <dolio> Of course, they're all isomorphic.
09:59:40 <lars9> how to add "-threaded" to cabal file?
09:59:51 <Kaidelong> so then you'd have umm
10:00:11 <lars9> extensions/ghc-options seem not work
10:00:32 <quicksilver> I think ghc-options, lars9 
10:00:55 <lars9> quicksilver: let me try again
10:01:11 <Kaidelong> a monoid with a single object which is a set and a single endomorphism on it which would basically be the set of all products, which is just the identity anyway?
10:01:11 <EvanR-work> is there an extensive theory about monoids in their own right?
10:01:25 <Kaidelong> well, you could represent it as...
10:01:33 <quicksilver> Kaidelong: not "which is a set".
10:01:41 <quicksilver> erm
10:01:46 <quicksilver> I'm not sure what you're trying to say again
10:01:52 <Kaidelong> no I didn't speak well
10:01:52 <quicksilver> EvanR-work: they're well studied, yes
10:02:01 <quicksilver> EvanR-work: mostly in representation theory.
10:02:18 <quicksilver> most of the study of monoids is about how you can embed them in other well-understood mathematical contexts.
10:02:23 <Kaidelong> "You could represent a monoid as a category which has a single object and an endomorphism on that object"
10:02:38 <Kaidelong> where that morphism is the identity
10:02:43 <quicksilver> Kaidelong: not "an" endomorphism, no
10:02:48 <quicksilver> many endomorphisms
10:02:53 <quicksilver> one for each element of your monoid.
10:03:35 <lars9> quicksilver: oh it's "-threaded" not "threaded"
10:03:37 <quicksilver> a monoid is (isomorphic to) a catgory with one element, and the elements of the monoid are the (endo)morphisms on that object. morphism composition is the "multiplication" of the monoid.
10:03:43 <EvanR-work> if i remember the crash course in CT i got from here, a category limitted to an arrow on one object is a monoid
10:04:00 <quicksilver> limited to many (all of its) arrows being on one object.
10:04:15 <EvanR-work> arrows on a given object
10:04:28 <Kaidelong> oooh
10:04:36 <Kaidelong> Okay that makes perfect sense
10:05:05 <quicksilver> but I have no idea what you original meant by all monoids are monads.
10:05:16 <quicksilver> you have quite a bit more structure to build up to acheive that
10:05:22 <quicksilver> you need to find a pair of categories
10:05:22 <EvanR-work> whats a monad now? ;)
10:05:22 <Kaidelong> I don't know if that was exactly what the lecture said
10:05:45 <quicksilver> and then represent your monoid in the endomorphisms of the functor category between them
10:05:50 <quicksilver> that' sprobably possible 
10:05:55 <Kaidelong> it was going on about building a monad "out of a monoid" or something like that
10:05:56 <quicksilver> but it's not obviously canonical
10:06:46 <Kaidelong> the thing I got out of it was that you could basically reduce a product or products to a single product?
10:07:05 <Kaidelong> and that you can always multiply something with unit
10:09:17 <quicksilver> that sonuds like a description of the monoid laws, yes.
10:23:11 <Kaidelong> hmm, is an adjunction just a pair of functors that form an endofunctor when the left adjunct is composed into the right adjunct?
10:23:26 <dolio> No.
10:23:27 <Kaidelong> Wait no I'll wait until I understand natural transformations
10:23:51 <Kaidelong> then go back to that
10:24:47 <quicksilver> any pair of functors C -> D and D -> C would form endofunctors when composed.
10:25:02 <quicksilver> that's just the algebra of composition.
10:25:26 <quicksilver> adjunction is something like a 'weak inverse'
10:25:32 <quicksilver> FGFG = FG
10:25:45 <quicksilver> you can 'cancel' GF pairs inside an F....G wrapper
10:25:52 <quicksilver> up to isomorphism.
10:25:59 * hackagebot cpsa 2.1.2 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.1.2 (JohnRamsdell)
10:28:57 <Kaidelong> so you could turn
10:29:33 <Kaidelong> FFGFFGFG into FFFG
10:29:35 <Kaidelong> ?
10:29:59 <Kaidelong> FFFFG I mean
10:30:03 <quicksilver> to be honest, I don't remember :)
10:30:15 <quicksilver> the immediate answer is no
10:30:23 <quicksilver> they have to have opposite pairs next to them
10:30:54 <quicksilver> however there might be something you can prove about more complex nestings
10:32:51 <lars9> can't replicateM_ take Integral? it's limited to Int now
10:34:31 <EvanR-work> then no
10:34:32 <dolio> If it's F -| G, then FG -> 1.
10:34:43 <EvanR-work> :t genericReplicate
10:34:43 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
10:34:48 <EvanR-work> :t genericReplicateM
10:34:49 <lambdabot> Not in scope: `genericReplicateM'
10:34:50 <dolio> So FFGFFGFG -> FF
10:35:08 <EvanR-work> :t sequence .: genericReplicate
10:35:09 <lambdabot> forall (m :: * -> *) a i. (Monad m, Integral i) => i -> m a -> m [a]
10:35:13 <EvanR-work> \o/
10:35:28 <lars9> :t (.:)
10:35:29 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:35:46 <djahandarie> :t let (.) = Prelude.. in (.).(.)
10:35:47 <lambdabot> parse error on input `Prelude..'
10:35:48 <lars9> :t sequence
10:35:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
10:36:38 <dolio> Although, I suppose you can't reverse that.
10:36:56 <EvanR-work> > genericReplicate 100000 'z'
10:36:57 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
10:37:02 <EvanR-work> > genericReplicate 1000000 'z'
10:37:03 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
10:37:06 <EvanR-work> > genericReplicate 100000000000 'z'
10:37:07 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
10:37:14 <EvanR-work> ok genericReplicate isnt broken ;)
10:37:30 <dolio> FFGFFGFG -> FFGFFG is, though.
10:38:09 <aristid> @src genericReplicate
10:38:09 <lambdabot> Source not found. Maybe you made a typo?
10:38:29 <aristid> > fromIntegral (100000000000 :: Integer) :: Int
10:38:30 <lambdabot>   100000000000
10:38:35 <lars9> :t liftM replicate
10:38:36 <lambdabot> forall a (m :: * -> *). (Monad m) => m Int -> m (a -> [a])
10:38:39 <aristid> > fromIntegral (10000000000000000000000000000000 :: Integer) :: Int
10:38:40 <lambdabot>   -4570789518076018688
10:38:48 <aristid> > fromIntegral (100000000000000000000000000000000 :: Integer) :: Int
10:38:49 <lambdabot>   -8814407033341083648
10:39:02 <dolio> So is FFGFFG -> FFFG, I think.
10:39:13 <aristid> > genericReplicate 100000000000000000000000000000000 'z'
10:39:14 <lambdabot>   "zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz...
10:39:39 <dolio> Perhaps not.
10:39:45 <arcatan> > length $ genericReplicate 10000000000000000000000000000000000 'z'
10:39:49 <lambdabot>   mueval-core: Time limit exceeded
10:40:34 <EvanR-work> > genericLength $ genericReplicate 1000000000000000000000000 'z'
10:40:36 <lambdabot>   *Exception: stack overflow
10:41:05 <EvanR-work> > genericLength $ genericReplicate 1000000000000000000000000 'z' :: Int
10:41:07 <lambdabot>   *Exception: stack overflow
10:41:55 <lars9> EvanR-work: can we use something else than .:?
10:42:06 <EvanR-work> ((.).(.))
10:42:19 <lars9> how to convert replicate to replicateM?
10:42:21 <EvanR-work> but its nicer to put then . in a nice pile
10:42:37 <EvanR-work> :t sequence .: replicate
10:42:38 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:43:02 <djahandarie> :t (sequence .) . replicate
10:43:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
10:43:06 <lars9> replicateM n x    = sequence (replicate n x)
10:43:14 <EvanR-work> @src replicateM
10:43:15 <lambdabot> replicateM n x = sequence (replicate n x)
10:43:26 <djahandarie> :t \f g -> (f .) . g
10:43:27 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f1 (f a) -> f1 (f b)
10:43:28 <lars9> i like this
10:43:35 <djahandarie> :t ((.).(.))
10:43:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:43:47 <lars9> i like english words
10:43:48 <EvanR-work> lars9: then dont both using (.) either ;)
10:43:58 <lars9> EvanR-work: lol
10:44:03 <EvanR-work> (f . g) x = f (g x)
10:44:57 <EvanR-work> h x = f (g x)
10:45:02 <EvanR-work> no need for (.) ;)
10:45:18 <aristid> or replacing the hidden whitespace operator by ($): f . g $ x = f $ g $ x
10:45:19 <tolkad> . is easier to understand though
10:45:33 <tolkad> I'd much rather read h = f . g 
10:46:08 <tolkad> as a bonus it confuses PHP and perl programmers who think you are trying to append them
10:46:18 <aristid> tolkad: it really does require less thought once you know .
10:46:38 <EvanR-work> whitespace should be composition
10:46:48 <EvanR-work> thats usually what we do when defining functions, compose
10:46:50 <aristid> EvanR-work: and . should be application?
10:46:55 <EvanR-work> yes!
10:46:57 <EvanR-work> ;)
10:47:00 <aristid> lol
10:47:08 <EvanR-work> f g h . x
10:47:16 <tolkad> EvanR-work: why don't we just stick to lambda calculus syntax
10:47:27 <aristid> EvanR-work: better yet, whitespace should be fmap :D
10:47:33 <EvanR-work> yes
10:47:44 <EvanR-work> and tabs should be <*>
10:47:48 * arcatan boots up his Agda virtual machine
10:48:02 <EvanR-work> and form feeds can be >>=
10:48:05 <tolkad> > letx = 3 in x
10:48:06 <lambdabot>   3
10:48:20 <tolkad> interesting, non breaking spaces are considered whitespace
10:48:25 <tolkad> we can give them special behavior
10:48:56 <tolkad> EvanR-work: what should nbsp be?
10:50:46 <EvanR-work> tolkad: callCC
10:52:28 <EvanR-work> :t callCC
10:52:29 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
10:52:57 <arcatan> call with yesterday's continuation
10:53:07 <geheimdienst> post to hpaste
10:53:46 <monochrom> hahaha
11:00:10 <BrianHV> the haskelldb web page on haskell.org has been unresponsive, but the google cache indicates it's from 1999.  is there some other place I should be looking for documentation?
11:05:38 <burp> BrianHV: http://hackage.haskell.org/package/haskelldb
11:05:55 <burp> haddock docs are working
11:12:13 <BrianHV> burp: thanks.  that led me to some archived docs on sourceforge that seem to be more than an api reference.
11:12:24 <BrianHV> don't know why I didn't think to check there first
11:12:31 <lars9> is readFile lazy?
11:12:46 <burp> BrianHV: the archived docs might be for 0.13
11:12:56 <burp> and I don't know how much has actually changed from 0.13 to 2.0
11:13:05 <burp> well you will see
11:20:16 <dnm_> infoe: =]
11:20:31 <infoe> dnm_: :)
11:21:01 * ksf wonders what one would get if one were to write a vcs that keeps both a git and darcs repository
11:21:31 <ksf> ...both approaches being antiparallel, as it stands.
11:26:00 <tg_> ksf: get the symmetric lenses guy to write transforms between them
11:26:18 <tg_> that shouldn't make him want to kill himse.f
11:26:21 <tg_> himself.
11:29:30 <ksf> I think the situation is simmilar to the expression problem, where you have to support a bijection between two completely diametrical views to have your code be extensible.
11:29:58 <ksf> that is, the actual code is something ethereal that's neither the one or other view.
11:30:31 <ksf> but then it's just a matter of keeping both around and up to date.
11:31:09 <ksf> ...as the bijection might be a bit lossy.
11:31:32 <ksf> (unless you restrict the expressivity of both views artificially)
11:35:55 <dschoepe> I'm having trouble with UTF8: When I use System.IO.UTF8.readFile everything works fine, but when using UTF8.getContents or UTF8.hGetContents, I get "Invalid or incomplete multibyte or wide character". With the standard System.IO I get the error either way.
11:36:39 <ksf> dschoepe, what's your locale setting?
11:36:51 <dschoepe> en_US.utf8
11:37:07 <ksf> hmmm
11:38:53 <dschoepe> ksf: I think the character that's causing the error is a ''
11:39:04 <ksf> oh.
11:39:14 <ksf> are you shure the _file_ is utf8 and not iso?
11:39:32 <ksf> you might try icu, there.
11:40:42 <dschoepe> ksf: You're right, that was the problem
11:40:48 <dschoepe> thanks
11:41:34 <dschoepe> Is there any way to handle this from Haskell instead of always expecting utf8-files?
11:41:51 <dschoepe> (Besides spawning iconv)
11:42:30 <lars9> forkIO is never invoked in my simple program...
11:42:38 <ksf> there's icu bindings, that should take care of all the encoding problems you are able to come across.
11:42:44 <dschoepe> Okay, thanks
11:42:56 <ksf> lars9, could it be that you just exit too fast?
11:43:01 <lars9> i compiled with -threaded, and run with +RTS -N2
11:43:25 <lars9> ksf: do you mean my main thread exit to fast?
11:43:29 <ksf> yep.
11:43:30 <dschoepe> lars9: If main exits, all threads are killed.
11:43:45 <lars9> how to let it wait?
11:43:52 <ksf> with a TVar or similar.
11:44:04 <lars9> to simulate?
11:44:18 <ksf> wait on it in the main thread, write to it at the end of your thread.
11:44:29 <lars9> ok, letme try
11:44:49 <ksf> if you never write to it your program is going to die even faster...
11:45:15 <roconnor> what is the type of the state-in-context comonad ?
11:46:24 <ksf> BONUS, want some help with a hypothetical iteratee lyah chapter? I think I'd need to explain them to deepen my understanding.
11:46:35 <ksf> also, do you think cps is adequate for lyah?
11:48:57 <sciolizer> Do I need to install ghc from source in order to be able to build .so files?
11:49:17 <ksf> ...while it's possible to implement them without cps, some understanding of continuations is necessary to grok them.
11:49:34 <ksf> ...and cps is one of the easier ways to get started with continuations
11:49:40 <ksf> sciolizer, in general, no.
11:50:24 <sciolizer> ksf: ok. Does the error `/usr/bin/ld: cannot find -lHSbase-4.1.0.0-ghc6.10.4` mean anything to you? (I can provide more information if you need it.)
11:51:01 <ksf> well, yes, it means that your ghc doesn't come with shared base libraries.
11:51:18 <sciolizer> ksf: ok, but I can download the shared base libraries from somewhere?
11:52:42 <ksf> I suggest you upgrade to 6.12.3, according to my system it comes with the libs.
11:52:55 <sciolizer> ksf: thanks. That's what I was hoping to hear.
11:53:26 <ksf> also, you might be confusing -shared with -dynamic, one of which builds an .so, the other one builds a non-static executable.
11:54:05 <ksf> iirc cabal-install right now doesn't really support building dynamically linked executables
11:54:05 <sciolizer> ksf: I'm trying to build a library for usage in c/c++, not an executable
11:54:33 <sciolizer> ghc -dynamic -fPIC -c IntLessThan.hs; ghc -dynamic -shared IntLessThan.o -o libIntLessThan.so
11:54:37 <ksf> yep, you most likely don't want to link you .so dynamically, then.
11:54:58 <sciolizer> ksf: so just drop the -dynamic?
11:55:04 <ksf> yep
11:55:28 <sciolizer> In that case, I get /usr/bin/ld: /home/jball/lib/ghc-6.10.4/base-4.1.0.0/libHSbase-4.1.0.0.a(Classes__5.o): relocation R_X86_64_32S against `.text' can not be used when making a shared object; recompile with -fPIC. You think that will be fixed with an upgrade?
11:55:32 <ksf> ...unless, of course, you're building more than one .so in which case -dynamic makes sense.
11:55:43 <sciolizer> ksf: I'm fine with just one .so.
11:56:06 <ksf> errr... yes. it's going to be fixed. if not properly, then due to the fact that you can use -dynamic.
11:57:37 <ksf> hmmm. I doubt those .a's will be compiled with -fPIC, as there's reason not to and the linking overhead incurred by just going .so all the way down is negligible.
11:57:54 <solistic> hmm, is there really no function Read a => String -> Maybe a
12:00:26 <EvanR-work> solistic: you could make one with catch
12:00:38 <ksf> or reads
12:00:48 <EvanR-work> :t reads
12:00:49 <lambdabot> forall a. (Read a) => String -> [(a, String)]
12:00:49 <copumpkin> reads is nicer
12:00:50 <ksf> (which would be preferrable)
12:00:57 <EvanR-work> ah
12:01:08 <copumpkin> :t fmap fst . listToMaybe . reads
12:01:09 <lambdabot> forall a. (Read a) => String -> Maybe a
12:01:19 <solistic> thx
12:01:38 <ksf> you might want to check whether snd is the empty string, too.
12:01:38 <WStude> Need quick help with a program error
12:02:03 <copumpkin> :t fmap fst . guard (not . null . snd) . listToMaybe . reads
12:02:04 <lambdabot>     Couldn't match expected type `Bool'
12:02:04 <lambdabot>            against inferred type `(a1, [a]) -> Bool'
12:02:04 <lambdabot>     In the first argument of `guard', namely `(not . null . snd)'
12:02:10 <solistic> I see, there is a definition in http://hackage.haskell.org/packages/archive/cgi/3001.1.7.1/doc/html/src/Network-CGI-Protocol.html#maybeRead
12:02:25 <WStude> got a program that, so far, is supposed to take something like [[1,2,3],[4,5,6],[7,8,9]], and return [1,4,7]
12:02:38 <EvanR-work> map fst
12:02:42 <EvanR-work> er head
12:02:44 <WStude> code here: http://hpaste.org/paste/41171/transpose#p41172
12:02:59 <WStude> I get a program error saying there is a pattern match failure
12:03:05 <EvanR-work> > map head [[1,2,3],[4,5,6],[]]
12:03:05 <lambdabot>   [1,4,*Exception: Prelude.head: empty list
12:03:17 <ksf> > map head $  [[1,2,3],[4,5,6],[7,8,9]]
12:03:18 <lambdabot>   [1,4,7]
12:03:35 <kmc> :t map head
12:03:36 <lambdabot> forall a. [[a]] -> [a]
12:03:38 <kmc> :t map head . filter (not . null)
12:03:39 <lambdabot> forall a. [[a]] -> [a]
12:03:51 <kmc> :t catMaybes . map listToMaybe
12:03:52 <lambdabot> forall a. [[a]] -> [a]
12:03:53 <EvanR-work> needs more type safety
12:04:04 <EvanR-work> NxN matrix type
12:04:07 <copumpkin> > head . transpose  $ [[1,2,3],[4,5,6],[7,8,9]]
12:04:10 <lambdabot>   [1,4,7]
12:04:10 <EvanR-work> N > 0
12:04:16 <WStude> okay, thx
12:04:19 <copumpkin> EvanR-work: I wrote something for that a while ago
12:04:22 <copumpkin> using SHE
12:04:28 <copumpkin> (also another version without)
12:04:33 <copumpkin> it had vector-space instances, too
12:04:44 <copumpkin> but it was on the old hpaste
12:04:54 <copumpkin> not sure if that stuff is still around
12:05:45 <EvanR-work> does Array have slicing?
12:07:01 <copumpkin> preflex: seen ivanm
12:07:02 <preflex>  ivanm was last seen on #haskell 9 days, 14 hours, 4 minutes and 30 seconds ago, saying: shachaf: moderately so ;)
12:08:14 <ksf> EvanR-work, write your own.
12:08:26 <EvanR-work> never!
12:08:36 <EvanR-work> i must use only frameworks made by people smarter than me
12:08:49 <ksf> ghc does a very decent job of compiling memcpy
12:09:32 <ksf> ...and if you have UArray, you might want to just provide an index mapping.
12:10:13 <ksf> as arithmetic is neglegible these days, cache misses are not.
12:10:37 <lars9> why ghc can not deduce type from this code : http://hpaste.org/41173/type
12:11:20 <c_wraith> lars9, because the only constraint you put on a was Ord
12:11:22 <lars9> line 16: pp is MVar [Integer], then in line 25
12:11:24 <c_wraith> It needs Read, also
12:11:34 <lars9> it should be [Integer] too
12:11:46 <c_wraith> but that's not what you told it
12:11:49 <mauke> lars9: that's not what it says in line 25
12:11:53 <c_wraith> you told it that it was a polymorphic function
12:11:56 <c_wraith> that takes an type a
12:12:02 <c_wraith> so long as a is an instance of Ord
12:12:08 <ArtyomKazak> preflex: seen preflex
12:12:09 <preflex>  what
12:12:30 <c_wraith> You need to add Read a to the head in line 25
12:12:45 <lars9> but sortAndMerge's caller tells it to use [Integer] right?
12:12:54 <c_wraith> doesn't matter
12:12:56 <mauke> lars9: irrelevant
12:12:56 <danderson> lars9: that's irrelevant
12:13:03 <monochrom> the "a" in "Ord a => MVar () -> MVar [a] -> FilePath -> IO ()" is different from the "a" in "... :: IO [a]"
12:13:03 <c_wraith> it typechecks based on the type you told it to be
12:13:05 <danderson> [Integer] satisfies Ord a
12:13:18 <danderson> but then in the function you assume that a is also an instance of Read
12:13:25 <danderson> but you didn't tell the compiler that you wanted that
12:13:44 <danderson> the compiler is looking at your function in isolation
12:13:52 <danderson> not relative to the callers
12:13:56 <monochrom> you are really better off not saying "IO [a]" there
12:14:00 <danderson> and, in isolation, its use of `show` is illegal
12:14:07 <lars9> do you mean the 'a' in line 25 and 27 is not the same?
12:14:15 <monochrom> right, they are not the same
12:14:26 <danderson> yeah, that too
12:14:39 <lars9> oh..
12:14:44 <danderson> the 'a' in the type signature is not available in the function body
12:14:59 <monochrom> you are not using pp anywhere.
12:15:49 <lars9> pp is about to be used as a pipe later
12:19:36 <lars9> it's fixed after connecting dat with pp :)
12:20:48 <monochrom> because the only way to propagte the type "a" is to use pp
12:21:14 <lars9> i see, i thought i can use line 25's a...
12:39:26 <WalterMundt> Question: I've determined that I want to try using a DiffUArray Int in a DP algorithm in Haskell for performance, but I'm new to arrays in Haskell.  How do I create one with a given size (contents can be undefined or zero)
12:39:32 <WalterMundt> ?
12:40:09 <copumpkin> I wouldn't use a DiffArray, really
12:40:19 <copumpkin> most DP algorithms work fine with lazy arrays, actually
12:40:21 <WalterMundt> okay, why not and what would you recommend?
12:40:37 <copumpkin> but writing a lazy implementation can be tricky
12:40:41 <monochrom> where is the doc of DiffArray so I can read it to you?
12:40:50 <copumpkin> DiffArrays are notorious for being slow
12:40:57 <WalterMundt> http://www.haskell.org/ghc/docs/6.8.2/html/libraries/array/Data-Array-Diff.html#2 ?
12:41:01 <copumpkin> probably don't need to be that slow, but nobody uses them so nobody has much of an incentive to fix them
12:41:01 <WalterMundt> Huh, interesting
12:41:09 <WalterMundt> that's good to know
12:41:24 <WalterMundt> from the concept it sounds like it could be quite fast at least in theory
12:41:42 <copumpkin> but anyway, a plain ol' lazy array is usually good enough, since most of the time you only need to make one edit to the cells
12:42:19 <WalterMundt> I'm just learning Haskell, sounds like that may possible, if rather tricky in this case to implement
12:42:24 <WalterMundt> er, may be possible
12:42:57 <copumpkin> http://www.haskell.org/haskellwiki/Dynamic_programming_example
12:43:03 <WalterMundt> my current imagined structure is not build around the array indices, but rather fills them in in intervals as it traverses another list
12:43:04 <copumpkin> that shows how to use a lazy array to do it
12:43:37 <monochrom> ones = array (5,20) [ (i, 1) | i<-[5..20] ]  -- creates array ones such that ones!i = 1 for each i from 5 to 20 inclusive
12:44:41 <monochrom> add a type signature "ones :: DiffArray Int Double" to resolve polymorphism.
12:44:58 <kmc> WalterMundt, DP is memoized recursion, right?
12:45:05 <kmc> WalterMundt, so you could just use data-memocombinators or MemoTrie
12:45:08 <WalterMundt> kmc: not in particular
12:45:08 <kmc> and forget the explicit array
12:45:15 <WalterMundt> it is sometimes implemented that way
12:45:17 <copumpkin> it is though
12:45:27 <copumpkin> it can always be implemented that way, can't it?
12:45:28 <WalterMundt> or rather, that's one way to look at it
12:45:34 <WalterMundt> I believe so
12:45:37 <copumpkin> it's the easiest way to do so in haskell
12:45:45 <copumpkin> since we already have mechanisms for doing that implicitly
12:45:55 <copumpkin> saves you from "scheduling" manually
12:46:25 <WalterMundt> in many cases that works nicely, the puzzle I'm playing with isn't as straightforward
12:47:45 <kmc> well an array is a function from indices to values
12:47:49 <monochrom> most dynamic programming algorithms are write-once memoizations. but I know one that loops over (a binary search over an array and changes the found entry). In particular the n*log n algorithm for longest increasing subsequence (non-consecutive)
12:48:20 <adnap> help! http://hpaste.org/41174/error?pid=41174&lang_41174=bash
12:48:28 <adnap> WHAT DOES IT MEAN?!
12:48:52 <adnap> Do I need to remove an old Cabal?
12:49:06 <WalterMundt> doing it this way is going to be really tricky, I was planning on using a tail-recursion through a list of events that would pass down a progressively-more-filled array
12:49:30 <kmc> WalterMundt, then you can do it that way
12:49:36 <kmc> DiffArray performs poorly
12:49:40 <adnap> I tried installing containers.
12:49:42 <copumpkin> adnap: do you have the same package in global and user lists?
12:50:18 <adnap> copumpkin: I don't know.  How do I  tell?  I'm not sure what those lists are.  Are they maintained by cabal?
12:50:20 <kmc> if you need an updatable lookup structure, use Map or IntMap or one of the packages like hashmap or EnumMap
12:50:25 <monochrom> Dijkstra has an exposition at http://www.cs.utexas.edu/users/EWD/ewd05xx/EWD591.PDF
12:50:30 <copumpkin> WalterMundt: maybe just run it in ST, but hat saves you from having to think as hard
12:50:35 <copumpkin> adnap: ghc-pkg list
12:50:44 <WalterMundt> I have a working impl using Map already
12:50:46 <copumpkin> adnap: see if containers 1.8.0.2 shows up in both lists
12:50:52 <WalterMundt> I was looking to see if I could do it faster with arrays
12:51:05 <copumpkin> WalterMundt: how often do you write each key?
12:51:07 <adnap> ghc-pkg list | grep -i cabal Cabal-1.8.0.2 Cabal-1.8.0.2
12:51:08 <kmc> possibly, but switching to IntMap will be much easier
12:51:21 <copumpkin> yay IntMap
12:51:44 <WalterMundt> copumpkin: once
12:52:06 <copumpkin> WalterMundt: then laziness will probably work out nicely
12:52:08 <WalterMundt> I will try IntMap too, that sounds nice
12:52:09 <copumpkin> since that's what it gives you
12:52:14 <copumpkin> IntMap is excellent
12:52:26 <monochrom> if you only write-once, it's merely memoization
12:52:58 <copumpkin> and laziness also saves you from thinking about the order of computation, as I mentioned earlier
12:52:58 <monochrom> all that glorification of dynamic programming is just historical zomgs.
12:53:02 <WalterMundt> copumpkin: but...that required inverting my current control structure, becuase I am currently writing whole intervals of values per outer level of recursion
12:53:32 <WalterMundt> there's probably some really simple way to do it, I'm just not used to thinking in functional programming mode yet
12:53:41 <adnap> Did you see my hpaste?  It says one version of Cabal is shadowed by another, but they both have the same numbers--just different garbage afterwards.
12:53:44 <copumpkin> WalterMundt: what is the algorithm actually doing? and how much of it is figuring out what order things need to be done in, and how much is the core algorithm?
12:53:55 <copumpkin> adnap: that suggests you have two of them
12:54:00 <WalterMundt> copumpkin: I'll /msg you with info on it, it's pretty simple
12:54:02 <mjo-work> Is it possible to have quickchecks 1 & 2 installed at the same time, or is this basically expected: "src/Maskbits.hs:119:4: `coarbitrary' is not a (visible) method of class `Arbitrary'"
12:54:17 <copumpkin> WalterMundt: I'm sure other people in here would be interested in it too, unless it's confidential
12:54:28 <WalterMundt> heh, not exactly
12:54:33 <WalterMundt> I'm doing http://www.facebook.com/careers/puzzles.php?puzzle_id=15
12:54:36 <copumpkin> whatever works best
12:54:38 <copumpkin> oh okay :)
12:54:42 <kmc> mjo-work, when you have two versions of a package installed, you can use your cabal file to choose which one is used
12:54:56 <WalterMundt> but it's considered good etiquette not to publicly discuss solution algorithms ;)
12:54:56 <adnap> copumpkin: Do I do ghc-pkg unregister "Cabal number-number-garbage"?
12:55:05 <copumpkin> adnap: that's a solution
12:55:07 <mjo-work> kmc: But just running ghc from the command line?
12:55:08 <copumpkin> WalterMundt: makes sense
12:55:19 <kmc> mjo-work, use cabal instead
12:55:21 <adnap> copumpkin: Is it the preferred solution?
12:55:28 <mjo-work> blarg =)
12:55:30 <kmc> mjo-work, otherwise you'll have to play with the ghc -package arguments
12:55:36 <kmc> that's what Cabal does for you...
12:55:37 * hackagebot ecu 0.0.6 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.6 (TomHawkins)
12:55:43 <copumpkin> adnap: maybe, not sure :) dcoutts is the master there
12:56:15 <adnap> Where can I read about cabal and ghc-pkg?  Are the man pages the best resource?
12:56:31 <mjo-work> Thanks for the info. I'm too lazy to write a cabal file at the moment, will just nuke QC-2. In the future I will do it correctly.
12:56:32 <adnap> Or is there a nice guide that describes how they interoperate?
12:57:20 <adnap> Or is there a nice guide that describes how they interoperate?
12:57:24 <adnap> Also, I get "ghc-pkg: cannot find package Cabal-1.8.0.2
12:57:39 <adnap> when I try to unregister, even though "list" says I have it.
12:59:09 <monochrom> you need a transactional file system and roll back all previous transactions until it is not broken
12:59:10 <pygmalion> what's the general status of web frameworks re: haskell? i seem to be finding more inactive frameworks than active ones. and further, what is/are the favorite(s)?
12:59:33 <monochrom> the favourite web frameworks are snap and yesod
12:59:37 <roconnor> @pl (\h -> f . h) . (\h -> g . h)
12:59:37 <lambdabot> ((f . g) .)
12:59:56 <roconnor> @pl (\h -> f . g . h)
12:59:56 <lambdabot> ((f . g) .)
13:00:00 <pygmalion> monochrom: thanks, i'll take a look
13:00:06 <Jafet> monochrom: we have it already, memorize all the command lines you typed to set up your current system
13:00:16 <Jafet> (It's more space efficient, too.)
13:00:55 <monochrom> not sure it is enough information to roll back. for example you see "rm Important.hs". how do you undo that one?
13:01:31 <dankna> darcs revert Important.hs :)
13:01:36 <Jafet> You could run your editor in screen and log all keystrokes.
13:01:40 <dankna> note: I just walked in and have no idea what the context is
13:01:56 <Jafet> Actually that wouldn't work. The log would be stored on the filesystem
13:01:57 <Azrael-> > let x = x in x
13:02:01 <lambdabot>   mueval-core: Time limit exceeded
13:02:08 <monochrom> transactional file system. unlimited undo of everything you did to your file system.
13:02:09 <hpc> > fix error
13:02:10 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:02:23 <Azrael-> :t fix
13:02:24 <lambdabot> forall a. (a -> a) -> a
13:02:28 <Azrael-> @src fix
13:02:28 <lambdabot> fix f = let x = f x in x
13:02:39 <hpc> your example would be fix id
13:03:04 <roconnor> what do you call an applicative functor morphism?  An idomatic transformation?
13:03:04 <copumpkin> > fix fail
13:03:05 <lambdabot>   ""
13:03:12 <Jafet> > fix (fix.)
13:03:15 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a
13:03:15 <monochrom> My pet peevish hypothesis is that all your cabal-install problems are due to your own previous mishap.
13:03:40 <hpc> fix id has the entertaining property of using no CPU time, in addition to no memory
13:03:59 <hpc> (on my machine, anyway)
13:04:28 <tarrasch> :pt (+)
13:04:54 <tarrasch> any channel available to play with the bot?
13:05:16 <Zao> tarrasch: She listens to PMs.
13:05:24 <adnap> When ghc-pkg list shows two packages with identical numbers, but different garbage afterwards, does that mean that those are distinct packages with minor differences?
13:05:37 <tarrasch> Zao, oh ok, btw, what's the name of the bot again? :p
13:05:37 <Zao> adnap: Hashes from building them, aren't they?
13:05:46 <Zao> @botsnack
13:05:46 <lambdabot> :)
13:06:16 <adnap> So, how can I resolve an issue where one shadows the other, if the problem occurs during the build process?
13:06:55 <tarrasch> How did one ask it to turn something into pointfree form?
13:07:20 <lars9> what's the time & space complexity of appending two lists? say: a ++ b, length a = m, length b = n
13:07:33 <monochrom> ghc-pkg unregister one of them. you may need to ghc-pkg unregister other packages that depend on it. transitively.
13:07:37 <maurer_> O(m) on both
13:08:01 <lars9> maurer_: could you explain why?
13:08:14 <lars9> maurer_: walk though a to its end, then append?
13:08:18 <maurer_> Kind of.
13:08:20 <Zao> @pl \x y z -> (y + z)
13:08:20 <lambdabot> const (+)
13:08:29 <lars9> maurer_: thanks
13:08:37 <maurer_> The difference being that you don't mutate anything, so you have to effectively replace the last value with a new one that points at b
13:08:45 <maurer_> Which means you have to replace the one before it
13:08:46 <maurer_> etc.
13:09:10 <maurer_> So you effectively need O(m) new cdrs to construct the concatenated list
13:09:16 <maurer_> Thus the O(m) space
13:09:24 <lars9> i see
13:10:00 <maurer_> Note this does not mean it will allocate new cars, which is good if the elements of the list are big.
13:10:07 <lars9> if list a and (a++b) share the content of a, how can a know where its end is?
13:10:15 <maurer_> They don't.
13:10:16 <copumpkin> I'm really enjoying FMList
13:10:25 <Jafet> They could, if b is [].
13:10:27 <maurer_> a and (a ++ b) share cars.
13:10:31 <copumpkin> it's a datastructure for holding fmylife entries
13:10:39 <maurer_> Jafet: Sure, but I assume he's talking about the general case.
13:10:50 <monochrom> ghc metadata records installed packages as "name-version-uuid". the garbage you see is uuid.
13:10:59 <Jafet> Does ghc let you get the address of an object?
13:11:09 <Jafet> Otherwise, there's no real way to tell.
13:11:18 <maurer_> Jafet: GC.
13:11:22 <maurer_> Also by thinking about STG
13:11:41 <maurer_> Jafet: Also, ++[] violates my runtime/space constraints as well
13:11:44 <copumpkin> Jafet: you can ask for a stablename or stablepointer
13:11:53 <maurer_> > take 5 $ (fix (0:)) ++ []
13:11:54 <lambdabot>   [0,0,0,0,0]
13:12:01 <copumpkin> but that may not provide enough guarantees for you
13:12:07 <Jafet> Well, I was thinking a backdoor along the lines of trace
13:12:10 <maurer_> Err, nvm, that's just laziness, that's fine.
13:13:10 <lars9> say a = [1,2,3], b = a ++ [4,5,6], after evaluating b, length a is still 3
13:13:29 <maurer_> Yes.
13:13:38 <maurer_> Thus my comment about sharing cars but not cdrs
13:13:43 <lars9> if they share the same content, how can that be 3?
13:13:44 <Jafet> I guess you can't get that address in general, because the objects in question might not even exist.
13:14:01 <mauke> they don't share their spine
13:14:01 <osaunders> lars9: How do they have the same content?
13:14:03 <maurer_> Think about the list formulation:
13:14:14 <copumpkin> adnap: did you figure it out?
13:14:21 <lars9> osaunders: partially
13:14:25 <osaunders> > let a = [1..3], b = a ++ [4..6] in length a
13:14:25 <lambdabot>   <no location info>: parse error on input `,'
13:14:26 <maurer_> data List a = Empty | Node a (List a)
13:14:40 <osaunders> > let a = [1..3]; b = a ++ [4..6] in length a
13:14:41 <lambdabot>   3
13:14:45 <Jafet> lars9: if you have defined a to be [1,2,3], why would you ever expect a to change?
13:14:48 <adnap> copumpkin: No, I don't know what's going on.  I don't even have the version of Cabal it's talking about.  I think it's trying to download and build it itself because it depends on it.
13:14:57 <maurer_> Now, if I concatenate a and b, the first argument in the Node constructor will be reused everywhere
13:15:07 <maurer_> The second argument will have to be newly allocated.
13:15:10 <maurer_> Does this make sense?
13:15:11 <copumpkin> adnap: did you ghc-pkg unregister one of those two?
13:15:16 <copumpkin> adnap: can you paste the output of ghc-pkg list ?
13:15:21 <adnap> copumpkin: They're not registered.
13:15:23 <copumpkin> into hpaste or something
13:15:25 <copumpkin> hm
13:15:27 <adnap> copumpkin: Sure
13:15:35 <copumpkin> and then the full error
13:16:50 <osaunders> lars9: If b were evaluated it would use the data from a but a would not be changed.
13:16:54 <lars9> maurer_: that's ture only if a and b only share the value(object) part, but the linked list part is independent
13:17:44 <lars9> osaunders: sure, i'm thinking about its complexity so i want to know how it's implemented internally
13:18:01 <maurer_> @src (++)
13:18:01 <lambdabot> []     ++ ys = ys
13:18:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
13:18:01 <lambdabot> -- OR
13:18:01 <lambdabot> xs ++ ys = foldr (:) ys xs
13:18:05 <maurer_> There.
13:18:19 <osaunders> lars9: OK but why do you want to know that?
13:19:03 <lars9> osaunders: what's the time & space complexity of appending two lists with length of m and n?
13:19:04 <adnap> copumpkin: http://hpaste.org/41176/error
13:19:25 <Jafet> That question does not make sense in Haskell, lars9.
13:19:50 <Jafet> > head ([1..100000000] ++ [1..100000000])
13:19:51 <lambdabot>   1
13:20:00 <maurer_> Jafet: It kind of does. Assume that "time and space complexity of expression e" actually means "time and space complexity of deepseq e"
13:20:07 <copumpkin> adnap: you have two copies of containers, it seems
13:20:29 <copumpkin> ghc-pkg unregister --user containers
13:20:33 <Jafet> Your modified form of the question has no relevance to most Haskell I write, either.
13:20:49 <adnap> copumpkin: I think that's because I tried to install containers after it said that it couldn't resolve that dependency.
13:20:50 <osaunders> lars9: Are you looking to learn Haskell or do you have a specific task that you want to evaluate Haskell for?
13:20:52 <Jafet> Sure, there's an answer, but knowing it is often irrelevant.
13:21:16 <maurer_> Jafet: Sure. Sometimes it is relevant though.
13:21:29 <copumpkin> adnap: still, I'd remove it
13:21:34 <maurer_> lars9: If you are running into efficiency issues with list append, I suggest you use Data.Sequence
13:21:39 <copumpkin> then we can see what error it encounters next
13:21:40 <adnap> copumpkin: I just did.
13:21:46 <copumpkin> adnap: what's the new error?
13:21:50 <lars9> osaunders: now in my program, i need to append two lists a lot, i can choose to put the larger one first or smaller first
13:22:02 <adnap> copumpkin: Oh wait, it says it would break a bunch of stuff I have installed.
13:22:11 <adnap> copumpkin: Should I force it?
13:22:21 <Haskellhelp> hello guys, does somebody know a function thats removes backets from begin and end of a line of code, ie (double x = 0)
13:22:24 <copumpkin> adnap: you definitely removing the user one?
13:22:30 <adnap> copumpkin: Yes
13:22:37 <maurer_> lars9: If you can pick between smaller and larger first, it sounds like you're using a list where you should be using a Set.
13:22:38 <monochrom> you should expect to ghc-pkg unregister those other stuff and install them again later
13:23:03 <copumpkin> adnap: Saizan may know a better answer
13:23:05 <Haskellhelp> please?
13:23:06 <copumpkin> he seems to know cabal pretty well
13:23:08 <lars9> osaunders maurer_ it's like a buffer, or StringBuilder
13:23:24 <adnap> copumpkin: When I run cabal install, how does it decide whether to install specifically for me, or for all users?
13:23:33 <monochrom> use Data.Sequence for string builder
13:23:48 <adnap> copumpkin: I don't know how I ended up with so many packages in both camps.  It's not like I ever specify.
13:23:52 <maurer_> Then use Data.Sequence, as I said earlier.
13:24:02 <maurer_> In that case, you also _don't_ have the choice of which to put first.
13:24:12 <lars9> monochrom: maurer_ thanks
13:24:15 <copumpkin> or use an FMList!
13:24:20 <copumpkin> cause FMLists are super cute
13:24:31 <monochrom> ok, FMList
13:24:36 <osaunders> lars9: Just do whatever and worry about it if that's too slow. Haskell gets very deep, very quickly and the value of going to that level of depth is often small. If you want to learn Haskell my advice is to save the big questions for later when you'll understand the answers better. Just try and write some code and play around and don't prematurely optimize.
13:24:40 <lars9> maurer_: their size is like tens vs thousands
13:25:27 <lars9> osaunders: good suggestion, thanks
13:25:44 <osaunders> If you have a high-performance requirement right now then obviously a lot of what I said doesn't apply but my guess is that you don't.
13:25:59 <monochrom> there is a way to rewrite your algorithm so you don't append.
13:26:12 <copumpkin> prepend?
13:26:21 <monochrom> yeah, like what map and scanl do
13:26:56 <lars9> monochrom: it's really easy to fall back to C mind though
13:27:01 <mauke> actually, DList is the StringBuilder
13:27:12 <maurer_> Another method is concatMap
13:27:18 <mauke> has anyone suggested that yet?
13:27:25 <monochrom> if you ask an imperative programmer to write map, they say, "I know, I will create an accumulator list variable and keep appending stuff to its end".
13:27:38 <monochrom> Now they have two problems. :)
13:27:55 <Jafet> Eager to be lazy.
13:28:03 * mauke ponders a regex-based implementation of map
13:29:37 <copumpkin> mauke: DList isn't as esoteric as FMList
13:29:41 <copumpkin> while still behaving similarly
13:29:47 <copumpkin> I prefer estoeric solutions
13:30:09 <monochrom> yes, the cutest babe wins
13:30:09 <maurer_> lars9: Out of curiosity, what are you building?
13:30:19 <copumpkin> monochrom: damn right
13:31:11 <lars9> maurer_: a simulation...
13:31:40 <maurer_> Wow. How specific.
13:32:12 <mauke> preflex: ? vague
13:32:12 <preflex>  You had better be a bit more vague, otherwise we might be able to help you.
13:32:13 <maurer_> Sorry to be sarcastic, but a simulation tells me next to nothing about what you are building other than that someone else defined the rules.
13:32:28 <lars9> maurer_: yeah, a distributed merge sort with very limited memory on each pc, how stupid
13:32:54 <lars9> maurer_: does whatever prof says though
13:34:10 <devinus> Is there a distributed haskell DB capable of holding gobs and gobs and gobs of text
13:34:21 <devinus> ?
13:34:38 <monochrom> God, Oleg reduces type inference to 3 lines of haskell code. And they aren't even real lines of code, just declaring a type class. http://article.gmane.org/gmane.comp.lang.haskell.cafe/83088
13:34:40 <adnap> What is the package gtk2hsC2hs?
13:34:45 <devinus> like...in the double terrabytes range
13:35:05 <devinus> double digit*
13:35:34 <copumpkin> devinus: nothing haskell-specific
13:35:45 <copumpkin> devinus: there may be bindings to another database though
13:35:50 <devinus> hrm...dang
13:36:08 <devinus> i thought with haskells work with stm and distributed stuff in general somebody may have researched it
13:39:18 <lars9> devinus: exactly, i'm looking forward to see haskell's name in distributed systems
13:39:30 <devinus> are ther more distributed stuff coming for ghc7?
13:39:36 <lars9> not untill now
13:39:54 <devinus> i use erlang on a daily basis, i would love to see haskell incorporate some of erlangs ideas
13:40:34 <lars9> devinus: can erlang run on clusters?
13:40:45 <devinus> lars9: depends on what you mean by clusters
13:40:45 <lars9> seemlessly
13:41:04 <devinus> lars9: we run erlang on "clusters" of computers if that's what you mean
13:41:14 <lars9> devinus: program on multiple computers the same as on one
13:41:16 <devinus> i'm unfamiliar with the term clusters if that's not what you mean
13:41:26 <adnap> How do I get gtk2hsC2hs?  Am I supposed to be able to get this by installing gtk with cabal?
13:41:33 <devinus> lars9: yes, you can
13:42:28 <lars9> devinus: that's great
13:43:53 <Jafet> Um, erlang was designed from the beginning to run on distributed systems
13:45:43 <devinus> Jafet: yes. i thought i heard somewhere that Haskell had distributed stuff coming up in ghc7
13:45:46 <devinus> was i wrong?
13:46:00 <Jafet> Rumours and legends. I don't know.
13:46:03 <adnap> Why is it that when I try to install gtk I get setup: gtk2hsC2hs is required but it could not be found.
13:47:21 <ccasin> adnap: try installing gtk2hs-buildtools forst
13:47:24 <ccasin> *first
13:47:31 <adnap> ccasin: Yeah, I just tried that.
13:47:48 <adnap> ccasin: It says cabal: alex is required but it could not be found.
13:47:59 <ccasin> adnap: do a cabal install alex
13:48:02 <ccasin> and a cabal install happy
13:48:11 <adnap> Why doesn't it do this automatically?
13:48:28 <ccasin> cabal can't handle executable package dependencies right now
13:48:58 <ccasin> basically, if your package installs a program but no libraries, it's very hard for another package to make cabal install yours first
13:49:02 <adnap> Also, it seems to be recompiling Data.Sequence, Data.Set, etc over and over.
13:50:02 <adnap> Ha-ha... it says Warning: This package indirectly depends on multiple versions of the same
13:50:05 <adnap> package. This is highly likely to cause a compile failure.
13:50:31 <ccasin> hmm... that shouldn't happen if you're installing something common.  What version of ghc are you using?
13:50:35 <adnap> It's still saying cabal: alex is required but it could not be found.
13:50:48 <adnap> 6.12.1
13:50:50 <ccasin> did alex successfully install?
13:51:19 <ccasin> gtk2hs might require a newer version, I'm not sure
13:51:29 <adnap> yes, alex install successfully
13:51:58 <ccasin> is the cabal install directory on your path?
13:52:09 <ccasin> for example, on linux this is often ~/.cabal/bin
13:52:16 <adnap> ccasin: Yes
13:52:50 <ccasin> and alex is in that directory but "cabal install happy" reports that it can't find alex?
13:53:40 <adnap> No, happy installs fine.
13:54:57 <ccasin> but gtk won't?
13:55:13 <ccasin> If so, you've reached the limit of my expertise, maybe someone else can help
13:56:16 <adnap> ccasin: http://hpaste.org/41177/error
13:57:36 <ccasin> my best guess is that you need to update your ghc because some standard library depends on an old version of something in your current version
13:58:14 <jmcarthur> adnap: if you type `which alex`, what does it say?
13:58:38 <adnap> jmcarthur: /home/adnap/.cabal/bin/alex
13:58:57 <adnap> ccasin: My repo doesn't seem to contain a new ghc.  Do I need to build the latest from source?
13:58:59 <jmcarthur> are you installing gtk2hs with sudo or su or anything?
13:59:39 <adnap> jmcarthur: Yes... whoops.
13:59:44 <jmcarthur> there we go :)
14:00:02 <adnap> Should I always install globally?  I hate that I have all these problems between global and user.
14:00:54 <jmcarthur> i always install locally, personally
14:01:20 <adnap> But sometimes seems to install globally.  I don't know why I have like 20 packages for each.
14:01:36 <adnap> I just want them all in the same place so I never have problems.
14:01:54 <jmcarthur> i never use --global and never used sudo
14:01:57 <jmcarthur> *use
14:02:08 <adnap> I guess the reason is because I sometimes use sudo.
14:02:28 <adnap> I need to wipe out all my packages in global and reinstall them locally.
14:11:26 <jrk_> hi
14:11:50 <jrk_> can i do this better/more elegant?
14:11:51 <jrk_>         foldr1 (\v -> (++) $ (++) v " ")
14:11:52 <jrk_>         foldr1 (\v -> (++) $ (++) v " ")
14:11:59 <jrk_> uh, sorry
14:12:42 <sciolizer> @pl \v -> (++) $ (++) v " "
14:12:43 <lambdabot> (++) . (++ " ")
14:12:51 <sciolizer> meh
14:13:24 <jrk_> ewh
14:13:26 <mauke> what does that do?
14:13:26 <jrk_> thanks
14:13:31 <Martty> > (++" ") "hi"
14:13:32 <lambdabot>   "hi "
14:13:37 <mauke> actually, there's only one thing it can really do
14:13:40 <danderson>  it appears to be `unwords`
14:13:40 <mauke> jrk_: unwords
14:13:56 <jrk_> geeeh :)
14:14:46 <jrk_> got to know your standard library
14:14:56 <jrk_> thanks a lot
14:15:28 <danderson> jrk_: also, http://haskell.org/hoogle/
14:15:37 <danderson> give it a type signature, sometimes it can help guide you
14:15:48 <danderson> e.g.: http://www.haskell.org/hoogle/?hoogle=[String]+-%3E+String
14:16:52 <jrk_> ah, nice one
14:16:58 <arcatan> intersperse and intercalate are also related to unwords and unlines
14:17:32 <jrk_> i hope i remember hoogle when i need it the next time :)
14:18:48 <monochrom> I have finally finished skipping all of haskell-cafe
14:21:09 <ddarius> One day I need to do a Mark All as Read.
14:22:12 <Martty> i have 200 unread atm
14:22:21 <Martty> its a nice round number
14:22:36 <maurer_> 
14:22:46 <ddarius> I have 5627 unread "conversations" which is GMail's term for threads.
14:24:34 <McManiaC> 4659 ^^
14:24:59 <c_wraith> you know you can mark those all unread in one pretty-fast pass? :)
14:25:03 <c_wraith> err, all read
14:25:20 <Martty> settings -> delete account
14:36:39 <sciolizer> /usr/bin/ld: Test.o: relocation R_X86_64_32S against `stg_CAF_BLACKHOLE_info' can not be used when making a shared object; recompile with -fPIC
14:36:46 <sciolizer> oh the joys of Haskell + shared objects
14:59:22 <limetree> I found this a bit curious: let f x = x * x; g' = f . f
14:59:33 <limetree> why does g receive the less general type Integer -> Integer?
14:59:50 <monochrom> monomorphism restriction
15:00:04 <limetree> ah, I've heard of that before.
15:00:50 <monochrom> all definitions that syntactically look like "identifier = blah" receives this treatment. use explicit type signature to override.
15:00:59 <kmc> or write "g' x = f (f x)"
15:01:08 <kmc> it's a silly rule that should be removed in the future
15:01:52 <monochrom> with GHC you can also use {-# LANGUAGE NoMonomorphismRestriction #-}
15:03:39 <tonkman> is it really impossible to write a program using win32 library?
15:04:43 <tonkman> win32.window for gui, i mean
15:05:08 <monochrom> I heard it is possible. I haven't tried.
15:05:31 <monochrom> I only knew win16 and it was a long time ago.
15:05:57 <damex> is code.haskell.org working for anyone ? =/
15:06:10 <asdf25> no i think it's been down since at least yesterday
15:06:17 <damex> =/
15:06:22 <tonkman> I tried search some examples from google code search
15:06:29 <tonkman> but found almost nothing
15:06:46 <monochrom> you may like http://downforeveryoneorjustme.com/ as an extra data point
15:07:29 * hackagebot DRBG 0.1.1 - A deterministic random bit generator (aka RNG, PRNG) implementing DRBGs from NIST SP 800-90  http://hackage.haskell.org/package/DRBG-0.1.1 (ThomasDuBuisson)
15:08:01 <ddarius> monochrom: If you can write something with win16 you can write something with win32
15:09:58 <monochrom> I wrote win16 toy programs in turbo c++, such as "create window, provide button, when clicked pop up some message"
15:10:14 <monochrom> oh, it was already borland c++ by then
15:10:17 <tonkman> http://www.google.com/codesearch/p?hl=en#SwdK0I69n_c/hugs98-Mar2005-patched/fptools/libraries/Win32/examples/hello.lhs&q=Graphics.Win32.Window&sa=N&cd=1&ct=rc
15:10:35 <monochrom> then I did the same on OS/2 with watcom c++ or something
15:10:44 <tonkman> that hello world makes me think is win32 a good choise
15:11:15 <monochrom> So yeah! I knew Presentation Manager/2 too!
15:22:50 <monochrom> my new article: http://www.vex.net/~trebla/haskell/scanl.xhtml
15:30:56 <Mathnerd314> monochrom: interesting. could one define scanl that way?
15:31:53 <monochrom> not define. but characterize. as in, you can fit your problem into scanl that way.
15:32:25 <dolio> It's similar to the universal property of foldr.
15:33:14 <dolio> Where if you have a set of equations: 'f [] = z ; f (x:xs) = g x (f xs)', f = foldr g z.
15:35:02 <dolio> Except the characterization of scanl is for a corecursive function.
15:36:01 <Mathnerd314> monochrom: I guess I was asking whether scanl was the only function satisfying those properties
15:36:11 <monochrom> it is.
15:41:49 <dankna> :t scanl
15:41:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:42:26 <Mathnerd314> @djinn (a -> b -> a) -> a -> [b] -> [a]
15:42:26 <lambdabot> Error: Undefined type []
15:42:53 <identity_> Can it really be that popen isn't in the standard library?
15:42:56 <identity_> or something analogous
15:44:00 <mauke> http://haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html
15:44:03 <Nibble> does haskell feature something like CL's run-time reevaluation of functions?
15:44:21 <dankna> No.
15:44:32 <identity_> mauke: ah, thanks. I'll take a look
15:45:15 <dankna> The run-time loading features you refer to in Common Lisp are made possible by its dynamic typing and relative lack of optimization; Haskell can't load things dynamically because that could require recompiling the rest of the program.
15:45:20 <dankna> loosely
15:45:26 <dankna> I'm sure someone will chime in to say "not quite"
15:45:46 <monochrom> like eval? no. unless you use GHC specifically, then you may use http://hackage.haskell.org/package/hint , which boils down to including a copy of GHC in your executable
15:46:07 <sproingie> it can't load arbitrary code dynamically no, but there's quite a bit you can load if you're not creating new types
15:46:09 <dankna> of course in Lisp, including the compiler in your executable is the only choice :)
15:47:45 <lispy1> sproingie: I thought dons thesis said you can load arbitrary types as long as you use things like Data.Dynamic
15:48:10 <sproingie> well Data.Dynamic isn't an arbitrary type, it's Data.Dynamic
15:48:33 <monochrom> the type loaded is known to the host program statically to begin with
15:49:17 <monochrom> existential type makes it flexible despite static
15:49:45 <dankna> now, if what you want is to load modules which are already compiled, you can use hsplugin or my own direct-plugins
15:50:02 <dankna> the latter grovels the .hi file to ensure that the type you get is the type you ask for, but it isn't complete in some fashion that I forget
15:50:26 <hpc> lol
15:50:35 <dankna> indeed
15:51:31 <identity_> mauke: Thanks a ton. System.Process is /exactly/ what I was looking for
15:51:43 <identity_> and it is much nicer than having to deal with popen directly(or a basic equivalent)
15:52:57 <monochrom> re-exports are not chased.
15:53:17 <dankna> ah, thanks, yes, that was at least one of its failings
15:53:19 <kmc> Nibble, to evaluate something at runtime, see packages: hint mueval plugins direct-plugins metaplug
15:53:26 <kmc> and the GHC API itself
15:53:36 <Nibble> ok
15:53:36 <dankna> also consider writing a scripting language instead
15:53:47 <dankna> Haskell is /good/ at writing scripting languages
15:54:02 <hpc> verily
15:54:05 <kmc> Nibble, you can also make your program recompile itself to adapt to new code.  see dyre
15:57:15 <aristid> > [ y | x <- [Just 1, Nothing, Just 2], let Just y = x ]
15:57:16 <lambdabot>   [1,*Exception: <interactive>:1:183-192: Irrefutable pattern failed for patt...
15:57:45 <aristid> hmm i expected it to use fail instead
15:58:10 <kmc> > do { let Just _ = Nothing; return 3 } :: Maybe Int
15:58:10 <lambdabot>   <no location info>: parse error on input `}'
15:58:39 <kmc> > do { let { Just _ = Nothing }; return 3 } :: Maybe Int
15:58:40 <lambdabot>   Just 3
15:58:45 <kmc> > do { let { Just x = Nothing }; return x } :: Maybe Int
15:58:46 <lambdabot>   Just *Exception: <interactive>:1:144-159: Irrefutable pattern failed for pa...
16:00:40 <aavogt> it uses fail for matches left of  <-
16:01:41 <aristid> > [ y | x <- [Just 1, Nothing, Just 2], Just y <- return x ]
16:01:42 <lambdabot>   [1,2]
16:09:13 <ddarius> dankna: It's not a matter of "not quite."  Dynamic loading of code requires neither dynamic typing (or at least pervasive dynamic typing) nor recompiling the whole program.
16:09:28 <dankna> well, okay
16:09:51 <ddarius> Also, there are quite performant CL implementations and even more dynamic languages such as Self.
16:10:35 <dankna> oh, I didn't mean to cast aspersions on CL, but it doesn't do whole-program optimization or cross-module inlining or such
16:10:53 <dankna> it does purely local optimization
16:11:03 <sproingie> how many compilers in fact do that?
16:11:06 <ddarius> dankna: What are you talking about?
16:11:28 <dankna> I'm also not sure that ghc DOES do these things ^^'
16:11:29 <ddarius> I agree most CL compilers don't do whole-program optimization, but then most compilers period don't do that.
16:12:06 <sproingie> go scheme and there's stalin.  mlton for ml.  don't know of a haskell compiler that does.
16:12:07 <ddarius> GHC quite definitely does not do whole program optimization.  JHC does, but you can't build anything with JHC.
16:12:11 <dankna> hmm okay
16:12:19 <sproingie> ok a useful haskell compiler :)
16:12:56 <aristid> maybe GHC 7.2 or so will?
16:13:02 <ddarius> aristid: Nope.
16:13:13 <sproingie> ghc 17.0 perhaps :)
16:13:22 <aristid> huh? is it so impossible to do?
16:13:27 <sproingie> it's ... hard
16:13:41 <ddarius> aristid: It's easy to do if you don't mind waiting days for compiles.
16:13:56 <ddarius> (and you have a lot of RAM)
16:14:15 <aristid> well it doesn't have to have perfect results initially
16:14:31 <ddarius> Extant ones certainly don't produce perfect results.
16:15:20 <aristid> just... if you determine which kinds of optimisations would bring the best results and only apply those...
16:15:33 <sproingie> finding the "optimal optimizaion" of a program is traveling salesman writ large
16:15:43 <sproingie> and may not even be applicable under all conditions
16:15:43 <aristid> sproingie: i mean empirically
16:16:29 <sproingie> there's profile guided optimization
16:16:34 <sproingie> they tend to produce modest results
16:16:43 <sproingie> and i suspect they'd be a bitch and a half for haskell
16:17:18 <Axman6> @pl (\x s' -> f x (go s'))
16:17:18 <lambdabot> (. go) . f
16:17:52 <ddarius> aristid: If you don't produce significantly better results than traditional compilers, then there is little reason to lose separate compilation.
16:18:48 <ddarius> Though there are some uses of whole program compilation unrelated to performance.
16:27:13 <osaunders> @let toMaybe p = listToMaybe . filter p . pure
16:27:14 <lambdabot>  Defined.
16:27:23 <osaunders> > toMaybe (> 3) 4
16:27:25 <lambdabot>   Just 4
16:27:30 <osaunders> > toMaybe (> 3) 2
16:27:31 <lambdabot>   Nothing
16:27:41 <osaunders> Does that already exist anywhere?
16:27:43 <dankna> :t pure
16:27:44 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:28:02 <hpc> :t toMaybe
16:28:03 <lambdabot> forall a. (a -> Bool) -> a -> Maybe a
16:28:10 <hpc> (this is IRC; cannot tab complete...)
16:28:25 <shaketheworld> anybody here?
16:28:30 <hpc> no
16:28:33 <hpc> we are all robots
16:28:36 <Rembane> Nobody
16:28:46 <sipa> none at all
16:28:47 <hpc> not even you
16:29:12 <osaunders> > pure 1 :: [Int]
16:29:13 <lambdabot>   [1]
16:30:15 <dankna> > pure 1 :: [[Int]]
16:30:16 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Int])
16:30:16 <lambdabot>    arising from the literal `...
16:30:35 <osaunders> @pl toMaybe p = listToMaybe . filter p . pure
16:30:36 <lambdabot> toMaybe = (listToMaybe .) . (. pure) . filter
16:30:40 <osaunders> @pl toMaybe p x = if p x then pure x else Nothing
16:30:40 <lambdabot> toMaybe = flip flip Nothing . (`ap` pure) . (if' .)
16:33:58 <osaunders> @hoogle :: (MonadPlus m) => (a -> Bool) -> a -> m a
16:33:58 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
16:33:58 <lambdabot> Data.IntMap filter :: (a -> Bool) -> IntMap a -> IntMap a
16:33:58 <lambdabot> Data.Foldable find :: Foldable t => (a -> Bool) -> t a -> Maybe a
16:35:40 <aristid> :t let whenM f a = guard (f a) >> return a in whenM
16:35:41 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => (b -> Bool) -> b -> m b
16:35:55 <aristid> osaunders: but i guess you were searching for an existing function?
16:36:21 <osaunders> Yeah.
16:36:25 <osaunders> I also came up with this:
16:36:26 <osaunders> monadify p x = if p x then return x else mzero
16:37:06 <aristid> beautiful name :D
16:37:12 <kmc> monadulate
16:44:19 <hpc> osaunders: that looks a lot like 'when'
16:44:58 <osaunders> hpc: Really? when doesn't return anything useful.
16:45:09 <hpc> :t when
16:45:09 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:45:18 <hpc> osaunders: i didn't say it /was/ when :P
16:45:24 <osaunders> lol
16:45:39 <sproingie> monadinate
16:45:55 <osaunders> There are conceptual similarities, possibly yes.
16:46:02 <ddarius> Larry Nivens waxes poetic about PKI.
16:46:06 <osaunders> > when True (print "foo")
16:46:07 <lambdabot>   <IO ()>
16:46:25 <osaunders> > when False (print "foo")
16:46:26 <lambdabot>   <IO ()>
16:46:48 <sproingie> lambdabot's output being not too useful 
16:47:11 <sproingie> > when False (Just 5)
16:47:12 <lambdabot>   No instance for (GHC.Num.Num ())
16:47:12 <lambdabot>    arising from the literal `5' at <intera...
16:47:35 <sproingie> :t when
16:47:36 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
16:47:41 <sproingie> durr durr
16:48:32 <sproingie> :t guard
16:48:32 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
16:48:44 <hpc> @src guard
16:48:44 <lambdabot> guard True  =  return ()
16:48:44 <lambdabot> guard False =  mzero
16:48:53 <hpc> huh
16:48:57 <hpc> @instances MonadPlus
16:48:58 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
16:49:15 <sproingie> still less general than the monadimunge function above
16:49:33 <aristid> > mzero :: Either Int Int
16:49:34 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Types.Int)
16:49:34 <lambdabot>    arising ...
16:49:43 <aristid> @instances is a liar!
16:49:43 <lambdabot> Couldn't find class `is a liar!'. Try @instances-importing
16:50:21 <hpc> what's the instance for MonadPlus IO?
16:50:28 <hpc> mzero = System.Exit?
16:50:43 <mauke> @src IO mzero
16:50:43 <lambdabot> mzero       = ioError (userError "mzero")
16:50:49 <hpc> oh
16:51:49 <hpc> can someone give advice on a frustrating exception i am getting with HDBC?
16:51:56 <dankna> possibly
16:51:57 <hpc> "*** Exception: SqlError {seState = "[\"IM002\"]", seNativeError = -1, seErrorMsg = "connectODBC/sqlDriverConnect: [\"0: [unixODBC][Driver Manager]Data source name not found, and no default driver specified\"]"}"
16:52:18 <hpc> this is being thrown by connectODBC
16:52:25 <dankna> well, what are you passing to connectODBC?
16:52:40 <c_wraith> that looks to me like it's being copied directly from the ODBC driver failure message
16:52:45 <hpc> "Driver={SQL Server};Server=localhost;Uid=www;Pwd=redacted;Database=foo;Trusted_Connection=yes;"
16:53:07 <hpc> it still happens when i change Driver
16:53:20 <dankna> is it perhaps expecting another field there?
16:53:21 <hpc> i've tried every permutation the internet has provided me
16:53:27 <dankna> hmm
16:53:31 <c_wraith> Have you verified that connect string works with ODBC outside of hdbc?
16:53:35 * ddarius is going to always use "redacted" as a password.
16:53:42 <hpc> c_wraith: how?
16:54:03 <c_wraith> honestly, I don't know.  I avoid odbc
16:54:18 <c_wraith> But that error message very clearly is being copied directly from what it's returning.
16:54:39 <dankna> ah!
16:54:40 <hpc> google brings up tips on how to fix it, but it is all for windows
16:54:49 <hpc> dankna: ?
16:54:49 <dankna> what OS are you on?
16:54:59 <hpc> ubuntu 10.something
16:55:01 <dankna> drat
16:55:05 <dankna> so much for my proposed fix
16:55:09 <hpc> lol
16:55:26 <dankna> I was googling around and found some stuff that looked more relevant than it turned out to be :)
16:55:39 <dankna> but it looks like that error comes up when the ODBC wrapper driver can't find the target ODBC driver that you asked for
16:55:44 <dankna> so check that it's properly installed
16:55:59 <dankna> if possible, install an end-user app that uses ODBC (perhaps a database browser?) and try to connect through it
16:56:31 <hpc> i am using package libghc6-hdbc-odbc-dev
16:56:41 <hpc> er, derp
16:56:51 * hpc 's brain farted
16:56:59 <dankna> HDBC is a wrapper around ODBC
16:57:03 <dankna> ODBC is a C library
16:57:13 <dankna> which is itself a wrapper around numerous backends, for different database servers
16:57:30 <dankna> the error appears to mean that ODBC is installed properly but the backend your connection string asked for is not
16:58:11 <dankna> it's like having XLib installed but not XFree86
16:58:40 <dankna> in that you can compile and run code that runs against that library, but shouldn't expect to see actual results, because there's no backend
16:58:47 <hpc> ah
16:59:12 <sproingie> hdbc only wraps odbc?  i thought odbc was just one backend it could use
16:59:27 <dankna> well, it wraps various things now that you mention it, but from the connection string he's passing it's clear that he's using ODBC
16:59:36 <sproingie> i tend to stay away from odbc, since odbc drivers tend to not be well maintained
16:59:41 <dankna> this is true
16:59:51 <sproingie> and when they are they're usually crappy
17:00:11 <sproingie> which is sad since odbc implemented in full is actually really really nice
17:00:17 <dankna> yeah
17:00:26 <hpc> :(
17:00:35 * ddarius has mostly lived in a Microsoft Sql Server world.
17:00:58 <sproingie> i'm not sure even those are up to snuff these days
17:01:22 <sproingie> since they moved everything to adodb
17:01:30 <sproingie> s/db//
17:01:58 <hpc> so if i bypass odbc with say, the hdbc mysql backend
17:02:04 <hpc> it will work, perhaps
17:02:17 <sproingie> you'll be far better off, yes
17:03:44 <ddarius> sproingie: Oh, I don't wouldn't use Sql Server through ODBC unless I -really- had to.
17:05:32 <brisbin> i use sql server through odb at work, it's pretty annoying
17:05:41 <brisbin> resultSet.getString(1); resultsSet.getDate(2); ...
17:05:47 <brisbin> odbc*
17:06:39 <ddarius> brisbin: You're using Java?
17:06:46 <brisbin> X++, sorta
17:06:56 <sproingie> jdbc has a similar api to odbc
17:07:00 <sproingie> thus the name
17:07:30 <hpc> alright! things got simpler
17:07:30 <sproingie> i'm a big fan of perl DBI, tho a lot of it is very perl-specific
17:07:38 <brisbin> makes sense, X++ is MS's dumbed down C#/Java with SQL statements mixed in
17:07:42 <hpc> connectMySQL is strongly typed with something not a String
17:07:45 <brisbin> but if the db isn't a native db  you have to use odbc
17:08:18 <sproingie> X++ sounds pretty horrendous
17:08:32 <brisbin> sproingie: is it, except for teh builtin SQL
17:08:38 <brisbin> that parts really nice for ERP software
17:09:06 <brisbin> while select myTable { do_something_with(myTable); }
17:09:35 <sproingie> i guess, but i usually don't have much problem with $dbh->selectall_arrayref(<<"END_SQL");
17:09:58 <brisbin> i wouldn't want to use that construct in the stuff i do
17:09:59 <sproingie> that's about as "embedded sql" as it ever got with COBOL or SQL/J
17:10:30 <sproingie> well i usually don't use selectall and i usually don't use here-docs in a method call, but it's definitely "embedded sql"
17:12:52 <brisbin> while select inventTable join inventSum where inventSum.ItemId == inventTable.ItemId && inventSum.PhysicalInvent != 0 { /* now you have inventory numbers by item id */ }
17:12:56 <brisbin> as an example
17:13:55 <hpc> right, now for some possibly stupider questions:
17:14:09 <hpc> http://hackage.haskell.org/packages/archive/HDBC-mysql/0.6.3/doc/html/Database-HDBC-MySQL.html
17:14:22 <hpc> ^ the constructor requires the port and unix socket
17:14:25 <hpc> how do i get those?
17:15:19 <dankna> you have to install a mysql server on your machine
17:15:24 <dankna> once you have done this, you will know how to get those
17:15:46 <dankna> the fact that you aren't aware of this kinda begs me to ask why exactly you're writing database code :)
17:15:49 <dankna> no offense intended
17:16:02 <hpc> i have mysql installed through apt
17:16:09 <dankna> okay.  look at its config files.
17:16:32 <dankna> also you will have to set up a user and password for yourself through the command-line tools that come with it
17:17:16 <sproingie> you probably want mysql-devel packages if you want to build any mysql access libs out of cabal
17:17:21 <hpc> and in response to that previous comment, i know how to do database code, and am fairly decent at it; i just have never installed a server before
17:17:49 <dankna> fair enough
17:17:55 <dankna> I didn't mean to cast aspersions on your coding ability at all
17:18:06 <hpc> np; i have the same bias
17:18:09 <dankna> it was more like...  I was wondering if you were using a database only because you'd been told you ought to or something
17:18:18 <hpc> i just never realized how damn /arcane/ databases are
17:18:21 <dankna> yeah, they really are
17:18:25 <lucca> they are not!
17:18:27 <dankna> they're their own specialty altogether
17:18:31 <lucca> well, maybe a little.
17:18:31 <hpc> and this is for a website, so...
17:18:35 <dankna> gotcha
17:19:07 <brisbin> yesod makes website/db stuff pretty nice -- anyone using it?
17:20:40 <ray> how about a language where you program with unit vectors
17:20:49 <ray> orientation oriented programming
17:20:55 <dankna> haha
17:20:57 <dankna> nice trick
17:21:38 <brisbin> pfft, computers are just (1,1,1)s and (0,0,0)s
17:22:36 <ray> instead of refactoring you perform linear transformations
17:23:00 <FunctorSalad_> better be unitary :p
17:24:12 <kmc> sounds like quantum computing
17:26:49 * copumpkin is working on naturals
17:28:02 <ddarius> copumpkin: Run any Agda programs yet?
17:28:11 <copumpkin> surely not!
17:28:16 <copumpkin> these are naturals for haskell anyway
17:28:37 <ddarius> copumpkin: One day the answer to that question will be "yes," and I will tactfully not ask what the program does.
17:29:15 <ray> naturals are trivial, construct quaternions already
17:29:43 <brisbin> wow, i thought #archlinux was a geeky place...
17:30:20 <ddarius> ray: Why would anyone care about quaternions when the 3D geometric algebra does everything they do and more and better.
17:30:35 <ddarius> Perhaps some algebraist would care.
17:30:43 <mauke> preflex: quote ystael
17:30:43 <preflex>  <ystael> #1 reason to use haskell: in the IRC channel, people say "bifunctor" and mean it.
17:31:44 <ray> why do people use the naturals when the integers do everything they do and more
17:32:08 <ddarius> Because they don't do everything better.
17:32:18 <mauke> naturals are cache-agnostic
17:32:19 <FunctorSalad_> like failing at being a group under addition
17:32:34 <FunctorSalad_> :F
17:32:50 <ddarius> copumpkin: So did you decide working is for suckers and extend your vacation some more?
17:33:07 <ray> is :F the face a set makes when it can't form a group under the usual operations
17:33:14 <monochrom> @remember ray how about a language where you program with unit vectors: orientation oriented programming
17:33:14 <lambdabot> Done.
17:33:45 <FunctorSalad_> ray: I thought it was a tooth
17:33:49 <FunctorSalad_> compareable to o_O
17:34:53 <monochrom> I use naturals when in my reasoning of the program, I want n>0 iff n/=0
17:35:59 <FunctorSalad_> naturals are kinda better at being well-founded I guess
17:36:13 <hpc> trouble again: mysql documents the socket file as being in either /tmp or /var/lib/mysql
17:36:20 <hpc> it is in neither location
17:36:22 <monochrom> and I use integers (rather than rationals, if you follow the "it does more!" slippery rope) when in my reasoning of the program, I want n>=1 iff n>0
17:37:08 <monochrom> but it is not a big deal. I can cope if all you give me is quaternions.
17:37:14 <FunctorSalad_> they aren't webscale though.
17:37:48 <ray> quaternions do everything complexes do and more!
17:38:07 <ddarius> ray: But again, not better.  Complex numbers are rather special.
17:38:07 <osaunders> preflex: seen Cale
17:38:08 <preflex>  Cale was last seen on #haskell 20 hours, 5 minutes and 56 seconds ago, saying: tolkad: haha
17:38:37 <mauke> preflex: seen ganon
17:38:37 <preflex>  Sorry, I haven't seen ganon
17:38:41 <monochrom> newsgroups do everything web forums do and more.
17:38:48 <hpc> having manually configured mysqld to use /tmp/mysql.sock, i still cannot find it
17:38:51 <momentum> who is someone from Microsoft, kinda famous for writing about functional reactive programming with animation / graphic demos ?
17:39:00 <dankna> hpc: weird?  I don't know why that would be
17:39:04 <identity_> I've been trying to use anything that looks like it could function for my purposes from System.Process, but all of it crashes with some bad handle exception except runInteractiveCommand which is .. less than optimal. I'm trying to create a process that takes input via stdin, write to its stdin and then read the output. Any suggestions?
17:39:21 <ray> except being aesthetically pleasing websites
17:39:35 <mauke> identity_: what's the exact error?
17:39:55 <identity_> mauke: It varies between functions that I try to use, let me dig some of them up
17:40:12 <sproingie> momentum: conal elliott?
17:40:13 <identity_> resource vanished (Broken Pipe) is common
17:40:38 <identity_> I think that's the most common
17:40:38 <Cale> osaunders: Looking for me?
17:40:39 <mauke> identity_: that means the program you're sending text to has exited
17:40:45 <momentum> sproingie: nice; found his tutorial; thanks!
17:40:46 <identity_> mauke: Hmm.
17:40:57 <osaunders> Cale: Yeah, just wondering what was happening with the altstdlib project?
17:41:08 <Cale> Uh, I don't know
17:41:12 <sproingie> momentum: he's on this channel, kinda idle tho
17:41:16 <sproingie> preflex: seen conal
17:41:16 <preflex>  conal was last seen on #haskell 2 days, 5 hours, 59 minutes and 39 seconds ago, saying: edwardk: yep
17:41:22 <identity_> mauke: I'm trying stuff like: runInteractiveProcess "cat > foo" [] Nothing Nothing, then writing to the resulting i handle
17:41:26 <identity_> stdin* handle
17:41:40 <monochrom> not sure "cat > foo" is accepted at all
17:41:49 <identity_> Oh.. 
17:41:59 <FauxFaux> sh -c 'cat > foo' should work.
17:42:02 <identity_> I think I may understand why
17:42:03 <identity_> yes
17:42:08 <identity_> exactly
17:42:12 <identity_> > is a 'shell construct'
17:42:13 <lambdabot>   <no location info>:
17:42:13 <lambdabot>      lexical error in string/character literal at chara...
17:42:15 <hpc> >:( it is resolved
17:42:21 <hpc> it was in /var/run/mysqld/mysqld.sock
17:42:25 <identity_> Thanks. 
17:42:29 <dankna> hpc: ah!  good
17:42:35 <hpc> which i only discovered doing mysqld --verbose --help
17:42:38 <hpc> on a whim
17:42:41 <dankna> hrm
17:42:47 <ray> >lambdabot_silliness_level
17:42:59 <hpc> so yeah, thanks for the help
17:43:01 <ray> QUITE HIGH!
17:43:20 <hpc> @let lambdabot_silliness_level = text "QUITE HIGH!"
17:43:21 <lambdabot>  Defined.
17:43:27 <hpc> > lambdabot_silliness_level
17:43:28 <lambdabot>   QUITE HIGH!
17:43:31 <hpc> :D
17:43:33 <monochrom> \/
17:44:23 <monochrom> I spam you again with my new article http://www.vex.net/~trebla/haskell/scanl.xhtml
17:44:44 <conal> momentum: hi
17:44:55 <momentum> whoa, #haskell is officially too cool
17:45:05 <momentum> conal: I'm trying to use FRP for robot control
17:45:08 <conal> :)
17:45:10 <ray> and now i know how to get [] on my phone keypad
17:45:12 <conal> momentum: fun.
17:45:14 <momentum> conal: besides your 1997 paper, can you suggest what to read?
17:45:25 <conal> momentum: i think there are some papers on robot control.
17:45:28 <conal> in frp
17:45:31 <hpc> #haskell is so cool, light travels through it at the brisk speed of 5 km/h
17:45:31 <sproingie> the conal wakes
17:45:36 <conal> let's see ...
17:45:43 <momentum> conal: though I shoudl specify; i'm mor einterested in learning the theory
17:45:49 <momentum> conal: after that, the applications are easy
17:46:01 <momentum> conal: so I'd prefer to read the hard theory behind frp, and afterwards, I can apply it myself
17:46:12 <ray> the ellipse and hyperbola are conal sections right
17:46:17 <conal> momentum: awesome!
17:46:22 <momentum> the frp notion of events / reaction .. .seems much cooler than having lots of randmo threads / coroutines
17:46:27 <monochrom> @quote monochrom faster
17:46:27 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
17:46:34 <dankna> haha
17:47:02 <conal> momentum: besides the initial fran paper, check out http://conal.net/papers/push-pull-frp/
17:47:44 <momentum> conal: cool; how to implement it efficiecntly thanks
17:47:49 <conal> momentum: both papers give you the precise semantics.  the push-pull one is a more modern packaging, using type classes.
17:48:04 <momentum> conal: most important question; when I get stuck understanding frp; besides you, who are the best nicks to bother in #haskell? (you can pm me if you don't want to annoy ppl here)
17:48:18 <conal> momentum: and using the discipline of type class morphisms, which ensures tight (leak-free) abstraction.
17:48:29 <ray> @quote haskel
17:48:29 <lambdabot> identity says: That Oleg guy is all over the place when it comes to haskell; is he like a Haskell superhero?
17:48:37 <thom_logn> how much from SPJ's contracts paper is patented these days?
17:48:54 <conal> momentum: there are a few folks here who like to talk frp.  just ask around a few times and see who chimes in.
17:49:21 <conal> momentum: also, check out arrow-style frp, as in yampa, and see which style you prefer.
17:49:28 <mauke> preflex: quote . haskel
17:49:29 <preflex>  <mauke> haskell software should move from alpha to beta to eta, then lambda
17:49:51 <conal> momentum: "classic" style is structured around Applicative and a few other classes.
17:50:53 <conal> momentum: see also http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming
17:51:14 <conal> momentum: and particularly the part that starts "So, what is FRP? You could have invented it yourself. Start with these ideas:"
17:51:46 <dolio> monochrom: Good article, by the way.
17:52:24 <monochrom> thanks
17:52:53 <conal> momentum: i don't think we've really gotten frp right yet. i like people to understand the ideas & sensibilities that led to frp, so they can imagine alternatives in the same spirit.
17:53:33 <conal> momentum: mainly: continuous time and simple & precise denotation.
17:55:49 <ddarius> thom_logn: Nothing that wasn't patented when it was published.
17:55:56 <ddarius> Which presumably is nothing.
17:57:02 <identity_> Is it possible to have two different read instances for a single type? I would prefer that my data type be readable via MyType Foo Bar Baz as well as MyType {foo = Foo, bar = Bar, baz = Baz}
17:57:28 <dolio> Those aren't two different instances.
17:57:34 <dolio> Just write a single instance that parses both.
17:57:36 <ddarius> identity_: You don't need two instances to do that and you couldn't do that with two instances.
17:57:37 <dankna> identity: not exactly, no.  but you can define something that behaves similar to read but has different semantics.
17:57:39 <identity_> Oh
17:57:43 <identity_> Like that.
17:57:44 <dankna> you will have to implement the parsing yourself though.
17:57:52 <identity_> Yes, hmm.
17:58:03 <identity_> Thanks again.
17:58:07 <dankna> I've been wrong once today already, so if ddarius has an answer I defer to him :)
17:58:13 <identity_> Heh
17:58:26 <thom_logn> thankds dd
17:58:26 <identity_> If 1 is your quota then you're doing pretty good
17:58:32 <dankna> one can hope
17:59:22 <mauke> preflex: xseen zelda
17:59:23 <preflex>  zelda was last seen on efnet/#c 166 days, 10 hours, 30 minutes and 12 seconds ago, saying: someone is going to help me or not ?
17:59:44 <conal> momentum: you'll find a lot more frp papers by following links on http://haskell.org/frp/
17:59:46 <identity_> Guess Ganon must've gotten her.
18:00:12 * ddarius hopes the response to zelda was "True."
18:03:17 * ddarius just got a fortune that says: "Turn your scars into stars."
18:03:40 <dolio> Nice.
18:03:43 <dankna> presumably by some form of string manipulation
18:03:58 <dolio> I got one once that said, "Alas! The onion you are eating is someone else's water lily."
18:04:04 * dankna laughs
18:04:06 <dankna> that's a good one
18:04:07 <momentum> conal: was afk (emergency), handled; thanks for all the links; do you mind if I email you?
18:05:40 <conal> momentum: i don't mind
18:13:00 <Axman6> @remember Axman6 Haskell is easy, you just apply functions to arguments, and then you apply them to other arguments. Axman6's girlfriend: I don't like conflict
18:13:00 <lambdabot> It is stored.
18:13:47 <EvanR> when i was a kid the BASIC manual made no sense for that reason
18:14:55 <dankna> lol
18:14:57 <dankna> amusing
18:15:03 <jmcarthur> ooh frp again
18:15:06 <dankna> when I was a kid I asked my mother what "syntax" meant
18:15:08 <dankna> she told me "spelling"
18:15:14 <dankna> so I went and fixed my spelling error and the program worked
18:16:04 <EvanR> lol
18:16:51 <dankna> yeah
18:22:06 <momentum> conal: is there a pdf of your fran tutorial in dr dobb's journal available somewhere? (printing out the HTML is somewhat ugly)
18:22:50 <momentum> conal: is http://portal.acm.org/citation.cfm?id=351276 the full article?
18:26:54 <osaunders> Look at this monster: zipWith3 (zipWith3 (\c y x -> fmap (const (Coord y x)) c)) justs2 (repeat [0..]) (map (replicate $ length justs2) [0..])
18:27:46 <osaunders> Oh wait, there's a bit missing: concatMap catMaybes $ zipWith3 (zipWith3 (\c y x -> fmap (const (Coord y x)) c)) justs2 (repeat [0..]) (map (replicate $ length justs2) [0..])
18:28:02 <Veinor> osaunders: augh
18:28:17 <osaunders> Now to try and simplify :)
18:28:45 <Veinor> @pl zipWith3 (zipWith3 (\c y x -> fmap (const (Coord y x)) c)) justs2 (repeat [0..]) (map (replicate $ length justs2) [0..])
18:28:45 <lambdabot> zipWith3 (zipWith3 (flip (flip . ((fmap . const) .) . Coord))) justs2 (repeat [0..]) (map (replicate (length justs2)) [0..])
18:29:08 <djbpython> anyone help a noob? I am following http://learnyouahaskell.com/starting-out b !! 2 doesn't produce the list i'd expect it to
18:29:35 <Veinor> djbpython: what does it produce?
18:29:57 <djbpython> Veinor: [1,2,2,3,4]
18:30:06 <djbpython> its the output in the tutorial
18:30:43 <brisbin> what did you expect?
18:31:29 <djbpython> [5,3,3,3], which is what it is in the interpreter
18:31:46 <pelotom> djbpython: it's returning the element at index 2, which is the 3rd element of the list, which is the list [1,2,2,3,4]
18:31:53 <Veinor> wait, in the interpreter b !! 2 is [5,3,3,3]?
18:32:00 <djbpython> yup
18:32:09 <pelotom> let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in b !! 2
18:32:15 <pelotom> > let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]] in b !! 2
18:32:16 <lambdabot>   [1,2,2,3,4]
18:32:20 <djbpython> [[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
18:32:33 <Veinor> oh
18:32:34 <pelotom> you added [6,6,6] to the list :P
18:32:38 <Veinor> yeah :P
18:32:50 <djbpython> isnt that what [6,6,6]:b does?
18:33:01 <pelotom> yes
18:33:13 <djbpython> ohhh i see
18:33:16 <pelotom> but that creates a new list
18:33:21 <pelotom> b is still the old list
18:34:13 <djbpython> also don't do let b = [3,3,3] : b
18:35:01 <pelotom> djbpython: unless that's what you really wanted :)
18:35:03 <Veinor> that's perfectly valid
18:35:08 <Veinor> > let b = [3,3,3] : b in take 10 b
18:35:09 <lambdabot>   [[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3...
18:35:58 <companion_cube> > take 10 $ cycle [3,3,3]
18:35:59 <lambdabot>   [3,3,3,3,3,3,3,3,3,3]
18:36:11 <companion_cube> > take 10 $ cycle [[3,3,3]]
18:36:12 <lambdabot>   [[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3...
18:36:22 <Veinor> > take 10 $ replicate [3,3,3]
18:36:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:36:23 <lambdabot>         against inferred type ...
18:36:27 <Veinor> oh, whoops
18:36:38 <Veinor> > take 10 $ repeat [3,3,3]
18:36:39 <lambdabot>   [[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3...
18:37:02 <companion_cube> > take 10 $ map (const [3,3,3]) [1..]
18:37:03 <lambdabot>   [[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3,3,3],[3...
18:37:15 <pelotom> djbpython: it's only a bad idea if you then treat b as if it were a finite list
18:37:27 <pelotom> let b = [3,3,3]:b in last b
18:37:31 <pelotom> > let b = [3,3,3]:b in last b
18:37:37 <lambdabot>   mueval: ExitFailure 1
18:37:58 <Mitar> aaaa, how can one export data constructors of type family instance?
18:38:08 <Veinor> related: don't use length x > 0 to check whether a list has nonzero length
18:38:47 <dolio> module Foo (Fam(..))?
18:39:04 <pelotom> > let b = [3,3,3]:b in nil b
18:39:05 <lambdabot>   Not in scope: `nil'
18:39:14 <pelotom> > let b = [3,3,3]:b in null b
18:39:15 <lambdabot>   False
18:39:24 <pelotom> > let b = [3,3,3]:b in not $ null b
18:39:25 <lambdabot>   True
18:39:42 * Veinor now wants to make a list-like type such that you can tell whether the list is infinite or not
18:40:45 <pelotom> Veinor: that's an interesting idea, is it possible? it seems like it might be problematic
18:40:50 <Mitar> nop
18:41:10 <Funktorsalat> Veinor: data List p a where { Nil :: List Finite a ; Cons :: a -> List p a -> List p a }?
18:41:30 <jaredj> Veinor: not too hard - just make a function that determines whether (last l) ever terminates ;)
18:41:31 <Funktorsalat> Mitar: why not?
18:41:48 <conal> momentum: i'll look for the dr dobb's article. ...
18:42:07 <pelotom> at least, it seems like you couldn't have this data type hold all possible infinite lists
18:42:08 <Funktorsalat> hmm I guess this doesn't quite work
18:42:40 <Mitar> i do not know why not
18:42:44 <Mitar> i will prepare an example
18:42:58 <Funktorsalat> bogusList = BogusList 1 bogusList would type as List Finite a :|
18:43:17 <conal> momentum: not that i know of.  
18:43:48 <lars9> is readMVar atomic?
18:44:01 <Funktorsalat> data List p a where { Nil :: List Finite a ; Cons :: a -> !(List p a) -> List p a }?
18:44:20 <Funktorsalat> me that may not hold infinite lists ;)
18:44:25 <Funktorsalat> *meh
18:44:53 <lars9> conal: hi are you the Conal working on FRP?
18:45:14 <conal> lars9: yeah.  though not much lately.  i'll get back to it.
18:45:17 <dolio> If you index your lists by the coinductively defined extended natural numbers, infinite lists will have types with infinity.
18:45:43 <jmcarthur> lars9: readMVar is not atomic
18:45:45 <lars9> conal: awesome, nice to see you here.
18:45:51 <dolio> But, I don't know if you can get coinductive values in GHC's type system.
18:45:51 <lars9> jmcarthur: thanks:)
18:45:58 <conal> lars9: thx.
18:45:59 <jmcarthur> conal: what have you been up to lately?
18:46:33 <momentum> conal: don't waste your time; read through enough of your fran article
18:46:38 <momentum> conal: how do you implement untilB ?
18:46:39 <jmcarthur> i've seen blog posts on laziness and unamb/lub stuff lately, but i'm not sure if you are focusing on that
18:46:50 <momentum> conal: implementing the non-reactive parts seems kind of easy
18:46:51 <dolio> Your only chance is if Max Bolingbroke's trick works.
18:48:18 <conal> jmcarthur: i'm working on a few things.  including thinking about sound numeric programming.  possibilities for liberating us high-level programmers from low-level numerics.
18:48:32 <jmcarthur> ah, right, now i remember that post
18:48:41 <aristid> data List emptiness finiteness where { Nil :: List Empty Finite a ; Cons :: a -> List e f a -> List Nonempty f a }
18:50:19 <conal> jmcarthur: i'm also co-leading a a workshop on recognizing and overcoming cultural programming.  and working with clients.
18:50:52 <lars9> jmcarthur: how to do some atomic actions on a MVar?
18:51:00 <Mitar> example: http://hpaste.org/41185/type_families_export
18:51:10 <conal> jmcarthur: relationship-focused, though broader. hard to characterize succinctly. which is another thing i'm working on -- how to talk about it clearly.
18:51:11 <Mitar> Baz is not visible in Test module
18:51:14 <jmcarthur> lars9: takeMVar and putMVar are atomic
18:51:36 <aristid> conal: what is "cultural programming"?
18:51:50 <lars9> jmcarthur: oh i need to take a mvar, do something and put back, how to make it atomic?
18:51:56 <jmcarthur> lars9: if you need a lock then you can implement that with another mvar: take the lock, do stuff, put the lock back
18:52:02 <pelotom> lars9: use STM
18:52:11 <litb> hm, function application is left associative?
18:52:12 <jmcarthur> lars9: and yeah, STM is nicer for that sort of thing :)
18:52:29 <lars9> jmcarthur: pelotom thanks i'll try
18:52:30 <conal> aristid: also called "cultural conditioning". the habitual thinking we pick up from our parents, authorities, peers, etc.
18:52:31 <jmcarthur> litb: yes.    f a b c == ((f a) b) c
18:52:31 <pelotom> lars9: or swapMVar
18:52:38 <litb> ah
18:52:49 <aristid> conal: i don't think you can completely overcome that.
18:52:56 <pelotom> but in general if you want to operate on multiple vars atomically you'll need STM
18:53:24 <conal> aristid: that'd be a tall order, indeed!
18:53:34 <jmcarthur> conal: is this distinct from (or more or less general than) the quest to be more open-minded?
18:54:05 <pelotom> conal: I think you're actually talking about "culture"
18:54:08 <lars9> pelotom: i see, i'll read more about STM:)
18:54:33 <litb> hmm, but type inference is done right-to-left
18:54:39 <pelotom> lars9: STM is one of the coolest things ever :)
18:54:51 <osaunders> You know what I'd like to do. I'd like to try and write an entire Haskell program without using any point and without using @pl.
18:54:59 <osaunders> *points
18:55:10 <jmcarthur> litb: you mean the associativity of (->)?
18:55:26 <aristid> osaunders: you crazy person
18:55:31 <conal> jmcarthur: open-mindedness is very helpful.  curiosity perhaps more so.  and yes, it's more specific.  it's some directions i've been exploring, growing out of marshall rosenberg's principles & practices, plus some other inspirations.
18:55:41 <jmcarthur> osaunders: i actually don't think it's that difficult to write entirely point free code (reading it later can suck though)
18:55:41 <osaunders> I think you could make it feasible by building lots of specialized combinators out of the general ones.
18:56:28 <jmcarthur> osaunders: the main difficulty is using data types that don't have predefined destructors and unwrappers and stuff
18:56:31 <lars9> pelotom: hi i've read to intro to STM, sounds like for some heated resources, the rollback can happen frequently?
18:57:04 <pelotom> lars9: that's one complication, yes
18:57:14 <jmcarthur> lars9: it can, but in most practical cases it doesn't
18:57:20 <pelotom> lars9: it's optimized rather more for correctness than performance
18:57:36 <osaunders> jmcarthur: Yeah, I might have to make some exceptions.
18:57:45 <litb> jmcarthur: like, if one says   foo :: (a -> b) -> d     and then says    foo x   if x has type  c -> c -> c, then  b is first matched to the right most c, then a is matched to the left rest, i.e "c -> c"
18:57:47 <osaunders> Maybe a better goal is to only use points to declare combinators.
18:57:47 <lars9> pelotom: i see, very interesting concept
18:57:49 <conal> jmcarthur: mainly shifting from being about communication to an inner practice.  and some new techniques to help people tune in to themselves more effectively.
18:57:49 <jmcarthur> i've toyed with a lock-based version of stm, but never finished it
18:58:00 <litb> jmcarthur: what is that procedure called?
18:58:37 <jmcarthur> litb: that doesn't sound right to me
18:58:41 <litb> oh
18:58:51 <litb> i must have misunderstood it then -.-
18:59:14 <jmcarthur> litb: i believe it would be:  a=c and b=c->c
18:59:20 <pelotom> osaunders: this sounds like the Backus Programme
18:59:24 <litb> oh
19:00:43 <osaunders> pelotom: What's that?
19:00:56 <osaunders> @google Backus Programme
19:00:57 <lambdabot> http://www.thocp.net/biographies/backus_john.htm
19:00:57 <lambdabot> Title: John Backus
19:01:10 <pelotom> jmcarthur: how would a lock-based version work? record the order of locks an STM block intends to make and decide whether it's safe to enter the first given the order of locks already held?
19:01:32 <jmcarthur> pelotom: it would still require the occasional rollback
19:01:35 <pelotom> osaunders: http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf
19:01:43 <jmcarthur> pelotom: the locks would basically be used to make it more pessimistic
19:02:11 <jmcarthur> pelotom: my idea was to try a variant of timestamp ordering
19:02:21 <lars9> isn't haskell good at data parallel computing? but now most data center systems use c++/java, and there are very few research papers/projects on that recently
19:02:34 <jmcarthur> not sure how to get orElse using that yet. haven't thought it very far through yet
19:02:42 <pelotom> jmcarthur: ah, so a kind of middle way between totally optimistic and totally pessimistic
19:02:43 <litb> jmcarthur: someone on cpp-next said that  for the (.) operator, if one does   (+1) . (+),  it won't yield the expected type because (.) has type (b -> c) -> (a -> b) -> a -> c and that a would get type "a -> a"
19:02:55 <jmcarthur> :t (+1) . (+)
19:02:56 <lambdabot> forall a. (Num a) => a -> a -> a
19:02:58 <litb> jmcarthur: but now I checked, and ghci tells me you are indeed right
19:03:31 <jmcarthur> yeah it sounds like somebody was wrong. it happens ;)
19:03:33 <litb> jmcarthur: hmm wait, my ghci displays a different type
19:03:46 <Saizan> (+1) . (+) :: (Num (a -> a), Num a) => a -> a -> a
19:04:04 <Saizan> lambdabot has a Num b => Num (a -> b) instance
19:04:25 <jmcarthur> you mean lambdabot has an awesome instance
19:04:56 <Saizan> "awesome" contains less information
19:05:01 <osaunders> > (+1) . (+) 1 2 3
19:05:02 <lambdabot>   No instance for (GHC.Num.Num (f a))
19:05:02 <lambdabot>    arising from a use of `e_11123' at <...
19:05:04 <jmcarthur> > ((+1) . (+)) 5 7
19:05:05 <lambdabot>   13
19:05:08 <osaunders> > (+1) . (+) 1 2
19:05:09 <lambdabot>   No instance for (GHC.Num.Num (f a))
19:05:09 <lambdabot>    arising from a use of `e_1112' at <i...
19:05:14 <Mitar> any help with this: http://hpaste.org/41185/type_families_export
19:05:15 <litb> i checked your statement by doing   :t (. (+))  and seeing that its type is  ((a -> a) -> c) -> a -> c   i.e that  b is  (a->a)
19:05:20 * osaunders fails
19:05:41 <osaunders> I don't really know Haskell. I just fumble around until things work.
19:05:51 <jmcarthur> osaunders: that approach works sometimes
19:06:31 <heatsink> Mitar: You need to export Baz
19:06:40 <brisbin> haskell by trial/error
19:06:42 <brisbin> that's how i roll
19:06:54 <osaunders> Is having a Num (a -> b) instance really a good idea?
19:07:11 <jmcarthur> it is if you ignore the pointless Show and Eq constraints
19:07:14 <jmcarthur> IMO
19:07:16 <pelotom> that's how most programmers roll... the difference is that you can be more assured of the quality of the result once it compiles in haskell :)
19:07:21 <litb> i have forgotten what an instance is. i really need to refresh my haskell
19:08:29 <osaunders> litb: Bool is an instance of the type class Eq which means you can say True == False.
19:08:36 <aristid> osaunders: it has some tiny problems but otherwise it is nice :D
19:08:43 <aristid> > const == 1
19:08:44 <lambdabot>   *Exception: (==): No overloading for function
19:09:00 <aristid> note that this is a runtime error
19:09:33 <pelotom> aristid: why is that a good thing?
19:09:42 <aristid> pelotom: it's a bad thing
19:10:01 <litb> osaunders: ohh
19:10:06 <pelotom> hm, I'm not following
19:10:23 <pelotom> oh, you're saying that's one of the minor problems?
19:10:29 <osaunders> pelotom: A negative side-effect of the Num (a -> b) instance, I think.
19:10:38 <aristid> pelotom: more or less minor
19:10:55 <pelotom> what's a benefit of Num (a -> b)?
19:10:58 <pelotom> I'm not familiar with this
19:11:18 <aristid> > (cos ^ 2 + sin ^ 2) pi
19:11:19 <lambdabot>   1.0
19:11:44 <pelotom> ohh
19:11:49 <pelotom> neat trick
19:12:11 <litb> what is a  Num b => Num (a -> b)   good for? isn't  a -> b a function? why should it model a number?
19:12:32 <pelotom> litb: see the above example
19:12:32 <Mitar> heatsink: Mitar: You need to export Baz << how?
19:12:39 <Saizan> litb: see aristid's example just above
19:12:54 <litb> oh
19:13:37 <brisbin> :t (cos ^ 2 + sin ^ 2)
19:13:38 <lambdabot> forall a. (Floating a) => a -> a
19:13:54 <osaunders> :t cos ^ 2
19:13:55 <lambdabot> forall a. (Floating a) => a -> a
19:14:03 <osaunders> :t cos ^
19:14:04 <lambdabot> parse error (possibly incorrect indentation)
19:14:10 <osaunders> :t cos (^)
19:14:10 <lambdabot> forall a b. (Floating a, Integral b) => a -> b -> a
19:14:15 <aristid> :t (^) cos
19:14:16 <lambdabot> forall a b. (Floating a, Integral b) => b -> a -> a
19:14:24 <brisbin> nifty
19:15:00 <osaunders> @instances Num
19:15:00 <lambdabot> Double, Float, Int, Integer
19:15:26 <aristid> not complete for lambdabot
19:16:35 <JohnnyL> why does ghci take up 2 percent of the cpu at idle?
19:16:36 <heatsink> Mitar: add FooI(Baz) to the export list
19:17:23 <brisbin> JohnnyL: cannot reproduce
19:17:27 <Mitar> thanks
19:17:31 <Mitar> i was trying HuuI(Baz)
19:17:34 <litb> so    (cos ^ 2)  can only take Integral types as parameter?
19:17:36 <litb> why's that
19:17:44 <Mitar> cos ** 2.0
19:17:55 <aristid> :t cos ^ 2
19:17:55 <lambdabot> forall a. (Floating a) => a -> a
19:18:01 <litb> oh
19:18:07 <aristid> litb: it is not limited to Integral at all :)
19:18:28 <litb> then I don't understand (Floating a, Integral b) => a -> b -> a which is the type of   cos (^)
19:18:48 <heatsink> Mitar: Syntactically, data families act like "data" and type families act like "type"
19:18:57 <aristid> litb: cos (^) is something completely different.
19:18:58 <litb> does it not say that the next argument (^) takes will yield a  b -> a, with b being Integral  ?
19:19:08 <astroboy> If something is a Monad and a Functor, what's the difference between (>>) and (*>)?
19:19:18 <aristid> :t (*>)
19:19:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f b
19:19:19 <litb> aristid: hmm
19:19:31 <aristid> astroboy: it also has to be Applicative :)
19:19:39 <astroboy> oh right
19:19:40 <aristid> :t ($>)
19:19:41 <lambdabot> Not in scope: `$>'
19:19:42 <pelotom> litb: the integral constraint is for the power you're raising to
19:19:45 <astroboy> so Monad and Applicative
19:19:51 <aristid> :t (<$)
19:19:52 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
19:19:52 <astroboy> you meant <$>?
19:19:53 <pelotom> if you want a non-integral power you need to use (**)
19:19:59 <aristid> no
19:20:00 <heatsink> :t fmap liftM <$>
19:20:01 <lambdabot> parse error (possibly incorrect indentation)
19:20:03 <aristid> i meant (<$)
19:20:07 <pelotom> :t cos ** 2.1
19:20:07 <astroboy> ok
19:20:07 <heatsink> :t fmap <$> liftM
19:20:08 <lambdabot> forall a. (Floating a) => a -> a
19:20:08 <lambdabot> forall (f :: * -> *) a1 r (m :: * -> *). (Functor f, Monad m) => (a1 -> r) -> f (m a1) -> f (m r)
19:20:20 <JohnnyL> brisbin: load windows
19:20:32 <pelotom> :t (**) cos
19:20:33 <lambdabot> forall a. (Floating a) => (a -> a) -> a -> a
19:20:33 <brisbin> JohnnyL: well, that's different
19:20:34 <astroboy> aristid: yes but if something is a Monad and is Alternative, what's the difference :P?
19:20:52 <aristid> astroboy: none if it is well-behaved
19:20:53 <pelotom> :t (^) cos
19:20:54 <lambdabot> forall a b. (Floating a, Integral b) => b -> a -> a
19:21:10 <astroboy> aristid: ok, thanks.
19:21:49 <heatsink> Mitar: What do you use type families for?
19:22:01 <litb> pelotom: ohh now i understand. 
19:22:04 <astroboy> aristid: thanks, that's what I tought
19:22:19 <litb> i thought  cos (^) would be a partial application of op ^ . but it of course is not
19:22:47 <aristid> :t [1, (^)]
19:22:48 <lambdabot> forall a b. (Num a, Integral b) => [a -> b -> a]
19:22:52 <litb> (cos ^) would, i think. 
19:23:07 <JohnnyL> brisbin: there is no excuse.
19:23:15 <pelotom> :t (cos ^)
19:23:16 <lambdabot> forall a b. (Floating a, Integral b) => b -> a -> a
19:23:21 <pelotom> :t (cos **)
19:23:22 <lambdabot> forall a. (Floating a) => (a -> a) -> a -> a
19:23:46 <aristid> :t (**)
19:23:47 <lambdabot> forall a. (Floating a) => a -> a -> a
19:23:51 <brisbin> JohnnyL: just saying, change your question to specify windows -- i cannot reproduce on my os
19:24:01 <Axman6> > cos ** id 10
19:24:02 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:24:02 <lambdabot>    arising from a use of `...
19:24:14 <Axman6> > cos ** id $ 10
19:24:15 <lambdabot>   NaN
19:24:22 <heatsink> Mitar: Part of the reason the documentation on type families is poor is that we don't have enough simple intuitive examples.  That's why I ask.
19:24:27 <Axman6> > cos ** 2 4
19:24:28 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
19:24:28 <litb> so  [1, (^)]  works because  (^) is a Num ?
19:24:28 <lambdabot>    arising from a use of `...
19:24:30 <Axman6> > cos ** 2 $ 4
19:24:31 <lambdabot>   NaN
19:24:34 <Mitar> a ok
19:24:34 <pelotom> > cos ^ const
19:24:35 <lambdabot>   No instance for (GHC.Real.Integral (a -> b -> a))
19:24:35 <lambdabot>    arising from a use of ...
19:24:39 <aristid> lol Axman6
19:24:44 <Mitar> my example is definitelly not simple and intuitive ;-)
19:24:58 <Axman6> litb: only in lambdabot 
19:24:59 <heatsink> heh
19:25:00 <Mitar> but will make it into a library someday
19:25:02 <Mitar> and publish it
19:25:42 <Mitar> i can send you current version if you wish
19:25:55 <Mitar> (of a file where i use family types)
19:26:07 <Mitar> or probably I misuse them ;-)
19:26:09 <litb> > [1, (^)] 3.0 4
19:26:10 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
19:26:10 <lambdabot>         against inferred type ...
19:26:12 <heatsink> Alright, sure.
19:26:13 <litb> hmm
19:26:17 <Mitar> mail?
19:26:29 <osaunders> @src lines
19:26:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
19:26:32 <litb> oh yes it's just a list
19:29:54 <JohnnyL> brisbin: linux user!
19:30:17 <brisbin> JohnnyL: windows user!
19:30:41 <jaredj> i'm writing a quickcheck property having to do with a 2d array (indexed by (Int,Int) tuples). How do I tell QuickCheck that I don't want a tuple of two arbitrary Ints, but a tuple of two arbitrary Ints inside the bounds of the array?
19:31:22 <JohnnyL> brisbin: i was using Linux 64 bit edition.. Then time became more valuable to me. :)
19:31:30 <heatsink> I think there's an implication operator in quickcheck
19:32:44 <brisbin> JohnnyL: i'm using 64b now, requires less time than my work pc and ghci doesn't take 2% cpu :D
19:33:02 <jaredj> heatsink: thanks. *rummage*
19:33:17 <heatsink> jaredj: use (==>) to limit the test to only in-bounds indices
19:35:49 <tux20> new online community www.blitzpost.com (chat, email, blog, dating..)
19:36:10 <Mitar> spam!
19:36:47 <tux20> sorry
19:37:19 <jaredj> ...?
19:37:33 <jaredj> who apologizes for spam? who spams in person?
19:38:01 <brisbin> hey, if anyone wants bigger peni just /q me :)
19:38:03 <brisbin> sorry
19:38:24 <ddarius> Who decides something is so exciting that it must be communicated to some large, random group of individuals.
19:38:29 <pelotom> it's a civilized irc channel where the spammers apologize
19:38:53 <JohnnyL> brisbin: well since Windows isn't free, I'm assuming the 2 % usage in windows is a conspiracy.
19:39:00 <Veinor> INCREASE your Monad size today!
19:39:22 <JohnnyL> Veinor: LONGER LASTING list comprehension!
19:39:30 <JohnnyL> ;)
19:39:33 <brisbin> JohnnyL: just call it tax
19:39:46 <brisbin> DUDE i'm talking [1..] lenghth!
19:39:50 <litb> lol
19:40:37 <jaredj> "Arguments exhausted after 21 tests."
19:41:04 <heatsink> Sounds like you need something to enhance your performance, jaredj
19:41:19 <pelotom> I was an Applicative before... since using this product I've become a MonadPlus
19:41:28 <jaredj> ppftftchchftpch!
19:41:30 <brisbin> ha
19:42:01 <litb> i'm teh Arrow
19:43:02 <JohnnyL> l8r
19:50:01 <blackdog> anyone know where the mac ghc packages put the binary?
19:50:11 <blackdog> trying to get about 7 versions of ghc to coexist
19:50:31 <blackdog> TacticalGrace: you built them, right? :)
19:50:31 <heatsink> blackdog: They put it in a framework
19:50:44 <blackdog> oh. how do i get to them from the command line?
19:50:53 <heatsink> Frameworks should have support for multiple versions at one of the directory levels
19:51:18 <heatsink> I think it's in /Library/Frameworks/
19:51:51 <heatsink> A few directories down, you reach a copy of the standard unix directory structure
19:53:01 <blackdog> ah, rgihto. i'll have a look, thanks.
19:53:27 <heatsink>  /Library/Frameworks/GHC.framework/Versions/Current/usr/local/bin/Program\ Files/My\ Documents/ghc
19:54:00 <brisbin> Program\ Files/My\ Documents *shudders*
19:54:25 * Saizan hopes that's a joke
19:54:43 <monochrom> probably a joke that mixes macos and windows
19:58:04 <ddarius> It is clearly a joke.  Why would ghc be in My Documents?
19:58:38 <Axman6> why would your home dir be in my documents? windows makes no sense
19:58:59 <ddarius> (and why would My Documents be in Program Files?)
19:59:03 <momentum> conal: I find the time varying part of FRP beautiful. I find the control flow of it hard to wrap my head around. How should I think of control flow in FRP ?
19:59:19 <Axman6> ddarius: you open your documents with your programs, duh
19:59:19 <momentum> conal: For the time varying part; it's very elegant: don't think of varaibles; think of variables that take time as a varaible.
20:00:07 <Veinor> yo dawg
20:08:27 <magicman> @type fmap (>>=) return
20:08:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> (a -> m b) -> m b
20:09:51 <adnap> Has anyone here used cairo?
20:13:27 <Mitar> i am using it in firefox right now ;-)
20:13:45 <adnap> Ha-ha...
20:14:33 <adnap> How would I create a series of transformations that, given a point p, gives me w - p, where w is some value?
20:14:59 <Mitar> map ((-) w) ps?
20:15:18 <adnap> If it's a matrix, can I do a scale and then a translate?
20:15:55 <adnap> Like, say p = [x,y]^T
20:16:02 <conal> oops.  i missed momentum.  
20:17:05 <adnap> Then, I want TS, where T translates by w in y and S scales by -1 in y.
20:17:11 <adnap> Right?
20:18:24 <litb_> hmm
20:21:04 <roconnor> adnap: translation isn't technically a linear transformation
20:21:33 <roconnor> adnap: people use homogenous coordinates to fake it though.
20:21:34 <adnap> roconnor: It is in a higher dimension.
20:21:57 <ddarius> under interpretation
20:22:03 <adnap> Well, it's affine space.
20:22:12 <adnap> Affine space supports translations.
20:22:28 <roconnor> yes, translation is an affine transformation.
20:23:13 <adnap> Anyhow, I can't figure this out.  Cairo has the top-left as (0, 0), but I want to draw points as if the bottom-left is (0, 0).
20:27:17 <Funktorsalat> apply a flip at the end? o_o
20:27:25 <Funktorsalat> (I have no clue about cairo though)
20:27:32 <Martty> sounds like a tony hawk advice
20:27:55 <Funktorsalat> (yes, it'd be an affine transformation too)
20:27:56 <ddarius> Few know that Tonk Hawk is an avid programmer.
20:28:02 <adnap> Ah, got it.
20:28:14 <Funktorsalat> (a flip not through the origin)
20:39:31 <lars9> getChanContents :: Chan a -> IO [a], when evaluating the returned list, if the concent is not ready, the thread is blocked?
20:39:36 <adnap> @pf (\u -> f(g(u)))
20:39:36 <lambdabot> Maybe you meant: bf pl
20:39:45 <adnap> How do I do that thingy?
20:40:02 <lars9> (f.g)
20:40:20 <adnap> No, I know how to do function composition.  I mean, how do I get the auto thingy to work.
20:40:30 <adnap> isn't it like @pf or something?
20:40:48 <adnap> @pf f(g(x))
20:40:48 <lambdabot> Maybe you meant: bf pl
20:41:30 <lars9> pl
20:41:41 <lars9> @pl f(g(x))
20:41:41 <lambdabot> f (g x)
20:41:50 <lars9> @pl (\x->f(g(x)))
20:41:50 <lambdabot> f . g
20:41:52 <adnap> @pl (\u -> f(g(u)))
20:41:52 <lambdabot> f . g
20:41:55 <adnap> Ah, cool.
20:42:11 <lars9> you can hlint locally
20:42:14 <adnap> Now I need...
20:42:45 <adnap> @pl (\u -> f (g u u))
20:42:46 <lambdabot> f . join g
20:42:54 <adnap> @pl (\u x -> f (g u x))
20:42:54 <lambdabot> (f .) . g
20:43:33 <lars9> er...
20:44:22 <lars9> im confoused by point-free style sometimes
20:44:24 <litb> bah this looks fun
20:44:30 <adnap> Me too! XD
20:45:13 <osaunders> @pl q f g x y = f (g x y)
20:45:13 <lambdabot> q = (.) . (.)
20:45:18 <litb> i think it' slike units in physics. once you get the units right, everything else gets easier. i need to getthe types right here
20:45:19 <lars9> @pl (\x y z z1 z2 -> f(g x y z z1 z2))
20:45:20 <lambdabot> ((((f .) .) .) .) . g
20:45:33 <heatsink> @pl a b c d e f g = c a b b a g e
20:45:33 <lambdabot> a = fix ((((const . (const .) . flip) .) .) . (flip =<< (flip .) . join . (flip .) . flip . flip id))
20:46:07 <lars9> ok, im stuck
20:46:12 <adnap> ew
20:46:26 <osaunders> Pointfree is hard for everyone. Don't worry about it.
20:46:37 <osaunders> At least it is for me.
20:48:15 <lars9> you are the everyone!
20:48:42 <lars9> im not qualified to be everyone, non-pointfree is still hard for me
20:48:50 <lars9> :D
20:49:23 <syntaxglitch> protip: If your expression involves composing a function with (.) or an operator section of it, then you really need to stop, put the pointfree down, and back away slowly
20:50:21 <lars9> syntaxglitch: i agree with that, (f .) . g is really confusing
20:51:51 <syntaxglitch> that's actually a useful combinator, though, just not written that way
20:52:12 <syntaxglitch> :t (.).(.)
20:52:13 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
20:52:21 <jmcarthur> lars9: if we define result = (.), where we interpret "result f g" as "apply f to the result after applying g", we can also say that "(result.result) f g" means "apply f to the result of the result of g", and "(result.result.result) f g" means "apply f to the result of the result of the result of g" and so. that last one is the same as "((.).(.).(.)) f g", which is the same as "((f .) .) . g". i think 
20:52:23 <jmcarthur> you see where this is going now
20:52:39 <litb> so  (.)  is  (a -> b) -> (c -> a) -> b      and it says   (f .) . g   so   f gets slurped by (a -> b), yielding  (c -> a) -> b  for the lhs, which in turn is mapped...  (c -> a) -> b  against (a -> b) -> (c -> a) yields to  (a -> b) := "(c -> a)" and (c -> a) := "b"
20:52:44 <litb> is that correct?
20:53:03 <jmcarthur> (f .) . g  ==  (result.result) f g
20:54:07 <lars9> jmcarthur: in fact i prefer *result* more than (.)
20:54:12 <lars9> in this situation
20:54:17 <litb> syntaxglitch: looks like a laying down girl xD
20:54:30 <lars9> jmcarthur: result.result looks better than (.).(.)
20:54:50 <syntaxglitch> though I have to say, sometimes obnoxious pointfree stuff makes more sense in terms of the applicative instance for ((->) t)
20:56:48 <syntaxglitch> having an extensible version of the S combinator can be pretty nice
20:57:07 <syntaxglitch> sort of like little inline chunks with a reader monad
20:57:13 <jmcarthur> lars9: there's that and more in http://hackage.haskell.org/package/DeepArrow
20:57:13 <syntaxglitch> well, not really "sort of"
20:58:10 <syntaxglitch> ugh I need to stop spending so much time on Stack Overflow
20:59:31 <lars9> jmcarthur: great, let me check it out
21:02:29 <litb_> syntaxglitch: heh what's your nick there?
21:02:59 <syntaxglitch> litb_, camccann
21:03:24 <syntaxglitch> I post answers occasionally
21:04:32 <litb_> nice
21:05:04 <adnap> Why doesn't this make sense? mapM_ ((putStrLn "woo") >> putStrLn) ["a", "b", "c"]
21:05:19 <adnap> How do I get woo's between my letters?
21:05:36 <adnap> And not in the trivial way, because this is just an example.
21:05:50 <Saizan> mapM_ (\x -> putStrLn "woo" >> putStrLn x) ["a", "b", "c"]
21:06:05 <adnap> Ah
21:06:08 <adnap> Dammit
21:06:23 <Saizan> = mapM_ ((putStrLn "woo" >>) . putStrLn) ["a", "b", "c"] -- if you prefer
21:06:29 <Mitar> i use type families, how can i force that some data instance of this family is also an instance of some other class?
21:06:31 <adnap> Yesss
21:07:02 <Mitar> like class Foo n where data FooBar n and FooBar n has to be instance of Bar class
21:07:03 <Mitar> ?
21:07:03 <lars9> @pl (flip compare)
21:07:04 <lambdabot> flip compare
21:07:27 <syntaxglitch> or mapM_ putStrLn $ intersperse "woo" ["a", "b", "c"]
21:07:30 <syntaxglitch> which kind makes more sense
21:07:42 <Saizan> Mitar: class Bar (FooBar n) => Foo n where data FooBar n
21:08:19 <Mitar> hmm, recursive ;-)
21:08:20 <Mitar> nice one
21:08:27 <jaredj> so a foo walks into a bar
21:08:45 <Mitar> and orders baz?
21:09:54 <Mitar> hmm, Non type-variable argument
21:10:07 <Mitar> one extension more ;-0
21:10:27 <jaredj> here's a q. is it bad practice to make fancy shows?
21:10:57 <jaredj> like i have a type for quilt squares, and the show is a five-line by ten-column square of characters
21:11:47 <jmcarthur> jaredj: the most important thing is that if there is also a Read instance it should be able to read whatever show gives you, but it's also good practice to make show give you a string that is valid haskell code so that you can, say, paste it into ghci to get the data structure
21:11:56 <jmcarthur> jaredj: but that doesn't mean you can't be fancy at all
21:12:00 <adnap> Saizan: Wait, I realized that's not I want.
21:12:08 <jmcarthur> jaredj: see for example the instance for Data.Set
21:12:08 <adnap> I need to fo the woo's after each letter.
21:12:35 <jmcarthur> jaredj: rather than revealing implementation details it shows "fromList [a, b, c, d]"
21:12:38 <syntaxglitch> so I think I'm going to take a break from Haskell, guys
21:12:41 <syntaxglitch> it's getting a bit dull
21:12:44 <syntaxglitch> time for me to learn Agda
21:12:47 <stepcut> jaredj: there really needs to be a separate class for fancy shows, IMO. I only make them fancy when it is not possible to create Read instance
21:12:54 <adnap> > mapM (\x -> putStrLn x >> putStrLn "woo") ["a", "b"]
21:12:55 <lambdabot>   <IO [()]>
21:12:57 <jaredj> syntaxglitch: prove it
21:12:59 <stepcut> syntaxglitch: fun!
21:13:04 <syntaxglitch> jaredj, har har har
21:13:13 <jaredj> :)
21:13:14 <stepcut> syntaxglitch: I wish I had time to learn more agda
21:13:23 <jmcarthur> learning agda isn't really taking a break from haskell
21:13:29 <stepcut> syntaxglitch: it can even do IO now!
21:13:47 <stepcut> jmcarthur: no.. but it is a break from trying to make money with Haskell
21:13:53 <Saizan> ?pl mapM (\x -> putStrLn x >> putStrLn "woo") ["a", "b"]
21:13:53 <lambdabot> mapM ((>> putStrLn "woo") . putStrLn) ["a", "b"]
21:13:58 <stepcut> jmcarthur: and can't afford that right now :p
21:14:05 <jmcarthur> stepcut: are you or syntaxglitch making money from haskell?
21:14:13 <syntaxglitch> well, I'm not
21:14:20 <stepcut> jmcarthur: I work for a company that is trying to
21:14:27 <jmcarthur> stepcut: are they hiring?
21:14:32 <jaredj> oho! verranice
21:14:33 <syntaxglitch> though I've bashed out a couple one-off utilities in Haskell at the day job
21:14:37 <stepcut> jmcarthur: not till we make money :)
21:14:41 <jmcarthur> aw
21:14:48 <SubStack> my startup is using haskell for a couple things, mostly node.js though
21:14:52 <stepcut> jmcarthur: did you see the jobs on haskellers?
21:15:00 <jmcarthur> i saw a couple. need to look again
21:15:19 <stepcut> jmcarthur: if you submit lots of high quality patches to happstack, you'll be on the short list for when we do hire ;)
21:15:25 <syntaxglitch> stepcut, anyway, "do IO" in what sense? I have no idea what all I can do with agda, pretty much just grabbed stuff from hackage, found a tutorial, and started typing
21:15:44 <stepcut> syntaxglitch: like, call putStrLn..
21:15:54 <jmcarthur> stepcut: i've only submitted one. it was the one that switched everything over to the MonadPlus instance
21:16:09 <stepcut> jmcarthur: oo. that is a good one!
21:16:17 <syntaxglitch> stepcut, you mean via the "FFI" that lets it use Haskell functions as postulates?
21:16:18 <stepcut> jmcarthur: now we need one that updates to monads-fd :p
21:16:21 <syntaxglitch> or more directly than that
21:16:22 <jmcarthur> heh
21:16:32 <jmcarthur> stepcut: i've been using snap lately and am planning to check out yesod soon
21:16:36 <stepcut> syntaxglitch: yes.. but there is a little extra glue code needed
21:16:45 <stepcut> jmcarthur: and then you'll come back home to happstack ?
21:16:54 <jmcarthur> heh. i'm liking snap so far
21:17:05 <syntaxglitch> stepcut, yeah
21:17:07 <jmcarthur> and i can still use the bits of happstack that i like in snap of course
21:17:09 <stepcut> jmcarthur: what do you like about it ? it seemed a lot the same ?
21:17:39 <syntaxglitch> I'm more interested in programs than proofs so I've already been messing with calling Haskell functions from agda
21:17:42 <jmcarthur> stepcut: snap-server is a bit simpler, IMO (and faster, supposedly). i also really like heist so far
21:17:58 <jmcarthur> stepcut: i don't see happstack and snap as very competitive against each other since they can share almost everything
21:18:06 <stepcut> jmcarthur: what about it do you find simpler? 
21:18:52 <stepcut> happstack 0.6 will have heist suport (the only real hold up is the switch to monads-fd, which is not really hard, it just wasn't the right time until now)
21:20:05 <stepcut> I am curious about what you find simpler though -- I don't want happstack to be more complicated that required ..
21:20:32 <stepcut> but no one ever complains about anything on the mailing list -- so it must be perfect already :p
21:21:37 <stepcut> actually, writing the tutorial for happstack 0.6 has cleaned up a lot of stupidness. When you have to write about how stupid something is, you finally realize it is stupid, and then decide it would be better to fix it and write about something great instead ;)
21:21:39 <jmcarthur> stepcut: you know, i'm going to have to get back to you on that. i seem to recall having a reason for believing this in the past but now i can't think of what it was
21:21:47 <stepcut> k
21:21:55 <jmcarthur> stepcut: heh, yeah, documentation does that :)
21:22:13 <stepcut> the most time consuming portion of documentation is fixing the code :)
21:22:32 <syntaxglitch> I'd offer opinions, but I haven't used happstack and also my idea of making things less complicated would probably just confuse most people
21:22:48 <stepcut> I think a big issue with happstack 0.5 is just the poor code organization and documenation -- a bunch of internals leaked into the user API making things look harder than they should have been
21:23:02 <jmcarthur> stepcut: one nice thing snap has is support for Text
21:23:03 <stepcut> syntaxglitch: I'd still be curious..
21:23:18 <jmcarthur> in addition to ByteString and String of course
21:23:21 <syntaxglitch> stepcut, I'll be sure to give feedback if I ever give it a go
21:23:34 <jmcarthur> although i suspect that since happstack is getting heist it might be getting Text support too?
21:23:45 <stepcut> jmcarthur: happtsack 0.6 supports Text
21:23:52 <jmcarthur> rock
21:25:03 <stepcut> jmcarthur: not sure what areas you want Text support in though -- it could be more places perhaps. I am a big fan of Text. Less of a fan of ByteString being exposed too much. For example, I think writeBS + overloaded in Snap is a bit dangerous because it is not obivous the ovreloaded Strings for blaze support unicode, but for ByteString they don't :(
21:25:44 <jmcarthur> stepcut: yeah that's kind of a gross wart
21:26:15 <stepcut> happstack 7 will be fun. Going to address a bunch of the annoyances in happstack-state
21:26:23 <jmcarthur> stepcut: not a big deal to me though. i pretty much only use writeBS for binary data
21:26:28 <jmcarthur> ooh
21:26:50 <stepcut> right. writeBS for binary can be ok..
21:27:23 <jmcarthur> i predictably think happstack-state is one of the cooler and riskier parts of happstack
21:27:41 <stepcut> happstack has a, toResponseBS for similar reasons. But you are normally typically encouranged to use things like toResponse which take care of the unicode stuff correctly
21:28:07 <stepcut> yeah, things like redis legitamize happstack-state more -- but almost make me really wish we where further ahead on it
21:28:52 <jmcarthur> yeah where's that sharding?
21:28:54 <stepcut> had to cleanup and stabalize the server before playing with state though. 
21:29:04 <stepcut> jmcarthur: will definitely be in happstack 
21:29:05 <stepcut> 7
21:29:37 <jmcarthur> awesome
21:29:45 <stepcut> for happstack 8, I am really hoping to finally move to hyena.
21:30:45 <stepcut> and then things git a bit fuzzier. There are a lot of cool things to work on, but the ordering is unknown
21:42:54 <adnap> Is it called linear interpolation when you "blend" between two points like so? (1-u)p0 + up1
21:43:38 <adnap> Or does linear interpolation imply that you have defined a line between p0 and p1?
21:43:44 <lars9> @pl (\(x, y) -> f x + f y)
21:43:44 <lambdabot> uncurry ((. f) . (+) . f)
21:46:09 <stepcut> jmcarthur: what do you like about heist? Do you find it annoying that sometimes you can update things by modifying the template file, but other times you have to modify the haskell code that creates the splices ?
21:49:03 <lars9> :t isJust
21:49:04 <lambdabot> forall a. Maybe a -> Bool
21:49:56 <litb_> BTW how is it possible to say   (* x) ?  I mean, that we first specify the result and "delay" giving the argument?
21:50:40 <Saizan> (* x) is just sugar for (\y -> y * x)
21:50:46 <ddarius> adnap: That expression as a function of u defines a line between p0 and p1.
21:50:46 <litb_> i mean in  Num a => a -> a -> a  that we first specify the second a and later the first. how is this theoretically represented?
21:50:54 <jmcarthur> stepcut: i like that heist reads like html, mainly, and also that i can reload heist templates on every request when in dev mode but cache them between requests in prod mode. i haven't found the need to modify haskell for creating splices that annoying. the only times i need to do that are when i want to use haskell to generate the data to begin with
21:51:01 <litb_> oh
21:51:19 <jmcarthur> stepcut: the dev/prod distinction is my own, not something build in to snap or heist, btw
21:51:24 <jmcarthur> *built in
21:51:40 <stepcut> jmcarthur: did you ever use HSP ?
21:51:57 <jmcarthur> i toyed with hsp a little a long time ago
21:52:05 <jmcarthur> but i don't remember much of the experience
21:52:11 <stepcut> k
21:53:21 <stepcut> I need to write the templating section of the happstack crash course soon, so I am trying to get an accurate idea of the merits of different systems so I can help people find the right one for their needs
21:53:41 <litb_> so for an Nary function, if we speficy the Ith argument, it yields a (N-1)ary function like (\p1 p2 .. pI-1 pI+1 ... pN -> stuff) ?
21:54:07 <stepcut> heist seems especially useful if you have graphic design team doing much of the web design -- because it gives them something very familiar, and no compiler errors
21:54:15 <jmcarthur> right
21:54:19 <stepcut> and a clean boundary between what the programmers provide and what the designers do
21:54:31 <Saizan> litb_: well, yes, but there's no syntactic sugar to do that
21:54:59 <litb_> ohh now i see
21:55:20 <litb_> it only works for binary functions
21:55:30 <Saizan> it only works for operators
21:55:37 <litb_> ohh
21:55:55 <jmcarthur> @src (.)
21:55:55 <lambdabot> (f . g) x = f (g x)
21:55:56 <lambdabot> NB: In lambdabot,  (.) = fmap
21:56:07 <jmcarthur> (.) is only binary from one point of view ;)
21:56:28 <jmcarthur> it's also unary and ternary depending on how you look at it
21:56:42 <stepcut> jmcarthur: if you have a single server, it also gives you the choice to edit templates directly on the server (whether that is a good idea is another question). But if you are using  mulitple servers, then you have to replicate the changes to all the other servers somehow
21:57:26 <litb_> jmcarthur: what confuses me is that with   f a one can say that one specifies one argument and it possibly yields another function that also accepts one argument and so on... to build up "multi-arg" functions even tho underlying are all one-arg functions
21:57:27 <jmcarthur> yeah i don't think that's a practice i wuld encourage anyway
21:57:27 <Saizan> it's called section syntax, and it's basically described by these two rules "(x *) = (*) x; (* y) = \x -> x * y;" where * can be any operator
21:57:30 <jmcarthur> stepcut: ^^
21:57:36 <stepcut> jmcarthur: do you use anything for form generation/validation with heist ? (eg. formlets or digestive functors?)
21:57:39 <litb_> but with (* x) one just "hacks around" that view 
21:57:51 <litb_> by random-access on the parameters
21:58:00 <jmcarthur> stepcut: i haven't yet, but i probably will be looking into it soon
21:58:04 <stepcut> jmcarthur: yeah, my policy is that things on get onto the server by being built in the autobuilder and apt-get installed on to the server
21:58:21 <jmcarthur> stepcut: digestive functors? i'm not familiar what that one
21:58:31 <stepcut> jmcarthur: I definitely recommend digestive functors over formlets. It's the same thing, but better.
21:58:37 * jmcarthur googles
21:58:48 <litb_> Saizan: ohh. 
21:59:27 <litb_> fmap was a monad thing iirc
21:59:58 <stepcut> jmcarthur: I use it with a digestive-functors-hsp library, but I assume you could make similar digestive-functors-heist library that created heist splices 
22:00:26 <Cale> litb_: fmap is a functor thing, and all monads are functors.
22:00:43 <Cale> litb_: fmap :: (Functor f) => (a -> b) -> (f a -> f b)
22:01:01 <Saizan> digestive functors?
22:01:02 <jmcarthur> stepcut: it looks nice to me
22:01:09 <jmcarthur> Saizan: https://github.com/jaspervdj/digestive-functors/blob/master/digestive-functors.lhs
22:01:11 <jaredj> mmmm
22:01:15 <jaredj> *burp*
22:01:32 <Cale> The usual interpretation of fmap is that it applies a function to each element of some datastructure, or to each result of some computation.
22:01:53 <Cale> (depending on how you're interpreting the data constructor f)
22:02:01 <Cale> er, type constructor
22:02:23 <stepcut> jmcarthur: here is a demo of using them with happstack+hsp, http://www.haskell.org/pipermail/web-devel/2010/000520.html, download the demo.bin and rename it to demo.hs. The mailing list software thinks that text/x-haskell is a binary format and does silly things to the filename
22:03:06 <stepcut> Saizan: like formlets, but better. Includes inline error rendering, and a bunch small but really nice API improvements
22:03:34 <Saizan> stepcut: ah, nice
22:09:11 <jaredj> i have a quilt. it's a 2-D array (index type (Int,Int)) of quilt squares. i want to find out how many squares are adjacent to squares of the same kind.
22:09:44 <jaredj> this involves going through the whole array - fine, fmap - but also the idea of what's left of here, right of here, etc. how do i do that?
22:10:12 <jmcarthur> sounds like you actually want some sort of a comonadic operation
22:10:44 <jaredj> agh!
22:10:49 <jmcarthur> jaredj: check this out. it's related: http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
22:11:01 <jaredj> people stick co- on things and suddenly i don't know what it is!
22:11:09 <Axman6> heh
22:11:14 <Veinor> co-quilting
22:11:21 <jaredj> you could say i co-understand it
22:11:48 <Axman6> hmm, i wonder how useful a 2D zipper would be
22:12:03 <stepcut> I have yet to write an application using a comonad -- I feel like I might be doing something wrong
22:12:05 <Axman6> probably not very
22:12:11 <jaredj> i thought about trying to make a tree that covers the quilt
22:12:19 <Axman6> i don't even know what a comonad is
22:12:25 <Axman6> i did once, for a small time
22:12:51 <stepcut> it' just a type and two functions
22:13:01 <stepcut> how hard could it be?
22:13:27 <ddarius> stepcut: Try writing it in an object oriented language.
22:13:58 <stepcut> ddarius: that's gross
22:14:02 <Saizan> jaredj: it seems you need exactly this comonad http://hackage.haskell.org/packages/archive/category-extras/0.51.3/doc/html/Control-Comonad-Pointer.html
22:14:16 <jmcarthur> i've used Comonad in a lot of toys, but never anything too serious. i think i understand it well enough that i could use it in a real program though
22:14:20 <jaredj> !
22:14:34 <jaredj> (get it, get it?)
22:14:47 <jmcarthur> i'm the author of comonad-random. almost useless package :)
22:14:51 <stepcut> I saw a blog post on rendering hierachical menus using comonads -- that looked useful
22:15:20 <Saizan> jaredj: the "extend" method would be your extended fmap that gives you access to the surrounding context
22:15:21 <jmcarthur> stepcut: interesting, but i don't see how the comonadic structure is useful. sounds like just an ordinary zipper to me
22:15:46 * hackagebot llvm 0.9.0.1 - Bindings to the LLVM compiler toolkit.  http://hackage.haskell.org/package/llvm-0.9.0.1 (BryanOSullivan)
22:15:51 <Axman6> :o
22:15:54 <stepcut> jmcarthur: behind every zipper is a comonad!
22:15:58 <jaredj> o  k... i see that this is what i need but i don't know what it is yet :)
22:15:58 <stepcut> http://fmapfixreturn.wordpress.com/tag/comonad/
22:16:07 <jmcarthur> stepcut: true, but it's the usefulness in this case that i don't see
22:16:19 <Saizan> in the end it's quite simple though
22:16:23 <jaredj> yeargh, now i'm two and a half comonad pages behind
22:16:33 <stepcut> jmcarthur: you'll have to read the post -- I have not finished it yet :(
22:16:36 <jmcarthur> i don't know about *every* zipper. i've seen zippers that contain no values
22:17:09 <jaredj> there's a viagra spam hiding in that statement
22:17:36 <jmcarthur> but i think that's actually an interesting property about zippers... they are fundamentally different depending on if the zipper can be empty or not
22:18:14 <Saizan> in the end you can just write yourself a "mapWithIndex :: (i -> a -> b) -> Array i a -> Array i b"
22:18:19 <Saizan> and use that
22:18:24 <stepcut> jmcarthur: heh
22:18:40 <Saizan> since with the i you can access the surrounding values of the array
22:18:40 <jaredj> wat
22:18:56 <lars9> swapMVar is also not atomic, it's so awkward to do locking with Control.Concurrent ...
22:19:10 <jmcarthur> lars9: STM
22:19:23 <jmcarthur> lars9: MVar is really just meant for very simple cases
22:19:36 <Saizan> takeMVar/putMVar work quite well to take/release the lock
22:19:39 <jmcarthur> it can be made to work for more complex ones, but you really might as well just save the mental overhead and use STM
22:19:46 <lars9> is there any advanced sync/messaging lib?
22:20:00 <Saizan> there are a few
22:20:03 <jmcarthur> yes, but you need to be more specific
22:20:24 <jmcarthur> chp had a lot of blog posts about it there for a while
22:20:45 <dolio> I can't connect to those slides linked with "Behind every zipper is a comonad." But I suspect that's only true if by "every zipper" you don't mean every zipper.
22:20:48 <lars9> Saizan: i need to take a MVar (it's my incoming channel), and set it to [] immediately to prevent others to write in
22:21:28 <lars9> swapMVar is not safe
22:21:41 <jmcarthur> lars9: it sounds like you are misusing MVar to me
22:21:52 <lars9> got to leave now, ttyl
22:21:55 <jmcarthur> lars9: if you need a lock you can implement it with *another* MVar though
22:22:03 <Saizan> lars9: if you always first take and then put then modifyMVar is perfectly safe for that
22:22:24 <jmcarthur> lars9: it sounds like he has some threads blindly putting without taking first though
22:22:28 <jmcarthur> oops
22:22:30 <jmcarthur> Saizan: ^^
22:22:30 <bos> crap, community.haskell.org is down
22:23:05 <lars9> thank you all, i will think about it on road
22:23:07 <lars9> ttyl
22:32:30 <heatsink> @quote co-
22:32:31 <lambdabot> thoughtpolice says: i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
22:32:39 <heatsink> @quote co-
22:32:39 <lambdabot> adept says: Tried to co-read and co-understand comonads, but got co-re dump
22:32:49 <heatsink> @quote co-
22:32:49 <lambdabot> gwern says: wonder what a co-human would be like. would it consume feces and emit steak? you could put a human and a co-human in a circle then
22:33:01 <heatsink> @quote co-
22:33:01 <lambdabot> thoughtpolice says: i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
22:33:49 <heatsink> @quote co-
22:33:49 <lambdabot> thoughtpolice says: i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
22:33:52 <heatsink> @quote co-
22:33:53 <lambdabot> thoughtpolice says: i believe #haskell established at one point or another that prefixing co- to things makes them exist in the bizarro-world
22:34:21 <dolio> Let's quote it a few more times.
22:35:32 <dancor> lbot needs numbered quotes or something
22:36:50 <litb_> oh
22:37:13 <litb_> @quote litb
22:37:13 <lambdabot> No quotes match. You untyped fool!
22:39:32 <dancor> i think it's common to do something where you run thru a list once and also make use of its size (like taking average)
22:39:55 <dancor> i wonder if there should exist helper functions to do this more efficiently than the naive approach
22:40:40 <dancor> or more generally combining two cases of accumulating-thru-a-list-twice
22:41:09 <Saizan> yep, it's possible
22:41:34 <syntaxglitch> ugh, okay, enough agda for tonight
22:42:05 <dancor> i wonder to what extent such optimization makes sense in a library
22:42:40 <dancor> what about that optimization is so hard for ghc?
22:43:19 <dancor> f xs = g (h1 xs) (h2 xs)
22:43:37 <dancor> converted to a strict fold or whatever
22:43:44 <Saizan> type Iteratee e acc = (acc -> e -> acc, acc); combine :: Iteratee e acc1 -> Iteratee e acc2 -> Iteratee e (acc1,acc2); -- something like this should be implementable
22:44:10 <litb_> @pl f xs = g (h1 xs) (h2 xs)
22:44:10 <lambdabot> f = liftM2 g h1 h2
22:44:15 <EvanR> dancor: thats fusion right
22:44:15 <litb_> hmm
22:44:50 <Saizan> combine (f1,z1) (f2,z2) = ((\(a1,a2) e -> (f1 a1 e, f2 a2 e)) , (z1,z2))
22:45:48 <dancor> EvanR: i'm not sure that this would be considered fusion.  fusion has more to do with removing more naive intermediaries i think.. unsure.  http://stackoverflow.com/questions/578063/what-is-haskells-stream-fusion
22:46:55 <Saizan> yeah, afaiu fusion mostly handles sequential pipelines, not so much parallel ones
22:47:06 <dancor> i think fusion is more like making (map f (map g x)) into (map (f . g) x)
22:47:18 <Saizan> though i though it could handle zip/zipWith ?
22:47:39 <Saizan> dancor: it doesn't just apply to map
22:47:43 <heatsink> It can handle one of the operands of zip, not both
22:48:17 <Saizan> i see
22:54:19 <dancor> maybe it's hard for ghc in general to know that h1 and h2 each pass thru the list once
22:54:28 <dancor> whereas writing out a fold makes that clearer
22:55:04 <dancor> does ghc do anything like big-O reasoning ever?
22:56:09 <Saizan> i'm not sure if RULES even allow you to write a transformation like "forall g. g (foldl ..) (foldl ..) = uncurry g $ foldl .."
22:56:33 <bos> they do, but rules like that won't fire very oftenl
23:02:26 <jmcarthur> dancor: i very much doubt it
23:04:23 <dancor> does agda or anything have any machinery to prove things about code running time so the compiler can do better optimizations
23:04:51 <dancor> time-to-spare compilation
23:05:30 <jmcarthur> i also doubt that
23:06:23 <jmcarthur> it's hard enough just to get big-O into the type system (although it's been done) where you manage it explicitly. for the compiler to be able to infer it completely magically would be a feat
23:27:14 <stepcut> dancor: only a small percentage of agda users actually *run* the programs :p
23:27:20 <dancor> heh
23:33:31 <Axman6> :t (/)
23:33:31 <lambdabot> forall a. (Fractional a) => a -> a -> a
23:35:06 <arcatan> oh you can actually run Agda code?
23:40:08 <dancor> i'm sure big-o-determination is undecideable just like halting-problem.  and agda is all about getting around the halting problem with supplemental proofs.  so who knows where it could lead
23:44:30 <raceRider> question of Data.Map http://hpaste.org/41188/datamap
23:46:42 <Axman6> kvPairs never changes, just like all variables in haskell
23:47:37 <dancor> raceRider: if you want to get the pairs back from the updated map, do toList on it.
23:49:49 <dancor> raceRider: if you are absolutely sure you want a _mutable_ map then you might want something crazy like judy arrays
23:50:20 <raceRider> judy arrays? is that a module on hacakge? 
23:50:45 <dancor> raceRider: http://hackage.haskell.org/packages/archive/judy/0.2.2/doc/html/Data-Judy.html
23:52:09 <dancor> > M.toList $ M.insert 6 "bye" $ M.fromList [(4, "hi")]
23:52:09 <lambdabot>   [(4,"hi"),(6,"bye")]
23:52:36 <raceRider> dancor, thanks, let me explore that. Didn't know of it before.
23:52:53 <Lemmih> raceRider: You really don't want to use judy arrays, though.
23:53:01 <raceRider> why?
23:53:58 <Lemmih> raceRider: Because Data.Map is the right choice almost all of the time.
23:55:07 <raceRider> I am not able to figure out how to handle adding new kv pairs during processing and retaining them for subsequent end-processing.
23:55:51 <Lemmih> raceRider: Imagine you had a number and you had to increment it by one.
23:56:05 <raceRider> yes, go on
23:56:22 <Lemmih> raceRider: (+) doesn't mutate the orginal number, it just gives you a new one.
23:56:32 <Lemmih> > let x = 1 in (x+1, x)
23:56:33 <lambdabot>   (2,1)
23:56:41 <Lemmih> raceRider: Data.Map is the same way.
23:57:34 <Lemmih> raceRider: So you do something like: let newMap = insert key value oldMap in ...
23:58:23 <Lemmih> raceRider: If you really don't want to pass the map around manually, use State or an IORef.
23:58:26 <raceRider> a newMap for each time I add a new pair or same newMap? 
23:59:29 <Lemmih> raceRider: A new one for each time you add a pair.
