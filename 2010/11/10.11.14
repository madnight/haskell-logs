00:04:15 <aavogt> isBEKaml: maybe at http://new-www.haskell.org
00:05:33 <aavogt> otherwise archive.org might help
00:09:06 <isBEKaml> aavogt: the new-www.haskell.org site is a front, not a fully hosted site? In particular, the community reports link points to haskell.org
00:14:15 <isBEKaml> aavogt,ksf: I'll try again after some time. Thanks. 
00:25:21 <ksf> gpipe is such a nice api but it's implementation is completely undocumented and possibly utterly messy.
00:25:31 <ksf> can't properly judge the latter due to the former.
00:42:51 <parshimers> so im trying to implement a breadth first traversal, but my tree defintion has nil nodes
00:43:07 <parshimers> i cant quite figure out how id handle skipping nil nodes in the queue
00:43:22 <parshimers> anyone attempted something like this before?
00:45:14 <Saizan> filter (/= Nil) ?
00:45:31 <Saizan> i mean, it's not hard to check for and ignore them
00:45:52 <Saizan> though i'm not particularly familiar with the problem
00:46:11 <parshimers> 's like i have an array of trees 
00:46:23 <parshimers> a tree is either nil or a node 
00:46:34 <parshimers> well array isnt quite the way to put it now is it, list rather
00:48:13 <parshimers> hm that filter thing is interesting though never knew of it...
00:52:16 <Saizan> ?type filter
00:52:17 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:52:25 <Saizan> > filter even [1..]
00:52:26 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
00:53:13 <Saizan> a list works well as a stack, for a queue you need a something else
00:53:19 <parshimers> http://jjinux.blogspot.com/2005/12/haskell-breadth-first-tree-traversal.html
00:53:25 <Saizan> e.g. Data.Sequence
00:54:13 <parshimers> i kind of get how they're goin about it in that example 
00:55:21 <parshimers> i cant think of how to adapt that idea there to a tree with nil nodes though
00:56:08 <parshimers> i have to guarantee somehow its an array of nodes, not nils 
00:57:39 <Saizan> instead of "map treeValue xs" you can do [ x | Branch x _ _ <- xs ]
00:59:06 <parshimers> how does the bar operator work there
00:59:12 <parshimers> same as always?
00:59:23 <parshimers> and ive never seen that <- before, thats interesting
00:59:37 <Saizan> thw whole thing is called a list comprehension
00:59:55 <Saizan> it's syntactic sugar for manipulating lists
01:00:01 * ksf still thinks that gpipe should support carrying texture (references) in vertex streams.
01:00:05 <Saizan> ?undo [ x | Branch x _ _ <- xs ]
01:00:05 <lambdabot> concatMap (\ a -> case a of { Branch x _ _ -> [x]; _ -> []}) xs
01:00:17 <Saizan> parshimers: that's what it desugars to ^^^
01:00:26 <ksf> it in fact doesn't make any sense not to, as that's where you also keep your uv coordinates.
01:00:39 <ksf> which are meaningless without an associated texture
01:01:14 <ksf> damn those minimal demo programs which fail to uncover such semantic gaps
01:01:51 <parshimers> huh, very cool. can say alot in a little for sure
01:02:44 <Saizan> yep, it's a very nice notation, it's inspired by set comprehensions in math
01:03:13 <parshimers> lol thats why i asked about the bar operator
01:03:26 <parshimers> made me think x such that x is that x in branch in xs
01:03:53 <Saizan> x such that (Branch x _ _) in xs :)
01:03:59 <parshimers> yeah!
01:04:54 <Saizan> i thought you were referring to the other use of | in haskell's syntax, which is to introduce guards
01:05:11 <parshimers> i wanted to think it was that but it didnt really make sense there
01:05:12 <monadic_kid> i tend to forget about list comprehensions to much
01:06:22 <Saizan> does it make sense now?
01:06:54 <parshimers> yes i just wish the haskell.org server didnt decide to die for me right now lol
01:07:03 <parshimers> was gonna go read up more about lists
01:07:56 <Saizan> it's been dead for a while
01:08:15 <Saizan> http://new-www.haskell.org/haskellwiki/List_comprehension <- the haskellwiki still works
01:09:44 <parshimers> oh neat, new bookmark
01:13:17 <Saizan> afaiu that's just a temporary address of the new server that's going to replace www.haskell.org
01:13:34 <parshimers> hm i see, explains all the weirdness
01:14:09 <parshimers> ah i wish my prof used this language as an example of functional programming
01:14:17 <parshimers> instead of scheme... stupid endless parenthesis
01:14:21 <engla> at least that works for now (trying tobrowse the docs). thanks
01:25:36 <winmike> hi
01:26:04 <winmike> i try to using find -> works. but what is this maybe? i want the result or empty list but nut "just" "nothing" :(
01:26:13 <Phyx-> is there a better way or writing "fapp s (v, b) = (fromJust $ appAll s v, fromJust $ appAll s b)" ? where are the bifunctor instances anyway?
01:26:40 <Phyx-> @hoogle maybe
01:26:40 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
01:26:40 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
01:26:40 <lambdabot> module Data.Maybe
01:26:44 <Phyx-> that maybe?
01:26:59 <winmike> i think so http://zvon.org/other/haskell/Outputlist/find_f.html
01:27:01 <Phyx-> > maybe [] return (Just 1)
01:27:02 <lambdabot>   [1]
01:27:34 <Phyx-> right
01:28:03 <Phyx-> :t \o-> maybe [] return . find o
01:28:04 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
01:28:35 <Phyx-> > maybe [] return (find (>3) [0,2,4,6,8])
01:28:35 <lambdabot>   [4]
01:28:40 <winmike> Phyx-, i want to use the result - no he gives me "Just (0,[(2,200),(3,100)])" - but i want the original type :-/
01:28:47 <winmike> now
01:29:02 <Saizan> winmike: you can pattern match against the constructors
01:29:26 <Saizan> the Nothing is there to report when no value satisfying the predicate has been found
01:29:42 <Saizan> Just instead tells you there was one
01:29:55 <Phyx-> oh, he meant Maybe instead of maybe?
01:30:24 <winmike> Saizan, but i want an empty list if there is now result *g*
01:30:32 <winmike> maybe confuses me
01:30:55 <Saizan> winmike: so you want a singleton list when there's one result?
01:31:00 <ddarius> Then what you probably want to do is get unconfused about Maybe.
01:31:38 <Saizan> yeah, Maybe is quite basic, you can't progress much without being able to understand it
01:32:33 <Saizan> > let findList p xs = case find p xs of Nothing -> []; Just x -> [x] in findList even [1..]
01:32:34 <lambdabot>   [2]
01:32:39 <Saizan> > let findList p xs = case find p xs of Nothing -> []; Just x -> [x] in findList even [1,3..]
01:32:43 <lambdabot>   mueval-core: Time limit exceeded
01:32:45 <Saizan> heh
01:32:49 <Saizan> > let findList p xs = case find p xs of Nothing -> []; Just x -> [x] in findList even [1,3..9]
01:32:54 <lambdabot>   mueval-core: Time limit exceeded
01:33:14 <Saizan> > let findList p xs = case find p xs of Nothing -> []; Just x -> [x] in findList even [1,3,5,7,9]
01:33:16 <lambdabot>   []
01:34:28 <Phyx-> > maybe [] return (find (>3) [0,2,4,6,8])
01:34:29 <lambdabot>   [4]
01:34:34 <Phyx-> > maybe [] return (find (>9) [0,2,4,6,8])
01:34:34 <lambdabot>   []
01:34:38 <Phyx-> @src maybe
01:34:38 <lambdabot> maybe n _ Nothing  = n
01:34:38 <lambdabot> maybe _ f (Just x) = f x
01:35:33 <Phyx-> > let m (f::foral a. -> Int) = (f 1, f 'a') in m (\_->1)
01:35:34 <lambdabot>   <no location info>: parse error on input `.'
01:35:46 <Phyx-> > let m (f::foral a. a-> Int) = (f 1, f 'a') in m (\_->1)
01:35:48 <lambdabot>   <no location info>: parse error on input `.'
01:35:54 * ddarius is more of the mind that the "requirement" to produce a list is spurious.
01:35:58 <Phyx-> > let m (f::forall a. a-> Int) = (f 1, f 'a') in m (\_->1)
01:35:59 <lambdabot>   (1,1)
01:36:15 <Phyx-> :t ord
01:36:17 <lambdabot> Char -> Int
01:36:50 <Phyx-> :t id `mkT` ord
01:36:51 <lambdabot>     Ambiguous type variable `b' in the constraint:
01:36:51 <lambdabot>       `Typeable b' arising from a use of `mkT' at <interactive>:1:0-11
01:36:51 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
01:37:09 <Phyx-> :t mkT
01:37:10 <lambdabot> forall b a. (Typeable a, Typeable b) => (b -> b) -> a -> a
01:37:25 <Phyx-> :t (mkT id) `extT` ord
01:37:26 <lambdabot>     Couldn't match expected type `Char' against inferred type `Int'
01:37:26 <lambdabot>     In the second argument of `extT', namely `ord'
01:37:26 <lambdabot>     In the expression: (mkT id) `extT` ord
01:39:54 <winmike> hmm Maybe confuses me. does anybody know what i have done wrong? http://codepad.org/oOnJgF16 al2amFindNode now returns this Maybe stuff and i have to change everything to maybe :-(
01:42:27 <Saizan> you don't seem to understand how algebraic data types and pattern matching work
01:42:58 <winmike> yes ;)
01:43:26 <winmike> but i will learn if there is some time in holidays
01:44:05 <winmike> most of the time i get it work - but i dont understand this maybe thing
01:44:08 <portnov> @src findIndex
01:44:08 <lambdabot> findIndex p     = listToMaybe . findIndices p
01:44:23 <parshimers> freaked me out when i saw it too
01:44:31 <parshimers> "maybe" is not a word you usually see in code, lol
01:45:08 <winmike> if i remove it from "al2amFindNode" he complains
01:45:27 <portnov> @src lookup
01:45:27 <lambdabot> lookup _key []          =  Nothing
01:45:27 <lambdabot> lookup  key ((x,y):xys) | key == x  = Just y
01:45:27 <lambdabot>                         | otherwise = lookup key xys
01:45:41 <Saizan> winmike: http://learnyouahaskell.com/making-our-own-types-and-typeclasses#algebraic-data-types
01:46:05 <parshimers> oh god thats a great domain lol
01:46:09 <parshimers> imm'a learn me a haskell
01:46:54 * ddarius much prefers Haskell's Maybe/Just/Nothing to ML's Option/Some/None.
01:48:13 <winmike> Saizan, long page ;)
01:48:48 <dolio> Option sounds kind of like Either.
01:49:02 <dolio> Although, if you read it as 'optional' I guess it makes sense.
01:49:27 <dolio> But that's kind of weird with the postfix.
01:51:33 <winmike> Saizan, ok - but how does this help me to solve my problem now? ;))
01:52:03 <endojelly> winmike, because you have to understand algebraic data types to solve your problem?
01:52:48 <ddarius> endojelly: Understanding the code you write is for weenies.
01:53:10 <endojelly> ddarius, well he doesn't understand how to write it in the first place, so...
01:53:48 <ddarius> endojelly: One should just slather text into a file until it compiles and passes the few test inputs you have, then call it done.
01:54:10 <endojelly> ddarius, sounds great. maybe employ a beam search algorithm to do so.
01:54:48 <endojelly> ddarius, or just map every test case input to its corresponding output. BAMM, instant code
01:54:53 * Phyx- doesn't understand his code at times
01:55:11 <Phyx-> If it compiles, ship it
01:55:48 <ddarius> endojelly: That's an acceptable answer, but that requires understanding pattern matching.
01:55:53 <Zao> Soo, how's that VSHaskell coming along? :D
01:56:00 <Phyx-> loool
01:56:14 <Phyx-> I was not expecting that comeback :P
01:56:23 <endojelly> ddarius, damn. again with the slathering.
01:56:33 <ManateeLazyCat> Which pipe library is best on hackage? Best don't use Lazy IO.
01:56:52 <ManateeLazyCat> I found http://hackage.haskell.org/package/Pipe
01:56:53 <Zao> Phyx-: I'm just curious, as I haven't seen any blog posts lately.
01:57:00 <Zao> I guess coursework is more fun, eh? :D
01:57:36 <winmike> endojelly, google also helps ;) "Just" works ;)
01:58:27 <Phyx-> Zao: not more fun.. more obligatory.. I'm about 3-4months from graduation. But I'm stuck while reading feedback from cabal-install. so I'm going to draft up something on a cabal-install-api and if that's accepted I can continue
01:58:59 <Phyx-> I also need to update the internal GHC to 7.0, I expect alot to break :/
01:59:22 <endojelly> winmike, and it doesn't strike you as odd that you hav no odea why you have to write this "Just" stuff?
02:00:10 <winmike> endojelly, i hope i will understand when i have to write the exam :)
02:01:41 <endojelly> winmike, anyway, you can't expect much help here if you're not willing to understand at least the most basic concepts. we are not here to do your homework. help with it, maybe, but that implies a willingness to learn.
02:02:28 <winmike> endojelly, doing homework means: give you a text and expect code. i never gave you a text here
02:03:05 <endojelly> winmike, you did sth. equivalent: "here's a problem, fix it, no I don't want to understand why"
02:04:33 <winmike> endojelly, i dont have to comment that - however
02:05:09 <endojelly> winmike, well then, good luck with your homework and your exam.
02:06:02 <winmike> endojelly, thanks
02:08:19 <ManateeLazyCat> @hoogle hFlush
02:08:19 <lambdabot> System.IO hFlush :: Handle -> IO ()
02:11:51 <Phyx-> lol, guess we won't be seeing winmike again
02:13:39 <ksf> so, let's hear your oppinions: with the advent of cuda and the possibility to write haskell->cuda compilers, will graphics stuff like gpipe become irrelevant?
02:14:30 <ksf> or should it be kept and get an interface to things possible on cuda-grade cards e.g. geometry shaders?
02:17:46 <Phyx-> isn't cuda restricted to only NVidia cards?
02:19:45 <ksf> nope. at least not in principle.
02:20:25 <ksf> actually I think nvidia is just disabling cuda on my card, it should, in principle, be capable of doing it. albeit possibly slowly around the edges.
02:21:10 <ksf> early fragment processors weren't designed with jumps and compares in mind.
02:21:39 <Phyx-> hmm
02:22:02 <ksf> ...not to mention all the management overhead involved when each fragment takes a different time to be calculated.
02:22:19 <ksf> ah, the cross-platform standard is opencl
02:22:28 <Phyx-> But all the work on Cuda is mainly supported by Nvidia, atleast that's the impression I get
02:22:35 <Phyx-> ATI has Stream or something
02:23:14 <ksf> yep opencl is only 4 months old
02:23:29 <ksf> ah no that's the current release.
02:23:30 <ksf> 2008.
02:28:35 <Phyx-> it's a quiet sunday here today
02:33:55 <Phyx-> This is rather sad.. I can fix my problem with a hack.. but I can't think of a proper fix
02:43:25 <arcatan> gah.
02:46:13 <arcatan> redis uses mtl and i use transformers. now my WithRedis instance needs MonadIO from mtl and I have it from transformers.
02:49:59 <Saizan> compile redis against mlt-2?
02:50:03 <Saizan> *mtl-2
02:50:13 <arcatan> sounds good, but how do i do that?
02:50:39 <ksf> opengl.org forums say glsl is going to survive
02:50:42 <Saizan> cabal install redis --constraint="mtl >= 2", assuming it'll build
02:51:25 <Saizan> seems so
02:51:33 <arcatan> yes, thanks!
03:00:20 <Heffalump> is there some pin so the default mtl is still < 2 ?
03:00:41 <ksf> don't.
03:00:47 <ksf> just don't.
03:01:13 <ksf> install a recent monadsfd and mtl-2 and lo! they're the same.
03:01:41 <ksf> you can freely intermix the StateT of one with the other because monadsfd is just a re-export.
03:02:06 <Saizan> Heffalump: i don't think so
03:10:04 <ksf> so... let's make gpipe into a proper glsl binding.
03:11:17 <ksf> starting with fixing the code generation to use an ast. the current one is an inscrutinable mess.
03:24:50 <arcatan> i wonder what's new in ListLike 2.0
03:39:09 <ksf> getCode ((f,i,b,s),inlns) (n, (ShaderUniform (UniformBool _), _)) = (((f,i,b+1,s),inlns), assign "bool" (const $ inName ++ "ub[" ++ show b ++ "]") (var n) [])
03:40:10 <adu> ksf++
03:40:18 <engla_> haskell zippers made me read about regular zippers and their invention :-)
03:41:10 <adu> engla_: that's odd, haskell zippers made me learn about Species and Formal Typolynimials
03:41:15 <Saizan> regular zippers?
03:41:29 <adu> Saizan: i'm assuming the pants kind
03:46:46 <engla_> zippers are really quite ingenious, both haskell and pants. especially considering a branching datastructure where the zipper will only break up linear trails
03:48:04 <engla_> I mean it needs to (de)reconstruct nodes in its path, but just the ones it passes over; no big copies of the whole datastructure (if it's recursive)
03:50:00 <RyanRN> Phyx-, ksf, Regarding the previous GPGPU language discussion I've been playing with accelerate and Nikola and in the context of both there has been a lot of discussion of targeting OpenCL.  I think CUDA was just the obvious choice for the first backend in both projects.
03:50:31 <RyanRN> But the nice thing about them is they're so high-level that they're not really CUDA-specific...
03:50:56 <ksf> gnnargh glsl doesn't allow int attributes.
03:52:32 <Axman6> RyanRN: i think targeting OpenCL will be a little bit more difficult, just because it's a bigger system where you have to do more to get the work done. CUDA makes it easy by extending C with its own 
03:52:42 <Axman6> own (actually quite nice) syntax*
03:53:08 <RyanRN> Ah, ok
03:54:02 <Axman6> but, it'll happen eventually... i hope
03:59:55 <ksf> well, my question was whether glsl, that is, a graphics-specific solution, will survive the gpgpu stuff.
04:00:42 <ksf> it's kind of the mapreduce of gfx
04:02:01 * ksf wonders why they forbid those. it'd be no problem to pass ints in float registers under the hood, anyway.
04:02:28 <ksf> it's strange to see a language where ints and bools are second-class citizens.
04:09:33 <ksf> there's also going to be tgsi, gallium's il, in the future.
04:23:58 <Ke> ksf: at least >24-bit integer operations require more on some more work on some nVidia hw
04:40:21 <krey_> o/
04:41:00 <krey_> I was wondering, is there some kind of book on continuations and such
04:41:12 <krey_> (not necessarily in Haskell)
04:45:50 <Saizan> you're more likely to find something that uses scheme, in fact
04:49:48 <akamaus> what happened to haskell.org?
04:50:37 <arcatan> apparently there are some hosting problems
04:50:53 <arcatan> in teh mean time there's http://new-www.haskell.org/haskellwiki/Haskell
05:06:56 <Etsun> arcatan: Woah, pretty.
05:16:25 <Rutix> haskell.org down?
05:16:38 <ksf> yep.
05:16:41 <Rutix> Damn
05:16:44 <ksf> omg nouveau works.
05:32:33 <joe6> hello, just curious of your thoughts on http://hpaste.org/41460/io_lists
05:32:34 <lambdabot> joe6: You have 1 new message. '/msg lambdabot @messages' to read it.
05:34:30 <ksf> mesa w/ gallium just won't compile, though.
05:37:55 <joe6> i have 3 lines of the format --  appendFile <filenamex> $  concatMap <functionx> messages
05:38:05 <joe6> i am sure there is a way to make it into one line
05:38:10 <joe6> any thoughts, please?
05:42:30 <joe6> the channel seems a bit quiet.
05:42:35 <Botje_> forM [("host2devicedata/writeusbflags.dat",msgflags),...] $ (\(file, fun) -> appendFile file $ concatMap fun messages
05:42:45 <Botje_> that's one solution
05:42:54 <Botje_> but for three lines I wouldn't argue it's nicer
05:43:56 <ksf> well, they _do_ compile.
05:44:08 <sshc> 3\la
05:44:19 <ksf> 300fps in glxgears, which looks quite flawless indeed.
05:44:26 <joe6> Botje: smart. Thanks.
05:45:58 <Twey> mapM . uncurry appendFile . second (message >>=) $ [("host2devicedata/writeusbflags.dat", msgflags), â€¦ ]
05:46:07 <Botje_> joe6: also, your msgtype can be written as msgtype (Message t _ _) = t
05:51:24 <joe6> Botje_: yes, i noticed that too. just changed it.. Thanks a lot.
05:51:34 <joe6> Twey: will try the solution.
05:52:45 <ksf_> omg I can play a 1048x872 h.264 and still have 5 to 1% cpu left.
05:52:54 <ksf_> the binary blob was failing so hard on that one.
05:53:28 <ksf_> 2048, even.
05:53:54 <joe6> mapM_ (\(file,getcontent) -> appendFile file $ concatMap getcontent messages) [("host2devicedata/writeusbflags.dat",msgflags), ....
05:54:12 <joe6> the above works, as per Botje_'s idea.
05:54:29 <Twey> Yes, but the point-free version is much nicer in this case.
05:54:33 <joe6> trying out Twey's ide.
05:54:38 <Phyx-> Twey's version is nicer though
05:54:45 <Twey> Should probably be mapM_ if you don't want the results
05:55:35 <joe6> Twey: why do you say " if you don't want the results" -- Doesn't mapM_ perform sequential IO actions?
05:55:42 <joe6> on a list of actions?
05:56:10 <Phyx-> :t mapM
05:56:11 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
05:56:13 <Phyx-> :t mapM_
05:56:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
05:56:18 <arcatan> yes, but it does not collect their results
05:56:44 <joe6> oh, ok. that is fine as there are no results coming back to the program. just side-effect of appendFile
05:56:54 <Twey> joe6: I just rephrased without looking at the actions you were actually performing
05:56:54 <Twey> If you're not going to use the results of the actions and just want to execute them for the side effects, you should discard the results by using mapM_ instead of mapM
05:57:19 <joe6> Twey: Thanks, makes a lot of sense.
05:57:51 <Twey> Oh
05:57:54 <Twey> I screwed up, though
05:58:30 <Twey> mapM_ (uncurry appendFile . second (message >>=)) $ [ â€¦ ]
05:59:05 <joe6> Twey: do not worry. you have shown me the path. I will figure out the details.
06:01:42 <hpc> ^^
06:07:15 <christastrophe> haskell.org sure seems to go offline with some frequency. where is the site hosted?
06:09:05 <Twey> Galois, I think?
06:09:08 <Mitar> is there soo much load?
06:09:16 <ksf_> no, it's sunday.
06:09:20 <hpc> when i checked it said connecticut 
06:09:28 <Mitar> do you need any help fixing it?
06:10:20 <christastrophe> galois should invest in a remote access powerstrip :)
06:10:45 <Phyx-> or an intern
06:10:49 <hpc> you mean a KVM?
06:11:46 <joe6> Twey: wouldn't i be doing appendFile many times per file, if I use uncurry and then mapM_ over the list?
06:12:11 <Heffalump> haskell.org is in Yale
06:12:17 <Heffalump> www.haskell.org, that is
06:12:24 <Botje_> no, you only get one invocation of appendFile per element of your input list
06:12:44 <DevHC> is it me, or is www.haskell.org down?
06:12:49 <Heffalump> there are plans to move away from there asap
06:12:52 <Heffalump> DevHC: it's down.
06:13:12 <Botje_> maybe it's time to put that in the topic :)
06:13:26 <hpc> why would yale have difficulty with hosting haskell.org?
06:13:32 --- mode: ChanServ set +o Heffalump
06:13:38 --- topic: set to '["Yes, www.haskell.org is down", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Heffalump
06:13:41 <hpc> it's not like it gets /that/ much traffic
06:13:48 <christastrophe> hpc: no. something like this: http://goo.gl/IB2y7
06:13:50 <Heffalump> no idea, but it's not working out well
06:13:54 <Botje_> Heffalump++
06:14:15 <Heffalump> Botje_: I had the same thought at the same time as you, just got slowed down by needing ops :-)
06:14:16 <arcatan> @faq Is www.haskell.org down?
06:14:16 <lambdabot> The answer is: Yes! Haskell can do that.
06:14:20 <Phyx-> Heffalump++
06:14:21 --- mode: Heffalump set -o Heffalump
06:14:38 <Heffalump> of course, now we need to remember to fix it
06:14:54 <Phyx-> eventually
06:14:58 <Phyx-> it's sunday afterall
06:15:32 <Heffalump> I mean the topic.
06:15:38 <Phyx-> oh
06:15:41 <christastrophe> if anything it would be nice to mirror hackage and hoogle
06:16:03 <Phyx-> you could get the hoogle tool
06:16:04 <solistic> christastrophe: hackages, afaik
06:16:25 <solistic> christastrophe: i mean hackage works, afaik ;)
06:16:36 <DevHC> well www.yale.* is running, so i gather yale is discriminating
06:16:39 <christastrophe> solistic: so it is
06:17:07 <Twey> I imagine there's more than one server at Yale ;)
06:17:23 <Phyx-> ilol
06:17:28 * hackagebot uuagc 0.9.30 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.30 (ArieMiddelkoop)
06:17:53 <joe6> i have graduated to using Control.Arrow, all excited about it..
06:17:55 <Twey> Heffalump: /msg chanserv topic #haskell <new topic> is easier
06:18:09 <Phyx-> why did my lol come with an i
06:18:32 <Heffalump> Twey: ah, didn't know about that
06:18:40 <Saizan> Phyx-: i thought it was from Apple
06:19:01 <Phyx-> Saizan: I should watch out, don't want to be sued :/
06:19:30 <Jafet> loli?
06:21:00 <Phyx-> pop
06:21:25 * Phyx- should stop making these random jokes here so he doens't get troll status
06:21:49 <Botje_> Phyx-: you're nowhere near protontorpedo, don't worry :)
06:22:05 <Phyx-> wee :)
06:22:43 <JimmyRcom> when I say, findEnd (level+1)  ('(':current), it's telling me it's grabbing "(level+1)  '('" as an argument to cons, can anyone help?
06:23:20 <Heffalump> JimmyRcom: what says that? With that bracketing that can't happen in Haskell.
06:24:00 <JimmyRcom> let me post to ideone, I'm trying to start a simple parser but I'm stuck
06:24:39 <JimmyRcom> http://ideone.com/ghwxL
06:25:31 <Saizan> JimmyRcom: line 20
06:25:51 <sipa1024> JimmyRcom: put brackets around it
06:25:57 <sipa1024> as you did in the paste here
06:26:18 <sipa1024> JimmyRcom: function application has higher priority than (:)
06:26:22 <Saizan> line 21 has the same problem
06:26:58 <JimmyRcom> ah shoot, thank you sipa, I don't know why I was thinking it was the other line
06:30:22 <JimmyRcom> want to make a simple thing where (b (u test)) returns <b><u>test</u></b> and other formatting. I wrote it in php first but found out it does really really crappy when there's a lot of nested formats
06:32:15 <exDM69> which Haskell package contains all the glX functions (needed for X11 + OpenGL)
06:32:54 <sipa1024> hopengl?
06:33:40 <exDM69> the docs aren't too good
06:33:48 <exDM69> can't find any of the glX functions there
06:33:53 <hpc> didn't hopengl just become opengl?
06:33:59 <exDM69> yeah, it's called OpenGL
06:34:03 <exDM69> without the H
06:34:22 <hpc> yeah, i tried dealing with that lib and it took me a week to make a cube
06:34:26 <hpc> it was pretty ridiculous
06:34:37 <exDM69> why did it take so long?
06:34:39 <Kedorlaomer> !ds_askforsession
06:34:53 <exDM69> was there technical issues or just having a hard time with OpenGL?=
06:34:58 <hpc> mostly because i haven't done much graphics stuff before
06:35:03 <lars9> JimmyRcom: what's wrong with that surrounding function?
06:35:11 <hpc> partially because it's quite hard to learn the lib
06:35:16 <exDM69> I'm trying to figure out how to set up an OpenGL 3+ context. Deprecated OpenGL 2.x won't do
06:35:40 <exDM69> seems that everyone uses SDL, GLUT or GLFW to set up their contexts
06:36:02 <JimmyRcom> lars9: what surrounding function? All is well now with no errors, thanks
06:36:44 <hpc> from what i have heard, SDL is the easiest
06:37:01 <exDM69> SDL also sucks
06:37:09 <exDM69> for example the fullscreen mode is really really bad
06:37:18 <exDM69> and multiple displays don't really work
06:38:04 <exDM69> I really would not like to write bindings for glX stuff but it might be that no-one else has done that
06:38:52 <ddarius> It shouldn't be all that hard.  You can check the X libraries.
06:39:06 <exDM69> yeah, I'm trying to find it
06:39:11 <exDM69> perhaps it's in x11-extras
06:40:08 <exDM69> nay, not there either
06:40:34 * hackagebot hjsmin 0.0.1 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.1 (AlanZimmerman)
06:40:56 <exDM69> http://www.n-heptane.com/nhlab/repos/haskell-glx/   found this
06:41:16 <exDM69> so perhaps they are not a part of the default OpenGL or X11 libs
06:44:12 <JimmyRcom> in erlang the reverse function was a built in function(BIF) that wasn't written in erlang. Does haskell have built in functions or is all prelude pure haskell?
06:44:54 <sipa1024> some things can't be
06:44:59 <hpc> haskell has built-in types
06:45:04 <hpc> some of which need not be built-in
06:45:12 <hpc> [], ->, and (,) are built in
06:45:39 <sipa1024> you can't define Int in haskell itself, at least not efficiently
06:45:47 <hpc> (,) can be implemented in pure haskell, and so can [], but [] wouldn't have those syntactical conveniences
06:46:29 <hpc> this question is best answered as an introduction to unboxed types
06:46:50 <JimmyRcom> ah, thanks, I'll try to read up more. Used to erlang being slow-ish
06:47:04 <opqdonut> JimmyRcom: all the functions in prelude are implemented in haskell
06:47:15 <opqdonut> IO is a bit magic, tho
06:47:22 <sipa1024> yes; but some are referring to built-in functions
06:47:35 <sipa1024> for their definition
06:47:42 <opqdonut> well ok, arithmetic is built-in
06:47:44 <engla_> list comprehensions are obviously not implemented as functions
06:47:49 <hpc> yeah, IO and (->) (and ST?) are the only types that can't be implemented in haskell
06:47:52 <hpc> at all
06:47:59 <opqdonut> engla_: list comprehensions are not in the prelude, as such
06:48:04 <hpc> the others can, in hacky ways
06:48:05 <Phyx-> Welcome to the RealWorld#
06:48:19 <engla_> is , in the prelude?
06:48:23 <hpc> yes
06:49:05 <Phyx-> @src (,)
06:49:05 <lambdabot> Source not found. Are you on drugs?
06:49:09 <Phyx-> possibly
06:49:31 <hpc> oh right, no hoogle :(
06:49:49 * engla_ has been downloading a lot of -doc packages for this debian system today. as a replacement for haskell.org
06:50:08 <Phyx-> @hoogle (,)
06:50:09 <lambdabot> Prelude undefined :: a
06:50:09 <lambdabot> Test.QuickCheck.Batch bottom :: a
06:50:09 <lambdabot> Data.Function fix :: (a -> a) -> a
06:50:22 <hpc> lol
06:50:30 <Phyx-> @hoogle a -> b -> (a,b)
06:50:30 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> e -> (a, e)) -> a -> d -> (a, d)
06:50:30 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
06:50:30 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
06:50:46 <hpc> these are the most useless results :D
06:50:51 <Phyx-> @hoogle :: forall a b. a -> b -> (a,b)
06:50:52 <lambdabot> Data.Generics.Twins gmapAccumT :: Data d => (a -> e -> (a, e)) -> a -> d -> (a, d)
06:50:52 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
06:50:52 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
06:51:07 <Phyx-> lol, not mostly, they are useless :P
06:51:54 <hpc> (i meant "most" as a superlative, not a quantifier :P)
06:52:33 <Phyx-> ah, 
06:52:36 <sipa1024> hpc: depending on how you see it, i think IO can be implemented in Haskell
06:52:37 <Phyx-> I read wrong :P
06:53:31 <hpc> sipa1024: i think at some point you still need primitives to get at the real world
06:53:33 <engla_> GHC.Tuple
06:53:36 <ksf> I'm genuinely impressed.
06:54:03 <engla_> since haskell is pure, there is no real world. (in haskell)
06:54:09 <Phyx-> I just spend 3 hours trying to fix my code, I just realised, it's the input that's wrong not the code :/
06:54:14 <hpc> there is no spoon?
06:54:22 <ksf> spring runs just fine on nouveau/gallium/llvm, ut2004 is playable at low resolutions/settings, and doom3... kills it utterly even on lowest settings.
06:54:37 <hpc> Phyx-: i hate when that happens; then i laugh about it later
06:54:57 <Phyx-> hpc: I figure.. atleast i fixed the "bug"
06:54:58 <ksf> so in case you didn't try nouveau yet, chances are that they fulfill your every 3d need.
06:55:02 <sipa1024> hpc: if you see IO a as a concrete algebraic data structure that represents an interaction with the real worl (with constructors like PutStr, ...), and main as a computation that produces such an action
06:55:19 <ksf> more than enough to play tuxracer.
06:55:30 <hpc> sipa1024: ah; so it's like having it output assembly code or something
06:55:32 <sipa1024> all the operations to combine IO actions can be written in Haskell itself (and i think they are)
06:56:07 <sipa1024> the runtime library would call main, and interpret the resulting action, and that part can't be written in haskell itself
06:56:19 <joe6> Twey: need some help, please. This is the best I can come up with: uncurry appendFile $ (\(x,y) -> (x, concatMap y [Message Setup 1 "string"]))  ("junk",msgflags)
06:56:33 <joe6> any thoughts on how I can take it to the next level?
06:56:35 <sipa1024> but from the point of view of the haskell code itself, nothing unimplementable happens to IO types
06:56:41 <ksf> that's actually what's being done. well, the STG interprets it and the strictifier turns most of it into straight code but...
06:56:48 <joe6>  msgflags :: Message -> String
06:57:05 <hpc> joe6: give that big lambda a name
06:57:15 <ksf> the magic happens at the ffi.
06:57:21 <Phyx-> @pl (\(x,y) -> (x, concatMap y [Message Setup 1 "string"]))
06:57:22 <lambdabot> second ($ Message Setup 1 "string")
06:57:40 <hpc> :t (>>>)
06:57:41 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
06:57:45 <joe6> hpc: ok, thanks
06:57:58 <joe6> Phyx: that was smart.
06:58:05 <Phyx-> I should really get around to learning arrows...
06:58:21 <Phyx-> and category theory in general
06:58:26 <Phyx-> everytime I start reading the book
06:58:27 <Phyx-> i nod off
06:58:31 <joe6> me too, I guess..
06:58:45 <hpc> @hoogle a b c -> a c d -> a b d
06:58:45 <joe6> are you using RWH?
06:58:45 <lambdabot> Control.Arrow (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:58:45 <lambdabot> Control.Category (>>>) :: Category cat => cat a b -> cat b c -> cat a c
06:58:45 <lambdabot> Control.Category (.) :: Category cat => cat b c -> cat a b -> cat a c
06:59:01 <hpc> pah
06:59:21 <Phyx-> joe6: no, "Introduction to category theory"
06:59:38 <exDM69> seems that it's not plausible to set up an OpenGL 3+ context with X11 using Haskell atm. You need some API's that haven't been wrapped yet. In particular this concerns the newer GLX functions (which are a mess anyways)
06:59:45 <Phyx-> joe6: http://www.amazon.com/Category-Computer-Scientists-Foundations-Computing/dp/0262660717
07:00:42 <chrisdone> anyone interested in a thin layer of lisp syntax on top of haskell? http://hpaste.org/41461/lisk_demo I'll give you a bump when it's complete
07:02:00 <exDM69> chrisdone: looks pretty interesting
07:02:49 <hpc> lispy monads would look kinda silly, i think
07:02:51 <Twey> joe6: http://hpaste.org/41462/twey
07:02:52 <Twey> Oh, I got the title and author backwards again.  That keeps happening.
07:03:10 <hpc> i hate when i do that
07:03:17 <chrisdone> hpc: why? merely: (do x y z)
07:03:45 <chrisdone> I've noticed that people tend to get their title and paste name the wrong way round. `\_o_O_/'
07:04:32 <joe6> chrisdone: have you checked out liskell
07:05:00 <Phyx-> ok.. my program is eating a quantifier...
07:05:02 <Phyx-> forall a b. (c -> b) -> (a -> c) -> a -> b
07:05:26 <hpc> om nom type variables nom
07:05:38 <hpc> is that from :t?
07:05:56 <Phyx-> no, from my typechecker
07:06:06 <hpc> ah
07:06:07 <hpc> nifty
07:06:26 <Phyx-> not if it eats a quantifier :/
07:06:38 <chrisdone> joe6: yep. differences are: (1) doesn't require a GHC patch, (2) goes a little further at being lispy e.g. (* 1 2 3) vs liskell's (* 1 (* 2 3)), and :foo-bar, vs FooBar for types/constructors. to run it you merely need to install the `lisk' executable and then add that line to your file. it works with vanilla GHCi too. theoretically you could use this, put it on a package on hackage and someone could use your library without knowing it
07:06:38 <chrisdone> was written in a lispy way
07:07:26 <hpc> Phyx-: i suspect it has something to do with 'c' being inside the function parameters
07:07:36 <FunctorSalad> Phyx-: that looks like \g f -> inverse g . f 
07:07:42 <hpc> try writing (c, b) -> (a, c) -> (a, b)
07:08:06 <FunctorSalad> nevermind
07:08:10 <hpc> see if that narrows down the problem
07:08:14 <FunctorSalad> it's just (.) with nonstandard var names
07:08:51 <Saizan> chrisdone: so it's just syntactic sugar? or does it come with a macro system?
07:08:56 <chrisdone> joe6: it's a mere rewriting to Haskell. (. f g b) is rewritten to f . g . b, so associativity of the operator is preserved
07:08:57 <Saizan> fsvo sugar
07:09:03 <Phyx-> FunctorSalad: yeah, my naming convention is different. I just name them on order of the fresh var count
07:09:08 <chrisdone> Saizan: it will come with defmacro and reader macros, yes
07:09:22 <Phyx-> hpc: It's my generalisation that eats it whole.. it goes in, doesn't come out
07:09:43 <FunctorSalad> @ty \g f x -> g (f x)
07:09:44 <lambdabot> forall t t1 t2. (t1 -> t2) -> (t -> t1) -> t -> t2
07:09:50 <FunctorSalad> hmm
07:10:10 <FunctorSalad> seems like it numbers them inside-out
07:10:16 <Saizan> generalization is the work of the devil
07:10:27 <Saizan> no wonder it eats baby type variables
07:10:32 <Phyx-> FunctorSalad: yeah, and I do it the easier way
07:10:33 <hpc> Phyx-: the hacky way would be to omit the outer-level foralls until the very end, and add them to any unquantified variables at the end
07:10:33 <FunctorSalad> nom nom nom
07:10:51 <hpc> not sure how that would interact with higher ranked types and existentials though
07:11:44 <Phyx-> hpc: I'm actually gonna revert... I had it working before, lol
07:11:48 <hpc> chrisdone: could you mix lispy style with haskell code in the same file?
07:12:12 <chrisdone> hpc: sure. would you want to do that?
07:12:26 <Phyx-> FunctorSalad: i get something like (a13 -> a10) -> (a6 -> a13) -> a6 -> a10 and then i rename
07:12:33 <Phyx-> you can see where my convention comes from then
07:12:35 <hpc> chrisdone: sure; if you have functions that look nicer one way or the other
07:13:01 <hpc> also, i would suggest it be granular to functions, so you don't have complex parsing
07:13:11 <hpc> it would be confusing to mix styles mid-function anyway
07:13:17 <chrisdone> hpc: sure. that's trivial to do
07:13:19 <chrisdone> hpc: heh, yeah
07:14:22 <chrisdone> hpc: mostly I'm sick of haskell's syntax. indentation-based editing with operator spaghetti is just a chore for me to edit, I spend more time figuring out the syntax than thinking about the logic. so for me the intent is to use it solo
07:15:00 <lars9> lol, liskell.org's front page is a big ads
07:15:15 <hpc> i like the whitespace sensitivity
07:15:24 <hpc> it puts an upper bound on the hideousness of code
07:15:45 <chrisdone> hpc: I think for any nontrivial code that is untrue
07:16:13 <chrisdone> hpc: for example ...
07:16:42 <FunctorSalad> Saizan: curious, what is devilish about it?
07:18:29 <Saizan> FunctorSalad: i was joking, though it tends to not mix well with more advanced type systems
07:22:17 <ezyang> Python decorators are a crappy approximation of higher order functions >:-( 
07:22:39 <chrisdone> hpc: http://hpaste.org/41464/code
07:23:00 <FunctorSalad> regarding the ongoing function serialization debate... could one use TH to generate concrete closures?
07:23:53 <hpc> ew; that can definitely be improved by more sane combinators
07:24:41 <hpc> http://hpaste.org/paste/41464/better#p41465
07:25:05 <FunctorSalad> e.g. explCl [d| add (g,f) x = g x + f x |] would translate to something like "data Add_Closure = Add_Closure (Int -> Int, Int -> Int); add = Add_Closure; instance Apply Int Int Add_Closure where ..."
07:25:14 <FunctorSalad> uncurried for simplicity
07:25:38 <Saizan> happstack-state does basically that
07:25:43 <FunctorSalad> though that's a bad example because the Int->Ints themselves aren't serializable :p
07:26:17 <Saizan> there's a mkMethods macro that given names of the "methods" creates thode datatypes
07:26:20 <Saizan> *those
07:26:31 <FunctorSalad> ah. haven't seen it
07:27:05 <Saizan> it's coupled with the whole serialization engine
07:28:43 <McManiaC> lol
07:28:57 <McManiaC> I can't see how lisp is supposed to be any more readable than haskell :>
07:29:58 <Saizan> see, you don't have to read lisp because it has no syntax
07:30:22 <Saizan> in fact you don't write a lisp parser, the String magically transmutes into the ast
07:30:30 <McManiaC> :>
07:30:31 <chrisdone> hpc: but disregarding beauty, I find it easier to edit, and you can merely write out your EDSL instead of battling issues like the blazehtml you see in mine
07:31:04 <joe6> Twey: thanks, I got it. it took me this long to work through it, hence the delay. Thanks a lot,agaun
07:31:12 <joe6> s/agaun/ again/
07:32:49 * hackagebot conductive-base 0.2 - a library for livecoding and real-time musical applications  http://hackage.haskell.org/package/conductive-base-0.2 (RenickBell)
07:32:53 <chrisdone> hpc: e.g. when you're within parentheses in lisp, there's only one possible indentation. in haskell, you have the tab cycle. and you spend your time, or at least I do, trying to avoid parentheses but half of the time you need to put them anyway
07:33:11 <McManiaC> I love blazehtml, and without qualified imports I find it very readable: https://github.com/mcmaniac/happstack-auth/blob/master/demo/Templates.hs
07:33:38 <hpc> McManiaC: that looks a lot like mine
07:33:49 * hackagebot conductive-hsc3 0.1.1 - a library with examples of using Conductive with hsc3  http://hackage.haskell.org/package/conductive-hsc3-0.1.1 (RenickBell)
07:34:40 <joe6> let messages = filter (\x -> (/=) Comment (msgtype x)) . zipWith parse [1..] $ lines contents
07:34:43 <joe6> msgtype (Message mtype _ _) = mtype
07:34:50 <joe6> i feel I could write that filter better. 
07:35:02 <joe6> just wanted to check if you have any thoughts, please?
07:35:10 <hpc> @pl (\x -> (/=) Comment (msgtype x)
07:35:10 <lambdabot> (line 1, column 32):
07:35:10 <lambdabot> unexpected end of input
07:35:10 <lambdabot> expecting variable, "(", operator or ")"
07:35:19 <hpc> @pl (\x -> (/=) Comment (msgtype x))
07:35:19 <lambdabot> (Comment /=) . msgtype
07:35:28 <Twey> joe6: filter ((/= Comment) . msgtype)
07:35:46 <McManiaC> chrisdone: in vim, I dont have tabcycles ;)
07:35:49 <McManiaC> :D
07:35:53 <joe6> hpc: that is brilliant. I should start using lambdabot for lambda functions.
07:36:02 <joe6> Twey: thanks.
07:36:37 <joe6> @pl (\x -> (/=) Comment (msgtype x))
07:36:37 <lambdabot> (Comment /=) . msgtype
07:36:58 <chrisdone> (and I really do hate typing upper case in variable/type names)
07:36:59 <aristid> \x -> Comment /= msgtype x
07:37:04 <joe6> i find it easier to use lambda functions, instead of searching for functions that match what I want to do with hoogle.
07:37:04 <aristid> would be an improvement, too
07:37:32 <joe6> maybe I could just put together the program and use @pl to convert to pointfree style.
07:37:38 <joe6> do you guys do that ?
07:37:47 <Saizan> no
07:37:48 <hpc> pointfree is easy to make nasty
07:37:57 <hpc> @pl \a b c d e f g -> g a d b c e
07:37:57 <lambdabot> ((((((const .) . flip) .) .) . flip . (flip .)) .) . flip . (flip .) . flip . flip id
07:38:00 <Saizan> most of the time @pl gives you something horrible
07:38:06 <Twey> joe6: Please don't
07:38:09 <joe6> oh, ok.
07:38:09 <Saizan> even when there's a nice pointfree version
07:38:20 <Twey> Yeah
07:38:24 <Twey> @pl rarely generates the nicest form
07:38:24 <lambdabot> rarely generates the nicest form
07:38:30 <hpc> haha
07:38:31 * Twey thwaps lambdabot.
07:38:41 <Twey> That's not a function!
07:38:47 <chrisdone> point-free pretty much only makes sense when you have a case like (\x -> f g b .. $ x)
07:38:47 <aristid> Twey: sure is
07:39:03 <paolino> hello, I have a Test module with main  = quickCheck something, it builds fine with ghc --make but cabal build fails with "No instance for (Testable (Gen Bool)"
07:39:04 <Saizan> but, anyhow, lambda expressions are perfectly good ways to glue together some functions
07:39:31 <Saizan> chrisdone: more like \x -> f (g (b (... x)))
07:39:46 <chrisdone> Saizan: woops, I meant f (g (b ..
07:39:54 <Twey> chrisdone: Strong disagreement
07:39:54 <Twey> It's often possible to rewrite an expression into such a form and have it come out looking lovely
07:40:07 <chrisdone> like what?
07:40:25 <dcoutts__> paolino: if you run cabal configure -v it'll tell you which package versions it's using
07:41:16 <paolino> dcoutts__ selecting QuickCheck-1.2.0.0 (installed) and discarding QuickCheck-2.1.1.1
07:41:24 <Twey> chrisdone: Like the above: http://hpaste.org/41462/twey
07:41:40 <dcoutts__> paolino: perhaps you want to use version 2 then
07:42:08 <paolino> dcoutts__ , right. Why it choosed the 1.2.0.0 ?
07:42:30 <aristid> @pl x, y) -> (x, concatMap y [Message Setup 1 "string"])
07:42:30 <lambdabot> (line 1, column 2):
07:42:30 <lambdabot> unexpected ","
07:42:30 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
07:42:33 <aristid> @pl (x, y) -> (x, concatMap y [Message Setup 1 "string"])
07:42:33 <lambdabot> (line 1, column 8):
07:42:33 <lambdabot> unexpected ">" or "-"
07:42:34 <lambdabot> expecting variable, "(", operator or end of input
07:42:37 <aristid> @pl \(x, y) -> (x, concatMap y [Message Setup 1 "string"])
07:42:37 <lambdabot> second ($ Message Setup 1 "string")
07:42:46 <dcoutts__> paolino: not sure, add --constraint='quickcheck >= 2' and find out
07:42:47 <aristid> Twey: lambdabot generates a nicer version.
07:43:05 <hpc> @pl \x y -> [a + b | a <- x, b <- y
07:43:05 <lambdabot> (line 1, column 9):
07:43:05 <lambdabot> unexpected "["
07:43:05 <lambdabot> expecting lambda abstraction or expression
07:43:09 <hpc> @pl \x y -> [a + b | a <- x, b <- y]
07:43:09 <lambdabot> (. (return . (b <-))) . (:) . (a +) . ((b | a) <-)
07:43:18 <aristid> hpc: haha. not nice.
07:43:50 <hpc> oh wait, it just can't understand comprehensions
07:44:08 <hpc> @pl \x y -> do a <- x; b <- y; return a+b
07:44:08 <lambdabot> (line 1, column 18):
07:44:08 <lambdabot> unexpected ";"
07:44:08 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
07:44:08 <aristid> yeah looks like it
07:44:11 <hpc> @pl \x y -> do a <- x; b <- y; return a+b;
07:44:11 <lambdabot> (line 1, column 18):
07:44:11 <lambdabot> unexpected ";"
07:44:11 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or end of input
07:44:17 <Twey> aristid: Nicer but wrong
07:44:20 <chrisdone> Twey: yeah, I use `second' all the time. I was thinking more like when you get past (f .) . g territory it stops being straight-forward
07:44:20 <lars9> @pl (+) <$> x <*> y
07:44:21 <lambdabot> (+) <$> x <*> y
07:44:22 <paolino> dcoutts__ There is no available version of quickcheck that satisfies >=2,  Dependency QuickCheck -any: using QuickCheck-2.1.1.1
07:44:25 <hpc> pah
07:44:28 <aristid> Twey: what's wrong about it?
07:44:37 <hpc> lars9: ^^
07:44:53 <Twey> aristid: It's not the same expression
07:45:03 <Twey> I think it assumed the monad was the function monad
07:45:07 <chrisdone> aristid: concatMap /= ($)
07:45:07 <dcoutts__> paolino: perhaps I'm forgetting, I didn't think it was case sensitive
07:45:18 <Twey> No
07:45:23 <Twey> That's the pre->>= version
07:45:29 <Twey> I don't even know how it got there, then
07:45:41 <Twey> Moral of the story: don't trust @pl ;)
07:46:17 <aristid> Twey: i thought it removes the (>>=) because it's unnecessary due to the fact that the input list is single-element
07:46:17 <McManiaC> hpc: http://npaste.de/pe/ :D
07:46:33 <chrisdone> @pl \(x, y) -> (x, concatMap y 1)
07:46:33 <lambdabot> second (1 >>=)
07:46:34 <lars9> it's a pain to read code with ----> ===> :->:
07:46:36 <Twey> chrisdone: Eh, nice â‰  straight-forward, necessarily
07:46:36 <aristid> :t (>>=) . return
07:46:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> (a -> m b) -> m b
07:46:44 <Twey> aristid: Ahh, yeah, that could be it
07:46:47 <hpc> McManiaC: whoa, never knew about that
07:46:47 <Twey> Yeah, fair
07:47:02 <Twey> Silly me for not spotting that
07:47:02 <McManiaC> hpc: I'm currently working on that :)
07:47:04 <aristid> Twey: so i think it is correct :)
07:47:08 <McManiaC> hpc: far from being ready to use
07:47:11 <hpc> McManiaC: ah
07:47:20 <joe6> gotta give it to haskell, the programs become so simple that at the end of it all, all you see is data, the code just seems to disappear.
07:47:26 <Twey> chrisdone: There was an expression I PL'd a little while back that had a rather complicated PL'ing process, but came out quite simple and nice at the end
07:47:41 <joe6> the code : data is approximately 50:50.
07:48:12 <joe6> atleast in the main function.
07:48:43 <chrisdone> most of my code is point free. but it's all usually the same flavour, or may it just seems that way because I'm used to it
07:48:53 <Twey> Oh, that was it
07:48:56 <Twey> chrisdone: http://hpaste.org/41066/pointfree_derivation
07:49:25 <paolino> dcoutts__ it worked, thanks
07:49:36 <chrisdone> Twey: http://hpaste.org/paste/41462/pointfree#p41466
07:49:51 <aristid> Twey: the original looks much nicer than the final version
07:50:01 <McManiaC> hpc: http://hackage.haskell.org/trac/ghc/ticket/4370
07:50:20 <chrisdone> Twey: I find the original easier to understand
07:50:37 <hpc> McManiaC: oh man, SQL comprehensions :D
07:50:46 <aristid> :t \f a b -> liftM2 f (a `mplus` b) (b `mplus` a)   
07:50:47 <lambdabot> forall a1 r (m :: * -> *). (MonadPlus m) => (a1 -> a1 -> r) -> m a1 -> m a1 -> m r
07:51:01 <chrisdone> the derivation is easy to follow, but it's hard in reverse
07:51:08 <McManiaC> hpc: :)
07:51:17 <joe6> @pl (\(file,getcontent) -> appendFile file $ concatMap getcontent messages)
07:51:17 <lambdabot> uncurry ((. (messages >>=)) . appendFile)
07:51:38 <aristid> :t liftM on liftM2
07:51:40 <lambdabot> forall a a2 r (m :: * -> *). (Monad m) => (a2 -> a2 -> r) -> (a -> m a2) -> a -> a -> m r
07:51:45 <Twey> chrisdone: I'd go with (format -> line, msg) = join (***) unlines . splitAt 1 . lines $ show err
07:51:45 <aristid> :t liftM `on` liftM2
07:51:46 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
07:51:47 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
07:51:47 <lambdabot>     In the second argument of `on', namely `liftM2'
07:51:52 <aristid> :t liftM2 `on` liftM2
07:51:53 <lambdabot>     Occurs check: cannot construct the infinite type: a2 = a2 -> a21
07:51:53 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
07:51:53 <lambdabot>     In the second argument of `on', namely `liftM2'
07:53:05 <Twey> chrisdone: Not for meâ€¦ just add each argument in separately
07:53:09 <Twey> I see it as sort of shunting back through the composition chain, a bit like a Newton's cradle :Ã¾
07:53:33 <Twey> Until you get to the beginning, and then you add another argument
07:53:39 <chrisdone> maybe you would like Factor
07:53:52 <Twey> I do like Factor
07:53:54 <Twey> â˜º
07:54:05 <chrisdone> figures
07:54:08 <Twey> (not that it's really the same thing)
07:55:51 <Twey> chrisdone: Actually, that derivation process in reverse is pretty much exactly what goes through my head when I read it
07:55:55 <Twey> I just realised
07:56:08 <Twey> Except each new argument is a single step
07:56:48 <chrisdone> the top one is higher level to me
07:57:06 <Botje_> I've liked what i saw of factor so far.
07:57:12 <chrisdone> it's essentially: f (a * b) (b * a)
07:57:44 <hpc> :t liftM2 `on` liftM
07:57:45 <lambdabot> forall a2 a1. (a1 -> a1) -> (a1 -> a1) -> ((a2 -> a1) -> a2) -> (a2 -> a1) -> a1
07:57:49 <lars9> @pl (,) <$> x <*> y
07:57:49 <lambdabot> (,) <$> x <*> y
07:57:57 <chrisdone> hpc: I was thinking about on too
07:58:26 <lars9> > let x = [1..3], y = [5..7] in (,) <$> x <*> y
07:58:27 <lambdabot>   <no location info>: parse error on input `,'
07:58:33 <lars9> > let x = [1..3]; y = [5..7] in (,) <$> x <*> y
07:58:34 <lambdabot>   [(1,5),(1,6),(1,7),(2,5),(2,6),(2,7),(3,5),(3,6),(3,7)]
07:58:46 <chrisdone> bothOn f g x y = f (g x y) (g y x)
07:58:46 <chrisdone> \f a b -> liftM2 f (a `mplus` b) (b `mplus` a)   
07:59:00 <hpc> :t (<*)
07:59:01 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f b -> f a
07:59:02 <chrisdone> bothOn (liftM2 f) mplus
07:59:20 <lars9> > let x = [1..3]; y = [5..7] in (,,) <$> x <*> y <*> x
07:59:21 <lambdabot>   [(1,5,1),(1,5,2),(1,5,3),(1,6,1),(1,6,2),(1,6,3),(1,7,1),(1,7,2),(1,7,3),(2...
07:59:55 * hackagebot shpider 0.1.0 - Web automation library in Haskell.  http://hackage.haskell.org/package/shpider-0.1.0 (JohnnyMorrice)
08:01:15 <chrisdone> Twey: although the last one has a certain SKI-calculus "look no hands ma" beauty to it, do you think it's actually clearer than the first step?
08:01:39 <Twey> There's not much difference in clarity to me
08:02:16 <Twey> The liftM2 already makes me engage my â€˜look a little deeperâ€™ mode
08:02:20 <chrisdone> I think you'd generalize it to something like, bothOn (liftM2 f) mplus, but with a better name than bothOn
08:02:20 <Twey> I guess it's a pretty binary thing
08:02:45 <Twey> Yeah, it definitely needs a name
08:03:32 <aristid> :t \f a b -> f <$> (a <|> b) <*> (b <|> a)  
08:03:33 <lambdabot> forall a b (f :: * -> *). (Alternative f) => (a -> a -> b) -> f a -> f a -> f b
08:03:34 <chrisdone> Twey: I like these two, although I haven't thought of a better name for the second yet
08:03:37 <chrisdone> :t bi f g = f . g . f
08:03:38 <lambdabot> parse error on input `='
08:03:44 <chrisdone> bah
08:03:52 <chrisdone> @let bi f g = f . g . f
08:03:53 <lambdabot>  Defined.
08:03:55 <chrisdone> @let co f g = f g . g
08:03:56 <lambdabot>  Defined.
08:04:09 <aristid> @pl \f a b -> f <$> (a <|> b) <*> (b <|> a) 
08:04:09 <lambdabot> (. ap (ap . ((<*>) .) . (<|>)) (flip (<|>))) . (.) . (<$>)
08:04:40 <Twey> Hmm
08:04:48 <Twey> @pl \f g -> f g . g
08:04:48 <lambdabot> ((.) =<<)
08:04:51 <chrisdone> > bi reverse (dropWhile isSpace) "hi "
08:04:53 <lambdabot>   "hi"
08:05:09 <aristid> :t co
08:05:10 <lambdabot> forall (f :: * -> *) a b. (Functor f) => (f a -> a -> b) -> f a -> f b
08:05:41 <chrisdone> > let trim = co (bi reverse) (dropWhile isSpace) in trim "  hello  "
08:05:42 <lambdabot>   "hello"
08:05:47 <aristid> :t co :: ((e -> a) -> a -> b) -> e -> a -> b
08:05:48 <lambdabot>     Occurs check: cannot construct the infinite type: e = e -> a
08:05:48 <lambdabot>     In the expression: co :: ((e -> a) -> a -> b) -> e -> a -> b
08:05:56 <chrisdone> admittedly bi and co only came about from wanting to write `trim' :-P
08:06:16 <chrisdone> `bi' turns out to be bijection. but co, I don't know what the category theoretical concept is, if any
08:06:21 <Twey> bi f = (.) f . flip (.) f
08:07:24 <Twey> Hey look, it's our bothOn again
08:09:28 <aristid> :t let co f g = f g Prelude.. g in co
08:09:29 <lambdabot> forall a b c. ((a -> b) -> b -> c) -> (a -> b) -> a -> c
08:10:06 <lars9> @src (<|>)
08:10:06 <lambdabot> Source not found.
08:10:13 <chrisdone> Twey: can you express bothOn with bi?
08:10:57 <jmcarthur> ksf: ACK. but i can't say i'm a GL guru by any stretch
08:11:28 <chrisdone> I think they're different
08:11:44 <jmcarthur> ksf: GPipe's implementation is indeed messy. it manipulates the syntax tree as merely a collection of strings and stuff, iirc
08:11:52 <jmcarthur> it's still nice though, overall
08:13:37 <Twey> Not nicely, but you can express bi with bothOn
08:17:54 <ClaudiusMaximus> jmcarthur, ksf: i'd also be interested in a nice AST-ful Language.GLSL or whatever, maybe interested enough to help contribute (in a couple of weeks, after current commitments are over), i've done some GLSL things with string collections and it's painful...
08:18:01 * hackagebot shpider 0.1.1 - Web automation library in Haskell.  http://hackage.haskell.org/package/shpider-0.1.1 (JohnnyMorrice)
08:20:36 <unkanon> does lambdabot does anything hoogle-ish?
08:20:55 <unkanon> can I pass it a type signature and get back a function that already does that?
08:20:57 <gds> @hoogle Int -> Int
08:20:58 <lambdabot> Test.HUnit.Base ListItem :: Int -> Node
08:20:58 <lambdabot> Data.Time.Calendar gregorianMonthLength :: Integer -> Int -> Int
08:20:58 <lambdabot> Data.Time.Calendar.Julian julianMonthLength :: Integer -> Int -> Int
08:21:16 <unkanon> gds: thanks. because hoogle seems to be down now
08:21:49 <companion_cube> why is haskell.org so often down ?
08:22:41 <roconnor> companion_cube: the server is written in haskell
08:22:44 <roconnor> :P
08:22:50 <companion_cube> hmmmm
08:22:52 <unkanon> aww that's mean
08:22:59 <joe6> @pl mapM_ (\(file,getcontent) -> appendFile file $ concatMap getcontent messages)
08:22:59 <lambdabot> mapM_ (uncurry ((. (messages >>=)) . appendFile))
08:23:03 <roconnor> actually I expect haskell.org is running apache
08:23:19 <roconnor> so the answer is that the server isn't written in Haskell :D
08:23:29 <unkanon> that sounds better :)
08:26:05 <Twey> Should've used Snap
08:27:04 <unkanon> I was all excited that I came up with the <$> by myself, but they define it as simply f <$> a = fmap f a while I came up with the verbose shove f x = x >>= return . f
08:27:43 <unkanon> @pl x >>= return . f
08:27:43 <lambdabot> f `fmap` x
08:27:51 <hpc> heh
08:27:52 <unkanon> :))
08:28:05 <unkanon> @unpl fmap f x
08:28:05 <lambdabot> fmap f x
08:28:11 <unkanon> it can't go back...
08:29:05 <unkanon> oh! now I understand so many things...
08:29:12 <unkanon> @src IO fmap
08:29:12 <lambdabot> fmap f x = x >>= (return . f)
08:29:31 <hpc> heh
08:29:56 <unkanon> I can really feel my brain tickle now
08:30:34 <hpc> i think there's a pill for that ;)
08:30:35 <FunctorSalad> roconnor: didn't someone say it's an issue with the physical building where the server is located?
08:30:36 <Twey> fmap f x = x >>= return . f -- for any reasonable Monad
08:30:40 <FunctorSalad> power or something
08:31:01 <unkanon> Twey: yes, for any monad, it's just that I can't ask lambdabot to do @src fmap
08:31:08 <unkanon> I have to specify which fmap
08:31:09 <Saizan> FunctorSalad: that was for hackage
08:31:17 <FunctorSalad> oh
08:31:21 <roconnor> @faq can a sever written in haskell keep working while it is being moved from building to building?
08:31:21 <lambdabot> The answer is: Yes! Haskell can do that.
08:31:24 <Twey> @unpl f `fmap` x
08:31:24 <lambdabot> (fmap f x)
08:31:50 <Saizan> haskell.org is hosted at yale iirc
08:32:18 <unkanon> Twey: were you also expecting that it @unpl fmap f x would give you x >>= return . f ?
08:34:05 <Twey> unkanon: Well, I saw that you did:
08:34:05 <Twey> 16:27:48 < unkanon> @unpl fmap f x
08:34:05 <Twey> Which was not quite what @pl gave you
08:34:05 <Twey> I figured perhaps if it were expressed precisely as given, it might figure it out
08:35:38 <Botje_> roconnor: heh. i've done that once before
08:35:42 <Botje_> server + cart + ups = win!
08:35:49 <unkanon> Twey: I see. do you have a clue why it won't get to the definition we're looking for?
08:36:04 <Botje_> of course it was moderately confused that every its IP addresses were changed, but it survived just fine
08:38:34 <Twey> unkanon: Well, because it's useless :Ã¾
08:38:52 <Twey> Botje_: Haha, wifi?
08:39:06 <monadic_kid> anyone recognize this message from ghc: "mkUsageInfo: internal name? r{tv aiC}"
08:39:46 <unkanon> Twey: should fmap f x = x >>= return . f also for the List monad? because fmap = map for lists and map is quite different from that
08:40:12 <Botje_> Twey: ethernet :P
08:40:39 <unkanon> Twey: I guess what I mean is that that first definition doesnt look like it will walk the list like map does
08:41:06 <Twey> unkanon: No it isn't
08:41:19 <Twey> > map (+ 1) [1 .. 5]
08:41:20 <lambdabot>   [2,3,4,5,6]
08:41:22 <unkanon> Twey: so is List not a reasonable monad?
08:41:38 <Mitar> how can I mix forall and Show constraint on a type of a function?
08:41:53 <ezyang> Mitar: In what way? 
08:42:01 <ezyang> For example Show a => a is implicitly forall a. Show a => a 
08:42:03 <unkanon> Mitar: (Show a) => a -> ()
08:42:17 <Twey> > [1 .. 5] >>= return . (+ 1)
08:42:18 <lambdabot>   [2,3,4,5,6]
08:42:25 <Mitar> i have currently: forall a a' c c' d. Nerve (Chan a) a' AxonConductive c c' d -> [Translatable a'] -> IO ()
08:42:40 <Twey> unkanon: List behaves just fine.
08:42:41 <Mitar> and it is telling me: Ambiguous type variable `a'' in the constraint:
08:42:41 <Mitar>       `Show a'' arising from a use of `attach' at Test.hs:74:7-25
08:42:59 <unkanon> Twey: but... how is it walking the list?
08:43:09 <Twey> unkanon: (>>=) = concatMap
08:43:11 <Twey> Er
08:43:13 <Twey> unkanon: (>>=) = flip concatMap
08:43:21 <Twey> return = (: [])
08:43:35 <unkanon> @src [] (>>=)
08:43:35 <lambdabot> xs >>= f     = concatMap f xs
08:43:42 <Saizan> Mitar: you can write e.g. "forall a a' c c' d. Show a' => ..." 
08:43:58 <Twey> > concatMap ((: []) . (+ 1)) [1 .. 5]
08:43:59 <lambdabot>   [2,3,4,5,6]
08:44:04 <Twey> > map ((: []) . (+ 1)) [1 .. 5]
08:44:05 <lambdabot>   [[2],[3],[4],[5],[6]]
08:44:26 <unkanon> Twey: I have to think about that
08:44:44 <unkanon> Twey: so then concatMap does the walking? 'cause somebody has to walk...
08:44:48 <unkanon> @src [] concatMap
08:44:49 <lambdabot> Source not found. You speak an infinite deal of nothing
08:44:51 <unkanon> @src concatMap
08:44:52 <lambdabot> concatMap f = foldr ((++) . f) []
08:44:57 <unkanon> oh there we go
08:45:22 <unkanon> ok I get it now
08:45:25 <unkanon> Twey: thanks :)
08:47:03 <Mitar> didn't work
08:48:31 <Twey> unkanon: concatMap f = concat . map f
08:48:36 <Mitar> but i just removed Show constraint everywhere and it seems it works now ;-)
08:49:51 <xarch> = join (fmap f) for lists :}
08:50:43 <unkanon> Twey: right because concat is foldr with just the ++
08:51:36 <Twey> Yep
08:51:43 <Twey> xarch: Not just for lists
08:51:53 <Twey> xarch: That holds for all well-behaved monads, too
08:52:07 <unkanon> I dont understand what xarch said
08:52:17 <xarch> yeah I know
08:52:22 <Twey> unkanon: join :: m (m a) -> m a
08:52:36 <Twey> It's the fundamental monad operation, from a theoretical perspective (not as implemented in Haskell, though)
08:53:11 <Twey> In Haskell, join is implemented in terms of >>= (join = (>>= id))
08:53:13 <orlandu63> join == concat in regards to Lists i thhink
08:53:18 <Twey> Yep
08:53:24 <unkanon> Twey: so join a = a >>= \x -> x
08:53:38 <unkanon> Twey: is that a bad thing that it's implemented in terms of bind?
08:54:19 * hackagebot sox 0.2.0.2 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.0.2 (HenningThielemann)
08:54:39 <Twey> unkanon: Yes; not necessarily
08:56:25 <Twey> unkanon: AFAIK, it's implemented with bind for two reasons: 1) Haskell has/had no class aliases or mandatory Functor subclasses for Monads, and since both join and fmap can be implemented using bind, it saves some typing; and 2) >>= is the fundamental operation when using monads to implement sequencing, which is AFAIK the reason they were first introduced into Haskell (IO)
08:57:13 <joe6> so, does simon peyton jones hang around on this irc?
08:57:30 <Twey> Not really
08:57:36 <Twey> I don't think I've seen him on here
08:57:56 <Twey> We got esr in here once, though
08:58:02 <ddarius> Very occassionally.
08:58:03 <joe6> who is esr?
08:58:15 <ddarius> esr is esr
08:58:25 <unkanon> Twey: so they introduced monads in haskell solely/initially to deal with IO?
08:58:48 <Twey> Don't know how far he got
08:59:31 <Twey> unkanon: I'm not that old, but from what I've read it seems that way, yes
09:00:03 <ddarius> IO was a good motivating case, but they were certainly aware of the other uses.
09:00:22 <unkanon> Twey: from the presentation i've seen given by SPJ it seemed that way too
09:00:50 <xarch> is it possible to have explicit polymorphism with GHC?
09:01:03 <ezyang> xarch: Yes. 
09:01:53 <unkanon> it's funny that in that presentation SPJ says that the IO monad makes dealing with IO basically like giving World and getting back (a,World), which basicaly is implementing uniqueness like Clean did before (and still does)
09:01:55 <ezyang> try ExplicitForall 
09:02:02 <xarch> ok, thanks
09:28:34 <FunctorSalad> unkanon: hmm I think "let x = foo >> x" is equal to const _|_ if IO a = World -> (a,World)
09:29:09 <Rotaerk> what?
09:29:46 <FunctorSalad> I've just been unrelatedly thinking about whether there's any "safe" way to use the IO type other than its monad interface
09:30:10 <FunctorSalad> if not, that'd make the 'a monad is used for IO' 'myth' not so mythical
09:32:26 <FunctorSalad> context: I think Tony Morris's messages here http://stackoverflow.com/questions/327955/does-functional-programming-replace-gof-design-patterns are overstating the 'monads have nothing to do with IO' a bit
09:35:06 <FunctorSalad> Rotaerk: what what?
09:35:54 <Rotaerk> FunctorSalad, "let x = foo >> x" just looks like F#, and what you were saying it's equal to didn't make any sense
09:36:20 <Rotaerk> but if that's also a haskell thing nevermind :P
09:36:33 <opqdonut> "let x = foo >> x" means "let x = fix (foo>>)"
09:36:33 <hpc> the top answer to that question has an entertaining conflation of the pattern and the abstraction that eliminates it
09:36:54 <FunctorSalad> Rotaerk: it does make sense if we accept that IO a = World -> (a,World), as I said
09:37:26 <engla_> what does that mean?
09:37:28 <FunctorSalad> opqdonut: yes, and I think that that's const _|_ for any foo
09:37:39 <opqdonut> ?src State (>>)
09:37:39 <lambdabot> Source not found.
09:37:42 <opqdonut> ?src State (>>=)
09:37:42 <lambdabot> Source not found. You speak an infinite deal of nothing
09:37:48 <opqdonut> ?src (>>=) State
09:37:48 <lambdabot> Source not found. :(
09:37:51 <opqdonut> gah
09:38:15 <FunctorSalad> Rotaerk: I'm omitting the newtype here that would be needed to actually declare it a moand
09:38:20 <FunctorSalad> monad..
09:41:06 <aristid> @unmtl State s a
09:41:06 <lambdabot> s -> (a, s)
09:42:46 <bblum> is there a standard way to express a triple-disjunction? "data Any a b c = Up a | Middle b | Down c"
09:42:52 <Funktorsalat> re. disconnect
09:43:22 <bblum> or do i just have to hack up my own datatype like the one i just said
09:43:29 <Funktorsalat> bblum: like Either but triple? nope
09:43:44 <bblum> yeah, i mean, i found myself writing "Either (Either a b) c"
09:43:51 <bd_> bblum: Well, you _could_ nest Eithers, but really, at that point it's better to use your own datatype just for the descriptive constructors
09:44:07 <bblum> i guess descriptive constructors is the way to go
09:44:27 <bd_> Otherwise, where do you stop? data Builtin26Dijunction a b c d .... z = C1 a | C2 b | C3 c | .... | C26 z
09:44:35 <bd_> Disjunction even
09:45:34 <bblum> yeah, i mean, at that point you should get it built-in to the language dependent-type style
09:46:00 <bblum> it probably is better style to force the programmer to write descriptive constructors for it
09:46:05 <Funktorsalat> mkEither :: Int -> Q [Dec]
09:46:05 <Funktorsalat> ;)
09:46:32 <Funktorsalat> not that there's any real point to that
09:50:52 <unkanon> Funktorsalat: sorry I missed the discussion
09:52:12 <unkanon> Funktorsalat: it was just yesterday that I learned that _|_ means bottom and bottom means neverending computation, so I don't quite understand the implications of what you said, though I am very interested in your thoughts about monads really being meant for IO
09:52:36 <hpc> bottom means "oops" in all its forms
09:52:55 <hpc> it can mean nontermination, uncaught exception, nuclear holocaust, etc
09:53:00 <Funktorsalat> unkanon: I mean it's sort of an absurd consequence of IO a = World -> (a,World)
09:53:26 <Funktorsalat> because clearly we can't substitute let x = putStrLn "hai" >> x with const _|_ :)
09:53:42 <Funktorsalat> or IO (const _|_) if someone insists on the newtype :p
09:54:13 <bblum> what does const mean at the type level?
09:54:18 <Funktorsalat> (I'm also assuming that IO would have the same monad instance as State RealWorld)
09:54:29 <Funktorsalat> bblum: this is value-level :)
09:54:45 <bblum> err, then why not say 'undefined'?
09:55:13 <Funktorsalat> well, like hpc said essentially
09:55:42 <Funktorsalat> _|_ is a denotation for when you're talking about programs, 'undefined' is just one possible way to obtain _|_ semantics
09:55:51 <Funktorsalat> 'fix id' is anotehr
09:55:52 <Funktorsalat> *another
09:56:16 <hpc> fix id is a funny one
09:56:26 <hpc> on my computer it uses zero memory and zero cpu
09:56:39 <opqdonut> ghc's loop detection
09:56:44 <hpc> haha
09:56:48 <hpc> awesome
09:56:54 <c_wraith> well, if you're using the threaded runtime, anyway.
09:57:08 <c_wraith> it should dump <<loop>> and terminate the program in the non-threaded runtime
09:57:08 <Funktorsalat> as I understand it it comes for free as a consequence of how closures work in stg
09:57:18 <Funktorsalat> (disclaimer: I just read a little bit of that paper)
09:57:33 <ezyang> Right, when someone starts evaluating a closure we overwrite it with a "blackhole" closure so other threads don't try to evaluate it too. 
09:57:58 <ezyang> I like data as closures. It's very nifty. 
09:58:08 <unkanon> hpc: oh, I thought it was just nontermination... I learned it from the haskell lectures at channel 9 (microsoft)
09:58:09 <Funktorsalat> ("for free" as in "no overhead", not "no programming effort" :))
09:59:41 <unkanon> what is fix used for?
10:00:06 <Funktorsalat> for reference, this it the definition in GHC.Types:
10:00:07 <hpc> fix is used for awesomeness
10:00:08 <Funktorsalat> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
10:00:31 <hpc> also for some neat infinite structures
10:00:38 <hpc> > fix (1:)
10:00:39 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
10:00:57 <unkanon> > fix (1+)
10:01:01 <lambdabot>   mueval-core: Time limit exceeded
10:01:01 <LegendaryPenguin> still dont get why fix (1:) makes a list
10:01:12 <Funktorsalat> but can you actually take an IO apart (as opposed to using >>=) without breaking purity?
10:01:17 <hpc> LegendaryPenguin: consider this
10:01:25 <Funktorsalat> (of course you can, I mean "and do something with the RealWorld")
10:01:31 <hpc> fix (1:) = 1:(fix (1:))
10:01:33 * unkanon watches attentively
10:01:43 <hpc> so say we want the head of our infinite list
10:01:50 <hpc> we get that first element, and don't evaluate the rest
10:01:58 <unkanon> > take 4 (fix (1:))
10:01:59 <lambdabot>   [1,1,1,1]
10:02:11 <hpc> if we want to grab the whole list, we won't terminate
10:02:21 <hpc> but you can get any initial section without evaluating the rest
10:02:36 <unkanon> is there a way to get [1,2,3,4...] with fix?
10:02:59 <Funktorsalat> > fix (const [1..])
10:03:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:03:03 <Funktorsalat> ;)
10:03:05 <hpc> Funktorsalat: lol
10:03:13 <opqdonut> :D
10:03:17 <hpc> i forgot you can break out with const :D
10:03:18 <unkanon> Funktorsalat: but now I have to ask what does const do
10:03:25 <opqdonut> ?src const
10:03:26 <lambdabot> const x _ = x
10:03:27 <hpc> const x _ = x
10:03:31 <unkanon> oh then that's cheating
10:03:36 <mreh> heh
10:03:36 <opqdonut> yep :)
10:03:39 <hpc> it is very cheating
10:03:42 <unkanon> hahah
10:03:49 <hpc> fix . const = id
10:04:08 <Funktorsalat> yes it's equivalent to how every non-recursive definition is a recursive definition ;)
10:05:01 <opqdonut> > fix (\xs -> 1:map (+1) xs)
10:05:02 <Funktorsalat> (of course you'd say 'not necessarily' rather than 'not' to make that accurate)
10:05:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:05:05 <opqdonut> ta-dah
10:05:13 * unkanon claps
10:05:32 <opqdonut> > fix ((1:) . map (+1)) -- point-free
10:05:33 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:06:21 <c_wraith> following fix with an explicit lambda is amusing.  It's kind of like undoing the fix.
10:06:42 <c_wraith> > let xs = 1 : map (+1) xs in xs
10:06:43 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:07:25 <opqdonut> yeah it's kinda beta-reduceable straight away
10:07:34 <unkanon> c_wraith: I understand how that's undoing it, but what's the point of having the fix function in the first place?
10:07:42 <opqdonut> for kicks
10:07:45 <opqdonut> why not
10:08:07 <opqdonut> most stuff _is_ clearer with a recursive let, but sometimes you want to be pointfree
10:09:06 <litb> hello folks
10:09:12 <litb> this channel is so much better than SO
10:09:23 <sipa1024> unkanon: to be able to write this:
10:09:24 <hpc> SO?
10:09:25 <dschoepe> unkanon: anonymous recursive functions are sometimes handy
10:09:26 <sipa1024> > fix ((1:) . scanl (+) 1)
10:09:27 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:09:32 <hpc> oh, stack overflow lol
10:09:32 <c_wraith> hpc: stack overflow
10:09:33 <LegendaryPenguin> is fix useful for anything
10:09:37 <LegendaryPenguin> other than confusing people
10:09:48 <dschoepe> > fix (\fact n -> if n <= 1 then 1 else n * fact (n-1)) 5
10:09:49 <lambdabot>   120
10:09:53 <hpc> :t scanl
10:09:54 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:10:02 <c_wraith> fix is an abstraction of generalized recursion.  So...  it's never necessary to use.
10:10:04 <unkanon> hmm
10:10:23 <Funktorsalat> LegendaryPenguin: theory (defining the meaning of recursive definitions)
10:10:52 <monochrom> "is fix useful" = "is lambda useful"
10:10:59 <Funktorsalat> and someone suggested the last time this topic came up that it can be useful by making the 'thing being recursified' first-class
10:11:10 <litb> :t (+)
10:11:11 <lambdabot> forall a. (Num a) => a -> a -> a
10:11:16 <litb> hmm
10:11:32 <sipa1024> litb: (+) is just the function corresponding to the + operator
10:11:37 <sipa1024> > (+) 3 5
10:11:38 <lambdabot>   8
10:11:38 <LegendaryPenguin> and it doesnt make any sense why let zeroes = 0 : zeroes comes out to be a list
10:11:42 <litb> oh
10:12:01 <LegendaryPenguin> if its an infinite structure, it isnt type checked or something?
10:12:15 <sipa1024> LegendaryPenguin: it type checks perfectly
10:12:28 <sipa1024> > let zeroes = 0 : zeroes
10:12:29 <lambdabot>   not an expression: `let zeroes = 0 : zeroes'
10:12:31 <sipa1024> @let zeroes = 0 : zeroes
10:12:32 <lambdabot>  Defined.
10:12:35 <sipa1024> :t zeroes
10:12:35 <monochrom> type checking and type inference do not require "unfolding" or "evaluating" or "executing" the expression
10:12:36 <lambdabot> forall t. (Num t) => [t]
10:12:37 <Funktorsalat> well the typesystem considered as a logic is circular logic, yes ;)
10:12:38 <litb> so scanl is just operating on the current list element and the next, and writes the result into the next list element, and then apply the same operation to the next and next next list element?
10:13:06 <Funktorsalat> assuming zeroes is of type [Int], 0 : zeroes is correctly of type [Int]
10:13:22 <Funktorsalat> (@ LegendaryPenguin )
10:13:35 <monochrom> and http://www.vex.net/~trebla/haskell/scanl.xhtml explains fix ((1:) . scanl (+) 1)
10:13:35 <sipa1024> litb: it's like foldl, but keeping all intermediate results
10:14:17 <aristid> > fix $ (1:) . scanl (+) 1
10:14:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
10:15:24 <Funktorsalat> LegendaryPenguin: it's similar to how "int foo(int x) { return foo(x); }" typechecks in C etc
10:15:34 <LegendaryPenguin> oh
10:16:11 <LegendaryPenguin> its kind of confusing
10:16:23 <monochrom> yeah, it's just recursive code, never had a type checking problem
10:16:26 <litb> sipa1024: ohh!
10:16:50 <jmcarthur> > foldl f z [a,b,c,d]
10:16:51 <lambdabot>   f (f (f (f z a) b) c) d
10:16:56 <jmcarthur> > scanl f z [a,b,c,d]
10:16:57 <lambdabot>   [z,f z a,f (f z a) b,f (f (f z a) b) c,f (f (f (f z a) b) c) d]
10:16:58 <monochrom> you know how to type z=0:z iff you know how to type z()=0:z()
10:17:36 <monochrom> in fact z()=0:z() should be harder to type, if anything
10:17:43 <spetrea-home> I read about the Y combinator and I wasn't as excited as the author was about it
10:17:50 <Funktorsalat> hehe
10:17:57 <monochrom> there is nothing exciting
10:17:57 <spetrea-home> I don't understand why
10:18:44 <aristid> > fix $ (a:) . scanl (+) b
10:18:45 <lambdabot>   [a,b,b + a,b + a + b,b + a + b + (b + a),b + a + b + (b + a) + (b + a + b),...
10:19:06 <Eduard_Munteanu> Well, the Y combinator is important.
10:19:11 <litb> :t fix
10:19:12 <lambdabot> forall a. (a -> a) -> a
10:19:32 <Funktorsalat> notice how that's the fallacy of circular logic ;)
10:19:33 <litb> ah that calls the function with its result all over again
10:19:33 <Eduard_Munteanu> As in remarkable.
10:19:37 <monochrom> @quote well-typed
10:19:37 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
10:19:43 <Funktorsalat> (the type of fix)
10:19:44 <monochrom> @quote well.*typed
10:19:44 <lambdabot> jmcarthur says: what you just typed isn't even well typed
10:19:47 <sipa1024> @src fix
10:19:47 <lambdabot> fix f = let x = f x in x
10:19:49 <spetrea-home> Eduard_Munteanu: why is it important ?
10:19:53 <Funktorsalat> reading "->" as "implies"
10:20:08 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml explains fix
10:20:10 <hpc> alternatively, fix f = f $ fix f
10:20:20 <Eduard_Munteanu> spetrea-home: because it allows you to write recursion without looking like recursion.
10:20:33 <spetrea-home> Eduard_Munteanu: ok, and why is that important ?
10:20:51 <Eduard_Munteanu> spetrea-home: it is when discussing lambda calculus.
10:21:07 <spetrea-home> is there something really serious one can do with lambda calculus ?
10:21:07 <Eduard_Munteanu> Not so much for the sugared syntax of most languages though.
10:21:16 <litb> where does fix get the initial argument from?
10:21:28 <monochrom> initial argument is not needed
10:21:29 <hpc> spetrea-home: instead of doing all the "okay, this is the function we are in, and this is how we are recurring and blah blah", we can say "this is what happens when we get a thing as an argument"
10:21:30 <sipa1024> spetrea-home: everything ;)
10:21:30 <Eduard_Munteanu> spetrea-home: yes, look at GHC's core, its internal, desugared form.
10:21:32 <hpc> then feed it itself
10:21:40 <Funktorsalat> litb: undefined
10:21:50 <Eduard_Munteanu> spetrea-home: basically GHC compiles your code to some lambda calculus.
10:21:55 <c_wraith> litb: it doesn't.  but the function you apply fix to *must* provide some output before looking at its argument for fix to be productive
10:22:06 <Funktorsalat> fix f = lim_{n -> infty} f^n undefined
10:22:09 <Funktorsalat> :)
10:22:33 <Funktorsalat> (the "limit" is with respect to "definedness" though, not numeric)
10:22:40 <litb> what if i give it    fix (unaryPlus)  
10:22:59 <c_wraith> > fix (+1) -- that function can't produce output without examining its input, so fix is non-productive
10:23:00 <Funktorsalat> you get undefined because unaryPlus undefined = undefined
10:23:03 <lambdabot>   mueval-core: Time limit exceeded
10:23:04 <Eduard_Munteanu> spetrea-home: much of the stuff from Haskell that looks like language features can actually be broken down to lambda calculus.
10:23:05 <monochrom> do you understand recursion?  <duck>
10:23:25 <spetrea-home> monochrom: yes I understand recursion
10:23:41 <Funktorsalat> (but e.g., 1:undefined isn't undefined, so fix (1:) works)
10:23:46 <spetrea-home> monochrom: what I don't understand is why lambda calculus or Y combinator are important
10:23:51 <litb> c_wraith: oh i see now. fix can use partial output of the function
10:24:01 <spetrea-home> Eduard_Munteanu: ok, and why does Haskell do that ?
10:24:02 <hpc> the general rule is, constructors can be fixed, but not functions
10:24:07 <hpc> kind of
10:24:08 <litb> is it defined how much output a function must give in order for fix be productive?
10:24:12 <monochrom> importance is subjectively assigned. I wouldn't try to understand other people.
10:24:17 <Funktorsalat> hpc: *strict* functions can't
10:24:24 <sipa1024> on natural numbers (data Nat = Z | S Nat), it is possible to have a fix (+1) that effectively evaluates to infinity, and can be compared in finite time to other Nat's
10:24:26 <danharaj> lambda calculus is a foundation for computing. the same way that the register machine is the foundation for other programming languages.
10:24:27 <c_wraith> > fix show
10:24:28 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
10:24:50 <hpc> without the escapes, fix show = """""""""""""""""""""""""""""...
10:25:06 <Eduard_Munteanu> spetrea-home: it makes more sense to represent language constructs in a simpler language you can reason about. You can prove stuff about it this way.
10:25:07 <aristid> hpc: the escapes are essential
10:25:18 <hpc> aristid: yeah, but it helps visualize it :P
10:25:21 <Funktorsalat> litb: f undefined /= undefined is a necessary condition
10:25:34 <Funktorsalat> (this property is the strict sense of 'nonstrict' ;))
10:25:36 <Eduard_Munteanu> spetrea-home: it also allows programmers to reason, for example see how 'do syntax' is desugared.
10:25:38 <litb> i take it because   show  returns a String starting with '"' that is what it gives
10:25:39 <hpc> as an unending sequence of opening quotes
10:25:47 <hpc> litb: exactly
10:26:20 <Eduard_Munteanu> spetrea-home: it's a lot better to know "do; a <- foo; bar a" desugars to "foo >>= bar" than to consider such stuff opaque.
10:26:28 <litb> Funktorsalat: oh
10:26:41 <litb> i slightly remember there is a "bottom" value here too somewhere
10:26:55 <litb> like it stops at the bottom value or such
10:26:58 <sipa1024> undefined is just one possible bottom value
10:27:04 <litb> oh
10:27:15 <Eduard_Munteanu> spetrea-home: also for Haskell compilers, lambda calculus is some sort of SSA.
10:27:16 <danharaj> bottom is represents a value you don't know or can't know.
10:27:19 <sipa1024> in fix, the initial argument is not exactly undefined
10:27:22 <aristid> fix id is another popular way to write bottom
10:27:31 <sipa1024> since undefined is some error value
10:27:33 <sipa1024> > undefined
10:27:34 <lambdabot>   *Exception: Prelude.undefined
10:27:35 <Funktorsalat> I was equating them here because 10 minutes ago someone asked 'why not just say "undefined"' ...
10:27:41 <aristid> > fix id
10:27:45 <lambdabot>   mueval-core: Time limit exceeded
10:27:45 <litb> p
10:27:49 <litb> oh i see now
10:27:50 <Eduard_Munteanu> You don't really need another SSA or internal representation for the compiler.
10:27:52 <Funktorsalat> sipa1024: so more accurately, I mean bottom, yes
10:28:13 <litb> so fix only works with functions that return lists or tuples
10:28:19 <danharaj> no
10:28:19 <aristid> Eduard_Munteanu: GHC does have an internal representation tho
10:28:25 <litb> and at least one element must have been output already
10:28:27 <monochrom> fix works with functions that return functions
10:28:37 <Funktorsalat> litb: the classical use of it is for a = b -> c
10:28:51 <danharaj> you can define, say, factorial with fix. What you normally do is build a sort of skeleton for the function, and then apply fix, and it gives you the function you want.
10:28:58 <Eduard_Munteanu> aristid: yeah, but it's trivial to convert between the two. It's more of a performance thingy, e.g. processing on text is slower.
10:29:06 <Funktorsalat> @let makeFact fact n = if n==0 then 1 else n * fact (n-1)
10:29:07 <lambdabot>  Defined.
10:29:09 <Eduard_Munteanu> Erm, easier if not trivial
10:29:10 <Funktorsalat> > fix makeFact 6
10:29:11 <lambdabot>   720
10:29:15 <revenantphx> I'm absolutely hopeless at studying.
10:29:28 <monochrom> this is because makeFact is also as non-strict as lists
10:29:32 <danharaj> :t makeFact
10:29:32 <revenantphx> I keep ending up back in front of my laptop working on my projects >_>
10:29:33 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
10:29:38 <danharaj> note the type of makeFact
10:29:44 <Funktorsalat> yes, makeFact undefined 0 = 1
10:29:45 <aristid> Eduard_Munteanu: i think GHC's "core" or how they call it, is also simplified and heavily desugared
10:29:55 <Funktorsalat> > makeFact undefined 0
10:29:56 <lambdabot>   1
10:30:13 <Eduard_Munteanu> I see.
10:30:23 <revenantphx> aristid: what amount of haskell is not implemented in haskell?
10:30:24 <Eduard_Munteanu> revenantphx: uh, I know how that feels.
10:30:27 <hpc> > makeFact id 100
10:30:28 <lambdabot>   9900
10:30:34 <revenantphx> like what comprises the functions that are exclusively C mapped or such.
10:30:35 <monochrom> makeFact bottom = (\n -> if n==0 then ....) /= bottom
10:30:38 <Funktorsalat> you can imagine factorial as a limit of ever more defined approximate factorial functions
10:30:40 <revenantphx> The "basics"
10:30:45 <aristid> revenantphx: um, don't ask me
10:30:49 <Funktorsalat> makeFact undefined, makeFact (makeFact undefined), ....
10:30:58 <danharaj> IO (most of it) is probably just calls to libc, like every other language, seq, anything that works with the runtime environment that is invisible from the semantic point of view
10:31:02 <revenantphx> :t (=)
10:31:02 <aristid> revenantphx: you could read the source code if you care that much
10:31:03 <lambdabot> parse error on input `='
10:31:08 <revenantphx> aristid: true
10:31:19 <hpc> at some point, makeFact stops being strict in fact
10:31:24 <hpc> so it doesn't try to evaluate deeper
10:31:40 <danharaj> > makeFact (makeFact undefined)
10:31:41 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
10:31:41 <lambdabot>    arising from a use of `...
10:31:53 <danharaj> > makeFact (makeFact undefined) 0
10:31:54 <lambdabot>   1
10:31:55 <Funktorsalat> > (makeFact.makeFact.makeFact) undefined 2
10:31:56 <lambdabot>   2
10:32:09 <litb> lol fix screws me
10:32:14 <danharaj> (makeFact.makeFact.makeFact) undefined 6
10:32:24 <danharaj> > 01(makeFact.makeFact.makeFact) undefined 6
10:32:24 <lambdabot>   <no location info>: lexical error at character '\ETX'
10:32:29 <danharaj> DAMMIT WHY I SUCK
10:32:35 <hpc> \etx?
10:32:38 <monochrom> that is like saying recursion screws you. but I guess recursion does screw you.
10:32:44 <danharaj> anyway, fix is probably the hardest usual construct of the lambda calculus
10:32:45 <hpc> > chr '\ETX'
10:32:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:32:46 <lambdabot>         against inferred type ...
10:32:55 <hpc> > toEnum '\ETX'
10:32:59 <Funktorsalat> > ord '\ETX'
10:32:59 <danharaj> because it represents recursion in a way that is not immediately intuitive
10:33:00 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
10:33:02 <lambdabot>         against inferred type ...
10:33:04 <lambdabot>   3
10:33:07 <danharaj> it represents it as a limit instead of self reference
10:33:08 <hpc> huh
10:33:30 <danharaj> >01(makeFact.makeFact.makeFact) undefined 6
10:33:39 <danharaj> I give up :<
10:33:41 <hpc> ETX = end terminal execution, or something like that?
10:33:42 <Funktorsalat> danharaj: yeah, the limit view can be slightly less confusing because it's bottom-up rather than circular
10:33:54 <danharaj> well, to a mathematician it makes perfect sense :p
10:34:06 <hpc> mathematicians are funny
10:34:14 <hpc> they call category theory "abstract nonsense"
10:34:22 <danharaj> those days are long gone
10:34:24 <Funktorsalat> uh actually mathematicians came up with that limit stuff to make recursion rigorous ;)
10:34:26 <danharaj> that was Bourbaki's thang
10:34:33 <hpc> ah
10:34:36 <danharaj> now it's "derived functorial bullshit"
10:34:41 <hpc> lol
10:34:59 <hpc> i was going to say, since when is /anything/ too abstract for a mathematician
10:35:15 <Funktorsalat> btw you need seven makeFacts for argument 6 ;)
10:35:17 <Funktorsalat> not 3
10:35:28 <danharaj> Good general theory does not strive for the maximum generality, but for the right generality. - Maclane
10:35:38 <danharaj> So the answer is, it is too abstract when it is too abstract ;)
10:35:58 <monochrom> I have two objections. (1) limit is more intuitive than self-reference. (2) regardless, fix can be defined either way. you can define it by self-reference if you like, or limit if you like, whichever you find more intuitive. fix is just a shorthand. fix is not counterintuitive, in the same way that shorthands are not counterintuitive.
10:36:27 <danharaj> monochrom: I think you are lying because everyone I know who knows fix said it was unintuitive when they approached it at first.
10:36:36 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml explains fix as usual self-reference or recursion
10:36:38 <danharaj> Now obviously if you understand something eventually it is subsumed into your intuition
10:36:42 <Funktorsalat> monochrom: you object to (1) or you argue (1)?
10:36:51 <_zip> since haskell.org is down, where is the side backup? especially the tutorial "for C programmers"?
10:36:55 <monochrom> I argue (1) and (2).
10:37:00 <medfly`> lol
10:37:00 <_zip> s/sde/site/
10:37:04 <litb> how can you make  fix makeFact 6 show the computations?
10:37:10 <Funktorsalat> monochrom: so did I :) (argue (1))
10:37:16 <medfly`> hpc, philosophy?
10:37:18 <danharaj> litb: you could totally write a lambda calculus interpreter
10:37:19 <hpc> > fix makeFact x
10:37:20 <lambdabot>   x * ((x - 1) * ((x - 1 - 1) * ((x - 1 - 1 - 1) * ((x - 1 - 1 - 1 - 1) * ((x...
10:37:28 <litb> ah yes nice
10:37:34 <hpc> <3 that show instance
10:37:36 <litb> lol danharaj 
10:37:43 <danharaj> not a joke, it is actually very easy
10:37:47 <monochrom> danharaj: I submit that everyone you know were given poor, overly philosophical explanations of fix, and that is why they found it unintuitive.
10:37:57 <danharaj> you should pick up "types and programming languages" if you really want to learn about the foundations of haskell
10:38:01 <litb> danharaj: eelis wrote one in a few lines of C++ afaik
10:38:12 <monochrom> give them my http://www.vex.net/~trebla/haskell/fix.xhtml instead.
10:38:15 <litb> altho i have no clue whatit actually is lol
10:38:29 <danharaj> monochrom: my first exposure was in Pierce, and it took me not too long to get it, but I did have to think to get it.
10:38:30 <_zip> hello?
10:38:37 <Botje_> hallo!
10:38:43 <danharaj> world!
10:39:00 <_zip> anyone having a site backup of haskell.org, and the tutorial for C programmers?
10:39:03 <litb> hm that show instance only shows the "inlined" calculations in seems -.-
10:39:30 <Botje_> _zip: http://webcache.googleusercontent.com/search?q=cache:OtLN9LQMPrIJ:www.haskell.org/~pairwise/intro/section1.html+http://www.haskell.org/~pairwise/intro/section1.html&cd=1&hl=nl&ct=clnk&gl=be&client=opera
10:39:54 <Botje_> if you enter the url of the link at the bottom into google, you can access the cached version of that page
10:39:57 <Botje_> and so on
10:40:00 <_zip> Botje_: that only caches the intro page, which I already have opened in firefox... but not the full tutorial.
10:40:17 <Botje_> _zip: that's the first section, actually, not the intro
10:40:32 <Botje_> and you can enter the url of the next section into google to get the next one
10:41:26 <Botje_> _zip: alternatively, http://web.archive.org/web/20080702221601/http://www.haskell.org/~pairwise/intro/intro.html
10:41:34 <Botje_> the wayback machine has a full backup, it seems
10:41:37 <litb> so "fac" in makeFact is actually a   fix makeFact
10:41:38 <Botje_> and the links are rewritten
10:41:38 <solistic> _zip: http://new-www.haskell.org/haskellwiki/Introduction
10:41:50 <solistic> _zip: Is it here?
10:41:53 <_zip> web.archive.org saved the day: http://web.archive.org/web/20080702221601/http://www.haskell.org/~pairwise/intro/intro.html
10:42:18 <_zip> solistic: thank you :-)
10:42:31 <monochrom> Pierce's TaPL "the intuitive is that..." for fix is not intuition.
10:42:38 <Botje_> hey! i just pasted you that link :P
10:42:48 <litb> ah i think i got it. at some point it calls  fix makeFact 1 which returns 1, and then it goes all up the recursion again
10:43:09 <monochrom> Generally do not trust people when they say "the intuition is that...". Their private intuition maybe. Not yours.
10:43:21 <litb> lol
10:43:28 <danharaj> It often is the case that you want your intuition to be what they say it is, at least partly.
10:44:17 <monochrom> For those who have already accepted the self-reference kind of recursion like "f = ... f ...", my explanation is immediate.
10:44:34 <_zip> Botje_: it looks like the one I pasted is the latest one in the archive. but thank you nevertheless. :-)
10:45:56 <monochrom> And on intuition in general, http://www.vex.net/~trebla/weblog/intuitive.html
10:48:27 <danharaj> monochrom: your fix is not the same fix in the pure lambda calculus
10:48:46 <monochrom> it is haskell's fix
10:48:47 <Botje_> no problem. have fun :)
10:49:34 <Twey> Â« A European or American may suggest R | S | T as an intuitive way; afterall [sic] his/her mother tongue is written from left to right. Â» â€” except when it isn't.  Fear the generalisations!  Fear them!
10:49:41 <monochrom> Y in lambda calculus is even easier. just play with it with many examples and you see the pattern.
10:49:45 <litb> i understand now: fix calling  f (fix f) is fine because  f (fix f)  does not immediately return a result but only a function
10:50:14 <danharaj> monochrom: then you exactly agree with pierce :)
10:50:36 <danharaj> "Probably the best way of getting some intuition about its behavior is to watch how it works on a specific example."
10:50:40 <litb> or if it returns a result it has to ignore the  (fix f) argument. i see now the advantage of lazy evaluation!
10:51:30 <litb> so you can say    f a = 0   and call  fix f   and it is 0
10:51:45 <danharaj> yes
10:51:45 <sipa1024> yes
10:51:52 <monochrom> I thought you meant Pierce's TaPL
10:51:53 <litb> xD
10:51:55 <sipa1024> that function is actually (const 0)
10:52:05 <sipa1024> > fix $ const 0
10:52:06 <lambdabot>   0
10:52:10 <litb> oh i see
10:52:15 <danharaj> monochrom: yes tapl, page 65 at the bottom
10:52:44 <monochrom> my copy is a pirated copy with no page number. which section?
10:52:51 <Twey> @src fix
10:52:51 <lambdabot> fix f = let x = f x in x
10:53:18 * hpc would like fix rewritten as (fix f = f . fix $ f)
10:53:20 <Twey> fix (const 0) = let x = const 0 x in x = let x = 0 in x = 0
10:53:35 <Twey> Haha, fix written in terms of fix
10:53:39 <Twey> There's something ironic about that
10:54:04 <danharaj> sup dawg, I heard you liked recursion so we put fix in your fix in your fix in your...
10:54:19 <sipa1024> loi
10:55:06 <Twey> fix = join $ flip fmap fix
10:55:08 <danharaj> so, last night I had a perfectly clear idea of what I was going to code today
10:55:11 <danharaj> I can't remember it :|
10:55:18 <monochrom> section 5.2? yes I agree with that one.
10:56:12 <monochrom> but section 11.11 "the intuition is that ... approximates ..." I disagree with that.
10:57:16 <litb> the "in x" looks weird
10:57:27 <litb> let x = f x   should be enough?
10:57:32 <danharaj> I suppose you have that right. We were talking about different things anyway :p
10:57:38 <hpc> no, it needs the 'in'
10:57:43 <danharaj> fix is not a derived form wheras Y is.
10:57:51 <danharaj> I made the mistake of conflating the two.
10:57:57 <unkanon> hpc: I think your definition is a lot clearer than the one with let
10:58:11 <litb> what does the in x do
10:58:13 <tomberek> @seen edwardk
10:58:13 <lambdabot> Unknown command, try @list
10:58:13 <preflex>  edwardk was last seen on #haskell 20 hours, 40 minutes and 49 seconds ago, saying: your type alias doesn't make sense though, type T :: * inside the class instance -- has to name every argument to your class
10:58:14 <hpc> unkanon: it makes the recursion itself more obvious
10:58:19 <litb> is it some syntax thign?
10:58:24 <hpc> and doesn't have a value that appears out of nowhere
10:58:37 <tomberek> hi unkanon
10:58:42 <unkanon> danharaj: always write it down, it happens to me everytime too, i always forget the day after
10:58:44 <monochrom> litb: have you heard of "let ..=... in ..."?
10:58:52 <unkanon> tomberek: hey there
10:58:56 <litb> ohh now i see!
10:59:00 <danharaj> unkanon: it was 4 am and I could not move out of my bed :[
10:59:52 <unkanon> hpc: but you changed it now, you had said f $ fix f before
11:00:00 <hpc> unkanon: same thing
11:00:07 <hpc> a $ b c == a . b $ c
11:00:09 <Funktorsalat> @let makeFix fix0 f = f . fix0 f
11:00:10 <lambdabot>  Defined.
11:00:11 <litb> to me  f (fix f)  is the most obvious haha
11:00:23 <Funktorsalat> > fix makeFix makeFact 6
11:00:24 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
11:00:24 <lambdabot>    arising from a use of `...
11:00:35 <Funktorsalat> sorry ;)
11:00:49 <hpc> :t fix makeFix
11:00:50 <lambdabot> forall b (f :: * -> *). (Functor f) => (b -> b) -> f b
11:01:02 <Funktorsalat> ah. lambdabotism in the way
11:01:42 <Funktorsalat> > fix (makeFix :: ((b -> b) -> b) -> ((b->b)->b))) makeFact 6
11:01:43 <lambdabot>   <no location info>: parse error on input `)'
11:01:47 <Funktorsalat> > fix (makeFix :: ((b -> b) -> b) -> ((b->b)->b)) makeFact 6
11:01:48 <lambdabot>   Occurs check: cannot construct the infinite type: b = f b
11:01:54 <Funktorsalat> ok I give up
11:02:43 <litb> lol
11:02:53 <Funktorsalat> @let realMakeFix fix0 f = f (fix0 f)
11:02:54 <lambdabot>  Defined.
11:03:02 <Funktorsalat> > fix realMakeFix makeFact 6
11:03:03 <lambdabot>   720
11:03:07 <Funktorsalat> phew
11:03:18 <unkanon> hpc: oh ok
11:03:32 <hpc> :t realMakeFix
11:03:33 <lambdabot> forall t t1. ((t -> t1) -> t) -> (t -> t1) -> t1
11:03:55 <hpc> eek; it's like fix only fixier
11:07:45 <tomberek> if I will not need to access an old version of the array, will DiffArrays provide an efficient functional array?
11:07:48 <litb> isn't that exactly the same as  fix ?
11:08:02 <Funktorsalat> yes sorry, I was just going for maximal insanity
11:08:19 <litb> lol
11:08:37 <c_wraith> tomberek, kind of.  they DiffArrays have poor constant factors, due to internal implementation details.
11:09:01 <c_wraith> tomberek, if you're always using the newest version, everything is still O(1), but rather slow
11:09:25 <tomberek> hm.... I was thinking of using them for a search algorithm
11:09:52 <tomberek> i want O(1) update, but i don't know if that is worth the constant
11:10:13 <litb> can haskell generate a perfect hash-function for me given a set of strings?
11:10:16 <tomberek> c_wraith: how is the unboxed version?
11:11:54 <c_wraith> tomberek, a bit better, but not a ton.  Oh, also, updates are O(n) either way.  you need true mutable arrays for O(1) updates
11:12:20 <djahandarie> I think there are more than constant factors involved in DiffArray
11:12:23 <tomberek> ouch, that means the monad will permeate everywhere, right?
11:13:49 <danharaj> uniqueness types would be nice :[
11:14:06 <sm> good morning
11:14:10 <c_wraith> djahandarie, it really is just constant factors.  The problem is that they involve locking, which makes them expensive
11:14:14 <sm> how do I pass -i options to runghc ?
11:14:26 <sm> to include source from other directories
11:15:30 <tomberek> c_wraith: would that mean that at the level of the algorithm using it, it will be monadic? can't split up the pure and impure?
11:15:57 <c_wraith> I wonder how much improvement DiffArray would get out of using an IORef and atomicModifyIORef.  It'd probably perform better in single-threaded use, and worse in heavily concurrent use.
11:17:05 <jmcarthur> i wouldn't want to use DiffArray in a heavily concurrent way anyway
11:17:34 <c_wraith> No.  The cases where you want it are almost all linear.
11:17:51 <c_wraith> So it'd probably be better off with an IORef and atomicModifyIORef
11:18:00 <jmcarthur> i say try it
11:18:10 <jmcarthur> sounds like an easy change, i think
11:18:22 <c_wraith> are there existing benchmarks for it?
11:18:33 <jmcarthur> there were plans to make some, but i don't know if they are still around
11:18:36 <c_wraith> If not, I think benchmarking it well would be harder than making the change
11:18:40 <jmcarthur> or if they were ever made, that is
11:18:42 <jmcarthur> yeah
11:18:48 <Heffalump> c_wraith: huh? Why would DiffArray updates not be O(1)?
11:19:11 <c_wraith> Heffalump:  Oh, you're right.  Sorry.
11:19:17 <jmcarthur> well, they wouldn't be O(1) if you updated an older version of one
11:19:20 <Heffalump> sure
11:19:31 <c_wraith> But yeah, updating the newest version should be O(1), yeah.
11:20:33 <c_wraith> I got confused. :(
11:20:39 <tomberek> c_wraith: ah, hm.... how bad is the constant? in most cases would it be better not to bother?
11:20:46 <sm> I see, no space after -i
11:20:59 <kmc> DiffArray :/
11:21:05 <c_wraith> tomberek, depends on your app.
11:21:11 <kmc> i contend that IntMap is almost always a better choice
11:21:44 <c_wraith> But DiffArray is always going to involve one more memory de-reference than a corresponding mutable array would.
11:21:59 <tomberek> i see
11:22:08 <c_wraith> for each operation.
11:22:39 <jmcarthur> even if not for the constant factors, DiffArray is merely a way to avoid using IO or ST. you still have the runtime characteristics of mutable code, both the good and the bad
11:23:12 <danharaj> do you lose persistence?
11:23:31 <jmcarthur> danharaj: you pay the performance penalty for making copies when you use old versions
11:23:46 <tomberek> jmcarthur: but if old versions are not needed?
11:23:56 <jmcarthur> tomberek: then it's as though you made no copies, just like mutable code
11:24:06 <tomberek> not bad
11:24:09 <jmcarthur> well
11:24:10 <danharaj> seems like it gives you flexibility to pay for only what you need.
11:24:13 <danharaj> (plus overhead)
11:24:22 <jmcarthur> danharaj: not the case though...
11:24:27 <danharaj> then what's the point :(
11:24:44 <jmcarthur> danharaj: a good purely functional data structure copies less even when you use older versions
11:24:47 <jmcarthur> e.g. IntMap
11:24:58 <danharaj> What's the intended use of DiffArray?
11:25:16 <jmcarthur> it's basically for those cases when mutable arrays are an option but you don't want to use ST or IO
11:25:26 <danharaj> ah.
11:25:28 <jmcarthur> it has the exact same performance tradeoffs
11:25:35 <jmcarthur> aside from those horrible constant factors
11:25:44 <danharaj> horrible, even eldritch constant factors
11:25:48 <danharaj> from beyond the IO veil
11:28:48 <Funktorsalat> @all-dicts eldritch
11:28:50 <lambdabot> *** "Eldritch" gcide "The Collaborative International Dictionary of English v.0.48"
11:28:50 <lambdabot> Eldritch \El"dritch\, a.
11:28:50 <lambdabot>    Hideous; ghastly; as, an eldritch shriek or laugh. [Local,
11:28:50 <lambdabot>    Eng.]
11:28:50 <lambdabot>    [1913 Webster]
11:28:52 <lambdabot> [9 @more lines]
11:29:00 <danharaj> ... hey, does every function f :: forall a. a -> b factor through ! :: a -> ()? Isn't that interesting.
11:29:21 <litb> @all-dicts litb
11:29:21 <lambdabot> No match for "litb".
11:29:23 <litb> -.-
11:29:38 <Twey> Ugh, Webster
11:29:50 <danharaj> and every function f :: forall a. [a] -> b should factor through fmap !.
11:29:53 <Funktorsalat> danharaj: I think so. are you familiar with parametricity/free theorems?
11:29:59 <danharaj> vaguely
11:30:07 <danharaj> I am wondering if you can state parametricity by this statement
11:30:21 <litb> i think fmap was similar to map but uses the Functor monad or something
11:30:28 <litb> it's been so long!
11:30:30 <danharaj> and if you can find types like () that work for typeclass polymorphism.
11:30:40 <Funktorsalat> I'm only vaguely familiar too actually ;)
11:30:52 <danharaj> all I know is "Blah blah, natural transformation hurp durp"
11:30:56 <danharaj> that's my intuition ;p
11:30:58 <litb> lol
11:32:06 <Funktorsalat> I think the 'b' is a red herring, so let's define f_A := f with a specialized to A
11:33:15 <danharaj> I think every typeclass instance should factor through the morphism that injects the instance into the 'dictionary type'
11:33:44 <danharaj> () would be the empty dictionary
11:33:49 <Funktorsalat> so if 'f' is a natural transformation from Id_Hask to, err, the functor (-> b) (pseudocode, section syntax on the type level)
11:34:46 <Funktorsalat> except that that's a contravariant functor. hmpf
11:34:50 <danharaj> I thought it was
11:35:00 <danharaj> a natural transformation from Id to the constant functor
11:35:13 <Funktorsalat> don't know how parametricity deals with contravariance
11:35:38 <Funktorsalat> where do typeclasses come in there?
11:35:40 <danharaj> in the case of forall a. a -> b, for some b
11:36:00 <danharaj> subcategory of hask, maybe?
11:36:10 <danharaj> actually no, because a typeclass really is a type equipped with extra structure.
11:36:22 <danharaj> it's a functor from a subcategory of hask, maybe?
11:36:39 <danharaj> instead of id
11:38:01 <Funktorsalat> how would that let you handle a contravariant functor?
11:38:28 <Funktorsalat> I vaguely seem to remember something about dinaturality here
11:39:16 <danharaj> if you want to talk about things like a |-> a -> a, you need to talk about dinatural transformations.
11:39:26 <danharaj> that's supposed to be an arrow with a flag :\
11:41:20 <Funktorsalat> http://en.wikipedia.org/wiki/Dinatural_transformation  with these letters we could take S : Hask^op x Hask -> Hask , projection to second component
11:43:20 <Funktorsalat> and T(a1,a2) = a1 -> b, T(f1 :: (a1 -> a1'), _) = ( \g -> g . f1 ) :: ( (a1' -> b) -> (a1 -> b) )
11:46:49 <danharaj> wah, the ghc docs are down
11:46:55 <danharaj> anyone know the pragma for rank2 types?
11:47:17 <Funktorsalat> LANGUAGE Rank2Types
11:47:47 <dons> danharaj: all libs are documented on hackage though
11:48:01 <danharaj> dons: wow, good to know. Google does not hit those at all.
11:48:05 <Funktorsalat> hint: ghc --supported-extensions :)
11:48:14 <dons> http://hackage.haskell.org/package/base
11:48:16 <dons> e.g.
11:48:17 <danharaj> pffffffff why would I ask my compiler?
11:48:28 <Funktorsalat> though I guess that's not so useful if you don't already know roughly what it's called
11:48:54 <Funktorsalat> it's useful for writing autocompletion functions, though ;)
11:51:13 <danharaj> wait, if dons is on, does that mean that haskell reddit is going to see a new round of interesting links to read? :)
11:53:42 <dons> well, its a sunday. usually a pretty quiet news day
11:56:22 <Feuerbach> Funktorsalat: when was this option added? my 6.12.1 does not know such option
11:56:46 <Funktorsalat> Feuerbach: this is 7.0. maybe --supported-languages
11:57:01 <Funktorsalat> (my manpage mentions the two as aliases)
11:57:42 <byorgey> oh, they changed it to --supported-extensions? that makes more sense
11:57:56 <byorgey> I always expect ghc --supported-languages to output "Haskell"
11:58:00 <fengshaun> are there any threading tutorials for haskell?
11:58:11 <Funktorsalat> byorgey: haha it seemed odd to me too
11:58:42 <jmcarthur> fengshaun: threading is haskell is not difficult. you just use forkIO to fork off an IO action
11:59:14 <fengshaun> jmcarthur, the thing is, I'm new to threading itself!
11:59:46 <jmcarthur> fengshaun: what is the application you are using threading in?
11:59:53 <danharaj> sewing.
11:59:55 * danharaj rimshot
12:00:14 <fengshaun> not a specific app, just wanted to know how to do it if the need arises!
12:00:31 <jmcarthur> fengshaun: well, there are different things to learn for different purposes
12:00:56 <fengshaun> oh, is there any article that overviews them?
12:01:08 <fengshaun> I couldn't find anything myself
12:01:15 <jmcarthur> fengshaun: here's something the covers a few options: http://book.realworldhaskell.org/read/concurrent-and-multicore-programming.html
12:01:28 <fengshaun> jmcarthur, thanks a lot!
12:02:08 <jmcarthur> fengshaun: also good to read after that one: http://book.realworldhaskell.org/read/software-transactional-memory.html
12:02:42 <fengshaun> thanks a lot, last time I checked RWH I didn't see those chapters!
12:02:43 <jmcarthur> fengshaun: there are also numerous libraries on hackage offering various concurrency models
12:03:35 <jmcarthur> fengshaun: and there's also something in the works called nested data parallelism which will be very cool once it's done, but don't get distracted by it if you see anything about it for now unless you are just curious, because it's not ready
12:04:00 <fengshaun> sounds cool, I will actually check that!
12:04:38 <jmcarthur> there are a couple cool videos explaining NDP
12:06:28 <fengshaun> that concurrency chapter on RWH is just what I was looking for, thanks
12:08:43 <jmcarthur> np
12:09:40 <kmc> fengshaun, you could take a look at my slides on this topic: http://www.ugcs.caltech.edu/~keegan/talks/first-class-concurrency/talk.html
12:10:20 <fengshaun> so much stuff to read right before finals!  Thanks, kmc
12:11:02 <kmc> fengshaun, i might turn this into a blog post at some point
12:12:49 <danharaj> I wonder, is ghc smart enough to optimize ( (), a) to a when it produces code?
12:13:24 <hpc> it can't
12:13:28 <hpc> () might be _
12:13:34 <hpc> _|_
12:13:35 <danharaj> accursed bottom
12:13:41 <hpc> for example:
12:13:42 <danharaj> it ruins everything that is nice
12:13:47 <Heffalump> it might do strictness analysis though
12:13:50 <danharaj> yeah yeah, I always ignore bottom when I think about semantics :|
12:13:53 <hpc> @unmtl State [Int] ()
12:13:53 <lambdabot> [Int] -> ((), [Int])
12:14:02 <Heffalump> but I guess the data representation still has to stay the same
12:15:08 <hpc> i still find it odd that the tuple is backwards like that
12:15:34 <hpc> you would expect the tuple to have the same order of type variables as State
12:15:38 <danharaj> pff it's all isomorphic
12:15:47 <danharaj> (except bottom >:|)
12:16:22 <jmcarthur> you can't ignore bottom :P
12:16:36 <danharaj> I can if I make sure bottom doesn't creep into my code.
12:16:50 <jmcarthur> bottom is not inherently bad
12:17:01 <jmcarthur> we just don't have great tools for dealing with it in haskell
12:17:12 <kmc> now what about Â«data Strict2 a b = Strict2 !a !bÂ»
12:17:14 <danharaj> Its presence in every type breaks a few nice properties.
12:17:20 <hpc> bottom: extremely difficult to handle properly :P
12:17:29 <kmc> then you could optimize Â«Strict2 () TÂ» to Â«TÂ» without changing semantics
12:17:35 <kmc> i wonder if unpacking does this
12:17:51 <jmcarthur> danharaj: it's not present in *every* type
12:17:57 <danharaj> oh?
12:18:00 <jmcarthur> newtype Unit = Unit Unit
12:18:26 <danharaj> I am confused by that line.
12:19:16 <Funktorsalat> data Foo a = Foo {-# UNPACK #-} !() a
12:19:19 <Funktorsalat> might work ;)
12:20:02 <jmcarthur> danharaj: basically it's just top (as opposed to bottom)
12:20:25 <jmcarthur> danharaj: it's like () but without _|_
12:20:35 <danharaj> Do you mean Top or Unit?
12:21:18 <jmcarthur> danharaj: i just mean that the semantics of newtype guarantee that nothing of type Unit can be bottom
12:21:23 * hackagebot redis-hs 0.0.13 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.0.13 (WillLangstroth)
12:21:23 <Funktorsalat> class HasTuple a b where { data Tuple a b :: *; fst :: .... }
12:21:31 <danharaj> ah
12:21:36 <Funktorsalat> could give you somewhat polymorphic unpacked tuples
12:21:41 <Funktorsalat> don't know if there's a lib for that
12:21:44 <danharaj> newtype always has something new to surprise me with
12:22:01 <jmcarthur> danharaj: case undefined of Unit _ -> ...   will always succeed
12:30:54 <danharaj> haskell wiki being down makes me sad :|
12:34:41 <Feuerbach> jmcarthur: you've just enlightened me with your Unit. Was this described elsewhere in more details?
12:36:11 <jmcarthur> i came up with it myself, but i doubt i was the first
12:39:42 <jmcarthur> actually, i made the tie of Unit to newtype myself, but it was somebody i was talking to that actually suggested that recursive definition
12:39:52 <jmcarthur> pumpkin maybe?
12:39:53 <Quadrescence> haskell is seriously the best programming language i've ever used
12:40:05 <jmcarthur> :D
12:42:15 <finnomenon> I like it too, except I can't get my head around recursion :I
12:43:05 <danharaj> even hoogle is down :| :|
12:43:31 <jmcarthur> recursion is not at all haskell-specific at least
12:43:45 <danharaj> recursion is the cornerstone of computation
12:43:58 <jmcarthur> although recursion in haskell is more interesting in haskell than most other languages due to laziness
12:44:58 <aristid> jmcarthur: the sentence started almost recursively :D
12:45:11 <finnomenon> I have to prepare java assignments for tomorrow. after that I'm back to learning haskell
12:46:20 <danharaj> what's the easiest way, if I have f :: a -> c, and I want to map it over [(a, b)]?
12:46:26 <Quadrescence> finnomenon: to understand recursion, see recursion
12:46:36 <sipa1024> try googling for "recursion"
12:46:38 <danharaj> such that (a, b) maps to (f x, id y)
12:46:42 <hpc> danharaj: use the types, luke
12:46:51 <kmc> :t first
12:46:52 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
12:46:53 <finnomenon> I've seen it before sipa1024 
12:47:00 <kmc> :t map . first
12:47:01 <lambdabot> forall b c d. (b -> c) -> [(b, d)] -> [(c, d)]
12:47:37 <danharaj> Is first in prelude?
12:47:51 <kmc> no
12:47:52 <applicative> Control.Arrow
12:48:41 <danharaj> I'm not sure I want to add yet another dependency
12:48:47 <Funktorsalat> it's base
12:48:56 <danharaj> Maybe I don't want to be GHC biased.
12:49:01 <danharaj> I don't know.
12:49:02 <kmc> danharaj, recursion is the cornerstone of computation, but most people learn only a couple special cases of recursion named like "for" and "while" and such
12:49:05 <hpc> base is base
12:49:15 <Funktorsalat> it's also not hard to define it yourself 
12:49:16 <Funktorsalat> ;)
12:49:31 <hpc> Prelude is base; Prelude isn't GHC specific
12:49:45 <danharaj> base is not prelude though?
12:49:50 <applicative> Hugs has Control.Arrow, for sure
12:49:51 <jmcarthur> aristid: ha i didn't catch that
12:49:52 <Funktorsalat> hpc: the whole base is pretty ghc-specific isn't it?
12:50:06 <Funktorsalat> that was ambiguous but I guess you know what I mean
12:50:26 <Funktorsalat> (having *all* of base) is pretty ghc-specific
12:50:35 <Funktorsalat> (or maybe it isn't)
12:51:41 <danharaj> Base on hackage includes the GHC libraries so...
12:54:26 <applicative> it
12:54:47 <applicative> is hard to follow how 'base' is used now, but hugs was using it in olde days, it seems http://cvs.haskell.org/Hugs/pages/libraries/
12:54:52 <jmcarthur> gah, first hackage yesterday, then haskell.org yesterday and today, and now github!
12:54:54 <jmcarthur> :(
12:55:06 <danharaj> pff github
12:55:15 * applicative is secretly pleased
12:55:22 <jmcarthur> i don't use it much, but others do. and i need some of that code right now
12:55:23 * danharaj is flagrantly pleased
12:55:32 <jmcarthur> i'm a darcs fan, myself
12:55:44 <danharaj> they should make a github-esque site for darcs called darcside
12:56:04 <Entroacceptor> danharaj: there's patch-tag
12:56:10 <danharaj> darcside is punny though
12:56:12 * applicative is trying to spread the meme that Linus has secretly encoded a "kill all git repositories" gene in the git source, set to go off, say today
12:57:14 <Entroacceptor> you can do that when darcs gets into the same magnitude of speed
12:58:19 <applicative> git clone is really fast from github, of course, but actually viewing source on their website is pretty clunky
12:59:29 <Quadrescence> this is why you don't rely on github or any other site, and just use tarballs and diffs
13:00:05 <applicative> indeed, it seems clear that patch tag is faster at rendering pages of source.  I'll have to study it sometime...
13:00:57 <jmcarthur> i don't understand everybody complaining about darcs speed anymore. it's just not a problem for me with current versions of darcs
13:01:14 <kmc> jmcarthur, can you use 'darcs annotate' on ghc?
13:01:29 <Ke> clone is painfully slow and unreliable
13:01:40 <jmcarthur> kmc: (1) that's the next command they are going to optimize, and (2) how often do you actually use that?
13:01:43 <Ke> wait days to see it fail
13:01:49 <jmcarthur> Ke: that's the old darcs
13:01:58 <jmcarthur> current darcs get is far faster now
13:02:11 <kmc> jmcarthur, i don't use darcs for my own projects.  so about 50% of the times i needed to use darcs, it was darcs annotate on ghc
13:02:13 <jmcarthur> i can get an entire GHC (without --lazy and without cache) in 3 minutes
13:02:22 <Ke> hopefully I'll see it in use somewhere then
13:03:20 <jmcarthur> kmc: that sounds unfortunate
13:03:28 <tomh> is there a haskell IDE with debugging functionality build in?
13:03:57 <Ke> is there any haskell debugging functionality =oP
13:04:01 <tomh> yeah
13:04:02 <Ke> not really
13:04:02 <hpc> haskell isn't really debugged so much as typechecked
13:04:24 <tomh> ghci has breakpoints etc
13:04:25 <hpc> and if you really need to, Debug.Trace
13:04:33 <applicative> @quote oasis
13:04:33 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
13:04:35 <tomh> yeah that is not good enough
13:04:52 <Ke> tomh: ghci debugger is worthless without cabal support
13:05:16 <hpc> haha, nice quote
13:05:30 <Feuerbach> jmcarthur: returning to Unit... does it make any sense from denotational semantics' point of view? If the type is represented by one-element set, it's reasonable to call it bottom (and also top)
13:06:09 <applicative> tomh, are you dealing with a particular problem, or wondering about what general practice should be?
13:06:40 <tomh> im dealing with the particular problem of not knowing what the heck is going on, how my code is evaluated and why :P
13:07:42 <jmcarthur> Feuerbach: it might make more sense to think of it in terms of initial and final objects
13:08:08 <jmcarthur> Feuerbach: newtype Unit = Unit Unit  and  data Void
13:08:30 <jmcarthur> Feuerbach: both have one element each, but they mean different things
13:08:39 <applicative> is it that you're getting wrong answers, errors -- or that its too slow or whatever
13:08:47 <applicative> tomh ^^^
13:09:15 <orlandu63> is it considered bad practice to use b <- return a instead of let b = a inside a do block? i find the former nicer as it doesn't stand out as much
13:09:20 <tomh> its giving unexplainable answers :)
13:09:35 <kmc> orlandu63, i consider that bad practice
13:09:42 <tomh> probably they are correct from a code point of view, its just not what I intended
13:09:44 <kmc> it also has different behavior wrt polymorphism
13:10:09 <kmc> orlandu63, there's an argument for using 'return' that way to prevent accidental recursion
13:10:15 <kmc> but i think it *should* stand out
13:10:25 <kmc> it should be clear from looking at the block where actions are executed and where they aren't
13:10:27 <applicative> is it a module you could paste on hpaste?  
13:10:32 <ski> orlandu63 : i only use `<p> <- return <e>' if `<p>' is a refutable pattern, which i want to call `fail' underneath
13:11:18 <tomh> eh well its an exam for school :)
13:11:26 <applicative> tomh, haha, i see
13:11:28 <tomh> so its better if I not post it in public
13:11:43 <orlandu63> ski, kmc: logical points. thanks
13:11:54 <tomh> im trying to solve one of the questions but I get stuck in the behavior and I need some ways to debug it :)
13:12:14 <ski> > do Just x <- [Just 2,Nothing,Just 3]; return x
13:12:15 <lambdabot>   [2,3]
13:12:22 <ski> orlandu63 : like that ^
13:12:36 <ski> er, actually, that's not quite it
13:12:43 <hpc> @src [] fail
13:12:43 <lambdabot> fail _      = []
13:13:36 <hpc> oh duh; i had the monadplus laws mixed up and thought it did something different
13:13:55 <hpc> :t mplus
13:13:55 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
13:14:13 <ski> hpc : i would prefer if `mzero' was used, though ..
13:14:28 <hpc> @src [] mzero
13:14:28 <lambdabot> mzero = []
13:14:47 <hpc> it helps to have a string describing the error
13:14:48 <Feuerbach> jmcarthur: what's the evidence that they mean different things? I see the difference in pattern matching, but without being backed up by some theory it looks like Haskell-specific detail
13:15:38 <danharaj> do I have to worry about efficiency if I have f :: [a] -> [c] and g :: [a] -> [c], and I do zip (f x) (g x), or is there a more efficient 'fusion' sort of thing?
13:15:52 <hpc> ski: for most monads, fail = const mzero anyway, in order for the laws of sanity to hold
13:16:08 <Feuerbach> jmcarthur: I don't understand how to interpret recursive newtype theoretically
13:16:09 <hpc> @src IO mzero
13:16:09 <lambdabot> mzero       = ioError (userError "mzero")
13:16:12 <hpc> hehe
13:17:19 <ski> @src IO fail
13:17:19 <lambdabot> fail s  = failIO s
13:17:33 <applicative> tomh, it isn't so easy to set up, but one standard practice is to use quickcheck to test "invariants" that should hold
13:17:42 <hpc> failIO = ioError . userError?
13:17:55 <applicative> @check \x y -> (reverse . reverse) x == x
13:17:56 <lambdabot>   "OK, passed 500 tests."
13:17:56 <ski> hpc : yes, the string helps for debuggingm .. i just don't think it should be available programatically
13:17:57 <Feuerbach> jmcarthur: non-recursive newtype denotes just the same type as its undelying type, but recursive newtype is like one hand clapping
13:18:12 <hpc> jeez, IO has a crapton of layers on it's system of exceptions and failures
13:18:18 <applicative> @check \x y -> (reverse . head . reverse) x == head x
13:18:19 <lambdabot>   "*Exception: Prelude.head: empty list
13:18:20 <ski> hpc : or more specifically, the ordinary evaluation results of code shouldn't be able to depend on that string
13:18:21 <tomh> well in my case its a bunch of type class functions being applied, but its hard to reason about in which order it happens
13:18:30 <magicman> @check \x -> reverse x == x
13:18:31 <lambdabot>   "OK, passed 500 tests."
13:18:45 <magicman> Your point. Type defaulting defeats it <_<
13:18:50 <jmcarthur> Feuerbach: lol, awesome analogy
13:18:55 * magicman growls at type defaulting.
13:19:50 <ski> @check \as -> not (null as) ==> (reverse . head . reverse) as == head as
13:19:50 <lambdabot>   No instance for (Test.QuickCheck.Testable
13:19:51 <lambdabot>                     (Test.QuickCh...
13:20:03 * ski wonders who broke `(==>)' in `check'
13:20:08 <ski> @type (==>)
13:20:09 <lambdabot> forall prop. (Testable prop) => Bool -> prop -> Property
13:20:23 <jmcarthur> Feuerbach: i'm feeling myself at a loss for words right now
13:20:57 <ski> @check \as -> (reverse . reverse) as == (as :: [Bool])
13:20:58 <lambdabot>   "OK, passed 500 tests."
13:21:04 <ski> @check \as -> reverse as == (as :: [Bool])
13:21:05 <lambdabot>   "Falsifiable, after 2 tests:\n[True,False]\n"
13:21:10 <magicman> :)
13:21:13 <jmcarthur> Feuerbach: a newtype constructor can always be taken as a given
13:21:36 <jmcarthur> Feuerbach: but a data constructor can't
13:21:54 <ski> jmcarthur : "taken as a given" means ?
13:22:07 <jmcarthur> ski: yeah it's hand wavy because i am not smart enough :(
13:22:19 <jmcarthur> s/smart/educated/
13:22:28 <ski> i was not complaining
13:22:33 <ski> i was just wondering what you meant
13:23:00 <jmcarthur> ski: by that i mean that you can always assume its existence without dissecting the term
13:23:02 <applicative> recursive newtype is a bit mysterious, i agree -- i mean, it's mysterious how it can be 'newtyping'
13:23:37 <ski> jmcarthur : ah, you mean that they are `O(0)', so to speak -- i.e. that they have no operational (/ run-time) existence ?
13:23:38 <jmcarthur> maybe it would be a good idea to compare haskell's newtype to something like agda's records
13:23:56 <jmcarthur> it's just that newtype must have exactly one field
13:24:18 <jmcarthur> a limitation that i increasingly am frustrated with
13:24:20 * ski is not that familiar with how Agda2 handles records
13:24:46 <applicative> newtype P a = P (a, P a)
13:24:54 <jmcarthur> applicative: that's not the same
13:25:01 <jmcarthur> that introduces a new element
13:25:12 <applicative> ah ok
13:25:26 <ski> ah, you want pairs where `_|_ = (_|_,_|_)' ?
13:25:33 <jmcarthur> in agda, records are basically just a group of values with no extra semantics added
13:25:45 <jmcarthur> and an empty record is even possible
13:26:01 <Funktorsalat> jmcarthur: I wasn't aware that there's a difference between your Unit and data Void either
13:26:06 <jmcarthur> it's as though you had simply passed each of those values as separate parameters
13:26:33 <jmcarthur> Funktorsalat: case undefined of Unit _ -> "foo"
13:26:38 <dancor> if i do getLine and type a 3-byte-utf8 double-width chinese character, then i have to backspace three times to erase it completely from the input buffer.  but this backspaces into the previous line.  how do you get correct utf8 backspacing on input prompts?
13:26:38 <ski> jmcarthur : yeah, real record types would be nice to have in Haskell
13:26:51 <Funktorsalat> but case undefined of _ -> "foo" too?
13:26:57 <Funktorsalat> undefined :: Void
13:27:06 <jmcarthur> Funktorsalat: but that's not matching anything
13:27:35 <Funktorsalat> yeah but your 'case' isn't either after erasing the newtype ;)
13:27:38 <jmcarthur> Funktorsalat: i just mean that a value of type Unit is a (trivial) proof of something
13:27:40 <Funktorsalat> (not sure what the point is)
13:27:43 <applicative> i didn't the newtype Unit = Unit Unit above  ... awesome type....
13:28:36 * ski wonders what Funktorsalat and jmcarthur is arguing atm
13:28:48 <jmcarthur> Funktorsalat: UnitÃ—a = a, but VoidÃ—a = Void
13:29:12 <Funktorsalat> I guess I'd just conclude that a newtype pattern match isn't really a pattern match
13:29:36 <Funktorsalat> ski: I don't know either to be honest
13:29:37 <ski> it's irrefutable, yes
13:29:54 <jmcarthur> Funktorsalat: likewise, Void+a = a, but Unit+a... is different :)
13:30:23 <Funktorsalat> jmcarthur: hmm these product identities seem off to me
13:30:24 <Funktorsalat> brb
13:31:14 <jmcarthur> not identities, just isomorphisms
13:31:35 <Funktorsalat> yes; I mean Unit x a and Void x a seem isomorphic to me
13:31:58 <Funktorsalat> \(_,x) -> (_,x) isn't an iso?
13:32:02 <Funktorsalat> err
13:32:10 <Funktorsalat> \(_,x) -> (undefined,x) :)
13:32:14 <jmcarthur> data Pair a b = Pair !a !b
13:32:23 <ski> Funktorsalat : of which type ?
13:32:34 <Funktorsalat> ski: (Unit,a) vs (Void,a)
13:32:51 <jmcarthur> Pair Unit a  vs.  Pair Void a
13:33:03 <Funktorsalat> ski: (Unit as applicative last said, not ())
13:33:03 <ski> `data Unit = U' or `newtype Unit = U Unit' ?
13:33:11 <Funktorsalat> latter
13:33:12 <ski> ok
13:33:56 <ski> yes
13:34:06 <ski> but i'd not call you `Unit', `Unit' :)
13:34:10 <ski> s/you/your/
13:34:21 <Funktorsalat> jmcarthur: hmm aren't both sides iso to {_|_}?
13:34:28 <ski> no
13:34:32 <jmcarthur> they are not
13:34:37 <Funktorsalat> ski: not my name ;)
13:34:54 <jmcarthur> ski: why wouldn't you call it unit? it's what () is intended to be, isn't it?
13:35:01 <ski> the values in the types are `_|_' and `(_|_,a)', for every `a'
13:35:20 <Funktorsalat> ski: I mean with the strict pair
13:35:34 <Funktorsalat> (which jmcarthur defined)
13:35:59 <Funktorsalat> jmcarthur: I guess you're saying Pair (let x = Unit x) 1 is a non-bottom value?
13:36:10 <jmcarthur> right
13:36:18 <ski> jmcarthur : if you admit partial values as real values, but still want the traditional cardinalities, then yes
13:36:23 <Funktorsalat> that's pretty ridiculous behaviour but in that case you win ;)
13:36:24 <jmcarthur> but Pair Void a only has _|_
13:36:42 <Funktorsalat> weird
13:36:42 <jmcarthur> i don't think it's ridiculous
13:37:21 <ski> `let x = Unit x in x' is `_|_'
13:37:29 <Funktorsalat> doesn't it contradict newtype erasability?
13:37:51 <Funktorsalat> ski: apparently not, if Pair (let x = Unit x) 1 isn't _|_
13:38:13 <Funktorsalat> in x, yes
13:38:29 <ski> Funktorsalat : with jmcarthur's `Pair' ?
13:40:10 <Funktorsalat> yes
13:40:11 <ski> with `data Pair a b = P !a !b' and `newtype Unit = U Unit', i think `P (fix U) True' is `_|_'
13:40:22 <ski> try it ?
13:40:26 <heatsink> I'm getting bottom
13:40:33 <Funktorsalat> jmcarthur: doesn't this give newtype some 'special status'?
13:40:47 <jmcarthur> huh, this seems to be not working, actually
13:40:49 <Funktorsalat> as in 'makes it possible to make a type that isn't isomorphic to one that can be made without newtypes'
13:40:53 <ski> jmcarthur :)
13:41:18 <jmcarthur> it seems to be forcing a newtype constructor, which seem to be against the spec. isn't it?
13:41:28 <ski> huh ?
13:41:28 <jmcarthur> because they shouldn't even exist
13:41:39 <ski> forcing `U x' of course forces `x'
13:41:46 <ski> because newtype constructors are strict
13:41:59 <jmcarthur> ski: newtype Foo = Foo Int ; case undefined of Foo _ -> "foo"   <-- why would that work but not this?
13:42:13 <jmcarthur> they aren't strict, otherwise what i just said would be _|_
13:42:18 <ski> (but merely matching `x' with `U y' doesn't force `x' .. that is the difference)
13:43:20 <ski> matching on a `newtype' constructor does not force, but using `seq', or a `!'-pattern, or `!'-marked fields (which both amounts to `seq') will force
13:43:25 <jmcarthur> bah
13:43:33 <jmcarthur> i see my error
13:43:47 <jmcarthur> so newtype is really nothing like agda's records then
13:43:56 <ski> if general `seq' was removed, then the results might be different
13:44:00 <jmcarthur> well
13:44:03 <jmcarthur> it still is i guess
13:44:06 <ski> `newtype' is not records, right :)
13:44:15 <jmcarthur> i bet recursive records in agda would do the same thing
13:44:24 <jmcarthur> if they were allowed, anyway
13:44:47 <ski> how does a record type (recursive or not) look like, in Agda2 ?
13:45:36 <jmcarthur> they are just values put together
13:45:43 <ski> i mean, syntactically
13:46:01 <jmcarthur> at the value level,  record { a = x; b = y }
13:46:06 <jmcarthur> record is a keyword there
13:46:24 <ski> .. so these are light-weight records, then ?
13:47:32 <jmcarthur> a record definition looks like:   record A : Set where { field { a : Bool; b : String } }    -- not sure how to put the indentation there so i just threw in {}
13:47:52 <jmcarthur> ski: what do you mean by light-weight?
13:47:56 <ski> (ok, so not light-weight, then)
13:48:18 <jmcarthur> they have their own types, if that's what you mean
13:48:20 <ski> "light-weight" meaning that you don't have to name and declare the types with a declaration
13:48:38 <ski> `data',`newtype' in Haskell are heavy-weight, while tuples are light-weight
13:48:55 <jmcarthur> ah, syntactic weight
13:49:10 <jmcarthur> :P
13:49:23 <ski> the Trex record system in Hugs is light-weight, you don't declare record types, you just use record values, and they get types inferred (and you can of course write them directly)
13:49:23 <jmcarthur> i think i understand what you mean though
13:49:43 <jmcarthur> here: http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Records
13:49:52 <ski> this is also how object, and polymorphic variants in OCaml works
13:50:00 <ski> (i.e. those are light-weight)
13:51:02 <jmcarthur> ski: http://www.cs.nott.ac.uk/~nad/listings/lib-0.4/Data.Unit.html#492
13:51:26 <jmcarthur> not recursive. i guess that's the difference between agda's unit and my newtype construction for it
13:51:53 <Funktorsalat> so I can go back to totally ignoring newtype ctor expressions and ctor patterns for reasoning purposes? :o
13:52:15 <jmcarthur> i guess reality is restored...
13:52:52 <Funktorsalat> (except that they make types match, obviously)
13:53:53 <litb> newtype is like a strong typedef
13:54:38 <litb> i heard newtypes cannot be used for instance declarations. but only data declarations can
13:54:54 <Funktorsalat> they can :)
13:54:59 <kmc> i think "newtype is a strong typedef" is a backwards way to think about it
13:55:10 <kmc> newtype is much closer to data than to type
13:55:21 <hpc> typedef as in C typedef
13:55:23 <hpc> i think
13:55:33 <kmc> to first approximation, it's a more efficient version of data that only applies in a subset of cases
13:55:36 <ski> litb : `type'-declared types can't be used in instance declarations (but see some extensions)
13:55:37 <kmc> and you can definitely write instances of newtypes
13:55:56 <kmc> yeah, the extensions just cause it to expand out the synonym in an instance declaration
13:55:56 <ski> `typedef' is pretty alike `type'
13:56:08 <kmc> you can't give the synonym a different instance from the thing it's a synonym for
13:56:12 <kmc> otherwise they wouldn't be synonyms
13:56:48 <ski> also, you can only partially apply a type synomym up to how much it was partially applied in the definition
13:59:10 <litb> ah, so "type" maps to "typedef" and "newtype" maps to  type + ability to write instance declarations
13:59:16 <kmc> not really
13:59:18 <litb> that makes sense, in a way
13:59:25 <litb> oh
13:59:28 <kmc> newtype makes a new type, type does not
13:59:34 <kmc> that's more fundamental than whether you can make an instance
13:59:34 <litb> ahh
13:59:47 <kmc> do you understand the difference between "type" and "data"?
13:59:54 <kmc> "newtype" is more like "data"
13:59:56 <litb> i see now!
14:00:14 <litb> newtype makes an entire new type
14:00:31 <kmc> as does "data"
14:00:33 <litb> yeah data is a tagged value
14:01:03 <kmc> some of the types you can declare with "data" could be declared with "newtype" instead
14:01:15 <kmc> namely, those with one constructor, which has one field
14:01:19 <litb> like data tree I = small I    and then when i write    small 0    the Int is tagged with  "small"
14:01:22 <kmc> you still introduce a new type and a constructor for it
14:01:34 <Funktorsalat> newtype *is* more like type though in that newtype Foo = Foo Bar is isomorphic to Bar though
14:01:42 <Funktorsalat> while data Foo = Foo Bar isn't
14:01:44 <kmc> Funktorsalat, only at runtime
14:01:48 <kmc> that's an implementation detail
14:01:55 <kmc> even though it's the motivation for including "newtype"
14:01:57 <Funktorsalat> conceptually too
14:02:09 <Funktorsalat> the data differentiates between Foo undefined and undefined
14:02:11 <kmc> you mean because it does not add more bottoms
14:02:12 <Funktorsalat> the newtype doesn't
14:02:12 <kmc> right
14:07:04 <pelotom> what's up with haskell.org?
14:07:19 <kmc> not much is 'up' about it
14:07:24 <pelotom> kmc: hehe
14:07:28 <heatsink> I thought it was only supposed to be down on Saturday.
14:07:58 <ski> still, it would be nice to have something like Hugs' restricted type synonyms <http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5> in GHC ..
14:08:04 <jmcarthur> type is an alias. newtype is a type. data is a tag and a type.
14:09:05 <jmcarthur> and apparently newtype Unit = Unit Unit is "OMGWTF_|_"
14:09:13 <kmc> but the constructor of newtype is still visible at source level
14:09:16 <kmc> so it's still tagged in a sense
14:09:19 <kmc> just not at runtime
14:09:23 <ski> `data' is a tag, together with a bunch of values (count depending on tag)
14:09:51 <Funktorsalat> now what's the difference between newtype and strict 1-field data again?
14:10:01 <Funktorsalat> I think there was some
14:10:03 <kmc> Funktorsalat, pattern-matching the newtype ctor has no operational meaning
14:10:05 <jmcarthur> Funktorsalat: that i can answer with certainty. the newtype would be irrefutable
14:10:07 <kmc> it is a no-op
14:10:15 <ski> Funktorsalat : matching on `newtype' constructors doesn't force
14:10:15 <Funktorsalat> ah right
14:10:23 <Funktorsalat> but they're isomorphic otherwise?
14:10:24 <kmc> pattern-matching the ctor of a strict 1-field data type will force the value itself
14:10:42 <jmcarthur> ^^ was the key detail i was missing earlier
14:11:48 <heatsink> (unsafeCoerce# () :: Unit) is non-bottom and, surprisingly, doesn't crash when you use it
14:12:10 <jmcarthur> heatsink: not that surprisingly to me
14:12:20 <jmcarthur> interestingly, though
14:12:26 <quintessence> Has anyone used hmatrix?  Using Numeric.LinearAlgebra.randomVector crashes GHCi for me but works fine when compiled.  Do I need to tell GHCi where to find some libraries or something?
14:13:19 <wagle> someone needs to put the status of haskell.org in the /topic
14:13:49 <heatsink> wagle: I'll tell Heffalump to do that a few hours ago.
14:14:05 <wagle> cool.. 
14:14:30 <wagle> except that i know its down, i wanted a guess as to when it'd be back up
14:14:37 <pelotom> are people asking why it's down every 5 minutes?
14:15:14 <wagle> i came in here a while ago, and there was nothing in the /topic, and people asking every N minutes
14:16:04 <wagle> oh well...
14:16:10 * wagle dies of curiosity
14:18:51 <ski> wagle : are you, perchance, a cat ?
14:19:25 <aristid> ski: always eliminate the most likely possibilities first. very good
14:19:35 <wagle> ski: I've been contemplating that
14:19:51 * ski purrs
14:20:59 <Cale> meow
14:21:46 <Cale> http://www.youtube.com/watch?v=bVZZ7wYjdwQ
14:22:34 <jmcarthur> wtf
14:23:50 <Twey> Cale: Haha
14:25:04 <az_ordog_maga> aloha haskellers
14:25:53 <ski> good evening
14:34:16 <pelotom> http://hackage.haskell.org/ is up, however... interestink
14:34:33 <wagle> different machine
14:34:34 <kmc> haskell.org stuff is hosted in a variety of places
14:34:37 <kmc> including yale and galois
14:34:44 <pelotom> ah
14:36:16 <Eduard_Munteanu> What happened, anyway?
14:40:14 <litb> what's the single most beautiful function definition you ever saw in haskell?
14:40:34 <hpc> :t (=~) -- :P
14:40:35 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
14:40:51 <wagle> main = main
14:41:03 <hpc> hehe
14:41:14 <Eduard_Munteanu> litb: boobs
14:41:17 <Eduard_Munteanu> :t (.) (.)
14:41:18 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
14:41:27 <diPython> lol
14:41:34 <hpc> wasn't there a "crunch" combinator on the wiki?
14:41:50 <hpc> it was something magical with (>>=) and (=<<) pointing at the same thing
14:42:02 <hpc> :t (>>=) (=<<)
14:42:03 <lambdabot> forall a (m :: * -> *) b b1. (Monad m) => ((m a -> m b) -> (a -> m b) -> b1) -> (a -> m b) -> b1
14:42:31 <litb> wait.  >>=  is  the  sequence op of monads. have never seen =<< tho
14:42:51 <litb> ah i think that's just the arguments flipped i think
14:42:53 <engla_>  it's just the flip
14:43:19 <wagle> :t (>>=)
14:43:20 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
14:43:27 <wagle> :t (=<<)
14:43:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
14:43:29 <litb> is there a function that can return true or false depending on whether two arguments have the same or a different type?
14:43:40 <hpc> :t (=<<) (>>=)
14:43:41 <lambdabot> forall (m :: * -> *) a b. (Monad m) => ((a -> m b) -> m a) -> (a -> m b) -> m b
14:43:47 <Eduard_Munteanu> hpc: combining those isn't that magical because one of them has to bind tighter I guess. So it's not what it looks like :)
14:43:55 <aavogt> @type \x y -> typeOf x == typeOf y
14:43:56 <lambdabot> forall a a1. (Typeable a, Typeable a1) => a -> a1 -> Bool
14:43:56 <pelotom> @let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) -- I always liked this one
14:43:57 <lambdabot>  Defined.
14:44:23 <litb> ohh
14:44:38 <hpc> @let wtf = (=<<) (>>=)
14:44:39 <litb> :t typeOf
14:44:39 <lambdabot>  Defined.
14:44:40 <lambdabot> forall a. (Typeable a) => a -> TypeRep
14:44:58 <hpc> how to test its properties....
14:44:59 <litb> so i suppose TypeRep is an instance of Eq
14:45:20 <Eduard_Munteanu> :t wtf
14:45:21 <lambdabot> forall a (m :: * -> *) b. (Monad m) => ((a -> m b) -> m a) -> (a -> m b) -> m b
14:45:36 <hpc> it looks like id, but i am not sure
14:45:41 <litb> you guys like playing with the type calculator xD
14:45:42 <hpc> er, no
14:46:02 <engla_> functions are often pretty in haskell
14:46:04 <hpc> hmm
14:46:28 <pelotom> @let a = (.) (.) (.) in let b = a a a in let c = b b b in let d = c c c
14:46:28 <lambdabot>   Parse error: KW_In
14:46:37 <litb> it starts to look like a triboob!
14:47:22 <pelotom> @let a = (.) (.) (.) in let b = a a a in let c = b b b in let d = c c c in d d d
14:47:22 <lambdabot>   Parse error: KW_In
14:47:50 <aristid> litb: hey little bear :P
14:47:57 <Eduard_Munteanu> @pl map (zip [1..])
14:47:57 <lambdabot> map (zip [1..])
14:47:59 <litb> i'm a let it be 
14:48:11 <hpc> :t let a = (.) (.) (.) in let b = a a a in let c = b b b in let d = c c c in d d d
14:48:12 <lambdabot> forall a a1 (f :: * -> *) a2 (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) a3 (f6 :: * -> *) a4 (f7 :: * -> *) (f8 :: * -> *) (f9 :: * -> *) (f10 :: * -> *) (f11 :: * ->
14:48:12 <lambdabot> *) a5 (f12 :: * -> *) a6 (f13 :: * -> *) (f14 :: * -> *) (f15 :: * -> *) (f16 :: * -> *) (f17 :: * -> *) a7 a8 a9 b a10 (f18 :: * -> *) a11 (f19 :: * -> *) (f20 :: * -> *) (f21 :: * -> *) (f22 :: * -
14:48:12 <lambdabot> > *) a12 (f23 :: * -> *) a13 (f24 :: * -> *) (f25 :: * -> *) (f26 :: * -> *) (f27 :: * -> *) (f28 :: * -> *) a14 (f29 :: * -> *) a15 (f30 :: * -> *) (f31 :: * -> *) (f32 :: * -> *) (f33 :: * -> *) (
14:48:12 <lambdabot> f34 :: * -> *) a16 (f35 :: * -> *) (f36 :: * -> *) (f37 :: * -> *) (f38 :: * -> *) (f39 :: * -> *) a17 (f40 :: * -> *) a18 (f41 :: * -> *) (f42 :: * -> *) (f43 :: * -> *) (f44 :: * -> *) (f45 :: * ->
14:48:12 <lambdabot>  *) a19 (f46 :: * -> *) a20 (f47 :: * -> *) (f48 :: * -> *) (f49 :: * -> *) (f50 :: * -> *) (f51 :: * -> *). (Functor f37, Functor f36, Functor f35, Functor f39, Functor f38, Functor f46, Functor
14:48:14 <lambdabot> [8 @more lines]
14:48:16 <pelotom> :t let a = (.) (.) (.) in let b = a a a in let c = b b b in let d = c c c in d d d
14:48:17 <lambdabot> forall a a1 (f :: * -> *) a2 (f1 :: * -> *) (f2 :: * -> *) (f3 :: * -> *) (f4 :: * -> *) (f5 :: * -> *) a3 (f6 :: * -> *) a4 (f7 :: * -> *) (f8 :: * -> *) (f9 :: * -> *) (f10 :: * -> *) (f11 :: * ->
14:48:18 <lambdabot> *) a5 (f12 :: * -> *) a6 (f13 :: * -> *) (f14 :: * -> *) (f15 :: * -> *) (f16 :: * -> *) (f17 :: * -> *) a7 a8 a9 b a10 (f18 :: * -> *) a11 (f19 :: * -> *) (f20 :: * -> *) (f21 :: * -> *) (f22 :: * -
14:48:19 <Eduard_Munteanu> wtf?!
14:48:19 <hpc> oh god
14:48:20 <lambdabot> > *) a12 (f23 :: * -> *) a13 (f24 :: * -> *) (f25 :: * -> *) (f26 :: * -> *) (f27 :: * -> *) (f28 :: * -> *) a14 (f29 :: * -> *) a15 (f30 :: * -> *) (f31 :: * -> *) (f32 :: * -> *) (f33 :: * -> *) (
14:48:20 <aristid> litb: but "little bear" is much cuter.
14:48:22 <lambdabot> f34 :: * -> *) a16 (f35 :: * -> *) (f36 :: * -> *) (f37 :: * -> *) (f38 :: * -> *) (f39 :: * -> *) a17 (f40 :: * -> *) a18 (f41 :: * -> *) (f42 :: * -> *) (f43 :: * -> *) (f44 :: * -> *) (f45 :: * ->
14:48:23 <litb> hahaha
14:48:24 <lambdabot>  *) a19 (f46 :: * -> *) a20 (f47 :: * -> *) (f48 :: * -> *) (f49 :: * -> *) (f50 :: * -> *) (f51 :: * -> *). (Functor f37, Functor f36, Functor f35, Functor f39, Functor f38, Functor f46, Functor
14:48:25 <pelotom> wheee
14:48:26 <lambdabot> [8 @more lines]
14:48:34 <kmc> urk
14:48:35 <aristid> do NOT do this again
14:48:47 <Eduard_Munteanu> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
14:48:48 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b (f2 :: * -> *). (Functor f, Functor f1, Functor f2) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
14:48:58 <kmc> @remember hpc :t let a = (.) (.) (.) in let b = a a a in let c = b b b in let d = c c c in d d d
14:48:58 <lambdabot> It is stored.
14:49:11 <aavogt> litb: also something like this (which doesn't do what's expected all the time) http://hpaste.org/41473/typeeq_mptc
14:49:15 <hpc> :D
14:49:21 <Eduard_Munteanu> I think it's been a long time since somebody pulled off something like that.
14:49:24 <aavogt> but it does work with any type
14:50:21 <dom96> wow
14:50:33 <engla_> it only "works" with any type
14:50:38 <litb> now someone come and calculate such a type. can any human do that?
14:50:43 <litb> or is it too complicated?
14:50:44 <tomh> @src head
14:50:44 <lambdabot> head (x:_) = x
14:50:44 <lambdabot> head []    = undefined
14:50:48 <tomh> @src groups
14:50:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
14:50:50 <tomh> @src group
14:50:50 <lambdabot> group = groupBy (==)
14:50:54 <litb> aavogt: ohh
14:50:59 <tomh> @src groupBy
14:51:00 <lambdabot> groupBy _  []       =  []
14:51:00 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
14:51:00 <lambdabot>     where (ys,zs) = span (eq x) xs
14:51:19 <tomh> @src span
14:51:20 <lambdabot> span _ xs@[]                     =  (xs, xs)
14:51:20 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
14:51:20 <lambdabot>                   | otherwise    =  ([],xs)
14:52:18 <engla_> Can we advice everyone to use /query when abusing the lambdabot ?
14:52:35 <heatsink> what does /query?
14:52:41 <Eduard_Munteanu> @vixen I think you like being abused.
14:52:42 <lambdabot> yeah, i like
14:52:43 <engla_> private sessions with the bot
14:52:56 <pelotom> engla_: that wouldn't be nearly as sociable!
14:53:04 <litb> so it does a partial order on instance declarations to try and fit to the best instance?
14:53:19 <engla_> pelotom: some uses of the bot are social, some are just antisocial..
14:53:25 * Eduard_Munteanu thinks pelotom enjoys gangbangs.
14:53:25 <heatsink> we should abuse her privately?
14:53:29 <tomh> engla_, sorry, if haskell.org is up again I can go there for that stuff :)
14:53:58 <engla_> tomh: apt-get ghc6-doc  if you can
14:54:02 <litb> who of you is active on SO?
14:54:09 <jmcarthur> > 0.0 == (-0.0)
14:54:09 <tomh> engla_, I run windows
14:54:10 <lambdabot>   True
14:54:16 <jmcarthur> > 1/0.0 == 1/(-0.0)
14:54:17 <lambdabot>   False
14:54:25 <Eduard_Munteanu> I haven't been on Stack Overflow for some time.
14:54:26 <jmcarthur> thanks floating point
14:54:34 <litb> > 1/0.0
14:54:35 <lambdabot>   Infinity
14:54:41 <hpc> > 1/-0.0
14:54:41 <lambdabot>   Not in scope: `/-'
14:54:47 <litb> :P
14:54:47 <hpc> > 1/(-0.0)
14:54:48 <lambdabot>   -Infinity
14:55:06 <hpc> the funny thing is, float has a negative zero
14:55:09 <jmcarthur> yeah
14:55:10 <hpc> (-0.0)
14:55:10 <Eduard_Munteanu> > 1/0.000000000000000000001
14:55:11 <lambdabot>   1.0000000000000001e21
14:55:14 <jmcarthur> but 0 and -0 are equal
14:55:15 <hpc> > (-0.0)
14:55:16 <lambdabot>   -0.0
14:55:18 <Eduard_Munteanu> Grr.
14:55:23 <jmcarthur> > 0 == (-0)
14:55:24 <lambdabot>   True
14:55:25 <jmcarthur> > 0 == (-0.0)
14:55:26 <lambdabot>   True
14:55:36 <Makoryu> > (-0.0) == (0.0 :: Float)
14:55:37 <lambdabot>   True
14:55:39 <litb> if they are equal why are they not equal when appearing as a denominator
14:55:42 <Eduard_Munteanu> > 1/0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001
14:55:43 <lambdabot>   1.0e119
14:55:44 <jmcarthur> exactly
14:55:49 <Makoryu>  â”(ã€€Â´ã€°`)â”Œ 
14:55:53 <jmcarthur> litb: it's because floating point is horrible
14:55:59 <litb> haha
14:56:01 <heatsink> I started using SO a bit
14:56:21 <pelotom> because that's how their Eq instance is defined?
14:56:57 <jmcarthur> IMO if a == b then you should be able to use a in place of b in any expression and get the same result
14:57:05 <jmcarthur> as an ideal
14:57:10 <engla_> litb: you expect something sensible  to come out after you divide by zero?
14:57:33 <jmcarthur> > 1/0
14:57:34 <lambdabot>   Infinity
14:57:35 <pelotom> > (1/0) == (1/0)
14:57:36 <lambdabot>   True
14:57:36 <danharaj> Float should not have a Num class
14:57:46 <jmcarthur> danharaj: Num has no laws
14:57:51 <pelotom> to me, that right there is kind of absurd
14:57:54 <jmcarthur> if Num had laws i would agree
14:58:00 <jmcarthur> depending on the laws
14:58:11 <pelotom> comparing infinities is silly
14:58:14 <danharaj> Num has Eq, and Equality is not equality unless it satisfies Leibniz' rule
14:58:24 <dancor> :t 1/0
14:58:25 <lambdabot> forall t. (Fractional t) => t
14:58:32 <jmcarthur> dancor: Num should not require Eq
14:58:35 <jmcarthur> oops
14:58:36 <Eduard_Munteanu> danharaj: what's that?
14:58:38 <Makoryu> > (1/0) == (-1/0)
14:58:38 <lambdabot>   False
14:58:39 <jmcarthur> danharaj: ^^
14:58:43 <Makoryu> ï¼ˆã€€Â°â€¿â€¿Â°ï¼‰
14:58:51 <dancor> > (1/0) == (2/0)
14:58:51 <lambdabot>   True
14:59:01 <Eduard_Munteanu> I imagine you could think of Eq as any equivalence relation.
14:59:18 <jmcarthur> if only
14:59:26 <pelotom> (1/0) == (2.3 / 0.0)
14:59:27 <danharaj> Eduard_Munteanu: Symmetric, reflexive, transitive
14:59:29 <litb> engla_: well i would either expect it to clearlyl say "oh you are silly see what you've done!" or that it yields the same result in both cases :)
14:59:30 <pelotom> > (1/0) == (2.3 / 0.0)
14:59:31 <lambdabot>   True
14:59:47 <Eduard_Munteanu> danharaj: oh, an equivalence.
14:59:47 <Phyx-> :t \t -> foldr map . zipWith map t []
14:59:48 <lambdabot> forall b a. [a -> b] -> [[b -> b] -> [b]]
14:59:51 <Phyx-> why does lambdabot typecheck that?
14:59:57 <Phyx-> ghci doesn't
14:59:59 <danharaj> http://en.wikipedia.org/wiki/Identity_of_indiscernibles
15:00:04 <Eduard_Munteanu> danharaj: thanks
15:00:10 <jmcarthur> the problem could also be solved in this case by making 0.0 == (-0.0)
15:00:11 <dancor> is Inf,-Inf,NaN,(no other Inf) built into Fractional, or is it just defaulting to Double here?
15:00:25 <jmcarthur> dancor: it's a Float and Double thing
15:00:28 <dancor> ok
15:00:36 <Phyx-> Oh ffs...
15:00:38 <danharaj> Leibniz' law is actually stronger than an equivalence
15:00:42 <Phyx-> (.) == fmap in lambdabot
15:00:47 <Eduard_Munteanu> danharaj: yeah, I was just about to say that.
15:00:59 <danharaj> It is equivalent to what jmcarthur would like.
15:01:03 <jmcarthur> heh
15:01:05 <jmcarthur> yes
15:01:17 <Phyx-> can I ask, what's the rational for making (.) = fmap?
15:01:24 <jmcarthur> i said something wrong though
15:01:33 <jmcarthur> *by making 0.0 /= (-0.0)
15:01:39 <dancor> Phyx-: it's a ploy to make error messages unreadable </flamebait>
15:01:39 <jmcarthur> that would fix this
15:01:44 <litb> @src fmap
15:01:44 <lambdabot> Source not found. My pet ferret can type better than you!
15:01:55 <jmcarthur> > 1/0 :: CReal
15:01:55 <danharaj> @src (.)
15:01:55 <litb> lol
15:01:55 <lambdabot> (f . g) x = f (g x)
15:01:55 <lambdabot> NB: In lambdabot,  (.) = fmap
15:01:58 <lambdabot>   mueval-core: Time limit exceeded
15:02:00 <pelotom> (.) is a less general version of fmap
15:02:18 <jmcarthur> :t (.)
15:02:18 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:02:25 <Phyx-> dancor, pelotom yes, but it's confusing, it typechecks more
15:02:25 <danharaj> :t fmap
15:02:25 <jmcarthur> in lambdabot they are equally general
15:02:26 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:02:28 <Eduard_Munteanu> :t (->)
15:02:29 <lambdabot> parse error on input `->'
15:02:40 <Phyx-> things that wouldn't typecheck if not for the functor instance on (-> a)
15:02:44 <hpc> :k (->)
15:02:45 <lambdabot> ?? -> ? -> *
15:02:47 <fengshaun> what does forall mean in type signatures?
15:02:50 <hpc> (->) has no constructor
15:02:56 <Eduard_Munteanu> Nah, I was rather thinking of Category.
15:03:08 <danharaj> forall means polymorphic in that variable
15:03:08 <litb> wait, my ghci says   (.) :: (b -> c) -> (a -> b) -> a -> c   so it seems to be more general since it doesn't presuppose a specific class
15:03:23 <Eduard_Munteanu> fengshaun: it's implicit
15:03:26 <fengshaun> danharaj, oh alright
15:03:36 <twanvl> ?type (Control.Category..)
15:03:37 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
15:03:39 <fengshaun> that makes sense
15:03:44 <dancor> Phyx-: redefining (.) to fmap is one of those things some ppl think would be a better trade-off of power/danger than the status quo.
15:03:46 <danharaj> yeah, you don't see it unless you use an extension. they're used for more advanced type signatures.
15:03:53 <kmc> fengshaun, in standard Haskell you don't write "forall"; it simply assumes all variables you mention are polymorphic
15:04:09 <dobblego> I am in favour of fmap being 4 times shorter in its name
15:04:10 <kmc> fengshaun, but GHC supports some type system extensions which can't be represented in that way
15:04:10 <Phyx-> litb: it's less general because the fmap instance can "compose" anything that's a function almost
15:04:16 <Phyx-> (id . (+))
15:04:19 <monochrom> haha 4 times shorter
15:04:19 <kmc> so ghc supports this "forall" keyword, for writing those types
15:04:23 <litb> ohh
15:04:32 <fengshaun> kmc, oh interesting, thanks!
15:04:41 <hpc> :t (id .)
15:04:42 <danharaj> kmc: it also assumes that the variable ranges across the entire signature.
15:04:42 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
15:04:53 <danharaj> So forall lets you actually explicitly scope a polymorphic variable, getting higher rank types.
15:05:04 <Phyx-> yup
15:05:07 <Eduard_Munteanu> kmc: it does make me wonder why 'forall' existed way before existentials and rank-2/n types.
15:05:25 <Eduard_Munteanu> It looks like gratuitous sugar.
15:05:45 <danharaj> it isn't sugar
15:05:53 <danharaj> the lack of forall is sort of a sugar
15:05:54 <pelotom> it's desugar
15:05:57 <Eduard_Munteanu> danharaj: isn't it sugar for "nothing"?
15:06:10 <Eduard_Munteanu> Oh.
15:06:16 <Phyx-> isn't it also to explicitly say that all the variables it binds are the same one
15:06:16 <danharaj> no, because haskell gets compiled to some variant of system f which has explicit foralls.
15:06:32 <kmc> in GHC it does
15:06:52 <Phyx-> in any Haskell compiler with higher-rank types it does
15:06:54 <danharaj> kmc: isn't haskell's semantics defined in terms of lambda calculus?
15:06:57 <Eduard_Munteanu> System F-omega is theoretical, it doesn't mean the implementation _has_ to do that.
15:07:08 <jmcarthur> grr. i hate it when an implementation just barely doesn't fit a semantic model
15:07:31 <kmc> danharaj, i don't know
15:07:33 <kmc> you could look it up
15:07:34 <danharaj> jmcarthur: if this were a c chat room we would all be flaming you for your desire for things to make sense.
15:07:37 <danharaj> kmc: I could. :p
15:07:40 <Phyx-> in any Haskell compiler with higher-rank types it does
15:07:43 <Phyx-> oops
15:07:44 <Phyx-> sorry
15:07:46 <danharaj> But now I recall haskell doesn't really have a denotational semantics.
15:07:48 <Phyx-> wrong black window
15:07:52 <Eduard_Munteanu> danharaj: say "trust me" :P
15:07:54 <danharaj> So I doubt myself.
15:08:04 <jmcarthur> model: Bool. implementation: R. semantics: (<=0). everything seems to work except for not, which fails when the value in the implementation is 0
15:08:38 <danharaj> jmcarthur: is it intuitionistic logic?
15:09:15 <jmcarthur> is what intuitionistic logic?
15:09:32 <danharaj> the thing you're modelling?
15:09:35 <jmcarthur> no
15:09:38 <danharaj> kay
15:09:57 <jmcarthur> i'm modelling Bool :P
15:10:19 <danharaj> you need to use a discrete topological space :p
15:10:39 <jmcarthur> i need to learn topology :\
15:10:52 * Eduard_Munteanu feels like whining about how TAPL's chapter on simply-typed lambda calculus was written in a hurry... :(
15:10:55 <ddarius> Eduard_Munteanu: GHC didn't have forall before existentials/rank-n types, except I don't think there was a time when GHC ever didn't have at least rank-2 types.
15:11:17 <Cale> Eduard_Munteanu: Was it?
15:11:22 <Eduard_Munteanu> ddarius: I see. Thanks, makes sense now.
15:11:26 <dons> hmm. rank-2 has been around since 1992 or so
15:11:30 <dons> the ST paper.
15:11:38 <Eduard_Munteanu> Cale: I had a hard time understanding the |- thingy.
15:12:25 <ddarius> Eduard_Munteanu: Also, System Fw isn't somehow specified as being the semantics of Haskell.  Core GHC just happens (by construction) to be rather similar to a variant of System Fw.
15:12:27 <Cale> Eduard_Munteanu: Gamma |- P  means that the statement P can be derived from the set of statements Gamma
15:12:29 <Eduard_Munteanu> Cale: no actual definition, not in the index, I even browsed backwards to see if it was defined somewhere else :/. I actually had to infer its meaning from wikipedia.
15:12:32 <jmcarthur> danharaj: anyway, i was seeing if Double's Eq instance distinguished between 0 and -0 for this reason. it doesn't, but it does between Infinity and -Infinity, so... :P
15:12:32 <Cale> hmm
15:13:07 <jmcarthur> but relying on Double to formally satisfy this model is... not a good idea :)
15:13:17 <Eduard_Munteanu> Cale: yeah, I now know. But I still have to wonder whether it's much different from ------------
15:13:27 <Eduard_Munteanu> or just a convenient way of writing that stuff.
15:13:31 <Cale> Eduard_Munteanu: It's not, it's really just a horizontal notation for that line.
15:13:38 <pelotom> > (1/0) == (1/(-0))
15:13:39 <lambdabot>   False
15:13:52 <Eduard_Munteanu> Cale: thanks, it makes sense now.
15:13:53 <danharaj> |- and horizontal lines can be used for different things at the same time too though
15:14:01 <danharaj> but they are just dividers
15:14:05 * jmcarthur is using mmm-mode with pandoc and literate haskell and loving it
15:14:21 <jmcarthur> oh, and i have added agda-mode's latex input stuff into this as well
15:14:27 <jmcarthur> :D
15:14:47 <jmcarthur> markdown ftw
15:15:26 <Cale> Eduard_Munteanu: They sort of introduce it on page 101
15:15:28 <Eduard_Munteanu> Yeah, I wish they defined it accurately instead of showing a typing rule and intermixing explanations with discussion of the rule.
15:15:39 <Cale> Eduard_Munteanu: Actually, in a slightly different manner than I talked about it...
15:15:58 <kmc> Eduard_Munteanu, âŠ¢ is little more than a tuple's comma.  when you have a box full of rules, you're describing an n-ary relation
15:16:05 <Cale> Eduard_Munteanu: They define a 3-ary typing relation which is written Gamma |- t : T
15:16:16 <Cale> That is, you can't have the |- without also having a :
15:16:21 <kmc> we may write that relation " Î“ âŠ¢ e : t " but you can think "(Î“, e, t)"
15:16:42 <Cale> Though in a more general setting |- would have a meaning on its own.
15:16:46 <kmc> and the rules collectively say which tuples (Î“,e,t) must be in the relation, based on which other tuples are
15:16:48 <Eduard_Munteanu> Cale: yeah, it wasn't clear to me that was a definition or just assuming |- was prior knowledge.
15:18:31 <hpc> @hoogle readfile
15:18:31 <lambdabot> Prelude readFile :: FilePath -> IO String
15:18:31 <lambdabot> Data.ByteString readFile :: FilePath -> IO ByteString
15:18:32 <lambdabot> System.IO readFile :: FilePath -> IO String
15:18:45 <hpc> *grumbles something about haskell.org*
15:19:15 <Cale> They also sort of skim over exactly the rules for the context extension operation, though they do say that Gamma is a set (it's important that it's not simply a list)
15:19:38 <Eduard_Munteanu> kmc: is that square in " âŠ¢ is little more than" a |- ?
15:19:47 <Cale> Eduard_Munteanu: yes
15:19:55 <Eduard_Munteanu> I see.
15:20:09 <Cale> Eduard_Munteanu: (your font must not have that unicode character)
15:20:23 <Eduard_Munteanu> Yeah, DejaVu mono here, works for most stuff though.
15:20:59 <pelotom> hpc: google cache is your friend
15:21:11 <Eduard_Munteanu> Cale: you mean it's important because ordering doesn't matter?
15:21:16 <hpc> pelotom: it can cache a cgi? :P
15:21:41 <pelotom> hpc: ah, well no :P
15:21:44 <hpc> (i would be surprised if it cached search queries, rather than just the page itself)
15:21:48 <engla_> if the cgi is pure..
15:22:11 * Eduard_Munteanu also shamelessly skipped over the implementation chapters for now
15:30:04 <ricree> what function converts from Int to Integer?
15:30:04 <republican_devil> hi is there anything like redis in haskell? a distributed in memory store that si not simply key value but can be data structure too?
15:30:13 <republican_devil> http://code.google.com/p/redis/wiki/TwitterAlikeExample
15:30:26 <Phyx-> :t toInteger
15:30:27 <lambdabot> forall a. (Integral a) => a -> Integer
15:30:29 <kmc> republican_devil, http://hackage.haskell.org/package/redis
15:30:36 <kmc> :t fromIntegral
15:30:37 <lambdabot> forall a b. (Integral a, Num b) => a -> b
15:31:09 <ricree> thank you
15:32:11 --- mode: ChanServ set +o mauke
15:32:24 --- mode: mauke set +b $a:republican_devil
15:33:22 <joe6> haskell.org seems to be still down. Is it so for you folks too?
15:34:24 --- mode: mauke set -o mauke
15:34:30 <thom_logn> yup, down
15:35:15 <Phyx-> joe6: isn't this the second time you're asking?
15:35:21 <Phyx-> it's even in the topic :(
15:35:45 <applicative> jmcarthur , the sub-sub-section crisis hasn't caused you to throw out pandoc + lhs?  
15:35:46 <monochrom> sorry I'm a newbie to irc
15:35:52 <applicative> http://groups.google.com/group/pandoc-discuss/browse_thread/thread/3c0a101695f3cff8
15:36:03 <jmcarthur> applicative: yeah it does suck. it already bit me once
15:36:27 <jmcarthur> applicative: but i don't tend to have very deep sections
15:36:34 <applicative> haha, I see. I wasn't sure what to make of it, since I don't write lhs 
15:36:58 <jmcarthur> i have a little sed script i could run to replace ~~~ with ### for pandoc if i needed to
15:37:25 <Phyx-> monochrom: ah, did you lose an "e" ?
15:37:30 <jmcarthur> it's actually silly to even call it a script :P
15:37:48 <applicative> oh, maybe you should chime in.  secretly, i'd like deeper setext headers just because I like them better than # ## ### ...
15:37:59 <jmcarthur> yeah
15:38:07 <monochrom> I don't know. you mean I should say "newbiee"? :)
15:38:08 <jmcarthur> ------- and ======= are nice
15:39:00 <applicative> if the conditions are right, I sometimes 'tidy' my codeless markdown with pandoc -r markdown -w markdown+lhs to get setext headers
15:40:19 * hackagebot webkit 0.12.1 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.1 (AndyStewart)
15:41:11 <jmcarthur> heh
15:42:12 <nostard> what does "entries" mean in a profile from GHC?
15:44:26 <kmc> more context?
15:47:32 <ddarius> Milner learned Lisp from Diffie who (with Milner) was part of the original LCF team.
15:50:33 <joe6> Phyx: sorry, I just got onto the computer. I was away since afternoon.
15:50:43 <joe6> i may asked this morning.
15:51:04 <joe6> Phyx: just checked the topic and I see it there.
15:51:04 <Phyx-> nah, dw, i'm just being a jerk :P
15:52:06 <sohum> hm. I now know why the haskell and ml communities are so tied to academia.
15:52:39 <kmc> why is that?
15:52:40 <sohum> It gives you an /incredible/ amount of legitimacy when you say something like "Haskell totally does this thing that I know because I've played around with it \cite{haskell98book}"
15:53:00 <sohum> :P
15:53:10 <kmc> i don't follow, how is that different from citing the C++ spec or the Python manual?
15:53:27 <danharaj> @pl (\t t' -> f (g t t'))
15:53:27 <lambdabot> (f .) . g
15:53:35 <danharaj> :t (f .)
15:53:36 <lambdabot> forall a b (f :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f) => f a -> f b
15:53:58 <sohum> well, it's a bootstrapping thing
15:54:12 <danharaj> :t (.)
15:54:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:54:45 <sohum> the c++ and python cite-targets aren't cited as much in their specific communities (afaik) and thus don't grant as much legitimacy and thus aren't cited as much...
15:54:49 <kmc> is the idea that only academics care about defining a language more rigorously than "whatever the Perl 5.4.1 interpreter happens to accept"?
15:55:11 <kmc> if you go to ##c++ i think you will see lots of C++ language-lawyers referencing the spec
15:55:16 <kmc> which is a monstrously huge tome
15:55:22 <jmcarthur> haskell isn't all that rigorously defined either, in all honesty. it has a spec, but it's pretty informal
15:55:26 <bremner> sohum: go to ##C++ and the whole conversation is a mix of the C++ standard and vitriol
15:55:48 <kmc> SML and Scheme are the only mainstream-ish languages i know of that have a formal semantics
15:56:06 <sohum> yes, but an IRC channel doesn't grant the same bootstrappingness that the rich academic community around haskell does
15:56:09 <kmc> though many third parties have e.g. written formal semantics for C, as part of a verified compiler project
15:56:10 <sohum> jeez, this was a joke
15:56:20 <kmc> i didn't get the joke
15:56:22 <kmc> sorry
15:56:25 <jmcarthur> sohum: nothing is a joke in #haskell ;)
15:56:29 <sohum> :P
15:56:33 <Cale> Eduard_Munteanu: Yes, sorry about being slow to answer. :)
15:56:53 <Eduard_Munteanu> Cale: oh, no problem at all.
15:57:48 <Cale> Eduard_Munteanu: One might naively think that the manner in which contexts are extended or decomposed with the comma means that Gamma is some term with an ordering on its elements, but it's not. :)
15:58:29 <kmc> sohum, my experience is that the majority of programmers see that "rich academic community" as a net negative
15:58:36 <LegendaryPenguin> is there a command to see the implementation of functions
15:58:51 <kmc> LegendaryPenguin, lambdabot has @src for some things
15:59:02 <LegendaryPenguin> oh
15:59:07 <kmc> which occasionally lies
15:59:09 <danharaj> is there any blog post about sections of composition? (.)
15:59:16 <danharaj> because it looks useful but I can't parse it in my head >:|
15:59:20 <kmc> it's not necessarily the "real" implementation
15:59:26 <kmc> LegendaryPenguin, and the docs at http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ have source hyperlinks
15:59:32 <kmc> as do docs for each package on hackage
15:59:51 <Cale> Yeah, the @src command just reads possible implementations of things from a text file. Those implementations are usually chosen for didactic reasons rather than performance or anything else.
15:59:54 <kmc> but www.haskell.org is down
15:59:57 <kmc> :/
16:00:09 <sohum> kmc: oh, ofc they do. most people today have this disdain for what they term ivory-tower thinking
16:00:52 <Eduard_Munteanu> Cale: yeah, I understand.
16:01:07 <LegendaryPenguin> itd be nice if ghci had some command
16:01:11 <Eduard_Munteanu> The "comma on the right thing" doesn't really make sense.
16:01:20 <danharaj> :t (f.) . g
16:01:20 <Cale> In GHCi, you can  :list foo  to print the source code for  foo  if that code is being interpreted. The source code for compiled modules obviously isn't available.
16:01:21 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Show a, SimpleReflect.FromExpr b, Functor f, SimpleReflect.FromExpr (f1 (f a)), Functor f1) => f1 (f b)
16:01:32 <Cale> That means that most stuff won't have source.
16:01:35 <jmcarthur> sohum: people make me sad
16:01:51 <sohum> jmcarthur: sad makes me people
16:01:55 <sohum> jmcarthur: wait, what?
16:02:21 <Cale> Eduard_Munteanu: Gamma, x essentially means the union of Gamma with the one element set x
16:02:38 <danharaj> @pl (\(x, t') -> ((g t t'), t'))
16:02:38 <lambdabot> ((,) =<< g t) . snd
16:02:41 <Cale> Or, the one element set {x}, rather.
16:02:51 <danharaj> geeze, @pl is voodoo
16:02:53 <copumpkin> djahandarie: allo
16:02:54 <danharaj> that makes my code look bloated.
16:03:13 <danharaj> also I don't understand the things it is telling me.
16:03:16 <sohum> @pl is awesome
16:03:16 <lambdabot> (line 1, column 4):
16:03:16 <lambdabot> unexpected "\STX"
16:03:16 <lambdabot> expecting variable, "(", operator or end of input
16:03:18 <Cale> danharaj: I would go with the lambda there.
16:03:33 <danharaj> Cale: yeah, but the previous one with (f.) . g looks pretty
16:03:36 <danharaj> but I can't parse it
16:03:57 <Cale> danharaj: Oh, that's an operator section
16:03:59 <sohum> what was that blog post with result = . and so on?
16:04:13 <Cale> danharaj: Just like (2*) is the function which multiplies its parameter by 2
16:04:17 <danharaj> yeah I know
16:04:22 <danharaj> but sections of composition break my head
16:04:29 <Cale> I find it easiest to think of them as fmap
16:04:41 <danharaj> fmap of what functor?
16:04:44 <Cale> So think of  (f .) . g  as being  fmap f . g
16:04:50 <Cale> The function functor
16:04:57 <Cale> (->) e
16:04:57 <danharaj> covariant or contra?
16:05:01 <danharaj> ah
16:05:01 <Cale> covariant
16:05:14 <danharaj> let me guess something...
16:05:22 <Cale> (All Functor instances in Haskell must be covariant)
16:05:37 <Cale> So yeah, if you're familiar, it's Hom(e,-)
16:05:37 <danharaj> @pl (\t t' -> f ( g (h t t')))
16:05:38 <lambdabot> ((f . g) .) . h
16:05:49 <tomh> in what lib is the function list?
16:06:02 <Cale> tomh: ?
16:06:05 <danharaj> @pl (\t t' t'' -> f $ g $ h t t' t'')
16:06:05 <lambdabot> (((f . g) .) .) . h
16:06:21 <tomh> can lambdabot do hoogle?
16:06:29 <sohum> @hoogle a -> a
16:06:29 <lambdabot> Prelude id :: a -> a
16:06:29 <lambdabot> Data.Function id :: a -> a
16:06:30 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
16:06:36 <danharaj> @pl (\t t' t'' -> f $ g t t' t'')
16:06:37 <lambdabot> ((f .) .) . g
16:06:48 <dobblego> \x y -> x `mplus` return y -- in the library somewhere?
16:06:49 <tomh> @hoogle list
16:06:49 <lambdabot> module Control.Monad.List
16:06:49 <lambdabot> module Data.List
16:06:49 <lambdabot> Language.Haskell.Syntax list_cons_name :: HsQName
16:06:49 <Cale> tomh: Do you know what type the function has?
16:07:02 <tomh> no, not yet
16:07:02 <Cale> tomh: (maybe ask ghci for it?)
16:07:07 <danharaj> how is hoogle working in irc but hoogle is down because haskell.org is down :o
16:07:08 <dobblego> @hoogle MonadPlus m => m a -> a -> m a
16:07:08 <lambdabot> Control.Monad mplus :: MonadPlus m => m a -> m a -> m a
16:07:09 <lambdabot> Data.Sequence (|>) :: Seq a -> a -> Seq a
16:07:09 <lambdabot> Data.Graph.Inductive.Internal.Queue queuePut :: a -> Queue a -> Queue a
16:07:17 <hpc> danharaj: hoogle is a package
16:07:26 <danharaj> oh
16:07:28 <danharaj> I see.
16:07:33 <ddarius> Cale: You may find Garret Sobczyk's "The Missing Spectral Basis in Algebra and Number Theory" interesting.
16:10:02 <Cale> tomh: Could it be the one from Data.MemoCombinators?
16:10:25 <danharaj> Cale: thanks. Seeing it that way makes everything better.
16:10:32 <tomh> mm i just see it in a paper
16:10:37 <tomh> but I just removed it temporary
16:10:39 <Cale> tomh: There's also one in Darcs.Commands.Show, Storage.Hashed.Tree, and Agda.TypeChecking.Primitive, out of the modules on my machine.
16:11:34 <nus> @where hayoo
16:11:34 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
16:11:50 <copumpkin> djahandarie: here, http://hpaste.org/41479/more_vec_crap
16:11:52 <Cale> danharaj: It's that sort of thing which makes me want to generalise (.) to fmap :)
16:12:15 <danharaj> Cale: I don't feel that way :p
16:12:38 <danharaj> Because function composition exists at two levels: at the 'meta' level if you think of Haskell as a category
16:12:56 <danharaj> and composition as a morphism in the category because we have internal hom objects.
16:13:15 <danharaj> and the conflation of (.) and fmap only works because we have that.
16:13:36 <Cale> danharaj: That's true of course.
16:14:09 <_xvinyl> hi everyone
16:14:16 <danharaj> hello
16:14:32 <_xvinyl> this is slightly offtopic, but do you happen to know if there is a tool similar to HLint, but for C code ?
16:14:48 <copumpkin> remove the H
16:14:49 <rickythesk8r> lint
16:14:52 <Cale> danharaj: The thing which really convinced me is that if we write the fusion law for fmap, specifically fmap (f . g) x = fmap f (fmap g x) replacing fmap by (.) gives us (f . g) . x = f . (g . x)
16:15:26 <jmcarthur> there's also splint, for the record
16:15:31 <Cale> So, we can always rely on (.) to behave associatively, whenever the associations make sense.
16:15:34 <_xvinyl> copumpkin: thanks... makes me feel stupid -_- was looking for "clint", but Clint Eastwood was first result by far
16:15:37 <_xvinyl> :)
16:15:41 <rickythesk8r> and Lindt in a gift box
16:16:05 <copumpkin> Saizan: you around?
16:16:13 <_xvinyl> jmcarthur: thanks
16:16:24 * copumpkin feels like the new typechecker in GHC 7 is smarter about the induction stuff
16:16:29 <danharaj> Cale: that's cool
16:16:30 <Cale> The jerk answer to _xvinyl's question would be "a bottle of aspirin"
16:16:47 <danharaj> the aspirin will tell you how to improve your C code?
16:16:56 <Cale> No, but you'll need it.
16:17:00 <danharaj> heh
16:17:13 <_xvinyl> wow, I didn't know this was such an old/used tool
16:17:14 <danharaj> We don't know what the tool is, but we do know it has a dependency on BottleOfAspirinLib
16:17:33 <kmc> programming in C is easy
16:17:37 <kmc> just think very hard and don't make any mistakes
16:17:49 <danharaj> yes, keep the entire state of the CPU and memory in your head at all times.
16:17:49 <ddarius> Cale: You might also find the article I'm reading now interesting: "From LCF to HOL: a short history"
16:17:59 <_xvinyl> danharaj: it's only numerical stuff so it's not that hard
16:18:24 <_xvinyl> danharaj: just have to get the computations right, but i wanted to make sure it was as portable as possible
16:18:28 <ddarius> copumpkin: You might find that article interesting as well.
16:18:48 <jmcarthur> copumpkin: how so?
16:18:50 <Cale> ddarius: I'm looking at that number theory paper now. :)
16:18:59 <nus> @type (>>>)
16:19:00 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
16:19:09 <adu> Cale: ooo number theory?
16:19:21 <Cale> <ddarius> Cale: You may find Garret Sobczyk's "The Missing Spectral Basis in Algebra and Number Theory" interesting.
16:22:20 <kadoban> so what's up with haskell.org?
16:22:33 <kmc> nothing is 'up' about it
16:22:40 <kmc> see topic
16:23:50 <copumpkin> IRC topics should be abolished
16:24:03 <sm> there was a short-notice electrical outage
16:24:14 <copumpkin> option 1: "what's up with X? is it down?" "yes, it's down, people are working on it." 
16:25:03 <copumpkin> option 2: "what's up with X?" is it down?" "yes, it's down, people are working on it. man people ask this a lot" ==> *change topic* ==> "what's up with X? is it down?" "YES IT'S DOWN, SEE TOPIC." "MAN, PEOPLE NEVER READ TOPICS !@?$>!%@!"
16:25:06 <ddarius> "The author 'Arthur J. Milner' of this book [Edinburgh LCF] was the result of a bug in the way Springer-Verlag created title pages"
16:25:12 <kmc> haskell.org will be down indefinitely.  Oracle has purchased the Haskell language and is planning to re-synergize it with their existing intellectual property portfolio of Java and MySQL
16:25:15 <copumpkin> ddarius: I'll check it out, thanks
16:26:05 <ddarius> kmc: The Haskell community hold no patents, what interest would Oracle see in acquiring it?
16:26:09 <kmc> i didn't mean to be all "RTFT NOOB", just a gentle pointer to information that may be useful in the future
16:26:32 <copumpkin> kmc: wasn't referring to you, it's just something I see a lot :) I guess you never notice the people who don't ask cause they did read the topic
16:26:40 <copumpkin> so I guess my conclusion isn't necessarily correct
16:26:42 <kmc> yeah
16:26:46 <kmc> i don't read the topic generally
16:26:49 <Eduard_Munteanu> Yeah, they're planning to make Has-queue-ell, and Haskell will be deprecated.
16:26:53 <kmc> but i might check it under such a circumstance
16:26:55 <kmc> but i might not ;P
16:27:01 <Eduard_Munteanu> They'll replace IO () with SELECT.
16:27:07 <ddarius> @google Hasql
16:27:08 <lambdabot> http://sproot.tripod.com/hasql.htm
16:27:08 <lambdabot> Title: HaSQL Project
16:27:10 <adu> Cale: ddarius: sounds like a Clifford/Cayley/Dickson thing
16:27:23 <Eduard_Munteanu> Ha.
16:27:33 <Cale> Why is www.haskell.org down? Any information on what went wrong yet?
16:27:48 <copumpkin> Cale: RTFT
16:27:50 <copumpkin> oh wait
16:27:53 <Eduard_Munteanu> :)
16:28:08 <Eduard_Munteanu> IRC conditioning.
16:28:45 <osaunders> *Whhhhhyyyyyy????
16:28:47 <Cale> http://www.flickr.com/photos/cgibbard/5170980387/#/photos/cgibbard/5170980387/lightbox/ - I like the reflections in this one :)
16:28:54 <ddarius> "Paulson and Huet then established a collaboration and did a lot of joint development of LCF by sending each other magnetic tapes in the post."
16:29:01 <ddarius> Internet 0.1
16:29:31 <ddarius> Cale: That is cool.
16:29:31 <Cale> Whenever I see LCF, I think of: http://en.wikipedia.org/wiki/LCF_notation
16:29:32 <joe6> > :t listOf
16:29:32 <lambdabot>   <no location info>: parse error on input `:'
16:29:46 <joe6> @hoogle listOf
16:29:46 <lambdabot> No results found
16:30:06 <joe6> @type listOf
16:30:07 <lambdabot> forall a. Gen a -> Gen [a]
16:31:12 <adu> Cale: what is that?
16:31:16 <osaunders> Cale: How were those made?
16:31:28 <Cale> Those are neodymium magnets
16:31:32 <Eduard_Munteanu> That looks a lot like polytopes :)
16:31:37 <copumpkin> jmcarthur: fewer type signatures necessary than here: http://www.mail-archive.com/haskell-cafe@haskell.org/msg60806.html
16:31:43 <copumpkin> jmcarthur: but I'm getting another error now
16:31:51 <copumpkin> I rewrote that from memory so I may have screwed it up though
16:31:52 <Eduard_Munteanu> Erm, stereographic projections of polytopes, rather.
16:32:05 <copumpkin> preflex: seen edwardk
16:32:05 <preflex>  edwardk was last seen on #haskell-blah 3 hours, 53 minutes and 28 seconds ago, saying: Roklobsta: most folks seem to be working on it out of desire to see something shipped, and for royalties and a song
16:32:13 <Cale> Most of my constructions are built from 2-layer hexagons which are then folded in some fashion, and then replicated symmetrically in various ways.
16:32:23 <joe6> i am searching for the listOf function? any thoughts on where I can find it?
16:32:29 <joe6> please
16:32:29 <Cale> (That is, hexagons built from 6*(1+2) magnets)
16:32:38 <monochrom> what is meant of listOf?
16:32:43 <copumpkin> joe6: you haven't told us what it is, what its type is
16:32:46 * monochrom has only heard of Liskov
16:32:48 <copumpkin> joe6: or anything about it
16:32:56 <djahandarie> copumpkin, wow, nice
16:32:59 <djahandarie> This got more complicated
16:33:00 <Cale> joe6: Test.QuickCheck?
16:33:00 <kmc> @hoogle listOf
16:33:01 <lambdabot> No results found
16:33:11 <Cale> Or Test.QuickCheck.Gen
16:33:13 <copumpkin> djahandarie: I added a typeclass that lets you inspect naturals
16:33:19 <Cale> listOf :: Gen a -> Gen [a]
16:33:19 <Cale> Generates a list of random length. The maximum length depends on the size parameter. 
16:33:43 <copumpkin> djahandarie: and that transpose function
16:33:49 <adu> Cale: wow
16:33:52 <joe6> I am checking out the code at http://jasani.org/2008/01/03/testing-haskell-with-quickcheck/, ext <- listOf $ elements ['a'..'z']
16:34:00 <copumpkin> then it's what Cale said
16:34:02 <joe6> it seems to generate a random list
16:34:12 <Cale> joe6: Right.
16:34:12 <joe6> oh, yes. exactly what Cale said.
16:34:22 <joe6> I was busy putting the links together.
16:34:25 <Cale> joe6: It turns a generator for single elements into a generator for lists.
16:34:26 <monochrom> you saw "import Test.QuickCheck.Gen
16:34:26 <monochrom> " didn't you?
16:35:13 <joe6> i tried the QuickCheck.Gen, but I am not sure if it is my system, I am not able to get to that module.
16:35:31 <Cale> If you like that construction of magnets, check out the rest of my photostream. I've been making a lot of stuff lately :)
16:35:32 <joe6>  Could not find module `Test.QuickCheck.Gen':
16:35:38 <djahandarie> copumpkin, I don't think I understand all of this haha
16:35:50 <copumpkin> djahandarie: what parts of it?
16:35:51 <monochrom> you probably haven't installed it.
16:35:51 <Cale> joe6: Perhaps you don't have QuickCheck installed, or not the right version.
16:36:04 <joe6> Cale: ok, thanks. will check for it.
16:36:10 <Cale> joe6: Do a ghc-pkg list QuickCheck to see
16:36:26 <djahandarie> copumpkin, what does witness do?
16:36:30 <joe6> Cale: will do, thanks.
16:36:46 <copumpkin> djahandarie: it gives you a value of any type-level Natural
16:36:55 <copumpkin> although it's kind of broken right now
16:36:56 <copumpkin> :P
16:37:47 <djahandarie> copumpkin, and what's the point of wrapping everything in the I newtype for that?
16:38:11 <majnemer> haskell.org down for anybody else?
16:38:13 <copumpkin> like the stuff with the folds we saw yesterday, the induction type expects a * -> *
16:38:17 <Eduard_Munteanu> Duh.
16:38:19 <Cale> majnemer: Yes.
16:38:30 <copumpkin> djahandarie: so the I gives it an * -> *
16:38:31 <djahandarie> Ah right I see now
16:38:38 <majnemer> Cale: cool, it's not just my connection then
16:38:50 <Eduard_Munteanu> majnemer: no, it has been like that since yesterday.
16:38:51 <Cale> majnemer: (The topic says so, but it would be silly to think that people would always read the topic :)
16:39:11 <djahandarie> copumpkin, is there any reason that we can't avoid that while Agda can?
16:39:27 <copumpkin> djahandarie: we don't get arbitrary type-level functions
16:39:34 <djahandarie> Why not?
16:39:39 <osaunders> Cale: Those are so cool. (I just saw the video of you assembling a small one.)
16:39:45 <copumpkin> because that breaks inference
16:39:56 <copumpkin> Agda doesn't care so much about inference
16:40:02 <copumpkin> but Haskell rather likes it
16:40:07 <Eduard_Munteanu> I think the reason is "because you can't write them".
16:40:08 <djahandarie> Hmm
16:40:42 <majnemer> in that case, are there mirrors for the distributions?
16:40:52 <copumpkin> djahandarie: http://www.mail-archive.com/haskell-cafe@haskell.org/msg60806.html is where I got started with all this stuff
16:40:54 <Cale> osaunders: Yeah. I love the company that I bought them from too (zenmagnets.com) because they keep sending me free sets for submitting pictures to their gallery. I get a free set of 216 for each 3 pictures they accept.
16:41:00 <Eduard_Munteanu> majnemer: Hackage works though.
16:41:19 <Eduard_Munteanu> What distributions? Haskell Platform?
16:41:22 <copumpkin> djahandarie: that's what got me into more interesting haskell types and eventually agda :P
16:41:27 <copumpkin> that email, that is
16:41:49 <majnemer> Eduard_Munteanu: yes, the Haskell Platform
16:41:51 <osaunders> Cale: hehe cool
16:41:52 <Cale> (I've won 3 free sets so far, and I'll probably get a 4th before the month is out. It's limit 2 per customer per month :)
16:42:17 <majnemer> ah, that part is still up
16:42:24 <majnemer> nevermind then
16:42:32 <adu> Cale: how did you win them?
16:42:37 <majnemer> just as you said :)
16:42:40 <Cale> adu: http://www.flickr.com/groups/zengallery/
16:42:46 <osaunders> Anyone go to the Haskell Symposium last year?
16:43:05 <ddarius> Cale: Soon you'll be able to make a house out of magnets.
16:43:12 <Cale> adu: I submit pictures to there (limit 6 accepted per month), and for each 3 pictures that they accept, I get a free set.
16:43:22 <Eduard_Munteanu> Wow.
16:43:46 <Cale> (They use the pictures on their website)
16:44:24 <hpc> that bacteriophage looks excellent
16:45:20 <djahandarie> copumpkin, this is really cool
16:45:29 <copumpkin> djahandarie: yeah, I love it
16:45:36 <djahandarie> copumpkin, there should be some tutorial on this stuff or something
16:45:52 <copumpkin> djahandarie: of course, any proofs you write in haskell aren't very trustworthy as undefined will "prove" anything
16:46:49 <Cale> O1athe: 1?
16:47:11 <Eduard_Munteanu> copumpkin: but I suspect using common sense will keep undefineds away.
16:48:04 <ddarius> An ATP Synthase model would be impressive, but potentially impossible.
16:48:18 <Eduard_Munteanu> copumpkin: or are there ways to get undefined more subtly?
16:48:22 <adu> ddarius: wouldn't that require some sticks?
16:49:00 <copumpkin> Eduard_Munteanu: sure
16:49:02 <copumpkin> x = x
16:49:03 <copumpkin> :P
16:49:04 <copumpkin> fix id
16:49:11 <copumpkin> loads of ways
16:49:21 <copumpkin> some can be quite subtle
16:49:40 <Cale> http://en.wikipedia.org/wiki/File:ATPsynthase_labelled.png -- based on this diagram, I'm going to tentatively say that it doesn't look magnetically stable.
16:49:52 <Eduard_Munteanu> Ah. I knew about 'fix' but it still looked like you usually end up with undefined only if you're really looking for it.
16:50:39 <djahandarie> copumpkin, stop linking me really cool shit when I'm suppose to be doing work :-(
16:50:54 <Cale> (though I can't really be sure that there isn't a way to orient things near the hanging edges so they won't snap together)
16:50:58 <copumpkin> djahandarie: aww okay
16:51:25 <djahandarie> copumpkin, (not really, keep linking, this is awesome :P)
16:52:26 <ddarius> > 2^3 * 3^3
16:52:27 <lambdabot>   216
16:53:05 <Cale> I like my current count of 2160, because the additional factor of 5 is very useful for icosahedral symmetry.
16:54:39 <joe6> instance Arbitrary String where
16:54:39 <joe6>    arbitrary = do xstring <- listOf $ elements (['A'..'Z'] ++ ['a' .. 'z'] ++ " ~!@#$%^&*()")
16:54:40 <ddarius> copumpkin: That email has resemblence to how when encoding algebraic data types into OO languages providing a fold method so you can actually analyse the result somewhat closes the class structure.
16:54:42 <joe6>                   return (xstring)
16:54:47 <pelotom> http://www.flickr.com/photos/cgibbard/5101497303/lightbox/ @ :43 ... whoooah
16:54:50 <Eduard_Munteanu> I see Cale has been melting some brains on Flicker there explaining his construction techniques :P
16:54:52 <joe6> Illegal instance declaration for `Arbitrary String'
16:55:12 <joe6> is there something wrong with the above declaration of arbitrary String
16:55:28 <mauke> joe6: obviously
16:56:16 <Cale> When I get my 2 free sets for November, I'll have 2592 = 2^5 * 3^4, and I'll probably try to focus more on things with octahedral symmetry, though we'll see, I might just split it up.
16:56:56 <Cale> I love the icosahedral group (and its chiral subgroup)
16:57:04 <monochrom> yes, consider "instance Arbitrary [Char] where..." instead. not allowed in haskell 98. generally "instance Arbitrary (ConstructName TypeName)" not allowed
16:57:05 <joe6> mauke: what do you mean?
16:57:07 <pelotom> Cale: the farthest I've gotten with those is to make a mobius strip, and I was inordinately proud of myself :P
16:57:12 <mauke> joe6: you're getting an error
16:57:26 <joe6> mauke: yes
16:57:35 <ddarius> pelotom: Now all you have to do is make a Klein bottle.
16:57:36 <mauke> joe6: so why are you asking?
16:57:40 <joe6> monochrom: thanks.
16:57:48 <pelotom> ddarius: right ;)
16:57:56 <joe6> mauke: yes, there is an error. will try out monochrom's suggestion
16:58:41 <joe6> same error with Arbitrary [Char] too.
16:58:46 <joe6> s/same/similar/
16:58:50 <mauke> not allowed in haskell 98. generally "instance Arbitrary (ConstructName TypeName)" not allowed
16:59:03 <Cale> pelotom: Yeah, that construction was actually discovered in reverse :)
16:59:20 <joe6> don't bother,  i can use newtype on it.
16:59:32 <copumpkin> ddarius: hmm, I haven't seen that
16:59:34 <pelotom> Cale: what do you mean?
16:59:37 <Cale> pelotom: The first time I built the truncated cuboctahedron, I think I did it by sticking together 6 loops of 8 (or maybe it was 8 loops of 6...)
16:59:55 <Cale> But if you push down on the top of the construction, it flattens into the shape that I cut into 2 sheets there.
17:00:08 <Cale> and I noticed that this shape flattens down into a cuboid nicely.
17:00:09 <pelotom> Cale: oh, you mean the video
17:00:14 <Cale> yeah
17:00:33 <pelotom> Cale: yeah, I need to try that tomorrow with the magnets we have at work :)
17:00:36 <Cale> So I figured I could just make a 2*6*4 cuboid and then expand it out again.
17:01:14 <Eduard_Munteanu> Does anybody know off the top of their head a free resource of articles on data mining?
17:01:31 <Eduard_Munteanu> arXiv doesn't really satisfy me.
17:02:41 <ddarius> Google Scholar?
17:03:31 <joe6> @hoogle generate
17:03:32 <lambdabot> Test.QuickCheck generate :: Int -> StdGen -> Gen a -> a
17:05:56 <Eduard_Munteanu> ddarius: thanks, will have a look
17:06:20 <osaunders> :t arbitary
17:06:21 <lambdabot> Not in scope: `arbitary'
17:06:34 <joe6> generate 8 (System.Random.mkStdGen 100) arbitrary :: [Testline] -- worked with the old version of quickcheck 1.2, but does not work with quickcheck2
17:06:35 <osaunders> :t arbitrary
17:06:36 <lambdabot> forall a. (Arbitrary a) => Gen a
17:06:54 <osaunders> :t listOf
17:06:55 <lambdabot> forall a. Gen a -> Gen [a]
17:07:25 <Eduard_Munteanu> ddarius: looks good, thanks.
17:07:45 <Eduard_Munteanu> (I only have to sift through books and find articles per se)
17:09:04 * ddarius didn't know that Don Syme had worked on HOL.
17:09:15 <ddarius> (er, Isabelle)
17:09:39 <Eduard_Munteanu> The thing with arXiv (besides seemingly lacking in content) is you don't really know how reputable the article is.
17:09:44 <ddarius> (No, HOL was correct.)
17:09:59 <Eduard_Munteanu> ddarius: I know it's Isabelle/HOL.
17:10:12 <ddarius> HOL and Isabelle are different things.
17:10:19 <joe6> i think i am better off ditching the debian haskell packages and just install everything from source to the user home directory or something.
17:10:29 <joe6> does anyone use debian?
17:10:32 <gds> There's a thing called Isabelle/HOL, and there's another thing called HOL4.
17:10:33 <danharaj> isn't there haskell platform for debian?
17:10:34 <joe6> on this irc, i mean.
17:10:39 <gds> There may be other things I'm not aware of too.
17:10:52 <Eduard_Munteanu> Strange. I remember the seL4 article mentioning they used Isabelle/HOL, something as a single entity.
17:10:54 <ddarius> gds: Isabelle is a framework.  Isabelle/HOL is Isabelle instantiated to HOL.
17:11:04 <joe6> yes, I installed haskell-platform but the packages are very old and it is just a pain to install new packages.
17:11:11 <Eduard_Munteanu> I see.
17:11:12 <gds> ddarius: And hol4 is something else again, I believe...
17:12:22 <ddarius> HOL4 is just one of the newest versions of HOL.
17:12:31 <gds> Ok...
17:12:32 <monochrom> HOL98's simplifier is mainly Don Syme's work. He did it as a tool for his thesis. He wanted better automatic rewriting to help him prove some operational semantics things in his thesis.
17:12:41 <HWSOD> Hey haskell.org seems to be down, is there a copy of the ghc user manual anywhere else?
17:13:03 <Eduard_Munteanu> HWSOD: possibly from Hackage via cabal install
17:13:21 <gds> HWSOD: Maybe new-www.haskell.org ?
17:13:43 <monochrom> HOL98 is an old version of HOL4
17:13:46 <kmc> HWSOD, file:///usr/share/doc/ghc6-doc/html/index.html
17:14:10 <Eduard_Munteanu> gds: hm, if that's on par with haskell.org maybe someone should put it in /topic
17:14:20 <Eduard_Munteanu> kmc: lol
17:14:48 <[swift]> i have seen in this channel that ghc 7 is coming relatively soon, but my google skills aren't good enough to find a list of changes or anything. anyone know where i can see what's new in ghc 7?
17:14:50 <kmc> Eduard_Munteanu, legit answer, it works on my system
17:14:53 <HWSOD> kmc: I am on windows..I forgot my pasword to my ubuntu install...:o
17:14:58 <kmc> :(
17:15:04 <kmc> you might still have doc somewhere
17:15:09 <Eduard_Munteanu> Well, not all distros install docs by default. I specifically disable that in Gentoo.
17:15:35 <Eduard_Munteanu> HWSOD: you know, you can reset it.
17:15:47 <HWSOD> I should probobly do that.
17:16:15 <HWSOD> What would you I google for?
17:16:16 <ddarius> [swift]: Most of the changes aren't visible.  The biggest visible ones that I recall are full support for type families and equality constraints and, I believe, the removal of let generalization in a particular case.
17:16:38 <ddarius> The internals, though, have been completely gutted.
17:16:52 <Eduard_Munteanu> Are type eq constraints a language feature? I thought they weren't.
17:17:21 <[swift]> ddarius: ah, ok, that's what i found when googling, but i thought i was only scratching the surface
17:17:37 <teratorn> HWSOD: boot off something, mount your root filesystem, edit /etc/passwd and delete the 'x' out of the passwd field, reboot and login without a password :)
17:17:49 <Eduard_Munteanu> edit?
17:17:58 <Eduard_Munteanu> Just launch passwd and change the damn thing :)
17:18:42 <teratorn> Eduard_Munteanu: that changes system password, not stuff that lives under a mountpoint
17:18:52 <Eduard_Munteanu> I mean chroot and do that.
17:19:11 <teratorn> *shrug*
17:19:18 <ddarius> "A licence agreement for HOL is available, but signing it is optional."
17:19:32 <Eduard_Munteanu> teratorn: chroot /mnt/blah; passwd root
17:20:17 <Eduard_Munteanu> ddarius: is that serious?
17:20:38 <ddarius> Eduard_Munteanu: As of 1996 it was.
17:20:53 <Eduard_Munteanu> Gee, that looks more tongue-in-cheek than WTFPL.
17:22:33 <ddarius> "A documentation standard was designed and then each of the several hundred ML functions comprising HOL was priced at £5 or £10.  Members of the Cambridge HOL users community were then invited to write documentation for money.  The whole job was done painlessly in a few weeks."
17:23:14 <dobblego> why is there no foldM for Data.Set?
17:24:37 <kmc> hmm, is Set Foldable?
17:25:03 <hpc> what order would it fold in?
17:25:25 <pelotom> :t foldM
17:25:26 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:25:35 <kmc> looks like yes
17:25:53 <kmc> so you can use foldrM or foldlM from Data.Foldable
17:25:55 <Eduard_Munteanu> Well I suspect the order doesn't matter.
17:26:12 <kmc> as to what order, Data.Set already has fold
17:26:16 <kmc> "O(n). Fold over the elements of a set in an unspecified order."
17:26:38 <Eduard_Munteanu> So it makes sense to use commutative operators on it.
17:27:03 <copumpkin> I'd be willing to be that the elements are folded in ascending or descending order :P
17:27:05 <Eduard_Munteanu> e.g. (+)
17:27:06 <copumpkin> to bet
17:27:29 <copumpkin> unless your Set is broken cause you lied to it
17:27:43 <Eduard_Munteanu> I suspect you infer that from implementation-related considerations. 
17:27:44 <Cale> associative, really
17:28:08 <copumpkin> Cale: well, the elements are in an unspecified order
17:28:30 <Eduard_Munteanu> Cale: why not commutativity? That's what makes it order-invariant.
17:28:36 <Cale> Oh, I see, you're talking about Set
17:28:49 <Cale> Well, Set is really ordered sets.
17:28:58 <Cale> So there is a natural order to fold in.
17:29:18 <Cale> (from least to greatest)
17:30:40 <dobblego> are you suggesting I instance Foldable for Data.Set in an orphan module?
17:31:01 <Eduard_Munteanu> dobblego: no
17:31:18 <Eduard_Munteanu> dobblego: use foldlM from Data.Foldable.
17:31:27 <dobblego> Eduard_Munteanu, it has no instance
17:31:28 <copumpkin> dobblego: it's already there
17:31:41 <dobblego> oh? 
17:31:42 <Eduard_Munteanu> I thought kmc checked and it was.
17:31:49 <dobblego> oh crap, sorry -- looking at 6.4.1 docs
17:32:30 <guest2425> hello\
17:32:38 <guest2425> EveryBody
17:32:43 <guest2425> I have a question
17:32:54 <dobblego> and it looks like haskell.org is down
17:32:57 <Eduard_Munteanu> I wonder if this thing is ever going to be cleaned up, I mean scrap all list-specific folds and replace them with those from Foldable.
17:33:17 <Eduard_Munteanu> and the same for other stuff.
17:33:21 <kmc> > Data.Foldable.toList $ Data.Set.fromList "abc"
17:33:22 <lambdabot>   Not in scope: `Data.Set.fromList'
17:33:23 <guest2425> I am trying to get this Cons 3 (Cons 4 Empty)
17:33:26 <kmc> > Data.Foldable.toList $ S.fromList "abc"
17:33:27 <lambdabot>   "abc"
17:33:28 <guest2425> :t Cons 3 (Cons 4 Empty)
17:33:29 <lambdabot> Not in scope: data constructor `Empty'
17:33:45 <dobblego> guest2425, where are you reading about Cons and Empty?
17:34:12 <guest2425> I need to do this  Cons 3 (Cons 4 Empty) = [3,4]
17:34:19 <kmc> guest2425, it will never be equal
17:34:21 <dobblego> guest2425, where are you reading about Cons and Empty?
17:34:25 <kmc> but you can convert between them
17:34:34 <guest2425> dobblego: Are you doing the same thing?
17:34:37 <kmc> Cons and Empty are not part of standard Haskell; they'd be in a data type you define somewhere, like:
17:34:40 <dobblego> guest2425, no
17:34:44 <kmc> data List a = Empty | Cons a (List a)
17:34:45 <mauke> guest2425: what are Cons and Empty?
17:34:52 <guest2425> ok
17:34:55 <kmc> as for how to define the conversion: pattern matching
17:35:05 <dobblego> guest2425, what "thing" are you doing?
17:35:08 <kmc> there's a direct correspondence between the constructors of that "List" type, and the list type built into Haskell
17:35:17 <guest2425> I am trying to do this Don't derive Show in the definition. Instead make List a an instance of Show and define show so that the defined lists look like ordinary lists. 
17:35:23 <kmc> guest2425, he's asking if you're doing homework, or reading some book
17:35:30 <kmc> or if you just dreamed up this exercise
17:35:40 <guest2425> I am doing HW
17:35:47 <guest2425> i need help
17:35:48 <dobblego> or even, the source for your question so we can help
17:36:02 <Eduard_Munteanu> guest2425: they will only look like ordinary lists when showed, I think that's the idea.
17:36:09 <dobblego> guest2425, what do you have so far?
17:36:10 <kmc> guest2425, so you should pattern-match
17:36:14 <kmc> one pattern (Cons x xs)
17:36:16 <kmc> one pattern Empty
17:36:31 <guest2425> I have this http://pastebin.com/fkQebWQq
17:36:41 <kmc> yeah
17:36:46 <kmc>     show (Cons x xs) = ...
17:36:49 <kmc> fill in the right hand side
17:37:07 <Eduard_Munteanu> That's a good start.
17:37:10 <kmc> actually, you may want a helper function
17:37:13 <kmc> which shows it without the []
17:37:19 <kmc> because otherwise it will be hard to make the recursion work
17:37:21 <dobblego> guest2425, have you considered writing List a -> [a] first?
17:37:40 <guest2425> dobblego: check this http://pastebin.com/3vfS9H9h
17:37:54 <guest2425> I dont know how to do the second part
17:38:38 <Eduard_Munteanu> guest2425: you need to define show for the second constructor as well.
17:38:49 <Eduard_Munteanu> guest2425: how does the left hand side look?
17:38:51 <guest2425> for the second clause I need to input this     .Cons 3 (Cons 4 Empty) and get this [3,4
17:39:23 <Cale> guest2425: There are a few reasonable approaches to take here. The most basic one is just to write a recursive function to transform your List a values into values of the standard list type.
17:39:29 <Cale> So:
17:39:34 <Cale> toList Empty = ...
17:39:40 <Cale> toList (Cons x xs) = ...
17:39:49 <Cale> (fill in the blanks)
17:40:53 <Cale> A more advanced approach would be to write a fold for your list type. That is, a function which replaces the Empty and Cons constructors throughout a List with other values
17:41:19 <Cale> foldList e c Empty = e
17:41:36 <Cale> foldList e c (Cons x xs) = c x (foldList e c xs)
17:41:40 <guest2425> Cale: can I have a (=) sign
17:41:52 <Cale> (=)?
17:42:07 <Cale> = isn't an infix operator, it's part of the syntax of declarations
17:42:23 <Cale> So you can't put it in parens to use it prefix.
17:42:34 <Eduard_Munteanu> Though you're free to define your (====) or something like that
17:42:45 <Cale> Yeah, and (==) is taken
17:42:48 <Cale> But (===) isn't
17:43:41 <kmc> guest2425, what are you reading to help you learn Haskell?
17:43:42 <mauke> @let a === b = cast a == Just b
17:43:43 <lambdabot>  Defined.
17:44:04 <Cale> guest2425: anyway, with this foldList, you could then translate your list type to the standard one by supplying the constructors of the standard list type as replacements for the constructors of your list type: foldList [] (:)
17:44:07 <guest2425> kmc: Learn your Haskell now
17:44:10 <Eduard_Munteanu> I think he's reading his school materials, he said it was homework.
17:44:17 <kmc> never heard of that one
17:44:30 <Eduard_Munteanu> @where lyah
17:44:31 <lambdabot> http://www.learnyouahaskell.com/
17:44:32 <kmc> Eduard_Munteanu, yes, but most courses will link to some textbook and/or online resource
17:44:33 <Eduard_Munteanu> This?
17:44:38 <Eduard_Munteanu> Oh.
17:45:09 <ddarius> As a correct/clarification to something I said earlier: Isabelle/HOL is Isabelle instantiated to a HOL-like logic, but is not directly connected to HOL itself.
17:45:21 <Eduard_Munteanu> I wish reputable and tried material was the first choice in other disciplines, *sigh*
17:46:05 <Cale> Eduard_Munteanu: ?
17:47:08 <Eduard_Munteanu> Cale: nah, I'm merely whining about school. Every teacher comes up with his own notes, and bibliography is generally a joke or a formality.
17:47:25 <Eduard_Munteanu> I've seen my loads of sucky textbooks.
17:47:26 <kmc> Eduard_Munteanu, not in my experience
17:47:37 <guest2425> Cale: show (Cons x xs) == (Cons x xs (Cons Empty)) I have this
17:47:45 <mauke> what the
17:47:48 <kmc> textbooks vary in quality, but i'd say the majority of courses i took had a text written by someone other than the prof
17:48:02 <kmc> guest2425, how would that make sense, "show" is supposed to return a string, plus you gave the wrong number of args to Cons both times
17:48:19 <guest2425> show (Cons x xs) = (Cons x xs (Cons Empty))
17:48:27 <Cale> Eduard_Munteanu: On the other have, there are a number of courses I took where the course notes (printed by the uni graphics dept.) were actually better than any widely-available textbook that I can find.
17:48:30 <Cale> hand*
17:48:49 <kmc> guest2425, could you explain how you came up with that code?
17:49:25 <Cale> Eduard_Munteanu: Which is really frustrating, because it's a bit awkward to recommend that people phone up the University of Waterloo graphics dept. and have course notes shipped to them :P
17:49:30 <guest2425> kmc: Cale told me to fill the second part
17:49:31 <Eduard_Munteanu> Cale: oh, printed notes. Yeah I prefer those to stuff taken in class, *if* they're good. I've seen good textbooks too, but I can barely count those.
17:49:42 <Eduard_Munteanu> Heh.
17:49:50 <kmc> guest2425, yes, but why did you fill it in with "(Cons x xs (Cons Empty))"
17:49:59 <Cale> guest2425: The right hand side of those equations should be a standard Haskell list
17:50:13 <Cale> guest2425: Um, and it's not called show, it's toList
17:50:35 <Cale> (Or should it be called fromList? ;)
17:50:37 <Eduard_Munteanu> These days I barely attend courses though. :/
17:50:39 <pantsd> I'm thinking about trying to write some simple classifiers in haskell, are there any libraries which I should look at for inspiration on interface/persistance?
17:50:48 <guest2425> do I need to call show or to List
17:51:06 <Eduard_Munteanu> Erm, lectures.
17:51:15 <kmc> guest2425, you need to *define* show because it's what your professor said to do.  one way to define show is to define toList
17:51:18 <kmc> toList :: List a -> [a]
17:51:24 <kmc> which would convert your List to an ordinary haskell list
17:51:27 <kmc> then, you can use show on the result
17:51:47 <kmc> guest2425, you still didn't explain where "(Cons x xs (Cons Empty))" came from, if it's just a guess or if you're following some ideas that maybe we could help you clarify
17:51:56 <Cale> Eduard_Munteanu: I always felt like it was a waste to pay for them but not show up :P
17:52:09 <Eduard_Munteanu> Cale: I don't pay for them :)
17:52:11 <kmc> sunk costs fallacy
17:52:28 <Cale> Well, it's not like there's no value in showing up :)
17:52:28 <Eduard_Munteanu> That's a point too.
17:52:40 <kmc> sometimes there's negative value in showing up, especially wrt opportunity cost
17:52:52 <Cale> If your prof is terrible :P
17:53:06 <kmc> what you're paying for is an external entity to force you to have the discipline to complete projects, and to provide some feedback on quality
17:53:06 <Eduard_Munteanu> I'd rather read through a lengthy material myself than take notes or watch slideshows.
17:53:42 <Eduard_Munteanu> Or attend events, but that's another thing.
17:53:53 <Cale> There was only one course that I took where I was seriously unhappy with my prof. It was Real Analysis 2. The head of the pure mathematics department personally apologised to us afterward.
17:53:59 * Eduard_Munteanu thinks distance learning is undervalued :)
17:54:18 <Eduard_Munteanu> Oh, it must've been terrible I guess.
17:54:29 <Eduard_Munteanu> kmc: yeah.
17:54:38 <monochrom> if your prof is terrible, but you have already paid a lot of money, you should show up, for the fun of trolling the prof
17:54:42 <gwern> Cale: I took an economics course where something similar happened
17:55:36 <Eduard_Munteanu> I'd rather have seminars / office hours than courses.
17:55:38 <kmc> we had a couple people banned from lecture by the prof for asking terrible questions
17:55:50 <monochrom> heh
17:55:57 * Eduard_Munteanu can't imagine
17:56:40 <guest2425> kmc: I have this http://pastebin.com/Wx9K4YpT
17:56:42 <Cale> Apparently the people in the group theory course a year after I took it had this one guy who would ask the dumbest questions, apparently without thinking before opening his mouth.
17:57:11 <kmc> guest2425, take out the "instance" line
17:57:17 <kmc> you aren't ready to define the instance yet
17:57:20 <kmc> get toList working first
17:57:31 <kmc> and why is the right hand side "[]"
17:57:47 <Eduard_Munteanu> guest2425: you're converting List to regular lists, forget about strings at the moment.
17:57:59 <Cale> Near the end of the course, he actually asked "What does G less than H mean?" (where G and H are groups). This is a notation which had been used since probably the second lecture.
17:58:09 <guest2425> ok
17:58:16 <Eduard_Munteanu> Normal subgroup?
17:58:20 <Cale> Just subgroup
17:58:32 <Eduard_Munteanu> Ah, that was more like <|
17:58:36 <Cale> (normal subgroup would be closed into a triangle, yeah)
17:58:52 <guest2425> kmc: I have []  because
17:59:25 <Cale> Apparently he knew already what it meant, but he just didn't think before asking questions.
17:59:29 <guest2425> kmc: it would give an error message
17:59:56 <guest2425> kmc: I need ti do this :3:4 = [3,4]
18:00:02 <guest2425> *to
18:00:19 <kmc> guest2425, i don't understand... you can't program by random guessing
18:00:27 <kmc> even if you have ghc or #haskell to check against
18:00:40 <guest2425> kmc: i need help
18:00:43 <megajosh2> lol
18:00:45 <kmc> i gathered that
18:00:47 <kmc> look at the type of toList.  it says List a -> [a].  that means the thing you return has to be a list, not a string
18:00:57 <guest2425> ok
18:01:03 <kmc> (it happens that strings are lists, but not the right type; it's basically irrelevant here)
18:01:06 <Eduard_Munteanu> help :: #haskell -> homework ?
18:01:15 <kmc> guest2425, do you understand the difference between these two expressions:
18:01:16 <kmc> []
18:01:17 <kmc> "[]"
18:01:25 <guest2425> yes
18:01:27 <kmc> what is it?
18:01:34 <Eduard_Munteanu> If #haskell is inhabited, homework's done? No way, unprovable.
18:01:39 <guest2425> [] is  a list
18:01:44 <guest2425> "[]" is an string
18:01:47 <kmc> right
18:01:51 <kmc> and which one should toList return?
18:02:03 <guest2425> a list
18:02:05 <kmc> right
18:02:13 <kmc> now, what about the second equation
18:02:19 <kmc> toList (Cons x xs) = ...
18:02:27 <kmc> which List does (Cons x xs) represent?
18:02:32 <Eduard_Munteanu> Cale: these days I'd rather have a clear syllabus, free reference textbook (and it better be good), and office hours with the prof.
18:02:42 <kmc> describe it in words, if you don't know how to write the Haskell code
18:02:55 <LegendaryPenguin> haskell.org broken/
18:03:08 <Eduard_Munteanu> I can barely ask questions with them constantly *teaching*
18:03:24 <Eduard_Munteanu> LegendaryPenguin: yes.
18:03:28 <Eduard_Munteanu> /topic
18:03:31 <guest2425> kmc: it means that to list is going to create a list using head and the tail using : 
18:03:42 <kmc> yeah
18:03:46 <kmc> > 1 : [2,3,4]
18:03:47 <lambdabot>   [1,2,3,4]
18:04:00 <guest2425> kmc: ok
18:04:52 <guest2425> kmc like this toList(Cons x xs) = Cons (x : xs)
18:04:59 <guest2425> kmc: like this toList(Cons x xs) = Cons (x : xs)
18:05:17 <kmc> guest2425, no
18:05:22 <kmc> why did you include Cons on the right-hand side?
18:05:38 <guest2425> kmc: i need it
18:05:39 <Eduard_Munteanu> Cale: actually we had one prof. who came to the seminar and simply asked "do you have any question?". Nobody said anything, then he said "Then why am I here? I'm leaving.".
18:05:54 <kmc> guest2425, you didn't answer my question
18:05:57 <Eduard_Munteanu> *questions
18:06:13 <guest2425> kmc: because I need it
18:06:19 <mauke> guest2425: for what?
18:06:32 <guest2425> to do the list
18:06:37 <mauke> what
18:06:47 <Eduard_Munteanu> Cale: incidentally his textbook (written by him and two other teachers) was the best stuff I read from my university so far.
18:07:44 <Eduard_Munteanu> Numerical algos, btw.
18:07:45 <copumpkin> https://github.com/yav/memory-arrays/wiki/Type-level-naturals-basics
18:07:55 <copumpkin> who knows anything about where I can get a GHC that supports that? :P
18:07:59 <copumpkin> byorgey?
18:08:32 <copumpkin> newtype Array (n :: Nat) a = MA (Ptr a)
18:08:54 <Eduard_Munteanu> What?!
18:09:24 <copumpkin> djahandarie would want to be distracted by that
18:09:39 <Eduard_Munteanu> I'd like to smoke some of that Nat.
18:10:38 <kaf3ii> is there any reason why I have to write "head' (x:_) = x" instead of "head' x:_ = x"
18:10:49 <mauke> kaf3ii: precedence
18:10:54 <rickythesk8r> hrypubeslvr
18:11:02 <Eduard_Munteanu> kaf3ii: function application binds tighter
18:11:22 <mauke> kaf3ii: put spaces around your operators to make this more obvious
18:11:22 <guest2425> kmc: like this toList(Cons x xs) = toList(x:xs) 
18:11:47 <kmc> guest2425, you won't share any of your thought process with me; you're just guessing
18:11:49 <kmc> so i'll let others help you
18:12:06 <guest2425> kmc: no
18:12:14 <guest2425> kmc: please help
18:12:59 <guest2425> kmc: this is a list (x:xs)
18:13:03 <guest2425> correct
18:13:05 <Eduard_Munteanu> guest2425: pretend you were GHC, would you accept that as valid? Does it look like toList's type is obeyed by its definition?
18:13:09 <jmcarthur> awesome http://detexify.kirelabs.org/classify.html
18:13:43 <sipa1024> awesome indeed
18:13:53 <sipa1024> i really wished i'd need it more often
18:14:37 <Eduard_Munteanu> Wow.
18:14:37 <guest2425> kmc: you are not going to help me anymore
18:14:43 <Eduard_Munteanu> I'll remember it.
18:15:46 <copumpkin> guest2425: what's the type of toList?
18:16:08 <copumpkin> guest2425: and what's the type of (x:xs)?
18:16:25 * monochrom reminds you: some problems are not meant to be solved
18:16:32 <copumpkin> lol
18:17:21 * ddarius needs to read "Around the World in Eighty Days" again.  Phileas Fogg is one of my favorite characters of all time.
18:17:37 <ddarius> copumpkin: By the way, if you need help with anything, feel free to ask me.
18:18:09 <copumpkin> ddarius: thanks!
18:18:52 <Eduard_Munteanu> copumpkin: is that Nat stuff in Haskell serious? I really doubt it.
18:18:59 <copumpkin> Eduard_Munteanu: definitely serious
18:18:59 * Eduard_Munteanu wished
18:21:51 <Quadrescence> haskell is the first language to make me think :)
18:22:01 <kmc> yeah
18:22:10 <kmc> it's hard to write correct programs, no matter what language you use
18:22:16 <kmc> Haskell makes it also hard to write incorrect programs
18:22:38 <Quadrescence> haskell also makes it hard to write huge inefficient programs too :)
18:22:52 <ddarius> Quadrescence: Your first programming language didn't make you think?
18:22:53 <Eduard_Munteanu> Think again...
18:22:56 <Eduard_Munteanu> :t (!!)
18:22:57 <lambdabot> forall a. [a] -> Int -> a
18:22:59 <kmc> i don't agree, i've written some huge inefficient programs in Haskell
18:23:02 <Quadrescence> ddarius: yeah...BASIC
18:23:11 <kmc> but generally the thought to code ratio is very high
18:23:20 <Eduard_Munteanu> BASIC was the first for me too...
18:23:21 <kmc> which can be frustrating and makes a lot of people feel dumb
18:23:29 <danharaj> Sometimes it takes a while to find the right thought.
18:23:48 <Quadrescence> i love how deep haskell is. there's always something new to learn
18:23:59 * monochrom steals some famous quote and says: some people, when confronted with a problem, say "I know, I will write an incorrect program first, then correct it later". now they have two problems.
18:24:26 <guest2425> copumkin: this is  a list correct (x:xs)
18:24:29 <Eduard_Munteanu> Sounds familiar.
18:24:29 <jeanfrancis> Hi guys! is haskell.org working for you? It is down for me since a couple of days! :(
18:24:42 <Eduard_Munteanu> jeanfrancis: yes, /topic
18:24:57 <jeanfrancis> Eduard_Munteanu: oh, sorry :( hehe
18:25:15 <bremner> :t (x:xs)
18:25:16 <lambdabot> Not in scope: `xs'
18:25:23 <jeanfrancis> and is there any good mirror for it?
18:25:26 <Quadrescence> :t (:)
18:25:26 * monochrom thought carefully, even when using BASIC in teenage. carefully planned ahead.
18:25:27 <lambdabot> forall a. a -> [a] -> [a]
18:25:29 <mauke> can I start kicking people who ask about www.haskell.org without reading the topic?
18:25:44 <Eduard_Munteanu> jeanfrancis: you could try new-www.haskell.org
18:25:52 <monochrom> how do you know they haven't read the topic?
18:26:17 * ddarius wrote the most atrocious spaghetti code in QBASIC.  It had subroutine mechanisms, I just didn't use them.  Of course, I did occassionally need subroutine-like functionality.  Hilarity ensued.
18:26:22 <mauke> because they join and the first thing they say is something like "is haskell.org down for anyone else?"
18:26:27 <Eduard_Munteanu> GOTO FTW!
18:26:33 <Quadrescence> GOSUB
18:26:37 <Eduard_Munteanu> COMEFROM :P
18:26:53 <Eduard_Munteanu> ILLBEBACK.
18:26:54 <kmc> call-with-current-continuation
18:26:54 <ezyang> I think COMEFROM is a good idea in principle. 
18:26:56 <Quadrescence> i actually implemented goto in a haskell monad lol
18:27:07 <monochrom> then again I'm all for banning people who don't read, not just banning people who don't read the topic, not just kicking.
18:27:08 <guest2425> i need to do this
18:27:10 <Eduard_Munteanu> Yeah, like kmc says.
18:27:16 <LegendaryPenguin> oh, i thought /topic meant off topic
18:27:20 <LegendaryPenguin> not a command, lol
18:27:32 * ddarius is completely behind monochrom on this.
18:27:32 <Eduard_Munteanu> LegendaryPenguin: I meant "read the channel topic"
18:27:39 <LegendaryPenguin> oh
18:27:39 <guest2425> monochrom: How can i do this http://pastebin.com/4bNsju88
18:27:43 <LegendaryPenguin> i thought u were being a dick
18:27:46 <LegendaryPenguin> haha
18:27:54 <monochrom> I don't know.
18:29:33 <Phyx-> mauke: to be fair though, if you change the topic while i'm in the channel already
18:29:37 <Phyx-> I probably won't notice it
18:29:55 <ddarius> There is also downforeveryoneorjustme.com
18:30:22 <Phyx-> I didn't ask if it was down, i was just making a case for the others who did :P
18:30:34 <Eduard_Munteanu> Hm, I thought the Glasgow people ran haskell.org, it seems that Yale people do it, heh.
18:30:36 <Phyx-> i mean, i have to explicitly type /topic to view it
18:30:41 <ddarius> My point is that there is another way of finding out without even joining the channel.
18:30:42 <Eduard_Munteanu> At least that's what whois tells me.
18:31:08 <Phyx-> ddarius: true
18:31:17 <monochrom> There is also http://www.vex.net/~trebla/humour/lmcify.html?t=haskell.org+is+down
18:31:17 <Eduard_Munteanu> ddarius: but somehow, asking makes it come back up faster.
18:31:19 <ddarius> I don't bother telling people these things because there is a constant influx of new people, so it is mostly pointless.
18:31:32 <ddarius> Eduard_Munteanu: Nope, it's still down.
18:31:36 <LegendaryPenguin> what about now
18:31:58 <Eduard_Munteanu> :P
18:32:02 <Phyx-> maybe add a line to lambdabot to automatically respond?"
18:32:08 <LegendaryPenguin> oh, yeah
18:32:10 <LegendaryPenguin> a new command
18:32:15 <Phyx-> "You are no# 324424 to ask, Yes it's freaking down"
18:32:24 <kmc> oh, reminds me, Cale: did you get my lambdabot patch?
18:32:25 <Eduard_Munteanu> @faq Can Haskell bring haskell.org back up?
18:32:25 <lambdabot> The answer is: Yes! Haskell can do that.
18:33:10 <Eduard_Munteanu> Phyx-: I second that.
18:33:21 <Phyx-> though in all fairness, Haskell.org seems to go down alot lately
18:33:26 <Phyx-> and hackage
18:33:31 <Gracenotes> maybe @faq Can haskell.org be rewritten in Haskell, or @faq your mom
18:34:26 <Cale> kmc: I did, thanks.
18:34:52 <Cale> kmc: You might also consider sending patches to gwern, since he's keener about maintaining the hackage version.
18:34:59 <Phyx-> ah, before i go to bed, i'll do a pull on the ghc head and cabal-install
18:35:34 <mauke> Cale: http://mauke.ath.cx/tmp/disable-seen.patch
18:35:35 <monochrom> great way to postpone going to bed. "not tonight dear, I've got ghc head"
18:35:45 <roconnor> Is it worth leaving academic work for industrial work if I got paid 3x to program in C++ instead of ocaml?
18:35:45 <Phyx-> lol
18:35:49 <Eduard_Munteanu> :)
18:35:56 <roconnor> oh maybe this is a #haskell-blah question
18:36:13 <Phyx-> I wish darcs pull -a still gave me some sort of accumulated log of what patches it applied
18:36:24 <ddarius> roconnor: It depends on your priorities and desires.
18:36:35 <monochrom> if you have to ask, it probably means not worthwhile for you
18:36:36 <Cale> mauke: Ah, I see.
18:36:48 <mauke> also http://mauke.ath.cx/tmp/admin-mauke.patch
18:36:52 <Eduard_Munteanu> roconnor: after a work's year you'll be able to quit sit on the couch for two years, programming Haskell, not OCaml :)
18:37:02 <roconnor> Eduard_Munteanu: that's what I'm thinking
18:37:12 <Eduard_Munteanu> *quit and sit
18:37:13 * ddarius has a plan vaguely akin to that currently.
18:37:19 <roconnor> even if my priorities is research in type theory, it still might be the right move
18:37:21 <Phyx-> what the... darcs just blew up
18:37:36 <roconnor> in fact, I might have more research freedom this way
18:37:51 <guest2425> :t mapMyList (*2) (3 :-: 4 :-: 5 :-: Empty)
18:37:52 <lambdabot> Not in scope: `mapMyList'
18:37:52 <lambdabot> Not in scope: data constructor `:-:'
18:37:52 <lambdabot> Not in scope: data constructor `:-:'
18:37:54 <ddarius> Phyx-: Great.  Now there's going to be a big lawsuit and darcs will have to have a sticker "Warning: May Explode" on it from now on.
18:38:07 <guest2425> How can i do this mapMyList (*2) (3 :-: 4 :-: 5 :-: Empty)
18:38:10 <guest2425> ??
18:38:11 <Eduard_Munteanu> roconnor: unless it's something you really dislike.
18:38:34 <Phyx-> ddarius: lol, not likely, but I do wonder how a darcs pull can cauze this much damage
18:38:38 <roconnor> Eduard_Munteanu: it would be reasonably intresting work I think
18:38:39 <Phyx-> now it tells me there's a crc error
18:38:40 <guest2425> Eduard_Munteanu: How can I do this http://pastebin.com/4bNsju88
18:38:59 * monochrom cringes, crc error too...
18:39:00 <mauke> guest2425: first you need to sit around helplessly
18:39:02 <Eduard_Munteanu> Then it's worth considering.
18:39:05 <Phyx-> I thought the whole point about patch based version control is that if a patch fail you just undo
18:39:15 <mauke> then you should ask random people for "help"
18:39:32 <guest2425> mauke: what you mean
18:39:42 <ddarius> Phyx-: That's not the point.
18:39:42 <Eduard_Munteanu> Master mauke, he should first learn patience by painting the fence before learning Haskell-fu.
18:39:59 <mauke> map paint fence
18:40:06 <guest2425> mauke: Can you help me
18:40:11 * Phyx- rm -rf's the folder and does a fresh pull
18:40:13 <Axman6> data LossyList a = LCons a (LossyList a) | LNill; mapLossy f xs = LNil
18:40:14 <Axman6> >_>
18:40:32 <ddarius> type LossyList a = ()
18:40:33 <monochrom> ^_^
18:40:55 <Axman6> pfft
18:40:56 <Eduard_Munteanu> guest2425: you're wasting more time literally guessing solutions, you could be going through your materials and see what you've got wrong.
18:41:02 <ddarius> mauke: fence is a list of boards ?
18:41:28 <Phyx-> where's lispy, I need to complain that darcs blew up
18:41:39 <kaf3ii> I problem with the "head' (x:_) = x" pattern is that I think of it as a tuple  containing 1 list "([x...])", but then pattern is really more like "[x...]"?
18:41:41 <Axman6> i'll call a fence an array of boards, which can be accessed in O(1) time with a paintball gun
18:41:42 <kaf3ii> I problem with the "head' (x:_) = x" pattern is that I think of it as a tuple  containing 1 list "([x...])", but then pattern is really more like "[x...]"?
18:41:48 <kaf3ii> I problem with the "head' (x:_) = x" pattern is that I think of it as a tuple  containing 1 list "([x...])", but then pattern is really more like "[x...]"?
18:42:05 <Axman6> kaf3ii: we heard you the first time... o.O
18:42:17 <mauke> kaf3ii: I don't understand that question and there is no such thing as a 1-tuple
18:42:30 <mauke> (((42))) == 42
18:42:32 <osaunders> @src map <- guest2425 
18:42:33 <lambdabot> Source not found. Where did you learn to type?
18:42:37 <osaunders> @src map
18:42:37 <lambdabot> map _ []     = []
18:42:37 <lambdabot> map f (x:xs) = f x : map f xs
18:42:42 <ddarius> f :: (Int) -> Int; f (3) = 3
18:42:49 <mauke> haha
18:42:50 <Axman6> :O
18:43:03 <kaf3ii> ah sry =P
18:43:22 <Axman6> 1-tuples are the only haskell datatypes which aren't properly typechecked
18:43:30 <Eduard_Munteanu> kaf3ii: for tuples, (,) is the constructor, not the paranthesis.
18:43:31 <kaf3ii> thought client had freezed
18:43:36 <mauke> I'd really prefer "head' (x : _) = x"
18:43:48 <Axman6> let to1Tup x = (x) in 1 == to1Tup x
18:44:08 <Phyx-> @src id
18:44:08 <lambdabot> id x = x
18:44:12 <Phyx-> @src (.)
18:44:12 <lambdabot> (f . g) x = f (g x)
18:44:12 <lambdabot> NB: In lambdabot,  (.) = fmap
18:44:13 <Axman6> > let to1Tup :: a -> (a); to1Tup x = (x) in 1 == to1Tup x
18:44:14 <lambdabot>   False
18:44:21 <Axman6> > let to1Tup :: a -> (a); to1Tup x = (x) in 1 == to1Tup 1
18:44:21 <lambdabot>   True
18:44:22 <Axman6> even
18:44:22 <kaf3ii> mauke: no 1 tuples :D, nice.. 
18:44:26 <ddarius> Eduard_Munteanu: That's not quite correct or at least misleading.  The whole '(', ',', ')' is part of the syntax.  , alone is not an operator.
18:44:40 <osaunders> > (+1) . Just 5
18:44:41 <lambdabot>   Just 6
18:44:47 <ddarius> However, (,) is a name.
18:44:51 <Eduard_Munteanu> ddarius: yeah, it was a stretch.
18:45:00 <mauke> > let to1Tup :: a -> (a); to1Tup x = (x) in [1] === to1Tup 1
18:45:01 <ddarius> > (,) 3 4
18:45:01 <lambdabot>   False
18:45:02 <lambdabot>   (3,4)
18:45:11 <Phyx-> > (,,) 8 7 2
18:45:12 <lambdabot>   (8,7,2)
18:45:17 <osaunders> :t (===)
18:45:18 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
18:45:28 <Phyx-> oh that's neat
18:45:34 <Phyx-> > "d" === "a"
18:45:35 <lambdabot>   False
18:45:49 <Axman6> > Nothing === ()
18:45:49 <Phyx-> i don't get that instance
18:45:49 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:45:49 <lambdabot>    `Data.Typeable.Typeable a...
18:46:03 <Axman6> > (Nothing :: Just ()) === ()
18:46:04 <lambdabot>   Not in scope: type constructor or class `Just'
18:46:09 <Eduard_Munteanu> > (0 :: Int) === 0.
18:46:09 <Axman6> > (Nothing :: Maybe ()) === ()
18:46:10 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:46:10 <lambdabot>   False
18:46:10 <Axman6> -_-
18:46:18 <Phyx-> does it use the typable instance to cast the a to b then use the Eq instance?
18:46:33 <Funktorsalat> True
18:46:47 <Quadrescence> Funktorsalat: are you related to tensorpudding
18:46:50 <Eduard_Munteanu> > (0 :: Int) === 0.
18:46:50 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:46:55 <Eduard_Munteanu> > (0 :: Int) === 0.0
18:46:56 <lambdabot>   False
18:46:59 <Funktorsalat> Quadrescence: nope
18:47:21 <Phyx-> > (0 :: Int) == 0
18:47:22 <Makoryu> :t .5
18:47:22 <lambdabot>   True
18:47:22 <lambdabot> parse error on input `.'
18:47:25 <ddarius> @undefine
18:47:27 <copumpkin> Quadrescence: hah, when tensorpudding first appeared here people asked him if he was related to Funktorsalat 
18:47:31 <ddarius> > (===)
18:47:32 <lambdabot>   Not in scope: `==='
18:47:37 <ddarius> Gut.
18:47:39 <Phyx-> aww
18:47:43 <Eduard_Munteanu> > (0 :: Int) === (0 :: Double)
18:47:44 * osaunders should change his name to monadDinner
18:47:44 <lambdabot>   Not in scope: `==='
18:47:48 <mauke> @let a === b = cast a == Just b
18:47:49 <Phyx-> i thought it was a pre-existing function
18:47:49 <lambdabot>  Defined.
18:47:53 <Eduard_Munteanu> Ha.
18:47:59 <Phyx-> :t (===)
18:48:00 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
18:48:04 <Phyx-> heh
18:48:09 <ddarius> Phyx-: It would be a stupid function to add to the libraries.
18:48:10 <Eduard_Munteanu> > (0 :: Int) === (0 :: Double)
18:48:11 <lambdabot>   False
18:48:21 <Eduard_Munteanu> I don't really understand it.
18:48:27 <Phyx-> ddarius: yeah, I was just wondering what it's use it
18:48:30 <Axman6> > Just 1 === Right 1
18:48:30 <osaunders> :t cast
18:48:31 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
18:48:31 <lambdabot>   False
18:48:53 <ddarius> Eduard_Munteanu: It compares two things for equality returning false if they are not the same type, or are but are not equal.
18:48:59 <Makoryu> What the hizazzy is this (===) floofgoofery
18:49:00 <Axman6> > cast (Just 1) :: Maybe (Either () Int)
18:49:01 <lambdabot>   Nothing
18:49:10 <Eduard_Munteanu> ddarius: oh.
18:49:10 <Axman6> > cast (Nothing) :: Maybe (Either () Int)
18:49:11 <ddarius> It doesn't do any kind of conversion.
18:49:11 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:49:11 <lambdabot>    `Data.Typeable.Typeable a...
18:49:24 <Phyx-> :t foldr (===)
18:49:25 <lambdabot> forall a. (Typeable a) => Bool -> [a] -> Bool
18:49:54 <Phyx-> > foldr (===) True []
18:49:55 <lambdabot>   Ambiguous type variable `a' in the constraint:
18:49:55 <lambdabot>    `Data.Typeable.Typeable a...
18:49:55 <kaf3ii> so is there any ambiguity about "head' x:_ = x"
18:50:03 <Phyx-> lol
18:50:09 <Phyx-> :t foldr (===) True []
18:50:10 <lambdabot>     Ambiguous type variable `a' in the constraint:
18:50:10 <lambdabot>       `Typeable a' arising from a use of `===' at <interactive>:1:6-10
18:50:10 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
18:50:11 <mauke> kaf3ii: no, it's just wrong
18:50:17 <Axman6> kaf3ii: yes, it's parsed as head (x) (:) (xs) = x
18:50:25 <mauke> Axman6: wtf
18:50:29 <Axman6> isn't it?
18:50:32 <mauke> hell no
18:50:38 <Quadrescence> yea it is
18:50:42 <Axman6> you're very angry today
18:50:56 <Cale> kaf3ii: It looks like (head' x) : _ = x -- which of course is an error because head' is not a data constructor.
18:51:11 <kaf3ii> mauke: Axman6 Ah :D, thanx for that explanation
18:51:14 <mauke> and because (:) is
18:51:18 <Axman6> yeah, that's the one i was after, listen to Cale 
18:51:34 <Makoryu> :t foldr (===) True ""
18:51:35 <lambdabot> Bool
18:51:38 <mauke> Axman6: (:) (head x) xs = ... I could accept
18:51:39 <Makoryu> > foldr (===) True ""
18:51:40 <lambdabot>   True
18:51:49 <Cale> kaf3ii: The most important thing to remember about operator precedence in Haskell is that function application (whitespace) has higher precedence than any infix operator.
18:52:09 <Phyx-> i'm confused on that explanation
18:52:09 <Cale> (that is, it binds more tightly)
18:52:19 <kaf3ii> Cale: try to remember that =s
18:52:19 <Phyx-> why would head' have to be a dataconstructor
18:52:35 <mauke> Phyx-: how else could you use (head x) in a pattern?
18:52:36 <ddarius> http://www.gutenberg.org/ebooks/103
18:52:39 <Quadrescence> kaf3ii: just use parentheses for everything
18:52:41 <Cale> Phyx-: Because this is a pattern binding, and you can only pattern match against functions which are data constructors
18:52:46 <Eduard_Munteanu> View patterns :P
18:52:57 <Phyx-> mauke: yes, the lightbulbs came on after i pressed send
18:52:59 <ddarius> mauke: See the pattern calculus.
18:53:04 <mauke> hah
18:53:08 <ddarius> Phyx-: See the pattern calculus.
18:53:14 <Cale> For example, you can't use  cos x = 1/2  to define x.
18:53:23 <Quadrescence> ddarius: see that haskell doesn't use the pattern calculus
18:53:24 <Cale> Same reason here.
18:53:50 <mauke> > let cos x = 1/2 in x
18:53:51 <lambdabot>   x
18:53:59 <Axman6> heh
18:54:00 <ddarius> Quadrescence: Unfortunately, though reasonably since it didn't exist when Haskell was made, or really any time until recently.  It would be an awesome thing to add to Haskell, though it would change it dramatically.
18:54:10 <Phyx-> lol
18:54:11 <Cale> (that defines cos instead, of course)
18:54:13 <Eduard_Munteanu> That would let you invert ANY function, that's surely impossible.
18:54:18 <Quadrescence> ddarius: It is something I'm adding to my language
18:54:22 <Cale> Interestingly, in Mathematica, you can write a binding like that, using ^=
18:54:42 <Quadrescence> Cale: No
18:54:44 <ddarius> Quadrescence: I would too if I were making an FP language.
18:54:45 <Quadrescence> That is different
18:54:59 <Quadrescence> Cale: That just associates the pattern with x
18:55:03 <Cale> Right.
18:55:12 <Quadrescence> it's not defining x in any way
18:55:28 <Quadrescence> also: boycott mathematica
18:55:30 <Cale> Well, to the extent which anything in Mathematica is defined, it is.
18:55:37 <Cale> (defining x)
18:55:54 <Phyx-> bleh, you guys are too interesting. everytime i come here I leave with new papers to read
18:56:03 <Cale> Things are defined in Mathematica entirely in terms of pattern substitutions which are associated with them.
18:56:16 <[swift]> what the heck is the pattern calculus?
18:56:16 <Quadrescence> Cale: No, that's wrong in this case
18:56:32 <[swift]> are the patterns in question "design patterns"?
18:56:35 <ddarius> Phyx-: If you ever doubt that you won't, just ask me.  I have -plenty- of papers to recommend.
18:56:40 <Quadrescence> Cale: It's an upvalue match or whatever. So it's really defining Cos[x]
18:56:44 <ddarius> [swift]: God no.
18:56:47 <Quadrescence> Cale: But it matches upon inspection of x
18:56:51 <Phyx-> ddarius: lol, will do
18:56:55 <Cale> Quadrescence: Yeah, we're defining an upvalue for x.
18:57:09 <Cale> But it becomes part of the definition of x.
18:57:27 <[swift]> ddarius: that's a relief =)
18:57:31 <Quadrescence> Cale: meh, I guess if you stretch it a little you could say that...ish
18:57:35 <Cale> (And will be cleared if you Clear[x])
18:57:38 <Quadrescence> I still wouldn't say it defines x
18:57:49 <mauke> ddarius: if you have direct links to .pdfs or whatever, please dump them in #haskell-blah :-)
18:57:51 <[swift]> ah ok, just found a post on it on LtU
18:57:51 <ddarius> @google "pattern calculus"
18:57:52 <lambdabot> http://lambda-the-ultimate.org/node/3695
18:57:52 <lambdabot> Title: Pattern Calculus | Lambda the Ultimate
18:58:01 <Quadrescence> Cale: also, http://symbo1ics.com/blog/?p=69
18:58:05 <[swift]> that very one! =)
18:58:19 <ddarius> mauke: It would have to be more specific.  I'm not about to paste 4,000 links to #haskell-blah.
18:58:31 <Cale> Quadrescence: I'm quite aware that Mathematica isn't open source :P
18:58:40 <Quadrescence> Cale: I know you are
18:58:42 <mauke> aww
18:58:53 <Quadrescence> but i'm giving you reasons to never talk about mathematica ever again
18:58:55 <Phyx-> i just got a pattern calculus paper http://www-staff.it.uts.edu.au/~cbj/Publications/purepatterns.pdf
18:59:20 <Cale> Oh, heh, another thing which vindicates my view on it:  Definition[x]  will report that upvalue :)
18:59:34 <ddarius> There's some newer work with Delia Kesner that's not included in the book or the other articles on Barry's page, that's interesting.
18:59:48 * Phyx- <3 Mathematica
18:59:53 <Quadrescence> Phyx-: no
18:59:55 <Quadrescence> stop
18:59:58 <ddarius> @google http://journals.cambridge.org/repo_A45US65o
18:59:59 <Cale> Quadrescence: I'm not that hardcore about free software.
19:00:04 <lambdabot> Plugin `search' failed with: Prelude.(!!): index too large
19:00:08 <Quadrescence> Cale: I'm in it for the math
19:00:11 <Quadrescence> not the software
19:00:13 <ddarius> Oops.
19:00:16 <Quadrescence> if you read the blog post, you'd understand
19:00:28 <Phyx-> eh, why did lambdabot just say that
19:00:29 <Cale> Oh, well, I would never consider anything done in mathematica as actually *part of* mathematics.
19:00:46 <Cale> It's a toy for messing around and trying to get ideas.
19:01:00 <Quadrescence> Why not use Sage or Axiom
19:01:07 <Cale> Because I hate their syntax.
19:01:09 <Quadrescence> Axiom should be tasty to you since it's fully typed
19:01:20 <Phyx-> yeah, mathematica is so easy to use
19:01:21 <ddarius> Phyx-: Because @google is a pile of crap.  I actually just cabal unpacked lambdabot about 10 minutes ago so I can make it less a pile of crap.
19:01:33 <Phyx-> and get used to
19:01:38 <Quadrescence> Phyx-: so are the others
19:01:42 <Quadrescence> and they're free and open source
19:01:48 <Phyx-> ddarius: aha
19:01:51 <Cale> Sage is a nice idea, but it's a mess.
19:01:56 <Quadrescence> yes it is a mess
19:02:05 <Quadrescence> use axiom then, 10000x more powerful
19:02:06 <Cale> It's an ugly hack which involves parsing text output of various other tools.
19:02:08 <monochrom> Ideologies please go to #haskell-blah
19:02:35 <Cale> Quadrescence: If it pleases you, I use GAP a lot
19:02:41 <jeanfrancis> do anybody has an idea how I can get yhc to build? :) http://paste.pocoo.org/show/291437/
19:02:55 <Phyx-> Cale: what do you get there? Shirts? pants?
19:03:07 <jeanfrancis> (I verified, and it's not answered in the topic :)
19:03:18 <monochrom> haha
19:03:29 <Cale> Phyx-: http://www.gap-system.org/
19:04:39 <Phyx-> ah
19:04:46 <Phyx-> ok, 4am, i'm out
19:04:51 <Gracenotes> oooh that's why my inbox is so empty
19:04:59 * Gracenotes throws glance at haskell.org
19:05:03 <Cale> The underlying language of GAP kinda sucks (though probably better than that of most CASes), but the functionality is irreplaceable.
19:05:09 <Gracenotes> bye
19:05:26 <Phyx-> Gracenotes: I've recently started just filtering all @haskell.org mails
19:05:31 <Phyx-> and automarking them as read
19:05:47 <Phyx-> and when i'm bored, i look through it
19:05:50 <monochrom> I know. Someone brought down haskell.org to prevent type-directed name resolution from gaining traction.
19:11:11 <ManateeLazyCat> @tell dcoutts 'webkit' package always build failed on hackage, i think it's because hackage server has install old gtk2hs-buildtools that can't parse webkit-0.12.1's code correctly (gtk2hs-buildtools is binary tools, can't update automatically), can you help me re-install gtk2hs-buildtools-0.12.0 again? Then i think webkit-0.12.1 can compile correctly. Thanks a lot! :)
19:11:11 <lambdabot> Consider it noted.
19:12:02 <djahandarie> copumpkin, efficient type-level naturals? sweet
19:16:17 <Eduard_Munteanu> Cale: I might suggest Maxima if you're looking for a symbolic CAS, it's based on Common Lisp.
19:16:35 <Eduard_Munteanu> Maybe that appeals more.
19:16:35 <wolfspaw> is there a way to compile that it doesnt make the .hi and .o ? (or removes them after compilation). Just for curiosity, because i always delete them after compiling
19:16:45 <Cale> All the open source CASes I've seen have awful notation :P
19:17:14 <Eduard_Munteanu> I guess so. Lisp doesn't tickle me too much either.
19:17:42 <Cale> Eduard_Munteanu: Mathematica interestingly uses the syntax that had originally been intended for Lisp.
19:17:50 <Cale> (M-expressions)
19:18:13 <Eduard_Munteanu> Hm, I'm mostly unfamiliar with Mathematica.
19:18:15 <Cale> It's just that the Lisp people ended up liking the originally-provisionary S-expressions better, and stuck with those.
19:18:30 <Eduard_Munteanu> I see.
19:19:00 <Cale> http://www.flickr.com/photos/cgibbard/5176766013/in/photostream/ -- some new photos
19:20:27 <guest2425> I am getting an error message http://pastebin.com/fGYdidbL
19:20:32 <ksf> if xmonad gets wayland support, it'd need a drawing backend as xlib won't be there, anymore.
19:20:39 <spetrea-home> Eduard_Munteanu: can Maxima be scripted ?
19:20:47 <spetrea-home> Eduard_Munteanu: using Common Lisp ?
19:20:48 <guest2425> Eduard_Munteanu:  I am getting an error message http://pastebin.com/fGYdidbL
19:20:52 <Eduard_Munteanu> spetrea-home: AFAIK, yes.
19:21:10 <ddarius> Eduard_Munteanu: From what I can tell, the UI experience of Mathematica is far better than any of the open source alternatives.  The mathematical abilities also seem to be significantly better than most others, though this is rather uneven.
19:21:12 <Cale> guest2425: Line up your definitions for show, and it'll hopefully not be a syntax error anymore
19:21:27 <spetrea-home> why isn't there a CAS written in Haskell ? it seems to be the exact perfect language for writing a CAS
19:21:28 <ksf> options include things like gl (all that mesa goodness) or a bit higher-level like cairo
19:21:30 <spetrea-home> isn't it ?
19:21:39 <Cale> guest2425: There are some pretty blatant type errors there though.
19:22:07 <Eduard_Munteanu> spetrea-home: you might want to look at some stuff Oleg did with symbolic differentiation in the type system.
19:22:20 <ddarius> spetrea-home: I think there was a relatively simple, but somewhat serious one somewhere.  There is also things like DoCon which provide several typical computational mathematics functions.
19:22:36 <ksf> the nice thing about mesa is that you can use gl on dumb vga cards and if you're not doing anything fancy you're not going to kill performance.
19:23:06 <ddarius> Cale: Just keep tweaking those and you'll get a reasonably, if coarse, approximation of ATP synthase.
19:23:25 <Eduard_Munteanu> ddarius: my needs for symbolic CAS were kinda satisfied by Maxima, I only played once or twice with Mathematica. I can't really comment.
19:23:28 <guest2425> Cale: I got this error now http://pastebin.com/bhvTUHFz
19:23:45 <Eduard_Munteanu> spetrea-home: but apart from that, IDK.
19:24:02 <spetrea-home> I've for my purposes GAP , Pari/GP  and Maxima
19:24:42 <Cale> guest2425: Right, some appropriate type errors.
19:24:43 <spetrea-home> Eduard_Munteanu: it's very curious for me why a company like Wolfram or some big company that writes math software doesn't port all Maxima to Haskell
19:25:01 <spetrea-home> Eduard_Munteanu: I mean, Haskell is the perfect language to implement Math, why write in LISP when you can have it in Haskell
19:25:19 <guest2425> Cale: how can I fix them
19:25:20 <guest2425> ?
19:25:21 <spetrea-home> Eduard_Munteanu: I've looked at DoCon
19:25:44 <Eduard_Munteanu> spetrea-home: economics would disagree with that.
19:26:38 <ricree> is there a library anywhere for filename manipulation, or should I just do it manually from the strings?
19:27:03 <adu> ricree: theres glib
19:27:06 <ksf> http://hackage.haskell.org/package/filepath-1.1.0.4
19:27:34 <guest2425> :t (Cons x xs (Cons x xs Empty))
19:27:35 <lambdabot> Not in scope: `xs'
19:27:35 <lambdabot> Not in scope: `xs'
19:27:36 <lambdabot> Not in scope: data constructor `Empty'
19:27:46 <Eduard_Munteanu> Yeah, glib isn't something you should depend on if you're only doing filepath manipulation.
19:28:07 <Cale> guest2425: You're giving Cons there three parameters
19:28:08 <Eduard_Munteanu> guest2425: look again at List's definition
19:28:09 <ricree> adu:  thank you.
19:28:16 <Cale> guest2425: It only takes 2
19:28:17 <guest2425> :t (Cons x xs (Cons x xs Empty))
19:28:18 <lambdabot> Not in scope: `xs'
19:28:18 <lambdabot> Not in scope: `xs'
19:28:18 <lambdabot> Not in scope: data constructor `Empty'
19:28:18 <adu> ricree: g_build_path_va
19:28:33 <unkanon> silly question: any way to make ghci use a, b, c for type variables when I do :t myflip instead of using the ugly t1, t2, etc?
19:28:33 <ksf> wtf just use filepath
19:28:34 <Cale> guest2425: Of course, those things aren't defined in lambdabot
19:28:38 <Eduard_Munteanu> guest2425: you can't possibly stuff 3 arguments into Cons.
19:28:41 <Cale> guest2425: You could try that in ghci though
19:28:53 <Cale> (it would give you similar errors, unless you define x and xs)
19:29:30 * Eduard_Munteanu imagines shipping Gtk2Hs just for that oO
19:29:46 <guest2425> Cale: like this toList(Cons x xs) = (Cons x xs (Cons x xs Empty))
19:29:52 <ricree> ksf: ah, thanks.  filepath looks more along the lines of what I was hoping for
19:29:58 <guest2425> Cale: only 2 parameters
19:30:14 <Cale> Cons is getting the parameters x, xs and (Cons x xs Empty)
19:30:18 <Eduard_Munteanu> guest2425: yeah, on the left hand side, but look on the right hand side
19:30:26 <Cale> and then again, three parameters because Cons x xs Empty
19:30:44 <Eduard_Munteanu> guest2425: don't you see Cons something something something?
19:30:44 <Cale> guest2425: Think about what toList was originally intended to do.
19:30:56 <Cale> guest2425: It was intended to turn one of your lists into a Haskell list
19:31:03 <guest2425> yes
19:31:09 <guest2425> Cale: yes
19:31:11 <Cale> That is, something built from Cons and Empty into something built from (:) and []
19:31:30 <Cale> So why the heck are Cons and Empty showing up on the right hand side of the definition? ;)
19:32:27 <guest2425> Cale: so i am not supposed to put them
19:32:59 <koiula> just wanna say hi to haskell community
19:33:15 <Cale> koiula: Hello! Learning Haskell?
19:33:17 <guest2425> Cale: so if thats the case then just this toList(Cons x xs) = []
19:33:24 <Cale> guest2425: Not quite...
19:33:33 <guest2425> I need a list
19:33:46 <guest2425> Cale: i need a list in the right hand side
19:33:48 <Cale> guest2425: Right, what should that list start with?
19:33:51 <Cale> yes, you do.
19:33:56 <Cale> But not an empty list.
19:34:00 <Eduard_Munteanu> guest2425: not _any_ list.
19:34:01 <Cale> (In that case)
19:34:19 <guest2425> Cale x:xs
19:34:26 <guest2425> Cale: (x:xs)
19:34:27 <Cale> That's closer
19:34:39 <Cale> But think about what type xs has on the left hand side of the equation.
19:34:49 <Cale> It's a List (rather than a Haskell list)
19:35:13 <guest2425> Cale : x . xs
19:35:18 <guest2425> like that
19:35:18 <Eduard_Munteanu> ?
19:35:19 <Cale> farther :)
19:35:30 <Cale> You want to convert xs from a List to a Haskell list as well.
19:35:35 <guest2425> Cale: what u mean?
19:35:40 <Eduard_Munteanu> x >>= xs? Let's not guess.
19:35:43 <Cale> xs :: List a
19:35:55 <Cale> (:) :: a -> [a] -> [a]
19:36:02 <Cale> x :: a
19:36:23 <Cale> So to get the types to match, you need something of type [a] to give as the second parameter to (:)
19:36:33 <guest2425> Cale: I need this  x :: a
19:36:46 <Cale> So x : something is fine
19:36:59 <Cale> But that something needs to be a Haskell list
19:37:11 <Cale> It can't be one of your custom-defined List values.
19:37:19 <guest2425> Cale: so then x: List
19:37:23 <Cale> However, we have a function  toList :: List a -> [a]
19:37:28 <Cale> No.
19:37:29 <Cale> x :: a
19:37:37 <Cale> x is an element (of an arbitrary type) here
19:37:53 <guest2425> this is what I need  x :: a
19:38:13 <copumpkin> lispy: you around?
19:38:48 <guest2425> Cale: what i need in the right hand side is x: ?
19:39:15 <Cale> guest2425: Yeah, where the question mark has been replaced by something else (I'm letting you think about that)
19:40:46 <Eduard_Munteanu> It might not really be his fault he's finding this that difficult, I wonder whether giving him the solution straight away wouldn't be better.
19:40:53 <Eduard_Munteanu> Maybe his courses covered too little.
19:40:59 <guest2425> Cale: like this toList(Cons x xs) = (x:Empty)
19:41:07 <Cale> Empty :: List a
19:41:12 <Cale> So it's not the right type
19:41:18 <Eduard_Munteanu> guest2425: that wouldn't convert the whole List
19:41:30 <Eduard_Munteanu> guest2425: plus it's a type error
19:41:53 <Zeiris_> Are there any real-world source examples of traversing a syntax tree to find specific elements? My pattern matching code is turning out ugleh, and while I'm sure there's some higher-order patterns to it I'd rather not reinvent the wheel. (I'm using the CoreErlang library.)
19:41:54 <Cale> What we want the tail of the list returned to be is the converted version of xs, that is xs :: List a, but we want something of type [a], and we want it to have the same elements as xs has
19:42:17 <Cale> guest2425: Thankfully, we have a function which does this conversion. It's the function that we're currently defining!
19:42:35 <copumpkin> sx tsiLot : x = )sx x snoC( tsiLot
19:42:49 <Cale> guest2425: So apply toList :: List a -> [a] to the value xs :: List a, and we get toList xs :: [a]
19:42:50 <Eduard_Munteanu> Heh.
19:43:17 <Cale> guest2425: and that will have the right type for what we need.
19:43:20 <guest2425> Cale: so this (x:xs)
19:43:29 <copumpkin> guest2425: ...
19:43:38 <guest2425> Cale: so like this (x:tail)
19:43:42 <copumpkin> guest2425: I asked you before, rhetorically, what is the type of xs there
19:43:55 <guest2425> the tail
19:43:57 <Cale> guest2425: Did you actually read what I wrote, or are you just guessing randomly?
19:43:58 <copumpkin> that isn't a type
19:44:11 <copumpkin> guest2425: give me a type that GHC would accept for xs
19:44:15 <guest2425> Cale: i read what u wrote
19:44:45 <Eduard_Munteanu> data [a] = [] | a : [a]
19:44:47 <litb_> Cale seems to know stuff
19:44:53 <Cale> guest2425: I wrote that the tail of the list that we want to produce should be toList xs. The head of the list that we're producing is x.
19:45:12 <Cale> guest2425: So the answer is that toList (Cons x xs) = x : toList xs
19:45:13 <litb_> wait wtf is  data [a] = [] | a : [a]  ?
19:45:13 <copumpkin> guest2425: he basically gave you the answer in words
19:45:15 <Eduard_Munteanu> data List a = Empty | Cons a (List a)
19:45:24 <mauke> litb_: the definition of []
19:45:35 <Eduard_Munteanu> Please stop mixing them.
19:45:42 <litb_> i'm starting to loose my marbles
19:46:01 <guest2425> cale: oh ok
19:46:16 <guest2425> Cale: so i need it to include the function name
19:46:32 <Cale> litb_: Of course, that's only schematic, it's not valid Haskell syntax. (:) and [] are built in
19:46:40 <litb_> Eduard_Munteanu: where is the "Cons" part in the list version?
19:46:50 <djahandarie> litb_,     List a = Nil | Cons a (List a)     =>    [] a = [] | (:) a ([] a)     =>   [a] = [] | a : [a]
19:46:52 <copumpkin> litb_: infix, as :
19:46:54 <litb_> Cale: ohh i thought it's valid syntax
19:47:09 <copumpkin> guest2425: the way you phrased that disturbs me :(
19:47:14 <Eduard_Munteanu> litb_: no, but you can define infix data constructors.
19:47:20 <Cale> guest2425: It's not a syntactic problem. It's about what the function actually does.
19:47:23 <litb_> copumpkin: ah i see
19:47:37 <guest2425> Cale: oh ok
19:47:54 <litb_> so could we say   data *a* = ** | a * *a*   ?
19:47:56 <Cale> guest2425: toList (Cons x xs) needs to not only convert this Cons cell into a Haskell (:), it needs to convert the remainder of the list (which is xs) as well.
19:48:09 <Cale> guest2425: To do that, it applies itself to the remainder of the list.
19:48:11 <Eduard_Munteanu> litb_: mm, no.
19:48:21 <guest2425> Cale: ok i got it I am getting this error message http://pastebin.com/5fy43yK9
19:48:42 <litb_> i.e   *a*  would be  a  list of a.  and   0 * *1*   would be  *0,1*
19:48:48 <Cale> Right, show a = toList  is nonsense.
19:48:49 <ddarius> The disillusionment of copumpkin begins.
19:48:55 <Eduard_Munteanu> litb_: but you can say    data List a = Empty | a Cons (List a)
19:49:05 <Eduard_Munteanu> if Cons is infix
19:49:10 <litb_> boring alphanumerics :/
19:49:35 <litb_> ah but alphanumberics as infix need backticks i think
19:49:54 <mauke> litb_: : is the only uppercase punctuation char
19:49:54 <litb_> like   1 `add` 2
19:50:11 <litb_> ohh
19:50:20 <guest2425> Cale: so is show toList
19:50:28 <copumpkin> ddarius: :(
19:50:33 <fengshaun> guest2425: I think that should be: show a = show . toList $ a
19:51:18 <Cale> Or in a more beginner-friendly way,  show a = show (toList a)
19:51:21 <litb_> can you not curry that?
19:51:38 <mauke> that's not really curried
19:51:44 <mauke> the functions really take only one arg
19:51:51 <Cale> Or in a less verbose way:  show = show . toList
19:52:04 <litb_> ohh i thought it would be    show a = (show . toList) a   but i guess i had it wrong xD
19:52:10 <copumpkin> Cale: you need to put the function name in? why not just show = show?
19:52:11 <copumpkin> ;)
19:52:19 <Cale> litb_: That would also be fine
19:52:20 <mauke> litb_: hmm? that's also ok
19:52:44 <fengshaun> litb_: (show . toList) a is almost the same as show . toList $ a
19:52:44 <Cale> copumpkin: You mean " = . toList"
19:52:45 <litb_> ah yes i see now
19:52:51 <copumpkin> :)
19:53:03 <litb_> $ has less priority than .
19:53:18 <Cale> litb_: Yeah, that's essentially the point of $
19:53:22 <guest2425> what is $ means
19:53:24 <guest2425> ?
19:53:26 <Cale> litb_: f $ x = f x
19:53:34 <Cale> But $ has really low precedence
19:53:34 <litb_> ohh i see now
19:53:40 <litb_> :P
19:54:02 <fengshaun> > :info ($)
19:54:03 <lambdabot>   <no location info>: parse error on input `:'
19:54:11 <fengshaun> :t ($)
19:54:12 <lambdabot> forall a b. (a -> b) -> a -> b
19:54:16 <fengshaun> guest2425: ^^^
19:54:25 <litb_> lol
19:54:31 <fengshaun> guest2425: function application operator
19:54:54 <Quadrescence> x $ y is the same as x (y)
19:55:03 <guest2425> oh ok
19:55:05 <guest2425> thanks
19:55:10 <Cale> Or (x) (y) even ;)
19:55:23 <Quadrescence> f $ 1 + 2 + 3 + 4 ====> f (1+2+3+4)
19:55:24 <jmcarthur> or (((x))) (((((((y)))))))
19:55:25 <litb_> so in  short     blah blup buzz $ haha this rocks   is   (((blah blup buzz) haha) this) rocks
19:55:28 <litb_> xD
19:55:30 <jmcarthur> just to cover all the bases
19:55:46 <Quadrescence> my example helped the most
19:55:54 <Quadrescence> since it's the only god damn way most ppl use it
19:55:55 <Cale> litb_: actually, it's ((blah blup) buzz) ((haha this) rocks)
19:55:57 <jmcarthur> @pl blah blup buzz $ haha this rocks
19:55:58 <lambdabot> blah blup buzz (haha this rocks)
19:56:07 <litb_> ohh right. /me fails again
19:56:25 <fengshaun> litb_: I don't think so, that would be ((blah blup) buzz) ((haha this) rocks)
19:56:32 <Quadrescence> litb_: i think you're wrong
19:56:38 <litb_> lol
19:56:46 <jmcarthur> let's keep telling litb_ how wrong he is
19:57:25 <Quadrescence> Cale: join #haskell-blah 
19:57:38 <Cale> Quadrescence: Something interesting there?
19:57:48 <litb_> they have the blah quantor
19:58:41 <Eduard_Munteanu> Heh, did guest2425 figure out toList? I see he moved on to the Show instance.
19:58:55 <koiula> haskell is strange and fun
19:59:14 <guest2425> yeah i did
19:59:17 <Eduard_Munteanu> Either he's a bad learner, or he has a really bad teacher. Could be either way, I'm not judging.
19:59:17 <guest2425> thank you
20:00:01 <guest2425> Eduard_Munteanu: I have a really hard hard teacher
20:00:29 <Eduard_Munteanu> I can't blaim him, this is very basic stuff, there's little else to base on.
20:01:06 <Eduard_Munteanu> guest2425: you said you used LYAH as a reference, you could've found out the answer by looking further through it I guess.
20:01:13 <Eduard_Munteanu> @where lyah
20:01:14 <lambdabot> http://www.learnyouahaskell.com/
20:06:29 <ddarius> koiula: I imagine people say much the same thing upon their first time using cocaine.
20:07:12 <JoeyA> Mind filling me in, ddarius | koiula ?
20:13:13 <Eduard_Munteanu> I'd have some 'caine' right now, I don't feel like reversing its arrows.
20:15:35 <guest2425> Cale: sorry again is me
20:16:23 <guest2425> Cale: Can I do this {3,4,5}
20:16:39 <guest2425> Cale: with that function I was writing
20:16:43 <Cale> ?
20:16:46 <copumpkin> man
20:17:03 <Cale> I don't understand the question. {3,4,5} isn't valid Haskell syntax though.
20:17:35 <Eduard_Munteanu> Perhaps I shouldn't... that would place me in the category Junkies.
20:17:53 <guest2425> Cale: Modify the show function from 8.1 a to use braces instead of square brackets. 
20:18:23 <guest2425> Cale: thats what the proffesor want us to do Modify the show function from 8.1 a to use braces instead of square brackets. 
20:18:30 <koninkje> Does cabal set any cpp flags when running haddock in order to know when files are being read by haddock?
20:18:37 <Eduard_Munteanu> { } in Haskell can mean a number of things.
20:18:49 <ddarius> koninkje: Haddock should set flags.
20:18:50 <Cale> Okay, now I understand what you want...
20:19:02 * Eduard_Munteanu is clueless
20:19:20 <Cale> Well... you could do it the cheesy way, or you could take a step back, and reimplement show directly, instead of in terms of the built-in show for lists
20:19:28 <jmcarthur> Eduard_Munteanu: he wants the braces in the resulting string, not in the haskell source code
20:19:36 <dobblego> show (Cons 3 (Cons 4 (Cons 5 Empty))) -> "{3,4,5}"
20:19:48 <guest2425> Cale: i choose the cheesy one
20:19:51 <koninkje> ddarius: then which flags does it set?
20:20:30 <ddarius> koninkje: Check its documentation.
20:20:34 <Cale> guest2425: Okay, then you just need to do something like drop the first and last element of the string, and concatenate on some different braces :P
20:20:56 <guest2425> Cale: how?
20:21:08 <Cale> guest2425: But if this is for a course, I recommend doing show the right way instead.
20:21:18 <dobblego> @src show []
20:21:18 <lambdabot> Source not found. Do you think like you type?
20:21:39 <ddarius> If this is for a course, I'd recommend learning the material, but I'm old-fashioned.
20:21:55 <Eduard_Munteanu> jmcarthur: oh.
20:22:06 <Eduard_Munteanu> I guess I see why.
20:22:16 <guest2425> Cale: i still choose the cheesy way how i can do that
20:22:21 <Eduard_Munteanu> Though this is easy to circumvent too.
20:22:45 <Cale> guest2425: Well, you'll want to know about tail and init
20:22:50 <Eduard_Munteanu> Simply map and replace '[' with '{' in show's result.
20:22:53 <Cale> actually, here's a nice diagram...
20:22:58 <Eduard_Munteanu> (show on Haskell lists)
20:23:01 <jmcarthur> honestly i think the proper way would be just about as easy as the cheesy way
20:23:14 <Cale> http://s3.amazonaws.com/lyah/listmonster.png
20:23:24 <Cale> > init "[1,2,3]"
20:23:24 <lambdabot>   "[1,2,3"
20:23:28 <Eduard_Munteanu> jmcarthur: yeah, if you did the first part properly, changing it is easy.
20:23:29 <Cale> > tail "[1,2,3]"
20:23:30 <lambdabot>   "1,2,3]"
20:23:35 <Cale> > tail (init "[1,2,3]")
20:23:36 <lambdabot>   "1,2,3"
20:23:43 <MtnViewMark> Love that diagram
20:23:51 <Cale> > "{" ++ tail (init "[1,2,3]") ++ "}"
20:23:52 <lambdabot>   "{1,2,3}"
20:24:41 <ddarius> Eduard_Munteanu: That doesn't work.
20:24:48 <Cale> I wonder if BONUS had to get permission from Nintendo to use the likeness of that character.
20:24:56 <guest2425> Cale: do i put this in the toList function
20:24:59 <guest2425> ?
20:25:04 <Cale> guest2425: no
20:25:20 <guest2425> Cale: where?
20:26:29 <MtnViewMark> Alex, is the question: "How does one get a string representation of a list, but with braces?"?
20:26:40 <copumpkin> guest2425: you are not giving the impression of putting any thought into this assignment
20:26:50 <copumpkin> are you at the "man, I just need to finish this and get it over with" stage?
20:26:59 <ddarius> Eduard_Munteanu: However, that probably works well enough for this code.  See my comments early this morning: [04:53] <ddarius> endojelly: One should just slather text into a file until it compiles and passes the few test inputs you have, then call it done.
20:27:40 <MtnViewMark> Considers "endojelly"... 
20:27:53 <jmcarthur> copumpkin: you would be surprised how many people actually believe that blindly guessing is a perfectly fine strategy for real problems
20:28:06 <copumpkin> jmcarthur: man, the real world scares me!
20:28:24 <MtnViewMark> If life were only multiple choice...
20:28:38 <jmcarthur> life is multiple choice
20:28:42 <monochrom> life is multiple choice. just infinitely.
20:28:59 <ddarius> Blindly guessing is a a perfectly fine strategy for real problems, it's simply not the only or usually the best strategy, but it is certainly one available and acceptable.
20:29:03 <monochrom> so just imagine multiple choice and generalize to infinity
20:29:19 <ddarius> monochrom: Is this infinity countable or not?
20:29:29 <Eduard_Munteanu> ddarius: um? I don't get it. Let show a = replace . show . toList $ a. I'm pretty sure there's a replace :: String -> String that does just that.
20:29:31 <MtnViewMark> Throws darts into the abyss
20:29:38 <jmcarthur> ddarius: okay, it passes your "life strategy" type checker :P
20:29:52 <ddarius> MtnViewMark: Just to say, that comment wasn't about endojelly's behavior but rather the behavior of a person he was interacting with at the time.
20:29:53 <monochrom> hmm, multiple choice, "A. countable", "B. uncountable", choice choice choice...
20:30:21 <copumpkin> being countable or not makes a big difference
20:30:36 <jmcarthur> multiple choice: "A. My decision process for this problem does not terminate."
20:30:38 <MtnViewMark> Ah - I was just enjoying his nick: mmmm endojelly on toast....
20:31:01 <MtnViewMark> ... With copeanut-butter, clearly
20:31:19 <ddarius> Eduard_Munteanu: There certainly isn't a unary such replace, and in fact there isn't one taking some strings or a lookup table, there is however map which works.  The problem is that your solution changes -all- []s to {}s which is incorrect.
20:31:40 <monochrom> blind guessing is fine as long as the guesser don't come back to ask "why is my blind guess rejected"
20:31:55 <jmcarthur> it's like bogosort
20:32:35 * jmcarthur deems this style of programming "bogoprogramming"
20:34:00 * copumpkin is a bogoprogrammer
20:34:06 <copumpkin> AND PROUD OF IT
20:34:22 <ddarius> copumpkin: The trick is you use Agda, so if it compiles it works.
20:34:31 <copumpkin> hell yeah
20:34:53 <copumpkin> the prof who assigned the exercise all these students seem to be asking for
20:35:00 <copumpkin> should've assigned it in agda with suitable types
20:35:36 <monochrom> agda is too hard for the prof
20:35:48 <djahandarie> You can't write recursionEngine in agda obv
20:35:54 <copumpkin> true
20:36:16 <ddarius> You just parameterize with proofs of productivity.
20:36:58 <dankna> proof of productivity is my new favorite term
20:37:02 <copumpkin> http://sites.google.com/site/russabbott/ is him I think
20:37:11 <dankna> next time my boss asks me if I'm getting work done I shall respond with one of them
20:37:25 <Eduard_Munteanu> ddarius: I still don't get you, what wrong with... replace [] = []; replace ('[':xs) = '{':(replace xs); replace (']':xs) = '}':(replace xs); replace (x:xs) = x:(replace xs)    ?
20:37:43 <koninkje> ddarius: alas haskell.org is down
20:37:45 <Eduard_Munteanu> replace :: String -> String
20:37:57 <Eduard_Munteanu> show :: a -> String
20:38:09 <Eduard_Munteanu> toList :: List b -> [b]
20:38:22 * monochrom adds to the list of papers "recursionEngine and human intelligence"
20:39:09 <copumpkin> I don't see why people don't just link to http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010/Week_8._Homework
20:39:35 <ddarius> Eduard_Munteanu: 1) it can be more simply written as map (\c -> case c of '[' -> '{'; ']' -> '}'; _ -> c) and 2) what if you have a List [a]?  The result should be {[1,2]} not {{1,2}}.
20:40:39 <ddarius> and 3) ETOOMANYPARENS
20:40:40 <Eduard_Munteanu> Ah, I guess I misunderstood his assignment then.
20:40:51 <Eduard_Munteanu> :)
20:41:48 <monochrom> @tell BONUS http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010
20:41:49 <lambdabot> Consider it noted.
20:41:52 <monochrom> hehehe
20:42:01 <ddarius> (as another example you want {"["} not {"{"}
20:44:25 * ddarius also sighs about the (recent) movie rendition of "Around the World in Eighty Days" which destroys the character, humor, and point of the book.
20:46:11 <Funktorsalat> . o O ( movie rendition of the haskell 98 report )
20:48:51 <ddarius> A movie rendition of the History of Haskell would be scary.
20:50:01 <ddarius> "A young man of thirty advanced and bowed."
20:54:09 <monochrom> "A young man of thirty advanced and type-checked."
20:56:48 <lispy> copumpkin, Phyx-: looking for me?
20:57:15 <copumpkin> lispy: I was wondering if you knew what voodoo yav is doing on github with type-level number literals in GHC and where his voodoo-ful branch of GHC lives, if anywhere public
20:59:18 <shepheb> is there aa GHC option to have it dump the post-TH-expansion code? is that code still in a readable state?
21:01:50 <lispy> copumpkin: I have no idea
21:03:11 <ddarius> shepheb: If you only need something specific, you can simply execute the TH code and print its result as the output of a program.
21:03:29 <ddarius> That said, I'm pretty sure there is something that would catch that output at an early enough time to still be readable.
21:03:38 <ddarius> Check the documentation... (somehow)
21:05:12 <Funktorsalat> shepheb: -ddump-splices
21:06:15 <Funktorsalat> maybe at some verbosity level it dumps the whole post-TH code (not just the expansions), I don't remember
21:11:13 <ksf> there's also noth, which does a .hs->.hs conversion.
21:12:16 <ksf> ...which you should bloody well use if your stuff is machine-independent and takes ages. put result in the tgz, keep source in the repo.
21:12:45 <ksf> xhb comes to mind, though it might be fixed by now.
21:14:48 <Axman6> ksf: what is noth? got a link?
21:15:42 <ksf> hmm. was it called like that?
21:16:00 <Funktorsalat> zeroth maybe
21:16:16 <ksf> http://hackage.haskell.org/package/zeroth-2009.6.23.2
21:16:18 <ksf> yep that's it.
21:31:11 <krainboltgreene> Is haskell.org down?
21:31:37 <tolkad> What's wrong with the haskell wiki?
21:31:54 <copumpkin> http://snapplr.com/aqfb
21:31:57 * copumpkin points at topic
21:31:58 <blackdog> http://downforeveryoneorjustme.com/haskell.org
21:32:13 <tolkad> oh
21:32:45 <krainboltgreene> Open browser, type url, copy url, paste url, click url, look at browser.
21:32:55 <krainboltgreene> Or "Yes"||"No"
21:33:00 <blackdog> it's starting to get a bit sketchy to be hosting it at galois offices, really
21:33:08 <blackdog> teach a man to fish:)
21:33:50 <copumpkin> krainboltgreene: you had to write the question into IRC
21:33:51 <krainboltgreene> Bore an old fisher.
21:33:53 <krainboltgreene> :P
21:33:54 <copumpkin> :)
21:34:40 <jmcarthur> blackdog: haskell.org is not hosted by galois
21:35:00 <jmcarthur> hackage is
21:35:08 <krainboltgreene> The annoying part is the Xmonad cheatsheet isn't hosted on Xmonad, but haskell.org
21:35:24 <blackdog> jmcarthur: ah, my mistake. still, in a way that's the more crucial infrastructure.
21:35:26 <arcatan> no cheating allowed!!
21:35:40 <krainboltgreene> Still, Xmonad is pretty awesome.
21:43:55 <tolkad> some of these links are broken: http://hackage.haskell.org/package/base-4.2.0.2
21:44:14 <tolkad> try clicking something in the "GHC" section
21:44:19 <tolkad> hmm
21:44:27 <tolkad> like GHC.Float
22:11:55 <hasenov> hello, i am trying to pass XBangPatterns to ghc for building, how would I accomplish this using configure utility?
22:13:12 * hackagebot relacion 0.1 - A relation data structure.  http://hackage.haskell.org/package/relacion-0.1 (LeonelFonseca)
22:15:45 <exDM69> hasenov: the preferred way seems to put the compiler arguments in the source files
22:16:00 <exDM69> hasenov: although I recon you should be able to do that with Cabal too
22:17:08 <exDM69> the preferred way = the way I've seen most examples of
22:18:36 <arcatan> with Cabal, you can add Extensions: BangPatterns to your .cabal file.
22:18:56 <arcatan> but what do you mean with configure utility?
22:19:56 <hasenov> i am trying to compile my own version of head of ghc
22:20:47 <hasenov> on templates/GenericTemplate.hs it errors out with "Illegal bang-pattern (use -XBangPatterns)"
22:21:05 <arcatan> oh
22:21:12 <hasenov> so i was thinking i could pass -XBangPatterns to configure initially like u pass to ghc
22:22:23 <hasenov> however i tried --enable-feature=-XBangPatterns but doesn't seem like it is working
22:41:50 <jdavis> The result of this expression surprised me. Can someone please explain it to me? Control.Monad.forM "asdf" $ \x -> x : ['-']
22:42:17 <Zao> What's the result, and there's a list monad.
22:42:45 <jdavis> ["asdf","asd-","as-f","as--","a-df","a-d-","a--f","a---","-sdf","-sd-","-s-f","-s--","--df","--d-","---f","----"]
22:42:45 <jdavis> \
22:43:08 <zooko> Folks: http://haskell.org appears to be down. Is there a mirror of the mailing list archives for glasgow-haskell-users ? How about for http://www.haskell.org/ghc/download_ghc_621.html ?
22:44:12 <shachaf> zooko: There's http://hackage.haskell.org/platform/
22:44:25 <arcatan> zooko: http://new-www.haskell.org/ghc/download_ghc_621
22:44:26 <jdavis> Zao: I don't quite see how I got an n-squared effect from that list.
22:44:43 <shachaf> zooko: And there's http://blog.gmane.org/gmane.comp.lang.haskell.glasgow.user
22:44:48 <shachaf> @src forM
22:44:48 <lambdabot> forM = flip mapM
22:44:50 <shachaf> @src mapM
22:44:51 <lambdabot> mapM f as = sequence (map f as)
22:44:53 <shachaf> @src sequence
22:44:53 <lambdabot> sequence []     = return []
22:44:53 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
22:44:53 <lambdabot> --OR
22:44:53 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
22:45:16 <shachaf> sequence in the list monad takes a cartesian product.
22:45:30 <zooko> new-www eh? :-) Is the plan to replace www.haskell.org with new-www.haskell.org? Is that why haskell.org is down?
22:45:35 <zooko> Thanks for the help!
22:46:47 <jdavis> shachaf: oh, thanks. Is there an intuition behind "sequence" doing a cartesian product?
22:47:07 <arcatan> yes, we're combating haskell becoming too popular
22:47:20 <shachaf> jdavis: Well, do {x <- l1; y <- l2; return (x,y) } also takes a cartesian product.
22:47:29 <shachaf> jdavis: It's just like a list comprehension.
22:48:02 <jmcarthur> :t sequence
22:48:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
22:48:28 <shachaf> > let sequ [] = [[]]; sequ (x:xs) = [v:vs | v <- x, vs <- sequ xs] in sequ ["ab","cd","ef"]
22:48:29 <lambdabot>   ["ace","acf","ade","adf","bce","bcf","bde","bdf"]
22:48:31 <jmcarthur> > sequence [[1,2,3],[4,5,6],[7,8,9]]
22:48:32 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
22:48:57 <jmcarthur> > sequence [[1,2],[3,4],[5,6]]
22:48:57 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
22:49:06 <shachaf> jdavis: That'd be equivalent to the @src definition, if we had monad comprehensions. :-)
22:49:31 <zooko> Okay, thanks, folks!
22:49:41 <jdavis> shachaf: Ok, thanks. I will have to think about it a little.
22:57:43 <FDFlock> Sorry if it has already been mentioned, but www.haskell.org seems to be down for me (I was reading a tutorial the other day and today I cannot access it). "www.haskell.org is taking too long to respond" Am I the only one with that problem? (my ISP is pretty bad)
22:58:19 <Zao> FDFlock: Seems generally AWOL.
22:59:04 <Zao> new-www seems up though, whatever that is.
23:03:58 <FDFlock> Zao: Heh, I see. They seem to be in the process of migrating. Too bad that the page I was reading isn't accessible from new-www.haskell.org. Thank you anyway.
23:04:03 <FDFlock> On a sidenote, tryhaskell.org seems cool.
23:05:46 <pkrumins> hey guys, wanted to let you know that HASKELL.ORG IS DOWN AGAIN
23:06:29 <jdavis> I'm going through Real World Haskell, and I'm trying to use some of the regex examples. However, when I do: "foo" =~ "bar" :: [String]   it doesn't work. "foo" =~ "bar" :: String works fine, but the book says that there's also a version that returns a list of strings.
23:06:31 <FDFlock> pkrumins: That's what I was typing 5 minutes earlier... :P Try new-www.haskell.org
23:06:40 <pkrumins> new-www!
23:06:55 <pkrumins> it works!
23:07:15 <endojelly> The requested URL /hoogle/ was not found on this server.
23:07:45 <endojelly> this is embarassing, you know?
23:08:14 <endojelly> the overall stability of haskell.org, I mean
23:08:44 <ibt> i'll second that
23:09:51 <endojelly> just because the stability of your WEB PRESENCE WITH ALL RELEVANT RESOURCES isn't theoretically interesting doesn't mean you don't have to take care of it.
23:10:57 <FDFlock> Totally unrelated comment: My progress on learning Haskell hasn't progressed AT ALL during the last 20 days due to lack of time (And I've started 21 days ago, or so), but it's nice to see that there is such a friendly/healthy community built around the language :)
23:11:07 * FDFlock goes back to being away... :)
23:12:06 <endojelly> FDFlock, yeah, the community (despite their lack of a stable web presence ;) ) is really one of the better ones when it comes to programming languages, or technical communities in general. #haskell is a channel where people seem actually friendly and hepful 8)
23:12:16 <FDFlock> :)
23:15:28 <endojelly> how can I ask lambdabot if there's an instance of a given class for a given type?
23:16:30 <Gracenotes> @instances Eq
23:16:30 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
23:17:23 <Cale> endojelly: It's probably safer to ask GHCi for this information using :info ClassName
23:17:35 <Cale> endojelly: Because it depends on which modules you have imported.
23:17:56 <Gracenotes> for lambdabot, at least, there's also instances-importing.. if the instance is in some yet-unimported module
23:17:59 <endojelly> Cale, that's the point: if there's a somewhat common module which defines it, I want to know
23:18:16 <Cale> okay :)
23:19:02 <endojelly> Cale, but thanks, turns out with :info that what I'm looking for is already in the module defining the class 8)
23:19:37 <endojelly> (that's the one if anyone cares: instance (Monoid a, Monoid b) => Monoid (a, b))
23:19:52 <endojelly> (it's pretty trivial but I didn't know whether it's already there)
23:21:06 <Gracenotes> endojelly: it is in Data.Mnoid
23:21:33 <Gracenotes> and up to 5-tuples
23:21:42 <endojelly> Gracenotes, yep, look what I wrote just before!
23:21:59 <endojelly> instance Monoid b => Monoid (a -> b) where
23:22:06 <endojelly> hm, I have to wrap my head around that one
23:23:57 <Gracenotes> for instance.. how would you combine an (Int -> String) and an (Int -> String) to produce a (Int -> String) that calls them both?
23:24:52 <endojelly> oh okay, it's just function composition for functions in the same monoid?
23:25:37 <endojelly> okay that statement was a bit flakey %)
23:25:45 <endojelly> but I think I get it: apply both, concatenate them
23:26:08 <endojelly> or better, `mappend` them
23:26:41 <Gracenotes> that's just about it
23:27:28 <endojelly> so if my two functions are toDec and toHex, (toDec `mappend` toHex) 10 would result in "10A"?
23:29:09 <Gracenotes> yes
23:30:14 <Gracenotes> check out some other instances too. http://darcs.haskell.org/packages/base/Data/Monoid.hs
23:31:13 <endojelly> > (length . filter (== 'a')) `mappend` length $ "abbaaaaba"
23:31:13 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Int)
23:31:14 <lambdabot>    arising from a use of...
23:31:33 <endojelly> oh, I thought Int was a perfectly good Monoid under addition
23:31:49 <endojelly> > (filter (== 'a')) `mappend` reverse $ "abbaaaaba"
23:31:50 <lambdabot>   "aaaaaaabaaaabba"
23:31:56 <endojelly> nice 8)
23:32:00 <endojelly> that wasn't too hard!
23:32:03 <endojelly> Gracenotes, thanks a lot
23:32:12 <endojelly> I like the Last Monoid, I'll also need it
23:32:57 <endojelly> > ("hello", Last 1) `mappend` (" world", Last 2)
23:32:57 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
23:32:58 <lambdabot>    arising from a use of...
23:33:08 <endojelly> > ("hello", Last $ Just 1) `mappend` (" world", Last $ Just 2)
23:33:09 <lambdabot>   ("hello world",Last {getLast = Just 2})
23:33:17 <endojelly> I love Haskell.
23:33:17 <Gracenotes> it's a lot like 'last . catMaybes'
23:33:48 <Gracenotes> or, more accurately, 'listToMaybe . reverse . catMaybes' (the maybe functions from Data.Maybe)
23:33:49 <endojelly> Gracenotes, yep, but it's useful if your Monoid is a tuple
23:36:03 <endojelly> > (Sum . filter (== 'a')) `mappend` (Sum . reverse) $ "abbaaaaba"
23:36:03 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
23:36:04 <lambdabot>    arising from a use of `Da...
23:36:20 <endojelly> > (Sum . length . filter (== 'a')) `mappend` (Sum . length) $ "abbaaaaba"
23:36:21 <lambdabot>   Sum {getSum = 15}
23:36:26 <endojelly> great
23:36:46 <Gracenotes> > map (uncurry $ comparing length `mappend` compare) [("hi", "there"), ("indeed", "so"), ("well", "then"), ("maybe", "maybe")]
23:36:47 <lambdabot>   [LT,GT,GT,EQ]
23:37:33 <endojelly> Gracenotes, heh, nice
23:37:55 <vegai> is there a darcs command that gives me a list of files that are in the local dir but not added to the repository?
23:37:56 <Gracenotes> more or less the only use of Monoid on Ordering...
23:38:14 <Gracenotes> darcs add <tab complete>?
23:39:40 <Gracenotes> if your system supports it. though personally, having ten thousand files in a given repository folder with just ~100 actually tracked, tab completion can get really expensive..
23:39:41 <Entroacceptor> darcs diff
23:40:27 <vegai> Entroacceptor: nope
23:40:45 <Entroacceptor> no, sorry
23:40:49 <Entroacceptor> darcs whatsnew -l
23:40:51 <vegai> e.g. hg status does this
23:40:59 <vegai> ah, yes. Thank you
23:41:13 <vegai> I did check whatsnew but missed the -l parameter
23:41:38 <Gracenotes> aw. I also came up with "darcs add --recursive --dry-run .".. considerably more convoluted
