00:00:44 <Eduard_Munteanu> @hoogle foldl'
00:00:44 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
00:00:44 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
00:00:44 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
00:06:10 <durble> hello all
00:06:24 <durble> what the purpose of "const" ?
00:07:05 <durble> I can't seem to find a reason for its existence...
00:08:27 <Veinor> sometimes you just need a function that does that
00:08:53 <durble> it simply returns its first argument, correct?
00:08:58 <arcatan> it is sometimes useful.. just randomly searching my code archive, I've converted an Either to Maybe with either (const Nothing) Just
00:09:16 <arcatan> > either (const Nothing) Just $ Left 1
00:09:16 <lambdabot>   Nothing
00:09:20 <arcatan> > either (const Nothing) Just $ Right 1
00:09:21 <lambdabot>   Just 1
00:09:26 <Veinor> > const 2 3
00:09:27 <lambdabot>   2
00:09:33 <durble> I see
00:09:35 <durble> hmmmmmm
00:10:19 <durble> I'm trying to take a list of tuples and convert it to a list of lists, grouped by the first element of each tuple
00:10:33 <geheimdienst> durble, you can say it's a function that throws away one argument. suppose you use map over a list ...
00:10:44 <geheimdienst> > map (const 42) [1,2,3]
00:10:45 <lambdabot>   [42,42,42]
00:11:04 <durble> i.e -->    [(2,3),(2,6),(4,5),4,9)] becomes [[2,3,6],[4,5,9]]
00:11:23 <durble> *sorry, missed an opening paren in the input 
00:11:27 <geheimdienst> so, suppose for some reason i don't care about the actual 1, 2 and 3 in this case, i just want the same number of things in the resulting list
00:11:43 <geheimdienst> note that's the same as > map (\_ -> 42) [1,2,3]
00:11:57 <durble> yeah, underscores as an ignoring case
00:16:40 <arcatan> durble: i'd go about it using groupBy to group them and then convert the grouped to a list
00:16:51 <arcatan> grouped tuples that is
00:18:38 <durble> [(2,3),(2,6),(4,5),(4,9)] becomes [[2,3,6],[4,5,9]]
00:18:40 <durble> and ideas?
00:19:04 <Eduard_Munteanu> Why is this slow? http://paste.pocoo.org/show/288199/
00:19:24 <Eduard_Munteanu> The intention is to count the frequency of each char in the file.
00:20:42 <Eduard_Munteanu> On a 1.3MiB file it's really slow. Have I messed up my strictness expectations there?
00:21:12 <arcatan> > groupBy (\(a,_) (b,_) -> a == b) [(2,3), (2,6), (4,5), (4,9)]
00:21:13 <lambdabot>   [[(2,3),(2,6)],[(4,5),(4,9)]]
00:22:18 <durble> arcatan, my good sir, you are a scholar and a gentleman!
00:22:22 <companion_cube> > groupBy ((==) `on` fst) [(2,3),(2,6),(4,5),(4,9)]
00:22:23 <lambdabot>   [[(2,3),(2,6)],[(4,5),(4,9)]]
00:22:34 <Veinor> Eduard_Munteanu: I'm pretty sure that data.array isn't strict
00:22:45 <durble> you too companion_cube!
00:22:53 <durble> many thanks, kind sirs
00:22:58 <Eduard_Munteanu> Veinor: even with foldl'? What would you suggest?
00:23:01 <durble> and Im off to study more!
00:23:11 <Veinor> I have no clue
00:23:16 <Veinor> I have no experience optimizing haskell code :x
00:23:21 <Eduard_Munteanu> :)
00:23:52 <arcatan> ah, i always think there should be something like on and never remember its existence
00:24:39 <Veinor> it's definitely slow, though
00:26:04 <guest2425> I am happy
00:26:06 <Veinor> and if I just have countSym' arr x = arr, it's fast
00:26:09 <Veinor> so it is the update
00:26:09 <guest2425> How is everybody
00:27:02 <Eduard_Munteanu> Veinor: hm... that makes sense. Also memory consumption goes up like hell.
00:27:18 <Veinor> yeah
00:27:22 <Veinor> that means you're not being strict enough
00:27:25 <Eduard_Munteanu> Veinor: so probably it isn't the indexing itself.
00:27:30 <Eduard_Munteanu> Hm...
00:27:34 * Eduard_Munteanu looks at the docs...
00:28:25 <Eduard_Munteanu> Maybe UArray does it...
00:28:53 <arcatan> seems you're looking for mutable arrays
00:29:42 <Eduard_Munteanu> Yep, a lot faster...
00:29:59 <Eduard_Munteanu> arcatan: not really, the fold should proceed faster through strictness and memoization.
00:30:19 <Eduard_Munteanu> Veinor: thanks
00:30:22 <Veinor> yeah, i don't get why saying countSym' arr x = arr `seq` blahblah isn't forcing the thunks
00:31:27 <arcatan> okay
00:31:44 <Eduard_Munteanu> arcatan: please do say if I'm wrong there.
00:32:07 <Eduard_Munteanu> arcatan: after all, I'm merely trying to find a way to go through that file only once, that's the idea.
00:32:46 <Veinor> man, laziness annoys me sometimes in cases like this. :P
00:33:28 <arcatan> Eduard_Munteanu: no idea, really, I don't know much about this kind of things
00:33:44 <Eduard_Munteanu> Hmm... I wonder if strictness annotation helps...
00:34:16 <Eduard_Munteanu> Anyway, unboxed should do, I don't care that much.
00:34:24 <Eduard_Munteanu> It's really fast now.
00:38:42 <Saizan> Veinor: maybe the thunks are inside the array
00:38:55 <Veinor> that's possible
00:39:35 <Saizan> and UArray being uboxed prevents that
00:42:15 <Eduard_Munteanu> Saizan: is there any way to keep it boxed but strict?
00:42:36 <Eduard_Munteanu> Saizan: I'm not sure I should bother though, I just want to be safe in case I go outside bounds.
00:42:56 <Saizan> Eduard_Munteanu: UArray checks bounds too
00:43:13 <Eduard_Munteanu> Saizan: oh, I see, then it's only the values that are unboxed. Thanks.
00:43:18 <Veinor> Eduard_Munteanu: add a (arr ! i) `seq` to the definition of countSym'
00:43:19 <Eduard_Munteanu> UArray it is then.
00:43:22 <Saizan> Eduard_Munteanu: yeah
00:43:34 <Veinor> it forces the entry in the array to be evaluated before it updates it
00:43:45 <Eduard_Munteanu> Veinor: is it fast?
00:44:12 <Veinor> yep
00:44:20 <Eduard_Munteanu> Anyway, I'll just keep the UArray, seems simpler and cleaner, but thanks Veinor.
00:44:25 <Veinor> fast and constant memory
00:44:49 <arcatan> meh, now the Array version doesn't want to die
00:45:17 <Eduard_Munteanu> arcatan: quick, a few ctrl+c until the OOM killer comes in
00:47:21 <Veinor> or ctrl+\
00:47:36 <Eduard_Munteanu> Yup, seems just as fast with 'seq'.
00:47:57 <arcatan> Eduard_Munteanu: http://hpaste.org/41310/character_frequency_with_st here's a version using the ST monad. seems to a bit faster than UArray version, but not that much
01:01:33 <Eduard_Munteanu> arcatan: thanks
01:03:14 <winmike> hi
01:03:24 <Eduard_Munteanu> winmike: hi
01:04:12 <winmike> i good a little question: http://codepad.org/O3LdfyCt how can i access the array tupple?
01:04:29 <winmike> hi Eduard_Munteanu 
01:04:33 <Eduard_Munteanu> Hm, I'd suspect folding might not be optimized properly.
01:04:42 <Eduard_Munteanu> Even though I'm using -O2.
01:04:58 <Eduard_Munteanu> I didn't try it though, to see how much difference it makes.
01:06:07 <Eduard_Munteanu> winmike: that isn't exactly an array, what do you intend to do?
01:06:28 <winmike> Eduard_Munteanu, a list i mean
01:06:53 <winmike> Eduard_Munteanu, i want access the first element and make something with it
01:07:06 <winmike> i guess (x,_) but doesnt work
01:07:06 <Eduard_Munteanu> > head [5,6,7]
01:07:07 <lambdabot>   5
01:07:21 <_mpu> > head []
01:07:22 <lambdabot>   *Exception: Prelude.head: empty list
01:07:25 <Eduard_Munteanu> winmike: though you should write two cases
01:07:39 <Eduard_Munteanu> winmike: one for an empty list, and one for when it isn't empty.
01:07:39 <_mpu> @srchead
01:07:40 <lambdabot> Unknown command, try @list
01:07:42 <_mpu> @src head
01:07:43 <lambdabot> head (x:_) = x
01:07:43 <lambdabot> head []    = undefined
01:08:25 <_mpu> once an undefined appears, the whole code stops, isn't it ?
01:08:40 <Eduard_Munteanu> _mpu: once it is needed
01:08:48 <_mpu> ?
01:08:52 <Eduard_Munteanu> as in evaluated.
01:09:05 <_mpu> sure
01:09:34 <_mpu> head (1 : undefined)
01:09:38 <_mpu> > head (1 : undefined)
01:09:38 <lambdabot>   1
01:09:54 <Eduard_Munteanu> > let l = [undefined, 5] in (head l) `seq` tail l
01:09:54 <lambdabot>   *Exception: Prelude.undefined
01:10:18 <Eduard_Munteanu> > let l = [4, 5] in (head l) `seq` tail l
01:10:18 <lambdabot>   [5]
01:11:20 * Eduard_Munteanu wonders if Haskell could've been lazier in its treatment of undefined though.
01:11:45 <_mpu> why ?
01:11:45 <Eduard_Munteanu> Though it probably doesn't make sense for 'seq' :/
01:11:52 <_mpu> sure
01:12:07 <_mpu> you explicitely _ask_ for the evaluation of undefined
01:12:10 <Eduard_Munteanu> Obviously 'seq' forces evaluation, but you don't really really need that result _now_.
01:12:41 <Eduard_Munteanu> > let l = [4, 5] in (head l) `par` tail l
01:12:42 <lambdabot>   [5]
01:12:49 <Eduard_Munteanu> > let l = [undefined, 5] in (head l) `par` tail l
01:12:50 <lambdabot>   [5]
01:13:07 <_mpu> that's strange
01:13:21 <Eduard_Munteanu> Nah, that's a bit more expected.
01:13:38 <Eduard_Munteanu> head l might not be evaluated
01:13:38 <winmike> complicated ;)
01:13:41 <winmike> but thx
01:13:52 <Eduard_Munteanu> 'par' is only a hint
01:14:03 <Eduard_Munteanu> "you might want to do this in parallel"
01:14:37 <Eduard_Munteanu> So I wonder if a lazySeq is possible, with semantics like "I really want this evaluated, but don't you trip on it!".
01:15:01 <_mpu> where is the spec of this par function (if it's a function)
01:15:27 <Eduard_Munteanu> @hoogle par
01:15:28 <lambdabot> Control.Parallel par :: a -> b -> b
01:15:28 <lambdabot> Text.Html paragraph :: Html -> Html
01:15:28 <lambdabot> Text.XHtml.Frameset paragraph :: Html -> Html
01:15:36 <Eduard_Munteanu> The first one.
01:15:42 <_mpu> thx
01:17:09 <_mpu> Eduard_Munteanu: you might be searching this : pseq :: a -> b -> b
01:17:50 <Jafet> Eduard: spoon?
01:17:52 <_mpu> > let l = [undefined, 5] in (head l) `pseq` (tail l)
01:17:52 <lambdabot>   *Exception: Prelude.undefined
01:18:13 <_mpu> no ...
01:18:40 <Eduard_Munteanu> Jafet: what do you mean?
01:18:55 <_mpu> ``pseq is only strict in its first argument ''
01:19:07 <Jafet> @hackage spoon
01:19:08 <lambdabot> http://hackage.haskell.org/package/spoon
01:19:23 <dolio> pseq is strict in both arguments.
01:19:24 <Jafet> A spoon with which to eat your breakfast of champions.
01:19:37 <Eduard_Munteanu> _mpu: hm, no, order doesn't matter
01:19:50 <_mpu> I quoted the spec
01:20:10 <Janni> Hello.
01:20:33 <Eduard_Munteanu> Jafet: ah, nice, looks like it
01:20:39 <dolio> The spec is lying, then.
01:21:24 <Eduard_Munteanu> @src seq
01:21:24 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:21:30 <Eduard_Munteanu> @src spoon
01:21:31 <lambdabot> Source not found. I feel much better now.
01:22:47 <Eduard_Munteanu> Though it still makes me wonder why that triggers an exception considering it isn't used.
01:22:54 <Jafet> I don't think I'd want to see the source for seq.
01:22:55 <Eduard_Munteanu> Used as in 'needed by IO'.
01:23:31 <Janni> I'd like to mechanically compile and evaluate Haskell modules submitted by students in a secure way. My Main.hs imports a pure function from their module. Now is there an easy way to prevent them from using unsafePerformIO to hack the machine, maybe a compile-time flag? Would it that even be sufficient (assuming that I have no security holes in the programming of my Main.hs)?
01:23:51 <Eduard_Munteanu> Janni: maybe lambdabot?
01:24:15 <Eduard_Munteanu> It has been poked at for longer than anything else.
01:24:19 <Janni> OK, thanks. Haven't considered it. *reading about lambdabot*
01:24:35 <Eduard_Munteanu> @vixen Say hi to Janni.
01:24:36 <lambdabot> hiya
01:24:39 <Jafet> The sandbox used by lambdabot is called...
01:24:41 <_mpu> just trust your poor students
01:24:42 <Jafet> > length [1..]
01:24:46 <lambdabot>   mueval-core: Time limit exceeded
01:26:27 <pelotom> > let (x, y) = (unsafePerformIO (do putStrLn ("test1\n" ++ undefined ++ "\ntest2"); return 3), 2) in x `par` y
01:26:27 <lambdabot>   Not in scope: `unsafePerformIO'
01:26:34 <pelotom> :P
01:27:21 <arcatan> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mueval and it has its own package!
01:28:52 <Jafet> for $f in students/*.hs; do sed -e 's/unsafe//g' -i "$f"; done
01:29:19 <Janni> Still reading, but it doesn't seem to me that Mueval would allow students to define their own module infrastructure.
01:29:43 <Janni> Jafet: I don't even know what to say to that... But it makes me wanna say something.
01:30:13 <Janni> Thanks for the help?
01:31:04 <quicksilver> mueval runs in a context in which you can't add new imports
01:31:08 <quicksilver> this makes it quite a bit eaier.
01:31:25 <quicksilver> the idea of a safe haskell flag has been discussed, but does not exist.
01:31:38 <quicksilver> I think you'll have to scan their 'import' lines.
01:32:19 <Jafet> If a student abuses undecidable instances to compute the result at compile time, thus causing a denial of service on your machine, is he or she penalized?
01:32:49 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/1380 is relevant.
01:33:30 <Jafet> Part of the problem is that not everyone can agree on what "safe" means.
01:33:55 <Janni> quicksilver: Thanks. That's fine by me. But what would I have to scan for? Is System.IO.Unsafe the only "hole"?
01:34:01 <Jafet> If you have lots of time to throw around, you could adapt geordi or some other supervisor.
01:34:23 <quicksilver> geordi does something different thought
01:34:29 <quicksilver> it permits unsafePerformIO
01:34:36 <quicksilver> but limits your syscalls.
01:34:52 <quicksilver> I belive Janni wants to enforce a policy restriction that students most only write pure functions
01:34:59 <Jafet> Well, it can't be used to check whether your students' pure code is really pure, if that's what you want
01:35:07 <quicksilver> Janni: No.
01:35:25 <quicksilver> Janni: there are many holes. That ticket contains links to discussions which mention some of them.
01:35:26 <Jafet> There's Unsafe.Coerce, Data.ByteString.Unsafe...
01:35:44 <Janni> quicksilver: Thanks. *reading*
01:36:16 <pelotom> why does that ticket mention banning IO a?
01:36:28 <pelotom> simply creating an IO action isn't a violation
01:37:37 <Jafet> There's also the question of whether unsafePerformIO violates purity, by definition.
01:38:43 <quicksilver> pelotom: different objectives
01:38:55 <quicksilver> pelotom: but my instinct is to say that's a bogus objective, yes ;)
01:39:37 <pelotom> it's the IOs that don't show up in the type which are the problem :)
01:40:23 <Jafet> > print x
01:40:24 <lambdabot>   <IO ()>
01:41:39 <arcatan> anyway, if the main concern is to prevent hacking, i'd look at the OS level controls (what the user account used to run the code can access, how much resources it can use etc.)
01:42:58 <quicksilver> arcatan: I don't think it is. I think the main concern is to ensure the pupils solve the problem in the correct spirit - that is, they produce a pure function of the required type.
01:43:09 <quicksilver> arcatan: and don't "cheat" by invoking unsafePerformIO or other tricks.
01:43:13 <arcatan> yeah
01:43:35 <Jafet> That doesn't sound hard to check manually.
01:44:54 <Eduard_Munteanu> @hoogle log2
01:44:54 <lambdabot> No results found
01:44:56 <Eduard_Munteanu> @hoogle log
01:44:56 <lambdabot> Prelude log :: Floating a => a -> a
01:44:56 <lambdabot> Prelude logBase :: Floating a => a -> a -> a
01:44:56 <lambdabot> Network.CGI logCGI :: MonadIO m => String -> m ()
01:45:20 <pelotom> http://www.haskell.org/haskellwiki/Safely_running_untrusted_Haskell_code
02:02:35 <mreh> how does the the IOException interface work? Magic?
02:02:50 <mreh> IO IOException = IO a
02:03:41 <Jafet> :t undefined -- mreh
02:03:42 <lambdabot> forall a. a
02:07:05 <Saizan> i'm not sure what you're asking
02:08:52 <mreh> :t error
02:08:52 <lambdabot> forall a. [Char] -> a
02:09:07 <mreh> error is magic, innut
02:10:45 <Saizan> the fact that you get the error string printed on stderr is fairly magic
02:10:59 <Saizan> otherwise you could just define "error str = error str"
02:14:56 <mreh> does returning an IOError in IO have the same effect?
02:15:18 <mreh> or only when it's read
02:18:09 <Saizan> "throw"ing one does
02:18:24 <Saizan> ?hoogle throw
02:18:24 <lambdabot> Control.Exception throw :: Exception e => e -> a
02:18:24 <lambdabot> Control.OldException throw :: Exception e => e -> a
02:18:24 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
02:19:02 <Saizan> or passing it to ioError
02:19:12 <Saizan> which is basically throw specialized to IOError
02:28:48 <sioraiocht> is there a pre-defined function for interweaving two lists?
02:30:15 <Jafet> concat . transpose?
02:32:56 <sioraiocht> ah thanks
02:32:59 <sioraiocht> that works =)
02:35:12 <winmike> are there already functions in haskell for # removing duplicates from list # sorting a list?
02:35:37 <sipa> nub
02:35:38 <engla> winmike: nub and sort
02:35:40 <sipa> sort
02:35:41 <PatrickRobotham> winmike: yes, nub and sort.
02:35:51 <PatrickRobotham> or if you like, nubBy 
02:35:52 <engla> winmike: in Data.List
02:36:47 <winmike> engla, PatrickRobotham thx a lot
02:37:01 <pelotom> cabal: internal error: impossible
02:37:07 <pelotom> is it impossible, cabal? is it really?
02:37:14 <dcoutts_> :-)
02:37:25 <dcoutts_> pelotom: what did you do?
02:37:29 <Artelius> winmike: Or hoogle for (Eq a)=>[a]->[a] then (Ord a)=>[a]->[a]
02:37:41 <mreh> oh noes, the impossible just happen
02:37:43 <pelotom> dcoutts_: I'm trying to install glib stuff
02:37:50 <pelotom> on a mac
02:39:44 <pelotom> http://pastebin.com/Sw2iC5D4
02:40:24 <mreh> glib is a dependency of cabal
02:40:25 <dcoutts_> ok, it's coming from the constraint solver in cabal-install
02:40:55 <dcoutts_> ah, cabal install base
02:41:13 <dcoutts_> pelotom: what does cabal --version say?
02:41:20 <pelotom> I just installed glib-2.12.12
02:41:34 <pelotom> cabal-install version 0.8.2 using version 1.8.0.6 of the Cabal library 
02:41:49 <dcoutts_> pelotom: interesting, we usually get a different error for cabal install base
02:42:01 <pelotom> dcoutts_: heh
02:42:03 <dcoutts_> pelotom: the workaround is not to cabal install base, since it's impossible :-)
02:42:31 <dcoutts_> the error message is, shall we say, suboptimal ;-)
02:43:03 <pelotom> well, the good news is, it's impossible
02:43:04 <dcoutts_> pelotom: using what ghc version btw?
02:43:08 <pelotom> so I must be dreaming
02:43:22 <pelotom> 6.6
02:43:37 <dcoutts_> ahh ok, so that explains the different error message in that case
02:43:49 <arcatan> solution: "just" upgrade your ghc
02:44:03 <dcoutts_> since you don't have two versions of base, like users of ghc-6.10 and 12 do
02:44:52 <dcoutts_> pelotom: you cannot upgrade base separately from ghc, the base version is fixed with the ghc version
02:45:06 <pelotom> ah, interesting
02:45:34 <pelotom> dcoutts_: tell that to cabal ;)
02:46:00 <mreh> this not being able to upgrade base is new to me
02:46:03 <dcoutts_> pelotom: well ironically that's what it's trying to do, avoid installing base
02:46:41 <dcoutts_> pelotom: it will never try to upgrade base when you've got a package that asks for a newer base. But it goes wrong when you explicitly ask to install base.
02:47:07 <pelotom> weird, how do I have such an old version of ghc?
02:47:10 <dcoutts_> it internally adds a constraint that the instance of base picked must be an installed version
02:47:20 <dcoutts_> pelotom: debian stable?
02:47:35 <pelotom> I'm using a mac
02:47:44 <mreh> debian is always about 2 years behind the curve
02:47:52 <pelotom> there's ascii art when I start up ghci
02:48:06 <dcoutts_> pelotom: you installed in 4 years ago and never upgraded? :-)
02:48:11 <dcoutts_> in/it
02:48:27 <pelotom> dcoutts_: no, I swear I was running a more recent version until 2 hours ago
02:48:34 <pelotom> something weird is going on
02:48:38 <dcoutts_> sounds like it
02:48:53 <mreh> temporal anomaly?
02:49:20 <pelotom> also there's a terminator in my living room
02:50:11 <dcoutts_> from 2006
02:50:30 <mreh> I didn't know Miles Dyson used haskell
02:50:31 <pelotom> does Xcode install haskell?
02:50:39 <dcoutts_> nope
02:50:41 <kowey> mornfall: I'm trying to adapt hsgtd to use cmdlib instead of its own command line parsing, and...
02:51:02 <kowey> mornfall: as you may remember hsgtd has this interactive mode / internal shell thingy
02:51:27 <pelotom> aha!
02:51:52 <winmike> does anybody know an example of transform a list into a tree with "data Tree = Nil | Node Integer Integer Tree Tree" - i run out of ideas :(
02:51:56 <kowey> using cmdlib almost works there except that if I type in an unknown command, cmdlib dies (FATAL)... which is not so good for interactive mode
02:52:07 <pelotom> for some reason there's a 6.6 in /usr/local/bin, and a 6.12.3 in /usr/bin
02:52:16 <pelotom> I just switched my path around an hour ago
02:56:00 <ManateeLazyCat> Cabal can't generate Paths_package when i set 'build-type' with Custom, how to fix it? Thanks?
02:56:19 <ManateeLazyCat> It's no problem if i set 'build-type' with 'Simple'
02:57:25 <mreh> does cabal use the GetOpt package I wonder?
02:57:30 <mreh> time to check out the source
02:58:04 <ManateeLazyCat> mreh: I use 'getDataDir' in Paths_package 
02:58:27 <ManateeLazyCat> mreh: So i add "other-modules: Paths_manatee_ircclient" in cabal file.
02:58:49 <mreh> ManateeLazyCat: to solve what problem?
02:59:13 <mreh> I wanted to conditionally parse arguments based on the first argument passed to the program, a catch-22 situation
02:59:21 <ManateeLazyCat> mreh: I have add some icon in package/icons, so i need use getDataDir to get package path.
03:00:13 <mreh> ManateeLazyCat: I wanted to do that a little later so I could automatically deduce the package version
03:00:25 <ManateeLazyCat> mreh: Problem is when i set "build-type" with 'Simple', everything works fine. But module 'Paths_manatee_ircclient'  can't generate correctly when i set "build-type" with Custom
03:03:12 <ManateeLazyCat> mreh: What do you mean? Write path with hardcode? How do you know the path of package?
03:03:49 <ManateeLazyCat> I guess there is a trick of keyword 'build-type'.
03:05:13 <dcoutts_> ManateeLazyCat: are you sure? Cabal itself uses build-type Custom but uses the Paths_pkgname module
03:05:21 <astroboy> I have a slight problem with buildExpressionParser in parsec: http://hpaste.org/41313/parsec_expression . 3 + ~5 works, 3+~5 doesn't. note that 3+5 works, the problem is only with ~
03:06:09 * ManateeLazyCat pasted "error" at http://paste2.org/get/1080636
03:06:13 <ManateeLazyCat> dcoutts_: When i use "build-type: Custom" , i got above error. 
03:06:29 * ManateeLazyCat pasted "manatee-ircclient.cabal" at http://paste2.org/get/1080637
03:06:39 <ManateeLazyCat> Above is manatee-ircclient.cabal
03:08:07 <ManateeLazyCat> dcoutts_: Write "other-modules: Paths_manatee_ircclient" is not enough?
03:09:50 <dcoutts_> ManateeLazyCat: it says it failed in the configure step
03:10:08 <ManateeLazyCat> dcoutts_: Yes.
03:10:24 <dcoutts_> ManateeLazyCat: I'm guessing that's due to not being able to compile the Setup.hs
03:10:39 <dcoutts_> ManateeLazyCat: does your Setup.hs import Paths_manatee_ircclient ?
03:11:15 * ManateeLazyCat pasted "Setup.hs" at http://paste2.org/get/1080641
03:11:15 <ManateeLazyCat> dcoutts_: Above is my Setup.hs,
03:11:53 <ManateeLazyCat> dcoutts_: Oh, maybe Setup.hs import IrcBuffer.hs, and IrcBuffer import Smile.hs, Smile.hs import Paths_manatee_ircclient
03:11:56 <dcoutts_> ManateeLazyCat: so do either of those imports indirectly import Paths_manatee_ircclient? My guess is that one of them does
03:12:14 <dcoutts_> ManateeLazyCat: ok, so if you think about it, you'll see that that cannot possibly work
03:12:41 <ManateeLazyCat> dcoutts_: Ok, i build new module around this problem, thanks for help.
03:12:48 <dcoutts_> because the Paths module has to be generated during or after the configure step
03:12:58 <dcoutts_> but Setup.hs has to be compiled before the configure step
03:13:30 * hackagebot amqp 0.2.5 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.5 (HolgerReinhardt)
03:13:38 <dcoutts_> ManateeLazyCat: generally it is not a good idea for the Setup.hs to import things from the package itself, because that can add additional dependencies to the Setup.hs itself
03:14:00 <dcoutts_> which means people cannot even compile your Setup.hs to discover which deps they are missing! :-)
03:14:20 <ManateeLazyCat> dcoutts_: Oh, this deep trick.
03:20:19 <ManateeLazyCat> dcoutts_: Fix it, thanks a lot! :)
03:32:42 <pastorn> what binding priority does `mod` have?
03:33:32 <Jonno_FTW> :i mod
03:33:47 <pastorn> Jonno_FTW: no, `mod`, the infix calling
03:33:56 <sipa> @src mod
03:33:56 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:34:05 <pastorn> @src Int mod
03:34:05 <lambdabot> Source not found. I am sorry.
03:34:18 <Jonno_FTW> infixl 7 mod
03:34:24 <pastorn> cool :)
03:34:35 <Jonno_FTW> I thought lambdabot did that
03:34:38 <sipa> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/src/GHC-Real.html#mod
03:34:40 <pastorn> ah, (+) is infixl 6
03:37:19 <ManateeLazyCat> dcoutts: I use command "darcs add ./Manatee/* -r -q --case-ok || darcs record" to scan files before "darcs record", but "darcs record" just can find new files when i do above command again, any idea?
03:39:44 * hackagebot AC-Boolean 1.1.0 - Handle Boolean values generatically.  http://hackage.haskell.org/package/AC-Boolean-1.1.0 (AndrewCoppin)
03:39:59 <dcoutts_> ManateeLazyCat: see darcs user guide, man page or ask in #darcs
03:58:16 <lars9> kmc: hi
03:58:57 <lars9> kmc: do you understand memotire now?
04:05:40 <boegel> Igloo: I didn't want to make you leave bt ;)
04:07:11 <Igloo> boegel: Don't worry, you didn't - I really would have left when I realised I was still there. Besides it can only be a matter of days before you're all apeaking in Flemish again  :-)
04:08:16 <boegel> Igloo: as long as you guys are there, we'd be happy to continue speaking English ;)
04:17:22 <mornfall> kowey: Ah!
04:17:31 <mornfall> kowey: Ok, that shouldn't be too hard to fix.
04:18:20 <mornfall> kowey: The problem with the exceptions is that they print out rather ugly messages.
04:18:34 <mornfall> kowey: But I guess that depends on the Show instance for the exception maybe?
04:18:40 <mornfall> (In which case, we could live with it I suppose.)
04:19:06 <hpc> of course, it begs the question of why you are using exceptions
04:19:17 <hpc> if you need the nice message
04:20:06 <Saizan> you could add an handler for the sole purpouse of printing nicer messages
04:21:56 <hpc> handlers are yucky
04:22:36 <hpc> i would rather use ErrorT
04:24:15 <Saizan> how is that different?
04:25:01 <hpc> it makes it explicit that the function produces an error
04:25:22 <hpc> so you can't forget to catch it
04:26:59 <Saizan> ah, ok, i was assuming we were already catching it
04:27:09 <Saizan> checked exceptions for IO would be nice
04:27:36 <Saizan> actually, there are a few packages on hackage for them
04:27:55 <hpc> i think the design committee already decided exceptions would be a pimple on the language when they allowed them inside pure blocks
04:28:40 <mornfall> hpc: Well, I actually have a die function. But turns out people sometimes want the program to not die. :)
04:28:47 <hpc> :D
04:29:00 <mornfall> Most curiously.
04:29:12 <Saizan> how is your die implemented?
04:29:31 <mornfall> hPutStrLn stderr msg >> exitWith (ExitFailure 1)
04:29:34 <mornfall> Or something like that anyway.
04:29:58 <Saizan> heh, that's catchable
04:30:05 <mornfall> Sure, but it's ugly.
04:30:14 <zygoloid> various languages have tried checked exceptions, and i think they've pretty much all been experiments which ended in failure
04:30:54 <mornfall> hpc: About exceptions in pure code: I guess once there is a bottom, it doesn't matter much how many different bottoms you have.
04:31:02 <mornfall> hpc: And languages without bottoms aren't all that useful.
04:31:18 <hpc> mornfall: having the exception there makes it look catchable
04:31:27 <hpc> and it is, if you are silly enough to try that hard
04:31:32 <mornfall> spoon!
04:31:37 <Saizan> tsk, languages without bottoms are quite useful
04:31:50 <mornfall> Saizan: But not as useful as those with bottoms.
04:31:54 <mornfall> Well, depending on context anyway.
04:31:56 * zygoloid doesn't consider ErrorT IO to be a checked execption mechanism fwiw
04:31:58 <hpc> technically, languages without bottom aren't turing complete
04:32:04 <mornfall> But I'm sure you wouldn't appreciate Haskell without bottoms.
04:32:04 <hpc> because you have to prove termination
04:32:19 <mornfall> hpc: (That was the implied point, yes. :)
04:32:34 <hpc> (nice overloaded closing paren there :)
04:32:43 <hpc> ))
04:32:53 <mornfall> :P
04:33:54 <zygoloid> there's only one reason to use a language with bottoms: to implement a language without them ;)
04:34:03 <Saizan> turing completeness is overrated, though haskell is probably too weak to do much without it
04:35:27 <hpc> Saizan: indeed; it's neat now many useful FSA's there are
04:35:32 <mornfall> Saizan: Do we have a theorem that there's a turing-incomplete language that can express all of P?
04:36:46 <zygoloid> mornfall: FO(LFP) is a non-turing complete language which can express exactly P
04:36:48 <hpc> mornfall: i don't think so; a turing-incomplete language can't handle arbitrarily long input
04:37:03 <hpc> or what zygoloid said
04:37:10 <Jafet> hpc: that's not what turing-incomplete means
04:37:21 <ketil> hpc: like regular expressions?
04:37:28 <hpc> ketil: shush ;)
04:37:32 <ketil> :-)
04:37:46 <sipa> an algorithm which calculates the sum of values in a list
04:37:58 <sipa> that's P, right?
04:38:06 <Jafet> > repeat 1 -- no bottoms?
04:38:07 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
04:38:07 <b0fh_ua> Hi. Can somebody please help me with resolving the problem: http://pastebin.com/KqQns0cq ?
04:38:31 <zygoloid> one could imagine a language with no recursion or functions, but with loops where the size bound is precisely the input size. that can probably express exactly P, but is turing-incomplete
04:38:48 <Jafet> What's P, again?
04:38:58 <hpc> b0fh_ua: update base, is what it says to do
04:39:07 <mornfall> Jafet: polynomial turing time
04:39:13 <zygoloid> P is the complexity class of decision problems decidable in deterministic polynomial time in the size (number of bits) of the input.
04:39:23 <lars9> which research group in California is working on haskell?
04:39:32 <b0fh_ua> base? why?
04:39:42 <lars9> in universities
04:39:49 <hpc> b0fh_ua: read your paste
04:40:07 <b0fh_ua> Not in scope: data constructor `Reader'
04:40:17 <hpc> up further
04:40:18 <b0fh_ua> why base?
04:40:25 <b0fh_ua> it is warning
04:40:29 <b0fh_ua> it doesn't crash the build
04:40:31 <hpc> "You are using the old package `base' version 3.x."
04:40:44 <hpc> oh i see lol
04:40:46 <hpc> <.<
04:40:47 <hpc> >.>
04:40:54 <Jafet> You can have a language with infinite loops that's still turing-incomplete
04:41:09 <mornfall> Jafet: Obviously.
04:41:20 <hpc> edit CustomKeys.hs and import Control.Monad, perhaps
04:41:21 <mornfall> Jafet: But turing-incomplete is a weaker requirement than always-terminates.
04:41:27 <mornfall> Jafet: Not having the first implies not having the second. :)
04:41:28 <Jafet> So dunno what hpc was saying about bottom.
04:41:39 <hpc> Jafet: i was being an ignoramus :P
04:41:49 * hpc clearly has not woken up yet
04:42:29 <kstt> hello, does anyone use the dbmigrations package by any chance please ?
04:42:35 <b0fh_ua> hpc: it doesn't help
04:42:38 <b0fh_ua> for some reason :(
04:42:54 <Jafet> You could have a language where a valid program must contain a proof that it terminates or not terminates... and it would be turing-incomplete? Doesn't that imply that there are programs for which termination proofs do not exist?
04:43:15 <b0fh_ua> I checked docs for Control.Monad.Reader and realized that there's no Reader constructor available - just type
04:43:17 <hpc> ah, import Control.Monad.Reader
04:43:19 <zygoloid> Jafet: yes, it does.
04:43:25 <hpc> or
04:43:28 <hpc> huh
04:43:29 <b0fh_ua> hpc: there is such import already
04:43:35 <Jafet> Infinity is weird.
04:43:35 <hpc> :(
04:43:54 <zygoloid> Jafet: there are programs which always terminate but cannot be proven to always terminate (cf Godel's incompleteness theroem)
04:44:07 <Jafet> Yeah, it goes back to that.
04:44:33 <b0fh_ua> hpc: http://hackage.haskell.org/packages/archive/mtl/2.0.0.0/doc/html/Control-Monad-Reader.html
04:44:58 <b0fh_ua> there's no Reader constructor available
04:45:27 <mornfall> zygoloid: But there might be other programs solving the same problem that can be proved to terminate.
04:45:28 <hpc> oh, what version of mtl do you have?
04:45:48 <hpc> they changed the standard monads to be transformers over the identity, so it could be using the old version
04:45:49 <b0fh_ua> 2.0
04:45:51 <Jafet> mornfall: but you could never actually prove that
04:46:02 <hpc> yeah, whoever wrote the cabal for that didn't constrain dependencies
04:46:09 <mornfall> Jafet: Too bad. :)
04:46:17 <mornfall> Jafet: But I usually care about the problems not about the programs.
04:46:19 <b0fh_ua> xmonad wants mtl 2.0
04:46:33 <mornfall> (I.e. I normally need to solve a problem, not to write a program that solves the same problem as some other program.)
04:47:02 <zygoloid> mornfall: i strongly suspect there are problems where any program solving that problem cannot be proven to terminate but actually always does.
04:47:21 <mornfall> zygoloid: Now the question is where they live. :)
04:47:33 <mornfall> Gotta go.
04:47:40 <hpc> zygoloid: wouldn't that be a natural consequence of the halting problem?
04:47:48 <mornfall> kowey: I'm flying home tomorrow, so hopefully I can make a cmdlib release then.
04:47:56 <zygoloid> i also strongly suspect that very few problems of practical interest lives in that category :)
04:48:02 <hpc> :D
04:48:27 <hpc> b0fh_ua: yeah, i have no clue; cabal was never my strength
04:48:39 <zygoloid> well, by definition we can never prove that any problem lives in that category :)
04:49:03 <zygoloid> any /particular/ problem. we may be able to prove the category non-empty ;)
04:49:17 <Saizan> the biggest problem i see to switching to a turing-incomplete language like Agda is that its termination checker doesn't handle higher order programming very well
04:49:40 <dcoutts_> hpc, b0fh_ua: in the mean time you can use the flag --constraint='mtl < 2'
04:49:44 <Saizan> there are already projects on smarter ones though
04:50:02 <dcoutts_> hpc, b0fh_ua: try it with cabal install --dry-run to see what it'll do
04:50:13 <b0fh_ua> I fixed that with rebuilding both xmonad and xmonad-contrib with changing dependency of mtl to mtl < 2
04:50:16 <b0fh_ua> weird
04:50:17 <Jafet> Note that Gödel's proof was laboriously constructive -- it actually constructed an unprovable statement
04:50:17 <hpc> dcoutts_: too tired, and it isn't my problem :P
04:53:30 <Roklobsta> hi guys.  i am new to haskell and fp in general.  having pored over the haskell.org site i was wondering if most of you use haskell for fun or implement serious applications by which you earn a living?
04:53:51 <hpc> Roklobsta: many here do both
04:55:41 <Roklobsta> hpc: i ask as i have a project in mind as a vehecle for learning haskell but also to be used in a deployed system (well that is the intention).
04:57:16 * hackagebot amqp 0.2.6 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.6 (HolgerReinhardt)
04:57:27 <Jafet> Hey boss, got the program to work now. I mean compile.
04:58:09 <hpc> :D
04:58:26 <Roklobsta> hpc: what do you use it for?
04:58:37 <hpc> currently, for a website i am building
04:58:48 <Roklobsta> using snap?
04:58:56 <hpc> eventually, i hope it replaces the 15-year-old CMS my boss's company uses
04:58:59 <hpc> no, from scratch
04:59:07 * hpc is crazy that way
04:59:30 <Jafet> Remember to invent your own html parser combinator library too
04:59:54 <Roklobsta> hpc: ;) sounds like job engineering.  you'll be the only one who knows how to maintain it.
05:00:21 <hpc> Roklobsta: nah, i am trying to make it look as clean as possible
05:00:27 <hpc> with...varying degrees of success
05:01:16 <hpc> the idea is, perl is kinda bad to write any significant amount of code in, because it is so easy to break everything and not notice
05:01:37 <hpc> (which has happened, admittedly once by myself, but i was not the only one)
05:02:22 <hpc> haskell is way more strict, and also faster when you factor in the fact that it is compiled
05:03:17 <exDM69> when using a language (implementation) with little or no compile time checking, an extensive set of unit tests is a must
05:03:25 <hpc> yes
05:03:37 <Roklobsta> hpc: interesting.  what i have in mind will need a web interface and sql. 
05:03:48 <Roklobsta> exdm69
05:04:06 <pettter> hpc: I read a presentation on a project in a swedish administration thingy, where they completely failed to make a huge java architecture thingy
05:04:26 <hpc> pettter: unsurprising :P
05:04:36 <exDM69> Roklobsta: ?
05:04:36 <pettter> hpc: So they needed something that /worked/ /now/, so they made a "quick" hack in Perl
05:04:40 <Roklobsta> exdm69: yes.  i did just leave a company that had a horrid vb/c++.net web/sql service that broke all the time and was a total nightmare to maintain.
05:04:48 <Zao> pettter: Take enterprise beans, put in water for a while, add spice.
05:05:17 <hpc> Zao: that's a good way to give yourself dysentery
05:05:25 <pettter> They  ended up with a very nice, robust and easilymaintained project of a few hundred thousand LOC
05:05:25 <stianhj> sooo, what's up with planet.haskell.org?
05:05:37 <exDM69> Roklobsta: it's also easy to write C++ (and many other languages) so that they violate type safety and effectively render all type checking and other compile time checks useless
05:05:59 <hpc> pettter: this is 15 years old (oh, did i say years, i meant man-years)
05:06:17 <Roklobsta> exdm69: not the least because of poor design and type bombs going off while users were plugging away at the web interface.
05:06:20 <hpc> and huge
05:06:26 <hpc> tens of thousands of lines
05:06:42 <pettter> hpc: "oh I'll just add this function here"
05:06:48 <Zao> exDM69: If you're not competent at avoiding UB, you shouldn't be let near a C++ compiler in a professional context.
05:07:05 <sipa> UB?
05:07:12 <pettter> Undefined Behavious
05:07:13 <pettter> *r
05:07:25 <Zao> Undefined behaviour. What you get in just about any beginner C++ program.
05:07:25 <Roklobsta> exdm69: my job was not related to the server but the guy next to me fought it on and off for 2.5 years.
05:07:38 <sipa> you mean there are people who can actually avoid that in C++ :)
05:07:40 <Zao> Also, C++/CLI is not C++.
05:07:54 <Zao> sipa: All you need is a decade of experience with feet-shootings.
05:08:06 <sipa> i guess you learn
05:08:18 <Zao> Oh, sorry about the off-topicness. I thought this was -blah.
05:08:24 <Roklobsta> exdm69: hence my resolve that if i ever made such a system myself i'd try and find a Better Way.
05:09:12 <Roklobsta> besides, wahtver.net is too bloody wordy.
05:09:20 <exDM69> Roklobsta: yes, using better tools would probably result in better products and productivity
05:09:31 <exDM69> unfortunately Haskell is pretty marginal
05:09:32 <Roklobsta> same goes for java and c++ i guess.
05:10:14 <Roklobsta> what do you mean?
05:10:59 <Ke> C++ is far from marginal
05:11:47 <hpc> fleeting thought: if you do all your haskell code inside the IO monad, it looks terrifyingly similar to python
05:12:04 <Jafet> safePerformNonIO
05:12:18 <mreh> is there much literature about producing precompiled executables for windows with haskell
05:12:25 <Jafet> Well, you still get type checking.
05:12:56 <hpc> Jafet: unsafePerformSomersault :D
05:13:06 <Jafet> Precompiled executables? Er, what
05:13:37 <zecrazytux> meaow !
05:14:12 <mreh> everywhere I go to download windows software there are always precompiled binaries
05:15:13 <Roklobsta> hpc: will you be using an SQL database for your CRM?
05:15:21 <Roklobsta> CMS
05:15:29 <hpc> Roklobsta: MySql
05:15:34 <sipa> mreh: how do you compile a precompiled binary, i mean... it's already compiled ;)
05:15:44 <hpc> i feel dirty using an Oracle product, but not as much as actually using Oracle
05:15:58 <hpc> sipa: the precompiled binary is the compiler ;)
05:16:03 <Roklobsta> postgres no good?
05:16:15 <hpc> postgres was impossibly confusing
05:16:22 <sipa> how so?
05:16:31 <mreh> alright then, how is it suggested that i distribute haskell on windows
05:16:41 <mreh> to users
05:16:54 <hpc> i just couldn't figure it out; i couldn't even figure out how to stop and start it
05:17:07 <hpc> init.d wasn't working, for whatever reason
05:17:07 <sipa> /etc/init.d/postgresql start ;)
05:17:31 <zecrazytux> I wrote a function that uses GD, loads the image and do a basic treatment. I would like to parallelise the call to that function with a list of filenames. I tried forkOS but it don't execute the GD calls at all :(, prints are called though. without any call to GD, my tests of forkIO or forkOS look sucessful. what could be the problem ?
05:17:34 <sipa> i've never used mysql though, could be that it's easiert
05:17:36 <Jafet> mreh: fish out the runtime shared libraries and distribute them with your program.
05:17:59 <hpc> mysql is quite nice; querying from the command line is just mysql -p
05:18:22 <sipa> what else would it be?
05:18:35 <hpc> sipa: something else, of course ;)
05:18:42 <mreh> Jafet: cross compiled of course
05:18:54 <mreh> what am I talking about?
05:18:56 <sipa> like?
05:19:01 <Jafet> mreh: you tell us...
05:19:08 <hpc> i think after this i will try and get postgres installed
05:19:20 <Jafet> Sure, if you want to cross-compile ghc for windows...
05:19:27 <hpc> to see if it is it that sucks, or me
05:20:05 <zecrazytux> forkOS is supposed to work well with bindings to C libraries, isn't it ?
05:22:03 <hpc> yes; forkIO makes fake threads, which are allocated to real threads by GHC
05:22:53 <Aisling> hpc: it's you.  I am a longtime MySQL user.  Yesterday, I had occasion to install postgresql.  I compiled it, read a couple of pages in the documentation (which provides plenty of sample commands) and I was up and running within the hour.
05:23:23 <Aisling> hpc: so..  I guess what I'm saying is it's easier than it looks :)
05:28:16 <hpc> heh
05:31:59 <Roklobsta> does haskell internally treat elements of a list as a doubly linked list?
05:32:23 <Zao> Roklobsta: Singly linked list of thunks.
05:32:36 <dcoutts_> zecrazytux: forkOS is only needed for foreign libs that use thread local state, otherwise you should just use forkIO and not waste resources
05:32:54 <Zao> Much like the definition of list.
05:33:13 <Zao> @src []
05:33:13 <lambdabot> data [] a = [] | a : [a]
05:33:14 <zecrazytux> dcoutts_: I first tried forkIO, but as it "oes not work" I tried forkOS too
05:33:36 <zecrazytux> would there be any reason for the thread to "die silently" when calling GD ?
05:33:43 <dcoutts_> zecrazytux: you need to link with -threaded in either case
05:33:56 <Roklobsta> zao: ah ok.
05:34:15 <Zao> Of course, there's all kinds of fusion and other snazzy optimizations.
05:34:51 <kstt> the dbmigrations package seems seriously buggish :(
05:35:06 <dcoutts_> zecrazytux: would need more info than "does not work"
05:35:17 <Roklobsta> zao: is this why some haskell may have elegant and terse code but awlful runtime (like quicksort)?
05:35:38 <Zao> Much like any other language, you've got to pick the right data structures.
05:35:44 <zecrazytux> yes, of course :) i'm writing a separate file with a few lines of code
05:36:08 <Zao> You're not going to get a good quicksort implementation on a glib slist either.
05:36:44 <Zao> If you have sequences of fixed size, vectors/arrays may be quite more suitable, particularly if done in some sufficiently stateful monad.
05:37:38 <Roklobsta> zao: i am a c monkey by trade who only gets to work with piddlingly small amounts of rom and ram so i am trying to get my head around what haskell is doing.
05:38:08 <exDM69> Roklobsta: I found "The implementation of functional programming languages" in my school library
05:38:11 <Roklobsta> under the bonnet.
05:38:12 <medfly> it's using tremendous amounts of ram
05:38:20 <exDM69> Roklobsta: it was pretty good at explaining how the compiler works
05:38:49 <exDM69> Roklobsta: most of it was pretty obvious, other parts weren't. and some were just brilliant (like how to implement pattern matching efficiently)
05:39:04 <dcoutts_> Roklobsta: if you're interested in low ram situations you might like to look at nhc and some of the papers about how it works in such environments
05:39:26 <dcoutts_> Roklobsta: nhc has been used in real embedded applications with very constrained memory
05:39:32 <exDM69> the book dates to the mid 80's so a lot of Haskell stuff wasnät there yet
05:39:58 <dcoutts_> Roklobsta: it uses a bytecode interpreter and some tricks with the heap to keep it small
05:40:02 <Roklobsta> i saw something about embedded stuff in hacakge.
05:40:15 <dcoutts_> Roklobsta: otoh, ghc's target is more about performance than minimal space
05:40:41 <Roklobsta> well, ram is cheap now.  and fast.
05:41:34 <Roklobsta> i have done some vhdl in the past for fpgas and i am seeing some parallels with haskell.
05:42:57 <dcoutts_> Roklobsta: aye, pure FP languages are quite good for expressing hardware logic
05:43:35 <dcoutts_> there are a couple commercial and several academic examples
05:45:25 <Roklobsta> what initially got me interested in FP was the potential for automatic concurrency and parallelism determination at compile time which i think erlang has a handle on.
05:47:25 <dcoutts_> Roklobsta: well, it's not automatic, you have to partition into processes with erlang, or with Haskell use parallel strategies or forkIO concurrency
05:47:32 <dcoutts_> Roklobsta: but yes, it's much much easier
05:49:08 <Roklobsta> i just recall reading about erlang that to speed up your program n times just add n cpus.
05:50:34 <dcoutts_> Roklobsta: that's only true if you've written your program already to have lots of parallelism
05:51:02 <zecrazytux> dcoutts_: could you please have a look to this http://paste.zecrazytux.net/haskell-forkio ?
05:51:13 <Roklobsta> hmmm...  i have just started the road to haskell nirvana,  i have much to learn,...
05:51:29 <zecrazytux> dcoutts_: I'm really new to haskell and I obviously don't get it easily :|
05:51:45 <pettter> dcoutts_: Well, a nice thing about erlang is that you can run a single erlang VM on, basically, a cluster of machines
05:52:15 <payo> haskell is pretty hard to get, but its worth it cuz its the coolest programming language and stuff...
05:52:28 <payo> plus i think its easier than those dirty imperative languages
05:52:32 <zomg_> Yes, I especially like the "and stuff"
05:52:33 <zomg_> =)
05:52:50 <payo> imperative languages are so ugly and dumb...
05:53:12 <sipa> imperative languages are assembly with syntactic sugar? :)
05:53:13 <quicksilver> in fact, haskell is the best imperative language I know.
05:53:16 <zomg_> Why are they so popular if they are ugly and dumb though :P
05:53:25 <payo> i dunno...
05:53:35 <sipa> easy to learn enough to do something in?
05:54:00 <Roklobsta> i blame basic, assembly and c for getting the world into the imperetive groove.
05:54:22 <payo> ive been told never ever to learn C++ and i think its prolly good advice
05:54:36 <payo> people should work on what they enjoy, not be slaves to corporations that insist on using C
05:54:41 <dcoutts_> zecrazytux: your program is terminating before it's had time to do anything. You've misunderstood how threads interact with program termination. When the main thread exits the program exists. If you want to wait for other threads to finish then you do that explicitly.
05:54:48 <quicksilver> in my experience teaching programming, very few people find *any* programming language easy to learn.
05:55:05 <Zao> *cough* -blah
05:55:09 <payo> except Inform, the IF programming language.. i learned it in 2 days, its almost exactly like english
05:55:11 <quicksilver> however once they feel they've been through two years of agoning learning (Java or Basic or C or whatever)
05:55:19 <quicksilver> agonising
05:55:35 <quicksilver> then they resist starting again with something difference.
05:55:46 <zecrazytux> dcoutts_: oh ! sounds logical :)
05:55:59 <zecrazytux> how do I do that ? using things like mvars ?
05:56:02 <dcoutts_> pettter: aye, the fact that you write the program as lots of processes which then can be distributed amongst a lot of machines does make that kind of cluster programming nice
05:57:31 <dcoutts_> zecrazytux: right
05:57:33 <Roklobsta> well, my thinking is that being an embedded c monkey, taking on java or blah.net was passe and requires too much frickin' typing to get anything done. do.something.with.this.function.ToString is a turn off.
05:57:39 <Roklobsta> and i am over for loops.
05:58:49 <dcoutts_> zecrazytux: you can get quite a nice model by writing functions: fork :: IO a -> IO (Future a); join :: Future a -> IO a
06:00:50 <yitz> thinking about using bsimmons' directory-tree package
06:01:19 <yitz> it gives access to a file system directory structure as a tree, with foldable and traversable instances, which is nice
06:01:44 <yitz> but am i right that this interface leaves missing one critical operation:
06:01:53 <yitz> pruning a sub-tree
06:02:13 <yitz> e.g., the ability to avoid descending into a subtree, based on a predicate
06:02:27 <hpc> i will say there is one thing i miss, and that's being able to conditionally "syntactically" modify a variable in IO
06:02:46 <hpc> like when condition (foo <- dothisstuff)
06:03:18 <sipa> foo would only be defined inside those brackets
06:03:21 <yitz> if i'm right that it's missing - what would be the nicest way to add it?
06:03:54 <hpc> i am aware of why it can't work, but it's funny how you miss it when you can't do it anymore
06:04:50 <yitz> hpc: i saw something like that recently, in a haskell-like language for os programming, forget the name
06:04:52 <sipa> well, maybe you can give an example of a piece of code you would like to be able to write, and what its intended meaning should be?
06:05:02 <hpc> yitz: Habit, perhaps?
06:05:09 <yitz> yes habit
06:05:44 <hpc> it's a nice thing to be able to do, when you just want to get shit done, and don't want to deal with ST or whatever
06:05:57 <dcoutts_> yitz: another possibility might be bos's directory package, can't remember the name, but it seemed to have a nice combinator language for expressing dir traversals (in the style of the unix find prog)
06:06:11 <hpc> that said, keep it out of haskell :P
06:06:13 <yitz> dcoutts_: indeed. one problem tho. i need windows
06:06:45 <yitz> dcoutts_: that package requires unix.
06:06:49 <dcoutts_> ah
06:07:03 <dcoutts_> may or may not be able to hack it with unix-compat
06:07:06 <yitz> whereas directory-tree doesn't
06:07:51 <yitz> dcoutts_: requires unix-compat only. does that mean it works on windows?
06:08:02 <dcoutts_> it'd be interesting to see what the other one uses from the unix package that's not provided by the System.Directory module
06:08:17 <yitz> yeah i was surprised
06:08:28 <dcoutts_> my guess is symlinks
06:08:41 <yitz> dcoutts_: unix-compat exists on windows?
06:08:52 <dcoutts_> yitz: unix-compat works on windows, though it emulates a bunch of things by ignoring them, so it may or may not help :-)
06:09:11 <yitz> i don't care about symlinks if that's all it is
06:09:22 <dcoutts_> yitz: it's purpose is to help porting apps that use the unix package
06:09:41 <yitz> so it might work for me after all. guess i should try it.
06:10:13 <yitz> bos's package does look practical. whereas bsimmons
06:10:24 <yitz>  is elegant, it would be fun to get it to work
06:10:33 <yitz> guess i'll try bos'
06:10:54 <yitz> thanks
06:13:50 <quicksilver> hpc: foo <- if condition then Just <$> dothisstuff else Nothing ?
06:14:14 <yitz> ah quicksilver you're around
06:14:17 <quicksilver> hpc: doesn't that have the same spirit but make more sense in the haskell context? I.e. foo is always in scope but will be 'Nothing' if the condition didn't cause it to be set.
06:14:20 * quicksilver denies everything.
06:14:27 <yitz> did you see my question about directory-tree?
06:14:32 <quicksilver> yes, I did.
06:14:36 <quicksilver> I don't know the answer.
06:14:51 <quicksilver> I'd have googled bos' package too ;)
06:14:58 <yitz> yeah
06:15:10 <quicksilver> I recall someone did something evil with unsafeInterleave on the cafe a few months/years back
06:15:15 <quicksilver> but, well, that was evil.
06:15:17 <hpc> quicksilver: i mean more like {int x = 5; if (y > 2) x = 6; return x;}
06:15:27 <yitz> hehe
06:15:41 <hpc> quicksilver: only a more complex case, where the obvious solution gets ugly
06:15:59 <quicksilver> hpc: if that really is what I needed, I'd use STRefs/IORefs
06:16:03 <quicksilver> they're not that bad.
06:16:13 <quicksilver> normally I'd use something more like
06:16:26 <quicksilver> let x_new = if (y>2) then 6 else x
06:16:32 <hpc> hah, completely forgot about IORefs
06:16:32 <quicksilver> (or, actually, with a guard)
06:16:49 <quicksilver> let x_new | y>2 = 6 |otherwise = x
06:17:19 <hpc> wait, whoa, you can do that with guards?
06:17:41 <quicksilver> yes. normally I'd put |otherwise on a new line.
06:17:48 <hpc> that's totally awesome
06:18:21 <quicksilver> x_new is a fairly ugly naming convention but context would, often, afford something nicer.
06:19:51 <hpc> you could also do \c x new | c -> new | otherwise -> x, i think
06:20:09 <hpc> plus a return in there, perhaps
06:22:21 <hpc> though IORefs are probably the better way
06:22:54 <sipa> quicksilver's way corresponds to what you call 'syntacic overwriting'
06:23:05 <sipa> IORefs allow real overwriting :)
06:23:26 <quicksilver> I don't know if that's really true
06:23:32 <quicksilver> the *variable* doesn't get over-written in an IORef
06:23:34 <quicksilver> just the pointer.
06:23:48 <quicksilver> to me that seems quite like syntactic overwriting.
06:23:55 <sipa> the value it points to is overwritten, no?
06:23:58 <quicksilver> no.
06:24:02 <hpc> quicksilver: no, it's real overwriting but of a different thing
06:24:03 <quicksilver> absolutely not.
06:24:08 <quicksilver> only the pointer gets changed.
06:24:10 <hpc> the pointer is still modified, even if the value isn't
06:24:22 <quicksilver> sure, but the pointer isn't the variable.
06:24:35 <quicksilver> if you're trying to draw an analogy with C-like languages.
06:24:44 <quicksilver> the "old" x having value 4 still exists in the heap
06:24:48 <quicksilver> (although it could be GCed)
06:25:03 <quicksilver> all you're doing is changing a special pointer in a special reference cell.
06:25:36 <quicksilver> it's more like: int x = 4; int* xptr = &x; int x_new = 5; xptr = &x_new;
06:25:51 <sipa> ic
06:27:23 <hpc> now that i have everyone geeking out over the least haskell-y part of haskell, i will vanish off to class
06:27:25 <hpc> :D
06:27:33 <cheater99> hi
06:27:49 <cheater99> does haskell have some sort of automated checking if edge conditions in recursive functions are satisfied?
06:28:19 <sipa> like?
06:28:41 <Jafet> I guess cheater is trying to say "non-exhaustive patterns"
06:28:44 * hackagebot fig 1.3.0 - Manipulation of FIG files  http://hackage.haskell.org/package/fig-1.3.0 (AndersLauOlsen)
06:28:48 <cheater99> Jafet: i guess so
06:29:13 <cheater99> say i do take' n (x:xs) = x : take' n-1 xs
06:29:20 <Jafet> Haskell doesn't "check" anything; if your question is about an implementation, name the implementation
06:29:24 <cheater99> but the list is shorter than n items..
06:29:31 <cheater99> Jafet: it's not
06:29:48 <Zao> Throw quickcheck at it, see if you die.
06:29:56 <cheater99> Jafet: but i'm using ghc. if it's an implementation detail, is there a way that does it?
06:30:06 <cheater99> Zao: ok. does quickcheck tell me about non-exhaustive pattern situations?
06:30:10 <Jafet> Er wait, what are you trying to check again?
06:30:22 <Jafet> "Non-exhaustive pattern" means something different entirely.
06:30:39 <sipa> cheater99: can you give an example?
06:30:40 <HugoDaniel> how does hackage work ?
06:30:48 <HugoDaniel> why is there only one package in the network apis category ?
06:30:50 <HugoDaniel> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:network%20apis
06:30:51 <HugoDaniel> this
06:30:53 <HugoDaniel> ?
06:31:01 <HugoDaniel> can i create my own category ?
06:31:02 <cheater99> sipa i have just given one
06:31:13 <sipa> cheater99: sorry :)
06:31:18 <paolino> cheater99: if the tests are significative in the parameter space you can bet 
06:31:30 <cheater99> take' recurses on itself, and then it gets to the point of take' k [], which has no matching pattern
06:31:50 <Jafet> cheater: well, take' n [] is missing from your function, and a compiler like ghc can tell you about it. Is that your question?
06:31:55 <cheater99> paolino: what does "significative" mean?
06:31:58 <Jafet> s/function/equation/
06:31:59 <cheater99> Jafet: yes
06:32:30 <sioraiocht> are breadth first searches always kinda ugly in Haskell?
06:32:32 <sipa> cheater99: the compiler may warn you (when compiling take', if you'd write it yourself) that there exists input which it will fail to match against
06:32:35 <sioraiocht> or in functional programming languages, that is?
06:32:47 <paolino> cheater99: that's the difficult part of quickcheck
06:32:47 <Jafet> Non-exhaustive patterns are just another brick in the -Wall.
06:33:06 <sipa> Jafet: lol!
06:33:36 <paolino> cheater99: generate corner cases combinations
06:34:00 <paolino> difficult for me
06:34:05 <EvanR-work> shouldnt breadth first searches not be reimplemented each time but abstracted out?
06:34:18 <EvanR-work> whether or not they are ugly
06:34:27 <sipa> HugoDaniel: because no one ever added a second? :)
06:34:41 <EvanR-work> you made it sound like a design pattern
06:34:56 <sioraiocht> EvanR-work: even the general "format" of a BFS is ugly, then =p
06:35:12 <cheater99> paolino: are you talking about the situation where my parameter space is n-dimensional but is not a fully open set, therefore having to be made up of open sets of dimensions lower than n?
06:35:37 <tomh> hey is it possible to use qualified type operators?
06:36:27 <paolino> cheater99: I have no notions of open set, sorry
06:36:50 <EvanR-work> yeah, are they not ugly in imperative?
06:36:58 <EvanR-work> if so, use do notation ;)
06:37:01 <cheater99> paolino: you should read up how to find maximum of a continuous function in a subset of R^n
06:37:12 <cheater99> paolino: i think this will help you with the problem you mentioned
06:37:46 <Jafet> @hoogle amb
06:37:47 <lambdabot> Language.Haskell.Syntax HsLambda :: SrcLoc -> [HsPat] -> HsExp -> HsExp
06:37:50 <Mitar> when all does RTS print exception in form "programname: exception"?
06:37:54 <Jafet> Sad.
06:38:25 <paolino> cheater99: it's just that rare conditions remain rare if you don't put the right lens on the parameter space 
06:38:56 <cheater99> let's say your set is a cube. it's not an open set, but mathematical tools will only show you the maximum on an open set. so you first check for the maximum of the inside of the cube (which is an open set). Then you find the maxima on the sides of the cube, but without the edges or vertices. then you check the edges, but without vertices. finally you compute the function on vertices. then you take the largest of those 15 numbers.
06:41:00 <Lemmih> Mitar: When you don't catch them?
06:41:44 <Mitar> the point is that i get two exceptions printed ;-)
06:41:50 <Mitar> and this is a strange thing ;-)
06:42:12 <Mitar> are exception to forkIO threads also printed?
06:42:22 <Lemmih> Mitar: Yeah.
06:42:26 <Mitar> ooo
06:44:12 <cheater99> paolino: gotcha
06:44:20 <cheater99> paolino: then it's very similar to what i have described
06:44:42 <Azrael-> @src rjustify
06:44:42 <lambdabot> Source not found. There are some things that I just don't know.
06:45:29 <paolino> I don't think it's right to use quickcheck on take', anyway
06:46:33 <Jafet> @check \xs l -> take l xs ++ drop l xs == xs
06:46:33 <paolino> take' looks conceptually wrong, it's not the implementation
06:46:33 <lambdabot>   "OK, passed 500 tests."
06:47:29 <Jafet> @check \xs l -> take l xs == xs
06:47:30 <lambdabot>   "Falsifiable, after 1 tests:\n[()]\n-1\n"
06:48:10 <cheater99> that's pretty cool - hadn't noticed it yet: http://tryhaskell.org/
06:52:36 <Azrael-> @src transpose
06:52:36 <lambdabot> transpose []             = []
06:52:36 <lambdabot> transpose ([]   : xss)   = transpose xss
06:52:36 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
06:52:53 <paolino> @check \xs l -> let take' n (x:xs) = x : take' n-1 xs in take' l xs == xs
06:52:53 <lambdabot>   Couldn't match expected type `[t]'
06:53:06 <paolino> @check \xs l -> let take' n (x:xs) = x : take' (n-1) xs in take' l xs == xs
06:53:06 <lambdabot>   "*Exception: <interactive>:1:165-199: Non-exhaustive patterns in function t...
06:53:57 <Azrael-> @check (x+1)*(x-1) = x^2 - 1
06:53:57 <lambdabot>   Parse error at "=" (column 13)
06:54:01 <Azrael-> @check (x+1)*(x-1) == x^2 - 1
06:54:02 <lambdabot>   "Falsifiable, after 0 tests:\n"
06:54:27 <Jafet> @check \xs l -> let take' n (x:xs) = x : take' (n-1) xs; take' _ [] = [] in take' l xs == take l xs
06:54:28 <lambdabot>   "Falsifiable, after 3 tests:\n[(),()]\n-3\n"
06:54:51 <Jafet> @check \x -> (x+1)*(x-1) == x^2 - 1
06:54:52 <lambdabot>   "OK, passed 500 tests."
06:55:34 <Jafet> @check \xs l -> let take' n (x:xs) = if n<0 then [] else x:take' (n-1) xs; take' _ [] = []; in take' l xs == take l xs
06:55:35 <lambdabot>   "Falsifiable, after 4 tests:\n[(),()]\n0\n"
06:55:50 <Jafet> Dammit, we need a Natural type
06:56:19 <Jafet> @check \xs l -> let take' n (x:xs) = if n<=0 then [] else x:take' (n-1) xs; take' _ [] = []; in take' l xs == take l xs
06:56:19 <lambdabot>   "OK, passed 500 tests."
06:56:47 <paolino> 'take' reverse ingeneering
06:57:03 <bastl> hello
06:59:02 <bastl> are there any approaches to visual syntax for functional programs? something similar to UML ? I want to present an implementation without showing too much source code ...
07:00:36 <cheater99> graphs
07:01:00 <bastl> with what meaning for arcs and nodes ?
07:01:19 <cheater99> a node is a type, an arc is a function.
07:01:35 <bastl> typeclass, instanciation? polymorhpy ?
07:01:44 <cheater99> f: A->B, g: B->C                   A-(f)->B-(g)->C
07:01:52 <cheater99> hey, don't expect everything
07:02:10 <cheater99> you can figure out polymorphy
07:02:29 <Cheery> do you know a wiki software written in haskell?
07:02:56 <Cheery> there's mod_haskell for apache right?
07:03:14 <quicksilver> fastcgi is better than mod_foo for most web application purposes
07:03:40 <Cheery> quicksilver: you think so? hmm. maybe
07:03:50 <Cheery> though I've used to mod_foo :)
07:03:58 <quicksilver> gitit is the most famous haskell wiki
07:04:25 <quicksilver> there are a couple more at http://hackage.haskell.org/packages/archive/pkg-list.html if you use your browser's text search for 'wiki'
07:05:02 <ray> rolling your own server is faster still if you do it right
07:05:17 * hackagebot redis-hs 0.0.10 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.0.10 (WillLangstroth)
07:05:27 <quicksilver> ray: I wasn't talking about speed, really
07:05:31 <quicksilver> just pragmatic deployment issues.
07:05:53 <ray> apache gets you cheapass web hosting at least then
07:05:57 <quicksilver> there are loads of advantages to having a conventional web server frontend layer
07:06:11 <quicksilver> rewriting / redirecting / virtualhosting etc
07:11:50 <bastl> cheater99: what about function types and currying? e.g. how would you depict map :: (a -> b) -> [a] -> [b]  ?
07:12:51 <cheater99> read up on category theory and graphs
07:13:19 * hackagebot cash 0.1.0.0 - the Computer Algebra SHell  http://hackage.haskell.org/package/cash-0.1.0.0 (ChrisBrown)
07:13:36 <cheater99> basically you do something like this: you draw A on your piece of paper, you draw B on your piece of paper, an arrow from A to B, and then you draw C above that arrow, and a second arrow, which starts in the middle of the previous arrow, and points at C.
07:14:10 <cheater99> that would be (A->B) -> C
07:15:08 <cheater99> if you want (A->B) -> C -> D then you could do something like: draw A->B, draw C somewhere next to it, surround both with a circle, have an arrow that starts at the circumference of that circle and points at D, with D being well outside of that circle
07:15:17 <cheater99> i mean it just depends on what you want to document there
07:15:29 <cheater99> there's little in the way of universal communication
07:15:45 <cheater99> you need to think about what you want to communicate and then use it
07:15:59 <cheater99> alternatively you can have an arrow with two dull ends and one pointy end
07:16:43 <cheater99> so A->B->C        has an arrow from A to C,  and since B is a "lesser parameter", there's a sort of line going from B to the first arrow, and that works too.
07:17:03 <cheater99> the line ends up joining the arrow at an angle of 0.
07:19:47 <bastl> well, the idea of UML was not specification but communication. And it was quite sucessful: To communicate an OO concept I can draw a class diagram or a sequence and people understand. Im looking for something similar for FP. (Such that my supervisor understands without knowing Haskell). How do you discuss a larger functional program on the whiteboard?
07:20:05 <bastl> Finding an adequate visual syntax is not easy ...
07:20:24 <bastl> I'd really like a good research paper on that :-)
07:20:40 <bastl> monadic actions are interesting too in that respect :-)
07:20:54 <Jafet> Draw burritos and spacesuits
07:21:11 <cheater99> category theory
07:21:35 <bastl> cheater99: CT is a nice formal underpinning, not a visual syntax
07:22:04 <bastl> an arrow from an arrow to an object makes no sense
07:22:17 <quicksilver> CT diagrams might be useful if your program uses lots and lots of different types.
07:22:28 <quicksilver> but if you program uses, e.g. mostly just Integers
07:22:41 <quicksilver> then a type-based depiction is not going to have much information.
07:22:54 <quicksilver> bastl: it is possible to make sense of diagrams where you have arrows from arrows.
07:23:23 <bastl> yes, but then arrows are objects. an arrow from an arrow to an object is not possible.
07:23:36 <bastl> it's getting confusing :-)
07:23:39 <yitz> dcoutts_: no, filemanip needs System.Posix.Temp, at least. hmph, no excuse for that. too bad.
07:23:48 <quicksilver> formally, it is possible, bastl 
07:23:59 <bastl> from an arrow to id, but no to the object.
07:24:08 <quicksilver> in a CCC you have a relationship between arrows and objects.
07:24:10 <bastl> not*
07:24:11 <dcoutts_> yitz: oh that's easy, Cabal has secure temp file code
07:24:15 <quicksilver> and Hask (as well as Set) are CCCs indeed.
07:24:41 <quicksilver> however, is it a good way of explaining your code? perhaps not.
07:24:58 <yitz> dcoutts_: meaning bos didn't need to use Posix for that.
07:25:19 <roconnor> @seen edwardk
07:25:19 <lambdabot> Unknown command, try @list
07:25:19 <preflex>  edwardk was last seen on #haskell 16 hours, 26 minutes and 49 seconds ago, saying: actually i stand corrected. it was a reference to "legal stamps" =)
07:25:23 <yitz> dcoutts_: sounds like he just didn't have windows in mind at all.
07:25:31 <dcoutts_> yitz: well, Cabal has code for it because the standard System.Directory versions are not enough
07:25:46 <dcoutts_> yitz: so bos will have faced the same problem
07:25:59 <bastl> quicksilver: i think this would be interesting research. I just thought, someone worked on such issues already ...
07:26:37 <yitz> dcoutts_: there are winapi calls that should do it, I think
07:27:10 <dcoutts_> yitz: see Cabal's Distribution/Compat/TempFile
07:28:25 <yitz> dcoutts_: that's just where it got stuck the first time through. having seen that, now i'm suspicious that it might take some significant work to port this.
07:29:41 <dcoutts_> yitz: in System/FilePath/Manip.hs looks like it's all just opening temp files and setting secure file permissions. The Cabal compat versions do that too.
07:29:59 <yitz> mm ok
07:30:23 <ManateeLazyCat> "darcs record -l" is i'm looking for.
07:30:24 * hackagebot redis-hs 0.0.11 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.0.11 (WillLangstroth)
07:30:43 <dcoutts_> yitz: mm, but the other module makes heavier use of the posix FileStatus type
07:30:57 * yitz was afraid of that
07:31:27 <dcoutts_> yitz: yeah, looks like rather more work for that one, ho hum.
07:32:29 <paolino> bastl, I will read it with interest :)
07:32:42 <dcoutts_> yitz: it's been on my TODO for some time to propose some better, portable, directory/file functions, especially in relation to file permissions, temp files etc
07:33:02 <yitz> dcoutts_: doesn't sound trivial
07:33:24 <dcoutts_> yitz: depends how much one bites off :-)
07:34:05 <yitz> dcoutts_: e.g. python, which tries to provide that sort of thing where possible, just exposes a posix kind of api and just omits things that don't work on windows.
07:34:11 <Igloo> I think modern base is good enough for what Cabal needs now, BICBW
07:34:40 <yitz> dcoutts_: in real life people use an acl approach via active directory on windows, often enough
07:34:41 <Igloo> And Cabal also supports older bases, of course
07:35:12 <dcoutts_> yitz: aye, that makes permissions quite tricky
07:35:27 <dcoutts_> yitz: but there's some portable notions, and system-specific extensions
07:35:51 <dcoutts_> e.g. make this readable to "everyone" and make this readable just for the "current user"
07:36:05 <dcoutts_> which would be sufficient for many purposes
07:36:10 <yitz> dcoutts_: you could do it the other way round - take a window-like approach, and use samba for a compatibility layer :)
07:36:21 <yitz> s/window/windows/
07:36:40 <dcoutts_> yitz: there are at least 3 different incompatible ACL systems out there :-(
07:36:41 <cheater99> or not.
07:36:56 <yitz> cheater99: right.
07:37:44 <dcoutts_> windows ntfs, posix acl, nfs 4 acl
07:41:14 <yitz> directory-tree installs smoothly on windows
07:41:46 <yitz> think i'll try just defining "pruneBy", and using the lazy IO interface.
07:42:40 <yitz> or perhaps just 'filter", might as well let it work on files as well.
07:45:22 <yitz> preflex: seen Cale
07:45:22 <preflex>  Cale was last seen on #haskell 9 hours, 34 minutes and 19 seconds ago, saying: It'll be machine independent that way
07:46:09 <dcoutts_> Igloo: it's almost enough for what cabal needs
07:46:27 <dcoutts_> Igloo: I think the openTempFileWithDefaultPermissions (ug, name) covers several cases
07:47:06 <dcoutts_> Igloo: we still cannot implement installExecutableFile because of lack of control over file permissions
07:47:26 <Igloo> Ah, OK
07:47:27 <dcoutts_> we can set user exec permissions but not other, so no good for global installs
07:48:07 <dcoutts_> what we need is openFile that takes a record of args including initial permissions
07:48:23 <dcoutts_> and perhaps similarly for openTempFile that does the name magic
07:48:47 <dcoutts_> then we don't need the plethora of open{Binary}TempFile{WithBlahBlah} functions
07:54:43 <Mitar> is there a way to find more information about where does exception come from, which is printed on the terminal?
07:54:53 <Mitar> it does not stop the program, it is just printed
08:18:44 <tomh> hey is there a way to see the evaluation of type families or some other form of debugging assistence?
08:40:30 <quicksilver> so, today, I learn that HSP and happstack both depend on overlapping instances
08:40:32 <quicksilver> how depressing
08:40:38 <quicksilver> I think we should burn hackage and start again.
08:42:12 <lantti> Was overlapping instances something bad?
08:42:56 <quicksilver> very bad.
08:42:59 <quicksilver> @quote overlapping
08:42:59 <lambdabot> xerox says: * xerox gets sucked in a vortex of -fdisallow-overlapping-explanations
08:43:02 <quicksilver> @quote overlapping
08:43:02 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
08:43:02 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
08:43:26 <Saizan> quicksilver: seen that instance chains paper?
08:44:06 <quicksilver> Saizan: No. Ref?
08:44:23 <wjt> sigh. darcs doesn't let me reword commit messages.
08:44:34 <Saizan> quicksilver: http://web.cecs.pdx.edu/~jgmorris/pubs/morris-icfp2010-instances.pdf
08:45:03 <quicksilver> Saizan: ty. downloaded for later perusal.
08:45:36 <quicksilver> abstract looks interesting.
08:45:44 <Saizan> it's both safer and nicer to use than Overlapping ones, though it doesn't cover the "default instance" use case
08:46:00 <Saizan> which is why happstack uses them, iirc
08:46:10 <quicksilver> in my experience a large class of people who use overlapping instances really want context-directed instance search.
08:46:16 <JohnnyL> given:  scanl1 (\acc x -> if x > acc then x else acc) [3,4,5,3,7,9,2,1] {* 1) how does the scanl1 function know how to accumlate 2) how does the accumlate persist from each lambda application 3) is accum a var inside scanl1?
08:46:27 <quicksilver> not that that makes the openworld problem any less severe.
08:46:31 <JohnnyL> ignore the {*
08:47:08 <quicksilver> Saizan: SPJ gives a pretty concise description of what he sees as the essential problem, here : http://hackage.haskell.org/trac/ghc/ticket/4485
08:47:18 <quicksilver> Saizan: that one doesn't look like a default instance thing, exactly.
08:47:22 <quicksilver> (two conflicting defaults, maybe?)
08:47:34 <Saizan> quicksilver: and instance chains have that! assuming it can prove some constraints can't be satisfied using the "fails" instance decls
08:48:00 <cozachk> is there a tutorial somewhere for using lambdabot in offline mode and/or with ghci ? 
08:49:32 <buntfalke> what's the total size of all of code.haskell.org?
08:50:02 <Mitar> 16 chars?
08:50:27 <sioraiocht> smartass =p
08:50:44 <JohnnyL> does a smart ass have AI?
08:51:10 <Mitar> left side of mine does
08:53:55 <Saizan> quicksilver: ah, i wasn't aware of that XMLGen, i was thinking of something else
09:04:21 <pistacchio> hi, could someone please check out the error in here? i can't understand what's it cause by http://hpaste.org/41319/nonexhaustive_patterns_in_fun
09:05:47 <quicksilver> pistacchio: your 'addTile' function defined in the where clase in roomsOnBoard only accepts lists of length exactly one.
09:06:34 <quicksilver> (inside the tuple)
09:07:07 <Zao> The whole list match there seems a bit odd, as you do not seem to use those xx, yy, tt vars.
09:07:35 <pistacchio> quicksilver: hmmm, i'm not sure i got it, what would be the correct version would be (i started learning haskell two days ago)
09:07:56 <pistacchio> Zao: i know, that is a to-the-bone versione just to reproduce the error
09:08:27 <quicksilver> pistacchio: well, I don't know what the correct version because I don't know what you're trying to do!
09:08:35 <quicksilver> pistacchio: since you don't use that list, you might as well ignore it
09:08:48 <quicksilver> addTile _acc ((_x, _y), _) = _acc
09:08:58 <quicksilver> but in general:
09:09:03 <quicksilver> [] -- mathes empty lists (only)
09:09:14 <quicksilver> [x] -- matches lists of length 1, the unique item in the list is called x
09:09:29 <pistacchio> quicksilver: i need "r" to be ((x, y), [Tile])
09:09:35 <quicksilver> (x:xs) -- matches lists of length >= 1, the first item is called 'x' and 'xs' is the rest.
09:10:28 <quicksilver> pistacchio: yes but don't need to do anything in particular to make that happen
09:10:34 <quicksilver> that will be inferred
09:10:42 <quicksilver> by the way you use it in line 22.
09:11:09 <quicksilver> it would be clearer what the type were if you annotated all the top-level functions
09:11:12 <quicksilver> but that's not required
09:13:32 <pistacchio> so
09:13:34 <pistacchio> hmmm
09:14:08 <pistacchio> how do i get a list of ALL the tiles to loop over it in the where?
09:15:15 <quicksilver> I think you don't understand foldl.
09:15:59 <quicksilver> @type foldl
09:15:59 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
09:16:35 <quicksilver> or maybe I misunderstand you
09:16:41 <quicksilver> there are multiple tiles in each room, right?
09:16:44 <quicksilver> 9, in fact.
09:17:04 <pistacchio> right
09:17:06 <quicksilver> pistacchio: normally you use foldr or map or a higher-level function to iterate 
09:17:26 <pistacchio> i'll try to explain
09:17:31 <quicksilver> so, "where addTile _acc ((_x, _y), ts) = .... some foldr over ts, perhaps .... "
09:17:39 <quicksilver> "ts" is then bound to the list of all tiles
09:17:42 <quicksilver> and you do something with it in the RHS
09:18:22 <Cheery> > 1 + (let double x = x+x in double 5 + double 2)
09:18:23 <lambdabot>   15
09:18:41 <pistacchio> oh, ok
09:18:55 <JohnnyL> interesting, it's like GHCi has a cache of those functions that have already run.
09:18:56 <pistacchio> so i can THEN cycle though all the Tile(s) in ts
09:19:00 <Cheery> hm. does lambdabot work with privmsg?
09:19:01 <quicksilver> yes.
09:19:08 <pistacchio> thanks, that helped
09:19:18 <quicksilver> Cheery: yes.
09:19:39 <quicksilver> Cheery: for :t you instead need @type. All the other commands work as normal though. > works fine.
09:23:44 <engla> is there a haskell function to round floats, like roundf 2 7.3748 -> 7.4
09:25:44 <quicksilver> > let roundf n = \x -> fromIntegral (round (x * 10^n)) / 10^n in roundf 2 7.3748
09:25:45 <lambdabot>   7.37
09:25:54 <quicksilver> engla: not quite what you asked for but you can work it out :)
09:26:55 <ClaudiusMaximus> > 2**-1
09:26:56 <lambdabot>   Not in scope: `**-'
09:27:30 <engla> quicksilver: it doesn't exist! that's interesting
09:27:33 <engla> thanks anyway
09:27:35 <ClaudiusMaximus> > let a **- b = a ** (- b) in 2**-1
09:27:36 <lambdabot>   0.5
09:28:56 <ClaudiusMaximus> decimal rounding is a bit odd for floats which are (almost always) binary
09:29:35 <quicksilver> engla: well, you can round-on-output
09:29:43 <quicksilver> engla: and if you really wanted you can read that back in
09:29:46 <quicksilver> but that seems ugly
09:30:29 <quicksilver> > showFFloat (Just 2) 7.3748 ""
09:30:30 <lambdabot>   "7.37"
09:30:39 <quicksilver> > read (showFFloat (Just 2) 7.3748 "") :: Double
09:30:40 <lambdabot>   7.37
09:30:44 <ClaudiusMaximus> i have an ugly function for something similar: converting scientific notation to human-readable notation using string splitting/joining
09:30:46 <engla> hm I realized that was not even what I wanted. I wanted   fmap (\x -> if x < eps then 0 else x)ffffffffff
09:31:00 <engla> just cut away below eps
09:31:08 <EvanR-work> is Reader really best rendered as a Monad
09:31:33 <EvanR-work> no matter what order you ask in, its the same answer
09:31:51 <EvanR-work> ignoring local
09:32:49 <ClaudiusMaximus> EvanR-work: in my understanding, the utility is that it transfers the plumbing of values through a deep chain of functions so you don't have to do that yourself
09:33:16 <EvanR-work> yes but monad allows more than just that
09:33:33 <EvanR-work> so you have to specifically decide where to perform the ask operation
09:33:36 <EvanR-work> imperatively
09:33:48 <ClaudiusMaximus> hm, good point
09:34:00 <EvanR-work> its a constant, so could in principle work like a let block
09:34:10 <EvanR-work> but not
09:34:22 <EvanR-work> maybe im thinking of applicative
09:34:28 <aristid> @pl \x -> if x < eps then 0 else x
09:34:28 <lambdabot> flip if' 0 =<< (< eps)
09:39:47 <McManiaC> is anyone using curl libraries with success on windows?
09:40:23 <McManiaC> I've build the .dll but cabal/ghc won't accept it :(
09:41:11 <dcoutts_> McManiaC: if you want anyone to help you have to give more details
09:41:29 <dixie> hmm. would it make sense to make org-mode files parser/writer for pandoc? probably no
09:41:31 <dcoutts_> otherwise it's just psychic debugging :-)
09:41:35 <McManiaC> curl-1.3.5 failed during the configure step. The exception was:
09:41:35 <McManiaC> ExitFailure 1
09:41:36 <McManiaC> thats all
09:41:50 <pumpkin> has anyone tried zeno here?
09:42:07 <dcoutts_> McManiaC: no previous details further up at the actual configure stage?
09:42:15 <pumpkin> McManiaC: http://www.haskell.org/cabal/FAQ.html#exitfailure-1
09:42:17 <writer> dixie: org-mode requires some stuff specific to Emacs, IIRC.
09:42:19 <McManiaC> uuuh
09:42:29 <McManiaC> it doesn't build on my linux machine either
09:42:37 <dcoutts_> McManiaC: a paste of the full command and log would be ideal
09:43:04 <McManiaC> configure: error: curl libraries not found, so curl package cannot be built
09:44:32 <McManiaC> http://npaste.de/pU/
09:44:36 <quicksilver> dixie: an org-mode writer for pandoc probably makes sense.
09:44:55 <quicksilver> dixie: reader, perhaps less so; might be better to write an org-mode exporter to one of the good pandoc choices.
09:47:29 <dcoutts_> McManiaC: so that lib uses a configure script and it'll need an env var set to tell it where to look for the curl libs
09:47:35 <dcoutts_> since there's no standard location on windows
09:47:53 <McManiaC> I thought it's using PATH on windows too
09:48:22 <dcoutts_> McManiaC: the PATH is for programs, I don't think it's used by gcc to find libs or header files
09:48:32 <McManiaC> it is
09:48:49 <McManiaC> it works that way with gtk, wxHaskell etc
09:49:59 <dcoutts_> ok, fair enough
09:50:04 <Mitar> is there a way to hide "Defined but not used" warning?
09:50:18 <pumpkin> dcoutts_: GHC 7 is working with the cmm! not sure why 6.12 didn't like it
09:50:22 <dcoutts_> McManiaC: wait, are you sure you're not thinking of the libs, this configure script will also be looking for headers
09:50:33 <dcoutts_> pumpkin: oh good
09:51:20 <ClaudiusMaximus> Mitar: you can name variables starting with an underscore which suppresses that warning while still offering more documentation than _ alone would
09:51:44 <McManiaC> dcoutts_: how can I pass those to the configure script? just --extra-include-dirs=... wont do it
09:52:05 <dcoutts_> McManiaC: right, the configure script sadly ignores those flags :-(
09:52:13 <Mitar> hthe problem is that i have defined a data type: data EmptyOptions = EmptyOptions {}
09:52:31 <dcoutts_> iirc, it'd actually work if it was not using a configure script at all
09:53:08 <Mitar> and if i export EmptyOptions it complains that constructor is defined but not used, but if I use EmptyOptions(..) it complains that i suggest there are constructors, but in fact there are none
09:55:06 <McManiaC> dcoutts_: how could I get that to work? :)
09:56:23 <ClaudiusMaximus> Mitar: that's odd/annoying - would omitting the {} change things?
09:57:36 <ClaudiusMaximus> Mitar: i recall i had a similar problem where i had   data Toggle = On | Off  and I only pattern-matched 'On', while using a derived Read instance
09:57:43 <dcoutts_> McManiaC: try using the standard CPPFLAGS env var
09:58:05 <dcoutts_> McManiaC: you might also like to remind dons that the package will work better if he removes the configure script
09:58:05 <EvanR-work> Mitar: whats the point of a constructor with field list {}
09:58:10 <Mitar> no
09:58:30 <Mitar> it is because it is an example
09:58:42 <EvanR-work> just export everything
09:58:43 <Mitar> in general options are a record
09:58:48 <Mitar> i would like to
09:58:52 <Mitar> but how
09:58:56 <EvanR-work> delete the export list
09:58:59 <Mitar> EmptyOptions(..) complains and EmptyOptions complains
09:59:06 <Mitar> no, i want some other functions hidden
09:59:19 <EvanR-work> so i guess you would not like to export everything
09:59:24 <Mitar> no ;-)
09:59:33 <EvanR-work> good way to get people to hate your guts!
09:59:42 <Mitar> why?
09:59:55 <ClaudiusMaximus> Mitar: if you 'man ghc' and search for -fwarn you might find something useful
10:00:18 <EvanR-work> warning unused constructor? ignore it
10:00:33 <EvanR-work> or use it
10:00:35 <McManiaC> dcoutts_: wow, it did build after switching to buildtype "simple"
10:01:05 <dcoutts_> McManiaC: aye, the configure script is just getting in the way. Tell dons when you see him next
10:01:23 <dcoutts_> McManiaC: or better yet, send him a patch
10:01:36 <dixie> quicksilver: I use sub-set of the org-mode syntax (e.g. outlines only) where the parser would make sense. But I agree that such a restrictive parser (reader) has no place in solid piece of software.
10:02:03 <McManiaC> getting a linking error when trying to use it tho :) guess GHCi needs to know the path aswell
10:04:40 <McManiaC> dcoutts_: Loading package curl-1.3.5 ... linking ... <interactive>: C:\Users\Nils\AppData\Roaming\cabal\curl-1.3.5\ghc-6.12.3\HScurl-1.3.5.o: unknown symbol `__imp__curl_easy_getinfo'
10:04:44 <McManiaC> : unable to load package `curl-1.3.5'
10:04:57 <McManiaC> what flag do I need to pass to ghci?
10:06:20 <dcoutts_> McManiaC: try static linking
10:06:47 <McManiaC> dcoutts_: how? where?
10:07:05 <dcoutts_> McManiaC: try compiling with ghc, rather than using ghci
10:07:21 * dcoutts_ suspects dll import lib linking issues
10:08:04 <dcoutts_> McManiaC: and check the curl dll on the path is the one you built against
10:09:00 <McManiaC> .\Network\Curl\Easy.o:fake:(.text+0x69d): undefined reference to `curl_version_num'
10:09:06 <McManiaC> ok, I guess thats because of the missing configure script
10:09:08 <McManiaC> ^^
10:11:05 <dcoutts_> McManiaC: I doubt it
10:15:38 <McManiaC> :(
10:15:39 <JohnnyL> why can one do this: oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]  ......but not this: oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) ( [1..]  )   ?
10:15:54 <JohnnyL> > let oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2) $ [1..] 
10:15:55 <lambdabot>   not an expression: `let oddSquareSum = sum . takeWhile (<10000) . filter od...
10:16:06 <kmc> :t  sum . takeWhile (<10000) . filter odd . map (^2) $ [1..]
10:16:07 <lambdabot> forall a. (Integral a) => a
10:16:14 <kmc> :t sum . takeWhile (<10000) . filter odd . map (^2) ( [1..]  )
10:16:15 <lambdabot> forall a. (Integral a, Num [a], Enum [a]) => [a]
10:16:15 <EvanR-work> JohnnyL: because the last term in the . sequence is not a function
10:16:40 <EvanR-work> its map (^2) [1..]
10:16:51 <kmc> f . g x   is not the same as   f . g $ x
10:16:54 <EvanR-work> precedence rules, whitespace > .
10:16:57 <JohnnyL> EvanCarroll: ah ok. But why does $ work? There is quite a difference. I had always thought that () can be substituted by $.
10:17:05 <kmc> :t ( sum . takeWhile (<10000) . filter odd . map (^2) ) [1..]
10:17:06 <EvanR-work> it cant
10:17:06 <lambdabot> forall a. (Integral a) => a
10:17:10 <JohnnyL> kmc: ah ok
10:17:14 <EvanR-work> f . g $ x <=> (f . g) x
10:17:28 <EvanR-work> what? i meant to say it can
10:17:46 <kmc> both . and $ are ordinary user-defined operators
10:17:52 <kmc> and you can look up their precedence
10:17:57 <kmc> infixr 9 .
10:18:00 <kmc> infixr 0 $
10:18:09 <JohnnyL> oh sweet
10:18:17 <kmc> using :i in ghci
10:18:37 <EvanR-work> can you define precedence of `f`
10:20:44 <JohnnyL> EvanR-work?
10:20:49 <zygoloid> > let f = ($); g = (.); infixr 0 `f`; infixr 9 `g` in (+2) `g` (*8) `f` 5
10:20:50 <lambdabot>   42
10:20:56 <EvanR-work> wow
10:21:32 <EvanR-work> precedence has lexical scope? ;)
10:21:36 <zygoloid> yep
10:21:52 <EvanR-work> isnane! (or sane, rather)
10:21:58 <EvanR-work> insane
10:22:17 <zygoloid> this was apparently not intentional in haskell'98, but it was permitted, and is intentional in haskell'2010
10:23:23 <EvanR-work> does scheme have infix?
10:23:29 * hackagebot haskelldb 2.0.1.1 - A library of combinators for generating and executing SQL statements.  http://hackage.haskell.org/package/haskelldb-2.0.1.1 (JustinBailey)
10:23:30 <Twey> No
10:23:41 <Twey> I don't see how else one could sanely implement it
10:23:56 <EvanR-work> (a `op` b c d) ;)
10:24:15 <Twey> Given that the *symbol* has lexical scope, it would be crazy if the precedence lived longer than the symbol did :þ
10:24:41 <exDM69> you can do infixes with scheme (using a macro or similar) but prefix/postfix is more tricky
10:24:49 <yrlnry> Were precedence declarations lexically scoped in SML/NJ?  
10:24:54 <yrlnry> I thought there was some insanity there.
10:31:06 <Botje> plt scheme supports (a .op. b) iirc :]
10:37:43 <HaskellElephant> Hey, I am having some problem with ghci, It doesn't find the Network package... I have tried ghc-pkg expose but it doesn't help... Any ideas?
10:38:02 <HaskellElephant> Is there any way to list what packages are hidden?
10:41:39 <HaskellElephant> So ghc-pkg lists network, not hidden however GHCI can't find it... Any ideas?
10:43:22 <mightybyte> HaskellElephant: Is there a .ghci file in the directory you are running it from?
10:43:54 <dcoutts_> HaskellElephant: the trick is always to state exactly what you're doing, e.g. with a paste of what command you ran and what the error message was
10:46:25 <dcoutts_> HaskellElephant: e.g. people can't tell if there's something technically wrong or if you're unsure what it means to select modules from a package using ghci
10:52:55 <HaskellElephant> well, I don't know what was wrong exactly, but reinstalling network package worked =D
11:09:23 <roconnor> what is the Language feature name for rank 2 polymorphism?
11:09:57 <kmc> Rank2Types
11:10:09 <kmc> ghc --supported-languages
11:24:16 <JohnnyL> EvanR-work: why does f .g $ x <=> (f .g) x ? Can one remember $ as being left associate for compositions?
11:24:30 <JohnnyL> associative
11:25:47 <tonkman> $ evaluates its right side first
11:26:10 <HaskellElephant> Hey guys, let's say I have some functions that are of type  State [Int] and some functions of type StateT [Int] IO . What is the best way of combining them, using the same state?  
11:26:18 <ClaudiusMaximus> JohnnyL: it's precedence rather than associativity here; eg a * b + c <=> (a * b) + c [precedence]  -vs-  a + b + c <=> (a + b) + c  -vs-  a + b + c <=> a + (b + c)  [left/right associativity]
11:26:53 <jmcarthur> tonkman: that's not true
11:27:16 <kmc> JohnnyL, it's because . has higher precedence than $
11:27:26 <kmc> go into ghci and type ":i (.)" and ":i ($)"
11:27:38 <JohnnyL> kmc, ClaudiusMaximus: Ok, thanks.
11:27:48 <jmcarthur> tonkman: ($) is right associative. that doesn't imply anything about evaluation order in haskell
11:28:24 <jmcarthur> > const "foo" $ undefined   -- if ($) evaluated the right side first then this wouldn't terminate
11:28:25 <lambdabot>   "foo"
11:28:47 <tonkman> ok
11:30:02 <tonkman> btw
11:30:24 <EvanR-work> JohnnyL: since $ has the lowest precedence, you can think of any expression e1 $ e2 as (e1) (e2). e1 $ e2 $ e3 would be *thinks* (e1) ((e2) (e3))
11:30:37 <engla> lazy haskell is cool, when I call   trace $ (transpose s) `mult` s   (you'll have to guess what the functions mean), it really is much quicker than to compute the full `mult`, because of the trace "reduction"
11:30:42 <engla> I didn't think it would work that well
11:31:08 <EvanR-work> hrm
11:31:28 <EvanR-work> is that last one right
11:32:43 <jmcarthur> EvanR-work: yeah, but your explanation is wrong
11:32:50 <jmcarthur> well, not wrong, but ambiguous
11:33:03 <EvanR-work> e1 e2 e3 are anything not containing $
11:33:07 <jmcarthur> it doesn't explain the associativity
11:33:50 <monochrom> in ghci use ":info $" to find out its associativity
11:33:51 <EvanR-work> i tried to explain that with e1 $ e2 $ e3
11:34:03 <jmcarthur> that is, "you can think of any expression e1 $ e2 as (e1) (e2)" doesn't tell you whether e1 $ e2 $ e3 should be (e1) ((e2) (e3)) or ((e1) (e2)) (e3)
11:34:09 <jmcarthur> ah okay
11:34:17 <monochrom> (there is nothing to explain. look up and infer.)
11:34:38 <jmcarthur> monochrom: i think the question for a lot of people is what associativity even means
11:35:07 <JohnnyL> how does: let oddSquareSum =( sum . takeWhile (<10000) . filter odd . map (^2) ) [1..] BECOMES let oddSquareSum = sum . takeWhile (<10000) . filter odd . map (^2)  $ [1..]    , IF $ is right associative?
11:35:33 <EvanR-work> in that case theres only two terms, so assoc doesnt matter
11:35:34 <monochrom> . has higher precedence
11:35:44 <jmcarthur> JohnnyL: that has to do with precedence, not associativity
11:35:59 <monochrom> 4 * 5+1
11:36:05 <jmcarthur> JohnnyL: ($) binds more loosely than anything else in that expression
11:36:43 <tonkman> how do I split 123456 to [12,34,56]
11:36:54 <solistic> is there a way to use the non-threaded runtime and still have other haskell threads running while one thread is blocking in C-land?
11:36:54 <EvanR-work> :t chunk
11:36:55 <lambdabot> Not in scope: `chunk'
11:37:05 <tonkman> I have tried with few modulo tricks
11:37:14 <JohnnyL> EvanCarroll: Ah ok
11:37:31 <EvanR-work> show in base 10 and use chunk split
11:37:59 <tonkman> so it has to converted to string first
11:38:10 <EvanR-work> or use base10 'bittwiddling' ;)
11:38:10 <jmcarthur> doesn't have to be
11:38:10 <tonkman> *has to be
11:38:22 <tonkman> bittwiddling?
11:38:31 <tonkman> never heard
11:38:33 <jmcarthur> :t unfoldr
11:38:33 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
11:38:35 <jmcarthur> :t divMod
11:38:36 <lambdabot> forall a. (Integral a) => a -> a -> (a, a)
11:38:41 <ski> > unfoldr (\n -> if n == 0 then Nothing else Just (let (q,r) = n `divMod` 100 in (r,q))) 123456
11:38:42 <lambdabot>   [56,34,12]
11:38:51 <jmcarthur> spoiled it, ski :P
11:38:56 <EvanR-work> 56 is x & 100
11:39:09 <EvanR-work> 34 is x >> 2, & 100
11:39:10 <kmc> solistic, you could make your C code spawn a new OS thread
11:39:38 <EvanR-work> >> is division by 10^n and & is modulo ;)
11:39:57 * pumpkin pouts
11:40:06 * ski sprouts
11:40:44 * EvanCarroll doubts
11:40:57 <pumpkin> I'm going to have to make lots of changes to my code :(
11:40:57 * EvanR-work shouts
11:41:10 <monochrom> @query lambdabot
11:41:11 <lambdabot> Unknown command, try @list
11:41:32 * sproingie grouts
11:41:34 <solistic> kmc: hmm, no sure if that gets too complicated
11:41:46 <kmc> well yes it does
11:41:50 <kmc> because threading in C is an insane mess
11:41:55 <monochrom> > 123456 .&. 100 :: Int
11:41:56 <lambdabot>   64
11:42:15 <kmc> the simple solution would be to let the clever and expertly developed GHC runtime system handle threading
11:42:29 <kmc> by using the threaded rts
11:42:47 <EvanR-work> > let & = mod in 123456 & 100
11:42:48 <lambdabot>   <no location info>: parse error on input `&'
11:43:04 <EvanR-work> > let (&) = mod in 123456 & 100
11:43:05 <lambdabot>   56
11:43:43 <EvanR-work> i mean to say & (power of ten minus 1)
11:43:45 <solistic> kmc: well I have some odd behavior with ncurses resize evets when I use the threaded runtime, but I guss I have to pin that, somehow.
11:44:06 <monochrom> > 123456 .&. 99 :: Int
11:44:07 <lambdabot>   64
11:44:19 <EvanR-work> you need decimal and
11:44:21 <EvanR-work> lol
11:45:17 <jmcarthur> pumpkin: i hate that
11:45:26 <jmcarthur> happens to me... pretty much in every project i work on
11:45:30 <pumpkin> I just made a bad design decision in this natural binding
11:45:37 <pumpkin> and now I need to pass along an extra word :/
11:45:37 <monochrom> I'm pretty sure "decimal and" and "(&) = mod" is your inside joke with yourself
11:45:42 <kmc> solistic, i suppose you would have to serialize your access to ncurses
11:45:45 <kmc> is it from Haskell or C?
11:46:10 <kmc> you can serialize related IO actions easily by making a Chan (IO ()) and a single thread to read and execute actions
11:46:33 <EvanR-work> monochrom: its hilarious trust me
11:46:48 <solistic> kmc: I do that mostly, but I can not get input from the event loop, otherwise it would be blocked, right?
11:46:57 <kmc> not sure what you mean
11:47:53 <solistic> I mean i still want to update the screen while waiting for user input, so I do call wget_wch from an other thread
11:48:21 <kmc> ok
11:48:29 <EvanR-work> kmc's thing would work if the only IO actions allowed 'finished immediately'
11:48:30 <kmc> well what does ncurses have to say about this kind of concurrency?
11:49:00 <mreh> graphmod *.hs */*.hs | dot -Tpng 1> graph.png
11:49:05 <mreh> why is my file blank?
11:49:30 <zygoloid> @pl [-1..5]
11:49:30 <lambdabot> (line 1, column 1):
11:49:30 <lambdabot> unexpected "["
11:49:30 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
11:49:35 <zygoloid> @pl enumFromTo (-1) 5
11:49:35 <lambdabot> [-1..5]
11:50:22 <roconnor> The haskell identing for Kate is terrible.  Who wrote this?
11:50:24 <solistic> kmc: I read somewhere that there may be thread safe libs, but I only have two libs (nucurse and ncurses_g)
11:50:37 <EvanR-work> s/The haskell identing for //
11:50:38 <solistic> kmc: just try to find that again in the man pages
11:50:56 <solistic> kmc: I mean I just try to find that again ;)
11:51:01 <roconnor> EvanR-work: what should I use instead?
11:51:14 <EvanR-work> anything
11:51:23 <roconnor> EvanR-work: how about Kate then
11:51:29 <EvanR-work> no
11:51:45 <monochrom> are you trolling?
11:52:24 <fysx> haskell editing for gedit is alright... although after learning some emacs, it seems to have the best haskell support i've seen... others?
11:52:38 <roconnor> Kate puts *tabs* into my file.
11:52:39 <zomg> What does emacs have for haskell editing?
11:52:54 <fysx> haskell-mode and agda-mode work well
11:52:56 <EvanR-work> zomg: haskell mode
11:53:04 <zomg> I have absolutely no idea what that does
11:53:06 <zomg> Please elaborate
11:53:07 <zomg> :D
11:53:21 <fysx> feature wise, i just use tabbing... i think it might have compiling.. anyone else?
11:53:31 <fysx> oh and syntax highlighting :P
11:53:37 <roconnor> No instance for (Applicative Identity)  :(
11:53:40 <monochrom> haskell-mode for emacs has almost psychic indenting
11:54:48 <monochrom> http://projects.haskell.org/haskellmode-emacs/
11:55:09 <zomg> Interesting
11:55:14 <zomg> I think I'll stick to vim though =)
11:55:30 <monochrom> there no need for editor wars
11:55:38 <zomg> Ya it's just what I use
11:55:45 <jmcarthur> there is nothing wrong with using an editor that suits you
11:55:50 <monochrom> I even use "cat > x.hs" sometimes
11:55:50 <zomg> It has hilight for haskell but besides that nothing special
11:55:55 <roconnor> @hoogle Id
11:55:55 <lambdabot> Prelude id :: a -> a
11:55:56 <lambdabot> Control.Category id :: Category cat => cat a a
11:55:56 <lambdabot> Data.Function id :: a -> a
11:56:03 <kmc> no everyone must use only my preferred editor
11:56:12 <jmcarthur> however, there is something wrong with not considering all valid options. that's not an accusation toward anybody, but it happens a lot in general
11:56:25 <zomg> Is there any editor with anything like code-assist you get with stuff like F# in visual studio?
11:56:26 <monochrom> no one may use my editor
11:56:29 <jmcarthur> s/not considering/being closed minded about/
11:56:45 <fysx> zomg: that would be amazing!  let's write it!
11:56:49 <roconnor> where is Id?
11:57:15 <jmcarthur> roconnor: don't mtl and transformers have Identity?
11:57:22 <jmcarthur> roconnor: monadLib, too
11:57:47 <roconnor> the applicative docs says that Id is an instance of applicative
11:58:01 <jmcarthur> and it doesn't link anywhere?
11:58:06 <roconnor> nope
11:58:11 <jmcarthur> huh
11:58:19 <roconnor> I tell it like it is
11:58:43 <roconnor> http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/Control-Applicative.html
11:59:14 <EvanR-work> ed is way better than cat
11:59:22 <EvanR-work> way more features!
11:59:28 <EvanR-work> cat sucks
12:00:02 * hackagebot fibon 0.2.0 - Tools for running and analyzing Haskell benchmarks  http://hackage.haskell.org/package/fibon-0.2.0 (DavidPeixotto)
12:00:37 <fysx> hey.. not starting a war, just curious... any benefits to point-free style aside from just sugar?
12:00:39 <Veinor> cat is my ghetto file copier
12:00:53 <kmc> fysx, more readable.  don't name things you don't need to
12:01:01 <Veinor> copy a file from my terminal that's ssh'd into my remote, paste it into the local terminal
12:01:13 <kmc> "h is f composed with g" rather than "h is the function which, for input x, returns f applied to g applied to x"
12:01:19 <Veinor> yeah
12:01:35 <kmc> "multiply by two" rather than "take some x, and return x times two"
12:01:40 <Veinor> @unpl g >=> h
12:01:40 <lambdabot> (g >=> h)
12:01:45 <fysx> so sugar then ? :P
12:01:50 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
12:01:58 <kmc> fysx, what do you mean by "sugar"?
12:02:15 <fysx> syntactic sugar...  
12:02:15 <kmc> you're asking if it makes some difference to the machine?
12:02:33 <jmcarthur> fysx: it's a different way to look at your code beyond mere sugar, even though it will technically mean the same thing most of the time
12:02:38 <fysx> yeah... any performance, flexibility, usable feature?
12:03:01 <EvanR-work> spelling things differently should strictly not affect performance
12:03:05 <kmc> often readability is more important than those
12:03:11 <EvanR-work> like it does most of the time in javascript, python etc
12:03:15 <kmc> i'd say it's more flexible too
12:03:25 <jmcarthur> fysx: i have seen some cases where ghc can optimize point free code more nicely than pointful code, but i wouldn't say it's the case in general
12:03:27 <monochrom> pointfree is more flexible and usable
12:03:36 <fysx> yeah.. so prefer point free when it leads to more readable code.. if it doesn't, then no reason to contort your code into point-free style
12:03:47 <kmc> when you write everything as a composition of small functions, it's easy to add / remove / move components of that chain
12:03:49 <EvanR-work> point free is definitely more readable
12:03:50 <kmc> also easier to test
12:04:06 <jmcarthur> fysx: i'd say that's a good rule of thumb, but it will lead different people to different amounts of point free code anyway
12:04:53 <EvanR-work> especially when it consists mostly of (, ), ., id, and flip
12:04:55 <jmcarthur> i lean quite heavily toward point free style. pointful style is kind of "giving up" to me
12:05:18 <jmcarthur> EvanR-work: i see complicated arrangements of such things to be a sign that there is a nicer abstraction waiting for me somewhere in there
12:05:27 <jmcarthur> a nicer combinator, in particular
12:05:41 <EvanR-work> (.).(.)
12:06:02 <jmcarthur> that one is very common, yeah
12:06:03 <fysx> jmcarthur: got a good site that describes common combinators and uses?
12:06:06 <mightybyte> EvanR-work: Yeah, I've seen that one too.
12:06:35 <jmcarthur> fysx: not really. they kind of have to be learned incremementally because they often take more general forms
12:07:12 <jmcarthur> fysx: the DeepArrow package has a lot of nice things for point free code, in addition to the things already in base
12:07:31 <fysx> jmcarthur: okie
12:08:58 <jmcarthur> fysx: in fact, hackage appears to have a Combinators category: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:combinators
12:09:15 <monochrom> typical HXT code is like "load file" >>> "modify with" ("find text nodes" >>> "convert to uppercase") >>> "write file". there is no need to write like java "let x be a node. is x text node? convert x content to uppercase"
12:10:03 <jmcarthur> if you want to make your code practically unreadable you could abuse this http://hackage.haskell.org/packages/archive/data-aviary/0.2.3/doc/html/Data-Aviary-Birds.html
12:10:34 <EvanR-work> nice
12:10:40 <jmcarthur> looks like a fun experiment :)
12:11:11 <EvanR-work> i should show this to my friend who knows birds, but is wary of computer programming
12:11:21 <fysx> weird
12:11:38 <jmcarthur> fysx: here's a good reference for some combinators in base (don't use this module directly) http://hackage.haskell.org/packages/archive/data-aviary/0.2.3/doc/html/Data-Aviary-Functional.html
12:11:51 <jmcarthur> i guess some of those are not in base
12:11:55 <jmcarthur> e.g. the Comonad stuff
12:12:47 <fysx> jmcarthur: cool stuff...  gotta gain some experience with this
12:13:43 <EvanCarroll> why does this not work ( fmap (+) (+3) ) $ 1 1, but this does ( ( fmap (+) (+3) ) $ 1 ) $ 1
12:14:02 <monochrom> because (1 1) does not work
12:14:12 <Botje> f $ 1 1 = f (1 1)
12:14:20 <jmcarthur> EvanCarroll: the first one means (fmap (+) (+3)) (1 1)
12:14:32 <opqdonut> > ( fmap (+) (+3) ) 1 1
12:14:32 <lambdabot>   5
12:14:40 <EvanCarroll> bleh, I hate that. I find that so confusing
12:14:41 <jmcarthur> 1 1 works witha Num instance :)
12:14:44 <EvanCarroll> how come (+) 4 2 works
12:14:45 <jmcarthur> *with a
12:14:57 <monochrom> because ((+) 4) 2 works
12:15:00 <jmcarthur> (+) 4 2 works because you aren't applying 4 to 2
12:15:00 <opqdonut> (+) 4 2 works just like ( fmap (+) (+3) ) 1 1
12:15:04 <EvanR-work> EvanCarroll: e1 $ e1 <=> (e1) (e2) ;)
12:15:09 <opqdonut> "(+) $ 4 2" doesn't work
12:15:09 <EvanR-work> crap
12:15:13 <EvanR-work> EvanCarroll: e1 $ e2 <=> (e1) (e2) ;)
12:15:50 <EvanCarroll> so is there a less verbose way of writing ( ( fmap (+) (+3) ) $ 1 ) $ 1
12:16:14 <monochrom> I tend to say "5", but...
12:16:19 <jmcarthur> yes there is:
12:16:36 <monochrom> fmap (+) (+3) 1 1  is just fine
12:16:38 <jmcarthur> > fmap (+) (+3) 1 1
12:16:39 <lambdabot>   5
12:16:42 <EvanCarroll> interesting
12:16:44 <jmcarthur> or:
12:16:58 <jmcarthur> > ((+) . (+3)) 1 1
12:16:59 <lambdabot>   5
12:17:13 <monochrom> you see how you can be more concise by not using $
12:17:24 <EvanCarroll> yar
12:17:30 <EvanR-work> down with $
12:17:55 <jmcarthur> it is a ever continuing struggle for me not to mix up EvanR-work and EvanCarroll in isolation from each other
12:18:29 <jmcarthur> ($) isn't bad
12:18:32 <jmcarthur> just don't misuse it
12:19:01 <sproingie> i wonder
12:19:07 <sproingie> > 1 `(+)` 1
12:19:08 <lambdabot>   <no location info>: parse error on input `('
12:19:19 <sproingie> aw, nope
12:19:34 <jmcarthur> > (+3) + 1 $ 1
12:19:35 <lambdabot>   5
12:19:41 <jmcarthur> there's one to confuse you
12:19:57 <Jiten_> which module to use for implementing HTTP server? any recommendations?
12:20:36 <EvanR-work> jmcarthur: i get confused if they even start with the same glyph
12:20:49 <EvanR-work> and have similar lengths
12:22:18 <EvanCarroll> all function return 1 value right?
12:22:35 <jmcarthur> (+3) + 1 $ 1   =   liftA2 (+) (+3) (const 1) 1   =   fmap (+) (+3) 1 1
12:22:41 <kmc> EvanCarroll, yes
12:22:49 <kmc> however that value can be a composite value like a tuple, list, etc.
12:22:51 <EvanCarroll> so how does a lambda return two values?
12:22:56 <EvanR-work> or a function
12:22:58 <EvanCarroll> kmc: granted
12:22:59 <kmc> what do you mean?
12:23:05 <EvanCarroll> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
12:23:10 <EvanCarroll> To demonstrate on a real example, when we did (+) <$> (+3) <*> (*100) $ 5, the 5 first got applied to (+3) and (*100), resulting in 8 and 500. Then, + gets called with 8 and 500, resulting in 508.
12:23:14 <EvanCarroll>     f <*> g = \x -> f x (g x)  
12:23:21 <EvanCarroll> (+) <$> (+3) <*> (*100) $ 5 
12:23:54 <jmcarthur> i still don't see where you are thinking it's returning two values anywhere
12:23:57 <kmc> where is a lambda returning two values?
12:24:20 <monochrom> (+3) 5 gives you 8. one value
12:24:21 <EvanCarroll> I looks to me if I substitute x into that lambda I get `(+3) 5  ((*100) 5)`
12:24:36 <monochrom> (*100) 5 gives you 500. one value.
12:24:37 <kmc> yeah
12:24:41 <EvanCarroll> how does that get returned as the two values (+) needs
12:24:43 <monochrom> "where is the missing value?"
12:24:51 <kmc> it doesn't EvanCarroll
12:24:55 <jmcarthur> EvanCarroll: a lambda can *substitute* into more than one location inside it
12:25:02 <EvanCarroll> ah!
12:25:04 <jmcarthur> EvanCarroll: that's not returning more than one value
12:25:07 <kmc> you'd have to look at the definition of <$>
12:25:17 <EvanR-work> > (\x -> (x,x,x)) 9
12:25:18 <lambdabot>   (9,9,9)
12:25:23 <kmc> <$> :: (a -> b) -> f a -> f b
12:25:29 <kmc> <*> :: f (a -> b) -> f a -> f b
12:25:58 <EvanR-work> > (,,) 9
12:25:59 <lambdabot>   Overlapping instances for GHC.Show.Show (b -> c -> (t, b, c))
12:25:59 <lambdabot>    arising fr...
12:26:00 <kmc> so say «(+) <$> (+3) :: f (Int -> Int)»
12:26:04 <monochrom> it is really just ((+3) 5) + ((*100) 5)
12:26:05 <EvanR-work> > (,,) 9 9 9
12:26:05 <lambdabot>   (9,9,9)
12:26:14 <EvanCarroll> I've never see «(+)
12:26:23 <kmc> and then «that <*> (*100) :: f Int -> f Int»
12:26:29 <kmc> i'm using «» to quote Haskell code within text
12:26:33 <jmcarthur> EvanCarroll: that's just a fancy quotation mark
12:26:34 <EvanR-work> kmc has fancy quotation marks
12:26:39 <jmcarthur> heh
12:26:56 <monochrom> all <*> does is fork 5 to both (+ 3) and (* 100)
12:26:57 <EvanR-work> the official english name for them
12:27:47 <EvanCarroll> gah, i'm still not getting it.
12:27:50 <monochrom> kmc and I settled on using «» because «"hello" ++ "hi"» is less ambiguous than ""hello" ++ "hi""
12:28:00 <Zao> EvanR-work: Guillemets (sp)
12:28:05 <fysx> where do i find these <$> and <*> ? 
12:28:06 <EvanCarroll> How does (+) get called with 8 and 500 if <*> isn't returning two arguments.
12:28:12 <kmc> fysx, Control.Applicative
12:28:12 <EvanCarroll> fysx: Control.Applicatives
12:28:28 <kmc> EvanCarroll, remember that a two-argument function actually takes one argument and returns a function to take another argument
12:28:31 <jmcarthur> EvanCarroll: it seems to me that if you are having trouble with lambdas and precedence and associativity then you shouldn't be on the Applicative section yet, just in my opinion
12:29:00 <EvanCarroll> not the question.
12:29:02 <EvanR-work> yeah you should already be on arrows
12:29:09 <monochrom> <*> is quite a bit very powerful
12:29:09 <jmcarthur> EvanR-work: you're mean
12:29:24 <EvanR-work> i still dont know applicative
12:29:32 <fysx> naive question, but where are you guys learning about things like Control.Applicative?  from experience or some readings?
12:29:34 <jmcarthur> EvanCarroll: i wasn't trying to be mean
12:29:38 <EvanCarroll> Anyway, I'll post to SO.
12:29:45 <kmc> fysx, well EvanCarroll linked the LYAH section about it
12:29:48 <EvanCarroll> jmcarthur: You weren't, but you were also not being at all helpful ;(
12:30:01 <monochrom> I learned Control.Applicative from here. Not a lot to learn.
12:30:29 <kmc> EvanCarroll, maybe it would be less confusing with an applicative functor other than ((->) r)
12:30:33 <jmcarthur> EvanCarroll: i thought what i said may have been the most helpful thing you could hear, personally. just because you don't want to hear it doesn't make it unhelpful
12:30:36 <fysx> oh yeah.. learn you a haskell for great good...  i'll dig
12:30:38 <kmc> > (+) <$> Just 3 <*> Just 4
12:30:39 <lambdabot>   Just 7
12:30:46 <kmc> EvanCarroll, do you understand how the above code works?
12:31:11 <monochrom> jmcarthur is helpful and truthful.
12:31:46 <kmc> i think it's helpful to have someone experienced suggest that you're going about things in the wrong order
12:31:54 <kmc> it can save much pain
12:33:31 <EvanCarroll> kmc, yes you're extracting 3 from Maybe Int, and returning a function in the Maybe functor that expects one argument.
12:34:22 <EvanCarroll> then you're unboxing Just 4, and the functor from the previous result, combining them and return the new result in the functor of the lhs
12:34:41 <kmc> and what's the type of (+) <$> Just 3
12:34:45 <roconnor> @type memtpy
12:34:46 <lambdabot> Not in scope: `memtpy'
12:34:48 <roconnor> @type mempty
12:34:49 <lambdabot> forall a. (Monoid a) => a
12:34:53 <EvanCarroll> Maybe ( a -> a ) ?
12:35:08 <kmc> yeah
12:35:09 <dons> ?yow
12:35:09 <lambdabot> Couldn't find fortune file
12:35:18 <kmc> so (+) is getting one argument at a time
12:35:37 <kmc> it's the same in your example, except that instead of lifting (+) to work on Maybe values, we're lifting it to work on functions returning numbers
12:36:16 <EvanCarroll> right, and that's where my head aparently blows up, but I'm not sure why
12:36:24 <EvanR-work> im finding <$> <*> hard to type
12:36:30 <jmcarthur> the ((->) a) functor can be confusing sometimes
12:36:39 <jmcarthur> i'm surprised LYAH even covers it
12:36:54 <EvanCarroll> LYAH is awesome. what can I say.
12:36:58 <jmcarthur> heh
12:37:18 <monochrom> I think it's a deliberate shock therapy.
12:37:39 <jmcarthur> LYAH teaches with shock therapy? wow
12:37:42 <monochrom> Better explode early with mere Applicative than explode latter with Monad.
12:37:49 <jmcarthur> i thought LYAH was gentler than that
12:37:49 <EvanCarroll> that's not what I want to hear someone say when I'm struggeling to understand it.
12:37:50 <kmc> it can be confusing; it can also occasionally make wrong code typecheck
12:38:02 <EvanCarroll> m/t =(
12:38:25 <EvanCarroll> I'm also reading the RWH book
12:38:31 <EvanCarroll> I finished the thompson book
12:38:35 <beginner1> hi i am absolutley new to haskell, I am doing homework, can someone help me with arrays?
12:38:51 <EvanCarroll> beginner1: don't ask2ask, etc.
12:38:52 <kmc> beginner1, yes, ask your qusetion :)
12:38:59 <monochrom> what are arrays, really?
12:39:05 <EvanR-work> lol
12:39:19 <jmcarthur> it's a valid question
12:39:25 <jmcarthur> beginners often call our lists arrays
12:39:57 <EvanR-work> and in python, its come to my attention that lists... are really arrays
12:40:01 <jmcarthur> it's only sensible, too. most languages don't make linked lists their primary collection structure
12:40:13 <monochrom> I guess I killed the question.
12:40:24 <jmcarthur> do they call arrays in python lists?
12:40:34 <EvanR-work> no they are vectors
12:40:37 <jmcarthur> ah
12:40:43 <jmcarthur> that's a sensible name at least
12:41:14 <jmcarthur> i'm not entirely sure i understand the difference between a vector and an array
12:41:21 <jmcarthur> if any
12:41:23 <EvanR-work> i might have to check, been a long time
12:41:32 <EvanR-work> there arent any im sure
12:42:04 <monochrom> by some historical accident, "array" implies fixed size, "vector" implies expandible. strange culture.
12:42:06 <[swift]> i always interpreted a vector in programming (as opposed to mathematics) as a variable-length array
12:42:08 <beginner1> Input: test = ([("a", "b"), ("a", "d"), ("a", "e")], [("b","c"), ("d","c")]), output = [("a","c"),("a","c")]. basicly I need to check output if there are elements repeating in this example ("a","c") ir written twice. What should I read or someone can give me an example how to filter output, that one string appears once.
12:42:21 <jmcarthur> monochrom: that seems counterintuitive to me, even
12:42:33 <EvanR-work> actually they are called arrays
12:42:57 <kmc> beginner1, yeah, that's a list, not an array
12:43:20 <[swift]> i feel like a tuple is closest to the mathematical notion of a vector
12:43:27 <beginner1> sorry, I am new to this, but anyway, how can I check this list for not repeating elements
12:43:38 <jmcarthur> [swift]: what about very high dimensional vectors?
12:44:05 <[swift]> jmcarthur: still seems consistent. if we're talking infinite-dimensional vectors, that's a different story, of course =)
12:44:05 <jmcarthur> [swift]: i'd say that a fixed-length array seems closest to a mathematical vector
12:44:11 <tomh> mm anyone can explain me how type families work?
12:44:30 <jmcarthur> [swift]: tuples don't imply that it's homogeneous
12:44:50 <[swift]> jmcarthur: do mathematical vectors? i didn't think so
12:45:02 <EvanR-work> i just take vector to mean array, variable length confuses me so i ignore it unless i cant
12:45:08 <jmcarthur> [swift]: most mathematical vectors i've seen do, but my experience is limited
12:45:09 <[swift]> jmcarthur: why couldn't you have a vector in R x C for example?
12:45:35 <jmcarthur> [swift]: you mean where each component is RxC? that's how i interpret what you just said, anyway
12:45:36 <monochrom> curiosity just kills the cat. philosophy kills the whole channel.
12:45:38 <[swift]> jmcarthur: i don't claim to be an expert either =)
12:45:59 <jmcarthur> i hate terminology quabbles. we should stop this before it becomes toxic :P
12:46:00 <[swift]> jmcarthur: no, where on component is in the reals and another is in the complex numbers, for example
12:46:02 <EvanR-work> [swift]: jmcarthur theres an implied homogeneity so you can do O(1) lookup with pointer arithmetic
12:46:05 <kmc> less philosophy, more answering questions?
12:46:10 <beginner1> has anyone got an idea about my question?
12:46:12 <jmcarthur> EvanR-work: well, in programming, sure
12:46:19 <monochrom> except I don't even understand the question.
12:46:20 <jmcarthur> EvanR-work: but we are talking about mathematics
12:46:24 <kmc> :t elem
12:46:24 <EvanR-work> we know what vectors are in math ;)
12:46:25 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:46:30 <kmc> beginner1, that may be useful
12:46:34 <kmc> > 'x' `elem` "xyz"
12:46:34 <EvanR-work> vector space
12:46:35 <lambdabot>   True
12:47:05 <beginner1> thank you
12:47:54 <EvanR-work> > elem 'x' ("x" ++ genericReplicate 100000000000000000000 'y' ++ "z")
12:47:55 <lambdabot>   True
12:48:47 <acemo> EvanR-work: u might aswell replace that statement by True
12:48:55 <EvanR-work> definitely
12:49:14 <monochrom> it's an experiment with elem, not an experiment with boolean
12:49:33 <EvanR-work> > elem 'x' ("x" ++ genericReplicate 100000000000000000000 'y' ++ "x")
12:49:34 <lambdabot>   True
12:49:45 <[swift]> if efficiency is a concern sorting the list before checking for duplicates is probably the way to go
12:50:04 <kmc> if you actually just want to remove duplicates, there's Data.List.nub
12:50:11 <kmc> or you could use Data.Set
12:50:17 <kmc> but i guess this is an exercise you want to solve yourself
12:50:17 <jmcarthur> > nub "acbdsflkjlbdooisw"
12:50:18 <lambdabot>   "acbdsflkjoiw"
12:50:52 <kmc> > nub "mississippi"
12:50:53 <lambdabot>   "misp"
12:50:58 <kmc> > group "mississippi"
12:50:59 <lambdabot>   ["m","i","ss","i","ss","i","pp","i"]
12:51:05 <jmcarthur> > nub "tennessee"
12:51:06 <lambdabot>   "tens"
12:51:16 <[swift]> oh snap, "group" is a good call
12:51:25 <kmc> :t map head . filter ((>1) . length) . sort
12:51:26 <lambdabot> forall a. (Ord a) => [[a]] -> [a]
12:51:30 <jmcarthur> > map head . group $ "mississippi"
12:51:31 <lambdabot>   "misisipi"
12:51:32 <EvanR-work> > group "mississippi" >>= head
12:51:33 <lambdabot>   Couldn't match expected type `[b]'
12:51:33 <lambdabot>         against inferred type `GHC.Types...
12:51:35 <kmc> :t map head . filter ((>1) . length) . group . sort
12:51:36 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:51:39 <jmcarthur> > map head . group . sort $ "mississippi"
12:51:40 <lambdabot>   "imps"
12:51:59 <EvanR-work> > map head (group "mississippi")
12:52:00 <lambdabot>   "misisipi"
12:52:12 <ray> @faq can haskell turn mississippi into imps?
12:52:12 <lambdabot> The answer is: Yes! Haskell can do that.
12:52:23 <kmc> :t let f (x:_:_) = Just x; f _ = Nothing in catMaybes . map f . group . sort
12:52:24 <lambdabot> forall a. (Ord a) => [a] -> [a]
12:52:30 <EvanR-work> (> map head . group . sort) "mississippi"
12:52:34 <EvanR-work> > ( map head . group . sort) "mississippi"
12:52:35 <lambdabot>   "imps"
12:52:44 <EvanR-work> @src nub
12:52:44 <lambdabot> nub = nubBy (==)
12:53:12 <acemo> this channel seems interesting :)
12:53:21 <EvanR-work> would nub be better implemented with map head . group . sort
12:53:24 <jmcarthur> > map fst . sortBy (comparing snd) . map head . groupBy (comparing fst) . sortBy (comparing fst) . flip zip [0..] $ "mississippi"
12:53:25 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
12:53:25 <lambdabot>         against inferred type ...
12:53:48 <jmcarthur> lol that's bad anyway
12:54:35 <EvanR-work> flip zip snap clap
12:54:41 <acemo> does haskell has a default heapsort implementation?
12:54:45 <jmcarthur> > map fst . sortBy (comparing snd) . map head . groupBy ((==) `on` fst) . sortBy (comparing fst) . flip zip [0..] $ "mississippi"  -- still not what i wanted, but type checks at least
12:54:46 <lambdabot>   "misp"
12:55:00 <kmc> acemo, the language standard specifies no such thing
12:55:10 <ray> zip zop zoobidy bop
12:55:14 <jmcarthur> > map fst . sortBy (comparing snd) . map head . groupBy ((==) `on` fst) . sort . flip zip [0..] $ "mississippi"  -- this may be what i meant
12:55:15 <lambdabot>   "misp"
12:55:17 <monochrom> the default sort is closer to merge sort
12:55:22 <kmc> i think the sort used by the Data.List that actually ships with ghc is mergesort
12:55:28 <acemo> kmc, thats great. No cheating possible for my homework :)
12:55:28 <EvanR-work> @faq can haskell code implement bill cosby
12:55:28 <lambdabot> The answer is: Yes! Haskell can do that.
12:55:43 <jmcarthur> mergesort and quicksort play nicely with laziness :)
12:56:08 <kmc> though some argue a true quicksort must be in-place
12:56:13 <kmc> but that's just a matter of naming
12:56:17 <opqdonut> quicksort?
12:56:24 <monochrom> merge sort was chosen simply because it required less work
12:56:26 <opqdonut> how does it play nicely with mergesort?
12:56:31 <opqdonut> gah, with laziness
12:56:35 <opqdonut> mergesort i can see
12:56:41 <jmcarthur> yeah, there is still this algorithm which may or may not be called quicksort that works like a purely functional version of the in-place quicksort
12:56:55 <acemo> as homework we have to make an external heapsort implementation in Java, I'm planning on doing it in haskell though
12:56:57 <jmcarthur> opqdonut: there was a blog post about it somewhere
12:57:06 <ray> i'm a mathematician, we just show that an ordering exists
12:57:07 <monochrom> I mean as compared to heap sort. heap sort requires first talking about yet another data structure.
12:57:21 <opqdonut> jmcarthur: ah, found it
12:57:25 <jmcarthur> opqdonut: http://apfelmus.nfshost.com/articles/quicksearch.html
12:57:31 <opqdonut> yes, exactly that
12:57:40 <ray> if you do it constructively enough it can be treated as an algorithm if you are into that kinky stuff
12:57:41 <opqdonut> ISTR reading that post ages ago :)
12:57:43 <yitz> for imperative languages i like shell sort
12:58:07 <monochrom> external heap sort sounds like a disaster
12:58:28 <EvanR-work> it should be appropriate to use java then
12:58:29 <yitz> it's very fast, probably because it allocates no memory and gets cache hits.
12:58:32 <acemo> monochrom: external heap sort in generally or in haskell?
12:58:33 <jmcarthur> radix sort is pretty awesome when you can use it :)
12:58:43 <beginner1> This is function that prints result
12:58:44 <beginner1> add vaardn i j =   if snd (viens vaardn  !! i) == fst (divi vaardn  !! j) then [(fst (viens vaardn !! i) , snd (divi vaardn  !! j))] ++ f1 vaardn  i j else f1 vaardn i j 
12:58:50 <jmcarthur> at least it is for large arrays
12:58:56 <beginner1> how could I arrange this line [(fst (viens vaardn !! i) , snd (divi vaardn  !! j))] ++ f1 vaardn  i j into a list and check for repeating elements?
12:59:21 <ray> as we all know, if you take the axiom of choice, there is always a well-ordering
12:59:33 <ray> so sorts are therefore equivalent to choice
12:59:41 <opqdonut> AC not needed for finite cases
12:59:42 <monochrom> external heap sort in general. external storage is usually not very friendly to heap.
12:59:48 <opqdonut> sorry to spoil your mathematical fun
12:59:57 <EvanR-work> opqdonut: but haskell has infinite data :)
13:00:04 <ray> the infinite case can happen in haskell
13:00:09 <opqdonut> no they can't
13:00:19 <acemo> monochrom: alright, in that case i'll just try it in haskell. I like haskell ^.^
13:00:19 <yitz> ray how about monte carlo sort?
13:00:23 <ray> at least if you're butchering the concepts like i already am
13:00:24 <opqdonut> you can't reorder an infinite list arbitrarily
13:00:25 <opqdonut> in finite time
13:00:28 <monochrom> for example merge sort is preferred for external because sequential external storage is plentiful and fast enough.
13:00:49 <acemo> fastest sorting algorithm would still be quantum bogo sort.
13:01:03 <ray> good thing we've already shown an ordering exists and are above such trivialities as sorts
13:01:14 <EvanR-work> should be possible with MonadQuantum
13:01:21 <ray> yes i implemented that one in haskell already
13:01:27 <lucca> > sort [1..]
13:01:31 <lambdabot>   mueval-core: Time limit exceeded
13:01:57 <ray> it's an example in my unsafeDestroyUniverse module
13:02:01 <monochrom> "an implementation exists"
13:02:32 <paolino>  /join #haskell-wine
13:02:44 <ray> monochrom: programs are just constructive proofs of that
13:02:45 <yitz> Control.Schroedinger
13:03:06 <monochrom> OutOfControl.Schrödinger
13:04:03 <EvanR-work> heisenberg compensators
13:04:52 <ray> i just accept nonconstructive existence proofs of implementations too
13:05:05 <ray> can't really call them "programs"
13:06:17 <monochrom> I don't want programs anyway. programs are the greatest source of errors.
13:06:56 <EvanR-work> i thought that was programmers
13:07:06 <dons> ?remember monochrom I don't want programs anyway. programs are the greatest source of errors.
13:07:06 <lambdabot> I will never forget.
13:07:36 <ray> programmers are the greatest source of programs.
13:08:13 <olsner> aha! so *programmers* are the greatest source of errors
13:08:38 <proq> programmers are the greatest source of solutions
13:08:45 <mahogny> and life would be so much easier without users
13:08:45 <monochrom> humanity is the greatest source of programmers.
13:08:53 <monochrom> and users.
13:08:59 <monochrom> exterminate all humans
13:09:03 <mahogny> agreed
13:09:05 <mahogny> working on it
13:09:05 <ray> QED
13:09:21 <EvanR-work> note to self dont invent robots
13:09:33 <dk> hey guys, i've got a simple question: is there a ready-to-use function that gives me an integer as binary string? i wrote my own, i'm just curious =)
13:10:00 <Botje> showIntAtBase 2
13:10:01 <Botje> iirc
13:10:11 <Botje> @hoogle showintatbase
13:10:11 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
13:10:14 <EvanR-work> > showIntAtBase 2 99
13:10:14 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
13:10:15 <lambdabot>    arising from the literal `9...
13:10:15 <Botje> that.
13:10:26 * hackagebot parsimony 1.1 - Monadic parser combinators derived from Parsec  http://hackage.haskell.org/package/parsimony-1.1 (IavorDiatchki)
13:10:28 <EvanR-work> > showIntAtBase 2 chr 99
13:10:29 <lambdabot>   Overlapping instances for GHC.Show.Show
13:10:29 <lambdabot>                              (GHC.B...
13:11:00 <EvanR-work> > (showIntAtBase 2 chr 99) ""
13:11:01 <lambdabot>   "\SOH\SOH\NUL\NUL\NUL\SOH\SOH"
13:11:21 <EvanR-work> > (showIntAtBase 2 ((+48).chr) 99) ""
13:11:22 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
13:11:22 <lambdabot>    arising from the literal `4...
13:11:30 <olsner> :)
13:11:31 <EvanR-work> > (showIntAtBase 2 (char.(+48)) 99) ""
13:11:32 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:11:32 <lambdabot>         against inferred type...
13:11:36 <EvanR-work> ok
13:11:56 <dk> thanks, i guess i have to install Numeric as its not part of the default installation, right?
13:12:32 <Botje> > showIntAtBase 2 intToDigit 123 ""
13:12:33 <lambdabot>   "1111011"
13:12:37 <Botje> there we go :p
13:13:05 <EvanR-work> @src intToDigit
13:13:05 <lambdabot> Source not found. My pet ferret can type better than you!
13:13:30 <olsner> > let f = chr . (+48) in map f [0..9]
13:13:32 <lambdabot>   "0123456789"
13:13:53 <Botje> > map intToDigit [0..]
13:13:54 <lambdabot>   "0123456789abcdef*Exception: Char.intToDigit: not a digit 16
13:14:00 <EvanR-work> lame
13:14:16 <Botje> come to think of it, show would've worked just as well :P
13:14:33 <lucca> binary string.
13:14:35 <acemo> seriously who gave a bot a pet?
13:14:48 <EvanR-work> :t head . show 
13:14:49 <lambdabot> forall a. (Show a) => a -> Char
13:15:16 <EvanR-work> > showIntAtBase 2 (head . show) 123 ""
13:15:17 <lambdabot>   "1111011"
13:15:51 <dk> thanks guys and good night =)
13:17:10 <Botje> bye!
13:31:10 <nostrand> http://www.wimp.com/beardedman/
13:31:34 * hackagebot bindings-bfd 0.2.0 - Bindings for libbfd, a component of the GNU `binutils'  http://hackage.haskell.org/package/bindings-bfd-0.2.0 (MichaelNelson)
13:32:12 <JohnnyL> Is the $ in  -- replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8] -- required because function compositions can only handle one parameter at a time?
13:33:07 <EvanR-work> no, its because whitespace has higher precedence than .
13:33:18 <EvanR-work> $ is whitespace, but with lower precedence than .
13:34:03 <EvanR-work> you want to apply the f . g . h to something, not the h to something
13:34:35 <JohnnyL> EvanR-work: Pretty funky, but ok.
13:34:43 <EvanR-work> about one parameter at a time
13:35:05 <EvanR-work> (f a b . g a . h a b c) x is a counterexample
13:35:17 <EvanR-work> i.e. f a b . g a . h a b c $ x
13:35:21 <beginner1> can this "[(fst (viens vaardn !! i) , snd (divi vaardn  !! j))] ++ f1 vaardn  i j" be added to variable and than sorted?
13:36:42 <EvanCarroll> hrm, I know this is subjective, but what is the most complex concept implimented in the Prelude?
13:37:02 <EvanR-work> gregorian calendar?
13:37:51 <EvanCarroll> I was more referring to something like the chapter title. I guess I could just take out RWH and flip through the last 100 pages.
13:38:00 <EvanR-work> maybe the Read instances
13:38:02 <EvanCarroll> s/the/a/
13:38:11 <EvanCarroll> EvanR-work++ fair suggestion that time ;)
13:38:23 <Veinor> man, text.printf.printf is a horrible hack
13:38:31 <EvanR-work> id say the calendar is worse
13:38:35 <Veinor> calendar?
13:38:43 <EvanR-work> referring to EvanCarroll 
13:38:47 <Veinor> ah
13:38:53 <EvanR-work> yeah printf sucks
13:38:59 <revenantphx> :D
13:39:04 <revenantphx> So guys.
13:39:06 <Veinor> i don't know how I'd write a printf in haskell, though
13:39:12 <EvanR-work> just dont
13:39:15 <revenantphx> Next year I'll have finished my schools (crappy) CS program.
13:39:24 <Veinor> EvanR-work: sounds right
13:39:29 <revenantphx> So they've added an Advanced CS course which is basically a year long indpendent study.
13:39:36 <revenantphx> so I was thinking I should try to write a programming language :D
13:39:37 <Botje> holiday!
13:39:38 <revenantphx> Like a simple one.
13:39:46 <EvanCarroll> EvanR-work: do you not like it? or are you just saying it is complex?
13:39:54 <EvanR-work> the calendar?
13:40:03 <revenantphx> And i wanted to know, if people here have recommendations for summer reading before trying that.
13:40:06 <EvanR-work> no i dont like it, and its complex
13:40:08 <Botje> revenantphx: javascript 1.0 was designed and implemented in two weeks :)
13:40:08 <JohnnyL> EvanR-work: thanks
13:40:28 <EvanR-work> Botje: that explains that
13:40:38 <revenantphx> EvanR-work: lol yep.
13:40:50 <revenantphx> So anyhow, any summer reading? Can't do it now, but just wondering.
13:40:51 <Botje> revenantphx: you most definitely want to read SICP and EoPL
13:40:57 <revenantphx> SICP I'm reading at the moment :P
13:41:10 <revenantphx> I started half a year ago, but a lot of school work made me stop.
13:41:13 <EvanR-work> i like implementation of functional programming languages
13:41:21 <EvanR-work> and sicp
13:41:25 <revenantphx> SICP is nice.
13:41:27 <EvanCarroll> Botje: with SAMS you can learn the whole and master it in two.
13:41:40 <revenantphx> ?
13:41:40 <EvanCarroll> whole thing*
13:41:45 <Botje> if you want to implement a compiler, the dragon book and/or compiling with continuations
13:42:00 <nh910> is there a haskell function that returns the precedence of an infix function?
13:42:01 <revenantphx> I'm thinking of starting with an interpreted langauge.
13:42:10 <Botje> of course it all depends on what features you want to hack in
13:42:38 <EvanR-work> nh910: for information on precedence, use :info in ghci
13:43:10 <revenantphx> I want to start with interpreted so I only have to deal with lexer/parser.
13:43:22 <Botje> even then :)
13:43:34 <Botje> if you want to support continuations, for example your interpreter will look completely different
13:44:04 <revenantphx> continuations?
13:44:06 <EvanR-work> revenantphx: maybe start with the interpreter, an hand write ASTs into the input
13:44:14 <revenantphx> ASTs?
13:44:22 <EvanR-work> abstract syntax tree
13:44:22 <revenantphx> oh, right.
13:44:33 <EvanR-work> then once it works, make a parser to output a tree
13:44:36 <Botje> i don't know if SICP explains continuations
13:44:41 <revenantphx> by hand write ASt's into the input you mean Lisp?
13:44:42 <revenantphx> :P
13:44:56 <EvanR-work> define the tree as code
13:45:06 <revenantphx> This is a while's off.
13:45:12 <revenantphx> At the moment I have ant behavior to model!
13:45:30 <Botje> revenantphx: http://people.csail.mit.edu/jhbrown/scheme/continuationslides04.pdf
13:45:31 <EvanR-work> it would look like lisp, but you dont have to write a parser
13:45:41 <Botje> this must be a good tutorial on continuations because i bookmarked it
13:45:45 <revenantphx> EvanR-work: but thats half the fun :\
13:45:56 <EvanR-work> ... im just suggesting an order of operations
13:46:01 <EvanR-work> to maximize working ness
13:46:40 <EvanR-work> personally i would want a solid ast format to target before deciding on the other end of the parser
13:46:48 <EvanR-work> (the language)
13:47:00 <revenantphx> Well, thanks for the links.
13:47:08 <revenantphx> I'll be back about this September of next year!
13:47:16 <EvanR-work> solid foundation, then user interface
13:47:17 * Eduard_Munteanu installs mingw and Haskell Platform on Wine, hopefully that provides a pleasant experience.
13:47:29 <Eduard_Munteanu> There doesn't seem to be a nice way to get a crosscompiler for Haskell.
13:48:04 <Eduard_Munteanu> Though Wine seems like it.
13:48:39 <revenantphx> EvanR-work: modelling ants is surprisingly fun.
13:48:45 <sproingie> running mingw in wine seems like quite the circuitous route
13:48:53 <revenantphx> I have my simulation set up with a little workflow, so it feeds the data right into gnuplot.
13:49:33 <Eduard_Munteanu> sproingie: I suppose I could get crossdev in Gentoo to build myself a mingw crosscompiler, but I'd still need other libs I could easily install in Wine.
13:49:50 <Eduard_Munteanu> sproingie: do you have any suggestions on that?
13:50:32 <Eduard_Munteanu> Also I still need Wine for Haskell it seems :/
13:51:13 <kmc> real men run cygwin inside wine
13:51:29 <beginner1> can I somehow get this "func vaardn i j = 	[(fst (viens vaardn !! i) , snd (divi vaardn  !! j))] ++ f1 vaardn  i j" into somekind of variable, so i could go trough list and check for duplicated items?
13:51:39 <EvanR-work> im guess to get a cross compiler for a given platforms, you need to build your own compiler
13:52:02 <EvanR-work> with expert knowledge of flags and build procedures ;)
13:52:34 <beginner1> anyone?
13:52:53 <pumpkin> (-) :: Natural -> Natural -> Maybe Natural?
13:53:20 <revenantphx> :t (-)
13:53:21 <lambdabot> forall a. (Num a) => a -> a -> a
13:53:26 <EvanR-work> beginner1: what is the type of your expression? i dont recognize viens vaardn or divi
13:53:31 <kmc> pumpkin, or truncate to 0
13:53:43 <pumpkin> hm
13:54:00 <pumpkin> how about fromIntegral on negatives? also 0?
13:54:04 <Eduard_Munteanu> EvanR-work: I'd rather not, at least not with GHC. GCC seems more tractable, but I'd rather download a binary for that too.
13:54:56 <EvanR-work> often cross cant be maintained for every combination of two platforms (linux win32, win32 win32 64, linux 64 osx), but i dont know about ghc
13:55:07 <EvanCarroll> if haskell has polyvaridic functions, how come we have zipWith7 ?
13:55:22 <EvanR-work> haskell doesnt have variadic functions
13:55:34 <EvanCarroll> http://okmij.org/ftp/Haskell/polyvariadic.html#polyvar-fn
13:56:18 <EvanR-work> looks like a sophisticated abuse of extensions ;)
13:56:27 <Eduard_Munteanu> Yeah, crossdev here on Gentoo automates that, and makes a bit more sensible suggestions. I had success in the past building relatively recent GCC versions and toolchains.
13:56:36 <Eduard_Munteanu> Although only for linux-mingw32 cross.
13:57:05 <EvanCarroll> EvanR-work: Our solution requires no special extensions to Haskell and works with the existing Haskell compilers; it is tested on GHC 6.0.1 and 6.2.1. The overlapping instances extension is not necessary (albeit it is convenient).
13:57:20 <Eduard_Munteanu> It still requires fine tuning and it's easy to make it fail.
13:58:23 <EvanR-work> despite Text.Printf i wouldnt use variadic-like functions
13:58:40 <kmc> more overloading => fewer errors caught by type checker
13:59:11 <EvanCarroll> It seems like zipWidth would be a great place to have it =(
13:59:15 <EvanR-work> beginner1: maybe paste your full code definitions with the error youre getting
13:59:28 <EvanR-work> EvanCarroll: i have never used triples or zipWith3
13:59:51 <beginner1> http://paste.php.lv/f2c05785c77dfd997701efc4cac31736?lang=php    --full code
13:59:53 <EvanR-work> it seems a lot like heterogenous lists, just not useful
14:00:14 <beginner1> I need to remove duplicated items from output
14:01:21 <beginner1> input= test1 = ([("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")])      given output = [("a","c"),("a","d"),("e","c"),("e","d"),("x","c"),("x","d"),("x","a"),("x","c")]      I neeed [("a","c"),("a","d"),("e","c"),("e","d"),("x","d"),("x","a"),("x","c")]
14:01:26 <EvanR-work> > nub [(1,1),(1,2),(2,2),(1,1)]
14:01:28 <lambdabot>   [(1,1),(1,2),(2,2)]
14:01:32 <pumpkin> "↺"
14:01:37 <Eduard_Munteanu> I'm not sure variadic functions make sense in a language like Haskell.
14:02:06 <Eduard_Munteanu> They mostly benefit C and that sort, where you can't easily pack a list and send that.
14:02:08 <EvanCarroll> beginner1: you need to sort on the first character in the tuple, then the second
14:02:13 <EvanR-work> they dont make much sense in php thats for sure
14:02:17 <EvanR-work> doesnt stop people from using them ;)
14:02:53 <beginner1> that is my local code paste, sorry, but I have no Idea how..
14:02:55 <EvanR-work> Eduard_Munteanu: lisp uses this heavily though
14:03:03 <EvanR-work> and its very not C
14:03:12 <Eduard_Munteanu> Yeah, it isn't.
14:03:36 <engla> if you want variadic functions, you can add a parallel function with one parameter more. Like sort and sortBy
14:04:49 <beginner1> how can I use "nub" function on this line? "[(fst (viens vaardn !! i) , snd (divi vaardn  !! j))] ++ f1 vaardn  i j"
14:06:01 <EvanR-work> http://paste.php.lv/f2c05785c77dfd997701efc4cac31736?lang=php repeating beginner1's information ;)
14:07:01 <beginner1> If I would know how can I use "nub" function on this line? "[(fst (viens vaardn !! i) , snd (divi vaardn  !! j))] ++ f1 vaardn  i j" it would probably be it
14:07:08 <EvanR-work> you might want to start over and rethink your functions, nested if then else is not easy to understand
14:07:33 <beginner1> this is the best I could do :(
14:08:04 <EvanR-work> what kind of duplicates do you want to remove
14:08:16 <EvanR-work> (1,1) (1,1) duplicates?
14:08:32 <EvanR-work> or (1,x) (1,x) duplicates
14:08:33 <EvanR-work> or
14:08:35 <Eduard_Munteanu> :t nubBy
14:08:36 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
14:09:13 <EvanR-work> (1,3) (1,3) ?
14:09:17 <Eduard_Munteanu> Also it's sucky there's no default nub that requires a Ord
14:10:00 <EvanR-work> meh removing duplicates is a rare task ;)
14:10:04 <EvanR-work> better to just not have them
14:10:04 <beginner1> for example test2  = ([("a", "b"), ("a", "d"), ("a", "e")], [("b","c"), ("d","c")]), this programm returns [("a","c"),("a","c")]. The functions are working fine, but I need that identical items appear only once like this [("a","c")]
14:10:31 <EvanR-work> > nub [("a","c"),("a","c")]
14:10:32 <lambdabot>   [("a","c")]
14:10:53 <EvanR-work> realAnswer = nub originalAnswer
14:11:09 <Eduard_Munteanu> I'd cite set union and intersection as operations that could be defined in terms of some 'nub'.
14:11:15 <lispy1> how would you generate [("a","c"),("a","c")] from [("a", "b"), ("a", "d"), ("a", "e")], [("b","c"), ("d","c")] ?
14:11:30 <EvanR-work> Eduard_Munteanu: sounds like a bad union algorithm
14:11:37 <beginner1> yes, but my return function is [(fst (viens vaardn !! i) , snd (divi vaardn  !! j))] ++ [("the", "end")], how to use nub on this one?
14:11:37 <lispy1> It seems like, ("a", "c") doesn't appear at all in the input
14:12:04 <EvanR-work> beginner1: put ( ) around the whole thing and nub on the front
14:12:16 <EvanR-work> or do what i did
14:12:19 <EvanR-work> y = nub x
14:12:51 <beginner1> Not in scope: `nub'
14:13:02 <EvanR-work> import Data.List
14:13:11 <beginner1> line 11 in here http://paste.php.lv/f2c05785c77dfd997701efc4cac31736?lang=php
14:13:31 <Eduard_Munteanu> Yeah, perhaps the interface doesn't suit that, though the operation is somewhat similar.
14:13:58 <EvanR-work> use some kind of tree
14:14:15 <beginner1> no idea how..
14:14:23 <EvanR-work> i was referring to Eduard_Munteanu's union
14:14:29 <beginner1> oh
14:16:20 <ddarius> Holy crap.  My laptop went from China to here (Massachusetts) in two days.
14:16:44 <EvanCarroll> hrm, why doesn't this work sortBy (\(x:y) (x':y') -> undefined ) $ concat$ f ( [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")] )
14:16:45 <EvanR-work> they used that tunnel that goes through the earth, and simply dropped it to you
14:17:24 <EvanR-work> holy crap lots of $
14:19:28 <EvanCarroll> sortBy (\(x:y) (x':y') -> undefined ) $ concat $ let f (a,b) = a:b:[] in f ( [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")] )
14:19:35 <EvanCarroll> I'm trying to solve beginner1's problem
14:19:40 <EvanCarroll> in my head, that should compile.
14:19:43 <EvanCarroll> it however doesn't
14:20:53 <ddarius> EvanCarroll: Get a new head.
14:20:53 <EvanCarroll> EvanR-work: any ideas?
14:21:34 * ddarius is reminded of The Island of Dr. Brain
14:21:34 * FauxFaux attempts to convince himself that the brackets even match.
14:22:03 <EvanCarroll> ddarius: not really useful.
14:22:16 <EvanR-work> on a desert island with nothing but a coconut, you gotta compile your own haskell
14:22:30 <ddarius> Actually, I think it was the Castle of Dr. Brain.  It definitely wasn't the Island.
14:22:54 <ddarius> Yeah, definitely the Castle.
14:23:07 <EvanR-work> EvanCarroll: rather than f, use ++
14:23:25 <EvanR-work> beginner1's main problem is his stuff is too complex for what its trying to do
14:23:35 <EvanR-work> and i cant understand it while supposedly at work
14:23:37 <EvanCarroll> i'm more concerned about my own now.
14:23:41 <EvanCarroll> ++ doesn't work on tuples does it?
14:23:45 <EvanR-work> it works on lists
14:23:58 <EvanCarroll> oh you mean use ++ in f
14:24:01 <EvanCarroll> righto.
14:24:02 <Eduard_Munteanu> He should probably split it and clean it up.
14:24:12 <EvanCarroll> sortBy (\(x:y) (x':y') -> undefined ) $ concat $ let f (a,b) = a++b in f ( [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")] )
14:24:14 <EvanR-work> no i mean use ++ rather than f . (,)
14:24:23 <EvanR-work> (remove the tuple)
14:24:25 <EvanCarroll> still not getting it.
14:24:28 <Eduard_Munteanu> A two-line statement isn't really helpful or easy to understand.
14:24:42 <EvanCarroll> I can't, that's the input I'm given.
14:25:02 <EvanR-work> refuse the input
14:25:11 <EvanCarroll> If the mission is explicitly to sort two equal sized lists of character tuples then you...
14:25:19 <EvanCarroll> This is most probably a homework problem, and it isn't mine.
14:25:24 <dobblego> is there a parser for ~/.cabal/config file?
14:25:26 <EvanCarroll> I'm just wondering why my sortBy doesn't work
14:25:36 <EvanR-work> try a simpler test case
14:25:56 <EvanCarroll> I feel that you're lengthening my trip to figure out what I'm doing wrong
14:27:01 <EvanR-work> > sortBy (>) . concat . [(1,2),(3,4),(5,6)]
14:27:02 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
14:27:02 <lambdabot>         against inferr...
14:27:15 <EvanR-work> :t sortBy
14:27:16 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:27:49 <EvanR-work> > sortBy undefined [(1,2),(3,4),(5,6)]
14:27:49 <lambdabot>   *Exception: Prelude.undefined
14:27:55 <Eduard_Munteanu> > sortBy (compare) . concat . [(1,2),(3,4),(5,6)]
14:27:56 <lambdabot>   Couldn't match expected type `[[a]]'
14:27:56 <lambdabot>         against inferred type `(t, t1)'
14:28:02 <EvanR-work> > sortBy compare [(1,2),(3,4),(5,6)]
14:28:03 <lambdabot>   [(1,2),(3,4),(5,6)]
14:28:36 <Eduard_Munteanu> @src Ordering (,)
14:28:36 <lambdabot> Source not found. You type like i drive.
14:28:45 <EvanR-work> @src Ordering
14:28:45 <lambdabot> data Ordering = LT | EQ | GT
14:28:53 <Eduard_Munteanu> Gr..
14:28:56 <Eduard_Munteanu> @src Ord (,)
14:28:56 <lambdabot> Source not found. My pet ferret can type better than you!
14:29:05 <Eduard_Munteanu> I meant the instance.
14:29:05 <mauke> @src sort
14:29:05 <lambdabot> sort = sortBy compare
14:29:27 <Eduard_Munteanu> Yeah.
14:29:45 <Eduard_Munteanu> Usually it's useful to compose to compare on the right or something.
14:30:28 <EvanR-work> > sortBy (\(_,x) (_,y) -> compare x y) [(1,2),(3,4),(5,6)]
14:30:29 <lambdabot>   [(1,2),(3,4),(5,6)]
14:30:41 <mauke> comparing snd
14:30:57 <EvanR-work> > sortBy (comparing snd) [(1,2),(3,4),(5,6)]
14:30:58 <lambdabot>   [(1,2),(3,4),(5,6)]
14:31:10 <Eduard_Munteanu> Grr... I'm acquiring mathspeak. I thought only my eyes would turn blue or something after spending time on Haskell.
14:31:38 <revenantphx> If I have a system in which the state of timestep n+1 is always determined by the state of timestep n, I should be able to implement it without using ST, correct?
14:32:00 <EvanR-work> revenantphx: strictly speaking, thats iterate
14:32:04 <EvanR-work> :t iterate
14:32:05 <lambdabot> forall a. (a -> a) -> a -> [a]
14:32:09 <kmc> you don't really need ST for anything
14:32:09 <revenantphx> ?
14:32:18 <kmc> you can always model state by passing extra parameters around
14:32:19 <revenantphx> iterate?
14:32:22 <pumpkin> or just unfold
14:32:23 <pumpkin> r
14:32:28 <EvanR-work> :t unfoldr
14:32:29 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:32:30 <pumpkin> since it presumably stops at some point
14:32:32 <kmc> > iterate (*2) 1
14:32:33 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
14:32:35 <EvanR-work> well unfoldr is more complex
14:32:46 <EvanR-work> thats why i said 'strictly speaking' ;)
14:32:52 <Eduard_Munteanu> @hoogle unfoldr
14:32:53 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
14:32:53 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
14:32:53 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
14:33:02 <revenantphx> well, it'd be a bit more complex than iterate, but similar idea I suppose.
14:33:05 <revenantphx> Interesting.
14:33:09 <revenantphx> I'll definitely have to try this...
14:33:27 <conal> does anyone here use emacs mmm mode with haskell? i'm having some indenting trouble.
14:33:41 <Eduard_Munteanu> That looks like poor man's State.
14:33:54 <EvanR-work> State is more general
14:34:10 <EvanR-work> hm no
14:34:12 <proq> conal: that sounds like a mix the author never envisioned
14:34:22 <EvanR-work> State lets you compute an auxilliary value with the new state
14:34:32 <EvanR-work> @unmtl State
14:34:32 <lambdabot> err: `State' is not applied to enough arguments, giving `/\A B. A -> (B, A)'
14:34:33 <Eduard_Munteanu> EvanR-work: well you don't need to accumulate a list in State.
14:34:37 <revenantphx> I could probably write this ant behavior simulation as a tail-call recursive function >_>
14:34:46 <pumpkin> unfoldr sort of resembles State
14:34:59 <kmc> revenantphx, ST matters because sometimes code using real in-place updates is faster than code which passes states through pure functions
14:34:59 <EvanR-work> Eduard_Munteanu: you dont accumulate a list of iterate either, thats just the lazy result of iterating
14:35:07 <revenantphx> kmc: sure.
14:35:15 <kmc> revenantphx, it's not that it enables a new kind of program you otherwise couldn't write
14:35:21 <Eduard_Munteanu> EvanR-work: I mean the last [a] in :t unfoldr
14:35:29 <EvanR-work> unfoldr?
14:35:38 <Eduard_Munteanu> :t unfoldr
14:35:39 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:35:40 <EvanR-work> i would love to see him use iterate ;)
14:35:59 <revenantphx> ant behavior is working well so far
14:35:59 <revenantphx> http://cl.ly/6933e47713cdf75241ce
14:36:07 <beginner1> ok, can I connect all strings into one, like (a,b), (a,c) from list? like    (list1 !! i),(list2 !! j) and so on for both lists into one?
14:36:08 <JohnnyL> haskell doesn't handle the negative symbole (-) very well
14:36:13 <EvanR-work> haskell origami
14:36:19 <revenantphx> That's without any pheromone biasing...
14:36:24 <revenantphx> so 50/50 movement.
14:36:25 <EvanR-work> JohnnyL: thats the subtraction sign
14:36:35 <kmc> beginner1, example input/output?
14:36:44 <revenantphx> -1* not good enough?
14:36:49 <revenantphx> owai
14:36:59 <revenantphx> that'd be just as fail. >_>
14:37:04 <kmc> beginner1, by the way (xs !! n) is slow, it has to walk the n elements of xs one at a time.  lists are not a good data structure for random access
14:37:04 <Eduard_Munteanu> I wonder how it distinguishes between substraction and negation.
14:37:20 <EvanR-work> :t (-3)
14:37:20 <kmc> the haskell grammar makes a special case for (-3)
14:37:20 <lambdabot> forall a. (Num a) => a
14:37:29 <EvanR-work> :t (`subtract` 3)
14:37:30 <lambdabot> forall a. (Num a) => a -> a
14:37:37 <Eduard_Munteanu> > - log(5)
14:37:38 <lambdabot>   -1.6094379124341003
14:37:43 <Eduard_Munteanu> :t - log(5)
14:37:44 <lambdabot> forall a. (Floating a) => a
14:37:54 <JohnnyL> :t 2* -3
14:37:55 <lambdabot>     Precedence parsing error
14:37:55 <lambdabot>         cannot mix `*' [infixl 7] and prefix `-' [infixl 6] in the same infix expression
14:38:04 <beginner1> input list1=("a", "b"), ("a", "d"), ("a", "e")        list2=("b","c"), ("d","c"), output = ([("a", "b"), ("a", "d"), ("a", "e"), ("b","c"), ("d","c")])
14:38:05 <EvanR-work> > 2*(-3)
14:38:06 <JohnnyL> failz!
14:38:06 <lambdabot>   -6
14:38:20 <EvanR-work> - is a special case in haskell syntax
14:38:20 <Eduard_Munteanu> You'd write that in math too! ^
14:38:28 <beginner1> what is better than (xs !! n) for list ?
14:38:30 <Eduard_Munteanu> EvanR-work: hm I figured that would be the case.
14:38:37 <Eduard_Munteanu> Looks impossible otherwise.
14:38:38 <kmc> beginner1, lists are not a good data structure for random access
14:38:44 <kmc> but perhaps you shouldn't care, since you're just starting out
14:38:53 <beginner1> what is better?
14:39:11 <beginner1> but the connection problem how can i resolve it?
14:39:44 <Eduard_Munteanu> beginner1: you should treat lists as lists. If they were C lists, would you access a certain index? Using such design patterns is cumbersome.
14:39:48 <EvanR-work> > concat ["abc", "def", "ghi"]
14:39:49 <lambdabot>   "abcdefghi"
14:40:12 <revenantphx> Lists are made to be walked, not random accessed.
14:40:13 <lispy1> It's often best to think of haskell lists as streams
14:40:31 <revenantphx> I had to choose between array and list implementation for my ant simulation... for the paths they follow.
14:40:57 <revenantphx> I decided on lists (using some fun struct/union stuff for adhoc polymorphism <- this will cause rage) and it's working nicely. 
14:41:10 <revenantphx> Mainly because I only ever need to work with elements immediately next to the current one.
14:41:22 <Eduard_Munteanu> revenantphx: 1D or 2D?
14:41:25 <EvanR-work> revenantphx: meh i hate that C idiom
14:41:25 <revenantphx> The main disadvantage I'm seeing is that to test if an ant is on one path or the other I have to walk the entire list to the end.
14:41:32 <revenantphx> EvanR-work: which idiom?
14:41:40 <EvanR-work> the union trick
14:42:00 <revenantphx> heh
14:42:03 <EvanR-work> just a function pointer will do
14:42:14 <Eduard_Munteanu> revenantphx: I recently implemented a cellular automata, lists just wouldn't do there :/
14:42:19 <Eduard_Munteanu> in 2D.
14:42:27 <EvanR-work> neither would an array
14:42:29 <revenantphx> Eduard_Munteanu: mm 
14:42:30 <revenantphx> https://gist.github.com/669981
14:42:34 <revenantphx> this the trick you hate?
14:42:50 <revenantphx> Eduard_Munteanu: You can use linked nodes for cellular automata...
14:42:53 <Eduard_Munteanu> EvanR-work: actually it was an array, but an array comonad.
14:43:24 <Eduard_Munteanu> Linked nodes?
14:43:25 <revenantphx> As in, each node is linked to all others next to it.
14:43:36 <EvanR-work> you need a sophisticated structure to support unlimited area
14:43:51 <Eduard_Munteanu> I don't support an unlimited area.
14:43:57 <EvanR-work> ah then thats great
14:43:58 <Eduard_Munteanu> It was a design decision.
14:44:00 <revenantphx> Unlimited area is easy with linked nodes.
14:44:12 <revenantphx> If the pointer to the node is null, then create the node.
14:44:14 <EvanR-work> easy but not necessarily efficient
14:44:18 <revenantphx> (it'll be created as it expands)
14:44:28 <revenantphx> struct node{ node up; node left; node right; node top;};
14:44:34 <revenantphx> (for cellular automata)
14:44:39 <revenantphx> with some state kept.
14:44:50 <EvanR-work> after the area expands and conways stuff mostly dies, it will be updating large zones for nothing
14:45:10 <revenantphx> I wrote up the game of life with looping edges once, that was neat. 
14:45:11 <EvanR-work> a lot of other rule sets have dead boring stuff which could be optimized
14:45:16 <revenantphx> very easy to do with linked nodes.
14:45:31 <Eduard_Munteanu> Ah, no I settled on implementing something like heat propagation. It really made sense having an impenetrable barrier as border :)
14:46:17 <Eduard_Munteanu> I also really wanted it to work in a comonadic setting.
14:46:43 <EvanR-work> whats comonad
14:46:51 <EvanR-work> @src Comonad
14:46:51 <lambdabot> Source not found. Take a stress pill and think things over.
14:47:00 <Eduard_Munteanu> EvanR-work: I just defined it myself.
14:47:04 <Eduard_Munteanu> No category-extras.
14:47:16 <EvanR-work> as what
14:47:43 <Eduard_Munteanu> EvanR-work: oh. It's just the Monad where the natural transformation are reversed
14:47:46 <Eduard_Munteanu> arrows flipped.
14:47:50 <Eduard_Munteanu> So you have:
14:47:57 <Eduard_Munteanu> coreturn :: w a -> a
14:48:06 <Eduard_Munteanu> cojoin :: w a -> w (w a)
14:48:21 <EvanR-work> =<< ?
14:48:37 <Eduard_Munteanu> EvanR-work: =>>
14:48:45 <Eduard_Munteanu> EvanR-work: I defined it in terms of cojoin and fmap
14:49:09 <EvanR-work> (=>>) :: m a -> (m a -> b) -> m b ?
14:49:31 <Eduard_Munteanu> I inspired myself from this, but migrated to an array... http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
14:49:48 <Eduard_Munteanu> and used a more CT-like definition by providing cojoin instead of =>>
14:50:05 <Eduard_Munteanu> EvanR-work: yeah, though we use 'w' for comonads usually.
14:50:10 <EvanR-work> lol
14:50:22 <Nopik> hi all
14:50:26 <EvanR-work> so comonad makes sense and is usesful?
14:51:12 <Eduard_Munteanu> EvanR-work: the basic idea here is cojoin turns your grid into a grid of grids, cloning the array and just moving a "center" pointer.
14:51:14 <Nopik> i have some simple gtk/cairo program which creates drawable canvas, and draws on it.. now i want to create some fancy rendering functions and compose them.. any idea how to compose two Render () into single Render ()?
14:51:35 <Eduard_Munteanu> EvanR-work: that provides context for transforming the element in focus.
14:51:51 <Eduard_Munteanu> It makes sense to think of zippers like sigfpe also suggests.
14:51:52 <EvanR-work> interesting
14:52:38 <revenantphx> So, I have a conundrum here.
14:52:44 <shapr> revenantphx: tell us!
14:52:46 <revenantphx> Or rather, a question of how to implement something.
14:52:57 <revenantphx> (it's in C, but thinking in a general algorithmic sense)
14:53:09 <revenantphx> So I have these two paths of linked nodes radiating outward from a center node.
14:53:11 <EvanR-work> general algorithms in C
14:53:12 <EvanR-work> concept
14:53:23 <Nopik> like, i have some "data Node = Op String OpF Node Node | Number Integer" then I instantiated Show to return fancy String's for me, so it is like myShow (Op _ _ a b) = (show a) ++ (show b)
14:53:26 <revenantphx> Each one has a certain amount of pheromone, which biases ant movement.
14:53:32 <Nopik> now i'd like to have something like this, but with Render(), not String
14:53:42 <revenantphx> Now, this pheromone amount needs to decay.
14:53:47 <revenantphx> So the question is:
14:53:52 <Nopik> namely to have "render :: Node -> Render()"
14:54:01 <revenantphx> Do I, at each timestep, run through every node and decay it
14:54:02 <revenantphx> or
14:54:08 <Eduard_Munteanu> EvanR-work: the evaluation function then simply looks like fn :: Grid <array> <pointer> -> your_array_element_type. You simply apply the rule by doing automata =>> fn.
14:54:12 <Nopik> and i'm not sure how to implement ++ for Render() :D
14:54:22 <revenantphx> Do I, each time an ant moves onto a new node, keep track of how many timesteps it has been since it last updated, and apply adequate decay.
14:54:27 <Eduard_Munteanu> EvanR-work: and it applies the transformation everywhere in the grid.
14:54:31 <Nopik> any idea?
14:54:33 <revenantphx> Option b is basically being lazy about updating it.
14:54:55 <revenantphx> There will usually be 1 or 2 ants on every single tile at a given moment though, so I'm not sure how much it would help.
14:54:56 <revenantphx> (if at all)
14:54:57 <EvanR-work> you cant implement ++ because its not in a class
14:55:23 <EvanR-work> :t (++)
14:55:24 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:55:38 <EvanR-work> lambdabot it good for validation
14:55:48 <Eduard_Munteanu> @type (++)
14:55:49 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:55:55 <Nopik> EvanR-work: 
14:55:56 <Eduard_Munteanu> Both are Caleskell?
14:56:07 <Eduard_Munteanu> Grrr...
14:56:14 <EvanR-work> lol
14:56:23 <Nopik> EvanR-work: of course i'm not trying to reimplement ++ directly.. i just want to compose two Render(), no idea how to do so
14:56:32 <mauke> what do you mean by "both"?
14:56:35 <revenantphx> so ah
14:56:37 <revenantphx> any insight?
14:56:39 <mauke> ":t" is @type
14:56:45 <EvanR-work> Nopik: do you mean Render ()
14:56:47 <Eduard_Munteanu> Nopik: looks like that's a monadic value and you're supposed to chain it using bind.
14:56:52 <EvanR-work> Render :: * -> * ?
14:57:10 <mauke> :t (Prelude.++)
14:57:10 <lambdabot> forall a. [a] -> [a] -> [a]
14:57:23 <Nopik> Eduard_Munteanu: yes, it is monadic.. how to chain it? (sorry, i'm newbie)
14:57:32 <EvanR-work> :t (>>)
14:57:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
14:57:45 <Eduard_Munteanu> Nopik: you'd have function like those in IO (), but instead it's Render ()
14:57:55 <Eduard_Munteanu> Nopik: just use it like IO
14:58:10 <Eduard_Munteanu> Nopik: e.g. use do and apply multiple operations.
14:58:25 <Eduard_Munteanu> Theoretical example:
14:58:29 <Nopik> render :: Node -> Render()       render (MyNode left right) = (render left) >> (render right)?
14:58:33 * revenantphx is ignored.
14:58:34 <Eduard_Munteanu> foo :: Blah -> Render ()
14:58:42 <Eduard_Munteanu> foo bar = do
14:58:53 <Eduard_Munteanu>   x <- renderThisBar bar
14:59:09 <Eduard_Munteanu>   y <- doSomethingElseRenderwise
14:59:14 <Eduard_Munteanu>   renderEverything
14:59:26 <Eduard_Munteanu> (disclaimer: not any actual GTK function in there)
14:59:34 <EvanR-work> revenantphx: did you think about iterate?
14:59:34 <EvanCarroll> EvanR-work: did you find out why it didn't work?
14:59:39 <Eduard_Munteanu> I could look if you have any specific question.
14:59:48 <EvanCarroll> it seems as if your sortBy which hsa the same format works.
14:59:58 <EvanCarroll> sortBy (\(x:y) (x':y') -> undefined ) $ concat $ let f (a,b) = a++b in f ( [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")] )
15:00:02 <EvanR-work> EvanCarroll: you must have had a random concat in there for no reason
15:00:14 <Nopik> Eduard_Munteanu: what would be a type of 'renderThisBar'? renderThisBar :: Blah -> Render() ? that would set x = (), right?
15:00:24 <EvanR-work> EvanCarroll: did you ever post a compiler error?
15:00:38 <EvanCarroll> oh interesting
15:00:56 <Eduard_Munteanu> Nopik: yeah, it's just an example. For example, I remember using a -> Render () function to do my Cairo drawing
15:01:23 <Eduard_Munteanu> IIRC I used some withDrawable, or something like that, I don't remember exactly.
15:01:25 <Nopik> Eduard_Munteanu: yeah, i figured it out... but i'm not understanding what type should be 'renderEverything' here?
15:01:34 <Nopik> yeah, it is renderWithDrawable
15:01:35 <Eduard_Munteanu> I could look it up if you have a really specific question.
15:02:12 <Nopik> ok, let me use some code on hpaste ;)
15:02:37 <Eduard_Munteanu> Nopik: you just need to imagine withDrawable calls that and that does the drawing, hiding all details and state inside that Render.
15:03:16 <revenantphx> EvanR-work: this is in C
15:03:17 <revenantphx> >_>
15:03:18 <EvanR-work> or think of them as not 'calls'
15:03:25 <revenantphx> I'm asking in a general sense, not for haskell.
15:03:30 <Nopik> Eduard_Munteanu: yeah, i already realized that, just not sure how to return 2 chained Render() from my function, so renderWithDrawable will render them one after another
15:03:49 <EvanR-work> revenantphx: well running through cells one by one and updating them isnt very general, thats what youd do in C
15:04:00 <revenantphx> It's one thing I *could* do in C.
15:04:05 <EvanR-work> yes
15:04:07 <EvanR-work> so its not in general
15:04:08 <revenantphx> I listed the two best choices I came up with.
15:04:21 <revenantphx> "In general for imperative languages"
15:04:24 <revenantphx> happy?
15:04:27 <Eduard_Munteanu> Nopik: you don't need to return anything.
15:04:31 <EvanR-work> if each cells next state is a function of just that cells previous state, then the whole board is basically being mapped
15:04:43 <EvanR-work> and the evolution can be iterated
15:04:58 <Eduard_Munteanu> Nopik: you just call the functions that do drawing inside a 'do' block or chain them with '>>' (or >>= where needed)
15:05:02 <EvanR-work> if its a function of adjacent cells too, then its not that simple but just a different model
15:05:11 <revenantphx> Each cells state is a function of its previous state, and the ants movement (which is stochastic)
15:05:18 <revenantphx> the ants deposit pheromones based on another sytsem
15:05:19 <Eduard_Munteanu> Nopik: paste some of that code, maybe it helps.
15:05:24 <EvanR-work> revenantphx: all of the ants movements?
15:05:27 <revenantphx> yep.
15:05:29 <EvanR-work> or just the ants on that cell
15:05:33 <EvanCarroll> EvanR-work: didn't work =(
15:05:34 <EvanCarroll> sortBy (\(x:y) (x':y') -> let { a = x `compare` x'; b = y `compare` y' } in if a == EQ then b else a ) $ let f (a,b) = a++b in f ( [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")] )
15:05:35 <revenantphx> just the ants that end on that cell.
15:05:56 <EvanR-work> EvanCarroll: it keeps getting more complex, that cant help
15:06:00 <revenantphx> the issue is that right now, at every timestep, I iterate through all ants, and all cells.
15:06:08 <EvanR-work> EvanCarroll: paste type errors
15:06:27 <EvanR-work> revenantphx: ok so dont iterate through all ants, just the ants on that cell
15:06:32 <EvanCarroll> EvanR-work: sortBy (\(x:y) (x':y') -> undefined ) $ let f (a,b) = a++b in f ( [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")] )
15:06:37 <EvanCarroll>  Couldn't match expected type `[t]' against inferred type `([Char], [Char])'
15:06:39 <revenantphx> I need to iterate through every ant on every cell.
15:06:45 <EvanR-work> EvanCarroll: ah
15:06:53 <revenantphx> Eh, I think I worked something out.
15:06:56 <EvanR-work> EvanCarroll: where
15:07:08 <EvanCarroll>     In the expression: ("a", "b")
15:07:09 <EvanCarroll>     In the expression: [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")]
15:07:09 <EvanCarroll>     In the first argument of `f', namely
15:07:09 <EvanCarroll>         `([("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], 
15:07:09 <EvanCarroll>           [("b", "c"), ("b", "d"), ("g", "a"), ("g", "c")])'
15:07:21 <JohnnyL> wow, I better write all this down.
15:07:29 <EvanCarroll> if sortby takes a [t] why can't t be unified with (a,a)
15:07:45 <EvanR-work> well (a,b) is never a [c]
15:07:52 <mauke> it's trying to unify [t] with (a,b)
15:07:54 <EvanR-work> (,) vs :
15:07:57 <Nopik> http://hpaste.org/41327/composing_render
15:08:12 * Eduard_Munteanu looks
15:08:23 <EvanR-work> try a (\(a,b) -> a++b)
15:08:45 <mauke> > let f (a,b) = a++b in f ( [("a", "b"), ("e", "b"), ("x", "b"), ("x", "g")], [("b", "c"),("b", "d"), ("g", "a"), ("g", "c")] )
15:08:46 <lambdabot>   [("a","b"),("e","b"),("x","b"),("x","g"),("b","c"),("b","d"),("g","a"),("g"...
15:08:47 <EvanCarroll> EvanR-work: not follow. I'm not sure why that doesn't work, both [1,2,3], and [(1,2),(1,2)] can be be used in functions of type [a] right?
15:09:05 <mauke> LOOK AT MY TINY GODDAMN FEET
15:09:12 <EvanR-work> yeah but not ("a","b") 
15:09:14 <mauke> your comparison function is whack
15:09:43 <EvanCarroll> EvanR-work: why?
15:09:48 <EvanR-work> nevermind
15:09:57 <EvanR-work> comparison function
15:10:29 <Eduard_Munteanu> Nopik: looks like it should simply be render l >> render r
15:10:34 <EvanCarroll> thanks, i got it.
15:11:32 <Eduard_Munteanu> Nopik: does that work for you?
15:12:11 <Nopik> Eduard_Munteanu: great.. let me see (it will take a while, as i've just rewritten few functions :D)
15:13:00 <Eduard_Munteanu> You might want to actually do something with the other fields in Op, yeah.
15:14:10 * hackagebot HTTP 4000.1.0 - A library for client-side HTTP  http://hackage.haskell.org/package/HTTP-4000.1.0 (GaneshSittampalam)
15:15:10 * EvanR-work sees HTTP and imagines a haskell browser
15:15:49 <EvanR-work> no more screwing around with fail fox and google spychrome
15:16:02 <pumpkin> dcoutts_: cabal test in HEAD seems to not have the detailed-1.0 type included. Is there somewhere I can get that, or is only exitcode-stdio-1.0 supported right now?
15:17:30 <EvanCarroll> http://stackoverflow.com/questions/4139711/type-unification-question-with-lists-of-tuples-of-strings
15:18:02 <EvanR-work> are you trying to use ++ with tuples ?
15:18:11 <EvanR-work> it wont work
15:18:22 <Nopik> Eduard_Munteanu: seems working somehow, thanks ;) now my actions are not final yet, so i'm having weird results, but i see that it compiled and several actions actually chained, in some way ;)
15:19:10 <chadz> how do you all manage all yoru packages, version?
15:19:12 <engla> how can i describe what happens here with simpler functions?  sequence [[1,2,3], [3,2,3]]
15:19:19 <EvanR-work> EvanCarroll: you didnt even put the error message 
15:19:21 <chadz> ie, do you use cabal-install, distro, etc?
15:19:42 <Nopik> what if it would be Render Int instead of Render() how to chain them and yet get their results? some >>= ?
15:19:55 <mauke> x >> y >> return 42
15:19:56 <EvanCarroll> EvanR-work: added
15:20:21 <EvanR-work> > sortBy compare [("a","b"),("b","c"),("3","6")]
15:20:22 <lambdabot>   [("3","6"),("a","b"),("b","c")]
15:20:42 <EvanR-work> > sortBy (comparing snd) [("a","b"),("b","c"),("3","6")]
15:20:43 <lambdabot>   [("3","6"),("a","b"),("b","c")]
15:20:57 <jmcarthur> EvanCarroll: "\(x:y) (x':y') ->" it looks like you are trying to pattern match two lists instead of two tuples
15:21:20 <EvanR-work> > sortBy (\(_:_) (_:_) -> undefined) [("a","b"),("b","c"),("3","6")]
15:21:21 <lambdabot>   Couldn't match expected type `[t]'
15:21:21 <lambdabot>         against inferred type `([GHC.Typ...
15:21:25 <EvanR-work> wrong
15:21:31 <EvanR-work> > sortBy (\(_,_) (_,_) -> undefined) [("a","b"),("b","c"),("3","6")]
15:21:32 <Eduard_Munteanu> Nopik: hm, maybe.
15:21:32 <lambdabot>   *Exception: Prelude.undefined
15:21:34 <EvanR-work> right
15:22:10 <EvanR-work> guess ill post this answer on stack overflow
15:22:19 <EvanCarroll> jesus
15:22:21 <EvanCarroll> that's it.
15:22:23 * Nopik slams forehead... 'do (render a) >> (render b)' is just  do render a; render b, right?
15:22:28 <Eduard_Munteanu> Nopik: you'd then want to bind them like 'x <- render l' and so on, and check the results.
15:22:42 <EvanCarroll> why all this talk about my sort function wack, and ++ and other stuff,.
15:22:42 <EvanCarroll> I' just confused : and , =(
15:22:53 <EvanR-work> EvanCarroll: your comparison was indeed whack
15:23:13 <EvanCarroll> why? it works [("a","b"),("b","c"),("b","d"),("e","b"),("g","a"),("g","c"),("x","b"),("x","g")]
15:23:15 <EvanR-work> i thought you had a different problem before i looked at the post
15:23:22 <Nopik> ie. do chains actions automatically.. yeah, i was just looking for complex solution to simple problem :)
15:23:25 <Eduard_Munteanu> Nopik: still, I suppose gtkWithDrawable wants a Render (), so make sure you discard that Int at some point.
15:23:26 <mauke> EvanCarroll: that's a list, not a function
15:23:26 <EvanCarroll> sortBy (\(x,y) (x',y') -> let { a = x `compare` x'; b = y `compare` y' } in if a == EQ then b else a )
15:23:30 <EvanR-work> EvanCarroll: the one with : doesnt
15:23:38 <Nopik> Eduard_Munteanu: yes, of course
15:23:52 <EvanCarroll> EvanR-work: right, but it doesn't work because of a haskell error I had with , and :
15:23:57 <EvanCarroll> that hardly deserves to be called "wack"
15:23:57 <EvanR-work> EvanCarroll: right
15:24:05 <adnap> Is it true that if I'm using matFromLists in Data.Vec, I cannot specify the size of the matrix dynamically?  Can I not specify arbitrarily large matrices?
15:24:10 <EvanR-work> well you tried to make a comparison function on tuples and made one for lists
15:24:19 <aavogt> Nopik: there are many different ways to write things
15:24:24 <Eduard_Munteanu> Nopik: yeah, it's quite imperative in IO-like monads, like Render.
15:24:49 <EvanCarroll> =( anyway, I got it now. I just think it could have been easier if an hour ago someone just explained that I was writing a compairison function for lists, instead of tuples. I hardly ever use tuples =(
15:24:57 <EvanR-work> i didnt notice
15:25:06 <Eduard_Munteanu> Nopik: you can simply drop 'do' there in that '>>' stuff.
15:25:11 <EvanR-work> i *am* at work ;)
15:25:15 <EvanCarroll> !!! ah ha,stumped you too then. At least I have some gratification
15:25:17 <mauke> I didn't really pay attention but I thought it was obvious
15:25:25 <mauke> I had no idea you were still talking about that
15:25:25 <Nopik> Eduard_Munteanu: yeah, now i know this ;) though i have more actions to chain there
15:26:07 <EvanCarroll> It would be nice if GHC could make that error clearer
15:26:26 <EvanCarroll> That's amazingly obtuse for a me. Maybe I just don't know how to read them well enough
15:26:40 <EvanR-work> well its inferring, so it can tell you one place where the types dont match. but it cant tell you which definition you wrote had the 'right' type
15:26:49 <EvanR-work> in this case it was the function, but ghc thought it was your list
15:27:22 <EvanCarroll> Why not error on both places then.
15:27:24 <EvanR-work> in this case the function had the wrong type, but ghc didnt know that
15:27:24 <mauke> > sortBy (\(_:_) (_:_) -> undefined) [["a","b"],["b","c"],["3","6"]]
15:27:25 <lambdabot>   *Exception: Prelude.undefined
15:27:40 <EvanR-work> EvanCarroll: well theres a combinatorially exploding number of places it could report
15:27:47 <EvanCarroll> Warning: List in function wanted, detected tuples. Warning: List of tuples present, sortBy wants list of functions
15:27:50 <mauke> heh, "both"
15:28:04 <mauke> EvanCarroll: maybe 'sortBy' was supposed to be something completely different
15:28:25 <Eduard_Munteanu> adnap: what do you mean by specifying the size dynamically?
15:28:27 <mauke> or you wanted to pass 'sortBy' and the other 2 arguments to another function
15:28:42 <EvanCarroll> This is more of a just a bitch-and-moan at this point. I just don't like that I can't yet read the error messages well enough to catch a trivial problem like that.
15:28:44 <Eduard_Munteanu> adnap: the size is given by the parameter (supposing it's well-formed)
15:28:46 <EvanCarroll> and, I did read it
15:29:11 <EvanR-work> EvanCarroll: in cases like these, its good to expand the definitions into their own names, and add your own type signatures and see where ghc disagrees with you
15:29:23 <EvanCarroll> I agree fully.
15:29:24 <adnap> Eduard_Munteanu: I mean, let's say I have a function that takes an int, n, as a paramaeter, and I want to generate an nxn matrix.
15:29:35 <EvanCarroll> sound advise. Haskell one liners are for people more experienced than myself.
15:30:12 <Eduard_Munteanu> > replicate 3 $ replicate 3 0
15:30:13 <lambdabot>   [[0,0,0],[0,0,0],[0,0,0]]
15:30:21 <Eduard_Munteanu> adnap: ^
15:30:27 <adnap> ...
15:30:54 <adnap> I can already create my [[a]] type.  I just can't get it to become a Mat type!
15:31:13 <engla> adnap: Mat [[1,2,3]] ?
15:31:35 <adnap> Is there a data constructor like that??
15:31:43 <dcoutts__> pumpkin: cabal HEAD has test type detailed-0.9
15:31:46 <Nopik> ok, it works as i wanted, thanks a lot ;)
15:32:29 <engla> adnap: what do you mean by Mat type then?
15:32:39 <pumpkin> dcoutts__: hmm, I checked it out and built it a couple of days ago, and it tells me "Warning: 'detailed-0.9' is not a supported test suite version. The known test
15:32:39 <pumpkin> suite types are: exitcode-stdio-1.0"
15:32:40 <adnap> One specified in Data.Vec!
15:32:47 <pumpkin> I'll grab a newer one
15:32:52 <pumpkin> oh actually
15:32:56 * pumpkin kicks self
15:32:57 <dcoutts__> pumpkin: are you using Cabal-1.10 or HEAD?
15:33:10 <pumpkin> I'm using cabal 1.10 and cabal-install HEAD
15:33:10 <Eduard_Munteanu> adnap: grr... it looks like you're right, Vec takes type-level naturals as sizes
15:33:11 <pumpkin> nevermind :)
15:33:12 <pumpkin> sorry
15:33:31 <engla> Data.Vec? What is that?
15:33:48 <dcoutts__> pumpkin: right ok, so we decided the detailed test type is not ready for a release, so it's not in the branch and at 0.9 in HEAD
15:33:58 <pumpkin> I see
15:33:59 <dcoutts__> pumpkin: what're you working on ooi?
15:34:08 <Eduard_Munteanu> It might be possibly to reify a runtime value into a type like that, but you need an existential I think.
15:34:13 <adnap> Eduard_Munteanu: Well, you can always generate a natural.
15:34:38 <mauke> Eduard_Munteanu: no, you can use a rank-2 function instead
15:34:43 <mauke> continuation style basically
15:34:50 <Eduard_Munteanu> mauke: yes, I mean rank-2
15:35:02 <Eduard_Munteanu> But that stuff won't be able to escape it.
15:35:11 <Eduard_Munteanu> Basically yeah, you need to do CPS.
15:35:15 <pumpkin> dcoutts__: two projects in parallel, really, but both need tests and I wanted to play with the new cabal test stuff. One is a gmp binding for naturals (plus a simple lazy layer on top of that), and the other is a decoder for ARM machine code
15:35:31 <adnap> Eduard_Munteanu: Oh wait, maybe you can't.  I thought there was a successor function, but it's actually a type.
15:36:05 <adnap> Is there a good haskell library for solving arbitrarily large systems of equations?
15:36:15 <pumpkin> adnap: hmatrix, maybe?
15:36:23 <bremner> what kind of equations, linear?
15:36:24 <pumpkin> if linear
15:36:29 <bremner> jinx
15:36:34 <pumpkin> :)
15:36:59 <mauke> I used Numeric.LinearAlgebra.LAPACK
15:37:05 <adnap> pumpkin: Thanks
15:37:09 <aavogt> hmatrix even has bindings for some numerical methods, which can do nonlinear ones too
15:37:10 <mauke> also Data.Packed.Matrix
15:37:49 <dcoutts__> pumpkin: cool
15:38:06 <adnap> Man, there is so much duplication on Hackage.  Why can't we have one nice linear algebra library/
15:38:20 <bos> adnap: step up and write it :-)
15:38:22 <dcoutts__> pumpkin: well make sure you report any issues with the new test feature, you're amongst the first to try it out
15:38:34 <pumpkin> dcoutts__: the gmp thing is currently just a variation on the integer-gmp package, but builds outside of GHC :) but once I have benchmarks I'm going to tweak the bindings and see which ones it pays to use the specialized natural functions
15:38:42 <pumpkin> yeah, will do
15:38:44 <adnap> bos: XD
15:38:50 <bos> amazingly, when you sit down and write something that's much better than the competition, people will stop writing and using the competition.
15:38:59 <adnap> bos: I just want to mooch!
15:39:46 <luite> amazingly, that won't stop people from using the competition ;)
15:40:10 <aavogt> bos: and that doesn't seem to address that there are (too many?) duplicated efforts
15:40:41 <bos> that's an issue people need to solve for themselves.
15:41:06 <bos> i write a lot of code, and publicise it, and people use it. so that technique works.
15:41:14 <mauke> this is what I used the equation solver for: http://mauke.ath.cx/exe/jslinenc?string+obfuscation
15:41:33 <adnap> Oh, LAPACK looks pretty sweet.  Does anyone use these Matrix and Vector types to implement functions like dot, norm, scale, translate, rotate, etc.?
15:41:46 <conal> phew! fixed (avoided) the problematic interaction between mmm and literate haskell indentation
15:41:58 <adnap> I know Data.Vec.LinAlg has a few of these things, but it uses Mat and Vec in Data.Vec.
15:42:42 <adnap> Data.Vec has a really sexy way of constructing vectors though.
15:42:59 <Eduard_Munteanu> Somebody also recommended me REPA for numerical computations, but it looks too general.
15:43:31 <Eduard_Munteanu> @hoogle repa
15:43:32 <lambdabot> Data.Typeable typeRepArgs :: TypeRep -> [TypeRep]
15:43:35 <Eduard_Munteanu> Uh.
15:43:39 <pumpkin> @hackage repa
15:43:39 <lambdabot> http://hackage.haskell.org/package/repa
15:45:06 <jmcarthur> repa is (or at least will be) really awesome
15:45:21 <roconnor> I've been meaning to play with repa
15:46:06 <jmcarthur> it's hard to make well-known algorithms fit it sometimes, but i attribute that to the fact that most well-known algorithms are not typically described from such a high level
15:47:10 <jmcarthur> repa is, at the same time, painfully low level
15:47:29 <jmcarthur> but i think that's because it makes it so easy to think about low level details like cache coherency
15:47:34 <pumpkin> I started modeling it in agda but then got distracted with other things
15:47:42 <jmcarthur> not so much because the interface is particularly low level
15:48:11 <jmcarthur> the forcing and deepSeqArray stuff is unfortunate though
15:50:05 <Eduard_Munteanu> jmcarthur: they look like regular but massively-parallel arrays to me, aren't they? I mean repa.
15:50:34 <pumpkin> that's what they are :)
15:50:35 <Eduard_Munteanu> At this point I'd appreciate elegance and easiness of use.
15:50:41 <pumpkin> regular in the sense that they're rectangular
15:50:49 <pumpkin> in however many dimensions you care about
15:51:03 <pumpkin> (unlike general DPH parallel arrays)
15:51:07 <Eduard_Munteanu> pumpkin: heh, I meant regular as in nothing special about them :)
15:51:17 <pumpkin> well, they have arbitrary dimensions
15:51:50 <pumpkin> in a much more sophisticated manner than just the (,..) instances of Ix
15:52:06 <Eduard_Munteanu> So it's a really fast/concurrent Data.Array, but I'm rather interested in e.g. traversal features that make writing functional matrix algos easier.
15:52:27 <Eduard_Munteanu> (err, rather doing that functionally, I doubt there are many functionally-concieved matrix algos)
15:52:35 <jmcarthur> Eduard_Munteanu: that's exactly repa
15:52:47 <jmcarthur> Eduard_Munteanu: folds and zip and such
15:52:57 <jmcarthur> *and zips and such
15:53:19 <Nikla> can some body explain why B-reduction of (\x x .x ) a => (\x.x)
15:53:38 <Eduard_Munteanu> jmcarthur: I remember looking at hmatrix, and you could split that into block matrices, traverse diagonals do lotsa other stuff than basic folds.
15:53:39 <jmcarthur> Nikla: i don't understand what you mean by (\x x .x )
15:53:45 <pumpkin> Eduard_Munteanu: if you just want nice fast arrays without the parallelism or multidimensional aspects of repa, use vector
15:53:57 <jmcarthur> Nikla: do you mean that the second x binding overrides the first?
15:54:03 <Eduard_Munteanu> Thanks, I'll have a look at that too.
15:54:10 <Nikla> its a lambda expression
15:54:19 <Nikla> ya
15:54:34 <jmcarthur> Nikla: okay, so then you mean it's the same as (\x y . y)?
15:54:37 <Nikla> \x.\x.x
15:54:41 <jmcarthur> okay
15:55:05 <dschoepe> Nikla: then substituting the outer x for a doesn't alter the inner term, since that x doesn't appear in it
15:55:27 <Eduard_Munteanu> Does any lambda calculus actually allow multiple params?
15:55:29 <dschoepe> so you get just \x.x since the first lambda is gone because you applied it to a
15:55:42 <jmcarthur> Nikla: it's a troublesome part of the lambda calculus that the same name might not represent the same variable in all cases
15:55:44 <pumpkin> Eduard_Munteanu: what would be the point? 
15:55:58 <Eduard_Munteanu> No point, but I just saw that \x y . y  :)
15:56:06 <pumpkin> oh, people use that shorthand all the time
15:56:15 <sproingie> it's a notational shorthand
15:56:21 <Eduard_Munteanu> Ah, it makes sense then.
15:56:38 <jmcarthur> Eduard_Munteanu: \xy.z == \x.\y.z
15:56:41 <Nikla> ok
15:56:48 <Eduard_Munteanu> Yeah, makes sense.
15:56:51 <ddarius> There are definitely lambda calculi that have explicit multiple parameter lambdas.  There are a whole lot of lambda calculi.
15:57:05 <ddarius> Possibly thousands.
15:57:34 <sproingie> what about ones in actual use
15:57:45 <sproingie> dozens perhaps?
15:57:52 <JohnnyL> how would one built a 'concat' from an unknown depth of nested lists?
15:58:15 <jmcarthur> JohnnyL: you mean like a tree?
15:58:18 <pumpkin> JohnnyL: one would use a suitable datastructure, like a tree
15:58:22 <jmcarthur> JohnnyL: like in Data.Tree?
15:58:30 <roconnor> I'd use Data.Tree
15:58:31 <mcnster> greetings.  can anyone point me to the rationale for the x.x.x.x version numbering system for ghc libs (on the web)?  i can't seem to find it...
15:58:33 <ddarius> sproingie: It depends on what you consider "actual use," though GHC probably counts as three or so by itself.  I was considering published or documented ones in my statement.
15:58:43 <jmcarthur> :t Data.Tree.flatten
15:58:44 <lambdabot> forall a. Tree a -> [a]
15:58:45 <pumpkin> http://www.haskell.org/haskellwiki/Package_versioning_policy
15:58:48 <jmcarthur> JohnnyL: ^^
15:58:49 <JohnnyL> jmcarthur, roconnor ok thanks.
15:59:00 <ddarius> Incidentally, one of the lambda calculi GHC uses has multi-arg lambdas.
15:59:04 <mcnster> pumpkin :) much obliged
15:59:06 <pumpkin> oh I guess that's not four components
15:59:18 <Eduard_Munteanu> ddarius: I thought that was desugared
15:59:21 <sproingie> ddarius: i guess it gets tricky when you talk about papers.  i guess citation counts as use, but then chains of citations get pretty deep
16:00:48 <jmcarthur> shapr: is the shop lively tonight?
16:00:55 <luite> especially when you have cycles
16:01:40 <Eduard_Munteanu> luite: wouldn't that make a closed time loop?
16:01:43 <jmcarthur> shapr: i'm thinking about just going there, making some coffee, and going into a heavy coding session
16:01:49 <ddarius> Is it bad that I can immediately think of a paper with cyclic citations?
16:01:58 <jmcarthur> ddarius: :o
16:02:01 <Zao> Heh.
16:02:02 <shapr> jmcarthur: Go for it, Haskell is a good thing! There are six people here so far, not sure how many more will be here.
16:02:46 <pumpkin> ddarius: yep, but which one?
16:03:22 <emilmeln> When building libraries with Cabal, I get this warning: "module `Prelude' is deprecated: You are using the old package `base' version 3.x.".  Does this mean that the third version of "base" package is used by default on my system?
16:03:35 <jmcarthur> shapr: i'm mainly just wanting a change of scenery without too many distractions, but i suppose i can just put myself into a corner and wear headphones if it's too crazy there
16:03:46 <beginner1> I did it
16:05:28 <proq> shapr: where is that?
16:05:50 <ddarius> http://www.brics.dk/RS/03/13/index.html and http://www.brics.dk/RS/03/14/index.html
16:10:00 <pumpkin> data Iso a b = Iso (a -> b) (b -> a)
16:10:15 <pumpkin> data Kleiso m a b = Iso (a -> m b) (b -> m a) ? :P
16:11:02 <Eduard_Munteanu> ddarius: yeah that makes sense, it's probably a conference and those guys had talks scheduled in two consecutive days.
16:11:07 <Eduard_Munteanu> Counts as simultaneous.
16:11:39 <SmartViking> Is haskell an intrepeter language?
16:12:02 <hpc> SmartViking: no, it can program more than interpreters ;)
16:12:21 <shapr> proq: Maker's Local 256 hackerspace in Huntsville Alabama. Would you like to drop by?
16:12:21 <proq> SmartViking: all languages can be compiled.  now reconsider your question
16:12:25 <hams> Hi!
16:12:36 <shapr> proq: Hey, be nice.
16:12:44 <hams> Can anyone help me make a simple function on TVars?
16:12:47 <shapr> SmartViking: There are both interpreters and compilers available for Haskell.
16:12:51 <rryan> proq : perl ? 
16:12:54 <sipa> SmartViking: there are interpreters and compilers for haskell, but the most common one is GHC, a compiler
16:12:58 <proq> shapr: I'm not trying to be mean, just break some misconceptions  :)
16:13:05 <hpc> rryan: i was gonna say that :P
16:13:11 <shapr> proq: I understand, just that it could come across as mean.
16:13:14 <rryan> proq: perl's grammar is ambiguous, so it cannot be compiled
16:13:21 <aavogt> hams: what's your specific problem
16:13:23 <hams> I made a type called ReadVar and a type called WriteVar. ReadVars can only be read and WriteVars can only be written.
16:13:23 <SmartViking> sipa: then it will work in computers without the haskell intrepeter?
16:13:34 <sipa> SmartViking: as there is no interpreter involved, yes
16:13:39 <sipa> you compile it to a binary
16:13:46 <SmartViking> nice
16:13:53 <hams> So I need a function ReadVar (a,b)->(ReadVar a,ReadVar b)
16:13:57 <proq> shapr: that's a bit too far away to drop by  :)
16:14:04 <sipa> rryan: i don't see how being ambiguous has anything to do with being able to compile it
16:14:16 <sipa> C is also ambiguous
16:14:25 <SmartViking> sipa: is there good documentation for haskell? I have actually never heard of this language
16:14:27 <hpc> sipa: perlCompiler = id :P
16:14:37 <aavogt> hams: so  data ReadVar a = ReadVar (TVar a) ?
16:14:47 <hpc> SmartViking: you are talking to a crowd of almost-mathematicians
16:14:52 <hpc> of course there is documentation :P
16:14:57 <shapr> proq: Where do you write Haskell?
16:15:06 <hams> I also need a dual function (WriteVar a,WriteVar b)->WriteVar (a,b)
16:15:07 <proq> shapr: portland
16:15:16 <sipa> rryan: perl is actually compiled to bytecode at runtime
16:15:24 <shapr> proq: Oh, so you get to hang out with the Galois people?
16:15:35 <SmartViking> hpc: mathematicians are great, i know that since i use to talk in #math somethimes lol
16:15:40 <hams> I implemented the types by newtyping TVars
16:15:46 <hams> from the STM library
16:15:52 * hpc should probably start hanging around in #math
16:15:53 <shapr> SmartViking: Except me, I know nothing about math.
16:15:57 <proq> shapr: I haven't, but that would be cool
16:16:01 <hams> and hiding the constructors in the modules
16:16:22 <shapr> proq: They have tech talks, I hear they're open entrance.
16:16:42 <danharaj> shapr: I'm sure you know a lot more about math than you know you know about math ;)
16:17:02 <shapr> I don't know. I am confused!
16:17:20 <danharaj> That is a common feeling amongst mathematicians.
16:18:22 <Adamant> hpc: I'd recommend either buying math books recommended in #haskell, or if you're broke anything from Dover, instead.
16:18:27 * pumpkin is proud of his Kleiso name
16:18:34 <Adamant> #math is mostly useless
16:18:42 <hpc> Adamant: heh
16:18:57 <danharaj> I do not agree about buying anything from Dover, there is some rubbish there.
16:19:16 <Adamant> danharaj: I agree, but it's cheap rubbish
16:19:29 <Adamant> that's where the broke part comes in
16:19:30 <danharaj> yes, but you could always go to your local library and get free non-rubbish for a time :)
16:19:34 <Adamant> also Dover does have good stuff
16:19:38 <Adamant> good point
16:19:44 <danharaj> It does, but it is kind of rare.
16:19:48 <hpc> hey, if i wanted rubbish math i would be an accountant!
16:19:59 <Adamant> accountancy isn't math math
16:20:11 <hpc> statistician then
16:20:11 <Adamant> it's close to being an engineer
16:20:13 <hpc> :P
16:20:19 <danharaj> It's more like being a human calculator.
16:20:20 <Adamant> no, I think stats are real math
16:20:37 <hpc> quit ruining my jokes :D
16:20:40 <Adamant> :P
16:23:54 <dsop> someone knows what's the problem with "is used in a top-level splice or annotation,"?
16:24:03 <dsop> GHC stage restriction: `graphicMap'
16:24:09 <aavogt> hams: for the split, the result will be in STM, since you need to make a new TVar
16:24:19 <aavogt> dsop: put it in a different module
16:24:31 <dsop> aavogt: hmm but why?
16:24:36 <dsop> it's not in any module at all
16:24:52 <dsop> I just a file foo.hs where graphicMap is defind and also partially applied
16:25:11 <aavogt> dsop: you're intending to use template haskell?
16:25:47 <dsop> aeh no
16:25:58 <dsop> i don't know what template haskell is, sorry I'm quite new to haskell
16:26:04 <aavogt> if you have an expression at top-level it's assumed to be a template haskell splice accidentally
16:27:16 <aavogt> at least in ghc 6.12
16:27:20 <dsop> ah okay thank you
16:27:22 <dsop> helps me a lot
16:29:24 <dsop> aavogt: fixed :D
16:30:35 <emilmeln> So, nobody knows why Cabal uses base-3 instead of base-4?
16:30:37 <Apocalisp_> subst Lam x y z = State \s => (Lam x y (\v => z(subst(v)(s))), s)
16:30:48 <aavogt> hams: maybe it'll work better to put  type ReadVar a = STM a; type WriteVar a = a -> STM ()
16:31:13 <Apocalisp_> subst Lam x y z = State \s => (Lam x y (\v => z(subst v s)), s)
16:31:13 <hams> That's a good Idea
16:31:24 <Apocalisp_> I wonder if I can express (subst v s) as monadic join
16:32:01 <danharaj> emilmeln: someone gave me a good explanation a few months ago, I forgot it though :\
16:33:06 <EvanR> someone needs to write a guide: OOP for Haskell programmers
16:33:16 <danharaj> It would be very short.
16:33:19 <danharaj> "Don't."
16:33:42 <EvanR> it would be a survival guide for when you have to use an oop system, which lacks most useful features of haskell
16:33:55 <emilmeln> EvanR: There is such guide somethere in the haskell wiki.
16:33:59 <EvanR> but has other features, which may be moldable imperfectly to our purposes
16:34:14 <EvanR> really
16:35:43 <sproingie> "Haskell for OO Programmers" would be a huge benefit
16:36:01 <EvanR> there are a lot of those
16:36:07 <aavogt> OOHaskell
16:36:18 <EvanR> which mainly concentrate on how to use type classes in place of classes
16:36:20 <sproingie> no, not OO haskell.  things that are actually useful alternatives
16:36:34 <sproingie> using type classes is one
16:36:38 <EvanR> because thats apparently haskells implementation of polymorphism
16:36:48 <aavogt> hams: for those other definitions, I've got splitReadVar a = do (x,y) <- a; return (return x,return y)
16:36:49 <sproingie> well that's how you get overloading
16:37:29 <hams> I got something like that too.
16:37:31 * aavogt isn't sure if you can do any differently
16:37:35 <hams> Thank you though
16:37:56 <sproingie> OO programmers have comfortable places to put state and where to put code that deals with that state
16:38:17 <sproingie> that comfort zone is gone in Haskell
16:38:26 <EvanR> they definitely look for their sippy cup
16:38:50 <sproingie> yeah and they run into insults like that too
16:39:06 <aavogt> hams: that may not be the right thing, if you're expecting something like dupTChan
16:39:16 <sproingie> there are just different comfort zones, but they don't really know which ones are "right" to use
16:39:35 <aavogt> but I dunno if that's possible to implement inside STM
16:39:47 <sproingie> heck for my game stuff i'm not really sure either
16:40:23 <sproingie> i do know a big GameState monad stack is not fun
16:40:30 <EvanR> the question is about heirarchy, a common theme in oop is to put data in containers, which may be in containers
16:40:42 <EvanR> i havent seen a need to do that in a game
16:41:20 <EvanR> if the data gets too complex then it seems like you need a database
16:42:41 <EvanR> so is there any hope is using lessons learned in haskell in an oo system?
16:43:33 <ddarius> Of course.
16:43:43 <danharaj> Thinking declaratively is useful anywhere.
16:43:51 <ddarius> Eduard_Munteanu: re earlier, it's the same people.
16:44:07 <EvanR> for example theres no algebraic data or pattern matching
16:44:38 <ddarius> There isn't in Scheme either.
16:45:00 <EvanR> would a Maybe data help in c++? could it provide more safety? provide a compiler warning if you dont handle Nothing?
16:45:12 <ddarius> EvanR: Yes, that's why there is one in boost.
16:45:13 <sproingie> EvanR: it's a hell of a lot safer than null pointers
16:45:48 <EvanR> great
16:46:00 <sproingie> some stuff ports over nicely
16:46:05 <sproingie> linq is a monad
16:46:07 <Zao> optional<T>
16:46:20 <Zao> And of course, the assorted smart pointers.
16:46:50 <EvanR> im not sure if i should be discussing c++, it still has pointers
16:47:00 <dobblego> sproingie, not according to this poor guy http://apisuckage.wordpress.com/2009/06/19/on-linq-monads-and-the-blindness-of-power/
16:47:06 <aavogt> @hoogle Ptr
16:47:06 <lambdabot> module Foreign.Ptr
16:47:07 <lambdabot> Foreign.Ptr data Ptr a
16:47:07 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
16:47:12 <sproingie> i've something to say about the various smart pointer classes, but i'm trying to keep my negativity down
16:47:24 <EvanR> haha
16:47:43 <proq> <sproingie> OO programmers have comfortable places to put state
16:47:48 <proq> sproingie: you can store state in haskell.  but why use haskell then?
16:48:22 <EvanR> "in CL the fundamental building block is the macro"
16:48:27 <EvanR> where do you find these blogs
16:48:31 <ddarius> I've read two and a half paragraphs and it is already filled with ignorance.
16:48:44 <sproingie> proq: because haskell's a freakin good language in a lot of other respects
16:48:48 <dolio> dobblego still reads the programming reddit, I think. :)
16:49:01 <dobblego> I did in June 2009
16:49:05 <sproingie> as for that blog on apisuckage, i'm not sure i see his point.  no, linq is not a pure monad by any stretch
16:49:15 <dobblego> sproingie, he's an idiot, don't take it seriously
16:49:18 <sproingie> it's designed as a monad.  in fact it's basically designed from haskellDB
16:49:19 <nostrand> "From what I hear, in Scheme closures are just as important as macros" HAHA
16:49:44 <EvanR> lol
16:49:52 <sproingie> first commenter has it right.  i'm inclined to believe Erik Meijer's opinion
16:49:56 <Makoryu> U MENA CONTINUTIONS
16:49:57 <Philippa_> proq: because Haskell is the finest imperative language in the world?
16:50:48 <sproingie> some stateful APIs map beautifully in haskell.  using opengl is a joy in haskell
16:51:06 <sproingie> i use $= which is unapolagetically stateful, but so is OGL
16:51:34 <sproingie> mind you i'd *like* a stateless API
16:52:04 <Makoryu> You could conceivably map a much less stateful API onto OpenGL
16:52:06 <Makoryu> But....
16:52:07 <Eduard_Munteanu> ddarius: yeah, I've seen that. I meant there were no causality breaches :)
16:52:21 <EvanR> im scared of eventually having to face these mainstream business systems c# java linq scala etc
16:52:37 <Kaidelong> I hear LINQ is inefficient on enumerables
16:52:41 <sproingie> scala is mainstream?
16:52:43 <sproingie> wow
16:52:45 <Kaidelong> compared to manually writing your loops
16:52:46 <dolio> dobblego: Oh, that's grauenwolf's blog? Mystery solved.
16:52:47 <EvanR> not yet
16:52:55 <Adamant> EvanR: I thought you were a scientist
16:52:56 <dobblego> dolio, yes, note "idiot" :)
16:52:56 <Makoryu> sproingie: Well sort of
16:53:11 <Makoryu> sproingie: It could be very mainstream someday, but I don't think that will ever really happen
16:53:15 <Adamant> or are you going CS for "getting a job that pays decent" reason
16:53:17 <EvanR> Adamant: *adjusts his scientist classes*
16:53:24 <EvanR> my disguise must be falling off
16:53:26 <Makoryu> Oracle is strangling the JVM as a platform, not just the Java language
16:53:27 <min> Would someone mind taking a look at this <http://hpaste.org/41330/>? It supposedly generates the set of all possible applications of a function to the members of a list. But it's monstrous, and I don't know how to simplify it.
16:53:44 <sproingie> personally i think microsoft is doing the best job at sneaking FP in one feature at a time
16:53:47 <Adamant> Makoryu: yeah, as much as I like Scala and Clojure, this hurting them
16:53:59 <Adamant> the stuff from Oracle
16:54:09 <Adamant> i think they are both working toward self-hosting as a result
16:54:11 <EvanR> Adamant: i dont know what the future holds
16:54:15 <Makoryu> Adamant: Yep
16:54:20 <aavogt> > filterM (const [0,1]) (replicate 2 ())
16:54:21 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
16:54:21 <lambdabot>    arising from the literal `0'...
16:54:23 <Makoryu> Adamant: Scala has experimental CLR support
16:54:23 <sproingie> meh.  oracle's commercial-tier JVM is jrockit, which has *always* been commercial
16:54:25 <ddarius> EvanR: C# is pretty nice.  Linq is pretty nice too.
16:54:28 <sproingie> (except when it was in beta from Bea)
16:54:36 <Makoryu> Adamant: Clojure has greater ambitions
16:54:46 <EvanR> i just hope it doesnt involve information technology best practices
16:54:51 <Adamant> EvanR: as a scientist, you will not deal with a lot of this
16:55:00 <Adamant> ugly Fortran, yes
16:55:03 <sproingie> IT Best Practices is an oxymoron
16:55:03 <aavogt> > filterM (const [True,False]) [1,0]
16:55:04 <lambdabot>   [[1,0],[1],[0],[]]
16:55:10 <sproingie> (oops back to negativity)
16:55:18 <Adamant> Matlab, Mathematica, LabVIEW, etc. yes
16:55:23 * ddarius has a new laptop just sitting in a box next to him.
16:55:24 <Kaidelong> C# is workable insofar as that it does not intentionally frustrate you the way java does
16:55:43 <Adamant> yeah, C# is definitely the nicer Java
16:56:03 <EvanR> hm
16:56:03 <min> How about a dependently typed version of F#?
16:56:14 <EvanR> ah i forgot abou f#
16:56:26 <dolio> How about adding fancy modules back into F#?
16:56:39 <dolio> You could call it OCaml#.
16:56:47 <Kaidelong> the type system in .NET is quite different from the one in Haskell so I don't know how useful dependent types would be there?
16:57:03 <Kaidelong> because everything is an object, anyway, is the intention
16:57:24 <sproingie> well everything could be an object after erasure
16:57:36 <sproingie> doesn't mean you can't have a fancy type system
16:57:40 <Kaidelong> I guess you could think of subtypes as restricting the supertypes and hence being like a dependent type?
16:57:45 <sproingie> i suspect it'd have to be a different language tho
16:57:54 <Kaidelong> and try to implement dependent types on top of that?
16:58:09 <Makoryu> I'd like to see a new VM runtime friendlier to languages like Haskell and ML
16:58:20 <Makoryu> But I would also like to be a professional ninja
16:58:27 <sproingie> you saying the STG machine isn't friendly? :)
16:58:33 <Kaidelong> if you have dependent types I say you should go all the way and aim to do all your programming in the type system as if though you're using a logical language
16:58:37 <Adamant> Makoryu: those dreams are both fufillable
16:58:39 <EvanR> as it stands were using php. i looked into some 'real code' and it seems to be using oop support. so if we seriously start developing software in this crap, i want to be able to protect myself as much as the language will allow
16:58:53 <ddarius> Kaidelong: Since dependently typed languages have type systems very different from Haskell's, I don't see how .NET comparing to Haskell is relevant.
16:58:59 <Makoryu> sproingie: It's not comparable to the JVM as a development platform.... yet. ;)
16:59:01 <sproingie> Kaidelong: in which case why call it the type system?  it's the language now.
16:59:09 <Kaidelong> true enough
16:59:14 <pumpkin> it's a type system
16:59:15 <Makoryu> Adamant: Well I'm sure one of them is more fulfillable than the other, but I can't tell which
16:59:21 <Kaidelong> ddarius too
16:59:22 <Adamant> EvanR: PHP is evil. Ruby On Rails is much nicer
17:00:12 <EvanR> is that so
17:00:15 <min> I mean, imagine if we all programmed in Coq and exported to OCaml. Our software would never crash.
17:00:19 <ddarius> Personally, I think Microsoft has been doing a pretty impressive job in the developer arena the last few years.
17:00:22 <min> In fact, it would never get developed at all...
17:00:42 <EvanR> min: non existent code cant fail!
17:00:43 <Adamant> Makoryu: well the CIA is hiring. for the ninja part, you just have to join an elite special operations unit, spend several years there, and get a fuckton of training. and you can't wear the masks or tabi. but otherwise, you're a modern-day ninja.
17:00:49 <Kaidelong> min: what's wrong with Coq exactly? I haven't used it yet, and was planning to go for ACL2 first
17:01:05 <Makoryu> Adamant: They totally let you wear masks in the CIA.
17:01:24 <Makoryu> Especially ninja masks.
17:01:28 <Adamant> Makoryu: only polymer ones, or those Arabic dust mask thingies
17:01:35 <dolio> Go watch Chuck.
17:01:47 <Adamant> yes, i forgot about the documentary angle :P
17:01:55 <Makoryu> Also, I'm told the customary greeting between agents is "valar morghulis"
17:02:00 <EvanR> hmm this blog is overemphasizing the perceived emphasis of monads
17:02:31 <EvanR> but for example in haskell you got this Reader, which seems cool. how would you go about making a Reader in OOP?
17:02:32 <min> Nothing at all. I started with Coq recently for a class. I'm sure experienced Coq programmers (hello, Pierce and Huet) have no problem with it.
17:03:03 <Adamant> EvanR: in that development space, Ruby On Rails is way nice
17:03:05 <Adamant> r
17:03:18 <ddarius> EvanR: The exact same way.
17:03:27 <Apocalisp_> How do you reconcile hindley-milner substitution with HOAS? Seems like you wouldn't be able to distribute the HM monad over the lamda term.
17:03:32 <Adamant> can Agda or Epigram export to Haskell yet?
17:03:51 <dolio> Agda has experimental compilation to Haskell.
17:03:56 <Adamant> nice.
17:03:58 <dolio> People have been working on it more lately.
17:04:04 <Adamant> so it begins
17:04:13 <EvanR> ddarius: i see that if it has first class functions or something resembling them, you could literally make a reader monad
17:04:27 <dolio> It uses a lot of unsafeCoerce currently, though, from what I've heard.
17:04:28 <EvanR> but i mean, no one would accept that
17:04:43 <ddarius> EvanR: Objects "resemble" first class functions.
17:05:34 <yatt0> noob question: for someone who just picked up the Introduction to Algorithms T.Cormen is Haskell a language well suited for a novice to tackle elementary algorithm problems? my previous experience has been with C/C++, python no formal CS training
17:06:03 <EvanR> ok so... myReader(s).run(a,b,c) could store s in the internal state and run could use methods defined in itself an each would have access to that s
17:06:10 <EvanR> thats a way
17:06:28 <EvanR> i should collect these 'patterns' ;)
17:06:43 <dolio> I suspect Haskell is not ideal for transcribing a lot of intro to algorithms pseudocode, if that's what you mean.
17:06:55 <ddarius> yatt0: Not using that book.  Most algorithms books use an imperative (pseudo)code.
17:07:12 <EvanR> its good for recursive algorithms
17:07:46 <yatt0> thanks; i was using googling when I ran across haskell 
17:08:00 <Axman6> yatt0: most psudocode in algorithms texts assumes mutability, which can make it quite difficult to translate it into haskell
17:08:05 <dolio> If you got a book on functional algorithms, it'd be good for that.
17:08:22 <dolio> But there aren't a lot of those around.
17:08:40 <ddarius> If you got a book on functional algorithms it would probably use, well, ML... and Haskell would actually not be terribly good for it in some sense.
17:08:53 <min> Actually, a lot of "imperative pseudocode" translates nicely into Haskell. Besides the state monad, stateful conputations translates nicely into mapAccums, superfolds, and fixed points; loops into maps and filters; and so on.
17:09:08 <ddarius> min: Yes, when you know wht's goingon.
17:09:20 <ddarius> Stupid latency.
17:09:36 <yatt0> so haskell is a high level lang for advance users?
17:09:47 <ddarius> No
17:10:04 <dolio> It just encourages you to not use mutability.
17:10:12 <moosefish> yatt0: Depends on the task at hand. You can go insane with type-level hackery, or you can just use it for everyday stuff. I prefer the latter.
17:10:15 <dolio> While most algorithms texts encourage the opposite.
17:10:58 <moosefish> Speaking of insanity -- are there any simple examples of socket I/O paired with Iteratees? I'd like to bite down on something that does networking and iteratee i/o to get started.
17:11:41 <EvanR> could those imperative mutable algorithms work in ST?
17:11:41 <ddarius> Just use normal iteratee code over handle, and get the handle from a socket API.
17:12:00 <ddarius> There isn't too much special in the combination.
17:12:07 <EvanR> or be nicely rendered
17:12:44 <moosefish> ddarius: I'm just reading through the Monad Reader #16 and wondering how it'd handle errors coming from the socket. Something like other end closing the connexion and whatnots.
17:17:01 <Kaidelong> yatt0: the reason to use haskell would be much the same reason to use Scheme, thinking carefully about the evaluation strategy being used and how to denote the algorithm as a function
17:17:27 <Kaidelong> IE many backtracking algorithms translate nicely into calls to "msum"
17:18:00 <yatt0> msum? is that a haskell token?
17:18:15 <Kaidelong> msum is a function that works on lists of MonadPlus instances
17:18:21 <Kaidelong> IE
17:19:01 <Kaidelong> > msum [[6],[],[],[5,6],[3],[],[]]
17:19:02 <lambdabot>   [6,5,6,3]
17:19:59 <Kaidelong> basically it's like sum but for monads with + and 0
17:20:21 <Kaidelong> lists being an example of a monad with a + and a 0
17:20:56 <Kaidelong> but that was just an example of one way it might help you understand algorithms better
17:21:00 <EvanR> @instances MonadPlus
17:21:00 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
17:21:49 <Kaidelong> basically rather than thinking of a backtracking algorithm being something that moves in and out of different levels of recursion you could think of it in simpler terms as a sum of computations that might fail
17:22:58 <Kaidelong> you could probably find other examples of algorithms that look imperative taking on a more declarative look when you put it into haskell
17:22:58 <yatt0> I'm trying to become a better programmer so I picked up the algorithms book. I still have a long way to go.
17:23:23 <yatt0> I deal with imperative code on a daily basis
17:23:35 <EvanR> imperative is tricky!
17:23:44 <yatt0> its confusing for to digest some of the online tutorials about haskell
17:23:49 <Kaidelong> it is yes, especially on large scales
17:24:00 <Kaidelong> I recommend BONUS' "learnyouahaskell"
17:24:11 <Eduard_Munteanu> @where lyah
17:24:11 <lambdabot> http://www.learnyouahaskell.com/
17:24:55 <yatt0> I was at that website today at work, trying to learn stuff during downtime
17:25:11 <Kaidelong> actually would you guys be interested in examples and an article on backtracking algorithms that use MonadPlus?
17:25:22 <ddarius> This laptop is definitely cheap.
17:25:23 <Kaidelong> it might be a good way to explain why MonadPlus is useful
17:27:05 <min> Is there such an article? I haven't found a good paper on backtracking algorithms in Haskell, but I see them implemented and used a lot.
17:27:31 <Kaidelong> I was asking if you guys would be interested in my writing a blog post on it, basically
17:27:41 <Kaidelong> it's a pretty simple concept and might make a decent tutorial
17:28:04 <Kaidelong> basically backtracking using msum and laziness
17:28:16 <tamerlan> Kaidelong: if its worth anything I would be interested in reading such a blog post.
17:28:42 <Kaidelong> IF foldr and msum work the way I think they do, hmm
17:28:47 <ddarius> There are a whole lot of articles on backtracking with monads.
17:28:48 <Eduard_Munteanu> I'm trying to figure it out right now, since you mentioned it, I would pay a visit and see if I got your idea right.
17:28:57 <min> That would be really interesting.
17:29:29 <Kaidelong> > foldr mplus mzero (Just 6 : repeat undefined)
17:29:30 <lambdabot>   Just 6
17:29:34 <Kaidelong> great
17:30:08 <Kaidelong> > foldr mplus mzero ([6] : repeat undefined)
17:30:09 <lambdabot>   [6*Exception: Prelude.undefined
17:30:29 <Kaidelong> also great
17:30:57 <Kaidelong> okay then it's not me being stupid and this works fine and I can write about it without looking stupid
17:30:58 <Eduard_Munteanu> Is foldr there providing a backbone for the tree-like branching in backtracking, with mplus accumulating?
17:31:12 <Kaidelong> basically, because:
17:31:18 <Kaidelong> mplus mzero = id
17:31:23 <int80_h> could someone explain why this doesn't work - dropWhile (/= "?") "/launchWebForward.do?resourceId=4&policy=0&returnTo=%2FshowWebForwards.do"
17:31:30 <Kaidelong> so it just goes on to check if the next computation on the list isn't mzero
17:31:48 <int80_h> I ask because I think I have the type right, but ghci gives me type complaints
17:31:51 <EvanR> :t dropWhile (/= "?")
17:31:52 <lambdabot> [[Char]] -> [[Char]]
17:31:56 <Azrael-> int80_h, '?', not "?"
17:31:58 <Kaidelong> and if you're using the Maybe monad, it ends up terminating after the first thing that gives you a just
17:32:03 <Azrael-> "?" = ['?']
17:32:12 <min> The function drops characters from the list while the predicate /= '?' is True
17:32:23 <min> It's a type error because you are trying to drop strings from a [Char]
17:32:32 <EvanR> as long as you give it a [String] it works
17:33:25 <Azrael-> > concat (dropWhile (/= "?") (map (:[]) "/launchWebForward.do?resourceId=4&policy=0&returnTo=%2FshowWebForwards.do"))
17:33:26 <lambdabot>   "?resourceId=4&policy=0&returnTo=%2FshowWebForwards.do"
17:33:30 <Azrael-> :)
17:33:48 <min> It's like splitting the infinitive
17:33:54 <int80_h> thanks!
17:34:09 <int80_h> this is my first attempt as screen scraping
17:34:11 <Azrael-> int80_h, i assume you're saying thanks for the explanation, not for the stupid code i just used
17:34:19 <Azrael-> if you actually do what i just did, you're a bad person and you should feel bad
17:34:20 <int80_h> yes yes, for the explaination
17:34:30 <Azrael-> just checking :)
17:34:47 <Azrael-> people in #haskell have a tendency to come up with silly code to a solution
17:35:15 <int80_h> oh I imagine my code is quite silly. When I'm done I'll pass it by a senior engineer for inspection.
17:35:24 <Kaidelong> http://hpaste.org/41331/backtracking_with_a_monadplus
17:35:35 <Kaidelong> I'll have to probably rewrite these to be more readable
17:35:39 <Kaidelong> not to mention comment them
17:35:44 <Kaidelong> but that would be the basic idea?
17:35:57 <jmcarthur> proq: psh. you're gonna miss out on meeting shapr and me because you're afraid of a little drive from oregon to alabama. :P
17:36:08 <proq> :'(
17:36:14 <int80_h> I do believe I have successfully introduced haskell as an automation tool at my workplace.
17:36:22 <jmcarthur> proq: actually i envy you because you live in portland
17:36:24 <int80_h> so that's cool
17:36:31 <Kaidelong> oh whoops
17:36:32 <Azrael-> int80_h, nice
17:36:46 <proq> I do like it here much better than los altos, ca
17:36:52 <int80_h> well, I wouldn't have been able to do it without this channel, and the mailing lists
17:36:54 * Makoryu fistbumps int80_h
17:36:57 <Azrael-> of course, for more practical and dirty stuff, an imperative scripting language like Python is easier, especially with no prior knowledge of the language
17:37:00 <Makoryu> YES BRO
17:37:02 <Azrael-> but Haskell is beautiful and elegant
17:37:08 <Kaidelong> how did that 0 get in there
17:37:59 <int80_h> azrael, I take it as an article of faith that one doesn't want to treat their automation tasks as quick and dirty one-offs, as it likely won't be.
17:38:08 <Kaidelong> http://hpaste.org/paste/41331/backtracking_with_a_monadplus#p41332
17:38:18 <int80_h> it's a matter of faith because I haven't much experience at this.
17:38:31 <Azrael-> I have significantly less :D
17:40:30 <Eduard_Munteanu> Well, that's what studying something is: going through material, getting some practice and asking questions.
17:40:56 <int80_h> as init truncates the final element in a list, is there a function that truncates the first element of the list, returning the remainder?
17:41:08 <jmcarthur> tail?
17:41:10 <Kaidelong> tail
17:41:12 <int80_h> hah
17:41:14 <int80_h> yes
17:41:14 <Kaidelong> but use a pattern instead
17:41:20 <int80_h> really?
17:41:22 <jmcarthur> head is to tail as last is to init
17:41:34 <Eduard_Munteanu> int80_h: good ol' x:xs
17:41:35 <jmcarthur> why use a pattern?
17:41:45 <jmcarthur> unless you mean matching empty as well
17:41:51 <Kaidelong> basically
17:42:00 <int80_h> hmm, yeah I may do that. I'm working out the algorithm in ghci, but I may use x:xs in implementation
17:42:04 <Kaidelong> you can turn on a compiler warning if the pattern doesn't cover that case
17:42:11 <jmcarthur> when i'm suggesting an alternative to head i normally suggest listToMaybe
17:42:15 <jmcarthur> not sure about tail
17:42:29 <Eduard_Munteanu> Describing list processing in terms of [] and x:xs is quite ubiquitous.
17:42:31 <jmcarthur> could say drop 1
17:42:34 <jmcarthur> > drop 1 []
17:42:35 <lambdabot>   []
17:42:38 <jmcarthur> > drop 1 [1,2,3]
17:42:38 <lambdabot>   [2,3]
17:42:57 <Azrael-> > drop 1 [1..]
17:42:57 <int80_h> tail []
17:42:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
17:43:11 <Azrael-> Clever girl...
17:43:11 <int80_h> > tail []
17:43:12 <lambdabot>   *Exception: Prelude.tail: empty list
17:43:27 <int80_h> ah yes, drop is better
17:43:44 <jmcarthur> i would use tail when i *know* that the list contains at least one element
17:44:01 <int80_h> yeah I think that will be the case
17:44:13 <int80_h> I will have a list of strings
17:44:30 <Kaidelong> jmcarthur: but then you could still have a pattern [] that does nothing other than complain with an error message3
17:45:32 <Kaidelong> software engineering principle actually, isn't it? "If something must be true, say so clearly"
17:46:53 <ddarius> jmcarthur: You could live in Portland too.
17:47:25 <Azrael-> Kaidelong, thorough documentation saves lives, it's true
17:48:05 <lispy1> did someone say Portland?
17:50:22 <osaunders> «instance (Num a) => Num [a] where (+) = zipWith (+)»... a good idea?
17:51:50 <osaunders> > [1,2,3] + repeat 1
17:51:51 <lambdabot>   No instance for (GHC.Num.Num [t])
17:51:52 <lambdabot>    arising from a use of `e_11231' at <in...
17:52:21 <osaunders> > let (+) = zipWith Prelude.(+) in [1,2,3] + repeat 1
17:52:21 <lambdabot>   Not in scope: data constructor `Prelude'
17:52:36 <Makoryu> So is there even a way to distribute modules as STG bytecode?
17:52:41 <Kaidelong> repeat 1 would have the value _|_ as a Num
17:52:49 <Kaidelong> > let (+) = zipWith Prelude.+ in [1,2,3] + repeat 1
17:52:50 <lambdabot>   <no location info>: parse error on input `in'
17:52:56 <Kaidelong> > let (+) = zipWith (Prelude.+) in [1,2,3] + repeat 1
17:52:57 <lambdabot>   [2,3,4]
17:53:02 <unkanon> > take 5 (repeat 1)
17:53:03 <lambdabot>   [1,1,1,1,1]
17:53:09 <Kaidelong> oh
17:53:12 <Makoryu> And if not, how hard would it be to separate GHC into front- and back-ends for a setup like that?
17:53:43 <unkanon> I have a question about the Functor laws. how could "fmap id = id" _ever_ not hold?
17:54:39 <Eduard_Munteanu> unkanon: suppose it switched Left with Right in Either.
17:54:48 <osaunders> unkanon: If the functor is a record with more than one value in it and the implementation of fmap changes something other than the first value.
17:54:49 <Kaidelong> unkanon: if fmap does something naughty to the functor itself, like for example counting how many times something was fmapped over
17:55:00 <osaunders> *last value
17:55:04 <jmcarthur> ddarius: i'd love to. just need to score a nice job there *ahem*
17:55:41 * unkanon is thinking about the answers he got
17:55:45 <osaunders> unkanon: example: fmap f (x,y) = (f x, y + 1)
17:55:54 <int80_h> if I wanted to test for an empty list, is length the right way, or is there a better way?
17:56:06 <unkanon> int80_h: null
17:56:18 <unkanon> int80_h: don't use length as it has to traverse the whole list
17:56:23 <unkanon> > null []
17:56:24 <lambdabot>   True
17:56:25 <unkanon> > null [1,2,]
17:56:26 <lambdabot>   <no location info>: parse error on input `]'
17:56:27 <unkanon> > null [1,2,3]
17:56:28 <lambdabot>   False
17:56:32 <jmcarthur> i'm hoping galois enters a hiring cycle soon or something
17:56:39 <int80_h> > null ""
17:56:40 <lambdabot>   True
17:56:46 <int80_h> excellent
17:56:58 <osaunders> jmcarthur: galois?
17:56:59 <Eduard_Munteanu> Actually Either isn't such a good example.
17:57:06 <Eduard_Munteanu> My bad.
17:57:21 <Kaidelong> http://learnyouahaskell.com/functors-applicative-functors-and-monoids
17:57:25 <osaunders> Eduard_Munteanu: Yeah, would only work if they were the same type.
17:57:34 <Eduard_Munteanu> And another kind :)
17:57:36 <Eduard_Munteanu> :k Either
17:57:37 <lambdabot> * -> * -> *
17:57:45 <int80_h> we should all buy lyah when it comes out
17:57:50 <Kaidelong> unkanon: that page has an example of a functor that violates that particular functor law
17:57:57 <unkanon> Eduard_Munteanu, osaunders, Kaidelong: so in order for fmap id = id to not hold, fmap would have to be the culprit, right? since there's no way to screw up id
17:58:06 <osaunders> yep
17:58:09 <Kaidelong> yes
17:58:31 <Eduard_Munteanu> unkanon: yes, only the instance definition can be screwed.
17:59:05 <unkanon> Kaidelong: thanks, I'll take a look at it
17:59:59 <jmcarthur> osaunders: as in http://www.galois.com/
18:00:24 <proq> the next techtalk at galois looks interesting
18:00:37 <unkanon> ok, and in order to break the second law, fmap (f . g) = fmap f . fmap g, the text I'm reading says it means "that fmap changes a value without altering its context"
18:01:00 <unkanon> the example it gives is of an fmap that acts like a map but cons'es x twice with xs
18:01:17 <unkanon> that is, fmap f (x:xs) = f x : f x : fmap f xs
18:01:35 <unkanon> I can clearly see that this "alters a value's context"
18:01:48 <unkanon> but can I see another example that is not about lists?
18:01:57 <osaunders> How does it alter the context?
18:02:13 <osaunders> In this case the context is that it is a list. If it conses twice, it is still a list.
18:02:16 <jmcarthur> i think that haskell's version of fmap specifically only requires the other law to be obeyed and the law you are talking about is implied by the first
18:03:04 <int80_h> I'm trying to do something like this
18:03:10 <jmcarthur> or maybe it's the other way around. i don't remember for sure
18:03:18 <int80_h> filter (null /= true) collection
18:03:33 <jmcarthur> filter (not . null) collection
18:03:34 <int80_h> where collection is a list of strings, some of them empty
18:04:07 <osaunders> int80_h: It's True not true.
18:04:16 <int80_h> jmcarthur, could you explain the composition?
18:04:20 <unkanon> osaunders: it alters it because now the list has more elements, perhaps?
18:04:25 <jmcarthur> > filter (not . null) ["foo", "", "bar", "baz"]
18:04:26 <lambdabot>   ["foo","bar","baz"]
18:04:27 <Kaidelong> :t (.)
18:04:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:04:35 <Kaidelong> oh
18:04:40 <jmcarthur> int80_h: it's the same as \xs -> not (null xs)
18:04:40 <Kaidelong> the other prelude
18:04:44 <Kaidelong> well, think of
18:04:44 <jmcarthur> @src not
18:04:44 <lambdabot> not True   =  False
18:04:44 <lambdabot> not False  =  True
18:04:57 <unkanon> jmcarthur: correct, haskell doesnt require the second law to be obeyed, but I'm studying it anyway :)
18:05:12 <Kaidelong> (b -> c) -> (a -> b) -> (a -> c)
18:05:21 <osaunders> unkanon: I don't think it does. That implementation of fmap is still (Functor f) => (a -> b) -> f a -> f b
18:05:24 <Kaidelong> as the type of (.)
18:05:26 <unkanon> jmcarthur: haskell doesnt require the first law to be obeyed either
18:05:36 <jmcarthur> unkanon: ?
18:05:37 <unkanon> jmcarthur: just that you have an fmap with the appropriate type
18:05:42 <mee> Is there another way to write [] to make it more like other type constructors? (like various lisps' (list)) (try saying that 5 times fast)
18:05:44 <jmcarthur> unkanon: i mean the spec of Functor
18:06:06 <jmcarthur> as in the laws that you are supposed to verify before writing the instance
18:06:06 <Kaidelong> mee: it is [], and you can use it prefix
18:06:11 <Eduard_Munteanu> mee: like what other type constructors?
18:06:14 <jmcarthur> the compiler just can't check them
18:06:17 <Kaidelong> IE [] T as opposed to [T]
18:06:30 <Eduard_Munteanu> Oh.
18:06:34 <osaunders> > [1,2,3] :: [] Int -- < mee
18:06:35 <lambdabot>   [1,2,3]
18:06:57 <mee> Kaidelong / osaunders : perfect, thanks
18:07:09 <unkanon> jmcarthur: I'm confused, what?
18:07:38 <Kaidelong> conal: Real World Functional programming does it all using IObservable and behaviors over time
18:07:47 <osaunders> unkanon: Haskell doesn't prevent you from writing «fmap»s that violate functor laws.
18:08:02 <unkanon> osaunders: that's what I said :)
18:08:14 <Kaidelong> they do examples of reactive animation as well as user input
18:08:16 <jmcarthur> unkanon: http://www.haskell.org/onlinereport/basic.html#sect6.3.5
18:08:24 <Kaidelong> I think they did read some of your stuff
18:08:40 <jmcarthur> unkanon: the compiler doesn't prevent you, but the spec clearly states "instances should satisfy the following laws:"
18:08:42 <osaunders> unkanon: OK, yeah. But that doesn't mean you should break them either.
18:08:59 <unkanon> osaunders: right, that's why I'm learning about the two functor laws
18:09:14 <osaunders> ok
18:09:23 <jmcarthur> and it just so happens that the second law is redundant in haskell even though it would need to be stated in a more general context
18:09:29 <unkanon> jmcarthur: well, at least it's good to know that all functors in prelude are real functors :)
18:09:35 <jmcarthur> yup
18:09:43 <unkanon> jmcarthur: why is it redundant?
18:10:06 <Eduard_Munteanu> Would there be any way to write some proofs regarding those laws? Or they'd be extremely verbose?
18:10:07 <conal> Kaidelong: ah. i wonder if they implemented mappend on events correctly. it's tricky.
18:10:14 <dolio> Because given fmap id = id, it follows from the free theorem for the type (forall a b. (a -> b) -> F a -> F b)
18:10:15 <jmcarthur> unkanon: i've heard that the second law is implied by the first in haskell because haskell's Functor is not as general as real functors
18:10:17 <Eduard_Munteanu> Barring partiality.
18:10:28 <jmcarthur> but i never worked it out myself
18:10:50 <unkanon> jmcarthur: maybe it's what dolio said
18:11:12 <conal> Kaidelong: e.g. for simultaneous event occurrences.
18:11:51 <Eduard_Munteanu> jmcarthur: aren't they actually endofunctors?
18:11:54 <osaunders> jmcarthur: Interesting
18:11:55 <unkanon> dolio: is there a newbie-friendly explanation of what you just said that you know of?
18:12:05 <dolio> @free fmap :: (a -> b) -> F a -> F b
18:12:05 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
18:12:29 <Eduard_Munteanu> We don't seem to be departing Hask.
18:12:59 <dolio> g = k = id, h = f
18:13:10 <osaunders> unkanon: Don't worry about it. It sounds to me like you've got functors nailed at this point.
18:13:26 <dolio> id . h = id . h => $map_F id . fmap h = fmap id . $map_F h
18:13:42 <dolio> $map_F id = id = fmap id, so fmap h = $map_F h.
18:13:58 <unkanon> osaunders: yeah I don't really have a problem with them, but it's just so interesting :)
18:14:00 <Kaidelong> conal: doesn't look like F# has any general functionality for taking two events and getting one event
18:14:05 <dolio> Where $map_F is assumed to obey the functor laws.
18:14:11 <jmcarthur> unkanon: one interesting Functor instance to study is the instance for ((,) a). the "obvious" instance doesn't obey they laws
18:14:15 <unkanon> osaunders: but you're right I gotta go back to reading otherwise I'll never finish any book
18:14:20 <jmcarthur> *obey the
18:14:29 <jmcarthur> unkanon: depending on your definition for obvious, i mean
18:14:37 <dolio> So fmap (g . f) = $map_F (g . f) = $map_F g . $map_F f = fmap g . fmap f
18:14:48 <jmcarthur> unkanon: i should have just not used that word
18:14:50 <osaunders> unkanon: Stuff in Haskell can go really deep if you want to and the people in this channel often like to. But there's a time for that later on.
18:15:12 <jmcarthur> unkanon: the lazy definition of fmap for tuples doesn't obey the laws. i'll just say that
18:15:20 <unkanon> Eduard_Munteanu: according to my text they're endofunctors, yes
18:15:32 <dolio> unkanon: If you want to know where you get that free theorem from, though, I don't know of any very easy introductions. You just have to puzzle over Wadler's "Theorems for Free" for a while.
18:15:46 <Eduard_Munteanu> I see.
18:16:01 <unkanon> jmcarthur: I sawthat ((,) e) being referenced but I don't know what that even means in haskell
18:16:10 <unkanon> jmcarthur: they also referenced ((->) e)
18:16:16 <dolio> > fmap (+1) undefined
18:16:17 <lambdabot>   No instance for (GHC.Show.Show (f a))
18:16:17 <lambdabot>    arising from a use of `M9151452700...
18:16:19 <jmcarthur> unkanon: ((,) e) a == (e, a)
18:16:21 <dolio> > fmap (+1) undefined :: (Int, Int)
18:16:22 <lambdabot>   *Exception: Prelude.undefined
18:16:37 <jmcarthur> unkanon: ((->) e) a == (e -> a)
18:16:42 <Eduard_Munteanu> dolio: I remember going a bit through that, but is there a more general definition of a 'free theorem', or is it something Wadler specifically defines there?
18:16:47 <conal> Kaidelong: ah.  i haven't seen the book. if they're using IObservable, doesn't sound very functional. maybe functional/imperative hybrid.
18:17:02 <osaunders> :t (,)
18:17:03 <lambdabot> forall a b. a -> b -> (a, b)
18:17:06 <Kaidelong> probably, although IObservable was made because of F#
18:17:06 <osaunders> :t (1,)
18:17:07 <lambdabot> parse error on input `)'
18:17:14 <Kaidelong> and it was released with the reactive framework
18:17:15 <osaunders> :t (,) 1
18:17:16 <lambdabot> forall t b. (Num t) => b -> (t, b)
18:17:20 <osaunders> :t (,) 1 2
18:17:20 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
18:17:25 <unkanon> dolio: thanks for the intro, though! I'll be looking at that after I'm more comfortabe with it all
18:17:27 <Makoryu> :t (,) undefined
18:17:28 <lambdabot> forall a b. b -> (a, b)
18:17:29 <Kaidelong> although I think the reactive framework now comes standard in .NET 4.0
18:17:37 <dolio> Eduard_Munteanu: Free theorems come from parametricity. Every type has an associated parametricity theorem, that talks about types as relations.
18:17:47 <Makoryu> :t (,) $ fix error
18:17:48 <lambdabot> forall b. b -> ([Char], b)
18:17:50 <osaunders> OK those types are really noisey.
18:17:54 <dolio> That's still "free" in the sense that you get it by knowing only the type, but that's not what is usually called the free theorem.
18:18:03 <dolio> And it is more general in most cases.
18:18:05 <unkanon> jmcarthur: is , a "tuple constructor" ?
18:18:09 <jmcarthur> unkanon: yes
18:18:12 <Eduard_Munteanu> dolio: oh. I hope I'll see something about that in TAPL.
18:18:35 <dolio> The so called free theorem is what you get by using functions for the relations in question.
18:18:53 <osaunders> > (,) True True
18:18:53 <lambdabot>   (True,True)
18:19:00 <Kaidelong> http://msdn.microsoft.com/en-us/devlabs/ee794896.aspx
18:19:04 <osaunders> > (,) True True :: (Bool, Bool)
18:19:05 <lambdabot>   (True,True)
18:19:17 <dolio> That is, when you need a relation A <-> A', you use f : A -> A', and use the relation {(x, y) | y = f x}.
18:19:23 <jmcarthur> > (,) True True :: (,) Bool Bool
18:19:24 <lambdabot>   (True,True)
18:19:24 <osaunders> > (,) True :: a -> (Bool, a)
18:19:25 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> (GHC.Bool.Bool, a))
18:19:25 <lambdabot>    arisin...
18:19:29 <jmcarthur> > (,) True True :: ((,) Bool) Bool
18:19:30 <lambdabot>   (True,True)
18:19:43 <unkanon> jmcarthur: is -> part of the do notation? I haven't gotten to that I think
18:19:52 <Eduard_Munteanu> dolio: those functions seem to belong to a fixed set, like map etc.
18:19:57 <jmcarthur> unkanon: id :: a -> a  -- it's like the -> in that
18:20:08 <Eduard_Munteanu> Sorta "common sense free theorems"
18:20:13 <jmcarthur> unkanon: id :: ((->) a) a
18:20:24 <dolio> Eduard_Munteanu: The $map stuff comes from parametricity theorems for datatypes.
18:20:33 <jmcarthur> :t id :: ((->) a) a
18:20:33 <lambdabot> forall a. a -> a
18:20:43 <Eduard_Munteanu> Grr... I have to do some reading I suppose.
18:21:12 <unkanon> jmcarthur: oh, like the arrow in type definitions? that's kinda crazy :P
18:21:26 <unkanon> I thought that was just syntax
18:21:43 <dolio> Eduard_Munteanu: Or, in general, fixed type constructors F : * -> * that are assumed to be functors.
18:21:49 <Eduard_Munteanu> Do we even have non-endofunctors in Haskell? I think * -> # would be an example if it existed.
18:22:17 <Eduard_Munteanu> I see.
18:22:37 <osaunders> What's an endofunctor?
18:22:50 <Eduard_Munteanu> Or am I misinterpreting kinds as categories?
18:22:53 <dolio> A functor from a category to itself.
18:22:58 <Eduard_Munteanu> (erm stars in kinds)
18:23:09 <unkanon> jmcarthur: yeah that's it, now I understand my text :) thanks
18:23:56 <dolio> Eduard_Munteanu: It's hard to say. You can have functions from types with kind * to types with kind #, and so on.
18:24:07 <dolio> That wouldn't really be possible if they were separate categories.
18:24:17 <dolio> At least, interpreting types as objects and functions as morphisms.
18:24:21 <Eduard_Munteanu> Hm, it makes sense.
18:24:37 <Eduard_Munteanu> So the whole universe is Hask?
18:24:47 <conal> Kaidelong: i guess Rx has gotten some interest. it didn't grab me. i prefer functional/denotative programming.
18:25:12 <Eduard_Munteanu> I can't really come up with a seemingly well formed function that wasn't an arrow.
18:26:29 <Kaidelong> conal: I don't think pure functional programming will be mainstream for a while yet unfortunately
18:26:58 <dolio> Eduard_Munteanu: You get a similar issue in certain dependent type theories.
18:27:02 <conal> Kaidelong: me neither. we have a lot to figure out. i don't mind taking the time and doing it well.
18:27:30 <Kaidelong> in the meantime I'm glad Microsoft is seriously pushing side-effecting functional programming on their platforms
18:27:39 <Eduard_Munteanu> dolio: I looked at Agda's Martin-Lof, I don't know much about it, but it's certainly richer.
18:27:51 <dolio> If your theory contains functions T -> Set, for some type T, then Set has to be an object for the naive interpretation.
18:27:54 <conal> Kaidelong: even haskellers resort to IO for lots of things we don't know how to formulate denotatively.
18:28:08 <dolio> So the category in question can't be Set, unless Set : Set, which leads to inconsistency.
18:28:33 <Kaidelong> that's true. But the whole idea behind functional and OO abstractions is that you're containing that stateful part to some part of the program where it is well understood
18:28:37 <EvanR> :t (^)
18:28:38 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
18:28:53 <EvanR> hmm thats not in a class....
18:28:58 <Kaidelong> and you can eventually reach a pure abstraction over it
18:29:09 <Eduard_Munteanu> dolio: hm so types can't be proper classes?
18:29:24 <unkanon> does the letter f in fmap mean functor?
18:29:25 <dolio> I think most categorical models of type theory side-step this by not considering functions T -> Set to really be functions, so to speak.
18:29:30 <Kaidelong> that actually explains pretty much how I personally write my classes in C#
18:29:59 <Kaidelong> clearly stateful structs or classes that are eventually abstracted into pure ones that hide them
18:30:31 <dolio> Eduard_Munteanu: By Set, I mean the classifier of types. It's called Set in Agda, and Martin-loef calls types "sets" I think.
18:30:37 <dolio> You could use Type, or * instead.
18:31:01 <Eduard_Munteanu> Oh. I took Set as related to the category Set.
18:31:02 <EvanR> :t (^^)
18:31:02 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
18:31:09 <EvanR> > 2 ^^ 4
18:31:10 <lambdabot>   16.0
18:31:32 <dolio> No (specific) relation to set theory.
18:32:40 <jmcarthur> bah! stinking IORef not being an instance of Ord... *grumble grumble*
18:32:52 <Eduard_Munteanu> Heh.
18:33:07 <jmcarthur> probably it would require an extra tag with all IORefs anyway though
18:33:11 <dolio> Anyhow, if functions of type T -> * aren't first class, you can probably get away without considering them arrows. But a lot of type theories aren't that limited.
18:33:13 <jmcarthur> because the GC can change addresses
18:33:44 <ManateeLazyCat> How to get *my* channel ops?
18:34:31 <ManateeLazyCat> I use "/topic ##manatee Welcome to Manatee", but server noticed me "You need to be a channel operator of ##manatee to do that"
18:35:03 <Eduard_Munteanu> dolio: hm to wrap it up with some stuff I've seen about Agda, it's fair to say functions in Agda can be both (either) arrows or functors?
18:35:51 <dolio> Agda certainly has functions that can be functors.
18:35:53 <Eduard_Munteanu> It seems to me something can be a Nat, something higher than Nat etc.
18:36:00 <Eduard_Munteanu> Ah, it makes sense then.
18:36:02 <dolio> Or, can be equipped as such.
18:36:22 <dolio> (\T -> T), (\f -> f) together form the identity functor.
18:37:00 <dolio> The first being the action on objects, the second being the action on arrows.
18:37:42 <Eduard_Munteanu> In Haskell that would be the type constructor and fmap, respectively, right?
18:38:05 <kmc> yes
18:38:33 <EvanR> > 4.5 `div` 9.5
18:38:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
18:38:34 <lambdabot>    `GHC.Real.Integral a'
18:38:34 <lambdabot>   ...
18:38:43 <EvanR> > 4.5 `div` 9.5 :: Double
18:38:44 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
18:38:44 <lambdabot>    arising from a use ...
18:38:49 <dolio> Sure. But you can represent categories that are unrelated to the Agda-category much more easily in Agda.
18:38:49 <Eduard_Munteanu> I see, thanks, this has been enlightening.
18:39:07 <dolio> And there's an identity functor that looks roughly like that for every one of them.
18:42:01 <EvanR> > negate (1 :: Word32)
18:42:02 <lambdabot>   4294967295
18:42:58 <jmcarthur> dolio: "you can represent categories that are unrelated to the Agda-category much more easily in Agda"  is there a simple example demonstrating this that you can think of?
18:44:07 <dolio> Apparently code.haskell.org is down, so I can't show you whatever is in my agda repository.
18:44:13 <jmcarthur> aw
18:44:17 <EvanR> > pred 0
18:44:17 <dolio> However, you can define categories like this:
18:44:18 <lambdabot>   -1
18:45:32 <dolio> record Category where { Obj : Set ; _=>_ : Obj -> Obj -> Set ; id : (A : Obj) -> A => A ; _._ : (A B C : Obj) -> (B => C) -> (A => B) -> (A => C) ; <laws> }
18:45:44 <dolio> That's not quite valid syntax, but it's close.
18:46:17 <dolio> Then you can have all kinds of other categories.
18:47:14 <pumpkin> jmcarthur: http://web.student.chalmers.se/~stevan/ctfp/html/Category.html#363
18:47:34 <dolio> Every type T is a category. Obj = T. The arrows are equality of elements of T, the identity arrow is the reflexive proof of equality, and composition is transitivity.
18:48:20 <dolio> Every finite set also induces a category, where there's an arrow x => y if x <= y.
18:48:29 * hackagebot cil 0.1.1 - An interface to CIL.  http://hackage.haskell.org/package/cil-0.1.1 (TomHawkins)
18:48:42 <pumpkin> the finite set one is in that ctfp repository
18:48:58 <dolio> The natural numbers are a category in the same way.
18:49:10 <pumpkin> ah, that's the one that's in here: http://web.student.chalmers.se/~stevan/ctfp/html/Category.Categories.Nat.html#191
18:50:16 <jmcarthur> okay i see
18:50:31 <dolio> The ability to have categories with objects that aren't essentially *, or whatever, is a big lack in Haskell.
18:50:32 <tolkad> Is there any way I could use unsafeCoerce to have mutable variables in haskell?
18:50:52 <tolkad> with unsafePerformIO
18:51:22 <tolkad> like... I could cast something to some sort of pointer and change its contents
18:51:22 <ivanm> FunctorSalad: just got your message from a few days ago r.e. SourceGraph: thanks!
18:51:37 <tolkad> any ideas?
18:51:45 <ivanm> I haven't managed to get much hacking done recently :s
18:51:45 <Eduard_Munteanu> tolkad: yes, see mutable variables on the wiki, I think there was something there on unsafePerformIO
18:52:07 <Eduard_Munteanu> tolkad: it also included big fat warnings :)
18:52:09 <jmcarthur> tolkad: you could certainly find a way but it would probably be very fragile
18:52:34 <jmcarthur> i would not do it without a really really really good reason
18:53:48 <tolkad> Eduard_Munteanu: it uses an IORef: http://www.haskell.org/haskellwiki/Top_level_mutable_state#Proposal_3:_Type-based_dictionaries_and_execution_contexts
18:53:53 <Eduard_Munteanu> I suppose it's safe in some cases, like printing a debug message on the screen.
18:54:01 <tolkad> I was thinking more like casting something into a #Ptr
18:54:11 <jmcarthur> tolkad: what for, may i ask?
18:54:33 <tolkad> jmcarthur: so I could have mutable state everywhere
18:54:45 <EvanR> tolkad is funny
18:54:46 <jmcarthur> tolkad: that is a means, not an end
18:54:56 <jmcarthur> tolkad: are you just trolling again? :P
18:55:18 <EvanR> i have much to learn from him
18:55:20 <tolkad> I just had the idea and I was sort of curious if it would work
18:55:45 <jmcarthur> tolkad: a #Ptr wouldn't be reliable because the GC can move things around in memory
18:56:27 <EvanR> tolkad: C has extensive first class support for pointers
18:56:31 <Eduard_Munteanu> I suppose it might make sense when there's a big chunk of code and you want to make that tiny little change, but that results in lotsa other changes.
18:56:38 <jmcarthur> tolkad: and of course there's always the expected referential transparency property of pure code to consider
18:56:53 <Eduard_Munteanu> *to make -> to try
18:56:54 <ManateeLazyCat> Welcome to ##manatee
18:58:16 <tolkad> anyway, superclass constraints are cool. when's GHC 7 being released?
18:58:59 <dolio> They got turned off in 7, last I heard.
18:59:03 <tolkad> jmcarthur: I guess it's completely unreliable then
18:59:06 <dolio> Because there was a bug or something.
18:59:10 <tolkad> what?!? : (
18:59:39 <tolkad> if GHCs code wasn't so scary I'd try to help
18:59:59 <Eduard_Munteanu> I thought GCC was scary :P
19:00:58 <Eduard_Munteanu> Actually what scares me about GHC is the huge compile time.
19:01:14 <Eduard_Munteanu> (of the compiler itself I mean)
19:02:46 <dolio> http://hackage.haskell.org/trac/ghc/ticket/4338
19:11:45 <sshc> Yay, Learn You a Haskell will be published as a book :D
19:13:29 <stepcut> nice
19:20:25 * ivanm glares at springerlink
19:20:44 <ivanm> my uni has an account there, but there's still a paper I want that they want me to pay 25 euros for!
19:21:33 <stepcut> papers want to be free!!
19:21:36 <danharaj> <3 to edwardk for category-extras
19:23:16 <ivanm> stepcut: exactly
19:23:22 <ivanm> it's not even a new paper...
19:23:32 <stepcut> it's recycled ?
19:23:44 <ivanm> heh
19:23:49 <ivanm> it's from 1988
19:23:58 <ivanm> referenced a lot, but no-one has online copies... :@
19:24:15 * ivanm is trying to find a good representation for planar graphs
19:24:29 <Axman6> lame :(
19:25:28 <Axman6> ivanm: have you heard my news?
19:25:34 <ivanm> nope
19:25:38 <ivanm> what is it?
19:25:46 <ivanm> you finally marked all 4 assignments? :p
19:26:05 <Axman6> heh, marking assignment 4 now :P
19:26:13 <Axman6> but, i'm going to Japan for a haskell internship :D
19:26:17 <ivanm> heh
19:26:23 <ivanm> gareth hasn't marked assignment 4 yet either
19:26:25 <ivanm> Axman6: :o
19:26:26 <ivanm> cool!
19:26:29 <Axman6> oh good!
19:26:29 <ivanm> whom with?
19:26:30 <Axman6> haha
19:26:47 <Axman6> Tsuru Capital: http://www.tsurucapital.com/en/
19:27:47 <Axman6> Conrad Parker works there (i didn't recognise any of the other names, but you may know of others there)
19:27:57 <ivanm> probably the most important question: do you speak Japanese?
19:28:04 <Axman6> nope
19:28:13 <ivanm> second most important question: what does your gf think? :p
19:29:16 <ivanm> hmmm, no mention of employees, so I can't tell if I know of anyone that works there
19:29:25 <ivanm> conrad's name is familiar; probably from -cafe
19:31:42 <Axman6> well, Sarah is going to miss me, but she's going to come and visit for 10 days while i'm there
19:31:49 <kmc> tsuru?
19:31:59 <Axman6> yeah
19:32:32 <kmc> congrats on getting the job
19:32:38 <Axman6> thanks :)
19:32:48 <kmc> tell us what you think about programming in finance
19:33:34 <Axman6> yeah. i don't think my work will be overly financial, more working on a web interface and letting them use more machine i think
19:34:37 <kfish> MORE MACHINE!
19:34:54 <geheimdienst> moar masheen
19:35:00 <geheimdienst> moar mashing
19:35:18 <Axman6> MASHMASHMASH
19:35:20 <EvanR> you know if the module wasnt called Control.Monad you could be pretty sneaky in a tutorial
19:36:23 <ivanm> EvanR: how so?
19:37:04 <EvanR> you could introduce haskell completely without ever mentioning them ;)
19:37:39 <EvanR> but without Control.Monad you cant seriously get them reading or writing IO code
19:37:40 <geheimdienst> make a module which just re-exports Control.Monad
19:38:04 <geheimdienst> Control.DontPayAttentionToTheMonadsBehindTheCurtain
19:38:10 <EvanR> exactly
19:38:17 <EvanR> lol
19:39:28 <geheimdienst> jokes aside, introducing haskell without the term monads could be worth a try. i think the odd names do distract
19:39:35 <syntaxglitch> speaking of monads, I just got a bronze badge on Stack Overflow for answering questions tagged with "monads", not quite sure how I should feel about that
19:39:50 <EvanR> lol
19:39:57 <syntaxglitch> apparently I'm the only person on SO to get a "monads" badge
19:40:06 <ivanm> Axman6: so, when do you go?
19:40:30 <Axman6> end of november until the middle of february
19:41:22 <ivanm> Axman6: right, we need to give you a Haskelly farewell dinner... that is, all 3 (being generous) of us here in Canberra :s
19:42:41 <EvanR> serve haskell chicken
19:42:48 <syntaxglitch> no
19:42:50 <syntaxglitch> serve curry
19:42:53 <syntaxglitch> come on, seriously
19:43:00 <geheimdienst> i thought it was called haskell curry chicken
19:43:09 <EvanR> hm well the people have spoken
19:43:12 <geheimdienst> 3 haskellers in canberra? ivanm, axman6, and?
19:43:14 <EvanR> its just i didnt use curry
19:43:23 <ivanm> geheimdienst: sohum
19:43:23 <Axman6> sohum
19:43:26 <Adamant> is there actually haskell chicken?
19:43:28 <Adamant> I must know
19:43:34 <ivanm> @google haskell chicken
19:43:34 <lambdabot> No Result Found.
19:43:36 <Axman6> ivanm: heh
19:43:37 <sohum> hello?
19:43:42 <geheimdienst> ohai
19:43:43 <EvanR> dolio gave me the recipe in -blah and ive been eating it for the last week
19:43:48 <ivanm> sohum: talking about you, not to you :p
19:43:51 <Axman6> CANBERRA PRIDE!
19:43:56 <sohum> ah, ofc :P
19:44:23 <EvanR> Adamant: ask dolio next time hes on for it
19:44:41 <Adamant> EvanR: ah, I was thinking more like a classical recipe
19:44:47 <Adamant> still cool though
19:45:12 <EvanR> classical?
19:45:44 <EvanR> no, this is completely quantum mechanical chicken
19:46:45 <ivanm> EvanR: string theory chicken is nicer IMHO
19:47:20 * ivanm is trying to work out how to adapt a data structure written in C into Haskell
19:47:21 * geheimdienst makes chicken that has a few extra dimensions of flavor in it, curled up really tiny
19:47:30 <ivanm> geheimdienst: nom nom nom
19:47:56 * EvanR cooks some pasta, dammit
19:50:16 <ivanm> I'm trying to convert/adapt this data structure into Haskell: http://hpaste.org/41334/edge_data_structure_from_plant
19:50:36 <ivanm> make_dual() is only called - if ever - when the graph is finished
19:50:51 <ivanm> as such, how should I represent it since it'll be an all or nothing thing?
19:51:04 <ivanm> I could use "Maybe Face", but then when I want to use it I'll have them all being Just
19:51:48 <ivanm> or I could just use "undefined" to start with and then have my version of make_dual() actually supply them all with values, but that seems rather fugly :s
19:52:35 <ivanm> or maybe I should just have my version of make_dual just return a new Map rather than trying to make the face information part of the graph...
19:52:41 <ivanm> hmmm, that almost makes sense...
19:53:09 <syntaxglitch> ivanm, you could make two constructors for the base type, one of which doesn't have the optional value, then use record syntax or whatever to give all the other fields the same names
19:53:33 <syntaxglitch> then you could access the others the same way regardless, or pattern match to check for the other thing
19:54:15 <ivanm> that sounds like it would have the same problems as using Maybe: when I want to get all the faces from a list of edges I'd have to pattern match on them to check which type they are (even though it'd be an all or nothing thing)
19:54:52 * ivanm decides to go with "makeDual returns a Map EdgeID Face"
20:08:17 <JohnnyL> (map (\l@(x:xs) -> (x,length l)) . group . sort) [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
20:08:31 <JohnnyL> what is the (x:xs) considered (as a type)?
20:08:44 <JohnnyL> > :t (x:xs)
20:08:44 <lambdabot>   <no location info>: parse error on input `:'
20:10:07 <EvanR> JohnnyL: a list
20:10:22 <JohnnyL> i thought it was a list inside a tuple.
20:10:29 <EvanR> theres no comma
20:10:33 <JohnnyL> oh
20:11:08 <geheimdienst> no, the parens in this case don't mean tuple. they're basically only for grouping, like the parens you have around your lambda ... (\... -> ...)
20:12:12 <EvanR> also, haskell has no 1-tuple *runs*
20:12:33 <geheimdienst> > ((((((42)))))
20:12:34 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:12:58 <EvanR> @faq can haskell look like scheme
20:12:58 <lambdabot> The answer is: Yes! Haskell can do that.
20:14:13 <JohnnyL> that means the parens for (x:xs) is specifically used as parameter enclosure?
20:14:45 <EvanR> patterns have their own precedence stuff you need to keep straight with ( )
20:15:08 <stepcut> EvanR: http://www.liskell.org/ ;)
20:15:12 <EvanR> > (\n Nothing -> n) 3 Nothing
20:15:13 <lambdabot>   3
20:15:25 <EvanR> > (\n (Just x) -> x) 3 (Just 4)
20:15:26 <lambdabot>   4
20:15:37 <EvanR> > (\n Just x -> x) 3 (Just 4)
20:15:38 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
20:15:54 <kmc> it's the same idea as (2+3)*4
20:19:37 <JohnnyL> EvanR: Interesting, thanks
20:21:22 <MrDimwit64> hello, does anyone know how tomake a haskell irc bot roll a dice?
20:22:28 <djahandarie> That's an odd question. Do you have a Haskell IRC bot and a function to roll a die?
20:22:37 <djahandarie> It'd just be a matter of combining them if you do.
20:22:44 <MrDimwit64> like choose a random number
20:23:09 <djahandarie> What part of the question are you having a problem with specifically? The IRC bot part or random number part?
20:23:49 <stepcut> ?dice 3d6
20:23:49 <lambdabot> 3d6 => 13
20:24:14 <djahandarie> Unless you were asking for a command to make lambdabot do it. In which case ^^ :P
20:24:21 <MrDimwit64> well i know how the bot works a bit caus i did the tutorial on making an irc bot on haskell .org
20:24:25 <stepcut> ?dice 1d20+2
20:24:26 <lambdabot> 1d20+2 => 21
20:24:30 <geheimdienst> @faq Is there anything you can't do, Lambdabot?
20:24:30 <lambdabot> The answer is: Yes! Haskell can do that.
20:24:54 <MrDimwit64> ?dice 6
20:24:54 <lambdabot> 6 => 6
20:25:01 <MrDimwit64> ?dice 666
20:25:01 <lambdabot> 666 => 666
20:25:25 <stepcut> MrDimwit64: has to be of the form <number of dice>d<number of sides>+<modifier>
20:25:26 <djahandarie> MrDimwit64, ok, if I remember correctly most of your functions are in IO for that. It's just a matter of using randomRIO.
20:25:40 <kadoban> ?dice 999999d999999
20:25:41 <lambdabot> 999999d999999 => 499625558871
20:25:54 <MrDimwit64> i tried a number of things but i just got errors
20:26:09 <MrDimwit64> im using winhugs in extended mode
20:26:18 <djahandarie> Winhugs... hmmm
20:26:28 <djahandarie> I don't have much experience with hugs
20:26:36 <djahandarie> Is there a reason you're using it?
20:27:28 <MrDimwit64> i just randomly chose it because it looked good (ghci gives errors anyway
20:27:59 <MrDimwit64> theres a site called pastebin i can upload the code there
20:28:02 <djahandarie> Hugs gives nicer errors and such, but GHC is the standard, more or less.
20:28:09 <MrDimwit64> its a simple bot
20:28:10 <djahandarie> http://hpaste.org
20:28:18 <MrDimwit64> is it better
20:28:32 <djahandarie> It has Haskell syntax highlighting and also some extra stuff for Haskell
20:28:43 <djahandarie> Basically just the pastebin for this channel
20:28:45 <MrDimwit64> nice
20:30:44 <MrDimwit64> i set the channel to#haskell does this meen that it will spam all lines of code on the irdc?
20:30:49 <djahandarie> Nope
20:30:50 <MrDimwit64> *irc
20:30:54 <kmc> no, that's the point of the pastebin
20:30:59 <kmc> it might someday send the link here, but it doesn't currently
20:31:07 <djahandarie> It's just used for categorizing the paste at the moment
20:31:14 <kmc> personally i find pastebin.com cluttered and unreadable; hpaste is good but so are plenty of other sites
20:31:27 <kmc> when hpaste is down i use codepad.org usually
20:31:36 <MrDimwit64> here you go: http://hpaste.org/41335/rather_messy_irc_bot_code
20:31:42 <djahandarie> kmc, but you recommend hpaste because we are taking over the world, right?
20:31:51 <MrDimwit64> haha
20:32:10 <djahandarie> MrDimwit64, what is the error?
20:32:52 <MrDimwit64> the code is fine but it just dosent let me add dice roll function
20:32:58 <MrDimwit64> im using winhugs
20:33:25 <djahandarie> What specific code are you trying?
20:34:08 <MrDimwit64> well i removed the code caus it wasent working ill try to remember wat i did
20:34:36 <MrDimwit64> i did include random: import System.Random
20:35:01 <MrDimwit64> is this a fuction?
20:35:02 <MrDimwit64> privmsg :: String -> Net ()
20:35:02 <MrDimwit64> privmsg s = write "PRIVMSG" (chan ++ " :" ++ s)
20:35:09 <djahandarie> Yes.
20:35:18 <djahandarie> A function decleration
20:35:25 <MrDimwit64> i was trying that with the randomrio thing
20:35:45 <djahandarie> I would recommend adding it to eval
20:36:29 <MrDimwit64> but dosent eval only support 1 line of code?
20:36:55 <djahandarie> Everything can be written in one line.
20:37:08 <djahandarie> And in fact, line breaks can be inserted anywhere
20:37:17 <djahandarie> You are probably talking about do-notation though, right?
20:37:36 <MrDimwit64> sry im more used to the c(++) style of breaks (;)
20:37:42 <MrDimwit64> damn emotes
20:37:53 <MrDimwit64> its a semi-colon
20:39:25 <MrDimwit64> i got alot of the code from a tutorial
20:39:35 <MrDimwit64> i can give u the link
20:39:38 <djahandarie> I've seen it.
20:39:42 <djahandarie> You should start with a tutorial.
20:39:47 <djahandarie> There is... a lot of stuff going on in there.
20:39:57 <djahandarie> Randomly trying to hack at it will be frustrating
20:40:10 <djahandarie> http://learnyouahaskell.com
20:40:15 <djahandarie> I recommend that
20:40:47 <stepcut> here is my irc bot code -> http://patch-tag.com/r/stepcut/happstackDotCom/snapshot/current/content/pretty/IrcLog.hs
20:41:02 <stepcut> it's suprising complex for a bot that does not actually support any user driven commands yet :)
20:41:31 <stepcut> it is multithreaded though
20:41:46 <MrDimwit64> should i just do a bot in c++ insted?
20:41:59 <stepcut> mine needs some documentation :-/
20:42:02 <djahandarie> MrDimwit64, if your goal is to write a bot, then do it in whatever language you are familiar with.
20:42:04 <MrDimwit64> whitch is better at whitch
20:42:23 <MrDimwit64> anybody heard of game maker?
20:42:24 <djahandarie> Haskell can write a bots just fine. For example, lambdabot.
20:42:44 <stepcut> haskell is awesome for bots
20:42:56 <MrDimwit64> i used gm to start me off at c++ style ccode
20:43:00 <djahandarie> MrDimwit64, Haskell requires learning first. It is nothing at all like C++.
20:43:29 <MrDimwit64> u dont c++ requires learning too
20:43:48 <djahandarie> I mean, from where you are at this point, Haskell will still require learning.
20:43:54 <djahandarie> You can't use most of your previous knowledge.
20:44:32 <MrDimwit64> i have my bot ready if anyone wants to see what exactly it does
20:45:11 <MrDimwit64> theres a irc channel on infinity irc called #bot where u can test em
20:45:27 <MrDimwit64> * correction tis #bots
20:46:14 <hush2> uhh orange background
20:46:52 <djahandarie> stepcut, when I was writing an IRC bot ages ago, I ended up doing StateT ReaderT IO with newtype deriving, kind of like you.
20:47:12 <djahandarie> It was a concurrent-friendly version of StateT which I used in place of MVars in the ReaderT
20:47:20 <stepcut> djahandarie:  nice
20:48:04 <MrDimwit64> i was going to write my bot in mirc untill i relised that it was too limited
20:48:28 <djahandarie> stepcut, make sure you add the ability to reconnect automatically when the connection fails. Learn the lesson from lambdabot :P
20:48:55 <stepcut> djahandarie: I think that the reconnection code is half the code
20:49:01 <MrDimwit64> how to learn things from lambdabot?
20:49:04 <stepcut> djahandarie: seems to be quite reliable though
20:49:21 <djahandarie> Oh yeah, didn't look
20:49:31 <djahandarie> MrDimwit64, lambdabot has a god-awful code base, don't learn anything from it
20:49:44 <MrDimwit64> lol
20:49:54 <MrDimwit64> no examples i geuss?
20:49:58 <stepcut> djahandarie: in my design, you can register a bunch of handlers, and each handler runs in a separate thread
20:50:07 <Axman6> @google roll your own irc bot haskell
20:50:08 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
20:50:08 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
20:50:14 <Axman6> MrDimwit64: use that
20:50:18 <djahandarie> Axman6, he already has.
20:50:29 <Axman6> once you've learnt haskell to a reasonable beginner level
20:50:34 <djahandarie> He hasn't done that.
20:50:37 <Axman6> well then, don't use that
20:50:42 <MrDimwit64> that makes up most of my code LOL
20:50:43 <Axman6> learn haskell
20:50:45 <djahandarie> Too late.
20:50:53 <djahandarie> (Re: don't use that)
20:51:06 <djahandarie> It's never too late to learn Haskell!
20:51:20 <MrDimwit64> i feel an awefull lot of tention building up
20:51:39 * EvanR gives learn you a haskell for great good to his great grand father on his death bed. lets see if he can cut it
20:51:45 <djahandarie> MrDimwit64, sorry, I was just trying to be funny.
20:51:52 <djahandarie> I usually fail at this
20:52:14 <MrDimwit64> lol
20:52:44 <MrDimwit64> imagine writing an irc bot in assembally :o
20:53:27 <djahandarie> Imagine writing a video encoder in assembly.
20:53:32 <MrDimwit64> u would need bout 20 years experiance with asm
20:53:38 <MrDimwit64> for both
20:53:49 <Axman6> not really
20:53:59 <djahandarie> The lead dev for x264 isn't even 20 years old :P
20:54:10 <djahandarie> Oh wait, maybe he is by now, dunno
20:54:16 <LegendaryPenguin> how many lines of assembly would an irc bot take if  u developd it from scratch
20:54:16 <Axman6> in face, a video encoder would probably not be all that hard, they're usually defined in very low level ways, which usually translate nicely to ASM
20:54:39 <djahandarie> Axman6, it was suppose to be a joke. ;)
20:54:40 <MrDimwit64> imagine writing a "hello world" in binary lol
20:54:52 <Makoryu> （　≖‿≖）
20:55:30 <MrDimwit64> imagine writing the matrix in asm
20:55:48 <MrDimwit64> or mirc
20:56:12 <djahandarie> Maybe this should be in #haskell-blah , considering how far off-topic we have gotten
20:56:26 <MrDimwit64> haha yes
20:56:51 <MrDimwit64> no it shold be #geeks try to make jokes
20:56:55 <kmc> aren't many video encoders designed to be easily implementable by logic hardware?
20:57:19 <djahandarie> Hardware encoders suck anywho
20:57:53 <heatsink> Some parts are
20:58:37 <MrDimwit64> i rmrmber at my old highschool - hacking old "harmless" dos viruses with notepad++
20:58:37 <heatsink> CABAC consists largely of lookup tables, state transitions, and appending bits to output
20:59:41 <MrDimwit64> one of my friends hacked techno.com and turned it into horny.com :o
20:59:53 <MrDimwit64> .com = dos app
21:00:00 <djahandarie> MrDimwit64, #haskell-blah
21:00:04 <djahandarie> That is actually a channel btw
21:00:40 <MrDimwit64> ssssooooooo how do i make my bot roll a dice?
21:00:49 <Axman6> how do you think?
21:01:01 <MrDimwit64> $dice?
21:01:06 <Axman6> you'd be able to tell us if you'd learnt haskell before trying to write things in haskell ;)
21:01:06 <djahandarie> MrDimwit64, randomRIO is the function you need
21:01:51 <djahandarie> MrDimwit64, then use (>>=) in the Net type (which can be lifted from IO) to pass it to privmsg
21:02:32 <MrDimwit64> like this? io :: IO a >>= Net a
21:02:49 <djahandarie> That isn't close to what I meant.
21:02:50 <Axman6> -_-
21:02:53 <djahandarie> >>= is a value-level function
21:03:01 <ivanm> what is a good way of having a "circular" data structure, e.g. be able to state what is the next edge clockwise around a node
21:03:18 <ivanm> use a Sequence and keep shifting values left or right?
21:03:20 <Axman6> ivanm: a zipper?
21:03:47 <ivanm> Axman6: hmmm... didn't recall zippers being able to go around to the beginning again
21:03:52 * ivanm goes off to have a look
21:03:58 <Axman6> it's easy to implement though
21:04:24 <djahandarie> ivanm, see PointedList
21:04:35 <MrDimwit64> stepbot was probibly written in logo LOL
21:04:37 <djahandarie> Unless you want to write it yourself
21:05:50 <MrDimwit64> should i do this: eval     "BOTS NAME GOES HERE, dice"               = privmsg RandomRIO (6)
21:06:12 <djahandarie> No, you really need to learn Haskell.
21:06:20 <Axman6> MrDimwit64: please go and follow a haskell tutorial
21:06:26 <Axman6> @where lyah
21:06:26 <lambdabot> http://www.learnyouahaskell.com/
21:06:28 <Axman6> like that one
21:06:34 <ivanm> djahandarie: oooohhh...
21:06:42 <MrDimwit64> wow, i really suck that much? LOL
21:06:47 <djahandarie> MrDimwit64, if (randomRIO 6) evaluated to a String that would work
21:06:58 <djahandarie> But it evaluates to an  IO Integer
21:07:04 <djahandarie> Which is nothing like what you need
21:07:32 <ivanm> djahandarie: though the use of a list appears to be inefficient :s
21:07:38 * ivanm might clone it using a Sequence
21:07:52 <djahandarie> It's a zipper...
21:08:00 <MrDimwit64> what would i need?
21:08:01 <ivanm> it's using reverse everywhere!
21:08:03 <djahandarie> Though, not sure what you are planning on doing
21:08:04 <djahandarie> Oh
21:08:27 <ivanm> admittedly, I'm highly unlikely to be having lists long enough to make that a problem...
21:08:39 <fengshaun> how can I determine the fixity of (!!)?
21:08:41 <ivanm> but still...
21:08:43 <MrDimwit64> it returns a random value between 1 and 6
21:08:46 <ivanm> fengshaun: :info (!!)
21:08:50 <ivanm> (in ghci)
21:08:55 <fengshaun> ivan, thanks
21:09:00 <djahandarie> MrDimwit64, look at the types
21:09:01 <ivanm> np
21:09:06 <ivanm> @type randomRIO 6
21:09:07 <lambdabot> forall a. (Num a, Random a) => IO a
21:09:15 <ivanm> it does _not_ return a value
21:09:25 <ivanm> it returns an action that - when evaluated - will return a value
21:09:34 <fengshaun> ivan, :info just gives me a type
21:09:43 <fengshaun> the* type, not the fixity
21:09:52 <djahandarie> MrDimwit64, but really, read the tutorial, no one here wants to walk you through the hours it will take to learn this from scratch
21:09:56 <djahandarie> It's already all in the tutorial
21:10:22 <ivanm> fengshaun: huh, thought it gave fixity
21:10:24 <Axman6> MrDimwit64: we're more than happy to help you with the tutorial if you get stuck, but we won
21:10:37 <Axman6> won't waste time teaching you stuff it can teach you much more easily
21:10:50 <MrDimwit64> i dont need to know all of it
21:10:51 <ivanm> Axman6: heh, I was wondering which competition we'd won :p
21:10:57 <djahandarie> MrDimwit64, you do.
21:11:05 <ivanm> MrDimwit64: but what you do need to know is best expressed in a pre-existing tutorial
21:11:05 <MrDimwit64> :(
21:11:14 <Axman6> MrDimwit64: lyah doesn't teach you all of it, it teaches you the basics, which is what you lack
21:11:26 <MrDimwit64> which one do i look at
21:11:28 <ivanm> and you can stop or skip over the chapters on stuff you don't need to know, like arrows, combinator parsing, monad transformers, etc.
21:11:30 * djahandarie has lost what 'it' is here
21:11:32 <Axman6> @where lyah
21:11:32 <lambdabot> http://www.learnyouahaskell.com/
21:11:37 <ivanm> @where wikibook
21:11:37 <lambdabot> http://en.wikibooks.org/wiki/Haskell
21:11:38 <ivanm> @where yaht
21:11:39 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
21:11:52 <Axman6> no!
21:11:54 <Axman6> :P
21:12:01 <MrDimwit64> WHICH ONE DO I CHOOSE?!?!?!
21:12:21 <ivanm> MrDimwit64: LYAH is similar to _why's poignant guide to ruby
21:12:24 <kmc> whichever you like best
21:12:26 <kmc> read a bit of each
21:12:33 <kmc> also
21:12:34 <kmc> @where RWH
21:12:34 <ivanm> so if you like/don't mind crazy style tutorials, go with that (it's newer, etc.)
21:12:34 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
21:12:44 <ivanm> kmc: I was trying to avoid suggesting that
21:12:53 <kmc> why?
21:13:05 <mee> RWH rocks
21:13:07 <ivanm> because it would probably be too advanced for MrDimwit64
21:13:17 <Axman6> MrDimwit64: for people who know a little haskell first
21:13:28 <Axman6> uh, mee, not MrDimwit64 
21:13:44 <ivanm> Axman6: or for people who know how to program well in other languages first
21:13:58 <djahandarie> I still think there should be a tutorial that assumes no understanding of programming
21:14:07 <djahandarie> Just maybe like algebra 1 high school
21:14:18 <Axman6> lyah comes close
21:14:26 <Axman6> or, maybe not
21:14:34 <ivanm> djahandarie: but then you spend too much time talking about what a computer is... :p
21:14:51 <djahandarie> Axman6, closer than any other Haskell tutorial, yeah
21:15:11 <djahandarie> ivanm, I think the way Haskell works makes programming really easy to think and reason about compared to anything else
21:15:26 <ivanm> djahandarie: don't disagree with you there
21:16:02 <djahandarie> Which is why it would be neat if we could steal the HS kids right off the bat ;)
21:16:16 <djahandarie> And then it'll be impossible for them to learn C++. Mission accomplished.
21:16:23 <ivanm> djahandarie: hooray!!!
21:16:45 <ivanm> anyone here feel like discussing design of graph libraries atm (whilst I'm actually doing work for once)?
21:16:58 <MrDimwit64> omg join flood :O
21:17:28 <MrDimwit64> wow
21:17:39 <djahandarie> ivanm, sure! But I know nothing about them
21:17:40 <ivanm> MrDimwit64: see how popular we are? :p
21:17:40 <ivanm> dammit, I _had_ to say that as the split occurred and all those people left again...
21:17:50 <ivanm> djahandarie: OK, do you know what a planar graph is?
21:17:58 <djahandarie> Yes
21:18:17 <MrDimwit64> wat just happend
21:18:24 <ivanm> MrDimwit64: a net split
21:18:27 <ivanm> look it up on wikipedia
21:18:32 <MrDimwit64> kk
21:18:40 <ivanm> OK, so I'm trying to copy the data structure implementation for planar graphs based off the one in Brendan McKay's plantri
21:19:03 <ivanm> part of the design is that the edges know which edge is next/previous going around the node it comes from
21:19:46 <ivanm> now, ideally IMHO, that should be part of how the node is defined: it contains the edges in a zipper or some such structure with the edges in clockwise order
21:20:02 <ivanm> however, that means that if you want to follow the chain of edges you have to keep referring back to the node
21:20:24 <MrDimwit64> epic netsplit: http://upload.wikimedia.org/wikipedia/commons/7/79/Netsplit.png
21:20:42 <ivanm> so should I do that, or follow the structure more fully and keep that information as part of the edge info/definition?
21:21:48 <ivanm> the actual C implementation is http://hpaste.org/41334/edge_data_structure_from_plant
21:22:07 <ivanm> (it then has a vector of nodes, a vector of edges and a vector of faces)
21:22:11 <ivanm> s/vector/array/g
21:23:01 <djahandarie> A zipper is usually a wrapper around a node and then its context
21:23:07 <djahandarie> Why does that not work?
21:23:18 <Axman6> it'll involve minimal reverses
21:24:23 <ivanm> well, using a Seq rather than a zipper around a list sounds better for me
21:25:09 * ramkrsna is away: Oh! Crap!!!, Bat signal is flashing, Gotta go.
21:25:27 <ivanm> but I'm just trying to work out if I should follow "upstream" on this (and not care about the order of the edges that the node "contains") or if I should use a zipper/Seq
21:28:30 <endojelly> so the do notation does more than just desugaring into >>= and >> ?
21:28:57 <ivanm> it does?
21:28:59 <djahandarie> ivanm, hm. Didn't understand what you meant by not caring about the order
21:29:01 <ivanm> I thought that's all it did
21:29:04 <kmc> endojelly, it also invokes some "case" and "fail", if you have patterns that might not match
21:29:10 <dmead> do is syntactic sugar
21:29:14 <kmc> @undo do { Just x <- y }
21:29:14 <lambdabot>  Parse error at "}" (column 18)
21:29:15 <ivanm> djahandarie: well, use a Set or something
21:29:16 <dmead> it doesn't actually do anything
21:29:20 <dmead> ;)
21:29:23 <kmc> @undo do Just x <- y; return ()
21:29:23 <lambdabot> y >>= \ a -> case a of { Just x -> return (); _ -> fail ""}
21:29:26 <ivanm> kmc: oh, right
21:29:44 <ivanm> djahandarie: e.g. Map Node (Set Edge); Map Edge EdgeInfo
21:30:05 <kmc> endojelly, http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
21:30:10 <kmc> it gives the translation
21:30:18 <endojelly> thanks
21:30:35 <kmc> or rather, a translation — @undo uses a different one
21:31:23 <kmc> anyone know why it's spec'd with let rather than case?
21:31:35 <endojelly> it seems that I can't replace >>=, return and >> with definitions of different types
21:31:48 <endojelly> (I hid them when importing the Prelude)
21:31:54 <endojelly> test2 = foo >>= (\x -> bar)
21:31:56 <endojelly> works fine, but
21:32:00 <endojelly> test3 = do foo bar
21:32:02 <kmc> oh, you need -XNoImplicitPrelude for that
21:32:06 <endojelly> ah, paste problem
21:32:06 <endojelly> do
21:32:08 <endojelly>   foo
21:32:10 <endojelly>   bar
21:32:16 <endojelly> fails type checking
21:32:17 <kmc> by default it refers to Prelude.>>= etc.
21:32:33 <endojelly> kmc, oh, it works, thanks!
21:32:43 <kmc> endojelly, http://haskell.cs.yale.edu/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#rebindable-syntax
21:33:42 <ivanm> kmc: seems to use explicit pattern-matching on dummy functions (which IIRC is converted to case-statements)
21:33:57 <djahandarie> ivanm, if there is no order in the edges how do you plan on moving between them? 
21:34:38 <ivanm> djahandarie: that's what I'm asking: should I keep the order in the "Map Node (... Edge)", or follow the original C code and have the order stored in the edges themselves?
21:34:38 <djahandarie> Shouldn't the Zipper be based on the node's ADT, not the edge's?
21:34:46 <djahandarie> Oh
21:34:59 <endojelly> (>>=) :: Ticks n a -> (a -> Ticks m b) -> Ticks (Add n m) b
21:35:04 <endojelly> I played around with type families
21:35:11 <ivanm> [where "..." is a placeholder for whatever datastructure I use to hold the edges]
21:35:17 <endojelly> do you know if I could somehow transofrm that into a real monad?
21:35:43 <ivanm> preflex: seen chrisdone
21:35:43 <preflex>  chrisdone was last seen 7 days, 8 hours, 50 minutes and 51 seconds ago, saying: <private message>
21:36:02 <endojelly> the idea is that ticks are added together
21:36:27 <endojelly> so that the type of a monadic expression is ultimately the sum of the ticks of all functions used
21:36:30 <endojelly> and it works
21:36:35 <djahandarie> ivanm, do it both ways and see which is nicer. :P I'd probably use a sequence over a list though
21:36:36 <endojelly> but I have to hide the Prelude
21:36:43 <MrDimwit64> kk im going now bye
21:36:52 <endojelly> the ticks are type-level only
21:37:27 <ivanm> djahandarie: right; the "keep the info in the edges" sounds like it would be slightly more efficient in terms of pure edge traversal, but inefficient in terms of having more data to keep in sync
21:38:04 <endojelly> and I don't know enough about type family magic yet to know if that somehow translates into a normal Monad, or if that's a more generic definition
21:38:34 <ivanm> hmmm... though if I use a zipper or a Seq, doing something like "previousEdge n e" would be O(|number of edges at n|) as opposed to O(1) if it's kept in the edge info
21:39:54 <Saizan> endojelly: if the type changes it can't
21:40:08 <endojelly> Saizan, ok, so what I did there isn't a Monad anymore
21:40:21 <ddarius> It's an indexed or parameterized monad.
21:40:38 <endojelly> it's a pity, because it behaves exactly like one, it's just additional type level stuff so that I can enforce some other constraints
21:40:49 * ivanm might go with the "both" option
21:40:51 <endojelly> ddarius, indexed monad sounds good
21:41:23 <djahandarie> (You can have an indexed version of a lot of things)
21:41:29 <endojelly> so would you say using NoImplicitPrelude in that case is a good way to do it?
21:41:34 <endojelly> seems a bit ugly...
21:41:35 <djahandarie> It'd be nice if it was easier to add type-level state to things
21:42:08 <endojelly> and I'll also have problems mixing my modules, won't I?
21:44:12 <endojelly> not to mention that I'd like to add state etc. so I'd like to use monad instances from the standard library...
21:44:35 <djahandarie> ddarius, isn't a join on an indexed monad kind of like a composition of an arrow in a category?
21:45:58 <ddarius> On potential view of indexed monads is instead of a monoid object in the category of endofunctors, you have a category object in the category of endofunctors.
21:46:18 <djahandarie> So I'm correct?
21:46:45 <ddarius> Yes.
21:48:26 <endojelly> so, basically, what I want to do is impossible?
21:48:45 <djahandarie> No, I think I'm wrong
21:49:11 <djahandarie> Hmmmm
21:50:45 <djahandarie> ddarius, I don't think we're working with endofunctors anymore
21:51:21 <ksf> http://downforeveryoneorjustme.com/code.haskell.org
21:51:36 <ivanm> hooray, pointedlist failed to build due to duplicate type sigs...
21:51:37 <ksf> someone feed the hamsters!
21:51:37 <ivanm> *sigh*
21:52:00 <ivanm> is Jeff Wheeler on here?
21:53:25 <ivanm> preflex: seen jeffwheeler
21:53:26 <preflex>  jeffwheeler was last seen on #haskell 17 days, 23 hours, 39 minutes and 25 seconds ago, saying: dolio: haha, is it?
21:57:03 * ramkrsna is back (gone 00:31:53)
21:58:29 <MachinShin> so this should be fun, i started reading 'real world haskell' yesterday. /me hopes haskell isn't has scary as reading some code makes it look :) 
21:59:08 <endojelly> "This preprocessor expands a Haskell program using ixdo notation into a Haskell program using the indexed monad bind operator (>>>=). It also serves as an example for the preprocessor-tools package."
21:59:23 <deech> Learn You A Haskell is also recommended http://learnyouahaskell.com/
22:00:06 <MachinShin> deech: yah.. i tried that sometime back.. couldn't get into it.. 
22:00:30 <ivanm> @where wikibook
22:00:30 <lambdabot> http://en.wikibooks.org/wiki/Haskell
22:00:32 <ivanm> @where yaht
22:00:33 <lambdabot> PDF: http://darcs.haskell.org/yaht/yaht.pdf Wikibook: http://en.wikibooks.org/wiki/Haskell/YAHT
22:00:52 <ivanm> or else there's Programming in Haskell, The Craft of Functional Programming, School of Expression, etc.
22:01:22 <MachinShin> something wrong w/ RWH? 
22:01:42 <deech> MachinShin: Neither could I. It starts off with language basics while RWH dives into practical application. Depends on your learning style. RWH worked wonders for me.
22:02:13 <ivanm> MachinShin: it's aimed more at intermediate/advanced users of haskell
22:02:18 <ivanm> not really for beginners
22:02:34 <ivanm> though it is also meant to be aimed at people who know how to program in other languages
22:02:39 <MachinShin> deech: yah, same here.. 
22:02:55 <ivanm> deech: I just don't like the craziness of LYAH
22:02:56 <MachinShin> ivanm: which i do, so that should be fine
22:03:08 <deech> ivanm: I was a beginner and it worked better for me because I needed to see code that does practical things without knowing exactly how it does it.
22:03:46 <ivanm> *shrug* I learnt Haskell by converting bird's sudoku solver into a partial latin square completor/generator whilst reading Craft ;)
22:03:53 <vircuser> Greetings haskell users! What is the best way to ask for help in this channel, just copy/paste code?
22:04:03 <Adamant> copy and paste to a pastebin
22:04:14 <deech> vircuser: http://hpaste.org
22:05:10 <ksf> endojelly, you can also use -XNoImplicitPrelude.
22:05:20 <ksf> do notation will use whatever >>= is in scope, then.
22:05:45 <_Mitar> i made library for interface to Lego Mindstorms NXT
22:05:56 <_Mitar> where should I put it in the module hierarchy?
22:06:09 <dobblego> is record selector syntax in a pattern match just a guard for that record?
22:06:32 <ksf> Word.Dominance.Weapons.Robots.LegoMindstorms
22:06:51 <ivanm> methinks ksf means World, not Word
22:06:56 <ksf> yep.
22:07:09 <ivanm> more realistically, find out where the other robotics stuff is
22:07:10 <ksf> dobblego, nope guards are functions which return true or false
22:07:36 <ivanm> gah, RMP just goes in System
22:07:36 <ksf> your ADT is matches as usual, it's just syntactic sugar.
22:08:00 <dobblego> is it matched and a record value is set?
22:08:00 <ksf> Robotics.Mindstorms sounds good
22:08:30 <ksf> patterns don't set anything, they bind variables.
22:08:37 <deech> I've been looking at the alioth benchmarks and wondering why Haskell is relatively slow on the binary-trees challenge. 
22:08:50 <dobblego> let f x@(T { x = y }) -- what is this?
22:09:18 <deech> Is it that constantly mutating trees overloads the garbage collector?
22:09:24 <ksf> binds the variable "x" to the value of record field "y"
22:09:44 * ivanm figures he'll call it a day and head off home
22:09:45 <ivanm> bye all
22:10:03 <ksf> with -XNamedFieldPuns you can write x@( T {y}), which is the same as y = y
22:10:15 <ksf> hmm. you might have a problem with your duplicate x, there.
22:10:49 <_Mitar> ksf: Robotics.NXT?
22:11:08 <ksf> if that's a better fit then yes.
22:11:16 <ksf> I never used mindstorms.
22:11:20 <dobblego> what would x@( T { y = y }) achieve?
22:11:25 <ksf> stopped at the control centre.
22:11:31 <_Mitar> but there is no Robotics currently
22:11:44 <_Mitar> http://hackage.haskell.org/packages/archive/pkg-list.html#cat:robotics
22:11:47 <_Mitar> this one is in "system"
22:11:49 <ksf> create it, other stuff should probably be there, too.
22:12:05 <_Mitar> ok
22:12:07 <ksf> there's way too much in System.
22:12:15 <_Mitar> ok
22:12:22 <ksf> everything not directly relating to an OS or such shouldn't be there.
22:13:07 <ksf> ( we need hare to work properly on all sources, so that we can clean up all that namespace mess )
22:13:44 <_Mitar> hare?
22:13:55 <_Mitar> yes, this is why I am asking
22:13:58 <ksf> http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
22:14:03 <djahandarie> ddarius, so you have  m s1 s2 a -> (a -> m s2 s3 b) -> m s1 s3 c  . Doesn't this mean there are two functors from C -> C where a,b \in C? But the functors can't be composed, so they aren't actually endo
22:14:09 <_Mitar> because namespaces are important
22:14:53 <ksf> well, should Maybe be in Data or in Control?
22:15:11 <_Mitar> yes ;-)
22:15:13 <Axman6> Monad!
22:15:18 <_Mitar> i am used to Data
22:15:34 <ksf> Concurrent sould probably be ripped out of Control to the top level.
22:15:56 <ksf> Text.Parser is inane, too.
22:16:26 <ksf> but then everything is better than prefixing everything with org.haskell
22:17:15 <djahandarie> (And if they aren't endo then it can't be a category object in End(C))
22:17:17 <djahandarie> Or something
22:17:24 <djahandarie> Ugh I need to go to bed, night
22:18:03 <rryan> I'm trying to get better at Haskell by using it for every time I need some dumb shell script. Anybody have suggestions on how to improve this http://pastebin.com/Jc57rPma
22:18:14 <rryan> It just takes a file and splits it into a series of files with N lines each until it runs out of lines.
22:18:47 <MachinShin> fst & snd seem kinda pointless.. they only work for pairs, wtf would i do for nested tuples? recurse? 
22:19:02 <Axman6> who uses nested tuples?
22:19:20 <ksf> itSeemLikeWeAreLookingAtAFormerJavaProgrammer
22:19:23 <MachinShin> i dunno, maybe i would? :) 
22:19:30 <MachinShin> ksf: ugh, gods, no. ihate java
22:19:54 <rryan> ksf: thankfully, no.. this is me mimic'ing LYAH
22:19:56 <MachinShin> it's the 2nd most verbose language i've ever seen
22:20:12 <Axman6> MachinShin: i can
22:20:22 <Axman6> i can't possibly think of a time i'd like to use nested tuples
22:20:45 <Axman6> (though, i guess technically my Stream fusion stuff i've been working on uses them, but you never see them)
22:20:51 <dobblego> it is often appropriate to use a HList
22:20:52 <ksf> well, I might be too used to x:xs style names.
22:21:09 <ksf> visually, I can barely make out the code between all those names.
22:21:10 <MachinShin> Axman6: well.. that's true,i don't think i can either :)  but still, how would i access the members of it? 
22:21:27 <rryan> ksf : yea, I agree
22:21:29 <rryan> it isn't pretty
22:21:42 <rryan> I'd like to keep the names descriptive though
22:21:59 <Axman6> MachinShin: pattern matching
22:22:11 <MachinShin> ah. that makes sense.
22:22:21 <rryan> ksf : anything glaringly dumb besides the names ? 
22:22:33 <rryan> did I write something that's O(e^n)  ? 
22:22:42 <rryan> will that tail call work ? 
22:22:50 <ksf> those do return () s
22:23:09 <ksf> return () is enough
22:23:14 <rryan> ksf: k
22:23:16 <ksf> ...and no need for the second case.
22:23:48 <ksf> hmmm
22:23:55 <rryan> you mean because I know that I'm not calling it any other way than with an infinite list ? 
22:24:07 <deech> rryan: Also I would keep the splitAndWriteLines function pure.
22:24:34 <rryan> deech : good point
22:24:46 <ksf> you can factor out splitting a list into sublists, and then zip them with your filenames.
22:24:54 <rryan> yea, makes sense 
22:24:56 <ksf> then foldM over the resulting list, writing stuff.
22:25:49 <ksf> :t foldM
22:25:50 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
22:26:00 <ksf> Control.Monad iirc, not prelude.
22:26:21 <ksf> :t foldM_
22:26:22 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m ()
22:26:28 <ksf> duh, I mean mapM
22:26:36 <ksf> :t mapM_
22:26:37 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
22:27:24 <rryan> gotcha
22:27:36 <deech> rryan: And I don't know if there is a pre-built function that handles this, but I would also write a variation of foldl that n elements at a time from the initial list.
22:34:15 <haskell-novice> http://hpaste.org/41337/schoolwork
22:34:44 <haskell-novice> phew, that pastebin is nice ive never used one before
22:36:12 <haskell-novice> bleh -- the rWS line is supposed to read && (rWS((split(x:xs) (length(x:xs) / 2) !! 0)) == rWS((split(x:xs) (length(x:xs) / 2) !! 1)))
22:36:39 <ksf> > let foo n = map (map snd) . groupBy ((==) `on` fst) . zip (cycle (replicate n False ++ replicate n True)) in foo 3 [1..20]
22:36:40 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
22:37:03 <Axman6> haskell-novice: you can't use length xs / 2, length returns an Int, which you can't use (/) on, only div
22:37:20 <ksf> well, writing a fold that does arithmetic is probably easier.
22:37:45 <Jonno_FTW> @src on
22:37:46 <lambdabot> (*) `on` f = \x y -> f x * f y
22:38:10 <kamatsu> can anyone provide me of a definition of "Syntactically built" data structures?
22:38:16 <kamatsu> wrt Haskell
22:38:18 <kadoban> is there a handy guide of the major changes between haskell 98 and haskell 2010?
22:38:22 <dancor> splitN n xs = l : splitN n r where (l, r) = splitAt n xs
22:38:30 <ddarius> kamatsu: Whoever is using the term can.
22:38:32 <ksf> there's no major changes.
22:38:47 <kamatsu> ddarius: andy gill is, but he's not explaining what it means. Googling returns his paper >_>
22:38:56 <kamatsu> (the paper I am trying to understand)
22:39:12 <kmc> kadoban, http://www.haskell.org/pipermail/haskell/2009-November/021750.html
22:39:45 <ksf> dancor, why write a recursion when you have primitives?
22:40:09 <kadoban> thanks
22:40:12 <kmc> kadoban, not much changed in 2010, but there's supposed to be a new revision every year
22:40:20 <dancor> ksf: i can't find a good way to do it
22:40:28 <kadoban> ah, i see
22:41:16 <FunctorSalad> that looks like the semi-notorious 'chunks' function ...
22:41:35 <FunctorSalad> minus termination ;)
22:42:01 <stepcut> FunctorSalad: sounds like a job for unfoldr!
22:42:15 <dancor> http://hackage.haskell.org/packages/archive/split/0.1.2.1/doc/html/Data-List-Split.html
22:42:39 <kmc> :t (# 'x' #)
22:42:40 <lambdabot> (# Char #)
22:42:49 <kmc> what's the point of these unboxed singleton tuples?
22:43:01 <kmc> :k (# Char #)
22:43:02 <lambdabot> (#)
22:43:40 <FunctorSalad> kmc: hehe
22:43:43 <kmc> :k (#)
22:43:43 <lambdabot> parse error on input `)'
22:43:45 <kmc> :k (##)
22:43:46 <lambdabot> Not in scope: type variable `##'
22:43:46 <kmc> :k (#,#)
22:43:47 <lambdabot> ? -> ? -> (#)
22:44:13 <kmc> can i even write the type constructor of unboxed singleton tuples?
22:44:15 <FunctorSalad> kmc: maybe for consistency of the family
22:44:33 <FunctorSalad> (for code generation)
22:45:24 <FunctorSalad> (not 'consistency' in the 'no contradiction provable' sense)
22:46:04 <dancor> Data.List.Split.chunk seems a bit crazy, not sure if it's better for long lists than something more naive
22:49:25 <deech> rryan: still there?
22:49:26 <FunctorSalad> stepcut: seriously or because I'm the resident everything-looks-like-a-list-coalgebra type? ;)
22:50:37 <_Mitar> what is english term for distance between axes of a car?
22:51:24 <_Mitar> (i have to name haskell variable like that)
22:51:57 <deech> rryan: I've added a suggestion to your pastebin script. Good luck!
22:54:48 <Cale> http://en.wikipedia.org/wiki/Wheelbase
22:56:00 <_Mitar> thanks!
22:57:10 <ksf> http://www.doc.ic.ac.uk/~ws506/tryzeno/   !!
22:57:14 <ksf> zomg
22:57:22 <ksf> TDD people eat that.
22:59:28 <haskell-novice> http://hpaste.org/41338/schoolwork this is almost working I can't tell if the split function im using is wrong, syntax or what
22:59:33 <Cale> It assumes finiteness of data structures, it seems.
22:59:43 <FunctorSalad> "prop_reverse_idem xs = 
22:59:43 <FunctorSalad>   reverse (reverse xs) === xs"
22:59:50 <FunctorSalad> that isn't idempotence
23:00:08 <FunctorSalad> 'involutivity' or some such
23:00:24 <ksf> shhh. we don't serve non-ultrafinitists around here.
23:00:43 <Cale> haskell-novice: It looks like there are some parens missing
23:01:02 <FunctorSalad> and it eliminates bottoms but maybe it deliberately overlooks that
23:01:06 <Cale> haskell-novice: around x:xs in several places
23:01:15 <FunctorSalad> ksf: what does that have to do with ultrafinitizm?
23:01:19 <Cale> haskell-novice: split x:xs means (split x) : xs
23:01:30 <ksf> well, it's obviously false for infinite lists.
23:01:34 <Cale> FunctorSalad: Infinite lists don't exist!
23:01:36 <ksf> I thought that was what you meant.
23:01:42 <haskell-novice> doh
23:01:59 <FunctorSalad> my first complaint was just about the identifier
23:02:02 <FunctorSalad> _idem
23:02:04 <Cale> haskell-novice: Though you're not really getting anything out of pattern matching against (x:xs) there
23:02:23 <Cale> haskell-novice: You could just as well use xs as your pattern, so long as it's after the empty list case.
23:02:34 <FunctorSalad> but don't get my nitpicking wrong, it seems cool :)
23:03:19 <Cale> haskell-novice: computing the length of a list is expensive -- computing it 3 times for every recursive step of a function is a *bit* wasteful.
23:03:42 <FunctorSalad> how does it come up with inductive hypotheses?
23:04:08 <Cale> FunctorSalad: He was talking about my comment
23:04:22 <haskell-novice> Well I bought a fast computer, so that I could write bad code -- as long as it at least worked.
23:04:37 <FunctorSalad> Cale: ah. I misunderstood that comment of yours
23:04:49 <haskell-novice> =)
23:06:03 <haskell-novice> can I only use the !! if im trying to pull list elements? does it not work on tuples
23:06:26 <haskell-novice> ([a],[b]) !! 0 , I want that to be [a]
23:06:33 <Cale> haskell-novice: Right.
23:06:38 <FunctorSalad> (it's true up to one side being less defined than the other... don't know if this is true in general if you do a traditional inductive proof (for finite lists))
23:06:47 <Cale> haskell-novice: fst and snd extract the two parts of a pair
23:06:55 <Cale> haskell-novice: for larger tuples, just pattern match
23:07:01 <kmc> !! only works on lists, you can see from its type:
23:07:04 <kmc> :t (!!)
23:07:05 <lambdabot> forall a. [a] -> Int -> a
23:07:14 <Cale> :t fst
23:07:15 <lambdabot> forall a b. (a, b) -> a
23:07:15 <Cale> :t snd
23:07:16 <lambdabot> forall a b. (a, b) -> b
23:07:36 <haskell-novice> I see. Thank you.
23:08:25 <haskell-novice> It compiled!!! Horray!
23:13:44 <Cale> http://blog.sigfpe.com/2010/11/statistical-fingertrees.html -- cool use of fingertrees :)
23:14:59 <Cale> and it suggests that perhaps a lot of other problems where numerical stability is a concern can be tackled in a similar way
23:25:52 <pelotom> data parallel haskell looks super potential-ful
23:38:09 <Schalken> Is there a natural number version of Integer somewhere? All I can find is Data.Nat, for which I can't figure out whether it is as efficient as Integer.
23:40:43 <pelotom> Schalken: I think you want Data.Number.Nat
23:40:43 <Saizan> there isn't afaik
23:41:42 <haskell-novice> More list questions cheer!! http://hpaste.org/41340/schoolwork
23:42:13 <Schalken> pelotom: Ah, yes I meant Data.Number.Nat, not Data.Nat. Is it really just an unsigned version of Integer?
23:43:02 <pelotom> Schalken: it's statically incapable of representing a negative number... I'm not sure about its efficiency
23:44:41 <pelotom> you can of course convert a regular integer to it, using toNat, which may throw a runtime exception
23:45:10 <pelotom> attempt to convert*
23:49:04 <Schalken> pelotom: Right. However I was hoping for a data type which didn't have any potential for runtime errors. I understand why a Number instance for N may not make sense, as N is not closed under subtraction, but I am interested in an efficient unbounded type for N regardless, even without a Number instance.
23:50:07 <Schalken> (As in, even if the only thing I can do is add Naturals together.)
23:50:41 <pelotom> Schalken: so you need to eschew the Num class, for sure
23:50:41 <sipa> then just use Integer?
23:51:08 <sipa> or put a newtype around Integer for which you do not implement (-) or fromInteger
23:51:24 <pelotom> Schalken: how do you expect to get data into this type from a more conventional type like Int?
23:51:43 <pelotom> you can't "prove" to the compiler that an Int is positive
23:52:03 <pelotom> or do you not care about that?
23:53:54 <Schalken> pelotom: Hmm. Literals like "6" and "12" are converted to Nums using fromIntegral, correct? So there is no way for Haskell to statically check that all literal Nats are positive, as they are first converted to Integrals and then fromInteger is called at runtime?
23:54:47 <pelotom> Schalken: yeah, you'd have to be in the Num class to get literals to work I think
23:54:57 <sipa> you do
23:55:18 <sipa> 13 in code is actually (fromInteger <Integer corresponding to 5>)
23:55:24 <sipa> eh, 13, not 5!
23:55:35 <pelotom> :t 13
23:55:36 <lambdabot> forall t. (Num t) => t
23:55:51 <sipa> :t fromInteger x
23:55:52 <lambdabot>     Couldn't match expected type `Integer' against inferred type `Expr'
23:55:52 <lambdabot>     In the first argument of `fromInteger', namely `x'
23:55:52 <lambdabot>     In the expression: fromInteger x
23:55:54 <sipa> :t fromInteger
23:55:55 <lambdabot> forall a. (Num a) => Integer -> a
23:56:07 <sipa> :t fromInteger 13
23:56:08 <lambdabot> forall a. (Num a) => a
23:56:36 <bd_> At the implementation level, of course, the compiler can choose to take shortcuts for known types like Int, or otherwise execute the fromInteger function at compile time
23:56:39 <Schalken> pelotom: Well, considering this type wouldn't be an instance of Num, let's say the only way I can build values of this type are through the functions "zero :: Nat" and "Succ :: Nat -> Nat".
23:57:05 <pelotom> Schalken: right, so if you do that kind of peano arithmetic to build up the values, it will work, but I dunno if it can be efficient
23:58:38 <pelotom> I know there's a more efficient encoding than just Zero | Succ Nat
23:58:43 <Schalken> Oooh, and let's say "fromWord8 :: Word8 -> Nat" to "fromWord64 :: Word64 -> Nat", which can just stick the given word into Nat's binary representation, whatever that happens to be. (I don't know how unbounded Integers are implemented so I can't say how unsigned unbounded Integers would be implemented.)
23:58:47 <pelotom> where essentially you treat it as a string of bits
23:59:11 <pelotom> so maybe that's how you should do it
23:59:26 <pelotom> store it as a string of Word8s
23:59:57 <pelotom> [Word8]
