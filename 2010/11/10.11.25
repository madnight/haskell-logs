00:00:03 <sinelaw> ok
00:00:25 <jmcarthur> sinelaw: e.g.    let x = 5 in (x :: Int, x :: Double)   -- i think that would fail with MonoLocalBinds
00:00:31 <sinelaw> on the downside, this means that people writing programs in the embedded languages have to keep in mind that it's haskell with MonoLocalBinds, not the usual stuff
00:01:00 <jmcarthur> but this would succeed:
00:01:14 <jmcarthur> let x = 5 :: Num a => a in (x :: Int, x :: Double)
00:01:33 <sinelaw> ok, then it's not too bad
00:01:55 <sinelaw> jmcarthur, what about let x = 5 :: a in (x :: Int, x :: String)
00:02:06 <jmcarthur> it just means that instead of having to be explicit about monomorphism you now have to be explicit about polymorphism
00:02:08 <sinelaw> let me check :)
00:02:17 <jyper> does the default show function for Arrays attempt to stringify all indexs in range even ones that don't have any elements resulting in an exception if you don't have an element for each index in range?
00:02:24 <jmcarthur> sinelaw: that would not work. the Num constraint is necessary for 5 to even make sense
00:02:35 <sinelaw> jmcarthur, oh oops
00:02:36 <sinelaw> :)
00:02:41 <jmcarthur> sinelaw: and then String has no Num instance...
00:02:49 <sinelaw> not what i meant
00:03:03 <copumpkin> sinelaw: but yeah, if you put an annotation on something that can be more general than it was inferred to be, it's fine
00:03:09 <copumpkin> it'll accept that
00:03:15 <sinelaw> ok, i think that's a nice solution
00:03:21 <copumpkin> the monolocalbinds is just about inference
00:03:32 <copumpkin> not the actual most general types (which should still be the same)
00:03:54 <sinelaw> what do you mean still be the same?
00:03:55 <jmcarthur> it's about default behavior, really. you still have the same power either way
00:04:08 <jmcarthur> you just have to be explicit about different kinds of things
00:04:19 <sinelaw> jmcarthur, yeah, that's what i want
00:04:47 <copumpkin> sinelaw: your terms can still be typed in the same ways as before, with sufficient annotations. It might just take a few more annotations to get behavior that happened by default before
00:05:01 <sinelaw> ah ok
00:05:19 <sinelaw> thanks jmcarthur and copumpkin, another hurdle passed
00:05:22 <jmcarthur> man i hate many to many relationships between types
00:05:29 <sinelaw> and some more understanding gained
00:05:41 <jmcarthur> multiparamtypeclasses kind of stinks for this because i don't really want it to be open
00:05:51 <jmcarthur> but on the other hand something like a GADT just seems horrible for this
00:06:44 <jmcarthur> to witness the relationship, that is
00:06:47 <copumpkin> use a multiparamtypeclass + a GADT!
00:06:48 <copumpkin> :P
00:06:52 <jmcarthur> *sigh*
00:06:57 <copumpkin> data Rel a b where witness :: MyWitness a b
00:07:04 <copumpkin> then write a bunch of instances :P
00:07:09 <jmcarthur> umm
00:07:14 <copumpkin> I mean
00:07:16 <copumpkin> class
00:07:16 <jmcarthur> that's as open as the type class idea :P
00:07:16 <copumpkin> :P
00:07:24 <copumpkin> no it isn't?
00:07:25 <jmcarthur> i don't want it to be open though :(
00:07:37 <copumpkin> where MyWitness is a GADT
00:07:43 <jmcarthur> oh
00:07:45 <jmcarthur> umm
00:07:49 <byorgey> jyper: probably.  there's no way it could know which indices it ought to show and which it ought not.
00:07:51 <jmcarthur> verbosity sucks!
00:07:54 <copumpkin> :P
00:08:01 <copumpkin> jmcarthur: you could write some TH that automates the pattern
00:08:20 <jmcarthur> this isn't the first time i've been in this situation. such patterns shouldn't exist :\
00:08:53 * eagle-runner recommend reading: this article mentions mem leak by laziness is a serious problem when devloping large systems: http://lambda-the-ultimate.org/node/3131  (search 'leak')
00:09:52 <sinelaw> woohoo I have a trivial imperative language with type inference!
00:10:54 <jmcarthur> eagle-runner: i never understood that attitude about laziness. it seems to me that if you code in a space leak you get a space leak, and if you don't code it in then you don't get it. they don't just appear, and it's not that difficult to prevent if you just think about strictness as you code. i don't think it's so difficult
00:11:29 <osaunders> > 1 + 1
00:11:58 <copumpkin> eagle-runner: are you pushing a point or asking for opinions?
00:12:01 <osaunders> Dammit, if it isn't haskell.org it's lambdabot
00:12:07 <jmcarthur> i guess i should read the stinking paper before i talk too much
00:12:15 <Enigmatic> jmcarthur: what tools do you use for debugging space leaks?
00:12:23 <eagle-runner> jmcarthur: in fact i have no experience in large system dev in haskell, im just reading LtU and recommending interesting stuff here
00:12:42 <jmcarthur> Enigmatic: i haven't had a space leak since i was a little noob
00:12:50 <jmcarthur> Enigmatic: well, i should correct that
00:12:52 <copumpkin> same
00:13:00 <jmcarthur> Enigmatic: i haven't had one that wasn't *immediately* obvious
00:13:22 <Enigmatic> ok, so what would noobs use for debugging space leaks? 
00:13:35 <jmcarthur> i would recommend that noobs learn to reason about strictness
00:13:44 <jmcarthur> Enigmatic: there is always heap profiling though
00:15:06 <Enigmatic> yeah that gets me back to the awesome profiling and stack traces ;-)
00:15:30 <Enigmatic> i've talked to a couple commercial haskell users that have these problems too, so i don't think it's restricted to noobs
00:15:36 <jmcarthur> the main things are recognizing when a field of a data structure should be strict and recognizing when a function is strict in any of its arguments. once you have a good grasp of those things it's all good
00:16:00 <jmcarthur> i think a lot of commercial haskell users don't actually have a good grasp of laziness and strictness, surprisingly
00:16:20 <Enigmatic> nah i'm pretty sure these guys do
00:17:09 <eagle-runner> Enigmatic: im curious about commercial haskell users, what do those companies do?
00:17:31 <Enigmatic> eagle-runner: prop trading
00:17:42 <jmcarthur> i've thought a lot about how to go about writing a blog post about this that would be actually helpful. i've found the thought exercise to increase my understanding, but i haven't found it very fruitful regarding how to word these ideas. it's all about throught process as you code
00:18:16 <jmcarthur> maybe i should just write a blog post about what i'm thinking while i code
00:18:32 <jmcarthur> not about techniques and stuff like that. just what i think about
00:18:56 <jmcarthur> i'm thinking i should go to bed
00:18:59 <jmcarthur> gnite
00:19:20 <copumpkin> night :)
00:19:52 <eagle-runner> jmcarthur: looking forward to see your post
00:19:56 <eagle-runner> jmcarthur: good night
00:21:34 <Enigmatic> eagle-runner: i've also heard rumors that some other large companies are pushing MS to develop a supported Haskell compiler, so there are definitely some people out there writing Haskell 
00:21:43 <Enigmatic> probably also finance companies, but whatever
00:23:10 <eagle-runner> Enigmatic: good news for haskell
00:23:24 <edwardk> Enigmatic: there are definitely finance companies using it
00:23:31 <kmc> heh
00:23:51 <Enigmatic> edwardk: well yeah, but not as many will go to MS to ask for a supported compiler and runtime.
00:24:31 <kmc> MS funds development of GHC as a prestige side project, but i bet anyone looking for a supported enterprise-ready buzzword-compliant functional language would be directed to use F# instead
00:24:45 <Enigmatic> kmc: how do you think F# got funded?
00:25:02 <edwardk> meh. they have an open standard that has been rock solid stable for 12 years and the better part of a dozen implementations what more could they ask for?
00:25:12 <edwardk> kmc: because don syme was already there
00:25:21 <edwardk> er enigmatic:
00:25:35 <Enigmatic> edwardk: uhm, he was in research, not a product team.
00:25:57 <edwardk> still is iirc
00:26:06 <Enigmatic> edwardk: research projects don't get picked up into a product team because they like someone in research ;)
00:26:31 <eagle-runner> simon pyton is also in MSR now?
00:26:33 <edwardk> Enigmatic: microsoft research generally doesn't put ANYTHING they do into production ;)
00:26:51 <eagle-runner> *peyton jones
00:26:54 <Enigmatic> eagle-runner: both simons work in MSR
00:27:07 <Enigmatic> edwardk: exactly.
00:27:35 <Enigmatic> so guess what big customers went to MS to demand a production F# compiler?
00:27:45 <eagle-runner> and i saw a person's profile in MSR's page, he is working in ghc
00:28:05 <sinelaw_> jmcarthur, i still have to do alpha-converions, maybe i should read about HOAS
00:28:31 <sinelaw_> *conversions
00:28:32 <edwardk> Enigmatic: syme has/had a fair bit of clout though, he designed the CLR generics implementation back when java was trouncing them
00:28:59 <ski> jmcarthur : sinelaw wants the type of a variable to be partially determined by how it is used
00:29:07 <edwardk> so the work he has been doing on f# was mostly just furthering that direction
00:29:23 <ski> .. oh, jmcarthur went to bed
00:29:44 <ski> @tell jmcarthur i think HOAS in lambdaProlog is much nicer .. because the lambda-bound variables act like new constructors of the relevant type, so you can match on them
00:29:52 <ski> argh, no lambabot
00:29:57 <Enigmatic> edwardk: yes, and he had a proposal for a functional IL (called ILX) that is actually used by the F# compiler before being lowered to IL
00:30:12 <sinelaw> ski, but in haskell you get stuck with closed lambdas, right?
00:30:29 <ski> sinelaw : well, in lambdaProlog as well
00:30:31 <Enigmatic> edwardk: anyways, i can assure you that the product team asked don to come make a production version, not the other way around.
00:30:56 <sinelaw> ski, so why is it nicer in lambdaProlog
00:31:20 <ski> jmcarthur : i think HOAS in lambdaProlog is much nicer .. because the lambda-bound variables act like new constructors of the relevant type, so you can match on them
00:31:32 <edwardk> meh. f# isn't all that radical. it sits right on top of the existing CLR pretty much unmodified, which is why it doesn't have any real notion of modules to speak of
00:31:37 <ski> jmcarthur :  "An Extension to ML to Handle Bound Variables in Data Structures: Preliminary Report" at <http://www.lix.polytechnique.fr/~dale/papers/abstracts.html#miller90mll> by Dale Miller in 1990-05 explains something similar, but as an ML extension
00:32:05 <ski> sinelaw : because you can match on the "object-lambda"-bound variables
00:32:24 <edwardk> you pay the full price of ml syntax to get no real additional benefits
00:32:28 <sinelaw> so the lambda are not really closed
00:32:36 <ski> yes they are
00:32:43 <Enigmatic> edwardk: i agree, that doesn't make it free to go and ship a supported compiler in visual studio though ;-)
00:33:16 <Enigmatic> and that was the point i was trying to make wrt Haskell
00:33:41 <ski> sinelaw : look at that paper, you too
00:34:18 <sinelaw> looking
00:34:37 <edwardk> visual studio support for f# is more or less window dressing. you don't need to work hard to integrate it into the microsoft ecosystem, it doesn't challenge the established order, the pecking order of vendors, all your existing code still fits in, you just get a funny syntax
00:34:47 <ski> sinelaw : they introduce a new type constructor, `=>', which i could, for the sake of Haskellifying the syntax, call `-->', here
00:35:08 <edwardk> for something like haskell it is a much taller order. the language works radically different, you get no reuse, the environment is completely different.
00:35:19 <sinelaw> ski, look interesting, but not something i can actually use
00:35:28 <Enigmatic> edwardk: how much do you think it would cost to support F# in Visual Studio for 10 years?
00:35:51 <sinelaw> though i'll read it for education, it doesn't solve my problem
00:35:58 <eagle-runner> i didnt pay much attention to F#, is it a real haskell clone with the same type system?
00:36:07 <ski> sinelaw : then instead of saying (basically) `data Ltm = App Ltm Ltm | Abs String Ltm | Var String', they say `data Tm = Abs (Tm --> Tm) | App Tm Tm'
00:36:18 <sinelaw> for me lack of pureness in f# is what makes it not interesting
00:36:28 <edwardk> Enigmatic: i'm not saying its cheap, i'm saying its an order of magnitude or more cheaper than trying to do the same for something that doesn't suit the ecosystem as well like haskell
00:37:01 <Enigmatic> edwardk: would you imagine they would pay that price just to keep don syme on the payroll?
00:37:08 <ski> sinelaw : that's right. unless someone implements something similar for Haskell (and, afaik, this wasn't implemented in an ML either, except possibly in a research prototype), you will have no *direct* use of this
00:37:10 <kmc> eagle-runner, it's closer to ML than Haskell
00:37:22 <kmc> not a direct clone of either
00:37:26 <kmc> but the type system is similar in the basic points
00:37:56 <edwardk> Enigmatic: there are a lot of reasons to do it. it serves as a holding pattern to keep someone else from coming along with a functional programming language killer app and catching them flat footed
00:38:28 <edwardk> it makes sure that the visual studio team can adapt to new styles of languages, it was a stepping stone towards the support for all the crazy nonsense they had to implement for dynamic for 4.0, etc.
00:38:45 <eagle-runner> kmc: so whats the difference with haskell? (the difference that really matters)
00:38:53 <kmc> i don't know, i'm not an F# expert
00:38:59 <kmc> i doubt you will find one conclusive difference
00:39:01 <kmc> but a lot of differences
00:39:02 <sinelaw> ski what about de bruijn indices
00:39:07 <sinelaw> as an alternative
00:39:19 <ski> sinelaw : anyway, the way to introduce something of type `A --> B' is to write like `\X --> ..X..' (they say `x \ ..x..' in their syntax)
00:39:36 <ski> sinelaw : so inside `..X..', `X' acts like a new constructor for `A'
00:39:54 <Enigmatic> edwardk: ok, I know I'm right though :-)
00:40:21 <ski> sinelaw : so instead of saying `Abs "x" (App (App (Var "f") (Var "x")) (Var "x"))', they can now say `Abs (\X --> App (App F X) X)' (assuming `F' is in scope)
00:40:28 <edwardk> f# is the cheapest coat of functional paint over the same old infrastructure that microsoft could throw on as a hedge against the fact that functional languages have been getting a lot of play lately
00:40:30 <eagle-runner> edwardk: i used C# a lot when its .net2.0, now too many features are screwed into .net, typical MS style...
00:41:00 <ski> sinelaw : de bruijn indices for getting a normal form works, but is ugly
00:41:27 <kmc> if functional languages are becoming popular and mainstream, where should i (as a language hipster) go to find something that's still cool and underground?
00:41:46 <edwardk> eagle-runner: i'll be honest, i actually rather like c# since the 3.5/4.0 features slid into it. real lambdas, var for type inference, the linq sugar, the fact that they went somewhere novel with language features on reflecting expressions, etc.
00:42:01 <sinelaw> so i'm left with implementing all the alpha-conversion stuff
00:42:17 <ski> kmc : in any case, you should learn about logic programming, if you haven't already. also, constraint programming. and attribute grammars could be fun
00:42:25 <kmc> yeah
00:42:30 <edwardk> kmc: concatenative languages or proof assistants. they are both esoteric enough you should be safe. better yet write a concatenative proof assistant ;)
00:42:35 <kmc> i know a bit about logic programing
00:42:37 <kmc> haha edwardk
00:42:48 <kmc> isn't Ltac a concatenative proof language ;)
00:42:54 <sinelaw> edwardk, i don't like how they push more and more language features
00:43:13 <sinelaw> edwardk, many overlapping, some broken
00:43:25 <sinelaw> the 'var' stuff is rather limited
00:43:28 <ski> sinelaw : anyway, if you have an expression `\X --> ..X..', then inside that you can do `case ... of X -> ...; ...' and so you can match on `X'
00:43:29 <copumpkin> omg an edwardk
00:44:03 <sinelaw> ski, that's nice, i'm in a practical mood though
00:44:18 <sinelaw> i have a specific goal right now
00:44:39 <eagle-runner> i still remember the horror brought by MFC to me. so i really dislike MS' products... i like C#2.0 because it was so simple, i could start programming in half a day. (with knowledge of C++ and Java)
00:44:42 <edwardk> sinelaw: its a bit heavy-weight, but they don't have the luxury of being able to start over
00:45:07 <edwardk> eagle-runner: MFC was a long time ago. i have managed to blot those years out. ;)
00:45:26 <sinelaw> edwardk, i'm also using java now and c# is indeed much better
00:45:29 <kmc> yeah early C#, being a Java clone, is easy to learn if you know Java
00:45:32 <edwardk> personally c# 3.5 was the first time c# was tolerable to me
00:45:34 <kmc> but early C#, being a Java clone, sucked
00:45:53 <sinelaw> specifically two things kill me in java
00:46:23 <edwardk> the new dynamic stuff in 4 is nice though it really reduces the amount of crap that has to be built via designers, and reduces the boilerplate for interacting with dynamic code
00:46:31 <sinelaw> 1. compiler forgets generic type parameters resolution during _compile time_ (can't declare static members in generic classes that use type parameters)
00:46:42 <sinelaw> 2. no lambdas! ahhhh inner classes.... :(
00:46:57 <sinelaw> edwardk, what dynamic stuff?
00:47:05 <edwardk> sinelaw: yeah, i've been writing a lot of scala lately. the former really drives me nuts
00:47:38 <copumpkin> edwardk: guess where I am!
00:47:48 <sinelaw> ski, is there any other way to not have to implement alpha conversion stuff?
00:47:51 <Enigmatic> and the scala compiler is just about the slowest thing i've ever used (and spend most of my day using, every day)
00:48:02 <eagle-runner> java's bytecode is type specific, IL is better, instructions are polymophic, really neat
00:48:03 <ski> sinelaw : do you need to implement it ?
00:48:05 <Enigmatic> otherwise scala is significantly better than java, but still limited by the jvm :(
00:48:11 <edwardk> sinelaw: they added a dynamic type that be used where you get the syntax for method calls, etc. but they all become dynamic dispatch.
00:48:17 <ski> sinelaw : are you going to compare expressions ?
00:48:53 <sinelaw> ski, maybe i do, maybe not. i might have to if I want to evaluated my language in haskell itself
00:49:20 <edwardk> so dynamic foo = …; foo.bar(x,y,z) has the method call dispatched entirely at runtime. so you don't have to deal with the horrible syntactic burden of doing all the reflection yourself, etc.
00:50:12 <edwardk> sinelaw: so they have var which does forward-only type inference, and dynamic which can be used to interoperate cleanly with dynamic programming languages, its a good mix.
00:51:04 <sinelaw> edwardk, i tried using var a bit (more than just for linq results) and hit the wall pretty quick
00:51:12 <edwardk> http://geekswithblogs.net/sdorman/archive/2008/11/16/c-4.0-dynamic-programming.aspx
00:51:53 <edwardk> sinelaw: i mostly use var for iterating or to avoid the annoying imperative BigComplicatedType<A,B,C,D,E,F,G> foo = new BigComplicatedType<….> pattern
00:52:17 <sinelaw> yes, but that only rids you of the lhs
00:52:38 <edwardk> if they could get rid of more of the old 1.1 style containers it'd be damn handy
00:52:38 <sinelaw> not saying it isn't god
00:52:47 <sinelaw> *good
00:53:24 <edwardk> sure, though i find i still spend less time writing type annotations in c# than i do in scala. ;)
00:53:49 <sinelaw> ski, maybe i should use a monad that allocates unique variable tags
00:53:54 <edwardk> but then i can't write all the crazy functors and categories stuff that makes scala fun
00:54:13 <sinelaw> i use java because of gwt
00:54:22 <ski> sinelaw : sounds like it could be handy, yes ..
00:54:55 * ski would still prefer to get HOAS and L-lambda unification into Haskell, somehow
00:57:08 <edwardk> ski ?
00:57:28 <ski> something like how one can do HOAS in lambdaProlog
00:57:50 <ski> .. or probably more like that "An Extension to ML to .." paper i linked to
00:58:30 <sinelaw> :t true
00:59:49 <edwardk> copumpkin: still at the office?
00:59:53 <copumpkin> yep
00:59:54 <copumpkin> :P
01:00:03 <copumpkin> gotta go to airport in a couple of hours
01:00:08 <ski> edwardk : had you seen that paper, before ?
01:00:10 <edwardk> copumpkin: ah
01:00:32 <edwardk> ski: 
01:00:33 <ski> "An Extension to ML to Handle Bound Variables in Data Structures: Preliminary Report" at <http://www.lix.polytechnique.fr/~dale/papers/abstracts.html#miller90mll> by Dale Miller in 1990-05
01:00:35 <ski> that one
01:00:47 <edwardk> pulling it up
01:01:20 <edwardk> don't think i have
01:01:21 * ski is unsure whether more work has been done to follow this up .. what sinelaw was talking about brought it up from my memory
01:02:08 <ski> it's providing something like how lambdas and universals and implications work in lambdaProlog, only instead for an ML
01:03:38 <ski> (sinelaw : where you wondering about the type of `true' in that paper ?)
01:03:42 <edwardk> ski: i have to admit the syntax doesn't really grab me but the pattern matching examples are kind of nice
01:03:44 <ski> (s/where/were/)
01:04:30 <ski> edwardk : replace the type `a => b' by `a --> b', the expression `x \ ..x..' by `\X --> ..X..' to get something more Haskelly, syntax-wise
01:05:05 <ski> (oh, and `t ~ t0' by `t $$ t0' or something)
01:05:49 <ski> edwardk : so `Abs "x" (App (App (Var "f") (Var "x")) (Var "x"))' would instead be cast as `Abs (\X --> App (App F X) X)' (assuming `F' is in scope)
01:06:45 <edwardk> ski: well syntactically construction doesn't win you anything over the more usual hoas encoding. the pattern matching possibilities are nice though
01:07:28 <ski> yeah, it's the matching and the function extension which gives you more power
01:07:52 <edwardk> i'll need to chew on it for a bit
01:09:25 <ski> ok
01:11:29 <ski> (generally, i think the type `A --> B' should only be allowed when the type `A' is "open", in the sense that we are allowed to add new constructors to it -- which would mean that functions matching on it wouldn't be exhaustive any more, unless you use a catch-all case -- or if you explicitly add a new case, with the function extension thing)
01:18:35 <TheColonial> Hi guys. I'm trying to build an app which is using Test.Framework.Providers.QuickCheck2. Does anyone know which package this lives in? I've installed quickcheck via cabal but it still says it can't find the module.
01:19:52 <quicksilver> TheColonial: google says, test-framework-quickcheck
01:20:24 <TheColonial> quicksilver: Thanks.
01:20:33 <TheColonial> quicksilver: not sure why that didn't come up in my searches
01:21:20 <quicksilver> :)
01:21:25 * quicksilver has the google-fu
01:21:56 * TheColonial is obviously lacking google-fu this evening
01:22:18 <TheColonial> hrm, must come up with an excuse! ... long day.. yup, lame, but that'll do :)
01:23:36 * hackagebot graph-rewriting-ski 0.5.4 - Two implementations of the SKI combinators as interactive graph rewrite systems  http://hackage.haskell.org/package/graph-rewriting-ski-0.5.4 (JanRochel)
01:23:54 <ski> .. er, what ?
01:24:08 <TheColonial> quicksilver: installed, but still get the same issue. Doh!
01:24:28 * ski has never been highlighted before by hackagebot .. *grmbl*
01:25:02 <cheater99> hello
01:26:08 <quicksilver> TheColonial: test-framework-quickcheck2 :P
01:26:33 <TheColonial> quicksilver: ha!
01:26:34 <TheColonial> :)
01:27:16 <cheater99> is there a haskell lib that does this? i have a directed graph of points i need to visit, each point has "costs" across n variables. I want to find a path from point A to point B, based on constraints describing the desired costs (which should be minimized, which should be maximized)
01:27:36 <TheColonial> there we go. thanks for that quicksilver 
01:27:37 <turiya> i read the "pack" function in ByteString and it uses unsafePerformIO internally, even though the function is documented to be pure.. kmc, told the other day about semantic purity, can someone explain what it is? 
01:28:11 <quicksilver> turiya: it just means that it always returns the same value when you feed it the same parameter.
01:28:14 <quicksilver> that's all purity is.
01:28:20 <quicksilver> (and has no other effects)
01:29:13 <turiya> quicksilver: i dont see why pack returns the same pointer for the same list..
01:29:27 <quicksilver> it doesn't, it returns the same *value*
01:29:30 <quicksilver> the same ByteString
01:29:38 <quicksilver> whether or not it is the same pointer is irrelevant
01:29:48 <quicksilver> 3 + 4 does not always return the same pointer (to 7)
01:30:08 <turiya> same value ==> the contents of the array are the same?
01:30:16 <quicksilver> in fact, you're pretty much guaranteed to get a different pointer every time you call 3+4.
01:30:22 <quicksilver> no arrays involved.
01:30:25 <quicksilver> same value => same bytestring.
01:30:30 <quicksilver> all the same properties.
01:30:49 <turiya> how is "same" defined?
01:30:55 <ski> observationally
01:31:08 <ski> if you can't observe a difference, then they're the same
01:33:08 <turiya> i thought that an instance of Eq would define similarity..
01:33:20 <quicksilver> no, but that's not a bad intuition.
01:33:35 <quicksilver> it's not the right answer because it suggests that you have no answer for types not members of Eq
01:34:16 <quicksilver> (e.g. functions)
01:34:26 <ski> `(==)' in `Eq' is supposed to be an equality
01:34:52 <ski> i.e. for any `x' any `y', `x == y = True', only if `x' and `y' are (observationally) equal
01:35:10 <ski> and `x == y = False' only if they are (observationally) not equal
01:35:18 <turiya> quicksilver: yes, true
01:35:38 <ski> otoh, two values `x' and `y' can be equal, even if `x == y' doesn't give `True'
01:35:55 <turiya> so, we tell haskell whats pure and whats not?
01:36:23 <turiya> as it cant by itself see if two things are observationally similar
01:36:47 <quicksilver> well, in many respects GHC doesn't actually care if a function is pure
01:37:06 <quicksilver> but to the extent we tell anything, then yes, using unsafePerformIO is "telling it" that.
01:37:25 <quicksilver> it's programmers that care if functions are pure, not compilers.
01:37:33 <ManateeLazyCat> lamdabot is down?
01:37:36 * ski still thinks `promisePureIO' would be a better name ..
01:37:40 <ski> ManateeLazyCat : yes
01:38:13 <turiya> quicksilver: oh..yeah, purity is for the programmers :)
01:39:20 <mm_freak> unsafePerformIO is the rusty, fragile pipe between evaluation and execution
01:39:32 <turiya> so as i understand, all haskell functions which are pure, are pure because we think they are?
01:39:45 <osfameron> quantum purity?
01:39:54 <mm_freak> in general all haskell functions are pure
01:40:09 <mm_freak> including IO
01:41:00 <ski> barring `unsafePerformIO'
01:41:07 <ski> (and `unsafeCoerce')
01:41:12 <mm_freak> there are no side effects in evaluation, until you deliberately ask for them using e.g. unsafePerformIO
01:41:54 <turiya> mm_freak: evaluation is done during compilation?
01:42:19 <ManateeLazyCat> turiya: Haskell not force must write pure function, if all funcitons are pure, you can't do anything. Haskell is build box to separate pure code and dirty code (have side effect) to make program more robust.
01:42:20 <mm_freak> turiya: no, evaluation and execution are done interleaved
01:42:41 <mm_freak> execution asks for a value, evaluation calculates it
01:43:29 <turiya> mm_freak: so execution begins in "main"
01:44:03 <mm_freak> turiya: yes, first 'main' is evaluated, the resulting value is a program, a value of type IO ()
01:44:08 <mm_freak> this program is executed
01:44:38 <mm_freak> and then the program is done, but because of laziness, during execution a lot of evaluation happens, too
01:44:55 <turiya> what exactly is evaluation?
01:45:07 <mm_freak> calculating a value of some type
01:45:18 <mm_freak> 1 + 1 ⇒ 2
01:45:51 <mm_freak> putStrLn "Hello" ⇒ (some program, which prints "Hello")
01:45:56 <ManateeLazyCat> turiya: evaluate /= execute
01:46:21 <mm_freak> in the former you calculate, say, a value of type Integer
01:46:30 <mm_freak> in the latter you calculate a value of type IO ()
01:46:32 <turiya> i see, if i write c = a + b in the Main module, this sentence gets evaluted first, i.e. the value of c is calculated..
01:46:49 <mm_freak> no, c is only evaluated as needed
01:47:15 <mm_freak> either you add a specific evaluation dependency using 'seq' or execution needs its value
01:47:25 <turiya> mm_freak: ok, due to laziness?
01:47:25 <ManateeLazyCat> turiya: If c is not reference by rest code, c won't evaluate.
01:47:37 <mm_freak> yes
01:47:45 <mm_freak> most values are evaluated as a side effect of execution
01:47:50 <ManateeLazyCat> @hoogle evaluate
01:48:11 <mm_freak> this even includes typing stuff into GHCi
01:48:13 <ManateeLazyCat> Hmm, missing lambdabot.
01:48:22 <turiya> excution is another name for evluating a value of type IO ()?
01:48:41 <mm_freak> no, a value of type IO () is a program, which results in ()
01:48:54 <mm_freak> evaluating it means calculating that program
01:49:02 <mm_freak> and execution — well — executes it
01:49:24 <ski>   evaluate :: a -> IO a
01:49:33 <el_alacran> sweet this channel is huge, can anyone give me an example of where haskell is used in the field? I'm on the fence about learning it
01:50:01 <el_alacran> by field i mean any field, research, workfield, etc
01:50:09 <mm_freak> el_alacran: i use it mainly for web/network development, but also often for small command line tools
01:50:24 <ski> turiya : execution, here, means taking a value of type `IO a' (which has already been evaluated), and "following the imperative instructions in it", doing stuff, to yield a value of type `a' (which can be passed to further actions)
01:50:34 <el_alacran> @mm_freak so like cluster computing?
01:50:45 <el_alacran> that falls under network
01:50:55 <turiya> el_alacran: i am trying to use it for image processing
01:50:56 <Cale> el_alacran: At iPwn we're using it to write an action RPG game for iPhones and other mobile devices.
01:51:12 <mm_freak> el_alacran: no, rather writing custom network apps for my company for all kinds of purposes
01:51:40 <mm_freak> mostly i'm forced to use PHP, but on many occasions i use haskell (whereever possible in fact)
01:51:46 <el_alacran> @Cale how's it stacking up so far against the Android API or Objective-C etc?
01:51:53 <el_alacran> @mm_freak oh alright
01:52:11 <Cale> It's a lot nicer than programming in Objective C or C++.
01:52:19 <el_alacran> @turiya why wouldn't you use C for image processing? that's mostly whats used for that
01:52:31 <el_alacran> Cale, well C++ is only mean when you start coding it
01:52:34 <Cale> el_alacran: It's a general purpose language, you could use it for almost anything you could use any language for. Its strengths don't tend to be specific to any one sort of application.
01:52:48 <mm_freak> el_alacran: if you would judge based on that, you shouldn't use haskell for anything ;)
01:52:49 <turiya> el_alacran: sometimes, c++ is too complicated..
01:53:15 <el_alacran> teriya that sounds like a cop-out
01:53:19 <el_alacran> no offense
01:53:27 <mm_freak> el_alacran: haskell is fine for image processing, even including high performance stuff
01:53:39 <el_alacran> mm_freak well i mean haskell is probably the fastest functional programming language out there
01:54:15 <el_alacran> so I mean, it definitely is something worth learning?
01:54:39 <mm_freak> i think ocaml beats it at some places, but in others haskell wins, so they are comparable in performance
01:54:48 <el_alacran> ocaml is fuckign awesome
01:54:50 <turiya> el_alacran: yeah, it might be. just say i get to think at a more higher level .. 
01:55:22 <el_alacran> tariya thats fair
01:55:26 <shachaf> When is 3bbbot coming back? Who runs her nowadays?
01:55:30 <mm_freak> anyway, haskell is way more elegant for a lot of stuff…  it's an elegant language in general, but you'll get the feel for it yourself
01:55:41 <Cale> el_alacran: We've known how to implement first class functions efficiently for around 30 or 40 years now, they're useful in absolutely every nontrivial program you might want to write, and their benefits to expressiveness have been known for longer than electronic computers have been around. There's no excuse for continuing to write in a programming language without them.
01:55:49 <mm_freak> so yes, learning it definitely pays off
01:56:04 <el_alacran> how does it stand when it comes to use for Artificial Neural Systems? I mean thats the root of all this
01:56:15 <el_alacran> its the reason i started considering learning it
01:56:19 <Cale> (Regarding C++)
01:56:31 <el_alacran> Cale you make a good point
01:56:51 <mm_freak> el_alacran: it's fine for ANNs and other AI stuff…  you'll even find some ready-made libraries out there, but nothing fancy yet
01:57:14 <mm_freak> on the other hand it's very easy to implement ANNs in haskell, including the learning algorithms
01:57:30 <el_alacran> yeah because i really dont wanna have to learn turbopascal
01:57:48 <turiya> ski: execution performs IO and evaluation does not?
01:58:11 <mm_freak> turiya: evaluation constructs IO, execution performs it
01:58:21 <el_alacran> alright good stuffs, thanks, I'm out I'm beat as hell, happy thanks giving everyone.
01:59:25 <turiya> main = putStrLn "here", what is the evaluation process for this code?
01:59:52 <ski> turiya : do you know about GADT types ?
02:00:37 <turiya> i think so
02:01:36 <mm_freak> "here" becomes a thunk _here, which is applied to putStrLn yielding a value of type IO (), a program
02:02:05 <turiya> whats a thunk?
02:02:07 <mm_freak> this program is executed…  it asks for the value of _here to print it, so this value is calculated
02:02:14 <mm_freak> an unevaluated value
02:02:23 <mm_freak> laziness artifact
02:02:51 <turiya> oh.. i see..
02:03:18 <mm_freak> i think any boxed value in memory is generally referred to as a thunk
02:03:21 <turiya> essentially values becomes thunks until they are needed
02:03:40 <mm_freak> it contains either an readily evaluated value or a recipe to calculate it
02:03:45 <mm_freak> yes
02:03:49 <mm_freak> until they are asked for
02:04:28 <turiya> whats the difference?
02:04:52 <mm_freak> sometimes you ask for a value, even if it's not needed
02:05:27 <turiya> oh.. i understand a bit..
02:05:27 <mm_freak> for example when calculating the sum of a list you would ask for the intermediate results along the way
02:05:49 <turiya> yeah, i understand now..
02:05:58 <mm_freak> sum [a, b, c] = a + sum [b, c] = a + b + sum [c] = a + b + c
02:06:16 <mm_freak> you would ask for (a + b) along the way, otherwise it would remain unevaluated until at the end
02:06:44 <Jafet> You would, but sum wouldn't
02:07:05 <Jafet> Unless ghc's strictness analyzer stared it down
02:07:05 <mm_freak> let's say a proper 'sum' would
02:07:19 <mm_freak> i.e. foldl' (+) 0
02:07:55 <Jafet> > 1/3 + 2/3 + 1/10^42 == (1 :: CReal)
02:08:13 <Cale> The original idea behind leaving foldl' out of Haskell 98 was that the expectation was that it's the compiler's job to work out strictness.
02:08:37 <Cale> (But that was possibly too optimistic :)
02:10:01 <Cale> On even the first optimisation level, GHC seems to strictify sum on Integer.
02:10:29 <Cale> (or maybe it's just fusion taking place, hmm...)
02:10:37 <ski> turiya : sorry, got busy a small while ..
02:11:03 <Jafet> I just learned about oleg's seq guard today. I was mildly horrified.
02:11:03 <turiya> ski: no problem 
02:11:04 <ski> turiya : so, if you know GADTs, then consider the following fragment
02:11:09 <ski>   data IO :: * -> *
02:11:11 <ski>     where
02:11:19 <ski>     GetChar :: IO Char
02:11:26 <ski>     PutChar :: Char -> IO ()
02:11:33 <ski>     Return :: a -> IO a
02:11:48 <ski>     Bind   :: IO a -> (a -> IO b) -> IO b
02:11:58 <ski> turiya : so assuming this, and
02:12:08 <ski>   main = putStrLn "here"
02:12:26 <turiya> ski: guess i dont know what GADTs are (apart from the full form).. what are the *'s?
02:13:08 <ski> turiya : the `:: * -> *' only says that `IO' is a parameterized type, like `Maybe' and `[]' and `IORef', &c.
02:13:27 <ski> turiya : the part after `where' tells the types of the constructors
02:14:18 <ski> evaluating `main' would yield (more or less) the value
02:14:19 <ski>   Bind (PutChar 'h') (\_ -> Bind (PutChar 'e') (\_ -> Bind (PutChar 'r') (\_ -> Bind (PutChar 'e') (Return ()))))
02:14:48 <turiya> ski: oh..
02:15:15 <ski> so `main' itself is just an inert value, that describes some actions that might be done .. it only really stores some data, and maybe some algorithms about what to do with input data, if anyone would like to feed it with input data
02:15:48 <ski> then, the run-time system will interpret this value as describing actions to actually *do*, and actually *perform* the corresponding actions
02:16:03 <ski> but nothing would then hinder you to write as well e.g.
02:16:13 <turiya> i understand a bit..
02:16:18 <ski>   interpret :: IO a -> String -> (String,a)
02:16:23 <ski> (which is a pure function)
02:16:47 <ski> another function could be
02:17:19 <ski>   countNo_PutChar :: IO a -> String -> Integer
02:17:33 <turiya> ski: i gotto catch my bus, i hope this discussion can be continued some other time.. 
02:17:35 <turiya> thanks all, i have got some of my doubts cleared..
02:17:37 <ski> (the `String' is for providing input, if the action ever wants to use `GetChar')
02:20:29 <Xilon> Are there any examples of using Network.HTTP.Browser to chain requests and use the coookies recieved? Having a hard time figuring out how to do it from just the documentation.
02:21:28 <IanCal> Morning all. I was wondering if anyone could point me to an overview of how QuickCheck shrinks multiple arguments for a failing test. I've worked through the code, but my haskell isn't good enough to really trace from the top test loop.
02:21:28 <Cale> Xilon: BrowserAction is a monad, so you use do-notation
02:21:53 <IanCal> I get how single arguments are shrunk, but don't really understand the strategy for shrinking more than one at a time
02:22:59 <IanCal> alternatively, if someone could point me at a way I can print things out during the test, or get a printout of all arguments tried then that'd be fantastically helpful :)
02:26:25 <Cale> IanCal: Well, I don't know the answer immediately, but let's take a look at the instance of Testable for functions.
02:26:31 <Cale> instance (Arbitrary a, Show a, Testable prop) => Testable (a -> prop) where
02:26:31 <Cale>   property f = forAllShrink arbitrary shrink f
02:26:52 <IanCal> ah great thanks, I'll have a bit more of a dig around
02:27:14 <Cale> This is applied as many times as there are arguments in f (until it gets down to, say, a Bool, or a Prop)
02:27:43 <Cale> forAllShrink :: (Show a, Testable prop)
02:27:44 <Cale>              => Gen a -> (a -> [a]) -> (a -> prop) -> Property
02:27:44 <Cale> forAllShrink gen shrinker pf =
02:27:44 <Cale>   gen >>= \x ->
02:27:44 <Cale>     shrinking shrinker x $ \x' ->
02:27:45 <Cale>       printTestCase (show x') (pf x')
02:27:50 <DL> Quick question: what is '!!' called ?
02:28:20 <Cale> DL: The indexing operator for lists. I usually pronounce it "bang bang" in my head.
02:28:25 <DL> :D
02:28:26 <DL> Thx
02:28:35 <McManiaC> what is that "rebindable syntax"?
02:28:37 <Cale> Or "at"
02:29:30 <IanCal> Cale, sorry for my slowness, does that mean it'll find the smallest value for the first argument that causes a fail, then work on the second etc. treating them independently?
02:29:44 <enthropy> McManiaC: where things like do-notation get translated into different functions than ones in the Prelude, presumably
02:30:26 <Cale> IanCal: I think it does mean that it's forced to treat them independently. I'm less sure about the order it tries shrinkings in.
02:30:35 <McManiaC> enthropy: example?
02:30:55 <enthropy> @undo do x <- x; y x
02:31:19 <enthropy> McManiaC: the desugaring could use whatever >>= is in scope
02:31:22 <ski> x >>= y
02:31:37 <McManiaC> ah
02:31:54 <Xilon> Cale: How do I get the cookies to chain through requests though?
02:32:24 <Cale> Xilon: I might be wrong, but I thought that the whole point was that this happened automatically :)
02:33:27 <Cale> Xilon: So, you write a BrowserAction which makes multiple requests. You can use getCookies and setCookies/addCookie to modify the cookie store, and otherwise the cookies are handled transparently.
02:33:54 <Xilon> Oh it does, I guess I was testing it wrong
02:34:03 <Cale> and then once you have your complete action built up, you use browse on it, and it'll turn it into an IO action
02:34:23 <enthropy> Cale: can you do something about lambdabot?
02:34:32 <Cale> oh, didn't notice!
02:34:37 <Cale> Yeah, I probably can :)
02:35:23 <Cale> Silly thing didn't realise that it was disconnected and was still running. :P
02:36:45 <McManiaC> enthropy: shouldnt this give an error? http://npaste.de/qp/
02:38:33 <enthropy> McManiaC: it does
02:38:43 <enthropy> try -fforce-recomp
02:38:59 <McManiaC> nope
02:40:01 <enthropy> did you break something in making that ghc?
02:40:35 <ski> lambdabot: howdy
02:40:39 <ski> @botsnack
02:40:39 <lambdabot> :)
02:41:02 <McManiaC> nothing related to do-syntax
02:41:12 <McManiaC> it fails with ghc 6.12
02:41:18 <McManiaC> not with latest head
02:42:11 <enthropy> McManiaC: even 7rc2 fails on with it too
02:42:42 <McManiaC> C:\Users\Nils\dev\hiwi\ghc\inplace\bin>ghc-stage2.exe --version
02:42:43 <McManiaC> The Glorious Glasgow Haskell Compilation System, version 7.1.20101108
02:44:17 <enthropy> maybe they've renamed the extension/split it into other flags? Or the difference could be a bug
02:44:28 <edlinde> dont understand this error
02:44:29 <edlinde> <interactive>:1:0: Not in scope: data constructor `Picture'
02:44:35 <edlinde> I just placed a new type in a file
02:44:44 <edlinde> did a ":l filename.hs"
02:44:57 <edlinde> and get this error when I try a ":t Picture"
02:45:35 <enthropy> edlinde: what is the type?
02:45:38 <sipa> what is the definition you placed into that file?
02:45:45 <edlinde> type Picture = [[Char]]
02:46:23 <edlinde> Prelude> :load practise.hs 
02:46:23 <edlinde> [1 of 1] Compiling Main             ( practise.hs, interpreted )
02:46:23 <edlinde> Ok, modules loaded: Main.
02:46:23 <edlinde> *Main> :t Picture 
02:46:24 <edlinde> <interactive>:1:0: Not in scope: data constructor `Picture'
02:46:26 <enthropy> the right output is with   :i Picture
02:46:45 <edlinde> why can I not say :t on it though?
02:47:02 <sipa> Picture is a type-level expression
02:47:06 <sipa> not a value-level one
02:47:11 <enthropy> Picture is not an expression, and :t only does those
02:47:23 <sipa>  :t shows the type of a value
02:47:39 <edlinde> ok how do I use Picture then?
02:47:47 <enthropy> you could do something like    :t [] :: Picture
02:47:48 <edlinde> *Main> let something = Picture "Whatever"
02:47:49 <edlinde> <interactive>:1:16: Not in scope: data constructor `Picture'
02:48:03 <sipa> edlinde: you want: data Picture = Picture [[Char]]
02:48:20 <DL> How would I join 2 (sorted) lists of infinite length, without having duplicates ?
02:48:21 <sipa> that creates a new type Picture, with one constructor, Picture
02:48:34 <sipa> edlinde: type Picture = ... just provides a new name for an existing type
02:48:43 <ski> edlinde : otoh, you can probably do `:k Picture'
02:48:51 <enthropy> DL: what kind of elements do you have?
02:49:00 <DL> Just Ints
02:49:08 <edlinde> sipa: so isn't [[Char]] just a string like "str"
02:49:08 <edlinde> ?
02:49:16 <edlinde> well thats what my understanding was
02:49:21 <sipa> edlinde: [[Char]] is [String]
02:49:29 <edlinde> ah sorry
02:49:30 <edlinde> yeah
02:49:37 <ski> edlinde : `type Picture = [[Char]]' means that `Picture' is the *same* type as `[[Char]]'
02:49:47 <sipa> indeed
02:49:55 <edlinde> ok
02:50:03 <ski> edlinde : so, given `type Picture = [[Char]]', `let something = ["This","works"]' would work
02:50:07 <edlinde> but then can I not use this Picture in an example?
02:50:08 <DL> enthropy: 2 lists of ints
02:50:20 <sipa> and how to use it: any expression of type [[Char]] is automatically an expression of type Picture as wel
02:50:29 <ski> edlinde : as would `let something :: Picture; something = ["This","too"]'
02:50:47 <sipa> but maybe it's easier to use the name Picture than [[Char]] when referring to that type
02:50:49 <edlinde> ah yeah 
02:50:52 <edlinde> get you now
02:50:53 <enthropy> DL: well if they're sorted, the next element in the result is just the lowest in the head of both lists
02:50:59 <edlinde> If I said  let something :: Picture
02:51:03 <sipa> indeed
02:51:05 <edlinde> it will force the type to be Picture
02:51:06 <edlinde> o
02:51:07 <edlinde> k
02:51:09 <edlinde> :)
02:51:18 <DL> enthropy: I'm having trouble with the fact that their size is infinite
02:51:22 <sipa> rather it would force the type to be [[Char]] :)
02:51:23 <IanCal> Cale: that's fantastic, thanks a lot for the help :D 
02:51:25 <ski> edlinde : still, note that
02:51:28 <DL> enthropy: So I cant work towards a base case
02:51:30 <edlinde> sipa: ok
02:51:34 <ski>   *Main> let something = ["This","works"]
02:51:34 <sipa> since Picture isn't a separate type
02:51:42 <ski> and
02:51:44 <ski>   *Main> let something :: Picture; something = ["This","works"]
02:51:48 <ski> are the same
02:51:52 <enthropy> DL: right, there is no base case, so you can't use a variable to accumulate the result
02:52:03 <edlinde> ski: but if I did a :t on something
02:52:09 <edlinde> I would get Picture yeah?
02:52:11 <edlinde> in the second case
02:52:17 <ski> edlinde : in the latter case, yeah, probably
02:52:33 <edlinde> Yeah it does
02:52:35 <edlinde> ok cool
02:52:40 <sipa> edlinde: you could use :t (undefined :: Picture)
02:52:46 <edlinde> ok
02:53:16 <enthropy> so    merge (a:as) (b:bs) | a > b = b : merge (a:as) bs | otherwise = ...
02:53:45 <DL> enthropy: thx, I'll try that
02:53:56 <enthropy> maybe you can use an accumulating parameter, if you take a continuation
02:54:19 <ski> DL : for good measure, you could add cases for empty lists, should you ever pass in finite lists .. but it should still work fine for infinite lists
02:54:35 <sipa> merge [] x = x
02:54:36 <ski> enthropy : huh ?
02:56:12 <silver_> what's the status of porting ghc to android? are there people doing it?
02:56:23 <McManiaC> gee, running GHCs testsuite takes a while
02:56:26 <McManiaC> :)
02:58:02 <DL> Thx, got it :)
03:00:05 <enthropy> ski: I guess it's nonsense to think that this can return early: merge acc (a:as) (b:bs) | a > b = merge (\cons nil -> b `cons` acc cons nil) (a:as) bs
03:00:58 * ski can't recall seeing anyone calling a continuation `acc' .. :)
03:01:12 <enthropy> well it is an accumulating parameter
03:01:14 <ski> (i suppose it can often be appropriate, though)
03:01:15 <enthropy> :P
03:02:10 <ski> yeah .. like how `acc' in `flatten (Leaf a) acc = a : acc; flatten (Branch l r) = flatten l (flatten r acc)' can be seen as a continuation, if you squint :)
03:02:36 <ski> enthropy : but the trouble with `merge' there is that it's not incremental, it is tail-recursive
03:03:14 <ski> so unless one of the lists end, it will not hand over control to anything other than itself
03:04:25 <enthropy> how about unsafeInterleaveIO, or concurrency (also doing the calculation in IO)?
03:08:27 <McManiaC> enthropy: -XRebindableSyntax
03:08:29 <McManiaC> :)
03:10:04 <sioraiocht> is there anywhere that gives a quick intro to generic haskell syntax?
03:10:10 <sioraiocht> I need to understand it to review something...
03:10:19 <enthropy> @where report
03:10:19 <lambdabot> http://www.haskell.org/onlinereport/
03:10:58 <sioraiocht> enthropy: that includes generic haskell?
03:11:06 <sioraiocht> I don't think it does...
03:11:30 <enthropy> sioraiocht: you mean -XGenerics?
03:11:35 <sioraiocht> yes
03:11:36 <ski> enthropy : yeah, one could ponder doing it with declarative concurrency (like in Oz)
03:11:56 <ski> iirc ddarius was thinking about making some kind of implementation of such in Haskell
03:12:26 <enthropy> that one doesn't seem to be very common, and it seems your best description would be the ghc manual
03:12:39 <enthropy> :t undefined :: 1
03:12:40 <lambdabot> Unit
03:13:09 <Jafet> :t undefined :: 5
03:13:10 <lambdabot> Only unit numeric type pattern is valid
03:13:50 <enthropy> :t undefined :: 1 :+: 1
03:13:51 <lambdabot> Unit :+: Unit
03:16:25 <opqdonut> heh, nice
03:17:19 * Jafet wonders if type 5 = 1 :+: 1 :+: 1 :+: 1 :+: 1
03:17:41 <enthropy> anyways, between :*:, :+:, and 1, you can supposedly write functions that look normal but operate on lots of types
03:18:01 <Jafet> :t undefined :: 0
03:18:02 <lambdabot> Only unit numeric type pattern is valid
03:18:12 <Jafet> Seems like a notable omission
03:18:48 <enthropy> dons had something about -XGenerics being faster than syb, but maybe there are some reasons it's not commonly used
03:19:24 <enthropy> @where generics
03:19:24 <lambdabot> I know nothing about generics.
03:19:38 <eagle-runner> lambdabot: omg you are back, miss you so much!
03:19:57 <eagle-runner> @instances Monoid
03:19:58 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
03:20:29 <quicksilver> sioraiocht: -XGenerics is documented in a research paper isn't it? :(
03:21:37 <Jafet> @vixen Say you'll share with me one tail, one pattern
03:21:37 <lambdabot> so?
03:44:15 <Mitar> who makes Mac OS X GHC installer?
03:44:22 <Mitar> i would have some suggestion for him/her?
03:45:29 <JaffaCake1> Mitar: Mark Lentczner just took over
03:45:45 <Mitar> is he around?
03:45:51 <JaffaCake> don't know
03:45:52 <Mitar> is there a trac/ticketing for that?
03:46:09 <quicksilver> it's ticketed in the main GHC trac
03:46:36 <JaffaCake> try http://www.haskell.org/haskellwiki/Mac_OS_X_Strike_Force
03:47:30 <Mitar> thanks
03:48:50 <quicksilver> gah!
03:48:57 <quicksilver> haskellers.com-- # forums. not want.
03:49:16 <DL> The OSX installer didnt work for me...I couldnt click 'next' in one of the screens
03:49:44 <Mitar> DL: it worked for me
03:50:18 <DL> I'll check my version etc when I'm on my mac
03:50:41 <Mitar> i had to run it twice, but it worked
03:50:54 <DL> I've run it 5 times by now ... :D
03:51:40 <Mitar> and at which step does it hang?
03:51:54 <DL> Rigth after the 'choose location' screen
03:52:33 <DL> But I cant access my mac right now
03:53:32 <ski> quicksilver : ?
03:53:49 <quicksilver> ski: Why have yet another place for discussion?
03:53:55 <quicksilver> we can already discuss on the wiki and by email
03:54:02 <quicksilver> another place just fragments the community
03:54:34 <quicksilver> I confess to being biased. I despise forums with the venom of a thousand snakes.
03:54:55 <JaffaCake> the community is too big these days to have just one place for discussion
03:55:04 <Mitar> i agree about forums
03:55:15 <Mitar> they are poor design: you have to poll for new information
03:55:24 * JaffaCake hates forums too
03:55:31 <Mitar> you can have then multiple mailing lists ;-)
03:55:46 <JaffaCake> people who like forums typically don't like mailing lists
03:55:52 <ski> quicksilver : oh, never seen that before
03:55:52 <int-e> Mitar: I think the real issue is the lack of choice of UI.
03:56:14 <quicksilver> JaffaCake: well the wiki (which has an unlimited number of pages) + multiple mailing lists is an infinitely large place
03:56:43 <quicksilver> ski: e.g. : http://www.haskellers.com/topics/3/ - another place for people to ask questions 
03:56:46 * arcatan has never liked mailing lists, probably because all e-mail clients suck
03:57:39 <ski> arcatan : .. and usenet ?
03:57:53 <arcatan> ski: i did prefer newsgroups to mailing lists
03:58:14 * ski always wonders why (apparently) non-companies want to use the `com' top-level domain
03:59:23 <arcatan> ski: probably because "all the web addresses are like www dot com"
03:59:45 <opqdonut> the other options are basically org and net
04:00:05 * quicksilver thinks either would have been appropriate for haskellers :)
04:00:10 <opqdonut> org isn't always that applicable, and net is supposed to be solely for isps and other network-related entities
04:00:18 <arcatan> plus not everyone even knows that .com stands for commercial
04:00:19 <opqdonut> haskellers.org would've worked I guess
04:00:19 <ski> this reminds me of "Thread Theory" at <http://www.rants.org/2008/03/06/thread_theory/> by Karl Fogel : "The thread is the fundamental unit of conversational information on the Internet, and the message relationships in a thread are independent of the mechanism used to access that thread."
04:01:25 <ksf> no, they aren't.
04:01:34 <ksf> mailing list threads are the obvious exception.
04:01:36 <ksf> and usenet.
04:01:39 <ksf> and fori.
04:01:43 <ksf> and reddit.
04:01:50 <ksf> wait, everything is hell.
04:02:08 <quicksilver> ski: forum threads are qualitatively different from email threads (at least, typically)
04:02:19 <quicksilver> ski: email threads are tree-structured and forum threads are linear.
04:02:36 <ksf> forum threads are tree-structured, too.
04:02:40 <ksf> just not visibly so.
04:02:51 <quicksilver> I don't believe you :)
04:03:05 <quicksilver> I think most forums do not record, or care, if you reply to an individual message
04:03:10 <quicksilver> maybe don't even give you the option.
04:03:10 <ski> afaiu, that post argues for there to be a single unifying abstraction that all these fit into (and which is interface-agnostic)
04:03:17 <ksf> well, show me a forum where members regularily answer to the whole thread.
04:03:28 <quicksilver> my point is that all posts go at the end
04:03:35 <quicksilver> the system does not record which post you were replying to
04:03:36 <ksf> ...if they do, they answer to the first post, or at the utmost the first page.
04:03:41 <ski> quicksilver : not at LtU, e.g.
04:03:47 <koala_man> ksf: any of them, usually on the form "this thread is stupid"
04:03:53 <quicksilver> ski: no, LtU is much more email/newgroup like
04:03:55 <Mitar> some time ago i made a forum-like interface to usenet
04:04:01 <DL> Depends on your forum software. There are forums (like VB4) with treelike layout
04:04:02 <quicksilver> ski: I'm talking about crap forums written in PhP
04:04:03 <Mitar> people didn't know that usenet is behind
04:04:07 <quicksilver> ski: which is most of them.
04:04:09 <Mitar> and it worked quite well
04:04:13 <Mitar> and it also had threading
04:04:14 <ksf> maybe they don't track a tree, but there's per-message quote buttons, and those are used.
04:04:16 <ksf> I rest my case.
04:04:21 <ski> quicksilver : i admit not having that much experience with such
04:04:35 <Mitar> so for people who prefered forums, it was a forum, for people who preferred usenet, it was usenet
04:04:36 * ski . o O ( hm .. "www.haskell.gov : we're making sure you follow the type rules !" )
04:04:38 <quicksilver> ski: keep it that way, is my advice :)
04:04:42 <quicksilver> ski++
04:04:59 <shachaf> quicksilver: I don't understand why those are so popular.
04:05:08 <ksf> the german pirate party made a forum interface to nntp to unify that ML/forum mess that's currently existing.
04:05:08 <shachaf> Everything about that format is just so unappealing.
04:05:27 <quicksilver> shachaf: I don't really understand. I can only guess.
04:05:40 <quicksilver> shachaf: people find the UI more attractice and/or easier to navigate than their email client
04:05:41 <ksf> figures the reason the switch isn't made yet is forum moderators spreading FUD among their minions because they fear losing authority.
04:05:54 <quicksilver> shachaf: I find neither of those things, but that's still what I guess.
04:05:56 <shachaf> quicksilver: I don't think mail clients are all that ideal either.
04:06:17 <DL> Since you guys dont want me to go to a forum, I'll post my Haskell question here then ;)
04:06:43 * hackagebot manatee 0.0.9 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.9 (AndyStewart)
04:06:48 <ManateeLazyCat> I just fix bug "paste clipboard in interactivebar" of manatee-0.0.8....
04:06:49 <Mitar> how can i write into cabal dependency that I am using mask/restore and not block/unblock?
04:06:50 <ksf> ...basically all moderation planned is moving stuff (yes you can do that with nntp), and they're fearing losing control over a thing they never, ever controled.
04:07:15 <quicksilver> Mitar: depend on the base version in which it change, I think? (which was 5.x?)
04:07:25 <quicksilver> DL: ask away, that's what we're here for.
04:07:36 <quicksilver> a good haskell question might stop us ranting about how much I hate forums :)
04:07:51 <Mitar> ksf: can you give a link to that software?
04:08:06 <DL> I need to invert a 2D list. Like this: [ (0,"abc"), (1,"acd") ]  =====> [('a',[0,1]),('b',[0]),('c',[0,1]),('d',[1])]
04:08:15 <ksf> Mitar, erm... no.
04:08:32 <Mitar> ?
04:08:35 <Mitar> it is not public?
04:08:56 <ksf> no, I have no idea where it is or what's it called.
04:09:45 <DL> Are there any built in functions I could use ?
04:10:17 <ksf> Mitar, http://wiki.piratenpartei.de/Syncom
04:10:33 <ski> DL : try going through the intermediate stage  [ (0,'a'), (0,'b'), (0,'c'), (1,'a'), (1,'c'), (1,'d') ]  ?
04:11:28 <DL> ski: ok, lets see if I can get there
04:11:36 <ksf> Mitar, I bet they release it if you ask nicely.
04:11:44 <Mitar> thanks
04:12:09 <ksf> ...most likely a hodgepodge of perl scripts.
04:12:14 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength = fmap . (,)
04:12:15 <lambdabot>  <local>:6:45:
04:12:15 <lambdabot>      Occurs check: cannot construct the infinite type:
04:12:15 <lambdabot>        ...
04:12:33 <ski> @let strength :: Functor f => (a,f b) -> f (a,b); strength = uncurry (fmap . (,))
04:12:35 <lambdabot>  Defined.
04:12:43 <zygoloid> huh, there's no Traversable ((,) a) instance ;(
04:12:44 <ski> > strength =<< [ (0,"abc"), (1,"acd") ]
04:12:45 <lambdabot>   [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'c'),(1,'d')]
04:13:01 <zygoloid> (strength = traverse)
04:14:53 <ski> @type equating
04:14:55 <lambdabot> Not in scope: `equating'
04:14:58 <ski> @type comparing
04:14:59 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:15:30 <shachaf> @let equating = on (==)
04:15:31 <ski> @let equating :: Eq a => (b -> a) -> (b -> b -> Bool); equating = ((==) `on`)
04:15:31 <lambdabot>  Defined.
04:15:32 <lambdabot>  <local>:8:50:
04:15:32 <lambdabot>      Multiple declarations of `L.equating'
04:15:32 <lambdabot>      Declared at: <...
04:16:18 <ski> > groupBy (equating fst) (strength =<< [ (0,"abc"), (1,"acd") ])
04:16:19 <lambdabot>   [[(0,'a'),(0,'b'),(0,'c')],[(1,'a'),(1,'c'),(1,'d')]]
04:16:40 <ski> hm, probably needs a `sortBy', as well
04:16:55 <ski> > group "aababba"
04:16:56 <lambdabot>   ["aa","b","a","bb","a"]
04:18:22 <DL> f ((key:value):xs) list = ... is this allowed ?
04:18:27 <DL> (Nesting arguments)
04:18:30 <ski> yes
04:18:33 <DL> ok
04:18:33 <quicksilver> nesting arguments is fine
04:18:40 <quicksilver> your example might be wrong
04:18:43 <quicksilver> (it makes 'value' a list)
04:18:44 <ski> `xs' will be a list of lists, `value' will be a list, and `key' will be an element
04:18:51 <ski> maybe
04:18:55 <quicksilver> f ((key,value):xs) = .... -- would be more expected
04:19:02 <ski>   f ((key,value):assocs) list = ...
04:19:03 <quicksilver> but anyway, nested patterns is fine.
04:19:10 <DL> Right, that has to be a ,
04:19:27 <ski> > (groupBy (equating fst) . sortBy (comparing fst)) (strength =<< [ (0,"abc"), (1,"acd") ])
04:19:29 <lambdabot>   [[(0,'a'),(0,'b'),(0,'c')],[(1,'a'),(1,'c'),(1,'d')]]
04:20:26 <ski> @type groupBy
04:20:27 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
04:20:40 <ski> @type sortBy
04:20:42 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
04:20:47 * hackagebot NXT 0.1.5 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1.5 (MitarMilutinovic)
04:21:26 <ski> @hoogle (a -> (b,c)) -> (b -> b -> Ordering) -> ([a] -> [(b,[c])])
04:21:27 <lambdabot> No results found
04:24:15 <ManateeLazyCat> Which mailing-list server do you use? I use gmane.org
04:24:47 <DL> Alright, I've arrived at the intermediate step
04:27:06 <DL> Why wont        map reverse [(1,a),(1,b)] work ?
04:27:25 <Saizan> because tuples are not lists
04:27:26 <nlogax> @type reverse
04:27:27 <lambdabot> forall a. [a] -> [a]
04:27:34 <DL> right
04:27:36 <mreh> :t swap
04:27:37 <lambdabot> Not in scope: `swap'
04:27:46 <sipa> > map (\(a,b) -> (b,a)) [(1,a),(1,b)]
04:27:47 <lambdabot>   [(a,1),(b,1)]
04:28:03 <nlogax> @pl \(a,b) -> (b,a)
04:28:04 <lambdabot> uncurry (flip (,))
04:28:13 <DL> Got it, thx
04:28:46 <mreh> exceptions would seem like a duff option for error handling to me, you cant handle them purely
04:29:27 <sipa> :t flip
04:29:28 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
04:29:48 <quicksilver> mreh: they're an OK option if you only use them in IO
04:29:55 <DL> I fixed it like this: reverseTuple (a,b) = (b,a)     :D
04:29:59 <quicksilver> mreh: because they are reasonable if you consider them 'part of the IO monad'
04:30:57 <mreh> quicksilver, ok
04:32:06 <quicksilver> mreh: and they behave rather like a polytypic Either monad, then
04:32:16 <quicksilver> Either Dynamic blah
04:34:52 <ski> @let groupAllBy :: (a -> (b,c)) -> (b -> b -> Ordering) -> ([a] -> [(b,[c])]); groupAllBy split compare = map (\ ~((b,c) : bcs) -> (b,c : map snd bcs)) . groupBy (((EQ ==) .) . compare `on` fst) . sortBy (compare `on` fst) . map split
04:34:54 <lambdabot>  Defined.
04:35:07 <ski> .. maybe something like that ought to be in a library (or already is) ?
04:37:45 <ski> > groupAllBy id compare (strength =<< [ (0,"abc"), (1,"acd") ])
04:37:47 <lambdabot>   [(0,"abc"),(1,"acd")]
04:37:48 <ski> > groupAllBy (snd &&& fst) compare (strength =<< [ (0,"abc"), (1,"acd") ])
04:37:49 <lambdabot>   [('a',[0,1]),('b',[0]),('c',[0,1]),('d',[1])]
04:39:00 <quicksilver> ski: I think what I would have done is put them in a map and taken them back out.
04:39:08 <quicksilver> ski: so the grouping and ordering would have been implicit.
04:39:41 <quicksilver> (using insertWith (++))
04:39:42 <ski> @hoogle insertWith
04:39:43 <lambdabot> Data.IntMap insertWith :: (a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
04:39:43 <lambdabot> Data.Map insertWith :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
04:39:43 <lambdabot> Data.Map insertWith' :: Ord k => (a -> a -> a) -> k -> a -> Map k a -> Map k a
04:39:55 <ski> yeah
04:40:19 <quicksilver> maps are great.
04:40:41 <quicksilver> @hoogle intersectionWith
04:40:41 <lambdabot> Data.IntMap intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
04:40:41 <lambdabot> Data.Map intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
04:40:41 <lambdabot> Data.IntMap intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
04:42:07 <Saizan> a bit harder to use a custom order, but you can solve that with a projection most of the time
04:42:34 <Cale> quicksilver: I hate linear forums too. I also don't see the need to further separate the community into different things that need to be checked separately.
04:43:18 <quicksilver> Saizan: wasn't clear to me that you really needed the order except as an efficient way to uniquify
04:43:27 <quicksilver> Saizan: maybe you have some generalisation in mind I wasn't seeing
04:43:54 <quicksilver> Cale: Yup. mailing lists + wiki + stackoverflow + reddit was already too many :)
04:44:02 <quicksilver> (I personaly ignore the last two)
04:45:03 <mreh> @src sequence
04:45:04 <lambdabot> sequence []     = return []
04:45:04 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
04:45:04 <lambdabot> --OR
04:45:04 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
04:45:36 <mreh> I cant help but think that looks like the writer monad
04:45:46 <quicksilver> how so?
04:45:51 <nlogax> i like the happy guy in the middle
04:46:22 <mreh> well a WriterT m monad
04:47:01 <quicksilver> i dont see how, mreh 
04:47:15 <Cale> While we're complaining about random stuff, I also have decided that I hate Xcode. It's a glorified filemanager that slowly balloons to over 500MB of memory and randomly dies with internal assertion failures. It also seems to randomly fail to start the app after building it, which is really the only thing I use it for.
04:47:32 <quicksilver> sequence just runs a bunch of actions and collects the results
04:47:35 <DL> Lol
04:47:47 <quicksilver> a writer monad lets you have some separate stream of log messages or something
04:48:01 <arcatan> Cale: we actually have an entire IRC channel for complaining about random stuff, namely the mighty -blah
04:48:05 <quicksilver> Cale: it's not even a very good file manager, at that :)
04:48:18 <Cale> arcatan: I already have enough channels.
04:48:22 <mreh> quicksilver: It can be implemented in the Writer monad i suppose
04:48:32 <quicksilver> mreh: sequence works in all monads
04:48:40 <quicksilver> it's a fairly fundament monad combinators
04:48:57 <mreh> quicksilver: not just implemented for, implemented in
04:49:08 <mreh> I'm sure this is not fundamentally new
04:49:49 <Cale> quicksilver: Yeah, stackoverflow also really bothers me, for fragmenting other existing communities needlessly.
04:49:54 <ski> implemented in an output monad, how ?
04:51:55 <quicksilver> Cale: the benefit of stackoverflow - when it works well - is providing a convenient searchable database of good answer.
04:52:24 <quicksilver> Cale: mailing lists aren't very good at that, since mailing list threads are more likely to wander off-topic or be badly answered, or have the thread broken by oleg and the good answers appear in another thread.
04:52:36 <Cale> heh
04:52:53 <quicksilver> (not that those advantages make me use stackoverflow myself, but I do occasionally find good answers in it when googling stuff)
04:53:19 <ManateeLazyCat> Haha, GoogleGroup is best one! :)
04:53:23 <quicksilver> but at least stackoverflow has that objective which sets it apart from a random discussion forum.
04:54:01 <mreh> mathoverflow is a dangerous place
04:56:23 <Cale> http://mathoverflow.net/questions/47304/are-any-powers-of-two-divisible-by-three-or-five-closed -- lol
04:56:23 <ski> (i wonder why they couldn't find a better name for "mathoverflow" .. "overflow" doesn't sound that math-like)
04:56:52 <Starfire> mathmoduloarithmetic?
04:57:47 <Mitar> do you know when 7.0.2 will be out?
04:57:50 <Entroacceptor> ouch
04:59:13 <quicksilver> Cale: ... however, we could, if we wished, curate good answers on the wiki; however it takes community time to do so.
04:59:23 <quicksilver> stackoverflow, oddly, seems to have the community weight to do these things.
04:59:34 <quicksilver> people must find moderating stackoverflow more fun than curating wikies.
05:00:26 <Cale> I liked the old wiki.
05:00:43 <Cale> Somehow mediawiki doesn't lend itself to actually being used like a wiki
05:01:52 <ManateeLazyCat> Cool, i have test, GoogleGroup is best choose for mailing-list...
05:02:25 <eagle-runner> arrow's loop seems really strange, it results in a closed circle, then how to give it an initial value?
05:02:42 <quicksilver> you can't. the closed circle must have a fixed point all of it's own.
05:02:43 <ManateeLazyCat> I have create two mailing-list : manatee-user@googlegroups.com and manatee-develop@googlegroups.com, welcome to discuss any problem about Manatee. :)
05:04:10 <quicksilver> manatee++ # community building
05:04:21 <eagle-runner> @src loop
05:04:22 <lambdabot> Source not found. You untyped fool!
05:04:34 <quicksilver> I look forward to the day when the haskell community is just an obscure backwater of the larger manatee community.
05:04:44 <quicksilver> eagle-runner: it's a method, so it doesn't have a single source
05:04:56 <Mitar> this is spam? http://hackage.haskell.org/trac/ghc/wiki/Building/MacOSX?action=diff&version=19&old_version=16
05:04:59 <quicksilver> I can't give you an interesting example of it.
05:05:13 <quicksilver> Mitar: yes.
05:05:37 <Mitar> but it was made by two persons
05:05:40 <eagle-runner> quicksilver: i see, it that fixed point generated by analysis, or convergence?
05:05:57 <Cale> eagle-runner: By recursion
05:06:07 <quicksilver> > fix (1:)
05:06:08 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
05:06:12 <Cale> In a similar way to  fix f = let x = f x in x
05:06:12 <quicksilver> ^^ simple example of a fixed point
05:06:20 <Mitar> JerryM and abhinav
05:06:25 <quicksilver> should be able to embed that into an example of 'loop' but I'm not sure how
05:06:26 <ski> Cale : yeah, i thought moinmoin was nicer than the new wiki, somehow
05:07:29 <Cale> > loop (\ ~(n, fib) -> (fib n, \n -> if n == 0 then 1 else n * fib (n-1))) 10
05:07:30 <lambdabot>   3628800
05:07:49 <Cale> actually, that ~ isn't needed
05:07:53 <Cale> > loop (\(n, fib) -> (fib n, \n -> if n == 0 then 1 else n * fib (n-1))) 10
05:07:54 <lambdabot>   3628800
05:07:58 <ski> @src (->) loop
05:07:58 <lambdabot> Source not found. Take a stress pill and think things over.
05:08:05 <ski> @type loop
05:08:07 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowLoop a) => a (b, d) (c, d) -> a b c
05:08:31 <Cale> instance ArrowLoop (->) where
05:08:31 <Cale>         loop f b = let (c,d) = f (b,d) in c
05:09:41 <eagle-runner> > fix (\x -> sqrt $ x + 90)
05:09:43 <Cale> > loop (\(n, xs) -> (xs, n:xs) 10
05:09:44 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:09:45 <lambdabot>   mueval-core: Time limit exceeded
05:09:50 <Cale> > loop (\(n, xs) -> (xs, n:xs)) 10
05:09:51 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
05:09:54 <Cale> > loop (\(n, xs) -> (xs, n:xs)) 5
05:09:54 <ski> eagle-runner : if you're thinking about some kind of stream transforming arrows, then instead of `loop' you often want a similar operation, that gives an initial input or output
05:09:55 <lambdabot>   [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,...
05:10:14 <eagle-runner> ski: im just curious about loop
05:10:22 <eagle-runner> why can not fix (\x -> sqrt $ x + 90) give a 10?
05:10:25 <Cale> eagle-runner: fix finds the least defined fixed point of a function
05:10:43 <Cale> eagle-runner: If undefined/nontermination is a fixed point, then that's what you'll get
05:10:44 <endojelly> "least defined", what does that mean?
05:11:54 <Cale> Every datatype is partially ordered with respect to definedness, where we normally write nontermination or abject failure as a value _|_ (called bottom), which is less than anything else.
05:12:44 <Cale> One function f is at least as defined as another function g if f x = g x whenever g x is defined.
05:13:11 <Cale> Well, I should really say if f x is at least as defined as g x for all x :)
05:13:44 <eagle-runner> Cale: so it seems only a few functions have a (fix f)?
05:13:45 <Cale> For lists, _|_ is less than [] and (_|_ : _|_)
05:14:07 <Cale> and (_|_ : _|_) is less than (1 : _|_) and (_|_ : []), for instance
05:14:12 <quicksilver> eagle-runner: anything you would normally expect to define recursively, basically.
05:14:33 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
05:14:34 <lambdabot>   3628800
05:14:40 <ski> eagle-runner :  x^2 = x + 90  <=>  x^2 - x + (1/2)^2 = 361/4  <=>  (x - 1/2)^2 = (19/2)^2  <=>  x - 1/2 = 19/2 \/ x - 1/2 = -19/2  <=>  x = 10 \/ x = -9
05:14:55 <quicksilver> the definedness order that cale describes is how you use fixed points to make sense out of recursive functions.
05:15:01 <quicksilver> this is by no means an obvious observation.
05:15:12 <quicksilver> it's a very clever one, but it is quite fundamental to the theory of programming languages.
05:15:13 <ski> eagle-runner : so there's two possible (ground / determined) solutions, which of them should `fix (\x -> sqrt (x + 90))' give ?
05:15:33 <zygoloid> eagle-runner: for a function to be meaningly usable from fix, you need a sequence of values: _|_, f _|_, f (f _|_), ... which get more and more defined. the limit of that sequence is the result.
05:16:01 <zygoloid> (if f _|_ = _|_, then all terms are _|_, so that's the limit)
05:16:18 <endojelly> Cale, aah. thanks
05:16:58 <endojelly> Cale, it's a non-strict order, I guess?
05:17:07 <Cale> It's a directed complete partial order
05:17:26 <endojelly> Cale, because for integers, neither 2 nor 5 seems more defined than the other, I guess?
05:17:44 <Cale> right
05:17:53 * eagle-runner is trying to understand
05:18:01 <zygoloid> Cale: what does "directed" mean in this context?
05:18:11 <Cale> directed-complete
05:18:21 <Cale> Each of the directed subsets has a supremum
05:18:39 <zygoloid> i see. like chain-complete?
05:18:44 <Cale> A directed subset is one for which any pair of elements has an upper bound in the set
05:18:48 <Cale> yeah
05:18:56 <endojelly> Cale, 2 and 5 are upper bounds, aren't they?
05:18:57 <Cale> (similar)
05:19:09 <eagle-runner> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
05:19:10 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
05:19:10 <lambdabot>    arising from a use of `...
05:19:17 <Cale> endojelly: {2,5} has no upper bound
05:19:20 <endojelly> Cale, cannot imagine anything "more" defined for the integers
05:19:32 <endojelly> Cale, oh, ok
05:19:42 <Cale> endojelly: So the set {2,5} has no required supremum
05:19:49 <endojelly> makes sense
05:19:53 <Cale> (It's not a directed subset)
05:20:12 <Cale> eagle-runner: This is all a quite technical explanation...
05:20:25 <endojelly> Cale, okay cool, can you give me common examples for least defined fixed points and... whatever the opposite ist? 8)
05:20:39 <Cale> Well, let's look at the factorial
05:21:04 <Cale> I constructed the factorial function as the fixed point of (\fac n -> if n == 0 then 1 else n * fac (n-1))
05:21:25 <Cale> Let's plug undefined in as the first parameter to this function.
05:21:42 <Cale> Do we get an undefined function as the result?
05:21:57 <eagle-runner> depends on n?
05:22:01 <Cale> We get: \n -> if n == 0 then 1 else n * undefined (n-1)
05:22:18 <Cale> So this is a function which is defined for n == 0
05:22:20 <zygoloid> > fix (\facs -> zipWith (*) [1..] (1:facs))
05:22:21 <lambdabot>   [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,8...
05:22:24 <Cale> and not for other values
05:22:37 <endojelly> got that
05:22:48 <Cale> So it's a little bit more defined than undefined was
05:23:06 <Cale> If we continue applying the function (\fac n -> if n == 0 then 1 else n * fac (n-1))
05:23:10 <ManateeLazyCat> Sorry all, Manatee spawn come again. :)
05:23:17 <Cale> (perhaps I should give it a name, like mkFac or something ;)
05:23:31 <endojelly> it's okay 8)
05:23:31 <ManateeLazyCat> Maybe we can filter hackagebot message? 
05:23:36 <Cale> then we get functions which are defined on more and more values
05:23:54 <zygoloid> ManateeLazyCat: if it bothers people they can /ignore hackagebot :)
05:23:54 <endojelly> okay. yes.
05:23:58 <endojelly> nice!
05:24:07 * hackagebot manatee-core 0.0.4 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.4 (AndyStewart)
05:24:09 * hackagebot manatee-anything 0.0.4 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.4 (AndyStewart)
05:24:18 <Cale> > let mkFac = \fac n -> if n == 0 then 1 else n * fac (n-1) in map (mkFac (mkFac undefined)) [0,1,2]
05:24:19 <lambdabot>   [1,1,*Exception: Prelude.undefined
05:24:30 <Cale> > let mkFac = \fac n -> if n == 0 then 1 else n * fac (n-1) in map (mkFac (mkFac (mkFac undefined))) [0,1,2,3]
05:24:31 <lambdabot>   [1,1,2,*Exception: Prelude.undefined
05:24:41 <Cale> > let mkFac = \fac n -> if n == 0 then 1 else n * fac (n-1) in map (mkFac (mkFac (mkFac (mkFac undefined)))) [0,1,2,3,4]
05:24:42 <lambdabot>   [1,1,2,6,*Exception: Prelude.undefined
05:24:43 <ski> (Cale : didn't you agree to s/defined for n == 0/defined for n = 0/ some week ago ? :)
05:24:43 <ManateeLazyCat> zygoloid: Maybe hackagebot can filter Manatee (so many packages), if people want follow use RSS. :)
05:25:05 <Cale> ski: Well, I actually used that condition as such in the code.
05:25:11 * hackagebot manatee-browser 0.0.4 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.4 (AndyStewart)
05:25:13 * hackagebot manatee-editor 0.0.4 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.4 (AndyStewart)
05:25:15 * hackagebot manatee-filemanager 0.0.4 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.4 (AndyStewart)
05:25:17 * hackagebot manatee-pdfviewer 0.0.4 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.4 (AndyStewart)
05:25:19 * hackagebot manatee-mplayer 0.0.4 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.4 (AndyStewart)
05:25:39 * ski thinks `manatee-anything' is a strange package name ..
05:25:47 <quicksilver> hackagebot could accumulate new packages into an N-minute window
05:25:52 <quicksilver> and then make one single announcement
05:25:58 <quicksilver> for multiple packages.
05:26:05 <ManateeLazyCat> ski: Search anything.el in EmacsWiki.org
05:26:06 <quicksilver> (in a more concise format than the normal one)
05:26:20 <endojelly> Cale, so the least defined fixed point for mkFac is the faculty function defined for 0?
05:26:21 * hackagebot manatee-ircclient 0.0.4 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.4 (AndyStewart)
05:26:23 <ManateeLazyCat> quicksilver: Agree
05:26:23 * hackagebot manatee-processmanager 0.0.4 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.4 (AndyStewart)
05:26:25 * hackagebot manatee-imageviewer 0.0.4 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.4 (AndyStewart)
05:26:25 <endojelly> Cale, but undefined for all others
05:26:27 * hackagebot manatee-reader 0.0.4 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.4 (AndyStewart)
05:26:27 <Cale> factorial function
05:26:29 * hackagebot manatee-curl 0.0.4 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.0.4 (AndyStewart)
05:26:32 <Cale> no
05:26:33 <ManateeLazyCat> Sorry. 
05:26:40 <ManateeLazyCat> I'm so sorry
05:26:44 <Cale> the least defined fixed point is the full factorial function
05:26:49 <endojelly> Cale, sorry, I often say faculty because that's what it's called in german
05:26:50 <quicksilver> don't be sorry, we love you ManateeLazyCat :)
05:26:53 <ski> endojelly : s/faculty/factorial/ :)
05:26:58 <ManateeLazyCat> quicksilver: Thanks. :)
05:27:12 <endojelly> ski, cale already told me, thanks
05:27:17 <Cale> Remember, it's the least defined function for which mkFac f = f
05:27:30 <endojelly> Cale, oh, right!
05:27:31 * hackagebot manatee 0.1.0 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.0 (AndyStewart)
05:27:48 <ManateeLazyCat> Ok, Just update mailing-list docs.
05:27:56 <endojelly> Cale, I forgot to take the "fixed point" into account 8)
05:27:58 <ManateeLazyCat> I will create new video and VirtualBox vdi soon.
05:28:06 <eagle-runner> Cale: so it recurse again and again, until something is defined?
05:28:09 <ManateeLazyCat> Then any platform can play Manatee in VirtualBox.
05:28:17 <endojelly> Cale, and the... most defined fixed point? is that what you call it?
05:28:28 <nlogax> ManateeLazyCat: you're a beast! in the most positive sense :)
05:28:44 <ManateeLazyCat> nlogax: :)
05:29:26 <Cale> eagle-runner: yeah. fix f actually doesn't need to start with undefined and apply the function over and over. It just defines a value x where x = f x, and hands you that.
05:29:39 <Cale> But that might result in a function which calls itself :)
05:29:49 <Ke> how about manatee-email-client with gvfs and gpg support
05:29:50 <ManateeLazyCat> ski: manatee-anything is inspire from anything.el (Emacs extension), and anything.el is inspire from quicksilver in MacOS.
05:30:00 <ManateeLazyCat> Ke: Come soon.
05:30:06 <Ke> =o)
05:30:07 <ManateeLazyCat> s/come/coming
05:30:19 <Ke> ManateeLazyCat: really gvfs?
05:30:20 <Cale> endojelly: Well... those don't generally exist, but when the least-defined fixed point exists, it's usually also the most defined one.
05:30:21 <ManateeLazyCat> Ke: I plan build Mail-Client to support IMAP-Offline
05:30:29 <Cale> endojelly: (but not always)
05:30:33 <endojelly> Cale, have to go now, I'll be back in a few minutes. thanks a lot so far!
05:30:48 <ManateeLazyCat> Ke: I will build simple version first, then add new features like gpg.
05:31:39 <Cale> eagle-runner: for example...
05:31:53 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
05:31:54 <ManateeLazyCat> If anyone have question or suggestion about Manatee, ask in manatee-user@googlegroups.com, i will reply as soon as i can. Thanks! :)
05:32:02 <Cale> -> let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
05:32:09 <ManateeLazyCat> manatee-develop@googlegroups.com for Manatee developer. 
05:32:11 <Cale> -> let x = (\n -> if n == 0 then 1 else n * x (n-1)) x in x
05:32:14 <Cale> er, oops
05:32:20 <Cale> -> let x = (\n -> if n == 0 then 1 else n * x (n-1)) in x -- correction
05:32:47 <Cale> which is the same as  let x n = if n == 0 then 1 else n * x (n-1) in x
05:33:00 <Cale> (the same as defining the factorial function recursively)
05:34:15 <eagle-runner> Cale: great, i'm following the steps
05:34:38 <justin_> Hello! I was wondering if anyone could answer a question about data accessors?
05:34:44 <Cale> Similarly, we can do:
05:34:46 <Cale> fix (1:)
05:34:51 <Cale> -> let x = (1:) x in x
05:34:55 <Cale> -> let x = 1:x in x
05:35:14 <Cale> which actually becomes a circularly-linked structure in memory
05:35:23 <ski> ManateeLazyCat : ok
05:35:26 <Ke> am I still the only one interested in haskell and external sandboxing
05:35:26 <Cale> (x contains a pointer to itself)
05:35:40 <Cale> justin_: Probably. Just ask :)
05:35:50 <eagle-runner> Cale: oh really, it's a self-loop?
05:36:16 <justin_> Thanks!  Okay, I have something like:
05:36:16 <ManateeLazyCat> ski: Simple, manatee-anything is multi-threads framework, that search and do it.
05:36:40 <eagle-runner> fix ([1..3]++)
05:36:40 <Cale> eagle-runner: yeah
05:36:43 <eagle-runner> > fix ([1..3]++)
05:36:44 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
05:36:53 <zygoloid> justin_: for more than one or two lines, paste your code at hpaste.org
05:36:54 <ManateeLazyCat> ski: Example, search filepath open, search url browse, search process, search application to startup, search name to send mail or twitter message..
05:37:00 <eagle-runner> and this is a circle of 1/2/3?
05:37:03 <Cale> yep
05:37:42 <Cale> This is because the definition of fix cleverly uses that let binding to define a value in terms of itself.
05:37:46 <ManateeLazyCat> ski: Screenshot for manatee-anything.el : http://www.flickr.com/photos/48809572@N02/5154125192/lightbox/
05:38:05 <Cale> If we had  fix f = f (fix f), it would do the same thing, but use more memory in some cases (it wouldn't be circular)
05:38:11 <ManateeLazyCat> ski: When you want do something, you just need press M-f and search you want, then press Return do it.
05:38:23 <justin_> Oh thanks.  So I have this: http://hpaste.org/41797/data_accessors
05:38:25 <ddarius> Create more garbage.
05:39:15 <eagle-runner> Cale: fix (1+) , let 1+x in x, that results in an infinite evaluation?
05:39:27 <Cale> eagle-runner: let x = 1 + x in x
05:39:28 <Cale> yeah
05:39:31 <ddarius> Live memory usage will probably be less.
05:39:38 <Jafet> Does the default derivation for Read parse infix operator constructors?
05:39:40 <Cale> and it will (usually) result in infinite evaluation
05:39:50 <justin_> My problem is that function I'm trying to use to modify (^:) the field is in the State monad, so it doesn't work.
05:39:55 <Cale> (Whenever (+) is strict, like it is with all the usual numeric types)
05:40:00 <zygoloid> what's happened to Natural? does lambdabot not import it any more?
05:40:00 <ddarius> Jafet: Yes.
05:40:09 <justin_> I get Couldn't match expected type `[WorldAgent]' against inferred type `State StdGen [WorldAgent]'
05:40:16 <ddarius> > read "3 :+ 5" :: Complex Double
05:40:17 <lambdabot>   3.0 :+ 5.0
05:40:38 <Jafet> So I could build an expression evaluator using string replacement and Read instances
05:40:51 <Cale> justin_: What's the error message?
05:40:55 <Cale> oh
05:40:56 <Cale> sorry
05:40:57 <Cale> :)
05:40:59 <ManateeLazyCat> I try to build mailing-list on gmane.org, last i found GoogleGroups is cooler.
05:41:16 <Cale> justin_: Is  type World = [WorldAgent] ?
05:41:19 <justin_> Cale: no worries.  I guess I need a liftM somewhere, but I can't figure out where.
05:41:20 <ManateeLazyCat> You can view mailing-list and don't need install any mail-client.
05:41:37 <Cale> justin_: You probably just need return
05:41:55 <justin_> Cale: no, but agents is a field in World that is of type [WorldAgent]
05:41:55 <Cale> justin_: because this isn't really a State monad computation
05:42:00 <quicksilver> justin_: don't think he needs return; "f" uses the state monad
05:42:07 <quicksilver> Cale: well that was meant for you
05:42:10 <Cale> er, oh
05:42:15 <quicksilver> justin_: didn't mean to reply to you in the third person :)
05:42:40 <quicksilver> I'd quite like to see the type of randomiseWorldAgentPos, I don't quite follow the code.
05:42:45 <Cale> Well, f is a State monad computation, I suppose. Maybe you want to run it?
05:42:55 <justin_> quicksilver: no worries :).  Yeah, return gives the same error.
05:43:30 <Cale> Try   do f' <- f; return (agents ^: f $ world)
05:43:32 <Cale> er
05:43:35 <Cale>    do f' <- f; return (agents ^: f' $ world)
05:43:49 <Cale> Maybe that's what you're after?
05:43:59 <Cale> I don't really have enough context to know for sure
05:44:05 <justin_> Cale:  One sec, I'll give it a shot.
05:45:03 * Cale waits for the game to install to the iPhone simulator some more :)
05:45:49 <Cale> Sometimes it's 30 seconds, sometimes it takes 5 minutes. :P
05:45:53 * ddarius found a great new game called ProgressQuest, but the install bar is still going.
05:45:59 <Cale> ddarius: hehe
05:47:24 <justin_> Cale: No, I'm not sure that's the answer.  So, for context World has a field agents, which is of type [WorldAgent].  f in the paste thing gives [WorldAgent] -> State StdGen [WorldAgent].  So when I do the modify, the State monad is inside the record, not outside.  If that makes sense?
05:47:49 <justin_> Cale: I guess I need a liftM somewhere or somehow, but I'm not sure where.  Or if that's the answer.
05:48:08 <ddarius> > 4 * sqrt 6
05:48:09 <lambdabot>   9.797958971132712
05:48:28 <ddarius> > 4 * sqrt 6 * 2 * pi
05:48:29 <lambdabot>   61.56239184776947
05:48:39 <justin_> quicksilver: sorry, I missed your message.  randomiseWordAgentPos is Int -> Int -> WorldAgent -> State StdGen WorldAgent
05:48:51 <Cale> justin_: um, well, presumably you want to actually run the computation expressed by f
05:49:23 <Cale> justin_: Oh, what's the type of randomiseWorldAgentPos?
05:49:39 <justin_> Cale: Int -> Int -> WorldAgent -> State StdGen WorldAgent
05:49:47 <Cale> ah, f needs another parameter -- the list of agents.
05:50:18 <Cale> So, give it that, and actually run it, before updating the record with the new list of agents
05:50:29 <ddarius> > map (\x -> round $ 2 * pi * sqrt (100 - x^2)) [0..10]
05:50:30 <lambdabot>   [63,63,62,60,58,54,50,45,38,27,0]
05:50:30 <justin_> Cale: Yeah, the list of agents is the field that I'm modifying.
05:50:37 <justin_> Cale: in world
05:51:04 <endojelly> Cale, so in that factorial (not faculty :D but seriously, that's what it's called in german) example, I see that it's possible to define the factorial without the function having to call itself, so recursion without... hmm... without a name map... I don't know, what's the proper expression?
05:51:40 <ddarius> > map (\x -> round $ 2 * pi * sqrt (25 - x^2)) [0..5]
05:51:41 <lambdabot>   [31,31,29,25,19,0]
05:51:45 <endojelly> Cale, anyway, my question actually was: can you do that generally, that is, can you write every recursive function as the least fixed point of somesuch?
05:51:54 <Cale> endojelly: yes
05:52:06 <ptr_> I have a problem with them IO monads, I'm implementing a small BASIC intepreter and I'm trying to do the printout (which ofc requires side-effects) but for some reason my output seems to appear in the reverse order
05:52:21 <sipa> endojelly: take a function f, that refers to f in its body
05:52:30 <ddarius> > map (\x -> round $ 2 * pi * sqrt (25 - x^2)) [0, 0.5 .. 5]
05:52:31 <lambdabot>   [31,31,31,30,29,27,25,22,19,14,0]
05:52:32 <Cale> endojelly: So in a language without recursive definitions, we can throw in fix as a primitive and recover recursion.
05:52:34 <sipa> turn it into g, and pass it an extra argument f
05:52:34 <endojelly> Cale, cool. makes sense.
05:52:35 <ptr_> I guess the IO actions are being stacked up and all executed after program is finished therefore being reversed
05:52:57 <quicksilver> justin_: I think you want: newagents <- f (world^.agents);
05:53:03 <endojelly> Cale, is that what it's called, what I meant above (and what sipa just wrote out), just "recursive definition"? sounds good
05:53:12 <ptr_> Does someone know an simple example of a program using I/O monads, but still complicated enogh to show how to structure the program?
05:53:13 <quicksilver> justin_: return (world { agents = newagents })
05:53:19 <Cale> ptr_: Note that evaluating IO actions does nothing, only executing them causes anything to happen.
05:53:21 <quicksilver> justin_: or, whatever the data.accessor syntax is for that last.
05:53:28 <Cale> So it'll be something like  do agents' <- mapM (randomiseWorldAgentPos w h) (world ^. agents); return ...
05:53:38 <Cale> yes
05:53:42 <endojelly> fix as a primitive... got it
05:54:16 <endojelly> well thanks.
05:54:29 <ptr_> Cale: so how do I execute them?
05:54:44 <quicksilver> justin_: return ( agents^=newagents $ world ), I believe.
05:54:55 <Cale> quicksilver beat me to it, because I was looking up how to do updates using data-accessor, but firefox is frozen because of some horrible interaction with VMware (linker is running in my VM -> linux kernel thrashes)
05:55:42 <quicksilver> *possibly* data.accessor needs a helper to run monadic modifies (a -> m a) on fields.
05:55:44 <Cale> ptr_: You write a do-block, and inside that do-block, the notation v <- x means to run the action x, getting the result v
05:55:58 <justin_> quicksilver: Brilliant, thanks.  I'll give it a shot.  I was hoping not to keep having to run the state.  I'll see if it works.
05:55:59 <Cale> ptr_: the do-block as a whole itself becomes an IO action
05:56:06 <Cale> (built up from the smaller ones)
05:56:19 <justin_> quicksilver: Yeah, I was thinking that it did, and I thought it must come with one.
05:56:27 <Cale> In the end, the only action which really runs is main, but it's in turn constructed by composing simpler actions.
05:56:31 <ptr_> Cale: so if I want to print, writing "putStr str" won't execute it, should i do "_ <- putStr str"?
05:56:57 <Cale> ptr_: No, if you leave the <- out, it means the same as that.
05:57:11 <Cale> (run, but don't bind the result of it to anything)
05:57:30 <hpc> as a more backend view of things
05:57:30 <Cale> ptr_: Let's actually look at your program and see what's going on.
05:57:34 <ptr_> Cale: okey
05:57:38 <hpc> do foo; bar translates to foo >> bar
05:57:54 <hpc> do x <- foo; bar translates to foo >>= \x -> bar
05:58:09 <hpc> x >> y = x >>= \_ -> y
05:58:24 <quicksilver> justin_: I wonder why your 'World' isn't inside the state too
05:58:34 <hpc> so doing "_ <-" is the same as ">>", which is the same as omitting the clause entirely
05:58:44 <quicksilver> justin_: your function has type World -> State StdGen World
05:58:58 <quicksilver> justin_: I wonder why it isn't simply State (StdGen,World) ()
05:59:06 <Cale> ptr_: Use hpaste.org or another paste site to paste your code :)
05:59:13 <quicksilver> (or some custom name for (StdGen,World))
05:59:32 <quicksilver> then you could use the special data.accessor monadstate stuff
05:59:40 <justin_> quicksilver:  Um, I'm not sure what you mean?  Should it be the second one?
05:59:42 <ptr_> Cale: http://pastebin.com/kBNzJxKr
06:00:00 <ptr_> Cale: it's kind of messy, so if you want I could try to make a smaller example
06:00:11 <quicksilver> justin_: well, they are isomorphic
06:00:15 <hpc> you want Data.Maybe, first of all
06:00:25 <ptr_> Cale: around line 135
06:00:38 <quicksilver> justin_: if you always read a world parameter and always return it, you might as well put that inside the state monad. That's what state monads are.
06:00:58 <Cale> okay, one sec (I have to put up with my machine thrashing during builds :)
06:01:04 <justin_> quicksilver: Hmmm, I just tried your example and it gives me the same error.
06:01:36 <justin_> quicksilver: Do you mean always as in over that function or all functions?
06:01:47 <quicksilver> justin_: all functions, or many functions.
06:02:01 <quicksilver> 'World' sounds like somehting you would often be modifying
06:02:08 <quicksilver> which sounds like the normal thing you stuff inside a state monad.
06:02:12 <quicksilver> anyway, that's just a style point
06:02:18 <quicksilver> paste the code which is now erroring?
06:02:26 <Cale> justin_: aha, okay
06:02:41 <Cale> justin_: So you're actually translating this source language into IO actions :)
06:03:08 <Cale> justin_: So what does the e parameter represent there? The continuation?
06:03:16 <ptr_> Cale: are you talking to me?
06:03:19 <Cale> errr
06:03:21 <Cale> yes, sorry :)
06:03:23 <justin_> Quicksilver: http://hpaste.org/41798/data_accessors_2
06:03:30 <ptr_> Cale: the e is the enviornment, for value bindings to strings
06:03:36 <ptr_> Cale: (or expressions really)
06:03:58 <quicksilver> justin_: newagents <- f (world^.agents)
06:03:58 <Cale> ptr_: You seem to be executing it after the print... but discarding its result.
06:04:01 <quicksilver> justin_: in a do block
06:04:08 <quicksilver> justin_: 'f' is a monadic action you want to 'execute'
06:04:16 <quicksilver> justin_: I'll edit the paste
06:04:24 <ptr_> Cale: executing e?
06:04:39 <Cale> ptr_: Yes. e is an IO action
06:04:55 * ManateeLazyCat Damn it, wrong mail address
06:05:00 <Cale> and you have there   do putStrLn "Print-statement!"; e
06:05:07 <ptr_> yeah
06:05:12 <ptr_> I hope it would print and then return e
06:05:16 <quicksilver> justin_: http://hpaste.org/paste/41798/put_it_in_a_do_block#p41799
06:05:33 <Cale> which denotes the action which when you run it, runs the action   putStrLn "Print-statement!",  followed by running the action e
06:05:46 <ptr_> okey, so how do I just return e?
06:05:51 <Cale> return e
06:05:58 <Cale> But that'll have a different type then.
06:06:01 <ptr_> yeah
06:06:08 <ptr_> so should i do ne <- e; return e?
06:06:11 <ptr_> ne*
06:06:14 <Cale> Probably you wanted e :: Env
06:06:17 <Cale> and not e :: IO Env
06:06:19 <justin_> quicksilver: Genius.  Thanks, that's fine.  I'm not exactly sure why, though?
06:06:31 <ptr_> but can a function that does side-effects return a non IO value?
06:06:37 <Cale> no
06:06:52 <Baughn> Functions don't do side-effects. IO values do side-effects.
06:06:54 <quicksilver> justin_: well, f is a monadic action.
06:06:59 <onteria> wohoo, haskell.org is finally moving to the new server
06:07:01 <ptr_> Baughn: ty =)
06:07:07 <quicksilver> justin_: you have to execute it
06:07:15 <quicksilver> justin_: 'let' doesn't do that.
06:07:20 <ptr_> Cale: my general confusion is how to structure the program
06:07:24 <Cale> ptr_: So  statement :: Stm -> Env -> IO Env
06:07:29 <Cale> in that case
06:07:55 <Cale> Unless for some reason, you really want your environment to be an action that can have side effects each time it's run
06:08:05 <justin_> quicksilver: Ah, okay.  That makes sense.  Thanks for your help.
06:08:14 <ptr_> Cale: no, I really don't,
06:08:36 <Cale> ptr_: A value of type (IO t) is completely different from a value of type t
06:08:53 <Cale> It's a description of some I/O which could be done in order to produce a value of type t
06:09:16 <Cale> So you could think of it like perhaps the source code of a C program :)
06:09:27 <quicksilver> or a compiled executable.
06:09:32 <Cale> or that, yeah
06:09:52 <Cale> Evaluating a value of type IO t does nothing interesting (just as opening the code of a program in a text or hex editor wouldn't execute it)
06:10:08 <Cale> But it describes something which can be carried out.
06:10:12 <ptr_> Okey
06:10:14 <Cale> (inside another IO action)
06:10:19 <ni_> hi
06:10:23 <ptr_> That's really nice information =)
06:10:42 <ni_> are you all real human?
06:11:02 <ptr_> so my functions that evaluates statements, what should they be returning?
06:11:05 <quicksilver> well, I'm not.
06:11:08 <Cale> ni_: Not *all*
06:11:22 <Cale> lambdabot is a bot :)
06:11:26 <Cale> and so is preflex
06:11:33 <Cale> But most of us are probably human
06:11:33 <Jafet> Poo, derived Read doesn't parse associative infix constructors
06:11:43 <ptr_> if they return Env (which feels like the most logical thing to do) I can't print
06:11:45 <Jafet> Some of us are too human
06:11:46 <Jonno_FTW> hello, I am using System.CPUTime  and got a very strange compile error
06:11:53 <ni_> hehe
06:11:57 <ptr_> so they should be IO Env?
06:11:58 <ni_> all are programmer?
06:12:06 <Jonno_FTW> prob71.o:fake:(.text+0x92b): undefined reference to `__stginit_Time_'
06:12:07 <Jonno_FTW> prob71.o:fake:(.text+0x88f): undefined reference to `Time_time1_info'
06:12:08 <Jonno_FTW> prob71.o:fake:(.data+0xd4): undefined reference to `Time_time1_closure'
06:12:41 <Zao> Do you -make or -package when you build it?
06:12:45 <Zao> +with it
06:12:48 <quicksilver> Cale: <pedant> some IO actions can do somethiing interesting when evaluated. like (\x -> putStrLn . concat $ [show x, "***", show x]) 5
06:12:55 <Jonno_FTW> no, I just used ghc -O3
06:13:02 <quicksilver> Cale: when evaluated it at least builds a closure etc.
06:13:10 <Jonno_FTW> woops I forgot the --make
06:13:29 <Cale> quicksilver: By "nothing interesting" I mean that it does nothing which is observable to the program itself.
06:13:37 <Cale> Or to the user
06:14:17 * quicksilver nods
06:14:31 <ptr_> Cale: I get the correct output now, and I think I start to understand how to structure it, thanks alot for the help =)
06:14:38 <ptr_> hopefully it is not just luck that makes it correct now :p
06:14:39 <quicksilver> Cale: but then you think nothing interesting happens when evaluating (3+4) either :)
06:14:47 <quicksilver> Cale: and I think that's a bit harsh on poor old evaluation.
06:15:34 <Cale> quicksilver: :)
06:15:42 <Cale> ptr_: great
06:20:40 <ManateeLazyCat> Hmmm, Haddock ignore @
06:20:52 <ski> Jafet : it doesn't ?
06:21:16 <ManateeLazyCat> I need re-build again
06:21:31 <Jafet> Hm, I caused the derived read to enter an infinite loop and exhaust memory
06:21:43 <ManateeLazyCat> Why haddock markup so weird?
06:21:58 <Jafet> > read "1:[]" :: [Int]
06:21:59 <lambdabot>   *Exception: Prelude.read: no parse
06:22:35 <ski> i think `read' on lists only support the `[a,b,c,...]' notation
06:22:43 <Jafet> I conclude that I do not understand deriving Read well enough
06:23:09 <quicksilver> Jafet: lists don't use deriving Read
06:23:14 <quicksilver> Jafet: lists are a big ugly hack.
06:23:21 <Jafet> Yeah, it's evident from above that they don't.
06:23:34 <ski> Jafet : did you try making a new datatype, with an infix constructor, with a corresponding fixity declaration
06:23:46 <Jafet> @where paste
06:23:46 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
06:24:03 <ski> quicksilver : yeah, but that's only to handle strings differently ..
06:24:12 <ManateeLazyCat> Hackage support documentation edit? I don't want re-upload Manatee again, it's spam.
06:24:56 <Jafet> http://hpaste.org/41800
06:25:12 <Jafet> (Try entering "(1 + 2) * 3"
06:25:14 <Jafet> )
06:25:20 <quicksilver> ManateeLazyCat: no, unfortunately not. Put the updated documentation on your own site, or it can wait for the next upload.
06:25:34 <Jafet> @index notElem
06:25:34 <lambdabot> Data.List, Prelude
06:26:16 <ManateeLazyCat> quicksilver: Haddock markup convert "manatee-user@googlegroups.com" "manatee-usergooglegroups.com", how do i know? :(
06:26:43 <quicksilver> ManateeLazyCat: I expect people will be ablt to work it out what you meant :)
06:26:56 <ski> endojelly : you can also define `fix' non-recursively
06:27:49 <Jafet> Well, it's merely a matter of outsourcing the recursion to somewhere less obvious
06:27:56 <andrewe> ski: please d
06:28:05 <andrewe> s/d/do
06:28:05 <endojelly> no wait
06:28:13 <ski> andrewe : sorry ?
06:28:14 <ManateeLazyCat> quicksilver: Where tick for hackagebot? I think hackagebot should improve with your idea, print so much message at #haskell.
06:28:27 <ManateeLazyCat> s/tick/ticket
06:28:49 <ski> Jafet : yeah, the types
06:28:59 <quicksilver> ManateeLazyCat: no idea.
06:29:07 <Jafet> ski: have you seen the one involving lazy ST?
06:29:08 <quicksilver> anybody know who maintains hackagebot?
06:29:10 <quicksilver> hackagebot: who are you?
06:29:18 <ski> Jafet : i don't think so
06:29:36 <ManateeLazyCat> I want upload new version, but worry hackagebot.
06:29:39 <ski> (but now that you mention it, i can imagine how that would work)
06:29:42 <endojelly> ski, I assume it's something a la let f = ... in f f?
06:29:44 <zygoloid> whois on hackagebot says: owner: sm
06:30:13 <ski> endojelly : yeah, but you need a recursive type for that to type-check
06:30:30 <zygoloid> preflex: seen sm
06:30:30 <preflex>  sm was last seen on #darcs 13 hours, 4 minutes and 53 seconds ago, saying: got to catch the bus, night all
06:30:43 <ski> (endojelly : in OCaml, you can do it with a cyclic type, if you enable `-rectypes')
06:30:43 <andrewe> ski: sorry, I didn't want to spoil your quiz
06:30:46 <endojelly> ski, yeah, that's what I'm wondering about. I know about the Y combinator, but its type would be infinite, no?
06:31:00 <Jafet> ski, endojelly: http://okmij.org/ftp/Haskell/Fix.hs
06:31:17 <ski> endojelly : some subexpression(s ?) would have cyclic/infinite type, yes
06:31:28 * hackagebot uu-parsinglib 2.5.5.2 - Online, error-correcting parser combinators; monadic and applicative interfaces  http://hackage.haskell.org/package/uu-parsinglib-2.5.5.2 (DoaitseSwierstra)
06:31:41 <ski> endojelly : but using a recursive `newtype' (or 'data', if you must) can roll this up
06:31:53 <Jafet> :t Mu
06:31:54 <lambdabot> Not in scope: data constructor `Mu'
06:31:59 <Jafet> @src Mu
06:31:59 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
06:32:04 <endojelly> ah, nice
06:32:41 <ptr_> :r
06:32:48 <ptr_> oups, wrong window, sorry
06:32:49 <endojelly> -- The fourth approach: using references and laziness
06:32:52 <endojelly> I feel dirty
06:33:32 <eagle-runner> Cale: hi cale, is fix used somewhere?
06:33:56 <ski> Jafet : ok, hadn't seen the 2nd or 3rd approach, there
06:37:25 <ski> Jafet : did you try writing a raw string to pass to `read', instead of going through `preprocess' ?
06:37:51 <Jafet> ski: hrm, what good would that do?
06:37:51 <Cale> eagle-runner: Well, it's mostly theoretically important, but some people use it when they want to write a recursive function which they don't consider to be worth naming.
06:38:07 <ski> (or are you fairly sure `preprocess' is correct ? .. i can't immediately say that it is)
06:38:08 <Cale> eagle-runner: For example, some people use it inside do-blocks to construct loops.
06:38:33 <Cale> fix $ \loop -> do <loop body>; loop
06:38:35 <Jafet> The preprocess result is valid as haskell code, but I'm reading the report now and it seems that extra parentheses and liberal uses of associativity may not be accepted by a derived Read
06:39:08 <ski> > read "(False)" :: Bool
06:39:09 <lambdabot>   False
06:40:29 <Jafet> ...but ghc's sometimes accepts extra parentheses, probably because it uses recursive descent
06:40:35 <Cale> eagle-runner: (that specific case would be better served by 'forever', but there are more complicated types of loops which one could write like that)
06:40:55 <eagle-runner> Cale: i see, what's the theorectical importance?
06:41:20 <Cale> eagle-runner: That all recursion can be expressed as finding least fixed points.
06:41:39 <Jafet> Oh, I misread. Extra parentheses should be allowed (so it seems like there's a bug with ghc)
06:41:50 <eagle-runner> Cale: oh, yeah
06:43:06 <Cale> eagle-runner: Some compilers for functional languages even compile recursive definitions into applications of fix (and treat fix specially as primitive)
06:43:19 <ManateeLazyCat> Sorry guys, i really don't want do this, but i need update mailing-list docs. Forgive me... :(
06:43:29 <Cale> (Maybe even some Haskell compilers, though I'm not sure about that)
06:43:43 <Cale> I can mute that bot
06:43:55 --- mode: ChanServ set +o Cale
06:44:10 <hpc> it's just a few lines...
06:44:19 <hpc> unless you are updating like, 20 packages
06:44:33 * hackagebot manatee-core 0.0.5 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.5 (AndyStewart)
06:44:35 * hackagebot manatee-anything 0.0.5 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.5 (AndyStewart)
06:44:37 * hackagebot manatee-browser 0.0.5 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.5 (AndyStewart)
06:44:53 --- mode: Cale set -o Cale
06:44:59 <Cale> I'll just let it go :)
06:45:05 <ManateeLazyCat> Mailing-list docs correct now. :)
06:45:12 <eagle-runner> Cale: i see, thanks
06:45:34 <sipa> not that there were many high-level discussions going here that were interrupted by hackagebot
06:45:39 * hackagebot manatee-editor 0.0.5 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.5 (AndyStewart)
06:45:41 * hackagebot manatee-filemanager 0.0.5 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.5 (AndyStewart)
06:45:43 * hackagebot manatee-pdfviewer 0.0.5 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.5 (AndyStewart)
06:45:45 * hackagebot manatee-mplayer 0.0.5 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.5 (AndyStewart)
06:45:47 * hackagebot manatee-ircclient 0.0.5 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.5 (AndyStewart)
06:46:49 * hackagebot manatee-processmanager 0.0.5 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.5 (AndyStewart)
06:46:51 <Jafet> Ah, I found out what's going on. The thing is that ghc's derived read is somehow astonishingly inefficient at parsing out parentheses
06:46:51 * hackagebot manatee-imageviewer 0.0.5 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.5 (AndyStewart)
06:46:53 * hackagebot manatee-reader 0.0.5 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.5 (AndyStewart)
06:46:55 * hackagebot manatee-curl 0.0.5 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.0.5 (AndyStewart)
06:46:57 * hackagebot manatee 0.1.1 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.1.1 (AndyStewart)
06:47:29 <ManateeLazyCat> BTW, look package dist-upload
06:47:34 <eagle-runner> Cale: just found finding fixed point is the job of Y calculus
06:47:43 <ManateeLazyCat> dist-upload upload your packages batch. :)
06:47:48 <ManateeLazyCat> @package dist-upload
06:47:49 <lambdabot> http://hackage.haskell.org/package/dist-upload
06:47:49 <eagle-runner> * Y combinator
06:49:28 <Jafet> ski, and anyone else who cares: http://hpaste.org/paste/41800/the_real_parse_blues#p41801
06:50:28 * eagle-runner feels more and more connected with those previously ignored terms
06:50:31 <hpc> eugh, that's a horridly long time
06:50:50 <hpc> wtf is the asymptotic complexity of that algorithm?
06:51:12 <Jafet> Yeah, it looks more like a recursive ascent parser from here
06:52:10 <quicksilver> exponential in the number of ()
06:52:14 <medfly> ManateeLazyCat, way to get attention
06:52:26 <quicksilver> approximately K * 10^n, from those three points.
06:52:30 <ManateeLazyCat> medfly: I don't want do that.
06:52:47 <ManateeLazyCat> medfly: Haddock markup confuse me.
06:53:07 <Cale> eagle-runner: Yeah, the Y combinator is a specific implementation of a fixed point operator in the untyped lambda calculus.
06:55:14 <eagle-runner> is it a more powerful way to define recursion? isn't function call enough?
06:56:01 <Nibble> eagle-runner: here is a definition of recursion
06:56:08 <Nibble> recursion: see recursion
06:56:42 <quicksilver> eagle-runner: they are the same.
06:57:04 <quicksilver> you can make recursion a primitive, or fix a primitive, or recursive data types a primitive.
06:57:13 <quicksilver> any of the three lets you recover the others.
06:57:23 <eagle-runner> quicksilver: i see, amazing.
06:57:53 <quicksilver> althouhg if you "recover" recursive data types from recursive functions you get something rather inconvenient to use as a data type. 
07:02:53 <endojelly> quicksilver, what do you get? something like Recursive (a -> a)?
07:04:09 <quicksilver> endojelly: I don't recall. Something like \a -> NotReallyRecursive a
07:04:48 <endojelly> ah
07:05:50 <Jafet> There are no bugs on the trac. I wonder how many people have tried to use derived Read on redundantly parenthesized infix-constructed sum types with differing constructor precedence.
07:06:02 <quicksilver> Jafet: my guess? 1
07:06:07 <Jafet> Yay
07:06:20 <eagle-runner> does haskell do tail recursion optimization?
07:06:29 <Nibble> eagle-runner: ghc does
07:06:45 <quicksilver> it's not really an optimisation, in the STG-machine
07:06:54 <quicksilver> it's just a consequence of how it runs
07:07:02 <quicksilver> it doesn't consume stack frames for function calls
07:08:12 <eagle-runner> @google stg machine
07:08:12 <lambdabot> No Result Found.
07:08:22 <jmcarthur> ski: yeah i've been meaning to look into lambdaprolog more deeply
07:08:37 <Raca> @google stg machine
07:08:37 <lambdabot> No Result Found.
07:09:13 <Raca> @google lambdaprolog
07:09:15 <lambdabot> http://www.lix.polytechnique.fr/~dale/lProlog/
07:09:15 <lambdabot> Title: λProlog Home Page
07:12:44 <eagle-runner> stg = spineless tagless g-machine, totally out of my knowledge base
07:15:20 <ski> @where+ lambdaProlog <http://www.lix.polytechnique.fr/~dale/lProlog/>
07:15:21 <lambdabot> Good to know.
07:19:32 <ddarius> lambdaProlog is pretty
07:22:15 <ManateeLazyCat> Crazy : GTK3 on H
07:22:20 <ManateeLazyCat> HTML5
07:22:27 <ManateeLazyCat> http://blogs.gnome.org/alexl/2010/11/23/gtk3-vs-html5/
07:23:17 <Cale> ManateeLazyCat: Yeah, I saw that :)
07:23:23 <Cale> ManateeLazyCat: It's insane :)
07:23:35 <ManateeLazyCat> Cale: What's HTML5 can't do?
07:24:08 <quicksilver> well, they're not doing anything interesting with HTML5.
07:24:13 <quicksilver> all it's doing is showing pixels.
07:24:20 <quicksilver> you can show pixels with HTML4, too.
07:24:23 <Cale> ManateeLazyCat: Apparently very little. The browsers are starting to execute javascript fast enough to do fast fourier transforms for audio processing in realtime, and WebGL makes 3D possible.
07:24:41 <quicksilver> the clever bit is javascript+websockets
07:24:59 <ManateeLazyCat> Cale: Browser is nothing once network disconnect.
07:25:06 <ManateeLazyCat> Cale: Poor offline features.
07:25:11 <Raca> its sad
07:25:38 <eagle-runner> quicksilver: after learning haskell, now i feel c is just an alias of machine instructions with some syntax sugar.
07:26:44 <eagle-runner> i tested some html5 demos, as cpu-consuming as flash...
07:26:47 <byorgey> eagle-runner: that's pretty much what it is. ;)
07:27:56 <eagle-runner> so i dont think html5 can replace gtk, unless there is a huge boost of performance.
07:28:33 <ManateeLazyCat> Cale: Some friends ask me why not use Javescript write Manatee, i said, i don't want my box become scrap when network is down.
07:29:02 <quicksilver> well there's no reason for html5/gtk to be slower than the various webVNC and webRemoteDesktop things
07:29:07 <quicksilver> and those work well enough for their purposes.
07:29:15 <quicksilver> ManateeLazyCat: wrong reason.
07:29:15 <ManateeLazyCat> Cale: I like ChromeOS's idea, but i don't think now is right time for ChromeOS
07:29:36 <quicksilver> ManateeLazyCat: the right reason is because haskell is more effective/fun programming language than javascript.
07:29:58 <quicksilver> actually there are plenty of offline javascript features in cutting-edge browsers
07:29:58 <ManateeLazyCat> quicksilver: Yes! you win! :)
07:30:01 <Cale> http://www.youtube.com/watch?v=oJ1UsLoPX3E
07:30:04 <quicksilver> and that trend will continue
07:30:13 <quicksilver> so offline browser apps will become more common
07:30:20 <Cale> There was a nice talk to go along with that and explain the slides, but I can't find the video of it now.
07:30:34 <ManateeLazyCat> quicksilver: What's the different between offline javascript and haskell-vm? 
07:30:59 <Cale> http://www.youtube.com/watch?v=1Uw0CrQdYYg&feature=player_embedded -- ah, here it is
07:31:03 <ManateeLazyCat> quicksilver: I think Haskell faster than javascript if compare offline feature.
07:31:20 <eagle-runner> quicksilver: in this years' osdi, there is a browse-os, it's a webkit built atop L4 microkernel, for efficiency & security.
07:31:55 <ski> ManateeLazyCat : GTK in ncurses : <http://zemljanka.sourceforge.net/cursed/>,<http://web.archive.org/web/20070721230516/zemljanka.sourceforge.net/cursed/screenshots/xchat-1.png>,<http://web.archive.org/web/20070721230516/zemljanka.sourceforge.net/cursed/screenshots/xchat-1.png>
07:32:12 <ski> (er, s/-1/-2/ at the last occurance)
07:32:35 <quicksilver> ManateeLazyCat: yes, I expect it is.
07:32:47 <quicksilver> ManateeLazyCat: but speed is not always the most important thing
07:33:00 <quicksilver> ManateeLazyCat: and there is a huge amount of resource going towards making javascript faster and faster
07:33:00 <Raca> the most important thing is..
07:33:02 <Jafet> quicksilver: make that 2 http://hackage.haskell.org/trac/ghc/ticket/1544
07:33:06 <Cale> The real question is whether we'll be able to compile Haskell to Javascript without losing too much performance ;)
07:33:08 <quicksilver> Jafet: \o/
07:33:18 <quicksilver> Cale: yes, that becomes more and more interesting.
07:33:45 <ManateeLazyCat> quicksilver: If Google can make javascript become faster, why not make Haskell faster ? Why not build Haskell-VM ?
07:33:57 <quicksilver> ManateeLazyCat: because they don't want to.
07:33:59 <quicksilver> that's all.
07:34:08 <quicksilver> they want to make existing javascript applications run faster on new devices
07:34:09 <Cale> ManateeLazyCat: GHC compiled code is getting faster...
07:34:16 <quicksilver> and then people write more ambitious web apps
07:34:23 <sipa> the web has chosen javascript as standard scripting language
07:34:26 <ManateeLazyCat> Most people want use JavaScript write OS, why we can't write Haskell OS?
07:34:27 <sipa> that may change over time
07:34:37 <sipa> but i doubt the "next" choice will be haskell
07:34:38 <quicksilver> and then the browser authors (actually, javascript VM authors) try again to make it faster
07:34:45 <Cale> If we wanted to put a Haskell implementation in everyone's browser, that's a big uphill battle
07:34:49 <eagle-runner> i dunno how much ppl/money google spends on testing of its javascript apps, but must be enormous
07:34:58 <quicksilver> compiling haskell to javascript is the right way.
07:35:03 <quicksilver> IMO.
07:35:06 <Jafet> Because nearly every PC has a slow implementation of javascript, and a small number of PCs have a fast implementation of Haskell
07:35:07 <Cale> Javascript is already there, and we just need a compiler :)
07:35:17 <quicksilver> you can get a pretty reasonable STG in javascript
07:35:27 <luite> quicksilver: unfortunately, many of those new devices are also pretty limited in terms of memory and cpu performance
07:35:29 <sipa> javascript supports first-class functions and closures... shouldn't be too hard :)
07:35:29 <eagle-runner> too error prone
07:35:32 <quicksilver> https://github.com/sviperll/ghcjs
07:35:35 <luite> although that's getting better too
07:35:39 <quicksilver> sipa: it's been done, at least twice.
07:35:43 <quicksilver> ^^ is the most recent.
07:36:04 <ManateeLazyCat> I like pure haskell more.
07:36:18 <arkonten> I'm trying to implement a BASIC interpreter in haskell. I have some problems with types when evaluating an expression mixed with floats and integers. Code snippet: http://hpaste.org/41802/basic_binop_evaluation?pid=41802&lang_41802=Haskell 
07:36:36 <arkonten> help would be greatly appreciated!
07:36:40 <ManateeLazyCat> The most power of JaveScript if it have *powerful* server in backend.
07:36:49 <Cale> arkonten: Lots of Basic interpreters lately! :)
07:36:51 <luite> I'd like to see a haskell compiler in javascript (but that should be easy once ghc can generate javascript code, just recompile itself :) )
07:37:13 <ManateeLazyCat> quicksilver:  I like Cloud idea, but i don't want put all my data on Cloud.
07:37:24 <quicksilver> ManateeLazyCat: definitely not.
07:37:46 <Jafet> luite: how long would it take to self-compile at -O2?
07:37:49 <quicksilver> ManateeLazyCat: but it's cool to be ab;e to compile haskell to a browser to make a demo or app available to lots of people easily.
07:38:12 <Cale> arkonten: That's not the type error that I'd expect to get from your code...
07:38:13 <quicksilver> ManateeLazyCat: and you can store data locally in recent browsers.
07:38:16 <luite> Jafet: I guess that's best left as an exercise to the reader ;p
07:38:23 <ManateeLazyCat> quicksilver: It's not safe.
07:38:32 <Cale> arkonten: I think the type you're intending for apply_binop isn't the one you've specified
07:38:32 <engla> luite, haskell compiler in js exists
07:38:36 <luite> with current javascript engines that is, once day, they might be fast enough
07:38:52 <ManateeLazyCat> quicksilver: When i first time seen ChromeOS, i think it's bad idea in China.
07:39:01 <ManateeLazyCat> quicksilver: All you data will filter by GFW.
07:39:01 <Nibble> ManateeLazyCat: is your OS up on hackage?
07:39:06 <Cale> arkonten: The type you've specified says that if a is any type at all in the Num class, you can pass a function (a -> a -> a) to apply_binop, along with two RVals and get an RVal
07:39:13 <ManateeLazyCat> Nibble: http://hackage.haskell.org/package/manatee
07:39:17 <quicksilver> ManateeLazyCat: you're missing the part about local data storage.
07:39:23 <Cale> arkonten: That is, I'd be allowed to simply pass in an Integer -> Integer -> Integer function
07:39:32 <quicksilver> ManateeLazyCat: locally stored data can be accessed by (modern) browsers, and this doesn't touch the network at all.
07:39:35 <luite> engla: hmm, I remember having seen something, but that was for a pretty limited subset. do you know a compiler for most of haskell 98 or 2010??
07:39:36 <roconnor> @go wiki waterfal
07:39:37 <lambdabot> Maybe you meant: google googleit do
07:39:45 <roconnor> @google wiki waterfall
07:39:46 <lambdabot> http://en.wikipedia.org/wiki/Waterfall_model
07:39:46 <lambdabot> Title: Waterfall model - Wikipedia, the free encyclopedia
07:39:49 <Cale> Or  Complex Double -> Complex Double -> Complex Double, and apply_binop would have to use that function.
07:39:52 <ManateeLazyCat> Nibble: Just Linux now, I will create VirtualBox image soon make Manatee can play in any platform
07:40:02 <arkonten> Cale: well, that's what I want, or an Float -> Float -> Float
07:40:03 <Cale> arkonten: Of course, that's not reasonable given the way that you're using the op
07:40:16 <arkonten> Cale: ok, so what's the problem?
07:40:20 <Cale> arkonten: Because in some cases, you're applying it to things which are definitely Integers
07:40:30 <ManateeLazyCat> quicksilver: Question is : When these technologies to mature?
07:40:31 <Cale> (and not just any numeric type)
07:40:51 <quicksilver> ManateeLazyCat: dunno.
07:40:54 <arkonten> Cale: aah.. so that's how the classes work
07:40:57 <quicksilver> ManateeLazyCat: I'm talking more about the future than now.
07:40:58 <ManateeLazyCat> quicksilver: That's the key
07:41:01 <quicksilver> ManateeLazyCat: probably a small number of years.
07:41:08 <quicksilver> agree.
07:41:13 <arkonten> Cale: but what's the right approach to handle this type of problem then?
07:41:15 <Cale> Consider   apply_binop (addFloats :: Float -> Float -> Float) (IVal 0) (IVal 1)
07:41:20 <ManateeLazyCat> quicksilver: If need we depend future, why not use Haskell implement those?
07:41:23 <Cale> (that should show what's wrong)
07:41:28 <ManateeLazyCat> quicksilver: Since haskell can do everything i want it do.
07:41:56 <Cale> arkonten: The type you want to write requires a language extension, and it's  apply_binop :: (forall a. Num a => a -> a -> a) -> RVal -> RVal -> RVal
07:42:03 <engla> luite, no of course, the thing I saw on github only implements a subset
07:42:35 <Cale> arkonten: Another option which doesn't require the extension is to take Integer -> Integer -> Integer and Float -> Float -> Float parameters separately
07:42:46 <ManateeLazyCat> quicksilver: IMO, even those newest browser technology not every browser support it.
07:43:43 <Nibble> ManateeLazyCat: That is why everyone should program in HTML 1.0
07:43:44 <arkonten> Cale: yes, but then every single binary operator I want to implement have to handle all cases of Integer vs. Float, right? that's what I wanted to avoid with apply_binop
07:44:07 <sipa> Nibble: i think some netscape-specific extensions like <marquee> should be permitted as well
07:44:07 <Cale> arkonten: Well, in the first case, the code you've written should work.
07:44:09 <arkonten> Cale: i.e. the same four cases which apply_binop handles
07:44:24 <quicksilver> ManateeLazyCat: yes, of course you are right.
07:44:27 <Cale> arkonten: In the second case, it'll still be useful, because you can do the appropriate fromInteger lifting.
07:44:29 <quicksilver> ManateeLazyCat: but it's still interesting stuff.
07:44:35 <Nibble> sipa: well, there are different ideas about how that would effect stuff
07:44:48 <Nibble> best not to touch em
07:45:08 <Cale> arkonten: So you could write  applyBinop (+) (+) v1 v2
07:45:13 <ManateeLazyCat> quicksilver: Those browser technology need depend on the browser's implementation.
07:45:15 <luite> I wonder if some haskell code could be executed faster in a javascript vm. it should be able to automatically specialize polymorphic code for example
07:45:23 <Cale> arkonten: Which would supply the two appropriately typed versions of (+)
07:45:48 <arkonten> Cale: aah..
07:45:58 <arkonten> Cale: I'll try that out, thanks alot!
07:46:01 <sipa> luite: but you don't want it to specialize all polymorphic code
07:46:45 <Cale> arkonten: The other option is just to add {-# LANGUAGE RankNTypes #-} to the top of your source file and then use the type I gave with the forall in it.
07:48:04 <luite> sipa: but the vm has runtime info about what code could be useful to specialize, where a traditional compiler doesn't
07:48:33 <sipa> true
07:49:16 <revenantphx> #haskell, is this a great deal, or best deal ever?
07:49:20 <arkonten> Cale: wow... that language extension actually worked.
07:49:45 <revenantphx> I bought my cousin 20$ of microsoft points... 
07:49:48 <sipa> luite: but i'm not sure how you'd generate javascript equivalents of polymorphic code (which will pass around dictionaries explicitly, i suppose) that permit the javascript VM to do specialization
07:50:03 <revenantphx> and in exchange he gave me the password to his family's netflix account, which I can freeload off of indefinitely.
07:50:29 <arkonten> Cale: amazing... thatnks alot! now I'll have to read up on the RankNTypes extension!
07:50:54 <luite> sipa: perhaps you could build the dictionary in the prototype of the objects you're working with
07:50:58 <ddarius> revenantphx: That's almost certainly a violation of his service contract.
07:51:09 <revenantphx> ddarius: Well yeah, but how would they be able to tell.
07:51:22 <revenantphx> His family already shares it between two households and one college dorm.
07:51:26 <sipa> arkonten: in short, it lets the called function decide which type a should be, instead of the caller
07:51:33 <revenantphx> (divorced, daughter is at college)
07:52:26 <ddarius> revenantphx: Since you aren't taking any of the risk in the situation, it certainly isn't a bad deal for you.
07:52:38 <arkonten> sipa: that makes sense. thanks!
07:52:47 <revenantphx> I think the risk is pretty much nonexistant.
07:52:50 <revenantphx> >_>
07:53:58 <sipa> arkonten: it's not very accurate, since types are decided through type inference, and not 'chosen' by a particular function
07:54:38 <quicksilver> ddarius: on the contrary, accessing a computer system without authorisation is a federal offence. In practice, I do not expect revenantphx would get prosecuted :)
07:55:04 <Raca> do they have internet in prison?
07:55:05 <arkonten> sipa: yeah, I'm reading about it on the haskellwiki. at least what you said gives some intuition of what it can be used for
07:55:17 <revenantphx> I know a lot of people who have shared netflix accounts... I don't see the issue tbh.
07:55:29 <quicksilver> sipa, arkonten: that intuition can be formalised, it lies at the heart of something called 'game theory semantics'
07:56:17 <quicksilver> with one kind of quantifier you choose the type, with the other kind "your opponent" chooses the type.
07:56:24 <revenantphx> Netflix even offers support for multiple profiles in one account to start with.
07:56:43 <sipa> quicksilver: interesting analogy
07:57:23 <ski> arkonten,Cale : or `Rank2Types'
07:57:35 <sipa> Rank2Types will suffice here, i think
07:57:36 <revenantphx> quicksilver: ddarius: A quick look through the TOS reveals.... nothing.
07:57:49 <revenantphx> Doesn't say anything anywhere about sharing accounts.
07:57:59 <revenantphx> except:
07:58:01 <revenantphx> "BY SHARING THE NETFLIX SERVICE PASSWORD, THE ACCOUNT OWNER AGREES TO BE RESPONSIBLE FOR ASSURING THAT HOUSEHOLD MEMBERS COMPLY WITH THE TERMS OF USE AND SUCH ACCOUNT OWNER SHALL BE RESPONSIBLE FOR THE ACTIONS OF THE HOUSEHOLD MEMBERS."
07:58:22 <zygoloid> what if i share it with someone outside of my household?
07:58:28 <endojelly> revenantphx, so if you share the accoung with non-household members...
07:58:30 <revenantphx> Doesn't say anything about that.
07:58:45 <leoncamel> Igloo: Are you working on cross-compiling ghc-7.0.1 for MacOSX now ?
07:58:46 <endojelly> yeah. it only says, when sharing in general, pay attention to your household members.
07:59:44 <revenantphx> In other words, the only thing it says about sharing is roughly "be careful"
07:59:57 <revenantphx> There's a 6 device limit anyhow, so I doubt they care too much.
08:00:23 <ddarius> The contract is presumably between Netflix and the "household" and "household" is almost certainly defined in the terms.
08:01:17 <endojelly> ddarius, does it reallt matter how household is defined, as along as the terms don't say that you may only share with those?
08:01:17 <revenantphx> ...nope.
08:01:25 <endojelly> doesn't
08:01:28 <revenantphx> endojelly: Doesn't say that either.
08:01:43 <quicksilver> I think you're right, revenantphx. It doesn't put any limitations on streaming from other houses / other people
08:01:51 <quicksilver> I'm surprised :)
08:01:58 <revenantphx> quicksilver: Well, there's a limit to how many devices can stream at once.
08:02:04 <revenantphx> And you can only have 6 registered devices.
08:02:05 <endojelly> well it's probably a mistake
08:02:11 <endojelly> the wording suggests that
08:02:19 <revenantphx> endojelly: It really doesnt.
08:02:23 <quicksilver> revenantphx: yes.
08:03:04 <endojelly> well then happy netflix account sharing?
08:03:41 <revenantphx> endojelly: yep, rewatching first season of the A-team, and last night I watched the 1966 Batman movie (Adam West)
08:03:47 <revenantphx> "Some days you just can't get rid of a bomb!"
08:03:52 <revenantphx> It's so camp and bad...
08:04:07 <endojelly> heh, I remember that scene
08:04:25 <endojelly> nowadays that would be purposefully trying to be bad, and trying a little too hard
08:04:36 <endojelly> but 1966 was far from that yet
08:11:54 <jmcarthur> i always thought the old batman tv show was supposed to be a little ridiculous
08:11:57 <ddarius> It's surprising how poor the support for exporting from Microsoft Sql Server to Microsoft Excel is.
08:12:14 <jmcarthur> or at least not too serious
08:13:05 <quicksilver> ddarius: I am not surprised :)
08:13:15 <quicksilver> ddarius: you may have more success via Access, I think.
08:13:39 <ddarius> quicksilver: You'd think, but that's not true hence me using Excel.
08:14:12 <quicksilver> ddarius: lucky you ;)
08:14:52 <Cale> http://www.youtube.com/watch?v=G4v1hAnfy1I
08:20:20 <ManateeLazyCat> G'night all. :)
08:29:33 <benmachine> http://new-www.haskell.org/haskellwiki/Special:Contributions/Ipyzykeho this guy needs an industrial-strength revert dropped on him
08:29:45 <benmachine> did we stop manually checking registrations?
08:30:08 <benmachine> I guess we did
08:30:40 <ddilinger> having trouble finding exact info on <|>, looking at the source it seems <|> on lists joins them together, on Maybe it results in the first non-Nothing, whats the more general term for what its doing?
08:31:12 <quicksilver> I don't think there is a general term
08:31:18 <quicksilver> it's a method of a class called 'Alternative'
08:31:32 <quicksilver> it's closely related to MonadPlus
08:31:40 <benmachine> I suppose he'll get walked over when the old wiki is merged, but if there's no spambot protection at all this will end badly
08:31:40 <ddilinger> hmm, ok
08:31:43 <quicksilver> the general sense of it is "consider both alternatives"
08:32:02 <quicksilver> but precisely what 'consider' means varies from instance to instance
08:32:17 <quicksilver> "consider" for Lists involves keeping them all, since lists model non-determinacy
08:32:29 <yaxu1> there seems to be a rather unfunny spoof dons on reddit
08:32:31 <ddilinger> ok, that makes sense
08:33:15 <byorgey> yaxu: indeed.
08:33:21 <quicksilver> ddilinger: for parsers it tends to mean "try to parse like this, and if that doesn't work out, try to parse like this"
08:33:28 <Philonous> Is there a variant of STMs "always" that will "retry" rather than throw an exception?
08:33:52 <JPablo> question...what is wrong with: Func :: (Integral a) => a -> [a] 
08:34:18 <benmachine> JPablo: function names start with lowercase letters
08:36:09 <JPablo> thanks
08:55:25 <Mitar> any suggestions: http://hpaste.org/41803/cannot_derive
08:56:05 <zygoloid> Mitar: hpaste the output of -ddump-deriv?
08:57:05 <Mitar> http://hpaste.org/paste/41803/ddumpderiv#p41804
08:57:16 <dankna> change it to
08:57:19 <dankna> data EqBox e
08:57:27 <ski> @type gunfold
08:57:29 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall b r. (Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Constr -> c a
08:57:29 <Nibble> why is it hpaste and not haste, haste sounds a lot cooler
08:58:07 <sipa> haste.org is not registered yet!
08:58:28 <Mitar> sipa: it is?
08:58:42 <Saizan> @google more speed less haste
08:58:43 <lambdabot> No Result Found.
08:58:44 <Mitar> dankna: what should i change?
08:59:07 <dankna> Mitar: it needs to take e as a parameter to the type
08:59:32 <dankna> Mitar: and also the context needs to be moved up there instead of in the specific instance thing
08:59:34 <ddilinger> :t (!)
08:59:35 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
08:59:39 <geheimdienst> more speed less hpaste?
09:00:28 <Mitar> dankna: but the idea is to have existential data type
09:00:28 <sipa> Mitar: actually it is registered :(
09:00:48 * ski tries to figure out what `gunfold' is doing ..
09:01:00 <Mitar> can you please annotate what you mean?
09:01:24 <ddilinger> What does it mean to have a ! in the following: data Foo = { fooName :: !ByteString }
09:01:33 <ski> .. oh
09:01:43 <dankna> Mitar: then you need the explicit forall
09:02:24 <Philonous> ddilinger, The bang makes it a strict data type, i.e. whenever you force the constructor the containing data will be forced aswell 
09:02:44 <Mitar> dankna: also when i write existential as GADTs?
09:02:50 <jmcarthur> omg http://www.reddit.com/user/Donald_Stewart
09:02:59 <ddilinger> Philonous: interesting, thanks
09:03:34 <dankna> Mitar: I believe so, though I haven't done this exact thing before.
09:04:33 <geheimdienst> dons says on reddit: "I once did a porn while I mixed the music for it in Haskell."
09:05:04 <Mitar> dankna: can you annotate and i will test it?
09:05:09 <dankna> sure
09:05:21 <yaxu> geheimdienst: sure that's him?
09:05:27 <Mitar> (myself believe that it is a bug in ghc)
09:05:43 <Mitar> at least better error message should be displayed
09:05:48 <dankna> http://hpaste.org/paste/41803/possibly_this#p41805
09:06:05 <dankna> well, it's a hard area, making meaningful error messages
09:07:05 <Mitar> sadly, doesn't work
09:07:15 <Mitar> first it complains about XRankNTypes, but then we are back
09:07:58 <dankna> oh
09:08:02 <dankna> hmm
09:08:06 <dankna> then I'm not sure what the problem is
09:08:22 <ski> Mitar : i'm not sure whether it makes sense to have a `Data' instance for an existential type ..
09:09:10 <ski> Mitar : after `RankNTypes' you're back where ?
09:09:23 <Mitar> Ambiguous type variable `e' in the constraints:
09:09:54 <jmcarthur> yaxu: it's definitely not him
09:10:02 <jmcarthur> it's just somebody trying to be funny
09:10:21 <Philonous> ddilinger, ("strict data type" may be an unfortunate choice of words as it is actually only the field that you added the bang to that becomes strict)
09:10:27 <geheimdienst> but wouldn't that mean that something is wrong on the internet?
09:13:08 <byorgey> augur: http://byorgey.wordpress.com/2010/11/24/species-subtraction-made-simple/
09:15:46 * ski . o O ( "Make Haste But Take Heed" )
09:16:21 <magicman> (T)Chans allow for many writers, but only one reader, yes? (unless dup(T)Chan)
09:16:26 <cole> head returns the first element of a list and tail returns everything but the first elements. If there a function for returning everything but the last element.
09:16:28 <cole> ?
09:16:35 <dankna> yes, there actually is and it's called init
09:16:42 <dankna> but remember that that copies the whole list
09:16:56 <geheimdienst> > init [1,2,3,4,5]
09:16:57 <lambdabot>   [1,2,3,4]
09:17:02 <geheimdienst> > last [1,2,3,4,5]
09:17:03 <lambdabot>   5
09:17:13 <magicman> > init [1..]
09:17:14 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
09:17:16 <magicman> Good.
09:17:29 <sipa> > last [1..]
09:17:33 <lambdabot>   mueval-core: Time limit exceeded
09:18:23 <ski> > (uncurry (++) . (last &&& ((:[]) . init))) "abcdefgh"
09:18:25 <lambdabot>   Occurs check: cannot construct the infinite type: a = [[a]]
09:18:53 <ski> > (uncurry (++) . (((:[]) . last)) &&& init) "abcdefgh"
09:18:55 <lambdabot>   Couldn't match expected type `(a, a)' against inferred type `[a1]'
09:19:01 <ski> hm .. why not just
09:19:17 <FauxFaux> Haha, I read that a s my irssi activity list.
09:19:24 <ski> > (uncurry (:) . (last &&& init)) "abcdefgh"
09:19:25 <lambdabot>   "habcdefg"
09:23:40 <Olathe> Is quot faster than div?
09:26:54 <yitz> > uncurry (:) . second reverse . splitAt 1 . reverse $ "abcdefgh"
09:26:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
09:27:03 <luite> byorgey: thanks for the blog post, I'd be interested to read about the molecular species decomposition and multiplicative inverses :)
09:27:23 <yitz> > uncurry (++) . second reverse . splitAt 1 . reverse $ "abcdefgh"
09:27:24 <lambdabot>   "habcdefg"
09:29:58 <paolino> > take 8 . tail . cycle $ "abcdefgh"
09:29:59 <lambdabot>   "bcdefgha"
09:30:24 <quicksilver> > take 8 . drop 7 . cycle $ "abcdefgh"
09:30:25 <lambdabot>   "habcdefg"
09:30:29 <ddarius> Olathe: Yes.
09:36:43 <Olathe> ddarius: Thanks :)
09:39:33 <ski> Mitar : looking at <http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Data.html>, i think `gunfold' doesn't know *which* type `e' (being in `Data' and `Eq') to use as an argument for the `EB' constructor, when unfolding out a value of type `EqBox'
09:41:19 <ski> Mitar : if you have `data Foo = F Bar' or `data Foo a = F (Bar a) a', then given that it knows to generate a `Foo' (alt. a `Foo a'), it can figure out that it will need to generate a `Bar' (alt. a `Bar a' and an `a') for the argument(s) for `F'
09:42:08 <ski> Mitar : but when you have `data EqBox = forall e. (Data e,Eq e) => EB e', it has no idea of knowing which `e' to choose, when generating a value of type `EqBox'
09:43:25 <dankna> yeah, that's basically what the error is saying
09:43:27 <dankna> or trying to say
09:43:58 <ski> .. this might be the same issue as trying to make an `Arbitrary' instance for an existential
09:55:11 * ski still wonders how `gunfold' is really supposed to be used
09:56:00 <ski> are you supposed to pass as first argument something that cases on which type is to be generated, and only handle a few cases, failing in all the rest ?
09:56:21 <Mitar> hmm
09:57:55 * yaxu baits the dons impersonator http://www.reddit.com/r/haskell/comments/ebob4/experimental_visual_environment_for_making_music/c16va74
10:02:15 <augur> byorgey!
10:02:17 <augur> :D
10:02:35 <augur> ill be reading it quite voraciously on my trip to florida today
10:02:36 <augur> <3
10:02:38 <tomh-> hey any uu alumni here atm?
10:02:45 <augur> byeee
10:03:59 <Mitar> another beauty: http://hpaste.org/41807/another
10:04:13 <Mitar> this deriving does not really work ;-)
10:06:38 <ski> byorgey : "Although `i2n' is partial, it is complete" <- is that as in "complete vs. sound" ?
10:07:06 <dankna> i2n?  what does that stand for?
10:07:15 <luite> integer to natural
10:11:44 <dankna> oh, that makes sense, haha
10:11:49 <dankna> I thought it was like i18n
10:18:35 <sipa> :t (undefined :: Ref Int)
10:18:36 <lambdabot> Not in scope: type constructor or class `Ref'
10:18:38 <Mathnerd314> can one do splices in quasiquotes?
10:18:58 <sipa> @hoogle Ref
10:18:58 <lambdabot> module Trace.Hpc.Reflect
10:18:58 <lambdabot> Data.IORef atomicModifyIORef :: IORef a -> (a -> (a, b)) -> IO b
10:18:58 <lambdabot> Foreign.StablePtr deRefStablePtr :: StablePtr a -> IO a
10:19:12 <sipa> does anyone know of a 'Ref a' type somewhere?
10:19:36 <dankna> what do you want it to do?
10:19:45 <cole> I'm using emacs on linux. How do I get syntax highlighting for haskell source?
10:20:12 <sipa> dankna: i read about it in a paper, but there is no reference or explanation
10:20:16 <sipa> :t deref
10:20:17 <lambdabot> Not in scope: `deref'
10:20:18 <dankna> sipa: oh, hm
10:20:24 <zakwilson> cole: haskell-mode
10:20:36 <cole> thx.
10:20:48 <ski> byorgey : btw, would the adjunction `forall m n o. m - n =< o <=> m =< o + n' for (e.g.) natural numbers (characterizing combinatorial subtraction / monus) be relevant, there ?
10:20:53 <sipa> @hoogle deref
10:20:53 <lambdabot> Foreign.StablePtr deRefStablePtr :: StablePtr a -> IO a
10:20:54 <lambdabot> System.Mem.Weak deRefWeak :: Weak v -> IO (Maybe v)
10:21:21 <kurganme> Hi. Someone can help me? Can I use ffi in order to interact with a runtime selected library? Seems that the library name must be choose at compile time. But I need to give the name during the sw runs. 
10:22:14 <cdsmithus> kurganme: I believe you'll need to write a C wrapper than handles the dlopen calls, and use FFI to bind to that
10:22:14 <lambdabot> cdsmithus: You have 1 new message. '/msg lambdabot @messages' to read it.
10:22:58 <ToRA> System.Posix.DynamicLinker will do dlopen 
10:23:42 <cdsmithus> Oh, I retract my answer then
10:25:21 <kurganme> Argh... Is possible to use ffi on dlopen and dlsym and work with pointers returned from dlsym?
10:26:18 <cdsmithus> Once you have a FunPtr, there's example code for doing the FFI bit at http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Foreign-Ptr.html#t:FunPtr
10:26:48 <cdsmithus> (The last code sample there)
10:30:49 <kurganme> thanks cdsmithus and ToRA 
10:40:25 <MasseR> If I have functions of type, a -> a -> f a, f a and f a. Can I take the two 'f a' and combine them with the first function (notice that it takes two pure values and returns f a). (The functions are from Network.URI package, parsing uris and relativeTo)
10:41:13 <sinelaw> f a isn't a function
10:41:17 <sipa> it can be
10:41:27 <sinelaw> how
10:41:45 <dankna> @pl do { a <- parse ; b <- relativeTo ; retrieve a b }
10:41:45 <lambdabot> (line 1, column 4):
10:41:45 <lambdabot> unexpected "{"
10:41:45 <lambdabot> expecting variable, "(", operator or end of input
10:41:52 <dankna> apparently pl can't handle that
10:41:58 <dankna> so I dunno
10:42:27 <dschoepe> @pl parse >>= \a -> relativeTo >>= \b -> retrieve a b
10:42:28 <lambdabot> (relativeTo >>=) . retrieve =<< parse
10:42:36 <dankna> ah
10:42:42 <dankna> fascinating
10:43:02 <ToRA> that's liftA2 retrive parse relativeTo  (or liftM2 depending on applicative / monad)
10:44:14 <ToRA> hmm, retrieve `liftM2` parse relativeTo probably looks neater, which I didn't realise before
10:45:41 <cole> I wrote a program which takes about 60 seconds to find all the primes from 1 to 10,000. (on a 2.4 ghz modern processor) Does that seem slow? 
10:45:46 <ski> @. pl undo do { a <- parse ; b <- relativeTo ; retrieve a b }
10:45:47 <lambdabot> (relativeTo >>=) . retrieve =<< parse
10:46:37 <ski> ToRA : that'd have to be  (retrieve `liftM2` parse) relativeTo  then ..
10:46:45 <kadoban> cole: doesn't seem very fast
10:46:50 <sipa> cole: how do you test for primality?
10:47:09 <ToRA> cole: google "The Genuine Sieve of Eratosthenes" if you're interested in prime generation (it's a fun paper imho)
10:47:42 <ToRA> ski: oh, yeah. :(
10:49:13 <cole> I simply take all the numbers from 1 .. p where and test if p mod n. I wouldn't expect it to be fast. How could I parallelize it?
10:49:43 <sipa> you could start by only using the odd numbers between 3 and sqrt(p)
10:50:10 <sipa> (and 2)
10:50:24 <ddilinger> cole: instead of testing all numbers, just test if its divisible by primes you already know about
10:50:38 <ddilinger> cole: one idea at least
10:50:42 <kadoban> cole: that's trial division, one of the slowest ways possible.  if you really want to make it fast, look at that paper that ToRA suggested, it's pretty interesting
10:51:05 <cole> thanks.
10:51:45 * hackagebot TypeClass 0.1 - Typing speed game  http://hackage.haskell.org/package/TypeClass-0.1 (JeanPhilippeMoresmau)
10:51:47 * hackagebot tagging 0.1 - Library for tagging data  http://hackage.haskell.org/package/tagging-0.1 (JosephRe)
10:52:00 <ToRA> i was just going to say it's a shame that the implementation of the paper isn't on hackage
10:52:03 <ToRA> but turns out it is
10:52:07 <ToRA> http://hackage.haskell.org/packages/archive/NumberSieves/0.1.1/doc/html/Math-Sieve-ONeill.html
10:52:17 <sipa> TypeClass is a confusing name ...
10:53:53 <cdsmithus> sipa: Yeah, looks like an intentional pun, but too bad it's now the unique package by that name
10:54:29 <monochrom> haha
11:02:00 <engla> ToRA: it's impressive, I like it
11:09:01 <Mitar> how can i make a list of Chans of different element types?
11:09:43 <ski> existentials ?
11:10:09 <monochrom> not sure if you must keep them in one single list
11:10:32 <monochrom> I really think you should re-design.
11:10:48 <roconnor> a list of Eithers?
11:12:16 <endojelly> GADTs and type classes?
11:12:25 <endojelly> (I agree, you should probably redesign)
11:13:44 <Mitar> yes, but how i do that with existensials so that i can recover original Chan back?
11:14:03 <monochrom> add Typeable
11:14:03 <Mitar> because Chan by itself is a data type and not a type class
11:14:10 <Mitar> i should cast?
11:14:13 <Mitar> this is ugly ;-)
11:14:23 <Mitar> this is the same as using dynamic
11:14:38 <monochrom> yes, I mean add Dynamic actually
11:15:02 <monochrom> I am sorry if haskell is not dependently typed.
11:20:17 <cole> I have: "run c (c:x) = . . ." and I'm getting the error "Conflicting definitions for 'c'. 
11:20:49 <zygoloid> cole: you have conflicting definitions for 'c'. :)
11:20:58 <cole> How do I express that I want the first argument and the first element of the list of the second argument ot be the sname?
11:21:06 <sinelaw> jmcarthur, seems like what i'm working on is slowly converging into AwesomePrelude
11:21:12 <mauke> depends on your definition of "same"
11:21:13 <sinelaw> so I might as well figure out how to use THAT instead
11:21:13 <zygoloid> cole: you have to explicitly compare them. you can't use pattern-matching for that.
11:21:30 <zygoloid> cole: using a guard might be appropriate here:
11:21:37 <cole> Oh.
11:21:39 <zygoloid> run c (d:x) | c == d = ...
11:22:50 <zygoloid> > let run c (((==c) -> True):xs) = xs; run _ xs = xs in run 'x' "xyzzy"
11:22:51 <lambdabot>   "yzzy"
11:25:15 <monochrom> eh, lambdabot has view pattern
11:33:43 <solrize> zomg thats sick
11:33:59 <zomg> Yes!
11:34:18 <zomg> (I have no idea what you're talking about in case it was really something sick)
11:35:04 <solrize>  let run c (((==c) -> True):xs) ...
11:36:17 <solrize> thats in ghc now?
11:37:00 <solrize> so you can run arbitrary code in a pattern match
11:38:12 <cole> How do you say "cons nothing to the front of the list"?
11:38:33 <ski> > let f (fmap ($ fa) -> fa) = fa in f [sum . tail,product . drop 2,(!! 4),2,sum . sequence (map (flip (!!)) [3,5]),4]
11:38:35 <lambdabot>   Not in scope: `fa'
11:38:39 <mauke> cole: there is no nothing
11:38:48 <ski> > let f (fmap ($ fa') -> fa) = fa where fa' = fa in f [sum . tail,product . drop 2,(!! 4),2,sum . sequence (map (flip (!!)) [3,5]),4]
11:38:50 <lambdabot>   Not in scope: `fa''
11:38:51 <ski> :(
11:39:00 <ski> (how to make the recursion work ?)
11:39:11 <cole> mauke: So, there's no way of saying that?
11:39:37 <mauke> cole: why are you trying to do that?
11:39:48 <solrize> > Nothing:[Nothing,Just 5,Nothing]
11:39:49 <lambdabot>   [Nothing,Nothing,Just 5,Nothing]
11:40:21 <solrize> : is the cons operator
11:40:38 <luite> > let consNothingToTheList = id in consNothingToTheList [1,2,3]
11:40:39 <lambdabot>   [1,2,3]
11:40:41 <cole> I'm creating a "skip" function and I'm saying "if n > 0 then ignore this element, i.e., cons nothing to the front of the list"
11:40:43 <paolino> > [] ++ [1,2,3]
11:40:44 <lambdabot>   [1,2,3]
11:41:07 <engla> @src filter
11:41:08 <lambdabot> filter _ []     = []
11:41:08 <lambdabot> filter p (x:xs)
11:41:08 <lambdabot>     | p x       = x : filter p xs
11:41:08 <lambdabot>     | otherwise = filter p xs
11:41:35 <solrize> oh, you mean "don't cons anything" not "cons Nothing"
11:41:54 <mauke> cole: why does doing nothing involve cons?
11:43:59 * hackagebot lbfgs 0.0.3 - L-BFGS optimization  http://hackage.haskell.org/package/lbfgs-0.0.3 (DanielDeKok)
11:44:03 <engla> cole: you can use the filter implementation above
11:44:48 <ion> If i run ‘let inf = 1 + inf in inf’ in ghci, it (of course) never returns, but it’s not using CPU at all. I naively expected it to run at 100 % CPU utilization forever. What kind of an optimization is that? For what kind of real use cases is it useful?
11:45:04 <Zao> ion: Yay for blackholes.
11:45:30 <Zao> ion: If you manage to wedge some piece of code with that, wouldn't you rather that it didn't do pointless work ruining the rest of the system?
11:45:45 <Zao> ion: ghc should <loop> and abort, I believe.
11:47:03 <ion> If the compiler’s intelligent enough to decude the computation has no side effects and it’ll never return, how about raising an exception instead of blocking forever?
11:47:16 <ion> or something equivalent
11:47:23 <Zao> ion: That sounds like a horrible idea.
11:47:48 <mauke> uh, that's exactly what ghc does
11:48:12 <solrize> > let j=1+j in j
11:48:16 <lambdabot>   mueval-core: Time limit exceeded
11:48:17 <erg0t> there isn't flymake-haskell for emacs23?
11:48:17 <lambdabot> erg0t: You have 1 new message. '/msg lambdabot @messages' to read it.
11:48:38 <flux> > let j x = j x
11:48:40 <lambdabot>   not an expression: `let j x = j x'
11:49:10 <flux> > let j x = j x in j 42
11:49:15 <lambdabot>   mueval-core: Time limit exceeded
11:49:40 <flux> hmph, under which circumtances does ghci give that <<loop>>?
11:50:14 <monochrom> compile "main = print (let i = 1 + i in i)" and run it to see <<loop>>
11:51:26 <kmc> flux, i think ghci never gives it
11:51:32 <kmc> ghc-compiled code will
11:51:40 <ion> alright
11:52:02 <zonehack> whats the meaning of '@' in haskell?
11:52:10 <kmc> when evaluation of some thunk t requires evaluation of the same thunk t
11:52:15 <mauke> zonehack: alias
11:52:28 <kmc> zonehack, the pattern x@p matches anything matched by the pattern p, binding the same variables, and also binds x to the whole thing matched
11:52:53 <zonehack> ohh.. thank you
12:01:15 <mm_freak> when are two MVars Eq-equal?
12:03:05 * hackagebot gnuplot 0.4.0.2 - 2D and 3D plots using gnuplot  http://hackage.haskell.org/package/gnuplot-0.4.0.2 (HenningThielemann)
12:03:20 <monochrom> "(MVar mvar1#) == (MVar mvar2#) = sameMVar# mvar1# mvar2#"
12:03:29 <esdee> is there a one module per file rule?
12:03:34 <mauke> yes
12:03:53 <monochrom> ghc and hugs can do one module per file only
12:04:05 <Martty> hugs can do wonderful things
12:04:23 <esdee> someone should tell this page that: http://www.haskell.org/tutorial/modules.html
12:05:06 <mornfall> monochrom: Actually, it's required by the spec. (Although maybe inadvertantly.)
12:05:20 <monochrom> where in the spec is it required?
12:05:37 <mornfall> The grammar says EOF after the module definition.
12:05:42 <mornfall> IIRC
12:06:42 <monochrom> "module → module modid [exports] where body | body"
12:08:03 <mornfall> monochrom: Layout rule or something.
12:08:35 <monochrom> overruled if you use {}
12:09:05 <monochrom> "body → { impdecls ; topdecls } | { impdecls } | { topdecls }
12:10:37 <mornfall> I can't find the problem anymore.
12:10:45 <shapr> preflex: seen yaxu
12:10:45 <preflex>  yaxu was last seen on #haskell 2 hours, 12 minutes and 49 seconds ago, saying: * yaxu baits the dons impersonator http://www.reddit.com/r/haskell/comments/ebob4/experimental_visual_environment_for_making_music/c16va74
12:10:59 <shapr> bah humbug, I missed him :-(
12:11:01 <shapr> yaxu
12:11:04 <shapr> where ar ya?
12:11:15 <monochrom> moreover I can't find the substring "eof" on http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17800010.3
12:14:26 <mornfall> *shrug* me neither...
12:14:32 <mornfall> I might be misremembering.
12:17:21 <monochrom> The "L" function considers the empty input stream of tokens [] as EOF. However, its significant is only in adding "}", and it is not the only way to add "}"
12:17:53 <monochrom> module X where
12:17:56 <monochrom>     x=True
12:18:00 <monochrom> module Y where
12:18:02 <monochrom>    y=()
12:18:10 <evident> hi everybody! Can anybody tell me if its possible to search the pastes on hpaste.org for some pastes I made (about 2-4 weeks ago)?
12:18:43 <monochrom> The L function would give you module X where { x=True } module Y where {y=()}  just as well without the help of EOF
12:19:37 <mornfall> monochrom: Oh, I think the argument was that module is the start symbol, and if you have EOF in your lexer, then it doesn't make much sense to consider "source" != "source file".
12:21:41 <mornfall> I am not sure what the CFG exactly describes, though. :) It's not entirely clear from the spec.
12:21:57 <mornfall> But if it is a valid source file, then it can only have one module in it.
12:22:20 <mornfall> If it has no relation to files, then eof is a mystery.
12:22:29 <radioactive_man> is there a fold function on Arrays, similiar to mapArray ?
12:23:03 <monochrom> I accept "source" != "source file". It still does not imply (between the first occurrence of 'module' and EOF there can't be another 'module')
12:23:32 <mornfall> monochrom: Well, if you accept that source is not a source file, then you are OK.
12:23:51 <mornfall> monochrom: But if source *is* a source file, then you are not (since the start symbol expands to at most one module).
12:23:55 <monochrom> I accept "source" == "source file" too and it still does not imply (between the first occurrence of 'module' and EOF there can't be another 'module')
12:24:41 <monochrom> give me a formal proof using only logic and the haskell report (either version)
12:25:06 <mornfall> :) The report is not expressible in any logic I know of.
12:25:47 <mornfall> Whatever the CFG from the report describes can only contain one module.
12:25:58 <mreh> man monad transformers are good
12:25:58 <byorgey> @tell ski re: complete, yes, in the sense that it 'proves all true things': there aren't any natural numbers for which i2n yields Nothing.  re: the adjunction, probably!
12:25:59 <lambdabot> Consider it noted.
12:26:47 <ManateeLazyCat> Hmm, looks GFW upgrade......
12:26:50 <mreh> they are actually monads in disguise
12:26:53 <monochrom> Do not restrict yourself to the CFG. There is also the sentence "A Haskell program is a collection of modules"
12:26:59 <ManateeLazyCat> YouTube.com can't see video.
12:27:12 <monochrom> There is then also "For example, here is a three-module program:" example.
12:27:15 <ManateeLazyCat> Glad i know how to around it.
12:27:28 <mornfall> monochrom: True, but it does not relate haskell program to files in any way.
12:27:39 <ManateeLazyCat> GFW allow you access YouTube.com but fliter site ytimg.com
12:28:03 <monochrom> This is why there is implementational freedom in distributing modules to files or files to modules.
12:28:43 <ManateeLazyCat> Some YouTube.com's CSS file store at ytimg.com, then YouTube.com can't show video if ytimg.com is filter. How smart GFW guys, damn you....
12:28:50 <mornfall> monochrom: In that case, I don't think the lexer should refer to end of file at all. It is at best confusing, since there may be multiple or no eofs.
12:29:04 <stroan> the haskell syntax spec is not very pretty
12:29:06 <mornfall> monochrom: If you distribute a module into multiple files, it'll lead to silly side effects.
12:29:38 <mornfall> But, whatever. It's like totally moot point. :))
12:29:48 <monochrom> I can't see end-of-file in Chapter 2.
12:29:50 <mornfall> And my testsuite finished.
12:29:57 <stroan> so much work to resolve fixities
12:30:03 <mornfall> monochrom: It's in chapter 9.
12:31:19 <monochrom> Chapter 9 just needs it for converting layout to {}, and it only says "if there is no more token, add }", as I said, and end-of-file is not the only way to add }
12:32:46 <monochrom> Chapter 9 still does not say it expects no more than one occurrence of the start symbol in the stream.
12:33:06 <mornfall> monochrom: That is the usual interpretation of a CFG.
12:33:10 <monochrom> At best it only says what to do if you hit EOF
12:33:25 <mornfall> You can't add random * to the grammar, usually.
12:34:03 <monochrom> Right, but "A Haskell program is a collection of modules" grants the exception.
12:34:20 <mornfall> How so? :)
12:36:42 <monochrom> Well, together with silence on how that collection is distributed
12:37:56 <monochrom> The report does not forbid putting the whole collection into one stream. If an implementation makes use of that, the stream contains several expansions of the start symbol.
12:39:34 <mornfall> monochrom: All implementations I know of treat multiple modules in a single stream as a syntax error, interpreting the grammar the usual way. I don't think a vaguely related statement about collection of modules overrides the interpretation of the grammar.
12:40:43 <mornfall> (But it's of course a matter of interpretation.)
12:41:58 <monochrom> Yes, (all implementations so far insists one module per file) is a fact. But your opinion of why it happens is not a fact. Here is my opinion of why it happens: tradition and easier to do separate compilation.
12:43:41 <mornfall> Of course, these are the real reasons. I don't dispute that. It doesn't mean that you are allowed to change the interpretation of the grammar.
12:47:58 <monochrom> Note also that the whole report does not explicitly declare a start symbol. To refute that there is an implicit start symbol, I refer to the ECMAScript spec version 3: it is explicit about the start symbol, which it calls the goal symbol: "The program is syntactically in error if the tokens in the stream of input elements cannot be parsed as a single instance of the goal nonterminal Program, with no tokens left over." (5.1.4)  
12:47:59 <monochrom> There is no similar thing in the haskell reports.
12:55:53 <Jeroen__> Hi All
12:57:21 <Jeroen__> Can someone tell me what's wrong with my type definition ? http://pastebin.com/VzhHiUkn
12:59:29 <Cale> Jeroen__: One problem is that it will be impossible to acheive the behaviour that you want without the ability to compare elements for equality.
12:59:45 <Cale> achieve*
13:00:36 <Cale> er, hmm
13:00:49 <Cale> oh, maybe it is doable without
13:00:49 <Jeroen__> Because I'm using 'a' and 'b', right ?
13:00:57 <Jeroen__> So how can I get a really general type def ?
13:02:00 <monochrom> this is a case of "insufficient data for a meaningful answer"
13:02:04 <Cale> oh, right, you could take a Cartesian product of sorts without Eq, but you couldn't collect it like that unless you really had Eq
13:02:28 <Cale> You can always delete your type signature and ask GHCi what it thinks
13:03:13 <Jeroen__> This is what it told me : duaal :: (Eq t1) => [(t, [t1])] -> [(t1, [t])]
13:03:28 <Cale> Then there you go :)
13:03:39 <ManateeAuthor> Sleep... bye. :)
13:03:48 <Cale> Feel free to replace t1 and t with variables of your choosing
13:03:54 <monochrom> you can write it as (Eq b) => [(a, [b])] -> [(b, [a])]
13:04:05 <Jeroen__> So why does it know that 't' equals 't', but doesnt know that t1 equals t1 ?
13:04:12 <Cale> huh?
13:04:16 <Jeroen__> :D
13:04:25 <monochrom> Eq t1 does not mean "t1 equals t1"
13:04:26 <Jeroen__> Right, what's the 'Eq b' for ?
13:04:31 <Cale> Eq t1 means that values of type t1 can be compared for equality
13:04:38 <Cale> (with == and /=)
13:04:48 <monochrom> Eq means "==" and "/=" are supported
13:05:06 <Jeroen__> I see
13:05:13 <Cale> There are many types which can't be meaningfully compared, like arbitrary functions or IO actions.
13:05:22 <Jeroen__> Ok
13:05:23 <monochrom> please don't read programming languages as natural languages.
13:06:01 <monochrom> even cobol is not always like natural languages
13:06:19 <radioactive_man> lol
13:06:20 <Jeroen__> What would the type def look like if 'a' also has to be able to be compared for equality ?
13:06:41 <monochrom> (Eq a, Eq b) => [(a,[b])] -> [(b,[a])]
13:06:50 <Jeroen__> Ok, thx
13:07:44 <Jeroen__> A more general question: whats the name of those inline functions ?
13:08:03 <Jeroen__> something like (\x y -> x + y == 4) (or something like that)
13:08:21 <Jeroen__> I want to look up some info, but what is that form called ?
13:08:31 <mercury^> lambda expression or something like that
13:08:32 <monochrom> anonymous functions, lambda, lambda terms, λ terms
13:08:40 <Jeroen__> Ok, thx :)
13:08:47 <monochrom> notice that \ is ascii art for λ
13:08:52 <Jeroen__> Ha :D
13:08:57 <Jeroen__> Crappy ascii art :p
13:09:04 <Jeroen__> ,\
13:09:06 <Jeroen__> :D
13:09:06 * mercury^ forgot to start screen with -U last time it crashed.
13:09:13 <djahandarie> 'Art' is probably not the correct term for that ;)
13:09:17 <djahandarie> Representation maybe :)
13:09:25 <dskippy> Happy Thanks Giving everyone. Is there a handy function that will give me the minimum of a list as compared by an accessor, rather than the whole value? Example "minimumBy snd [(A,1),(B,2),(C,0)]" == (C,0)
13:09:38 <mercury^> Now I face the difficult decision of having to setup my irc client again or living with not reading anything beyond ascii.
13:10:07 <luite> dskippy: minimumBy (compare `on` snd)
13:10:10 <monochrom> if and only if it will crash again in 5 days, don't bother restarting
13:10:23 <luite> dskippy: or comparing instead of compare `on`
13:10:28 <dskippy> luite I couldn't find minimum by.
13:10:33 <luite> dskippy: Data.List
13:10:40 <luite> dskippy: and `on` is in Data.Function
13:10:41 <dskippy> luite, Thanks.
13:10:41 <Rembane> dskippy: minimum $ map snd [(A,1),(B,2),(C,0)]
13:10:52 <dskippy> luite: Yeah on is awesome.
13:11:06 <dskippy> Rembane: That ditches the value in the first.
13:11:23 <Rembane> dskippy: Good point. Nevermind then. :)
13:13:12 <radioactive_man> how can i do a fold on arrays ?
13:13:45 <radioactive_man> i get "not enough stack" error with : foldM (\s i -> do a <- readArray xs i; return (s `f` a) ) x0 [i..j]
13:20:09 <radioactive_man> did haskell invent the curry wurst?
13:20:11 <Cale> radioactive_man: why not just getElems and then use the normal list folds?
13:20:41 <radioactive_man> because thats slow^n
13:20:41 <Cale> (maybe a strict left fold)
13:20:47 <Cale> It shouldn't be slow at all.
13:21:24 <Cale> well, hmm, let's see
13:23:12 <Jeroen__> Thanks for the help everyone, I'm off :) (And happy thanksgiving to those across the atlantic)
13:23:42 <Cale> Well, okay, it's linear time to getElems, but you're reading them all anyway
13:23:58 <Cale> Maybe the space for the intermediate list is an issue.
13:24:15 <radioactive_man> its just that lists are incredibly slow
13:24:23 <Cale> They are not. :)
13:24:30 <radioactive_man> for me they are^^
13:24:35 <Cale> They only have slow random access
13:24:43 <Cale> For linear access like folds, they're idea.
13:24:45 <Cale> ideal*
13:25:00 <radioactive_man> well i get about 20x slowdown compared to arrays
13:26:23 <radioactive_man> its just a constant - but its huge ;)
13:26:32 <blackh> radioactive_man: Converting it to a list then folding the list is the right way to do it. If it's slow, then it's a bug.
13:26:55 <blackh> Is there something else slowing it down?
13:27:05 <radioactive_man> i dont do anything fancy
13:27:08 <radioactive_man> just a fold
13:27:49 <razvandimescu> how can i declare a class in haskell?
13:28:09 <monochrom> foldM (\s i -> do a <- readArray xs i; return $! (s `f` a) ) x0 [i..j]
13:28:22 <blackh> razvandimescu: What do you mean by "class"?
13:28:26 <Cale> Hmm, actually getElems is unduly slow
13:29:03 <Cale> If you really need to keep the elements in an array you can use foldM with $! like monochrom showed.
13:29:20 <Cale> But in some tests, that's still much slower than folding over a list.
13:29:25 <radioactive_man> currently trying it
13:29:32 <Cale> (over 10 times slower)
13:29:33 <monochrom> getElems then drop i incurs some wasteful work
13:30:06 <Cale> Oh, yes, that's true, if you're only looking at certain indices.
13:30:08 <blackh> Cale: That could be important (for me)! Thanks.
13:30:16 <razvandimescu> blackh: i would like to group together some functions, somehting like a library/module i guess
13:30:56 <monochrom> I feel that a complete rewrite can satisfy both fast and uses-list
13:30:58 <blackh> razvandimescu: Well, Haskell doesn't have anything that directly corresponds to a class in object oriented programming.
13:31:11 <Cale> razvandimescu: Make a file called Foo.hs and stick  module Foo where  at the top of it.
13:31:29 <Cale> razvandimescu: From other files in your project you can write  import Foo  to import the definitions from there.
13:31:45 <monochrom> converting a for-C-algorithm into haskell verbatim-except-change-array-to-list is slow of course
13:31:52 <Cale> razvandimescu: You can also restrict what you import and export from modules.
13:32:11 <monochrom> but converting a for-C-algorithm into haskell verbatim is slow to begin with
13:32:22 <Peaker> monochrom, what if you keep arrays arrays?
13:32:40 <radioactive_man> whoa it works :D
13:32:51 <radioactive_man> you  safed my day! thx monochrom!
13:33:17 <monochrom> still slow because most haskell arrays are lazy but you don't use the lazy part so it's extra work down the drain
13:33:19 <blackh> radioactive_man: Is it really fast?  (I've got a problem with slow arrays and it sounds like you might have found it for me!)
13:33:28 <Peaker> monochrom, IOArray is lazy?
13:33:32 <monochrom> yes
13:33:36 <razvandimescu> Cale: thanks, cool stuff
13:33:40 <Peaker> monochrom, oh, you mean boxed
13:33:40 <radioactive_man> when i use arrays in haskell they are as fast as c++
13:33:44 <Peaker> IOUArray then, I guess
13:34:00 <radioactive_man> with data.array.storable its fast, blackh
13:34:23 <blackh> thanks!
13:34:36 <monochrom> yes, IOUArray is not slow. but some other part of your for-C-algorithm may still be problematic
13:34:50 <radioactive_man> blackh, but try to use -O2 and {-# INLINE zipWithA #-}, so you use rewrite rules right
13:35:05 <radioactive_man> , where zipWithA is the name of your function^^
13:35:25 <dskippy> Where is comparing defined?
13:35:27 <monochrom> the big picture is that your for-C-algorithm uses for-C-idioms not recognized by optimizing haskell compilers. whereas if you use for-haskell-idioms they are.
13:35:36 <Cale> razvandimescu: Other aspects of classes from OO are split up across a bunch of different language features. If you think of a class as a datatype whose objects are specified through the implementations of certain functions or procedures, you can define a record datatype in Haskell whose fields are functions or IO actions (or a combination of the two)
13:36:08 <Cale> dskippy: Data.Ord
13:36:32 <dskippy> Cale: Thanks. Annoying one to Google for it turns out.
13:37:08 <Peaker> monochrom, when I looked at some "fast" Haskell stuff, it all seemed to be using C-like idioms in Haskell :)
13:37:32 <monochrom> perhaps those live in the overlap between the two.
13:38:45 <monochrom> or hybrid C-haskell idioms
13:39:02 <Peaker> Lots of pointer fiddling
13:39:04 <radioactive_man> haskell gets really fast using unboxed arrays and rewrite rules
13:39:43 <Peaker> I wonder if ByteString can be replaced by a parametric type (some kind of IOUArray, so it looks like BlahArray Word8) so we can have "fmap"/etc without "ListLike", etc
13:39:48 <Peaker> (without losing performance)
13:39:54 <Peaker> (for the unparametric case)
13:40:07 <Cale> Peaker: That's sorta what Vector is
13:40:07 <Peaker> s/unparametric/Word8
13:40:15 <Jiten> is there a function defined in a module somewhere that basically is: swapTuple (a,b) = (b,a)
13:40:28 <Cale> Jiten: no, though a lot of people call it swap
13:40:29 <Peaker> Cale, So Vector Word8 should roughly be equivalent to ByteString? And there's lazy/strict vector?
13:40:40 <Cale> yeah
13:40:47 <Peaker> @type uncurry (flip (,))
13:40:48 <lambdabot> forall b a. (a, b) -> (b, a)
13:40:54 <Jiten> there's this nice mismatch with modifyMVar and runStateT :P
13:41:00 <Cale> Err...
13:41:06 <monochrom> for example translating "for (i=0...) { a[i]=0 }" to haskell using STRef for i is verbatim but slow. People translate it to "mapM_ [0..blah] (writeArray ...)" and that's a hybrid idiom and works ok.
13:41:08 <Cale> (are there lazy Vectors?)
13:41:23 <Cale> It definitely does fusion.
13:41:57 <monochrom> Anyway StorableArray looks nice. Not as restrictive as IOUArray.
13:42:12 <radioactive_man> oh yeah i love storablearrays
13:42:16 <FunctorSalad> of which package is that?
13:42:19 <radioactive_man> work real nice with ffi
13:42:20 <jrk_> hi
13:42:27 <monochrom> the package is "array". comes with GHC
13:42:29 <jrk_> i got a 'type foo = String'
13:42:38 <jrk_> and a 'type bar = String'
13:42:42 <FunctorSalad> ah :)
13:42:48 <jrk_> now i'd like to make an instance
13:42:50 <monochrom> the module name is Data.Array.Storable
13:43:00 <jrk_> 'instance Foo where'
13:43:06 <jrk_> 'instance Bar where'
13:43:09 <jrk_> but
13:43:25 <jrk_> i get 'Duplicate instance declarations'
13:43:41 <FunctorSalad> are type families involved? ;)
13:43:46 <jrk_> because they are both Strings and only alias types
13:43:54 <jrk_> what can i do about it?
13:44:14 <FunctorSalad> you mean 'Foo' and 'Bar' are type synonyms expanding to the same thing?
13:44:24 <jrk_> exactyl
13:44:38 <Cale> jrk_: Then you can't do that.
13:44:45 <Cale> jrk_: Use newtype instead.
13:44:49 <FunctorSalad> *nod*
13:44:57 <jrk_> hmm..
13:45:03 <jrk_> that's nasty
13:45:11 <Cale> Which classes?
13:45:33 <jrk_> cause i can't change the type aliases
13:45:59 <FunctorSalad> jrk_: type synonyms are compareable to a preprocessor macro... they aren't really in any way distinct from their expansion
13:46:03 <jrk_> the class is written by me
13:46:10 <jrk_> ok
13:46:13 <monochrom> Must you use a typeclass?
13:46:32 <jrk_> er
13:46:38 <jrk_> is there an alternative?
13:46:47 <jrk_> i mean.. i wish to have polymorphism :)
13:47:12 <shachaf> jrk_: You can't have polymorphism on the same type. :-)
13:47:19 <monochrom> many wishes are not granted
13:47:35 <jrk_> yeah, that crossed my mind too atm ;)
13:47:41 <monochrom> carefully divide what you need from what you mistakenly want
13:48:33 <jrk_> mh
13:48:37 <jrk_> good hint
13:48:47 <jrk_> i think i have to reconsider my design
13:49:22 <FunctorSalad> *makes a note too* :)
13:49:32 <osaunders> Trying to install Leksah (again): <http://hpaste.org/41811/cabal_cairo_install_fail> Any suggestions?
13:50:08 <radioactive_man> :)
13:50:29 <osaunders> Isn't it type class not typeclass.
13:50:40 <monochrom> yes, type class
13:50:56 <monochrom> "typeclass" is an old mistaken learned from this channel
13:51:04 <FunctorSalad> 'typeclass' makes it clearer it's a technical term rather than a class of types *captain obvious*
13:51:08 <jrk_> geeeh... i knew that haskells white space sensitive.. :)
13:51:39 <osaunders> FunctorSalad: But they are classes of types.
13:51:56 <FunctorSalad> but not every class of types is a typeclass ;)
13:52:27 <osaunders> typeclass doesn't exist though.
13:52:34 <osaunders> As we just established.
13:52:34 <FunctorSalad> and there can be many typeclasses (with different methods) for the same set of types
13:52:40 <FunctorSalad> oh :(
13:53:13 <osaunders> Anyway this is incredibly unimportant. I wish I hadn't mentioned it.
13:53:30 <FunctorSalad> yes sorry for supporting the discussion
13:53:58 <monochrom> the reports use "type class". that closes the case for me.
13:54:51 <osaunders> Anyone able to help with my pastie above?
13:58:05 <blackh> osaunders: That's a missing GNU package called cairo-pdf, not a missing Haskell package.
13:58:10 <blackh> What OS are you using?
13:58:22 <osaunders> OS X
13:58:38 <blackh> osaunders: 10.5 or 10.6?
13:58:43 <osaunders> OK I can try install a couple macports
13:58:44 <osaunders> 10.6
13:59:08 <blackh> I know that it's possible to install Leksah on 10.6, but I can't help much more than that.
13:59:22 <osaunders> Well that's good to know :-)
13:59:27 <osaunders> (That it is possible.)
13:59:47 <blackh> Hamish Mack (one of the developers of Leksah) runs it on Mac OS/X 10.6.
13:59:53 <blackh> I'm using 10.5 and I gave up. :)
14:00:20 <blackh> Hasmish Mackenize, that should b
14:00:21 <blackh> e
14:00:54 <osaunders> TextMate is just annoying me too much.
14:01:05 <osaunders> The syntax coloring for Haskell is really awful.
14:01:17 <radioactive_man> in vim its probably worse
14:01:24 <osaunders> I doubt it.
14:01:35 <osaunders> I don't really know but I doubt it.
14:01:48 <blackh> I use jEdit. There's nothing special about it - but I did the Haskell syntax colouring.
14:01:50 <radioactive_man> it doesnt understand comments - so it randomly colors things as a comment or not
14:02:40 <mreh> how come GHC does away with any make files
14:02:43 <radioactive_man> whats wrong with textmate?
14:02:52 <osaunders> OK, you might be right about it being worse in that case.
14:03:20 <osaunders> radioactive_man: It doesn't understand type annotations unless they are written at the top.
14:03:35 <osaunders> radioactive_man: It gets class constraints wrong most of the time.
14:03:43 <blackh> osaunders: Have you checked the Leksah website? I know Hamish was making quite an effort to make it possible to install on Mac OS/X.
14:03:47 <blackh> There should be something on there.
14:04:01 <radioactive_man> oh well, just as every os sucks, every editor sucks too
14:04:27 <FunctorSalad> might as well use The Standard Editor ;)
14:04:44 <osaunders> radioactive_man: It is overeager at distinguishing things that are in the prelude (giving them different colors). Which is completely useless if you happen to shadow or hide them.
14:05:16 <osaunders> blackh: Yeah, I'll have a poke around.
14:05:19 <osaunders> Thanks
14:05:45 <osaunders> radioactive_man: It also highlights all operators a keywords.
14:05:52 <radioactive_man> lol :)
14:06:39 <osaunders> Some of these problems can be corrected but after some fiddling around I think I'd be subjecting myself to something unpleasant if I tried to get the more serious ones fixed.
14:07:11 <FunctorSalad> sorry naive question, but what about vim or emacs o_O
14:07:19 <monochrom> do you mind emacs? emacs haskell mode has none of those problems
14:07:45 <osaunders> I tried vim for a while, I don't really get on with it and I don't know CL.
14:08:05 <monochrom> no knowledge of CL needed.
14:08:07 <radioactive_man> cl is like prefix-haskell
14:08:22 <FunctorSalad> without types ;) and with dynamic scope in the case of emacs
14:08:27 <radioactive_man> ^^
14:08:29 <blackh> osaunders: jEdit does everything and it works exactly the same on every platform. It's a bit clunky, though.
14:09:16 <osaunders> Hm, I'll give emacs some thought.
14:09:32 <osaunders> If I started using it I'd no doubt want to play with it after a while.
14:09:41 <osaunders> I really like my macros and snippets in TM.
14:09:52 <radioactive_man> i kinda like those linux editors, like kate
14:09:54 <osaunders> (Play with the CL, I mean).
14:10:03 <blackh> The thing that worries me about emacs is that I want an editor, not a relationship.
14:10:08 <osaunders> Yeah
14:10:16 <osaunders> I don't want to read mail.
14:10:23 <monochrom> I have no relationship.
14:10:31 <osaunders> Oh wait isn't emacs, emac lisp not CL.
14:10:45 <FunctorSalad> yeah
14:10:53 * osaunders is a silly.
14:11:00 <blackh> That's what I like about jEdit - it's just an open source fully-featured GUI editor, written in Java, which at least means you can run it on anything.
14:11:14 <monochrom> I aliased CL to emacs lisp in the above context.
14:15:02 <ClaudiusMaximus> i think i now understand why my code makes 'ad' explosively consume memory :(
14:15:03 <arcatan> can I unhide a module?
14:15:16 <radioactive_man> yeah
14:15:19 <monochrom> ghc-pkg expose whee
14:15:32 <ClaudiusMaximus> the documentation says "If the (partial) derivatives of each of those operations is known, then they can be composed to derive the answer for the derivative of the entire program at a point."
14:15:48 <arcatan> monochrom: doesn't that expose a package rather than a module?
14:15:48 <ClaudiusMaximus> but my function is quite large
14:15:56 <monochrom> oh, sorry
14:16:10 <FunctorSalad> how did you hide a module rather than a package then?
14:16:50 <ClaudiusMaximus> > let f z = z * z + c in f . f . f . f . f . f . f . f $ z
14:16:51 <lambdabot>   (((((((z * z + c) * (z * z + c) + c) * ((z * z + c) * (z * z + c) + c) + c)...
14:17:23 <arcatan> FunctorSalad: i'm trying to use some internal module of Snap (snap-server) to parse string into requests and ghc complains that it's hidden
14:17:38 <monochrom> modify project.cabal to move the module name from other-modules to exposed-modules
14:17:51 <FunctorSalad> beat me to it :)
14:18:30 <arcatan> monochrom: i guess so. thanks.
14:19:01 <monochrom> you could hack your package database if you want...
14:19:32 <ClaudiusMaximus> so, back to my quest for a multidimensional root finder that works with arbitrary number types
14:20:32 <arcatan> monochrom: nah, rebuilt it already and it works.
14:20:47 <radioactive_man> maximus, how do you search for roots? some gradient like algorithm?
14:22:38 <ClaudiusMaximus> radioactive_man: so far i tried GSL via 'hmatrix' (but that only goes up to Double precision) and 'ad' (using self-coded Newton's method with 'Vec' to solve J(f) (x' - x) = x)
14:23:08 <ClaudiusMaximus> oops, confused
14:23:12 <cole> I'm being told that I can't import "System.Environment" because it cannot be found. How can I get it?
14:23:38 <radioactive_man> maximus, does one have to specify starting points, or do you randomly select these?
14:23:43 <ClaudiusMaximus> anyway, the wikipedia page gives the formulas
14:24:01 <ClaudiusMaximus> radioactive_man: yes, i specify where i want to start from
14:24:55 <radioactive_man> damn! still no magic method to calculate the starting points^^
14:25:11 <ClaudiusMaximus> :)
14:26:55 <ClaudiusMaximus> anyway, 'ad' works up to about (iterate f z)!!1000, but after that memory usage shoots up and i kill my program....
14:27:15 <monochrom> System.Environment comes with GHC. If it is not found, you're in deep trouble.
14:27:44 <monochrom> OK, maybe you're not even using GHC.
14:27:49 <Mathnerd314> I need a complement to -fwarn-missing-signatures, say -fwarn-redundant-signatures, that warns if I give a type signature that can be inferred
14:28:20 <monochrom> There is no such complement.
14:28:44 <radioactive_man> just dont write any - and put in the missing ones ;)
14:29:39 <Mathnerd314> monochrom: not yet.
14:29:41 <monochrom> GHC version 75 will have all warning options conceivable.
14:30:07 <Mathnerd314> you mean 7.5?
14:30:12 <monochrom> I really mean 75
14:30:36 <monochrom> should take a century to add all conceivable flags, don't you think?
14:30:54 <radioactive_man> lol, thats a long-term feature plan
14:31:00 <Mathnerd314> monochrom: I don't care about the other flags; I just want this one
14:31:08 <cole> I'm using ghc
14:31:38 <monochrom> I don't really see this particular one in my lifetime
14:32:35 <monochrom> In fact haddock pretty much relies on explicitly intentionally redundant type signatures so there is little incentive for adding your wanted warning from the POV of the implementers.
14:33:03 <cole> Nevermind, I spelled environment wrong.
14:33:09 <monochrom> haha
14:33:09 <enthropy> monochrom: newer versions of haddock puts inferred signatures in the documentation
14:33:59 <monochrom> ah, and then they will invoke "top-level redundant type sigs are good practice" and still ignore requests for that warning
14:34:38 <enthropy> it should be easy enough to write a program that systematically removes top-level type sigs and checks if ghc still accepts the file
14:34:47 <monochrom> I am non-partisan on what's "good practice" but I see that this one will likely not happen.
14:35:16 <enthropy> Mathnerd314: can a redundant signature be different from what is inferred?
14:35:29 <Mathnerd314> enthropy: yes; it could be more specific
14:35:47 <Mathnerd314> @type (id :: Integer -> Integer)
14:35:48 <lambdabot> Integer -> Integer
14:35:52 <Mathnerd314> @type id
14:35:53 <lambdabot> forall a. a -> a
14:36:05 <Mathnerd314> something like that
14:36:11 <enthropy> then it's not redundant because it can change whether some code using those definitions is accepted
14:36:14 <Philippa> and that can be a useful property, not least for fixing interfaces
14:36:32 <Philippa> and if it /is/ redundant, what's the problem?
14:37:10 <Mathnerd314> enthropy: but some signatures *are* redundant, like "blah" :: [Char]
14:37:30 <Philippa> actually that isn't redundant in the presence of a GHC extension, but sure
14:37:45 <Philippa> but: what's your use case? Why do you care?
14:37:48 <enthropy> sure, I'm just trying to help you clarify your definition of redundant signature
14:38:19 <enthropy> Philippa: do you use the   \ pat -> expr     construct?
14:38:39 <Philippa> enthropy: do you mean, do I use lambdas at all? Yes, sometimes
14:40:01 <Mathnerd314> Philippa: mostly I have a lot of code of the form `f (a :: X)`, where f is either of type forall a. a -> b or of type X -> b, and it's non-obvious from the name of f whether it is polymorphic
14:40:05 <enthropy> perhaps you can see the similarity in motivation between not putting a function definition at top level and not putting type signatures at top-level
14:40:05 <Philippa> it's comparatively rare that I use the fact it's a pattern rather than a variable
14:40:37 <Philippa> Mathnerd314: you mean, you want to be warned when you could be more polymorphic?
14:41:06 <Philippa> enthropy: for me, that's a straw man - never argued against
14:41:18 <monochrom> you should cut down on writing "f (a :: X)" then.
14:41:38 <Mathnerd314> monochrom: not my code; I'm rewriting it
14:41:55 <Philippa> first of all: it really, really doesn't belong as a warning
14:41:59 <monochrom> I see.
14:42:29 <Philippa> it's hard to argue that it's always an improvement to remove a redundant annotation
14:42:53 <Philippa> if it is a warning, you're going to mess with people's coding styles
14:43:20 <Mathnerd314> Philippa: it always makes it shorter, which is good; note that I didn't say it should be on by default
14:43:32 <Philippa> given that caveat, yeah, it'd be nice to have the tool - but it actually involves quite a lot of effort to maintain
14:44:09 <Philippa> Mathnerd314: except an awful lot of people go with -wall and warnings as errors
14:44:17 <Philippa> really, that's a lot of pressure to put in place
14:44:25 <enthropy> Philippa: which difference between the two situations makes the analogy useless?
14:44:38 <Philippa> enthropy: the bit where I'm not advocating removing things
14:44:44 <Mathnerd314> Philippa: GCC doesn't turn on all warnings with -Wall; why should GHC?
14:45:00 <Philippa> *shrug*
14:45:14 <enthropy> Mathnerd314: ghc doesn't
14:45:16 <Philippa> so next in line is the maintenance burden. Do you understand how hard the problem is?
14:45:55 <Mathnerd314> no; I haven't the foggiest idea of GHC's implementation of types
14:46:02 <Philippa> I didn't say anything about implementation
14:46:25 <Philippa> but to be fair, I think there's an implementation that uses the typechecker as a black box
14:46:28 <Philippa> it's just, um, kinda slow
14:46:39 <Philippa> because it has to re-typecheck once per annotation, with that annotation removed
14:47:14 <Philippa> (and compare all the types necessary to confirm the relevant property's maintained, but that part's comparatively cheap)
14:47:41 <Philippa> the alternative approach, the one that's type-aware? Is hard work, bordering on if not actually research
14:48:15 <Philippa> and that's the case without having to look at issues caused by the specific implementation
14:48:49 <Philippa> (I could do it for plain Hindley-Milner comparatively easily, as in, fun puzzle - but GHC Haskell ain't Hindley-Milner by a long shot)
14:50:08 <matthiasgoergens> @pl (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
14:50:08 <lambdabot> (line 1, column 5):
14:50:08 <lambdabot> unexpected ">"
14:50:08 <lambdabot> expecting variable, "(", operator or ")"
14:50:13 <cole> How do you load a module in ghci?
14:50:25 <enthropy> :module
14:50:32 <monochrom> :m + Data.List
14:51:01 <monochrom> it is not so much loading as increasing scope
14:51:22 <monochrom> if it's your own module, not in libs: :load Whee.hs
14:51:54 <blackhole89> I am probably doing something immensely stupid, but how come that when I import Data.ByteString, decode from Data.Binary spits a "Couldn't match expected type `Data.ByteString.Lazy.Internal.ByteString'" at me
14:51:56 <applicative> :l fingertreeinterval.hs
14:52:09 <blackhole89> and when I import Data.ByteString.Lazy, it goes "Couldn't match expected type `Data.ByteString.Internal.ByteString'"
14:52:28 <blackhole89> in the same place
14:52:43 <monochrom> there are two kinds of bytestrings, lazy and non-lazy, you know that?
14:52:50 <blackhole89> yes
14:52:55 <Mathnerd314> Philippa: but everything GHC-y seems to be research, so that doesn't seem to be saying much
14:52:59 <applicative> one is a list of the other, crudely
14:53:02 <blackhole89> my problem here just is that whenever I import one, it appears to start expecting the other
14:53:04 <monochrom> but I see your problem
14:54:05 <monochrom> decode absolutely wants the lazy one
14:54:12 <applicative> blackhole89, if you hpaste.org it, it might be visible what's up. Are there other imported modules?
14:55:00 <monochrom> yeah, some other part of your code demands the non-lazy one and conflicts decode
14:55:36 <blackhole89> well, I'm also using network.socket.bytestring
14:55:47 <monochrom> it takes two hands to clap. it takes two code paths to type error.
14:56:29 <monochrom> "Network.Socket.ByteString.Lazy" :)
14:56:52 <blackhole89> okay, that compiled
14:56:54 <blackhole89> almost too simple
14:57:10 <blackhole89> although now I'd kind of like to know why it threw up on decode in both cases
14:57:37 <blackhole89> because no matter how I look at it, my interpretation of the errors observed would be "whichever I pick, decode expects the other"
14:57:44 <monochrom> "Network.Socket.ByteString" wants non-lazy, decode wants lazy. it takes two code paths to type error.
14:58:40 <blackhole89> I do understand what the problem was from a holistic point of view
14:59:11 <applicative> what decode is this?
14:59:27 <monochrom> I see. I don't entirely know what is "expected" either. I only loosely know that often it means "from external constraints"
14:59:33 <monochrom> Data.Binary.decode
15:00:09 <blackhole89> Hm.
15:00:15 <applicative> decode "Decode a value from a lazy ByteString, reconstructing the original structure."
15:00:19 <blackhole89> Well, at least it builds 
15:00:49 <blackhole89> with time and enlightenment, I might come to understand how exactly that happened
15:00:50 <blackhole89> thanks
15:01:05 <monochrom> If you say "the message should not mention 'expected' vs 'inferred'", I agree, and it seems to be the consensus too.
15:01:46 <enthropy> > (undefined :: Int) :: Integer
15:01:47 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
15:01:47 <lambdabot>         agains...
15:02:08 <Philippa> expected is what it knew before it started inspecting that node of the AST, inferred is when it gets back up there again
15:03:02 <enthropy> the problem is that both types mentioned are expected and can be inferred in some cases
15:03:33 <blackhole89> Ah!
15:03:35 <enthropy> as in, when you get type errors without annotations being so closely in conflict like above
15:03:53 <blackhole89> Completely eluding my attention, "expected" and "inferred" were swapped between the two error messages.
15:03:53 <monochrom> http://en.wikipedia.org/wiki/Infernal_Affairs :)
15:04:00 <blackhole89> So this was at the poodle's core, etc.
15:05:05 <Philippa> enthropy: they mean something specific in the context of the GHC typechecker - approximately the distinction I describe
15:05:21 <Philippa> monochrom: I can never decide whether it or The Departed is the better film
15:05:53 <monochrom> indeed people are very polarized on that
15:06:01 <Philippa> (and I suspect I'm lacking enough info on the original, despite having seen it more than once)
15:06:44 <monochrom> I do think most of the time people are just splitting hair when it comes to movie quality.
15:07:02 <Philippa> I saw IA first, FWIW. I suspect most people who saw The Departed first lean towards that just because they didn't know the outcome of all the tense parts
15:08:01 <Philippa> enthropy: if you read the "putting 'putting type annotations to work' to work" material, I think that describes it reasonably
15:08:03 <enthropy> Philippa: of course, ghc doesn't randomly swap which type gets which label when it gives a type error
15:08:27 <Philippa> certainly it's something in the vicinity of that which describes it, anyway!
15:08:30 <enthropy> Philippa: is that the title of the material?
15:08:42 <Philippa> it's definitely at least the title of a talk on the same subject
15:09:03 <Philippa> I think you want the paper though, which ought to be on SPJ's publications page
15:09:08 <Philippa> (at least, I think SPJ was involved)
15:10:51 <Philippa> monochrom: it's nice to at least have a remake that deserves such arguments, anyway :-)
15:13:58 <enthropy> Philippa: did the talk discuss typing -XRank2Polymorphism / -XExistentialQuantification using a minimum of annotations?
15:16:15 <Philippa> enthropy: nope, it's about rank n not rank 2
15:16:33 <Philippa> it /is/ about reducing the annotation burden compared to Odersky's earlier work though
15:21:50 <Jiten> how do I stop Network.Browser from printing the HTTP request and response headers on every request I make?
15:22:00 <Jiten> it appears to do it by default
15:23:29 <cole> Let's say I wanted to be able to query the length of a list without having to walk the entire list (by calling "length myList") what would my options be?
15:24:27 <Zao> cole: Not using a list.
15:24:36 <blackh> cole: You can wrap it with something that stores the length, or you can use a different data structure like Data.Sequence
15:24:39 <cole> Some languages store the length of a list along with the contents. Haskell doesn't. Could I define my own datatype which also stores the length of the list?
15:24:43 <Jiten> try looking in here http://hackage.haskell.org/cgi-bin/hackage-scripts/package/containers
15:24:46 <sipa> cole: yes
15:24:57 <Jiten> and yes, you could define your own datatype too
15:25:12 <Zao> cole: You would not be able to guarantee that length though, unless you either hid the list completely or trust that any user must tell you the new length.
15:25:23 <blackh> cole: Data.Sequence is good for a lot of things that List doesn't quite do.
15:30:43 <blackhole89> According to ghci (and not-in-scope errors) sendTo exists in Network.Socket.ByteString, but not in Network.Socket.ByteString.Lazy...
15:40:51 <monochrom> Jiten: setOutHandler (const (return ()). There is also setErrHandler
15:47:36 <dibblego> byorgey, I looked at those three packages; none seem to allow my desire to generalise to a type-class
15:48:36 <ivanm> dibblego: what are you after?
15:49:07 <dibblego> record combinators where each field is on a type class, not a data type
15:49:15 <ion> If i have a function f :: a -> a -> a -> a and a list [1,2,3], how do i apply the list as f 1 2 3? foldl ($) f [1,2,3] doesn’t work because a type violation.
15:49:36 <dibblego> ion, \[a, b, c] -> f a b c
15:51:01 <Jiten> monochrom: thank you :)
15:51:04 <enthropy> dibblego: what part of the (data,label) is the field?
15:51:07 <ivanm> ion: yeah, I don't think there is a way of doing that for the generic case
15:51:12 <ion> Ok, thanks
15:51:54 <dibblego> enthropy, are you suggesting that it is not sensible?
15:51:59 <ivanm> ion: unless you very carefully write a custom fold-like function that keeps calling itself...
15:53:29 <enthropy> dibblego: I'm not jumping to that conclusion until I understand what your need is
15:53:43 <dibblego> enthropy, I only ask because I suspect it is not sensible also
15:54:31 <dibblego> enthropy, I wish to have combinators for data type with many fields, but those fields are defined as type-class functions, not data fields
15:54:31 <enthropy> also what the request even is
15:55:15 <enthropy> in one class or classes?
15:56:21 <dibblego> class GetJelly r where get :: r -> Jelly; set :: r -> Jelly -> Jelly
15:57:58 * ivanm suspects someone is hungry...
16:05:35 <enthropy> dibblego: shouldn't set return an r?
16:05:51 <dibblego> yes sorr
16:05:51 <dibblego> y
16:06:38 <enthropy> and you'll expect people to write classes/instances GetJelly for every type?
16:07:03 <enthropy> or make it a MPTC/type family where Jelly is associated with the r
16:07:16 <enthropy> which is more or less how HList/records do it
16:07:44 <dibblego> yeah I was fiddling with MPTCs
16:08:20 <dibblego> I think that might be the way to go
16:09:23 <enthropy> dibblego: if you don't keep the structure of the records (being a list or whatever) out of user fields (Jelly) how do you stop the duplication when people write those classes?
16:09:24 * monochrom imagines that functional dependency is multiple parameter type class monomorphism restriction :)
16:09:58 <enthropy> @quote mono.*restriction
16:09:59 <lambdabot> JohnMeacham says: There will also be a karaoke competition to determine the fate of the monomorphism restriction.
16:10:07 <enthropy> @quote monoc.*restriction
16:10:07 <lambdabot> No quotes match. You speak an infinite deal of nothing
16:10:11 <monochrom> hahaha karaoke competition
16:10:25 <monochrom> @quote monochrom restriction
16:10:25 <lambdabot> No quotes match. Wrong!  You cheating scum!
16:10:55 <dibblego> enthropy, this is my dilemma essentially
16:11:15 <enthropy> dibblego: to me it seems you're looking for something more like data-accessor
16:11:30 <dibblego> enthropy, perhaps, I shall look more, thanks
16:11:34 <enthropy> where you don't get to concatenate records and such
16:16:21 <Adamant> be careful. there are karaoke ringers.
16:28:11 <alpounet> hey Cale, joined math.SE too
16:28:12 <alpounet> nice
16:29:18 <luite> hmm, sveriges universitets matematikportal
16:31:57 <maarons> Hi, is it possible to export all symbols from a module including imported ones?  Currently I have "module X where import A ...", but symbols from A are not exported.
16:33:19 <dibblego> what am I doing wrong wrt data-accessor? http://paste.pocoo.org/show/296102/
16:34:14 <ivanm> maarons: yes, but you need an explicit export list
16:34:27 <ivanm> module X ( foo, bar, module A ) where import A ...
16:35:17 <enthropy> dibblego: it doesn't magically use the named fields you've created
16:35:37 <dibblego> enthropy, is there a type-class to implement?
16:36:17 <dibblego> enthropy, I'm trying to use the example on the module description and the Example.hs doesn't include this example
16:36:43 <maarons> ivanm: module X (module A) was what I needed!  Thanks.  I didn't see it documented anywhere though=/
16:37:11 <ivanm> np
16:37:21 <enthropy> it's definitely documented in the language report
16:38:18 <dibblego> enthropy, data-accessor is documented in h98 report?
16:38:41 <enthropy> no, but module export lists are
16:38:51 <dibblego> oh right
16:39:22 <enthropy> dibblego: last I used data-accessor you need to write some boilerplate for the accessors
16:39:34 <enthropy> but there's some template-haskell to automate it
16:40:36 <dibblego> oh right I think I see now thanks
16:41:53 <monochrom> tutorials are not meant to be complete
16:46:05 <blackh> fwiw, my favourite accessor library is fclabels
17:02:59 * monochrom begins installing gtk2hs
17:04:32 * McManiaC fails to install wx
17:04:33 <McManiaC> :>
17:04:39 <augur> byorgey: quelle interresant
17:04:51 <augur> i await the explanation of division
17:05:12 <augur> byorgey: also, i think Reader and State are the same, just State is upside down
17:12:57 <nejucomo> Firefox tells me "Error code: sec_error_reused_issuer_and_serial" when attempting to load: https://www.haskell.org/haskellwiki/Orphan_instance
17:13:07 <nejucomo> Is this a known problem?
17:13:19 <nejucomo> It looks like a certificate was misconfigured.
17:14:30 <monochrom> yeah, "localhost.localdomain" seems lame even for a self-signed certificate :)
17:15:07 <monochrom> onoes, now his computer is also compromised!
17:16:52 <nejucomo> The firefox error isn't for the domain (I trust CACert more than commercial CAs) it's because the serial number was reused.
17:17:21 <nejucomo> I also prefer self-signed certs to CA signed certs.  :-)
17:17:33 <monochrom> I see
17:21:52 <ClaudiusMaximus> aaarrg i hate 'nan' :-[
17:22:12 <nejucomo> Huh.  I don't really understand orphan modules, nor why I should care.
17:22:34 <monochrom> it just hurts separate compilation, that's all.
17:22:39 <nejucomo> It's strange how haskell seems like such a pure language, yet ghc exposes implementation warts.
17:22:49 <nejucomo> "hurts" how?  By making it less efficient?
17:23:15 <monochrom> by recompiling modules that probably doesn't need recompile
17:23:45 <nejucomo> Ah, I see.
17:23:49 <ClaudiusMaximus> is there any way to tell where a 'nan' came from, eg, whether it resulted from 0/0 or inf-inf or something along those lines?  (or better, exception with stack trace?)
17:24:06 <Saizan> really? i thought the problem was just that it'd have to scan more .hi files
17:24:47 <nejucomo> It sounds like from the ghc docs it only costs scanning .hi files.
17:24:53 <blackh> ClaudiusMaximus: If you can run it in ghci, then I can tell you a way.
17:25:10 <ClaudiusMaximus> blackh: should be possible
17:25:28 <nejucomo> So I am defining an instance in module M.  If I understand the docs on orphans, this means to compile M, ghc needs to scan all transitive dependency interfaces.
17:25:30 <blackh> ClaudiusMaximus: Here's the procedure. Step 1: Type :break main
17:25:48 <nejucomo> If the cost is *only* to compiling M and *not* to compiling modules that import M, then I'm happy with the cost.
17:25:49 <blackh> Step 2: Type main
17:26:02 <blackh> Step 3: (when it hits the breakpoint), type :trace
17:26:03 <nejucomo> Does anyone know if it adds a cost to modules which import M?
17:26:11 <nejucomo> (It sounds like it does not from the docs.)
17:26:11 <blackh> Actually, step 0: ghci -fbreak-on-exception
17:26:34 <blackh> Step 4: Use :list and :history commands
17:26:43 <blackh> ClaudiusMaximus: Sort those steps into order, then do them. :)
17:27:15 <Saizan> a NaN doesn't throw an exception, or does it?
17:27:29 <Saizan> also, i think you've to run :trace main
17:27:40 <blackh> Well, that won't work, then.
17:28:12 <byorgey> augur: hm?  what about Reader and State?
17:28:39 <ClaudiusMaximus> blackh: thanks for the tips, but since nan is silent, not much i can do :(
17:28:54 <blackh> Poo
17:30:59 <monochrom> M is an orphan module. "GHC ... visits the interface file of every orphan module below the module being compiled". So If X imports Y, Y imports M, then when compiling X, GHC will visit M.hi
17:32:58 <nejucomo> Ah, I see.
17:33:38 <nejucomo> I take back my complaint that GHC is exposing implementation details unnecessarily.  This would affect the users of my library.
17:38:05 <nejucomo> I find I want general "short circuit" combiners for Either where the Left represents an error condition, so I've written this: http://codepad.org/s5I2fpCA
17:38:16 <nejucomo> Is there already a way to do these operations in the stdlib?
17:38:32 <nejucomo> Also, is there a way to make the Functor instance I want here?
17:41:36 <dibblego> nejucomo, that looks like (>>=) You might like to see Data.Validation on hackage
17:42:23 <enthropy> @instances-importing Control.Monad.Instances Either
17:42:23 <lambdabot> Couldn't find class `Either'. Try @instances-importing
17:42:28 <enthropy> @instances-importing Control.Monad.Instances Functor
17:42:29 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:42:57 <nejucomo> dibblego: fmapRight looks like fmap to me and injectRight looks like (flip (>>=)).
17:43:22 <enthropy> =<<
17:43:26 <dibblego> nejucomo, yes precisely, Control.Monad.Instances has those
17:43:38 <enthropy> depends
17:43:40 <nejucomo> Ah, there's a Functor instance for Either a in Control.Monad.Instances ?
17:43:45 <nejucomo> Excellent.
17:43:48 <enthropy> @instances-importing Control.Monad.Error Either
17:43:49 <lambdabot> Couldn't find class `Either'. Try @instances-importing
17:43:52 <enthropy> @instances-importing Control.Monad.Error Monad
17:43:52 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:44:52 <enthropy> so mapRights = mapM; and presumably there are foldM variations to suit you
17:44:55 <monochrom> Control.Monad.Instances has instance Functor (Either a)
17:45:36 <nejucomo> Thanks!
17:47:47 <augur> byorgey: i took some things that are nicely done using the reader monad
17:47:54 <augur> eg an evaluator for a system with variables
17:48:07 <augur> and i turned the expressions inside out, as if using a zipper
17:48:36 <onteria> after looking over I can't count how many anymore tutorials on Monads I think it's finally clicking
17:48:41 <ivanm> @type partition
17:48:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
17:48:49 <augur> so instead of (Let 'x' 1 (Add 'x' 2)) you do (Add 'x' 2 (Let 'x' 1 Bottom))
17:49:10 <onteria> @src words
17:49:10 <lambdabot> words s = case dropWhile isSpace s of
17:49:10 <lambdabot>     "" -> []
17:49:10 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:49:19 <augur> and then i defined the appropriate functions for evaluating such a thing
17:49:27 <augur> and the result basically looked like the state monad
17:49:34 <nejucomo> onteria: For me it helped to see different instances:  IO, State, Parsec were helpful.
17:50:06 <nejucomo> Actually I ended up implementing something like State from a tutorial somewhere and that helped.  Let me see if I can find that tutorial...
17:50:14 <enthropy> > 1 =<< 2
17:50:15 <lambdabot>   No instances for (GHC.Num.Num (m b), GHC.Num.Num (m a))
17:50:15 <lambdabot>    arising from a u...
17:50:16 <shachaf> nejucomo: You don't need a tutorial!
17:50:26 <shachaf> The best way to understand State is to implement it yourself.
17:51:02 <nejucomo> shachaf: Yes, it depends on your style and motivation, I suppose.
17:52:23 <monochrom> the tutorial that walks you through defining your own state monad is likely http://www.engr.mun.ca/~theo/Misc/haskell_and_monads.htm
17:52:57 <nejucomo> monochrom: Yeah, that was the one.
17:59:16 <monochrom> the damage is done. gtk2hs is installed
18:06:34 <siplux> why does `interact $ unlines . lines` immediately return every keypress, but `interact $ unlines . filter ((<10) . length) . lines` wait until a newline? I realize its due to laziness, but how that is determine in that situation is confusing.
18:06:55 <Manifesto> @src reverse
18:06:55 <lambdabot> reverse = foldl (flip (:)) []
18:07:29 <Saizan> siplux: length forces the whole list before returning its result
18:09:43 <siplux> Saizan: that makes sense ... probably hard to get the length of an unknown 
18:10:43 <siplux> Saizan: but why wouldn't it just be a list of one character strings?
18:11:24 <Gracenotes> unlines is waiting for a String from filter. once it gets it, it'll pass it Char by Char to interact to print. now filter is reading a [String] from lines.. so when you start typing, it gets one of those Strings to either pass on or not. It's not a complete String, though: you can get the first few characters, but lines will only give you the end when it finds a \n.
18:11:46 <Gracenotes> because it's not a complete string, length can't give a result yet
18:12:49 <Gracenotes> (disclaimer: this is a bit informal/inexact)
18:13:11 <Saizan> btw, intercat is very peculiar in its mixing of I/O and evaluation
18:13:43 <Saizan> it's not a good example of either
18:13:51 <siplux> thanks - is there an actual internal difference between a "complete" and "incomplete" strings, or was that part of the informal/inexact - ness?
18:14:26 <shachaf> siplux: Why would you expect it *not* to wait until a newline?
18:15:01 <siplux> shachaf: because `interact $ unlines . lines` doesn't wait
18:15:13 <shachaf> siplux: Its behavior is correct. What you're asking is only for lines shorter than 10 characters to be echoed.
18:15:37 <shachaf> siplux: Until it gets to the newline, it doesn't know if the line is shorter than 10 characters. What if it echoed a character and then the line turned out to be too long?
18:16:02 <Gracenotes> @src lines
18:16:02 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
18:16:24 <siplux> shachaf: that's true. I stupidly didn't think about trying another test
18:16:29 <shachaf> siplux: Now, if you were asking about ((>10) . length), the question would be more interesting.
18:16:54 <shachaf> siplux: In that case it still waits until the newline before echoing.
18:17:22 <Gracenotes> siplux: incomplete/complete might be better explained in terms of normal form... do you know what a thunk is?
18:17:22 <shachaf> But if you use lazy naturals that would no longer be true.
18:18:14 <siplux> Gracenotes: informally I understand them as "promise" to a compiler that at point point a value will be returned
18:18:27 <siplux> s/point/some
18:19:03 <shachaf> Saizan: In what way is interact peculiar? How would you expect it to behave?
18:21:22 <Gracenotes> siplux: right, they are expressions that can give you values when you require them somehow
18:23:18 <siplux> I guess my confusion is how the test `<10` or `>10` is affecting when the input is "required" by interact?
18:24:11 <Philippa> because you only need the first 10 to answer it
18:24:15 <Gracenotes> the thing is figuring out when thunks are required to be evaluated: when the promise has to be fulfilled before your program can continue
18:25:58 <siplux> but I would expect a newline to either be necessary or unnecessary in both cases, rather than unnecessary in the first (<10) and necessary in second case (>10). 
18:26:17 <Gracenotes> in if a > 10 then .. else .. -- suppose you need to evaluate that. well, you need to find out whether a > 10 is True or False. To do that, you need to evaluate both a and 10. and so on.
18:27:16 <Gracenotes> the > function is strict, since both arguments need to be fully evaluated before it can give you True or False. Well, one of your arguments is (length str). That needs to give you the length of the line. Which it can only get once it has the full line.
18:27:54 <Gracenotes> in both (<10) and (>10) the newline is necessary
18:28:25 <Gracenotes> well, I should say that the > function is strict if you're dealing with comparing Ints.
18:28:45 <Gracenotes> shachaf was talking about a > which does *not* need to fully evaluate both of its arguments before giving you a result
18:28:46 <siplux> sorry, you're correct - I confused myself with the original comparison to `interact $ unlines . lines`
18:28:48 <shachaf> siplux: The only difference in the case of (>10) is that in theory you can start echoing chracters immediately after you see 10 characters.
18:29:30 <Gracenotes> but, in your code, that >/< is not that one that's used.
18:29:32 <shachaf> If you're using "length" and Ints, (<10) an (>10) will both wait for a newline, even though it's not *strictly* necessary for the latter case.
18:29:49 <cdsmithus> So I'm trying to use cabal with a custom preprocessor, and cabal sdist is complaining and won't look for the right file extension.
18:29:52 <shachaf> Gracenotes: The issue is more with the "length" that's used than the (>). :-)
18:30:27 <Gracenotes> shachaf: I think we're both right. there's something tao-ish here, when it's thunks all the way down :)
18:30:54 <siplux> shachaf: because theoretically, for example you can tell than [1] is < than [1..] ?
18:31:06 <Gracenotes> I think it's helpful to focus on Int's >, which requires (length str) to be fully evaluated. Natural's > might not require (length str) to be fully evaluated
18:31:18 <Gracenotes> > [1] < [1..]
18:31:18 <shachaf> siplux: There's no comparison of lists involved here.
18:31:19 <lambdabot>   True
18:31:25 <siplux> shachaf: sorry, bad example
18:31:44 <monochrom> the strictness of both (>) and length are necessary
18:31:50 <siplux> shachaf: I meant more than you can still do comparisons between lazy values, whereas with length it has to be evaluated?
18:31:54 <shachaf> siplux: You can tell that 2 is less than (...) + 5, where (...) is a natural number.
18:32:08 <shachaf> Gracenotes: This behaves correctly : interact $ unlines . filter ((>(10 :: Natural)) . genericLength) . lines
18:32:38 <Gracenotes> shachaf: yeah, as I'd expect.
18:33:41 <shachaf> For that matter, if you make an instance Num [a] where ... that behaves like lazy naturals, you don't even need the genericLength. :-)
18:34:23 <Gracenotes> siplux: there's a module, Data.Number.Natural, that has lazy numbers.. it's in the numbers package
18:35:21 <Gracenotes> if you use it instead of Int, then the behavior you get is that after typing in 10 characters, then you see all 10 characters get printed, and then it's one-for-one for the rest of the line
18:35:40 <siplux> why is that?
18:35:59 <shachaf> siplux: That's the most immediate possible correct behavior.
18:36:48 <Gracenotes> er, I mean, after typing 11 characters, since it requires (>10)
18:37:55 <siplux> I misread you, I thought you meant for the rest of the input
18:37:59 <siplux> that does make sense
18:38:10 <siplux> thanks
18:38:39 <luite> siplux: if you just want to see the behaviour without worrying about how those natural numbers work, you might try: filter (not.null.drop 10)
18:38:50 <Gracenotes> yeah, like 0123456789a0123456789abbccddee
18:39:57 <siplux> interesting
18:41:30 <siplux> thansk
18:41:32 <siplux> thanks
18:42:20 <Gracenotes> @src lines
18:42:21 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:42:37 <Gracenotes> hrm.. it's not so hard to implement though..
18:56:12 * hackagebot mvclient 0.2 - Client library for metaverse systems like Second Life  http://hackage.haskell.org/package/mvclient-0.2 (ChrisSmith)
18:56:15 <unkanon> can somebody give me an example on how to use @djinn with lambdabot?
18:56:23 <shachaf> @djinn a -> a
18:56:23 <lambdabot> f a = a
18:58:15 <djahandarie> @djinn a -> (s -> (a, s))
18:58:15 <lambdabot> f a b = (a, b)
18:58:27 <djahandarie> @djinn a -> State s a
18:58:27 <lambdabot> Error: Undefined type State
18:59:15 <djahandarie> @djinn a -> S s a
18:59:15 <lambdabot> Error: Undefined type S
18:59:19 <djahandarie> I swear it was in there
18:59:28 <djahandarie> @djinn-let type S s a = (s -> (a,s))
18:59:28 <lambdabot> Maybe you meant: djinn-del djinn-ver
18:59:35 <djahandarie> -_-
19:00:10 <djahandarie> @djinn-add S s a = (s -> (a,s))
19:00:10 <lambdabot> Cannot parse command
19:00:14 <djahandarie> @djinn-add type S s a = (s -> (a,s))
19:00:16 <djahandarie> Boom
19:00:21 <djahandarie> @djinn a -> S s a
19:00:21 <lambdabot> f a b = (a, b)
19:00:33 <djahandarie> @djinn-names
19:00:33 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool S
19:03:52 <Gracenotes> @djinn Either a b -> Maybe a
19:03:53 <lambdabot> f a =
19:03:53 <lambdabot>     case a of
19:03:53 <lambdabot>     Left b -> Just b
19:03:53 <lambdabot>     Right _ -> Nothing
19:03:56 <tomberek> what advantage does a zipper provide?
19:04:35 <djahandarie> @djinn ((((a, b) -> f) -> Either (a -> f) (b -> f)) -> f) -> f
19:04:35 <lambdabot> f a = a (\ b -> Left (\ c -> a (\ _ -> Right (\ d -> b (c, d)))))
19:04:38 <djahandarie> Hehe
19:05:01 <Gracenotes> tomberek: compared to..?
19:05:02 <unkanon> thanks guys :)
19:05:20 <djahandarie> CPS of demorgan's law btw ^^
19:06:32 <Gracenotes> hm I forget how negation works there..
19:06:34 <tomberek> Gracenotes: i read scrap your zippers and a few other papers about zippers, but it seems like they're just saying, "hey, look at this cool thing we can do"   I don't see the practical side yet
19:08:40 <tsbo> Is there a good tutorial on using attoparsec?
19:10:06 <wavewave> why my ghci cannot load a so file while ghc compilation is okay?
19:10:10 <Gracenotes> tomberek: I think the canonical useful example is xmonad?
19:11:28 <tomberek> Gracenotes: but why is using a zipper concept useful? is it more efficient? more modular? easier to write?
19:12:15 <shachaf> tomberek: Compared to what?
19:12:30 <tomberek> compared to not using a zipper
19:12:31 <djahandarie> tomberek, usually more efficient
19:12:37 <Gracenotes> tomberek: I've never had to use it consciously, except with a turing machine implementation.
19:12:45 <Gracenotes> BONUS I think has a motivating example here: http://learnyouahaskell.com/zippers
19:12:57 <onteria> wavewave:  this sounds like the linker bug
19:12:58 <cdsmithus> tomberek: Essentially, a zipper lets you have a purely functional data structure, but with a "current" position around which it's fast to do updates... the sort of thing for which you'd have otherwise wanted pointers and mutable data.
19:13:13 <wavewave> onteria: is it a bug?
19:13:24 <onteria> wavewave:  what so file is it trying to load?
19:13:26 <wavewave> Loading package HROOT-0.1.4 ... can't load .so/.DLL for: X3d (/home/wavewave/nfs/root/lib/libX3d.so: undefined symbol: _ZNK7TObject7DoErrorEiPKcS1_P13__va_list_tag)
19:13:37 <wavewave> error message is like this. 
19:13:48 <onteria> wavewave:  okay that's not the linker bug, that's something else
19:14:14 <wavewave> this is when I try to use this in ghci.
19:14:29 <tomberek> cdsmithus: so it's more than just an improvement in complexity by a constant?
19:15:04 <wavewave> I am now reading this ticket. http://hackage.haskell.org/trac/ghc/ticket/3333
19:15:09 <cdsmithus> tomberek: Again... compared to what?  Compared to keeping a traditional list and modiying the nth element many times in a row, yes, a zipper gives an asymptotic improvement
19:16:07 <wavewave> onteria: am my library using "weak symbol"? no clear.
19:16:13 <tomberek> cdsmithus: a zipper over a tree should obviously be compared to just using a tree
19:16:50 <tomberek> a zipper for a graph compared to just a graph, etc.
19:17:14 <shachaf> tomberek: Well, efficient, then. In a purely-functional context.
19:17:44 <onteria> wavewave:  not sure either on that one unfortunately
19:17:51 <cdsmithus> tomberek: So... I guess the answer is, yes, there are situations in which you could use a zipper, and gain an asymptotic improvement over naively modifying the stock data structure.  Normally, these correspond to situations where what you want is to make several consecutive changes around the same location in the data structure.
19:18:20 <tomberek> what about extensive changes in the entire structure?
19:18:51 <onteria> wavewave:  it looks as though if that's the resolution that it's milestoned for ghc-7.0.1. Unfortunately there are things that don't build yet with ghc7, so if you want to stay with ghc6, you'll have to figure out how to backport the fix
19:19:02 <onteria> wavewave:  or hope your distro backported it for you
19:19:05 <Philippa> depends how the extensive changes are implemented, amongst other things
19:19:21 <cdsmithus> tomberek: It depends very much on what your base point algorithm looks like.
19:19:33 <djahandarie> A zipper in a non-functional language could also provide a fast way to do certain mutable things (pointer reversal) in a immutable way.
19:19:55 <wavewave> onteria: ok. I see. I will look up ghc 7.0 changes. Thx
19:19:56 <tomberek> ok, and can you preserve fusion opportunities?
19:20:35 <ddarius> @google unfolding pointer algorithms
19:20:35 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.104.4178
19:20:45 <cdsmithus> tomberek: I think the questions you're asking are too specific for the level of context you've provided... hence the reluctance to give definite answers.
19:23:50 <luite> is template-haskell 2.4.0.1 incompatible with ghc 7? I get teh following error: "Something is amiss; requested module  template-haskell-2.4.0.1:Language.Haskell.TH differs from name found in the interface file template-haskell:Language.Haskell.TH"
19:23:54 <tomberek> cdsmithus: i know, i'm just trying to understand the advantage of using the zipper concept
19:25:46 <shachaf> tomberek: How's the xmonad example?
19:27:09 <tomberek> shachaf: not useful because I don't know HOW they used zippers and the reasoning... i'm just asking what sorts of situations would lead you to consider using a zipper and why?
19:28:04 <shachaf> tomberek: There's a list of workspaces, [1..n], one of which is "current".
19:28:11 <shachaf> You can move "forward" and "backward" in the list.
19:28:38 <Philippa> I don't think a zipper has to cost you all that much if you're doing a traditional 'complete traversal' algorithm
19:28:46 <Philippa> aside from a bit of code inconvenience
19:28:57 <Philippa> you can always, and easily, reconstitute the original structure from the zipper
19:29:12 <cdsmithus> tomberek: Imagine you have an algorithm specified in terms like "now go up one level, make this change, follow the left branch down two levels, then change that, and so on..." Okay, maybe you can understand the algorithm and implement it more functionally.... but if you can't, then a zipper lets you reasonably translate that into a purely functional implementation without asymptotic blowup in time.
19:29:55 <shachaf> One way to do this is to store an index into the list, but then you have O(n) forward and backward. Instead of that, they store a (Zipper previousWorkpaces thisWorkspace nextWorkspaces) (where previousWorkspaces is reversed).
19:30:14 <tomberek> cdsmithus: so what about something classic like a breadth first search?
19:30:30 <cdsmithus> tomberek: Or, as in the xmonad case, perhaps the reason you can't is that the individual commands like "okay, now go over there, now change that" come interactively from a user.  Then you *need* something like a zipper
19:30:55 <cdsmithus> tomberek: I think there are good functional techniques for implementing breadth first search, so using a zipper for it would IMO be overkill
19:36:12 <cdsmithus> tomberek: So yeah, zippers aren't meant to replace ordinary functional programming.  They are meant for use in places where something about the structure of the problem makes you wish for something like pointer traversal and mutation through a pointer... and yet you also want to program functionally (persistent data structures and such).
19:36:23 <monochrom> the lazy cat is lazy. :)
19:39:55 <to_On1> Hi all, I have a problem with the following function  
19:40:33 <to_On1> zipWith (/) left rigth 
19:40:59 <to_On1> when I compile my function, I get the following error.
19:41:54 <to_On1>  No instance for (Fractional Int)
19:41:56 <to_On1>       arising from a use of `/' at Primal.hs:31:45-47
19:41:57 <ivanm> > zipWith (/) [1..5] [2,4..10]
19:41:58 <lambdabot>   [0.5,0.5,0.5,0.5,0.5]
19:41:58 <to_On1>     Possible fix: add an instance declaration for (Fractional Int)
19:42:00 <to_On1>     In the first argument of `zipWith', namely `(/)'
19:42:02 <to_On1>     In the expression: zipWith (/) left rigth
19:42:04 <to_On1>     In the definition of `pivot': pivot = zipWith (/) left rigth
19:42:09 <ivanm> to_On1: are you wanting them to be Int values, or Doubles?
19:42:18 <cdsmithus> to_On1: left and right need to be Fractional types, since you're going to divide them.
19:42:23 <monochrom> you can't use (/) for Int
19:42:37 <ivanm> zipWith (\l r -> fromIntegral l / fromIntegral r)
19:42:43 <ivanm> @pl (\l r -> fromIntegral l / fromIntegral r)
19:42:44 <lambdabot> (. fromIntegral) . (/) . fromIntegral
19:42:50 <cdsmithus> to_On1: Perhaps you meant div?  Or what ivanm said
19:42:53 <ivanm> yeah, the lambda expression is nicer
19:43:01 <ivanm> or `div`
19:43:22 <ivanm> wait, no need to make it infix
19:43:44 <monochrom> > (`div`) 5 4
19:43:45 <lambdabot>   <no location info>: parse error on input `)'
19:43:50 <cdsmithus> to_On1: So div will do integer division (result will be an integer, discarding the remainder).  On the other hand, with ivanm's answer, the result will be a list of some Fractional type, not of Int 
19:43:51 <orlandu63> @type liftM2 (/) fromIntegral
19:43:52 <lambdabot> forall a1 a. (Fractional a1, Integral a) => (a -> a1) -> a -> a1
19:43:53 <monochrom> is broken :)
19:45:15 <enthropy> @type (/) `on` fromIntegral
19:45:16 <lambdabot> forall b a. (Fractional b, Integral a) => a -> a -> b
19:45:32 <cdsmithus> enthropy: Nice! :)
19:46:14 <Gracenotes> @type join (liftM2 (/)) fromIntegral
19:46:15 <lambdabot> forall a1 a. (Fractional a1, Integral a) => a -> a1
19:46:36 <ivanm> @type liftM3 (/) fromIntegral fromIntegral
19:46:37 <lambdabot> forall a3 r a. (Fractional r, Integral a) => (a -> a3) -> a -> r
19:46:45 <Gracenotes> would surely be 1 or NaN
19:46:52 <ivanm> OK, that failed ;-)
19:47:06 <orlandu63> > liftM2 (/) fromIntegral 1 2
19:47:07 <lambdabot>   2.0
19:47:14 <orlandu63> oh :(
19:47:18 <cdsmithus> I wonder if we scared to_On1 away
19:47:23 <Gracenotes> oh that's scary
19:48:05 <Gracenotes> the Num function instance
19:48:28 <ivanm> what instance?
19:48:45 <Gracenotes> > liftM2 (/) fromIntegral (const 1) 2
19:48:46 <lambdabot>   2.0
19:49:07 <ivanm> oh, right, it used a function instance
19:49:11 <cdsmithus> There's a Num instance for functions?
19:49:13 <ivanm> I was looking for one in a type sig ;-)
19:49:23 <ivanm> @type (1 :: (a -> b))
19:49:24 <cdsmithus> > let f x = 2 * x in (f + f) 1
19:49:25 <lambdabot>     Could not deduce (Num b) from the context ()
19:49:25 <lambdabot>       arising from the literal `1' at <interactive>:1:1
19:49:25 <lambdabot>     Possible fix:
19:49:25 <lambdabot>   4
19:49:28 <ivanm> bah
19:49:42 <cdsmithus> Cool
19:52:18 <to_On1> this is my original function is not finished yet but when I compile I get this error that I showed
19:52:31 <to_On1> solprimal :: [Int] -> [[Int]] -> [Int]
19:52:33 <to_On1> solprimal der matriz = let mencero = menor (head matriz) 0 (0,0) --(menor,posicion)
19:52:35 <to_On1>                            columna = map (\x -> x !! (snd mencero)) (tail matriz) --[1,2]
19:52:37 <to_On1>                            pivot   = zipWith (/) der columna
19:52:39 <to_On1>                        in 
19:52:41 <to_On1>                          columna
19:53:14 <to_On1> I I need pivot is a list of float
19:53:21 <cdsmithus> to_On1: Since you don't seem to want any floats even in the result... perhaps you meant div instead of (/)
19:55:55 <cdsmithus> Anyone have a guess how much work is involved with making haxr work with Michael Snoyman's http-enumerator so that XML-RPC works over SSL?
20:00:31 <ddarius> It took some experimentation and some chicanery, but I've managed to get it so I can run my (actual) Windows install usefully in a VM.
20:10:11 <cole> When I install haskell on ubuntu linux, where does the prelude go?
20:11:01 <mauke> what do you mean by "haskell"?
20:14:22 <enthropy> it's part of it
20:15:14 <to_On1> thank you all for your help, I solve it this way 
20:15:19 <to_On1> zipWith (/) (map fromIntegral left) (map fromIntegral rigth)
20:15:37 <mauke> .oO( rigth? how is babby formed? )
20:29:21 <applicative> cole, do you have the ghc installed?
20:30:24 <monochrom> yes
20:31:08 <applicative> you're not cole!
20:31:41 <monochrom> but I remember he/her confirming using ghc
20:32:14 <applicative> cole, if you do then one of the ghc-pkg incantations might tell you what you want, e.g. ghc-pkg describe prelude  
20:32:21 <cole> Yes, I have ghc installed
20:32:50 <applicative> sorry, i meant "ghc-pkg describe base"
20:35:58 <cole> Okay, so I entered that command and it told me that it's in /usr/lib/ghc.../base. I found a ghc.hi file. Are the source files also be default installed?
20:36:27 <monochrom> no
20:36:50 <cole> Is there an easy way to download the base sources?
20:36:53 <applicative> I have haddocked html
20:38:01 <applicative> in the directory just above the one you mention
20:39:13 <applicative> http://darcs.haskell.org/packages/base/ 
20:40:26 <cole> Thanks.
20:40:27 <applicative> Prelude.hs just exports a bunch of things from other modules in that directory, e.g. System.IO, Control.Monad, etc
20:40:58 <cole> So, haskell is organized in "modules" do modules correspond directly to files, or are they more general than that?
20:41:17 <applicative> I think that right, they're files. 
20:41:20 <cole> Can a single module (say System.IO) correspond to several different .hs files?
20:41:41 <applicative> Its not like fancy module systems, but I don't know others
20:42:05 <applicative> a single module can import many modules and then export them
20:42:27 <applicative> so a single module might be the one that sums up a library full of definitions
20:43:25 <applicative> Prelude.hs is ugly because of all the C-preprocessor nonsense. I wonder what a good illustration would be
20:44:28 <applicative> But if you look at the top it starts module Prelude (....many lines here ....) where import X ; import Y 
20:45:14 <applicative> the many lines name the functions it exports, getting them from module X (= X.hs, basically) and so forth
20:45:49 <monochrom> Data.Maybe is a reasonable example
20:45:53 <applicative> one can also do module ManyModules (module Jones, module Smith) where import module Jones ; import module Smith.
20:48:52 <tsbo> mai
20:48:54 <unkanon> can I make @djinn give me another different definition for the same type?
20:49:01 <djahandarie> Yes
20:49:06 <djahandarie> @djinn-more
20:49:06 <lambdabot> Unknown command, try @list
20:49:08 <djahandarie> Hmm
20:49:35 <djahandarie> Maybe not
20:49:44 <djahandarie> You can make the actual djinn do it though
20:49:51 <unkanon> I want to give djinn this: a -> a -> Bool, and get this: f x y = x == y
20:50:08 <djahandarie> @djinn x -> y -> Bool
20:50:09 <lambdabot> f _ _ = False
20:50:09 <unkanon> would my example work with the actual djinn?
20:50:13 <djahandarie> It doesn't know about Bool
20:50:18 <unkanon> yeah it does
20:50:24 <unkanon> it doesn't know about [] though
20:50:32 <djahandarie> Well
20:50:33 <unkanon> @djinn-names
20:50:34 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool S
20:50:35 <djahandarie> It doesn't know about Eq
20:50:37 <unkanon> there's bool right there
20:50:38 <djahandarie> Hmm
20:50:41 <unkanon> eq too
20:50:59 <djahandarie> It attempts to use all variables first, so it should have given you x == y if it could have
20:51:09 <djahandarie> It's odd that it claims to know Eq, I wonder how it is defined
20:51:12 <magicman> @djinn Eq a => a -> a -> Bool
20:51:13 <lambdabot> f = (==)
20:51:17 <djahandarie> Oh
20:51:18 <djahandarie> Ha
20:51:29 <unkanon> wow!
20:51:40 * djahandarie hits self for not noticing that
20:51:49 <unkanon> that's beautiful
20:52:04 <unkanon> @djinn Eq a => (a,a) -> Bool
20:52:05 <lambdabot> f (a, b) = a == b
20:52:09 <unkanon> wow!
20:52:13 <lars9> is djahandarie author of djinn?
20:52:17 <djahandarie> Nah
20:52:22 <unkanon> thanks, djahandarie
20:52:23 <djahandarie> Not close ;)
20:52:27 <djahandarie> Thank magicman :P
20:52:39 <unkanon> is he the author?
20:52:43 <djahandarie> No lol
20:53:06 <unkanon> do you know if the actual djinn supports [] ?
20:53:12 <djahandarie> It doesn't.
20:53:16 <mauke> too recursive
20:53:21 <unkanon> aw :/
20:53:40 <djahandarie> I think it may have at one point or something odd like that
20:53:52 <monochrom> adding some boyer-moore induction thing may enable it to do []
20:54:02 <unkanon> if I really need [] though, would Coq help?
20:54:08 <djahandarie> I've been meaning to ask augustuss about this for awhile but he hasn't been around
20:54:22 <djahandarie> augustss*
20:54:36 <mauke> preflex: seen augustss
20:54:36 <preflex>  augustss was last seen on #haskell 25 days, 12 hours, 1 minute and 41 seconds ago, saying: ddarius: and by induction, all finite numbers are nothing?
20:55:19 <djahandarie> He has posted on reddit so he isn't dead :P
20:55:28 <djahandarie> Too busy for IRC I guess
20:56:24 <unkanon> @djinn Ord a => (a,a) -> Bool
20:56:25 <lambdabot> Error: Class not found: Ord
20:57:05 <unkanon> hm, I guess it won't derive (>) then
20:58:00 <mauke> @djinn Ord a => (a,a) -> Bool
20:58:00 <lambdabot> f _ = False
20:58:23 <mauke> @djinn Ord a => (Ordering -> Bool) -> (a,a) -> Bool
20:58:23 <lambdabot> Error: Undefined type Ordering
20:58:41 <djahandarie> Are you defining stuff mauke? :P
20:58:43 <djahandarie> @djinn-names
20:58:44 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Monad Eq Bool Ordering LT EQ GT S Ord Ordering
20:58:45 <mauke> @djinn Ord a => (Ordering -> Bool) -> (a,a) -> Bool
20:58:46 <lambdabot> f a =
20:58:46 <lambdabot>     case a LT of
20:58:46 <lambdabot>     False -> \ _ -> False
20:58:46 <lambdabot>     True -> case a EQ of
20:58:46 <lambdabot>             False -> \ _ -> False
20:58:48 <lambdabot>             True -> case a GT of
20:58:50 <lambdabot>                     False -> \ (b, _) ->
20:58:52 <lambdabot>                              case compare b b of
20:58:54 <lambdabot>                              LT -> False
20:58:56 <lambdabot>                              EQ -> False
20:58:58 <lambdabot>                              GT -> True
20:59:00 <lambdabot>                     True -> \ (c, d) ->
20:59:02 <lambdabot> Plugin `djinn' failed with: thread killed
20:59:03 <djahandarie> There should probably be a cap on that...
20:59:07 <djahandarie> Spoke to soon
20:59:40 <mauke> @djinn Ord a => (a,a) -> Ordering
20:59:41 <lambdabot> f (a, _) = compare a a
20:59:56 <djahandarie> ...
21:00:00 <mauke> I feel like djinn is trolling me
21:00:07 <djahandarie> That looks like a bug to me
21:02:04 <unkanon> mauke: I would have loved to have seen how you did that :)
21:02:20 <unkanon> even if it didn't come out right :P
21:02:58 <mauke> -- @djinn-add data Ordering = LT | EQ | GT
21:03:09 <mauke> -- @djinn-add class Ord a where compare :: a -> a -> Ordering
21:04:51 <djahandarie> Found the problem
21:05:12 <djahandarie> It's a problem with it not being good enough with the typeclass constraint in the function type
21:05:28 <djahandarie> @djinn (Ord a, Ord b) => (a,b) -> Ordering
21:05:28 <lambdabot> f (a, b) =
21:05:28 <lambdabot>     case compare a a of
21:05:28 <lambdabot>     LT -> compare b b
21:05:28 <lambdabot>     EQ -> compare b b
21:05:28 <lambdabot>     GT -> LT
21:05:38 <djahandarie> Heh
21:06:02 <unkanon> I don't fully understand that
21:06:06 <unkanon> that twists my brain a little
21:06:16 <unkanon> is that even right?
21:06:20 <djahandarie> No.
21:06:27 <unkanon> GT -> LT didn't look right, yeah :)
21:06:36 <mauke> looks right to me
21:07:17 <djahandarie> Ah
21:07:22 <djahandarie> You're right, just a lot of junk flying around
21:07:31 <djahandarie> Wait
21:07:31 <djahandarie> No
21:07:33 <djahandarie> You're wrong
21:07:33 <djahandarie> lol
21:07:40 <djahandarie> That'd always return EQ
21:08:21 <djahandarie> Seems like it just comes down to shitty typeclass support
21:08:38 <mauke> > let x = 0/0 in compare x x
21:08:39 <lambdabot>   GT
21:08:46 <djahandarie> -_-
21:08:51 <mauke> FUCK YOUR INVARIANTS
21:12:56 <unkanon> how does "compare a a" make any sense?
21:13:00 <unkanon> it can only be EQ,no?
21:13:10 <ddarius> Someone wasn't reading.
21:17:28 <luite> @djinn (Ord a, Ord b) => (a,b) -> (a,b) -> Ordering
21:17:28 <lambdabot> f (a, b) =
21:17:28 <lambdabot>     \ _ ->
21:17:28 <lambdabot>     case compare a a of
21:17:29 <lambdabot>     LT -> LT
21:17:29 <lambdabot>     EQ -> LT
21:17:30 <lambdabot>     GT -> case compare b b of
21:17:32 <lambdabot>           LT -> LT
21:17:34 <lambdabot>           EQ -> LT
21:17:36 <lambdabot>           GT -> EQ
21:17:55 <luite> :(
21:17:55 <kmc> it's a party in here
21:18:35 <dankna> what is @djinn?
21:18:41 <djahandarie> Wow, that function is just totally wrong
21:18:54 <mauke> dankna: generates code from types
21:18:54 <shachaf> djahandarie: It's not wrong.
21:19:00 <djahandarie> Oops, missed the lambda, nevermind
21:19:26 <mauke> dankna: it's actually a theorem prover, but ... same thing
21:19:32 <applicative> danka, for a type, it tries to derive a value
21:19:59 <luite> unfortunately not always an interesting one :)
21:20:03 <applicative> which works if the type is sufficiently abstract, like (a,b) -> (b,a)
21:20:04 <djahandarie> Anyways, if it supported typeclasses better it would be able to get f (a, b) = compare a b
21:20:21 <djahandarie> luite, it should always be able to get the interesting one if you have all the types loaded in and you don't have any recursive types
21:20:33 <djahandarie> Might require searching till infinity though
21:20:34 <shachaf> @djinn Ordering
21:20:34 <lambdabot> f = LT
21:21:21 <shachaf> @djinn (Ord a) => a -> a -> Ordering
21:21:22 <lambdabot> f = compare
21:21:24 <shachaf> @djinn (Ord a) => (a,a) -> Ordering
21:21:25 <lambdabot> f (a, _) = compare a a
21:21:32 <djahandarie> Talking more about theorem provers than djinn at this point though, since it'll stop after awhile
21:21:59 <djahandarie> Seems to be some odd problem with typeclass mixed with tuples lol
21:22:06 <mauke> @djinn Char -> Char -> Bool
21:22:07 <lambdabot> Error: Undefined type Char
21:22:12 <mauke> @djinn Int -> Int -> Bool
21:22:12 <lambdabot> Error: Undefined type Int
21:22:15 <mauke> :-(
21:22:32 <shachaf> @djinn (a -> b -> Ordering) -> (a,b) -> Ordering
21:22:33 <lambdabot> f a (b, c) = a b c
21:22:37 <shachaf> @djinn (a -> a -> Ordering) -> (a,a) -> Ordering
21:22:38 <lambdabot> f a (b, _) = a b b
21:23:00 <mauke> @djinn ()
21:23:00 <lambdabot> f = ()
21:23:06 <djahandarie> Once it uses the type variable in the tuple once it gives up for the second time?
21:23:12 <mauke> @djinn Maybe () -> Maybe () -> Bool
21:23:12 <lambdabot> f a b =
21:23:12 <lambdabot>     case a of
21:23:12 <lambdabot>     Nothing -> False
21:23:12 <lambdabot>     Just _ -> case b of
21:23:12 <lambdabot>               Nothing -> False
21:23:14 <lambdabot>               Just _ -> True
21:23:36 <luite> whoah
21:23:44 <luite> why did it generate that :)
21:23:58 <djahandarie> Why not?
21:24:09 <kmc> because it would be easier to say "f a b = False"
21:24:25 <djahandarie> That would be ignoring a and b
21:24:25 <kmc> maybe it has some mandate to use all inputs when possible
21:24:28 <djahandarie> It does.
21:24:45 <kmc> djahandarie, right, you're allowed to ignore antecedents in proofs generally
21:24:52 <shachaf> djahandarie: Well, clearly not completely.
21:25:04 <MtnViewMark> If it gave answers like that, we wouldn't use it, and it would get lonley
21:25:06 <djahandarie> shachaf, it doesn't even list the correct answer ever
21:25:13 <djahandarie> shachaf, so there is some sort of bug
21:25:38 <shachaf> @djinn (Bool,Bool) -> Bool
21:25:39 <lambdabot> f (a, b) =
21:25:39 <lambdabot>     case a of
21:25:39 <lambdabot>     False -> b
21:25:39 <lambdabot>     True -> False
21:25:44 <shachaf> @djinn Bool -> Bool -> Bool
21:25:45 <lambdabot> f a b =
21:25:45 <lambdabot>     case a of
21:25:45 <lambdabot>     False -> b
21:25:46 <applicative> @type f a b = case a of Nothing -> False; Just _ -> case b of Nothing -> False; Just _ -> True
21:25:48 <lambdabot>     True -> False
21:25:49 <lambdabot> parse error on input `='
21:25:57 <applicative> hmmm
21:26:17 <applicative> @typecase a of Nothing -> False; Just _ -> case b of Nothing -> False; Just _ -> True
21:26:17 <lambdabot> Unknown command, try @list
21:26:21 <applicative> @type case a of Nothing -> False; Just _ -> case b of Nothing -> False; Just _ -> True
21:26:22 <lambdabot>     Couldn't match expected type `Expr' against inferred type `Maybe a'
21:26:22 <lambdabot>     In the pattern: Nothing
21:26:22 <lambdabot>     In a case alternative: Nothing -> False
21:26:23 <shachaf> @djinn (a -> Bool) -> (b -> Bool) -> a -> b -> Bool
21:26:24 <lambdabot> f a b c d =
21:26:24 <lambdabot>     case a c of
21:26:24 <lambdabot>     False -> b d
21:26:26 <lambdabot>     True -> False
21:26:32 <applicative> man, pardon spam
21:26:37 <shachaf> @djinn (a -> Bool) -> (b -> Bool) -> (a,b) -> Bool
21:26:37 <lambdabot> f a b (c, d) =
21:26:38 <lambdabot>     case a c of
21:26:38 <lambdabot>     False -> b d
21:26:38 <lambdabot>     True -> False
21:26:42 * shachaf should probably stop it too.
21:26:52 <djahandarie> Yeah it's going djamnn crazy in here!
21:27:05 <unkanon> sorry I still don't get it, was "compare a a" good code?
21:27:15 <mauke> what do you mean by "good code"?
21:27:17 <applicative> djinn madness, which overtakes the valley in long dry seasons ...
21:27:20 <djahandarie> unkanon, no, there is a bug, so it couldn't find "compare a b"
21:27:24 <shachaf> unkanon: As far as @djinn is concerned, code is good if it's total and has the type that you asked for.
21:27:58 <djahandarie> unkanon, the function it gave satisfied the type, but it's not "right" in the sense of "the one that is in Prelude" ;)
21:28:07 <monochrom> hahaha ghci is evil. needs two sigterm's to quit
21:28:24 <djahandarie> unkanon, cabal install djinn,   then run "djinn", then ":set +m",  then "f ? someTypeHere"
21:28:36 <djahandarie> That should make it slightly clearer what it does
21:29:39 <shachaf> Is there a way to make GHC use readline?
21:29:50 * applicative notices djinn wants editline and senses cabal install catastrophe
21:30:03 <mauke> shachaf: there's a patch for 6.10.2
21:30:24 <djahandarie> Yeah, you'll probably need to grab editline from your distro if you don't have it
21:30:42 <applicative> unkanon, haha, notice also the 'caveat emptor' when it starts.
21:31:03 <ddarius> "emptor" seems inappropriate.
21:31:41 <unkanon> djahandarie: ok, thanks :)
21:32:12 <unkanon> djahandarie: I will do that tomorrow because it's late now :)
21:32:14 * monochrom is even more evil. writes a gtk2hs program such that if you close a window, the program doesn't quit, instead waits 4 seconds and re-opens the window! ad infinitum. your window comes back to haunt you bwhahahahaha
21:32:39 <applicative> lennart augustsson is a wonder.
21:33:03 <shachaf> monochrom: It should wait a random interval before reopening.
21:33:18 <monochrom> hehe
21:34:00 * applicative doesn't call the 'closing a window'
21:34:13 <cole> Does it shound pedantic when someone says the "inductive" case rather than the "recursive" case?
21:34:18 * applicative doesn't call that 'closing a window'
21:35:02 <shachaf> cole: If you're talking about induction, no.
21:35:43 <djahandarie> If you're posting this on proggit, yes
21:36:06 * ivanm suspects he needs to try actually implenting his algorithm on paper before writing any more code
21:36:49 <unkanon> ddarius: caveat usor? utor? I don't remember now
21:37:31 <applicative> cole, proofs are by induction, deduction, abduction, 
21:37:49 <applicative> definitions of terms are recursive or not
21:38:14 * applicative thinks: hows that for simple minded?
21:38:15 <krey_> is it just me, or is the "visitor pattern" (OOP) basically a fold?
21:38:50 <kmc> or a roundabout way to write pattern-matching
21:40:00 <shachaf> krey_: Is <http://en.wikipedia.org/wiki/Visitor_pattern#Source> an example of the "visitor pattern"?
21:40:01 <krey_> kmc: yes! it's kinda strange trying to learn these oop design patterns having a functional perspective...
21:40:35 <kmc> krey_, many "design patterns" are just standard boilerplate workarounds for Java or C++ flaws
21:40:45 <kmc> so they're strange not only in functional languages but in any decent language
21:40:46 <krey_> shachaf: yeah, I think so
21:40:47 <applicative> man, look at the unholy 'code' examples on that page.  can there be any truth found ther?
21:40:49 <unkanon> I can't stand the boilerplate of OO code
21:40:56 <shachaf> krey_: Why is that a fold?
21:41:05 <kmc> unkanon, Java and C++ are not good OO languages
21:41:05 <ivanm> unkanon: s/the boilerplate of// :p
21:41:13 <monochrom> indeed even multiple-dispatch OO (like CLOS) doesn't need visitor.
21:41:17 <krey_> shachaf: looks like a fold to me
21:41:21 <kmc> a good language for OOP is of course a functional language too
21:41:31 <kmc> when i do OOP in Python or Haskell it's worlds more pleasant than C++ or Java
21:41:34 <shachaf> krey_: What is it folding into?
21:41:54 <krey_> shachaf: I guess it could do with some generics
21:42:02 <kmc> C++ and Java are the strawmen of any statement about programming languages
21:42:04 <krey_> shachaf: "void" atm
21:42:12 <unkanon> kmc: agreed :)
21:42:13 <kmc> "static types suck because Java sucks"
21:42:17 <kmc> "OOP sucks because Java sucks"
21:42:18 <kmc> etc
21:42:20 <unkanon> ivanm: and agreed!
21:42:28 * applicative thinks, its folding into hell
21:42:33 <unkanon> gotta go to sleep now, wife is mad :P
21:42:57 <monochrom> "not tonight dear, I've got visitor"
21:43:06 <ivanm> lol
21:43:13 <krey_> monochrom: aren't visitors for emulating double dispatch?
21:44:08 <djahandarie> I wonder how many people just googled double dispatch
21:45:50 * ivanm didn't
21:46:12 <kmc> in the Haskell community, "OOP sucks because Java sucks" is widely believed and repeated even as "static types suck because Java sucks" is recognized as bogus
21:46:43 <kmc> because our favorite horse has static typing but not special features for OOP
21:47:36 <shachaf> kmc: Do people here disparage OOP that much?
21:47:38 <applicative> > let visitWith = foldr in visitWith (+) 0 [1,2,3]
21:47:39 <lambdabot>   6
21:48:07 <applicative> > let visitWith = foldr in visitWith (*) 0 [1,2,3]
21:48:08 <lambdabot>   0
21:49:57 <djahandarie> > let visitWith = foldr; f = visitWith mappend mempty in f [1,2,3]
21:49:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
21:49:58 <lambdabot>    `GHC.Num.Num a'
21:49:58 <lambdabot>      ari...
21:50:00 <shachaf> > let visitWith = mapM_ in execWriter $ visitWith tell ["a","b","c"]
21:50:01 <kmc> shachaf, yes
21:50:01 <lambdabot>   "abc"
21:50:26 <djahandarie> > let visitWith = foldr; f = visitWith mappend mempty in f [1,2,3] :: Integer
21:50:27 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Integer.Internals.Integer)
21:50:27 <lambdabot>    arisi...
21:50:50 <shachaf> kmc: I don't see many people here saying that e.g. OCaml is bad.
21:50:51 <djahandarie> Oh
21:50:53 <applicative> the wikipedia article is almost 100% OO jargon, it's amazing. 
21:51:01 <applicative> OCaml is bad.
21:51:08 * applicative didn't mean it
21:51:15 <shachaf> applicative: Which Wikipedia article?
21:51:15 <djahandarie> > let visitWith = foldr; f = visitWith mappend mempty in getProduct f [1,2,3] :: Integer
21:51:16 <lambdabot>   Couldn't match expected type `Data.Monoid.Product a'
21:51:16 <lambdabot>         against inferr...
21:51:18 <djahandarie> Gah
21:51:29 <applicative> shacaf, visitor pattern
21:51:54 <shachaf> applicative: "In object-oriented programming and software engineering, the visitor design pattern is a way of separating an algorithm from an object structure it operates on."
21:52:02 <shachaf> What would you expect?
21:52:37 <cole> For those who are using linux, what distro are you using?
21:52:43 <monochrom> ubuntu
21:54:00 <krey_> arch
21:55:13 <applicative> according to the wikipedia article shows the problem of pretty printing really shows the strength of the visitor pattern
22:02:24 <kmc> shachaf, right.  my point is that they *don't* talk about languages
22:02:35 <kmc> they talk about OOP in general but ignore non-shitty OOP languages
22:03:25 <jyper> ubuntu
22:03:27 <shachaf> kmc: You are talking about people in general but ignoring non-generalizing people. :-)
22:04:00 <kmc> ;)
22:04:02 <shachaf> Maybe I just haven't seen that much of it.
22:05:06 <kmc> shrug
22:05:08 <kmc> back later
22:11:53 <revenantphx> Haskell at 1AM.
22:11:56 <revenantphx> How refreshing.
22:13:47 <revenantphx> So, I'm trying to figure this out...
22:13:59 <revenantphx> I have a bunch of cells with ants on them, however unlike most ant behavior models,
22:14:05 <revenantphx> I can have multiple ants on each cell.
22:14:13 <revenantphx> So a type of Maybe [Ant] seemed like a nice idea.
22:14:28 <revenantphx> Or just Ant[] would be fine.
22:14:37 <mauke> []Ant
22:15:02 <revenantphx> ?
22:15:35 <kadoban> revenantphx: Ant[] would be C++ or something :)   [] or [Ant] is haskell
22:15:46 <revenantphx> yeah, sorry :P
22:15:51 <revenantphx> I said [Ant] earlier.
22:15:52 <revenantphx> anyways
22:15:54 <mauke> > "foo" :: []Char
22:15:55 <lambdabot>   "foo"
22:16:04 <revenantphx> the only issue is, if I go through each cell and move all the ants on it
22:16:13 <kadoban> i could have sworn i typed Ant after that first []...wonder if my client messed with it..woops
22:16:16 <revenantphx> Then most ant's will get repeats.
22:16:23 <revenantphx> Which I don't want.
22:16:31 <revenantphx> The other option is iterating through each ant.
22:16:42 <applicative> > [()] : []()
22:16:43 <lambdabot>   Couldn't match expected type `() -> [[()]]'
22:16:43 <lambdabot>         against inferred type `...
22:16:45 <revenantphx> I cannot make each ant act on its own in a separate thread.
22:16:55 <revenantphx> :t []Int
22:16:56 <lambdabot> Not in scope: data constructor `Int'
22:17:11 <mauke> > [()]::[]()
22:17:12 <lambdabot>   [()]
22:17:22 <applicative> thank you
22:17:24 <mauke> > ([()])::([])()
22:17:25 <lambdabot>   [()]
22:17:36 <revenantphx> Okay that's enough now :P
22:17:41 <revenantphx> anyways, do you have a suggestion?
22:17:43 <mauke> om nom nom
22:17:58 <revenantphx> I mean, the logical thing is "iterate through by ants instead"
22:18:11 <ddarius> You could try an anti-objects approach and have each cell be the active player.
22:18:12 <applicative> revenantphx you want folks to go back to @djinn?
22:18:24 <revenantphx> applicative: what
22:18:28 <revenantphx> ddarius: ?...
22:18:39 <revenantphx> I just need this to work in a very C like, step by step way.
22:18:49 <revenantphx> I can't have all the ants workign simultaneously and so on.
22:20:15 <applicative> > [[()]] :: []([]()) -- spam alert
22:20:16 <lambdabot>   [[()]]
22:20:52 <revenantphx> > putStr "I am revenantphx's bitch"
22:20:52 <lambdabot>   <IO ()>
22:20:56 <revenantphx> fuck you.
22:21:05 <revenantphx> >_>
22:21:22 <revenantphx> so ddarius any idea?
22:24:01 <ClaudiusMaximus> data Ant = Ant{ location :: (Int, Int), ... } ; type Landscape = Array (Int, Int) Smell ; updateEverything :: [Ant] -> Landscape -> ([Ant], Landscape) -- would something like this work?
22:24:34 <nejucomo> Can I constrict an existential type variable by class?
22:25:03 <revenantphx> ClaudiusMaximus: well yes, I suppose
22:25:18 <revenantphx> but it'd be nice to make it so I don't have run two iterations with each time step.
22:25:41 <revenantphx> Hm, one idea
22:26:07 <revenantphx> I could just not write the ants to mutable storage until all of them are processed.
22:26:26 <nejucomo> Sweet.  Apparently this works.
22:26:29 <revenantphx> I get the feeling I should use ST, not STM here XD
22:26:36 <revenantphx> Since I'm not really doing any concurrency.
22:27:14 * nejucomo is reading "Libraries for Generic Programming in Haskell" from: http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-025.pdf
22:27:27 <revenantphx> :t forM_
22:27:28 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
22:27:35 <ClaudiusMaximus> yeah, that's what i'm thinking too - updateEverything would do one pass over the [Ant] and accumulate a collection of differences to the Landscape, then a second pass to give a new Landscape - otherwise you'll get weird errors where different Ant sees different Landscape at same timestep
22:27:57 <revenantphx> Yeah, basically what I'm thinking is:
22:28:08 <revenantphx> 1) All ants movements are staged
22:28:22 <revenantphx> 2) World is updated with decayed pheromone
22:28:27 <revenantphx> 3) Ant movements are commited.
22:28:34 <revenantphx> However, the issue is ant pheromone deposit.
22:28:49 <dankna> is this the old ICFPC problem?
22:28:55 * dankna just wandered in
22:29:13 * ManateeLazyCat Downloading Cinelerra....
22:30:14 <revenantphx> dankna: what no.
22:30:16 <ClaudiusMaximus> i think i need to add a progress bar to my app, so far it's been running for 90mins and i have no idea how much longer it'll take...
22:30:24 <revenantphx> This is me rewriting my simulation in haskell for fun.
22:30:40 <revenantphx> See, this is where pointers are nice.
22:30:53 <revenantphx> Each Ant (in C) can point to it's position in the World.
22:31:03 <revenantphx> And since the World is constructed as a linked list, it's easy.
22:31:19 <revenantphx> However, I have to run through a second pass to decay pheromone, which I dont like.
22:31:44 <ClaudiusMaximus> why don't you like it?
22:31:55 <dankna> revenantphx, oh.  there was one very like this about four years ago.  it was cool.
22:32:36 <revenantphx> Oh I see.
22:32:59 <revenantphx> Yeah I have this running in C, wanted to see if could write it a bit more succinctly in Haskell.
22:33:07 <dankna> nodnod
22:33:13 <revenantphx> The C version isn't that bad, just has a LOT of setup code to construct the linked list :P
22:33:16 <dankna> gotcha
22:33:22 <ClaudiusMaximus> you can do mutable linked worlds in Haskell, much like C (with IORef etc)
22:33:41 <revenantphx> I'd prefer to take a more Haskelly approach
22:33:46 <revenantphx> rather than try to emulate the C version
22:34:07 <revenantphx> this is the C code
22:34:07 <revenantphx> https://gist.github.com/716352
22:34:30 <revenantphx> It's heavily commented, so don't worry.
22:34:57 <revenantphx> The file output is for gnuplot.
22:35:04 <dankna> neato
22:35:12 <revenantphx> I'm surprised it's under 200 lines.
22:35:18 <dankna> that actually strikes me as pretty succinct
22:35:23 <revenantphx> Yeah, It's not bad.
22:35:31 <nejucomo> Is there a standard class for bijection?
22:36:21 <revenantphx> The union/struct stuff on line 24 of the header is...
22:36:27 <revenantphx> um, well it pisses off a lot of people.
22:36:33 <revenantphx> It's very much adhoc polymorphism.
22:36:44 <revenantphx> Defines two different access schemes to the same data.
22:36:45 <dankna> yeah I'm used to it
22:36:49 <revenantphx> I like it myself...
22:36:57 <revenantphx> Then again, I program using goto's for error handling.
22:36:58 <dankna> I think it's kind of neat and very much in the spirit of C
22:37:03 <dankna> if you're going to use C you might as well use it right
22:37:05 <dankna> which this is
22:37:06 <dankna> yeah so do I
22:37:11 <revenantphx> At some point I decided "fuck it, this is the cleanest way to handle this"
22:37:20 <dankna> I think there's a general consensus among high-level C programmers that it's actually a rather appropriate use
22:37:24 <revenantphx> I'm not rewriting the same error code in every if statement.
22:37:30 <revenantphx> And I'm not using an extra variable for it.
22:37:38 <ClaudiusMaximus> here's some of my code that implements a growable hyperbolic space: http://gitorious.org/maximus/kjhf/blobs/master/src/DataTape.hs
22:37:42 <revenantphx> I mean, if you look at C++ and Objective-C, all of their error handling is implemented using goto's.
22:37:46 <dankna> right
22:37:48 <revenantphx> exception handling*
22:38:06 <revenantphx> Anyways, my challenge is to rewrite this in haskell.
22:38:19 <revenantphx> It'd be cool to make it totally pure without using the ST monad...
22:38:24 <revenantphx> but idk about that >_>
22:39:31 <revenantphx> :t STRef
22:39:32 <lambdabot> Not in scope: data constructor `STRef'
22:39:36 <revenantphx> :t newSTRef
22:39:37 <lambdabot> forall a s. a -> ST s (STRef s a)
22:39:42 <revenantphx> what are s and a?
22:40:18 <ivanm> ClaudiusMaximus: out of curiosity, what made you pick gitorious over github? (I may be needing to use git for something soon, and am still mulling over which one to choose)
22:40:25 <ddarius> @google antiobject
22:40:26 <lambdabot> http://en.wikipedia.org/wiki/Antiobjects
22:40:26 <lambdabot> Title: Antiobjects - Wikipedia, the free encyclopedia
22:40:40 <revenantphx> oh, dankna http://cl.ly/342X2K1v202E1G1g0Z0N
22:40:49 <revenantphx> That's the fruits of my labor.
22:40:50 <ClaudiusMaximus> ivanm: mainly that gitorious is free software and github isn't
22:41:05 <revenantphx> 12000 data points, showing the bifurcation in the system as the decay rate changes.
22:41:32 <revenantphx> ClaudiusMaximus: While that's all nice and good, github is more feature rich, and very nice to use :P.
22:41:42 <revenantphx> So, I use github instead.
22:41:49 <ClaudiusMaximus> revenantphx: fair enough
22:41:58 <revenantphx> Nothing wrong with gitorious.
22:42:12 <revenantphx> I actually really appreciate there being multiple git hosting sites.
22:42:23 <revenantphx> Inter-competition builds a better tool.
22:42:33 <revenantphx> Same thing for multiple implementations of a language.
22:42:40 <revenantphx> It pushes each version to be more creative.
22:43:39 <ddarius> Cooperation would probably be more effective in this space ...
22:43:54 <revenantphx> Well, you can easily share between them.
22:44:03 <revenantphx> The other key player is a standards group of some sort.
22:44:22 <revenantphx> That way there's a baseline which is always present and stable, and all sorts of fun offshoots.
22:44:56 <revenantphx> Kind of like how the Khronos Consortium standardizes OpenGL, but there are all sorts of fun GL_EXT*, GL_ARB*, GL_NV*, GL_ATI*, and GL_APPLE* functions.
22:45:05 <revenantphx> Many of which are eventually included upstream.
22:45:13 <revenantphx> Anyways, back to me trying to solve my problem :D
22:45:34 <revenantphx> I really have no idea here >_>
22:47:42 <nejucomo> Woah.  My head is throbbing.
22:49:29 <revenantphx> sorrt
22:51:02 <osaunders> revenantphx: What is your problem?
22:51:13 <revenantphx> backlog people
22:51:24 <osaunders> You talk so much though.
22:51:28 <revenantphx> I just wanted some ideas on how to implement my simulation (which is in C) in haskell
22:51:30 <osaunders> I can't easily see.
22:51:32 <revenantphx> osaunders: sorry >_>
22:51:40 <revenantphx> https://gist.github.com/716352
22:52:32 <nejucomo> Is this a sign that I'm just up too late?  http://codepad.org/qAEH6VhT
22:53:06 <revenantphx> "toEnum (fromEnum a)"?
22:53:27 <osaunders> nejucomo: That looks pretty cool to me.
22:53:35 <osaunders> Although I'm also up very late.
22:54:07 <revenantphx> anyone have a good link to a tutorial/pdf on the state monad?
22:54:12 <revenantphx> ST and STRef
22:54:18 <osaunders> revenantphx: What is a node?
22:54:35 <revenantphx> osaunders: You could call it a cell.
22:54:42 <revenantphx> Think of the world like this:
22:54:52 <Enigmatic> revenantphx: ST/STRef are not the same as the State monad
22:55:01 <revenantphx> Enigmatic: exactly why I need a PDF@
22:55:03 <nejucomo> I added examples: http://codepad.org/S5FmHLEA
22:55:05 <revenantphx> Or multiple.
22:55:16 <revenantphx> [foodA][ ][ ][ ][ ]...[colony]...[ ][ ][ ][ ][food B]
22:55:46 <revenantphx> Two radial chains from the center.
22:55:46 <nejucomo> So you end up obscuring all a -> b functions with the name "project".  Seems kind of silly.
22:56:18 <revenantphx> Oh look. Casting.
22:56:22 <osaunders> nejucomo: Nice
22:56:26 <nejucomo> hehe...
22:56:44 <osaunders> Some potential for chaos but if you use it right....
22:57:11 <osaunders> revenantphx: Radical chains?
22:57:17 <revenantphx> radial
22:57:23 <osaunders> Oh, right.
22:57:23 <revenantphx> As in, radiating from a center node.
22:57:39 <osaunders> Mmm radioactive
22:57:53 <nejucomo> back to reading about generic functions...
22:57:56 <revenantphx> So er mainly
22:58:09 <revenantphx> I need to know the difference between State, ST, and STRef
22:58:14 <osaunders> Yes I am very manly, thank you.
22:58:15 <revenantphx> I think that'd be a place to start :D
22:58:25 <revenantphx> ma_i_nly.
22:58:28 <osaunders> lol
22:58:31 <revenantphx> You're up a bit too late.
22:58:36 <osaunders> Yes, yes I am.
22:58:39 <osaunders> Actually I need food.
22:58:41 <revenantphx> Increase font size to 24pt...
22:58:47 * revenantphx is stuffed :P
22:59:01 <osaunders> I knew you said mainly, I was just joking.
22:59:24 <osaunders> Those things might be covered in typeclassopedia
22:59:29 <osaunders> @where typeclassopedia
22:59:29 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
22:59:41 <revenantphx> I'M UP AT 2:00AM 
22:59:50 <revenantphx> I need the digest version, so I can think it over while I sleep.
22:59:54 <osaunders> Pfft, it's 7am here.
22:59:59 <osaunders> And I didn't just wake up.
23:00:17 <osaunders> Ah, I can't help you there. I'm still new to monads.
23:00:54 <kmc> hi everyone
23:00:59 <revenantphx> hi kmc
23:01:02 <revenantphx> Hey kmc
23:01:05 <osaunders> Greetings
23:01:13 <revenantphx> In under 140 characters, what is the difference between State, ST and STRef
23:01:16 <revenantphx> GO
23:01:23 <kadoban> the Ref
23:01:24 <kmc> yeah ok
23:01:35 <kmc> State is just sugar for passing around state through pure functions
23:01:37 <kmc> @unmtl State s a
23:01:38 <lambdabot> s -> (a, s)
23:01:51 <revenantphx> Yeah, I saw that.
23:01:53 <kmc> State is something you can implement in vanilla Haskell 98 in a few lines
23:01:56 <kmc> ST is totally different
23:02:05 <revenantphx> I want something like STM, but without the concurrency.
23:02:06 <kmc> ST is an interface to real in-place mutable reference cells
23:02:09 <revenantphx> Capisce?
23:02:09 <kmc> which are called STRefs
23:02:12 <kmc> and act much like IORefs
23:02:18 <revenantphx> Okay, that sounds more like it.
23:02:19 <osaunders> Ahh, that's interesting. I've probably already made my own ad-hoc State before then.
23:02:21 <kmc> ST is like a limited version of IO where you *only* get refs
23:02:28 <kmc> in exchange, you're allowed to use runST
23:02:32 <kmc> to turn an ST action into its result
23:02:58 <kmc> in GHC, runST and unsafePerformIO are implemented identically!
23:02:59 <revenantphx> So er, can I have some PDF's for ST?
23:03:05 <kmc> why, then, do we consider runST to be safe?
23:03:09 <revenantphx> I know you guys keep hundreds of PDFs....
23:03:10 <kmc> because there are type system tricks to make it so
23:03:16 <revenantphx> TT_TT
23:03:24 <kmc> which i can attempt to explain
23:03:35 <revenantphx> Well I don't understand either of those functions yet.
23:03:38 <kmc> but essentially it prevents your refs from leaking out to another runST invocation
23:03:39 <revenantphx> So maybe not yet ;)
23:03:50 <kmc> so the stuff inside a runST call is a "closed world" of reference manipulation
23:03:53 <revenantphx> kmc: it does magic locking >_>?
23:03:56 <kmc> no
23:03:59 <kmc> it's all compile-time checking
23:04:09 <osaunders> revenantphx: unsafePerformIO lets you do an IO thing without giving you an IO back.
23:04:11 <kmc> at runtime, your ST code is the same as if you used IORef and unsafePerformIO
23:04:14 <osaunders> :t unsafePerformIO
23:04:15 <lambdabot> Not in scope: `unsafePerformIO'
23:04:18 <kmc> unsafePerformIO :: IO a -> a
23:04:18 <revenantphx> I seeeee.
23:04:25 <kmc> runST :: (forall s. ST s a) -> a
23:04:42 <kmc> ST is really nice, because some algorithms just can't be implemented in a pure-functional way without a slowdown
23:04:42 <revenantphx> what is that forall syntax?
23:04:49 <kmc> so ST lets us implement those imperatively, while providing a pure interface
23:04:54 <kmc> revenantphx, explicit polymorphism
23:05:01 <kmc> it's not in Haskell 98 but is used by some GHC extensions
23:05:07 <kmc> when we say map :: (a -> b) -> [a] -> [b]
23:05:13 <revenantphx> Does it just mean "s can be all types"
23:05:15 <kmc> we mean map :: forall a b. (a -> b) -> [a] -> [b]
23:05:51 <revenantphx> Why isn't it runST :: (forall s a. ST s a) -> a then?
23:05:52 <kmc> in H98, type variables get an implicit "forall" at the outside
23:06:06 <kmc> revenantphx, you mean forall s a. (ST s a -> a)
23:06:17 <kmc> if we write just "ST s a -> a", that's what we get
23:06:24 <kmc> but that type is different from (forall s. ST s a) -> a
23:06:32 <kmc> when we have forall in the left argument to (->)
23:06:33 <revenantphx> ......>_<?
23:06:46 <kmc> we're using a GHC extension called "higher-rank polymorphism"
23:06:51 <revenantphx> It's really too late for this.
23:06:59 <revenantphx> Listen, can I take a rain check on this conversation?
23:07:04 <kmc> yeah
23:07:09 <revenantphx> I need a few pdf's on ST for tomorrow.
23:07:13 <kmc> ok
23:07:15 <revenantphx> And we'll continue this when I get back on.
23:07:22 <kmc> you don't need to worry about *how* runST does its magic checking
23:07:26 <kmc> you can just use it
23:07:29 <revenantphx> yepyep
23:07:32 <kmc> if you get bizarre type errors, we can help you fix them
23:07:42 <revenantphx> Oh and btw
23:07:55 <revenantphx> it was nice to do stuff with STM like type TCell = TVar Cell
23:08:13 <revenantphx> but that doesn't seem possible given the multiple left hand variables to STRef :\
23:08:18 <nejucomo> kmc: What is the s type variable in ST?  I recall it being some kind of magic inaccessible goo.  Is that part of the "type system trick" of quarantining worlds?
23:08:25 <revenantphx> Or at least, yet, since I don't know what s and a are yet.
23:08:32 <kmc> type TCell s = STRef s Cell
23:08:35 <revenantphx> a value of type STRef s a is a mutable variable in state thread s, containing a value of type a
23:08:41 <revenantphx> kmc: gotcha.
23:08:43 <kmc> 'a' is the type of thing which is stored in the ref
23:08:47 <kmc> just like (TVar a) or (IORef a)
23:08:54 <revenantphx> right right.
23:09:05 <kmc> 's' is never instantiated to a particular type
23:09:06 <revenantphx> Alright then, PDF!
23:09:11 <kmc> you have to keep 's' polymorphic throughout your ST code
23:09:13 <revenantphx> Before I die TT_TT
23:09:15 <kmc> that's how runST works its magic
23:09:19 <kmc> and that's why it has a forall to the left of (->)
23:09:32 <revenantphx> I am like my MacBook at 5% battery right now.
23:09:36 <kmc> forall to the left of (->) means that the function *demands* polymorphism, not *provides* polymorphism
23:09:37 <nejucomo> :t runST
23:09:37 <lambdabot> forall a. (forall s. ST s a) -> a
23:09:41 <revenantphx> I'm going to hibernate to preserve memory contents soon.
23:09:46 <kmc> ttyl revenantphx
23:09:51 <revenantphx> Hey hey.
23:09:54 <revenantphx> I need PDFs!!!
23:10:12 <ClaudiusMaximus> http://homepages.dcc.ufmg.br/~camarao/fp/articles/lazy-state.pdf is the one
23:10:19 <revenantphx> Lambdabot needs a @pdf command.
23:10:33 <revenantphx> like, @pdf-store <tag>
23:10:36 <osaunders> @google Haskell ST filetype:pdf
23:10:37 <lambdabot> No Result Found.
23:10:41 <osaunders> @google ST filetype:pdf
23:10:42 <lambdabot> Plugin `search' failed with: Lib.URL.isTextHTML: getHeader failed
23:10:46 <revenantphx> osaunders: smart ass.
23:10:47 <osaunders> @google "ST filetype:pdf"
23:10:48 <lambdabot> No Result Found.
23:10:51 <osaunders> :(
23:10:54 <nejucomo> kmc: I don't understand the bit about demanding vs providing polymorphism.  Does this mean: "Regardless of s, a can be any type." ?
23:11:01 <revenantphx> But no, I mean so that people can record pdf's which are relevant to a topic.
23:11:33 <revenantphx> ... ClaudiusMaximus Is MutVar STRef?
23:11:35 <ddarius> osaunders: I rewrote the Search plugin recently so stuff like that should happen less (not at all.)  I don't know when it will get into the live version of lambdabot though.
23:11:49 * revenantphx is confused by this PDF already :D
23:11:58 <ddarius> revenantphx: Why be specific to pdf?
23:11:59 <kmc> nejucomo, you might enjoy http://mainisusuallyafunction.blogspot.com/2010/10/quantification-in-haskell.html
23:12:09 <revenantphx> ddarius: I mean that it isn't using the same types.
23:12:12 <nejucomo> Thanks.
23:12:21 <osaunders> ddarius: I look forward to that.
23:12:48 <kmc> nejucomo, f :: ((forall a. [a]) -> b) *requires* that the argument to f be polymorphic over the list's element type
23:12:58 <kmc> so we can pass in [] or [undefined] or undefined, but not [3] or ['x']
23:13:16 <kmc> f :: forall a. ([a] -> b)  *promises* to accept any *particular* element type
23:13:21 <nejucomo> Oh, wait, it's on the tip of my brain:  s is never "instantiated", but composition with the same "uninstantiated type" of s ensures the quarantine… somehow.
23:13:32 <revenantphx> good night then folks.
23:13:35 <revenantphx> Thanks for your help.
23:13:53 <kmc> nejucomo, consider «runST (newSTRef 'x')»
23:14:00 <kmc> this would have type STRef s Char
23:14:02 <kmc> except what's s?
23:14:08 <kmc> it escaped from the "forall"
23:14:18 <kmc> the thing we pass to runST has to not care what s is
23:14:28 <kmc> and that can't be the case if s is allowed to escape and unify with other stuff
23:14:30 <Enigmatic> nejucomo: it's provided by the runtime, the compiler doesn't have any visibility into it
23:14:39 <kmc> Enigmatic, what?
23:15:13 <Enigmatic> kmc: well, it is for IO :-)
23:15:35 <nejucomo> Enigmatic: Are you sure?  I thought no value of type s ever exists at runtime.
23:15:49 <kmc> s is a phantom type parameter
23:15:50 <nejucomo> :t runST
23:15:51 <lambdabot> forall a. (forall s. ST s a) -> a
23:15:55 <kmc> it has no run-time meaning
23:15:56 <nejucomo> :t newSTRef
23:15:57 <lambdabot> forall a s. a -> ST s (STRef s a)
23:16:04 <kmc> it has no meaning at the value level
23:16:18 <nejucomo> :t runST (newSTRef 'x')
23:16:19 <lambdabot>     Inferred type is less polymorphic than expected
23:16:20 <lambdabot>       Quantified type variable `s' escapes
23:16:20 <lambdabot>     In the first argument of `runST', namely `(newSTRef 'x')'
23:16:29 <nejucomo> :t readSTRef
23:16:30 <lambdabot> forall s a. STRef s a -> ST s a
23:16:38 <Enigmatic> kmc: yes but it needs to be part of the type signature
23:16:44 <Enigmatic> doesn't matter if the value is defined or not
23:16:44 <cole> Could haskell scripts make for a reasonable alternative to bash scripts, in the way that perl and python are commondly used?
23:16:58 <kmc> cole, yes
23:17:07 <nejucomo> :t newSTRef 'x' >>= readSTRef
23:17:08 <lambdabot> forall s. ST s Char
23:17:10 <kmc> cole, i think ezyang wrote a recent blog post about that, and dons (?) did a presentation
23:17:21 <kmc> Enigmatic, i agree... so what does that have to do with "provided by the runtime"?
23:17:24 <nejucomo> :t runST (newSTRef 'x' >>= readSTRef)
23:17:25 <lambdabot> Char
23:17:43 <Enigmatic> kmc: it's part of the actual assembly code that is being executed, so something has to provide storage for it
23:17:45 <adu> hi
23:17:48 <kmc> Enigmatic, no it's not
23:17:59 <adu> ooo assembly
23:18:00 <kmc> there is no value of type 's' at runtime
23:18:13 <kmc> Enigmatic, if i say «data Foo a = MkFoo»
23:18:18 <kmc> bar :: Foo Char; bar = MkFoo
23:18:21 <kmc> there is no Char stored anywhere
23:18:22 <ClaudiusMaximus> cole: i used HSH in a project once, was quite nice to be able to pipe my haskell-generated video into encoders without having to have large intermediate files
23:19:32 <kmc> Enigmatic, if you've picked through GHC assembly output and see evidence to the contrary, i'd like to take a look
23:19:49 <kmc> so no value of type 's' appears at runtime
23:19:57 <kmc> but does a value of type (State# s) appear at runtime?
23:20:03 <cole> ClaudiusMaximus: you used it once. Is there some reason you haven't used it again?
23:20:06 <kmc> the parameter to State# is phantom, so this would not imply a value of type 's'
23:20:06 <adu> ghc-asm is wierd
23:20:10 <nejucomo> Ok, so now the quantification reference is on my haskell reading queue after this generic function thing and "Typing Haskell in Haskell".
23:20:16 <aefjt> Does it make any sense to have scoped class instances in Haskell?
23:20:24 <kmc> Enigmatic, i believe the answer is also "no", but for a different reason
23:20:25 <aefjt> Eg. scoped within modules
23:20:35 <kmc> which has more to do with GHC internals and less to do with basic properties of polymorphic types
23:21:20 <nejucomo> aefjt: I could think of uses.
23:22:13 <Enigmatic> kmc: i thought Sp_Arg was the opaque IO value but i could be wrong
23:22:13 <aefjt> It certainly has potential uses. But I'm not sure if those uses are sensible (eg. formally consistent)
23:22:34 <Enigmatic> from something like this (in llvm ir): define  cc 10 void @Main_main_info(i32* noalias nocapture %Base_Arg,i32* noalias nocapture %Sp_Arg,i32* noalias nocapture %Hp_Arg,i32 %R1_Arg) align 4 nounwind section "__STRIP,__me12"
23:23:26 <kmc> isn't that just the stack pointer?
23:23:41 <kmc> Sp = stack pointer, Hp = heap pointer, R1 = STG register 1
23:23:52 <kmc> Base is probably the pointer to the struct of other STG regs but i'm not sure
23:23:57 <Enigmatic> alright well nevermind :)
23:24:05 <kmc> why did you think it's got to do with State# RealWorld?
23:24:51 <aefjt> Note that RealWorld has no values anyway
23:25:05 <kmc> yeah, it's the phantom type parameter to State#
23:25:22 <kmc> but the question of whether RealWorld has runtime representation is different from the question of whether (State# RealWorld) has runtime representation
23:25:28 <kmc> or (State# s) generally
23:25:36 <kmc> my understanding is that (State# s) has STG representation type 'v' (void) so it doesn't actually get loaded into registers or occupy stack space etc.
23:28:04 <kmc> STG representation types are: non-ptr word, pointer word, void, float, double, long (64-bit)
23:28:46 <Enigmatic> i deal too much with our own runtime so i occassionally get argument types mixed up :P
23:29:06 <aefjt> Is there any research on expressing "inverse" evaluation? ie. turning values back into their thunks
23:34:03 <flux> aefjt, there is 'reversible computing', but that's a bit different
23:35:19 <flux> (actually very much different ;-))
23:35:34 <aefjt> Grapes and grapefruits
23:35:51 <ClaudiusMaximus> cole: i had some problems with insufficient concurrency (ie, i had to patch HSH with extra 'yield' calls to avoid deadlock) - and i also got more hard disk space so that the intermediate files could exist...
23:36:06 <ivanm> ClaudiusMaximus: sorry, did you respond to me before?  my net decided to play up :s
23:36:15 <ClaudiusMaximus> ivanm: mainly that gitorious is free software and github isn't
23:36:23 <ivanm> *nod*
23:36:31 <ClaudiusMaximus> ivanm: someone else said that github is more featureful
23:36:47 <ivanm> yeah, that seemed to be the main points of difference between the two that I saw
23:37:24 <ClaudiusMaximus> gitorious seems project-centric and github user-centric, which is quite a semantic difference
23:37:47 <ivanm> yeah
23:38:29 <ivanm> on the one hand, I like the project-centric bit because a project isn't tied to a specific developer; on the other hand, it means you have heaps of little throw-away projects cluttering the main namespace :s
23:56:05 <ClaudiusMaximus> is there any tool out there that reads unbuffered lines from stdin and prefixes them with a timestamp before dumping on stdout?
23:58:21 <McManiaC> very cool: http://justtesting.org/final-version-of-the-accelerate-paper-gpgpu-i
23:58:22 <McManiaC> :)
23:58:25 <flux> claudiusmaximus, ts
23:58:47 <flux> I don't remember in which package it is, though :)
23:58:57 <flux> ah, moreutils
