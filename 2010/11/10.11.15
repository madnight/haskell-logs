00:03:02 <endojelly> > (length,id) <*> ("foo",2)
00:03:02 <lambdabot>   Couldn't match expected type `[a] -> GHC.Types.Int'
00:03:02 <lambdabot>         against inferre...
00:03:15 <endojelly> > (length,id) <*> ("foo","bar")
00:03:16 <lambdabot>   Couldn't match expected type `[a] -> GHC.Types.Int'
00:03:16 <lambdabot>         against inferre...
00:04:18 <endojelly> > (length,length) <*> ("foo","bar")
00:04:19 <lambdabot>   Couldn't match expected type `[a] -> GHC.Types.Int'
00:04:19 <lambdabot>         against inferre...
00:34:11 <jekor> What am I doing wrong? http://hpaste.org/41484/th_stage_error
00:34:47 <jekor> I'm trying to convert the result of a query (run at runtime), to a tuple with types determined at compile time.
00:39:56 <Saizan> jekor: r there would be the actual row, which you obviously can't inspect at compile time
00:41:23 <Saizan> ?hoogle tupE
00:41:24 <lambdabot> Language.Haskell.TH tupE :: [ExpQ] -> ExpQ
00:41:24 <lambdabot> Language.Haskell.TH.Lib tupE :: [ExpQ] -> ExpQ
00:41:24 <lambdabot> Language.Haskell.TH TupE :: [Exp] -> Exp
00:41:28 <jekor> The limitation makes sense, but I'm wondering how I'd work around it.
00:42:19 <Saizan> you need to pass the variable r to convertRow rather than r itself, i think that's done with 'r or maybe [| r |]
00:42:53 <Saizan> and convertRow needs to handle that
00:43:30 <jekor> OK. I'm going to lookup how to take a Name and get a value.
00:43:54 <Saizan> you won't get a value
00:43:59 <arcatan> hmm, do you know the types of result at compile time?
00:44:21 <Saizan> you can build an expression with it though
00:44:23 <arcatan> (looking at the code it seems like you're doing a SQL query)
00:44:24 <jekor> arcatan: Yes. I'm using PostgreSQL's type inference.
00:44:26 <Saizan> with VarE
00:44:31 <jekor> Saizan: Ah...
00:45:20 <arcatan> oh, interesting
00:45:28 <Saizan> you need to generate code that will do the conversion, you can't actually convert at compile time
00:45:47 <jekor> Saizan: That makes sense. It just hurts my brain to think of how to. Thank you.
00:47:22 <Saizan> yeah, staged programming is a bit mind bending
00:50:12 * Phyx- awakens
00:52:42 * hackagebot benchpress 0.2.2.4 - Micro-benchmarking with detailed statistics.  http://hackage.haskell.org/package/benchpress-0.2.2.4 (JohanTibell)
00:55:25 <Mitar> i want to use case ... of to match on numeric constants and everything works well if I really use constants, but if I move numbers to variables (so that they have more meaningful names) ghc starts complaining about overlapping instances
00:55:36 <Mitar> s/instances/patterns)
00:58:28 <arcatan> Mitar: if you do case ... of a -> b, it binds ... to a
00:58:38 <Phyx-> Mitar: because the LHS of case statements are supposed to be patterns. it won't match the expression with the content of the variables, it'll just create a variable with the content of the expression
00:59:17 <Mitar> ok, but if I do case ... of 1 -> ...
00:59:26 <Mitar> then it matches only if it is 1?
00:59:49 <arcatan> yes
01:01:00 * Phyx- rubs his eyes and yawns
01:01:41 <Mitar> so then, what? case ... of a | a == var1 -> ... | a == var2 ... ?
01:01:51 <arcatan> yeah, that would work
01:01:59 <Mitar> any better way?
01:02:12 <Mitar> (it is nice to map C exit values to something meaningful)
01:02:23 <Mitar> hmm, i could define enum data type and use toEnum ;-)
01:02:46 <arcatan> sounds good
01:04:23 <Mitar> hmm, and this data type could be an exception instance ;-)
01:04:35 <Mitar> throwIO $ toEnum returnValue
01:04:36 <Mitar> ;-)
01:07:01 <bsod1> I want to start to learn haskell, do you have any IDE or editor advices?
01:07:21 <pacak> bsod1: vim, emacs
01:07:31 <solistic> bsod1: I use vim.
01:07:41 <Phyx-> bsod1: which platform?
01:07:50 <bsod1> Phyx-: ubuntu linux
01:08:02 <bsod1> pacak, solistic: they are really hard to learn and I have limited time
01:08:12 <bsod1> I need a fast solution, easy to install etc.
01:08:18 <solistic> bsod1: vimtutor
01:08:20 <Phyx-> i use gvim or just kate on linux
01:08:34 <pacak> bsod1: Haskell is harder to learn than both vim and emacs at the same time.
01:08:34 <bsod1> solistic: I already finished vimtutor but still I can't even install haskell on my vim
01:08:48 <bsod1> pacak: so yes I can only focus on one of them
01:08:52 <arcatan> bsod1: if you have a favourite editor, i suggest just using it
01:08:52 <Phyx-> not true
01:09:01 <Phyx-> Haskell is easier than vim
01:09:04 <Phyx-> and emacs is an os
01:09:15 <bsod1> arcatan: but I need interactive shell, syntax highlighter, auto indentation, etc.
01:09:38 <bsod1> ok, so do you have any tutorials about installing haskell on vim or emacs?
01:09:57 * Phyx- needs to refresh his latex foo
01:10:32 <solistic> bsod1: I use just plain vim with synstax highlighting, and ghci in an other shell
01:10:44 <solistic> bsod1: you know how you get syntax highlighting in vim?
01:10:49 <arcatan> i think Vim users usually don't integrate Haskell shell inside Vim but just use GHCi from command line
01:10:57 <bsod1> everybody always telling me that I should use vim or emacs but nobody knows any tutorials to show a newbie how to install haskell to vim or emacs
01:11:01 <arcatan> but yeah, syntax highlighting and good indentation are very good thing
01:11:10 <bsod1> solistic: no, I just edit some plain texts
01:11:41 <bsod1> su how did you install haskell to your vim or emacs?
01:11:49 <solistic> bsod1: so type vim foo.hs and type `main = do'
01:12:05 <arcatan> my vim came with haskell syntax highlighting
01:12:20 <bsod1> arcatan: where did you download your vim?
01:12:24 <solistic> bsod1: If it does not get highlighted properly, I'll give you some hints
01:13:33 <bsod1> solistic: I just want to start rapidly learning haskell but there are always some distractions like syntax highlightint or wrong indentation.. I don't spend my time setting up emacs or vim I just want to code something..
01:14:14 <bsod1> so I should install vim, and haskell syntax highlighting and indentation will come with it, right?
01:14:15 <solistic> bsod1: well, you'll need an editor to code something...
01:14:47 <solistic> bsod1: just do `sudo aptitude install vim-full'
01:14:51 <arcatan> bsod1: yes, i think. just use the ubuntu package manager or apt-get
01:15:02 <bsod1> solistic: yes but vim and emacs are the hardest editors to learn and start coding
01:15:16 <bsod1> arcatan: I already have vim installed with ubuntu software center
01:15:21 <arcatan> though if vim is too hard, you could just use, say, gedit. it comes with Haskell syntax highlighting too
01:15:30 <Phyx-> or kate
01:15:51 <solistic> bsod1: I don't know, I only use vim for coding..
01:15:54 <arcatan> gedit's indentation isn't anything special, though.
01:16:01 <bsod1> arcatan: gedit really sucks. I tried it for lots of languages..
01:16:32 <arcatan> oh, okay. I've never used it much.
01:16:35 <bsod1> so there isn't any editor for a newbie who just wants to learn haskell not an editor..
01:16:50 <ddarius> Just use whatever editor you are currently using.
01:17:22 <bsod1> ddarius: I'm using eclipse for java and komodo edit for python, are they ok for haskell?
01:17:42 <Phyx-> there's eclipse-fp
01:17:48 <Phyx-> not sure how easy it is to setup
01:17:57 <ddarius> There are plugins for Eclipse.  I've never heard of Komodo Edit.  It doesn't really matter; you just need the ability to edit text.
01:18:41 <bsod1> ddarius: no I need at least synrax highlighter and auto indentation
01:18:48 <bsod1> syntax*
01:19:12 <ddarius> That said, I don't see how a Haskell-specific editor would help you.  It would be just another editor you'd need to learn and then you'd need to learn another one later on.
01:19:12 <bsod1> I really want to learn vim but see, nobody can show me any tutorials to use vim for my language of choice..
01:19:26 <ddarius> Invest the effort to learn one that is applicable to many languages.
01:19:45 <arcatan> to tell a truth: vim's haskell autoindenation is rather... manual
01:19:47 <Phyx-> you don't "need" it, I for one just use notepad++
01:19:58 <bsod1> arcatan: so what do you prefer? haskell?
01:20:02 <bsod1> sorry, emacs?
01:20:09 <arcatan> no, i like vim
01:20:14 <bsod1> Phyx-: im on ubuntu
01:20:20 <ddarius> I use vim with no special Haskell support.  It comes with syntax highlighting out of the box as do almost all serious programmer's editors nowadays.
01:20:22 <arcatan> though emacs's haskell integration is clearly more advanced
01:20:35 <ddarius> I use vim's autoindent which is language agnostic.
01:21:02 <Jafet> a\Oh boy, an editor war!
01:21:04 <Jafet> ?
01:21:08 <bsod1> do you really thousands of lines of haskell without proper indentation on vim?
01:21:09 <maurer_> Is it dead enough in here that it is appropriate to ask a general CS question? I'm doing the implementation in haskell, but it's not particularly relevant.
01:21:55 <ddarius> bsod1: What is "proper indentation"?  autoindent almost always does what I want.  Typing tab every now and then is hardly burdensome and apparently you'd have to do that anyway.
01:21:58 <Phyx-> bsod1: yes i know, my point was, you don't need any of that stuff, it's more important to learn haskell. syntax highlighting is handy, but indentation, meg
01:22:05 <ddarius> It would certainly be no trouble for me to write Haskell in notepad.
01:22:48 <bsod1> ok, so I have gvim, which command do I need to give for haskell syntax highlighting or indentation or something..
01:23:13 <solistic> bsod1: does it not highlight? Have you tried?
01:23:20 <ddarius> bsod1: You don't need to do anything.  There should be Haskell syntax highlighting by default.  It will load when you open a Haskell source file.
01:23:20 * osfameron has mostly given up on any indentation in vim except "keep me at the same indentation as line above" which is at least Less Wrong in many cases than trying to be more clever about it...
01:23:24 <bsod1> solistic: no :) I don't have any haskell code yet
01:23:32 <solistic> bsod1: just try "main = do"
01:23:32 <maurer_> bsod1: If you want fancy stuff, you could try leksah.
01:23:48 <maurer_> bsod1: It should do it, but you may need to save it as a .hs file first so it knows what language you're using.
01:23:55 <maurer_> (It in the above being gvim)
01:24:00 <bsod1> maurer_: is it free?
01:24:04 <ddarius> bsod1: There is no "Haskell indenting" by default.  You can install the vim haskell-mode, but what are you expecting the indenting to do?
01:24:07 <maurer_> bsod1: Yes. cabal install leksah
01:24:24 <bsod1> great, I'll try it maurer_
01:24:29 <ddarius> maurer_: So he could have yet another editor that he'll eventually have to abandon.
01:24:31 <ddarius> ?
01:24:32 <maurer_> bsod1: If you haven't written haskell before, don't try it yet.
01:24:58 <bsod1> ok I'll try haskell-mode and leksah
01:25:06 <maurer_> bsod1: Just use a regular editor. If you don't understand cabal, and don't need a documentation reference at all times, you should just try a normal editor
01:25:11 <bsod1> is haskell-mode for vim?
01:25:23 <maurer_> bsod1: Yes, but you don't need it?
01:25:47 <solistic> bsod1: I give you the same advice, do not mess with any fancy extension, yet
01:25:54 <bsod1> solistic: ok
01:25:54 <maurer_> ddarius: Sorry, when I first suggested leksah, I hadn't seen that he hadn't written any code before. I figured it was someone who knew what they were doing, but was fed up with their editor.
01:26:03 <solistic> bsod1: the may only put more work on your shoulders
01:26:27 <ddarius> I'm not sure if Leksah does anything particularly special with indentation (not that I see why people care so much about that.)
01:26:34 <bsod1> ok thank you all, I'll try to code some with default vim, and ghci.
01:26:55 <maurer_> ddarius: It does, and I kind of like what it does. It is correct enough most of the time that it saves me holding space frequently.
01:27:18 <ddarius> maurer_: Why would you be "holding space" anyway?
01:27:41 <maurer_> Say I've got nested do-case-if or something like that?
01:27:49 <maurer_> I need to get my indentation all the way in to type the then block.
01:28:03 <solistic> bsod1: have tried, if your syntax highlighting works?
01:28:18 <solistic> bsod1: e. g. by putting `main = do putStrLn "Hello, World"
01:28:22 <ddarius> Your indentation should already start there and it should only take a few strokes of the tab key to get there anyway.
01:28:23 <bsod1> solistic: no, can you give me a few lines of haskell code and I can try? 
01:28:23 <solistic> bsod1: in Main.hs?
01:28:34 <maurer_> I try to keep nesting to a minimum, but sometimes it just happens that I end up with 3 or so deep nesting
01:28:41 <maurer_> Esp. when writing a function in a where clause.
01:29:11 <solistic> bsod1: the do in the above is not necessary, but we insert it here, to see if it gets properly highlighted ;)
01:29:12 <bsod1> solistic: yea it's highlighting something..
01:29:13 <maurer_> ddarius: Is there some better way that I've missed entirely?
01:29:20 <DontGetHaskell> Hi can anyone help me with this:  http://hpaste.org/41485/define_show
01:29:28 <solistic> bsod1: ok, now do runhaskell Main.hs
01:29:31 <ddarius> maurer_: Pressing tab instead of space.
01:29:35 <solistic> bsod1: ghci Main.hs
01:29:41 <solistic> bsod1: here you go...
01:29:54 <bsod1> solistic: yea thanks
01:29:57 <maurer_> ddarius: That won't always line up right...
01:30:42 <ddarius> maurer_: Then you press space to make it line up, though usually things will be on tabstops anyway if you format your code correctly.
01:31:12 <solistic> bsod1: btw, you have to change the indentation level manually with vim, but make sure that you haev `set ai
01:31:20 <solistic> bsod1: in your .vimrc
01:31:39 <solistic> bsod1: that will keep the indentation level for new lines
01:31:40 <bsod1> solistic: yea I have a problem about that, I can't find my .vimrc, I searched my entire hard drive..
01:31:41 <arcatan> DontGetHaskell: now with show a, you should pattern-match against Cons and write a definition for it
01:32:01 <Jafet> or $ do { write <- all your code; like this; }
01:32:20 <solistic> bsod1: just do `cd && vim .vimrc` ;)
01:32:27 <ddarius> Jafet: On one line? or with no indentation at all?  Indentation is independent of layout.
01:32:38 <bsod1> solistic: oh so I have to create it..
01:32:53 <bsod1> solistic: which lines do I need to add?
01:33:13 <solistic> bsod1: `set ai' is important, at least to me
01:34:11 <bsod1> `set ai' or set ai or `set ai ? :)
01:34:13 <DontGetHaskell> arcatan : I tried something like this but got errors, show a -> Cons a Empty
01:34:39 <solistic> bsod1: set ai
01:34:51 <bsod1> solistic: ok thanks, any additional commands?
01:34:53 <DontGetHaskell> show a = Cons a Empty
01:35:16 <Mitar> hmm, there still seems to be a bug: http://hackage.haskell.org/trac/hackage/ticket/656
01:35:42 <DontGetHaskell> arcatan: should I have another variable?
01:36:11 <arcatan> DontGetHaskell: the correct syntax is show (Cons a Empty) = ?
01:36:54 <solistic> bsod1: ok, I'll paste you my config somewhere
01:37:11 <bsod1> solistic: great, thanks
01:38:15 <arcatan> DontGetHaskell: and yes, you should have another variable to match case, where the tail of the list is not empty
01:38:33 <DontGetHaskell> ok
01:39:05 <DontGetHaskell> arcatan: do I need to define the variable
01:39:11 <pelotom> DontGetHaskell: you'll want a sekrit function to do the dirty work of the inner comma-separated list, and then wrap whatever it produces with {}
01:40:06 <solistic> bsod1: This is my haskell-specific stuff, put it in ~/.vim/after/ftplugin/haskell.vim
01:40:17 <DontGetHaskell> pelotom: yes that is what I was trying to do, but I didn't what to define another variable to do it
01:40:30 <solistic> bsod1: lines starting with " are comments, though..
01:40:33 <bsod1> solistic: where?
01:40:47 <solistic> bsod1: http://hpaste.org/41486/vimafterftpluginhaskell
01:40:57 <pelotom> DontGetHaskell: why not?
01:41:17 <solistic> bsod1: that is what works for me, it is only very minimal
01:41:19 * ski feels like wanting to smack DontGetHaskell's exercise writer, for having the bad taste of demanding to write a `Show' instance that doesn't produce valid Haskell code ..
01:41:39 <bsod1> solistic: how can I active it?
01:41:48 <solistic> bsod1: wait
01:41:57 <ski> (.. it would have worked just fine to demand to write a separate `showList :: Show a => List a -> String' function, instead)
01:42:32 <DontGetHaskell> ski: blame my professor 
01:43:17 <ski> DontGetHaskell : you "define" another variable by just writing it in the pattern, instead of `Empty'
01:43:29 * ski blames DontGetHaskell's professor, then
01:43:31 <DontGetHaskell> ok pelotom & arcatan : I did this for my second line          show (Cons a Empty)= x : toList xs  
01:43:41 <DontGetHaskell> is that the right idea
01:43:46 <ski> what is `toList' ?
01:43:57 <ski> what is its type ?
01:43:58 <pelotom> DontGetHaskell: just use your constructors, don't convert it to []
01:44:26 <pelotom> DontGetHaskell: and that's not going to produce a string
01:44:39 <pelotom> oh, unless toList does that :)
01:45:31 <ski> also, `x' and `xs' are undefined variables, there
01:46:32 <DontGetHaskell> pelotom:  this what I have for my toList  toList :: List a -> [a]    toList Empty = []  toList(Cons x xs) =  x : toList xs
01:47:12 <ski> DontGetHaskell : ok, then *don't* use `toList', since that's what "In other words, don't convert a List a to an ordinary list in the process of showing it." in the exercise tells you not to do
01:47:12 <solistic> bsod1: http://hpaste.org/41487/vimrc
01:47:14 <pelotom> DontGetHaskell: ok, you don't need to convert his to [] to write this function
01:47:21 <DontGetHaskell> ski: how should I define them?
01:47:26 <solistic> bsod1: here are some basic setting from my vimrc
01:47:46 <solistic> bsod1: be aware that they are my preferences, you may have others, though
01:48:11 <ski> DontGetHaskell : write them in the pattern, or in a `where'-clause .. or, possibly, refrain from using `x' and `xs' (perhaps using the perfectly fine variable `a' which you already have)
01:48:39 <ddarius> ski: Good luck and have fun.
01:48:44 <solistic> bsod1: you need `filetype plugin on' for the haskell specific stuff in ~/.vim/after/ftplugin/haskell.vim
01:48:58 * ski . o O ( "These are my principles; if you don't like them, I have others." )
01:49:00 <solistic> bsod1: not everybody likes hlsearch
01:49:05 <ski> ddarius : .. with ?
01:49:23 <pelotom> DontGetHaskell: do you understand how pattern matching works?
01:50:01 <ski> DontGetHaskell : hm, sorry, i missed that in your last `toList (Cons x xs) =  x : toList xs' you removed the `a' and "defined" `x' and `xs' instead .. so ignore the last part of my earlier comment
01:50:07 <DontGetHaskell> pelotom: not quite but don't I match the types?
01:50:18 <ski> you match the shapes of the values
01:50:33 <bsod1> solistic: ok thanks, I'll try
01:50:40 <ski> a value of type `List a' is either of the shape `Empty' or of the shape `Cons x xs', for some values `x' and `xs'
01:50:55 <pelotom> DontGetHaskell: you match the *constructors*
01:51:21 <ski> (of course you can match with `Cons cat food' instead, if you prefer those variable names -- the language doesn't care (but your examiner might))
01:51:24 <pelotom> DontGetHaskell: and when you do that, you get variables bound to the values with which it was constructed
01:51:54 <pelotom> DontGetHaskell: so when you say show (Cons x xs) = ...
01:52:14 <pelotom> DontGetHaskell: if that pattern matches, then you have x and xs variables that you can use on the right side
01:52:16 <solistic> bsod1: you can get help for the option with e. g. `:help hlsearch'
01:52:40 <solistic> bsod1: if you do not want to mess with the vim help system, try the search box at: http://vimdoc.sourceforge.net/
01:53:07 <pelotom> DontGetHaskell: if you matched (Cons x Empty), it would only match if the second argument to Cons was Empty, and then it would give you a bound variable 'x'
01:53:45 <ddarius> vim's help is excellent
01:53:58 * hackagebot ansi-wl-pprint 0.6.1 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.1 (MaxBolingbroke)
01:54:07 <pelotom> DontGetHaskell: if you say show x = ..., it will match anything, because you're not giving a pattern
01:54:08 <solistic> ddarius: it is, but you have to learn how to navigate it first
01:54:20 <DontGetHaskell> so ok pelotom and ski: back to the drawing board, so my constructors are Empty and Cons a (List a) right?
01:54:29 <pelotom> DontGetHaskell: yep
01:54:38 <ski> that's how they're declared in the `data'-declaration, yes
01:54:55 <pelotom> DontGetHaskell: so all your patterns will be combinations of those 2
01:54:56 <DontGetHaskell> So I match Empty with []
01:55:03 <pelotom> DontGetHaskell: no
01:55:05 <DontGetHaskell> that ok right
01:55:11 <pelotom> DontGetHaskell: don't try to convert this to a regular list
01:55:28 <pelotom> DontGetHaskell: oh, unless you're building a [Char]
01:55:36 <ddarius> Which is fortuitously the very first thing described when you type :help, a command which itself is described when you start vim.
01:55:37 <pelotom> DontGetHaskell: you're trying to build a String
01:55:37 <ski> DontGetHaskell : and that means that when pattern-matching, you can have one case `show Empty = ...'
01:55:43 <ddarius> And of course there's vimtutor.
01:55:45 <DontGetHaskell> yes 
01:56:05 <ski> DontGetHaskell : and another case `show (Cons .. ..) = ...' where the two `..' will be any patterns, typically variable names, so `show (Cons x xs) = ...' or `show (Cons cat food) = ...',&c.
01:56:44 <DontGetHaskell> show Empty = "{}"
01:57:09 <ski> DontGetHaskell : so, your first `show Empty = "{}"' will work ok
01:57:19 <ski> the problem is how to do the other case
01:57:28 <ski>   show (Cons x xs) = ...
01:57:35 <DontGetHaskell> ya that were I am stuck
01:57:52 <ski> to take a simple example, what do you want `show (Cons 2 Empty)' to return ?
01:57:53 <pelotom> DontGetHaskell: I recommend you not worry about the {}s to start with
01:57:58 <pelotom> it will be easier that way
01:58:55 <DontGetHaskell> ski: something like {a}
01:59:08 <ski> why not `"{2}"' ?
01:59:28 <DontGetHaskell> that what I meant sorry
01:59:33 <ski> ok
01:59:51 <ski> so, to convert the number `2' to the string `"2"' you can use `show 2'
01:59:55 <ski> so, in the
01:59:58 <ski>   show (Cons x xs) = ...
02:00:00 <ski> case
02:00:16 <ski> if `x' is the number `2', then what do you need to write to get the string `"2"' ?
02:01:44 <DontGetHaskell> ski: why can't I use the "x Cons Empty"
02:01:55 <DontGetHaskell> where Cons is equal to :
02:02:08 <ski> do you mean, why you can't say
02:02:13 <ski>   show (Cons x Empty) = ...
02:02:13 <DontGetHaskell> ya 
02:02:15 <ski> ?
02:02:19 <ski> well, you *can*
02:02:42 <ski> but then that only handles lists of length one (and of length zero, because you also had a case for `Empty')
02:02:52 <ski> but then how will you handle lists of length two ?
02:02:56 <ski> of length three ?
02:02:59 <ski> writing
02:03:04 <ski>   show Empty = ...
02:03:12 <ski>   show (Cons x Empty) = ...
02:03:19 <ski>   show (Cons x0 (Cons x1 Empty)) = ...
02:03:27 <ski>   show (Cons x0 (Cons x1 (Cons x2 Empty))) = ...
02:03:29 <ski>   ...
02:03:35 <DontGetHaskell> ski: doesnt Cons handle 2 args
02:03:41 <ski> you'll soon realize that by this strategy, you'll never get done
02:03:54 <DontGetHaskell> ya 
02:04:00 * hackagebot ansi-wl-pprint 0.6.2 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.2 (MaxBolingbroke)
02:04:08 <DontGetHaskell> I c that wont work
02:04:10 <pelotom> ski: I think in this case it is reasonable to match Cons x Empty though... I see this function as having 3 equations
02:04:16 <ski> a list of the `Cons'-shape consists of two main parts, yes : the head (first element) and the tail (the list of the rest of the elements, possible an empty list)
02:04:52 <ski> pelotom : maybe, maybe not .. we don't know yet :)
02:05:35 <ski> (well, of course i know, but the point is to show DontGetHaskell how to reason about it, and try things out)
02:05:46 <pelotom> ski: fair enough :)
02:06:19 <mlesniak> Great to see that my question is already answered in the topic :)
02:06:28 <ski> DontGetHaskell : so, to get anywhere, we have to start matching on lists where the length of the list isn't determined completely by the pattern
02:06:35 <Entroacceptor> mlesniak: that's why it's there ;)
02:06:41 <mlesniak> :D
02:06:52 <pelotom> mlesniak: it doesn't answer the real question though, which is "why?" :P
02:07:01 * hackagebot ansi-wl-pprint 0.6.3 - The Wadler/Leijen Pretty Printer for colored ANSI terminal output  http://hackage.haskell.org/package/ansi-wl-pprint-0.6.3 (MaxBolingbroke)
02:07:04 <ski> DontGetHaskell : so, either we need a `show (Cons x xs) = ...' case .. or maybe a `show (Cons x0 (Cons x1 xs)) = ...' case (or longer)
02:07:05 <pelotom> anyone can tell it's down
02:07:12 <mlesniak> pelotom: Why is not as important as for how long ;)
02:07:16 <mlesniak> (at least for me)
02:07:21 <pelotom> mlesniak: yeah, or that
02:07:23 <DontGetHaskell> so thats why i need a variable like toList
02:07:33 <ski> DontGetHaskell : the point being that we want a pattern that will match a few initial elements, and then put all the rest of the list into a variable like `xs'
02:07:54 <ski> DontGetHaskell : no, the exercise specifically asks you *not* to use something like `toList'
02:08:11 <DontGetHaskell> yes thats I want
02:08:34 <ski> DontGetHaskell : `toList' converts from your "special lists with `Empty' and `Cons'" to the ordinary Haskell lists with `[]' and `(:)'
02:08:55 <ski> and you're probably not allowed to do that, because that would make it too easy, so you wouldn't learn as much
02:09:20 <ski> so, forget about `toList' and `[]' and `(:)' for a while, now
02:09:49 <ski> think only in terms of your `Empty' and `Cons' -lists, and of the strings you want to build from them
02:10:07 <ski> ok ?
02:11:08 <DontGetHaskell> ok
02:12:46 <ski> (back, i just grabbed something to eat)
02:12:58 <ski> so
02:13:02 * hackagebot uuagc 0.9.31 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.31 (ArieMiddelkoop)
02:13:05 <DontGetHaskell> ski or pelotom: for the right side I wouldn't call show again right? I just want to make sure
02:13:18 <pelotom> DontGetHaskell: why not?
02:13:24 <ski> well, you probably would
02:13:33 <ski> you're trying to define a recursive function
02:13:40 <DontGetHaskell> yes 
02:14:02 <ski> (because you want to be able to handle lists of any length, so you need recursion to loop through the lists)
02:14:18 <mjrosenb> @pl f pts = (maximim (map fst pts) - minimum (map fst pts), maximum (map snd pts) - minimum (map snd pts))
02:14:18 <lambdabot> f = ap ((,) . ap ((-) . maximim . map fst) (minimum . map fst)) (ap ((-) . maximum . map snd) (minimum . map snd))
02:14:26 <ski> now, you could try to write this in more than one way
02:14:43 <mjrosenb> @unpl f pts = (maximim (map fst pts) - minimum (map fst pts), maximum (map snd pts) - minimum (map snd pts))
02:14:43 <lambdabot> f pts = (((maximim (map fst pts)) - (minimum (map fst pts))), ((maximum (map snd pts)) - (minimum (map snd pts))))
02:14:46 <ski> you could (a) try to think carefully about what result you want, and try to reason about how to write the recursion
02:14:57 <mjrosenb> why do i bother asking lambdabot?
02:14:58 <pelotom> DontGetHaskell: there's a reason that your Show instance depends on a Show instance for the type of the elements of the list... you need to use that somehow
02:15:13 <DontGetHaskell> show (Cons x xs)= show (Cons x xs (Cons x Empty))
02:15:20 <ski> DontGetHaskell : or you could (b) try to write something that looks more or less right, try it out, and if it doesn't work, try to understand how to fix it
02:15:40 <ski> DontGetHaskell : ok, that definitely will *not* work :)
02:15:48 <ski> consider how that will evaluate :
02:16:07 <ski> actually, that's even type-incorrect
02:16:21 <ski> the outer `Cons' doesn't want three arguments, it wants only two
02:16:42 <DontGetHaskell> o ya
02:16:50 <ski> mjrosenb : s/maximim/maximum/ ?
02:16:57 <pelotom> DontGetHaskell: remember that you're trying to produce a String... so the right hand side should evaluate to a String
02:16:59 <ski> so, try again ?
02:17:32 <DontGetHaskell> I am even thinking it correctly
02:17:45 <DontGetHaskell> or on the right track
02:17:49 <DontGetHaskell> ?
02:18:03 * hackagebot flock 0.2.3 - Wrapper for flock(2)  http://hackage.haskell.org/package/flock-0.2.3 (ErikHesselink)
02:19:15 <ski> mjrosenb : `(join (***) (uncurry (-) . (maximum &&& minimum)) . unzip) pts' ?
02:19:25 <pelotom> DontGetHaskell: also the right hand side should be *simpler* than the pattern you matched on the left... you don't want to recursively call show on a longer list than you had before
02:19:50 <DontGetHaskell> show (Cons x xs)= show . ? 
02:19:51 <ski> yeah, that's what i was about to show, before i saw the type error :)
02:20:00 <Phyx-> :t (===)
02:20:01 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
02:20:10 <Phyx-> :t foldr (===)
02:20:10 <ski> @index (===)
02:20:11 <lambdabot> forall a. (Typeable a) => Bool -> [a] -> Bool
02:20:11 <lambdabot> bzzt
02:20:20 <Phyx-> :t foldr (===) True []
02:20:20 <lambdabot>     Ambiguous type variable `a' in the constraint:
02:20:21 <lambdabot>       `Typeable a' arising from a use of `===' at <interactive>:1:6-10
02:20:21 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
02:20:24 <Phyx-> :t foldr (===) True 
02:20:25 <lambdabot> forall a. (Typeable a) => [a] -> Bool
02:20:32 <Phyx-> :t foldr (===) True [1]
02:20:33 <lambdabot> Bool
02:20:33 <pelotom> DontGetHaskell: when you match (Cons x xs), what are the types of x and xs respectively?
02:20:39 <Phyx-> > foldr (===) True [1]
02:20:40 <lambdabot>   False
02:20:44 <mjrosenb> ski: yeah, that looks reasonable
02:20:46 <Phyx-> > foldr (===) True [1,1]
02:20:47 <lambdabot>   False
02:20:50 <DontGetHaskell> pelotom or ski: there a way to find out what type I need
02:20:54 <mjrosenb> ski: i can never remember the arrow operators :(
02:20:55 <DontGetHaskell> not sure right now
02:20:57 <Phyx-> > foldr (===) True [True]
02:20:58 <lambdabot>   True
02:21:04 <Phyx-> > foldr (===) True [True, False]
02:21:05 <lambdabot>   False
02:21:07 <pelotom> DontGetHaskell: just look at the definition of your data type
02:21:11 <ski> Phyx- : that doesn't look like what you probably want (it will compare `a's with `Bool's)
02:21:18 <pelotom> DontGetHaskell: your custom list type
02:21:52 <pelotom> DontGetHaskell: if you matched (Cons x xs), x and xs must have a certain type as dictated by the type of the constructor
02:21:53 <DontGetHaskell> of type a
02:21:53 <ski> mjrosenb : most are simple, if you know some basic category theory
02:22:00 <Phyx-> ski: yeah, I went to bed playing with it, wanted, just realised why [] didn't work and wanted to try it
02:22:15 <pelotom> DontGetHaskell: ok, x is some type a, yes
02:22:22 <pelotom> is of some type*
02:22:29 <pelotom> DontGetHaskell: and xs?
02:22:53 <Phyx-> @src Dynamic
02:22:54 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:23:01 <Phyx-> @src toDyn
02:23:01 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
02:23:02 <DontGetHaskell> xs is a List of a
02:23:15 <ski> DontGetHaskell : yes
02:23:17 <Phyx-> oh, smart, saves the type too
02:23:17 <pelotom> DontGetHaskell: exactly!
02:23:23 <ski> i.e. the type of `xs' is `List a'
02:23:38 <ski> Phyx- : how else would it work .. ? :)
02:23:43 <pelotom> DontGetHaskell: so xs is a *simpler* list of the same type as (Cons x xs)
02:23:55 <ski> DontGetHaskell : you wrote before
02:23:57 <ski>   show (Cons x xs)= show (Cons x xs (Cons x Empty))
02:24:02 <ski> but maybe meant something like
02:24:05 <ski>   show (Cons x xs)= show (Cons x (Cons x Empty))
02:24:06 <ski> or
02:24:08 <ski>   show (Cons x xs)= show (Cons x (Cons x xs))
02:24:12 <Phyx-> ski: In my mind, I just thought it was some kinda of existential. and it just shoved it in there and tried to cast it on fetching the value
02:24:20 <ski> would you like to see *why* those are bad ?
02:24:53 <DontGetHaskell> ya
02:24:54 <ski> Phyx- : in `exists a. ..a..', one can't recover the type of `a' from that, at run-time
02:25:15 <ski> ok, let's assume that you had written the latter, and went on to evaluate `show (Cons 2 Empty)'
02:25:19 <ski> that would evaluate as :
02:25:27 <ski>      show (Cons 2 Empty)
02:25:29 <Phyx-> ski: right, but in fromDyn :: Dynamic -> a, you request it to be a type, so you could try to cast it to a, if it succeeds return it
02:25:37 <ski>   =  show (Cons 2 (Cons 2 Empty))
02:25:40 <ski>   =  show (Cons 2 (Cons 2 (Cons 2 Empty)))
02:25:43 <ski>   =  show (Cons 2 (Cons 2 (Cons 2 (Cons 2 Empty))))
02:25:45 <ski>   =  ...
02:25:46 <Phyx-> :t fromDyn
02:25:47 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
02:25:51 <ski> so, that would never end
02:26:19 <ski> (similarly if you had `Empty' instead of `xs', except that instead of growing larger, it just stays the same, but doesn't end anyway)
02:26:39 <Phyx-> hmm, with scoped variables that extra argument isn't needed is it?
02:26:43 <DontGetHaskell> so is it looping
02:26:57 <ski> DontGetHaskell : so, what you want for your recursion, is to make sure that you recursively call your function (i.e. `show') on a *smaller* list than the list `Cons x xs' which is the current input
02:27:18 <ski> @type fromDynamic  -- Phyx- ?
02:27:18 <lambdabot> forall a. (Typeable a) => Dynamic -> Maybe a
02:27:49 <ski> Phyx- : `fromDyn' uses a default, while `fromDynamic' instead uses `Maybe'
02:27:57 <Phyx-> ski: ah, I meant that one :)
02:28:19 <Phyx-> ah ok
02:28:31 <Phyx-> i've never really used Dynamic,
02:28:33 <ski> @type (`fromDyn` error "my feet hurts !")
02:28:34 <lambdabot> forall a. (Typeable a) => Dynamic -> a
02:28:39 <pelotom> DontGetHaskell: have you dealt with recursion in other languages?
02:28:46 <DontGetHaskell> ski or pelotom: side question..  do my equal signs have to line up?
02:28:59 <DontGetHaskell> yes Java
02:29:05 <ski> DontGetHaskell : no they don't, but i generally think it's more pretty, if they do
02:29:08 <DontGetHaskell> and I hated it then too
02:29:08 <DontGetHaskell> haha
02:29:13 <ski> DontGetHaskell : it's up to you (and your examiner)
02:29:39 <pelotom> DontGetHaskell: ok, so you know what a base case is, right?
02:30:03 <ski> the good thing about Haskell here is that there is no `for' or `while' -loops, so you *have* to learn to use recursion properly :)
02:30:06 <Phyx-> maybe he got induction in a math course
02:30:34 <ski> (and yes, there's `until',`forM', &c. ..)
02:30:36 <pelotom> ski: or fold :)
02:30:50 <Phyx-> folds == foreach
02:31:13 <ski> (`map' or `mapM' is more similar to folds, imo)
02:31:20 <Entroacceptor> maybe I can chime in with a different approach?
02:31:35 <DontGetHaskell> pelotom: yes I do
02:31:35 <pelotom> Entroacceptor: have at it :)
02:31:45 <ski> DontGetHaskell : so, considering `show (Cons x xs) = ...'
02:31:59 <Entroacceptor> you have show (Cons x xs), so there's something of type a and something of type List a to show
02:32:05 <ski> DontGetHaskell : what is a smaller list than `Cons x xs', that you might feed to `show', in a recursive call ?
02:32:37 <DontGetHaskell> ski: Empty
02:32:47 <Entroacceptor> DontGetHaskell: how do you convert something of type a into a string?
02:32:49 <pelotom> DontGetHaskell: too small ;)
02:33:06 <ski> yes .. but consider that you want to show e.g. `Cons 0 (Cons 1 (Cons 2 Empty))'
02:33:11 <ski> i.e. you call
02:33:15 <pelotom> DontGetHaskell: a *slightly* simpler list than Cons x xs ...
02:33:18 <ski>   show (Cons 0 (Cons 1 (Cons 2 Empty)))
02:33:21 <Phyx-> I feel like slapping the google
02:33:25 <ski> so, this will match your
02:33:31 <ski>   show (Cons x xs) = ...
02:33:36 <DontGetHaskell> Entroacceptor:  show
02:33:44 <ski> case, and then, for this call, you will have
02:33:49 <ski>   x  = 0
02:33:54 <ski>   xs = Cons 1 (Cons 2 Empty)
02:34:18 <DontGetHaskell> ski: are u talking about the head
02:34:30 <ski> so, what you want here is to show the `0', and also show the `Cons 1 (Cons 2 Empty)', to get a final result `"{0,1,2}"'
02:34:46 <DontGetHaskell> yes
02:34:56 <ski> `show (Cons x xs)' is the head of the defining clause/equation `show (Cons x xs) = ...' for `show', yes
02:35:03 * pelotom thinks there are plenty of cooks in this kitchen without him, and bows out :)
02:35:13 <ski> (and `x' is the head of the list `Cons x xs' .. that's a different use of the word "head")
02:35:38 <DontGetHaskell> thanks pelotom 
02:35:51 <pelotom> DontGetHaskell: keep at it, you'll get it!
02:36:13 <ski> so, one of things about recursion is that you have to "trust" it
02:36:42 <ski> you want to call `show' recursively .. to be able to "loop" over the list
02:37:19 <DontGetHaskell> ski: x show xs 
02:37:21 <ski> and, as i showed above, you need to call it recursively on a smaller list than the current input (i.e. `Cons x xs'), otherwise you'll not get nearer the base case, so it well never end
02:37:28 <DontGetHaskell> that does make sense
02:37:33 <ski> so, yes, `show xs' makes sense
02:37:36 <DontGetHaskell> doesnt*
02:37:40 <Mitar> in haddock, how can i add text just bellow a section heading?
02:37:47 <ski> `xs' is a smaller list than `Cons x xs'
02:38:07 <DontGetHaskell> by one element
02:38:16 <ski> in the case above, where we called `show (Cons 0 (Cons 1 (Cons 2 Empty)))', then `xs' is the list `Cons 1 (Cons 2 Empty)'
02:38:26 <ski> so then that recursive call will be `show (Cons 1 (Cons 2 Empty))'
02:38:38 <ski> and then in the next recursive call it will be `Cons 2 Empty'
02:38:55 <ski> and the next recursive call will be `show Empty', which is the base case, so the recursion will end
02:39:06 <ski> DontGetHaskell : so, what you have so far, is
02:39:18 <ski>   show (Cons x xs) = ..x..(show xs)..
02:39:30 <ski> the `..' meaning that we have to figure out what to put in there
02:39:49 <ski> we know we want `show xs' in there, and we also need `x' in there (since we want to show that as well)
02:39:51 <DontGetHaskell> I need to fill the dots right
02:39:54 <ski> yeah
02:40:14 <ski> do you have a suggestion for how to do that ?
02:40:24 <ski> remember that you want to create a string
02:40:44 <ski> and `show xs' will give a string back for you (you have to trust it works correctly)
02:41:32 <ski> but `x' is not a string, it is a number in the example above (namely `0')
02:41:35 <DontGetHaskell> question do I those .... I think there called infixes
02:41:47 <DontGetHaskell> do I need those *
02:41:57 <ski> `*' is multiplication
02:42:06 <ski> i don't think you will need to multiply numbers with each others
02:42:15 <dafis> Mitar: in the export list, -- * Section Header, on the next line -- $commentForSection, and then write the comment in the file with the heading -- $commentForSection
02:42:26 <DontGetHaskell> ok
02:42:33 <ski> so, you need to figure out a way to turn `x' into a string
02:42:41 <Mitar> thanks
02:42:53 <Entroacceptor> DontGetHaskell: if you use infix or prefix functions is purely an aesthetic choice, they're equivalent 
02:43:09 <ski> and then how to fit those two strings (one from `x' and one from `xs', i.e. `show xs') together into a larger string that is the proper `show' of `Cons x xs'
02:43:12 <DontGetHaskell> ok thanks
02:43:33 <ski> so, how do you turn `x' (think "a number") into a string ?
02:44:03 <DontGetHaskell> can't I just put show in front of it
02:44:09 <ski> sure you can :)
02:44:12 <ski> > show 0
02:44:13 <lambdabot>   "0"
02:44:19 <ski> > let x = 42 in  show x
02:44:20 <lambdabot>   "42"
02:44:24 <ski> so, now you have
02:44:31 <ski>   show (Cons x xs) = ..(show x)..(show xs)..
02:44:43 <DontGetHaskell> so that what I want right
02:44:50 <DontGetHaskell> ya
02:44:59 <ski> (btw, note that the `show' before `x' is not "your" `show' .. it is another show, for numbers (or whatever elements you have))
02:45:13 <ski> so .. now you have two strings `show x' and `show xs'
02:45:21 <ski> let's consider the case
02:45:29 <ski>   show (Cons 0 (Cons 1 (Cons 2 Empty)))
02:45:30 <ski> again
02:45:33 <ski> in this case, we have
02:45:36 <ski>   x  = 0
02:45:41 <ski>   xs = Cons 1 (Cons 2 Empty)
02:45:52 <ski> and, then your two `show' calls will evaluate as
02:46:05 <ski>   show x  =  show 0  =  "0"
02:46:28 <ski>   show xs =  show (Cons 1 (Cons 2 Empty))  =  "{1,2}"
02:46:33 <DontGetHaskell> for my problem dont I need { }
02:46:47 <ski> that last step you have to just trust the recursion to "do the right thing"
02:46:52 <ski> yes
02:47:01 <ski> so, you want to piece together several strings
02:47:04 <ski> how do you do that ?
02:47:51 <ski> how to you concatenate/append two (or more) strings together into a single string ?
02:48:27 <DontGetHaskell> can I use concat
02:48:32 <ski> you can
02:48:40 <DontGetHaskell> but...
02:48:45 <ski> yes ?
02:49:08 <DontGetHaskell> o I thought there was a but coming ok
02:49:49 <DontGetHaskell> so do I concat between show x and show xs
02:49:59 <DontGetHaskell> or ++
02:50:02 <ski> well, how do you suggest using `concat' in the defining equation
02:50:03 <ski>   show (Cons x xs) = ..(show x)..(show xs)..
02:50:03 <ski> ?
02:50:09 <ski> > "abc" concat "def"
02:50:10 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t'
02:50:10 <lambdabot>         against inferred type ...
02:50:15 <ski> that doesn't work
02:50:19 <ski> > "abc" ++ "def"
02:50:20 <lambdabot>   "abcdef"
02:50:20 <ski> works
02:50:29 <ski> > concat ["abc","def"]
02:50:29 <lambdabot>   "abcdef"
02:50:30 <ski> also works
02:50:34 <ski> ok ?
02:51:04 <DontGetHaskell> hmmm so I have 2 choices
02:51:14 <Entroacceptor> > "abc" `concat` "def"
02:51:15 <lambdabot>   Couldn't match expected type `[a]'
02:51:15 <lambdabot>         against inferred type `GHC.Types...
02:51:28 <ski> it doesn't really matter that much which variant you do, as long as you decide on one
02:51:53 <Entroacceptor> > ("abc"::Char) `concat` "def"
02:51:53 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
02:51:53 <lambdabot>         against inferred type...
02:52:12 <DontGetHaskell> show x ++ (show xs)
02:52:16 <ski> Entroacceptor : `concat' doesn't want two arguments
02:52:25 <ski> DontGetHaskell : yes, or even `show x ++ show xs'
02:52:28 <ski> so
02:52:39 <ski>   show (Cons x xs) = show x ++ show xs
02:52:44 <ski> shall we try this out ?
02:52:48 <Entroacceptor> oh :(
02:52:50 <DontGetHaskell> ya
02:52:53 <ski> ok
02:53:21 <ski> i'll rename your `show' to `showList' in lambdabot, since i can't do `instance Show a => Show (List a) where ...' there
02:53:27 <ski> otherwise, it will be just the same
02:53:40 <DontGetHaskell> ok 
02:53:42 <ski> i'll also use `let ..definition here.. in ..testing here..'
02:54:08 <ski> oh, one more thing
02:54:11 <DontGetHaskell> ok I still get error on compiler though
02:54:32 <DontGetHaskell> ski: yes ?
02:54:47 <ski> i can't teach lambdabot about `Empty' and `Cons', so, just in lambdabot i'll use `[]' and `(:)' instead .. imagine i'm really writing `Empty' and `Cons' !
02:55:11 <DontGetHaskell> ok
02:55:13 <ski> (that's a little inconvenient, but can't be helped, if i want to show using lambdabot)
02:55:50 <ski> > let showList [] = "{}"; showList ((:) x xs) = show x ++ showList xs  in  showList ((:) 0 ((:) 1 ((:) 2 [])))
02:55:51 <lambdabot>   "012{}"
02:56:29 <ski> that's the example i had above, and the code you have now, only converting `Empty' and `Cons' to `[]' and `(:)'
02:57:05 <ski> (note that i changed "your" `show' to `showList', but not the "number" `show' which was called on `x')
02:57:20 <DontGetHaskell> ski: when I run this example ...  3 :-: 4 :-: 5 :-: Empty  I get out of scope error
02:57:26 <ski> so, since we didn't get `"{0,1,2}"' as we wanted, we know there's still things to fix in the code
02:57:41 <ski> .. oh
02:57:54 * ski didn't see that `3 :-: 4 :-: 5 :-: Empty' line before
02:58:08 <DontGetHaskell> haha its cool
02:58:12 <ski> apparently, the exercise wants you to use `x :-: xs' instead of `Cons x xs'
02:58:21 <ski> that's just naming .. it's basically the same thing
02:58:46 <ski> so, if you want to use `:-:', instead of `Cons', you'll need to define `List' instead as
02:59:07 <ski>   data List a = Empty
02:59:16 <ski>               | a :-: List a
02:59:18 <ski>                 deriving (Read, Eq, Ord) 
02:59:41 <ski> (the indentation is not necessary, i just find that nicer to read)
02:59:53 <ski> and then your code is now
03:00:02 <Entroacceptor> (and you probably don't want 'read' in there)
03:00:15 <ski>   show  Empty      = "{}"
03:00:28 <ski>   show (Cons x xs) = show x ++ show xs
03:00:36 <ski> (aligning `=' for prettiness)
03:00:52 <dafis> > let showList [] = "{}"; showList (x:xs) = let showl [] = "}"; showl (y:ys) = showChar ',' . shows y $ showl ys in showChar '{' . shows x (showL xs) in showList [0,1,2]
03:00:53 <ski> er, sorry, forgot to change to `:-:' :P
03:00:53 <lambdabot>   Not in scope: `showL'
03:01:10 <ski>   show  Empty     = "{}"
03:01:16 <dafis> > let showList [] = "{}"; showList (x:xs) = let showl [] = "}"; showl (y:ys) = showChar ',' . shows y $ showl ys in showChar '{' . shows x (showl xs) in showList [0,1,2]
03:01:16 <ski>   show (x :-: xs) = show x ++ show xs
03:01:17 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
03:01:17 <lambdabot>         against inferred ty...
03:01:33 <ski> Entroacceptor : i have no idea about that ..
03:01:55 <dafis> > let showList [] = "{}"; showList (x:xs) = let showl [] = "}"; showl (y:ys) = showChar ',' . shows y $ showl ys in showChar '{' . shows x $ showl xs in showList [0,1,2]
03:01:56 <lambdabot>   "{0,1,2}"
03:02:14 <ski> DontGetHaskell : anyway, using that code, changing `Empty' and `:-:' into `[]' and `:' for lambdabot's sake, we had
03:02:23 <ski> > let showList [] = "{}"; showList ((:) x xs) = show x ++ showList xs  in  showList ((:) 0 ((:) 1 ((:) 2 [])))
03:02:24 <lambdabot>   "012{}"
03:02:53 <ski> (dafis : bad boy/girl, you're not supposed to do DontGetHaskell's exercise for him/her !)
03:03:16 <ski> DontGetHaskell : so, can you name at least one thing that's wrong with the output `"012{}"' ?
03:03:22 <dafis> Oops, sorry, not yet quite awake
03:03:24 <Entroacceptor> ski: use "bad sentinence" or "bad person" :)
03:03:50 <ski> Entroacceptor : i suppose .. it's not got quite the same ring to it, though :/
03:03:58 <dafis> Entroacceptor: in my case, dirty old man ;)
03:03:59 * ski blames english
03:04:31 * ski idly wonders whether DontGetHaskell has been lost in action ..
03:04:41 <DontGetHaskell> should it be {0,1,2}
03:04:48 <DontGetHaskell> not that
03:04:54 <ski> yes, i would think so
03:05:01 <ski> but it's your exercise
03:05:14 <ski> you should (hopefully) be able to tell what the expected result is
03:05:15 <DontGetHaskell> so...
03:05:34 <ski> name at least one thing that's wrong with `"012{}"' !
03:05:56 <ski> (attack one bug at a time)
03:06:04 <freshnewpage> Anyone got the latest on the .org outage?
03:07:06 <benl23> It'd be nice if someone put up a page saying what happened, and when it might be back up.
03:07:09 <ski> (DontGetHaskell : of course, if you already have an idea of how to make the code better, you can immediately jump to showing a new version of the code)
03:07:21 <benl23> Could just point the DNS at a different server and add a virtual domain to apache
03:08:13 <freshnewpage> Yeah that would be a good idea.
03:09:08 <ski> (hm .. `cvs.haskell.org' seems to still work ..)
03:10:00 <ski> (.. though only `Hugs' appears to be on it)
03:10:25 <benl23> cvs is at galois
03:10:28 <ski> ok
03:10:34 <ski> DontGetHaskell : you've got an idea ?
03:10:38 <benl23> I think it's a differnet machine
03:10:48 <ski> i suppose so
03:10:55 <freshnewpage> 'sudo apt-get install haskell-doc' was my friend this weekend to let me browse file:///usr/share/doc/haskell98-tutorial/html/index.html and file:///usr/share/doc/haskell98-report/html/index.html
03:12:34 <DontGetHaskell> ski: could I use "{
03:12:38 <DontGetHaskell> "
03:13:37 <ski> DontGetHaskell : yes
03:14:07 <DontGetHaskell> "{" ++ show x  ++ show xs ++ "}"
03:14:13 <DontGetHaskell> something like that
03:14:54 <ski> let's try it ?
03:15:03 <ski> i.e. trying
03:15:15 <ski>   show  Empty     = "{}"
03:15:23 <ski>   show (x :-: xs) = "{" ++ show x ++ show xs ++ "}"
03:15:33 <ski> asking lambdabot
03:15:50 <ski> > let showList [] = "{}"; showList ((:) x xs) = "{" ++ show x ++ showList xs ++ "}"  in  showList ((:) 0 ((:) 1 ((:) 2 [])))
03:15:51 <lambdabot>   "{0{1{2{}}}}"
03:16:01 <ski> that's not quite right, either
03:16:04 <DontGetHaskell> ski: I get a big error
03:16:22 <ski> also, there's something else missing, not just that the placements of the `{'s and `}'s are wrong
03:16:32 <ski> what error do you get ?
03:16:40 <DontGetHaskell> I will paste it
03:17:03 <ski> DontGetHaskell : please annotate on the original paste
03:17:52 <ski> hm .. i suppose asking
03:18:12 <ski> > let showList [] = "{}"; showList (x : xs) = "{" ++ show x ++ showList xs ++ "}"  in  showList (0 : (1 : (2 : [])))
03:18:13 <lambdabot>   "{0{1{2{}}}}"
03:18:33 <ski> would be more consistent with replacing `Empty' and `:-:' with `[]' and `:', for lambdabot's sake
03:18:42 <ski> same answer still though, of course
03:19:42 <DontGetHaskell> ski: http://hpaste.org/paste/41485/define_show#p41489
03:19:49 <ski> DontGetHaskell : please add `infixr 5 :-:' to get `:-:' to be right-associative
03:20:34 <DontGetHaskell> everywhere?
03:20:36 <ski> otherwise it will assume left-associative, so then `3 :-: 4 :-: 5 :-: Empty' will be interpreted as `((3 :-: 4) :-: 5) :-: Empty', rather than as `3 :-: (4 :-: (5 :-: Empty))', which is what you wanted
03:20:39 <ski> no
03:20:41 <ski> just put
03:20:44 <ski>   infixr 5 :-:
03:20:48 <ski> on a line by itself
03:20:59 <ski> e.g. just above or below the `data'-declaration
03:21:01 <DontGetHaskell> ok
03:21:50 <ski> (the `5' tells the precedence level .. since we have `infixr 5 :', i.e. `:' uses that precedence level, i think it makes sense to use the same level for your `:-:')
03:22:43 <ski> DontGetHaskell : do you get it running ?
03:23:54 <DontGetHaskell> ok its running, I need to fix the bug though
03:23:58 <ski> yeah
03:24:21 <ski> i expect you get `"{0{1{2{}}}}"' when you ask GHCi/Hugs, as well
03:24:28 <DontGetHaskell> yup
03:24:48 <ski> so, remember i said there's something else missing, apart from the `{'s and `}'s being wrong ?
03:24:56 <ski> what more is missing ?
03:25:28 <ski> (hint : what string would you *want* to get, in this example ?)
03:26:49 <DontGetHaskell> curious of if I put show outside the {...}
03:27:06 <ski> hm, how do you mean ?
03:27:48 <DontGetHaskell> show { show x ++ show xs}
03:28:05 <ski> that will probably not work
03:28:14 <ski> `show x ++ show xs' is already a string
03:28:18 <DontGetHaskell> haha just curious
03:28:21 <ski> you don't want to `show' that string
03:28:21 <DontGetHaskell> ok
03:28:29 <ski> well, it is valid code, but it's not what you want
03:28:55 <ski> > show ("{" ++ "0" ++ "{1{2{}}}" ++ "}")
03:28:56 <lambdabot>   "\"{0{1{2{}}}}\""
03:29:05 <DontGetHaskell> so I need to change something with show x ++ show xs
03:29:07 <ski> > "{" ++ "0" ++ "{1{2{}}}" ++ "}"
03:29:08 <lambdabot>   "{0{1{2{}}}}"
03:29:29 <ski> so, `show' on the string will add two extra `"' characters (written like `\"' inside the string)
03:29:32 <ski> yes
03:30:29 <ski> DontGetHaskell : so, do you see what else is missing ?
03:30:41 <ski> .. missing, to reach to goal `{0,1,2}', i.e.
03:31:24 <ski> DontGetHaskell : if you want, you can go back to the previous version, if that makes it clearer
03:31:25 <ski> i.e.
03:31:36 <ski>   show  Empty     = "{}"
03:31:44 <ski>   show (x :-: xs) = show x ++ show xs
03:31:50 <ski> that gives you
03:32:11 <ski> > let showList [] = "{}"; showList (x : xs) = show x ++ showList xs  in  showList (0 : (1 : (2 : [])))
03:32:12 <lambdabot>   "012{}"
03:32:15 <ski> (or simply
03:32:23 <ski> > let showList [] = "{}"; showList (x : xs) = show x ++ showList xs  in  showList (0 : 1 : 2 : [])
03:32:24 <ski> )
03:32:24 <lambdabot>   "012{}"
03:32:53 <ski> so .. what is missing to get from `"012{}"' to `"{0,1,2}"' .. *apart* from the `{' in the wrong place ?
03:32:57 <DontGetHaskell> to be honest I think that Empty needs to be in there
03:33:08 <DontGetHaskell> but I think I am off
03:33:38 <ski> (i'm not sure what you mean ..)
03:33:58 <DontGetHaskell> nevermind I think I was off
03:34:03 * ski still wonders whether DontGetHaskell can give any suggestion for what else is missing
03:34:43 <aleator> Hi, can quasiquotes produces top-level declarations?
03:34:55 <edgimar> where can I get a terse summary list of all of the basic (i.e. built-in) haskell operator syntax (e.g. $, -> , ...)?
03:35:18 <ski> edgimar : note that `$' is not built-in
03:35:44 <DontGetHaskell> ski: I still trying to figure it out
03:35:51 <edgimar> ok- that's what I'm trying to figure out -- I see a lot of code with lots of symbols, and I don't know what is and isn't standard.
03:36:42 * hackagebot hdaemonize 0.4.4 - Library to handle the details of writing daemons for UNIX  http://hackage.haskell.org/package/hdaemonize-0.4.4 (FrederickRoss)
03:36:45 <ski> edgimar : possibly Zvon at <http://zvon.org/other/haskell/Outputglobal/index.html>, under `Syntax' will show you what you're looking for
03:37:17 <ski> edgimar : `$' is standard, just like `head' and `length' are standard -- i.e. standard *library*
03:37:36 <ski> edgimar : `$' is not special magic syntax that you can't do yourself
03:37:44 <ski> DontGetHaskell : ok, no worry
03:38:24 <DontGetHaskell> ski: I want to put Empty in the code but I feel that is not right
03:38:26 <edgimar> ski: in other words, $ can be overridden / redefined?
03:39:43 <bz> Hello, friends! Could you give me advices about how to debug a module or package from hackage? I need to trace Network.Browser.browse and see how it's working. When I do `*Main> :break Network.Browser browse`, it says "module 'Network.Browser' is from another package; this command requires an interpreted module". 
03:41:10 <ski> edgimar : the keywords are `module',`import',`export',`where',`infix',`infixl',`infixr',`type',`data',`newtype',`deriving',`class',`instance',`let',`in',`if',`then',`else',`case',`of',`do',`default'
03:41:43 <Phyx-> o.O
03:42:23 <Phyx-> ski: atleast in terms os standard haskell :)
03:43:09 <edgimar> ski:  thanks for the Zvon link -- looks like what I'm looking for.  Is there an advantage to the "old" version of the site over the new one?
03:43:10 <ski> edgimar : the special symbols are `::',`=>',`=',`->',`<-',`\',`_',`@',`~',`|',`{',`;',`}',`(',`)',`[',`]',`..'
03:43:15 <DontGetHaskell> ski: what if I move the "{" around would that help the situation ?
03:43:18 <earthy> > let ($) a b = a = b in 1 $ 2
03:43:19 <lambdabot>   <no location info>: parse error on input `='
03:43:25 <earthy> > let ($) a b = a + b in 1 $ 2
03:43:26 <lambdabot>   3
03:43:27 <ski> edgimar : re "$ can be overridden / redefined?" : yes
03:43:42 <ski> (the term is "shadowed")
03:44:15 <ski> edgimar : re old vs. new Zvon : i don't know, i haven't looked there in a while, i only just now noticed there being a new one
03:44:31 <DontGetHaskell> ski: is type a missing ?
03:45:02 <ski> edgimar : another source is of course the Haskell report, which contains the definite authority on this .. but `www.haskell.org' is down right now :/
03:45:36 <DontGetHaskell> ski:   oh the :-: right 
03:45:57 <ski> edgimar : if i'm not forgetting any, those above should be the reserved words and symbols (at least in Haskell 98 .. not as sure about Haskell 2010 .. maybe they added `!' and something else ..)
03:46:07 <ski> edgimar : oh, right, `!' is also in Haskell98
03:46:42 <ski> DontGetHaskell : hm
03:47:03 <edgimar> ski: it seems that not all of the symbols you listed are on the Zvon site (at least under 'operators').
03:47:06 <ski> "move the \"{\" around" is one thing you'll need to do, somehow, yes
03:47:25 <ski> DontGetHaskell : i'm not sure what you mean by "is type a missing ?"
03:48:07 <ski> edgimar : where is this `operators' section ?
03:48:42 * ski is looking at the "old" version, for the record
03:48:50 <ski> (also, "Syntax reference is at alpha stage. Please, use with care.")
03:49:16 <DontGetHaskell> ski:  why don't I add the :-: thing
03:49:27 <ski> add how ?
03:49:28 <ski> where ?
03:49:28 <DontGetHaskell> I kinda of guessing know
03:50:00 <DontGetHaskell> on the line with the show x ++ show xs
03:50:08 <ski> edgimar : .. oh
03:51:10 <Mitar> is it OK to add -Wall to package's ghc-options?
03:51:57 <ski> edgimar : if you mean the "Operators" section that begins with "(!), (!!)", then that's not reserved symbols, but operators, which are defined in the standard library (but which you could shadow with your own definitions of them, if you want to)
03:53:20 <edgimar> ok.  so it seems that the new site lacks this 'syntax' section, so I'll refer to the old for now.
03:53:33 <ski> (edgimar : hm, i suppose i forgot to mention `,' as a reserved symbol, as well)
03:54:38 <ski> edgimar : if you look at <http://zvon.org/other/haskell/Outputsyntax/index.html>, and click the "keywords" link, then that appears to document most of the reserved words and symbols
03:55:37 <ski> (edgimar : when `www.haskell.org' gets back up, you can also look at the Haskell report, at
03:55:41 <ski> @where report
03:55:41 <lambdabot> http://www.haskell.org/onlinereport/
03:55:42 <ski> )
03:56:20 <ski> (maybe that's also up somewhere else, i'm not sure)
03:56:32 <edgimar> great - thanks for your help.  How large of a document is the 'haskell report'?
03:58:16 <ski> edgimar : for completeness, i see `hiding',`qualified' and `as' which i forgot about :) .. also note that `otherwise' and `return' mentioned there are *not* reserved words, but ordinary library operations
03:59:26 <ski> the Haskell report is not that large, i think
04:00:10 <ski> DontGetHaskell : so .. are you still at
04:00:18 <ski>   show  Empty     = "{}"
04:00:23 <ski>   show (x :-: xs) = show x ++ show xs
04:00:24 <ski> or
04:00:25 <ski>   show  Empty     = "{}"
04:00:33 <ski>   show (x :-: xs) = "{" ++ show x ++ show xs ++ "}"
04:00:33 <ski> ?
04:00:40 <DontGetHaskell> what about the []
04:00:44 <edgimar> ski: I was originally trying to find this info in the ghc user's guide, but didn't know where to find it...
04:00:47 <ski> which `[]' ?
04:00:48 <DontGetHaskell> i mean {}
04:01:39 <ski> edgimar : ok, the place to look at on `www.haskell.org' is the report, which lambdabot linked to above (you can also reach that from `http://www.haskell.org/', which gets you the wiki)
04:01:56 <ski> DontGetHaskell : yeah, that will also have to be fixed
04:02:15 <ski> > let showList [] = "{}"; showList (x : xs) = show x ++ showList xs  in  showList (0 : 1 : 2 : [])
04:02:16 <lambdabot>   "012{}"
04:02:27 <ski> the problem there is that the `{' is in the wrong place
04:02:42 <ski> maybe if you began by removing the `{' which appears in the wrong place ?
04:02:48 <DontGetHaskell> yes
04:02:50 <ski> DontGetHaskell : how would that look, in the code ?
04:02:53 <Mitar> i would like to use mapMaybe in a monadic context, like mapMaybe' monadicFunction [0..10]
04:03:03 <ski> @type mapMaybe
04:03:04 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
04:03:23 <ski> so you want `Monad m => (a -> m (Maybe b)) -> ([a] -> m [b])' ?
04:03:34 <Mitar> yes
04:04:16 <DontGetHaskell> ski: this is what I see, I see Empty in the middle 
04:04:51 <DontGetHaskell> since Empty is {}
04:05:17 <DontGetHaskell> then the numbers appending to it
04:05:22 <ski> Mitar : so if you try `mapMaybe foo list' you get `m [Maybe a]' .. so `liftM catMaybes (mapMaybe foo list)' will get you to `m [a]'
04:05:44 <ski> Mitar : so `mapMaybeM f as = liftM catMaybes (mapMaybe f as)'
04:05:54 <ski> @type let mapMaybeM f as = liftM catMaybes (mapMaybe f as) in mapMaybeM
04:05:55 <lambdabot> forall a a1. (a -> Maybe [Maybe a1]) -> [a] -> [[a1]]
04:06:02 <ski> hm, no that's not right
04:06:10 <ski> @type catMaybes
04:06:11 <lambdabot> forall a. [Maybe a] -> [a]
04:06:31 <ski> er, right
04:06:45 <ski> @type mapM
04:06:45 <DontGetHaskell> when I take the "{" that is what is left
04:06:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
04:06:59 <ski> @type let mapMaybeM f as = liftM catMaybes (mapM f as) in mapMaybeM
04:06:59 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m (Maybe a1)) -> [a] -> m [a1]
04:07:09 <ski> Mitar : that's it ^
04:07:45 <ski> DontGetHaskell : when you take the `{' what ?
04:07:48 <Mitar> @type let mapMaybeM f as = catMaybes <$> (mapM f as) in mapMaybeM
04:07:49 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => (a -> f (Maybe a1)) -> [a] -> f [a1]
04:08:18 <ski> if you use `liftM', then you avoid the extraneous `Functor' constraint
04:08:19 <Mitar> but to directly lift mapMaybe, this is not possible?
04:08:30 <ski> @type let mapMaybeM f as = catMaybes `liftM` mapM f as in mapMaybeM
04:08:31 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m (Maybe a1)) -> [a] -> m [a1]
04:08:34 <DontGetHaskell> ok I took the "{" out of the code, just that and run this  3 :-: 4 :-: 5 :-: Empty and got this 345{}}}}  cand
04:08:40 <ski> @type let mapMaybeM f as = return . catMaybes =<< mapM f as in mapMaybeM
04:08:41 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m (Maybe a1)) -> [a] -> m [a1]
04:08:52 <ski> DontGetHaskell : ok
04:08:53 <nlogax> is there a function that does `foo "hello" 2 -> "llohe"` ? i feel it should be in Data.List somewhere, maybe with a funny name :)
04:09:05 <ski> so your code now is
04:09:06 <ski>   show  Empty     = "{}"
04:09:11 <ski> er
04:09:12 <ski>   show  Empty     = "}"
04:09:18 <ski> hm, no
04:09:20 <ski>   show  Empty     = "{}"
04:09:24 <ski>   show (x :-: xs) = show x ++ show xs ++ "}"
04:09:41 <Jafet> rotate xs n = drop n xs ++ take n xs
04:09:51 <ski> nlogax : there might be some function called `rotate' in some library ..
04:10:07 <Jafet> If you were smarter, you'd flip the arguments
04:10:08 <ski>   rotate n as = back ++ front
04:10:10 <ski>     where
04:10:16 <ski>     (front,back) = splitAt n as
04:10:28 <Jafet> And do that.
04:10:52 <ski> DontGetHaskell : so, let's remove the `++ "}"' for the while as well, ok ?
04:10:55 <ski> i.e.
04:10:58 <ski>   show  Empty     = "{}"
04:11:02 <ski>   show (x :-: xs) = show x ++ show xs
04:11:03 <nlogax> yeah, i did yours, Jafet. just wondering if it's already defined somewhere
04:11:07 <DontGetHaskell> ya I did that
04:11:10 <nlogax> thanks Jafet and ski :)
04:11:18 <ski> DontGetHaskell : and what do you get, then ?
04:11:56 <DontGetHaskell> ski: 345{}
04:11:59 * ski is trying to break the "running around in circles" game we've been playing for a while
04:12:03 <ski> yes
04:12:06 <ski> so
04:12:13 <mjrosenb> is haskell.org own?
04:12:22 <ski> DontGetHaskell : i'm suggesting you now remove that remaining `{' as well
04:12:23 <ski> ok ?
04:12:29 <dafis> mjrosenb: yes
04:12:29 <ski> mjrosenb : yes, topic
04:12:30 <byorgey> mjrosenb: yes.
04:12:38 <mjrosenb> D'oh.
04:12:51 <DontGetHaskell> ya I did that and thats what I got
04:12:53 <DontGetHaskell> 345{}
04:12:58 * mjrosenb usually reads topics when he /joins, then never again :(
04:13:06 <ski> DontGetHaskell : there's still one `{' left in that
04:13:08 <ski> remove that one as well
04:13:16 <ski> (because it is in the wrong place)
04:13:17 <byorgey> mjrosenb: don't worry, me too =)
04:14:10 <ski> DontGetHaskell : do you see how to do that ?
04:14:22 <DontGetHaskell> I did I have  show (x :-: xs) =  show x ++ show xs
04:14:27 <ski> yes ..
04:14:30 <ski> and the `Empty' case ?
04:14:38 <DontGetHaskell> still there
04:14:45 <ski> what does it look like ?
04:15:05 <DontGetHaskell> are u saying I don't need the Empty case
04:15:08 <ski> no
04:15:16 <ski> i'm saying i want to see your current `Empty' case
04:15:31 <DontGetHaskell> show Empty = "{}" 
04:15:34 <ski> ok
04:15:42 <DontGetHaskell> I haven't change it
04:15:46 <DontGetHaskell> I thought that was ok
04:15:50 <ski> now look at the `{' in `"012{}"'
04:15:58 <ski> that `{' is caused by the `Empty' case
04:16:08 <ski> since there's no `{'s left in the other case
04:16:22 <ski> and the `{' in `"012{}"' is in the *wrong* place
04:16:26 <ski> so make it go away
04:16:29 <ski> pretty please ?
04:16:51 <DontGetHaskell> that would mean getting rid of the Empty case
04:17:09 <sipa1024> move the printing of { outside of the recursion
04:17:12 <sipa1024> you just do it once
04:17:17 <ski> (the `Empty' case was good before, as an *initial,rough* approximation of what you wanted .. now we're discovering it needs to be changed)
04:17:28 <ski> DontGetHaskell : no
04:17:38 <sipa1024> empty still needs to produce }
04:17:43 <ski> don't get rid of the `Empty' case -- get rid of the `{' in the `Empty' case
04:18:14 <DontGetHaskell> show Empty = "{" ++ "}" 
04:18:21 <ski> i still see a `{' in there
04:18:31 <DontGetHaskell> o get rid that one
04:18:39 <ski> that will behave exactly the same as the variant you had before
04:18:43 <ski> > "{" ++ "}"
04:18:44 <lambdabot>   "{}"
04:18:49 <DontGetHaskell> show Empty = ++ "}" 
04:18:56 <ski> since `"{" ++ "}" is the same as `"{}"'
04:19:02 <sipa1024> you know what ++ does, DontGetHaskell?
04:19:12 <ski> `++' is used to concatenate two strings
04:19:25 <ski> you only have one string there, so you can't use it there
04:19:32 <DontGetHaskell> show Empty = "}" 
04:19:36 <ski> exactly
04:19:45 <ski> now, try that, and report what you get now
04:20:08 <exDM69> @type (++)
04:20:09 <lambdabot> forall m. (Monoid m) => m -> m -> m
04:20:19 <ski> @type (Prelude.++)
04:20:20 <lambdabot> forall a. [a] -> [a] -> [a]
04:20:34 <byorgey> exDM69: lambdabot has a special generalized version of (++)
04:20:57 <ski> @src (++)
04:20:58 <lambdabot> []     ++ ys = ys
04:20:58 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
04:20:58 <lambdabot> -- OR
04:20:58 <lambdabot> xs ++ ys = foldr (:) ys xs
04:20:58 <exDM69> byorgey: what is it useful for? examples?
04:21:11 <byorgey> exDM69: what, the normal (++), or the specialized version?
04:21:15 <ski> > Just "abc" ++ Nothing ++ Just "de"
04:21:16 <lambdabot>   Just "abcde"
04:21:16 <byorgey> I mean, generalized
04:21:18 <Jafet> @instances Monoid
04:21:18 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
04:21:19 <DontGetHaskell> ski: 345}
04:21:25 <ski> DontGetHaskell : right
04:21:39 <exDM69> byorgey: the specialized one
04:21:44 <ski> DontGetHaskell : this is better than `"345{}"', since we didn't want the `{' in that place
04:21:52 <ski> DontGetHaskell : so it is closer to the goal
04:21:56 <DontGetHaskell> yes
04:21:56 <Eduard_Munteanu> Is there a way to override Prelude stuff without explicitly importing it qualified or hiding? I'd like to import Data.ByteString non-qualified and have that override Prelude stuff.
04:22:10 <byorgey> exDM69: well, it can be used to combine any two things of a type which is an instance of Monoid
04:22:14 <aavogt> Eduard_Munteanu: you can shadow Prelude definitions
04:22:15 <Eduard_Munteanu> Extensions are welcome.
04:22:24 <byorgey> exDM69: Monoid just means: things for which there is a way to combine two of them, and an identity element
04:22:37 <Eduard_Munteanu> aavogt: thanks, I'll look that up.
04:22:50 <aavogt> Eduard_Munteanu: extensions are as much work as importing the prelude qualified
04:23:00 <byorgey> exDM69: for example, integers can be added, and the identity for addition is zero
04:23:04 <exDM69> byorgey: thanks for a good description of monoid
04:23:12 <byorgey> > Sum 4 ++ Sum 6
04:23:13 <lambdabot>   Sum {getSum = 10}
04:23:25 <DontGetHaskell> ski: It seems like its not stopping correctly
04:23:46 <aavogt> Eduard_Munteanu: as in -XNoImplicitPrelude, probably needs you to mention the Prelude import...
04:23:47 <Eduard_Munteanu> aavogt: ah, so you're still proposing hiding/qualified
04:23:49 <DontGetHaskell> or not at the right point
04:23:50 <byorgey> exDM69: lists can be concatenated, and the identity is the empty list (that's the usual definition of (+))
04:23:54 <byorgey> exDM69: and so on
04:23:54 <ski> > sortBy (comparing length ++ compare) (words "The quick brown fox jumps over the lazy dog")
04:23:55 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
04:24:09 <byorgey> exDM69: whoops, I meant the usual definition of (++)
04:24:10 <ski> exDM69 : ^ that compares first by length, then by the usual string comparision
04:24:35 <sipa1024> :t comparing
04:24:35 <Eduard_Munteanu> aavogt: or will importing bytestring after Prelude override the latter?
04:24:36 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:24:36 <exDM69> byorgey: makes perfect sense
04:24:50 <ski> @type comparing fst
04:24:51 <lambdabot> forall a b. (Ord a) => (a, b) -> (a, b) -> Ordering
04:25:38 <aavogt> Eduard_Munteanu: no
04:25:44 <ski> DontGetHaskell : it is stopping, since you don't get a program that hangs (or infinite output)
04:25:59 <Eduard_Munteanu> Uh, then importing qualified is still the best option I guess.
04:26:00 <ski> DontGetHaskell : you get the `}' at the right place, but not the `{'
04:26:05 <aavogt> but   -XNoImplicitPrelude  stops the implicit  import Prelude
04:26:18 <aavogt> with lots of other side effects you're probably not wanting
04:26:27 <ski> DontGetHaskell : do you have any suggestion of where to place the `{' in the code, now that we know that it shouldn't be in the `Empty' case ?
04:27:34 <DontGetHaskell> ski: its own case
04:27:40 <DontGetHaskell> ?
04:27:44 <sipa1024> what case?
04:27:54 <sipa1024> what will you match on to know that you need a { ?
04:28:03 <ski> you have two cases, one for each basic shape of a list : empty and non-empty
04:28:25 <DontGetHaskell> ok yes
04:28:36 <ski> what alternative case had you in mind ?
04:28:52 <aavogt> if the string you're generating is actually a  String -> String,  you can prepend when you reach the end of your input
04:29:14 <DontGetHaskell> show ? = "{"
04:29:14 <ski> aavogt : too advanced for DontGetHaskell atm, i think :)
04:29:20 <ski> what is `?'
04:29:21 <DontGetHaskell> but wont work
04:29:26 <ski> which lists should it match ?
04:29:32 <aavogt> ski: it's pretty though :(
04:29:44 <ski> aavogt : sure :)
04:29:59 <ski> (but not incremental)
04:30:28 <ski> DontGetHaskell : previously, you had `{' in both the `Empty' and in the `x :-: xs' case
04:30:28 <aavogt> good point
04:30:35 <ski> now you've removed both
04:30:42 <ski> you know the first of them was bad
04:30:48 <ski> maybe the second one was ok ?
04:30:57 <ski> you could try it ?
04:31:00 <DontGetHaskell> so it does belong on that line with show x ....
04:31:13 <Eduard_Munteanu> Don't tell me DontGetHaskell was the one with the Show instance / toList stuff that took ages to figure :P
04:31:24 * ski is only suggesting DontGetHaskell to try things, at the moment
04:32:05 <ski> Eduard_Munteanu : hey, it can be hard to grasp recursion, if you've never been taught it well
04:33:21 <ski> DontGetHaskell : so .. what do you get ?
04:33:53 <byorgey> Eduard_Munteanu: let's stick to encouraging comments re: newcomers, please
04:33:55 <mjrosenb> what is the runtime of Data.Array.(//)?
04:34:08 <ski> @type (Data.Array.//)
04:34:09 <lambdabot> forall i e. (Ix i) => Array i e -> [(i, e)] -> Array i e
04:34:15 <byorgey> mjrosenb: it's O(1), as long as you don't inspect the output ;)
04:34:29 <Eduard_Munteanu> Ok, ok, don't jump on me, I actually tried to help him earlier today.
04:34:39 <mjrosenb> byorgey: and if i do n of those, and inspect the output?
04:34:40 <byorgey> Eduard_Munteanu: ok, noted =)
04:35:27 <ski> mjrosenb : it might be that `DiffArray' will be more useful in such cases .. (though people say that `DiffArray' is a bit slow)
04:35:51 <byorgey> mjrosenb: seriously, though, I think it is O(1), but subsequent accesses may start getting slower
04:35:57 <byorgey> I forget exactly how it is implemented
04:35:59 <DontGetHaskell> ski 3{4{5{}
04:36:06 <Eduard_Munteanu> I wasn't sure we would manage to make him write toList on his own, his teacher seemed to assume too much of them.
04:36:28 <Eduard_Munteanu> (and he often resorting to guessing.)
04:36:41 <ski> mjrosenb : `(Data.Array.//)' will copy to a new array, but `DiffArray' will instead mutate the array, and backdiff the input to refer to the mutated one, plus "patches" expressing the difference
04:36:48 <ski> DontGetHaskell : ok, fine
04:36:58 <ski> i expect you tried
04:37:15 <ski>   show  Empty     = "}"
04:37:24 <ski>   show (x :-: xs) = show x ++ "{" ++ show xs
04:37:26 <ski> now
04:37:32 <ski> (by my psychic powers)
04:37:44 <ski> if you want, you can try with
04:37:49 <DontGetHaskell> that what I did
04:37:53 <ski>   show (x :-: xs) = "{" ++ show x ++ show xs
04:37:55 <ski> instead
04:38:05 <Eduard_Munteanu> Regarding that... in my mind, if I use (//) in a certain way, say with UArrays, it's possible to make it just as good as mutable, right? For example, when counting character frequencies in a file.
04:38:12 <byorgey> Eduard_Munteanu: unfortunately there's a fine line between challenging your students and expecting too much of them. But teachers that do the latter are frustrating =(
04:38:14 <ski> and then you'll get `"{3{4{5}"' instead of `"3{4{5{}"'
04:38:41 <ski> DontGetHaskell : ok. so i wanted you to try this, to realize why this doesn't work
04:38:56 <Eduard_Munteanu> byorgey: yeah. I finally conceded it might be better to just give him the solution, and explain it.
04:39:07 <ski> DontGetHaskell : the problem is that the `x :-: xs' will be called over and over, as `show' is stepping down your list
04:39:12 <byorgey> Eduard_Munteanu: no, it won't be just as good as mutable
04:39:12 <Eduard_Munteanu> It just was too basic stuff to be broken into smaller pieces.
04:39:18 <byorgey> yeah.
04:39:26 <ski> DontGetHaskell : so, for every `:-:' in the input list, you'll get a `{' in the output string
04:39:44 <ski> DontGetHaskell : while what you really want is to get only a *single* `{', at the very start
04:39:55 <byorgey> Eduard_Munteanu: it's probably close to just as good if you only do a small number of updates.
04:40:03 <DontGetHaskell> ski: I was suppose to get this {3,4,5}
04:40:07 <ski> yes
04:40:24 <ski> DontGetHaskell : so, what you need to do, is to make sure the `{' only happen *once*
04:40:26 <Eduard_Munteanu> The code I'm referring to is...
04:40:29 <Eduard_Munteanu> getCounts xs = foldl' getCounts' (listArray (0, 255) [0, 0..]) xs where getCounts' arr x = arr // [(i, arr ! i + 1)] where i = fromEnum x
04:40:49 <ski> DontGetHaskell : so the `{' can't be in a recursive case, since then it will happen many times
04:40:50 <byorgey> Eduard_Munteanu: for counting character frequencies I wouldn't use an immutable array, I'd use Data.Map, or if speed really mattered, STUArray
04:41:01 <Eduard_Munteanu> Considering this is an UArray, won't memoization / strictness analysis be able to turn it into something like a mutable array?
04:41:06 <ski> DontGetHaskell : also, it can't be in the base case `Empty', since then it will be in the wrong place, as we've seen
04:41:20 <Eduard_Munteanu> Or where's exactly the difference between that and a mutable array?
04:41:21 <DontGetHaskell> ski: yes thats been my problem
04:41:25 <ski> DontGetHaskell : so, it can't be either in the base case, nor in the recursive case
04:41:43 <byorgey> Eduard_Munteanu: only if it can figure out that the old versions of the array won't be needed anymore, and I'm not sure it is clever enough for that
04:41:57 <DontGetHaskell> so can it be in own case?
04:42:20 <DontGetHaskell> or do I need to refine my data 
04:42:24 <ski> DontGetHaskell : now .. suppose you renamed your `show' to something else .. like `showRest' .. couldn't then `showRest' be recursive, but `show' not be, and `show' adds the `{' (*once*) ?
04:42:30 <Phyx-> hmm, is there any reason why doing substitution on a type can fail?
04:42:43 <Eduard_Munteanu> byorgey: I see, thanks. It's still waaaay faster and leaner than Data.Array, but it could be better.
04:42:56 <Eduard_Munteanu> I guess there's room for improvement, either there or using ByteStrings
04:43:32 <DontGetHaskell> then would I need to make that show x ++ show xs equal some variable
04:43:34 <byorgey> Eduard_Munteanu: try running it on big files using that method, Data.Map, and STUArray and profiling to see which is fastest
04:43:36 <Eduard_Munteanu> (actually Data.Array explodes on some inputs)
04:44:19 <ski> DontGetHaskell : i.e. `show' will be a "wrapper" (or "boss", if you prefer), who does almost no work, delegating most of it to the poor "worker", `showRest', which will actually walk through the list ?
04:44:25 <byorgey> Phyx-: I'm not sure what you are asking, can you give more context?
04:44:45 <ski> DontGetHaskell : what do you think about this plan ?
04:45:16 <Eduard_Munteanu> byorgey: I figure ByteString would compensate for boxing in Data.Map, although that's O(log N) I think compared to STUArray, so the latter might be better anyway.
04:45:33 <DontGetHaskell> let me understand this, so u want me to make an new show called showRest
04:45:35 <DontGetHaskell> ?
04:45:48 <ski> yea
04:45:55 <ski> renaming your old `show' to `showRest'
04:45:57 <Phyx-> byorgey: i'm just wondering why i made my subtitution on a SystemF type return a Maybe. I don't think [a:=t']t can ever really fail
04:46:17 <byorgey> Phyx-: ah, indeed, I would not expect that to be able to fail
04:46:18 <DontGetHaskell> so I will have to define showRest
04:46:22 <DontGetHaskell> or show
04:46:42 <ski> you only have to rename
04:46:47 <ski> and then define a new `show'
04:47:01 <byorgey> Phyx-: does your implementation ever return Nothing?  or have you not written the implementation yet?
04:47:12 <DontGetHaskell> so my second line should be called showRest?
04:47:22 <ski> hum, what is the second line ?
04:47:41 <Phyx-> byorgey: no, never, lol. and i always have to patternmatch on the result or do fromJust, which is why I'm wondering why I did it in the first place
04:47:49 <dafis> Eduard_Munteanu: for counting charcter frequencies and such, accumArray on a UArray ix Int is pretty good, it uses a mutable array unser the hood
04:47:57 <DontGetHaskell> show x  ++ show xs
04:48:16 <Eduard_Munteanu> :t accumArray
04:48:17 <lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
04:48:19 <byorgey> Phyx-: if you find yourself using fromJust it is a sure sign that you are Doing It Wrong ;)
04:48:22 <ski> you mean the second defining equation of `show' in
04:48:24 <ski>   show  Empty     = "}"
04:48:31 <ski>   show (x :-: xs) = show x ++ show xs
04:48:31 <ski> ?
04:48:38 <DontGetHaskell> ya
04:48:49 <ski> if you're renaming `show', you should rename it everywhere in its definition
04:49:08 <ski> (but don't change the `show x', since that `show' is not your `show')
04:49:16 <Phyx-> byorgey: heheeh, yeah, i'll mark that one to be cleaned up when I reimplement soon
04:49:34 * Eduard_Munteanu looks
04:49:56 <ski> DontGetHaskell : so .. how does the code look like, after the renaming ?
04:50:43 <DontGetHaskell> Im not sure which show to change
04:51:28 <ski> every `show', except the one in `show x' .. since that for the numbers in the example .. you haven't written that `show'
04:51:38 <Eduard_Munteanu> dafis: hm, that's interesting. I'll try it.
04:51:39 <DontGetHaskell>      show (x :-: xs) = "{" ++ show x ++ showRest xs 
04:51:43 <Eduard_Munteanu> Thanks.
04:51:46 <DontGetHaskell> o
04:52:11 <ski> not quite
04:52:20 <ski> you haven't changed the left-hand-side of the `='
04:52:28 <ski> (and you haven't changed the `Empty' case, either)
04:52:37 <DontGetHaskell> instance (Show a) => Show (List a) where      showRest Empty = "}"       showRest (x :-: xs) = "{" ++ show x ++ showRest xs
04:52:46 <ski> yeah, that's fine
04:53:00 <ski> now, let's drop the `"{" ++' part, since we already know that is wronf
04:53:06 <ski> s/wronf/wrong/
04:53:19 <ski> (it will repeat `{' many times, which we do not want)
04:53:22 <ski> so
04:53:27 <ski>   showRest  Empty     = "}"
04:53:35 <ski>   showRest (x :-: xs) = show x ++ showRest xs
04:53:37 <ski> yes
04:53:53 <Eduard_Munteanu> What's he at? Replacing '[' / ']' in his show's output with braces?
04:54:03 <ski> now, i hope you agree that this `showRest' does the exact same thing as `show' did, before the renaming
04:54:08 <ski> DontGetHaskell : agree ?
04:54:22 <DontGetHaskell> yes
04:54:31 <ski> Eduard_Munteanu : `show (0 :-: 1 :-: 2 :-: Empty) = "{0,1,2}"'
04:54:46 <Eduard_Munteanu> I think Cale's idea of using tail and init was good.
04:54:57 <ski> DontGetHaskell : so, let's for a moment now define `show', to do the *exact* same thing it did right before !
04:54:58 <ski> i.e.
04:55:04 <ski>   show xs = showRest xs
04:55:13 <ski> ok ?
04:55:20 <DontGetHaskell> ok
04:55:38 <ski> (if you want, you can try this, to make sure it works the same as before)
04:55:44 <DontGetHaskell> where do I put that
04:56:08 <ski> (if you do so, either put `showRest' inside a `where' under `show' .. or put `showRest' outside of the `instance ...' declaration)
04:56:13 <ski> i.e. either
04:56:13 <Cale> Eduard_Munteanu: I didn't think so ;)
04:56:20 <ski>   instance Show a => Show (List a)
04:56:21 <ski>     where
04:56:27 <ski>     show xs = showRest xs
04:56:30 <ski>       where
04:56:31 <Eduard_Munteanu> Uhm, I must be confusing, sorry.
04:56:35 <ski>       showRest  Empty     = "}"
04:56:38 <ski>       showRest (x :-: xs) = show x ++ showRest xs
04:56:44 <ski> *or*
04:56:48 <ski>   instance Show a => Show (List a)
04:56:50 <ski>     where
04:56:52 <ski>     show xs = showRest xs
04:56:56 <ski>   showRest  Empty     = "}"
04:57:01 <Cale> Eduard_Munteanu: It's fine, I'm joking a bit. That way is the hacky way, which he's probably not meant to do on a homework assignment.
04:57:01 <ski>   showRest (x :-: xs) = show x ++ showRest xs
04:57:04 <Eduard_Munteanu> Cale: at least I remember you linking the pic with the caterpillar.
04:57:06 <ski> DontGetHaskell : ok ?
04:57:20 <DontGetHaskell> I will try the latter
04:57:23 <Cale> (It's also quite slow)
04:57:27 <Eduard_Munteanu> Yeah.
04:57:45 <Eduard_Munteanu> It gets it the job done faster though.
04:57:52 <ski> (of course, you can put `showRest' anywhere else in your file, above or below the `instance' .. as long as it's not inside anything else)
04:59:39 <Eduard_Munteanu> Anyway for a newbie I think giving him a way to express what he wants in a more-or-less natural language isn't a bad idea
05:03:57 <ski> (DontGetHaskell said they'd probably be back tomorrow)
05:04:35 <Eduard_Munteanu> They?
05:04:44 <ski> s/he, if you prefer
05:04:51 <Eduard_Munteanu> Oh.
05:05:04 <Eduard_Munteanu> 'It' would've been rude. :P
05:05:37 <ski> (<http://en.wikipedia.org/wiki/Singular_they>)
05:07:14 <Eduard_Munteanu> Hm, I wasn't familiar with that.
05:07:25 * ski recalls the bot `minion' saying something like "Your memo has been recorded. I will tell it to he/she/it appears.", when asking it to record a memo
05:07:32 <Eduard_Munteanu> (was also a bit ambiguous there)
05:07:34 <ski> (like with `tell'/`ask')
05:08:26 <ski> (er, s/I will tell it to he\/she\/it appears./I will say it when he\/she\/it appears./)
05:11:50 * Eduard_Munteanu wonders whether there's some inherent gender in English words.
05:12:17 <Eduard_Munteanu> In my native language it's easy to determine gender by counting "one X, two Xes".
05:12:26 <sipa1024> Eduard_Munteanu: there isn't
05:12:44 <Eduard_Munteanu> Ah, hence 'it'.
05:12:54 <sipa1024> and that makes english an exception compared to most other european languages
05:12:58 <gds> There are traditions, which are currently being dismantled - like boats used to always be "she"...
05:13:11 <Eduard_Munteanu> Ah, heh.
05:14:15 <Eduard_Munteanu> It also makes less sense to me when referring to animals using 'it'
05:14:55 <gds> My brother works as a vet-tech and wildlife rescue officer, and always uses the masculine when refering to an ungendered animal.
05:14:56 <Eduard_Munteanu> Just sometimes, but perhaps I'm misattributing gender where there's none.
05:14:56 <hpc> i just refer to everything as 'it'/'they' until i know gender
05:15:22 <gds> But yeah, the singular plural thingie is getting more and more common.
05:15:24 <Eduard_Munteanu> gds: oh.
05:15:37 <gds> and IMO is probably to be preferred.
05:16:10 <Eduard_Munteanu> gds: do you specifically mean "they"? Or using a neutral gender 'it'/'they'?
05:16:12 <gds> (by "ungendered animal", I meant "an animal whose gender we have not yet identified")
05:16:21 <ben> It seems pretty retarded that something as un-syntactic as gender has such a central role in grammar
05:16:21 <Eduard_Munteanu> Of course.
05:16:29 <ben> Who came up with that
05:16:46 <Eduard_Munteanu> ben: heh, that's a good point.
05:17:01 <gds> Eduard_Munteanu: I think it's still rude to use "it" to refer to something conscious. Hence "they".
05:17:14 <gds> ben: Yeah, it gets on my nerves too :)
05:18:31 <Eduard_Munteanu> gds: yeah, I know. I'd rather use "he or she" in some contexts, or directly "he". For example, "About your teacher, how is he?"
05:19:01 <gds> Eduard_Munteanu: So, the phrase I'm trying to train myself to use in that context would be "About your teacher, how are they?"
05:19:09 <sipa1024> it doesn't sound appropriate to use 'it' when referring to a person, even if you don't know its gender ;)
05:19:30 <Eduard_Munteanu> gds: it sounds a bit insane. How familiar are native English speakers with that?
05:19:53 <ben> Refering to people as 'it' is probably as insulting as a purely grammatical choice can be
05:20:51 <dafis> ben: not in German
05:21:03 <gds> Eduard_Munteanu: It is a bit odd, 'cause you're changing from singular to plural half way through the sentence. But that also makes it clear that the plural isn't a real plural, it's standing in for "he/she"....
05:21:36 <dafis> Pluralis Maiestatis?
05:21:52 <ski> (hm .. "Wie ist es ?" or ?)
05:22:04 <gds> Eduard_Munteanu: I read an article about President Obama's inaugural address, and how he used similar constructs in his speech. The article suggested that this marked him out as a modern cosmopolitan man, who would appeal to the young city demographic.
05:22:11 <dafis> ski: Was macht das Baby?
05:22:12 * ski 's german is bad
05:22:40 <Eduard_Munteanu> dafis: what's that? We have something called "courtesy plural" (or something like that). Basically you refer to anybody who's not a close acquaintance with a plural noun.
05:22:43 <ski> dafis : oh, but that's a neutral noun, that's not the same thing
05:23:19 <dafis> ski: answer "Es schlft"
05:23:23 <gds> Ah - not inaugural address...
05:23:30 <gds> Another thing he said on tv: http://languagelog.ldc.upenn.edu/nll/?p=1629
05:23:35 <lars9> is there any sample solution for 24-points in haskell?
05:23:47 <ski> Eduard_Munteanu : Thou meanst instead of "thou" ?
05:24:08 <dafis> Eduard_Munteanu: I think it is sometimes referred to as "Royal we".
05:24:08 <Eduard_Munteanu> ski: yes.
05:25:13 * ski imagines the 24 corners of the 24-cell, ordered in a nice lattice structure
05:25:31 <Eduard_Munteanu> ski: basically, when speaking we're not speaking to close acquaintances, we use constructs like "could I ask <plural you> a question?".
05:25:57 <Eduard_Munteanu> s/when speaking//
05:26:00 <ski> yes
05:26:17 <ben> s//when/
05:26:29 <dafis> > cycle "when"
05:26:30 <Eduard_Munteanu> Ha.
05:26:30 <lambdabot>   "whenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwhenwh...
05:26:40 <Eduard_Munteanu> ben just sed-ed my sed command.
05:27:11 <ben> No, that would have had to be s/\/\//\/when\// :v
05:27:12 <Eduard_Munteanu> Uhm, not, but close.
05:27:37 <Eduard_Munteanu> (I read it as s/when//
05:28:47 <Eduard_Munteanu> Grr... natural languages suck.
05:29:08 * dafis agrees
05:29:23 <Eduard_Munteanu> Maybe we need a EBNF specification for a designed but usable language.
05:30:46 <gds> Eduard_Munteanu: lojban?
05:31:06 <Eduard_Munteanu> gds: what's that?
05:31:23 <gds> @google lojban
05:31:24 <lambdabot> http://www.lojban.org/
05:31:24 <lambdabot> Title: Lojban : Lojban
05:31:29 <gds> A designed language.
05:31:33 * ski tries to guess how to use `Regex', by pestering lambdabot
05:31:39 <gds> Designed to be spoken.
05:31:46 * gds doesn't speak it :)
05:32:05 <Eduard_Munteanu> gds: wow, never thought that existed, nice.
05:32:06 <ski> (.. intelligently designed ? ;)
05:32:44 * Eduard_Munteanu hopes it comes with a typechecker :P
05:32:49 <gds> Eduard_Munteanu: Actually, I think I first heard about it in this channel some years ago...
05:32:57 <ski> Eduard_Munteanu : write one in GF ?
05:33:04 <gds> So you might find some speakers knocking around here....
05:33:41 <Eduard_Munteanu> ski: what do you mean?
05:33:44 * gds experiments...
05:33:45 <Eduard_Munteanu> Heh.
05:33:47 <gds> @where lojban
05:33:47 <lambdabot> I know nothing about lojban.
05:33:51 <gds> Ah well.
05:34:07 <ski> @where GF
05:34:07 <lambdabot> http://www.grammaticalframework.org/
05:34:12 <aristid> @src cycle
05:34:12 <lambdabot> cycle [] = undefined
05:34:12 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
05:34:40 <Eduard_Munteanu> Nice.
05:35:27 * Eduard_Munteanu hopes they based Lojban on English words.
05:35:58 * ski can't seem to find any implementation of lojban in GF :/
05:36:15 <gds> Eduard_Munteanu: IIRC, it uses a similar design to an older language called "loglan", but takes words from existing languages based on population...
05:36:21 <Eduard_Munteanu> Hm, it seems not.
05:36:23 <gds> So many of the phonemes are chinese...
05:36:30 <Eduard_Munteanu> Grrr....
05:37:28 * Eduard_Munteanu wonders if IPA makes sense as an alphabet for such stuff.
05:39:23 * ski plays around with <http://www.grammaticalframework.org/demos/resource-api/editor.html>
05:40:53 <Entroacceptor> Eduard_Munteanu: there's #lojban on freenode
05:41:50 * gds wonders how the number of lojban speakers compares with the number of haskell speakers....
05:42:02 <Entroacceptor> speakers?
05:42:09 <Entroacceptor> I'd guess lojban wins by a handful ;)
05:42:11 <zygoloid> gds: it compares poorly to the number of klingon speakers so i think we're in with a shot.
05:43:26 <Entroacceptor> but I'm sure Haskell has more writers
05:43:37 <ski> (hehe, <http://homepages.inf.ed.ac.uk/wadler/realworld/gf.html> lists GF being compiled by HBC :)
05:43:49 <gds> :)
05:43:51 <Eduard_Munteanu> Entroacceptor: heh
05:45:02 <zygoloid> wikipedia claims 200-1000 people speak esperanto; i'm pretty sure haskell wins there :)
05:46:09 <ski> @where HBC
05:46:10 <lambdabot> http://www.cs.utah.edu/~hal/HBC/
05:46:14 <ski> .. huh ?
05:46:36 <Eduard_Munteanu> o	 	
05:46:38 <Ke> if lojban had proper fonemic representation
05:46:38 <Eduard_Munteanu> as in bold or more
05:46:44 <Eduard_Munteanu> Bold seems wrong.
05:47:00 <Entroacceptor> Ke: ?
05:47:02 <Eduard_Munteanu> Ke: IPA? Might've been better I guess.
05:47:11 <ziman> @pl \ st x z -> st (f x z)
05:47:11 <lambdabot> (. f) . (.)
05:47:21 <Ke> IPA is way too complex
05:47:25 <Ke> try finnish
05:47:28 <Eduard_Munteanu> Well, a subset of IPA.
05:48:11 <Ke> subset might do
05:48:11 <ziman> @pl \ x st z -> st (f z x)
05:48:12 <lambdabot> flip (.) . flip f
05:48:51 <Eduard_Munteanu> Actually maybe even 26 chars is too much, like in English.
05:48:56 <ski> @where+ HBC Haskell B Compiler <http://www.augustsson.net/Darcs/hbc/>,<http://www.haskell.org/haskellwiki/Implementations#HBI_and_HBC.2C_Chalmers.27_Haskell_Interpreter_and_Compiler> | Hierarchical Bayes Compiler <http://www.cs.utah.edu/~hal/HBC/>
05:48:56 <lambdabot> Okay.
05:49:15 <ski> @where+ HBI see HBC
05:49:15 <lambdabot> Good to know.
05:49:53 <Entroacceptor> looking at the problems we have with unicode, still, I'm glad Lojban did what they did
05:50:38 * hackagebot uuagc 0.9.32 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.32 (ArieMiddelkoop)
05:50:55 <sajkr> why would they use unicode?
05:50:56 <Eduard_Munteanu> Entroacceptor: I guess that's a valid point.
05:51:10 <Eduard_Munteanu> sajkr: were they to use IPA.
05:51:26 <Entroacceptor> and the translation from letters to sounds is defined
05:52:14 <Eduard_Munteanu> I'm taking it for granted, my language is exactly like that. A few more European languages too.
05:52:17 <sajkr> yes, but the point is not to be overly precise when it comes to pronounciation.
05:52:54 * Eduard_Munteanu imagines people saying "ha! look at that guy's accent"
05:53:01 <Eduard_Munteanu> in Lojban.
05:53:38 <sajkr> for example, 'r' can be pronounced in many different ways.
05:54:02 <exDM69> people do recognize my regional dialect of Finnish in my internet chatting
05:54:37 <Entroacceptor> Eduard_Munteanu: which language would that be?
05:55:14 <Eduard_Munteanu> Entroacceptor: Romanian. AFAIK, pronunciation rules are similar in Italian, Greek, Turkish etc.
05:55:36 <Eduard_Munteanu> (in fact there are no rules, 1-to-1 correspondence with letters)
05:56:07 <dafis> Eduard_Munteanu: at least in Italian, it's more complicated
05:56:07 <Eduard_Munteanu> *pronounciation
05:56:56 <Eduard_Munteanu> dafis: hm, excluding stuff that might be classified as mere "accent"?
05:57:41 <dafis> in Italian, you have 'g' in buon giorno pronounced like 'j' in jungle, but in Lamborghinin, it's pronounced like 'g' in guest
05:57:56 <dafis> analogous stuff for c vs. ch
05:58:22 <sajkr> dafis: so 'h' is like an escape sequence which prevents palatalization?
05:58:31 <aristid> so romanian pronunciation is like simplified italian? :D
05:58:38 <Eduard_Munteanu> dafis: oh, yeah, I forgot about that. Same here with "gi" vs "ghi".
05:58:49 <dafis> sajkr: mostly, maybe there's more, I don't really know Italian
05:58:49 <aristid> ok, so not really simplified
05:59:24 <Eduard_Munteanu> But it's phonetical for the most part.
05:59:39 <sajkr> dafis: it probably is. 'u' works pretty much the same way in spanish.
05:59:57 * Eduard_Munteanu remembers Greek had exceptions too, like "y' could be read as either "i" or "u" depending on context.
06:00:17 <hpc> 'y' == ''?
06:00:52 <Eduard_Munteanu> Hm, no, not \nu. I mean capital Y, there's one in modern Greek.
06:00:53 <sajkr> Eduard_Munteanu: i think that the pronounciation of 'y' shifted in ancient greek between 'i', 'u' and ''.
06:00:56 <ben> Was that not a question of adding a '' before the ''?
06:01:13 <Nibble> what has this to do with haskell -__-
06:01:32 <hpc> Nibble: there's always -blah, if you want to talk about that
06:01:37 <Eduard_Munteanu> :)
06:01:37 <hpc> :D
06:06:53 <Nibble> gtk2hsc2hs
06:07:01 <Nibble> cabal can't find it
06:07:13 <Eduard_Munteanu> Nibble: Windows?
06:07:17 <Nibble> Eduard_Munteanu: no
06:07:24 <gds> Nibble: is it installed?
06:07:29 <dcoutts> Nibble: not surprising since there's no such thing ;-)
06:07:29 <lambdabot> dcoutts: You have 1 new message. '/msg lambdabot @messages' to read it.
06:07:29 <Eduard_Munteanu> Nibble: did you install gtk2hs-buildtools ?
06:07:34 <Nibble> dcoutts: well
06:07:37 <Nibble> glib requires it.
06:08:03 <dcoutts> Nibble: sorry, being facetious, as Eduard_Munteanu says, the package you want is gtk2hs-buildtools
06:08:21 <dafis> Nibble: gtk2hsC2hs with a capital C?
06:08:39 * gds managed to screw his gtk2hsC2hs up further by including "~" characters in his path variable....
06:08:58 <Nibble> is it only me that thinks cabal has poor dependency handling?
06:08:59 <gds> Meant that bash could find it when I wanted to run it myself, but cabal couldn't find it when it wanted to test if it was there....
06:09:08 <cathper> Can I have a function to be defined in different files (modules)? Say, f 1 x = foo in one and f 2 x = bar in another?
06:09:21 <Eduard_Munteanu> gtk2hsC2hs seems a bit fragile anyway, I had issues building stuff with it on Wine, that's why I asked.
06:10:35 <dcoutts> Nibble: it has poor handling of all kinds of dependencies except for library dependencies.
06:11:03 <dcoutts> Nibble: it only does dep analysis for libs at the moment, so others only get discovered at configure time for individual packages
06:12:24 <Nibble> :/
06:12:47 * Eduard_Munteanu wonders if a reference Haskell Linux distro would improve anything.
06:13:10 <Eduard_Munteanu> Not as much something usable, but more like a specification which can be tested and from which other distros can inspire.
06:15:26 <gds> cathper: You might be able to do something similar to what you want using type classes. If you have typeclass Foo that provides f :: Foo -> a -> b
06:15:39 <lars9> how to write split2lists :: [a] -> [([a], [a])], for example split2lists [1,2,3,4] = [([1], [2,3,4]), ([1,2], [3,4]), ([1,2,3], [4])]
06:15:49 <gds> then you have two files, which define types Bar and Baz, which are instances of Foo.
06:16:03 <hpc> :t inits &&& tails
06:16:04 <lambdabot> forall a. [a] -> ([[a]], [[a]])
06:16:07 <ville> Personally I dislike that Haskell has this cabal thing, it doesn't seem to play very nice with distributions package systems. And I get to choose I rather manage the packages on my system through the distro's system just like for every other programming language.
06:16:10 <gds> But that doesn't work if you want to switch on an integer argument as you suggest you might.
06:16:14 <hpc> > inits &&& tails $ [1..4]
06:16:14 <lambdabot>   ([[],[1],[1,2],[1,2,3],[1,2,3,4]],[[1,2,3,4],[2,3,4],[3,4],[4],[]])
06:16:34 <hpc> :t uncurry zip
06:16:35 <lambdabot> forall a b. ([a], [b]) -> [(a, b)]
06:16:56 <hpc> :t uncurry zip . inits &&& tails
06:16:57 <lambdabot>     Couldn't match expected type `([a], [b])'
06:16:57 <lambdabot>            against inferred type `[[a1]]'
06:16:57 <lambdabot>       Expected type: [a1] -> ([a], [b])
06:17:02 <dcoutts> ville: Cabal was designed to integrate with distro packages, the package description language is restricted specifically so that they can be translated into distro packages
06:17:13 <dcoutts> ville: there are several automated translation tools for various distros
06:17:30 <cathper> gds: I see. But then I could just have foo1 and foo2 that takes one argument, and then have foo a x | a == 1 = foo1 a, ...
06:17:49 <hpc> :t (uncurry zip) . (inits &&& tails)
06:17:50 <lambdabot> forall a. [a] -> [([a], [a])]
06:17:52 <cathper> ... which was my first thought.
06:17:52 <dcoutts> ville: in fact I think we do much better with distro packages than most languages, because we make the original authors put in the effort of documenting dependencies, so that the distros can just translate automatically (for the most part)
06:18:14 <hpc> > let headstails = (uncurry zip) . (inits &&& tails) in headstails [1..4]
06:18:15 <lambdabot>   [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
06:18:27 <ville> dcoutts: Well seems something is amiss at least when it comes to Arch and Haskell packages.
06:18:35 <dcoutts> ville: now if you're using both distro packages and cabal-install then that's a harder problem
06:18:52 <ville> I only install through distro packages.
06:18:55 <aristid> dcoutts: which distros translate cabal packages into their own format?
06:18:59 <Eduard_Munteanu> AFAICT, Arch is among the top Haskell distros.
06:19:01 <lars9> hpc: amazing!
06:19:15 <hpc> lars9: not that amazing; it looks pretty slow from here
06:19:20 <dcoutts> ville: oh then I'm surprised you're having problems, arch is one of the better distros and uses this automated translation method
06:19:21 <hpc> but it gives you a starting place
06:19:27 <dafis> @type inits *** tails
06:19:28 <lambdabot> forall a a1. ([a], [a1]) -> ([[a]], [[a1]])
06:19:31 <lars9> hpc: i feel connected with Arrow for the first time!
06:19:40 <dcoutts> aristid: arch, gentoo, debian, fedora at least
06:20:01 <hpc> arch is definitely one of the best distros for haskell
06:20:04 <aristid> dcoutts: ok, so debian does it, but just tends to be outdated and not including a lot of packages?
06:20:05 <ville> dcoutts: there're frequent breaks, forcing one to start over with their Haskell environment from GHC on up.
06:20:27 <lars9> hpc: why it's slow?
06:20:48 <hpc> lars9: not sure; it shouldn't take 4 seconds to process a 4-length list though
06:20:58 <hpc> see what you can come up with
06:21:38 <lars9> hpc: it works normally here
06:22:11 <hpc> perhaps nets are slow then
06:22:25 <Nibble> hmm
06:22:28 <dcoutts> aristid: they were one of the later ones to the game of automating, and debian/ubuntu have quite a lot of lag when it comes to getting packages out into releases, but I think they're doing pretty well now
06:22:31 <lars9> hpc: yep. does other arrow help?
06:22:32 <Nibble> prefix = do
06:22:33 <Nibble>   userId <- getEffectiveUserID
06:22:35 <Nibble>   if userId == 0 then "#" else "$"
06:23:00 <lars9> @pl uncurry zip . (inits &&& tails)
06:23:00 <lambdabot> uncurry zip . (inits &&& tails)
06:23:03 <Nibble> it thinks that UserID (the type that getEffect.. returns) is a list and not a unlist
06:24:02 <dafis> Nibble: return (if userId == 0 ...)
06:24:32 <dafis> Nibble: I suppose getEffectiveUserId is IO Int
06:24:53 <Nibble> dafis: no, IO UserID
06:25:04 <dafis> Okay, same difference
06:25:09 <Nibble> :)
06:25:49 <dafis> Nibble: the point is, you have to "return result", since the entire thing must be an IO action
06:26:24 <dafis> if you give Strings as results, the compiler thinks it takes place in the [] monad
06:27:28 <Saizan> dcoutts: the problem with arch's packages is that they are source packages, installed via Setup configure
06:27:39 <Saizan> dcoutts: i'd think
06:28:05 <hpc> no, pacman does binaries
06:28:13 <hpc> always has
06:28:29 <dcoutts> Saizan: there's nothing wrong with that in principle, if the distro packages specify the versions of dependencies
06:28:44 <dcoutts> Saizan: e.g. gentoo does the same
06:29:01 <Saizan> dcoutts: exact versions? they don't
06:29:04 <dcoutts> it has a haskell-updater tool that rebuilds broken packages
06:29:10 <gds> cathper: I guess so :)
06:40:04 <joe6> latest cabal cannot seem to do much useful on debian packages. I am thinking of removing all the debian packages and getting ghc and cabal from source in the local home dir. Just curious, if any of you do the same?
06:41:15 <dcoutts> joe6: I use distro packages for the basic ghc and I use cabal for everything else
06:41:29 <dcoutts> but then I'm cabal maintainer, so dogfooding is kind of important for me :-)
06:42:31 <dafis> joe6: I'm not using debian, but all from source in $HOME is what I do, it works fine
06:43:32 <joe6> dcoutts: i do not mean to disparage your efforts on cabal. I think your efforts are honorable. i have been trying to install sourceGraph with cabal and it keeps failing with one error or another. The sad thing is that it does not fail immediately but runs through a bunch of packages before failing. i tried to install all the packages that it complains about without much luck. 
06:44:02 <dcoutts> joe6: what were the reasons ooi? C libs ?
06:44:11 <joe6> That prompted to think that I am better off getting and building everything regarding haskell from src.
06:45:04 <joe6> dcoutts: it said something about directory and process packages. Though the latest were involved, it wanted something 1 release back and even after that install, it was still prompting me for those packages.
06:45:08 <dcoutts> joe6: I'm not sure I follow, if you're saying that cabal could not easily build SourceGraph, how will it be better by building everything from source?
06:45:24 <joe6> I do not have the exact error message, as i just rebooted my cpu.
06:45:32 <dafis> dcoutts: sounds like diamond dependencies
06:45:47 <dcoutts> mm, but that's what cabal-install avoids
06:45:50 <joe6> dafis: thanks.
06:45:57 <dafis> something depends on an older versionf process/directory
06:46:15 <dafis> s/versionf/version of/
06:46:27 <lars9> @pl concat . map
06:46:27 <lambdabot> join . map
06:46:33 <joe6> dcoutts: i have the ghc debian packages. and i noticed that i could not get sourcegraph with the baseline cabal.
06:47:01 <joe6> hence, did cabal install in the home dir using the old cabal and pointed my cabal to the new cabal in the home dir.
06:47:21 <gds> dcoutts: I got into a similar pickle recently in ubuntu. I "fixed" it by doing "ghc-pkg list ; mv .cabal .cabal-old ; mv .ghc .ghc-old ; cabal update ; cabal install STUFF"
06:47:35 <Saizan> joe6: what command corresponds to that?
06:47:39 <gds> Where "STUFF" was all the stuff that the original ghc-pkg list suggested I already had.
06:48:07 <dcoutts> gds: mm, things go down hill quickly once you get multiple versions of the core libs
06:48:32 <gds> Indeed. I have no idea how that happened, but resetting the lot seemed to be the order of the day.
06:49:00 <joe6> dcoutts: that is the reason I am thinking of getting rid of all the debian haskell packages and just starting from ghc and cabal in the home dir
06:49:28 <dcoutts> joe6: I'm afraid I didn't follow what the problem was, or how you tried to solve it
06:49:57 <joe6> dcoutts: I will post once I have more details.
07:01:24 <lars9> @pl perm2parts (x:xs) = concat $ map (\(as, bs) -> [(x:as, bs), (as, x:bs)]) $ permCalc xs
07:01:25 <lambdabot> perm2parts = ap ((join .) . (. permCalc) . map . (`ap` snd) . (. fst) . ap (ap . ((ap . ((:) .) . (,)) .) . (:)) (flip flip [] . ((flip . ((:) .)) .) . flip ((.) . (,)) . (:)) . head) tail
07:01:31 <lars9> oops...
07:01:43 <lars9> @pl \(as, bs) -> [(x:as, bs), (as, x:bs)
07:01:44 <lambdabot> (line 1, column 14):
07:01:44 <lambdabot> unexpected "["
07:01:44 <lambdabot> expecting lambda abstraction or expression
07:01:52 <lars9> @pl \(as, bs) -> [(x:as, bs), (as, x:bs)]
07:01:52 <lambdabot> uncurry (ap (ap . ((:) .) . (,) . (x :)) (flip flip [] . ((:) .) . (. (x :)) . (,)))
07:02:04 <lars9> @pl \x (as, bs) -> (x:as, bs), (as, x:bs)
07:02:05 <lambdabot> (line 1, column 26):
07:02:05 <lambdabot> unexpected ","
07:02:05 <lambdabot> expecting variable, "(", operator or end of input
07:02:18 <lars9> @pl \x (as, bs) -> [(x:as, bs), (as, x:bs)]
07:02:19 <lambdabot> (`ap` snd) . (. fst) . ap (ap . ((ap . ((:) .) . (,)) .) . (:)) (flip flip [] . ((flip . ((:) .)) .) . flip ((.) . (,)) . (:))
07:02:29 <engla> ah, pointless expansions
07:03:46 <wto> @pl \a b c d -> d c b a
07:03:46 <lambdabot> flip (flip . (flip .) . flip (flip . flip id))
07:03:49 <wto> :D
07:04:33 <Gracenotes> @pl \x (as, bs) -> ((x:as, bs), (as, x:bs))
07:04:33 <lambdabot> (`ap` snd) . (. fst) . ap (ap . ((ap . ((,) .) . (,)) .) . (:)) (flip ((.) . (,)) . (:))
07:04:43 <litb> wait i know what that means!
07:05:09 <litb> it means 6 flips and 4 dots lol
07:06:05 <Gracenotes> @type \x (as, bs) -> ((x:as, bs), (as, x:bs))
07:06:06 <lambdabot> forall a. a -> ([a], [a]) -> (([a], [a]), ([a], [a]))
07:07:01 <litb> is there a  @pl that uses  $ instead of parentheses?
07:07:31 <Jafet> It costs them more to run that one
07:08:13 <freshnewpage> hi there
07:08:18 <Gracenotes> litb: it wouldn't look terribly different
07:08:28 <freshnewpage> Don't know if anyone can help with this.
07:08:38 <joe6> dcoutts: any thoughts on this, please: http://hpaste.org/41493/cabal_issues
07:09:39 <dcoutts> joe6: you've got the exact same package version installed in the user package db as in the global one. That's not technically wrong but Cabal does not cope with it very well at the moment.
07:09:49 <dcoutts> joe6: so the workaround is to eliminate such duplication
07:10:24 <Gracenotes> repository-installed packages rarely have the same hashes as cabal-installed ones
07:10:30 <freshnewpage> But supposing you have a function ' \ x -> (read x) :: Int '
07:10:31 <joe6> dcoutts: even after this : http://hpaste.org/paste/41493/cabal_issues1#p41494
07:10:32 <freshnewpage> My understanding is that the function either returns an int or throws an error. How can I get one thing to happen if an Int is returned an another thing to happen if an error is return? Case, if , guard. Not sure what the right approach is here.
07:10:35 <Gracenotes> er let me say 'never'
07:11:03 <joe6> dcoutts: ok,  thanks.
07:11:06 <dcoutts> joe6: right, that's the problem you don't want those to be installed in the user db, since they're already installed in the global db
07:11:26 <dcoutts> joe6: use ghc-pkg list, look for ones where the exact same version is in both, get rid of the user one
07:11:51 <dcoutts> joe6: then rebuild whatever is borked, use --dry-run to see what will happen, don't use cabal upgrade, stick to cabal install
07:13:32 <Gracenotes> freshnewpage: read isn't actually part of the Read typeclass. it uses complex functions behind the scenes, and if it's not satisfied with what they have to say, it throws an error
07:13:38 <joe6> dcoutts: ok, thanks a lot.
07:13:46 <Gracenotes> a more useful wrapper function might be reads
07:13:48 <Gracenotes> @type reads
07:13:49 <lambdabot> forall a. (Read a) => String -> [(a, String)]
07:14:04 <dafis> freshnewpage: there's also readEither
07:14:11 * hackagebot hs2bf 0.6 - Haskell to Brainfu*k compiler  http://hackage.haskell.org/package/hs2bf-0.6 (DaikiHanda)
07:14:12 <Gracenotes> oh is that recent? -.-
07:14:22 <dafis> @type readEither
07:14:22 <lambdabot> Not in scope: `readEither'
07:14:27 <freshnewpage> Humm interesting.
07:14:36 <Gracenotes> in any case, if the output of reads is [(value, "")], then that's the same as read being successful
07:14:41 <dafis> probably you have to import Text.Read for that one
07:15:04 <Gracenotes> hm, not getting it there
07:15:23 <dafis> Gracenotes: wait a mo, let me dig sources
07:15:23 <freshnewpage> Cool, so I should check out reads by the sounds of it.
07:15:40 <freshnewpage> Basically I'm trying to squelch the error in this case.
07:16:11 * hackagebot hs2bf 0.6.1 - Haskell to Brainfu*k compiler  http://hackage.haskell.org/package/hs2bf-0.6.1 (DaikiHanda)
07:16:12 <freshnewpage> If the read fails I want nothing (well 0 because I'm trying to read an Int)
07:16:41 <Gracenotes> readMaybe x = case reads x of [(val, "")] -> Just val; _ -> Nothing. for example.
07:16:45 <lars9> @pl \f (x, y) = (f x, f y)
07:16:45 <lambdabot> (line 1, column 11):
07:16:46 <lambdabot> unexpected "="
07:16:46 <lambdabot> expecting pattern or "->"
07:16:53 <lars9> @pl (\f (x, y) = (f x, f y))
07:16:53 <lambdabot> (line 1, column 12):
07:16:53 <lambdabot> unexpected "="
07:16:53 <lambdabot> expecting pattern or "->"
07:16:58 <Gracenotes> try ->
07:17:05 <lars9> @pl (\f (x, y) -> (f x, f y))
07:17:05 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
07:17:14 <lars9> ah..
07:17:22 <dafis> Oh, it's defined in Text.Read, but not exported :(
07:17:26 <lars9> any arrow helps this?
07:18:21 <freshnewpage> Thanks Gracenotes
07:18:57 <Gracenotes> @type \f (x, y) -> join (***) f (x, y)
07:18:58 <lambdabot> forall b c. (b -> c) -> (b, b) -> (c, c)
07:19:16 <Gracenotes> join (***) f == (f *** f)
07:19:50 <nostard> in a .prof generated by GHC, is "entries" the same as the number of times the function is called?
07:20:19 <nostard> there seems to be to many entries for some functions in a profile i got
07:21:17 <lars9> Gracenotes: hi how does *** work?
07:21:46 <Gracenotes> @type (***)
07:21:47 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
07:22:17 <Gracenotes> it's just (b -> c) -> (b' -> c') -> (b, b') -> (c, c'), as you'd expect it to be implemented
07:22:24 <Gracenotes> @djinn (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
07:22:24 <lambdabot> f a b (c, d) = (a c, b d)
07:22:38 <Gracenotes> when the arrow is a function that is
07:22:45 <Gracenotes> how that's useful in general.. well.. other reasons for that
07:23:13 <lars9> i mean how to implement \f (x, y) -> (f x, f y) using ***
07:24:52 <Gracenotes> look at the lambdabot evals above
07:24:58 <Gracenotes> and uh I have to go to class bbl
07:25:37 <lars9> Gracenotes: thanks, i'll figure it out
07:26:06 <dafis> nostard: no, entries is not the number of calls. In a single call, the function may be entered multiple times
07:27:41 <lars9> @pl f <$> x <*> y
07:27:41 <lambdabot> f <$> x <*> y
07:28:08 <nostard> dafis: ok, what does that mean? or rather, should i care that the number of entries is much higher than the number of calls for an expensive function?
07:29:22 <joe6> i am just curious of viruses targetting haskell apps. afaik, there are a bunch of ways to get control of C apps, is it just the same with haskell apps. or, are haskell apps more secure?
07:30:44 <lars9> @pl (,) <$> x <*> y
07:30:44 <lambdabot> (,) <$> x <*> y
07:31:03 <lars9> @pl [x,y|x<-xs, y<-ys]
07:31:03 <lambdabot> [x, y | x <- xs, y <- ys]
07:31:11 <jmcarthur> joe6: haskell as a language encourages somewhat better security practices, if that's what you mean
07:31:28 <dafis> nostard: I think (I may be wrong), it's like: if you have foo xs = map f xs (for some f) and call foo via "take 10 (foo bar)" where bar is a long enough list, foo is entered once and returns (h : thunk), the caller says "thanks, but is there more?", foo is entered a second time, giving (next : nextThunk), caller says again "more?", foo is entered a third time, etc.
07:31:58 <jmcarthur> joe6: but i wouldn't say a haskell binary is inherently more difficult to hack than a C binary if both are coded non-idiotically
07:32:52 <joe6> jmcarthur: oh, ok.
07:34:02 <jmcarthur> they both compile to the same architecture, after all
07:34:36 <joe6> i was thinking that haskell might avoid some of the issues with the memory management as there is no single buffer.
07:34:38 <gds> jmcarthur: Do you mean it's possible to get a buffer-overrun in haskell code, or do you mean that non-idiotic C code shouldn't have them? Or do you mean something else?
07:34:42 <nostard> dafis: hmm, i get 15866152 entries for a function that is called 844 times, is that something bad?
07:34:53 <dafis> nostard: maybe
07:35:06 <nostard> hm
07:35:12 <dafis> paste?
07:35:13 <joe6> but, I do not know much about the haskell internals. just wanted to check if haskell is inherently more secure.
07:35:28 <nostard> dafis: the code or the profile?
07:35:39 <lars9> @instances Fractional
07:35:40 <lambdabot> Double, Float
07:35:40 <jmcarthur> gds: i mean the latter
07:35:58 <jmcarthur> gds: the former is also possible though, especially if you use FFI or certain libraries
07:36:03 <dafis> nostard: both, the profile alone doesn't tell whether it's reasonable to have so many entries
07:36:07 <joe6> i mean haskell apps, not haskell language.
07:36:12 <gds> jmcarthur: I see - thanks :)
07:36:14 <jmcarthur> gds: and of course this is ignoring bugs in the runtime and stuff
07:36:32 <jmcarthur> joe6: nothing it inherently secure on conventional operating systems
07:36:34 <jmcarthur> *is
07:36:39 <jmcarthur> joe6: or on conventional hardware
07:36:48 <jmcarthur> it depends what kind of attack you are asking about
07:37:20 <oscar_boykin> I just ran a program which time reports: real 562m, user 4m, sys 557m.  This is a purely computational code, can I assume the sys time is due to memory allocation? 
07:37:52 <jmcarthur> oscar_boykin: http://book.realworldhaskell.org/read/profiling-and-optimization.html
07:38:05 <jmcarthur> oscar_boykin: profiling is pretty easy, so you should always do it if you aren't sure why something is slow :)
07:38:46 <oscar_boykin> jmcarthur, yeah, I know, but the character of this problem changes as a function of size (even this one is a small example), so profiling for 9h is kind of annoying.
07:39:06 <jmcarthur> oscar_boykin: you can't shrink the problem any further?
07:39:06 <lars9> @instances Num
07:39:07 <lambdabot> Double, Float, Int, Integer
07:39:17 <lars9> @instances Real
07:39:18 <lambdabot> Double, Float, Int, Integer
07:39:29 <jmcarthur> oscar_boykin: i wouldn't assume anything about where your time is going without profiling
07:39:34 <oscar_boykin> jmcarthur, like I said, I can, but when I shrink it to a smaller version of the problem, the profile says GC is only taking 5%, so I assumed I was pretty much fine.
07:40:15 <jmcarthur> oscar_boykin: oh i see. i think your best bet is still to do a proper profile. what if GC is going up to 40% or something due to the larger problem?
07:40:17 <nostard> dafis: http://hpaste.org/41497/number_of_entries
07:40:39 <jmcarthur> oscar_boykin: you should still be able to get GC stats after a ^C i think
07:40:47 <jmcarthur> might want to try it before waiting for a couple hours though
07:41:03 <oscar_boykin> jmcarthur, okay.  I guess that is indeed the best course.  I just wanted to check if it makes sense that high memory churn would result in high sys time.
07:41:09 <jmcarthur> of course, stats isn't even profiling, but it could help narrow it down
07:41:20 <lars9> is there a uniq function works on a sorted list?
07:41:23 <oscar_boykin> jmcarthur, good idea.  I'll try that approach.
07:41:32 <lars9> :t uniq
07:41:33 <lambdabot> Not in scope: `uniq'
07:41:43 <jmcarthur> lars9: map head . group
07:42:04 <lars9> jmcarthur: lol, yea it works
07:42:12 <lars9> map head . group . sort
07:42:38 <jmcarthur> lars9: toList . fromList    -- using Data.Set as an intermediary :)
07:43:01 <jmcarthur> to be pedantic, toAscList would probably be better
07:43:14 <jmcarthur> although in the current implementation toList = toAscList, i think
07:43:48 <lars9> jmcarthur: yeah, linear time is better
07:43:48 <lars9> thanks
07:43:54 <jmcarthur> it's not linear
07:44:01 <jmcarthur> it's still n log n
07:44:13 <dafis> nostard: how long is the list of Labelings in a typical call?
07:44:18 <jmcarthur> insertion into the set is O(log n)
07:45:06 <lars9> jmcarthur: it's tree not hash?
07:45:15 <nostard> dafis: ah, it's only called from isGraceful = not.null.gracefulLabelings
07:45:41 <nostard> dafis: i only want to see if there exist a Labeling
07:45:53 <jmcarthur> lars9: correct
07:46:04 <lars9> jmcarthur: thanks
07:46:12 <jmcarthur> lars9: hashes aren't very haskelly because they are tougher to get right regarding persistence
07:46:35 <jmcarthur> lars9: trees are also underrated, IMO
07:46:38 * quicksilver remarks that hash insertion is O(log n) too
07:46:51 <jmcarthur> quicksilver: ;)
07:47:40 <jmcarthur> quicksilver: that changes if you consider key size as a separate variable
07:47:45 <quicksilver> it is a shame we don't have a good trie in the "standard" library.
07:47:48 <dafis> nostard: Hmm, that may be a problem then. Can't tell without seeing more.
07:48:06 <quicksilver> jmcarthur: tree insertion is O(1) if I consider "time to insert into a tree structure" as a separate variable :P
07:48:15 <jmcarthur> heh
07:48:16 <quicksilver> there are all kinds of ways to cheat.
07:52:47 <jmcarthur> quicksilver: i just mean that a hash function is O(k) for k = key size. if k tends to be smaller than log n (which can happen when we are talking about set insertion since we are removing duplicates) then the worst case can be a bit tighter
07:55:20 <jmcarthur> if i wanted to cheat i would have pulled out the cache coherency argument
07:56:13 <quicksilver> jmcarthur: but in tree insertion the 'n' in log n is number of distinct elements
07:56:19 <quicksilver> jmcarthur: not number of total elements
07:56:39 <quicksilver> the tree removes duplicates too so duplicates don't make you do balancing work
07:56:52 <quicksilver> and they don't make your search paths longer
07:57:12 <nostard> dafis: do you really want to see more? :P
07:57:14 <jmcarthur> quicksilver: tree insertion is O(k log n)
07:57:29 <jmcarthur> quicksilver: okay i'm starting to cheat now ;)
07:57:37 <dafis> nostard: I'm not sure, but I'm curious.
07:59:46 <nostard> dafis: hehe do you need to be able to compile it and such? The important stuff is in 70 loc, but there's another module that you need if you want to compile. And that code is full of psycotic comments to myself =) (i can clean it of course)
08:00:38 <lars9> [f x y | f <- [(*), (/)], (x, y) <- l, f /= (/) || y /= 0], i need to add a guard here, but f /= (/) is not legal
08:00:41 <dafis> nostard: I think looking at the 70 lines will do for starters
08:00:50 <lars9> how to compare function?
08:01:14 <quicksilver> lars9: you can't.
08:01:34 <lars9> quicksilver: how to work it around for this problem?
08:01:38 <quicksilver> you can make an ADT which describes your operations and then refer to that
08:01:42 <quicksilver> data Op = Mul | Div
08:01:58 <quicksilver> run Mul = (*); run Div = (/)
08:02:18 <quicksilver> (run :: Num a => Op -> a -> a -> a)
08:02:33 <quicksilver> not quite actually because that's not the right type for (/)
08:02:36 <quicksilver> but that kind of idea
08:03:09 <lars9> quicksilver: i see, thanks
08:04:04 <shachaf> lars9: Alternatively you can use a safe division operator.
08:04:36 <nostard> dafis: ok =). http://hpaste.org/41499/no_of_entries_in_profile the functions we discussed begin at line 57
08:05:21 <nostard> dafis: in this case i get 2 entries for gracefulLabelings' but one for the non-primed.
08:05:56 <lars9> shachaf: not really for this case
08:06:11 * nostard just ordered Real World Haskell =)
08:06:11 <dafis> nostard: Graph is a list of edges, [(Int,Int)]?
08:06:13 <dino-> I'd like to use Network.Curl to write the file that's retrieved to a file, but it would be nice to avoid having it dump to stdout. Does anybody know of some examples of this type of usage? Everything I've been able to find so far is all about getting the response data back as a string.
08:06:18 <nostard> dafis: yep =)
08:06:37 <dino-> er, write the url that's retrieved to a file
08:07:37 <shachaf> lars9: What do you mean?
08:08:22 <dino-> Or maybe Network.Curl is a poor choice for this, that's fine too.
08:08:33 <lars9> in this case: [f x y | f <- [(*), (/)], (x, y) <- l, f /= (/) || y /= 0], i need to add a guard here, but f /= (/) is not legal
08:09:01 <shachaf> lars9: ...Alternatively you can use a safe division operator.
08:09:05 <lars9> a safe div still adds an item to the result list?
08:09:21 <shachaf> lars9: A safe div is whatever you want it to be.
08:10:06 <lars9> shachaf: how to let the safe div not add an elem to the result list?
08:11:15 <deech> Hi all, what does the '()' type mean? I see this most in the context of a function to return 'IO ()'.
08:11:57 <dino-> deech: It's the unit type whose only value is also ()
08:11:59 <lars9> :t ()
08:12:00 <lambdabot> ()
08:12:02 <shachaf> deech: It's a unit type. Think of it as a zero-element tuple.
08:12:11 <shachaf> dino-: () and _|_. :-)
08:12:17 <dino-> shachaf: yes!
08:12:59 <deech> So whenever I see () I can think 'nothing'? How is it different from bottom then?
08:13:15 <lars9> how to define a data: Data MyData a = MyData String a, with the constraint that a is a Num ?
08:13:19 <Saizan> > () `seq` "unit"
08:13:20 <lambdabot>   "unit"
08:13:29 <Saizan> > (undefined :: ()) `seq` "unit"
08:13:29 <lambdabot>   "*Exception: Prelude.undefined
08:13:32 <shachaf> lars9: You don't -- you put the constraint in the functions that use it.
08:13:50 <shachaf> deech: Bottom is very different -- it's a value that doesn't return once evaluated.
08:14:10 <deech> shachaf: And () just returns ()?
08:14:14 <shachaf> deech: You can't check if something is bottom -- examining a _|_ value is more or less equivalent to crashing your program.
08:14:25 <shachaf> deech: Not so much "returns" as "is", but yes.
08:15:13 <osaunders> Topic is out of date
08:15:50 <shachaf> > let safeMul x y = Just (x * y); safeDiv x 0 = Nothing; safeDiv x y = Just (x / y); l = [(5,3), (9,0), (4,8), (0,0)] in catMaybes [f x y | f <- [safeMul,safeDiv], (x,y) <- l] -- lars9
08:15:51 <lambdabot>   [15.0,0.0,32.0,0.0,1.6666666666666667,0.5]
08:15:53 <deech> Can I pattern match on ()? 
08:16:05 <dafis> nostard: I don't see why it would generate so many entries for gracefulLabelings', but overall, it doesn't look very efficient.
08:16:19 <shachaf> deech: Yes, though all that does is never return if the value happens to be _|_.
08:16:46 <shachaf> > let f () = 5 in f ()
08:16:47 <lambdabot>   5
08:16:48 <shachaf> > let f () = 5 in f undefined
08:16:49 <lambdabot>   *Exception: Prelude.undefined
08:17:03 <deech> I see, is there a use-case for () outside of IO ()?
08:17:50 <arcatan> some other monads with side-effects use it for similar purposes
08:18:14 <exDM69> > let f _ = 5 in f undefined
08:18:15 <lambdabot>   5
08:18:41 <osaunders> It's used in Data.Vec to represent empty.
08:18:56 <shachaf> deech: Anywhere you need a value but don't care much what it is.
08:19:04 <osaunders> 1:.2:.3:.() rougly equivalent to [1,2,3]
08:20:24 <nostard> dafis: i guess you are reffering to the use of ++ and permutations and similar? Those aren't the expensive functions so it really doesn't matter =)
08:20:33 <deech> So what I'm hearing is that () is the type equivalent of id. Is that correct?
08:20:49 <nostard> dafis: thank you very much for the help anyway =)
08:20:50 <shachaf> deech: Not really. Identity is the type equivalent of id.
08:21:22 <Saizan> the church encoding for () is the type of id though :)
08:21:23 <dafis> nostard: More isComplete, choose, possibly allSets
08:21:37 <shachaf> deech: () is the type equivalent for (the value) (). :-)
08:22:02 <deech> I'm thinking about it in the sense that I can throw in 'id' into a chain of functions without changing it : eg. func3 . func2 . id . func1 == func3 . func2 . func1
08:22:23 <Saizan> deech: and how would you do the same with ()?
08:22:40 <nostard> dafis: isComplete takes 0.0% of the time, and allSets 0.1% =)
08:23:04 <deech> In the same way that : Just 1 >>= \a -> Just () >> Just 3  == Just 1 >> Just 3
08:23:28 <shachaf> deech: That refers more to a property of the monad than to a property of ().
08:23:36 <shachaf> deech: You could use any value there.
08:23:50 <nostard> dafis: so i don't see any benefit of optimizing them =)
08:23:53 <dafis> nostard: Yes, but it's a matter of principle :)
08:24:11 <Saizan> > (Just 1 >>= \a -> Just "foo" >> Just 3) == (Just 1 >> Just 3)
08:24:12 <lambdabot>   True
08:24:12 <nostard> dafis: yep, "Premature optimiziation is the root of all evil" ;)
08:24:17 <osaunders> a is the closest thing I know to a type equivalent of id.
08:24:33 <dafis> nostard: By the way, what graph does kn create?
08:24:55 <nostard> dafis: a complete graph of n nodes
08:25:01 <deech> Then how about: Just 1 >>= \a -> () >>= \b -> Just 3?
08:25:09 <dafis> nostard: I really hate that quote. It hardly ever is used complete and appropriately.
08:25:23 <Saizan> deech: type error
08:25:27 <deech> Crap
08:25:50 <nostard> dafis: bah, it's was used just now by me very appropriately :D
08:25:52 <Saizan> the only thing that's special about () is the syntax
08:25:58 <shachaf> deech: () is just a value. You could make it yourself if you wanted.
08:26:04 <shachaf> data Unit = Unit
08:26:34 <Saizan> it's like Maybe a, but without 'a' and Just :)
08:26:56 <deech> So when I see "IO ()" is there an "()" instance of the IO typeclass defined somewhere?
08:27:00 <Saizan> but it's still a completely separate type
08:27:00 <dafis> nostard: It means to not start low level optimisations until you know where and why, but you should nevertheless get your algorithms fast from the beginning.
08:27:05 <shachaf> deech: IO isn't a type class.
08:27:23 <shachaf> deech: (If it was that syntax wouldn't be valid.)
08:27:48 <deech> shachaf: You're right. Sorry. I'm a little muddy.
08:27:50 <nostard> dafis: ok, yeah i guess so. But really, in many cases even the algorithm doesn't mather that much
08:28:09 <shachaf> deech: My usual advice for this situation is to pretend that IO doesn't exist. :-)
08:28:18 <dafis> nostard: True, but you don't know when that is as a rule.
08:29:02 <deech> Cool. I guess it'll click the first time I use it in practice.
08:29:19 <nostard> dafis: try first, if it is to slow: look into it =)
08:29:24 <Olathe> Is #haskell-cafe the proper non-Haskell channel?
08:29:26 <deech> Thanks for all your help.
08:29:46 <shachaf> Olathe: There's #haskell-blah.
08:29:50 <Olathe> Ahh, thanks.
08:29:50 <dino-> I so wish Google search didn't decide to not find what I typed and instead shows results for what they think I meant. jerky
08:30:00 <shachaf> Olathe: haskell-cafe@ is pretty on-topic, so you'd expect the channel to be similar.
08:30:10 <Olathe> Sure.
08:30:11 <dino-> Dear Google: I meant "callbackwriter" NOT f-ing "callback writer"
08:30:30 <shachaf> dino-: Add a + to the beginning of the word.
08:30:32 <dafis> nostard: I say, write fast algorithms as a matter of principle, if you don't need them, so what? But when you need them, it saves a lot of work and headaches.
08:30:59 <dino-> shachaf: They could have left it the way it was.
08:31:33 <nostard> dafis: i rather spend my time to think about the code that matters for my problem
08:33:07 <quicksilver> dafis: I think you have indeed failed to learn the lesson of premature optimisation ;)
08:33:08 <dafis> nostard: You should not need to think about the good algorithms in most cases, you just know them (of course, *optimal* algorithms is a different cup of tea).
08:33:33 <quicksilver> it is pointless spending programmer effort solving a problem you do not need to solve.
08:33:35 <shachaf> dino-: I agree -- on the other hand, there are some advantages to the auto-correcting one.
08:34:33 <nostard> dafis: so you rather implement an algorithm on 50 lines, rather than a one-liner even though you know that the speed isn't needed?
08:35:01 <jmcarthur> it's always worth thinking hard about what the best algorithm for your problem is. when you can't find that algorithm ready-made in a library, it's not always worth it to spend the time writing it yourself
08:35:42 <jmcarthur> i should say almost always
08:35:43 <dafis> nostard: No. But when it's one line for an n^2 algorithm versus two for an n*log n, I take the n*log n.
08:35:51 <nostard> jmcarthur: =)
08:36:00 <nostard> dafis: yeah
08:36:09 <jmcarthur> dafis: what if n is 2
08:36:15 <jmcarthur> not always worth it ;)
08:36:18 <nostard> =)
08:36:35 <dafis> jmcarthur: if n is bounded, all are O(1) :D
08:36:59 <jmcarthur> dafis: what if n is unbounded, but will be 2 in 99% of cases (not unrealistic, i think)
08:37:46 <shachaf> jmcarthur: If n is 2^64 the other 1%, a better algorithm than O(n!) is probably a good idea. :-)
08:37:47 <jmcarthur> i suppose it still depends on that other 1%
08:38:20 <jmcarthur> okay let's say it's a normal distribution where 99% of the time n=2
08:38:22 <jmcarthur> :P
08:38:26 <engla> well I don't like to write code that fails on the extreme cases.. those are the ones that matter. I mean, any code is going to be fast enough for N=2.. so we don't code for that case.
08:38:29 <jmcarthur> okay i have constructed a problem where i win
08:38:36 <dafis> jmcarthur: then it depends, if the constant factors make the O(n*log n) much slower for n = 2, that would enter the picture (and perhaps I'd write both and decide which one to take depending on the input).
08:39:20 <shachaf> dafis: jmcarthur's point, I think, is that some problems are small enough that putting any sort of effort into an algorithm other than brute force is wasted.
08:39:31 <jmcarthur> indeed
08:39:37 <jmcarthur> or rather...
08:39:54 <shachaf> dafis: You can call that O(1) if you want, but that's a bit of a cop-out -- the function you write to solve the problem is still general, just inefficient.
08:40:14 <jmcarthur> my point is that while the problem may have unbounded size, realistic-sized workloads might make big-O pretty meaningless next to programmer effort
08:41:29 <dafis> shachaf: If it's too inefficient even in 0.1% of the cases, it's not a suitable solution. Details vary of course.
08:41:44 <jmcarthur> i disagree
08:41:57 <quicksilver> you may know that the first 1000 uses are going to be a certain kind of case
08:41:59 <jmcarthur> sometimes it's just worth optimizing for the 80% majority
08:42:09 <quicksilver> and that after that you will received $100 million in venture capital
08:42:13 <jmcarthur> and screw the other 20%
08:42:19 <quicksilver> at which point you can write a PHP compiler and conquer the world.
08:43:30 <jmcarthur> dafis: this is a software engineering view that i'm arguing of course, not a computer science view with the idealism that most programmers can't afford to have
08:43:44 <Saizan> just like people waited for CPU/GPUs to get fast enough in the past
08:43:46 <jmcarthur> as a computer scientist, i'm with you. i would love for all my code to be 100% optimal in every way...
08:44:03 <dafis> jmcarthur: and I'm a hobbyist, so I have the time for the idealism.
08:44:08 <jmcarthur> but even from that point of view, there's an issue
08:44:28 <jmcarthur> optimizations have a tendency to destroy your code and your ability to reason about it
08:44:29 <quicksilver> you might find it more satisfying ot put your effort somewhere else
08:44:34 <quicksilver> even as an idealist
08:44:37 <jmcarthur> i guess you are not talking about low level optimization though
08:44:44 <quicksilver> you might be working on a clever mesh generation algorithm
08:44:58 <dafis> jmcarthur: low level optimisations enter the picture very late
08:45:00 <quicksilver> and you don't want to waste 2 weeks debugging a correct delaunay triangulator
08:45:12 <quicksilver> so you write a quick and dirty triangulator so you can get on with the interesting cases.
08:45:36 <jmcarthur> as an idealist, i prefer to think about whether my implementation even satisfies my model before i bother at all with the correct algorithms
08:46:37 <jmcarthur> Saizan: you never hear about that waiting game being fruitful :\
08:46:47 <shachaf> What a sad world it is when even idealists have to make priorities.
08:46:48 * hackagebot hjsmin 0.0.2 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.2 (AlanZimmerman)
08:47:11 <jmcarthur> shachaf: people are idealist about different things
08:52:16 <dino-> Ugh, having much trouble making sense of Network.Curl wrt writing the body out as it comes in.
09:02:55 <aristid> dino-: i'm switching away from Network.Curl
09:02:56 * hackagebot th-expand-syns 0.1.1.0 - Expands type synonyms in Template Haskell ASTs  http://hackage.haskell.org/package/th-expand-syns-0.1.1.0 (DanielSchuessler)
09:10:59 * hackagebot hakyll 2.4.1 - A simple static site generator library.  http://hackage.haskell.org/package/hakyll-2.4.1 (JasperVanDerJeugt)
09:14:06 <dino-> aristid: It's very opaque to me. Not documentation really. No examples other than getting (small, I guess) responses back as strings.
09:15:24 <aristid> dino-: http-enumerator looks good
09:19:06 <dino-> aristid: That looks very promising. Example in the API docs of writing body to a file in const space. Thank!
09:19:09 <dino-> Thanks!
09:19:25 <aristid> :)
09:44:17 <JoshTriplett> Does haskell-cafe block posts by non-subscribers?
09:47:23 <monochrom> yes iirc. but you can post through http://news.gmane.org/gmane.comp.lang.haskell.cafe
09:48:10 <JoshTriplett> monochrom: I'll just subscribe and disable mail delivery.  But it would have helped if http://www.haskell.org/mailman/listinfo/haskell-cafe explicitly said that only subscribers may post.
10:02:17 <endojelly> so now I discovered that something is in fact a Monoid
10:04:49 <endojelly> hmm, nah, I'll do it differently. never mind.
10:06:07 <monochrom> don't work too hard for monoids
10:06:40 <endojelly> yeah
10:09:23 * hackagebot SVGPath 1.0.1 - Parsing the path command from SVG  http://hackage.haskell.org/package/SVGPath-1.0.1 (TillmannVogt)
10:10:23 * hackagebot SVGFonts 0.3 - Fonts from the SVG-Font format  http://hackage.haskell.org/package/SVGFonts-0.3 (TillmannVogt)
10:20:23 <dons> News about haskell.org :  http://haskellorg.wordpress.com/2010/11/15/the-haskell-org-committee-has-formed/
10:32:00 <solistic> Can somebody fix the topic?
10:32:45 <aristid> @where ops
10:32:45 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
10:33:02 --- mode: ChanServ set +o dcoutts
10:33:05 --- topic: set to '["Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by dcoutts
10:33:08 --- mode: ChanServ set -o dcoutts
10:39:31 <dmhouse> solistic: what needs fixing?
10:42:01 <solistic> dmhouse: dcoutts_ has already changed it ;)
10:44:56 <unkanon> if I dream of making a vim plugin that will show the type of the haskell function under the cursor, what's the best source to get that list from?
10:45:02 <unkanon> is it this link?: http://www.haskell.org/onlinereport/standard-prelude.html
10:47:29 <dmhouse> unkanon: Emacs can do that :)
10:48:22 <rryan> unkanon: I'd like to buy a pony. Where can I buy one? dhouse: I have a pony. Does that help?
10:48:48 <rryan> :P
10:49:35 <dskippy1> Where is the 'on' function defined?
10:50:19 <arcatan> dskippy1: Data.Function
10:50:22 <_xvinyl> unkanon: use Yi in vi mode ?
10:50:33 <_xvinyl> :)
10:50:58 <dskippy1> Thanks arctan
10:51:54 <unkanon> lol
10:52:21 <unkanon> _xvinyl: when I'm more proficient at vi I might just do that
10:52:47 <unkanon> but really I'm just concerned with the best source for the types of the prelude functions
10:53:03 <_xvinyl> mmh
10:53:21 <_xvinyl> i don't know if there is an equivalent of Ocamlbrowser in Haskell
10:54:05 <nostrand> _xvinyl: maybe you could extract it from here: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Prelude.html
10:54:07 <gds> unkanon: There seems to be type info in these vim plugins: http://projects.haskell.org/haskellmode-vim/screencasts.html
10:54:13 <dons> more like ghc-api, _xvinyl ?
10:54:16 <lispy1> _xvinyl: fire up ghci and type, :t somethingFromThePrelude
10:54:40 <unkanon> lispy1: should I do that every time I type a function while I'm coding?  :)
10:55:00 <unkanon> plus I have to add modules to ghci because it doesn't see everything out of the box
10:55:19 <lispy1> unkanon: I guess it depends on your goals.  Several people pointed out existing editors that can show it to you.
10:55:39 <lispy1> unkanon: the prelude is there out of the box
10:55:54 <rryan> unkanon : haskell-mode for emacs hard-codes the prelude types 
10:56:09 <rryan> http://code.haskell.org/haskellmode-emacs/haskell-doc.el
10:56:12 <nostrand> unkanon: oh, that link was for you
10:56:20 <lispy1> unkanon: hayoo and hoogle are general purpose search engines you could use
10:56:24 <rryan> unkanon: search for haskell-doc-prelude-types
10:56:32 <rryan> you'll find the complete list that haskell-mode for emacs uses 
10:56:55 <rryan> for non-prelude stuff, it can parse the HTML docs for the modules, which is more advanced
10:57:01 <rryan> that file also describes how it does that... if you speak elisp
10:57:27 <unkanon> nostrand: thanks, that's a very nice page
10:57:51 <_xvinyl> dons: can't find ghc-api on hackage/google... is this a package ?
10:58:13 <unkanon> cool, I will go over those links, thanks guys
10:58:16 <monochrom> the package name is "ghc", and it comes with GHC, and it's initially hidden
10:58:18 <unkanon> and gals
10:59:17 <dons> its the 'ghc' package.
11:00:47 <_xvinyl> thanks
11:09:09 <_xvinyl> dons: well i think we were not really talking about the same thing, as i can't understand what's ghc-api :(
11:09:21 <dons> what functionality do you need?
11:09:23 <_xvinyl> dons: thanks anyway (and congratulations for your new position)
11:09:31 <dons> my new position?
11:09:36 <dons> oh !
11:09:37 <dons> hehe
11:09:48 <_xvinyl> committee ?
11:09:50 <monochrom> what new position?
11:10:08 <dons> http://haskellorg.wordpress.com/2010/11/15/the-haskell-org-committee-has-formed/
11:10:41 <monochrom> great, now everyone will lobby dons for language extensions
11:11:04 <dons> not my problem.
11:11:27 <c_wraith> yes, it's the haskell.org committee, not the haskell committee
11:11:34 <monochrom> oops
11:11:35 <engla> when is the "new-www" for haskell.org going live?
11:11:56 <monochrom> but even greater, now everyone will lobby dons for colour changes!
11:12:14 <dons> we have to work out a couple more things, and then a timetable for the move will be published.
11:12:15 <monochrom> "hi dons, I don't like red" "hi dons, I don't like blue"
11:12:25 <_xvinyl> engla: i thought it was down yesterday for this reason
11:12:39 <mauke> well, that's what custom CSS is for
11:12:42 <monochrom> colouring bikeshed is nothing compared to colouring links
11:12:48 <mauke> web skins, what a great idea
11:13:03 <dons> stay classy, guys.
11:13:32 <c_wraith> we're merely celebrating your new position, dons. :)
11:16:36 <sciolizer> If I'm creating a mini language with a Haskell like syntax, what's the trick to keep from putting a "expr := expr expr" bomb in my grammar?
11:16:36 <lambdabot> sciolizer: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:16:50 <_xvinyl> so haskell.org committer will act as coordinators for Hackathons too ?
11:18:06 <dons> nope
11:18:13 <tolkad> How do I tell --make mode of ghc what directories to search for modules in?
11:19:01 <sm> tolkad: -i extradir
11:19:11 <monochrom> sciolizer: the trick seems to be http://www.haskell.org/onlinereport/exps.html#sect3.3
11:19:32 <sm> tolkad: actually, I think it must be -idir, no space
11:19:44 <tolkad> sm: when I do that it stops finding stuff in the original dir
11:19:52 <tolkad> sm: even if I add the original dir to the path
11:19:56 <sm> surprising
11:20:06 <sm> are there duplicated module names ?
11:20:10 <tolkad> no
11:20:21 <tolkad> it gives a different message too
11:20:33 <tolkad> it says "it is not a module in the current program"
11:20:55 <monochrom> but I confess "fexp -> [fexp] aexp" is not quite factored to suit parsec.
11:20:56 <c_wraith> tolkad, use two -i options then.  -i. -idir
11:21:03 <sciolizer> monochrom: thanks
11:21:14 <c_wraith> -i is an option that can be repeated
11:21:20 <sciolizer> monochrom: it's ok; I'm using a glr parser
11:21:26 <monochrom> haha nice
11:21:49 <tolkad> c_wraith: that worked, thanks
11:23:49 <monochrom> when I did it in parsec, I used fexp = chainl1 aexp ...
11:25:12 <unkanon> sciolizer: how far into it are you? into that language you'recreating
11:25:48 <sciolizer> monochrom: haha, I wonder why that function was created. :)
11:26:38 <sciolizer> unkanon: I have a working calculator that can also do lists, dictionaries, and sets. (It's a dsl - not going to go for full blown ADTs, especially since it's dynamically typed and dictionaries are good enough.)
11:27:25 <sciolizer> unkanon: current bnf is about 104 lines long, but I want to switch from `function(application)` to `function application`
11:28:01 <tolkad> why can't I have unused type variables in a class constraint to the left of a data declaration?
11:29:14 <mauke> tolkad: how would you instantiate them?
11:29:28 <unkanon> sciolizer: good move on the func arg thing :)
11:29:38 <unkanon> sciolizer: is it on github or something? I'd be curious to follow that
11:29:59 <sciolizer> not currently
11:30:01 <sciolizer> company project
11:30:07 <sciolizer> But we plan to open source it at some time
11:30:13 <tolkad> mauke: why would I need to?
11:30:56 <mauke> tolkad: because you need a concrete type to use the value
11:32:03 <tolkad> mauke: well they might still be in the type signature, just hidden under a type application
11:32:24 <mauke> I don't understand
11:32:49 <tolkad> like...  data (t ~ (Maybe s)) => T t =  
11:33:11 <mauke> argh, sorry. I completely misread your question
11:34:00 <tolkad> sorry, I'm not very good at asking haskell questions. I'm still missing some vocabulary
11:34:27 <tolkad> so.. am I just doing the syntax wrong?
11:34:42 <tolkad> why does it care whether they are "in scope"?
11:34:57 <nolrai1002> Is there a good up-to-date tutorial on using quick check?
11:35:35 <tolkad> well, I guess it doesn't matter
11:35:42 <kmc> nolrai1002, RWH?
11:35:51 <tolkad> you can just enforce the constraint in any functions that USE T
11:35:56 <nolrai1002> kmc?
11:36:07 <kmc> nolrai1002, http://book.realworldhaskell.org/read/testing-and-quality-assurance.html
11:36:28 <kmc> though that's for version 1 i think
11:37:01 <kmc> tolkad, yeah, constraints on type constructors like that don't work very well
11:37:24 <kmc> constraints on *value* constructors work how you'd expect, iff you use GADT-style declarations
11:37:55 <kmc> data T t where MkT :: (t ~ (Maybe Char)) => t -> T t
11:38:29 <tolkad> ah, thanks
11:39:05 <kmc> err, i guess you wanted (Maybe s)
11:39:10 <kmc> though i'm not sure where s was supposed to come in scope
11:39:41 <nolrai1002> Great I am in here twice...
11:39:41 <BONUS> hmmm, so next haskell platform will feature mtl-2 instead of mtl?
11:39:41 <lambdabot> BONUS: You have 1 new message. '/msg lambdabot @messages' to read it.
11:40:28 <kmc> tolkad, http://hpaste.org/41501/gadts_and_equality_constraints
11:40:54 <kmc> i think T1 and T2 are entirely isomorphic; T1 is basically how GHC will desugar T2 internally
11:41:29 <kmc> equality constraints are the "more fundamental" feature in GHC; GADTs and type families are implemented by equality constraints
11:41:32 <kmc> see the System Fc paper
11:42:23 <ewr33> whats the typeclass for categories again?
11:42:30 <kmc> Control.Category.Category
11:42:35 <ewr33> thanks
11:42:43 <kmc> and probably a more general one in category-extras
11:43:19 <tolkad> is there an IOT?
11:43:23 <kmc> ?
11:43:31 <tolkad> MonadTrans version of IO
11:43:34 <TryToLearnHaskel> Hi everyone
11:43:44 <kmc> tolkad, it would be unsafe in the unsafePerformIO sense
11:43:47 <kmc> you can write it, though
11:43:48 <TryToLearnHaskel> I need help with this problem
11:43:57 <TryToLearnHaskel> This is the link http://hpaste.org/paste/41485/define_show#p41502
11:43:58 <tolkad> kmc: why?
11:44:11 <kmc> try to write it
11:44:28 <kmc> hackage has STMonadTrans, which has the same issue
11:45:06 <BONUS> TryToLearnHaskel: you don't have the string "," anywhere in your show code
11:46:01 <nostrand> TryToLearnHaskel: you need to have a special case for the first element
11:46:31 <TryToLearnHaskel> I try to put that but it will give me this {3,{4,{5,}
11:46:35 <TryToLearnHaskel> as an answer
11:46:59 <ewr33> TryToLearnHaskel: Show Empty is also wrong
11:47:06 <kmc> TryToLearnHaskel, it's easier to write a helper which shows without the {}
11:47:09 <kmc> TryToLearnHaskel, then wrap that
11:47:11 <monochrom> firstly, nevermind what you want happen. do you know why your code gives {3,{4,{5,}?
11:47:11 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
11:47:16 <kmc> the helper will be recursive
11:47:23 <nostrand> TryToLearnHaskel: like show xs = "{" ++ show' xs, where show' is similiar to the one you wrote
11:47:35 <BONUS> > intercalate "," (map show [1,2,3,4])
11:47:36 <lambdabot>   "1,2,3,4"
11:47:51 <BONUS> > "{" ++ intercalate "," (map show [1,2,3,4]) ++ "}"
11:47:52 <lambdabot>   "{1,2,3,4}"
11:48:27 <TryToLearnHaskel> so you want me to rewrite the data part
11:48:39 <TryToLearnHaskel> or the whole thing
11:49:09 <BONUS> nah just the show instance
11:49:11 <nostrand> TryToLearnHaskel: no, data is ok =)
11:49:13 <BONUS> the data part's cool
11:49:47 <TryToLearnHaskel> so are you talking about the instance part?
11:49:50 <BONUS> basically that's how you can display a normal list as {x,y,z} ... now you just ahve to make it work for List
11:49:53 <BONUS> yeah
11:51:32 <nocture> hi, im trying out some haskell, but has run into an issue, say i have a function declaration which takes another function as parameter (call it f), what does it mean when it is used like this: `f` in the expression? i can't seem to find the difference between just saying f or `f`
11:51:47 <TryToLearnHaskel> I'm unsure how to wrap something in, in Haskell
11:52:11 <BONUS> basically the show function is just how to turn something into a string
11:52:12 <tolkad> kmc:  newtype IOT m a = IOT { runIOT :: IO (m a) }; instance Monad m => Monad (IOT m) where { m >>= k = IOT (runIOT m >>= (>>= {- not exactly sure what to put here -})); return = IOT . return . return } 
11:52:24 <tolkad> kmc: I wrote most of it
11:52:31 <TryToLearnHaskel> Yeah I understand that
11:52:32 <mauke> nocture: x `f` y == f x y
11:52:40 <BONUS> and by wrap we mean first make the string "2,3,4" and then wrap it with { and } by turning it into "{2,3,4}"
11:52:47 <nocture> oh
11:52:49 <nocture> so its used infix instead?
11:52:53 <mauke> nocture: yes
11:52:56 <nocture> sweet
11:52:57 <nocture> thanks
11:53:21 * hackagebot error-message 1.1 - Composable error messages.  http://hackage.haskell.org/package/error-message-1.1 (GregoryCrosswhite)
11:54:33 <kmc> tolkad, newtype MaybeT m a = MaybeT { runMaybeT :: m (Maybe a) }
11:54:37 <kmc> so i think you have it backwards
11:54:42 <TryToLearnHaskel> BONUS: Do I need to make another my own special Show in the instance line, or in the show cases
11:54:46 <kmc> newtype IOT m a = IOT { runIOT :: m (IO a) }
11:54:51 <tolkad> oh
11:55:10 <tolkad> well I couldn't write that one either
11:55:14 <BONUS> TryToLearnHaskel: just make a separate function first. showMyList or something like that
11:57:02 <TryToLearnHaskel> BONUS: Does the function return a String 
11:57:07 <BONUS> yea
11:57:10 <BONUS> make a function showMyList
11:57:24 <BONUS> that takes, say, 3 :-: 4 :-: 5 :-: Empty and returns "3,4,5"
11:57:33 <BONUS> for Empty it should return ""
11:58:05 <BONUS> then you can make the Show instance like: show myList = "{" ++ showMyList myList ++ "}"
11:58:42 <TryToLearnHaskel> BONUS: Can I do something like this: showMyList (x:xs) = show x ++ "," ++ showMyList xs
11:59:15 <BONUS> TryToLearnHaskel: try it. but for a single element, that would print out "3,"
11:59:31 <BONUS> so you have to make a separate case for a single element
11:59:35 <BONUS> but that's the gist of it yeah
12:01:27 <TryToLearnHaskel> BONUS: I'm not sure how to run that showMyList
12:02:57 <monochrom> eh? we have forgotten that showMyList should be like showMyList (x :-: xs) = show x ++ "," ++ showMyList xs
12:03:45 <monochrom> and to run it you enter showMyList (3 :-: (4 :-: Empty))
12:04:01 <BONUS> TryToLearnHaskel: try this http://hpaste.org/41504/basasfasfsaf
12:04:05 <Mitar> why i do not get a link in haddock in description of a module when i try to make a link to another module?
12:05:33 <tolkad> kmc: maybe something like this would work: data Mu3 f g h = In (f (g (h (Mu2 f g h)))); newtype IOT m a = IOT {runIOT :: Mu3 (Either a) m IO } 
12:06:18 <kmc> can you explain that code tolkad
12:07:53 <TryToLearnHaskel> BONUS: Thank you it work perfectly fine now
12:08:11 <BONUS> np
12:08:12 <tolkad> kmc: I messed up
12:08:16 <kmc> tolkad, why use the explicit fixed-point?
12:08:32 <tolkad> kmc: maybe something like this would work: data Mu3 f g h = In (f (g (h (Mu2 f g h)))); newtype IOT m a = IOT {runIOT :: Mu3 (Either (m (IO a))) m IO } 
12:08:41 <tolkad> uh wait I don't need the Mu3
12:09:57 <tolkad> kmc: newtype IOT m a = IOT {runIOT :: Either (m (IO a)) (m (IO (IOT m a))) } 
12:10:23 <kmc> why and how would that work?
12:12:14 <TryToLearnHaskel> BONUS: You are a life saver, I have been spending a lot of time on this problem with my group
12:12:50 <BONUS> hehe, cool. just always break your problem into smaller subproblems and build from there, thats always a good approach
12:14:58 <krey_> hello, I'm interested in learning about haskell / theory related to haskell
12:15:16 <krey_> any recommendations? (books, pdfs, idunno)
12:15:24 <tolkad> kmc: well, the problem is that when you try to write  m >>= k = runIOT m >>= (>>= k)  it doesn't work because k returns something wrapped in an IO and you can't get it out of the IO.
12:15:52 <tolkad> kmc: so instead, you can write something like  m >>= k = runIOT m >>= (>>= (return . return . k)) !
12:16:12 <tolkad> kmc: and that's how you end up with the (m (IO IOT))
12:16:21 <tolkad> uh wait
12:16:28 <tolkad> no that wont work
12:16:34 <byorgey> krey_: that's rather broad =)
12:16:38 <tolkad> maybe I could use unsafeCoerce
12:16:46 <kmc> krey_, that's very vague, what do you want to learn?
12:16:56 <kmc> how to program in Haskell? type theory? implementation?
12:17:52 <byorgey> krey_: also, what sort of programming background do you have?  mathematical background?
12:18:10 <krey_> kmc, byorgey: I know it's rather vague/broad, i was hoping you guys could tell me what stuff is available/what my options are
12:18:25 <kmc> krey_, well, i gave you three categories above
12:18:40 <krey_> byorgey: I can do some haskell, imperative, oop, and a lotta maths, you name it :P
12:19:04 <kmc> krey_, if you've already started programming in Haskell: what part of the language would you like to learn more about?
12:19:34 <byorgey> krey_: reading some functional pearls is a nice way to learn more haskell and theory at the same time
12:19:48 <krey_> kmc: i'm not sure, but i'm quite interested in formal logic (incl. lambda calc), computation and type theory
12:19:52 <monochrom> propositional logic is a theory related to haskell
12:20:04 <byorgey> krey_: http://haskell.org/haskellwiki/Research_papers/Functional_pearls
12:20:27 <kmc> krey_, read TaPL
12:20:29 <kmc> @where tapl
12:20:29 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:20:50 <haskellElephant> @pl \(x, y) -> (+x) *** (+y)
12:20:50 <lambdabot> uncurry ((. (+)) . (***) . (+))
12:21:11 <krey_> byorgey: I see the names spivey and bird, both are at my uni (spivey's my friend on fb) :)
12:21:34 <byorgey> krey_: well then, you absolutely must read some functional pearls =)
12:21:44 <byorgey> krey_: or read Bird's new book
12:21:51 <krey_> byorgey: thanks, bookmarked, will go through them
12:21:55 <byorgey> http://www.cambridge.org/us/knowledge/isbn/item5600469/
12:22:49 <krey_> byorgey: looks interesting, have you read it?
12:23:00 <byorgey> krey_: not yet, I just ordered it
12:23:09 <byorgey> it just came out a couple months ago
12:23:26 <byorgey> I have no doubt it will be fantastic though.
12:23:39 <krey_> byorgey: that's really interesting, I thought bird had retired two years ago!
12:23:40 <BONUS> ooh i gotta get that
12:24:02 <krey_> kmc: this book also looks interesting, thanks :)
12:24:43 <byorgey> krey_: as long as we are namedropping, the author of TaPL is my friend on fb ;)
12:25:34 <BONUS> so wait, am i getting this right: the next version of the haskell platform will feature version 2 of mtl
12:25:45 <krey_> byorgey: :-)
12:26:06 <byorgey> BONUS: yes
12:26:33 <BONUS> i gotta update lyah with the interface changes before it goes to print
12:31:07 <sm> persistent highlight-lines-matching-regexp config is very handy in ledger-mode
12:34:15 <c_wraith> woo, my copy of Pearls of Functional Algorithm Design arrived.
12:34:57 <BONUS> gotta order that as soon as i get my hands on some cash
12:36:38 <dskippy1> Is there an easier way to export all constructors of a type from a module than listing them all out in the export?
12:37:02 <dskippy1> I have a data type with 20 null constructors. It's an enum-style data type. 
12:37:14 <dskippy1> Seems silly to listen them all out again in the export.
12:37:28 <roconnor> BONUS: soon you will have a dumptruck of royalty cheques poured onto your porch.
12:37:44 <dmhouse> I think you can do Type(..)
12:38:12 <monochrom> module Woohoo(Everything(..)) where data Everything = This | That { that :: Int }
12:38:23 * BONUS rubs hands in anticipation
12:38:57 <roconnor> unfotunately each cheque will be for a fraction of a cent
12:38:58 <dskippy1> Doesn't seem to like ...
12:39:06 <monochrom> use credit card to buy bird's book so you pay later, right when you receive money for your book
12:39:17 <dskippy1> Ah it's only two dots.
12:39:36 <monochrom> always try my example literally before reporting problems
12:39:45 <BONUS> i have to tell the publisher to send me those oversized novelty cheques, those are awesome
12:39:54 <monochrom> use computer copy-paste, do not trust yourself.
12:40:03 <monochrom> never trust any human. any human at all.
12:40:09 <monochrom> exterminate all humans
12:40:12 <dskippy1> Right, right I got it.
12:40:40 <dskippy1> But if I copy paste I'm trusting you. You're human right. 
12:40:45 <dskippy1> Never mind, don't answer.
12:40:48 <monochrom> I am a computer.
12:41:01 <monochrom> \/  <-- the bot rejoices
12:41:15 <Mitar> why i do not get a link in haddock in description of a module when i try to make a link to another module?
12:41:55 <byorgey> BONUS: with balloons
12:42:03 <BONUS> yeah lol
12:42:31 <byorgey> Mitar: you have to do some magic command-line incantations to get it to link to modules from other packages
12:42:35 <byorgey> I don't remember what they are
12:44:40 <Molten> Hey guys is this the chat room for Haskell?
12:44:46 <Molten> As in the programming language?
12:45:00 <monochrom> yes
12:45:15 <Molten> Oh great :(
12:45:19 <Molten> :)**
12:45:39 <Molten> Could you help me with a small haskell problem?
12:46:15 <sipa1024> maybe
12:46:17 <monochrom> If it turns out that I can't solve this small problem, will it mean I can't even solve small problems?
12:46:28 <byorgey> Molten: don't ask to ask, just ask =)
12:47:01 <Molten> lol
12:47:03 * fryguybob is on the edge of his seat...
12:47:20 <sipa1024> tension is rising
12:47:54 <Molten> Well, basically, I'm REALLY new to Haskell, I read the starting out part of 'learnyouahaskell.com' and I want to find a solution to a this problem:
12:48:18 <Molten> I need to find the partition of a positive integer
12:48:36 <Molten> example: parts 4 = [[1, 1, 1, 1], [1, 1, 2], [1, 3], [2, 2], [4]]
12:49:01 <Molten> So far I've just figured this out: partOne var = [a | a <- [var-1]] ++ [b | b <- [var - (var-1)], var - 1 > 0]
12:49:27 <Molten> Which if you did partOne 4 it would give a list [3,1]
12:49:35 <Molten> I sort of know how to solve this problem
12:50:04 <byorgey> Molten: [var-1] is just a list with a single element, is that what you meant?
12:50:09 <Mitar> ahh, the problem was that i was using single quotes instead of double
12:50:10 <tromp__>  [a | a <- [var-1]]  is a silly way to write [var-1]
12:50:16 <haskellElephant> @pl \(x,y) (z,w) = (x+z,y+w)
12:50:16 <lambdabot> (line 1, column 14):
12:50:16 <lambdabot> unexpected "="
12:50:16 <lambdabot> expecting pattern or "->"
12:50:26 <haskellElephant> @pl \(x,y) (z,w) -> (x+z,y+w)
12:50:26 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
12:50:39 <Molten> You'd just divide every element of a list to form a new list which would add up to the main integer, finally giving all the partitions of the number
12:51:00 <Molten> @tromp what would you suggest? :S
12:51:00 <lambdabot> Unknown command, try @list
12:51:11 <Molten>  @ tromp what would you suggest?
12:52:41 <Molten> This somewhat does what I want except I don't know how to do the recursive call to make a new list of a non-one value: partitionOld y = [[x,y] | x <- [y,y-1..1], y <- [y-x]]
12:54:17 <tromp__> use a helper function that gives partitions of n with a minimum of m
12:54:48 <haskellElephant> I'm working on my point free skills, and the best I can do on the above function is: uncurry (***) . ((+) *** (+)) , anyone got any good Ideas on how to do it better?
12:55:37 <Molten>  @tromp... helper function? Is that basically a function like:
12:55:47 <Molten> divideBy2 :: (Num a) => a -> [b]
12:57:08 <byorgey> haskellElephant: that's pretty good.  this particular task comes up from time to time and annoyingly there is no nicer way to do it pointsfree.
12:57:31 <byorgey> haskellElephant: probably the best approach is to think about a nice pattern to abstract out and implement it in terms of that
12:57:43 <Molten> Hmm
12:58:32 <Molten> I was probably thinking first make the divideBy2 function which takes a number and returns a list of values which have been divided once and all the items equal to the original number?
12:59:22 <Molten> However, I'm having a hard time getting the syntax right :(
12:59:35 <haskellElephant> byorgey: I was thinking it looks a lot like Data.Function.on , but I haven't found a nice way to  use that with this task, It's almost like fmap really.
12:59:48 <Molten> Here's my divide by 2 code so far
12:59:53 <Molten> divideBy2 :: a -> [b]
12:59:58 <Molten> divideBy2 1 = [1]
13:00:02 <Molten> divideBy2 n = divideBy2 [n-1]
13:00:23 <Molten> The third line would actually get EVERY division until 1 but I've simplified it right now
13:00:37 <Molten> I keep getting a syntax error though
13:00:55 <jmcarthur> :t uncurry (***) . ((+) *** (+))
13:00:56 <lambdabot> forall c c'. (Num c, Num c') => (c, c') -> (c, c') -> (c, c')
13:01:05 <jmcarthur> :t on
13:01:06 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:01:50 <byorgey> Molten: what is divideBy2 supposed to do?  Can you give an example?  e.g. what should  divideBy2 6 == ?
13:02:05 <Molten> What I want the function divideBy2 to do though is that it would return a list of lists of numbers that recursevely all add up to a number
13:02:18 <jmcarthur> newtype Two a = Two (a, a) ; ... ; haskellElephant'sFunction = liftA2 (+)
13:02:59 <Molten> ex divideBy2 4 == [[4],[2,2]... But here [2,2] one of the 2s would get divided to form [2,1,1] etc
13:03:06 <tromp__> so what is the  list of lists of numbers that recursevely all add up to 3?
13:03:09 <byorgey> well,  unTwo . liftA2 (+) `on` Two
13:03:40 <Molten> divideBy2 3 == [[3],[2,1],[1,1,1]] I'd say
13:03:54 <jmcarthur> byorgey: sure, but who's to say that Two isn't actually the desired type anyway?
13:04:10 <jmcarthur> i should have called it Vec2
13:04:26 <Molten> which I get basicall means that the 2 in [2,1] gets devided by 2 again (as it's not 1) by the recursive call to give the final [1,1,1]
13:04:29 <tromp__> so it's the partition function?
13:04:34 <Molten> Hope it sort of makes sense
13:05:07 <Molten> well yeah actually, though it can have repeats like [2,1] [1,2] and I was thinking the partition function filters the repeats out?
13:05:54 <tromp__> that's inefficient
13:05:58 <edlinde> whats this mean "x -: f = f x "?
13:06:02 <tromp__> you shld avoid generating repeats
13:06:06 <edlinde> I don't get the -: ... format
13:06:15 <Molten> hmm tromp you're right it is :(
13:06:18 <BONUS> edlinde: it's just a normal function definition
13:06:21 <BONUS> in infix
13:06:40 <edlinde> BONUS: hmm I haven't seen that one before 
13:06:46 <BONUS> you can also write it as (-:) x f = f x
13:06:54 <Molten> But I can't seem to find an easy way to solve it, there is an answer I found on the internet but it's very complicated (for me) and I'm intent of figuring an answer out myself! :)
13:07:09 <tromp__> try find recursion for partition with a minimum
13:07:10 <edlinde> BONUS: ah so "-:" is the infix operator here?
13:07:19 <BONUS> basically when a function's name is made up of only special characters, you can define it as infix and use it as infix
13:07:24 <BONUS> for instance:
13:07:29 <Molten> Should I keep working on this: partitionOld y = [[x,y] | x <- [y,y-1..1], y <- [y-x]]
13:07:47 <BONUS> > let x ^-:^* z = x + z + z in 3 ^-:^* 4
13:07:48 <lambdabot>   11
13:07:51 <Molten> because I actually recoded the partition program to something else as my mind came to a roadblock trying to implement recursion for that
13:08:07 <BONUS> -: is just a normal function, like + or *
13:08:09 <edlinde> ok
13:08:10 <BONUS> but we define it
13:08:16 <edlinde> got you 
13:08:22 <edlinde> BONUS: did you write up LYAH?
13:08:27 <BONUS> yaes
13:08:53 <edlinde> BONUS: Hmm I think the chapter on "Fistful of Monads" has a lot of stuff repeated at the start 
13:08:54 <edlinde> :)
13:09:08 <Martty> BONUS: there's a bug in your stack
13:09:18 <proq> fistful of monads? that's a terrible name
13:09:19 <BONUS> yeah it does, lyah sometimes does that so that people don't have to look at previous chapters
13:09:25 <BONUS> Martty: yeah? where
13:09:34 <BONUS> proq: ever seen the movie a fistful of dollars?
13:09:46 <proq> I don't think I have
13:09:52 <BONUS> it's rly good, you should
13:10:06 <writer> monads trilogy :P
13:10:07 <edlinde> BONUS: its just that it makes it tedious to read through the same examples over and over again.. coz I am thinking maybe I missed something about functors or applicative functors :)
13:10:27 <Martty> BONUS: http://s3.amazonaws.com/lyah/rpn.png check the order of the operators. its not consistent
13:10:29 <haskellElephant> Hmmm, I've tried getting the liftA2 (+) to work, however It's giving me some really weird errormessage about Integer not beeing a Monoid. Isn't this defined somewhere? making Int a monoid should be trivial!
13:10:57 <Molten> hey tromp I started a private chat with you, did you get it?
13:10:59 <edlinde> BONUS: am reading your example about birds landing on a pole now
13:11:03 <edlinde> :)
13:11:05 <BONUS> edlinde: yeah it's a teaching choice i made. it sort of repeats how we got from functors to applicatives so that it's easier to see how we can extend applicatives to monads
13:11:08 <BONUS> hehe cool
13:11:08 <BONUS> Martty: let's see
13:11:41 <edlinde> BONUS: I just want to get to the end ... am impatient
13:11:42 <BONUS> Martty: what do you mean that the order is not consistent
13:12:01 <BONUS> edlinde: take it easy, imagine you're in karate kid.
13:12:04 <Martty> BONUS: the last one should be 14-10
13:12:15 <Martty> the previous one is 2+7 not 7+2 
13:12:19 <edlinde> BONUS: that was a crap movie :)
13:12:20 <Martty> same with 3+4 and not 4+3
13:12:27 <edlinde> wipe on wipe off 
13:12:29 <edlinde> hehe
13:13:33 <BONUS> Martty: i see your point. in the end it does amount to the same thing though
13:13:41 <BONUS> because of the commutativity of * and +
13:13:52 <BONUS> but yeah i see what you're getting at. i might change that
13:13:54 <Martty> BONUS: yeah, that's probably why you missed it
13:13:59 <Martty> you should change it, its terribly confusing
13:14:26 <roconnor> Ha.  ``We'll also take a look at monoids, which are sort of like socks.''
13:14:28 <BONUS> i will change it, thanks for the warning
13:14:45 <BONUS> roconnor: you have two and all of a sudden there's just one
13:14:46 <Martty> BONUS: on a more positive comment, the tutorial is great
13:15:03 <roconnor> :D
13:15:07 <BONUS> Martty: thanks :) but i really appreciate people pointing out mistakes
13:15:22 <Martty> i wish you updated the PDF
13:15:34 <BONUS> yeha, pdf wasnt made by me and i dont have the source :\
13:15:44 <Martty> i guess i'll just print the html later
13:15:53 <BONUS> there's gonna be a pdf now when the book comes out, with pictures and everything
13:16:07 <edlinde> stupid question but should I be using guards when I want to have function clauses for each kind of pattern match?
13:16:12 <edlinde> is that when they are useful?
13:16:40 <BONUS> no, use guards when you want to have function bodies depending on if some condition is true
13:16:50 <BONUS> for pattern matches, just do pattern matching
13:16:57 <BONUS> like f [] = blah; f (x:xs) = foo
13:17:10 <edlinde> I can say ; ?
13:17:17 <BONUS> if you want
13:17:25 <edlinde> k
13:17:43 <BONUS> but unless you're doing it in one line to demonstrate something over irc, it's better if you dont
13:17:49 <edlinde> I didn't get when you say function bodies depend on a condition being true
13:17:52 <edlinde> sorry
13:18:35 <edlinde> its kind of not clear when I should use a guard and not write a separate function clause 
13:19:00 <edlinde> I know I have to start writing some serious haskell code first :)
13:19:33 <arcatan> why so serious?
13:19:45 <edlinde> BONUS: you got some good examples?
13:19:53 <edlinde> arcatan: ok maybe some funny code
13:20:10 <BONUS> edlinde: if youre reading lyah there's a section about guards and pattern matching
13:20:11 <edlinde> I am just wondering what I can use Haskell for after reading through LYAH 
13:20:12 <byorgey> f [] = ...; f (x:xs) = ....  -- this should not be done with guards
13:20:13 <dskippy1> edlinde: General rule of thumb is to use guards when a pattern match is not powerful enough but you still want to have the body depend on that condition.
13:20:30 <edlinde> byorgey: i know
13:20:33 <byorgey> f [] = ...; f (x:xs) | x > 2 = ... | otherwise = ...   -- this requires a guard
13:20:36 <BONUS> edlinde: http://hpaste.org/41506/asfasfasfas
13:20:51 <BONUS> guards good for stuff like this. we're not deconstructing x based on its constructors
13:20:58 <edlinde> I see
13:20:59 <dskippy1> edlinde: It would be silly fro me to use a guard to separate two bodies for my list function, on for it being empty and one not, since a pattern can do that.
13:21:04 <BONUS> but we have differet function bodies based on some condition being true or not
13:21:14 <edlinde> so the guard is really like a case statement huh?
13:21:19 <BONUS> basically use guards instead of doing if else then else if else if
13:21:20 <BONUS> blah blah
13:21:28 <BONUS> no, a case statement is like a case statement
13:21:35 <BONUS> i mean case expression
13:21:42 <edlinde> hmm
13:21:42 <BONUS> pattern matching is morelike case expressions
13:21:45 <dskippy1> edlinde: But if I want something more expressive, like if the first element of the list is equal to some other agument, then I need a guard.
13:21:49 <BONUS> cause you deconstruct on things
13:22:02 <edlinde> ok and with a where clause?
13:22:18 <edlinde> so that it goes past guards and you can access stuff in many guards yeah?
13:22:26 <monochrom> > case 5 of x | x<4 = "hey" | x>=4 = "woohoo"
13:22:27 <lambdabot>   <no location info>: parse error on input `='
13:22:29 <edlinde> I mean if there is a need
13:22:40 <monochrom> > case 5 of {x | x<4 = "hey" | x>=4 = "woohoo"}
13:22:40 <lambdabot>   <no location info>: parse error on input `='
13:22:52 <monochrom> oh!
13:22:59 <monochrom> > case 5 of {x | x<4 -> "hey" | x>=4 -> "woohoo"}
13:22:59 <lambdabot>   "woohoo"
13:23:47 <monochrom> > case 5 of {x | y<0 -> "hey" | y>=0 -> "woohoo" where y = x*x}
13:23:48 <lambdabot>   "woohoo"
13:24:33 <edlinde> ok
13:24:34 <monochrom> I should learn to read error messages for real.
13:24:56 <edlinde> what would be a good project to do in haskell?
13:25:13 <edlinde> I mean something complicated enough to get the hang of it
13:25:19 <arcatan> the timeless classic I always suggest: an interpreter for a programming language
13:25:45 <edlinde> arcatan: slightly more interesting maybe? :)
13:25:54 <BONUS> that's actually rly interesting
13:25:56 <monochrom> complicated enough usually implies lost enough
13:26:17 <BONUS> maybe try making a JSON document store, something like couchdb
13:26:20 <BONUS> a simple one
13:26:37 <arcatan> or just do something you'd do anyway but do it in Haskell
13:27:41 <edlinde> arcatan: hmm yeah I usually do a lot of work with data structures etc, but I think they wouldn't be too hard to do in Haskell
13:27:58 <edlinde> search trees, hash tables etc
13:28:12 <edlinde> I believe there must be haskell modules out there that already do that stuff yeah?
13:28:12 <BONUS> make an avl tree, in haskell you can do it in like 20 minutes
13:28:17 <BONUS> yeah
13:28:32 <edlinde> hmm that might be interesting actually
13:28:44 <edlinde> a self balancing tree might not be as simple a task
13:28:50 <edlinde> (well for a beginner like me) :)
13:29:06 <BONUS> most of the stuff is in the rotations and the avl rotations are simple to do in haskell
13:29:09 <edlinde> maybe a B-tree
13:29:11 <BONUS> cause of the pattern matching
13:29:18 <edlinde> okie
13:29:26 <BONUS> b-tree is a bit harder to do than avl tree
13:29:29 <edlinde> I just want to know where I can use monads and functors etc
13:29:33 <monochrom> and because there is no obsession over "modify in-place, don't create new nodes"
13:29:42 <BONUS> yeah that too
13:29:44 <edlinde> yeah :)
13:30:03 <lispy1> looking for a btree?
13:30:12 <lispy1> I started a btree Haskell implementation, I could use some help
13:30:16 <edlinde> I haven't had any ideas about how to use monads yet... 
13:30:41 <lispy1> I'm going to formally verify it
13:30:58 <lispy1> To help make it distinct from all its competitors
13:31:04 <edlinde> lispy: I was just saying that I wanted to think of something where I could learn haskell in the process
13:31:18 <edlinde> lispy: what competitors?
13:31:34 <edlinde> lispy: you mean other trees? or B-tree implementations in haskell?
13:32:10 <lispy1> Ohh
13:32:39 <lispy1> edlinde: Maybe not a good first project.  To answer your other question, to compete with implementations not in Haskell (such as Berkley DB)
13:33:09 <edlinde> lispy1: are you working on building a DB in haskell?
13:33:30 <lispy1> edlinde: Of sorts.  I think it would be useful in darcs
13:33:45 <lispy1> and maybe someday I'll make a Haskell SQL DB, but that requires lots of work
13:34:07 <shachaf> lispy1: Oh, how's your B-tree going?
13:34:43 <ulfdoz> I'd prefer a prolog-like deductive DB.
13:34:59 <lispy1> shachaf: I've been neglecting it :(
13:35:06 * hackagebot happstack-heist 0.5.1 - Support for using Heist templates in Happstack  http://hackage.haskell.org/package/happstack-heist-0.5.1 (JeremyShaw)
13:35:48 <lispy1> shachaf: I was meaning to write a version and use quickcheck in place of a theorem prover, get it working and then revisit the assurance story when haskell-verifier is more mature
13:36:06 <lispy1> I don't think I've written that  plan down anywhere  yet
13:38:43 <dr460neye> hi there
13:40:11 <dr460neye> i got a big problem on little code. http://hpaste.org/41507/expression_reducer  
13:40:33 <dr460neye> i try to write a method to simplify user input
13:40:51 <dr460neye> but i get some problems with line 9 to 15
13:41:30 <dr460neye> because i want to use some unknows values which are no parameters
13:41:42 <BONUS> you can't do x == (Val _)
13:41:56 <BONUS> you can only do (Val _) in pattern matching
13:42:10 <dr460neye> i know
13:42:12 <BONUS> so instead of writing simplify with guards like you did
13:42:13 <BONUS> just do
13:42:26 <mightybyte> @pl (\f g a b c d -> f $ g a b c d)
13:42:26 <lambdabot> (.) . (.) . (.) . (.)
13:42:44 <BONUS> simplify x@(Add _ (Var _)) = x
13:42:56 <BONUS> simplify x@(Add (Var _) _) = x
13:42:59 <BONUS> etc
13:43:09 <dr460neye> the problem at the @ is that they are overlapping
13:44:09 <BONUS> just do
13:44:12 <dr460neye> in the 3 rd line i use 2 Val expressions in line 9 i use _ and (Val _)
13:44:17 <dr460neye> ok i'll try
13:44:19 <BONUS> simplify x@(Add _ _) = x
13:44:40 <BONUS> oh wait no
13:46:51 <BONUS> wait what's the point of lines 9 to 15 anyway
13:47:04 <BONUS> wouldnt this work without them?
13:48:16 <dr460neye> no, because if i try this it doesn't simplify all Expr simplify (Add (Mult (Val 5) (Mult (Val 5) (Val 3))) (Var "x"))   => Add (Mult (Val 5) (Val 15)) (Var "x")  but it should be Add (Val 45) (Var "x")
13:50:37 <dr460neye> you got any idea
13:53:30 <pygmalion> what's the best way to check if a list is a singleton?
13:53:42 <opqdonut> pattern match for [x] ?
13:54:35 <oscar_boykin> I have a function that profiling is telling me is allocating most of my memory: http://hpaste.org/41508
13:55:02 <BONUS> dr460neye: hmm yeah it's cause that example comes to line 6, simplifies the adds but then returns them like that
13:55:05 <oscar_boykin> I'm a bit of a newbie, so I don't see where toRUDot in http://hpaste.org/41508 is allocating.  Thunks?
13:55:06 <BONUS> instead of doing the adas
13:55:25 <xxxxx> A cap P\A=empty is not?
13:55:42 <edlinde> dr460neye: did you fix your problem?
13:55:47 <dr460neye> no
13:55:51 <aristid> the http://nlpwp.org seems to be a thinly disguised haskell tutorial :/
13:56:21 <dr460neye> got the same problem of overlapping
13:56:48 <BONUS> dr460neye: try doing this: on lines 6 and 7, check if both simplify x and simplify y result in Val values
13:57:12 <BONUS> if they do, then return a Val where you just add/multiply both values
13:58:48 <dr460neye> hmm, i don't know how you mean it
13:58:51 <edlinde> dr460neye: I think you got some redundant cases
13:58:59 <BONUS> dr460neye: http://hpaste.org/paste/41507/asfasf#p41509
13:59:03 <BONUS> the code is ugly but should work
13:59:34 <Dashkal> Is it possible to slot mtl-1.1.0.2 next to mtl-2.0.1.0 safely?  xmonad wants 2.x, but XMonadContrib wants 1.x
13:59:46 <edlinde> don't think he even needs simplify (Add (Val x) (Val y)) = (Val (x+y))
13:59:46 <edlinde> simplify (Mult (Val x) (Val y)) = (Val (x*y))
13:59:54 <edlinde> is that not redundant?
13:59:54 <aristid> BONUS: hmm, i think that's something where view expressions are nice
14:00:09 <BONUS> aristid: yeah good call
14:00:34 <BONUS> :r
14:00:36 <BONUS> whoops
14:01:07 <dr460neye> @elinde, no it's not. because if i don't do this. then the code simplifies nothing
14:01:08 <lambdabot> Unknown command, try @list
14:01:37 <aristid> BONUS: why do you reevaluate simplify x / y here instead of reusing the values from above? _ -> (Add (simplify x) (simplify y))
14:02:11 <BONUS> aristid: i didn't say it's efficient :)
14:02:26 <arcatan> @pl a >>= \x -> b x >> return x
14:02:26 <lambdabot> liftM2 (>>) b return =<< a
14:02:42 <aristid> BONUS: well it's also uglier this way :) but you said it is ugly, so... ;)
14:03:14 <BONUS> heres another slow & ugly one http://hpaste.org/paste/41507/bonus#p41510
14:03:20 <BONUS> now lets  use view patterns to make a pretty one
14:03:57 <dino-> I have a script that I'm executing with runhaskell. Due to a recent installation I'm now getting an ambiguous module Control.Monad.Error because it's found in both mtl and monads-tf ..
14:04:19 <dino-> Can I specify which of those to use with args to runhaskell?
14:04:35 <dino-> Not seeing anything that looks right in ghc --help output yet. :/
14:04:38 <edlinde> dr460neye: what you are trying to solve is a bit more complicated than you think I believe
14:05:07 <edlinde> dr460neye: can you paste your latest code? I had an error with the last one 
14:05:09 <dino-> Or maybe, if this is complicated enough to be using ErrorT, it should be cabalized. ;)
14:06:50 <edlinde> dr460neye: did you get my last message?
14:06:54 <dr460neye> yes
14:07:02 <dr460neye> i'm on posting :)
14:07:08 <edlinde> dr460neye: ok cool
14:07:43 <edlinde> dr460neye: so is that your only problem ? or you stuck with more stuff in there? 
14:07:52 <BONUS> aristid: here's one with view patterns http://hpaste.org/paste/41507/with_view_patterns#p41511 you were right. hmmm i wonder if we can combine view patterns and at the same time avoid recomputation
14:07:57 <edlinde> dr460neye: that thing could crash given some weird expressions I believe :)
14:10:08 <dr460neye> http://hpaste.org/41512/expression_reducer?pid=41512&lang_41512=Haskell
14:10:13 <dr460neye> this was my latest code
14:10:23 <BONUS> dr460neye: did you see my annotations?
14:10:23 <dr460neye> before bonus helped me
14:10:25 <BONUS> oh
14:11:27 <edlinde> dr460neye: was this that failed? simplify (Add (Mult (Val 5) (Mult (Val 5) (Val 3))) (Var "x")) 
14:11:54 <dr460neye> yes, but i'm not good in multitasking. so i'm a little bit overstrained in talking and coding and posting :)
14:12:03 <dr460neye> yes
14:12:08 <dino-> OR should I actually uninstall mtl now and use newer libs?
14:12:10 <edlinde> dr460neye: so which function is it? the first or the second?
14:12:24 <dino-> Are we migrating/migrated to something newer than mtl now?
14:12:30 <BONUS> mtl-2
14:12:34 <BONUS> or so it seems
14:12:47 <dino-> That coexists with monads-tf ?
14:12:50 <edlinde> dr460neye: simplify or simplify2?
14:12:57 <dr460neye> the first get a wrong result, the second an endless loop
14:13:13 <BONUS> dino-: not sure actually, im a bit confused wrt all these monad libraries
14:13:34 <dino-> BONUS: It seems to be in flux at this moment, yeah. But moving forward, which is cool.
14:13:38 <dr460neye> after this i tried that code> http://hpaste.org/41507/expression_reducer but there i got the problem that the _ aren't accepted.
14:14:45 <dr460neye> @Bonus what does the -> exactly do?
14:14:45 <lambdabot> Unknown command, try @list
14:15:09 <BONUS> it's a view pattern. it works like so
14:15:19 <sm> BONUS: you are not the only one
14:15:49 <BONUS> instead of blaah x = case f x of Foo -> something; Bar -> something_else
14:15:49 <dr460neye> hmm, ok , i didn't set the flag for ghci so i get some errors
14:15:51 <BONUS> you can write
14:16:08 <BONUS> blaah (f -> Foo) = something; blaah (f -> Bar) = something_else
14:16:53 <dr460neye> ok
14:20:01 <aristid> dino-: mtl-2 coexists with monads-fd, but not sure about monads-tf.
14:20:31 <aristid> but it's simple: everybody should use mtl-2
14:29:59 <oscar_boykin> this function is allocating 18% of the 4 GB in my program:
14:30:01 <oscar_boykin> ruFold base acc h k = base*acc + ((k - h) `mod` base)
14:30:13 <oscar_boykin> Is this due to it not being strict?
14:30:31 <oscar_boykin> Does it cause the accumulation of thunks?
14:31:10 <hpc> oscar_boykin: where is it being called? you probably have other functions calling it a lot and building many thunks
14:31:28 <oscar_boykin> It is called in a foldl' like situation:
14:31:46 <oscar_boykin> hpc, http://hpaste.org/41508
14:31:55 <kmc> well, foldl' will force the accumulator at every step
14:32:15 <sproingie> @src foldl'
14:32:15 <lambdabot> foldl' f a []     = a
14:32:15 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
14:32:19 <hpc> that definition of foldl2' isn't strict
14:32:24 <az_ordog_maga> aloha haskellers
14:32:25 <hpc> oh, nvm
14:32:35 <kmc> your foldl2' looks ok, though it might be written more clearly with BangPatterns
14:32:40 <dons> oscar_boykin: what is its  type?
14:33:07 <kmc> also you can worker-wrapper transform this for clarity
14:33:07 <oscar_boykin> dons: what is "its"
14:33:13 <dons> note that foldl' isn't strict in case 1.
14:33:20 <dons> ruFold_base
14:33:38 <kmc> foldl2' step = go where { go a [] _ = zero; ...; go !a (x:xs) (y:ys) = ... }
14:33:42 <kmc> this way you don't pass "step" everywhere
14:33:52 <oscar_boykin> ruFold base :: Int -> Int -> Int -> Int -> Int
14:34:46 <kmc> oscar_boykin, you could also use foldl' with zip, i think
14:35:02 <oscar_boykin> kmc, I was trying to avoid an intermediate list creation.
14:35:06 <kmc> :t \f z xs ys -> foldl' f z $ zip xs ys
14:35:07 <lambdabot> forall a a1 b. (a -> (a1, b) -> a) -> a -> [a1] -> [b] -> a
14:35:12 <kmc> oscar_boykin, ah, i think the list creation should fuse
14:35:31 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/rewrite-rules.html#id670639
14:36:00 <kmc> zip is a good producer, and foldr is a good consumer, but i don't know about foldl'
14:36:05 <oscar_boykin> kmc, I'll try that, but in the mean time I'm trying to get something to work.
14:36:12 <kmc> right
14:36:31 <kmc> to answer the question about the accumulation of thunks, you want a profile of heap size over time
14:36:33 <oscar_boykin> dons: when you say, foldl' isn't strict in case 1, are you speaking of the paste I put up?
14:36:40 <kmc> it may be that this function does lots of allocation, but nothing sticks around very long
14:37:13 <oscar_boykin> my concern is that when I run the program, I get about 2:1 sys:user time, which I think is strange.
14:37:23 <kmc> odd
14:37:28 <kmc> any guess where the sys time is going?
14:37:31 <kmc> you can profile system calls with strace
14:37:33 <oscar_boykin> A very small case runs for about 12 minutes.  very large cases will run for months and hundreds of computers.
14:37:45 <oscar_boykin> kmc, I guess malloc or something...
14:37:50 <BONUS> dons: since you're here, a question: is mtl-2 being in the next platform release a sure thing?
14:37:56 <oscar_boykin> it's purely computational code.
14:38:00 <kmc> oscar_boykin, malloc isn't directly a system call
14:38:15 <kmc> iirc GHC will allocate big chunks of memory from the OS, then manage them internally
14:38:29 <kmc> anyway i would try profiling system calls with strace or similar, assuming your OS has such a tool
14:38:48 <oscar_boykin> kmc, I'm on linux, so I can use strace
14:38:57 <dons> BONUS: yep
14:39:27 <BONUS> ah, alright. good thing i caught word of this now, gonna have to modify lyah a bit before it goes to print :)
14:39:27 <kmc> strace -c
14:39:29 <kmc> i believe
14:39:31 <dons> oscar_boykin: yeah, i'd write it as f !z ...  ; in both branches of the function.
14:39:33 <BONUS> to reflect the slight interface changes
14:39:35 <dons> yes
14:40:08 <int80_h> hiya
14:40:27 <oscar_boykin> dons: okay, I'll give that a try.  Thanks (unfortunately I have to run now someone just came to my office).  Thanks for the help dons and kmc
14:40:58 <kmc> ok oscar_boykin, good luck :)
14:44:23 <edlinde> dr460neye: still around?
14:44:35 <edlinde> dr460neye: managed to get somewhere with your fix?
14:44:50 <edlinde> dr460neye: have you got more test cases that fail? I might have a solution
14:44:52 <dino-> aristid: ok, thanks
14:45:01 <edlinde> dr460neye: ?
14:45:04 <dr460neye> so, i got no more test cases failing
14:46:17 <edlinde> hmm ok
14:46:18 <edlinde> one sec
14:46:22 <dr460neye> yes
14:46:24 <edlinde> lemme paste and you can test it
14:46:26 <dr460neye> i'm still around
14:47:08 <edlinde> dr460neye: http://hpaste.org/paste/41507/fix#p41519
14:47:27 <edlinde> dr460neye: give that a shot and lemme know how you go... though there are cases that it might fall over
14:47:36 <edlinde> dr460neye: will leave that to you :)
14:48:33 <dr460neye> this code also works
14:49:26 <edlinde> dr460neye: what do you mean "also works"? 
14:49:43 <edlinde> dr460neye: is there any other that was working too? :)
14:50:23 <dr460neye> the first "ugly" code from BONUS :)
14:50:36 <edlinde> did that one work?
14:50:41 <dr460neye> yes
14:50:44 <edlinde> I thought you said it went into some infinite loop?
14:50:48 <edlinde> or was that yours?
14:50:56 <dr460neye> my one was an infinite loop
14:51:10 <edlinde> ah well
15:12:54 <pkrumins> Does anyone know how to get the String of current user that is logged in the system in windows haskell?
15:13:19 <ddarius> Use the appropriate Windows API call.
15:13:31 <pkrumins> oh, okay!
15:13:34 <kmc> yeah, you should be able to translate a non-Haskell answer
15:13:47 * kmc does not use windows and cannot be of more help, sorry
15:14:19 <pkrumins> the api call clue should be enough
15:14:59 <ddarius> There's a win32 package that may already have it bound, but if it is not bound it should be easy enough to bind yourself.
15:15:13 <pkrumins> i am already using win32 package
15:15:18 <pkrumins> just looking up the right api now!
15:15:51 <pkrumins> GetUserName()
15:16:48 <pkrumins> unfortunately win32 package doesn't export this
15:17:06 <pkrumins> ddarius: how would I go about binding it myself?
15:19:28 <ddarius> @where ffi
15:19:29 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
15:20:59 <kmc> pkrumins, mayhaps there's a package providing it on hackage?
15:24:03 <pkrumins> kmc, unlikely, it's just a single api call.
15:24:19 * pkrumins naps
15:26:00 <c_wraith> I put a package on hackage for a single api call. >_>
15:26:31 <monochrom> what single api call and what does it do?
15:27:12 <monochrom> note: it's quite possible to do complex things by one single api call but it takes a very rich data structure.
15:27:30 <monochrom> (this is called object-oriented programming)
15:27:52 <c_wraith> monochrom, gnu's cryptr call.  (re-entrant version of crypt)
15:27:55 <hpc> haha
15:28:15 <c_wraith> it definitely qualifies as a single API call that does *far* too much.
15:28:27 <sipa> eg. the function callSomething :: FunPtr (a -> b) -> a -> IO b has rather unlimited possibilities ;)
15:28:27 <c_wraith> I considered re-implementing it, before I realized how much it actually does.
15:29:20 * hackagebot tga 0.1.0.1 - Reading and writing of tga image files  http://hackage.haskell.org/package/tga-0.1.0.1 (TillmannVogt)
15:54:08 <Fuco> @pf m f g h x = g (f x) (h x)
15:54:08 <lambdabot> Maybe you meant: bf pl
15:54:13 <Fuco> @pw m f g h x = g (f x) (h x)
15:54:13 <lambdabot> m = (ap .) . flip (.)
15:54:26 <int80_h> http://hpaste.org/41520/let_and_case
15:55:55 <hpc> pw?
15:56:05 <int80_h> huh?
15:57:42 <Fuco> pointwise pointfree translation
15:58:40 <hpc> @pl m f g h x = g (f x) (h x)
15:58:40 <lambdabot> m = (ap .) . flip (.)
15:58:50 <hpc> oh, silly
15:59:08 <brisbin> > map (\x -> read x :: Int) $ catMaybes [Nothing, Just "1", Nothing, Just "2"]
15:59:09 <lambdabot>   [1,2]
16:00:15 <int80_h> brisbin thanks!
16:00:32 <brisbin> int80_h: hope it helps :)
16:01:34 <int80_h> it did! I still need to figure out how to use let and case together but that's for another day.
16:02:53 <fryguybob> pkrumins: http://hpaste.org/41521/getusername
16:03:49 <int80_h> @hoogle catMaybes
16:03:49 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
16:03:59 <pkrumins> fryguybob: oh wow! thank you sir!
16:10:07 <dobblego> dcoutts, are you there?
16:10:31 <dobblego> FileManip is obsoleted by filemanip, but where is the find function in filemanip?
16:11:44 <dobblego> oh duh, sorry
16:22:23 <dons> http://www.reddit.com/r/programming/comments/e6o24/ghc_701_the_fastest_release_yet_of_the_optimising/ ghc 6 go go go
16:22:27 <dons> ghc 7 lives!
16:23:12 <kmc> proggit trolls go go go
16:23:28 <kmc> anyway, that kicks ass :)
16:23:43 <kmc> thank god for --make by default
16:23:50 <lispy1> woot, ghc7!
16:24:07 <c_wraith> I was nothing the haskell 2010 default
16:24:11 <c_wraith> err, *noting
16:24:11 <lispy1> Why is it not in my linux distro yet :)
16:24:14 <c_wraith> that'll break some stuff
16:24:43 <kmc> does the new type checker mean no more inconsistency between GeneralizedNewtypeDeriving and type families?
16:24:45 <orlandu63> wow, ghc 7 is out already?
16:24:50 <orlandu63> is it considered stable?
16:25:35 <jmcarthur> well, a lot of things have changed
16:26:05 <jmcarthur> i think releases are by definition supposed to have some sort of stability though
16:26:31 <c_wraith> it means they fixed the bugs people reported in the release candidates.
16:26:44 <c_wraith> If there are still bugs, people didn't test the RC thoroughly enough :)
16:27:51 <jmcarthur> "Rebinadble syntax now has its own extension, RebindableSyntax"  <-- awesome
16:28:02 <jmcarthur> typos aside :)
16:28:45 <kmc> if my cabal file has two executables which have mostly the same dependencies
16:28:49 <kmc> can i avoid listing those twice?
16:28:53 <ricree> I have a Data.Map whose values are strings.  I want to run it through something like Data.Map.map, except that the map function returns IO String and I want to wind up with an IO Data.Map at the end.  any idea what the best way to go about it would be?
16:29:15 <c_wraith> ricree, I think you want fmap
16:29:28 <kmc> ricree, what do you want to do? execute an IO action for each map element?
16:30:00 <ricree> kmc:  Basically, I want to do what mapM does, except for the Data.Map instead of a list
16:30:00 <c_wraith> Oh, I see, you do want IO.  um.  You can get that from Data.Foldable.Foldable, I think
16:30:34 <c_wraith> Err, I think I mean traversable
16:30:40 <c_wraith> I am bad at thinking today.  anyway.
16:30:46 <kmc> ricree, mapM f = sequence . map f
16:30:54 <kmc> so maybe you can use sequence with Data.Map.map
16:30:57 <kmc> or use Foldable or Traversable
16:31:07 <c_wraith> sequence won't work.  Traversable will
16:31:40 <kmc> oh because you want a map back
16:32:51 <c_wraith> ricree, just import mapM from Data.Traversable
16:33:34 <ricree> thank you, c_wraith
16:33:51 <ricree> and you too, kmc
16:34:02 <c_wraith> That module defines generalized functions for traversing a structure in place.  It's good to know about, for things that implement its interface
16:34:16 <c_wraith> And Data.Map does implement it
16:34:34 <jmcarthur> "The inliner has been overhauled. The most significant user-visible change is that only saturated functions are inlined."  <-- great, a subtle thing for me to be looking out for when using anything that relies on rewrite rules
16:34:42 <ricree> yeah, I figured something like that would exist, but I wasn't sure where to go looking for it
16:35:06 <c_wraith> ricree, a good place to start is the documentation of Data.Map, where it lists all the classes it implements.
16:35:31 <c_wraith> ricree, it's easy to overlook that section, because it's terse, but it contains a lot of good information
16:37:33 <dobblego> I just mistyped "Haksell" then realised this is what most Java programs are for, hack then sell
16:38:21 <pickles> same thing goes for social security #'s, doesn't it?
16:42:30 <monochrom> ESR's "cathedral and bazaar" article teaches you: release often, goof often, scam often.
16:44:09 <pickles> that latter would be in the bazaar section, right?
16:46:01 <Axman6> Anyone know if the LLVM backend is included by default? I got the impression that you'd need to compile GHC yourself to get it, and wasn't sure if that was still the case
16:49:44 <ricree> dunno.  Release notes say it's there
16:51:07 <jmcarthur> it should be there
16:57:57 <Eelis> i'm reading the release notes for GHC 7 and am disturbed by the new rule that makes "(.) f g x = f (g x)" have different inlining behavior than "(.) f g = \x -> f (g x)". all these years we teach people that one is just syntactic sugar for the other and that they're really the same in a nice abstract sense. and now we have to tell them "well, actually... if you want your program to be fast, you need to realize that they mean very different things"
16:58:05 <Eelis> this seems to me to be a "leaky abstraction" of the worst kind.
16:58:17 <Eelis> so what's up with this nonsense?
16:59:18 <kmc> lots of things are equivalent until you care about performance
16:59:32 <sproingie> i think when you start hand-tuning optimizations, you're drilling holes in your abstraction bucket
16:59:36 <kmc> the syntactic arity of a function has always mattered for codegen, iirc
17:00:07 <kmc> see http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode and all the discussion of saturated vs. undersaturated vs. oversaturated application
17:00:26 <Eelis> i see. well, i'm sorry to say that "it's always been crappy this way" isn't very reassuring :(
17:00:40 <sproingie> patches welcome
17:00:57 <kmc> similarly, rewrite rules are fragile and can fail to recognize semantically equivalent but syntactically different expressions
17:01:37 <Eelis> kmc: sure, but that doesn't constitute a leaky abstraction. with this arity thing it seems like a very basic equivalence is broken
17:01:45 <kmc> if i rewrite map myself it will not fuse the way that the Prelude map does
17:02:37 <pickles> if you rewrite a map would that make you a cartographer?
17:02:56 <kmc> similarly it matters how you divide things up into modules, for the purpose of whether they get inlined
17:03:08 <kmc> basically at this level of optimization there are tons of leaky abstractions
17:03:36 <kmc> and it's not a leaky abstraction, if the equivalence is about semantics and not performance
17:04:03 <ezyang> Clearly we need a performance calculus. 
17:04:20 <Eelis> it's 100% leaky abstraction when it concerns something that's we've taught people is "just syntax sugar"
17:04:36 <Eelis> s/that's/that/
17:05:05 <pickles> ezyang: doesnt O() etc take care of performs? wouldn't what we'd need be a way to link that to syntactic stuff?
17:05:08 <dobblego> Eelis, "all these years we teach people that one is just syntactic sugar for the other" <-- all these years I've been teaching that actually they are not the same, because they aren't
17:05:13 <pickles> *performance?
17:05:20 <Eelis> dobblego: good for you!
17:05:23 <ezyang> pickles: Ha ha ha asymptotics 
17:05:31 <pickles> mind you, i was an EE not a CS
17:05:56 <kmc> asymptotic complexity is so misleading that i almost wish it weren't in basic CS curriculum
17:07:03 <aavogt> dobblego: how are they different in a way that matters then?
17:07:38 <aavogt> performance changes much between different ghcs, so what can you teach that isn't obsolete in a year?
17:07:47 <dobblego> aavogt, a difference f x = e and f = \x -> e can be observed with strictness
17:08:19 <nus> "If you squint enough, some sugar is sweeter" (-;
17:08:51 <dolio> 'f x = e' and 'f = \x -> e' is also different due to the monomorphism restriction.
17:08:56 * nus feels dejavue
17:08:57 <Eelis> dobblego: how?
17:09:14 * hackagebot Lastik 0.7.0 - A library for compiling programs in a variety of languages  http://hackage.haskell.org/package/Lastik-0.7.0 (TonyMorris)
17:09:21 <aavogt> dolio: but that doesn't apply to Eelis's example
17:09:51 <Eelis> nor does dobblego's objection, does it?
17:10:29 <dolio> dobblego's does.
17:10:35 <dolio> Well, it could.
17:10:39 <Eelis> eh?
17:10:52 <aavogt> > let f x = undefined; g = \x -> undefined in (f `seq` (), g `seq` ())
17:10:53 <lambdabot>   ((),())
17:11:15 <aavogt> > let f x = undefined; g = \x -> undefined in (f undefined `seq` (), g undefined `seq` ())
17:11:16 <lambdabot>   (*Exception: Prelude.undefined
17:11:23 <aavogt> > let f x = undefined; g = \x -> undefined in (g undefined `seq` ())
17:11:24 <lambdabot>   *Exception: Prelude.undefined
17:11:29 <dolio> 'f x y | something = undefined | otherwise = \z -> ...' versus 'f x y z | something = undefined | otherwise = ...'
17:11:43 <Eelis> dolio: but that's completely different from my example.
17:11:55 <shachaf> dobblego: Why would they differ in strictness?
17:12:38 <dolio> It's certainly not completely different.
17:12:57 <aavogt> dolio: that's different from dobblego's example
17:13:28 <Eelis> dolio: my case was "(.) f g x = f (g x)" vs "(.) f g = \x -> f (g x)". and dolio objected to it on strictness grounds. so please demonstrate how they behave differently w.r.t. strictness.
17:13:39 <dolio> Unless you're complaining that someone taught you specifically that in the case of functions of multiple arguments with a single clause, you can shuffle arguments to the left and right as long as you don't move them all to one side or the other.
17:13:40 <aavogt> there you're substituting  undefined for (\ _ -> undefined)
17:13:42 <Eelis> s/dolio objected/dobblego objected/
17:13:43 <danharaj> Is there a type class for a functor that has a natural transformation (f a, f b) -> f (a,b)?
17:13:48 <dolio> But I don't know why anyone would have taught you that.
17:14:16 <jmcarthur> danharaj: Applicative
17:14:26 <jmcarthur> :t liftA2 (,)
17:14:27 <lambdabot> forall a b (f :: * -> *). (Applicative f) => f a -> f b -> f (a, b)
17:14:33 <jmcarthur> :t uncurry $ liftA2 (,)
17:14:34 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
17:14:35 <Eelis> dolio: you're changing the goal post.
17:14:46 <danharaj> is pure and liftA2 a complete definition of applicative?
17:14:55 <danharaj> (I mean at least morally speaking)
17:15:08 <aavogt> Eelis: but dolio didn't set it
17:15:14 <jmcarthur> danharaj: you must have fmap too i think
17:15:20 <danharaj> jmcarthur: right.
17:15:24 <jmcarthur> but yes
17:15:47 <jmcarthur> you can get (<*>) using liftA2 and fmap
17:15:53 <danharaj> ah, I'll try to define <*> as an exercise
17:15:53 <Eelis> aavogt: first he pretends to go along with what dobblego is saying, but then he changes the subject so that he doesn't have to concede being wrong.
17:15:56 <danharaj> thanks.
17:16:20 <aavogt> well there's really no point in saying "you're wrong" for it's own sake
17:16:43 <Eelis> i agree. so i didn't
17:16:55 <aavogt> but I'm interested in an example that shows a difference between    f x = e     and   f = \x -> e
17:17:01 <aavogt> in strictness
17:17:40 <dolio> You'd need multiple clauses.
17:17:56 <dolio> Where one of the clauses is undefined, and gets eta expanded/contracted by the conversion.
17:18:11 <danharaj> if eval :: (a -> b, a) -> b, then <*> f x = fmap eval (liftA2 f x)
17:18:33 <danharaj> (in pseudocode)
17:19:35 <aavogt> dolio: this is the case where you drop the  "\x ->" because the x is unused?
17:19:45 <jmcarthur> @djinn (a -> b, a) -> b
17:19:46 <lambdabot> f (a, b) = a b
17:20:00 <jmcarthur> :t uncurry ($)
17:20:01 <lambdabot> forall b b1. (b -> b1, b) -> b1
17:20:10 <danharaj> djinn is a boss at finding natural transformations.
17:20:28 <dolio> aavogt: Either that, or pull the x to the left.
17:20:50 <jmcarthur> :t (fmap.fmap.fmap) (uncurry ($)) liftA2
17:20:51 <lambdabot> forall b a b1 c. (Monoid b) => (a -> b1 -> c) -> (c -> b, a) -> (c -> b, b1) -> b
17:20:56 <jmcarthur> bleh
17:21:12 <dolio> f 0 = undefined ; f (n+1) = \x -> ... ; g 0 x = undefined ; g (n+1) x = ...
17:21:31 <jmcarthur> @pl \f x -> fmap (uncurry ($)) (liftA2 f x)
17:21:31 <lambdabot> (fmap (uncurry id) .) . liftA2
17:21:43 <Eelis> on a separate note, i think a good argument can be made that even these strictness considerations constitute a rather severe leak in the abstractions, causing minute and superficially meaningless definitional differences to have severe functional consequences, but that's a rant for another day ;)
17:21:48 <dolio> Anyhow, there's other things GHC won't do.
17:22:29 <aavogt> dobblego: is your "difference f x = e and f = \x -> e can be observed with strictness" the same as dolio's example?
17:22:43 <dolio> If you have 'f x y z = let w = expensive x in ...' it might be cheaper to instead do 'f x = let w = expensive x in \y z -> ...', but GHC won't do that translation.
17:22:57 <dolio> However, it probably will if you write 'f x = \y z -> let w = expensive x in ...'.
17:24:15 <aavogt> it seems a roundabout way to say that   (f undefined)  is less defined than   f
17:30:42 <Veinor> time to upgrade ghc, whoo
17:31:38 * jmcarthur waits impatientily for ghc 7 to hit the arch repos
17:32:19 <aavogt> jmcarthur: important packages aren't compatible though
17:32:55 <orlandu63> jmcarthur: same. i'm also waiting for freebsd to update to at least verison 6.12
17:34:31 <jmcarthur> aavogt: hence the "impatiently" ;)
17:36:43 <penelope> I'm curious if anyone knows an elegent way to do a counting unfold?
17:37:25 <jmcarthur> as in it counts the number of elements it generates as it goes?
17:37:34 <penelope> Exactly.
17:38:00 <dolio> Where does it put that information?
17:38:07 <jmcarthur> you need to this number in the function it's iterating?
17:38:13 <jmcarthur> *to use this
17:38:14 <shachaf> penelope: Why not just count it yourself?
17:38:26 * ezyang wonders if there's a monadic unfold 
17:38:28 <lispy1> is code.haskell.org down again?
17:38:29 <ezyang> @hoogle unfoldM 
17:38:29 <lambdabot> No results found
17:38:31 <penelope> Well, that would be easy, but a list traversal.
17:38:41 <lispy1> ezyang: I wrote one of those while you were here :)
17:38:46 <shachaf> Oh, I misunderstood.
17:38:57 <jmcarthur> i still don't understand
17:38:59 <lispy1> ezyang: let me see if I can find it.  One thing I found with monad unfold was that the strictness can be an issue
17:39:16 <penelope> sort of a the anamorphism of mapAccupL
17:39:55 <jmcarthur> ezyang: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Morphism-Ana.html#v:g_ana
17:39:57 <penelope> Not hard to write, just looking for a best practise...
17:40:00 <ezyang> classy. 
17:40:14 <jmcarthur> hmm
17:40:14 <lispy1> ezyang: http://hpaste.org/41522/unfoldm
17:40:18 <jmcarthur> that doesn't look like what i intended
17:40:38 <jmcarthur> ezyang: ignore that. it isn't what you asked for
17:41:13 <ezyang> Yeah, I was wondering about those types. 
17:42:48 <xxxxx> i need a algorithm to verify whether a girl is virgin. can one give me a hint how to design algorithm and prove its correctness ?
17:43:13 <lispy1> the version of unfoldM that I have there takes the extra 'action at each step' argument to avoid having to build the full thing before doing something with it
17:43:55 <penelope> Very nice!
17:44:26 <ezyang> Anyway, to answer the original question, you could probably stuff your unfold on top of a State Int or Writer (Sum Int) 
17:45:18 <trevor> Is the next release of the Haskell Platform (2011.x) planning to have ghc7?
17:45:25 <trevor> I couldn't tell from the wiki
17:45:52 <penelope> ghc7 should be out by then?
17:46:04 <jmcarthur> penelope: it's out now
17:46:12 <penelope> OMG!
17:46:14 <jmcarthur> today, in fact
17:46:30 <trevor> It is, but I noticed the platform has is locked or freezed for packes
17:46:34 <trevor> packages
17:47:06 <trevor> Didn't know if that meant ghc7 would be in it or not
17:47:24 <jmcarthur> i'm a little doubtful that it will have ghc7
17:48:29 <penelope> I wonder how long before it migrates to debian?
17:50:24 <lispy1> trevor: the next platform will probably have the next ghc7 release
17:50:42 <trevor> neat
17:50:48 <ezyang> whoo 
17:50:57 <orlandu63> http://www.reddit.com/r/programming/comments/e6o24/ghc_701_the_fastest_release_yet_of_the_optimising/c15q6zl
17:54:54 <lispy1> trevor: I don't want to sound too certain, things could change
17:55:03 <lispy1> But, what I said is my understanding
17:55:20 <kmc> it says 4 comments, i only see two
17:55:28 <lispy1>     Couldn't match type `t' with `b'
17:55:28 <lispy1>       because this skolem type variable would escape: `b'
17:55:37 <trevor> The link from orlandu63 seems to confirm what you are saying, lispy1 
17:55:40 <lispy1> Looks like ghc7 has new error messages
17:55:59 <ezyang> Mmm skolem variables 
17:55:59 <dons> http://i.imgur.com/japTZ.png 
17:56:01 <lispy1> Now I have to learn what skolem type variables are
17:56:02 <dons> good haskell day
17:56:25 <kmc> that and the website is back up
17:56:28 <kmc> albeit still with the old logo
17:56:57 <ezyang> dons: If I wanted to get a mop and help with the transition work, what should I do? 
17:57:56 <trevor> That old logo sure is ugly
17:58:19 <ezyang> new-www is soooo pretty 
17:58:20 <dons> ezyang: wait for now
17:58:35 <dons> i'll have a timetable tomorrow
17:58:41 <xxxxx> www.yahoo.com
17:58:44 <ezyang> dons: Ok. 
17:59:42 * hackagebot vty 4.6.0.1 - A simple terminal access library  http://hackage.haskell.org/package/vty-4.6.0.1 (CoreyOConnor)
18:00:35 <penelope> Hmm. The dph packages are gone...off to hackage?
18:03:33 <ManateeLazyCat> I'm looking for haskell job, you can find my skills at http://www.haskellers.com/user/AndyStewart/ , let me know some haskell company interested me, my mail is lazycat.manatee@gmail.com Thanks!
18:16:04 * monochrom re-programs the way xchat displays events. nick changes now look like " | xxx is now known as yyy"
18:16:24 <ezyang> hahaha 
18:16:37 * ezyang approves 
18:17:51 <osaunders> ManateeLazyCat: Is Haskell big in China
18:17:52 <osaunders> ?
18:18:10 <ManateeLazyCat> osaunders: No
18:19:00 <ManateeLazyCat> I haven't found any company use Haskell in China. 
18:19:07 <Quadrescence> monochrom: did you really just fucking use alpha
18:20:19 <osaunders> ManateeLazyCat: Are you looking for work in China?
18:20:52 <ManateeLazyCat> osaunders: Yes
18:21:40 <ManateeLazyCat> osaunders: I hope found a Haskell job to support my project.
18:21:56 <osaunders> I want to use Haskell in a startup.
18:21:56 <monochrom> @slap monochrom
18:21:56 <lambdabot> I don't perform such side effects on command!
18:22:07 <monochrom> @slap monochrom
18:22:07 * lambdabot loves monochrom, so no slapping
18:22:52 <ManateeLazyCat> osaunders: Real-World program?
18:22:54 <osaunders> ManateeLazyCat: Are you from China originally, your doesn't sound Chinese.
18:22:55 <dons> ManateeLazyCat: maybe send an email to haskell-cafe@ about haskell jobs in/from china?
18:22:55 <aavogt> @slap lambdabot
18:22:55 <lambdabot> I don't perform such side effects on command!
18:23:11 <osaunders> s/your/your name/
18:23:14 <dons> and link to the amazing code you've written :) haskell/gtk expert
18:23:21 <aavogt> psudonyms
18:23:26 <osaunders> ManateeLazyCat: Yeah, proably a web app.
18:23:27 <aavogt> pseudonyms too
18:24:11 <ManateeLazyCat> dons: I have build http://www.haskellers.com/user/AndyStewart/ , maybe i will send mail to haskell-cafe ...
18:24:35 <ManateeLazyCat> dons: It's really hard find a haskell job, but i don't want use any other language....
18:25:12 <dons> just make sure your skills stand out
18:26:24 <jekor> Saizan: I finally got that TH stuff working (type-safe queries). Thanks for the help last night.
18:26:59 <osaunders> Awesome win. Using chat logs I can verifiably say I started learning Haskell on 9th July 2009.
18:27:24 <unkanon> osaunders: which chatlogs did you use? I only know of ... (hold on)
18:27:33 <unkanon> osaunders: http://tunes.org/~nef/logs/haskell/
18:28:26 <osaunders> I used my personal IM chat logs.
18:28:41 <osaunders> Because I knew I told a friend about LYAH when I first discovered it.
18:29:15 <aavogt> osaunders: in what way is that useful?
18:29:31 <ManateeLazyCat> osaunders: Do you interested haskell browser develop?
18:29:40 <osaunders> The "Using Haskell Since" field on http://www.haskellers.com/profile/
18:29:51 <ManateeLazyCat> osaunders: I'm looking for haskeller join my browser team. :)
18:29:53 <ManateeLazyCat> @package
18:29:53 <lambdabot> http://hackage.haskell.org
18:29:56 <ManateeLazyCat> @package manatee
18:29:56 <lambdabot> http://hackage.haskell.org/package/manatee
18:30:00 <ManateeLazyCat> osaunders: ^^^^^^
18:31:50 <osaunders> ManateeLazyCat: Is this a Haskell IDE?
18:32:05 <ManateeLazyCat> osaunders: Haskell OS 
18:32:10 <osaunders> Oh wow
18:32:17 <ManateeLazyCat> osaunders: Aim is build everything in it.
18:32:29 <ManateeLazyCat> osaunders: http://goo.gl/MkVw
18:32:38 <osaunders> Yeah, I'm looking at the screenshots.
18:32:46 <monochrom> he says "haskell os" like how the emacs people say "emacs os"
18:32:57 <osaunders> Ah
18:33:00 <aavogt> heh, not sure it's helpful to say "started in early 2008", since the question will be "and that's it?"
18:33:09 <osaunders> ManateeLazyCat: So this is written on Linux and X?
18:33:19 <ManateeLazyCat> osaunders: On Linux and GTK+
18:33:38 <ManateeLazyCat> monochrom: But more powerful than emacs os. :)
18:33:50 <osaunders> aavogt: And what's it?
18:34:07 <aavogt> osaunders: that I don't know so much
18:34:40 <osaunders> aavogt: Did you mean people will be unimpressed by how little time I've been doing Haskell?
18:35:06 <osaunders> ManateeLazyCat: Is this profitable? Because I really need to be doing things that can make money.
18:35:26 <ManateeLazyCat> osaunders: No, i won't use it for money
18:35:27 <aavogt> oh no, they will be unimpressed if they compare what I know with when I started (march 2008 or so)
18:35:42 <ManateeLazyCat> osaunders: It's my dream project base on GPL3
18:35:50 <Sunhay> 
18:36:10 <ManateeLazyCat> osaunders: But i think it's good project to improve your haskell skill.
18:36:14 <osaunders> aavogt: Yeah, I don't know very much.
18:37:35 <osaunders> ManateeLazyCat: Will it run on Mac OS X?
18:37:48 <_xvinyl> wow, ghc 7 was released today
18:37:57 <ManateeLazyCat> osaunders: I design it for Linux.
18:38:06 <_xvinyl> did any of you try to build Platform with it ?
18:38:15 <ManateeLazyCat> osaunders: But i think it's not hard to make it work on MacOS since Mac is also Unix.
18:38:23 <osaunders> ManateeLazyCat: Hm, I don't really think it is for me. But good luck with it. It sounds cool. I'm really more interested in doing web development.
18:38:24 <ManateeLazyCat> osaunders: But i don't know, i haven't Mac.
18:38:41 <ManateeLazyCat> osaunders: Ok. :)
18:40:20 <osaunders> aavogt: How long do you need to do Haskell for to be good, do you think?
18:42:10 <osaunders> GHC 7 release notes: http://new-www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html
18:43:27 <ManateeLazyCat> Wow, GHC-7 release!
18:43:36 <ManateeLazyCat> Test GHC-7 with gtk2hs.....
18:45:40 <osaunders> Can someone change the topic to tell people about GHC 7.
18:46:47 <aavogt> osaunders: well I'm probably not representative since my formal studies involve minimal discrete math and programming
18:48:13 <xvinyl> aavogt: what do you study ?
18:48:24 <aavogt> chemical engineering
18:48:28 <xvinyl> aavogt: just curious, I don't want to be rude/inquisitive
18:48:35 <ezyang> Awesome. 
18:48:41 <xvinyl> aavogt: cool
18:48:42 <aavogt> maybe this is -blah if there's more
18:49:40 <xvinyl> aavogt: well i'm studying bioinformatics right now
18:50:03 <xvinyl> aavogt: sometimes we have slightly chemoinformatics-related problems
18:50:05 <xvinyl> :)
18:50:22 <osaunders> ezyang: Hello :-)
18:50:23 --- mode: ChanServ set +o monochrom
18:51:40 --- topic: set to '["GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
18:51:47 --- mode: monochrom set -o monochrom
18:53:01 <osaunders> monochrom: Nice one
18:53:40 <osaunders> Do you think there's any paid open source Haskell work out there I could do. 
18:53:52 <osaunders> That would be totally awesome.
18:54:05 <osaunders> I'd love to write a better Hackage. I know there's demand for that.
18:54:20 <osaunders> The Hackage website that is.
18:54:22 <aavogt> somebody did get paid for that
18:54:31 <osaunders> Really, who?
18:54:45 <aavogt> look at the gsoc
18:54:54 <osaunders> gsoc?
18:55:00 <aavogt> google summer of code
18:55:27 <aavogt> well I guess you don't get paid for that if they fail you
18:55:49 <aavogt> otherwise it's roughly minimum wage (if you put in the time they expect)
18:55:54 <osaunders> I'm not a student :-(
18:55:58 <osaunders> I think you have to be a student.
18:56:09 <osaunders> I'm basically a homeless bum.
18:56:14 <osaunders> Only I have a home.
18:56:32 <osaunders> OK, I'm not a bum.
18:57:14 <ezyang> osaunders: Hi! 
18:57:52 <osaunders> ezyang: Hello. I have a question: do you have any Haskell libraries/projects that you work on?
19:01:38 <ibt> osaunders: someone has already worked on a new hackage
19:01:51 <osaunders> ibt: Ah OK, good.
19:02:04 <osaunders> One less thing to worry about.
19:02:43 <ibt> osaunders: http://sparky.haskell.org:8080/
19:03:15 <sbahra> osaunders: #haskell-FreeBSD
19:03:22 <sbahra> osaunders: I'll pay you $100 to revive it
19:03:53 <osaunders> sbahra: The channel?
19:04:06 <osaunders> Oh the website
19:04:10 <sbahra> osaunders: the project!
19:04:29 <osaunders> Oh
19:04:52 <sbahra> osaunders: bunch of ports need updating and we need a better community that isn't so FreeBSD-centric (haskell@FreeBSD committers are the only gatekeepers)
19:05:08 <sbahra> osaunders: Granted, it's probably going to be very boring work. :-P
19:05:40 <osaunders> I don't understand. This is a project for FreeBSD support of Haskell?
19:05:55 <sbahra> Yes.
19:06:06 <int80_h> netBSD needs something similar
19:06:07 <sbahra> I think I've confused you with someone else.
19:06:22 <sbahra> I think I confused you with obraun.
19:06:25 <sbahra> haha
19:06:33 <pickles> owell?
19:07:03 <sbahra> osaunders: My offer still stands though.
19:07:13 <osaunders> What's involved?
19:07:33 <osaunders> Fixing bugs in all the GHC standard libraries for FreeBSD?
19:07:53 <int80_h> you could do that on a lunch break!
19:08:00 <sbahra> osaunders: I would start by talking to writer in the IRC channel or mezzy. 
19:08:28 <writer> sbahra: s/m/d/
19:08:40 <sbahra> osaunders: well, improving GHC support for FreeBSD (I think support is pretty solid at this point), providing FreeBSD ports for hackage (there is a cabal2port project, Haskell-based, which would appreciate improvements).
19:09:14 * osaunders isn't a FreeBSD user and knows nothing about FreeBSD
19:09:25 <osaunders> So I'm probably not the guy for this one.
19:09:32 <sbahra> Oh well, I guess that $100 will go to a stripper.
19:09:56 <osaunders> Yeah, I guess.
19:10:02 <alex404> If you're mapping a function over a vector, does doing it inplace with mutable state come out any faster than simply using the pure map?
19:10:11 <osaunders> I've learnt it is important to pick the right work.
19:10:26 <osaunders> Just working because there's money leads to very bad things.
19:12:01 <monochrom> such as compilers, linkers, and strippers.
19:13:12 <Veinor> strippers, you say
19:13:35 <erikc``> has anyone done the ghc porting process recently? it is up to date?
19:13:45 <sbahra> erikc``: for?
19:13:57 <sbahra> Hi copumpkin 
19:14:34 <erikc``> i'd wanna do ppc64/linux, maybe ppc64/aix
19:14:46 <ibt> alex404: i guess i would say.. it depends. is the data naturally stream like?
19:15:34 <monochrom> ppc64/linux and ppc64/aix are not done and need help
19:15:50 <alex404> ibt: Hmm... I would assume so, but how exactly do you mean?
19:16:36 <alex404> ibt: The vector is being mapped at the old vector should be able to be garbage collected right away
19:17:16 <unkanon> alex404: maybe he means the wasted cycles for allocating a new vector
19:17:38 <jaredj> what's that debugger thingy that shows thunks right before they get evaluated?
19:17:54 <blackdog> vacuum?
19:18:01 <alex404> unkanon: But that's a pretty minimal cost, right?
19:18:18 <alex404> unkanon: Assuming I'm not madly looping over it
19:18:21 <unkanon> alex404: it depends on the code around it.
19:18:23 <unkanon> right
19:18:37 <ibt> alex404: bench it with criterion
19:18:42 <unkanon> I read somewhere that the average allocation takes 57 instructions
19:18:46 <ibt> alex404: or hpaste more information
19:19:18 <alex404> Yah, I'll benchmark myself. I think the answer i was looking for was, "yes, I understand how this works"
19:19:32 <alex404> Which I think I do... if I want every little drop of performance, I have to tweak
19:20:00 <alex404> Is criterion much superior to ghc's profiler? I haven't tried it yet.
19:20:41 <djahandarie> criterion is specifically for microbenchmarks
19:21:00 <alex404> What's that?
19:21:28 <djahandarie> To bench a very small piece of code
19:21:39 <djahandarie> It doesn't profile your application
19:21:44 <unkanon> which is to say, the complete opposite of "real world benchmark"
19:21:47 <unkanon> :)
19:22:05 <unkanon> so it is only useful when comparing two versions of the same code
19:22:19 <alex404> I see... so in my case where I'm wondering about the cost of some infrequent allocation, criterion is what I'd want
19:22:30 <unkanon> yes
19:22:38 <alex404> Rather then figuring out what the difference in 0.01 seconds in the profiler is supposed to tell me
19:22:50 <djahandarie> If you can narrow it down to the single area where it is happening yet
19:22:51 <djahandarie> yes*
19:22:57 <alex404> Gotchya
19:22:59 <alex404> Cheers
19:24:16 <ibt> but, if you're doing a map on a list and a map on a vector and then you only use the first 10 elements.. 
19:26:28 <alex404> ?
19:27:12 <osaunders> Yay! "Data.Tuple exports a new function swap :: (a,b) -> (b,a)."
19:27:18 <Veinor> \o/
19:27:23 <Veinor> but what does it do?! :P
19:27:47 <kmc> that's a valid question
19:27:48 <kmc> it could be
19:27:52 <kmc> swap (a,b) = (b,a)
19:27:52 <kmc> or
19:27:57 <kmc> swap ~(a,b) = (b,a)
19:28:10 <kmc> the latter would be weird because swap   
19:28:13 <Veinor> presumably the former
19:28:24 <Veinor> I forget, what does ~ mean
19:28:27 <djahandarie> Yep, good times
19:28:29 <kmc> lazy pattern
19:28:50 <kmc> with ~(C x y) the value is not forced to expose the ctor C; it is just assumed and forced later if x and/or y is forced
19:28:56 <Veinor> ah
19:34:13 <aavogt> it's the latter
19:34:30 <aavogt> lazy swap :)
19:36:20 <aavogt> hmm, on second consideration it's not
19:37:15 <aavogt> > let swap2 ~(x,y) = (y,x); swap (x,y) = (y,x) in (swap2 undefined `seq` (), swap undefined `seq` ())
19:37:16 <lambdabot>   ((),*Exception: Prelude.undefined
19:46:55 <danderson> ?
20:06:39 <fruight> when i do "[ x^2 | x <- [1..], x<5 ]" in ghci, why doesnt it end the line?
20:07:31 <kmc> because somewhere in [1..] there might be another element less than 5
20:07:35 <kmc> obviously, not really
20:08:08 <fruight> if i do "[ x^2 | x <- [1..4] ]" it gives the expected output and returns to the prelude
20:08:25 <kmc> right, because you're iterating over a finite list
20:08:37 <kmc> > filter (<5) [1..]
20:08:41 <lambdabot>   mueval-core: Time limit exceeded
20:08:44 <kmc> > takeWhile (<5) [1..]
20:08:45 <lambdabot>   [1,2,3,4]
20:08:45 <copumpkin> fruight: it isn't smart enough (nor could it really be, in a general sense) to see that the list is ascending
20:09:56 <fruight> ok i didnt think about that, i'm new to haskell :P
20:09:59 <fruight> thx
20:10:05 <kmc> if you want to stop taking elements after the first one at which the condition fails, use takeWhile
20:12:27 <fruight> how would i use that in a list comprehension predicate? i tried "[ x^2 | x <- [1..], takeWhile (<5) ]" but that gives an error
20:12:50 <fruight> ok figured it out
20:13:10 <fruight> > [ x^2 | x <- takeWhile (<5) [1..] ]
20:13:11 <lambdabot>   [1,4,9,16]
20:13:14 <fruight> :)
20:13:16 <Veinor> :D
20:13:25 <Veinor> yeah, infinite lists not terminating when you expect is annoying
20:14:08 <fruight> why did nobody nobody tell me about haskell while i was still in highschool :P could have made math and physics a lot easier and more fun
20:14:27 <kmc> because haskell isn't useful for getting a job
20:14:50 <Veinor> sad, but true
20:14:53 <Veinor> it's fun as hell though!
20:15:02 <codemac_> are there any libraries for playing/decoding multiple types of audio in haskell?
20:15:07 <unkanon> I have a motivational question. should I keep at learning haskell even if I'm pretty sure I'll never grok CT?
20:15:13 <kmc> unkanon, absolutely
20:15:22 <kmc> category theory is there if you want it, but the connection is pretty oblique
20:15:29 <kmc> it's more that some people who like CT use Haskell as a language for talking about it
20:15:33 <Veinor> yeah
20:15:45 <unkanon> and I've really tried and I even understand things like functors, arrows, morphisms (with all the greek prefixes except hylo), etc
20:15:58 <Makoryu> unkanon: Man I've been bangin' away at Haskell for like two years now and I don't even really know what the fuck category theory is actually about
20:16:00 <kmc> and CT is a universal language of sorts, so you can use it to talk about Haskell as well
20:16:07 <unkanon> kmc: that statement is the only thing that makes me keep at it
20:16:19 <kmc> but i wouldn't say it's fundamental
20:16:30 <kmc> i mean you can write very interesting clever elegant programs in Haskell without knowing CT
20:16:37 <unkanon> so you'd say, for somebody like me, it's best to keep away from cayenne and coq and the agda etc, right?
20:16:39 <kmc> you can get shit done, make money, get laid etc without knowing CT
20:16:45 <kmc> unkanon, those don't have much to do with CT either
20:16:48 <Makoryu> unkanon: But going by what other people have said about Haskell and CT, I would say that you should learn Haskell first and then understand CT in terms of Haskell
20:17:05 <kmc> i find playing with coq and agda to be fun for the same reason playing with haskell was fun
20:17:08 <unkanon> Makoryu: and you have no problems using monads and such?
20:17:11 <kmc> just try it and if you don't like it, quit.  whatever.
20:17:17 <fruight> what does CT stand for?
20:17:25 <kmc> category theory
20:17:30 <Makoryu> unkanon: None whatsoever!
20:17:51 <unkanon> kmc: oh they don't have to do with CT? what are they then? type theory?
20:17:51 <kmc> it's a branch of mathematics -- or really, it's a standardized mathematical vocabulary which is applied to lots of different fields
20:18:03 <kmc> unkanon, yeah, type theory, denotational semantics, etc
20:18:07 <kmc> not that there are no connections to CT there
20:18:13 <kmc> but you can get pretty deep without using CT
20:19:09 <kmc> it is hard to find a field where category theory *doesn't* apply
20:19:14 <kmc> because it is so general
20:19:30 <kmc> that also means there's little you can say about all categories
20:20:09 <kmc> like i'm sure we can find plenty of categorical structure in Java
20:20:17 <unkanon> well i've pretty much decided (after much reading and some practice) that haskell is for me because I like all of its philosophy. but you guys discuss things like _|_ so effortlessly and I don't know if I can get that far
20:20:27 <kmc> there are lots of papers on formal semantics, type theory, etc. in Java
20:20:44 <kmc> shrug anyway
20:20:55 <kmc>  isn't that big a deal
20:20:59 <kmc> it just means "an undefined value"
20:21:03 <kmc> or "an expression which fails to evaluate"
20:21:09 <kmc> could be an infinite loop, or something like (error "urk")
20:21:20 <unkanon> I know what it means but I don't know how to reason about it like you did above
20:21:30 <kmc> unkanon, you might like Conal Elliott's blog
20:21:40 <kmc> he talks about a lot of this stuff in a very precise yet accessible way
20:21:53 <kmc> unkanon, well, i can try to explain the above reasoning (the bit about swap?)
20:22:29 <fruight> kmc: how can you type _|_
20:22:36 <unkanon> kmc: yes.
20:22:49 <kmc> fruight, http://mainisusuallyafunction.blogspot.com/2010/10/typing-mathematical-characters-in-x.html
20:22:53 <kmc> of course you could copy-paste it too
20:22:57 <roconnor> unkanon: if you are like me you won't understand any of the category theory in Haskell for 7 years.
20:23:11 <kmc> unkanon, so first let's get rid of special syntax
20:23:16 <kmc> data Pair a b = MkPair a b
20:23:21 <kmc> swap1 (Pair x y) = Pair y x
20:23:25 <fruight> kmc: thanks
20:23:25 <kmc> swap2 ~(Pair x y) = Pair y x
20:23:31 <kmc> makes sense?
20:23:31 <unkanon> roconnor: do you understand it now afte 7 years?
20:23:41 <unkanon> kmc: perfect sense
20:23:46 <roconnor> I understand a very little about it.
20:23:58 <kmc> now, if we force the value of (swap1 p)
20:24:03 <kmc> it has to match against the pattern (Pair x y)
20:24:04 <byorgey> unkanon: not understanding things that get talked about on this channel is perfectly normal.  you'll just keep learning things bit by bit, but there's always more to learn =)
20:24:16 <kmc> which means evaluating the expression p until it produces its outermost constructor
20:24:26 <kmc> (that's called "evaluating to weak head-normal form" or "evaluating to WHNF")
20:24:51 <unkanon> roconnor: that motivates me, thanks :)
20:24:54 <kmc> and any expression which forces  to WHNF will itself be 
20:24:54 <ManateeLazyCat>  oShow to build ghc-7 with llvm backend?
20:25:09 <ManateeLazyCat>  So how to build ghc-7 with llvm backend?
20:25:34 <kmc> so: swap1  = 
20:25:54 <kmc> now, if we force the value of (swap2 p)
20:25:59 <kmc> it matches against ~(Pair x y)
20:26:07 <kmc> and the rule with ~ is that the match succeeds immediately, with no evaluation
20:26:19 <kmc> and that, later, if x or y is forced, it will have to go back and force the Pair constructor
20:26:27 <kmc> so: swap2  = Pair  
20:26:33 <kmc> because if we force x or y, the  arg gets forced
20:26:36 <unkanon> so it's passing on the bottom but not evaluating it.
20:26:39 <kmc> yeah
20:26:47 <unkanon> much like normal functions do in haskell
20:26:55 <kmc> i mean, they're both normal functions in Haskell
20:26:57 <kmc> here's a translation for swap2:
20:27:04 <kmc> swap2 p = let Pair x y = p in Pair y x
20:27:10 <kmc> or:
20:27:14 <kmc> swap2 p = (snd p, fst p)
20:27:19 <unkanon> and swap1 has to use seq?
20:27:30 <kmc> both of those have the same kind of laziness, and don't need ~
20:28:01 <unkanon> oh, I thought what made them different was the fact you had ~ on swap2 ?
20:28:28 <kmc> yeah, but i'm explaining how you can get the same effect without ~
20:28:35 <kmc> by using "let", which does lazy pattern-matching
20:28:36 <unkanon> byorgey: yes, and I always try to catch up to the conversations here, but they get pretty high level and the chat scrolls fast :)
20:28:44 <kmc> or by using fst and snd, which would extract components lazily
20:29:07 <kmc> swap2 p = let Pair x y = p in Pair y x
20:29:14 <kmc> swap1 p = case p of (Pair x y) -> Pair y x
20:29:26 <kmc> let is lazy, case is strict
20:29:59 <unkanon> kmc: is that why the source for fix uses let instead of the more straighforward way? so that it retains laziness?
20:29:59 <kmc> (i should say "non-strict" rather than "lazy", because "lazy" is an operational property of *implementations* of non-strict semantics.  but eh.)
20:30:09 <kmc> unkanon, no, i think that's for memory efficiency
20:30:14 <kmc> fix1 f = f (fix1 f)
20:30:21 <kmc> fix2 f = let x = f x in x
20:30:40 <kmc> consider: length . take 10000 $ fix (1:)
20:30:54 <kmc> i think fix1 will potentially expand it to a 10000-element list in memory
20:30:56 <kmc> (ignoring list fusion)
20:31:18 <unkanon> kmc: hmm, i'm learning haskell by using some 3 books and none of them has yet told me that let is lazy, case is strict. I wonder how you learn that stuff :)
20:31:28 <Cale> Exactly. With fix2, you get a single x in memory which is defined once and for all, and with fix1, you get an arbitrarily large datastructure, since GHC doesn't do such hardcore CSE.
20:31:43 <kmc> but fix2 will cause length to go round and round a single circularly-linked cons cell
20:31:53 <kmc> counting how many times it goes around
20:31:59 <unkanon> Cale: CSE = ?
20:32:00 <kmc> rather than counting and discarding new cells
20:32:04 <kmc> common subexpression elimination
20:32:16 <Cale> kmc beat me to it :)
20:32:18 <kmc> ;)
20:32:36 <unkanon> wow I didn't even know that that kind of optimization existed
20:33:13 <kmc> unkanon, i don't know where i learned that let does lazy pattern matching
20:33:16 <kmc> maybe the Gentle Introduction?
20:33:21 <kmc> it's in the Report itself, of course
20:33:22 <Cale> unkanon: Operationally, I think of let as having control over the heap (defining things in it), and case as driving forward evaluation and controlling the stack (which consists of case expressions whose scrutinee isn't evaluated enough to pattern match)
20:33:34 <kmc> yeah
20:33:44 <unkanon> kmc: ok, i've been exploring those pages as well
20:33:51 <kmc> in an intermediate language like Core, let is *the* allocation / thunk-making construct, and case is *the* evaluation construct
20:34:05 <Cale> You can learn this stuff in a fair amount of detail by reading the STG machine paper.
20:34:07 <kmc> yep
20:34:21 <kmc> you can learn a lot about sausages by visiting a sausage factory
20:34:22 <Cale> (which is not quite accurate as a reflection of GHC anymore, but it's close enough)
20:34:29 <unkanon> Cale: most of the papers people recommend me go way above my head :D
20:34:49 <kmc> i read the STG machine paper pretty early on in learning Haskell (6 months or so) but didn't really get it until a re-read years later
20:34:56 <kmc> it did help me think a lot more about operational semantics and performance
20:34:57 <djahandarie> There is no better way to swim than to drown
20:35:04 <Pseudonym> Strangely enough, though, you don't learn much about how legislation is made by visiting a legislature, thus not everything is Bismarck-compliant.
20:35:09 <kmc> there's also the "How to make a fast curry" paper
20:35:16 <Cale> Yeah, mostly you can get by ignoring the parts you don't understand though. Most papers have a section for beginners, and then get successively more detailed.
20:35:17 <kmc> and http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/GeneratedCode
20:35:26 <kmc> i'd recommend reading all three of those, in order
20:35:33 <kmc> and then trying to write a Haskell compiler :D
20:35:35 <Cale> (Though the STG machine paper is definitely aimed at language implementors)
20:36:02 <unkanon> I will give the stg paper a read
20:36:30 * hackagebot lambda-bridge 0.1 - A bridge from Haskell (on a CPU) to VHDL on a FPGA.  http://hackage.haskell.org/package/lambda-bridge-0.1 (AndyGill)
20:36:43 <unkanon> Cale: that's how i've been reading them, ignoring the parts I don't understand
20:37:04 <Cale> www.ncc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
20:37:18 <unkanon> kmc: the order being stg, how to make a fast curry, and generatecode ?
20:37:21 <kmc> yeah
20:37:22 <kmc> brb
20:37:27 <unkanon> I will. ok
20:38:02 <unkanon> Cale: I love reading about language implementation
20:38:17 <danharaj_> I like reading about Haskell's implementations
20:38:20 <danharaj_> not so much other languages
20:38:45 <unkanon> danharaj_: what's your opinion on haskell's implementation?
20:38:59 <Cale> unkanon: Actually, the level of detail in the STG machine paper is one level deeper than I usually think at when trying to understand the performance of Haskell code, so it's a bit lower-level than I think most people would really need while programming in Haskell.
20:39:13 <Pseudonym> danharaj_: The ML book was pretty good.
20:39:14 <Cale> But I don't know of a really *great* reference for the level at which I think.
20:39:47 <unkanon> Cale: I'll keep that in mind. by the way, I keep seeing references to a "Caleskell" language, is that related to you?
20:39:59 <unkanon> is that the language lambdabot speaks and you coded lambdabot?
20:40:02 <unkanon> is that it?
20:40:04 <Cale> That's what some people call my extra definitions in lambdabot
20:40:18 <Cale> I don't really understand why they call it that, since it's just Haskell. :P
20:40:28 <Cale> (with a few extra functions)
20:40:42 <unkanon> but the extra functions are written in haskell, right?
20:40:50 <Cale> yes
20:40:58 <ManateeLazyCat> Cale: Can you bring lambdabot to ##manatee? Thanks! :)
20:41:01 <Cale> I didn't write lambdabot
20:41:02 <unkanon> then they're just paying tribute to you :)
20:41:04 <Cale> I just run it.
20:41:07 <Pseudonym> @join ##manatee
20:41:20 <Cale> ManateeLazyCat: Should it be permanent?
20:41:24 <ManateeLazyCat> Cool
20:41:35 <ManateeLazyCat> Cale: Yes.
20:42:00 <Cale> okay
20:42:06 <ManateeLazyCat> Cale: Thanks. :)
20:44:09 <Cale> unkanon: Anyway, the level at which I usually think is in terms of either expression reduction -- where you picture evaluation as simply turning expressions into other expressions, or, a little more realistically, graph reduction, where expressions aren't just trees anymore, but graphs (which is basically what they are in memory in the real implementations -- graph structures built from pointers)
20:44:31 * Cale should bring his webserver machine back up...
20:44:46 <unkanon> Cale: are they graphs like ASTs?
20:44:57 <Cale> Yeah
20:44:59 <A1kmm> Does anyone Lennart Augustsson is still maintaining the typehash package?
20:45:12 <Cale> unkanon: ASTs possibly with cycles in them
20:45:22 <Cale> unkanon: and they're rooted of course.
20:45:37 <monochrom> Bird's book includes expression reduction.
20:45:44 <A1kmm> The last release in Oct 2009 names him as maintainer, but since then, there haven't been any releases, even though it still depends on base < 4
20:46:06 <monochrom> For example it can explain why foldl is so expensive.
20:46:10 <aavogt> send patches, then complain that they are ignored
20:47:01 <unkanon> monochrom: I thought it was expensive just because it builds thunks
20:47:04 <A1kmm> Okay... I'll see if he replies to my patch for base < 4.4 if I can find an address.
20:47:37 <monochrom> yes, it is expensive just because it build thunks. but the book shows you the thunks.
20:47:53 <JoeyA> In GHC's foldr/build implementation, what tells it to add builds so it can apply the rule?
20:48:01 <monochrom> and to a large extent there is no distinction between "thunk" and "expression"
20:48:29 <monochrom> for the most part, "thunk" is more machine-readable and "expression" is more user-friendly, that's all.
20:49:22 <unkanon> I see..
20:49:37 <unkanon> monochrom: so you recommend this book? "Introduction to Functional Programming using Haskell (2nd Edition)"
20:49:48 <unkanon> that's the Bird's book you referenced?
20:50:09 <monochrom> yes absolutely. this book was written 10 years ago and today it is still 10 years ahead of today.
20:50:43 <monochrom> observe how most other books don't dare to discuss foldl vs foldl'
20:51:35 <JoeyA> meh, who needs to know that stuff.  Just add 's to your program in random places until it works.
20:51:42 <lars9> where is the details about this syntax: newtype Reader e a = Reader { runReader :: (e -> a) } ?
20:51:48 <unkanon> does it get more advanced than that? I already know foldl vs foldl'
20:51:53 <monochrom> yes
20:52:00 <A1kmm> Does anyone have a current e-mail for Lennart Augustsson for patches? I presume augustss@se.chalmers.cs is no longer up to date.
20:52:06 <lars9> is it  "multi-parameter type classes and funDeps"?
20:52:31 <JoeyA> No, it's record syntax
20:52:40 <JoeyA> http://bloggablea.wordpress.com/2007/04/24/haskell-records-considered-grungy/
20:52:55 <JoeyA> That might help introduce them.
20:53:15 <A1kmm> I'm going to try lennart@augustsson.net and hopefully he checks that.
20:53:16 <JoeyA> Note that records are not "considered harmful", it's just that people wish the syntax was nicer.
20:54:15 <unkanon> monochrom: ok I'll get the book, just got paid :)
20:55:30 <JoeyA> It'd be nice if there was a syntax where, if you have data Foo = Foo {a :: Int}, saying a.foo would "subscript" a value which has the member foo, and (.foo) would be the name of the function that does that.
20:56:12 <JoeyA> That would put the record selectors in their own namespace.
20:56:16 <unkanon> Cale, kmc : thanks for the motivational boost, guys :0
20:56:20 <unkanon> :)
20:56:56 <Rotaerk> don't really have a problem with record syntax
20:57:04 <Rotaerk> namespace pollution is bollocks; just put them into modules
20:57:08 <JoeyA> To resolve the issue of conflicting namespaces, selectors could each get their own implicit type class.
20:57:38 <JoeyA> The syntax I suggested would conflict with the composition (.) operator.
20:58:00 <Rotaerk> F# has member access syntax but that's inferior imo
20:58:08 <JoeyA> Why so?
20:58:17 <Rotaerk> x.Foo doesn't place as strong a type constraint as foo x
20:58:25 <Rotaerk> also foo is more easily composed
20:58:41 <JoeyA> (\x -> x.Foo) compose that!
20:59:00 <Rotaerk> more *easily* :P
20:59:04 <Cale> unkanon: The least exciting webcomic ever: http://cale.yi.org/share/fib.png
20:59:25 <JoeyA> Or, as I proposed, .foo would be the name of the foo member.  Sort of like tags in Ruby, a language I have yet to learn.
20:59:37 <Rotaerk> in the case of "foo x", you're using a specific foo, thus the type signature of x is clear
20:59:38 <JoeyA> (except based on type classes, not strings)
20:59:56 <Rotaerk> whereas with x.Foo, that only says "x is of a some type with a member called Foo"
21:00:04 <unkanon> Cale: do you have a program that generates that? that's pretty awesome, I'll spent some time looking at it
21:00:29 <Cale> http://cale.yi.org/share/fibs.png
21:00:31 <JoeyA> Cale: Functional porn?  Sorry.
21:00:40 <Cale> No, I just drew them in inkscape.
21:01:04 <unkanon> Cale: by hand? you should write a book
21:01:08 <copumpkin> Cale: you need some text accompanying those! but I love it
21:01:18 <JoeyA> Those are cool drawings, though.
21:01:25 <copumpkin> Cale: also, if you're bored, you should move to boston and join the huge haskell community we're getting over here
21:01:33 <unkanon> Cale: there are some videos on youtube showing a software that draws similar pictures
21:01:42 <Cale> copumpkin: It would make sense, since I'm working for iPwn
21:01:50 <copumpkin> Cale: DO IT!
21:01:57 <djahandarie> DOOOO EEEET
21:03:07 <JoeyA> '<Rotaerk> whereas with x.Foo, that only says "x is of a some type with a member called Foo"' but that type could have a concrete (albeit polymorphic) type signature:  HasFoo a => a
21:03:21 <monochrom> Cale never writes a book. Prefers explaining in IRC again and again.
21:03:33 <JoeyA> s/concrete/clear
21:03:55 <Cale> monochrom: Explaining again and again is the only way to make sure that your book will be good when it finally gets written.
21:04:02 <unkanon> :)
21:04:04 <JoeyA> How can I get college credit for being on IRC?
21:04:05 <copumpkin> Cale: so how many magnets do you have? I was showing edwardk them today
21:04:09 <Cale> 2160
21:04:13 <Rotaerk> JoeyA, thing is, typeclasses tend to imply certain semantics; but "having a member called Foo" could mean many many things
21:04:15 <copumpkin> wow
21:04:29 <Cale> (plus a few spares in case any get damaged)
21:04:31 <unkanon> bed time for me guys. thanks again
21:04:39 <djahandarie> What are these magnets for?
21:04:40 <monochrom> Future generations will place Cale among the rank of Confuscius and Lao Tze etc. They never wrote a single piece of paper, but each of them has like 4 books attached to them as collections of all their sayings.
21:04:42 <copumpkin> so you take pics and then take them apart again?
21:04:51 <Cale> copumpkin: right
21:04:56 <monochrom> And perhaps I mean Confucius.
21:05:13 <copumpkin> confusedious
21:05:26 <djahandarie> As monochrome said, Kale was in the ranks of Tao Say and Confuscius.
21:05:55 <JoeyA> Rotaerk: So a HasFoo typeclass would be equivalent to "having a member called Foo", but you're saying it wouldn't be a meaningful use of type classes because it doesn't specify any kind of useful structure?
21:05:56 <Cale> copumpkin: Lately, I've been making lots of things out of 2-layer hexagon units which are then folded. I try to recover as many 2-layer hexagons from the structures as I can when I take them apart, so that I can make the next thing easily.
21:06:36 <Rotaerk> JoeyA, yes; just because you have a member called Foo doesn't mean that that Foo is intended for the same use
21:07:21 <Rotaerk> JoeyA, that effectively introduces (static) duck typing
21:07:29 <Rotaerk> well... structural typing, as it's called
21:07:40 <Rotaerk> which isn't particularly useful imo
21:08:20 <JoeyA> Let's see, "if a type walks like a duck and talks like a duck, then that type is a duck".  Duck kinds?  :D
21:08:21 <Cale> http://www.flickr.com/photos/cgibbard/5172982891/in/pool-magnetspheres/#/photos/cgibbard/5172982891/in/pool-1553182@N22/lightbox/ -- for example (though here I'm making parts to be put together rather than the reverse, which is messier, I usually lose some)
21:08:37 <Rotaerk> >_<
21:08:41 <JoeyA> Or maybe duck classes.
21:08:43 <djahandarie> Wow Cale
21:08:48 <copumpkin> very neat
21:09:08 <djahandarie> Jesus christ
21:09:14 <lars9> Lao Tze did write his own book...
21:09:15 <djahandarie> This are the coolest pictures I've ever seen
21:09:22 <monochrom> oh oops
21:09:37 <monochrom> Chairman Mao then! hahaha...
21:09:41 <guest2425> Hi what are curry functions?
21:09:43 <djahandarie> They are so cool they have rendered me incapable of talking
21:10:02 <Cale> Oh, that's in the magnetspheres pool
21:10:13 <Cale> So, there will be other people's stuff mixed in there
21:10:16 <JoeyA> guest2425: (+) 3 4 is the same as ((+) 3) 4
21:10:18 <lars9> wow, a guest from 2425...
21:10:21 <JoeyA> > ((+) 3) 4
21:10:22 <lambdabot>   7
21:10:25 <Cale> http://www.flickr.com/photos/cgibbard/5171580754/in/photostream/#/photos/cgibbard/5171580754/in/photostream/lightbox/ -- here's a link into the middle of my photostream
21:10:42 <guest2425> oh ok
21:10:46 <guest2425> thank you
21:10:59 <djahandarie> Yeah this is what I've been looking at
21:11:03 <JoeyA> It also means that (\x y -> x+y) is the same as (\x -> \y -> x+y)
21:11:06 <djahandarie> The one with the diagram is particularly cool
21:11:21 <djahandarie> fold, pinch, x5, etc
21:11:21 <Cale> http://www.flickr.com/photos/cgibbard/5171580754/in/photostream/#/photos/cgibbard/5168792854/in/photostream/lightbox/ -- this one gives some idea for how I'm exploring the space of constructions
21:11:26 <Cale> yeah
21:11:36 <JoeyA> Or, in JavaScript, function f(x) {function g(y) {return x+y;}}
21:11:41 <JoeyA> f(3)(4) is 7.
21:12:02 <monochrom> you forgot one return
21:12:03 <lars9> Cale: did you see the videos about self assembling robots?
21:12:24 <Cale> lars9: I don't think I did
21:12:32 <lars9> Cale: it will be cool if you combine those cubes and robots
21:12:58 <applicative> lars9, does one assemble the next, or do bits of metal start moving into robot shape?
21:13:13 <djahandarie> Cale, how long does this stuff take...? It looks... really complicated
21:13:16 <lars9> applicative: yep
21:13:31 <guest2425> I need to do this but I dont have any idea how to start I know how the function map works http://pastebin.com/9XdpHa09 
21:13:31 <lars9> Cale applicative : http://www.youtube.com/watch?v=uIn-sMq8-Ls   http://www.youtube.com/watch?v=SkvpEfAPXn4
21:13:34 <monochrom> monad transformers are self-assembling functors
21:13:39 <Cale> djahandarie: Usually about 30 minutes to an hour to put together something which uses all my magnets.
21:13:55 <JoeyA> monochrom: oops
21:14:15 <guest2425> Cale : I need to do this but I dont have any idea how to start I know how the function map works http://pastebin.com/9XdpHa09 
21:14:31 <JoeyA> function f(x) {return function g(y) {return x+y;}}
21:14:37 <JoeyA> f(3)(4) = 7
21:15:07 <Cale> guest2425: Okay, so there are two cases
21:15:12 <guest2425> ok
21:15:16 <Cale> mapMyList f Empty = ...
21:15:23 <Cale> mapMyList f (x :-: xs) = ...
21:15:25 <guest2425> Cale : ok
21:15:35 <guest2425> Cale: got it
21:15:42 <Cale> mapMyList's job is to apply the function f to each of the elements of the list
21:15:55 <guest2425> Cale: ok like the map
21:15:59 <guest2425> function
21:16:14 <Cale> So it doesn't have anything much to do in the case of Empty, it just produces another Empty list
21:16:19 <applicative> lars9, I think certain slime molds do something like this, this re-assembly
21:16:23 <Cale> So mapMyList f Empty = Empty
21:16:28 <guest2425> ok
21:16:43 <Cale> In the case of a nonempty list whose first element is x and where the rest of the list is xs
21:16:52 <unkanon> applicative: sea sponges reassemble (whatever their real name is)
21:16:54 <unkanon> anemones?
21:16:57 <Cale> The resulting list's first element will be f x
21:16:57 <lars9> applicative: those robots are controled by their own minds
21:17:09 <Cale> and the rest of the list will be constructed by applying f to all the elements of xs
21:17:18 <guest2425> Cale: and then f  to xs
21:17:23 <Cale> (which we can do by using this very function)
21:17:32 <Cale> f can't be applied *directly* to xs
21:17:42 <Cale> But mapMyList f can
21:17:49 <Cale> yeah?
21:18:03 <guest2425> ok 
21:18:12 <Cale> So  mapMyList f (x :-: xs) = f x :-: mapMyList f xs
21:18:23 <shepheb> yes, sea sponges do reassemble after being sieved. you can even mix several together, and they'll separate and reassemble. slime molds make that look like a quaint palour trick, though.
21:18:24 <lars9> applicative: they can configure their internal magnets to change shape, move etc
21:19:01 <applicative> they do seem charming.
21:19:48 <monochrom> I want my self assembling haskell programs.  <--- deliberately ambiguous!
21:20:15 <guest2425> Cale: but the type is different http://pastebin.com/arufY6TN
21:21:27 * Rotaerk reaches into the photo and moves Cale's pieces around.
21:21:30 <Rotaerk> mwahaha
21:21:59 <Cale> guest2425: you're defining f
21:22:05 <Cale> guest2425: (why?)
21:22:10 <guest2425> oh no
21:22:11 <guest2425> sorry
21:22:13 <guest2425> my bad
21:22:55 <Cale> Who is teaching your course, btw?
21:23:21 <guest2425> Cale: why?
21:23:34 <Cale> I'm just curious.
21:23:46 <Cale> There's some points where the style is weird.
21:23:52 <guest2425> I ok
21:23:59 <guest2425> Cale: where do you live?
21:24:05 <Cale> Brantford, Ontario
21:24:09 <Cale> (Canada)
21:24:18 <guest2425> Cale: oh ok
21:24:21 <copumpkin> soon to be Boston!
21:24:22 <copumpkin> ;)
21:24:27 <Cale> copumpkin: haha
21:24:27 * copumpkin quits bugging Cale
21:24:41 <copumpkin> Cale: I linked to the prof's page yesterday
21:24:44 <copumpkin> let me dig it up
21:24:57 <djahandarie> lol really
21:25:13 <djahandarie> Someone should start a conversation with him
21:25:23 <copumpkin> http://abbott.calstatela.edu/ I think
21:25:32 <guest2425> Cale: I got do the same thing for foldr but that I will do it my self 
21:25:50 <guest2425> Cale: if get stuck I will ask questions
21:25:52 <kmc> unexpected hazards of teaching: IRC channel challenges you to a rap battle
21:26:18 <djahandarie> Nothing like a good rap battle
21:26:50 <monochrom> https://sites.google.com/site/russabbott/ and http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010
21:27:41 <guest2425> Cale: Here is my professor http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010
21:28:00 <guest2425> monochrom: are you in the same class
21:28:03 <guest2425> ??
21:28:07 <djahandarie> Haha
21:28:24 <monochrom> The textbook is particularly noteworthy!
21:28:30 <djahandarie> We're all in your class
21:28:38 <djahandarie> All 635 of us
21:28:39 * kmc was sure Calstatela was some kind of exotic region of Spain before parsing it correctly
21:29:27 <copumpkin> lol
21:29:30 <lars9> is there any connection between Calstatela and Cale?
21:29:42 <copumpkin> yeah, Cale is The Professor of Calstatela
21:30:03 <kmc> inquiring minds want to know: is there any connection between Cale and kale?
21:30:40 <monochrom> now we know why BONUS wrote the book. it is meant to be the textbook for Cale
21:30:50 <guest2425> opumpkin: cale lives in canada not Los Angeles
21:31:00 <guest2425> copumpkin: cale lives in canada not Los Angeles
21:31:06 <copumpkin> guest2425: yes, I was kidding :)
21:31:11 * applicative liked opumkin ok
21:31:23 <djahandarie> Wrong!
21:31:27 <kmc> O'Pumpkin?
21:31:29 <monochrom> o'pumpkin
21:31:35 <opumpkin> that's my irish cousin
21:31:47 <kmc> where's Pumpkin Lite
21:31:50 <djahandarie> He's pretty objective
21:31:54 <monochrom> hahahaha
21:32:45 <monochrom> opumpkin is an object-oriented dependent typed type-level programming language
21:32:55 <opumpkin> lol
21:33:01 <opumpkin> yeah, dependent types with subtyping!
21:33:14 <kmc> woot
21:33:24 <monochrom> it does model-view-control at the type level
21:33:49 <kmc> "kale is considered to be anti-inflammatory"
21:33:52 <monochrom> and SAX at the kind level
21:34:22 <djahandarie> Oh god, XML in my kinds?
21:34:26 <djahandarie> I'm going to have nightmares now
21:35:29 <guest2425> Cale: Why I am getting this error messages http://pastebin.com/ePZKVpma
21:37:40 <Cale> guest2425: Because foldrMyList is supposed to produce a value of type t according to the type signature, but you have it producing a list of values of type t
21:38:14 <Cale> guest2425: and so in order for the program to typecheck, the type of lists of values of type t would have to be the same type as t itself, which we don't allow.
21:39:03 <guest2425> Cale: Haskell don't allow it
21:39:05 <guest2425> ?
21:39:31 <Cale> guest2425: If t = List t, then t = List (List t) = List (List (List t)) = List (List (List (List ...)))
21:39:36 <Cale> and so on
21:39:49 <guest2425> omg
21:39:51 <Cale> guest2425: Usually you don't want that.
21:39:58 <guest2425> ok
21:39:58 <Cale> So the compiler rejects it.
21:40:20 <guest2425> Cale: so what i have is wrong?
21:40:23 <Cale> yes
21:40:46 <guest2425> Cale: They are 2 clauses in foldr
21:40:48 <Cale> You should think of f as being a replacement for the (:-:) constructor
21:40:57 <guest2425> oh ok
21:40:58 <Cale> and you should think of p as being a replacement for Empty
21:41:15 <Cale> and foldrMyList's job is to make those replacements throughout the list
21:41:55 <Cale> So, for example, the result of  foldrMyList f p (1 :-: (2 :-: (3 :-: Empty)))  will be  f 1 (f 2 (f 3 p))
21:46:12 <guest2425> yes
21:46:12 <guest2425> Cale: so this should be ok for empty foldrMyList f p Empty = Empty
21:46:12 <guest2425> Cale: but it complaints about the typw
21:46:12 <guest2425> 8typw
21:46:12 <guest2425> *type
21:47:09 <Cale> guest2425: no.
21:47:25 <Cale> guest2425: If you replace each occurrence of Empty in Empty with p, what do you get?
21:47:40 <guest2425> Cale: foldrMyList f p Empty = p
21:47:44 <Cale> right
21:47:49 <guest2425> you get p
21:47:52 <guest2425> yeah
21:48:11 <guest2425> Cale: ok now second clause
21:48:51 <Cale> So we're replacing each occurrence of :-: in (x :-: xs) with f, and each occurrence of Empty with p
21:49:03 <guest2425> ok
21:49:20 <Cale> Note that xs, being a List, might have more occurrences of :-: and Empty in it
21:49:40 <Cale> (in fact, it always will have at least one of those)
21:50:08 <Cale> So you have to make the replacements in xs too. Thankfully, you have a function which does that, called foldrMyList ;)
21:50:24 <edwardk> Cale: you obviously have too much free time. I need to get you a job ;)
21:50:34 <edwardk> (re the magnets)
21:50:57 <Cale> edwardk: Compiling inside a virtual machine takes a long time.
21:51:08 <guest2425> Cale: like this foldrMyList f p (x f xs) = 
21:51:13 <guest2425> ?
21:51:20 <Cale> (It's like 5 to 10 minute build cycles)
21:51:51 <Cale> guest2425: foldrMyList f p (x :-: xs) = ...
21:52:05 <guest2425> oh ok
21:52:13 <guest2425> so that part will be the same
21:52:17 <edwardk> Cale: regardless, the magnet models are rather impressive =)
21:52:22 <Cale> edwardk: Thanks!
21:52:30 <Cale> So now we're replacing :-: with f. Note that :-: is written infix, and f is prefix
21:52:42 <Cale> So it'll be f x <something>
21:52:50 <Cale> Not x f <something>
21:52:59 <guest2425> Cale: I ok
21:53:34 <guest2425> Cale: like this foldrMyList f p (x :-: xs) = f x p foldrMyList f xs p
21:54:20 <guest2425> no
21:54:40 <Cale> edwardk: Most of my constructions are made from 2-layer hexagons which have been folded in some fashion and then replicated symmetrically into polygons which are then composed into some polyhedron or another.
21:55:09 <Cale> edwardk: You might have seen http://www.flickr.com/photos/cgibbard/5168792854/ which gives a pretty good idea :)
21:55:27 <guest2425> Cale:  is this part ok foldrMyList f p (x :-: xs) = f x p
21:55:34 <kmc> Cale, what are you building inside a VM? iPwn code?
21:55:38 <Cale> kmc: yeah
21:55:45 <edwardk> Cale: so how many months until you have enough to do the 'hopeless' 5400 piece model that you photographed a piece of? =)
21:55:49 <Cale> kmc: I'm running XCode and the iPhone simulator
21:56:20 <Cale> edwardk: 15
21:56:23 <Cale> er
21:56:29 <Cale> no, 8 :)
21:56:39 <Cale> Assuming I win two free sets every month.
21:57:09 <edwardk> so they are basically paying you in magnets to build stuff with magnets? vicious cycle that
21:57:12 <Cale> yes
21:58:22 <shutch> Not to ask a dumb question, but where would you suggest starting out for someone who has mediocre amounts of experience with procedural languages and less experience with OO languages
21:58:29 <edwardk> clearly we need to pay you in money to do things with money ;)
21:58:45 <Cale> haha
21:59:11 <guest2425>  Cale: like this foldrMyList f p (x :-: xs) = f x p
21:59:11 <opumpkin> shutch: I hear LYAH is good: learnyouahaskell.org
21:59:15 <Cale> Money doesn't naturally arrange itself into icosahedral objects though. So boring.
21:59:21 <shutch> yeah ive been looking through that
21:59:25 <shutch> chapter 3 right now
21:59:26 <opumpkin> http://learnyouahaskell.com/
21:59:28 <opumpkin> ah
21:59:32 <shutch> this recursion is blowing my mind
21:59:33 <shutch> i like it
21:59:44 <opumpkin> getting one's mind blown can be pleasurable
21:59:45 <Cale> Clearly we need magnetic currency.
22:00:21 <Cale> guest2425: What's that p doing there? Which occurrence of Empty is is replacing?
22:00:36 <shutch> so what would you say are the advantages of haskell over something like common lisp
22:00:56 <guest2425> Cale: :-: this
22:01:13 <Cale> shutch: Having an awesome type system. Also common lisp isn't really that great for functional programming (even among lisps)
22:01:21 <danharaj_> Scheme would be better, no?
22:01:25 <Cale> Yeah
22:01:26 <shutch> i see
22:01:44 <Cale> guest2425: That's not Empty ;)
22:01:50 <danharaj_> In the grand scheme of things, you'll probably pick up Scheme/Lisp if you use Haskell long enough.
22:01:53 <danharaj_> If only out of curiosity.
22:01:56 <Cale> guest2425: p is the replacement for Empty, f is the replacement for :-:
22:01:56 <edwardk1> Cale: with the chinese lock on lots of the remaining rare earths, is that a particularly good idea?
22:02:23 <Cale> edwardk1: There are apparently some big neodymium deposits in Canada now too :)
22:02:54 <guest2425> Cale: like this foldrMyList f p (x :-: xs) = f x Empty :-: foldrMyList f xs p
22:03:05 <edwardk1> i for one welcome out new er.. chinadian overlords
22:03:09 <edwardk1> er our
22:03:11 <Cale> Okay, now what's that Empty doing there?
22:03:12 <opumpkin> Cale: you should go into the mining business
22:03:15 <kmc> legalize canada
22:03:18 <xvinyl> danharaj_: what about Clojure ?
22:03:22 <guest2425> cale: hold on
22:03:24 <Cale> edwardk1: lol
22:03:25 <opumpkin> kannada
22:03:30 <guest2425> Cale; hold on
22:03:35 <guest2425> Cale: hold on
22:03:40 <danharaj_> xvinyl: I don't know. Scheme intrigues me. Clojure dosen't.
22:03:50 <xvinyl> danharaj_: minimalistic ?
22:03:52 * Cale holds the conveniently-placed handrail.
22:04:03 <guest2425> hahahaha
22:04:04 <danharaj_> xvinyl: I just don't know what sort of ideas I would gain from it.
22:04:41 <xvinyl> danharaj_: i think the main advantage is, it's a modern implementation of Lisp
22:04:55 <xvinyl> danharaj_: never really used it, though
22:05:18 <guest2425> Cale: I am confuse
22:05:37 <opumpkin> SON. I AM DISAPPOINT
22:05:42 <guest2425> Cale: like this doesnt make sense foldrMyList f p (x :-: xs) = p x  f foldrMyList f xs p
22:05:59 <Cale> right, it makes no sense at all to be passing 6 parameters to p
22:06:07 <Cale> (which doesn't necessarily take any at all)
22:06:18 <opumpkin> omg it's an ivanm
22:06:28 <ivanm> omg it's an opumpkin
22:06:32 <opumpkin> ivanm: I was playing with graphs recently!
22:06:35 <xvinyl> xvinyl: of course if you already know Scheme there won't be much novelty in Clojure
22:06:52 <ManateeLazyCat> Cale: Wow, You do those all ? http://www.flickr.com/photos/cgibbard/
22:07:00 <Cale> ManateeLazyCat: yes
22:07:18 <xvinyl> danharaj: prev. message was supposedto be for you, not for myself obviously :P
22:07:20 <Cale> guest2425: So, consider that  foldrMyList f p xs  will be the list xs where each occurrence of :-: has already been replaced by f, and the Empty (if any) is replaced by p
22:07:27 <ManateeLazyCat> Cale: You're artist! :)
22:07:37 <guest2425> Cale: in the regular foldr you can do this foldr f p (x:xs) = f  p x : foldr f p xs
22:07:46 <Cale> guest2425: no you can't.
22:07:54 <ivanm> opumpkin: \o/
22:07:55 <guest2425> ok
22:07:56 * ManateeLazyCat Add Cale's photos in my bookmark...
22:08:01 <ivanm> opumpkin: have you lost a `c'?
22:08:03 <Cale> ManateeLazyCat: :)
22:08:06 <opumpkin> ivanm: yeah :(
22:08:12 <ivanm> do you want to borrow one?
22:08:28 <danharaj> man
22:08:35 <guest2425> Cale: but you can do this foldr f z (x:xs) = f x (foldr f z xs) 
22:08:40 <danharaj> The longer I think about FRP, the more I want to eschew the notion of time.
22:08:49 <Cale> guest2425: right
22:09:01 <danharaj> At first, I just wanted to get rid of the notion of future.
22:09:05 <danharaj> Now I want to get rid of the notion of past.
22:09:33 <guest2425> Cale: so is this foldrMyList f p (x :-: xs) = f x (foldrMyList f p xs)
22:09:56 <opumpkin> ivanm: anyway, I parametrized the graph by its usage pattern represented by a type (witnessed by a GADT, to prevent you from screwing with it), and then give data families to provide implementations that can accommodate those operations efficiently
22:09:57 <Cale> danharaj: Eventually if you keep cutting concepts out, you'll end up with ordinary functional programming ;)
22:10:03 <danharaj> Cale: heh
22:10:11 <danharaj> There's still a notion of future actually
22:10:13 <Cale> danharaj: (Or more likely some system for incremental computation)
22:10:15 <danharaj> I just hide it in my interface.
22:10:19 <opumpkin> ivanm: not finished yet though
22:10:24 <guest2425> Cale: yeah thank you
22:10:29 <guest2425> Cale: i got it
22:10:31 <Cale> guest2425: right
22:10:39 <opumpkin> ivanm: sure, I'll take one
22:10:40 <guest2425> Cale: yeah I  am happy
22:10:48 <danharaj> Cale: but getting rid of the past is straightforward and gets rid of a lot of potential leaks
22:11:02 <guest2425> Cale: *Main>  foldrMyList (*) 1 (3 :-: 4 :-: 5 :-: Empty)  = 60 yay yay
22:11:12 <Cale> guest2425: :)
22:11:17 * ivanm passes opumpkin a `c' that he happens to have lying around
22:11:20 <danharaj> Cale: making the future opaque to the user means causality is enforced by an inexpressibility of causality-violating signals.
22:11:26 <copumpkin> ivanm: thanks
22:11:30 <guest2425> Cale: thank you for your patiente
22:11:41 <Cale> guest2425: Cheers, no problem
22:11:48 <Cale> danharaj: hmm :)
22:11:50 <ivanm> I've been meaning to hack on my planar graph stuff the past couple of days, but gcc keeps playing up, which means my system plays up :s
22:11:59 <copumpkin> aw
22:12:24 <DJ> 5+7
22:12:34 <Cale> danharaj: So how is it that computations involving values from different points in time are expressed?
22:13:30 <danharaj> Cale: I'm trying to think. If you keep the past around, you can make delayed signals and stuff. But eliminating space/time leaks becomes cumbersome.
22:14:31 <danharaj> Cale: I also have the design goal of making everything with respect to relative time at least from the pov of the user.
22:14:48 <danharaj> Cale: and fixing an absolute time either in the IO monad or some other sort of structure for executing such signals.
22:18:37 <danharaj> anyway, I'm off to bed. The more I think about it, the more it seems like all the relevant data for FRP computation should be visible in the present, and past and future should remain behind the scenes as an implementation detail. I'll try to flesh out some ideas tomorrow.
22:18:51 <danharaj> End of the semester is coming up though, and I have a lot of work to do :|
22:29:41 <ManateeLazyCat> Many package just for ghc-6.12.x
22:30:26 <ManateeLazyCat> Looks i need rollback waiting all packages update to ghc-7
22:42:48 <ChongLi_> hi
22:43:41 <ChongLi> what's the best tutorial explaning State monad?
22:44:49 <ChongLi> haskell seems a million times more complicated than an imperative language for doing a simple thing like: x=3; x+=5;
22:48:20 <guest2425> Cale: are you still here?
22:48:26 <shachaf> ChongLi: The State monad isn't magical -- it's just the equivalent of a function that changes the state and passes it forward as an argument.
22:49:01 <ChongLi> so you are always having to pass it along?
22:49:20 <ChongLi> chained to your ankle
22:49:21 <ChongLi> heh
22:49:31 <shachaf> ChongLi: Well, you can wrap it with some sugar if you like.
22:49:43 <guest2425> Cale: i am getting this error message http://pastebin.com/PbcjJhLP
22:50:03 <ChongLi> and state doesn't work in ghci?
22:50:23 <guest2425> Cale: I am suppose to do a regular [] and {} braces
22:50:54 <shachaf> ChongLi: You are the one chained to your preconceptions. Accept the functions and allow yourself to be free.
22:51:18 <ChongLi> I'd love to but I just don't understand really
22:51:58 <shachaf> ChongLi: Well, that may have been an exaggeration. :-)
22:52:16 <ChongLi> to me, a program is just an endless stream of instructions that modify memory
22:52:38 <shachaf> ChongLi: It might help to stop thinking about programs and start thinking about functions, then.
22:52:39 <Cale> ChongLi: That will be a problematic perspective to take if you're trying to understand Haskell.
22:52:40 <ChongLi> haskell seems to want to wrap the entire program into one expression and then try to evaluate it
22:53:23 <arcatan> RWH on state monad: http://book.realworldhaskell.org/read/monads.html#monads.state
22:53:42 <shachaf> ChongLi: It's going to be a different way of thinking, certainly. :-)
22:53:53 <Cale> ChongLi: Evaluation does indeed modify memory -- replacing expressions with other expressions that are more evaluated, but this is often not the best way to view it.
22:54:18 <Cale> ChongLi: It's often best to just think of everything as its final value. Time doesn't exist.
22:54:45 <ChongLi> yeah, but that doesn't make sense for an interactive program
22:54:58 <ChongLi> which is just a state machine that the user interacts with
22:55:35 <shachaf> ChongLi: In some cases it does.
22:55:55 <shachaf> ChongLi: For instance, (map toUpper) is a specification of an interactive program that converts the user's input to upper-case.
22:57:02 <ChongLi> what do I do with a value the user is not currently interacting with?
22:57:19 <Tefaj> Does ghc have any extension that makes this compile? "string" :: exists a. [a]
22:57:36 <ChongLi> it seems to me that anything I don't pass into the next function basically no longer exists
22:57:52 <guest2425> any idea how to solve this error message http://pastebin.com/SYHYHy9x
22:57:56 <Cale> ChongLi: Indeed, once you try to involve more complicated interactions with time, that becomes a deep and interesting question.
22:58:02 <guest2425> please help
22:58:17 <guest2425> Cale: I am getting this error message http://pastebin.com/SYHYHy9x
22:58:25 <ChongLi> how would you code a GUI spreadsheet in haskell?
22:59:13 <blackdog> ChongLi: I'd write it as a web app, to be honest
22:59:26 <luite> hmm, interesting, natural language input in mathematica 8
22:59:27 <blackdog> you can build gui apps, but it'll be different for each platform.
22:59:29 <Cale> ChongLi: Well, it depends on which GUI library you're using. With a lot of the existing bindings, it's (quite uninterestingly) a lot like imperative programming, because that's just how the underlying libraries are.
22:59:44 <Tefaj> ChongLi: that's a very, very vague question.
22:59:50 <Cale> ChongLi: With one important difference in all cases:
22:59:51 <ChongLi> yeah, I realize that
23:00:06 <ChongLi> I'm just frustrated
23:00:14 <Cale> ChongLi: In Haskell, we have values of type IO t which represent I/O-performing actions having results of type t
23:00:19 <ChongLi> I've been following learnyouahaskell.com for quite a while
23:00:23 <Tefaj> It might be fun to use Haskell's nonstrictness for the job, though.
23:00:27 <ChongLi> and I just hit a brick wall
23:01:11 <ChongLi> here's a simpler example
23:01:22 <ChongLi> how do I code a simple stateful stack that I can play with in ghci
23:01:25 <Cale> That is, x :: IO t means that x is something which can be carried out (you can think of it as source code for a C program if you want), and it can have arbitrary effects on the world when it happens, before producing a value of type t.
23:01:30 <ChongLi> pushing and popping ints onto it
23:01:46 <ChongLi> Ints rather
23:01:47 <Tefaj> If the brick wall is because you're trying to jump from hello world to a spreadsheet, try finding a staircase instead.
23:01:50 <Cale> But evaluation doesn't make that action occur
23:02:20 * hackagebot attoparsec-iteratee 0.1.2 - An adapter to convert attoparsec Parsers into blazing-fast Iteratees  http://hackage.haskell.org/package/attoparsec-iteratee-0.1.2 (GregoryCollins)
23:02:22 <Cale> ChongLi: Let's take a look at these IO things, because it's at least a partial answer to your question.
23:02:40 <ChongLi> Cale: ok
23:03:04 <Cale> ChongLi: Another thing I could do is to show you how to translate a pure imperative program (one which maybe uses some state but which doesn't do any I/O) into an ugly recursive function.
23:03:25 <Cale> (But once you see that, you might see how to make a prettier one)
23:03:52 <ChongLi> well, I know I want to avoid tainting functions with IO as much as possible
23:04:01 <Cale> Right
23:04:37 <Cale> Let's make a program which reads lines from the user, and after each line, prints all the lines it got so far.
23:04:45 <ChongLi> ok
23:04:54 <Cale> :t getLine
23:04:55 <lambdabot> IO String
23:05:18 <Cale> getLine is a value which represents the action of getting a line of text from the user, and that action has a String result
23:05:42 <Cale> Evaluating getLine does nothing visible, but executing it gets that line.
23:05:55 <Cale> (Just need to reinforce that distinction :)
23:06:08 <ChongLi> hmmm
23:06:20 <Cale> In the end, the only IO action which is really executed in a compiled program is main
23:06:30 <Cale> and in turn, it'll have been built from simpler ones
23:06:41 <maurer_> Does anyone know a good way to make Parsec:
23:06:52 <maurer_> a.) Support multiple lineComment values
23:07:09 <Cale> We have do-notation which is a decent way to compose IO actions (it's really syntax sugar for some functions, but let's ignore that for now)
23:07:10 <maurer_> b.) Do iterated prefix operator parsing without parenthesis?
23:07:27 <ivanm> maurer_: what are you trying to parse?
23:07:37 <maurer_> ivanm: A language very similar to C.
23:07:40 <Cale> Oh, another primitive:
23:07:43 <Cale> :t putStrLn
23:07:44 <lambdabot> String -> IO ()
23:07:52 <maurer_> ivanm: However, the spec says that "//" and "#" both start line comments
23:08:11 <Cale> putStrLn takes a String and produces an action which when executed prints the String
23:08:13 <ChongLi> so I made a simple program: getline.hs
23:08:15 <ivanm> maurer_: so use combinators like many or many1
23:08:19 <maurer_> ivanm: It also says that "- ~ - 3" is legal, and I can't get parsec to do this.
23:08:33 <Cale> The action:  do x <- getLine; putStrLn x
23:08:36 <ivanm> maurer_: however, it may be easier to use something like alex + happy if you have a proper grammar for the language
23:08:48 <Cale> will, when executed, read a line of text from the user and print it back out
23:08:49 <maurer_> ivanm: I already have a working complete parser.
23:08:56 <ChongLi> yeah, I did just that
23:09:00 <maurer_> ivanm: I just uses a patched version of buildExpressionParser
23:09:01 <Cale> Instead of the ; you can just line it up with the next line
23:09:14 <Cale> Er, previous :)
23:09:16 <maurer_> And I'm wondering if there's a known way I can lift the modifications I made into my program instead.
23:09:20 <ChongLi> main = do a <- getLine putStrLn a main
23:09:23 <ChongLi> hmm
23:09:23 <Tefaj> maurer: how are you trying to get parsec to do that?
23:09:24 <ChongLi> hehe
23:09:29 <ChongLi> it doesn't paste the newlines
23:09:33 <ChongLi> into my irc client
23:09:36 <Cale> Yeah, that's all right
23:09:37 <ChongLi> oh well
23:09:38 <maurer_> ivanm: Also a patched commentLine attribute to make commentLine support a generic Parser instead of just a string
23:09:44 <Cale> Yeah, so there's a loop
23:09:58 <Cale> Now let's make a new version which collects the lines into a function parameter
23:10:00 <ChongLi> it's an infinite recursive function
23:10:08 <ChongLi> but apparently it doesn't eat up my memory :)
23:10:13 <Cale> yeah
23:10:22 <ChongLi> is that ghc doing some magic?
23:10:38 <Cale> Well, it's just an effect of the exact order in which things occur.
23:11:05 <Tefaj> It's cheney on the invisible jello train
23:11:14 <ChongLi> anyway, lets get back to the tutorial
23:11:20 <ChongLi> you're being very helpful so far :)
23:11:59 <Cale> Okay, so we're going to write our function to take a parameter, the list of lines seen so far:  collectLines :: [String] -> IO ()
23:12:20 <Cale> That way, when we recurse, we can push something new onto the head of that list/stack.
23:12:53 <Cale> collectLines xs = do x <- getLine; print xs; collectLines (x:xs)
23:13:06 <Cale> Try that with an initial list of []
23:13:46 <Cale> actually, we might want to print xs before the getLine, it would make a little more sense ;)
23:13:58 <Cale> Or print (x:xs) instead
23:14:31 <ChongLi> ok
23:15:15 <ChongLi> wow
23:15:25 <ChongLi> it keeps adding new strings to the list
23:15:44 <Cale> yep
23:16:08 <ChongLi> ahh, but this list is somewhere in the void
23:16:14 <ChongLi> I have no pointer to it :(
23:16:19 <Cale> You do too.
23:16:21 <Cale> You have xs
23:16:35 <ChongLi> but how do I access xs from main?
23:16:43 <Cale> Oh, it's not in scope there.
23:17:05 <Cale> However, if collectLines ever finished, you could have it return the list
23:17:12 <Cale> and then main could catch it
23:17:24 <Cale> xs <- collectLines []
23:17:52 <guest2425> Cale: I am having an error message
23:17:59 <Cale> guest2425: Okay, I'll take a look
23:18:33 <guest2425> Cale: this http://pastebin.com/SYHYHy9x
23:18:46 <Cale> You defined your List datatype twice.
23:19:01 <Cale> That's what "Multiple declarations of `Homework8.List'" means
23:19:15 <Cale> You're not allowed to define the same type more than once :)
23:19:25 <Tefaj> Is there a ghc extension for doing this: "string" :: exists a. [a] ?
23:20:02 <shachaf> Tefaj: Unfortunately not.
23:20:13 <shachaf> Tefaj: (Also, that type is pretty useless.)
23:20:18 <guest2425> Cale: I need to do this http://pastebin.com/JptUM0BW
23:21:09 <Boney_> Don't tutors usually get paid?
23:21:41 <Tefaj> shachaf: yeah, it is. But I can think of places where it saves brain cells.
23:21:43 <mtnviewmark> guest2425: define two types:  List and List'
23:21:56 <shachaf> Tefaj: ?
23:22:05 <guest2425> ok
23:22:26 <Cale> guest2425: and don't reuse the name Empty either
23:22:38 <Cale> guest2425: Maybe make it Nil for one of the types of list
23:23:51 <Tefaj> shachaf: like if x has a really hairy type, and I want to write return x :: exists a. [] a, where something will magically infer a (the type of x)
23:24:10 <mtnviewmark> if this is a problem set, then I'm guessing that show . toList isn't going to be the solution the instructor is after
23:25:12 <mtnviewmark> but showMyList looks about right
23:25:41 <Cale> ChongLi: We can implement some control structures as well, since IO actions are values.
23:26:09 <Cale> ChongLi: So for example, if we want a function which carries out an IO action a given number of times...
23:26:35 <Cale> (and let's say, collects a list of all the results)
23:26:52 <Tefaj> Suppose I could write myReturn x where myReturn x :: forall a. a -> [a], but using forall for existential typing has always felt strange to me
23:27:00 <guest2425> Cale: so dont type empty twice
23:27:11 <Cale> ChongLi: times :: Int -> IO t -> IO [t]
23:27:36 <Cale> ChongLi: We can define it recursively like:   times 0 x = return []
23:27:46 <guest2425> mtnviewmark; complains about Empty now
23:27:55 <Cale> times n x = do v <- x; vs <- times (n-1) x; return (v:vs)
23:27:57 <guest2425> Multiple declarations of `Homework8.Empty'
23:28:06 <guest2425> mtnviewmark: Multiple declarations of `Homework8.Empty'
23:28:21 <mtnviewmark> each type is defining a constructor named Empty - they are both at top level - hence colliding
23:28:32 <Cale> ChongLi: Oh, that's important to note as well:  return :: a -> IO a  is not syntax, but just a function which gives the IO action that does nothing, except return that value.
23:28:34 <mtnviewmark> do you need to put both of these parts of the assignment in the same module (file)?
23:28:44 <guest2425> yes
23:28:45 <blackdog> p/sb end
23:28:50 <Cale> ChongLi: (it's actually more general, and works in any monad, but we'll ignore that)
23:29:31 <guest2425> mtnviewmark: never mind I will do another main for problem 8b
23:29:35 <mtnviewmark> then they need to be different types (hence List and List') and the constructors need to be all distinct (try Empty and Empty' ) since otherwise, when Empty appeared elsewhere in the program, it wouldn't be clear which of the two types it meant
23:29:36 <ChongLi> wait a sec
23:29:46 <ChongLi> times 0 x = return []
23:30:08 <mtnviewmark> that seems perhaps better
23:30:11 <ChongLi> what is going on here?
23:30:42 <ChongLi> return wraps the empty list in an IO?
23:31:05 <shachaf> ChongLi: It constructs an IO action that, when executed, does nothing and gives you the value [].
23:31:39 <mtnviewmark> ChongLi: I read that as "to do an action 0 times, return an action that results in the empty list"
23:32:09 <ChongLi> return in haskell is very strange
23:32:15 <mtnviewmark> or perhaps "the value of doing an action 0 times is the action the returns the empty list"
23:32:31 <Cale> ChongLi: return [] is the action which does nothing, and produces the empty list every time
23:32:31 <shachaf> ChongLi: Ignore the associations you have with that name -- it's an unfortunate similarity.
23:32:40 <ChongLi> the parameters 0 and x seem to be discarded?
23:32:49 <Cale> x is discarded
23:32:55 <Cale> 0 is pattern matched
23:33:10 <Cale> So this case only applies when the number of times to loop is 0
23:33:11 <ChongLi> ok, so if i pass in a 1 it'll just throw an error?
23:33:23 <shachaf> ChongLi: Yes -- the rest of the function hasn't been defined yet. :-)
23:33:24 <Cale> Well, it'll try the next case, before that happens
23:33:33 <Cale> (which happens to apply)
23:33:43 <shachaf> (Oh, it was defined above. Never mind.)
23:33:43 <mtnviewmark> no, the 1 won't match the 0, so that clause won't be selected - instead the second clause Cale gave will be, and that one matches
23:34:00 <ChongLi> oh, I must've missed the second clause
23:34:31 <ChongLi> ahh
23:34:33 <ChongLi> times n x = do v <- x; vs <- times (n-1) x; return (v:vs)
23:34:39 <ChongLi> that makes the function more useful
23:34:52 <ChongLi> I was going to say, hehe
23:35:27 <Cale> yeah
23:35:27 <ChongLi> wait, so where do v and vs come from?
23:35:36 <Cale> v is the result of running the action x
23:35:56 <ChongLi> ahh, right
23:36:07 <Cale> and vs is the result of running the action  times (n-1) x
23:37:18 <Cale> So this is something nice about imperative programming in Haskell. Since we can pass actions around as values without having evaluation set them off prematurely, we can invent our own control structures, and make libraries of them
23:37:57 <ChongLi> yeah, laziness's perks pop up everywhere it seems
23:37:58 <shachaf> Cale: To be fair, you could do this in any language by wrapping the action in a lambda.
23:38:02 <Cale> (Control.Monad is such a library of control structures, generalised to things beyond IO, but IO is a monad, so all those functions apply)
23:38:24 <kmc> ChongLi, this isn't about laziness -- even when you *do* evaluate an IO action, you don't execute it
23:38:27 <mtnviewmark> Ah, but in Haskell we can manipulate actions like values - which isn't so easy in other langauges
23:38:39 <Cale> ChongLi: Yeah, this actually isn't laziness, it's the separation of evaluation from execution, so that evaluation order doesn't matter at all.
23:38:54 <mtnviewmark> consider:  repeat 5 1    gets  [1,1,1,1,1]   
23:38:57 <kmc> mtnviewmark, it's easy in most languages; they just call actions zero-arg functions
23:39:00 <ChongLi> so how do I make use of times in my little program here?
23:39:07 <Cale> (Lazy evaluation is an evaluation order, together with a little optimisation over that)
23:39:09 <mtnviewmark> where as   repeat 5 getline      gets a list of five actions!
23:39:18 <ChongLi> it's expecting an IO type as parameter
23:39:27 <shachaf> mtnviewmark: That's not really a fair comparison.
23:39:33 <shachaf> mtnviewmark: You still need to sequence it.
23:39:34 <Cale> ChongLi: Maybe try  main = do vs <- times 5 getLine; print vs
23:39:36 <mtnviewmark> :-)
23:40:03 <Cale> ChongLi: Of course, in place of getLine there, you could also stick in a do-block
23:40:19 <mtnviewmark> well, actually - it think that is sort of the point --- you can separate out the manipulation from the execution or combination via sequence.....
23:40:25 <Cale> In order to avoid parens in that case, using a $ after the 5 would be good style.
23:40:40 <Cale> do vs <- times 5 $
23:40:41 <shachaf> mtnviewmark: But you can write sequence in another language too, if your actions are wrapped in "lambdas".
23:40:48 <Cale>          do ... some stuff ...
23:41:00 <Cale>    continue onward ...
23:41:32 <guest2425> Can someone help with this puzzle please http://pastebin.com/VerqQnq4
23:41:53 <guest2425> Cale: Can you help me with this puzzle please http://pastebin.com/VerqQnq4
23:42:57 <Cale> guest2425: What in particular are you having trouble with?
23:43:02 <ChongLi> ok, so each time main loops back around
23:43:03 <Cale> guest2425: Do you understand typeclasses?
23:43:12 <ChongLi> it wipes out vs with another 5 strings
23:43:15 <guest2425> Cale: no
23:43:30 <Cale> ChongLi: Yeah.
23:43:42 <Cale> ChongLi: In fact, vs isn't being updated as such.
23:43:53 <ChongLi> it's being printed and then it's gone?
23:44:15 <Cale> ChongLi: vs isn't the name of a cell in memory which is being modified to the result of getLine, it's a name directly for the result of getLine
23:44:34 <Cale> This is a subtle distinction, I know.
23:44:45 <ChongLi> weird
23:44:55 <guest2425> Cale: type classes is the type I create??
23:45:07 <Cale> guest2425: no.
23:45:18 <Cale> guest2425: You should read about typeclasses somewhere first.
23:45:20 <ChongLi> so when vs is evaluated it simple calls getLine and then prints the result?
23:45:27 <guest2425> Cale: ok
23:45:45 <ChongLi> like a unix pipe?
23:46:04 <Cale> guest2425: They're introduced with the class keyword, and instances with the instance keyword (so you know when you've found the right part of your book)
23:46:42 <guest2425> Cale: ok thank you
23:47:41 <Cale> ChongLi: No, when the action that this do-block describes is executed, getLine is executed, and vs is a name for its result -- that is, if vs occurs in later lines in the do-block, those directly point to the result of getLine in memory (and cause it to be retained)
23:47:54 <Cale> If you want to think in terms of pointers, that is.
23:48:17 <ChongLi> hmm
23:48:19 <Cale> But I think it's maybe easier just to say that vs *is* the result of getLine, whatever that may be.
23:48:55 <ChongLi> so how do I set vs aside, get some lines into xs and then go back to vs later?
23:48:58 <Cale> It's not a memory cell into which we're storing the result of getLine -- that result exists somewhere in memory sure, but it is an immutable value.
23:49:23 <ChongLi> it seems everything in haskell is immutable
23:49:25 <Cale> (vs is immutable as well)
23:49:26 <Cale> Yeah
23:49:33 <Tefaj> .oO( a continuation! )
23:49:34 <Cale> Well, there are IORefs
23:49:48 <kmc> yeah -- you can allocate mutable cells specially, but they're different from variables
23:49:51 <Cale> and, by calling a function with different parameters, you can also simulate mutability
23:50:09 <ChongLi> you're constantly running along allocating new stuff while the garbage collector cleans up behind you?
23:50:16 <pkrumins> I have code `handle <- connectTo host port` and runhaskell dies silently right there. Any ideas how to extract some kind of error there, why it dies?
23:50:16 <Cale> ChongLi: yep
23:50:26 <Cale> ChongLi: and it's really good at picking up short-lived data
23:50:43 <kmc> ChongLi, and much of the new data will actually point back into the old data
23:50:46 <kmc> since it's immutable
23:50:57 <kmc> you can often share between "versions" of data, without doing a full copy
23:51:07 <ChongLi> yeah, I followed an example about finding the average of 1e9 Doubles
23:51:17 <kmc> like if you implement a binary tree in Haskell in the straightforward way
23:51:22 <kmc> then when you call insert it will return a "new" tree
23:51:23 <ChongLi> it was insane how much memory it ran through while keeping the total footprint low
23:51:30 <kmc> but actually most of the tree will be shared
23:51:35 <kmc> only O(log n) will be copied, for a balanced tree
23:51:59 <Cale> Right, we have things like Data.Set which gives you a set structure (internally a tree), and when you use the insert function to add a new value to an existing set, it makes a new tree, but that tree shares almost all of its structure with the old one (so it's constructed in log memory and space)
23:52:03 <ChongLi> oh, so it's not copying the entire tree to a new chunk of memory?
23:52:06 <Cale> er, log time and space
23:52:08 <ChongLi> that's useful :)
23:52:12 <kmc> right
23:52:19 <kmc> and this isn't some special compiler optimization that has to work just right
23:52:22 <ChongLi> it kind of reminds me of zfs
23:52:24 <kmc> it's a basic consequence of the Haskell data model
23:52:26 <Cale> It only rebuilds a new path from the root to the element (and a little more for balancing)
23:52:31 <ChongLi> (I'm running freebsd)
23:52:46 <kmc> and in particular of immutability
23:52:52 <ChongLi> with zfs when you write to a file it doesn't overwrite the file, it allocates a new one
23:52:59 <kmc> concurrent systems in most languages have to either do lots of copying, or lots of locking
23:53:02 <xvinyl> ChongLi: FreeBSD, really ?
23:53:03 <ChongLi> and then points to the new file
23:53:08 <kmc> if you use immutable data, you need neither
23:53:13 <ChongLi> xvinyl: yeah
23:53:16 <xvinyl> ChongLi: does it have good Haskell support ?
23:53:17 <kmc> just some atomic pointer swaps
23:53:35 <ChongLi> xvinyl: not sure I'd be able to answer that adequately
23:53:41 <ChongLi> I installed ghc from the ports tree
23:53:45 <kmc> and you can do that in any language, but Haskell makes it natural, while most languages try to thwart this style
23:53:47 <ChongLi> and started messing around :)
23:54:10 <xvinyl> ChongLi: ok. Enjoy !
23:54:16 <ChongLi> thanks
23:56:08 <guest2425> Cale: why this dont work data Structure = structureMap (a -> b) -> [a] -> [b]  |   structureFoldr (a -> b -> b) -> b -> [a] -> b
23:56:39 <xvinyl> companion_cube: do you study Haskell at X nowadays :) ?
23:57:05 <companion_cube> if only...
23:58:36 <guest2425> :t []
23:58:37 <lambdabot> forall a. [a]
23:58:59 <guest2425> :t  (a -> b) -> [a] -> [b]
23:59:00 <lambdabot> parse error on input `->'
23:59:49 <dmwit> > product [1..52] / 2^^30
23:59:50 <lambdabot>   7.511877936398972e58
