00:01:33 <allbery_b> uniqueness types are a sort of special case of monads.  turns out that providing them without the protections provided by monads, in Haskell, is really tricky
00:03:13 <allbery_b> so you usually end up using monads anyway to enforce safe usage, and then you might as well thread a state parameter and be done with it... which gives you the IO monad
00:05:00 <ski> allbery_b : linear implicit parameters are not like Clean's / Mercury's unique types / insts, no
00:08:59 <allbery_b> ski: sure looks to me like the restrictions on their use makes thrm look like it, until you push the limits (cf http://www.haskell.org/ghc/docs/6.4/html/users_guide/type-extensions.html#id3144379) and they bite you hard in  the butt
00:09:54 <allbery_b> a half-*ssed attempt at uniqueness types without most of the guarantees
00:11:03 <ski> allbery_b : there's nothing corresponding to `split' in Clean
00:11:48 <ski> and `split' is basically the point of linear implicit parameters, in addition to what the "implicit parameters" part give you
00:12:40 <kmc> it sounds like this is sugar providing something resembling uniqueness types
00:12:53 <allbery_b> yes
00:12:53 <kmc> but as i understand it, uniqueness types in Clean are much deeper than sugar
00:13:02 <allbery_b> but not close enough
00:13:33 * hackagebot yesod-continuations 0.1 - Continuations for Yesod  http://hackage.haskell.org/package/yesod-continuations-0.1 (MattBrown)
00:13:33 <allbery_b> and split is kinda "uniqueness types don't work in Haskell so we add a hack"
00:13:40 <ski> uniqueness types in Clean has nothing to do with splitting values, either implicitly or explicitly
00:13:52 <ski> (it also has nothing to do with implicit parameters)
00:14:00 * ddarius agrees with ski.
00:14:49 <ski> if you want to split a (unique or not) value in Clean, you need to explicitly apply a splitting function, just like you'd do in Haskell, if you didn't use linear implicit parameters
00:16:35 <Saizan> linear implicit parameters insert a split exactly in the cases where you'd get a type error with uniqueness types, though?
00:18:25 <ddarius> Saizan: They are somewhat dual insofar as uniqueness types require a pattern of usage while linear implicit parameters provide a pattern of usage.
00:19:31 <ski> Saizan : not quite. look at the `foo' example at <http://www.haskell.org/ghc/docs/6.4/html/users_guide/type-extensions.html#id3144379> -- `foom' is used (potentially) more than once, but `x' is still not split
00:20:07 <ski> in Clean, you'd get an error with that code, if `x' was unique
00:21:25 <ddarius> Yes, there's a subtle but significant distinction between 'linear' and 'unique.'
00:22:13 <ski> hm, that too, yes
00:22:53 <ski> `unique' being "hasn't been duplicated yet", while `linear' being "will not be duplicated in the future"
00:23:22 * ski recalls edwardk worked through this some time ago
00:23:38 <ski> (well, s/duplicated/duplicated or discarded/ really)
00:23:39 <ddarius> There was a paper about this not too long ago.
00:23:59 <ski> do you recall the title ?
00:24:18 <Saizan> how is x not duplicated in the future in foom?
00:25:16 <ski> "linear implicit parameters" probably only loosely relates to the "linear" in "linear logic"
00:25:43 <ski> (the one about future duplication was re linear logic)
00:29:28 <ddarius> ski: https://www.cs.tcd.ie/~devriese/pub/ifl07-paper.pdf  This is the paper I was talking about, though of course the difference between linear and unique has been known for well over a decade.
00:30:09 <ski> ddarius : ty
00:30:46 <ski> (yeah, but there's still confusion about it. i know it took me a while to remember and appreciate the distinction)
00:30:49 <ddarius> Dana Harrington's (2001) thesis also covers the difference in one part.
00:31:05 <ski> (btw, semi-related to the above discussion on `split' : <http://en.wikipedia.org/wiki/Coalgebra>,<http://en.wikipedia.org/wiki/Hopf_algebra>)
00:31:16 * Saizan can't see the rationale behind the foom translation, other than "this is what we managed to implement"
00:38:46 <ski> "A Type System for Destructive Updates in Declarative Programming Languages" at <http://web.archive.org/web/*/http://pages.cpsc.ucalgary.ca/~danaha/uniqueness-types.ps> by Dana G. Harrington in 2001-10
00:42:18 <Nibble> why hasn't arch updated their ghc package
00:45:41 <kmc> for ghc7?
00:45:45 <kmc> perhaps they are tracking haskell-platform
00:47:14 <Nibble> perhaps :/
00:54:43 <lars9> unlike in C, it seems ok to compare two Doubles using ==, does it imply that haskell's double is not the same as a raw floating number?
00:55:08 <Nibble> lars9: nope
00:56:03 <lars9> Nibble: then what is Double in haskell?
00:56:22 <kmc> why do you think it's not ok in C / why do you think it's okay in Haskell
00:57:04 <medfly> :t (==)
00:57:05 <lambdabot> forall a. (Eq a) => a -> a -> Bool
00:57:08 <Jafet> print (unsafeCoerce x :: CDouble)
00:57:10 <kmc> > 2.0 == 2.0
00:57:11 <medfly> problem solved
00:57:11 <lambdabot>   True
00:57:15 <kmc> > let x = 0/0 in x == x
00:57:16 <lambdabot>   False
00:57:56 <ddarius> Haskell's Double type is not necessarily a (boxed) machine double, but I believe all extant implementations do use hardware floating point for Double and Float.
00:58:13 <ddarius> But yes, (==) is no more or less appropriate in Haskell than C.
00:58:48 <kmc> the Haskell spec has very little to say about Double
00:59:07 <nejucomo> $ cabal install base
00:59:07 <nejucomo> Resolving dependencies...
00:59:08 <nejucomo> cabal: Distribution/Client/Dependency/TopDown.hs:169:37-73: Non-exhaustive patterns in lambda
00:59:18 <kmc> http://www.google.com/search?q=double+site:http://www.haskell.org/onlinereport/
00:59:36 <kmc> http://www.google.com/search?q=double+site:http://www.haskell.org/onlinereport/haskell2010
00:59:41 <nejucomo> I'm having a hard time upgrading cabal-install on an ubuntu lucid box.
00:59:51 <kmc> lars9, so i'm not sure you can even say that Haskell *has* the Double type
01:00:02 <kmc> but in GHC, it's a machine float
01:00:13 <Jafet> hs98 says as much about Double as C does.
01:00:17 <kmc> not sure what gave you the impression otherwise
01:00:26 <Jafet> "It *should* be IEEE double-precision floating point"
01:00:36 <lars9> kmc: i tested, adding [1, 0.5, 0.25 ....] (length 10000), then compare the result (==2.0), in haskell it's true. in c it's false.
01:01:10 <kmc> from that one data point you conclude that (==) on Double is free of caveats?
01:01:19 <Jafet> lars9: then you do not understand floating point arithmetic.
01:01:26 <Jafet> For one thing, addition is not associative
01:01:42 <kmc> for some reason you're invoking a different set of operations in C and Haskell and this means you get different results
01:02:10 <kmc> > sum . take 10000 $ iterate (/2) 1.0
01:02:12 <lambdabot>   2.0
01:02:17 <kmc> > (sum . take 10000 $ iterate (/2) 1.0) == 2.0
01:02:18 <lambdabot>   True
01:02:19 <lars9> Jafet: i know exactly how float point is encoded in bits...
01:02:42 <kmc> lars9, then you should know that one experiment doesn't tell you much about how Haskell or GHC treats floating point
01:03:04 <Jafet> That's not even half of what is to know about floating point.
01:03:08 <theorbtwo> The #1 thing to remember about floating point is that, while there are an infinite number of reals, there is a very finite number of floats (of a given precision).
01:03:23 <theorbtwo> Almost everything else flows naturally from that.
01:03:26 <nejucomo> When running "cabal install cabal-install" it seems to build all dependencies with no errors (plenty of warnings) then get through steps 40 of 40 for cabal, then dies after printing "Linking dist/build/cabal/cabal".
01:03:33 <nejucomo> ExitFailure 9
01:03:43 <nejucomo> I don't see any specific indication of what went wrong.
01:03:48 <nejucomo> Any advice?
01:04:34 <kmc> indeed, there are uncountably many reals
01:04:40 <ddarius> theorbtwo: There's only a finite number of integers occupying a given number of bits, but the algebra for machine integers is quite a bit nicer than the one for floating point.
01:04:54 <kmc> so even encodings which use arbitrarily many bits will fail to represent almost all reals
01:05:02 <kmc> though this fact is perhaps less practically relevant
01:05:06 <Jafet> lars9: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.102.244&rep=rep1&type=pdf
01:05:42 * nejucomo mourns the unrepresentable irrationals.
01:05:44 <Jafet> IEEE floating-point isn't a subset of the reals, either
01:05:48 <Jafet> > 1/0
01:05:49 <lambdabot>   Infinity
01:05:59 <ddarius> nejucomo: They never existed to begin with.  Nothing to mourn.
01:06:04 <kmc> damn straight
01:06:11 <kmc> the "real" numbers are anything but
01:06:30 <nejucomo> huh?
01:06:55 <nejucomo> I think it may be too late for me to talk about reals and attempt to grok cabal error messages.
01:07:40 <jyper> I have a list of maybe that I want to use like a list for Data.List.find what is the easiest way to do so?
01:07:53 <kmc> jyper, as is.  a list of maybes is a list
01:08:02 <jyper> is there an easier way then wrapping it with a conditional lambda
01:08:15 <kmc> > Data.List.find (== Nothing) [Just 3, Nothing]
01:08:16 <lambdabot>   Just Nothing
01:08:19 <nejucomo> Aha: http://tuukka.iki.fi/tmp/haskell-2009-04-10.html#00:49:53.2
01:08:20 <kmc> > Data.List.find isJust [Just 3, Nothing]
01:08:21 <lambdabot>   Just (Just 3)
01:08:51 <jyper> I meant using a funxtion that works with type a with a list of Maybe a
01:09:01 <kmc> :t catMaybes -- jyper 
01:09:02 <lambdabot> forall a. [Maybe a] -> [a]
01:09:04 <kmc> from Data.Maybe
01:09:29 <jyper> currently I have (\y -> case x of Just z -> isAValidSolution; otherwise -> Nothing)
01:09:31 <lars9> lets do an experiment, you can get a number < 100 from "length $ takeWhile (/=1.5) $ scanl1 (+) $  iterate (/3.0) 1"; but how to repeat it in c?
01:10:04 <lars9> i tried several different numbers
01:10:26 <TryingToLearnHas> is hpaste.org link down???
01:10:33 <nejucomo> Looks like I must run "cabal install caball-install" as super user.  That's too bad.
01:10:42 <jyper> kmc++, thanks, somehow I kept forgetting about catMaybes
01:10:56 <ddarius> catMaybes is a super useful function.
01:11:03 <nejucomo> jyper: fmap . isAValidSolution
01:11:21 <nejucomo> Do you want to filter out all the Nothings or leave them in?
01:11:34 <ddarius> Of course, if you did forget about its existence, it's easily representable: catMaybes xs = [x | Just x <- xs]
01:11:43 <nejucomo> Err, I mean "fmap isAValidSoltion"
01:11:45 <kmc> :t \xs -> [x | Just x <- xs]
01:11:46 <lambdabot> forall t. [Maybe t] -> [t]
01:11:51 <nejucomo> except I can't type, nor think.
01:13:02 <nejucomo> Where do I submit a UI bug ticket to cabal so that it mentions it needs sudo instead of just saying "failed, exit 9" at the very end of the upgrade?
01:16:20 <kmc> nejucomo, http://hackage.haskell.org/trac/hackage/
01:16:25 <TryingToLearnHas> hello, happy holidays... can anyone help me with this http://hpaste.org/41844/kenken
01:16:31 <nejucomo> kmc: Thanks.
01:19:05 <lars9> hah, i did test on more numbers
01:20:27 <lars9> for 41 numbers out of [2..100], "scanl1 (+) $ iterate (/x) 1" does not give exact 1/(1 - 1/x)
01:21:23 <lars9> for the rest 55 numbers, haskell's double gives exact 1/(1-1/x)
01:22:09 <lars9> so haskell's Double still a read "float point", but the result is very different from c's double, more exact match.
01:22:26 <kmc> Haskell's Double is not anything.
01:22:32 <kmc> GHC's Double is a machine floating point
01:22:43 <ddarius> There's nothing different about Haskell's floats (in GHC) and C's and I'm pretty sure they both implement comparison via fcmp.
01:23:06 <ddarius> lars9: The difference is that you are using different algorithms in Haskell and C and thus get different results.
01:23:14 <kmc> unless i'm mistaken, it will give the exact same results as C's double, when you perform the same operations in the same order
01:26:21 <Jafet> Well, there's also the rounding mode to consider
01:26:43 <lars9> kmc: maybe some intermediate states are different. but anyway there is no magic in haskell Double.
01:27:02 <Jafet> Or x87 fun
01:28:01 <kmc> "Float is implementation-defined; it is desirable that this type be at least equal in range and precision to the IEEE single-precision type. Similarly, Double should cover IEEE double-precision."
01:28:12 <kmc> lars9, there is very little you can say about Double in Haskell in general
01:28:33 <kmc> you can talk about what GHC happens to do today
01:28:41 <kmc> but you keep saying "Haskell Double" like it's a precisely defined concept
01:29:10 <kmc> if you need precise, portable semantics, you should not use Double, and this is true of most languages
01:29:38 <augur> portable semantics?
01:29:52 <kmc> Jafet, yeah, and there's no way to set the rounding mode in GHC Haskell without interfering with other threads :/
01:30:07 <augur> also: lambda operators with their variable can be given a denotation in a semantics with variable assignments. x.x
01:31:05 <lars9> kmc: i see, it's implementation dependent?
01:31:09 <kmc> yes
01:31:44 <Jafet> http://www.nicta.com.au/people/norrishm/attachments/bibliographies_and_papers/2008/C-TR.pdf
01:32:23 <kmc> jesus
01:32:37 <kmc> so is "float" / "double" in C and C++ spec'd to be IEEE, or is it implementation-dependent?
01:32:40 <kmc> i always thought the latter
01:32:48 <kmc> is this a point where C and C++ differ?
01:33:18 <Jafet> Like in hs98, C does not require float and double to be IEEE floating-point, but it is recommended
01:33:21 <kadoban> it's probably implementation defined in both
01:33:27 <lars9> Jafet: hi you work in nicta?
01:34:14 <kmc> IIRC C++ at least provides a way to ask "is the implementation IEEE" at compile-time
01:34:36 <Jafet> lars9: I don't work
01:35:40 <lars9> Jafet: :)
01:36:39 <Jafet> kmc: I've never seen an actual program using it
01:38:51 <TryingToLearnHas> hello can anyone help me with this: http://hpaste.org/41844/kenken
01:41:43 <Jafet> trying: http://haskell.org/haskellwiki/Literate_Haskell
01:43:49 <Jafet> Er
01:44:57 <Jafet> http://haskell.org/haskellwiki/Literate_programming
01:58:01 * hackagebot supercollider-midi 0.1.3 - Demonstrate how to control SuperCollider via ALSA-MIDI  http://hackage.haskell.org/package/supercollider-midi-0.1.3 (HenningThielemann)
02:08:18 <jyper> TryingToLearnHaskell: I'm not quite sure but I think cageCellsInGrid grid cage = [getCell grid ref | ref <- cells cage]   and  cageComplete grid cage = all isNullValue (cageCellsInGrid grid cage)
02:10:06 * hackagebot pvd 1.0.0 - A photo viewer daemon application with remote controlling abilities.  http://hackage.haskell.org/package/pvd-1.0.0 (RickardNilsson)
02:26:33 <mreh> why does everything in Java have to be over engineered?
02:26:45 <mreh> objection, argumentative
02:27:05 <geheimdienst> object orientation, argumentative
02:27:46 <Jafet> Obsessive objectification perversion?
02:28:36 * geheimdienst thinks java has a tendency for overengineering, but overengineering is possible in any language
02:29:38 <mreh> I think it's all Java people bike shedding
02:29:58 <Jonno_FTW> bike shedding?
02:30:19 <mreh> over-complicating simple things
02:30:20 <geheimdienst> Jonno_FTW: well, a cat sheds hair, java people shed bikes
02:30:47 <Jonno_FTW> I was thinking shed as in garage
02:30:52 <mreh> @google bike shedding Parkinson
02:30:52 <lambdabot> http://en.wikipedia.org/wiki/Parkinson's_Law_of_Triviality
02:30:53 <lambdabot> Title: Parkinson's Law of Triviality - Wikipedia, the free encyclopedia
02:31:14 <geheimdienst> Jonno_FTW: i'm just messing with you :-) j/k
02:31:36 <Jonno_FTW> :|
02:38:53 <mreh> :t listify
02:38:54 <lambdabot> forall r a. (Data a, Typeable r) => (r -> Bool) -> a -> [r]
02:39:17 <mreh> huh?
02:40:52 <ManateeLazyCat> mreh: "over-complicating simple things" Yes, i agree
02:41:55 <mreh> I'm afraid to use haskell at work, my colleagues will think I'm not doing any work
02:42:44 <ManateeLazyCat> mreh: Haskell make complicated thing simpler
02:43:11 <ManateeLazyCat> mreh: Haskell just need 1/10 code solve problem perfect
02:43:32 <jutaro> ManateeLazyCat: Hi, have installed your stuff
02:43:34 <ManateeLazyCat> mreh: Same work, code less is better
02:43:43 <ManateeLazyCat> jutaro: Any bug?
02:43:44 <ManateeLazyCat> :)
02:44:16 <jutaro> Well, I tested with xmonad, and it is possible to run it
02:44:43 <jutaro> Great work!
02:45:23 <jutaro> I don't know if I can use parts in Leksah. 
02:45:38 <ManateeLazyCat> jutaro: In XMOnad, when you press M-f popup search window, XMonad can't focus window correctly
02:46:05 <ManateeLazyCat> jutaro: I have create Manatee video, server in handling, i will paste video link later.
02:46:23 <ManateeLazyCat> jutaro: You will know how to play it after you watch video
02:46:38 <jutaro> ok
02:46:51 <ManateeLazyCat> http://www.tudou.com/programs/view/nZrYy3CR5Ho/
02:46:55 <ManateeLazyCat> jutaro: ^^^^^
02:47:19 <ManateeLazyCat> Oh, compress by server
02:47:23 <ManateeLazyCat> Not so clear
02:48:01 <ManateeLazyCat> Maybe tudou.com have HD version?
02:48:04 <ManateeLazyCat> Find out.
02:49:02 <jutaro> but to be honest, I don't think to use Manatee as my work env currently. I'm more interested in the underlying concepts
02:50:26 <ManateeLazyCat> jutaro: Yes, Manatee just beginning, many detail haven't finish
02:51:00 <ManateeLazyCat> jutaro: I recommend play it now, but don't use as productive tool. :)
02:51:34 <jutaro> ManateeLazyCat: This music is like candy
02:51:51 <ManateeLazyCat> jutaro: Hehe, my favorites
02:52:04 <jutaro> ManateeLazyCat: What is it?
02:52:06 <ManateeLazyCat> jutaro: Video is not clear, but my .avi is HD version
02:52:17 <ManateeLazyCat> jutaro: But don't know why server compress it.
02:52:26 <ManateeLazyCat> jutaro: Depend on you how to use it. :)
02:53:15 <jutaro> Leksah has videos to, have you seen?: http://www.youtube.com/watch?v=iSUvMe7HVQY
02:53:52 <jutaro> But no music
02:54:21 <ManateeLazyCat> jutaro: I know Leksah
02:54:34 <ManateeLazyCat> jutaro: I can't upload video to YouTube.com now.
02:54:47 <jutaro> ManateeLazyCat: Tell me about that music, who are the artists?
02:54:57 <ManateeLazyCat> jutaro: Owl city
02:54:59 <jutaro> ManateeLazyCat: Why not?
02:55:10 <ManateeLazyCat> jutaro: GFW
02:55:30 <ManateeLazyCat> jutaro: My proxy tool (GAppProxy) can't upload *large* file 
02:55:44 <jutaro> oh
02:56:22 <ManateeLazyCat> jutaro: My video is can't show content, i need contact tudou.com's administrator.
02:57:30 <jutaro> ManateeLazyCat: Well I can see the vid (after some chinese commercial)
02:58:02 <jutaro> ManateeLazyCat: What are your plans for making Manatee a Haskell IDE?
02:58:06 <ManateeLazyCat> jutaro: I remember you're Leksah developer, is it?
02:58:36 <ManateeLazyCat> jutaro: Code completion like Eclipse, Fly suggestion by hlint, integrated ghci in temrinal 
02:58:45 <ManateeLazyCat> jutaro: And more handy command like Emacs.
02:58:49 <lars9_> hi is there any library deal with infinite graph? that is: buildInfiniteGraph :: (n -> [n]) -> InfiniteGraph n
02:59:17 <jutaro> ManateeLazyCat: I want to make a plugin concept for Leksah, so maybe I do it multithreaded
02:59:36 <ManateeLazyCat> jutaro: You can see my project 'pdynload'
02:59:49 <jutaro> ManateeLazyCat: Ok
02:59:52 <ManateeLazyCat> jutaro: I plan mix it in Manatee to support hot-swapping 
03:00:49 <ManateeLazyCat> @package pdynload
03:00:49 <lambdabot> http://hackage.haskell.org/package/pdynload
03:01:47 <ManateeLazyCat> jutaro: Manatee is not IDE
03:02:36 <ElijahsFriend> 'God bless america'
03:02:37 <ElijahsFriend> I hear this call in all circles. Military, Political, Financial and even Churches. But I say America bless God first. Make him proud to be an American then yes he will bless you as a nation. In your coming and in your going, in your dealings and in your negotiations yes I dare say even in your prosperity. But it is not a one way street. Should God reward us for our misdeeds, our greed and...
03:02:39 <ElijahsFriend> ...our lack of mercy. We push our power around like a bully rather than a benefactor. I say let us show God what we want from him and not the other way around because we neither obey nor follow the lead we just goad that he favors us. Now let me show you when he blesses other nations so that you can see what you missed. As far as one nation under God you can kiss my ass. - Elijah
03:03:27 <jutaro> ManateeLazyCat: Well, it would have been perfect, if you would have started your project first
03:03:27 <monadic_kid> hmmmmm
03:03:53 <ManateeLazyCat> jutaro: Now pdynload still issue before mix, i will found time fix it.
03:04:05 <ManateeLazyCat> jutaro: Maybe i need develop "customize system" first.
03:04:08 <monadic_kid> ElijahsFriend: do you understand what this room is about?
03:04:12 <ManateeLazyCat> jutaro: So you can use Manatee in XMOnad?
03:05:00 <jutaro> ManateeLazyCat: No problem, if I use a complete screen
03:05:20 <ManateeLazyCat> jutaro: Can you try M-f and type something (url or filepath) ?
03:05:28 <ManateeLazyCat> jutaro: Manatee just can't work when you do M-f
03:05:46 <ManateeLazyCat> jutaro: You need open some extension to press M-f
03:05:58 <ManateeLazyCat> jutaro: YOu can press F5 and then press M-f
03:06:19 <Nibble> ManateeLazyCat: how are the keybindings in manatee?
03:06:21 <ManateeLazyCat> jutaro: If M-f can work in your XMOnad, i'm interested your XMOnad configuration file. :)
03:06:30 <ManateeLazyCat> Nibble: http://haskell.org/haskellwiki/Manatee
03:07:28 <Nibble> ManateeLazyCat: why can't it work in XMonad?
03:07:44 <ManateeLazyCat> Nibble: XMonad can't support floating window well.
03:07:55 <ManateeLazyCat> Nibble: I popup some window for search interface
03:08:04 <jutaro> ManateeLazyCat: I can e.g. search for an url, and the open the browser pane
03:08:29 <ManateeLazyCat> jutaro: Can you try some pdf filepath?
03:08:54 <ManateeLazyCat> jutaro: If pdf viewer open, can you press key n or p to test in pdf viewer.
03:09:26 <ManateeLazyCat> jutaro: Type something in search interface and press M-m or Return to open it in Manatee extension
03:11:28 <Xilon> So this Manatee isn't for development, it's sort of an integrated desktop environment?
03:11:46 <Nibble> Xilon: indeed, if I understand it correctly
03:11:46 <ManateeLazyCat> Xilon: It's depend on you how to use it.
03:11:52 <jutaro> ManateeLazyCat: Pdf viewer works, but I can't see the keystrokes doing anythink
03:12:08 <ManateeLazyCat> jutaro: That's XMOnad 
03:12:17 <ManateeLazyCat> jutaro: XMonad focus wrong place.
03:12:21 <jutaro> ManateeLazyCat: Oh
03:12:45 <ManateeLazyCat> jutaro: You can mix Manatee with other program, then you can use keystroke in pdf viewer or any other extension
03:12:45 <jutaro> ManateeLazyCat: Never had problems with Lekash and Xmoand
03:13:05 <ManateeLazyCat> jutaro: Manatee use special framework
03:13:25 <Nibble> hmm
03:13:38 <Nibble> shouldn't one be able to just run manateewithout a window manager
03:13:40 <ManateeLazyCat> Maybe i can tell my US friend help me build a YouTube HD video.
03:13:46 <ManateeLazyCat> Nibble: Yes.
03:13:53 <Nibble> ManateeLazyCat: that is a nice idea
03:13:56 <ManateeLazyCat> Nibble: If all you need Manatee have implement
03:13:56 <jutaro> ManateeLazyCat: Bye for now, I have to do something. If you  have ideas about Haskell IDE talk to me. 
03:14:07 <ManateeLazyCat> jutaro: I want works with Leksah
03:14:19 <ManateeLazyCat> jutaro: Maybe we can work together on low-level library
03:14:29 <ManateeLazyCat> jutaro: Since Leksah and Manatee both use gtk2hs
03:14:36 <jutaro> ManateeLazyCat: Ah, that would be great
03:15:02 <jutaro> ManateeLazyCat: Let us talk later
03:15:10 <ManateeLazyCat> jutaro: Ok, see you.
03:15:49 <ManateeLazyCat> Nibble: In design, Manatee just need linux kernel and GTK+ library
03:16:03 <ManateeLazyCat> Nibble: If GTK+ use other backend, Manatee even don't need X11
03:16:05 <Nibble> ManateeLazyCat: how would I go ahead cloning all your source from patch-tag for manatee
03:16:47 <ManateeLazyCat> Nibble: Download https://patch-tag.com/r/AndyStewart/manatee/snapshot/current/content/pretty/repos.sh and do "./repos.sh get"
03:17:07 <ManateeLazyCat> Nibble: Maybe i need write this in HaskellWiki.
03:18:00 <Nibble> darcs failed:  Not a repository: http://patch-tag.com/r/AndyStewart/manatee-cor
03:18:41 <ManateeLazyCat> Nibble: I have test, can work.
03:18:47 <ManateeLazyCat> Nibble: Should be manatee-core
03:18:48 <Its_a_trap> what is a closure?
03:19:03 <Nibble> ManateeLazyCat: it is, I just fail pasted
03:19:18 <Nibble> turns out I need to run it as super-user
03:19:18 <Nibble> wth
03:19:33 <ManateeLazyCat> Nibble: You need give that script permission first.
03:19:53 <Nibble> why does it need super-user
03:20:07 <Xilon> @wiki closure
03:20:07 <lambdabot> http://www.haskell.org/haskellwiki/closure
03:20:35 <ManateeLazyCat> Nibble: It don't, it need *execute* permission
03:20:41 <Its_a_trap> ahh cheers mate!
03:20:51 <ManateeLazyCat> Nibble: sudo chmod +x ./repos.sh
03:20:51 <Nibble> ManateeLazyCat: I have chmod +x it
03:20:56 <ManateeLazyCat> Nibble: Can't work?
03:21:06 <Nibble> ManateeLazyCat: it works well, when I run it with sudo
03:21:21 <Nibble> or wait
03:21:23 <Nibble> it didn't
03:21:36 <Nibble> or wait
03:21:38 <Nibble> it did
03:21:54 <Nibble> apparently it put all the repos in /home
03:22:20 <ManateeLazyCat> Nibble: It's pull all code in *parent* directory of ./repos.sh
03:22:32 <ManateeLazyCat> Nibble: ./repos.sh is part of package 'manatee'.
03:22:35 <Nibble> oh
03:22:55 <ManateeLazyCat> Nibble: All 'manatee' packages under same directory
03:23:13 <Xilon> that's a lot of packages
03:23:15 <ManateeLazyCat> Nibble: Then i can do command with those packages batch.
03:23:24 <ManateeLazyCat> Xilon: Not so much. :)
03:23:49 <Nibble> also, white man dumb. http://existenz.se/out.php?id=29230
03:23:50 <ManateeLazyCat> Xilon: I plan build thousand extension for Manatee. :)
03:24:43 <Xilon> ManateeLazyCat: What's the advantage of doing this over just using standalone apps?
03:25:04 <Nibble> Xilon: it is written in haskell
03:25:05 <Nibble> sandboxed
03:25:11 <Nibble> it is coor
03:25:17 <ManateeLazyCat> Xilon: Manatee is framework, you can use mix any extension in it.
03:25:38 <ManateeLazyCat> Xilon: What's Manatee depend on how do mix those extension.
03:25:53 <ManateeLazyCat> Xilon: You can use as browser, editor, file-manager, or all of those. :)
03:26:23 <ManateeLazyCat> Xilon: Manatee provide framework mix those extension together, and use sandbox protected core won't crash by extension bad code.
03:26:24 <Xilon> From an end-user point of view, why would I want to, rather than using a browser, editor, etc separately?
03:26:35 <ManateeLazyCat> Xilon: For "work efficient"
03:26:39 <Nibble> Xilon: it is integrated
03:26:45 <Nibble> think emacs
03:26:52 <ManateeLazyCat> Nibble: Yes, for emacsers
03:26:58 <erlnoob> hey guys, I'm using haskell platform for mac, how do I update to the latest version? do I just download and install or..?
03:27:01 <ManateeLazyCat> Nibble: Do thing that emacs can't do
03:27:31 <ManateeLazyCat> erlnoob: I recommend you wait next version haskell platform
03:27:48 <ManateeLazyCat> erlnoob: Or you can use "cabal update && cabal install foo" to update package 'foo'
03:28:59 <osaunders> ManateeLazyCat: s/install/upgrade/ ?
03:29:16 <ManateeLazyCat> osaunders: Don't use upgrade command.
03:29:27 <ManateeLazyCat> osaunders: It just thing become worse.
03:29:31 <lars9_> how to generate a list, in which l[n] = sum l[0] to l[n-1] ?
03:29:45 <ManateeLazyCat> osaunders: If you found new version on hackage, "cabal install" update to new version.
03:29:49 <Xilon> cabal upgrade doesn't do anything but print a list of packages that should be upgraded
03:30:00 <osaunders> ManateeLazyCat: OK
03:30:07 <erlnoob> ManateeLazyCat: my ghc is version 6.12.1 and it was installed using haskell platform, how do I update ghc to 7.0.1?
03:30:21 <osaunders> erlnoob: You don't want to
03:30:27 <erlnoob> or do I just wait for new version of haskell platform?
03:30:30 <ManateeLazyCat> erlnoob: Haven't new haskell platform for ghc-7
03:30:30 <osaunders> GHC 7 is for package developers
03:30:32 <Xilon> lars9_: sum . take?
03:30:33 <ManateeLazyCat> erlnoob: Yes.
03:30:48 <ManateeLazyCat> erlnoob: Not all packages has update to ghc-7
03:31:05 <osaunders> erlnoob: Unless you're developing packages for other people you just want to follow along with the latest Haskell Platform.
03:31:08 <ManateeLazyCat> erlnoob: If you update to ghc-7 now, it's perhaps break some package.
03:31:13 <Xilon> > sum . take 5 $ [1..]
03:31:14 <lambdabot>   15
03:31:20 <Cin> > map sum $ inits [1..10]
03:31:22 <lambdabot>   [0,1,3,6,10,15,21,28,36,45,55]
03:31:42 <Cin> Not quite the same.
03:32:04 <osaunders> Xilon: is that special syntax lars9_ used not significant for something.
03:32:17 <ManateeLazyCat> BTW, don't install Manatee on ghc-7, i just report high bug in ghc-7
03:32:56 <erlnoob> osaunders and ManateeLazyCat: ok but when the time comes, how do I update the latest haskell platform? download, open the .dmg, and install away or ..?
03:33:13 <Xilon> osaunders: not sure
03:33:53 <ManateeLazyCat> erlnoob: I guess need download new HP for new install
03:34:14 <osaunders> erlnoob: Well you can upgrade any packages with «cabal install» as mentioned. As for GHC, I'm not sure. I think you can DL a new version of GHC without affecting installed packages.
03:34:37 <osaunders> If you come up with a definitive answer, let me know.
03:35:26 <Zao> ManateeLazyCat: Which bug number?
03:35:50 <ManateeLazyCat> http://hackage.haskell.org/trac/ghc/ticket/4534
03:36:16 <ManateeLazyCat> Zao: ^^^^^
03:36:23 <Nibble> What is the problem with ghc 7 btw
03:36:32 <Nibble> oh wait
03:36:33 <Nibble> nvm
03:36:38 <ManateeLazyCat> Nibble: Because ghc-7 use base-5
03:36:38 <Nibble> I just saw that link, lol
03:36:47 <ManateeLazyCat> Nibble: Many packages haven't update cabal
03:37:01 <ManateeLazyCat> Nibble: So some package can't fix depend problem if you use ghc-7
03:37:06 <Nibble> :/
03:37:27 <ManateeLazyCat> Nibble: My friend Jens has rebuilding most packages for ghc-7.0.1 for fedora 15
03:37:39 <Nibble> ok
03:37:49 <ManateeLazyCat> Nibble: But i suggest wait next Haskell platform though ghc-7 looks so great
03:37:49 <Nibble> ManateeLazyCat: you use fedora?
03:37:57 <ManateeLazyCat> Nibble: I use Debian/Ubuntu
03:38:23 <ManateeLazyCat> Nibble: Ubuntu have more user test, less bug. :)
03:38:43 <Nibble> ManateeLazyCat: I use arch, the best!
03:38:45 <Nibble> also, bbiab
03:39:48 <Nibble> back
03:40:21 <Nibble> ManateeLazyCat: do you use manatee for browsing, irc, writing code etc?
03:40:41 <ManateeLazyCat> Nibble: I use it for irc 
03:40:52 <ManateeLazyCat> Nibble: Manatee editor still in developing
03:41:25 <ManateeLazyCat> Nibble: And most feature i use everyday is RSS/Atom reader
03:41:35 <ManateeLazyCat> Nibble: Press F3 in Manatee. :)
03:41:42 <Nibble> I am still compiling
03:42:20 <ManateeLazyCat> Nibble: I suggest you install gold-linker instead ld to link program
03:42:31 <lars9_> > iterate ((:) . sum) [1]
03:42:33 <lambdabot>   Couldn't match expected type `[a] -> [a]'
03:42:33 <lambdabot>         against inferred type `[a...
03:42:34 <ManateeLazyCat> Nibble: I have test, save 3 minutes after replace by gold-linker
03:42:49 <lars9_> > iterate ((:) . sum . head) [[1]]
03:42:50 <lambdabot>   Couldn't match expected type `[a] -> [a]'
03:42:50 <lambdabot>         against inferred type `[a...
03:43:23 <Nibble> it is taking forever to preprocess library gtk
03:43:48 <lars9_> > iterate (\l -> (sum $ head l):l) [[1]]
03:43:50 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
03:44:14 * ManateeLazyCat Create new HD video.....
03:45:30 <Cin> ManateeLazyCat: Great work on Manatee!
03:45:40 <ManateeLazyCat> Cin: Thanks. :)
03:45:50 <ManateeLazyCat> Cin: Have you install it successful?
03:46:58 * Cin runs cabal install manatee
03:47:14 <Cin> You nervous?
03:47:16 <ManateeLazyCat> Hmm, my video file is too big 700MB and too long (35minutes), have anyone want to help me create less version then upload to YouTube.com ?
03:47:28 <ManateeLazyCat> @package manatee
03:47:28 <lambdabot> http://hackage.haskell.org/package/manatee
03:47:28 <Cin> What format did you use?
03:47:36 <ManateeLazyCat> Cin: Looks http://hackage.haskell.org/package/manatee first
03:47:48 <ManateeLazyCat> Cin: Otherwise you perhaps install failed.
03:47:56 <ManateeLazyCat> Cin: Format : avi
03:48:06 <Jafet> ghc7 has base 5?
03:48:12 * Jafet quietly kills tar -x
03:48:47 <ManateeLazyCat> Jafet: I think so.
03:49:20 <Jafet> avi isn't a video format, manatee, it's the container format
03:49:39 <Jafet> Your video format's probably mpeg-4, h.264 or something
03:49:53 <Jafet> (The second one is generally better)
03:49:55 <Zao> Jafet: Except you can't mux any of those into AVI, afair.
03:50:11 <Zao> (well, divx, but hey, that's not really mpeg-4)
03:50:45 * ManateeLazyCat Upload Manatee video to Network-Disk
03:51:30 <ManateeLazyCat> Nibble: You can try manatee-reader (F3)
03:51:39 <Jafet> divx isn't mpeg-4? Who knew
03:52:13 <Zao> Jafet: Not exactly current-gen.
03:55:38 <Phyx-> *yawn*
03:56:53 * Cin pokes Phyx- with an arrow
03:57:05 <Cin> ManateeLazyCat: I am still installing.
03:57:26 * Phyx- throws a monad at Cin 
03:57:52 <Cin> The `gold' linker sounds good. I spent a lot of time waiting for the linker.
03:58:11 * Cin apples bind to it and throws the result at Phyx-
04:01:51 * Phyx- does the unthinkable and updates his ghc
04:02:54 <Cin> Phyx- was bored and decided to update his GHC. Now he has two problems.
04:03:55 <Jafet> Try svn co gcc and make all && make check, your computer will be unusable for days
04:04:08 <Phyx-> Cin: i usually have more than 2 problems
04:04:39 <Phyx-> I have to be careful that it applies the patches correctly
04:05:07 <Cin> Jafet: Days? You were lucky. In my day we used to dream of waiting for days.
04:06:58 * Phyx- has some free time today and is working on VSH again
04:10:00 <Phyx-> hmm.. crash..
04:13:44 <Cin> Wo-howza! gold is 2 to 5 times faster than ld. Nice!
04:14:02 <ManateeLazyCat> Cin: Yes.
04:16:43 <Cin> ManateeLazyCat: How do I ensure that GHC is using gold and not ld?
04:17:40 <Jafet> Make gold ld?
04:17:51 <ManateeLazyCat> Cin: Which linux do you use?
04:17:57 <Cin> ManateeLazyCat: Ubuntu
04:18:06 <ManateeLazyCat> Cin: Just do "sudo aptitude install binutils-gold -y"
04:18:12 <Cin> ManateeLazyCat: That's all?
04:18:16 <ManateeLazyCat> yes
04:18:33 <Cin> Fantabulous.
04:19:01 <Cin> The manatee- packages are installing fine.
04:19:32 <Cin> Done!
04:20:02 <lars9_> @instances Foldable
04:20:03 <lambdabot> Couldn't find class `Foldable'. Try @instances-importing
04:20:19 <lars9_> @instances-importing Data.Foldable Foldable
04:20:20 <lambdabot> Maybe, []
04:21:39 <ManateeLazyCat> Cin: Unfortunately, Manatee video on tudou.com is not clear.
04:21:55 <ManateeLazyCat> Cin: I will create new shoter (in 15minutes) to upload to YouTube.com
04:23:10 <ManateeLazyCat> Cin: Startup manatee, 
04:23:17 <ManateeLazyCat> Cin: Type something, like url or filepath
04:23:29 <ManateeLazyCat> Then press M-m or Return
04:24:02 <ManateeLazyCat> Type url will open in browser, type pdf filepath will open in pdf-viewer, type music filepath will open in multimedia-player ...etc.
04:24:16 <Cin> Ahh, it's meant to be integrated. I see.
04:24:56 <ManateeLazyCat> Cin: Here is video http://www.tudou.com/programs/view/nZrYy3CR5Ho/ , but compress by server.
04:25:54 <ManateeLazyCat> After mail-client twitter-client finish, i will build new plugins to search name to send mail or twitter.
04:26:13 <ManateeLazyCat> The idea is search you think, then do it.
04:26:25 * ManateeLazyCat If that video is clear, i don't talk those..... :(
04:27:04 <Cin> Don't worry, I'm sure your spoken English is like the queen's.
04:27:26 <ManateeLazyCat> Cin: No, my spoken English is very bad,
04:27:56 <ManateeLazyCat> Cin: I'm afraid you will consider i'm come from Mars....
04:28:37 <Cin> ManateeLazyCat: You don't? :-P
04:29:08 <ManateeLazyCat> Cin: I'm Chinese, my spoken English is bad, not kidding.
04:29:17 <Cin> I know. ;-)
04:29:33 <ManateeLazyCat> Cin: You can press F7
04:29:48 <ManateeLazyCat> Cin: Then irc.freenode.net 6667 #haskell Cin
04:30:01 <ManateeLazyCat> Cin: Use manatee login #haskell :)
04:30:17 <ManateeLazyCat> Cin: And you can press F3 to watch RSS/Atom news.
04:30:55 <ManateeLazyCat> Cin: After you open many extension, you can press M-t and M-9 to mix those extension, M-n and M-p to switch window.
04:33:09 <ManateeLazyCat> Cin: In manatee ?
04:33:27 <Cin> No. I was in manatee, but I was unable to register to nickserv.
04:33:38 <ManateeLazyCat> Cin: Try other nick.
04:33:53 <ManateeLazyCat> Cin: Something, CinNew. :)
04:34:22 <ManateeLazyCat> Or you can close #haskell tab and press F6 
04:34:31 <ManateeLazyCat> Then you can login as default nick (ManateeUser)
04:35:03 <Cin> How do I send private messages?
04:35:13 <ManateeLazyCat> Cin: Can't now. 
04:35:17 <ManateeLazyCat> Cin: In my TODO list. :)
04:35:27 <Cin> I will try it when I can register to nickserv.
04:35:57 <ManateeLazyCat> Cin: You can try temporary nick 
04:36:13 <Cin> Manatee is pretty cool.
04:36:43 <ManateeLazyCat> Cin: It's multi-processes framework, any extension running in separate sandbox.
04:36:53 <ManateeLazyCat> Cin: So don't worry speed and safe problem
04:37:07 <Cin> ManateeLazyCat: Unless Manatee crashes? ;-)
04:37:09 <Phyx-> import .. as .. does that import it as bothe qualified and normal? I forget
04:37:15 <ManateeLazyCat> Cin: Core always safe protected in daemon process
04:37:25 <Cin> Phyx-: Both.
04:37:43 <ManateeLazyCat> Cin: When you play in browser or other extension, they're in different processes with core.
04:37:52 <Phyx-> Cin: ty
04:38:04 <Cin> Phyx-: Well, technically it's the same as "import ..." but adds an alias too.
04:38:05 <ManateeLazyCat> Cin: Include search plugins is running separate process.
04:38:35 <Cin> Phyx-: (I mean, I don't *think* it's the same as qualified.)
04:39:26 <Cin> ManateeLazyCat: When you asked me to search a URL, I typed a URL and there was a segmentation fault and Manatee closed. Presumably that's the fault of Gtk+ or another C library.
04:40:05 <ManateeLazyCat> Cin: Do you use newest gtk2hs?
04:41:16 <Cin> ManateeLazyCat: I followed the instructions on the manatee package. I ran cabal update, so it should be the latest. I can't find a single gtk2hs package on Hackage to check.
04:42:08 <ManateeLazyCat> Cin: Hmmm, is Manatee crash or just manatee-anything plugins crash (manatee-anything use for search interface)
04:42:10 <ManateeLazyCat> ?
04:42:11 <Cin> ManateeLazyCat: I'm unable to reproduce the problem. I typed "url" and then hit backspace to delete it.
04:42:27 <ManateeLazyCat> Cin: Work now?
04:42:46 <Cin> ManateeLazyCat: Yes, it works.
04:42:46 <ManateeLazyCat> Cin: If you use newest gtk2hs, manatee-core shouldn't crash.
04:43:25 <ManateeLazyCat> Cin: So you last problem is manatee crash complete or just nothing show in search interface?
04:43:42 <ManateeLazyCat> Cin: Try M-t
04:43:48 <ManateeLazyCat> Cin: And M-n or M-p
04:44:05 <ManateeLazyCat> Cin: M-t and M-T for split current window.
04:44:19 <Cin> Ah, I managed to reproduce it.
04:45:17 <Cin> cin@cin:~$ manatee
04:45:17 <Cin> Anyting process (30164) startup.
04:45:17 <Cin> Segmentation fault
04:45:17 <Cin> cin@cin:~$ Anything plug disconnect from daemon process, exit process (30164).
04:47:01 <Cin> ManateeLazyCat: There are some GObject assertion failures. My original problem was If you hit a key and hold it down. Example, type a word, then delete it by holding backspace.
04:47:38 <ManateeLazyCat> Cin: So just search pluglins can't work, but manatee still running?
04:47:39 <Cin> http://hpaste.org/41846/manatee
04:47:55 <Cin> Sometimes the search fails and Manatee remains open, sometimes Manatee closes too.
04:47:57 <byorgey> @tell roconnor I guess I'd rather be able to easily google it.  Adding words to my private spell checker dictionary is easy. =)
04:47:57 <lambdabot> Consider it noted.
04:48:30 <ManateeLazyCat> Cin: It's looks like gtk2hs bug.
04:48:45 <Cin> ManateeLazyCat: Can you reproduce it?
04:49:04 <ManateeLazyCat> Cin: NO.
04:49:24 <Cin> ManateeLazyCat: Hit `m' and hold it for about 20 m's, then hit backspace and hold it.
04:49:32 <Cin> This time I got: (manatee-anything:30828): Gtk-CRITICAL **: gtk_box_pack: assertion `child->parent == NULL' failed
04:49:50 <ManateeLazyCat> Cin: Ok, i try.
04:50:19 <Phyx-> This is a long shot, but bear with me.. is it possible, to automatically lift an IO a to m a in the monad you're currently in? so that I don't have to type liftIO everytime?
04:50:40 <blueonyx> hi, what does http://hpaste.org/41847/ mean/how to fix it?
04:52:04 <Saizan> Phyx-: you could try by using a custom >>=
04:52:25 <Phyx-> would the type allow that?
04:52:37 <Phyx-> @hoogle (>>=) --info
04:52:38 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
04:52:38 <lambdabot>  
04:52:38 <lambdabot> From package base, version 4.0.0.0
04:52:50 <Saizan> the customization included changing the type :)
04:53:22 <Saizan> i'm not confident it'd work well anyhow
04:54:02 <Phyx-> Saizan: neither am i.. guess i'm stuck using liftIOs and convert as many other functions to the monad i'm in
04:54:33 <Saizan> you could implement support for coercive subtyping :)
04:54:38 <Phyx-> @where liftIO
04:54:38 <lambdabot> I know nothing about liftio.
04:54:46 <Phyx-> @index liftIO
04:54:47 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:54:49 <Cin> liftIO is in Control.Monad.Trans
04:55:49 <Phyx-> Saizan: lol
04:56:07 <ManateeAuthor> Cin: Sorry, emacs crash.
04:56:13 <ManateeAuthor> I use manatee-ircclient now.
04:56:42 <ManateeAuthor> I can reproduce this problem
04:57:50 <ManateeAuthor> Cin: Looks some gtk widget code crash when do extreme test like you did. :)
04:58:08 <Cin> ManateeAuthor: I only typed "url" and deleted it originally. :-P
04:58:30 <ManateeAuthor> Cin: So everything works fine if you don't do crazy hit like that? :)
04:59:17 <Phyx-> if you have a function, implemented with guards, is there a way to define something that's available in all the guards? besides making it a case statement or creating an inline function?
04:59:43 <osaunders> :t valid
04:59:43 <ManateeAuthor> Cin: I'm sure it's gtk2hs bug that double free pointer.
04:59:43 <lambdabot> Not in scope: `valid'
04:59:54 <osaunders> :t S.valid
04:59:55 <lambdabot> forall a. (Ord a) => S.Set a -> Bool
05:00:06 <osaunders> ^ What exactly is that for? ^
05:00:21 <osaunders> > S.valid $ S.fromList []
05:00:22 <lambdabot>   True
05:00:23 <osaunders> > S.valid $ S.fromList [1,2,3]
05:00:24 <lambdabot>   True
05:00:30 <ManateeAuthor> Cin: If manatee-anything crash, type M-g close it, and press M-f will start new process to run manatee-aything for search.
05:00:37 <osaunders> > S.valid $ S.fromList [1,1]
05:00:38 <lambdabot>   True
05:01:16 <ManateeAuthor> Cin: Thanks for your test, i haven't test this problem before.
05:01:44 <ManateeAuthor> Cin: Can you use irc client correctly? 
05:01:53 <ManateeAuthor> Cin: I'm using it. :)
05:02:19 <ManateeAuthor> Cin: And use Manatee play music at the same time.
05:02:42 <osaunders> Phyx-: Use where
05:02:56 <osaunders> f x | y > 0 = True
05:02:56 <osaunders>     | otherwise = False
05:02:56 <osaunders>    where y = x + 1
05:04:43 <ManateeAuthor> I would also like a lot of stress testing.
05:05:02 <ManateeAuthor> not bad.
05:05:04 <Phyx-> osaunders: I confused the scoping on that and mutiple bindings for the function. ty
05:05:15 * Phyx- is forgetting his haskell basics!
05:05:22 * Phyx- bows head in shame
05:05:51 <ray> quick, @pl f a b = b a
05:06:22 * osaunders lifts Phyx-'s head to normal position.
05:06:43 <osaunders> @pl f a b = b a
05:06:43 <lambdabot> f = flip id
05:06:44 <ray> wrong normal position
05:06:50 <ray> now it is inside his torso
05:07:07 <osaunders> Damn
05:07:20 <Phyx-> @hoogle bracket
05:07:20 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:07:21 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:07:21 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
05:07:31 <ray> @unicode brakcet
05:07:32 <lambdabot> Unknown command, try @list
05:07:36 <Jafet> Head-lifting isn't confluent?
05:07:59 <Phyx-> @hoogle IO a -> m a
05:08:00 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
05:08:00 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
05:08:00 <lambdabot> Network withSocketsDo :: IO a -> IO a
05:08:08 <Phyx-> err
05:08:09 <Phyx-> duuh
05:08:21 <Phyx-> @hoogle m a -> IO a
05:08:22 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
05:08:22 <lambdabot> Network withSocketsDo :: IO a -> IO a
05:08:22 <lambdabot> Control.Exception block :: IO a -> IO a
05:08:45 <byorgey> Phyx-: what are you looking for?
05:10:03 <Phyx-> byorgey: i'm converting a bunch of IO a functions to a Cabal a, occasionally i have an IO action, which i just do liftIO on, but then sometimes in the IO a i have another Cabal a function
05:11:36 <byorgey> what do you mean you "have another Cabal a" ?
05:11:46 <byorgey> you mean you return one as a result?  or you want to run one?
05:12:10 <byorgey> in the latter case, you can't.  Just make everything of type Cabal a.
05:12:18 <Phyx-> i would like to run one, but if i just do , runCabal.. the current session is lost
05:12:58 <byorgey> you can only run Cabal actions from inside other Cabal actions, not from inside IO actions
05:13:05 <Phyx-> byorgey: i know, but it's inside Exception.bracket. i can't make it another type.. hmm i could just do a liftIO on whatever i pass to bracket
05:13:27 <Phyx-> that should work..
05:14:29 <byorgey> hmm, I see, that's annoying.
05:15:43 <Phyx-> well, these Util functions are the only one with such constructions, i *hope* if not I might need to consider another approach
05:16:28 <byorgey> Phyx-: what's the type of runCabal ?
05:16:31 <Cin> Perhaps if Cabal provided a function like:
05:16:31 <Cin> liftAndLower :: MonadIO m => ((Cabal a -> m a) -> m a) -> Cabal a
05:16:31 <Cin> Then you could write:
05:16:31 <Cin> liftAndLower $ \runCabal -> bracket (runCabal $ ...) (runCabal $ ...) (runCabal $ ...)
05:16:34 <Cin> Imho many instances of MonadIO could provide such a function.
05:17:17 <Phyx-> byorgey: it's simply runCabal :: Cabal a -> IO a
05:17:27 <byorgey> oh, ok.
05:17:29 <Cin> (Where the provided `runCabal' just continues instead of starting from scratch.)
05:18:25 <Jafet> By "2-stage build", does that mean ghc compiles itself again?
05:18:50 <dcoutts_> Jafet: yes
05:18:59 <Jafet> Thanks. And cool.
05:19:22 <Phyx-> Cin: hmm
05:19:30 <dcoutts_> Jafet: it means the version you install and use has been built by the same version
05:20:03 <dcoutts_> Jafet: the stage-1 gets built using your existing system ghc which may be older, so some features are turned off in stage 1, like ghci and template haskell
05:20:05 <Jafet> Yeah, I get it.
05:20:15 * ManateeLazyCat Found some GIO bug that cause double free.
05:20:53 <Cin> Phyx-: Doesn't Cabal provide its own catch function? The CGI monad does. I suppose there's no other case in which you'd need liftAndLower than catching. You could use it for using forkIO but most monads are not forkable...
05:20:57 <Cin> ManateeLazyCat: Oh, nice. :-)
05:20:59 <ManateeLazyCat> Cin: I know why, i will fix in GIO< then manatee-anything won't failed. Thanks report
05:21:08 <Cin> ManateeLazyCat: Cool!
05:21:35 <ManateeLazyCat> Cin: This GIO bug exist in newest version that some new patch free pointer wrong times.
05:22:09 <Cin> Naughty.
05:22:34 <ManateeLazyCat> Cin: Press F3 in Manatee, you will like it. :)
05:22:56 * Cin likes it
05:23:45 <Mitar> ;-)
05:24:21 <Phyx-> Cin: since it's using IO a, there was no need to, afaik
05:27:04 <mpiechotka> @pl \f a b c -> f c a b
05:27:04 <lambdabot> (flip .) . flip
05:27:40 <mpiechotka> @pl \a b c -> f c a b
05:27:40 <lambdabot> flip . flip f
05:28:56 <ManateeLazyCat> Cin: Type pdf filepath and Return
05:29:06 <ManateeLazyCat> M-f pdf filepath Return
05:30:33 <mpiechotka> @pl \a b c -> Call b c a
05:30:33 <lambdabot> flip (flip . Call)
05:33:29 <Phyx-> boy, cabal sure is big
05:42:55 * hackagebot Biobase 0.1.0.0 - Base library for bioinformatics  http://hackage.haskell.org/package/Biobase-0.1.0.0 (ChristianHoener)
05:44:49 <Phyx-> @hoogle onException
05:44:49 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
05:44:49 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
05:45:13 <Phyx-> :t onException
05:45:14 <lambdabot> Not in scope: `onException'
05:45:22 <Phyx-> :t on
05:45:23 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:45:31 <Phyx-> :t ap
05:45:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
05:46:03 <Phyx-> @pl "\a b -> f a `x` f b"
05:46:03 <lambdabot> "\a b -> f a `x` f b"
05:46:23 <Phyx-> @pl "\a b -> f a + f b"
05:46:24 <lambdabot> "\a b -> f a + f b"
05:46:38 <Botje> without the quotes :)
05:46:43 <Botje> @pl \a b -> f a + f b
05:46:44 <lambdabot> (. f) . (+) . f
05:46:46 <opqdonut> @unpl on
05:46:47 <lambdabot> on
05:46:50 <Phyx-> @pl \a b -> f a `x` f b
05:46:50 <lambdabot> (. f) . x . f
05:47:09 <Phyx-> Botje: lol, i'm used to using the cmdline version :)
05:47:10 <Phyx-> ty
05:50:06 <Botje> Phyx-: and it's f `on` x
05:50:17 <Botje> pl doesn't know about on, apparently
05:50:26 <Phyx-> ah
05:50:27 <Botje> err
05:50:33 <Phyx-> i knew there was a version
05:50:34 <Botje> no, it's x `on` f :p
05:59:10 <stumpty> im learning me a HASKELL!
05:59:19 <byorgey> =D
05:59:24 <stumpty> i never liked functional programming before learning about haskell
05:59:36 <stumpty> but to be fair the professor i had who introduced me to it (using scheme)
05:59:42 <stumpty> was a very poor professor
05:59:57 <byorgey> that does tend to put a damper on things
06:00:00 <stumpty> or at least i didn't find his teaching method very effective
06:00:09 <stumpty> that, and i couldn't understand him half the time
06:00:21 <stumpty> so scheme just looked like a bunch of parenthesis 
06:00:36 <stumpty> he also had a lisp. which made him talking about "lisp" rather funny
06:00:40 <byorgey> hahaha
06:01:03 <Botje> heh
06:01:06 <Axman6> lave you a lisp for great lolz
06:01:09 <Axman6> have*
06:02:23 <stumpty> that was the only course i got a C in while getting my degree
06:02:24 <stumpty> :/
06:03:53 <byorgey> "You do not theem to care about Thcheme and Lithp.  You get a Thee."
06:08:46 <byorgey> stumpty: well, welcome, we're glad you decided to give FP another chance. =)
06:09:02 <byorgey> stumpty: feel free to ask lots of questions in here as you're learning.
06:11:37 <iago> stumpty, well, that's your fault
06:11:59 <iago> some people reject what they don't understand
06:12:09 <Phyx-> that's not nice
06:12:17 <iago> instead of try to understand before reject
06:12:30 <geheimdienst> i agree, that's less than civil
06:15:32 <stumpty> well this guys method of explaining things just didn't work
06:16:04 <stumpty> and its not like i have free time during the school year to study things on my own
06:16:09 <stumpty> my time is packed
06:16:18 <stumpty> now that ive graduated i can finally go back and learn things on my own
06:18:29 <iago> stumpty, anyway, you should know LISP syntax is not bad
06:18:42 <stumpty> i never said it was
06:18:58 <iago> just to clarify
06:22:21 <sajkr> @pl (\f c -> (\a b -> f a b c))
06:22:21 <lambdabot> flip . (flip .)
06:22:56 <Phyx-> more ofthen than not, pl code is just plain ugly
06:28:47 <PaulAJ> Hi, I've got a problem with my GHC on Fedora 14.  
06:29:21 <PaulAJ> When I do "ghc-pkg list" I don't have a "ghc" package.   Various packages complain when I do "cabal install foo"
06:29:38 <PaulAJ> Has anyone else seen this?
06:29:45 <dcoutts_> that's bad
06:30:11 <dcoutts_> PaulAJ: if reinstalling the fedora package does not fix it, report the bug to the fedora packaging people
06:30:14 <PaulAJ> Hi Duncan, its Paul from one of your clients here.
06:30:16 <Phyx-> wow, how'd that happen
06:30:32 <dcoutts_> PaulAJ: hi :-)
06:31:05 <PaulAJ> OK, I'll give it a try.  Its nice to know where the bug is; at first I thought it was a Leksah problem.
06:31:10 <Phyx-> hmm i'm pretty sure ghc is screwing with me...
06:31:46 <Phyx-> ah, saving the file helps..
06:31:48 <dcoutts_> PaulAJ: if it is listed, but marked as broken, then that's a different problem
06:32:37 <lars9> how to do backtrace when doing depth first search?
06:32:42 <lars9> in a graph.
06:33:11 <lars9> what monad should we use? a State is needed to store visited nodes
06:33:14 <geheimdienst> what's it mean when ghc-pkg prints a package in parens? the "ghc" package i have installed is in parens
06:33:19 <PaulAJ> dcoutts_: how would I know?
06:33:28 <Phyx-> geheimdienst: it's hidden
06:33:38 <dcoutts_> PaulAJ: ghc-pkg list will show broken packages with '{}' iirc
06:33:59 <geheimdienst> how strange
06:34:04 <Phyx-> geheimdienst: the ghc package by default is always hidden
06:34:08 <dcoutts_> PaulAJ: and ghc-pkg check will complain about missing dependencies
06:34:19 <geheimdienst> oic. thanks
06:34:27 <byorgey> lars9: don't just store visited nodes, also store a stack of nodes along the current path from the root
06:35:21 <Phyx-> you can control that with ghc-pkg expose/hide . or if you're using cabal you don't need to worry along as you mention it in the .cabal. if you want to play around with it in ghci you need to expose it
06:35:28 <PaulAJ> dcoutts_: no, its just not showing up at all, and ghc-pkg check is silent.  Looks like it got missed from the build.  I'll try reinstalling, and submit a bug if that doesn't fix it.
06:36:14 <dcoutts_> PaulAJ: you reinstalled the fedora ghc package? then definitely a fedora bug
06:36:50 <Phyx-> how did that bug come about i wonder
06:36:57 <Phyx-> the ghc package is needed to build ghc
06:37:35 <dcoutts_> Phyx-: it's not
06:38:05 <Phyx-> dcoutts_: huh? it's not?
06:38:13 * hackagebot mvclient 0.3 - Client library for metaverse systems like Second Life  http://hackage.haskell.org/package/mvclient-0.3 (ChrisSmith)
06:39:00 <dcoutts_> Phyx-: obviously the same code is used when building the ghc binaries, but if the package were not registered or installed then everything else would still work
06:40:33 <PaulAJ> yum install ghc now completed.  ghc package still not there.  I'm off to submit a bug.  Thanks for the help.
06:40:38 <Phyx-> oh, ghc-prim is in a package by itself.. thought it was in ghc
06:40:55 <ManateeAuthor> Hello, everyone. :)
06:45:21 <Phyx-> hi
06:46:05 <ManateeAuthor> I have record new video, then upload to YouTube.com
06:46:27 <ManateeAuthor> Hope new video under 15 minutes limit.
06:49:19 <Phyx-> @pl getSession >>= \s e-> reflectCabal (f e) s
06:49:20 <lambdabot> flip (reflectCabal . f) =<< getSession
06:49:34 <Phyx-> meh, like the first one better
06:51:08 <lars9> import qualified Data.Set as S; S.map ... the "S." looks really ugly
06:52:30 <ManateeLazyCat> How to convert .ogv file to H.264 ?
06:53:21 <Zao> ManateeLazyCat: H.264 is a format family, not a container.
06:53:30 <ManateeLazyCat> Zao: I mean .avi
06:53:39 <ManateeLazyCat> Zao: With H.264 format.
06:53:41 <Zao> ManateeLazyCat: You probably want to "demux" the OGV and "mux" it into a MP4 or MKV.
06:54:09 <Axman6> Zao: eh? h.264 isn't a format family, it's a codec
06:54:17 <Zao> Axman6: Well, yeah. That.
06:54:32 <ManateeLazyCat> Zao: I want create a YouTube.com video, but tool 'recordmydesktop' record video as .ogv file.
06:55:00 <Zao> Well, what containers do youtube support? And what format is in the OGV container?
06:55:05 <ManateeLazyCat> Zao: I use ffmpeg convert it, but looks my video is not standard that server compress my video
06:55:10 <ManateeLazyCat> Zao: .avi
06:55:15 <sipa> encoder 
06:55:17 <Zao> Just? That sounds unlikely.
06:55:26 <ManateeLazyCat> Zao: Let me check
06:55:40 <arcatan> isn't avi a container too?
06:55:45 <ManateeLazyCat> Zao: Or .mpg
06:55:48 <sipa> yes
06:56:03 <sipa> mencoder -ovc copy -oac copy file.ogv -o file.avi
06:56:07 <sipa> try that
06:56:11 <Zao> I'd be quite surprised if they didn't accept mp4, to be honest.
06:56:13 <ManateeLazyCat> Zao: Someone tell me use H.264 in .avi is better.
06:56:20 <sipa> yes
06:56:32 <ManateeLazyCat> sipa: Infact, i use "ffmpeg -sameq -i out.ogv out.avi"
06:56:32 <Zao> Assuming it's possible to mux h.264 in AVI, sure.
06:56:47 <sipa> it is
06:56:56 <Zao> I guess that the reservations about using AVI for it is because most H.264 content tends to break the size barriers of compliant AVI files.
06:57:08 <Zao> Translating in my head to a general "don't do it, stupid".
06:57:17 <ManateeLazyCat> sipa: I don't know is my command wrong or server side.
06:57:33 <Zao> Not to mention that it's supposedly hard to get decent sync with non-CBR audio in it.
06:57:42 <sipa> can you play the resulting avi?
06:57:49 <Zao> ManateeLazyCat: There should be tools to verify what codecs and container you have.
06:57:50 <ManateeLazyCat> sipa: Yes.
06:57:54 <Zao> gspot or mediainfo exist for Windows.
06:58:02 <ManateeLazyCat> Zao: Linux?
06:58:03 <Zao> Heaven knows what non-Windows tools there are.
06:58:10 <Zao> ManateeLazyCat: They probably run in Wine.
06:58:20 <Phyx-> gspot is awesome
06:58:24 <sipa> avidemux works fine
06:58:26 <ManateeLazyCat> sipa: Infact, i know how to convert, but i'm not sure inside is correct.
06:58:31 <Phyx-> auggestive name though
06:58:31 <Zao> Or if your platform has a decent 'file' command, it might reveal something.
06:58:42 <Phyx-> suggestive*
06:59:21 <ManateeLazyCat> sipa: My step like this: 1) recordmydesktop got .ogv file 2) Convert to .avi "ffmpeg -sameq -i out.ogv out.avi" 3) Edit .avi by avidemux.
06:59:44 <ManateeLazyCat> sipa: Perhaps my step is right, it's looks like server's problem.
07:00:20 <ManateeLazyCat> sipa: BTW, i found ffmpeg is much faster than mencoder.
07:01:08 <Nibble> ManateeLazyCat: of course it is, it is written by that french guy I think
07:01:31 <ManateeLazyCat> Nibble: So my step is right?
07:02:01 <Nibble> ManateeLazyCat: I have no clue
07:02:04 <Nibble> http://bellard.org/
07:03:05 <sipa> ManateeLazyCat: there's thousands of settings for both, and they use the same library for codecs
07:03:16 <sipa> the defaults may differ
07:03:26 <ManateeLazyCat> sipa: Oh, thanks help
07:03:45 <ManateeLazyCat> sipa: I will use those step edit my new video again, and try upload to YouTube.com
07:04:13 <Axman6> "...The TCCBOOT boot loader demonstrate the speed of TCC by compiling and launching a Linux kernel in less than 15 seconds."
07:04:16 <Axman6> o.O
07:04:21 <ManateeLazyCat> sipa: It's perhaps somewhere wrong if YouTube.com compress my video too.
07:04:28 <ManateeLazyCat> sipa: Thanks! :)
07:06:33 <ManateeLazyCat> sipa: Last question, if avidemux can play my HD video file (.avi) , YouTube.com shouldn't compress it and use same quality? 
07:07:01 <ManateeLazyCat> sipa: I found many video sites will compress your video to get low quality.
07:07:49 <luite> what's a good way to handle computations with a time limit, for example when using a foreign function for optimization or numeric integration (to some specified degree of accuracy). the computation itself is pure, but the dependency on real time isn't
07:08:50 <Axman6> sounds like it could be an appropriate place to use unsafePerformIO, and return a Maybe type
07:10:11 <luite> Axman6: yes that's what I've used now, but I consider that a bit ugly, since different calls to the same function, with the same data, could lead to different results
07:10:41 <luite> it's somewhat pure, since the result for non-error conditions are always the same, but not quite
07:11:53 <luite> (a more advanced implementation might return a continuation to resume the computation, but I only need timeout or non-timeout at the moment)
07:12:18 <Axman6> something like: killAfter n x = unsafePerformIO $ do {var <- newEmptyMVar; tid <- forkIO (putMVar var $! x); ... hmm, i can;t see a way to make it return faster if there is an answer before the timeout :(
07:12:42 <luite> oh there is some IO thing with timeouts for actions
07:13:27 <luite> but killing the computation isn't the point, in this case I call an FFI function with an explicit timeout
07:13:45 <luite> err, I mean, isn't the problem, in this case at least :)
07:14:14 <luite> the problem is purity
07:14:59 <ManateeLazyCat> sipa: avidemux just support h.263 not h.264
07:15:16 <luite> exceptions could be used, which can then be caught somewhere in IO, but that's not exactly pretty or intuitive...
07:17:10 <sipa> ManateeLazyCat: it supports h264 just fine :)
07:17:34 <sipa> ManateeLazyCat: and youtube will always recompress
07:17:58 <ManateeLazyCat> sipa: Recompress will lose video quality?
07:18:00 <sipa> yes
07:18:12 <ManateeLazyCat> sipa: Much?
07:18:30 <ManateeLazyCat> sipa: If video is not clear, my video is nothing
07:18:32 <sipa> for low quality a lot, for high quality not :)
07:18:43 <sipa> but don't worry
07:18:48 <ManateeLazyCat> sipa: Ok, thanks.
07:25:26 * hackagebot BiobaseInfernal 0.0.2.1 - (deprecated) Infernal CM manipulation  http://hackage.haskell.org/package/BiobaseInfernal-0.0.2.1 (ChristianHoener)
07:25:28 * hackagebot BiobaseTurner 0.0.2.2 - (deprecated) RNA folding data structures.  http://hackage.haskell.org/package/BiobaseTurner-0.0.2.2 (ChristianHoener)
07:25:30 * hackagebot BiobaseTypes 0.0.2.2 - (deprecated) Ring class, with several instances.  http://hackage.haskell.org/package/BiobaseTypes-0.0.2.2 (ChristianHoener)
07:25:32 * hackagebot BiobaseVienna 0.0.2.3 - (deprecated) ViennaRNA parameter library  http://hackage.haskell.org/package/BiobaseVienna-0.0.2.3 (ChristianHoener)
07:26:37 <ManateeLazyCat> For can upload video to YouTube.com, i won't add text describe like previous video (too long).
07:26:48 <ManateeLazyCat> I guess you guys should know what's i'm doing. :)
07:34:48 <lars9> in State Monad, what will the initial state be
07:34:50 <lars9> * ?
07:35:18 <Cale> lars9: Whatever you pass in to the runState function
07:35:22 <Cale> :t runState
07:35:23 <lambdabot> forall s a. State s a -> s -> (a, s)
07:36:02 <Cale> It takes a State s computation with result type a, an initial state of type s, and produces the the final result of type a, along with the final state of type s.
07:36:58 <lars9> i see
07:37:07 <lars9> runState
07:37:08 <lars9> thanks
07:40:30 <Xilon> If a module is in more than one package, how do I specify which package to use in ghci?
07:41:31 <Cale> I *think* you can just do  :set -package foo
07:42:51 <Xilon> Hmm, still complaining about it being ambigious
07:43:06 <Phyx-> @hoogle evaluate
07:43:07 <lambdabot> Control.Exception evaluate :: a -> IO a
07:43:07 <lambdabot> Control.OldException evaluate :: a -> IO a
07:43:07 <lambdabot> Test.QuickCheck evaluate :: Testable a => a -> Gen Result
07:43:22 <Cale> Xilon: Okay, one sec...
07:43:35 <Cale> Xilon: Wait, which packages are we talking about?
07:43:48 <Xilon> mtl and monads-fd
07:44:07 <Cale> Ah, from the commandline, do  ghc-pkg hide monads-fd
07:44:21 <Cale> and then you don't have to worry about it :)
07:44:39 <Cale> (it'll only use monads-fd when explicitly requested by packages then)
07:44:43 <Xilon> Yep that works. Thanks
07:53:32 <aindl> hello, i am trying to install hlint with cabal-install, but i have problem with happy: setup: happy version >=1.17 is required but it could not be found.
07:53:32 <aindl> I am installing happy manually with cabal install and it installed successfully. But cabal  can't see it. Executing ghc-pkg list | grep happy print nothing. I am using FreeBSD and ghc-6.10. Log:http://hpaste.org/41854/happy_problem
07:54:16 <byorgey> aindl: by default, cabal will install executables in ~/.cabal/bin
07:54:40 <byorgey> aindl: so you either need to add ~/.cabal/bin to your $PATH, or tell cabal to install executables somewhere else
07:54:51 <ManateeLazyCat> aindl: Add your ~/.cabal/bin in PATH env
07:55:01 <ManateeLazyCat> Damn erc (too slow)
07:55:04 <luite> Axman6: hmm, I was thinking of making a monad for time constrained computations, but I don't think it's possible since you need something like a NFData constraint for return
07:55:05 <byorgey> =)
07:55:25 <ManateeLazyCat> byorgey: Next use haskell irc client.
07:55:42 <ManateeLazyCat> :p
07:56:04 <byorgey> you can tell cabal to install executables somewhere else by editing ~/.cabal/config and putting the directory you want under 'prefix:' in the install-dirs user section
07:58:26 <aindl> i am add ~/.cabal/bin ti $PATH but it didnt work
07:58:52 <byorgey> aindl: when you type  echo $PATH  at the prompt, ~/.cabal/bin is listed there?
07:58:53 <Axman6> how did you add it?
07:59:23 <aindl> yep
08:00:28 <lars9> im working on DFS in graph using a State monad to store visited nodes. bfs :: (a -> [a]) -> (a -> Bool) -> State (Map a a, a) (Maybe a), where (a->[a]) calculates children of a node, (a->Bool) returns True if we found our target, (Maybe a) is the target node we found. Now in the do block, after get the children of current node, i need to visit each child, and return the 1st target we found. how to visit children and return 1st target we found?
08:01:52 <aindl> it works, i make typo when add cabal to path
08:02:08 <aindl> thanks all :)
08:02:35 <byorgey> aindl: great, glad you got it to work =)
08:02:55 <Cale> lars9: Er, wait, why Map a a for the set of visited nodes?
08:03:10 <Cale> lars9: Also, you need an Ord constraint
08:03:14 <lars9> here http://hpaste.org/41855/dfs
08:03:14 <Cale> (Why not Set a)
08:03:35 <byorgey> combination set of visited nodes and child-parent mapping, perhaps?
08:03:39 <Cale> Also, what's that extra a?
08:03:40 <byorgey> or parent-child
08:03:48 <Cale> Ah, hmm.
08:03:57 <Cale> okay
08:04:08 <lars9> Map k v, k is visited node, v is the previous node, for back tracing
08:04:15 <lars9> a is the next node to visit
08:04:21 <Cale> all right, yes, that makes sense
08:05:27 <lars9> i simplified a little bit when typing in irc just now. then i thought maybe just pasting code is better,
08:05:55 <Cale> This would be easier to write if the initial vertex was an explicit parameter
08:06:00 <dubhrosa> Any suggestions for where a haskell R serve client module should live? I was thinking of Network.Rclient but not sure if that would be agreeable.
08:06:19 <dubhrosa> (Rserve is a tcp/ip frontend to R)
08:07:11 <Cale> dubhrosa: That's probably fine
08:07:35 <Cale> Or even just Network.R or Network.R.Client
08:07:40 <lars9> i want to runState (dfs f p) (singleton v0 v0, v0)
08:07:57 <Cale> (It doesn't matter if Network.R itself exists to have Network.R.Client)
08:08:29 <Cale> lars9: You probably shouldn't use runState inside your State computation actions, or you're not getting any benefit from using the State monad.
08:08:54 <lars9> how can i finish that dfs function?
08:08:58 <Cale> lars9: You want to update the state with the new initial vertex, and the new map
08:08:59 <lars9> *complete
08:09:03 <dubhrosa> cool, I'll probably do that. I originally thought it might be better under Statistics, but only bos's statistics library lives there
08:09:05 <Cale> and then recurse
08:09:19 <dubhrosa> I guess I was thinking of the package heirarchy as being a global categorisation
08:09:22 <Cale> dubhrosa: You could put it there too if you want.
08:09:27 <Cale> dubhrosa: It's up to you :)
08:09:30 <lars9> how to recurse on a list of nodes? (that's ns)
08:09:39 * hackagebot blaze-builder-enumerator 0.1 - Use blaze-builder Builder's in an Iteratee.  http://hackage.haskell.org/package/blaze-builder-enumerator-0.1 (ThomasSutton)
08:09:52 <Cale> forM ns $ \n -> do ...
08:10:17 <Cale> (though maybe you don't want to use n there, it's just an example ;)
08:10:20 <Cale> n' perhaps
08:13:48 <lars9> can I use mapM and msum to do it?
08:16:44 <Cale> Is the point of this exercise to use the State monad or to write a depth first search? ;)
08:16:58 <Cale> I actually think this thing is a lot easier to write without the State monad in the way.
08:17:42 <Cale> mapM is the same thing as forM with the parameters flipped
08:17:48 <lars9> then what else is good for recording visited nodes?
08:17:54 <Cale> Function parameter
08:18:29 <Cale> That is, just make this thing have type   (a -> [a]) -> (a -> Bool) -> Map a a -> a -> Maybe [a]
08:19:03 <lars9> yeah
08:19:07 <Cale> er, hmm.
08:19:26 <Cale> I might be wrong about that.
08:19:52 <Cale> It might be best to put the Map a a in the state
08:20:01 <Cale> But pulling the 'a' out makes things easier regardless.
08:20:02 <lars9> as long as you can add visted part of children into map
08:20:47 <lars9> then how can we know which one should we visit next?
08:24:14 <Cale> lars9: Oh, another thing, what if the current vertex satisfies the goal condition?
08:25:02 <lars9> yeah, need to check
08:31:48 <Firegolfer> how can I 'typedef' something
08:32:00 <Firegolfer> I want to declare (a -> b) as a Type
08:32:12 <monochrom> type Type a b = a->b
08:32:52 <monochrom> or type Haha a b = a->b
08:33:34 <Firegolfer> that does not do what I want, I guess
08:33:40 <Firegolfer> like
08:33:52 <Firegolfer> let f :: (a -> b) -> (a -> b)
08:34:01 <Firegolfer> I want to write that as let f :: Type -> Type
08:34:16 <monochrom> f :: Typa a b -> Type a b
08:34:18 <rmitt__> has anyone successfully subscribed to the haskell mailing list?
08:34:36 <rmitt__> i tried twice, but the web page threw an error
08:34:46 <Firegolfer> or is there a #define?
08:34:56 <monochrom> no
08:34:58 <Firegolfer> because writing Type a b sucks
08:35:13 <monochrom> I agree to disagree.
08:37:47 <Axman6> Firegolfer: being able to write type Type = a -> b doesn't make any sense, a and b aren't bound
08:40:25 <Cale> lars9: Actually, here's a version which works, with explicit looping. http://hpaste.org/paste/41855/dfs#p41857
08:41:00 <mreh> rmitt__ googlemail?
08:41:44 <Cale> lars9: I'm sure I've written a prettier dfs than that before :)
08:43:59 <Cale> You can see how we don't really need the Map as a whole... but perhaps it's useful to you in other ways.
08:44:40 <byorgey> yay, monad comprehensions are coming back! =D
08:45:09 <alpounet> ref ?
08:45:13 <Cale> byorgey: Yeah, I heard :)
08:45:25 <byorgey> http://blog.n-sch.de/2010/11/27/fun-with-monad-comprehensions/
08:45:59 <Cale> I wonder if we can get back MonadZero :)
08:46:29 <monochrom> MonadZoro will bring back justice.
08:46:52 <FunctorSalad> is containers one of the packages you mustn't install another version of?
08:46:58 <Cale> FunctorSalad: yeah
08:47:34 <Cale> Well, "mustn't" is a bit strong
08:47:50 <FunctorSalad> maybe I should try to disable the constraint then to build darcs with ghc 7
08:47:51 <Cale> But it's probably best not to unless you have a really good reason to enter into dependency hell :)
08:48:02 <rmitt__> mreh: problem solved, thanks.
08:49:43 <Firegolfer>     Illegal polymorphic or qualified type:
08:49:44 <Firegolfer>       (Num a) => a -> (a -> a) -> a -> a
08:50:02 <Firegolfer> type Haha a = (Num a) => a -> (a -> a) -> (a -> a)
08:50:10 <dark> is there some library for this http://www.alsonkemp.com/programming/a-haml-parser-for-haskell/ ?
08:50:18 <monochrom> delete "(Num a) =>"
08:50:24 <Firegolfer> then
08:50:30 <Cale> Firegolfer: Ah, without extensions, you're not allowed to put class contexts in type synonyms.
08:50:35 <Firegolfer> Could not deduce (Num a) from the context ()
08:50:46 <monochrom> that's a separate problem
08:50:52 <dark> (also, do it support some looping structure, like with - syntax? or can it be made to support)
08:51:47 <monochrom> or rather, you have to fix the problem elsewhere
08:52:38 <dark> hmm i see hamlet
08:52:58 <Cale> Firegolfer: What are you trying to achieve?
08:53:12 <unkanon> I only faintly understand why nextToLast xs = last . init xs is wrong, can anyone help? (I know last $ init xs works)
08:53:13 <dark> it uses $ at the syntax
08:53:28 <Cale> Type synonyms are usually considered something to be used quite sparingly.
08:53:41 <Cale> If they're getting complicated enough, proper datatypes would be better.
08:53:45 <unkanon> I did last . init on paper and didn't see a problem
08:54:04 <Cale> unkanon: last . init is fine
08:54:10 <Cale> init xs is a list though
08:54:12 <Cale> Not a function
08:54:16 <dark> in haskell, what name.person syntax means? since there is no record / struct proper
08:54:20 <Cale> So you can't compose last with init xs
08:54:25 <dark> Name.person would be person from Name module
08:54:29 <Cale> dark: It means function composition
08:54:37 <Cale> (f . g) x = f (g x)
08:54:38 <monochrom> > (not . not) False
08:54:39 <lambdabot>   False
08:54:43 <dark> ok, so what is name.person at http://hackage.haskell.org/package/hamlet-0.2.0 ?
08:54:49 <dark> seemed to be embedded haskell code
08:54:51 <monochrom> > (f . g) a :: Expr
08:54:52 <lambdabot>   Ambiguous occurrence `f'
08:54:52 <lambdabot>  It could refer to either `L.f', defined at <local...
08:54:55 <unkanon> Cale: hmm, let me think
08:54:58 <Cale> dark: That's another language.
08:55:02 <Cale> dark: (not Haskell)
08:55:13 <monochrom> @undefine
08:55:21 <Cale> dark: It's been embedded into Haskell syntax using quasiquotation.
08:55:42 <unkanon> Cale: oh, so when I do last . init I'm tryingto compose the function last with the list returned by init?
08:55:44 <monochrom> I hate these local definitions people add and never clean up. Someone should write a bot to @undefine every 5 minutes.
08:55:47 <monochrom> > (f . g) a :: Expr
08:55:48 <lambdabot>   Ambiguous type variable `a' in the constraints:
08:55:48 <lambdabot>    `SimpleReflect.FromExpr ...
08:55:50 <dark> Cale, (but haml is supposed to embed code. like, the original haml embeds ruby; jade embeds javascript; haml-lua embeds lua)
08:55:55 <Cale> unkanon: last . init is fine
08:56:03 <Cale> unkanon: last . init xs means last . (init xs)
08:56:09 <Cale> which is a type error
08:56:14 <dark> > let a x = x+1 in let b x = x+2 in (a.b) 0
08:56:15 <lambdabot>   3
08:56:30 <Cale> unkanon: What you want is either  (last . init) xs  or  last . init $ xs
08:56:34 <unkanon> > (last . init) [1,2,3]
08:56:36 <lambdabot>   2
08:56:43 <unkanon> Cale: oh! got it :)
08:57:01 <unkanon> Cale: the precedence always bites me
08:57:05 <Cale> unkanon: The single most important rule of precedence in Haskell is that function application binds more tightly than any infix operator
08:57:31 <dark> so f x +@# y always means (f x) +@# y?
08:57:35 <Cale> yes
08:58:02 <unkanon> ok I will make a stronger effort to try and remember that :)
08:58:24 <Cale> It's usually okay to forget most of the other rules about precedence if you remember that one.
08:58:40 <unkanon> good, because I suck at remembering precedence
08:58:42 <Cale> It can also help to remember that $ binds as weakly as possible (which is sort of the point of it)
08:59:03 <byorgey> unkanon: you can always ask ghci about the precedence of an operator with :info
08:59:05 <Cale> So  ... $ ...  means (...) (...), essentially.
08:59:31 <unkanon> I look at $ as parentheses that start at $ and end at the end of the line
08:59:44 <Cale> (on both sides)
08:59:48 <Cale> f . g . h $ x
08:59:53 <Cale> Is a common idiom
09:00:07 <Cale> compose a bunch of functions, then apply them to a value
09:00:37 <unkanon> oh so $ creates two pairs of parentheses, I see
09:01:12 <Cale> It's nicer than writing   f $ g $ h $ x   because 1) it doesn't rely on $ being right associative, and 2) it has more textual subexpressions, that is, g . h is meaningful, while g $ h is not.
09:01:12 <sipa> no it doesn't, it just does function application like a space does, but with low precendence instead of high
09:01:33 <Cale> It doesn't *really* create parens
09:01:45 <unkanon> no I get it
09:01:51 <Cale> But it sort of has that effect, because of its low precedence.
09:01:52 <unkanon> $ means "apply function"
09:01:58 <sipa> but in simple/normal situation you can interpret it as creating parentheses
09:02:06 <monochrom> every operator creates two pairs of parentheses. x + y is always (x) + (y)
09:02:12 <unkanon> it is just the opposite of a space as far as precedence is concerned
09:02:30 <Cale> yeah
09:03:24 <Cale> dark: Well, some liberties have apparently been taken...
09:03:34 <Cale> dark: Though it *could* still mean composition...
09:03:48 <Cale> I don't really know this language, let me look :)
09:05:10 <Cale> dark: It looks like . just means plain function application
09:05:18 <Cale> dark: In that hamlet language
09:05:32 <Cale> Although, associated the wrong way...
09:05:45 <Cale> string.age.person appears to mean string (age person)
09:05:58 <Cale> I don't really know why.
09:06:59 <monochrom> RPN Smalltalk
09:09:01 <Cale> The problem with Yesod is that it's full of weird poorly-documented quasiquoter languages and lots of Template Haskell magic that does a lot of invisible variable binding, so it seems to take a lot of effort to understand (at least to me).
09:09:34 <Cale> Other than that, it looks pretty cool.
09:09:38 <Phyx-> odd.... why does a cabal clean continue a failed compilation
09:10:22 <dark> Cale, so name is.. a function?
09:10:30 <dark> hmm
09:10:59 <Cale> dark: As with any record type, the field names are functions for extracting those fields.
09:11:03 <monochrom> because Oleg added continuations to cabal :)
09:11:45 <dark> Cale, I thought haskell had no record type
09:12:06 <dark> I want to make a command line app to feed a database. I decided it will be written in haskell. I want to present this database with a web app. I could use ruby. But the web app can make the same operations the command-line app could do..
09:12:28 <Cale> dark: Well, it has no extensible polymorphic records, which is what we usually mean when we say 'record types', but it has record syntax for algebraic datatypes.
09:12:43 <dark> so I thought that I could write the web front-end in haskell too, and share code in form of a library
09:13:32 <Cale> dark: The only web applications I've done in Haskell have just been using the plain CGI library, which is easy enough for simple things.
09:13:43 <unkanon> with lambdabot, how do I define a function with @let at the same time as defining the type signature?
09:13:46 <Cale> (and some libraries for generating HTML)
09:13:59 <Cale> unkanon: put a semicolon in between
09:14:08 <Cale> @let foo :: Integer; foo = 6
09:14:09 <lambdabot>  Defined.
09:14:12 <Cale> :t foo
09:14:13 <lambdabot> Integer
09:14:16 <Cale> > foo
09:14:21 <lambdabot>   6
09:14:35 <dark> yes it is (I did some CGI things with OCaml and.. shell script), but I would like to use haml, I find it nice. (And it is spreading quickly through programming languages, it's not just for ruby)
09:15:34 <Cale> I still feel that we haven't exhausted the possibilities for embedding HTML-constructing combinators directly into Haskell.
09:15:42 <Cale> which is something that would be much nicer.
09:16:14 <Cale> There are some first-order HTML construction libraries, and a few interesting libraries surrounding forms (formlets)
09:17:55 <dark> btw, I don't actually want to embed haml in haskell. I want to have a file for each, or better, to have some mechanism like ruby's __END__ and @@something. (That is, I would not like to have haml syntax errors messing with _haskell_ syntax, or worse, type errors). So that's a downside for hamlet..
09:18:33 <unkanon> Cale: that's what I thought. How do I "reset" something I've already @let ? I won't let me @let twice
09:18:34 <Zao> dark: "heredocs"
09:18:41 <unkanon> @let appl2 :: (a -> b) -> (b -> c) -> (a -> c); appl2 x f = f . x
09:18:42 <lambdabot>  <local>:5:0:
09:18:42 <lambdabot>      Duplicate type signature:
09:18:42 <lambdabot>        <local>:5:0-40: appl2 :: ...
09:18:46 <Cale> unkanon: @undefine will clear everything
09:18:58 <Cale> (and that's all you get)
09:19:11 <aavogt> hi, I'm having trouble to see why my list permutation implementation fails for lists longer than 4 http://hpaste.org/41860/type_level_list_permutations
09:19:14 <Zao> dark: You can get a decent approximation of heredocs via TH.
09:19:29 <unkanon> Cale: thanks :)
09:19:47 <aavogt> Zao: what happens if the contents of your heredoc must contain |] ?
09:19:54 <Cale> aavogt: I should have known... lol.
09:20:02 <dark> Zao, but, is there a haml haskell library that would use such heredocs? I'm quite newbie in haskell, this seems like a lot of magic for doing myself .-.
09:20:21 <aavogt> Cale: about the contents of the paste?
09:20:25 <Cale> *Expects newbie permutations function without noticing who it is that's asking*
09:20:29 <Cale> *click*
09:20:31 <Cale> *oh...*
09:20:33 <Zao> dark: I don't know about this "HAML" library of yours, so "no clue".
09:21:31 <aavogt> Cale: I can't catch the first line of the type error (missing instances) that happens with the list of length 5
09:22:06 <dark> my other approach would be to use node.js - that already has everything I need in place - but I really wanted to do some code in haskell.. (specially the db query code, I think it could be very clean)
09:22:06 * aavogt tries compiling the code
09:24:14 <Cale> dark: My recommendation would be to try simpler libraries for this first, like the plain HTML library, and CGI. I haven't done a lot of web stuff in Haskell, but at least those libraries are pretty easily understood :)
09:25:09 <paolino> or SCGI
09:25:18 <aavogt> preflex: seen Saizan
09:25:18 <preflex>  Saizan was last seen on #haskell 4 hours, 30 minutes and 45 seconds ago, saying: you could implement support for coercive subtyping :)
09:25:19 <Cale> There's also blaze-html, which seems to use a writer monad for constructing HTML.
09:25:39 <Cale> (and saves you from writing lots of infix operators)
09:26:21 <Cale> It's a bit of an abusive way of using a monad, but it results in pretty code without being incomprehensible.
09:26:26 <dark> Cale, by plain html library you mean like (tag "p") ..? this can be tedious
09:26:39 <cdsmithus> dark: I think using Snap or the request routing stuff in Happstack are very decent options, as well.  They're very nice, and actually pretty simple and straightforward.  Snap is the cleaner of the two, with less unnecessary typeclass abstraction.
09:26:41 <Cale> dark: I mean the one which defines p as a function.
09:27:18 <Cale> p :: Html -> Html
09:27:58 <dark> oh, I don't know this. but it isn't http://hackage.haskell.org/cgi-bin/hackage-scripts/package/xhtml-3000.2.0.1 , right?
09:28:03 <aavogt> Cale: my error was a "Context reduction stack overflow"
09:28:42 <dark> cdsmithus, uhm. õ.o
09:28:45 <Cale> aavogt: Interesting :)
09:29:04 <Cale> dark: That's one of them. There's also 'html'
09:29:10 <cdsmithus> dark: Sorry, I just jumped in the middle... did I miss some context?
09:29:14 <Cale> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/html
09:29:43 <dark> cdsmithus, I am not sure. but do you mean http://snapframework.com/docs/tutorials/heist ? (I was talking about templating, and more specifically, "haml for haskell")
09:30:39 <cdsmithus> dark: Okay, sorry, I did miss context.  Though heist is nice for that sort of thing.  I have even taking to using it for internal static web sites with the minimal autogenerated Snap server.
09:31:05 <Phyx-> hmm
09:31:12 <cdsmithus> Other options that don't involve building HTML in Haskell would include HStringTemplate
09:31:47 <Phyx-> Saizan: I think I found a way of allowing IO actions in the monad.. if i just define a IO instance for the monad, that just ignores the session, since IO funcions can't read it anyway
09:31:53 <Phyx-> that should save alot of liftIOs
09:32:25 <aavogt> Cale: do you think using a better permutations algorithm could help? If the code must expand roughly 40x to work at type level, I'm quite afraid of the Data.List.permutations implementation
09:32:42 <dark> cdsmithus, but, can heist be used to embed some haskell code there? like, for iterating over a list, and creating a html list item for each haskell list item (not sure if I'm being clear, it would be like haml's - for .. { |item|)
09:32:55 <Cale> aavogt: Um, why are you doing permutations at the type level? :)
09:33:04 <Cale> aavogt: Is it just for fun?
09:33:28 <aavogt> @hackage xmonad-extras
09:33:28 <lambdabot> http://hackage.haskell.org/package/xmonad-extras
09:33:38 <Cale> aavogt: I think your problem in part might be that there's already an unavoidable combinatorial explosion, because the list of permutations is so large.
09:33:40 <aavogt> the Config stuff in there
09:34:13 <aavogt> the permutations are for testing
09:34:14 <cdsmithus> dark: You can't write Haskell directly in the template.  What you do instead is bind certain tags to certain behavior with splices.  Those basically say "when you see this XML tag, instead, call this Haskell function, passing it a node tree for the children, and it will build the node tree to put inside"
09:34:36 <Cale> AAAH MY EYES, THE GOGGLES, THEY DO NOTHING
09:34:43 <Cale> ;)
09:34:47 <dark> cdsmithus, quite interesting. (I'm reading the Heist lets you bind XML tags to Haskell code with a splice part. But I'm not understanding it)
09:34:49 <aavogt> :p
09:34:54 <Cale> dzen :: (Ins2 b (HSucc HZero) HTrue (Config (XConfig x) -> Config (XConfig (ModifiedLayout AvoidStruts x))) b1 l', HLt ll (HSucc HZero) b, HLength b1 ll, Read (x Window), LayoutClass x Window, MonadIO m, LayoutClass l Window, HLength a ll1, HLt ll1 (HSucc (HSucc HZero)) b2, Ins2 b2 (HSucc (HSucc HZero)) HTrue (m (XConfig l) -> m (XConfig l)) a b1) => a -> l'
09:35:13 <Saizan> Phyx-: if you get it to work i'd like to see it
09:35:31 <aavogt> haskell may be the wrong language for this then?
09:35:54 <Cale> It might help to know what's actually going on there
09:36:11 <Cale> Are you trying to determine if one type-level list is a permutation of another?
09:36:18 <Cale> Maybe you could sort the elements somehow?
09:36:19 <cdsmithus> dark: So you could define your own tag called, for instance, <dark:forAllItems itemTag="dark:itemName">We also have a <dark:itemName/>. </dark:forAllItems>
09:36:38 <Cale> Or at least, eliminate the elements from both at once?
09:36:53 <aavogt> Cale: the permutations are just for testing an invariant in the rest of the code
09:37:09 <cdsmithus> And you'd write a splice for <dark:forAllItems/> which just makes a copy of its child elements, and evaluates them with the additional splice for the <dark:itemName/> tag.
09:37:11 <Cale> aavogt: ah, hmm
09:37:22 <aavogt> that the order in which those  dzen and such functions are applied doesn't affect the outcome
09:37:22 <Cale> aavogt: Maybe you could use TH to generate the types you're looking for?
09:37:32 <cdsmithus> dark: Does that make sense?
09:38:51 <Cale> aavogt: Is that what all this type hackery is for? So that you can have functions which take their parameters in a random order? :)
09:39:06 <dark> cdsmithus, hmm.. yes. it might be way better than actually embed code (and deal with type errors and such at template level..)
09:39:17 <Cale> (That seems sort of insane to me.)
09:39:55 <cdsmithus> dark: It's unfortunately a bit like coding in XML... but when you're writing the page in HTML/XML anyway, that turns out to work better, IMO, than trying to mix syntaxes
09:39:55 <dark> it looks like snap is more "polished" than yesod. or at least has wider acceptance. is that right?
09:40:01 <aavogt> Cale: also that duplicate parameters are ignored
09:40:23 <Cale> aavogt: Why?
09:40:33 <cdsmithus> dark: I'd say actually that Yesod is more polished... but the quasiquoter/TH stuff leaves a bad taste in my mouth
09:40:46 <dark> cdsmithus, well, i am _not_ writing anything in html. i am writing everything in haml and sass, and it feels light..
09:41:09 <dark> oh, so a  yesod program is actually written in template haskell, not haskell
09:41:20 <aavogt> Cale: justification here http://hackage.haskell.org/packages/archive/xmonad-extras/0.9.2/doc/html/XMonad-Config-Alt.html
09:41:32 <dark> is TH transparent to the user, like ocaml's camlp4? or is there some additional step?
09:41:37 <aavogt> more realistically it's just a proof of concept
09:41:57 <aavogt> dark: there is some extra syntax
09:42:06 <aavogt> and you need to tell ghc to use it
09:42:08 <cdsmithus> dark: It's written in Haskell with the TH and quasiquoter language extensions.  The majority is Haskell, but some core parts use an ad hoc syntax and a quasiquoter.
09:42:35 <dark> oh, so th is a syntax extension
09:42:55 <aavogt> and in this case it's used to write more syntax extensions
09:43:02 <cdsmithus> dark: Yes, it's a language extension that lets you write little bits of stuff that are processed at compile time.
09:44:19 <aavogt> dark: more like  metaocaml than camlp4 I think (though I have not used either in detail)
09:45:06 <cdsmithus> dark: TH is basically s system for writing code that changes the source code as it's compiling (perhaps generates new code for you, etc.).  And quasiquotation lets you embed stuff in other languages into your Haskell source, and have a processor convert it into Haskell for you while compiling.  Yesod uses both; so you tend to write code with embedded stuff in other languages and calls to TH bits.
09:45:10 <dark> camlp4 is run by the compiler itself, so I just set some flags at compile time. but I think it can also be used to output a proper ocaml source
09:45:35 <dark> I see an example at https://github.com/snapframework/snap-website , I think I will git clone it and see. (but isn't there more lightweight, didactic examples of heist/snap?)
09:45:45 <Cale> aavogt: I sort of wonder about whether you could do that all on the value level with an appropriate monoid. I suppose it wouldn't be able to verify at compile time that you haven't completed your configuration.
09:45:53 <dark> oh, i see "snap init"
09:45:57 <FunctorSalad> dark: TH is run by the compiler too
09:46:04 <dark> it must be something like ruby on rails
09:46:06 <FunctorSalad> (before typechecking)
09:46:36 <FunctorSalad> (nevermind that last comment, I have no idea how it could run *after* typechecking ;))
09:46:40 <aavogt> Cale: one problem with that approach is that ugly wrapping in existentials
09:47:00 <aavogt> since layouts are arbitrary types that inhabit a typeclass
09:47:03 <cdsmithus> dark: That's actually a pretty simple example.  It's mostly static, though... no form processing or anything
09:47:43 <aavogt> so it doesn't seem possible in general to write an    (addLayout x)
09:47:50 <FunctorSalad> dark: and it can also output sort-of proper haskell source with -ddump-splices ;)
09:48:13 <aavogt> oops, modification of Layout was the issue
09:48:13 <Phyx-> Saizan: hrm, actually it's wrong, it's the inverse, doing that just allows you to do a Cabal action inside of IO, nvm :)
09:48:24 <FunctorSalad> though ISTR ghc's pretty-printer doesn't always print valid haskell (with some infix things)
09:48:44 <FunctorSalad> not sure I do remember that correctly
09:48:57 <aavogt> FunctorSalad: at a time parens were missing, I think they fixed that one
09:49:30 <dark> cabal: There is no package named snap. Perhaps you need to run 'cabal update' first?
09:49:52 <cdsmithus> dark: Try snap-server
09:50:18 <cdsmithus> dark: Also http://www.snapframework.com has tutorials and guides to get started
09:50:42 <aavogt> FunctorSalad: this bug http://hackage.haskell.org/trac/ghc/ticket/3899  maybe there were others
09:51:18 <dark> cdsmithus, oh, I'm following some of it (but i was at the wrong page). and yes, it's snap-server, http://snapframework.com/docs/tutorials/snap-api
09:54:24 <aavogt> Cale: so it was wrapping things like   newtype Mirror l a = Mirror (l a), such that you end up with a    Layout a -> Layout a
09:55:32 <aavogt> where the Layout is an existential that hides the l bit, which gets changed
09:56:09 <dark>     Warning: Definition but no type signature for `point'              Inferred type: point :: Char -> Bool while installing some dependency at cabal
09:56:25 <aavogt> warnings don't matter
09:56:27 <dark> is this a default warning? seems strange
09:56:36 <aavogt> it's in -Wall
09:56:45 <dark> oh
09:57:22 <dark> also lots warnings for redundant imports
10:02:45 <FunctorSalad> aavogt: ah yes. maybe what I was thinking of was printing infix tycons like this though: :+: a b
10:03:09 <FunctorSalad> the square braces variable names in that ticket look like a problem too
10:03:29 <FunctorSalad> *bracket
10:03:46 <aavogt> well that way you know those names are generated
10:04:05 <aavogt> it'd be easy enough to post-process those away I think
10:04:32 <FunctorSalad> yeah
10:04:52 <aavogt> since the pretty printer puts some spaces when the expression would be    x [aXYZ]
10:05:51 <aavogt> FunctorSalad: at one point or another there was a program for expanding TH splices?
10:06:06 <FunctorSalad> aavogt: ZeroTH?
10:06:17 <aavogt> sounds about right
10:06:32 <aavogt> it must be horribly bitrotten by now
10:09:21 <FunctorSalad> aavogt: still seems broken http://hpaste.org/41861/infix_types_ppr_bug
10:10:22 <aavogt> it's not going to be fixed if nobody else knows about it!
10:12:33 <dark> http://snapframework.com/docs/style-guide - all of this is interesting, but do emacs mode actually enforce all those rules?
10:12:54 <dark> if not, the first providence should be to write an emacs mode, then just indent normally...
10:13:40 <dark> (i used to wonder about the right style, but now, i just indent. if the code looks wrong, the indenter should itself be fixed...)
10:16:24 <AmunRa> anyone here managed to get some sort of UI working on OSX? hscurses seems to work, but something nice would be good. wxHaskell segfaults and gtk2hs dosn't dynamically load the right libs.. 
10:18:58 <dark> where is cabal binaries located? (snap-server was supposed to install an snap command, but i think the right directory is not on my PATH)
10:19:33 <geheimdienst> dark: check ~/.cabal/bin
10:20:03 <AmunRa> dark, also try just doing `cabal build`
10:20:34 <dark> oh, I think I was warned against installing "as root". I thought that installing as root would just install for all users, like rubygems, but I now remember that cabal isn't exactly like this
10:21:09 <dark> I need snap-server as more than one user.. and yes, it's all on /root/.cabal now
10:21:50 <aavogt> cabal install --global
10:22:16 * hackagebot supercollider-midi 0.2 - Demonstrate how to control SuperCollider via ALSA-MIDI  http://hackage.haskell.org/package/supercollider-midi-0.2 (HenningThielemann)
10:22:25 <dark> so I actually should rm /root/.cabal?
10:23:15 <dark> i think this directory was just created
10:23:46 <ManateeLazyCat> AmunRa: Ask in gtk2hs.
10:24:08 <ManateeLazyCat> AmunRa: Axel (the author of gtk2hs) have Mac.
10:24:08 <dcoutts_> dark: yep
10:24:24 <AmunRa> ManateeLazyCat, didn't realise the existance of such channel, thanks
10:24:47 <monochrom> if you use "cabal install" with default settings, files go into $HOME/.cabal . if you use "cabal install --global" but otherwise default settings, files usually go to /usr/local
10:24:48 <ManateeLazyCat> AmunRa: gtk2hs-users@lists.sourceforge.net
10:25:11 <AmunRa> Ahh ok... well I filed a bug report already.. I guess that is enough
10:25:25 <ManateeLazyCat> AmunRa: you maybe need read http://code.haskell.org/gtk2hs/INSTALL first.
10:25:34 <monochrom> however this is just files. metadata is another story. metadata is more determining than files. you just delete the files, ghc still thinks packages are installed.
10:25:49 <dcoutts_> dark: btw, with rubgems, does it install globally when you just sudo rubgems, or only when you su first, then run rubgems from a root shell?
10:29:35 <dark> dcoutts, I have no idea .-. but this info of 'as root == globally' I got from #rubygems
10:30:40 <monochrom> cabal uses --user vs --global rather than amiroot
10:31:13 <dcoutts_> monochrom: it's partly because I don't know how to implement amiroot :-)
10:31:17 <monochrom> "sudo cabal install" is implicitly "sudo cabal install --user" and the result depends on what $HOME it gets
10:31:18 <dark> oh yes :)
10:31:41 <dark> dcoutts_, oh you are the cabal guy?
10:31:51 * dcoutts_ is the cabal maintainer
10:31:59 <dark> at linux you can check if the "effective user id" is 0
10:32:20 <dark> there must be a syscall for that
10:32:33 <monochrom> my sudo preserves $HOME i.e., it's still my /home/trebla . sudo -H sets $HOME to /root
10:32:36 <geheimdienst> i guess "caballero" would be the term for cabal developer ...
10:32:38 <ManateeLazyCat> dcoutts_: Any plan to fix gtk2hs-buildtools problem? Maintain Gtk2hsSetup.hs is painful.
10:33:05 <revenantphx> Does anyone have some links to code using STRef and ST?
10:33:10 <revenantphx> So I can see some examples in usage?
10:33:14 <monochrom> the windows story for amiroot may be complicated
10:33:18 <dcoutts_> dark: right, that's the thing, sudo bash -c 'echo $EUID' gives 0, but $HOME remains the same
10:41:15 --- mode: lindbohm.freenode.net set +o ChanServ
10:41:54 <litb> hmm
10:42:36 <dcoutts_> ManateeLazyCat: sure, but no timescale
10:44:37 <drak> wtf
10:44:37 <drak> wtf was that
10:44:38 <litb> largest netsplit ever lol
10:44:38 <aavogt> revenantphx: pass arguments around then?
10:44:40 <EliasAmaral> @type (***)
10:44:40 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
10:44:41 <EliasAmaral> @type (fmap fmap fmap)
10:44:41 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
10:44:41 <EliasAmaral> @type zip.ap fmap.(id &&& id)
10:44:41 <lambdabot>     Couldn't match expected type `[a1 -> a]'
10:44:41 <lambdabot>            against inferred type `(a2 -> b) -> f a2 -> f b'
10:44:41 <lambdabot>     In the first argument of `ap', namely `fmap'
10:44:41 <EliasAmaral> @type zip.ap fmap
10:44:41 <lambdabot>     Couldn't match expected type `[a1 -> a]'
10:44:41 <lambdabot>            against inferred type `(a2 -> b) -> f a2 -> f b'
10:44:41 <lambdabot>     In the first argument of `ap', namely `fmap'
10:44:49 <revenantphx> The hell are arrows.
10:45:33 <aavogt> revenantphx: pass arguments around then?
10:45:34 * EliasAmaral reading the monad.reader 13, "typeclassopedia". maybe it will help one understand arrows?
10:46:06 <aavogt> or the state can be to return a new version of the function incorporating whatever changes you wanted
10:46:44 <monochrom> examples of arrows are "a->b" and "a -> IO b" and "a -> Maybe b" and "a -> [b]"
10:46:47 <aavogt> the State monad is a convenient abstraction for that, so you don't have to keep track of names
10:47:17 <revenantphx> monochrom: ... functions?
10:47:28 <revenantphx> So... anything that takes inputs and produces outputs 0.o
10:47:33 <monochrom> if you have heard of people saying "do not think of a -> IO b as side-effecting functions", now arrows says you should.
10:47:42 <monochrom> yes that is all.
10:47:53 <revenantphx> :t (>>>)
10:47:54 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
10:48:01 <monochrom> "a -> [b]" allows multiple-universe output
10:48:02 <revenantphx> :|
10:48:16 <monochrom> >>> is just function composition
10:48:27 <revenantphx> Yeah, that's what I was thinking.
10:48:27 <aavogt> <<<
10:48:28 <djahandarie> Generalized to categories
10:48:28 <dark> I never understood the relationship between -> (the constructor for functions) and arrows
10:48:38 <djahandarie> -> is an arrow
10:48:38 <revenantphx> :t (.)
10:48:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:48:50 <revenantphx> oh, that's functors...
10:48:52 <revenantphx> nmd
10:48:54 <dark> yeah it looks like an arrow
10:48:54 <djahandarie> :t Prelude..
10:48:55 <lambdabot> parse error on input `Prelude..'
10:48:59 <djahandarie> :t (Prelude..)
10:49:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:49:01 <litb> ((->) e) is the type of a function that takes an e and that returns an *
10:49:28 <aavogt> :k (->) e
10:49:29 <lambdabot> Not in scope: type variable `e'
10:49:30 <FunctorSalad> nope it's the type constructor that maps each type A to the type e -> A
10:49:37 <dark> :k (->)
10:49:37 <lambdabot> ?? -> ? -> *
10:49:46 <litb> FunctorSalad: hmm
10:50:10 <djahandarie> :k (->) Int
10:50:11 <lambdabot> ? -> *
10:50:35 <FunctorSalad> litb: any (value-level) functions have a (->) with two arguments as their type
10:50:39 <dark> http://www.haskell.org/sitewiki/images/8/85/TMR-Issue13.pdf
10:50:42 <litb> so it's a type constructor that takes an ? and that returns a function type *  ?
10:50:51 <FunctorSalad> maybe you meant a type-level function though
10:50:52 <dark> i'm finding it interesting
10:51:00 <litb> damn netsplit
10:51:08 <djahandarie> litb, just ignore ? and ??, that's GHC junk
10:51:11 <djahandarie> They are just *
10:51:12 <litb> hmm
10:51:31 <litb> so it's a type constructor that takes a * and that returns a function type *  ?
10:52:07 <litb> or isn't  a -> b   a function type?
10:52:20 <litb> (of kind  *)
10:52:38 <litb> hmm i dont get this lol
10:53:07 <djahandarie> Yes, (e ->)  has kind * -> *, and when applied with another type 'a' will have kind *, and the type (e -> a)
10:53:25 <litb> ohh!
10:53:44 <dark> a type constructor is a parametric type not fully applied, right?
10:54:00 <litb> is it a dependent type  ?
10:54:11 <dark> so if a type has kind * -> *, then i need to apply it to another type, in order to actually have a type
10:54:25 <dark> like: Maybe is not a type, but Maybe Int is
10:54:30 <djahandarie> dark, you're right
10:54:37 <djahandarie> litb, this has nothing to do with dependent types
10:54:43 <litb> ohh!
10:54:55 <djahandarie> dark, except you're abusing terms a little
10:55:14 <dark> djahandarie, in which sense?
10:55:21 <djahandarie> dark, Maybe is still a type, it is just a type with kind * -> * rather than kind *
10:55:48 <Claudius1aximus> has anyone already implemended something like this and put it on hackage for me to use? newtype NFloat = NFloat Float ; instance Num NFloat where NFloat x + NFloat y = let z = x + y in if isNaN z then error (x,y) else z
10:55:49 <djahandarie> dark, just like id is still a value, but it is a value with type a -> a rather than a
10:55:59 <litb> if haskell had an array type that would be constructed as  {N}  would   ({})   be a dependent type?
10:56:08 <dark> I'm just repeating what I'm reading at the monad.reader issue 13: "Maybe is not a type in and of itself, but requires another type as a parameter, like Maybe Integer."
10:56:13 <Cale> litb: Yeah, if that N :: Integer, say
10:56:19 <dark> but hmm I get it
10:56:20 <litb> ohh i see now!
10:56:21 <Cale> litb: Or Nat
10:56:41 <Cale> In Haskell, types can only be parametrised on other types
10:56:44 <dark> djahandarie, in ocaml, one would say that maybe is a _polymorphic_ type (but still a type), and would write type 'a maybe = ..
10:56:50 <Cale> (rather than on values)
10:57:22 <Cale> dark: Well, there are various ways we can use language here :)
10:57:31 <monochrom> Λa. Maybe a :)
10:57:40 <djahandarie> monochrom, hey, that's illegal!
10:57:41 <Cale> dark: It might be preferable to say that Maybe is a type constructor.
10:57:53 * monochrom is a haskell criminal!
10:58:23 <dark> the complete statement was "Maybe is such a type constructor: Maybe is not a type in and of itself, but requires another type as a parameter, like Maybe Integer."
10:58:37 <dark> nonetheless, are type constructors types?
10:58:37 <djahandarie> dark, yeah he's abusing terms also
10:58:40 <FunctorSalad> 'types' sometimes includes type constructors, sometimes not
10:59:01 <monochrom> a type constructor that still needs more parameters is not a type
10:59:13 <djahandarie> Then what is it?
10:59:21 <monochrom> it is a type constructor
10:59:42 <djahandarie> So type constructors are not on the type-level?
10:59:49 <dark> now I'm really confused. you are saying Maybe Int is a type but Maybe _is not_ a type but a type constructor? monochrom
10:59:52 <monochrom> they are on the type level
11:00:01 <litb> Cale: i see
11:00:14 <monochrom> Maybe is a type constructor
11:00:16 <djahandarie> monochrom, I don't understand why we seperate type constructors and types, but not functions and values.
11:00:21 <dark> so if I want to talk about a general Maybe _type_ I should really talk about Maybe a, not Maybe
11:00:23 <djahandarie> dark, he's saying the opposite of what I said
11:00:36 <djahandarie> I could be wrong here if both byorgey and monochrom and disagreeing with me :P
11:00:39 <remy_o> ? Maybe is a monad.
11:00:58 <monochrom> I don't understand either. There is nothing to understand.
11:01:06 <dark> djahandarie, I think the rationale is: you can have a value of type Maybe a or Maybe Int, but there is not value of type Maybe
11:01:21 <dark> there is no value
11:02:00 <monochrom> The only metric for definitions is useful and useless.
11:02:01 * djahandarie shrugs
11:02:18 <eikke> does anyone happen to know whether someone wrote Hs bindings for libmx?
11:02:19 <remy_o> Maybe is like something that takes a Type and returns another Type (and is a particular function of that kind, a Functor, or a Monad)
11:02:20 <djahandarie> I'd prefer to say that values can only have types with kind *
11:02:58 <medfly`> hi cale
11:03:27 <djahandarie> Man it sure is spammy in here
11:03:28 <litb> with values, if we have  double a = a + a   and when we say    double   will that be a value of kind  * -> *  ?
11:03:44 <dark> djahandarie, hmm so there are "higher" types with no values; and at the lowest kind, *, we find all values?
11:03:54 <djahandarie> litb, no, double is on the value-level so we talk about it with types, not kinds
11:04:11 <litb> i.e   double   would be a value constructor.   double 5   would be a value 10   :)
11:04:20 <litb> djahandarie: oh
11:04:23 <litb> i see now!
11:04:36 <djahandarie> litb, a "value constructor" is also known as a function
11:04:39 <dark> litb, I think you can only talk about kind of types. double has type Num a => a -> a, and -> itself has kind * -> *. I.. think
11:04:42 <monochrom> if we have mean xs = sum xs / genericLength xs, we can say mean is unkind.
11:04:42 <litb> makes sense
11:04:46 <Cin_> If kinds were polymorphic we could say that kinds consider types and type functions as the same thing, just as types consider functions and values as the same thing.
11:05:19 <litb> so a value consturcotr is also known as function. and a function is a value. so why wouldn't be a type constructor of kind * -> * be a type.
11:05:24 <revenantphx> Now I'm just confused...
11:05:45 <augur> whoa
11:05:46 <djahandarie> litb, because it isn't, apparently. :P
11:06:22 <monochrom> you are free to consider Maybe as a type.
11:06:34 <djahandarie> What does the report say?
11:06:46 <dark> I would like to first know "standard" haskell terminology (on what would be called a type, exactly) and then see the divergent interpretations
11:06:57 <litb> lol
11:06:59 <dark> yes, I meant in relation to the haskell 98 report
11:07:20 <djahandarie> The report calls Maybe a type...
11:07:26 <djahandarie> Damn you for misleading me monochrom
11:07:33 <dark> ok, case settled
11:07:38 <monochrom> which section?
11:08:05 <djahandarie> "Predefined Types and Classes"
11:08:21 <dark> (but I think I see the point on calling Maybe a type constructor)
11:08:25 <djahandarie> I suppose I should look where they actually define them
11:08:27 <litb> do values always have types of kind *  ?
11:09:00 <Cale> In the Report, yes
11:09:12 <Cale> In GHC, there are some kinds for unboxed types
11:09:22 <monochrom> Alright, I'll follow the Report then. Maybe is both a type and a type constructor.
11:09:30 <Cin_> Perhaps anything which can be an instance of a class is a type.
11:09:49 <djahandarie> But more importantly, even in GHC there are no values that have (->) in their kind
11:09:50 <Cin_> (e.g. Maybe)
11:10:22 <revenantphx> @source STRef
11:10:23 <lambdabot> STRef not available
11:10:30 <revenantphx> @source Data.STREf
11:10:30 <lambdabot> Data.STREf not available
11:10:31 <dark> kinds for unboxed types?
11:10:31 <djahandarie> Cin_, I keep on reading your name as Cale
11:10:38 <revenantphx> @source Data.STRef
11:10:38 <lambdabot> http://darcs.haskell.org/packages/base/Data/STRef.hs
11:10:39 <djahandarie> dark, like ? and ??
11:10:42 <djahandarie> :k (->)
11:10:43 <lambdabot> ?? -> ? -> *
11:10:46 <monochrom> You should see the dilemma. Dilemma A: if Maybe is a type, what are its values? Dilemma B: if Maybe is not a type, why can you plug it into the type variable f in (Functor f) => f a -> f (f a) ?
11:10:54 <revenantphx> SO THAT'S HOW YOU BIND IT
11:11:00 <revenantphx> damn, now it makes sense.
11:11:12 <dark> djahandarie, yes, I haven't a slight idea on how ? and ?? differ from *
11:11:37 <Cin> monochrom: Phantom types don't have values, would you say they're not types?
11:11:51 <Cin> (I mean, types without constructors.)
11:12:21 <litb> i thought types don't need values to exist. 
11:12:25 <monochrom> "data Phatom a = P" has the value P.
11:12:30 <revenantphx> modifySTRef kind of does what I want :P
11:12:41 <Cale> If Maybe is not a type, why does it have a kind?
11:12:41 <monochrom> "data None" is not in Haskell 2010.
11:12:50 <Cin> Well, I can't remember the cute way in which people refer to data types without constructors.
11:13:00 <monochrom> empty types
11:13:29 <Cin> Cale: What is a type?
11:13:39 <monochrom> with extensions, "data None" has value ⊥
11:14:20 <litb> does the void type in C have the value ⊥
11:14:21 <litb> ?
11:14:24 <monochrom> no
11:14:29 <djahandarie> dark, well, if you have an unboxed tuple it doesn't actually exist
11:14:35 <litb> hm
11:15:02 <djahandarie> dark, their values are stored in registers, so they can be accessed immediately rather than using a pointer to the tuple
11:15:09 <magicman> newtype Thing = Thing Thing -- Wheee.
11:15:30 <Cin> Cale: Is it a possibly-empty set and an arity?
11:15:36 <dark> so it's just an optimization, like strictness annotation?
11:15:37 <monochrom> I see, Thing has no value
11:15:40 <augur> lolwut
11:15:48 <augur> chrisdonedonedone deleted his account from reddit o_O
11:15:57 <djahandarie> dark, so basically what the (->) kind is saying is that it allows any two types to come in, but a boxed type must go out
11:16:17 <litb> dunno who chrisdonedonedone is
11:16:26 <djahandarie> (? is a superset of *)
11:16:30 <revenantphx> Could I get some help with this?
11:16:31 <revenantphx> https://gist.github.com/718179
11:16:37 <Cale> Cin: Well, that's a philosophical question :)
11:16:38 <monochrom> grandchild of chrisdone
11:17:04 <Cin> Cale: Is it not well-defined to ask what a Haskell type is?
11:17:26 <Cin> revenantphx: What is the type of writeSTRef?
11:17:33 <revenantphx> :t writeSTRef
11:17:36 <lambdabot> forall s a. STRef s a -> a -> ST s ()
11:17:39 <Cale> Cin: Well, that's what was under discussion just now - whether things at the type-level with kinds other than * are really "types" or not.
11:17:39 <monochrom> delete "runST $"
11:17:45 <litb> i'm disappointed. i thought you guys know the haskell stuff
11:17:47 <litb> lol
11:17:48 <Cin> revenantphx: And what is the type of addSTFloat?
11:17:50 <augur> litb: some dude who wrote Lisk
11:18:00 <litb> augur: ohh
11:18:00 <revenantphx> Cin: I'm confused :P
11:18:05 <Cale> Cin: They could be, if we wanted them to.
11:18:20 <revenantphx> ah right
11:18:20 <monochrom> addSTFloat :: I'm confused ? :)
11:18:23 <revenantphx> ST 
11:18:25 <revenantphx> not STRef 
11:18:31 <augur> a bunch of people chewed him out for complaining about nothing
11:18:33 <augur> including myself
11:18:41 <revenantphx> monochrom: admittedly this is pointless, modifySTRef is fine.
11:18:45 <augur> i said he was a baby for complaining about the capitalization rules
11:18:45 <revenantphx> This is just for me to try stuff :
11:18:51 <djahandarie> Wow
11:18:53 <djahandarie> 72 comments
11:18:53 <augur> "zomg too many caps in haskell D:"
11:19:18 <monochrom> I don't criticize on that.
11:19:18 <djahandarie> augur, what's your account on reddit?
11:19:19 <augur> and i was like, dude, you just wrote english and used a bunch of capitals. maybe you just havent given haskell enough care and attention
11:19:22 <augur> djahandarie: psygnisfive
11:19:24 <litb> i think of type constructors as type functions. a type function is a type. just like a value function is a value. 
11:19:40 <Cale> One of my favourite descriptions of what a type is in general is that it's a statement about a program for which the program itself constitutes a proof, and hence is and statically machine verifiable.
11:19:43 <Cale> -and
11:19:47 <augur> djahandarie: warning: potential abundance of anarchist commentary.
11:19:56 <Cin> Cale: I especially like that one.
11:20:03 <revenantphx> Cin: monochrom: Okay I'm just lost TT_TT
11:20:07 <revenantphx> I keep screwing it up further.
11:20:47 <Cin> revenantphx: Paste your current program and we can address it.
11:20:56 <revenantphx> My current program is what I pasted earlier.
11:21:03 <monochrom> use formal logic to unlose.
11:21:22 <monochrom> be mechanical, don't be philosophical.
11:21:31 <litb> i'm not well versed with all those proof-with-types things
11:22:04 <Cale> Cin: But from that definition, there are arguments both ways for whether Maybe on its own is a type. It is a kind error to say that x :: Maybe, and so no programs have that type.
11:22:28 <path[l]> what do you guys think of Lisk
11:22:43 <augur> djahandarie: dont hate me on reddit plox :x
11:22:44 <monochrom> I think it is too close to Risk
11:22:49 <litb> my thoughts about it are undefined
11:22:53 <Cale> path[l]: I think that I like Haskell's syntax better.
11:22:54 <revenantphx> Cin: I like this version more
11:22:55 <revenantphx> addSTFloat' :: STFloat s -> Float -> ST s ()
11:22:55 <revenantphx> addSTFloat' ref x = modifySTRef ref (+ x) 
11:22:57 <revenantphx> :P
11:23:00 <revenantphx> A lot simpler heh.
11:23:10 <monochrom> http://appshopper.com/games/risk-the-official-game :)
11:23:12 <revenantphx> (and it *should* work)
11:23:38 <monochrom> wrong type signature. right code.
11:23:39 <Philippa> Cale: It's a type in the sense of "types and terms" and it's not a type in the sense that type constructors are distinct, no big?
11:23:58 <revenantphx> monochrom: explain ?
11:24:01 <path[l]> I too dont like it, except I agree with him about one thing
11:24:03 <Cale> Philippa: Yeah, it's just a matter of wanting to use the same word for two different things.
11:24:09 <monochrom> oops, right type signature too.
11:24:14 <path[l]> I still havent gotten to liking indentation for syntax
11:24:34 <revenantphx> monochrom: I think it'd be easier to work in terms of modifySTRef
11:24:45 <Cale> I love indentation for syntax, but I am mildly uncomfortable with the lack of editor support.
11:24:46 <monochrom> I don't mind either way.
11:25:04 <Cin> Cale: Does Djinn exemplify your description?
11:25:04 <Cin> @djinn a -> Maybe a
11:25:05 <revenantphx> monochrom: how would I correctly write it otherwise.. lets see
11:25:05 <lambdabot> f = Just
11:25:25 <revenantphx> ah, got it.
11:25:32 <Cale> We should have an editor mode where any edit that causes a layout keyword to be moved will cause the entire block that it contains to move in the same way.
11:25:37 <revenantphx> https://gist.github.com/718191
11:25:39 <revenantphx> these are both fine then
11:25:45 <djahandarie> Cale, I think yi does that
11:25:47 <monochrom> do { val <- readSTRef ref; writeSTRef ref (val + x) }
11:25:53 <Cale> djahandarie: It almost does, there are some problems.
11:25:53 <Cin> Cale: It seems that "f = Just" is the proof, and "a -> Maybe a" is the description.
11:25:54 <revenantphx> According to the source of modifySTRef, they're identical for all intensive purposes.
11:26:00 <Cale> Cin: yes.
11:26:01 <revenantphx> monochrom: exactly what I did.
11:26:15 <revenantphx> correction: they're just identical.
11:26:21 <Cale> Cin: djinn is a theorem prover for a decidable fragment of Haskell
11:26:28 <Cale> (without recursion)
11:26:49 <revenantphx> I don't get djinn :\
11:27:02 <Cale> revenantphx: You give it a type, it gives you a program with that type
11:27:04 <monochrom> djinn just does formal logic mechanically
11:27:23 <Cale> @djinn Either a b -> (a -> c) -> (b -> c) -> c
11:27:23 <lambdabot> f a b c =
11:27:23 <lambdabot>     case a of
11:27:23 <lambdabot>     Left d -> b d
11:27:23 <lambdabot>     Right e -> c e
11:27:28 <revenantphx> @djinn STREf s a -> Float -> ST s ()
11:27:29 <lambdabot> Error: Undefined type STREf
11:27:29 <monochrom> philosophizing too much limits your options
11:27:36 <revenantphx> @djinn STRef s a -> Float -> ST s ()
11:27:37 <lambdabot> Error: Undefined type STRef
11:27:51 <monochrom> djinn doesn't know STRef
11:27:58 <revenantphx> yeah, didn't think so.
11:28:10 <revenantphx> @djinn Num -> Num -> Num
11:28:10 <lambdabot> Error: Undefined type Num
11:28:14 <litb> is djinn better than coq ?
11:28:15 <Cale> If it did, it would probably have given you  return ()
11:28:20 <monochrom> coq is better
11:28:25 <revenantphx> @djinn Int -> Int -> Int
11:28:25 <lambdabot> Error: Undefined type Int
11:28:35 <revenantphx> @djinn a -> a -> a
11:28:35 <lambdabot> f _ a = a
11:28:40 <monochrom> djinn can't do induction. Coq can. ACL2 even better.
11:28:40 <Cale> litb: djinn is a triviality by comparison with coq
11:28:57 <litb> oh
11:28:59 <revenantphx> Is coq very large?
11:29:09 <Cale> Yeah, with lots of libraries
11:29:11 <monochrom> mediumly large
11:29:55 <revenantphx> Something like lambdabot would need protection when working with coq, to prevent it from exceeding memory limits.
11:30:17 <Cale> The "libraries" for djinn wouldn't get you banned from here if you pasted them into the channel.
11:31:00 <revenantphx> haha
11:31:00 <Cale> (They're maybe about 10 lines?)
11:31:04 <revenantphx> @list
11:31:04 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:31:21 <revenantphx> Oh, is bf brainfuck?
11:31:24 <monochrom> it's lambdabot's boyfriend
11:31:25 <Cale> yes, it is
11:31:27 <Cin> @vixen Is brainfuck your boyfriend?
11:31:27 <lambdabot> i prefer to go without panties or bras :)
11:31:31 * Cin blinks
11:31:32 <monochrom> obscene
11:32:43 <revenantphx> @vixen What did you do last night?
11:32:43 <lambdabot> whoa whoa whoa, one question at a time!
11:32:53 <revenantphx> @vixen Did he look like a bitch?
11:32:53 <lambdabot> Whoa, language! :)
11:33:20 <revenantphx> @vixen Then why you treating him like one!
11:33:20 <lambdabot> i'd say i like
11:35:25 <revenantphx> ...is lambdabot okay?
11:36:04 <pww> grrrr. stupid firefox
11:36:34 <revenantphx> > "oy"
11:36:34 <lambdabot>   "oy"
11:36:34 <revenantphx> > 1 + 2
11:36:34 <revenantphx> TT_TT
11:36:34 <revenantphx> I killed lambdabot.
11:36:34 <lambdabot>   3
11:36:35 <Cale> revenantphx: The IRC network is just being unreliable right now
11:36:35 <Cale> (as you can see by all the joins and ping timeouts)
11:37:12 <Aune> Join #haskell-blah
11:37:21 <revenantphx> It seems to be working fine TT_TT
11:37:30 <dark> djinn is simply nice
11:38:39 <kafee> why does this code does nothing? http://hpaste.org/41862/qt Which slot should I use?
11:39:23 <Cin> @djinn (a -> b) -> (b -> b -> c) -> a -> c
11:39:23 <lambdabot> f a b c = b (a c) (a c)
11:39:44 <revenantphx> One quick question.
11:39:50 <revenantphx> If I want to define "constants"
11:40:00 <revenantphx> is a good way to do that just to make them simple functions?
11:40:05 <revenantphx> evapRate :: Double
11:40:08 <revenantphx> evapRate = 10.0
11:40:12 <Cin> Yes.
11:40:14 <remy_o> yes
11:40:20 <litb> how does the above djinn thing prove anything? what does it prove?
11:40:25 <Saizan> except that i wouldn't call that a function
11:40:26 <litb> i don't get it lol
11:40:36 <dark> revenantphx, is evapRate a.. function?
11:40:36 <revenantphx> litb: It proves a lot of haskellers don't have a life :P
11:40:44 <revenantphx> dark: I don't think so...
11:40:58 <revenantphx> But it's functionally equivalent 
11:41:02 <revenantphx> evapRate a :: Double
11:41:03 <ddilinger> its not a function, but a standard definition of foo = "bar" should be plenty
11:41:06 <revenantphx> evapRate _ = 10.0
11:41:06 <orlandu63> revenantphx: evapRape isn't a function in that case
11:41:08 <Twey> litb: It proves that a type is inhabited
11:41:08 <monochrom> just say "definition" or "top-level definition"
11:41:29 <Cin> litb: I believe providing a value for the specified type using the rules of the type system constitutes a proof.
11:41:41 <revenantphx> Well, I'm curious actually
11:41:51 <revenantphx> if evapRate :: Double, evapRate = 10.0 is not a function
11:41:54 <Saizan> @google Curry Howard correspondence
11:41:55 <lambdabot> http://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence
11:41:56 <lambdabot> Title: Curry–Howard correspondence - Wikipedia, the free encyclopedia
11:41:59 <revenantphx> than is evapRate a :: Double, evapRate _ = 10
11:42:05 <Saizan> litb: see that page ^^^
11:42:12 <remy_o> revenantphx: maybe you could do evapRate :: (Num a) => a ; evapRate = 10.0 ? 
11:42:13 <revenantphx> I'd guess it's just a degenerate function.
11:42:30 <revenantphx> remy_o: Not much reason too.
11:42:49 <monochrom> "functional programming" does not mean you must confine yourself to functions. You may define constants, too.
11:42:55 <Saizan> "evapRate :: a -> Double; evapRate _ = 10" <-- that would be rightfully called a function
11:43:02 <dark> litb, in certain interpretation, a type is a logical statement. a value would be a proof that this statement is indeed true. (but haskell type is "inconsistent", because every type has a value, undefined..)
11:43:07 <Gracenotes> constant functions, amirite
11:43:36 <dark> constants are 0-ary functions
11:43:38 <Saizan> anyhow, it's a matter of using an useful definition, not finding the True one
11:43:56 <dark> but a constant function can have a greater arity (like f x = 1)
11:43:57 <aristid_> dark: functions are always 1-ary in haskell :)
11:44:03 <remy_o> revenantphx: i meant 10.0 would benefit from polymorphism, if you want to use it with various types
11:44:06 <Cin> Double -> Double is a function, Double is not a function
11:44:13 <revenantphx> remy_o: Oh, true.
11:44:24 <remy_o> but Num is not the right Class for that
11:44:25 <monochrom> yeah, just get the code going and screw the terminology
11:44:27 <dark> aristid_, yes
11:44:29 <revenantphx> Yeah, that's what I'm wondering.
11:44:37 <ion> foo = 42  -- foo is bound to a number
11:44:43 <revenantphx> Is a "0-ary function", as dark put it, a function?
11:44:46 <ion> foo = \a -> a + 42  -- foo is bound to a function
11:44:54 <aristid_> revenantphx: not really
11:45:11 <Twey> revenantphx: No
11:45:20 <Twey> A function is a mapping from one thing to another
11:45:20 <ddilinger> revenantphx: with haskells curying, it seems all functions must have 1 argument, with no arguments its not a function
11:45:34 <monochrom> terminology is for helping the lower 30% of the class pass the course by enabling lame questions on tests like "what is a value? multiple choice: A. ...  B. ... C. ..."
11:45:34 <Twey> If it doesn't have an argument, it's not doing any mapping, so it's not a function
11:45:37 <orlandu63> http://conal.net/blog/posts/everything-is-a-function-in-haskell/
11:46:32 <dark> (there are no 0-ary functions in haskell, i was just trying to explain the initial reasoning)
11:46:36 * hackagebot midi-alsa 0.1.1 - Convert between datatypes of the midi and the alsa packages  http://hackage.haskell.org/package/midi-alsa-0.1.1 (HenningThielemann)
11:46:44 <monochrom> perhaps the lower 99% of the class, too
11:46:51 <Gracenotes> of course, a function and a (boxed) int have a similar representation.. since in one evaluation step the former may turn into the latter...
11:47:19 <Twey> Conal looks very jolly in that picture on his blog
11:47:31 <Saizan> Gracenotes: that doesn't sound right
11:47:45 <revenantphx> :t flip
11:47:47 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:48:04 <revenantphx> :\
11:48:07 <litb> i think evapRate = 10.0  is a nullary function
11:48:10 <revenantphx> I thought it was (a -> b -> c) -> b -> a -> c
11:48:25 <ddilinger> revenantphx: the name would imply that
11:48:30 <monochrom> lambdabot /= ghci
11:48:31 <Saizan> :t Prelude.flip
11:48:32 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:48:37 <revenantphx> aah, 
11:48:54 <Gracenotes> Saizan: hm.. all I'm saying is, it's all closures
11:49:34 <monochrom> it's depressions all the way down
11:49:51 <revenantphx> Oh here's a question
11:50:08 <Gracenotes> functions are closures which take arguments (and the arity is important for evaluation.. taking arguments less than arity just means replacing the closure with a partially evaluated one)
11:50:09 <Saizan> Gracenotes: that i can agree with, but a thunk for a function won't transmute to an Int in any normal execution
11:50:15 <revenantphx> say I have something like data Box = Box { a :: Int, b :: Int, c :: Double}
11:50:29 <revenantphx> And I have a function called "updateBoxA"
11:50:34 <revenantphx> which is Box -> Box
11:50:39 <revenantphx> so 
11:50:40 <litb> ohh i see now!
11:50:43 <Gracenotes> Saizan: yeah that is true. preservation theorem of types and all
11:50:59 <revenantphx> er, those are bad names
11:51:06 <monochrom> good names.
11:51:12 <revenantphx> not for what I want to show :P
11:51:18 <revenantphx> data Box = Box { ralph :: Int, phil :: Double}
11:51:18 <orlandu63> (Box { a = 
11:51:23 <orlandu63> oops
11:51:27 <litb> so in a sense, it's different from types. while a  * type is still a type, a parameter less function isn't a function anymore
11:51:29 <ddilinger> with par and spark generation, and lazy evaluation, at what point are the sparks created?
11:51:30 <revenantphx> lets go with that for now.
11:51:32 <revenantphx> So 
11:51:34 <Gracenotes> a constant is a closure with no scope information
11:51:39 <Gracenotes> etc.
11:51:50 <revenantphx> updateBox box = Box .......
11:51:53 <Cin> litb: Consider that the alphabet consists of 'a' and 'b'. We can define some rules of production:
11:51:53 <Cin> 1. S -> aSb
11:51:53 <Cin> 2. S -> ba
11:51:53 <Cin> The S means 'start symbol'. We apply the production rules until a string containing no start symbol S is produced. For example, we want to prove that aababb is a valid string in this grammar. If we choose rule 1, rule 1 again and then rule 2, we achieve the following productions: S => aSb => aaSbb => aababb. We have given a proof of aababb following the production rules.
11:52:03 <revenantphx> so it needs to then call the functions to get each part of the previous box.
11:52:06 <revenantphx> To pass it into the new one.
11:52:19 <revenantphx> When you get to many more members, that could be a bit cumbersome.
11:52:22 <revenantphx> Is there a "nicer" way?
11:52:25 <Saizan> yes
11:52:46 <revenantphx> Saizan: ?
11:52:51 <monochrom> what orlandu63 tries to say. box{ralph=0} or box{ralph = floor (phil box)}
11:52:53 <ddilinger> revenantphx: i think you can just do Box { ralph: 4 } 
11:52:53 <remy_o> revenantphx: updateBox box = box { a = newa }
11:53:05 <ddilinger> err, yea = :)
11:53:06 <Gracenotes> wait.. what is the context for CFGs? *scroll*
11:53:07 <revenantphx> heh?....
11:53:28 <revenantphx> gotcha :\
11:53:36 <revenantphx> Where is that syntax defined?
11:53:41 <revenantphx> Or is it just special.
11:53:48 <Gracenotes> it is a bit special
11:54:08 <Gracenotes> like, if you want to define a modification function -Box
11:54:09 <revenantphx> what about if I want the new value to be based on the old one
11:54:18 <revenantphx> is Box { ralph = ralph - 2}
11:54:18 <revenantphx> okay
11:54:20 <ddilinger> revenantphx: that is doing that
11:54:22 <Gracenotes> er (Int -> Int) -> Box -> Box, modifying a
11:54:33 <Cin> Gracenotes: A context-free grammar can be expressed in a single-stack finite state machine.
11:54:46 <Gracenotes> modA f box = box { a = f (a box) }
11:54:54 <Gracenotes> gets a bit cumbersome
11:55:23 <litb> so the type given to djinn is in this example the grammar you give. and the derivations shown is the function definition?
11:55:25 <revenantphx> right...
11:55:31 <revenantphx> and how does it know to use the old values for all the others?
11:55:32 <monochrom> box{ralph=0} is at http://www.haskell.org/onlinereport/exps.html#sect3.15.3
11:55:57 <Gracenotes> Cin: yeah, pushdown.. I'm just curious to see where it comes in.. oh programs as proofs
11:56:08 <Saizan> revenantphx: you use the fields as accessors as usual
11:56:21 <revenantphx> I see, so for updating pheromone in a cell, this'd be good?
11:56:21 <revenantphx> evapCell c = c { pheromone = (* evapRate) (pheromone c)}
11:56:29 <revenantphx> Still seems a bit... oh well.
11:56:44 <Gracenotes> pretty much
11:57:03 <revenantphx> so if this is being passed into modifySTRef...
11:57:04 <Saizan> evapCell c = c { pheromone = pheromone c * evapRate} -- this is valid too
11:57:04 <revenantphx> could I do
11:57:11 <revenantphx> modifySTRef ref {pheromone = (* evapRate) (pheromone c)}
11:57:15 <revenantphx> except, not.
11:57:19 <revenantphx> And er.... shit.
11:57:23 <revenantphx> >_>
11:57:32 <revenantphx> Just trying to write this as one concise function.
11:57:34 <Saizan> use a lambda
11:57:38 <monochrom> evapCell c@Cell{pheromone=old} = c{pheromone = old * evapRate}
11:57:42 <revenantphx> Saizan: there we go
11:57:54 <Gracenotes> don't you need an extension for that?
11:58:01 <Saizan> no
11:58:09 <revenantphx> evapSTCell ref x = modifySTRef ref (\c -> c {pheromone = (* evapRate) (pheromone c)})
11:58:22 <revenantphx> That's not that bad.
11:58:32 <Saizan> s/x // ?
11:58:44 <revenantphx> ignore the x >_>
11:58:55 <Cin> litb: The program is analogous the choices of rules, yes. The type is analogous to the resulting string.
11:59:13 <Gracenotes> well. it's good to make a suite of pure functions to define common access and modification functions for your objects.
11:59:33 <Gracenotes> access beyond just field lookup: like if you have a Map, some lookup wrappers maybe.
11:59:43 <Gracenotes> in any case, once you have that, then add an impure glue on top, if you need it
12:00:12 <Gracenotes> so if you have a function Int -> Box -> Box, you can just say modifySTRef boxref (func 4)
12:09:16 <revenantphx> Gracenotes: I suppose that's the idea.
12:09:24 <revenantphx> To abstract over all the STRef stuff a bit.
12:10:24 <revenantphx> I mean, i see the difference.
12:10:35 <revenantphx> It just feels cleaner to me if the modifySTRef isn't there... hmmm
12:10:43 <revenantphx> I guess your method would be more generally useful.
12:11:07 <revenantphx> In this version I can ONLY modify a Cell in this way if it is an STRef
12:11:25 <McManiaC> http://npaste.de/rI/ rebindable if \o/
12:11:25 <McManiaC> :D
12:11:49 <revenantphx> McManiaC: what?
12:12:01 <McManiaC> see link :)
12:12:06 <abstractstone> anyone good at GTK? I'm stuck on this thing for  a few days .. http://stackoverflow.com/questions/4281984/how-can-i-make-a-graphical-command-line-in-haskell-gtk2hs
12:12:06 * revenantphx doesn't get it.
12:12:19 <McManiaC> you can overload "if" statements with your own version of it
12:12:24 <revenantphx> Ooooh.
12:12:36 <McManiaC> my one uses type classes to be able to test on IO Bool, IO (Maybe a) etc
12:12:37 <McManiaC> :D
12:12:52 <revenantphx> That's convenient.
12:14:35 <revenantphx> Can this be no further simplified?
12:14:35 <revenantphx> evapCell c = c {pheromone = (* evapRate) (pheromone c)}
12:14:45 <revenantphx> (no way to cancel out c)
12:15:08 <McManiaC> no
12:15:25 <Botje> not unless you write a helper function
12:15:36 <McManiaC> there are a few extensions though
12:15:41 <McManiaC> I dont remember their names
12:15:42 <Botje> but then you might as well use fc-labels or accessors
12:15:48 <McManiaC> yeah
12:15:56 <revenantphx> So in conclusion?
12:16:23 <McManiaC> RecordPuns could be usefull iirc
12:16:46 <revenantphx> Eh, it's fine as it is.
12:16:52 <revenantphx> No need to over complicate.
12:17:04 <monochrom> or over simplify :)
12:17:07 <McManiaC> yeah
12:17:15 <revenantphx> monochrom: true, I was just curious though.
12:17:15 <McManiaC> its fine as it is :)
12:18:05 <abstractstone> nobody able to give me a kick start ? it's frustating because I'm sure it's a simple problem 
12:19:22 <McManiaC> abstractstone: you could ask some gtk devs :)
12:19:26 <revenantphx> If I want to make a Cell in an IO monad context, is c <- return $ Cell 10.0 False False correct?
12:19:35 <McManiaC> I'm not that familiar with gtk
12:19:55 <monochrom> yes, but let c = Cell 10.0 False False is even better
12:19:57 <abstractstone> me neither, everything I try with it goes wrong
12:20:04 <McManiaC> revenantphx: c <- return x is almost always written as "let c = x"
12:20:06 <revenantphx> monochrom: gotcha
12:20:14 <revenantphx> monochrom: is it synonymous thouhg?
12:20:21 <revenantphx> I'm curious as to how it's different.
12:20:36 <ClaudiusMaximus> abstractstone: something like:   _ <- cmdline `onEntryActivate` do { txt <- entryGetText cmdline ; {- do something with the text here -} }
12:20:47 <Claudius1aximus> abstractstone: something like:   _ <- cmdline `onEntryActivate` do { txt <- entryGetText cmdline ; {- do something with the text here -} }
12:20:51 <revenantphx> @source let
12:20:51 <lambdabot> let not available
12:20:56 <ClaudiusMaximus> o_O
12:21:09 <McManiaC> revenantphx: let is a statement, not a function
12:21:18 <revenantphx> McManiaC: but what does it *do*
12:21:30 <revenantphx> within pure functions it seems to always be let..in..
12:21:34 <revenantphx> but here it's just "let"
12:21:37 <McManiaC> revenantphx: bind x to the variabel c :)
12:21:42 <revenantphx> Well, yes, I got that XD>
12:21:52 <revenantphx> I'm wondering how it's different when it's in the IO monad though.
12:22:01 <revenantphx> Probably has to do with desugaring it .
12:22:01 <litb> the only bigger haskell GUI program i know is yi
12:22:08 <abstractstone> ClaudiusMaximus: oh thank you, that's useful - the hardest bit is having output in a scrolly.. thing
12:22:09 <McManiaC> revenantphx: it works the same way as if you would write "let c = x in do ..."
12:22:17 <litb> which is gtkhs too, afaik
12:22:32 <monochrom> the do-notation allows and encourages "let" without "in". what does it do? definitions.
12:22:43 <ClaudiusMaximus> abstractstone: ah, i never tried displaying images
12:22:54 <McManiaC> monochrom: right
12:22:54 <ClaudiusMaximus> abstractstone: at least not with scroll bars
12:23:16 <litb> the let notation in do also translates to certain monadic constructs
12:23:31 <ClaudiusMaximus> abstractstone: btw, if you finish it, i'd be interested - would like to display LaTeX math in one of my programs too
12:23:47 <abstractstone> to be honest I don't care if I use gtk or anything else, but it seemed the easiest
12:24:28 <Phyx-> @hoogle xargs
12:24:28 <lambdabot> No results found
12:24:32 <Phyx-> wtf is that
12:24:35 <abstractstone> ClaudiusMaximus: whether someone else shows me how or if I eventually figure it out (seems unlikely though.. ) ill put the solution up on the stack page
12:24:41 <McManiaC> I'd prefer wxwidgets, but I can't get it to run :(
12:25:10 <abstractstone> it's really easy to do this sort of thing in HTML, it's just that I want to use haskell instead of javascript
12:25:30 <McManiaC> abstractstone: you can create HTML via haskell ;)
12:25:40 <McManiaC> Text.Blaze is awesome
12:26:27 <revenantphx> :t sequence
12:26:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:26:33 <revenantphx> ...heh?
12:27:00 <ClaudiusMaximus> abstractstone: i started playing around with LaTeX -> PNG using the recipes here, fwiw: http://meta.wikimedia.org/wiki/Help:Displaying_a_formula#Diagrams_in_TeX
12:27:42 <abstractstone> ClaudiusMaximus: cool thanks, ill keep that bookmarked
12:29:46 <Cale> abstractstone: Are you Paul Taylor? (Your nick reminds me of http://www.paultaylor.eu/ASD/ :)
12:30:13 <abstractstone> Cale: heh no I was just reading that book when  I had to choose a nick
12:31:07 <monochrom> haha
12:31:57 <ClaudiusMaximus> abstractstone: probably you could use: http://hackage.haskell.org/packages/archive/gtk/0.12.0/doc/html/Graphics-UI-Gtk-Scrolling-ScrolledWindow.html#v:scrolledWindowAddWithViewport
12:33:30 <abstractstone> ClaudiusMaximus: oh great! that works perfectly, thanks a lot
12:36:42 <ClaudiusMaximus> abstractstone: :)
12:37:17 <ClaudiusMaximus> abstractstone: just tried it here too, only slight wart is tiny minimum/default vertical size, but that's fixable i guess
12:37:59 <abstractstone> ClaudiusMaximus: this is great, I have literally been stuck on this for days!
12:39:49 <revenantphx> Hm
12:40:01 <revenantphx> so if I have this
12:40:01 <revenantphx> https://gist.github.com/718247
12:40:04 <revenantphx> very simple and such.
12:40:41 <revenantphx> How would I, starting from within the IO monad, create a new STCell and do some stuff to it.
12:41:55 <Phyx-> @hoogle withTempFile
12:41:56 <lambdabot> No results found
12:42:24 <mauke> :t runST
12:42:25 <lambdabot> forall a. (forall s. ST s a) -> a
12:42:47 <povik1> hi
12:42:50 <mauke> @hoogle a -> STRef s a
12:42:50 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
12:42:51 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
12:42:51 <lambdabot> Data.Graph.Inductive.Monad delNodeM :: GraphM m gr => Node -> m (gr a b) -> m (gr a b)
12:43:28 <mauke> @hoogle a -> ST s (STRef s a)
12:43:29 <lambdabot> Data.STRef newSTRef :: a -> ST s (STRef s a)
12:43:29 <lambdabot> Data.STRef.Lazy newSTRef :: a -> ST s (STRef s a)
12:43:33 <revenantphx> I know I'd use runST
12:44:17 <mauke> do { cell <- newSTRef (Cell 0 False False); ... }
12:49:07 <revenantphx> :\
12:49:18 <revenantphx> I'm still not seeing how to start a do block in the ST monad, from the IO monad.
12:49:40 <mauke> uh, you start a do block with 'do'
12:49:45 <revenantphx> Well, yes.
12:49:55 <revenantphx> As in
12:49:58 <revenantphx> main = do
12:50:03 <revenantphx>     some stuff....
12:50:12 <revenantphx>     {-- want ST code here --}
12:50:17 <revenantphx>     other stuff...
12:50:25 <revenantphx> the ST code would have to be inside its own do block
12:50:33 <revenantphx> I just don't know how to do that >_>
12:50:46 <mauke> what would the ST code do?
12:50:59 <revenantphx> This is just to test, but create a reference, and then modify it a bit.
12:51:03 <revenantphx> with some functions.
12:51:19 <revenantphx> newSTRef, modifySTRef mainly.
12:51:31 <mauke> and then what?
12:51:37 <revenantphx> That's all.
12:51:45 <revenantphx> I'm just trying to test a really simple case.
12:51:48 <mauke> that's equivalent to 'return ()'
12:51:51 <revenantphx> sure.
12:52:23 <revenantphx> Is stToIO what I want?
12:52:35 <mauke> how do you do calculations in the IO monad?
12:52:44 <mauke> define some variables, add and multiply, ...
12:52:52 <revenantphx> mm.
12:53:44 <revenantphx> ...and
12:56:08 <McManiaC> hmmm
12:56:19 <McManiaC> who do I have to kill to get my link onto reddit? :>
12:57:47 * revenantphx is still not getting an answer.
12:58:33 <revenantphx> I'm just going to put all of the ST stuff within another function which I can call nicely from the ST monad...
12:58:37 <revenantphx> IO monad*
13:00:09 <revenantphx> I think part of my problem is I'm still stuck thinking imperatively.
13:00:25 <revenantphx> I find myself wanting to have functions that do nothing but side effects related to my model :\
13:00:57 <mauke> ST is for pure computations that use mutable variables internally
13:01:24 <mauke> so you have some function Foo -> Bar but the algorithm it uses is imperative
13:01:56 <Botje> if you're already in IO, you might as well use IORefs
13:05:27 <taktoa> I've been working on a haskell mandelbrot generator implementation
13:05:45 <taktoa> using OpenCL through Python for GPGPU acceleration
13:05:56 <taktoa> here's my code: http://z7b08q.bay.livefilestore.com/y1pYngz4olYqRaLHg2er3FlFdcqU6noW2uvIGsugkpmrXohfEOqyqR6emsFDIgdUMCg47e37gRMFGst9VNafQDtbeNboz4DyGoP/mandelbrot.tar.gz?download&psid=1
13:06:14 <taktoa> however, the output is very strange
13:06:14 <revenantphx> mauke: My issue is, I'm trying to work with a large body of mutable state.
13:06:23 <revenantphx> And I'm not sure how to put together the "outside"
13:06:24 <taktoa> almost... aricebo-message-like
13:06:35 <taktoa> the output is included in that archive
13:06:53 <taktoa> can anyone figure out why this is happening
13:07:08 <taktoa> *s/$/?/g
13:08:07 <taktoa> I suspect it has to do with the parallel nature of the graphics card, which accordingly outputs the pixels in somewhat random order
13:08:21 <taktoa> but I wouldn't know how to fix that...
13:09:13 <abstractstone> how does one get the text printed by a command from rawSystem?
13:09:49 <mauke> by not using rawSystem
13:10:15 <taktoa> also, does anyone have experience with using the OpenCLRaw library in haskell?
13:10:33 <taktoa> any source code relating to it would be very helpful
13:13:02 <revenantphx> mauke: I guess I'm looking for something like atomically for ST.
13:13:35 <mauke> why are you using ST instead of IO?
13:13:55 <kmc> revenantphx, it is impossible for two threads of execution to see the same STVars
13:13:59 <kmc> unless you're cheating
13:14:04 <kmc> so what good would "atomically" do?
13:14:05 <revenantphx> Because I'm trying to learn how to use ST >_>
13:14:11 <revenantphx> kmc: just as an example 
13:14:15 <kmc> ?
13:14:28 <revenantphx> STM a -> IO () vs ST s a -> IO ()
13:14:36 <revenantphx> It's not relevant at this point.
13:14:44 <revenantphx> I might as well try to write this entirely functionally.
13:14:47 <kmc> stToIO :: ST RealWorld a -> IO a
13:14:53 <kmc> but this has nothing to do with concurrency or transactions
13:14:57 <revenantphx> no no, not at all
13:14:57 <kmc> which is the whole point of "atomically"
13:15:00 <revenantphx> I know that
13:15:03 <kmc> ok
13:15:08 <revenantphx> I just meant in terms of it transitioning between monads.
13:15:11 <kmc> sure
13:15:12 <revenantphx> I just want to do it in constant space.
13:15:14 <kmc> then stToIO is the thing
13:15:27 <revenantphx> since with 10000 timesteps... heh
13:15:31 <kmc> run-time no-op!
13:15:40 <revenantphx> I'll come back to this in a bit allright?
13:15:42 <revenantphx> I have to go for a bit.
13:15:49 <kmc> enjoy
13:15:50 <revenantphx> I'm trying to implement my simulation.
13:28:14 <abstractstone> ClaudiusMaximus: is this useful to you? http://i.imgur.com/oRfnu.png
13:29:53 <ClaudiusMaximus> abstractstone: nice! yeah something like that would be cool to have
13:30:25 <abstractstone> here is the code http://pastebin.com/PseiRDYA - thanks again for making it happen!
13:33:04 <ClaudiusMaximus> abstractstone: cool!   i'll be using it for converting external angles (rationals in (0..1)) to angled internal addresses; something like: 41%255 -> http://img84.imageshack.us/img84/1978/example0.png
13:34:06 <abstractstone> is that something to do with the mandelbrot?
13:34:57 <ClaudiusMaximus> abstractstone: yes
13:35:05 <abstractstone> cool
13:35:44 <ClaudiusMaximus> abstractstone: still stuck on finding the 'c' value corresponding to an angled internal address, it seems a Hard Problem...
13:35:52 <unkanon> abstractstone: that's all the code you need to make that program you linked to the screenshot?
13:36:02 <abstractstone> unkanon: yes
13:36:18 <abstractstone> it requires the texvc program though
13:36:19 <unkanon> abstractstone: that's pretty cool (the code and the program)
13:37:12 <abstractstone> ClaudiusMaximus: is it something to do with solving the zeros of the polynomials z^2+z, (z^2+z)^2+z, ...?
13:37:32 <abstractstone> unkanon: I am happy it's done so I can work on the interesting part now ;)
13:37:54 <ClaudiusMaximus> abstractstone: http://arxiv.org/abs/math/9411238v2
13:38:14 <unkanon> abstractstone: which is?
13:38:57 <abstractstone> unkanon: making it compute things
13:39:23 <unkanon> hmm
13:43:12 <uaehcf> > [1..20]
13:43:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
13:43:30 <aristid> > [20,19..1]
13:43:31 <lambdabot>   [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
13:44:06 <unkanon> > [1,1,2,3,5,8,13..]
13:44:08 <lambdabot>   <no location info>: parse error on input `..'
13:44:21 <aristid> unkanon: it is very limited :)
13:44:32 <aristid> @oies 1,1,2,3,5
13:44:33 <lambdabot>  Sequence not found.
13:44:40 <aristid> @oies 1,1,2,3,5,8
13:44:40 <lambdabot>  Sequence not found.
13:44:42 <unkanon> I wasn't expecting t to get it right :)
13:44:48 <unkanon> s/t/it/
13:45:09 <unkanon> @oies 0,1,1,2,3,5,8
13:45:10 <lambdabot>  Sequence not found.
13:45:41 <mauke> @oeis 1 1 2 3 5
13:45:42 <lambdabot>  Sequence not found.
13:45:48 <mauke> you're broken!
13:45:55 <unkanon> maybe we just don't know the syntax?
13:46:00 <unkanon> I certainly don't
13:46:22 <unkanon> @oeis fibonacci
13:46:23 <lambdabot>  Sequence not found.
13:47:08 <unkanon> @oies 1,2,3,4,5
13:47:08 <lambdabot>  Sequence not found.
13:47:09 <Gracenotes> @oeis 1,2,3,6,11,23,47,106,235
13:47:09 <lambdabot>  Sequence not found.
13:47:12 <Gracenotes> o_o
13:49:06 <povik> > [1..]
13:49:07 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
13:49:13 <povik> hm :)
13:51:53 <Phyx-> @hoogle bracket
13:51:54 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:51:54 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:51:54 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
13:52:34 <Phyx-> what a pain...
13:53:27 <Phyx-> is bracket the same in new and old exception?
13:54:24 <Cale> I think it probably catches the same exceptions... it's the one in System.IO that you have to watch out for, I think.
13:54:48 * Cale tests
13:55:24 <Manifesto_> how can I see the source code of Data.Lista, for example?
13:56:27 <Manifesto_> sorry, Data.List
13:56:31 <Phyx-> Manifesto_: http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-List.html
13:56:34 <Cale> Manifesto_: Go to the documentation and click the source links on the right
13:56:38 <Phyx-> click on the source code link
13:56:38 <McManiaC> http://blog.n-sch.de/2010/11/27/rebindable-if-then-else-statements/ :)
13:57:28 <Manifesto_> tyvm
13:57:31 <Cale> McManiaC: s/if statement/if expression/
13:57:57 <Phyx-> oh and ty Cale 
13:58:03 <McManiaC> Cale: oops
13:58:03 <McManiaC> :)
13:58:19 <Phyx-> i've been wrapping IO calls all day
13:58:30 <Phyx-> soon i'll start side effecting myself
14:00:40 <Cale> Phyx-: So, the bracket from System.IO won't catch the exceptions from Control.Exception
14:01:09 <Cale> (but I believe the one from Control.Exception will catch errors thrown by System.IO)
14:01:18 <Cale> Let me see about OldException
14:02:32 <uaehcf> > [x*2 | x <- [1..10]]
14:02:33 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:03:06 <Cale> Okay, Exception and OldException are mutually compatible
14:03:23 <Cale> (either bracket will catch errors thrown by the other library)
14:10:19 <Manifesto_> I'm having trouble updating cabal. It fails when updating zlib-0.5.2.0, any one knows beforehand what could it be?
14:11:22 <rgrig> randomly looking at http://darcs.haskell.org/packages/base/Data/List.hs I see "unlines (l:ls) = l ++ '\n' : unlines ls" which doesn't typecheck. how could that be?
14:12:09 <Botje> if ++ has lower precedence than : it typechecks
14:12:40 <mauke> :t ?l ++ '\n' : unlines ?ls
14:12:41 <lambdabot> (?ls::[String], ?l::[Char]) => [Char]
14:13:19 <dcoutts_> Botje: they have the same precedence, right associative
14:13:31 <Botje> ah
14:13:33 <dcoutts_> rgrig: as Botje says, it does actually type check
14:13:35 <Botje> then it's still okay :)
14:13:38 <rgrig> ah.. i keep mixing ' with " writing python
14:13:54 <dcoutts_> @type '\n'
14:13:54 <lambdabot> Char
14:13:57 <rgrig> i typed it wrongly (didn't copy&paste)
14:13:57 <dcoutts_> @type "\n"
14:13:58 <lambdabot> [Char]
14:16:06 <Cale> Yeah, the reason that version is more efficient is because of that right-association.
14:16:50 <Cale> You're not walking down each string in the list twice (once to add the '\n' to the end, and then again for concatenation)
14:17:05 <osaunders> OK, just to get this straight when I say:
14:17:06 <osaunders> process :: Show a => String -> a
14:17:06 <osaunders> process = lines
14:17:06 <osaunders> and I get a type error ("a is a rigid type variable[...]") that's because it doesn't know that the «a» I'm using is the same as what «lines» outputs? The «a» I specified is supposed to be specialized by arguments?
14:17:43 <Cale> osaunders: The type signature you've written means that process could produce a value of any type I demand, so long as that type is an instance of Show
14:17:57 <Cale> So, I could request  process "foo" :: Integer
14:18:12 <Cale> and that ought to work according to the type signature you gave
14:18:20 <Cale> (at least, it ought to typecheck)
14:18:40 <osaunders> Hmm
14:18:40 <Cale> But lines won't produce an Integer.  lines :: String -> [String]
14:19:02 <osaunders> So is there a way of saying "just infer this"?
14:19:05 <Cale> lines isn't polymorphic enough
14:19:08 <Cale> No.
14:19:24 <osaunders> ...other than leaving the type sig off.
14:19:27 <Cale> You can delete the type signature, and ask ghci to infer the type, and then paste it back into the code.
14:20:50 <osaunders> So when it says it can't match «a» against «[String]» what does that really mean?
14:21:09 <osaunders> Oh OK dw.
14:21:20 <Cale> Yeah, I sorta just explained that :)
14:21:24 <osaunders> It means lines outputs «[String]» and not «a».
14:21:26 <Cale> right
14:21:36 <osaunders> I still get confused by this.
14:22:09 <osaunders> I keep thinking «a» should mean anything so why doesn't it match «[String]».
14:22:17 <Cale> and the 'a' is rigid because it was specified in the type signature -- it can't just be equated with some monomorphic type (like it could if the type sig was missing)
14:22:41 <pww> jee golly. what a neat language
14:23:08 <osaunders> Cale: What would happen if it could?
14:23:19 <remy_o> osaunders: String -> a is like "forall a, String -> a"
14:23:33 <mauke> foralls would become existss
14:23:47 <Cale> osaunders: You mean, what would happen if GHC just glossed over the problem and let the program run?
14:24:25 <osaunders> Cale: Sorta yeah, what would it screw up?
14:24:47 <Cale> osaunders: Then I could call your function process using Integer in place of 'a', and what would happen is that the list of lines produced by lines would get treated as an Integer value, and all hell would break loose (probably Segfault)
14:25:29 <Cale> We can find out exactly what would happen using unsafeCoerce, if you like :)
14:26:09 <osaunders> OK so «a» really means it is specialized by how it is used.
14:26:17 <osaunders> Not by how it is defined.
14:26:40 <osaunders> Cale: Hehe, I don't think that will be necessary :-)
14:27:11 <Cale> lol, it does weird stuff
14:27:27 <osaunders> Oh? I'm curious now.
14:27:35 <Cale> ghci> process "foo" :: Integer
14:27:35 <Cale> -^Chmm... Interrupted.
14:27:39 <Cale> It prints -
14:27:45 <Cale> (a single hyphen)
14:27:56 <osaunders> lol
14:27:57 <Cale> and then when I tried to ^C, it waited for about a second or two
14:28:07 <mauke> so we know it's negative!
14:28:19 <Cale> heh, yeah, I guess that's what it means :)
14:28:36 <osaunders> lol, sweet
14:28:41 <osaunders> I always wanted to know that!
14:29:22 <Cale> When compiled, it seems to just eat lots and lots of memory, and not die with ^C
14:30:03 <mauke> file a bug!
14:30:23 <Cale> Haskell programs in the presence of unsafeCoerce behave like C programs do ;)
14:30:32 <djahandarie> I don't think behavior when using unsafeCoerce in stupid ways constitutes a bug report :P
14:30:59 <osaunders> Are there sensible uses for unsafeCoerce?
14:32:43 <Jiten> just guessing but perhaps it's useful for debugging?
14:32:49 <pww> WHY does google display insta find for a second and then closes it and tells me it was too slow?
14:32:53 <pww> STUPID google :/
14:36:14 <pww> does ghci have a startup file (like a .ghcirc or something)?
14:36:44 <osaunders> pww: .ghci
14:36:45 <pww> oh, ok. there it is
14:36:49 <pww> ~/.ghci
14:38:35 <hatds> what happens when you read from a Chan created by dupChan.. does it remove the value from both Chans?
14:39:17 <ddarius> Jiten: No, it isn't.
14:42:25 <rgrig> osaunders, it's used in Data.Typeable, for example. That module offers a (safe) cast operation that rewuire either compiler support or the use of unsafe*
14:43:16 <ddarius> You can provide something with a similar interface without compiler support or unsafeCoerce.
14:43:39 <rgrig> ddarius, I guess you should do it, then.
14:44:01 <ddarius> Why?
14:44:40 <rgrig> ddarius, wouldn't it be nicer to not use unsafeCoerce if it's not needed?
14:45:10 <rgrig> btw, the place that claimes this is needed is http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/hmap.ps (a paper by lammel and peyton jones)
14:45:36 <rgrig> it's from 2003 so perhaps things changed
14:46:34 <ddarius> The unsafeCoerce version is much faster and a bit more flexible, but really, we all rely on Simon not messing up the equivalent of unsafeCoerce in much more complicated situations all them time, so...
14:47:26 <rgrig> faster and more flexible than what? I'm not aware of an altrenative implementation.
14:47:44 <ddarius> @google a lightweight implementation of generics and dynamics
14:47:45 <lambdabot> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.19.7113
14:48:30 <rgrig> ddarius, thanks
14:49:20 <lewis1711> where can one find info on the implementation of haskell? I am curious as to whether tuples are contiguous in memory or more like a heterogeneous linked list.
14:50:00 <roconnor> lewis1711: they are like linked lists
14:50:00 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
14:50:42 <lewis1711> roconnor: and lists as well I imagine are linked lists?
14:50:49 <ddarius> They are like neither.
14:51:11 <roconnor> lewis1711: oh right
14:51:20 <ddarius> n-tuples are arrays of pointers to the components.  The pointers are more or less contiguous in memory, the components are anywhere.
14:51:25 <roconnor> lewis1711: a tuple of size n has a continguous memory of n points
14:51:30 <roconnor> *pointers
14:51:38 <lewis1711> ah
14:51:59 <ddarius> An unboxed tuple is just a contiguous allocation of its components (modulo alignment issues potentially)
14:52:55 <lewis1711> similar to structs in C-likes then (at least at my level of understanding)
14:53:00 <lewis1711> what of lists?
14:54:04 <roconnor> lewis1711: lists are like linked lists, though laziness gives them pecular properties
14:54:11 <ddarius> lewis1711: Lists are definable in Haskell.  Their representation follows from the representation of algebraic data types.  (Also, to add the caveat after the fact, all this is implementation defined, though there are obvious implementations)
14:57:26 <lewis1711> right, ty roconnor and ddarius:) gives me enough to go on for now
15:02:38 <Manifesto> anyone using criterion?
15:03:40 <byorgey> Manifesto: if you have a question about criterion, it's better to just ask the question than to ask whether anyone is using it.
15:03:59 <byorgey> (but ignore me if you really do just want to know whether anyone is using it, to which I am sure the answer is "yes". ;)
15:08:04 <revenantphx> quick check
15:08:13 <revenantphx> listenOn (PortNumber 9900) >>= acceptConnections 
15:08:16 <revenantphx> is equivalent to
15:08:29 <Manifesto> agreed.
15:08:33 <Manifesto> sorry about that.
15:08:37 <revenantphx> do {sock <- listenOn (PortNumber 9000); acceptConnections sock;}
15:08:44 <ddarius> Yes.
15:09:52 <revenantphx> Just need to remember that >>= passes on a value, >> does not.
15:10:19 <mauke> @redo listenOn (PortNumber 9900) >>= acceptConnections 
15:10:20 <lambdabot> Maybe you meant: do read todo undo
15:10:27 <mauke> @do listenOn (PortNumber 9900) >>= acceptConnections 
15:10:27 <lambdabot> do { a <- listenOn (PortNumber 9900); acceptConnections a}
15:10:36 <revenantphx> :O
15:10:39 <revenantphx> that's useful
15:10:45 <revenantphx> @redo { a <- listenOn (PortNumber 9900); acceptConnections a}
15:10:45 <lambdabot> Maybe you meant: do read todo undo
15:10:48 <revenantphx> @undo { a <- listenOn (PortNumber 9900); acceptConnections a}
15:10:49 <lambdabot>  Parse error at "{" (column 1)
15:10:59 <revenantphx> @undo do { a <- listenOn (PortNumber 9900); acceptConnections a}
15:10:59 <lambdabot> listenOn (PortNumber 9900) >>= \ a -> acceptConnections a
15:11:03 <revenantphx> That's useful :3
15:11:13 <revenantphx> Alright, I've decided.
15:11:15 <mauke> @. pl undo do { a <- listenOn (PortNumber 9900); acceptConnections a}
15:11:15 <lambdabot> acceptConnections =<< listenOn (PortNumber 9900)
15:11:21 <revenantphx> I'm gonna get myself a personal lambdabot.
15:11:32 <revenantphx> Keep him in a little widget on my desktop.
15:11:36 <revenantphx> I'll call him Clive ^_^
15:11:40 <ddarius> You can private message lambdabot.
15:11:44 <revenantphx> (but with a lambda instead of an l)
15:11:59 <revenantphx> I want to run him standalone without irc.
15:12:16 <djahandarie> Just integrate yourself into IRC like the rest of us have
15:12:24 <aavogt> @vixen are you a him?
15:12:24 <lambdabot> yes, i am
15:12:24 <revenantphx> >_>...
15:12:24 <ddarius> lambdabot is a her.
15:12:29 <uaehcf> its a female
15:12:29 <revenantphx> ddarius: I know.
15:12:33 <monochrom> pointfree socket operations? :)
15:12:33 <revenantphx> But Clive would not be.
15:12:55 <revenantphx> I still dont get why it's called pointfree style.
15:13:09 <uaehcf> bc theres no point to it
15:13:09 <mauke> because it has no points
15:13:23 <mauke> function parameters are points
15:13:24 <monochrom> "they call me Clive. they call me Jacky. they call me Jane. ... That's not my name! That's not my name! That's not my! name!"
15:13:28 <ousado> mauke: why not elephant free style then?
15:13:29 <revenantphx> mauke: gotcha.
15:13:39 <revenantphx> monochrom: I'm sorry. What?
15:13:45 <monochrom> just joking
15:13:50 <taktoa> I keep getting this error when I try to install a package in cabal: "Cabal-1.8.0.6 is unusable due to missing or recursive dependencies: directory-1.0.1.2 process-1.0.1.3"
15:13:59 <maurer_> So, I hear GHC 7 is out--do we have the same library incompatibility clusterfuck we had last time we upgraded base?
15:13:59 <revenantphx> @quote sillymonochrome "they call me Clive. they call me Jacky. they call me Jane. ... That's not my name! That's not my name! That's not my! name!"
15:14:00 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
15:14:04 <revenantphx> D:
15:14:09 <revenantphx> @list
15:14:09 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:14:20 <revenantphx> @remember sillymonochrome "they call me Clive. they call me Jacky. they call me Jane. ... That's not my name! That's not my name! That's not my! name!"
15:14:20 <lambdabot> It is stored.
15:14:25 <revenantphx> @quote sillymonochrome
15:14:26 <lambdabot> sillymonochrome says: "they call me Clive. they call me Jacky. they call me Jane. ... That's not my name! That's not my name! That's not my! name!"
15:14:52 <gwern> @quote monochrom
15:14:53 <lambdabot> monochrom says: ...but you could impose a "maximal slurp" rule
15:15:06 <revenantphx> shit I put monochrome...
15:15:16 <revenantphx> @ghc
15:15:16 <lambdabot> ghc says: GHC's heap exhausted
15:15:25 <revenantphx> @forget sillymonochrome
15:15:25 <lambdabot> Incorrect arguments to quote
15:15:27 <luite> maurer_: most things still seem to work, but I think beginners should wait a bit before upgrading :)
15:15:36 <mauke> (reference: http://www.youtube.com/watch?v=v1c2OfAzDTI )
15:15:51 <revenantphx> @pretty
15:15:52 <dcoutts_> taktoa: use ghc-pkg check, reinstall any broken packages. Also check if you've got the same versions of libs registered in both the global and user package dbs, that confuses cabal.
15:16:05 <revenantphx> @do a >> b >> c >>= d >>= e
15:16:05 <lambdabot> do { f <- do { f <- do { do { a; b}; c}; d f}; e f}
15:16:11 <gwern> revenantphx: @forget requires the exact name and quote to forget
15:16:15 <revenantphx> ah k
15:16:23 <dcoutts_> maurer_: last time we upgraded base not that much broke actually and ghc came with both base 3 and 4 for two whole releases.
15:16:25 <revenantphx> @forget sillymonochrome "they call me Clive. they call me Jacky. they call me Jane. ... That's not my name! That's not my name! That's not my! name!"
15:16:25 <lambdabot> Done.
15:16:27 <gwern> revenantphx: what would that do, forget everything attributed to sillymonochrome? dangerous
15:16:43 <dcoutts_> maurer_: perhaps you're remembering the base 2 -> 3 transition
15:16:47 <revenantphx> @remember monochrom "they call me Clive. they call me Jacky. they call me Jane. ... That's not my name! That's not my name! That's not my! name!"
15:16:47 <lambdabot> Okay.
15:16:50 <revenantphx> @quote monochrom
15:16:50 <lambdabot> monochrom says: Teach a man succ, and he understands Peano for a day; teach him induction, and he understand Peano for life?
15:16:56 <fxr> hmm I think Control.Parallel.Strategies has problems with ghc 7.0.1.
15:16:59 <revenantphx> @quote monochrom
15:16:59 <lambdabot> monochrom says: Well I was writing Windows apps in C since the days of Windows 3.0 and I tell you it's very OO.
15:17:09 <maurer_> dcoutts_: Maybe I'm misremembering, but I thought that with some version of ghc, I installed it, only to find that in order to get it to do things I had to manually patch network and a number of other core packages.
15:17:10 <revenantphx> @quote revenantphx
15:17:10 <lambdabot> No quotes match. That's something I cannot allow to happen.
15:17:13 <revenantphx> TT_TT
15:17:32 <pkrumins> Hey guys, I am making one of my programs safer in a sense that I am catching all exceptions, and in this one place I just want program to continue working in case of an exception (it's a putStrLn), I wonder if there is a simpler way to do it than "catch (putStrLn "Listening on port 6000") (\e -> return())"
15:17:35 <mauke> preflex: quote monochrom 
15:17:35 <preflex>  <monochrom> einstein's theory implies that haskell cannot be faster than c
15:17:40 <maurer_> dcoutts_: It was fixed a month or so later, but I was just checking whether I was going to be in for a world of hurt before trying 7.0.1
15:17:51 <gwern> @quote gwern
15:17:51 <lambdabot> gwern says: if hlist is the answer, I don't want to know the question
15:18:00 <medfly> hahaha
15:18:08 <dcoutts_> maurer_: ah ok, yeah, if you don't want to fix stuff then I'd wait for the HP release
15:18:13 <revenantphx> @quote spj
15:18:13 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
15:18:26 <maurer_> dcoutts_: I'm cool with fixing stuff, I just don't want to have to repair everything :P
15:18:34 <revenantphx> @quote penis
15:18:34 <lambdabot> Vellos says: I TYPE IN CAPS BECAUSE I WANT ALL THESE PIXELS TO ADD TO MY PENIS LENGTH
15:18:48 <revenantphx> @help quote
15:18:49 <lambdabot> quote <nick>
15:18:49 <lambdabot> remember <nick> <quote>
15:18:49 <lambdabot> Quote somebody, a random person, or save a memorable quote
15:19:09 <revenantphx> Odd, how is it that his name is Vellos but the quote is under "penis"
15:19:22 <dcoutts_> maurer_: people have already built a few non-trivial things so it's probably not too bad, I've not tried myself
15:19:28 <revenantphx> @quote hopscotch
15:19:28 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
15:19:32 <mauke> revenantphx: because @quote does a regex search
15:19:33 <revenantphx> Oh, it looks it up.
15:19:35 <luite> is a ghc 7.0.2 release planned before the next haskell platform?
15:19:37 <uaehcf> quote mauke
15:19:42 <revenantphx> @quote girth
15:19:43 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
15:19:45 <ion> revenantphx: The bot is intelligent and it notices Vellos is a bit like phallos which is a bit like penis.
15:19:55 <uaehcf> @quote mauke
15:19:55 <lambdabot> mauke says: Fire Lord Okasaki
15:19:57 <monochrom> pkrumins: «try (putStrLn "Listening on port 6000")». It gives you IO (Either exception ()), so you can care or ignore.
15:19:59 <revenantphx> @remember GaryOak "You cannot deny my girth"
15:19:59 <lambdabot> It is forever etched in my memory.
15:20:17 <pkrumins> monochrom: thanks!
15:20:27 <uaehcf> @remember monochrom "It gives you IO"
15:20:27 <lambdabot> Nice!
15:20:34 <monochrom> ...
15:20:37 <mauke> @forget GaryOak "You cannot deny my girth"
15:20:37 <lambdabot> Done.
15:20:42 <mauke> @forget monochrom "It gives you IO"
15:20:42 <lambdabot> Done.
15:20:49 <monochrom> now look who's being silly :)
15:21:01 <maurer_> pkrumins: "catching all exceptions" is generally a bad idea.
15:21:16 <monochrom> this one is fine.
15:22:05 <pkrumins> one more question - how to wrap exception catching of `socket <- listenOn port` statement, since listenOn can fail
15:22:41 <mauke> depends on what you want to do when it fails
15:22:49 <revenantphx> Is this good code guys?
15:22:50 <revenantphx> https://gist.github.com/718379
15:22:53 <pkrumins> catch the exception, write it to a file
15:23:04 <monochrom> twocases <- try (listenOn port); case twocases of { Left e -> ... ; Right socket -> ... }.  There are other approaches.
15:23:05 <revenantphx> Should I try/except every line
15:23:08 <revenantphx> bbl
15:23:20 <pkrumins> monochrom: aha!
15:23:33 <mauke> pkrumins: yeah, but where should execution continue?
15:23:46 <pkrumins> mauke: oh it was in putStrLn code
15:24:07 <pkrumins> if I launch the process as a daemon there is no stdout, and haskell program just quits on putStrLn
15:24:20 <pkrumins> but for deb ugging I run it with stdout open
15:24:22 <monochrom> Another approach is try (do socket <- listenOn port; .... ) or catch ( do socket <- listenOn port; ) (\e -> xxx).  Depends on how you like your program structured.
15:24:31 <mauke> what do you mean there is no stdout?
15:24:36 <mauke> why is there no stdout?
15:24:37 <pkrumins> so then putStrLn works. but now I know I can do it with "try (putStrLn ...)"
15:24:41 <pkrumins> mauke: cause it's closed
15:24:43 <monochrom> err, catch ( do socket <- listenOn port; ... ) (\e -> xxx)
15:24:46 <mauke> why are you closing stdout?
15:25:03 <pkrumins> mauke: this is a windows program actually and windows closes it if I spawn the process as SW_HIDE
15:25:17 <mauke> ok, that sort of makes sense
15:25:33 <pkrumins> mauke: also daemon processes on Unix close stdout, don't they?
15:25:41 <mauke> no
15:25:50 <mauke> they generally just redirect to /dev/null
15:25:52 <pww> i thought they redirected
15:25:57 <pkrumins> oh yeah
15:25:59 <pww> or a log
15:26:00 <pkrumins> i forgot.
15:26:04 <pww> but most use syslog
15:26:04 <mauke> otherwise the next file you open will be fd 1, i.e. STDOUT
15:26:09 <pww> instead of their own log
15:26:38 <pkrumins> oh yeah
15:26:46 <pkrumins> that's right.
15:27:04 <pkrumins> monochrom: thanks for the tips
15:32:13 <revenantphx> @quote zen
15:32:14 <lambdabot> sethg says: I feel like I still don't understand comonads.  Maybe I just need a Zen comaster to hit me with a costick and then I'll become coenlightened.
15:32:18 <revenantphx> Lol, random word.
15:34:15 <revenantphx> What's the different between 'import Monad' and 'import Control.Monad
15:34:20 <revenantphx> are they the same?
15:34:30 <revenantphx> I mean, is Monad an alias?
15:34:35 <revenantphx> I also see List instead of Data.List
15:34:38 <aavogt> Monad is H98
15:34:56 <aavogt> the hierarchial module names are more recent (and contain more stuff)
15:35:01 <revenantphx> oic
15:35:18 <aavogt> so importing List won't get you things like  permutations
15:35:56 <revenantphx> Where is Network now?
15:36:01 <revenantphx> Is it its own top level package?
15:36:16 <aavogt> not everything got put under Control, Data and so on
15:36:50 <dskippy> I am trying to create an 201x201 matrix of Ints. It is represented as lists and I have some code turning it into an array. When I load this module I get "ghc: panic! (the 'impossible' happened)" Is a 201x201 matrix too big for GHCI? It should be 161KB, I think.
15:37:35 <Axman6> remember that boxed arrays (Array) have quite a bit of overhead
15:37:48 <revenantphx> One other thing.
15:37:53 <revenantphx> er, lets see
15:37:56 <revenantphx> @hoogle sockopt
15:37:56 <lambdabot> No results found
15:38:00 <revenantphx> @hoohle setsockopt
15:38:01 <lambdabot> No results found
15:38:06 <revenantphx> @hoogle setSockOpt
15:38:06 <lambdabot> No results found
15:38:10 <dskippy> Axman6: I don't want to modify this at all. How do I make an unboxed array?
15:38:12 <pww> nothing like spending all saturday night scratching your own leg. ahhhh, weekends :)
15:38:15 <revenantphx> @hoogle setSocketOption
15:38:16 <lambdabot> Network.Socket setSocketOption :: Socket -> SocketOption -> Int -> IO ()
15:38:17 <revenantphx> :D
15:38:38 <revenantphx> @where setSocketOption
15:38:38 <lambdabot> I know nothing about setsocketoption.
15:38:46 <revenantphx> I want link
15:38:50 <mauke> to what?
15:38:59 <revenantphx> A haddock page containing thast
15:39:02 <revenantphx> @list
15:39:02 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:39:12 <aavogt> @hackage network
15:39:12 <lambdabot> http://hackage.haskell.org/package/network
15:39:13 <revenantphx> @haddock Network
15:39:13 <lambdabot> Unknown command, try @list
15:39:18 <revenantphx> tyvm
15:39:31 <revenantphx> The new haddock is very clean.
15:39:48 <aavogt> the old stylesheet is cleaner
15:39:51 <mauke> preflex: calc (201*4*2+4)*201+4 / 1024
15:39:51 <preflex>  324012.00390625
15:39:54 <mauke> preflex: calc (201*4*2+4)*201+4 / 1024 / 1024
15:39:55 <preflex>  324012.0000038147
15:40:04 <mauke> preflex: calc (201*4*2+4)*201+4) / 1024 
15:40:04 <preflex>  316.421875
15:40:20 <revenantphx> preflex: calc 1 + 1
15:40:20 <preflex>  2
15:40:22 <revenantphx> :D
15:40:30 <revenantphx> preflex: calc 2^2
15:40:31 <preflex>  4
15:40:40 <revenantphx> preflex: calc -1^(1/2)
15:40:40 <preflex>  Not enough mana
15:41:04 <pkrumins> monochrom: for some reason «Prelude Control.Exception> try (putStrLn "hello")» gives error «Ambiguous type variable `e' in the constraint: `Exception e' arising from a use of `try' at <interactive>:1:0-21»
15:41:06 <Eduard_Munteanu> Heh, I didn't know that :)
15:41:24 <revenantphx> preflex: calc -1^(1/3)
15:41:25 <preflex>  Not enough mana
15:41:25 <aavogt> pkrumins: add a type signature
15:41:32 <revenantphx> preflex: calc sqrt(4)
15:41:33 <preflex>  2
15:41:35 <aavogt> @type Control.Exception.try
15:41:37 <lambdabot> forall a e. (GHC.Exception.Exception e) => IO a -> IO (Either e a)
15:41:45 <pkrumins> aavogt: how would that look? I don't really have 'e' anywhere.
15:42:03 <aavogt> something like     try (putStrLn "hello") :: IO (Either SomeException ())
15:42:07 <pkrumins> aavogt: ah!
15:42:11 <monochrom> yeah, Control.Exception is extremely general. there is a whole type class of different exceptions. so you have to say something.
15:42:18 <mauke> write your own try with a restricted type signature
15:42:36 <pkrumins> mauke: oh that would be pretty cool!
15:42:44 <mauke> tryAll :: IO a -> IO (Either SomeException a); tryAll = try
15:42:54 <pkrumins> :D
15:42:54 <aavogt> well presumably you go and do something with the caught exceptions, which will narrow down the type
15:42:56 <pkrumins> thanks!
15:43:10 <pkrumins> not in this case, i just throw it out
15:43:16 <pkrumins> i'll make it try'
15:43:17 <aavogt> it's for the better that code won't compile when it implicitly caught all exceptions
15:43:52 <aavogt> well maybe you only should catch IOException
15:44:06 <revenantphx> Haskell wouldn't have as many exceptions would it :\.
15:44:13 <revenantphx> They could only really occur with IO monad or something like that.
15:44:18 <revenantphx> Or maybe some complex math.
15:44:21 <aavogt> revenantphx: no it does
15:44:25 <monochrom> A councillor in Hong Kong became a laugh stick when he wanted to say "try our best" to English reporters but he erred and said "try our breast".  tryOurBreast :: IO a -> IO (Either OurBreast a)
15:44:28 <revenantphx> I'm just thinking, being pure and all.
15:44:41 <revenantphx> As long as inputs are sanitized from the real world, it should stay clean all the way through calls.
15:44:53 <Axman6> xceptions can be quite useful in haskell programs, i believe don stewart uses them to send messages between concurrent threads
15:45:02 <gwern> monochrom: a laugh stick?
15:45:04 <revenantphx> Axman6: What? D
15:45:05 <revenantphx> XD*
15:45:09 <Axman6> > [1..10] !! 11
15:45:10 <lambdabot>   *Exception: Prelude.(!!): index too large
15:45:20 * gwern is tempted to @quote that for the irony
15:45:29 <aavogt> laughing-stock
15:45:31 <monochrom> perhaps laughing stick? target of laughs
15:45:38 <monochrom> thanks.
15:45:42 <revenantphx> @remember Axman6 exceptions can be quite useful in haskell programs, i believe don stewart uses them to send messages between concurrent threads
15:45:42 <lambdabot> It is stored.
15:45:56 <Axman6> why would you remember that :\
15:45:57 <sannysanoff> hello gentlemen. I run into very straightforward performance problem. My code is following: (forever $ recvBufFrom rsocket buf 1500) and it iterates around 600 times / second, and takes 10-11 %cpu. Same C code takes 1 %cpu.  Shall I use erlang instead?
15:46:13 <Axman6> it's true, it's quite a handy technique
15:46:19 <monochrom> well, sending messages by exceptions is funny :)
15:46:19 <mauke> @forget Axman6 exceptions can be quite useful in haskell programs, i believe don stewart uses them to send messages between concurrent threads
15:46:20 <lambdabot> Done.
15:46:29 <revenantphx> Hey, It's funny > <
15:46:36 <mauke> how is it funny?
15:46:39 <adnap> What do you consider the best library for solving large systems of equations?
15:46:52 <monochrom> I use unix signal handlers to implement some weak form of mutable variable
15:46:54 <medfly> like, linear equations?
15:46:55 <revenantphx> You're using something for something it is not intended for in an amusing way.
15:47:02 <revenantphx> monochrom: that's also amusing;
15:47:05 <adnap> Yes, linear equations.
15:47:10 <adnap> Matrix problems
15:47:11 <gwern> mauke: it's saying we have no use for what exceptions are meant for, so we use it for something else instead
15:47:19 <mauke> but it's totally intended for that!
15:47:20 <revenantphx> gwern: precisely.
15:47:24 <medfly> adnap, so... you want some implementation of gauss jordan ?
15:47:26 <mauke> why else would we have throwTo?
15:47:37 <gwern> mauke: it's the same genre of humor as fruitcakes
15:47:38 <dskippy> My list of 201 lists of 201 Ints is also not readable in Haskell.
15:47:42 <mauke> but ok, I understand now
15:48:10 <adnap> Yeah, matrix solving routines.
15:48:26 <adnap> Not necessarily a specific one
15:48:30 <medfly> dunno. it seems like too little for a library...
15:48:37 <medfly> OK
15:48:41 <jmcarthur> > replicate 201 (replicate 201 ()) -- seems perfectly readable to me :D
15:48:42 <lambdabot>   [[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
15:48:47 <adnap> Well, data structures included and everything
15:48:57 <medfly> I dunno any libraries
15:48:59 <jmcarthur> oh Ints
15:49:09 <dskippy> jmcarthur: Can I pastebin a file and see if you can load it?
15:49:11 <jmcarthur> > replicate 201 (replicate 201 0)
15:49:12 <lambdabot>   [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
15:49:23 <jmcarthur> dskippy: oh is ghci not even loading it?
15:49:31 <Mitar> how can i document with haddock type class instance methods?
15:49:34 <jmcarthur> dskippy: i'll give it a shot if you'd like
15:49:39 <dskippy> jmcarthur: It loads. It's 201x201 hard-coded Ints
15:49:58 <revenantphx> Hm.
15:49:59 <dskippy> And when I try "myList !! 1 !! 200" it says "the impossible happend" and crashes
15:50:01 <revenantphx> I see functions in the form
15:50:04 <jmcarthur> :o
15:50:09 <revenantphx> func tuple@(part1, part2) =
15:50:11 <Axman6> > read . show . replicate 201 $ (replicate 201 7) :: [[Int]]
15:50:13 <abstractstone> p
15:50:13 <lambdabot>   [[7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7...
15:50:19 <revenantphx> Is that some way to bind the whole tuple AND its parts?
15:50:19 <jmcarthur> dskippy: what version of ghc?
15:50:27 <shachaf> > join (.) (replicate 201) () :-(
15:50:29 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
15:50:32 <Axman6> > last. read . show . replicate 201 $ (replicate 201 7) :: [[Int]]
15:50:33 <lambdabot>   *Exception: Prelude.read: no parse
15:50:34 <dskippy> jmcarthur: 6.12.1
15:50:35 <shachaf> > join (.) (replicate 201) () -- :-(
15:50:36 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:50:41 <adnap> Perhaps this: http://hackage.haskell.org/package/hmatrix-0.10.0.1
15:50:43 <Axman6> > last . read . show . replicate 201 $ (replicate 201 7) :: [[Int]]
15:50:44 <lambdabot>   *Exception: Prelude.read: no parse
15:50:51 <Axman6> > last . read . show . replicate 201 $ (replicate 201 7) :: [Int]
15:50:52 <lambdabot>   [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,...
15:51:06 <jmcarthur> dskippy: i have 6.12.3 and 7.0.1 handy
15:51:18 <dskippy> jmcarthur: I'll pastebin
15:51:24 <jmcarthur> hpaste please
15:51:30 <jmcarthur> i hate pastebin. so hard to read
15:51:33 <revenantphx> Oh, that @ is useful.
15:52:00 <lewis1711> less haskell tutorials should spend so long typing throwaway things into ghci.
15:52:16 <jmcarthur> > let foo a@(b,c) = (a, b, c) in foo (4,5)
15:52:17 <lambdabot>   ((4,5),4,5)
15:53:24 <McManiaC> how do you print out "{-# ... #-}" text in source blocks for haddock pages?
15:53:44 <revenantphx> jmcarthur: It's useful.
15:53:48 <revenantphx> :)
15:54:10 <aristid> :t last . read
15:54:11 <lambdabot> forall a. (Read a) => String -> a
15:54:22 <McManiaC> like this: http://npaste.de/rK/
15:54:50 <dskippy> jmcarthur: http://hpaste.org/41867/floydwarshall_output
15:54:59 <aristid> > last . read $ "[]"
15:55:00 <lambdabot>   *Exception: Prelude.last: empty list
15:55:04 <aristid> > last . read $ "[4]"
15:55:05 <lambdabot>   *Exception: Prelude.read: no parse
15:55:10 <aristid> > last . read $ "[\"4\"]"
15:55:11 <lambdabot>   *Exception: Prelude.read: no parse
15:55:17 <aristid> > last . read $ "[()]"
15:55:18 <lambdabot>   ()
15:55:38 <revenantphx> @hackage Network
15:55:38 <lambdabot> http://hackage.haskell.org/package/Network
15:55:49 <revenantphx> @hackage Network.Socket
15:55:49 <lambdabot> http://hackage.haskell.org/package/Network.Socket
15:55:49 <McManiaC> > laste . (read :: String -> Int) $ "[4]"
15:55:51 <lambdabot>   Not in scope: `laste'
15:55:55 <McManiaC> > last . (read :: String -> Int) $ "[4]"
15:55:57 <lambdabot>   Couldn't match expected type `[a]'
15:55:57 <lambdabot>         against inferred type `GHC.Types...
15:55:57 <revenantphx> broken >_>
15:56:06 <McManiaC> > last . (read :: String -> [Int]) $ "[4]"
15:56:07 <lambdabot>   4
15:56:09 <McManiaC> :)
15:56:40 <shachaf> > last . read $ "[4]" :: Int
15:56:41 <aavogt> McManiaC: put > in front?
15:56:42 <lambdabot>   4
15:56:46 <dskippy> jmcarthur: You can also just ignore all the array stuff and try to load just the list of lists called distances.
15:56:51 <McManiaC> aavogt: I did
15:57:35 <jmcarthur> dskippy: so i should try something like (distances !! 1 !! 200)?
15:57:47 <dskippy> jmcarthur: Yes, please.
15:58:33 <aavogt> McManiaC: works here http://i.imgur.com/Vx7RM.png
15:59:05 <McManiaC> aavogt: what haddock version?
15:59:24 <aavogt> 2.8.1
15:59:31 <jmcarthur> dskippy: okay, i also get that panic in 6.12.3, saying "linkBCO: >= 64k literals" when using ghci. i'm seeing what happens if i compile it first. then i'll try with ghc 7
15:59:48 <jmcarthur> dskippy: sounds like ghc has a hard limit on the number of literals that are permissible in a file
15:59:51 <aavogt> McManiaC: I recall putting pragmas in documentation having worked all the time though
16:00:07 <dskippy> jmcarthur: Seriously? Damn.
16:00:10 <revenantphx> Out of curiously
16:00:13 <revenantphx> Out of curiosity*
16:00:14 <gwern> jmcarthur: I think the usual trick to link in very large literals involved a C file, didn't it?
16:00:23 <revenantphx> Why would a function like swapMVar be included, if it has a race condition.
16:00:25 <Axman6> dskippy: why are you using an array of arrays and not a 2D array?
16:00:29 <dskippy> jmcarthur: So should I try loading this from a text file?
16:00:36 <McManiaC> aavogt: hmmm I use the same
16:00:44 <dskippy> Axman6: Because I've never heard of 2D arrays in Haskell.
16:01:03 <lewis1711> ...there's a difference in haskell!?
16:01:05 <aavogt> McManiaC: minor difference is that my documentation section starts with  {- | 
16:01:19 <gwern> @quote best.arrays
16:01:19 <lambdabot> gwern says: Haskell has the best arrays around; problem is, we don't know which module it is.
16:01:21 <jmcarthur> lewis1711: haskell has a *lot* of arrays
16:01:26 <Axman6> just use array ((0,0),(200,200)) ...
16:01:45 <jmcarthur> lewis1711: but the array package does allow you to use nearly arbitrary indices (any instance of Ix)
16:01:50 <jmcarthur> lewis1711: including tuples
16:01:54 <McManiaC> aavogt: then it doesn't work at all: http://n-sch.de/hdocs/rebindable-if/Data-IfThenElse.html
16:01:57 <lewis1711> the only languages I know that can do them properly are linalg packages like scipy and matlab
16:02:09 <dskippy> Axman6: You're suggesting using a pair of Int as my index?
16:02:14 <Axman6> yes
16:02:27 <Axman6> then you can use arr ! (x,y)
16:02:32 <jmcarthur> dskippy: when i precompile the module it doesn't panic
16:02:44 <jmcarthur> dskippy: i used -O2 in this case, but i'm thinking it shouldn't matter
16:02:47 <dskippy> jmcarthur: Interesting. I guess I'll have to do that.
16:02:59 <aavogt> McManiaC: I think the issue is with {- vs -- comments
16:03:15 <aavogt> this would seem to be a haddock bug
16:03:24 <dskippy> Axman6: What's the advantage of using a pair of Ints as the index?
16:03:27 <McManiaC> aavogt: indeed
16:03:37 <jmcarthur> dskippy: for the record, ghc 7 also panics when interpreting it
16:03:43 <dskippy> Axman6: Oh I guess I could make the whole thing and unboxed array if I did that.
16:03:46 <aavogt> sorry about misleading you for the comment style
16:03:50 <Axman6> yeah
16:03:55 <dskippy> jmcarthur: Thanks for the info. Very helpful.
16:04:05 <Axman6> you'd have UArray (Int,Int) Int
16:04:13 * ddarius goes to eat a steak.
16:04:18 <McManiaC> aavogt: it should work anyway :)
16:04:25 <jmcarthur> lewis1711: what is "properly"?
16:04:39 <aavogt> McManiaC: well you've got enough to file a bug on haddock?
16:05:11 <lewis1711> jmcarthur: generally being able to to go over them without writing nested for loops or nested map functions..
16:05:35 <povik> BONUS: diky za tutorial :)
16:05:56 <revenantphx> I'm gonna try to rewrite this thing I found on the internet with STM for fun
16:05:56 <revenantphx> https://gist.github.com/718410
16:05:59 <jmcarthur> lewis1711: you would like the idea of repa then (although its API is currently a bit lacking)
16:06:01 <revenantphx> dunno why, but it seems like a nice idea.
16:06:30 <jmcarthur> lewis1711: i guess the upcoming version of accelerate will also have ideas from repa, so you might like that too once it's out
16:06:35 <Phyx-> hmm is there a darcs diff like there's svn diff?
16:06:45 <lewis1711> noted ^_^
16:07:14 <jmcarthur> lewis1711: but basically repa gives you purely functional folds and zips and stuff over n-dimensional arrays
16:07:38 <jmcarthur> lewis1711: (and gives you nearly free data parallelism with decent cache coherency, at that!)
16:08:13 <pumpkin> just in case we thought the current disgustingly dynamic languages were too static: http://www.chrisseaton.com/katahdin/
16:08:32 <gwern> Phyx-: what is an svn diff?
16:09:07 <ddarius> pumpkin: That's old news.
16:09:23 <jmcarthur> pumpkin: how is it any more dynamic than, say, Io?
16:09:24 <Phyx-> gwern: shows a different between the current file and the versioned one 
16:09:44 <gwern> sure darcs can do that. I needed that for filestore
16:10:33 <Phyx-> gwern: how? :P
16:10:42 <jmcarthur> pumpkin: Io used to even have its own parser written in dynamically interpreted (and replaceable at runtime!) Io, but it's just C now (still replaceable though)
16:10:56 <gwern> it probably involved 'darcs diff'
16:11:01 <aavogt> or whatsnew
16:11:05 <gwern> I dunno, I write it in code so I don't have to remember
16:12:11 <Phyx-> lol, it seems there is a darcs diff
16:12:18 <jmcarthur> maybe this language is more convenient for it or something...
16:12:39 <Phyx-> but it compares two versions of the repositories
16:12:48 <Phyx-> not two individual files
16:12:57 <gwern> there is a difference?
16:13:07 <Phyx-> oh, you can just pass it a file :/
16:13:27 <pkrumins> In `case x of ...` statement, how do I specify what would be `default:` in C?
16:13:37 <pkrumins> like catch all other cases
16:13:39 <Phyx-> gwern: considering i've changed almost every file. i don't want to see *everything* that's changed
16:13:50 <gwern> pkrumins: _ -> foo
16:13:55 <pkrumins> gwern: aha!
16:14:00 <gwern> _ = wildcard to match anything
16:14:14 <pkrumins> nice
16:14:28 <Eduard_Munteanu> with no binding as well
16:16:57 <McManiaC> aavogt: is there a name for those {- -} comments?
16:16:58 <McManiaC> :)
16:17:21 <aavogt> no idea
16:17:44 <revenantphx> What is TChan for?
16:17:57 <revenantphx> could I use it for a queue of messages?
16:19:42 <Eduard_Munteanu> @hoogle toList
16:19:43 <lambdabot> Data.Foldable toList :: Foldable t => t a -> [a]
16:19:43 <lambdabot> Data.HashTable toList :: HashTable key val -> IO [(key, val)]
16:19:43 <lambdabot> Data.IntMap toList :: IntMap a -> [(Key, a)]
16:19:49 <gwern> McManiaC: I call them long comments and short comments, because those are the usecases
16:20:21 <Eduard_Munteanu> Hm, isn't there a toList for Seq?
16:20:33 <alpounet> revenantphx, yeah
16:20:44 <Eduard_Munteanu> oh the Foldable thing
16:20:47 <Eduard_Munteanu> Nevermind.
16:21:04 <revenantphx> And what is TArray for?
16:21:20 <alpounet> revenantphx, more generally, it's for making threads communicate
16:21:28 <revenantphx> alpounet: sure, that's what I'm looking for.
16:21:41 <alpounet> :)
16:22:00 <revenantphx> Would TArray be suitable for an inter-thread state bundle
16:22:09 <revenantphx> (file handles in this case)
16:22:41 <jmcarthur> what's the bird's eye use case?
16:23:23 <revenantphx> tbh, Tvar [FileHandle] is fine
16:23:32 <revenantphx> I need a variable to manage a list of file handles, to keep track of who's connected.
16:24:05 <jmcarthur> eek, i'd at least use Set or something instead of []
16:24:30 <jmcarthur> since it sounds like you'd be doing a lot of inclusion tests
16:24:48 <jmcarthur> or is this not for a huge system? :)
16:25:01 <revenantphx> not a huge system
16:25:04 <revenantphx> just me playing
16:25:06 <jmcarthur> *membership tests. that's the word i was looking for
16:25:22 <jmcarthur> mmkay then an MVar would probably be fine unless you really need transactions
16:25:34 <McManiaC> gwern: yeah, thought so
16:25:38 <jmcarthur> i have found that STM is usually way overkill for me
16:26:15 <revenantphx> jmcarthur: The point is trying to do it in STM
16:26:15 <jmcarthur> when i first learned about STM i was in one of those "everything looks like a nail" phases
16:26:24 <revenantphx> ...what?
16:26:40 <jmcarthur> revenantphx: "When all you have is a hammer, everything looks like a nail."
16:26:44 <jmcarthur> perhaps the wrong saying though
16:26:47 <revenantphx> :\
16:26:56 <revenantphx> anyways
16:27:04 <jmcarthur> revenantphx: what i meant is i was suffering from believing i had a golden hammer
16:27:08 <revenantphx> for messages, TChan is great
16:27:12 <Philippa> jmcarthur: ITYM thumb?
16:27:14 <jmcarthur> what's wrong with Chan?
16:27:15 <revenantphx> I can have my broadcast thread run in a forked thread.
16:27:29 <revenantphx> broadcast function*
16:27:48 <Axman6> there's more overhead when using STM than just plain MVars, Chans etc
16:27:57 <revenantphx> I know this >_<
16:27:58 <Axman6> MVars are extremely fast
16:27:58 <jmcarthur> Chan works just as well. in fact, MVar still works great in this case if you have enough worker threads that there is rarely more than one item in the queue anyway
16:28:02 <revenantphx> It's just for fun dammit.
16:29:01 <jmcarthur> actually... the one-master, many-worker pattern is so common i'm surprised we don't have some high level module with a few convenient abstractions for it. perhaps it doesn't exist because it's just so easy anyway
16:29:18 <jmcarthur> maybe that's just Chan :)
16:30:34 <revenantphx> jmcarthur: Or all of Node.js
16:30:35 <revenantphx> :P
16:31:04 <lpsmith> holy cow GHC's bug tracker got spammed
16:31:14 <revenantphx> Too bad JS is kind of terrible.
16:31:17 <revenantphx> (PHP is worsE)
16:31:29 <revenantphx> I'm baffled why we can't use better languages for the internet.
16:31:38 <revenantphx> as to why we can't*
16:31:39 <lpsmith> JS is kind of terrible,  JS is kind of nice
16:31:48 <revenantphx> lpsmith: Yeah... >_>
16:32:57 <pww> haha yeah
16:32:57 <revenantphx> :t (=<<)
16:33:04 <revenantphx> The. Fuck. Is This.
16:33:06 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:33:07 <lpsmith> well,  it seems that usually when a niche that has the potential to spawn a widely-used language crops up,  the language folk are nowhere to be found,  and the pioneers in that area usually aren't language folk.
16:33:08 <jmcarthur> I've heard JS described as "an amazing language with glaring flaws"
16:33:14 <revenantphx> :t (>>=)
16:33:24 <pww> i dont do too much web programming any more
16:33:30 <pww> dont really miss it
16:33:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:33:42 <Axman6> @src (=<<)
16:33:43 <lambdabot> f =<< x = x >>= f
16:33:43 <jmcarthur> revenantphx: (=<<) is a more easily understandable version of (>>=) :D
16:33:54 <revenantphx> jmcarthur: I don't understand TT_TT
16:34:00 <lpsmith> At least Brendan Eich had some knowledge about programming languages,  and cared.
16:34:03 <jmcarthur> revenantphx: compare:
16:34:06 <revenantphx> I see it takes a function turning a into m b, and a ma, and gives a mb
16:34:10 <revenantphx> I get what it does.
16:34:18 <osaunders> Shouldn't tail output a Maybe [a]? #improvement-suggestion
16:34:32 <jmcarthur> fmap :: (a -> b) -> (f a -> f b) ; (<*>) :: f (a -> b) -> (f a -> f b) ; (=<<) :: (a -> f b) -> (f a -> f b)
16:34:34 <revenantphx> Axman6: It's simmetrical!
16:34:43 <Axman6> sure is
16:34:48 <litb> i hate web development
16:34:55 <litb> always having to handle broken compilers...
16:35:10 <jmcarthur> revenantphx: all three of those functions just transform functions of different forms into the form (f a -> f b)
16:35:22 <McManiaC> web development is the easiest way to set up a quick "GUI" ;)
16:35:25 <revenantphx> The only difference between >>= and =<< is the order of the arguments
16:35:27 <lpsmith> (=<<) is basically the monadic analog of ($)
16:36:01 <lpsmith> :t ($)
16:36:01 <jmcarthur> revenantphx: another difference is that (=<<) is easier to generalize to other categories, but maybe i shouldn't get into that
16:36:02 <lambdabot> forall a b. (a -> b) -> a -> b
16:36:07 <lpsmith> :t (=<<)
16:36:08 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
16:36:11 <jmcarthur> :t (.)
16:36:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:36:13 <jmcarthur> :t (<=<)
16:36:15 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
16:36:16 <Eduard_Munteanu> Uh, what a mess with Data.Sequence stuff stepping over Prelude stuff.
16:36:17 <jmcarthur> :D
16:36:29 <jmcarthur> Eduard_Munteanu: qualified imports are your friend
16:36:40 <jmcarthur> i don't think it's a mess at all
16:36:50 <jmcarthur> what i think is a mess is the lack of a general interface for these things
16:36:54 <Eduard_Munteanu> jmcarthur: yeah, I know. But Foldable instances could've been Prelude's friends.
16:37:01 <jmcarthur> agreed
16:37:02 <pkrumins> How do I combine catch with finally in this code structure: `catch (...) (\e -> ...)`
16:37:11 <pkrumins> I'd like to add finally somewhere.
16:37:15 <jmcarthur> pkrumins: check out bracket
16:37:26 <jmcarthur> pkrumins: or other variations ofit
16:37:29 <jmcarthur> (of it
16:37:29 <pkrumins> oh that's an option, yeah.
16:38:02 <jmcarthur> *normally* when you think you need finally you probably would be better of with bracket anyway
16:38:20 <jmcarthur> *better off
16:38:20 <pkrumins> got it
16:38:37 <pkrumins> but i am still curious, how would i add it to that code there
16:38:43 <ManateeLazyCat> I have build new Manatee video at http://goo.gl/f8EKh , someone so kind help me upload to YouTube.com? I can't upload it in China. Thanks! :)
16:38:44 <pkrumins> just so i became better with haskell
16:38:51 <jmcarthur> that particular code i'm sure is in a larger context of some sort
16:39:01 <pkrumins> jmcarthur:  le me paste
16:39:08 <jmcarthur> kk
16:39:36 <revenantphx> Is it relatively common in a simple program to pass around a big tuple with all your state >_>?
16:39:42 <revenantphx> Or at least, most of the relevant state. (2 or 3 items right now)
16:40:09 <Mitar> how is called that a type of a data type has a free type variable?
16:40:16 <jmcarthur> pkrumins: to only look at what you said here, i'd say you want something like:   catch (... finally ...) (\e -> ...)
16:40:18 <Mitar> so Foo vs. Foo a
16:40:19 <Mitar> ?
16:40:42 <jmcarthur> pkrumins: since finally should pass exceptions on up after running anyway
16:41:47 <Phyx-> i'm really confused here, ghc says "Expected type a -> Int against inferred type Int" but the inferred type is correct, infact it matched the typesig, what's ghc complaining about
16:42:15 <jmcarthur> Phyx-: the context of that expression is hoping for something different i guess
16:42:35 <pkrumins> jmcarthur: http://hpaste.org/41872/pkruman
16:42:51 <lpsmith> hi pkrumins 
16:42:54 <ManateeLazyCat> Of course, if anyone interested Manatee, here is video http://goo.gl/f8EKh
16:42:54 <ManateeLazyCat> dom96: Hi 
16:42:57 <pkrumins> lpsmith: hey
16:43:29 <revenantphx> :t mapM_
16:43:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
16:45:07 <jmcarthur> pkrumins: i'd say something like:   bracket (accept sock) (`handler` kioskMode) (<do forking stuff here>)    ... but you realize this looks like it will spawn an infinite number of threads, right?
16:45:39 <jmcarthur> pkrumins: oh i did that wrong
16:45:39 <pkrumins> jmcarthur: wait it wont, accept is blocking
16:45:45 <jmcarthur> pkrumins: oh right
16:45:50 <jmcarthur> pkrumins: i still did it wrong though
16:46:08 <pkrumins> jmcarthur: okay, just write the correct one. :)
16:46:10 <jmcarthur> i was thinking handler took the handle, but it takes the sock. that's why i was thinking all goofy
16:48:28 <jmcarthur> pkrumins: why not just put the recursive call after the whole thing?
16:48:49 <pkrumins> jmcarthur: oh!
16:48:51 <pkrumins> hah
16:48:53 <pkrumins> good idea
16:49:06 <pkrumins> :)
16:49:09 <jmcarthur> heh
16:49:17 <revenantphx> !
16:49:23 <revenantphx> jmcarthur: I have type error for you to help me with :D
16:49:24 * pkrumins hides
16:49:52 <jmcarthur> oh noes
16:50:19 <jmcarthur> i shall give one more halp and then i'm ignoring #haskell ;)
16:50:39 <revenantphx> fine
16:50:45 <revenantphx> I'm... PASTING
16:51:09 <revenantphx> https://gist.github.com/718448
16:51:29 <osaunders> Is there a name for when a list has elements other than not null?
16:51:43 <jmcarthur> revenantphx: check out the type of the atomically function
16:51:48 <revenantphx> :t atomically
16:51:49 <lambdabot> Not in scope: `atomically'
16:52:14 <pww> sexy
16:52:21 <lpsmith_> osaunders,  meaning lists of lists,  like [[],[],[]],  [[],[4,5],[]]?
16:52:21 <revenantphx> STM -> IO...
16:52:32 <jmcarthur> revenantphx: STM can only be run using atomically. the idea is that it executes an entire transaction (semantically) at once
16:52:39 <revenantphx> Yes, I got that.
16:52:45 <jmcarthur> revenantphx: meaning you can't just use STM in IO
16:52:51 <revenantphx> Where did I?
16:52:53 <revenantphx> Oh,!
16:52:54 <jmcarthur> revenantphx: that would imply doing one thing at a time
16:52:56 <jmcarthur> heh
16:52:59 <osaunders> lpsmith_: No, much simpler than that: what is the adjective that distinguishes this list [1] from this one [].
16:53:14 <lpsmith_> ahh
16:53:16 <revenantphx> hurray for newTVarIO
16:53:19 <jmcarthur> :)
16:53:29 <aavogt> nonempty
16:53:30 <grsch> @help
16:53:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:53:35 <lpsmith_> not null, non-empty,  has at least one element
16:53:38 <jmcarthur> i misunderstood your misunderstanding
16:53:40 <revenantphx> Still have that second error...
16:54:05 <osaunders> Basically I have this function and I'm wondering if there is a better name for it:
16:54:05 <osaunders> withListMaybe :: ([a] -> b) -> [a] -> Maybe b
16:54:06 <osaunders> withListMaybe _ [] = Nothing
16:54:06 <osaunders> withListMaybe f xs = Just (f xs)
16:54:08 <jmcarthur> revenantphx: what's the type of readTVar?
16:54:12 <grsch> list
16:54:17 <grsch> help list
16:54:22 <osaunders> @src list
16:54:23 <lambdabot> Source not found. There are some things that I just don't know.
16:54:23 <lpsmith_> I'm not sure how much I like the term "nonempty" though,  as it's indirect
16:54:29 <pkrumins> How can i get current time as String in haskell? Date and Hour.
16:54:37 <jmcarthur> revenantphx: and of forM_?
16:55:03 <pkrumins> system.time!
16:55:31 <osaunders> @hoogle current
16:55:31 <lambdabot> module Control.Concurrent
16:55:31 <lambdabot> module Foreign.Concurrent
16:55:32 <lambdabot> System.Directory getCurrentDirectory :: IO FilePath
16:55:36 <osaunders> @hoogle now
16:55:37 <lambdabot> Text.Html nowrap :: HtmlAttr
16:55:37 <lambdabot> Text.XHtml.Transitional nowrap :: HtmlAttr
16:55:37 <lambdabot> Text.Parsec.Error errorIsUnknown :: ParseError -> Bool
16:55:43 <revenantphx> jmcarthur: Yeah, I see.
16:55:46 <jmcarthur> revenantphx: oh it's even more complex than that...
16:55:57 <revenantphx> just need to do this...
16:55:57 <jmcarthur> revenantphx: you are also trying to use IO inside a transaction, it seems
16:56:02 <osaunders> @hoogle time
16:56:03 <lambdabot> package time
16:56:03 <lambdabot> module Data.Time
16:56:03 <lambdabot> module System.Time
16:56:07 <revenantphx> hs <- readTVar handles
16:56:13 <revenantphx> wait... where?
16:56:15 <pkrumins> getClockTime
16:56:17 <revenantphx> forM_ works in any monad.
16:56:26 <jmcarthur> revenantphx: hPutStrLn and hFlush are in IO
16:56:33 <revenantphx> TT_TT
16:56:34 <jmcarthur> revenantphx: and you are using the forM_ in STM
16:56:44 <revenantphx> so how can I jump back to IO?
16:56:55 <jmcarthur> revenantphx: you can't. you have to return from the transaction first
16:57:36 <jmcarthur> revenantphx: there is no such thing in STM as transactional IO, so you will either have to get each handle one at a time in separate transactions or you will need to get all of them at once and then do the forM_ in IO
16:58:58 <revenantphx> Since i'm not modifying them, I could get the handles and the next message in a transaction
16:59:01 <revenantphx> then write in IO
16:59:08 <revenantphx> I just dont know how >_<
16:59:44 <jmcarthur> you just described it yourself :)
17:00:21 <pkrumins> hwo could I shorten this: `nowTime :: IO String; nowTime = moo <- getClockTime; return $ show moo`
17:00:30 <Funktorsalat> hxt says: 'fatal error: encoding scheme not supported: "UTF-8;"'
17:00:32 <Funktorsalat> :(
17:00:35 <pkrumins> so getClockTime returns IO ClockTime
17:00:41 <jmcarthur> pkrumins: liftM show getClockTime
17:00:42 <pkrumins> and then i put it in moo, and show it to convert to string
17:00:46 <pkrumins> jmcarthur: NICE!
17:00:47 <Funktorsalat> (utf8 is kinda common isn't it ;))
17:01:01 <pkrumins> first time i use liftM in my own code
17:01:02 <jmcarthur> pkrumins: if you have Control.Applicative in scope, you can say   show <$> getClockTime
17:01:02 <Funktorsalat> I suppose it may be the semicolon
17:01:20 <pkrumins> jmcarthur: oh wowsie
17:01:21 <jmcarthur> pkrumins: you may also use fmap if you wish
17:01:28 <jmcarthur> instead of liftM
17:01:31 <pkrumins> aha
17:01:42 <pkrumins> :t fmap
17:01:44 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:01:49 <pkrumins> :t map
17:01:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:01:54 <pkrumins> :t liftM
17:01:56 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
17:02:04 <jmcarthur> pkrumins: the only reason you can use fmap or (<$>) is because IO is also an instance of Functor. unfortunately, not all haskell Monads are Functors (even though they should be)
17:02:25 <jmcarthur> pkrumins: so if you were actually writing generic Monad code, you would have to use liftM
17:02:26 <pkrumins> :t <$>
17:02:28 <lambdabot> parse error on input `<$>'
17:02:31 <jmcarthur> :t (<$>)
17:02:33 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:02:39 <pkrumins> pretty similar
17:02:45 <jmcarthur> @src (<$>)
17:02:46 <lambdabot> f <$> a = fmap f a
17:02:50 <pkrumins> hah!
17:02:55 <jmcarthur> @src liftM
17:02:56 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
17:03:00 <pkrumins> !
17:03:04 <rothwell> 'lo. i have a small program that forks $EDITOR to edit a temporary file but for some reason, reading from the temporary file handle results in no data after the editor has exited... any idea what's going on? -> http://paste.lisp.org/display/117088
17:03:04 <pkrumins> this is what i had
17:03:06 <revenantphx> jmcarthur: Yeah I did, but the issue is how to get those variables.
17:03:09 <pkrumins> nice ones
17:03:14 <jmcarthur> liftM = fmap, basically
17:03:15 <pkrumins> thanks for the tips jmcarthur 
17:03:20 <jmcarthur> np
17:03:21 <revenantphx> If I do a <- readVar in the transactions, is it available outside of the transaction?
17:03:31 <revenantphx> Or am I just stuck thinking in scopes when I shouldn't be?
17:03:43 <jmcarthur> revenantphx: look at the type of atomically again
17:03:50 <McManiaC> > (+1) . Just 5
17:03:51 <lambdabot>   Just 6
17:03:54 <McManiaC> :D
17:03:57 <revenantphx> jmcarthur: what about it?
17:04:06 <rothwell> actually... i may have it
17:04:07 <jmcarthur> revenantphx: look at the type variable
17:04:17 <revenantphx> What am I looking for >_<
17:04:19 <jmcarthur> revenantphx: it's the same in both the STM and the IO
17:04:28 <McManiaC> > Just . (+1) . Just 5
17:04:29 <lambdabot>   Just (Just 6)
17:04:32 <McManiaC> hmhmh
17:04:41 <revenantphx> jmcarthur: okay...
17:04:42 <jmcarthur> revenantphx: that means you can return data from an STM transaction and get it in IO. atomically preserves it
17:04:52 <pkrumins> jmcarthur: another question, now I have nowTime function that returns IO String, and I wish to print it via putStrLn, which takes String as argument, is there a shortcut for the opposite now? Instead of lifting String in IO, I now want to get it out. My current solution is: `now <- getTime; putStrLn now`
17:04:57 <revenantphx> I don't understand, but ok...
17:05:12 <lpsmith_> So here's a possibly stupid question:   is there a way that something can sensibly be a monad and a functor but in a different way than Haskell expects?
17:05:12 <jmcarthur> pkrumins: there are two ways. first my favorite:
17:05:22 <jmcarthur> pkrumins:    putStrLn =<< getTime
17:05:25 <revenantphx> see, https://gist.github.com/718462
17:05:30 <revenantphx> hs and msg are out of scope
17:05:35 <jmcarthur> pkrumins: the more common is:   getTime >>= putStrLn
17:06:03 <jmcarthur> pkrumins: i prefer the former because it mirrors fmap/liftM/(<$>) more closely (and has some other nice properties like looking a lot like ($))
17:06:11 <jmcarthur> in type and usage, i mean
17:06:11 <pkrumins> jmcarthur: :D
17:06:23 <pkrumins> so great
17:06:34 <pkrumins> feeling supercalifragilistic
17:06:37 <luite> hmm, I know that I should take a break when =<< starts to look like $ ;p
17:06:37 <AmunRa> is there a better way to initialise a Data.Array matrix to a constant value? The following seems a bit silly: A.listArray range (replicate (A.rangeSize range) P.Empty)
17:06:52 <revenantphx> jmcarthur: so about that scope
17:07:02 <revenantphx> would I have to use return and bind the result of atomically to a tuple?
17:07:04 <jmcarthur> pkrumins: the whole thing could be inlined something like this:    putStrLn . show =<< getClockTime
17:07:12 <applicative> pkrumins, if Foo  is a Monad but isn't a functor, you can just write instance Functor Foo where  fmap = liftM and then use <$> as you please
17:07:14 <jmcarthur> revenantphx: that would be a way
17:07:21 <revenantphx> yeah, that works
17:07:30 <revenantphx> https://gist.github.com/718462
17:07:33 <revenantphx> what works better?
17:07:34 <pkrumins> applicative: oh sweet
17:07:41 <revenantphx> This seems too... "patternish"
17:07:48 <jmcarthur> pkrumins, applicative: yeah, you can do that if you don't mind orphan instances
17:07:56 <pkrumins> what are those?
17:08:12 <revenantphx> jmcarthur: I have to go, real quick
17:08:16 <revenantphx> Is there a better way than that?
17:08:23 <jmcarthur> revenantphx: i'll fork and annotate
17:08:27 <revenantphx> kk
17:08:28 <lpsmith_> Or,  the dual question,  why is liftM expected to correspond to fmap,  if both fmap and >>= are defined?
17:08:32 <revenantphx> jmcarthur: 
17:08:37 <revenantphx> Wait, let me login and repaste
17:08:40 <revenantphx> so I can get it later
17:09:07 <hristoasenov> hello i am having some trouble compiling the llvm bindings to haskell
17:09:15 <revenantphx> here we go jmcarthur 
17:09:15 <revenantphx> https://gist.github.com/718467
17:09:41 <jmcarthur> revenantphx: here's a shorter way to write the transaction https://gist.github.com/718466
17:09:43 <hristoasenov> for some reason checking for LLVMModuleCreateWithName in -lLLVMCore... no
17:09:51 <hristoasenov> this fails
17:09:58 <flazz_> is the State value constructor meant to be used? when i have Control.Monad.State imported it complains data constructor State is not in scope
17:10:05 <jmcarthur> revenantphx: not sure where else you might be looking for improvement
17:10:16 <hristoasenov> even though i specify where i installed it on the configure options
17:10:26 <hristoasenov> what am i doing wrong?
17:11:11 <applicative> lpsmith_, so the suspicion is that DeriveFunctor is like deriving Eq, which might not give the equivalence relation you want
17:12:25 <aavogt> flazz_: it got removed in mtl-2
17:12:55 <jmcarthur> pkrumins: when you create an instance of a type class that is defined in another module for a type that is in another module, that is an orphan instance. they are often avoided because it's possible to have multiple orphan instances for the same class/type pair without realizing
17:12:59 <flazz_> aavogt: runState evalState etc appear to be here tho
17:13:03 <applicative> jmcarthur, I didn't realize about orphan instances.  I will have to think.  Certainly it is standard practice with instance Applicative to write pure = return; <*> = ap
17:13:08 <applicative> jmcarthur, or is that different
17:13:09 <revenantphx> jmcarthur: what?
17:13:17 <pkrumins> jmcarthur: oh i see.
17:13:18 <revenantphx> lift makes a function work on monads right?
17:13:22 <revenantphx> what does , do?
17:13:25 <jmcarthur> applicative: it's only an orphan when it's for a type and class that already exist elsewhere
17:13:27 <revenantphx> :t (,)
17:13:27 <lambdabot> forall a b. a -> b -> (a, b)
17:13:33 <jmcarthur> revenantphx: that's tuple
17:13:34 <revenantphx> Oic.
17:13:45 <revenantphx> So you lift the tuple maker to monad.
17:13:48 <revenantphx> Interesting :D
17:14:10 <aavogt> flazz_: so use those functions for deconstructing State (which is now  StateT Id), and there's a function  state  which does the same as the constructor State used to
17:14:15 <jmcarthur> revenantphx: liftA2 is actually for Applicative (which i'm not really sure STM is an instance of), but liftM2 does the same thing
17:14:18 <applicative> jmcarthur, okay, yes; that I get
17:14:33 <revenantphx> then why not use liftM2?
17:14:42 <jmcarthur> revenantphx: i just like using the more general version when i can
17:14:47 <revenantphx> ah okay
17:15:21 <applicative> STM is Applicative http://hackage.haskell.org/packages/archive/stm/2.2.0.1/doc/html/Control-Monad-STM.html 
17:15:37 <flazz_> aavogt: which package is state in? ':t state' gives me 'Not in scope'
17:16:07 <jmcarthur> excellent
17:18:25 * ddarius drinks something that looks like pond scum.
17:18:30 <rothwell> is the handle returned by openBinaryTempFile write-only?
17:18:43 <ddarius> I'd doubt that.
17:18:52 <rothwell> hm
17:19:32 <rothwell> http://paste.lisp.org/display/117088
17:19:47 <applicative> hristoasenov, I don't know who among the more expert people who come around here would be knowledgeable about the llvm bindings.  
17:19:55 <rothwell> i don't get any data from 'hGetContents handle' when $EDITOR has exited
17:20:43 <rothwell> i thought perhaps the file was being removed/closed before any data could be read, but apparently that's not it either
17:20:49 <hristoasenov> applicative: ok thanx it seems like the only people who would know would be the developers
17:21:31 * rothwell traces
17:21:34 <aavogt> flazz_: Control.Monad.State as far as I can tell
17:22:01 <ddarius> rothwell: The file pointer will be at the end of the file when you pass it to hGetContents.
17:22:14 <rothwell> ddarius: d'oh!
17:22:20 <rothwell> *ahem* thanks
17:22:54 <lpsmith_> applicative, I'm a little confused,  what does "equivalence relationship" mean in the context of things that are instances of both Monad and Functor?     Or are you making some kind of analogy to Eq,  and "equivalence relationship" didn't have a precise meaning on the other side of the analogy?    To make a hand-waving analogy myself,  I'm wondering if there isn't something like a "skew field"  where liftM /= fmap when they both make sense.
17:23:30 <applicative> hristoasenov,  I take it you mean the LLVM package not the new ghc compilation via llvm.  Actually Brian O'S does show up as bos sometimes
17:24:36 <applicative> lpsmith_ sorry I was just making an analogy.  With an Eq instance, you must define (==) with the 'proof obligation' that your (==) is an equivalence relation
17:24:45 <lpsmith_> right
17:25:05 <lpsmith_> but I understand why we expect such a proof obligation :)
17:25:16 <jargonjustin> I'm working through an Iteratee/Enumerator tutorial (http://docs.yesodweb.com/blog/enumerators-tutorial-part-2/) and but am having trouble getting the getNumberEnum function to typecheck
17:25:22 <hristoasenov> applicative: yes i mean llvm package
17:25:26 <applicative> lpsmith_, but of course there are any number of *those*.  so deriving Enum just gives you the most discriminating equivalence possible
17:25:38 <lpsmith_> I don't understand why liftM == fmap should be a proof obligation :)
17:25:49 <jargonjustin> GHC seems to be inferring getNumberEnum :: (MonadIO (Iteratee t t1), Monad t1, Read t) => Step t t1 b -> Iteratee t t1 b
17:26:28 <applicative> hristoasenov, you might try when bos is around.  Or write to Haskell-cafe, of course.  The divine Lennart A. is sometimes here too, but not often I think. 
17:27:05 <lpsmith_> I mean,  it seems perfectly reasonable,  and I can't think of anything that seems reasonable where liftM /= fmap,   but that's just my vaguest intuition.
17:27:29 <applicative> lpsmith_, so I was thinking, maybe you were thinking, that 'DeriveFunctor' just gives some standard inferrable Functor instances, when maybe I could devise another, in some case. 
17:27:56 <lpsmith_> Ahh,  I see now =)
17:28:23 <ddarius> lpsmith_: It's not a proof obligation.  liftM is provably a valid definition of fmap, in fact it is with join the proof that the (>>=)/return view of a monad is equivalent to the fmap/join/return view.
17:28:26 <applicative> lpsmith_ sorry, it was too opaque a statement of the obvious.... I remember questions like this arising on the -cafe list
17:28:43 <pkrumins> can anyone take a look at this code: http://hpaste.org/41873/pkruman
17:28:48 <applicative> lpsmith_ ddarius is here!
17:29:00 <pkrumins> getting an error: parse error on input `<-'
17:29:02 <shachaf> ddarius: Can there ever be two valid fmap definitions for the same type?
17:29:09 <applicative> ddarius the question might be independent of that
17:29:11 <ddarius> Nothing technically relies on liftM and fmap being observationally equivalent, though if both Monad and Functor are instanced, it would be misleading to do it differently.
17:29:13 <pkrumins> which happens to be on line 4 in the paste
17:30:04 <applicative> ddarius, the main question is: can I ever finish the sentence "instance Functor Foo where fmap = ..." in more than one way 
17:30:07 <Ytinasni> pkrumins: you want a `do` before that block.
17:30:33 <pkrumins> Ytinasni: like catch (do ...)?
17:30:39 <lpsmith_> well,  that's applicative's question,  which I want to answer yes to, but I don't have any examples in mind
17:30:40 <Ytinasni> yes.
17:30:44 <pkrumins> Ytinasni: thanks!
17:30:58 <applicative> ddarius, there is the familiar point that Applicative can be instanced in more than one way, even given an fmap 
17:31:11 <jargonjustin> A nevermind, seems to have something to do with importing Control.Monad.Trans instead of Control.Monad.IO.Class
17:32:29 <lpsmith_> but my (possibly mistaken) impression that fmap should correspond to <*>,  when both are available
17:32:53 <ddarius> fmap doesn't correspond to (<*>) at all.
17:33:03 <applicative> lpsmith_ s original question was more complicated, i was trying break it down, possible ineptly
17:33:10 <ddarius> There is pure f <*> x == fmap though.
17:33:14 <applicative> if there is pure
17:33:49 <applicative> ddarius, and since Applicative presupposes Functor, it is your duty to make that equality work
17:34:13 <ddarius> If you make a valid instance of Applicative, that will work.
17:34:20 <applicative> yeah
17:34:29 <lpsmith_> right,  I misspoke =)
17:35:33 <applicative> lpsmith_, I keep thinking your question comes down to 'can there be more than one Functor instance' 'can there be more than one Monad instance' when nothing yet has been settled
17:35:43 <ddarius> I believe it is possible to formulate a "higher-order" version of parametricity that can be used to show that it isn't possible to make more than one distinct, valid instances of Functor, but formulating the notion is tricky.  Alternatively, you could start an inductive proof on the structure of types and at least get all polynomial types.
17:36:14 <lpsmith_> applicative, you are doing ok;  my question was horribly vague,  and this is helping me to clarify the question at least :)
17:37:11 <lpsmith_> although the question "is there more than one instance of Functor" is definitely interesting it it's own right
17:37:32 <tomberek> hey, what sorts of uses have people found for data List2 a b = Nil | a :> (List2 b a)   ?
17:37:41 <pkrumins> Ytinasni: could you take a look at the updated version: http://hpaste.org/41875/pkruman
17:37:46 <pkrumins> Ytinasni: now a new error.
17:38:27 <pkrumins> Can't really understand why it would want ThreadId there
17:40:15 <lpsmith_> ok,  so let's say you start with the state monad,  and choose the lazy liftM and the strict fmap,  or vice-versa?
17:40:16 <ddarius> So, for the type data One a = One, there is only one Functor instance.  For data X a = X a there is only one instance.  Given that there is only one instance of Functor for f and g, then there is only one instance of Functor for data Times f g a = Times (f a) (g a) [exercise: prove this]. 
17:40:19 <applicative> lpsmith_ ddarius, do we have to specify non-triviality?  instance Functor maybe where fmap f x = Nothing.  does that violate functor laws? 
17:40:33 <Claudius1aximus> tomberek: hmm.  i've got some code that uses: data Address = P Integer | S Integer Rational Address
17:40:53 <Claudius1aximus> tomberek: not quite the same..
17:41:08 <tomberek> No, not quite,, the idea is that the types in the list alternate
17:41:18 <ddarius> applicative: That clearly violates the functor laws, fmap id /= id.
17:41:27 <lpsmith_> applicative, I'm pretty sure that's a kosher Functor instance,  even if it isn't immediately obvious how that might be interesting :)
17:41:32 <applicative> right, i was only thinking of composition
17:41:39 <tomberek> Claudius1aximus: so something like:    a = 1 :> True :> 2 :> False :> Nil
17:41:42 <lpsmith_> err,  right
17:41:44 <Claudius1aximus> tomberek: this is an alternating list with the additional condition that the length is odd
17:42:01 <shachaf> lpsmith_: It's certainly possible to make an Applicative with more than one (<*>) instance.
17:42:19 <tomberek> Claudius1aximus:   ah yes, I see, you have to add them two at a time into Address
17:42:19 * lpsmith_ is exhausted,  and should go to bed soon.
17:42:28 <ddarius> Given that there is only one instance of Functor for f and g, then there is only one instance of Functor for data Plus f g a = InL (f a) | InR (g a) [exercise: prove this too]
17:43:11 <Claudius1aximus> tomberek: i'm representing them visually like http://img84.imageshack.us/img84/1978/example0.png
17:43:57 <ddarius> It's also useful to generalize One to Const t, so that we can lift types to functors to handle, e.g. Either Int (f a) which would be Sum (Const Int) f a
17:44:02 <Claudius1aximus> tomberek: and the context is http://img146.imageshack.us/img146/6181/figure2s.png
17:44:41 <tomberek> I came up with this and i'm trying to see what I can do it:   data Object ma mb a b = A a (ma (Object mb ma b a))   
17:44:55 <ddarius> At any rate, if you accept those, that shows that every (non-recursive) polynomial type constructor 1) has a functor instance and 2) has exactly one functor instance.=
17:45:23 <applicative> ddarius, yes, I see, the polynomial case seems convincing (without having yet completed the exercises)
17:45:32 <ddarius> If you do the same kind of thing for Mu, you'll get almost all practically used types.
17:45:46 <tomberek> Claudius1aximus: it's a sequence of alternating types and containers... so if ma and mb are functors, you have a structure that alternates the shape each level
17:46:26 <ddarius> It's also easy to start expanding into exponential spaces, i.e. (X -> a) has only one functor instance.
17:46:54 <ddarius> Of course, once we start adding exponentials things get more complicated.  (a -> a) has no functor instance.
17:47:11 <lpsmith_> well,  I'm off to bed.  g'night applicative, ddarius!
17:47:22 <applicative> by lpsmith_
17:47:27 <applicative> bye
17:47:49 <pkrumins> Can anyone take a look at this code: http://hpaste.org/41875/pkruman
17:47:58 <pkrumins> Getting the error in the comment.
17:48:24 <Claudius1aximus> tomberek: interesting - i can't think of an application for it, but there probably is one out there somewhere...
17:48:43 <ddarius> Also, just to be clear, I'm pretty sure that this property comes from "parametricity" properties of Haskell type constructors (plus some other limitations).  It is certainly -not- the case that functors are limited in this way in other categories, e.g. Set.
17:49:32 <Cale> pkrumins: maybe try putting a  return ()  after the forkIO
17:49:40 <Cale> :t catch
17:49:41 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:49:47 <pkrumins> Cale: trying
17:49:50 <tomberek> Claudius1aximus: i was thinking about graphs at the time.  ma = [] and mb = newtype Pair a = Pair (a,a)  , then you have a simple graph
17:50:10 <pkrumins> Oh yeah that must be it
17:50:13 <pkrumins> even though...
17:50:19 <Cale> pkrumins: Since forkIO :: IO a -> IO ThreadId, that first do-block has type IO ThreadId, and so it expects the handler to be the same type
17:50:23 <pkrumins> Cale: why isnt the return type determined by the code on line 18?
17:50:37 <pkrumins> since that should run after the catch block
17:51:00 <Cale> pkrumins: The type error is all in that one line of the do-block
17:51:09 <Cale> (of the outermost do-block)
17:51:22 <pkrumins> oh the blocks itself have types as well?
17:51:49 <Cale> Every do-block is an expression, with a value and a type
17:52:33 <Cale> :t (do putStrLn "hello there"; getLine)
17:52:34 <lambdabot> IO String
17:52:36 <pkrumins> Cale: got it. and it works now!
17:52:43 <Cale> :t forkIO (do putStrLn "hello there"; getLine)
17:52:44 <lambdabot> Not in scope: `forkIO'
17:52:44 <pkrumins> after adding return ()
17:52:56 <Cale> pkrumins: yep :)
17:53:09 <pkrumins> Cale: but will the code on line 18 execute?
17:53:20 <Cale> Every time.
17:53:20 <pkrumins> Cale: that return () is to return from the do-block, right?
17:53:23 <Cale> no
17:53:37 <pkrumins> it doesn't make function to return? or does it
17:53:37 <Axman6> so, would any one find it useful if the function done = return () were added to Control.Monad?
17:53:38 <Cale> return () is the action which does nothing, but returns ()
17:53:52 <Cale> It doesn't have any special control effects like return in C does.
17:53:58 <Axman6> > return 1 :: Maybe Int
17:53:59 <lambdabot>   Just 1
17:53:59 <pkrumins> ooh
17:54:00 <pkrumins> snap
17:54:02 <pkrumins> i forgot that
17:54:03 <Cale> return is an ordinary function
17:54:11 <pkrumins> Cale: was thinking about return as C return -_-
17:54:42 <Cale> return in C and many other imperative languages is actually quite weird if you think about it.
17:54:53 <pkrumins> is it?
17:55:20 <Ytinasni> nah, it's just invoking a continuation :D
17:55:22 <Cale> In such languages, it's like every function definition has been wrapped with call/cc, and return provides a restricted way to access the continuation.
17:55:36 * ddarius suspects Landin's J operator is quite a bit more wierd.
17:56:02 <pkrumins> btw, Cale, so what was exactly the reason why compiler rejected the previous code? I didn't really understand it fully. Why was the () so important in that catch block, if it didn't determine the return type of the whole function?
17:56:31 <ddarius> (Note, that, as normally implemented, every function has been wrapped in the equivalent of call/cc and return does access the continuation.)
17:56:35 <Cale> pkrumins: The do-block ending with forkIO had type  IO ThreadId  (because every do-block has the same type as the action on its last line)
17:56:43 <Ytinasni> pkrumins: the type of returning normally needed to match the type of the exception result.
17:56:52 <Cale> pkrumins: Now, look at the type of the function  catch
17:56:55 <Cale> :t catch
17:56:56 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:57:04 <pkrumins> looking yes
17:57:11 <Cale> So, a = ThreadId here
17:57:15 <pkrumins> Ah!
17:57:22 <Cale> since our first action has type IO ThreadId
17:57:30 <pkrumins> Oh, actually go on.
17:57:36 <Cale> and so the handler, whatever it was, would have needed to produce an IO ThreadId as well.
17:57:57 <Cale> But it didn't. The handler ended with  hPutStrLn ... :: IO ()
17:58:06 <Cale> and that's where the type didn't match up
17:58:15 <pkrumins> AH!
17:58:21 <pkrumins> that explains it perfectly
17:58:28 <pkrumins> and i just understood some more about types.
17:58:35 <pkrumins> Ytinasni: yeah!
17:58:42 <pkrumins> thanks guys, this was really helpful :)
17:58:49 <pkrumins> now i can proceed with my haskell adventures
17:59:43 <ddarius> @quote sprynge
17:59:43 <lambdabot> Cale says: Beware of the function [a] -> a. For it may contain trappes and sprynges of great variety and harm.
17:59:57 <Cale> ddarius: haha
18:01:36 <Eduard_Munteanu> How would I write a Word32 to a file?
18:01:46 <Eduard_Munteanu> I don't care about possible endianness issues.
18:01:58 <ddarius> Eduard_Munteanu: There are a lot of answers, but you probably want the binary package.
18:02:09 <Eduard_Munteanu> ddarius: thanks, I'll look it up.
18:04:57 <djahandarie> Who is rampion on reddit?
18:05:08 <Eduard_Munteanu> Hm, encode seems to do that, and I needed to switch to bytestrings anyway.
18:11:02 <jmcarthur> gbacon!
18:11:16 <gbacon> jmcarthur: howdy!
18:14:53 <augur> byorgey: i wonder if theres a way to use species as a programming language. like, since it's plausible to have the species `Lam (X*X)` which is effectively the powerset function, what primitive species could we have that would let us define all computations?
18:16:51 <pygmalion> can someone explain lookahead recursion as a concept to me? i'm having some trouble understanding it
18:17:40 <Cale> pygmalion: lookahead recursion?
18:18:04 <pygmalion> is it not something that people know about?
18:19:09 <Cale> Is there some specific context where those words are occurring together?
18:19:22 <pygmalion> AI for a simple mancala game
18:19:34 <Cale> Oh, I see.
18:19:43 <Cale> So you mean looking ahead in a game tree.
18:19:54 <pygmalion> yes i think so
18:21:29 <Cale> So, the easiest way to look at it (I think) is that your game consists of a tree, whose root is the starting position, and where each subtree consists of the resulting game where the player whose turn it was has moved.
18:21:41 <Cale> (each subtree of the root)
18:21:48 <pygmalion> Cale: so as i understand it
18:21:59 <_POD__> hey I have a monad that is not an instance of functor, but I want to do something similer to fmap on it in do notation (without making it a instance of functor)
18:22:03 <pygmalion> Cale: the root is the current state. and then there are subtrees for each of the possible moves for the current player?
18:22:07 <Cale> _POD__: liftM
18:22:17 <_POD__> OK thanks.
18:22:30 <Cale> _POD__: But every instance of Monad should also be an instance of Functor, and it's a bug if it's missing.
18:23:07 <Cale> _POD__: We have the mechanism to enforce this, but for some reason, the standard library doesn't make use of it :P
18:24:51 <Cale> pygmalion: yeah
18:25:25 <pygmalion> Cale: hmm ok i'll see what i can do with that thanks
18:25:32 <Cale> pygmalion: So you might use a type like  data Tree a = Node a [Tree a]
18:25:51 <pygmalion> right
18:25:51 <Cale> pygmalion: and you can define a very large, or even infinite tree that consists of the entire game
18:26:00 <pygmalion> only limited by time i guess
18:26:14 <Cale> which is convenient in Haskell because it's lazy, and you'll only compute the part of it that you need
18:26:32 <Axman6> could even define an infinite tree in constant space! :o
18:27:05 <luite> or a constant tree in infinite space
18:27:17 <Cale> and so the next thing after that would be to define some functions for chopping up that tree, and examining maybe only a few moves ahead of a given move.
18:27:31 <byorgey> augur: I don't understand what you mean. The species Nat = 1 + Nat can be used to define all computations: just interpret each number appropriately as a description of a Turing machine.
18:27:35 <byorgey> augur: but that's obviously not what you mean
18:27:50 <augur> byorgey: no, its not :p
18:28:33 <augur> byorgey: what i mean is, if we have species as a primitive (like, if we have species as a programming language), then we could define the powerset function to be Lam (E*E)
18:28:38 <augur> pset = Lam (E*E)
18:28:52 <byorgey> what is Lam ?
18:28:59 <augur> Fst, sorry
18:29:04 <augur> pset = Fst (E*E)
18:30:18 <byorgey> so what would be the semantics of defining  f = S  for some species S?
18:31:12 <augur> just a naming convention
18:31:38 <augur> so the way i'd interpret a construction like E [1,2,3] is enumerating E with [1,2,3]
18:31:44 <augur> application ~ enumeration
18:31:57 <_POD__> Cale: Yeah, I'm writing a bot for the google ai challenge, and I'm using a module from the forums there, so I don't know how "Official" it is.
18:32:01 <augur> so f = S is just binding the variable f for convenience
18:32:14 <augur> hence pset [1,2,3] ~ (Fst (E*E)) [1,2,3]
18:36:38 <byorgey> augur: ok, but you said "define all computations"; I don't see how this would let us define things like, say, succ :: Nat -> Nat
18:38:00 <augur> well, for certain models, succ is just   `succ x = S x` right
18:38:08 <augur> so succ = S
18:39:01 <augur> enumerate S [n] = [S n]
18:39:11 <augur> so succ n = S n
18:39:47 <augur> afk
18:41:29 <byorgey> maybe succ was a bad example.  How about pred?
18:50:08 <colton> Are there any decent haskell shells?
18:50:45 <revenantphx> an hsh is a neat idea
18:50:48 <revenantphx> but what's the point
18:51:05 <revenantphx> oh, haskell as shell script
18:51:06 <revenantphx> r
18:51:06 <revenantphx> ight
18:51:19 <revenantphx> Google says Hashell, HSH, and HaSh
18:51:27 <revenantphx> and SHSH
18:51:30 <revenantphx> dunno about decent
18:53:01 * hackagebot monad-coroutine 0.6.1 - Coroutine monad transformer for suspending and resuming monadic computations  http://hackage.haskell.org/package/monad-coroutine-0.6.1 (MarioBlazevic)
18:53:42 <nostrand_> dvbf
18:53:51 <nostrand_> oups, wrong window
18:55:02 * hackagebot scc 0.6.1 - Streaming component combinators  http://hackage.haskell.org/package/scc-0.6.1 (MarioBlazevic)
18:55:49 <applicative> colton, what's wrong with ghci?
18:56:05 <colton> nothing
18:56:31 <Jafet> Perhaps he meant haskell unix shell
18:57:30 <ddarius> You could, if you wanted to, set GHCi as your shell.  You could even do everything you normally do.
18:58:21 <pygmalion> suppose i have a list of ints and a function (Int->Int) and I want to return the list value with the greatest value after applying the function to all of the items
18:58:30 <pygmalion> is there a simple way for this?
18:58:53 <ddarius> Either maximumBy or maximum . map f depending on what you mean.
18:59:02 <augur> byorgey: o hai
18:59:08 <pygmalion> :t maximumBy
18:59:10 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
18:59:48 <augur> pred might imply that we need some more primitive species combinators!
19:00:06 <pygmalion> thanks ddarius 
19:00:18 <augur> but if we take these species to be functions of type Set a -> Set b or something like that
19:00:27 <augur> then pred might just be like
19:00:56 <augur> pred = E, and all you do is pred n instead of succ [n]
19:01:01 <augur> that feels unpleasant tho
19:01:20 <augur> im not sure how it would work, precisely, im just curious if theres some natural, elegant way of doing it
19:01:48 <byorgey> pred = E?  I don't understand that
19:02:04 * hackagebot monad-parallel 0.5.2 - Parallel execution of monadic computations  http://hackage.haskell.org/package/monad-parallel-0.5.2 (MarioBlazevic)
19:02:42 <augur> byorgey: well, if 1 = {0}, the enumerate E 1 = {0}
19:03:06 <augur> the set contains the values, so 0 is the precessor of 1
19:03:28 <augur> succ {1} = {2}
19:03:42 <byorgey> but that depends on interpreting it in a particular way, which is different than the way you interpreted succ.
19:03:48 <augur> ofcourse
19:03:52 <augur> thats why i said it was inelegant :p
19:04:17 <augur> tho its cute that pred and succ are the same function, one working directly on the value, the other on a set containing the value :p
19:04:24 <byorgey> I guess I am highly skeptical, is what I am trying to say
19:04:36 <augur> thats ok, im just throwing ideas out there
19:04:40 <byorgey> sure
19:04:51 <augur> we might need to define an inverse cominator
19:05:25 <Axman6> > succ [1,2,3]
19:05:26 <lambdabot>   No instance for (GHC.Enum.Enum [t])
19:05:26 <lambdabot>    arising from a use of `e_1123' at <i...
19:05:29 <Axman6> :(
19:05:46 <augur> so like, if F is the species that wraps some labels into an F, then surely theres also Inv F, the species that takes an F and pulls out some labels
19:06:37 <augur> (Inv (X*X)) [(1,2),(2,1)] = [1,2]
19:06:44 <byorgey> augur: no, Inv F doesn't make sense as a species
19:06:47 <forall> > succ [1..12]
19:06:48 <lambdabot>   No instance for (GHC.Enum.Enum [t])
19:06:49 <lambdabot>    arising from a use of `e_1112' at <i...
19:06:54 <pygmalion> is there some acceptable functional alternative to foreach in haskell?
19:06:56 <augur> byorgey: sure it does!
19:06:56 <byorgey> since species have to be independent of the particular labels used
19:07:17 <augur> im not saying Inv F is dependent on particular labels
19:07:34 <Axman6> pygmalion: map? mapM? forM? mapM_? forM_?
19:07:34 <byorgey> so what is (Inv (X*X)) [3,4] ?
19:07:35 <augur> no, im saying Inv F is that species which, when you enumerate an F with labels, gets you those labels
19:07:40 <augur> undefined
19:07:42 <augur> its a type error
19:07:51 <byorgey> augur: that's what I'm saying. You can't do that.
19:07:53 <augur> because you're nor enumerating X*X's
19:07:57 <byorgey> it has to be functorial.
19:08:07 <augur> not**
19:08:16 <augur> ok then these are hyperspecies
19:08:16 <augur> :P
19:08:43 <byorgey> I'm off to eat some pie, talk to you later =)
19:08:43 <pygmalion> Axman6: yeah that was my first instinct but the issue i'm having is that i need to use the items in the list as an argument for a subfunction if that makes sense
19:09:06 <augur> so long as the following law holds: enumerate (Inv F) (enumerate F ls) = ls
19:09:11 <pygmalion> i.e. i have f x y z = q x (map y xs) z
19:09:28 <pygmalion> Axman6: does that make sense?
19:09:36 <Eduard_Munteanu> How would I mapM_ over a ByteString?
19:10:05 <ddarius> Eduard_Munteanu: Getting a byte for each?
19:10:12 <Cale> Eduard_Munteanu: Use mapM_ with unpack?
19:10:14 <Eduard_Munteanu> ddarius: yeah.
19:10:55 <Eduard_Munteanu> Cale: hm, that would do.
19:11:08 <Eduard_Munteanu> But I wonder, doesn't that kill any performance gains over regular I/O?
19:11:14 <augur> consider the simple case:   enumerate (Inv X) (enumerate X [a]) = [a]. this seems relatively sane. using `X a` as the label for (Inv X) yields just X
19:11:18 <augur> er, just a
19:11:30 <Cale> I forget if unpack is lazy
19:11:39 <Cale> It ought to be.
19:12:20 <Eduard_Munteanu> Ah, so it's not going to do anything bad. Thanks.
19:12:58 <ddarius> The issue with regards to performance would be you processing byte by byte, not the unpack.
19:14:46 <Eduard_Munteanu> I see, that wouldn't have made sense.
19:16:05 <ddarius> This will be a good set of baguettes.
19:16:11 <revenantphx> For functions which are entirely in the io monad, (like main) how should I type them?
19:16:18 <revenantphx> I often see than the type is just left to be inferred.
19:16:25 <revenantphx> Is there any "any type" I can use?
19:16:31 <revenantphx> to do "anything -> IO ()
19:17:01 <revenantphx> To at least indicate im in the IO monad?... It's pointless but idk :P
19:17:03 <revenantphx> just curious.
19:17:11 <Cale> revenantphx: If there's no parameter, it's not a function, it's just an IO action.
19:17:14 <Cale> IO ()
19:17:21 <revenantphx> Cale: Well, there is a parameter.
19:17:27 <revenantphx> But it's a tuple and idk if I might change the type...
19:17:39 <revenantphx> I might add stuff you know.
19:17:47 <revenantphx> So I feel it might be best to let the type system change it.
19:17:56 <Cale> You could just leave the type signature off.
19:18:04 <revenantphx> It feels naked :P
19:18:09 <revenantphx> Oh well >_>
19:18:11 <Cale> Using an IO action in the definition is enough to pin the type down.
19:18:42 <Eduard_Munteanu> Why not change the signature if you add a parameter?
19:18:53 <Eduard_Munteanu> or change types.
19:19:00 <revenantphx> Eduard_Munteanu: I think I am.
19:19:09 <Cale> So you probably won't get an inferred type which is polymorphic in the monad, but if you do, well, it makes your code all the more reusable.
19:19:28 <revenantphx> I mean, I do want SPECIFIC input.
19:19:36 <revenantphx> So I think it should be staticall types.
19:19:43 <revenantphx> For something like the main function though, I don't think so.
19:19:48 <Cale> Remember that the compiler is going to infer the type of the thing anyway.
19:20:00 <Cale> If you leave it out. It's still statically typed :)
19:21:47 <revenantphx> sure.
19:22:03 <revenantphx> When I check :t in ghci, TChan becomes TChan String
19:22:07 <revenantphx> is that just default?
19:22:27 <revenantphx> How does it know I want strings > <
19:22:42 <Cale> Maybe how you used it?
19:23:10 <revenantphx> I guess...
19:24:03 <edwardk> preflex: xseen jbapple
19:24:04 <preflex>  jbapple was last seen on freenode/#haskell 78 days, 10 hours, 21 minutes and 52 seconds ago, saying: I think lazy IO tripped me up again
19:24:09 * hackagebot mps 2010.11.28 - simply oo  http://hackage.haskell.org/package/mps-2010.11.28 (JinjingWang)
19:25:14 <revenantphx> How can I handle a socket disconnecT?
19:25:49 <mauke> gracefully :-)
19:26:43 <mauke> I see sockets as pipes that go over the internet
19:26:51 <mauke> a disconnect closes the other end of the pipe
19:28:31 <revenantphx> ... No no, I mean how can I set up a handler for a socket closing.
19:28:41 <revenantphx> I saw one person using exception finally statements to do it.
19:28:56 <mauke> reading from a closed pipe gives you EOF
19:29:17 <mauke> writing to a closed pipe sends you a SIGPIPE, which you should ignore to make the write fail with EPIPE
19:30:54 <revenantphx> As I said, one piece of code I saw wrapped the forked IO action in catch/finally
19:31:00 <revenantphx> and had finally close the connections
19:31:45 <mauke> ok, so ... do that?
19:31:53 <revenantphx> Well, I'm asking if theres a different way.
19:31:56 <revenantphx> Like a callback type thing.
19:32:03 <revenantphx> Then again that wouldn't be much like haskell I suppose.
19:32:05 <revenantphx> idk.
19:32:07 <pygmalion> http://hpaste.org/41878/type_issue i'm getting a type error trying to use map in a sort of complicated way... can anyone take a look for me?
19:32:17 <mauke> aren't exception handlers callbacks?
19:32:59 <mauke> pygmalion: seems pretty obvious
19:33:09 <mauke> evalPosition takes a MancalaBoard
19:33:20 <mauke> your map returns a whole list of them
19:34:40 <forall> > lex "ABC"
19:34:42 <lambdabot>   [("ABC","")]
19:34:46 <pygmalion> mauke: yeah i guess i see that but i can't figure out a better way to do what i'm trying to do. i want to get the maximum of evalPosition for each of those moves
19:35:00 <mauke> pygmalion: then shouldn't evalPosition be inside the map?
19:35:27 <mauke> pygmalion: or do you want maximumBy?
19:35:59 <revenantphx> D:
19:36:01 <revenantphx> hap
19:36:08 <revenantphx> My first actual code in Haskell is failing TT_TT
19:36:08 <revenantphx> https://gist.github.com/718558
19:36:21 <mauke> maximumBy (comparing $ \m -> evalPosition (getCurPlayer mancala) m depth)
19:36:26 <revenantphx> When I send messages from telnet nothing happens. (sad face)
19:37:36 <revenantphx> From a print I put in talk, it's never actually happening?
19:37:41 <revenantphx> er, let me add a flush
19:38:30 <revenantphx> nope, it never prints.
19:38:43 <revenantphx> edited: https://gist.github.com/718558
19:39:05 <revenantphx> mauke, you see anything?
19:39:12 <mauke> no
19:39:32 <mauke> my next steps would be 1) strace and 2) debug prints everywhere
19:39:35 <revenantphx> yep
19:39:45 <revenantphx> Also, the ports aren't being released
19:39:49 <revenantphx> *** Exception: bind: resource busy (Address already in use)
19:39:56 <revenantphx> ReuseAddr is not working in other words :(
19:40:20 <mauke> wait, what
19:40:47 <mauke> listenOn binds the socket
19:40:52 <mauke> your setSocketOption is too late
19:40:57 <revenantphx> Figured.
19:41:02 <ddarius> mauke is constantly surprised by the antics of the newbies here.
19:41:14 <mauke> "NOTE: To avoid the "Address already in use" problems popped up several times on the GHC-Users mailing list we set the ReuseAddr socket option on the listening socket. If you don't want this behaviour, please use the lower level listen instead."
19:41:23 <revenantphx> So, how would I fix this in any case.
19:41:27 <mauke> no idea in which version of network that happened, though
19:41:39 <ManateeLazyCat> Can you access http://goo.gl/4YeZS ? It's my video, i need sure other people can access it. 
19:41:48 <revenantphx> I'd need to create a socket first, then setSocketOption... and then use lower lever listen.
19:41:49 <revenantphx> (TCP)
19:42:00 <revenantphx> @hackage network
19:42:00 <lambdabot> http://hackage.haskell.org/package/network
19:42:27 <mauke> ManateeLazyCat: yes, but "You have chosen to open  Manatee.avi  which is a: BIN file.  Would you like to save this file?  [Cancel]  [Save File]"
19:42:43 <pygmalion> mauke: i'm not really sure. i want to run evalPosition for each of the possible moves. but evalPosition takes the mancala board so i have to run the move through "move" first
19:43:07 <revenantphx> aw, using low level it'd be a pain to make it agnostic
19:43:16 <revenantphx> (ipv4/6 agnostic)
19:44:03 <ManateeLazyCat> mauke: Thanks,
19:44:06 <ManateeLazyCat> mauke: It's safe.
19:44:18 <ManateeLazyCat> mauke: It's video show "how to play Manatee". :)
19:44:21 <ManateeLazyCat> @package manatee
19:44:21 <lambdabot> http://hackage.haskell.org/package/manatee
19:44:56 <ManateeLazyCat> mauke: I'm need sure it's can access before my friend help me upload it to YouTube.com
19:45:55 <ManateeLazyCat> mauke: If you interested, you can download it to watch, 355MB
19:45:59 <ManateeLazyCat> :)
19:46:32 <revenantphx> this makes binding a pain in the but
19:46:38 <revenantphx> have to go through all the BSD crap.
19:47:25 <mauke> revenantphx: which version of network are you using?
19:47:37 <revenantphx> 2.2.1.7
19:48:15 <revenantphx> It's alright... I can work with BSD.
19:48:24 <revenantphx> It's just a bit irritating that I have to deal with it now.
19:48:35 <mauke> why do you have to?
19:48:43 <revenantphx> Because I need SO_REUSEADDR
19:48:55 <mauke> uh, listenOn already does that
19:49:01 <revenantphx> apprently not :P
19:49:13 <mauke> http://hackage.haskell.org/packages/archive/network/2.2.1.7/doc/html/src/Network.html#listenOn
19:49:29 <revenantphx> huh, so it does.
19:49:33 <revenantphx> Then why's the issue occuring.
19:50:02 <revenantphx> So it may not be in my version though..
19:50:40 <revenantphx> :\
19:50:46 <revenantphx> Why's it happening here....
19:50:52 <revenantphx> where's the haskell source on my machine?
19:51:03 <ManateeLazyCat> revenantphx: ~/.cabal/packages
19:51:49 <revenantphx> I don't see network in there :\
19:51:50 <revenantphx> odd
19:52:06 <revenantphx> I'm looking for the built in parts.
19:52:12 <ddarius> revenantphx: It doesn't keep the source unpacked once it's installed.
19:52:31 <revenantphx> ddarius: oh true.
19:52:49 <revenantphx> I'm downloading 2.3 anyhow
19:52:56 <ddarius> At any rate, unless you or someone who provided you with that network package modified it, the source code mauke linked to is the source code for version 2.2.1.7 which is the version you claimed to be using.
19:53:08 <revenantphx> That's what it said.
19:53:16 <revenantphx> Oh, I know.
19:53:29 <revenantphx> It could be that the kernel is tying the sockets use to the ghci process for some reason.
19:53:34 <revenantphx> port's use*
19:54:02 <revenantphx> yeah, seems like it is :P
19:55:34 <revenantphx> alright, here's the current code then.
19:55:35 <revenantphx> https://gist.github.com/718568
19:55:39 <revenantphx> I don't know where to start :\
19:55:42 <revenantphx> (debugging wise)
19:55:43 <Ziphilt> i am messing with some code that imports System.Console.ANSI (package ansi-terminal). it runs fine in GHCi, but will not compile, with this error: http://hpaste.org/41880/ansiterminal_compilation_erro
19:55:46 <revenantphx> maybe its the forever...
19:56:13 <revenantphx> oh, it was :P
19:56:15 <ddarius> Ziphilt: Use --make
19:56:20 <revenantphx> making the line forkIO . forever $ echo conn state fixed it.
19:56:25 <Ziphilt> okay, thanks
19:56:33 <revenantphx> ddarius: Does --make just tell it to look for the packages automatically?
19:56:37 <ddarius> Ziphilt: And for future reference, simply always use --make when building with GHC directly.
19:57:05 <Ziphilt> okay
19:57:06 <mauke> :t forever
19:57:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
19:57:11 <revenantphx> :D
19:57:14 <revenantphx> I'M SO HAPPY.
19:57:15 <Ziphilt> good to know
19:57:20 <revenantphx> My first actual piece of code in haskell.
19:57:23 <revenantphx> It is working TT_TT
19:57:27 * revenantphx tears of joy.
19:57:45 <mauke> > forever (+) 2 2
19:57:49 <lambdabot>   mueval-core: Time limit exceeded
19:57:57 <Ziphilt> revenantphx: my first is this GoL simulator
19:58:05 <revenantphx> Oh, fun.
19:58:12 <revenantphx> I did an echo server ¬_¬
19:58:17 <revenantphx> Ostensibly less cool.
19:58:20 <Ziphilt> hee
19:58:27 <Funktorsalat> > runWriter (forever (tell "nom"))
19:58:30 <revenantphx> Ziphilt: Do you have prior experience in functional languages tho?
19:58:33 <lambdabot>   mueval: ExitFailure 1
19:58:43 <Ziphilt> no
19:58:47 <revenantphx> Aw.
19:58:55 <revenantphx> You make me feel bad TT_TT
19:59:06 <Ziphilt> would you like to see mah code? :D
19:59:12 <revenantphx> How are you drawing the game of life?
19:59:25 <revenantphx> I should try that with GLUT...
19:59:38 <Ziphilt> ansi-terminal
19:59:50 <pygmalion> mauke: are you around still?
20:01:49 <Ziphilt> revenantphx: http://hpaste.org/41881/gol
20:01:52 <Ziphilt> :DD
20:02:07 * ddarius should have used one or two more bursts of steam.
20:02:41 <Ziphilt> it requires a text file to porse
20:02:48 <Ziphilt> *parse
20:03:16 <Ziphilt> just 0s and 1s
20:03:37 <Ziphilt> i also have a version that does WireWorld :D
20:05:13 <revenantphx> @hackage exception
20:05:13 <lambdabot> http://hackage.haskell.org/package/exception
20:06:52 <revenantphx> @quote goose
20:06:52 <lambdabot> No quotes match. It can only be attributed to human error.
20:07:00 <revenantphx> brb
20:14:34 <xcthulhu> Hoogle is down!
20:14:45 <xcthulhu> :_(
20:16:20 <revenantphx> How can I tell an import to override an existing function?
20:16:24 <revenantphx> In this case something in Prelude?
20:17:01 <orlandu63> revenantphx: you'd have to hide the function with import Prelude hiding (blah)
20:17:06 <orlandu63> then define blah
20:17:08 <ManateeLazyCat> revenantphx: You can use "import qualified YouModule as Y"
20:17:10 <revenantphx> Yeah, figured :\
20:17:24 <revenantphx> w/e
20:19:48 <revenantphx> @hoogle IOError -> IO ()
20:19:48 <lambdabot> Prelude ioError :: IOError -> IO a
20:19:48 <lambdabot> Control.Exception ioError :: IOError -> IO a
20:19:48 <lambdabot> Control.OldException ioError :: IOError -> IO a
20:19:59 <revenantphx> @hoogle a -> IO ()
20:19:59 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
20:19:59 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
20:19:59 <lambdabot> Control.Concurrent.Chan unGetChan :: Chan a -> a -> IO ()
20:20:12 <revenantphx> I want something that does *nothing* to use as an exception handler
20:20:18 <revenantphx> Empty lambda works I suppose.
20:20:46 <revenantphx> :t print
20:20:47 <lambdabot> forall a. (Show a) => a -> IO ()
20:20:53 <revenantphx> @hoogle  a -> IO ()
20:20:54 <lambdabot> Control.Concurrent.MVar putMVar :: MVar a -> a -> IO ()
20:20:54 <lambdabot> Data.IORef writeIORef :: IORef a -> a -> IO ()
20:20:54 <lambdabot> Control.Concurrent.Chan unGetChan :: Chan a -> a -> IO ()
20:23:42 <pkrumins> How do I quit a haskell program at any time?
20:24:01 <pkrumins> )(like exit() in C program)
20:24:30 <Eduard_Munteanu> Any suggestions for a (preferably terminal) human-readable, binary diff?
20:25:09 <pkrumins> found it, System.Exit.
20:25:17 <Eduard_Munteanu> *diff tool
20:25:22 <pkrumins> Should have more carefully looked before I asked
20:26:01 <orlandu63> there's such thing as a human-readable binary diff tool?
20:26:39 <Eduard_Munteanu> orlandu63: yeah, basically I'm looking for something that highlights and compares the output of 'hexdump -C' for example.
20:27:27 <crutcher> I'm trying to grok Enumerators; and beating on the Yesod enumerator tutorial
20:27:43 <crutcher> and I don't understand why this example doesn't work: http://hpaste.org/41883/why_is_this_an_error
20:27:54 <crutcher> it's copied from the tutorial
20:28:23 <pww> oh holy shit
20:28:27 <crutcher> but it blows up, complaining about class instances which I think are defined
20:28:43 <crutcher> haddock thinks they're there
20:30:24 <revenantphx> :t show
20:30:24 <lambdabot> forall a. (Show a) => a -> String
20:30:48 <revenantphx> > putStr "Hello" ++ show 9
20:30:49 <lambdabot>   Couldn't match expected type `GHC.IOBase.IO ()'
20:30:49 <lambdabot>         against inferred ty...
20:31:49 <magicman> :t putStr ("Hello" ++ show 9)
20:31:50 <lambdabot> IO ()
20:32:03 <byorgey> crutcher: can you paste the haddock that leads you to think the relevant instances are defined?
20:32:28 <revenantphx> magicman: I did putStr $ "Hello" ++ show 9
20:32:29 <revenantphx> instead.
20:32:33 <applicative> byorgey, crutcher, it compiles for me.  could it be different versions of the package>
20:32:40 <Ziphilt> hey everyone, i did something that works and manes me happy! https://gist.github.com/718590
20:32:40 <byorgey> ah, could be.
20:32:42 <magicman> Works :)
20:32:46 <Ziphilt> *makes
20:33:23 <byorgey> Ziphilt: awesome!
20:33:28 <crutcher> applicative: I'm at GHC 6.12.3, and enumerator 0.4.2
20:33:28 <Ziphilt> :DD
20:33:35 <byorgey> Ziphilt: looks like the Game of Life
20:33:40 <Ziphilt> it... is
20:33:44 <crutcher> byorgey: http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#t:Iteratee
20:33:50 <byorgey> =)
20:34:17 <applicative> crutcher, the MonadIO instance for is defined in Data.Enumerator ...
20:34:35 <applicative> crutcher, wait, I see i'm on enumerator 0.4.0.2
20:34:41 <byorgey> crutcher: ok. what version of enumerator do you have installed?
20:34:43 <revenantphx> so er
20:34:51 <revenantphx> what can I use as a a -> IO () function
20:34:52 <applicative> he has 0.4.2
20:35:02 <revenantphx> Needs to take anything, and just do *nothing* with it.
20:35:10 <revenantphx> \x -> return () works I guess
20:35:13 <orlandu63> revenantphx: const (return ())
20:35:17 <revenantphx> const?
20:35:21 <Ziphilt> i seem to be unable to get gist to color my code
20:35:32 <byorgey> crutcher: you linked to the documentation for 0.4.0.2
20:35:41 <Xilon> @src const
20:35:41 <lambdabot> const x _ = x
20:35:45 <applicative> but the instance in question -- isn't it -- is on hackage http://hackage.haskell.org/packages/archive/enumerator/0.4.2/doc/html/Data-Enumerator.html
20:35:45 <crutcher> byorgey: yeah, maybe it changed, let me search
20:35:47 <Ziphilt> is it colored for you people?
20:35:47 <revenantphx> perfect
20:35:59 <byorgey> hmm, but that instance is still in the 0.4.2 documentation
20:36:00 <adu> i just found out that alex doesn't support unicode
20:36:05 <adu> alex--
20:36:35 <revenantphx> Er, is there a nice way to make this line a bit cleaner
20:36:36 <revenantphx> forkIO $ catch ((forever $ echo conn state) `finally` (closeConn conn state)) (const $ return ())
20:36:38 <revenantphx> or break it up?
20:37:00 <Eduard_Munteanu> I'd like to do stuff like fwrite(&word32, 4, 1, fp) in Haskell. Binary seems to do that except it enforces big endian.
20:37:15 <Eduard_Munteanu> Any other alternatives?
20:37:31 <applicative> crutcher, byorgey so maybe we're overlooking something else obvious.  i worked on this tutorial, i wonder if my code is somewhere
20:37:34 <Ziphilt> revenantphx: any idea why your gist is colored and mine is not?
20:37:39 <byorgey> Ziphilt: no, it's not colored for me
20:37:43 <revenantphx> Ziphilt: I selected Haskell as language.
20:37:53 <crutcher> applicative: that is the ONLY thing in this file
20:37:57 <tomberek> are there mutual recursion schemes or are they just handled by conversion to primitive recursion?
20:37:57 <Ziphilt> i tried that, to no avail
20:38:07 <revenantphx> set file name as .hs
20:38:20 <Ziphilt> did that too
20:38:34 <Ziphilt> this has worked for me before
20:38:37 <revenantphx> hey, you see any way to make that line more legible?
20:38:52 <Ziphilt> in my code?
20:38:56 <revenantphx> no, mine :P
20:39:00 <adu> how do i do unicode lexing with alex? or with anything?
20:39:00 <Ziphilt> ha
20:39:05 <revenantphx> forkIO $ catch ((forever $ echo conn state) `finally` (closeConn conn state)) (const $ return ())
20:39:33 <revenantphx> forks a new thread in which echo is looped forever, while catching any exceptions with const $ return (), and finally always calls cleanup code.
20:39:57 <pkrumins> what is the const about?
20:39:58 <Ziphilt> that feels a bit above my head
20:40:22 <revenantphx> pkrumins: apparenrly it does f a _ = a
20:40:32 <pkrumins> :t const
20:40:33 <lambdabot> forall a b. a -> b -> a
20:40:35 <orlandu63> revenantphx: take a look at hslint
20:40:37 <crutcher> applicative, byorgey: okay, I found it.
20:40:39 <revenantphx> hslint?
20:40:48 <pkrumins> hpaste.com has hslint built in
20:40:48 <orlandu63> it's in hackage
20:40:53 <crutcher> I'd broken ghc by uninstalling monads-fd, rather than hiding it
20:41:00 <byorgey> oh, heh
20:41:00 <Eduard_Munteanu> @pl forkIO $ catch ((forever $ echo conn state) `finally` (closeConn conn state)) (const $ return ())
20:41:01 <lambdabot> forkIO (catch (forever (echo conn state) `finally` closeConn conn state) (const (return ())))
20:41:07 <pkrumins> so what's exactly the point of using const $ return ()?
20:41:09 <crutcher> my fault, now it works fine
20:41:20 <pkrumins> not sure how it fits there
20:41:31 <pkrumins> :t const $ return ()
20:41:32 <lambdabot> forall b (m :: * -> *). (Monad m) => b -> m ()
20:41:32 <revenantphx> Oh, neat.
20:41:34 <revenantphx> thanks.
20:41:38 <byorgey> Ziphilt: do you want any suggestions for improvements on your code?
20:41:39 <pkrumins> :t return ()
20:41:40 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
20:41:50 <orlandu63> pkrumins: that's his exception handler. it simply does nothing :P
20:41:58 <Ziphilt> byorgey: yes please
20:41:59 <byorgey> crutcher: no worries, glad you got it figured out =)
20:42:07 <pkrumins> oh i see!
20:42:09 <pkrumins> that is smart
20:42:16 <pkrumins> my exception handler dir \e -> return ()
20:42:17 <Ziphilt> any is appreciated
20:42:19 <pkrumins> did
20:42:21 <byorgey> Ziphilt: ok.
20:42:30 <pkrumins> but now i can rewriteit to const $ return ()
20:42:32 <pkrumins> now i get it
20:42:32 <pkrumins> :)
20:42:36 <pkrumins> code improvements++
20:42:49 <applicative> crutcher, I see what you said... I was about to say, the monad transformer libraries crisis may be at the bottom of this. 
20:42:52 <Eduard_Munteanu> Run @pl on it to really get an improvement :P
20:42:54 <byorgey> Ziphilt: line 18 could just be  | sane u = map render (iterate newgen u)
20:43:02 <revenantphx> this is nicer :)
20:43:03 <revenantphx> forkIO $ catch (forever (echo conn state) `finally` closeConn conn state) (const $ return ())
20:43:07 <Ziphilt> i also wanted cookies and hugs for my efforts :D
20:43:21 <revenantphx> So, correct me if I'm wrong, $ is just infixed seq right?
20:43:22 <pkrumins> i bought cookies today
20:43:23 <crutcher> applicative: what's going on with that?
20:43:28 * pkrumins throws some at Ziphilt 
20:43:30 <byorgey> Ziphilt: whenever you find yourself defining an explicitly recursive function like iter' you should ask yourself whether there is a way to do it with an existing library function
20:43:35 <revenantphx> It's essentially "evaluate everything on the right hand side of this first"
20:43:44 <byorgey> Ziphilt: such as map, filter, foldr, iterate, takeWhile ...
20:43:47 <revenantphx> Forces strict evaluation (or at least right to lefT)
20:43:55 <Ziphilt> byorgey: yes, what is iterate?
20:43:56 * byorgey gives Ziphilt a lambda cookie
20:44:00 <byorgey> @type iterate
20:44:01 <lambdabot> forall a. (a -> a) -> a -> [a]
20:44:08 <pkrumins> cocookies
20:44:11 <byorgey> > iterate (*2) 1
20:44:13 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
20:44:21 <Ziphilt> ah cool
20:44:22 <revenantphx> byorgey: That or just cdr down the list ;)
20:44:24 <pkrumins> > take 5 $ iterate (*2) 1
20:44:25 <lambdabot>   [1,2,4,8,16]
20:44:32 <applicative> crutcher, I don't really understand it, but for some time there have been conflicts with major packages with identical module names, it has been resolved, in principle
20:44:44 <orlandu63> @type seq
20:44:46 <lambdabot> forall a t. a -> t -> t
20:44:47 <orlandu63> @type ($)
20:44:48 <lambdabot> forall a b. (a -> b) -> a -> b
20:44:57 <pkrumins> whats the diff @type or :t?
20:45:00 <pkrumins> same right?
20:45:04 <pkrumins> :t ($)
20:45:05 <revenantphx> pkrumins: same I believe.
20:45:05 <lambdabot> forall a b. (a -> b) -> a -> b
20:45:07 <byorgey> Ziphilt: so do you see how my suggested code works?
20:45:15 <Ziphilt> ...ish...
20:45:22 <Ziphilt> thinking
20:45:29 <orlandu63>  :t doesn't work in PMs for some reason
20:45:36 <revenantphx> https://gist.github.com/718598
20:45:37 <orlandu63> so i'm used to @type
20:45:39 <revenantphx> hurray :D
20:45:44 <revenantphx> any recommendations for improving this?
20:46:01 <revenantphx> I'm kind of just passing all of the state to everything :P
20:46:02 <crutcher> applicative: I go away for 6 months and everything changes :)
20:46:21 <pygmalion> can lambda functions be used as the first argument to map?
20:46:28 <revenantphx> pygmalion: why not
20:46:30 <revenantphx> :t map
20:46:31 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:46:41 <pygmalion> revenantphx: that's what i assumed but i'm getting a strange type issue
20:46:46 <revenantphx> :t (\x -> 9)
20:46:47 <lambdabot> forall t t1. (Num t1) => t -> t1
20:47:26 <pygmalion> revenantphx: i'm trying to use the lambda because in need to use each element of a list as a particlar argument to a function that takes several arguments
20:47:32 <Ziphilt> byorgey: yes, i do now
20:48:07 <revenantphx> ERP.
20:48:10 <revenantphx> haha
20:48:12 <revenantphx> I just realized.
20:48:18 <revenantphx> My echo server is more of a chat server.
20:48:21 <Ziphilt> there should be more advertisement of higher-order functions
20:48:24 <revenantphx> It broadcasts back to everyone :P
20:48:36 <Ziphilt> byorgey: thanks, anything else?
20:48:52 <revenantphx> Also, it seems that compiled haskell code using forkIO doens't produce more than 1 thread?
20:48:55 <revenantphx> are they virtual?
20:49:12 <applicative> crutcher, yes, I mean you really can't haskellize without spending all day everyday reading threads like this :) : http://www.haskell.org/pipermail/libraries/2010-November/thread.html#15065
20:49:32 <byorgey> Ziphilt: my one other suggestion before heading to bed is that using an eight-tuple to represent the neighborhood seems kludgy
20:49:34 <magicman> Eduard_Munteanu: Re big-endian/little-endian stuff: look at Data.Binary.Put.putWord32le, for example.
20:49:50 <byorgey> Ziphilt: why not just represent the neighborhood as a list of CellStates?
20:50:18 <byorgey> Ziphilt: that would make quite a few things easier to write, and it would easily generalize to other sorts of neighborhoods as well
20:50:28 <m3ga> i'm using alex and parsec (as a token parser) in a compiler front end written in Haskell, but i'm getting :
20:50:30 <m3ga>     hGetContents: invalid argument (Invalid or incomplete multibyte or wide character)
20:50:45 <m3ga> and i;ve got LAN set to en_AU.UTF-8
20:50:54 <m3ga> s/LAN/LANG/
20:50:59 <Ziphilt> i knew that when i wrote it, but i wanted the order to be significant because of rules that involve directions
20:51:04 <m3ga> clues?
20:51:15 <byorgey> Ziphilt: the order of the list can still be significant.
20:51:31 <revenantphx> :t forkOS
20:51:32 <lambdabot> Not in scope: `forkOS'
20:51:48 <Ziphilt> hm, i'll try that
20:52:07 <byorgey> Ziphilt: ok, I'm off to bed, but anyway, it's really quite a nice program, congratulations =)
20:52:15 <Ziphilt> thanks :D
20:52:26 <Ziphilt> my first too
20:52:54 <Ziphilt> first one i talked to the channel about, anyway
20:53:50 <revenantphx> awesome, switching to OS threads instead of haskell threads was super easy.
20:54:04 <revenantphx> forkOS instead of forkIO, done.
20:55:03 <Xilon> revenantphx: You need to set the amount of threads using +RTS I believe
20:55:11 <revenantphx> Xilon: what?
20:55:17 <revenantphx> I just tried it with -threaded and it worked perfectly.
20:55:19 <crutcher> applicative: informative!
20:55:29 <revenantphx> 3 thread runtime + 1 broadcast + 1 per client
20:55:41 <revenantphx> went up and down easily as I telnetted in clients
20:55:52 <ddarius> revenantphx: That's not what forkOS does.
20:55:59 <pkrumins> anyone knows how System.Exit.exitSuccess works? It doesnt seem to exit the program
20:56:02 <djahandarie> revenantphx, forkOS has nothing to do with making OS threads
20:56:04 <djahandarie> Oops
20:56:07 <djahandarie> Beat to it
20:56:09 <pkrumins> i see the program running, even its networking part is still up
20:56:18 <revenantphx> ddarius: what does it do then?
20:56:28 <revenantphx> from what I can see, using forkIO causes it to make runtime (virtual) threads.
20:56:35 <Xilon> Doh, RTS does something completely different :P
20:56:35 <revenantphx> using forkOS seems to make it use OS level threads.
20:56:49 <ddarius> revenantphx: The exact same thing as forkIO except it won't allow the Haskell thread to migrate to a different OS thread.
20:56:51 <revenantphx> (I see in top/ps threads going up/down when I connect clients)
20:56:58 <revenantphx> ddarius: ?...
20:57:24 <djahandarie> Why the hell is it called forkOS anyways? *mumble*
20:57:36 <djahandarie> forkIOBound
20:57:38 <Claudius1aximus> pkrumins: i guess it throws an exception which makes the thread exit, but the program only exits when the main thread exits
20:57:53 <pkrumins> oh i see
20:57:57 <pkrumins> i am catching all exceptions
20:57:58 <revenantphx> "However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Concurrent.html#v%3AforkOS instead of http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Concurrent.html#v%3AforkIO."
20:58:01 <revenantphx> er
20:58:03 <pkrumins> and resuming the networking loop
20:58:08 <revenantphx> However, if you want to interact with a foreign library that expects your program to use the operating system-supplied thread package, you can do so by using forkOS instead of forkIO.
20:58:15 <ddarius> revenantphx: What made the difference was the -threaded flag.  GHC only uses multiple OS threads if you use -threaded and pass -N <num> to the program.
20:58:30 <revenantphx> ddarius: No I tried it with -threaded and forkIO
20:58:36 <nomothetis> Does anyone know why ghci won't find HUnit? This is the output of "ghci-pkg list": http://pastie.org/1329315
20:58:38 <revenantphx> and GHC created 3 threads, and that was it.
20:58:52 <revenantphx> when I used threaded and forkOS, a thread is added per fork (in addition to starting 3)
20:58:54 <revenantphx> as expected.
20:58:55 <Xilon> -N was probably what I was thinking of
20:59:58 <revenantphx> "A bound thread is a haskell thread that is /bound/ to an operating system
20:59:58 <revenantphx> thread."
21:00:17 <djahandarie> revenantphx, you can stop pasting stuff, we've all read the docs here. :P
21:00:18 <revenantphx> So that'd be why the thread count goes up and down when forkOS is used.
21:00:22 <djahandarie> And no
21:00:28 <ddarius> revenantphx: Yes, that is what I said earlier.  It doesn't mean that -other- threads aren't also using that OS thread.
21:00:31 <djahandarie> You can have 100 haskell threads bound on a single OS thread
21:00:39 <revenantphx> djahandarie: ah, ok.
21:00:52 <djahandarie> It's just that they won't move. (Hence bound.)
21:00:52 <ddarius> When you don't use -threaded, forkIO/forkOS still work.
21:01:17 <ddarius> Even though there is only one OS threaded (modulo non-blocking IO.)
21:01:24 <ddarius> s/threaded/thread/
21:01:39 * revenantphx is confused a bit.
21:02:18 * Axman6 reminds you all of forkOnIO
21:02:41 <pkrumins> looking at that
21:03:00 <ddarius> revenantphx: Basically, the only time you'd use forkOS rather than forkIO is if you had to deal with a library that used thread local state.
21:03:09 <ClaudiusMaximus> > ceiling (1%2)
21:03:11 <lambdabot>   1
21:03:14 <pkrumins> some advanced stuff
21:04:02 <ddarius> revenantphx: How are you deciding how many threads are being used anyway?
21:04:38 <ddarius> Ah, via ps.
21:05:35 <revenantphx> @hackage network
21:05:35 <lambdabot> http://hackage.haskell.org/package/network
21:06:33 <ddarius> You might actually be worsening your program by using forkOS.  GHC uses non-blocking IO exclusively even for things that are blocking calls from the Haskell perspective.  That's probably why you weren't seeing other threads.  (And this is why forkIO still works even without -threaded rather than blocking on the first IO.)
21:06:45 <revenantphx> I'm just playing around. I'm leaving it as forkIO
21:07:08 <revenantphx> I have faith in virtual threading systems until proven otherwise.
21:08:02 <revenantphx> so one other thing
21:08:08 <revenantphx> notice where I create handles...
21:08:12 <revenantphx> handles <- newTVarIO []
21:08:20 <revenantphx> I left the array empty because I was lazy but...
21:08:25 <revenantphx> a) it works
21:08:30 <revenantphx> b) it doesn't work if I put Handle inside.
21:08:34 <revenantphx> c) what.
21:08:53 <revenantphx> In other words, the type system can figure out from that I was "an array of something"
21:08:58 <revenantphx> ?
21:09:54 <revenantphx> @source System.IO
21:09:54 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
21:10:24 <ddarius> Incidentally, using GHC's concurrency system and IO manager you get the best of all worlds.  You get the speed and low overhead of an event-based interface to the OS/hardware, while the convenience and simplicity of a thread-based interface to the API.
21:11:54 <Axman6> revenantphx: array? sure looks like a list to me ;) the type of the 
21:12:03 <revenantphx> Sorry :P
21:12:06 <revenantphx> list
21:12:07 <Axman6> TTVar there will be inferred by its use later on in your program
21:12:12 <revenantphx> That's neat.
21:12:13 <Axman6> -T
21:12:44 * hackagebot yuuko 2010.11.28 - A transcendental HTML parser gently wrapping the HXT library  http://hackage.haskell.org/package/yuuko-2010.11.28 (JinjingWang)
21:13:06 <revenantphx> odd
21:13:07 <revenantphx> "Someone said: '" ++ msg ++ "'\n"
21:13:20 <revenantphx> > "Someone said: '" ++ msg ++ "'\n" where msg = "hello"
21:13:21 <lambdabot>   <no location info>: parse error on input `where'
21:13:25 <Ziphilt> goodnight all, happy hacking
21:13:40 <revenantphx> > do putStr $ "Someone said: '" ++ msg ++ "'\n" where msg = "hello" where msg = "hello"
21:13:41 <lambdabot>   <no location info>: parse error on input `where'
21:13:48 <revenantphx> > let msg = "hello"
21:13:49 <lambdabot>   not an expression: `let msg = "hello"'
21:14:05 <revenantphx> > let msg = "hello in putStr $ "Someone said: '" ++ msg ++ "'\n"
21:14:06 <lambdabot>   <no location info>:
21:14:06 <lambdabot>      lexical error in string/character literal at chara...
21:14:11 <revenantphx> >_>
21:14:25 <Axman6> let foo = "Someone said: '" ++ msg ++ "'\n" where msg = "hello" in foo
21:14:30 <Axman6> > let foo = "Someone said: '" ++ msg ++ "'\n" where msg = "hello" in foo
21:14:31 <lambdabot>   "Someone said: 'hello'\n"
21:15:15 <revenantphx> The ' keep messing up in my code.
21:15:48 <revenantphx> I get this
21:15:49 <revenantphx> "omeone said: "Hello world
21:15:55 <revenantphx> for this
21:15:56 <revenantphx> hPutStrLn h $ "Someone said: \"" ++ msg ++ "\""
21:16:13 <revenantphx> I guess the order of evaluation is the issue?
21:16:29 <ddarius> revenantphx: No, it looks like a concurrency issue.
21:16:43 <revenantphx> ddarius: What TT_TT?
21:16:44 <revenantphx> how.
21:16:56 <revenantphx> It's the same if I use single quotes.
21:17:00 <revenantphx> If I use no quotes it's all fine...
21:17:04 <ClaudiusMaximus> > length . show . ceiling $ 11 * (2^100-1) % (2^10 - 1)
21:17:05 <lambdabot>   29
21:17:31 <ClaudiusMaximus> why do i always end up picking large problems :(
21:17:59 <revenantphx> ddarius ???
21:18:19 <pastorn> Data.Text.Text works with over
21:18:22 <pastorn> loaded strings?
21:18:37 <revenantphx> > let foo = "Someone said: \"" ++ msg ++ "\"" where msg = "Hello world" in foo
21:18:38 <lambdabot>   "Someone said: \"Hello world\""
21:18:41 <ddarius> hPutStrLn is not an atomic operation.  If you have multiple threads writing to the same handle (or ultimately being redirected to the same output), they may be interleaved.
21:18:54 <revenantphx> ddarius: I don't here ddarius 
21:19:08 <Axman6> > "test" :: Text
21:19:09 <lambdabot>   Not in scope: type constructor or class `Text'
21:19:09 <revenantphx> And it's EVERY TIME, exactly the same.
21:19:15 <Axman6> :(
21:19:17 <revenantphx> And there is never any other corruption.
21:19:32 <pastorn> Axman6: :~(
21:19:32 <lars9> hi, I have a problem about recursion in a State monad, could any one help me? the code and the explaination are well placed here: http://hpaste.org/paste/41886/bfs__problem
21:20:24 <ddarius> revenantphx: Actually, I know what the problem is.  It is working correctly.
21:20:29 <revenantphx> ddarius: orly?
21:20:45 <revenantphx> Is it laziness or order of execution?
21:20:51 <pastorn> lars9: so what's bff's objective?
21:20:57 <ddarius> It has nothing to do with order of evaluation.
21:21:23 <revenantphx> So how would I fix it?
21:21:32 <revenantphx> It only seems to be an issue with quoes
21:21:35 <ddarius> revenantphx: It is printing what you are telling it to print.  Think harder on what you are telling it to print.
21:22:13 <revenantphx> Well, given the $ I'm telling it to print the result of "Someone said: a" ++ msg ++ "a"
21:22:14 <lars9> pastorn: breadth first flattening, could you please scroll down that page? there are some comments
21:23:06 <pastorn> ah, saw that now :)
21:23:15 <revenantphx> ddarius: Not seeing the issue..
21:23:21 <revenantphx> :t (++)
21:23:22 <lambdabot> forall m. (Monoid m) => m -> m -> m
21:23:28 <revenantphx> hm
21:23:33 <ClaudiusMaximus> revenantphx: are you on windows?  maybe it's a textmode vs binarymode issue?
21:23:38 <lars9> yeah, this should be a general problem about recursion in a function returning a State Monad.
21:23:41 <revenantphx> No, OS X
21:23:49 <ddarius> revenantphx: What do you think the string you are ultimately giving to hPutStrLn h is?
21:24:03 <revenantphx> ddarius: "Someone said " message ""
21:24:09 <lars9> that is how to share the same State with recursive functions
21:24:10 <revenantphx> Well, once it evaluate.
21:24:30 <revenantphx> :t "Someone said: \"" ++ msg ++ "\""
21:24:30 <lambdabot> Not in scope: `msg'
21:24:36 <ddarius> revenantphx: Provide more detail.  Give an actual example.
21:24:41 <revenantphx> hPutStrLn h $ "Someone said: \"" ++ msg ++ "\""
21:24:45 <revenantphx> If msg is "hello world"
21:24:49 <revenantphx> then the output is...
21:25:01 <revenantphx> "omeone said: "hello world
21:25:05 <pastorn> lars9: ok, (ns ++ rest) differs from visited'', right?
21:25:06 <ddarius> revenantphx: Incorrect.
21:25:20 <revenantphx> ddarius: The program running here begs to differ with you.
21:25:34 <pastorn> lars9: i was thinking of you last line, the return statement
21:25:41 <ddarius> revenantphx: If msg is "hello world" it will print out 'Someone said "hello world"', but msg isn't "hello world".
21:25:54 <ddarius> revenantphx: I'm not faulting the program.  I'm faulting your assumptions.
21:26:11 <revenantphx> What is message then?
21:26:20 <lars9> pastorn: yeah, that line is need in either way
21:26:32 <revenantphx> input and output from telnet:
21:26:33 <revenantphx> TESTSTRING
21:26:34 <revenantphx> "omeone said: "TESTSTRING
21:27:07 <ddarius> revenantphx: You should be able to work backwards and figure out what msg must be.
21:27:21 <Eduard_Munteanu> Some '\r' thingy somewhere? Otherwise I can't see it either.
21:27:25 <ClaudiusMaximus> revenantphx: what line-ending conventions does telnet use?  what line ending conventions does hGetLine expect?
21:27:41 <revenantphx> ClaudiusMaximus: All of it should be \n only.
21:27:58 <revenantphx> I'm concerned that the S is being overwritten by a "
21:28:19 <pastorn> lars9: i don't really see the problem... could you provide another paste, maybe with two different versions of bff' with what you expect and what you get etc.?
21:28:23 <ClaudiusMaximus> revenantphx: try piping the output through hexdump
21:28:32 <revenantphx> HelloWorld
21:28:32 <revenantphx> HelloWorld
21:28:33 <revenantphx> "omeone said: "HelloWorld
21:28:39 <pastorn> (some more comments inside the code would be appreciated :)
21:28:48 <revenantphx> line 1 is input, 2 is output with no ++, 3 is with ++ 
21:29:10 <revenantphx> msg is exactly what I expect it to be ddarius.
21:29:17 <ddarius> revenantphx: How do you know?
21:29:23 <revenantphx> Because I JUST PRINTED IT.
21:29:31 <ddarius> And saw the -printable- characters.
21:29:37 <Eduard_Munteanu> Pipe it, don't copy&paste it.
21:29:39 <ClaudiusMaximus> try 'show' to escape them
21:29:46 <revenantphx> ClaudiusMaximus: mmk.
21:29:56 <lars9> pastorn: this is the correct version. i need to explictly get and put state before and after recursion.
21:30:20 <lars9> pastorn: is there anyway to avoid it, just use line 30 only?
21:30:33 <revenantphx> literal string is "Hello world\r"
21:30:44 <pastorn> ah, now i see
21:30:45 <Eduard_Munteanu> There you go.
21:30:47 <pastorn> lars9: no
21:30:48 <ddarius> Oh my!  What do you know?  msg /= "Hello world"
21:30:54 <revenantphx> So telnet's using \r\n sure.
21:30:54 <revenantphx> But
21:30:59 <revenantphx> that doesn't explain the issues.
21:31:03 <ddarius> Yes it does.
21:31:04 <pastorn> lars9: but what you can do instead would be to use the reader monad and the function 'local'
21:31:16 <revenantphx> No it doesn't. Why is the S in 'Someone' truncated?
21:31:22 <Eduard_Munteanu> Excerpt ... '\r"'
21:31:24 <ddarius> Put: putStrLn "Someone said: \"Hello world\r\"" into GHCi.
21:31:31 <monochrom> I just tested. telnet emits \r\n. So if you enter "hi<return>", hGetLine sees "hi\r"
21:31:34 <Xilon> revenantphx: The \r puts it back to the start of the line
21:31:37 <Eduard_Munteanu> So the last '"' is put at the beginning.
21:31:42 <revenantphx> Xilon: ACK right.
21:31:52 <pastorn> lars9: this is if you explicitly call the recursion yourself, and this won't work with the function 'forever' (fixM will work, though)
21:31:57 <revenantphx> I'm mixing up /r and /n again.
21:32:10 * revenantphx needs a trim function...
21:32:15 <Eduard_Munteanu> \r is carriage return
21:32:29 <monochrom> This is what I do to deal with it: hSetNewlineMode h NewlineMode{inputNL=CRLF,outputNL=CRLF}
21:32:32 <revenantphx> Eduard_Munteanu: I'm aware, I was just mixing it up with other uses.
21:32:46 <revenantphx> monochrom: but what if someone isn't using telnet :\
21:32:48 <monochrom> (you may omit the outputNL part if it suits you)
21:33:07 <monochrom> ah, you want to accept both \r\n and \n ?
21:33:17 <revenantphx> that's the thing, idk where it would come from.
21:33:23 <revenantphx> Might as well figure out how now.
21:33:28 <pastorn> lars9: reload hpaste, i made an annotation
21:33:35 <Eduard_Munteanu> Look in the telnet RFC then.
21:33:37 <monochrom> yes, you are better.
21:33:41 <lars9> pastorn: ok, let me look
21:33:56 <pastorn> lars9: with that you should be able to do just line 30 with
21:34:01 <revenantphx> @hackage string
21:34:01 <lambdabot> http://hackage.haskell.org/package/string
21:34:05 <pastorn> preservingState (bff' f ns')
21:34:09 <pastorn> oh
21:34:12 <pastorn> rest <- preservingState (bff' f ns')
21:34:28 <monochrom> well it's easy to be general: s<-hGetLine; if last s == '\r' then init s ...
21:34:53 <pastorn> lars9: shit... that short and a bug! I haven't used the state monad for some time now... one sec
21:35:38 <monochrom> alternatively \r is just whitespace so if the rest of your program is robust against whitespace, you don't even have to care.
21:35:48 <lars9> pastorn: sure, it's tricky
21:36:39 <pastorn> lars9: i'm back! now with less suck
21:36:42 <pastorn> (!)
21:37:09 <revenantphx> monochrom: Would I have to use a new variable?
21:37:18 <revenantphx> Or is there some way to condense it into one statement msg <- ...
21:37:49 <lars9> pastorn: let me test
21:37:52 <monochrom> yeah I think it's a good idea to use a new variable. let s' | last s == '\r' = init s | otherwise = s
21:38:12 <revenantphx> wait... guards? in my mona?
21:38:17 <revenantphx> what is this 0.o
21:38:31 <monochrom> oh you like if-then-else?  let s' = if last s == '\r' then init s else s
21:38:37 <revenantphx> no no, the guards are nice
21:38:43 <revenantphx> just didn't know you could do that
21:38:46 <monochrom> heh :)
21:39:58 <revenantphx> are the guards sugar?
21:40:05 <pastorn> revenantphx: yes
21:40:05 <revenantphx> or do they just work in multiple contexts
21:40:23 <revenantphx> @list
21:40:23 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
21:40:24 <pastorn> revenantphx: you can't use guards in monadic code unless you cheat
21:40:31 <pastorn> .paste
21:40:32 <revenantphx> pastorn ?
21:40:35 <pastorn> revenantphx: let me show you
21:40:37 <pastorn> @paste
21:40:38 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
21:40:40 <revenantphx> I just did it and it compiles
21:41:06 <lars9> pastorn: hi, i think what we need is "updateState" not "preservingState"? 
21:41:07 <pastorn> well, at the start of a monadic function, yes, but not in the middle of it
21:41:18 <revenantphx> Im guessing it's because of how let desugars
21:41:24 <pastorn> lars9: huh? write it and give it comments :)
21:41:41 <revenantphx> let x = xxxxxx becomes a lambda no?
21:41:51 <ddarius> No, it doesn't.
21:42:03 <revenantphx> Oh, my bad.
21:42:09 <revenantphx> Hm, how does it work thne > <
21:42:13 <revenantphx> (the guards)
21:45:35 <pastorn> revenantphx: http://hpaste.org/41891/cheating_with_guards
21:45:59 <pastorn> lars9: updateState = put ?
21:46:04 <revenantphx> 0.o
21:46:15 <revenantphx> it's totally fine with this
21:46:16 <revenantphx> let msg' | last msg == '\r' = init msg | otherwise = msg
21:47:12 <revenantphx> Is there a way to get the Socket (to get the host/port) from a Handle?
21:48:19 <revenantphx> @hoogle Handle -> Socket
21:48:19 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
21:48:20 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
21:48:20 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
21:48:24 <pastorn> revenantphx: why would you want that?
21:48:26 <monochrom> no, but accept tells you those. (handle, host, port) <- accept serversocket
21:48:38 <revenantphx> monochrom: Yeah I know, I'm just keeping track of all the handles.
21:48:44 <pastorn> revenantphx: seems like you should be using Network.Socket and maybe Network.BSD from the start :)
21:48:47 <revenantphx> And it'd be nice to get the other stuff from them.
21:48:51 <revenantphx> pastorn: yeah really :P
21:49:08 <monochrom> you should keep track of more than the handles.
21:49:10 <revenantphx> I could just keep track of host and port as well I guess.
21:49:14 <revenantphx> monochrom: yep
21:49:21 <augur> revenantphx: multiple definitions are, iinm, all collapsed into a case analysis
21:49:38 <pastorn> revenantphx: what are you working on?
21:50:32 <augur> foo 0 = 1; foo 1 = 2 ---> foo x = <conditional expression>
21:50:40 <revenantphx> pastorn: Just playing with a chat server :P
21:50:53 <augur> revenantphx: so if its all compiling down to a conditional anyway, you can stick in guards too
21:50:58 <revenantphx> kk.
21:51:00 <monochrom> and I know two reasons to find out client's host and port. (1) to stalk the users. (2) TracerT: http://www.youtube.com/watch?v=SXmv8quf_xM
21:51:05 <augur> thats just an extra part of the condition.
21:51:26 <revenantphx> localhost said: "Hello world" yay
21:51:42 <revenantphx> rofl.
21:51:50 <revenantphx> monochrom: Is this guy a disciple of Mike Sandy
21:51:56 <monochrom> I don't know.
21:52:34 <revenantphx> monochrom: are you familiar with see-em-dee?
21:53:48 <monochrom> I don't have see-em-dee dot ee-ex-ee on my linux
21:54:01 <revenantphx> uh oh, his ping is dropping. That's bad.
21:54:21 <revenantphx> "That's obviously a shared server where 4 people are all looking at google"
21:54:33 <revenantphx> "Last two digits stand for ip server connection number"
21:54:47 <pastorn> revenantphx: so you want to remember all the sockets of everyone connected to your server?
21:55:10 <revenantphx> pastorn: No no, I just keep track of them while they're connected to I can broadcast to all of them
21:55:35 <pastorn> [T/M]Var (Set Socket)
21:55:54 <pastorn> depending on if you like STM or not
21:56:05 <revenantphx> https://gist.github.com/718462
21:56:16 <revenantphx> The point was to do it with STM :P
21:56:30 <revenantphx> I fixed it to store handle, host, and port
21:57:08 <pastorn> revenantphx: i like how it starts with "Ignore Nothing"
21:57:12 <revenantphx> Testing
21:57:12 <revenantphx> localhost:57302 said: "Testing"
21:57:20 <pastorn> gives a feeling of robusteness
21:58:44 <revenantphx> heh.
21:59:07 <revenantphx> wait... here
21:59:07 <revenantphx> https://gist.github.com/718462
21:59:13 <revenantphx> Anything you see I could improve on here?
22:01:18 <pastorn> revenantphx: yes, the guard inside echo could benefin from a line break
22:01:24 <revenantphx> ?
22:01:37 <revenantphx> I gues
22:04:33 <pastorn> revenantphx: i dunno... maybe inside broadcast you could make your STM function return the actual message
22:04:47 <revenantphx> pastorn ?
22:05:35 <pastorn> wait... nevermind... that'll make that atomic block slower
22:06:06 * pastorn is a premature optimizer and thus avoids heavy STM functions like the plague
22:07:24 <Jafet> Optimizing concurrent IRC?
22:07:36 <Jafet> (It's pretty noble, carry on.)
22:08:07 <pastorn> revenantphx: i don't know if you think this is good style, but i don't like functions calling themselves indefinetly, so if i had written this i would have put the definition of 'acceptConnection' in a let in main
22:08:22 <pastorn> and then on the last row of main i'd have 'forever acceptConnection'
22:08:57 <revenantphx> Oh, sure.
22:09:06 <revenantphx> I could just add a forever there
22:09:34 <pastorn> sure :)
22:09:44 <revenantphx> I think I wanted to make sure that the state being passed was the newest.
22:09:48 <revenantphx> And not the original or somehting.
22:10:00 <fengshaun> do we have a foreverAndEverUntilTheCowsComeHome function analogous to forever?
22:10:00 <revenantphx> some silly thing
22:10:05 <pastorn> other than that i can't think of much... maybe use printf to make the 2nd line from the bottom look petter
22:10:07 <pastorn> *better
22:10:13 <revenantphx> there's a printf?
22:10:16 <revenantphx> :O
22:10:22 <revenantphx> joyous day.
22:10:33 <pastorn> revenantphx: check hackage :)
22:10:36 <pastorn> @where printf
22:10:36 <lambdabot> I know nothing about printf.
22:10:39 <pastorn> awww
22:10:58 <pastorn> > printf "do you know nothing %s?" "lambdabot"
22:10:58 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:10:59 <lambdabot>    `GHC.Show.Show a'
22:10:59 <lambdabot>      a...
22:11:02 <Jafet> It's there in case your code isn't already as ugly and questionably typed as the one in C
22:11:31 <pastorn> revenantphx: right... add type signatures :)
22:11:48 <revenantphx> pastorn: Yeah, I removed them since the types were chaning a lot.
22:11:52 <pastorn> hehe
22:11:54 <Jafet> @instances PrintfType
22:11:55 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
22:11:56 <revenantphx> I was just going to use :t to figure them all out afterwards :3
22:12:08 <Jafet> @instances-importing Text.Printf PrintfType
22:12:09 <lambdabot> (a -> r), IO a, [c]
22:12:28 <Jafet> (->)? Oh dear
22:12:32 <pastorn> Jafet: rigth... where c is an instance of "isChar"
22:12:38 <revenantphx> acceptConnection :: Socket -> (TChan [Char], TVar [(Handle, HostName, PortNumber)]) -> IO ThreadId
22:12:43 <revenantphx> great signature there.
22:12:54 <pastorn> Jafet: yes, that way it's a vararg function :)
22:12:55 <revenantphx> I dont really care to return the threadId though
22:12:58 <revenantphx> I'll add a return ()
22:13:12 <Jafet> The signature doesn't matter, as long as your code isn't in CPS
22:13:42 <revenantphx> Um. These signatures are terrible :D
22:13:46 <revenantphx> closeConn is 
22:13:47 <revenantphx> closeConn
22:13:47 <revenantphx>   :: (Show t, Show t1, Show t2, Eq t, Eq t1, Eq t2) =>
22:13:47 <revenantphx>      (t, t1, t2) -> (t3, TVar [(t, t1, t2)]) -> IO ()
22:13:51 <pastorn> Jafet: please stop... i feel my CPS related migrane coming
22:14:24 <pastorn> revenantphx: type Connection = (Handle, HostName, Port)
22:14:42 <pastorn> isn't that what you have?
22:14:52 <revenantphx> no, but I should add it.
22:15:32 <revenantphx> are [Char] and String analogous?
22:15:46 <pastorn> revenantphx: btw, shouldn't closeConn actually do something to kill the Handle/Socket?
22:15:49 <Eduard_Munteanu> String is a type synonym for [Char].
22:15:54 <Jafet> @src String
22:15:55 <lambdabot> type String = [Char]
22:15:57 <Xilon> type String = [Char]
22:16:01 <Xilon> Baw
22:16:04 <revenantphx> pastorn: probably, it happens when writing to the server fails though
22:16:08 <revenantphx> writing to the socket*
22:16:12 <revenantphx> so i was just kind of "we"
22:16:13 * pastorn hugs Xilon
22:16:18 <pastorn> conselation hug
22:17:43 <revenantphx> type Connection = (Handle, HostName, PortNumber)
22:17:43 <revenantphx> type ServerState = (TChan String, TVar [Connection])
22:17:46 <revenantphx> abstraction, like a boss.
22:17:57 <revenantphx> (also, pointless and just to make the type signatures legible!)
22:18:12 <tokenmathguy> in a case statement, is there a way to match regex?
22:18:31 <Jafet> mathguy: view patterns
22:18:43 <Jafet> (Or: no, you can't)
22:18:44 <revenantphx> https://gist.github.com/718462
22:18:47 <revenantphx> is this better?
22:18:55 <pastorn> tokenmathguy: there is probably like fiddy different regexp libraries on hackage
22:19:09 <pastorn> @hayoo regex
22:19:09 <lambdabot> Unknown command, try @list
22:19:16 <revenantphx> pastorn: better?
22:19:50 <revenantphx> echo is named badly.
22:20:34 <revenantphx> https://gist.github.com/718462
22:20:35 <revenantphx> thar
22:22:07 <pastorn> tokenmathguy: http://hackage.haskell.org/package/regex-base
22:22:45 <pastorn> tokenmathguy: if you download the .tar.gz, and look inside it, it contains two example files which are really simple
22:22:50 <pastorn> basically it seems to be
22:23:09 <Jafet> :t (=~)
22:23:11 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
22:23:12 <pastorn> string =~ regexString
22:23:17 <Jafet> Real simple
22:23:38 <pastorn> there is an instance of Bool for 'target', so yes :)
22:24:16 <tokenmathguy> pastorn: thanks for the reference
22:24:27 <tokenmathguy> Jafet: i will try =~
22:24:42 <tokenmathguy> looking to do this in case x of statement
22:25:34 <Jafet> Oh, you probably don't need view patterns for that
22:27:05 <tokenmathguy> worked like a champ. case x of ~"com" -> ... and it matches. thanks all
22:30:22 <ddarius> ...
22:30:49 <ddarius> tokenmathguy will figure it out eventually.
22:48:07 <adu> i found a hack to get around alex
22:48:12 <adu> :)
22:48:39 <Axman6> ... aww :(
22:48:43 * Axman6 feels unloved
22:49:04 <adu> Axman6: well, alex doesn't to unicode
22:49:36 <Axman6> i sure do :(
22:50:03 <adu> and I am writing a Go parser, which uses Unicode identifiers
22:50:21 <portnov> Hi all.
22:50:21 <portnov> updateMaybe Nothing Nothing = Nothing
22:50:21 <portnov> updateMaybe (Just x) Nothing = Just x
22:50:21 <portnov> updateMaybe Nothing (Just x) = Just x
22:50:21 <portnov> updateMaybe (Just _) (Just x) = Just x
22:50:22 <portnov> is there such a standard function?
22:50:34 <opqdonut> yes
22:50:43 <opqdonut> > Just 1 `mplus` Just 2
22:50:44 <lambdabot>   Just 1
22:50:48 <opqdonut> > Just 1 `mappend` Just 2
22:50:49 <lambdabot>   Ambiguous type variable `t' in the constraints:
22:50:49 <lambdabot>    `Data.Monoid.Monoid t'
22:50:49 <lambdabot>  ...
22:50:57 <pastorn> portnov: flip mplus
22:50:57 <opqdonut> hrm
22:51:05 <opqdonut> > Just 1 >> Just 2 
22:51:05 <portnov> hm
22:51:06 <lambdabot>   Just 2
22:51:06 <pastorn> since you want to select the 2nd if both are Just
22:51:19 <portnov> > Nothing `mplus` Just 1
22:51:20 <lambdabot>   Just 1
22:51:36 <portnov> > Just 1 `mplus` Just 5
22:51:37 <lambdabot>   Just 1
22:51:44 <adu> so to be compatible with the 2 existing compilers, I'm separating out the lexing into 2 stages: (1) turn unicode identifiers into #[日本] and leave other ascii identifiers as is, then (2) pass the output to alex which doesn't care what's between #[ and ]
22:51:51 <pastorn> > let f = flip mplus in (Just 1) `f` (Just 5)
22:51:52 <lambdabot>   Just 5
22:51:55 <Axman6> it's flip mplus i think
22:52:03 <portnov> aha, flip mplus seems to be it. Thanks pastorn.
22:52:15 <opqdonut> :t mplus
22:52:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
22:52:39 <opqdonut> using mplus for that is kinda ugly if you're not using the Monad semantics of Maybe
22:53:20 <portnov> opqdonut: you suppose writing such a function by hands?
22:53:26 <portnov> as I did?
22:53:29 <portnov> :)
22:53:31 <opqdonut> maybe, yeah
22:53:33 <pastorn> portnov: you can also do it quite easily with
22:53:36 <pastorn> @type maybe
22:53:37 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
22:54:15 <adu> portnov: i would prefer flip mplus anyday
22:54:19 <pastorn> f mb0 mb1 = maybe mb1 Just mb0
22:55:00 <pastorn> portnov: knowing the functions in http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Data-Maybe.html by hand is very useful :)
22:55:10 <pastorn> *by heart
22:55:37 <pastorn> knowing english by heart, on the other hand, is not
22:56:55 <adu> knowing english is useful
22:57:29 <pastorn> adu: me thinks you missed teh funnay
22:57:41 <adu> apparently
22:57:45 <adu> what was it?
22:58:24 <pastorn> adu: i wrote "by hand" when i meant "by heart"
22:58:42 <adu> ha
22:58:48 <pastorn> adu: precisely
22:58:59 <adu> well, not so funny
22:59:02 <pastorn> hehe
23:00:02 <adu> if it was really funny i would have repeated "ha"
23:00:40 <pastorn> > cycle "ha"
23:00:41 <lambdabot>   "hahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahahaha...
23:00:49 <adu> lol
23:00:54 <adu> now that's funny
23:01:22 <Veinor> > fix error
23:01:23 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
23:01:26 <Veinor> never gets old
23:01:37 <adu> lololol
23:01:58 <pastorn> "catch me if you can"
23:02:52 <Jafet> > fix ("*Exception: "++)
23:02:54 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
23:03:43 <ddarius> It's also mappend for Last.
23:03:52 <Veinor> > fix error !! 0
23:03:53 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:04:03 <Veinor> :t fix error !! 0
23:04:04 <lambdabot> Char
23:05:13 <Jafet> :t fix error
23:05:14 <lambdabot> [Char]
23:05:25 <Jafet> Oh
23:05:33 <Jafet> Recursion is weird
23:06:37 <pastorn> ehm... wait a minute
23:06:47 <pastorn> should't that be a type mis-match?
23:06:57 <Veinor> :t error
23:06:58 <lambdabot> forall a. [Char] -> a
23:07:05 <pastorn> (!!) :: [a] -> Int -> a, not String
23:07:18 <Veinor> String is a synonym for [Char]
23:07:26 <pastorn> Veinor: yes, i know this
23:07:46 <Veinor> :t fix (error :: String -> String)
23:07:47 <lambdabot> String
23:08:00 <pastorn> :t error
23:08:01 <lambdabot> forall a. [Char] -> a
23:08:32 <pastorn> and (!!) :: [a] -> Int -> a, not String
23:08:45 <Veinor> right
23:08:49 <Jafet> :t fix error
23:08:50 <lambdabot> [Char]
23:08:58 <Jafet> :t (!!) (fix error)
23:08:59 <lambdabot> Int -> Char
23:09:00 <pastorn> wait... either way !! gets executed before error
23:09:16 <pastorn> but error :: String -> a, not error :: [a]
23:09:30 <pastorn> so !! should complain that error isn't a list
23:09:39 <Jafet> > (fix error) !! (0)
23:09:40 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:10:06 <pastorn> at least when my head typechecks this it should
23:11:03 <ManateeLazyCat> Hmm, video still not clear : http://www.tudou.com/programs/view/oSgtds3rxdM/
23:11:18 <Jafet> Why does fix error have quotes around it, anyway?
23:11:19 <ManateeLazyCat> YouTube.com uploading
23:11:39 <pastorn> ManateeLazyCat: what's your goal with the whole thing?
23:11:41 <augur> linguistics nerds rejoice: http://www.wellnowwhat.net/blog/?p=434
23:11:47 <pastorn> next generation of emacs?
23:11:55 <ManateeLazyCat> pastorn: Next generateion OS
23:12:06 <augur> or not. its just a way of connecting up the reader monad to linguistic semantics
23:12:10 <pastorn> so next generation emacs, then
23:12:15 <ManateeLazyCat> pastorn: You can watch video http://www.tudou.com/programs/view/oSgtds3rxdM/
23:12:22 <ManateeLazyCat> pastorn: Not clear
23:12:38 <pastorn> am doing so
23:12:43 <pastorn> but it streams slooooooooooowly
23:12:46 <ManateeLazyCat> pastorn: I'm uploading video to YouTube.com hope YouTube won't compress my video
23:12:49 <pastorn> also: vocoders... i can't take this
23:13:00 <pastorn> ManateeLazyCat: vimeo?
23:13:11 <ManateeLazyCat> pastorn: vimeo in GFW list.
23:13:21 <pastorn> whut?
23:13:39 <ManateeLazyCat> pastorn: All my proxy tool killed by GFW, just GAppProxy can work, but GAppProxy can't upload *large* file.
23:13:55 <ManateeLazyCat> pastorn: GFW is "Great Firewall" that develop by China gov
23:14:05 <ManateeLazyCat> pastorn: To limit freedom of internet.
23:14:23 <pastorn> ManateeLazyCat: sweet...
23:14:25 <pastorn> ehm...
23:14:53 <ManateeLazyCat> pastorn: I install Windows on my WM, and use a Windows Proxy tool uploading to YouTube.com
23:15:09 <ManateeLazyCat> pastorn: Just that one can upload video through GFW now, sadly.
23:15:35 <ManateeLazyCat> s/WM/VM
23:15:36 <pastorn> ManateeLazyCat: google video, perhaps?
23:15:40 <pastorn> is that still alive?
23:16:30 <teeler> should be
23:16:39 <teeler> maybe not.
23:17:23 <ManateeLazyCat> pastorn: I give you a list that can't access in China (if you don't use proxy tool) : Facebook, Twitter, Google, YouTube, WordPress, Blogsopt, Dropbox, Picase, ...etc.
23:18:05 <pastorn> ManateeLazyCat: woriking in IT, living in Chine must be *awesome*
23:18:16 <ManateeLazyCat> pastorn: Yes. :)
23:18:23 <ManateeLazyCat> pastorn: Fighting GFW everyday
23:18:42 <ManateeLazyCat> pastorn: I have collect many proxy tool in my box for ready switch
23:19:02 <ManateeLazyCat> pastorn: I will find time develop new proxy tool in Manatee, 
23:19:03 <pastorn> ManateeLazyCat: can't you have someone set up a server somewhere outside china, like korea or japan and then you dirty business remotely?
23:19:09 <pastorn> vnc or ssh or whatever
23:19:30 <ManateeLazyCat> pastorn: I use GAppProxy, good enough except can't upload *large* file.
23:20:01 <pastorn> ManateeLazyCat: are you going to port it to work in House?
23:20:10 <pastorn> you should...
23:20:12 <pastorn> :p
23:20:45 <ManateeLazyCat> pastorn: I will give you YouTube.com link after i uploading complete.
23:21:04 <ManateeLazyCat> pastorn: Then you will know what's the thing that Manatee can do, and Emacs can't do.
23:21:19 <pastorn> heh, cool :)
23:21:52 <ManateeLazyCat> pastorn: http://www.tudou.com/programs/view/oSgtds3rxdM/ is not clear, but still have some idea you can understand.
23:22:36 <pastorn> ManateeLazyCat: i can't use that service... it's too slow... i get to watch ~ 6 seconds between buffering times (~3 seconds)
23:22:47 <ManateeLazyCat> pastorn: Oh, i see.
23:23:00 <ManateeLazyCat> pastorn: It's server at China.
23:23:01 <pastorn> ManateeLazyCat: i'll watch it once you've put it on youtube... and what's up with the vocoders?
23:23:22 <ManateeLazyCat> pastorn: You mean background music?
23:23:26 <pastorn> yes
23:23:47 <ManateeLazyCat> pastorn: Owl City's song : Fireflies
23:24:33 <ManateeLazyCat> I wonder so many people don't know "Owl City" it's my favorites artist. :)
23:25:01 <pastorn> ManateeLazyCat: it might be an indication... :p
23:26:36 <ManateeLazyCat> pastorn: You can see screenshot : http://goo.gl/MkVw, but just video can show my idea. :)
23:27:40 <ManateeLazyCat> pastorn: Manatee = Chrome (Sandbox) + Emacs (Behaviour) + GTK+ (Render Engine) + Haskell (concurrent) + Me (Idea). :)
23:27:41 <ddarius> Jafet: fix error :: String, how do you show a String?
23:28:50 <Jafet> > head (fix error)
23:28:51 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:29:08 <pastorn> ManateeLazyCat: how many lines is your project now?
23:29:17 <Jafet> So the value of fix error isn't the value of fix error.
23:29:37 <Veinor> Jafet: ?
23:29:52 <ManateeLazyCat> pastorn: All features: 23542
23:30:04 <pastorn> you're nuts
23:30:07 <Veinor> > null (fix error)
23:30:08 <lambdabot>   *Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
23:30:10 <pastorn> :)
23:30:11 * ddarius agrees with pastorn.
23:30:24 <Veinor> fix error is a string such that attempting to get any information about it results in an exception
23:30:30 <ManateeLazyCat> pastorn: Many detail haven't implement
23:30:40 <Axman6> > 1 + fix error
23:30:41 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
23:30:41 <lambdabot>    arising from the literal ...
23:30:45 <Axman6> :(
23:30:50 <Veinor> well that just won't typecheck!
23:30:56 <Jafet> But the exception that results from accessing that information contains that information
23:31:05 <ManateeLazyCat> pastorn: I hope one day reach 1 million lines. :)
23:31:15 <pastorn> ManateeLazyCat: i sincerely hope you don't
23:31:22 <Axman6> ManateeLazyCat: you should hope to one day reach 10,000 lines ;)
23:31:38 <ManateeLazyCat> pastorn: I will develop framework, then let people help me develop extension
23:31:42 <ManateeLazyCat> pastorn: Just like firefox.
23:31:56 <Veinor> Jafet: ?
23:32:02 <Veinor> > error "whoops!"
23:32:03 <lambdabot>   *Exception: whoops!
23:32:05 <ManateeLazyCat> Manatee = Chrome (Sandbox) + Firefox (Extension) + Emacs (Behaviour) + GTK+ (Render Engine) + Haskell (concurrent) + Me (Idea). :)
23:32:09 <Veinor> > head $ error "whoops!"
23:32:10 <lambdabot>   *Exception: whoops!
23:32:32 <ManateeLazyCat> Axman6:  10,000 ?
23:35:00 <ManateeLazyCat> Go to sleep ... hope upload finish when i wake up. 
23:35:35 <Jafet> How many lines now is emacs?
23:36:13 <adu> Jafet: do you mean lines of code?
23:38:52 <pastorn> anyone here proficient in template haskell?
23:39:03 <pastorn> if i have a lot of files in say ./DIR/
23:39:33 <ski> > undefined :: String  -- Jafet
23:39:35 <lambdabot>   "*Exception: Prelude.undefined
23:39:35 <pastorn> and i want to have a list of all functions of a certain type in all files in that directory, is this possible?
23:40:17 <ddarius> pastorn: Sure.
23:40:26 <adu> what is Manatee?
23:40:40 <pastorn> adu: http://hackage.haskell.org/packages/archive/pkg-list.html#cat:manatee
23:46:59 <adu> fascinating, sounds like Yi
23:49:15 <ddarius> Yi has a much more limited scope than Manatee it seems.
23:49:18 <pastorn> adu: http://www.flickr.com/photos/48809572@N02/
23:58:47 <A1kmm> Does anyone know if there is a process for dealing with packages in Hackage which still depend on base < 4 if the maintainer doesn't respond to patches?
23:59:02 <A1kmm> (patch sent on the 16th of November).
