00:22:31 <pygmalion> can anyone give me some tips for removing the redundancies here? http://hpaste.org/41600/too_verbose
00:23:20 <kmc> f x y PlayerA = x; f x y PlayerB = y
00:23:53 <kmc> leftPit = f playerBPit playerAPit player
00:24:19 <kmc> also you can factor topRow like:  topRow = reverse $ case ...
00:24:40 <kmc> also you can bind a tuple, e.g.
00:25:00 <kmc> (leftPit, rightPit) = case player of PlayerA -> (playerBPit, playerAPit) | PlayerB -> ...
00:26:26 <pygmalion> kmc: will that work for a 4-tuple?
00:26:30 <kmc> yes
00:26:39 <pygmalion> perfect...
00:27:46 <kmc> :t flip (flip (!!) . fromEnum)
00:27:47 <lambdabot> forall a a1. (Enum a1) => [a] -> a1 -> a
00:28:31 <kmc> .... that's apropos of nothing
00:29:53 <pygmalion> kmc: better? http://hpaste.org/paste/41600/fix#p41601
00:30:14 <kmc> pygmalion, looks good
00:30:23 <pygmalion> kmc: thanks for your help
00:30:26 <kmc> no problem :)
00:30:32 <kmc> your variable names are pretty long... most Haskell code i've seen uses short names for local identifiers
00:30:44 <kmc> i'm not saying you're wrong though
00:31:02 <vegai> most Haskell code I've seen is utter crap because of just that, kmc
00:31:07 <pygmalion> kmc: this is for an assignment, so i'd rather be more verbose and clear than more concise i think
00:31:17 <kmc> yeah
00:31:20 <kmc> vegai, utter crap?
00:32:05 <vegai> yes. Examples, blog articles, even library code that's supposed to be production level is littered with those
00:32:33 <vegai> because Haskell programmers are too clever
00:32:45 <bpalmer> too much math heritage.
00:32:47 <kmc> and this alone makes it "utter crap" as opposed to maybe "one negative point in a complex nuanced assessment of software quality"
00:32:50 <kmc> of course it does
00:33:02 <kmc> because on the internet, nobody takes you seriously unless your criticisms are absurd hyperbole
00:33:27 <vegai> utter craphood is much easier to achieve than the opposite :)
00:34:36 <vegai> yes, math :-/
00:34:49 <kilimanjaro> naming conventions are one thing I sort of liked about scheme style
00:34:51 <vegai> perhaps mathematicians shouldn't be allowed to write code :-P
00:35:15 <kmc> haha
00:35:40 <vegai> that's like allowing physicists to act as surgeons, isn't it :P
00:35:40 <kmc> but all haskell programmers are mathematicians
00:35:53 <kmc> fact: it is impossible to write Haskell code of any kind unless you have three PhDs in category theory
00:36:18 * motolep can't tell who's trolling whom in this conversation
00:36:34 <kmc> two is only enough to write OCaml
00:37:36 <kmc> vegai, you know what they call the person at the bottom of the graduating class in medical school?
00:37:54 <vegai> is this a trick question?
00:37:57 <kmc> yes
00:38:00 <kmc> the answer is "doctor"
00:38:09 <vegai> :)
00:39:17 <kmc> you should name your haskell vars with http://www.classnamer.com/
00:40:20 <Ke> those actually make sense
00:40:27 <motolep> kmc: no can do, they all start with uppercase :(
00:40:54 <Ke> motolep: _class_ name
00:41:01 <Ke> like Num
00:41:24 <kmc> invert case
00:41:26 <motolep> Ke: kmc said vars!
00:41:33 <kmc> for enterprise compatibility
00:41:38 <caleb_> hi everyone newbie here need help
00:41:47 <shachaf> kmc: lLAMAcASE?
00:41:48 <kmc> hi caleb_, welcome :)
00:41:52 <kmc> what's your question?
00:42:00 <caleb_> thanks kmc
00:42:03 <dancor> onHead toLower
00:42:07 <caleb_> im using ghci
00:42:41 <caleb_> to load a module Text.XML.HXT.Arrow
00:43:00 <caleb_> but it can;t find the module
00:43:18 <caleb_> I have use cabal to install the hxt package
00:43:41 <kmc> caleb_, the doc doesn't show that as a module, only a namespace that other modules live in
00:43:42 <kmc> http://hackage.haskell.org/package/hxt
00:43:50 <kmc> perhaps it changed in some version of the library?
00:44:19 <dancor> if you don't like a haskell library, wait five minutes
00:44:40 <kmc> hehe
00:45:00 <caleb_> dancoe, what do u mean
00:45:17 <dancor> caleb_: it's a joke about libraries changing too often
00:45:34 <caleb_> haha
00:45:38 <dancor> :D
00:45:48 <kmc> if you don't like a java feature, wait five decades
00:46:02 <caleb_> that is what expected in language like this
00:46:07 <caleb_> :)
00:46:26 <silver> kmc, till java dies? cause they don't remove features like ever
00:46:38 <silver> they just add more of them
00:46:52 <kmc> i'm thinking of features like "no first class functions"
00:46:56 <kmc> some may consider that an un-feature
00:47:19 <motolep> silver: they don't remove features ever, but they very rarely add features either :P
00:47:27 <silver> :-)
00:48:09 <lars9> is there an alias for EOL? 
00:48:16 <lars9> for "\n"
00:48:33 <kmc> the string or the char?
00:48:41 <kmc> you can make an alias yourself
00:48:47 <kmc> > "\EOL"
00:48:48 <lambdabot>   <no location info>:
00:48:48 <lambdabot>      lexical error in string/character literal at chara...
00:48:50 <kmc> > "\CR"
00:48:50 <lambdabot>   "\r"
00:48:55 <kmc> > "\LF"
00:48:55 <lambdabot>   "\n"
00:49:20 <dancor> > "\10"
00:49:21 <lambdabot>   "\n"
00:49:37 <dancor> > "\x0A"
00:49:38 <lambdabot>   "\n"
00:50:10 <lars9> what is f in f n = concate . replicate n ?
00:50:41 <motolep> :t let f n = concat . replicate n in f
00:50:42 <lambdabot> forall a. Int -> [a] -> [a]
00:51:26 <lars9> oh i meant is there any existing function for this?
00:51:57 <motolep> @hoogle Int -> [a] -> [a]
00:51:58 <lambdabot> Prelude drop :: Int -> [a] -> [a]
00:51:58 <lambdabot> Prelude take :: Int -> [a] -> [a]
00:51:58 <lambdabot> Data.List drop :: Int -> [a] -> [a]
00:52:10 <dancor> i don't think there is
00:52:37 <dancor> it doesn't feel like a fundamental thing to do to me
00:52:55 <dancor> (\ n -> concat . replicate n)
00:53:04 <lars9> i see
00:53:18 <dancor> (concat .) . replicate
00:53:27 <dancor> is crazy pointfree form
00:54:03 <shachaf> fmap (fmap join) replicate
00:55:09 <TryingToLearnHas> hello 
00:55:22 <TryingToLearnHas> can any help me on this ... http://hpaste.org/41602/usefoldrmapontree
01:02:20 <ksf> a -> b) -> f [a] -> f [b] looks wrong.
01:02:35 <ksf> f already is [], no reason to put it in there.
01:02:39 <ksf> same goes for foldr
01:03:57 <ksf> ...your' missing an argument in those map functions, they take three.
01:04:12 <ksf> map f initVal EmptyTree = initVal
01:04:23 <ksf> er bullshit that's foldr
01:04:53 <ksf> also, you can't split your instance into two like that.
01:05:11 <ksf> if that's homework, complain that you weren't told enough to do that exercise.
01:08:48 <TryingToLearnHas> ksf: I agreed that it should be this   fstructureMap :: (a -> b) -> f a -> f b 
01:09:19 <TryingToLearnHas> but when I do this :
01:09:21 <TryingToLearnHas> instance Structure [] where    fstructureMap f [xs] = [map f xs]
01:09:33 <ksf> fstructureMap = map
01:09:35 <ksf> @src map
01:09:35 <lambdabot> map _ []     = []
01:09:36 <lambdabot> map f (x:xs) = f x : map f xs
01:09:59 <TryingToLearnHas> putStrLn "HW8.1e>fstructureMap (+2) [[3,4,5]])"    print (fstructureMap (+2) [[3,4,5]])   putStrLn ""
01:10:09 <TryingToLearnHas> I get a big error
01:10:53 <TryingToLearnHas> actually  [3,4,5] 
01:11:07 <TryingToLearnHas> still big error
01:11:35 <ksf> I suggest you first try implementing mapList :: (a -> b) -> [a] -> [b], mapTree :: (a -> b) -> Tree a -> Tree b by themselves, to reduce confusion.
01:12:32 <ManateeLazyCat> Hi all. :)
01:12:52 * hackagebot derivation-trees 0.7.3 - Typeset Derivation Trees via MetaPost  http://hackage.haskell.org/package/derivation-trees-0.7.3 (JeanPhilippeBernardy)
01:13:44 <TryingToLearnHas> ksf, got rid that error
01:13:51 <TryingToLearnHas> ok I will try that 
01:13:57 <b_jonas> wow there's new ghc
01:14:50 <b_jonas> I'll have to look at this. I hope the threading runtime is changed in the direction I wish. 
01:15:05 <ksf> haskell is #1 in thread-ring now.
01:15:10 <ksf> so I'd wager it did.
01:15:53 <b_jonas> I'll read the short changes 
01:16:31 <b_jonas> where's the ghc homepage? 
01:16:51 <ksf> @where ghc
01:16:52 <lambdabot> http://haskell.org/ghc
01:17:08 <b_jonas> the link from the wiki has disappeared, argh
01:17:29 <b_jonas> thansk
01:18:18 <Marco____> :t e1 => e2 
01:18:19 <lambdabot> parse error on input `=>'
01:18:38 <Marco____> :t inc            :: Integer -> Integer
01:18:39 <lambdabot> Not in scope: `inc'
01:18:51 <b_jonas> hmm, it doesn't have the user's guide for the new version online
01:18:57 <b_jonas> I'll have to download the whole package then
01:19:26 <b_jonas> ah, here it is, http://new-www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html
01:19:31 <b_jonas> it's just not linked from the documentation page
01:19:51 <b_jonas> could you fix http://haskell.org/haskellwiki/GHC so it links to the latest docs?
01:20:22 <ksf> rather not, it links to latest.
01:21:00 <b_jonas> isn't 7.0.1 the latest?
01:21:30 <b_jonas> it links to an url without a version number, which redirects to the 6.12.2 docs
01:22:31 <ksf> either the ghc guys missed that, or they want latest to point to 6.12.2
01:24:48 <Saizan> you could send a reply to the 7.0.1 announce asking to update http://www.haskell.org/ghc/docs/latest/
01:25:18 <TryingToLearnHas> ksf: is this right
01:25:19 <TryingToLearnHas> instance Structure Tree where   fstructureMap f EmptyTree = []
01:25:41 <ksf> nope, lists aren't trees.
01:25:50 <ksf> it also won't typecheck.
01:27:13 <ksf> you need to return a tree, and the only thing you _can_ put in place of your [] is EmptyTree.
01:27:13 <TryingToLearnHas> then what is a map on an EmptyTree then?
01:27:19 <ksf> ...which is also correct.
01:27:30 <ksf> changing the elements of an empty tree is still an empty tree. 
01:27:35 <TryingToLearnHas> ok
01:27:40 <ksf> everything else would be conjuring up elements out of thin air.
01:28:00 <TryingToLearnHas> haha ummm ok 
01:28:47 <Marco____> Hello
01:29:09 <dancor> unix sockets allow multiple connections.  named pipes allow permissions.  how do you get both?
01:29:50 <Marco____> Someone of you guys know where I can get a List of all built-in Haskell functions and their types .. I am getting ready for my winter class
01:29:57 <Mitar> is it possible to store username and password somewhere for cabal upload?
01:30:08 <Marco____> Mitar: yes
01:30:14 <ksf> Marco____, _all_ of them?
01:30:27 <b_jonas> Saizan: reply to what announce? what list? I'm nost subscribed to anything like that
01:30:27 <Mitar> i see You can store your Hackage login in the ~/.cabal/config file in help
01:30:31 <Mitar> but what is syntax?
01:30:33 <Marco____> ksf: yes if its possible
01:30:40 <ksf> depending on what you mean, the Prelude, the GHC primops, or all of hackage.
01:30:43 <Mitar> aha, i see
01:30:44 <Mitar> ok ;-)
01:31:18 <b_jonas> dancor: on Linux, unix sockets allow permissions too, otherwise try SO_PASSCRED
01:31:28 <Marco____> The prelude
01:32:18 <TryingToLearnHas> ksf: my tree is not a binary tree, but a tree with many children , so how do I go about trying to transverse it so I can map the Nodes 
01:32:18 <ksf> http://cs.anu.edu.au/student/comp1100/haskell/tourofprelude.html
01:32:31 <ksf> you use your map on lists
01:33:10 <TryingToLearnHas> so I need to 1st turn the Tree to a list correct?
01:33:16 <ksf> that is, you map your map on trees over the nodes by using your map on lists.
01:33:20 <dancor> b_jonas: ah, i guess i want unix domain sockets?
01:33:22 <ksf> nope.
01:34:00 <b_jonas> dancor: yes, but you're right in that on some systems they don't honor file system permissions
01:34:00 * hackagebot NXT 0.1.1 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1.1 (MitarMilutinovic)
01:34:07 <b_jonas> dancor: it's only on linux that they do
01:35:06 <quicksilver> really? other OSes don't honour file permissions on unix socket? Weird.
01:35:16 <quicksilver> I thought file permissions was one of the main reasons to choose to use unix sockets.
01:35:30 <b_jonas> quicksilver: no, the reason is that they're faster than ip sockets
01:35:41 <merijn> FreeBSD and OSX both honour file permissions on unix sockets...
01:35:46 <b_jonas> and have a larger (so more managable) namespace
01:36:24 <quicksilver> I don't believe it's because they're faster.
01:36:40 <quicksilver> (a) I don't see why any reasonable kernel would make them substantial faster than loopback ip
01:36:57 <quicksilver> (b) I flat out don't believe that any reasonable proportion of users of them cares about that speed difference.
01:37:11 <merijn> quicksilver: I agree with b, not entirely sure about a
01:37:13 <b_jonas> quicksilver: ip has to go through iptables and stuff, but it's really for old bad kernels that don't optimize ip well where unix sockets are much faster
01:37:14 <lars9> how to convert an Int to String with fixed width?
01:37:24 <merijn> IP restricts packet size, unix domain does not
01:37:29 <b_jonas> quicksilver: and you do care about the latency difference on a slow system if you run X11
01:37:43 <Marco____> ksf: Any link 
01:37:51 <b_jonas> quicksilver: because all the images and mouse moves and other updates go through sockets, multiple times
01:37:54 * quicksilver nods
01:37:55 <ksf> Marco____, http://cs.anu.edu.au/student/comp1100/haskell/tourofprelude.html
01:38:05 <Marco____> ksf: thank you man
01:38:09 <quicksilver> b_jonas: don't modern Xes use SHM for images?
01:38:15 <quicksilver> where by modern I mean "last 20 years"
01:38:19 <b_jonas> quicksilver: no idea
01:38:21 <b_jonas> I don't follow it
01:38:24 <quicksilver> ;)
01:38:30 <b_jonas> it probably doesn't make a difference in modern systems
01:39:00 <b_jonas> but it did make sense with slow cpus where a large part of the cpu time was paid on updating the screen
01:39:56 <b_jonas> I for one am currently running on a remote X system where everything goes through multiple links of 100 MB ethernet and it doesn't lag unless I use firefox
01:40:11 <b_jonas> so the unix sockets aren't needed today
01:40:17 <lars9> Text.Printf does
01:40:25 <b_jonas> quicksilver: but there's still the larger so more managable namespace
01:40:42 <b_jonas> tcp/udp has 2^32 ports, you have to manage that for all users
01:40:52 * quicksilver nods
01:41:02 <quicksilver> yes, the namespace I agree with.
01:41:10 <ksf> ...each connection taking up two ports.
01:41:23 <ksf> you could spawn more interfaces, though.
01:41:34 <quicksilver> ksf: well if it's a server the listening end only takes up one port for all the clients
01:41:38 <quicksilver> but still, I agree.
01:41:43 <b_jonas> and I guess decades ago people used to run X11 on unix systems without an ip stack
01:42:12 <ksf> wait is X older than tcp?
01:42:27 <quicksilver> I think early X was remote more often than it was local
01:42:36 <ksf> yeah but over what protocol
01:42:56 <b_jonas> ksf: probably not older, but it's not that all machines had it
01:42:57 <ksf> terminals on a mainframe don't need tcp/ip
01:43:10 <b_jonas> I'm young, so I don't really know
01:43:21 <Jafet> Serial, probably.
01:43:46 <merijn> Anyhoo, whoever said only linux enforces file permissions on unix sockets...you're wrong
01:44:01 <merijn> I just tested on OSX and FreeBSD and it indeed works there too
01:44:11 <b_jonas> merijn: that's not what I said
01:44:19 <b_jonas> merijn: I said that some unix systems don't enforce it
01:44:25 <b_jonas> I'm not saying linux is the only one
01:44:41 <merijn> I'm pretty sure that those systems don't confirm to the unix standards then
01:45:24 <b_jonas> which ones? susv?
01:46:14 <merijn> Whichever one specifies the behaviour of unix domain sockets. Giving the amount of standards there's bound to be one...
01:46:27 <Marco____> Any one knows what pills to take to be smarter???
01:46:39 <b_jonas> merijn: yes, that's the good thing in standards, that there are so many
01:46:51 <merijn> Marco____: My strategy is to hang out here in #haskell and hope you can get smarter via osmosis :p
01:47:01 <sipa> the red pill
01:47:17 <Marco____> merjin: hahahaha
01:47:31 <Marco____> sipa: red pill I prefer the white one
01:48:10 <merijn> #haskell is a gateway drug to reading mathematics papers
01:48:24 <Marco____> ok bye 
01:48:32 <Marco____> ksf: Any one knows what pills to take to be smarter???
01:48:46 <ksf> practice.
01:48:52 <Marco____> kool
01:48:54 <ksf> practice and experience.
01:49:01 <Marco____> where to buy that at
01:49:05 <Marco____> ?
01:49:20 <Marco____> tell me a place or street and I will go all of way
01:49:48 <ksf> at the time shop. it trades time for other time.
01:50:09 <Marco____> ksf: koolest thing ever
01:50:11 <ksf> you might want to read http://en.wikipedia.org/wiki/Momo_(novel)
01:50:18 <Marco____> ksf: ok kool
01:50:59 <Marco____> whats that do?
01:51:07 <Marco____> this http://en.wikipedia.org/wiki/Momo_(novel)
01:51:29 <Mitar> ksf: really very very good book
01:51:31 <b_jonas> yes, that's a good book
01:51:39 <b_jonas> but how is that related?
01:51:40 <Marco____> oh 
01:52:11 * shachaf wonders why _Jim Knopf_ is so unavailable in English.
01:52:21 <Mitar> Jim Knopf?
01:52:28 <merijn> Since we're grossly off-topic anyway...quick poll: The three most influential computer scientists?
01:52:33 <ksf> well, Marco____ wanted to know how to get smarter, for which he needs practice and experience, for which he needs time, and to have that it's useful to have read momo.
01:52:38 <shachaf> Mitar: _Jim Button_, maybe?
01:52:53 <Mitar> i wasn't aware of him ;-)
01:53:21 <merijn> I was thinking Church, Turing and von Neumann were the most obvious candidates, but unsure if I'm skipping over anyone...
01:53:32 <lars9> @src concatMap
01:53:32 <lambdabot> concatMap f = foldr ((++) . f) []
01:53:41 <b_jonas> ksf: ah, I see 
01:53:43 <shachaf> Mitar: Another book by Michael Ende.
01:53:54 <ksf> or you could invest the time reading momo would take you at the time bank, which would give you interest but actually smoke your time like pot.
01:54:00 <Mitar> aha, i read that: http://en.wikipedia.org/wiki/Jim_Knopf
01:54:32 <b_jonas> what I wondered is how come The Moon is a Harsh Mistress by Robert Heinlein seems to have no Hungraian translation
01:54:41 <Jafet> -- OR
01:54:41 <Jafet> concatMap = (concat.) . map
01:54:52 <b_jonas> because normally every popular book is translated, though many of the newer translations suck
01:55:06 <Jafet> Too little of Stanislaw Lem is in english.
01:55:11 <b_jonas> it's not like I wanted to read the translation, it's just bad
01:55:22 <Mitar> lem is great
01:55:34 <b_jonas> Jafet: yes, it does seem like too few English translations in general
01:55:38 <shachaf> Mitar: You read _Jim Knopf_? In what language?
01:55:54 <b_jonas> they just don't care about all that much the non-English literature
01:56:08 <b_jonas> Jim Knopf is silly
01:56:12 <b_jonas> it's not even funny
01:56:19 <ksf> it was never supposed to be.
01:56:22 * shachaf keeps being told (by the same person) to read _The Cyberiad_.
01:56:35 <b_jonas> shachaf: you should read it, yes
01:56:44 <ksf> it's ende coming to terms with WWII
01:56:45 <Mitar> no, i haven't read jim knopf
01:56:51 <shachaf> Mitar: Oh.
01:57:20 <shachaf> I keep trying to get hold of an English copy, but it looks like the price at Amazon is $2400 nowadays.
01:58:10 <b_jonas> shachaf: there was a time when it was so out of print here too that even the library copies were stolen
01:58:44 <shachaf> b_jonas: "here" being Hungary?
01:58:47 <b_jonas> shachaf: then they started to print all of Lem's work (still in progress, with three volumes published so far), and they reappeared in used book shops
01:58:50 <b_jonas> so I now own a copy
01:58:51 <b_jonas> shachaf: yes
01:59:13 <shachaf> Oh, you're referring to Lem.
01:59:19 <shachaf> That's available in English pretty easily, I think.
01:59:26 <b_jonas> oh
01:59:36 <b_jonas> yes, I'm referring to the Cyberiad in particular
01:59:37 <shachaf> (Also Hebrew, which is the language it was given to me in.)
01:59:38 <dancor> what is the best way to set unix socket permissions with haskell?
01:59:59 <b_jonas> dancor: so, are you on a system that supports file system permissions for them? if you are, than that is.
02:00:20 <dancor> b_jonas: ok
02:00:37 <dancor> it's unusual bc there is getPeerCred in Network.Socket
02:00:39 <b_jonas> dancor: otherwise it might be SCM_CREDENTIALS or a setuid program that gives you a file descriptor
02:00:42 <dancor> but not setPeerCred
02:01:16 <dancor> and also binding will not work if the unix socket already exists
02:01:23 <dancor> so you have to bind and then do a file system operation
02:01:53 <b_jonas> dancor: no, you have to do an umask and then bind
02:01:57 <dancor> ok
02:01:59 <b_jonas> dancor: or set the directory permission and then bind
02:02:09 <dancor> ah
02:02:11 <b_jonas> dancor: if you do it the other way, setting the permission later, then you have an insecure window
02:02:14 <b_jonas> which is no good
02:02:18 <dancor> right
02:02:25 <b_jonas> bind doesn't have a mode parameter so you need umask
02:04:05 <b_jonas> dancor: alternately, on some systems, you can create a socket file with mknod, which does have a mode parameter
02:37:27 * hackagebot FM-SBLEX 3.0 - A set of computational morphology tools for Swedish diachronic lexicons.  http://hackage.haskell.org/package/FM-SBLEX-3.0 (MarkusForsberg)
02:42:03 <Mitar> any hope of fixing this: http://hackage.haskell.org/trac/hackage/ticket/656
02:42:17 <Mitar> this really prevents some documentation from building on hackagedb
02:55:13 <guest2425> Hello
02:55:20 <guest2425> anybody here
02:55:27 <sipa> no
02:55:29 <sipa> sorry
02:55:30 <guest2425> How can I test this http://pastebin.com/cB4KUcHR
02:55:47 <guest2425> sipa: u are funny
02:56:02 <sipa> define 'test' ?
02:56:25 <guest2425> sipa: no to run in the shell
02:56:48 <sipa> save it as something.hs
02:56:50 <guest2425> sipa: like fringe (Leaf 1) = [1]
02:56:54 <sipa> load ghci
02:57:00 <Eduard_Munteanu> guest2425: just give it a tree?
02:57:03 <guest2425> sipa: i did
02:57:11 <guest2425> Eduard_Munteanu: how?
02:57:14 <sipa> ghci something.hs
02:57:16 <sipa> that way
02:57:36 <guest2425> sipa: no I just testing
02:57:44 <Eduard_Munteanu> guest2425: you can use the constructors to build one, like you'd build a list out of (:) and []
02:57:50 <sipa> i don't know what you mean
02:57:50 <guest2425> sipa: 1 clause fringe (Leaf 1) = [1]
02:58:03 <sipa> yes, type that into ghci?
02:58:13 <guest2425> sipa: i did
02:58:28 <sipa> without the '= [1]' part
02:58:39 <guest2425> sipa: but I dont know how to test this part fringe (Branch left right) =  fringe left ++ fringe right
02:58:50 <guest2425> sipa: I know
02:58:56 <Eduard_Munteanu> guest2425: obviously you need to give it a "bigger" tree.
02:59:09 <Eduard_Munteanu> guest2425: how would you use 'Branch'?
02:59:31 <guest2425> Eduard_Munteanu: I  dont know
02:59:55 <Eduard_Munteanu> guest2425: well it's just a constructor, just like Leaf
03:00:04 <sipa> guest2425: can you write an example of a tree with more than just a leaf?
03:00:10 <guest2425> Eduard_Munteanu: I  tried prelude> fringe (Branch 1 4 ) it gives an error message
03:00:12 <Eduard_Munteanu> guest2425: but it has two parameters of type Tree a.
03:00:26 <Eduard_Munteanu> guest2425: of course, that's not valid, look again at your data definition.
03:00:32 <sipa> 1 and 4 are not trees, they are numbers
03:00:33 <guest2425> Eduard_Munteanu: I  tried prelude> fringe (Branch 1) (Branch 4)  it gives an error message
03:00:42 <Eduard_Munteanu> I can infer it's: data Tree a = Leaf a | Branch (Tree a) (Tree a)
03:00:54 <guest2425> sipa: ok then how 
03:01:04 <Eduard_Munteanu> So you can't give it some value '5'
03:01:16 <Eduard_Munteanu> guest2425: do you understand how this tree looks like?
03:01:22 <guest2425> Eduard_Munteanu: yes
03:01:29 <sipa> guest2425: "Leaf 1" is a Tree, right?
03:01:33 <Eduard_Munteanu> guest2425: it's not a regular tree, it only has actual values/data in leaves.
03:01:34 <guest2425> yes
03:01:49 <sipa> guest2425: Branch takes two trees as argument
03:01:55 <guest2425> yes
03:01:58 <guest2425> sipa: yes
03:02:04 <sipa> so you'll need to give it trees
03:02:06 <sipa> not numbers
03:02:27 <sipa> and you already know how to create a tree with a single number in
03:03:28 <guest2425> sipa: I still dont get it
03:03:46 <sipa> guest2425: write a tree with the single number '5' in
03:03:51 <guest2425> sipa: Can you just write how to tested please
03:04:07 <sipa> no, i want to learn you something by letting you come up with it yourself
03:04:09 <Eduard_Munteanu> guest2425: look again at the data definition. You can only give a value of type a to a Tree a if you're using the Leaf constructor.
03:04:17 <guest2425> (Leaf 5)
03:04:21 <guest2425> sipa: (Leaf 5)
03:04:27 <sipa> yes
03:04:39 <sipa> Leaf takes a number, and return a tree with that number in
03:04:45 <guest2425> sipa: yes
03:04:47 <sipa> now to Branch you need to give two such trees
03:05:04 <guest2425> sipa: (Leaf 5) (Leaf 6)
03:05:10 <Eduard_Munteanu> close
03:05:25 <Eduard_Munteanu> I mean yeah, I guess you got it.
03:05:30 <guest2425> still complaints
03:05:37 <Eduard_Munteanu> What exactly did you write?
03:05:55 <guest2425> fringe (Leaf 5) (Leaf 6)
03:05:57 <merijn> What you want is: (Branch (Leaf 5) (Leaf 6))
03:06:03 <guest2425> oh
03:06:04 <guest2425> ok
03:06:21 <Eduard_Munteanu> guest2425: well, does fringe take two parameters? It certainly doesn't look like it.
03:06:30 <guest2425> I got it
03:06:32 <merijn> guest2425: You should look up a bit about induction/recursion
03:07:04 <guest2425> merijin: Thank you I am reading a book and it has that example
03:07:21 <guest2425> merijin: is bearly chapter 2
03:07:39 <merijn> Which book?
03:07:47 <Eduard_Munteanu> LYAH?
03:08:00 <guest2425> A Gentle Introduction to Haskell, Version 98
03:08:08 <merijn> guest2425: oh, bad choice
03:08:11 <guest2425> 2  Values, Types, and Other Goodies
03:08:16 <merijn> That one isn't very gentle at all
03:08:22 <guest2425> why?
03:08:34 <quicksilver> "the vicious stinging introduction to haskell"?
03:08:37 <guest2425> which one is better?
03:08:38 <merijn> Take a look at "Learn You A Haskell" it is much friendlier if you are new to functional programming
03:08:40 <Eduard_Munteanu> In 98 I suppose it was gentle to PhDs :P
03:09:08 <guest2425> merijn: but that one dont have exercises at all
03:09:21 <guest2425> merijn: for me to do
03:09:31 <guest2425> merijn: I need to do some exercises
03:09:55 <merijn> quicksilver: My favorite quote about it remains: "<Brend> Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something."
03:10:29 <Eduard_Munteanu> @where RWH
03:10:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
03:10:53 <merijn> guest2425: Maybe take a look at Real World Haskell? (Can't remember if that has exercises). You could also just read LYAH and then continue with A Gentle Introduction once LYAH explains the basics
03:10:55 <Eduard_Munteanu> That one seems to have exercises, but I heard people saying it's less friendlier.
03:11:11 <guest2425> oh ok
03:11:12 <Eduard_Munteanu> For example see the bottom of this page: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html
03:11:19 <guest2425> yeah thats a good idea too
03:11:35 <merijn> I think Real World Haskell is ok, but not quite as much of a beginner book as LYAH
03:11:43 <guest2425> ok
03:11:51 <guest2425> see you guys and thank you
03:12:20 <pkrumins> real world haskell is for real munctional men
03:12:21 <Eduard_Munteanu> guest2425: out of curiosity, what year are they teaching Haskell to you?
03:12:39 <merijn> guest2425: The main problem with the Gentle Introduction is that it assumes you know quite a bit already and thus concepts like the tree aren't explained. LYAH focuses much more explaining everything from the ground up
03:12:39 <guest2425> what you mean?
03:12:47 <Eduard_Munteanu> First university year?
03:12:52 <guest2425> oh no
03:12:58 <pkrumins> munctional parallel
03:12:58 <guest2425> is only one class
03:13:18 <Eduard_Munteanu> guest2425: yes, but is it during the 1st year or 2nd year or ...?
03:13:22 <guest2425> well you can take after all java classes
03:13:29 <guest2425> are pass 
03:13:55 <guest2425> like you need to do Java 201, 202, 203 before taking that Haskell class
03:14:11 <guest2425> Eduard_Munteanu : like you need to do Java 201, 202, 203 before taking that Haskell class
03:14:23 <merijn> That's odd
03:14:32 <guest2425> why?
03:14:35 <merijn> I'd say learning Java makes learning Haskell harder, not easier
03:14:40 <Rembane> Indeed
03:14:41 <guest2425> well Java and Haskell
03:14:47 <merijn> Since it teaches so many bad habits
03:14:48 <Eduard_Munteanu> Well, some experience with programming does make at least some things easier.
03:14:51 <guest2425> are really water and oil
03:15:18 <guest2425> Java is water for me and Haskell is oil so sticky
03:15:23 <Eduard_Munteanu> For instance, understanding recursion.
03:15:33 <guest2425> yes
03:16:20 <guest2425> Eduard_Munteanu: recursion doesnt exist in Java
03:16:20 <merijn> Eduard_Munteanu: I started using Java and recursion made no sense until I learned lambda calculus
03:16:21 <Eduard_Munteanu> Really?
03:16:26 <guest2425> yes
03:16:53 <merijn> Eduard_Munteanu: Why would you ever use recursion in Java as a beginner? (*Now* I would, but before...no)
03:17:33 <guest2425> Eduard_Munteanu: Java is all about abstraction 
03:17:41 <guest2425> Eduard_Munteanu: Java is all about abstraction and objects 
03:17:45 <Eduard_Munteanu> Recursion is basic stuff. You don't really need to use fixpoint combinators to reason about it, at least not in imperative languages.
03:18:05 <merijn> Eduard_Munteanu: It is basic stuff, but it doesn't have any basic applications for beginners
03:18:18 <Eduard_Munteanu> What's harder is NOT using recursion where recursion is a natural thing.
03:18:21 <guest2425> merijin: I agree 
03:18:34 <Eduard_Munteanu> merijn: traversing trees?
03:18:39 <geheimdienst> merijn, well say you want to traverse directories in java ...
03:18:50 <Eduard_Munteanu> Maybe we have different ideas of "basic stuff".
03:18:54 <Rembane> You can traverse trees without recursion. It's just more code.
03:19:11 <Eduard_Munteanu> Yeah.
03:20:08 <b_jonas> but when you're doing basic programming, you're just using libraries instead of writing trees by hand
03:20:32 <Entroacceptor> that used to be different in my time!
03:20:42 <Entroacceptor> (ha, I so wanted to say that)
03:20:48 <Eduard_Munteanu> b_jonas: many of the people my age started programming in highschool where they used either C or Pascal.
03:21:07 * Entroacceptor learned basic from an ms-dos instruction book
03:21:19 <b_jonas> sure
03:21:28 <guest2425> hello
03:21:30 <b_jonas> and it's still worth to learn C so you know what the computer can actually do
03:21:35 <b_jonas> even if you won't program in C much
03:21:35 <guest2425> sipa:are you there?
03:21:47 <guest2425> merijin: Are you there
03:21:48 <Eduard_Munteanu> Yeah. Although I program in C a lot.
03:21:49 <b_jonas> only the few bits of system interaction or optmizations
03:21:59 <guest2425> The other day, I was watching Who Wants To Be A Millionaire. The $16,000 question was 'What color is Pikachu?' The man used a lifeline
03:22:33 <b_jonas> guest2425: the Who Wants to be a Millionaire of which Country?
03:22:44 <guest2425> Today my best friend discovered she's been spelling my name wrong for 10 years
03:22:46 <guest2425> USA
03:22:56 <b_jonas> thanks
03:22:56 <merijn> My C code got so much better after learning haskell...
03:23:15 <guest2425> merijn: Today my best friend discovered she's been spelling my name wrong for 10 years
03:23:21 <Eduard_Munteanu> merijn: really? I thought that only led to depression and misery :P
03:23:54 <merijn> Eduard_Munteanu: Well, my first assignment after haskell was a compiler class. Functional C increased code readability dramatically :p
03:24:39 <guest2425> A few days ago I found out my grandma was buying me a star. She asked me what I wanted to name it. I now have a star named Heaven and a certifict on my wall that says ' you own HEAVEN ' I feel O so very powerfull
03:24:40 <merijn> guest2425: That's why computer people use tab-completion >.>
03:24:50 <guest2425> oh hahah
03:24:51 <Eduard_Munteanu> merijn: yeah, plus I'd use Haskell as a rapid prototyping tool. "Here's basic and terse Haskell code that does that, now let's write it in C."
03:25:31 <Eduard_Munteanu> Actually I was wondering if there were tools that took a Haskell "specification" and output a C skeleton.
03:25:31 <guest2425> merijn:  A few days ago I found out my grandma was buying me a star. She asked me what I wanted to name it. I now have a star named Heaven and a certifict on my wall that says ' you own HEAVEN ' I feel O so very powerfull
03:29:18 <quicksilver> Eduard_Munteanu: that tool is called a haskell compiler, no?
03:29:49 <merijn> Eduard_Munteanu: Well, that wasn't so much of a problem, we used lex and yacc for parsing and the research group here has a compiler framework they use for two research compilers which we could use. So most of the boring stuff already existed
03:30:30 <Eduard_Munteanu> quicksilver: no, not if you intend to generate readable C code with it. And not really code, but more of a skeleton.
03:30:43 <merijn> All I had to do was write functions which took the top of the AST and returned another AST and specify which function had to be called in which compilation phase
03:31:11 <quicksilver> Eduard_Munteanu: well there's not standard way to generate readab;e code for either laziness or first class functions (in C)
03:31:18 <quicksilver> Eduard_Munteanu: and those are pretty core haskell features.
03:43:04 <leo2007> Is there a definite guide on setting up emacs for haskell? I have already had haskell-mode installed and configured.
04:31:28 * pkrumins meows all over the place
04:34:14 <ksf> someone tell me a good name for     foo ptr f = poke ptr . f =<< peek ptr
04:34:32 <ksf> ha!
04:34:34 <ksf> =!
04:35:02 <Entroacceptor> I don't think "ha" is a good name for that
04:35:39 <ksf> no, but =!
04:35:47 <ksf> actually, $!
04:36:00 <ksf> $=! , probably.
04:36:11 <geheimdienst> if i'm reading you correctly, it's a little like fmap
04:36:18 <ksf> yep.
04:36:23 <ksf> "apply and set"
04:36:37 <geheimdienst> anyhoo, is fmap* a legal name?
04:36:51 <ksf>  Ptr a -> (a -> a) -> IO ()
04:37:17 <geheimdienst> > let fmap* = id in fmap* 42
04:37:18 <lambdabot>   <no location info>: parse error on input `='
04:37:28 <ksf> it's rather like modifyIORef
04:37:31 <geheimdienst> > let fmap' = id in fmap' 42
04:37:32 <lambdabot>   42
04:37:48 <Entroacceptor> <$*>
04:37:59 <ksf> what's the star for?
04:38:08 <ksf> and why the brackets?
04:38:09 <geheimdienst> to make it look pointer-ish
04:38:14 <ksf> that's a point.
04:38:34 <ksf> $* :: apply function to pointer value
04:38:51 <pkrumins> monadic cats go: m eow
04:39:52 <geheimdienst> @remember pkrumins monadic cats go: m eow
04:39:53 <lambdabot> Okay.
04:40:19 <Entroacceptor> and the brackets because of <$>
04:40:50 <hpc> MonadError cat goes m e ow
04:41:15 <geheimdienst> m e ouch
04:43:08 <ksf> hopInfo bounce $* (`clearBit` (ffs hop - 1))
04:43:09 <ksf> hopInfo bounce $* (`setBit` hr)
04:43:13 <ksf> I'd say that's readable.
04:44:35 <ksf> :t poke
04:44:36 <lambdabot> Not in scope: `poke'
04:44:48 <ksf> :t Foreign.Storable.poke
04:44:49 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> a -> IO ()
04:49:12 <faust45> don't understand fun Just
04:51:26 <quicksilver> faust45: Just is the function which takes "5" to "Just 5" and "9" to "Just 9" etc etc etc
04:53:47 <faust45> quicksilver: what is the sense of Just 5?
04:53:57 <hpc> :t Just
04:53:58 <lambdabot> forall a. a -> Maybe a
04:54:01 <hpc> :t Just 5
04:54:01 <lambdabot> forall t. (Num t) => Maybe t
04:54:05 <hpc> :t Nothing
04:54:06 <lambdabot> forall a. Maybe a
04:54:14 <quicksilver> faust45: in "Just 5", Just is one of the constructors of the type Maybe a
04:54:20 <hpc> data Maybe a = Nothing | Just a
04:54:25 <quicksilver> faust45: this is a useful type for storing either a value, or not
04:54:30 <quicksilver> where Nothing is the 'not' case.
04:54:35 <quicksilver> like an 'optional value'
04:57:52 <ksf> I should use *$ and (*=) = poke
04:58:17 <ksf> doesn't make sense for peek as I need <- there, anyway.
04:58:21 <FunctorSalad> @ty poke
04:58:22 <lambdabot> Not in scope: `poke'
04:58:26 <ksf> :t Foreign.Storable.poke
04:58:26 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> a -> IO ()
04:58:27 <quicksilver> ksf: some other combinator libraries use ~ to signify modification by a function.
04:58:38 <quicksilver> ksf: in that spirit you might use *~ instead of *$
04:58:42 <quicksilver> not important though.
04:58:46 <ksf> and $<- ?
04:58:51 <ksf> er *<-
04:59:03 <quicksilver> well you can't do much about <-
04:59:08 <ksf> way to obfuscate do notation.
04:59:10 <quicksilver> ;)
04:59:14 <ksf> nah for poke.
04:59:19 <quicksilver> ah, no
04:59:20 <hpc> OpenGL uses $=
04:59:23 <quicksilver> for poke I would use *=
04:59:39 <FunctorSalad> what would *$ be?
04:59:39 <quicksilver> hpc: for poke, and $~ for modify, I think.
04:59:49 <hpc> or *~
04:59:51 <faust45> quicksilver:  as understand Just is useful only in data type Maybe a?  
04:59:55 <hpc> to keep it consistent
05:00:11 <quicksilver> FunctorSalad: nothing.
05:00:25 <geheimdienst> > let a# = 42 in a#
05:00:26 <lambdabot>   42
05:00:42 <FunctorSalad> you could get rid of the <- by combining the peek with a bind
05:00:44 <quicksilver> FunctorSalad: my thesis is as follows: the initial character defines what kind of object it is. $ for opengl, * for ksf's poke/peek
05:00:47 <ksf> *~ is good.
05:01:02 <FunctorSalad> $* :: (a -> IO b) -> Ptr a -> IO b
05:01:02 <geheimdienst> ^^ what chars are legal in regular names, btw? besides ' and #
05:01:02 <quicksilver> then the second char signifies ~ for 'modify' and = for 'set'
05:01:04 <FunctorSalad> or something
05:01:16 <quicksilver> geheimdienst: # is not legal
05:01:25 <ksf> FunctorSalad, I'm doing that in a lot of places but sometimes you have to bind variables or write pointless code.
05:01:25 <quicksilver> geheimdienst: lambdabot speaks rubbish
05:01:29 <FunctorSalad> quicksilver: oh, I thought it was to simulate C ;)
05:01:34 <geheimdienst> why not? lambdabot accepted it
05:01:35 <quicksilver> geheimdienst: (lambdabt has -XMagicHash enabled)
05:01:41 <sipa> faust45: Just takes something of type a, and returns something of type (Maybe a)
05:01:45 <quicksilver> or whatever the option is called.
05:01:48 <hpc> geheimdienst: filter isAlpha [minBound..maxBound]
05:01:53 <hpc> all those are legal
05:02:12 <quicksilver> faust45: not so much 'only useful in data type Maybe'. It is *part of* data type Maybe.
05:02:19 <quicksilver> hpc, geheimdienst : plus ' and _
05:02:28 <quicksilver> and 0-9 after the first char.
05:02:32 <hpc> indeed
05:02:50 <geheimdienst> okay thanks
05:03:29 <hpc> is _ considered a letter, or is it valid in both?
05:04:12 <geheimdienst> > isAlpha '_'
05:04:13 <lambdabot>   False
05:04:20 <quicksilver> hpc: it's not validin operators
05:04:22 <quicksilver> if that's what you mean
05:04:32 <hpc> yeah
05:04:32 <ksf> _ isn't valid at the start of identifiers, either.
05:04:34 <quicksilver> > let x *_* y = x+y in 5 *_* 2
05:04:35 <lambdabot>   <no location info>: Parse error in pattern
05:04:44 <ksf> foo _x means the same as foo _
05:04:49 <exDM69> https://github.com/rikusalminen/slolog/blob/master/example/peano.slo  here's some logic programming I did a while ago
05:05:11 <ksf> ...or are they valid and ghc just leaves out the warnings for ___magic__stuff?
05:06:23 <faust45> sipa: "Just takes something of type a, and returns something of type (Maybe a)"  Maybe a returns Just, but how i can get  real value from Just a?
05:06:28 <ksf> AARRRGGHH
05:06:39 <ksf> hlint doesn't understand DoIfThenElse
05:07:28 <sipa> faust45: Just a is the type of a value
05:07:30 <theorbtwo> faust45: Pattern matching: f :: Maybe Int -> Int; f Just x = x+1
05:07:50 <sipa> faust45: but i suppose you want to get the value you passed to Just back?
05:07:55 <sipa> use what theorbtwo says :)
05:08:00 <faust45> sipa: yes
05:08:06 <hpc> theorbtwo: except with parens, of course
05:08:18 <theorbtwo> Whoops.
05:10:18 <quicksilver> ksf: good. DoIfThenElse is the worst thing in haskel2010. Don't use it. ;)
05:10:50 <faust45> thanks guy's
05:11:56 <ksf> :i ($)
05:12:03 <ksf> @info ($)
05:12:03 <lambdabot> ($)
05:12:21 <ksf> there. infixr 0
05:13:08 <hpc> > f $ x $ y $ z
05:13:09 <lambdabot>   Couldn't match expected type `a -> b'
05:13:09 <lambdabot>         against inferred type `Simple...
05:13:22 <hpc> > f $ g $ x
05:13:23 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:13:23 <lambdabot>    `GHC.Show.Show b'
05:13:23 <lambdabot>      a...
05:13:26 <hpc> pah
05:13:30 <Saizan> > f $ g $ h $ x :: Expr
05:13:31 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:13:31 <lambdabot>    `SimpleReflect.FromExpr ...
05:13:56 <hpc> it should be f g h x, right?
05:14:06 <Saizan> yep
05:14:20 <Saizan> > f $ g $ (h :: Expr -> Expr) $ x :: Expr
05:14:20 <lambdabot>   Ambiguous type variable `b' in the constraints:
05:14:21 <lambdabot>    `SimpleReflect.FromExpr ...
05:14:22 <hpc> map $ (+1) $ [1..3]
05:14:25 <hpc> > map $ (+1) $ [1..3]
05:14:26 <lambdabot>   Couldn't match expected type `a -> b' against inferred type `[t]'
05:14:39 <hpc> huh
05:14:49 <hpc> it looks like it is actually f . g . h $ x
05:15:10 <Saizan> ah, yeah, sorry, not sure what i was thinking earlier
05:15:36 <hpc> i think it would be cool to be able to say f . g $ x $ y
05:15:45 <hpc> if say, f . g :: a -> b -> c
05:16:08 <geheimdienst> so, when we're talking about DoIfThenElse, we mean this, right? http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
05:16:10 <Saizan> and make that (f . g) x y ? you'd just have to make $ infixl
05:16:40 <Saizan> geheimdienst: yep
05:16:47 <geheimdienst> thanks
05:17:45 <hpc> i could just use those parens...
05:17:48 <hpc> it would be shorter
05:18:05 <hpc> foiled again by pesky logic~
05:18:07 <hpc> !
05:18:14 * hackagebot hsdns 1.5 - Asynchronous DNS Resolver  http://hackage.haskell.org/package/hsdns-1.5 (PeterSimons)
05:19:23 <ksf> I usually don't even use if then else in do blocks but cap c a p = if p then c else a , but I need the binding somewhere else.
05:20:47 <hpc> ksf: i think cap is usually written as (t ?? f) p = if p then t else f
05:21:45 <FunctorSalad> why is it called 'cap'?
05:22:03 <ksf> consequent, alternative, predicate.
05:22:06 <ksf> it's a SICP thing.
05:22:07 <geheimdienst> > let (t ?? f) p = if p then t else f in ((42 ?? 37) True)
05:22:08 <lambdabot>   42
05:22:17 * FunctorSalad sees
05:22:32 * geheimdienst sees and does not like
05:22:34 <ksf> foo >>= (bar ?? baz) doesn't look good.
05:22:44 <ksf> foo >>= cap bar baz does.
05:23:39 <ksf> I fear wadler was wrong, the most discussed thing is the literal syntax of monadic ifs.
05:24:47 * ksf wonders why he didn't make a Storable instace for CStringLen yet.
05:25:48 <ksf> well... in general alignment could be confusing, I think.
05:26:14 <quicksilver> ksf: 'poke' doesn't work well with variable length objects
05:26:25 <ksf> CStringLen isn't variable.
05:26:29 <ksf> it's a pointer and a length.
05:26:39 <quicksilver> oh, you'd store the pointer?
05:26:53 <FunctorSalad> it's a lenghted string?
05:27:10 <quicksilver> that's a bit odd, because Storable is normally used either to communicate with C or serialise
05:27:23 <quicksilver> and the pointer wouldn't be valid after serialisation and it might not be valid from C
05:30:07 <FunctorSalad> do \NUL-terminated strings have any advantage over lenghted ones except saving 3 bytes? o_O
05:30:58 <FunctorSalad> (I guess that may still matter if you have a whole lot of strings)
05:31:10 <BCoppens> FunctorSalad: in general?
05:31:17 * ksf wonders why the length is an Int and not a CUInt
05:31:24 <BCoppens> FunctorSalad: or in Haskell
05:31:31 <quicksilver> FunctorSalad: the sender doesn't have to know how long they are before it starts sending them
05:31:33 <FunctorSalad> BCoppens: in general (maybe off topic :))
05:31:38 <quicksilver> which is handy in streaming contexts.
05:31:45 <mstone> Hi all. Burned my brain over this. Have a two-line program:
05:31:50 <BCoppens> FunctorSalad: in general: you can have multiple strings point to suffixes of a single string
05:31:51 <FunctorSalad> quicksilver: ah, right
05:32:03 <mstone> First line: as_num = foldl1 ((+) . (*10))
05:32:09 <mstone> Second line: main = print $ (\s -> (as_num s, length s, as_num s `mod` 10)) [9,8,7,2,5,4,1,6,3,0]
05:32:14 <BCoppens> also what quicksilver says
05:32:21 <quicksilver> and along the general lines of BCoppens's remark, you can also very cheaply 'chop' up a string by replacing delimeters with 0s
05:32:32 <quicksilver> a cheap, dirty, mutation based technique common in C parsing code :)
05:32:39 <FunctorSalad> ok :)
05:32:45 <mstone> It's output is (9872541630,10,0), as expected
05:33:09 <ksf> I'm doing quite the opposite right now, taking pointers and length out of a long bytestring and saving them as keys.
05:33:14 <mstone> But if you replace 10 with length s in the second line, the output becomes (1282607038,10,8)
05:33:23 <mstone> What do I do wrong?
05:33:37 <quicksilver> > 9872541630 > 2^32
05:33:38 <lambdabot>   True
05:33:43 <quicksilver> mstone: you overflowed your 32bit Int
05:33:59 <quicksilver> mstone: the original code defaults to Integer, which can store large numbers like 9872541630.
05:34:06 <ksf> :t length
05:34:07 <lambdabot> forall a. [a] -> Int
05:34:12 <quicksilver> but when you put 'length s' in there, it forces it to Int
05:34:15 <ksf> ...but some idiots fixed that to Int.
05:34:18 <quicksilver> which on your machine is only 32 bit
05:34:27 <quicksilver> so that changed the type inference.
05:34:37 <FunctorSalad> :t genericLength
05:34:38 <lambdabot> forall b i. (Num i) => [b] -> i
05:34:39 <quicksilver> fromIntegral (length s) or genericLength s would work.
05:34:39 <geheimdienst> @hoogle length
05:34:39 <hpc> > 2^32
05:34:39 <lambdabot> Prelude length :: [a] -> Int
05:34:40 <lambdabot> Data.ByteString length :: ByteString -> Int
05:34:40 <lambdabot> Data.List length :: [a] -> Int
05:34:40 <lambdabot>   4294967296
05:34:42 <mstone> Got it
05:35:02 <mstone> So I should explicitly specify the type to fix it?
05:35:28 <geheimdienst> i guess functorsalad had the right solution ... genericLength
05:35:29 <quicksilver> if you explicitly specify the type you'll get a compile time error
05:35:39 <quicksilver> which is probably better than wrong results :)
05:35:45 <quicksilver> 13:34 < quicksilver> fromIntegral (length s) or genericLength s would work.
05:36:15 <hpc> is there a good way to work around the fact that running a module like Foo.Bar from inside /Foo doesn't work?
05:36:17 <mstone> Thank you-thank you-thank you! You saved me! :)
05:36:43 <hpc> i want to organize some cgi files, and putting them in sub-directories is breaking things
05:37:14 <quicksilver> hpc: yes.
05:37:20 <quicksilver> hpc: but why not compile it?
05:37:21 <geheimdienst> quicksilver: yes, you said it too, however FunctorSalad was a little quicker
05:37:44 <hpc> quicksilver: i want to be able to do both
05:37:46 <FunctorSalad> ;)
05:37:47 <quicksilver> hpc: (ghci has command line flags to specify the search path)
05:38:30 <hpc> quicksilver: cool; that will solve the problem quite nicely
05:39:34 <ksf> :t Foreign.Ptr.plusPtr
05:39:35 <lambdabot> forall a b. GHC.Ptr.Ptr a -> Int -> GHC.Ptr.Ptr b
05:39:48 <ksf> hmmm yes it comes with a free cast.
05:40:05 <ksf> which makes sense but doesn't make sense.
05:42:43 <FunctorSalad> yeah
05:45:16 <ksf> ...hrmpf. no a Storable instace for strict bytestrings isn't the right thing.
05:45:27 <ksf> ...they can be null pointers, so it's a maybe.
05:46:01 <Phyx-> hm?
05:46:20 <FunctorSalad> bytestrings can be null pointers?
05:46:36 <ksf> look under their hood and you'll understand.
05:46:43 <ksf> they're pointer length pairs.
05:47:01 <ksf> ...and my code nulls the pointer to indicate an empty bucket.
05:47:08 <quicksilver> bukkit!
05:47:19 <ksf> as distinct from a non-null pointer but zero length.
05:47:33 <quicksilver> ksf: http://miscellany.lolthulhu.com/2008/03/07/teh-bukkit-of-cthulhu/
05:47:44 <FunctorSalad> ksf: I know they are, but thought they never were null pointers unless you use the naked ctor
05:47:59 <ksf> well, I'm using unsafe functions.
05:49:02 <ksf> as I'm working with an unpacked array of (Word32 (bitmask), ByteString (key), Word32 (hash), Word32 (value))
05:49:31 <ksf> nulling the key is the only safe place to indicate an empty bucket without introducing another field.
05:49:50 <ksf> ...and that's already quite a lot for a single hash entry.
05:54:28 * hackagebot hsemail 1.7 - Internet Message Parsers  http://hackage.haskell.org/package/hsemail-1.7 (PeterSimons)
05:55:38 <hpc> quicksilver: something very odd is breaking things
05:55:54 <hpc> i can do runhaskell -i/var/www Index.hs from the command line
05:56:00 <hpc> but in the lighty config it breaks
05:56:11 <hpc> saying there is no such path
05:57:16 * quicksilver thinks CGI + interpreter is just about the worst of all worlds
05:57:33 <quicksilver> but I can't tell you what's wrong with your lighty config ;)
05:57:45 <quicksilver> somethign to do with missing env vars possibly.
05:58:22 <merijn> quicksilver: What's wrong with CGI?
05:58:29 <hpc> oh i think i might know
05:58:50 <hpc> it is trying to interpret "runhaskell -i" as a directory
05:59:00 <hpc> and continue into var/www
06:00:33 <quicksilver> merijn: the overhead of launching a new process on each request
06:00:57 <quicksilver> merijn: esepcially if it's an interpreter which generally has time consuming startup + parsing + interpreting tasks to do
06:02:19 <lars9> ghc7's release note saies its performance under a large number of threads is improved a lot. does forkIO count?
06:02:37 <hpc> forkIO threads are what it refers to, i think
06:02:53 * quicksilver agrees with hpc
06:03:06 <quicksilver> forkIO threads are the 'normal' threads 
06:03:10 <tsbo> Why would my simple FFI programme crash when I extract the foreign imports into a new module?
06:03:18 <merijn> quicksilver: Oh yeah, I forgot about the process startup
06:04:11 <tsbo> (And is it really a simple FFI programme if I'm linking against libstd++?)
06:05:44 <lars9> Text.Pretty can not support multi-line Doc very well. i want to use it to combine some 4x4 Doc blocks but ($$)'s output is awkward
06:05:53 <ksf> I think I asked this before, but what's the english term for the german idiom "egg-laying woolmilkpig"?
06:06:12 <ksf> (no I won't call that function "emacs")
06:06:37 <ksf> (though it's one of the prime examples, doing everything but being useable for nothing)
06:07:38 <hpc> it looks a lot like it might be a bug in ghc, actually
06:07:46 <ben> ksf: hahaha
06:07:53 <hpc> (the cgi thing)
06:08:14 <hpc> if it runs a module, Foo.Bar.Baz
06:08:27 <hpc> it should cd into the directory, then up two levels
06:08:42 <hpc> so it is at the "program root", so to speak
06:09:40 <quicksilver> no it shouldn't.
06:09:46 <quicksilver> ghc shouldn't do any cd'ing at all.
06:09:58 <quicksilver> all it should do it know which paths to look for modules in.
06:10:07 <ksf> keep your pwd at the root.
06:10:15 <ksf> er cwd.
06:10:16 <ksf> whatever.
06:10:43 <ksf> it'd be lost as soon as you have another include directory, anyway.
06:11:45 <ksf> _cabal-install_, though, could arguably traverse down until it finds a cabal file.
06:11:55 <thoughtpolice> hm, i think my evil plan might work
06:11:57 <ksf> so you can cabal build out of the source dir.
06:13:39 <lars9> ksf: gingerbread?
06:13:54 <ksf> now you've lost me.
06:14:45 <lars9> ksf: i can think of many non-english words for that though, but this is the only english one i know :D
06:15:36 <ksf> ...I'm searching for the name for foo :: HashTable a -> (Maybe a -> Maybe a) -> IO (Maybe a), which can lookup, insert, modify, delete as well as set a new value and return you the old one..
06:16:06 <quicksilver> ksf: "alter"?
06:16:09 <ksf> (the returned Maybe is the same as the one passed into the function, I think that makes more sense than returning the one just set)
06:16:16 <quicksilver> I think that's what's data.map calls it
06:16:19 <ksf> well but it doesn't necessarily alter.
06:16:28 <quicksilver> sure, but it can.
06:16:52 <quicksilver> alter :: Ord k => (Maybe a -> Maybe a) -> k -> Map k a -> Map k a
06:17:01 <quicksilver> not quite the same but similar.
06:17:33 <ksf> you can't get an old value out of that one while setting a new.
06:18:04 <quicksilver> true.
06:19:08 <ksf> ...and I don't even need to care about wasting time when id is passed as function as everything's in cache already, anyway.
06:19:54 <ksf> though strictly speaking it'd make sense to use foo :: HashTable a -> Maybe (Maybe a -> Maybe a) -> IO (Maybe a)
06:21:09 <ksf> so, here's a function that offers everything you could ever want but is a bit unwieldly, what's a good name?
06:22:05 <mux> bazinga
06:22:08 <geheimdienst> everythingAndTheKitchenSink
06:22:13 <geheimdienst> everythingAndTheDog
06:22:16 <Jafet> boilerPlate
06:22:18 <ksf> linguee actually has emacs as one of the translations of eierlegende wollmilchsau
06:22:25 <quicksilver> saveAndAlter
06:22:27 <mux> dwim
06:22:42 <merijn> mux: bazinga is only good if the function is a joke :p
06:22:46 <geheimdienst> f
06:23:05 <geheimdienst> jackOfAllTrades
06:23:10 <ksf> frobnicate.
06:23:18 <merijn> xyzzy?
06:23:21 <Eduard_Munteanu> or recursionEngine like some stuff I've seen these days here
06:23:44 <geheimdienst> systematicProcessingEngine
06:23:58 <geheimdienst> doThings
06:24:09 <merijn> I prefer doStuff
06:24:35 <geheimdienst> stuffSomeStuffIntoStuff
06:24:52 <geheimdienst> allInOne
06:26:00 <merijn> theOneFunction
06:26:12 <geheimdienst> srsly though, i'd go with kitchenSink
06:26:18 <ksf> theRing?
06:26:41 <Eduard_Munteanu> No, theOneFunction for me would be theOneFunction :: a -> b
06:26:46 <fryguybob> Make several names and use the one that fits the context?
06:27:01 <ksf> well that's after I wrote that one.
06:27:30 <ksf> it's always the same logic, just with other tweaks made.
06:51:23 <acemo> http://hpaste.org/41608/random_number_generator What is wrong with this code? its giving me Program error: arithmetic overflow
06:58:19 <choffstein> 1
06:59:18 <choffstein> Hey all.  Anyone use the package install on Mac OS X that wouldn't mind helping me out for a quick second?  Everything installed as a Framework (as I would expect it to), but I don't know whether I should be adding symlinks in /usr/local/bin or adding the Framework bin directory to my local path.  Any thoughts?
07:05:25 <ksf> :t Just . maybe 1 (+1)
07:05:26 <lambdabot> forall a. (Num a) => Maybe a -> Maybe a
07:11:07 <ksf> @pl (\f -> maybe (return Nothing) (\v -> blindInsert ht hashBucket top k h v >> return Nothing) (f Nothing)
07:11:07 <lambdabot> (line 1, column 104):
07:11:07 <lambdabot> unexpected end of input
07:11:07 <lambdabot> expecting variable, "(", operator or ")"
07:11:21 <ksf> @pl (\f -> maybe (return Nothing) (\v -> blindInsert ht hashBucket top k h v >> return Nothing) (f Nothing))
07:11:21 <lambdabot> maybe (return Nothing) ((>> return Nothing) . blindInsert ht hashBucket top k h) . ($ Nothing)
07:13:15 * Eduard_Munteanu repeatedly turns the lights on and off in #haskell...
07:14:16 * ksf wants MaybeT
07:14:18 <ksf> ...in base.
07:14:25 * quicksilver agrees.
07:14:38 <quicksilver> although sometimes the unwrapping would be a pain
07:14:42 <ksf> those calls to maybe are obfuscating everything.
07:14:47 <Eduard_Munteanu> Do we even have transformers in base? oO
07:14:58 <ksf> well then put it into mtl
07:15:04 <quicksilver> sometimes you want to use the >> from m in m (Maybe a) and sometimes y ou want to use the >> from MaybeT m
07:15:39 * ksf keeps the top-level, monadically fed maybe and leves the rest as cases.
07:18:01 <ksf> well, you tell me how to write this: http://hpaste.org/41609/fix_this
07:18:29 <adnam> hey, I'm trying to fix the torrent package, and i need a sha1 :: ByteString -> ByteString (i assume the return value should be the a stringified hex), how should i go about doing this? So far I have String -> Word160 using Data.Digest.SHA1.hash . map (fromIntegral . ord)
07:18:59 <ksf> last time I tried combinatorrent worked fine.
07:19:18 <ksf> If you're trying any other torrent package, just don't.
07:19:39 <acemo> Whats wrong in here? http://hpaste.org/41608/random_number_generator It gives me Program error: arithmetic overflow
07:20:30 <Twey> It feels like we should have some sugar like do-notation to flatten with* functions
07:20:48 <quicksilver> sometimes it does, Twey 
07:20:56 <quicksilver> but then again I hardly think they need it
07:20:58 <adnam> ksf: oh, did not know it existed :-) i have been using "torrent" previously, i only want to parse torrent files
07:21:05 <quicksilver> they're perfectly readable when you get used to them
07:21:08 <Twey> I guess
07:21:13 <ksf> oh combinatorrent definitely can do that.
07:21:15 <Twey> So's de-sugared do-notation, though :
07:21:27 <ksf> and parsing bencoding doesn't require SHA, so you could just rip out the code.
07:21:51 <adnam> ksf: sweetums, thank you
07:21:53 <quicksilver> Twey: in my experience you normally only see 2-4 withs and they're all clustered at the beginning
07:22:03 <Twey> True, true
07:22:12 <quicksilver> Twey: whereas "<-" can be scattered all along through a 40 line algorithm
07:22:15 <quicksilver> but I agree it's marginal.
07:22:20 <quicksilver> do notation is very marginal.
07:22:23 <gwern> dang it haskell.org, stop being slow
07:22:42 <ksf> bencoding, in fact, is a very sweet encoding. binary enough to be easily parsed and human-decipherable enough to be editable in a text editor if you really have to.
07:22:57 <quicksilver> Twey: I suppose the thing I like more about do notation is more >> vanishing entirely, than >>= \ turning into <-
07:23:20 <Eduard_Munteanu> gwern: that's really bad advocacy :)
07:23:42 <ksf> stop arguing, figure out ways how to make my code more readable + not so casey
07:23:51 <Twey> quicksilver: Yeah, same, I think
07:24:18 <gwern> Eduard_Munteanu: I call it 'trolling development'; it's like agile development except you get things done by splitting the work among various communities, prefixing the spec with trolling statements
07:24:25 <gwern> Eduard_Munteanu: I'll make millions!
07:24:46 <ksf> hmmm probably just maybe' m n j = maybe n j m
07:26:47 <acemo> how do i generate a random integer value?
07:29:01 <gwern> acemo: you looked at the Random module already?
07:29:55 <Alan> Is there a way to "hide" something from the prelude?  I have a data constructor that conflicts with something in the prelude, but i'd really like to keep it's name
07:30:22 <gwern> Alan: sure, something like import Prelude hiding (Foo(Bar))
07:30:30 <gwern> or Foo(..), I suppose
07:31:49 <Alan> gwern: oh, ok, didn't realise you could import Prelude...
07:33:47 <Alan> gwern: thanks :)
07:35:04 <acemo> gwern: I did, but anything I find just dies on me
07:35:12 <gwern> dies?
07:35:22 <acemo> http://hpaste.org/41608/random_number_generator gives me Program error: arithmetic overflow
07:35:29 <gwern> how can it die, for we who live in the immortal realms of algorithms?
07:37:12 <gwern> works here: [-524994214,-1510111358,1722331302,668592186,2004281950,310231926,1378256271,-574819374,1768537881,1148306253]
07:37:28 <damex> for example i will need to compile it here on gentoo like QEMU_SOFTMMU_TARGETS="i386 x86_64 ppc" QEMU_USER_TARGETS="i386 x86_64 ppc" emerge qemu-kvm ?
07:37:36 <acemo> gwern: wtb?
07:37:37 <damex> or it will not work?
07:37:57 <gwern> acemo: that's what ghci gave me for 'main'
07:38:15 <acemo> gwern: I open the file in hugs and then I type main <enter> should be correct right?
07:38:19 <damex> oh missed channel
07:38:29 <gwern> acemo: dunno. never used hugs
07:38:38 <gwern> acemo: few people do these days
07:38:51 <ksf> @pl case mf of Nothing -> return Nothing; Just f -> case f Nothing of Nothing -> return Nothing; Just v -> foo v >> return Nothing
07:38:51 <lambdabot> (line 1, column 20):
07:38:51 <lambdabot> unexpected ">" or "-"
07:38:51 <lambdabot> expecting variable, "(", operator or end of input
07:39:10 <acemo> gwern: its what we learn to use at my school, what would you suggest me to use instead?
07:39:14 <gwern> ghc
07:39:20 <roconnor> @type isJust
07:39:21 <lambdabot> forall a. Maybe a -> Bool
07:39:25 <ksf> @pl case mf of {Nothing -> return Nothing; Just f -> case f Nothing of {Nothing -> return Nothing; Just v -> foo v >> return Nothing}}
07:39:25 <lambdabot> (line 1, column 12):
07:39:25 <lambdabot> unexpected "{"
07:39:25 <lambdabot> expecting variable, "(", operator or end of input
07:39:30 <ksf> grrrr
07:39:44 <roconnor> @type Cont . All . isJust
07:39:45 <lambdabot>     Couldn't match expected type `(a -> r) -> r'
07:39:45 <lambdabot>            against inferred type `All'
07:39:45 <lambdabot>     In the first argument of `(.)', namely `All'
07:40:06 <roconnor> @type Const . All . isJust
07:40:07 <lambdabot> forall b a. Maybe a -> Const All b
07:40:28 * roconnor claims that is an idomatic transformation.
07:41:03 <roconnor> > mempty :: All 
07:41:04 <lambdabot>   All {getAll = True}
07:41:41 <ksf> @pl join (($ Nothing) <$> mf)
07:41:41 <lambdabot> join (($ Nothing) <$> mf)
07:41:41 <quicksilver> roconnor: well, it's parametric polymorphic so it's certainly natural :)
07:41:54 * ksf fears he's approaching pointless heights.
07:42:49 <roconnor> quicksilver: natural WRT the Wadler functor, which could be different from the actuall functor instance, but usually isn't.
07:43:51 <roconnor> > pure 5 ::  Const All
07:43:52 <lambdabot>   `Control.Applicative.Const Data.Monoid.All' is not applied to enough type a...
07:43:57 <roconnor> > pure 5 ::  Const All Int
07:43:58 <lambdabot>   No instance for (GHC.Show.Show
07:43:58 <lambdabot>                     (Control.Applicative.Con...
07:44:09 <roconnor> > pure 5 ::  Constant All Int
07:44:09 <lambdabot>   Not in scope: type constructor or class `Constant'
07:44:17 <roconnor> > pure 5 ::  Data.Functor.Constant All Int
07:44:18 <lambdabot>   Not in scope: type constructor or class `Data.Functor.Constant'
07:44:20 <roconnor> aww
07:44:38 <roconnor> > pure 5 ::  Data.Functor.Constant.Constant All Int
07:44:39 <lambdabot>   Not in scope:
07:44:39 <lambdabot>    type constructor or class `Data.Functor.Constant.Constant'
07:44:42 <roconnor> aww
07:45:52 <roconnor> quicksilver: I believe my claim is correct
07:46:31 <roconnor> notice however, that Const . Any . isJust or Const . All . isNothing are not idomatic transformations
07:46:33 <acemo> gwern: yep works in ghci.. must be a hugs bug then
07:46:54 <roconnor> though Const . Any . isNothing is probably a idomatic transformation again.
07:46:57 <Eduard_Munteanu> acemo: does it work with mkStdGen ?
07:48:09 <acemo> Eduard_Munteanu: what do you mean?
07:48:35 <Eduard_Munteanu> acemo: I was going to suggest trying in hugs with mkStdGen instead of newStdGen
07:48:43 <Eduard_Munteanu> You'd need to provide a seed though.
07:48:46 <Eduard_Munteanu> :t mkStdGen
07:48:47 <lambdabot> Int -> StdGen
07:49:28 <Eduard_Munteanu> But if you could ditch Hugs, by all means, do so.
07:49:53 <Jafet> Heh
07:50:11 <Jafet> "And your excuse?" "Uh, its StdGen was broken"
07:50:40 <acemo> It seems I can. No idea which is better.. but its just for a school assignment..
07:50:43 <Eduard_Munteanu> Jafet: actually I feel bad it's unmaintained (?), it has some nice stuff.
07:52:07 <bastl> is there something cleverer than 'strip = reverse.tail.reverse.tail'  ?
07:52:46 <copumpkin> there's the funky lazier one I wrote a while back
07:52:47 <Jafet> tails? That's a weird stripper.
07:52:59 <Eduard_Munteanu> bastl: I wouldn't use that.
07:53:48 <copumpkin> :t join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ")
07:53:49 <lambdabot> [Char] -> [Char]
07:53:51 <copumpkin> iirc
07:53:57 <Eduard_Munteanu> bastl: you could use a sequence instead of lists if you really have an access pattern like that.
07:54:47 <Jafet> strip [] = []; strip [x] = []; strip (x:xs) = let s [] = []; s [x] = []; s (x:xs) = x:s xs in s xs
07:54:52 <copumpkin> > join . tail . init . groupBy ((==) `on` isSpace) . (" " ++) . (++ " ") $ "    \t  mooo    baa zomg      \t\t  "
07:54:53 <lambdabot>   "mooo    baa zomg"
07:55:10 <Jafet> No points for copumpkin!
07:55:18 <copumpkin> oh he just wants to remove the first and last?
07:55:25 <copumpkin> > init []
07:55:26 <lambdabot>   *Exception: Prelude.init: empty list
07:55:30 <copumpkin> tail . init
07:55:37 <copumpkin> and pattern match on the empty and one-element case
07:56:13 <copumpkin> > let strip [] = []; strip [x] = [x]; strip xs = tail . init $ xs in strip "hahah"
07:56:14 <lambdabot>   "aha"
07:57:01 <Eduard_Munteanu> It's quite inefficient anyway on lists.
07:57:20 <ksf> http://hpaste.org/paste/41609/hmm#p41610
07:57:26 <ksf> is that parsable?
07:57:30 <bastl> thanks guys.
07:57:50 <Jafet> > tail []
07:57:51 <c_wraith> not by me, ksf. :)
07:57:51 <lambdabot>   *Exception: Prelude.tail: empty list
07:58:16 <copumpkin> Eduard_Munteanu: not that bad
07:58:27 <Eduard_Munteanu> For a "withForeignPtr" it's not that bad.
07:58:36 <ksf> oh once you figured out (join (($ foo) <$> bar)) it should be easy.
07:58:38 <Eduard_Munteanu> I've seen worse.
07:58:59 <ksf> :t \foo bar -> (join (($ foo) <$> bar)) it should be easy.
07:59:00 <lambdabot> parse error (possibly incorrect indentation)
07:59:08 <ksf> :t \foo bar -> (join (($ foo) <$> bar)) 
07:59:09 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => a -> m (a -> m a1) -> m a1
07:59:13 <c_wraith> It's actually applying the do block to a lambda expression that made me go "I'm not going to try" :)
07:59:33 <c_wraith> oh, that's not what it's doing.  those are each arguments to maybe
07:59:35 <c_wraith> hah
08:00:12 <Eduard_Munteanu> ksf: are you working on some better Haskell hashtable?
08:00:17 <ksf> yep.
08:00:21 <ksf> hopscotch.
08:00:28 * Eduard_Munteanu salutes ksf's idea
08:00:28 <dixie> hmm, this one must be known issue. I have a debian testing and linker (ld) crashes on out of memory.
08:01:23 <c_wraith> dixie, you can try compiling with no-split-objs
08:01:40 <c_wraith> that *should* make ld less psychotic.  but ld is *really* not well-suited for the code ghc produces
08:02:23 <Eduard_Munteanu> Really? I don't quite remember the last time ld misbehaved for me
08:02:50 <ksf> wait did I just manually implement a monad transformer step there?
08:02:51 <dixie> this is ghc 6.12.1. I'll try no-split-objs
08:02:53 <Eduard_Munteanu> Is there some fancy linker script ghc passes?
08:03:03 <c_wraith> ld often wants a gigabyte of ram to link my code
08:03:24 <Eduard_Munteanu> c_wraith: /me's got six of those, maybe that's the reason :P
08:03:53 <c_wraith> yeah.  attempting to compile on a virtual machine with only 512 mb of memory was a shock
08:04:23 <c_wraith> It's sad that a tool that wouldn't use more than 20 mb of ram required a gig to compile
08:05:43 <ksf> @djinn  (Functor m, Monad m) => a -> m (a -> m a1) -> m a1
08:05:43 <lambdabot> -- f cannot be realized.
08:05:51 <ksf> @djinn  a -> m (a -> m a1) -> m a1
08:05:51 <lambdabot> -- f cannot be realized.
08:06:21 <Eduard_Munteanu> Does it work with type operators?
08:06:23 <ksf> is that a djinn bug or really true?
08:06:37 <jmcarthur> djinn isn't very good with type classes
08:06:44 <Eduard_Munteanu> I don't think it's true.
08:07:12 <jmcarthur> :t \x f -> f <*> pure x
08:07:13 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => a -> f (a -> b) -> f b
08:07:15 <ksf> ...does anyone have a name for that?
08:07:49 <jmcarthur> :t \x f -> ($x) <$> f
08:07:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => a -> f (a -> b) -> f b
08:07:57 <ksf> ...bind and join combined.
08:08:12 <quicksilver> no join required, though, as jmcarthur is showing.
08:08:15 <jmcarthur> it only requires functor :P
08:08:27 <ksf> that's not the same type.
08:08:34 <quicksilver> ah, it's now what ksf asked.
08:08:34 <jmcarthur> oh right
08:08:36 <Eduard_Munteanu> :t liftM
08:08:37 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
08:08:40 <jmcarthur> :t \x f -> join $ ($x) <$> f
08:08:41 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => a1 -> m (a1 -> m a) -> m a
08:09:01 <Eduard_Munteanu> :t flip $ liftM . pure
08:09:02 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => m a1 -> r -> m r
08:09:17 <ksf> that's the shortest form according to @pl
08:09:21 <Eduard_Munteanu> :t liftM . pure
08:09:22 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => r -> m a1 -> m r
08:09:40 <jmcarthur> @pl \x f -> join $ ($x) <$> f
08:09:40 <lambdabot> (join .) . (<$>) . flip id
08:09:59 <Eduard_Munteanu> Nah, that makes me cringe.
08:10:03 <ksf> well, shortest with x and f free.
08:10:41 <jmcarthur> personally i think i would prefer the flipped version of this function
08:10:54 <jmcarthur> m (a -> m b) -> (a -> m b)
08:11:09 <shachaf> @pl \x f -> join (fmap ($x) f)
08:11:09 <lambdabot> (=<<) . flip id
08:11:12 <jmcarthur> that's looking vaguely similar to something else
08:11:40 <jmcarthur> shachaf: ha, @pl knows fmap better than (<$>) i take it
08:11:49 <ksf> :t \foo bar -> join $ ($ foo) `liftM` bar
08:11:50 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => a1 -> m (a1 -> m a) -> m a
08:12:03 <jmcarthur> @pl \x f -> join $ ($x) `fmap` f
08:12:03 <lambdabot> (=<<) . flip id
08:12:07 <jmcarthur> @pl \f x -> join $ ($x) `fmap` f
08:12:07 <lambdabot> (join .) . flip (fmap . flip id)
08:12:10 <jmcarthur> ew
08:12:55 <jmcarthur> @pl \f x -> join $ f `ap` return x
08:12:55 <lambdabot> (join .) . (. return) . ap
08:13:15 <ksf> ...I need f to be free in any case, because I need it twice.
08:13:24 <jmcarthur> that doesn't mean it needs to be free :P
08:13:32 <ksf> and I will _not_ pointless the whole shebang.
08:13:35 <jmcarthur> aw
08:13:44 <jmcarthur> then you're giving up
08:14:05 <ksf> I'd rather write a haskell obfuscator.
08:14:13 <jmcarthur> :t (join .) . (. return)
08:14:14 <lambdabot> forall (m :: * -> *) a a1 (m1 :: * -> *). (Monad m, Monad m1) => (m1 a1 -> m (m a)) -> a1 -> m a
08:14:17 <shachaf> @pl the whole shebang -- See? Doesn't reduce clarity.
08:14:18 <lambdabot> the whole shebang
08:14:28 <jmcarthur> shachaf: sure it does :P
08:14:49 <jmcarthur> it got rid of that silly comment!
08:14:59 <shachaf> @pl jmcarthur
08:14:59 <lambdabot> jmcarthur
08:15:20 <roconnor> how do I write @a `foo` b@ in haddock such that foo becomes hyperlined to it's definiton?
08:15:58 <jmcarthur> roconnor: is it even possible without the infix? i'd never seen that
08:16:22 <zygoloid> @pl id not say it doesn't reduce clarity
08:16:23 <lambdabot> not say it doesn't reduce clarity
08:16:26 <roconnor> jmcarthur: sure
08:16:34 <roconnor> just put the identifier in single quotes
08:17:01 <jmcarthur> i thought @@ was supposed to make that not happen. oh well
08:17:32 <roconnor> nope
08:17:36 <roconnor> @@ is just monospaced fot
08:17:37 <lambdabot>  is just monospaced fot
08:17:43 <roconnor> lambdabot: thanks
08:17:44 <Eduard_Munteanu> @pl > "hi"
08:17:44 <lambdabot> (line 1, column 1):
08:17:44 <lambdabot> unexpected ">"
08:17:44 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:17:48 <ksf> monadic view patterns?
08:17:51 <dixie> c_wraith: hmm, I'm not able to find out how to pass the -no-split-objs. It seems the GHC 6.12.1 accepts the -split-objs option only.
08:17:53 <Eduard_Munteanu> @pl :t "hi"
08:17:54 <lambdabot> (line 1, column 1):
08:17:54 <lambdabot> unexpected ":"
08:17:54 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:17:59 <Eduard_Munteanu> Oh, damn.
08:18:21 <Eduard_Munteanu> @pl id @type foo
08:18:21 <lambdabot> id @ type foo
08:18:24 <c_wraith> dixie, does it give an error message with -no-split-objs ?
08:18:30 <Eduard_Munteanu> @pl @type foo
08:18:30 <lambdabot> (line 1, column 1):
08:18:30 <lambdabot> unexpected "@"
08:18:30 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:18:42 <jmcarthur> Eduard_Munteanu: what should that even do?
08:18:47 <zygoloid> @@ @pl @djinn @type either
08:18:48 <lambdabot>  (line 1, column 36):
08:18:48 <lambdabot> unexpected ">" or "-"
08:18:48 <lambdabot> expecting variable, "(", operator or end of input
08:18:51 <Eduard_Munteanu> jmcarthur: I'm trying to make it answer to itself.
08:18:59 <jmcarthur> it won't do that
08:19:00 <dixie> c_wraith: ghc: unrecognised flags: -no-split-objs
08:19:03 <Eduard_Munteanu> :(
08:19:12 <jmcarthur> Eduard_Munteanu: you can compose commands with @@ or @. though
08:19:22 <jmcarthur> Eduard_Munteanu: but @@ pl type doesn't even make sense
08:19:39 <Eduard_Munteanu> Ah. I was just hoping @pl would somehow put it into an infinite loop :P
08:19:47 <dixie> c_wraith: http://hpaste.org/41611/abc
08:19:58 <roconnor> jmcarthur: @a ``foo`` b@ works!
08:20:03 <jmcarthur> wtf
08:20:11 <Eduard_Munteanu> Would be doable with two bots perhaps.
08:20:12 <jmcarthur> :)
08:20:18 <roconnor> identifies can also be enclosed in ``
08:20:19 <roconnor> or `'
08:20:26 <roconnor> and probably '` as well :^)
08:21:00 <roconnor> @hoogle isNothing
08:21:00 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
08:38:44 <Eduard_Munteanu> Hm, how would you name it when a distance gives rise to a total order? I'm comparing sort in Haskell (which takes Ord instances) with C99's qsort.
08:39:11 <quicksilver> I'm not sure what you mean.
08:39:27 <quicksilver> a distance is a metric, but most metrics don't lead straightforwardly to orders
08:39:40 <Eduard_Munteanu> The latter uses (a fake) HOF that returns an integer distance which is used in sorting.
08:39:41 <quicksilver> one-dimensional metric spaces can be totally ordered by the metric
08:40:03 <quicksilver> is it realy a distance?
08:40:07 <Eduard_Munteanu> quicksilver: oh, so it's 1-dimensional strictly.
08:40:10 <quicksilver> or just a convention
08:40:14 <quicksilver> integer < 0 means 'LT'
08:40:18 <quicksilver> 0 means 'EQ'
08:40:21 <quicksilver> > 0 means 'GT"
08:40:22 <lambdabot>   <no location info>:
08:40:22 <lambdabot>      lexical error in string/character literal at chara...
08:40:51 <Eduard_Munteanu> quicksilver: in C you use it like qsort(arr, ..., fcn), where fcn takes two arguments and usually (e.g. when sorting an array of numbers) returns their difference.
08:41:12 <quicksilver> sure.
08:41:19 <quicksilver> it doesn't really have to be a distance
08:41:28 <quicksilver> it just has to have the property I described above
08:41:39 <quicksilver> there is no "difference" between it returning -2 or -1
08:41:51 <quicksilver> it's just a way to map {LT,EQ,GT} onto a natural C type
08:42:03 <Eduard_Munteanu> Hm, I would've expected some optimizations to take place depending on the actual value.
08:42:09 <quicksilver> since the people who designed the C standard were allergic to enums.
08:42:15 <quicksilver> Eduard_Munteanu: I very much doubt it.
08:42:23 <quicksilver> I'd be quite interested to be proven wrong ;)
08:42:31 <quicksilver> but such 'heuristic' searches are quite rare and fiddly.
08:42:33 <Eduard_Munteanu> Yeah, I'm not sure about it.
08:42:37 <quicksilver> s/searches/sorts/
08:43:11 <nostard> quicksilver: enums are one of the best things in C :P
08:43:40 <Eduard_Munteanu> Yeah, they're fine.
08:43:58 <quicksilver> nostard: they're fine, but you'll notice they're hardly used in the standard lib.
08:44:02 <nostard> quicksilver: i hate it when people use numbers instead of enums, yeah -1 is left, 0 is up and so on...
08:44:08 <nostard> quicksilver: yeah
08:46:48 <Twey> 16:43:37 < nostard> quicksilver: i hate it when people use numbers instead of enums, yeah -1 is left, 0 is up and so on...
08:46:50 * Eduard_Munteanu would like to see bead sort implemented feasibly :)
08:46:52 <Twey> Vectors are the way to go
08:47:51 <Eduard_Munteanu> (though that makes more sense in case of Haskell on an abacus)
08:48:33 <quicksilver> Twey: pun intended?
08:48:41 <nostard> Twey: directions was just an example, but you are probably right in that case, it can be nice to do some numerical stuff with the directions so
08:49:17 <Twey> quicksilver: ;)
08:52:25 <peterNovice> What can I do so that I do not get "cannot match type a1 against a, a1 bound in 'doit' and a bound in 'f' ", where f:: Monad m => b -> m a;     f x = do; res <- doit x; return res; where doit::Monad m=> a -> m b; doit x = "something". It only works if I do not explicitly state the type of "doit" in the where clause of f. 
08:53:03 <Twey> f doesn't look like a terribly useful function
08:53:59 <Twey> doit :: a -> String
08:54:14 <Twey> = a -> [Char]
08:54:31 <quicksilver> peterNovice: because the type you are giving doit is wrong
08:54:35 <roconnor> by the monad laws, f = doit
08:54:38 <quicksilver> it is consistent, but too general.
08:54:49 <peterNovice> twey. the real function is at http://hpaste.org/41612/explicit_type_in_where
08:57:02 <roconnor> how does haddock know if I want a hyperlink to a type constructor or a type?
08:59:18 <peterNovice> quicksilver: too general? So there is no way to bind the types?
08:59:58 <quicksilver> peterNovice: well, in the example you pasted here, doit has type a -> String, not Monad m => a -> m b
09:00:05 <quicksilver> that is consistent but too general
09:00:08 <quicksilver> (since [] is a monad)
09:00:17 <quicksilver> however I since learn that wasn't your real example ;)
09:00:49 <quicksilver> can you paste the exact error from the real example?
09:01:08 <peterNovice> Couldn't match expected type `a1' against inferred type `a'
09:01:09 <peterNovice>       `a1' is a rigid type variable bound by
09:01:09 <peterNovice>            the type signature for `expl' at EMM3-4.hs:34:16
09:01:09 <peterNovice>       `a' is a rigid type variable bound by
09:01:09 <peterNovice>           the type signature for `metropolis' at EMM3-4.hs:24:22
09:01:52 <quicksilver> peterNovice: OK. if you uncomment the signature for exp1
09:02:04 <quicksilver> peterNovice: then you have a signature which says exp1 works FOR ANY type 'a'
09:02:20 <quicksilver> peterNovice: in fact, it only works for the same 'a' - the 'a' mentioned in the type signature for metropolis.
09:02:25 <quicksilver> you wanted them to be the same 'a'.
09:02:25 <dankna> the ScopedTypeVariables extension would make it the same a
09:02:33 <quicksilver> haskell98 type signatures do not behave this way
09:02:41 <quicksilver> however... dankna has stolen the punchline.
09:02:44 <dankna> haha
09:02:46 <dankna> sorry
09:03:05 <quicksilver> {-# LANGUAGE ScopedTypeVariables #-}
09:03:14 <quicksilver> and add a forall a . 
09:03:23 <quicksilver> just before the U.Unbox in the type sig for metropolis
09:03:36 <peterNovice> ok thanks a lot
09:05:53 <faust45> any one know where folks looking for haskell related jobs?
09:06:28 <roconnor> faust45: haskellers.com
09:07:21 <dixie> is this up-to-date repo for lambdabot? http://code.haskell.org/lambdabot
09:07:33 <Saizan> dixie: yes
09:07:39 * hackagebot happstack-state 0.5.0.4 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-0.5.0.4 (JeremyShaw)
09:07:41 * hackagebot happstack-server 0.5.0.4 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-0.5.0.4 (JeremyShaw)
09:07:42 <dixie> thanks
09:07:50 <Saizan> which doesn't mean it'll work smoothly :)
09:08:06 <dixie> :)
09:08:09 <Eduard_Munteanu> LOL, SPJ has a profile there, but I guess he isn't looking for a job... "About Me"
09:08:12 <Eduard_Munteanu> "I helped design Haskell, and build GHC."
09:08:31 <Twey> Heh, yes
09:09:07 <dankna> I like the symmetric crystal-esque doodles that it uses for users who haven't set a custom photo of themselves.
09:09:12 <dankna> I wonder how those are generated.
09:09:55 <Eduard_Munteanu> dankna: gravatar
09:10:01 <Eduard_Munteanu> Or something similar.
09:10:09 <Twey> It's based on a hash of the name, isn't it?
09:10:13 <dankna> oh, didn't realize it did that
09:10:22 <dankna> yeah, I figured it was based on the name in some fashion
09:10:38 <Eduard_Munteanu> I think it takes the email address into account as well.
09:11:26 <Eduard_Munteanu> I've seen a similar thingy on Gmane, attributing logos (e.g. employers) to names based on the domain
09:11:33 * dankna nods
09:19:16 <JimmyRcom> can't install alsa in cabal, c2hs fails because "c2hs-0.16.2 depends on language-c-0.3.2 which failed to install." -are there any good examples of projects that play midi sounds in haskell? 
09:19:38 <dankna> can't think of any
09:22:20 <ksf> C code on the shootout may use glib, doesn't it?
09:22:35 <ksf> I think I could ffi to http://library.gnome.org/devel/glib/2.16/glib-Atomic-Operations.html , then.
09:23:39 <Eduard_Munteanu> JimmyRcom: even with that, you'd need Timidity or something to actually synth them I think.
09:24:06 <ksf> yep regex-dna uses it.
09:25:09 <ksf> btw, ghc should ship those as primitives.
09:25:12 <JimmyRcom> Thanks Eduard_Munteanu, just wanting to get started
09:25:57 <ksf> that's at least one cache line the rest of the program can't use because a single instruction is in some C library.
09:29:49 <Eduard_Munteanu> ksf: are you working up that hashtable for the debian shootout?
09:30:06 <ksf> yep.
09:30:17 <ksf> half procrastinating right now.
09:30:27 <Eduard_Munteanu> ksf: and you need atomic ops? There are better ways of getting them
09:31:53 <Eduard_Munteanu> ksf: if you're concerned only about x86(-64), you might have a look at the Linux kernel stuff.
09:32:42 <ksf> ...and calling into the kernel would be faster than calling glib?
09:32:44 <quicksilver> ksf: the FFI overhead is quite substantial
09:33:03 <quicksilver> ksf: I'd be surprised if FFI's to glib's atomics was better than using some native haskell facility or other
09:33:04 <Eduard_Munteanu> ksf: no, I mean doing what it does...
09:33:07 <Eduard_Munteanu> http://lxr.linux.no/#linux+v2.6.36/arch/x86/include/asm/atomic.h#L93
09:33:14 <ndm> hi
09:33:15 <lambdabot> ndm: You have 4 new messages. '/msg lambdabot @messages' to read them.
09:33:15 <ksf> atomicModifyMutVar#
09:33:15 <ksf>   :: MutVar# d a -> (a -> b) -> State# d -> (# State# d, c #)
09:33:22 <quicksilver> omg it's an ndm ;)
09:33:25 <quicksilver> long time no ndm!
09:33:30 <ndm> I'm trying to understand the output of GHC +RTS -S
09:33:34 <ndm> quicksilver: i know, it's been forever!
09:33:35 <Eduard_Munteanu> It seems you only need a lock prefix.
09:33:49 <Eduard_Munteanu> At least for updating an int-sized one.
09:34:26 <Eduard_Munteanu> That if you're willing to code that asm-snippet somewhere and make it x86-specific, dunno if that makes sense or not for the shootout.
09:34:35 <ksf> those rely on gcc
09:34:50 <ksf> ...which also means calling out to C.
09:35:20 <Eduard_Munteanu> ksf: yeah, but it's slimmer than calling to glib, as far as dependencies go
09:35:21 <ksf> ghc _does_ use cas for atomicModifyIORef
09:35:39 <ksf> well the cache hit is likely to be the same.
09:35:51 <Eduard_Munteanu> ksf: you don't really need CAS for modifying an atomic value.
09:35:55 <ndm> @message gwern No, as far as I am aware the GHC isSpace slowness still exists, I did raise a GHC bug for it
09:35:55 <lambdabot> Maybe you meant: messages messages?
09:36:15 <quicksilver> it's @tell :)
09:36:23 <ksf> well, I can't just do another array of MVars, that kills the cache.
09:36:25 <ndm> http://hpaste.org/41613/rts_s_output - given that RTS output, does it mean my program has space left at the end?
09:36:34 <ksf> ...or at least drastically impairs performance.
09:36:36 <ndm> why does performGC only seem to do a Gen 1 GC?
09:36:42 <ndm> @tell gwern No, as far as I am aware the GHC isSpace slowness still exists, I did raise a GHC bug for it
09:36:43 <lambdabot> Consider it noted.
09:36:58 <Eduard_Munteanu> ksf: what do you need it for? Perhaps there are better ways.
09:37:01 <ksf> I need to unbox the lock next to the rest of the data, and I'm not at all sure that works with MVars.
09:37:13 <quicksilver> by default there are only two generations, 0 and 1
09:37:17 <quicksilver> I believe.
09:37:38 <quicksilver> the nursery is collected rather frequently anyway, performGC forces a 'full' collection
09:37:48 <Eduard_Munteanu> ksf: as in, do you need a lock?
09:38:08 <ksf> yep.
09:38:17 <ksf> lookup can be lockfree, but not update.
09:38:34 <ndm> quicksilver: full GC is gen 0 or gen 1?
09:39:54 <Eduard_Munteanu> ksf: I could imagine hashtables that were lockfree on update at least wrt concurrent lookups.
09:40:21 <Eduard_Munteanu> It depends on how you extend the hashtable.
09:40:41 <ksf> yeah you can lookup while updating
09:41:26 <ksf> otoh, I don't have any significant number of pure lookups, it's all updates.
09:42:08 <Eduard_Munteanu> ksf: oh so they're updates, but not really insertions? That doesn't necessarily change the layout of the hashtable.
09:42:10 <ksf> Eduard_Munteanu, http://www.cs.tau.ac.il/~liortzaf/papers/disc2008_submission_98.pdf
09:42:15 * Eduard_Munteanu looks
09:42:39 <ksf> it doesn't, but an insertion might want to move the bucket you're modifying.
09:43:02 <ksf> that should be a quite rare thing, though.
09:44:40 <ksf> Eduard_Munteanu, also http://hpaste.org/41614/hopscotch
09:44:49 <ksf> which is more readable source than what's in the paper.
09:46:26 <ksf> ...doesn't do the multi-threaded thing, though.
09:47:00 <quicksilver> ndm: I think gen 0 is the nursery
09:47:03 <quicksilver> ndm: but I'm not sure.
09:47:11 <quicksilver> ndm: really you need a simon :)
09:47:20 <quicksilver> JaffaCake: you're not really there are you?
09:47:23 <ndm> I'm running with -G1 now, to force one generation, and my returns are look rather weird
09:47:33 <ndm> i think i'll invoke the Simon via email
09:47:57 <byorgey> ghc --invoke-Simon
09:48:14 <Eduard_Munteanu> Are MVars worse than straight pthread locking?
09:48:30 <ksf> they're surely fast
09:49:12 <Eduard_Munteanu> byorgey: strange, I thought ghc was opening a socket straight to SPJ
09:49:35 <ksf> ...but I'd still like to have atomic cas on a Ptr
09:50:11 <byorgey> Eduard_Munteanu: no, since ghc 6.6 it has used a complex simulation of SPJ
09:50:18 <quicksilver> I think MVars are probably faster than pthread locks.
09:50:23 <byorgey> Eduard_Munteanu: but sometimes it isn't sufficient so the --invoke-Simon flag was added
09:50:42 <quicksilver> although I also think that's comparing apples with oranges
09:50:43 <ksf> the problem with MVars is that they're not Storable.
09:50:45 <Eduard_Munteanu> :)
09:51:07 <quicksilver> certainly the GHC team has spent some time trying to get the primitives generating good code
09:51:10 <dankna> .... Storable MVars... the mind boggles
09:51:13 <quicksilver> it's the higher levels that bite you
09:51:40 <Eduard_Munteanu> I'd bet using atomic ops to update is slower than just locking a larger portion.
09:51:53 <Eduard_Munteanu> *can be
09:52:26 <ksf> well hopscotch scales linearly with number of cpus
09:53:11 <ksf> it is a darn good algorithm and I'm not keen on messing (much) with it
09:54:10 <Eduard_Munteanu> ksf: they don't really give much implementation details wrt locking
09:54:23 <Eduard_Munteanu> Except what can be and what can't be lockfree
09:54:29 <ksf> in the appendix
09:54:53 <Eduard_Munteanu> Whoops.
09:54:53 <ksf> the rest of the paper doesn't explain the idea completely.
09:56:10 <jmcarthur> so much Ptr :(
09:56:26 <jmcarthur> and a ccall? is that allowed?
09:56:31 <acemo> ok.. so I can get a random IO Int with "getStdRandom $ randomR (0,65536)" but is it possible without the whole IO stuff?
09:56:48 <ksf> jmcarthur, you try to unbox a product without using vector
09:57:06 <ksf> ffs wouldn't be hard to replace.
09:57:11 <jmcarthur> acemo: mkStdGen
09:57:17 <ziman> acemo, you can use StdGen but you still need to provide the seed.
09:57:18 <ksf> though probably slower.
09:57:41 <jmcarthur> ksf: vector is what i would rather use. dons hinted that it may be possible to convince... i forget his name... to install vector
09:58:00 <jmcarthur> vector has plenty of unsafe versions of functions ;)
09:58:19 <ksf> wouldn't change too much code-wise, though.
09:58:26 <ksf> the code is pretty typesafe as it is.
09:58:43 <ksf> ...note the lack of plusPtr etc. in kitchenSink
10:00:17 <acemo> jmcarthur: and on the StdGen it returns i can call next to generate a number? but how do i tell it between which values the numbers have to be?
10:00:48 <jmcarthur> :t randomR
10:00:49 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:01:09 <jmcarthur> :t randomR (0,99) (mkStdGen 0)
10:01:10 <lambdabot> forall t. (Num t, Random t) => (t, StdGen)
10:03:01 <jmcarthur> acemo: you can also use the MonadRandom package to help manage the generator, but then of course you are using Monad again... but don't be afraid of it :)
10:03:55 <stepkut> I notice that a lot of libraries have a bunch of special haddock stuff in the module description like, 'stability', etc. But I do not see a section in haddock that describes those special tags..
10:04:42 <acemo> jmcarthur: i have no idea what Monad is.. i just need to write a bunch of numbers to a file.. Think it would be worth learning what Monad is for just that?
10:05:16 <Twey> acemo: Monads are not that scary
10:05:24 <Twey> acemo: If you get addition, you get monads
10:06:13 <stepkut> how hard could monads be? You got a type and two simple functions...
10:06:46 <jmcarthur> the difficulty that people have with Monad is just the diversity of things it represents, i think
10:06:49 <ddilinger> just look at any page trying to describe monads, they go on forever :P
10:07:21 <jmcarthur> the types and the laws are all you need to "know" what it is, but of course that doesn't drive home how useful it is
10:07:36 <ddilinger> or when you need <- or ==> or a number of other operators
10:07:41 <baba_bubba> and they usually have a really complicated example
10:07:48 <jmcarthur> the same could be said of most very general things though
10:08:02 <jmcarthur> what is ==>?
10:08:06 <jmcarthur> and <- isn't an operator
10:08:07 <ddilinger> i dont know, i might have made it up :P
10:08:29 <jmcarthur> and in fact, do notation is one of the worst things about Monad when it comes to teaching it
10:08:30 <ddilinger> just i tend to see 'symbolic things' in monadic code that i dont see elsewhere
10:08:40 <ddilinger> and the pages desribing monads just show them without giving the symbols names
10:09:04 <Philippa> jmcarthur: not as bad as having to teach what it expands to straight up as a serious coding style would be, though :-(
10:09:19 <jmcarthur> i'm not sure i agree
10:09:25 <ksf> http://www.haskell.org/haskellwiki/What_a_Monad_is_not   <-- the most important things about monads
10:09:42 <jmcarthur> convenience is not a requirement for being easy to understand
10:09:46 <Philippa> oh, pedagogically you might want to teach the expansion first, but even so
10:09:56 <Philippa> no, but ease of parsing tends to help
10:10:16 <jmcarthur> i tend to think of syntax sugar expension as a parsing step
10:10:29 <baba_bubba> ksf: cool link, thanks!
10:11:05 <Philippa> a) it's not, b) it's entirely possible to assign semantics directly to the sugar
10:11:25 <conal> jmcarthur: i'm with you about the harmfulness of "do" in teaching & learning about Monad. unnecessary magic that shrouds the simplicity of Monad in mystery.
10:11:29 <jmcarthur> a) i know, but both things typically are done at the same time mentally. b) true
10:11:39 <Philippa> 9 times out of 10, I don't think of >>= when I'm writing monadic code
10:11:58 <ksf> monads are background noise.
10:12:10 <Philippa> I only actually expand it out if I'm going WTF and need to pin down something I've clearly misunderstood
10:12:17 <ddilinger> if i had to place it, i would say the problem with monads is the documentation.  For example 'learn you a haskell for great good' starts off with showing <$> <*>  >>=, but no exact description of what that means
10:12:21 <sproingie> in the tutorial i started, i introduced 'do' as a way of sequencing actions, no monad entering into it
10:12:40 <sproingie> mostly because i wanted to introduce a real app
10:12:44 <jmcarthur> sproingie: that's another approach. i'm just personally not a fan of the "lies-to-programmer" approach
10:12:50 <Philippa> ddilinger: the exact description is "hey, there's this abstract structure...", so there's a reason for it
10:12:52 <jmcarthur> but it does work
10:12:57 <ksf> if lyah doesn't explain something, you're supposed to take it at face value.
10:13:00 <conal> jmcarthur: :)
10:13:11 <Philippa> lies-to-learner are fine so long as you leave a trail indicating that they're lies and where to get the next one
10:13:31 <sproingie> i did mention that it's a bit of an oversimplification
10:13:44 <sproingie> for introducing I/O it's good enough
10:14:15 <jmcarthur> they are... *acceptable* as long as they are clearly pointed out, but i still would rather not be lied to. knowing i'm learning lies just makes me feel more lost
10:14:26 <jmcarthur> and i think this is another reason that people feel so lost when learning Monad
10:14:27 <ksf> one really can't teach monads before the learner is comfortable with type errors.
10:14:31 <Twey>  Also, don't be surprised if you leave this page more confused than before. That just means that it has successfully destroyed your false assumptions, or that you've fallen for some horrible inside joke. 
10:14:36 <Philippa> ksf: agreed
10:14:39 <Twey> Horrible inside joke?  As if we would
10:14:42 <Philippa> also, with HOFs
10:14:47 <Twey> 0:)
10:15:13 <acemo> Also, don't be surprised if you leave this page more confused than before.
10:15:17 <acemo> great..
10:15:28 * Philippa does think it might be worth taking a shot at introducing monads in terms of ANF for some people
10:15:37 <sproingie> yeah dealing with error output is tricky.  i sort of handwaved and say "that's just ghc's way of saying it couldn't make the two different types it saw jibe with each other"
10:15:39 <Eduard_Munteanu> ANF?
10:15:43 <ksf> "...and while addition and multiplication are both monoids over the positive natural numbers, a monad is a monoid object in a category of endofunctors: return is the unit, and join is the binary operation. It couldn't be more simple. If that confuses you, it might be helpful to see a Monad as a lax functor from a terminal bicategory. "
10:15:51 <conal> BONUS: speaking of which, please don't use the term "functor value" in LYAH. there are integer values and string values, but not functor values. we could brainstorm here about an accurate & pleasant alternative.
10:15:53 <Philippa> (the relationship between >>= and let bindings in ANF is pretty strong)
10:15:56 <sproingie> thus introducing them to the rigorous mathematical notion of "type jibing"
10:15:56 <Eduard_Munteanu> ksf: hah
10:16:17 <Philippa> Eduard_Munteanu: A(dministrative) Normal Form. A direct-style analogue of CPS with the administrative redexes reduced
10:16:27 <sproingie> "functons"
10:16:29 <Philippa> I've gtg, so someone else can fill in further detail there
10:16:29 <sproingie> "functoids"
10:16:38 <Eduard_Munteanu> Oh, ok.
10:17:05 <ksf> funbits.
10:17:06 <jmcarthur> hmm... is a functor value a type class dictionary? ;)
10:17:21 <sproingie> yunno i still don't understand this dictionary stuff
10:17:22 <Philippa> ping me later if nobody else covers it, it's a simple limitation of lambda calculus + let
10:17:24 <conal> jmcarthur: sure.
10:17:47 <conal> jmcarthur: though the programming model doesn't have dictionaries, and i think BONUS is teaching the programming model.
10:17:47 <ksf> monadic (IO) code easily degenerates into CPS.
10:18:06 <jmcarthur> conal: i'm with you. i was just trying to assign a meaning to "functor value"
10:18:09 <ksf> ...ending up with every single function being a control structure.
10:18:15 <Twey>  join is also the operation true category theorists tend to work with. They also know of bind, but don't use it a lot because, unlike programmers, they don't do any actual productive work.   heheheh.
10:18:22 <conal> jmcarthur: i like it.
10:18:39 <jmcarthur> albeit operational
10:18:47 <Twey> BONUS: Fotes!
10:19:21 <ddilinger> where are <*> <$> etc imported from?  I'm trying yet again on the monad portion of learn you a haskell, but i cant even run the samples
10:19:33 <Eduard_Munteanu> Control.Applicative IIRC
10:19:35 <jmcarthur> ddilinger: those would be in Control.Applicative
10:20:03 <Eduard_Munteanu> Which also tells you they're not really monadic.
10:20:15 <ddilinger> yea, first thing i tried was import Monad :)
10:20:44 <Eduard_Munteanu> ddilinger: for monads, that would be Control.Monad
10:20:55 <HugoDaniel> i can't build haddock for ghc 7 :( :(
10:21:00 <Eduard_Munteanu> :t pure
10:21:01 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
10:21:01 <ddilinger> how can i get types on them? <$> is now valid, but :t <$> is not
10:21:03 <Eduard_Munteanu> :t return
10:21:03 <ksf> you really should do lyah in order.
10:21:04 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
10:21:11 <HugoDaniel> and arch linux updated to ghc 7, meh
10:21:17 <Eduard_Munteanu> ddilinger: use parens
10:21:21 <Eduard_Munteanu> :t (<$>)
10:21:22 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:21:24 <ksf> everything builds upon stuff that's been dealt with before.
10:22:24 * Eduard_Munteanu as a side note, really like the idea of using a dependency graph between chapter like TAPL does
10:22:37 <Eduard_Munteanu> *likes
10:24:38 <jmcarthur> Eduard_Munteanu: me too
10:26:47 <Eduard_Munteanu> jmcarthur: it seems bcpierce had more people advising on pedagogy than actual content, which is good. I wish more (text)books had proper indexes, such graphs etc.
10:38:29 <ksf> the really best monad tutorial out there is http://ertes.de/articles/monads.html
10:38:49 <ksf> ...because it spends enough time on the "why"
10:39:35 <baba_bubba> ksf: looks promising, thanks
10:39:51 <kmc> needs more burritos
10:39:55 <kmc> is this new?
10:40:07 <ksf> nope
10:40:14 <ksf> http://blog.plover.com/prog/burritos.html
10:40:27 <ksf> ...I linked both of them from the what monads are not page.
10:41:47 <HugoDaniel> i need haddock :(
10:43:32 <acemo> ok... function :: IO Int should first do some input/output stuff and then return an Int right?
10:43:40 <kmc> it's not a function
10:43:44 <kmc> functions have -> in their types
10:43:57 <kmc> and i would say "produce" rather than "return" because "return" is what functions do
10:44:08 <copumpkin> can anyone see why http://hpaste.org/41618/type_families_with_unboxed_cod would not be possible, apart from GHC not supporting it right now? TacticalGrace?
10:44:38 <acemo> great.. i'm getting more and more confused about this stuff, all i wanted was to generate some random numbers.. 
10:45:22 <ksf> is there a 1:1 relationship between boxed and unboxed stuff?
10:45:54 <jmcarthur> copumpkin: did you mean to use # instead of *?
10:46:02 <jmcarthur> oh nevermind
10:46:06 <jmcarthur> unboxed. duh
10:46:12 <copumpkin> :)
10:46:12 <ksf> ...and, while I'm at it, can I safely store a MutVar# or TVar# in a Ptr ?
10:46:37 * dixie makes lambdabot running on his machine! (first time)
10:46:39 <copumpkin> ksf: I'd guess not
10:47:01 <copumpkin> ksf: you probably want a StablePtr of it
10:47:18 <ksf> IORef?
10:47:24 <kmc> acemo, did you read http://www.haskell.org/haskellwiki/Introduction_to_IO
10:47:30 <copumpkin> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/ghc-prim-0.2.0.0/GHC-Prim.html#t%3AStablePtr%23
10:47:45 <ksf> gragh no I want to have it unboxed along with the rest of my data, it's a cache locality thing.
10:47:54 <kmc> acemo, don't worry about monads if all you want to do is IO.  that page doesn't talk about them
10:48:12 <ksf> anything supporting atomic cas or upwards would work.
10:48:31 <copumpkin> ksf: the issue is that the MutVar# doesn't live anywhere static, as far as I can tell
10:48:35 <copumpkin> maybe ask in #ghc
10:48:48 <zygoloid> copumpkin: well, you could never use an (Unboxed a) value polymorphically
10:49:26 <kmc> acemo, a value of type "IO T" is called an "IO action".  it's a "recipe" describing how you *could* perform some IO
10:49:48 <kmc> just evaluating the recipe doesn't perform IO.  evaluation and execution are distinct
10:50:05 <kmc> this means that the type "IO T" is very different from the type "T" and also different from the type "S -> T"
10:50:06 <copumpkin> zygoloid: true, so I guess you'd want c++ template-like typeclasses where stuff is specialized at compile time
10:50:13 <copumpkin> (and whole-program compilation)
10:51:27 <ddilinger> can a function that does IO return a 'normal' value, or does the program have to be organized such that the function that does IO then calls whatever needs to be done with it?  
10:51:43 <xarch> not in Haskell, I think
10:51:44 <copumpkin> ddilinger: yeah, you can't take things out of it
10:51:47 <copumpkin> you can only put things into it
10:51:57 <copumpkin> which is sufficient to do anything, but may not be how you'd normally think of it
10:51:58 <xarch> but with unsafePerformIO you can
10:52:04 <copumpkin> xarch: no you can't
10:52:22 <Eduard_Munteanu> You can but you shouldn't?
10:52:22 <xarch> oh, sorry then.
10:52:31 <copumpkin> it still won't behave in a predictable manner
10:52:39 <copumpkin> unless your IO is effectively pure
10:52:53 <yiannis_t> ddilinger: you can get a 'normal' value but only in an IO monad
10:52:58 <copumpkin> haskell + unsafePerformIO is still nothing like an imperative language
10:53:09 <Eduard_Munteanu> Well... unsafePerformIO . return is pretty safe.
10:53:27 <Phyx-> that's basically id
10:53:28 <Phyx-> lol
10:53:30 <Eduard_Munteanu> :)
10:53:56 <c_wraith> it's unsafeId, obviously. :)
10:54:13 <Phyx-> but there's nothing unsafe about it though
10:54:15 <ski> it's ambiguous
10:54:27 <Eduard_Munteanu> ski has a point.
10:54:30 <aristid> there is more than one unsafeId, i think
10:54:51 * ski rather likes <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html>, on the topic of monad tutorials
10:55:07 <aristid> unsafeCoerce :: a -> a
10:55:38 <ski> "To be more specific, it's IO that's impure. That makes the IO monad impure." <- argh :/
10:55:43 * ski thinks that's nonsense
10:55:48 <c_wraith> that should totally be safeCoerce
10:55:58 * Eduard_Munteanu ponders unsafePerformOI :: a -> OI a
10:56:26 <ski> `IO' in no way introduces impurity .. just like using mutation to implement thunks doesn't introduce impurity
10:57:05 <ski> Eduard_Munteanu : heh, i had such an idea, about an `Execution' comonad i was thinking about ..
10:57:12 <roconnor> you need to put on Kleisli googles to see impure functions
10:57:18 <ski> right
10:57:54 <Eduard_Munteanu> ski: unfortunately you kinda need something like that in comonad applications.
10:57:56 <roconnor> a -> IO b is a pure function, but when you put on Klesli goggles ... O-O ... you see an impure a -> b
10:58:06 <ski> impurity is not a property of an operational semantics, but instead has to be stated wrt a source language
10:58:23 <ski> Eduard_Munteanu : example ?
10:58:41 <Eduard_Munteanu> ski: well you need some comonadic value to begin with.
10:58:59 <ski> (i.e. example of where it is potentially unsafe, unless the programmer manually proves what is (implicitly) promised to the compiler)
10:59:01 <Eduard_Munteanu> ski: otherwise cobinding isn't much use.
10:59:33 <ski> yeah, but `repeat :: forall a. a -> Stream a' is not an unsafe operation, e.g.
10:59:41 * roconnor never could make much sense of the OI comonad
10:59:47 <Eduard_Munteanu> ski: actually I don't think it's that unsafe. For example, pattern matching Maybe isn't unsafe, even though it's some unsafePerformMaybe :)
11:00:05 <ski> roconnor : it is a mistake .. at least if one doesn't have something like Clean's uniqueness typing
11:00:12 <Eduard_Munteanu> Erm, it actually is a bit...
11:00:15 <Eduard_Munteanu> :t fromJust
11:00:16 <lambdabot> forall a. Maybe a -> a
11:00:19 <roconnor> ski: how did it get published?
11:00:30 <ski> roconnor : i don't know
11:00:33 <kmc> ddilinger, "a function that does IO"   contradiction in terms
11:00:37 <roconnor> ok
11:00:43 <ski> (was it published in a refereed journal ?  i'm not sure)
11:00:48 <kmc> ddilinger, a function cannot do IO.  it can return a description of some IO to be done later
11:01:01 <ski> Eduard_Munteanu : "I don't think it's that unsafe" -- "it" being ?
11:01:16 <ddilinger> kmc: think of it as a programmer coming from C++, you have a function, IO happens inside of it, so its seems like a function that does IO
11:01:30 <kmc> but that's an incorrect view
11:01:35 <Eduard_Munteanu> ski: extracting from monads  /  creating comonadic values
11:01:42 <kmc> when the function evaluates and returns, no IO has happened
11:01:51 <ddilinger> kmc: how can you force IO to happen?
11:01:56 <ddilinger> kmc: or does it not work that wa
11:01:59 <kmc> the only IO which happens is the action named "main"
11:02:05 <kmc> or any IO action you type at the GHCi prompt
11:02:11 <ski> Eduard_Munteanu : yeah, but extracting from monads isn't something bad, always .. e,g, `evalState' is perfectly safe
11:02:31 <ski> Eduard_Munteanu : the same with `repeat :: forall a. a -> Stream a' for the `Stream' comonad
11:02:33 <kmc> ddilinger, functions pass around descriptions of IO which *could* be performed.  these are values, you can pass and return them like any other value
11:02:37 <kmc> but no IO has occurred
11:02:46 <Eduard_Munteanu> ddilinger: imagine your terminal is pulling from a string that leads into your program, and getting values out of it.
11:02:56 <kmc> when your program runs, the runtime system will get the IO action named "main" and actually execute whatever it says to do
11:03:19 <ddilinger> kmc: so its not possible to return the result of an IO, only pass arround an action that can perform IO?
11:03:21 <Eduard_Munteanu> ddilinger: it ain't your program that _does_ IO.
11:03:46 <kmc> yeah.  your program describes IO, the runtime system does what it's told
11:03:58 <roconnor> ski: oh you are right, as popular as it was, it doesn't seem to have been published in a refereed publication.
11:04:05 <roconnor> The system works.
11:04:06 <ski> ddilinger : if a function "does I/O", then it must have `IO' somewhere in its result type (possibly hidden inside other types)
11:04:35 <roconnor> ski: it is quite well cited though.
11:05:00 <ddilinger> its just a little non-intuitive that i cant get the value of an IO and store it, it has to be an action that will re-perform that IO at any given moment
11:05:30 <kmc> "the value of an IO" makes no sense
11:05:34 <monochrom> re-configure your intuition to accept it.
11:05:37 <kmc> "IO Int" is not like a container storing an Int
11:05:44 <kmc> it's a recipe for how you could obtain an int
11:05:51 <ddilinger> and how do you convert IO Int to Int
11:05:53 <kmc> if you execute this action multiple times, you'll get different Ints
11:05:54 <kmc> you can't
11:06:01 <kmc> ddilinger, did you read http://www.haskell.org/haskellwiki/Introduction_to_IO
11:06:18 <ddilinger> i've been going through learn you a haskell, havn't done the haskell wiki
11:06:20 <kmc> you can't convert IO Int to Int because they are completely different types with completely different meaning
11:06:24 <kmc> ok, check out that one article
11:06:24 <Eduard_Munteanu> ddilinger: you bind around. Like in   f initial_value >>= g >>= h
11:06:29 <aristid> @quote IO String
11:06:29 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
11:06:35 <aristid> @quote IO.String
11:06:35 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
11:06:36 <Eduard_Munteanu> f, g, h :: a -> m b
11:06:38 <monochrom> someone should @remember my famous saying about just because a type has "Money" in it doesn't mean you can extract Money.
11:06:49 <aristid> kmc: does that also work for IO Int? :>
11:06:52 <Eduard_Munteanu> aristid: heh
11:07:26 <Eduard_Munteanu> (actually, that's a bit too general for it's own good, but you get the point)
11:07:31 <monochrom> In fact the type "US_Economy Money" not only means you can't extract Money, but also you have to put in Money and it will only ask for more.
11:07:33 <ddilinger> things just work so differently in haskell, getting used to it :)
11:07:40 <kmc> yeah
11:07:41 <c_wraith> Sometimes people get satisfied and go away if you lie to them and say you can convert an IO Int to and Int with <- .  You can pretend it's true!
11:07:50 <c_wraith> err, to *an* Int
11:07:52 <FunctorSalad> :D
11:07:52 <kmc> it seems unintuitive at first, but it actually makes a ton of sense once you're used to it
11:07:56 <ksf> but US_Economy Money is obviously pointed.
11:07:58 <onteria|i7> I'm walking through a haskell video lecture on Channel 9, and I notice that ghci doesn't like 'average ns = sum ns `div` length ns' but it works okay if I put it in a file and compile it with ghc. Also hugs seems to display the same behavior
11:08:01 <ksf> it's easy to generate more.
11:08:09 <onteria|i7> I'm wondering what the reason is for that
11:08:12 <kmc> Haskell has a better separation of concerns than other languages; we're just not used to those concerns being separate
11:08:22 <kmc> ddilinger, the key is that evaluation and execution are distinct processes
11:08:24 <shachaf> onteria|i7: The ghci prompt isn't a Haskell file.
11:08:28 <Eduard_Munteanu> US_Economy is comonadic, everybody tries to extract stuff from it.
11:08:50 <shachaf> onteria|i7: It corresponds more to a do block.
11:08:53 <ksf> onteria|i7, ghci is basically a do block.
11:09:08 <shachaf> onteria|i7: Use "let" for what you're doing.
11:09:08 <Eduard_Munteanu> Do you guys have lectures on Haskell on TV? oO
11:09:32 <onteria|i7> Channel 9 is an MS thing
11:09:40 <Eduard_Munteanu> Oh.
11:09:45 <ddilinger> one more q', is there a difference between 'func a = let foo=bar in baz' and 'func a = baz where foo=bar' (insert returns as necessary)
11:09:56 <monochrom> no difference
11:10:08 <ski> roconnor : yeah :/ .. and i'm not really sure the operation `(.>>) :: Comonad w => w a -> b -> w b' Kieburtz introduced is of much value
11:10:20 <onteria|i7> ah, let indeed did the trick and thanks for the explanation on what ghci is doing
11:11:01 * monochrom invents the analogy "IO is like DRM" :)
11:11:31 <Eduard_Munteanu> ski: that's a bit like >>= variants others have proposed.
11:12:00 <ski> Eduard_Munteanu : yeah .. and i think trying to shoehorn comonads into what we expect from monads make no sense at all
11:13:18 <Eduard_Munteanu> Yeah, the codo stuff might never be useful.
11:13:42 <copumpkin> {-# LANGUAGE OverlappingInstances, IncoherentInstances #-} instance Eq a where x == y = case reallyUnsafePtrEquality# x y of 1# -> True; _ -> False
11:14:01 <copumpkin> that should be in the Prelude
11:14:10 <ksf> hmmm v >>== f = join $ ($v) `liftM` f
11:14:29 <ski> onteria : one reason for this is that the declarations in a Haskell file are all mutually recursive with each other. but it's hard to do the same in an interactor like GHCi,Hugs,nhi,hbi,&c. for hopefully apparent reasons ..
11:14:32 <ksf> ...usually used as f ==<< v, I'd say.
11:14:39 <copumpkin> yeah, was just going to say
11:15:14 <Eduard_Munteanu> What's $v ?
11:15:24 <ksf> not a splice.
11:15:28 <kmc> a section?
11:15:31 <ksf> yep.
11:15:50 <Eduard_Munteanu> And what is it?
11:16:00 <ski> Eduard_Munteanu : Philippa had some ideas .. and i have some ideas .. but i don't think it useful to expect something that similar to the monad `do'-notation
11:16:03 <ksf> :t \v f -> join $ ($v) `liftM` f
11:16:04 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => a1 -> m (a1 -> m a) -> m a
11:16:22 <Eduard_Munteanu> :t \v -> $v
11:16:23 <lambdabot> parse error on input `$'
11:16:27 <ksf> f, in my case, is Maybe (Maybe Value -> Maybe Value) 
11:16:49 <ksf> but in general Maybe (Maybe -> Maybe Value) 
11:16:49 <ddilinger> if haskell is a 'non-strict functional programming language', what about it isn't strict, i thought strict refered to typing but aparently not
11:16:53 <Eduard_Munteanu> Section as in section/retract?
11:16:59 <kmc> ddilinger, strict as opposed to lazy
11:17:03 <kmc> strict evaluation order
11:17:09 <ddilinger> ahh, evaluation order, ok
11:17:09 <ksf> as in "look if you have a function and if yes, apply my argument to it".
11:17:14 <Eduard_Munteanu> As in pseudoinverse?
11:17:18 <kmc> :t \v -> ($v)
11:17:19 <lambdabot> forall a b. a -> (a -> b) -> b
11:17:30 <kmc> :t \v -> (+v)
11:17:31 <lambdabot> forall a. (Num a) => a -> a -> a
11:17:47 <Eduard_Munteanu> Oh.
11:18:00 <ski> ddilinger : in that example, no difference. in general, there's a difference :
11:18:04 <ski> ddilinger : (a) `let .. in ..' is an expression, so can occur anywhere an expression can occur, nested inside another expression e.g.
11:19:05 <ski> ddilinger :     but `where' attaches to defining equations/clauses (as well as `case'-branches), so can't be as easily used "inside" other things
11:19:43 <ksf> ...where the function I give may fail, that's the important point that makes it useful even in the face of bind.
11:21:18 <ski> ddilinger : (b) otoh, since `where' attaches to equations and `case'-branches, it can bind variables which can be used in guards .. which you can't do with `let'. e.g. `foo (x:xs) | x < m = ..m.. where m = minimum xs'
11:22:35 <Eduard_Munteanu> BTW, if I remove rules like    t2 -> t2'  --------------   t1 t2 -> t1 t2'     from TAPL, I end up with lazy evaluation, right?
11:22:46 <ski> Eduard_Munteanu : s/section\/retract/section & retraction/ :)
11:23:35 <kmc> yeah Eduard_Munteanu, but you're only describing non-strict semantics.  lazy evaluation is an implementation strategy for non-strict semantics
11:23:36 <Eduard_Munteanu> Oh, right.
11:25:09 <Eduard_Munteanu> kmc: as in some speculative evaluation could still be nonstrict?
11:25:59 <kmc> yeah
11:26:08 <kmc> or the work-duplicating implementation of non-strict
11:26:21 <Eduard_Munteanu> For example, I could see that non-strict semantics can still express infinite lists if you evaluate "a few elements" instead of none.
11:26:27 <ski> Eduard_Munteanu : given `r : A >-> B' and `s : B >-> A', if those satisfy `r . s = id', then `r' and `s' is said to form a retract situation, and `B' is said to be a retract of `A'
11:26:32 <ski> Eduard_Munteanu : additionally, `r' is known as a retraction (of `s') and is also known as a split epi; while `s' is known as a section (of `r') and is also known as a split mono
11:26:41 <kmc> let a=2+2 in a+a  (2+2)+(2+2)  4+(2+2)  4+4  8
11:26:51 <kmc> "call by name" versus lazy aka "call by need"
11:27:04 <Eduard_Munteanu> ski: yeah. Although I first heard about those in an algebra treatise, and it referred to functions / relations.
11:27:15 <Eduard_Munteanu> It's also in Awodey's on category theory.
11:27:46 <ski> Eduard_Munteanu : the "split" name comes from that `s . r' (call it `f') here must be an idempotent, i.e. `f . f = f', and if `f = s . r', such that `r . s = id', then the idempotent `f' is said to split into `r' and `s'
11:28:36 <kmc> Eduard_Munteanu, "lazy evaluation" is the particular strategy for implementing non-strict semantics where you avoid duplicated work by allocating a placeholder for the let-bound variable and destructively updating it with the result once you've computed it once
11:28:48 <kmc> that's a pretty operational, not denotational, idea
11:29:31 <Eduard_Munteanu> kmc: yes, I was talking about the operational semantics given in TAPL, though they used call by value.
11:29:32 <monochrom> also lambda-bound variables
11:29:46 <ski> Eduard_Munteanu : removing that evaluation rule (and modifying some things) gives you the "normal order" evaluation strategy (alt. call-by-name, if you don't evaluate under lambdas)
11:29:57 <kmc> monochrom, i suppose so
11:30:09 <kmc> depends on your formalism... in STG the only construct which allocates thunks is "let"
11:30:13 <Eduard_Munteanu> So which do we have in Haskell? I think it's call by name.
11:30:16 <monochrom> TaPL is call-by-value
11:30:33 <Eduard_Munteanu> Yes.
11:30:34 <kmc> Eduard_Munteanu, non-strict semantics.  most (all?) implementations use call-by-need evaluation strategy
11:30:36 * hackagebot hjsmin 0.0.4 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.0.4 (AlanZimmerman)
11:30:50 <kmc> but the Report doesn't require it
11:30:59 <monochrom> Most (or all) haskell implementations are call-by-need, following the advocation by some Wadler paper or something.
11:31:03 <kmc> so if you want to be totally pedantic, "Haskell is a lazy language" is an incorrect statement
11:31:08 <kmc> "GHC is a lazy Haskell implementation"
11:31:13 <Eduard_Munteanu> I see.
11:32:02 <ski> kmc : iirc, some experimental system evaluated things eagerly in threads, making sure to handle partiality correctly
11:32:04 <Eduard_Munteanu> (Sometimes semantics given by TAPL seem confusing, since I'm still assuming I'm reading stuff for Haskell purposes :) )
11:32:42 <kmc> in STG lambda-bound vars aren't given thunks explicitly, but the only things allowed for a function call (syntactically) are vars and primitive values
11:33:07 <monochrom> http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html#need-journal is my preferred description of call-by-need or lazy
11:33:36 <Eduard_Munteanu> By the way, what happens if I know some value doesn't need to be evaluated and let it possibly evaluate to undefined? What happens if some compiler/RTS decides "hey let's evaluate this speculatively" ?
11:34:01 <Eduard_Munteanu> It seems the report allows for this.
11:34:32 <Eduard_Munteanu> Should the RTS complain or ignore it if not "needed"?
11:35:24 <monochrom> Yes, speculation is allowed if it doesn't hang things that shouldn't be hang.
11:35:35 <Eduard_Munteanu> Ah, I see.
11:36:10 <alex404> So I've got a multiparamter typeclass Foo a b c, and I've instantiated it in another module as Foo A B C, but I can't run the methods. GHC complains that I haven't instantiated the class when I tried to run it on the appropriate objects.
11:36:36 <alex404> It does however compile.
11:36:36 <allbery_b> you can actually trigger that with some ghc optimizations I think. theoretically it's allowed, practically it's an "illegal" action if evaluation would change the program's behavior --- and determining that is the Halting Problem
11:37:47 <allbery_b> so ghc will let you do it with some optimizations but those are documented explicitly as changing the strictness behavior of your program and its up to you to insure things don't break. IIRC
11:37:59 <ChongLi> alex404: a typeclass is not the same thing as a class in an imperative language such as C++
11:38:04 <monochrom> If I ask to evaluate (5 < 0 && []!!5 > 0), you may spawn a thread to speculatively evaluate []!!5>0, find that it is an error, and later find out it is not needed, and silently drop the error.
11:39:04 <Eduard_Munteanu> Hm, tricky.
11:39:22 <kmc> alex404, you're getting a *run-time* error?
11:39:30 <alex404> kmc: Yes.
11:39:31 <allbery_b> monochrom: yes, ut what if it speculatively evaluates let x = x in x ?
11:39:43 <kmc> alex404, sounds like you're writing the instance but omitting one of the methods
11:39:49 <kmc> alex404, are you building with ghc -Wall
11:39:55 <monochrom> if it doesn't starve other threads, it's ok!
11:39:59 <ski> alex404 : have you implemented the class methods ?
11:40:16 <alex404> kmc: Just trying to run it through ghci. And yah I've implemented all the methods in the class.
11:40:21 <alex404> ski: Yes.
11:40:35 <alex404> kmc: Should I try running through ghc -Wall you think?
11:40:49 <ski> what is the error ?
11:40:52 <kmc> or ghci -Wall
11:41:04 <alex404> Neat. Didn't know you could do that.
11:41:22 <monochrom> in the year 2140 we will have 10^100-core desktops and so ghc 940 will do multi-threaded speculative evaluations!
11:41:38 <alex404> The error is "No instance for (Foo A b c) arrising from use of method
11:41:45 <kmc> how is that a run-time error?
11:41:57 <kmc> you can hpaste your code an error message
11:42:03 <alex404> yah, just a sec
11:42:06 <monochrom> it's a compiler run-time error :)
11:42:18 <monochrom> @quote monochrom runtime
11:42:18 <lambdabot> monochrom says: just add #! /usr/bin/runghc to your haskell file. then type errors occur at runtime only.
11:42:20 <Eduard_Munteanu> monochrom: such a googol-core would be many times larger than the universe :P
11:42:38 <monochrom> haha
11:42:54 <monochrom> I probably really have no idea how large 10^100 is.
11:42:57 <alex404> Umm... if I the files compile (in ghci anyway) and I only get the error when I run it, doesn't that make it runtime?
11:43:30 <Eduard_Munteanu> Yeah, 10^100 looks small, but it ain't :)
11:43:35 <mornfall> alex404: Well, guess it can't type check code you haven't typedyet.
11:43:39 * ski first read it as "we will have (10^100 (core desktops))" (i.e. re the common window manager "desktop" thing)
11:44:13 <Eduard_Munteanu> "A googolplex is ten raised to the power of one googol: it is a large number. In the documentary Cosmos, astronomer and broadcast personality Carl Sagan  estimated that writing a googolplex in base-10 numerals (i.e., 1 followed by a googol of zeroes) would be physically impossible, since doing so would require more space than the known universe provides."
11:44:19 <ski> alex404 : "run it" means what ?
11:44:22 <monochrom> "press ctrl-alt-right 10^100 times to get to the rightmost desktop"? :)
11:44:26 <ski> alex404 : enter an expression in GHCi ?
11:44:37 <ski> alex404 : running a compiler executable from your OS ?
11:44:48 <Eduard_Munteanu> So by that reasoning a 10^100-core would be equally unreasonable.
11:45:03 <Eduard_Munteanu> (googolplex = 10^(10^100))
11:45:23 <monochrom> yeah
11:45:29 <alex404> ski: Entering an expression
11:45:53 <ski> monochrom : "Ctrl-Alt-Left" once, obviously !
11:46:08 <ski> alex404 : then that expression can still have a type error (or an ambiguity)
11:46:46 <monochrom> ctrl-alt-left doesn't wrap around for me. then again I'm just using ubuntu gnome whatever and you may just call me substandard.
11:47:19 <alex404> Okay, here is the hpaste:
11:47:22 <alex404> http://hpaste.org/41621/class_definition
11:48:55 <ski> where is `mlp' in the expression bound ?
11:49:12 <kmc> alex404, oh, the problem is it's not willing to choose that particular instance
11:49:19 <kmc> because you did nothing to constran the b and c parts
11:49:38 <kmc> alex404, is it the case that, for some particular A, there should only be one B and C such that instance Model A B C exists?
11:49:55 <alex404> kmc: For now, yah
11:50:00 <Eduard_Munteanu> Fundeps
11:50:10 <kmc> then you should write class Model a b c | a -> b, a -> c where ...
11:50:17 * ski sees no `instance ... => Model MultiLayerPerceptron .. ..' anywhere in the paste ..
11:50:18 <kmc> "functional dependencies"
11:50:45 <ski> kmc : are you sure alex404 wants those fundeps ?
11:50:45 <Eduard_Munteanu> (I think a -> b c is also valid)
11:51:08 <alex404> ski: The instance is just after the error. I didn't include the whole module
11:51:09 <kmc> it will fix the bug and it fits the model just described
11:51:17 <ski> kmc : oh, sorry, missed you asked just that
11:51:35 <Eduard_Munteanu> *Bayes.Perceptron> (mlp *|*)
11:51:47 <Eduard_Munteanu> ski: ^
11:52:06 <kmc> i am kind of suspicious of this design
11:52:07 <ski> Eduard_Munteanu : yes ?
11:52:15 <Eduard_Munteanu> It's right in looking for a MultiLayerPerceptron b c, instead of more specific stuff.
11:52:27 <kmc> like, having an instance C T and an instance C [T], just so the user can avoid typing extra []?
11:52:47 <alex404> kmc: It is a bit over the top
11:52:52 <alex404> kmc: But I'm still experimenting
11:53:03 <raek> Does anyone have any recommendation for an introduction article on monads? I don't mind if it is formal. Something like "a monad consists of these parts, that fits together in this way" with some examples using types a Haskell beginner might befamiliar with. (Perhaps with an explanation of the 'do' syntax too...)
11:53:12 <alex404> It is very nice not to have to enter the Vector.fromList yourself
11:53:14 <kmc> raek, typeclassopedia
11:53:21 <kmc> raek, are you just trying to do IO?
11:53:47 <alex404> raek: I had great experience with 'Learn you a Haskell'
11:53:48 <Eduard_Munteanu> alex404: I think an ADT would suffice
11:54:25 <alex404> Eduard_Munteanu: For what? The Sample/SupervisedSample classes?
11:54:43 <Eduard_Munteanu> data MultiLayerPerceptron a = MLP [U.Vector a] a
11:55:08 <raek> kmc: no, I just want to learn about what monads are in general. thanks for the suggestion!
11:55:12 <raek> alex404: thanks!
11:55:20 <Eduard_Munteanu> then when you actually use it, you can define a type synonym for MultiLayerPerceptron Double
11:55:38 <alex404> kmc: Why does the way I've arranged things bother you, though? Do you really think it's bad design?
11:56:04 <ski> raek : <http://web.cecs.pdx.edu/~antoy/Courses/TPFLP/lectures/MONADS/Noel/research/monads.html> has some motivating examples .. it is slightl dated, though (`accumulate' is now spelled `sequence', e.g.
11:56:43 <ski> )
11:56:57 <kmc> alex404, yes
11:57:21 <alex404> Eduard_Munteanu: I'm not sure I understand what you're saying... but MultiLayerPerceptron is not a paramterized data type. The paramters are all from the instance.
11:57:29 <alex404> kmc: Why?
11:57:31 <kmc> alex404, it's a frivolous use of classes, unnecessary complexity
11:57:32 <Eduard_Munteanu> I don't why you'd use an MPTC with a single instance there.
11:57:54 <roconnor> > mempty :: All
11:57:54 <lambdabot>   All {getAll = True}
11:58:16 <Eduard_Munteanu> alex404: then an ADT for Model?
11:58:28 <Eduard_Munteanu> alex404: why do you think you need typeclasses there?
11:58:38 <alex404> kmc: Is there a better way of hiding the difference between Vectors and lists from the user?
11:58:40 <kmc> alex404, frivolous classes => more confusing error messages, fewer errors caught at compile time
11:58:47 <alex404> kmc: Fair enough
11:58:52 <kmc> alex404, i wouldn't hide that difference.  i'd just provide separate functions
11:59:07 <Eduard_Munteanu> And hide constructors if you care that much.
11:59:08 <micrypt1> Random question? I have dmenu installed on Ubuntu but can't seem to get the "mod + p" shortcut working. 
11:59:21 <kmc> fromVec / fromList / fromLists
11:59:22 <kmc> or something
11:59:34 <ChongLi> is this a daily battle here or something? :)
11:59:36 <Eduard_Munteanu> micrypt1: does it work for other mod combos?
11:59:57 <alex404> The primary reason I've created this certain typeclass is so that I can have the (*|*) and related functions work across a variety of models
12:00:03 <ChongLi> I've learned my lesson: let go of your imperative assumptions
12:00:41 <ChongLi> should be some kind of support group for this :)
12:00:43 <kmc> alex404, so maybe Model should be a data type, with a field which is that function
12:00:46 <alex404> It creates a nice conceptual framework across the whole library
12:00:46 <roconnor> Cale: can you give lambdabot a show instance for Control.Applicative.Const
12:00:50 <roconnor> @seen Cale
12:00:50 <lambdabot> Unknown command, try @list
12:00:50 <preflex>  Cale was last seen on #haskell 12 hours, 20 minutes and 48 seconds ago, saying: guest2425: It really seems (at least to us) like you're just guessing randomly at a lot of things. That's just not going to work when you're programming. Rather than fighting with error messages from the compiler, you might actually step away from the computer and try to write your complete function on paper first,
12:00:51 <preflex>  and get it into a state where you're reasonably sure it'll work before typing it in.
12:00:56 <ChongLi> because it is such a radical change
12:01:05 <roconnor> @ask Cale:can you give lambdabot a show instance for Control.Applicative.Const
12:01:05 <lambdabot> Consider it noted.
12:01:05 <kmc> ChongLi, it's not just about "imperative".  Haskell is an imperative language too
12:01:11 <roconnor> @ask Cale can you give lambdabot a show instance for Control.Applicative.Const
12:01:12 <lambdabot> Consider it noted.
12:01:33 <alex404> kmc: How would that work?
12:02:02 <ChongLi> kmc: well, I'm not sure what term would best label the transition from a language like C++ to Haskell
12:02:14 <ChongLi> and all of the terms that change with it
12:02:16 <kmc> ChongLi, "imperative" and "functional" aren't two warring camps
12:02:25 <kmc> C++ isn't a model "imperative" or "object-oriented" language
12:02:31 <micrypt1> Eduard_Munteanu: Other mod combos seem to be working fine. 
12:02:34 <kmc> C++ is just a mess
12:02:46 <kmc> it's just bad, and what you're abandoning are the ideas from programming in a bad language, not an "imperative" language
12:02:52 <aristid> kmc: you're such a troll :P
12:02:59 <kmc> don't legitimize bad design by calling it a "paradigm"
12:03:07 <ChongLi> kmc: haha
12:03:16 <monochrom> haha, "imperative victims rehabilitation group therapy society"
12:03:29 <kmc> if you want good imperative programming, use Haskell or Clojure or Python or Ruby or like two hundred other languages that aren't C++
12:03:38 <micrypt1> Eduard_Munteanu: I thought perhaps the installation went awry I can run "dmenu_run".
12:03:42 <kmc> aristid, :D
12:03:47 <monochrom> or even just "worldly victims rehabilitation group therapy society"
12:03:56 <micrypt1> *but I can...
12:04:45 <kmc> part of learning Haskell is learning functional style as an alternative to imperative style
12:05:01 <kmc> but part of learning Haskell is unlearning arbitrary restrictions from C++ and Java that have nothing to do with "paradigms"
12:05:06 <ksf> I'd call OO a doctrine.
12:05:29 <alex404> What's that quite about OO and premature generalization?
12:05:35 <alex404> *quote
12:05:42 <monochrom> @quote monochrom premature
12:05:43 <lambdabot> monochrom says: premature generality is the root of OOP
12:05:49 <Eduard_Munteanu> micrypt1: hm... check the keybindings, maybe it's not enabled.
12:05:57 <ksf> @quote premature.generalisation
12:05:57 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
12:06:23 <alex404> ksf: What did you mean by that?
12:06:24 <Eduard_Munteanu> micrypt1: oh, and check mod+shift+p. AFAIK, it's gmrun on mod+p by default and dmenu on mod+shift+p
12:06:45 <monochrom> my "premature" means you don't even have a use-case you need now.
12:07:00 <ksf> that starting out with anything but concrete code is a bad idea. abstract once you've moved out of thin air onto solid ground.
12:07:39 <alex404> It's somewhat surprising that it would be haskellers who need to make that admonishment
12:07:50 <monochrom> Piaget says concrete examples before abstraction. He says it just for education. I say it for writing programs too.
12:08:10 <dankna> heh, Piaget - didn't expect to hear that name in here
12:08:14 <ksf> you can spend ages in arcane terms that even typecheck.
12:08:15 <dankna> and I agree
12:08:18 <ksf> but they won't go "bing"
12:08:19 <alex404> I had the exact reaction
12:08:40 <ksf> alex, google for "zygohistomorphic prepromorphism"
12:08:48 * Eduard_Munteanu *hides*
12:08:53 <pygmalion> what's the difference between print and show?
12:08:55 <alex404> ksf: Dear lord, I'd rather not ;)
12:09:05 <ksf> print = putStrLn . show
12:09:17 <byorgey> pygmalion: show just converts things to String.  print converts something to a string and then prints it to the screen.
12:09:18 <ChongLi> ksf: what? I thought that was a joke :P
12:09:34 <pygmalion> ah so no putStrLn needed
12:09:40 <Eduard_Munteanu> ChongLi: it's not.
12:09:45 <Eduard_Munteanu> ChongLi: well it is, but it's real.
12:09:57 <kmc> it's a real thing
12:10:02 <kmc> it's a joke that anyone would use it
12:10:05 <Eduard_Munteanu> :)
12:10:06 <ChongLi> ah
12:10:14 <monochrom> People here who learn monads applicatives etc are evidence for Piaget's opinion.
12:10:28 <ksf> WHILE WE'RE AT IT
12:10:35 <ksf> what's the CT name of (==<<) :: Monad m => m (a -> m b) -> a -> m b
12:10:56 <kmc> i agree Haskell has lots of premature generalization.  which is why I'm slightly allergic to Haskell code where every function lives in a class
12:11:28 <alex404> kmc: Is that your primary issue with my code?
12:11:29 <Eduard_Munteanu> ksf: counit ?
12:11:31 <kmc> or, let's make class Thing a where thing :: a and then every program can be written as thing thing thing thing thing thing thing thing thing
12:11:37 <kmc> alex404, yeah
12:11:42 <kmc> not that i think your code is horrible alex404
12:11:46 <Eduard_Munteanu> ksf: looks a lot like a simple counit :: w a -> a
12:11:55 <kmc> i'm not even saying you should change it necessarily
12:12:05 <kmc> just pointing out the downside of this design
12:12:06 <ksf> note the m in the function.
12:12:14 <ksf> f ==<< v = join $ liftM ($ v) f
12:12:23 <alex404> I've only just come up with that module today... I'm still wrestling with the correct joints at which to cut it
12:12:28 <kmc> *nod*
12:12:33 <copumpkin> :t let f ==<< v = join $ liftM ($ v) f in (==<<)
12:12:34 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => m (a -> m a1) -> a -> m a1
12:12:34 <alex404> which is to say, all advice is welcome ;)
12:12:44 <monochrom> kmc: you may like my http://article.gmane.org/gmane.comp.lang.haskell.cafe/83292/ :)
12:12:56 <Eduard_Munteanu> :t return Just
12:12:56 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Maybe a)
12:13:06 <acemo> if i'm going to use any IO stuff, i'll have to rewrite my whole program to use IO everywhere?
12:13:21 <ChongLi> acemo: no
12:13:24 <pygmalion> http://pastebin.com/HSDe7pMf for some reason this code is not "show"ing an the correct version of an object on the first try but it is in consecutive times like this: http://pastebin.com/1eCgHdHA
12:13:39 <kmc> acemo, no, you usually have an outer layer of IO which calls other functions
12:13:53 <monochrom> acemo: no, you will have to refactor your design so you have what kmc says
12:13:53 <kmc> main = do { x <- readLn;  print (complicatedPureFunction x) }
12:13:56 <ksf> did anyone mention contravariance yet?
12:14:00 <Eduard_Munteanu> acemo: see interact for example
12:14:02 <Eduard_Munteanu> :t interact
12:14:03 <lambdabot> (String -> String) -> IO ()
12:14:29 <monochrom> interact is hard to get execution order right.
12:14:48 <monochrom> (but yes, I know how and I may use it)
12:15:34 <Eduard_Munteanu> It works for basic stuff that parses input "causally" and outputs something.
12:15:35 <kmc> acemo, i think LYAH, RWH, etc. cover  this
12:15:42 <micrypt1> Eduard_Munteanu: No luck.
12:16:30 <Eduard_Munteanu> micrypt1: hm, I'd try adding an explicit keybinding.
12:16:36 <Eduard_Munteanu> micrypt1: also there's #xmonad
12:16:38 <monochrom> bad interleaving of I/O and non-I/O appear in beginner c++ code too. they ask user for input data not in main or designated UI parts; they ask in freaking constructors!
12:16:42 <acemo> LYAH, RWH?
12:16:46 <kmc> @where LYAH
12:16:46 <lambdabot> http://www.learnyouahaskell.com/
12:16:48 <kmc> @where RWH
12:16:48 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
12:16:51 * hackagebot bibtex 0.0.6 - Parse, format and processing BibTeX files  http://hackage.haskell.org/package/bibtex-0.0.6 (HenningThielemann)
12:17:10 <kmc> haha monochrom
12:17:40 <monochrom> class RationalNumber { RationalNumber() { cout << "please enter numerator: "; ...
12:17:51 <acemo> THANKS
12:17:55 <acemo> sorry caps
12:18:02 <micrypt1> Eduard_Munteanu: Okay, thanks. 
12:18:02 <kmc> yeah i would say separating IO from computation is not a new idea in software engineering
12:18:48 <monochrom> I opine that such garbage is usually unpunished and therefore when they come to haskell they hit such a wall.
12:18:48 <Eduard_Munteanu> micrypt1: try pasting your config and posting it there.
12:19:13 <Eduard_Munteanu> monochrom: that's true
12:19:39 <ChongLi> IO is dirty and error-prone
12:19:43 <megatron242> Hi, I have noob question
12:19:49 <monochrom> I had no problem entering haskell and accepting such as separated walled IO because I was already separating I/O in my Java code anyway!
12:19:50 <acemo> kmc, i think the problem i'm having is we learned only pure stuff.. and i'm trying to use haskell for an other subject, which makes me have to use do, let, IO and monads all of which, i haven't learned yet
12:20:06 <kmc> yeah well, ignore monads for now
12:20:11 <kmc> it happens that IO is a monad
12:20:17 * Eduard_Munteanu didn't think monochrom was a Java codemonkey :)
12:20:22 <megatron242> I want to write a function that take a number n and a list, and create a list of lists, each one in the size of n
12:20:29 <monochrom> I was even a Perl codemonkey.
12:20:33 <kmc> but it also happens that integers are an Abelian group, yet when we teach people to add we usually omit this fact
12:20:34 <ski> roconnor : you saw my links re coexponentials ?
12:20:42 <megatron242> I tried the followin, but it won't compile:
12:20:45 <monochrom> And a BASIC codemonkey.
12:20:46 <megatron242> splitList :: (Num n, Ord n) => n -> [a] -> [[a]]
12:20:48 <megatron242> splitList val xs
12:20:48 <megatron242>    | length xs < val = [[xs]]
12:20:48 <megatron242>    | otherwise = (take val xs):splitList (drop val xs) xs
12:20:55 <megatron242> Any ideas?
12:21:05 <kmc> acemo, anyway, Real World Haskell tries to bridge the gap from little toy haskell example to real-world IO-ful code
12:21:13 <kmc> and LYAH gets there too, though slower
12:21:20 <monochrom> I am a counterexample to what Dijkstra says about BASIC harmful as a first language :) (And yes, I know that many of you are, too.)
12:21:31 <kmc> TI-83 basic for lyfe
12:21:44 <dankna> MS BASICA 3.0
12:21:52 <alex404> Nibbles for life
12:21:54 <monochrom> Applesoft BASIC!
12:22:10 <monochrom> (oh, Apple Integer BASIC too)
12:22:18 <Eduard_Munteanu> Well I was only about 7 when I discovered DOS had QBasic.
12:22:34 <acemo> kmc: I'll try RWH then
12:23:14 <kmc> did you read that "introduction to IO" article?
12:23:27 <Eduard_Munteanu> (But "codemonkey" has a very well-defined name for Java programmers in corporate environments, usually the kind that just stepped out of university)
12:23:57 <b_jonas> Eduard_Munteanu: you must be young
12:24:08 <acemo> yeah
12:24:09 <acemo> actually
12:24:18 <dankna> by the time QBasic came out I had switched from DOS to the Mac :)
12:24:18 <Eduard_Munteanu> Not that young, 22.
12:24:19 <ChongLi> acemo: you might want to read both
12:24:34 <b_jonas> when I was 7, DOS didn't yet have qbasic, though I wouldn't have known about it if it did
12:24:41 <paolino> megatron splitList val (drop val xs)
12:24:42 <acemo> i think my problem is i don't understand do and let
12:24:44 <Eduard_Munteanu> Oh.
12:24:56 <kmc> acemo, "let" has nothing in particular to do with IO or monads
12:24:56 <b_jonas> I used GW-BASIC first, but not yet when I was 7 I think
12:25:00 <kmc> it's useful everywhere
12:25:05 <b_jonas> later I did use QBASIC
12:25:06 <kmc> it's just a way to make a local name for something
12:25:09 <kmc> > let a = 2+2 in a*3
12:25:10 <lambdabot>   12
12:25:21 <kmc> the syntax for let-within-do is different, but that's about all
12:25:27 <Eduard_Munteanu> b_jonas: suffice to say, I broke that computer often :)
12:25:32 <acemo> ohh that makes sence
12:25:35 <kmc> and "do" is not fundamental; it's syntactic sugar for this (>>=) operator
12:25:47 <acemo> i don't know the >>= operator either
12:25:56 <kmc> and (>>=) is where monads would come in.  a monad is roughly defined as "any type which implements the (>>=) operator".  but you can ignore that fact and pretend (>>=) is for IO only
12:26:01 <kmc> (>>=) :: IO a -> (a -> IO b) -> IO b
12:26:07 <kmc> the "Introduction to IO" article does this
12:26:14 <kmc> maybe you could read it again
12:26:37 <kmc> so we said the type "IO T" represents a recipe for doing IO with a result of type T
12:26:55 <kmc> (>>=) is how we combine these IO-recipes together to make bigger recipes
12:27:15 <alex404> Do people have favourite operators? Because for me it's <$>
12:27:20 <kmc> (m >>= f) is a recipe which consists of "execute m, pass its result to f, and execute the recipe returned by f"
12:27:28 <kmc> so it lets you do one thing, then decide what to do next based on the result
12:27:39 <monochrom>   is my favourite operator
12:27:41 <kmc> but (m >>= f) is just another recipe, and no IO has actually happened until you get to "main"
12:27:43 <Eduard_Munteanu> alex404: with the risk of repeating myself, boobies is better.
12:27:48 <Eduard_Munteanu> :t (.) (.)
12:27:49 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
12:28:12 <acemo> hmm
12:28:13 <acemo> okay
12:28:28 <alex404> That's the silliest thing I've ever seen.
12:28:47 <alex404> My introduction to haskell for people will now consist of: fib, then boobies
12:28:49 <Eduard_Munteanu> alex404: @pl comes up often with that
12:28:54 <ChongLi> how many new people come in here every day? it seems like haskell is growing rather nicely
12:28:55 <ksf> right now, I'm quite fond of (x *<< y) f = poke (f x) =<< peek (f y)
12:29:16 <ksf> ...which is yet another thing that's -- if possible at all -- utterly non-trivial to do in say C++.
12:29:24 <alex404> Eduard_Munteanu: @pl?
12:29:45 <ksf> (struct1 *<< struct2) field
12:29:56 <ksf> move field of struct 2 to field of struct1
12:30:38 <alex404> ksf: What are poke and peek supposed to be?
12:30:46 <ksf> raw pointer access.
12:30:48 <Eduard_Munteanu> @pl \x -> map head (zip [1..] x)
12:30:48 <lambdabot> map head . zip [1..]
12:30:51 <ksf> peek peeks, poke pokes.
12:30:53 <acemo> kmc, i'll study the stuff a bit and i'll get back when i think i understand it mostly
12:31:01 <alex404> ksf: Got it
12:31:03 <acemo> or if i get some specific questions..
12:31:19 <kmc> cool acemo :)
12:31:26 <alex404> acemo: FYI, I found LYAH more useful than RWH. Try them both to see which suits you
12:31:37 <Eduard_Munteanu> @pl \x y -> map head (zip (head x) y)
12:31:37 <lambdabot> (map head .) . zip . head
12:31:43 <alex404> acemo: If you spend a whole day with LYAH, you can get to and finish the monad stuff
12:31:50 <alex404> acemo: err, io stuff
12:31:56 <Eduard_Munteanu> alex404: it turns function definitions into pointfree style
12:31:58 <ksf> for monads in specific, there's also the best of the best linked from http://www.haskell.org/haskellwiki/What_a_Monad_is_not
12:32:05 <Eduard_Munteanu> (pun on "pointless")
12:32:20 <copumpkin> what are IRC handles of people who work on haddock?
12:32:23 <copumpkin> mtnviewmark, who else?
12:32:28 <acemo> alright
12:32:32 <ksf> ...note that "point" doesn't mean "dot".
12:32:43 <ksf> point is math-speak for variable bindings.
12:32:53 <alex404> o
12:33:03 <ksf> (some mathematician is about to hit me with a terminology bat)
12:33:07 <Eduard_Munteanu> Or functions applied on points.
12:33:15 <ksf> Q.E.D.
12:33:23 <monochrom> no pedantic mathematician here, don't worry
12:33:24 <Eduard_Munteanu> Or as in pointwise convergence.
12:33:32 <ksf> so predictable.
12:33:38 <ksf> even the statisticans.
12:33:39 <alex404> That's the lamest kind of convergence.
12:33:41 <Eduard_Munteanu> @unpl (.) (.)
12:33:41 <lambdabot> (\ b c e f -> b c (e f))
12:33:43 <alex404> Whatever to that.
12:33:49 <Eduard_Munteanu> ^ does the reverse
12:33:51 <vitka> :q
12:41:27 <copumpkin> @tell mtnviewmark hmm, http://hackage.haskell.org/packages/archive/hoopl/3.8.6.0/doc/html/Compiler-Hoopl-Wrappers.html seems broken :) is that a CSS issue?
12:41:28 <lambdabot> Consider it noted.
12:41:33 <copumpkin> preflex: seen mtnviewmark
12:41:33 <preflex>  mtnviewmark was last seen on #haskell 13 hours, 47 minutes and 22 seconds ago, saying: ah - I don't know WinGHCi at all...
12:45:01 <augur> anyone know anything about algebraic proof theory?
12:46:14 <roconnor> augur: is that universal algebra?
12:46:17 <gueux> hi
12:46:50 <augur> roconnor: it might employ UA, i dont know
12:47:13 <gueux> I have a problem with ghc: it seems that it shadows my local db by the global one :(
12:47:13 <augur> roconnor: its just a way of treating proofs as algebraic objects
12:47:36 <roconnor> I've never heard of this
12:47:42 <gueux> is there something to do to force the use of the local one?
12:47:52 <ski> @type let (toStruct *<< fromStruct) field = Foreign.Storable.poke (field toStruct) =<< Foreign.Storable.peek (field fromStruct) in (*<<)
12:47:53 <lambdabot> forall t a. (Foreign.Storable.Storable a) => t -> t -> (t -> GHC.Ptr.Ptr a) -> IO ()
12:47:54 <copumpkin> augur: algebraic objects in what sense?
12:48:30 <augur> copumpkin: dont ask me! im trying to figure out what it is!
12:49:01 <monochrom> gueux: my understanding is that the local shadows the global.
12:49:01 * hackagebot fix-symbols-gitit 0.1.0 - Gitit plugin: Turn some Haskell symbols into pretty math symbols.  http://hackage.haskell.org/package/fix-symbols-gitit-0.1.0 (ConalElliott)
12:49:36 <gueux> monochrom: in my case it seems to be the contrary
12:49:56 <monochrom> I can't reproduce it. what is your secret of success?
12:50:05 <ksf> ski, the only thing that's missing there is mapping it over a heterogenous list of fields.
12:51:08 <gueux> monochrom: http://pastebin.com/Q0nA9TdR http://pastebin.com/jihMf5j8
12:51:28 <gueux> the local xmonad-contrib is shadowed by the global one
12:52:00 <ksf> Setup.hs defaults to --global which completely ignores the user database.
12:52:10 <ksf> cabal-install defaults to --user which shadows the global.
12:53:52 <ski> (hm, "Test.HUnit.Base (" seems like a strange response from `@hoogle+' ..)
12:54:25 <monochrom> notice that ironically the global xmonad is shadowed by the local xmonad.
12:55:39 <monochrom> gueux: do you mind sending me the complete contents of both /var/lib/ghc-6.12.1/package.conf.d and /home/gueux/.ghc/x86_64-linux-6.12.1/package.conf.d ?  I am writing an article on these oddities and I need an odd state like this which I can't quite reproduce myself.
12:57:02 <ski> @type let foo = (`flip` 1) . Foreign.Marshal.Array.moveArray in (foo `on`)
12:57:03 <lambdabot> forall a a1. (Foreign.Storable.Storable a) => (a1 -> GHC.Ptr.Ptr a) -> a1 -> a1 -> IO ()
12:58:13 <Jeroen__> Does anyone know a good explanation for the function definitions ?
12:59:19 <kmc> can you be more specific?
13:00:24 <Jeroen__> I'm doing a little assignment
13:00:29 <Jeroen__> And I have no problem implementing the solution
13:00:34 <Jeroen__> But we also have to add a type definition
13:00:41 <Jeroen__> like Int -> [Int] -> Int
13:00:51 <Jeroen__> But I can't seem to find a clear explanation
13:01:07 <kmc> Jeroen__, that should be covered early on in a Haskell book or tutorial
13:01:10 <kmc> what have you been reading?
13:01:20 <Jeroen__> No book, only classes ...
13:01:24 <Jeroen__> Which aren't that great ...
13:01:26 <kmc> then you should find a book to read
13:01:28 <kmc> @where LYAH
13:01:28 <lambdabot> http://www.learnyouahaskell.com/
13:01:30 <kmc> @where RWH
13:01:30 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
13:01:34 <kmc> both free online
13:01:37 <Jeroen__> Thx
13:01:40 <kmc> Jeroen__, a function that takes an argument of type S and returns a value of type T has type S -> T
13:01:46 <Jeroen__> I've looked trhough the haskel site, but I don't really get that part
13:02:02 <kmc> when a function takes multiple arguments A, B, C, we write A -> B -> C -> T
13:02:13 <kmc> what that really means is A -> (B -> (C -> T))
13:02:19 <kmc> and the reason for that is
13:02:26 <pkrumins> as i like to say, haskell begins with monads
13:02:38 <kmc> that a "multi-argument" function is actually a function of one argument, which returns another function to take the second argument
13:02:44 <ksf> ...there's no functions with more than one argument in haskell.
13:02:50 <kmc> pkrumins, why would you say that
13:03:08 <pkrumins> cause that's where the interesting stuff starts
13:03:13 <kmc> i don't agree
13:03:17 <Jeroen__> I get that functions only take one argument .
13:03:18 <ksf> once you broke the monad barrier you can read oleg and thus understand everything?
13:03:20 <kmc> type classes are interesting
13:03:29 <kmc> "classical" functional programming is interesting
13:03:37 <pkrumins> kmc, i disagree
13:03:38 <kmc> algebraic data and pattern matching are interesting
13:03:40 <Jeroen__> I have a little example here, a function whose first argument is a functor (i mean something like *)
13:03:51 <Jeroen__> and the type def is: myfunction :: (Int -> Int -> Int) -> Int -> [Int] -> Int
13:03:54 <kmc> at least, all these things are interesting if you come from the typical intellectually starved background
13:03:55 <Jeroen__> How does that work ?
13:03:59 <pkrumins> kmc, it's pretty mundane, not very exciting.
13:04:00 <kmc> Jeroen__, that's not what the word "functor" means
13:04:06 <kmc> only in C++ does it mean that, and they're crazy
13:04:10 <kmc> (*) is a function
13:04:11 <pkrumins> kmc, gotcha what you're saying
13:04:14 <Jeroen__> Yeah, thought so ... Thats why I added the (i mean something like ... :p)
13:04:21 <kmc> Jeroen__, what do you mean by "how does that work"?
13:04:37 <Eduard_Munteanu> kmc: do C++ people actually speak of functor? Or what do you mean? :)
13:04:41 <Eduard_Munteanu> *functors
13:04:48 <pkrumins> Eduard_Munteanu: not in that sense
13:04:51 <Jeroen__> If the first argument is a function (like *), I have to embed its signature in my own ?
13:04:56 <pkrumins> Eduard_Munteanu: functors in c++ are classes with operator()
13:04:58 <ksf> in C++ and other ill-advised terminologies functors are callable objects.
13:05:01 <kmc> Eduard_Munteanu, in C++ a functor is a function which has to be implemented in 12 lines of code instead of one because it has some free variables
13:05:08 <kmc> Jeroen__, yes
13:05:17 <pkrumins> Eduard_Munteanu: I wrote an article on various uses of term Functor in programming: http://www.catonmat.net/blog/on-functors
13:05:19 <kmc> a function which takes S and returns T has type S -> T
13:05:22 <maurer_> Jeroen__: See also
13:05:22 <Jeroen__> myfunction f = f 5     ==> signature = (Int -> Int -> Int) -> Int ?
13:05:24 <maurer_> :t foldr
13:05:25 <kmc> Jeroen__, that's true even if S itself is a function type
13:05:25 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
13:05:27 <kmc> @type map
13:05:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:05:33 <maurer_> or
13:05:33 <kmc> (ignore the "forall" bit for now)
13:05:36 <maurer_> :t foldl
13:05:37 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:05:43 * Eduard_Munteanu will look
13:05:49 <kmc> map :: (a -> b) -> [a] -> [b]
13:05:50 <Eduard_Munteanu> So I guess it isn't CT-related.
13:06:07 <kmc> Eduard_Munteanu, indeed, it's a fancy word to make the lack of first-class functions sound like a feature
13:06:13 <pkrumins> Eduard_Munteanu: not in c++.
13:06:27 <kmc> with C++ the easy is hard and the hard impossible
13:06:33 <kmc> [/troll]
13:06:34 <pkrumins> kmc, well c++ now has lambdas ;)
13:06:42 <kmc> so Jeroen__, does it make sense?
13:06:44 <pkrumins> kmc, and the impossible is possible ;)
13:06:51 <pkrumins> kmc, it's a circular list!
13:06:58 <Jeroen__> kmc: If this is correct, i get it: myfunction f = f 5 ==> signature = (Int -> Int -> Int) -> Int ?   and I use it like myfunction *   ?
13:07:17 <kmc> :t let myfunction f = f 5 in myfunction
13:07:17 <pkrumins> offset by one.
13:07:18 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
13:07:31 <pkrumins> stroustrup was drunk and offset the pointers by one by accident.
13:07:33 <kmc> when you write * it parses as an infix application of that operator
13:07:39 <maurer_> Jeroen__: Standard type signature notation (for future reference) would be
13:07:41 <kmc> to refer to multiplication itself you write (*)
13:07:53 <maurer_> myFunction :: (Int -> Int -> Int) -> Int
13:08:04 <kmc> @type let myFunction f = f 2 3 in f
13:08:05 <lambdabot> forall a. (SimpleReflect.FromExpr a) => a
13:08:08 <kmc> err
13:08:10 <kmc> ignore that
13:08:12 <kmc> @type let myFunction f = f 2 3 in myFunction
13:08:13 <lambdabot> forall t t1 t2. (Num t1, Num t) => (t -> t1 -> t2) -> t2
13:08:21 <kmc> you could also write (Int -> Int -> Int) -> Int
13:08:31 <kmc> instead of the more general polymorphic type
13:08:39 <kmc> @type let myFunction :: (Int -> Int -> Int) -> Int; myFunction f = f 2 3 in myFunction
13:08:40 <lambdabot> (Int -> Int -> Int) -> Int
13:08:41 <maurer_> > let testFunc f = f 2 3 in testFunc (*)
13:08:41 <lambdabot>   6
13:09:04 <Jeroen__> Ok, I think I get it
13:09:08 <kmc> cool
13:11:19 <Jeroen__> Currently, I have a function which takes the arguments           [(3+),(2*), (5-)]   10                 Signature :: [ Int->(Int->Int->Int)]->Int->Int    (it returns an int). Is that correct ?
13:11:52 * ksf grokked that stuff after staring at SICP's listing of cons car and cdr in terms of lambdas, not believing his eyes. 
13:12:34 <ksf> I'd say that's [Int -> Int] -> Int -> Int
13:12:42 <pkrumins> ksf, i love that one
13:12:44 <ksf> :t (3+)
13:12:45 <lambdabot> forall t. (Num t) => t -> t
13:12:49 <kmc> (3+), (2*), (5-) are all Int -> Int
13:12:51 <pkrumins> i should write about cons car and cdr in term of lambdas
13:12:55 <ksf> ...well, nearly.
13:12:59 <kmc> so [(3+), (2*), (5-)] is [Int -> Int]
13:13:07 <Jeroen__> Ah, ok
13:13:08 <pkrumins> very intersting stuff, people would love it.
13:13:19 <Jeroen__> You know what would help? If someone explained the lambdabot ... :D
13:13:31 <kmc> > let f :: [Int -> Int] -> Int -> Int; f xs y = map ($ y) xs in f [(3+),(2*), (5-)]   10
13:13:31 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
13:13:32 <lambdabot>         against inferred type ...
13:13:33 <Jeroen__>     :t generages a type def ?
13:13:37 <Jeroen__> *generates
13:13:42 <ksf> like in ghci, yes.
13:13:45 <kmc> you use :t to ask for the type of an expression
13:13:59 <Jeroen__> aha
13:14:03 <ksf> > "executes stuff"
13:14:04 <Jeroen__> Thats usefull :D
13:14:04 <lambdabot>   "executes stuff"
13:14:06 <Eduard_Munteanu> You just told him how to cheat on his homework :)
13:14:09 <Jeroen__> (I told you, the classes suck :p)
13:14:14 <ksf> > "I mean evaluates"
13:14:15 <lambdabot>   "I mean evaluates"
13:14:27 <Jeroen__> Thats probably not cheating ...
13:14:36 <kmc> > let f :: [Int -> Int] -> Int -> Int; f xs y = sum $ map ($ y) xs in f [(3+),(2*), (5-)]   10
13:14:37 <lambdabot>   28
13:15:03 <kmc> Jeroen__, where are you taking this class?
13:15:12 <ksf> aka known as [(3+),(2*), (5-)] <*> pure 10
13:15:15 <Jeroen__> Belgium
13:15:17 <ksf> > [(3+),(2*), (5-)] <*> pure 10
13:15:18 <lambdabot>   [13,20,-5]
13:15:19 <kmc> ok
13:15:27 <ksf> omg it's too late.
13:15:30 <kmc> Jeroen__, ghci is your friend; you can evaluate expressions and also ask their types
13:16:26 <kmc> lambdabot does those things too, and a lot more
13:16:28 <ksf> @pl \xs y -> sum $ xs <*> pure y
13:16:28 <lambdabot> (sum .) . (. pure) . (<*>)
13:17:04 <ksf> > ((sum .) . (. pure) . (<*>)) [(3+),(2*), (5-)] 10
13:17:05 <lambdabot>   28
13:17:13 <ski> pkrumins : heh, i was about to hand kmc that link :)
13:17:18 <ski> @quote chewing.pieces
13:17:18 <lambdabot> shapr says: Academics are continually chewing pieces off of impossible and making them merely difficult.
13:17:18 <ski> @quote impossible.just
13:17:19 <lambdabot> <autrijus> says: Perl: "Easy things are easy, hard things are possible" <autrijus> Haskell: "Hard things are easy, the impossible just happened"
13:17:34 <Jeroen__> Well, that all looks like gibberish to me, but I'm sure I'll understand it in a few weeks :)
13:17:48 <kmc> weeks or months or years...
13:17:52 <Jeroen__> :D
13:17:55 <Jeroen__> Always an optimist ;)
13:18:01 <ksf> anything containing (. foo) is pure evil.
13:18:02 <pkrumins> ski ;)
13:18:14 <Eduard_Munteanu> @pl output often looks gibberish
13:18:14 <lambdabot> output often looks gibberish
13:18:26 <Eduard_Munteanu> @vixen Shut up!
13:18:26 <lambdabot> you sound like an awesome guy... are you single?
13:18:28 <kmc> yeah, Haskell can take a while to learn
13:18:40 <b_jonas> @unpl \xs y -> sum $ xs <*> pure y
13:18:40 <lambdabot> \ xs y -> sum (xs <*> (pure y))
13:18:44 <kmc> people are surprised, they think a new language is just new syntax for old OOP concepts
13:18:46 <ski> Jeroen__ : "Teach Yourself Programming in Ten Years" at <http://norvig.com/21-days.html> by Peter Norvig :)
13:18:52 <danr> well (. foo) is not to complex, but when it becomes (bar .) . (. foo) it's a bit too much I'd say :p
13:18:55 <pkrumins> so i had this macho attitude - you can learn everything in 1 day
13:19:01 <jmcarthur> lol
13:19:18 <pkrumins> so i'd tell everyone how stupid they were cause they couldn't learn something in 1 day
13:19:24 <ksf> you can write yourself a scheme in 48 hours!
13:19:25 <Jeroen__> Gotta love those "learn programming in 24 h" books :p
13:19:37 <pkrumins> and then i started programming in haskell, and a week later i was not further than hello world
13:19:49 <jmcarthur> lol http://www.haskell.org/haskellwiki/Learn_Haskell_in_10_minutes
13:19:51 <pkrumins> realized how idiotic my attitude had been
13:19:53 <ski> @type (. (. not))
13:19:55 <lambdabot> forall b b1. ((Bool -> b1) -> b) -> (Bool -> b1) -> b
13:19:55 <JoeyA> I have a macho attitude: you can learn everything in one day  :-)
13:20:03 <pkrumins> and i have never been that arrogant from then on.
13:20:13 <Jeroen__> Be back in 10 !
13:20:14 <Jeroen__> :D
13:20:22 <dancor> has anyone written a heterogeneous STM select :: [Sel] -> IO () with data Sel = forall a. => Sel (STM a) (a -> IO ())
13:20:31 <jmcarthur> that link ends with a section titled "Topics that don't fit in 10 minute limit"
13:20:36 <kmc> teach yourself 100,000 Deutschmarks in 20 minutes
13:20:44 <conal> ski: (argument.argumet) not
13:20:51 <pkrumins> tech yourself Deutsch in EIN UHR
13:21:00 <conal> (in SEC style)
13:21:01 <ski> conal : yeah
13:21:01 <baba_bubba> yeah, haskell is very humbling
13:21:32 <monochrom> dancor: no, but I assume it's writable in terms of orElse?
13:21:59 <conal> danr: also spelled foo ~> bar.  i use it *a lot*.
13:22:18 <Eduard_Munteanu> Is that some sort of "Has anyone written a heterogenous STM select, OR ELSE..."? :P
13:22:24 <jmcarthur> relevant http://norvig.com/21-days.html
13:22:28 <danr> conal: how do you define (~>) ? is it (.) . (.)?
13:22:38 <monochrom> hrm! no, it may be difficult just because of typing. got to workaround the type system! :)
13:22:47 <dancor> monochrom: you have to mark/number the STM a somehow..
13:22:58 <dancor> the (STM a) somehow
13:23:02 <conal> danr: particularly when bar & foo are inverses. for instance bar is a newtype constructor and foo is the constructor. leads to cascading simplifications.
13:23:03 <ski> conal : sometimes i think using `(<-<)' by `(res <-< arg) f = res . f . arg' can be clearer than `argument' and `result'
13:23:27 <Eduard_Munteanu> jmcarthur: hm, yeah, that's actually pertinent
13:23:32 <jmcarthur> considering that learning haskell is for many like starting over, it logically follows that it takes 10 years to learn haskell
13:23:36 <ski> conal : .. hm, or is that your `flip (~>)' ?
13:23:38 <dancor> wearing the hair straitjacket
13:23:41 <jmcarthur> therefore i am not done yet
13:23:46 <conal> danr: defined in Control.Compose, in the TypeCompose package.
13:24:01 <kmc> the idea of being done learning is sad
13:24:04 <JoeyA> My problem is, I learned it in a few months, and blew off a lot of other stuff I was supposed to be doing.
13:24:05 <ski> @type \bar foo -> (bar .) . (. foo)
13:24:05 <lambdabot> forall b a b1 (f :: * -> *). (Functor f) => (b1 -> b) -> f a -> (a -> b1) -> f b
13:24:11 <kmc> researchers are not done learning.  they are just learning things nobody else has learned yet
13:24:21 <pkrumins> jmcarthur: well not 10!
13:24:24 <pkrumins> 10 is too crazy long
13:24:25 <conal> danr: yes. it's defined as you did. or in terms of 'argument' & 'result'.  you can see a lot of uses in my blog.
13:24:29 <pkrumins> in 10 you can have 10 children!
13:24:42 <ski> @type let (.) = (Prelude..) {- please ! -} in \bar foo -> (bar .) . (. foo)
13:24:43 <lambdabot> forall c a b c1. (c1 -> c) -> (a -> b) -> (b -> c1) -> a -> c
13:24:47 <Eduard_Munteanu> pkrumins: so each can learn Haskell in 7 days? :P
13:25:06 <pkrumins> teach them haskell as natural language
13:25:09 <dancor> in 7 children
13:25:11 <conal> ski: i've gone to using ~> instead of argument & result.
13:25:15 <jmcarthur> pkrumins: do you know all of english?
13:25:17 <ski> conal : good :)
13:25:36 <pkrumins> jmcarthur: hold on there cowboy! this comparison doesn't work
13:25:39 <jmcarthur> (i'm assuming that's your native tongue)
13:25:41 <ski> conal : `(~>)' is the exponential functor map
13:25:47 <conal> ski: yeah. much prettier. 
13:26:07 <Jeroen__> I'm off to bed. Thanks for the help everyone. I'll be dropping by again and maybe I'll stick around :) Cya!
13:26:10 <pkrumins> jmcarthur: it doesn't work because english is evolving all the time, at a much faster rate than haskell!
13:26:11 <FunctorSalad> is there a library for building sql strings?
13:26:24 <jmcarthur> pkrumins: haskell evolves pretty dang quickly
13:26:29 <conal> oops. caleskell is using the wrong (.) generalization here.
13:26:30 <JoeyA> English is evolving?
13:26:33 <roconnor> @hoogle fromMaybe
13:26:33 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
13:26:50 <Eduard_Munteanu> "As Alexander Pope said, a little learning is a dangerous thing."
13:27:02 <FunctorSalad> meh printf-th will do I guess ;)
13:27:04 <ski> conal : that way, you don't have to choose between `argument f . result g' and `result g . argument f' (the same argument goes for `(***)' instead of `first' and `second', of course)
13:27:07 <pkrumins> jmcarthur: but i get your point.
13:27:20 <pkrumins> well, let's say this then
13:27:26 <pkrumins> you can never learn anything!
13:27:32 <jmcarthur> pkrumins: even the simplest of ideas are never mastered. consider lowly addition, for example
13:27:35 <FunctorSalad> (don't worry, I'm not substituting user-supplied values, just abstracting my repetitive create script)
13:27:36 <Eduard_Munteanu> FunctorSalad: the other day I just found out we had SQL-like list comprehensions in a GHC extension :O
13:27:43 <pkrumins> *fully
13:28:00 <FunctorSalad> Eduard_Munteanu: :o like linq?
13:28:05 <conal> ski: yep. tho also more specialized/ad-hoc than argument & result, both of which have many other handy uses.
13:28:13 <jmcarthur> as far as i know, no person in the entire world understands every little nuance of addition
13:28:23 <jmcarthur> it would be awesome to be wrong about that
13:28:24 <danr> conal: nice library! I don't know how I have missed this! thanks I'll probably start using it right away!
13:28:37 <Eduard_Munteanu> FunctorSalad: http://haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html     7.3.10. Generalised (SQL-Like) List Comprehensions
13:28:38 <conal> danr: :) !
13:28:47 <pkrumins> jmcarthur: agreed.
13:29:17 <roconnor> @type fromMaybe
13:29:17 <lambdabot> forall a. a -> Maybe a -> a
13:29:24 <conal> danr: i'm sorry for the hodge-podge nature of this lib. could be split into a few packages.
13:29:37 <JoeyA> jmcarthur: what nuances doesn't a big integer package understand?
13:30:03 <ski> conal : yea
13:30:13 <ski> conal : wrong `(.)' generalization ?
13:30:27 <FunctorSalad> Eduard_Munteanu: :D when did that sneak in?
13:30:30 <JoeyA> I guess adding things that aren't integers?  :-)
13:30:41 <jmcarthur> i was about to point out that obvious one, yes ;)
13:30:52 <conal> ski: in lambdabot's reply to @type \bar foo -> (bar .) . (. foo)
13:30:54 <FunctorSalad> I never ever saw it discussed here
13:31:15 <ski> conal : i mean .. what would the right generalization be ?
13:31:42 <conal> ski: not just one.
13:31:52 <conal> ski: there are a couple of useful generalizations.
13:32:07 <ski> ok s/the/a/ :)
13:32:08 <conal> ski: one is Category, and another is DeepArrow
13:32:13 <conal> yeah
13:32:48 * ski was thinking you had something other, like `(Caleskell..)' or `Caleskell.flip' in mind
13:32:51 <ski> @type flip
13:32:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
13:33:05 <pelotom> > [(x, y) | x <- [1,2,3] | y <- [4,5,6]]
13:33:06 <lambdabot>   [(1,4),(2,5),(3,6)]
13:33:32 <gueux> monochrom: http://pastebin.com/ts8rzpkT http://pastebin.com/b9qSaRV4
13:33:52 <pelotom> FunctorSalad: have you seen parallel list comprehensions?
13:34:09 <monochrom> dancor: http://hpaste.org/41623/heterogeneous_orelse_or_moar 
13:34:16 <FunctorSalad> pelotom: other than parMap on a regular list?
13:34:17 <fxr> @pl \x y -> x + y + 1
13:34:17 <lambdabot> flip flip 1 . ((+) .) . (+)
13:34:25 <FunctorSalad> or mapPar, I can't remember
13:34:44 <monochrom> gueux: sorry, I mean the content of those files too, not just directory listing.
13:34:51 <pelotom> FunctorSalad: no, it's not necessarily performed in parallel, it's just a syntax for zipping
13:34:56 <gueux> ok
13:35:18 <pelotom> > [(x, y) | x <- [1,2,3] | y <- [4,5,6]] -- FunctorSalad
13:35:19 <lambdabot>   [(1,4),(2,5),(3,6)]
13:35:34 <FunctorSalad> pelotom: cool. news to me
13:35:34 <Eduard_Munteanu> FunctorSalad: dunno, I spotted it while looking for something else.
13:35:46 <pelotom> in data parallel haskell it's actually done in parallel of course
13:35:48 <FunctorSalad> all these eastereggs :)
13:36:14 <jrk_> would a data structure like "hierarchically tiled arrays" make sense for haskell?
13:36:38 <ski> fxr : `((+ 1) .) . (+)'
13:36:48 <jmcarthur> jrk_: i don't know what you mean by that
13:36:54 <Eduard_Munteanu> jrk_: could you explain in more detail?
13:37:02 <orlandu63> > [(x, y, z) | x <- [1..3]  | y <- [4..6], z <- [7..9]]
13:37:03 <lambdabot>   [(1,4,7),(2,4,8),(3,4,9)]
13:37:11 <jrk_> yap
13:37:16 <jrk_> one moment please
13:37:22 <dancor> monochrom: nice!
13:37:34 <FunctorSalad> > [(x,y) | x <- [1..3] | y <- [1..x] ]
13:37:35 <lambdabot>   *Exception: not a number
13:37:39 <JoeyA> > sequence [[1..3],[4..6],[7..9]]
13:37:40 <lambdabot>   [[1,4,7],[1,4,8],[1,4,9],[1,5,7],[1,5,8],[1,5,9],[1,6,7],[1,6,8],[1,6,9],[2...
13:37:47 <FunctorSalad> lol wtf (the error)
13:37:48 <JoeyA> oops
13:37:51 <jrk_> htas are currently in research and there is an experimental c++ lib: http://polaris.cs.uiuc.edu/hta/
13:37:57 <ski> FunctorSalad : `x :: Expr'
13:37:58 <JoeyA> > fix error -- fix'd
13:37:59 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
13:38:14 <FunctorSalad> (I expected 'x not in scope') ski: ah makes sense!
13:38:29 <aristid> > getZipList . sequenceA $ map ZipList [[1..3], [4..6], [7..9]]
13:38:30 <lambdabot>   Not in scope: `sequenceA'
13:38:55 <jrk_> the idea of htas is to have a 2-dim array (a tile) which is hierarchically (recursive) scattered across cluster/nodes or at least threads/cores
13:39:08 <Eduard_Munteanu> I suspected so... looks a bit like comonads doesn't it?
13:39:12 <jmcarthur> jrk_: sounds like simple data parallelism to me
13:39:26 <pelotom> I wonder, is the hope for data parallel haskell that it will eventually be so solid that all pure haskell code can be transformed with it, without having to explicitly use [: parallel arrays :]?
13:39:33 <jmcarthur> jrk_: we can take it even beyond that soon, but nested data parallelism is a work in progress
13:39:40 <jmcarthur> jrk_: in the meantime, you might be interested in repa
13:39:40 <ksf> never.
13:39:52 <Eduard_Munteanu> Hm, okay, not just a design pattern.
13:39:52 <jrk_> there are quite a few papers around on it: http://portal.acm.org/citation.cfm?id=1066657
13:39:54 <ksf> dph arrays have other semantics than lists.
13:40:03 <ksf> ...regarding strictness, infinity etc.
13:40:20 <jmcarthur> jrk_: repa is only for regular multi-dimensional arrays, essentially, but nested data parallelism is for irregular things like unbalanced trees
13:40:26 <pelotom> ksf: because they're strict?
13:40:33 <pelotom> hm, right
13:41:02 <ksf> but stream fusion will surely one day replace the standard fusion framework.
13:41:14 <jrk_> jmcarthur: where could i find more info about nested data parallelism?
13:41:26 * monochrom wants generalized GADT fusion!
13:41:42 <jmcarthur> jrk_: here's a fun talk http://www.youtube.com/watch?v=NWSZ4c9yqW8
13:41:50 <jrk_> (in the meantime i have to implement htas in $some_other_language *sigh*)
13:42:12 <jrk_> thanks
13:42:22 <Eduard_Munteanu> What's fusion here?
13:42:22 <jmcarthur> jrk_: you could probably implement htas in haskell, but you might like htas less after watching that video ;)
13:42:30 <ksf> Eduard_Munteanu, deforestation
13:42:34 <Eduard_Munteanu> Oh.
13:42:39 <pelotom> jrk_: also have a look here: http://haskell.org/haskellwiki/GHC/Data_Parallel_Haskell and at the papers it links to
13:42:57 <ddilinger> is '-' a function?  i'm just curious because :t (-79) and :t (0-79) are both legal, but it would seem (- 79) should return a function with one parameter
13:43:08 <Eduard_Munteanu> ddilinger: that's a special case
13:43:32 <gueux> monochrom: http://gueux.org/caca/tata
13:43:38 <Eduard_Munteanu> ddilinger: it's a syntax feature, you can't reimplement it in terms of other language constructs.
13:43:41 <ksf> ...supercompilation will make it so much easier to actually get fusion right, eliminating all those constructors and destructors reliably without any fragile rules.
13:43:49 <gueux> monochrom: http://gueux.org/caca/tata2
13:43:59 <ksf> we code in interesting times.
13:44:04 <jrk_> pelotom: thanks!
13:44:09 <monochrom> gueux: thanks alot.
13:44:51 <roconnor> @hoogle Seq
13:44:51 <lambdabot> Data.Sequence data Seq a
13:44:51 <lambdabot> Prelude seq :: a -> b -> b
13:44:51 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
13:44:52 * ksf still opts to completely abandon unary -
13:44:59 <ksf> 0- should be enough for everyone.
13:45:19 * hackagebot vector-strategies 0.1 - A parallel evaluation strategy for boxed vectors  http://hackage.haskell.org/package/vector-strategies-0.1 (ThomasDuBuisson)
13:45:42 <alex404> Is the only difference between Repa and Accelerate that Accelerate is built with the CUDA backend?
13:46:01 * Eduard_Munteanu would want overridable application (aka "space" :) ) and making integers a group :)
13:46:16 <dons> nice, tommd
13:46:19 <gueux> 21:51:35 < ksf> Setup.hs defaults to --global which completely ignores the user database.
13:46:24 <jrk_> jmcarthur: i was just wondering if it would make sense to propose it to my prof :)
13:46:32 <gueux> I've used "runhaskell Setup.lhs configure --user --prefix=$HOME
13:46:36 <gueux> in both cases
13:46:48 <bench1> how to solve this with haskell: http://milo.com/images/MiloEngineeringProblem.pdf
13:46:56 <ksf> oh I was just spouting out a faq answer.
13:47:03 <jrk_> i hope i'll find some good unis in the papers from the wiki page..
13:47:33 <ksf> --prefix=$HOME is suspicious, though.
13:47:56 <ksf> cabal knows to install stuff in ~/.cabal and ~/.ghc , without that.
13:48:10 <bench1> i.e., how to best represent a matrix for the problem above
13:48:18 <alex404> jmcarthur: The metal intro on that SPJ video is something special
13:48:20 <Eduard_Munteanu> bench1: well you should work out more specific questions.
13:48:23 <jmcarthur> heh
13:48:38 <alex404> It does express how I feel about haskell
13:48:49 <Eduard_Munteanu> bench1: matrices can be represented as arrays
13:48:56 <bench1> E_M: with java, i can do a two dimension array for representing matrix
13:49:02 <bench1> is that the best way to do in java?
13:49:02 <Eduard_Munteanu> Or lists but I wouldn't recommend.
13:49:38 <Eduard_Munteanu> bench1: you mean Haskell? Yeah, arrays are okay for matrices, though it very much depends what you want to do with it.
13:50:19 <bench1> E_M: yes in haskell
13:50:48 <Eduard_Munteanu> @hoogle Data.Array
13:50:48 <lambdabot> module Data.Array
13:50:48 <lambdabot> package array
13:50:48 <lambdabot> Data.Array.IArray array :: (IArray a e, Ix i) => (i, i) -> [(i, e)] -> a i e
13:51:03 <bench1> so assume i use array, then how do i do dynamic programming in haskell -- since the data is in-mutable
13:51:17 <Eduard_Munteanu> There might be other solutions, such as hmatrix, if you require linear algebra stuff.
13:51:38 <monochrom> gueux: I'm wondering if "sudo ghc-pkg recache" and "ghc-pkg --user recache" helps.
13:52:16 <gueux> monochrom: no :(
13:52:48 <jrk_> any good hints on (european) universities with a focus on haskell?
13:52:50 <roconnor> bench1: use the boxed arrays with the LazyST monad.
13:53:05 <gueux> I've tried to remove --prefix=$HOME but it still does not work
13:53:10 <Botje> bench1: make each cell of the array represent a solution to a subproblem
13:53:25 <roconnor> bench1: then you can define arrays whose value depends on other values in the array
13:53:26 <Botje> bench1: and rely on lazy evaluation to only calculate each solution once, as it's needed
13:53:36 <osaunders> So, cross-compiling, possible with GHC?
13:53:43 <lispy1> jrk_: graduate or undergraduate?
13:53:59 <jrk_> lispy1: graduate
13:54:03 <Eduard_Munteanu> osaunders: afaik, not really. If you want to cross-compile for Windows, then you could try like I did: install the platform in Wine.
13:54:09 <bench1> roconnor: can you elaborate on boxed array? 
13:54:26 <roconnor> bench1: arrays are boxed unless you see a U somewhere
13:54:28 <Eduard_Munteanu> osaunders: as in true cross-compiling is difficult.
13:54:32 <lispy1> jrk_: My advice for graduate schools is to focus on the faculty.  Find faculty members who like Haskell.
13:54:36 <osaunders> Eduard_Munteanu: No, I want to cross-compile to 32-bit Linux from 64-bit Mac.
13:54:49 <Eduard_Munteanu> osaunders: PPC or Intel?
13:54:53 <osaunders> Intel
13:55:09 <jrk_> lispy1: yeah, but i have no idea where i should look..
13:55:10 <bench1> roconnor: lazyST?
13:55:18 <Eduard_Munteanu> osaunders: I don't know specifics, but if you use the GCC backend it should be trivial to pass in -m32
13:55:24 <jrk_> lispy1: i mean.. there are hundreds of universities and faculties
13:55:25 <djahandarie> Utrecht is probably a fun place to go to school
13:55:27 <roconnor> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/Control-Monad-ST-Lazy.html
13:55:37 <lispy1> jrk_: In that case, look through the last 3 or say years of ICFP papers and the ones that are interesting to you, look up the authors.
13:55:37 <Eduard_Munteanu> osaunders: any 64bit GCC can generally output 32bit code.
13:56:06 <osaunders> Eduard_Munteanu: What about the Linux/Mac thing?
13:56:08 <djahandarie> lispy1, who says you need to be a professor to submit one of those? :P
13:56:08 <roconnor> bench1: in particular you will want to use the MonadFix instance
13:56:14 <lispy1> jrk_: Start with the interesting research, and trace back from that to the interesting authors.  I'm sure you'll find some in Europe
13:56:24 <djahandarie> Actually, most of the people who submit papers there aren't professors :P
13:56:25 <roconnor> bench1: but to make life easier you will probably one to use one of the recursive-do extensions
13:56:27 <knobo> Does there exist an haskell intensive course anywhere in the world?
13:56:34 <jrk_> lispy1: that's a good hint, thanks!
13:56:52 <ski> > let dip f = ZipList . f . getZipList; return = ZipList . repeat; as >>= f = join (fmap f as); join (ZipList []) = ZipList []; join (ZipList (ZipList (a:_):ass)) = (a :) `dip` join (ZipList (dip tail `map` ass)) in getZipList (ZipList [1 .. 3] >>= \x -> ZipList [1 .. x] >>= \y -> return (x,y))
13:56:53 <lambdabot>   [(1,1),(2,2),(3,3)]
13:56:55 <ski> > let dip f = ZipList . f . getZipList; return = ZipList . repeat; as >>= f = join (fmap f as); join (ZipList []) = ZipList []; join (ZipList (ZipList (a:_):ass)) = (a :) `dip` join (ZipList (dip tail `map` ass)) in getZipList (ZipList [0 ..] >>= \x -> ZipList (iterate (x *) 1) >>= \y -> return (x,y))
13:56:56 <lambdabot>   [(0,1),(1,1),(2,4),(3,27),(4,256),(5,3125),(6,46656),(7,823543),(8,16777216...
13:57:02 <lispy1> djahandarie: usually a professor will appear on papers.  But you're right that's it's not usually the first author
13:57:05 <bench1> roconnor: what do you mean monadFix instance?
13:57:06 <ski> FunctorSalad : ^
13:57:06 <Eduard_Munteanu> osaunders: I'm not sure what Mac uses, is it ELF-based?
13:57:16 <bench1> sorry, i'm newbie on monad
13:57:36 <bench1> i assume you meant that the function takes a matrix and a lazyST monad
13:57:38 <Eduard_Munteanu> osaunders: I suspect you could link to a Linux glibc.
13:57:46 <bench1> so that the sum is save with the lazyST
13:57:47 <roconnor> bench1: actually you may not need to use ST monad, depending on what you want to do
13:57:57 <roconnor> bench1: you can probably just use regular arrays
13:58:03 <FunctorSalad> ski: I don't see the connection to things I said :)
13:58:11 <jrk_> oh nice, the 2010 icfp was in leipzig
13:58:12 <roconnor> bench1: so forget about all that ST stuff (for now)
13:58:37 <roconnor> bench1: let me paste a snipit of code I used for the google code jam
13:58:42 <FunctorSalad> (I didn't actually have any sensible interpretation in mind for my parallel list comp, was just curious ;))
13:58:50 <ski> > getZipList . Data.Traversable.sequenceA $ map ZipList [[1..3], [4..6], [7..9]]  -- aristid's example
13:58:51 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
13:58:55 <bench1> roconnor: did you see the problems?  http://milo.com/images/MiloEngineeringProblem.pdf
13:58:57 <ski> monochrom : "generalized GADT fusion" ?
13:59:06 <roconnor> bench1: nope
13:59:12 * ziman has always used plain lazy arrays for dynamic programming, kind of memoizing recursion
13:59:16 <aristid> ski: yay
13:59:31 <bench1> w/o saving states, how did i know which pair/cell has been selected, etc
13:59:57 <roconnor> bench1: check out http://hpaste.org/41624/dynamic_programming_with_haske
14:00:15 <roconnor> bench1: notice how updates uses f to build up an array
14:00:31 <roconnor> bench1: however f uses the array build (named updates) in it's definition
14:00:40 <roconnor> that is the magic of haskell
14:00:42 <roconnor> ...
14:00:54 <ski> FunctorSalad : list comprehensions correspond to list monad. parallel list comprehensions sortof correspond to stream monad
14:00:58 <roconnor> for a simpler example (without arrays) check out http://r6.ca/blog/20081116T213644Z.html
14:01:41 <ski> FunctorSalad : your `[(x,y) | x <- [1..3] | y <- [1..x] ]' sortof corresponding to my `ZipList [1 .. 3] >>= \x -> ZipList [1 .. x] >>= \y -> return (x,y)'
14:02:01 <Eduard_Munteanu> osaunders: also, if that proves too difficult, don't despair, you can always use a Linux VM to do your final compilation.
14:02:13 <FunctorSalad> ski: hmm I thought ZipList was just an applicative :)
14:02:46 <ski> FunctorSalad : yeah, it's not really a monad, because `ZipList's can be finite (which causes the associative law to fail) .. but for infinite `Stream's it works
14:02:52 <FunctorSalad> > ZipList [1,2,3] >>= (\x -> ZipList [(x,'a'),(x,'b')])
14:02:53 <lambdabot>   No instance for (GHC.Base.Monad Control.Applicative.ZipList)
14:02:53 <lambdabot>    arising fro...
14:03:08 <jrk_> lispy1: i found a guy in freiburg.. i wanted to apply there already :)
14:03:24 <ski> FunctorSalad : note how i carefully didn't define `join (ZipList (ZipList []:ass)) = ...' there
14:03:33 <bench1> roconnor, 
14:03:50 <bench1> where is i, j defined?
14:03:59 <ski> (FunctorSalad : also, i mapped `tail')
14:04:38 <bench1> and (i',j') <- range r0 generates (0..r0, 0..r0) for both i and j?
14:04:39 <monochrom> http://www.haskell.org/haskellwiki/Dynamic_programming_example has yet another dynamic programming example using array (lazy) again.
14:04:50 <osaunders> Eduard_Munteanu: OK, thanks.
14:04:54 <ski> FunctorSalad : with infinite streams, all is fine. `Stream a' is iso to `Nat -> a', which is an environment monad
14:05:23 <roconnor> bench1: more or less.  r0 is a 2-d range.  It is define elsewhere and isn't included in the snippit
14:05:37 <FunctorSalad> ski: hmm reading one-line haskell is hard ;) what does bind (or join) do?
14:05:40 <roconnor> bench1: you can think of it as some range (0..n, 0..m) if you like
14:05:58 <Botje> bench1: rather range ((0,0),(r0,r0)) 
14:06:19 <roconnor> bench1: i and j are defined outisde this code
14:06:19 <bench1> come to think of it, my original problem may not be suitable for dynamic programming, because i can't reduce the assignment to its subproblems/subarrays
14:06:23 <ski> FunctorSalad : `join' takes the diagonal
14:06:43 <bench1> roconnor/monochrom, thx
14:06:49 <Eduard_Munteanu> Hah... http://www.apl.jhu.edu/~paulmac/c++-memoization.html
14:06:58 <roconnor> bench1: if it helps, r0 = ((i-v'+1,j-v'+1),(min m' (i+v'-1),min n' (j+v'-1))) is the definition of r0
14:07:02 <roconnor> but it doesn't really  help
14:07:03 <lispy1> jrk_: Excellent.  BTW, it's never too early to setup an interview with the potential professors.  Talk to some of their grad students, etc.  Just to make sure there are no big personality clashes, etc.
14:07:17 <roconnor> r0 has type ((Int,Int),(Int,Int))
14:07:36 <ski> > let join [] = ZipList []; join ((a:_):ass) = a : join (tail `map` ass) in join [[0],[1,2],[3,4,5],[6,7,8,9]]
14:07:37 <lambdabot>   Couldn't match expected type `[a]'
14:07:37 <lambdabot>         against inferred type `Control.A...
14:07:40 <ski> er
14:07:43 <ski> > let join [] = []; join ((a:_):ass) = a : join (tail `map` ass) in join [[0],[1,2],[3,4,5],[6,7,8,9]]
14:07:44 <lambdabot>   [0,2,5,9]
14:07:50 <roconnor> and ((a,b),(c,d)) represents the rectuagular range.
14:07:50 <ski> > let join [] = []; join ((a:_):ass) = a : join (tail `map` ass) in join [[0],[1],[3,4,5],[6,7,8,9]]
14:07:51 <lambdabot>   [0*Exception: <interactive>:1:173-230: Non-exhaustive patterns in function ...
14:08:16 <roconnor> bench1: maybe this isn't the best pedelogical code :(
14:08:27 <bench1> roconnor, i see, thank for the explanation
14:08:28 <roconnor> bench1: I just pulled it out because it is recent dynamic programming that I did.
14:08:52 <adimit> Hello kind people of #haskell. May I request some help with HXT-Arrows? I'm trying to left-factor my arrows, but it doesn't seem to work  the parse fails! I've made a brief ghci session script to illustrate the problem: http://hpaste.org/41625/trouble_with_hxt Does anybody know what I'm doing wrong?
14:08:56 <roconnor> the point is that you can fill the values of the array with a funciton f that depends on the finished values of the array.
14:08:58 <aristid> roconnor: yeah it uses too many partial functions unsafely to be pedagoical
14:09:04 <ski> FunctorSalad : the definition of `(>>=)' in terms of `fmap',`join' is the usual one. and i should have written `return = pure' instead of `return = ZipList . repeat' (it's the same)
14:09:47 <roconnor> aristid: it is hard to do anything with arrays without using partial functions.
14:10:28 <bench1> roconnor, all, so how do we solve this problem in haskell then? http://milo.com/images/MiloEngineeringProblem.pdf
14:10:30 <FunctorSalad> ski: [x i | i <- Nat ] >>= f = [ f (x i) !! i | i <- Nat]?
14:10:30 <aristid> roconnor: i don't see any arrays in your example
14:10:34 <jrk_> lispy1: i'll try to do that, thanks :)
14:10:44 <FunctorSalad> ah so it's the standard reader monad
14:10:48 <FunctorSalad> in that view
14:10:48 <roconnor> aristid: update is an array
14:10:51 <bench1> with java/procedural language, i can loop through (probably not the best solution)
14:10:55 <roconnor> *updates
14:11:03 <ski> FunctorSalad : yes
14:11:09 <aristid> roconnor: wait, i was looking at ski's code, sorry.
14:12:08 <ski> FunctorSalad : so in `[(x,y) | x <- [1..3] | y <- [1..x] ]', each `x' would generate a different list for `y', and `y' would be the element of that list at the same position as the corresponding `x' (so the most part of those lists are thrown away)
14:13:55 <FunctorSalad> ski: ah I get it now :)
14:14:23 <identity_> wasn't there a bot that would do that sequence database query thing?
14:14:25 <identity_> I can't remember it
14:14:29 <FunctorSalad> > map (uncurry id . join) [0..]
14:14:30 <lambdabot>   No instances for (GHC.Base.Monad ((,) (b -> c)),
14:14:31 <lambdabot>                    GHC.Enu...
14:14:46 <FunctorSalad> > map (join $ uncurry id ) [0..]
14:14:47 <lambdabot>   Occurs check: cannot construct the infinite type:
14:14:47 <lambdabot>    m = (->) (b -> m a, b)
14:15:03 <FunctorSalad> or something like this :(
14:15:23 <ski> FunctorSalad : the fact that finite lists (well, `ZipList's) screw the associative law is a bit unfortunate, though ..
14:15:51 <ski> identity_ : "sequence database query thing" ?
14:15:57 <identity_> ski: Hmm, oeis?
14:16:03 <identity_> Don't remember the name for it
14:16:18 <identity_> some four letter acronym
14:16:21 <identity_> @oeis 1, 2, 3
14:16:22 <lambdabot>  Sequence not found.
14:16:24 <identity_> ah
14:16:28 <identity_> Never mind :)
14:16:40 <FunctorSalad> > map (join $ curry id ) [0..]
14:16:41 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
14:17:32 <ski> > join (,) `map` [0 ..]
14:17:32 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
14:18:01 <FunctorSalad> :)
14:18:11 <FunctorSalad> curry vs uncurry id is very confusing
14:18:16 <djahandarie> > join (,) . [0..]
14:18:17 <lambdabot>   [(0,0),(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11...
14:18:58 * ski often does memoization by defining an `memo :: Ix i => (i,i) -> (i -> e) -> (i -> e)' operation
14:21:29 <maurer_> :t Data.MemoCombinators.integral
14:21:30 <lambdabot> forall a r. (Integral a) => (a -> r) -> a -> r
14:21:35 <maurer_> Bam.
14:23:41 <ski> > let (memo (0,12) -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n - 2) + fib (n - 1) in fib 12
14:23:43 <lambdabot>   144
14:23:50 <Dashkal> Question about what data construct I should use for a problem: I'm trying to map coordinates (x,y,z as integers) to things.  Map feels odd as there isn't a straightforward Ord instance for that key.
14:24:06 <ski> > let (Data.MemoCombinators.integral -> fib) = \n -> case n of 0 -> 0; 1 -> 1; n -> fib (n - 2) + fib (n - 1) in fib 12
14:24:07 <lambdabot>   Not in scope: `Data.MemoCombinators.integral'
14:24:15 <ski> bah !
14:24:19 <maurer_> :(
14:24:47 <Botje> @instances Ord
14:24:48 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
14:24:54 <Botje> Dashkal: looks like there is :P
14:25:11 <Dashkal> *blinks* How does ord handle (a,b,c)?  Nevermind, I can read the source on that one
14:25:22 <ski> Dashkal : lexicographic ordering
14:25:22 <Phyx-> @src Ord (a,b,c)
14:25:23 <lambdabot> Source not found. stty: unknown mode: doofus
14:25:33 <pkrumins> @instances Num
14:25:34 <lambdabot> Double, Float, Int, Integer
14:25:39 <monochrom> > (0,1,1) < (0,0,2)
14:25:40 <lambdabot>   False
14:25:40 <pkrumins> @instances Monad
14:25:41 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:25:43 <jmcarthur> > sort $ zip3 [1..3] [1..3] [1..3]
14:25:44 <lambdabot>   [(1,1,1),(2,2,2),(3,3,3)]
14:25:49 <jmcarthur> woops
14:25:57 <jmcarthur> > sort $ liftA3 (,) [1..3] [1..3] [1..3]
14:25:58 <lambdabot>   Couldn't match expected type `c -> a'
14:25:58 <lambdabot>         against inferred type `(a1, b)'
14:25:59 <ski> > sort (replicateM 3 [False,True])
14:26:00 <lambdabot>   [[False,False,False],[False,False,True],[False,True,False],[False,True,True...
14:26:07 <jmcarthur> > sort $ liftA3 (,,) [1..3] [1..3] [1..3]
14:26:08 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
14:26:08 <ski> > sort (replicateM 3 "ab")
14:26:09 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
14:26:16 <pkrumins> i havent yet understood how that works
14:26:23 <pkrumins> some crazy magic
14:26:26 <ski> which ?
14:26:34 <jmcarthur> > liftA3 (,,) [1..3] [1..3] [1..3]
14:26:35 <lambdabot>   [(1,1,1),(1,1,2),(1,1,3),(1,2,1),(1,2,2),(1,2,3),(1,3,1),(1,3,2),(1,3,3),(2...
14:26:39 <pkrumins> ski: the one you just did
14:26:42 <monochrom> there is no magic. just crazy.
14:26:46 <djahandarie> There isn't much magic in Haskell
14:26:49 <ski> @src replicateM
14:26:49 <lambdabot> replicateM n x = sequence (replicate n x)
14:26:53 <pkrumins> ski, generate all possible 3 chars from 2 chars
14:26:58 <Phyx-> there is no lambda, just bindings
14:27:00 <djahandarie> Once you understand typeclasses... you're pretty much able to understand everything
14:27:05 <ski> > sequence ["a","bc","def"]
14:27:06 <lambdabot>   ["abd","abe","abf","acd","ace","acf"]
14:27:07 <djahandarie> Except the more advanced type stuff
14:27:12 <Dashkal> ski: Ahh, thanks.  Didn't think in that direction.
14:27:15 <djahandarie> Which isn't being utilized here
14:27:20 <pkrumins> i understand typeclesses but not this stuff yet.
14:27:23 <ski> > sequence ["xy","ab"]
14:27:24 <lambdabot>   ["xa","xb","ya","yb"]
14:27:28 <ski> > sequence ["xy","xy"]
14:27:29 <lambdabot>   ["xx","xy","yx","yy"]
14:27:54 <pkrumins> sequence!
14:28:05 <ski> `sequence' in the list monad is more or less "cartesian product"
14:28:17 <pkrumins> oh yeah!
14:28:27 <ski> > sequence ["xy","ab","01"]
14:28:28 <lambdabot>   ["xa0","xa1","xb0","xb1","ya0","ya1","yb0","yb1"]
14:28:29 <djahandarie> pkrumins, just read the Monad instance for lists
14:28:35 <djahandarie> And the definition for sequence
14:28:43 <djahandarie> @src sequence
14:28:43 <lambdabot> sequence []     = return []
14:28:43 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
14:28:43 <lambdabot> --OR
14:28:43 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
14:28:44 <pkrumins> djahandarie: oh!
14:28:45 <pkrumins> okay
14:28:45 <Phyx-> :t a * a
14:28:46 <lambdabot> Expr
14:28:52 <Phyx-> > a * a
14:28:53 <lambdabot>   a * a
14:28:53 <pkrumins> @src replicateM
14:28:53 <lambdabot> replicateM n x = sequence (replicate n x)
14:28:56 <pkrumins> !
14:28:58 <pkrumins> so easy
14:29:01 <Phyx-> > a * a - x
14:29:02 <pkrumins> @src replicate
14:29:02 <lambdabot>   a * a - x
14:29:03 <ski> @src mapM
14:29:04 <lambdabot> replicate n x = take n (repeat x)
14:29:06 <lambdabot> mapM f as = sequence (map f as)
14:29:15 <pkrumins> hah
14:29:16 <pkrumins> i get it now
14:29:17 <ski> see the similarity between `replicateM' and `mapM'
14:29:25 <pkrumins> yeah
14:29:46 <pkrumins> holy cow this is awesome!
14:30:01 <monochrom> from crazy magic to holy cow
14:30:02 <ski> @type replicateM
14:30:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
14:30:28 * monochrom invents book title "from crazy magic to holy cow: the road to haskell"
14:30:32 <ski> (copy action `n' times, run it that many times, collecting the results)
14:30:41 <Phyx-> monochrom: that's not actually a bad title
14:30:51 <djahandarie> All that you need to do now is memorize a bunch of names for functions and you're a Haskell pro ;)
14:31:09 <Phyx-> djahandarie: and master the lambdabot!
14:31:12 <ski> djahandarie : and master CPS, of course
14:31:21 <pkrumins> djahandarie: haha yeah.
14:31:49 <Phyx-> what's the haskell knowledge scale look like anyway
14:31:56 <djahandarie> monochrom, is that about alice in wonderland or hinduism?
14:32:04 <djahandarie> The Haskell-brick road
14:32:19 <djahandarie> Now The Wizard of Oz too!
14:32:39 * monochrom invents more titles: "from holy cow to holy batman: the road to adga, a sequel to the road to haskell"
14:33:01 * monochrom keeps mixing up adga and agda
14:33:20 <dons> Phyx-: http://24.media.tumblr.com/tumblr_l96d7c1jh31qznepvo1_500.jpg 
14:34:01 <Phyx-> dons: hahaha, i remember that
14:34:44 <Phyx-> that's actually quite depressing
14:34:47 <Phyx-> what happens next atleast
14:35:28 <pkrumins> phd!
14:36:07 <pkrumins> pink zone is the safest
14:36:10 <monochrom> what? dons was inspired by that picture to go to phd?
14:36:43 <djahandarie> I don't understand this picture at all
14:36:47 <Saizan> i don't think that picture was around at the time
14:37:12 <djahandarie> I guess I'm just not enlightened
14:37:36 <Saizan> you probably haven't seen the blog post from which it's taken
14:37:47 <dankna> I don't get it either.  Explanation would be lovely.
14:38:47 <Saizan> http://matt.might.net/articles/phd-school-in-pictures/
14:39:01 <Phyx-> aww beat me to it
14:39:28 <djahandarie> Oh man
14:39:30 <Phyx-> it's amazing what google can find with "phd dot dent blog"
14:39:31 <djahandarie> That was a good blog post
14:39:33 <JoeyA> Is there a standard function for what is, in essence, a right fold with an accumulator?
14:39:43 <JoeyA> take would be an example of a function using it, for instance
14:39:47 <dankna> ahahahha
14:39:47 <dankna> nice
14:39:48 <Saizan> Phyx-: or phd circle knowledge :)
14:39:55 <Phyx-> heheh
14:39:59 <pkrumins> keep pushing
14:41:34 <FunctorSalad> is "Writer String" a bad idea for the same reason Show instances use String->String rather than String?
14:41:41 <kmc> yes
14:41:49 <kmc> Writer (Endo String) or Writer (DList Char)
14:41:50 <kmc> etc
14:41:51 <FunctorSalad> hmm no magic fusion to save you? ;)
14:42:14 <Phyx-> Endo?
14:42:24 <aristid> @src Endo
14:42:24 <lambdabot> Source not found. Take a stress pill and think things over.
14:42:29 <wisepumpkin> newtype Endo a = Endo (a -> a)
14:42:31 <wisepumpkin> iirc
14:42:31 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Monoid.html#t%3AEndo
14:42:46 <aristid> newtype Endo a = Endo {appEndo :: a -> a}
14:42:55 <Saizan> FunctorSalad: the magic fusion is called Codensity :)
14:43:01 <kmc> monoid with id and (.)
14:43:25 <aristid> :t [(.), flip (.)]
14:43:26 <lambdabot> forall b. [(b -> b) -> (b -> b) -> b -> b]
14:43:38 <aristid> kmc: would it also be a monoid with flip (.)?
14:43:48 <kmc> yeah, every monoid has a dual like that
14:43:58 <aristid> heh
14:43:59 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Monoid.html#t%3ADual
14:44:20 <FunctorSalad> Saizan: hmm isn't that (Char -> String) -> String?
14:44:30 <FunctorSalad> Codensity [] Char :)
14:44:38 <aristid> Dual (Endo a)
14:44:46 <Saizan> i meant Codensity (Writer String)
14:44:55 <kmc> clever :)
14:45:01 <FunctorSalad> ah, mine looked not so useful ;)
14:46:10 <FunctorSalad> hmm and I confused something anyway. Codensity [] a = C (forall r. (a -> [r]) -> [r]) no?
14:46:12 <Saizan> it takes care of reassociating everything to the right, and you also save useless uses of mempty
14:46:24 <Saizan> yep
14:46:56 <FunctorSalad> Codensity (Writer String) a = C (forall r. (a -> (String,r)) -> (String,r))
14:46:58 <FunctorSalad> hmm...
14:48:03 <onteria|i7> I'm working through the learn you a haskell series, and I made this simple substr function as a sort of practice experiment: 'substr start len string = take len (drop start string)'. I'm just starting out so I'm wondering if there's a better way to achieve this.
14:48:30 <Botje> that's pretty much how i'd write it
14:48:42 <Botje> well, maybe "substr start len = take len . drop start"
14:48:58 <Botje> but yours is equally good
14:49:03 <monochrom> it's good
14:50:53 <Tutor1> @pl uf2 x = (sum . (filter (\y -> (y `mod` x) == 0)))
14:50:53 <lambdabot> uf2 = (sum .) . filter . flip flip 0 . ((==) .) . flip mod
14:50:58 <onteria|i7> Thanks for the responses. I'll get through this yet!
14:51:03 <pkrumins> what does @pl do?
14:51:33 <djahandarie> @pl (\x -> f x)
14:51:34 <lambdabot> f
14:51:35 <kmc> converts code to "pointless" aka points-free style
14:51:36 <dankna> translates Haskell to Perl :)
14:51:37 <kmc> @help pl
14:51:37 <lambdabot> pointless <expr>. Play with pointfree code.
14:51:46 <kmc> meaning that function arguments are eliminated
14:51:55 <pkrumins> oic
14:52:02 <pkrumins> is it always possible?
14:52:13 <kmc> @pl let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
14:52:13 <lambdabot> fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
14:52:31 <djahandarie> Yes, but sometimes it's ugly
14:52:42 <djahandarie> And the script in lambdabot is crude and makes mistakes sometimes
14:52:53 <pkrumins> mistakes!
14:52:58 <kmc> pkrumins, yeah.  it's always possible.  http://en.wikipedia.org/wiki/SKI_combinator_calculus
14:53:29 <pkrumins> i have yet to study that
14:53:41 <Phyx-> @unpl f
14:53:41 <lambdabot> f
14:53:41 * ski peers around curiously
14:53:51 <Phyx-> @unpl f . g
14:53:51 <lambdabot> (\ c -> f (g c))
14:53:53 <kmc> @unpl \x y -> y+x
14:53:53 <lambdabot> \ x y -> y + x
14:53:57 <kmc> @pl \x y -> y+x
14:53:57 <lambdabot> (+)
14:54:03 <kmc> @unpl flip (+)
14:54:03 <lambdabot> (\ b c -> c + b)
14:54:12 <kmc> pl assumes (+) is commutative?
14:54:14 <kmc> @pl \x y -> y/x
14:54:14 <lambdabot> flip (/)
14:54:20 <djahandarie> One of the many problems
14:54:43 <Phyx-> @unpl ($) (.)
14:54:44 <lambdabot> (\ b d e -> b (d e))
14:55:03 <mauke> pkrumins: it's not always possible
14:55:13 <Phyx-> @unpl (($).)
14:55:13 <lambdabot> (\ c f b -> c f b)
14:55:19 <mauke> pattern matching is irreducible
14:55:21 <Phyx-> lol
14:55:36 <djahandarie> Ah, true
14:55:39 <Phyx-> :t (($).)
14:55:40 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> f (a -> b)
14:55:59 <mauke> Phyx-: "compose id"
14:56:46 <Phyx-> mauke: hm? I don't get that
14:57:32 <mauke> (($).) is "compose id", which is a no-op
14:57:47 <wisepumpkin> it does constrain the type slightlu
14:57:50 <mauke> hence \c f b -> c f b
14:57:57 <Phyx-> ah
14:58:41 <thoughtpolice> wisepumpkin? what happened to the copumpkin? arrows reversed and then he got old?
14:58:47 <wisepumpkin> yeah
14:58:50 <ski> JoeyA : elaborate on "right fold with an accumulator" ?
14:58:56 <litb> > [x | x <- 1..10 ]
14:58:57 <lambdabot>   <no location info>: parse error on input `..'
14:59:22 <Phyx-> next he'll turn into beardedpumpkin
14:59:26 <litb> hmm
14:59:39 <ski> > [x | x <- [1..10] ]
14:59:40 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:59:59 <ski> > [x | x <- enumFromTo 1 10 ]
15:00:00 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
15:00:04 <mauke> > [x | [1..10]]
15:00:05 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
15:00:05 <lambdabot>         against inferred type ...
15:00:13 <mauke> > [x | y <- [1..10]]
15:00:14 <lambdabot>   [x,x,x,x,x,x,x,x,x,x]
15:01:02 <litb> what would [0..10][0..10] mean ?
15:01:02 <Phyx-> "evaluated-ness" is a word?
15:01:33 <mauke> litb: call [0..10] with an argument of [0..10]
15:01:40 <kmc> litb, it would mean "apply the function [0..10] to the argument [0..10]"
15:01:41 <litb> oh
15:01:53 <kmc> which doesn't make sense, because [0..10] is a list
15:02:10 <ski> > foldr (\x take_xs n -> if n <= 0 then [] else x : take_xs (n-1)) (\_ -> []) "abcdefg" 3
15:02:11 <lambdabot>   "abc"
15:02:16 <ski> JoeyA : like that ^ ?
15:02:20 <thoughtpolice> wisepumpkin: anything interesting lately?
15:02:23 <ski> @src take
15:02:23 <lambdabot> take n _      | n <= 0 =  []
15:02:23 <lambdabot> take _ []              =  []
15:02:23 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
15:02:40 <litb> i hoped it would create 00, 01, 02, ..., 09, 10, 11, 12, ..., 91, 92, ..., 99
15:03:02 <ski> > liftM2 (,) [0..10] [0..10]
15:03:02 <wisepumpkin> thoughtpolice: hmm, not much
15:03:03 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5),(0,6),(0,7),(0,8),(0,9),(0,10),(1,0),(...
15:03:12 <litb> oh
15:03:19 <mauke> > replicateM 2 [0..9]
15:03:20 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[1,0],[1,1],[1...
15:03:27 <ski> > liftM2 (\a b -> 10 * a + b) [0..9] [0..9]
15:03:28 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:03:42 <mauke> > replicateM 2 ['0'..'9']
15:03:43 <lambdabot>   ["00","01","02","03","04","05","06","07","08","09","10","11","12","13","14"...
15:03:43 <ski> > liftM2 (\a b -> [a,b]) [0..9] [0..9]
15:03:44 <lambdabot>   [[0,0],[0,1],[0,2],[0,3],[0,4],[0,5],[0,6],[0,7],[0,8],[0,9],[1,0],[1,1],[1...
15:03:52 <litb> lol
15:04:03 <Phyx-> :t join id
15:04:04 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
15:04:04 <lambdabot>     Probable cause: `id' is applied to too few arguments
15:04:04 <lambdabot>     In the first argument of `join', namely `id'
15:04:09 <Phyx-> :t join return
15:04:09 <lambdabot> forall a. a -> a
15:04:12 <Phyx-> lol
15:04:14 <litb> you guys and your list monads xD
15:04:24 <Phyx-> :t join forM
15:04:25 <lambdabot>     Couldn't match expected type `[a]' against inferred type `a -> m b'
15:04:25 <lambdabot>       Expected type: [a] -> [a] -> a1
15:04:25 <lambdabot>       Inferred type: [a] -> (a -> m b) -> m [b]
15:04:34 <Phyx-> don't mind me
15:04:39 <Phyx-> i'm just typing random stuff
15:04:44 <Phyx-> without thinking
15:06:29 <JoeyA> "ski> JoeyA : like that ^ ?" clever
15:06:48 <litb> replicateM seems to do   a <- list, b <- list, return [a, b]  ?
15:07:01 <aristid> @src replicateM
15:07:01 <lambdabot> replicateM n x = sequence (replicate n x)
15:07:38 <Philippa> Eduard_Munteanu: you wanted to know about ANF
15:07:45 <Eduard_Munteanu> Philippa: yes.
15:07:56 <Philippa> so, start with a lambda calculus, add "simple" let bindings (I'll ignore recursion for now)
15:08:04 <mauke> litb: yes
15:08:14 <litb> mauke: ohh i were just guessing
15:08:27 <Philippa> now, divide syntax up into 'terms' and 'values'. A lambda is a value, a variable is a value, a constant or literal is a value
15:08:39 <Philippa> a function application is a term, a let is a term
15:08:43 <mauke> > sequence ["ABC", "01", "xy"]
15:08:44 <lambdabot>   ["A0x","A0y","A1x","A1y","B0x","B0y","B1x","B1y","C0x","C0y","C1x","C1y"]
15:08:53 <Philippa> now, limit function applications so that parameters have to be values
15:09:33 <thoughtpolice> wisepumpkin: I think my evil plan i've worked on the past couple of days may work but I have yet to get the prototype fully working
15:09:43 <wisepumpkin> thoughtpolice: what is it?
15:09:50 <Philippa> you now have code that looks like: let temp1 = (+) 1 2 in let temp2 = (+) 3 4 in (*) temp1 temp2
15:09:52 <Eduard_Munteanu> Philippa: yes.
15:09:58 <thoughtpolice> wisepumpkin: I'm trying to recreate threadscope, but using canvas/html5
15:10:02 <wisepumpkin> :o
15:10:03 <wisepumpkin> oh nice
15:10:05 <ski> litb : `sequence [as0,as1,...] = do a0 <- as0; a1 <- as1; ...; return [a0,a1,...]', yes
15:10:15 <litb> ohh!
15:10:21 <wisepumpkin> thoughtpolice: blaze html!
15:10:37 <Philippa> compare and contrast with do temp1 <- (+) 1 2; temp2 <- (+) 3 4; (*) temp1 temp2
15:10:38 <thoughtpolice> wisepumpkin: and I have found an evil trick that will, I think, actually let me stream live eventlog data into a websocket so the browser can display it in real-time
15:10:54 <Philippa> (assume for a moment that it typechecks)
15:11:02 <Eduard_Munteanu> Philippa: wait, Haskell's <- ?
15:11:04 <thoughtpolice> i had to completely rewrite ghc-events using attoparsec and attoparsec-enumerator, but it's very close to working now
15:11:07 <litb> i think that is the  (->)  monad
15:11:07 <ski> Eduard_Munteanu : yes
15:11:26 <ski> litb : what is ?
15:11:33 <Eduard_Munteanu> Oh, ok, everything's all right, except they're not monadic values.
15:11:35 <litb> oh wait i#m talkin nonsense
15:12:07 <Philippa> Eduard_Munteanu: assume they are :-)
15:12:13 <thoughtpolice> wisepumpkin: and that evil trick is 'place a FIFO where GHC thinks it will dump the eventlog file', and viola! you can read off the fifo and get data as it comes in
15:12:16 <litb> yes that was confusing me :)
15:12:24 * ski wonders how to get composable composable continuations, so as to be able to do an ANF-transformation, sanely ..
15:12:27 <thoughtpolice> attoparsec also seems to be doing pretty fast but I still have to work out the bugs to make it parse a full eventlog file
15:12:45 <Eduard_Munteanu> Ok. :)
15:13:00 <thoughtpolice> i'm actually really surprised that trick worked too, no GHC hacks necessary
15:13:13 <DerisionSnort> @pl (\x y -> x:[y])
15:13:13 <lambdabot> (line 1, column 15):
15:13:13 <lambdabot> unexpected "\173"
15:13:13 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or ")"
15:13:23 <DerisionSnort> @pl \x y -> x:[y]
15:13:23 <lambdabot> (line 1, column 14):
15:13:23 <lambdabot> unexpected "\173"
15:13:24 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>" or end of input
15:13:34 <thoughtpolice> although apparently the eventlogging infrastructure falls on its face once you start fwrite'ing past the limits of a 32bit integer (which can happen damn fast because threadscope evenlogs are massive)
15:13:42 <Phyx-> what's that trailing 
15:13:45 <Phyx-> what's that trailing "-"
15:13:51 <Philippa> Eduard_Munteanu: monads correspond to higher-order ANF languages :-) >>= is let
15:13:57 <thoughtpolice> i think 1.9s runtime -> 30mb of data, which is pretty intense
15:14:11 <DerisionSnort> @pl \x y -> x:[y]
15:14:11 <lambdabot> (. return) . (:)
15:14:31 <DerisionSnort> @pl \x y z -> x:y:[z]
15:14:31 <lambdabot> (. ((. return) . (:))) . (.) . (:)
15:14:35 <DerisionSnort> bah
15:14:35 <Eduard_Munteanu> Philippa: oh
15:14:36 <DerisionSnort> terrible
15:15:09 <joe6> yes
15:15:47 <litb> it's all ellipsis
15:15:48 <Eduard_Munteanu> Philippa: you basically made up a meta-language in which just about everything from the original language is a value, then redefined application and added lets?
15:15:56 <Philippa> Eduard_Munteanu: bingo
15:16:01 <Eduard_Munteanu> Nice.
15:16:15 <Eduard_Munteanu> Philippa: what did 'A' stand for again?
15:16:23 <Philippa> and this is one of the "monads are..." analogies that I think /is/ useful and relevant
15:16:25 <litb> (. return) . (:)   don't understand this
15:16:34 <Philippa> "Administrative", but most people just leave it at A these days
15:16:38 <wisepumpkin> thoughtpolice: yeah
15:16:45 <mauke> litb: why not?
15:16:46 <wisepumpkin> thoughtpolice: that kind of stuff makes me feel icky though :P
15:16:46 <aristid> :t (Prelude.. return) Prelude.. (:)
15:16:47 <lambdabot> forall a. a -> a -> [a]
15:16:52 <Eduard_Munteanu> Philippa: if you think about it that way, yeah, it makes sense.
15:16:56 <Eduard_Munteanu> Philippa: thanks.
15:17:02 <wisepumpkin> thoughtpolice: APIs should avoid assuming file IO always
15:17:09 <aristid> :t (Prelude.. return)
15:17:10 <lambdabot> forall c a (m :: * -> *). (Monad m) => (m a -> c) -> a -> c
15:17:10 <wisepumpkin> thin wrappers that put file IO in are okay
15:17:19 <ski> Philippa : oh, right, that was what i was going to ask you about .. you said ANF is like CPS but with administrative redices removed
15:17:21 <litb> (:)   alone would require "y" to be a list
15:17:32 <aristid> :t (Prelude.. return) :: ([a] -> b) -> a -> b
15:17:33 <lambdabot> forall a b. ([a] -> b) -> a -> b
15:18:00 <aristid> :t \f x -> f [x]
15:18:00 <lambdabot> forall t t1. ([t] -> t1) -> t -> t1
15:18:22 <DerisionSnort> @litb: Johannes?
15:18:22 <lambdabot> Unknown command, try @list
15:18:33 <DerisionSnort> @list
15:18:33 <litb> DerisionSnort: ohh you are right
15:18:33 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:18:35 <Pseudonym> As a matter of curiosity, does anyone know anything about the lazy version of the CPS transformation?
15:18:54 <mauke> (. return) . (:) === \x -> (. return) ((:) x) === \x -> (x :) . return
15:19:03 <DerisionSnort> FredOverflow here :) How do I address people here? @ doesnt seem to work
15:19:04 <sipa> :t (===)
15:19:04 <ski> Philippa : i assume you must be talking about something else than "administrative redices" as in "Representing Control: A Study of the CPS Transformation" at <http://www.diku.dk/hjemmesider/ansatte/andrzej/papers/RC.ps.gz> by Andrzej Filinski in 1992-12 ?
15:19:05 <lambdabot> forall a b. (Typeable a, Typeable b, Eq b) => a -> b -> Bool
15:19:14 <mauke> DerisionSnort: uh, you use their name
15:19:16 <Philippa> ski: no, ANF is the direct-style equivalent of CPSed code that's had the administrative redices removed. The "direct-style" bit is important
15:19:17 <litb> DerisionSnort: just do    "nick: foo"
15:19:34 <DerisionSnort> litb: lol, very terse syntax
15:19:50 <ski> Philippa : ok. still "administative" in the sense of that paper, or in another sense ?
15:19:50 <Eduard_Munteanu> DerisionSnort: use tab-completion
15:19:54 <litb> you're teh IRC n00b?
15:19:59 <Philippa> in the same sense, I think
15:20:08 <Philippa> (not directly checking, but it's standard terminology)
15:20:09 <DerisionSnort> litb: haven't used irc in a looooong time
15:20:21 <Philippa> certainly in the sense that's standard when talking about CPS
15:21:04 <litb> so  foo . (:)    says that  if you give it an argument, it will push a  ([t] -> [t])  to  "foo", correct?
15:21:25 <mauke> :t ?foo . (:)
15:21:26 <lambdabot> forall b a. (?foo::([a] -> [a]) -> b) => a -> b
15:21:27 <ski> Philippa : (thinking a little ..) ok, i can see how that could make sense, now that i added the "direct-style" bit :)
15:21:33 <litb> since   (:) applied to one arguiment yields a  [t] -> [t]
15:22:19 <ski> litb : yes
15:22:24 <litb> oh
15:22:42 <Philippa> ski: that's actually how ANF was discovered, specifically that question
15:22:47 <ski> @type undefines `asTypeIn` \foo -> foo . (:)
15:22:48 <lambdabot> Not in scope: `undefines'
15:22:52 <ski> @type undefined `asTypeIn` \foo -> foo . (:)
15:22:52 <lambdabot> forall b a. ([a] -> [a]) -> b
15:23:10 <ski> Philippa : ok, i wasn't sure of the "etymology" of it
15:23:14 <litb> never seen this syntax: (?foo::([a] -> [a]) -> b) => a -> b
15:23:35 <ski> litb : that's implicit parameters, an extension in GHC
15:24:21 <litb> it says:   "be ?foo a ([a] -> [a]) -> b, then   ?foo . (:)   is  of type  a -> b"    why is that not wrong?
15:24:23 <ski> litb : my `asTypeIn' is maybe slightly more clunky to use, but may be simpler to interpret if you don't know that extension
15:25:02 <mauke> litb: why would it be wrong?
15:25:13 <ski> litb : it still waits for an `a' input to pass to `(:)'; after it has gotten that, it will return the same as `?foo' returns
15:25:47 <mauke> :t show (2 + ?f 3)
15:25:48 <lambdabot> forall t t1. (Num t, ?f::t1 -> t, Num t1) => String
15:27:00 <revenantphx> aadsffafdasdafdasdasdasdasdsad
15:27:12 <revenantphx> So, it turns out my broken simulation, which I spend a week debugging.
15:27:15 <revenantphx> ISN'T ACTUALLY BROKEN.
15:27:40 <revenantphx> my pheromone decay was too strong, so a competitive environment didn't exist...
15:27:41 <revenantphx> pooh.
15:28:11 <litb> mauke: because ?foo .  (:)   when it takes an a   it first yields an  ([a] -> [a]) -> b  i thought -.-
15:28:18 <ddarius> revenantphx: Now you've learned something about the scientific method.  When scientists get results they don't expect, they change the model to get the results they want.
15:28:30 <litb> dammit i must be missing something xD
15:28:30 <revenantphx> haha, I know that.
15:28:34 <revenantphx> The model was fine.
15:28:41 <revenantphx> The parameters were just bad.
15:29:06 <revenantphx> Theres some pitchfork bifurcation here (I'm learning this stuff as I go), and I was just too far towards the  part
15:29:18 <revenantphx> decrease the decay, and it works perfectly.
15:29:23 <mauke> litb: no, that's the type of ?foo
15:29:26 <mauke> litb: it doesn't yield ?foo
15:30:14 <ski> Philippa : i was wanting to do something like `translate expr = genSym $ \x -> shift $ \c -> makeLet x (trans expr) (c x); trans (App e e0) = liftM2 App (translate e) (translate e0); ...'
15:31:42 <ski> Philippa : so that translating `(a b) (c d)' i would get something like `let ab = a b; cd = c d in let abcd = ab cd in abcd' instead of the linearly nested pain i actually get :/
15:32:19 <litb> mauke: ohh wait now i see
15:32:46 <Philippa> ski: ah, not good in a strict setting. Sorta irrelevant in a lazy one
15:33:05 <ski> why not good ?
15:33:34 <ski> i want to keep from over-sequentializing the non-ordering of subexpressions in applications
15:33:44 <thartman> how can one coun the number of times string a matches string b?
15:34:08 <thartman> I guess you could get all substrings, but that would be o n squared right?
15:34:24 * ski wonders what "string a matches string b" means
15:34:43 <thartman> matches "blee" "blah blee bloo blee" would return 2
15:35:04 <proq> > "foo" == "foo"
15:35:04 <lambdabot>   True
15:35:10 <ski> how about matching `"apa"' with `"apapa"' ?
15:35:10 <litb> but ?foo  has to be programmed to accept a  ([a] -> [a]) -> b
15:35:22 <proq> > "apa" "apapa"
15:35:23 <lambdabot>   Couldn't match expected type `t1 -> t'
15:35:23 <lambdabot>         against inferred type `[GHC....
15:35:30 <proq> > "apa" == "apapa"
15:35:31 <lambdabot>   False
15:36:00 <thartman> non-overlapping matches. i see your point...
15:36:05 <Philippa> ski: in a strict setting you lose potential parallelism, in a non-strict setting it's just a syntactic PITA
15:36:25 <Philippa> (subject to the semantics of your "multiple let" statements)
15:36:31 <thartman> seems like there should be some util library to cover this but I'm not finding it
15:36:35 <thartman> could use regex I supose
15:36:44 <ski> thartman : look up Knuth-Morris-Pratt and/or Boyer-Moore algorithms ?
15:37:36 <thartman> bingo, kmp on hackage, stringsearch on hackage... probably useful stuff there.
15:37:45 <ski> Philippa : why would i lose potential parallelism by doing `let ab = a b; cd = c d in let abcd = ab cd in abcd' rather than `let ab = a b in let cd = c d in let abcd = ab cd in abcd' ?
15:37:55 <ddarius> @google gwern
15:37:55 <lambdabot> http://en.wikipedia.org/wiki/Gwern
15:37:55 <lambdabot> Title: Gwern - Wikipedia, the free encyclopedia
15:39:18 <monochrom> http://hackage.haskell.org/package/stringsearch has many string search algorithms
15:39:47 <hpc> ski: i don't see how either of those would compile differently
15:40:01 <Philippa> ski: see the "subject to" statement. The former doesn't have to be semantically identical to the latter, and you can have a semantics whereby multi-let is "parallel let" - the bindings don't see predecessors and can thus be evaluated in parallel
15:40:36 <litb> :t return
15:40:37 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:41:59 * ddarius has, he is pretty confident, figured out the solution to two of @google's failings.
15:42:10 <ben> I am trying to use TH to generate instances for types by name. It is the first time I am trying to use TH. I want to have [d| instance Foo $name where ... |], how do I get from a string to the right thing for name?
15:42:12 <ski> hpc : we're talking about a strict language here
15:42:37 <hpc> ski: oh :D
15:42:52 <litb> so it passes the  ([a] -> [a])  that is returned by   (:) to  return, which will return a   m ([a] -> [a])  . how does it know what type m is?
15:43:57 <litb> i mean, with (. return) . (:)
15:44:20 <ski> Philippa : i'm assuming none of `ab' and `cd' occurs in `a',`b',`c',`d', naturally
15:44:22 <aavogt> ben: mkName, but maybe you get the Type with ''TypeName
15:44:54 <aavogt> ben: I'm not sure you can use that syntax; you might have to use the   instanceD   function instead
15:45:22 <Philippa> ski: sure. If you're happy to do that level of inspection to spot it, fair enough
15:45:52 <ski> Philippa : well, that property holds, by construction, since i'm generating fresh `ab' and 'cd'
15:46:15 <ben> aavogt: It seems to want a Q Type, not a plain name
15:46:46 <Saizan> $(varT $ mkName name) ?
15:47:06 <Saizan> or conT ?
15:47:18 <Saizan> i'm wildly guessing :)
15:47:27 <Philippa> ski: sure. I'm just saying that if your lets work this particular way, you don't even need to check it
15:47:30 <ski> Philippa : i still don't see how `let ..; .. in ..' could be worse wrt parallelism than `let .. in let .. in ..'
15:47:34 <ben> Huh. Does that mean the Q is optional?
15:47:44 <Philippa> oh, I meant the other way round
15:47:52 <aavogt> the Q is required
15:47:55 <Philippa> the latter is the bad, serialised one
15:47:59 <ben> Saizan: That makes the compiler say "Illegal instance declaration for `Foo t_t'
15:48:02 <ski> Philippa : ah, that explains most of the confusion, then :)
15:48:13 <ben> Oh, conT /= ConT
15:48:14 <aavogt> ben: but we don't know if you have a constructor or type variable there
15:48:38 <ben> It is supposed to be a dumb algebraic type
15:48:56 <ben> data Bar = Bar String Int or something of the sort
15:49:08 <ski> Philippa : ok. so i want to generate such `let's, but i want to be able to "back up and push in a `let' (or a new clause in it)" when i'm spotting a complex sub-expression .. hence i'm trying to use composable continuations with `shift'
15:49:09 <aavogt> are you generating those Strings containing Bar automagically?
15:49:33 <aavogt> if the user writes Bar, it's better to ask for a   ''Bar
15:49:35 <ski> Philippa : but that sequentializes everything, of course .. so i'm wondering if i can somehow remedy this
15:49:48 <ben> Actually the user says "Bar" and ["String", "Int"] right now
15:49:59 <ben> and I put it together into a data declaration myself, and then try to make some instances for that
15:50:39 <Philippa> ski: Dunno. I've no idea what the standard approach to parallelism in CPS is: seems to me that CPS is "all about" forcing evaluation order regardless of the meta-language's
15:50:48 <ski> Philippa : anyway .. i'm not really expecting you to have an answer, just lifting the question, since you mentioned ANF
15:51:19 <ben> I have no clue whether that is a good plan of action.
15:51:24 <Philippa> ski: maybe you can do something with an analogue of par, or some other combinator expressing it
15:51:41 <ski> Philippa : yeah .. still this translation seems to want "something" like `shift' (i suppose similarly to how the CPS-transformation can be written very nicely using `shift')
15:52:05 <Saizan> ben: it makes more sense to ask for a Name from the user
15:52:35 <Saizan> ben: which can be provided with the '' notation to get the name corresponding to a type constructor
15:52:55 <ski> Philippa : i'm traversing the expression from outside to in, when i reach each complex subexpression on the path, i want to reach out outside the `let' corresponding to the parent level complex expression, and create (or merge with an existing) `let' at that level
15:53:06 <aavogt> but if you're writing the data type, String is probably your only option
15:53:17 <Philippa> ski: tbh, getting out of my current depth. I'm out of practice these days :-)
15:53:26 <ben> I am trying to say data $name = $name so I have a value constructor too :3
15:53:29 <litb> > ((. return) . (:)) 1 2
15:53:30 <monochrom> gueux: I have isolated the cause. A bug in GHC 6.12.1. (I haven't checked 6.12.3.) You see the hex strings following the package names and versions? for example xmonad-contrib-0.9.1-16a4fe3d427a319d7ad3405c264f50f4. The bug is: preference is given to the bigger hex string. package xmonad-contrib-0.9.1-16a4fe3d427a319d7ad3405c264f50f4 is shadowed by package xmonad-contrib-0.9.1-4570c2899a5e9e70faf5054ed78d5702 because 4570c2899a
15:53:30 <monochrom> 5e9e70faf5054ed78d5702 is bigger.  This hex string is a hash value of the ABI, you can't really choose one yourself, it's derived from compiled code.
15:53:31 <lambdabot>   [1,2]
15:53:35 <litb> oO
15:53:46 <ben> except with a bit more elaborate syntx
15:54:03 <litb> ah *now* i see how this works
15:54:03 <mauke> monochrom: hahaha
15:54:07 <ben> DataD [] name [] [NormalC name (map ((,) NotStrict . ConT . mkName) fields)] [mkName "Read", mkName "Show"]
15:54:11 <ski> Philippa : np :) i'm just feeling a bit frustrated since it "feels" like the problem wants something like `shift', but i haven't been able to figure out a way to make it work
15:54:14 <ben> It seems to typecheck... ;)
15:54:18 <Saizan> ben: ah, for that you need String, because it wouldn't be defined yet
15:55:06 <ben> Maybe I should post some code...
15:55:20 <ski> Philippa : i could probably do something like keeping a list of lists of clauses for the `let's, and modifying that, generating the `let's finally .. but it seems very ad hoc and ugly
15:55:48 <Philippa> ski: heh. I suspect the answer may have deep consequences
15:56:32 <litb> if it type checks then it's to 97 % correct
15:56:48 <mauke> > fix error
15:56:48 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
15:57:04 <litb> the other 3 percent is premature pessimization
15:57:22 <ski> Philippa : could be :) .. someone mentioned an ANF-translator exercise in #scheme some months ago, and i started to write a solution for myself, thinking it would be easy .. except it wasn't, at least if i also wanted it to be pretty and "modular" in the right sense of the word
15:57:27 <ddarius> :t maybe
15:57:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:57:36 <ben> http://hpaste.org/41628/i_dont_know_th <- It complains about the quoted instance declarations in lines 18 and 21, Illegal instance declaration for `AnyPacket t_t', (All instance types must be of the form (T a1 ... an) ...)
15:57:54 <Philippa> ski: heh
15:57:56 <hpc> :t fromMaybe
15:57:57 <lambdabot> forall a. a -> Maybe a -> a
15:58:06 <monochrom> gueux: I have found that 6.12.3 has corrected it. local packages shadow global packages correctly.
15:58:09 <aavogt> ben: just add the extensions ghc wants
15:58:24 <aavogt> ben: also load with -ddump-splices helps immensely
15:59:20 <ben> aavogt: I am pretty sure I did not need FlexibleInstances when I was doing this without TH
15:59:22 <ski> Philippa : anyway, ty for bearing with me blathering about it :)
15:59:37 <ddarius> @. hoogle type flip maybe
15:59:38 <lambdabot> Parse error:
15:59:38 <lambdabot>   --count=20 "forall b a. (a -> b) -> b -> Maybe a -> b
15:59:38 <lambdabot> "
15:59:55 <litb> it appears from its type that   maybe a b c   means: if c is Nothing, then eval to a, otherwise eval to  b >>= c
16:00:06 <kmc> :t maybe
16:00:07 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
16:00:22 <kmc> @src maybe
16:00:22 <lambdabot> maybe n _ Nothing  = n
16:00:22 <lambdabot> maybe _ f (Just x) = f x
16:00:22 <litb> or wait. not quite -.-
16:00:31 <aavogt> ben: then you're not doing the same thing with TH, which probably means it's wrong
16:00:39 <ben> Yeah :V
16:00:48 <aavogt> check how your generated data types look when you load the file with -ddump-splices
16:00:56 <kmc> ben, TH can be silly about type-checking decl splices
16:01:02 <kmc> i've had to turn on FlexibleInstances for this very reason
16:01:07 <kmc> even though the generated instance was H98
16:01:09 <hpc> @src fromMaybe
16:01:09 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
16:01:12 <ben> Right
16:02:48 <litb> can haskell prove itself?
16:02:57 <monochrom> can you prove yourself?
16:03:09 <wisepumpkin> litb: {-# LANGUAGE Presburger #-}
16:03:14 <hpc> haha
16:03:20 <monochrom> but yes, haskell can prove itself, just needs some programming.
16:03:29 <thoughtpolice> wisepumpkin: ideally yes, dependence on fifo creation is icky, but I don't want to hack GHC at the moment to have another means of getting the eventlog data :)
16:03:41 <thoughtpolice> it would be nice to have something you didn't need a special build of GHC for, IMO
16:03:48 <kmc> litb, Haskell is not a very good language for writing proofs, since the logic of its type system is unsound
16:03:58 <Saizan> oh, it's whining about that extension when typechecking the code of the quote ?
16:04:05 <kmc> better to program in Coq and extract Haskell code
16:04:11 <kmc> or program in Agda and call out to Haskell
16:05:20 <litb> kmc: why isn'T it fixed to be sound
16:05:20 <djahandarie> How's your Coq going kmc?
16:05:28 <litb> perv xD
16:05:38 <monochrom> I think my little discovery above has just nailed a large class of past unresolved cabal/ghc package problems reported here.
16:05:47 <wisepumpkin> litb: soundness and turing-completeness are at odds with one another
16:05:50 <ddarius> God lambdabot's code is crappy.
16:05:58 <litb> wisepumpkin: oh
16:06:04 <djahandarie> monochrom, good find
16:06:29 <djahandarie> ddarius, write a nicer bot ;)
16:06:37 <kmc> litb, because that would imply that you can't write arbitrary recursive programs
16:06:39 <thoughtpolice> ddarius: not surprising, lambdabot's pretty damn crufty at this point
16:06:47 <djahandarie> kmc, that was a serious question by the way :P
16:06:52 <kmc> litb, in Coq and Agda you can only write recursive functions if you prove they terminate
16:06:56 <kmc> djahandarie, i haven't done any coq recently
16:07:01 <kmc> i finished bcpierce et al's book though
16:07:17 <djahandarie> God who the hell named this language
16:07:19 <ben> man template haskell is pretty dumb
16:07:22 <kmc> the french
16:07:28 <kmc> yes ben
16:07:50 <kmc> litb, if you have general recursion then you can write the fixed point combinator fix :: (a  a)  a
16:07:57 <djahandarie> ben, I've primarily avoided it so far
16:07:58 <kmc> whose type is equivalent to the proposition "(A implies A) implies A"
16:08:04 <thoughtpolice> it's a pun on the calculus of constructions (CoC) and coq also means something in french ('rooster' i think)
16:08:06 <litb> kmc: i see
16:08:09 <kmc> and a logical system with that axiom is completly unsound, you can prove anything
16:08:14 <wisepumpkin> le agda sportif
16:08:17 <kmc> :t fix id
16:08:18 <lambdabot> forall a. a
16:08:26 <ben> djahandarie: Me too. I just hoped I could reduce a few dozen lines of dumb boilerplate by making haskell generate it.
16:08:28 <Saizan> monochrom: yeah, that's part of the problem, newer versions should have been fixed to consistently give precedence to packages in the userdb though
16:08:39 <monochrom> yes, 6.12.3 is good
16:08:51 <ben> It seems like such a good idea
16:08:56 <litb> wait haven't yet gotten to that "fixed point combinator" thing
16:09:07 <wisepumpkin> ben: there's a fairly solid proposal on compeltely rehauling it
16:09:09 <Philippa> thoughtpolice: and Thierry Coquand's name, no?
16:09:09 <wisepumpkin> completely 
16:09:29 <djahandarie> ben, you could try uniplate or something
16:09:34 <djahandarie> Depends on what you're trying to eliminate
16:09:39 <thoughtpolice> i've also been trying to learn agda and it's been going terrible (lack of time for one,) but the emacs mode is pretty awesome and i certainly like the feel more than Coq
16:09:42 <ddarius> Moral of the story, the French like puns and thus French computer scientists ... !
16:09:46 <thoughtpolice> proofs feel like a much larger burden though
16:09:55 <monochrom> I feel like I have found the Higgs boson or something :)
16:10:10 <engla> monochrom: hush. don't tell anyone!
16:10:27 <ddarius> monochrom: If they exist, they'd be all over the place so it wouldn't be hard to find one.
16:10:28 <ben> wisepumpkin: Sounds neat. Where do I look for that?
16:10:41 <djahandarie> ben, you look into the future!
16:10:47 <Saizan> monochrom: that still doesn't help cabal, but it makes working with ghci/ghc directly somewhat saner :)
16:10:50 <djahandarie> It's on the ghc wiki somewhere
16:10:50 <thoughtpolice> Philippa: not sure actually, but that would make sense too!
16:10:50 <wisepumpkin> ben: nobody's implemented it yet, but Simon Peyton Jones wrote a long blurb about it on haskell-cafe recently
16:11:01 <djahandarie> Or maybe the mailing list... or both?
16:11:18 <ben> "onward and upward"?
16:11:38 <thoughtpolice> man, when are plugins finally going mainline in GHC? now that's one patch I would like to see get in
16:11:55 <monochrom> Saizan: please tell me more.
16:12:14 <thoughtpolice> this is all worsed by the fact there is no public repository (afaik) of bsp's GHC repo supporting plugins and the patch has never been made public
16:12:20 <thoughtpolice> a terrible fate
16:12:39 <wisepumpkin> thoughtpolice: you could bug him, he does have a github account
16:12:48 <wisepumpkin> I bugged him once on github about it
16:12:50 <wisepumpkin> he was very friendly
16:13:13 <djahandarie> Check if wisepumpkin still has all his limbs first
16:13:13 <ben> Oh. I remember reading this and not understanding a thing.
16:13:22 <djahandarie> (Or would it be stem?)
16:13:25 <thoughtpolice> i would definitely like to see it go mainline and would be willing to dedicate some time to help integrating it (if that's even necessary)
16:14:04 <thoughtpolice> it would be really cool to actually be able to write REAL ghc plugins, not just piggyback on GHC Core (like CLaSH and LHC do which is terrible IMO since external-core is a pain)
16:14:48 <djahandarie> Would it even fit into the plugin architecture if it was modifying the GHC Core language?
16:17:19 <kmc> litb
16:17:21 <kmc> @src fix
16:17:21 <lambdabot> fix f = let x = f x in x
16:17:40 <kmc> litb, http://www.vex.net/~trebla/haskell/fix.xhtml
16:18:00 <hpc> alternatively, fix f = f (fix f)
16:18:10 <hpc> @pl fix f = f (fix f)
16:18:10 <lambdabot> fix = fix (ap id)
16:18:12 <kmc> alternatively but less efficiently
16:18:19 <hpc> :t ap id
16:18:20 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
16:18:40 <hpc> um, what
16:18:45 <hpc> pl, you so silly
16:18:57 <kmc> pl uses fix to translate let
16:19:18 <hpc> haha
16:19:40 <Saizan> monochrom: cabal parses ghc-pkg dump and builds it's index of packages via a procedure which was still influenced by the abi hash last time i looked, and it doesn't even try to do a proper shadowing like ghc which prunes away installations that depend on other ones that got excluded earlier
16:20:09 <ben> What is a Cxt in TH?
16:20:17 <ben> Context/constraints?
16:20:19 <dankna> a context, I presume
16:20:29 <aavogt> the stuff to the left of =>
16:20:32 <ben> Right
16:27:11 <ddarius> > foldl (flip (:)) "foo" "rab"
16:27:12 <lambdabot>   "barfoo"
16:28:29 <romanandreg> hey guys
16:28:31 <romanandreg> what does it mean
16:28:35 <romanandreg> when I have exclamation signs
16:28:35 <Twey> > flip (:) `foldl` "foo"  "rab"
16:28:36 <lambdabot>   Couldn't match expected type `t -> [b]'
16:28:36 <lambdabot>         against inferred type `[GHC...
16:28:37 <romanandreg> before a type
16:28:40 <romanandreg> in a type signature
16:28:40 <Twey> Oops
16:28:43 <Twey> > flip (:) `foldl` "foo" $ "rab"
16:28:43 <romanandreg> !Int
16:28:44 <lambdabot>   "barfoo"
16:28:46 <Twey> Phew
16:28:51 <Twey> romanandreg: Strictness annotation
16:29:01 <dibblego> romanandreg, they are strictness annotations. denoting that the argument is evaluated to WHNF
16:29:02 <romanandreg> Twey: what does that imply
16:29:09 <romanandreg> WHNF?
16:29:17 <Twey> romanandreg: Evaluating the constructor results in evaluating the argument one stage
16:29:31 <romanandreg> so for example
16:29:33 <romanandreg> if I do 
16:29:43 <romanandreg> data X = X !Int
16:29:51 <romanandreg> X (5 + 5)
16:29:55 <romanandreg> will evaluate the 5 + 5
16:30:02 <romanandreg> if I do not have the exclamation sign
16:30:07 <romanandreg> it won't evaluate until needed?
16:30:08 <kmc> romanandreg, once you force the X it will force the 5+5
16:30:09 <Twey> Yes
16:30:20 <romanandreg> ok... 
16:30:23 <romanandreg> cool
16:30:24 <kmc> i mean if you say let a = X (5+5) in () then a is never used so it doesn't add
16:30:33 <aristid> :t [pure, map]
16:30:33 <romanandreg> ok 
16:30:34 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[b]'
16:30:34 <lambdabot>     Probable cause: `map' is applied to too many arguments
16:30:34 <lambdabot>     In the expression: map
16:30:41 <aristid> :t map
16:30:42 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:30:45 <Twey> (but only because our numbers are strict; with a normal function it would just evaluate up to the (+))
16:30:55 <Twey> :t (pure, map)
16:30:55 <lambdabot> forall a (f :: * -> *) a1 b. (Applicative f) => (a -> f a, (a1 -> b) -> [a1] -> [b])
16:31:02 <kmc> it would evaluate until (5+5) return a constructor
16:31:08 <kmc> i.e. to whnf
16:31:21 <revenantphx> ffff
16:31:24 <romanandreg> ok
16:31:25 <Twey> *nod*
16:31:31 <romanandreg> Twey I didn't understand that last bit
16:31:38 <Twey> romanandreg: Never mind it
16:31:41 <romanandreg> hahahaha
16:31:42 <Twey> You probably don't need to
16:31:43 <romanandreg> ok
16:31:45 <joe6> has anyone tried ghc7 with haskell-platform-2010.2.0.0?
16:31:50 <romanandreg> cool then
16:31:56 <Twey> (and it wasn't a very good explanation anyway)
16:32:02 <kmc> for Int, WHNF = NF
16:32:05 <kmc> but not so for other types
16:32:07 <revenantphx> I have to say, it's humbling when a guy walks into the room, briefly hears about the problem, says "whoa cool, let me try to make a mean field model" and in the course of 5 minutes, does so immediately.
16:32:14 <aavogt> romanandreg: you can have a   data X = X ![Int], and the list is allowed to be infinite
16:32:17 <revenantphx> Math speed way above me.
16:32:45 <romanandreg> aavogt: and why is that again?
16:33:00 <kmc> the ! only forces the outermost constructor of the list
16:33:03 <kmc> which is either [] or (:)
16:33:11 <kmc> > repeat 'z' `seq` ()
16:33:12 <lambdabot>   ()
16:33:13 <romanandreg> ohh 
16:33:18 <aavogt> all keeping in mind that we've forced the X
16:33:43 <kmc> to make a totally spine-strict list you'd say:  data SL a = Nil | Cons a !(SL a)
16:34:02 * kmc wonders if this is another advantage of the explicit pattern-functor approach: lazy and strict variants from the same code
16:34:14 <romanandreg> kmc: interesting
16:34:23 <romanandreg> so the ! only work with the first cons 
16:34:24 <romanandreg> ?
16:34:28 <aavogt> kmc: pattern-functor?
16:34:29 <kmc> yeah
16:34:35 <kmc> ! says strict to weak head-normal form
16:34:38 <kmc> which means outermost constructor
16:34:41 <kmc> which is the head cons here
16:35:04 <romanandreg> interesting, ok I get it know
16:35:05 <kmc> aavogt, yeah, data ListF a xs = Nil | Cons a xs; type List a = Mu (ListF a)
16:35:27 <kmc> i'm imagining newtype Mu' f = In' !(f (Mu' f))
16:35:38 <kmc> @src Mu
16:35:38 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
16:35:45 <kmc> hmm something's not ight
16:35:49 <kmc> because it's a newtype anyway
16:36:16 <kmc> hmm no i don't think this works :/
16:37:00 <aavogt> how do you save any code using Mu anyways?
16:37:16 <aavogt>  ListF is just about as long as List
16:37:40 <djahandarie> You don't, but you can use code which references the underlying type
16:38:18 <Eduard_Munteanu> How is it useful to reference a ListF a xs?
16:38:52 <ddarius> @hoogle maybe
16:38:52 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
16:38:52 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
16:38:52 <lambdabot> module Data.Maybe
16:38:56 <ddarius> @hoogle fromMaybe
16:38:57 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
16:39:43 <romanandreg> does the same (!) applies when we are using pattern matching?
16:40:03 <djahandarie> Eduard_Munteanu, you can define a catamorphism as (f -> a) -> Mu f -> a
16:40:13 <djahandarie> Err
16:40:20 <ski> kmc : "lazy and" ?
16:40:22 <aavogt> Eduard_Munteanu: well you could presumably substitute a  ListF2 a xs = Nil2 | Cons2 a !xs  for the spine strict one
16:40:23 <djahandarie> (f a -> a) -> Mi f -> a
16:40:25 <Eduard_Munteanu> Hm, I knew I saw something with Mu in connection to hylos
16:40:35 <djahandarie> Damn
16:40:37 <djahandarie> Mu*
16:41:10 <ski> (kmc : hm, i missed the "strict variants from the same code" line)
16:41:11 <Eduard_Munteanu> aavogt: hm, that makes some sense.
16:41:12 <aavogt> but separating the recursion doesn't seem to help the code size
16:42:01 <djahandarie> Eduard_Munteanu, I don't think there is Mu in a hylomorphism
16:42:03 <Eduard_Munteanu> So basically it's theoretically interesting so you can define recursive types in terms of a type-level Y combinator?
16:42:19 <djahandarie> At least not the type I'm remembering
16:42:20 <aavogt> kmc: was the idea to swap out the Mu for different strictness?
16:42:23 <ski> aavogt : if haven't seen them, see <http://www.haskell.org/wikisnapshot/DecoratingStructures.html> and
16:42:24 <djahandarie> *checks category-extras*
16:42:30 <ski> @wiki Indirect_composite
16:42:30 <lambdabot> http://www.haskell.org/haskellwiki/Indirect_composite
16:42:57 <djahandarie> Eduard_Munteanu, nope, no Mu in a hylomorphism
16:42:58 <wisepumpkin> if you want different strictness, change the strictness of the underlying functor you're taking the fixed point of
16:43:09 <Eduard_Munteanu> I could understand treating type operators like more usual lambda calculus.
16:43:11 <ski> aavogt : doing this give more flexibility, and also you can often reuse more code
16:44:16 <ski> Eduard_Munteanu : see the two links above, you too
16:44:18 <Eduard_Munteanu> A-ha!
16:44:21 <djahandarie> It is (g b -> b) -> (f a -> g a) -> (a -> f a) -> a -> b
16:44:27 <Eduard_Munteanu> djahandarie: http://www.willamette.edu/~fruehr/haskell/evolution.html
16:44:39 <Eduard_Munteanu> I remembered, just look under "Ph.D. Haskell programmer"
16:45:41 <djahandarie> Eduard_Munteanu, the hylomorphism type isn't even defined there :P
16:46:04 <Eduard_Munteanu> djahandarie: yeah, but it's an ana + a cata
16:46:34 <Eduard_Munteanu> (that's what a hylomorphism is)
16:46:36 <djahandarie> Both of which aren't defined over an arbitrary product functor
16:46:41 <ski> also
16:46:45 <djahandarie> Just over lists there
16:46:46 <ski> @wiki Hash_consing
16:46:46 <lambdabot> http://www.haskell.org/haskellwiki/Hash_consing
16:47:11 <djahandarie> Either way, the eventual type of a hylomorphism doesn't involve the recursive type
16:47:27 <wisepumpkin> Eduard_Munteanu: GHC can't handle that deriving Show on the Mu in that
16:48:17 <djahandarie> It gets factored out even if you compose the cata and anomorphisms
16:48:23 * Eduard_Munteanu doesn't get the point in indirect composite, looks at hash consing
16:49:00 <Eduard_Munteanu> djahandarie: well obviously, that might be too tongue-in-cheek to be correct.
16:49:58 <kmc> djahandarie, so you can write cata :: (f a -> a) -> Mu f -> a ?
16:50:20 <djahandarie> Functor f, yeah
16:50:34 <kmc> ah right
16:51:15 <wisepumpkin> (f a -> a) -> Mu (Codensity f) -> a
16:51:45 <Eduard_Munteanu> ski: will read that again tommorrow, I'm a bit tired atm and don't get it :)
16:52:02 <djahandarie> Hmm... what would that do conal 
16:52:04 <djahandarie> Err
16:52:06 <djahandarie> wisepumpkin*
16:52:16 <djahandarie> Still stuck tab-completing your old nick ;)
16:52:59 * kmc can't write it :/
16:53:11 <kmc> hint?
16:53:16 <wisepumpkin> you need fmap :)
16:53:20 <wisepumpkin> :P
16:53:39 <wisepumpkin> kmc: hint: -XImplicitParams
16:53:46 <wisepumpkin> my favorite extension for exploratory programming
16:54:33 <ski> Eduard_Munteanu : e.g. `IOExpr' is a variant of `Expr' where each sub-expression lies inside an `IORef', so can be mutated inside the `IO' monad
16:54:49 <djahandarie> kmc, hmm... think of when the recursion needs to happen I guess? Hard to give a hint :P
16:55:08 <wisepumpkin> kmc: in agda I'd stick holes in various places and see what I can fill them with
16:55:18 <kmc> yeah
16:55:19 <wisepumpkin> in haskell I do it the cheap way with implicit params
16:55:44 <wisepumpkin> kmc: so what can you do to that Mu f?
16:55:50 <dixie> hmm, how to copy&paste code in yesodwed.com tutorial ? :) it puts all in single line 
16:55:59 <kmc> wisepumpkin, i'ma hack on it a bit more
16:56:04 <kmc> ImplicitParams is a good suggestion
16:56:05 <ski> kmc : add `Functor f => '
16:56:12 <kmc> i got that ski, thanks
16:56:24 <ski> (ok, i wasn't sure about that)
16:57:12 <wisepumpkin> kmc: any time I'm doing something nontrivial with types I use it
16:57:17 <Kaidelong> what's the easiest way to get GHCi to play a bunch of sine waves in tandem for .25 seconds?
16:57:35 <djahandarie> kmc, may also be helpful to try to define it as "cata f = ..." rather than "cata f x = ..."
16:57:40 <Kaidelong> supercollider looks hard
16:57:40 <kmc> yeah
16:58:32 <kmc> i got it!
16:58:34 <kmc> thanks for help all
16:59:01 <c_wraith> moderately commercial moment:  the company I work at is in search of more engineers.  Yes, there is Haskell programming involved, though not 100% of the time.  Located in Portland, Oregon.  see the description here:  http://www.janrain.com/company/careers/software-engineer
16:59:20 <djahandarie> Oh you work at janrain?
16:59:23 <wisepumpkin> kmc: now write the other *morphisms!
16:59:23 <c_wraith> yep
16:59:35 <Eduard_Munteanu> ski: ah, after a bit more staring I do see why it could be useful. So you can get different variants depending if you apply the vanilla Mu or add IORef to it.
16:59:40 <djahandarie> Zygohistoprepromorphism this shiat up!
17:01:04 <kmc> data MutMu f = MutIn (IORef (f (MutMu f))) ?
17:01:23 * kmc wonders if there's any use for (Mu IORef)
17:01:29 <kmc> i was quite happy to find a use for (Mu Chan)
17:01:41 <Pseudonym> kmc: Implementing the WAM?
17:01:46 <kmc> WAM?
17:01:50 <Pseudonym> Warren Abstract Machine
17:01:52 <kmc> implementing the  calculus
17:01:55 <kmc> mybe it's similar
17:02:04 <Eduard_Munteanu> Rather a newtype or something.
17:02:11 <ddarius> The WAM is used for logic languages.
17:02:18 <Pseudonym> No, the WAM is used for Prolog.
17:02:42 <kmc> ah
17:02:46 <Pseudonym> Most logic languages aren't Prolog, they just look like Prolog.
17:02:57 <Pseudonym> Kind of like how most functional languages look like Lisp.
17:03:04 <kmc> no they don't
17:03:09 <ddarius> I was going to say that originally, but (highly modified) versions of the WAM are used elsewhere.
17:03:34 <Pseudonym> OK, let me rephase that.  If you take all functional languages, more of them look like Lisp than don't.
17:03:34 <Eduard_Munteanu> Thankfully they don't.
17:03:49 <djahandarie> wisepumpkin, do you know why newtype instances screw up GHC's optimiser?
17:03:55 <djahandarie> (Like rl said in his blog post)
17:04:11 <djahandarie> With the data family
17:04:30 <kmc> Pseudonym, counting or averaging over languages is a tricky business
17:04:37 <kmc> and defining "functional language" likewise
17:04:57 <kmc> maybe every Lisp program is its own language due to macros etc
17:05:04 <ski> Eduard_Munteanu : right
17:05:17 <kmc> and so almost every language ever looks like lisp
17:05:35 <wisepumpkin> djahandarie: nope
17:05:56 <djahandarie> Maybe I'll comment
17:06:07 <Eduard_Munteanu> ski: so I guess this could be used to get, ehm, mutable lists for instance?
17:06:14 <Eduard_Munteanu> (mutable in elements)
17:06:35 <ski> rather mutable in links (if you define an `ListF' first)
17:06:46 * Eduard_Munteanu looks again
17:07:11 <Eduard_Munteanu> Oh, yes.
17:07:12 <ski> mutable in elements is just `[IORef X]'
17:07:45 <Eduard_Munteanu> Yeah. Nice idea, I guess I'll try it a bit.
17:08:35 * Eduard_Munteanu needs some sleep now...
17:08:37 <Eduard_Munteanu> o/
17:09:30 <JoeyA> > let xs = 0 : map (+1) xs in xs
17:09:31 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:09:51 <ski> Eduard_Munteanu : instead of doing `newtype IOExpr = IOExpr (ExprF (IORef IOExpr))', you could do `newtype IOExprF self = IOExprF (IORef (ExprF self))' (flipping the order of `IORef' and `ExprF' since i prefer the other order), so that you can possibly apply more "modifications", before tying the whole result together with `Mu'
17:10:10 <ski> @tell Eduard_Munteanu instead of doing `newtype IOExpr = IOExpr (ExprF (IORef IOExpr))', you could do `newtype IOExprF self = IOExprF (IORef (ExprF self))' (flipping the order of `IORef' and `ExprF' since i prefer the other order), so that you can possibly apply more "modifications", before tying the whole result together with `Mu'
17:10:10 <lambdabot> Consider it noted.
17:10:14 <JoeyA> I'm writing an interpreter for a Haskell-like language, and I'm trying to understand this construct better, as my evaluator breaks on it.
17:10:37 <ddarius> @. pl djinn (a -> b -> c -> d) -> b -> c -> a -> d
17:10:37 <lambdabot> f = (flip .) . flip
17:10:42 <JoeyA> (actually, it breaks with my native implementation of map which carries a statefully modified thunk)
17:11:05 <ski> @tell Eduard_Munteanu (this applying `Mu' finally in some ways corresponds to instantiating a class in OO, btw)
17:11:05 <lambdabot> Consider it noted.
17:11:06 <JoeyA> First, I gotta figure out why that construct seems to be O(n)
17:11:57 <JoeyA> as in, why don't the additions stack up?
17:12:38 <monochrom> you print the items in a good order. the printing interleaves with the generating. this is why the addition thunks don't stack up.
17:12:53 <monochrom> now try let xs = 0 : map (+1) xs in xs !! 10000000
17:13:41 <ddarius> @let ifMaybe m j n = maybe n j m
17:13:42 <lambdabot>  Defined.
17:14:11 <JoeyA> That's efficient, too
17:14:42 <JoeyA> and my interpreter does it efficiently, too
17:14:58 <JoeyA> I'm just trying to understand it.
17:15:11 <ddarius> @google 2+2
17:15:12 <lambdabot> No Result Found.
17:15:23 <litb> > ((. (+ 5)) . (*)) 2 3
17:15:24 <lambdabot>   16
17:15:29 <litb> haha nice
17:15:38 <Kaidelong> should I ever have to use PackageImports or is there a better way?
17:15:44 <Kaidelong> fd-monads conflicting with mtl
17:16:12 <JoeyA> oh, I think I see it now
17:16:19 <JoeyA> the (+1)s aren't being stacked
17:16:27 <JoeyA> 0 : map (+1) xs
17:16:30 <JoeyA> 0 : 1 : map (+1) xs
17:16:32 <JoeyA> 0 : 1 : 2 : map (+1) xs
17:16:34 <JoeyA> etc.
17:17:19 <litb> it reads the partial result of the list
17:17:52 <monochrom> ghc 6.12.3 probably just got a larger stack
17:18:22 <litb> what'S the most efficient way to loop from 1 to 1000000 ?
17:18:36 <jmcarthur> > [1..1000000]
17:18:37 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
17:18:57 <kmc> litb, loop and do what?
17:19:12 <litb> print the current index
17:19:20 <djahandarie> Use map and a list
17:19:22 <jmcarthur> :t mapM print [1..1000000]
17:19:23 <lambdabot> IO [()]
17:19:27 <mauke> print [1..1000000]
17:19:28 <jmcarthur> :t mapM_ print [1..1000000]
17:19:28 <lambdabot> IO ()
17:19:30 <Kaidelong> mapM_
17:19:31 <Kaidelong> yes
17:19:38 <kmc> :t forM_
17:19:39 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
17:19:44 <jmcarthur> Kaidelong: i never think about these things before i hit enter
17:20:06 <djahandarie> jmcarthur, that's what the murder says too!
17:20:13 <jmcarthur> the murder!
17:20:31 <litb> hmm that loops seems to be much slower in haskell than in python
17:20:41 <djahandarie> murderer* :P
17:20:47 <kmc> litb, are you compiling your code, or running it in ghci?
17:20:53 <litb> ghci
17:20:59 <kmc> ghci is much slower than compiled code
17:21:04 <litb> ohh
17:21:05 <monochrom> in ghci let xs = 0 : map (+1) xs in xs !! 100000000 takes more than 2GB memory. I didn't let it finish.
17:21:10 <kmc> main = mapM_ print [1..1000000]
17:21:12 <kmc> ghc --make -O foo.hs
17:21:16 <JoeyA> wow, I don't know how to do a for loop in python.
17:21:23 <JoeyA> plz telp me.  itz due tomorow
17:21:24 <mauke> how about -O2
17:21:25 <monochrom> it looks like recent ghc has got growable stack.
17:21:30 <JoeyA> (jk)
17:21:33 <kmc> O2 doesn't usually matter but why not
17:21:39 <JoeyA> ah, range
17:21:45 <djahandarie> O2 can cause some problems since it's more aggressive
17:21:45 <kmc> JoeyA, i wrote this python code, why doesn't it work?!?!?  the code  is @#$*%&(@*%$(@^%(&$#@^%(#$&^
17:21:52 <djahandarie> Especially with CSE iirc
17:22:02 <mauke> since when does ghc do CSE?
17:22:02 <kmc> i though GHC didn't do CSE at all
17:22:02 <litb> will ghci do as interpreter?
17:22:06 <litb> or will it jit?
17:22:09 <jmcarthur> ghc does very little CSE
17:22:13 <djahandarie> It does some
17:22:14 <kmc> litb, it's a bytecode interpreter.  no jit afaik
17:22:22 <kmc> litb, but it will load compiled code modules
17:22:30 <litb> oh
17:22:33 <kmc> it's useful as a frontend to compiled libraries
17:22:38 <kmc> and for testing and exploration and learning
17:22:57 <monochrom> yeah, put it in a module file, ghc -c it, then load it in ghci for happiness
17:23:05 <monochrom> err, ghc -c -O it, of course
17:23:16 <JoeyA> kmc> Try running 'perl' on it.
17:23:16 <jmcarthur> i'd just go ahead and do -O2
17:23:25 <jmcarthur> it's never hurt me ^_^
17:23:30 <djahandarie> Yes. -O2 will definitely do better almost all the time
17:23:36 <monochrom> otoh if you just want to hurt the stack, interpreted is as good as any
17:23:36 <litb> ah compiled it really is faster
17:23:49 <kmc> ghc --make -O surely monochrom ;)
17:23:56 <djahandarie> But I think I've hit performance bugs where it only happened in -O2
17:24:01 <litb> i think it's as fast as my own nerdy LLVM made language compiler
17:24:01 <djahandarie> I definitely know other people have
17:24:02 <kmc> all i know is that cabal bitches when you put 'ghc-options: -O2'
17:24:08 <kmc> and says it's usually as good
17:24:11 <ddarius> Cale: Do you have a copy of the code you are actually running for lambdabot publically available somewhere?
17:24:18 <kmc> to do -O
17:24:20 <mauke> "usually"
17:24:30 <kmc> too much is never enough
17:24:31 <monochrom> I'm too old to mind either way.
17:24:32 <djahandarie> ddarius, isn't it just running whatever is on Hackage?
17:24:40 <djahandarie> Except maybe the included file
17:24:58 <mauke> JoeyA: it's a syntax error
17:25:08 <aavogt> ddarius: the copy on code.haskell.org should be pretty close
17:25:28 <aavogt> close enough that patches relative to that one are good
17:25:37 <aavogt> @source
17:25:38 <lambdabot>  not available
17:25:51 <aavogt> @help
17:25:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:25:54 <aavogt> @list
17:25:54 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
17:26:03 <aavogt> that repo
17:26:17 <ddarius> djahandarie: It doesn't seem to be, though I'm sure it is close to the Hackage version.
17:27:03 <ddarius> (Actually, I know that it isn't running what's on hackage, but I also have a particular query.)
17:34:36 <ivanm> preflex: seen ndm
17:34:36 <preflex>  ndm was last seen on #haskell 7 hours, 47 minutes and 3 seconds ago, saying: i think i'll invoke the Simon via email
17:34:59 <mauke> !
17:35:13 <ddarius> Which Simon?!
17:35:19 <ivanm> dunno
17:35:30 <mauke> [Simon]
17:35:46 <ivanm> but ndm sent me a message via lambdabot saying he's fixed some issues in the cmdargs docs, and I don't even recall what or when I told him!
17:36:18 <mauke> preflex: seen mmorrow
17:36:18 <ddarius> ivanm: Maybe he's a time traveller and a future you will tell him.
17:36:18 <preflex>  mmorrow was last seen on #ghc 304 days, 22 hours, 38 minutes and 32 seconds ago, saying: * mmorrow is rtfm'ing
17:36:26 <kmc> preflex, seen god
17:36:26 <preflex>  god was last seen on ##c++ 1 year, 46 days, 2 hours, 30 minutes and 59 seconds ago, saying: I don't really know either actually
17:36:37 <ddarius> How apropos.
17:36:51 <ivanm> ddarius: heh
17:37:08 <ivanm> I vaguely recall telling him *something*...
17:37:10 <aristid> preflex: seen edwardk
17:37:10 <preflex>  edwardk was last seen on #haskell-blah 20 hours, 36 minutes and 27 seconds ago, saying: night man
17:37:30 <ivanm> preflex: seen sw17ch
17:37:30 <preflex>  sw17ch was last seen on #haskell 48 days, 18 hours, 23 minutes and 59 seconds ago, saying: lol
17:37:48 * ivanm still finds it amazing how long it takes mmorrow to rtfm...
17:38:12 <kmc> preflex, seen lambdabot
17:38:12 <preflex>  lambdabot was last seen on #haskell 12 minutes and 18 seconds ago, saying: http://code.haskell.org/lambdabot/COMMANDS
17:38:52 <wisepumpkin> oh now that I'm in the US I might try calling mmorrow
17:38:58 <wisepumpkin> over the weekend when I have some time
17:39:08 <ivanm> wisepumpkin: what's with the new nick?
17:39:15 <Kaidelong> nobody here have any experience doing real-time audio with GHCi?
17:39:18 <wisepumpkin> I said something wise earlier
17:39:20 <wisepumpkin> forgot what it was
17:39:25 <ivanm> and I thought you tried calling him before you left the USA...
17:39:27 <Kaidelong> I figured it could make a cool demo
17:39:41 <ivanm> Kaidelong: I'm not sure how well it would work in ghci...
17:39:44 <Kaidelong> failing that I could demonstrate the reduced dissonance using plot
17:39:45 <sm> I think I've seen a quasiquoter that just makes it easier to define multiline strings.. does anyone know where ?
17:39:51 <ivanm> probably better writing an actual program
17:40:02 <ivanm> sm: hmmm, it was something by john macfarlane on github IIRC
17:40:09 <ivanm> he was giving it up for adoption as well
17:40:12 <aavogt> there's actually something to it?
17:40:27 <ivanm> aavogt: to what?
17:40:32 <sm> ok, thanks for the lead
17:40:32 <Kaidelong> ivanm: Well the point would be doing a harmony search for decreasingly dissonant chords and demonstrating live how the chord improves
17:40:36 <aavogt> sm: that one is rather trivial to write, if annoying because you need another module
17:40:53 <ivanm> sm: actually, it may have been a pre-processor...
17:41:01 <ivanm> and you shoved the text you wanted in an external file
17:41:02 <Kaidelong> I guess I could do it with a program
17:41:17 <sm> oh I don't want that. That sounds like binembed
17:41:25 <Kaidelong> I think I'll use a plot
17:41:26 <aavogt> you just put  stringE . getRidOfSpacesAsIsPleasant   in the quasiquoter data type
17:41:27 <ivanm> yeah, I think that was it
17:41:49 <ivanm> @hoogle getRidOfSpacesAsIsPleasant
17:41:49 <lambdabot> No results found
17:41:52 <ivanm> :(
17:42:14 <aavogt> well there are lots of ways you might like to cut some of the whitespace between the  | and  |]
17:42:52 <kmc> sm, haskell-src-meta?
17:42:53 <aavogt> like whether having the lot indented should subtract off that much from every line
17:42:56 <kmc> Language.Haskell.Meta.QQ.Here ?
17:43:05 <ben> template haskell does not let me find all instances of a class just from its name, does it?
17:43:22 <aavogt> ben: doubtful, it would be nice if it did
17:43:33 <ben> hm
17:43:59 <sm> thanks
17:56:29 <ivanm> wisepumpkin: Oh wise one, do you have any suggestions on how to do the Show/Read instances for my PlanarGraph type?
17:56:37 <ivanm> or even on how to do a pretty-printer for it?
17:59:59 <ski> (ivan : .. derive them ?)
18:00:08 <ivanm> I don't think so ;-)
18:00:23 <ivanm> ski: this is the type in question: http://hpaste.org/41590/initial_version_of_planargrap
18:00:41 <ivanm> I don't want the internal details to be visible tot he user
18:01:24 <ski> ok
18:01:42 <ski> > listArray (0,3) "abcd"
18:01:43 <lambdabot>   array (0,3) [(0,'a'),(1,'b'),(2,'c'),(3,'d')]
18:01:51 <ski> you could do something similar, maybe ?
18:02:28 <ivanm> yeah, not sure exactly how though
18:02:33 <ivanm> the internal details are rather fiddly
18:03:01 <ivanm> I was thinking of using something like the graph6 format, but it doesn't allow for labels: http://cs.anu.edu.au/~bdm/data/formats.html
18:03:09 <ivanm> also, it assumes simple graphs, etc.
18:03:43 * hackagebot sifflet-lib 1.2.1 - Library of modules shared by sifflet and its  tests and its exporters.  http://hackage.haskell.org/package/sifflet-lib-1.2.1 (GregoryWeber)
18:04:43 * hackagebot sifflet 1.2.1 - A simple, visual, functional programming language.  http://hackage.haskell.org/package/sifflet-1.2.1 (GregoryWeber)
18:05:19 <ski> (if you use something like that, i hope you make sure the result of `show' is valid Haskell code, still (even if it always is of the form `fromGraph6 "..."'))
18:06:53 * ski assumes "graph6" is for serialization, rather than for readability
18:07:39 <ivanm> yeah
18:07:50 <ivanm> and yes, doing something like fromGraph6 "..." was the plan
18:08:17 <ivanm> admittedly, that is currently not the case for Node and Edge, because I definitely don't want people to create them by hand (though read . show == id)
18:08:36 <Kaidelong> hmm
18:08:41 <Kaidelong> @instances show
18:08:42 <lambdabot> Couldn't find class `show'. Try @instances-importing
18:08:51 <ski> @instances Show
18:08:51 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, ST s a, Sum a, [a]
18:10:20 <ivanm> if fromInteger wasn't part of the Num class, I'd consider abusing it for the show/read instances for Node and Edge...
18:18:36 <wisepumpkin> ivanm: oh
18:18:45 <wisepumpkin> ivanm: not sure
18:19:27 <ivanm> I was thinking of ripping off Data.Graph.Inductive.Tree's Show instance as the pretty-printer, but should it also indicate the inverse edge somehow?
18:21:29 <joe6> @hoogle listOf
18:21:29 <lambdabot> No results found
18:21:44 <joe6> :t listOf
18:21:45 <lambdabot> forall a. Gen a -> Gen [a]
18:28:22 <joe6> does anyone know where this listOf is? I cannot find it in hoogle?
18:28:39 <ivanm> QuickCheck
18:28:45 <ivanm> @index listOf
18:28:45 <lambdabot> bzzt
18:28:51 <ivanm> @where hayoo
18:28:51 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:29:01 <ivanm> joe6: ^^ try using hayoo
18:29:38 <joe6> cool, thanks. I was searching on hoogle and it was not finding anything.
18:30:01 <ivanm> hoogle mainly just indexes the libraries that come with ghc
18:30:12 <ivanm> hayoo indexes all of hackage
18:32:31 <joe6> ivanm: how can I install Test.QuickCheck.Gen with cabal. I have quickcheck installed but I am not able to find quickcheck.gen
18:32:35 <joe6> can you please help?
18:32:50 <joe6> cabal install --prefix=$HOME/.cabal quickcheck
18:32:50 <ivanm> module Test.QuickCheck
18:33:00 <ivanm> you shouldn't need that --prefix argument....
18:33:06 <joe6> oh, ok.
18:33:13 <ivanm> also, which version of QuickCheck do you have?
18:33:30 <joe6> is there an easy way to find the version?
18:33:37 <ivanm> cabal show quickcheck
18:34:05 <joe6> unrecognised command, it says.
18:34:39 <ivanm> cabal list, sorry
18:35:23 <joe6> that's ok. thanks. QuickCheck Latest version available: 2.4.0.1 Latest version installed: 1.2.0.1
18:35:43 <ivanm> so you may need a newer version
18:35:47 <ivanm> cabal install QuickCheck
18:36:41 <joe6> No packages to be installed. All the requested packages are already installed.
18:36:48 <joe6> trying it with the --reinstall flag.
18:37:29 <joe6> Configuring QuickCheck-1.2.0.1...
18:37:36 <joe6> it is going to the old library.
18:37:40 <ivanm> might need to specify a version
18:37:43 <joe6> is there a way to force it to upgrade?
18:37:51 <joe6> ok, will try that.
18:37:52 <ivanm> cabal install QuickCheck-2.4.0.1
18:39:14 <joe6> ivanm: that did the trick.
18:39:19 <joe6> thanks a lot
18:39:43 <ivanm> np
18:56:14 <danharaj> if I have a pair of functions, (f, g), is there already a combinator to apply them to a tuple (a, b) -> (f a, g b)?
18:56:45 <ivanm> @type (***)
18:56:46 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
18:57:15 <ivanm> @type (&&&)
18:57:16 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
18:57:28 <ivanm> @pl \(f,g) (a,b) -> (f a, g b)
18:57:29 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .))
18:58:14 <ivanm> @type uncurry (***)
18:58:15 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => (a b c, a b' c') -> a (b, b') (c, c')
18:58:22 <ivanm> danharaj: ^^
18:58:24 <kmc> here a = (->)
18:59:07 <danharaj> thanks
18:59:17 <danharaj> I should get around to learning Control.Arrow
19:00:49 <kmc> it has some useful stuff, even if you only use it for the arrow (->)
19:01:09 <danharaj> good to know
19:01:20 <danharaj> I think I finally have the proper idea for my FRP idea.
19:01:27 <danharaj> (that sounded stupid outside of my head)
19:01:51 <kmc> @djinn (a -> b, c -> d) -> (a, c) -> (b, d)
19:01:51 <lambdabot> f (a, b) (c, d) = (a c, b d)
19:02:42 <kmc> @. elite djinn (a -> b, c -> d) -> (a, c) -> (b, d)
19:02:42 <lambdabot> F (A, b) ((, d) = (a c, B D)
19:02:49 <djahandarie> -_-
19:02:52 <kmc> @. vixen djinn (a -> b, c -> d) -> (a, c) -> (b, d)
19:02:52 <lambdabot> there is nothing going on in your pants that the dictatorship of the proletariat will not solve
19:03:04 <kmc> @remember lambdabot there is nothing going on in your pants that the dictatorship of the proletariat will not solve
19:03:04 <lambdabot> Okay.
19:03:06 <djahandarie> "The dictatorship of the proletariat"
19:03:16 <kmc> that's a pretty good name for your junk
19:03:23 <djahandarie> Hahahaha
19:03:44 <djahandarie> @. vixen nixon
19:03:45 <lambdabot> I work and go to school
19:05:50 <danharaj> I really wish there were an unsigned integer type aka nat
19:06:10 <danharaj> There are plenty of instances where I want exactly a non-negative number
19:06:23 <aavogt> word
19:06:30 <danharaj> word is not arbitrary precision :[
19:06:34 <aavogt> oh, but unbounded
19:06:34 <danharaj> (is it)
19:06:38 <aavogt> right
19:06:50 <aavogt> wisepumpkin: you were binding a nat?
19:07:04 <danharaj> The signature of 'take' bothers me.
19:07:06 <wisepumpkin> ?
19:07:07 <danharaj> SO MUCH
19:07:09 <wisepumpkin> oh
19:07:19 <danharaj> :t take
19:07:20 <lambdabot> forall a. Int -> [a] -> [a]
19:07:25 <danharaj> look at that nonsense.
19:07:25 <wisepumpkin> https://github.com/pumpkin/natural-gmp
19:07:26 <ivanm> why? because of the allowability of a negative index?
19:07:32 <ivanm> I've taken advantage of that a few times
19:07:37 <danharaj> What are the semantics of take -n?
19:07:41 <ivanm> you don't have to worry about sanitising inputs as much
19:07:45 <ivanm> danharaj: empty list
19:07:45 <wisepumpkin> danharaj: drop n!
19:07:47 <djahandarie> wisepumpkin... when do you get time for all this stuff?
19:07:51 <ivanm> > take (-3) [1..]
19:07:52 <lambdabot>   []
19:08:01 <danharaj> ivanm: that's nice and I would expect it, but the type and the name of the function don't say that
19:08:02 <wisepumpkin> djahandarie: I start lots of things and then don't have time to finish them :)
19:08:10 <danharaj> I feel like I'm in python land where I have no idea what a function I call might throw
19:08:33 <ivanm> danharaj: OK, fine: takeIfPositiveAndReturnEmptyListIfNotPositive :p
19:08:36 <djahandarie> wisepumpkin, I used to do that, but now I just don't start anything at all
19:08:41 <sebfisch> http://hackage.haskell.org/package/nat
19:08:45 <danharaj> ivanm: indeed :p
19:09:15 <djahandarie> danharaj, well if you don't care about efficiency... :P
19:09:19 <djahandarie> Peano numbers to the rescue!
19:09:20 <djahandarie> :P
19:09:25 <danharaj> heh
19:09:43 <danharaj> I think I'll just use a Word32 or something
19:09:57 <djahandarie> Hm
19:10:02 <djahandarie> That linked package is interesting
19:10:03 <sebfisch> danharaj, nat package is like peano numbers but binary
19:10:16 <danharaj> sebfisch: It is also YAD
19:10:19 <danharaj> (yet another dependency)
19:10:24 <danharaj> So yeah I guess I'm just whining.
19:10:26 <sebfisch> not very efficient, but lazy
19:10:31 <wisepumpkin> natural-gmp is very speedy :)
19:10:40 <wisepumpkin> and I'm working on some ideas for fast lazy naturals
19:10:41 <djahandarie> From that package "Furthermore the implementation is supposed to be reasonable efficient (in comparison to peano numbers)."
19:10:50 <djahandarie> It's worrying when they say "supposed to"
19:11:02 <ivanm> @pl (\(n,ni) -> ((n,f ni), g ni))
19:11:02 <lambdabot> uncurry ((`ap` g) . ((,) .) . (. f) . (,))
19:11:05 <sebfisch> yes, it's theoretically more efficient than peano because of the binary representation
19:11:06 <ivanm> bah
19:11:08 <wisepumpkin> peano numbers are an initial object in the poset category of efficiencies of impelmentations
19:11:08 <danharaj> I have good faith in the hackage community
19:11:26 <danharaj> but then again I have tried to install a package that outright lied about how I was supposed to configure the C part of it.
19:11:34 <sebfisch> also practically more efficient than peano of course!
19:11:37 <danharaj> because no one ever tests things for windows before going up on hackage
19:11:38 <kmc> ListTakeFunctor<NegativeBehaviorConfigurableListTakeFunctorAttributes> listTakeFunctor = ListTakeFunctorFactory::getListTakeFunctorFactoryByAttributes(NegativeBehaviorConfigurableListTakeFunctorAttributes::TAKE_IF_POSITIVE_AND_RETURN_EMPTY_LIST)::newListTakeFunctorInstance();
19:11:42 <wisepumpkin> off I go
19:11:43 <wisepumpkin> ciao
19:11:47 <danharaj> later
19:11:51 <danharaj> kmc: you win the prize
19:11:53 <sebfisch> but compared with built-in bit representations is is much slower
19:12:06 <sebfisch> at least if you don't need the laziness
19:13:08 <danharaj> Would be nice if they provided as well a strict version.
19:13:14 <danharaj> But I understand how much of a pain that can be.
19:13:20 <danharaj> Haskell's laziness is a double edged lambda.
19:13:28 <danharaj> (so an x)
19:13:40 <ivanm> @pl (\(n,ni) -> (n,f ni, g ni))
19:13:40 <lambdabot> uncurry ((`ap` g) . (. f) . (,,))
19:14:12 <kmc> what's the record for shortest @pl input  longest output?
19:16:04 <MrAI> How would I get the age out of "type Person = (NI, Age, Balance)" ? fst and snd wont work as that requires only two
19:16:11 <sebfisch> danharaj, it is not inefficient because of laziness but because each bit is represented as one constructor
19:16:14 <kmc> pattern-matching
19:16:21 <kmc> age (_, x, x) = x
19:16:28 <kmc> but really you should declare a new type, not use tuples
19:16:34 <kmc> data Person = MkPerson NI Age Balance
19:16:37 <kmc> age (Person _ x _) = x
19:16:44 <WalterMundt> I'm having a bit of trouble using the ST monad
19:16:50 <kmc> err by "x, x" i meant "x, _" above
19:16:56 <WalterMundt> http://hpaste.org/41632/st_issues 
19:17:24 <kmc> what's the problem WalterMundt?
19:17:48 <kmc> oh, runST doesn't always work right with $
19:17:59 <danharaj> :t merge
19:18:00 <lambdabot> Not in scope: `merge'
19:18:07 <danharaj> rats, thought there would be a merge for lists :p
19:18:15 <kmc> we think that runST $ do ... should be equivalent to runST (do ...) but in fact it's not, because GHC won't infer the higher-rank specialization of ($)
19:18:39 <WalterMundt> kmc: okay, I'll try changing that, but I don't think that's the issue
19:18:51 <aavogt> there are tabs in the file
19:18:53 <kmc> yeah, what problem are you seeing?
19:19:03 <WalterMundt> kmc: see the paste again, I added the error
19:19:15 <aavogt> which make the alignment ghc sees different from the one you see
19:19:26 <ivanm> danharaj: there's an ordlist package on hackage...
19:19:35 <ivanm> if that's the kind of merge you were after
19:19:57 <ivanm> (not quite sure of the name though)
19:20:07 <ivanm> kmc: yeah, that trips me up all the time :s
19:20:07 <danharaj> ivanm: probably. But if it's not a standard library/haskell platform, I don't want to add another dependency.
19:20:11 <ivanm> (not with ST though)
19:20:11 <danharaj> I'm trying to keep them minimal.
19:20:19 <ivanm> danharaj: minimal, schminimal
19:20:20 <kmc> WalterMundt, the type var 's' on line 17 and on line 30 are not the same
19:20:28 <kmc> so it complains
19:20:32 <kmc> that's why the error references s and s1
19:20:38 <kmc> you can enable the ScopedTypeVariables extension
19:20:53 <kmc> and then rewrite 17 to "sortPoints :: forall s. Int -> ST s (PointArray s)"
19:20:54 <WalterMundt> *looks up*
19:21:03 <kmc> that will bring s into scope for  the rest of the block
19:21:21 <onteria> wow... Simon Peyton Jones is pretty intense
19:21:26 <WalterMundt> okay, I'm not sure I understand entirely but I'll try it
19:21:50 <djahandarie> onteria, watching a video of him?
19:21:51 <kmc> i can try to elaborate
19:21:54 <djahandarie> I really like his presentations
19:22:02 <onteria> djahandarie: yeah, Data Parallel Haskell
19:22:06 <kmc> "wiggly pointers going everywhere, like snakes"
19:24:11 <WalterMundt> kmc: well, it compiles now
19:24:30 <kmc> cool :)
19:24:39 <ivanm> @quote type-check
19:24:40 <lambdabot> qwe1234 says: For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
19:24:44 <ivanm> bah
19:24:45 <ivanm> @quote type-check
19:24:45 <lambdabot> qwe1234 says: For the majority of tasks, C++ templates produce code that is clearer and better type-checked [than Haskell].
19:24:50 <ivanm> @quote typecheck
19:24:50 <lambdabot> FunctorSalad says: lol I solved my typechecking problem... forgot that I overrode (.)
19:24:50 <WalterMundt> it seems that the forall clause is acting like some kind of declaration
19:24:57 <ivanm> @quote typecheck
19:24:57 <lambdabot> mjrosenb says: <3 #haskell; "why doesn't this program typecheck?" ;  5 hours of category theory later, op left 4 hours ago
19:24:59 <WalterMundt> but that seems like a really odd name for such a thing
19:25:02 <kmc> WalterMundt, it brings the variable 's' into scope over all the signatures under it
19:25:14 <ivanm> what's that quote about if it typechecks it does something, even if it's not what you want?
19:25:17 <kmc> it is an odd name; the keyword 'forall' is used for other stuff too
19:25:30 <kmc> there's an implicit forall on each type variable in a signature
19:25:45 <kmc> when you say (a -> b) -> [a] -> [b], you mean this should work for all types a,b
19:25:58 <kmc> but by default these only scope over that signature
19:26:02 <aavogt> you don't need the extension to make sure it uses the right array type
19:26:11 <kmc> > let x :: (Num a) => a; x = 3; y :: (Num a) => a; y = 4 in x + y
19:26:11 <lambdabot>   7
19:26:14 <kmc> ...
19:26:20 <kmc> oh that's a bad example
19:26:21 <kmc> nm
19:26:32 <MrAI> type Person = (NI, Age, Balance)
19:26:32 <MrAI> retired :: Person -> Bool
19:26:32 <MrAI> retired (x,y,z) = 
19:26:32 <MrAI>  if (y>=65) then True 
19:26:32 <MrAI>  else False
19:26:39 <MrAI> Is that the right way to do it?
19:26:48 <kmc> if foo then True else False
19:26:52 <aavogt> a well-placed     `asTypeOf` (undefined :: ST s (PointArray s))  will do
19:26:53 <kmc> is a longwinded way of saying "foo"
19:27:11 <kmc> aavogt, you'll still have a ScopedTypeVariables problem, if you want to use another sig involving 's'
19:27:31 <ivanm> MrAI: if you're going to split it over multiple lines, typically you start a new line with "then" as well
19:27:47 <MrAI> Ah ok
19:27:58 <kmc> but don't write an if whose branches are True and False ;P
19:28:09 <MrAI> Got it :)
19:28:10 <ivanm> kmc: gah, missed that
19:28:22 <kmc> retired (_,age,_) = age >= 65
19:28:23 <MrAI> Does that use the Person tuple though? Im not sure
19:28:23 <ivanm> and that's one of the things I keep bitching about when students do that :s
19:28:29 <MrAI> It looks like im creating my own tuple
19:28:37 <kmc> "type" creates a synonym only
19:28:47 <kmc> the synonym and the underlying type are totally interchangeable
19:28:53 <MrAI> Ah ok
19:29:02 <ivanm> MrAI: well, without a type sig it accepts any 3-tuple that has a number as the second value
19:29:09 <kmc> that's why it's uglier and less safe than defining your own type
19:29:15 <kmc> but sometimes it's what you want
19:29:54 <MrAI> I think I get it
19:30:00 <ivanm> especially for quick`n`dirty stuff
19:30:05 <MrAI> :)
19:30:44 <kmc> basically anyone anywhere else in the code could make an unrelated 3-tuple and confuse it with your Person
19:30:52 <kmc> and the typechecker won't catch it
19:31:56 <MrAI> Haha I get it :D
19:32:09 <MrAI> Thanks you two: kmc and ivan :)
19:34:04 <ivanm> np
19:41:20 <MrAI> type Person = (NI, Age, Balance)
19:41:20 <MrAI> type Bank = [Person]
19:41:20 <MrAI> credit :: Bank -> [Person]
19:41:20 <MrAI> credit [(x,y,z)] = [(x,y,z)|x<-xs]
19:41:24 <MrAI> Where am I going wrong here?
19:41:48 <kmc> i don't know, you could tell us why it doesn't work as expected
19:41:53 <kmc> your last line tries to bind x in two places
19:42:07 <kmc> and doesn't bind xs anywhere
19:42:08 <djahandarie> There is no xs anywhere
19:42:11 <djahandarie> Damn
19:42:14 <kmc> you're using xs without defining it
19:42:31 <kmc> can you tell us what the "credit" Function is supposed to do?
19:43:00 <MrAI> Just return a list of all the people who have positive bank balance. I wanted to start to return all the people
19:43:03 <MrAI> But im not sure how I do that
19:43:48 <kmc> the bank is a list of all the people
19:43:50 <kmc> credit bank = bank
19:44:17 <kmc> then to get only the positive balance:
19:44:38 <kmc> credit bank = [(x,y,z) | (x,y,z) <- bank, z > 0]
19:44:44 <kmc> or more concisely and better
19:44:52 <kmc> credit bank = [p | p@(_,_,z) <- bank, z > 0]
19:45:08 <MrAI> Ok now your going to have to explain that :p
19:45:14 <kmc> when you write [(x,y,z)] as a pattern, you're only matching a single-element list
19:45:21 <kmc> because [v] is a single-element list
19:45:29 <kmc> MrAI, what part don't you understand
19:46:11 <MrAI> how you can do p@(_,y,z) - or what @ does
19:46:15 <kmc> ah
19:46:25 <kmc> the pattern x@p matches the same things as the pattern p
19:46:28 <kmc> and binds the same variables as p
19:46:35 <kmc> except it also binds x to the whole thing it matched
19:46:53 <kmc> so p is the whole Person tuple, and z is just the third component -- the balance
19:47:40 <MrAI> Ah ok
19:47:40 <alex404_> If I've got a function which takes a bool, is there any difference in speed between pattern matching on the boolean and writing distinct functions vs using the bool inside the function? Even if you only evaluate a single 'guard' or 'if then else' in your function?
19:48:18 <kmc> alex404_, not sure.  test it :)
19:48:29 <alex404_> kmc: Fair enough :)
19:48:34 <djahandarie> Sounds like a time for criterion to shine
19:48:50 <kmc> i doubt it will matter
19:48:57 <djahandarie> *agree*
19:49:15 <djahandarie> Probably generates the exact same ASM
19:49:16 <kmc> especially won't matter if you haven't established this function as a bottleneck
19:49:24 <djahandarie> Hell
19:49:30 <alex404_> Well it's a function which gets called a lot
19:49:33 <kmc> you can use the ghc-core utility off hackage to view the Core generated by ghc
19:49:35 <djahandarie> Doesn't pattern maching just turn into a case in the core?
19:49:54 <kmc> Core is an intermediate language similar to Haskell, with relatively few constructs
19:50:02 <kmc> and you could compare the Core from the two cases
19:50:11 <alex404_> That's a good idea
19:50:17 <alex404_> Have yet to dig into core on anything
19:50:24 <alex404_> Would be a nice problem to cut my teeth on...
20:01:28 <Zeiris> I want to write a tool that parses a language of my own syntax, and compiles it to either Erlang or Core Erlang.
20:01:55 <Zeiris> Are there parser libraries which would let me write definitions that allow both parsing of text to tokens, and creation of text from tokens?
20:02:13 <Zeiris> (So I could get an Erlang->Language compiler as a freebie.)
20:02:54 <Makoryu> Sounds like you want something much more declarative than the usual tools
20:03:04 <Makoryu> Though I can't see how that would be terribly useful
20:03:25 <Zeiris> I'm not even sure if it's possible. The main benefit would be the ability to instantly port Erlang code to my own syntax.
20:03:26 <kmc> i think it's quite useful
20:03:40 <kmc> most complier-ish projects include a parser and a pretty-printer
20:03:46 <kmc> and it would be nice to specify them at the same time
20:03:49 <Zeiris> And, I guess, automatically update code in case the syntax changed in non-backwards-compatible ways. Just do OldLang->Erl->NewLang.
20:03:53 <alex404_> ghc-core, eh? This must be a new use of the term human readable of which I was not formerly aware.
20:03:58 <ivanm> what's a better term: unserialise or deserialise?
20:04:00 <kmc> alex404_, hehehe
20:04:17 <kmc> i think there's been some work using attribute grammars to specify parsers and prettyprinters at the same time
20:04:20 <kmc> but i'm not too familiar
20:04:21 <ivanm> alex404_: well, if you squint and tilt your head the right way...
20:04:22 <ivanm> ;)
20:04:44 <alex404_> Oh... I see it all now...
20:04:47 <kmc> alex404_, yeah, it's pretty low-level.  if you have a specific question maybe we can help
20:04:56 <kmc> there's a few syntactic differences from haskell
20:05:01 <Makoryu> Zeiris: In general, this can't be done.
20:05:22 <alex404_> Perhaps I gave it a bad test case
20:05:27 <alex404_> Just a sec...
20:05:27 <Zeiris> It's only doable for some subset of parsers, with simple enough rules?
20:06:04 <Makoryu> Zeiris: Most language->language translation is quite lossy in one regard or another, particularly with regards to how well the output will perform.
20:06:59 <kmc> i think we're confusing two issues
20:07:04 <kmc> text <-> your language
20:07:06 <kmc> your language <-> erlang
20:07:19 <kmc> when you say "parser" you probably mean the former
20:07:24 <kmc> and it's quite useful to do that bidirectionally
20:07:43 <kmc> actually you said "tokens" which just refers to lexing, not parsing
20:07:58 <kmc> but i'm guessing parsing to a syntax tree, or pretty-printing that tree, are both useful operations
20:08:06 <alex404_> Here's my tester code for bools: http://hpaste.org/41636/code
20:09:19 <alex404_> I can't figure out how to save the core...
20:09:28 <Zeiris> Well, my initial language<->language ideas are mostly trivial syntax modifications, that don't change code structure at all. But I guess it's optimistic to assume things would stop there, and they would indeed get lossy immediately after :\
20:09:40 <kmc> ghc -ddump-simpl
20:09:41 <alex404_> But it's like a few hundred lines...
20:10:02 <Makoryu> Zeiris: Well if the semantics of the two languages are completely identical, that's a much more optimistic situation ;)
20:10:56 <alex404_> Perhaps I'll just try criterion instead on real code
20:11:52 <Zeiris> Afaik going from line and function separators to indentation-aware syntax, and using the now-freed ',' and '.' characters to do point-free function application + bracketless tuples should maintain semantics.
20:12:15 <Zeiris> And being able to go both ways would have the massive benefit of letting people convert their code base to the language, then go back if they didn't like it :D
20:31:05 <ivanm> preflex: seen wisepumpkin
20:31:05 <preflex>  wisepumpkin was last seen on #haskell 1 hour, 19 minutes and 22 seconds ago, saying: ciao
20:31:13 <wisepumpkin> :o
20:31:15 <ivanm> so, are you back then?
20:31:22 <wisepumpkin> more or less
20:31:28 <wisepumpkin> might go find something to eat in a bit
20:31:42 <ivanm> wisepumpkin: I ended up making my own serialisation type: type SerialisedGraph n e = [(Int, n, [(Int, Int, e, Int)])]
20:31:50 <wisepumpkin> :o
20:31:50 <ivanm> and so Show and Read use that
20:32:20 <ivanm> now to work out if I should adapt my by-hand dual construction to just constructing the serialised form instead...
20:32:31 <wisepumpkin> :o
20:33:02 <ivanm> I wonder if I should switch to using Word instead of Int though...
20:33:20 <ivanm> the only real advantage to still using Int is that I can use an IntMap under the hood if I so wish...
20:34:45 <kmc> you can use Word and convert
20:34:48 <kmc> which should be cheap
20:34:55 <kmc> you can use EnumMap too
20:35:15 <ivanm> EnumMap? never heard of it...
20:35:19 <geheimdienst> ivanm, switching from Int to Word sounds less than promising. try switching to Excel
20:35:23 <kmc> http://hackage.haskell.org/package/EnumMap
20:35:27 <ivanm> @slap geheimdienst
20:35:27 * lambdabot hits geheimdienst with an assortment of kitchen utensils
20:35:47 <ivanm> kmc: oooohhh.....
20:36:17 <ivanm> I'm already using his data-clist package... :p
20:37:58 <katelman> Hi. I have a question about the FFI and was wondering if might find some help here.
20:38:14 <kmc> sure, go ahead
20:38:20 <katelman> my understanding is that C compilers are free to choose a bit representation for NULL
20:38:34 <katelman> which makes me wonder how equality testing with nullPtr works correctly
20:39:14 <kmc> i'd guess nullPtr is defined to be equal to whatever your system's "standard" C ABI uses for NULL
20:39:57 <ivanm> dammit, I can't use EnumMap... because one of the things I use from Data.Map is findMax to get the largest key size currently being used :s
20:40:09 <kmc> could track that separately
20:40:12 <kmc> but yeah, it's an annoyance
20:40:22 <katelman> that sounds reasonable; any idea where that would come from, though?
20:40:47 <ivanm> kmc: oh, wait, it has maxView and minView
20:40:55 <ivanm> looks like it needs updating to use latest containers anyway
20:41:02 <kmc> katelman, the FFI modules are part of the "base" package.  when compiling ghc it will build "base" for your system
20:41:07 <ivanm> well, I've already sent him patches for data-clist; might as well send patches for this as well...
20:41:07 <kmc> and i'm betting those modules are .hsc files
20:41:16 <kmc> which means they run through hsc2hs first, and can get information out of the c compiler
20:42:19 <katelman> I see. So then perhaps it's tied to whatever C compiler ghc chooses during that process?
20:42:29 <kmc> if you're using GHC, nullPtr is defined in GHC.Ptr as nullPtr = Ptr nullAddr#
20:43:01 <ivanm> hmmm, did GHC 7 fix that FFI bug with Double or whatever it was?
20:43:06 <kmc> and nullAddr# is a primitive value produced during compilation of GHC somehow
20:43:16 <kmc> katelman, yeah.  not to the specific compiler but to whatever ABI is in use
20:43:20 <kmc> most platforms have a standardized C ABI
20:43:22 <mauke> katelman: have you ever seen a system where different compilers use different null pointers?
20:43:40 <kmc> such that code from different C compilers can be linked together
20:43:45 <mauke> actually, have you ever seen a platform that uses non-zero null pointers and is supported by ghc?
20:44:24 <katelman> kmc: I see, that question just popped into my mind; makes sense. Thanks.
20:44:27 <katelman> mauke: no, I guess just random anxiety.
20:44:33 <katelman> my code seems to be working.
20:49:38 <katelman> kmc: thanks for the help. now I can sleep comfortably.
20:49:51 <joe6> let databytes = ["80","06","00","01","00","00","08","00"]
20:49:52 <joe6> concat [unwords databytes, " ", unwords $ replicate (8 - (length databytes)) "00"," \n"]
20:49:55 <ivanm> @type (!)
20:49:56 <lambdabot> forall i e. (Ix i) => Array i e -> i -> e
20:50:01 <ivanm> @hoogle (!)
20:50:02 <lambdabot> Data.IntMap (!) :: IntMap a -> Key -> a
20:50:02 <lambdabot> Data.Map (!) :: Ord k => Map k a -> k -> a
20:50:02 <lambdabot> Text.Html (!) :: ADDATTRS a => a -> [HtmlAttr] -> a
20:50:11 <joe6> "80 06 00 01 00 00 08 00  \n"
20:50:33 <joe6> is the output. I am trying to get  "80 06 00 01 00 00 08 00  \n" without the 2 trailing spaces
20:50:45 <joe6> can anyone please help?
20:51:10 <ivanm> do you want the \n ?
20:51:16 <joe6> yes, ivanm
20:51:29 <joe6> i want an if on  unwords $ replicate (8 - (length databytes)) "00"
20:51:35 <ivanm> joe6: well, you have a space or two before the \n in your original code...
20:51:50 <joe6> yes, i just want a " \n" instead of "  \n"
20:51:59 <ivanm> joe6: may I suggest the use of a pretty-printing library?
20:52:50 <monochrom> > intercalate " " ["00", "11", "01", "10"]
20:52:51 <lambdabot>   "00 11 01 10"
20:53:09 <joe6> monochrom: thanks, that helps.
20:53:14 <ivanm> or just unwords
20:53:36 <ivanm> > unwords ["hi", "bye", ""]
20:53:37 <lambdabot>   "hi bye "
20:53:46 <ivanm> OK, it doesn't check if lists are empty or not
20:56:48 <monochrom> unwords (databytes ++ replicate (8 - length databytes) "00") ++ "\n"
20:57:19 <monochrom> (not sure why you unwords two things separately, only to join them together with space again later)
20:58:27 <joe6> monochrom: thanks a lot.
20:59:53 <ivanm> anyone know how to tell darcs to put a repo in a home directory on community.haskell.org?
21:03:22 <ivanm> nvm, it's suddenly letting me know :s
21:03:30 <ivanm> @tell wisepumpkin http://code.haskell.org/~ivanm/planar-graph/
21:03:31 <lambdabot> Consider it noted.
21:04:32 <djahandarie> I really wish c.h.o would send files with a mime-type that let me view them in the browser
21:04:50 <djahandarie> Like text/haskell or something... is that even a type?
21:06:59 <monochrom> the current mime type is text/x-haskell
21:07:32 <ivanm> someone gave me an extension which lets you specify more mimetypes as being equivalent to plain text so that the browser would open them...
21:07:33 <monochrom> this is exactly what prevents you from viewing in the browser.
21:07:36 <ivanm> I forget from where though :s
21:07:50 <monochrom> you want text/plain
21:09:43 * hackagebot improve 0.1.3 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.1.3 (TomHawkins)
21:09:47 <kmc> text/xxx-haskell
21:09:55 <applicative> > let databytes = map text ["80","06","00","01","00","00","08","00"] in hcat (punctuate space databytes) <> space
21:09:55 <lambdabot>   80 06 00 01 00 00 08 00
21:12:41 <MrAI> type Person = (NI, Age, Balance)
21:12:41 <MrAI> type Bank = [Person]
21:12:41 <MrAI> type Market = [Bank]
21:12:58 <MrAI> How would I total all the balance's? I am just unsure how to get to the Balance
21:14:14 <Makoryu> MrAI: let balance (_, _, b) = b in sum (sum . map balance) markets
21:14:43 <Makoryu> MrAI: This can break or use a lot of RAM if you've got very long lists, but it's straightforward
21:14:57 <applicative> or build balance in at the start with obnoxious record syntax?   e.g. data Person = Person { ni :: NI, age:: Age, balance :: Balance}
21:15:29 <MrAI> I see you use 'in' - didnt think of that
21:15:41 <MrAI> Im just starting out applicative ;)
21:15:48 <Makoryu> MrAI: Actually, I almost always use "where" for stuff like that
21:16:16 <Makoryu> But it desugars to let/in anyway :p
21:16:44 <MrAI> I see. I just didnt know how to reference up two levels
21:17:15 <kmc> yeah, "let" and "in" come together
21:17:21 <kmc> except within "do" there's a variant of "let" you can ues
21:18:47 <monochrom> do { x <- getLine; let {y = (let n = length x in n*n)}; print y }
21:20:40 <mjrosenb> aka: do is *tons* of syntatic sugar, so let's throw some more on
21:21:05 * monochrom is just evil, that's all :)
21:21:46 <Makoryu> That's the one thing that really bothers me in Haskell
21:21:55 <Makoryu> The syntactic sugar is so hard to explain sometimes
21:22:57 <kmc> i don't think 'do' is all that sugary
21:23:09 <kmc> though it's more complicated than most people say, because of pattern match failure and 'fail'
21:24:14 <kmc> Makoryu, which bits of sugar do you think are the worst?
21:24:17 <Makoryu> It's just that you have to draw a fucking flow chart to keep track of the many layers of exceptions to syntax rules
21:25:04 <Makoryu> kmc: Hard to say. It's mainly just that there's so much of it and it's everywhere
21:25:10 * mjrosenb thinks it is sugary due to the number of lambdas that a typical do block will expand to
21:26:10 <mjrosenb> there is do, list comprehensions, ?
21:26:12 <kmc> but that's kind of 1:1
21:26:20 <kmc> you already have the parameter name; you already have <- which becomes ->
21:26:22 <mjrosenb> iirc, guards are not really syntatic sugar
21:26:37 <kmc> what do you consider sugar? everything that's not in Core?
21:26:42 <kmc> in that case there's a lot of sugar
21:26:50 <kmc> for example defining functions by multiple equations is sugar
21:26:58 <kmc> pattern-matching in "let" is sugar
21:27:23 <kmc> Makoryu, i'm not sure you can get from "sugar" to "exceptions to syntax rules"
21:27:34 <kmc> for the most part, sugar in Haskell consists of new forms that would be illegal otherwise
21:27:35 <mjrosenb> at least case x of y isn't syntatic sugar for (\ y ) x
21:27:41 <kmc> yeah
21:27:53 <deech> Hi all, is there a way of using functions with their fully qualified name without importing the package? For instance "main = System.getArgs >>= print" without "import System".
21:28:01 <MrAI> Can someone explain this to me please :s http://pastebin.com/EkHU5FyR
21:28:05 <kmc> deech, no
21:28:35 <Makoryu> MrAI: The last line is a list comprehension
21:28:50 <Makoryu> MrAI: This function will examine its arguments, then discard the data and return [[]]
21:28:50 <MrAI> Yep
21:29:10 <MrAI> I know I havent passed in the x <- xs part right
21:29:41 <deech> And is it possible to import things with commas like "import System, Control.Monad.State ..." ? The only reason I ask this silly question is because we have code-golfing competition at work.
21:30:04 <MrAI> Im trying to total the balance of all the Person in all the banks, where the NI is the same
21:30:24 <deech> I have to parse command line args, download and parse JSON in under ten lines.
21:30:54 <pelotom> is MonadZero something that used to exist but no longer does? What's the history of that?
21:30:59 <Makoryu> MrAI: The way to do that, I think, is to first sort by NI, and then group by NI
21:31:22 <Makoryu> MrAI: And then you will have a list of lists of Person values
21:31:41 <mjrosenb> deech: presumably you can write your whole library on a single line
21:31:42 <MrAI> I was thinking if I went through all the NI's against all the banks (looking through all the Person)
21:31:43 <mjrosenb> deech: if that helps.
21:31:56 <Makoryu> I am too tired to help more
21:31:57 <Makoryu> Good night
21:32:16 <deech> mjrosenb: Yeah, but that's a little cheap :)
21:32:39 <mjrosenb> deech: usually "i want to do X in less than Y lines of code" is kinda cheap.
21:33:09 <deech> mjrosenb: Winner get $100. Not so cheap.
21:34:01 <deech> mjrosenb: Also trying to sell Haskell. I'm dealing with a bunch of die-hard Java, Python guys.
21:34:20 <MrAI> Haha good luck with that deech
21:34:24 <applicative> deech, you can do  import A; import B; import qualified C as D
21:34:34 <deech> applicative: Sweet!
21:35:09 <mjrosenb> yeah, in general, '\n' can be replaced with ';'
21:35:27 <applicative> i'm not sure it's in the best taste...
21:35:34 <mjrosenb> although the indenting thing isn't always obvious.
21:36:00 <deech> applicative: taste is a luxury I can't afford :)
21:36:07 <applicative> if you have several things of one type, you can use commas for type declarations: north, south, east, west:: Direction
21:36:27 <applicative> then give the definitions following
21:37:10 <applicative> But I suppose you will want to have as few type signatures as possible, to show off type inference
21:37:53 <mjrosenb> also, *horrible* hack that i've occasionally used
21:38:00 <guest2425> Hello I am having trouble fixing this error message http://pastebin.com/eh9be2Bt
21:38:13 <mjrosenb> (x,y,z) = (13, "hello world", \ x 
21:38:17 <mjrosenb> -> x+1)
21:38:21 <mjrosenb> sans the newline
21:39:29 <mjrosenb> guest2425: do you know what . does?
21:39:36 <applicative> guest2425 how would you write a function "double n" that doubles a number n?  "double n = ..."?
21:40:04 <guest2425> i got it look
21:40:15 <guest2425> add_and_double  x y  = (x + y) * 2 
21:40:18 <guest2425> yeay
21:40:21 <applicative> check
21:40:33 <guest2425> mjrosenb
21:40:39 <guest2425> mjrosenb: yes
21:40:47 <guest2425> let add_and_double  x y  = (x + y) * 2
21:41:01 <guest2425> add_and_double   4 5
21:42:06 <guest2425> applicative: I got it right?
21:42:17 <mjrosenb> guest2425: try it out.
21:42:30 <pelotom> > let add_and_double  x y  = (x + y) * 2 in add_and_double 4 5
21:42:31 <lambdabot>   18
21:42:42 <guest2425> *Main> add_and_double 3 3 
21:42:56 * edwardk waves hello.
21:43:04 <guest2425> let add_and_double  x y  = (x + y) * 2 in add_and_double 3 3
21:43:10 * mjrosenb waves world
21:43:13 <pelotom> guest2425: you can try things out in here by prefixing a haskell expression with ">"
21:43:20 <applicative> > let add_and_double x y = (x + y) * 2 in add_and_double 3 3
21:43:20 <lambdabot>   12
21:43:22 <guest2425> oh ok
21:43:38 <guest2425> >let add_and_double  x y  = (x + y) * 2 in add_and_double 3 3
21:44:00 <guest2425> pelotom: nice
21:44:02 <applicative> or just follow the idea, we want to add then double, the add function is (+), the double function is (*2), so we compose
21:44:02 <djahandarie> You need a space after the >
21:44:12 <applicative> > let ad = (*2) . (+) in ad 3 3
21:44:12 <lambdabot>   12
21:44:22 <guest2425> > let add_and_double  x y  = (x + y) * 2 in add_and_double 3 3
21:44:22 <lambdabot>   12
21:44:45 <guest2425> yes baby
21:44:57 <Funktorsalat> woha downloading ghc is blazing fast now (1800kb/s, which more or less maxes out my pipe)
21:45:15 <edwardk> gah. that damn data RealFloat a =>  constraint on Complex bit me again
21:45:29 <djahandarie> edwardk, what're you up to?
21:45:41 <guest2425> mjrosenb: guest2425: do you know what . does?   = Function composition
21:45:58 <edwardk> djahandarie: just got bored and implemented a bunch of small vector combinators in the style that Roman posted up to his blog the other day.
21:46:16 <djahandarie> I think he plans on releasing a package for that
21:46:22 <djahandarie> Don't beat him to it ;)
21:46:24 <deech> guest2425: check out your pastebin
21:46:58 <guest2425> deech: why?
21:47:01 <edwardk> djahandarie: in the process i noticed that you can obviously build a definition for foldMap for any valid Vector v a, but the constraint on Complex keeps you from making an instance of Foldable for Complex
21:47:26 <djahandarie> Hmmm
21:47:28 <djahandarie> That's annoying
21:47:29 <edwardk> djahandarie: not planning on it. though we have slightly different tastes in api design, so i felt it was worth exploring what typeclasses CAN be implemented
21:47:49 <deech> guest2425: I just added an amendment to your function. But I guess you've solved your problem
21:48:04 <guest2425> deech: is working now
21:48:16 <deech> guest2425: Ok cool.
21:48:30 <guest2425> thank you do
21:48:40 <edwardk> djahandarie: up until Complex bit me in the ass for no reason other than historical accident, I was all gung ho to make the class constraint on vector look like class (Arity (Dim v), Foldable v) => Vector v a where ...
21:49:16 <djahandarie> lol
21:49:38 <edwardk> djahandarie: i was playing with it because i have my shiny blas bindings that could really benefit from a decent 'small vector' interface like this
21:49:55 <djahandarie> Oh by the way, do you know why the data family newtype instance version he said was inefficient can't be optimized?
21:50:12 <djahandarie> It seems very similar to what he did manually
21:50:24 <djahandarie> (Wrapping the type family with a newtype)
21:51:17 <edwardk> its a bit of a mess. i ran into something similar a while back, but never tracked it down
21:51:44 <edwardk> in one case the compiler keeps unrolling, i presume because it has some inductive principle telling it to stop
21:53:25 <edwardk> anyways, to make sure i understood it i implemented a bunch of other combinators, cons, fmap over the Fun type, etc.
21:53:31 <lispy> zeno is pretty cool
21:53:42 <lispy> it appears simple, elegant, and powerful
21:53:49 <lispy> I'm quite impressed
21:54:56 <edwardk> djahandarie: http://hpaste.org/41637/romanstyle_vectors
21:56:10 <edwardk> the new hpaste is sexy
21:56:17 <edwardk> when did that come along?
21:56:22 <djahandarie> Awhile ago
21:56:25 <djahandarie> Thanks to chrisdone
21:56:30 <djahandarie> Who rarely is in here anymore
21:56:42 <edwardk> well, he's done ;)
21:56:47 <MrAI> Can someone help out with http://pastebin.com/EkHU5FyR please.
21:57:51 <edwardk> djahandarie: any ideas for a faster zipWith? i can't think of one given the approach roman described
21:59:10 <pelotom> MrAI: what's your question?
22:00:04 <MrAI> I need to sum up all the Person, where the NI is an input. And a person may have different accounts in different banks
22:00:09 <MrAI> e.g. market
22:00:17 <kmc> edwardk, yeah, the new hpaste does hlint which is *fantastic*
22:00:28 <kmc> if you read ndm's hlint documentation, it's exactly how he wanted it to be used
22:00:47 <edwardk> kmc:  the hlint piece was what made me sit up and take notice
22:01:08 <kmc> other than that, nice UI, doesn't go down as much, etc
22:02:08 <MrAI> I've got creditNI ni market = sum [x| (x) <-[ni], bank <- market] this far now
22:02:21 <kmc> MrAI, [ni] is a one-element list
22:02:24 <kmc> whose only element is ni
22:02:28 <kmc> that's probably not what you want
22:02:36 <MrAI> Oops
22:02:39 <kmc> i've seen a lot of beginners who think you need [brackets] whenever you're using a list
22:02:48 <kmc> you need them when you're *creating* a list
22:02:57 <MrAI> My biggest mistake at the moment, lol
22:02:59 <kmc> or when you're pattern-matching a list by an *exact* number of arguments
22:03:29 <pelotom> kmc: or when you're talking about the type of lists... I think neophytes have a lot of trouble distinguishing list type signatures from list terms
22:03:44 <guest2425> Hello I am getting an error message http://pastebin.com/tmE0d229
22:04:36 <djahandarie> edwardk, hmmm. Not immediately. Although I think there might be another way to write this zipWithF
22:06:16 <edwardk> http://hpaste.org/41638/hlint_fixes
22:06:55 <edwardk> djahandarie: yeah, though, i'm building a Fun that returns a Fun, so i can't think of a nice way other than  a pair of accum's
22:07:23 <edwardk> though i could arguably consume the argument fun building up the first result that way
22:07:35 <edwardk> i was trying to dodge the reversal
22:07:49 <edwardk> but it doesn't look doable
22:09:35 <Orclev> Anyone happen to know if theres any effort going on to port ghc to android? I'm aware of a project for iPhone
22:09:51 <edwardk> Orclev: talk to kmc ;)
22:09:54 <guest2425> Hello I am getting an error message http://pastebin.com/tmE0d229
22:12:09 <kmc> yeah i've been working on it
22:12:19 <kmc> for these guys: http://ipwnstudios.com
22:12:32 <Orclev> Kmc
22:13:05 <kmc> Orclev
22:13:22 <geheimdienst> never developed for android, but wouldn't clojure be a good match for the javaish vm they have?
22:14:01 <Orclev> kmc: cool, hows it coming... Sorry, using an android based irc client and its a bit fiddly
22:14:52 <edwardk> geheimdienst: i'd probably go to scala before clojure, warts and all
22:15:10 <Orclev> yeah, or scala, but I prefer haskell, why settle for second best ;)
22:15:31 <onteria> "It's time to write server software in #haskell, thanks to new I/O manager in GHC! <link>" click on link: "500 Internal Server Error"
22:16:13 <pelotom> onteria: yes, but did you see how fast the response came back?
22:16:15 <kmc> Orclev, coming along pretty well
22:16:21 <kmc> it's mostly done but i need to get off my ass and finish it
22:16:33 <geheimdienst> edwardk: hm ... i found clojure fairly accessible, even though i hadn't used a lisp before. scala however seemed pretty complicated to me and i lost interest
22:16:39 <kmc> hahaha onteria
22:16:46 <kmc> Orclev, i think it'll be open source when finished
22:16:58 <geheimdienst> onteria: what part of "new" don't you understand?
22:17:00 <geheimdienst> ;)
22:17:08 <Orclev> That wad my next question
22:17:17 <Orclev> Was even
22:17:30 <pelotom> geheimdienst: lisp is like haskell with more parens and fewer compile errors!
22:17:42 <onteria> geheimdienst: Oh I've got a good idea of "new" from trying to get many things to compile under ghc-7
22:18:08 <Orclev> Compile errors are good, they mean fewer runtime errors
22:18:22 <kmc> compile errors are bad.  i just program without making mistakes, it's so easy
22:18:28 <kmc> ;)
22:18:46 <djahandarie> kmc, I had some people claiming that the other day when I was trying to list some benifits from Haskell
22:18:50 <djahandarie> edwardk, what I tried to do failed
22:18:52 <djahandarie> So, not sure :P
22:19:17 <Orclev> sadly I had someone say that to me once seriously
22:19:21 <pelotom> Orclev: you're preaching to the choir :P
22:20:06 <djahandarie> I wonder if you could do anything useful with even/odd indexed peano numbers...
22:20:26 <pelotom> dynamic languages are for young programmers who can remember everything and resent the authority of the compiler
22:20:42 <edwardk> djahandarie: just flagging if they are even or odd?
22:20:54 <djahandarie> Unrelated to the current problem :P
22:21:03 <Orclev> This client is nice in a pinch but a bit painful... Think I'll dig out my laptop
22:21:04 <djahandarie> Just popped into my head randomly and violently O.o
22:21:21 <edwardk> djahandarie: if you are going there just do infinite precision 2's complement ;)
22:21:58 <djahandarie> Infinite precision 2's complement?
22:22:01 <edwardk> data Zero a; data One a; data Zeros; data Ones
22:22:33 <MrAI> Kinda boom :D creditNI market = sum [c| [(a,b,c)] <- market]
22:22:38 <edwardk> or data CoInt = Zero CoInt | One CoInt | Zeros | Ones
22:23:26 <djahandarie> ... it isn't clear to me what this is representing. What would Zero Zero Zero Zero Ones be?
22:23:39 <onteria> Oh my... I attempted to see out of curiousity if ghci would allow me to run product on an infinite list. Let's not do that again...
22:23:42 <edwardk> Ones == 1, Zeroes = 0, One a = 2 * a + 1; Zero a = 2 * a
22:23:52 <djahandarie> Ahh
22:24:33 <edwardk> think of ones being an infinite chain of msb ones, and zeroes being an infinite chain of msb zeros
22:24:55 <edwardk> One Ones == Ones; Zero Zeroes = Zeroes
22:25:10 <edwardk> so normalize them away and store the rest
22:26:01 <djahandarie> Is it even possible to control when certain evaluation happens for the type families?
22:26:06 <pelotom> someone said there is a way to target iOS with haskell?
22:26:34 <edwardk> djahandarie: there is a dirty hack with ~ that can make lazy-ish type families, but its probably a bug =)
22:27:00 <orclev> pelotom: there was a project aiming to do that, but I don't know what kind of status it's in
22:27:14 <djahandarie> It'd be interesting (useful?) to have a way to do that
22:27:20 <kmc> pelotom, you don't have to be old to learn that you can make mistakes
22:27:42 <pelotom> orclev: do you know what it's called?
22:27:45 <kmc> pelotom, http://projects.haskell.org/ghc-iphone/
22:27:56 <orclev> pelotom: what kmc just said
22:27:57 <kmc> pelotom, Cale is working on the actual iPwn game and has been doing builds recently
22:28:01 <kmc> so he might could help you set up the compiler
22:28:27 <pelotom> kmc, orclev: again, preaching to the choir :)
22:28:37 <djahandarie> It'll be interesting to see what insights Cale has about game programming by the time he's done with this
22:28:55 <orclev> pelotom: lol, I meant about the ghc-iphone link
22:29:05 <djahandarie> "Game programming is just a dodecahedrolite on a sphere!"
22:29:16 <pelotom> kmc: thanks, is Cale's thing on github or something?
22:29:40 <kmc> dunno
22:29:59 <edwardk> better than mine: 'its just a zygohistomorphic prepromorphism!' doesn't seem to go over very well ;)
22:30:27 <orclev> I keep thinking I want to right a game, but I realize I've barely got enough free time to do the odd programming experiment, and I kind of shelve the idea for another day
22:30:30 <djahandarie> Yeah, that's obviously zygohistoprepromorphism* get it right
22:30:41 <orclev> ... write
22:31:06 <orclev> my brain doesn't work as well as it used to at 1:30 in the morning
22:31:08 <pelotom> orclev: same here
22:32:02 <pelotom> that nikki game looks fun
22:33:17 <orclev> #haskell is the only place I regularly visit that makes me feel like I know absolutely nothing about math... I'm not sure if that's a reflection of the level of math knowledge in the haskell community, or the lack of math knowledge in my normal hangouts
22:33:51 <pelotom> http://vimeo.com/13228822
22:33:56 <djahandarie> Both!
22:33:58 <pelotom> although there's not much to that video
22:34:01 <djahandarie> Well, entirely depends!
22:36:08 <pelotom> orclev: if you really want to feel like you know absolutely nothing about math, try http://mathoverflow.net/
22:36:15 <orclev> hmm... did you link that nikki game because it's being developed in haskell, or just because it's an iteresting CC licensed game?
22:36:17 <pelotom> sorry
22:36:25 <pelotom> oops, wrong window
22:36:37 <pelotom> orclev: the former
22:36:37 <orclev> pelotom: yeah, I've been there... my brain melted
22:38:08 <orclev> pelotom: any idea what graphics API is being used? It looks like some sort of sprite library, so I'm guessing SDL?
22:39:33 <pelotom> orclev: nope, I don't know
22:40:34 <orclev> pelotom: found the website for the game... says they're using Qt, with the OpenGL backend and chipmunk physics engine... never heard of chipmunk before, but my field isn't games dev so no surprise there
22:42:45 <pelotom> orclev: ah yes, I think I remember that now
22:43:02 <pelotom> http://hackage.haskell.org/package/Hipmunk
22:43:47 <pelotom> playing with a physics engine sounds fun
22:44:13 <orclev> pelotom: yeah, it was linked off their site... already installing the HipmunkPlayground package... GLFW looks interesting and answers a long standing question I've had about what to partner OpenGL with to more equally match DirectX
22:49:07 <orclev> :(... HipmunkPlayground fails to build on the linking stage, looks like some library it depends on is out of date on my system... anyone happen to know a simple way to figure out which C library a particular function belongs to?... just google it?
22:49:19 <orclev> linux btw
22:55:15 <pelotom> orclev: ouch
22:55:28 <pelotom> orclev: you can try installing nikki itself
22:55:42 <pelotom> I mean building the source
22:56:33 <orclev> pelotom: I googled the function, and it looks like it's one of the chipmunk library functions, so it looks like maybe hipmunk installed the chipmunk .so's incorrectly or something...
22:57:23 <pelotom> orclev: maybe a 32/64-bit thing?
22:58:00 <orclev> pelotom: ah, hadn't considered that... could be... although I figured it would have built the libraries from source
23:08:00 <ddilinger> @src sum
23:08:04 <lambdabot> sum = foldl (+) 0
23:21:07 <gueux> monochrom: ok for the bug with the bigger hex string, thanks :-)
23:28:23 <gueux> monochrom: could you give me the bug reference, so that I can ask for an upgrade of debian testing's ghc?
23:31:45 <JoeyA> What is one programming language where the Y combinator (\f -> (\x -> f (x x)) (\x -> f (x x))) works, unmodified? (of course, the syntax may be different)
23:41:01 <ziman> if you consider untyped lambda calculus a programming language, then, there. :)
23:41:42 <kmc> scheme
23:41:48 <kmc> or other lisps
23:42:02 <kmc> JoeyA, http://www.ece.uc.edu/~franco/C511/html/Scheme/ycomb.html
23:42:16 <kmc> there's a fragment of scheme which is very close to the untyped lambda calculus
23:43:21 <kmc> it depends on what you consider "unmodified" and "different syntax"
23:44:18 <kmc> you can write the Y combinator in Javascript; the syntax is a lot more verbose but the structure is the same
23:45:31 <ziman> hm, don't you need non-strictness for Y?
23:46:21 <kmc> ah, good point
23:46:39 <kmc> reading that link i just pasted
23:47:02 <kmc> i guess the applicative-order version of Y is expanded to avoid this problem
23:47:44 <kmc> so try Lazy Scheme or Lazy Racket or whatever it's called now
23:50:27 <dibblego> @where hayoo
23:50:28 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
23:50:37 * kmc starts writing out the Y combinator in C++ but gets bored at about the 25th line of code
23:51:02 <JoeyA> lol
23:51:25 <JoeyA> My lambda calculator lets you do the Y combinator.  It was one of the first things I tested :-)
23:51:39 <JoeyA> But I added fix and recursive let later on, simply because they're much faster.
23:52:06 <JoeyA> (it's a dynamically-typed Haskell half-clone I've been working on)
23:52:22 <JoeyA> (and runs on the TI-89 calculator)
23:57:42 <mm_freak> kmc: in C++0x (or 1x) the Y combinator is easy to write, but you have to write multiple versions
23:57:53 <mm_freak> because of missing currying
