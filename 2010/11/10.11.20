00:07:11 <ddarius> @hoogle listToMaybe
00:07:12 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
00:11:28 <kmc> aka safeHead ;)
00:18:04 <guest2425> Hello
00:55:24 <Palmik> Hi guys, could you give me a hint how to effectively store ([Bool], Map a [Bool]) in binary format? I have used Data.Binary, but the result is too big... I suspect that [Bool] is not really saved as a list of bits
00:57:03 <lars9> is there any research on haskell-machine like the lisp-machine?
01:03:59 <ddarius> @where reduceron
01:03:59 <lambdabot> http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
01:09:02 <ddarius> Palmik: Don't use the Binary class if you care about representation, directly use the Put monad.
01:09:16 <kmc> Palmik, did you try gzip?
01:09:19 <kmc> import qualified Codec.Compression.GZip as Z
01:09:24 <kmc> Bin.decode . Z.decompress
01:09:28 <kmc> Z.compress . Bin.encode
01:09:36 <ddarius> Palmik: If you want to be lazy, though, you could newtype wrap [Bool] and implement your own Binary instance that does something better.
01:09:47 <Palmik> kmc, I did, but that is not really a solution, but thanks.
01:09:53 <Veinor> yeah, gzip sou nds like it could handle the whole 'True, True, False' -> '110' issue nicely
01:09:54 <Palmik> ddarius, will poke that, thanks :)
01:10:04 <kmc> i doubt this will shrink it so much, but it's hard to beat for a 3-line change
01:10:08 <kmc> Palmik, why isn't it a solution?
01:11:11 <Palmik> Well, because the program itself should be implementation of huffman coding and when the "compressed" result is bigger that the source I need to look for improvements elsewhere :P
01:11:22 <kmc> hehe
01:11:24 <kmc> okay
01:11:39 <kmc> Integer has a Bits instance; that may be useful in writing the packing transformation [Bool] <-> [Word64]
01:12:13 <kmc> wtf does the Integer Bits instance do for negative numbers
01:12:23 <kmc> infinite prefix of 1s?
01:12:35 <Palmik> Thanks :)
01:13:14 <ddarius> kmc: Probably.  complement 0 = -1
01:13:48 <kmc> i don't think Binary is meant to be particularly space-efficient
01:13:55 <kmc> since it can be composed with gzip so easily
01:14:09 <kmc> => you may want to roll your own
01:14:20 <Palmik> I guess so :/
01:15:11 <ddarius> kmc: The Binary -class- isn't.  Otherwise, it's whatever you implement, though it is definitely not geared/intended for sub-byte processing.
01:15:20 <kmc> yeah
01:15:38 <kmc> using the Binary class with a map-like structure containing integers and small fragments of text, i got a roughly 5x compression out of gzip
01:16:15 <Axman6> :o
01:16:30 <Axman6> interesting to know how wasteful the Binary instance is
01:16:53 <kmc> single uncontrolled anecdotal report etc.
01:17:45 <ddarius> Axman6: The Binary class is supposed to be quick and simple (and generic) binary serialization.
01:18:02 <kmc> most of the bytes in my file are 0
01:18:06 <Axman6> i wrote a fairly efficient Binary instance for my TernaryTrees package which encoded which elements of the tree were emptyor had subtrees using bits in the Node's header byte
01:18:23 <kmc> i suspect it's writing 64-bit Ints as-is
01:18:33 <kmc> when the values are in the <100,000 range
01:19:07 <Axman6> things like Int, Intn,Word etc are all represented pretty efficiently
01:19:12 <kmc> don't know how it handles Char
01:19:29 <kmc> for that matter i don't remember how GHC represents Char
01:19:33 <kmc> UTF-32?
01:19:33 <Axman6> i believe it writes them out basically as utf-8
01:19:39 <kmc> ok
01:19:46 <Axman6> might not be 8, could be 16
01:19:57 <Axman6> but whatever it is, it is a variable sized encoding i think
01:20:02 <kmc> my file seems to contain printable ASCII so i bet Binary uses UTF-8
01:20:23 <kmc> still a lot of redundancy in text
01:21:14 <kmc> i really like how easily gzip composes with binary
01:21:47 <kmc> i suspect that's a better solution than writing clever (possibly slow) Binary instances, for most apps
01:22:03 <kmc> but if you're writing a compression utility, it's a different story ;)
01:23:09 <kmc> uncompressed Binary was a lot faster and smaller than my previous approach
01:23:28 <kmc> "deriving (Read, Show)"
01:23:33 <ddilinger> if i was trying to import listArray and ! only, how would i do that? import Data.List (listArray, !) gives error, i need something special for infix?
01:23:42 <kmc> (listArray, (!))
01:23:54 <kmc> when you want to refer to an operator itself, you enclose in parens
01:24:01 <kmc> :t (+)
01:24:02 <lambdabot> forall a. (Num a) => a -> a -> a
01:24:14 <kmc> otherwise it parses as the operator being applied to arguments
01:24:14 <ddilinger> ahh, yea i've used that for other things didn't think of that here, of course its the same all over :)
01:24:30 <kmc> yeah, Haskell syntax is pretty consistent overall
01:24:47 <kmc> not a particularly small grammar, but consistent
01:26:43 <kmc> sleep bbl
01:34:34 <Causalien> Night people
01:44:40 <McManiaC> huh?
01:44:41 <McManiaC> [5 of 8] Compiling Data.ByteString  ( Data\ByteString.hs, dist\build\Data\ByteString.o )
01:44:44 <McManiaC> Data\ByteString.hs:1959:21: Parse error in pattern
01:45:05 <Axman6> :o
01:45:31 <McManiaC> latest bytestring-0.9.1.8
01:46:59 <McManiaC> anyone else getting that error?
01:47:16 <Axman6> i'll try in a sec. which ghc?
01:48:00 <McManiaC> 6.12.3
01:49:01 <Axman6> hmm, how odd
01:55:25 <McManiaC> got it to build?
01:55:42 <Nibble> hm?
01:58:00 <Entroacceptor> McManiaC: same error here
01:58:10 <Entroacceptor> ghc 6.12.3
01:58:13 <McManiaC> hmhm
01:58:20 <McManiaC> someone fucked up ;)
01:59:07 <pirateunderwear> lol
02:05:25 <Axman6> McManiaC: it seems to have built find for me in the last few days on ghc 7.0.1
02:18:29 <Axman6> oh hooray, i missed that "import Foo as F" now works in ghci :D
02:19:34 <handonson> I want to obtain the 'current time' twice at the different places of the code, calculate the diff, humanize (format) it and print. What is the recommended way (not the deprecated/platform-dependent way) to do this?
02:20:09 <Axman6> handonson: in what context?
02:20:19 <handonson> no context
02:20:23 <handonson> just the general way
02:20:53 <Axman6> i mean what file, something you're reading in, or a haskell source file?
02:21:03 <handonson> like, timing a specific HTTP request/response action?
02:21:10 <handonson> file? what file?
02:21:24 <Axman6> oh, i read current line -_-
02:21:48 <Axman6> well, doesn't the time package give you a way to do that? (that's shipped with ghc afaik)
02:22:00 <handonson> The only thing I can get with the time-1.1.4 library is of type NominalDiffTime, which I have no idea how to handle
02:22:34 <handonson> It's not an instance of FormatTime class, for example.
02:23:09 <handonson> I can't see any function that converts NominalDiffTime into something else, either.
02:23:29 <Axman6> well, there's plenty of examples out there of how to get the difference between two times and print them, take those and change them to suit your needs i guess
02:23:43 <Axman6> what's the definition of NominalDiffTime?
02:23:57 <Axman6> @hoogle NominalDiffTime
02:23:58 <lambdabot> Data.Time.Clock data NominalDiffTime
02:24:00 <handonson> not exposed, I think.
02:24:08 <Axman6> @src NominalDiffTime
02:24:09 <lambdabot> Source not found. Are you on drugs?
02:24:12 <Axman6> :\
02:25:28 <handonson> The examples I can find are all with System.Time which is provided by old-time which is deprecated and recommended not to be used any more
02:26:20 <handonson> so I thought I'd learn the new recommended way
02:31:16 <handonson> hmm, NominalDiffTime is an instance of Num... but that doesn't give me any way to format it properly...
02:32:01 <el_> hello
02:32:52 <Axman6> 'lo el_ 
02:34:09 <el_> when i open new xterm (S-M-Enter) it does not take focus sometimes
02:35:01 <Axman6> is this related to haskell?
02:35:07 <el_> xmonad
02:35:30 <Axman6> have you asked in #xmonad?
02:35:30 <Ke> there is #xmonad
02:35:49 <dibblego> who's asking what in #xmonad?-
02:36:03 <dibblego> http://paste.pocoo.org/show/293857/ ?
02:36:40 <el_> thanks. i'm moving to #xmonad
02:39:20 <Axman6> McManiaC: after reading http://new-www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html it seems that the latest ByteString is supposed to be used with 7.0.1 (it was released with it)
02:40:55 <pille456> hey ho! I try to delete every element in a list, for which is p(x) false, where p is some boolean function and x an element of this list, but only using the foldl function.  imo this is quite easy without using the foldl function, but i have to. my idea is to give the foldl function a function f which does not return an element, but a list of elements.This doesnt work so well. ghci says "cannot construct the infinite type: b = [b]"
02:41:02 <McManiaC> Axman6: ok, thanks
02:41:29 <dibblego> pille456, I think you want foldr not foldl
02:41:44 <McManiaC> so its about time for the haskell platform to update to ghc 7 :)
02:42:38 <Axman6> pille456: as dibblego says, foldr is much more suitable. if you must use foldl, you may have to reverse the list after you've filtered it
02:43:10 <Axman6> McManiaC: i think they updates are supposed to be 6 months out of sync. i don't like this however. (i may also be wrong, but i remember seeing that somewhere)
02:44:14 * hackagebot quick-generator 0.1 - Generator random test data for QuickCheck  http://hackage.haskell.org/package/quick-generator-0.1 (YuriyIskra)
02:44:19 <pille456> dibblego, axman6: hm yeha think so too, but it does not seem to work either. look at this: http://pastebin.com/CKcdY3QM
02:44:45 <Axman6> pille456: is this a school project btw?
02:44:51 <Axman6> /homework?
02:45:08 <dibblego> pille456, myFunc is pretty close (you should delete f)
02:45:11 <Axman6> :t foldr
02:45:11 <pille456> Axman6: yeha it is... in any other case i wouldnt use foldl/r in this way :o
02:45:12 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
02:45:35 <Cale> foldr is pretty suitable for writing filter
02:45:48 <McManiaC> Axman6: yep... I would update by hand but I'm kinda scared to break something :)
02:45:59 <Axman6> pille456: replace x with [] and xs by (x:xs)
02:46:51 <Axman6> > let filt p = foldr (\x -> if p x then (x:) else id) [] in filt even [1..10]
02:46:52 <lambdabot>   [2,4,6,8,10]
02:46:59 <Cale> pille456: You can think of foldr f z as replacing each (:) in the construction of a list with a replacement function f, and an [] at the end (if any) by z. Here you'll want to replace (:) with a function that tests if the condition passes or not before adding the element to the list.
02:47:18 <McManiaC> Axman6: it's even saying "Next release: January 2011 
02:47:25 <McManiaC> " on the platform website
02:47:27 <McManiaC> ups
02:47:38 <pille456> Axman6: hm all right, seems to work.. ;) thank you! give me a moment to think about this, maybe i'll ask later something more *g*
02:48:00 <Axman6> pille456: make sure you do understand why that works
02:48:09 <pille456> Cale: Hm thank you, too! ;) this sounds pretty understandable
02:48:15 * hackagebot cmdargs 0.6.4 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.6.4 (NeilMitchell)
02:48:26 <pille456> Axman6: yeha i'm working on it
03:25:10 <ddilinger> can the following be combined, it seems like this will walk the same list twice:  xa = takeWhile (==c) x', xn = dropWhile (==c) x'
03:26:59 <dibblego> ddilinger, see span and break
03:28:06 <ddilinger> dibblego: thanks
03:42:51 <aristid> :t span
03:42:52 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:42:53 <aristid> :t break
03:42:53 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:43:17 <aristid> > span (==0) [0,0,1,1,0]
03:43:17 <lambdabot>   ([0,0],[1,1,0])
03:43:25 <aristid> > break (==0) [0,0,1,1,0]
03:43:26 <lambdabot>   ([],[0,0,1,1,0])
03:43:46 <aristid> > break (/=0) [0,0,1,1,0]
03:43:47 <lambdabot>   ([0,0],[1,1,0])
03:44:05 <aristid> span = break . not
03:57:58 <handonson> man, what did they mean when they made Data.Time.Clock?
03:58:29 <handonson> all I want to do is to get a time diff and format it properly for printing
03:58:45 <handonson> and I can't for the life of me find any way to do this
03:59:11 <Axman6> are you sure that just printing the result isn't good enough?
03:59:52 <aristid> handonson: Data.Time.Format?
04:00:07 <handonson> aristid: NominalDiffTime is not an instance of FormatTime
04:00:55 <handonson> Axman6: it's like "27723.2892s" which is not readable for us
04:01:12 <Axman6> hmm
04:02:16 <aristid> handonson: NominalDiffTime is an instance of Num, and it encodes seconds
04:02:30 <aristid> handonson: are seconds difficult too difficult to deal with? :P
04:03:16 <aristid> and what's not readable about "27723.2892s"?
04:03:44 <handonson> readable as in human readable
04:04:03 <handonson> what i want is like "2 days 3 hours 32 minutes ..."
04:04:23 <handonson> how do I extract that seconds value to, say, Float?
04:05:22 <aristid> toRational, for example
04:05:32 <aristid> maybe timeToTimeOfDay or so would help, too
04:05:38 <Axman6> well, you could hack it and say read . init . show $ x :: Float
04:06:33 <handonson> Axman6: :) yeah that's similar to what i'm doing right now, but i really feel like i shouldn't do this
04:07:01 <aristid> fromRational . toRational
04:07:13 <aristid> if it really needs to be a Float
04:07:37 <handonson> hmm yeah
04:07:45 <handonson> it's also an instance of Real
04:07:46 <aristid> handonson: but why do you complain instead of just reading the docs and looking which instances NominalDiffTime has?
04:08:15 <handonson> aristid: because the docs didn't give me anything
04:08:45 <aristid> handonson: huh? they show which instances NominalDiffTime has. and if they don't show it, ghci shows the instances
04:09:14 <handonson> aristid: really? the docs shipped with my ghc didn't.
04:09:24 <aristid> handonson: but maybe it's easiest to convert your time to a LocalTime
04:09:31 <aristid> well, i always use the docs on hackage
04:10:06 <aristid> utcToLocalTime utc
04:10:11 <aristid> now you have a TimeOfDay
04:10:13 <handonson> mine only said "This is a length of time, as measured by UTC..." and didn't list the instances at all. never thought it could be different on hackage
04:10:27 <aristid> handonson: even if not, ghci can show you them
04:11:21 <aristid>  :t utcToLocalTime utc
04:11:21 <aristid> utcToLocalTime utc :: UTCTime -> LocalTime
04:11:42 <aristid>  :info LocalTime
04:11:42 <aristid> data LocalTime = LocalTime {localDay :: Day, localTimeOfDay :: TimeOfDay}
04:12:08 <aristid>  :info TimeOfDay
04:12:09 <aristid> data TimeOfDay = TimeOfDay {todHour :: Int, todMin :: Int, todSec :: Data.Fixed.Pico}
04:12:41 <handonson> i still think the docs should have included the proper instruction to handle NominalDiffTime values (like "use realToFrac to extract the seconds value"), instead of just listing a bunch of instances
04:14:45 <aristid> handonson: there's always some use case the author of the docs didn't think of. and the reference docs should not be a huge collection of examples
04:15:21 <aristid> it should be a starting point, where with a small amount of effort, you can find a solution to your problem, even if it is not presented on a silver plate
04:15:50 <handonson> aristid: that's a straw man argument. the NominalDiffTime docs does not include *any* example at all
04:16:17 <handonson> and you're worried about a 'huge' collection of examples?
04:16:53 <aristid> i found a faster way to find your TimeOfDay
04:16:56 <aristid>  :t timeToTimeOfDay . utctDayTime
04:16:56 <aristid> timeToTimeOfDay . utctDayTime :: UTCTime -> TimeOfDay
04:18:34 <aristid> handonson: i just happen to think that the time package is quite excellent, and deserves a better reputation than it has
04:22:27 <handonson> it is! i just... couldn't figure out how to use it by myself.
04:26:01 <aristid> there should be a function for converting from NominalDiffTime to DiffTime tho
04:28:20 <handonson> aristid: (secondsToDiffTime . round . realToFrac) works, but it's not a precise conversion
04:28:22 <MiggyX> Hi guys - does anyone happen to know off hand where the concept of pure / impure functions originated?
04:28:54 <handonson> i wonder what would be the way to extract the picoseconds value of NominalDiffTime
04:29:23 <aristid> handonson: fromRational . toRational works too
04:30:06 <aristid> Rational is a good fit for both DiffTime types, because they are decimal fixed-precision types internally
04:32:06 <ddarius> @src realToFrac
04:32:07 <lambdabot> realToFrac = fromRational . toRational
04:32:41 <handonson> what the... seriously?
04:32:49 <aristid> ddarius: why was i not aware of that function?
04:36:50 <handonson> then what would be the proper way to format a time diff?
04:42:01 <aristid> if you have a NominalDiffTime, show . timeToTimeOfDay . realToFrac gives you something like "10:22:54.33"
04:43:04 <aristid> handonson: note that TimeOfDay is also an instance of FormatTime, so you can use formatTime instead of show
04:44:56 <dibblego> is there anything I can do about transformers-0.2.2.0 and category-extras-0.53.5 conflicting with Monad/Applicative instances for Either?
05:01:07 <handonson> aristid: that's neat, but it would clamp everything to 24 hours because timeToTimeOfDay does
05:01:58 <aristid> handonson: oh, i was not aware of that limitation :)
05:03:04 <handonson> well, it's the correct behavior since TimeOfDay represents a moment within a day
05:03:46 <nocture> hi all, i got a tiny question... can you relate lazy patterns (~pattern) to some kind of unification process as in prolog ?
05:03:48 <handonson> System.Time has formatTimeDiff... which makes me feel less attracted to Data.Time :(
05:03:54 <aristid> handonson: you can use divMod' (from Data.Fixed) to count days
05:05:05 <aristid> given that you use NominalDiffTime, there should be no problems with leap seconds either (because they are ignored by all computations which return NominalDiffTime)
05:05:16 <mreh> where should I start looking for detecting if files already exist before writing them?
05:05:28 <mreh> I've never really gotten deep into haskell IO
05:05:32 <handonson> mreh: System.Directory
05:05:53 <mreh> I was poking around in System.IO, that must be why I didn't find anything
05:05:59 <handonson> doesFileExist :: FilePath -> IO Bool
05:06:07 <aristid> race condition
05:06:53 <mreh> handonson: got it, thanks
05:07:08 <handonson> once i had trouble locating that function too
05:07:13 <handonson> with exactly the same reason
05:07:21 <mreh> never again huh?
05:07:37 <mreh> monadic IO is the shizzle for command line programs
05:09:03 <handonson> aristid: maybe I should write myself a formatDiffTime function
05:09:22 <aristid> handonson: sure
05:09:35 <aristid> or maybe formatNominalDiffTime
05:11:06 <mreh> high five?
05:13:16 <mreh> haskell programs should be art, however I can't find a suitable construct for conditionals in monadic code that don't do anything when it fails
05:13:22 <mreh> when the condition fails
05:13:38 <mreh> my solution is ugly
05:13:39 <aristid> :t when
05:13:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:13:47 <hpc> @src when
05:13:47 <lambdabot> when p s = if p then s else return ()
05:13:54 <Botje> @src unless
05:13:55 <lambdabot> unless p s = if p then return () else s
05:14:20 <hpc> the other one i like is when' p s = if p then s else return mempty
05:14:42 <mreh> :t when'
05:14:43 <lambdabot> Not in scope: `when''
05:14:51 <hpc> when' :: (Monoid a, Monad m) => Bool -> m a -> ma
05:14:54 <hpc> *m a
05:15:09 <hpc> there's so many instances of Monoid that it works pretty well
05:15:27 <hpc> (except for the lack of Monoid for unwrapped nums...)
05:17:31 <hpc> what's funny is that when' is a strict generalization of when
05:17:42 <hpc> @instances Monoid
05:17:42 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
05:17:58 <aristid> hpc: unfortunately no default instance for Maybe :/
05:18:09 <aristid> i mean the wrong default instance.
05:18:32 <hpc> mempty = Nothing, mappend = fmap mappend?
05:19:15 <aristid> hpc: yeah. i would prefer First to be the default instance.
05:19:52 <hpc> doesn't that instance break the monoid laws anyway?
05:20:02 <hpc> foo `mappend` mempty = foo?
05:20:14 <mreh> I don't understand how () is a Monoid
05:20:53 <mreh> what's the operation in this case?
05:20:55 <aristid> mempty = (); mappend _ _ = ()
05:21:17 <aristid> well, perhaps mappend x _ = x is better
05:21:28 <mreh> right, I forgot how Monoids were defined
05:23:58 <pkrumins> @instances Functor
05:23:58 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
05:26:49 <mreh> has anyone writen a helpful command line tool library?
05:27:07 <mreh> I'm just thinking how useful it would have to make generatlised input prompts and such
05:27:30 <mreh> not sure if it warrants a whole library
05:28:09 <hpc> i think it does
05:28:24 <hpc> it can be non-trivial if you want something easy to use
05:28:57 <Botje> defaults, choices, abbreviations .. the works :)
05:29:18 <hpc> you can also make it cover standard input
05:29:38 <hpc> something neat might be an HTTP-like method of providing options
05:29:54 <pkrumins> Botje: meow to you fine kitster! ~^_^~
05:29:55 <hpc> where you put them into stdin, then use a blank line to end input
05:30:08 <Botje> http://search.cpan.org/~persicom/Term-Prompt-1.04/lib/Term/Prompt.pm # for example
05:30:16 <Botje> pkrumins: m eow to you too!
05:30:22 <hpc> then you could do silly things like piping parameters
05:30:28 <pkrumins> ^_^
05:31:20 <hpc> that's a lot of perl for string manipulation
05:31:21 <mreh> I was just staring at my code that reads the first character of the user input for a y or an n, thinking this could be put somewhere else
05:31:49 <mreh> could you put all those ideas on the wiki?
05:32:01 <mreh> I didn't understand most of them
05:34:47 <mreh> just started working again, looks like I'll be writing lots of commandline stuff
05:35:02 <mreh> XML is not acceptable to me
05:35:11 <hpc> XML shouldn't be acceptable to anyone :P
05:35:20 <mreh> it's completely innapropriate for config files
05:35:20 <Botje> I like xml :(
05:35:22 <hpc> (except as output for a browser, of course)
05:35:25 <mreh> yes
05:35:47 * hpc edits http://haskell.org/haskellwiki/Cmdargs
05:36:38 <mreh> hpc: it's not my intention to overlap too much with GetOpt, I think that library is pretty complete
05:36:52 <hpc> oh we have GetOpt?
05:37:05 <hpc> yay
05:37:10 <mreh> it's a port of the unix one, yup
05:37:49 * hpc is confused what you want then
05:38:17 <mreh> generalised interactive input
05:38:24 <hpc> ah
05:38:38 <hpc> http://haskell.org/haskellwiki/CmdIn, perhaps
05:39:18 <hpc> and have it include stuff like yesno :: IO a -> IO a -> IO a
05:39:36 <mreh> hpc: I was thinking promptCofirmation :D
05:39:46 <mreh> yesno sounds more general
05:40:14 <mreh> like I said, I'm not sure it warrants a whole library
05:40:45 <hpc> i was thinking more could be lumped in with this as well
05:41:04 <hpc> for example, the functionality of adduser
05:41:18 <hpc> which takes all the user information as line prompts, with default values
05:41:40 <hpc> you can have specific handling for numbers, emails, etc
05:42:17 <mreh> yeah, I was thinking of cabal acutally, so I know what you're talking about
05:42:29 <hpc> and your promptConfirmation would be something like yesn (exitWith ExitSuccess) (return ())
05:42:37 <hpc> *yesn
05:42:39 <hpc> o
05:42:41 <hpc> >:(
05:42:55 <mreh> hpc: indeed
05:43:46 <hpc> that reminds me, i have never submitted a package to haskell.org
05:43:59 <mreh> :@
05:44:41 <hpc> not sure what of what i have written would be worth uploading
05:44:42 <mreh> I don't think it's a requirement
05:44:54 <mreh> the only thing I've uploaded is haskelloids
05:45:01 <hpc> it looks good on resumes, and it's a good thing to do
05:45:22 <hpc> perl got where it is now by having a crapton of libs
05:45:32 <hpc> made by users
05:46:04 <Ke> nowadays every lib has wrappers for every language
05:46:21 <hpc> fair
05:46:29 <hpc> but perl's are pretty awesome
05:46:51 <hpc> one of my favorites is an email validator, which my workplace uses in their CMS
05:47:03 <hpc> it pulls out the domain name, and checks that mail server's MX records
05:48:01 <hpc> i think the draw of haskell's libs can be that they reduce your program from 500 lines to 5
05:49:32 <mreh> I think the draw is that you don't have to do more work than you have to
05:49:50 <mreh> short programs are good too :)
05:50:34 <hpc> yeah; what i mean is because of how haskell is structured, you can abstract away preposterous proportions of others' programs
05:50:56 <hpc> which makes our libraries, in theory, that much more effective
05:51:24 <hpc> (preposterous proportions is a pretty awesome alliteration)
05:53:17 <Twey> Perfectly preposterous proportions of pernicious programs' pleonasms
05:53:51 <hpc> :D
05:53:54 <pkrumins> wat!
05:56:31 <hpc> @wn pleonasms
05:56:32 <lambdabot> No match for "pleonasms".
05:56:55 <onteria> wow, I had no idea vim could copy all text to the x11 clipboard... learn something new everyday
05:57:07 <hpc> awesome
05:57:28 <hpc> i actually found out the other day that htop can intercept mouse events in the terminal window
05:57:42 <hpc> EVEN IF it is run over SSH
05:58:30 <mreh> isn't that a feature of the terminal more than anything?
05:58:38 <hpc> and ssh, apparently
05:59:20 <hpc> the fact that it exists is kind of odd
05:59:32 <hpc> the fact that vim doesn't use it is disappointing
05:59:55 <mreh> why even bother with VNC
06:00:08 <hpc> VNC?
06:00:35 * hpc uses putty, if that's what you are asking
06:00:49 <mreh> sharing your desktop over the net
06:01:03 <hpc> ah, yes
06:01:04 <mreh> or any desktop
06:02:22 <hpc> i used teamviewer for a while, before mastering the art of terminal-fu
06:02:52 <mreh> do most people opt for screen these days?
06:04:09 <hpc> i use screen
06:05:02 <hpc> didn't know until yesterday there was an alternative, in fact
06:05:14 <hpc> and i just forgot the name :(
06:05:43 <pkrumins> i use tmux
06:05:54 <PhilRod> @pl (\x y -> abs (x - y))
06:05:55 <lambdabot> (abs .) . (-)
06:06:14 <PhilRod> ^^^ can someone help me with that one? I'm having trouble understanding the two uses of (.)
06:06:28 <pkrumins> :t (abs .)
06:06:29 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f a
06:06:39 <aristid> :t abs .: -
06:06:40 <lambdabot> parse error (possibly incorrect indentation)
06:06:42 <aristid> :t abs .: (-)
06:06:43 <lambdabot> forall a. (Num a) => a -> a -> a
06:06:50 <aristid> (.:) saves the day again
06:06:54 <pkrumins> huh!
06:06:55 <Botje> if you expand it once you get \x -> (abs .) (x -)
06:06:55 <PhilRod> what's .: ?
06:07:01 <Botje> or  \x -> abs . (x-)
06:07:10 <Botje> if you expand the . again you get your original expression back
06:07:27 <pkrumins> :t (.:)
06:07:28 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:07:35 <mreh> screen doesn't support pgUp/Dn
06:07:35 <pkrumins> had never seen .: before
06:07:42 <PhilRod> Botje: ah, that's the way to do it. I didn't think of working it backwards!
06:07:46 <pkrumins> mreh: sure it does, go in copy mode
06:07:59 <pkrumins> mreh: rebind it for quicker access
06:08:49 <diPython> hey, the System.Directory.doesDirectoryExists is always returning False. Does anyone know if there is any problem with this function and Darwin 10.5.0?
06:10:38 <PhilRod> pkrumins, aristid, Botje: thanks all!
06:11:17 <aristid> pkrumins: (.:) is simply defined as (.:) = fmap.fmap; infixr 9 .:
06:12:48 <pkrumins> @src (.:)
06:12:48 <lambdabot> Source not found. Do you think like you type?
06:13:00 <pkrumins> @src .:
06:13:00 <lambdabot> Source not found. Are you on drugs?
06:13:17 <aristid> pkrumins: it's not in the @src database, nor in any standard module
06:13:22 <pkrumins> oh!
06:13:23 <aristid> you have to define it yourself to use it
06:13:28 <pkrumins> ooh
06:13:52 <PhilRod> oh, the other question I had was, is the pointless version of my function considered good style? or is the pointful version considered more readable?
06:15:28 <hpc> i would write \x y -> abs (x - y)
06:15:39 <Twey> PhilRod: I'd prefer to write it fmap abs . (-)
06:16:15 <hpc> :t join fmap
06:16:16 <lambdabot> forall a. (a -> a) -> a -> a
06:16:24 <hpc> :t join
06:16:25 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:16:42 <hpc> > (join fmap) (+5) 2
06:16:43 <lambdabot>   12
06:16:48 <Jafet> Don't confuse the poor lad, bewilder him instead
06:16:53 <hpc> heh
06:17:07 <hpc> > (join fmap) (++"foo") ""
06:17:08 <lambdabot>   "foofoo"
06:17:20 <hpc> heh, nifty
06:17:26 <PhilRod> I've been idling here long enough to be only mildly bewildered :-)
06:18:02 <Jafet> Note that @pl does not use the caleskell (.), so you don't have to worry about it.
06:18:19 <Jafet> @unpl (f.) . g
06:18:20 <lambdabot> (\ d i -> f (g d i))
06:19:20 <Twey> What odd choices of variable names
06:20:28 <Jafet> What did you expect from pointful code!
06:20:38 <hpc> hehe
06:22:07 <Twey> Heh
06:22:18 <Twey> I just wondered why it chose ‘d’ and ‘i’ apparently at random
06:22:25 <Twey> Instead of doing it alphabetically or something
06:22:33 <Twey> Oh
06:22:43 <Twey> I guess it skips f, g, and h, and reserves them for functions
06:23:00 <Twey> But still, what's wrong with a, b, and c?
06:25:16 <Jafet> @unpl ((((((((f.).).).).).).).).g
06:25:17 <lambdabot> (\ m p s v y ab ae ah ak -> f (g m p s v y ab ae ah ak))
06:26:40 <hpc> @src (.)
06:26:40 <lambdabot> (f . g) x = f (g x)
06:26:41 <lambdabot> NB: In lambdabot,  (.) = fmap
06:26:48 <dixie> Loading package readline-1.0.1.0 ... <command line>: can't load .so/.DLL for: ncurses (/usr/lib/libncurses.so: file too short)
06:26:51 <dixie> any clue? :)
06:28:48 <Jafet> yes >> /usr/lib/libncurses.so
06:28:51 <Botje> check if that file is an actual library and not a linker script
06:30:04 <dixie> Botje: it is one line text file: INPUT(-lncursesw)
06:30:15 <dixie> hmm. I have to check my ncursers installation
06:31:14 <Zao> Botje: The first time I saw a linker script, I almost lost my temper.
06:31:57 <Zao> Who thought that it's a good idea to overload the semantics of ".so is a shared library, yo" with arbitrary linker-specific formats without headers.
06:32:48 <Jafet> http://google.com/search?q=dlopen+linker+script: 1) hackage.haskell.org/trac/ghc/ticket/2615
06:32:59 <Jafet> When did google implement clairvoyance
06:33:43 <Botje> two weeks ago
06:39:06 <maurer_> Given that
06:39:09 <maurer_> :t (,)
06:39:10 <lambdabot> forall a b. a -> b -> (a, b)
06:39:15 <maurer_> Why does this not work:
06:39:20 <maurer_> > 3, 4
06:39:20 <lambdabot>   <no location info>: parse error on input `,'
06:39:37 <maurer_> Shouldn't that parse ',' as an operator?
06:39:45 <Jafet> Because tuples are special, like your half-brother Kenny
06:40:24 <Jafet> > (1,,3) 2
06:40:25 <lambdabot>   <no location info>: parse error on input `,'
06:40:44 <hpc> tuples are uniquely irritating because they can be implemented in-language
06:41:05 <hpc> and implemented /better/
06:42:43 <Jafet> I suppose you could define the constructor (:,)
06:43:00 <Jafet> I dub thee the dotted semicolon
06:44:58 <hpc> data a :, b = a :, b
06:45:06 <hpc> triples are a :, b :, c
06:45:14 <hpc> etc etc
06:45:20 <hpc> :t curry
06:45:21 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:45:25 <hpc> :t uncurry
06:45:26 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:45:39 <hpc> uncurry :: (a -> b -> c) -> a :, b -> c
06:45:41 <hpc> :D
06:53:49 <Philonous1> Can I add a version constraint for a dependency of a package in cabal-install? (xmonad-contrib doesn't build with mtl 2 and the .cabal doesn't specify a version)
06:54:49 <dixie> Jafet: after reading the trac it looks like the GHC 6.12.x doesn't have correction of #2615. Am I right ? :)
06:54:57 <merijn> hpc: Isn't that problem easier* solved by not using tuples but implementing proper strong sum types? :p (* - note, might not actually be easy...)
06:55:01 <ddarius> There's a command line option to do that, I believe it is --constraint.  You will have to check the documents for details.
06:55:11 <Philonous1> thx
06:57:01 <Philonous1> cabal install --contraint="mtl <2.0.0.0" xmonad-contrib did the trick, thanks again
07:00:44 * dixie ln -sf /usr/lib/ncurses.so.5.7 /usr/lib/libncurses.so
07:02:32 <ski> OCaml doesn't require brackets around tuples ..
07:03:06 <ski> .. so you can write `let x,y = ...', e.g.
07:04:02 <roconnor> ski: isn't that more like a parallel let?
07:04:07 * roconnor isn't sure
07:04:49 <ski> no, that's similar to `let (x,y) = ...' in haskell
07:05:16 <roconnor> ski: Can you write let p = (a,b) in let x,y = p in ...
07:05:40 <roconnor> I bet 0.2 cents the answer is no
07:06:30 <ski> you can
07:06:47 <ski> though that is simpler written as `let p = a,b in let x,y = p in ...'
07:07:07 <roconnor> well I'll be
07:07:12 * ski doesn't recall atm whether OCaml has collateral declarations .. SML has, though
07:07:42 <roconnor> I owe you 0.2 cents
07:07:45 <ski> roconnor : that's no different from `let p = (a,b) in let (x,y) = p in ...' in Haskell, apart from the concrete syntax
07:07:46 <ddarius> roconnor: All O'Caml does is use , as a constructor.  It behaves as any other constructor.
07:08:06 <ski> you can of course also say stuff like
07:08:12 <ski>   match xs , ys with
07:08:35 <ski>     | []    , []    -> ...
07:08:42 <ski>     | x::xs , []    -> ...
07:08:52 <ski>     | []    , y::ys -> ...
07:08:59 <ski>     | x::xs , y::ys -> ...
07:09:23 <ski> (which looks slighty nicer than the Haskell counterpart, i'd have to say)
07:09:56 <ddarius> ski: Feel free to define your own infix pair constructor.
07:10:04 <ski> note that `a , b , c' is neither `(a , b) , c' nor `a , (b , c)', though (just like in Haskell)
07:10:11 <Eduard_Munteanu> Can that be an ADT in OCaml? I'd think no.
07:10:11 <Blkt> good day everyone
07:10:30 <Eduard_Munteanu> Blkt: o/
07:11:42 <Eduard_Munteanu> at least a, b, c should be able to take in different types for a, b and c.
07:13:12 <Blkt> Eduard_Munteanu: \o
07:13:59 <Eduard_Munteanu> Hm, I'm wrong, I think it does work after all.
07:14:46 * hackagebot augeas 0.3.4 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.3.4 (JudeNagurney)
07:16:08 <hvr> ...anyone know of good mapErrorT examples?
07:16:14 <ski> roconnor : presumably by "parallel let" you mean something like `let val a = b and b = a in ...', swapping `a' and `b' ?
07:16:51 <Eduard_Munteanu> ski: oh, btw, thanks for the explanation left on lambdabot 
07:17:00 <roconnor> ski: yes
07:17:09 * ski looks confused
07:17:19 <ski> Eduard_Munteanu : did i leave a message for you ?
07:17:37 <roconnor> ski: I thought the syntax was let a,b = e1 , e2
07:17:46 <ski> that was sML
07:17:47 <ski> SML
07:17:48 <Eduard_Munteanu> ski: the Mu thingy
07:18:00 <roconnor> ie that if you have this sort of pair on the LHS it had to be the same sort of pair on the RHS
07:18:02 <Eduard_Munteanu> 1-2 days ago
07:18:03 <mreh> let (a,b) = (e1,e2) is supported
07:18:18 <ski> roconnor : of course `let val (a,b) = (b,a) in ... end' works just as fine, in this case, with no collateral declarations needed
07:18:26 <roconnor> yes
07:18:39 <ski> mreh : yeah, but that isn't a collateral declaration
07:18:46 <roconnor> but that involves a tuple being produce and consumed (and optimized away so it makes no difference)
07:19:12 <roconnor> anyhow I can't keep up with the various flavours of ML 
07:19:16 <ski> roconnor : oh, you're thinking about some kind of unboxed tuples, then ?
07:20:04 <ski> there's two main flavours of ML : SML and OCaml
07:20:16 <ski> not that much to keep track of
07:20:30 <roconnor> :)
07:20:34 <ski> there's a simpler variant of OCaml, Caml, but i don't know if it's used much
07:21:20 <ski> also, there's Alice ML (Andreas Rossberg), which, afaiu, is based on SML, but adds lots of semantics from Oz
07:21:34 * ski can't recall any more ..
07:22:12 <ski> (there's several *implementations* of SML, though. SML/NJ MLton, PolyML, Moscow ML, ML-Kit .. maybe i'm forgetting one or two)
07:22:15 <ddarius> There are a lot of little research variants like JoCaml and MetaML.
07:22:15 <roconnor> wow Gentoo is a type of penguin
07:22:28 <ski> s/MLTon/, MLTon/
07:23:08 <ski> (oh, right, JoCaml, and MetaML (and MetaOCaml) .. i've heard of (and played some with MetaML))
07:25:44 <Eduard_Munteanu> Is declarative/logic programming a-la Prolog in any way different from the functional paradigm?
07:26:00 <ski> Eduard_Munteanu : hm, i have only a very vague recollection of saying something about `Mu' in a lambdabot `tell'
07:26:02 <ddarius> Um, it's completely different.
07:26:13 <ski> well, some things are similar
07:26:18 <ski> lots are different
07:26:28 <Eduard_Munteanu> Yeah I'm seeing lots of similarities.
07:26:40 <ski> pattern-matching (generalized) and recursion and immutable variables are similar
07:26:57 <ski> (by "recursion" i mean the emphasis thereof)
07:26:58 <Eduard_Munteanu> <lambdabot> ski said 9h 45m 30s ago: instead of doing `newtype IOExpr = IOExpr (ExprF (IORef IOExpr))', you could do `newtype IOExprF self = IOExprF (IORef (ExprF self))' (flipping the order of `IORef' and `
07:27:04 <Eduard_Munteanu> But anyway, thanks ^ :)
07:27:14 <ski> ah, ok
07:27:26 <Eduard_Munteanu> (the timing ain't right there, I read it yesterday)
07:28:29 <Eduard_Munteanu> Well, if you take SQL as declarative, it isn't much functional.
07:28:39 <Eduard_Munteanu> But Prolog at least has some resemblance.
07:28:39 <ski> SQL is a bad language
07:28:43 <Eduard_Munteanu> Yeah.
07:29:13 <ski> relational algebra is fine. SQL itself is too ad hoc
07:29:40 <ski> (also there's lots of problems with SQL, making it deviate from the relational model)
07:30:15 <ski> Eduard_Munteanu : you should check out deductive databases and Datalog (which is in some sense "similar" to Prolog)
07:30:38 <Eduard_Munteanu> Hm, I read once something about Datalog, it was interesting.
07:31:09 <ski> (the syntax is similar to Prolog, but a bit more restricted. the (operational) semantics is more restricted as well, and quite different)
07:32:25 <Eduard_Munteanu> I also took a look at that attribute grammars thingy for Haskell, it looks like an interesting idea although it's a hack.
07:32:39 <ski> (very briefly : Prolog is top-down, backward-chaining, tuple-at-a-time, while Datalog is bottom-up, forward-chaining, set-at-a-time)
07:33:10 <Eduard_Munteanu> I see.
07:33:41 <yiannis_t> @seen Cale
07:33:42 <lambdabot> Unknown command, try @list
07:33:42 <preflex>  Cale was last seen on #haskell 4 hours, 46 minutes and 42 seconds ago, saying: pille456: You can think of foldr f z as replacing each (:) in the construction of a list with a replacement function f, and an [] at the end (if any) by z. Here you'll want to replace (:) with a function that tests if the condition passes or not before adding the element to the list.
07:34:10 <ski> preflex responds to `@seen', now ?
07:34:22 <Nibble> hmm
07:34:24 <Nibble> haskell vs ml
07:34:28 <Nibble> any winner?
07:34:29 <ski> preflex: seen Nibble
07:34:29 <preflex>  Nibble was last seen on #haskell 1 second ago, saying: any winner?
07:34:31 <Eduard_Munteanu> Have you seen me?
07:34:41 <Eduard_Munteanu> (nah, it's not matching blindly)
07:36:04 <ski> @vixen Who should we cheer on, in a death-match between Haskell and the MLs?
07:36:04 <lambdabot> church is my favourite computer scientist.
07:36:13 <ski> Nibble : there's your answer
07:37:21 <Nibble> ski: :/
07:37:36 <Nibble> let me put it this way
07:37:47 <Nibble> what language of Haskell and ML, is the most useless?
07:38:43 <ski> Mu
07:39:03 <ski> (hint : `ML' isn't *one* language (anymore))
07:39:15 <Nibble> well
07:39:24 <Nibble> mention the most useless functional programming language
07:39:45 <nocture> http://pastebin.com/5xpXfuux can someone tell me why I get a "  Couldn't match expected type `MyVal' against inferred type `Bool' In the pattern: True" error in this one
07:39:51 <ski> i'm not sure about most useless, but maybe you'll like `unlambda' ?
07:39:55 <ski> or `lazy-k' ?
07:40:31 <Nibble> I didn't mean estoric
07:40:47 <ski> how about ISWIM ?
07:40:55 <ski> iirc, ISWIM was never implemented
07:41:15 <kadoban> nocture: on line 5 i assume you mean "No == Yes = False" ?
07:41:32 <geheimdienst> nocture: the error message should be telling you the line number
07:41:37 <nocture> fuck
07:41:45 <nocture> i been going for too long now
07:41:49 <nocture> thanks *blush*
07:41:53 <kadoban> hehe, np
07:51:55 <Eduard_Munteanu> I'd rather nominate Coq and that kinda stuff as the most useless from a software development perspective. Although I hope they do figure out a way to do that.
07:53:05 <merijn> Eduard_Munteanu: Epigram is trying to be Coq without the utter inapplicability in software development
07:53:28 <Saizan> merijn: how is your study of epigram going, btw?
07:53:30 <Eduard_Munteanu> Yeah, there was another Haskell spinoff trying to achieve the same thing, not Agda.
07:54:09 <merijn> Saizan: Sorta sidetracked with my other stuff from classes. Still terrified by and stuck on figure 9 of View from the Left :p
07:54:09 <arbitrarylogic> does anyone know why ghci is saying "Not in scope: data constructor `State'" after I import Control.Monad.State?
07:55:22 <merijn> I did get a new paper from my prof, draft of the view from the left which has more examples and less formal writing which I hope will get me unstuck
07:55:43 <byorgey> merijn: I have tried to understand that paper twice.
07:55:43 <Eduard_Munteanu> Erm, not really like Coq but with dependent types at least.
07:55:48 <Eduard_Munteanu> I don't recall the name...
07:55:49 <byorgey> merijn: it didn't work.
07:56:17 <merijn> byorgey: Well, I got halfway through so far. I feel slightly more enlightened and drastically more confused :p
07:56:31 <Saizan> i think the levitation paper (and related agda model) helps there, because D-elim is constructed by recursion on the structure of the datatype
07:56:31 <ski> Eduard_Munteanu : Smerdyakov is doing work on how to use Coq for programming. see e.g. his book "Certified Programming with Dependent Types" at <http://adam.chlipala.net/cpdt/>
07:56:42 <byorgey> merijn: that sounds about right =)
07:56:45 <Eduard_Munteanu> Ah, I remember... Idris.
07:57:02 <byorgey> Idris is pretty cool
07:57:07 <merijn> Saizan: Yeah, from what I've seen once I figure out the structural recursion on datatypes the rest well fall into place automagically
07:57:12 <Saizan> which is a bit less scary than inference rules :)
07:57:21 <Eduard_Munteanu> ski: heh, I've been reading that a few weeks ago.
07:57:30 <merijn> s/well/will
07:58:09 <ski> (inference rules are scary ?)
07:58:17 <Saizan> merijn: yeah, the rest is about the <= tactics
07:58:28 <Saizan> *tactic
07:59:02 <Saizan> ski: can be, especially since they tend to have notational shortcuts and you can't play with them as easily
07:59:30 <merijn> But almost all my time has been going to a different project (declarative stream coordination language, hope to implement on demand scaling of the stream network components on a 48 core machine, to aim at a modest goal >.>)
07:59:44 <ski> one usually is able to read inference rules like a logic program
08:01:52 <Eduard_Munteanu> Am I wrong to think fully decidable type inference isn't a worthy goal? I mean, we already annotate Haskell programs with lotsa types, it's just good practice.
08:02:12 <merijn> Eduard_Munteanu: The epigram people agree with you :p
08:02:20 <Eduard_Munteanu> Heh.
08:02:22 <merijn> I'm pretty sure their type inference is undecidable
08:02:43 <merijn> Then again, they also think Turing completeness is overrated
08:02:52 <Eduard_Munteanu> Neither is Haskell + rank-N types.
08:03:12 <jmcarthur> i'm pretty sure that the only way to make it decideable would be to somehow include all that information at the term level anyway. it wouldn't really save any boilerplate
08:03:36 <aavogt> you're supplying types when you write classes
08:03:40 <Eduard_Munteanu> Some inference is good, I'm not going to annotate just about every value or term in an expression.
08:03:50 <Saizan> right
08:04:02 <aavogt> nobody's going to say those can be inferred (unless you write some instances at the same time)
08:04:03 <jmcarthur> my point is that in order for inference to work then the information is already there
08:04:09 <merijn> The only interesting thing is whether the type inference is decidable enough :p
08:04:15 <Saizan> you want a system where annotating lambdas is enough, or better where toplevel signatures are enough
08:04:16 <jmcarthur> it may be somewhat obscured, but it's there
08:04:27 <Saizan> and even then you might want some syntax for automatic generalization
08:05:10 <hvr> I have something of type (x->x)->y and needs to lift it into something liek (x->m x)->m y
08:05:21 <hvr> I just can't see how :-/
08:05:48 <cdsmithus> I think I shouldn't be allowed to program late at night.  Was just reviewing some code I wrote last night, and saw: \p -> foo p >>= maybe (return Nothing) (return . Just)
08:05:48 <Saizan> possibly you can't
08:06:02 <Saizan> hvr: can you be more specific?
08:06:17 <merijn> :t fix
08:06:18 <lambdabot> forall a. (a -> a) -> a
08:06:51 <Saizan> cdsmithus: nice :D
08:07:11 <hvr> Saizan: yeah, say I have a pure function, that given a pure x->x can generate some y; and I don't have a pure x->x but something that's in the IO monad for instance...
08:07:12 <Eduard_Munteanu> @djinn (x->x)->y
08:07:12 <lambdabot> -- f cannot be realized.
08:07:46 <cdsmithus> Saizan: it was the result of simplifying some more complicated stuff... so I don't feel too bad; I just missed that last rather obvious step.
08:07:50 <merijn> My CH senses say the reason people always call fix the devil is because it's an unprovable logic statement meaning it makes the type system inconsistent!
08:07:56 <developernotes> is there an easy way to convert the result of something like zip [1..5] [5,4..1] to a hashtable? 
08:08:11 <Botje> Maps have a fromList function
08:08:11 <merijn> developernotes: Maybe something in Data.Map?
08:08:49 <jmcarthur> even the type of fix is obviously a logical fallacy
08:08:53 <jmcarthur> (a -> a) -> a
08:08:54 <Saizan> hvr: depends on the exact types of the function, and what it's doing, so you haven't been specific enough
08:09:07 <developernotes> merijn: looking into it..
08:09:13 <merijn> jmcarthur: That's what I said :p
08:09:36 <Saizan> hvr: for example if it's polymorphic on 'x' you could pass it a function (m x -> m x) which you can construct from your (x -> m x)
08:09:45 <Eduard_Munteanu> hvr: unless you have some constraints on that, I doubt it's possible to make a function like that.
08:10:13 <hvr> Saizan: x would be something easy like an Int
08:10:16 <Saizan> developernotes: Data.Map.fromList
08:10:23 <hvr> and m would be IO
08:10:48 <Saizan> if your function is of type (Int -> Int) -> String then you can't
08:11:03 <Eduard_Munteanu> hvr: so (Int -> IO Int) -> IO ... ?
08:11:14 <developernotes> Saizan: I was just looking at that.  :-) 
08:11:14 <hvr> Eduard_Munteanu: yes
08:11:38 <hvr> Eduard_Munteanu: that's what I want... givven (Int -> Int) -> ...
08:11:45 <Eduard_Munteanu> That's possible but, you'll need to apply the first argument to an arbitrary value, methinks, then bind it to some other function
08:12:05 <Eduard_Munteanu> Well, Int -> Int, or Int -> IO Int?
08:12:18 <aavogt> you can write a    (Int -> IO Int) -> IO (Int -> Int), which does the IO for all numbers
08:14:17 <hvr> Eduard_Munteanu: let's say my function was "(\f -> sum (map f [5..10]) > 10)"
08:14:43 <hvr> Eduard_Munteanu: i.e. (Int->Int)->Bool
08:14:58 <Eduard_Munteanu> Ok, so it isn't monadic.
08:15:13 <ski> @type \f -> liftM ((> 10) . sum) (mapM f [5..10])
08:15:14 <lambdabot> forall a a1 (m :: * -> *). (Num a, Ord a, Num a1, Enum a1, Monad m) => (a1 -> m a) -> m Bool
08:15:27 <hvr> Eduard_Munteanu: yes, but a want to give it something monadic, e.g. something that adds a random number
08:15:48 <ski> hvr : in general it's not possible
08:15:49 <Eduard_Munteanu> Like ski says
08:15:55 <hvr> alright :)
08:16:18 <hvr> at least I know I shouldn't waste time on it :)
08:16:20 <hvr> thx
08:16:50 <Eduard_Munteanu> I think by "in general" you mean you can't make a more polymorphic variant.
08:16:50 <ski> hvr : in specific cases, you can monadify your original function to have type `forall m. Monad m => (x -> m x) -> m y' (the `forall m. Monad m => ' then ensures that this function can't *itself* do any monadic effects)
08:17:05 <ski> hvr : to recover the pure function, use the `Identity' monad
08:17:49 <developernotes> when I do: let h = fromList(zip [1..5] [5,4..1]), how do I get a value out of h?  I tried Data.Map.lookup(h, 1) but it errored out.
08:18:05 <aavogt> developernotes: Map.lookup h 1
08:18:13 <aavogt> oops, swap the order
08:18:59 <developernotes> aavogt: awesome, thanks!
08:19:04 <Eduard_Munteanu> To avoid confusion maybe you should also annotate it with a type.
08:19:08 <Eduard_Munteanu> @hoogle fromList
08:19:09 <lambdabot> Data.HashTable fromList :: Eq key => (key -> Int32) -> [(key, val)] -> IO (HashTable key val)
08:19:09 <lambdabot> Data.IntMap fromList :: [(Key, a)] -> IntMap a
08:19:09 <lambdabot> Data.IntSet fromList :: [Int] -> IntSet
08:19:29 <aavogt> Eduard_Munteanu: which?
08:19:48 <Eduard_Munteanu> I mean to annotate the fromList let
08:21:03 <Eduard_Munteanu> (unless that value somehow escapes its context and you should annotate top-level declarations anyway)
08:21:32 <aavogt> there's defaulting to address what the numbers should be
08:22:07 <aavogt> and types aren't used to resolve name ambiguities
08:22:22 <Eduard_Munteanu> I usually do that with array stuff.
08:22:37 <Eduard_Munteanu> :t listArray
08:22:38 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
08:22:58 <Eduard_Munteanu> Grr.. not the best example.
08:23:05 <Eduard_Munteanu> :t array
08:23:06 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
08:23:26 <aavogt> yeah, some of that IArray stuff can't figure out which array implementation to use
08:23:35 <Eduard_Munteanu> Yeah.
08:24:10 <Eduard_Munteanu> (IMHO it's better to use typeclasses for such stuff so you don't need to import qualified when using multiple versions)
08:25:27 <aavogt> like this then http://hackage.haskell.org/packages/archive/container-classes/0.0.0.0/doc/html/Data-Containers.html 
08:25:35 <Eduard_Munteanu> There's already lots of conflicts between Prelude and other base modules.
08:26:41 <Eduard_Munteanu> Yeah.
08:27:19 <Eduard_Munteanu> I suspect base stuff needs some cleanup (like removing folds for lists), though I'm unsure how much breakage that would case.
08:27:38 <JoeyA> Does seq evaluate its first argument to "head normal form" or "weak head normal form"?
08:27:48 <Eduard_Munteanu> WHNF, IIRC.
08:27:53 <roconnor> WHNF
08:27:54 <JoeyA> The GHC docs just say "head normal form":  http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Prelude.html#v:seq
08:28:14 <aavogt> when the second second argument is forced
08:28:14 <JoeyA> But doesn't HNF imply that all thunks inside are evaluated as well?
08:28:14 <thoughtpolice> seq is whnf, for hnf you should use the deepseq package
08:28:30 <JoeyA> (so hnf [1..] = _|_)
08:28:39 <roconnor> thoughtpolice: I don't think deepseq does that
08:28:48 <roconnor> JoeyA: no
08:28:57 <aavogt> rnf isn't hnf then
08:29:02 <Eduard_Munteanu> I'd really like to see such a cleanup in the next Haskell' iteration.
08:29:27 <aavogt> there have been many alternate prelude projects
08:29:33 <roconnor> head normal form more or less means the top constructor has been evaluated
08:29:37 <thoughtpolice> roconnor: does it not? i thought that e.g. [1,2,undefined] `seq` () == (), and that [1,2,undefined] `deepseq` () == undefined
08:29:37 <ski> hvr : see <http://hpaste.org/10060/repaste_of_poormandebug>,<http://hpaste.org/10061/example_usage> for an example of this, giving you a simple recursive trace of a function that has been monadified
08:29:52 <thoughtpolice> er, or do i just have my terms mixed up? :x
08:30:05 <roconnor> weak head normal form doesn't look under lambdas and just stops
08:30:35 <roconnor> deepseq runs things to normal form, and is restricted to types without functions involved.
08:30:49 <lars9> does ghc7 have a minimal prelude?
08:30:52 <JoeyA> Is there a difference between "weak head normal form" and "head normal form"?
08:30:57 <roconnor> JoeyA: yes
08:31:13 <Eduard_Munteanu> Is that equivalent to saying WHNF doesn't reduce abstractions?
08:31:14 <hvr> ski: thx, now I have something to feed my brain :-)
08:31:24 <roconnor> (\x -> (\y -> y) 7) is in weak head normal form
08:31:31 <thoughtpolice> aavogt: i like awesomeprelude just because it's a cool concept
08:31:31 <roconnor> (\x -> 7) is in head normal form
08:31:41 <JoeyA> Oh
08:31:44 <ski> hvr : that's simulataneously also an example of rank-2 polymorphism
08:31:46 <Eduard_Munteanu> Looks like it.
08:31:52 <JoeyA> So seq is head normal form, not weak head normal form, right?
08:31:59 <JoeyA> err, vice versa
08:31:59 <roconnor> I suspect many problems with seq would go away if it put things into head normal form.
08:32:12 <roconnor> seq does WHNF
08:32:12 <jmcarthur> that's difficult to get right though
08:32:20 <roconnor> nothing does HNF
08:32:31 <roconnor> deepseq does NF for a certain subset of types
08:32:43 <jmcarthur> i mean while keeping the compiled code efficient
08:33:04 <JoeyA> :let f = \x -> (\y -> undefined) 7
08:33:05 <Eduard_Munteanu> @src seq
08:33:06 <lambdabot> Source not found. Are you on drugs?
08:33:15 <JoeyA> @let f = \x -> (\y -> undefined) 7
08:33:16 <lambdabot>  Defined.
08:33:20 <JoeyA> > f `seq` (2+2)
08:33:20 <lambdabot>   Ambiguous occurrence `f'
08:33:21 <lambdabot>  It could refer to either `L.f', defined at <local...
08:33:35 <JoeyA> @let joey_a's_very_own_f = \x -> (\y -> undefined) 7
08:33:36 <Eduard_Munteanu> @undefine L.f
08:33:37 <lambdabot>  Defined.
08:33:52 <JoeyA> > joey_a's_very_own_f `seq` (2+2
08:33:53 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:33:56 <Eduard_Munteanu> > f `seq` (2+2)
08:33:58 <lambdabot>   Ambiguous type variable `a' in the constraint:
08:33:58 <lambdabot>    `SimpleReflect.FromExpr a...
08:34:00 <JoeyA> > joey_a's_very_own_f `seq` 2+2
08:34:01 <lambdabot>   Not in scope: `joey_a's_very_own_f'
08:34:20 <roconnor> Eduard_Munteanu accidentally undefined your very own f 
08:34:27 <JoeyA> Anyway, that works in GHC.  Would that fail if it were doing head-normal form?
08:34:30 <Eduard_Munteanu> Hm, yeah
08:34:51 <roconnor> > let f = \x -> (\y -> undefined) 7 in f `seq` 2+2
08:34:52 <lambdabot>   4
08:34:55 <roconnor> > let f = \x -> (\y -> undefined) 7 in f `seq` (2+2)
08:34:57 <lambdabot>   4
08:35:08 <roconnor> JoeyA: yes, it would fail
08:35:12 <JoeyA> thanks
08:35:13 <Eduard_Munteanu> @hoogle seq
08:35:13 <lambdabot> Prelude seq :: a -> b -> b
08:35:14 <lambdabot> Data.Sequence data Seq a
08:35:14 <lambdabot> Control.Parallel.Strategies seqArr :: Ix b => Strategy a -> Strategy (Array b a)
08:36:25 <Eduard_Munteanu> Well is that okay even if you don't 'need' the undefined value?
08:36:56 <lars9> is haskell memory safe? if yes, does it mean we don't need sperated address space if the whole os is implemented in haskell?
08:36:58 <Eduard_Munteanu> I'd be okay with values that evaluate to undefined as long as I don't 'need' them.
08:37:29 <Eduard_Munteanu> lars9: yes and no, you can still mess things up with Ptr
08:37:51 <roconnor> lars9: what does memory safe mean?
08:38:07 <lars9> Eduard_Munteanu: is Ptr unavoidable?
08:38:17 <Eduard_Munteanu> (I'd still have some separation anyway)
08:38:39 <Eduard_Munteanu> What if someone runs untrusted code?
08:38:50 <Eduard_Munteanu> Maybe it's not Haskell code.
08:38:52 <lars9> roconnor: explicit memory operation is not exposed to programmer.
08:39:26 <alex404> Is it strange that 'innerProduct v1 v2 = V.sum $ V.zipWith (*) v1 v2' is taking up 40% of my allocation? Should it be all fuse streamy and magical?
08:39:53 <lars9> Eduard_Munteanu: the untrusted code is another story. i'm imaging a system build with L4-verified / Haskell core/ haskell applications, 
08:40:28 <roconnor> reading diffs of diffs is confusing
08:40:39 <Eduard_Munteanu> lars9: I'm not sure how feasible it is to run such stuff in kernel space.
08:42:05 <Eduard_Munteanu> alex404: did you enable optimizations?
08:42:19 <alex404> Eduard_Munteanu: -O2
08:42:41 <lars9> Eduard_Munteanu: a recent OSDI paper talks about an OS built dedicatedly for webbrowsing. http://code.google.com/p/op-web-browser/
08:42:42 <Eduard_Munteanu> alex404: see if using foldl' fixes that.
08:43:03 <lars9> Eduard_Munteanu: those dedicated os deisng is interesting.
08:43:18 <lars9> *design
08:44:01 <Eduard_Munteanu> I'm having doubts even House is safe, it's relying heavily on the modified RTS to do the right thing.
08:44:10 <Eduard_Munteanu> And it's probably using some pointers at some point too.
08:44:30 <jmcarthur> Eduard_Munteanu: he's using vector it looks like. i doubt V.foldl' would make any difference
08:44:40 <Eduard_Munteanu> Ah.
08:44:44 <alex404> Aye
08:44:56 <jmcarthur> alex404: are you using the result of that in more than one place?
08:45:04 <jmcarthur> like after applying it to arguments
08:45:56 <jmcarthur> stream fusion sometimes doesn't get along with sharing. i don't know how to reason about it yet for sure
08:46:00 <alex404> Hmmm... yah, I didn't phrase this in the right way
08:46:10 <alex404> I do indeed
08:46:15 <alex404> It writes it into a data structure
08:46:22 <alex404> Well, wait...
08:46:27 <jmcarthur> well that's probably okay then
08:46:45 <alex404> Yah, and anyway, the point is that it boils down to a scalar
08:46:49 <alex404> So shouldn't this not be an issue?
08:46:54 <jmcarthur> oh you're right
08:47:10 <jmcarthur> maybe you are simply using it more times than you are expecting
08:47:15 <merijn> lars9: I think there's already a bare metal OS written in haskell around, lemme see if I can find it
08:47:31 <lars9> merijn: cool
08:47:31 <jmcarthur> well there's House
08:47:45 <jmcarthur> but it's just the rts ported to run on bare metal
08:48:01 <merijn> That's the one I meant, I think
08:48:02 <merijn> http://programatica.cs.pdx.edu/House/
08:48:40 <merijn> jmcarthur: Sure, but if you're gonna implement an OS having the RTS ported to bare metal already is a major time saver :p
08:48:52 <alex404> jmcarthur: Well, no, I use it a lot, which is expected. It's a core operation in the two work horse functions of my program ;) But I guess I don' t what the high allocation is telling me. I'm imagining that it should be able to calculate the innerproduct this in constant space.
08:49:59 <Eduard_Munteanu> Yeah, it's not really like House binds Haskell so tightly to the underlying machine like Linux does.
08:50:30 <alex404> What's this House you're talking about?
08:50:36 <merijn> alex404: http://programatica.cs.pdx.edu/House/
08:50:48 <Eduard_Munteanu> A Haskell OS.
08:50:53 <Eduard_Munteanu> (kernel)
08:50:54 <merijn> Haskell User's Operating Sytem and Environment
08:51:12 <merijn> Its not really a kernel, afaik. Just the runtime system, you could implement a kernel using it, of course
08:51:13 <olsner> but... that's "huose"
08:51:35 <merijn> olsner: I didn't come up with it :p
08:51:41 <alex404> Neat
08:51:54 <Eduard_Munteanu> I'm quite a bit uneasy with taking an userspace RTS (that contains a GC and whatnot) and port it on bare hardware.
08:52:38 <merijn> Eduard_Munteanu: Wuss :D
08:53:08 * Eduard_Munteanu is a bit old school :)
08:53:37 <Eduard_Munteanu> I'd rather have some region inference like JHC does.
08:53:39 <merijn> Manual memory management code in FreeBSD still ocassionally runs out of memory and panics with stuff like ZFS, so that's not a guaranteed fix
08:53:41 <Eduard_Munteanu> (or tries to)
08:54:09 <merijn> Also, garbage collected OS is old school, manual memory management is wannabe old school :p
08:54:12 <lars9> merijn: is it a haskell rts on bare metal?
08:54:19 <merijn> lars9: Pretty much
08:54:39 <Eduard_Munteanu> merijn: off-by-one errors are fixable, OOM probably not.
08:54:43 <lars9> merijn: hard to imagine
08:54:53 <Eduard_Munteanu> *fixable by using automatic allocation
08:54:54 <merijn> lars9: Why? Doesn't seem to hard to me
08:55:08 <alex404> Bare Metal Haskell would be a great name for a cyberpunk erotica zine
08:55:10 <merijn> LispMachines had garbage collection to
08:55:13 * Eduard_Munteanu would bet it has crappy performance
08:55:40 <Eduard_Munteanu> IIRC, it wasn't a realtime GC or anything.
08:56:19 <lars9> merijn: it stands between user application and bare metal? who takes care of drivers, mem management etc?
08:56:22 <merijn> realtime only affects performance, not going OOM
08:56:40 <Eduard_Munteanu> Yes.
08:56:40 <merijn> The RTS does memory management, there are no drivers
08:56:58 <merijn> Eduard_Munteanu: So that statement is irrelevant to whether you can have an OS using GC
08:57:18 <merijn> lars9: RTS already does memory management under your OS anyway
08:57:25 <Eduard_Munteanu> Yes, it's totally separate.
08:58:12 <lars9> merijn: so it does something usually done by an os kernel?
08:58:13 <Eduard_Munteanu> But I still suspect the performance is crap :)
08:59:07 <merijn> lars9: You mean memory management?
09:00:21 <lars9> merijn: memory management, ipc, driver, and run in ring0 ?
09:00:35 <Eduard_Munteanu> They must.
09:00:45 <Eduard_Munteanu> At least a thin layer.
09:00:47 <merijn> lars9: OS memory management consists of memory segmentation and virtual memory, all other memory management is done my applications themselves. Since there is no segmentation, virtual memory or concept of processes none of the exists in House
09:01:05 <Eduard_Munteanu> Whoa!
09:01:05 <merijn> (Actually, it might exist in House, but is not necessary for a bare metal runtime)
09:01:12 <lars9> merijn: i can understand the mem point
09:01:17 <Eduard_Munteanu> Oh, that's better :).
09:01:28 <lars9> merijn: L4 has no mem manager
09:02:26 <merijn> lars9: The RTS doesn't need to do drivers or IPC (or even multiple processes..), if you need that you need to implement yourself, that's what baremetal means...
09:02:29 <monochrom> whee
09:02:56 <Eduard_Munteanu> I think lars9 was referring to the whole OS, not just the RTS.
09:03:02 <lars9> merijn: i see, amazing
09:03:21 <merijn> Well, House (if it implements it) would need to implement that on top of the RTS, yes
09:03:38 <merijn> Just like you would program an OS in any other language
09:03:54 <lars9> Eduard_Munteanu: i asked in L4's mailling list how to run L4, they told me to implement my mem manager, driver etc first.
09:04:02 <Eduard_Munteanu> I had an even crazier idea at some point: have a language in which you can write a kernel along with a specification, and choose at compile-time whether to make it monolithic or splice it into multiple servers :)
09:04:34 <Eduard_Munteanu> lars9: L4 is just a thin layer, look at L4Linux or stuff like that if you want something runnable.
09:05:02 <merijn> Writing OSes is surprisingly easier then expected, although a little tedious
09:05:43 <Eduard_Munteanu> But I suspect it's not so decideable how to convert pointer passing to message passing :).
09:06:18 <Eduard_Munteanu> (at least efficiently, trivial solutions might be doable)
09:06:19 * hackagebot atomo 0.2.2 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.2.2 (AlexSuraci)
09:06:45 <merijn> See Minix? Although that does still use absolute memory accesses, which might be harder in Haskell
09:06:50 <lars9> Eduard_Munteanu: yeah i know it's a thin layer, but isn't there a minimal set of tools around it, to at least print a hello world to a file or socket? so that i can start to interact with it
09:07:11 <merijn> lars9: If you're interested in OS level stuff I can recommend you a good book :>
09:07:53 <rovar> is there a way to import a type without its instance declarations?
09:08:09 <merijn> lars9: Operating Systems: Design & Implementation by Tanenbaum is very readable, very in depth and the Minix source code is surprisingly hackable if you know basic C.
09:08:19 <lars9> merijn: i have an idea in my mind and i want to investigate a little bit deeper. and i need a minimal runnable OS around L4 for it.
09:08:20 <Eduard_Munteanu> http://os.inf.tu-dresden.de/L4/LinuxOnL4/
09:08:38 <Eduard_Munteanu> They've developed some other OSes on top of L4, that can coexist with Linux.
09:08:40 <aavogt> rovar: you can't hide instances. You can use a newtype to write alternate instances though
09:08:52 <rovar> ah.. that's a good idea. thanks
09:09:10 <Eduard_Munteanu> merijn: is that the same book as Modern Operating Systems?
09:09:27 <Jafet> There are various levels on which to consider a bunch of code an operating system. Everything even mentioned in passing in Operating Systems, consists only of basic low-level functions.
09:09:29 <merijn> Eduard_Munteanu: Modern Operating Systems has a lot of implementation detail stripped out, but otherwise yes
09:09:30 <Eduard_Munteanu> That one was a rather easy read :(
09:09:34 <Eduard_Munteanu> Oh.
09:09:47 <Eduard_Munteanu> I thought it was too watered down.
09:09:56 <Jafet> "And all the data one can ever possess, is but a fragment compared to the whole."
09:10:08 <merijn> The one I suggested has a large Minix source code listing and includes *a lot* of in-depth explanation of how and why Minix does things
09:10:28 <merijn> But a lot of the Minix details carry over trivially to other OSes
09:10:37 <Eduard_Munteanu> Or you can take a look at how Linux does stuff, there's lots of material around for that.
09:10:52 <merijn> Eduard_Munteanu: Yes, but the Linux kernel is scary awful code and Minix kernel is not :p
09:10:57 <Jafet> If linux is a kernel, then gentoo is a distribution.
09:11:20 <Eduard_Munteanu> Yeah, Minix is a lot smaller, but I can't really comment on it, I'm not familiar with it.
09:11:44 <thoughtpolice> scary in that linux is not toy software and has been relentlessly optimized and tested for a lot of hardware
09:11:46 <merijn> Having looked at both sources (and having to hack the Minix code for 4 months this year) I can tell you it is incredibly easy to start on with only basic C experience. Linux kernel code still beats me up and takes my lunch money
09:12:11 <lars9> merijn: linux kernel code has layers and layers of marcos, i hate to read onion-like macros...
09:12:22 <Eduard_Munteanu> merijn: Summer of Code?
09:12:35 <thoughtpolice> by many people, over many years. it is not easy code but then again, GHC is not simple either
09:12:38 <merijn> thoughtpolice: Not just in that sense but also in the ad hoc not very well though out design sense. But that's off-topic flamewar material, so lets stick with that
09:13:27 <Eduard_Munteanu> lars9: I kinda appreciate that stuff.
09:13:33 <merijn> Eduard_Munteanu: No, we have a mandatory OS hacking course, and with AST being a faculty member that of course uses Minix :p
09:13:37 <thoughtpolice> i'm not so sure. linux had most of the fundamental design from prior unix OSs, so i'm not really sure how much groundwork was actually done on the part of linux people. there are definitely flops, but I don't think linux radically changed things in this area (correct me if I'm wrong because I was about 1.2 years old when torvalds made the first release)
09:13:39 <rovar> if you have a need for a single purpose kernel for an appliance or somesuch,  Minix is great, but I wouldn't use it as the default platform for an enterprise..
09:13:44 <Eduard_Munteanu> merijn: oh, nice.
09:14:03 <merijn> thoughtpolice: I much prefer the FreeBSD kernel to the Linux one
09:14:16 <merijn> thoughtpolice: The code quality and design is better, on average
09:14:23 <Jafet> lars9: some might say that the macros turn C into a language more suited to writing linux.
09:14:52 <Jafet> Of course, you have to learn that language first...
09:15:02 <thoughtpolice> freebsd is certainly very nice code, i'll agree with you. i'm just pointing out that it's not as clear cut as "linux code bad, freebsd/minix code good" when you consider the use cases and workloads. not to say linux is the bestest written software ever, but there's more to it than that
09:15:05 <rovar> the freebsd kernel is more consistent and ideologically pure
09:15:13 <Eduard_Munteanu> For me, writing C code is fun when you're doing plumbing, not when writing very high-level stuff.
09:15:29 <Eduard_Munteanu> And conversely, Haskell is nice for expressing high-level stuff in a terse format.
09:15:32 <b_jonas> rovar: that's what they still keep saying, but that was true only back in the dark days of linux imo
09:15:54 <rovar> b_jonas,  well.. it's not necessarily an argument *for* fbsd
09:16:11 <rovar> linux will take shortcuts in the interest of efficiency
09:16:29 <Eduard_Munteanu> Like when wondering "hm, perhaps this if(unlikely()) shouldn't even be here, it hurts performance too much).
09:16:35 <merijn> thoughtpolice: I'm not saying it was bad, I'm saying its an awful starting point for people who want to learn about OS coding :p
09:16:51 <thoughtpolice> merijn: oh sure, i'll totally agree with that too
09:17:24 <thoughtpolice> there is some scary shit in the lowest level parts of that system
09:17:27 <merijn> Were my personal experience shows me that the Minix3 code is an awesome starting point (especially combined with the book)
09:17:53 <rovar> http://hpaste.org/41660/check_my_work
09:18:02 <rovar> this typechecks, but am I doing it right? 
09:18:47 <rovar> heh.. i love the auto hlint feature in hpaste
09:18:49 <aavogt> rovar: you can be lazier
09:19:08 <aavogt> this equation doesn't need to inspect the second argument Nothing <*> (Just g) = Nothing
09:19:09 <lars9> rovar: you can replace last two lines with _ _ = Nothing
09:19:26 <rovar> that makes sense
09:19:28 <b_jonas> rovar: does that define Nothing <*> Nothing?
09:19:29 <lars9> * _ <*> _
09:20:13 <Eduard_Munteanu> I think you should get warnings about non-exhaustive patterns if you compile with -Wall
09:20:30 <tonkman> Is there any gui libraries for windows that do not require installing any environments?
09:20:49 <Eduard_Munteanu> tonkman: what do you mean by "environments"?
09:21:02 <tonkman> like GTK or WX
09:21:06 <Eduard_Munteanu> tonkman: I think you can do with static linking and Gtk2Hs.
09:21:18 <Eduard_Munteanu> Then your executable will have everything.
09:21:25 <tonkman> oh, cool
09:21:40 <rovar> http://hpaste.org/paste/41660/take_two#p41661
09:21:41 <tonkman> Where I can get more specific instructions
09:21:49 <rovar> v2.0
09:22:23 <Eduard_Munteanu> tonkman: GHC does static linking by default. Try your executables on a computer without GTK and the platform, and see if it works.
09:22:56 <tonkman> Ok, after I have succesfully installed GTK
09:23:04 <tonkman> I have few problems
09:24:06 <Eduard_Munteanu> Even if not, you might be able to distribute your program along with a few DLLs you need.
09:24:37 <lars9> @hoogle Just a -> Just b -> Just (a b)
09:24:37 <lambdabot> Did you mean: Maybe a -> Maybe b -> Maybe (a b) /count=20
09:24:38 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
09:24:38 <lambdabot> Prelude (>>) :: Monad m => m a -> m b -> m b
09:24:38 <tonkman> I tried to write my program on win32
09:24:44 <tonkman> never have to try again that
09:25:39 <Jafet> Isn't there a direct winapi library?
09:26:01 <Eduard_Munteanu> I'd really really not write MFC apps like that.
09:26:43 <Jafet> If they were monadic functor classes, it might not be so bad
09:27:00 <Eduard_Munteanu> Heh.
09:27:17 <tonkman> Jafet: Dont ever even think win32 api
09:27:44 <Twey> >.-
09:27:50 <Eduard_Munteanu> IMHO, Gtk2Hs is worth distributing a few extra MiBs of binary code
09:28:48 <tonkman> am I only one who can't install GTK?
09:28:57 <Eduard_Munteanu> (Especially since that's the way Windows apps have been doing distribution for a long time)
09:29:06 <lars9> tonkman: life is short, use linux :)
09:29:07 <Eduard_Munteanu> tonkman: gtk or gtk2hs?
09:29:15 <tonkman> *gtk2hs, sorry
09:29:23 <Eduard_Munteanu> tonkman: why can't you install it?
09:29:30 <tonkman> I have tried with cabal install and from binaries
09:29:49 <Eduard_Munteanu> tonkman: binaries work with older Platform versions.
09:30:04 <tonkman> I have installed older ghc
09:30:15 <Eduard_Munteanu> At least here on Wine I had major issues, and could only install binaries.
09:30:24 <tonkman> I have no clue why it wont work, but think I can solve this
09:30:31 <Eduard_Munteanu> tonkman: so what happens exactly?
09:31:33 <tonkman> when installing gtk2hs it finds ghc and everything seems to work
09:31:54 <tonkman> but ghc doesnt find the library
09:32:06 <aavogt> how are you calling ghc?
09:32:16 <Eduard_Munteanu> tonkman: does the installer complain in any way about the GHC version?
09:32:17 <tonkman> :m +Graphics.UI.GTK
09:32:27 <tonkman> I have also tried to compile demos
09:32:32 <tonkman> Eduard_Munteanu: no
09:32:48 <tonkman> I downloaded 6.6.1, what should work
09:33:00 <Eduard_Munteanu> tonkman: what gtk2hs version?
09:33:12 <tonkman> 0.9.12
09:33:32 <jmcarthur> woah 6.6.1?
09:33:39 <tonkman> http://haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/
09:33:52 <nostrand> at my uni we have GHC 5 :D
09:33:54 <jmcarthur> omg just use up to date stuff please :o
09:33:57 <jmcarthur> :O
09:34:02 <jmcarthur> that's horrifying
09:34:06 <nostrand> how old is GHC 5?
09:34:16 <Eduard_Munteanu> I've had success on Wine with Platform version 2009.2.0.1 and gtk2hs-0.10.1
09:34:26 <byorgey> GHC *5*!?
09:34:27 <jmcarthur> well, 6 was out before i started using haskell so i'm not even sure how old 5 is
09:34:28 <Heffalump> 7 years?
09:34:46 <jmcarthur> how do you live?
09:35:12 * jmcarthur wonders what somebody 7 years in the past would have though of this conversation
09:35:13 <byorgey> Version 5.04.3 (released 11 March 2003)
09:35:15 <tonkman> I give a try with cabal install
09:35:15 <jmcarthur> *thought
09:35:19 <byorgey> that was the last release in the 5.x series
09:35:30 <Eduard_Munteanu> tonkman: ^
09:35:31 <nostrand> byorgey: thanks
09:35:38 <geheimdienst> unbelievable. that ghc version predates lolcats.
09:35:40 <Eduard_Munteanu> tonkman: I meant binary
09:35:55 <jmcarthur> lolcats isn't *really* that old is it?
09:36:06 <Eduard_Munteanu> I'd uninstall the current GHC/Platform first.
09:36:16 <tonkman> Ok, I try 2009.2.0.1
09:36:20 <tonkman> done that
09:36:27 * hackagebot uuagc 0.9.33 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.33 (ArieMiddelkoop)
09:36:39 <Eduard_Munteanu> tonkman: I mean that exact combination of the Platform and gtk2hs
09:36:47 <geheimdienst> yeah but lolcats are as important a milestone as any
09:36:56 <tonkman> I think that most of my problems originate from windows _server_ 2003
09:36:58 <nostrand> jmcarthur: i don't use it. I used to SSH to my home computer, then i bought a laptop =)
09:36:59 <Eduard_Munteanu> tonkman: and do make sure there's no other platform install left behind
09:37:09 <jmcarthur> nostrand: good for you!
09:37:10 <geheimdienst> lolcats : internet :: gutenberg bible : movable type
09:37:11 <Eduard_Munteanu> That's possible.
09:37:38 <Eduard_Munteanu> In some sense this makes me wonder if Wine isn't better :)
09:37:54 <rovar> lolcode : haskell : ml : lisp
09:38:19 <geheimdienst> lolcode : haskell : ml : lisp : []
09:38:47 <Jafet> Yeah, lolcode is like getting head.
09:38:59 <Eduard_Munteanu> :)
09:39:13 <rovar> alright.. which bot stores quotes?
09:39:35 <byorgey> rovar: lambdabot does
09:39:50 <rovar> lambdabot, help
09:39:53 <rovar> @help
09:39:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:39:57 <Eduard_Munteanu> @quote kmc Coq
09:39:58 <lambdabot> No quotes match.
09:40:02 <byorgey> @quote Coq
09:40:02 <lambdabot> monochrom says: Ask Coq. Don't rely on head.
09:40:07 <Eduard_Munteanu> @quote kmc coq
09:40:07 <lambdabot> No quotes match. The more you drive -- the dumber you get.
09:40:08 <rovar> @help quote
09:40:08 <lambdabot> quote <nick>
09:40:08 <lambdabot> remember <nick> <quote>
09:40:08 <lambdabot> Quote somebody, a random person, or save a memorable quote
09:40:16 <Jafet> @quote coq
09:40:16 <lambdabot> roconnor says: <roconnor> merijn: I got into Haskell from Coq. <xplat> that's like getting into drinking through heroin.
09:40:21 <Twey> Hehe
09:40:31 <Eduard_Munteanu> :))
09:40:35 <rovar> @remember Jafet Yeah, lolcode is like getting head.
09:40:35 <lambdabot> Done.
09:41:17 <rovar> @quote lolcode
09:41:18 <lambdabot> Jafet says: Yeah, lolcode is like getting head.
09:41:21 <rovar> @quote lolcode
09:41:22 <lambdabot> Jafet says: Yeah, lolcode is like getting head.
09:41:43 <rovar> @quote integration
09:41:43 <lambdabot> TheoDeRaadt says: But software which OpenBSD uses and redistributes must be free to all (be they people or companies), for any purpose they wish to use it, including modification, use, peeing on, or
09:41:44 <lambdabot> even integration into baby mulching machines or atomic bombs to be dropped on Australia.
09:41:46 <Eduard_Munteanu> Some context would've been better.
09:41:50 <Jafet> @forget Jafet Yeah, lolcode is like getting head.
09:41:50 <lambdabot> Done.
09:41:56 <Jafet> @quote jafet
09:41:56 <lambdabot> jafet says: "Zygomorphism" sounds like a reproductive disorder
09:42:02 <Eduard_Munteanu> :))
09:46:18 <romildo> I need to escape special characters in an URI. Is there a function for that in hackage? For instance, in "http://www.adorocinema.com/common/search/search_by_film/?criteria=O Ultimato Bourne" the spaces is invalid. Any help?
09:46:31 <winmike> hi
09:46:56 <winmike> i found List.intersection and union. is there no "difference" function?
09:47:31 <Jafet> :t (\\)
09:47:32 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
09:47:52 <winmike> hmm
09:47:56 <winmike> thx a lot
09:48:05 <byorgey> romildo: maybe try the uri package?
09:48:31 <byorgey> winmike: however, depending on what you are doing, you might consider using Data.Set instead
09:48:35 <tonkman> Eduard_Munteanu: gtk2hs 0.10.1 installed nicely
09:48:44 <tonkman> but ghc cant find gtk
09:49:10 <byorgey> winmike: it depends on whether you care about the order of things in the list
09:49:33 <winmike> byorgey, no - the order is not imoirtant
09:49:40 <Eduard_Munteanu> tonkman: are you sure there aren't multiple platforms/ghcs around in Program Files/Haskell Platform?
09:49:48 <tonkman> yes
09:49:51 <byorgey> winmike: ok, then Data.Set will be much faster
09:50:39 <Eduard_Munteanu> tonkman: does 'ghc-pkg list' show it at all?
09:50:50 * Eduard_Munteanu was going to tell you to grep :/
09:51:05 <tonkman> no grep in windows :C
09:51:18 <Eduard_Munteanu> tonkman: post the output of that command in pastebin
09:51:32 <Eduard_Munteanu> *a pastebin
09:52:09 <tonkman> http://hpaste.org/41662/pkg
09:52:48 <medfly> http://gnuwin32.sourceforge.net/packages/grep.htm :3
09:53:42 <tonkman> what if: http://www.haskell.org/gtk2hs/archives/2005/06/24/building-from-source-on-windows/
09:54:33 <Eduard_Munteanu> tonkman: hm, did you try manually adding C:\gtk2hs-0.10.1\bin in PATH?
09:54:38 * Eduard_Munteanu looks
09:54:45 <tonkman> I checked path
09:54:49 <tonkman> Its there
09:55:03 <Eduard_Munteanu> tonkman: if you want to build it, just cabal install it
09:55:11 <tonkman> going to try that now
09:55:22 <Eduard_Munteanu> tonkman: you'll need gtk2hs-buildtools first, then gtk IIRC
09:55:33 <Eduard_Munteanu> and you need GTK itself I think.
09:55:41 <tonkman> and mingw?
09:55:53 <Eduard_Munteanu> I'm not sure, maybe not.
09:56:13 <Eduard_Munteanu> It no longer has any configure script.
09:56:13 <tonkman> ok
09:56:58 <Eduard_Munteanu> Cabal install didn't work for me, but I was on Wine
09:57:25 <Eduard_Munteanu> (didn't work for installing gtk2hs, other things went well)
09:58:07 <Eduard_Munteanu> tonkman: use a binary GTK distribution
09:59:57 <tonkman> setup.exe: pkg-config version >=0.9.0 is required but it could not be found.
10:00:04 <tonkman> so mingw or cygwin is needed
10:02:06 <Eduard_Munteanu> tonkman: mingw
10:02:56 <Eduard_Munteanu> tonkman: oh, wait, the binary distribution of GTK contains pkg-config
10:03:11 <Eduard_Munteanu> tonkman: did you add c:\gtk\bin in PATH?
10:04:57 <Eduard_Munteanu> Wow, people are still using Motif oO
10:05:58 <Eduard_Munteanu> I kinda hate that look.
10:07:06 <edlinde> hi guys, say I had a list of 3 elements like (-1,0,+1) and I wanted to make every possible two-pair from it, is there a list comprehension to do it?
10:07:27 <edlinde> so I get values like (-1,-1) (-1,0) .... etc
10:08:57 <stulli> edlinde: [(x,y) | x <- [-1,0,1], y <- [-1,0,1]]
10:09:06 <mornfall> You mean like [ (x, y) | x <- [ ... nevermind, stulli got it. :)
10:09:20 <Eduard_Munteanu> > [(x, y) | x <- [-1,0,1], y <-[-1,0,1], x /= y]
10:09:21 <lambdabot>   [(-1,0),(-1,1),(0,-1),(0,1),(1,-1),(1,0)]
10:09:45 <edlinde> it missed 1,1
10:09:51 <edlinde> but its cool
10:09:53 <edlinde> thanks guys
10:09:53 <mornfall> edlinde: He explicitly removed it.
10:10:02 <edlinde> i got to learn list comprehensions :)
10:10:05 <edlinde> awesome stuff
10:10:06 <luite> edlinde: if you want your result to be a list, you can use > replicateM 2 [-1,0,1]
10:10:45 <luite> which you can use for lists of other lengths as well
10:11:59 <mikeg> Neat, here's a picture of hexpat lazily traversing a 1TB XML file. Nice and leak-free :D http://i.imgur.com/aqT6w.png
10:12:36 <luite> 1TB XML file o_O
10:13:27 <mikeg> The wikipedia database ;D 6GB bz2 file -> lots of XML
10:14:13 <luite> sounds like an impressive waste of resources ;p
10:14:22 <Eduard_Munteanu> I can't really tell from the pic, but I'm sure bytestring does better than []
10:14:39 * hackagebot atomo 0.2.2.1 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.2.2.1 (AlexSuraci)
10:15:35 <mikeg> "for research"
10:16:05 <luite> does that file include history?
10:16:34 <mikeg> No, just 10 million current articles (most of which are small redirect files)
10:18:08 <edlinde> sorry with the list comp .. .is there a way to eliminate the tuple (0,0)?
10:18:16 <mikeg> I'm parsing the articles into tar.bz2's of ~1000 files, so I can relatively quickly extract a given article. All of the .tbz's only add an overhead of ~.3GB from the original compressed XML
10:18:35 <luite> but I'm pretty sure most of it is complete episode lists of terrible tv shows ;)
10:18:35 <edlinde> [(x, y) | x <- [-1,0,1], y <-[-1,0,1], x /= y] here...
10:19:23 <aavogt> edlinde:  [(x, y) | x <- [-1,0,1], y <-[-1,0,1], (x,y) /= (0,0)]
10:19:30 <mikeg> Haha, at the moment I'm only looking at making a graph of date of birth vs. date of death.. so still mostly useless data :)
10:19:53 <edlinde> thanks!
10:29:12 <Dari> Ahoy
10:29:34 <Dari> I want to retrieve values from the environment variables
10:29:49 <Dari> I found help on the internet but can't get it to work properly
10:30:10 <alexsuraci> when does hackage build the docs for new packages?
10:30:10 <Dari> I'm using System.Environment.getEnvironment
10:30:29 <Dari> And I would like to turn it in a Data.Map.Map String String
10:30:32 <Dari> With e function
10:30:35 <Dari> *a
10:31:37 <Dari> I used "getEnvMap = do env <- System.Environment.getEnvironment ; return ( Data.Map.fromList env )"
10:31:48 <Dari> And can't get types right :/
10:31:52 <mikeg> Dari: fmap Map.fromList getEnvironment
10:32:13 <Dari> Okies
10:32:17 <Dari> thanks
10:33:42 <aavogt> well the original expression works too
10:34:15 <sipa> :t System.Environment.getEnvironment
10:34:16 <aavogt> Dari: the type has to be     IO (Data.Map.Map String String)
10:34:16 <lambdabot> IO [(String, String)]
10:34:28 <Dari> Oh, OK
10:34:42 <Dari> I was trying to extract from the IO monad
10:34:46 <sipa> > System.Environment.getEnvironment
10:34:47 <lambdabot>   Not in scope: `System.Environment.getEnvironment'
10:34:48 <mikeg> Eek
10:35:05 <Dari> I should do it after, maybe?
10:35:23 <aavogt> yeah, that's not allowed. you put your functions and stuff into the IO
10:35:38 <Dari> OK
10:35:53 <Dari> pure and impure code, right?
10:36:08 <sipa> Dari: the only way to turn an IO a expression into a a expression is by using unsafePerformIO
10:36:28 <Dari> Ok
10:36:33 <aavogt> or other unsafe functions
10:36:41 <sipa> yes, there are alternatives
10:36:43 <Dari> Which is not cool :]
10:36:46 <Dari> Okay
10:36:52 <sipa> in this case, i suppose it you could use them
10:37:09 <sipa> assuming the environnement doesn't change
10:38:16 <aavogt> maybe not in this case, but you might end up with exceptions from the IO that gets done at a random point in your program (using unsafePerformIO)
10:39:22 <tonkman> Eduard_Munteanu: I MADE IT
10:40:08 <Dari> Okay, my function is right now
10:40:26 <Dari> I can use it with "env <- getEnvMap" now ?
10:40:47 <tonkman> Eduard_Munteanu: I succesfully cabal installed gtk, but it does not show in ghc-pkg
10:41:17 <sipa> Dari: yes
10:41:33 <Dari> Ok
10:41:38 <Dari> (thanks for help by the way)
10:41:51 <tonkman> Eduard_Munteanu: forget, it works
10:41:51 <sipa> yw
10:44:43 <Dari> Okay, seems to work, I'm on to my next problem now :]
10:46:32 <romildo> I am using the function:
10:46:33 <romildo> openURL x = getResponseBody =<< simpleHTTP (getRequest x)
10:47:19 <romildo> to download a web page. It uses the module Network.HTTP.
10:48:04 <romildo> But I am not getting the full web source. I is being 'cut' at a certain size.
10:48:47 <romildo> I am trying with the URL: http://www.adorocinema.com/common/search/search_by_film/?criteria=Bourne"
10:49:16 <romildo> Why am I not getting the full HTML source of the page?
10:50:02 <turiya> what is the use of ! (exclamation mark) in a haskell program (particularly in defining data types)
10:51:01 <yiannis_t> turiya: what do you mean? can you post an example ?
10:51:19 <Eduard_Munteanu> tonkman: what was wrong?
10:51:31 <Twey> romildo: I don't get the full source to telnet, either, if it helps.
10:51:34 <turiya> yiannis_t: hmatrix-0.10.0.0:Data.Packed.Internal.Vector.ioff :: !Int
10:51:54 <Eduard_Munteanu> turiya: it means strict fields
10:52:14 <tonkman> Eduard_Munteanu: nothing, ghc just was not updated
10:52:17 <Eduard_Munteanu> like if you use data Foo = Foo !Int
10:52:28 <turiya> Eduard_Munteanu: what are strict fields?
10:52:30 <tonkman> hello world in gtk is 15Mb big :/
10:52:45 <Eduard_Munteanu> tonkman: yeah, it's statically built
10:53:09 <tonkman> still it requires few dlls
10:53:39 <Eduard_Munteanu> turiya: they're evaluated strictly (as in not lazily), it also lets the compiler unbox them
10:53:47 <yiannis_t> turiya: it means tha the evaluation is forced (in contrast to haskell's laziness)
10:54:46 <turiya> exactly which evaluation is forced?
10:55:31 <romildo> Twey, I see that 'elinks --source' also fails to get the full source. I have no idea of the reason :(
10:55:40 <Twey> romildo: I think it's the server's fault
10:56:03 <Twey> From what I can tell, it has rather a short connection time-out
10:56:08 <Twey> And it's under quite a lot of load
10:56:14 <Twey> So it's responding slowly
10:56:19 <Twey> But I could be mistaken
10:56:20 <yiannis_t> turiya: Do you know what '$' operator does?
10:56:31 <turiya> yiannis_t: no
10:56:39 <romildo> Twey, firefox gets it full.
10:56:46 <yiannis_t> turiya: ok. it forces right associavity in operations
10:56:52 <Twey> romildo: It might retry
10:57:12 <Twey> Or get it in chunks, or something
10:57:17 <romildo> Twey, there would be anything I can do in my Haskell program to get it?
10:57:34 <yiannis_t> turiya: for example: return $ my_res + 3 is equivalent to return (my_res + 3)
10:58:30 <Eduard_Munteanu> turiya: normally that would've been left as a lazy thunk
10:58:35 <turiya> yiannis_t: so, "return a + b + c" = return (a + b + c)?
10:58:44 <Eduard_Munteanu> No.
10:58:52 <turiya> sorry
10:58:52 <Eduard_Munteanu> return $ a + b + c
10:58:58 <yiannis_t> turiya: when you do: return $! my_res + 3 you force the evaluation of my_res + 3 in contrast to returnin a lazy thunk
10:59:04 <turiya> yeah.. right.. typo
10:59:18 <Twey> romildo: Probably.  I don't know what, though.  Have a look at what Firefox is doing with a packet-sniffer, maybe.
11:00:08 <turiya> yiannis_t: i get it now but what is the use of ! in the declaration (?) of a data type?
11:00:30 <yiannis_t> turiya: this denotes tha the data type should be unboxed
11:00:45 <turiya> unboxed?
11:01:57 <Eduard_Munteanu> turiya: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/primitives.html
11:02:00 <HugoDaniel2> Conditionals (e.g. "if e1 then e2 else e3") means "ifThenElse e1 e2 e3". However case expressions are unaffected. 
11:02:01 <Eduard_Munteanu> for unboxed stuff ^
11:02:05 <HugoDaniel2> this seems like the feat!
11:02:29 <Eduard_Munteanu> turiya: and here for the '!' thing http://www.haskell.org/haskellwiki/Performance/Data_types
11:06:51 <turiya> Eduard_Munteanu: "An unboxed type, however, is represented by the value itself, no pointers or heap allocation are involved". Does it mean that space is created in the executable itself?
11:07:38 <Eduard_Munteanu> turiya: not really, it could live on the stack
11:07:54 <Heffalump> it means that no separate heap allocations or pointers are needed - it uses the same ones as the thing containing it
11:08:16 <Eduard_Munteanu> Or yeah, it's directly embedded in the bigger object.
11:08:59 <Jafet> It means that the constructor is strict and the type has no bottom.
11:09:21 <Jafet> Which has other side-effects, like saving space, that some people like to harp on
11:09:29 <turiya> Eduard_Munteanu: i see..
11:13:48 <turiya> thanks guys, i got some doubts cleared 
11:22:14 <mtbeedee> Hey, I am a newbie and I have a question about stringing functions together.
11:22:45 <mtbeedee> how do you do it?  like in java you'd do Something.method(Otherthing.method2())
11:22:51 <mtbeedee> in haskell something like
11:23:08 <mtbeedee> putStrLn show doubleThis 42
11:23:10 <mtbeedee> it doesn't understand
11:23:18 <mtbeedee> it tries to call them in forward order
11:23:43 <mauke> putStrLn (show (doubleThis 42))
11:23:53 <Eduard_Munteanu> :t (.)
11:23:54 <mtbeedee> you need to qualify it with the parens?
11:23:54 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:24:03 <Eduard_Munteanu> aw crap
11:24:05 <mauke> mtbeedee: yes, otherwise it tries to call putStrLn with three arguments
11:24:26 <mtbeedee> of course
11:24:27 <Eduard_Munteanu> Or putStrLn $ show (doubleThis 42)
11:24:29 <mtbeedee> duh
11:24:40 <mtbeedee> what is that $ thing?
11:24:46 <mtbeedee> havent seen that yet
11:24:48 <mauke> @src ($)
11:24:49 <lambdabot> f $ x = f x
11:24:59 <Entroacceptor> but with a very low operator precedence
11:25:01 <mauke> a cute little operator doing nothing
11:25:06 <mtbeedee> hmm
11:25:11 <mauke> can save you typing some parens
11:25:16 <Eduard_Munteanu> mtbeedee: it makes putStrLn bind less tight, taking one arg
11:25:41 <mtbeedee> it forces the preceeding function to only bind to one arg?
11:26:14 <Eduard_Munteanu> mtbeedee: if you want function composition style, you can do it like putStrLn . show . doubleThis $ 42
11:27:11 <Eduard_Munteanu> (.) :: (b -> c) -> (a -> b) -> (a -> c)
11:27:28 <mtbeedee> yea, I am looking at that trying to understand what it's saying
11:27:41 <mtbeedee> it takes 2 tuples and a atom and evaluates it?
11:28:05 <Eduard_Munteanu> mtbeedee: rather it makes show take what follows as an arg
11:28:23 <Eduard_Munteanu> What tuples/atom? :/
11:28:41 <sgtarr> So i've been looking at interesting functional languages. I've been visiting Clojure, scala, f# and now finally I've landed at Haskell, it looks interesting. 
11:28:45 <mtbeedee> isnt that the same thing that $ does?
11:28:52 <Eduard_Munteanu> Normally function application binds tightest, hence putStrLn sees show as an argument, rather than the whole expression
11:29:47 <Eduard_Munteanu> sgtarr: it actually is :)
11:30:21 <sgtarr> Eduard_Munteanu: people had been telling me that it's mostly an academic language, mostly interested to the PhD's with an interest in formal methods and such
11:30:40 <sgtarr> Eduard_Munteanu: to be honest, I'm interested in that too, but mostly I'm interested in creating solid bullet proof software that will run forever.
11:30:59 <mtbeedee> thanks guys
11:31:25 <Jafet> Forever? That's Visual Basic 6.
11:31:33 <Jafet> You're on the wrong floor, sir.
11:31:46 <Eduard_Munteanu> sgtarr: it indeed interests academics, but developers too. If not for academic stuff, at least for its brevity and elimination of runtime errors.
11:32:28 <aavogt> you don't eliminate failures at runtime
11:32:36 <Eduard_Munteanu> @faq Do Haskell programs halt on any input? :P
11:32:36 <lambdabot> The answer is: Yes! Haskell can do that.
11:32:54 <maurer_> :/
11:32:59 <maurer_> For that nonsense, you want agda
11:33:01 * hackagebot lhs2TeX-hl 0.1.2.1 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.2.1 (AlessandroVermeulen)
11:33:02 <Eduard_Munteanu> aavogt: I mean strong typing prevents some runtime erros
11:33:06 <Eduard_Munteanu> *errors
11:33:12 <maurer_> Successful compilation of an agda program comes with a proof of termination.
11:33:39 <Eduard_Munteanu> maurer_: yeah, though I think you can turn that termination checker off, right?
11:34:10 <Eduard_Munteanu> :t forever
11:34:11 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b
11:34:32 <maurer_> If you're bothering t ouse agda, I figure you want a proof that everything works properly. Disabling termination checking violates that.
11:34:32 <aavogt> yeah, and you can turn off the type system in haskell with various unsafe function or the foreign function interface
11:34:53 <Jafet> Can't you just plug in a proof of false?
11:34:53 <maurer_> For example, I can write:
11:35:10 <maurer_> f () = f ()
11:35:16 <maurer_> and declare the type to be () -> a
11:35:17 <applicative> are you advising sgtarr to bypass Haskell for Agda?  
11:35:29 <maurer_> And then agda's proof system is broken :(
11:35:31 <Eduard_Munteanu> I hope not.
11:35:38 <Eduard_Munteanu> Yeah.
11:35:49 <maurer_> applicative: No I was just making fun of Munteanu for his @faq
11:36:06 <maurer_> Agda has its place, and its place is not developing code.
11:36:19 <Jafet> applicative: the kingpins demand it
11:36:22 <maurer_> Haskell is great for writing real applications but still having some of the good old functional strongly typed mojo.
11:36:27 <Eduard_Munteanu> And I was picking at "run forever" :)
11:36:39 <applicative> maurer_ you mean, your'e not helping with the new Agda web framework....
11:36:49 <Jafet> @hoogle indefinitely
11:36:49 <lambdabot> Control.Exception data BlockedIndefinitely
11:36:49 <lambdabot> Control.Exception BlockedIndefinitely :: BlockedIndefinitely
11:36:49 <lambdabot> Control.OldException BlockedIndefinitely :: Exception
11:36:55 <maurer_> applicative: I think that's just an exercise in wankery.
11:37:07 <dixie> hackagebot is rss2irc ?
11:37:17 <maurer_> Agda is a neat tool for formal methods, but most of the people I know who use agda have started to use twelf instead.
11:37:29 <Jafet> applicative: will it allow printing page load times in the page header instead of the footer?
11:38:08 <applicative> Jafet, surely it will also come with a proof that that's where the page load time is printed
11:38:42 <danharaj> Are functors equipped with Zip strictly more specific than functors with Applicative?
11:38:54 <sgtarr> what's new in ghc 7? I just downloaded 140MB worth of ghc 6.12.3 :)
11:38:58 <applicative> sgtarr, I can't tell if our friends are advising you well
11:39:04 <applicative> oh there you are
11:39:24 <applicative> i'm still on 6.12 too
11:39:39 <sgtarr> oh ok, that's fine then.
11:39:50 <Eduard_Munteanu> sgtarr: AFAIK, there isn't much that's visible to coders.
11:40:09 <sgtarr> well that sounds good, so the code will be backwards compatible
11:40:16 <Eduard_Munteanu> You should be getting the Platform, not just GHC.
11:40:26 <Eduard_Munteanu> erm, Haskell Platform
11:40:44 <applicative> sgtarr, there's a summary by Brian O'Sullivan here http://www.reddit.com/r/haskell/comments/e6o0y/ghc_701_released/c15q68m
11:40:53 <sgtarr> Eduard_Munteanu: yes, i got both
11:41:11 <Entroacceptor> just stick with 6 for now
11:41:14 <sgtarr> applicative: hm, dang, reddit, I blocked it.  It makes me procrastinate.
11:41:34 <applicative> good work. here's http://new-www.haskell.org/ghc/docs/7.0.1/html/users_guide/release-7-0-1.html
11:41:43 <sgtarr> thanks
11:41:51 <applicative> sgtarr, what os are you using
11:41:52 <Eduard_Munteanu> Though if you're on a decent Linux distro (wrt Haskell support), distro packages might do as well.
11:42:11 <sgtarr> applicative: OS X mainly, also FreeBSD and OpenSolaris / illumos
11:42:28 <Eduard_Munteanu> I think the Platform is better then.
11:42:39 <applicative> on OS X you should stick with the platform installer I think, though it's a bit of a nightmare in some cases
11:42:47 <exDM69> when was GHC 7 released?
11:42:57 <sgtarr> I used the platform installer for OS X.  It was very quick. 
11:43:03 <aavogt> this week exDM69
11:43:40 <danharaj> :t rem
11:43:41 <lambdabot> forall a. (Integral a) => a -> a -> a
11:43:55 <applicative> sgtarr, it's good, but keep in mind its 32 bit, and there can be delicacies with macports.  It is set up to use the OS X versions of several great c libs for instance
11:43:57 <danharaj> Is there a rem that works on any num?
11:44:17 <Eduard_Munteanu> danharaj: why? For floats?
11:44:22 <danharaj> Yeah
11:44:50 <Eduard_Munteanu> I'd just stick it inbetween toIntegral and fromIntegral
11:45:09 <applicative> sgtarr, but if you are using esoteric things like OpenSolaris, you will probably understand the possible errors more readily than some of us
11:45:35 <Eduard_Munteanu> @src Integral
11:45:35 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:45:35 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:45:35 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:45:35 <lambdabot>     toInteger           :: a -> Integer
11:45:54 <danharaj> wait
11:45:59 <sgtarr> applicative: 32-bit? I guess i'd have to compile my own if I needed 64-bit then.  32-bit is fine for now.
11:46:05 <danharaj> is float in Integral?
11:46:05 <applicative> sgtarr, I mean the errors mixing up c library versions on OS X.  
11:46:15 <Eduard_Munteanu> danharaj: I doubt it.
11:46:21 <Eduard_Munteanu> > 3.0 `rem` 2
11:46:22 <applicative> yeah, the macports version is 64 bit at the moment.  
11:46:22 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:46:22 <lambdabot>    `GHC.Real.Integral a'
11:46:22 <lambdabot>   ...
11:46:29 <sgtarr> applicative: oh i see, that's good
11:46:44 <danharaj> > 3.68 `rem` 1.2
11:46:45 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:46:45 <lambdabot>    `GHC.Real.Integral a'
11:46:45 <lambdabot>   ...
11:46:50 <applicative> I am hoping they will sort this out for the ghc 7 version of the platform in a month or so, not sure when
11:46:53 <sipa> @instances Integral
11:46:54 <lambdabot> Int, Integer
11:47:11 <Eduard_Munteanu> danharaj: oh, that wouldn't make much sense anyway.
11:47:33 <Eduard_Munteanu> Unless you somehow want the quotient to be integer.
11:48:02 <marks> hello room.. I'm new to haskell and looking to parse a binary file for my first project. I'm confused by the libraries I've found: there's Data.ByteString.Parser as well as Text.Parsec.Bytestring... I know parsec is a parsing library, but can anyone advise which is the better choice for parsing binary data? what's the difference between the two?
11:48:19 <marks> sorry to but in :-)
11:48:22 <danharaj> At least for positive floats/doubles whatever I want it to just give me the smallest positive left over after repeated subtraction of one from the other
11:48:29 <Eduard_Munteanu> marks: no trouble
11:48:42 <danharaj> I thought there would already be a function for that.
11:48:48 <applicative> sgtarr, so have you been reading anything about Haskell yet, I mean a primer, tutorial?  
11:49:07 <sgtarr> applicative: currently busy with the wikibooks one
11:49:43 <Eduard_Munteanu> marks: Parsec is a full-fledged parser, like the kind you'd use to write a compiler, do you need that?
11:50:01 <applicative> sgtarr, oh, haven't looked at that lately.  
11:50:10 <sgtarr> seems pretty good so far
11:50:12 <Eduard_Munteanu> marks: what exactly do you mean by parsing there?
11:50:33 <Eduard_Munteanu> @where lyah
11:50:33 <lambdabot> http://www.learnyouahaskell.com/
11:50:35 <applicative> I take it you've seen the "learn you a haskell" and "real world haskell" pages?  
11:50:35 <marks> it's a dvi file I want to parse, so I guess that would be more complex than a jpg or something like that
11:50:43 <sgtarr> applicative: no :)
11:50:51 <applicative> sgtarr, oh they're good. 
11:50:57 * sgtarr . . .
11:50:59 <sgtarr> applicative: now I have.
11:51:02 <applicative> @where rwh
11:51:02 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:51:22 <sgtarr> this looks a lot better than the wiki book.
11:51:25 <applicative> rwh is in print;  lyah is supposed to be made into a book at some point. 
11:51:35 <marks> Eduard_Munteanu: I want to read in the binary .dvi file and disect it into individual typesetting commands
11:52:03 <applicative> rwh would be a little hard if you're not familiar with the abc's of the syntax and so forth -- the kind of thing you get from lyah
11:52:45 <dsunshine> My "ghc-pkg check" shows that I have alot of broken packages. Is there a way I can remove everything and start from scrath again?
11:52:48 <marks> Eduard_Munteanu: so you're saying Data.Bytestring.Parser is not a "fully fledged" parser?
11:52:56 <applicative> at some point, one should add the Typeclassopedia, which is totally awesome
11:53:35 <applicative> @where Typeclassopedia
11:53:35 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
11:54:02 <Eduard_Munteanu> marks: where did you find that?
11:54:47 <Saizan> dsunshine: you can rm -fr ~/.ghc
11:54:54 <applicative> sgtarr, there is also #haskell  Several of our friends are extremely talented at explaining things
11:55:12 <sgtarr> yep
11:55:31 <Saizan> dsunshine: that should be enough if you didn't install anything with --global
11:56:02 <marks> Eduard_Munteanu: that? that Data.ByteString is not a full-fledged parser? You seemed to imply it by saying parsec is :-)
11:56:22 <Dari> Ok, I'm clearly getting it wrong
11:56:24 <osaunders> You know what would be really cool: if GHC checked that instances of Functor, Applicative, Monad etc, obeyed the relevent laws.
11:56:35 <marks> Eduard_Munteanu: as in, the parser in Data.ByteString is only good for simpler binary formatd
11:56:36 <marks> s
11:56:38 <Dari> How could I retrieve the terminal size from Haskell?
11:56:58 <osaunders> Dari: There's a routine that does that in HSCurses
11:57:12 <Eduard_Munteanu> marks: I'm clueless about Data.ByteString.Parser, where did you find it? Data.ByteString is something else.
11:57:17 <Dari> So I must assume the terminal uses ncrses?
11:57:21 <Dari> *ncurses
11:57:38 <osaunders> Dari: http://hackage.haskell.org/packages/archive/hscurses/latest/doc/html/UI-HSCurses-Curses.html#v:scrSize
11:57:46 <sgtarr> 680 nicks in #haskell and less than half in #erlang.  I thought Erlang was far more popular.  Interesting.
11:57:55 <marks> Eduard_Munteanu: http://hackage.haskell.org/packages/archive/HCodecs/0.1/doc/html/Data-ByteString-Parser.html
11:57:57 <Eduard_Munteanu> Dari: the terminal doesn't use ncurses
11:57:57 <dsunshine> Saizan: Thanks, but I think I do have a few packages that I foolishly installed with global.
11:58:08 <osaunders> sgtarr: I think Haskellers like IRC more.
11:58:09 <Eduard_Munteanu> Dari: ncurses is just a UI for console-based apps
11:58:10 <monochrom> erlang people get real jobs using erlang, no time for irc :)
11:58:17 <Dari> Oh, OK
11:58:28 <Saizan> Dari: http://hackage.haskell.org/packages/archive/terminfo/0.3.1.3/doc/html/System-Console-Terminfo-Cursor.html
11:58:30 <Dari> So it will work whatever happens "under" the program?
11:58:36 <sgtarr> monochrom: should I be afraid since I'm diving into haskell then? ;)
11:58:37 <Eduard_Munteanu> marks: well, that's something the HCodecs package contains, I'm unsure you should depend on that.
11:59:04 <osaunders> sgtarr: I'm going to use Haskell for a startup
11:59:18 <sgtarr> osaunders: are you at liberty to say anything about the startup?
11:59:23 <Saizan> dsunshine: you can ghc-pkg unregister some of those manually, or just reinstall ghc
11:59:37 <osaunders> sgtarr: Yes but there's nothing to say, I haven't decided what to do yet.
11:59:46 <osaunders> It'll be a web app though.
11:59:48 <Eduard_Munteanu> Dari: not really
12:00:01 <sgtarr> osaunders: you know, it really doesn't matter what language you use for a startup, in 99% of cases
12:00:03 <Dari> Hrmph
12:00:20 <jmcarthur> well it matters a little
12:00:24 <Eduard_Munteanu> Dari: you kinda need to make some assumptions, for example it won't work on Windows if you're assuming an ANSI terminal
12:00:24 <jmcarthur> don't use brainfuck
12:00:48 <sgtarr> jmcarthur: fair enough, unless your startup is tied up with brainfuck somehow. A brainfuck consultancy, perhaps.
12:00:51 <osaunders> sgtarr: Yeah that's is pretty much true but I can't really stand normal languages.
12:00:53 <marks> Eduard_Munteanu: ok, I'll just use the parsec one then.. Thanks!
12:01:37 <jmcarthur> IMO, the most important criteria for a language is how much you enjoy it
12:01:47 <sgtarr> osaunders: i also have an idea for a "startup", that's actually wrong because it'd be more of a hobby and making money off it isn't that much of a deal, but in any case I wanted to use Haskell for it as well. Also a webapp
12:02:00 <Eduard_Munteanu> Dari: see termcap(5)
12:02:00 <sgtarr> osaunders: i figured it could be a good way to introduce myself to haskell
12:02:21 <jmcarthur> or rather... how enjoyable that language would be to use for the project you will use it for
12:02:27 <sgtarr> the real company I work for use mainly java ee 6 and .net
12:02:41 <jmcarthur> it's a vague criteria... almost obvious though
12:02:48 <osaunders> jmcarthur: I like that thought
12:03:11 <osaunders> sgtarr: I want to make money off of mine.
12:03:20 <sgtarr> osaunders: of course you do, we all love money.
12:03:30 <sgtarr> at least, if you're an entrepreneur.
12:03:30 <danharaj> does anyone else find it annoying that if you miss a parenthesis in a where clause, GHC tells you it is 'possibly incorrect identation'?
12:03:44 <osaunders> sgtarr: Actually, no, I wouldn't say I love money. I'd just like to have _some_.
12:05:32 <Philippa> danharaj: problem is it's actually pretty tricky to tell which kind of bracket it missed before the kind it ran into
12:05:33 <monochrom> haha, "multiplate is a lightweight generic library for mutually recursive data types that won't make Conor lose his lunch."
12:05:45 <sgtarr> osaunders: actually what I meant too.  My requirements aren't that much, as long as I can keep on going and focus on cool things instead of wasting time on crap that I do not want to do, such as housework or doing my laundry, and rather spend my time at work and with my hobbies, then I'm happy.
12:06:11 * hackagebot feed 0.3.8 - Interfacing with RSS (v 0.9x, 2.x, 1.0) + Atom feeds.  http://hackage.haskell.org/package/feed-0.3.8 (DonaldStewart)
12:07:02 <sgtarr> No need to be scrooge rich, is what I'm saying.
12:07:30 <BMeph> Howdy! Been a while, but I'm back...
12:09:36 <applicative> monochrom, yeah, that was pretty funny...
12:10:05 <applicative> sgtarr, another thing I was going to mention, if you haven't studies much is the 'interact' functions
12:11:10 <applicative> a module withe main = interact foo  will compile a String -> String function to a pipeable unix executable
12:11:29 <sgtarr> oh that is neat.
12:11:30 <dsunshine> Saizan: I get this error "MissingH-1.1.0.3 depends on haskell98-1.0.1.1 which failed to install." But "ghc-pkg list" shows "haskell98-1.0.1.1"
12:12:01 <applicative> sgtarr, similarly with the interact in Data.ByteString, or in Data.Text, they need a function ByteString -> ByteString or Text -> Text
12:12:17 <applicative> sgtarr, it's a very simple way of getting something useful fairly quicly. 
12:14:22 <danharaj> (fmap.fmap) is so cool
12:14:30 <sgtarr> applicative: i can see that, i like to learn with small practical things
12:14:43 <danharaj> :t (fmap.fmap)
12:14:44 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:14:48 <applicative> so import qualified Data.Bytestring as B;  main = B.interact foo  ; foo = B.reverse will reverse the bytestring, 
12:15:31 <applicative> main = interact foo ; foo = reverse  , compiled, will reverse the string, i.e.g put the characters in reverse order
12:16:20 <Saizan> dsunshine: it doesn't like your installed haskell98-1.0.1.1 for some reason so it's trying to install another and failing
12:16:35 <applicative> the standard incantation for compilation is ghc --make -O2 Foo.hs -o foo
12:17:01 <Saizan> dsunshine: it's not something that should be done anyway
12:17:21 <dsunshine> Saizan: What do you mean?
12:17:54 <Saizan> dsunshine: two installations of haskell98-1.0.1.1 are not really manageable
12:18:31 <Saizan> dsunshine: have you upgraded any package that came with ghc? that's one common pitfall
12:19:05 <dsunshine> Saizan: I was trying to and it failed. And I lost some modules I already had. Now I feel like I'm in limbo.
12:19:08 <sgtarr> applicative: tried it, works, although I get a newline before the reversed string.
12:19:25 <sgtarr> applicative: makes sense :)
12:19:37 <sgtarr> applicative: just need to find a way to snip the newline off
12:20:01 <applicative> foo = tail . reverse, i guess
12:20:06 <Saizan> dsunshine: i'd rather upgrade ghc
12:20:19 <applicative> if you are using prelude interact, \n is the first character
12:20:24 <sgtarr> bingo
12:20:40 <mauke> if you don't want the newline, why pipe it into the program in the first place?
12:20:54 <sgtarr> i didn't
12:20:55 <sgtarr> echo "foobar"  | ./foo
12:20:58 <mauke> you did
12:20:59 <applicative> mauke, we are just going over abcs with interact
12:21:00 <Eduard_Munteanu> or interact (unlines . reverse . lines)
12:21:01 <mauke> echo appens a \n
12:21:04 <sgtarr> hey mauke
12:21:05 <dsunshine> Saizan: I just reinstalled ghc6 is there another method to upgrade?
12:21:11 <mauke> sgtarr: echo -n foobar
12:21:13 <applicative> sgtarr has just installed ghc
12:21:14 <sgtarr> echo -n, you're right
12:21:33 <Saizan> dsunshine: nothing other than installing a newer version of ghc
12:21:37 <sgtarr> mauke: long time, what are you working on these days?
12:22:02 <Eduard_Munteanu> > unlines . reverse . lines $ "Hello\nWorld\n"
12:22:03 <lambdabot>   "World\nHello\n"
12:22:16 <mauke> sgtarr: looking into Moose, Catalyst, and javascript "strict mode"
12:22:23 <applicative> sgtarr, if you know mauke you're in good hands.  I should clear out....
12:22:27 <mauke> heh
12:22:41 <sgtarr> didn't know there was a javascript strict mode
12:22:58 <mauke> apparently new in ecmascript 5; no idea if anyone implements it
12:23:08 <dsunshine> Saizan: Ubuntu 10.04
12:23:11 <sgtarr> what's Moose?
12:23:29 <mauke> sgtarr: perl OO framework
12:24:09 <mauke> http://search.cpan.org/~drolsky/Moose-1.19/lib/Moose/Manual.pod
12:24:17 <sgtarr> almost forgot people still use perl
12:24:18 <Dari> Eduard_Munteanu: When I use the System.Console.Terminfo.Cursor.getLines, I get a "Capability Int", how can I retrieve the value inside?
12:24:30 * Eduard_Munteanu looks
12:24:36 <Dari> I'm definitely lost with these monad-y things
12:25:14 <mikeg> newtype Capability a = Capability (IO (Maybe a))
12:25:15 <Saizan> dsunshine: there are generic linux tarballs on ghc's website, though ooi, why do you need a newer version of a package shipped with ghc?
12:25:30 <Eduard_Munteanu> Dari: getCapability?
12:25:36 <mauke> getCapability :: Terminal -> Capability a -> Maybe a
12:25:37 <Dari> Erf OK
12:25:44 <Dari> <- noob spotted
12:25:48 <dsunshine> Saizan: I'm just trying to use cabal to try and install the HSH module from hackage
12:25:57 <aristid> Dari: it does not really seem monad-y
12:26:02 <Dari> Ok
12:26:04 <danharaj> monadic?
12:26:05 <danharaj> :p
12:26:08 <Dari> :p
12:26:14 <ozataman> hey all. when compiling on OS X, how can I make sure all imported cabal packages are statically included in the executable?
12:26:44 <Eduard_Munteanu> ozataman: they will be by default, at least in GHC
12:26:44 <Saizan> dsunshine: that shouldn't need it, can you put "ghc-pkg list" on a pastebin?
12:27:04 <ozataman> Eduard_Munteanu: Yeah my qestion was for GHC. Thank you
12:27:25 <Eduard_Munteanu> ozataman: but I assume you could also use ldd or readelf or something to figure if it's still using other .so's
12:27:30 <dsunshine> Saizan: Excuse my ignorance but what's a pastebin?
12:27:32 * Eduard_Munteanu can only guess about Mac
12:27:39 <Eduard_Munteanu> @where hpaste
12:27:39 <lambdabot> http://hpaste.org/
12:27:47 <Eduard_Munteanu> dsunshine: anything of that sort ^
12:28:06 <ozataman> Eduard_Munteanu: I wonder if strace would work... Have to remind myself its OS X cousin though :)
12:28:08 <Saizan> dsunshine: a website like hpaste.org where you can paste some text and get a link to share it
12:28:57 <Eduard_Munteanu> ozataman: maybe. Though you'll have to look hard for opens and mmaps I think.
12:29:18 <ozataman> Eduard_Munteanu: Yeah.. I don't know how to use readelf - let me see that
12:29:25 <Eduard_Munteanu> ozataman: do you have ldd?
12:29:36 <ozataman> Eduard_Munteanu: Don't think so
12:29:48 <dsunshine> Saizan: http://hpaste.org/41665/ghcpkg_list
12:31:22 <Eduard_Munteanu> ozataman: hm, maybe readelf -r ?
12:31:52 <tmo_> In Gtk2Hs, I'm trying to simplify code writing with regards to binding keys, but one of the function I wrote doesn't work correctly and I don't know why
12:31:53 <tmo_> http://pastebin.com/VCf3wav7
12:32:13 <tmo_> How do I make it so that the fuction behaves EXACTLY like the code I'm trying to replace?
12:32:19 <Saizan> dsunshine: ah, you've a lot of multiple versions of packages in the global db, i thought those would get eliminated when reinstalling ghc, maybe you should clean /var/lib/ghc-6.12.1/package.conf.d manually and then reinstall
12:32:51 <ozataman> Eduard_Munteanu: http://bit.ly/aazHIq
12:32:58 <ozataman> Eduard_Munteanu: This seems to be the answer for OS X
12:33:02 <Saizan> dsunshine: and also rm -fr ~/.ghc, at that point it should be smoother
12:33:38 <mauke> tmo_: first off, you don't need the { }
12:34:16 <Eduard_Munteanu> ozataman: oh. Sorry for misleading you :)
12:34:41 <ozataman> Eduard_Munteanu: No no, thank you! I only found that site because you mentioned readelf!!
12:34:44 <Eduard_Munteanu> ozataman: still ghc should do static linking, at least with Haskell modules
12:35:03 <Eduard_Munteanu> (libc might go in dynamically though)
12:35:13 <mauke> tmo_: mod' <- eventModifier; guard $ mod == mod'; key' <- eventKeyName; guard $ key == key'  -- completely untested
12:35:23 <ozataman> Eduard_Munteanu: I'm waiting on the binutils installation to see - will let you know
12:35:36 <Saizan> ozataman: passing -static should make sure the haskell libs are linked statically
12:35:52 <Eduard_Munteanu> Isn't it default?
12:36:18 <Dari> w00t
12:36:26 * Dari hugs Eduard_Munteanu 
12:36:30 <Dari> It works :]
12:36:31 <mauke> tmo_: that liftIO looks redundant
12:43:05 <tmo_> mauke: when importing Control.Monad and using the guard function, ghc states that there's no instance for MonadPlus IO. What would be the best way to resolve this?
12:43:53 <mauke> import Control.Monad.Error ()
12:44:02 <cole> Has anyone used F#? How do Haskell and F# compare?
12:44:31 <Twey> Haskell is like F#, but better.  :þ
12:44:53 <Twey> F# is a lot more like an ML from what I know of them.
12:45:04 <Eduard_Munteanu> I think F# was something put out so SPJ could justify the money he's been given :)
12:45:18 <Twey> Heh
12:45:36 <danharaj> SPJ justifies himself
12:45:39 <aavogt> it would better justify work on ocaml
12:45:44 <danharaj> SPJ :: SPJ -> SPJ
12:46:13 <sipa> @src guard
12:46:13 <lambdabot> guard True  =  return ()
12:46:13 <lambdabot> guard False =  mzero
12:46:21 * hackagebot lhs2TeX-hl 0.1.2.2 - Literate highlighter preprocessor for lhs2tex  http://hackage.haskell.org/package/lhs2TeX-hl-0.1.2.2 (AlessandroVermeulen)
12:46:23 * hackagebot yesod 0.6.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.3 (MichaelSnoyman)
12:47:24 <Eduard_Munteanu> cole: well for start, F# isn't pure or lazy
12:47:25 * hackagebot curl 1.3.6 - Haskell binding to libcurl  http://hackage.haskell.org/package/curl-1.3.6 (DonaldStewart)
12:47:55 <Eduard_Munteanu> cole: which makes it look more friendly/familiar to imperative programmers
12:48:30 <danharaj> declarativeness is more important, I think.
12:49:00 <BMeph> Eduard_Munteanu: s/SPJ/Erik Meijer/ is better.
12:49:15 <Eduard_Munteanu> So if you want something really different than your average programming language, Haskell is the place to look.
12:49:37 <dsunshine> Saizan: I deleted the /var/lib/ghc.. directory and re-installed ghc and everthing works. Thanks for all your help
12:49:45 <Eduard_Munteanu> BMeph: ah, I thought SPJ had a part in it. After all he has been employed in that research dept for quite some time.
12:51:37 <BMeph> Eduard_Munteanu: He may have had a hand in it, but Meijer's made not bones about his "mission" of bringing FP more into the mainstream.
12:51:51 <BMeph> made *no bones...
12:55:00 <ddarius> Eduard_Munteanu: The members of Microsoft Research don't need to "justify" their work by getting products out.
12:55:22 <Eduard_Munteanu> ddarius: I know, I'm kidding.
12:56:04 <danharaj> Speaking of Microsoft Research, Michael Freedman gave a talk at my university on friday about quantum computing.
12:56:04 * Eduard_Munteanu thinks somebody is too serious :P
12:57:33 <Eduard_Munteanu> Anyway, that research department is one of the things I like appreciate from MS.
12:58:26 <ddarius> Microsoft has been pretty respectable all around the past few years.
12:59:34 <mauke> hello, OOXML
13:01:55 <tmo_> mauke: thanks for the help, although there's one more issue that remained that I haven't figured out how to eliminate. When I run the guard command, instead of doing nothing (as preferred), the program exits.
13:02:38 <mauke> but isn't that also what fail does in IO?
13:02:42 <mauke> throwing an exception, I mean
13:02:58 <Eduard_Munteanu> Hm, yeah, they didn't have the stereotypical MS behavior
13:03:45 <tmo_> Well, when it runs normally, if the condition fails, gtk just pretends that nothing happened until the right pattern appears.
13:04:35 <mauke> tmo_: what's the type of bindKey?
13:04:52 <tmo_> IO (ConnectId)
13:05:07 <mauke> unlikely
13:05:28 <mauke> and by "unlikely" I mean "impossible"
13:05:30 <tmo_> bindKey :: WidgetClass self => 
13:05:31 <tmo_>             self                           -> 
13:05:31 <tmo_>             Signal self (EventM EKey Bool) -> 
13:05:31 <tmo_>             [Modifier]                     -> 
13:05:34 <tmo_>             String                         -> 
13:05:36 <tmo_>             IO ()                          -> 
13:05:39 <tmo_>             IO (ConnectId self)
13:05:45 <mauke> also impossible
13:06:04 <mauke> liftIO fun :: IO (), not IO (ConnectId self)
13:06:29 <tmo_> so IO() then?
13:07:25 <mauke> uh, what?
13:07:36 <mauke> this is not a matter of guessing
13:07:41 <mauke> does your code compile?
13:07:44 <tmo_> Yes.
13:07:53 <mauke> does the code contain the above type signature?
13:08:30 <tmo_> what do you mean?
13:09:02 <mauke> which part is unclear?
13:09:33 <tmo_> I don't understand what you're referencing by "above type signature". If you're talking about bindKey, then yes, the code contains that.
13:10:26 <mauke> this confuses me
13:10:36 <mauke> unless 'type ConnectId a = ()'
13:11:50 <tmo_> I don't really know what ConnectId means.
13:17:06 <tmo_> mauke: sorry if I just obfuscated things
13:17:14 <mauke> no, it's actually me who's confused
13:17:25 <mauke> reading gtk docs now
13:18:14 <mtbeedee> can you overload functions?  Like have one "name" that can handle both (Num a) => a -> a AND (Num a) => (a,a) -> (a,a)
13:18:38 <mauke> mtbeedee: only in different class instances
13:19:02 <mtbeedee> so then no
13:19:02 <mtbeedee> ok
13:19:24 <shachaf> mtbeedee: I think mauke just said the opposite? :-)
13:20:09 <mauke> tmo_: when (key /= key') stopEvent
13:20:27 <mtbeedee> shachaf: what do you mean?
13:20:55 <shachaf> mtbeedee: "only in different class instances" means it *is* possible (in different class instances).
13:21:10 <mauke> tmo_: hmm, or: key' | key' == key <- eventKeyName
13:21:26 <shachaf> mtbeedee: Something like class MyClass a where name :: a -> a; instance (Num a) => MyClass a where name = ...; instance (Num a) => MyClass (a,a) where name = ...
13:21:27 <mtbeedee> but that means the same object can't handle different situations under the same name
13:21:42 <tmo_> mauke: thanks, it works :)
13:21:44 <ddarius> There are no objects.
13:21:58 <ddilinger> i notice when looking over GHC source, there are alot of bits that are "ifdef use_report_prelude foo = someother func #else foo = implementation of foo", why is that?
13:22:04 <mauke> mtbeedee: object?
13:22:24 <ddarius> Haskell is not an OO language.  Do people coming to Haskell not realize this?
13:22:51 <Twey> ddilinger: The report prelude version is a naïve instructional version that presents the semantics
13:22:58 <mtbeedee> what do you mean by class then
13:23:05 <Twey> ddilinger: The other is the real version that aims for performance.
13:23:16 <ddilinger> Twey: interesting, thanks
13:23:22 <dons> mtbeedee: type classes are designed for method overloading. the one name is used at different types.
13:23:46 <mtbeedee> ok, I'll go read more about that
13:24:01 <dons> :t (+)
13:24:01 <lambdabot> forall a. (Num a) => a -> a -> a
13:24:18 <shachaf> mtbeedee: Num is an example of a type class -- you used it in the types you mentioned above.
13:24:23 <dons> any thing that has an instance of Num, including, e.g. tuples.
13:24:35 <mtbeedee> right
13:24:39 <ddarius> > (3,3) + (5,6)
13:24:40 <lambdabot>   (8,9)
13:24:53 <Twey> ddilinger: (so named because it's the sample implementation given in the Report, of course)
13:24:58 <mikeg> I've read there's some performance hit for typeclass-based method overloading. Does it approximately compare to what I could expect in Java or C++?
13:25:11 <ddarius> mikeg: Probably not.
13:25:29 <JoeyA> Why not?
13:25:47 <ddarius> The overall performance change may be comparable, but what's happening and how it affects performance is rather different.
13:26:00 <dons> mtbeedee: e.g.
13:26:00 <dons> *M> (1,2) + (3,4)
13:26:02 <dons> (4,6)
13:26:10 <dons> from instance (Num a, Num b) => Num (a,b) where (a,b) + (c,d) = (a + c, b + d)
13:26:12 <mikeg> That's a GHC thing though, not Haskell, though?
13:26:20 <mikeg> err without one "though" :P
13:26:27 <ddarius> mikeg: What's a GHC thing?
13:26:31 <dons> mikeg: should be a lot cheaper, since ghc is able to resolve most uses statically
13:26:34 <dons> thanks to the strong types.
13:26:43 <mikeg> Ah, that's what I was thinking dons :)
13:26:53 <mikeg> method overloading semantics, ddarius
13:27:08 <dons> ghc can usually see at what type youre using the overloaded value at, replacing the overloaded function with the concrete definition.
13:27:37 <ddarius> mikeg: If you mean type classes, it certainly isn't.  If you mean the implementation, the implementation GHC is pretty common, although JHC does something different.
13:28:10 <danharaj> @djinn [a] -> [a] -> [[a]]
13:28:11 <lambdabot> Error: Undefined type []
13:28:16 <ddarius> s/GHC/GHC uses/
13:29:20 <ddarius> Both C++ and Java (for different reasons and in different cases) can often statically (perhaps at JIT time) resolve a method invokation.
13:30:21 <mikeg> Exactly.. I mean Haskell's typeclasses aren't inherently slower than OOP languages
13:30:22 <ddarius> In the "worst-case" scenario for each though, what's happening in each is still rather different and has a different performance profile in each case.
13:30:32 <ddarius> mikeg: They're completely different.
13:31:27 <mikeg> Well, they're similar in that method resolution can potentially be at runtime or compile-time
13:32:41 <tmo_> mauke: although I'm glad it works, I'm not exactly sure why the conditional tests are needed when the monad is in a function, but are not necessary when it's directly in the mainGUI loop.
13:33:11 <mauke> tmo_: your use of "the monad" is wrong
13:33:19 <mauke> tmo_: the issue is variables in patterns
13:33:56 <mauke> > case "abc" of x : xs -> show (x, xs); [] -> "empty"
13:33:57 <lambdabot>   "('a',\"bc\")"
13:34:15 <mauke> > case [1,2] of x : xs -> show (x, xs); [] -> "empty"
13:34:16 <lambdabot>   "(1,[2])"
13:34:20 <mauke> ok, better
13:34:33 <mauke> that 'x : xs' there is a pattern. it contains two variables, 'x' and 'xs'
13:34:48 <ddarius> mikeg: In the case of Haskell when a method is "resolved" has no semantic import, which is a rather different case than the Java/C++ situation, though certainly compilers for them can replace dynamic dispatches with static ones if they know it won't change semantics.
13:34:49 <mauke> they're bound by the pattern match (to '1' and '[2]' in this case)
13:35:26 <mikeg> Ah, true. that makes sense
13:36:01 <mauke> that means you can't store a pattern in a variable and match against it, because the match would just treat it as a new variable to bind, instead of using its contents as a pattern
13:36:16 <tmo_> ah, okay
13:36:21 <danharaj> regardless of the merits of non-function arrow types, the combinators in Control.Arrow are really friggin useful
13:37:48 <roconnor> danharaj: true
13:38:22 <danharaj> It makes working with tuples and functions much easier.
13:42:40 * hackagebot concurrent-extra 0.6.0.1 - Extra concurrency primitives  http://hackage.haskell.org/package/concurrent-extra-0.6.0.1 (BasVanDijk)
13:43:31 <danharaj> the pattern where you do f.g.h $ x, I call it the "dot, dot, goose" pattern :p
13:43:42 <monochrom> @quote monochrom parsec
13:43:42 <lambdabot> No quotes match. Maybe you made a typo?
13:57:44 * hackagebot idiii 0.1 - Reading and writing of ID3v2 tags  http://hackage.haskell.org/package/idiii-0.1 (ChrisWagner)
14:02:33 <revenantphx> danharaj: hnnnngggggh >_>
14:02:34 <revenantphx> really?
14:02:40 <revenantphx> now that's going to be stuck in my head forever.
14:06:03 <SandCat> I never thought I'd say this, but I need homework. I'm using project Euler to give me practice problems, and it's helping me learn a lot faster.
14:06:38 <mauke> http://spoj.pl/?
14:07:08 <djahandarie> It would be nice if there was a giant repository of Haskell problems
14:09:21 <djahandarie> (I.e., ones that have constraints involving the solution you use)
14:09:31 <djahandarie> (Use a monad to solve this)
14:09:47 <SandCat> eww, I don't like being micromanaged.
14:09:51 <djahandarie> Hopefully better than an awful constraint than that though :v
14:10:01 <SandCat> just challenge yourself to use a monad if that is what you need practice on.
14:11:04 <djahandarie> SandCat, *shrug* I think it'd be useful to help point people in the right direction
14:11:48 <revenantphx> djahandarie: I know there was one that was mentioned.
14:11:51 <revenantphx> Let me see if I can find it.
14:12:14 <revenantphx> ah, there's this
14:12:15 <revenantphx> http://haskell.org/haskellwiki/99_Haskell_exercises
14:12:27 <revenantphx> (It's a translation of the 99 problems in Lisp)
14:12:32 <SandCat> I love you forever <3
14:12:37 <revenantphx> you're welcome.
14:13:17 <hristoasenov> hello, i am trying to compile the nofib framework however on linking I get the error "library not found for -lHSrtsmain"
14:13:36 <hristoasenov> would anyone know the package i need to install?
14:13:39 <aavogt> djahandarie: do you recall seeing a quiz where you are asked to write some instances of oddly named classes?
14:13:56 <aavogt> such that you end up implementing ex. Monad []  and similar
14:14:05 <djahandarie> Hmm, I don't
14:14:52 <revenantphx> I don't think that's a package hristo
14:15:13 <revenantphx> I've definitely seen HSrtsmain before (was it a .a?)
14:15:17 <aavogt> that would be part of ghc
14:15:36 <aavogt> or something it produces anyways
14:15:51 <revenantphx> hm, might as well finish my CS homework.
14:15:54 <revenantphx> Encoding barcodes, easy.
14:16:14 <JoeyA> In the Monad for (->), is (m >>= k) x = k (m x) x  ?
14:16:28 <revenantphx> Being in an easy class (for me) has really put it into perspective how long it takes to develop some sense of algorithms... and then I come in here and I realize just how ridiculously far I have to go :D
14:17:55 <revenantphx> I mean, you don't realize how much it takes before you start thinking algorithmically... when you see people using 8 or 9 nested loops to crop an image or something.
14:18:38 <mauke> > (f >>= g) x
14:18:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:18:39 <lambdabot>    `GHC.Show.Show a'
14:18:39 <lambdabot>      a...
14:18:44 <mauke> > (f >>= g) x :: Expr
14:18:46 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:18:46 <lambdabot>    `GHC.Show.Show a'
14:18:46 <lambdabot>      a...
14:18:49 <mauke> :-(
14:19:05 <hristoasenov> hmm, let me ask this then, is there another way to get the nofib framework without getting it from darcs?
14:19:25 <mauke> > ((f :: Expr -> Expr) >>= g) x :: Expr
14:19:26 <lambdabot>   g (f x) x
14:19:54 <hristoasenov> because i am compiling using stage2 of compiler which is different from the one actually installed on my system
14:21:48 <danharaj> hmmmm
14:22:04 <danharaj> is (uncurry zip) . f . unzip a common pattern?
14:22:15 <danharaj> does it have a simpler form I completely missed?
14:22:36 <Saizan> ?type \f -> (uncurry zip) . f . unzip
14:22:38 <lambdabot> forall a b a1 b1. (([a1], [b1]) -> ([a], [b])) -> [(a1, b1)] -> [(a, b)]
14:26:06 <danharaj> the way I just used it, I had a list [(a, b)] and I wanted to apply scanl to just the first projections.
14:28:27 <Saizan> ?type \f -> (uncurry zip) . (f . map fst) &&& map snd
14:28:28 <lambdabot> forall a b a1 b1. ([a1] -> ([a], [b])) -> [(a1, b1)] -> ([(a, b)], [b1])
14:28:48 <Saizan> ?type \f -> (uncurry zip) . ((f . map fst) &&& map snd)
14:28:50 <lambdabot> forall a a1 b. ([a1] -> [a]) -> [(a1, b)] -> [(a, b)]
14:29:19 <aavogt> djahandarie: http://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/
14:29:21 <mikeg> Is there a way to tell build only one executable from a .cabal?
14:29:37 <danharaj> :t (uncurry zip).(f *** g).curry
14:29:38 <lambdabot>     Couldn't match expected type `(b, b')'
14:29:38 <lambdabot>            against inferred type `a -> b1 -> c'
14:29:38 <lambdabot>     Probable cause: `curry' is applied to too few arguments
14:29:50 <danharaj> err
14:29:59 <danharaj> :t (uncurry zip).(f *** g).zip
14:29:59 <lambdabot>     Couldn't match expected type `(b, b')'
14:30:00 <lambdabot>            against inferred type `[b1] -> [(a, b1)]'
14:30:00 <lambdabot>     Probable cause: `zip' is applied to too few arguments
14:30:04 <danharaj> d'oh THINK PROPERLY
14:30:15 <danharaj> :t (uncurry zip). (f *** g).unzip
14:30:16 <lambdabot> forall a b a1 b1. (Show a1, SimpleReflect.FromExpr [a], Show b1, SimpleReflect.FromExpr [b]) => [(a1, b1)] -> [(a, b)]
14:30:33 <dancor> just fuzz the answer
14:30:46 <aavogt> mikeg: I think the .cabal can disable/enable executable targets using flags, which you can pass to  cabal with -f
14:30:53 <dancor> with random choices until it typechecks
14:30:56 <dancor> fuzzy logic
14:31:21 <danharaj> :t (\f g -> (uncurry zip).(f *** g).unzip)
14:31:23 <lambdabot> forall a b a1 b1. ([a1] -> [a]) -> ([b1] -> [b]) -> [(a1, b1)] -> [(a, b)]
14:31:31 <danharaj> that is a nice combinator
14:31:37 <danharaj> (misusing the term combinator)
14:31:54 <aavogt> all the cool kids are these days
14:32:34 <dancor> the term promotes reuse
14:32:53 <danharaj> I'm going to use the term functional from now on.
14:32:56 <danharaj> It is a nice functional.
14:33:00 <aavogt> reusator
14:33:13 <mauke> functino
14:33:49 <aavogt> mikeg: but that depends on the .cabal file having been written with that in mind
14:34:02 <danharaj> time to make lambdabot vomit up a page of garbage
14:34:14 <mikeg> Yeah, it's my own .cabal file, and that doesn't sound very elegant :P
14:34:18 <danharaj> @pl (\f g -> (uncurry zip).(f *** g).unzip)
14:34:18 <lambdabot> ((uncurry zip .) .) . flip flip unzip . ((.) .) . (***)
14:34:32 <danharaj> I misevaluated
14:35:22 <tibbe> Why is there no Applicative Either instance?
14:35:30 <danharaj> :t flip flip
14:35:30 <tibbe> because there are two possible instances?
14:35:31 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
14:36:26 <danharaj> I feel like I could sit here all day and try to decipher @pl statements in my head.
14:36:27 <aavogt> @hackage applicative-extras
14:36:27 <lambdabot> http://hackage.haskell.org/package/applicative-extras
14:36:38 <danharaj> Like some sort of brutally insipid exercise :p
14:39:43 <danharaj> what should I name the functional? I found another use for it, so I might as well factor it out
15:09:15 <hvr> is there something like sequence for tuples? I want '(m x, m y) -> m (x, y)'
15:09:42 <dibblego> FZip in category-extras
15:10:01 <mauke> :t uncurry (liftM2 (,))
15:10:03 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
15:10:16 <hvr> mauke: thx!
15:10:44 <dibblego> http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Zip.html
15:16:03 <wisepumpkin> roconnor: your proposal doesn't tell us where we can find the magic Data.Functor.Backwards
15:16:36 <roconnor> wisepumpkin: it is attached to the proposal
15:16:39 <roconnor> on trac
15:16:57 <Causalien> Any good songs for programming in haskell?
15:17:37 <hvr> dibblego: but I'd still need to uncurry fzip I guess?
15:17:45 <dibblego> hvr, yes
15:21:48 <SKK> hello? anyone there?
15:22:38 <Entroacceptor> SKK: no
15:22:47 <Entroacceptor> Causalien: try the lambdada
15:22:51 <I> SKK: I am
15:23:10 <mauke> :t ap const const
15:23:11 <lambdabot> forall b. b -> b
15:23:17 <SKK> Oh!
15:23:24 <kmc> Guest69345, you got NickServ'd!
15:23:27 <SKK> let x = 3 in 0
15:23:27 <Guest69345> :(
15:23:42 <SKK> how do i eval it?
15:23:49 <copumpkin> > let x = 3 in 0
15:23:49 <kmc> > let x = 3 in 0
15:23:49 <lambdabot>   0
15:23:50 <lambdabot>   0
15:23:51 <mauke> > let 2 + 2 = 5 in 2 + 2
15:23:52 <lambdabot>   5
15:23:54 <kmc> > let 2 = 3 in 0
15:23:55 <lambdabot>   0
15:23:58 <SKK> >let x = 3 in x + x
15:24:05 <copumpkin> let !2 = 3 in 0
15:24:09 <copumpkin> > let !2 = 3 in 0
15:24:09 <lambdabot>   *Exception: <interactive>:1:149-154: Non-exhaustive patterns in pattern bin...
15:24:21 <SKK> let x = 2 in 2
15:24:26 <SKK> > let x = 2 in 2
15:24:28 <lambdabot>   2
15:24:29 <SKK> ok!
15:24:30 <SKK> thx!
15:24:44 <SKK> > let fold f (a:as ) = f a (fold  f as) in let merge  (a:as ) (b:bs ) = a:b:m erge as bs in let bs = '0':' 1':fold merge  (map (\s -> map (s++)  bs) bs) in bs
15:24:45 <lambdabot>   <no location info>:
15:24:45 <lambdabot>      lexical error in string/character literal at chara...
15:25:01 <SKK> > let fold f (a:as ) = f a (fold  f as) in let merge  (a:as ) (b:bs ) = a:b:merge as bs in let bs = '0':' 1':fold merge  (map (\s -> map (s++)  bs) bs) in bs
15:25:02 <lambdabot>   <no location info>:
15:25:02 <lambdabot>      lexical error in string/character literal at chara...
15:25:21 <SKK> ok
15:25:29 <mauke> ' 1' is invalid
15:25:30 <SKK> > let fold f (a:as ) = f a (fold  f as) in let merge  (a:as ) (b:bs ) = a:b:merge as bs in let bs = '0':'1':fold merge  (map (\s -> map (s++)  bs) bs) in bs
15:25:31 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
15:25:31 <lambdabot>    arising from a use o...
15:25:37 <SKK> yep bad paste
15:25:48 <SKK> what did he just say?
15:26:03 <mauke> you can't use ++ on Chars
15:26:11 <SKK> > let fold f (a:as) = f a (fold f as) in let merge  (a:as) (b:bs) = a:b:merge as bs in let bs = '0':'1':fold merge (map (\s -> map (s++) bs) bs) in bs
15:26:12 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
15:26:12 <lambdabot>    arising from a use o...
15:26:14 <SKK> ??
15:26:18 <SKK> oh ok
15:26:47 <SKK> > let fold f (a:as) = f a (fold f as) in let merge  (a:as) (b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in bs
15:26:52 <lambdabot>   mueval-core: Time limit exceeded
15:27:00 <SKK> > let fold f (a:as) = f a (fold f as) in let merge  (a:as) (b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in bs !! 10
15:27:05 <lambdabot>   mueval-core: Time limit exceeded
15:27:07 <mauke> infinite loop
15:27:15 <SKK> how do i take the first 10?
15:27:25 <mauke> won't help you
15:27:42 <SKK> ?
15:28:20 <SKK> [0..10] !! 2
15:28:24 <SKK> > [0..10] !! 2
15:28:25 <lambdabot>   2
15:28:34 <SKK> > [0..10] !! 10
15:28:35 <lambdabot>   10
15:28:56 <Causalien> Why would I use guards when a normal pattern matching will do the same?
15:29:21 <Axman6> Causalien: they won't do the same thing
15:29:24 <mauke> Causalien: you wouldn't
15:29:31 <Causalien> Is it because pattern matching can't do comparison?
15:29:41 <Axman6> guards take boolean expressions, pattern matching only matches patterns
15:29:53 <Twey> Unless you use view patterns
15:30:01 <Causalien> Ah.
15:30:02 <Axman6> yeah
15:30:04 <Causalien> Make sense.
15:30:14 <Twey> And you can get patterns in guards with pattern guards, too.
15:30:14 * mauke proceeds to use pattern guards
15:30:17 <Twey> Heh
15:30:33 <hvr> btw, for getting the first n positive integers I can write [1..n] but for getting them in the reverse order do I really have to write [n,n-1..1] ?
15:30:44 <Twey> hvr: Yes
15:30:52 <Twey> Or you could write reverse [1 .. n]
15:30:55 * Axman6 starts using view pattern guards for ultimate power
15:30:55 <Twey> But it would be silly
15:30:59 <hvr> Twey: :-)
15:31:07 <hvr> Twey: ok... was just checking
15:31:19 <Twey> Or there's always [n, pred n, .. 1]
15:31:42 <Axman6> or enumFromThenTo n (n-1) 0
15:31:45 <Axman6> uh 1
15:31:50 <Entroacceptor> [ (n+1) - x | x <- [1..n] ]
15:31:54 <aavogt> @quote benmachine pattern
15:31:54 <lambdabot> benmachine says: let (\x -> case x of (\x -> x -> x) -> x -> x) = 0 in x / best view pattern evar
15:32:10 * hackagebot copilot 0.27 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-0.27 (LeePike)
15:32:24 <McManiaC> http://npaste.de/qX/ :)
15:32:44 <Causalien> In haskell, would I save more cpu cycle if I do the calculation of a condition before sending it into the guard to check which case is true? 
15:33:16 <Axman6> what do you mean?
15:33:26 <Causalien> If I do the following check
15:33:44 <Causalien> | weight/ height ^2 <= 11
15:33:46 <aavogt> McManiaC: does it require MonadPlus when patterns can fail or you have Bool?
15:33:55 <Causalien> | weight/height ^2 <= 20
15:34:05 <Causalien> Versus if I do weight/height.
15:34:11 <mauke> > x/y ^2
15:34:12 <lambdabot>   x / (y * y)
15:34:16 <Causalien> then pass it into the function whcih has guard
15:34:23 <mauke> Causalien: spacing doesn't affect precedence
15:34:27 <Causalien> |result < = 10
15:34:28 <conal> does anyone here use GLUT or SDL on mac os x with ghci ?
15:34:31 <Causalien> |result <= 15
15:34:36 <Axman6> if you've got common sub espressions, then it is usually a good idea to put them in a where clause so the result is stored if needed
15:35:17 <Entroacceptor> but I'd bet ghc can optimize that
15:35:27 <Entroacceptor> if it's pure, of course
15:35:30 <mauke> Entroacceptor: unlikely
15:35:43 <conal> i'm trying to find some way to do interactive graphics in haskell on mac os x. a REPL is very important to me, as my programs are often half-liners.
15:35:51 <SKK> > let me = case me of [a] -> [a]
15:35:52 <lambdabot>   not an expression: `let me = case me of [a] -> [a]'
15:36:01 <SKK> > let me = case me of [a] -> [a] in me
15:36:05 <lambdabot>   mueval-core: Time limit exceeded
15:36:11 <Axman6> Entroacceptor: ghc doesn't do much CSE
15:36:15 <mauke> SKK: infinite loop
15:36:27 <SKK> > take 3 [0..10]
15:36:28 <lambdabot>   [0,1,2]
15:36:29 <McManiaC> aavogt: thats the next step
15:36:31 <SKK> > take 3 [0..]
15:36:33 <lambdabot>   [0,1,2]
15:36:44 <SKK> > let fold f (a:as) = f a (fold f as) in let merge  (a:as) (b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 10 bs
15:36:48 <lambdabot>   mueval-core: Time limit exceeded
15:36:53 <SKK> ???????
15:37:10 <mauke> SKK: you've got an infinite loop
15:37:23 <aavogt> McManiaC: is it much worse than writing a quasiquoter?
15:37:30 <SKK> O, yes!
15:38:02 * aavogt really means challenging
15:38:56 <jekor> Is there a way to pass options to a library at compile time? I have a library that connects to a database at compile time (Template Haskell) and I'd like to avoid having to read the options (database name, host, etc) from a file.
15:38:57 <McManiaC> aavogt: i'm having a hard time browsing the ghc sources for the needed functions, but actually its almost everything already there
15:39:32 <SKK> no, i don't see why it should be infinite!
15:39:34 <Axman6> jekor: possibly using CPP?
15:40:08 <andreo> which function does double to int?
15:40:09 <Heffalump> jekor: or template haskell
15:40:11 <jekor> Axman6: I guess there's that option. Not fond of it though :/
15:40:24 <Heffalump> oh, you already said you were using that, sorry
15:40:26 <Heffalump> I see the problem
15:40:32 <mauke> andreo: round, floor?
15:40:33 <aavogt> getArgs does something in TH?
15:40:35 <Axman6> well, connecting to a database at compile time, you've already gone over the edge :P
15:40:40 <jekor> Heh.
15:40:59 <Heffalump> what are you using to invoke the build?
15:41:11 <jekor> cabal
15:41:14 <SKK> > let fold f (a:as) = f a (fold f as) in let merge  (a:as) (b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 2 bs
15:41:16 <lambdabot>   ["0","1"]
15:41:23 <SKK> > let fold f (a:as) = f a (fold f as) in let merge  (a:as) (b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 3 bs
15:41:27 <lambdabot>   mueval-core: Time limit exceeded
15:41:41 <jekor> I looked through the GHC manuall and didn't see anything. Just curious if I'd missed something obvious.
15:43:41 <Saizan> > let fold f (a:as) = f a (fold f as) in let merge ~(a:as) ~(b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 3 bs
15:43:42 <lambdabot>   ["0","1","00"]
15:43:50 <Saizan> > let fold f (a:as) = f a (fold f as) in let merge ~(a:as) ~(b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 10 bs
15:43:51 <lambdabot>   ["0","1","00","10","01","000","000","11","010","100"]
15:44:05 <SKK> Thank you!!!!
15:44:12 <SKK> >>:-DDDD
15:44:33 <aavogt> jekor: if there's some way to give ghc some args without it otherwise complaining http://npaste.de/qY/
15:44:34 <SKK> > ":-"++ show 0
15:44:35 <lambdabot>   ":-0"
15:44:46 <aavogt> jekor: perhaps environment variables are the way to go
15:44:54 <Saizan> > let fold f ~(a:as) = f a (fold f as) in let merge (a:as) (b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 3 bs
15:44:59 <lambdabot>   mueval-core: Time limit exceeded
15:45:41 <jekor> aavogt: Aha. How did I not think of that one. So simple. Thanks.
15:45:54 <SKK>  > let fold f (a:as) = f a (fold f as) in let merge (a:as) (b:bs) =
15:45:55 <SKK> 	 a:b:merge ~as bs in let bs = "0":"1":fold merge (map (\s -> map (s++)
15:45:55 <SKK> 	 bs) bs) in take 3 bs
15:46:20 <Saizan> ~ work only in patterns
15:46:31 <SKK>  > let fold f (a:as) = f a (fold f as) in let merge ~(a:as) (b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 10 bs
15:46:42 <Axman6> > let gray = "0":"1":++ map ('0':) gray ++ map ('1':) (reverse gray) in gray
15:46:43 <lambdabot>   Not in scope: data constructor `:++'
15:46:51 <SKK>  > let fold f (a:as) = f a (fold f as) in let merge (a:as) ~(b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 10 bs
15:46:53 <Axman6> > let gray = "0":"1": map ('0':) gray ++ map ('1':) (reverse gray) in gray
15:46:54 <lambdabot>   ["0","1","00","01","000","001","0000","0001","00000","00001","000000","0000...
15:46:57 <Axman6> hmm, no
15:47:30 <SKK> > let fold f (a:as) = f a (fold f as) in let merge (a:as) ~(b:bs) = a:b:merge as bs in let bs = "0":"1":fold merge (map (\s -> map (s++) bs) bs) in take 10 bs
15:47:32 <lambdabot>   ["0","1","00","10","01","000","000","11","010","100"]
15:47:45 <Axman6> > let gray xs = "0":"1": grey (map ('0':)  ++ map ('1':) (reverse xs)) in gray ["0","1"]
15:47:47 <lambdabot>   Not in scope: `grey'
15:47:56 <Axman6> > let gray xs = "0":"1": gray (map ('0':)  ++ map ('1':) (reverse xs)) in gray ["0","1"]
15:47:57 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
15:47:57 <lambdabot>                           ...
15:48:08 <Axman6> > let gray xs = gray (map ('0':)  ++ map ('1':) (reverse xs)) in gray ["0","1"]
15:48:09 <SKK> yaay, so only one is needed after all... but was supposed to enumerate trees not strings, hence repetition
15:48:09 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]
15:48:09 <lambdabot>                           ...
15:48:17 <Axman6> > let gray xs = gray (map ('0':) xs ++ map ('1':) (reverse xs)) in gray ["0","1"]
15:48:23 <Axman6> :\
15:48:25 <lambdabot>   mueval: ExitFailure 1
15:48:42 <Axman6> > let gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs)) in gray ["0","1"]
15:48:47 <lambdabot>   mueval-core: Time limit exceeded
15:48:58 <Axman6> o.O
15:49:19 <SKK> is it supposed to count off all binary strings?
15:49:36 <Axman6> this should count binary strings in gray order
15:49:55 <SKK> hm, that's not at all trivial now that i think of it
15:50:20 <Axman6> > let gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs)) in take 2 $ gray ["0","1"]
15:50:22 <lambdabot>   ["0","1"]
15:50:28 <Axman6> > let gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs)) in take 3 $ gray ["0","1"]
15:50:29 <lambdabot>   ["0","1","00"]
15:50:46 <Axman6> > let gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs)) in take 4 $ gray ["0","1"]
15:50:48 <lambdabot>   ["0","1","00","01"]
15:50:57 <Axman6> > let gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs)) in take 6 $ gray ["0","1"]
15:50:58 <lambdabot>   ["0","1","00","01","11","10"]
15:51:09 <Axman6> > let gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs)) in take 8 $ gray ["0","1"]
15:51:10 <lambdabot>   ["0","1","00","01","11","10","000","001"]
15:51:16 <Axman6> hmm, not quite
15:51:29 <SKK> let gray xs = xs ++ gray (map ('0':) xs ++ reverse (map ('1':) xs)) in gray ["0","1"]
15:51:41 <aristid> @pl gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs))
15:51:42 <lambdabot> gray = fix (ap (++) . (. ap ((++) . map ('0' :)) (map ('1' :) . reverse)))
15:51:51 <aristid> :t let gray xs = xs ++ gray (map ('0':) xs ++ map ('1':) (reverse xs)) in gray
15:51:54 <lambdabot> [[Char]] -> [[Char]]
15:51:59 <SKK> > let gray xs = xs ++ gray (map ('0':) xs ++ reverse (map ('1':) xs)) in take 10 (gray ["0","1"])
15:52:01 <lambdabot>   ["0","1","00","01","11","10","000","001","011","010"]
15:52:46 <Axman6> > let gray xs = xs ++ (map ('0':) (grey xs) ++ map ('1':) (reverse (grey xs)) in take 8 $ gray ["0","1"]
15:52:47 <lambdabot>   <no location info>: parse error on input `in'
15:52:56 <Axman6> > let gray xs = xs ++ (map ('0':) (grey xs) ++ map ('1':) (reverse (grey xs))) in take 8 $ gray ["0","1"]
15:52:57 <lambdabot>   Not in scope: `grey'Not in scope: `grey'
15:53:05 <Axman6> > let gray xs = xs ++ (map ('0':) (gray xs) ++ map ('1':) (reverse (gray xs))) in take 8 $ gray ["0","1"]
15:53:07 <lambdabot>   ["0","1","00","01","000","001","0000","0001"]
15:53:13 <Axman6> hmm, nope
15:53:51 <SKK> > let gray xs = xs ++ gray (map ('0':) xs ++ reverse (map ('1':) xs)) in let cn n f s = if n==0 then s else f (cn (n-1) f s) in take 10 . cn 10 . gray $ ["0","1"]
15:53:52 <lambdabot>   Couldn't match expected type `[a]' against inferred type `t -> t'
15:54:20 <SKK> > let gray xs = xs ++ gray (map ('0':) xs ++ reverse (map ('1':) xs)) in let cn n f s = if n==0 then s else f (cn (n-1) f s) in take 10 . cn 10  gray $ ["0","1"]
15:54:22 <lambdabot>   ["0","1","00","01","11","10","000","001","011","010"]
15:54:33 <Axman6> > let gray xs = let ys = xs ++ map ('0':) xs ++ map ('1':) (reverse xs) in gray ys in gray [""]
15:54:41 <lambdabot>  Terminated
15:54:51 <Axman6> > let gray xs = let ys = xs ++ map ('0':) xs ++ map ('1':) (reverse xs) in ys ++ gray ys in gray [""]
15:54:54 <Cale> http://upload.wikimedia.org/wikipedia/commons/a/a8/Gray_code_rotary_encoder_13-track_opened.jpg -- ruined, but still pretty cool :)
15:54:56 <lambdabot>   mueval-core: Time limit exceeded
15:55:05 <Axman6> > let gray xs = let ys = xs ++ map ('0':) xs ++ map ('1':) (reverse xs) in ys ++ gray ys in takw 3 $ gray [""]
15:55:06 <lambdabot>   Not in scope: `takw'
15:55:11 <Axman6> > let gray xs = let ys = xs ++ map ('0':) xs ++ map ('1':) (reverse xs) in ys ++ gray ys in take 3 $ gray [""]
15:55:13 <lambdabot>   ["","0","1"]
15:55:18 <Axman6> > let gray xs = let ys = xs ++ map ('0':) xs ++ map ('1':) (reverse xs) in ys ++ gray ys in take 7 $ gray [""]
15:55:20 <lambdabot>   ["","0","1","","0","1","0"]
15:55:24 <SKK> > let gray xs = xs ++ gray (map ('0':) xs ++ reverse (map ('1':) xs)) in gray ["0","1"] = gray (gray ["0","1"])
15:55:25 <lambdabot>   <no location info>: parse error on input `='
15:55:38 <SKK> > let gray xs = xs ++ gray (map ('0':) xs ++ reverse (map ('1':) xs)) in gray ["0","1"] == gray (gray ["0","1"])
15:55:42 <Axman6> > let gray xs = let ys = map ('0':) xs ++ map ('1':) (reverse xs) in xs ++ ys ++ gray ys in take 7 $ gray [""]
15:55:44 <lambdabot>   mueval: ExitFailure 1
15:55:46 <lambdabot>   mueval-core: Time limit exceeded
15:56:14 <SKK> quite beautiful
15:56:40 <SKK> haskell rules
15:57:08 <Axman6> let gray 1 xs = xs; gray n xs = map ('0':) ys ++ map ('1':) (reverse ys) where ys = gray (n-1) xs in gray 4 ["0","1"]
15:57:16 <Axman6> > let gray 1 xs = xs; gray n xs = map ('0':) ys ++ map ('1':) (reverse ys) where ys = gray (n-1) xs in gray 4 ["0","1"]
15:57:18 <lambdabot>   ["0000","0001","0011","0010","0110","0111","0101","0100","1100","1101","111...
15:57:23 <Axman6> better
15:57:38 <Axman6> slightly different to what i was after, but works better
15:57:48 <Axman6> > let gray 0 xs = xs; gray n xs = map ('0':) ys ++ map ('1':) (reverse ys) where ys = gray (n-1) xs in gray 4 [""]
15:57:49 <lambdabot>   ["0000","0001","0011","0010","0110","0111","0101","0100","1100","1101","111...
15:58:00 <Axman6> > let gray 0 xs = xs; gray n xs = map ('0':) ys ++ map ('1':) (reverse ys) where ys = gray (n-1) xs in gray 10 [""] !! 192
15:58:02 <lambdabot>   "0010100000"
15:58:09 <SKK> very nice
16:00:11 <ezyang> Does anyone know whatever happened to unimo? 
16:00:21 <Axman6> > let gray 0 xs = xs; gray n xs = map ('0':) ys ++ map ('1':) (reverse ys) where ys = gray (n-1) xs in gray 10 [""] !! (2^10)
16:00:22 <lambdabot>   "*Exception: Prelude.(!!): index too large
16:00:27 <Axman6> > let gray 0 xs = xs; gray n xs = map ('0':) ys ++ map ('1':) (reverse ys) where ys = gray (n-1) xs in gray 10 [""] !! (2^10 -1)
16:00:28 <lambdabot>   "1000000000"
16:01:07 <SKK> wow
16:01:10 <SKK> cool
16:01:17 <ezyang> Was it shown to, like, not actually fulfill the monad laws or something? 
16:01:57 <Cale> ezyang: I thought the whole point was that it was shown to always be a monad.
16:02:15 <aristid> ezyang: what is unimo?
16:02:27 <ezyang> http://sneezy.cs.nott.ac.uk/fplunch/weblog/?p=89 
16:02:37 <ezyang> http://sites.google.com/site/chklin/research/unimo-icfp06.pdf?attredirects=0 
16:02:46 <Cale> To be honest, I haven't looked too hard at unimo. I have taken a good look at MonadPrompt, and it's pretty cool.
16:03:21 <SKK> let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in cn 10 gray [""]
16:03:25 <SKK> > let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in cn 10 gray [""]
16:03:26 <ezyang> Yeah. I decided to finallly take a good look at the Unimo paper, and I remember vaguely hearing something about Unimo not working a while back. 
16:03:27 <lambdabot>   ["0000000000","0000000001","0000000011","0000000010","0000000110","00000001...
16:03:31 <ezyang> I think from that blog post, actually. 
16:03:56 <ezyang> Though it's not as bad: Nils just states that you can violate the monad laws if you reaaally awant to. 
16:04:05 <SKK> > let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in map (\x -> length (cn x gray [""])) [0..12] 
16:04:07 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096]
16:04:34 <SKK> > let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in take 3 cn 40 gray [""]
16:04:35 <lambdabot>   Couldn't match expected type `[a]'
16:04:35 <lambdabot>         against inferred type `t1 -> (t ...
16:04:48 <SKK> > let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in take 3 $ cn 40 gray [""]
16:04:49 <lambdabot>   ["0000000000000000000000000000000000000000","000000000000000000000000000000...
16:05:08 <SKK> > let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in  cn 400 gray [""] !! 5
16:05:10 <lambdabot>   "00000000000000000000000000000000000000000000000000000000000000000000000000...
16:05:22 <SKK> > let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in  cn 400 gray [""] !! (2^10-1)
16:05:24 <lambdabot>   "00000000000000000000000000000000000000000000000000000000000000000000000000...
16:05:37 <SKK> > let gray ys = map ('0':) ys ++ map ('1':) (reverse ys); cn 0 f s = s; cn (n+1) f s = f (cn n f s) in  cn 400 gray [""] !! (2^100-1)
16:05:38 <lambdabot>   "*Exception: Prelude.(!!): negative index
16:05:43 <SKK> haha
16:06:27 <romildo> When compiling blaze-builder-0.2.0.1 with ghc-7.0.1 on my ~amd64 gentoo system, I am getting the error:
16:06:29 <romildo> [1 of 8] Compiling Blaze.ByteString.Builder.Internal ( Blaze/ByteString/Builder/Internal.hs, dist/build/Blaze/ByteString/Builder/Internal.o )
16:06:29 <romildo> ghc: panic! (the 'impossible' happened)
16:06:34 <romildo> Any help?
16:06:57 <Cale> romildo: ouch!
16:07:18 <Heffalump> check the GHC bug reports to see if anyone has already reported it
16:07:36 <Heffalump> if not, report to the author of blaze and/or try to cut it down to a small test case yourself
16:07:48 <ezyang> romildo: That sounds like a good thing to toss at the mailing list. 
16:08:20 <romildo> ezyang, I will report it at the mailing list.
16:11:11 <thoughtpolice> hm, not reproducable for me on a simple test run on amd64 debian with 7.0.1 (squeeze)
16:11:54 <SKK> > let a [b] = a [a [b]] in a [0]
16:11:59 <lambdabot>   mueval-core: Time limit exceeded
16:12:24 <SKK> > let a [b] = a [b] in a [0]
16:12:28 <lambdabot>   mueval-core: Time limit exceeded
16:13:02 <SKK> > let i = i in i
16:13:07 <lambdabot>   mueval-core: Time limit exceeded
16:13:54 <Cale> > let i = i in 0
16:13:55 <lambdabot>   0
16:15:40 <SKK> > let a [b] = a [a [b]] in 0
16:15:42 <lambdabot>   0
16:16:37 <SKK> so why can't one give new datatypes to the lambdabot?
16:17:14 <Cale> SKK: It's just not implemented. I can add datatypes to L.hs.
16:18:01 <thoughtpolice> SKK: lambdabot is built on the same code that powers GHCi, but ghci is rather limited in that it does not allow you to define new datatypes at runtime when messing with things
16:18:15 <thoughtpolice> it has to be defined in a file and then loaded/reloaded into the running instance
16:18:25 <Cale> Though, this is already what's happening.
16:18:43 <Cale> Each expression is evaluated in a separate process, even.
16:19:11 <SKK> so is there some deeper reason why datatypes are not added at runtime??
16:19:16 <thoughtpolice> nope
16:19:20 <thoughtpolice> nobody's done the work
16:19:24 <Cale> When you @let some definition, it gets parsed to ensure that it's a valid function or pattern binding, before being added to L.hs
16:19:25 <SKK> or is a lot of work to implement it?
16:19:29 <SKK> it
16:19:53 <Cale> Someone would just have to try parsing it as a data declaration.
16:19:57 <thoughtpolice> i think simon has said it wouldn't be too difficult, but it would require some effort to do naturally
16:20:14 <Cale> It has nothing to do with why GHCi doesn't support making data declarations.
16:20:25 <SKK> it would be nice if it could just accept vasic inductive datatypes
16:20:30 <Cale> (since the definitions are going into a file to be loaded anyway)
16:20:31 <SKK> typeclasses can be added later
16:21:06 <thoughtpolice> Cale: oh, i misunderstood :x
16:21:52 <SKK> Cale: so everytime someone does "> let x = ..." it actually writes a new file and feeds it to ghc?
16:22:42 <Cale> well, yes. Every expression gets turned into a temporary file at some point. But @let actually stores things into a separate module as well.
16:22:59 <SKK> if it is already in a separate process why isn't there a hidden "just do it" instruction that would allow you to feed an arbitrary string there...
16:23:17 <Cale> Because that would allow you to break security.
16:23:50 <SKK> even if you give every process only 1 sec?
16:24:12 <Cale> Well... if you could work out a way to import another module :)
16:24:31 <SKK> hm....
16:24:39 <Cale> You could import System.IO.Unsafe, and then use unsafePerformIO to execute arbitrary IO actions.
16:25:49 <SKK> so... who would want to actually hack a computer running the lambdabot?  has someone burdened it with sensitive data?
16:25:50 <Cale> We're making use of the fact that evaluating expressions doesn't cause any IO to occur.
16:26:04 <ben> SKK: It is on IRC. If it was breakable, someone would break it.
16:26:17 <osaunders> @src IO
16:26:17 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:26:37 <Cale> (which incidentally, is why you it's good policy not to IRC as root ;)
16:26:38 <SKK> @src L
16:26:38 * osaunders wants to know what the IO monad's definition looks like.
16:26:39 <lambdabot> Source not found. I feel much better now.
16:26:46 <Cale> -you
16:27:11 <Cale> osaunders: In GHC?
16:27:28 <osaunders> I guess.
16:27:44 <ben> It involves lots of #
16:27:50 <Cale> osaunders: GHC's implementation is a hack. They use effectful functions which pass around values of an empty datatype.
16:28:20 <osaunders> Right, so the IO monad isn't really a data structure so much?
16:28:32 <osaunders> In that it doesn't really contain things.
16:28:40 <ben> Monads are not data structures
16:28:44 <aavogt> how could there be an implementation of IO that would be pleasing?
16:29:02 <copumpkin> ben: define data structure before saying what isn't one
16:29:17 <SKK> still... do u really need to implement the whole syntax of haskell just to make sure people can't access IO?
16:30:51 <Cale> osaunders: A better mental model of the IO datatype is something like this:
16:30:54 <ddarius> It's standard security practice to whitelist user input.
16:30:55 <Cale> data IO a where
16:30:57 <osaunders> I always had this conception that bind was somehow constructing this aggregate value, kind of like cons. But it doesn't does it.
16:31:00 <Cale>   ReturnIO :: a -> IO a
16:31:08 <Cale>   BindIO :: IO a -> (a -> IO b) -> IO b
16:31:16 <Cale>   GetChar :: IO Char
16:31:23 <Cale>   PutChar :: Char -> IO ()
16:31:25 <ddarius> However, if the structure of a Haskell program was more stringently capability oriented, we could nicely avoid IO.
16:31:28 <Cale>   ... other IO primitives ...
16:31:40 <Cale>   ForkIO :: IO a -> IO ThreadId
16:32:07 <Cale> So IO actions are basically just inert descriptions of things to do.
16:32:22 <Cale> and the RTS then includes an interpreter for this higher-order abstract syntax
16:32:33 <Cale> which actually effectfully carries this stuff out
16:32:44 <Cale> (after pattern matching on the IO values)
16:32:58 <osaunders> RTS = Runtime system?
16:33:01 <Cale> yes
16:34:25 <SKK> ddarius: what do u mean by that?
16:34:38 <Cale> That pattern matching on the IO values is the initial cause of evaluation. (In general, all evaluation is eventually triggered by some pattern match)
16:36:00 <osaunders> Is it possible to write a monad that stands in for IO? Like, for testing?
16:36:11 <osaunders> Something akin to mock objects only with monads.
16:36:13 <Cale> osaunders: Sure, some people have done things like that
16:36:18 <copumpkin> @hackage iospec
16:36:18 <lambdabot> http://hackage.haskell.org/package/iospec
16:36:29 <copumpkin> :(
16:36:30 <Cale> http://hackage.haskell.org/package/IOSpec
16:36:33 <SKK> that last bit (the RTS) make the whole thing rather fishy
16:36:33 <osaunders> :(
16:36:39 <osaunders> :-)
16:36:53 <copumpkin> SKK: why?
16:36:54 <Cale> (I was just going to get the link :)
16:37:06 <Cale> SKK: What?
16:37:06 <copumpkin> Cale: ACK THE SMILE + CLOSING PAREN
16:37:14 <SKK> in that the members of (IO a) are not part of the language semantics
16:37:21 <SKK> but shadowed by the RTS
16:37:36 <copumpkin> my CPU isn't written in its own assembly either
16:37:45 <copumpkin> not sure about yours
16:37:51 <ben> You cannot implement open() and write() in pure C either <:)
16:38:11 <Cale> SKK: I'm not sure that I understand what you mean. The runtime system is part of the language implementation. The semantics of IO actions needs to be part of the semantics of Haskell execution in general.
16:38:18 <ddarius> ben: Not without invoking undefined behavior...
16:38:41 <Cale> SKK: However, the execution of IO actions has nothing to do with the semantics of evaluating Haskell expressions (except via low-level hackery like unsafePerformIO)
16:39:17 <SKK> that's exactly what seems unsatisfactory
16:39:53 <Cale> That's the whole idea of the IO monad. To separate execution of I/O actions from the evaluation of expressions, so that evaluation order and execution order can be separated.
16:39:56 <SKK> that we have definitions for language expressions, but whenever there's open() or write(), this part is not defined
16:40:21 <Cale> Is it not?
16:40:30 <SKK> sure, that's great
16:41:03 <Cale> Obviously at some point, we leave details up to the underlying operating system.
16:41:07 <SKK> but it doesn't change the fact that open() and write() are hostage to the runtime environment,
16:41:26 <SKK> so the definitions stop there
16:41:46 <Cale> It's not Haskell specification's job to formalise the underlying OS.
16:41:51 <Cale> (or the CPU, for that matter)
16:42:16 <SKK> sure, i don't disagree
16:42:17 <Cale> It's more abstract than that.
16:43:10 <osaunders> I have some special gloves for programming and chatting about Haskell. I call them "Haskell Gloves"
16:43:25 * copumpkin reduces SKK
16:43:34 <SKK> and it's great that monads protect the abstract part.  but it's not entirely satisfactory that those IO members are completely "freely interpreted", since we do mean that they read values, or output values
16:43:59 <copumpkin> SKK: a lot of people call the IO monad a "sin bin" that we throw anything we don't really know how to specify nicely into
16:44:14 <copumpkin> most people don't really like it but coming up with a nice alternative is hard
16:44:22 <Cale> SKK: Well, they have to be interpreted in a moderately consistent way.
16:44:28 <Cale> readFile is actually meant to read a file.
16:44:33 <SKK> Cale: do they really?
16:44:35 <Cale> yes
16:44:53 <SKK> and what's to prevent me from interpreting them by something else?
16:44:55 <Cale> It's just that that specification is *not* part of the specification of how evaluation occurs.
16:45:05 <Cale> It's still part of the specification of how Haskell is executed.
16:45:18 <ddarius> copumpkin: SKK is not a redex.
16:45:37 <SKK> SKK reduced to me
16:45:49 <SKK> only when translated into lambda calculus
16:46:12 <copumpkin> > ap const const 5
16:46:13 <lambdabot>   5
16:46:37 <Cale> > (<*>) pure pure 5
16:46:38 <lambdabot>   Ambiguous type variable `f' in the constraint:
16:46:38 <lambdabot>    `Control.Applicative.Appl...
16:46:42 <Cale> er :)
16:46:50 <SKK> ???
16:47:02 <dixie> > 1+2
16:47:03 <lambdabot>   3
16:47:16 <Cale> (Just an ambiguity in which instance I wanted to use)
16:47:32 <Cale> :t (<*>)
16:47:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:47:44 <copumpkin> Cale: that's what you get for being so ambiguous
16:47:46 <Cale> If f = (e ->), then that's S
16:47:53 <Cale> :t pure
16:47:54 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:48:07 <Cale> and that's K
16:48:27 <SKK> what's S?
16:48:36 <Cale> <*> is
16:48:49 <SKK> oh, cool
16:48:52 <SKK> can you do
16:49:06 <SKK> > <*> pure pure
16:49:07 <lambdabot>   <no location info>: parse error on input `<*>'
16:49:22 <SKK> > <*> pure pure 3
16:49:24 <lambdabot>   <no location info>: parse error on input `<*>'
16:49:30 <osaunders> :t <*> pure pure
16:49:30 <Cale> SKK: I just tried that (modulo syntax error), and it's ambiguous
16:49:31 <lambdabot> parse error on input `<*>'
16:49:36 <osaunders> :t (<*>) pure pure
16:49:36 <lambdabot>     Ambiguous type variable `f' in the constraint:
16:49:37 <lambdabot>       `Applicative f'
16:49:37 <lambdabot>         arising from a use of `pure' at <interactive>:1:11-14
16:49:38 <SKK> > (<*>) pure pure 3
16:49:40 <lambdabot>   Ambiguous type variable `f' in the constraint:
16:49:40 <lambdabot>    `Control.Applicative.Appl...
16:49:53 <osaunders> :t (<*>) (pure :: Maybe a) pure
16:49:54 <lambdabot>     Couldn't match expected type `Maybe a'
16:49:54 <lambdabot>            against inferred type `a1 -> f a1'
16:49:54 <lambdabot>     In the first argument of `(<*>)', namely `(pure :: Maybe a)'
16:49:55 <Cale> One of the pures needs to have a more specific type
16:50:06 <osaunders> :t (<*>) (pure :: Int -> Maybe Int) pure
16:50:07 <lambdabot>     Couldn't match expected type `a -> b'
16:50:08 <lambdabot>            against inferred type `Maybe Int'
16:50:08 <lambdabot>       Expected type: Int -> a -> b
16:50:13 <Cale> Maybe?
16:50:17 <Cale> Why Maybe?
16:50:30 <osaunders> :t (<*>) (pure :: Int -> [Int]) pure
16:50:31 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[Int]'
16:50:31 <lambdabot>       Expected type: Int -> a -> b
16:50:31 <lambdabot>       Inferred type: Int -> [Int]
16:50:31 <SKK> these are type class operators?
16:50:33 <Cale> :t (<*>) (pure :: a -> b -> a) pure
16:50:35 <lambdabot>     Ambiguous type variable `f' in the constraint:
16:50:35 <lambdabot>       `Applicative f'
16:50:35 <lambdabot>         arising from a use of `pure' at <interactive>:1:28-31
16:50:38 <Cale> hmm
16:50:42 <Boxo> > (<*>) pure (pure :: Int -> (Int -> Int)) 3
16:50:42 <dixie> hmm. what is right place in cabal file for runtime only dependecies ?
16:50:43 <Cale> :t (<*>) (pure :: a -> b -> a) (pure :: a -> b -> a)
16:50:43 <lambdabot>   3
16:50:44 <lambdabot> forall b. b -> b
16:50:49 <Cale> there we go :)
16:50:53 <SKK> hm
16:51:02 <Cale> yeah, really only the second one needs an annotation
16:51:11 <Cale> :t (<*>) pure (pure :: a -> b -> a)
16:51:13 <lambdabot> forall b. b -> b
16:51:19 <SKK> > (<*>) pure (pure :: a -> a) 3
16:51:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
16:51:23 <SKK> YAY
16:51:30 <SKK> > (<*>) pure (pure :: a -> b -> a) 3
16:51:32 <lambdabot>   3
16:51:50 <SKK> > ((<*>) pure (pure :: a -> b -> a) ((<*>) pure (pure :: a -> b -> a))) 3
16:51:52 <lambdabot>   3
16:51:58 <SKK> ???
16:52:03 <osaunders> > (+) <$> Just 10 <*> Just 5
16:52:04 <lambdabot>   Just 15
16:52:09 <SKK> Omega shouldn't type-check :"[
16:52:15 <Cale> That's not omega
16:52:36 <copumpkin> SKK is just I
16:52:38 <SKK> > ((<*>) pure (pure :: a -> b -> a) ((<*>) pure (pure :: a -> b -> a)))((<*>) pure (pure :: a -> b -> a) ((<*>) pure (pure :: a -> b -> a))) 3
16:52:39 <Boxo> That's II
16:52:39 <lambdabot>   3
16:52:51 <copumpkin> so SKK SKK is II is I
16:53:01 <SKK> oh yes
16:53:04 <Eduard_Munteanu> What? :)
16:53:10 <SKK> how can we abreviate I = SKK ?
16:53:20 <Cale> id
16:53:33 <osaunders> > id id id id id id id id id "PAIN!"
16:53:34 <lambdabot>   "PAIN!"
16:53:38 <Cale> :t (id <*> id) (id <*> id)
16:53:40 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
16:53:40 <lambdabot>     Probable cause: `id' is applied to too few arguments
16:53:40 <lambdabot>     In the second argument of `(<*>)', namely `id'
16:53:48 <SKK> (<*> id id) (<*> id id)
16:53:53 <SKK> > (<*> id id) (<*> id id)
16:53:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> a -> b
16:53:57 <Cale> SKK: <*> is an infix operator
16:54:01 <Eduard_Munteanu> :t fix id
16:54:02 <lambdabot> forall a. a
16:54:11 <Eduard_Munteanu> > fix id
16:54:14 <lambdabot>   mueval-core: Time limit exceeded
16:54:17 <Cale> You actually just wrote a section of it there...
16:54:26 <SKK> > (id <*> id) (id <*> id)
16:54:28 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
16:54:29 <SKK> oh cool
16:54:37 <SKK> so it bottom IS inhabited
16:54:37 <BCK> don't mess with me
16:54:59 <SKK> > (id <*> id) (id <*> id) 3
16:55:01 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> t -> t1
16:55:10 <mikeg> @let 2=3
16:55:12 <lambdabot>  Defined.
16:55:15 <Eduard_Munteanu> > fix const 2
16:55:16 <lambdabot>   Occurs check: cannot construct the infinite type: a = b -> a
16:55:17 <Cale> We can force that expression to typecheck by adding some isomorphisms to it, I believe.
16:55:24 <SKK> > (id <*> (forall a b => a b)) (id <*> id)
16:55:26 <lambdabot>   <no location info>: parse error on input `=>'
16:55:27 * Cale thinks...
16:55:56 <SKK> need to eta-expand the first id ?
16:56:05 <Eduard_Munteanu> Type operators aren't allowed there.
16:56:11 <SKK> :t <*>
16:56:13 <lambdabot> parse error on input `<*>'
16:56:17 <SKK> :t (<*>)
16:56:18 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:56:32 <Eduard_Munteanu> Heh.
16:57:02 <ddarius> :t flip . const
16:57:03 <lambdabot> forall a b b1. (a -> b) -> a -> b1 -> b
16:57:05 <SKK> can you define type operators locally?
16:57:17 <ddarius> :t flip . join
16:57:19 <lambdabot> forall (f :: * -> *) a b. (Functor f, Monad f) => f (f (a -> b)) -> a -> f b
16:57:35 <Eduard_Munteanu> I don't think so, they make sense only in conjuction with typeclasses
16:58:00 <kwantam> possibly stupid and frustrating question: I believe it is possible to define a recursive datatype such that I can define a function that applies the members of a list to another function as arguments, i.e. (approximately) listapply f (a:b:c:[]) = (((f a) b) c); I'm having trouble finagling said datatype, however. Anyone done this before?
16:58:11 <SKK> let i = pure <*> (pure id) in i 0
16:58:17 <SKK> > let i = pure <*> (pure id) in i 0
16:58:19 <lambdabot>   0
16:58:34 <Eduard_Munteanu> :t scanl
16:58:35 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:58:53 <SKK> > let dbl = id <*> id in dbl dbl 0
16:58:55 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
16:58:57 <Eduard_Munteanu> Gr...
16:59:12 <SKK> > let dbl = id <*> id in dbl id dbl 0
16:59:13 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
16:59:16 <Cale> kwantam: It's possible using typeclasses to do things like that, but you probably really don't want to.
16:59:20 <Eduard_Munteanu> kwantam: that's some sort of fold
16:59:33 <Cale> It's not a plain fold.
16:59:38 <Eduard_Munteanu> like foldl' f (head xs) (tail xs)
16:59:42 <Cale> Think about what the type of listapply should be
16:59:43 <Eduard_Munteanu> erm s/'//
16:59:45 <kwantam> E_M: it's not a fold because the type changes constantly
16:59:48 <Cale> What's the type of f?
16:59:58 <osaunders> kwantam: Is that even type valid
17:00:15 <kwantam> osaunders, not in any obvious way
17:00:15 <Cale> It's not on the face of it valid, but given enough typeclass polymorphism, it's possible.
17:00:21 <kwantam> what Cale said
17:00:32 <osaunders> Yes
17:00:36 <SKK> > let dbl = id <*> id in (\a b -> dbl a) dbl 0
17:00:38 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
17:00:49 <Eduard_Munteanu> It won't work on empty lists though.
17:00:55 <SKK> :t (id <*> id)
17:00:57 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
17:00:57 <lambdabot>     Probable cause: `id' is applied to too few arguments
17:00:57 <lambdabot>     In the second argument of `(<*>)', namely `id'
17:00:58 <Cale> Eduard_Munteanu: It might.
17:01:00 * monochrom suggests the Hungry type in TaPL
17:01:11 <SKK> :t (id <*>)
17:01:12 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
17:01:15 <kwantam> It ought to, if it's done right; listapply f [] should be f
17:01:54 <Eduard_Munteanu> Oh, damn, I misread his problem.
17:01:57 <osaunders> > (+) <*> id $ 10 -- why is this 20?
17:01:58 <lambdabot>   20
17:02:04 <SKK> hey, someone help me do this!
17:02:41 <Cale> :t (id <*> InR)
17:02:42 <lambdabot> forall b. (Rec b -> b) -> b
17:02:57 <SKK> :t (Rec b)
17:02:58 <Cale> :t (outR <*> id)
17:02:59 <lambdabot> Not in scope: data constructor `Rec'
17:02:59 <lambdabot> forall b. Rec b -> b
17:03:05 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
17:03:06 <JoeyA> (f <*> g) x = f x (g x), if I'm not mistaken
17:03:11 <Cale> InR and outR are isomorphisms
17:03:12 <SKK> Rec b is a fixpoint type?
17:03:19 <JoeyA> > (+) 10 (id 10)
17:03:20 <lambdabot>   20
17:03:22 <kwantam> Cale: the problem I have with the typeclass approach is that naively it seems that I'd need to define a member of the class for all X in (function of N arguments), N=1..
17:03:26 <Cale> (you can think of them as being like approximations to id ;)
17:03:39 <aavogt> > (+) <*> id $ x :: Expr
17:03:40 <lambdabot>   x + x
17:03:42 <BMeph> > (*) <*> succ $ 4 -- why is this 20?
17:03:43 <lambdabot>   20
17:03:45 <Cale> kwantam: You can just define it once for function types.
17:04:00 <BMeph> osaunders: Does ^^ help? ;)
17:04:02 <Cale> kwantam: Remember that all functions in Haskell take exactly one parameter
17:04:16 <JoeyA> BMeph: because it takes 4 and multiplies it by its successor :-)
17:04:24 <Cale> > (id <*> InR) (outR <*> id)
17:04:28 <lambdabot>   mueval-core: Time limit exceeded
17:04:29 <Cale> ^^ win
17:04:31 <kwantam> hmm, what you say makes sense
17:04:45 <SKK> lol omg i just defined that datatype a week ago just fooling around with the same name, except it was 
17:04:53 <SKK> > data Self a = Rec (Self a -> a)
17:04:55 <lambdabot>   <no location info>: parse error on input `data'
17:05:12 <osaunders> BMeph: No, I guess I've forgotten how applicatives work.
17:05:14 <SKK> but that's cheating
17:05:21 <SKK> u should be able to do without it
17:05:57 <monochrom> @type (+) <*> id
17:05:57 <lambdabot> forall a. (Num a) => a -> a
17:05:58 <SKK> why does lambdabot actually know this Rec constructor?
17:06:17 <SKK> :t Rec id
17:06:19 <lambdabot> Not in scope: data constructor `Rec'
17:06:26 <SKK> :t (Rec id)
17:06:28 <lambdabot> Not in scope: data constructor `Rec'
17:06:34 <SKK> :t (Rec Integer)
17:06:35 <lambdabot> Not in scope: data constructor `Rec'
17:06:35 <lambdabot> Not in scope: data constructor `Integer'
17:06:43 <Eduard_Munteanu> It ain't there.
17:06:54 <SKK> :t InR
17:06:55 <lambdabot> forall a. (Rec a -> a) -> Rec a
17:07:07 <Eduard_Munteanu> Ah, it's a type, that explains it.
17:07:09 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 5
17:07:10 <lambdabot>   120
17:07:29 <SKK> :[
17:07:41 <Cale> ^^ traditional Y combinator, using isorecursive types :)
17:07:58 <SKK> oh wait, that makes complete sense
17:08:09 <Eduard_Munteanu> Dead owl combinator (x x)
17:08:32 <SKK> pretty awesome
17:08:55 <Cale> So even if Haskell didn't initially support recursion at the value level, we could recover it from the recursion at the type level.
17:09:01 <SKK> what about the one for kinds?
17:09:19 <monochrom> isorecursive types scare kids.
17:09:22 <Cale> Haskell's kind system is probably too weak to do any sort of trickery.
17:09:23 <SKK> of course, that makes perfect sense
17:09:35 <monochrom> equirecursive types scare kids and babies
17:09:57 <Eduard_Munteanu> So babies deal better with isorecursive types? :)
17:10:02 <kmc> there's a wretched type-family hack to get equirecursive types in Haskell
17:10:11 <kmc> s/Haskell/what GHC 6.12.3 happens to accept/
17:10:26 <kmc> you can use a synonym family to hide stuff from the occurs check basically
17:10:28 <SKK> can u inhabit (forall a.  (a -> a) -> a) ?
17:10:32 <BMeph> Eduard_Munteanu: I guess, they don't know enough to be scared... ;)
17:10:36 <kmc> :t fix -- SKK
17:10:37 <lambdabot> forall a. (a -> a) -> a
17:10:40 <kmc> @src fix
17:10:41 <lambdabot> fix f = let x = f x in x
17:10:53 <monochrom> that is very evil
17:10:54 <kmc> fix f = f (fix f) -- same function, less efficient
17:11:19 <osaunders> kmc: Why is it less effcient?
17:11:27 <Eduard_Munteanu> Is Mu a standard name for the type-level Y combinator?
17:11:36 <Cale> Eduard_Munteanu: yeah
17:11:36 <ddarius> Eduard_Munteanu: Sort of.
17:11:42 <Eduard_Munteanu> I see.
17:11:45 <Cale> mu and nu both
17:11:46 <kmc> Eduard_Munteanu, yes.  μ and ν are common names for least fixed point resp. greatest fixed point in math
17:11:49 <Eduard_Munteanu> Oh.
17:11:50 <kmc> in Haskell they're the same?
17:11:53 <monochrom> I call it Fix
17:11:53 <SKK> that's the one i was asking for
17:12:03 <ddarius> (Also, "Y combinator" technically specifically means the crazy lambda expression.)
17:12:07 <kmc> osaunders, length . take 10000 . fix ('x':)
17:12:20 <kmc> with the first fix it just goes round and round a circularly linked cons pair
17:12:27 <Eduard_Munteanu> ddarius: crazy lambda as in the call-by-value Y combinator from TAPL?
17:12:40 <kmc> with the second fix it will potentially build a 10000 node list in memory
17:12:44 <ddarius> Usually the call-by-name one.
17:12:56 <SKK> so what kind of things can you do with Fix?
17:13:03 <Eduard_Munteanu> The call-by-name one is simpler anyway.
17:13:10 <monochrom> call-by-value Y is too crazy to be called crazy.
17:13:14 <kmc> SKK, generic catamorphisms:   cata :: (Functor f) => (f a -> a) -> Mu f -> a
17:13:18 <Cale> Someone should work out the right application of InR's and outR's to make this work:  Yk = (L L L L L L L L L L L L L L L L L L L L L L L L L L) where L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
17:13:26 <kmc> i'm writing up a blog post about this SKK
17:13:37 <SKK> I want to take the fixpoint of the type operator (/\ a => a -> a)
17:13:43 <kmc> we'll see if it arrives ever
17:13:43 <ddarius> Often the call-by-value Y combinator is called the Z combinator.
17:13:45 <kmc> haha
17:14:01 <Cale> self-documenting lambda calculus ;)
17:14:08 <SKK> Cale, that one is due to Klop
17:14:17 <Cale> yeah
17:14:18 <kmc> Haskell lets you write the type of infinite ∞-ary trees
17:14:28 <kmc> maybe i should say ω-ary
17:14:41 <SKK> kmc, link plz?
17:14:42 <kmc> data Tree = Tree (Integer -> Tree)
17:14:58 <kmc> but that's not related to the above, just a thing i remembered
17:15:01 <kmc> SKK, it's not up yet
17:15:01 <Eduard_Munteanu> kmc: why, first cardinal > aleph zero?
17:15:07 * ddarius actually read the first as omega-ary.
17:15:17 <Cale> I WAN TYPE OF ZFC SETS NAO.
17:15:26 <SKK> hehehhehe
17:15:29 <Eduard_Munteanu> :)
17:15:32 <kmc> Eduard_Munteanu, ?  i think ordinal numbers are correct here
17:15:38 <kmc> so i wrote ω
17:15:57 <kmc> Cale, mr fancy pants ZFC
17:16:04 <kmc> back in my day we used naive sets and it worked just fine
17:16:11 <kmc> data Set = MkSet (Set -> Bool)
17:16:17 <Eduard_Munteanu> Oops, I'm confusing.
17:16:25 <kmc> and by "worked just fine" i mean "puts the GHC inliner into an infinite loop in a known wontfix bug"
17:16:31 <BMeph> OMG - ω'd! 
17:16:40 <Cale> lol
17:16:41 <BMeph> :)
17:16:42 <kmc> hey BMeph :D
17:16:50 <Eduard_Munteanu> If that ZFC thingy come by my house... I kill it.
17:16:54 <SKK> seriously though what's the difference between using Fix F and writing   data FFixed = FF (F FFixed)  ?
17:17:03 * BMeph tips his cyber-chapeau in kmc's general direction
17:17:14 <kmc> BMeph, long time? or were you here under another nick?
17:17:19 <kmc> SKK, because you can write generic stuff
17:17:27 <Cale> SKK: notation, plus maybe an extra partially-defined value
17:17:29 <kmc> like cata :: (Functor f) => (f a -> a) -> Mu f -> a
17:17:45 <Cale> and yeah, the separation lets you do things with the original functor
17:17:47 <SKK> \Omegad
17:18:33 <BMeph> kmc: Long time; went for a few months with unreliable 'net service. It got better. :)
17:18:37 <Cale> cata :: Functor f => Algebra f a -> FixF f -> a
17:18:45 <Cale> ^^ the one from category-extras
17:18:57 <SKK> what are category-extras?
17:19:03 <Cale> http://hackage.haskell.org/package/category-extras
17:19:12 <Eduard_Munteanu> Lots of fun in there.
17:19:41 <SKK> is this the bananas go into boxes thing?
17:20:32 <Cale> It's Edward Kmett's implementation of specialisations of things from category theory and recursion theory into Haskell.
17:20:34 <SKK> ah ok i see
17:21:15 <SKK> don't see any recursion theory there
17:21:31 <Cale> See Control.Morphism.*
17:21:41 <Eduard_Munteanu> Actually there was a paper titled something like "functional programming with bananas, lenses, [...]"
17:21:49 <Cale> Yeah, and barbed wire
17:21:54 <Eduard_Munteanu> :)
17:22:10 <BMeph> Fokkinga's thesis, Ch. 3, I think. :)
17:22:25 <SKK> cool
17:22:29 <BMeph> Also released as an excerpt.
17:22:43 <SKK> thanks a lot, this has been a very enjoyable haskell chat
17:22:46 <Eduard_Munteanu> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.41.125
17:22:52 <SKK> good night
17:22:58 <Eduard_Munteanu> SKK: good night
17:24:16 <kmc> Cale et al: I'm thinking of doing a blog article called "#haskell lightning round"
17:24:21 <kmc> which is to say answering questions that come up a lot here
17:24:26 <kmc> not big things like "what is monad"
17:24:43 <Eduard_Munteanu> What kinda questions?
17:24:45 <kmc> but little stuff i've noticed, like "why is the one fix more efficient than the other fix"
17:24:52 <kmc> or "what the hell does the kind of (->) mean"
17:24:53 <monochrom> but like "can I ask a question here?"
17:24:58 <kmc> yes monochrom exactly
17:25:01 <danharaj> if I factor out a common subexpression via where, is it guaranteed to be shared?
17:25:03 <Eduard_Munteanu> :)
17:25:25 <monochrom> there is a complete enumeration of "can I ask a C++ question here" etc :)
17:25:35 <Boxo> > let (.)> let comp = ap (const ap) const in ((*2) `comp` (+10)) 1
17:25:35 <aristid> @quote c++
17:25:35 <lambdabot> thermoplyae says: <thermoplyae> someone finally pointed out to me that a monad is an monoid-object in an endofunctor category <thermoplyae> i have no idea how i've never seen that before
17:25:36 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
17:25:45 <Boxo> > let comp = ap (const ap) const in ((*2) `comp` (+10)) 1
17:25:47 <lambdabot>   22
17:25:57 <Eduard_Munteanu> Isn't that a guy from #math?
17:25:59 <aristid> @quote c\+\+
17:26:00 <lambdabot> quicksilver says: C++ templates are a vile obscenity with no theoretical foundation and no comprehensible denotational semantics. Please do not compare them to haskell types or classes again.
17:27:00 <monochrom> yes, if you factor out and put in where, it has to be shared
17:27:20 <McManiaC> Segmentation fault/access violation in generated code
17:27:21 <McManiaC> :(
17:27:34 <Eduard_Munteanu> Unless it's too polymorphic for it's own good, right?
17:27:42 <monochrom> yes thermoplyae is in #math
17:27:49 <Eduard_Munteanu> (like for top-level bindings)
17:28:19 <ezyang> McManiaC: Good luck. 
17:28:26 <danharaj> wouldn't the monomorphism restriction bite me in the ass if it were too polymorphic?
17:28:27 <ezyang> Hopefully, it's in C and not in Haskell. 
17:28:33 <monochrom> monomorphism restriction kills polymorphism
17:28:47 <danharaj> I mean, ghc will kick me in the face
17:28:48 <Eduard_Munteanu> monochrom: and I guess he came by in here puzzled by what somebody said in #math? :)
17:28:50 <danharaj> so I will know.
17:29:44 <monochrom> I don't know. maybe he came here. maybe lambdabot went there.
17:29:52 <danharaj> @where lambdabot
17:29:52 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
17:30:00 <danharaj> no, lambdabot is right there!
17:30:12 <Eduard_Munteanu> Oh, that would make sense if Cale's keeping lambdabot around, isn't he?
17:30:13 <monochrom> maybe they both went to #erlang
17:31:12 <monochrom>  @where is a bunch of lies
17:31:36 <aavogt> @where lies
17:31:36 <lambdabot> I know nothing about lies.
17:32:05 <aristid> @where aavogt
17:32:05 <lambdabot> I know nothing about aavogt.
17:33:36 <danharaj> Haskell is interesting in that I don't mind naming my variables by single letters
17:33:50 <McManiaC> http://npaste.de/qa/ :(
17:33:52 <ezyang> That's because Haskell functions tend to be short! 
17:33:55 <danharaj> in fact, long names hinder the readability of my code
17:34:04 <danharaj> It is a lot more like math than it is like other programming languages :p
17:34:48 <danharaj> the only long names I use are greek letter names
17:34:59 <danharaj> because delta is the most natural symbol for a quantity denoting change, for example.
17:35:09 <mauke> δ
17:35:10 <monochrom> like αλφα ?
17:35:18 <danharaj> heh
17:35:19 <ezyang> -XUnicode 
17:35:35 <mauke> > let δ = 2 in δ
17:35:35 <danharaj> I don't have an editor with nice unicode input
17:35:36 <lambdabot>   2
17:35:38 <danharaj> :[
17:35:45 <mauke> get a better OS
17:35:51 <ezyang> go go XCompose 
17:35:54 <ezyang> ♥ 
17:35:54 <monochrom> I use SCIM
17:36:15 <monochrom> But probably ibus is just as good.
17:36:21 <danharaj> I use notepad++ on windows
17:36:33 <monochrom> Then I have a cunning plan for you.
17:37:06 <monochrom> use virtualbox to run linux and have scim or ibus there. get greek letters there. copy and paste to notepad++
17:37:12 <danharaj> brilliant
17:37:29 <danharaj> I could add another keyboard layout and learn a greek keyboard if I wanted to
17:37:29 <ezyang> googling up unicode symbols works surprisingly well 
17:37:50 <monochrom> http://www.vex.net/~trebla/symbols/select.html
17:38:41 <mauke> http://mauke.ath.cx/stuff/javascript/unicode.html?q=greek+letter
17:39:11 <Eduard_Munteanu> I wonder if irssi could take in LaTeX symbol codes and send the Unicode char.
17:39:13 <monochrom> is notepad++ nice?
17:39:15 <danharaj> I'm trying to come up with utility functions for building FRP streams
17:39:38 <danharaj> right now I am taking inspiration from reactive, but if anyone has ever used an FRP library and wanted a particular utility function, I would like to know.
17:39:40 <mauke> Eduard_Munteanu: is there a list of those somewhere?
17:39:54 <danharaj> monochrom: it is for me
17:39:55 <applicative> McManiaC, where is {-# LANGUAGE MonadComprehension #-} from, I thought it was a forgotten dream.
17:40:13 <danharaj> monochrom: if it has fancy features I wouldn't know, I use it like notepad with syntax highlighting.
17:40:16 <McManiaC> applicative: working on it... thus that segfault :)
17:40:24 <Eduard_Munteanu> mauke: I usually google "latex symbols" when I don't remember something, but they're pretty easy, e.g. \rho, \Phi
17:40:28 <applicative> you are devising one to add to ghc? 
17:40:36 <McManiaC> yeah
17:40:47 <McManiaC> http://hackage.haskell.org/trac/ghc/ticket/4370
17:41:16 <mauke> Eduard_Munteanu: well, it's a bit hard to implement just from that
17:41:16 <monochrom> onoes, McManiaC is working to add segfaults to ghc!
17:41:42 <McManiaC> :(
17:41:47 <monochrom> hehe
17:42:00 <McManiaC> monochrom: it's kinda boring without them tbh
17:42:00 <Eduard_Munteanu> mauke: hm, I have some Vim autoreplace commands that are similar.
17:42:06 <McManiaC> ;D
17:42:17 <mauke> hmm, what would be a good interface for that
17:42:28 <Eduard_Munteanu> imap <buffer> \alpha α
17:42:32 <Eduard_Munteanu> like this in a Vim script ^
17:42:39 <applicative> McManiaC I see.  I didn't realize it was in the air again.  I know it from whichever Wadler paper and accompanying things
17:42:58 <monochrom> "comprehending monads" is the paper name
17:43:04 <applicative> right
17:43:08 <mauke> Eduard_Munteanu: oh, you could hook that into tab completion, I think
17:43:20 <monochrom> wadler is a great pun maker
17:43:27 <Eduard_Munteanu> Hm, I'll try looking at irssi's docs then.
17:43:46 <applicative> strangely, i just started using list comprehensions lately, not having used them before.  why not go further....
17:43:52 <mauke> Eduard_Munteanu: haha, good luck
17:44:20 <Eduard_Munteanu> :)
17:44:51 <applicative> wadler's titles are all wonderful. 'How to turn failure into a list of successes' is too wonderful
17:45:08 <monochrom> "linear types can change the world"
17:45:13 <sm> dixie: yes, hackagebot is rss2irc
17:45:27 <applicative> WHEN WILL THE DEFORESTATION STOP?
17:46:01 <monochrom> that's a real Wadler paper title?
17:46:13 <applicative> teah
17:46:15 <applicative> yeah
17:46:51 <mauke> http://lambda-the-ultimate.org/node/1760
17:47:33 <kmc> so if i want to show off the "cata" generic for all fixed points
17:47:39 <kmc> i can fold over nats, lists, trees
17:47:42 <kmc> any other good demos?
17:47:45 <applicative> monochrom, him and A B Ferguson http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.28.6971
17:48:20 <Eduard_Munteanu> Heh.
17:48:58 <kmc> in particular, those functors all have 2 ctors
17:49:16 <kmc> what are some other good functors which can be fix'd
17:49:44 <ben> You... you can use fix on other things than error?
17:49:55 <kmc> hehe
17:50:17 <dmwit> ?instances MonadFix
17:50:18 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
17:50:27 <copumpkin> kmc: you can make a separate tree that has three constructors ;)
17:50:29 <kmc> i meant the type-level fix
17:50:33 <kmc> copumpkin, true 'nuff
17:50:33 <Eduard_Munteanu> Haskell must be great on debugging, just apply fix to the broken function.
17:50:34 <ddarius> People are always trying to fix things that aren't broken.
17:50:42 <kmc> i see it's comedy hour in here
17:50:59 <dmwit> kmc: Oh, sorry, didn't see the context, just the question.
17:51:09 <kmc> yeah, my question was poorly phrased
17:51:29 <kmc> cata :: (IO a -> a) -> Mu IO -> a
17:51:33 <kmc> seems... unfortunate
17:51:53 <dmwit> funny one =)
17:51:58 <kmc> i'll do rose trees at least
17:52:01 <dmwit> Hard to supply an interesting first argument.
17:52:45 <kmc> i consider unsafePerformIO to be very interesting
17:53:01 <ddarius> data H b a = H (H a b -> b); Mu (H x)
17:53:11 <kmc> what's that ddarius?
17:53:20 <ddarius> Who knows?
17:53:33 <dolio> 'Ultrafunctions.'
17:53:55 <dolio> Or something like that.
17:54:16 <kmc> instance Functor (H x) where...
17:54:23 <ddarius> H is the type of hyperfunctions with the arguments flipped.  Mu (H x) is a functor in x, but what it is I have no idea.  Probably nothing.
17:54:37 <dolio> Oh right, hyper.
17:54:37 <kmc> uh
17:54:40 <kmc> what's a hyperfunction?
17:54:52 <danharaj> not the hyperfunctions I know of
17:55:11 <ddarius> danharaj: You're probably thinking of the things from complex analysis.  These are definitely not those.
17:55:31 <danharaj> yeah I was
17:56:00 <dolio> ((... -> b) -> a) -> b
17:56:46 <pickles> I bought a curtan thingy today that is described as "One Haskel Strip Panel". Naturally I took this as a sign to buy it.
17:56:52 <ddarius> H is covariant in b and contravariant in a just as we'd expect a function type to be.
17:57:12 <Boxo> Hyper a b = Hyper b a -> b
17:57:21 <kmc> weird
17:58:03 <danharaj> what's the point of hyperfunctions?
17:58:13 <ddarius> danharaj: Because we can?
17:58:21 <danharaj> fair enough
17:58:30 <copumpkin> can you do anything useful with one?
17:58:37 <danharaj> if that fixpoint existed in a nice computational category, I would be surprised.
17:58:38 <Eduard_Munteanu> Yes we can
17:58:43 <ddarius> The first paper that introduced them didn't really have applications.  However, there was a later paper but others that did use it for something.
17:59:11 * ddarius wishes he had bread.
17:59:17 * ddarius might have to go buy crappy French bread.
17:59:31 <mauke> Eduard_Munteanu: I've got a working prototype
17:59:47 <Eduard_Munteanu> mauke: oh? I didn't bother THAT much THAT quick :)
18:00:09 <mauke> http://p3rl.org/8766ASDZ
18:00:11 <Eduard_Munteanu> mauke: irssi script?
18:00:14 * Eduard_Munteanu looks
18:00:47 <mauke> actually, the \s* part is useless
18:01:17 <Eduard_Munteanu> mauke: thanks, I'll try it. Do you want my vim charmap file? (I don't remember where I got it from.)
18:01:39 <mauke> sure
18:01:43 <Eduard_Munteanu> mauke:  http://paste.pocoo.org/show/294111/
18:02:15 <Eduard_Munteanu> It doesn't contain the explicit codes, but the actual unicode chars
18:02:22 <mauke> that's fine
18:02:50 <mauke> hmm, should I do the ^ codes too?
18:03:05 <mauke> the current code assumes all abbrevs start with \
18:03:47 <Eduard_Munteanu> mauke: mm, probably not
18:04:17 <Eduard_Munteanu> Superscripts are readable even without unicode
18:04:40 <mauke> also easily typeable with <compose>
18:04:45 <mauke> ¹⁶⁹
18:05:29 <Eduard_Munteanu> Mmm, that "therefore" sign is funny, looks like the Predator thingy: imap <buffer> \therefore ∴
18:13:30 <mauke> Eduard_Munteanu: http://codepad.org/hGjgz9ch
18:13:50 <McManiaC> ok, typechecking monad comprehensions works \o/
18:13:58 <McManiaC> time to look at the desugaring :)
18:13:59 <copumpkin> McManiaC: nice!
18:14:12 <copumpkin> wait, I'd have imagined desugaring came before typechecking
18:14:40 <McManiaC> nope
18:14:44 <mauke> copumpkin: that causes terrible error messages
18:14:48 <Eduard_Munteanu> mauke: thanks
18:14:53 <copumpkin> mauke: oh, fair enough
18:15:04 <McManiaC> desugaring is the last step before optimization/machine code gen
18:15:25 <copumpkin> man, lazy copumpkin would do it first
18:15:32 <copumpkin> real men don't get errors, anyway
18:15:36 <copumpkin> so who needs error messages
18:16:29 <McManiaC> hehe
18:16:36 <mauke> oh fuck
18:16:38 <McManiaC> true
18:16:48 <mauke> wtf is irssi doing with the encoding there?
18:16:59 <copumpkin> where?
18:17:03 <McManiaC> thats why I probably won't fix that one little segfault... ;)
18:19:22 <turiya> can i export data constructors?
18:19:27 <McManiaC> sure
18:19:32 * Eduard_Munteanu needs Munge, installing it.
18:19:54 <McManiaC> module MyModule ( MyData (MyConstructor) ) where ...
18:20:00 <McManiaC> or just MyData (..)
18:20:15 <turiya> McManiaC: the library hsmatrix exports Matrix in the module Data.Packed.Matrix but not the data constructor MC
18:20:25 <mauke> ∞∈𝟙∴∎
18:20:55 <turiya> McManiaC: ok, thanks, i will try that
18:21:28 <mauke> Eduard_Munteanu: get the updated version from http://mauke.ath.cx/stuff/irssi/latex-complete.pl
18:21:39 <lispy_> http://pastebin.com/km74Sjyc  <-- immediately after a fresh/clean install of ghc7.  Should I be worried?
18:22:57 <thoughtpolice> copumpkin: i have succeeded in also making haskell a strict language using more plugins! still trying to get the loop unrolling plugin to work though :/
18:23:05 <copumpkin> thoughtpolice: oh nice!
18:23:45 <thoughtpolice> turns out ghc-syb just isn't necessary in 7.0, because GHC itself has all of the data/typeable instances which is really nice
18:24:13 <Eduard_Munteanu> mauke: hm, that Data.Munge is your thing and it ain't in Gentoo :)
18:24:24 <Eduard_Munteanu> I'll have to get it through CPAN I guess.
18:24:53 <mauke> Eduard_Munteanu: g-cpan?
18:25:07 <Eduard_Munteanu> Is that an overlay?
18:25:13 <mauke> no, a command
18:33:39 <polarina> Does anyone know if the maintainer of bindings-sqlite3 is going to update it anytime soom?
18:34:09 <tolkad> How much memory do partially applied functions take in haskell?
18:34:13 <tolkad> ghc haskell*
18:34:15 <mauke> Eduard_Munteanu: did you get it to work?
18:34:42 <tolkad> are they just a function pointer along with the arguments applied to so far?
18:34:51 <tolkad> or does it recreate the body of the function?
18:35:48 <polarina> tolkad, it isn't that simple.
18:36:12 <Eduard_Munteanu> mauke: nah, I can't really get CPAN to install that into my home dir
18:36:33 <tolkad> polarina: well, how do I know approximately how much memory a partially applied function will require?
18:36:39 <tolkad> polarina: any sort of heuristic?
18:37:14 <tolkad> polarina: because right now, I don't even know what it is dependant on
18:37:22 <polarina> tolkad, the optimizer in ghc does lots of "tricks" that makes it near impossible to give a straight answer.
18:37:30 <mauke> Eduard_Munteanu: don't you have root?
18:37:57 <tolkad> polarina: can I ever expect it to be depedant on the size of the function body?
18:38:08 <polarina> tolkad, I am no expert with GHC. You shouldn't worry about such overhead, it's very minimal and the optimizer will do its best.
18:38:19 <polarina> tolkad, good question.
18:38:37 <FunctorSalad> tolkad: try vacuum?
18:38:51 <polarina> tolkad, are you expecting your function to be huge and dissastrous?
18:39:04 <FunctorSalad> though I'm not sure it works for partially applied functions
18:39:48 <Eduard_Munteanu> mauke: ah it worked, I had it misconfigured. And I'm rather paranoid about root :)
18:39:49 <FunctorSalad> I think that generally speaking it should be one pointer for each free variable in the closure
18:39:56 <mauke> Eduard_Munteanu: I just installed it with 'g-cpan -i Data::Munge'
18:39:58 <mauke> as root
18:40:07 <tolkad> polarina: maybe in the area of 100 bytes?
18:40:07 <FunctorSalad> plus what these pointers point to, of course, if the closure is the only thing keeping them alive
18:40:07 <mauke> it made an ebuild and everything
18:40:43 <tolkad> polarina: not really sure. I'm new to application programming/low level stuff
18:40:50 <polarina> tolkad, mind me asking, why are you attempting to wrap your head on possible size overhead when it really shouldn't matter?
18:40:59 <polarina> tolkad, haskell isn't a low-level language. :)
18:41:02 <Eduard_Munteanu> mauke: any idea how to point Perl to my local home dir installation?
18:41:32 <mauke> Eduard_Munteanu: http://search.cpan.org/~apeiron/local-lib-1.006008/lib/local/lib.pm is what the cool kids use
18:41:47 <tolkad> polarina: because I want to know whether I should store the arguments to a function if I'm only ever going to use them to apply the function to
18:42:08 <mauke> (not me, because I actually have a complete perl in my $HOME, so I'm effectively "root" as far as perl is concerned)
18:42:47 <polarina> tolkad, which method seems simpler to you?
18:43:00 <tolkad> polarina: partially applying the function
18:43:07 <polarina> tolkad, the go with that.
18:43:10 <mauke> Eduard_Munteanu: but if you already have a local module directory, setting PERL5LIB should do it
18:43:21 <tolkad> polarina: thanks :P
18:43:29 <polarina> tolkad, you're welcome. :)
18:44:18 <Eduard_Munteanu> Hm, yes, I'm was trying: use lib '~/perl'
18:48:06 <ddarius> tolkad: A closure stores the variables referred to in the environment which would include any parameters.
18:48:21 <ddarius> The code size of the function is irrelevant to the size of a closure.
18:48:21 <joe6> has anyone checked out Curl library yet? i am noticing that it does not work in my env, but I am not sure if the package is a broken package.
18:49:07 <polarina> ddarius, thanks for clarifying. :)
18:52:16 <Eduard_Munteanu> ∃x, ∀y \therefore z   -- swell stuff, mauke
18:52:22 <Eduard_Munteanu> ∴
18:54:14 <mikeg> Any idea how I could do a binary search of a file in Haskell? Using something like hTell sounds awful :(
18:54:27 <ddarius> You can mmap it.
18:54:27 <tolkad> ddarius: thanks, that was the relationship I was worried about
18:55:11 <Eduard_Munteanu> Heh, that's how I'd do it in C.
18:55:14 <mauke> mikeg: why?
18:56:04 <mikeg> I have a sorted ten million line file of Hash -> Integer, and given a hash I need that integer
18:56:23 <Eduard_Munteanu> Though it might not be ideal since pagefaults would bring in the whole page.
18:56:28 <mauke> ok, but why is hTell awful?
18:56:32 <ddarius> Eduard_Munteanu: So?
18:56:53 <mikeg> Well.. I don't mean "awful," but "difficult" :)
18:57:02 <Eduard_Munteanu> ddarius: I suspect it kills O(log n) complexity on large files
18:57:18 <ddarius> Eduard_Munteanu: Why would it do that?
18:57:42 <Eduard_Munteanu> ddarius: well it's still O(log n), but for each lookup it has to read a lot more from the disk
18:57:59 <Eduard_Munteanu> (at least more than the typical sector size)
18:58:00 <ddarius> Eduard_Munteanu: Which will probably be essentially free for 4kb pages.
18:58:09 <Eduard_Munteanu> Hm, yes.
18:58:16 <ddarius> For 2MB pages, it might hurt a bit.
18:59:36 <Eduard_Munteanu> Yeah, 8 sectors ain't much.
18:59:51 <tolkad> just include a kernel patch with your application
19:00:02 <Eduard_Munteanu> :))
19:00:35 <Eduard_Munteanu> (though you can't work around it like tolkad says)
19:00:47 <mikeg> lol. I'll try mmap later
19:02:38 <Eduard_Munteanu> I wonder, is Haskell's mmap stuff OS-independent, or just for POSIX? Last time I looked it was in System.POSIX or something.
19:03:01 <Eduard_Munteanu> (by OS independent I mean Windows these days)
19:03:16 <Eduard_Munteanu> *mean it works on
19:03:38 <Eduard_Munteanu> @hoogle mmap
19:03:39 <lambdabot> No results found
19:04:11 <ddarius> @hackage bytestring-mmap
19:04:12 <lambdabot> http://hackage.haskell.org/package/bytestring-mmap
19:04:26 <McManiaC> http://blog.n-sch.de/2010/11/21/work-in-progress-monad-comprehension-1/ :D
19:05:17 <joe6> @hayoo toLower
19:05:17 <lambdabot> Unknown command, try @list
19:05:24 <joe6> @list toLower
19:05:25 <lambdabot> No module "toLower" loaded
19:05:31 <joe6> @hoogle toLower
19:05:31 <lambdabot> Data.Char toLower :: Char -> Char
19:06:05 <ddarius> McManiaC: How the heck does that give a segfault?
19:06:18 <Eduard_Munteanu> Hm, so mmap(2)-specific
19:09:05 <copumpkin> McManiaC: I'd call it MonadComprehensions
19:09:20 <thoughtpolice> there's also http://hackage.haskell.org/package/mmap
19:09:27 <copumpkin> McManiaC: most extension names are plural 
19:09:29 <McManiaC> ddarius: I guess it's because lists cannot fail, but monads can
19:09:32 <thoughtpolice> which does windows (MapViewOfFile) and posix mmap
19:09:34 <McManiaC> copumpkin: oh, thats a typo
19:10:20 <Eduard_Munteanu> Didn't Haskell previously have comprehensions for all monads, but has been removed? I think I read that somewhere :/
19:10:25 <copumpkin> McManiaC: are you going to add separate support for Monad and MonadPlus? meaning that you only get a Monad constraint on your comprehension if you don't use guards, and MonadPlus otherwise?
19:10:36 <ddarius> Eduard_Munteanu: Yes.  Haskell 1.4 had monad comprehensions.
19:10:39 <McManiaC> copumpkin: yes
19:10:50 <lpsmith> Eduard_Munteanu, yeah,  list comprehensions uses to be monad comprehensions as well, but that changed with H98
19:11:02 <copumpkin> cool :)
19:11:10 <Eduard_Munteanu> Neat thing to revive as an extension, though.
19:11:31 <Eduard_Munteanu> thoughtpolice: oh, I see.
19:11:39 <lpsmith> Eduard_Munteanu,  well,  the do syntax has most of the same features.
19:11:45 <McManiaC> Eduard_Munteanu: that's why most of the functionality is still there... list comprehensions are already desugared using return and bind
19:12:01 <McManiaC> but of course there's always something to be done :)
19:12:21 <lpsmith> McManiaC, where does filter fit in? :)
19:12:28 * Eduard_Munteanu facepalmed when he saw the SQL-like comprehensions extension.
19:12:30 <McManiaC> lpsmith: monad plus
19:14:00 <lpsmith> McManiaC, well, that can be part of the solution,  but how would e.g. [ x | x <- [1..], even x ] be desugared?
19:14:05 <ddarius> Eduard_Munteanu: Phil Wadler was pretty adamant about them, though I have no idea why.
19:14:28 <McManiaC> lpsmith: that does already work
19:14:43 <dolio> [1..] >>= \x -> guard (even x) >> return x
19:14:52 <mauke> > do x <- [1..]; guard $ even x; return x
19:14:53 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
19:15:15 <lpsmith> ah
19:15:23 <McManiaC> Eduard_Munteanu: monad comprehensions will hopefully "take over" all of those functions
19:16:13 <McManiaC> so you can use sql-like comprehensions for real sql queries ;)
19:17:45 <Eduard_Munteanu> Hah, Wadler has a nice photo here... http://en.wikipedia.org/wiki/File:Wadler2.JPG 
19:17:49 <ddarius> McManiaC: I don't think all of those things map to sensible monadic operations.
19:18:11 <ddarius> You should see his older photos.
19:18:31 <joe6> how do I get rid of the error: "Use -XViewPatterns to enable view patterns"
19:18:50 <joe6> I am trying to add the flag to the file. I tried {-# LANGUAGE -XViewPatterns #-}
19:18:51 <McManiaC> ddarius: we will have to introduce a new "MonadZip" class to use that [ x + y | x <- f | y <- g ] functionality
19:18:56 <joe6> without any luck
19:18:56 <mauke> joe6: remove -X
19:19:01 <joe6> ok, thanks.
19:19:20 <Eduard_Munteanu> joe6: the -X part is when you add it as a parameter to ghc/ghci
19:19:35 <Eduard_Munteanu> *is needed
19:19:42 <FauxFaux> > liftM2 (,) [1..3] [1..3]
19:19:43 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
19:19:54 <joe6>  Cannot parse LANGUAGE pragma  Expecting comma-separated list of language options,
19:20:02 <McManiaC> you could do {-# OPTIONS -XViewPatterns #-} *hides*
19:20:03 <joe6> when
19:20:08 <joe6> I remove the -X
19:20:10 <Eduard_Munteanu> :))
19:20:17 <joe6> ok, thanks. will try the Options
19:20:24 <mauke> joe6: don't
19:20:27 <McManiaC> dont lol
19:20:38 <McManiaC> {-# LANGUAGE ViewPatterns #-}
19:20:39 <joe6> unknown flag in  {-# OPTIONS_GHC #-} pragma: ViewPatterns
19:20:52 <mauke> joe6: what did I tell you?
19:20:56 <McManiaC> at the top of your haskell file (before "module ...")
19:22:10 <joe6> mauke: sorry, I was looking at the previous error message. scrolled too far back.
19:22:33 <joe6> it works now.
19:22:58 <ddarius> McManiaC: You could transform that example to Applicative.
19:23:47 <Eduard_Munteanu> I'd like to study there... http://homepages.inf.ed.ac.uk/wadler/Pics/phillambdabig.jpg
19:25:25 <McManiaC> anway, its laaaaaaate
19:25:28 <McManiaC> gotta go :)
19:26:25 <applicative> McManiaC,  it looks wonderful so far
19:27:09 <ddarius> One of the best Wadler pictures doesn't seem to be on the internet anymore.
19:28:06 <Eduard_Munteanu> Aw.
19:31:42 <turiya> class (Eq a, Show a) => Num a where.. what does the => signify?
19:32:11 <Eduard_Munteanu> turiya: it separates class constraints from the rest.
19:32:58 <Eduard_Munteanu> turiya: that's basically declaring a typeclass Num where each instance must also be members of Eq and Show.
19:33:18 <applicative> its like :   class Num a where (on condition that Eq a and Show a) ....
19:33:20 <turiya> Eduard_Munteanu: oh.. ok.. i get it now..
19:35:37 <ddarius> The arrow is, unfortunately, pointing in the wrong direction to read it as an implication.
19:37:21 <Eduard_Munteanu> Hm yes, you could rather think "if this type is an instance of Num, then it must be an instance of both Eq and Show".
19:37:56 <applicative> ddarius does it seem wrong in signatures for values?
19:38:01 <applicative> @type comparing'
19:38:02 <lambdabot> Not in scope: `comparing''
19:38:05 <applicative> @type comparing
19:38:06 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
19:38:26 <ddarius> applicative: It's fine there and for instance declarations, just not for class declarations.
19:42:05 * Eduard_Munteanu has to leave
19:42:06 <Eduard_Munteanu> o/
19:42:11 <Axman6> o/
19:42:13 <turiya> so, if I want to write deriving (Num) for a data type then I must write deriving (Eq, Show, Num)?
19:42:22 <Axman6> you can't derive Num
19:42:50 <applicative> you can't derive it, it would have to make sense, like Functor or something
19:42:51 <copumpkin> for a newtype you might be able to
19:43:11 <Axman6> but you can't derive it for your own data types
19:43:26 <turiya> hmm.. i dont understand, why is it different from Eq and Show?
19:43:32 <Axman6> i'm not sure it could even be derivable
19:43:42 <kmc> turiya, there is an explicit list in the Report of which classes are derivable
19:43:42 <Cale> turiya: What would the derived instance be, in general?
19:43:57 <Axman6> turiya: if i have data Foo = X | Y | Z Int | Q String, what would the instance of Num look like?
19:44:03 <ddarius> turiya: The deriving mechanism is completely ad-hoc.  In the Eq and Show case, there is at least some reasonable choice.
19:44:19 <Axman6> what's X + (Q str) look like?
19:44:33 <ddarius> Axman6: It's clearly Y.
19:44:39 <applicative> X + Y = Z 4
19:44:45 <Axman6> why not Z 7?
19:44:58 <monochrom> because of human creativity
19:45:02 <applicative> maybe the instance deriver could randomize
19:45:10 <turiya> but we can add instance delarations for Num?
19:45:13 <kmc> yes
19:45:18 <kmc> you can write an instance for any class
19:45:23 <kmc> you can only derive instances for certain classes
19:45:30 <kmc> o_O  http://hpaste.org/41671/my_favorite_error_message
19:46:00 <Axman6> turiya: things like Eq are easy, X == X = True, Y == Y = True, (Z x) == (Z y) = x == y, (Q x) == (Q y) == x == y, _ == _ = False
19:46:01 <monochrom> hahaha
19:46:07 <applicative> kmc, you have no one but yourself to blame for that error message
19:46:12 <kmc> i blame the media
19:46:19 <Axman6> ha
19:46:29 <monochrom> well-typed programs cannot be blamed
19:47:16 <copumpkin> monochrom: I'm learning chinese!
19:47:34 <turiya> ok..i seem not to understand the purpose of deriving..
19:47:38 * hackagebot lenses 0.1.4 - Simple Functional Lenses  http://hackage.haskell.org/package/lenses-0.1.4 (JobVranish)
19:47:42 <applicative> turiya, also, even where you can write "deriving ( Eq, Show, etc)", you can decide against the derived ones for something else, e.g. a show that is pretty printed a bit; or an Eq that
19:47:45 <ddarius> copumpkin: That will be handy on the mean streets of Boston.
19:47:45 <turiya> what does derive accomplish?
19:47:55 <copumpkin> ddarius: indeed! :P
19:48:00 <kmc> turiya, "deriving" means that the compiler writes the instance for you
19:48:02 <Cale> turiya: It saves us from having to type out really boring instances of a few classes
19:48:03 <applicative> would just be an equivalence relation from the derived instance point of view
19:48:54 <turiya> ok, yeah, the compiler would have a hard time figuring out writing a (+) for arbitraty data types..
19:49:04 <kmc> if you write lots of data types and write "natural" Show instances for all of them, you'll recognize a pattern
19:49:08 <kmc> likewise Eq
19:49:21 <kmc> the pattern for Eq is "if same constructor, compare fields pairwise; if not same constructor, return False"
19:49:28 <applicative> turiya, if you think how data Foo = X | Y | Z Foo works, it's like a grammar, giving you a bunch of expressions.  The 'derived' Eq says that where they're different, so are the values they denote
19:49:33 <ddarius> Polytypism
19:49:56 <turiya> so, if i add an instance declaration of Num for my data type, i need to add instance declarations for Eq and Show?
19:50:01 <danharaj_> in some sense, the automatically derived Eq definition is the most general derived type.
19:50:08 <danharaj_> most general Eq*
19:50:12 <Cale> turiya: Or derive it
19:50:29 <turiya> Cale: i was unable to do so..
19:50:44 <applicative> turiya, what does the type look like?
19:50:46 <Cale> You can't derive Num, but you can derive Eq and Show
19:51:28 <applicative> > map 1 [2,3]
19:51:28 <lambdabot>   [1,1]
19:51:41 <ddarius> > 1.[2,3]
19:51:43 <lambdabot>   [1,1]
19:51:49 <danharaj> :t 1
19:51:50 <Twey> o.@
19:51:50 <lambdabot> forall t. (Num t) => t
19:51:52 <Twey> :t map
19:51:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:51:53 <applicative> turiya, there's a truly depraved Num instance for you....
19:52:03 <Twey> What the heck is that Num instance?!
19:52:10 <Twey> > 5 undefined
19:52:11 <lambdabot>   5
19:52:12 <turiya> applicative: http://hpaste.org/41672/data_type
19:52:40 <Twey> Num n => Num (b -> n)?
19:52:44 <Cale> yep
19:52:53 <Twey> Lovely
19:53:05 <ddarius> > zipWith 3 "abc" "def"
19:53:06 <lambdabot>   [3,3,3]
19:53:20 <Twey> Now we just need to include the Roman-numeral Num a => IsString a instance
19:53:27 <kmc> hahaha
19:53:38 <danharaj> I hope that instance isn't prelude :|
19:53:48 <Twey> danharaj: Hahaha, no.
19:53:59 <turiya> applicative: it seems, deriving Show on Matrix fails
19:54:06 <Cale> I kind of think the Num instance for functions should be
19:54:38 <Twey> I like the way the Num instance works for * and so on
19:54:55 <Twey> (+ 5) * (+ 3) $ 6
19:54:58 <Twey> > (+ 5) * (+ 3) $ 6
19:54:59 <lambdabot>   99
19:55:09 <Cale> > sin^2 + cos^2 $ 1/2
19:55:10 <lambdabot>   1.0
19:55:12 <Twey> The auto-lifting is cool
19:55:17 <Twey> Yeah, that's nice too
19:55:24 <applicative> turiya, I was going to ask where the Matrix type was coming from 
19:55:36 <Twey> But I don't like that const one one bit
19:55:38 <applicative> what does it look like?
19:55:41 <Twey> That's horrific
19:55:50 <Cale> Wait, why?
19:55:54 <Cale> That's the natural thing
19:55:58 <ddarius> It's natural.  cos^2 + sin^2 = 1
19:56:12 <turiya> applicative: it is from the hmatrix library
19:56:13 <Twey> ddarius: Not that one
19:56:14 <Cale> The constant 0 function is the additive unit
19:56:21 <Cale> and the constant 1 function is the multiplicative unit
19:56:27 <Twey> ddarius: This one: > map 1 [2,3] ⇒ [1,1]
19:56:34 <Twey> Cale: Mmm
19:56:37 <ddarius> It's the same instance.
19:56:37 <Twey> I guess so
19:56:38 <Cale> 1 is the constant 1 function
19:56:40 <Axman6> > 1 "hello"
19:56:41 <lambdabot>   1
19:56:48 <Twey> Yeah, I know.  It's just odd to me.
19:57:24 <danharaj> It's completely natural to mathematicians :p
19:57:30 <mauke> > (* 2) + 1 $ 3
19:57:32 <lambdabot>   7
19:57:43 <mauke> > sin + pi $ 3
19:57:44 <lambdabot>   3.2827126616496605
19:57:54 <Axman6> > sin + pi $ 0
19:57:55 <lambdabot>   3.141592653589793
19:58:16 <Twey> danharaj: Yes, well :þ
19:58:56 <Axman6> so, i take it fromIntegral x = \y -> fromIntegral x?
19:59:19 <Cale> Yeah
19:59:38 <danharaj> The covariant hom functor is nice.
19:59:47 <danharaj> you can do things like that.
20:00:01 <mauke> http://mauke.ath.cx/stuff/haskell/fun.hs  <- not what lambdabot actually uses but illustrates the concept
20:08:07 <Axman6> will installing ghc-6.12.3 on OS X replace ghc-7.0.1? (this is what i want)
20:08:39 <Cale> My guess would be no.
20:08:58 <Cale> Though it will update the symlinks for ghc, ghc-pkg, etc.
20:09:18 <Axman6> well, that's all i need
20:10:43 <ddarius> instance Monoid m => Num (m -> m) where fromInteger 0 = const mempty; fromInteger 1 = id; fromInteger n = sum (genericReplicate n 1); m + n = \x -> m x `mappend` n x; m * n = m . n
20:11:09 <ddarius> (restricting to m -> m that are monoid homomorphisms)
20:17:00 <ddarius> I guess this would be prettier: instance Monoid m => Num (Endo m) where (*) = mappend; Endo (m + n) = Endo (m `mappend` n); fromInteger 0 = Endo mempty; fromInteger 1 = mempty; fromInteger n = sum (genericReplicate n 1)
20:17:35 <edwardk> but then there are the pesky Eq and Show instances to give
20:18:41 <mauke> instance Eq (Endo m); instance Show (Endo m);
20:18:53 <edwardk> and is fromInteger n allowed to do anything by the monoid laws? so shouldn't fromInteger _ just be mempty? =)
20:20:14 <osaunders> @where typeclassopedia
20:20:14 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
20:20:18 <applicative> turiya, actually in principle, it seems like you might be able to get it to derive Show for hmatrix Matrix.  You would need to add several conditions
20:21:10 <edwardk> ah i think i see the intent, apply the function n times?
20:21:30 <edwardk> (not that was stated, but what one could do)
20:21:51 <turiya> applicative: yes, as there is a Show for ForeignPtr a, i believe it can be done ..
20:22:14 <turiya> what editor is best for haskell?
20:22:41 <Twey> emacs
20:23:03 <ddarius> The intent is not to apply the function n times. fromInteger 3 will be \m -> m `mappend` m `mappend` m
20:23:43 <turiya> i want nice indentation and some colours (syntax highlighting).. can emacs do that?
20:23:55 <applicative> it seems that the Matrix type is basically (Int,Int,Vector t)  but Vector t can be either the one from the vector package or else the homemade one with ForeignPtr a.  
20:23:58 <mauke> any editor can do that
20:24:22 <edwardk> yeah i just got the difference in your fromInteger, i didn't spot the Endo mempty vs. mempty
20:24:24 <turiya> mauke: kwrite is not good @ indentation
20:24:35 <applicative> but if it is  using the Data.Vector vectors, they already  have a Show instance, 
20:25:32 <edwardk> @src genericReplicate
20:25:33 <lambdabot> Source not found. You untyped fool!
20:25:50 <ddarius> appEndo (3*5) (Sum 1) == Sum 15
20:26:28 <ddarius> I messed up the left hand side of the (+) definition though.
20:26:33 <edwardk> you might want to use http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/Data-Monoid-Combinators.html instead of genericReplicate to get the peasant exponentiator going
20:26:41 <applicative> instance Show a, Storable a => Show (Vector a)  it says there.
20:26:59 <turiya> applicative: i am using the ForeignPtr version, for Matrix it is "instance (Show a, Element a) => Show (Matrix a)"
20:27:06 <ddarius> edwardk: Isn't it specifically a -Russian- peasant?
20:27:16 <edwardk> Endo f + Endo g = Endo (\m -> f m `mappend` g m)
20:27:17 <turiya> does that not mean "a" can be any type..
20:27:36 <applicative> oh, so is the deriving show for Chitram go through?
20:27:48 <ddarius> edwardk: Yeah, but you can just write f `mappend` g, that part was right.
20:28:12 <applicative> no, it means you'll only be able to write   "show m" for matrices of showable, element items
20:28:20 <edwardk> where is the lifting of any monoid into a ->  hiding?
20:28:24 <ddarius> edwardk: Also, there's an implicit requirement that f in Endo f is a monoid homomorphism because Endo (const 1) * 0 doesn't do the right thing.
20:28:40 <ddarius> @instance Monoid 
20:28:40 <lambdabot> Maybe you meant: instances instances-importing
20:28:45 <ddarius> @instances Monoid 
20:28:46 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
20:28:52 <turiya> applicative: it says "No instance for (Element Word8)"
20:28:55 <ddarius> It should be in Data.Monoid with the rest.
20:29:43 <edwardk> ah, overlooked it
20:29:50 <ddarius> (well, const -1- might do the right thing if 1 = mempty, but const x where x /= mempty won't)
20:30:19 <turiya> applicative: oh, i see.. i often get confused on reading instance and class declarations
20:30:59 <turiya> applicative: so an instance of Element for Word8 has to be defined
20:31:56 <applicative> That's what it's asking for, does that make sense?  Ive never used Element
20:33:23 <turiya> applicative: yes. I would add my own instance declarations of Show for Chitram. can that be done?
20:33:26 <copumpkin> edwardk: turns out that discount is on the data too
20:33:28 <osaunders> Is pure = const in instance Pointed ((->) r)?
20:33:45 <edwardk> copumpkin: sweet. i'll need to sign up =)
20:33:54 <copumpkin> :D
20:34:02 <copumpkin> Apocalisp: you too!
20:34:26 <onteria> vim haskellmode is really nice when learning haskell
20:34:46 <applicative> turiya, I see Element is from the same hmatrix file; i assumed it was something else.  Can you comprehend the instances for Element Float etc. at the bottom there?  You might be ab le to get the derivation going
20:34:46 * ddarius has never used the vim haskell modes.
20:35:14 <edwardk> osunders: yes
20:36:40 <applicative> turiya you can define your own  instance Show Chitram  where ...   you are likely to bump up to similar difficulties on the way, though. 
20:37:53 <applicative> turiya, you just have to define a function show :: Chitram -> String   it could be:  \chit -> "I'm a chitram"
20:38:44 <turiya> applicative: actually, i do not care about show on a Chitram
20:39:12 <turiya> i would just write something like what you have above
20:39:18 <turiya> written*
20:39:58 <turiya> but i wanted to know why a show on a Matrix was not working..
20:42:10 <ddarius> Where'd lambdabot go now?
20:43:27 <applicative> turiya, right, i forgot matrix was our main point.  Now that i'm figuring it out, I don't know w hy he doesn't add a show instance, maybe he thinks it'll be too ugly. the materials are present
20:43:56 <applicative> how can I derive a Show instance for a type defined in someone else's module?
20:44:15 <applicative> instance Show Foo where deriving Show  ?
20:45:15 <turiya> some one with more knowledge than me can be of help .. :)
20:46:33 <turiya> applicative: i have no idea..
20:49:22 <dabuckle> \leave
20:50:23 <xpika> I'm on ghc 6.10.4
20:50:53 <xpika> I'm on ghc 6.10.4, if i install 6.12.3 will i loose all my cabal packages and have to download them again?
20:53:29 <applicative> cabal maintains a registry for the old ones. but you wont be able to use the libraries with the new compiler.   the executables should still work
20:53:34 <applicative> i think thats right
20:54:59 <xpika> i might be better uninstalling ghc first then
20:55:30 <xpika> I'm using the one which comes with macports
20:55:36 <applicative> if you look inside ~/.cabal/lib/mypackage  youll see how it works
20:56:09 <applicative> for me, each package has a subdirectory ghc-6.12.1 and anaother ghc-6.12.3
20:56:31 <dmead> can someone tell me why ghci always tries to cd to .ghc or .cabal, instead of the current directory it's called on?
20:56:48 <dmead> or called in rather
20:56:59 <applicative> does it?? 
20:57:22 <dmead> it does
20:57:31 <dmead> at least with the default install with gentoo and ubuntu
20:57:45 <dmead> but not fedora :s
20:58:23 <applicative> xpika, I am using the Platform installer on OS X.   I used the macports one before, I cant remember if there are any delicacies about using one after the other.  the new ghc will go in /usr/local/bin
20:58:44 <dmead> the default behavior in haskell mode prepends "Prelude> :cd ~/.cabal/" to the haskell-load-file function
20:58:48 <dmead> which is awful
20:59:06 <xpika> can i install cabal packages to specific ghc versions?
20:59:24 <applicative> oh yes, check  cabal install --help
20:59:44 <megajosh2> Does anybody know how to catch an exception that "read" throws?
21:00:08 <dmead> catch works fine 
21:00:53 <MiggyX> Hi guys - does anyone happen to know off hand where the concept of pure / impure functions originated?
21:01:15 <applicative> xpika, it will even let you specify jhc as the default compiler in you cabal configuration file.  
21:01:24 <megajosh2> > (read "asdf" :: Int) `catch` \e -> putStrLn "There was a horrible error~"
21:01:44 <megajosh2> Oh it's not here...
21:02:00 <dmead> MiggyX, this is probably a good start http://www.google.com/search?client=ubuntu&channel=fs&q=liberated+from+the+von+neumann+model&ie=utf-8&oe=utf-8
21:02:09 <applicative> MiggyX, isn't the real question:  Where did the pseudoconcept of an impure function come from?
21:02:27 <applicative> dmead, excellent idea
21:04:02 <MiggyX> awesome thanks. i was wondering if a similar idea ould be applied to testing frameworks, to determine whether thy can be reliably stubbed or if they need something more such as a simulator
21:04:04 <dmead> thanks
21:04:21 <dmead> MiggyX, how do you mean?
21:04:27 <dmead> like referential transparency?
21:04:35 <dmead> or something?
21:04:58 <megajosh2> dmead: Hey, could you give me an example of using "catch" to catch errors that "read" throws?
21:05:08 <megajosh2> I keep getting type errors when I try to use it
21:05:15 <Axman6> :t catch
21:05:20 <dmead> megajosh2, actually i can, hold on a sec
21:05:29 <MiggyX> when testing software there are some things that cant be stubbed i.e a price feed or externally hosted api
21:05:33 <dmead> i used that trick to make a crappy type checker last semester
21:13:58 <megajosh2> dmead: You still there?
21:14:01 <dmead> yep
21:14:02 <dmead> i found it
21:14:04 <MiggyX> I was thinking of expanding the pure / impure concept ( effectively whether a function, method or component uses I/O ) as a way to determine that stubbing code for tests would not be sufficient
21:14:05 <dmead> http://taz.cs.wcupa.edu/~dmead/SQLparser.hs
21:14:12 <dmead> look at typechecker, top of the file
21:14:44 <dmead> it uses stuff from Control.Exception
21:15:30 <Boxo> Is there a Haskell debugger that can let you watch it evaluation expressions step by step?
21:15:37 <Boxo> s/evaluation/evaluate
21:15:44 <MiggyX> dmead: hopefully that doesn't sound too insane ;)
21:15:55 <dmead> Boxo, ghci does that iirc
21:16:00 <dmead> consult the manual?
21:16:02 <megajosh2> dmead: Alright, thanks!
21:17:45 <Boxo> I'm looking at it, I was thinking of something more usable that just displayed the current expression and evaluated it one step further when you press a key, without having to enter a list of commands before and after every step...
21:20:19 <dmwit> Boxo: The hat debugger works somewhat like that, though it's of limited use -- if you use Data.Map or just about any GHC extension, it doesn't work.
21:20:46 <kmc> MiggyX, Haskell doesn't have pure vs. impure functions
21:21:42 <MiggyX> kmc: Didn't know that - it seems to be written about Haskell a lot.  However it's more the idea of pure vs impure functions that I was looking to apply
21:21:53 <MiggyX> Admittedly I was hoping to look at Haskell to find the base theory for this :/
21:23:07 <Axman6> dmwit: what's wrong with Data.Map?
21:23:17 * dmwit shrugs
21:23:23 <kmc> MiggyX, yes, it's a common misconception by people who don't know haskell
21:23:24 <Boxo> Meh, I'm trying to write a little function to reduce lambda calculus expressions and being hilariously inept at it
21:23:24 <Axman6> heh, fair enough
21:23:43 <kmc> MiggyX, Haskell does have something interesting in this area but that's a bad description of it
21:23:48 <copumpkin> MiggyX: all functions are pure, but some may return computations that, when run, affect the outside world
21:23:56 <ddilinger>                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
21:24:01 <kmc> it's not about pure vs. impure functions.  it's about evaluation versus execution
21:24:11 <kmc> some functions evaluate to "IO recipes" which, *if executed*, would have some effect
21:24:23 <kmc> some function applications, i should say
21:24:30 <kmc> but the function itself has no effect
21:24:35 <kmc> and the recipe itself is just a value
21:24:44 <kmc> and does nothing until it reaches a particular point in the runtime system
21:25:34 <kmc> MiggyX, you might find this article enlightening even if you don't know Haskell: http://haskell.org/haskellwiki/Introduction_to_IO
21:25:49 <MiggyX> I would have thought that a function that adds two integers together could be considered pure - but one that calculates the difference between a time and the current time (assuming the only input is the time to compare with), would be consider impure as if you pass in the same parameters, you will get a different answer
21:26:04 <kmc> it wouldn't be considered "impure"
21:26:08 <kmc> it would be considered "not a function"
21:26:37 <kmc> you can make a function f such that (f t) evaluates to an "IO recipe" which compares the current clock time to t
21:26:42 <kmc> that recipe is a value
21:26:48 <kmc> you can execute that recipe more than one and get different results
21:26:55 <kmc> evaluation is not the same as execution
21:27:33 <djahandarie> Doesn't help that their names are so close
21:27:34 <copumpkin> MiggyX: think of IO as strings containing python code that gets built up by our pure functions. Then someone takes those strings and actually runs them, producing side effects
21:28:29 <MiggyX> ah right - so no language actually has this concept of pure and impure ?
21:28:39 <kmc> MiggyX, nope, we didn't say no language has it
21:28:51 <MiggyX> is there a term to better describe what I was suggesting?
21:29:04 <kmc> Disciple is a haskell dialect of sorts with true effect typing
21:29:17 <kmc> but anyway, i feel we're not communicating how Haskell works
21:29:22 <kmc> it separates pure computation from IO
21:29:32 <kmc> but this is not about separating one kind of function from another
21:29:40 <Axman6> i'm really interested to see how deciple turns out
21:29:54 <kmc> it's more a property of the language's runtime semantics than a property of its type system
21:29:56 <MiggyX> kmc: It's a different way of acheiving a similar goal though isn't it?
21:30:00 <kmc> yes
21:30:15 <kmc> in fact you could have a dynamically typed language which separates effects in the same way
21:31:53 <MiggyX> At a stretch, could you say that functions that use IO recipes, would be difficult to test properly using stubs and simple test cases?
21:32:27 <MiggyX> or at least perhaps as an indicator of
21:32:34 <kmc> what you're getting at is that IO is harder to test than pure computation
21:32:35 <kmc> and i agree
21:32:54 <dmwit> There's MonadPrompt or so, which is supposed to help with this kind of thing.
21:33:03 <kmc> but functions don't really "use" IO recipes
21:33:09 <kmc> not any more than they use numbers or strings
21:33:15 <kmc> IO recipes are data
21:33:22 <kmc> they're values you can pass around and manipulate
21:33:27 <copumpkin> dmwit: IOSpec?
21:33:31 <kmc> they don't have magical effecting-the-outside-world powers
21:33:57 <copumpkin> oh, MonadPrompt as a way to redesign some of your stateful stuff
21:34:05 <kmc> no more than the string "get me a sandwich" has the magical power to get me a sandwich
21:34:17 <dmwit> copumpkin: Maybe. What I had in mind was the tool for separating the "monad commands" and "monad interpretation"... is that MonadPrompt?
21:34:40 <MiggyX> I guess I was thinking of a more formal way to define some code or component (doesn't have to be Haskell) that would be difficult to test properly with stubbing, and should use other methods.
21:34:46 <copumpkin> MonadPrompt is basically a fancy free monad, with support for writing interpreters. So that sounds about right
21:34:56 <copumpkin> it's very similar to apfelmus' operational monad
21:34:57 <dmwit> yeah, that's what I was thinking of, then
21:34:59 <MiggyX> For example an app that requires a market price feed, is a nightmare to test - you really need a price feed to test with
21:35:06 <dmwit> IOSpec sounds interesting, too, of course
21:35:54 <copumpkin> MiggyX: what dmwit is suggesting is that you break your interaction with that market feed into meta-commands, and then write an interpreter that actually contacts a real server
21:35:56 <copumpkin> for production
21:36:15 <copumpkin> but another interpreter that talks to static data, predictably, for testing
21:36:21 <copumpkin> as far as I can see, anyway :)
21:36:41 <dmwit> yes
21:36:56 <MiggyX> I was thinking of researching the viability of being able to simulate a price feed with reasonable accuracy
21:37:12 <dmwit> I would have said the same thing myself but I'm on a qwerty keyboard and my typing speed is really low as a result... =/
21:37:13 <MiggyX> so that you wouldn't have to use static data as such
21:37:39 <copumpkin> MiggyX: well, you could write an arbitrary interpreter for your metalanguage 
21:37:48 <copumpkin> presumably for testing you'd want something you can model simply
21:38:29 <MiggyX> but you can only write tests for error conditions that you anticipate
21:38:42 <MiggyX> which means you might right an awesome test suite, everything passes and then falls flat on its face when deployed
21:39:40 <copumpkin> that's a separate issue
21:39:53 <copumpkin> we're just talking about how you'd go about testing some typically stateful behavior
21:40:02 <copumpkin> not what you'd actually put in the tests
21:40:19 <copumpkin> if your tests aren't testing what you care about, then you need better tests
21:40:33 <MiggyX> I'm suggesting that you might not know what to test for
21:41:05 <dmwit> This is undoubtedly true.
21:41:07 <dmwit> But so what?
21:41:16 <dmwit> That's true in every language.
21:41:47 <copumpkin> MiggyX: well, you can make the same free monad in agda, and then specify its behavior formally in terms of a virtual machine
21:42:25 <kmc> stubbing a program that reads market data over the network seems fairly easy
21:42:27 <MiggyX> Yeah, I'm not trying to say this all about Haskell. The reason I came here asking questions is because I'm very interested in Haskell as a language and mistakenly thought it used pure and impure functions. I was hoping to extend that idea to cover other languages and constructs - those that use external resources and therefore could benefit from a different form of testing
21:42:36 <kmc> just play back market data from another machine
21:42:56 <kmc> historical or generated
21:43:12 <MiggyX> kmc: For the feed itself that's reasonably easy but not if you want to test order execution against it :)
21:43:16 <kmc> yeah
21:43:22 <kmc> then you need an exchange simulator
21:43:23 <Twey> MiggyX: It sort of does, but the difference between (pure) functions and impure procedures is so pronounced as to be on an entirely different level.
21:43:27 <kmc> but again, you need that either way
21:43:32 <MiggyX> The best systems for testing, are those that are effetctively identical to the real thing 
21:43:39 <MiggyX> but creating somrthing that is close to the real thing is difficult
21:43:43 <MiggyX> which is what I want to look into
21:43:50 <copumpkin> MiggyX: we isolate impurity, and have the facilities to make specific subsets of impurity more formally modeled
21:45:12 <kmc> MiggyX, i think what Haskell does is *closer* to what you want than an idea of "pure vs impure functions"
21:45:19 <dmwit> If only agda were fast...
21:45:23 <Twey> .ie
21:45:24 <kmc> because in Haskell you functionally build descriptions of IO without doing the IO
21:45:30 <kmc> and then hand it off to another component to be performed
21:45:34 <copumpkin> dmwit: someone's working on it :)
21:45:39 <kmc> and that seems conducive to testing
21:45:48 <kmc> because you can take that IO-description and do something else with it
21:45:50 <MiggyX> kmc: It does sound more advanced :)
21:46:09 <dmwit> Well, Agda's producers are damn fast, anyway. Every release has like 10 new major type system features!!
21:46:13 <kmc> but that's not how most IO is actually tested in Haskell
21:46:19 <kmc> but i think the idea is good anyway
21:46:38 <copumpkin> dmwit: I mean, working specifically on a decent compiler for it :P
21:46:50 <djahandarie> An impure function is an oxymoron.
21:46:55 <copumpkin> for those two people who actually run agda code
21:47:30 <MiggyX> djahandarie: as I said, pure / impure was just a way to describe code that deals with data from the outside world and therefore might need a better form of testing
21:47:39 <MiggyX> ideally a way to easily and quickly define some sort of simulator
21:47:44 <MiggyX> as opposed to simple stubbing
21:48:07 <Axman6> "Agda's type checker is now written completely in the type system. It first typechecks itself before typechecking your program to ensure it hasn't gone insane"
21:48:09 <MiggyX> again, this is not Haskell specific - I would love to do it in Haskell, but as my questions have already demonstrated, I don't know enough :)
21:48:37 <dmwit> hm... would you bother believing a consistency proof in the system your proving consistent?
21:50:19 <MiggyX> Of course the next question, is whether such a system would be useful :)
21:50:32 <Twey> Axman6: Haha
21:52:40 <MiggyX> bbiab
21:52:57 <Twey> dmwit: We do it with logic all the time
21:55:02 <dmwit> Twey: Normally no.
21:55:23 <dmwit> Twey: Normally you prove consistency in a different system than the one you're proving things about.
21:58:02 <ddarius> Normally you just hope that the logic you're using is consistent.
22:23:00 <xpika> the cairo package is not loading for me  /opt/local/lib/libcairo.dylib: mach-o, but wrong architecture)
22:23:34 <xpika> do i need to reinstall cairo with some specific variant?
22:25:55 <dmwit> Did you build cairo yourself?
22:26:13 <dmwit> If so, I'm a little puzzled how you got a library for the wrong architecture.
22:28:06 <xpika> i have installed cairo via ports
22:29:47 <dmwit> Could you give the exact command you're trying to run, along with the exact error you get?
22:30:34 <xpika> im compiling yi
22:35:58 <xpika> http://hpaste.org/41674/cairo_fail_on_yi
22:41:38 <dmwit> Can you build cairo as a static library, instead?
22:41:43 <lpsmith> Out of curiousity,  does anybody have a quad core machine with GHC-6.12.3 and GHC-7.0.1 handy?
22:44:39 <xpika> ok , fixed it just needed to compile cairo via the universal variant
23:25:15 <abhibtcs08> hii
23:25:32 <abhibtcs08> is anyone there to teach me haskell?
23:25:45 * hackagebot shell-escape 0.1.1 - Shell escaping library.  http://hackage.haskell.org/package/shell-escape-0.1.1 (JasonDusek)
23:26:53 <abhibtcs08> where is the use of haskell in today's world?
23:27:42 <ksf> about anything you care to code up.
23:28:02 <abhibtcs08> applications as examples?
23:28:24 <ksf> haskell is general-purpose, supports very high level abstractions as well as systems programming
23:28:41 <ksf> http://snapframework.com/
23:28:49 <abhibtcs08> can we make any type of softwares using haskell?
23:28:54 <ksf> some people are using it to develop commercial games
23:29:03 <ksf> generally speaking, yes.
23:29:15 <writer> for mathematicians and non-mathematicians...
23:29:57 <abhibtcs08> can you give me any graphics application as an example made in haskell?
23:30:25 <ksf> http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
23:30:40 <abhibtcs08> what is hugs?
23:31:50 <writer> http://www.haskell.org/haskellwiki/Implementations#Hugs
23:32:03 <ksf> hugs is an implementation I wouldn't use except if I wanted to embed haskell as a scripting language.
23:32:26 <ksf> it's very portable and quite light-weight, but not trendemously fast, and ghc has vastly more features.
23:33:01 <abhibtcs08> so its better to use ghc than hugs?
23:33:13 <ksf> yep.
23:33:35 <ksf> ghc is the recommended default compiler
23:33:36 <abhibtcs08> that mean direc download haskell platform
23:33:57 <ksf> ...which includes ghc, yes.
23:34:04 <abhibtcs08> but in which way hugs lack behind than ghc?
23:34:38 <ksf> first off it's an interpreter, not a compiler
23:34:46 <ksf> ...and it's not very actively developed, any more.
23:35:17 <abhibtcs08> is it true, haskell can do any work of object-oriented languages?
23:35:57 <ksf> sure, haskell is turing-complete. one usually doesn't write code that could be considered object-oriented, though.
23:36:30 <abhibtcs08> wat's d scope of haskell in todays software market?
23:37:01 <ksf> not impressive enough to convince your boss without further arguing.
23:37:12 <ksf> ...but it's coming quite nicely.
23:37:44 <abhibtcs08> actually i want to make a simple graphics logo design using haskell, can you please suggest me some idea?
23:38:03 <abhibtcs08> please if you can help me?
23:38:06 <ksf> yes, use inkscape instead.
23:38:21 <abhibtcs08> wat's d inkscape?
23:38:39 <ddarius> ksf: That's nowhere near as fun as implementing a Bezier curve library from scratch.
23:38:52 <ksf> http://www.inkscape.org
23:38:54 <abhibtcs08> ?????
23:39:39 <djahandarie> Who needs Bezier curves when you have Bezier surfaces?
23:39:53 <ksf> well, you just asked what kind of jet engine you should use to drive shopping, and I think the best jet engine is a bike.
23:39:54 <abhibtcs08> ok
23:39:57 <ddarius> djahandarie: For a logo?
23:40:10 <ddarius> I guess one could do something like Silverlight's logo.
23:40:11 <abhibtcs08> yup
23:40:17 <ddarius> Subdivision surfaces would be good for that.
23:40:41 <abhibtcs08> how?
23:40:53 <abhibtcs08> please show me d way
23:40:54 <ksf> if you want to go 3d, use blender instead.
23:41:00 <djahandarie> 4 spatial dimension logos are the new bomb, haven't you heard ddarius?
23:41:18 <abhibtcs08> nope
23:41:21 <ddarius> djahandarie: I don't keep up with such things.
23:42:22 <geheimdienst> these sunday-early-morning discussions in here are not for the faint of heart
23:42:50 <djahandarie> Oh god, it's Sunday already?
23:43:04 <djahandarie> Man, it's nearly 3am, where have I been...
23:43:25 <geheimdienst> in all 4 of my spatial dimensions, it is
23:43:29 <abhibtcs08> can you give me the source code in haskell to draw a java "duke" picture?
23:43:44 <writer> lol
23:44:03 <abhibtcs08> ???????
23:44:35 <lars9> abhibtcs08: yes, but what is java?
23:44:48 <ksf> an island.
23:44:57 <ksf> they've got exellent coffee there
23:45:08 <lars9> ksf: the cat shit coffee?
23:45:45 <djahandarie> I was reading a paper but I don't think it was for the past three hours
23:45:47 <ksf> no that's somewhere in the americas iirc
23:45:49 <abhibtcs08> nope "duke" the mascot of java programming language
23:46:31 <ksf> 1) download http://en.wikipedia.org/wiki/File:Duke.svg  , create a cairo surface with haskell, let cairo draw the svg.
23:46:35 <lars9> ksf: cat-poo-coffee: http://en.wikipedia.org/wiki/Kopi_Luwak
23:46:51 <ksf> that hasn't much to do with /programming/, though.
23:47:07 <djahandarie> This feels sufficiently off-topic for me to say "-blah please"
23:47:10 <ksf> oh. indeed, java.
23:48:14 <abhibtcs08> yup
23:48:48 <JoshTriplett> When using Applicative, how can I use <|> but ignore a return type, such as with (string "{{" <|> eof) where I don't actually need the string "{{".
23:48:48 <JoshTriplett> ?
23:48:53 <djahandarie> Has anyone else here read "Generative Type Abstraction and Type-level Computation (Extended Version)" by simonpj et al?
23:49:00 <JoshTriplett> I found *>, but I don't see a |> anywhere. ;)
23:49:08 <ksf> JoshTriplett, you can't, <|> is Alternative.
23:49:22 <JoshTriplett> ksf: :)
23:49:38 <JoshTriplett> ksf: OK, "when using the Applicative/Alternative/etc family of stuff"...
23:49:42 <ksf> anyway, () <$ ( whatever )
23:50:10 <ksf> that is, just make the string and eof types match and then use <* as usual.
23:50:34 <JoshTriplett> ksf: OK, (() <$ string "{{") certainly more succinct than (do _ <- string "{{" ; return ())...
23:50:59 <ksf> ...you can't ignore one part of the applicative just like that because it might be used, after all.
23:51:01 <JoshTriplett> Though not exactly appealing.
23:51:04 <JoshTriplett> ksf: Sure.
23:51:04 <ksf> same thing as with ifthenelse.
23:51:24 <JoshTriplett> ksf: Any more succinct name for the function (()<$)?
23:51:35 <JoshTriplett> By which I mean, does it already exist?
23:51:40 <ksf> well, you might call it ignore or something.
23:51:41 <c_wraith> fmap (const ())
23:52:27 <JoshTriplett> ksf: Good point, I could give (() <$) . string a name. :)
23:52:29 <JoshTriplett> ksf: Thanks!
23:52:47 <ksf> hmm. x <_|_> y = ignore x <|> ignore y
23:53:25 <JoshTriplett> ksf: Really tempted to call that | , by analogy with <* and *>. :)
23:53:27 <ksf> JoshTriplett, try string_
23:53:38 <JoshTriplett> ksf: Oh, perfect.  Thanks!
23:53:54 <dibblego> what is ignore?
23:54:10 <ksf> :t (()<$)
23:54:16 <ksf> @bot
23:54:19 <ksf> gree
23:56:05 <ddarius> djahandarie: I started reading it but haven't got back to it.
23:56:22 <djahandarie> Same here, just finished it today
23:57:10 <JoshTriplett> ksf: A related question: the precedence of *> seems to make (X <$> foo *> bar) parse as ((X <$> foo) *> bar) ; have I misused the syntax somehow?
23:57:25 <djahandarie> Pretty nice solution. I was curious if they have even scratched the surface into coding any of this
23:57:36 <JoshTriplett> ksf: When using applicative, having to explicitly write parentheses always makes me feel like I've missed something. :)
23:58:20 <ksf> JoshTriplett, yep I find that to be annoying, too.
23:58:58 <JoshTriplett> ksf: Any particular suggestion?
23:59:03 <JoshTriplett> Or should I just get over it? :)
23:59:18 <ksf> make a <$$> operator with lower precedence
23:59:29 <ksf> <$> might still have its uses.
23:59:31 <JoshTriplett> Heh.  I think I'll pass. :)
23:59:43 <ksf> why it's easy.
