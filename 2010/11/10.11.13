00:01:58 <lars9> Saizan: i dont quite understand how it works, so I dont know how to convert my type an instance of HasTrie
00:07:27 <Saizan> the basic idea is that most ADTs are isomorphic to some combination of Either, (,) and recursion, and that the type of the trie can then be calculated compositionally by recursing over that formulation
00:07:58 <Saizan> for the specific rules see the instances in MemoTrie and Hinze's paper linked in the post
00:08:11 <Saizan> but they are also fairly intuitive
00:13:22 <ksf> all adts can be built from sum, product and recursion.
00:13:32 <ksf> otherwise they wouldn't be adts
00:13:59 <ddarius> data F a = F (Int -> a)
00:14:18 <Cale> http://www.flickr.com/photos/cgibbard/5170812041/in/pool-magnetspheres/#/photos/cgibbard/5170812041/in/pool-1553182@N22/lightbox/ -- This will be on the final exam. ;)
00:14:31 <ddarius> newtype H a b = H (H b a -> b)
00:14:56 <ddarius> Cale: Gee, I hope St. Peter passes me.
00:15:59 <Cale> :)
00:16:27 <Cale> It's made from 2160 magnetic spheres
00:20:16 <lars9> ksf: what is ADT?
00:21:18 <ksf> abstract data type
00:21:58 <ksf> a thing made out of sum (as in Foo = Bar | Baz) and product (as in Foo = Foo Bar Baz) things.
00:22:06 <ddarius> Umm... "algebraic" data type in the context you are considering.
00:22:08 <ksf> plus recursion plus type variables
00:22:12 <ksf> yeah.
00:22:29 <ddarius> (though I prefer to reserve ADT for "abstract data type")
00:23:51 <ksf> ...sum because the total numbers of inhabitants of Either Word8 Word32 is 2^8+2^32, for (Word8, Word32) it's the product.
00:25:39 <ksf> hmmm I still don't seem to know what I'm doing here.
00:26:39 <ksf> as it stands I seem uncapable of deciding whether to add something to iteratees, or sandwich them between something.
00:28:26 <ksf> sandwiching seems easy because they're Yet Another Monad Transformer, but visualising the implementation of each part is confusing as hell.
00:29:12 <ksf> ...because the interplay between all parts is so complex, iteratees themselves not being the most semantically unambigious thing ever.
00:34:54 * ddarius wants to read some vintage Heinlein.
00:35:06 <Krimpet> Hello folks, I'm trying to figure out a "couldn't match expected type error" I'm getting. Compiling the following code:
00:35:33 <Krimpet> http://hpaste.org/41416/type_errors - I get the following error - http://hpaste.org/41417/type_errors
00:35:36 <funkyjunkyrobot> having some trouble with comparing lists
00:36:26 <funkyjunkyrobot> i can only compare 2 items at a time with a comparison statement
00:36:55 <funkyjunkyrobot> sorry, need to re-think my question
00:37:07 <lars9> omg, Prelude Data.Map> fromList [(Nothing ,1)]
00:37:22 <lars9> map is great...
00:37:30 <ddarius> Actually, there is an interesting theory of k-compares.
00:38:05 <Krimpet> Anyone know what could be wrong?
00:38:47 <Saizan> Krimpet: the signature of stateAt doesn't mean what you think it means
00:39:15 <Krimpet> I'll admit, I'm still trying to wrap my head around type classes.
00:39:35 <Saizan> this is basic parametric polymorphism
00:39:51 <Saizan> well, typeclasses obscure it a little
00:39:56 <funkyjunkyrobot> lars9 i don't understand what u are telling me
00:40:41 <Saizan> Krimpet: anyhow, the problem is that the 'k' and 'a' in "instance (Ord k, State a) => Generation (Map.Map k a) where" won't be assumed to be equal to the 'k' and 'a' in the type of stateAt above
00:41:32 <funkyjunkyrobot> :t fromList
00:41:32 <lambdabot> forall a (m :: * -> *). (MonadRandom m) => [(a, Rational)] -> m a
00:41:59 <Saizan> Krimpet: so you get that the implementation of stateAt you've to provide for the instance has type "stateAt :: (Ork k1 , State a1, Ord k2, State a2) => (Map k1 a1) -> k2 -> a2"
00:43:07 <Krimpet> Saizan, ah. Is there a way to ensure k and a are equal in both places?
00:43:29 <Saizan> you need to change the definition of Generation
00:44:11 <Saizan> you could write "class Generation g k a where ..."
00:44:24 <Saizan> and then "instance Generation (Map k a) k a where .."
00:44:35 <Saizan> using MultiParamTypeClasses
00:45:00 <Krimpet> Ah, OK. I had tried that, but I wasn't sure if I was going about it the right way since MultiParamTypeClasses isn't standard.
00:45:28 <Krimpet> If it's the best way to do it, though, I'll go back to MultiParamTypeClasses. Thanks for the help :)
00:45:49 <Saizan> well, there's always the rule of thumb that you shuold think twice before you decide you need a typeclass at all
00:47:41 <Saizan> Krimpet: another way would be to use TypeFamilies
00:47:46 <Krimpet> I'm pretty sure a type class is what I want here. I'm building a generic library for cellular automata; I'd like to allow individual automaton algorithms to provide other representations of a generation if it's more efficient.
00:49:17 <funkyjunkyrobot> how would one sort a list of lists of Ints such as [ [1,1,1],[1,2,3],[1,2,1] ] and choose the sort order  [a1,a2,a3]  by either checking a1, a2, or a3 . keep in mind i'm a total noob and don't understand very complex code
00:50:06 <ksf> > sort [ [1,1,1],[1,2,3],[1,2,1] ] 
00:50:07 <lambdabot>   [[1,1,1],[1,2,1],[1,2,3]]
00:50:15 <funkyjunkyrobot> i have an insertion sort working, but i want to change which element of the sort list it is checking
00:50:23 <funkyjunkyrobot> of the sub list i mean
00:50:30 <ksf> > map sort [ [1,1,1],[1,2,3],[1,2,1] ] 
00:50:31 <lambdabot>   [[1,1,1],[1,2,3],[1,1,2]]
00:50:33 <funkyjunkyrobot> i know i can do that.... :9
00:50:45 <funkyjunkyrobot> map sort?
00:50:48 <ksf> :t map
00:50:49 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:51:04 <ksf> :t map sort
00:51:05 <lambdabot> forall a. (Ord a) => [[a]] -> [[a]]
00:51:43 <funkyjunkyrobot> so what does that mean forall a. (Ord a) =>
00:52:00 <ksf> ignore the forall a. part
00:52:05 <ksf> :t sort
00:52:06 <lambdabot> forall a. (Ord a) => [a] -> [a]
00:52:06 <funkyjunkyrobot> A is of type Ord meaning it can be orderd right?
00:52:12 <ksf> yep.
00:52:14 <funkyjunkyrobot> k
00:52:18 <ksf> :t cmp
00:52:18 <Saizan> Ord is not a type
00:52:18 <lambdabot> Not in scope: `cmp'
00:52:23 <ksf> :t compare
00:52:24 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
00:52:33 <ksf> > 1 `compare` 2
00:52:34 <lambdabot>   LT
00:52:45 <ksf> > [1,1] `compare` [2]
00:52:46 <lambdabot>   LT
00:52:46 <funkyjunkyrobot> k, i am with u
00:53:31 <ksf> > [1,2] `compare` [2]
00:53:32 <lambdabot>   LT
00:53:50 <Saizan> funkyjunkyrobot: the simples way is make your sort function take an explicit (a -> a -> Ordering) function rather than having (Ord a) => in its type
00:53:55 <funkyjunkyrobot> i want to make my own compare that lets me take say if [1,1] were represented as [a1,a2] i want to say check a2
00:54:08 <Saizan> funkyjunkyrobot: so by changing that function you can decide which position of the lists matter
00:54:30 <ksf> you could also use 
00:54:32 <ksf> :t sortBy
00:54:33 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
00:54:45 <Saizan> ?type let compareNth n xs ys = compare (xs !! n) (ys !! n) in compareNth
00:54:46 <lambdabot> forall a. (Ord a) => Int -> [a] -> [a] -> Ordering
00:55:09 <Saizan> ?type let compareNth n xs ys = compare (xs !! n) (ys !! n) in sortBy (compareNth 0) [ [1,1,1],[1,2,3],[1,2,1] ]
00:55:10 <lambdabot> forall a. (Ord a, Num a) => [[a]]
00:55:13 <Saizan> > let compareNth n xs ys = compare (xs !! n) (ys !! n) in sortBy (compareNth 0) [ [1,1,1],[1,2,3],[1,2,1] ]
00:55:14 <lambdabot>   [[1,1,1],[1,2,3],[1,2,1]]
00:55:18 <Saizan> > let compareNth n xs ys = compare (xs !! n) (ys !! n) in sortBy (compareNth 1) [ [1,1,1],[1,2,3],[1,2,1] ]
00:55:19 <lambdabot>   [[1,1,1],[1,2,3],[1,2,1]]
00:55:25 <Saizan> > let compareNth n xs ys = compare (xs !! n) (ys !! n) in sortBy (compareNth 2) [ [1,1,1],[1,2,3],[1,2,1] ]
00:55:26 <lambdabot>   [[1,1,1],[1,2,1],[1,2,3]]
00:56:01 <ksf> > let compareNth n = (!!n) . zipWith compare in sortBy (compareNth 2) [ [1,1,1],[1,2,3],[1,2,1] ]
00:56:01 <lambdabot>   Couldn't match expected type `[a]'
00:56:02 <lambdabot>         against inferred type `[a1] -> [...
00:56:18 <ksf> :t zipWith
00:56:19 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
00:56:42 <ksf> :t (!!1) . zipWith compare
00:56:43 <lambdabot>     Couldn't match expected type `[a]'
00:56:43 <lambdabot>            against inferred type `[a1] -> [Ordering]'
00:56:43 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
00:56:59 <Saizan> :t ((!!1) .) . zipWith compare
00:57:00 <lambdabot> forall a. (Ord a) => [a] -> [a] -> Ordering
00:57:03 <ksf> :t \n -> (!!n) . zipWith compare
00:57:04 <lambdabot>     Couldn't match expected type `[a]'
00:57:04 <lambdabot>            against inferred type `[a1] -> [Ordering]'
00:57:04 <lambdabot>     Probable cause: `zipWith' is applied to too few arguments
00:57:26 <funkyjunkyrobot> ok. well i'll keep trying
00:57:29 <ksf> that shouldn't confuse me.
00:57:46 <ksf> ah doh.
00:57:52 <Saizan> funkyjunkyrobot: what's still obscure for you?
00:58:13 <ksf> > let compareNth n = (!!n) .: zipWith compare in sortBy (compareNth 2) [ [1,1,1],[1,2,3],[1,2,1] ]
00:58:13 <lambdabot>   Not in scope: `.:'
00:58:38 <funkyjunkyrobot> well, it's just alot for me to process at once, i'm very much not used to this kind of syntax
00:59:02 <funkyjunkyrobot> i get so many functions thrown at me and it takes me a while to realize what one is and by then i've got 10 more to look at :(
00:59:29 <Saizan> well, i've just tried it with various inputs
00:59:29 <funkyjunkyrobot> i don't know how to define my comparison
00:59:37 <funkyjunkyrobot> ahh
00:59:54 <Saizan> the comparison is "compareNth n xs ys = compare (xs !! n) (ys !! n)"
01:00:12 <funkyjunkyrobot> ok, let me try something
01:00:12 <Saizan> (ksf was writing the same thing a little differently)
01:00:48 <funkyjunkyrobot> i want to try to get that to work with my insertion sort now
01:01:11 <funkyjunkyrobot> i'll put some work into it and come back. i do apreciate your time by the way :)
01:02:45 <Saizan> np
01:03:12 <funkyjunkyrobot> so i'm writing this into a .hs file. and i can't get statements like that to work
01:03:17 <Saizan> come bak with the code of your sort if you get stuck :)
01:03:19 <funkyjunkyrobot> using ghci
01:03:26 <Saizan> ah
01:03:33 <Saizan> statements like which?
01:03:54 <Saizan> "compareNth n xs ys = compare (xs !! n) (ys !! n)" should be fine in a .hs file
01:04:11 <funkyjunkyrobot> compareNth n xs ys = compare (xs !! n) (ys !! n)
01:04:25 <Saizan> what error are you getting?
01:04:44 <funkyjunkyrobot> parse error (possibly incorrect indentation)
01:04:49 <funkyjunkyrobot> not very helpful
01:05:07 <funkyjunkyrobot> and it's the line right after that statement is placed in and it's the last line in the document
01:05:32 <Saizan> mh, that might mean that you've some non-closed parenthesis or wrong use of layout above
01:06:19 <funkyjunkyrobot> when i comment out the statement it loads
01:06:28 <Saizan> can you paste the source?
01:06:41 <Axman6> the complete source
01:07:00 <funkyjunkyrobot> sure, all of it.
01:07:06 <funkyjunkyrobot> it's got alot....
01:07:15 <funkyjunkyrobot> it's an assigment so i've made alot of functions
01:07:25 <Saizan> it's ok, use a pastebin though
01:07:26 <funkyjunkyrobot> but sure, just look to the bottom for the sort stuff
01:08:21 <funkyjunkyrobot> http://hpaste.org/41418/sort
01:10:08 <funkyjunkyrobot> so i should be able to call the sort with my own custom predicates which would be these orderings I want to write
01:11:13 <funkyjunkyrobot> i have the statement in question commented out i think i should uncomment it and re-bin it to see if it gives me any usefull feedback
01:12:02 <Saizan> that file loads fine after uncommenting compareNth here
01:12:13 <Saizan> if you're on windows maybe you need to add a newline at the end
01:13:09 <funkyjunkyrobot> i'm on os x
01:14:00 <funkyjunkyrobot> new line did it
01:14:03 <funkyjunkyrobot> wow
01:14:11 <Saizan> anyhow, since your insertion_sort already takes a (a -> a -> Bool) then you might want to define "leqNth n = (xs !! n) <= (ys !! n)" instead of compareNth
01:14:33 <Saizan> so that you can just use "insertion_sort (leqNth ..) ..."
01:14:59 <funkyjunkyrobot> what is leq short for?
01:15:07 <Saizan> less or equal
01:15:30 <funkyjunkyrobot> k
01:15:57 <funkyjunkyrobot> this is starting to make way more sense now
01:17:01 <funkyjunkyrobot> i'm still not seeing the whole picture though. give me one sec to explain
01:18:19 <funkyjunkyrobot> so if i can get it to compare these specific elements that is all well and good, but when they are equal i want it to then check another element . so if  i'm using n=1 and it finds them to be equal, i want it to then check n=3 to see if that is leq.
01:18:41 <funkyjunkyrobot> can i do that w/ if statements?
01:18:54 <funkyjunkyrobot> i don't see it fitting in to the sort's recursive calls
01:19:41 <Saizan> from 1 you want to jump to 3, rather than 2?
01:19:42 <funkyjunkyrobot> possibly in my insert then
01:20:08 <Saizan> anyhow it still is just a matter of picking an appropriate (a -> a -> Bool) function
01:20:11 <funkyjunkyrobot> yeah, well do u want me to post u a link to the assignment, so u can at least know what i am trying to do? 
01:20:17 <funkyjunkyrobot> yeah
01:20:25 <Saizan> well [Int] -> [Int] -> Bool in this case
01:20:25 <funkyjunkyrobot> so i can pry have more cases in my insert
01:20:38 <Saizan> you don't need to change insert
01:20:48 <funkyjunkyrobot> k
01:22:11 <Saizan> i'll give you one example
01:23:00 <Saizan> p xs ys = compare (xs !! 0) (ys !! 0) of LT -> LT; EQ -> (xs !! 2) <= (ys !! 2); GT -> GT
01:23:43 <Saizan> that p compares the first element, and in case it's equal for both lists it'll compare the third
01:24:23 <Saizan> if you want to not stop at the third but rather continue you'll have to use recursion
01:24:46 <ksf> case
01:25:13 <Saizan> also, make sure you handle the case where the lists are not long enough
01:25:14 <funkyjunkyrobot> ok, well i will have to be able to use different orders up to 3 items
01:25:30 <Saizan> (unless you know they will always be of some size)
01:25:44 <funkyjunkyrobot> yeah the sub lists always have 3 numbers
01:26:02 <funkyjunkyrobot> and then i get a list of chars to tell me my sort oder
01:26:08 <funkyjunkyrobot> it can have 1 to 3 chars in it
01:26:14 <funkyjunkyrobot> http://cse.unl.edu/~jsukup/3v7.pdf
01:26:30 <funkyjunkyrobot> this is the assignment and i'm on number 4, that explains what i am really trying to do
01:27:03 <funkyjunkyrobot> not that i want u to directly answer it or anything, i just really want it to be clear what i'm doing.
01:27:39 <lars9> ehhh... still can not read xmonad core's source code, how much more do i need to learn..
01:28:03 <ksf> first. you need the guided tour.
01:28:19 <ksf> http://www.haskell.org/haskellwiki/Xmonad/Guided_tour_of_the_xmonad_source
01:28:32 <lars9> ksf: omg, there is a guide
01:28:38 <lars9> ksf: thanks
01:29:39 <Saizan> funkyjunkyrobot: it sounds like you want to define an "interpret :: [Char] -> ([Int] -> [Int] -> Bool)"
01:30:52 <ksf> hmmm, xmonad.
01:31:01 <Saizan> though it might be easier to define [Char] -> ([Int] -> [Int] -> Ordering) and then convert that Ordering to Bool
01:31:19 <ksf> there's a buggering semantic gap when it comes to floaties and xinerama
01:31:53 <ksf> well, actually bluetile is the culprit.
01:32:57 <lars9> ksf: i started to use xmonad before learning haskell
01:33:30 <funkyjunkyrobot> why would i need the bool?
01:33:50 <funkyjunkyrobot> i'd want the char to go to an int so i can plug it into the n as far as i can tell this far
01:34:06 <ksf> actually, it's bluetile and xmonad being incompatible. bluetile doesn't know of floaties in tabbed layouts, either everything floats or nothing
01:34:25 <ksf> from the user's pov, that's very clean, semantically.
01:34:40 <Saizan> funkyjunkyrobot: you need a ([Int] -> [Int] -> Bool) to pass to your insertion_sort
01:35:02 <funkyjunkyrobot> ahh
01:35:13 <funkyjunkyrobot> ok, so it would be the comparison
01:35:20 <funkyjunkyrobot> brilliant
01:35:43 <Saizan> higher order programming ftw
01:35:49 <funkyjunkyrobot> w00t
01:36:09 <ksf> lars9, other people attempt to re-write xmonad because they judge it to be crippled by haskell...
01:36:22 <funkyjunkyrobot> man, this is great. i just hope i can get it coded in time
01:36:56 <funkyjunkyrobot> i have 6 hours :)
01:38:04 <lars9> ksf: someone is rewriting xmonad?
01:39:18 <ksf> lars9, http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/01#xmonad_part1_model   http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/17#xmonad_part1b_zipper
01:39:31 <ksf> I've heard about it, but didn't find a link yet.
01:40:01 <lars9> ksf: oh i read that two posts a year ago. can not understand them. now i can understand
01:40:09 <lars9> *could
01:40:11 <Saizan> funkyjunkyrobot: hoping i'm not completely misundertanding the assignment :)
01:40:45 <Entroacceptor> ksf: which project attempts to rewrite xmonad?
01:40:45 <lars9> ksf: xmonad is incredibly stable, never saw a bug:)
01:40:47 <funkyjunkyrobot> can be any worse than me
01:42:16 <funkyjunkyrobot> so when i'm making this interpret function it is returning a function similar to the one u showed me as an example. is it possible to have 3 cases in there or just the 2 without recursion?
01:43:54 <Saizan> funkyjunkyrobot: sure, just add another case expression
01:43:55 <funkyjunkyrobot> defenatly only 2. hmm
01:44:12 <funkyjunkyrobot> ok.
01:44:20 <ksf> well, it was mentioned en passe on reddit.
01:44:58 <ksf> could be the confused babbling of one of those bloggers the internet seems to spawn amass lately.
01:45:44 <Saizan> funkyjunkyrobot: you can also have a case over multiple things at once, just pack them insto a tuple
01:48:20 <funkyjunkyrobot> i don't know enough to do these things.
01:48:39 <funkyjunkyrobot> writing the interpret function is not clear to me yet
01:48:52 <funkyjunkyrobot> i have to some how make sense of the chars first
01:49:00 <funkyjunkyrobot> can i define the chars to ints?
01:49:14 <funkyjunkyrobot> say let s=1
01:49:31 <funkyjunkyrobot> and when it is red from the char list it will be interpreted as 1?
01:51:37 <funkyjunkyrobot> so if i start with what you have said
01:51:40 <funkyjunkyrobot> interpret :: [Char] -> ([Int] -> [Int] -> Bool)
01:51:40 <funkyjunkyrobot> interpret [Char] |
01:52:18 <Jonno_FTW> isn't [Char] == String ?
01:52:50 <funkyjunkyrobot> i duno
01:53:08 <funkyjunkyrobot> a string is a [Char] yes
01:53:15 <funkyjunkyrobot> can be traversed as such
01:53:20 <funkyjunkyrobot> head and tail and all
01:54:14 <Saizan> funkyjunkyrobot: you could define a function convert :: Char -> Int; convert 's' = 1; ...
01:54:26 <lars9> ksf: do you use xmonad?
01:54:45 <lars9> ksf: i use it, but i will like it better if it supports containers
01:55:04 <Saizan> funkyjunkyrobot: and then apply "map convert :: [Char] -> [Int]" inside interpret
01:55:42 <funkyjunkyrobot> makes sense
01:56:20 <ksf> containers?
01:56:50 <thom_logn> functors?
01:57:15 <lars9> ksf: the screen is splited into several containers, and windows are assigned into containers
01:58:01 <ksf> well, I'm content with layouts and xinerama
01:58:20 <lars9> ksf: then i can split screen into two containers, and move windows between them.
01:58:45 <lars9> ksf: current TwoPane layout is too hard to use...
01:59:09 <Entroacceptor> lars9: afaik there's a wmii-like module
01:59:36 <lars9> ksf: because windows are not sticked to panes, so switching windows in TwoPane layout is a pain
02:00:11 <lars9> ksf: you dunno what will happen when switching to 'next' window
02:00:13 <funkyjunkyrobot> it doesn't like this
02:00:15 <funkyjunkyrobot> char2Int:: Char -> Int
02:00:15 <funkyjunkyrobot> char2Int a | a=='s' = 0
02:00:43 <lars9> Entroacceptor: i think it's related to xmonad's data structure
02:05:40 <funkyjunkyrobot> ok, got the char -> int working
02:07:44 <dschoepe> lars9: http://www.eng.uwaterloo.ca/~aavogt/xmonad/docs/xmonad-contrib/XMonad-Layout-SubLayouts.html -- this should do what you want
02:08:57 <lars9> dschoepe: lemme check
02:15:54 <funkyjunkyrobot> saizan i am having some trouble figuring out how this function is going to work without 2 lists to work with
02:16:04 <funkyjunkyrobot> i need to make it more generic but i don't know how exactly
02:16:37 <Saizan> but you can make use of the two lists
02:16:54 <funkyjunkyrobot> k
02:16:59 <funkyjunkyrobot> here is where i'm at
02:17:31 <funkyjunkyrobot> interpret :: [Char] -> ([Int] -> [Int] -> Bool)
02:17:31 <funkyjunkyrobot> interpret [Char] = compare xs
02:17:41 <funkyjunkyrobot> do i need xs to be part of the fucntion prior to calling it
02:18:01 <Saizan> "interpret [Char]" doesn't make sense
02:18:03 <funkyjunkyrobot> i'm not done at all, i'm just trying to figure out if i need to split this into a few functions first
02:19:14 <funkyjunkyrobot> yeah. it doesn't make sense to me at the moment
02:19:43 <Saizan> [Char] is a type, a pattern for an argumeent of that type can be 1) simple variable: x   2) the empty list []  3) a cons: (x:xs) where x is the head and xs the tail
02:19:48 <Saizan> or some nesting of those
02:20:18 <Saizan> so, start with "interpret chars xs ys = .."
02:20:42 <funkyjunkyrobot> ok
02:20:58 <Saizan> xs and ys are the two [Int]
02:21:14 <funkyjunkyrobot> yep
02:22:45 <Saizan> for Char you can pattern match with character literals, like 'c'
02:23:26 <Saizan> btw, [Char] -> ([Int] -> [Int] -> Bool) and [Char] -> [Int] -> [Int] -> Bool are the same type, if that wasn't clear
02:27:07 <funkyjunkyrobot> her is something , it doesn't work, but it's my train of thought right now
02:27:14 <funkyjunkyrobot> interpret chars xs ys = compare (xs !! ((chars2Int chars !! 0))) (ys !! ((chars2Int chars !! 0))) of LT -> LT; EQ ->(interpret (tail chars) xs ys); GT -> GT
02:28:00 <funkyjunkyrobot> i don't see how i can use recursion to keep moving through it to give me the next comparison
02:30:53 <lars9> do you use quickcheck to check, profile and improve your program?
02:31:43 <funkyjunkyrobot> no
02:31:45 <funkyjunkyrobot> what is that?
02:31:48 <lars9> @instance integral
02:31:48 <lambdabot> Maybe you meant: instances instances-importing
02:31:54 <lars9> @instances Integral
02:31:55 <lambdabot> Int, Integer
02:32:04 <lars9> @index Integral
02:32:04 <lambdabot> Prelude
02:32:19 <funkyjunkyrobot> i don't follow
02:32:59 <funkyjunkyrobot> what are u trying to show me?
02:33:06 <funkyjunkyrobot> did i use the wrong type?
02:33:14 <lars9> funkyjunkyrobot: oh its not relavent to quickcheck
02:33:27 <funkyjunkyrobot> what is quickcheck?
02:33:29 <nus> funkyjunkyrobot, is "f a b = ...; ..." valid Haskell syntax?
02:33:35 <lars9> funkyjunkyrobot: and i was not responding to your problem..
02:34:49 <funkyjunkyrobot> i don't know. 
02:34:51 <funkyjunkyrobot> i thought so
02:35:00 <funkyjunkyrobot> is it suposed to be a comma?
02:37:56 <Saizan> ; works for case
02:38:13 <Saizan> but in an .hs you usually go with layout
02:38:41 <funkyjunkyrobot> do i want something more like this?
02:38:44 <funkyjunkyrobot> compare x y | x==y      = EQ
02:38:44 <funkyjunkyrobot> 		| x<=y      = LT
02:38:44 <funkyjunkyrobot> 		| otherwise = GT
02:38:46 <Saizan> funkyjunkyrobot: what do you need to "move" there?
02:39:11 <funkyjunkyrobot> in place of the ;?
02:39:15 <funkyjunkyrobot> or where?
02:39:40 <Saizan> "i don't see how i can use recursion to keep moving through it to give me the next comparison" <- i was referring to this
02:40:03 <funkyjunkyrobot> k
02:40:17 <funkyjunkyrobot> so should i be focused on the eq case?
02:40:25 <ksf> @check \x y -> x + y - y = x
02:40:25 <lambdabot>   Parse error at "=" (column 19)
02:40:28 <ksf> @check \x y -> x + y - y == x
02:40:29 <lambdabot>   "OK, passed 500 tests."
02:40:36 <funkyjunkyrobot> what needs to happen at the eq case?
02:40:39 <ksf> @check \x y -> x + y + y == x
02:40:40 <lambdabot>   "Falsifiable, after 1 tests:\n-2\n3\n"
02:40:46 <funkyjunkyrobot> i mean is that what i'm supposed to look at
02:41:17 <Saizan> funkyjunkyrobot: i'm not following you
02:41:46 <Saizan> funkyjunkyrobot: why do you think that the interpret function you've given above doesn't work?
02:42:10 <funkyjunkyrobot> ok, so can i use recursion in the definition of "interpret chars xs ys = compare"
02:42:44 <funkyjunkyrobot> i'm just getting a parse error and it's making it hard to move forward
02:43:52 <Saizan> funkyjunkyrobot: you lack a "case" just after "="
02:44:52 <funkyjunkyrobot> i don't even understand if i have any cases
02:45:16 <Saizan> case is a keyword, 
02:45:22 <funkyjunkyrobot> ahh
02:46:11 <funkyjunkyrobot> i have no clue, i can't find anything about this on-line either
02:46:16 <Saizan> interpret chars xs ys = case compare (xs !! ..) (ys !! ..) of ...
02:46:31 <funkyjunkyrobot> ohh
02:46:53 <funkyjunkyrobot> no wonder it was so hard to explain it to me
02:46:55 <Saizan> http://en.wikibooks.org/wiki/Haskell/Control_structures#case_Expressions
02:47:37 <Saizan> i assumed you were familiar with case expressions from the start
02:48:07 <Saizan> but now i see you never used them in your code :)
02:50:30 <funkyjunkyrobot> interpret chars xs ys = case compare (xs !! (((map char2Int chars) !! 0))) (ys !! (((map char2Int chars) !! 0))) of LT -> LT; EQ ->(interpret (tail chars) xs ys); GT -> GT
02:50:33 <funkyjunkyrobot> that works
02:50:39 <funkyjunkyrobot> well to give u a little background
02:50:50 <funkyjunkyrobot> i'm in a class called programming languages concepts
02:51:05 <funkyjunkyrobot> we are learning the objective of "choosing the right tool for the job"
02:51:19 <Nibble> funkyjunkyrobot: and that tool is always haskell
02:51:20 <funkyjunkyrobot> so we learn about programming languages and we get thrown into a new language every 2 weeks
02:51:35 <funkyjunkyrobot> and we get assignments like this
02:51:50 <funkyjunkyrobot> and with haskell, i have been failing pretty bad
02:52:24 <funkyjunkyrobot> we get 5 slack days to turn in work late. and this was due on monday, so in 5 hours my time is up
02:52:48 <funkyjunkyrobot> i have been trying really hard tho. just to do the first 3 parts took longer then we were given.
02:52:59 <funkyjunkyrobot> i had never seen a functional programming language before
02:53:19 <Nibble> funkyjunkyrobot: you will probably be thrown lisp at you some week in the future
02:53:28 <funkyjunkyrobot> thats next
02:53:30 <Nibble> funkyjunkyrobot: my suggestion is to experiment with it a bit before
02:53:36 <funkyjunkyrobot> lisp is what we get assigned next for sure
02:53:40 <Nibble> :)
02:54:02 <diabolo_> hello people, I have a noob question, is this the place to ask?
02:54:05 <treblih> awesome
02:54:08 <Nibble> diabolo_: yes.
02:54:11 <funkyjunkyrobot> well i have to get through this and then i have lisp thrown at me monday... not alot of time to get ahead when ur drowning in ur current state
02:55:09 <funkyjunkyrobot> thanks saizan by the way, u are my light at the end of a dark tunnel right now :)
02:55:13 <Saizan> haskell in 2 weeks is a bith harsh if you've never seen a functional language before
02:55:21 <funkyjunkyrobot> ur telling me
02:55:22 <Saizan> *bit
02:55:31 <funkyjunkyrobot> i haven't got much sleep to say the least
02:55:48 <treblih> is haskell the hardest by now in your course
02:55:58 <funkyjunkyrobot> i'm the type of person who really likes to understand things and haskell has been awesome. but i haven't been able to spend the time to be comfortable enough to use it right
02:56:04 <ksf> it's also unnecessary. haskell can emulate all other languages sufficiently, modulo their sucky syntax.
02:56:04 <funkyjunkyrobot> by far
02:56:37 <ksf> well, duff's device is going to be hard.
02:56:42 <funkyjunkyrobot> not the hardest i would say, but it's such a paradigm shift it's hard to handle
02:56:44 <Gabbie> I <3 learnyouahaskell.com for learning haskell
02:56:51 <diabolo_> ok, I'm trying to make a game of life, i have a [[Int]] -> [[Int]] function to update the state of the cells matrix. Now i'd like to make a program that update and displays the state every second for example
02:57:21 <Saizan> yeah, you need a month or some more to feel comfortable with it, depending on the material you have
02:58:09 <funkyjunkyrobot> i agree
02:58:25 <funkyjunkyrobot> i'm running outa time though ...
02:58:35 <funkyjunkyrobot> so my next question is this
02:58:50 <Saizan> diabolo_: you should start with a function [[Int]] -> String
02:59:16 <Saizan> diabolo_: assuming by "display" you meant in the terminal
02:59:33 <diabolo_> Saizan, yes, actually I already have that
02:59:41 <diabolo_> so far I got it working with recursion, something like loop m = do display m; sleep ; loop (next m)
02:59:50 <diabolo_> but I'm not sure it feels right
03:00:23 <Saizan> that's display :: [[Int]] -> IO () though
03:01:35 <Saizan> anyhow, you can also write it like "loop m = mapM_ (\m -> do display m; sleep) (iterate next m)"
03:01:53 <Saizan> but your version of loop is quite fine too
03:03:33 <Heffalump> gah, the code.haskell.org webserver has fallen over again
03:03:46 <funkyjunkyrobot> whats the pasty site again?
03:04:03 <ksf> hpaste.org
03:04:37 <diabolo_> Saizan, thanks, I think that the kind of construct I was looking for
03:04:40 <ksf> yep we need to either get a proper p2p infrastructure up and running or have someone pay someone to feed the hamsters more regularly.
03:04:43 <diabolo_> this place rocks
03:04:54 <funkyjunkyrobot> i agree
03:05:09 <funkyjunkyrobot> saizan rocks! and others that have helped me as well.
03:05:47 <funkyjunkyrobot> http://hpaste.org/41422/currentspot
03:06:40 <Saizan> funkyjunkyrobot: and the question?:)
03:06:45 <funkyjunkyrobot> this is confusing how i am going to get this interpret chars to go into my sort
03:07:51 <funkyjunkyrobot> it needs 2 lists, and my sort is only working on one list
03:08:36 <Saizan> funkyjunkyrobot: but the first argument of sort is given two elements
03:08:42 <Saizan> the pred
03:08:55 <funkyjunkyrobot> ahh
03:09:09 <funkyjunkyrobot> so is that thing just called interpret?
03:09:15 <funkyjunkyrobot> can i use that?
03:09:18 <Saizan> almost
03:09:32 <funkyjunkyrobot> then the list of chars
03:09:44 <Saizan> yeah, and you also need to convert Ordering to Bool
03:10:00 <funkyjunkyrobot> the compare is an ordering then i take it
03:10:21 <Saizan> isLTorEQ GT = False; isLTorEQ _ = True
03:11:14 <Saizan> (\chars -> insertions_sort (\ xs ys -> isLTorEQ (interpret chars xs ys)) :: [Char] -> [[Int]] [[Int]]
03:11:22 <Saizan> oops
03:11:25 <Saizan> (\chars -> insertions_sort (\ xs ys -> isLTorEQ (interpret chars xs ys)) :: [Char] -> [[Int]] -> [[Int]]
03:11:47 <Saizan> are you familiar with lambda expressions? the "\ .. -> .." thing
03:11:59 <funkyjunkyrobot> no
03:12:17 <Saizan> heh
03:12:24 <funkyjunkyrobot> i want eq to recurse and lt to be true or false and gt to be true or false
03:12:41 <funkyjunkyrobot> trying to decide which 
03:12:45 <Saizan> that's already described in the definition of interpret, afaiu
03:13:45 <Saizan> anyhow, you can define "interpretBool chars xs ys = isLTorEQ (interpret chars xs ys)"
03:13:54 <funkyjunkyrobot> so this isLTorEQ GT = False; isLTorEQ_ = True some key words i need?
03:14:13 <funkyjunkyrobot> k
03:14:25 <Saizan> that's the definition of the function named isLTorEQ
03:14:36 <Saizan> you need a space in front of the _
03:14:47 <Saizan> _ is a pattern that matches everything
03:15:23 <Saizan> actually, "isLTorEQ o = not (o == GT)" <- maybe this definition is clearer?
03:15:47 <treblih> saizan, how long you've learned haskell
03:15:56 <funkyjunkyrobot> Not in scope: `isLTorEQ'
03:16:12 <Saizan> funkyjunkyrobot: you've to define it
03:16:28 <Saizan> funkyjunkyrobot: isLTorEQ o = not (o == GT) <- put this in the source file
03:17:13 <funkyjunkyrobot> wow
03:17:25 <funkyjunkyrobot> this is rediculous
03:17:43 <Saizan> why?
03:17:44 <funkyjunkyrobot> there has to be a simpler way to do this. cuz there is no way our professor expects us to figure this much out
03:18:10 <funkyjunkyrobot> i'm down for the direction we are headed in, but it seems beyond the scope of what one can learn in a couple weeks
03:18:27 <funkyjunkyrobot> just commenting
03:18:40 <funkyjunkyrobot> i need some air and some water. my brain is starting to hurt 
03:18:49 <Saizan> this is just a little bookeeping, compared to implemeting interpret of insertion sort
03:18:56 <Saizan> *implementing
03:19:31 <Saizan> treblih: ghc 6.6 was released around the time i started, so 3 or 4 years?
03:19:48 <treblih> wow!
03:21:18 <Saizan> funkyjunkyrobot: it's quite possible that there's a simpler way to solve the overall exercise, i just focused on showing how you can use your insertion_sort to get the sorting you want
03:21:19 <treblih> do you use haskell in your work
03:22:05 <funkyjunkyrobot> yeah, i agree you are doing more than a fine job at helping me with the path i have chosen.
03:22:10 <Saizan> no, mostly because i don't have a work :)
03:23:28 <funkyjunkyrobot> so do i drop in isLTorEQ in for (a -> a -> Bool) in my sort?
03:23:37 <funkyjunkyrobot> my pred
03:24:21 <Saizan> before i as in the middle of saying that you can put the pieces together like this: "composeCost chars xs = let sorted = insertion_sort (interpretBool chars) xs in .."
03:25:05 <Saizan> no, you've to use interpretBool for your pred, defined as "interpretBool chars xs ys = isLTorEQ (interpret chars xs ys)"
03:25:42 <Saizan> isLTorEq was just for the sake of defining interpretBool from simple pieces
03:26:00 <funkyjunkyrobot> k
03:26:05 <funkyjunkyrobot> i think i'm missing something
03:26:17 <treblih> oh,,,that's unbelievable, recently i talked with 3 haskell master, one is you, one is the author of manatee(you know that?), and the last has solved more than 250 problems in Project Euler,  to my big big surprise, you all free programmers
03:26:35 <funkyjunkyrobot> isLTorEQ GT = False; isLTorEQ _ = True do i need this in my source?
03:27:04 <Saizan> treblih: people with an haskell job tend to have less time to spend on irc :)
03:27:15 <Saizan> funkyjunkyrobot: yes
03:27:40 <Saizan> funkyjunkyrobot: well, i've given you two equivalent definitions of isLTorEQ, you've to put in your source one of them
03:27:56 <Saizan> funkyjunkyrobot: the other one was isLTorEQ o = not (o == GT)
03:28:07 <funkyjunkyrobot> ok i had that one
03:28:44 <treblih> but, excuse me, how do you make a living
03:29:07 <Saizan> treblih: i'm still a student
03:29:16 <treblih> wow!
03:30:15 <funkyjunkyrobot> and a teacher :)
03:31:18 <Saizan> mh, i'm still throwing code at you without explaining much actually
03:31:18 <treblih> yeah i agree
03:33:36 <treblih> you've done a project in google summer code, right?
03:33:43 <treblih> 2008
03:34:15 <Saizan> yep
03:38:30 <funkyjunkyrobot> so i've ran into a bit of a snag
03:39:03 <funkyjunkyrobot> when recursing through the char array, when it gets to the empty set it fails. can i nest a check in there some how?
03:39:25 <funkyjunkyrobot> interpret chars xs ys = case compare (xs !! (((map char2Int chars) !! 0))) (ys !! (((map char2Int chars) !! 0))) of LT -> LT; EQ ->(interpret (tail chars) xs ys); GT -> GT
03:39:40 <funkyjunkyrobot> on the part that it calls it on tail chars in the EQ statement
03:40:01 <funkyjunkyrobot> it can return an empty set and then my call to index !! 0 is to large
03:40:15 <Saizan> you can add another equation for when chars is empty
03:40:37 <Saizan> just put a line above like "interpret [] xs ys = ..something here of type Bool .."
03:40:57 <funkyjunkyrobot> ok
03:41:01 <diabolo_> funkyjunkyrobot, if you where in C you would check the length of the array inside the function with an if
03:41:18 <funkyjunkyrobot> yeah i know that much but i'm not in c :(
03:41:28 <Saizan> funkyjunkyrobot: actually you simplify it quite a bit if you pattern match against chars even in the second equation
03:41:30 <diabolo_> in haskell you can define the function with the special case as an argument
03:41:30 <funkyjunkyrobot> i do have a length function though
03:43:23 <diabolo_> funkyjunkyrobot, i know, i'm just mentioning it to point out the difference just in case, it's easy to be tempted to replicate C stuff in haskell when there are better ways to do it
03:43:45 <Saizan> funkyjunkyrobot: http://hpaste.org/paste/41422/pattern_match#p41423
03:48:03 <paolino> are type families used to write libraries ?
03:48:13 <treblih> nice to meet all of you
03:49:00 <paolino> and client of those libraries use to instantiate those ?
03:50:10 <Cale> paolino: Sure
03:50:12 <paolino> I mean that is the way type classes go. 
03:50:51 <Cale> paolino: There are also class-associated types, which are very closely related to type families (basically they're the same thing, but tied into a typeclass)
03:51:07 <paolino> Cale, I see how they can be convenient inside classes
03:51:24 <funkyjunkyrobot> damn i broke it
03:51:30 <paolino> I just miss how to use them outside
03:51:54 <paolino> s/how/when
03:51:59 <Cale> paolino: Well, they're kind of like type-level functions with odd syntax :)
03:52:41 <Cale> You'll usually end up using them along with typeclasses regardless, because the corresponding value-level functions need to be polymorphic like that.
03:53:15 <Cale> But sometimes it's just handy to not have to define a class right away.
03:53:20 <paolino> ok, so they expand the power of typeclasses
03:53:49 <Cale> Yeah
03:54:18 <paolino> Cale you have an example where they are useful without writing a new class ?
03:54:24 <funkyjunkyrobot> i can't figure out this case for the empty set
03:54:51 <funkyjunkyrobot> going from an ordering to a bool is not clear to me
03:56:13 <Cale> paolino: Well, say you're implementing type level naturals, for instance, where you don't care about having any values of those natural number types.
03:56:27 <paolino> :t \f x y -> let (t :: Bool) = x `f` y  in t
03:56:28 <lambdabot> forall t t1. (t -> t1 -> Bool) -> t -> t1 -> Bool
03:56:29 <Cale> paolino: type families would be useful for operations on those naturals, like addition or multiplication
03:58:59 <funkyjunkyrobot> i put in "interpret [] xs ys = compare xs ys"  and it seems to be working. any downfalls to this?
03:59:35 <ksf> yeah, you're not doing anything with the first argument.
03:59:48 <ksf> ...at least if that's the only case.
04:00:04 <paolino> Cale: implementing type level naturals is in some way not a pragmatic example
04:00:29 <Cale> paolino: Well, or other type-level programming.
04:00:34 <paolino> and not useful in a library 
04:01:03 <Saizan> funkyjunkyrobot: well that means that at the end you'll use the standard lexicographic ordering if they never differ for anything else
04:01:09 <paolino> Cale, typeclasses are type level programming ?
04:01:14 <funkyjunkyrobot> saizan, thank you so much for your help. 
04:01:32 <funkyjunkyrobot> yeah i believe that is what i want
04:01:41 <funkyjunkyrobot> i can handle the rest
04:01:44 <Cale> paolino: Sometimes, but I mean without involving typeclasses, type level programming is mostly what you'd use type families for.
04:01:55 <Saizan> i hope you get the assignment done in time :)
04:02:03 <funkyjunkyrobot> i got 4 hours now
04:02:10 <Cale> Once you have typeclasses, you get perhaps more practical uses out of them
04:02:15 <Cale> Oh
04:02:22 <funkyjunkyrobot> the part off adding up the difference between shipping costs should be easy now that i can sort it
04:03:14 <Cale> I suppose another case would be where you want one type family but where the related operations were separated into multiple typeclasses. Associating the family with just one typeclass might be a bit unnatural in that case.
04:03:42 <Cale> I haven't used type families all that much myself.
04:04:07 <Cale> (The separate kind)
04:04:39 <Cale> Associated types are an often nicer alternative to multiparameter typeclasses with functional dependencies.
04:04:51 <paolino> That is clear
04:06:58 <paolino> Cale , for me it's difficult to imagine how can use a type without it's value definition to instantiate a class or 2
04:09:54 <Nibble> hmm
04:09:59 <Nibble> where is manatee?
04:11:07 <Entroacceptor> sleeping, perhaps?
04:11:43 <Cale> paolino: I'm afraid I don't have a really great example handy.
04:11:55 <paolino> class GMapKey k where   data GMap k :: * -> *  is equivalent to class GMapKey k gm | k -> gm ?
04:12:21 <Cale> If it were  type  and not  data.
04:12:31 <paolino> ops
04:12:39 <Cale> data means that each instance will actually introduce new constructors
04:15:04 <paolino> mhh,   empty       :: GMap k v  would be translated in empty :: gm , I guess
04:16:48 <paolino> the only difference I see is that I can use the type (GMap k) in my methods
04:17:08 <paolino> which they do not in the example
04:21:08 <paolino> thanks anyway, type level programming will knock later
04:22:47 <Kafka> hm... haskell.org is down...
04:23:26 <paolino> data instance GMap (Either a b) v = GMapEither (GMap a v) (GMap b v)
04:24:05 <paolino> this is nice, GMap is exported to be used in its data instances
04:25:29 <paolino> I start to see the point :)
04:29:54 <diabolo_> Saizan, can I ask you another question?
04:43:12 <Saizan> diabolo_: ok
04:44:11 <diabolo_> it's not really a specific question but if I put my code on hpaste could you have a quick look at it and tell me what you think about it ?
04:44:17 <winmike> hi
04:44:43 <winmike> if i have a list of tuples - can i applay the maximum function on the second tuple in a simple way?
04:45:29 <Saizan> diabolo_: yep
04:45:58 <Saizan> winmike: the second element you mean?
04:46:12 <Saizan> iiuc you want maximumBy (compare `on` snd)
04:46:13 <ben> Do you mean maximumBy (comparing snd)?
04:46:16 <ben> oh
04:46:55 <hpc> @src comparing
04:46:55 <lambdabot> Source not found. Wrong!  You cheating scum!
04:47:02 <hpc> :t comparing
04:47:02 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:47:08 <diabolo_> Saizan, thx http://hpaste.org/41424/game_of_life_test
04:47:11 <Saizan> compare `on` snd == comparing snd
04:47:19 <ben> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Data-Ord.html#comparing it is not a very exciting implementation
04:47:22 <hpc> so it would seem
04:47:36 <winmike> Saizan, yes - the second of the tuple
04:51:00 <Saizan> winmike: then maximumBy (compare `on` snd) should be what you want
04:51:31 <winmike> Saizan, thx  a lot :)
04:52:21 <Saizan> diabolo_: side from the hlint hints, you should rather define lShiftL in terms of lShiftR, since appending has a linear time complexity
04:53:13 <Saizan> *aside
04:54:30 <diabolo_> Saizan, yeah I didn't know about hlint before I posted on hpaste, i'm installing it right now. i'll see if I can redefine lShiftR and lShiftL the other way around then
04:57:22 <Saizan> i'm afraid mShift in general won't be very efficient
04:59:50 <diabolo_> Saizan, I guess I could redefine the lShift functions using cycle in some way, then I wouldn't have to use much recursion in mShift, but I don't know if it would help
05:00:48 <Nibble> diabolo_: isn't that impossible?
05:01:53 <diabolo_> Nibble, i'm not sure about much when it come to haskell
05:02:10 <Nibble> diabolo_: I am just messing with you
05:03:14 <Saizan> recursion is not a problem per se, but it uses the shift functions a lot, and at least one is going to be slow
05:15:52 <diabolo_> what would be the best way to get a list with the first n elements dropped? (tails xs)!!n ?
05:17:10 <hpc> > drop 3 [1..10]
05:17:11 <lambdabot>   [4,5,6,7,8,9,10]
05:17:16 <hpc> :P
05:18:04 <Phyx-> is lambdabot lagging?
05:18:26 <hpc> no; that reply took less than a second for me
05:18:34 <sipa1024> @vixen are you lagging?
05:18:38 <lambdabot> i truely am
05:18:43 <hpc> haha
05:18:50 <hpc> that one lagged
05:19:04 <sipa1024> isn't it "truly" ?
05:19:07 <Phyx-> 14:16:42 < hpc> > drop 3 [1..10]
05:19:07 <Phyx-> 14:17:17 < lambdabot>   [4,5,6,7,8,9,10]
05:19:13 <Phyx-> then i'm lagging :(
05:19:23 <sipa1024> so it would seem
05:20:04 <Nibble> Phyx-: you are indeed lagging
05:20:06 <Phyx-> well then, time to get off the internets
05:20:12 <Phyx-> and read a book...
05:23:00 <winmike> hmm. i have version sept 2006 - why "Can't find imported module Data.Functions"? o_O
05:24:51 <Phyx-> my guess it the Base in that version of GHC doesn't have it
05:25:20 <Phyx-> and it's Data.Function
05:25:20 <Phyx-> not Functions
05:25:54 <winmike> Phyx-, same :-( Can't find imported module "Data.Functions"
05:26:43 <winmike> is there a other solution to get the maximum of the second element of a list with tuples?
05:27:32 <Phyx-> winmike: you still typed "Data.Functions" no "s", "Data.Function"
05:28:11 <winmike> Phyx-, a sorry - i pasted it wrong the first time. i had Function alreay
05:28:24 <winmike> Can't find imported module "Data.Function"
05:28:39 <Phyx-> :t foldr max 0 (liftM2 (,) [1..10] [1..10])
05:28:40 <lambdabot> forall a1 a2. (Ord a1, Ord a2, Num a1, Num a2, Enum a1, Enum a2) => (a1, a2)
05:28:59 <Phyx-> snd $foldr max 0 (liftM2 (,) [1..10] [1..10])
05:29:06 <Phyx-> > snd $ foldr max 0 (liftM2 (,) [1..10] [1..10])
05:29:06 <lambdabot>   10
05:29:30 <Phyx-> err
05:30:44 <Phyx-> > foldr (max . snd) 0 (liftM2 (,) [1..10] [1..10])
05:30:45 <lambdabot>   10
05:31:00 <Phyx-> > foldr (max . snd) 0 (liftM2 (,) [1..10] [1..15])
05:31:01 <lambdabot>   15
05:31:32 <Phyx-> > foldr (max . fst) 0 (liftM2 (,) [1..10] [1..15])
05:31:33 <lambdabot>   10
05:31:36 <lars9> will all the language extensions merged into ghc7? it seems repeating to add {- LANGUAGE xxx again and again
05:32:02 <Phyx-> winmike: would that do?
05:33:05 <winmike> Phyx-, liftM2 looks like magic :-( but yes: thanks a lot :))))
05:34:01 <Phyx-> winmike: the liftM2 part was just so i can construct a sample, it's the same as [(x,y) | x<-[1..10], y <-[1..15]]
05:34:17 <winmike> Phyx-, hmm. does it also work if there are 3 elements in tuple? i tried with "trd"
05:34:23 <winmike> Phyx-, ahhh ok i see
05:34:50 <engla> winmike: there are no functions fst, snd, trd for three-element tuples
05:34:51 <Phyx-> winmike: no, it only works on a 2 tuple. you should change it to (\a b c->c) instead of snd then
05:35:13 <Phyx-> there are no predefined selector functions for > 2 tuples
05:35:19 <winmike> Phyx-, engla thx a lot
05:35:30 <alpounet> hmm
05:35:33 <alpounet> when you release something
05:35:39 <alpounet> breaking compatibility with the previous version
05:35:49 <alpounet> what version number is supposed to change ?
05:35:51 <alpounet> the major one ?
05:37:09 <Phyx-> alpounet: i personally think so
05:37:51 <alpounet> (i can't manage to load the PVP page of the haskell wiki)
05:38:02 <Phyx-> > (1,5) `max` (8,0)
05:38:03 <lambdabot>   (8,0)
05:38:07 <Saizan> haskell.org is probably in the middle of moving
05:38:10 <alpounet> yeah
05:38:22 <Phyx-> > (1,9) `max` (8,0)
05:38:23 <lambdabot>   (8,0)
05:38:29 <Phyx-> interesting instance...
05:38:41 <Saizan> alpounet: http://new-www.haskell.org/haskellwiki/Package_versioning_policy
05:38:48 <alpounet> thanks!
05:38:54 <Phyx-> > (1,10) `max` (8,0)
05:38:55 <lambdabot>   (8,0)
05:39:24 <Phyx-> it's only looking at the fst element huh
05:39:33 <Phyx-> > (1,10,0) `max` (8,0,5)
05:39:34 <lambdabot>   (8,0,5)
05:39:43 <Saizan> > (8,10) `max` (8,0)
05:39:44 <lambdabot>   (8,10)
05:39:49 <Saizan> it's lexicographic
05:40:02 <Nibble> > (8,0) `max` (8,0,1)
05:40:03 <lambdabot>   Couldn't match expected type `(t, t1)'
05:40:03 <lambdabot>         against inferred type `(t2, ...
05:41:26 <aleator> Is there any way to make quasiquoter for declarations?
05:42:34 <winmike> Phyx-, sorry for being nastx :-( i cant get it work. is "foldr (max . (\a b c->c)) 0 [(1,2,3),(0,3,4),(0,2,5)]" ok? it doesnt work here :S
05:42:45 <winmike> i want the max of third element
05:42:58 <Saizan> winmike: it's (\(a,b,c) -> c) 
05:43:07 <Phyx-> yeah, sorry bout that
05:43:51 <Phyx-> foldr (max . (_,_,a)->a) 0 should do it
05:44:03 <winmike> i think i should read a book someday *g* thanks
05:44:04 <Phyx-> foldr (max . ((_,_,a)->a)) 0 should do it
05:44:16 <Saizan> Phyx-: \
05:44:16 <Phyx-> foldr (max . (\(_,_,a)->a)) 0 should do it
05:44:22 <Phyx-> wow, i'm really off my game today..
05:44:48 <Saizan> foldl' would be better
05:45:17 <catface> hi guys, is there an easy way to change how ghci formats Floating? specifically to fixed point like 0.0001
05:45:21 <Saizan> foldl' (\m (_,_,a) -> max m a) 0
05:46:17 <Saizan> catface: ghci simply uses the Show instance for Double
05:46:53 <Saizan> catface: you can't change that, but you could use a newtype MyDouble = MyDouble Double deriving (Num,Fractional,etc..)
05:47:04 <Saizan> and make your own Show instance for it
05:47:50 <Saizan> you'd have to add type annotations though, because the default will still be Double
05:48:16 <catface> ok, i guess what i want is just an easy way of formatting not necessarily using show
05:49:00 <catface> ah, i'm just whining really, i should do it myself
05:49:33 <Saizan> see the Numeric module
05:49:45 <Saizan> it has various formatting functions
05:49:46 <catface> ok thanks :)
05:54:43 <diabolo_> so... i redefined my shifting functions, any input/comments ? http://hpaste.org/paste/41424/better_shifts#p41425
05:54:53 <funkyjunkyrobot> saizan i'm having some trouble yet again
05:55:11 <funkyjunkyrobot> i'll make a pasty
05:58:19 <funkyjunkyrobot> http://hpaste.org/41426/stuck
05:58:27 <KBme> ☹
05:58:53 <funkyjunkyrobot> i can get the sort to pump out the right list, and i am trying to pass it to the different functions to do the cost and it is just spitting out a zero
05:59:32 <funkyjunkyrobot> when i do subTotal on the lists it gives me the right numbers, but something seems broken when it transfers from total to subTotal
06:00:11 <KBme> is the haskell site down for everyone?
06:00:35 <funkyjunkyrobot> http://downforeveryoneorjustme.com/
06:00:47 <funkyjunkyrobot> plug it in there
06:00:59 <KBme> oh lol i didn't know that site
06:01:06 <KBme> ok thanks
06:01:08 * KBme sad
06:01:09 <funkyjunkyrobot> :)
06:02:02 <KBme> is there a mirror or a quick and dirty start guide outside of the haskell site?
06:02:25 <Phyx-> RWH or LYAH
06:02:25 <KBme> i don't need that much, just to get started with xmonad..
06:02:38 <Phyx-> oh, on xmonad
06:02:41 <KBme> i don't know what those are :-/
06:02:57 <Ke> @where lyah
06:02:57 <lambdabot> http://www.learnyouahaskell.com/
06:03:08 <KBme> great
06:03:12 <KBme> thansk
06:03:33 <Saizan> http://new-www.haskell.org
06:04:16 <KBme> ohh sweet
06:05:30 <Saizan> funkyjunkyrobot: what's an input for which total gives zero?
06:05:40 <Saizan> funkyjunkyrobot: when it shouldn't
06:06:09 <funkyjunkyrobot> computeCost [[1,2,3],[1,1,1]] ['w']
06:06:27 <funkyjunkyrobot> first one is free
06:06:27 <KBme> is it possible to change the compiler path ghc uses?
06:06:34 <funkyjunkyrobot> then the 2nd one should be cost of 3
06:06:38 <KBme> my gcc's path changed now ghc can't compile anything
06:07:11 <funkyjunkyrobot> subTotal [1,2,3] [1,1,1]     gives me 3
06:07:31 <funkyjunkyrobot> so i know those functions are working @ subtotal and below
06:08:22 <funkyjunkyrobot> and i changed the computeCost function to output a [[Int]] and not call total and just spit out the list and the list looks right that is going into total
06:08:43 <funkyjunkyrobot> then i made total just count how many times the otherwise case is called. and it calls it once like it should
06:08:56 <funkyjunkyrobot> so puzzled
06:10:19 <Saizan> funkyjunkyrobot: but subTotal [1,1,1] [1,2,3] == 0
06:10:38 <Saizan> funkyjunkyrobot: and insertion_sort (interpretBool "w") [[1,2,3],[1,1,1]] == [[1,1,1],[1,2,3]]
06:11:06 <funkyjunkyrobot> ahh crap
06:12:17 <funkyjunkyrobot> well damn, i'm sorry that should have been easy to see. i'm so sleep deprived at this point. thank you yet again
06:13:23 <funkyjunkyrobot> but if u do that same one with the m option in sort it still gives zero
06:13:44 <funkyjunkyrobot> and the m option should sort it so that it's not fliped
06:13:47 <kadoban> i'm using Data.Map in ghc and getting linker errors.  i don't see exactly what i'm supposed to do from the man page, and haskell.org seems down, what's the compiling command line supposed to look like?
06:15:30 <KBme> kadoban: new-www.haskell.org
06:17:28 <kadoban> KBme: thanks, found it
06:19:34 <funkyjunkyrobot> i believe i'm wrong again
06:23:56 <MoALTz> opened that new-www link and my computer beeped and hanged
06:24:08 <MoALTz> (coincidence most likely)
06:26:19 <engla> kadoban: ghc --make <file>  maybe? I'm no expert
06:28:10 <kadoban> ya, i didn't know i needed --make...
06:28:46 <alpounet> --make figures out what libraries/packages you need automatically
06:28:54 <Nibble> hmm
06:28:58 <Nibble> how do I get user id in haskell
06:29:22 <alpounet> what user id ?
06:29:25 <alpounet> on the system ?
06:29:26 <Nibble> alpounet: in linux
06:29:28 <Nibble> yes
06:29:50 <alpounet> something like http://hackage.haskell.org/packages/archive/unix/2.4.0.2/doc/html/System-Posix-User.html may be what you're looking for
06:30:12 <Nibble> haskell.org is down :(
06:30:24 <Nibble> thank god for google cache!
06:30:31 <tg_> Nibble: try http://new-www.haskell.org/haskellwiki/Haskell
06:30:48 <alpounet> hackage is still up though
06:30:56 <aristid> http://new-www.haskell.org/haskellwiki/Hackage_statistics
06:31:22 <diabolo_> Nibble, http://new-www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-User.html ?
06:33:08 <diabolo_> getRealUserID calls getuid to obtain the real UserID associated with the current process. 
06:34:28 <Nibble> fuck
06:34:52 <Nibble> nvm
06:40:19 <dom96> Anyone know what this is caused by, (when using ghc --make) https://gist.github.com/675372
06:40:24 <dom96> ?
06:49:08 <Nibble> in this program
06:49:51 <Nibble> I use execvp to execute a program, but the problem is since it replaces the current process I have to fork and wait, the program is in C, I want to write it in haskell
06:49:59 <dankna> that's difficult
06:50:03 <dankna> well actually
06:50:06 <Nibble> I am not sure what to do
06:50:09 <dankna> no, you can use System.Process
06:50:14 <Nibble> is there any better way to do this?
06:50:18 <Nibble> dankna: ok?
06:50:22 <dankna> which does the difficult bits for you
06:50:42 <funkyjunkyrobot> saizan u still around. i overlooked one thing. we have everything going in ascending order and i need the first attribute shame to go in descending order
06:50:53 <funkyjunkyrobot> shape*
06:51:07 <funkyjunkyrobot> is there an easy fix for that?
06:51:30 <Heffalump> there are many easy fixes depending on how your code looks, can you paste it?
06:51:40 <funkyjunkyrobot> sure
06:52:55 <funkyjunkyrobot> http://hpaste.org/41429/quickfix
06:53:55 <Heffalump> the first attribute being the !!0 bit in interpret?
06:54:43 <Nibble> dankna: is there any way to use forkIO in my situation
06:54:52 <funkyjunkyrobot> yeah
06:55:06 <Heffalump> switch the LT and GT
06:55:21 <funkyjunkyrobot> well they can come in any order they are ['s','w','m'] and the chars determine the sort order
06:55:33 <funkyjunkyrobot> for just that case tho
06:55:48 <funkyjunkyrobot> when it's s
06:55:54 <funkyjunkyrobot> sorry i am a total noob
06:56:45 <funkyjunkyrobot> can i say "interpret ['s',_,_] xs ys = case compare (xs !! (((map char2Int chars) !! 0))) (ys !! (((map char2Int chars) !! 0))) of LT -> GT; EQ ->(interpret (tail chars) xs ys); GT -> LT
06:56:54 <funkyjunkyrobot> switch the LT and GT there?
06:56:56 <Heffalump> right
06:57:07 <funkyjunkyrobot> lets see if that works :)
06:57:10 <Heffalump> oh, I see. Hangon
06:57:22 <funkyjunkyrobot> knew it wouldn't be that simple
06:57:50 <Heffalump> I'm not sure I understand the problem yet.
06:57:58 <funkyjunkyrobot> k
06:58:26 <Heffalump> Can you paste the full problem?
06:59:59 <funkyjunkyrobot> yeah
07:00:06 <funkyjunkyrobot> let me try this link
07:00:16 <funkyjunkyrobot> cse.unl.edu/~jsukup/3v7.pdf
07:00:27 <funkyjunkyrobot> http://cse.unl.edu/~jsukup/3v7.pdf
07:00:38 <funkyjunkyrobot> i'm on the very last problem
07:01:22 <funkyjunkyrobot> saizan was helping me with it and i'm stuck yet again, because i misred the sort order where their asscending except for the shape part, the straights = 1 come before the curves=0
07:01:42 <funkyjunkyrobot> so i duno how to make just the 's' sorts go in descending order
07:02:31 <joe6> i am reading up on some basic category theory (http://www.cs.toronto.edu/~sme/presentations/cat101.pdf) and it appears that if we take out the input and output, everything in haskell is a morphism or functor?
07:02:48 <joe6> haskell is basically a functor?
07:02:51 <Heffalump> I'm not sure I fully understand the specification even from that :-)
07:02:55 <joe6> one big morphism?
07:03:08 <alpounet> joe6, functions are morphisms
07:03:08 <funkyjunkyrobot> thx anyway
07:03:10 <alpounet> the objects are types
07:03:17 <alpounet> parametrized types (like Maybe or []) are functors
07:03:35 <Heffalump> what happens if multiple characters are specified?
07:04:37 <joe6> alpounet: is there a distinction in the definition of functor in category theory vs definition of functor in haskell?
07:04:40 <Heffalump> and it refers to second and third inputs, but the signature of computeCost only has two inputs
07:05:18 <joe6> or, maybe i am better off saying, the haskell program = functor?
07:05:28 <joe6> when generalising.
07:05:35 <alpounet> haskell program?
07:05:56 <alpounet> but Functor in Haskell covers functors in the Hask category
07:06:14 <alpounet> (the category whose objects are haskell types and morphisms are functions from/to these objects)
07:06:21 <joe6> oh, ok.. gotta read up on Hask category, then.
07:06:40 <joe6> gotcha.
07:06:43 <alpounet> natural transformations in Haskell are functions between functors
07:06:46 <alpounet> like
07:06:49 <alpounet> listToMaybe
07:07:44 <joe6> alpounet: if we step back, can we not say: input -> functor -> output
07:08:04 <joe6> too much generalisation, and pretty useless, I guess.
07:08:12 <joe6> do not bother, will read up on hask category
07:08:24 <alpounet> a functor isn't just a function
07:08:42 <alpounet> particularly not in the Hask category
07:09:01 <alpounet> depending on the categories you work with, a functor may be a function
07:09:05 <alpounet> but here that's not the case
07:09:05 <dankna> Nibble: forkIO doesn't do what you're looking for
07:09:12 <dankna> but yes, it's compatible
07:09:26 <alpounet> a functor is something that maps the objects of a category to the objects of another category
07:09:31 <alpounet> and does the same for morphisms
07:09:33 <paolino> funkyjunkyrobot: the alternatives are ascending an descending ?
07:09:52 <Nibble> dankna: I got it to work with the link you gave me, thanks!
07:10:09 <funkyjunkyrobot> yeah, how can i make it flip from ascending to descending based on the character list
07:10:31 <joe6> alpounet: yes, you are correct. a functor is a superset of the function set
07:10:32 <funkyjunkyrobot> if it's an 's' which turns to a 0 , then i need it to be descending
07:10:39 <dankna> Nibble: great, congrats
07:10:42 <joe6> functor set is a superset of function set.
07:10:55 <funkyjunkyrobot> the other 2 cases are ascending 'w' or 'm'
07:10:57 <joe6> alpounet: would you agree with that?
07:11:02 <winmike> does anybody know why that fails? http://codepad.org/PHw5OSDU :-( i dont understand the error message
07:11:17 <alpounet> joe6, i'd say there is no point comparing functors and functions
07:11:35 <alpounet> you do not take a function and try to figure out for which categories it's a functor
07:11:37 <joe6> oh, ok.
07:11:43 <Nibble> dankna: btw, I am using waitForProcess, and since it returns an exit code
07:11:49 <alpounet> you just have interesting categories
07:12:00 <alpounet> and see how you can go back and forth between them through functors
07:12:06 <Nibble> or wait
07:12:08 <Nibble> hold on a sec
07:12:26 <joe6> "you do not take a function and try to figure out for which categories it's a functor" -- why do you say this? don't the type definitions define the category or domain or codomain for teh function?
07:12:33 <joe6> s/teh/the/
07:12:50 <alpounet> yes but i mean
07:13:01 <alpounet> when you learn category theory
07:13:10 <alpounet> you generally have categories
07:13:18 <Nibble> dankna: it exits my main process too
07:13:29 <alpounet> and try to find a way to go from one to the other
07:13:41 <alpounet> you don't take a function
07:13:50 <alpounet> and try to figure out for which categories this function is a functor
07:15:11 <dankna> Nibble: hm, that shouldn't be happening ^^' I haven't tried this exact case so I'm not sure why it would
07:15:39 <Nibble> I have this short code
07:15:41 <Nibble>   pid <- runCommand cmd
07:15:43 <Nibble>   waitForProcess pid >>= exitWith
07:15:56 <Nibble> or
07:15:58 <Nibble> wait
07:16:00 <Nibble> nvm
07:16:02 <Nibble> I fail :/
07:16:17 <dankna> haha, okay
07:16:43 <Nibble> or perhaps, not I forgot to call my run function recursively... 
07:16:56 <Nibble> still closes down on me
07:17:31 * Twey . o O (… runCommand >>= waitForProcess >>= exitWith …)
07:18:09 <Philonous> winmike: You're trying to cons a triple with an ELgraph, but the second argument to (:) has to be a list. (It's type is a -> [a] -> [a] )
07:18:57 <winmike> Philonous, yes :-( but i dont know how to get the list recursive :-/ does that work without a helper function?
07:19:22 <winmike> Philonous, i just need to write a comverter function from Inp -> ELgraph
07:19:39 <Heffalump> funkyjunkyrobot: I think the code you suggested would work for flipping it based on the list, but you might need to explicitly list several cases to do it precisely that way.
07:21:39 <Philonous> winmike: Well, you want to convert every element in a list. So you are looking for a function of type "(a->b) -> [a] -> [b] "
07:21:55 <Philonous> @type map
07:21:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:22:24 <winmike> Philonous, aahhhhh ok thx a lot :)))
07:23:33 <Philonous> winmike: Hope that helps. 
07:28:12 <winmike> Philonous, yes - you rescued my life :))
07:29:09 <dankna> Nibble: I assumed you noticed this, but just in case, let me point it out.  The fact that you're calling exitWith means your parent process will indeed exit, since you told it to.
07:30:00 <Nibble> dankna: I figured it was something like that :P
07:30:04 <dankna> heh okay
07:30:16 <Nibble> haven't done a lot in haskell lately
07:30:29 <dankna> nod
07:30:32 <Nibble> getting rusty, not to mention I have never worked this close to the OS before
07:30:35 <Nibble> in haskell
07:31:00 <dankna> fair enough
07:37:30 <Nibble> dankna: how should I do this then :/
07:38:05 <dankna> well, what's your goal?  if you don't want to exit after the child exits, what do you want to do?
07:38:22 <Nibble> dankna: continue running, doing the same thing again
07:38:24 <Nibble> and again
07:38:28 <Nibble> and some times more
07:38:29 <dankna> "waitForProcess pid" will wait for it to exit
07:38:36 <Nibble> dankna: the child, right?
07:38:36 <dankna> without exiting yourself
07:38:40 <Nibble> that's what I want
07:38:40 <dankna> yeah
07:39:06 <Nibble> my problem is that I need to take care of the ExitCode that it returns
07:39:22 <Nibble> (returns in a C way)
07:40:08 <dankna> what do you need to do with the exit code?
07:40:23 <Nibble> hold on a sec :P
07:40:24 <dankna> exitCode <- waitForProcess pid
07:40:28 <dankna> putStrLn $ show exitCode
07:42:15 <Nibble> dankna: that would work
07:43:04 <Nibble> dankna: how do I print something out without the newline?
07:44:17 <sipa1024> :t putStr
07:44:18 <lambdabot> String -> IO ()
07:44:23 <sipa1024> there you go
07:44:28 <Nibble> :)
07:46:35 <MrAI> Does anybody know a good resource to learn mutl threading in Haskell?
07:48:21 <raichoo> MrAI: Realworld Haskell and the Haskell Wiki. I'd recommend the STM bits.
07:48:30 <MrAI> Thanks
07:48:40 <MrAI> I wasnt sure what Haskell called it
07:48:40 <raichoo> No problem. Have fun.
07:48:43 <MrAI> :D
07:49:52 <Nibble> LYAH
07:49:54 <Nibble> is great
07:49:59 <Nibble> read a few chapters
07:50:03 <Nibble> then read real world haskell
07:50:12 <raichoo> Do they have a section on multithreading?
07:50:19 <raichoo> I mean in LYAH?
07:50:21 <MrAI> Yes. Real World Haskell does
07:50:25 <MrAI> Ah not sure
07:50:39 <jmcarthur> "multithreading" is an implementation. what problem are you wanting to solve with it? there are higher level ideas you can be looking for
07:50:40 <raichoo> But agreed LYAH is outstanding.
07:50:40 <MrAI> Real World Haskell: Chapter 24. Concurrent and multicore programming
08:02:34 <alexsuraci> gah, looks like haskell.org is down again
08:04:12 <jmcarthur> huh. it was known that hackage would go down today, but i don't think haskell.org is even on the same server
08:04:38 <mornfall> We are falling apart, are we...
08:05:35 <Saizan> http://new-www.haskell.org/ <- might help
08:05:56 <mornfall> Oh, new design.
08:06:10 <mornfall> One that doesn't fit my 1280px wide display. :(
08:06:26 <mornfall> (Well, not very well, anyway.)
08:07:21 <monochrom> why not read both. the best tutorial is the 3rd one you read.
08:07:32 <jmcarthur> umm... the new design scales very well in my browser
08:07:44 <jmcarthur> i can make it very narrow without destroying it
08:08:36 <MtnViewMark> Perks his head up at web design: which site?
08:09:01 <jmcarthur> MtnViewMark: http://new-www.haskell.org/
08:09:20 <jmcarthur> it's been sitting around for a while now
08:10:17 <MtnViewMark> Ah yes, that design was also the starting point for the new haddock
08:10:24 <jmcarthur> yeah
08:11:23 <mornfall> jmcarthur: The events column is virtually unreadable for me.
08:11:31 <MtnViewMark> One of my too many projects is helping style the new hackage along similar lines
08:12:45 <mornfall> The headlines/links form a solid block of text without any form of delineation between.
08:13:06 <Heffalump> there is work in progress to improve the haskell infrastructure
08:17:57 <Phyx-> Heffalump: is that the working theory
08:25:40 <jmcarthur> mornfall: weird
08:25:44 <jmcarthur> that is not the case for me
08:26:43 <jmcarthur> mornfall: for me it even rearranges the columns and resizes the text as if for a mobile phone browser, if i shrink the window enough
08:26:59 <jmcarthur> this is in chrome
08:30:19 <arcatan> meh, is hackage broken or is it just my crappy connection?
08:30:52 <dons> the building hosting hackage is switched off 7 - 12 PST today for emergency electrical repairs
08:31:01 <dons> so 3.5 more hours, approx
08:31:11 <monochrom> planned downtime. see reddit. not announced in the haskell mailing list.
08:31:39 <dons> yes, we were informed around 5pm friday evening a serious fault had been uncovered.
08:31:50 <dons> so semi-planned.
08:32:02 <arcatan> oh
08:32:14 <dons> more concerning, www.haskell.org seems to be down, and there's no good reason for that.
08:32:45 <dons> its hosted on the other side of the US though, in an unrelated facility
08:34:18 <Nibble> dons: use new-www.haskell.org
08:34:49 <arcatan> i think it was down yesterday already
08:35:19 <dons> yes, the switchover to new-www will be soon, but some other services need to be moved.
08:54:35 <mornfall> jmcarthur: web.mornfall.net/stuff/hsweb.png -- I can't discern the individual items in the event list at all
08:54:43 <mornfall> which makes it very hard to read
08:58:11 <jmcarthur> mornfall: okay that does suck
08:58:18 <jmcarthur> i was misunderstanding your complaints
08:59:23 <mornfall> I sort of thought it was because the middle column was too squeezed.
08:59:43 <mornfall> (But can't check what happens on wider screen given how I don't have one ... :)
09:00:32 <jmcarthur> it's about the same for me (1680x1050)
09:03:17 <Heffalump> I have 1440x900 and it looks just about ok, but rather crowded
09:24:52 <MrAI> Is there a function to tell where in a list is an element if it exists? e.g Find 4 in [1,2,3,4] would result position 3 or 4
09:25:51 <luite> > elemIndex 4 [1,2,3,4]
09:25:52 <lambdabot>   Just 3
09:25:58 <MrAI> Thanks
09:26:22 <jmcarthur> hmm
09:26:25 <jmcarthur> :t elemIndices
09:26:26 <lambdabot> forall a. (Eq a) => a -> [a] -> [Int]
09:26:29 <jmcarthur> yay
09:26:31 <Twey> > elemIndices 4 [1, 2, 3, 4, 5, 4, 3]
09:26:32 <lambdabot>   [3,5]
09:26:35 <Twey> Quite ☺
09:27:52 <luite> ooh high tech unicode emoticons
09:28:24 <luite> a future revision of unicode should add animated color emoticons ;)
09:28:52 <vladsharp> is hackage expected to be back up soon?
09:29:28 <luite> vladsharp: 3.5 hours was what dons said about an hour ago
09:29:46 <vladsharp> luite: ok, thanks
09:30:12 <vladsharp> is there a mirror of the packages (i need the haskell platform dmg)
09:31:49 <dons> vladsharp: yes, on http://lambda.galois.com/hp-tmp/2010.2.0.0/
09:31:53 <dons> mac and windows installers
09:32:40 <vladsharp> thanks, will bm that for the future
09:37:34 <pokoko222> when to do single rotation vs double rotation in AVL? general computer science question :)
09:38:33 <vladsharp> ah ofc cabal now can't download the package list as hackage is down ^_^ 
09:56:36 <jmcarthur> okay i officially want kind polymorphism in ghc
09:57:30 <portnov> are hackage and haskell.org both down?
09:58:38 <jmcarthur> hackage was expected to be down for a little while today. haskell.org was not
09:58:41 <jmcarthur> both are down though
09:59:49 <portnov> :(
10:03:25 <alpounet> jmcarthur, what's your use case ?
10:07:06 <jmcarthur> alpounet: http://hpaste.org/41433/kind_polymorphism_use_case
10:08:33 <jmcarthur> alpounet: it expects an instance of Category to have kind * -> * -> *, but Functor has kind (* -> * -> *) -> (* -> * -> *) -> *
10:09:16 <alpounet> yeah, and the first two * for Category would be (* -> * -> *)
10:09:23 <jmcarthur> right
10:09:28 <alpounet> ok got it
10:09:42 <jmcarthur> kind polymorphism would mean Category would expect (a -> b -> *) instead
10:10:10 <jmcarthur> hmm
10:10:23 <jmcarthur> yeah that's right
10:10:56 <alpounet> a and b being any kind we want
10:11:01 <alpounet> ok
10:11:13 <jmcarthur> UHC has kind polymorphism, supposedly
10:11:22 <alpounet> "higher order kinds", smth like that
10:12:01 <sipa1024> value -> types -> kinds -> what's next?
10:12:22 <alpounet> oleg
10:12:25 <portnov> uh oh. Maybe «types as first-order values» than?
10:12:28 <portnov> he.
10:12:52 <portnov> 5 :: Int; Int :: Type; Type :: Type.
10:12:57 <jmcarthur> sipa1024: you could just skip the whole thing and go to Coq or Agda, of course :)
10:13:10 <jmcarthur> anything with dependent types
10:13:26 <portnov> yeah, also dependent types and subtypes.
10:14:30 <Nibble> nested data parallel programming sounds cool
10:14:57 <kmc> sipa1024, there's also languages like Ωmega which have an infinite hierarchy of 'sorts' but are not dependently typed
10:15:10 <portnov> btw, about dependent types. Is type inferrence for dependent types proved to be impossible? Or it's just un-implemented?
10:15:10 <jmcarthur> i like omega
10:15:11 <sipa1024> hmmm, nice :)
10:15:34 <kmc> portnov, proven undecidable.  even inference for System F is proven undecidable
10:15:40 <jmcarthur> portnov: my impression is that it's impossible, but i haven't seen proof myself
10:15:50 <sipa1024> define impossible
10:15:51 <portnov> ok.
10:16:09 <jmcarthur> sipa1024: um... not possible?
10:16:18 <kmc> sipa1024, you might also want to read about "pure type systems"
10:16:40 <sipa1024> some people call undecidable impossible
10:16:42 <jmcarthur> sipa1024: "undecidable" is a better word choice than "impossible"
10:16:50 <sipa1024> but it's not the same
10:16:54 <jmcarthur> yeah
10:17:01 <portnov> what about inferring «independent» types in languages with dependent types? Is this possible?
10:18:12 <portnov> I mean, if we cannot infer types of some complex constructs, may be we can infer types for some set of simple constructs at least?
10:18:26 <jmcarthur> portnov: hmm... if it's otherwise simply typed then that sounds feasible to me. kind of like how ghc infers the types of some functions but fails to for others, e.g. higher ranked types
10:19:38 * jmcarthur debates whether to try UHC for this
10:19:54 <jmcarthur> i was planning to use ghc extensions pretty liberally before i thought of this limitation
10:22:10 <merijn> portnov: Type inference for dependent types is proved to be possible because Epigram is implementing it and they discuss the implementability in their papers
10:22:25 <portnov> eh
10:22:52 <jmcarthur> o_O
10:22:56 <merijn> portnov: It depends on the rest of the type system though
10:23:13 <merijn> I sorta skipped over the start of the convo :p
10:23:40 <portnov> i thought mathematics is exact science, and things are possible or not possible :)
10:23:56 <kmc> which means you're talking about two different problems
10:24:33 <merijn> portnov: Yes, but that relies on all people working in the same framework. Also, you are excluding the option of "undecided"
10:24:42 <kmc> i doubt Epigram has complete type inference; it's probably partial in the way discussed above
10:25:26 <merijn> kmc: Actually. I misremebered their claims. I just looked it up, they claim programs are strongly terminating and validity and typechecking are decidable
10:26:06 <portnov> hm. Type checking == type inferrence, no?
10:26:11 <merijn> portnov: No
10:26:29 <portnov> hm. Is it so in haskell/ghc?
10:26:34 <jmcarthur> no
10:26:45 <portnov> nice.
10:26:51 <merijn> portnov: Type checking is "given this function definition and this type signature, proof that the signature is valid" type inference is "find the valid signature"
10:26:55 <jmcarthur> haskell/ghc will sometimes require you to write a type signature but can still check that it's valid
10:27:06 <kmc> yeah
10:27:15 <portnov> ok
10:27:17 <kmc> vanilla Haskell 98 will only do this in cases where it's actually ambiguous what you meant
10:27:30 <merijn> portnov: Math being inconsistent according to Gödel's proof means that we cannot proof a truth value (truth value meaning either "true" or "false") for all possible math statements. So limiting things to "possible/not possible" is not strictly correct
10:27:37 <kmc> GHC will do it in some cases which are unambiguous but involve type system extensions it does not try to infer
10:28:15 <portnov> uh oh, Gödel is here too :)
10:28:31 <merijn> On slightly related note, Epigram being strongly terminating would make it not Turing-complete, right?
10:28:47 <sipa1024> agda isn't turing complete
10:28:47 <damike84> is there a way to define a NxM matrix in haskell and set cells?
10:28:55 <sipa1024> i suppose epigram isn't either
10:29:14 <jmcarthur> who cares about turing completeness?
10:29:34 <kmc> damike84, "set" in what way? in-place update, or update by producing a new matrix with most of the same values?
10:29:40 <jmcarthur> also, agda can write nonterminating programs, if that's what you mean, so i think is turing complete anyway
10:29:49 <kmc> yeah, you can disable the termination checker in agda
10:30:04 <merijn> jmcarthur: I don't so much care, just testing my understanding by using my knowledge to arrive at new conclusion and verifying my conclusions are correct :p
10:30:07 <kmc> i'm not sure how it ensures the type system is sound then
10:30:25 <damike84> kmc, i want to define "12x14", set some values and then the rest should be filled up with "0"
10:30:41 <kmc> damike84, how much Haskell do you know?
10:30:52 <damike84> kmc, small amount
10:30:59 <kmc> do you understand why i say that we don't typically "set" things?
10:31:03 <merijn> kmc: I suspect the type system isn't sound then :p
10:31:04 <jmcarthur> kmc: it flags functions that it can't prove as terminating as a warning
10:31:22 <portnov> kmc: are you asking «how many milliOlegs do you have?» ;)
10:31:24 <kmc> jmcarthur, is there any checking on whether you've used such a term in a type equality proof?
10:31:28 <damike84> kmc, yes - i know that i have to build lists - but in my case its impossible
10:31:37 <jmcarthur> kmc: i think it just makes the type checker undecidable
10:31:41 <kmc> damike84, you don't have to build lists.  there are many other data structures in Haskell besides lists
10:31:42 <merijn> kmc: Because afaik any consistent type system cannot be Turing complete and vice versa
10:31:47 <jmcarthur> kmc: so if type checking terminates, you're fine
10:31:49 <kmc> everyone is talking to me!
10:31:58 <kmc> madness
10:32:00 <merijn> You're popular! :p
10:32:02 <nlogax> kmc: hi!!
10:32:22 <kmc> damike84, i'm going to make some assumptions and declare that the datastructure you want is Data.Map
10:32:26 <kmc> with an (Int,Int) key or so
10:32:33 <kmc> damike84, i can elaborate on why, if you like
10:32:52 <damike84> kmc, i have a list with tplues [(9,2,3)] which means set row 9 col 2 to 3 - and then i want to return a 10x10 matrix where everything is 0 except (9,2)=3
10:34:04 <merijn> So essentially you want a sparse matrix?
10:34:13 <kmc> Data.Map
10:34:14 <kmc> ;)
10:34:36 <kmc> even ignoring sparseness, it has nicer functional-update than Array
10:34:54 <damike84> hmm
10:35:07 <damike84> i dont know how to apply map in this case
10:35:17 <kmc> :t foldr (\(x,y,v) -> M.insert (x,y) v) M.empty
10:35:18 <lambdabot> forall t t1 t2. (Ord t, Ord t1) => [(t, t1, t2)] -> M.Map (t, t1) t2
10:35:32 <kmc> damike84, start by reading the docs: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/
10:35:34 <byorgey> > foldr (\(x,y,v) m -> M.insert (x,y) v m) M.empty [(9,2,3), (7,4,1)]
10:35:34 <kmc> click on Data.Map
10:35:35 <lambdabot>   fromList [((7,4),1),((9,2),3)]
10:35:58 <damike84> kmc, i used map today in a simple situation ;)
10:36:10 <kmc> map != Data.Map
10:38:49 <jmcarthur> != /= /=
10:39:16 <damike84> kmc, haskell is too complicated for me i think ;))
10:39:30 <danharaj> haskell is less complicated than C++ :[
10:39:46 <damike84> imo not
10:39:48 <jmcarthur> faaar less complicated than C++
10:40:02 <danharaj> you don't know how complicated C++ is if you think Haskell is more complicated.
10:40:10 <danharaj> C++ is by far the most complicated language actually being used.
10:40:12 <kmc> most people who use C++ don't know how complicated it is
10:40:28 <damike84> what in C++ is complicated?
10:40:35 <jmcarthur> everything
10:40:39 <kmc> damike84, http://www.parashift.com/c++-faq-lite/
10:40:45 <kmc> this is off topic and going to become a flamewar
10:40:48 <jmcarthur> try checking up on the C++ spec and compare it to the haskell spec some time
10:41:30 <damike84> kmc, ok - but haskell trys to abstract every problem - that sucks. i spend the whole day solving a problem because of that syntax vodoo
10:41:30 <Rembane> I think Haskell is percieved as more complicated since it is built on a completely different abstraction level than i.e. C++
10:41:33 <jmcarthur> i don't think it's off topic at all
10:41:41 <Jafet> @quote c++
10:41:41 <lambdabot> ricky_clarkson says: I think IO should be called Kansas.
10:41:45 <danharaj> This is not flamewar material, this is objective fact. That C++ is complicated does not mean that it is a bad language. Haskell is not complicated, it is simply *different*.
10:41:53 <teratorn> damike84: is that a joke? you're asking what in c++ is _complicated_
10:41:54 <Jafet> @quote c\+\+
10:41:54 <lambdabot> qwe1234 says: c++ is the way it is for a very, very good reason.
10:42:10 <jmcarthur> damike84: then it's a philosophical difference. i see the greater ease of and more widespread use of abstraction as a good thing in haskell
10:42:28 <danharaj> I don't see how Haskell tries to abstract every problem?
10:42:33 <kmc> damike84, yes, it takes a long time to solve problems in Haskell when you are just starting out
10:42:36 <kmc> it is not an easy language to learn
10:42:40 <kmc> don't expect instant gratification
10:42:46 <sipa1024> haskell is very different from many languages, and that may take a while to get used to
10:42:48 <kmc> if this means the language "sucks" then you should probably move along
10:42:54 <kmc> but if you have patience, it will be rewarded
10:42:55 <teratorn> re: lambdabot, "we just aren't going to tell you what that reason is"
10:43:15 * jmcarthur thinks damike84 is a successful troll, even if unintentionally
10:43:24 <danharaj> I remember learning C++, god that was painful. So was learning Haskell. Perhaps you have forgotten how you learned your first language.
10:43:31 <Jafet> Wait till he asks about IO String
10:43:37 <dom96> What's the best way to check if a socket is still connected? I tried using hIsEOF although that doesn't work whenever my IRC Bot times out. Any ideas?
10:43:44 <danharaj> You mean Burrito String?
10:43:50 <jmcarthur> Sin String
10:43:54 <kmc> and most experiences "learning C++" involve learning about 10% of the actual madness buried within
10:44:07 <Jafet> dom96: you cannot. If it times out, you assume it was disconnected.
10:44:11 <danharaj> kmc: I was the guy who learned what pointer-to-member function dereferencing syntax is.
10:44:14 * danharaj shivers
10:44:17 <kmc> hahaha
10:44:22 <Jafet> dom96: you may want to read a network programming book.
10:44:24 <damike84> kmc, i wouldnt say that there a problems out there where haskell is the better choice - but for "simple" stuff it sucks
10:44:32 <teratorn> kmc: exactly.. people that think they "know" c++ (unless their last name is "Stroustrup") are just deluding themselves
10:44:32 <dom96> Jafet: I want to know when it times out.
10:44:35 <kmc> damike84, no, for "being a beginner" it sucks
10:44:40 <kmc> damike84, wait until you actually understand the language
10:44:41 <jmcarthur> damike84: how about an actual example?
10:44:41 <damike84> no problems out there i mean ;)
10:44:47 <Jafet> dom96: it times out when you decide it has timed out.
10:44:52 <kmc> damike84, i use Haskell for simple stuff all the time, because I spent 5+ years learning it
10:45:05 <jmcarthur> damike84: a reasoned argument would be much better accepted here, even if still controversial
10:45:07 <merijn> teratorn: Even Stroustrup has admitted he has no clue about C++
10:45:08 <danharaj> Simple stuff in Haskell tends to be one-liners when you know what you're doing.
10:45:13 <dom96> Jafet: huh?
10:45:13 <sipa1024> the easiest language is always the one you already know
10:45:21 <jmcarthur> hear hear, sipa1024 
10:45:22 <arcatan> dom96: IRC clients typically do it by pinging the server (PING irc command)
10:45:31 <damike84> jmcarthur, most of the i spend on programming n-tier stuff - simple data manipulations apps - and i like that work
10:45:35 <sipa1024> that doesn't mean that's the most appropriate :)
10:45:38 <Jafet> dom96: what does "timeout" mean?
10:45:38 <damike84> time
10:45:42 <teratorn> merijn: at times like this I always like to refer people to the C++ FQA
10:45:44 <dom96> arcatan: Yes, that's what i was going to do. I was wondering whether there is a better way.
10:45:58 <jmcarthur> damike84: i'm not sure how you think haskell makes that more difficult compared to C++
10:46:02 <kmc> damike84, you sound like you're about to join the proud ranks of people who spend two days trying to learn haskell, give up, want to blame someone else for lack of patience, write a big blog article "debunking the myth" of Haskell, and get mega karma on programming Reddit
10:46:09 <Jafet> damike: this channel doesn't exist to convince you to use Haskell. If you don't like it, go away.
10:46:13 <Jafet> That is all.
10:46:16 <jmcarthur> woah
10:46:20 <jmcarthur> calm down
10:46:24 <jmcarthur> (everybody)
10:46:33 <danharaj> NEVER
10:46:36 <thom_logn> NAZIS!!!
10:46:36 <dom96> Jafet: By timeout i mean when the server doesn't receive a PONG from the client.
10:46:43 * kmc sets off a pile of firecrackers
10:46:49 <dom96> Jafet: The server then disconnects the client.
10:46:54 <dom96> And i want to detect that.
10:46:56 <danharaj> I'm actually eating a sandwich, listening to music, and writing an instance for Comonad. I am totes relaxed.
10:47:03 <Jafet> dom96: a socket has no notion of client or server.
10:47:14 <Nibble> dom96: yo
10:47:21 <damike84> kmc, i think you are right ;)
10:47:23 <Nibble> still working on your bot
10:47:25 <dom96> Nibble: yes.
10:47:29 <jmcarthur> "* jmcarthur thinks damike84 is a successful troll, even if unintentionally"  <-- still holds :)
10:47:30 <sipa1024> dom96: you are talking about irc timeout
10:47:31 <Nibble> dom96: :(
10:47:36 <sipa1024> dom96: not socket timeout
10:47:39 <dom96> sipa1024: yes
10:47:42 <kmc> damike84, but you'll get some good Reddit karma out of it!
10:47:44 <kmc> ;)
10:47:47 <dom96> ^^ Like what just happened there.
10:47:49 <Nibble> dom96: you should receive a SIGNOFF message
10:47:57 <arcatan> but what dom96 wants to know if the remote end has closed the socket
10:47:58 <merijn> Jafet: You are wrong though about the fact that a socket times out when you want to. It times out when your *OS* wants to. (Which you could concievably influence)
10:47:59 <Jafet> sipa1024: eh? What's the difference?
10:48:11 <Jafet> Pah, details
10:48:12 <dom96> yes, what arcatan said.
10:48:20 <sipa1024> Jafet: irc has an own concept of timeout, namely no timely response to a ping command
10:48:38 <Jafet> sipa1024: and what determines "timely"?
10:48:41 <damike84> kmc, well - i can tell you: if i pass the lecture i will never to functional programming again ;) i dont like it and i will never like it - call me too stupid - but i dont like it
10:48:46 <sipa1024> some server-set constant
10:48:49 <damike84> do
10:48:56 <kmc> damike84, Haskell is also not the simplest functional language
10:49:10 <merijn> The IRC timeout is not really relevant to his problem. afaik he just want to check whether a sockets connection has been closed
10:49:11 <kmc> damike84, you could try Scheme, Standard ML, Clojure, ...
10:49:12 <damike84> haskell confuses me - got problems with writing :D
10:49:14 <Jafet> dom96: then the socket closes if you received the notice of it closing, and presumably has an error or EOF condition.
10:49:16 <jmcarthur> damike84: talk like that is unnecessary here though
10:49:21 <kmc> damike84, and you'll note i never called you stupid above.  just impatient
10:49:26 <tommd> kmc: Obviously it isn't lambda calculus, but why would you even bother to state that?
10:49:28 <jmcarthur> damike84: it just angers people. if you would like to use #haskell as a resource, don't be an ass about it
10:49:57 <dom96> Jafet: Well, i don't receive any message of it being closed, and as i said using hIsEOF doesn't work.
10:50:02 <kmc> damike84, i think any competent programmer can learn Haskell
10:50:12 <danharaj> I think anyone can learn Haskell :p
10:50:15 <kmc> it takes a long time; i think it took all of us a long time
10:50:22 <vegai> that's one way to define 'comptente programmer'
10:50:22 <damike84> jmcarthur, i respect that you like haskell - but i dont do it ;) i'm here because i have to solve problems with haskell in this spring
10:50:28 <jmcarthur> i think any competent non-programmer can learn it, even
10:50:36 <tommd> I think anyone can learn to put trolls on mute.
10:50:36 <jmcarthur> damike84: then shut up and solve problems
10:50:39 <merijn> damike84: On a related note, I didn't understand the idea of functional programming 3 years back. All my problems seemed needlessly complicated in a functional language (OCaml). flash forward 3 years later, I've had an epiphany and suddeny everything makes sense
10:50:42 <ray> i think any competent programmer is a contradiction
10:50:50 <Jafet> dom96: the TCP socket closes. Find out how you can check that.
10:50:57 <jmcarthur> damike84: we aren't very embracing of toxic attitudes here and my trigger finger is itching
10:51:11 <Nibble> jmcarthur: we aren't? 
10:51:13 <danharaj> jmcarthur: relax your nipples :o
10:51:13 <jmcarthur> if shapr was here you'd be gone already
10:51:17 <Nibble> I have completely misunderstood something here
10:51:24 <paolino> kmc, don't exclude incompetent, please :)
10:51:32 <jmcarthur> Nibble: certain types of trolls are better accepted than others
10:51:33 <Jafet> damike: so pissing us off before you start is supposed to help you? Interesting.
10:52:03 <jmcarthur> Nibble: constant complainers are different from constistently slow or unintelligible people
10:52:11 <dom96> Jafet: I heard that writing to the socket will throw an error when remote end closed the socket, not sure if that happens with haskell.
10:52:19 <jmcarthur> Nibble: complainers aren't likely to change, is my point
10:52:22 <Nibble> dom96: haskell uses magic
10:52:28 <Nibble> so that will not work
10:52:31 <jmcarthur> especially when they.. continue to complain after being advised not to
10:52:47 <danharaj> It's too, late he is already writing his reddit post about how mean and stupid #haskell is.
10:52:53 <jmcarthur> heh
10:53:07 <danharaj> how did that comma shift over one word to the left :o
10:53:20 <ray> that is called an off by one error
10:53:30 <Jafet> dom96: in Haskell, probably catch the exception that is thrown when reading from that socket.
10:53:34 <danharaj> is it related to off by some errors?
10:53:38 <kmc> jmcarthur, re your trigger finger:  "Do it or don't.  But I got someplace to be."
10:53:39 <kmc> ;)
10:53:46 <ray> nope
10:53:56 <jmcarthur> kmc: i believe in fair warning
10:53:58 <ray> off by one errors are almost conceptually different from off by two errors
10:53:59 <dom96> Jafet: What exception is thrown?
10:54:02 <Jafet> *whirrr* *click*
10:54:09 <ray> almost, because you can compose two off by ones to get something that seems to be an off by two
10:54:13 <Jafet> dom96: no idea, I've never programmed with Socket
10:54:30 <ray> but you can also compose two off by ones to get something that seems correct
10:54:47 <ray> anyway uh how long before hackage is back up
10:54:51 <vegai> I think you can find out that a socket has died only by reading from it and the read failing
10:55:00 <ray> someone said 3.5 hours but i didn't check what time they said it at
10:55:03 <vegai> but unix sockets are weird
10:55:12 <jmcarthur> kmc: "You don't know me, son, so let me put this to you plainly: If I ever kill you, you'll be awake. You'll be facing me."  ... Mal also says "And you'll be armed." but that doesn't actually apply here ;)
10:55:34 <kmc> :D
10:55:39 <Jafet> /mode duels?
10:55:40 <orlandu63> i have a question about sockets: do you _have_ to bind a socket to an address to communicate through it? or can you just pass the Socket around and send/receive data to it?
10:55:45 <kmc> wire quote vs. firefly quote, well played
10:55:47 <kmc> anyway i'll bbl
10:56:30 <applicative> tonkman , are you around?
10:56:55 <dcoutts__> orlandu63: those are not alternatives
10:57:39 <dcoutts__> orlandu63: you have to have hold of a socket to use it (though you can wrap a socket in a Handle, in which case you have to have hold of the handle)
10:57:45 <ray> you mean like passing a file descriptor?
10:58:05 <ray> not really (though you can pass file descriptors through sockets!)
10:58:49 <dcoutts__> orlandu63: as for binding, it depends on the protocol you're using, tcp yes, udp no
10:59:35 <newsham> perhaps you are interested in getsocketpair?
11:00:12 <newsham> err socketpair() rather
11:00:47 <paolino> it should be natural to keep hackage on a p2p protocol , as we are enough online to serve it
11:01:46 <damike84> kmc, but maybe i'm allowed to explain you my problem? ;)
11:02:04 <paolino> but I guess there is no standard protocol for the task
11:02:59 <orlandu63> let me rephrase: i'd like to use a Socket to pass buffered data between threads. is this possible to do without having to bind the socket to an fd or ip/port?
11:03:55 <sipa1024> at least in linux, a socket is a file descriptor
11:03:57 <Botje_> why not use a pipe for that?
11:03:58 <orlandu63> (sorry if i sound like an idiot; this is my first time working with threads and sockets)
11:04:10 <Botje_> or, in haskell, a Chan
11:04:21 <orlandu63> Botje_: i'll look into that
11:04:45 <jmcarthur> yeah sockets are overkill for interthread communication
11:04:59 <jmcarthur> MVar and Chan are reasonable enough
11:05:11 <jmcarthur> there's also STM for complex shared state
11:05:20 <paolino> sockets are for interprocess
11:05:31 <orlandu63> yeah, i'm currently using an MVar but i'd like to look at alternatives
11:05:36 <sipa1024> paolino: or intermachine :)
11:05:42 <jmcarthur> orlandu63: what's wrong with MVar?
11:06:00 <jmcarthur> what is it you are looking for in alternatives, i mean?
11:06:15 <paolino> sipa1024: yes
11:06:40 <lpsmith> Ok,  quick question
11:07:08 <lpsmith> I'm generating a file format that consists of both ascii and UTF-16 unicode mixed together
11:07:11 <tommd> dcoutts__: In a .cabal file I can't seem to guard the installation of extra data files based on a flag (ex: testing files in crypto-api).  Is this a known bug?  Shall I file?
11:07:35 <lpsmith> so is it faster to use hSetEncoding to go back and forth,  or should I handle the encoding myself?
11:08:27 <orlandu63> jmcarthur: with MVars, it seems you have to jump through hoops when working with buffered data
11:08:40 <jmcarthur> orlandu63: oh?
11:08:45 <jmcarthur> what kind of hoops?
11:08:51 <tommd> news to me
11:09:41 <jmcarthur> lpsmith: why not just try the easy way and then change to the hard way if it's too slow?
11:10:18 <lpsmith> heh,  I'm not sure what the "easy" way is yet,  though I'm inclined to not mess around with hSetEncoding
11:10:19 <orlandu63> say i have an MVar [String], and i want its head. i have to retrieve the list, take the head and place the tail in.
11:10:39 <orlandu63> seems inefficient to me for some reason
11:10:42 <jmcarthur> orlandu63: why would you only take its head?
11:10:50 <jmcarthur> orlandu63: what does this have to do with buffered data?
11:11:24 <orlandu63> jmcarthur: not sure. i use terms whose meanings i don't quite understand.
11:11:44 <dcoutts__> tommd: I think there is a ticket for it, lemme find it
11:11:57 <jmcarthur> orlandu63: if you are making some sort of a queue abstraction with MVar, Chan already does that for you
11:12:24 <paolino> @src Chan
11:12:24 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:12:33 <orlandu63> jmcarthur: queue, that's it :) okay, i'll take a look at it once hackage is back up
11:12:54 <jmcarthur> orlandu63: i wouldn't only take one character at a time though, unless this isn't going to be passing much data through
11:12:59 <jmcarthur> orlandu63: Chan is in base
11:13:02 <jmcarthur> no need for hackage
11:13:11 <dcoutts__> tommd: oh, course, hackage is down
11:14:00 <jmcarthur> orlandu63: what exactly is it that you are doing, btw? i've found that normally when somebody considers using Chan they may be an easier way to approach things
11:14:09 <jmcarthur> *there may
11:14:17 <jmcarthur> s/easier/more elegant/
11:15:08 <osaunders> @unfold
11:15:09 <lambdabot> Unknown command, try @list
11:15:12 <osaunders> @unwrap
11:15:12 <lambdabot> Unknown command, try @list
11:15:29 <osaunders> @list
11:15:29 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:15:52 <jmcarthur> why does lambda suggest @list instead of just giving that link?
11:15:58 <jmcarthur> *lambdabot
11:16:35 <sipa1024> maybe it used to give a list, until the list growed too long
11:16:56 <paolino> lazybot
11:17:04 <ymasory> i installed "cabal-install" on the latest ubuntu, but "cabal update" gets a timeout error. did i do something wrong?
11:17:09 <applicative> @type unfold  -- is that what you wanted osaunders?
11:17:10 <lambdabot> Not in scope: `unfold'
11:17:11 <jmcarthur> it could still just give a link instead of suggesting @list
11:17:22 <paolino> ymasory: the server is down
11:17:38 <jmcarthur> ymasory: it should be back up soon
11:18:09 <osaunders> applicative: No, what the thing that expands something written with do notation?
11:18:10 <applicative> ymasory, it's discussed on reddit.com/r/haskell  with the alleged hours 
11:18:19 <ymasory> thank you
11:18:26 <jmcarthur> osaunders: @undo
11:19:10 <orlandu63> jmcarthur: i'm creating a threaded chat server and client
11:19:12 <applicative> @undo do { number <- [1,2,3]; return number}
11:19:13 <lambdabot> [1, 2, 3] >>= \ number -> return number
11:19:29 <fengshaun> applicative, reddit.com/r/haskell -> bad request
11:20:18 <applicative> http://www.reddit.com/r/haskell/comments/e5db7/alert_hackage_downtime_tomorrow_0600_1200_pst/  that work?
11:20:27 <osaunders> jmcarthur: thnx
11:20:32 <ymasory> learn you a haskell uses the term "algebraic data type" but doesn't really explain it. what can i contrast algebraic data types with?
11:20:38 <orlandu63> jmcarthur: each client has its own thread that fills an MVar String with text inputted from the client. then a dedicated thread waits for that MVar String to fill, and sends its value to all connected clients
11:20:41 * applicative agrees that directing attention to redditland is bad
11:21:31 <jmcarthur> orlandu63: then why would you ever only take the head of the String?
11:21:41 <danharaj> I am lost without hackage :(
11:21:41 <orlandu63> jmcarthur: that was a contrived example
11:21:54 <jmcarthur> orlandu63: do you actually have something that you need that for?
11:22:01 <jmcarthur> orlandu63: if not, what's wrong with MVar?
11:22:15 <jmcarthur> danharaj: me too :(
11:22:20 <Saizan> ymasory: http://en.wikipedia.org/wiki/Algebraic_data_type <- maybe?
11:22:28 <osaunders> ymasory: Objects would be one example
11:22:32 <ymasory> Saizan: sort of over my head
11:22:51 <jmcarthur> i wouldn't try to contrast it with anything
11:23:08 <orlandu63> jmcarthur: yes. i was thinking of turning the MVar String to an MVar [String] under the assumption that, under high load, the MVar String may get overwritten before the dedicated thread can get to it.
11:23:09 <Saizan> ymasory: the idea is that they are those you can define with the data keyword
11:23:22 <orlandu63> i hope i make sense
11:23:29 <jmcarthur> orlandu63: personally i wouldn't worry about it
11:23:30 <osaunders> ymasory: Algebatic data types at their most basic are tagged unions.
11:23:41 <jmcarthur> orlandu63: the client threads will queue up appropriately anyway
11:23:52 * ymasory is thinking
11:23:54 <applicative> why are they supposed to be any more algebraic than anything else?
11:23:59 <jmcarthur> orlandu63: they may have to wait for the main thread, but do they really have processing they must do in the meantime anyway?
11:24:10 <osaunders> http://en.wikipedia.org/wiki/Tagged_union
11:24:18 <fengshaun> applicative, ah yes, that link works
11:24:18 <Saizan> ymasory: which let you compose tagged unions, records, functions spaces and recursion
11:24:37 <applicative> fengshaun, it suggests hackage should be up in 36 minutes
11:24:41 <orlandu63> jmcarthur: i guess not.
11:25:00 <orlandu63> jmcarthur: thanks for the elightenment :)
11:25:01 <fengshaun> oh good!
11:25:30 <jmcarthur> orlandu63: also, for the record, Chan is written in terms of MVar, so that overhead you were afraid of would still exist (but it would still be very small, btw)
11:25:32 <heatsink> applicative: ADTs correspond to algebraic structures http://en.wikipedia.org/wiki/Term_algebra
11:25:44 <paolino> it is possible , changing .cabal remote-repo field to point to someone .cabal/packages/hackage.haskell.org/ ?
11:26:09 <dcoutts__> paolino: if it's a local dir then you use the local-repo field
11:26:48 <paolino> dcoutts__ it is to serve some packages while the server is down
11:26:59 <applicative> hmm, heatsink, seems a little fancy.   
11:27:02 <damike84> does anybody know how to fix that problem http://codepad.org/WuDLJhpG ? AMg is [[Integer]] - so i dont understand the problem :(
11:27:10 <heatsink> fancy?
11:27:17 <dcoutts__> paolino: of course the problem is you're not likely to have a full set of packages
11:27:19 <orlandu63> jmcarthur: good to know
11:28:19 <applicative> ymasory, the main point -- our friends will correct us -- is that for any two types A and B, you have A + B , A x B, and A ^ B   -- i.e.  Either A B, (A,B) and (A -> B) as we call them.  Or that's the starting point
11:28:36 <joeyh> I have a stupid question, but well, Hoogle seems down -- how can I cast a FileOffset to an Integer?
11:28:39 <paolino> damike84: you must deconstruct AMg to use the function on its value
11:29:01 <ymasory> okay i think i'm getting the basic idea.
11:29:02 <jmcarthur> damike84: AMGraph is a different type from [Integer], and [[a]] also won't unify with [Integer]. to get the list in the AMgraph you will need to use pattern matching, and you will also have to correct the function that's manipulating it because it's expecting a [[Integer]] where you will be giving it [Integer]
11:29:05 <ymasory> thanks everyone
11:29:36 <jmcarthur> damike84: oh sorry, i misread the definition of AMgraph
11:29:54 <jmcarthur> damike84: it only the pattern matching thing. AMgraph is indeed wrapping [[Integer]], not [Integer] as i at first though
11:30:11 <applicative> ymasory, so for example, you'll have all the polynomials.  The famous topic of 'differentiation' of datatypes in connection with zippers is amusing in this connection.
11:30:28 <SonOfLilit> Hi
11:30:47 <SonOfLilit> Is it just me, or is hackage down?
11:30:50 <damike84> jmcarthur, i dont understand that :( [[a]] is a weak type - so why cant i pass [[Integer]]?
11:31:15 <applicative> Son of Lit http://www.reddit.com/r/haskell/comments/e5db7/alert_hackage_downtime_tomorrow_0600_1200_pst/
11:31:33 <jmcarthur> damike84: "foo :: AMgraph -> AMgraph"   <-- AMgraph != [[Integer]]
11:32:17 <SonOfLilit> Thanks
11:32:33 <damike84> jmcarthur, is there a way to apply matrixMap on the AMgraph?
11:32:37 <paolino> damike84: define type AMgraph = [Row]  is another solution
11:32:42 <jmcarthur> damike84: pattern matching
11:33:19 <joeyh> SonOfLilit:  been down for me for an hour or 2
11:33:40 <SonOfLilit> so, is there any way to go about installing haskell packages?
11:33:41 <jmcarthur> damike84: type is like C's typedef, but data is closer to C's struct
11:33:53 <RyanRN> Hey all — does anyone know if "cabal build" is capable of building just one executable or library and not all that are defined in the .cabal file?
11:33:57 <jmcarthur> damike84: so AMgraph is actually a different type from [[Integer]]
11:34:17 <dcoutts__> RyanRN: not yet, no
11:34:30 <jmcarthur> RyanRN: check the cabal documentation for flags
11:34:40 <jmcarthur> other than flags, no way that i know of
11:34:46 <damike84> jmcarthur, ok - so "foo m =" is wrong?
11:34:48 <paolino> damike84: http://en.wikibooks.org/wiki/Haskell/Type_declarations
11:34:50 <RyanRN> @dcoutts__ is there a tough technical barrier here, or just not gotten around to it?
11:34:51 <lambdabot> Unknown command, try @list
11:34:53 <jmcarthur> damike84: yes
11:35:14 <RyanRN> dcoutts__: is there a tough technical barrier here, or just not gotten around to it?
11:35:19 <dcoutts__> RyanRN: nothing especially tough, there's lots of features people want and not much dev time
11:36:16 <Eduard_Munteanu> Does anybody know a uniqueness types extension in a Haskell compiler? I had a look at them and they look interesting.
11:36:43 <Eduard_Munteanu> I could only find a paper on uniqueness types in Haskell.
11:37:02 <damike84> jmcarthur, ok - i'm too stupid for that :( i would guess "foo [[Row]] = " but that doesnt work either
11:37:07 <RyanRN> dcoutts__:  Understandable re: dev-time of course.   I ask about the difficulty because if it's obvious enough I can try to submit a patch ;-).  Usually I just use ghc directly during my dev cycle… I happen to have run into a sticky situation where that doesn't work.
11:37:20 <Eduard_Munteanu> damike84: what do you want to do?
11:37:20 <jmcarthur> damike84: what is it that you are learning from?
11:37:26 <RyanRN> Due to dependencies I've got mtl and monad-fd installed… so I can *only* build with cabal and its library-masking features.
11:37:28 <jmcarthur> @where lyah
11:37:29 <lambdabot> http://www.learnyouahaskell.com/
11:37:31 <RyanRN> But I don't want to build the whole project.
11:37:33 <jmcarthur> damike84: ^^ a good resource
11:37:38 <jmcarthur> for beginners
11:37:59 <damike84> Eduard_Munteanu, apply a function on each matrix element
11:38:28 <Funktorsalat> RyanRN: you could run cabal -v3 and see how it's invoking ghc
11:38:29 <paolino> damike84: it's foo (AMgraph m) = AMgraph $ ..., but read something if you can
11:38:30 <jmcarthur> damike84: pattern matching would look like foo (AMgraph m)... that solves half of your problem. the other half is foo's return type
11:38:54 <Eduard_Munteanu> damike84: I'd recommend using something else than lists of lists for representing matrices. If you used 2D arrays you could simply 'amap' on them.
11:39:00 <Funktorsalat> the package selection is a ghc feature, cabal just makes the commandline for you
11:39:03 <jmcarthur> Eduard_Munteanu: oh, no, don't push him
11:39:07 <Funktorsalat> (afaik)
11:39:27 <Eduard_Munteanu> Hm, yes, you're right.
11:39:36 <damike84> paolino, hmm - first time i see $ in haskell ;) thx
11:39:55 <RyanRN> Funktorsalat: Thanks!  That's a good idea.
11:40:05 <jmcarthur> :t ($)
11:40:06 <lambdabot> forall a b. (a -> b) -> a -> b
11:40:20 <dcoutts__> RyanRN: the flag you want is --hide-package
11:40:30 <dcoutts__> RyanRN: or make the setting persistent using ghc-pkg hide
11:41:07 <RyanRN> Double thanks — aww, but now you removed my incentive to try to come up with a patch for cabal ;-).
11:41:09 <Eduard_Munteanu> Anyway, my curiosity is whether uniqueness types would reduce IO bloat in function types. It still looks like World needs to be passed around in Clean.
11:41:16 <sipa1024> damike84: $ is just function application, so f $ g is equal to f g; however, f $ g x means f (g x) instead of (f g) x
11:41:35 <sipa1024> so it's used to override the priority of operators
11:41:41 <Nibble> @type $
11:41:42 <lambdabot> parse error on input `$'
11:41:45 <Nibble> @type ($)
11:41:46 <lambdabot> forall a b. (a -> b) -> a -> b
11:42:41 <dcoutts__> RyanRN: someone is currently working in that area to allow arbitrary dependencies between components within a package, so I expect that work will make it easier to add the facility to build individual components
11:43:51 <Eduard_Munteanu> Hm... would haskell.org be down for long?
11:44:01 <Eduard_Munteanu> s/would/will/
11:44:47 <dcoutts__> Eduard_Munteanu: unknown
11:44:54 <dcoutts__> it was not scheduled
11:45:11 <RyanRN> dcoutts__: Ah, ok, I'll leave it alone then.  Btw, is there any could solution for rampant duplication within a cabal file with multiple components?  I was just looking at the cabal file for nikola 0.1 which consists largely of 341 lines of duplicated options and module names.
11:45:20 <Eduard_Munteanu> I see.
11:45:27 <RyanRN> Err, any good solution that is.
11:45:39 <heatsink> Eduard_Muntenau: Uniqueness types improve the efficiency of in-place update.  However, you still need to pass values around just as much as in a language without uniqueness types.
11:45:46 <dcoutts__> RyanRN: yes, you can now have an exe depend on the lib
11:46:01 <RyanRN> dcoutts__:  A good solution meaning something hopefully better than #include + having to run the C preprocessor on the .cabal file
11:46:20 <RyanRN> dcoutts__:  Cool, so that's falling out of this new functionality as well.  Nice.
11:46:31 <dcoutts__> RyanRN: actually that works already
11:46:47 <dcoutts__> the new thing is letting libs depend on exes :-)
11:46:54 <dcoutts__> ie preprocessors within the same package
11:47:53 <Eduard_Munteanu> heatsink: yeah, that's another reason they looked interesting. I wonder how they compare with strictness analysis.
11:48:34 <damike84> paolino, now i understand the problem ;) but i like learning by examples :) next time i know
11:49:00 <Eduard_Munteanu> heatsink: because it seems to me binding monadic values to functions explicitly does get old values out of scope just as well as uniqueness types.
11:49:31 <heatsink> What do you mean "get old values out of scope"?
11:50:47 <Eduard_Munteanu> heatsink: createSomeMonadicValue a >>= useIt >>= useIt'   -- a is not bound in useIt and useIt' scope.
11:51:23 <Eduard_Munteanu> Although do-notation still keeps those in scope.
11:52:21 <Eduard_Munteanu> heatsink: so my question is whether augumenting Haskell's monads with uniqueness types is worth.
11:52:47 <Eduard_Munteanu> (I've seen claims that Clean is faster.)
11:54:04 <kmc> well, they're used for different things
11:54:45 <kmc> most monads aren't anything like uniqueness typing
11:54:47 <Eduard_Munteanu> kmc: yeah, this mostly pertains to IO.
11:54:52 <kmc> some Clean advocates are not clear on this point
11:55:39 <Eduard_Munteanu> kmc: though I notice some sort of ST + uniqueness types could do IO.
11:56:04 <kmc> i'm not sure you'd need to change the user-visible API for IO to take advantage of uniqueness types
11:56:45 <Eduard_Munteanu> I see.
11:56:51 <kmc> if GHC supported uniqueness types, couldn't you work them in at the level where IO is implemented by State# passing?
11:57:09 <kmc> there's already some special-case hacks there — see "-fno-state-hack" in the GHC manpage
11:57:13 <Eduard_Munteanu> Yes, that's what I'm thinking about.
11:58:18 <Eduard_Munteanu> But would there be any advantage over strictness analysis? GHC could nevertheless figure out it can do in-place updates without uniqueness types.
11:59:15 <Eduard_Munteanu> Some cases are trivial, like using the Identity monad to do imperative computations.
11:59:47 <heatsink> Uniqueness types might be useful for references that escape from the monad code (like in the function argument of modifyIORef).
12:00:08 <yitz> Eduard_Munteanu: foo >>= (\a -> aNotBound) is no different than foo >>= (\_ -> aNotBound) in GHC I believe. So using do is no worse.
12:00:37 <Eduard_Munteanu> yitz: hm, yeah.
12:00:50 <alpounet> it's foo >> aNotBound
12:02:06 <Eduard_Munteanu> Although there is the advantage that uniqueness types give static guarantees.
12:02:42 <Eduard_Munteanu> In Haskell, there are no guarantees it won't violate referential transparency.
12:03:45 <kmc> implementing IO in terms of uniqueness types would potentially catch bugs in the implementation of the IO monad
12:03:59 <yitz> Eduard_Munteanu: violate ref.trans>? how do you mean?
12:04:25 <srobertson> I'm trying to describe the abstract syntax tree of PTX, a statically-typed language with strict but inconsistent type rules (e.g. mad.wide would have either the Haskell signature (I16->I16->I32->I32) or (I32->I32->I64->I64), where I32 is either s32 or u32).
12:04:53 <srobertson> any clues or examples as to how to do this so that Haskell's type checking and introspection are active?
12:05:57 <heatsink> It might be too complicated to be worth encoding in the type sytem, but you could do it with type families
12:06:15 <heatsink> mad_wide :: t -> t -> Widened t -> Widened t
12:06:22 <heatsink> type instance Widened I16 = I32
12:07:25 <srobertson> heatsink: at first glance that seems like it might do the trick. thanks!
12:08:53 <Eduard_Munteanu> yitz: that happens if an older reference escapes outside.
12:09:32 <Eduard_Munteanu> yitz: like having a function getStuff :: RealWorld -> Value, and using it twice.
12:09:57 <FireFly> <kmc> wire quote vs. firefly quote, well played
12:10:04 <FireFly> ...even in #haskell, I get accidentally highlighted
12:10:41 <heatsink> The awesome thing about haskell is I can write sophisticated algorithms without knowing how they work.  The terrible thing about writing sophisticated algorithms without knowing how they work is I can't debug them.
12:11:25 <Eduard_Munteanu> I could only find this article on implementing them in Haskell, I'm not sure there's any prototype out there... http://people.cs.uu.nl/ariem/INF-SCR-06-008.pdf
12:12:08 <Eduard_Munteanu> FireFly: hm, irssi here doesn't highlight me if my name doesn't occur first.
12:12:13 <Eduard_Munteanu> Or something like that.
12:12:23 <yitz> @quote firefly
12:12:23 <lambdabot> No quotes match. You speak an infinite deal of nothing
12:12:40 <FireFly> Hm
12:19:30 <mm_freak> i've said this before, and i have to say it again:  yesod is AWESOME
12:20:02 <mm_freak> even the best frameworks in other languages are nowhere near yesod
12:20:38 <mm_freak> it only leaves one wish open:  the scaffolding tool installs too much stuff
12:21:08 <mm_freak> good for learning yesod, but for a serious project i'd start from scratch
12:21:14 <joe6> i have been going through the xmonad code and it is not that beautiful. Is it just that I am not looking at it right? without knowing the high-level details?
12:21:55 <joe6> sorry, do not mean to offend. 
12:22:02 <joe6> Just wanted to check what others feel.
12:22:03 <mm_freak> joe6: it's probably related to X11 requiring lots and lots of boilerplate
12:22:31 <mm_freak> honestly even after two trials i have no idea how to write a window manager
12:23:37 <mm_freak> even after reading the xmonad code
12:23:43 <joe6> oh, ok.
12:26:11 <sm> mm_freak: agreed I think (yesod)
12:26:52 <sm> sometimes I find the types and TH and specialised templating systems a little much to swallow, but I haven't used it all that much yet
12:27:05 <KSkrzet> hackage seems is up, but "cabal upload" is hanging for me
12:27:10 <KSkrzet> is this a known issue?
12:27:11 <sm> and everything else out there is harder
12:28:20 * hackagebot loadavg 0.1 - Load average parsing from /proc/loadavg and bindings to getloadavg (3)  http://hackage.haskell.org/package/loadavg-0.1 (KrzysztofSkrzetnicki)
12:29:43 <KSkrzet> weird
12:30:10 <Eduard_Munteanu> haskell.org still seems down.
12:30:38 <KSkrzet> well, http://hackage.haskell.org/packages/hackage.html isn't
12:30:58 <Eduard_Munteanu> Hm, yes, that works for me too.
12:31:44 <KSkrzet> still, 'cabal uploads' acts strange
12:31:45 <KSkrzet> █▓▒░tener@arch-nsn░▒▓██▓▒░ sob lis 13 09:23:24 
12:31:45 <KSkrzet> ~/doc/haskell/loadavg/ cabal upload dist/loadavg-0.1.tar.gz 
12:31:45 <KSkrzet> Uploading dist/loadavg-0.1.tar.gz...
12:31:45 <KSkrzet> ^C
12:31:45 <KSkrzet> █▓▒░tener@arch-nsn░▒▓██▓▒░ sob lis 13 09:26:51 
12:31:47 <KSkrzet> ~/doc/haskell/loadavg/ cabal upload dist/loadavg-0.1.tar.gz
12:31:49 <KSkrzet> Uploading dist/loadavg-0.1.tar.gz...
12:31:51 <KSkrzet> ^C
12:32:06 <mm_freak> sm: well, i'm using hamlet only with TH
12:32:11 <KSkrzet> but the package arrived, despite the fact cabal-install hanged
12:32:13 <mm_freak> i don't like the quasiquoting stuff that much for hamlet
12:32:22 <mm_freak> but it's great for routes and Persist
12:32:58 <mm_freak> KSkrzet: "cabal upload" somestimes takes up to 30 seconds for me
12:34:36 <KSkrzet> mm_freak: I hit ^C after 3 minutes, so it's more than 30 sec
12:35:10 <sm> mm_freak: the other problems I have are to do with deployment: how to customise templates without a relink, and how to find template files at runtime without having to hard-code an absolute path or require the user to be in a certain directory or do other high jinks
12:35:12 <mm_freak> ok, that's unusual
12:35:30 <sm> this may not be yesod-specific
12:35:49 <mm_freak> sm: i think the usual way to deploy a yesod application is in source code form
12:36:01 <joe6> haskell programs are mostly input -> type -> some other type -> output. i think that the key to understanding haskell programs is to understand the types being used. just curious, if there is a documentation tool that can read a haskell program and display the types being used and the morphisms between types.?
12:36:30 <Eduard_Munteanu> joe6: Haddock?
12:37:13 <sm> mm_freak: and I want to deploy binaries. I'd even be happy if a simple cabal install always worked. I think that's possible but still a bit tricky wrt dev/user environment setup. I'll have to try again one of these days
12:37:32 <sm> joe6: also Hoogle
12:37:41 <sm> and maybe SourceGraph
12:38:17 <joe6> SourceGraph seems interesting. Thanks.
12:38:42 <mm_freak> joe6: haddock generates documentation with types and links from your source code
12:39:22 <mm_freak> sm: the biggest problem i see is that distributions installed on servers generally have a very outdated version of both GHC and libraries
12:39:40 <mm_freak> for example debian still has 6.8 from what i've seen on most servers
12:40:15 <mm_freak> i noticed that in a very unpleasant way, developing an application locally and trying to compile it on a debian server
12:40:26 <mm_freak> i had to rewrite half of the code to make it compatible
12:40:55 <dominikh> 6.8.2 is the current ghc version in Debian Stable
12:41:17 <dominikh> 6.12.3 in Arch Linux (hardly a server OS of course)
12:43:10 <sm> and current ubuntu has 6.12.1
12:43:36 <KSkrzet> mm_freak: you can do a --prefix'ed installation
12:43:43 <sm> being restricted to stable debian release packages is certainly tough for deploying haskell apps
12:45:28 <paolino> and you need 512 MB of ram to link them
12:48:43 <sm> argh, no hoogle
12:50:05 <sm> what function does filter p ls and filter (not p) ls at the same time ?
12:50:10 <yitz> traditionally, you *want* older software for a production server, on the assumption that it has had more time to have the bugs worked out.
12:50:17 <conal> :ty partition
12:50:25 <yitz> that doesn't work so well with quickly advancing technologies though
12:50:41 <yitz> or with keeping up with quickly advancing security needs
12:50:49 <conal> sm: partition :: (a -> Bool) -> [a] -> ([a], [a])
12:51:05 <conal> sm: i think that's the one
12:51:25 <conal> is lambdabot asleep? or did i get ":ty" wrong?
12:51:53 <sm> conal: you're right, thanks!
12:51:55 <sipa1024> @vixen are you alive?
12:51:56 <lambdabot> i truely am
12:51:59 <conal> cool :)
12:52:07 <conal> @ty partition
12:52:08 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:52:29 <conal> ah.
12:52:45 <conal> oh. i'm thinking of ghci syntax
12:53:05 <sipa1024> :t partition
12:53:06 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:53:18 <conal> hrmf.
12:53:44 <Eduard_Munteanu> yitz: that works well only if upstream backports fixes, otherwise not so much.
12:54:00 <mm_freak> i have arch linux, which has GHC 6.12
12:54:10 <Eduard_Munteanu> It's not always about bugs introduced by new features.
13:00:04 <zomg> å
13:00:15 <zomg> oops. ignore that
13:00:19 <Nibble> å
13:00:23 <Nibble> zomg: swe+
13:00:29 <zomg> fi
13:00:48 <sm> ghci syntax would be better for lambdabot
13:03:41 <pastorn> if i'm writing to a socket
13:03:58 <pastorn> but i have two threads both trying to write, can i fuck that up?
13:04:42 <pastorn> or is the kernel managing that so i that i can't accidentically send one message while sending another?
13:04:56 <sipa1024> what kind of socket?
13:05:15 <aavogt> will modifications to http://new-www.haskell.org be lost when it's made the default?
13:05:49 <aavogt> that seems to be the case
13:05:51 <zomg> Usually if two threads try to do something to something like a socket at the same time that would cause a concurrencyexception or something
13:06:03 <zomg> Then again this is Haskell, who knows what it'll do
13:09:23 <sipa1024> pastorn: some sockets preserve message boundaries, others don't
13:09:48 <sipa1024> if not, the kernel will consider the socket a stream of data, and so should userland that calls it
13:10:42 <pastorn> sipa1024: so i'm better off writing a lock thingy, right?
13:10:47 <sm> zomg: I think the haddock will tell you
13:10:54 <sm> eg for System.IO
13:11:40 <sipa1024> pastorn: haskell may have a locking mechanism itself to prevent this (eg. libc's fopen/fread/fwrite does)
13:12:40 <pastorn> sipa1024: yeah, but what i'll have is multiple threads which will all want to write to the same socket
13:13:00 <pastorn> so i guess i'll just make a lock type and put that in some shared state
13:13:14 <pastorn> type Lock = TMVar () -- should work
13:14:15 <Eduard_Munteanu> pastorn: http://stackoverflow.com/questions/1981372/are-parallel-calls-to-send-recv-on-the-same-socket-valid
13:14:52 <Eduard_Munteanu> pastorn: that seems to say the operations are atomic. For send() it might work as long as you pack your data properly.
13:14:57 <pastorn> Eduard_Munteanu: <3 <3 <3
13:15:24 <Eduard_Munteanu> pastorn: you might want to check it out for yourself though, I'm not sure.
13:15:42 <Eduard_Munteanu> For recv() it's harder to get good semantics, even if atomic.
13:15:58 <Eduard_Munteanu> Because pieces of data might end up in different threads.
13:16:36 * hackagebot csound-expression 0.1.0 - Csound combinator library  http://hackage.haskell.org/package/csound-expression-0.1.0 (AntonKholomiov)
13:16:53 <vf> haskell.org looks down
13:16:58 <sipa1024> Eduard_Munteanu: are you talking about the send() system call?
13:17:04 <vf> anyone knows what happened?
13:17:05 <Eduard_Munteanu> A single serializing thread might be better. In general multi-threaded network apps use different threads for *different* sockets.
13:17:07 <pastorn> well, i'll have my recieved data put on a channel to some distributor thread which will then write it to the appropriate chan/thread (which the third thread will be blocking on)
13:17:11 <Eduard_Munteanu> sipa1024: yes.
13:17:38 <tommd> @seen bos
13:17:39 <preflex>  bos was last seen on #haskell 23 hours, 4 minutes and 57 seconds ago, saying: inits
13:17:39 <lambdabot> Unknown command, try @list
13:17:47 <tommd> good quote.
13:17:48 <pastorn> Eduard_Munteanu: Bah! That sounds very un-erlang-y
13:17:54 <sipa1024> Eduard_Munteanu: the problams is that a single write call from haskell may result in multiple send() calls internally, and those may be interleaved with send() calls from another thread
13:18:01 <sipa1024> s/ams/em/
13:18:13 <Eduard_Munteanu> sipa1024: ouch.
13:18:18 <pastorn> sipa1024: oh, ok
13:18:21 <pastorn> locks it is then
13:18:46 <sipa1024> that is, unless haskell/your runtime does some locking by itself
13:18:50 <Eduard_Munteanu> I'd really use a thread to do the whole serialization.
13:19:23 <Eduard_Munteanu> Something like a multiple producers - one consumer paradigm.
13:19:32 <pastorn> Eduard_Munteanu: hmm... that sounds kinda good
13:20:39 <Eduard_Munteanu> pastorn: yeah, as I said, usually multithreaded servers assign one thread per client, so the sockets are thread-local.
13:20:56 <pastorn> serializer inpCh = atomically (readTChan inpCh) >>= putOnSocket >> serializer inpCh
13:21:37 * hackagebot usb-enumerator 0.2.0.1 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.2.0.1 (BasVanDijk)
13:21:48 <Eduard_Munteanu> I'm not familiar with stuff trying to use the same socket on multiple threads.
13:23:17 <yitz> yay! hackage is back up
13:23:54 <djahandarie> I guess I don't really understand why foldl (\rev x -> Cons x rev) with Vecs creates an infinite type error in Haskell but works in Agda
13:24:47 <jmcarthur> :t foldl
13:24:48 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:24:55 <sipa1024> :t foldl (\rev x -> Cons x rev)
13:24:56 <lambdabot>     Couldn't match expected type `b -> a -> a'
13:24:56 <lambdabot>            against inferred type `Keyword'
13:24:57 <lambdabot>     In the expression: Cons x rev
13:25:20 <jmcarthur> :t foldl (\rev x -> x : rev)
13:25:21 <lambdabot> forall b. [b] -> [b] -> [b]
13:25:40 <jmcarthur> oh is Cons length indexed or something?
13:25:42 <djahandarie> Yes
13:25:46 <djahandarie> I guess Agda's foldl has a different type
13:25:53 <jmcarthur> probably
13:26:10 <djahandarie> (b n -> a -> b (Suc n)) ... or something
13:26:25 <jmcarthur> it could probably be written in haskell too
13:27:47 <jmcarthur> foldl : ∀ {a b} {A : Set a} (B : ℕ → Set b) {m} → (∀ {n} → B n → A → B (suc n)) → B zero → Vec A m → B m
13:27:52 <McManiaC> hoogle down?
13:27:57 <djahandarie> Right
13:27:59 <jmcarthur> yeah that's very different :)
13:28:23 <jmcarthur> the result type is indexed
13:28:52 <jmcarthur> djahandarie: foldl₁ looks like haskell's foldl
13:29:18 <jmcarthur> well, haskell's foldl1 i guess
13:29:33 <jmcarthur> but it's result isn't indexed, is the point
13:29:36 <jmcarthur> *its
13:29:39 * hackagebot usb-safe 0.11.0.1 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.11.0.1 (BasVanDijk)
13:29:49 <jmcarthur> <3 hackage
13:30:27 <danharaj> hackage LIVES
13:30:38 <danharaj> haskell.org still down :<
13:30:49 <djahandarie> Yeah, two seperate servers
13:30:57 <djahandarie> Hackage was known to be going down
13:31:02 <djahandarie> haskell.org... just went down
13:31:29 <djahandarie> Why can't all these financial groups and people provide us with some damn cash? :P
13:32:37 <dcoutts__> djahandarie: hackage is hosted by Galois, it went down due to electrical work in their office block
13:32:39 * hackagebot diagrams 0.2.2.1 - An EDSL for creating simple diagrams  http://hackage.haskell.org/package/diagrams-0.2.2.1 (BrentYorgey)
13:32:55 <dcoutts__> djahandarie: haskell.org has indeed been slightly flaky recently
13:33:00 <danharaj> Should we really trust hackage with a company named after a guy who died in his 20's in a duel ;p
13:33:27 <dcoutts__> djahandarie: using GSoC cash we're renting a new commercial server and haskell.org will be migrating there soon
13:33:38 <dcoutts__> see http://new-www.haskell.org/haskellwiki/Haskell
13:34:19 <dcoutts__> new-www.haskell.org is an alias for lambda.haskell.org, which is the new box
13:34:46 <dcoutts__> same for the community server, it's migrating to a VM on lambda
13:38:01 <djahandarie> Sounds good
13:42:52 <anonymous1994> Hello, I found something that I could use to grasp Haskell a bit. It's called SoccerFun. I can't seem to create a data type Position (http://hackage.haskell.org/packages/archive/SoccerFun/0.4.1/doc/html/SoccerFun-Geometry.html), can someone show me how I should create a "position"? 
13:43:43 <mauke> Position 0 0
13:43:47 <tommd> anonymous1994: 1) select a name 2) "Position x y"
13:44:02 <anonymous1994> well I tried, I loaded the main program
13:44:12 <anonymous1994> and tried that in GHCi
13:44:17 <tommd> import SoccerFun.Geometry
13:44:22 <anonymous1994> already did
13:44:34 <tommd> Care to paste the session with errors?
13:44:36 <tommd> @where paste
13:44:36 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
13:45:09 <anonymous1994> A very stupid question how can I select the error in GHCi?
13:45:16 <anonymous1994> I can't seem to select it in Windows 7 Ultimate
13:45:32 <tommd> Like any other terminal program you should be able to highlight the text and copy/paste (or middle click in X)
13:45:38 <Zao> anonymous1994: Depending on command prompt mode, either rightclick, mark, press enter.
13:45:44 <tommd> Then you have an interface problem to report to Microsoft.
13:45:51 <Zao> Or click the system menu, edit, mark, enter
13:46:07 <mauke> using <enter> to copy? genius!
13:46:07 <Zao> (select your text between the Mark command and pressing enter)
13:46:09 <anonymous1994> it's not actually a command prompt, I just clicked on ghci.exe?
13:46:17 <Zao> mauke: There's a quickedit mode for pansies too.
13:46:25 <mauke> anonymous1994: then what is ghci running in?
13:46:27 <Zao> anonymous1994: It's running in a console window, so close enough.
13:47:16 <anonymous1994> I'm going to write it. "*Main > Position 0 0", "<interactive>:1:0: Not in scope: data constructor 'Position'"
13:47:29 <Zao> mauke: You're in a modal copy mode, so it doesn't really matter which key they chose, so why not <Enter>?
13:47:37 <Zao> anonymous1994: ...
13:47:50 <anonymous1994> <Enter>?
13:48:19 <Zao> As in, the key named "Enter/Return".
13:48:19 <vf> [23:43] <tommd> import SoccerFun.Geometry
13:48:37 <anonymous1994> Well I'm loading it in a module that is loaded by Main
13:48:47 <anonymous1994> should I reimport it again??? :|
13:48:51 <anonymous1994> in Main?
13:49:09 <mauke> no, in ghci
13:49:24 <vf> just import it into ghci and try
13:49:29 <anonymous1994> okay
13:49:45 <anonymous1994> :|?
13:49:50 <anonymous1994> How come this works? :(
13:50:26 <danharaj> haha, conal I like how you provided a synonym Behaviour == Behavior in reactive :p
13:50:28 <anonymous1994> Main loads > some file > some file imports SoccerFun.Geometry.. then I should expect that Main loads that too / imports that too right?
13:50:48 <vf> it depends on how you import this
13:51:31 <vf> if you have hidden import (like import BlaBla (list to import) ) - this won't work
13:51:52 <anonymous1994> hmm.. icic
13:52:11 <anonymous1994> THANKS!
13:53:37 <ddarius> anonymous1994: No, you shouldn't expect that.  You import Prelude which imports GHC.Base among many other modules, you shouldn't expect your namespace to have all those functions in them now.
13:53:46 <vf> and no, imports from some file are not visible to main, just re-ckecked this
13:54:09 <ddarius> It would defeat the point of modules to do so.
13:54:59 <vf> is there some mirror with gtk2hs docs?
13:55:22 <vf> I need them now, but haskell.org still down
13:55:40 <anonymous1994> thanks guys!
13:58:23 <danharaj> @pl (\t x -> t)
13:58:24 <lambdabot> const
13:58:29 <danharaj> <_< brain fart
14:00:08 <Nibble> vf: use new-www.haskell.org
14:00:35 <danharaj> Is there a functional reactive library that a) uses relative time and b) enforces causality?
14:00:48 <vf> already tried - 404
14:01:04 <vf> for http://new-www.haskell.org/gtk2hs/ I mean
14:02:07 <dcoutts__> vf: you can build the gtk2hs docs yourself
14:03:32 <hpc> anonymous1994: a bit late, but modules can export other modules; write something like: module Foo (module Bar) where import Bar; import Baz; foo = quux
14:03:53 <hpc> importing Foo won't give you Foo.foo, but it will give you everything from Bar
14:04:23 <vf> <dcoutts__> good idea, trying to google out how.. would be great if you point me
14:04:46 <dcoutts__> vf: cabal install gtk --enable-documentation
14:04:57 <vf> thx
14:05:11 <dcoutts__> though presumably you've got gtk installed already, so you'd need to --reinstall
14:06:00 <vf> yep, already found it out
14:11:13 <tolkad> how can I make no argument type families in haskell?
14:11:40 <kmc> there are no type families in haskell
14:11:51 <tolkad> ghc haskell?
14:11:59 <tolkad> the equivalent of minBound at the type level
14:12:27 <kmc> minBound belongs to a class, which has a type argument
14:12:44 <edwardk> tolkad that is called a 'type' =)
14:12:55 <tolkad> something like: class (T ~ a) => C a where { type T :: * }
14:13:01 <kmc> i'm not sure how you'd build this equivalent
14:13:06 <kmc> what you mean by that
14:13:16 <edwardk> tolkad: 'type T = ...
14:13:27 <edwardk> tolkad there are no arguments to parameterize it on, so it doesn't need to be in a class
14:13:53 <joe6> cabal is so slow and hogs up the machine.
14:13:55 <edwardk> and it isn't a family, its just a type =)
14:14:09 <dcoutts__> joe6: how so? which operations?
14:14:21 <tolkad> edwardk: but if I could do that, I could have an implicit class constraint
14:14:24 <joe6> Linking takes forever
14:14:38 <joe6> even cabal update takes some time.
14:14:55 <alpounet> edwardk, well, a single-child family
14:15:03 <edwardk> tolkad: you can do that with a fundep
14:15:06 <dcoutts__> mm, linking is a ghc issue
14:15:14 <edwardk> tolkad: class C a | -> a where ...
14:15:17 <dcoutts__> joe6: yes, update is slow, we're working on a more incremental update
14:15:24 <tolkad> so after I do « class (T ~ a) => C a where { type T :: * } », « f :: T -> Int » is equivalent to « f :: C a => a -> Int »
14:15:31 <joe6> dcoutts__: that's cool. thanks.
14:15:51 <tolkad> will that work after superclass constraints are implemented?
14:15:52 <joe6> aren't the updates as compressed files?
14:16:13 <edwardk> it works now, so if it doesn't work then a lot of us will bitch ;)
14:16:25 <tolkad> wait my example works?
14:16:26 <edwardk> its the only good way to make closed universes
14:16:42 <edwardk> tolkad: no, the class C a | -> a;
14:16:55 <tolkad> but that's different. I want to be able to have multiple class instances
14:17:24 <edwardk> your type alias doesn't make sense though, type T :: * inside the class instance -- has to name every argument to your class
14:17:42 <dcoutts__> joe6: yes, it's compressed but it's still large (about 2Mb atm)
14:17:54 <tolkad> edwardk: it does?
14:17:58 <tolkad> edwardk: I didn't know that
14:18:20 <kmc> tolkad, what problem are you actually trying to solve?
14:18:36 <ddarius> tolkad: You know where they probably state such things?  The documentation.
14:18:39 <kmc> tolkad, if you want a class plus a value that provides evidence of membership in the class, you could use a GADT
14:20:19 <tolkad> oh wait, I don't need what I asked for. I can just make the type a class argument
14:21:12 <joe6> how do I install data.binary using cabal?
14:21:26 <Saizan>  cabal install binary
14:21:36 <Saizan> because that's the package name
14:21:46 <dcoutts__> joe6: the thing to do is work out which package name you want, given the module you want
14:22:03 <tolkad> http://hackage.haskell.org/package/binary-0.5.0.2
14:22:23 <tommd> joe6: cabal update ; cabal install binary
14:22:24 <joe6> ok, thanks.
14:22:27 <tolkad> joe6: if you aren't sure of the package name, find it on hackage
14:22:55 <tommd> You can use Hayoo to find package names (sometimes).
14:22:56 <aristid> dcoutts__: i started with the partial downloader by generating test data btw :D https://github.com/aristidb/incremental-hackage
14:23:03 <joe6> tolkad: thanks, will do. I am trying to install lambdabot and sourceGraph, but am running into trouble.
14:23:47 <joe6> There are files missing in the `binary-0.5.0.2' package
14:23:52 <tolkad> caball install lambdabot; caball install SourceGraph
14:23:53 <tommd> yeah, lambdabot is pretty crusty code.
14:23:59 <tolkad> joe6: full error message?
14:24:09 <tolkad> joe6: pastebin it if it is too long
14:24:17 <tolkad> http://pastebin.com/
14:24:28 <tommd> joe6: I have binary 0.5.0.2 installed fine, I don't think there are missing files.
14:24:33 <joe6> tolkad: sure, thanks.
14:24:56 <dcoutts__> aristid: I see
14:26:34 <tolkad> since I saw the generalized newtype deriving type system bug, I'm kind of scared to use the extension. is there a guide anywhere on how to use it safely?
14:27:07 <aavogt> tolkad: I think people need a guide to hit that bug usually
14:27:16 <joe6> reinstall fixed the binary package issue.
14:27:24 <alpounet> tolkad, byorgey wrote a blog post about it a while ago
14:28:58 <tolkad> meh, I'll just keep avoiding it
14:32:57 * hackagebot atomo 0.2.1 - A highly dynamic, extremely simple, very fun programming  language.  http://hackage.haskell.org/package/atomo-0.2.1 (AlexSuraci)
14:51:51 <joe6> Could not find module `System.Posix.Signals': -- when installing lambdabot
14:51:57 <joe6> apt-get install libghc6-unix-compat-dev
14:52:08 <joe6> i did the above but looks like it needs more
14:52:14 <joe6> It is a member of the hidden package `unix-2.4.0.2'.
14:52:28 <joe6> and the unix package does not install when i add it to the build command.
14:52:36 <joe6> any thoughts, please?
14:52:53 <ymasory> has anyone had success getting leksah to install on ubuntu 10.10?
14:53:10 <ymasory> 11.04 will apparently have a haskell-leksah package which is nice, but until then ...
14:53:18 <kmc> joe6, the unix package should come with Haskell Platform, on unix systems
14:53:28 <kmc> it comes with GHC even
14:53:51 <kmc> my guess is lambdabot has old dependencies?
14:54:18 <joe6> haskell-platform is already the newest version.
14:54:32 <joe6> that is what apt-get says about haskell-platform
14:54:36 <tommd> as I said aboce, lambdabot is bit rotted.
14:54:40 <tommd> *above
14:55:03 <joe6> ok, will not bother with it..
14:55:12 <kmc> it might be fixable
14:55:21 <tommd> Sure, but it does need fixing.
14:55:25 <tommd> by andy
14:55:28 <tommd> bye bye
14:55:37 <tommd> He never talks anymore, just comes in and out.
15:00:50 <danharaj> does anyone know the language pragma for functional dependencies in ghc?
15:01:15 <kmc> FunctionalDependencies
15:01:19 <danharaj> <3
15:01:27 <kmc> ghc --supported-languages
15:05:53 <Twey> [@ twey peordh ] % ghc --supported-languages | wc -l
15:05:54 <Twey> 65
15:05:57 <Twey> Woah
15:07:23 <sbahra> When will the Haskell site be back up?
15:10:45 <kmc> can anyone tell me about throwDyn? I guess it's part of OldException, but docs aren't loading
15:12:40 <KSkrzet> kmc: on most systems you also have docs with your GHC installation
15:12:59 <kmc> yeah, found them just now
15:12:59 <kmc> thanks
15:17:50 <kmc> @tell joe6 http://hpaste.org/41441/building_lambdabot_on_latest_h
15:17:50 <lambdabot> Consider it noted.
15:21:36 <EvanCarroll> god i hate rwh.
15:21:47 <alpounet> why ?
15:21:52 <EvanCarroll> for the life of me 90% of it is so badly worded I have no idea what it is talking about.
15:22:01 <aristid> hmm
15:22:06 <Heffalump> people seem to like LYAH
15:22:10 <aristid> looks like opinion is divided on rwh
15:22:12 <aristid> i liked it.
15:22:16 <alpounet> i liked it too
15:22:19 <EvanCarroll> LYAH is awesome. Seriously, awesome.
15:22:25 <hpc> ^
15:22:29 <alpounet> IMO, they're complementary
15:22:31 <kmc> EvanCarroll, you could ask here for clarification on RWH's wording
15:22:35 <aristid> lyah is nice, but i think rwh allowed for more rapid learning
15:22:39 <kmc> maybe from one of the authors even ;)
15:22:49 <aristid> kmc: heh
15:23:01 <kmc> fwiw i've found the bits of RWH i read to be quite readable, but obviously opinions can differ
15:23:06 <alpounet> you can't get help from Stroustrup on ##C++, see ?
15:23:09 <kmc> hehe
15:23:13 <alpounet> advantage to Haskell
15:23:15 <kmc> you can't get help from SPJ here :/
15:23:17 <EvanCarroll> I'm reading this brief districting snippet on Page 155. It is telling you of a trick of for "Show [Char]", I understand the problem from the wording, but I have no idea how the conclusion is:
15:23:36 <alpounet> kmc, well, he posts on -cafe at least
15:23:38 <kmc> EvanCarroll, chapter and section? sorry, i don't have the dead-tree
15:23:46 <alpounet> Stroustrup doesn't post on clc++m of csc++
15:23:49 <EvanCarroll> "At least sometimes, ten, we can avoid the need for the OverlappingInstances extension ith a little bit of lateral thinking."
15:23:52 <alpounet> s/of/nor/
15:23:59 <EvanCarroll> kmc: page 155, chatper 6.
15:24:03 <kmc> alpounet, he has a profile on haskellers.com too.  "20 years of Haskell experience, I was on the Haskell 98 committee"
15:24:07 <kmc> kinda makes the rest of our profiles look pretty bad
15:24:14 <alpounet> haha yeah
15:24:18 <alpounet> I saw that
15:24:21 <alpounet> i laughed 
15:24:26 <EvanCarroll> kmc: I understand the problem, I have no idea how it distribing a solution that does not involve "OverlappingInstances".
15:24:36 <alpounet> his profile is like "well, i know a bit of haskell yes"
15:24:40 <EvanCarroll> describing*
15:25:00 <kmc> EvanCarroll, without showList, you'd need separate instances for «(Show a) => [a]» and for «[Char]»
15:25:02 <kmc> those would overlap
15:25:44 <kmc> the solution is that each instance «Show a» knows how to show 'a' as well as '[a]'
15:25:52 <EvanCarroll> I don't get it.
15:25:53 <EvanCarroll> =(
15:25:54 <kmc> the latter function is showList
15:26:15 <EvanCarroll> http://book.realworldhaskell.org/read/using-typeclasses.html
15:26:24 <kmc> so usually «showList xs» is equivalent to «shows xs»
15:26:40 <kmc> but «showList "abc"» dispatches to the Char instance, which can do the custom [Char] code
15:27:01 <kmc> and then «instance (Show a) => Show [a]» is implemented in terms of showList
15:27:10 <kmc> EvanCarroll, what part don't you get?
15:27:13 <EvanCarroll> aparently, some 20 people have commented about this confusion on the books comments online
15:28:22 <kmc> sorry, i said "usually «showList xs» is equivalent to «shows xs»".  i should have said "always"
15:28:33 <kmc> because <kmc> and then «instance (Show a) => Show [a]» is implemented in terms of showList
15:31:04 <aristid> the real solution is to make String a newtype.
15:32:14 <ddarius> Both Simon Marlow and Simon Peyton Jones have been in this channel.
15:32:29 <ddarius> Admittedly, relatively rarely for SPJ.
15:32:39 <kmc> what nick does SPJ use?
15:32:44 <ddarius> simonpj
15:32:49 <kmc> EvanCarroll, i can try to explain more, if you give me something to go on
15:32:51 <kmc> lambdabot, seen simonpj
15:32:57 <kmc> preflex, seen simonpj
15:32:57 <preflex>  simonpj was last seen on #ghc 2 years, 64 days, 8 hours, 25 minutes and 12 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
15:33:19 <hpc> it seems he went away for another moment
15:34:39 <EvanCarroll> kmc: I just don't get how it is *NOT* an overlapping instance
15:34:45 <kmc> which?
15:34:52 <EvanCarroll> any possible implimentation
15:34:58 <kmc> there is only one instance under consideration
15:35:03 <kmc> instance (Show a) => Show [a]
15:35:10 <kmc> what does it overlap with?
15:35:24 <kmc> the point is that we *don't* need instance Show [Char], which *would* overlap
15:35:30 <EvanCarroll> how do you define that to get the instance for Char ?
15:35:35 <kmc> what do you mean?
15:35:52 <EvanCarroll> (a) I thought the difficulty here was the instance for "string"
15:35:56 <EvanCarroll> and not just Char
15:35:59 <EvanCarroll> but [Char]
15:36:01 <kmc> type String = [Char]
15:36:04 <kmc> EvanCarroll, it is
15:36:08 <kmc> let me just write out an example
15:36:14 <EvanCarroll> Right, so how do you write the code to do Show String
15:36:21 <EvanCarroll> kmc: Cool
15:36:32 <mauke> instance (Show a) => Show [a] where show = showList
15:37:53 <ddarius> EvanCarroll: String is supported through a hack.
15:38:01 <ddarius> Namely the showList function mauke pointed out.
15:38:56 <ddarius> Oddly, I don't think I've seen anyone ever actually use this hack for their own types.
15:39:26 <opqdonut> what type of hack is it exactly?
15:39:30 <mauke> other types don't have their own literal list syntax
15:39:56 <hpc> :t ''
15:39:57 <lambdabot>     lexical error in string/character literal at character '\''
15:40:08 <opqdonut> hmm, it's just a custom showList for char
15:40:12 <hpc> D: crappy client
15:40:21 <opqdonut> and the only reason why showList exists is strings, basically?
15:40:26 <mauke> opqdonut: yes
15:40:27 <alpounet> :t chr
15:40:28 <lambdabot> Int -> Char
15:40:29 <ray> hence hack
15:40:33 <alpounet> > chr 0
15:40:34 <lambdabot>   '\NUL'
15:40:56 <ray> i guess you could write your own showLists
15:41:58 <ddarius> mauke: instance Show MLExpr where showList es = "["++intersperse "; " (map show es)++"]"
15:42:07 <EvanCarroll> kmc: no rush, but you're still writing the example?
15:42:40 <mauke> ddarius: yeah, but you still can't write [1; 2] in your Haskell code
15:42:41 <kmc> EvanCarroll, http://hpaste.org/41444/the_showlist_trick
15:42:47 <ddarius> mauke: So?
15:42:53 <mauke> ddarius: and show is supposed to be valid source syntax
15:42:55 <tolkad> Will this work when superclass constraints are implemented? « class (T a ~ a) => C a where { type T a : *; f :: a -> a }; g :: T a -> a; g = f »
15:43:02 <ddarius> mauke: The Report doesn't say that.
15:43:08 <mauke> ddarius: sure, it's informal
15:43:18 <ddarius> > show (1/0)
15:43:19 <lambdabot>   "Infinity"
15:43:20 <kmc> EvanCarroll, this shows the trick, ignoring irrelevant details of the actual Show class
15:43:32 <ddarius> mauke: Apparently, even the standard instances don't obey that.
15:43:41 <mauke> ddarius: but I think it's at least part of the reason why no one overrides showList
15:43:51 <tolkad> > getRoundingMode
15:43:51 <lambdabot>   Not in scope: `getRoundingMode'
15:44:19 <EvanCarroll> kmc: how is MyShow Char not an overlapping instance with MyShow a ?
15:44:43 <mauke> EvanCarroll: there is no MyShow a instance
15:44:45 <kmc> EvanCarroll, there is no "instance MyShow a"
15:44:51 <hpc> oh wow, that's disgusting
15:44:56 <EvanCarroll> oh
15:45:08 <hpc> the showList it uses is for a different instance
15:45:18 <kmc> instances of MyShow: Char, Int, [a]
15:45:32 <kmc> each has a different outermost type constructor
15:47:22 <EvanCarroll> kmc: could you also define three non-overlapping instances, using instance (MyShow a) => MyShow [a] where
15:47:26 <EvanCarroll> gah
15:47:33 <EvanCarroll> kmc: could you also define three non-overlapping instances, using instance (MyShow Char) => MyShow [Char] where
15:47:40 <kmc> no
15:47:50 <EvanCarroll> And, doesn't all of these methods require TypeSynonymInstances ?
15:48:08 <ddarius> EvanCarroll: What type synonyms are there?
15:48:09 <kmc> «instance MyShow [Char]» overlaps «instance MyShow [a]»
15:48:20 <kmc> EvanCarroll, TypeSynonymInstances is purely syntactic sugar
15:48:28 <kmc> you can always write the expansion yourself
15:48:30 <ddarius> Also, instance MyShow [Char] is not legal Haskell 98.
15:48:47 <kmc> with TSI you write «instance Foo String»; without TSI you write «instance Foo [Char]»
15:48:53 <kmc> but that's irrelevant to my code and irrelevant to the showList trick
15:49:56 <kmc> that code i pasted is Haskell 98 except that Data.List is a hierarchical module name ;)
15:50:14 <alpounet> hierarchical module names are forbidden in H98 ?
15:50:24 <kmc> yep
15:50:27 <alpounet> wow
15:50:28 <ddarius> alpounet: They are syntactically invalid.
15:50:29 <EvanCarroll> I'm still confused, why couldn't you write "(MyShow Char) => MyShow [Char]"
15:50:38 <tolkad> is it ever possible to have different instances of a class have different kind arguments?
15:50:40 <kmc> EvanCarroll, because it would overlap with (MyShow a) => MyShow [a]
15:50:53 <alpounet> ddarius, yeah ok
15:50:53 <ddarius> The only difference the proposed but never ratified (until 2010) hierarchical modules extension added was to allow "." in module names.
15:50:54 <mauke> also, I don't think MyShow Char is valid
15:50:58 <alpounet> it just doesn't allow "." in modules
15:51:00 <alpounet> yeah ok
15:51:02 <hpc> also because you can just say MyShow [Char]
15:51:02 <tolkad> like instance C (T :: * -> *); instance C (S :: *)
15:51:10 <kmc> tolkad, no
15:51:13 <kmc> not in GHC
15:51:14 <EvanCarroll> right, but if you didn't write the generic MyShow [a], you could write three non-overlapping instances for each list type right?
15:51:22 <EvanCarroll> not that it would be a good idea
15:51:25 <mauke> not in H98
15:51:28 <kmc> EvanCarroll, oh, sure
15:51:30 <kmc> (also, three?)
15:51:35 <ddarius> mauke: In the context constraints, it isn't valid or necessary.
15:51:38 <kmc> you could write instances for [Int] and [Char]
15:51:45 <EvanCarroll> kmc: 2, =)
15:51:49 <kmc> but this way gives you all the lists
15:51:53 <kmc> including [[[[Int]]]] and such
15:52:15 <EvanCarroll> right. kmc, I'm going to paste this example as a comment in the book
15:52:17 <kmc> also, Haskell 98 does not allow instances like [Int] and [Char]
15:52:20 <kmc> EvanCarroll, go ahead
15:52:21 <EvanCarroll> i think a lot of others need ittoo
15:52:51 <sipa1024> why not? which instances would it allow?
15:52:53 <kmc> in Haskell 98 the type getting an instance must have the form (C a b c ...) where C is a type constructor and a, b, c are the correct number (possibly zero) type variables
15:53:13 <kmc> you can put constraints on a,b,c,... but that does not affect legality or overlapping of the instance "head"
15:53:26 <kmc> so "Char" and "[a]" are both valid but not "[Char]"
15:53:37 <sipa1024> so ([] a) ?
15:53:43 <sipa1024> *and
15:53:47 <kmc> so "Char" and "[] a" are both valid but not "[] Char"
15:53:54 <ddarius> The FlexibleInstances extension is what removes this restriction.
15:53:57 <sipa1024> oh nvm
15:53:58 <tolkad> I saw that Ωmega has polymorphism between different kind-levels. are there any plans to implement something similar in haskell?
15:53:59 <kmc> so "Char" and "Maybe a" are both valid but not "Maybe Char"
15:54:04 <kmc> tolkad, uhc has it
15:54:09 <sipa1024> yes, sorry, i misread
15:54:31 <kmc> tolkad, http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
15:54:46 <shachaf> You can fake it the way Text.Printf does, though, with a class "IsChar".
15:55:03 <kmc> yeah, that's silly
15:55:09 <EvanCarroll> kmc: thanks, g2g now. i've been staring at this for a while.
15:55:21 <EvanCarroll> I think i got it ;)
15:56:24 <kmc> cool :)
15:56:25 <kmc> ttyl
15:56:31 <jmcarthur> tolkad: no idea, but i want it
15:56:43 <jmcarthur> uhc does indeed have it, but that's not very useful for me
15:56:51 <jmcarthur> i am very indoctrinated to the ways of ghc at this point
15:57:08 <danharaj> is there a mirror for the ghc library docs?
15:57:11 <alpounet> darcs get the ghc repo
15:57:12 <jmcarthur> i like too many extensions
15:57:14 <alpounet> and implement it man
15:57:14 <pumpkin> if they implement GADTs and Type Families, I'll move
15:57:37 <jmcarthur> i'd like to play with omega a little
15:58:04 <jmcarthur> agda fans will have to forgive me. i'm kind of attracted to phase distinction
15:58:18 <ddarius> jmcarthur: So roll up your sleeves and add it to GHC.
15:58:49 <ddarius> pumpkin: What about all the GHC-only libraries?
15:59:01 <jmcarthur> ddarius: that takes time that i could spend on other things :(
15:59:32 <alpounet> is there any interface to google translate from haskell ?
15:59:58 <Axman6> i believe there is, i think that manatee guy made one for his irc client
16:00:23 <alpounet> oh it seems there is
16:00:43 <alpounet> http://hackage.haskell.org/package/gt-tools
16:00:44 <alpounet> hooray
16:00:52 <pumpkin> ddarius: I guess that might be a pain to give up
16:00:54 <pumpkin> :(
16:06:26 <ddarius> Curses.
16:06:42 <danharaj> The library or...?
16:07:23 <Eduard_Munteanu> Is there a tool that takes a Haskell program as a specification and outputs some C code, some sort of implementation skeleton, that can be completed to make up a full implementation?
16:08:02 <Eduard_Munteanu> It'd be neat to use Haskell for designing _and_ implementing stuff in other languages.
16:08:31 <Axman6> well, you can use Atom i think, thought it's designed for something slightly different
16:08:36 <ddarius> danharaj: Zipping of IEnumerables is a standard extension method in .NET 4 but not 3.5.
16:08:48 <danharaj> ah
16:09:14 <tolkad> what I meant was, will haskell ever have level polymorphism
16:09:26 <Eduard_Munteanu> Axman6: did you mean that for me? I'm not sure how that helps.
16:09:32 <danharaj> I'm trying to design a functional reactive system with no notion of the future.
16:09:36 <tolkad> like data T :: *n where ...
16:09:36 * fryguybob has zip sprinkled around several .NET projects :(.
16:09:38 <danharaj> Thus establishing causality.
16:09:43 <pumpkin> tolkad: level polymorphism or polymorphism at different levels?
16:09:59 <pumpkin> tolkad: the former, I'd say probably not
16:10:10 <tolkad> pumpkin: the former
16:10:17 <tolkad> why not? it looks cool
16:10:42 <pumpkin> well, you can probably some "autolifting"
16:10:44 <raichoo> level polymorphism? someone played with omega? ^^
16:10:53 <tolkad> raichoo: well I was reading about it a bit
16:10:56 <pumpkin> but that's not what I'd consider level polymorphism
16:11:42 <raichoo> tolkad: It's pretty cool. Too bad it's strict.
16:12:34 <tolkad> I wouldn't need to write a « data Bool = True | False; data TFalse; data TTrue ». I could write: « data Bool :: *n where { True :: Bool; False :: Bool } »
16:12:50 <pumpkin> tolkad: what about functions that operate on Bool?
16:12:52 <tolkad> and use True and False as values OR types
16:13:04 <tolkad> pumpkin: they are also level polymorphic
16:13:09 <pumpkin> tolkad: what if they don't terminate?
16:13:19 <tolkad> pumpkin: then compilation wont terminate
16:13:20 <ddarius> Y not
16:13:29 <pumpkin> tolkad: many people aren't a fan of that
16:13:36 <tolkad> pumpkin: I don't see why
16:13:45 <pumpkin> if you accept nonterminating compilation, shit becomes a hell of a lot easier
16:13:50 <Eduard_Munteanu> > fix not
16:13:53 <lambdabot>   mueval-core: Time limit exceeded
16:13:58 <Eduard_Munteanu> Woo :)
16:14:08 <Eduard_Munteanu> Heh.
16:14:30 <tolkad> pumpkin: Someone can write a program that takes such a large amount of time to terminate that it never will during the computers lifetime anyway
16:14:41 <flippo> Non-terminating compilation relieves constipation?
16:14:51 <tolkad> pumpkin: there's no functional difference between that and non-termination
16:14:54 <pumpkin> tolkad: most type-level stuff tends not to behave like that
16:14:57 <ksf> I don't think the issue is termination, but being able to run unproven programs in general.
16:15:06 <mauke> if you accept nonterminating compilation, why have separate compilation?
16:15:27 <mauke> just check everything at runtime
16:15:37 <tolkad> pumpkin: unless of course you can prove that haskell has some reasonable compilation time relative to program length
16:15:37 <ksf> oh you absolutely do want to have terminating compilation.
16:15:44 <Eduard_Munteanu> Wasn't there a GHC bug that resulted in non-termination? I think it was related to lambdas.
16:15:50 <tolkad> it's still there
16:15:56 <pumpkin> Eduard_Munteanu: there's an inliner bug with a nasty recursive data type
16:16:07 <Eduard_Munteanu> \x -> x x or something like that
16:16:15 <ksf> they rewrote the inliner for ghc7
16:16:18 <mauke> Eduard_Munteanu: that's just a good old type error
16:16:19 <pumpkin> tolkad: no, the typechecking is still exponential, but tends not to be for most common type-level patterns
16:16:23 <Eduard_Munteanu> I see.
16:16:47 <hpc> :t \x -> x x
16:16:48 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
16:16:48 <lambdabot>     Probable cause: `x' is applied to too many arguments
16:16:48 <lambdabot>     In the expression: x x
16:16:51 <tolkad> Eduard_Munteanu: try compiling this: http://pastebin.com/QTnTSw7P
16:17:46 <tolkad> pumpkin: well I don't care if compilation doesn't halt as long as there's an easy way to ask the compiler what it is currently evaluating
16:17:47 <Eduard_Munteanu> tolkad: hm, makes sense.
16:18:15 <pumpkin> tolkad: most people still do, but you're welcome to make an implementation that has the things you want :P
16:18:23 <pumpkin> it'd be interesting
16:18:53 <tolkad> in C I can write a program with macros that will take an insane amount of time to compile
16:18:55 <Eduard_Munteanu> Heck, I'd have non-termination at compile time if it meant guaranteed termination at runtime :)
16:19:21 <tolkad> perhaps that isn't relevant though
16:19:25 <Eduard_Munteanu> tolkad: I think you can make the C compiler spin infinitely
16:19:27 <sipa1024> Eduard_Munteanu: loi
16:19:35 <mauke> #include __FILE__
16:19:45 <hpc> haha
16:19:46 <mauke> tolkad: I'd like to see that
16:20:40 <sipa1024> mauke: technically, that's the preprocessor going in a loop, not the compiler
16:21:38 <ddarius> CPP's macro language has no constructs to produce loops, however you can set things up to nest arbitrarily deep and have the nesting grow exponentially so that you can emulate Turing-completeness well enough and this is what the CPP part of boost does.
16:22:54 <Eduard_Munteanu> Heh, C's preprocessor is more like Haskell in that regard.
16:23:07 <Eduard_Munteanu> Haskell has no explicit looping constructs either.
16:23:15 <mauke> yes, it does: fix
16:23:29 <hpc> mauke: syntactic looping mechanism
16:23:30 <aristid> or just recursion
16:23:36 <aristid> recursion does not work in CPP
16:23:49 <ddarius> Eduard_Munteanu: CPP doesn't have recursion.
16:23:51 <Eduard_Munteanu> Fix is still recursion.
16:24:19 <Eduard_Munteanu> ddarius: how so?
16:24:30 <Eduard_Munteanu> I can even pass parameters by #defining some value.
16:24:50 <mauke> Eduard_Munteanu: because there is no recursion
16:25:12 <Eduard_Munteanu> mauke: how does self-referential include not count?
16:25:33 <hpc> Eduard_Munteanu: preprocessor
16:26:14 <mauke> Eduard_Munteanu: how do you use those #define parameters?
16:28:52 <tolkad> mauke: one moment
16:29:25 <Eduard_Munteanu> mauke: #ifndef FOO; #define FOO 1; #endif; #if (FOO == 1); #define FOO 2; #endif;  [...] #if (FOO == 5); #define I_M_STOPPING_NOW; #else; #include __FILE__; #endif
16:29:38 <tolkad> mauke: well, no purpose writing it all out. you #define x y y y\n #define z x x x; etc.
16:29:55 <Eduard_Munteanu> I'm not sure at this hour whether self-referential define works though.
16:30:05 <Eduard_Munteanu> like #define FOO FOO + 1
16:30:28 <mauke> that "works" in that FOO will expand to FOO + 1
16:30:52 <tolkad> mauke: you can encode an exponential amount of text using a series of #define's
16:31:02 <mauke> tolkad: I see
16:32:19 <pumpkin> that's similar to how you make GHC's typechecking exponential
16:35:13 <ksf> isn't cpp turing complete, or at least nearly?
16:35:21 <ksf> (that is, you have to drive it correctly)
16:35:41 <aristid> ksf: not at all
16:35:46 <sipa1024> i believe i read it wasn't
16:35:55 <ksf> there's some pretty impressive stuff you can do with it.
16:35:59 <pumpkin> http://stackoverflow.com/questions/319328/writing-a-while-loop-in-the-c-preprocessor
16:36:06 <sipa1024> but if you use the preprocessor until you reach a fixpoint, it would be
16:36:08 <aristid> ksf: for example in boost.cpp, all numbers are limited to the 0-255 range
16:36:26 <ksf> http://ldeniau.web.cern.ch/ldeniau/oopc.html
16:36:38 <alpounet> aristid, that's to match the impl limitations
16:37:30 <aristid> alpounet: no, that's how the preprocessor is defined
16:37:46 <aristid> basically, recursion is explicitly outlawed in the language spec
16:37:56 <kingping> moin
16:38:02 <ksf> well yes, and in haskell all numbers are limited to whatwasit 2^128^(2^128) or something.
16:38:12 <kingping> Something happened with haskell.org
16:38:34 <ksf> (2^128)^(2^128) 
16:38:34 <aristid> ksf: but that's quite a difference from 0-255, which in turn is only achieved with insane tricks
16:38:52 <aristid> ksf: i don't really understand how boost.preprocessor works, i just know i couldn't do that
16:39:05 <aristid> i can use it, of course
16:40:02 <tolkad> if the compiler doesn't halt, it's the programmers fault
16:40:12 <hpc> ^
16:40:24 <hpc> it takes quite the effort to make it happen, generally
16:40:32 <ksf> yeah macro languages aren't the rage anymore.
16:40:34 <dolio> ksf: I suspect it's smaller than that.
16:40:38 <alpounet> aristid, i took a look at their code several times
16:40:41 <ksf> tex definitely is turing complete, though.
16:40:46 <alpounet> but decided some day that i was wasting my time
16:41:17 <aristid> alpounet: it's one of the craziest parts of boost
16:41:18 <sipa1024> ksf: so is postscript
16:41:19 <ksf> and cpp could have less restrictive implementations, so there you go.
16:41:30 <dolio> 2^(2^64) at most, unlesss you're on a fancy architecture.
16:41:32 <aristid> ksf: no. not a conformant implementation
16:41:40 <ksf> ps isn't a macro language afaiu, though.
16:41:40 <ddarius> dolio: Well physics will kick in before that limitation is hit.
16:41:45 <dolio> And I think GMP is more limited than that.
16:41:47 <aristid> ksf: the STANDARD requires that it be so restrictive.
16:41:53 <iago> hi, someone has defined some metrics for Haskell code in order to have a measure its quality? Something like no very big modules, no big function definitions, etc ?
16:41:54 <alpounet> aristid, yeah definitely
16:42:00 <alpounet> the others aren't that crazy actually
16:42:27 <aristid> alpounet: heh, yeah, mostly they are better. ironically boost.pp is often easier to use tho
16:42:33 <mauke> iago: I don't think that's how quality works
16:42:49 <alpounet> aristid, have you ever tried boost.proto ?
16:42:54 <kmc> <tolkad> if the compiler doesn't halt, it's the programmers fault  <--- and the programmer should respond by trolling #ghc
16:43:07 <ddarius> mauke: Shh.  I want to sell tools that improve code "quality."
16:43:08 <aristid> alpounet: well, i read about it
16:43:13 <iago> mauke, I appreciate your opinion but... independently of my own opinion I should ask for them :P
16:43:15 <ksf> iago, have a look at hlint
16:43:39 <ksf> iago, code should be elegant.
16:43:56 <ksf> let no boilerplate survive
16:44:00 <alpounet> aristid, you really should take a look some time
16:44:03 <alpounet> it's a great piece of code
16:44:04 <tolkad> kmc: it is the logical conclusion, captain (read in spock's voice)
16:44:10 <ksf> the rest is pretty standard.
16:44:26 <kmc> bbl
16:44:43 <iago> ksf, well in general the idea is to forbid things that are known to make code harder to read
16:44:55 <ddarius> PostScript is a pretty nice language.  Most of its issues are library related and due to being targetted at printers.
16:45:01 <ksf> well, don't go uselessly pointless.
16:45:22 <ksf> there's a line there that crosses from elegance straight into obfuscation.
16:45:37 <ksf> anyway, elegant code _is_ easy to read (at least to the initiated)
16:45:54 <tolkad> one man's elegance is another man's obfuscation? :P
16:45:57 <ksf> don't use ContT when all you need is if?
16:46:19 <ksf> I think that when defined in such a way, there's an infinite amount of rules.
16:46:47 <tolkad> it would be cool if haskell had lazy type evaluation
16:47:00 <Eduard_Munteanu> Hm, yes, C++ template hacks seem more powerful than CPP.
16:47:09 <hpc> tolkad: it would also kinda suck :P
16:47:10 <ksf> iago, one idea would be to post your code, #haskell is famous for its golf handicap.
16:47:24 <Eduard_Munteanu> Although with that nesting limitation, you might as well build your numbers explicitly, I think that's possible.
16:47:25 <tolkad> hpc: lol maybe
16:47:29 <hpc> spend all that effort making compile errors powerful just to make them diverted to runtime
16:47:35 <ddarius> Since the type level is strongly normalizing, there is no difference between strict and non-strict.
16:47:37 <hpc> or something
16:48:05 <tolkad> no, I mean lazy in the sense of I could make an infinite list of types and still have the compiler halt
16:48:38 <Eduard_Munteanu> Being lazy in types? How does that work? :/
16:48:41 <iago> ksf, well, the point is that I need it for a course-work, that's why I say "independently of my opinion". I should measure the quality of the code in some way
16:48:54 <iago> I agree with tolkad 
16:49:06 <iago> (" one man's elegance is another man's obfuscation? :P" :)
16:49:25 <Eduard_Munteanu> ksf: golf handicap?
16:49:31 <ksf> code golfing.
16:49:59 <tolkad> iago: long functions aren't necessarily bad
16:50:08 <tolkad> iago: especially if they are do blocks
16:50:15 <iago> I may assume LHint suggestions to be standard, since I know many projects use it to improve their code
16:50:28 <hpc> functions like to trend towards bad with size though
16:50:33 <mauke> did you mean: hLint
16:50:42 <iago> sorry, hLint
16:50:44 <iago> sure
16:50:50 <ksf> nested where/let clauses are a bad sign.
16:51:04 <hpc> as are deep do blocks
16:51:08 <iago> I'm talking about what ksf is talking :)
16:51:09 <ksf> (unless they take no parameters and are _really) short
16:51:23 <iago> things that are known to be bad (in general)
16:51:51 <ksf> (or come by the name of f and are only let-bound because a lambda can't pattern-match properly)
16:52:35 <ksf> it's hard to say without seeing actual code
16:52:45 <tolkad> I can tell you that mine is terrible
16:52:57 <ksf> as haskell in general is quite elegant.
16:53:23 <ksf> after hlint is through with your code it should be reasonably good.
16:54:11 <ksf> then there's wars like (const . Foo $ 1) vs. (const $ Foo 1)
16:54:32 <hpc> that's a war?
16:54:39 <ksf> yeah I do the latter.
16:54:47 <hpc> same, but only sometimes
16:54:55 <ManateeLazyCat> Morning all. :)
16:55:33 <ksf> ...when you turn that into pointless, you're likely to have it take a Foo not an Int.
16:55:36 <hpc> this channel is so funny; there's a page of lines from people with very short names, then ManateeLazyCat shows up
16:55:53 <ManateeLazyCat> hpc: :)
16:55:53 <ksf> that is, the $ should come before the semantical, not syntactical last argument.
16:55:56 <ddarius> hpc is easily amused
16:56:09 <iago> ksf, well, the idea is to get a measure, a module with just one "bad-thing" will get a good rank
16:56:10 <tolkad> ksf: why not just (const (Foo 1))
16:56:25 <ksf> tolkad, that's lisp.
16:56:26 <iago> if a module have lot of "bad-things", then we could assume something is bad...
16:56:29 <ddarius> People like to make up arbitrary rules about Haskell code.
16:56:39 <tolkad> ksf: it's not longer
16:57:43 <ksf> iago, well, see it this way: if you get a bad mark for something but can lateron demonstrate that you actually consciously chose that formulation for such and such reason, you've got a chance to convince people.
16:58:00 <ksf> in short, just go through your code token by token and make decisions.
16:58:51 <tolkad> the best thing to do is just use as few functions as possible and try to keep stuff on one line
16:59:06 <tolkad> . and $ are functions, you should use less functions
16:59:20 <jmcarthur> my favorite code typo of the day: Monaid
16:59:29 <ksf> not if that line would be 100 characters long.
16:59:36 <hpc> tolkad: you should use more "fewer" :P
16:59:40 <tolkad> ksf: why not? I have a wide screen
16:59:52 <tolkad> hpc: you say fewer for discrete objects
17:00:04 <ksf> tolkad, have a look at a book and count the characters/line.
17:00:04 <tolkad> hpc: you use _less_ functions
17:00:17 <tolkad> ksf: functions aren't discrete. you can have 1.5 functions
17:00:21 <ksf> they virtually never exceed around 80, and that's for good reason.
17:00:22 <hpc> you say "less" that have a "singular plural"
17:00:33 <hpc> you don't say "less waters"
17:00:44 <tolkad> sorry
17:00:50 <tolkad> I meant "less function"
17:00:54 <hpc> perfect
17:00:58 <hpc> :D
17:01:18 <hpc> (sorry, i am way better at grammar than a person should ever be)
17:01:25 <ksf> hpc stop confusing people function is countable, water is not.
17:01:53 <tolkad> ksf: water is made up of molecules. molecules are countable
17:02:08 <ksf> that's what I told my english teacher and got an evil stare.
17:02:12 <koninkje> "waiter, can we get two waters?"
17:02:29 <ksf> that's semantically "two glasses of water"
17:02:39 <tolkad> ksf: function is made up of code
17:02:48 <opqdonut> i'd say "fewer real numbers", but the reals are uncountable!
17:03:02 <koninkje> ah, but semantics doesn't define syntax
17:03:06 <tolkad> ksf: you can have "less code" in the same way you can have "less function"
17:03:07 <hpc> opqdonut: :D
17:03:17 <opqdonut> sorry :)
17:03:28 <tolkad> ksf: for example « f = id » has less function than « f = id; g = id »
17:03:34 <opqdonut> thanks for the reminder though, I haven't run hlint on my code yet
17:03:45 <ksf> koninkje, "water" as in fluid is uncountable, "water" as in short for "a glass of water" is countable.
17:03:57 <koninkje> yeah, so?
17:04:24 <koninkje> Fish as an animal or food product is uncountable, but fish as species are countable
17:04:24 <tolkad> ksf: what about the word "object"?
17:04:28 <ksf> that's why you can say "waiter, two waters". it won't ever have the first meaning, always the second.
17:04:53 <tolkad> ksf: would you use "less" or "fewer" with the word object?
17:05:03 <ksf> depends on meaning.
17:05:09 <tolkad> objects*
17:05:18 <tolkad> ksf: would you use "less" or "fewer" with the word "objects"?
17:05:57 <ksf> I'm admittedly ignorant quite ignorant of the difference, usually.
17:05:59 <dbelange> http://ask.slashdot.org/story/10/11/13/1742253/Which-Language-To-Learn
17:06:06 <koninkje> chicken as a food product is uncountable, but as an animal it's countable
17:06:23 <dbelange> Chicken as a food product is unconscionable.
17:06:25 <koninkje> You can't claim that English plurality marking makes a whole heck of a lot of sense
17:06:31 <ksf> I'm trying hard getting when and if right every time.
17:06:35 <koninkje> dbelange: well, yes, that too :)
17:07:23 <tolkad> ksf: I was trying to get you to say that it was "fewer" as in "fewer objects" and then I'd respond "UR RONG I know u can say "he objects less"" and the trolling would commence
17:07:28 <ksf> btw, when's ghc7 going to hit release?
17:07:38 * koninkje never noticed the food vs animal distinctions until a Japanese speaker pointed out the anomaly
17:07:52 <hpc> whoa
17:07:58 <hpc> subtle
17:08:18 <ksf> intuitively I'd say that less is acceptable for countable things, but fewer is better style. don't use fewer for uncountable, though.
17:08:26 <ksf> but then I'm no native speaker.
17:08:49 <tolkad> ksf: it's not acceptable
17:08:58 <tolkad> ksf: it's just a common error
17:09:20 <koninkje> ksf: "less" is for things that are gradiant (whether countable or not), and "fewer" is for things that are disctrete (whether countable or not)
17:09:28 <ksf> well, the linguist in me says you just lost an argument.
17:10:09 <opqdonut> the linguist in me says prescrpition is futile
17:10:36 <opqdonut> *prescription
17:10:43 <tolkad> opqdonut: not for long
17:10:45 <koninkje> *discrete
17:11:03 <opqdonut> tolkad: ?
17:11:03 <koninkje> opqdonut: what about proscription?
17:11:11 <opqdonut> conscription?
17:11:15 <Eduard_Munteanu> @hoogle Tree
17:11:15 <lambdabot> module Data.Graph.Inductive.Tree
17:11:15 <lambdabot> module Data.Tree
17:11:15 <lambdabot> Data.Tree data Tree a
17:11:26 <tolkad> opqdonut: as soon as we have adequate speek recognition and good text-to-speech and they become common place, they will help slow down the evolution of language
17:11:31 <ksf> cf. german, which uses "wenn" for both when and if and thus freed "falls" for if and only if.
17:11:39 <tolkad> speech recognition*
17:12:11 <opqdonut> I'm not sure I buy that
17:12:17 <opqdonut> in any case this is wildly offtopic
17:12:48 <ksf> linguistics is never offtopic in programming circles.
17:12:58 <Eduard_Munteanu> What should I use for binary trees? Data.Tree or some special binary tree equivalent?
17:13:03 <tolkad> If you want to talk about haskell exclusively join #haskell-blah
17:13:05 <ksf> we're just the hard side of their soft science.
17:13:07 <tolkad> that's what it's for
17:13:12 <Eduard_Munteanu> tolkad: heh
17:13:53 <Eduard_Munteanu> I wonder if I should make my own.
17:15:32 <tolkad> I wish there was a /~ constraint
17:15:43 <tolkad> for making sure types are _not_ equivalent
17:16:13 <ksf> tolkad, have a look at TypeCast and so on.
17:16:37 <ksf> it maps equality to type-level booleans.
17:16:50 <aristid> ksf: "falls" is NOT "if and only if". it's just "if".
17:17:37 <ksf> strictly speaking, it's "if the case be, then"
17:18:54 <ksf> It's stronger than the english "if" in the sense that you have to consciously choose it for its strength as if you didn't care you'd just use "wenn".
17:19:31 <ksf> spoken semantics are such a mess
17:20:26 <jmcarthur> > [1,2,3,undefined] ++ []
17:20:27 <lambdabot>   [1,2,3,*Exception: Prelude.undefined
17:20:41 <ksf> what would you use for iff? "genau wenn"?
17:20:45 <jmcarthur> guess we don't want it to be stricter than necessary in the second parameter
17:21:09 <aristid> ksf: i think "falls" is just if, but because it sounds slightly more formal than "wenn" (which can be used for both), it may be somewhat stronger
17:21:25 <jmcarthur> > head $ [1,2,3,undefined] ++ []
17:21:26 <lambdabot>   1
17:21:31 <jmcarthur> nevermind me
17:21:48 <jmcarthur> i had a reason that mattered...
17:22:03 <ksf> > length $  [1,2,3,undefined] ++ []
17:22:04 <lambdabot>   4
17:22:28 <ksf> it's not like your : would be undefined.
17:22:30 <jmcarthur> i can't think of it now
17:22:34 <alpounet> > length $ repeat 5 undefined
17:22:35 <lambdabot>   Couldn't match expected type `a1 -> [a]'
17:22:35 <lambdabot>         against inferred type `[t]'
17:22:44 <jmcarthur> @src (++)
17:22:44 <lambdabot> []     ++ ys = ys
17:22:44 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:22:44 <lambdabot> -- OR
17:22:44 <lambdabot> xs ++ ys = foldr (:) ys xs
17:22:52 <alpounet> @type repeat
17:22:53 <lambdabot> forall a. a -> [a]
17:22:54 <ksf> > length $ replicate 5 undefined
17:22:55 <lambdabot>   5
17:22:58 <alpounet> oh, yeah.
17:22:59 <alpounet> replicate.
17:23:00 <jmcarthur> it's just that i hate that the entire list is rebuilt when the second list is empty
17:23:01 <hpc> ksf: "nur wenn" perhaps?
17:23:19 <hpc> it translates nicely to "if and only if"
17:23:50 <Eduard_Munteanu> @hoogle sort
17:23:51 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
17:23:51 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
17:23:51 <lambdabot> Data.ByteString.Char8 sort :: ByteString -> ByteString
17:23:54 <hpc> or "only if", since the former will make a linguist have a seizure
17:23:59 <jmcarthur> "exactly when"?
17:24:02 <Eduard_Munteanu> Is there a sort/sortBy for arrays?
17:24:14 <ksf> well nur doesn't imply that you have found a definition, just a constraint.
17:24:31 <jmcarthur> Eduard_Munteanu: there is for vector in the vector-algorithms package. not sure about for arrays
17:24:33 <hpc> ah, true
17:24:35 <Axman6> > [1,2,3] ++ undefined
17:24:35 <lambdabot>   [1,2,3*Exception: Prelude.undefined
17:25:08 <Eduard_Munteanu> jmcarthur: ah, I see. I'll just make a list from it then, I'll need one anyway.
17:25:09 <ksf> I think "exactly if" is cromulent for english, too.
17:25:23 <ksf> er exactly when.
17:25:35 <hpc> if you wanted to be silly, "wennn"
17:25:37 <hpc> like "iff"
17:25:38 <ksf> now it's getting fuzzy.
17:25:41 <Eduard_Munteanu> :))
17:25:52 <aristid> how about <=>
17:25:57 <aristid> or the unicode symbol
17:26:02 <hpc> how about ⇔
17:26:04 <hpc> or ninja
17:26:16 <jmcarthur> robot monkey! (:[])
17:26:24 <Eduard_Munteanu> Damn, that symbol is waaay too small.
17:26:38 <jmcarthur> @let robotMonkey = (:[])
17:26:39 <lambdabot>  Defined.
17:26:46 <ksf> that's why I don't like unicode in sources.
17:26:48 * pumpkin is in boston!
17:26:51 <jmcarthur> @let boobs = (.).(.)
17:26:52 <hpc> same
17:26:52 <lambdabot>  Defined.
17:26:56 <ksf> all those symbols need tex to look good.
17:27:07 <hpc> @let yodawg = fix const
17:27:08 <lambdabot>  <local>:4:13:
17:27:08 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -...
17:27:12 <aristid> :t boobs robotMonkey
17:27:13 <lambdabot> forall a (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f (f1 a) -> f (f1 [a])
17:27:20 <jmcarthur> :t robotMonkey boobs
17:27:21 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => [(a -> b) -> f (f1 a) -> f (f1 b)]
17:29:16 <tolkad> xor needs to enter the english language
17:29:33 <tolkad> then or can always be inclusive
17:29:55 <jmcarthur> i use xor in everyday conversation with those who will understand it
17:31:14 <catface> doesn't that cause a type error?
17:32:05 <ksf> xor is actually the default in my book, because it's iso to sum types.
17:33:12 <ksf> well
17:33:25 <alpounet> jmcarthur, what happens when you say xor to people who do not understand it ?
17:33:26 <ksf> nevermind.
17:34:03 <aristid> robotMonkey needs to enter the english language
17:34:12 <mauke> kneel before xor
17:34:13 <aristid> :t robotMonkey
17:34:14 <lambdabot> forall a. a -> [a]
17:34:19 <jmcarthur> alpounet: i have not tried
17:34:33 <aristid> boobs also needs to enter the english language. oh wait, it already has
17:35:18 <Phyx-> mauke: rofl
17:35:30 <mikeg> @src robotMonkey
17:35:31 <lambdabot> Source not found. Maybe you made a typo?
17:43:30 <megajosh2> :t Reader
17:43:31 <lambdabot> forall r a. (r -> a) -> Reader r a
17:43:36 <megajosh2> Huh
17:44:37 <pumpkin> Reader is a data constructor _and_ a type constructor
17:45:45 <ray> reader's just a wrapper on function
17:47:08 <jmcarthur> :k Reader
17:47:09 <lambdabot> * -> * -> *
17:48:25 <ddarius> The Noetherianess of the (quotiented) citation poset does little to save me.
17:48:33 <megajosh2> I was wondering why it wasn't in scope in GHCi, and then I realize I forgot to import Control.Monad.Reader...
17:49:17 <jmcarthur> ddarius: i have no idea what you just said but it sounds suitable for a @remember for that reason
17:54:40 <greboides> http://paste2.org/p/1088823, if someone could help me out with this, its homework :)
17:58:16 <kmc> eep
17:58:23 <kmc> you don't need to indent 900 spaces
17:58:28 <kmc> you can use a new line like:
17:58:37 <kmc> seno_aux n x k prev_sum division flip
17:58:39 <kmc>   = if ...
17:58:40 <pumpkin> ddarius, kmc, edwardk: I'm in boston!
17:59:04 <kmc> hot damn
17:59:12 <pumpkin> rather cold, actually :(
17:59:21 <pumpkin> also, ridiculously dark even at 4:50 when my plane landed
17:59:23 <greboides> kmc its in auto mode i didnt cared so much
17:59:30 <rryan> fatorial ? 
17:59:44 <greboides> its wrong fac is fatorial
18:00:01 <kmc> greboides, it makes it hard to read... my terminal isn't that wide
18:00:19 <kmc> anyway, could you paste the error message or whatever else makes you think it doesn't work?
18:00:20 <greboides> a second
18:00:24 <kmc> also a description of what it's supposed to do?
18:00:47 <greboides> it calculates sin through taylor series
18:01:06 <greboides> up to n precision 
18:01:28 <Eduard_Munteanu> Operations on a reversed list would occur through memoization, right?
18:01:31 <greboides> which is compared against the division of the kth term
18:01:54 <kmc> what does that mean?
18:01:58 <kmc> Eduard_Munteanu
18:02:32 <kmc> greboides, btw, your code might be clearer if you used a helper function in a "where"
18:02:36 <kmc> since n and x don't change
18:02:41 <Eduard_Munteanu> kmc: I mean reversing the list, which is O(n), happens only once, right? So if my algorithm is O(n), then it will operate O(n) on the reversed list.
18:03:12 <kmc> greboides, i'll reformat this for you, sec
18:03:20 <greboides> i dont know if it works, but it eats all my memory
18:03:31 <kmc> ok, you probably want some strictness on some of those accumulator parameters
18:06:58 <ddarius> pumpkin: Yeah, it does get dark ridiculously early, and this was made worse by daylight savings.
18:07:05 <pumpkin> yeah
18:08:24 <Eduard_Munteanu> kmc: does that make sense? I'm wondering if xs' ! k, where xs' = reverse xs, will take k steps or length xs + k steps
18:08:29 <Eduard_Munteanu> (erm, !!)
18:09:07 <Eduard_Munteanu> I figure the reversing should be memoized.
18:12:08 <ddarius> pumpkin: Want to go running in the woods some time tomorrow?
18:12:30 <kmc> greboides, i would clean up that code along these lines: http://hpaste.org/41452/reformat_for_greboides
18:12:53 <pumpkin> ddarius: I have a lot to cram in over the next few days :/ still don't have an apartment and need to visit lots of apartments and set up visits for others and try to avoid getting screwed by high rents here :P
18:13:24 <alpounet> try to avoid getting screwed by high rents is a pretty hard task nowadays
18:13:30 <alpounet> trying*
18:13:34 <ddarius> Yeah, I came up here on leave to apartment hunt before moving.
18:14:00 <pumpkin> admittedly, I was just irresponsible and that's why I don't have one yet
18:14:03 <pumpkin> but it'll be fine
18:14:12 <ddarius> Everything works out in the end.
18:14:13 <pumpkin> just have to get it done quickly
18:14:18 <greboides> it turns out it works
18:14:19 <pumpkin> yep!
18:14:35 <greboides> just i have to convert angles to radians
18:15:04 <pumpkin> greboides: that makes sense
18:15:07 <greboides> at least it returns the values as builtin sin function
18:15:15 <greboides> same
18:15:50 <Eduard_Munteanu> Hm, I'm thinking about using some sort of zipper for traversing a list sequentially from both ends.
18:16:09 <kmc> greboides, sorry, my connection dropped, did you see my messages?
18:16:47 <Colours> aaaaaahhh
18:16:50 <Eduard_Munteanu> Grr, I could really use a doubly-linked list though.
18:16:50 <Colours> is haskell.org down
18:16:58 <Eduard_Munteanu> Colours: yes.
18:17:10 <Eduard_Munteanu> Colours: hackage was too, but it came up again a few hours ago
18:17:12 <ray> hackage is however back up
18:17:13 <greboides> kmc yeah
18:17:17 <Colours> D:
18:17:35 <greboides> nice rewrite btw
18:19:51 <jmcarthur> anybody know what i could call this? \a b -> liftA2 mappend a b <|> a <|> b
18:19:54 <jmcarthur> :t \a b -> liftA2 mappend a b <|> a <|> b
18:19:54 <lambdabot> forall a (f :: * -> *). (Monoid a, Alternative f) => f a -> f a -> f a
18:20:34 <jmcarthur> > let foo a b = liftA2 mappend a b <|> a <|> b in foo (Just "foo") (Just "bar")
18:20:34 <lambdabot>   Just "foobar"
18:20:37 <jmcarthur> > let foo a b = liftA2 mappend a b <|> a <|> b in foo (Just "foo") Nothing
18:20:38 <lambdabot>   Just "foo"
18:20:42 <jmcarthur> > let foo a b = liftA2 mappend a b <|> a <|> b in foo Nothing (Just "bar")
18:20:43 <lambdabot>   Just "bar"
18:22:17 <Axman6> succedeAtAllCosts
18:22:19 <Axman6> >_>
18:22:32 <Axman6> succeed even
18:23:21 <Eduard_Munteanu> I'm considering something like 'data DList a = DNil | DCons (DList a) a (DList a)' (which is basically a zipper), but unlike in other languages, it's still not looking like keeping pointers to start and end.
18:24:48 <Eduard_Munteanu> Also I can't really tell if, when coming from both ends, my "pointers" touch.
18:24:57 <Eduard_Munteanu> Any ideas?
18:25:23 <hpc> what do you mean "from both ends"?
18:26:11 <Eduard_Munteanu> hpc: from the head of that DList, and from the head of the reversed DList
18:26:46 <gds> Eduard_Munteanu: You want a doubly linked list?
18:26:57 <gds> I think what you've got there is a binary tree...
18:26:57 <Eduard_Munteanu> gds: yes, sorta.
18:27:50 <alpounet> @type (<|>)
18:27:51 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
18:27:51 <ddarius> Eduard_Munteanu: Making immutable doubly-linked lists isn't hard or bad.
18:27:56 <Eduard_Munteanu> If a ternary operator was allowed, say (@) a b c, denoted a @ b @ c, an example dlist would look like [] @ 1 @ 2 @ 3 @ []
18:28:06 <ddarius> secedeAtAllCosts
18:28:52 <Eduard_Munteanu> ddarius: help? :)
18:29:32 <Eduard_Munteanu> It's not that I want a doubly linked list that badly, i just want a list traversable from both ends in opposite directions.
18:29:49 <Axman6> like a Seq?
18:29:50 <ddarius> Eduard_Munteanu: By "immutable" in this context, I mean that you'll make it and you'll query it, but you won't cons onto it or insert into it etc.  Those are certainly implementable but they will be expensive.
18:29:51 <Eduard_Munteanu> (more of a zipper, but one on doubly linked lists, or a list and its reverse)
18:30:03 <ddarius> Your representation is fine, you just need to connect things appropriately.
18:30:26 <ddarius> As Axman6 suggests, you could just use a Seq and be done with it.
18:30:42 <Eduard_Munteanu> ddarius: yeah, I'm not consing. After going over the elements (the stuff I'm doing from both ends), I'll just split it in half.
18:31:06 <Eduard_Munteanu> ddarius, Axman6: thanks, I'll have a look at Seq, I'm not familiar with ti.
18:31:08 <Eduard_Munteanu> *it
18:31:19 * ddarius goes running.
18:32:12 <gds> @doc Data.Sequence
18:32:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/containers/Data-Sequence.html
18:32:36 <gds> Or possibly http://users.skynet.be/jyp/html/base/Data-Sequence.html while haskell.org is down...
18:32:55 <Eduard_Munteanu> gds: thanks.
18:33:12 <Eduard_Munteanu> I think Hackage covers some of that stuff too
18:33:55 <jmcarthur> i don't like succeedAtAllCosts :\
18:35:07 <sbahra> Any ideas what's up with haskell.org?
18:35:09 <gds> Eduard_Munteanu: I don't know the libs very well I'm afraid. Good luck in your search for the Right Data Structure :)
18:35:37 <gds> sbahra: I know it's been down for at least 12 hours or so.
18:35:57 <jmcarthur> Eduard_Munteanu: so you are doing some stuff from the ends, meeting up in the middle, then splitting it? is my understanding right?
18:36:14 <gds> sbahra: and that http://new-www.haskell.org/ is ok.
18:36:26 <Eduard_Munteanu> jmcarthur: yes, though the "midpoint" may vary depending on data. As in it's not exactly middle.
18:36:29 <jmcarthur> Eduard_Munteanu: Data.Sequence should be able to manipulate the ends in O(1) and split in O(log n)
18:36:58 <Eduard_Munteanu> jmcarthur: thanks, I'll try it.
18:36:59 <jmcarthur> Eduard_Munteanu: and in fact if you arrive at the midpoint by traversing from the ends it should already be split :)
18:37:07 <jaredj> are things supposed to be interface-stable before you post them on hackage?
18:37:23 <alpounet> it depends
18:37:44 <alpounet> but in 'base', yeah
18:37:58 <Eduard_Munteanu> jmcarthur: yeah, I'm thinking about doing some sort of fold that conses stuff to two lists as I'm going.
18:38:32 <jmcarthur> jaredj: there are plenty of packages that are not stable on hackage
18:38:49 <jmcarthur> jaredj: release early, release often. just don't be silly and upload a new version every day or something...
18:39:11 <jmcarthur> i try to make sure releases are at least somewhat stable and well documented
18:39:54 <jaredj> ok
18:40:20 <Eduard_Munteanu> Hm, viewl and viewr look nice.
18:40:22 <Eduard_Munteanu> :t viewl
18:40:23 <lambdabot> Not in scope: `viewl'
18:40:29 <Eduard_Munteanu> @src ViewL
18:40:30 <lambdabot> Source not found. Maybe you made a typo?
18:40:35 <Eduard_Munteanu> Anyway.
18:40:37 <jaredj> simple, to be sure
18:40:43 <jaredj> ;)
18:42:16 <jaredj> :d each hackage entry shows what Haskell modules the hackage package provides
18:42:38 <jaredj> is there a page showing the union of all those?
18:43:07 <jmcarthur> jaredj: if you set .cabal/config so that documentation is built for all your installed packages you get one locally
18:43:23 <jmcarthur> jaredj: at ~/.cabal/share/doc/index.html
18:43:57 <shachaf> jmcarthurL You don't need to build documentation to get a list of Haskell modules available locally.
18:44:08 <jaredj> weell... the reason i want it is so i can figure out where in the hierarchy to put my package; i don't want to install them all but i do want to see all the dank corners of the hierarchy
18:44:35 <Eduard_Munteanu> Something must be wrong, why is reverse on Seq O(n)?
18:45:21 <jmcarthur> shachaf: but documentation is presumably the reason jaredj wanted it
18:45:24 <Eduard_Munteanu> Oh, they're probably not doubly-linked lists.
18:45:27 <jmcarthur> ah
18:45:52 <jmcarthur> Eduard_Munteanu: Seq is basically a list with shortcuts
18:46:09 <jaredj> actually heck with that. i'll just ask you fine folks :)
18:46:51 <jaredj> so i'm writing code to represent quilts (i.e., of cloth squares). does that go under Data?
18:50:40 <jmcarthur> jaredj: sure
18:50:54 <jmcarthur> jaredj: things like this aren't really important to me anyway. any choice is pretty much arbitrary, IMO
18:51:48 <ddarius> @hackage base
18:51:48 <lambdabot> http://hackage.haskell.org/package/base
18:54:19 <Mitar> hmm, I have a class like "class Foo n" and I would like to make an instance of "class Foo (Bar a b c)" but I get a kind's error, is there some way around that?
18:54:56 <shachaf> Mitar: The kind error probably means you're doing something that doesn't make sense.
18:57:22 <shachaf> Mitar: So the way around it is to figure out why. :-)
18:58:34 <ddarius> Eduard_Munteanu: reverse is O(n) on doubly-linked lists as well.  You can make it cheap by inverting the sense of next and previous but that requires either changing type or storing a bit to specify which sense to use.  You can do the same for Seq.
18:58:47 <Mitar> it says that Foo expects * but I am giving * -> * -> *
19:01:17 <crutcher> is haskell.org down?
19:01:31 <alpounet> it's being migrated
19:01:41 <alpounet> use http://new-www.haskell.org/
19:01:48 <crutcher> thanks
19:03:15 <Eduard_Munteanu> ddarius: hm, I guess it makes sense after all, even in imperative languages you'd need a pointer to its end. If you don't have, it's O(n) to obtain it.
19:03:32 <Eduard_Munteanu> *have it
19:04:05 <jmcarthur> Eduard_Munteanu: even if you have the pointer to the end it's O(n) to reverse unless you did what ddarius suggested
19:04:15 <tmo_> With gtk2hs, certain widgets like the Window widgets accept strings as constructors, which in turn allows you to modify that string and retrieve that string for that specific widget instance.
19:04:32 <tmo_> Unfortunately, upon looking at the source, it appears to call a C function to accomplish that.
19:04:53 <tmo_> How can I get the SourceView widget to accept a string and behave like a Window widget in that regard?
19:07:37 <Eduard_Munteanu> jmcarthur: oh, I see what he meant now.
19:09:00 <jmcarthur> Eduard_Munteanu: in fact, with Seq you *do* have a pointer to the end already
19:11:41 <Eduard_Munteanu> Yeah, otherwise appending wouldn't be O(1).
19:13:07 <sshc> What is the OpenGL package's equivalent of glTranslate3d(x, y, z);?
19:13:58 <jmcarthur> sshc: you know immediate mode is deprecated, right?
19:21:11 <Eduard_Munteanu> Let f x = f' (g x); f' Nothing = 0; f' (Just x) = x. Is there anything in Haskell (even non-standard) that would let me write that as "f (g Nothing) = 0; f (g (Just x)) = x"?
19:21:15 <Eduard_Munteanu> It looks sound to me.
19:21:37 <Eduard_Munteanu> Note I'm pattern-matching on the result of g, not its argument.
19:21:54 <ksf> jmcarthur, it is?
19:22:19 <ksf> even to construct lists?
19:22:50 <Axman6> Eduard_Munteanu: f (g -> Nothing) 0; f (g -> Just x) = x
19:23:02 <Axman6> using um... i forget the name of the extension
19:23:20 <ksf> vertex array?
19:23:35 <Axman6> f (g -> Nothing) = 0*
19:23:36 <Eduard_Munteanu> Axman6: nice, it was a long shot.
19:23:54 <Axman6> i keep thinking pattern guards, but that's not it
19:23:59 <ksf> well, that's like using write instead of putc.
19:24:16 <ksf> -XViewPatterns
19:24:21 <Axman6> that's the one
19:24:38 <Eduard_Munteanu> Ah, thanks.
19:24:51 <jmcarthur> ksf: yes, opengl core only contains the programmable pipeline now
19:25:07 <Eduard_Munteanu> I wonder if it's the best way though. It'd involve a lot of cruft to do that without using it.
19:25:25 <Axman6> > let g x = if even x then Just x else Nothing; f (g -> Nothing) = 0; f' (g -> Just x) = x in f 4
19:25:26 <lambdabot>   *Exception: <interactive>:1:187-206: Non-exhaustive patterns in function f
19:25:37 <Axman6> > let g x = if even x then Just x else Nothing; f (g -> Nothing) = 0; f (g -> Just x) = x in f 4
19:25:38 <lambdabot>   4
19:25:41 <Axman6> > let g x = if even x then Just x else Nothing; f (g -> Nothing) = 0; f (g -> Just x) = x in f 3
19:25:42 <lambdabot>   0
19:26:00 <Eduard_Munteanu> I see.
19:27:00 <ksf> oh I see vbos
19:27:08 <ksf> well stuff has just changed since 2000
19:27:08 <jmcarthur> yup
19:28:00 <ksf> ...I don't care for tossing out the fixed pipeline as long as the library comes with ready-made defaults that let me use an equivalently programmed one.
19:28:25 <ksf> the cards did that a long time ago, I'd scream if the library does the same.
19:28:32 <jmcarthur> there is a compatibility mode
19:29:00 <jmcarthur> most implementations just implement the fixed function in terms of the programmable now
19:29:13 <ksf> can't have hello word require to write custom shaders.
19:29:15 <jmcarthur> i think all of them do, in fact
19:29:29 <jmcarthur> well, for opengl core, hello world requires exactly that
19:30:28 <revenantphx> Luckily, with the programmable pipeline, most of the setup code you struggle through once.
19:30:32 <revenantphx> And then you can reuse.
19:30:53 <revenantphx> Once you have some good headers for error checking, resource loading, and matrix handling, you're good.
19:31:11 <jmcarthur> exactly
19:31:19 <jmcarthur> it's actually pretty nice once you're used to it
19:31:25 <ksf> am I the only one thinking that a hello world should be functional with minimum fuzz?
19:31:28 <revenantphx> For instance, I have a header in which I have fully expanded 4x4 matrix multiplication
19:31:32 <revenantphx> into a huge macro :3
19:31:45 <ksf> you can always dig into what a function like initDefaultMode() does later on.
19:31:49 <jmcarthur> ksf: opengl isn't really supposed to be all that high level, IMO
19:31:56 <revenantphx> https://gist.github.com/675880
19:32:25 <jmcarthur> revenantphx: omg that can't actually be faster than just using a function
19:32:33 <jmcarthur> revenantphx: static inline is your friend :)
19:32:39 <ksf> and I dont' argue it should be high-level. but getting something to display sholud be easy and not require understanding the whole shebang.
19:32:50 <revenantphx> meh, it works well.
19:33:02 <jmcarthur> ksf: i don't think http://duriansoftware.com/joe/An-intro-to-modern-OpenGL.-Table-of-Contents.html is that hard to follow
19:33:09 <revenantphx> And if you think about it, the only difference between that and static inline is... what?
19:33:14 <revenantphx> (nothing pretty much)
19:33:31 <jmcarthur> revenantphx: sanity checks
19:33:38 <revenantphx> jmcarthur: hah, this is OpenGL
19:33:43 <ksf> I just fear that they're going to make me repeat those days in which I was continuously staring at a black gl screen.
19:33:57 <revenantphx> jmcarthur: that tutorial is great, but the shader model it uses it a tad out of date, oh well.
19:33:59 <ksf> (until I borrowed a red book)
19:34:00 <jmcarthur> ksf: you only have to go through that once
19:34:01 <revenantphx> It's very very very helpful.
19:34:04 <jmcarthur> revenantphx: yeah, well
19:34:15 <ksf> yeah, and I did. in fixed-pipeline days.
19:34:26 <revenantphx> I recommend the SuperBible 5th edition.
19:34:29 <revenantphx> The new one is amazing.
19:34:36 <revenantphx> The entire thing is purely programmable pipeline, nothing else.
19:34:37 <jmcarthur> revenantphx: my hardware doesn't even support geometry shaders, so...
19:34:45 <ksf> switching such code to vbos shouldn't require implementing the old pipeline in shaders.
19:34:59 <jmcarthur> revenantphx: i thought it touched on some fixed pipeline stuff near the end at least, just for kicks
19:35:03 <jmcarthur> i don't have it though
19:35:12 <revenantphx> jmcarthur: the old ones were 50/50
19:35:19 <revenantphx> the 5th edition is rewritten from the ground up
19:35:22 <jmcarthur> ksf: no, the opengl drivers already provide that in a compatibility mode
19:35:32 <jmcarthur> ksf: you shouldn't have to rewrite old code. just new code should use the new stuff
19:35:46 <jmcarthur> revenantphx: nice, i'll have to check it out
19:35:52 <jmcarthur> revenantphx: what opengl version does it cover?
19:36:05 <jmcarthur> i assume 3
19:36:09 <jmcarthur> which is fine
19:36:11 <revenantphx> um, let me check
19:36:17 <revenantphx> AT LEAST 3.1/2
19:36:29 <revenantphx> 3.3 XD
19:36:37 <jmcarthur> that is, i doubt any books cover 4 yet
19:36:39 <revenantphx> "complete reference and tutorial  to the OpenGL 3.3 Core Profile."
19:36:40 <jmcarthur> okay
19:36:44 <jmcarthur> cool
19:36:53 <revenantphx> which sucks for me
19:37:01 <revenantphx> since my hardware supports 3.0 95%
19:37:05 <revenantphx> 33% of 3.2
19:37:07 <revenantphx> and none of 3.3
19:37:11 <jmcarthur> aw
19:37:22 <jmcarthur> my main dev machine has intel graphics. consider yourself lucky
19:37:34 <ksf> geforce 7600 gs here.
19:37:44 <ksf> just a generation before cuda.
19:37:46 <Eduard_Munteanu> @hoogle foldl'
19:37:46 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
19:37:46 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
19:37:46 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
19:37:54 <revenantphx> I have intel/nvidia
19:37:56 <revenantphx> on my macbook pro
19:38:18 <ksf> and those types of cards are going to stick around for a while still.
19:38:55 <revenantphx> Once I get a job... preferably within the first year of college... the saving will begin.
19:38:57 <ksf> though I bet the card _could_ do cuda, if nvidia cared to do some hacking. possibly not very fast when it comes to conditionals, but still.
19:39:04 <revenantphx> And once I have 4000$...
19:39:17 <revenantphx> I will build a very nice computer indeed :3
19:39:49 <revenantphx> tbh, I don't play games much so I don't need it that bad though.
19:39:59 <revenantphx> Though with the simulations I'm doing, I would love some more cores.
19:40:05 <revenantphx> (parallelization ftw)
19:40:24 <ksf> OpenGL version string: 2.1.2 
19:40:53 <revenantphx> ksf: http://www.realtech-vr.com/glview/
19:41:00 <jmcarthur> OpenGL version string: 2.1 Mesa 7.8.3
19:41:09 <ksf> uh.
19:41:12 <ksf> glxinfo.
19:41:32 <ksf> OpenGL renderer string: GeForce 7600 GS/PCI/SSE2                               
19:41:32 <ksf> OpenGL version string: 2.1.2 NVIDIA 256.44                                     
19:41:32 <ksf> OpenGL shading language version string: 1.20 NVIDIA via Cg compiler
19:41:52 <revenantphx> OpenGL renderer string: NVIDIA GeForce GT 330M OpenGL Engine
19:41:52 <revenantphx> OpenGL version string: 2.1 NVIDIA-1.6.18
19:41:53 <revenantphx> OpenGL shading language version string: 1.20
19:42:07 <jmcarthur> OpenGL renderer string: Mesa DRI Mobile Intel® GM45 Express Chipset GEM 20100328 2010Q1 
19:42:08 <jmcarthur> OpenGL version string: 2.1 Mesa 7.8.3
19:42:10 <jmcarthur> OpenGL shading language version string: 1.20
19:42:16 <revenantphx> We all have comparable stuff
19:42:23 <revenantphx> in terms of version/GLSL
19:42:31 <jmcarthur> i bet you guys support way more extensions than i do
19:42:41 <revenantphx> I have 95% support of OpenGL 3.1
19:42:43 <revenantphx> 3.0*
19:42:49 <jmcarthur> yeah i'm nowhere near that
19:43:04 <revenantphx> only thing I dont have in ogl3.0 is GLSL 1.30
19:43:07 <jmcarthur> at least i have framebuffers
19:43:19 <revenantphx> I have geometry shaders tho!
19:43:24 <jmcarthur> i don't :(
19:43:26 <revenantphx> and texture rects :D
19:43:26 <ksf> http://hpaste.org/41454/glxinfo
19:43:30 <jmcarthur> i have that
19:44:17 <revenantphx> I wonder how my Intel graphics rate...
19:44:47 <revenantphx> OpenGL renderer string: Intel HD Graphics OpenGL Engine
19:44:48 <revenantphx> OpenGL version string: 2.1 APPLE-1.6.18
19:44:48 <revenantphx> OpenGL shading language version string: 1.20
19:45:18 <revenantphx> This card only have 43% support for 3.0 though.
19:45:22 <revenantphx> So less extensions, less power.
19:45:45 <Eduard_Munteanu> :hoogle sortBy
19:45:49 <Eduard_Munteanu> @hoogle sortBy
19:45:49 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
19:46:01 <revenantphx> Eduard_Munteanu: way to ruin the moment, we're comparing epeens!
19:46:02 <ksf> I don't think there's cuda-class agp cards.
19:46:05 <revenantphx> (I have two!)
19:46:10 <ksf> and even then, I should just get a new box.
19:46:54 <revenantphx> this bad boy
19:46:55 <revenantphx> http://www.nvidia.com/object/product-geforce-gtx-580-us.html
19:47:31 <revenantphx> they're about 580$ a pop.
19:47:55 <ksf> having geometry shaders would be a charm. bezier and thus font rendering in hardware without using elaborate ugly hacks.
19:48:22 <Eduard_Munteanu> revenantphx: heh, but what do you mean with "epeens"?
19:48:35 <revenantphx> It's like comparing penis size in real life.
19:48:44 <revenantphx> hence e-peen
19:48:44 <Eduard_Munteanu> Oh :))
19:49:11 <Eduard_Munteanu> Well, mine is just longer considering I have a Radeon HD 5850 :P
19:49:46 <ksf> I guess my next one is going to be an ati, too, considering the driver situation.
19:49:55 <revenantphx> driver situation
19:49:55 <revenantphx> ?
19:50:04 <ksf> or rather, doc situation that enables people to write drivers.
19:50:15 <revenantphx> ?
19:50:32 <ksf> while the binary nvidia blob is functional, I seriously doubt it's quality code.
19:50:58 <danharaj> are we talking about how much opengl sucks :[
19:50:58 <Eduard_Munteanu> ATI might be faster to get good Gallium support.
19:51:03 <Eduard_Munteanu> *Gallium3D
19:51:24 <ksf> and nvidia isn't going to give people access to documentation of their cards.
19:51:29 <ksf> not even under nda.
19:51:51 <Eduard_Munteanu> For Evergreens (HD5xxx) it's already public.
19:51:53 <revenantphx> *yawn*
19:51:54 <revenantphx> night
19:52:26 <Eduard_Munteanu> And they say 6xxx will probably be based on Gallium3D directly, no Mesa drivers.
19:53:58 <Eduard_Munteanu> That Gallium thingy is the holy grail.
19:54:51 <ksf> kernel mode switching. wayland.
19:55:00 <ksf> it's going to be the decade of the linux desktop.
19:56:21 <ksf> wayland could even be reasonably put into initrd.
19:56:52 <ksf> getting rid of /dev/ttyX, who needs them anyway.
19:57:39 <Eduard_Munteanu> It's a big undertaking, nobody so far has really managed to provide a unified 3D driver infrastructure.
19:58:32 <ksf> the actual joke of the whole thing is that linux could get native direct3d support.
19:58:57 <Eduard_Munteanu> Yeah, I read that on Phoronix.
20:00:07 <ksf> and it's still an obsolete, monolithic kernel!
20:02:25 <Eduard_Munteanu> At least for drivers, newer hardware might make moving them to userspace doable.
20:02:44 <ksf> yep.
20:02:51 <Eduard_Munteanu> IOMMUs are really neat for that.
20:02:53 <ksf> IPC is the open topic, then.
20:04:43 <Eduard_Munteanu> IPC is difficult. At least when comparing to shared data.
20:04:46 <ksf> while we're busy prophetising, haiku is going to get interesting.
20:05:01 <Eduard_Munteanu> What about it?
20:05:16 <ksf> have you ever used beos?
20:05:33 <Eduard_Munteanu> No. I know about BeOS and Haiku though.
20:05:58 <jmcarthur> my impression is that BeOS was way ahead for its time but that we're pretty much caught up technically since it's been dead. am i wrong?
20:06:57 <ksf_> I'm still trying to construct scenarios that inlude the complete demise of mircosoft, though.
20:09:20 <Eduard_Munteanu> I'm using 'import Data.Sequence (viewl, viewr, Seq, ViewL, ViewR, (:>), (:<), fromList)', but ghc complains that "Module `Data.Sequence' does not export `:>'". How is that possible?
20:09:39 <Eduard_Munteanu> http://users.skynet.be/jyp/html/base/Data-Sequence.html#t%3AViewR
20:10:33 <tmo_> To solve a particular problem, I need a type to behave similar to an object with mutable variables. How can I do this in haskell?
20:10:46 <danharaj> You have to specify the problem to get help.
20:10:50 <mauke> depends on your definition of "similar"
20:11:15 <ksf> the most basic solution is a simple record, which you update.
20:11:27 * Eduard_Munteanu thinks the vultures are picking the easy pray :P
20:11:30 <tmo_> Basically, I want the TextView object to store a string of text representing the directory of the file it's editing.
20:11:41 <mauke> Eduard_Munteanu: well, haskell.org is down so I can't check
20:11:50 <tmo_> Where it's also possible to read and update the field.
20:11:50 <Eduard_Munteanu> mauke: I just linked you ^
20:11:55 <Eduard_Munteanu> http://users.skynet.be/jyp/html/base/Data-Sequence.html#t%3AViewR
20:12:00 <mauke> Eduard_Munteanu: but to what?
20:12:17 <Eduard_Munteanu> mauke: looks like the API for Data.Sequence.
20:12:21 <mauke> Eduard_Munteanu: which version?
20:12:22 <jmcarthur> Eduard_Munteanu: ViewL ((:<)), ViewR ((:>))
20:12:33 <ksf> newTextView = oldTextView { file = newFile }
20:12:34 <Eduard_Munteanu> mauke: you have a point.
20:12:40 <jmcarthur> Eduard_Munteanu: or:
20:12:46 <jmcarthur> Eduard_Munteanu: ViewL (..), ViewR (..)
20:12:48 <mauke> ViewL(..), ViewR(..)
20:13:24 <Eduard_Munteanu> jmcarthur, mauke: thanks, that worked
20:13:29 <tmo_> I tried looking at the source of other gtk2hs objects that did something similar, but they all seem to call the original C functions.
20:14:01 <mauke> tmo_: IORef
20:14:34 <tmo_> mauke: can an object instance store a unique IORef?
20:14:45 <mauke> huh?
20:15:36 <tmo_> well if I were to create a TreeView A and a TreeView B initialised with two different text values, if I were to call getTextField A, will it return A's text value?
20:16:19 <mauke> if you code it right, yes
20:16:24 <mauke> what
20:16:27 <Eduard_Munteanu> Yes, c.p. capitalization.
20:18:55 <djahandarie> Object instance?
20:19:34 <djahandarie> There are no objects in Haskell
20:19:48 <jmcarthur> sure there are, if you make them
20:20:12 <tmo_> djahandarie: you should look at gtk2hs or wxhaskell's source
20:20:24 <ksf> we even have a meta object system as a library.
20:20:26 <tmo_> they make use of a lot of oo techniques
20:20:40 <ksf> that is, a library which lets you easily create object systems.
20:21:01 <ksf> that's because they're bindings to libraries which are OO.
20:21:23 <ksf> don't expect code using them to look very haskellish.
20:21:56 <Eduard_Munteanu> Gtk2Hs does look Haskellish, despite being a C library.
20:22:05 <Eduard_Munteanu> *using
20:22:15 <ksf> you haven't seen grapefruit, then.
20:22:26 <Eduard_Munteanu> Heh, let's not FRP :)
20:22:33 <ksf> although I must admit the examples look like a maze of arrows.
20:22:51 <ksf> the key to grokking grapefruit is the record system, though.
20:22:55 <Eduard_Munteanu> What I mean is, for something that binds to a C lib, it's incredibly Haskellish.
20:24:07 <Eduard_Munteanu> Also in GTK you've got that neat model data store thingy, which allows you to specify data in controls in a functional fashion.
20:24:50 <djahandarie> I know there has been work to make Haskell be nice with objects, but I would be reluctant to say that Haskell has them 'out-of-the-box'
20:25:03 <ksf> grapefruit-records is awesomely close to what anyone could want, now we just need better type-level programming to make it more useable.
20:25:34 <ksf> especially the pattern matching support is nice.
20:25:49 <ksf> reordering and narrowing records in the process.
20:26:56 <ksf> I think the only time I use objects is when I want to have an actor, though.
20:28:25 <Eduard_Munteanu> I need a binary tree. Should I make my own or use <insert some lib>?
20:28:44 <Eduard_Munteanu> I'm reluctant to use general trees.
20:28:55 <ksf> define "binary tree"
20:29:12 <ksf> balanced? skewed? splay?
20:29:30 <ksf> cache-oblivious?
20:29:33 <Eduard_Munteanu> ksf: none
20:29:57 <Eduard_Munteanu> ksf: just a restriction of a general tree to one that has 2 children for each node.
20:29:58 <ksf> data Tree a = Tip a | Node (Tree a) (Tree a)
20:30:07 <ksf> ymmv on the placement of a.
20:30:21 <Eduard_Munteanu> ksf: well, should I use that or is there some lib that implements it?
20:30:37 <ksf> for sanities' sake, make your own adt.
20:30:39 <Eduard_Munteanu> Because I might need some Traversable/Foldable instances.
20:30:53 <ksf> ... deriving Data
20:30:54 <ddarius> djahandarie: Haskell definitely doesn't have objects "out of the box."
20:31:12 <ksf> I think syb should suffice for your needs.
20:31:26 <ksf> leave the rest to worry about later.
20:31:28 <Eduard_Munteanu> ksf: thanks, I'll try that way.
20:31:37 <roconnor> ugh, syb is an abomination
20:31:45 <ksf> yeah, but it's derivable.
20:32:11 <djahandarie> ddarius, you're preaching to the choir
20:32:17 <ksf> it's not fast, but it's quite easy to use.
20:32:56 <ddarius> djahandarie: I'm emphasizing.  I would not be reluctant to say it, I wouldn't say it at all.
20:32:58 * Eduard_Munteanu would use data Tree a = Empty | Node a (Tree a) (Tree a)
20:33:40 <ksf> you could even use Tree a b = Tip a | Node b (Tree a) (Tree a) and keep a monoid in a
20:33:50 <ksf> er b.
20:33:53 <djahandarie> ddarius, I just said it like that because I didn't want to get into some detailed analysis of what "out-of-the-box" means etc. etc.
20:34:35 <ksf> Node a Empty Empty for a tip is broken imho
20:34:37 <Eduard_Munteanu> ksf: nah, I'd like to avoid the forest thingy of Data.Tree, if that's what you allude to.
20:34:58 <Eduard_Munteanu> ksf: why? that would be a leaf.
20:35:17 <ksf> well why use that when you can use my Tree a b above?
20:35:35 <mauke> because your tree doesn't store data in the internal nodes
20:35:40 <mauke> er
20:35:54 <ksf> you have to test thrice there to see that you have a node.
20:36:01 <djahandarie> I'm pretty against duplicating code in your own package if it exists somewhere on Hackage (in a form you are satisfied with of course)
20:36:17 <ksf> it's not supposed to. data at the leaves, monoidal information to do the lookup in the nodes.
20:36:20 <mauke> ksf: no empty trees
20:36:47 <ksf> tree monoids are overrated.
20:37:02 <tmo_> Actually, I found a way using GTK's library to avoid having to make a mutable object all together.
20:37:22 <ksf> anyway, Foo a b = Empty | Tree a b
20:37:41 <Eduard_Munteanu> oO
20:37:56 <djahandarie> Still no empty trees. Only empty foos ;)
20:38:05 <mauke> == Maybe (Tree a b)
20:38:06 <ddarius> There's not much value to a "generic" binary tree package.  Even Data.Tree is rarely used.
20:38:19 <ksf> I never claimed trees should form a monoid.
20:39:36 <ksf> and even fingertree isn't used by e.g. Data.Sequence
20:39:54 <djahandarie> ddarius, why not? Ideally we should be able to pull stuff from different places and compose them into what we want. If we can't then there is a shortcoming in the language or the package ;)
20:40:18 <roconnor> ksf: isn't that only because Haskell sucks at modularity?
20:40:29 <ksf> it's speed issues, I think.
20:40:35 <roconnor> exactly
20:40:54 <ksf> well, supero.
20:40:57 <ddarius> djahandarie: People rarely want a "plain" binary tree and "building" one out of other things tends to create more overhead than a direct definition would have and provide little.
20:40:59 <roconnor> :D
20:42:54 <jmcarthur> ddarius: i'd still say that those downsides are shortcomings of the language
20:43:31 <ddarius> The overhead part, yes, the other parts or more socialogical.
20:43:36 <ddarius> s/ia/io
20:43:37 <jmcarthur> i mean, wouldn't it be nice to be able to take a "plain" binary tree and decorate it with the things you need?
20:44:00 <jmcarthur> or was your argument about building the trees from non-trees?
20:44:01 <adu> ddarius: do you mean things like underscores?
20:44:19 <jmcarthur> like Free Pair and all that
20:47:15 <ddarius> jmcarthur: I wasn't limiting the method of building trees out of other things.  But already above, there are questions like: do I want empty trees, or node labelled or leaf labelled or both, the same type or not, some ether information, etc.  And what does one get from using this super general tree beyond complex patterns, probably a Functor instance and a few traversals/pretty-printers which are likely also not what I
20:47:15 <ddarius>  want.
20:47:58 <ddarius> Basically the issue is that binary trees are so simple in Haskell that a library doesn't save you much, especially if that library has to please all users.
20:48:36 <jmcarthur> if we had a larger number of generic type classes then such constructions would be more useful, i think
20:48:53 <jmcarthur> it would also help if our language could talk about such things more abstractly
20:48:58 <ddarius> There are a large number of generic classes which aren't popular.
20:50:01 <jmcarthur> e.g. currently even when i don't care what kind of data is stored in leaves and branches of a tree, i still have to carry around type variables if i want to allow stuff to go there later. that means i'm concerning myself with things that aren't "tree"
20:52:04 <jmcarthur> i have no particular ideas to solve this, but my point is just that there could be a lot of value in having it and perhaps some extra power would make these compositions more practical and useful
20:52:46 <jmcarthur> in haskell specifically, i'm inclined to agree with you. it's too much trouble to build many data structures from little type combinators and stuff
20:53:12 <jmcarthur> i tend to only use them when i'm playing around with a semantic model or something
21:00:33 <ksf> jmcarthur, what about e.g. idris?
21:00:34 <stepkut> Gracenotes: the 'time' command sometimes records message usage
21:01:46 <jmcarthur> ksf: i'm not familiar enough with it to say anything meaningful
21:01:53 <Gracenotes> messages?
21:02:21 <ksf> though in the end public acceptance of abstraction hinges on supercompilation.
21:02:38 <ksf> noone wants to use combinators that blow up your program.
21:02:40 <jmcarthur> i think supercompilation is not enough
21:02:55 <ksf> it's crucial, though.
21:03:04 <jmcarthur> it won't necessarily catch things that could benefit from dynamic optimization
21:03:18 <ksf> well, yes.
21:03:22 <ksf> jit compiling?
21:03:32 <jmcarthur> optimal evaluation or something approaching it would help more, albeit probably with higher constant runtime costs
21:04:06 <ksf> especially on those newfangled multicores I'd imagine there to be ample timeslices to just try to optimise and see if it works.
21:04:56 <kmc_> jit compiler ftw
21:04:57 <ksf> "optimal" is a quite fuzzy term, there, processors don't care about the number of reductions but cache misses.
21:05:19 <jmcarthur> ksf: the idea is to share more. reductions isn't really that important as you say
21:06:09 <jmcarthur> for example, some evaluation orders will turn (f . g) into something nicer, even if it was constructed at runtime
21:06:10 * ksf waits for graphene-based fpgas to become the default platform.
21:06:27 <jmcarthur> and once that's been specialized, the jit could come in and make it sing, if that would help
21:07:48 <ksf> one part of the fpga to model an STG, the other a haskell->stg compiler molded into hardware.
21:08:04 <jmcarthur> why the latter?
21:08:19 <ksf> well, if nothing else, eval.
21:08:45 <ksf> also, as a frontend to the stg->fpga compiler that should be part of the pack.
21:09:32 <ksf> tight loops then get molded into hardware, while the bulk of the programs runs on the stg interpreter.
21:09:47 <jmcarthur> yeah that'd be awesome
21:10:57 <ksf> also, don't forget http://en.wikipedia.org/wiki/Graphene#Graphene_transistors
21:11:03 <ksf> fucking 100ghz.
21:11:51 <jmcarthur> god
21:12:05 <jmcarthur> i didn't know about this
21:12:11 <jmcarthur> pretty crazy
21:16:34 <Axman6> they reckon they can get graphine up to 1THz
21:16:59 <nemo__> hey, i can't seem to get to www.haskell.org, am i the only one?
21:17:07 <Axman6> memristors also provide an interesting future for us, there's the possibility of programmable hardware
21:17:12 <anthonyw> nope, I can't get on it
21:17:14 <Axman6> nemo__: it's down at the moment
21:17:37 <nemo__> just making sure. thanks axman
21:18:01 <kmc_> in a 1 THz cycle, light in a vacuum travels 0.3 mm
21:18:37 * Axman6 can't wait for memristor-graphine computers
21:19:13 <aavogt> nemo__: you can try http://new-www.haskell.org
21:19:47 <Axman6> super fast general purpose CPUs with blocks of memristor storage/programmable stuff. make specialised memristor CPU's on the fly for whatever your parallel needs are, and leave the basic stuff for the super fast graphine core
21:19:57 <ksf> 1thz is low infrared, btw.
21:21:35 <Axman6> i have no idea if this will ever be feasable, but it's nice to think about
21:22:50 <kmc_> once our CPUs get to 400 THz then they will glow red :D
21:23:00 <danharaj> I don't think that is physically possible on silicon :p
21:23:09 <kmc_> bah "physically possible"
21:23:37 <Axman6> danharaj: hence the move to materials like graphine
21:23:50 <Darkone> Uhhmm
21:24:00 <Darkone> The clock is pretty limited on any physical chip.
21:24:02 <aavogt> taking this further into -blah territory: you should look up techniques for making graphene
21:24:13 <aavogt> the impressive scotch tape approach :p
21:24:18 <jmcarthur> we've been in -blah territory all night
21:24:27 <ksf> ranging from taking a pencil and some scotch tape to pretty sophicsticated.
21:25:09 <Darkone> Take the distance your clock signal has to travel, divide that by C, and then divide 1 by the number you just got, and that gives you the maximum possible throughput.
21:25:11 <ksf> graphene also has insane tensile strength which makes it interesting for e.g. windows.
21:25:39 <ksf> processors don't need to be synchronized througout.
21:25:44 <ddarius> danharaj: The way silicon transistors work is pretty suboptimal.
21:25:46 <Darkone> Of course, that's assuming your clock is the limiting factor.
21:25:49 <Darkone> It isn't.
21:25:51 <Darkone> :P
21:27:00 <ksf> just as a trivial example, the multiplication part of an ALU could work at 10 times the op decoding clock.
21:27:20 <jmcarthur> haven't they made clockless CPUs, even?
21:27:29 <ddarius> We'll probably have a transition to explicitly NUMA architectures with a transition to such chips.
21:27:35 <ksf> would definitely make sense.
21:27:43 <Axman6> i read somewhere that if you took a piece of graphine that's less than 1mm^2 and grew it to be big enough to fit over a coffee cup, you could put it on a (strong enough) coffee cup, and you could support the weight of a truck on an area the size of a pencil tip
21:27:47 <ddarius> jmcarthur: They started with clockless CPUs.
21:27:54 <ksf> automatically clock parts up and down with temperature and load.
21:27:55 <jmcarthur> ddarius: well, i mean more modern ones
21:28:22 <Darkone> I'm no expert, but I point to the fact that all consumer CPUs use clocks. Ergo, there must be something about clocked CPUs that makes them in some way more agreeable to a consumer, whether it's cost or capability.
21:28:44 <ksf> Axman6, and it's size are going to cut through your fingers as you try to place it, without you even noticing.
21:28:55 <ksf> s/size/edges
21:28:55 <aavogt> Axman6: well normal materials are weak because of defects in the (crystal or otherwise) structure
21:28:55 <jmcarthur> clocks do keep things simpler for the designers, at the very least
21:28:58 <ddarius> Darkone: It's much, much, much easier to design clocked CPUs.
21:29:16 <Darkone> ddarius, which means, effectively, you can make much more complicated CPUs.
21:29:18 <Darkone> Correct?
21:29:22 <Axman6> danharaj: making components from NAND gates somewhat requires some kind of clocking
21:29:39 <ksf> well, you don't need to make individual components clockless. just make them loosely coupled.
21:29:59 <Axman6> hmm, was it nand gates, or just making flipflops from transistors that needed a clock, i think it's the latter
21:30:18 <jmcarthur> loose coupling of components sounds like the prediction that the cores in multicore ships will gradually become specialized
21:30:37 <jmcarthur> everything comes full circle
21:30:45 <ksf> well, why shouldn't they. 
21:30:51 <jmcarthur> and suddenly multicore looks like single core again :)
21:31:02 <ksf> nah, everone is going amiga.
21:31:11 <danharaj> reduceron all the way
21:31:26 <jmcarthur> reduceron would be awesome at 100GHz
21:31:43 <Darkone> Either way, the practical estimat eI saw was that a switch of current processors to graphene is 3x speedup.
21:31:47 <ddarius> Axman6: You don't need a clock for either of those.
21:32:19 <ksf> you need a clock to figure out if the signal you're waiting for is valid, already.
21:32:24 <jmcarthur> Axman6: perhaps you are just thinking of the time it takes for a state to stabilize?
21:32:29 <ddarius> Darkone: Presumably to begin with unless you are not localizing to just the CPU.
21:32:35 <ksf> due to signal runtimes through gates and different runtimes through different paths.
21:33:34 <ksf> I've worked with that some bit, lately. signal latency is a big problem in openttd logic programming.
21:34:01 <ddarius> Yes, the synchronization code in clockless CPUs tend to either wash out the advantages or be very complicated.
21:34:04 <ddarius> (or both)
21:34:11 <ksf> and regular phantom signals due to the way not gates are constructed.
21:35:27 <ksf> it's a quite endearing turing tarpit.
21:36:08 <ksf> http://blog.openttdcoop.org/2009/01/18/optimization-of-logic-logic-gates-part-ii/
21:44:15 <turiya> how do i install data.packed.internal.vector?
21:58:00 <ksf> now the wiki's hamsters are on strike.
22:05:55 <Axman6> ah bugger, just missed dons
22:06:31 <fengshaun> I just realized how cool ($) really is: 
22:06:34 <fengshaun> > ((+) 2 $) . f $ 2 where f x = x+4
22:06:35 <lambdabot>   <no location info>: parse error on input `where'
22:06:53 <fengshaun> let f x = x+4 in ((+) 2 $) . f $ 2
22:06:57 <ksf> cabal should allow testing for package flags and should make them more prominent.
22:07:02 <fengshaun> > let f x = x+4 in ((+) 2 $) . f $ 2
22:07:03 <lambdabot>   8
22:07:20 <ksf> also, depending on flags of a package and resolving them as dependencies.
22:08:38 <Axman6> @tell dons I know there's a list of packages here already, but in the Functionality section on [http://hackage.haskell.org/platform/contents.html#functionality] could we also have each thing mentioned to the package/haddock for that particular task?
22:08:38 <lambdabot> Consider it noted.
22:08:49 <ddarius> fengshaun: You realize that ($) is just the identity function.
22:09:12 <h-cell> Hello, I'm have a probelm with "Illegal instance declarations" which apparently can be fixed by using -XTypeSynonymInstances. What is this function and how do I use it? 
22:09:40 <fengshaun> ddarius, what the identity function?
22:09:49 <ksf> @src ($)
22:09:49 <lambdabot> f $ x = f x
22:09:51 <ksf> @src id
22:09:51 <lambdabot> id x = x
22:09:58 <fengshaun> > let f x = x+4 in ((+) 2 ) . f $ 2
22:09:59 <lambdabot>   8
22:10:09 <Axman6> h-cell: it's a language extension in ghc
22:10:14 <fengshaun> oh damn!  oh well, one thing learned
22:10:21 <ksf> it's not the identity function, it's function application.
22:10:48 <Axman6> > a $ b $ c $ d
22:10:48 <lambdabot>   Couldn't match expected type `a -> b'
22:10:48 <lambdabot>         against inferred type `Simple...
22:10:54 <Axman6> > a $ b $ c $ d :: Expr
22:10:55 <lambdabot>   Couldn't match expected type `a -> b'
22:10:55 <lambdabot>         against inferred type `Simple...
22:11:05 <Axman6> :(
22:11:12 <fengshaun> > let f x y = x + y in ($ 2) . f $ 2
22:11:13 <lambdabot>   4
22:11:17 <fengshaun> oh here it is!
22:11:23 <fengshaun> > let f x y = x + y in ( 2) . f $ 2
22:11:24 <lambdabot>   2
22:11:33 <fengshaun> there we go
22:11:43 <ksf> h-cell, you could also define your instance on the real type, not the synonym.
22:13:38 <ddarius> ksf: Module an extra bottom, curried function application -is- the identity function.
22:14:00 <ddarius> This is actually an important part of the adjunction defining function spaces.
22:14:12 <aavogt> often -XTypeSynonymInstances can be substituted for other extensions
22:14:22 <ksf> I like to ignore that.
22:14:45 <aavogt> as in, you can write a type that will stop you from needing -XFlexibleInstances
22:14:51 <ddarius> :t uncurry id
22:14:52 <lambdabot> forall b c. (b -> c, b) -> c
22:15:54 <h-cell> I don't know much about language extentions in Haskell ..  is -XTypeSynonymInstances a type of function or how is it used?
22:16:26 <aavogt> h-cell: at the top of your file, add  {-# LANGUAGE TypeSynonymInstances #-}
22:17:06 <aavogt> you can read about it, and 50 other extensions, in GHC's manual
22:17:15 <Cale> h-cell: Written like that, it's meant as a commandline parameter to the compiler
22:17:37 <Cale> (but follow aavogt's advice and use a LANGUAGE pragma anyway)
22:18:03 <h-cell> oh oh I see yes it appears to work now
22:18:47 <aavogt> Cale: can \bot import a modified vector-space that uses function show instances from smallcheck?
22:19:49 <aavogt> if I make those changes (deleting instances, adding imports and cabal file deps), will it be more likely to happen?
22:27:55 <turiya> what are hidden modules?
22:28:27 <ddarius> "Weil referred to Gentzen as the lunatic who justified induction on the natural numbers [..] using induction on a higher ordinal."
22:29:14 <turiya> was Weil right?
22:29:35 <Eduard_Munteanu> Transfinite induction?
22:31:47 <turiya> transfinite induction seems to be the reverse.. extending induction on N to ordinals (what are these?) according to wikipedia
22:55:44 <ksf> well, there are also lunatics calling people who construct sets from type theory as lunatics.
22:56:00 <ksf> after all, every decent mathematician knows that it's sets all the way down.
22:57:37 <Cale> turiya: Ordinals are standard representatives for order-isomorphism types of well-ordered sets. An ordinal is a set S for which every element of S is a subset of S, and every element of S is also an ordinal.
22:58:04 <Cale> (Note that the empty set is trivially an ordinal according to this definition)
22:59:33 <turiya> Cale, is there a simple example?
22:59:48 <Cale> Now let's build some then
23:00:19 <Cale> If w is an ordinal, then w union {w} is also an ordinal, called the successor of w
23:00:59 <Cale> Actually, I probably shouldn't be using w, for fear of confusion with omega :)
23:02:04 <Cale> So we have the empty set (which we can call 0), the set {0} which we can call 1, 2 = {0,1}, and so on
23:02:22 <Cale> So the natural numbers in this way become ordinals
23:02:54 <turiya> if v = w U {w}
23:03:16 <turiya> why is v an ordinal? i cant seem to understand this that fast..
23:03:30 <Cale> Right, let's actually prove that...
23:03:45 <Cale> So let x be some element of v.
23:03:57 <turiya> ok
23:03:57 <Cale> Either x is an element of w then, or it is w itself
23:04:13 <Cale> If x is an element of w, then we know that x is a subset of w, because w is an ordinal
23:04:22 <Cale> and so x is also a subset of w union {w}
23:05:16 <Cale> If x is w itself, then we also easily get that x is a subset of w union {w}
23:05:44 <turiya> ok.. i see the logic, why are these invented?
23:05:46 <Cale> We also have to check that x in each case is an ordinal
23:06:15 <Cale> In the first case where x is an element of w, x must be an ordinal because w was assumed to be, and in the second case, that's even more direct.
23:06:16 <lpsmith> ksf,  sets all the way down?   No proper classes?  ;-)
23:06:31 <Cale> turiya: Well, do you know what a well-ordered set is?
23:06:37 <turiya> no..
23:06:50 <Cale> Okay, so let's take a step back...
23:07:08 <turiya> cool..i though u wud ask me to go refer to wiki.. :)
23:07:09 <Cale> A totally ordered set is a set S together with a relation <= satisfying the following properties:
23:07:16 <dolio> Wouldn't proper classes be up?
23:07:28 <Cale> 1) For all a in S, we have a <= a  (reflexivity)
23:07:50 <Cale> 2) For all a, b, c in S, if a <= b, and b <= c, then a <= c  (transitivity)
23:08:10 <Cale> 3) For all a, b in S, if a <= b and b <= a then a = b  (antisymmetry)
23:08:26 <Cale> 4) For all a, b, in S, a <= b or b <= a  (totality)
23:08:41 <turiya> oh..ok, looks like it is related to equivalence classes..
23:08:55 <Cale> (if only the first two properties hold, it's called a preorder, and if the first three hold, it's called a partial order)
23:09:28 <Cale> Now, a well-ordering is a total ordering which has the special property that every nonempty subset of S has a minimum element.
23:10:12 <turiya> ok.. the <= is just like < on the reals
23:10:13 <ksf> turiya, Cale is actually a bot we coded to explain stuff because wikipedia fails to.
23:10:13 <Cale> That is, if T is any nonempty subset of S, there is some x in T so that for all y in T, x <= y.
23:10:31 <Cale> The reals are not well-ordered by their usual ordering
23:10:40 <turiya> ksf, haha.. 
23:11:01 <Cale> Because, for example, the entire set of reals is a subset, and it has no least element (you can subtract 1 from any real number to get one which is less)
23:11:34 <Cale> Note also that the interval of reals [0,1] is not well-ordered, because it has a subset {1,1/2,1/3,1/4,...} which has no least element.
23:12:04 <Cale> The integers are not well-ordered for a similar reason. But the natural numbers are.
23:12:18 <turiya> ok..
23:12:25 <Cale> If we take any nonempty subset of the natural numbers, there will be a least natural number in it.
23:13:39 <turiya> yeah, thhat could be derived from the peano axioms, i guess
23:13:44 <Cale> Ordinals provide a very large class of examples of well-ordered sets. We can define a well-ordering on any ordinal by taking x <= y to mean that x is an element of y.
23:14:40 <Cale> In fact, if we introduce an appropriate notion of equivalence or isomorphism between different well-ordered sets, there will be exactly one ordinal which is isomorphic to any given well-ordered set.
23:15:10 <lpsmith> dolio, I'm a bit lesdixic,  so down, up...  ;-)
23:15:18 <Cale> We can do induction on any well-ordered set.
23:16:18 <ksf> jmcarthur, gl-guru, SYN?
23:16:28 <Cale> Let S be a well-ordered set, and let A be a subset of S having the property that whenever all x < y belong to A, then y belongs to A as well.
23:16:39 <Cale> We can prove that A = S.
23:17:14 <Cale> Suppose not. Then S \ A = { s in S : s not in A } must be nonempty, and of course, it's a subset of S.
23:17:28 <Cale> So S \ A has a least element, say y.
23:17:56 <Cale> But that means that every element of S which is less than y must belong to A.
23:18:07 <Cale> and so by our assumption, y must belong to A as well
23:18:11 <Cale> which is a contradiction
23:18:48 <Cale> and so that's induction in general :)
23:19:15 <Cale> (sometimes this is called transfinite induction, because it's the type you need for very large sets)
23:20:42 <turiya> Cale, I only have a very basic intro to set theory. I could not possibly understand all this in a short duration. I will save what all you have said and think about it for long :)
23:21:28 <Cale> turiya: You'll also want to note that x < y is just shorthand for x <= y and x /= y.
23:21:57 <Cale> (I've been using that, but I didn't define it)
23:22:19 * hackagebot stream-monad 0.4 - Simple, Fair and Terminating Backtracking Monad  http://hackage.haskell.org/package/stream-monad-0.4 (SebastianFischer)
23:23:25 <turiya> yes..
23:24:10 * ddarius makes a Simple, Terminating, Fair, and Unrestricted monad.
23:25:49 <mauke> x<y:⇔x≤y∧x≠y
23:26:09 <turiya> Cale: set theory is based on ZF axioms but I vaguely understand that Godel's (in)completeness theorem that there are some propositions which cannot be proven to be true or false in this system.. so, why bother learning set theory with ZF?
23:26:40 <dolio> Why bother learning anything?
23:26:56 <Cale> turiya: The incompleteness theorem applies to any system powerful enough to express universal statements about arithmetic.
23:27:01 <Eduard_Munteanu> turiya: those are independent propositions.
23:27:17 <Eduard_Munteanu> It's not they're unprovable, but true
23:27:20 <ddarius> Goedel's incompleteness theorem says that about almost all interesting logics, and even without that we can't prove that our logics are meaningful, so why bother with math at all?
23:27:49 <Eduard_Munteanu> *not like
23:28:56 <Eduard_Munteanu> You might want to consider those as axioms.
23:28:59 <ddarius> Luckily, you'll be glad to know that if you view Haskell as formal logical system, everything can be proven true or false.
23:29:44 <mauke> haha
23:29:49 <mauke> s/ or false//
23:30:47 * Eduard_Munteanu leaves...
23:30:53 <Eduard_Munteanu> o/
23:31:37 <turiya> i have this vicious cycle of learning.. set theory, construction of numbers, logic.. and never get anywhere.. so i have these dumb questions..
23:32:23 <ddarius> Start working with Coq or Isabelle/HOL or Agda.
23:33:12 <dolio> Ditch the set theory. It's lame. :)
23:33:36 <ddarius> The basic notation and concept of a set is definitely useful.
23:36:22 <ksf> is a texture atlas still the way to go for performance, or should I use a battalion of texture objects? those textures have quite different size each (they're glyphs)
23:36:23 * hackagebot stream-monad 0.4.0.1 - Simple, Fair and Terminating Backtracking Monad  http://hackage.haskell.org/package/stream-monad-0.4.0.1 (SebastianFischer)
23:39:42 <ddarius> Kronecker has a nice looking plot.
23:39:44 <turiya> Cale, Eduard_Munteanu, ddarius, dolio: all of u have a math background?
23:39:58 <Cale> I do
23:40:11 <dolio> Not really.
23:40:23 <ddarius> Not formally.
23:40:58 <turiya> Cale: What type of degree do you have?
23:41:02 <turiya> ddarius : me too
23:41:05 <Cale> Just a BMath
23:41:12 <Cale> In pure mathematics
23:41:31 <ddarius> Cale turns category theory into iPhone games.
23:41:39 <Cale> :)
23:42:08 <turiya> Cale: great.. 
23:42:50 <turiya> unfortunately i had to study chemical engineering..
23:43:10 <ddarius> Chemical engineering is probably more interesting than computer science.
23:43:52 <turiya> ddarius: what do you think chem. engg. invloves?
23:45:05 <aavogt> there are still interesting optimization problems there
23:46:04 <ddarius> turiya: Processes used in chemical manufacture, such as cracking.
23:46:54 <turiya> ddarius: true.. but most of the real research happens in chemisty or physics..
23:47:06 <turiya> and chem. engg. applies them
23:47:07 <ddarius> Indeed.
23:50:28 <isBEKaml> hello, I can't seem to connect to haskell.org. is it down?
23:50:50 <isBEKaml> I merely wanted to read the haskell community report for may2010. It just timed out. 
23:51:56 <ddarius> Hmm, Lawrence Paulson's term rewriting stuff for Cambridge LCF looks like it might be fun and interesting to implement in Haskell.  It may even be useful.
23:57:22 <ksf> isBEKaml, yep, it is.
23:57:56 <ksf> at leas one of the server that is *.haskell.org is down, that is.
23:58:42 <isBEKaml> yes, that's what it looks like. Btw, is the HCAR hosted elsewhere?
23:58:58 <isBEKaml> (Haskell Communities and Activities Report)
