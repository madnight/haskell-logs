00:02:27 * hackagebot type-settheory 0.1.3.1 - Sets and functions-as-relations in the type system  http://hackage.haskell.org/package/type-settheory-0.1.3.1 (DanielSchuessler)
00:04:09 <Funktorsalat> think I'm also going to get rid of the unicode type names...
00:04:34 <Funktorsalat> data (set1 :: SET) :⊆: (set2 :: SET) where
00:04:34 <Funktorsalat>        Subset :: (forall a. a :∈: set1 -> a :∈: set2) -> set1 :⊆: set2
00:04:56 <Funktorsalat> it's so pretty but I guess it excludes everyone who can't be bothered to figure out how to enter them
00:05:46 <Funktorsalat> where #define PROP *     #define SET (* -> PROP)
00:05:48 <Funktorsalat> :)
00:21:07 <pelotom> the section on invariants in RWH's STM chapter is woefully short
00:21:22 <pelotom> this 'alwaysSucceeds' function seems magical
00:22:35 <Saizan> ?hoogle alwaysSucceeds
00:22:35 <lambdabot> No results found
00:22:50 <pelotom> http://www.haskell.org/ghc/docs/6.10.2/html/libraries/base/GHC-Conc.html#v%3AalwaysSucceeds
00:25:32 <Saizan> the magical one is checkInv, and in fact it's a primitive
00:26:40 <Saizan> you couldn't implement anything like that from the rest without a global transformation of your code
00:27:24 <pelotom> @hoogle checkInv
00:27:24 <lambdabot> Data.ByteString.Lazy.Internal checkInvariant :: ByteString -> ByteString
00:27:53 <pelotom> Saizan: where is this checkInv you speak of?
00:28:29 <Axman6> pelotom: in the source of alwaysSucceeds
00:28:39 <pelotom> ah, ok
00:29:01 <Saizan> ah, sorry, i assumed it was also exposed
00:29:15 <Saizan> *exported
00:29:23 <arcatan> lately I've been reading more and more source when looking for documentation. i wonder if that is a good thing...
00:35:33 <pelotom> man, STM is really cool
00:49:10 <cch`> @hoogle a->(a)
00:49:10 <lambdabot> Prelude id :: a -> a
00:49:10 <lambdabot> Data.Function id :: a -> a
00:49:10 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
00:49:58 <JoshTriplett> I have a crazy type inference goal I'd like to reach, and I'd love some suggestions.  http://hpaste.org/41084/type_inference_hijinks
00:50:18 <JoshTriplett> I want to infer the type to use in "sizeOf" from the element type of the array returned by the function.
00:51:50 <JoshTriplett> However, GHC complains of an ambiguous type, and some experiments confirm that it apparently generalizes the type of "elemType" to "forall a.a".
00:53:43 <Saizan> JoshTriplett: i'd just use ScopedTypeVariables
00:53:53 <JoshTriplett> Saizan: Really tempting, yeah. :)
00:54:03 <JoshTriplett> But having started down this path, I wanted to figure out why I couldn't make it work. ;)
00:54:40 <Saizan> http://hpaste.org/paste/41084/abusing_the_monomorphism_restr#p41085 <- this one should work
00:55:16 <Saizan> yours doesn't because elemType is polymorphic, so each use can potentially be at a different type
00:55:44 <Saizan> in mine, elemType is still polymorphic, but result shouldn't be, thanks to the monomorphism restriction
00:56:08 <JoshTriplett> Creative, thanks!
00:56:35 <Saizan> i guess "let elemType = (undefined :: Storable e => e)" could have also worked then
00:58:25 <cch`> @hoogle (a,b,c) -> c
00:58:26 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
00:58:26 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
01:00:20 <cch`> @hoogle tuple
01:00:20 <lambdabot> module Data.Tuple
01:00:20 <lambdabot> Language.Haskell.Syntax tuple_con :: Int -> HsExp
01:00:20 <lambdabot> Language.Haskell.Syntax tuple_con_name :: Int -> HsQName
01:29:57 <Veinor> lol, I just thought of the perfect operator for lookup
01:30:09 <Veinor> の
01:31:36 <Veinor> aw, unicode characters can't be operators without ``. lame.
01:32:40 <Saizan> Symbols and Punctuation characters can
01:32:53 <Saizan> but の is probably a letter
01:33:19 <Saizan> > Data.Char.isLetter 'の'
01:33:19 <lambdabot>   True
01:38:36 <Veinor> @src (>=>)
01:38:36 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:49:10 <lars9> if f :: a -> b may throw exception, can we convert it to f' :: a -> Either String b ?
01:50:17 <lars9> if an exception is threw, then return Left error_message
01:51:37 <Veinor> :t try
01:51:38 <lambdabot> Not in scope: `try'
01:51:41 <Veinor> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Control-Exception.html#v%3Atry
01:52:37 <lars9> it returns IO eventually
01:52:49 <Veinor> there's no way to 'get out' of IO, if that's what you mean
01:53:37 <lars9> i see, exception is IO?
01:54:10 <Veinor> yeah.
01:54:47 <lars9> thanks
01:55:32 <Veinor> you can't handle exceptions without being in the IO monad
01:55:52 <lars9> it seems so...
02:07:12 <pelotom> lars9: you can technically do it using unsafePerformIO
02:07:47 <pelotom> let x = unsafePerformIO $ try (something that might throw an exception)
02:32:09 <mlesniak> stm-2.2.2.0 is broken with ghc-6.12 (throwSTM not found). Unfortunately some packages depend on this version (e.g. concurrent-extras). Is there any way to fix this locally (for my machine)?
02:35:18 <Jafet> @hackage spoon for lars9
02:35:19 <lambdabot> http://hackage.haskell.org/package/spoon for lars9
02:35:28 <opqdonut> :D
02:38:23 * hackagebot stm 2.2.0.1 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.2.0.1 (SimonMarlow)
02:39:48 <Saizan> wow, fixes in realtime.
02:40:26 <Jafet> Guess the answer is no, then.
02:41:24 <Saizan> mlesniak: so, cabal update and it'll pick 2.2.0.1 :)
02:42:20 <Saizan> mlesniak: btw, it doesn't seem like concurrent-extra requires stm >= 2.2, so you could have specified --contraint="stm < 2.2" to get an older version
02:42:25 <mlesniak> Saizan, how long is 2.2.0.1 out. I loaded the stm-page maybe 5 minutes ago and there was only 2.2.0.0 :D
02:42:31 <merijn> In the context of type theory, what would be meant by "elaborating a program"? I have no clue what they're intending to say and "teh Googlez" is decidedly unhelpful for the word combination "program elaboration"...
02:42:57 <merijn> mlesniak: The update was announced by hackagebot about 6 minutes after your question :p
02:43:03 <dcoutts__> merijn: probably they mean doing type inference and producing a fully type-annotated version of the program
02:43:25 <mlesniak> *laughs* Ah, I see :)
02:44:59 <merijn> dcoutts__: They're adding new term definitions for the type theory. So I'm guessing the intention is to extend the accepted terms in the theory to fit the language requirements?
02:45:55 <Saizan> merijn: or if not type inference some other kind of transformation, usually from user-level syntax to some "core" theory
02:46:51 <merijn> Saizan: That makes sense in this context, yeah
02:47:53 <Saizan> an usual operation is to introduce some new user-level construct by showing how it elaborates into the core theory, which remains the same instead
02:48:37 <Saizan> you could consider it desugaring on steroids :)
02:51:55 <tibbe> Igloo: can you access /home/tibbe/ghc/master/libraries/base/fix-4348.dpatch ?
02:58:28 * hackagebot monad-peel 0.1 - Lift control operations like exception catching through monad transformers  http://hackage.haskell.org/package/monad-peel-0.1 (AndersKaseorg)
03:29:18 <Blkt> good day everyone
03:31:41 <yf`> you too
03:34:13 <Blkt> yf`: :D
03:40:06 <Nebukadneza> heho
03:40:34 <Nebukadneza> i was wondering what to import on a ghci commandline to get the trace command? (i can't seem to find documentation for that ;/)
03:40:50 <mux> Debug.Trace
03:40:56 <mux> @index trace
03:40:56 <lambdabot> Debug.Trace
03:41:08 <Nebukadneza> so simple 'import Debug.Trace' should do it?
03:41:26 <mux> in the ghci prompt, you'd do :m Debug.Trace
03:41:43 <Jafet> Or import Debug.Trace
03:41:47 <Nebukadneza> ah okay, thanks alot! :P
03:47:23 <jkff> Hi folks. Can anyone help me diagnose this problem http://hpaste.org/41086/jkff ? It's a linker error while loading the cairo library from ghci
03:47:33 <jkff> Where should I look to determine the cause of this?
03:48:23 <exDM69> jkff: perhaps a version mismatch between your cairo lib binaries and the haskell binding
03:48:23 <jkff> Is it that I've built cairo incorrectly? Or are some libraries missing from my PATH?
03:48:39 <jkff> But I've looked into all the cairo dlls on my hard drive :) and they do have cairo_surface_destroy
03:48:50 <jkff> However I'm not 100% sure that it's _cairo_surface_destroy
03:48:54 <jkff> (with an underscore)
03:49:01 <jkff> Could that matter?
03:49:36 <jkff> I mean, I know where to look when resolving problems with dynamic linking of dlls - there are tools for that. But how should I *diagnose* this one?
03:49:39 <Jafet> That's normal with the C ABI.
03:50:53 <jkff> Generally, does this error say that ghci can't *dynamically* find Cairo, or does it say that HScairo.o is corrupt?
03:51:13 <jkff> I tried various verbosity levels but couldn't get ghci to tell me where it's looking for cairo in runtime
03:54:18 <jkff> By the way, is linking in GHC by default static or dynamic?
03:56:09 <Janni> Hello. I need a little help...
03:56:30 <Janni> cabal upload gives me an error, saying that "section syntax" is required
03:56:50 <Janni> I can't interpret this error and I can't find information what exactly section syntax is.
03:57:08 <Janni> Oh, I think I just got it.
03:57:16 <Janni> Tabs may not be used (anymore) to indent
03:57:41 <Janni> No still not OK.
03:57:48 <dcoutts__> Janni: run: "cabal check"
03:57:52 <dcoutts__> before upload
03:59:33 <Janni> Thanks, but it doesn't give me any errors
04:01:23 <dcoutts__> Janni: newer cabal versions add more checks, so hackage can sometimes complain when your local cabal check does not
04:01:38 <dcoutts__> Janni: if you're still stumped, post your .cabal file somewhere
04:03:17 <merijn> jkff: I believe its static, but I might be wrong
04:19:26 <Janni> Here's the .cabal file that gives me headaches: http://pastebin.ca/1980532
04:20:13 <Janni> The error: "SoccerFun-0.3.5/SoccerFun.cabal: A package using 'cabal-version: >=1.6' must use section syntax. See the Cabal user guide for details."
04:22:24 <dcoutts__> Janni: ok, did you look in the cabal user guide?
04:22:40 <Janni> Yes, but I couldn't identify the error I made...
04:22:52 <dcoutts__> did you see what section syntax is?
04:23:34 <Janni> I think I did. (although the term "section syntax" is not used in the user guide...
04:23:54 <dcoutts__> http://haskell.org/cabal/release/cabal-latest/doc/users-guide/authors.html
04:24:07 <Janni> Oh... Curly braces...
04:24:24 <Janni> No.. Doesn't seem to be a requirement...
04:24:37 <dcoutts__> Janni: right, it's not a requirement
04:24:53 <Janni> Sorry, I'm a bit hard pressed to get this package uploaded...
04:25:28 <dcoutts__> Janni: well, see how the syntax uses sections, with libraries and executables in named sections
04:25:40 <dcoutts__> Janni: look at the examples in that section of the user guide
04:25:48 <dcoutts__> and look at your current .cabal file
04:25:54 <dcoutts__> see what I mean?
04:26:52 <Janni> Ah yes, completely missed that.
04:26:54 <Janni> Thank you.
04:30:05 * hackagebot SoccerFun 0.3.5 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.3.5 (JanRochel)
04:30:12 <lars9> how to get max limitation of Int ?
04:31:18 <quicksilver> > maxBound :: Int -- lars9
04:31:19 <lambdabot>   9223372036854775807
04:31:25 <lars9> quicksilver: thanks
04:33:06 <lars9> emacs just crashed when using haskell-mode!
04:33:33 <quicksilver> :(
04:50:05 <nus> lars9, emacs version?
04:50:51 <lars9> nus: latest version in archlinux
04:51:00 <lars9> nus: 23.2.1
04:51:09 <lars9> anyway, it rarely happens
04:59:35 <Xilon> Hello. I've got an issue building a library linking with C code. For some reason ghc isn't compiling the C file when run through cabal: http://hpaste.org/paste/41088
05:00:51 <Xilon> Still a newbie so I'm probably doing something wrong, but I haven't been able to find any examples for FFI libs
05:04:35 <Lemmih> Xilon: Your executable doesn't use the library. It uses the sources directly.
05:09:05 <Xilon> Either way it should have the symbols though? ocauth.c never gets compiled
05:09:34 <Xilon> Oh, the library isn't used so the source doesn't get compiled?
05:15:43 <Xilon> Lemmih: Got it working. Thanks :)
05:23:08 <dcoutts__> Xilon: right, each component is actually independent.
05:23:33 <dcoutts__> there's a way to have one depend on the other, but there's some rough edges to that feature still
05:31:38 <lars9> when we need to deal with consecutive elements of a list, how to do it elegantly? for example, find the x,y in a list where x*2 == y
05:32:40 <lars9> x,y are neighbors
05:33:35 <Saizan> ?type find (\(x,y) -> x*2 == y) . ap zip tail
05:33:36 <lambdabot> forall t. (Num t) => [t] -> Maybe (t, t)
05:33:52 <Ytinasni> zip xs (tail xs), and map/filter on that?
05:33:59 <Saizan> > find (\(x,y) -> x*2 == y) . ap zip tail $ [1,2,3,4,8,4,3,2]
05:34:00 <lambdabot>   Just (1,2)
05:34:08 <Saizan> > find (\(x,y) -> x*2 == y) . ap zip tail $ [0,2,3,4,8,4,3,2]
05:34:09 <lambdabot>   Just (4,8)
05:34:50 <lars9> :i ap
05:35:00 <lars9> @:i ap
05:35:00 <lambdabot> Maybe you meant: . ? @ bf bid do ft id pl rc v wn
05:35:07 <lars9> @:src ap
05:35:07 <lambdabot> ap = liftM2 id
05:35:21 <lars9> @:src liftM2
05:35:21 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
05:35:40 <silver> you can omit ":" here
05:35:47 <silver> @src foldr
05:35:47 <lambdabot> foldr f z []     = z
05:35:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
05:36:13 <lars9> this is good
05:36:19 <lars9> i can not use src in ghci
05:43:12 <hpc> you only need the ':' for a few select aliases
05:43:18 <hpc> and those are only to mimick ghci
05:52:21 <hpc> @instances Monoid
05:52:22 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
05:52:34 <hpc> @instances MonadPlus
05:52:34 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
05:54:06 <hpc> it seems Monoid is what i want then...
05:55:18 <hpc> so now i have catchM action = action `catch` \_ -> return mempty
06:03:37 <tolkad> Does liftIO seem a bit too abstract to be safe? Shouldn't it have some rules associated with it?
06:04:35 <companion_cube> liftIO is like liftM, isn't it ?
06:04:39 <hpc> @src liftIO
06:04:40 <lambdabot> Source not found. :(
06:05:06 <hpc> liftM == liftIO, i thought
06:05:14 <tolkad> no
06:05:20 <companion_cube> it's for monad transformers
06:05:20 <hpc> :t liftIO
06:05:21 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
06:05:26 <hpc> oh
06:05:42 <hpc> :t lift
06:05:43 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
06:05:57 <tolkad> it's for use with monads that hold IO computations
06:06:08 <companion_cube> so it's rather like lift ?
06:06:10 <hpc> would liftIO == lift, then?
06:06:12 <tolkad> no
06:06:19 <tolkad> :t lift
06:06:20 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
06:06:49 <hpc> MonadIO m is generally going to be (m IO) though
06:07:17 <hpc> unless it somehow isn't, which would be magic and/or unsafe
06:07:29 <companion_cube> so, one can embed IO in a monad without using this monad transformer ?
06:08:19 <hpc> why would liftIO be unsafe?
06:09:27 <hpc> unless liftIO = return . unsafePerformIO...
06:09:38 <tolkad> for example, I can write « newtype MyIOThing a = MkMyIOThing (IO a); instance Monad MyIOThing where { (MkMyIOThing x) >>= k = x >>= k; return = MkMyIOThing . return }; instance MonadIO MyIOThing where { liftIO = MkMyIOThing }
06:09:41 <tolkad> »
06:10:08 <tolkad> except if this were a realy implementation MyIOThing would probably have some other useful semantics as well
06:10:35 <tolkad> the reason I'm asking whether it is safe, is you have no idea what those semantics are
06:10:48 <tolkad> all you know is that it can hold an IO action in some manner
06:10:57 <tolkad> you don't even know whether it will be executed
06:11:09 <tolkad> this for example, could lead to a deadlock if something doesn't get released
06:11:11 <Axman6> = x >>= MkMyIOThing . k
06:12:00 <tolkad> Axman6: what?
06:12:15 <Axman6> oh wait, that is correct, my bad
06:12:50 <tolkad> no wait you are right... mine doesn't work
06:14:01 <Axman6> well k :: a -> MyIOThing b, so it does work
06:14:09 <lars9> when processing a string, i need to use different parsing methods for different type of strings, for example: if isType1 then processAsType1 else if isType2 then processAsType2...
06:14:11 <Axman6> uh, no
06:14:21 <lars9> can we make it neater using Either and functor?
06:14:22 <Axman6> because then things have the wrong type
06:14:40 <tolkad> lars9: there is only one type of string
06:14:51 <tolkad> lars9:  a string represents a sequence of characters
06:15:16 <lars9> tolkad: i mean its content may have different meaning, so i need to parse differently
06:15:17 <Axman6> lars9: what do you mean?
06:15:29 <tolkad> lars9: that's what parsing IS
06:15:31 <Axman6> arsing it as things with different types?
06:15:50 <Axman6> p*
06:15:52 <tolkad> lars9: that's like saying "Different messages have different meanings so I have to read them differently"
06:15:55 <lars9> for example the string maybe human name, city name, stars name
06:16:26 <lars9> i need to apply different functions on them
06:16:31 <hpc> lars9: start by figuring out how to tell which is which
06:17:09 <tolkad> lars9: uh that depends on context, you'll probably want to validate them and then change them into your internal representation before passing them to your application logic
06:17:13 <lars9> hpc: sorry my english vocabulary is limited...
06:17:42 <tolkad> lars9: call different functions
06:18:11 <tolkad> lars9: for example you could have parseHumanName :: String -> Maybe HumanName
06:18:33 <tolkad> lars9: or class Parsable a where parse :: String -> Maybe a
06:18:33 <lars9> tolkad: yeah, this is like what i want
06:19:03 <tolkad> lars9: if you need anything more complex than that like the combination of parsing functions, you'll want to use a library
06:19:36 <tolkad> for example: http://hackage.haskell.org/package/parsec-3.0.0
06:19:40 <lars9> every parsing function should be: if parsing well then return parsing result, otherwise try another parsing function
06:20:05 <tolkad> lars9: that doesn't make sense, a human name might also be a city name
06:20:44 <tolkad> lars9: you need to parse differently depending on context. the Parsable class only works if you have a different datatype for each parsable object
06:21:01 <tolkad> lars9: perhaps you could explain where these strings are coming from?
06:23:20 <lars9> tolkad: hmmm... let me read more about functor first, im kind of confusing ppl around here
06:23:23 <tolkad> lars9: it's possible you really are recieving a string as input and you want to know whether it can be parsed as a human name, or a city name, etc.
06:23:50 <tolkad> lars9: but more likely you should already know what you are trying to parse
06:24:34 <lars9> tolkad: imagine this, you need to read user's input to decide what to do next
06:24:49 <tolkad> lars9: ok...
06:25:04 <Darkone> lars9, did you check out the learnyouahaskell tutorials?
06:25:15 <lars9> tolkad: so you need to first parse user's input a little bit, to decide which function you need to call to process rest input
06:25:21 <Darkone> One shows how haskell makes it easy to bind functions to strings.
06:25:34 <Darkone> ("add",add)
06:25:38 <tolkad> lars9: that's just one big parse then
06:25:44 <Darkone> Right.
06:26:12 <tolkad> lars9: you could use parsec for that, or implement it as a function which parses that little bit, and then calls another function to parse the rest
06:26:20 <Darkone> (function:arguments) <- getArgs     or something like that.
06:26:26 <Darkone> Right? :P
06:27:15 <tolkad> lars9: you can then return a wrapper type like data Input = InputHumanName HumanName | InputCityName CityName
06:27:20 <lars9> Darkone: but it's not directly string binding, for example, i need to see if the input contains '/', if the input contains ','..etc
06:27:29 <tolkad> lars9: multiple passes
06:27:46 <tolkad> lars9: parse it once to check, then go back to the beginning and call the appropriate parse function
06:28:07 <Darkone> Have you tried presenting some case data? So everyone knows what you want exactly?
06:28:18 <lars9> tolkad: yeah, exactly what i want
06:29:17 <tolkad> lars9: be aware there are parsing libraries to handle this kind of stuff automatically for you, like parsec: http://hackage.haskell.org/package/parsec-3.0.0
06:30:38 <lars9> so is it possible to make every function look like: if imWorkingWell then return myResult else pass to next function
06:32:25 <lars9> then we can just connect them using some operator(assuming >- here) f1 >- f2 >- f3 >- f4 ... >- fn userInput
06:34:14 <EvanR-work> lars9: Maybe
06:34:32 <aristid> mtl 2.0 is the new standard?
06:34:37 <EvanR-work> > Just 8 >> Just 9
06:34:37 <lambdabot>   Just 9
06:34:43 <EvanR-work> > Just 8 >> Nothing >> Just 9
06:34:44 <lambdabot>   Nothing
06:34:48 <aristid> can i switch to mtl 2.0 before all dependencies have done so?
06:35:16 <Jafet> @let merge xs@(x:_) ys@(y:_) = let p = fromEnum (x<y) in ([y,x]!!p) : merge ([id,tail]!!p$xs) ([tail,id]!!p$ys)
06:35:17 <lambdabot>  Defined.
06:35:32 <EvanR-work> or Either since you want 'my result' in case of error
06:36:07 <lars9> EvanR-work: but Either is not Monad, cannt use >>
06:36:14 <EvanR-work> @instances Monad
06:36:15 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:36:35 <ray> import Control.Monad.Instances
06:36:54 <EvanR-work> i heard Either has two instances, one of which is the useful one
06:36:56 <ray> and really it's Either a that's an instance not Either
06:37:06 <EvanR-work> Either e i mean
06:37:15 <ray> you have to fix one argument
06:37:24 <aristid> Either's instance is in Control.Monad.Error iirc
06:37:25 <lars9> ray: T_T i didn't import that pkg...
06:37:35 <aristid> instance Error e => Monad (Either e)
06:37:45 <ray> yeah. if things that should be Monads aren't import that
06:38:04 <ray> also related classes
06:38:36 <ray> i believe that module contains several Applicative instances for example
06:39:28 <EvanR-work> > Right 1 >> Right 2
06:39:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:39:29 <lambdabot>    `Control.Monad.Error.Cla...
06:39:55 <lars9> (Either a), a is for Left, right?
06:40:02 <EvanR-work> > Right 1 >> Right 2 :: Either a Int
06:40:03 <lambdabot>   Could not deduce (Control.Monad.Error.Class.Error a)
06:40:03 <lambdabot>    from the context ()...
06:40:10 <EvanR-work> yes
06:40:29 <lars9> > Right 1 >> Left 2
06:40:30 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:40:30 <lambdabot>    `GHC.Num.Num a'
06:40:30 <lambdabot>      ari...
06:41:51 <aristid> :t Right 1 >> Left 2
06:41:52 <lambdabot> forall a b. (Num a, Error a) => Either a b
06:41:56 <lars9> > Right 'a' >> Left 'c'
06:41:57 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Types.Char)
06:41:57 <lambdabot>    arising...
06:42:13 <aristid> > Right "a" >> Left "c"
06:42:14 <lambdabot>   Left "c"
06:42:23 <aristid> String is an instance of Error.
06:42:38 <aristid> > Right "a" >> fail "FAILED!"
06:42:39 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:42:39 <lambdabot>    `Control.Monad.Error.Cla...
06:42:44 <aristid> :t Right "a" >> fail "FAILED!"
06:42:44 <lambdabot> forall a b. (Error a) => Either a b
06:42:54 <aristid> > Right "a" >> fail "FAILED!" :: Either String String
06:42:55 <lambdabot>   Left "FAILED!"
06:43:04 <aristid> @instances Error
06:43:04 <lambdabot> IOError, String
06:43:16 <aristid> > Right "a" >> fail "FAILED!" :: Either IOError String
06:43:17 <lambdabot>   Left user error (FAILED!)
06:43:46 <lars9> @instances Monad
06:43:47 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:44:42 <lars9> i've added moudle Control.Monad and Control.Monad.Instances, but (Either a) is still not a Monad, so strange..
06:45:41 <EvanR-work> thats stupid
06:45:56 <EvanR-work> why is Either e caught up with Error
06:46:12 <lars9> which module do i miss?
06:46:22 <quicksilver> EvanR-work: because of 'fail'
06:46:41 <EvanR-work> what about it
06:47:02 <quicksilver> it requires you have something sensible to do with String arguments
06:47:09 <quicksilver> and that's what the Error class is asbout
06:47:12 <quicksilver> yes, it's annoying.
06:47:16 <quicksilver> but fail is annoying anyway.
06:47:19 <quicksilver> that's the reason.
06:47:27 <EvanR-work> fine but that doesnt mean Either e should have anything to do with it
06:47:41 <quicksilver> yes, it does.
06:47:52 <quicksilver> the entire purpose of Error is to allow Either to do something sensibel for 'fail'
06:48:07 <EvanR-work> i dont want to use Error
06:48:08 <quicksilver> the Error class is there to explain what to do with the string argument to fail.
06:48:08 <lars9> oh wait, is the 'e' in Either e special? not just any type?
06:48:15 <EvanR-work> no
06:48:30 <quicksilver> EvanR-work: I know. I agree it's annoying. I"m just explaining the reason.
06:48:31 <EvanR-work> also, i dont want to mess with fail
06:48:38 <quicksilver> I'm not saying I agree with the reasoning, particularly.
06:48:49 <EvanR-work> i havent implemented fail so it must have a reasonable default
06:49:02 <EvanR-work> anyway, there must be another implementation of Either e somewhere
06:49:02 <quicksilver> it defaults to calling "error"
06:49:10 <jkff> Guys, sorry for bugging (already asked this today) but perhaps now someone has gone online who can help me - I've still not resolved the problem. How can I diagnose this http://hpaste.org/41086/jkff ? - linking error for cairo (in ghci or during compilation of anything dependent)
06:49:57 <EvanR-work> lars9: it should be any type, but in a certain instance of Monad it must be an instance of Error
06:50:47 <EvanR-work> quicksilver: seems like a cambrian explosion of ways to do errors
06:50:49 <lars9> EvanR-work: so can any Either be monad? such as Either String
06:51:00 <jkff> I don't even understand what exactly ghci is complaining about - failure to resolve a dynamic link dependency? Mislinked HScairo.o file?
06:51:01 <quicksilver> Yes, any 'Either e' can be a Monad.
06:51:12 <Jafet> > let primes = nubBy (((>1).).gcd) [2..]; mergeinf ((x:xs):(y:ys):r) = if y<x then mergeinf (merge (x:xs)(y:ys):r) else x:mergeinf (xs:(y:ys):r) in mergeinf $ ((.[2..]).flip(^)).primes
06:51:13 <lambdabot>   [4,8,9,16,25,27,32,36,49,64,64,81,100,121,125,128,144,169,196,216,225,243,2...
06:51:14 <quicksilver> you can use the supplied instance with its annoying Error constraint.
06:51:21 <quicksilver> just define a vacuous Error instance
06:51:23 <quicksilver> it doesn't matter.
06:51:28 <quicksilver> it's annoying, btu doesn't matter.
06:52:21 <lars9> quicksilver: what should I import to make Either String a monad? i've imported Monad and Monad.Instances
06:52:36 <Jafet> The instance is in Monad.Error.
06:52:40 <quicksilver> Control.Monad.Error
06:52:45 <lars9> oops
06:52:47 <lars9> see
06:53:09 <EvanR-work> quicksilver: define a vacuous Error, how about define a different Either e instance
06:53:18 <EvanR-work> one with no fail
06:53:25 <quicksilver> if you like.
06:53:31 <quicksilver> that's not what I said.
06:53:35 <lars9> quicksilver: now Left "Find" becomes a (Error String) ?
06:53:39 <EvanR-work> i know
06:53:44 <quicksilver> I said you CAN use the supplied instance with its annoying Error
06:53:48 <quicksilver> you CAN do whatever you want
06:53:53 <quicksilver> I didn't say what you have to do.
06:54:11 <EvanR-work> well you said 'or' so it made it sound exclusive and complete
06:54:31 <quicksilver> lars9: no. Left "Find" remains what it was before. Either String b
06:54:52 <quicksilver> lars9: it just becomes an instance of Monad (and String becomes an instance of Error)
06:55:46 <lars9> quicksilver: can I just not import Monad.Error, and define Either a as instance of Monad in my own code?
06:55:55 <quicksilver> yes, you can.
06:56:07 <EvanR-work> there must be one of those in some package
06:56:17 <EvanR-work> 'the sane Either e'
06:56:36 <EvanR-work> is the Error thing part of the standard or what
06:57:09 <jkff> Generally, where can I read about how GHC does linking?
06:58:24 <quicksilver> EvanR-work: no, it's part of no standard.
06:58:47 <quicksilver> EvanR-work: I think you're making a bigger deal of this than you need to.
06:58:48 <Axman6> jkff: you might try asking in #ghc
06:58:58 <quicksilver> Error is annoying in the same way that fail is annoying.
06:59:07 <quicksilver> You've apparently ignored fail up until now but not implementing it
06:59:20 <quicksilver> you can ignore Error in almost the same way - by not (really) implementing it.
06:59:30 <quicksilver> instance Error Foo where -- empty instance
06:59:42 <quicksilver> so it's not really a problem in practice
06:59:43 <jkff> Thanks Axman6, I'll look there
07:06:39 <dankna> hmm
07:10:54 <dankna> I'm the author of direct-daemonize, and I'm getting bitten by some interaction between the -threaded RTS and the FFI
07:11:02 <dankna> the daemon /sometimes/ fails to start
07:11:31 <dankna> somebody opened a ticket on ghc for what is probably my bug -- http://hackage.haskell.org/trac/ghc/ticket/4449 :)
07:18:04 <lars9> great, just converted a big chunk of if/else's into >>= >>= >>=
07:18:43 <dankna> excelling
07:20:03 * hackagebot xml-monad 0.3.1 - Monadic extensions to the xml package.  http://hackage.haskell.org/package/xml-monad-0.3.1 (AristidBreitkreuz)
07:20:32 <aristid> yay, mtl 2.0 ftw
07:21:02 <dankna> hmm
07:21:25 <dankna> so I think I may need (I'm not sure yet whether it would resolve my issue or not) to force all Haskell operation to be suspended during a particular foreign-function call
07:21:30 <dankna> oh wait, no
07:21:33 <dankna> I think I just realized something
07:21:46 <aristid> dankna: no problem, glad i could help
07:21:50 <dankna> lol!
07:22:07 <dankna> because the ffi call forks (it is daemon()), I need to explicitly kill all Haskell threads but the current onea
07:22:15 <dankna> hmm
07:22:26 <dankna> I wonder if that's even possible
07:25:46 <dankna> question: does the GHC runtime ever create worker threads on its own, without being asked to by forkIO?
07:27:11 <dankna> hmm
07:27:32 <dankna> maybe I can look at ghc's implementation of forkProcess.  it must deal with some of the same gotchas as I have to.
07:27:45 <dankna> (yes, I really do want to have the foreign code do the fork() instead of doing it through forkProcess)
07:28:00 <dankna> (because it's a standard, POSIX function that accomplishes a task which is otherwise very difficult to accomplish portably)
07:28:15 <dankna> (daemon() is, that is, not fork())
07:29:04 <stepcut> dankna: I assume you know about hdaemonize?
07:29:15 <dankna> I do.  hdaemonize is less portable because it does things in Haskell.
07:29:32 <lars9> is there a built-in function to Integer -> String with specified base?
07:29:41 <dankna> it also doesn't do certain things that daemons are supposed to do, because they are difficult in Haskell.
07:29:43 <Jafet> @index showIntAtBase
07:29:44 <lambdabot> Numeric
07:29:49 <dankna> I am the author of direct-daemonize, and its raison d'etre is to address those two shortcomings
07:29:57 <silver> @hoogle Integer -> String
07:29:57 <lambdabot> Prelude show :: Show a => a -> String
07:29:58 <lambdabot> Text.Show show :: Show a => a -> String
07:29:58 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
07:30:03 <stepcut> dankna: spiffy
07:30:13 <dankna> thanks.  it would be spiffier if it didn't have this bug :)
07:30:27 <dankna> I'll admit I actually enjoy having to poke around in ghc implementation, but...
07:30:32 <dankna> that doesn't mean I'm good at it
07:30:41 <dankna> >< fire alarm just went off here
07:32:06 <stepcut> dankna: even forkProcess has been (or may still be) a source of issues when it comes to what happens in the forked processed. Not sure how much trouble you will run into trying to using a native call..
07:32:20 <dankna> yeah I am sure
07:33:27 <lars9> @hoogle Int -> Char
07:33:27 <lambdabot> Data.Char chr :: Int -> Char
07:33:27 <lambdabot> Data.Char intToDigit :: Int -> Char
07:33:27 <lambdabot> Data.ByteString.Char8 index :: ByteString -> Int -> Char
07:33:48 <stepcut> dankna: will your code work on platforms besides linux? (eg, windows)
07:34:23 <stepcut> dankna: I would like to integrate something sensible into happstack (even if 'integration' just means showing how to use it in the documentation)
07:34:31 <lars9> oops what's happening? 
07:34:51 <merijn> lars9: Netsplit
07:35:04 <lars9> merijn: see...
07:36:21 <dankna> stepcut: I aim to make it work on Lin, Win, and the Mac
07:36:38 <dankna> stepcut: but testing on Win is hard for me
07:37:06 <silver> lars9, there is also web-front-end http://www.haskell.org/hoogle/
07:37:46 <lars9> silver: i installed cli version, but it's not as good as lambdabot
07:52:26 <Jafet> Hm, CReal is surprisingly memory efficient
08:04:01 <Cale> Jafet: Perhaps, but it's not very time efficient at all.
08:04:46 <Jafet> From looking at the code, the tradeoff seems deliberate.
08:08:47 <tibbe> what's the cleanest (yet still efficient) way to implement this case fallthrough:
08:08:49 <tibbe> 	switch(len)
08:08:49 <tibbe> 	{
08:08:49 <tibbe> 	case 3: h ^= data[2] << 16;
08:08:50 <tibbe> 	case 2: h ^= data[1] << 8;
08:08:50 <tibbe> 	case 1: h ^= data[0];
08:08:50 <tibbe> 	        h *= m;
08:08:51 <tibbe> 	};
08:08:55 <roconnor> @pl \l -> map (p2 l) (h (p1 l))
08:08:55 <lambdabot> liftM2 map p2 (h . p1)
08:09:38 <lars9> how to understand  type ReadS = String -> [(a,String)], why it returns a list?
08:10:08 <Jafet> What do you think it should return, lars9?
08:10:09 <roconnor> lars9: multiple possible parses
08:10:33 <roconnor> lars9: though everything the Haskell 98 either returns the empty list or a singleton
08:11:03 <Botje> tibbe: don't paste so many lines in the channel, use hpaste or somesuch
08:11:03 <Jafet> "And for everything else, there is parsec"
08:11:16 <lars9> for example, readInt :: (Integral a) => a -> (Char->Bool) -> (Char->Int) -> ReadS a , so (readInt base isdig d2i) is an integer readerS
08:11:39 <roconnor> @src read
08:11:39 <lambdabot> read s = either error id (readEither s)
08:11:47 <roconnor> @src readEither
08:11:47 <lambdabot> Source not found. You type like i drive.
08:11:50 <roconnor> pfft
08:11:57 <Botje> tibbe: you could have a list of functions that each transform f, drop functions as needed, and then compose the rest
08:12:01 <tibbe> Botje: I thought that was borderline OK, there was no talking going on ;)
08:12:17 <tibbe> Botje: right, but that wouldn't generate very good code
08:12:38 <Botje> i don't know, check
08:12:52 <Botje> you could always compose them by hand and dispatch on the number
08:12:54 <Jafet> Pack an array and unsafeCoerce
08:13:27 <Jafet> Oh wait, you're not supposed to do that in C either.
08:13:56 <Botje> case len of 3 -> h . h1 . h2 . h3; 2 -> h . h1 . h2; 1 -> h . h1; _ -> h
08:13:59 <Botje> roughly
08:14:26 <tibbe> Botje: http://hpaste.org/41098/tibbe
08:17:50 <Jafet> foldr ($) n (take len [h, h1, h2])
08:18:10 <Botje> tibbe: looks okay
08:18:13 <Botje> if a bit strict ;)
08:18:15 <Jafet> Though I doubt ghc's optimizer will figure out half of what that does
08:19:45 <tibbe> Jafet: it generates Core which is very close to that (except unboxed)
08:21:48 <Jafet> Well, I don't think you can ever expect to make a remotely portable jump table in Haskell
08:23:57 <tibbe> Jafet: I'd be happy as long as GHC creates one
08:27:24 * hackagebot redis 0.9 - A driver for Redis key-value database  http://hackage.haskell.org/package/redis-0.9 (AlexanderBogdanov)
08:28:34 <opqdonut> a function is doing 30% of my allocs according to profiling
08:28:45 <opqdonut> but the core shows that it does primitive arithmetic
08:29:56 <opqdonut> however, it is allocating some error closures (to report array index errors)
08:36:07 <opqdonut> hmm, figures remain the same even if I use Data.Array.Base.unsafeAt
08:36:09 <opqdonut> so it's not that
08:43:14 <_Matt_J_W_> Anyone know a channel for discusing general theoretical comp science?
08:44:44 <DoYouKnow> there are several, depending on what you want to discuss
08:44:51 <DoYouKnow> #ai is one
08:45:21 <_Matt_J_W_> discrete math stuff
08:45:25 <DoYouKnow> actually, not entirely theoretical
08:45:31 <_Matt_J_W_> as well as the more comp science related topics
08:48:00 <_Matt_J_W_> #ai? 
08:48:16 <_Matt_J_W_> `artificial intelligence'?
08:49:48 <zachk> #haskell-in-depth perhaps 
08:49:48 <dankna> try #math?
08:50:10 <zachk> i wouldnt try #math for anything remotely comp sci related unless you are willing to describe in set theory notation 
08:50:14 <dankna> haha
08:50:16 <dankna> I see
08:50:21 <merijn> _Matt_J_W_: We discuss quite a bit of theoretical comp science
08:50:24 <dankna> I have no experience with the channel, beyond knowing of its existence
08:51:30 <_Matt_J_W_> already been to #math
08:51:35 <merijn> Mostly it seems to be type and category theory and maybe some algorithms/data structure stuff. the Stackoverflow people recently launched a CS theory site too
08:51:45 <merijn> #math is hopelessly useless for theoretical CS
08:51:47 <_Matt_J_W_> it's true, they're not really up with the comp science materials
08:52:00 <merijn> _Matt_J_W_: http://cstheory.stackexchange.com/
08:53:32 <_Matt_J_W_> cheers merij
09:00:52 <lars9> is this function existing in ghc lib?: orM::Maybe a -> Maybe a -> Maybe a; orM a b = if a==Nothing then b else a
09:01:28 <conal> :i fromMaybe
09:01:42 <conal> :t fromMaybe
09:01:43 <lambdabot> forall a. a -> Maybe a -> a
09:02:05 <conal> oh, hm.
09:02:28 <lars9> is it the same?
09:02:37 <lars9> Day changed to 04 Nov 2010
09:02:46 <quicksilver> mplus, lars9 
09:02:50 <lars9> is thie msg sent by irc server?
09:02:53 <conal> lars9: does your orM really have that type?
09:03:00 <quicksilver> > Nothing `mplus` Just 9
09:03:01 <lambdabot>   Just 9
09:03:09 <quicksilver> > Just 5 `mplus` Just 9
09:03:10 <lambdabot>   Just 5
09:03:16 <lars9> quicksilver: cool
09:03:24 <quicksilver> that message was put there by your client
09:03:27 <quicksilver> irssi, quite likely.
09:03:28 <lars9> how does irc server know my time?
09:03:37 <lars9> i see...
09:04:37 <geheimdienst> @time lars9
09:04:38 <lambdabot> Local time for lars9 is Thu Nov  4 00:02:27 2010
09:05:07 * geheimdienst giggles to himself. geheimdienst did that just to stir up some more confusion
09:05:29 <quicksilver> the irc server can know your time, as it happens, because your client will tell it.. but that message was not put there by the server.
09:06:16 <lars9> geheimdienst: hi how to do giggles?
09:07:46 <Lemmih> lars9: Aim at something between a chuckle and a laugh.
09:08:02 <Twey> And try to make yourself sound like a little girl
09:08:34 <lars9> Lemmih: hmm...
09:08:43 <Twey> lars9: BTW, your function didn't have the right type: for orM a b = if a == Nothing then b else a requires Eq a (because of the ==)
09:08:56 <Twey> lars9: If you don't want to incur that constraint in your functions, you should use isNothing
09:09:40 <lars9> Twey: i see, isn't (Maybe a) instance of Eq?
09:09:49 <lars9> @instances Eq
09:09:50 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
09:09:50 <Twey> lars9: Not unless a is
09:10:05 <Twey> Otherwise Just 3 == Just 5
09:10:12 <Twey> Which is silly
09:10:33 <lars9> :i isNothing
09:10:55 <Twey> :i is dead
09:11:00 <Twey> :t isNothing
09:11:01 <lambdabot> forall a. Maybe a -> Bool
09:11:05 <Twey> :t (== Nothing)
09:11:06 <lars9> cool.
09:11:06 <lambdabot> forall a. (Eq a) => Maybe a -> Bool
09:11:20 <lars9> Twey: yeah...
09:12:57 <kstt> hello
09:13:22 <kstt> I'd need a bit of help for my first MVar steps
09:13:27 <lars9> when writing a strip function for string, it's very inefficient to recursively check last s == ' ', how to be more efficient?
09:14:22 <quicksilver> > reverse . dropWhile (==' ') . reverse $ "trailing spaces        "
09:14:23 <lambdabot>   "trailing spaces"
09:14:35 <Lemmih> lars9: reverse+dropWhile+reverse is an option. It can also be done in a single pass, though.
09:14:57 * pumpkin pulls out his single-pass version
09:15:00 <kstt> I just pasted some MVar code on hpaste : http://hpaste.org/41100/db_mvar_cache
09:15:03 * pumpkin puts it back
09:15:22 <lars9> kind of miss c's s[i] here.
09:15:34 <kstt> Basically, I want a simple key-value cache shared by all the threads
09:15:35 * geheimdienst really doesn't know why the Prelude doesn't have a strip function
09:16:03 <Botje> there;s a stripprefix in data.list
09:16:19 <Twey> It's the suffix we want
09:16:23 <quicksilver> kstt: don't put constraints on newtypes (or datas) it doesn't do what you'd want. However what is your problem in fact?
09:16:37 <EvanR-work> lars9: why are you writing a strip function for strings
09:16:55 <EvanR-work> stripping white space from the right is going to be inefficient on strings
09:17:03 <EvanR-work> but is implemented in missingH
09:17:29 <EvanR-work> it will be more efficient on ByteString (or Text im guessing)
09:17:55 <lars9> EvanR-work: i'll just use the reverse*2 method
09:18:07 <EvanR-work> that would probably be simplest
09:18:16 <EvanR-work> if you wanted to write your own
09:18:23 <kstt> quicksilver : I think the problem is that I would like to get a reference to the mvar bound to the toplevel.
09:18:28 <quicksilver> kstt: you can't.
09:18:32 <lars9> EvanR-work: yeah...
09:18:37 <quicksilver> you can do something horrible with unsafePerformIO
09:18:38 <kstt> quicksilver: ok
09:18:45 <kstt> no no thx
09:18:51 <quicksilver> but you need to understand GHC's optimiser and where you put the NOINLINE.
09:18:55 <kstt> I'll manage differently
09:19:14 <kstt> so I must get the MVar ref from the IO monad, true ?
09:19:18 <quicksilver> right.
09:19:32 <quicksilver> so you need some kind of top level harness which sets up the MVar ref
09:19:41 <EvanR-work> kstt: you should pass the abstract reference to the store (the mvar really) around
09:19:43 <quicksilver> and then arranges for it to be inscope for the rest of the program
09:19:48 <quicksilver> either by closure-capture
09:19:51 <quicksilver> or as a parameter
09:20:03 <kstt> that sucks a bit as I will probably have to thread it through many calls before it eventually gets to its goal
09:20:08 <EvanR-work> or you could assign it to a global variable with unsafePerformIO ;)
09:20:21 <EvanR-work> but they are writing php code
09:20:23 <EvanR-work> then*
09:20:30 <EvanR-work> or c++
09:20:39 <Twey> There's also State
09:20:52 <Twey> But it feels like even more overhead than just passing, to me >.>
09:20:57 <EvanR-work> kstt: if everything is in a ReaderT S IO, you could access S anywhere
09:21:24 <opqdonut> should show for Int be fast?
09:21:26 <kstt> EvanR-work: yes, but as twey said that's even more intrusive 
09:21:33 <EvanR-work> why?
09:21:40 <EvanR-work> he said it had overhead
09:21:48 <EvanR-work> i think its less intrusive on the code
09:21:50 <kstt> because nothing is in ReaderT at the moment
09:22:25 <EvanR-work> when you want general global state its usually done with a ReaderT over IO or StateT but the latter i have been told to avoid
09:23:00 <EvanR-work> basically you are making explicit that your code uses an invisible context
09:23:10 <EvanR-work> that is implicit in most languages
09:23:16 <EvanR-work> which is fishy business
09:27:05 <kstt> basically, I'm doing a authenticating http proxy based on Snap Framework (good piece of code !). Threads must allow or deny access based on result of queries to a third party network service. I want to cache the results accross requests. 
09:27:42 <kstt> I'm doing so with an MVar containing an association Map
09:27:58 <kstt> basically, this is : [(query, result)]
09:28:08 <kstt> with a expiration timestamp
09:28:28 <EvanR-work> i have the same thing to store temporary state for multipart form submission
09:28:36 <EvanR-work> keyed by uid submitted with the form
09:29:15 <EvanR-work> Map Uid Dynamic
09:29:21 <kstt> Snap is built around the (big) Snap monad. I don't feel like proxying every snap monadic functions through ReaderT.
09:29:38 <EvanR-work> does snap give you a way to store state
09:29:55 <EvanR-work> the mvar in this case
09:29:55 <kstt> I was looking for that but I don't think so.
09:30:24 <Twey> EvanR-work: It includes IO in the monad stack, so yeah :þ
09:30:38 <EvanR-work> uh huh
09:30:41 <Twey> kstt: ReaderT is already part of Snap
09:30:50 <Twey> I believe you can give it custom state
09:30:57 <Twey> But I might be wrong
09:31:13 <Twey> If not, it's all in IO anyway, so… :þ
09:31:17 <EvanR-work> the way direct-fastcgi works is you can make your own monad
09:31:26 <EvanR-work> and have it implement MonadFastCGI
09:31:36 <EvanR-work> so you can do whatever you want, and also use all the cgi methods
09:32:01 <EvanR-work> for example to ReaderT your own state
09:32:23 <EvanR-work> but it would make sense to provide a single 'hook' mvar in the default state for user data
09:32:26 <EvanR-work> :(
09:32:50 <EvanR-work> getUserdata putUserdata
09:33:49 <kstt> mmmh
09:34:27 <quicksilver> state is normally considered an important property of web frameworks
09:34:30 <quicksilver> I've never looked at snap
09:34:38 <kstt> I'm a bit stuck. Threading the MVar ref fetched from the very top level is definitely not an option.
09:35:06 <EvanR-work> i didnt have a problem with that, guess i dont do IO stuff very deep into the framework
09:36:18 <EvanR-work> deeply nested side effects sounds bad ;)
09:37:01 <gio123> I have to prove A \issebset B \/ A=b \/ B\isssubset A where A and B are finite sets
09:37:02 <kstt> I'd be happy to suit my need without shared cache :) Proposals very welcome
09:37:17 <EvanR-work> shared cache sounds sensible
09:37:36 <EvanR-work> just pass the reference to the cache to the things that need it
09:38:39 <merijn> Hmm, anyone have any heuristics for determining whether reading a paper actually made you smarter or the resulting mental breakdown of said paper just makes you think you got smarter? :p
09:38:54 <kstt> well, that will be very unaesthetic because repetitive, but I guess I'll have to take that way.
09:39:31 <EvanR-work> invisible state is unaesthetic
09:39:48 <EvanR-work> (its not invisible if you could put it into the snap monad)
09:39:55 <EvanR-work> go ahead and hack snap ;)
09:40:04 <zygoloid> merijn: if you feel more curious about the subject matter afterwards you got smarter :)
09:40:45 <merijn> zygoloid: What if you have a feeling more akin to having stared into a Lovecraftian abyss?
09:42:17 <zygoloid> merijn: well, do you want to stare into it /again/? [if not, you still got smarter, but a different kind of smarter ;)]
09:43:17 <Saizan> merijn: which paper is this?
09:43:37 <merijn> Saizan: The View from the Left
09:44:04 <merijn> by McBride/McKinna
09:45:03 <pumpkin> hah
09:45:19 <pumpkin> any hardcore right-wingers in the haskell/type theory community?
09:45:27 <pumpkin> "the view from the right"?
09:46:46 <Saizan> not sure, but i've seen hinze showing to oleg that "finally tagless interpreters" are "The Right Way" :)
09:46:51 <bos> pumpkin: psnively
09:47:15 <EvanR-work> http://www.myspace.com/index.cfm?fuseaction=vids.individual&videoid=7798911
09:47:36 <merijn> I've come to the conclusion that academic papers are more in need of sugaring then most programming languages :>
09:48:15 <tab> -
09:48:55 <Saizan> merijn: not having to write a parser makes adding new syntax too easy :)
09:50:45 <sm> has anyone here successfully printed non-ascii characters in a windows command window ?
09:50:47 <merijn> I'd call some of these figures dense in the same way I'd call granite a sponge. I've successfully scared small children with the formula's. (This message may have some slight exaggerations)
09:50:52 * hackagebot todos 0.4 - Easy-to-use TODOs manager.  http://hackage.haskell.org/package/todos-0.4 (IlyaPortnov)
09:51:41 <sm> http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/19163 makes it sound impossible. I'm seeing a different problem (junk characters)
09:51:52 <merijn> Although I imagine it can't be *too difficult* to scare small kids with math formula's and these are certainly above where I'd expect the scariness threshold to be :p
09:51:57 * zygoloid recursively applies "this message may have some slight exaggerations" and arrives at "this message is entirely unreliable"
09:53:04 <merijn> I thought unreliability was implicit in IRC messages :p
09:53:06 <Saizan> you get used to logic programs after a while (inference rules are more or less isomorphic to prolog code)
09:55:47 <Saizan> ..though Figure 9 is pretty scary
09:56:05 <merijn> Saizan: Thank god
09:56:24 <merijn> Saizan: I was wondering whether it was just me who got stuck there for half a day and counting :p
09:56:37 <sm> nobody interested in building programs on windows eh
09:56:56 <EvanR-work> sm: use rxvt
09:57:00 <EvanR-work> or putty
09:57:36 <EvanR-work> command prompt was not meant for public consumption, and based on eat-your-own-dog-food microsoft policy, wasnt meant for their consumption either
09:57:47 <Saizan> merijn: what is saving me that effort is that i've already spent that time in front of the Agda code for the levitation paper, which does pretty much the same thing :D
09:58:10 <sm> thanks EvanR. I don't have to use windows myself, just wondering if it's possible to provide a unicode-aware command-line program for regular windows folk
09:58:39 <EvanR-work> i would be astounded
09:58:58 <EvanR-work> i mean, it probably works in rxvt
09:59:03 <EvanR-work> just not command prompt
09:59:34 <sm> well, that is an idea, for the power users; I'll suggest it
09:59:54 <EvanR-work> non power users would go anywhere near a console app?
10:00:10 <sm> yes, as you say
10:00:17 <merijn> sm: Oh! Try if you can get it to work in PowerShell?
10:00:28 <EvanR-work> PowerShell(tm)
10:00:31 <merijn> PowerShell is decidedly less sucky then the normal prompt
10:00:37 <merijn> Saizan: I especially like the short, off-the-cuff introduction "oh, btw, in this figure we introduce some new stuff we're sure you can figure out..." :p
10:00:42 <sm> thanks, will suggest that too
10:00:58 <gio123> Cale: hi
10:01:30 <geheimdienst> merijn: it's called the "more leet than thou" strategy of introducing terms
10:02:35 <Saizan> merijn: yeah, but they have the decency of providing an example at least :D
10:06:19 <conal> edwardk: ping
10:12:24 <lars9> why foldl is inefficient?
10:13:46 <quicksilver> it's not.
10:14:08 <quicksilver> not inherently, but it's an inefficient way to solve some problems.
10:14:46 <monochrom> inefficient methods are due to PEBKAC, not due to foldl
10:15:44 <lars9> see...
10:15:47 <monochrom> note that foldl' is an inefficient way to compute the number 40000
10:16:18 <zygoloid> > foldl' const 40000 []
10:16:19 <lambdabot>   40000
10:17:17 <monochrom> of course I had in mind foldl' (+) 0 (replicate 40000 1). but even foldl' const 40000 [] is inefficient: slightly inefficient in execution, royally inefficient in human reading.
10:17:29 <dolio> > foldl' undefined 40000 []
10:17:30 <lambdabot>   40000
10:17:35 <zygoloid> :D
10:17:44 <monochrom> note that foldl' const 40000 [] is 400% more to read than 40000
10:17:55 <zygoloid> > foldl' const 40000 (replicate 100000 undefined)
10:17:55 <lambdabot>   40000
10:18:44 <dolio> Oh, by the way, some folks on the compsci reddit were talking about how Dijkstra's formal methods for writing computer programs are unnecessary and overly time consuming.
10:18:49 <dolio> You should go crack some heads.
10:19:09 <monochrom> I don't use reddit at all.
10:19:18 <dolio> I know.
10:19:33 <byorgey> unnecessary and overly time consuming... as opposed to, say, reddit?
10:19:35 <monochrom> They are really welcome to say computers are unnecessary too, or humans are unnecessary too.
10:20:09 <monochrom> Also reddit is hardly the first place ever where people say such urban legends.
10:20:28 <pumpkin> most of reddit is pretty dumb
10:20:34 <pumpkin> and I am proudly a member of that
10:20:38 <monochrom> People oppose all kinds of formal methods long before even HTML existed.
10:21:01 <dolio> That's also true, although it's disappointing that the section populated by people allegedly interested in computer science would be repeating it.
10:21:37 <dolio> But then, there were a bunch of people in the math reddit talking about how nobody really needs to know any math the other day.
10:21:51 <dolio> So maybe I shouldn't be surprised.
10:22:12 <monochrom> Nobody in the US need to know any math. Let Chinese mathematicians do it.
10:22:32 <aristid> maybe there are real advantages to not jumping into the rabbit hole
10:22:48 * quicksilver carefully avoids jumping in the reddit hole.
10:22:52 <christastrophe> Does the fact that a ByteString can split strings without a copy, mean that if you append the split strings it should be an O(1) operation rather than an O(n)?
10:23:02 <dolio> No.
10:23:19 <dolio> I seriously doubt it's that smart.
10:23:33 <quicksilver> strict bytestring append is always a copy.
10:23:38 <aristid> appending lazy bytestrings is O(n) over the chunks
10:23:38 <quicksilver> lazy bytestring append is O(1).
10:23:45 <quicksilver> actually O(chunks) yes
10:23:45 <christastrophe> hmm, that's too bad
10:23:57 <quicksilver> but we assume O(chunks) = O(1)
10:24:06 <dolio> Really?
10:24:10 <quicksilver> ;)
10:24:13 <aristid> quicksilver: the chunks can be pretty small for some stupid reasons
10:24:21 <quicksilver> I dont care how small they are
10:24:24 <aristid> i.e. there can be many chunks
10:24:25 <quicksilver> I care how many there are.
10:24:31 <aristid> ...
10:24:40 <quicksilver> I claim that, for a wide variety of interesting 'n' (i.e. problem scale variables)
10:24:47 <quicksilver> the number of chunks does not scale up with 'n'.
10:24:55 <quicksilver> it might be more than you hope, but it doesn't scale up.
10:24:59 <lars9> why this simple code is wrong: http://hpaste.org/paste/41105/foldl2
10:25:08 <quicksilver> you can certainly construct algorithms for which I'm wrong, of course.
10:25:20 <dolio> Is f(n) = n/50000 O(1) now?
10:25:30 <quicksilver> nope.
10:25:37 <quicksilver> I'm suggesting it doesn't scale *at all*
10:25:42 <quicksilver> not that it scales with n/50000
10:25:49 <quicksilver> e.g., you might have a problem where the number of chunks is 17
10:25:55 <byorgey> lars9: the third case needs a recursive call to foldl2
10:25:57 <quicksilver> and it will stay 17 even when n goes to 10,000,000
10:26:11 <lars9> byorgey: oops... yeah!
10:26:13 <christastrophe> perhaps lazy is the way to go here, since I'm merely scanning the ByteString, never creating new ones
10:26:22 <quicksilver> and you might still be annoyed because it would obviously be nicer with 3 chunks
10:26:29 <quicksilver> but it's still not O(chunks) = O(n)
10:26:51 <byorgey> lars9: try to think carefully about the types involved.  "if this function has type blah, and these arguments have type blah, then the expression has type blah, and I'm passing that to this other function..."
10:27:13 <quicksilver> the reason I avoid reddit : I can't trust myself to resist the lure of http://xkcd.com/386/
10:27:41 <lars9> byorgey: thanks, very useful method
10:27:53 <aristid> quicksilver: fortunately that doesn't happen here :)
10:33:58 <jacobian> I'm trying to create a Functor instance and have encountered the following problem. 
10:34:07 <jacobian> fmap f t = t 
10:34:30 <lars9> how to find the pattern "\\\\\\\/" (a '/' following k consecutive '\'s, where k is odd) in a String?
10:34:31 <Twey> That's not a very useful Functor instance
10:34:56 <jacobian> Twey, sorry, that's just the default catch all at the bottom, for leaves. 
10:35:09 <Saizan> that won't typecheck
10:35:12 <jacobian> However it gives a type error, saying it can't infer the type
10:35:18 <pumpkin> hm! 
10:35:18 <Twey> lars9: With regexen, "\\(\\\\)+/"
10:35:18 <pumpkin> cabal: dependencies conflict: ghc-6.12.1 requires array ==0.3.0.1 however
10:35:18 <pumpkin> array-0.3.0.1 was excluded because ghc-6.12.1 requires array ==0.3.0.0
10:35:20 <pumpkin> :P
10:35:34 <jacobian> Is there a way to help the typechecker Saizan? 
10:35:35 <dcoutts__> pumpkin: see Cabal FAQ #1
10:35:47 <pumpkin> dcoutts__: it isn't mine, I just noticed it on haskell-cafe
10:35:53 <Saizan> jacobian: if "t :: SomeFoo a" it can't also be "t :: SomeFoo b"
10:35:55 <lars9> Twey: yeah, but it's kind of using canoon to kill a fly
10:35:59 <dcoutts__> pumpkin: point them at the FAQ
10:36:19 <pumpkin> dcoutts__: excellent, thanks :)
10:36:28 <Saizan> jacobian: even if the remaining cases don't have fields of type 'a', you still have to pattern match and reconstruct them
10:36:35 <mplus> mzero: you are nothing to me
10:36:51 <jacobian> Ok, thanks
10:37:11 <quicksilver> jacobian: you have to write fmap f Leaf = Leaf
10:37:18 <Twey> lars9: You can recurse if you want… nothing particularly special about it.  Just start again if the match breaks.
10:37:21 <quicksilver> jacobian: because, although 'Leaf' looks like 'Leaf'
10:37:23 <mzero> mplus: you can combine me all you like - but you'll still get me in the end!
10:37:26 <jacobian> Yeah, Saizan's explanation made sense.
10:37:31 <quicksilver> jacobian: they are not the same value, if they're at different types.
10:37:39 <lars9> Twey: ok i'll try, thanks:)
10:37:46 <jacobian> I just don't want to write the boiler plate! :)
10:37:57 <quicksilver> that's why you're writing a Functor instance
10:38:01 <quicksilver> so you only have to write this once.
10:38:01 <EvanR-work> lol mzero 
10:38:21 <Saizan> if you were feeling extremely evil you could use unsafeCoerce, but god would kill a kitten
10:38:28 <mplus> mzero: nuh uh! nothing in Haskell guarantees the laws
10:38:39 * mplus writes a new instance just to prove mzero wrong
10:39:07 <mzero> wonders if mplus knows which package he's from... ;-)
10:39:12 <quicksilver> Saizan: and actually this is an obscure reason to prefer 'deriving Functor'
10:39:28 <quicksilver> Saizan: it actually writes the unsafeCoerce version, IIRC.
10:39:36 <osaunders> lars9: Something like this: «let (x, _) = span (/= '/') "\\\\\\\\/" in all (== '\\') x && odd (length x)»?
10:39:40 <mplus> mzero: I don't, actually!
10:39:45 <mplus> I was adopted
10:39:48 <int80_h> From some code I've written, I get a result "Just 4". Now, how can I isolate the 4 from the Just?
10:39:59 <outsid3r> how recursion can be optimized, besides tail recursion?
10:40:05 <EvanR-work> int80_h: pattern matching
10:40:16 <int80_h> ah!
10:40:16 <EvanR-work> forces you to handle Nothing
10:40:27 <EvanR-work> not really but at least it makes you think
10:40:28 <lars9> osaunders: i'll trying scanl
10:40:31 <mzero> wonders if that is what we should call the construct of a module exporting a whole other module: adoption!
10:40:34 <mplus> or convenience functions like fromMaybe or maybe
10:40:35 <zachk> import Data.Maybe , and use fromJust 
10:40:39 <mplus> NO
10:40:41 <mplus> NOT FROMJUST
10:40:42 <quicksilver> BZZT.
10:40:42 <int80_h> EvanR-work, thanks :)
10:40:43 <EvanR-work> no not fromJust!
10:40:45 <quicksilver> do no use fromJust.
10:41:01 <int80_h> okay will not use fromJust
10:41:04 <quicksilver> use: maybe, fromMaybe, fmap, or >>=
10:41:07 <EvanR-work> unless you have a proof less than 2 lines away that shows it cant be nothing
10:41:18 <quicksilver> which are basically the four natural ways of handling Nothing
10:41:20 <mplus> quicksilver: or >=> or =<< or <=<!
10:41:26 <geheimdienst> i guess fromJust ought to be renamed to something like unsafeFromJust
10:41:31 <EvanR-work> haha
10:41:34 <mzero> observes that the just never use fromJust
10:41:38 <EvanR-work> everything partial is unsafe
10:41:43 <EvanR-work> pattern matching is unsafe
10:41:49 <EvanR-work> haskell is unsafe
10:41:51 <int80_h> huh?
10:41:56 <int80_h> your mom is
10:42:01 <int80_h> oh snap!
10:42:05 <geheimdienst> ceiling cat is watching you fromJust
10:42:40 <Philippa> eh, it all depends on what you mean by "safe". It shouldn't segfault or reformat your storage, for example
10:42:56 <mplus> launching the missiles is fine though
10:42:57 <EvanR-work> the problem with fromJust is its a Bool, which usually adds Bool handling code
10:42:58 * geheimdienst mumbles something about missles
10:43:15 <EvanR-work> oh
10:43:16 <EvanR-work> thats isJust
10:43:22 <EvanR-work> dont use isJust ;)
10:43:51 <shachaf> EvanR-work: isJust is fine.
10:44:09 <quicksilver> isJust isn't dangerous
10:44:09 <EvanR-work> pattern matching is usually more preferrable
10:44:12 <quicksilver> but it is code smell
10:44:20 <zachk> use pattern matching in a case expression 
10:44:40 <quicksilver> it's almost always better to do pattern matching or use one fo the combinators which has been mentioned
10:44:52 <quicksilver> which between them encapsulate various pattern matching patterns.
10:44:53 <EvanR-work> if you need to value, isJust followed by fromJust is better a pattern or maybe or fromJust
10:45:19 <EvanR-work> i could see a marginal use in monadic when isJust (do something) that doesnt need to know what it is
10:45:23 <shachaf> EvanR-work: If you follow it with fromJust, sure.
10:45:36 <quicksilver> "length . filter (isNothing)" is an example when you might want to use the 'is' version.
10:45:58 <EvanR-work> length . catMaybes
10:46:08 <EvanR-work> hmm thats the opposite
10:46:12 <quicksilver> indeed.
10:46:15 <quicksilver> that's why I chose what I chose,
10:46:39 <EvanR-work> would be been cooler to call it maybeCats
10:46:44 <aristid> @let count = let (.:) = (.).(.) in length.filter
10:46:45 <lambdabot>  <local>:11:37:
10:46:45 <lambdabot>      Couldn't match expected type `[a]'
10:46:45 <lambdabot>             against i...
10:46:51 <aristid> @let count = let (.:) = (.).(.) in length.:filter
10:46:52 <lambdabot>  Defined.
10:47:08 <aristid> :t count isNothing [Just 1, Nothing, Just 2, Just 3, Nothing]
10:47:09 <lambdabot> Int
10:47:12 <aristid> > count isNothing [Just 1, Nothing, Just 2, Just 3, Nothing]
10:47:13 <lambdabot>   2
11:03:54 <solistic> Is there some function `foo n l = drop n l ++ take n l' in the standard lib?
11:04:25 <c_wraith> @pl foo n l = drop n l ++ take n l
11:04:25 <lambdabot> foo = ap (ap . ((++) .) . drop) take
11:04:30 <c_wraith> eww
11:04:35 <c_wraith> I thought it would be prettier than that
11:05:18 <solistic> c_wraith: I guss this means no?
11:05:29 <Saizan> ?type liftM2 (liftM2 (++)) take drop
11:05:30 <lambdabot> forall a. Int -> [a] -> [a]
11:05:55 <c_wraith> See, that's the prettier I was expecting.
11:06:13 <c_wraith> And no, there's no function like that just lying around.
11:06:36 <c_wraith> rotating lists is not a common function
11:06:48 <c_wraith> because it's inherently inefficient
11:07:29 <monochrom> in the Promised Land, there is a module called Prelude.Twitter that contains all functions implementable in 140 characters or less.
11:07:40 <opqdonut> :D
11:07:46 <conal> SEC style: (liftA2.liftA2) (++) take drop
11:07:53 <opqdonut> monochrom: with what names?
11:09:18 <solistic> c_wraith: so lets say I have a current position 'n' and I want to find from the first element that macht a given predicate, starting from that position and wrapping around at the end of the list, how would I implement that without rotating?
11:09:21 <monochrom> I don't know :)
11:10:09 <EvanR-work> c_wraith: but wait, if its cyclic rotating is easy!
11:11:12 <c_wraith> solistic, it's probably fine for your question.  But be aware, it's not going to be especially efficient.  I doubt that matters for most cases you'd use String for anyway
11:12:20 <solistic> c_wraith: ok, I only expect lists that have thounds or so of elements
11:12:45 <c_wraith> Oh, generic lists, not strings.
11:13:01 <c_wraith> in any case, yeah.  it's probably fine.
11:13:07 <solistic> well enumerate lists of strings
11:13:43 <solistic> because I need the next postion in the list, that matches the predicate..
11:15:39 <EvanR-work> is total amount of code a sense-making thing to try and optimize in a project
11:20:21 <Cale> Interesting, for any n > 12, the nth Fibonacci number has at least one prime factor not belonging to any earlier Fibonacci number.
11:21:04 <c_wraith> that's an interesting result
11:21:17 <franksh_> did lambdabot's @pl ever get rewritten? i seem to remember it was much more clever before (like years ago).
11:21:20 <c_wraith> Doesn't sound practical an any way, but it's cute. :)
11:21:22 <franksh_> @pl f g (a,b) = (g a, g b)
11:21:22 <lambdabot> f = (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
11:21:49 <EvanR-work> c_wraith: another great way to crack RSA goes out the window
11:22:25 <franksh_> f = join (***)....
11:23:39 <cts> c_wraith: It proves again that there are infinitely many prime numbers.
11:28:01 <Cale> franksh_: Not that I'm aware of
11:28:54 <franksh_> i do think it knew how to at least apply arrow logic before, but now is doesn't seem to
11:30:44 <Saizan> ?pl \f g (x,y) -> (f x , g y)
11:30:44 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
11:33:03 <EvanR-work> i use flip flip snd . (ap .) . flip flip fst . ((.) .) . flip .  (((.) . (,)) .)
11:33:06 <EvanR-work> all the time
11:38:14 <burp> the haskell obfuscator, just run @pl over your sourcecode
11:38:24 <burp> @unpl  flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
11:38:24 <lambdabot> (\ aa f -> (\ p w -> ((,)) (aa (fst p)) (f w)) >>= \ af -> snd >>= \ ae -> return (af ae))
11:39:32 <EvanR-work> lol
11:40:36 <EvanR-work> which >>= is it using there?
11:40:44 <Eduard_Munteanu> Hm, is there any theorem guaranteeing pl's success, like "given these operations, pl can always turn some kind of expressions into pointfree"?
11:41:03 <Eduard_Munteanu> Or is it guessing and trying?
11:41:05 <edwardk> conal: pong
11:41:21 <conal> edwardk: nm. emailed instead.
11:41:22 <unkanon2> what is @pl for?
11:41:31 <edwardk> conal: ah the earlier bit about unamb?
11:41:37 <conal> edwardk: yep
11:41:38 <Eduard_Munteanu> unkanon2: turns expressions into pointfree style
11:41:40 <EvanR-work> unkanon2: for frightening small children and imperative programmers
11:42:02 <unkanon2> wow you guys said exactly the same thing at the same time :P
11:42:19 <Eduard_Munteanu> unkanon2: foo x = f (g x) -> foo = f . g
11:42:23 <Eduard_Munteanu> for instance
11:42:55 <unkanon2> oh, gotcha
11:43:17 <unkanon2> @pl foo x = f (g x)
11:43:17 <lambdabot> foo = f . g
11:43:35 <Eduard_Munteanu> "pointfree" as in the functions aren't applied pointwise.
11:43:36 <Saizan> Eduard_Munteanu: i'm sure there's a theorem about converting the pure lambda calculus to SKI combinators, which is probably extensible to handle simple pattern matches
11:43:55 <unkanon2> @pl foo x = x >>= id
11:43:55 <lambdabot> foo = join
11:43:59 <unkanon2> lol it's clever
11:44:29 <Eduard_Munteanu> Saizan: I see.
11:44:37 <Saizan> Eduard_Munteanu: @pl's code has a lot of more ad-hoc rules, so it's more complicated..
11:44:41 <EvanR-work> @pl f x y z = x (y, z x)
11:44:41 <lambdabot> f = liftM2 (.) (.) (flip ((.) . (,)) . flip id)
11:44:50 <Eduard_Munteanu> Oh so it's heuristics then.
11:45:22 <Eduard_Munteanu> :t (.) (.)
11:45:22 <unkanon2> can it go the other way?
11:45:23 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => f1 (a -> b) -> f1 (f a -> f b)
11:45:33 <Saizan>  @unpl
11:45:37 <unkanon2> from point free to point...erm... -y?
11:45:45 <Eduard_Munteanu> I think it's pointful.
11:45:55 <unkanon2> @unpl foo = join
11:45:55 <lambdabot> foo b = b >>= \ a -> a
11:46:02 <EvanR-work> @unpl liftM2 (.) (.) (flip ((.) . (,)) . flip id)
11:46:02 <lambdabot> ((\ i j k -> i (j k)) >>= \ b -> (\ x n q -> ((,)) n (q x)) >>= \ a -> return (\ h -> b (a h)))
11:46:12 <EvanR-work> @pl ((\ i j k -> i (j k)) >>= \ b -> (\ x n q -> ((,)) n (q x))  >>= \ a -> return (\ h -> b (a h)))
11:46:13 <lambdabot> (`fmap` (flip ((.) . (,)) . flip id)) . (.) =<< (.)
11:46:24 <EvanR-work> @unpl (`fmap` (flip ((.) . (,)) . flip id)) . (.) =<< (.)
11:46:25 <lambdabot> (\ t -> fmap (((\ o p q -> o (p q)) >>= \ l m n -> l (m n)) t) (\ w c f -> ((,)) c (f w)))
11:46:26 <unkanon2> hah, it uses id all the time, yet it doesnt know that \a -> a is id
11:46:42 <EvanR-work> it needs to learn how to simplify
11:46:46 <Eduard_Munteanu> I suspect @unpl is used less.
11:46:53 <unkanon2> ic
11:47:18 <EvanR-work> the code above looks like brainfuck or unlambda or something ;)
11:47:19 <Eduard_Munteanu> Usually you shouldn't copy-paste @pl's output then wonder what you initially meant :)
11:48:23 <EvanR-work> @unpl (.) (.)
11:48:24 <lambdabot> (\ b c e f -> b c (e f))
11:48:50 <unkanon2> @pl foo b = b >>= \a -> a
11:48:50 <lambdabot> foo = join
11:49:21 <unkanon2> @unpl (_|_)
11:49:21 <lambdabot>  Parse error at "|_)" (column 3)
11:49:44 <EvanR-work> unkanon2: its getting hot in here
11:49:55 <unkanon2> i know, right. lol
11:51:28 <EvanR-work> > map length (tails [1,2,3])
11:51:29 <lambdabot>   [3,2,1,0]
11:51:39 <EvanR-work> > ((.) (.)) map length tails [1,2,3]
11:51:40 <lambdabot>   [3,2,1,0]
11:51:44 <EvanR-work> handy ;)
11:53:35 <Eduard_Munteanu> > map length $ tails [1,2,3]
11:53:36 <lambdabot>   [3,2,1,0]
11:54:02 <Eduard_Munteanu> I know, I got the joke. :)
11:54:31 <EvanR-work> im not sure you did
11:54:40 <EvanR-work> IT LOOKS LIKE BOOBS Eduard_Munteanu 
11:55:57 <Eduard_Munteanu> Well yes, I know, I understood the subtler variant :P
11:56:26 <Eduard_Munteanu> Um, actually I could use that once or twice in my code...
11:58:26 <roconnor> what is a good greek letter to use for a functor?
11:58:50 <christastrophe> how do you declare an FFI C function which has a signature of 'int x(int)', but treats the argument as a char and the result as a bool?
11:59:05 <Saizan> greek letters are for natural transformations usually
11:59:13 <christastrophe> should the foreign types still be CInt?
11:59:24 <roconnor> Saizan: but polymorphic type variables are greek letters
11:59:52 <EvanR-work> testing
12:00:11 <roconnor> Saizan: so specifically I want a letter for a polymoprhic type variable for a functor
12:00:40 * Eduard_Munteanu recommends Xi whenever someone asks for a greek letter
12:00:59 <Eduard_Munteanu> It's a pain the first time you see it.
12:01:23 <EvanR-work> Ξ
12:01:27 <Eduard_Munteanu> (though that makes more sense in calculus)
12:01:30 <Eduard_Munteanu> EvanR-work: no, lowercase
12:01:36 <EvanR-work> i like Ξ
12:01:40 <Eduard_Munteanu> :)
12:02:11 <Eduard_Munteanu> ξ
12:02:14 <EvanR-work> in my engineering courses, no one knew what ξ was or could pronounce it
12:02:21 <EvanR-work> it was always 'squiggle'
12:02:22 <Lemmih> christastrophe: Yes.
12:02:30 <Eduard_Munteanu> Heh.
12:03:13 <Eduard_Munteanu> I'm not yet really sure about 'chi'. Neither the electromagnetics teacher was.
12:03:35 <christastrophe> Lemmih: what about when calling it, if I want to wrap it in a function 'f :: Char -> Bool' 
12:03:43 <EvanR-work> as in cheewees
12:04:20 <Eduard_Munteanu> EvanR-work: hm, that sounds right, although people have told me it's not really as in 'chee'.
12:04:25 <EvanR-work> christastrophe: watch out for Char that dont fit in a int ;)
12:04:34 <Lemmih> christastrophe: You still have to use CInt when you import it. If can of course use any wrapper you want.
12:04:41 <Lemmih> s/If/You/
12:04:56 <Eduard_Munteanu> I heard lots of variants, like 'key' and 'he'.
12:05:05 <Eduard_Munteanu> and 'hi'.
12:05:19 <EvanR-work> well if you dont want me to call it chee dont spell it chi
12:05:35 <Lemmih> christastrophe: f = cintToBool . x . cintToChar
12:05:40 <EvanR-work> Xi spelling was invented by an asshole
12:05:45 <christastrophe> EvanR-work: goodpoint
12:07:06 <christastrophe> Lemmih: I see.
12:08:24 <unkanon2> Eduard_Munteanu: ξ is pronounced "ksee"
12:08:31 <christastrophe> Lemmih: of course cintToChar is not in the standard library :)
12:08:49 <aristid> @hoogle cintToChar
12:08:49 <lambdabot> No results found
12:08:59 <aristid> :t chr
12:08:59 <osaunders> Is it possible to define a subset of Char that only contains letters and numbers?
12:09:00 <lambdabot> Int -> Char
12:09:56 <EvanR-work> osaunders: Data.Char has character classes
12:10:08 <christastrophe> err. I do belive I actually need Char -> CInt
12:10:09 <EvanR-work> which im guessing are inspired by unicode
12:10:42 <christastrophe> these are ByteStrings I'm dealing with, so Char is really 8bits
12:10:55 <EvanR-work> christastrophe: in haskell Int is defined to be good enough to hold a codepoint
12:10:56 <osaunders> EvanR-work: I'm asking not because this is something I need but because I'm interested to know if the type system can do it.
12:10:59 <EvanR-work> so its not Char its Word8
12:11:14 <EvanR-work> so chr (fromIntegral w)
12:11:54 <EvanR-work> osaunders: oh, Char is any character. but defining a new type which is a subset of possible values sounds like dependent typing?
12:12:25 <Eduard_Munteanu> unkanon2: yeah just reading 'xi' in my language is like that.
12:12:31 <christastrophe> what about ByteString.Char8?
12:12:32 <roconnor> I'm just going to use kappa untill I get a better suggestion :P
12:12:33 <Eduard_Munteanu> So it fit well.
12:12:51 <christastrophe> :t c2w
12:12:52 <lambdabot> Not in scope: `c2w'
12:12:56 <EvanR-work> christastrophe: that treats the Word8s as Chars less than 256
12:13:09 <Eduard_Munteanu> EvanR-work: indeed, the transliteration probably wasn't that good.
12:14:23 <EvanR-work> :t chr . fromIntegral :: Word8 -> Char
12:14:24 <lambdabot> Word8 -> Char
12:14:31 <EvanR-work> :t chr . fromIntegral
12:14:32 <lambdabot> forall a. (Integral a) => a -> Char
12:14:42 <unkanon2> Eduard_Munteanu: :)
12:14:51 <EvanR-work> christastrophe: are you still looking for Char -> Word8 im confused
12:17:37 <EvanR-work> > fromIntegral 257 :: Word8
12:17:38 <lambdabot>   1
12:19:13 <christastrophe> here is the copiler error I'm getting: http://hpaste.org/41109/ffierr
12:19:56 <Eduard_Munteanu> BTW, are you aware of any bitstream implementations in Haskell? I'll need to work out a Shannon-Fano algo soon, and I'll need it.
12:21:06 <Eduard_Munteanu> I could do it myself though, but it's nice to know.
12:21:56 <Eduard_Munteanu> Basically I only need to read/write bits from it (say, lists?), and it should handle packing to bytes internally.
12:22:06 <min_> The datatype of rose trees, data Tree a = Node a [Tree a], defines a monad. Is it correct that Tree a is not an instance of MonadPlus (there is no sensible way to define mzero)?
12:23:13 <christastrophe> EvanR-work: obviously the sensible thing to do woule be to use the Data.Char functions, but I thought this would be a relatively painless FFI exercise...
12:24:08 <osaunders> min_: Take this with a grain of salt because I'm not familiar with MonadPlus, but isn't «mzero x = Node x []» conforming? 
12:24:24 <osaunders> s/grain/lump/
12:24:50 <Eduard_Munteanu> :t mzero
12:24:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
12:25:27 <EvanR-work> christastrophe: ord and chr are basically the interface to Char
12:25:27 <Eduard_Munteanu> It works for lists because they can be empty.
12:26:00 <osaunders> Eduard_Munteanu: Ah
12:26:02 <unkanon2> osaunders: wait, did you ever get a reply to that char type question? that was a good question
12:26:05 <christastrophe> EvanR-work: why would only the last function defined give the error and not all of them?
12:26:18 <EvanR-work> i missed that, what?
12:26:35 <min_> If mzero x = Node x [], then mzero = return. So I don't think that works.
12:26:39 <EvanR-work> scrolls up
12:26:44 <Eduard_Munteanu> Yeah, unless you define the rose tree as data Tree a = Empty | Node a [Tree a], Node will require a value of type a.
12:26:49 <osaunders> unkanon2: Not really. I'm assuming it isn't possible in standard Haskell unless someone tells me otherwise.
12:27:19 <osaunders> Repeat: "Is it possible to define a subset of Char that only contains letters and numbers?"
12:27:26 <EvanR-work> christastrophe: i dont know what line 43 is
12:28:00 <EvanR-work> is it possible to do dependent types in haskell
12:28:25 <osaunders> EvanR-work: But?
12:28:32 <EvanR-work> but ?
12:28:41 <EvanR-work> i asked a question
12:28:42 <unkanon2> it wasnt an assertion
12:28:45 <unkanon2> it was a question yeah
12:28:46 <unkanon2> yeah
12:28:49 <unkanon2> :)
12:28:55 <osaunders> Oh
12:28:58 <osaunders> OK :-)
12:29:08 <EvanR-work> osaunders: you could define an abstract data type that can be constructed from a Char and is an error if its not a letter or number
12:29:11 <min_> Couldn't you define an abstract type with functions restricting possible Char values to letters and numbers?
12:29:11 <Eduard_Munteanu> unkanon2, osaunders: maybe if you make an ADT deriving Enum, or a special Enum instance? Although I'm unsure what semantics you want.
12:29:24 <osaunders> I sometimes read "is it" as "it is".
12:29:34 <EvanR-work> this sort of thing also can make a non zero positive number, or similar
12:29:53 <EvanR-work> or a non empty list
12:29:55 <christastrophe> EvanR-work: im not sure the line number helps :) in the file, line 43 is 'isXDigit = cTest c_isxdigit' ... 
12:30:02 <EvanR-work> ok
12:30:17 <christastrophe> EvanR-work: but I'm starting to gather that mucking with Char like this is just going down a deep rabiit hole...
12:30:20 <Eduard_Munteanu> unkanon2: why would you want that though?
12:30:29 <EvanR-work> christastrophe: you want to use ord
12:30:32 <unkanon2> Eduard_Munteanu: we just want to know if it's possible
12:30:41 <Eduard_Munteanu> Ah.
12:30:53 <osaunders> EvanR-work: Yeah, that is probably how I would do it too.
12:30:56 <EvanR-work> christastrophe: having a hard time since i dont have type sigs ;)
12:31:42 <christastrophe> EvanR-work: they types should all hopefully be Char -> Bool :)
12:31:52 <EvanR-work> whats cTest
12:32:02 <christastrophe> its type?
12:32:06 <EvanR-work> yes
12:32:42 <EvanR-work> Char -> Bool?
12:32:44 <christastrophe> not sure actually :) I was hoping for some compiler magic there!
12:33:09 <EvanR-work> oh its (CInt -> Bool) -> Char -> Bool
12:33:18 <christastrophe> EvanR-work: hmm. Char -> (Cint -> CInt) -> Bool
12:33:24 <EvanR-work> hrm
12:33:30 <EvanR-work> the first arg is a function
12:33:43 <christastrophe> err. yes
12:33:47 <EvanR-work> ok
12:33:53 <christastrophe> (CInt -> CInt) -> Char -> Bool
12:34:04 <EvanR-work> so cTest f = toBool . f . fromIntegral . ord
12:35:45 <christastrophe> EvanR-work: I see. Makes perfect sense now.
12:35:54 <christastrophe> danke
12:36:15 <EvanR-work> rather than fromIntegral....
12:36:17 * EvanR-work tries
12:36:30 <EvanR-work> > fromEnum 'e' :: CInt
12:36:31 <lambdabot>   Not in scope: type constructor or class `CInt'
12:36:35 <EvanR-work> > fromEnum 'e' :: Word8
12:36:36 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
12:36:36 <lambdabot>         against inferred type...
12:36:50 <EvanR-work> nevermind, fromEnum gives Int
12:36:58 <_Matt_J_W_> hey guys. why doesn't he following work: `data Bin = String Op String' ?
12:37:04 <EvanR-work> its basically ord
12:37:16 <jmcarthur> _Matt_J_W_: it's missing a constructor
12:37:29 <_Matt_J_W_> Op is?
12:37:31 <jmcarthur> data Bin = MyConstructor String Op String
12:37:44 <Eduard_Munteanu> _Matt_J_W_: then Op String String
12:37:52 <EvanR-work> data Bin = String :-: String
12:38:05 <paper_cc> _Matt_J_W_: if Op is supposed to be a constructor, then it should be specified as a prefix one
12:38:09 <jmcarthur> oh if Op is supposed to be the constructor you could say something like:   data Bin = String `Op` String
12:38:59 <EvanR-work> > (,) "left" "right"
12:39:00 <lambdabot>   ("left","right")
12:39:35 <paper_cc> > (:+) 1 2
12:39:36 <lambdabot>   1.0 :+ 2.0
12:39:47 <monochrom> ChanServ `Op` monochrom :)
12:40:19 <EvanR-work> :t (:+) 1 2
12:40:19 <lambdabot> forall t. (RealFloat t) => Complex t
12:40:31 <paper_cc> @src Complex
12:40:32 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
12:40:36 <EvanR-work> :t (,) 1 2
12:40:37 <lambdabot> forall t t1. (Num t, Num t1) => (t, t1)
12:41:17 <EvanR-work> but if you evaluate (,) 1 2, and then take the type of the result it will be (Integer,Integer)
12:41:36 <Razz_DK> If I have a string and want the length as a Num, how do I go about that?
12:41:46 <EvanR-work> :t genericLength
12:41:46 <lambdabot> forall b i. (Num i) => [b] -> i
12:41:48 <monochrom> genericLength
12:42:03 <monochrom> @type fromIntegral
12:42:04 <lambdabot> forall a b. (Integral a, Num b) => a -> b
12:42:12 <paper_cc> @ty fromIntegral . length
12:42:12 <monochrom> fromIntegral . length
12:42:13 <lambdabot> forall b a. (Num b) => [a] -> b
12:42:13 <_Matt_J_W_> jmcarth... that data definition works. how would I then write out the value?
12:42:45 <EvanR-work> fromIntegral . length wont work for very long lists
12:42:57 <monochrom> "hello" `Op` "hi"
12:42:59 <Eduard_Munteanu> _Matt_J_W_: "foo" `Op` "bar"
12:43:40 * paper_cc tries to think of a list containing more then 2**31 items and fitting in memory at the same time
12:43:54 <Eduard_Munteanu> You can still use it infix I think: Op "foo" "bar"
12:44:12 <EvanR-work> > length [1..]
12:44:16 <lambdabot>   mueval-core: Time limit exceeded
12:44:22 <_Matt_J_W_> yes
12:44:24 <_Matt_J_W_> it works
12:44:30 <monochrom> > genericLength [1..]
12:44:31 <lambdabot>   *Exception: stack overflow
12:44:35 <_Matt_J_W_> I think it was the unspaced `" that was causing the problem
12:44:39 <Eduard_Munteanu> s/infix/prefix/
12:44:41 <EvanR-work> > length (cycle [5])
12:44:46 <lambdabot>   mueval: ExitFailure 1
12:44:53 <monochrom> > genericLength (cycle [5])
12:44:54 <lambdabot>   *Exception: stack overflow
12:45:01 <EvanR-work> three ways to crash lambdabot
12:45:05 <monochrom> doesn't seem an improvement to me
12:45:26 <EvanR-work> stop hiding behind your machines!
12:45:26 <_Matt_J_W_> So, the `Op' becomes the data constructor for String and String
12:45:36 <_Matt_J_W_> String and String become its arguments
12:45:47 <Eduard_Munteanu> _Matt_J_W_: yes, Op :: String -> String -> Bin
12:45:59 <_Matt_J_W_> cheers
12:46:29 <_Matt_J_W_> What if I wanted Op as just a token?
12:47:47 <Eduard_Munteanu> Define 'token'.
12:48:27 <Eduard_Munteanu> They're all constructors, even if Op :: Bin, Op :: String -> Bin or Op :: String -> String -> Bin, mind you.
12:49:06 <_Matt_J_W_> Well, just Op appearing between String and String
12:50:06 <Eduard_Munteanu> _Matt_J_W_: then either Bin is a type synonym, or a data with another constructor. But in both cases 'Op' must be defined elsewhere.
12:50:16 <_Matt_J_W_> sure
12:50:20 <Eduard_Munteanu> or some newtype.
12:50:58 <_Matt_J_W_> hmm, let me try something
12:51:43 <EvanR-work> > genericLength [1..1000]
12:51:44 <lambdabot>   1000
12:51:47 <EvanR-work> > genericLength [1..10000]
12:51:47 <lambdabot>   10000
12:51:52 <EvanR-work> > genericLength [1..100000000]
12:51:53 <lambdabot>   *Exception: stack overflow
12:51:57 <EvanR-work> > genericLength' [1..100000000]
12:51:58 <lambdabot>   Not in scope: `genericLength''
12:52:05 <Eduard_Munteanu> _Matt_J_W_: you might also want to take a look at GADTs
12:52:18 <Eduard_Munteanu> I'm not sure what you're trying to accomplish.
12:52:29 <Eduard_Munteanu> s/I'm/But I'm/
12:53:28 <Eduard_Munteanu> http://www.haskell.org/haskellwiki/GADT has a similar application example
12:54:48 <_Matt_J_W_> Well, okay
12:54:57 <_Matt_J_W_> Op now has a type
12:55:15 <_Matt_J_W_> and Bin = String Pop String is accepted
12:55:51 <_Matt_J_W_> how do I write out the values for this new type?
12:56:23 <Eduard_Munteanu> type Bin = String Pop String   ?
12:57:01 <Eduard_Munteanu> If so, just write as you'd write a String Pop String.
12:57:58 <Eduard_Munteanu> Uhm, I might have misunderstood you.
12:58:34 <EvanR-work> _Matt_J_W_: use the keyword, data, newtype, or type, they make a difference
12:59:20 <_Matt_J_W_> I am using `data'
12:59:58 <Eduard_Munteanu> I'm not sure, it looks malformed :/
13:00:47 <Eduard_Munteanu> Where's the constructor?
13:00:55 <Saizan> with "data Bin = String Pop String" you're defining a "String :: Pop -> String -> Bin" constructor
13:01:21 <EvanR-work> tricky
13:01:39 <Saizan> which i doubt is what he wanted
13:02:17 <monochrom> data Bin = Pop String String
13:02:37 <monochrom> you are free to write like "hey" `Pop` "aloha" afterwards
13:02:38 <Eduard_Munteanu> I think he wants Pop to be a value.
13:03:15 <Eduard_Munteanu> Erm, type. Not a constructor.
13:03:39 <EvanR-work> data Bin = Bin String Pop String
13:03:44 <stepcut> you can do, data Bin = String `Pop` String, as well, which affects the way compiler errors are reported I think
13:03:55 <Eduard_Munteanu> If so a newtype might be more appropriate.
13:04:10 <stepcut> oh, but not if Pop is a type instead of a constructor
13:04:48 <monochrom> data Bin = BinCtor String Pop String
13:05:02 <Eduard_Munteanu> though you still need a constructor.
13:05:09 <monochrom> a typing value: BinCtor "hey" undefined "aloha"
13:05:22 <monochrom> typo
13:05:26 <monochrom> a typical value: BinCtor "hey" undefined "aloha"
13:05:36 <EvanR-work> a tropical value
13:08:42 <fserb> I need help with Data.Data. I'm trying to use the data type name of a return value inside a function. Is this possible?
13:09:08 <Saizan> yes
13:09:18 <fserb> Saizan, how?
13:09:51 <fserb> I basically have something like f :: Data a => a and I want to use the data type of "a" inside f.
13:11:09 <Saizan> {-# LANGUAGE ScopedTypeVariables #-} ... f :: forall a. Data a => a; f = ... where name = show (typeOf (undefined :: a))
13:11:33 <edwardk> fserb you can do as saizan suggests or you can play games with scoping
13:12:06 <Saizan> you could also play games with the MR
13:12:29 <Saizan> f :: Data a => a; f = r where r = ..; name = show (typeOf r)
13:12:35 <edwardk> f = ... where name = show (typeOf f);; if f has arguments you can do so with things like f x y z = r where r = ....; name = show (typeOf r)
13:13:19 <Saizan> assuming you use some other typeclass method in r's body
13:13:26 <Eduard_Munteanu> :t typeOf
13:13:27 <lambdabot> forall a. (Typeable a) => a -> TypeRep
13:14:53 <EvanR-work> Data.Data documentation refers to something called generic programming, whats that? surely not the same thing as java generics
13:15:35 <dolio> Surely.
13:16:01 <fserb> Saizan, cool. It works! :)
13:16:21 <EvanR-work> When the query is meant to compute a value of type r, then the result type withing generic folding is r -> r.
13:16:38 <EvanR-work> s/within/using/ ah
13:16:44 <edwardk> EvanR-work: you might want to look at some of the old SYB papers: http://research.microsoft.com/en-us/um/people/simonpj/papers/hmap/
13:17:03 * hackagebot websockets 0.1.2.3 - Implements the WebSocket protocol.  http://hackage.haskell.org/package/websockets-0.1.2.3 (SinisaBidin)
13:17:09 <EvanR-work> ah, thats what SYB is ;)
13:17:14 * EvanR-work connects two names
13:17:14 <fserb> edwardk, I'm not sure if I can pull it off... I have a function that returns a "ReaderT SomeState IO a" and I want to use typeOf a to build a itself.
13:17:17 <edwardk> EvanR-work: the idea is how to search through some structure for all values of a given type and do things to them. quite at odds with the usual notions of parametricity, but quite practical
13:17:25 <Eduard_Munteanu> Mm? Isn't generics some sort of polymorphism we already have?
13:17:59 <Saizan> the complete name here would be "datatype generic programming"
13:17:59 <edwardk> fserb: you can make little combinators like asArgTypeOf :: a -> f a -> a; asArgTypeOf = const
13:18:24 <Eduard_Munteanu> Saizan: sounds like type families
13:18:31 <edwardk> and then do stuff like f x y z = r where r = ...; name = show (typeOf (undefined `asArgTypeOf` r))
13:18:35 <Saizan> since what java calls generics has already a name: parametric polymorphism
13:18:58 <edwardk> fserb: that avoids the language extension
13:19:09 <dolio> "Generics" is the word for whatever kind of polymorphism is added to the language/libraries after the fact.
13:19:20 <Eduard_Munteanu> Heh, that explains it.
13:19:41 <edwardk> fserb: iirc, i used that trick a LOT in http://hackage.haskell.org/packages/archive/reflection/0.3.1/doc/html/Data-Reflection.html
13:20:04 <edwardk> fserb: so skimming the source there might provide a ton of examples
13:20:07 <EvanR-work> haha
13:20:16 <Eduard_Munteanu> So I guess Data.Data stuff is just a library-based implementation of polymorphism.
13:20:30 <Eduard_Munteanu> in addition to language mechanisms.
13:21:12 <edwardk> Eduard_Munteanu: it lets you do things like go through a company and find all salaries and increase them by 20% without knowing all the paths, just the data types.
13:21:56 <EvanR-work> so there are generic containers at various levels which hold generic data, which may be containers
13:22:06 <EvanR-work> sounds pretty bad ;)
13:22:45 <Eduard_Munteanu> edwardk: oh, so it's actually something that breaks module encapsulation.
13:23:07 <edwardk> gmapT (\(Salary x) -> Salary (x * 1.2)) -- would work over any container than is an instance of Data finding any newtype Salary = Salary Double deriving (Data,Typeable) -- inside of it, and replacing them with salaries a bit larger
13:23:13 <fserb> edwardk, I see the code, but really not sure I understand it. :)
13:23:16 <edwardk> Eduard_Munteanu: exactly, so like i said, quite the opposite =)
13:24:17 <EvanR-work> edwardk: what a bizarre system
13:24:28 <edwardk> EvanR-work: its quite useful actually in certain contexts.
13:24:34 <EvanR-work> here i am trying to bring meaning to my data structures ;)
13:25:01 <edwardk> EvanR-work: you can make little 'semantic' instances of Data where appropriate. for instance
13:25:28 <EvanR-work> it reminds me of active directory
13:25:58 <edwardk> for instance the definition of Data inside of http://hackage.haskell.org/packages/archive/heaps/0.2/doc/html/src/Data-Heap.html#Heap makes a Heap look like it has a constructor 'fromList' that takes a list and returns a heap
13:26:08 <fserb> edwardk, if I get it right, you're doing this to use Data.Tagged on the type, is that so?
13:26:39 <EvanR-work> edwardk: what is meant by reflection?
13:26:40 <edwardk> fserb: trying to understand the purpose of that module is a bit hairy. =) lemme find you a guide to it =)
13:26:44 <solistic> @pl foo = const $ return ()
13:26:44 <lambdabot> foo = const (return ())
13:26:48 * fserb brain hurts.
13:26:54 <edwardk> http://comonad.com/reader/2009/clearer-reflection/
13:27:54 <edwardk> EvanR-work, fserb reflection takes a _term_ and reifies it into a type, which you can then reflect back down. this is useful when you want to define things like a monoid that needs access to some piece of the environment
13:28:08 <djahandarie> edwardk, oh god, I'm actually looking at the code of this now
13:28:12 <edwardk> it lets you define otherwise impossible instances
13:28:12 * djahandarie is truly scared
13:28:31 <edwardk> djahandarie: which, heap or reflection?
13:28:35 <djahandarie> reflection
13:28:38 <edwardk> haha
13:28:39 <EvanR-work> reifies?
13:28:40 <djahandarie> reify
13:29:03 <djahandarie> I don't know how you came up with this idea
13:29:04 <EvanR-work> i get nervous if something is marketted as powerful ;)
13:29:21 <orbital_fox> hello
13:29:41 <edwardk> djahandarie: oleg and cc shan deserve credit. i just ground out a hackage-able implementation, since theirs stopped working sometime around 6.8
13:29:43 <teseract>  /ignore
13:30:08 <orbital_fox> what is the difference between list and sequence (algebraically)
13:30:11 <edwardk> and then made it a little bit more safe by using tagged
13:30:41 <EvanR-work> orbital_fox: Data.Sequence has more efficient insert and removal from the other side
13:30:52 <EvanR-work> than list
13:31:08 <edwardk> djahandarie: the idea is quite simple. you can reify a number into a type.
13:31:11 <mzero> or did you mean more abstractly than the difference between [] and Data.Sequence in particular
13:31:19 <orbital_fox> EvanR-work, i was asking generally, no haskell specific, but mathematically
13:31:33 <edwardk> djahandarie: and you can reify a list of things that you can reify into a type into a type
13:31:37 <monochrom> no difference
13:31:38 <EvanR-work> these are haskell terminologies
13:31:42 <djahandarie> edwardk, yeah I remember you explaining it
13:31:53 <djahandarie> It sounded simple when you did
13:32:04 <orbital_fox> monochrom, was "no difference" to my question? 
13:32:06 <edwardk> so you can reify anything that you can encode into a list of numbers... anything Storable fits that bill
13:32:07 <monochrom> yes
13:32:14 <orbital_fox> ok thanks
13:32:20 <edwardk> and StablePtrs are Storable, and can point to any haskell object
13:32:29 <djahandarie> But the fact that you are calling unSsafePerformIO, doRefStablePtr, freeStablePtr, and newStablePtr just makes it scary
13:32:34 <Cale> orbital_fox: Sometimes "list" is used for the finite case and "sequence" means infinite.
13:32:40 <edwardk> so you can reify any haskell object into a type, that due to the instance you can reflect back down into that object
13:32:54 <Eduard_Munteanu> edwardk: when you're saying "reify a number into a type", you mean in that in a peano sort of way?
13:33:03 <edwardk> djahandarie: the unsafePerformIO for the freeStablePtr stuff is a trick oleg came up with to avoid leaking stable pointers
13:33:05 <Cale> orbital_fox: But there are no hard standards about notation in mathematics, so you'd have to determine that in each context.
13:33:06 <Eduard_Munteanu> s/in that/that/
13:33:09 <EvanR-work> edwardk: are your words making sense to you?
13:33:18 <orbital_fox> Cale, right, and is that the case in haskell? and generally programmatic implementations?
13:33:45 <EvanR-work> reify into a type, reflect back down
13:33:46 <Cale> In Haskell, lists may be finite or infinite
13:33:47 <edwardk> Eduard_Munteanu: yeah if i have a class like class ReflectNum s where reflectNum :: Num a => Tagged s a -- I can make various types like data Z   with an instance that says its value is 0
13:34:00 <monochrom> ironically, in haskell it is the opposite: lists are infinite, sequences are finite.
13:34:08 <Eduard_Munteanu> Ah, I see.
13:34:10 <edwardk> and data S a -- with an instance that says its value is 1 more than the value of a, etc.
13:34:12 <dolio> You can replace "reify" and "reflect" with "turn into" if that makes more sense.
13:34:13 <Cale> and oddly enough, there's Data.Sequence, which can only encode finite sequences, yeah
13:34:34 <EvanR-work> ok im feeling better now
13:34:45 <Cale> So I guess the answer is that you should just be careful about what things mean in context ;)
13:34:55 <dolio> They're just arbitrarily chosen to indicate the two different directions.
13:34:59 <fserb> edwardk, not sure I understand it in any meaningful level, but I made it work. Scary shit.
13:35:05 <monochrom> in the limit you decide that there is no point splitting hair
13:35:12 <edwardk> EvanR-work: most of the time they do. but it good be a form of glossolalic aphasia ;)
13:35:12 <dolio> reify is value -> type and reflect is type -> value, for some reason.
13:35:16 <edwardk> er could be
13:35:18 <orbital_fox> Cale, monochrom, hmm I am asking cause im about to implement a little class in C++, and i wanted to be careful about naming it
13:36:02 <EvanR-work> now i can understand several language features from the business world, maybe
13:36:03 <orbital_fox> it will be used to handle temporary lists or sequences from expressions
13:36:07 * hackagebot HaskellForMaths 0.3.1 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.3.1 (DavidAmos)
13:36:29 <Eduard_Munteanu> EvanR-work: lol. Or read a management paper. :)
13:36:45 <monochrom> every name upsets someone
13:36:47 <EvanR-work> orbital_fox: you probably dont need to worry about correct terminology at all in c++
13:36:50 <EvanR-work> no one will notice
13:36:55 <djahandarie> edwardk, what do you think about that HaskellForMaths package btw?
13:37:03 <edwardk> djahandarie: never looked
13:37:04 <orbital_fox> EvanR-work,  i will
13:37:11 <Eduard_Munteanu> djahandarie: um, where's that?
13:37:21 <djahandarie> The thing hackagebot just spammed
13:37:26 <djahandarie> http://hackage.haskell.org/package/HaskellForMaths-0.3.1
13:37:27 <Eduard_Munteanu> Oh.
13:37:33 <EvanR-work> an infinite list structure in c++ sounds pretty horrendous
13:37:45 <Eduard_Munteanu> My retina seems to automatically eliminate its messages from sight.
13:37:51 <orbital_fox> monochrom, do you mind a PM for a couple of minutes?
13:37:58 <monochrom> yes, I mind.
13:38:06 <orbital_fox> k
13:38:08 <edwardk> djahandarie: i'll admit i'm scared by the number of lists involved in the API ;)
13:38:21 <djahandarie> Formidable API then
13:38:27 <EvanR-work> how does type -> value work
13:38:29 <edwardk> oh, i have looked at this before
13:38:33 <Eduard_Munteanu> Why is everyone so eager to ask in PM instead of asking the _entire_ channel?
13:38:33 <EvanR-work> what value
13:38:42 <Veinor> i think i'm going to learn how to use the enumerator package
13:39:39 <Veinor> seems nicer than iteratee
13:40:09 <Eduard_Munteanu> Hm, I assume Haddock doesn't run immediately on uploaded packages.
13:40:15 <djahandarie> Eduard_Munteanu, yes
13:40:24 <djahandarie> I think it is a nightly cron
13:40:42 * Eduard_Munteanu looks at the previous version.
13:43:05 <Eduard_Munteanu> Grrr... I wonder if [[a]] is a useful representation of a matrix, like Math.Algebra.LinearAlgebra does.
13:43:27 <Eduard_Munteanu> Last time I tried that representation, it kinda sucked.
13:43:31 <dolio> I'd be suspicious of it.
13:43:34 <EvanR-work> Array for the win
13:43:38 <Eduard_Munteanu> Yeah.
13:43:43 <dolio> Assuming you're actually using it for matrix stuff.
13:45:04 <Eduard_Munteanu> I've been messing my brains trying to figure out a 2D zipper using lists, I'm unsure it works that way. If it did, lists would be workable.
13:45:33 <EvanCarroll> is this prompted by the new LYAH chapter?
13:45:45 <EvanCarroll> http://learnyouahaskell.com/zippers
13:46:13 <Eduard_Munteanu> EvanR-work: um no. I actually got the idea while trying to extend sigfpe's comonadic cellular automata to 2D.
13:46:18 <Veinor> Eduard_Munteanu: moveUp, moveDown, moveLeft, moveRight
13:46:22 <Veinor> implementation is left to the reader
13:46:27 <EvanR-work> EvanCarroll: not me!
13:46:35 <Eduard_Munteanu> EvanR-work: I eventually gave up and implemented a comonadic "zipper" using an Array :)
13:46:51 <Eduard_Munteanu> Veinor: I don't think that works.
13:47:02 <Eduard_Munteanu> At least not efficiently.
13:47:12 <BrianHV> am I missing some obvious TimeSpan or date/time arithmetic functionality?
13:47:32 <EvanR-work> @src TimeDiff
13:47:32 <lambdabot> Source not found. My pet ferret can type better than you!
13:48:06 <Eduard_Munteanu> Veinor: for example, try writing out a 'data' declaration for such a zipper, you'll find out you can't really represent all elements. You can make out a "cross" of sorts, but not a grid.
13:48:13 <EvanR-work> BrianHV: theres Data.Time
13:48:37 <BrianHV> EvanR-work: yeah, I'm using ZonedTime from that module, but I can't figure out how to add a few hours to a ZonedTime
13:48:38 <Eduard_Munteanu> Unless it's something like data Zipper2D a i = Zipper2D [[a]] i
13:48:50 <Eduard_Munteanu> But that sucks.
13:48:54 <edwardk> Eduard_Munteanu: it is a lot easier =)
13:48:55 <EvanR-work> BrianHV: you cant
13:49:08 <Veinor> edwardk: goUpRight, goUpUpRight, ...
13:49:18 <EvanR-work> try converting to clock time first, and adding n*3600 seconds
13:49:22 <EvanR-work> and convert back
13:49:24 <Eduard_Munteanu> edwardk: what do you mean?
13:49:35 <BrianHV> EvanR-work: ok, thanks
13:49:36 <edwardk> Eduard_Munteanu: to use an array for the 2d automaton
13:50:13 <edwardk> otherwise you need a data structure that you can index on two axes efficiently, and while there exist tree structures that have that property they aren't nice
13:50:16 <BrianHV> though hoogle doesn't come up with an obvious way to convert to clock time
13:50:24 <Eduard_Munteanu> edwardk: heh, well, I used an array, just wanted to make evaluation comonadic. It worked with something that remotely resembles a zipper: data Grid a i = Grid (Array a i) i
13:50:43 <edwardk> Eduard_Munteanu: there is a comonad for that in category-extras called 'Pointer'
13:50:55 <Eduard_Munteanu> edwardk: oh.
13:51:00 <EvanR-work> BrianHV: well theres secondsToDiffTime
13:51:15 <EvanR-work> then theres addUTCTime
13:51:30 <Eduard_Munteanu> edwardk: anyway, it was an exercise in itself. :)
13:51:46 <edwardk> data Grid i e = Grid (Array i e) i
13:51:54 <edwardk> extract (Grid a i) = a ! i
13:52:01 <Eduard_Munteanu> Yeah.
13:52:31 <edwardk> http://hackage.haskell.org/packages/archive/category-extras/0.52.1/doc/html/Control-Comonad-Pointer.html
13:52:52 <EvanR-work> BrianHV: last time i researched this i didnt have internet, and basically learned from the types found in ghci. now that i have internet and read the docs, its very interesting ;)
13:53:02 <djahandarie> Didn't sigfpe write something like that?
13:53:25 <Eduard_Munteanu> djahandarie: sorta... but he didn't use an array.
13:53:26 <edwardk> djahandarie: yeah i credit him in the docs for that comonad
13:53:31 <EvanR-work> DiffTime is what you want, add a certain amount of real time. NominalDiffTime is the only way to add time to UTC clock time due to UTC being based on leapseconds, and NominalDiffTime not having them
13:53:43 <BrianHV> EvanR-work: converting to utc and back looks promising
13:53:56 <edwardk> Eduard_Munteanu: actually he did in a different article
13:53:57 <edwardk> http://blog.sigfpe.com/2008/03/comonadic-arrays.html
13:54:04 <EvanR-work> if you want to be wrong in your calculation about once every five years, add some NominalDiffTime
13:54:10 <EvanR-work> otherwise i dont know...
13:54:14 * EvanR-work looks for TAI time
13:54:16 <Eduard_Munteanu> edwardk: what would be really nice is to have Comonad instances defined in terms of either extract and duplicate or extract and extend.
13:54:31 <Eduard_Munteanu> edwardk: last time I tried defining duplicate wouldn't do it.
13:54:39 <ketil> I don't know how to phrase this, but....  is GHC really bad at running lots of threads?  I tried running a program with -N and it slowed down, a lot.  Using 1000% cpu or so, but still slower (wall clock) than the single threaded version.
13:54:50 <Eduard_Munteanu> Just like in Control.Monad where join isn't part of the typeclass. :(
13:56:03 <Eduard_Munteanu> edwardk: ah. I see.
13:56:22 <EvanR-work> BrianHV: ah. Data.Time.Clock.TAI this is black magic for when you want to mess with leap seconds ;)
13:57:23 <EvanR-work> :t addAbsoluteTime
13:57:24 <lambdabot> Not in scope: `addAbsoluteTime'
13:57:48 <Eduard_Munteanu> @src Comonad
13:57:48 <lambdabot> Source not found.
13:57:52 <Eduard_Munteanu> Grr.
13:58:10 <EvanR-work> i like how haskell libraries actually acknowledge these things about the real world where as in php the library just says 'to get a random number, use mt_rand. dont worry about shared state or restoring'
13:58:18 <Eduard_Munteanu> Anyway, this doesn't look right to me... class Copointed w => Comonad w where
13:58:34 <EvanR-work> also dont worry about seeding, php seeds for you
13:58:36 <Eduard_Munteanu> duplicate :: w a -> w (w a); extend :: (w a -> b) -> w a -> w b
13:58:50 <Eduard_Munteanu> Should also have extract.
13:59:01 <BrianHV> there seems to be no data constructor for NominalDiffTime...?
13:59:08 <edwardk> Eduard_Munteanu: you can actually
13:59:10 <Eduard_Munteanu> And default definitions to make it possible to define a comonad multiple ways.
13:59:25 <edwardk> Eduard_Munteanu: you need to provide both duplicate and map though
13:59:26 <EvanR-work> BrianHV: im investigating
13:59:47 <edwardk> Eduard_Munteanu: likewise with monad you need return join AND map or just return and bind
14:00:14 <edwardk> Eduard_Munteanu: note the superclass
14:00:18 <Eduard_Munteanu> edwardk: oh wait, now I see, you're basing it on Copointed instead of Functor, so Copointed has extract.
14:00:20 <edwardk> Eduard_Munteanu: copointed provides extract
14:00:22 <Eduard_Munteanu> Yeah.
14:00:33 <edwardk> there are lots of useful copointed functors
14:01:00 <edwardk> and there are compositions by which given a copointed functor and a comonad and a distributive law between them you can generate a comonad, etc.
14:01:00 <Eduard_Munteanu> Indeed, Monad should also be based on a Pointed.
14:01:19 <edwardk> Eduard_Munteanu: or Applicative
14:01:25 <Eduard_Munteanu> Yeah.
14:01:26 <Eduard_Munteanu> :t pure
14:01:27 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
14:01:45 <edwardk> Eduard_Munteanu: but Applicative has the problem that it only works over categories with arbitrary exponentials
14:01:49 <EvanR-work> BrianHV: ok. to get some amount of nominal diff time, you can do diffUTCTime :: UTCTime -> UTCTime -> NominalDiffTime
14:02:23 <edwardk> so really one should flip the definition of bind around, so it doesn't require exponentials, and base it on a strong lax monoidal functor, which is then in turn based on a pointed functor, etc.
14:02:51 <edwardk> and then you can start killing strength, etc.
14:04:28 <BrianHV> EvanR-work: which means I have to construct a couple of arbitrary UTCTimes to get a NominalDiffTime?
14:04:30 <djahandarie> Killing it?
14:04:59 <BrianHV> EvanR-work: and it seems like the UTCTime data constructor requires a DiffTime, which also has no constructor, so I also need some other way to construct my two UTCTimes...
14:05:09 <EvanR-work> BrianHV: that logically works out. nominaldifftime is the difference between two utc times, which is not a real length of time, because it ignores leap seconds
14:05:37 <EvanR-work> BrianHV: DiffTime, an absolute interval, can be constructed from number of seconds using secondsToDiffTime
14:05:54 <BrianHV> aah, I see
14:06:12 <magthe> how can I get './Setup.hs register' to register in a custom package database (i.e. neither in --global or --user)?
14:06:33 <EvanR-work> Day can be constructed using toModifiedJulianDay 
14:06:45 <EvanR-work> set that to zero
14:07:11 <EvanR-work> er
14:07:23 <EvanR-work> wouldnt it make sense to set the day to jan 1 1970...
14:07:33 <Eduard_Munteanu> djahandarie: I assume edwardk is referring to the strong monad in here.. http://en.wikipedia.org/wiki/Strong_monad
14:07:38 <EvanR-work> otherwise how much sense does utc make 
14:08:14 <EvanR-work> BrianHV: btw what are adding 2 hours to something for ;)
14:08:38 <djahandarie> Eduard_Munteanu, I was assuming a strong functor
14:08:39 <BrianHV> I'm reading data the specifies show start times.  shows are always three hours.
14:08:42 <Eduard_Munteanu> I'm a bit unsure how tensorial strength applies to Haskell.
14:08:44 <BrianHV> that* specifies
14:08:45 <djahandarie> I was just wondering what he meant by killing it
14:09:15 <Eduard_Munteanu> Removing it so you end up with a monad? :/
14:09:16 <stepcut> > (fromIntegral 10) :: NominalDiffTime
14:09:17 <lambdabot>   Not in scope: type constructor or class `NominalDiffTime'
14:09:43 <monochrom> "killing tensorial strength in haskell"? an academic paper title generated by a bot? :)
14:09:44 <EvanR-work> its not integrals
14:09:49 <EvanR-work> BrianHV: but hes right
14:09:55 <EvanR-work> NominalDiffTime is an instance of Num
14:09:56 <EvanR-work> so
14:10:02 <EvanR-work> > 10 :: NominalDiffTime
14:10:03 <lambdabot>   Not in scope: type constructor or class `NominalDiffTime'
14:10:27 <EvanR-work> addUTCTime 3600 showStartTime
14:10:29 <BrianHV> huh.
14:10:55 <EvanR-work> > 10 + (1 :+ 1)
14:10:56 <lambdabot>   11.0 :+ 1.0
14:11:03 <EvanR-work> regular numbers can stand for any Num
14:11:27 <EvanR-work> i dont know if its 3600 seconds or picoseconds or what
14:11:42 <djahandarie> strength should be defined in lambdabot in its little file
14:11:52 <djahandarie> As fmap . (,) or whatever it is
14:11:57 <djahandarie> @type fmap . (,)
14:11:58 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
14:12:01 <djahandarie> Yeah that
14:13:57 <EvanR-work> BrianHV: in ghci, import Data.Time, then 10 :: NominalDiffTime, ;)
14:14:15 <BrianHV> yeah, it works.  thanks.  that's much easier. :)
14:14:19 <BrianHV> so, I wound up with this... addToZonedTime diff time = utcToZonedTime (zonedTimeZone time) (addUTCTime diff (zonedTimeToUTC time))
14:14:48 <BrianHV> which I guess isn't that unreasonable.  just wish I didn't need it.
14:14:55 <EvanR-work> youd probably do well to keep all your internal times in UTC until display
14:15:22 <EvanR-work> when reading times, convert from the i-hope-you-know-the source time zone
14:15:32 <EvanR-work> in mysql you dont ;)
14:15:41 <BrianHV> they come out of my data with zones, and I want to make sure I keep the correct zones on output.
14:15:51 <BrianHV> I guess I could carry zones along with utc
14:15:59 <EvanR-work> they always are in the correct zone
14:16:08 <EvanR-work> you choose the zone when you display them
14:16:11 <EvanR-work> usually local
14:16:20 <BrianHV> local changes though
14:16:24 <EvanR-work> yes
14:16:32 <BrianHV> it's a tour, so within the same week we could be in three different time zones
14:16:37 <EvanR-work> if its a large scale application show both utc and local
14:16:48 <EvanR-work> or two specific time zones, or those three
14:17:06 <EvanR-work> internally just keep it as utc though
14:18:08 <BrianHV> well.  now that I think more, I guess I really don't care about the output timezone.
14:19:11 <stepcut> edwardk: http://www.haskell.org/pipermail/haskell-cafe/2010-September/083965.html
14:21:03 <EvanR-work> BrianHV: i would care that the times are correct in some timezone, and i know what zone that is when i read it ;)
14:21:21 <EvanR-work> usually that means show in local time
14:23:05 <Eduard_Munteanu> djahandarie: I see.
14:27:24 * hackagebot SoccerFun 0.3.6 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.3.6 (JanRochel)
14:28:15 <roconnor> @seen dolio
14:28:15 <lambdabot> Unknown command, try @list
14:28:15 <preflex>  dolio was last seen on #haskell 44 minutes and 32 seconds ago, saying: Assuming you're actually using it for matrix stuff.
14:29:05 <EvanR-work> soccerfun looks awesome
14:29:31 <EvanR-work> written in clean ??
14:31:14 <edwardk> stepcut: thanks!
14:34:28 <BrianHV> EvanR-work: looks like haskell, iCal, and I are on the same page now.  thanks for the help!
14:34:49 <EvanR-work> great
14:34:50 <gigabytes> hello
14:35:14 <EvanR-work> its refreshing to see a library make sense
14:36:09 <BrianHV> well... it was a struggle for me, but that may be my n00bishness.
14:36:18 <xivix> Is BONUS here?
14:36:48 <mauke> preflex: seen BONUS
14:36:48 <preflex>  BONUS was last seen on #haskell 13 days, 6 hours, 50 minutes and 20 seconds ago, saying: ah. i'll read the thesis then
14:37:11 <xivix> Oh poo.
14:37:20 <xivix> Wanted to thank him for making LYAH.
14:37:29 <mauke> BONUS++
14:37:44 <EvanR-work> BrianHV: im thinking the choice between utctime/nominaldifftime or absolutetime(tai)/difftime comes down to a question of whether you are doing conventional time keeping or are doing real physical time calculations which need to be correct
14:37:50 <hpc> holy crap, zippers are up!
14:37:53 * Eduard_Munteanu takes a look at LYAH
14:37:54 * hpc reads
14:37:59 <xivix> Yup.
14:38:04 <djahandarie> Oh, nice
14:38:05 <Eduard_Munteanu> @where lyah
14:38:05 <lambdabot> http://www.learnyouahaskell.com/
14:38:07 <xivix> It was on proggit today.
14:38:45 <xivix> I'm actually somewhat surprised, though, that he doesn't shoutout _why anywhere on the site.
14:38:48 * jmcarthur has no idea what "zippers are up" means
14:38:55 <xivix> It's obviously inspired by the Poignant Guide.
14:38:56 <jmcarthur> oh, in lyah?
14:39:00 <djahandarie> jmcarthur, a new section
14:39:01 <djahandarie> Yeah
14:39:07 <gigabytes> hello everybody. I have a little question. consider this simple tail recursive factorial. http://pastebin.com/Tq1vqCRx
14:39:16 <mzero> BONUS ROCKS!
14:39:36 <mzero> wow - you think he's been reading that thesis for 13 days?!?!
14:39:38 <EvanR-work> except lyah has actual content
14:39:45 <EvanR-work> you cant learn ruby from why
14:39:58 <gigabytes> is there a simple way to transform a function like this into some type of call to foldl (or foldr)?
14:40:03 <xivix> You can *kinda* learn Ruby... But yeah, I agree.
14:40:27 <BONUS> whew, finished the thesis!
14:40:27 <lambdabot> BONUS: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:40:39 <mzero> heh
14:40:47 <BONUS> it took 13 days but it was worth it
14:40:51 <xivix> LYAH is an eccentric manual, while Poignant Guide was just eccentric in general... Oh here he is!
14:41:37 <hpc> haha, nice timing BONUS
14:41:46 <BONUS> yeah i used to give him a shout out in the faq but then at some point i kind of felt lyah had its own thing
14:41:48 <monochrom> eccentric are those who use haskell
14:41:48 <xivix> 13 days ago, and I come 5 minutes before he signs in.
14:41:55 <EvanR-work> gigabytes: yes 
14:42:01 <EvanR-work> factorial is clearly a fold
14:42:05 <EvanR-work> a foldl' probably
14:42:20 <mzero> > let fac = foldr (*) 1 . enumFromTo 1 in fac 7
14:42:21 <lambdabot>   5040
14:42:24 <Eduard_Munteanu> Heh, nice artwork.
14:42:28 <xivix> BONUS: Thank you for making such an awesome site.
14:42:36 <BONUS> haha thanks for reading
14:42:41 <xivix> It's what I came here, literally 5 minutes ago, to say.
14:42:48 <c_wraith> If you can perform an operation as a single pass across a list with an accumulator, you should probably implement it as foldl'
14:42:53 <BONUS> haha, nice timing
14:42:58 <xivix> Indeed.
14:43:23 <c_wraith> You know he's like beetlejuice, right?  Say his name 3 times, and he appears. :)
14:43:33 <BONUS> also i eat bugs
14:43:34 <EvanR-work> BONUSjuice
14:43:36 <EvanR-work> BONUSjuice
14:43:37 <EvanR-work> BONUSjuice
14:43:44 <monochrom> oh god, beetle juice
14:43:45 <BONUS> haha
14:43:51 <xivix> Peace, I'm gonna go read s'more.
14:44:15 <mzero> gigabytes: of course, such a fold is common enough to have a function for it
14:44:26 <mzero> > let fac = product . enumFromTo 1 in fac 7
14:44:27 <lambdabot>   5040
14:44:33 <Eduard_Munteanu> BONUS: what paper? I see you kinda allude to Oleg's ZipperFS.
14:44:36 <xivix> BONUS: If you didn't know, your site is on proggit right now.
14:44:37 <Lee_> msg lambdabot @messages
14:44:41 <mzero> though enumFromTo is rather rare, so I'd write:
14:44:47 <EvanR-work> > produce [1..7]
14:44:48 <lambdabot>   Not in scope: `produce'
14:44:49 <Eduard_Munteanu> s/paper/thesis
14:44:51 <EvanR-work> > product [1..7]
14:44:51 <mzero> > let fac n = product [1..n] in fac 7
14:44:52 <lambdabot>   5040
14:44:52 <lambdabot>   5040
14:45:03 <xivix> Oh, wait, you posted it.
14:45:06 <gigabytes> mzero: of course. But I'm interested in some generic way to transform a tail recursion to a fold call. is it possible?
14:45:07 <xivix> LMAO whoops.
14:45:15 <gigabytes> into*
14:45:36 <BONUS> haha
14:46:02 <EvanR-work> use one of these for factorial
14:46:02 <mzero> gigabytes - that *is* what folds are
14:46:03 <gigabytes> expecially some tail recursive functions that operate on lists (not the case of the factorial)
14:46:04 <EvanR-work> http://www.willamette.edu/~fruehr/haskell/evolution.html
14:47:28 <gigabytes> mzero: yes. But there are some tail recursive functions that use the accumulator parameter. how do I translate this into a fold?
14:47:48 <EvanR-work> it doesnt have to be tail recursive
14:48:10 <mzero> :t foldr
14:48:11 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:48:14 <Lee_> I have a question: I'd like to map across `elem`.  Works fine with (`elem` "abc") but (`elem` ["abc" ab"]) gives me a type error.  Anybody know why?
14:48:18 <EvanR-work> wait, what is tail recursive in haskell again?
14:48:20 <mzero> that b *is* the accumulator
14:48:50 <gigabytes> hm
14:48:53 <Lemmih> Lee_: What should that code do?
14:48:55 <mauke> Lee_: uh, that's a syntax error
14:49:00 <BONUS> Eduard_Munteanu: i dont quite remember, i think i was asking about why the type declarations for the session types package are so freaky weird
14:49:01 <mzero> Lee_: The first is looking for a character in a string, the second a string in a list of strings
14:49:02 <mauke> " have to be balanced
14:49:10 <BONUS> and quicksilver pointed me to the thesis about them
14:49:18 <Lemmih> Lee_: (I assume you made a typo.)
14:49:46 <Eduard_Munteanu> BONUS: oh, I thought it was about the zipper fs in LYAH, I just saw it.
14:50:23 <BONUS> yeah i mostly referred to huet's paper when writing that
14:50:58 <EvanR-work> ok. so tail recursive in haskell is when the top most expression is an application of itself... sounds like a stupid name :S
14:51:21 <BONUS> brb
14:51:25 <hpc> wow, so zippers make sense now
14:51:26 <c_wraith> EvanR-work, that's tail-recursive in any language.
14:51:38 <hpc> BONUS: you have done in 15 minutes what hours of wikibooking could not
14:51:39 <EvanR-work> whats tail about it
14:51:53 <Eduard_Munteanu> EvanR-work: if you write it in an imperative language, it's easy to see.
14:51:58 <BONUS> haha hpc thanks, glad you found it enlightening
14:52:00 <EvanR-work> yes i saw that
14:52:05 <EvanR-work> in which case its *last*
14:52:13 <EvanR-work> but in haskell its first
14:52:20 <Lemmih> EvanR-work: "f x = f (x+1)" is tail-recursive. 'f' bites the tail of itself.
14:52:54 <Eduard_Munteanu> EvanR-work: heh, yeah. Though when the term was invented, they were probably applying the reasoning to imperative languages.
14:52:58 <hpc> haskell is a lot like math, it seems; things make no sense until you see it derived in front of you
14:52:58 <mzero> gigabytes: you are interested in functions of the form: If we have the empty list, then accum0, otherwise apply some f to the first/last element and the result from the rest of the list... right?
14:53:06 <c_wraith> However, haskell is different in that tail-call optimization generally does nothing, without also doing strictness analysis.
14:53:34 <sproingie> "recursive definition" is one thing you can call it in haskell, though that could put the recursion anywhere
14:53:37 <BONUS> yeah the term tail recursive isn't applicable to haskell so much i think, at least not in a very interesting way
14:53:52 <BONUS> btw anyone coming to belhac on friday?
14:53:56 <Lemmih> c_wraith: How so?
14:53:58 <Eduard_Munteanu> Yeah, it's no use to TCO if you still end up with lotsa lazy thunks.
14:54:07 <sproingie> tree traversal isn't tail-recursive but is a recursive definition
14:54:08 <Eduard_Munteanu> Lemmih: ^
14:54:24 <EvanR-work> whats/wheres belhac
14:54:28 <Eduard_Munteanu> I think we were discussing that the other day.
14:54:35 <BONUS> a haskell hackaton in belgium
14:54:46 <Lemmih> Eduard_Munteanu: Yes it is. Think of 'last'.
14:55:22 <Lemmih> Eduard_Munteanu: You don't always build up huge chains of closures when you're recursing.
14:55:42 <Eduard_Munteanu> Ah, I'm not sure how that works exactly...
14:55:44 <Eduard_Munteanu> @src last
14:55:44 <lambdabot> last [x]    = x
14:55:45 <lambdabot> last (_:xs) = last xs
14:55:45 <lambdabot> last []     = undefined
14:56:11 <Eduard_Munteanu> Mm, probably it makes sense.
14:56:16 <Lemmih> Eduard_Munteanu: It would eat the stack if it wasn't tail-recursive.
14:56:21 <Eduard_Munteanu> But in folds you generally need to evaluate intermediates.
14:56:21 <EvanR-work> > last [1..10000]
14:56:22 <lambdabot>   10000
14:56:23 <gigabytes> mzero: yes, that kind of functions
14:56:29 <EvanR-work> > last [1..100000000]
14:56:32 <lambdabot>   mueval-core: Time limit exceeded
14:56:41 <Eduard_Munteanu> So if you're not ignoring it it's going lazy.
14:56:45 <gigabytes> mzero: I'll post a concrete example if you want
14:56:52 <mzero> sure
14:56:56 <Lemmih> Eduard_Munteanu: Sure, but that doesn't mean that TCO is useless without strictness analysis.
14:57:25 <Eduard_Munteanu> Lemmih: ah, that makes it more clear.
14:58:28 <Lemmih> Writing an Haskell to C compiler makes one keenly aware of when tail-calls are essential.
14:58:50 <edwardk> Lemmih: hahahahaha
14:58:55 <chrisdb> Question: Is there a tool for doing some analysis of dependencies in a Haskell program? I'm not sure my current distribution of functions across modules is optimal... 
14:59:05 <chrisdb> I could improve it by experimentation and/or trying to sketch things out on paper, but I was wondering if there was any premade tool which will take a set of Haskell source files and draw some pretty pictures.
14:59:18 <edwardk> Lemmih: i gave up and turned to using the cheesy stackhack approach
14:59:41 <gigabytes> mzero: http://pastebin.com/RgX25Ne5
14:59:43 <edwardk> Lemmih: http://www.ccs.neu.edu/scheme/pubs/stackhack4.html
15:00:10 <gigabytes> mzero: for example this is not tail-recursive but uses an accumulator.
15:00:21 <gigabytes> mzero: is this transformable into a fold?
15:00:34 * ddarius doesn't understand this "TCO is meaningless in Haskell" meme.
15:00:48 <edwardk> Lemmih: that let me exploit the c stack when possible but fall back on heap based frames to compact unoptimized tail-calls, and capture continuations, etc.
15:00:54 <EvanR-work> gigabytes: first use fold to get the right hand sides, then zip
15:01:08 <EvanR-work> or instead of fold, 
15:01:17 <ddarius> edwardk: Besides your paycheck which you haven't received yet, how's your new job treating you?
15:01:21 <EvanR-work> > map sum (tails [1,6,2,5,4])
15:01:22 <lambdabot>   [18,17,11,9,4,0]
15:01:31 <EvanR-work> hm
15:01:32 <edwardk> ddarius: actually i already received a check. they are fast ;)
15:01:36 <edwardk> ddarius: and quite well
15:01:45 <gigabytes> EvanR-work: of course but I should use a fold, and make only one pass to the list
15:01:52 <EvanR-work> why do you say that
15:02:02 <gigabytes> because I have to ;)
15:02:17 <EvanR-work> you should have to?
15:02:50 <EvanR-work> you should do the simplest unless its a performance problem or nazis are beating the door in of your apartment and demand otherwise
15:03:01 <Eduard_Munteanu> Or it's an assignment.
15:03:03 <edwardk> ddarius: its kinda nice getting paid to work on a type inferencer ;)
15:03:05 <mzero> > let f = snd . foldl (\(acc,res) x -> (acc+x, (x,acc):res)) (0,[]) in f [3,10,200]
15:03:05 <lambdabot>   [(200,13),(10,3),(3,0)]
15:03:06 <EvanR-work> thats what i said
15:03:17 <Eduard_Munteanu> :)
15:03:39 <gigabytes> EvanR-work: eheh I don't know if he's nazi but he's demanding this :) yes it's an assignment
15:03:41 <mzero> yes, but I did it in terms of his general function structure, rather than reduce it for this particular example
15:03:42 <mzero> :-)
15:03:51 <ddarius> edwardk: Clearly I have the wrong job.
15:04:05 <Lemmih> edwardk: Neat. (still reading.)
15:04:08 <mzero> > let f = snd . foldl (\(acc,res) x -> (acc+x, (x,acc):res)) (0,[]) in f [1,6,2,5,4]
15:04:09 <lambdabot>   [(4,14),(5,9),(2,7),(6,1),(1,0)]
15:04:16 <edwardk> ddarius: i did make a point of introducing you to both companies =P
15:04:31 <Eduard_Munteanu> Mm... do you have Haskell or Haskell-related jobs?
15:04:32 <gigabytes> mzero: let me understand your example
15:04:50 <mzero> oh - whoops, I got it backwards
15:04:51 <Eduard_Munteanu> Not that I currently need one, but I'm interested in the prospects.
15:05:01 <gigabytes> mzero: does it do a single pass like my version?
15:05:13 <mzero> > let f = snd . foldr (\x (acc,res) -> (acc+x, (x,acc):res)) (0,[]) in f [1,6,2,5,4]
15:05:14 <lambdabot>   [(1,17),(6,11),(2,9),(5,4),(4,0)]
15:05:21 <mzero> yes, gigabytes, it does
15:05:29 <gigabytes> hm
15:05:32 <gigabytes> is it backward?
15:05:38 <edwardk> Eduard_Munteanu: of sorts
15:05:49 <Eduard_Munteanu> edwardk: research?
15:06:02 <mzero> > let f = snd . foldl (\(acc,res) x-> (acc+x, res ++ [x,acc])) (0,[]) in f [1,6,2,5,4]
15:06:03 <lambdabot>   [1,0,6,1,2,7,5,9,4,14]
15:06:07 <ddarius> edwardk: Maybe in a few years, but I'll probably want to move geographically as well as occupationally then.
15:06:14 <mzero> bah
15:06:21 <edwardk> ddarius: fair nuff
15:06:27 <mzero> > let f = snd . foldl (\(acc,res) x-> (acc+x, res ++ [(x,acc)])) (0,[]) in f [1,6,2,5,4]
15:06:28 <lambdabot>   [(1,0),(6,1),(2,7),(5,9),(4,14)]
15:06:33 <gigabytes> mzero: that's it
15:06:43 <edwardk> Eduard_Munteanu: nah, i like actually shipping something eventually =)
15:06:53 <Eduard_Munteanu> Heh :).
15:06:55 <gigabytes> but doesn't that append do too much work?
15:07:03 <EvanR-work> > let xs = [1,6,2,5,4] in zip xs (map sum . tails . reverse $ xs)
15:07:04 <lambdabot>   [(1,18),(6,14),(2,9),(5,7),(4,1)]
15:07:06 <ddarius> edwardk: You know the answer to this: what's the quickest you can do a Master's degree?
15:07:09 <mzero> so the key to realize is that in this example there are TWO things being carried along - one is your explicit accum variable, the other is the partial construction of the list
15:07:13 <EvanR-work> hm
15:07:19 <mzero> so to make that a fold, i carried two things along in a tuple,
15:07:24 <mzero> and picked out one in the end
15:07:36 <edwardk> ddarius: i was unable to compress one beyond a semester =/
15:07:46 <EvanR-work> > let xs = [1,6,2,5,4] in zip xs (reverse (map sum . tails . reverse $ xs))
15:07:47 <lambdabot>   [(1,0),(6,1),(2,7),(5,9),(4,14)]
15:08:27 <edwardk> ddarius: it could more conventionally be done in about a year or a couple of semesters if you kick ass and take names
15:08:40 <Eduard_Munteanu> Of course, you can always get a more liberal job and do it your way. Well, bad example, but say, sysadmin.
15:08:46 <EvanR-work> > let xs = [1,6,2,5,4] in zip (reverse xs) (map sum . tails $ xs)
15:08:47 <lambdabot>   [(4,18),(5,17),(2,11),(6,9),(1,4)]
15:09:01 <mzero> your example is a little awkward because the defined order of the sum and the natural order of the list construction are in opposite orders
15:09:12 <gigabytes> mzero: yes that's the difficult part
15:09:14 <mzero> hence the need for ++ [ ... ]  
15:09:32 <EvanR-work> :t heads
15:09:33 <lambdabot> Not in scope: `heads'
15:09:34 <gigabytes> mzero: that kind of use of ++ is what I'm specifically try to avoid
15:09:46 <gigabytes> because it traverses the partial list at each call
15:10:00 <EvanR-work> you can make a diff list during the fold
15:10:05 <mzero> you do realize that in a traditional sense, your example function isn't tail-recursive, right?
15:10:24 <EvanR-work> nevermind
15:10:25 <gigabytes> yes I know
15:10:32 <mzero> the final call in the function inner (pretending this was, say Scheme and not Haskell) is to cons, not inner
15:10:32 <mzero> okay
15:10:52 <gigabytes> Scheme..brr..
15:11:17 <gigabytes> mzero: but I think that's the right direction
15:11:23 <mzero> because it is haskell, many of us would probably separate out the two aspects
15:11:30 <gigabytes> I need to simulate the two "accumulations" with the fold
15:12:26 <EvanR-work> ah yeah
15:12:36 <mzero> > let before xs = zip xs $ drop 1 $ scanl (+) 0 xs in before [1,6,2,5,4]
15:12:37 <lambdabot>   [(1,1),(6,7),(2,9),(5,14),(4,18)]
15:12:38 <EvanR-work> one accumulator is for the sum
15:12:41 <EvanR-work> one is for the diff list
15:12:55 <mzero> > let before xs = zip xs $ scanl (+) 0 xs in before [1,6,2,5,4]
15:12:56 <lambdabot>   [(1,0),(6,1),(2,7),(5,9),(4,14)]
15:12:59 <mzero> sill me
15:13:00 <mzero> there
15:13:00 <EvanR-work> rather than snd, do ($ [])
15:13:15 <mzero> so - remember the scans - like folds, but keeping track of intermediate results
15:13:28 <mzero> this combination of zip and scanl, btw, is only one pass
15:13:31 <mzero> not two
15:13:41 <mzero> and avoids the unease you are feeling with the ++
15:13:43 <EvanR-work> mzero: why is that?
15:13:43 <gigabytes> mzero: yes, scans would be more natural in this case, but I need a fold anyway :(
15:13:55 <mzero> "need a fold"? HW?
15:14:02 <mzero> ;-)
15:14:24 <EvanR-work> gigabytes: then you can accumulate the list with composed (++xs) ;)
15:14:37 <EvanR-work> or (xs++) rather
15:14:40 <mzero> :src scanl
15:14:41 <gigabytes> hm..
15:14:45 <mzero> @src scanl
15:14:45 <lambdabot> scanl f q ls = q : case ls of
15:14:45 <lambdabot>     []   -> []
15:14:45 <lambdabot>     x:xs -> scanl f (f q x) xs
15:14:50 <mzero> bah
15:14:56 <mzero> you can write scanl in terms of foldl
15:15:07 <mzero> which, perhaps in the end, is really what you are trying to get at
15:15:10 <EvanR-work> this combination of zip and scanl is one pass, how do you figure?
15:15:27 <mzero> lazy evaluation!
15:15:31 <mzero> and fusion
15:15:35 <EvanR-work> ok
15:15:36 <EvanR-work> fusion
15:15:42 <EvanR-work> thats not a language thing ;)
15:16:00 <mzero> as the result from the zip are needed, the next step, and just the next step of the scan is produced
15:16:04 <EvanR-work> zip xs (map sum (tails xs)) also is fusion?
15:16:27 <mzero> and so the "intermediate list" never really exists all at once
15:16:51 <mzero> no - because there each application of sum must run down the lists 
15:17:16 <mzero> er, run down a list
15:17:25 <mzero> there is no sharing of the summation, as there is in the scan
15:17:33 <mzero> which is only a single pass
15:18:00 <EvanR-work> :t scanl
15:18:01 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:18:18 <EvanR-work> > scanl (+) 0 [1,2,3,4]
15:18:18 <lambdabot>   [0,1,3,6,10]
15:18:40 <EvanR-work> > scanl (:) [] [[1],[2],[3],[4]]
15:18:41 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:18:56 <EvanR-work> > scanl (:) [] [1,2,3,4]
15:18:57 <lambdabot>   Occurs check: cannot construct the infinite type: a = [a]
15:19:09 <c_wraith> (:) doesn't unify with a -> b -> a
15:19:17 <EvanR-work> :t scanr
15:19:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
15:19:23 <c_wraith> (:)'s type would unify with a -> b -> b
15:19:30 <EvanR-work> > scanr (:) [] [[1],[2],[3],[4]]
15:19:31 <lambdabot>   [[[1],[2],[3],[4]],[[2],[3],[4]],[[3],[4]],[[4]],[]]
15:19:42 <EvanR-work> > scanr (:) [] [1,2,3,4]
15:19:43 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
15:19:50 <EvanR-work> ah
15:19:56 <c_wraith> congrats, you've discovered tails. :)
15:20:06 <EvanR-work> > tails [1,2,3,4]
15:20:07 <lambdabot>   [[1,2,3,4],[2,3,4],[3,4],[4],[]]
15:20:30 <EvanR-work> next i will discover sonic
15:22:14 * mzero must get back to coding Java... alas...
15:22:22 * EvanR-work php
15:36:49 * hackagebot asn1-data 0.2.2 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.2.2 (VincentHanquez)
15:37:19 <fserb> Is it possible to mix do and where clauses? like: do x <- a ; return y where y = f x 
15:37:49 <McManiaC> fserb: do x <- a; return (y x) where y x = f x
15:37:51 <McManiaC> ;)
15:38:12 <aristid> preflex: seen snoyberg
15:38:12 <preflex>  Sorry, I haven't seen snoyberg
15:38:45 <stepkut> preflex: seen the light
15:38:45 <preflex>  the was last seen on #perl 330 days, 4 hours, 29 minutes and 14 seconds ago, saying: ....
15:38:57 <stepkut> preflex seen the_light
15:38:57 <preflex>  the_light was last seen on ##c++ 1 year, 103 days, 5 hours, 51 minutes and 58 seconds ago, saying: nolyc: here I am!
15:39:01 <stepkut> >:(
15:39:23 <stepkut> preflex has clearly seen too much
15:39:43 <Eduard_Munteanu> whois says he's only on #haskell, has he been used on #c++ ? :/
15:39:50 <c_wraith> preflex: seen too_much
15:39:50 <preflex>  Sorry, I haven't seen too_much
15:39:57 <stepkut> :)
15:40:14 <McManiaC> fserb: or even cooler: do y <$> a where y = f
15:41:34 <fengshaun> how can I check if a big string contains another string?
15:42:21 <monochrom> try isInfixOf as a first try
15:42:36 <fengshaun> hmm thanks!
15:42:42 <fserb> McManiaC, thanks.
15:43:03 <monochrom> if isInfixOf is not fast enough, there are some big gun KMP choices on hackage
15:43:29 <tibbe> fserb: :)
15:43:29 <lambdabot> tibbe: You have 1 new message. '/msg lambdabot @messages' to read it.
15:43:52 * hackagebot cryptocipher 0.2 - Symmetrical Block and Stream Ciphers  http://hackage.haskell.org/package/cryptocipher-0.2 (VincentHanquez)
15:46:53 * hackagebot certificate 0.3.2 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.3.2 (VincentHanquez)
15:48:13 <Avi_> :pl
15:48:16 <Avi_> :pl help
15:48:50 <Lemmih> Avi_: Yes?
15:49:28 <tab> Lemmih: you scared him ;)
15:50:34 <avi_> @help
15:50:35 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:50:40 <avi_> @help list
15:50:40 <lambdabot> list [module|command]
15:50:40 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
15:50:55 <avi_> @help list command
15:50:55 <lambdabot> list [module|command]
15:50:56 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
15:52:09 <Lemmih> avi_: Are you in need of assistance?
15:52:16 <avi_> @pl (\x y z > x z >> y z)
15:52:16 <lambdabot> (line 1, column 9):
15:52:16 <lambdabot> unexpected ">"
15:52:16 <lambdabot> expecting pattern or "->"
15:52:27 <avi_> @pl (\x y z -> x z >> y z)
15:52:27 <lambdabot> liftM2 (>>)
15:52:49 <Lemmih> avi_: lambdabot also responds to private messages.
15:58:37 <Lemmih> Not a chatty fellow.
16:02:11 <tromp__> i'm trying to cabal install cairo and get an error
16:02:15 <tromp__> setup: gtk2hsC2hs is required but it could not be found.
16:02:55 <Lemmih> tromp__: Install gtk2hs-buildtools.
16:03:26 <tromp__> trying...
16:04:37 <tromp__> progress! thx, Lemmih
16:06:06 <Axman6> @list Data.List
16:06:06 <lambdabot> No module "Data.List" loaded
16:06:18 <Axman6> @list Control.Monad
16:06:18 <lambdabot> No module "Control.Monad" loaded
16:06:26 <Axman6> @list Prelude
16:06:26 <lambdabot> No module "Prelude" loaded
16:06:29 <Axman6> :(
16:07:30 <mauke> @list tell
16:07:30 <lambdabot> tell provides: tell ask messages messages? clear-messages
16:07:51 <Lemmih> @list list
16:07:51 <lambdabot> system provides: echo list listchans listmodules listservers uptime
16:08:13 <Axman6> ah, thse sort of modules
16:08:21 <Axman6> @uptime
16:08:21 <lambdabot> uptime: 10d 7h 10m 2s, longest uptime: 1m 10d 23h 44m 29s
16:15:36 <Nopik> hi all.. i'm trying to play with some simple programs with gtk in haskell, got some examples from 'real world haskell'.. now, it seems, that cabal doesnt see my glade installed (even if it claims that it is already installed..)
16:15:42 <Nopik> i'm on mac, btw.
16:15:48 <Nopik> on linux it would be easier, probably
16:16:27 <Nopik> i had ghc 6.12 from haskell platform, but now i've also installed 6.10 from macports (as my glade is coming out from there as well)
16:17:18 <Nopik> so, i run 'runghc Setup configure'  on ch23 example from RWH, then it says: Configuring pod-1.0.0... Setup.hs: at least the following depedencies are missing: glade -any
16:17:39 <Nopik> cabal install glade says: No packages to be installed. All the requested packages are already installed.
16:17:59 <Nopik> when i run glade-2 command, it starts
16:18:11 <Nopik> any idea how to persuage cabal/ghc that glade is there?
16:18:18 <Nopik> is there any detailed log i could look on?
16:18:26 <dcoutts__> Nopik: sounds like it is installed
16:18:34 <Nopik> dcoutts__:  yeah, i know ;)
16:18:51 <Nopik> probably because, when i did 'cabal install glade' for first time, it actually installed it
16:18:58 <dcoutts__> Nopik: note that the glade-2 command and the Haskell glade binding package are quite different things
16:19:05 <Nopik> yes, i know
16:19:15 <Nopik> though 'cabal install glade' should do the right thing, right?
16:19:20 <dcoutts__> Nopik: you can confirm it's installed if you run ghc-pkg list
16:19:27 <Nopik> ok, let me check
16:20:24 <Nopik> it says: /Users/nopik/.ghc/x86_64-darwin-6.10.4/package.conf: glade-0.11.1, (among others)
16:20:39 <dcoutts__> Nopik: ok, so what is the problem exactly?
16:20:59 <dcoutts__> what are you doing, what do you expect to happen?
16:21:21 <mauke> <Nopik> so, i run 'runghc Setup configure'  on ch23 example from RWH, then it says: Configuring pod-1.0.0... Setup.hs: at least the following depedencies are missing: glade -any
16:21:27 <tromp__> my .cabal dir uses 327M. how much do other people have in there?
16:21:37 <mauke> hmm, just a missing --user?
16:22:03 <dcoutts__> Nopik: ohh, use 'cabal' rather than 'runghc Setup'
16:22:11 <dcoutts__> Nopik: there's no need to use both
16:22:44 <Nopik> mauke: yeah, when i added --user, it stopped to complain about glade, started to complain about other pkgs, i think i dont have installed them yet, thanks
16:22:55 <Nopik> dcoutts__: yeah, i was trying to do that as well, i think
16:23:29 <Lemmih> tromp__: 1.2G :(
16:24:48 <stepkut> is there a portable way to get the file size of a FilePath besides, withFile fp ReadMode hFileSize, ?
16:24:49 <Nopik> tromp__: 180mb, and i did not even managed to write any serious program in haskell :)
16:25:10 <tromp__> is that to be blamed on included c libraries?
16:25:30 <tromp__> or does ghc produce so much bloat?
16:25:42 <Lemmih> tromp__: Yeah, it is GHC's fault.
16:26:32 <tromp__> what makes it so bloated? 
16:26:33 <Eduard_Munteanu> Is GHC still doing static linking for everything?
16:26:41 <kmc> by default
16:26:43 <Eduard_Munteanu> (by default)
16:26:47 <Eduard_Munteanu> Yeah.
16:26:47 <kmc> and where everything = Haskell libs
16:26:50 <dcoutts__> yep
16:26:52 <kmc> it will still link libc etc. dynamically
16:26:57 <Eduard_Munteanu> Well that explains Cabal prefix sizes.
16:27:33 <dcoutts__> tromp__: 1.9G on my laptop and 3.5G on my desktop :-)
16:28:10 <tromp__> makes you wonder how much gzipping all that would save
16:28:11 <gronkalonk> Haskell is too slow, how do I write everything in core?
16:28:12 <dcoutts__> of the 3.5G, 2.7 is in lib and only 1/2 G in bin (ie the static linking)
16:28:29 <Lemmih> gronkalonk: You don't.
16:28:33 <dcoutts__> gronkalonk: you're in luck! core is a subset of Haskell!
16:28:34 <Eduard_Munteanu> gronkalonk: what makes you think that improves it?
16:28:52 <kmc> dcoutts__, not really
16:29:03 <Eduard_Munteanu> gronkalonk: or to ask something else, why do you think Haskell is the problem?
16:29:09 <gronkalonk> Becuase I know what the code should look like
16:29:17 <dcoutts__> kmc: more or less, there's some fairly minor differences
16:29:26 <Eduard_Munteanu> gronkalonk: what do you mean, when disassembled?
16:29:34 <Nopik> great, now i am able to configure the package for RWH examples, though they are not building correctly, some type errors are reported during compilation.. any idea if i need ghc 6.12 instead of 6.10?
16:29:35 <gronkalonk> no in core
16:29:37 <kmc> the ones that come to mind are strictness of 'case' and explicit type abstraction/application
16:30:11 <Eduard_Munteanu> gronkalonk: is it slow or are you conjecturing it?
16:30:43 <gronkalonk> It is too slow. It is running in 0.788 ms, but should be running in 0.100 ms
16:30:54 <Nopik> ouch, with 6.12 it is even worse
16:30:57 <Eduard_Munteanu> gronkalonk: compared to what?
16:31:01 <kmc> should be by what standard  gronkalonk?
16:31:03 <Lemmih> gronkalonk: Write your Haskell code so GHC makes the correct core.
16:31:06 <kmc> did you do traditional profiling etc?
16:31:07 <Nopik> now it says that Prelude is deprecated ;)
16:31:19 <kmc> Nopik, well the Prelude in base3-compat is ;)
16:31:28 <dcoutts__> Nopik: well, it means base 3, not the prelude
16:31:33 <Nopik> yeah
16:31:47 <Nopik> how to update my code to base 4?
16:31:56 <Nopik> is it easy?
16:32:00 <dcoutts__> Nopik: just select base 4 in your .cabal file
16:32:23 <Nopik> it just says: base, should it be base-4 or somehow different?
16:32:37 <dcoutts__> Nopik: use: build-depends: base >= 4
16:32:43 <kmc> base >= 4 && < 5
16:32:44 <kmc> maybe?
16:32:46 <Nopik> ok, thanks
16:32:55 <dcoutts__> yes, the upper bound is better
16:34:35 <Nopik> thanks, it doesnt complain now
16:34:52 <Nopik> though, it seems that the code is incorrect, i'm getting about 5 type errors
16:36:04 <Nopik> ah, it apparently gets some types from haxml.. probably i have more recent haxml which introduced different types.. nice
16:36:23 <dcoutts__> tromp__: so of my 2.7G of ~/.cabal/lib, about 50% is the lib .a files, 30% .o files and 10% .hi files
16:36:33 <gronkalonk> I must say I dislike the move to LLVM depending on a c++ codebase is like building a house on sand
16:37:10 <Eduard_Munteanu> gronkalonk: it's not using LLVM, not by default
16:37:15 <Lemmih> gronkalonk: I don't think the ncg will be deprecated for quite a while.
16:37:18 <Vanadium> You must be running one of those pure haskell operating systems
16:37:22 <dcoutts__> gronkalonk: ghc does not depend on LLVM, there are two other backends
16:37:41 <Nopik> is there any possibility to 'cabal install haxml' of previous version?
16:37:49 <dcoutts__> tromp__: so if we moved to purely dynamic linking, we'd save about 50%
16:37:59 <dcoutts__> Nopik: sure you can install as many versions as you like
16:38:02 <gronkalonk> Vanadium: I try to minimize my dependance on c++
16:38:07 <Nopik> dcoutts__: i suspect so, but how?
16:38:18 <Nopik> i.e. what is the syntax?
16:38:22 <sproingie> then don't use the LLVM backend
16:38:28 <Eduard_Munteanu> dcoutts__: what's with those .o files?
16:38:36 <dcoutts__> Nopik: see cabal install --help
16:38:37 <Eduard_Munteanu> dcoutts__: or do you mean .so?
16:38:37 <tromp__> ic. dcoutts
16:38:50 <dcoutts__> Eduard_Munteanu: the .o versions of the libs are for GHCi
16:39:00 <Eduard_Munteanu> Oh.
16:39:03 <dcoutts__> Eduard_Munteanu: for each package foo, there is a libHSfoo.a and a HSfoo.o
16:39:07 <Nopik> dcoutts__:  ah, thanks.. plain 'cabal --help' didnt revealed this :)
16:39:17 <gronkalonk> you know from a FSF stance also the llvm project is just a way to reduce our freedoms
16:39:50 <sproingie> gronkalonk: are you going to say anything interesting?
16:40:01 <dcoutts__> gronkalonk: problem is, gcc is a terrible backend for non-C compilers
16:40:05 <EvanR> what dependence on c++ could you possible have
16:40:07 <Eduard_Munteanu> dcoutts__, tromp__: I suspect the savings are more than 50% considering the RTS and some other deps are duplicated more than once.
16:40:13 <dcoutts__> gronkalonk: because it does not expose anything useful for compiler authors
16:40:26 <dcoutts__> Eduard_Munteanu: huh?
16:40:49 <sproingie> dcoutts__: i'm not putting a lot of confidence in gronk's capacity to base his argument on actual technical merit
16:40:50 <Eduard_Munteanu> Like if some libB uses libA, and your program uses libB, then your cabal dir will contain libA thrice.
16:41:20 <dcoutts__> Eduard_Munteanu: it's only the final binaries where static linking means you get copies of things
16:41:20 <Lemmih> Eduard_Munteanu: I don't think so.
16:41:36 <Eduard_Munteanu> Once in that app, once in libB, once in itself as an .a
16:41:52 <dcoutts__> Eduard_Munteanu: no, not that last one
16:42:03 <Eduard_Munteanu> dcoutts__, Lemmih: for a single given app, what you say is true, but the .cabal dir might be a lot bigger.
16:42:18 <gronkalonk> sproingie: I do not need to base my argument on anything other than it being a well established fact that c++ is a horrible language that should have died ages ago
16:42:19 <dcoutts__> Eduard_Munteanu: if foo depends on bar, libHSfoo.a does not contain everything from libHSbar.a
16:42:39 <Eduard_Munteanu> Hm, that's true.
16:42:46 <sproingie> gronkalonk: thank you for proving my point.  gronkalonk is a good name for a troll.
16:42:56 <gronkalonk> ambiguous grammar and a standard that nobody has ever read
16:43:11 <blackdog> gronkalonk: it hardly even matters what language LLVM is written in. if you write code to a reasonably clean API, if the C++ness of it becomes a problem later, a reimplementation is always possible.
16:43:13 <gronkalonk> compiler writers just guess the details
16:43:13 <EvanR> you arent a very good one. try asserting something people have opposing opinions about
16:43:20 <dcoutts__> gronkalonk: while all that is true, and I don't think you'll find many defenders of C++ here, LLVM does provide something very useful
16:43:20 <Eduard_Munteanu> gronkalonk: have you considered a carreer in religion?
16:43:43 <monochrom> freedom is freedom to invent your own programming environment that no one else uses
16:43:44 <Lemmih> Eduard_Munteanu: And because there are relatively few executables, static linking doesn't contribute very much to the disk size.
16:43:47 <Eduard_Munteanu> s/carrer/career/
16:44:07 * ddarius likes C++.
16:44:17 <EvanR> now ddarius is trolling
16:44:22 <dcoutts__> gronkalonk: no doubt LLVM could be better implemented in Haskell :-) but the point is that someone else is doing the work of making portable code generators. If gcc had done that, that'd probably have been better.
16:44:25 <monochrom> \∩/
16:44:32 <Nopik> yeah, downgraded haxml thrice, it went on, now i'm left with only 1 error in the example code :) wish me luck :)
16:45:08 <gronkalonk> now they are even going to use c++ in gcc, setting the compiler practises back several years
16:45:13 <Eduard_Munteanu> Lemmih: hm, that makes sense. Then what's with the big sizes then? I remember a trivial Haskell program with dynamic linking has about 50K, not a lot more.
16:45:28 <ddarius> EvanR: It's a well established fact that I like C++.  Check the logs or my internet history.
16:45:38 <sproingie> gronkalonk: i'm happy this sort of thing is so important to you.  why do you think it's important to us?
16:45:45 <gronkalonk> To write proper software you need to use GNU C with as many extensions as possible enabled for maximum freedom
16:45:48 <EvanR> ddarius: sorry, my feed back is empty ;)
16:45:51 <EvanR> bag
16:45:58 <Lemmih> Eduard_Munteanu: GHC just doesn't try all that hard to generate skinny code.
16:46:13 <sproingie> you could try telling it to use -Os
16:46:16 <gronkalonk> I very much dislike the bsd license on ghc
16:46:28 <hpc> what's so bad about it?
16:46:30 <Eduard_Munteanu> Lemmih, sproingie: I see.
16:46:35 <hpc> bsd is by far the most permissive license
16:46:36 <sproingie> hpc: please don't feed the troll
16:46:47 <Eduard_Munteanu> Well, AFAICT, -O3 is a killer in GCC too.
16:46:51 <dcoutts__> hpc: gronkalonk is taking the piss now, don't worry about it
16:46:53 <EvanR> hpc: not if you want the freedom to take away other peoples freedom
16:46:58 <hpc> oh lol
16:47:01 <Eduard_Munteanu> Especially in C++ code or such.
16:47:01 <hpc> EvanR: hahahahaha
16:47:28 <Eduard_Munteanu> I wonder if the gcc backend does make code slimmer when using -Os as CFLAGS
16:47:38 <sproingie> i've never had -O3 go berzerk and -O2 not
16:48:05 <aristid> gcc -O3 is pretty safe for decent code
16:48:16 <aristid> if your code does terrible things, it might give you problems
16:48:21 <sproingie> well it's the indecent code that makes it go nuts
16:48:22 <Eduard_Munteanu> Ah, not that.
16:48:27 --- mode: ChanServ set +o Lemmih
16:48:28 <Eduard_Munteanu> But compile times do explode a bit.
16:48:35 <hpc> indecent code should make the programmer go nuts first
16:48:40 <Eduard_Munteanu> And filesizes a bit too.
16:48:47 <sproingie> indecent code with ascii art of the programmer's nuts
16:48:53 <gronkalonk> who cares about safety? Do you always wear a rubber when you fuck? Hell no, just set that -O3 and fastmath right on
16:48:55 <hpc> if it gets to the compiler, the problem is between the chair and keyboard
16:49:19 <Eduard_Munteanu> IIRC, performance might hurt, but I'm unsure if it's still the case.
16:49:42 <EvanR> sproingie lol
16:49:47 <Nopik> hm, is it normal that linking phase is veery slow? the 7 example files from RWH compiled in a matter of seconds, but 'cabal build' now got stuck on 'Linking dist/build/pod/pod..' for several minutes (it eats cpu).. and my machine is not overloaded by any other process
16:49:49 <FunctorSalad> @quote -fomit-control-flow
16:49:50 <lambdabot> No quotes match.
16:49:58 <sproingie> -vomit-frame-pointer
16:50:00 <EvanR> Nopik: yes
16:50:03 <Eduard_Munteanu> :)
16:50:09 <Nopik> EvanR:  nice
16:50:13 <EvanR> Nopik: check the memory usage of ld
16:50:18 <hpc> sproingie: is that 'omit' or 'vomit'?
16:50:28 <sproingie> hpc: yes :)
16:50:35 <hpc> :D
16:50:45 <Nopik> ok, it finished now, it was ld indeed... now it thrown me like 500 screens of unresolved references
16:50:58 <Eduard_Munteanu> ld should generally be IO-bound
16:51:16 <sproingie> i learned that the mid-stand exits in a theater and a stadium are called vomitoriums
16:51:17 <Eduard_Munteanu> Perhaps otherwise if using crazy LDFLAGS.
16:51:27 <EvanR> we should probably replace larry david with a real linker
16:53:01 <Nopik> ok, i see the problem now.. in meantime i've switched for ghc 6.12, but it is for i386 on my machine, while gtk libs are linked for x86.. i'll revert back to ghc 6.10, since i have it for x86
16:53:10 <Nopik> x86-64 i mean
16:54:17 <monochrom> combinatorial vomitorium
16:54:19 * Eduard_Munteanu likes the way x86-64 ABI handles debugging, no frame pointers needed.
16:54:21 <Nopik> fortunately i'm getting grip of cabal now ;)
16:54:42 <gronkalonk> oh yeah the cabal documentation sucks
16:54:50 <gronkalonk> no wonder you're progressing slowly
16:55:02 --- mode: ChanServ set +o monochrom
16:55:10 * Veinor vomits frame pointers
16:55:32 --- mode: monochrom set +q *!*@gateway/web/freenode/ip.80.212.75.71
16:55:40 --- mode: monochrom set -o monochrom
16:55:47 --- mode: Lemmih set -o Lemmih
16:56:04 * EvanR blocks veinors attack with a writer barrier
16:56:11 <EvanR> .. a write barrier
16:56:18 * Eduard_Munteanu brings in the DWARF
16:56:26 * monochrom +q's Veinor's vomit, too :)
16:56:38 <hpc> it's too late! the vomit overflows and forms a heap at the bottom of your stack!
16:56:45 <Lemmih> EvanR: Is that related to writer's block?
16:56:51 <monochrom> /mode #haskell +q vomit@veinor!*
16:56:54 <EvanR> no its a typo
16:57:05 <Veinor> oh no!
16:57:38 <EvanR> how do you troll #haskell by insulting c++
16:57:50 <EvanR> people are losing their touch these days
16:57:51 <Veinor> seriously
16:58:07 <Nopik> yeah.. i've managed to run haskell program using gtk ;) i've been trying to do so like 2 weeks ago, but stuck, put it on hold for some time, now i can continue..
16:58:10 <Veinor> hey #haskell, i heard object oriented programming sucks!
16:58:11 <hpc> EvanR: it's a rite of passage; surmount the most difficult of trolling challenges to become one of them
16:58:21 <EvanR> lol
16:58:32 <hpc> there's a ceremonial fire and everything
16:58:35 <blackdog> Veinor: we're too used to being pathologically fair:)
16:58:36 <monochrom> i heard aop takes away your freedom
16:58:37 <Eduard_Munteanu> It's a puzzle to me why #haskell is such a popular channel. Moreso for trolls.
16:59:02 <monochrom> no, I think #math is even more popular for trolls
16:59:08 <EvanR> the trolls are a by product of failing to avoid success
16:59:14 <hpc> how do you troll #math?
16:59:23 <monochrom> I have long forgotten
16:59:28 <hpc> "so what is a math major useful for, anyway?"
16:59:30 <EvanR> ive been here for about a year and i havent seen many
16:59:40 <Eduard_Munteanu> hpc: mostly you ask them about categories and monads in Haskell :P
16:59:41 <monochrom> maybe you can bring up the recent P/=NP paper in #math
16:59:49 <hpc> haha
16:59:55 <Eduard_Munteanu> hpc: it seems very annoying for some people in there :)
16:59:57 <Veinor> hpc: 'i can divide by zero, look!'
17:00:09 <EvanR> > 0/0
17:00:10 <lambdabot>   NaN
17:00:13 <hpc> 0.999999 != 1
17:00:14 <Veinor> or 'prove' that 1 != 0.9999999
17:00:16 <Veinor> yeah
17:00:26 <hpc> or the airplane never takes off
17:00:36 <hpc> though that's probably more physics trolling
17:00:40 <Veinor> yeah
17:01:03 <hpc> (related: it is nice to be on a channel where people agree about all these things)
17:01:08 <EvanR> physics trolling consists mainly of paranormal phenomena, ufos, free energy, and conspiracy theory
17:01:08 <monochrom> let's troll shapr so his wifi bill skyrockets
17:01:10 <Veinor> http://static.funnyjunk.com/pictures/62740b45_3540_b7ff0.jpg insist that this works
17:01:48 <hpc> Veinor: or this: http://themavesite.com/TMS-Pictures/2010-07/InfinitePower.jpg
17:02:15 <Veinor> ... is that light on?
17:02:24 <Eduard_Munteanu> Heh.
17:02:26 <hpc> ... wtf
17:02:38 <Nopik> hehe ;)
17:02:41 <Eduard_Munteanu> Junk science can be fun.
17:02:44 <hpc> it looks like glare
17:02:44 <monochrom> > cycle ["infinite power! "]
17:02:45 <lambdabot>   ["infinite power! ","infinite power! ","infinite power! ","infinite power! ...
17:02:47 <alex404_> What's the deal with the new mtl 2.0? How do I declare a function to be of the State monad? It doesn't appear to export the State constructor...
17:02:56 <monochrom> > cycle "infinite power! "
17:02:56 <lambdabot>   "infinite power! infinite power! infinite power! infinite power! infinite p...
17:02:57 <Eduard_Munteanu> hpc: :))
17:03:24 <hpc> alex404_: you can't write what you want through the interface?
17:03:39 <Veinor> http://i56.tinypic.com/2z65itz.jpg
17:03:50 <monochrom> don't you just import Control.Monad.State ?
17:03:54 <hpc> it's also fun to show people how to accelerate in a vacuum
17:03:59 <hpc> because that one works
17:04:02 <EvanR> > fix ("2^"++)
17:04:03 <lambdabot>   "2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^2^...
17:04:14 <alex404_> hpc: I guess I can, I'm just scratching my head about how to do it. It's probably simple...
17:04:16 <hpc> it involves "swimming" through gravitational fields
17:04:45 <EvanR> hpc: theres the electromagnetic microwave cavity drive, funded by the british government
17:04:49 <alex404_> I think you should talk to NASA about your techniques.
17:04:49 <Eduard_Munteanu> Actually superconductive rings work a bit like that.
17:04:56 <Eduard_Munteanu> Except you can't extract something for free.
17:05:02 <Nopik> bye all
17:05:03 <monochrom> I see, "type State s = StateT s Identity". use the StateT constructor instead
17:05:24 <monochrom> http://hackage.haskell.org/packages/archive/mtl/2.0.0.0/doc/html/Control-Monad-State-Lazy.html#t:StateT
17:06:22 <hpc> Veinor: love that image
17:07:23 <Veinor> EvanR: fix (2^) = -W_n(log 2)/(log 2)
17:07:48 <Entroacceptor> EvanR: fix ("6^"++) 
17:07:57 <Entroacceptor> don't you read Heinlein...
17:08:15 <Veinor> hm, apparently 2^x is not equal to x for any real x
17:08:17 <EvanR> no, i just checked out my first pile of fiction books the other day
17:08:54 <Veinor> but clearly 1^x = x has a solution. so what's the largest z such that z^x=x has a real solution?
17:09:02 <hpc> Veinor: y^x ==x iff y <= 1
17:09:15 <hpc> er, s/==/can equal/
17:09:43 <Veinor> > 1.1^1.12452
17:09:44 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:09:44 <lambdabot>    `GHC.Real.Fractional t'
17:09:44 <lambdabot> ...
17:09:49 <Veinor> > 1.1^1.12452 :: Float
17:09:50 <lambdabot>   Ambiguous type variable `t' in the constraints:
17:09:50 <lambdabot>    `GHC.Real.Fractional t'
17:09:50 <lambdabot> ...
17:09:53 <EvanR> > pow 3 5
17:09:54 <lambdabot>   Not in scope: `pow'
17:09:55 <Veinor> > 1.1**1.12452 :: Float
17:09:56 <lambdabot>   1.1131326
17:10:02 <Veinor> > 1.11**1.12452 :: Float
17:10:03 <lambdabot>   1.1245185
17:10:08 <alex404_> monochrom: So they've exported things in such I way that I can use the type name in my signatures, but I can't access its constructor? Because I can use 'State s' in my signatures...
17:10:10 <Veinor> :P
17:10:46 <monochrom> State is now just a type synonym.
17:10:48 <Eduard_Munteanu> alex404_: it's a type synonym, so no
17:10:57 <Eduard_Munteanu> unless you use StateT's constructor
17:10:59 <monochrom> there is nothing to export.
17:11:24 <alex404_> So before it would have been declared with a newtype or something?
17:11:31 <monochrom> I think you are underestimating the fact that mtl 2.0 is a clean break from mtl 1.*
17:11:41 <alex404_> Indeed
17:11:52 <Veinor> experimentation suggests that the critical value is around 1.44
17:12:11 <sipa> > fix (2^)
17:12:14 <lambdabot>   mueval-core: Time limit exceeded
17:12:24 <monochrom> in the same way that haskell is a clean break from python
17:12:25 <alex404_> Right, it was with a newtype...
17:12:39 <Veinor> 1.4446 or so
17:12:40 <alex404_> How about I google my own questions...
17:12:45 <sipa> isn't haskell older than python?
17:13:22 <EvanR> Veinor: you can solve it using derivatives
17:13:23 * Eduard_Munteanu wonders if Haskell even looked similar in those days.
17:13:24 <danderson> sipa: 1 year older according to wikipedia
17:13:26 <monochrom> so certain questions like "where is the State constructor" and "where is the metaclass" are devoid of semantics to begin with.
17:13:36 <danderson> (haskell "appeared in" 1990, python in 1991
17:13:38 <EvanR> Veinor: at least you can give an equation whos solution is what you want
17:13:57 <alex404_> monochrom: What do you mean?
17:14:16 <alex404_> What's wrong with asking where the State constructor is?
17:14:26 <sipa> danderson: wow, didn't know python was that old - i think i only heard about it around 1999
17:14:30 <EvanR> miranda vs modula3 go
17:14:37 <sipa> then again, i only heard about haskell in 2004 :$
17:14:40 <EvanR> also, ubuntu vs slackware go
17:14:43 <Eduard_Munteanu> alex404_: "State constructor" must exist to begin with
17:14:52 <Eduard_Munteanu> And must be a coherent thing.
17:15:03 <Eduard_Munteanu> That can't happen if State is a type synonym.
17:15:12 <alex404_> Eduard_Munteanu: Oh indeed. I do understand that much.
17:15:16 <Veinor> EvanR: it's e^1/e
17:15:20 <EvanR> alex404_: you shouldnt be asking for constructors of abstract data types, for your own safety
17:15:21 <danderson> sipa: python had a shorter creation-to-hype time
17:15:36 <danderson> haskell avoided success for quite a while
17:15:38 <blackdog> hey, what's that software for getting a reasonable unix env on windows?
17:15:44 <blackdog> hamish was talking about it... blastoff or something?
17:15:44 <Veinor> ssh?
17:15:45 <danderson> blackdog: cygwin?
17:15:46 <Veinor> :P
17:15:46 <dschoepe> blackdog: cygwin?
17:15:49 <mauke> putty
17:15:51 <blackdog> no, not cygwin
17:15:54 <mauke> mingw
17:15:54 <megajosh2> Are the packages that start with dph- in hackage?
17:15:55 <blackdog> cygwin is painful
17:16:00 <EvanR> msys
17:16:00 <Eduard_Munteanu> mingw/msys
17:16:02 <alex404_> EvanR: What do you mean? (I'm feeling a bit dumb asking that over and over)
17:16:03 <megajosh2> According to ghc-pkg --lsit they're all broken
17:16:05 <megajosh2> *list
17:16:15 <megajosh2> I can't find them there anyway
17:16:19 <EvanR> alex404_: you dont want the raw constructor, even if it existed
17:16:26 <EvanR> use >>= and return
17:17:47 <alex404_> EvanR: But if I want to get haskell to treat my 'do' series as a State monad, don't I have to wrap the relavent functions in the constructor? Otherwise it will just interpret them as being of the (->) monad
17:17:48 <Eduard_Munteanu> Normally they shouldn't be exported.
17:17:59 <EvanR> alex404_: no
17:18:04 <Eduard_Munteanu> alex404_: runState
17:18:15 <Eduard_Munteanu> :t runState
17:18:15 <lambdabot> forall s a. State s a -> s -> (a, s)
17:18:16 <EvanR> alex404_: each element of the do (>>= sugar) is already a State something
17:18:26 <monochrom> x :: State () (); x = get >>= put
17:18:49 <EvanR> you use runState on THAT to use the action
17:19:24 <monochrom> I haven't heard of a defaulting mechanism for monad.
17:19:29 <alex404_> Okay, I'm sorry I'm being dense... but in the list monad, I the x in x >>= fun has to be of type list
17:19:34 <ksf> did I lately read something (I think linked from the haskell reddit) about a statically typed but interpreted scripting language, or have I been dreaming?
17:20:06 <alex404_> For a list to be a list it has to be construct with : or []
17:20:06 <EvanR> alex404_: yes, list isnt abstract
17:20:10 <EvanR> alex404_: no
17:20:12 <Eduard_Munteanu> alex404_: well the list monad it's safe to use it.
17:20:14 <monochrom> haskell is a statically typed interpreted scripting language, courtesy of hugs
17:20:19 <Eduard_Munteanu> alex404_: although you could pack it with a return.
17:20:29 <alex404_> Eduard_Munteanu: Ooooohhhh...
17:20:47 <EvanR> alex404_: you could also generate a list with something like map, tails, zip, etc
17:20:50 <alex404_> The lightbulb isn't on yet... but I've found the switch I think
17:20:51 <Eduard_Munteanu> > return 5 :: [Int]
17:20:51 <lambdabot>   [5]
17:21:02 <EvanR> or return
17:21:19 <EvanR> > return 5 :: State Bool Int
17:21:20 <lambdabot>   No instance for (GHC.Show.Show
17:21:20 <lambdabot>                     (Control.Monad.State.Laz...
17:21:38 <EvanR> :t return 5 :: State Bool Int
17:21:39 <lambdabot> State Bool Int
17:21:59 <monochrom> is powershell statically typed?
17:22:48 <monochrom> anyway wouldn't it be nice if reddit kept your browsing history
17:22:55 <alex404_> So, the point is to just keep things entirely abstract, and let the type system to the inference
17:23:12 <alex404_> I suppose that's just good style
17:23:15 <EvanR> in the case of return, fromIntegral, read, etc, yes
17:23:18 <EvanR> :t read
17:23:19 <lambdabot> forall a. (Read a) => String -> a
17:23:22 <EvanR> :t fromIntegral
17:23:22 <lambdabot> forall a b. (Integral a, Num b) => a -> b
17:23:33 <EvanR> :t return
17:23:34 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:23:37 <Eduard_Munteanu> alex404_: that usually doesn't apply to function sigs
17:23:53 <Eduard_Munteanu> alex404_: it's a good idea to spell them out usually
17:24:04 <EvanR> put sigs at the top level
17:24:06 <alex404_> Eduard_Munteanu: Well I would stick 'State foo bar' in my sig, yah?
17:24:17 <EvanR> if its a top level action
17:24:22 <alex404_> Idneed
17:24:25 <Eduard_Munteanu> alex404_: the _type_ constructor is there.
17:24:45 <Eduard_Munteanu> Even if the data constructor is missing.
17:24:47 <EvanR> blowAwayMyState :: State (Maybe a) ()
17:25:04 <EvanR> = put Nothing
17:25:20 <ksf> isn't hugs dead?
17:25:35 <alex404_> Heh
17:25:36 <ksf> latest release is 2006
17:25:38 <alex404_> That's cute
17:25:42 <monochrom> hugs is dead but still usable
17:25:53 <ksf> yeah, but with h' that's going to change
17:26:05 <Eduard_Munteanu> Awww... I remember installing WinHugs to play with it on a Windows box.
17:26:30 <ksf> an implementation that could compete with lua in terms of embeddability would be really nice, though.
17:26:33 <monochrom> change to: haskell98 is a statically typed interpreted scripting language, courtesy of hugs
17:26:38 <tele> State constructor is not exported to destinguish functions with states from functions witout states
17:27:33 <alex404_> So, what makes State an abstract data type vs Lists being concrete?
17:27:45 <EvanR> you can use list the two list constructors
17:28:17 <EvanR> if state had constructors that were not exported, youd be forced to use the monad a certain way
17:28:21 <EvanR> with get and put
17:28:43 <alex404_> So whereas I can play with lists directly
17:28:52 <Eduard_Munteanu> That probably should've been the case, isn't it?
17:28:53 <alex404_> I can only interface with StateT through some other construction?
17:28:59 <monochrom> @quote monochrom premature
17:28:59 <lambdabot> monochrom says: premature generality is the root of OOP
17:29:13 <alex404_> That's awesome.
17:29:17 <Eduard_Munteanu> Heh.
17:29:57 <tele> how to add support for completion in emacs?
17:29:59 <EvanR> alex404_: StateT eh, now youre getting crazy ;)
17:30:31 <Eduard_Munteanu> EvanR: he means StateT a Identity
17:30:45 <alex404_> EvanR: Indeed. All this terminology is making my brain mushy
17:30:51 <EvanR> State
17:30:55 <EvanR> MonadState
17:31:02 <EvanR> RWS IO
17:31:07 <alex404_> But is the distinction I laid out the right one for concrete vs abstract?
17:31:09 <Eduard_Munteanu> RWS?
17:31:26 <EvanR> ReaderT + WriterT + StateT
17:31:32 <Eduard_Munteanu> Ah.
17:31:40 <EvanR> for maximum insanity
17:31:46 <EvanR> without using ContT
17:31:56 <monochrom> not maximum until you add Error
17:32:23 <Eduard_Munteanu> if you put a distributivity law on top, perhaps you can stack in a few comonad transformers there (they exist?) :P
17:32:25 <monochrom> and there are probably 4 different ways to add Error
17:32:26 <EvanR> build your own php in 24 hours
17:32:29 <tele> alex204_, do you use IO?
17:32:44 <alex404_> What the hell. RWS. ContT monad I just saw for the first time the other day. Is it possible to know haskell or does it just go on forever?
17:33:00 <EvanR> alex404_: how deep does the MonadFix go?
17:33:09 <Eduard_Munteanu> alex404_: Haskell is a bit like 'fix'
17:33:45 <monochrom> it is possible to know haskell. only the libs go on forever.
17:33:55 <monochrom> RWS is just another lib.
17:34:09 <hpc> the haskell libs become the language, to a certain extent
17:34:16 * Eduard_Munteanu wonders how Haskell98 compares to C99 in length.
17:34:22 <FunctorSalad> EvanR: actually I find RWS a lot less confusing than stacking the others guys, even two of them
17:34:33 <FunctorSalad> @unmtl RWS r w s a
17:34:33 <lambdabot> r -> s -> (a, s, w)
17:35:06 <EvanR> yes using one monad rather than transformers is usually less confusing
17:35:12 <EvanR> if youre going to implement them
17:35:26 <Eduard_Munteanu> Oh, RWS is a real thingy.
17:35:38 <Eduard_Munteanu> Not just a synonym for doing it yourself.
17:35:40 <hpc> RWS = Read, Write, State monad?
17:35:45 <FunctorSalad> :)
17:35:46 <Eduard_Munteanu> yeah
17:35:50 <hpc> nifty
17:36:25 <EvanR> RWS IO and you turned haskell into a full featured imperative language
17:36:32 <Eduard_Munteanu> Well, I suppose you can do some of that stuff using only IO.
17:36:48 <Eduard_Munteanu> or ST.
17:36:49 <EvanR> RWST
17:36:51 <FunctorSalad> all of it?
17:36:58 <FunctorSalad> using IORefs
17:37:03 <FunctorSalad> but that's not so pretty
17:37:06 <Eduard_Munteanu> I guess so, didn't want to be wrong.
17:37:11 <hpc> RWCELST ;)
17:37:11 <Eduard_Munteanu> Or STRefs.
17:37:19 <hpc> see how many monads you can shove in an acronym
17:37:33 <EvanR> its turning into super friends
17:37:34 <FunctorSalad> LS=lazy state?
17:37:38 <Eduard_Munteanu> :))
17:37:40 <FunctorSalad> you forgot identity
17:37:40 <hpc> L = List
17:37:41 <FunctorSalad> ;)
17:37:46 <hpc> FunctorSalad: crap!
17:37:51 <EvanR> our favorite heros under one roof!
17:37:56 <hpc> i also forgot Maybe
17:38:03 <FunctorSalad> and STM :D
17:38:09 <hpc> and Parsec
17:38:18 <FunctorSalad> that monad will be UNSTOPPABLE
17:38:19 <hpc> and IO
17:38:43 <hpc> it will be the /only/ monad
17:38:45 <EvanR> TartusT
17:38:45 <monochrom> hi, what are monads?
17:38:50 <EvanR> er Tardis
17:38:57 <FunctorSalad> (because your system will be swapping too much to kill the process)
17:39:05 <Eduard_Munteanu> monochrom: burritos :P
17:39:16 <hpc> FunctorSalad: i cannot stop laughing
17:39:21 <monochrom> is burritos greek?
17:39:32 <EvanR> monads are like metaphors
17:39:32 <Eduard_Munteanu> I think mexican :/
17:39:46 <hpc> EvanR: do not mix them?
17:39:53 <Eduard_Munteanu> And monad transformers are burritos in spacesuits :P
17:39:53 <EvanR> haha
17:40:14 <EvanR> burritos which can morph into enchiladas
17:40:57 <aristid> burritos are remarkably popular here
17:41:00 <Entroacceptor> aarrrg
17:41:06 <Entroacceptor> stop talking about those again
17:41:22 <monochrom> hi, what is a thunk?
17:41:22 <EvanR> the burrito meme will never die
17:41:25 <Entroacceptor> our local Burrito guy knows me by name already
17:41:38 <aristid> Entroacceptor: because you always talk about monads to him?
17:41:45 <Entroacceptor> no, I keep that to myself
17:41:48 <Entroacceptor> sadly
17:42:04 <aristid> Entroacceptor: maybe he could explain it to you. after all, he IS the burrito guy
17:42:09 <Entroacceptor> :)
17:42:11 <monochrom> haha
17:42:16 <hpc> "you got monads in my peanut butter!" "you got peanut butter in my monads!"
17:42:30 <Eduard_Munteanu> I'd really like my burritos to duplicate.
17:42:41 <FunctorSalad> as in the comonad method?
17:42:45 <Eduard_Munteanu> Yes.
17:42:45 <EvanR> get your monads outta the ground beef
17:42:50 <aristid> i want to take a burrito in a burrito and make a burrito out of it
17:42:52 <monochrom> use the Banach-Tarski theorem
17:42:58 <Eduard_Munteanu> :)
17:43:07 * ksf wants an expert system for programming languages (and for data structures, but that's another topic)
17:43:11 <Eduard_Munteanu> monochrom: that advice is not constructive :P
17:43:12 <Entroacceptor> monochrom: that doesn't work on burritos
17:43:15 <Entroacceptor> wrong topology
17:43:17 <Entroacceptor> I've tried
17:43:19 <aristid> Eduard_Munteanu: haha
17:43:32 <Entroacceptor> bwahaha
17:44:05 <EvanR> banach-tarski broke geometry
17:44:14 <alex404_> I don't think I've ever seen nerdier jokes than in here.
17:44:16 <aristid> does it work with donuts?
17:44:36 <Entroacceptor> alex404_: find a local RPG group...
17:44:38 <FunctorSalad> EvanR: it broke the credibility of arbitrary subsets of R maybe
17:44:44 <monochrom> what does an expert system for programming languages do? "do you want memory leaks?" yes. "do you want segfaults?" yes. "do you want to feel superior?" yes. "x86 assembly." \∩/
17:44:53 <FunctorSalad> borel measurable sets came to the rescue.
17:45:10 <EvanR> R is broke
17:45:19 <EvanR> not subsets
17:45:26 <EvanR> i like subsets
17:45:49 <FunctorSalad> come on not the constructivist tirade about 'oh noes I can't construct all the elements' again
17:45:50 <aristid> EvanR: subsets are evil.
17:45:52 <FunctorSalad> :D
17:45:57 <monochrom> is "local RPG group" some kind of topological group?
17:46:02 <Eduard_Munteanu> :))
17:46:16 <aristid> monochrom: it's just a set of donuts
17:46:20 <ksf> asm is a nice language, iff you have a nice macro system (at least turing complete) and a decent debugger.
17:46:35 <EvanR> asm monad
17:46:37 <Eduard_Munteanu> ksf: uh, that's C.
17:46:40 <aristid> Eduard_Munteanu: no
17:46:43 <hpc> haha
17:46:46 <FunctorSalad> 'tis better to have a category with some pathological elements but good properties as a whole, said the wise man ;)
17:46:46 <aristid> C has no turing complete macro system
17:46:47 <caelan> ksf: greenspun's tenth rule much?
17:46:57 <hpc> aristid: C is the macro system for asm
17:46:58 <Eduard_Munteanu> aristid: I mean that macro system would be C :)
17:47:00 <sipa> aristid: it is if you run it repeatedly
17:47:00 <ksf> well no I didn't write a lisp back then.
17:47:22 <sipa> Eduard_Munteanu: even them - you can not have the compiler do turing-complete things
17:47:33 <sipa> *then
17:47:34 <hpc> sipa: sure you can!
17:47:35 <Eduard_Munteanu> sipa: um, yeah, that's right.
17:47:36 <ksf> but I _did_ do implement fully-featured functions (with parameters and locals and everything) and ifs in nasm.
17:47:37 <hpc> see perl
17:47:48 <sipa> hpc: ?
17:47:49 <aristid> hpc: C is not perl
17:47:51 <Eduard_Munteanu> sipa: although isn't recursive include turing complete?
17:47:51 <mauke> hpc: I'd like to see you run your C programs with perl
17:47:57 <ksf> cmp eax, 0 ; %if ge ...
17:48:06 <lars9> cabal says "Future GHC versions will not support base version 3.x. You should update your code to use the new base version 4.x."
17:48:18 <lars9> but my ghc is already latest...
17:48:24 <sipa> Eduard_Munteanu: no, you need successive runs (till reaching a fixpoint) of the C preprocessor to get turing completeness
17:48:25 <FunctorSalad> lars9: the future is here, in fact
17:48:30 <FunctorSalad> ghc 7 had no base 3
17:48:33 <FunctorSalad> *has
17:48:57 <FunctorSalad> lars9: it's not that your ghc is too old. you need to set your cabal build-deps to "base >= 4"
17:49:09 <lars9> FunctorSalad: let me try
17:49:11 <FunctorSalad> otherwise it sometimes defaults to 3
17:49:30 <monochrom> fun fact: if you say "base >= 3", you get base 4 too
17:49:40 <mauke> para-related: http://mauke.ath.cx/stuff/haskell/yes.hs
17:49:41 <sipa> fun fact: 4 >= 3!
17:49:51 <Cale> FUN!
17:49:59 <EvanR> > product [1..3]
17:50:00 <lambdabot>   6
17:50:05 <EvanR> > 4 >= 6
17:50:06 <lambdabot>   False
17:50:22 <sipa> i knew someone would interpret my exclamation mark as a factorial
17:50:26 <monochrom> 3.99999...
17:50:49 <sipa> 3.999999... equals 4 ;)
17:51:03 <monochrom> fun fact: 0!=1 is correct, both parsings
17:51:14 <hpc> mauke: what on earth have you done?
17:51:21 <mauke> YES
17:51:26 <FunctorSalad> mauke: is that supposed to work as ghc input?
17:51:33 <mauke> FunctorSalad: sure
17:51:38 <hpc> FunctorSalad: ghc, perl, and gcc
17:51:45 <hpc> and that's just what i can decypher
17:51:45 <geheimdienst> i guess it's one of those programs that work in multiple languages
17:51:57 <Eduard_Munteanu> It does.
17:52:18 <hpc> what's the language at the very top?
17:52:27 <Eduard_Munteanu> Note the {- and -} and where they close
17:52:28 <mauke> C
17:52:30 <FunctorSalad> mauke: looks like an illegal @-pattern in line 1-2
17:52:44 <FunctorSalad> ah or maybe it's all part of one token
17:52:44 <mauke> you mean the operator?
17:53:15 <Eduard_Munteanu> AFAICT only 'main = putStr (cycle "y\n");' escapes preprocessing.
17:53:58 <mauke> the Perl interpretation is the most interesting part IMO
17:54:01 <Eduard_Munteanu> Although the first line makes me wonder.
17:54:21 <geheimdienst> what does "int(//+$@" mean in haskell anyway?
17:54:33 <FunctorSalad> it continues on the next line
17:54:48 <megajosh2> Good lord what is that monstrosity?
17:55:03 <geheimdienst> so "int(...)" is the name of the variable?
17:55:12 <mauke> no, int is the name of the function
17:55:35 <monochrom> > let int (//+$@ ) = 0 in int ()
17:55:36 <lambdabot>   0
17:55:47 <geheimdienst> oh i see. a function "int" with a parameter gobbledegook
17:55:53 <hpc> wow
17:55:56 <geheimdienst> nice
17:56:08 <megajosh2> ...what
17:56:21 <monochrom> > let f (b@ ) = 0 in f ()
17:56:22 <lambdabot>   <no location info>: parse error on input `)'
17:56:47 <Eduard_Munteanu> Oh, makes perfect sense now.
17:57:21 <EvanR> so this program won the obfuscated C, haskell, and perl contests simultaneously
17:57:28 <EvanR> impressive
17:57:43 <sipa> loi
17:57:45 <monochrom> haha
17:57:53 <Draconx> EvanR, dunno about the obfuscated haskell and perl contests, but the obfuscated C contest has much higher standards :P
17:58:28 <sipa> i know perl, haskell and C, but this is horrible!
17:58:29 <Draconx> considering that the program becomes trivial after comments are replaced with whitespace.
17:58:33 <monochrom> I see, the whole name is //+$@, the @ there is not considered reserved.
17:58:37 <Draconx> (when considered as C)
17:58:39 <Eduard_Munteanu> Well if mauke shapes it into a plane or something, perhaps he wins IOCCC too
17:58:53 <monochrom> > let int (//+$@ ) = (//+$@) + 4 in int 3
17:58:54 <lambdabot>   7
17:58:56 <mauke> yeah, the C was an afterthought
17:58:58 <hpc> Eduard_Munteanu: good luck getting haskell to accept it like that
17:59:02 <geheimdienst> > let f (/@) = 0 in f ()
17:59:03 <lambdabot>   0
17:59:27 * sipa thinks all languages should support definition of arbitrary operators :)
17:59:41 <Eduard_Munteanu> hpc: it's most likely possible, there's only about 2 lines of real Haskell code.
17:59:41 <hpc> ^
17:59:49 <hpc> Eduard_Munteanu: ah, true
18:00:10 <Draconx> as an aside, this is my favourite polyglot: http://paste.pocoo.org/show/285807/
18:00:30 <Draconx> (literate haskell is in there)
18:00:37 <mauke> Draconx: http://mauke.ath.cx/stuff/poly.poly
18:00:40 <mauke> surprise!
18:01:18 <hpc> Draconx: good god
18:01:35 <Draconx> mauke, hehe.
18:01:36 <Eduard_Munteanu> Win additional points if you make that a quine :P
18:01:51 <monochrom> gosh, it even contains javascript for web browsers
18:01:55 <mauke> Draconx: looks like you have an older version
18:02:23 <EvanR> mauke is in ur filez, being the author
18:02:37 <Draconx> mauke, not surprising :P
18:03:17 <monochrom> I would like it to lie, e.g., the haskell part says "I'm C", the C part says "I'm javascript", the javascript part says "I'm Haskell", etc. Permutation.
18:03:20 <hpc> http://blog.sigfpe.com/2008/02/third-order-quine-in-three-languages.html
18:03:30 * geheimdienst will start working on a program that not only passes through 20 compilers but also makes sense to a human
18:03:44 <EvanR> lol "I'm a Makefile"
18:03:55 <mauke> geheimdienst: see poly.poly :-)
18:04:07 <mauke> unless you don't count me as human. hmm
18:04:21 <Eduard_Munteanu> hpc: whoa
18:04:25 <monochrom> don't worry, you are not alone, I am not a human either.
18:04:29 <monochrom> \∩/
18:04:49 <mauke> http://mauke.ath.cx/stuff/c/quine.c - a boring quine
18:05:01 <mauke> http://www.ioccc.org/2000/dhyang.c - an awesome quine
18:05:03 <EvanR> @faq are you a bot?
18:05:03 <lambdabot> The answer is: Yes! Haskell can do that.
18:05:33 <sciolizer> FFI help? http://hpaste.org/41116/problems_with_building_ffi_lib
18:05:35 <hpc> http://forums.thedailywtf.com/forums/t/7942.aspx
18:05:41 <hpc> http://forums.thedailywtf.com/forums/t/10689.aspx
18:06:05 <hpc> one is a basic program that is the same output if all the lines are shuffled
18:06:15 <hpc> and further down the second is a perl program that transposes a file
18:06:30 <hpc> if you transpose itself, it produces a different perl program that does the same thing
18:06:49 <FunctorSalad> mauke: don't tell me that latter one was handwritten
18:07:13 <sipa> sciolizer: compile the C code with -c
18:07:27 <sipa> to produce a .o file instead of a complete binary
18:07:50 <mauke> sciolizer: hmm, does ghc prog.c work?
18:08:06 <sciolizer> sipa: Thanks. First it said "GCC does not support -C or -CC without -E"
18:08:21 <sciolizer> sipa: so I added an -E, and it dumped out a lot of text.
18:08:21 <mauke> sciolizer: -c, not -C
18:08:27 <sipa> sciolizer: -c is very different from -C
18:08:28 <sciolizer> oops
18:08:33 <mauke> but I don't see how -c is useful here
18:08:47 <sciolizer> sipa, mauke: ok, now I've got a prog.o with no errors.
18:08:51 <monochrom> I think sipa has another card to play
18:09:04 <sciolizer> sipa, mauke: I'm a gcc n00b. How do I make an executable out of that?
18:09:16 <mauke> sciolizer: have you tried my suggestion?
18:09:41 <sciolizer> mauke: yes. prog.c:5:22:  error: foo_stub.h: No such file or directory
18:09:48 <sipa> actually, i'm using the FFI myself, and let cabal take care of verything
18:10:06 <monochrom> heh
18:10:13 <monochrom> that's the trump card :)
18:10:35 <sipa> sciolizer: anyway, the -c means: just compile this module
18:10:51 <sipa> without -c it will link everything together to be a binary
18:11:01 <mauke> he wants a binary
18:11:03 <sipa> but i think you can pass .o files as input to ghc as well
18:11:13 <sipa> so you compile it using gcc as you just did
18:11:36 <sipa> and then ghc Foo.hs prog.o
18:12:02 <sipa> oh, you'll call gcc with "-c -o prog.o" 
18:12:12 <mauke> -o prog.o is optional
18:12:22 <sipa> by default it will create a.out, no?
18:12:25 <mauke> no
18:12:31 <sipa> or not when just compiling a single module
18:12:40 <sciolizer> sipa, mauke: yeah, still no binary
18:12:49 <sipa> sciolizer: how do you mean?
18:12:51 <mauke> sciolizer: what's the error?
18:13:04 <sipa> sciolizer: you have Foo.hs and prog.o ?
18:13:07 <sciolizer> prog.c:(.text+0x36): undefined reference to `foo' <--- when I run ghc Foo.hs prog.o
18:13:23 <sciolizer> sipa, mauke: yeah, I have Foo.hs and prog.o
18:13:59 <sciolizer> sipa, mauke: keep in mind that prog.c is the one with main, and it calls into Foo.hs, so this might be a little different from the normal build process
18:14:34 <mauke> I've done this kind of thing before but I'm too lazy to look up the manual
18:14:56 <sciolizer> mauke: my programs are straight out of the manual. It just doesn't tell me which commands to run to build. :)
18:15:50 <sipa> sciolizer: ok, just try it the other way around? ghc Foo.hs -c -o Foo.o
18:16:00 <sipa> sciolizer: and gcc Foo.o main.c -o main
18:16:21 <sipa> so now we'll let gcc do the linking
18:16:40 <mauke>  NOTE: when linking the final program, it is normally easiest to do the link using GHC, although this isn't essential. If you do use GHC, then don't forget the flag -no-hs-main, otherwise GHC will try to link to the Main Haskell module.
18:16:41 <Eduard_Munteanu> sipa: that happens when doing all the steps including linking, I'm unsure about '-c'
18:16:54 <Eduard_Munteanu> (this refers to the lack of '-o')
18:17:12 <monochrom> sciolizer: ghc -c Foo.hs; ghc Foo.o Foo_stub.o prog.c -o prog.exe
18:17:17 <sipa> sciolizer: ok, try what mauke said, there's you problem :)
18:17:20 <ksf> crazy idea #10: jit-compile haskell to luajit.
18:17:55 <sciolizer> sipa: the ghc part works, the gcc part gives me lots of undefined references, to things like stg_upd_frame_info, stg_INTLIKE_closure, base_GHCziIOBase_zdf25_closure, etc.
18:17:58 <Eduard_Munteanu> It'd be great if Haskell could be JITed.
18:18:08 <sipa> sciolizer: gcc -c main.c -o main.o; ghc -no-hs-main main.o Foo.hs -o Foo
18:18:45 <mauke> listen to monochrom, he looks like he knows what he's doing
18:19:22 <monochrom> actually I don't like that. I now like this better: ghc -no-hs-main Foo.hs prog.c
18:19:56 <monochrom> (I forgot -o prog.exe)
18:20:08 <sciolizer> monochrom: foo_stub.h: no such file or directory (upper/lower case problem?)
18:20:13 <Eduard_Munteanu> Although I'm not really sure how Haskell fares with portability in many respects; probably won't outdo Java in those respects.
18:20:24 <monochrom> Yes, Foo_stub.h
18:21:19 <sipa> sciolizer: or just in one go "ghc -no-hs-main main.o Foo.hs -o Foo" ?
18:21:23 <sipa> oh
18:21:30 <sipa> ghc -no-hs-main main.c Foo.hs -o Foo
18:22:04 <Eduard_Munteanu> It'd also need lots of sanctioned libs, which just won't fly in case of GUIs and such.
18:22:26 * Eduard_Munteanu stops ranting :)
18:22:50 <EvanR> why are we comparing portability of ghc and java ;)
18:23:05 <EvanR> there are more portable systems than java
18:23:16 <Eduard_Munteanu> EvanR: eh, ksf brought up an idea I've been pondering upon.
18:23:22 <EvanR> oh right
18:23:40 <EvanR> i know, a haskell gui
18:23:43 <EvanR> like java
18:23:44 <monochrom> using cabal is superior
18:23:49 <ksf> hugs beats java, lua beats hugs, luajit beats lua.
18:24:03 <ksf> oh, and every js engine out there, too.
18:24:15 <Eduard_Munteanu> EvanR: possibly, but probably not as ubiquitous.
18:24:25 <sciolizer> hooray, it works! (Monochrom's solution)
18:24:28 <EvanR> probably is right
18:24:32 <EvanR> since it doesnt exist
18:24:35 <sciolizer> Thank you so much.
18:24:39 <EvanR> its basically the opposite of ubiquitous
18:26:13 <mwc> 2
18:26:45 <sciolizer> Now I can go to Erik Meijer's talk at Bahug!
18:27:09 <ksf> heck luajit beats the crap out of ghc, at least according to the shootout.
18:27:38 <ksf> http://shootout.alioth.debian.org/u32/benchmark.php?test=all&lang=ghc&lang2=luajit
18:27:53 <Eduard_Munteanu> Actually, I'd be happy even with AOT compiling from bytecode.
18:27:58 <ksf> well... k-nucleotide.
18:28:05 <Eduard_Munteanu> As long as it's integrated nicely and it's fast.
18:28:10 <ksf> can't beat languages which come with built-in hashtables there, it seems.
18:28:32 <EvanR> meh all the myriad implementations are at the bottom, 'really fast'
18:28:39 <EvanR> where are they gonna go
18:29:26 <ksf> stuff's going to change soon, when llvm becomes more widely used.
18:29:57 <ksf> ...where's clang in the shootout?
18:30:44 <ksf> it can compile linux, the shootout programs shouldn't be a problem...
18:31:44 <ksf> why's ghc such a megabyte-monster, btw?
18:32:23 <ksf> all those gazillion different codepaths for a bazillion different combinations of language features?
18:33:22 <ksf> right now, using hint for scripting is embarassing.
18:36:30 <Eduard_Munteanu> Last time I checked an article on Phoronix (not a very recent one), clang wasn't that good compared to GCC.
18:37:04 <Eduard_Munteanu> wrt executable performance.
18:37:14 <Eduard_Munteanu> In some cases, it got better performance than GCC though.
18:44:45 <Funktorsalat> ksf: is that the dumbass one where you must use a hashtable? :o
18:44:59 <Funktorsalat> ahem. sorry
18:45:07 <syntaxglitch> oh man, hashtables are the best data structure ever, who needs anything else
18:45:20 <syntaxglitch> that's why haskell isn't suitable for real world use, it doesn't have enough hash
18:45:22 <syntaxglitch> er, hash tables
18:45:34 <Funktorsalat> (I mean the benchmark)
18:46:09 <Eduard_Munteanu> Really, what's wrong with hashtables in Haskell?
18:46:25 <Funktorsalat> syntaxglitch: not saying I mind hashtables
18:46:49 <Funktorsalat> but it's a bit silly to force their use (iirc) in a language that didn't give much attention to them
18:47:12 <Eduard_Munteanu> They don't seem particularly hard to implement given some mutable storage.
18:47:18 <sipa> s/htab/kel/
18:47:19 <sipa> fixed.
18:47:28 <syntaxglitch> Nothing, they're just an inherently mutable data structure and one that many people seize on as "this hammer is all I have"
18:47:36 <sipa> 02:45:45 < Eduard_Munteanu> Really, what's wrong with haskelles in Haskell?
18:48:02 <Eduard_Munteanu> Heh.
18:48:14 <sipa> sorry, i need sleep
18:48:18 <Eduard_Munteanu> I guess nothing.
18:48:31 <syntaxglitch> it's just one of those "not even wrong" complaints about Haskell
18:48:49 <syntaxglitch> it implies so many misunderstandings that you don't even know where to start correcting someone
18:49:16 <syntaxglitch> and with as much time as I've spent on stackoverflow I've seen lots of Haskell misunderstandings
18:49:44 <Eduard_Munteanu> Well what Funktorsalat implies is (1) the hashtable performance is poor and (2) the situation is somehow irredeemable in Haskell.
18:49:53 <Eduard_Munteanu> And I can't really see why.
18:50:17 <Funktorsalat> huh? <Funktorsalat> ... in a language that didn't give much attention to them
18:50:39 <syntaxglitch> there were some GC bugs at one point I think? And not much attention paid to making optimized libraries
18:50:49 <syntaxglitch> nothing all that major I don't think
18:51:00 <Funktorsalat> if it stores strings, one would probably use bytestring-trie or so
18:51:04 <Eduard_Munteanu> Funktorsalat: so then the test ain't that bad.
18:51:09 <monochrom> the current version is slow. no one has found out why. but it's open-source, anyone may fix it.
18:51:13 <syntaxglitch> and when I say GC bugs I mean performance degradation, not like serious bug-bugs
18:51:29 <Eduard_Munteanu> monochrom: is it somehow based on DiffArray, or it's the same problem that's affecting it?
18:51:39 <monochrom> the problem is reduced to demand-supply economics.
18:51:39 <djahandarie> I think the real problem is no one cares about it enough
18:51:48 <djahandarie> (=゜ω゜)人(゜ω゜=)
18:52:23 <Funktorsalat> doesn't one of the ffi-bound data structures we have on hacakge qualify as a 'hashable'? :D
18:52:29 <Funktorsalat> if you're allowed to use those...
18:52:31 <Eduard_Munteanu> It's a bit awkward.
18:52:47 <monochrom> it is not based on DiffArray. it doesn't even pretend to be pure-functional. all its functions are in IO.
18:53:47 <Eduard_Munteanu> Now if haskellers don't care about those, it seems they don't care about O(1) insertion/lookup. What's the alternative?
18:54:30 <monochrom> Data.Map/Set are the most popular. And then there are Data.IntMap/Set. And then there are finger trees, tries, judy trees...
18:54:46 <syntaxglitch> Hashtables aren't O(1) lookup anyway, because the hash function is going to be O(something) in the key size
18:54:52 <Eduard_Munteanu> monochrom: I see. Those seem to be at least O(log n) though.
18:55:05 <monochrom> and there is always the enlightened knowledge that "O(1)" is a lie to begin with.
18:55:21 <syntaxglitch> And tries are also sorta-O(1) in lookup, O(something) in key size
18:55:22 <Entroacceptor> but O(keysize) is different from O(number of entries)
18:55:29 <Eduard_Munteanu> syntaxglitch: yeah, but take the average case and assume about constant-size keys.
18:55:59 <Funktorsalat> what about this? :) http://hackage.haskell.org/packages/archive/HsJudy/0.2/doc/html/Data-Array-Judy-Hash.html
18:56:01 <Eduard_Munteanu> If so, then on average it's theta(1) to be accurate.
18:56:03 <monochrom> http://enfranchisedmind.com/blog/posts/problems-with-hash-tables/
18:56:17 <syntaxglitch> Anwyay the simple version is that it's complicated
18:56:41 <syntaxglitch> Hashtables are actually a very subtle thing and people who use them blindly everywhere are being silly
18:56:42 <Eduard_Munteanu> monochrom: thanks, looking at it...
18:57:07 <Funktorsalat> I don't pretend to understand judy arrays but apparently the HS variant is "a hybird using the best features of hashing and Judy methods"
18:57:08 <Eduard_Munteanu> syntaxglitch: dunno, in some languages they're pretty easy to implement.
18:57:12 <djahandarie> Eduard_Munteanu, I think the idea here is that if someone was hitting the case where they needed a hash table it would be done
18:57:18 <Eduard_Munteanu> syntaxglitch: as opposed to say, red-black trees.
18:57:19 <djahandarie> And it isn't done so no one is hitting it
18:57:33 <syntaxglitch> Eduard_Munteanu, implementing is not the same as implementing and using effectively
18:57:35 <Funktorsalat> so is one allowed to use libraries on the benchmark?
18:57:39 <Eduard_Munteanu> Yeah.
18:57:46 <Eduard_Munteanu> not to Funktorsalat 
18:58:00 <syntaxglitch> Hash tables have a lot of ways to screw up when using them. Trees mostly have ways to screw up when implementing them.
18:58:04 <Eduard_Munteanu> Funktorsalat: I suppose you can use standard libs, or at least basic stuff.
18:58:12 <Funktorsalat> (by "HS" I don't mean "haskell"; it's one of the variants of the original judy array)
18:58:44 <syntaxglitch> Anyway, aren't Judy arrays some insane recursive hashing-trie with five thousand node variations or something?
18:58:52 <djahandarie> Yes
18:59:08 <djahandarie> They *are* fast though
18:59:08 <syntaxglitch> I read some stuff about them once and just kinda boggled
18:59:54 <monochrom> perhaps you want Judy rather than being inflexible about "I absolutely want hash table"
19:00:26 * syntaxglitch has the impression that Judy arrays pretty much beat the crap out of every other dictionary-ish data structure on every metric except "ease of implementation"
19:00:33 <monochrom> programmers are sometimes control freaks in what they insist and lose track of their real purposes
19:00:59 <Funktorsalat> monochrom: uh? I'm talking about whether it would satisfy the requirement of the benchmark to use a hashtable
19:01:32 <syntaxglitch> yeah, the tangent on denigrating hash tables was my fault, sorry
19:01:35 <ddarius> Argh!
19:01:53 * ddarius will have to drive down to New York someday just to get a particular alcohol.
19:02:00 <monochrom> I am not talking about the benchmark question.
19:02:11 <Eduard_Munteanu> monochrom: I quickly skimmed over that, and yeah, it makes sense. But I don't necessarily agree with the conclusion.
19:02:14 <djahandarie> ddarius, you have to?
19:02:16 <syntaxglitch> ddarius, that sounds like serious business, what kind?
19:02:18 <djahandarie> At gun point?
19:03:07 <ddarius> syntaxglitch: I would like to get some Yuzu Komachi but any yuzu shu would be adequate.
19:03:09 <monochrom> alcohol drinkers are sometimes control freaks in what they insist and lose track of their real purposes...
19:03:21 * ddarius very rarely drinks alcohol.
19:03:31 <syntaxglitch> I drink expensive alcohol
19:03:32 * djahandarie doesn't at all
19:03:43 <syntaxglitch> This has two benefits: one, it tastes good. two, I can't afford enough to get drunk
19:03:49 <Eduard_Munteanu> The type of hashtable I'm used to concoct up quickly solves collisions with linked lists and uses very simple hash functions. I do get collisions, but it's usually fast. So I think it's worth it in some applications.
19:03:50 <ddarius> syntaxglitch: Most of the alcohol I've drunk has not been cheap.
19:04:01 <djahandarie> Because we're all high class here
19:04:21 * djahandarie puts on monocle
19:04:39 <syntaxglitch> ddarius, I mostly go for microbrew beer, some expensive imported ales, and single malt scotch.
19:04:41 <ddarius> djahandarie: That and most of the alcohol I've drunk was in Japan and who wants to "settle" when on vacation.
19:04:45 <Eduard_Munteanu> Especially if you just don't over-insert and if the data is already somewhat random.
19:04:48 <Adamant> I basically follow syntaxglitch's rule
19:05:05 <Adamant> except I don't drink especially fancy beer, just fancy liquor
19:05:22 <Adamant> being a broke-ass, I can only afford two drinks of the good shit
19:05:26 <djahandarie> ddarius, you were in Japan?
19:05:29 <ddarius> I'm not a beer person despite the variety of high quality beers presented/suggested to me.
19:05:33 <ddarius> djahandarie: Yes.
19:05:37 <djahandarie> For the military?
19:05:40 <ddarius> djahandarie: No.
19:05:42 <Eduard_Munteanu> syntaxglitch: aye, ales are the best.
19:05:47 <Adamant> ddarius: I like them sometimes, but not often
19:06:01 <syntaxglitch> ddarius, I'll resist the urge to make suggestions then, you've likely heard them all before
19:06:05 <Eduard_Munteanu> And unfiltered beer!
19:06:26 <monochrom> I use Data.Map i.e. immutable binary search trees because it is not slow and it is thread-safe.
19:06:44 <Eduard_Munteanu> I still remember Carlsberg Porter, probably the best black beer I had.
19:06:58 <ddarius> I love yuzu shu and, oddly, I rather like tequila.
19:07:01 <Eduard_Munteanu> s/black//, it's the best beer.
19:07:03 <syntaxglitch> monochrom, that suddenly seemed really out of place after talking about beer
19:07:11 * syntaxglitch pours a shot of Data.Map
19:07:14 <Eduard_Munteanu> Very thick.
19:07:27 <monochrom> of course you could make mutable hash table thread safe too. just lock, modify, unlock.
19:07:33 <ddarius> Eduard_Munteanu: I do tend to prefer porters, but not to the point of wanting to go out and buy some.
19:08:16 <monochrom> but compare to immutable binary search tree, coupled with laziness: lock, change one pointer, unlock, modify.
19:08:27 <monochrom> the critical section is so small.
19:08:32 <Eduard_Munteanu> ddarius: sadly I can't find any porter here. And no, I don't drink regularly :)
19:08:51 <syntaxglitch> Eduard_Munteanu, where is "here" that you can't find porter?
19:09:11 <Draconx> monochrom, you could certainly do the same thing with a hash table.
19:09:14 <ddarius> syntaxglitch: Perhaps Utah?
19:09:14 <Eduard_Munteanu> syntaxglitch: Romania. I only found Carlsberg Porter at a beer festival here.
19:09:27 <monochrom> with hypothetical immutable hash table, yeah.
19:10:19 <Eduard_Munteanu> monochrom: hm, actually an immutable hash table would make sense for the applications I have in mind.
19:10:36 <monochrom> immutable hash table is probably an order of magnitude slower than immutable binary search tree if you "compute new version"
19:12:01 <Eduard_Munteanu> Err perhaps I was wrong. I mean the hashtable itself be immutable in the keys, but data associated with the keys should be mutable.
19:12:15 <Eduard_Munteanu> So no removes/replaces, just lookup and modify associated data.
19:13:02 <Eduard_Munteanu> Hashtable (Data Key IORef) in pseudo-Haskell
19:17:47 * Eduard_Munteanu would still use Data.Map or something if he did that in Haskell though.
19:18:09 <monochrom> Data.Map is always worth a first try
19:19:37 <lars9> why (>) 3 head [1..10] is illegal, but 3 > head [1..10] is legal?
19:20:06 <kmc> (>) 3 (head [1..10])
19:20:15 <kmc> otherwise you're using (>) as a 3-arg function
19:20:19 <kmc> which is incompatible with its type
19:20:32 <lars9> how is ( ) defined?
19:20:43 <lars9> a function or syntax suggar?
19:20:51 <monochrom> syntax
19:20:51 <lars9> and ``
19:20:53 <Funktorsalat> should there be an --ignore-upper-bounds flag to cabal-install?
19:20:55 <monochrom> syntax too
19:20:56 <kmc> those are syntax
19:21:05 <Eduard_Munteanu> > (>) 3 $ head [1..10]
19:21:06 <lambdabot>   True
19:21:08 <kmc> () turns an infix operator into a regular function name
19:21:11 <kmc> `` does the opposite
19:21:32 <kmc> > let greater = (>) in greater 3 (head [1..10])
19:21:33 <lambdabot>   True
19:21:40 <lars9> how is infix operator's association behavior defined?
19:21:51 <Eduard_Munteanu> infixl/infixr
19:22:15 <monochrom> someone declares it somewhere with "infixl" or "infixr" or "infix"
19:22:24 <kmc> if you're comparing binary search trees and hash tables, you should also consider hash tries
19:23:37 <Eduard_Munteanu> Hm, how do those fare? Still O(log n) but much smaller constants?
19:23:49 <Eduard_Munteanu> That would be my guess.
19:23:50 <Funktorsalat> nothing works on ghc 7 because packages are scared of base-4.3 :|
19:24:08 <monochrom> I wait for haskell-platform
19:24:14 <Funktorsalat> am I really the only one who finds that upper-bound policy annoying?
19:24:21 <monochrom> besides, ghc 7 is only at 2nd RC
19:24:37 <kmc> Eduard_Munteanu, asymptotics are misleading.  they're "O(1)" because your tree depth is bounded by your hash value's size in bits, which is constant
19:24:40 <Funktorsalat> and does cabal unpack foo; gvim foo*/*.cabal; <delete bound> as a matter of routine now
19:24:50 <Funktorsalat> monochrom: I'm not complaining about ghc 7
19:25:02 <lars9> so, a `f` b c d ... = f a (b c d ...) ?
19:25:12 <kmc> yes lars9
19:25:15 <Funktorsalat> monochrom: I didn't run into actual incompatibility; I mean paranoid upper bounds
19:25:19 <Eduard_Munteanu> kmc: hm, I see.
19:25:22 <kmc> infix always binds weaker than function application lars9
19:25:34 <lars9> kmc: i see
19:25:40 <monochrom> dons has one package saying "base <= 10"
19:25:44 <kmc> Eduard_Munteanu, that's ignoring the possibility of collision, as one often does when analyzing hash-based structures
19:25:48 <Funktorsalat> monochrom: way to go
19:26:00 <Eduard_Munteanu> Yes, I understand.
19:26:28 <kmc> anyway immutable hash tries can have efficient updates with sharing
19:26:54 <kmc> clojure's main associative data structure is a 32-ary hash trie
19:27:01 <kmc> with packed nodes
19:27:26 <Funktorsalat> sounds less efficient than a flat array (with mutable ops)
19:27:29 <szany> Is there an introduction to Haskell that's written more like a math textbook?
19:27:35 <kmc> well yes Funktorsalat
19:27:43 <Eduard_Munteanu> I wish.
19:27:46 <kmc> but there's big advantages to ignoring mutable ops
19:27:47 <ddarius> @google Haskell Road to Logic
19:27:48 <lambdabot> http://homepages.cwi.nl/~jve/HR/
19:27:48 <lambdabot> Title: The Haskell Road
19:28:05 <newguy> need a little help plz, i'm doing this  | (a>b) and (b>c) = (a,b,c) (my function returns a triple), but haskell says i cant, can i put two comparisons like that in a guard??
19:28:10 <Eduard_Munteanu> Ah, then I thought of something else.
19:28:14 <kmc> newguy, write && instead of 'and'
19:28:15 <monochrom> The Haskell Road to Logic, Maths, Truth, and Insanity
19:28:18 <kmc> :t (&&)
19:28:19 <lambdabot> Bool -> Bool -> Bool
19:28:26 <newguy> thx
19:28:26 <Funktorsalat> would I have to hack cabal or just cabal-install to add that flag?
19:28:27 <Eduard_Munteanu> :t and
19:28:28 <lambdabot> [Bool] -> Bool
19:28:52 <wlangstroth> if you already have insanity covered, there's less to learn
19:28:59 <Eduard_Munteanu> It's a bit misleading that 'not' is spelled out like that and 'and' is something else.
19:29:23 <kmc> misleading, but necessary given the constraints on haskell syntax
19:29:27 <Funktorsalat> ! is already taken for bang patterns
19:29:30 <szany> ddarius: looks like an introduction to math, I know math already 8-)
19:30:05 <kmc> szany, usually people bitch that Haskell is too mathematical as is
19:30:06 <ddarius> Most math textbooks are introductions to math.
19:30:25 <szany> kmc: yeah, I'm coming from the other end haha
19:30:39 <Eduard_Munteanu> Heh :)
19:31:15 <Eduard_Munteanu> OTOH, I see many maths people being clueless at programming.
19:31:25 <Eduard_Munteanu> It's a bit strange.
19:31:27 <kmc> i know a few maths people who hated programming before they learned haskell
19:31:34 <Eduard_Munteanu> Oh :).
19:31:38 <monochrom> Oh, I see, a haskell book written like a math book. That would be "a Gentle Introduction to Haskell" and "Introduction to Functional Programming using Haskell 2nd edition"
19:32:54 <Eduard_Munteanu> Still many (older) math people use stuff like FORTRAN sadly.
19:33:34 <szany> I liked the Gentle Introduction though it seemed a bit light; the second book looks really good
19:33:37 <Eduard_Munteanu> That and COBOL should be banned :P
19:34:00 <kmc> FORTRAN is a respectable formula translator
19:34:10 <kmc> if you need to turn a formula into some really fast code
19:34:17 <kmc> it is still a good tool for that
19:34:21 <kmc> it is not a general purpose language
19:34:58 <Martty> Yet Another Haskell Tutorial is pretty "mathish"
19:35:39 <Eduard_Munteanu> kmc: I'd still take something else and BLAS or something like that for those tasks.
19:35:59 <kmc> yeah
19:36:08 <kmc> FORTRAN is good for writing BLAS, basically
19:38:02 <szany> Has anyone succeeded in learning Haskell from the Report directly?
19:38:27 <monochrom> haha
19:38:58 <szany> The Gentle Introduction seems to push towards that direction
19:39:10 <Eduard_Munteanu> Report? Screw that, just the EBNF.
19:39:12 <lars9> how can Show knows how to convert a data constructor to string?
19:39:15 * Eduard_Munteanu just kidding
19:39:27 <kmc> lars9, "deriving Show"?
19:39:32 <kmc> is built into your compiler
19:39:32 <lars9> data WOW = WOW Int, the WOW part
19:39:39 <kmc> if you write your own Show instance, there's no magic to it
19:39:48 <monochrom> compiler assistance
19:40:02 <lars9> compiler assistance, that explains
19:40:16 <kmc> instance Show WOW where { show (WOW x) = "WOW " ++ show x }
19:40:17 <kmc> basically
19:40:27 <lars9> i see
19:40:51 <kmc> the ability to use "deriving" for a class is specially baked into the compiler for each class
19:41:15 <kmc> (except in the case of "newtype", where you can derive any class from the underlying type, with a GHC extension)
19:41:56 <szany> oh there's even a shiny new 2010 edition PDF online
19:42:04 <lars9> ghc is awesome
19:42:10 <kmc> it's a nice compiler, yeah
19:42:48 <lars9> other compilers are practically dead?
19:42:57 <kmc> for Haskell?
19:42:58 <monochrom> no.
19:43:09 <kmc> UHC and LHC are under active development
19:43:11 <lars9> kmc: sure, not gcc, javac...
19:43:15 <kmc> they're just not mainstream
19:43:31 <kmc> UHC got a Javascript backend very recently
19:43:40 <kmc> JHC has had recent releases too
19:43:59 <kmc> don't know about yhc; it's the successor to nhc98 so i'd consider the latter dead
19:44:17 <kmc> hbc and hugs haven't been updated in a long time
19:45:23 <Funktorsalat> insofar as haskell is mainstream. insofar as programming is mainstream.
19:45:36 <Funktorsalat> :)
19:45:56 <Eduard_Munteanu> Yeah, Haskell isn't exactly a neat party trick.
19:46:21 <dolio> I don't think yhc gets much time these days.
19:47:07 <lars9> JHC... this name is really implying something like JPython, JRuby...
19:47:13 <kmc> heh
19:47:18 <dolio> Man, this ultimate computer language guide is great.
19:47:24 <monochrom> J Hadron Collider
19:47:39 <kmc> it's John Meacham's Haskell Compiler
19:47:53 <kmc> there were a few projects to add JVM backends to GHC
19:48:01 <kmc> afaik none are production quality
19:48:17 <kmc> however you can call Java from Haskell and vice versa with standard GHC using FFI and JNI
19:48:45 <dolio> "Forth is a Stack Computing Language. Basically the language represents two virtual stacks to accomplish algorithms."
19:49:31 <djahandarie> Does the JVM even have TCO?
19:49:36 <dolio> No.
19:49:50 <geheimdienst> "Haskell is a scripting language inspired by Python." O RLY
19:50:04 <djahandarie> That's what I thought, which makes me wonder why there are so many functional-ish languages being built on top of it
19:50:11 <kmc> the term "scripting language" is worse than useless
19:50:17 <dolio> Yes, I'm not sure any of the others get to that level of ridiculum.
19:50:32 <kmc> and no, JVM lacks TCO.  in that, if you want your JVM-targeting compiler to provide TCO, you slow down *all* function calls, compared to Java
19:50:53 <djahandarie> Right
19:50:59 <dolio> That forth one is funny to me, though. It seems like such a weird thing to single out as the only thing you describe about the language.
19:51:09 <kmc> people are wrong on the internet?
19:51:40 <monochrom> people are funny on the internet
19:51:57 <geheimdienst> "PHP is a hypertext preprocessor." <- clear as mud on a weeknight
19:52:01 <kmc> http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
19:52:23 <dolio> The OCaml one is good, too. "OCaml is an attempt to implement object-oriented syntax in Caml." Note, it doesn't tell you what Caml is.
19:52:34 <kmc> also assumes that syntax is the important part
19:52:38 <geheimdienst> kmc, yes, a classic. "bjarne stroustup bolts everything he has ever heard of onto c ..."
19:52:38 <Funktorsalat> cabal: cannot configure base-3.0.3.2. It requires base >=4.0 && <4.4
19:52:43 <dolio> "It is related to SML."
19:52:47 <Funktorsalat> base-4.3.0.0 was excluded because of the top level dependency base ==3.0.3.2
19:52:51 <Funktorsalat> hmm.
19:52:53 <Funktorsalat> :)
19:53:24 <dolio> Then SML: "SML is the current descendant of the ML language." ML is also not described. "The most common current implementation is Moscow."
19:53:56 <Eduard_Munteanu> Caml?
19:53:57 <geheimdienst> in soviet russia, cities implement ML?
19:54:04 <Eduard_Munteanu> Heh.
19:54:30 <monochrom> hahaha
19:54:43 <monochrom> MoscowML
19:55:03 <Eduard_Munteanu> What's that, Uncyclopedia?
19:55:06 <caelan> "Your language is pure for the good of the Program."
19:55:29 <dolio> I probably would have picked SML/NJ as the go-to SML implementation.
19:55:36 <geheimdienst> Eduard_Munteanu: http://www.datarecoverylabs.com/ultimate-computer-language-guide.html
19:55:48 <Eduard_Munteanu> Oh.
19:56:11 <Eduard_Munteanu> Good, good... "C is one of the earliest examples of a high level programming language that was portable between systems. To this day most UNIX and UNIX-like systems ship with a C Compiler."
19:56:14 <lars9> it's said every C expression is pure, and the whole C program is just a monad
19:56:24 <kmc> lars9, lots of wrong things are said
19:56:28 <kmc> monads are types
19:56:31 <kmc> a monad is a type
19:56:34 <kmc> not a value or a program
19:56:51 <lars9> IO ExitCode ?
19:57:03 <kmc> a program isn't a type, it's a value which has some type
19:57:17 <kmc> anyway it's plainly untrue
19:57:24 <Eduard_Munteanu> Types are proofs.
19:57:29 <kmc> because if f and g have effects you can still say int z = f() + g();
19:57:36 <Eduard_Munteanu> err
19:57:38 <Eduard_Munteanu> Theorems.
19:57:48 <Eduard_Munteanu> Rather the programs are proofs.
19:57:51 <kmc> a pure language with monadic effects forbids this, because a value is a different thing from a recipe for producing a value
19:57:57 <erg0t_> any way of showing the name of a function?
19:58:21 <kmc> how do you mean erg0t_
19:58:44 <caelan> geheimdienst: so haskell is a scripting language, apparently?
19:58:45 <erg0t_> for example if I have a datatype Func = Func (Int -> Int)
19:58:50 <erg0t_> and I do: Func myfunc
19:58:50 <lars9> is it true that: let y = f x in .. computes y only once but where y = f x may compute multi times?
19:59:04 <kmc> lars9, no
19:59:05 <erg0t_> and then I want Func to have show
19:59:16 <geheimdienst> caelan, absolutely. inspired by python. must be correct, i read it on the interwebs
19:59:26 <kmc> erg0t_, and what would the output be
19:59:35 <erg0t_> in that case I want the name "myfunc"
19:59:43 <erg0t_> is possible?
19:59:44 <kmc> no
19:59:47 <kmc> not really
20:00:22 <lars9> kmc: where y = f x also only compute once?
20:00:39 <dolio> What if you wrote 'myfunc2 = myfunc' and then printed 'Func myfunc2'. What would it say then?
20:01:59 <Eduard_Munteanu> Interestingly this can be done in C.
20:02:18 <Eduard_Munteanu> Though I guess that owes much to its simplicity.
20:02:27 <erg0t_> dolio: I get the point
20:02:34 <Eduard_Munteanu> So maybe that's where he comes from.
20:02:39 <erg0t_> or if I pass a lambda
20:02:48 <erg0t_> to the constructor
20:02:58 <dolio> That too.
20:02:59 <erg0t_> I have no way of printing its name :P
20:04:05 <Eduard_Munteanu> I wonder if the report specifies any such implementation details, as to the resulting representation of a Haskell program after it's compiled.
20:04:17 <Eduard_Munteanu> So far it seems completely opaque wrt machine.
20:04:27 <monochrom> no, not specified
20:09:04 <Funktorsalat> erg0t_: data Func = Func String (Int -> Int)?                                  
20:11:08 <fengshaun> > [read x :: Integer | x <- show 1234]
20:11:09 <lambdabot>   Couldn't match expected type `GHC.Base.String'
20:11:09 <lambdabot>         against inferred typ...
20:11:12 <Eduard_Munteanu> Hm, actually you can coax a CPP macro in there.
20:11:18 <fengshaun> why doesn't this work?
20:11:43 <kmc> erg0t_, i think the closest you can do is a macro along the lines of http://mainisusuallyafunction.blogspot.com/2010/10/verbose-show-and-missing-preprocessor.html
20:11:47 <erg0t_> Funktorsalat: I'm trying to thing another way of solving my problem because obviously my design is flawed
20:11:55 <erg0t_> s/thing/think/
20:11:55 <Eduard_Munteanu> should look something like #define FUNC(fn) Func ##fn## fn
20:12:02 <kmc> or perhaps some GHC-dependent black magic
20:12:06 <Eduard_Munteanu> and use FUNC instead of the constructor directly.
20:12:10 <Funktorsalat> template haskle
20:12:42 <Funktorsalat> (transforming a toplevel binding decl)
20:12:53 <kmc> the Template Haskell fanclub is a group of people who would shout "USE A CHAINSAW" in response to a question on any home-improvement task
20:13:04 <Funktorsalat> so in the end you could write: j
20:13:08 <Funktorsalat> err sorry
20:13:09 <Funktorsalat> hit enter
20:13:23 <kmc> Funktorsalat, no, i like the first version, a macro that expands 'j' to the entire program desired
20:13:30 <Funktorsalat> func [d| mkFunc x = x+1 |]
20:13:31 <Eduard_Munteanu> :))
20:13:35 <Funktorsalat> kmc: :D
20:13:53 <Funktorsalat> (you know, toplevel decl splices don't need a $)
20:14:02 <kmc> if you're willing to throw out portability
20:14:09 <kmc> in GHC
20:14:12 <kmc> you can turn a value into a pointer to a closure
20:14:18 <kmc> and you can turn that into the address of an info table
20:14:30 <Funktorsalat> s/mkFunc/myFunc
20:14:34 <kmc> and that's in the binary's static data section
20:14:39 <Eduard_Munteanu> I wonder if addr2line works on Haskell binaries.
20:14:50 <kmc> and you can look up the symbol name of the info table
20:15:05 <kmc> and that's sort of like the function name
20:15:08 <Eduard_Munteanu> If it does, you can just call it.
20:15:22 <Eduard_Munteanu> and it will associate the pointer with a function name.
20:15:23 <lars9> can't cabal uninstall a package?
20:15:31 <Eduard_Munteanu> lars9: not really
20:15:32 <kmc> lars9, no, but ghc-pkg can unregister a package
20:15:42 <fengshaun> > map (\a -> read a :: Integer) $ show 1234
20:15:43 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:15:43 <lambdabot>         against inferred ty...
20:15:49 <Eduard_Munteanu> lars9: read ivanm's blog on "Cabal is not a package manager"
20:16:10 <Eduard_Munteanu> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
20:16:36 <Funktorsalat> @tell ivanm SourceGraph appears to work fine against Cabal-1.10
20:16:36 <lambdabot> Consider it noted.
20:16:46 <lars9> oops, has to do it myself.
20:16:47 <fengshaun> how can I get a list of an integer's digits? 1234 -> [1, 2, 3, 4]
20:17:22 <Funktorsalat> at least as in "compiles and analyzes cabal-install without error"
20:17:37 <lars9> > show 1234
20:17:38 <lambdabot>   "1234"
20:17:48 <Funktorsalat> :)
20:18:10 <fengshaun> lars9:
20:18:18 <Funktorsalat> > map (\c -> ord c - ord '0') (show 1234)
20:18:19 <lambdabot>   [1,2,3,4]
20:18:21 <fengshaun> > map read $ show 1234
20:18:21 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:18:22 <lambdabot>         against inferred ty...
20:18:23 <lars9> > map ord "1234"
20:18:24 <lambdabot>   [49,50,51,52]
20:18:49 <lars9> > map (-48) map ord "1234"
20:18:49 <lambdabot>   Couldn't match expected type `[a]'
20:18:50 <lambdabot>         against inferred type `(a1 -> b)...
20:18:54 <fengshaun> Funktorsalat, that's a nice one!
20:18:54 <lars9> > map (-48) $ map ord "1234"
20:18:55 <lambdabot>   [-48,-48,-48,-48]
20:19:24 <fengshaun> lars9, that should be subtract, not -
20:19:38 <fengshaun> > map (subtract 48) $ map ord "1234"
20:19:38 <lambdabot>   [1,2,3,4]
20:19:50 <fengshaun> ah, cool!  lars9 & Funktorsalat thanks!
20:20:06 <fengshaun> but why doesn't read work?
20:20:07 <Eduard_Munteanu> Or you can just reimplement the imperative algo in haskell
20:20:09 <Funktorsalat> something based on divMod might be more efficient, fengshaun 
20:20:20 <Eduard_Munteanu> fengshaun: it should read the whole number back, plus it needs a sig
20:20:39 <fengshaun> > map (\a -> read a :: Int) $ show 1234
20:20:39 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:20:40 <lambdabot>         against inferred ty...
20:21:02 <fengshaun> Funktorsalat, I'll look into that
20:21:38 <fengshaun> Eduard_Munteanu, I'm giving read a signature, and still doesn't work
20:22:04 <fengshaun> even:
20:22:09 <fengshaun> > map read $ show 1234
20:22:10 <lars9> fengshaun: unfoldr should be able to do it neatly
20:22:10 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:22:10 <lambdabot>         against inferred ty...
20:22:16 <Funktorsalat> @let swap (x,y) = (y,x)
20:22:17 <Eduard_Munteanu> > let toDigits 0 = []; toDigits n = (n `mod` 10) : (toDigits $ n / 10); in toDigits 1234
20:22:17 <lambdabot>  Defined.
20:22:18 <lambdabot>   Ambiguous type variable `t' in the constraints:
20:22:18 <lambdabot>    `GHC.Real.Integral t'
20:22:18 <lambdabot>   ...
20:22:30 <Eduard_Munteanu> Crap.
20:22:40 <Funktorsalat> > unfoldr (\x -> if x == 0 then Nothing else Just (swap (divMod x 10))) 1234
20:22:41 <lambdabot>   [4,3,2,1]
20:22:43 <Funktorsalat> :)
20:22:46 <Funktorsalat> @ fengshaun 
20:22:52 <fengshaun> Funktorsalat, holy moly!
20:22:53 <Eduard_Munteanu> fengshaun: that would read the whole number back anyway, it's not good
20:23:18 <fengshaun> Eduard_Munteanu, I don't think that would.  read is applied to each digit (which is a Char)
20:23:20 <Eduard_Munteanu> What's wrong with my let above?
20:23:35 <fengshaun> I just want to know why that read approach doesn't work
20:23:37 <Eduard_Munteanu> fengshaun: oh, you mapped, then it's fine.
20:23:49 <fengshaun> > map read $ show 1234
20:23:50 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:23:50 <lambdabot>         against inferred ty...
20:24:05 <fengshaun> > map (\a -> read a :: Int) $ show 1234
20:24:06 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:24:06 <lambdabot>         against inferred ty...
20:24:11 <fengshaun> Eduard_Munteanu, ^^^
20:24:39 <fengshaun> > read "3" :: Int
20:24:40 <lambdabot>   3
20:24:47 <fengshaun> show 1234
20:24:48 <Eduard_Munteanu> > read '3' :: Int
20:24:49 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:24:49 <lambdabot>         against inferred ty...
20:24:58 <fengshaun> oh!
20:25:10 <fengshaun> ' and " are different then!
20:25:17 <Cale> > map (read . (:[])) . show $ 1234
20:25:17 <Eduard_Munteanu> map (pure . read) $ show 1234
20:25:18 <lambdabot>   [*Exception: Prelude.read: no parse
20:25:21 <Cale> oop :)
20:25:30 <Cale> > map (read . (:[])) . show $ 1234 :: [Integer]
20:25:31 <lambdabot>   [1,2,3,4]
20:25:31 <kmc> yes, 'c' :: Char, "c" = ['c']
20:25:32 <Eduard_Munteanu> map (read . pure) $ show 1234
20:25:38 <Eduard_Munteanu> > map (read . pure) $ show 1234
20:25:39 <lambdabot>   [*Exception: Prelude.read: no parse
20:25:40 <caelan> fengshaun: yes; ' means a character, and " means a string
20:25:42 <Eduard_Munteanu> Gr.
20:25:46 <kmc> "abcd" = ['a','b','c','d']
20:25:52 <Cale> Same problem that I had :)
20:26:04 <Funktorsalat> @let auto_unfoldr f = unfoldr (\s -> let fs = f s in if fs == s then Nothing else fs)
20:26:04 <fengshaun> oh cool, now I understand.  I have to do '1':[] to make it "1"
20:26:04 <lambdabot>  <local>:13:77:
20:26:04 <lambdabot>      Occurs check: cannot construct the infinite type: b = Ma...
20:26:07 <Eduard_Munteanu> > map (read . pure) $ show 1234 :: [Integer]
20:26:08 <lambdabot>   [1,2,3,4]
20:26:20 <Eduard_Munteanu> Cale: yeah
20:26:25 <fengshaun> Eduard_Munteanu, what is pure?
20:26:28 <lars9> map (read . return) $ show 1234 :: [Int]
20:26:31 <lars9> > map (read . return) $ show 1234 :: [Int]
20:26:32 <fengshaun> :t pure
20:26:32 <lambdabot>   [1,2,3,4]
20:26:33 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
20:26:41 <Eduard_Munteanu> fengshaun: just like return, just like \x -> [x] here
20:26:46 <Funktorsalat> @let auto_unfoldr f = unfoldr (\s -> let fs = f s in if maybe False ((==s).snd) fs then Nothing else fs)
20:26:47 <lambdabot>  Defined.
20:26:50 <Funktorsalat> :D
20:26:53 <fengshaun> Eduard_Munteanu, oh nice
20:27:04 <Funktorsalat> > auto_unfoldr (`divMod` 10) 1234
20:27:05 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, b)'
20:27:05 <lambdabot>         against infe...
20:27:34 <fengshaun> :t return
20:27:35 <Funktorsalat> > auto_unfoldr (Just . (`divMod` 10)) 1234
20:27:35 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
20:27:36 <lambdabot>   [123]
20:27:44 <Funktorsalat> meh. ;)
20:27:50 <Funktorsalat> > auto_unfoldr (Just . swap . (`divMod` 10)) 1234
20:27:51 <lambdabot>   [4,3,2,1]
20:27:53 <Funktorsalat> yay
20:28:02 <Eduard_Munteanu> The div/mod algo is probably better unless GHC does some deforestation.
20:28:10 <fengshaun> Funktorsalat, lol, you're going way over the top of my head
20:28:41 <Funktorsalat> I just noticed a pattern in that auto_unfoldr 
20:29:06 <Funktorsalat> it often seems to be the termination condition that the state becomes fixed
20:29:35 <tolkad> would it be bad to use overlapping instances to create a function that automatically lifted something as many times as necessary?
20:29:49 <lars9> > map (read . return) $ show 123421321343243241342143 :: [Int]
20:29:50 <lambdabot>   [1,2,3,4,2,1,3,2,1,3,4,3,2,4,3,2,4,1,3,4,2,1,4,3]
20:30:10 <lars9> > map (read . return) $ show "12345" :: [Int]
20:30:11 <lambdabot>   [*Exception: Prelude.read: no parse
20:30:40 <Eduard_Munteanu> lars9: that prints '"'s too
20:30:44 <Eduard_Munteanu> > show "foo"
20:30:45 <kmc> :t auto_unfoldr
20:30:45 <lambdabot>   "\"foo\""
20:30:46 <lambdabot> forall b a. (Eq b) => (b -> Maybe (a, b)) -> b -> [a]
20:30:49 <kmc> :t unfoldr
20:30:50 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
20:30:54 <lars9> Eduard_Munteanu: yep... crap
20:31:22 <Funktorsalat> the Maybe could be scrapped if fixedness is to be the only way to terminate
20:31:54 <Eduard_Munteanu> tolkad: perhaps you should use transformers if I'm guessing correctly what your application is.
20:32:19 <Eduard_Munteanu> tolkad: or is this an exercise in itself?
20:32:24 <tolkad> (concat . map show) [1,2,3,4,2,1,3,2,1,3,4,3,2,4,3,2,4,1,3,4,2,1,4,3]
20:32:29 <tolkad> > (concat . map show) [1,2,3,4,2,1,3,2,1,3,4,3,2,4,3,2,4,1,3,4,2,1,4,3]
20:32:30 <lambdabot>   "123421321343243241342143"
20:32:48 <tolkad> Eduard_Munteanu: well my application is I have a bunch of combined monads
20:33:00 <tolkad> Eduard_Munteanu: and I don't want to have to worry about how many times to lift each one
20:33:10 <tolkad> Eduard_Munteanu: and I realized I could use overlapping instances to do it for me
20:33:29 <Eduard_Munteanu> tolkad: are you already using monad transformers?
20:33:34 <tolkad> Eduard_Munteanu: yes
20:33:40 <Eduard_Munteanu> Ah.
20:33:40 <tolkad> Eduard_Munteanu: but chained together
20:33:51 <Eduard_Munteanu> tolkad: what do you mean?
20:33:54 <tolkad> Eduard_Munteanu: so I have to lift some of the underlying monads multiple times
20:34:53 <Eduard_Munteanu> tolkad: depending on the combo you're using, perhaps there's something else that does it.
20:35:09 <tolkad> like let's say I have MaybeT (ErrorT IO)
20:35:18 <tolkad> I have to lift IO computations twice
20:35:46 <tolkad> but I could write a magic lift function to automatically figure that out for me using OverlappingInstances
20:36:34 <Eduard_Munteanu> Hm, that would be an open question for me as well, as to what approach is best.
20:54:57 * hackagebot nettle-frp 0.1 - FRP for controlling networks of OpenFlow switches.  http://hackage.haskell.org/package/nettle-frp-0.1 (AndreasVoellmy)
21:01:04 <pygmalion> is anyone familiar with binary search trees in haskell? i'm having some trouble writing a lookup function
21:02:34 <pygmalion> well here's the relevant code anyway http://hpaste.org/41117/bst
21:03:39 <mtnviewmark> sure,
21:03:46 <Eduard_Munteanu> pygmalion: the otherwise case should be for Empty.
21:03:59 <mtnviewmark> 1) what should    aLokup Empty x  yield
21:04:01 <mtnviewmark> ?
21:04:16 <pygmalion> mtnviewmark: Nothing?
21:04:17 <mtnviewmark> Instead of    s < k,  s == k, and s > k
21:04:46 <mtnviewmark> consider    case compare s k of  LT -> ....;  EQ -> ....;   GT -> ....;
21:04:58 <mtnviewmark> then you are certain to catch all the cases
21:05:33 <pygmalion> mtnviewmark: okay i'll take a look and see what i can conjure up with that
21:05:40 <mtnviewmark> right now your | otherwise clause looks like "belt and suspenders":  "I'm not certain that <, =, & > will cover all the cases ... so I added an otherwise caluse"
21:06:15 <mtnviewmark> pygmalion - are you using ghc?
21:06:26 <pygmalion> mtnviewmark: yes, why?
21:06:42 <mtnviewmark> use -Wall   --- it will tell you lots of good things!
21:07:14 <pygmalion> mtnviewmark: ooh okay thanks! i tried that case expression, i'm getting an "Occurs check" error
21:07:19 <pygmalion> mtnviewmark: pasting it, one sec
21:07:53 <mtnviewmark> what you want is    -fwarn-incomplete-patterns    which comes with -Wall
21:08:04 <pygmalion> http://hpaste.org/paste/41117/error#p41118
21:08:57 <mtnviewmark> so - I'm suggesting that rather than use guards, you use a case..   
21:09:20 <mtnviewmark> like     aLookup (ANode (k,v) a b) s = case compare s k of     .....
21:09:23 <pygmalion> mtnviewmark: yes, sorry i did. i didn't repaste the new code
21:09:27 <pygmalion> i only pasted the error
21:09:33 <pygmalion> i can paste the new code too, one sec
21:09:36 <mtnviewmark> please
21:09:43 <Eduard_Munteanu> pygmalion: that error suggests you misused the case syntax
21:09:57 <pygmalion> mtnviewmark: http://hpaste.org/paste/41117/new_code#p41119
21:10:19 <mtnviewmark> you left out 'compare'    
21:10:23 <mtnviewmark> :t compare
21:10:24 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
21:11:13 <Eduard_Munteanu> also don't forget the alookup Empty x case
21:11:36 <lars9> i use ghc-pkg decribe regex-tfda | grep id to find its id: id: regex-tdfa-1.1.6-f9be3711dc1876270e698fecdb42e883; then use ghc-pkg unregister regex-tdfa-1.1.6... to unregister it, but ghc-pkg said no such pkg...
21:11:50 <pygmalion> mtnviewmark, Eduard_Munteanu: ah that was it! thanks guys, very helpful
21:12:00 <pygmalion> i'll be back... the delete function is bound to be tricky
21:12:17 <mtnviewmark> problem set? working through a tutorial?
21:12:27 <mtnviewmark> happy to help... :-)
21:12:46 <pygmalion> mtnviewmark: actually a lab assignment, thanks :)
21:13:17 <mtnviewmark> then we'll be sure not to out-right write it for you... but hopefully explain stuff you get it!
21:13:31 <pygmalion> mtnviewmark: exactly what i'm looking for
21:18:05 <Eduard_Munteanu> I sometimes do my homework/projects in Haskell, but my courses/labs don't deal in Haskell, I'm on my own. :)
21:18:52 <Eduard_Munteanu> It surely raises some eyebrows though :D.
21:29:44 <lars9> what's the time complexity of tail? O(1) or (length l)?
21:29:58 <lars9> O(len l)
21:30:42 <monochrom> O(1)
21:31:17 <kmc> if xs is evaluated then (head (tail xs)) is O(1)
21:31:24 <kmc> of course printing all of (tail xs) is O(n)
21:31:31 <kmc> because that's n-1 ∈ O(n) elements
21:32:25 <lars9> in doc it's said Map.Insert is O(Log N), the old and new Maps share some data?
21:32:32 <monochrom> yes
21:32:42 <lars9> just like l and (tail l) share?
21:32:47 <monochrom> yes
21:33:11 <lars9> ok, i'm feel better when using Data.Map now.
21:33:49 <kmc> yeah, trees are great for persistent data
21:33:55 <kmc> you can share everything except the path from the root to the new node
21:34:09 <kmc> so tree-shaped structures are good for concurrency
21:34:12 <lars9> does GC work only on a whole list, or just part ot a list? 
21:34:26 <kmc> the gc can free any (:) node which is unreachable
21:35:29 <kmc> so, can i use 'vacuum' to get the symbol name of a function?
21:35:43 <lars9> when applying map f on a huge list, can GC free heading part when processing tailing part? suppose the list is not referenced anymore
21:35:49 <kmc> yes lars9
21:36:52 <lars9> so smart, in java, elems of an ArrayList can not be freed unless the whole ArrayList is freed
21:37:23 <lars9> ?freeed?
21:37:23 <lambdabot> Unknown command, try @list
21:37:55 <Pseudonym> lars9: You can null out unused elements, right?
21:38:28 <lars9> Pseudonym: have to do it explicitly though
21:38:48 <Pseudonym> Right, but that's not a problem with Java specifically, it's a problem with mutable data structures.
21:39:02 <pygmalion> mtnviewmark: okay so i'm attempting to write a helper function for delete that locates the requested key within the tree (i.e. recursively finds the node to be deleted) http://hpaste.org/paste/41117/findnode#p41120
21:39:30 <lars9> Pseudonym: yeah...
21:39:52 <Pseudonym> Of course, there's a semantic issue with the library, too.  If you shrink an array, then the references to the elements that are lost should disappear.
21:41:28 <Pseudonym> In general, in a GC'd language with mutable data structures, sometimes you have to work with the GC.  Thankfully, it's invariably a local concern, not a global concern like you'd have to do with manual memory management.
21:42:48 <pygmalion> mtnviewmark: i'm not sure if i'm returning what i want with that. it seems to be just returning the tree that was input.
21:42:49 <mtnviewmark> pygmalion: are you sure that error goes with that text? the erorr is indicative of swapping the arguments to findNode somewhere
21:42:59 <mtnviewmark> yes, that is what that does
21:43:01 <copumpkin> hm
21:43:23 <pygmalion> mtnviewmar: the error was there because i had another unnecessary otherwise clause which i've now removed so the error is gone
21:43:28 <pygmalion> mtnviewmark: *
21:43:37 <pygmalion> but the problem of it being a useless function still exists
21:43:50 * mtnviewmark points again to the use of guards and testing vs. case comapre of...
21:44:11 <pygmalion> mtnviewmark: fair enough. obviously my thought process starts with guards... i'll make the switch
21:44:21 <mtnviewmark> yes, so ask yourself this: in this pure functional, non-mutable world -- what does it mean to "delete" a node from a tree?
21:44:48 <pygmalion> mtnviewmark: to return a tree without that node?
21:45:06 <tolkad> it's not as inefficient as you might think at first
21:45:20 <tolkad> much of the tree will simply be references to the old tree's branches
21:45:36 <mtnviewmark> (the guard vs. case thing is, perhaps mostly stylistic (though in this case the case version is slightly more efficient --- but I see you keep getting tempted to put in otherwise clauses, and case will keep you from that -- and should make you feel more certain that you've covered all the... cases!)
21:45:54 <mtnviewmark> correct: return a tree without the node
21:46:21 <pygmalion> mtnviewmark: right. so the easy cases should be those in which the node to be deleted lacks children
21:46:44 <tolkad> is there any efficiency difference bewteen case x of { True -> …; False -> … } and case x of { True -> …; _ -> … }
21:46:46 <tolkad> ?
21:46:49 <mtnviewmark> so ask your self this - can the root of that returned tree be the *same* value as the root of the input tree?
21:46:54 <tolkad> in GHC that is
21:47:14 <kmc> tolkad, doubtful
21:47:22 <kmc> you could use ghc-core and see if they produce the same Core code
21:47:54 <pygmalion> mtnviewmark: i'm not sure i understand your question. i think the answer is that it must be unless your deleting the root node
21:48:12 <mtnviewmark> tolkad: hard to imagine it would anything but very very small -- in which case go for textual clarity!
21:48:13 <tolkad> kmc: I have tried, apparently I have missing C library "pcre". I'm on Mac 10.5.8
21:48:22 <geotop> tolkad: think lazy evaluation
21:48:32 <mtnviewmark> pygmalion: thought experiment time
21:48:55 <tolkad> geotop: well, it has to check against the True branch first so they are equivalently strict
21:48:58 <mtnviewmark> so, you want to delete the node with k == 42 from some big tree, and 42 is in there, somewhere in the middle
21:49:02 <lars9> how to do static linking in ghc?
21:49:07 <mtnviewmark> put your mental finger on the node with the 42
21:49:13 <pygmalion> okay
21:49:18 <mtnviewmark> look at the node above it
21:49:36 <mtnviewmark> when the delete operation returns a new tree, will *that* node be the same?
21:49:52 <pygmalion> no because it has a different child on one side
21:50:00 <mtnviewmark> correct
21:50:10 <tolkad> lars9: http://www.haskell.org/haskellwiki/Web/Literature/Static_linking
21:50:18 <mtnviewmark> now, look at the node above that one... can this grandparent node be the same?
21:50:20 <geotop> I'm on mac too... I use the macports libraries
21:50:32 <kmc> lars9, by default all haskell code is statically linked
21:50:36 <kmc> do you need the system C lib and such to be static too?
21:50:55 <pygmalion> mtnviewmark: hmm. well i guess since everything in the tree below it is different, then no. so the root node must always change. 
21:51:03 <mtnviewmark> bingo!
21:51:21 <lars9> kmc tolkad i see, let me learn more details thanks
21:52:13 <mtnviewmark> so, now in your findNode code, as it walks down, is it building up a new set of nodes?
21:52:42 <pygmalion> mtnviewmark: no. but should it be?
21:53:00 <mtnviewmark> in all three cases I see it building up a new node (notice the ANode constructor being used each time)
21:53:19 <lars9> > mempty :: String
21:53:20 <lambdabot>   ""
21:53:20 <mtnviewmark> but in one of those cases, the node it builds is the node it came in with....
21:54:06 <lars9> @instances Monoid
21:54:07 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:54:57 <pygmalion> mtnviewmark: oh okay, yes i suppose it is then. just some confusion on my part regarding syntax. i see now. so is that not what i want?
21:55:19 <mtnviewmark> ask yourself this: (back to our big tree wtih 42) --- looking at the root node of the big tree, when I delete the 42 node, how will the new root node look? Will the k be the same? the v? the left? the right?  (assuming 42 is NOT at the root, but lower down)
21:55:58 <pygmalion> k,v will be the same. depending on the k of the root node, either left or right will be different
21:56:08 <tolkad> let's say we have data Tree k v = TreeBranch { treeLeft :: Tree k v; treeRight :: Tree k v; treeKey :: k } | TreeLeaf { treeKey :: k; treeValue :: v }
21:56:11 <mtnviewmark> and the other side will be ?
21:56:23 <pygmalion> mtnviewmark: the same. 
21:56:40 <tolkad> mtnviewmark: we only have to reconstruct the direct path from the root to the leaf we are changing
21:56:47 <mtnviewmark> good! spot on!  Now - that looks to me like exactly what you've expressed in the key < k and key > k cases, no?
21:56:50 <tolkad> mtnviewmark: all other branches can just be references
21:56:54 <tolkad> referenced*
21:56:57 <mtnviewmark> right
21:56:59 <pygmalion> mtnviewmark: yes i think so. 
21:57:19 <tolkad> oh wait
21:57:21 <mtnviewmark> well - you can't tell if they are copied or not... but yes, if you are thinking von Neumann, then yes
21:57:23 <mtnviewmark> :-)
21:57:26 <pygmalion> mtnviewmark: so the EQ case (i've changed it away from guards) needs to be returning something else
21:57:36 <mtnviewmark> BINGO
21:57:39 <tolkad> @instances a
21:57:40 <lambdabot> Couldn't find class `a'. Try @instances-importing
21:57:47 <tolkad> @instances-importing
21:57:47 <lambdabot> Plugin `instances' failed with: Prelude.last: empty list
21:57:58 <pygmalion> mtnviewmark: ah should it take the greater k from left or right and make it the new root?
21:58:04 <tolkad> @help instances-importing
21:58:04 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
21:58:11 <pygmalion> or i guess that's for the delete function
21:58:25 <pygmalion> mtnviewmark: oh it should just be returning k?
21:58:36 <tolkad> @instances-importing Prelude Eq
21:58:37 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:58:39 <mtnviewmark> so - let's continue the thought experiment: AH, here's the node with k == 42 and some v (= "The answer", perhaps?) 
21:58:53 <mtnviewmark> after we delete it what should this node look like?
21:59:11 <tolkad> @instances-importing Unsafe.Coerce Eq
21:59:12 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:59:17 <tolkad> @instances-importing Unsafe.Coerceasdf Eq
21:59:17 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
21:59:29 <tolkad> > unsafeCoerce 5 :: Bool
21:59:30 <lambdabot>   Not in scope: `unsafeCoerce'
21:59:35 <tolkad> darn it
21:59:50 <pygmalion> mtnviewmark: well it's k and v will change to the k and v of the root of either left or right (as everything shifts up)
21:59:52 <mtnviewmark> we've got a k we no longer want... a v that we supposedly are happy to lose too.... what do we do with left and right
22:01:21 <mtnviewmark> perhaps you are jumping one step ahead --- you've got a left tree and a right tree - you need a node --- assume we'll get to it later, but what is the type and name of this function you need here in the EQ case?
22:02:15 <pygmalion> mtnviewmark: i guess i'm not realy sure what i want to be returning. i think i just want the nodei itself but i don't really see how to grab that
22:02:56 <mtnviewmark> well - we've already agreed that you *don't* want the node itself -- the node itself is  ANode (k,v) left right --- and that can't be right
22:03:19 <mtnviewmark> you want a new node.... what are the inputs to some function that is going to compute this new node?
22:03:30 <pygmalion> hmm. a key and a value.
22:03:37 <pygmalion> and a left and right child
22:03:42 <pygmalion> if existent
22:03:44 <mtnviewmark> what have you got to work with here?  we don't want that k and that v
22:04:02 <mtnviewmark> right left and right --- oh, they are existant  -- you pattern matched them there at the top of the function
22:04:06 <mtnviewmark> :-)
22:04:25 <pygmalion> true enough.
22:04:37 <pygmalion> so do i just want left and right?
22:04:39 <mtnviewmark> so, you need         EQ -> someFunctionThatReturnsANode left right
22:04:57 <mtnviewmark> what is the type of that function (always start with the types)
22:05:22 <pygmalion> AST -> AST -> AST
22:05:37 <mtnviewmark> well.. AST k v -> AST k v -> AST k v
22:05:38 <mtnviewmark> but yes
22:05:45 <mtnviewmark> now - can you think of a name for that function?
22:05:53 <mtnviewmark> wha'ts it doing?
22:06:01 <pygmalion> findParent
22:06:04 <pygmalion> or findRoot
22:06:20 <mtnviewmark> put your finger on that 42 node....
22:06:46 <pygmalion> okay
22:06:51 <mtnviewmark> you've got two sub trees.... you want a new tree.... I'd call that function....
22:07:07 <pygmalion> combine? or fold?
22:07:14 <mtnviewmark> combine works for me
22:07:34 <mtnviewmark> (fold has another meaning in functional systems...)
22:07:43 <mtnviewmark> I might have used merge
22:07:51 <pygmalion> mtnviewmark: yes i wasn't sure if combine did too. we've already used foldr and foldl
22:07:59 <pygmalion> mtnviewmark: yeah i like merge better
22:08:04 <pygmalion> or mergeTrees
22:08:07 <mtnviewmark> so    EQ -> combineTree left right
22:08:15 <mtnviewmark> right?
22:08:21 <pygmalion> yes
22:08:27 <lars9> is newtype Writer w a = Writer { runWriter :: (a, w) }  the same as: newtype Writer w a = Writer (a, w), runWriter (Writer (a,w)) = (a,w) ?
22:08:36 <c_wraith> lars9: yes
22:08:42 <lars9> c_wraith: thanks
22:08:59 <tolkad> wait maybe not
22:09:03 <mtnviewmark> okay - setting aside mergeTrees / combineTrees for now --- look at the function you now have....
22:09:08 <tolkad> they might have different laziness
22:09:15 <mtnviewmark> what does it do? is "findNode" the right name?
22:09:26 <c_wraith> tolkad, those two are completely identical.
22:09:40 <pygmalion> mtnviewmark: it's really returning a new subtree
22:09:53 <mtnviewmark> and what is the property that this subtree has?
22:09:54 <pygmalion> it's returning everything below the node to be deleted
22:10:07 <tolkad> c_wraith: not runWriter (Writer ~(a,w)) = (a,w)?
22:10:20 <c_wraith> tolkad, it's a newtype.  there's nothing to evaluate there anyway.
22:10:40 <mtnviewmark> hmmm....   what is the value of    findNode rootOfMyBigTree 42   ?
22:10:56 <pygmalion> mergeTrees left right
22:11:09 <mtnviewmark> (remember, 42 is in the middle, not at the node rootOfMyBigTree)
22:11:32 <pygmalion> right but won't it eventually recurse to that?
22:11:37 <mtnviewmark> yup
22:11:43 <mtnviewmark> but what is it doing overall?
22:11:50 <mtnviewmark> is "findNode" the right name?
22:12:48 <pygmalion> mtnviewmark: findNode is recursing through our tree to locate the three that 42 is the root of and then apply mergeTrees to left and right of that tree
22:13:03 <mtnviewmark> isn't it doing something along the way?
22:13:30 <pygmalion> creating new nodes for everything above it
22:13:34 <mtnviewmark> right - 
22:14:07 <mtnviewmark> so it isn't just "locating"
22:14:25 <pygmalion> mtnviewmark: true. it's rebuilding
22:14:36 <mtnviewmark> I'm going to pretend we've renamed this function foo
22:15:00 <mtnviewmark> the last case is then     GT -> ANode (k, v) left (foo right k)
22:15:15 <pygmalion> correct
22:15:19 <lars9> suppose we have implemented findNodeInBinaryTree :: (a - > Bool) -> Tree a -> Maybe a; if we want to also return the path from root to the found node, is Writer suitable?
22:16:19 <mtnviewmark> I'm going to read that in English:  "if the key was greater than k, then the result of foo'ing this node is a new node with the same k,v and left, but with a foo'd right"
22:16:45 <pygmalion> mtnviewmark: yes i see that reading.
22:16:56 <mtnviewmark> lars9: as in the Writer Monad? waaaaaay overkill
22:17:03 <mtnviewmark> rename "foo"
22:17:20 <mtnviewmark> I don't think if you substituted "find" for "foo" that sentence would make sense
22:17:28 <pygmalion> mtnviewmark: i agree.
22:17:34 <mtnviewmark> what should it be?
22:19:09 <mtnviewmark> correcting myself, this version is more accurate:  "if the key was greater than k, then the result of foo'ing k on this node is a new node with the same k,v and left, but with a foo'ing k on right"
22:19:43 <tolkad> how do unpack pragmas interact with lazy pattern matching?
22:20:12 <pygmalion> mtnviewmark: foo is basically just moving down through the tree without leaving any changes in its wake until it reaches what it wants. i'm not sure beyond that what it's goal is until it reaches the EQ case
22:20:29 <pygmalion> i'm sorry, i must be missing something
22:20:35 <tolkad> oh it has to be strict already
22:20:45 <mtnviewmark> it looks to me like it makes a change at EVERY step in it's wake...
22:21:02 <mtnviewmark> if there were no change then we'd see     GT -> ANode (k, v) left right
22:21:20 <pygmalion> mtnviewmark: well at each stop, it's making that stop the root of the tree
22:21:40 <mtnviewmark> but you are perhaps being misled by "make a change" -- change is really not a good concept here
22:22:21 <mtnviewmark> "foo is basically moving down through the tree, returning an altered sequence of nodes until it reaches the one it wants"
22:22:36 <pygmalion> mtnviewmark: right
22:23:15 <mtnviewmark> let's assume you've got mergeTrees done ---- now you have foo .... what is left to write deleteNode?
22:23:51 <pygmalion> just combining them i suppose?
22:24:14 <pygmalion> is foo finding the two trees that i want to input into mergeTrees?
22:25:54 <mtnviewmark> it is doing something much more than just that
22:26:01 <mtnviewmark> it only does that in the EQ case,
22:30:04 <pygmalion> mtnviewmark: i'm having trouble seeing the LT and GT cases as anything other than leading to the EQ case. foo is traversing the tree down to the node it needs. it's setting the root maybe. i can't think of something else that it is doing
22:30:25 <mtnviewmark> okay - so there is no setting going on - you can't change anything, right?
22:31:01 <pygmalion> mtnviewmark: no i can't change anything, but i can sort of recenter i guess? that's what i mean by setting.
22:31:15 <pygmalion> that doens't make much sense now that i see it in words
22:31:18 <pygmalion> doesn't*
22:33:02 <mtnviewmark> http://hpaste.org/paste/41117/another_function#p41123
22:33:09 <rothwell> 'lo. i'm attempting to throw together a little reusable tcp/ip server but am having a strange problem with mvars (again): http://waste.corolla.ath.cx/2010/11/03/TCP_Server.hs
22:33:15 <mtnviewmark> what does that do
22:33:27 <rothwell> for some reason, in client_main, it seems as if the withMVar/modifyMVar_ calls never actually happen
22:33:39 <rothwell> the map passed to the callback_client_* functions is always empty
22:33:45 <mtnviewmark> should have been Empty on the 2nd line
22:33:54 <mtnviewmark> locateNote Empty _
22:34:02 <pygmalion> mtnviewmark: got it. looking now.
22:34:53 <pygmalion> mtnviewmark: okay so we have a function taking a tree and a key. when the root of the tree has a key (k) equal to the key given, we return the tree.
22:35:24 <pygmalion> when key < k, we take just the left as the tree and key again as our key
22:35:41 <pygmalion> key > k, take the right ... ^
22:36:05 <mtnviewmark> right -- so - this function doesn't do anything "along the way" does it?
22:36:20 <pygmalion> no. it just gets to the node down stream
22:36:31 <rothwell> http://waste.corolla.ath.cx/2010/11/02/server_main.hs (example server, for the above)
22:36:32 <mtnviewmark> but foo does.... 
22:37:18 <mtnviewmark> taking another tack.....   if we had mutable state, we'd drill down to the node to delete, leaving the rest all untouched, and then fiddle about the node to delete
22:37:57 <mtnviewmark> looks to me ('cause you named it 'findNode') that you were planning on doing that... and THEN figuring out how to re build the stuff on top - since we can't mutate
22:38:06 <pygmalion> mtnviewmark: right. 
22:38:10 <mtnviewmark> aha
22:38:16 <pygmalion> mtnviewmark: but i ended up rebuilding the stuff on top as i went?
22:38:26 <mtnviewmark> you did, didn't you?
22:38:29 <pygmalion> yes
22:38:32 <mtnviewmark> aha
22:38:38 <pygmalion> ANode (k,v) (findNode left k) right
22:38:45 <pygmalion> is rebuilding the tree behind it
22:38:47 <pygmalion> foo is*
22:41:57 <mtnviewmark> the key to these things is recursion -- in the real inductive sense.... "if I'm going to delete a key from a node I have three cases: if the key is at this node I somehow build a tree with just the stuff from left and right; if the key is in the left tree, then I build a node with the same k,v and right, but with key deleted from left....."   
22:43:09 <mtnviewmark> rather than "rebuild in its wake" it might be more accurate to say "rebuild the node right here, and push the problem one step out in front"
22:43:12 <pygmalion> mtnviewmark: is findNode actually deleting the node then??
22:43:16 <mtnviewmark> yes
22:43:18 <mtnviewmark> yes it is
22:43:22 <pygmalion> wow.
22:43:43 <pygmalion> funny how that happened...
22:43:57 <Rotaerk> hmm I didn't find this in hoogle; anyone know of a standard name for this?  (a -> b) -> (a -> c) -> a -> (b,c)
22:44:03 <Rotaerk> I'm thinking of calling it "fork2"
22:44:52 <Rotaerk> takes a value and performs two transforms on it, returning those transforms in a tuple
22:45:10 <mtnviewmark> notice the shift in perspective --- rather think from where you end up, and then worry about rebuilding behind....  think from where you are - what would have to happen here, now, one part of which may be doing it all again on a smaller part of the data
22:45:30 <mtnviewmark> :t (&&&)
22:45:31 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
22:45:57 <pygmalion> mtnviewmark: very nice. slick even. i see how that makes more sense. so then the heavy lifting really occurs in mergeTrees
22:46:02 <Rotaerk> hmm
22:46:10 <mtnviewmark> :t ((+5) &&& (*100)) 7
22:46:11 <lambdabot> forall b. (Num b) => (b, b)
22:46:19 <mtnviewmark> > ((+5) &&& (*100)) 7
22:46:20 <lambdabot>   (12,700)
22:46:43 <mtnviewmark> well - I'd say the effort is about split 50/50
22:47:02 <mtnviewmark> but you're going to have to now think the same way about merge trees: think from the top
22:47:04 <Rotaerk> thanks
22:47:13 <pygmalion> mtnviewmark: yeah. let me have a go at writing mergeTrees and paste it...
22:47:51 <mtnviewmark> "I've got two trees I want to merge... in case x I do... in case y I do.... in case z i do something which also involves merging two smaller trees ..."
22:48:31 * mtnviewmark thinks functional programming is "Be Here Now" programming
22:49:09 * mtnviewmark and imperative programming is "Oy my to do list is getting long" programming
22:53:35 <pygmalion> mtnviewmark: okay i have something... definitely missing something though. my LT-EQ-GT aren't correct yet, for sure http://hpaste.org/paste/41117/heres_a_start#p41124
22:53:52 <pygmalion> mtnviewmark: to clarify in the context of our earlier thought experiment,
22:54:01 <pygmalion> let's say we have 42 again
22:54:18 <pygmalion> it has children of 40 on the right and 50 on the left
22:54:47 <pygmalion> i want to take 40 and make it's right child 50 and it's left child whatever it's original left child was?
22:54:51 <pygmalion> is that correct?
22:57:35 <mtnviewmark> wait - what happend to 40's original right child? did you just abondon it? poor orphan....
22:57:42 <mtnviewmark> so cold outside....
22:58:00 <pygmalion> mtnviewmark: it becomes the child of 50
22:58:06 <pygmalion> ah. so that's the trick of it
22:58:11 <mtnviewmark> not quite
22:59:07 <pygmalion> one moment.. i'm drawing this out with pen and paper to get a better visual
22:59:23 <mtnviewmark> so let me restate what you said: "I've got two trees, one with 40 and one with 50. I'm going to make a new tree with a root node of 40 and the original 40's left, and for this new 40's right I'm going to .... X"
22:59:29 <mtnviewmark> what was X?
23:00:09 <pygmalion> X was 50, no?
23:00:47 <mtnviewmark> yeah but there was that poor orphan out in the cold (original 40's right)....
23:01:43 <mtnviewmark> so let's see, you've got 40's original right tree... and the tree rooted at 50.... and we've got to get them somehow to be the right tree of the new 40 node.... 
23:01:52 <mtnviewmark> what function could *that* be?
23:02:07 <pygmalion> mergeTree
23:02:10 <pygmalion> all the way down...
23:02:11 <mtnviewmark> :-)
23:02:29 <pygmalion> lemme do a quick rewrite...
23:03:19 <pygmalion> to clarify, what parameters should i be taking/caring about in the first line of mergeTrees?
23:03:37 <pygmalion> i.e. what am I comparing? if anything? it seems like i'll be taking the left tree as the new root no matter what
23:04:31 <mtnviewmark> ah - well..... here is where it requires some design: in the case where mergeTree is used from delete, you KNOW that the first argument has a key that is less than the second argument
23:05:01 <mtnviewmark> strike that
23:05:06 <mtnviewmark> I'm hallucinating again
23:05:13 <mtnviewmark> what I meant to say was.....
23:05:18 <pygmalion> :)
23:05:26 <mtnviewmark> given two trees is there more than one way to merge them?
23:05:39 <mtnviewmark> are there more than one legal tree that contains the union of those nodes?
23:06:00 <pygmalion> yes
23:06:18 <mtnviewmark> then, perhaps your choice of left bias here is fine... but arbitrary!
23:06:47 <pygmalion> mtnviewmark: can it be anything but arbitrary?
23:07:02 <pygmalion> mtnviewmark: i.e. is there a better way?
23:07:24 <mtnviewmark> there is a whole literature and countless algorithms for balanced trees
23:07:36 <mtnviewmark> but it depends on what you are optimizing for
23:07:52 <mtnviewmark> whereas here, I think you are optimizing for clarity and understanding!
23:08:02 <pygmalion> mtnviewmark: if it makes a difference in your answer, my instructor noted that we should (in the case of both left and right subtrees) consider how we might use a function bstMax that returns the key value with the largest key in the tree
23:09:39 <mtnviewmark> well - it is an issue of specification and contract the function is to fulfill. In this case, we want a mergeTrees that makes our delete work.... and I didn't see any requirement that the AST must have certain balance properties
23:11:06 <pygmalion> mtnviewmark: well i don't know that we must use the "bstMax" if we achieve the same result. does bstMax imply something about the tree's properties?
23:11:09 <mtnviewmark> so indeed, your approach will effectively hang the right tree on the right most empty spot in the left tree
23:12:21 <mtnviewmark> seems to me that having the largest key  in the pair of trees gives you nothing interesting for merging
23:12:41 <mtnviewmark> I can't really see where the instructor was leading with bstMax...
23:12:49 <lars9> is there a BST implementation? hoogle cant find it
23:13:33 <pygmalion> mtnviewmark: okay. me neither (obviously or else i would've mentioned it). i'd prefer (and i think he would to) to go with an approach i understand and that seems natural, so this tack seems fine. 
23:13:37 <lars9> *package*
23:13:54 <pygmalion> mtnviewmark: is it safe to assume then that i don't need a "case compare" in mergeTrees?
23:14:09 <mtnviewmark> I think so
23:14:30 <pygmalion> mergeTrees (ANode (k,v) left1 right1) (ANode (l,w) left2 right2) =  (ANode (k,v) (mergeTrees left1 right1) (ANode (l,w) left2 right2)
23:15:25 <mtnviewmark> I don't think that is what you said you were goign to do
23:15:34 <mtnviewmark> what will be the left of the new node?
23:16:27 <pygmalion> mtnviewmark: the merge of the original left and right, i.e. of the original left and the one that i had orphaned?
23:17:16 <mtnviewmark> re-read our conversation
23:17:34 <pygmalion> okay.
23:18:43 <pygmalion> mtnviewmark: agh whoops. okay so we want:
23:19:25 <pygmalion> (ANode (k,v) left1 (mergeTrees right1 (ANode (l,w) left2 right2))
23:20:29 <mtnviewmark> yes
23:21:14 <mtnviewmark> now .... I see (ANode (l,w) left2 right2) in both the head of the function and the body ---- just replace it with node2 in both places... or a2.... or just a
23:21:38 <mtnviewmark> doesn't matter what it is, right? you're just going to pass it along in the recursion
23:21:47 <pygmalion> mtnviewmark: correct
23:22:05 <mtnviewmark> you may be surprised at how small and concise mergeTrees ends up being
23:22:23 <pygmalion> mtnviewmark: unfortunately, it works for some of my nodes, but isn't working for others. "Non-exhaustive patterns in delete"
23:22:34 <mtnviewmark> paste away
23:22:54 <pygmalion> mtnviewmark: okay. i think (hunch) that maybe it's because i don't have cases for when the subtrees are empty?
23:23:31 <mtnviewmark> well, perhaps... but if you write this carefully, you won't need that many cases (I think two, actually!)
23:24:13 <pygmalion> http://hpaste.org/41127/delete
23:24:16 <pygmalion> error is below
23:24:33 <pygmalion> those last few functions were given as helpers, i'm doing my testing on the tree "ast"
23:25:06 <mtnviewmark> lines 9 and 10 are identical
23:25:29 <pygmalion> mtnviewmark: yeah i was in the midst of trying to fix the problem when i pasted, sorry
23:25:55 <mtnviewmark> and again, in those lines, (ANode (k,v) left right) appears in both the head and the body --- reduce!
23:26:04 <mtnviewmark> (reuse and recycle, too!)
23:26:19 <pygmalion> mergeTrees _ a  = a
23:26:31 <mtnviewmark> no, you need to match the Empty
23:26:48 <pygmalion> mtnviewmark: or it will catch everything
23:26:49 <pygmalion> duh
23:27:30 <lars9> need help here, anyone can tell me how (+) <$> (*2) <*> (+10) works?
23:28:10 <mtnviewmark> :t (+) <$> (*2) <*> (+10) 
23:28:11 <lambdabot> forall a. (Num a) => a -> a
23:28:44 <lars9> first of all, how are those three pieces associated?
23:28:59 <mtnviewmark> :t (+) <$> (*2)
23:29:00 <lambdabot> forall a. (Num a) => a -> a -> a
23:29:16 <mtnviewmark> :t (+) <$>
23:29:17 <lambdabot> parse error (possibly incorrect indentation)
23:29:23 <mtnviewmark> :t ((+) <$>)
23:29:24 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
23:29:47 <lars9> what does (+) <$> do?
23:30:43 <mtnviewmark> it applies the (+) to the value inside the functor f
23:31:06 <mtnviewmark> so if f is Maybe, then given a Maybe Int, you get a Maybe (Int -> Int)
23:31:25 <pygmalion> mtnviewmark: i've added my insert to the paste because i'm wondering if maybe it's causing the problem since it is effectively generating the test tree
23:32:08 <lars9> :t ((+) <$>) (1+)
23:32:09 <lambdabot> forall a. (Num a) => a -> a -> a
23:32:14 <lars9> :t ((+) <$>) (1+) 2 3
23:32:15 <lambdabot> forall a. (Num a) => a
23:32:20 <lars9> > ((+) <$>) (1+) 2 3
23:32:21 <lambdabot>   6
23:32:36 <lars9> > ((+) <$>) (7*) 2 3
23:32:37 <lambdabot>   17
23:32:49 <mtnviewmark> insert looks fine
23:33:03 <mtnviewmark> lars9: so consider this first
23:33:26 <mtnviewmark> > (+) <$> Maybe 10 <*> Maybe 7
23:33:27 <lambdabot>   Not in scope: data constructor `Maybe'Not in scope: data constructor `Maybe'
23:33:35 <lars9> :t ((+) <$>) Just
23:33:36 <lambdabot> forall a. (Num (Maybe a)) => a -> Maybe a -> Maybe a
23:34:00 <mtnviewmark> > (+) <$> Just 10 <*> Just 7
23:34:00 <lambdabot>   Just 17
23:34:08 <lars9> :t ((+) <$>) Just 3 (Just 5)
23:34:09 <lambdabot> forall a. (Num (Maybe a), Num a) => Maybe a
23:34:13 <lars9> > ((+) <$>) Just 3 (Just 5)
23:34:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a))
23:34:14 <lambdabot>    arising from a use of...
23:34:34 <Veinor> > (+) <$> (Just 3) <*> (Just 5)
23:34:34 <lambdabot>   Just 8
23:34:35 <mtnviewmark> so whereas <$> applies a function inside a functor,  <$> takes a function within a functor, and applies it inside a functor
23:35:04 <mtnviewmark> in this case it took our Maybe (Int -> Int)  and applied it to the Int inside the Maybe Int
23:35:08 <mtnviewmark> all well and good
23:35:25 <mtnviewmark> the craziness is that  (-> a) is a Functor
23:35:27 <lars9> i see, it explains, let me think
23:35:46 <mtnviewmark> er (->) a is a functor
23:37:01 <mtnviewmark> > ((*) <$> (+1))  2 6
23:37:02 <lambdabot>   18
23:37:52 <pygmalion> mtnviewmark: so i've narrowed down my issue. it's only having a problem when the node to be deleted is a right child of any other node
23:38:24 <sm> evening all
23:38:36 <sm> the HTTP package can't handle https: can it ? how do I do that ?
23:38:41 <mtnviewmark> did you fix the GT case in delete?
23:38:46 <mtnviewmark> you have a transcription error in there
23:39:08 <lars9> so ((+) <$> (*2)) 3 == what?
23:39:41 <pygmalion> mtnviewmark: aghhh! that was it! haha. well it works now...
23:39:44 <lars9>  (6+) ?
23:39:46 <pygmalion> woo!
23:39:52 <mtnviewmark> lars9 - yes
23:40:31 <lars9> mtnviewmark: where is the (*) then?
23:40:41 <lars9> (2*3)
23:40:46 <mtnviewmark> right
23:41:31 <lars9> mtnviewmark: can you please convert (+) <$> (*2) to simpler code?
23:41:44 <lars9> \x y -> what
23:42:15 <mtnviewmark> \x y -> ((x*2) +)
23:42:28 <neshatcsyahoocom> who can help me in assignment?
23:42:38 <mtnviewmark> well all - bed time here
23:42:52 <neshatcsyahoocom> who can help me in haskll assignment?
23:42:55 <pygmalion> mtnviewmark: THANK YOU SO MUCH. i really understand the task and my solution
23:42:59 <mtnviewmark> best of luck, pygmalion and lars9
23:43:03 <pygmalion> mtnviewmark: you're a fabulously patient teacher
23:43:06 <mtnviewmark> excellent! 
23:43:23 <mtnviewmark> the payoff is when the students utters "wow..."
23:43:26 <lars9> mtnviewmark: thanks
23:43:27 <mtnviewmark> which, you did!
23:43:28 <pygmalion> mtnviewmark: thanks again. have a good night :)
23:43:31 <mtnviewmark> laters
23:44:40 <neshatcsyahoocom> who can help me in haskll assignment?
23:45:14 <danderson> neshatcsyahoocom: if you only ask meta-questions, we'll never find out
23:45:19 <danderson> what are you having trouble with?
23:45:39 <lars9> @src fmap
23:45:39 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
23:45:47 <neshatcsyahoocom> heyyyyyyyyyyyyyy in need to submit some assignments in haskell 
23:45:51 <Axman6> @src Either fmap
23:45:52 <lambdabot> fmap _ (Left x) = Left x
23:45:52 <lambdabot> fmap f (Right y) = Right (f y)
23:46:08 <Axman6> lambdabot: you need to ask for a specific implementation
23:46:16 <Axman6> neshatcsyahoocom: what is your question
23:46:22 <lars9> Axman6: thanks
23:46:30 <Axman6> neshatcsyahoocom: we can help you, but we won't do your homework for you
23:47:20 <neshatcsyahoocom> finding second max of the given list with foldr or foldl
23:48:28 <Axman6> neshatcsyahoocom: and what do you have so far? how do you think you should do it?
23:49:00 <neshatcsyahoocom> i am asking u !!
23:49:13 <Axman6> we wont do your homework for you, i already told you that
23:50:27 <lars9> @instances Functor
23:50:28 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:50:41 <Axman6> @src RWST fmap
23:50:42 <lambdabot> Source not found. :(
23:50:45 <Axman6> :(
23:51:40 <lars9> in \x -> x + 1, which part is a functor?
23:51:45 <neshatcsyahoocom> why u can not do my assignment ?
23:51:56 <Axman6> ...
23:52:12 <Axman6> because that's your job. assignemtns are there to show that you can do the work, and aren't an idiot
23:52:19 <Axman6> assignments*
23:52:51 <tolkad> neshatcsyahoocom: people in here will be happy to help you gain the understanding that you need to complete your assignment
23:53:00 <Axman6> lars9: well, functions are functors.. but don't worry about that. \x -> y is an annonymous function
23:53:02 <yf`> Aha
23:53:08 <lars9> ((->) \x) ? looks so weired
23:53:27 <Axman6> -> isn't a function, it's syntax
23:53:32 <neshatcsyahoocom> u are very bad programmer 
23:53:43 <Axman6> neshatcsyahoocom: no, you are a very bad programmer, obviously
23:53:46 <neshatcsyahoocom> thatnkssssssssssssssssss
23:54:14 <neshatcsyahoocom> i m not programmer
23:54:16 --- mode: ChanServ set +o quicksilver
23:54:19 <danderson> Axman6: obvious troll is obvious, leave it alone and it'll go away :)
23:54:22 <tolkad> neshatcsyahoocom: it's has nothing to do with the "fairness" of you having to do work, we just want to make sure you gain an understanding form your homework. if we just did it for you we would be cheating you out of that
23:54:22 <neshatcsyahoocom> am manager
23:54:26 <lars9> Axman6: so every function is a functor?
23:54:26 <Axman6> neshatcsyahoocom: and if you keep asking for us to do your assignment for you, i will have no problem finding your university lecturer and telling them about this
23:54:34 <tolkad> from your*
23:54:36 <tolkad> it has*
23:54:49 <quicksilver> neshatcsyahoocom: ask a specific question or be quiet.
23:55:00 <tolkad> lol "am manager". ok that's a troll
23:55:20 <Axman6> lars9: ok, would you like a lesson in what functors are?
23:55:27 <Axman6> at least what functors are in haskell?
23:56:22 <Axman6> lars9: they're probably one of the easiest classes to get your head around, except maybe things like Num
23:56:47 <lars9> Axman6: anything can be applied something with fmap?
23:57:11 <Axman6> sort of...
23:57:19 <Axman6> ok, so, for lists, we have the function map
23:57:21 <Axman6> :t map
23:57:22 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:57:35 <lars9> Axman6: so what does fmap something ((->) r) do?
23:57:40 <Axman6> which takes a function, and a list, and applies the function to every element in the list, right?
23:58:14 <Axman6> lars9: we'll get to that, i want to make sure you completely understand the Functor class first, if that's ok?
23:58:24 <tolkad> lars9: Functors are types of kind * -> * (any type with one parameter) where if "f" is a Functor type and "a" and "b" is are other types there is a function "fmap" with the type signature Functor f => (a -> b) -> f a -> f b
23:58:35 <lars9> Axman6: i (think i) understand functor, but just do not understand how to fmap something on a function
23:58:59 <Axman6> ok, well, let's see what we get from the type of fmap for functions
23:59:07 <tolkad> lars9: that is what we mean when we write class Functor f where fmap :: (a -> b) -> f a -> f b
23:59:26 <Axman6> fmap :: (a -> b) -> (a -> r) -> (b -> r), right?
23:59:32 <tolkad> uh no
23:59:36 <Axman6> uh, that's not right
23:59:45 <tolkad> fmap :: Functor f => (a -> b) -> f a -> f b
23:59:52 <Axman6> tolkad: shush
