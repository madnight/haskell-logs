00:00:14 <ClaudiusMaximus> flux: ta
00:01:41 <shachaf> ClaudiusMaximus: You know flux was answering your question, right?
00:04:24 <ClaudiusMaximus> shachaf: yep, 'ta' is british for "thank you most kindly.  would you like another cup of tea?"
00:11:09 * ivanm isn't british, but says "ta" all the time
00:16:15 <ClaudiusMaximus> hmm, NaN strikes again :'(
00:18:19 <McManiaC> dont do 0/0!
00:22:20 <aefjt> > 0 / 0 :: CReal
00:22:24 <lambdabot>   mueval-core: Time limit exceeded
01:07:01 <augur> byorgey: how does enumerate avoid looping forever on P = X + P*P?
01:20:12 <turiya> if i have two pointers with the same length can i add them element wise in haskell?
01:20:32 <ivanm> "pointers"/
01:20:35 <ivanm> ?
01:20:44 <turiya> ForeignPtr's
01:21:01 <turiya> i can do it on the C side..
01:21:11 <turiya> using FFI
01:21:13 <ivanm> I didn't know they had a "length"...
01:21:18 <ivanm> admittedly, I've never done any FFI
01:21:58 <turiya> length might not be the right word, 
01:22:45 <turiya> i did not know how to put it any other way.
01:22:52 <Ke> I bet ivanm knows what you mean
01:23:13 <ivanm> nope
01:23:31 <ivanm> I bet Ke knew that I didn't... >_>
01:23:37 <sipa> pointers to mrmory objects of the same size?
01:23:48 <turiya> sipa: yes
01:24:29 <sipa> and what is 'add elementwise'
01:24:40 <Ke> ivanm: wow, you really aren't a C programmer
01:24:49 <ivanm> nope
01:25:16 <ivanm> I did half a semester on it, and have avoided it since (apart from quicly glancing through C code to try and guesstimate how something works so I can re-implement it in Haskell)
01:25:36 <turiya> if i have [1,2,3,4] and [5,6,7,8] (they are not lists here) i want something like [6,7,8,9]
01:25:41 <turiya> sorry..
01:25:50 <turiya> [6,8,10,12]
01:27:11 <turiya> using FFI, on the C side, i can always add them with a for loop
01:27:12 <Jafet> Looks like turiya isn't, either
01:27:23 <Jafet> By "pointer" do you mean "the array that is pointed to by the pointer"
01:28:01 <ClaudiusMaximus> @hoogle advancePtr
01:28:01 <lambdabot> Foreign.Marshal.Array advancePtr :: Storable a => Ptr a -> Int -> Ptr a
01:28:22 <turiya> oh..
01:28:38 <Ke> Jafet: It's extremely common to incorrectly alias pointer to an "array" to array to the chunck of memory reserved that malloc returns
01:28:57 <sipa> you can't add pointers nor arrays in C
01:29:05 <sipa> do you mean add indices into an array?
01:29:10 <ClaudiusMaximus> mm, given that the MPFR webpage says "MPFR internal data such as flags, the exponent range, the default precision and rounding mode, and caches (i.e., data that are not accessed via parameters) are either global (if MPFR has not been compiled as thread safe) or per-thread (thread local storage). "
01:29:23 <ClaudiusMaximus> should i assume the worst and only use 'hmpfr' from the main thread?
01:29:28 <Jafet> It looks like turiya wants to pairwise add stuff in two arrays
01:29:29 <turiya> :(, my technical jargon is way too limited
01:29:30 <ivanm> turiya: zipWith (+) ? :p
01:29:31 <Ke> you usually assume that listener the interprets the corrections
01:29:45 <Jafet> Ke, unless you're in ##c (ha)
01:29:53 <Ke> =D
01:30:32 <Jafet> ClaudiusMaximus: well did you build your mpfr library with threading?
01:30:34 <turiya> i mean the normal C pointer
01:30:57 <turiya> meant*
01:31:18 <ClaudiusMaximus> turiya: you could perhaps write   zipWithP :: (a -> b -> c) -> Int -> Ptr a -> Ptr b -> Ptr c :: IO ()
01:31:30 <Ke> sipa: I think only C++ disallows pointer additions, though they don't make any sense in C
01:32:10 <turiya> ClaudiusMaximus: I am wondering if I can write such a zipWithP without needing to write explicit C code
01:32:16 <ClaudiusMaximus> Jafet: no clue, it's the distro package (ubuntu lucid 64bit), but i am using ghc -threaded - and hmpfr docs don't seem to mention anything about threading
01:33:10 <turiya> i will look at advancePtr
01:33:12 <ClaudiusMaximus> turiya: peek / poke / (`advancePtr`1)
01:33:15 <sipa> Ke: 
01:33:17 <sipa> test.c:7: error: invalid operands to binary + (have ‘char *’ and ‘char *’)
01:33:55 <turiya> ClaudiusMaximus: oh.. what do peek and poke do?
01:34:32 <sipa> read from and write to memory locations
01:34:34 <Jafet> A tribute to the infamous basic commands
01:34:49 <ClaudiusMaximus> @src Storable
01:34:49 <lambdabot> Source not found. There are some things that I just don't know.
01:34:50 <sipa> and, indeed Jafet :p
01:35:09 <Jafet> Isn't there a way to wrap your pointer in a nice haskell array interface?
01:35:11 <turiya> sipa: ok, can i always use peek and poke to replace C code?
01:35:36 <Jafet> Yes, but that's like writing C in BASIC from Haskell
01:36:05 <turiya> Jafte: array interface?
01:37:22 <Ke> sipa: ok
01:37:52 <sipa> turiya: do you need the FFI even?
01:38:36 <turiya> sipa: i dont know, i want to know if i can do away with it..
01:38:57 <sipa> you'd only need it to modify array elements?
01:39:42 <turiya> yes, for addition, subtraction, on arrays
01:39:56 <sipa> you know haskell itself also has arrays?
01:40:19 <sipa> and lists which can do about the same, but are very slow for random-access
01:40:53 <turiya> yes, i did know about arrays..
01:41:00 <turiya> i am using the hmatrix library
01:41:27 <turiya> which uses ForeignPtr's
01:41:41 <sipa> i don't know hmatrix
01:42:10 <turiya> I am basically trying to convert a ByteString into a Matrix
01:42:20 <turiya> ok
01:43:27 <Kaidelong> why is "if something is of class a, it is also of class b" undecidable?
01:43:37 <ivanm> I don't recall needing to use ForeignPtrs with hmatrix...
01:44:23 <Kaidelong> unless there is some other mechanism other than "instance (C a) => D a"
01:44:30 <ClaudiusMaximus> Kaidelong: because if it isn't now, someone might come along at a later date and add one
01:45:10 <Kaidelong> like perhaps the class itself providing default implementations of the other classes
01:46:07 <Kaidelong> ClaudiusMaximus: couldn't you complain about overlappin instances when that happens?
01:47:01 <turiya> ivanm: if the unexposed MC constructor is used, we can create a Matrix from a ForeignPtr
01:47:02 <ClaudiusMaximus> i think it would be hard to tell they are overlapping without whole-program compilation - i'm far from an expert here though
01:47:39 <turiya> but, i think i should just use a matrix addition function in the hmatrix library
01:48:21 <turiya> is there one such in hmatrix?
01:48:29 <ivanm> I believe so
01:48:44 <ivanm> that's kinda the whole point, isn't it? :p
01:49:08 <turiya> ivanm: u r right, i was not thinking straight
01:50:15 <turiya> the last time I checked I could not find a matrix addition function in hmatrix
01:51:18 <turiya> is it too easy that it is not included?
01:52:31 <turiya> i find it weird that such functionality is absent.. 
01:53:42 <osfameron> turiya: is a matrix an instance of Numeric ?
01:53:57 <osfameron> turiya: in which case, *perhaps*:   matrix1 + matrix2   will Just Work?
01:54:43 <osfameron> turiya: http://hackage.haskell.org/packages/archive/hmatrix/0.10.0.0/doc/html/Numeric-LinearAlgebra.html (linked to from hmatrix doc) says "It also provides instances of standard classes Show, Read, Eq, Num, Fractional, and Floating for Vector and Matrix"
01:54:59 <osfameron> so it sounds like you can just treat them as numbers, and use the standard (+), (-) etc. ops on them ?
01:55:18 <turiya> i typed :t Matrix in ghci
01:56:06 <turiya> it does not show that it is an instance of Num
01:56:24 <ibt> maybe you didn't import the instances of Num
01:56:32 <ivanm> turiya: :i Matrix
01:56:54 <turiya> oh yeah, i typed :i Matrix, not :t Matrix
01:58:05 <ivanm> which module?
01:58:18 <turiya> Data.Packed.Matrix
01:58:25 <ivanm> because using Numeric.LinearAlgebra and then doing ":i Matrix" says it is an instance of Num
01:58:38 <quicksilver> you need the module ivanm mentions, that's where the instances are
01:58:49 <ivanm> yeah, looks like it
01:58:55 <ivanm> and I got that module off osfameron ;-)
01:59:15 <quicksilver> they're actually in Numeric.Container I think, but that is re-exported by Numeric.LinearAlgebra
01:59:54 <ibt> looks like Numeric.Matrix to me..
02:00:04 <turiya> oh..
02:00:24 <quicksilver> ibt: there isn't a Numeric.Matrix in the hmatrix I'm looking at
02:00:45 <quicksilver> it's documented in the hackage summary, actually
02:00:46 <ibt> quicksilver: okay, i was looking at darcs
02:00:49 <quicksilver> Data.Packed: structure manipulation
02:00:54 <quicksilver> Numeric.LinearAlgebra: everything + instances of standard Haskell numeric classes
02:00:57 <turiya> i did a :i Matrix after :m + Numeric.LinearAlgebra
02:02:24 <turiya> i see some output where Num is mentioned but nothing like "instance Num Matrix"
02:02:46 <ivanm> instance (Container Matrix a, Num (Vector a)) => Num (Matrix a)
02:03:39 <turiya> ivanm: thanks, i understand now..
02:04:23 <ivanm> good-o
02:09:07 <turiya> thanks all for the help.. :)
02:10:09 <quicksilver> I wonder if hmatrix is actually fast, for small matrices.
02:10:44 <ivanm> with the marshalling, I would guess not
02:10:44 <quicksilver> it seems to me like the overhead of making an FFI call to multiple two sets of 16 numbers would outway the fact that the implementaiton is good.
02:11:17 <ClaudiusMaximus> 'Vec' is what I would use, probably - it can invert/solve matrices
02:11:41 <ClaudiusMaximus> but it's a bit unweildly with its type-level naturals
02:12:57 <quicksilver> ClaudiusMaximus: hackage name?
02:13:07 <quicksilver> oh, simply Vec
02:13:18 <quicksilver> uppercase-in-hackage-names--
02:13:48 * ivanm slinks away before anyone brings up his hackage packages with capitals in the names...
02:14:54 <quicksilver> ClaudiusMaximus: doesn't look likely to be particularly fast
02:15:02 <quicksilver> not particularly slow, either
02:15:11 <quicksilver> but they're just naive strict lists
02:15:28 <ivanm> QuickCheck-as-a-mandatory-dep--
02:15:37 <ClaudiusMaximus> quicksilver: there's a packed version too afaik
02:16:00 <quicksilver> ClaudiusMaximus: oh yes, so there is.
02:16:06 <quicksilver> I take it back :(
02:16:07 <quicksilver> :)
02:16:32 <quicksilver> although, multmm apparently unpacks them
02:25:16 <Jafet> Does ghc provide an interface to garbage collector information? I'm thinking of how to implement a transparent cache, if at all possible
02:25:40 <Jafet> (Without patching ghc, that is)
02:26:38 <FauxFaux> I see GHC.Weak.
02:26:55 <FauxFaux> </knowledge about gcs in general, not about ghc>
02:27:04 <Jafet> I'm supposing that weak pointers can be collected at any time, not just when memory runs out
02:27:57 <Jafet> Actually, if some other code gets hold of the cached stuff with a real pointer, the entire thing breaks. So I'm not sure if it can be transparent.
02:28:21 <FauxFaux> Java calls what you want a soft reference, but it's not a good policy for caching; go read up on it. ¬_¬
02:28:50 <quicksilver> Jafet: well, weak pointers will be collected on GC
02:29:01 <quicksilver> GHC has no concept of 'memory running out' normally
02:29:14 <quicksilver> it's normally run with an unlimited heap.
02:29:35 <quicksilver> a sensible cache suggests you have some configured 'pool' of memory for the cache
02:29:44 <quicksilver> you're going to have to do that manually, although it's not especially hard
02:29:52 <quicksilver> (adding another level of indirection most likely)
02:30:03 <quicksilver> hmm
02:30:13 <quicksilver> you could have your cache master object hold the strong pointer
02:30:17 <quicksilver> and clients only hold weak pointers
02:30:25 <quicksilver> then the cache master object is in control of when things can be collected.
02:30:37 <quicksilver> and it can limit the number it keeps live.
02:30:41 <FauxFaux> His question was "when can I, as the cache master, decide when to collect", though, quicksilver.
02:30:55 <quicksilver> that's not how I read his question.
02:31:05 <quicksilver> my solution answers the question I think he's asking :)
02:31:10 <Jafet> There's also the problem of making it look pure (which it is), even though it really isn't
02:31:46 <quicksilver> my suggestion could look pure
02:31:56 <quicksilver> the cache master could just be kept around in a state monad
02:31:58 <Jafet> quicksilver's answer would work in theory, though I don't know how to implement it
02:33:16 <Jafet> But for a recursive structure, I was thinking of putting weak pointers in only certain branches. But if clients get hold of intermediate strong pointers in the middle, they essentially block the process. So the whole recursive structure would have to be weak, which seems very expensive
02:34:38 * Jafet ponders
02:37:29 <Jafet> Oh well, I'll try it anyway and see what ghc does
02:46:14 * hackagebot alex 2.3.5 - Alex is a tool for generating lexical analysers in Haskell  http://hackage.haskell.org/package/alex-2.3.5 (SimonMarlow)
02:55:40 <paolino> gpu programming is a promising area, and haskell is already there O_O
02:57:30 * ManateeLazyCat Hmm, video is compressing from memory to disk.....
02:58:10 <ibt> paolino: odd thing to say at random..
02:58:38 <ivanm> ibt: I'm guessing paolino just saw the Accelerate paper link on the haskell reddit
02:58:47 <paolino> ibt: I was just reading Accelerate paper
02:59:07 <ibt> fine, i'll read it too
03:01:48 <paolino> within some years cabal install , (with help of TH) will produce the right gpu accelerated code for the host  machine, given the source was ready for it
03:04:10 <ivanm> someone was talking about using TH to generate GPGPU code as a pre-processor...
03:04:12 <ivanm> forget who though :s
03:04:15 <ivanm> hey Cale 
03:04:31 <paolino> it's mentioned in the paper
03:05:04 <Jafet> instance Monad (SIMD a) where
03:05:21 <Cale> hey
03:05:31 <ClaudiusMaximus> hmpfr is a lottery, even with forkOS - maybe i'm doing it wrong, or it gets scheduled on the 'wrong' bound thread?
03:06:35 <ivanm> paolino: no, someone in here was talking about it as a completely separate project they were working on *now*
03:06:50 <paolino> ooh
03:07:16 <quicksilver> ClaudiusMaximus: maybe just run the hmpfr stuff in the main thread?
03:07:21 <quicksilver> (the main thread is always bound)
03:09:17 <ivanm> preflex: seen kremsera
03:09:17 <preflex>  kremsera was last seen on #haskell 62 days, 19 hours and 58 minutes ago, saying: and how did you solve it?
03:09:25 <ivanm> paolino: ^^ I think that's who it was
03:09:45 <ivanm> oh, did we bore Cale out _already_? :(
03:10:37 <ClaudiusMaximus> quicksilver: i'm using gtk in the main thread - this could get ugly...
03:11:00 <ClaudiusMaximus> quicksilver: opengl too, but that's less problematic...
03:11:22 <ManateeLazyCat> ClaudiusMaximus: forkIO ++ "-threaded" flag is enough. Just remember use function 'postGUIAsync' wrap your GTK+ code.
03:12:00 <ManateeLazyCat> ClaudiusMaximus: Function 'postGUIAsync' post GTK+ code to GTK+ main thread. 
03:12:05 <ClaudiusMaximus> ManateeLazyCat: yes, it works - but i'm trying to use MPFR which appears not to be threadsafe
03:12:23 <ManateeLazyCat> ClaudiusMaximus: 
03:12:28 <ManateeLazyCat> MPFR?
03:13:02 <ClaudiusMaximus> ManateeLazyCat: http://hackage.haskell.org/package/hmpfr http://www.mpfr.org/
03:13:08 <quicksilver> ClaudiusMaximus: yup, you just need to juggle all the things you have to do in the main thread :-/
03:13:38 <quicksilver> still, gtk has a special wrapper and opengl should only need calling in the render loop
03:13:44 <quicksilver> it's manageable just annoying
03:13:51 <ManateeLazyCat> ClaudiusMaximus: I don't know the detail of MPFR, but i can tell you how play multi-threads in GTK+
03:14:16 <ClaudiusMaximus> mm, i found a case where i was accidentally calling show :: MPFR -> String instead of show :: QuadDouble -> String - in the wrong thread
03:14:21 <ManateeLazyCat> ClaudiusMaximus: I use forkIO ++ MVar ++ postGUIAsync to implement multi-threads. 
03:14:47 * ManateeLazyCat pasted "my gtk2hs multithread library" at http://paste2.org/get/1111078
03:14:49 <ClaudiusMaximus> ManateeLazyCat: is postGUIAsync always in the 'main' thread?
03:14:59 <ManateeLazyCat> ClaudiusMaximus: http://paste2.org/get/1111078
03:15:34 <ManateeLazyCat> ClaudiusMaximus: Yes, postGUIAsync always in main thread, otherwise you will got "X error" that share between many threads.
03:16:17 <ManateeLazyCat> ClaudiusMaximus: The key of multi-threads of GUI is, do *long time* calculate at backend thread, just *render* graphics when result finish
03:16:52 <ClaudiusMaximus> ManateeLazyCat: hm, ok - but i need my long time calculation in the main thread because of mpfr...
03:17:20 <ManateeLazyCat> ClaudiusMaximus: You can running non-GTK+ code in different threads. 
03:17:36 <ManateeLazyCat> ClaudiusMaximus: The key is split "non-GTK code" and "GTK code"
03:17:39 <ClaudiusMaximus> i know - if that non-GTK+ code is threadsafe
03:18:01 <ManateeLazyCat> ClaudiusMaximus: Yes, if current threads not including GTK+, it's threadsafe
03:18:37 <ManateeLazyCat> ClaudiusMaximus: So when *long time* calculate finish, fill MVar, then main thread callback can read MVar to render result in main thread.
03:19:09 <ClaudiusMaximus> ManateeLazyCat: the problem comes from the foreign library i am using (mpfr) which is not thread safe, so i need to run it in the main thread, or i get segfault
03:19:18 <ManateeLazyCat> ClaudiusMaximus: You can see function 'forkGuiIO' in http://paste2.org/get/1111078
03:19:31 <quicksilver> ManateeLazyCat: you are not listening.
03:19:39 <quicksilver> ManateeLazyCat: ClaudiusMaximus does not have a problem with GTK.
03:19:49 <ManateeLazyCat> quicksilver: I just login in
03:19:53 <quicksilver> ManateeLazyCat: he has a problem with another library - mpfr - which *also* needs to run in the main thread.
03:20:04 <ManateeLazyCat> ClaudiusMaximus: Hmmm
03:20:10 <ManateeLazyCat> ClaudiusMaximus: So MPFR is not thread-safe?
03:20:12 <quicksilver> which means he can't update his gui, because he needs to call GTK from the main thread.
03:20:53 <ManateeLazyCat> ClaudiusMaximus: Let me think.
03:21:46 <ManateeLazyCat> ClaudiusMaximus: Can you split non-mpfr out?
03:22:05 <ManateeLazyCat> ClaudiusMaximus: I mean most *time* code don't need mpfr.
03:22:17 <ClaudiusMaximus> ManateeLazyCat: here's the relevant code: http://hpaste.org/41814/mpfr_thread_local_storage_pain
03:22:50 <ClaudiusMaximus> ManateeLazyCat: right, the mpfr code is just in 'muAtom'
03:23:31 <ClaudiusMaximus> but that can take a long time
03:23:41 <ManateeLazyCat> ClaudiusMaximus: If so, split non-mpfr code in other thread.
03:24:10 <ManateeLazyCat> ClaudiusMaximus: Then read forkIO + empty MVar in current thread. 
03:24:28 <ClaudiusMaximus> ManateeLazyCat: i have a lot of non-mpfr code in other threads too, works great, the problem is just mpfr
03:24:39 <ManateeLazyCat> ClaudiusMaximus: After other thread finish calcuate, fill mvar, then current thread can readMVar to continue
03:24:51 <ManateeLazyCat> ClaudiusMaximus: mpfr can't finish in *one* cycle?
03:25:56 <ClaudiusMaximus> depends, if the input is small (eg: [1%3]) it finishes in a fraction of a second; if the input is large (eg: [1%10, 1%10, 1%10, 1%10, 1%10]) it might take 30 seconds
03:26:01 <ManateeLazyCat> ClaudiusMaximus: IMO, any *graphics render* code should finish *one* render cycle, otherwise you need re-think your algorithm
03:26:53 <ClaudiusMaximus> ManateeLazyCat: ideally it would be in a separate thread, with a progress bar - but mpfr doesn't like to be in a different thread
03:27:27 <ClaudiusMaximus> ManateeLazyCat: so maybe i try again with 'qd' (200-something bits of precision, instead of the 512 i'm using with MPFR)
03:27:45 <ManateeLazyCat> ClaudiusMaximus: You must render result in real-time?
03:28:03 <ManateeLazyCat> ClaudiusMaximus: I mean don't render UI if result not finish
03:29:45 <ClaudiusMaximus> ManateeLazyCat: i think it's working ok (eg: gui updates fine, because the haskell thread running muAtom yields when it allocates, and is rescheduled on the same bound thread) - it's just that sometimes it starts on the 'wrong' bound thread and crashes (?)
03:31:10 <ManateeLazyCat> ClaudiusMaximus: If you use postGUIAsync, gtk2hs thread won't crash, but i don't know the detail of MPFR
03:31:45 <ClaudiusMaximus> ManateeLazyCat: right. gtk + threads = love :) ; but gtk + threads + mpfr = pain
03:32:10 <ClaudiusMaximus> ManateeLazyCat: anyway, i think i'll figure it out, thanks!  thanks quicksilver too :)
03:42:27 <radioactive_man> > Why Think
03:42:29 <lambdabot>   Not in scope: data constructor `Why'Not in scope: data constructor `Think'
03:42:37 <radioactive_man> >why think
04:19:55 <mm_freak> given this type:  newtype IdT m a = forall r. IdT (ContT r m a)
04:20:11 <mm_freak> is there an easy way to derive all the instances from ContT?
04:20:37 <Cale> That seems like moderately deceptive naming ;)
04:20:51 <mm_freak> Cale: it's just an example =)
04:21:27 <Cale> I would be a bit surprised if newtype deriving worked there, but you can try it...
04:21:39 <mm_freak> but the problem is actually quite related:  newtype StateT s m a = forall r. StateT (ContStateT r s m a)
04:21:46 <mm_freak> i tried
04:21:50 <mm_freak> it doesn't =)
04:24:03 <mm_freak> in a sense i'm trying to convert CPS monads to the Rans of their respective non-CPS variants
04:24:04 <Cale> Er, wait. What?
04:24:16 <Cale> newtype + existential quantification?
04:24:20 <mm_freak> yes
04:24:40 <mm_freak> it works, but i have to rewrite all instances, which is horrible to maintain
04:24:54 <quicksilver> Cale: it's permitted if there is no context
04:25:01 <quicksilver> Cale: because there is no runtime cost for parametric existentials.
04:25:22 <mm_freak> now i tried this instead:
04:25:22 <Cale> (It's apparently not permitted in  6.10.4)
04:25:25 <quicksilver> in fact, there is no runtime anything for parametric existentials.
04:25:27 <mm_freak> type MaybeT m a = forall r. T.MaybeT r m a
04:25:33 <mm_freak> type StateT s m a = forall r. T.StateT r s m a
04:25:50 <mm_freak> but when i try to combine both, i get an error about not fully applied type synonyms
04:26:13 <mm_freak> there should be something between type synonyms and newtypes
04:26:53 <Cale> You might try dropping the 'a' from those synonyms
04:26:57 <Cale> (on both sides)
04:27:09 <Cale> er, except that probably won't work
04:27:16 <Cale> (with the forall in the way)
04:27:22 <mm_freak> yeah, that won't work
04:28:00 <Cale> I'd probably just write the instances. They shouldn't have to change, at least.
04:28:29 <mm_freak> the problem is not the writing or changes, because i'm just referring to the existing instances
04:28:36 <mm_freak> the problem is maintainance
04:28:40 <mun> does first order logic allow functions that take in functions as arguments?
04:28:51 <ClaudiusMaximus> woop, no more crashes!  i fixed my code by s/hmpfr/qd/g 
04:28:56 <Cale> mun: Mu?
04:29:07 <quicksilver> do you mean logic, mun?
04:29:17 <mm_freak> well, i guess i have no choice =/
04:29:27 <Cale> mun: Well, function symbols aren't allowed to have other function symbols in their arguments, if that's what you mean.
04:29:29 <quicksilver> first order logic isn't normally all that specific about what you're allowed to do with individuals + function symbolx
04:29:45 <Cale> er, well, not unapplied function symbols
04:29:55 <ClaudiusMaximus> hah, it just crashed :(   gmndl: gmndl.hs:250:6-46: Irrefutable pattern failed for pattern (big, '.' : small)
04:29:56 <mun> quicksilver, yes
04:30:01 <mm_freak> (or i don't provide a simplified interface in the first place)
04:30:10 <Jafet> mm_freak: hrm, what is there to maintain?
04:30:12 <ClaudiusMaximus> (that'll teach me to crow..)
04:30:21 <mun> Cale, why not? doesn't second-order and higher simply allow quantification over functions?
04:30:30 * Jafet hands claudius a spoon
04:30:37 <mm_freak> Jafet: i constantly add new classes, which a lot of monad transformers are instances of
04:30:47 <Cale> mun: Or sets
04:30:53 <mm_freak> Jafet: my aim is to provide a simplified, more traditional interface to contstuff
04:30:55 <quicksilver> mun: no.
04:31:05 <quicksilver> mun: second order logic allows quantification over predicates, not functions.
04:31:06 <mm_freak> StateT s m a instead of StateT r s m a
04:31:20 <mm_freak> and more notably ChoiceT m a instead of ChoiceT r i m a
04:31:30 <Cale> There actually seems to be a few different versions of what second order logic consists of :)
04:32:26 <Cale> (but it always involves generalising quantification)
04:32:47 <mun> Cale, so why doesn't FOL allow functions of functions?
04:32:52 <quicksilver> Cale: you can choose to permit function symbols in arguments in first order logic via an encoding trick.
04:33:03 <quicksilver> mun: no important reason. Just history/convention.
04:33:30 <mun> quicksilver, right. but aren't predicates essentially functions with type a => bool instead of a => b?
04:33:36 <quicksilver> mun: no.
04:33:57 <quicksilver> mun: that is a very model theoretic view. It is not a good logical view.
04:34:06 <Cale> Well, because the interpretation of function symbols are not (usually) meant to be members of the domain which interpretations of elements range over. I suppose you could make something like that work if you want.
04:34:32 <quicksilver> Cale: yes, represent functions as elements and have a (real) function for apply.
04:34:47 <quicksilver> Cale: ... but this works better if you have sorts to classify your elements.
04:34:50 <Cale> Your quantifiers range over some set U, and the function symbols are interpreted as operators U^n -> U
04:35:29 <Cale> and n-ary predicate symbols are interpreted as subsets of U^n
04:35:41 <mun> so it's only a historical reason why first order functions cannot take functions as arguments. then do first order theorem provers or other FO systems disallow functions of functions even if it's not a technical restriction?
04:35:57 <Cale> I'm not sure it's fair to say *only* a historical reason
04:36:00 <quicksilver> because they don't find it interesting/useful.
04:36:11 <quicksilver> you can encode such things if you want to 
04:36:34 <opqdonut> yeah, one can have the one-ary predicate function() and a function symbol apply()
04:36:37 <Cale> For U as a set to contain some functions U^n -> U is sort of a strange thing :)
04:36:40 <quicksilver> by encoding functions as sets of pairs, or encoding functions as elements an having an apply symbol.
04:37:01 <opqdonut> apply(f,x), that is
04:37:08 * quicksilver nods at opqdonut 
04:37:15 <Cale> It has to do with what the interpretations of FOL in set theory are.
04:37:15 <opqdonut> yeah
04:37:28 <quicksilver> opqdonut: you can extend it to partial application of curried functions if you wish.
04:37:36 <opqdonut> yes, sure
04:37:42 <Cale> That is, in the sense of model theory.
04:37:43 <mun> so is apply(f,x) first order?
04:37:57 <Cale> yes, you can do that, though f there won't be a function symbol
04:38:01 <quicksilver> given the right choice of U, yes.
04:38:15 <quicksilver> you've represented your functions as constant symbols instead of function symbols.
04:38:24 <quicksilver> which is fine.
04:38:31 <quicksilver> U can be a model of STLC, or something.
04:38:37 <opqdonut> but may destroy some model-theoretic properties
04:38:57 <opqdonut> or, will
04:39:11 <Cale> Look at the way that set theory is usually encoded in FOL -- it doesn't require any function symbols at all :)
04:39:15 <mun> so f :: a rather than f :: a => b
04:39:22 <Cale> (Just a relation symbol 'in')
04:39:29 <opqdonut> yep
04:41:31 <Cale> The main difference between second order logic and first order logic is actually not the syntax, but the constraint that whe quantifying over subsets of the universe, the interpretation of those subsets must be actual subsets of the interpretation of the universe.
04:41:41 <Cale> when*
04:43:42 <Cale> There's no first order theory whose only model up to isomorphism is the real numbers (because any such theory would have a countable model)
04:43:54 <Cale> But there is a second order theory of the reals.
04:44:42 <Cale> (you need quantification over sets of real numbers in order to talk about completeness)
04:47:04 <mun> thanks
04:52:34 <quicksilver> Cale: there's no first order theory whose only model of anything is anything.
04:52:50 <quicksilver> Cale: all (infinite) first order theorys have multiple non-isomorphic models.
04:53:33 <quicksilver> the first order theory of peano arithmetic has models non-isomorphic to the 'normal' natural numbers.
05:02:11 <ManateeLazyCat> What's the best "video editor" ?
05:02:36 <ManateeLazyCat> I'm looking for software edit video (cut, concat).
05:02:52 <Jafet> Scissors and clear tape
05:03:10 <Jafet> Not software, though
05:03:40 <enthropy> ManateeLazyCat: perhaps manatee could be?
05:03:54 <quicksilver> ManateeLazyCat: http://arstechnica.com/open-source/guides/2010/01/video-editing-in-linux-a-look-at-pitivi-and-kdenlive.ars
05:04:02 <quicksilver> has some useful background in it
05:04:04 <ManateeLazyCat> enthropy: Yes, but i'm build Manatee video upload to YouTube.com 
05:04:11 <quicksilver> I thought there was a more recent article but I can't find it.
05:04:22 <ManateeLazyCat> enthropy: I need cut some pieces from video
05:05:17 <sipa> i've been thinking for a long time about a functional-style (perhaps haskell) video editor, with pieces of video extractable from sourcefiles and combinable with combinators like crossfading... all lazily evaluated :)
05:06:06 * ManateeLazyCat Many video editor i found is crap and slow!.....
05:06:20 <ManateeLazyCat> quicksilver: Thanks, looking
05:06:50 <ManateeLazyCat> quicksilver: If noone can work, maybe i will use encoder do that. :)
05:07:32 <ManateeLazyCat> quicksilver: pitivi looks cool
05:07:52 <quicksilver> ManateeLazyCat: I have no experience with any of this, I just remembered readin the article ;)
05:07:58 <quicksilver> ManateeLazyCat: I'll be intrested to see how it goes, though
05:08:21 <ManateeLazyCat> quicksilver: Yes, that's help, i have install many (10+) video editor, no one can work.
05:09:22 <ManateeLazyCat> quicksilver: Today, i record a fully video to show "how to play manatee", hope i can upload to YouTube.com tonight.
05:10:33 <ManateeLazyCat> quicksilver: pitivi base on gstreamer, looks great.
05:16:41 <ManateeLazyCat> quicksilver: pitivi lodi
05:16:45 <ManateeLazyCat> loading
05:16:51 <ManateeLazyCat> UI is clean, find out how to use it.
05:17:33 * ManateeLazyCat Can't understand why many people make UI so complicated...
05:18:09 <ManateeLazyCat> Wow, is drop down to edit area.
05:19:04 <ManateeLazyCat> quicksilver: Just import file in pitivi and drop video to edit area (at bottom), looks can work.
05:19:23 <quicksilver> good.
05:19:46 <ManateeLazyCat> quicksilver: I like pitivi's design though it's a bit slow.
05:20:04 <ManateeLazyCat> quicksilver: Design is very natural and clean.
05:21:03 <datenwolf> ManateeLazyCat: Blender's Sequence Editor is quite capable, too. I use this for video editing.
05:21:23 <ManateeLazyCat> datenwolf: Fast?
05:21:39 <datenwolf> Depends. If you're just cutting videos, then yes.
05:21:50 <quicksilver> blender is awesome.
05:21:53 <ManateeLazyCat> datenwolf: Easy to use ?
05:21:56 <quicksilver> in oh-so-many ways.
05:21:59 <datenwolf> But the more transformations and effects you apply the slower it gets.
05:22:25 <datenwolf> ManateeLazyCat: Well, Blender's UI is a bit unique at first, but once you've groked it, it's great.
05:22:52 <datenwolf> This is kind of going from imperative to functional programming.
05:22:57 <ManateeLazyCat> datenwolf: I almost install all video editor in linux, all crap and hard to use.
05:23:13 <ManateeLazyCat> datenwolf: pitivi looks better, but still slow.
05:23:24 <sipa> blender is not really a video editor, more a rendering system, no?
05:23:48 <ManateeLazyCat> sipa: I know Blender use for 3D model.
05:23:56 <datenwolf> ManateeLazyCat: Blender's sequence editor has only one drawback: It won't read arbitrary video files. You've first to convert them into uncompressed AVI, or MJPEG-AVI, or a sequence of image files.
05:24:36 <ManateeLazyCat> datenwolf: I hate sequence of image files, many video is convert my video (38 mins) to images (10000+)
05:24:44 <datenwolf> sipa: Blender is a 3D-Modelling-Game-Engine-Physics-Simulator-Videoeditor-Renderer
05:25:19 <datenwolf> ManateeLazyCat: Believe it or not, but in professional video editing you've almost always to deal with image sequences.
05:25:59 <datenwolf> Has a simple reason: If you want to rerender only a part of the whole sequence you don't end up with recreating the whole container.
05:26:26 <ManateeLazyCat> datenwolf: Maybe my box is crap 
05:26:33 <ManateeLazyCat> datenwolf: My box is not fast enough
05:26:52 <datenwolf> What's the specs of it?
05:27:02 <datenwolf> And of your video?
05:28:08 <ManateeLazyCat> datenwolf: I use 'recordmydesktop' record video when i play manatee, is .ogv 295MB 
05:29:45 * sipa has video files 1000x as large ;)
05:29:59 <sipa> well, 500x only, actually
05:30:38 <ManateeLazyCat> datenwolf: Thanks for help, i'm using pitivi, though a little bit slow.
05:30:46 <Jafet> datenwolf: video codecs support random access fine
05:30:47 <datenwolf> Question on Haskell, not video editing: I'm used to the OCaml runtime system: You can embedd a leightweigt OCaml bytecode interpreter into your natively compiled programs and bytecode compiled OCaml modules can access exported parts of the native and vice versa. I'd like to do this or similar with Haskell.
05:31:09 <Jafet> The issue here is that those codecs are lossy
05:31:26 <sipa> h264 has a lossless mode
05:31:36 <tab> datenwolf: you means calling haskell from C ?
05:31:42 <datenwolf> tab: No
05:32:14 <quicksilver> Jafet: but as long as you store all the transformations procedurally, and only "bake" your video render once / on-demand, you only make that loss once
05:32:15 <datenwolf> I mean: compile a Haskell programm to native, then have a plugin system for other Haskell modules, but this should be plattform neutral.
05:32:31 <quicksilver> Jafet: so it doesn't matter, unles you keep doing repeated "Save-as" back to the lossy format.
05:32:57 <quicksilver> datenwolf: you can do it, but it's not particularly lightweight.
05:33:04 <Jafet> quicksilver: video editors support procedural editing?
05:33:08 <quicksilver> datenwolf: the "lightweight interpreter" is, in fact, GHC(i).
05:33:11 <ManateeLazyCat> datenwolf: Hot-swapping?
05:33:19 <datenwolf> Jafet: Working with plain image files is a lot easier in the long term, believe me. I did a full rerender of Elephants Dream in stereoscopic 3D.
05:33:41 <quicksilver> datenwolf: and you're not restricted to bytecode, you can just do last minute compilation instead.
05:33:57 <quicksilver> datenwolf: (i.e. ship haskell source, or generate haskell source at runtime)
05:34:00 <Jafet> datenwolf: well, that may be if you have hard drives to go around
05:34:17 <quicksilver> Jafet: some of them do, in some limited, way, like I describe, I think.
05:34:18 <Jafet> It's basically a special case of making all frames I-frames
05:34:23 <datenwolf> quicksilver: Yes, I've read about GHCi, which looks fine. I'm not concerned by source code publication, that's fine for me, but having some kind of intermediary bytecode, which could in turn be JIT compiled into native would be awesome.
05:34:46 <quicksilver> datenwolf: don's paper on "plugins" is worth reading, although it's out of date.
05:35:01 <quicksilver> datenwolf: more recent things include 'muevel', 'dyre' and 'pdynload'
05:35:28 <quicksilver> oh, 'hint'
05:35:57 <preyalone> Is there a Common Lisp equivalent to Haskell's main function (esp. for scripting)?
05:36:22 <ManateeLazyCat> quicksilver: IMO, at least now, embedded interpreter just fine for *little* user customize script, if interpret everything, it's really slow.
05:36:38 <datenwolf> quicksilver: The background is: I'm going to develop a distributed, collaborative sandbox game engine (think of Minecraft, but with fine detailed graphics). I've a scene graph already in place (my very own engine called "EVEN"), but I'd like to replace the whole logic with something functional.
05:36:59 <ManateeLazyCat> quicksilver: Infact, dyre is not plugin system, it's use recompile.
05:37:26 <ManateeLazyCat> @package muevel
05:37:27 <lambdabot> http://hackage.haskell.org/package/muevel
05:37:41 <ManateeLazyCat> datenwolf: Functional engine? 
05:38:54 <datenwolf> Well a high class game engine written in Haskell. I'd like to gradually port my EVEN scene graph to Haskell, and add network, game, AI and other logic.
05:39:00 <ManateeLazyCat> quicksilver: My video is too big, i give up.
05:39:10 <Nibble> datenwolf: is there any repo for your code?
05:39:13 <Nibble> sounds interesting
05:39:19 <ManateeLazyCat> quicksilver: I try installing develop-version pitivi
05:40:11 * ManateeLazyCat Installing so many software today...
05:40:16 <datenwolf> Nibble, not yet, as I'm just about to begin. EVEN never worked the way I wanted it to, so I never published it. It's quite a large bunch of (IMHO) very good C code, together with a really broken runtime system.
05:40:42 <ManateeLazyCat> datenwolf: Maybe you can read the source code of pdynload
05:40:50 <datenwolf> It's mostly the runtime system I want to get rid of in the first place.
05:40:54 <ManateeLazyCat> datenwolf: Use GHC-API implement hot-swapping feature 
05:41:08 <ManateeLazyCat> datenwolf: But still have a issue need perfect
05:41:29 <ManateeLazyCat> pdynload can't upload entry once new version install by Cabal
05:41:50 <ManateeLazyCat> But if you don't install new version by Cabal, pdynload can interpret code to running
05:41:56 <ManateeLazyCat> And make sure type match
05:42:11 <datenwolf> It funny, because all that EVEN C code makes use of a lot of functional paradigms, but it's not functional of course.
05:43:22 <Cale> quicksilver: Indeed, anything with an infinite model has a model of every cardinality.
05:43:23 <ManateeLazyCat> Hope develop-version pitivi will be faster
05:43:32 <datenwolf> So I expect that I may shift the whole thing to pure Haskell with a little C glue to media APIs.
05:43:42 <Cale> (any first order theory)
05:45:05 <Cyrus1989_> hello
05:45:15 <ManateeLazyCat> datenwolf: You can use gstreamer
05:45:16 <quicksilver> Cale: yes, I know.
05:45:16 <Mentos> hi
05:45:36 <quicksilver> Cale: so, therefore, real numbers are not particularly ununusual in not having a categorical first order theory
05:46:19 <Cyrus1989_> what is this channel about?
05:46:31 <quicksilver> the haskell programming language
05:46:38 <quicksilver> as it says in the topic :)
05:47:38 <Cyrus1989_> I didn't know that haskell is programming language.
05:47:40 <datenwolf> ManateeLazyCat: You mean gestreamer as media API for Haskell?
05:47:51 <sipa> Cyrus1989_: now you do :)
05:48:22 <Jafet> He was reborn into one
05:48:23 <ManateeLazyCat> datenwolf: Yes.
05:48:32 <ManateeLazyCat> @package gstreamer
05:48:32 <lambdabot> http://hackage.haskell.org/package/gstreamer
05:49:10 <ManateeLazyCat> datenwolf: Peter binding it, looks great, but haven't time to trym
05:49:14 <ManateeLazyCat> try
05:49:17 <datenwolf> ManateeLazyCat: With media API I mean different. gstreamer is if you want to build video players or stuff.
05:49:36 <datenwolf> I'm talking about a game engine, which means: Other needs. Like very low latency.
05:49:54 <datenwolf> I know about HGL OpenGL binding.
05:50:10 <ManateeLazyCat> datenwolf: Like when time load/play music ?
05:50:49 <Jafet> I would like a reactive game engine. The only one I know of that's going that way is reactive-fieldtrip
05:53:23 --- mode: lindbohm.freenode.net set +o ChanServ
05:53:37 <datenwolf> Well, I'm not confident that using OpenGL directly from Haskell will do good. To take really leverage of modern GPU featuers you've to use Buffer Objects, which can be accessed by memory mapping them into process memory.
05:53:46 <quicksilver> no problem accessing VBOs + friends from haskell, datenwolf 
05:53:59 <datenwolf> quicksilver: Really, cool.
05:56:47 <datenwolf> quicksilver: Darn, HOpenGL still lacks support for geometry shaders, though EVEN makes havy use of them if available.
05:57:05 <datenwolf> Think, it should be addable easy enough, though
05:58:17 <Baughn> @src (>>)
05:58:17 <lambdabot> m >> k      = m >>= \_ -> k
05:58:19 <Baughn> @src (>>=)
05:58:20 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
05:59:26 <ManateeLazyCat> Installing blender
05:59:26 <endojelly> monad instances typically define their own (>>=)
05:59:48 <Jafet> @src (>>=) :: [a] -> (a -> [b]) -> [b]
05:59:48 <lambdabot> Source not found. You type like i drive.
06:00:37 <quicksilver> datenwolf: yes, adding new bindings to OpenGLRaw is essentially mechanical although fiddly.
06:01:02 <quicksilver> datenwolf: what do you use geometry shaders for, out of interest?
06:01:18 <sipa> endojelly: not 'typically'; they must
06:01:22 <ToRA> the binding is already in glraw; it just doesn't have the nice interface yet in gl
06:01:39 <ToRA> quicksilver: (sorry if that's what you meant)
06:03:09 <endojelly> sipa, can't they define join instead?
06:06:12 <sipa> endojelly: join is not in the monad type class, no?
06:06:36 <ManateeLazyCat> datenwolf: blender just support avi?
06:06:47 <endojelly> @info Control.Monad.Monad
06:06:47 <lambdabot> Control.Monad.Monad
06:07:01 <Jafet> @src join
06:07:01 <datenwolf> ManateeLazyCat: There's FFMPEG support for output.
06:07:01 <lambdabot> join x =  x >>= id
06:07:05 <quicksilver> ToRA: no, that's not what I meant.
06:07:12 <quicksilver> ToRA: I didn't know the binding was already in GLRaw, that's great :)
06:07:16 <datenwolf> But I strongly disregard its use.
06:07:47 <datenwolf> Believe me: Using image sequences will save you a lot of trouble in the end. Yes, they consume space, but that's how it is.
06:08:36 <datenwolf> Some time ago I also used contained formats for animation. Don't do this anymore.
06:09:00 <datenwolf> Only the final product for publication will be in a container.
06:09:22 <sipa> maybe that's specifically true for blender, but not necessarily for all video editors?
06:10:13 <datenwolf> sipa: Maybe, but I found image file squences also very usefull for steps after editing.
06:10:43 <sipa> if you want to make a montage of 10+ hours of HD video, you'll need way too much storage if you convert everything into separate images
06:10:45 <datenwolf> For example I am publishing "Elephants Dream 3D" in a number of different formats.
06:11:26 <sipa> i leave the source in the original format, edit it, export in a lossless video format, compress the lossless video using h264 or ffv1 (lossless of course)
06:11:41 <sipa> and then turn that into all output formats necessary
06:11:50 <datenwolf> Oh, it's quite manageable: ~15 Minutes of stereoscopic animation at 1998x1080 resolution with all intermediary files and various output variants took only about 500GB
06:11:56 <endojelly> sipa, hm. I somehow quietly assumed you could define either one
06:12:16 <sipa> datenwolf: 10h is not :)
06:12:26 <Jafet> datenwolf: 30fps progressive?
06:12:29 <datenwolf> sipa: Well, problems begin if this "lossless" format is not as lossless and you might have thought.
06:12:34 <quicksilver> endojelly: I don't think there is a general way to deduce >>= from a correct >> implementation.
06:12:38 <datenwolf> Jafet: 24fps Digital Cinema 2k
06:12:47 <sipa> datenwolf: lossless means lossless
06:13:25 <sipa> datenwolf: as in pixel-per-pixel identical to the original
06:13:49 <endojelly> quicksilver, I meant join... is there a way to deduce it from join?
06:13:58 <datenwolf> sipa: What about if further manipulation requires you to do a colour space transformation? If your lossless is only defined in say8 bits per channel, then you will get banding if you do the conversion from YUV to X'Y'Z
06:14:13 <sipa> datenwolf: ah, it's YUV420 from the beginning to the end
06:14:24 <sipa> if you do color space conversions, you're right
06:14:29 <datenwolf> Well, Digital Cinema is X'Y'Z'
06:14:54 <datenwolf> So Elephants Dream 3D was done in a end-to-end lossless HDR pipeline.
06:14:57 <ManateeLazyCat> quicksilver: I found best one.
06:15:27 <datenwolf> And only for the final publishing format it gets reduced to what's needed.
06:15:39 <sipa> datenwolf: that's how it should be of course
06:15:54 <ManateeLazyCat> quicksilver: Use recordmydesktop record video as out.ogv, then use "mencoder out.ogv -o out.avi -oac mp3lame -ovc lavc" convert .ogv to .avi, then use avidemux edit .avi file.
06:16:16 <datenwolf> ManateeLazyCat: Did you try ffmpeg x11grab input?
06:16:37 <ManateeLazyCat> datenwolf: I'm use avidemux now,
06:16:37 <datenwolf> Works quite well for me (alas, I think recordmydesktop uses right that as backend).
06:16:48 <ManateeLazyCat> datenwolf: Sorry, i don't know how to play blender
06:17:03 <sipa> ManateeLazyCat: i think you often mean 'use' when you say 'play'
06:17:21 <ManateeLazyCat> datenwolf: blender looks too complicated, IMO
06:17:31 * ManateeLazyCat Never use blender before...
06:18:00 <sipa> datenwolf: but if you work with rendered material your definition of 'lossless' is obviously different from someone making a montage where the source material is 1440x1080 MPEG2 :)
06:18:20 <datenwolf> sipa: Well, yes.
06:19:27 <quicksilver> sipa: ManateeLazyCat uses automatic translation sometimes :)
06:19:32 <quicksilver> endojelly: yes.
06:19:39 <quicksilver> endojelly: you can deduce it from join and fmap 
06:19:49 <quicksilver> endojelly: but, as it happens, neither join nor fmap is a method of Monad
06:20:00 <endojelly> quicksilver, see, that's why I assumed join was part of the Monad type class, and you could define either >>= or join!
06:20:07 <ManateeLazyCat> quicksilver: Yes, you will find i use automatic translation in my video
06:20:12 * datenwolf has this crazy idea of building his very own HD-HDR video camera from parts. That CCD looks really nice http://www.kodak.com/global/en/business/ISS/Products/Interline/KAI-04050/support.jhtml?pq-path=15691
06:20:16 <quicksilver> it would be sensible, endojelly.
06:20:21 <endojelly> I never looked, because I never actually attempted to define join instead of >>=
06:20:27 <quicksilver> endojelly: but it would need fmap (liftM) to be a method.
06:20:43 <quicksilver> and that would be annoying w.r.t. the functor instance
06:20:48 <endojelly> ah, I see
06:20:56 <quicksilver> we wish we had a better way to make classes build from other classes.
06:21:31 <endojelly> so that's an open topic of research?
06:22:08 <cdsmithus> I'm trying to compile someone else's code using base 3 with a later base... and, I'm getting undefined references to 'errorCalls' and 'ioErrors'.  Someone point the direction I should look?
06:23:27 <ManateeLazyCat> quicksilver: If you interested video edit, should try avidemux though just support fews format.
06:23:43 <ManateeLazyCat> quicksilver: avidemux is very fast, allowed me edit video frame by frame
06:25:00 <ManateeLazyCat> quicksilver: Most important is, avidemux is very fast.
06:29:23 * ManateeLazyCat Looks ffmpeg is cool "ffmpeg -i out.ogv out.avi"
06:40:31 <byorgey> augur: it precomputes lower and upper bounds on sizes, so for P = X + P*P  it would know that P generates no structures on the empty label set, and avoid calling enumerate on P with zero elements
06:42:48 <Mkman> Hey!
06:43:24 <byorgey> hey Mkman 
06:46:34 <norm2782> I'm trying to used quickcheck to test some of my functions. however, the lists it generates eventually become too big (I'm looking at all the permutations of a list). can anyone point me to a way to constrain the size of the lists quickcheck generates?
06:47:17 <hpc> can't you write your own check function? it shouldn't be much more than sequence, map, and print
06:48:38 <norm2782> would that be a check function for quickcheck? (I admit to being a quickcheck noob)
06:49:00 <hpc> i mean, something like:
06:49:31 <hpc> do let conds = map test [1..500]; when (all conds) print "yay"
06:49:47 <byorgey> norm2782: what version of QuickCheck are you using?
06:50:25 <Jafet> hpc: that... misses the point entirely
06:50:42 <norm2782> byorgey: apparently an older version: 2.1.1.1
06:51:08 * norm2782 upgrades
06:51:11 <byorgey> norm2782: it doesn't matter, I asked only because the interface has changed
06:51:20 <byorgey> you will still have the same problems with a newer version
06:51:25 <byorgey> although upgrading won't hurt.
06:51:40 <Jafet> I added something like length xs > 10 ||, but that's also partly missing the point
06:52:20 <byorgey> norm2782: for fewer tests you can set the 'maxSuccess' field in the Args parameter to quickCheckWith
06:52:53 <Jafet> I think he wants maxSize
06:52:54 <byorgey> norm2782: for limiting the length of the test lists you can use 'sized'
06:53:04 <byorgey> oh! Indeed, I missed that
06:53:18 <byorgey> yes, set the maxSize field in the Args record =)
06:53:22 <norm2782> ah, that sounds like it would work :)
06:53:26 <norm2782> nice
06:53:35 <byorgey> heh, I didn't know that existed, nice =)
06:54:30 <norm2782> thanks guys
06:54:31 <byorgey> norm2782: yeah, testing functions with combinatorial blowup using quickcheck can be a pain
06:54:35 <Jafet> For more precision, you could write your own generator that picks out of replicateM n [1..n]
06:54:35 <byorgey> good luck
06:55:05 <Jafet> (All other sequences for testing permutations are isomorphic to those)
06:55:57 <norm2782> yeah, a custom generator would be a second option.. I'd like to avoid using one if at all possible though :)
06:56:01 <norm2782> s/using/writing
06:57:34 <Jafet> Or run it through quickspec and see if you get an equivalent function
06:58:06 <byorgey> quickspec?
06:58:15 <Cale> It's not all that tricky. Gen is a monad, which makes it sort of easy to write new generators.
06:59:04 <byorgey> woah, how did I miss that?
06:59:40 <Jafet> Is there any other documentation for quickcheck 2 besides the haddock?
07:00:09 <Jafet> (Or is its usage supposed to be obvious from the haddock comments...?)
07:00:14 <quicksilver> Arbitrary instances are a blind alley.
07:00:34 <quicksilver> supplying your own Gens is a more general approach
07:00:49 <quicksilver> the Arbitrary instance is just a naive 'simplest Gen for each type'
07:00:57 <quicksilver> handy, but don't get distracted from what's actually possible.
07:01:27 <byorgey> Jafet: not that I know of
07:03:27 * Jafet contemplates writing a coherent, persuasive essay on "haddock considered harmful", but decides to make a one-line description of it instead.
07:14:06 <ManateeLazyCat> avidemux is damn cool.
07:16:59 <radioactive_man> valgrind is damn cool
07:17:23 <arcatan> snow is damn coll
07:19:07 * hackagebot TypeClass 0.1.1 - Typing speed game  http://hackage.haskell.org/package/TypeClass-0.1.1 (JeanPhilippeMoresmau)
07:19:09 <radioactive_man> knowing whats damn cool, is damn cool
07:22:55 <portnov> @pl \a ks -> or [testBit a b | b <- ks]
07:22:56 <lambdabot> (or .) . flip flip [] . ((:) .) . (<-) . (| b) . flip testBit b
07:23:00 <portnov> :)
07:25:23 <ceezer> Are there any packages for adaptive digital filtering in Haskell? Looking for stuff like, Wiener, LMS, RLS algorithms
07:27:55 <byorgey> Jafet: so what's the one-line description?
07:28:43 <byorgey> portnov: heh, @pl doesn't know about list comprehensions =)
07:29:13 <portnov> byorgey: I see :)
07:29:25 <byorgey> \a ks -> or [testBit a b | b <- ks]
07:29:34 <byorgey> \a -> or . map (testBit a)
07:29:54 <portnov> @pl \a -> or . map (testBit a)
07:29:55 <lambdabot> any . testBit
07:30:03 <portnov> nice
07:30:46 <norm2782> byorgey, Jafet: maxSize works like a charm, thanks!
07:30:51 <byorgey> norm2782: great!
07:36:39 <ceezer> Any ideas?
07:37:25 <byorgey> ceezer: did you look on Hackage?
07:38:52 <byorgey> ceezer: there's http://hackage.haskell.org/package/dsp, I have no idea if that's what you're looking for
07:39:03 <ceezer> byorgey: I looked but didn't see anything appropriate.
07:39:21 <byorgey> ok.  well, if it isn't on Hackage, it doesn't exist. ;)
07:40:12 <ceezer> byorgey: Yea, that is for static filtering, but not for adaptive filters
07:40:25 <byorgey> ok, I see.  I don't know much about the area.
07:40:33 <ceezer> Might  be nice to write something on it then. :)
07:40:59 <byorgey> hehe
07:42:11 <ceezer> adaptive filters, the actual filter used changes due to feedback at the output. 
07:42:31 <byorgey> ceezer: makes sense.  What kinds of things are such filters used for?
07:43:30 <ceezer> many things: echo cancelation; line enhancement; equalizing channels; identifying unknown systems
07:44:27 <byorgey> cool
07:44:44 <byorgey> well, feel free to write something yourself and put it up on Hackage
07:44:57 <ceezer> byorgey: I'm using it for microphone array processing, for noise reduction. Yes. I might do that.
07:45:05 <byorgey> it's very easy to put things on Hackage and there's no "minimum standard"
07:45:15 <byorgey> so just put something, anything, up, and then you can keep improving it
07:45:41 <ceezer> Thanks for the link to the dsp package, i can build on some of the basic tools there.
07:46:04 <byorgey> great
07:46:07 <byorgey> glad I could help =)
07:49:06 <mreh> has there been a suggestion for rating hackage packages?
07:49:13 <mreh> maybe by downloads
07:49:34 <byorgey> mreh: yes.  there will be some sort of comments/ratings/etc. system on the new Hackage server
07:49:51 <mreh> wow great
07:50:15 <mreh> I was expecting some kind of neo-luddite rebellion against such a thing
07:50:32 <byorgey> hehe
07:50:33 <mreh> neo-luddite?
07:51:03 <byorgey> well, you can at the very least expect lots of bike-shedding over which particular features should be included
07:51:36 <ceezer> Yea, it would be useful. Especially to see if there are any packages needing attention.
07:52:17 <byorgey> indeed.  Hackage has been around only for a couple years, and it has definitely outgrown its initial design
07:52:25 <chris__> yo
07:52:36 <byorgey> hi chris__ 
07:52:37 <mreh> bike-shedding, excellent, I'll remember that one
07:53:16 <byorgey> chris__: enjoying Try Haskell?
07:53:19 <byorgey> aww
07:55:24 <ceezer> I only started looking at Haskell around a couple of weeks ago, some of the concepts can be hard to grasp.
07:56:02 <ceezer> I'm interested in the numerical computing side of things.
08:00:03 <ceezer> Ciao
08:04:00 <Leemp> I'm sure this will seem like a stupid question to you all, but i'm only just reading about haskell and it's getting interesting (which i guess is a nice way of saying weird :P). So.. i simply want to know, is Haskell a good choice for GUI projects (ie, user applications), or web apps, and etc? Are there any odd limitations in that regard?
08:05:26 <Entroacceptor> there are some "weird" approaches to those, afaik
08:05:46 <lantti> Leemp: Yes, haskell can do that :)
08:05:50 <Leemp> Entroacceptor: What do you mean?
08:05:51 <Entroacceptor> for web stuff, look at yesod, snaps, or happstack
08:06:12 <Entroacceptor> Leemp: there was a paper about reactive functional programming or something
08:06:23 <Entroacceptor> but I'm not the right guy to ask about haskell gui programming
08:06:38 <Leemp> k
08:06:43 <sipa> @faq can you write GUI applications in Haskell?
08:06:44 <lambdabot> The answer is: Yes! Haskell can do that.
08:06:48 <Entroacceptor> still a newb myself, trying to build a web app
08:07:09 <Entroacceptor> afaik the GTK bindings are good to use
08:07:10 <sioraiocht> Leemp: there's gtk2hs
08:07:15 <sioraiocht> which are pretty good
08:07:21 <sioraiocht> dunno about the state of wxHaskell
08:07:50 <Leemp> I guess i am just asking if haskell is more of a pain in regards to that stuff. So far haskell is seeming so foreign i honestly was starting to think it was just for computer science majors and people needing to track stars across the sky or something lol.
08:08:25 <quicksilver> writing GUI applications in the asbolutely conventional - imperative, GTK - fashion is easier in haskell than in C/C++
08:08:48 <quicksilver> there are also other more experimental, less imperative approaches. Which are really interesting. But you don't have to use them.
08:08:54 <Leemp> Ie, it seemed like it was a language designed for a small body of work, but it excels at what it's designed for. 
08:09:06 <cdsmithus> Leemp: Haskell can do GUI programming in just the same way as most other languages... see gtk2hs for example.
08:09:30 <Raca> @faq can you buy me something on black friday?
08:09:31 <lambdabot> The answer is: Yes! Haskell can do that.
08:09:47 <medfly> I think that Haskell is a bit too strong at times, like if you just want to write a few pages of a website, probably best not to use Haskell :-)
08:09:52 <cdsmithus> Leemp: If you're new to Haskell, don't get distracted by stuff like FRP that someone mentioned.  That's ongoing research work, and not the kind of thing you'd want to get started with. :)
08:10:10 <Leemp> Entroacceptor: Specifically web programming is my interest though, how is your experiment going?
08:10:27 <Leemp> cdsmithus: k :)
08:10:43 <Leemp> Mostly at this point, i'm sick of hearing about Haskell and i want to wrap my head around it
08:11:04 <Leemp> So i'm trying it. :)
08:11:25 <cdsmithus> Leemp: For web programming, Snap, Happstack, and Yesod are all definite possibilities... I don't find them particularly unusual, but you might find them to be rather new and sometimes not fleshed out yet.
08:11:26 <Raca> what i like about haskell is that its so spartan
08:11:35 <Leemp> Though, it scares me that there are fields f "ongoing research" xD. Feels like i'm already in over my head ;)
08:12:03 <Raca> i wish there were more spartan languages like it
08:12:17 <Entroacceptor> Leemp: I'm specifically writing something like an extensible CMS
08:12:19 <medfly> but then we'd split up all the awesome people!
08:12:19 <cdsmithus> Leemp: Oh, if you're not happy with the fact that people do research in the same language that you're programming in, then Haskell isn't for you. :)  Neither is Scala, or a bunch of other nice languages.
08:12:20 <Entroacceptor> in Happstack
08:12:32 <cdsmithus> Leemp: But I don't see why it should bother you.
08:12:52 <Entroacceptor> it's different from django (Python) which I used before, more direct
08:13:00 <dcoutts_> Leemp: the fact that researchers choose this language is an advantage it means we get to use their cool new stuff before it appears in any other language
08:13:08 <lars9> i can see that the motivation of haskell's designs come from category theory. then what's theory of OOP?
08:13:39 <dcoutts_> lars9: it's not really category theory, it's domain theory
08:13:42 <Entroacceptor> Leemp: but that's actually cool for the stuff I'm doing atm, so it's fine
08:13:50 <Entroacceptor> Leemp: I'm learning a great deeal
08:13:54 <Raca> does anyone know any other kind of hard, spartan languages like haskell?
08:14:03 <Raca> im serious
08:14:06 <Leemp> cdsmithus: Nah, i wasn't serious, it just sounds like "Look, we're really curious how doing X in Haskell is possible.. we have bright minds working on it!", which seems scary hehe. Not because haskell would be/is "limited", but simply because i'm already learning new theories, so it just all sounds over my head lol. I meant nothing disrespectful by it :)
08:14:08 <Entroacceptor> and it is fun, most of the time
08:14:58 <lars9> Raca: coq
08:15:22 <cdsmithus> Leemp: What I was trying to point out is that while people may be doing research in FRP, for example, as a way to do GUIs (and other stuff) in Haskell... that does NOT mean you have to use them.  The gtk2hs library is a straight-forward wrapper around GTK and should be quite familiar for GUI programming.  Same thing for many other tasks.
08:15:50 <cdsmithus> Leemp: I said that because I feared you might look into FRP thinking it was *the* way to do GUIs in Haskell, and that would be disconcerting indeed
08:16:09 <Leemp> Righto :)
08:16:15 <Leemp> Though, you do have me curious now haha
08:17:21 <lars9> dcoutts_: what's the theoretical support for OOP?
08:17:33 <quicksilver> lars9: OOP has no theory
08:17:45 <quicksilver> lars9: this is one reason why it's widely considered to be a complete failure.
08:17:48 <cdsmithus> Leemp: A major characteristic of programming in Haskell is that abstractions can be built in entirely new ways that wouldn't be possible in other languages.  So people like to explore those, and ask, for example, "Can I build this kind abstraction on top of this task?"  But that doesn't mean you have to; merely that you can.
08:18:24 <cdsmithus> quicksilver: I doubt you'll find majority support for the idea that OOP is a failure.  But lacking in theory, yes.
08:18:30 <osfameron> quicksilver: this is an advanced definition of "widely" that I haven't come across ;-)
08:18:33 <quicksilver> cdsmithus: it was a joke :)
08:18:36 <dcoutts_> lars9: people have constructed semantics for various varieties of OOP, but the practice certainly led the theory
08:18:39 <roconnor> quicksilver: isn't there some sort of mu-calculus or pi-calculus for OOP?
08:18:46 <quicksilver> osfameron: widely consider === considered by quicksilver
08:18:50 <quicksilver> osfameron: (obviously)
08:19:00 <quicksilver> roconnor: yes, there are reams of papers in that vein
08:19:07 <cdsmithus> roconnor: Luca Cardelli had something called object calculus.  But it seemed less fundamental than traditional calculi
08:19:15 * osfameron met quicksilver once, and doesn't remember him being that wide ;-)
08:19:18 <quicksilver> roconnor: they have not arrived at a convincing or unifying consensus.
08:19:27 * quicksilver met Cardelli once.
08:19:34 <quicksilver> so osfameron's cardelli number is officially 2.
08:19:35 <roconnor> quicksilver: okay
08:19:47 <quicksilver> roconnor: not convincing to me, anyway :)
08:19:59 <osfameron> yay!
08:20:11 <osfameron> quicksilver: my Lenin number is 4
08:20:24 <quicksilver> not bad.
08:20:38 <sipa> what's a lenin number?
08:20:52 <quicksilver> but what's your peyton-jones number, osfameron ? Clearly that's more important ;)
08:21:25 <cdsmithus> Are we talking about coauthor Peyton-Jones number?  Or handshake Peyton-Jones number?  If the latter, mine is 1. :)
08:21:38 <quicksilver> cdsmithus: he has something called ambients, too. I find them interesting but not convincing.
08:21:45 <quicksilver> cdsmithus: just handshaking. 
08:22:03 <McManiaC> http://npaste.de/qu/ whats wrong with ghci here?
08:23:09 <quicksilver> McManiaC: :{ doesn't understand layout
08:23:10 <quicksilver> it lets you do multi-line but you still need explicit {} and/or ; for layout constructs
08:23:33 <quicksilver> at least, I never got it to understand layout...
08:23:34 <cdsmithus> quicksilver: That's just pre-7.0 right?  I thought ghci does layout in 7.0
08:23:52 <quicksilver> cdsmithus: I believe so. I've never witnessed it though :)
08:23:58 <cdsmithus> But I don't know whether McManiaC is using 7.0 or not
08:25:17 <McManiaC> quicksilver: ok, it's 6.12
08:25:19 <cdsmithus> *nod* I'm patiently waiting for the platform... despite the fact that the new if-then-else syntax for do blocks will IMO revolutionize Haskell coding in the real world, and its painful doing without it when I know it's there.
08:25:37 <Nibble> cdsmithus: I haven't heard of that
08:25:38 <Nibble> link?
08:25:46 <quicksilver> the new if-then-else syntax is the most catastrophic mistake ever made by the haskell' team
08:25:57 <cdsmithus> @google DoAndIfThenElse
08:25:57 <lambdabot> No Result Found.
08:26:02 <quicksilver> it single handedly burns down everything worthwhile about haskel2010
08:26:02 <cdsmithus> Oops
08:26:37 * quicksilver shakes his head sadly.
08:26:38 <cdsmithus> Seriously?  What can possibly be bad about it?
08:26:39 <quicksilver> it's horrendous
08:26:42 <quicksilver> it takes a rule which people already found a bit tricky to conceptualise
08:26:42 <cdsmithus> Nibble: http://hackage.haskell.org/trac/haskell-prime/wiki/DoAndIfThenElse
08:26:47 <quicksilver> and adds an exception
08:27:00 <quicksilver> which lures them into perpetuating their misconceptions
08:27:01 <cdsmithus> It just adds optional semicolons to if statements
08:27:09 <quicksilver> rather than actually taking what's going on.
08:27:17 <quicksilver> it's much worse than that.
08:27:25 <quicksilver> it breaks the meaning of "a line" in a do block
08:27:40 <quicksilver> a line in a do block was always a single expression, or a x <- expression
08:27:40 <cdsmithus> quicksilver: What about people who understand what's going on, but are sick of programming in the right-hand 20 columns of their screen due to indents?
08:27:54 <quicksilver> cdsmithus: because of one extra space from 'then' and 'else'?
08:28:06 <quicksilver> and if you have nested ifs you're really doing it wrong anyway.
08:28:27 <cdsmithus> quicksilver: I'd like to hear how.  Nested ifs are fairly common.
08:28:41 <quicksilver> I think I can honestly say I've never kept a nested if in a haskell program.
08:29:13 <quicksilver> I might have a single level of nesting in a couple of places.
08:29:32 <cdsmithus> quicksilver: How so?  What's wrong about them?
08:29:43 * quicksilver thinks
08:30:03 <quicksilver> they normally have more code paths than are actually distinct
08:30:19 <quicksilver> and they're often conceptually on the same level.
08:30:30 <applicative> as soon as I write "if ... then ... else if ..." I realize I need to rethink
08:30:40 <quicksilver> if I have all four combinations of P and Q, then rather than a nested if
08:30:42 <quicksilver> I would use
08:30:48 <quicksilver> case (P,Q) of .... 
08:30:57 <quicksilver> and list all four cases (True,False) (False,False) etc.
08:31:15 <quicksilver> if I have a 'trailing' else if, like applicative's example
08:31:18 <quicksilver> the I probably use a guard
08:31:29 <quicksilver> or a 3-or-more-way case
08:31:50 <quicksilver> basically, when the nesting is not actually characteristic of the algorithm being written
08:32:02 <quicksilver> I'd rather 'flatten' the nesting and bring it up to a one-level multi-way switch
08:32:16 <quicksilver> when the algorithm honestly is conceptually nested, I probably split it into two functions
08:32:20 <quicksilver> (even if one is locally defined)
08:32:48 * applicative is totally with quicksilver, but doesn't yet see the cataclysmic danger in the new rule, which he doesn't understand yet...
08:33:06 <quicksilver> applicative: I'm just annoyed they added an exception to a rule which was already hard to understand.
08:33:19 <cdsmithus> quicksilver: Okay, true that the nesting structure is normally not present in the original... but 'case (x < 1, x < 5, x < 10, x < 20) of (True, _, _, _) -> ... ; (False, True, _, _) -> ... ; ... is really ugly
08:33:20 <quicksilver> applicative: I don't think you "fix" a rule which some people find hard by adding an exception to cater to their misunderstanding.
08:33:33 <ManateeLazyCat> Crazy, 
08:33:35 <quicksilver> cdsmithus: I'd definitely use guards for that kind of example
08:33:49 <ManateeLazyCat> Why video editor can't save data in real-time?
08:33:57 <ManateeLazyCat> NO.
08:34:01 <cdsmithus> So, "case True of True | x < 1 -> ..." and so one?
08:34:02 <endojelly> Haskell: if-then-else considered dangerous
08:34:05 <quicksilver> f | x < 1 = ..... | x < 10 = ..... | x < 20 = ....
08:34:25 <applicative> endojelly, I do think it's a bit of a concession to an alien point of view
08:34:30 <quicksilver> when you've got a "cascade" of cases.
08:35:16 <ManateeLazyCat> My 2 hours work over.
08:35:20 <endojelly> I was always a little annoyed when I had to indent the else in do-blocks. So I'm happy now.
08:35:28 <applicative> endojelly, I know this because I feel like my most vulgar tendencies emerge with if then else....
08:35:33 <ManateeLazyCat> I remember i haven't save data when i finish 100%
08:35:59 <endojelly> applicative, heh
08:36:07 <applicative> the style idea of indenting 'else' so it's under 'then ' is a very sound one, since that's where the types match
08:36:08 <ManateeLazyCat> I suppose video editor like my Emacs, save in real-time
08:36:41 * applicative wonders if any editor automates such indentation
08:36:53 <quicksilver> emacs does, yes
08:36:58 <quicksilver> well, the emacs haskellmode
08:37:05 <applicative> damn, another reason to learn haskell mode
08:37:11 <quicksilver> correctly indents when you're inside an if
08:37:31 <ManateeLazyCat> avidemux have any copy somewhere?
08:37:32 <quicksilver> (and if that if is in a layout block
08:37:35 <cdsmithus> Well, I'll just say that I don't agree that chained if-then-else is an indication of anything bad; and that it's optional, so if you'd like to keep indenting, go for it! :)
08:37:52 <ManateeLazyCat> quicksilver: if ident is not perfect in haskellmode
08:38:15 * applicative sees that even the TextMate indenter does this...
08:39:49 <monochrom> I am half annoyed at adding DoIfThenElse, and fully annoyed at adding DoIfThenElse but not its logical conclusion about case. I am fully annoyed at cognitive dissonance people.
08:40:07 <applicative> would you want to be able to have the second case in case x of [] -> 1; x:xs -> 2  -- to line up with "case"?
08:40:39 <cdsmithus> monochrom: What's the case equivalent?  An optional semicolon before of?
08:40:48 <quicksilver> after of
08:40:57 <quicksilver> you'd line up [] and x:xs both with 'case'
08:40:59 <quicksilver> I suppose
08:41:02 <quicksilver> would look ugly to me
08:41:11 <quicksilver> (but DoIfThenElse looks ugly to me, so that's consistent)
08:42:17 <quicksilver> ManateeLazyCat: isn't it?
08:42:38 <ManateeLazyCat> quicksilver: Yes.
08:42:39 <monochrom> "___ is not perfect" is usually a tautology.
08:42:54 <quicksilver> ManateeLazyCat: seems OK to me. which case does it get wrong?
08:43:32 <ursthegizmo> hi
08:43:32 <cdsmithus> quicksilver: I'd guess that lining up patterns with 'case' is likely to be ambiguous syntax though... that's a completely separate issue, and why I think it would be ugly.
08:43:39 <ursthegizmo> hello
08:43:52 <ManateeLazyCat> quicksilver: 'if...else...then' not in ()
08:44:12 <quicksilver> ManateeLazyCat: I just tried a couple of examples they all seem OK to me
08:44:27 <ManateeLazyCat> quicksilver: Ah, maybe my haskell-mode is too old
08:44:27 <quicksilver> I'm not wild on the way it lines up 'then' with 'if' outside of a do block but it's not a disaster
08:44:34 <ManateeLazyCat> quicksilver: I havne't update Emacs long time.
08:44:45 <ManateeLazyCat> quicksilver: I still use 2008-12-25
08:44:50 <quicksilver> ManateeLazyCat: the version that comes with emacs is not good.
08:45:02 <quicksilver> ManateeLazyCat: you need a more recent haskell mode, which has never been included in emacs as far as I know
08:45:23 <monochrom> use version 2.8.0. or at least 2.7.0. ubuntu's is 2.7.0
08:45:26 <ManateeLazyCat> quicksilver: I don't want spend any time on Emacs. :)
08:46:31 * ManateeLazyCat I will build video-editor that support *real-time* backup ... stupid avidemux even don't notice me my vide haven't save to disk......
08:46:46 * ManateeLazyCat Try again.
08:49:29 <monochrom> I read the book "GUI design for dummies". It saved the name for the "for dummies" series. The author is like "why do they make us explicitly save? do they think we modify things just for laughs?"
08:49:34 <Mitar> if I want for data type internals not to be visible i should probably not derive Show on it?
08:51:25 <ManateeLazyCat> monochrom: Right way should, always save user data, and provide a way rollback to old version.
08:51:36 <monochrom> yes
08:51:53 <Entroacceptor> gnome does that
08:51:53 <ManateeLazyCat> monochrom: Program should design that don't ask so many question to user, it should smart finish work.
08:51:59 <Entroacceptor> or at least did in its config stuff
08:52:02 <Entroacceptor> except the rollback
08:52:20 <Entroacceptor> mmh
08:52:34 * Entroacceptor thinks about automatically putting configs into a vcs
08:52:42 <ManateeLazyCat> Entroacceptor: I lost 2 hours YouTube video just because avidemux don't ask me save data, just shutdown immediately
08:52:47 <Entroacceptor> and have a rollback button 
08:52:59 <Entroacceptor> ManateeLazyCat: ok, that's crap, I agree
08:54:36 <ManateeLazyCat> monochrom: I remember a book named : "软件观念革命 - 交互设计精髓"
08:54:59 <ManateeLazyCat> monochrom: The art of interactive design
08:55:29 <ManateeLazyCat> monochrom: One rule is, don't ask user stupid problem, and don't lose user's data
08:55:52 <ManateeLazyCat> monochrom: Another is don't popup dialog.
08:56:19 <ManateeLazyCat> monochrom: And avoid to move user's focus
08:56:30 <ManateeLazyCat> Make user focus on current work.
08:57:27 * ManateeLazyCat Go to edit video, hope i can upload Manatee video (713MB) to YouTube.com tomorrow.
08:57:34 * hackagebot mtl 1.1.1.1 - Monad transformer library  http://hackage.haskell.org/package/mtl-1.1.1.1 (RossPaterson)
09:05:17 <frustrated> Is anyone here?
09:05:23 <tomberek> hi
09:05:56 <frustrated> i'm having a problem with some haskell code, i was wondering of someone could look at it
09:06:01 <frustrated> this is de link: http://hpaste.org/41819/pal
09:07:35 <tomberek> frustrated: sure, i'll try
09:07:41 <frustrated> tnx:D
09:07:43 <monochrom> runParser (satisfy (=='a')), runParser pPaling, etc.
09:07:53 <frustrated> oke tnx monochrom
09:07:56 <frustrated> i'll try it
09:07:59 <frustrated> just a sec
09:08:55 <tomberek> frustrated: yeah, looks like you didn't construct the newtype
09:08:57 <byorgey> frustrated: alternatively, you may find it easier to change the types of <$>, <*>, and <|> to work on Parsers instead of directly on functions
09:09:16 <tomberek> monochrom beat me to it
09:09:27 <byorgey> i.e. (f <$> Parser p) = Parser (\xs -> ...)
09:09:30 <byorgey> and so on
09:09:37 <frustrated> oke
09:09:46 <frustrated> that's a good plan
09:10:01 <frustrated> that't even better i think
09:10:02 <frustrated> tnx
09:10:12 <byorgey> frustrated: is this for a class? or just for personal edification?
09:10:34 <frustrated> how do you mean by class
09:10:40 <frustrated> like class a where?
09:10:48 <byorgey> no, I mean like is it a homework assignment =)
09:11:09 <frustrated> It's kind of homework, but it isn't for a grade
09:11:28 <frustrated> it's just a assignment to learn how to use parsers
09:11:38 <byorgey> ok, sounds good
09:11:51 <frustrated> yes indeed
09:12:03 <byorgey> once you get this working you may also be interested in looking at the Functor, Applicative, and Alternative classes
09:12:10 <byorgey> which are where <$>, <*>, and <|> normally come from
09:12:22 <kaini> *title
09:12:25 <byorgey> but get it working first =)
09:12:29 <frustrated> Yes i know about the classes
09:12:33 <byorgey> oh, ok.
09:12:35 <kaini> uh oh sorry wrong window
09:12:37 <frustrated> but i think it's better to learn it first:P
09:12:43 <byorgey> I agree.
09:12:51 <frustrated> :D
09:13:00 <frustrated> brb
09:32:13 * byorgey makes leftover turkey and cran-lambda-berry sauce sandwiches for everyone
09:38:48 <esdee> if I have lists a, b, c, and d, is there a concise way to get a list of all possible combinations of (a,b,c,d)?
09:40:33 <dankna> I think it's
09:40:37 <Jafet> There is more than one concise way!
09:40:37 <Cale> esdee: sequence [a,b,c,d]
09:40:54 <dankna> [(a, b, c, d) | a <- as, b <- bs, c <- cs, d <- ds]
09:53:44 <Jafet> > (,,,) . [1,2,3] <*> [4,5] <*> [6] <*> [7,8]
09:53:45 <lambdabot>   [(1,4,6,7),(1,4,6,8),(1,5,6,7),(1,5,6,8),(2,4,6,7),(2,4,6,8),(2,5,6,7),(2,5...
09:54:17 <Jafet> @pl \a b c d -> (,,,) <$> a <*> b <*> c <*> d
09:54:17 <lambdabot> (((((((,,,) <$>) .) . (<*>)) .) . (<*>)) .) . (<*>)
09:54:19 <Nibble> how would I go ahead multithreading [(x,y,z) | x <- [1..100], y <- [1..100], z <- [1..100] , x < z, y < z, x^2 + y^2 == z^2]
09:54:35 <revenantphx> So ah
09:54:45 <Jafet> > ((((((((,,,) <$>) .) . (<*>)) .) . (<*>)) .) . (<*>)) [] [] [] []
09:54:46 <lambdabot>   Overlapping instances for GHC.Show.Show
09:54:46 <lambdabot>                              (b -> ...
09:54:47 <revenantphx> In this http://homepages.dcc.ufmg.br/~camarao/fp/articles/lazy-state.pdf , is "MutVar" really just STRef?
09:54:56 <revenantphx> Jafet: Why do I have to wake up to this...
09:55:11 <revenantphx> Can't you use seq or $ instead of parentheses :P
09:55:32 <Jafet> You would rather have CReal?
09:56:02 <monochrom> yes mutvar becomes stref
09:56:14 <revenantphx> monochrom: kk.
09:57:03 <Raca> monochrom
09:57:52 <ddilinger> Nibble: i'm fairly sure it can be split across processors, i've read haskell stuff refering to resolving a list comprehension in parallel, but not sure where
09:57:53 <roconnor> Nibble: that appears to be a job for RePa.
09:58:11 <lars9> how is the reputation of Go among haskellers?
09:58:18 <roconnor> lars9: low
09:58:31 <monochrom> oh, Go language, not Go game? :)
09:58:47 <geheimdienst> lars9, we could warm up to the game. roconnor referred to the language
09:59:14 <lars9> monochrom: i've got starcraft, thats enough for me
09:59:19 <monochrom> 碁
09:59:29 <roconnor> oh, I like 碁
09:59:36 <Lemmih> lars9: What league are you in?
09:59:53 <roconnor> assuming those scribbles in that glyph mean "Go"
10:00:05 <monochrom> yes it does
10:00:18 <ddilinger> Nibble: these are just slides, but a good overview of multi-processor haskell: http://donsbot.wordpress.com/2010/06/01/open-source-bridge-talk-multicore-haskell-now/
10:00:22 * geheimdienst thinks "go" is seriously ungooglable. the korean name (baduk) is better from that perspective
10:00:36 <lars9> Lemmih: i dunno, maybe the one who will pay me
10:00:39 <ddilinger> geheimdienst: its golang
10:01:06 <ddilinger> geheimdienst: its just sort of agreed on in the go community that the keyword is golang, noone googles go :)
10:01:12 <roconnor> geheimdienst: how about weiqi ?
10:03:39 <osaunders> Haskell in PHP: <https://gist.github.com/717023> :-O
10:04:38 <sm> osaunders: you nut :)
10:05:16 <Jafet> return call_user_func(mkList('is_' . gettype($x)), array($x));
10:05:19 <mauke> http://mauke.ath.cx/stuff/perl/yes.pl - Haskell in Perl
10:05:26 <Jafet> No, good sir, that does not look very much like Haskell
10:06:06 <osaunders> Jafet: Well, no.
10:06:13 <osaunders> It was just a bit of fun.
10:06:25 <Jafet> I flinched more than once.
10:06:34 <Jafet> Maybe it's because I know PHP
10:06:42 <osaunders> Yes, probably.
10:06:55 <osaunders> If you know PHP you'll realize what I'm doing isn't very complete or reliable.
10:07:09 <osaunders> It works for lists of some some types though.
10:07:23 <osaunders> ints, strings, objects all work.
10:07:51 <Nibble> why does this work in ghci, but not in ghc, [(x,y,z) | x <- [1..100], y <- [1..100], z <- [1..100], x < z, y < z, x^2 + y^2 == z^2]
10:08:01 <sm> has anyone got gtk2hs working on a mac lately ? which variant of the gtk2 macport did you use ?
10:08:02 <Nibble>     Couldn't match expected type `Language.Haskell.TH.Syntax.Q
10:08:03 <Nibble>                                     [Language.Haskell.TH.Syntax.Dec]'
10:08:03 <Nibble>            against inferred type `[a]'
10:08:03 <Nibble>  
10:08:39 <Jafet> That's not even valid TH, eh
10:08:50 <osaunders> sm: I got it to work using: gtk2 @2.22.1_0+x11
10:08:50 <MeineWenigkeit> why do I get an error when typing    read "3.3"   but   (read "3.3")/2   works?
10:08:57 <Jafet> Better clean your pipe
10:09:50 <mauke> MeineWenigkeit: what error do you get?
10:09:57 <sm> osaunders: good to know, thanks. I currently have gtk2 @2.22.0_0+no_x11+x11 (!) installed but while installing eg Chart I get Loading package gtk-0.12.0 ... <command line>: can't load .so/.DLL for: gdk-quartz-2.0 (dlopen(libgdk-quartz-2.0.dylib, 9): image not found)
10:10:02 <osaunders> MeineWenigkeit: Because "3.3" is ambigious but the second one probably causes GHC to pick a default.
10:10:18 <MeineWenigkeit>     Ambiguous type variable `a' in the constraint:       `Read a' arising from a use of `read' at <interactive>:1:0-9     Probable fix: add a type signature that fixes these type variable(s) 
10:10:45 <mauke> MeineWenigkeit: 'read' is overloaded based on its return type
10:10:46 <osaunders> MeineWenigkeit: It is feasible that some custom type could have a representation of "3.3"
10:10:57 <MeineWenigkeit> thanks
10:10:59 <mauke> MeineWenigkeit: ghci doesn't know which 'read' to call there
10:11:14 <osaunders> But with the application of «/» GHC knows what type to expect.
10:11:19 <osaunders> Roughly.
10:11:27 <Jafet> Defaulting sucks
10:11:30 <Nibble> urk
10:12:25 <Nibble> How would I go ahead threading that code then :/ I have had no success
10:12:32 <sm> it's not "defaulting", it's type inference
10:12:52 <osaunders> sm: Yes, you're right, my mistake.
10:13:13 <osaunders> Although I think there is some defaulting going on because / wants a fractional.
10:13:16 <osaunders> :t (/)
10:13:16 <lambdabot> forall a. (Fractional a) => a -> a -> a
10:13:22 <osaunders> But that's not actually the issue.
10:13:42 * osaunders heads off.
10:13:52 <mauke> it is defaulting!
10:14:01 <sm> just clarifying for those who might think there's a magic special case going on. I don't think there is... eh ?
10:14:03 <Jafet> Capital idea, osaunders.
10:14:36 <tomberek> MonadState vs ST ?  is this like foldl vs foldl' in terms of the reasons for and against?
10:15:21 <Jafet> :t let x = read "" / 2 in x
10:15:22 <lambdabot> forall a. (Fractional a, Read a) => a
10:16:16 <cdsmithus> Can anyone help me convince cabal to install http-enumerator with network-2.2.3 or higher?
10:16:22 <Jafet> > read "1" / 2 -- blah, screw the types
10:16:23 <lambdabot>   0.5
10:16:30 <Raca> :t let x = read "" / 2 in x
10:16:32 <lambdabot> forall a. (Fractional a, Read a) => a
10:16:42 <Raca> :t Jafet
10:16:43 <lambdabot> Not in scope: data constructor `Jafet'
10:20:17 <Raca> :t iterate
10:20:18 <lambdabot> forall a. (a -> a) -> a -> [a]
10:20:53 <edwardk1> preflex: xseen Apocalisp
10:20:53 <preflex>  Apocalisp was last seen on freenode/#haskell 1 day, 19 hours, 31 minutes and 22 seconds ago, saying: it only works for ADTs
10:21:04 <cdsmithus> More specifically, how do I convince cabal to pick a specific one of the possible sets of dependencies?  I want network 2.3.*, NOT the network-bytestring package, but Cabal seems to not want to do that
10:21:29 <Raca> preflex: xseen Cale
10:21:29 <preflex>  Cale was last seen on freenode/#haskell 40 minutes and 52 seconds ago, saying: esdee: sequence [a,b,c,d]
10:21:45 <Raca> sequence [a,b,c,d]
10:24:49 <sm> b0
10:25:24 <edwardk1> @tell Apocalisp if you unsealed MA, couldn't MAB extend PimpedType[M[A,B]] with MA[PartialApply1Of2[M,A]#Apply,B] fixing dispatch for state, etc?
10:25:25 <lambdabot> Consider it noted.
10:35:49 <romildo> I need a function similar to Data.List.findIndex, but what accepts a monad predicate to test the elements on the list. I have written the one at http://hpaste.org/41822/findindex_with_a_monadic_predi
10:36:12 <romildo> How can this function be rewritten using combinators?
10:37:10 <romildo> The function that test the elements of the list is monadic.
10:41:38 <Jafet> :t (\p xs -> liftM2 findIndex p $ return xs)
10:41:39 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> [a] -> m (Maybe Int)
10:41:44 <Raca> let adjectives = ["lazy", "hungry"];
10:41:52 <Jafet> @pl \p xs -> liftM2 findIndex p $ return xs
10:41:52 <lambdabot> (. return) . liftM2 findIndex
10:41:53 <Raca> let adjectives = ["lazy", "hungry"];
10:42:33 <tomberek> MonadState vs ST ?  is this like foldl vs foldl' in terms of the reasons for and against?
10:44:31 <roconnor> the MonadState and ST interfaces are quite different.
10:45:07 <jdavis_> I am trying to learn Happy. In the %token declaration, what's the $$ really mean?
10:46:11 <McManiaC> http://npaste.de/r1/ :D
10:48:38 <ben> @pl \f (a, b, c) -> f a b c
10:48:39 <lambdabot> (line 1, column 9):
10:48:39 <lambdabot> unexpected ","
10:48:39 <lambdabot> expecting letter or digit, operator or ")"
10:48:39 <lambdabot> ambiguous use of a non associative operator
10:48:48 <mauke> no triples
10:48:56 <ben> Well. I know how to say it for pairs.
10:49:06 <mauke> so does @pl :-)
10:49:19 <ben> So is there a clever way to say uncurry3?
10:49:34 <Jafet> No.
10:53:16 <radioactive_man> ben, there is
10:55:02 <radioactive_man> you can do it similar to that: https://haskell.cs.yale.edu/haskellwiki/Template_Haskell#.27generic.27_zipWith
10:55:23 <Jafet> That's the painful, desperate way
10:56:15 <radioactive_man> better than handcoding uncurry3..n
10:56:37 <radioactive_man> just using $(mkUncurry 3) sounds not *that* bad
10:57:14 <mauke> how often do you need uncurryn?
10:57:22 <radioactive_man> never ^^
10:57:24 <radioactive_man> :D
10:57:35 <Jafet> instance Functor (a,...) where
10:59:42 <byorgey> handcoding just uncurry3 is way better than generating it with TH, if that's the only one you need.
10:59:52 <byorgey> and if you need uncurry4 or higher, you are Doing It Wrong.
10:59:56 <ClaudiusMaximus> latest music I made with Haskell and Pure-data: http://claudiusmaximus.goto10.org/g/mandelbrot/gmndl-zzc-pd-bridge-proof-of-concept.ogg ; screenshot of Haskell program: http://claudiusmaximus.goto10.org/g/mandelbrot/gmndl-zzc-pd-bridge-proof-of-concept-2.png ; screenshot of Pure-data program: http://claudiusmaximus.goto10.org/g/mandelbrot/gmndl-zzc-pd-bridge-proof-of-concept.png
11:00:44 <ClaudiusMaximus> next step is to make the bridge fully automatic, instead of copy/paste into terminal and reformatting...
11:01:40 <byorgey> ClaudiusMaximus: you're generating music based on the mandelbrot set?
11:01:46 <ClaudiusMaximus> byorgey: yep!
11:01:49 <byorgey> neat =)
11:02:08 <Jafet> I prefer listening to something with integral hausdorff dimension
11:02:42 <ClaudiusMaximus> byorgey: released an EP on GOSUB10 netlabel with the pure-data source code..  http://gosub10.org/GOSUB10-003.html
11:03:24 <ClaudiusMaximus> > fromIntegral 2
11:03:24 <lambdabot>   2
11:03:37 <Raca> @help
11:03:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:03:50 <byorgey> ClaudiusMaximus: nice, congrats
11:03:57 <ClaudiusMaximus> :)
11:04:09 <Jafet> Oh, so it is
11:04:10 * byorgey listens
11:04:44 <Jiten> it sounds pretty nice, at first, then it becomes boring since the same pattern repeats over and over :)
11:04:53 <Jiten> but a good start :)
11:05:03 <Raca> @ map (+1) [1..10]
11:05:04 <ClaudiusMaximus> that EP was made by manually counting blobs and zooming in, etc; but i've been working on automating it since the release...
11:05:13 <Raca> how do you put commands in
11:05:22 <Raca> > map (+1) [1..10]
11:05:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
11:05:25 <Raca> oh
11:06:01 <Raca> > (> 3) 'filter' [1..10]
11:06:01 <lambdabot>   <no location info>:
11:06:02 <lambdabot>      lexical error in string/character literal at chara...
11:06:06 * byorgey wants to compose something involving Stern's diatomic series
11:07:24 <Jafet> You might have better luck with diatonic series
11:08:00 <Raca> > (> 3) 'filter' [1..10]
11:08:00 <lambdabot>   <no location info>:
11:08:01 <lambdabot>      lexical error in string/character literal at chara...
11:08:12 <mauke> Raca: you fail at copy/paste
11:08:26 <Raca> haha
11:08:46 <Raca> this mauke guy is interesting, lets see what he is
11:08:49 <Raca> :t mauke
11:08:50 <lambdabot> Not in scope: `mauke'
11:09:40 <mauke> > isLower `filter` "Raca"
11:09:41 <lambdabot>   "aca"
11:10:22 <mauke> > "mauke" > "Raca"
11:10:23 <lambdabot>   True
11:12:14 <byorgey> Jafet: hehe
11:13:04 <byorgey> > (> 3) `filter` [1..10]  -- there are many kinds of quotes
11:13:05 <lambdabot>   [4,5,6,7,8,9,10]
11:13:22 <mauke> such as `àwesome quoteś´
11:13:46 <Jafet> A purely functional audio patch system might be fun to write
11:14:28 <Jafet> Or bind ladspa, which is less fun to write
11:15:14 <ousado_> ClaudiusMaximus: is this about the enjoyment of art?
11:16:25 <chreekat> I have a question about some code but never know which pastebin type site to use. What's commonly used around here?
11:16:38 <roconnor> @paste
11:16:39 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:16:43 <roconnor> pfft
11:16:50 <Jafet> @where paste
11:16:50 <roconnor> that link is like 20 years out of date
11:16:50 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
11:17:00 <ClaudiusMaximus> ousado_: it's fiddling about until something vaguely listenable emerges - if that's art then i suppose so
11:17:52 <romildo> Jafet, your function above "\p xs = liftM2 findIndex p $ return xs" is not what I am looking for. The type of your function is "Monad m => m (a -> Bool) -> [a] -> m (Maybe Int)", and the one I need has the type "Monad m => (a -> m Bool) -> [a] -> m (Maybe Int)"
11:17:58 <Jafet> There are no standards for art, but I like to think there are standards for music, and a bunch of random octaves may or may not meet those standards
11:18:28 <Jafet> romildo: indeed
11:20:16 <turmfalke> small question, is it possible to replace every parenthesis with a $? I don't think I got the concept of $ and . yet
11:20:25 <mauke> no
11:20:43 <byorgey> $ is just function application:  f $ x = f x
11:20:53 <byorgey> but it has precedence 0
11:21:15 <byorgey> so e.g.  foo bar $ 3 + 5   parses as  (foo bar) $ (3 + 5)
11:21:15 <Jafet> If you can afford to, by all means
11:21:26 <Raca> $
11:21:29 <byorgey> since $ has lower precedence than + and function application
11:21:37 <byorgey> function application has higher precedence than anything else.
11:21:47 <turmfalke> hm.. ok
11:21:57 <ursthegizmo> hi
11:22:01 <mauke> except for record update
11:22:12 <ursthegizmo> hi
11:22:23 <byorgey> mauke: yes, I was avoiding having to mention that ;)
11:22:37 <byorgey> hi ursthegizmo, we heard you the first time =)
11:23:20 <byorgey> turmfalke: (.)  is function composition.
11:23:34 <byorgey> (f . g) x  = f (g x)
11:23:37 <Paczesiowa> nominolo: what's the status of scion? how does it relate to ghc-mod?
11:26:34 <McManiaC> http://npaste.de/r3/ :D
11:28:44 <chreekat> Ha, I did not expect to spend 10 minutes learning better Haskell by pasting into hpaste.org and getting chided by HLint
11:31:38 <chreekat> Anyway. I wrote a brute-force algorithm to solve problem 14 on the Euler Project. In C it takes 4 seconds, but my Haskell code takes some number of hours. Could someone help me understand what is happening with my Haskell?
11:31:56 <chreekat> Code is : http://hpaste.org/41825/collatz_sequences
11:32:43 <Paczesiowa> chreekat: do you compile with -O2 ?
11:33:19 <chreekat> My C? I complied as 'gcc -ggdb -W -Wall p14.c'
11:33:27 <mauke> no, your haskell
11:33:36 <chreekat> Using ghci
11:33:39 <mauke> pfft
11:33:45 <chreekat> Ah ha
11:34:09 <mauke> also, does your C code recompute p14SeqLen all the time?
11:35:37 <Phyx-> everyone notice ghci is very unresponsive after idling for ~6 hours? it's probably paging it back in, but it takes a looong time to resume
11:35:59 <Jafet> Phyx: "probably"?
11:36:55 <nostrand> Phyx-: i have seen that sometimes too
11:37:55 <ski> @type (. (,)) . (.)
11:37:56 <lambdabot> forall a b b1. ((a, b) -> b1) -> a -> b -> b1
11:38:00 <ski> @type (. (,,)) . (.) . (.)
11:38:02 <lambdabot> forall a b c b1. ((a, b, c) -> b1) -> a -> b -> c -> b1
11:38:02 <chreekat> I actually made my C code build an array of {start, length} structs
11:38:06 <ski> @type (. (,,,)) . (.) . (.) . (.)
11:38:07 <lambdabot> forall a b c d b1. ((a, b, c, d) -> b1) -> a -> b -> c -> d -> b1
11:39:52 <chreekat> When I compile my haskell code, I get a stack space overflow
11:39:58 <chreekat> With and without -O2
11:40:29 <chreekat> (sorry, i mean "when I compile my haskell code and run the resulting executable")
11:41:14 <Paczesiowa> chreekat: but it works in ghci?
11:42:30 <chreekat> Paczesiowa: I never actually let it run to completion. I did let it chug for two hours once.
11:42:47 <chreekat> The algorithm works for smaller inputs though :)
11:42:50 <Cale> chreekat: Is it short enough to paste?
11:42:57 <Cale> (on hpaste, say)
11:43:08 <mauke> <chreekat> Code is : http://hpaste.org/41825/collatz_sequences
11:43:16 <Cale> ah
11:43:16 <chreekat> ta
11:43:22 <sm> omg.. the joys of relying on four different packaging systems.. (apple, macports, ghc, cabal)
11:43:29 <Cale> ah, okay
11:43:31 <McManiaC> hmmm how do you use Control.Monad.List.ListT ??
11:43:31 <magicman> The stack overflow is probably neverending layers of (1+). Maybe adding the length as accumulating parameter (and enforcing strictness on it) helps.
11:43:40 <Cale> You're not doing any memoisation there.
11:43:48 <magicman> And the memoing thing, of course :P
11:44:00 <Paczesiowa> McManiaC: why do you need it?
11:44:05 <chreekat> Right, that's why I call it the brute force method. :)
11:44:13 <mauke> chreekat: http://hpaste.org/paste/41825/my_version#p41826
11:44:21 <Cale> Yeah, the stack overflow is definitely the giant expression constructed of 1 + (1 + ...) being evaluated
11:44:23 <mauke> not exactly fast but doesn't seem to stack overflow
11:44:32 <Phyx-> Jafet: well, i'm not sure why it would even page it out, my physical memory is almost never full
11:44:38 <chreekat> Ok! That's what I was concerned about
11:45:17 <chreekat> But how do I avoid that? I was vaguely under the impression that ghc would manage tail call optimization for me
11:45:20 <cdsmithus> AAAAAAAAAHHHHHHH!  I hate Cabal version dependencies some days. :(
11:45:27 <McManiaC> Paczesiowa: want to try something :)
11:45:31 <Cale> Tail call optimisation doesn't apply to lazy evaluation
11:45:34 <ski> McManiaC : that's the (broken) `newtype ListT m a = ListT (m [a])' version, yes ?
11:45:35 <lambdabot> ski: You have 1 new message. '/msg lambdabot @messages' to read it.
11:45:40 <McManiaC> ski: yeah
11:45:43 <ski> @messages
11:45:43 <lambdabot> byorgey said 23h 19m 31s ago: re: complete, yes, in the sense that it 'proves all true things': there aren't any natural numbers for which i2n yields Nothing. re: the adjunction, probably!
11:45:46 <Cale> chreekat: The stack is completely unrelated to function calls
11:45:51 <McManiaC> ski: is there a working version of it?
11:46:18 <Cale> chreekat: It consists of case expressions whose scrutinee is not evaluated enough to pattern match
11:46:19 <Phyx-> @tell
11:46:19 <lambdabot> Plugin `tell' failed with: Prelude.head: empty list
11:46:23 <Phyx-> @help tell
11:46:24 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
11:46:44 <ski> McManiaC : i forget, but one such would be `newtype ListT m a = MkListT (m (ListTCell m a)); data ListTCell m a = Nil | Cons a (ListT m a)'
11:46:45 <Phyx-> @tell dcoutts Hi, did you ever get a chance to review that email i send to cabal-devel about the API?
11:46:46 <Cale> chreekat: This includes things like (+), which you can think of as pattern matching on both its arguments.
11:46:46 <lambdabot> Consider it noted.
11:47:20 <ski> McManiaC : btw, the broken part of the former `ListT' is that only if `m' is a "commutative" monad is `ListT m' also a monad
11:48:06 <Cale> chreekat: So, for one of the longer sequences, your p14SeqLen will run to completion, producing a giant expression like 1 + (1 + ... (1 + 1)...)
11:48:20 <Cale> chreekat: and evaluating that expression is what kills the stack
11:48:40 <Cale> the right parameter to the outermost (+) isn't evaluated enough to match on yet
11:49:05 <McManiaC> ski: ok... so how would you use it if its working for a non commutative monad?
11:49:13 <Cale> so it goes on the stack, and then the right parameter starts evaluating, and the same thing happens over and over until (1 + 1) is reached, or the stack runs out.
11:49:22 <ski> McManiaC : use the variant i gave ?
11:49:40 <ski> or use the former variant ?
11:49:49 <chreekat> Cale: Ok. I do not understand immediately but I think I can figure it out after rereading your explanation a few times.
11:49:51 <Cale> chreekat: So, the solution is to ensure that a large expression for the length doesn't build up, and you get things evaluated earlier.
11:50:47 <crutcher> chreekat: tail call optimization can't help here; 1 + SomeNumber can't be computed until you know SomeNumber
11:51:25 <crutcher> chreekat: so you need an approach that passes an accumulator of all the values added so far
11:52:22 <ski> byorgey : i think one can also use that adjunction to characterize truncating subtractions (i.e. "monus" more or less) on other monoids, such as lists .. <http://en.wikipedia.org/wiki/Monus> only seems to mention commutative monoids, though
11:52:44 <ski> s/characterize/specify/
11:53:00 <chreekat> Ok! Thanks folks. I am understanding.
11:53:53 <byorgey> a − b = the smallest c such that a + b = c if a ≤ b, or    -- seems totally wrong, or am I crazy?
11:54:01 <Cale> Tail call optimisation is irrelevant in the context of Haskell.
11:54:30 <Paczesiowa> what about strict foldls'?
11:54:40 <Cale> Yeah, those might help :)
11:55:04 <Cale> (but you don't need tail call optimisation for them to be efficient, you just need the usual lazy evaluator + seq)
11:56:26 <byorgey> ski: thanks for the idea though, I'll give it some thought
11:57:21 <ski> byorgey : `forall n. m - o =< n <=> m =< n + o' can be read loud as "`m - o' is the least `n' such that `m =< n + o'"
11:58:20 <ski> byorgey : reading it like that only requires `n |-> (m =< n + o)' to be monotonic (which is it), to make sure that conforms with the usual definition of `least'
11:58:35 <byorgey> ski: sure, that makes sense
11:58:59 <byorgey> ski: my beef with the quote from the wikipedia page is that the letters are switched around
11:59:02 <ski> byorgey : generally `forall y. x =< y <=> P y' can be read as "`x' is the least `y' such that `P y'", when `P' is monotonic
11:59:39 <cdsmithus> I'm starting to decide that a good practice for a large-scale haskell project is to set up a local hackage so you have a place to put all the libraries for which you had to change version bounds, and get cabal-install to handle them for you.
12:00:01 <eigen> I'm attempting to install cabal on arch linux. What's the proper procedure for this?
12:00:17 <Paczesiowa> eigen: install haskell-platform
12:01:02 <byorgey> cdsmithus: interesting idea.  I was actually just thinking about writing a blog post asking for people's thoughts on managing large-scale projects
12:01:17 <ski> byorgey : yeah, i think that page has a bug (if noone has fixed it since last time i looked) .. i was going to fix it, but got dragged into checking into the paper referenced, to be sure to use the same definitions, and then i never got around to it ..
12:01:29 <quicksilver> cdsmithus: I have similar problems in Perl.
12:01:31 <sm> cdsmithus: capri won't do ?
12:01:35 <crutcher> chreekat: http://hpaste.org/41827/collatz_sequences_fixed
12:01:38 <cdsmithus> capri?
12:01:38 <byorgey> cdsmithus: I don't have the version bounds problem, but I do have the problem that the project comprises several cabal packages which depend on one another
12:01:38 <eigen> Paczesiowa: via pacman?
12:01:41 <cdsmithus> @google capri
12:01:42 <lambdabot> http://en.wikipedia.org/wiki/Capri
12:01:42 <lambdabot> Title: Capri - Wikipedia, the free encyclopedia
12:01:47 <quicksilver> cdsmithus: (the perl community doesn't have brilliant answers to it either although thre are plenty of part answers)
12:01:48 <byorgey> ski: hehe
12:01:50 <sm> http://hackage.haskell.org/package/capri
12:02:12 <cdsmithus> Oh, that's nice!
12:02:27 <Paczesiowa> eigen: I don't use arch, but I'm sure that there's a package for haskell-platform, after all dons uses arch
12:03:05 <sm> cdsmithus: yes I think so.. only tried it briefly but it seems useful
12:04:01 <cdsmithus> sm: I'll poke at it; not sure if it'll solve this problem or not.  Mainly that I'm having to download, modify, and install modified versions of eight or nine different packages, just to tweak their dependencies.
12:04:18 <ski> byorgey : anyway, i find this "adjunction-like" `forall y. x =< y <=> P y' to be very useful for all kinds of things .. e.g. for specifying what absolute value of real numbers mean : `forall y. |x| =< y <=> -y =< x =< y'
12:05:03 <sm> I hear that, I certainly agree dealing with dependencies gets time consuming in non-small projects
12:05:07 <ski> byorgey : proofs usually get less tedious (and often one can do both directions at once), using this (i think Dijkstra has some note about this, as well)
12:05:28 <byorgey> ski: neat
12:05:31 <Cale> chreekat: btw, why not compute the sequence that you're computing the length of and then just apply length?
12:05:35 * byorgey files this idea away for future reference
12:06:39 <chreekat> Cale: That was, in fact, an earlier version. While trying to figure out what was taking so long I moved to the current version.
12:07:27 <quicksilver>  /win 22
12:08:30 <Cale> chreekat: The thing which will really help here is to not recompute the sequence lengths for every single comparison.
12:09:16 <Cale> chreekat: that is, to switch from maximumBy (comparing p14SeqLen) to  fst . maximumBy (comparing snd) . (zip <*> map p14SeqLen)
12:09:34 <ben> What is the [Dec] for in Language.Haskell.TH.Match?
12:09:55 <Cale> (or if you're unfamiliar with that use of <*>,  (\xs -> zip xs (map p14SeqLen xs))
12:11:36 <Cale> ben: case expressions are allowed to have where clauses
12:11:48 <ben> Oh, I did not know what at all. Thanks.
12:12:06 <Cale> I'm not sure if it's standard.
12:12:19 <Cale> oh, yes it is :)
12:12:26 <ben> All the Qs in the [| |] stuff are really confusing :(
12:12:53 <chreekat> Cale: The thing is that I used an identical algorithm in C and it takes 4 seconds.
12:13:11 <Cale> chreekat: Are you sure it's identical?
12:13:22 <Cale> chreekat: What does your C code look like? :)
12:13:54 <Cale> chreekat: Currently, you're recomputing the sequence length of both values for every comparison.
12:14:48 <chreekat> Cale: That is the question, isn't it? ;) I'll paste the code
12:15:20 <chreekat> Cale: Oh, you're right. I have a different version that did not do that. Here, let me clean up my two versions, make them identical, and come back
12:16:18 <crutcher> chreekat: you recompute the value every time a compare is done
12:16:24 <mauke> so I was playing around with my version and http://p3rl.org/8767TCVR is reasonably fast
12:17:28 <crutcher> chreekat: http://hpaste.org/41828/collatz_faster
12:17:39 <crutcher> chreekat: that runs in 6 seconds on my laptop
12:18:41 <augur> byorgey: hmm. how does it precompute the bounds? :|
12:19:23 <byorgey> augur: very carefully ;)
12:19:29 <augur> lol
12:19:43 <augur> well, i implemented it with a carry-in
12:19:53 <byorgey> augur: it's not actually that hard.  every species has an associated (lo,hi) range
12:20:03 <augur> hm
12:20:10 <byorgey> where lo,hi are taken from the set  Nat + {infinity}
12:20:15 <augur> ahh ok
12:20:33 <byorgey> and then it's just a matter of working out how each species operation corresponds to operations on ranges
12:20:51 <byorgey> the only tricky bit is recursive species but that can be worked out too
12:20:58 <augur> what i did was i had a covert optional argument (i did it in ruby, see) called ins which gets carried through each enumerate
12:21:00 <byorgey> I forget the exact details
12:21:22 <byorgey> and what is ins?
12:21:58 <chreekat> crutcher: That gives me a stack space overflow
12:22:16 <chreekat> "Stack space overflow: current size 8388608 bytes."
12:22:31 <augur> if you enumerate something like `mu s. f` with xs, instead of carrying through ins by itself, you carry through [`mu s. f`, xs]:ins
12:23:22 <crutcher> chreekat: what version of ghc are you using?
12:23:22 <augur> so each mu enumeration knows its inside another mu enumeration, and it knows what that enumeration looked like
12:23:27 <monochrom> for example ceiling cat is characterized by ∀y::Integer. ⌈x⌉≤y ⇔ x ≤ fromIntegral y. ceiling cat and fromIntegral are Galois-connected.
12:23:30 <Cale> http://hpaste.org/41829/my_version
12:23:40 <Cale> ^^ that's reasonably fast
12:23:44 <augur> if you try to enumerate two identical mu's, one inside the other, the lower one returns nothing
12:23:52 <Cale> Takes 0.7s on my machine
12:23:56 <augur> well, it returns []
12:24:44 <Cale> I get around the stack overflow using memoisation ;)
12:25:00 <Cale> There's probably something less cheesy you could do, but there you go.
12:25:15 <ben> Is there a simpler way to say uncurry (liftM2 (,))
12:25:19 <ben> I feel like I must be missing something
12:25:32 <byorgey> augur: hmm... and how would  L = 1 + X * L  work?  What would tell the L inside another L that it *should* return something?
12:26:49 <augur> byorgey: well, so it depends slightly on how i implemented mu, right. since i did it in ruby, i cant have lazy evaluation, so i need an actual mu combinator, with a separate mu variable combinator that gets "bound"
12:27:01 <chreekat> crutcher: 6.12.1, stock whatever that comes with ubuntu 10.04
12:27:12 <chreekat> Cale: that is purty
12:27:17 <crutcher> hmm, I'm 6.12.3 on osx
12:27:19 <byorgey> augur: sure, fine, so mu L. 1 + X * L
12:27:53 <augur> byorgey: that is, you do something like v = MuVar.new; L = Mu.new(v, 1 + X*v), and the second one does v.bind_by(self)
12:27:58 <crutcher> Cale: I don't understand why my version would _have_ a stack overflow, unless it was lazy on 1 + acc
12:28:52 <chreekat> crutcher: I wondered the same thing
12:29:02 <byorgey> augur: ok, fine, but I still don't understand.  How does your scheme work properly for L = 1 + X*L but avoid recursing infinitely for P = X + P*P ?
12:29:03 <augur> then Mu::enumerate(xs, ins) is then defined as something like   ins.include?([self,xs]) ? [] : @scope.enumerate(xs, [[self,ins]] + ins)
12:29:10 <crutcher> Cale: that, and your version has the 1 + (some thing) pattern
12:29:40 <byorgey> augur: oh, I see, you check whether any of the xs have been used
12:29:43 <crutcher> Cale: wait, I see
12:29:45 <chreekat> crutcher: He's "cheating" by memoizing, so the 1 + (1 + ..) expr never gets too big
12:29:49 <chreekat> aye
12:30:09 <augur> byorgey: yeah. you carry in a mini-history (of all the mu enumerations above you, and what the labels enumerated were)
12:30:27 <augur> and if theres ever a repetition, you kill it there, since you know it wont return anything
12:30:47 <chreekat> crutcher, Cale : I gotta go, but thanks for the insights. I'll probably be back
12:31:13 <augur> X*L works fine because the label set is reducing each time, whereas P*P it isnt
12:31:32 <augur> i dont know if this actually works properly in all cases, there might be cases where it fails miserably :p
12:33:47 <byorgey> augur: I'm not sure, but it sounds OK to me
12:33:58 <byorgey> actually sounds more robust than my method =)
12:34:09 <byorgey> but my method gives you other efficiency benefits as well
12:34:39 <byorgey> since even for non-recursive things it can avoid making calls to enumerate in cases where it has been able to prove beforehand that no structures will get generated
12:34:48 <augur> its a nasty technique, dude. firstly, you have to have extra arguments for enumerate (maybe Reader could handle it nicely, since it *does* look a bit like variable binding)
12:35:11 <byorgey> I didn't say it wasn't nasty, just that it's more *robust* =)
12:35:14 <augur> :p
12:35:30 <augur> i dont think the bounds version is a bad idea at all
12:36:12 <augur> i was considering it but couldnt figure out how to appropriate bound recursive species automatically, so i said pah!
12:36:19 <byorgey> the only problem is that since it's an approximation, I don't know for sure that there aren't cases where it fails
12:36:45 <augur> also, i defined some new unary combinators that i think are useful in making clean species
12:36:51 <byorgey> well, if you're interested I could refresh myself on how I did it for recursive species
12:36:53 <McManiaC> http://npaste.de/r6/ meeeh I'm too stupid to do this, what am I doing wrong? :>
12:36:54 <byorgey> such as?
12:37:24 <djahandarie> preflex, seen chrisdon
12:37:24 <preflex>  Sorry, I haven't seen chrisdon
12:37:25 <djahandarie> preflex, seen chrisdone
12:37:26 <preflex>  chrisdone was last seen on #haskell 9 days, 8 hours, 12 minutes and 3 seconds ago, saying: oh well, I can just use that one now
12:37:39 <augur> so like while E*E is a nice way of getting subsets, its nasty because you have to write your code to deal with species pairs, and then strip that second pair off later in your code to test it
12:37:59 <byorgey> yup
12:38:14 <augur> so why not have a combinator like ?E that lets you drop elements from the labels with no cost
12:38:48 <byorgey> so ?E is like a special primitive "subset" species?
12:39:21 <augur> no, ? is just a combinator that works just like * except it discards one of the pairs
12:40:12 <augur> so lets see, if * is defined with   enumerate ls = [(x,y) | (fls,gls) <- split ls, x <- enumerate fls, y = enumerate gls]
12:40:27 <byorgey> oh, I see, nice
12:40:38 <augur> then ? is defined with   enumerate ls = [ x | (fls,gls) <- split fls, x <- enumerate fls]
12:40:49 <byorgey> yes, I see
12:42:51 <augur> or maybe you have Lam where   enumerate (Lam (F*G)) ls = [ l | (l,r) <- enumerate (F*G) ]
12:43:00 <augur> and Rho is the right version of that
12:44:34 <augur> so that powerset proper is just Lam (E*E)
12:47:12 <augur> or we could name them Fst and Snd :p
12:47:24 <augur> that was a CT mindset i guess
12:48:29 <tomberek> how is ST monad different than MonadState?  I read that it is a strict version.  Is this similar to foldl and foldl' where folding lazily would build up big thunks.  ie: threading state though lots of functions would build up big thuniks?
12:48:34 <taktoa> let's say I have two variables of type [[a]]
12:48:51 <taktoa> what function could I use to horizontally concatenate them?
12:48:57 <ivanm> tomberek: ST has a session variable (the `s' type) which makes sure you don't mix values from two different ST "sessions"
12:49:12 <ivanm> so it's usually used for memory access, etc.
12:49:21 <taktoa> so that, say, the first list of the first variable is concatenated to the first list of the second
12:49:27 <taktoa> and so on and so forth
12:49:29 <ivanm> note that you can't set the `s' value/type
12:49:44 <ivanm> taktoa: map concat . transpose?
12:49:53 <taktoa> I'll try that
12:50:08 <tomberek> ivanm: hello... yeah, i got that part, but what's the motivation for 'strict'?
12:50:36 <ivanm> where's that?
12:50:52 <ivanm> and by "MonadState", do you mean the State monad?
12:51:06 <dmbarbour> Hello. I recently ran a few tests to figure out the precision of threadDelay. For ghci, tests averaged 90 usec different than the request. For ghc, tests averaged 30 milliseconds different than the request. Does anyone have an idea why I'm seeing 3 orders of magnitude difference?
12:51:24 <ivanm> because ghci is interpreted and slower than compiled code?
12:51:28 <tomberek> ivanm: yes (sorry, i was in MTL earlier)
12:51:42 <ivanm> I don't think it's a matter of strictness
12:51:52 <ivanm> (disclaimer: I've never used ST)
12:51:57 <monochrom> perhaps ghci is more interruptible
12:52:08 <ivanm> monochrom: that too probably
12:52:16 <ivanm> @hoogle (Maybe a,b) -> Maybe (a,b)
12:52:16 <lambdabot> No results found
12:52:18 <dmbarbour> more interruptible?
12:52:27 <monochrom> unoptimized code is more interruptible than optimized code
12:52:37 <ivanm> dmbarbour: other things use the CPU whilst ghci is running
12:52:48 <ivanm> also, ghci isn't threaded IIRC...
12:52:53 <tomberek> ivanm: ST and State look like they have similar motivations, and I think the lazy/strict difference is the same idea as foldl and foldl' , i'm just not sure
12:52:53 <dmbarbour> I tried with and without optimizations on the ghc version.
12:52:54 <sm> why does cabal install Chart want to install gtk ? I can't see that dependency (only cairo). cabal install --dry-run -v doesn't seem to tell me
12:52:55 <eigen> Looking here I don't see anything labeled the "haskell platform" http://www.archlinux.org/packages/?sort=&arch=&repo=&q=haskell&maintainer=&last_update=&flagged=&limit=50
12:52:59 <dmbarbour> And this was single-threaded test.
12:53:30 <dmbarbour> (optimizations made no difference to the test.)
12:53:38 <monochrom> ghc rts switches context only at certain points. these points tend to disappear in compiled code.
12:53:51 <ivanm> tomberek: they are similar, except ST forces a per-session "state"
12:54:01 <mreh> has anyone created a haskell golf course? I'd like to practice my stroke
12:54:09 <ivanm> eigen: .... so?
12:54:17 <ivanm> are you saying you want a haskell platform pkgbuild?
12:54:44 <ivanm> eigen: http://aur.archlinux.org/packages.php?ID=26279
12:55:21 <eigen> So, it wasn't in that list because it's on AUR?
12:55:31 * ivanm doesn't use arch and thus has no idea
12:57:41 <tomberek> ivanm: ....... i guess i'm still confused about when you would use one over the other?
12:57:56 <HairyDude> http://hpaste.org/41830/cabal_install_lambdabot_failed
12:58:05 <dmbarbour> monochrom: again, there is only a single running thread. Is there a way to compile ghc to support higher resolution in the code?
12:58:15 <monochrom> I don't know.
12:58:18 <ivanm> tomberek: when you're doing memory pinning, etc. use ST
12:58:58 <tomberek> ivanm: uh....... huh?
12:59:33 <ivanm> tomberek: OK, think about Vector, Bytestring, etc.: they do explicit memory manipulation
12:59:41 <ivanm> (though I think Bytestring does it in IO rather than ST)
13:00:03 <tomberek> yeah, to encapsulate destructive algorithms inside of pure ones
13:00:30 * sm forms a theory: Chart doesn't depend on gtk, but depends on some different version of a lib that cairo also uses (eg mtl), so wants to rebuild cairo with that lib version, and also things depending on the installed cairo (gtk)
13:00:56 <ivanm> tomberek: but when you're doing that memory manipulation, you don't want to mix up different invocations, etc.
13:01:06 <quicksilver> ivanm: how can you use ST to do memory pinning?
13:01:19 <tomberek> ivanm: ah, i understand now, State can only make threading of state through functions easier, ST actually uses memory manipulation?
13:01:20 <ivanm> quicksilver: oh, I thought it could; have I misinterpreted something someone said again? :s
13:01:31 <ivanm> tomberek: sounds like not :/
13:01:36 <HairyDude> anyone got the cabal version of lambdabot to compile lately? it seems to be missing a build-depends
13:01:43 <tomberek> dang
13:01:47 <quicksilver> well the only memory manipulation ST gives you is STUArray
13:01:50 <ivanm> HairyDude: yeah, lambdabot is known to be difficult to build
13:01:53 <quicksilver> unboxed mutable arrays
13:02:00 <quicksilver> (but for what it's worth, they're not pinned)
13:02:22 <McManiaC> http://npaste.de/r8/ fun with monad comprehensions! :)
13:02:30 <quicksilver> the real hairy memory stuff is all in IO (Ptr, ForeignPtr, ByteArray#, etc...)
13:03:09 <McManiaC> output: http://npaste.de/r9/
13:03:43 <HairyDude> that's weird, unix is in fact in lambdabot's build-depends
13:04:31 <tomberek> ivanm: then what's the right way to look at the difference?
13:06:05 <ivanm> tomberek: ask quicksilver ;-)
13:06:17 <tomberek> roger
13:06:38 <quicksilver> the difference between which? State and ST or State and IO?
13:06:44 <tomberek> State and ST
13:06:58 <quicksilver> in State you have to declare the type of state you want.
13:07:03 <quicksilver> It can be a great big type.
13:07:05 <quicksilver> as complex as you like
13:07:08 <quicksilver> but you have to define it.
13:07:23 <quicksilver> In ST you have this amazing extendable state that you can ask for new bits of whenever you want (newSTRef)
13:07:37 <quicksilver> and you can call newSTRef at *any* type, to get a new bit of that type.
13:08:15 <quicksilver> additionally, ST supports efficient arrays of data. But that's more-or-less just a cute benefit. (You could be using a list of data - it's just arrays are more efficient)
13:10:28 * HairyDude realises all he needs is pointfree and not the full lambdabot
13:10:39 <tomberek> quicksilver: i'm not quite understanding "great big type as complex as you like"  /  "any type"
13:11:56 <ivanm> tomberek: you can suddenly switch from having something like "ST Int a" to "ST String a"
13:12:04 <ivanm> with State, you have the same state type throughout
13:12:14 <tomberek> ah, i see
13:12:29 <quicksilver> tomberek: well, with State you can say "data MyCleverState = { this :: Int, that :: String, other :: Map String String }
13:12:49 <quicksilver> tomberek: so you can be arbitrarily complex in your design of data type
13:13:22 <quicksilver> but, in ST, you ca just ask for a new piece of state
13:13:25 <quicksilver> at any time
13:13:40 <quicksilver> of any type you choose at theat moment
13:15:25 <tomberek> quicksilver, can you have MyCleverState in ST?
13:16:04 <quicksilver> sure
13:16:10 <quicksilver> you can have as many of it as you like
13:16:18 <quicksilver> newSTRef can give you any kind of state.
13:16:52 <tomberek> so can State?
13:18:03 <quicksilver> State just has one single state vlue
13:18:05 <applicative> HairyDude, you can use pointfree in ghci if you supplement the ghci configuration file with something like  :def pf \str -> return $ ":! pointfree \"" ++ str ++ "\""
13:18:17 <quicksilver> (although, as discussed, it can be a complex value)
13:20:37 <tomberek> quicksilver: thanks for trying to explain, but this isn't working, .    how about a new angle, when would you use one instead of the other
13:21:47 <crutcher> is there really no way to uninstall a package with cabal?
13:22:07 <Nibble> crutcher: ghc-pkg unregister, then manually delete the files
13:22:32 <quicksilver> tomberek: I would use State when I can decide up front what my state type looks like, and a happy to just use that.
13:22:50 <applicative> crutcher, why do you want to uninstall it?
13:23:09 <quicksilver> tomberek: I would use ST when I had an algorithm which necessarily needed to create new variables of surprising types halfway through (this is actually a very unusual thing)
13:23:30 <quicksilver> tomberek: ...or when I wanted efficient mutablee array updates.
13:23:38 <quicksilver> the mutable arrays are the more convincing reason, most of the time.
13:23:42 <crutcher> does it matter? what package installing system doesn't support remove?
13:23:54 <Raca> @faq Can you teach Haskell to Jesus?
13:23:54 <lambdabot> The answer is: Yes! Haskell can do that.
13:24:58 <monochrom> cabal doesn't support remove. but you already know.
13:25:08 <tomberek> quicksilver: what if you knew you needed to update the state many many times, is that more efficient in ST than State?
13:25:51 <crutcher> specifically, I'm having conflict between monads-fd and mtl; which may or may not be solvable by removing monads-fd
13:25:54 <applicative> its really ghc-pkg that doesnt support remove, isn't that the main thing?
13:25:56 <tomberek> because in State you'd have to copy it each time?
13:26:01 <quicksilver> tomberek: no.
13:26:14 <monochrom> ghc-pkg unregister sufficies
13:26:23 <applicative> crutcher, for this you can use the simpler expedient of hiding the enemy
13:26:33 <revenantphx> yo bitch
13:26:38 <revenantphx> er... wrong channel
13:26:40 <applicative> ghc-pkg hide mtl  ...
13:26:45 <roconnor> Who gave the state-in-context comonad it's name?  Was it Kieburtz?  It seems like a very misleading name.
13:26:52 <roconnor> *its
13:26:57 <tomberek> wow, either I'm having a really bad day or something is stuck in my mind that is way off
13:27:51 <quicksilver> tomberek: in you have an STRef like, x :: STRef (MyHugeState)
13:27:57 <monochrom> IMO cabal does too much and therefore people have even higher expectations
13:28:10 <quicksilver> tomberek: then when you update it, the only thing that is actually "mutable" is the *pointer* 
13:28:18 <mauke> who has ops in #haskell-blah?
13:28:37 <quicksilver> the value stored inside is just as immutable as any other haskell value
13:28:59 <mauke> marienz: oh hey, can you do something about racist spam in #haskell-blah?
13:29:08 <monochrom> I use MVar (Data.Map X Y) for example
13:29:11 <quicksilver> and when you change it it will be partly copied and partly shared, just as it would be iin the State case
13:29:26 <quicksilver> mauke: not I, unforuntately. sorry.
13:29:29 <mauke> idoru++
13:29:31 <applicative> crutcher, there are more sophisticated things, but a few trials of "ghc-pkg expose foo" "ghc-pkg hide bar" can get one past these things.
13:29:54 <quicksilver> mauke: I suggested that all #haskell ops should be -blah ops, but others did not agree.
13:30:22 <applicative> crutcher, there is also {-# LANGUAGE PackageImports #-} which you can use to insist on, e.g. mtl or whatever
13:31:00 <quicksilver> tomberek: so, the only place where you get a real win of non-copying mutable is the unboxed STArrays STUArray.
13:31:30 * applicative has ever higher expectations for cabal install.
13:31:38 <monochrom> MVar (Data.Map X Y) is very satisfying. the critical section of (swap one pointer for another) is as fast as you can get. and every thread sees a consistent snapshot. fast safe user-friendly, you no longer have to pick two.
13:31:53 <tomberek> quicksilver: so that would be the only reason to use ST in most cases?
13:32:32 <quicksilver> tomberek: I think so, yes.
13:33:11 <tomberek> quicksilver: ok, until more understanding creeps through my skull, that'll have to do,,,, thanks for being persistent
13:34:24 <esdee> is there a way to iterate over the types of a variant type?  Like for "data Sometype = A | B | C" do something for A, B and C?
13:34:43 <monochrom> data Sometype = A | B | C deriving Enum
13:34:56 <monochrom> now you can write [A..C] for [A,B,C]
13:35:11 <esdee> perfect
13:35:41 <monochrom> > (+) <$> [1] <*> [2]
13:35:42 <lambdabot>   [3]
13:35:48 <monochrom> > (+) <$> [1] <*> [2] <*> [3]
13:35:48 <lambdabot>   [3]
13:35:58 <monochrom> > (+) <$> [1] <*> [2] <*> [3] <*> [4]
13:35:59 <mauke> deriving (Bounded, Enum, Eq, Ord, Show, Read)
13:35:59 <lambdabot>   [3]
13:36:07 <mauke> [minBound .. maxBound], yo
13:37:12 <monochrom> > (&&) <$> [True] <*> [False]
13:37:13 <lambdabot>   [False]
13:37:18 <monochrom> > (&&) <$> [True] <*> [False] <*> [True]
13:37:19 <lambdabot>   Couldn't match expected type `a -> b'
13:37:19 <lambdabot>         against inferred type `GHC.Bo...
13:39:06 <Aune> join /haskell-blah
13:39:08 <Cin> Peaker: Did you get anywhere with that subtext-kinda AST-editor-kinda project?
13:45:03 <applicative> > > 6 <$> 5 <$> (+) <$> [1] <*> [2] <*> [3] <*> [4]
13:45:04 <lambdabot>   <no location info>: parse error on input `>'
13:45:09 <applicative> > 6 <$> 5 <$> (+) <$> [1] <*> [2] <*> [3] <*> [4]
13:45:10 <lambdabot>   [6]
13:45:50 <applicative> monochrom, this is so wrong :)
13:46:29 <monochrom> some Num instance for function is interfering.
13:46:40 <applicative> > 1 1
13:46:41 <lambdabot>   Ambiguous type variable `t' in the constraint:
13:46:41 <lambdabot>    `GHC.Num.Num t' arising f...
13:47:11 <applicative> > map 1 [1]
13:47:12 <lambdabot>   [1]
13:48:06 <taktoa> how can I convert an int into it's character representation?
13:48:13 <JoeyA> > show 123
13:48:14 <lambdabot>   "123"
13:48:38 <taktoa> so 65 goes to "A"
13:48:42 <taktoa> not like that...
13:48:45 <applicative> > ord 'a'
13:48:45 <mauke> > chr 65
13:48:46 <lambdabot>   'A'
13:48:46 <lambdabot>   97
13:49:06 <mauke> > "\65"
13:49:06 <applicative> @type (chr,ord)
13:49:06 <lambdabot>   "A"
13:49:07 <lambdabot> (Int -> Char, Char -> Int)
13:49:35 <taktoa> ok, thanks
13:49:37 <applicative> @type map ord
13:49:37 <lambdabot> [Char] -> [Int]
13:49:46 <applicative> @type map chr
13:49:47 <lambdabot> [Int] -> [Char]
13:50:31 <applicative> taktoa, they're in Data.Char 
13:50:49 <mauke> > let f x = read "'\\" ++ show x ++ "'" :: Char in f 65
13:50:50 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
13:50:50 <lambdabot>         against inferred type...
13:51:02 <mauke> > let f x = read ("'\\" ++ show x ++ "'") :: Char in f 65
13:51:03 <lambdabot>   'A'
13:51:10 <taktoa> thanks
13:51:18 <wvl> Hi everyone. I'm new to Haskell so I was wondering if all of you are using cabal-install for your packages or if you're downloading them from source?
13:51:36 <monochrom> @pl \c -> cust c >> return c
13:51:36 <lambdabot> liftM2 (>>) cust return
13:51:40 <monochrom> eww
13:51:45 <applicative> wvl, I use cabal install even to manage my finances 
13:51:54 <applicative> wvl, just to annoy monochrom!
13:51:58 <mauke> wvl: I use cabal-install to download the sources
13:52:10 <Raca> *
13:52:25 <monochrom> cabal-install downloads source. false dichotomy.
13:52:53 <wvl> my install from yi didn't really seem to work and I didn't really get the preference versus constraint options
13:53:05 <applicative> wvl, actually i usually do the same, first "cabal unpack pandoc" then cd pandoc-7.8.9 then cabal install
13:53:40 <applicative> cabal install figures out what source to download
13:54:01 <monochrom> I don't know preference vs constraint either. But I try both.
13:56:14 <wvl> do you have to reinstall all the packages if you upgrade ghc versions? since they are installed in .cabal/lib/package/ghc-x.x.x?
13:56:23 <mauke> yes
13:56:47 <roconnor> CoState is almost as terrible as the name state-in-context
13:57:11 <wvl> ok well thanks everyone I'll try to install yi again then. :)
14:01:01 <Peaker> Cin, Well, not sure when we talked, I got to a structural revision control system with a purely functional widget set based editor (undo buffer and revision control are same).. But I had to suspend it to complete a project at my workplace so I can leave to work on it full-time
14:01:52 <monochrom> binaries compiled by ghc are extremely sensitive to versions and minor changes
14:03:36 * sm also uses cabal install to manage his finances
14:06:17 <monochrom> @type ap
14:06:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:07:26 <monochrom> I think s/Cin/Cale/
14:14:11 <bos> does anyone know how to distinguish between ghc 7.0.1 and 7.0.2 using CPP macros?
14:14:32 <bos> according to both 7.0.1 and the current tip of the 7.0.2 tree, __GLASGOW_HASKELL__ is 700
14:15:44 <enthropy> sounds like they need to bump that number then
14:19:28 <applicative> all the references to __GLASGOW_HASKELL__ on hackage seem to be like #if __GLASGOW_HASKELL__ >= 609 #if __GLASGOW_HASKELL__ < 610 etc
14:20:13 <applicative> so they did 'bump the number' in their sense
14:22:08 <Cin> Peaker: Righto. Did you base the structural version control system off of Git or some existing system; I imagine it could be done merely as a layer ontop which interprets the changes semantically, or perhaps that doesn't make sense. Your widget based editor sounds interesting, is it uploaded somewhere?
14:24:17 <Peaker> Cin, no, it is textual, I need structural..
14:24:55 <Peaker> Cin, Adding a textual->structural layer on top of git would probably not be worth the hassle, I don't think implementing what git already does (at least naively) should be very difficult, I think git's main contribution is the idea/model :)
14:25:49 <Peaker> Cin, I discovered that if I work on that project, though, I cannot work on challenging projects at my workplace (if they're not the "top idea in my mind") so that's why I'm suspending it (I hope to finish the current project finally and leave :-)
14:26:53 <Cin> Peaker: Okay. I will wait. I find your ideas very interesting and I would like to subscribe to your newsletter.
14:31:50 <Mitar> Cin, Peaker: which project are you talking about?
14:31:54 <Mitar> (I just popped in)
14:33:34 <quicksilver> Mitar: peaker has a vision of an editor which works on the structure of the code (like its AST) rather than its textual form
14:34:16 <Mitar> i would like that generlized to to free text also ;-)
14:42:03 <monochrom> @pl \a b c d -> f b c d a
14:42:04 <lambdabot> flip (flip . (flip .) . f)
14:42:07 <monochrom> heh
14:45:11 <esdee> I assume there is a nicer way to get all the non-empty lists in a list of lists?  Instead of "filter (\x -> not (null x)) list_of_lists"
14:45:28 <Zao> filter (not . null)
14:45:54 <Zao> @pl \x -> not (null x)
14:45:55 <lambdabot> not . null
14:45:59 <Zao> ^ tada :D
14:46:21 <Taslem> How do you use unlimited size integers?
14:46:27 <Zao> Taslem: Trivially.
14:46:31 <Zao> (Integer is unbounded)
14:46:39 <ksandstr> by declaring something as having an Integer type somewhere
14:46:46 <Taslem> I'm trying to divide one by 30, and it yeields infinity.
14:46:54 <mauke> unlikely
14:46:58 <Mitar> > 1 / 30
14:47:00 <mauke> infinity is not an integer
14:47:00 <lambdabot>   3.333333333333333e-2
14:47:07 <Taslem> That's what's weird.
14:47:10 <Zao> @type 9001 ^ 9001
14:47:11 <lambdabot> forall t. (Num t) => t
14:47:16 <mauke> you're just confused
14:47:26 <Zao> Taslem: Note that / is not integral division.
14:47:37 <Taslem> I guess that's the issue.
14:47:38 <Mitar> > 1 `div` 30
14:47:39 <lambdabot>   0
14:47:40 <Zao> Integral division is 'div' or 'quot', and integers are whole numbers.
14:47:55 <Zao> @type (/)
14:47:56 <lambdabot> forall a. (Fractional a) => a -> a -> a
14:50:32 <Taslem> Is there a Sort function?
14:50:37 <Taslem> To sort Ords?
14:50:48 <monochrom> @type sortBy
14:50:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
14:50:55 <monochrom> @type sort
14:50:56 <lambdabot> forall a. (Ord a) => [a] -> [a]
14:51:02 <monochrom> try "sort"
14:51:05 <Taslem> sort [1,3,5,3]
14:51:13 <monochrom> [1,3,3,5]
14:51:20 <Taslem> Not in scope.
14:51:30 <monochrom> it's in Data.List
14:51:57 <alexi> is there a channel to deal with cabal issues? i just upgraded to 6.12.3 but my cabal is dated and won't update itself
14:52:25 <Saizan> there's #hackage
14:52:59 <monochrom> so you mean "cabal install cabal-install" fails?
14:53:16 <Saizan> anyhow, iiuc you need to download the tarball from hackage and run the bootstraph.sh script inside it
14:54:23 <alexi> monochrom: yes, it says you will need to install the 'cabal-install' package version 0.8 or higher
14:54:41 <alexi> which i can't find on ubuntu package system
14:55:01 <alexi> so im searching to install it manually
14:55:18 <Saizan> @hackage cabal-install
14:55:19 <lambdabot> http://hackage.haskell.org/package/cabal-install
14:55:32 <alexi> but now it is included in the ghc platform 
14:56:34 <alexi> Saizan: cool thanks. this is what i was after
14:57:13 <Mitar> uh, cabal-install has quite a list of dependencies ;-)
14:57:32 <Mitar> not really easy to bootstrap it manually
14:57:34 <Saizan> see the or
14:57:35 <Taslem> How would I find half of a number?
14:57:46 <Taslem> That's too large to do normal calculation on.
14:58:08 <Mitar> shift one bit to the right?
14:58:18 <Saizan> most of those come with ghc, only ~4 do not, also there's bootstrap.sh
14:58:28 <Taslem> Okay, how would I calculate its bit-code?
14:58:54 <Mitar> by hand?
14:59:05 <Mitar> its bit-code is already in the computer ;-)
14:59:17 <Mitar> true, bootstrap.sh helps
14:59:20 <Saizan> depends on how its represented
14:59:28 <Saizan> *it is
14:59:34 <Taslem> Um... It's very large.  And I'm not used to dealing with bytes and bits and whatnot.
14:59:44 <Mitar> what is really large for you?
14:59:54 <Mitar> and can be represented in your computer?
14:59:55 <Taslem> 362526617024763385466364072451713151314127883938363248919917793200926079747786368525410485973386478458541196888176771215351821639418591324527545964385491374867367735861383783825819622224459585501203778870240031265863510091066417721535484805129849776296463493752695689894874194965322605747558317167965589792236090639792503710021878291670780888
15:00:08 <Mitar> > 362526617024763385466364072451713151314127883938363248919917793200926079747786368525410485973386478458541196888176771215351821639418591324527545964385491374867367735861383783825819622224459585501203778870240031265863510091066417721535484805129849776296463493752695689894874194965322605747558317167965589792236090639792503710021878291670780888 `div` 2
15:00:09 <lambdabot>   181263308512381692733182036225856575657063941969181624459958896600463039873...
15:00:14 <Mitar> here you have ;-)
15:00:29 <Taslem> Thansk!
15:00:32 <Mitar> np ;-)
15:01:38 <sorear> Who controls the lambdabot autojoin file these days?
15:02:34 <alexi> Mitar: was pretty fast installing them :)
15:02:50 <Mitar> true, i missed OR there ;-)
15:11:05 <Saizan> sorear: Cale
15:11:11 <sorear> thanks
15:20:10 <McManiaC> fun with monad comprehensions: http://blog.n-sch.de/2010/11/27/fun-with-monad-comprehensions/
15:23:09 <cvertino> whats the logic behind [[],[]] > [] (it's true)
15:23:30 <cvertino> its a bigger size so its greater? its sort of confusing using > on empty sets
15:23:55 <monochrom> > "abc" > ""
15:23:56 <lambdabot>   True
15:24:24 <monochrom> let's start from what you would agree with
15:24:27 <monochrom> > "abc" > "ab"
15:24:28 <lambdabot>   True
15:24:36 <cvertino> yes. ok
15:24:45 <monochrom> now progress towards its logical conclusion
15:24:47 <monochrom> > "abc" > "a"
15:24:48 <lambdabot>   True
15:24:48 <McManiaC> > "0.1" > "1"
15:24:49 <lambdabot>   False
15:24:50 <monochrom> > "abc" > ""
15:24:51 <Ke> [1] > [2]
15:24:51 <lambdabot>   True
15:24:55 <McManiaC> woot?
15:24:58 <Ke> > [1] > [2]
15:24:59 <cvertino> hmm ok
15:24:59 <lambdabot>   False
15:25:03 <monochrom> It is just taking limits
15:25:20 <McManiaC> :t "0.1" > "1"
15:25:22 <lambdabot> Bool
15:25:26 <McManiaC> > "0.1" > "1"
15:25:27 <erlnoob> > [0,0] > [0]
15:25:28 <lambdabot>   True
15:25:28 <lambdabot>   False
15:25:44 <McManiaC> huh
15:25:48 <McManiaC> :O
15:25:57 <djahandarie> > [[],[]] > [[]]
15:25:57 <lambdabot>   True
15:26:07 <djahandarie> > [0,0] > [0]
15:26:08 <lambdabot>   True
15:26:17 <cvertino> so nothing can be less than [], right?
15:26:36 <Cin> > [] > []
15:26:36 <monochrom> yes
15:26:37 <lambdabot>   False
15:26:54 <djahandarie> > undefined > []
15:26:55 <lambdabot>   *Exception: Prelude.undefined
15:27:04 <Cin> > [] > undefined
15:27:06 <lambdabot>   *Exception: Prelude.undefined
15:27:51 <Cin> Clearly not defined in terms of pattern matching.
15:28:24 <Cin> > let (>>) = (>) `on` length in [] >> undefined
15:28:26 <lambdabot>   *Exception: Prelude.undefined
15:29:15 <Cin> > let [] >> a = False; a >> b = length a > length b in [] >> undefined
15:29:17 <lambdabot>   False
15:29:56 <Cin> I didn't need to demonstrate that. That's just how I roll.
15:40:15 * hackagebot suffixarray 0.0.2 - Suffix arrays  http://hackage.haskell.org/package/suffixarray-0.0.2 (DanielDeKok)
16:07:40 <jdavis_> When using Happy, I get warnings about overlapping patterns. It appears to be using a "_" as a catch-all in a case statement, even when the case statement exhausts all possibilities.
16:08:19 <jdavis_> Is that a bug in Happy, or should I write my grammar differently, or should I just compile all Happy-generated .hs files with -fno-warn-overlapping-patterns
16:08:21 <jdavis_> ?
16:09:08 <byorgey> jdavis_: definitely a (harmless) bug in Happy.
16:09:14 <byorgey> your grammer would not affect that at all
16:09:39 <byorgey> ...neither wuld your speling
16:09:53 <jdavis_> byorgey: ok. Should I report it, or is it known? 
16:10:03 <byorgey> I've no idea.
16:10:41 <byorgey> try emailing the maintainer.
16:11:35 <jdavis_> byorgey: (did I make some atrocious spelling mistake somewhere? I missed your point about spelling. )
16:11:57 <byorgey> jdavis_: no, *I* did. =)
16:11:59 <Cale> jdavis_: He was making fun of his own spelling
16:12:31 <jdavis_> byorgey: oh, hah :)
16:12:57 <jeffwheeler> I'm confused on a cabal parsec dependency thing. I've got network, built with parsec 2, installed globally. When I try to build a package that depends (indirectly) on that and parsec 3, it always recompiles network with parsec 3.
16:13:35 <jeffwheeler> It seems that if I install network with parsec 3 as user, then it doesn't see that. It sees a matching network globally, but it's built wrong, so it rebuilds it.
16:14:11 <byorgey> well, if you have two copies of the same version of network installed, I'm not sure how it decides which one to use.
16:14:14 <Cale> jeffwheeler: Are you building a user or global package?
16:14:17 <jeffwheeler> user
16:14:28 <byorgey> it may not be smart enough to notice that one of them is built with the right dependency and one isn't
16:14:54 <jeffwheeler> Is it okay to replace the global one with one built with parsec? I installed the global one with apt.
16:15:26 <jeffwheeler> I expect it'll put the files in the same place as the apt version, so replacing the files will be harmless.
16:15:30 <byorgey> it should be OK, although you will have to recompile anything which was built using it
16:15:47 <byorgey> but ghc-pkg will tell you which packages are broken after installing the new version
16:16:06 <McManiaC> http://npaste.de/rD/ :D
16:16:07 <jeffwheeler> alright, giving it a shot; thanks
16:16:15 * McManiaC loves RebindableSyntax
16:16:21 <byorgey> AFAIU parsec 3 will be included in the next HP release, so hopefully this will not be a problem too much longer =)
16:16:28 <Cale> I try not to touch my global package database.
16:16:45 <Cale> (though I don't use apt to install ghc)
16:16:58 <byorgey> me too.  But in this case I think it's probably the right way to go.
16:17:18 <jeffwheeler> Is there a good reason not to use apt? It seems to work well for installing the base stuff.
16:18:48 <byorgey> woah, I didn't know you could rebind if then else =)
16:19:19 <McManiaC> :)
16:19:27 <McManiaC> it's pretty new i think
16:20:31 <Cale> Well, at least with Ubuntu, the packages are almost perpetually out of date (though they haven't been so bad in the last little while, ghc 7 just came out...)
16:21:17 <Cale> I usually just grab the generic linux binary GHC package, and install that, and then grab cabal-install.
16:22:11 <FunctorSalad_> McManiaC: hmm :p http://npaste.de/rE/
16:22:43 <McManiaC> FunctorSalad_: haha
16:22:50 <FunctorSalad_> (yes, my main is not IO, but that's not the error ;))
16:23:01 <McManiaC> nice
16:23:12 <McManiaC> yeah
16:23:41 <thoughtpolice> McManiaC: in your monad comprehensions patch and blog post you mention RebindableSyntax also rebinds guard, is that an extension added by your patch?
16:24:10 <McManiaC> thoughtpolice: which one?
16:24:20 <thoughtpolice> http://blog.n-sch.de/2010/11/27/fun-with-monad-comprehensions/
16:24:36 <thoughtpolice> "For our example I want to overload the guard function with my own version of guard, so I make use of another extension here, RebindableSyntax"
16:24:47 <McManiaC> oh
16:25:03 <McManiaC> no, that's not directly related to that extension, but if you read on I'll make use of it :)
16:25:16 <thoughtpolice> right now RebindableSyntax only does if then else doesn't it?
16:25:26 <McManiaC> it does all kind of stuff
16:25:34 <McManiaC> you can rebind (>>) in do-blocks etc
16:25:37 <thoughtpolice> i should check the docs i suppose
16:26:04 <jeffwheeler> That seems like it'd only be useful for obfuscation.
16:26:21 <McManiaC> yeah...
16:26:26 <jdavis_> Should I try to use packages that are provided by ubuntu, or should I get all packages from cabal instead? For instance, something like Happy is old in ubuntu, but a fresher version is available from cabal.
16:26:30 <Cale> What does?
16:26:31 <McManiaC> but thats what you have monad instances for actually ;)
16:26:39 <Cale> Rebindable if/then/else?
16:26:47 <FunctorSalad_> jeffwheeler: use for restricted or indexed monads seems fair enough (rebinding (>>))
16:28:28 * hackagebot yesod-markdown 0.0 - Markdown processing for Yesod sites using Pandoc  http://hackage.haskell.org/package/yesod-markdown-0.0 (AlexanderDunlap)
16:28:32 <FunctorSalad_> (http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Monad-Indexed.html :))
16:29:13 <jeffwheeler> FunctorSalad_, what would the replacement >> do?
16:29:23 <thoughtpolice> McManiaC: seems like it implies NoImplicitPrelude + rebindable if-then-else
16:29:44 <FunctorSalad_> jeffwheeler: the (>>) of the modified monad class
16:30:08 <FunctorSalad_> (defined in the same way from return and bind of that modified monad class)
16:30:13 <McManiaC> thoughtpolice: I think the NoImplicitPrelude got removed again
16:30:24 <McManiaC> at least with my build I dont have to manually load Prelude
16:31:11 <FunctorSalad_> (or from just 'bind' actually... a >> b = a >>= const b)
16:32:14 <thoughtpolice> McManiaC: but yeah! I like it, it's nice that you can lift those monadic actions into if, it would clean up a lot of my code :)
16:32:39 <McManiaC> yeah
16:33:07 <McManiaC> actually I think those two instances should be part of the extension, but yeeeaah
16:33:11 <McManiaC> :>
16:33:29 <McManiaC> or maybe a separate extension which doesn't require RebindableSyntax
16:34:46 <FunctorSalad_> NoImplicitPrelude doesn't rebind syntax anymore, iirc
16:34:54 <McManiaC> yeah
16:34:56 <FunctorSalad_> (does that make it any different from import Prelude()?)
16:35:52 <McManiaC> FunctorSalad_: instances maybe
16:36:06 <FunctorSalad_> ah makes sense
16:36:43 <McManiaC> and I like the new "import Control.Monad.Instances.Some.Very.Long.Module as M" thingy
16:36:47 <McManiaC> :)
16:37:15 <McManiaC> nice mix between qualified ans usual import
16:37:23 <McManiaC> *and
16:37:40 <eigen> I'm trying to think of how you would build a physics engine in haskell. A traditional physics engine works like: You add objects to world, initializing position, mass velocity. You call update with a time step. New positions/properties are set on the objects. You inspect the object's new positions to update the graphics accordingly. Could something like this be done in haskell?
16:37:52 <FunctorSalad_> McManiaC: what's new about that?
16:38:10 <djahandarie> FunctorSalad_, I imagine he is talking about ghci
16:38:16 <eigen> There's seems to be a great deal of state in a physics engine.
16:38:31 <McManiaC> FunctorSalad_: its old? ok, than I missed out on it
16:38:31 <McManiaC> :>
16:38:35 <djahandarie> Or not
16:38:39 <Botje> eigen: the only mutation happens when you evolve the engine
16:38:58 <Botje> so you put all the state in a datastructure and then have evolve :: State -> State
16:39:16 <Botje> maybe with a time delta, if such a thing is wanted
16:40:11 <FunctorSalad_> maybe allocating a new world at every step is too slow... you could have STRefs in your State as an alternative
16:41:25 <jeffwheeler> My dependencies problem seems to be better now. I removed apt's network package (and its dependencies) and reinstalled network globally with --constraint="parsec > 3". I then had to reinstall all my package's dependencies, one at a time, with the same constraint.
16:42:11 <McManiaC> FunctorSalad_: are there any benchmarks who used this?
16:42:16 <McManiaC> *which
16:42:37 <FunctorSalad_> McManiaC: no, pure speculation ;)
16:42:44 <FunctorSalad_> (none that I know of, anyway)
16:43:46 <jeffwheeler> My dependencies problem seems to be better now. I removed apt's network package (and its dependencies) and reinstalled network globally with --constraint="parsec > 3". I then had to reinstall all my package's dependencies, one at a time, with the same constraint.
16:43:49 <jeffwheeler> oops, sorry
16:43:54 <jeffwheeler> (up arrow, enter in the wrong window)
16:44:28 <eigen> Does haskell support traditional object oriented programm?
16:44:57 <ibt> eigen: not directly
16:45:06 <eigen> can you create an object which contains both methods and properties?
16:45:12 <jeffwheeler> eigen: it's not an OO language . . .
16:45:21 <McManiaC> eigen: well, actually you can
16:45:22 <McManiaC> ^^
16:45:24 <eigen> Does that limit what you cann do?
16:45:37 <McManiaC> it's not like in java though :>
16:45:41 <McManiaC> no
16:47:04 <eigen> From working with OO languages, I have a rather OO mindset. I think of solutions to problems in those terms -- am I going to be disappointeed by haskell's limitations in this area?
16:47:40 <McManiaC> its not a limitation :)
16:48:02 <jeffwheeler> eigen: it's not an OO language . . .
16:48:05 <jeffwheeler> ack, sorry again
16:48:06 <eigen> ok.
17:02:19 <Cale> eigen: Functions and IO actions are first class values though, and you can put both in datastructures.
17:03:11 <eigen> nice to learn.
17:11:12 <jdavis_> Dumb question: I'm using Data.Set, what options do I pass to ghc so that it can link against Data.Set? I get some undefined reference errors.
17:11:24 <monochrom> --make
17:12:16 <McManiaC> http://npaste.de/rF/ <- whats wrong with this?
17:12:30 <Cale> eigen: So, if classes are just types whose values (objects) are determined by the implementation of certain operations on them (methods), then that's easy. :)
17:13:19 <jdavis_> monochrom: thanks!
17:13:43 <Cale> McManiaC: runST's type is too fancy to be used with $
17:14:57 <Cale> :t runST
17:14:58 <lambdabot> forall a. (forall s. ST s a) -> a
17:15:04 <Cale> :t \x -> runST $ x
17:15:05 <lambdabot>     Inferred type is less polymorphic than expected
17:15:06 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
17:15:06 <lambdabot>         x :: ST s a (bound at <interactive>:1:1)
17:15:21 <Cale> :t \x -> runST x
17:15:22 <lambdabot>     Inferred type is less polymorphic than expected
17:15:22 <lambdabot>       Quantified type variable `s' is mentioned in the environment:
17:15:22 <lambdabot>         x :: ST s a (bound at <interactive>:1:1)
17:15:28 <McManiaC> Cale: O.o
17:15:30 <McManiaC> why's that
17:15:49 <Cale> Because GHC will never instantiate a type variable to a polytype
17:15:58 <Cale> :t ($)
17:16:00 <lambdabot> forall a b. (a -> b) -> a -> b
17:16:23 <McManiaC> so with paranthesis it should work?
17:16:24 <Cale> It would have to instantiate 'a' in that type signature with  (forall s. ST s t)
17:16:26 <Cale> yeah
17:16:31 <Cale> Well, try that :)
17:17:15 <Cale> mm, it's still apparently problematic
17:17:46 <kafee> qtHaskell: why does it do nothing? http://hpaste.org/41839/qthaskell
17:17:52 <McManiaC> hmmm nope doesnt work :(
17:19:45 <Cale> oh
17:19:45 * hackagebot yesod-markdown 0.1 - Markdown processing for Yesod sites using Pandoc  http://hackage.haskell.org/package/yesod-markdown-0.1 (AlexanderDunlap)
17:19:54 <Cale> heh
17:21:02 <Cale> aha
17:21:30 <Cale> that's really quite a contortion :) Put parens around the right parameter to +=
17:21:34 <cvertino> hoohoo
17:21:42 * cvertino guffaws
17:22:17 <Cale> Or,  infixl 0 +=
17:22:31 <Cale> (probably want the same for .=)
17:24:13 <Cale> McManiaC: It was seeing that as being that you wanted to multiply (sum += (a !! i !! j)) * xj, which would mean that xj :: ST s (), which would mean that the elements of x are all ST actions, and you're trying to return a list of them.
17:24:29 <Cale> (nevermind that ST actions aren't an instance of Num)
17:25:45 <Cale> and that's where the 's' was escaping -- the ST action as a whole had type  ST s [ST s ()]
17:26:09 <Cale> (and you're not allowed to return anything with that 's' in its type from runST)
17:27:11 <Cale> Note also that 0 is polymorphic and might stand for an ST action as well, given the right instance :)
17:27:34 <Cale> (it hadn't got as far as the point where it would look for one)
17:27:55 <Cale> McManiaC: Does that help?
17:29:47 <McManiaC> I had to remove .= and +=
17:29:48 <McManiaC> :(
17:30:01 <Cale> Did you see my explanation there?
17:30:02 <McManiaC> and now it compiles but I get an empty list as a result
17:30:07 <McManiaC> yeah
17:33:26 <Cale> McManiaC: There are more strange things with this code... !! is 0-indexed
17:33:39 <McManiaC> yep, fixed that already
17:33:41 <Cale> (also, you just shouldn't use it, but nevermind that)
17:33:55 <McManiaC> I know :>
17:34:19 <McManiaC> I wanna see if I can "copy & paste" this code here to haskell: http://npaste.de/os/
17:35:11 <Cale> I just get a list of 0's from your code, after fixing the indexing problem (and the type problem)
17:35:26 <Cale> Which makes sense, given the (x !! i) .= 0
17:35:36 <McManiaC>     Couldn't match expected type `Double'
17:35:36 <McManiaC>            against inferred type `Double -> Double'
17:35:36 <McManiaC>     In the second argument of `(*)', namely `s'
17:35:36 <McManiaC>     In the second argument of `(-)', namely `1 / (a !! i !! i) * s'
17:35:36 <McManiaC>     In the second argument of `(.=)', namely
17:35:38 <McManiaC>         `(b !! i) / (a !! i !! i) - 1 / (a !! i !! i) * s'
17:35:41 <McManiaC> ups
17:35:46 <McManiaC> meant to sent you the link :>
17:37:11 <McManiaC> wtf
17:37:23 <McManiaC> No instance for (Num (Double -> Double))
17:37:29 <McManiaC>     In the expression:
17:37:30 <McManiaC>         do { sum <- newSTRef 0;
17:38:51 <Cale> what type is s?
17:39:14 <McManiaC> oh
17:39:16 <McManiaC> fixed it
17:39:17 <McManiaC> :)
17:39:24 <McManiaC> but I still dont get a result
17:40:13 <McManiaC> not even with 0's
17:46:24 <McManiaC> hmmm it doesn't soome to like viewpatterns aswell
17:47:00 <McManiaC> ooooooooor I'm too stupid to use subtract :))
17:49:12 <stroan> hmm, would I be right in saying that the haskell syntax can't be lexed by Lex & co. That I'd need a full parser?
17:49:26 <stroan> to tokenize
17:49:42 <McManiaC> GHC is using alex
17:49:46 <McManiaC> which is kind of like lex
17:50:54 <Mitar> is let in do-notation strict?
17:51:08 <stroan> oh, interesting. Will go digging there. It seemed that qualified identifiers required more than Lex could give
17:51:15 <stroan> Mitar: nope
17:51:31 <Mitar> can i force it with bang patterns?
17:51:52 <Cale> http://hpaste.org/41840/seidel
17:52:01 <Cale> McManiaC: ^^
17:52:22 <Mitar> so i would like someting like do { time1 <- getTime ; let a = ... ; time2 <- getTime ; return $ time2 - time1 }
17:54:03 <stroan> I would imagine so
17:54:25 <stroan> haven't done it before
17:54:38 <roconnor> I'm trying to come up with a new name for the state-in-context comonad, which I think is a terrible name.
17:55:15 <roconnor> I'm thinking selector comonad or oxylector comonad or aculector comonad.
17:56:55 * hackagebot dbus-core 0.8.5.3 - Low-level D-Bus protocol implementation  http://hackage.haskell.org/package/dbus-core-0.8.5.3 (JohnMillikin)
17:56:57 * hackagebot dbus-client 0.4.0.3 - Monadic and object-oriented interfaces to DBus  http://hackage.haskell.org/package/dbus-client-0.4.0.3 (JohnMillikin)
17:57:47 <byorgey> roconnor: I have no idea what the second two are supposed to mean.  Although I suppose a name with no connotations is better than one with wrong connotations.
17:58:56 * hackagebot enumerator-fd 0.1.0.1 - Enumerator instances for monads-fd classes  http://hackage.haskell.org/package/enumerator-fd-0.1.0.1 (JohnMillikin)
17:59:04 <McManiaC> Cale: hmhmhm :)
17:59:05 <roconnor> byorgey: lector appears to mean gather.
17:59:20 <djahandarie> roconnor, isn't it just the context comonad?
17:59:26 <roconnor> byorgey: se- means appart
17:59:42 <roconnor> oxy means sharp or pointed
17:59:56 <roconnor> acu also means sharp or pointed
18:00:10 <McManiaC> Cale: that's not the seidel algorithm though
18:00:12 <roconnor> djahandarie: I don't like context because all comonads are about context
18:00:32 <roconnor> and points
18:00:40 <Cale> McManiaC: yes it is
18:00:42 <roconnor> every comonad is a value in some sort of context
18:00:47 <McManiaC> or is it?
18:00:47 <McManiaC> hmmm
18:00:53 <McManiaC> meh I should go to bed
18:00:54 <roconnor> what varies between comonads is what the context is
18:00:55 <McManiaC> :)
18:01:57 * hackagebot ncurses 0.1.0.2 - Modernised bindings to GNU ncurses  http://hackage.haskell.org/package/ncurses-0.1.0.2 (JohnMillikin)
18:03:10 <roconnor> oh I also consider eclector or eclectic
18:03:35 <roconnor> ex- meaning from or out of
18:03:58 * hackagebot network-protocol-xmpp 0.3.2.4 - Client->Server XMPP  http://hackage.haskell.org/package/network-protocol-xmpp-0.3.2.4 (JohnMillikin)
18:04:38 <byorgey> I like eclectic.
18:04:54 <byorgey> "the eclectic comonad"
18:04:59 * hackagebot gnome-keyring 0.2.2.4 - Bindings for libgnome-keyring  http://hackage.haskell.org/package/gnome-keyring-0.2.2.4 (JohnMillikin)
18:05:03 <byorgey> rolls right off the tongue.
18:06:10 <roconnor> byorgey: you are only saying that cause it is a real word :)
18:06:14 <Cale> The pointed function comonad?
18:07:09 * ddarius just calls it the adjoint-transpose-of-the-Reader-monad.
18:07:52 <byorgey> roconnor: perhaps =)
18:07:56 <Cale> Wouldn't that just be the plain pair comonad?
18:09:32 <roconnor> byorgey: I kinda like eclector
18:10:08 <byorgey> roconnor: that one is nice too.
18:12:00 * hackagebot anansi 0.2.1.2 - Simple literate programming preprocessor  http://hackage.haskell.org/package/anansi-0.2.1.2 (JohnMillikin)
18:13:28 * roconnor is reading the wiki page on prefixes
18:25:14 <roconnor> electic
18:35:46 <papermachine> So I'm looking for a GUI framework with a tree widget. Have any of the FRP frameworks gotten that far yet?
18:43:30 <Cale> papermachine: I think you're basically looking at Gtk2Hs
18:45:15 <kmc> GTK's tree control is pretty flexible, but the interface is complicated, and i've found the docs to be outright incorrect sometimes
18:48:12 * hackagebot xss-sanitize 0.2.4 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.2.4 (GregWeber)
18:50:32 <papermachine> Cale, kmc: Thanks for input. I don't think anyone's really written a good tree widget, but well,...
18:50:40 <papermachine> I'll try GTK
19:14:19 * hackagebot husk-scheme 1.0 - R5RS Scheme interpreter program and library.  http://hackage.haskell.org/package/husk-scheme-1.0 (JustinEthier)
19:23:05 <mpiechotka> @pl foldr (\(n, y) x -> p y >>= \b -> if b then return $! Just $! n else x) (return $! Nothing) . zip (map fromIntegral [1..]))
19:23:06 <lambdabot> (line 1, column 123):
19:23:06 <lambdabot> unexpected ")"
19:23:06 <lambdabot> expecting variable, "(", ".", "`", "!!", operator or end of input
19:23:22 <mpiechotka> @pl foldr (\(n, y) x -> p y >>= \b -> if b then return $! Just $! n else x) (return $! Nothing) . zip (map fromIntegral [1..])
19:23:22 <lambdabot> foldr (uncurry (flip ((.) . (>>=) . p) . flip . flip if' . (return $!) . (Just $!))) (return $! Nothing) . zip (map fromIntegral [1..])
19:33:25 <tmo_> Gtk2Hs question: when I compile the following code, it compiles just fine. However, whenever I run the executable, I get "test: <<System.Glib.GError.GError>>" and the program doesn't run.
19:33:30 <tmo_> http://pastebin.com/J6N7XpmK
19:33:42 <tmo_> Does anybody know a possible cause?
19:34:50 <kmc> you can get an error message from a GError: http://hackage.haskell.org/packages/archive/glib/0.12.0/doc/html/System-Glib-GError.html
19:34:53 <kmc> and yo ucan catch GErrors
19:34:59 <kmc> so that will probably help you figure out what's going on
19:36:58 <tmo_> kmc: thanks
19:38:18 <tmo_> Although I found the two sources of runtime errors actually... immediately after I posted it on #haskell :P
19:40:17 <tmo_> I call it the law of maximal embarrassment: the longer you work on an error, the probability of it becoming immediately obvious after you ask somebody becomes 1.
19:41:50 <kmc> yep, i've noticed this
19:42:07 <fiala> Holy, there really are a lot of people here. Oh, and hello.
19:42:11 <kmc> it's a convenient way to solve problems, if you don't mind becoming embarrassed
19:42:14 <kmc> hi fiala :)
19:43:08 <kmc> this is actually kinda small, it gets up to 680+ people
19:43:31 <fiala> Oh.
19:43:34 <fiala> Well.
19:43:40 <fiala> Maybe relatively
19:43:48 <fiala> But not if we're speaking absolutes ;)
19:44:15 <fiala> I don't think I've seen a chatroom with this many people before.
19:44:54 <ddarius> We have one ten-thousandth of a percent of the world population here.
19:45:09 <fiala> Pretty sweet eh?
19:45:52 <ddarius> I remember when it was less than one hundred-thousandth of a percent.
19:46:12 <fiala> Yeah. Must've been different.
19:46:22 <fiala> So is this a place where one can ask non-stupid questions about Haskell?
19:50:36 <kmc> fiala, yes
19:50:40 <kmc> also stupid questions about Haskell
19:50:43 <kmc> both are acceptable
19:52:00 <kmc> ddarius, what percentage of "active Haskell users" do we have? and how does that compare to ##c's percentage of "active C users"?
19:52:11 <ddarius> I've never been in ##c.
19:53:35 <fiala> I'm wondering, are you all using Linux? Lots of this stuff seems like it's targeted at Linux.
19:54:08 <djahandarie> Most use Linux or Mac. There are some Windows users here too
19:54:28 <fiala> I see.
19:54:39 <djahandarie> kmc, active Haskell users? Like people in the channel who actually use Haskell? How would you even measure that?
19:55:06 <djahandarie> fiala, GHC is developed by Microsoft Research though so I imagine they try to maintain some Windows compatibility. ;)
19:55:20 <fiala> Nifty.
19:55:48 <kmc> MSR kinda gets to do their own thing within MS
19:55:58 <djahandarie> Yeah
19:56:08 <kmc> but yes, Windows is a first-tier platform for GHC and Haskell Platform
19:56:17 <djahandarie> Which is why I said developed by "Microsoft Research" rather than "Microsoft" ;)
19:56:28 <kmc> a few things work less well on Windows
19:56:50 <kmc> GHC has a fancy new subsystem for massively concurrent I/O
19:57:05 <kmc> which uses kqueue on BSD and epoll on Linux, but something less sexy on Windows
19:57:06 <djahandarie> There are a lot of packages on hackage with the "unix" dependency unforunately
19:57:15 <kmc> yeah
19:57:18 <fiala> Oh.
19:57:25 <djahandarie> Some people don't care about Windows compatibility too much :(
19:57:27 <kmc> like most languages, Haskell lets you write portable code or platform-specific code
19:57:33 * djahandarie probably included
19:57:55 <fiala> I think most of what I might make someday if I do what I want to do will be ran on Windows.
19:58:12 <kmc> i have no love for Windows but i don't go out of my way to break compatibility
19:58:45 <fiala> It's not that I love or even like Windows in itself but it's got a lot of users.
19:59:10 <kmc> you know what has more users than Windows?
19:59:11 <kmc> the Web
19:59:25 <fiala> Clever. ;-)
19:59:48 * kmc thinks that crystalfontz probably works on Windows even though it talks to USB hardware
20:00:52 <lars9> copumpkin: ha, just see your twitter, when googling haskell stuff
20:07:10 <roconnor> byorgey: I'm torn between electic comonad and elector comonad.  Would you rather your spell checker know how the spell the world, or to be able to easily google the term?
20:09:21 * kmc would guess that any word followed by "comonad" has few irrelevant Google hits, if searched as a phrase
20:19:00 <co_dh> @where tapl
20:19:01 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
20:22:07 <copumpkin> lars9: :O
20:22:58 <tmo_> I feel like I should make a http://www.trans.upenn.edu/~bcpierce/tapl/
20:24:36 <augur> whats the ReverseState monad?
20:25:38 <roconnor> augur: like the state monad except the state changes go backwards
20:26:04 <roconnor> kmc: have a preference :)
20:26:05 <augur> roconnor: example from the treetops?
20:26:22 <roconnor> treetops?
20:27:21 <augur> birds eye view
20:27:31 <augur> nothing detailed, just a feeling of what it means for changes to go backwards
20:29:32 <roconnor> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
20:39:43 <kniu> http://chrisdone.com/posts/2010-11-25-lisk-lisp-haskell.html
20:39:55 <kniu> I was just reading this, and it gave me an idea:
20:40:17 <kniu> are there editors that highlight sections of code based on operator precedence?
20:42:11 <djahandarie> That'd be neat
20:42:37 <kmc> personally i don't use two operators together unless their precedence is totally obvious
20:42:40 <kmc> when in doubt, parenthesize
20:42:49 <kniu> hm
20:42:57 <kniu> kind of defeats the point of operators, I think.
20:43:02 <kmc> basically, i avoid learning the precedence rules
20:43:17 <kmc> except in well-recognized patterns like f.g.h$x
20:43:21 <kmc> and so i wonder if such an editor would cause one to write code which is less readable by others
20:43:53 <kniu> It would only be less readable to those who don't know the precedence rules.
20:44:21 <kmc> it would be less readable to anyone who hasn't deeply internalized the precedence rules
20:44:28 <kmc> even if you know the rules, it takes time to remember and apply them
20:44:56 <kniu> hm.
20:45:13 <kniu> btw, I was imagining something like this, except with operators instead: http://lemonodor.com/images/michaelw-sexpr-highlighting.jpg
20:45:38 <jmcarthur> i like to only assume knowledge of precedence rules for operators with an obvious contrast in visual weight (heavier operators bind less tightly)
20:45:52 <kniu> Is that really a safe assumption to make?
20:46:10 <jmcarthur> that is, when i am writing code with the reader in mind
20:46:24 <jmcarthur> when it happens to be the case then i feel free to leave out parens
20:46:39 <jmcarthur> when it doesn't then i use parens anyway
20:46:57 <jmcarthur> and when i define operators i try to stick with that convention
20:47:23 <kmc> that's really nice kniu
20:47:44 <kmc> though, how does it show the difference between ((x) (y)) and ((x y)) ?
20:48:05 <kniu> I don't know; I've never used it.
20:48:13 <kniu> But in Haskell, there's no difference anyway.
20:48:25 <jmcarthur> the space could be darker?
20:48:29 <jmcarthur> in the former
20:48:52 <jmcarthur> tougher with no space
20:50:03 <kmc> in Haskell there's a difference between ((a b) (c d)) and ((a b c d))
20:50:17 <kmc> :t (?a ?b ?c ?d)
20:50:18 <lambdabot> forall t t1 t2 t3. (?d::t2, ?c::t1, ?b::t, ?a::t -> t1 -> t2 -> t3) => t3
20:50:22 <kmc> :t (?a ?b) (?c ?d)
20:50:23 <lambdabot> forall t t1 t2 t3. (?d::t3, ?c::t3 -> t1, ?b::t, ?a::t -> t1 -> t2) => t2
20:51:33 <kniu> hm
20:52:16 <joyfulgirl>  a
20:52:17 <kniu> It might help readability if parentheses aren't omitted.
20:52:17 <lars9> which xml lib do you recommend?
20:52:47 <kniu> That is, the highlighting is on top of the symbols, and don't replace them.
20:53:20 <kmc> yeah
20:56:14 <jmcarthur> could just have whitespace in place of the parens if you are using color anyway
20:56:51 <sailorreality> does anyone here know modal logic
20:56:51 <jmcarthur> to the point of adding some extra whitespace between )(
20:57:11 <kniu> Actually, I'd prefer that the actual code itself not be shown in any other way than how it was originally written.
20:57:48 <kniu> Adding or subtracting characters violates the principle of least surprise.
20:58:05 <jmcarthur> i wasn't talking about the lisp highlighting
20:58:28 <jmcarthur> i meant that in haskell code you could add some whitespace where parens might otherwise be necessary to get that coloring scheme to work
20:58:37 <jmcarthur> i am being ambiguous... maybe just time for bed
20:59:17 <kniu> I kind of get what you mean, but
20:59:24 <kniu> who does the adding?
20:59:32 <kniu> The editor? Or the programmer?
20:59:42 <kniu> If the editor does it, the programmer might find it annoying.
20:59:54 <kniu> If the programmer does it, that's extra work, which he will find
20:59:56 <kniu> annoying.
21:01:00 <co_dh> does anybody using emacs and flymake haskell in Mac OS X ? 
21:01:00 <lambdabot> co_dh: You have 1 new message. '/msg lambdabot @messages' to read it.
21:01:03 <sailorreality> knui do u know modal logic
21:01:55 <co_dh> whenever I start flymake-mode, my emacs seemed enter a dead loop . 
21:01:59 <Xilon> People don't use Yi here?
21:02:07 <kniu> I'm a vim guy.
21:02:09 <co_dh> No, I don't use Yi.
21:02:48 <Xilon> I can never bother getting all the deps to compile it but I thought it'd be a nice vim replacement
21:03:46 <sailorreality> fags
21:04:00 <kmc> @where ops
21:04:00 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
21:04:07 --- mode: ChanServ set +o Cale
21:04:16 <monochrom> hi, how may I help?
21:04:22 --- mode: ChanServ set +o monochrom
21:04:27 <monochrom> oh!
21:04:35 --- mode: monochrom set +b *!*@74.198.148.18
21:04:35 --- kick: sailorreality was kicked by monochrom (sailorreality)
21:04:55 --- mode: monochrom set -o monochrom
21:05:29 <monochrom> /mode is a modal logic. of course we know modal logic. :)
21:05:54 <kniu> That might have given the poor kid a bad impression of IRC.
21:06:56 <monochrom> on the contrary, he/she gave me a bad impression of IRC
21:07:06 <kniu> Probably a he.
21:07:08 <kmc> kniu, the impression that IRC is full of people who react badly when you call them "fags"?
21:07:19 <kniu> Between the age of 12 and 16.
21:07:48 <kmc> yeah, i wonder if that was a 13-year-old kid studying graduate-level mathematics, or a grad student who never grew out of acting like a 13-year-old
21:08:13 <djahandarie> You'd be suprised. Anonymity can make a grown man be incredibly immature
21:08:17 <ben> Or someone who is going through freenode channels sorted by size.
21:08:27 <monochrom> although, when later he/she complains that he/she was banned, he/she will just say "I just asked about modal logic and I got banned", conveniently forgetting the "fags" part.
21:08:28 <augur> so the reader monad
21:08:36 <augur> how does it's lift2 work?
21:08:59 <augur> because im trying to do it by hand and every time i get a type error
21:09:03 <monochrom> human selective memory is very convenient.
21:09:03 <danderson> monochrom: maybe he was just wondering how modal logic might apply to tobacco products!
21:09:04 <kmc> liftM2 f g h = \x -> f (g x) (h x)
21:09:06 <danderson> ... or something.
21:09:16 <kmc> :t let liftM2 f g h = \x -> f (g x) (h x) in liftM2
21:09:17 <lambdabot> forall t t1 t2 t3. (t -> t1 -> t2) -> (t3 -> t) -> (t3 -> t1) -> t3 -> t2
21:09:59 <augur> kmc: hm. but.. isnt lift2 defined as like... lift2 f a b = do a' <- a, b' <- b, return f a' b'
21:10:00 <augur> ?
21:10:06 <augur> er, return (f a' b')
21:10:08 <kmc> sure
21:10:14 <kmc> but i think the above is equivalent for the Reader monad
21:10:16 <augur> yeah well, im doing that and it aint workin :|
21:10:42 <augur> i end up trying to do (Reader \e -> ...) e
21:10:52 <augur> which obviously cant happen
21:11:13 <kmc> liftM2 f (Reader g) (Reader h) = Reader $ \x -> f (g x) (h x)
21:11:28 <augur> yeah i get the defintion you're giving
21:11:30 <augur> thats not the issue
21:11:37 <augur> im trying to understand the bind definition
21:11:45 <kmc> @src (->) (>>=)
21:11:45 <lambdabot> f >>= k = \ r -> k (f r) r
21:12:09 <augur> what the
21:12:28 <augur> well anyway, yes
21:12:39 <augur> i get that thats bind for the reader monad
21:12:47 <kmc> @djinn (r -> a) -> (a -> (r -> b)) -> (r -> b)
21:12:47 <lambdabot> f a b c = b (a c) c
21:13:08 <augur> but im doing that, and i end up applying (Reader \e -> ...) e'
21:13:37 <kmc> i don't follow
21:13:50 <augur> ill show you
21:14:07 <kmc> (Reader f) >>= k = Reader $ \r -> case k (f r) of Reader k' -> k' r
21:14:09 <kmc> i think
21:14:28 <augur> give me a second
21:14:42 <tomberek> anyone good at 'tying the knot'? I'm trying to envision a double linked list, where the types alternate
21:15:26 <kmc> for alternating types you can do something like «data List2 a b = Nil | Cons a (List2 b a)»
21:15:31 <kmc> but not sure how to make it doubly-linked
21:16:02 <tomberek> kmc: yeah, i'm having a hard time avoiding infinite loops in the type checker
21:16:47 <tomberek> kmc: at the moment, i'm trying mutually recursive data types
21:16:49 <augur> kmc: http://hpaste.org/41841/reader
21:17:59 <kmc> i don't understand these code fragments augur
21:18:06 <kmc> (Reader u) >>= \u' -> ....
21:18:06 <augur> they're evaluation traces
21:18:08 <kmc> what's the syntax there?
21:18:09 <kmc> ok
21:18:16 <kmc> right, the rhs is a lambda
21:18:17 <augur> what do you mean whats the syntax there :|
21:18:19 <kmc> i see
21:18:26 <augur> haskell syntax :|
21:18:43 <augur> im using returns liberally.
21:20:07 <augur> you see? you end up getting (Reader \e -> f u' (v e)) e
21:20:16 <augur> which is obviously a type error
21:23:35 <augur> kmc: but thats what lift2 does right? :|
21:26:27 <augur> i mean, it'd be different if Reader e a were merely a type aliad for e -> 
21:26:32 <augur> er, e -> a
21:26:34 <augur> but its not
21:26:53 <augur> Reader e a = Reader { runReader :: e -> a }
21:27:14 <lars9> there are an hxml and xml, which one do ppl prefer?
21:27:19 <augur> so you cant _apply_ a reader to something
21:27:51 <ManateeLazyCat> Damn it, GAppProxy can't support upload big file, and YourFreedom has killed by GFW, I need find other way to upload Manatee video.
21:28:28 <tomberek> kmc: i think i got something working
21:31:49 <lars9> ManateeLazyCat: can you buy some VPS or SSH service?
21:32:12 <ManateeLazyCat> lars9: GAppProxy is enough for me know
21:32:17 <ManateeLazyCat> s/know/now
21:32:24 <ManateeLazyCat> lars9: Just can't upload big file
21:32:34 <lars9> ManateeLazyCat: see...
21:32:52 <ManateeLazyCat> lars9: GAppProxy is python program that fighting GFW by GoogleApps
21:34:09 <ManateeLazyCat> lars9: GAE have 1GB/day, that's enough for me
21:34:22 <lars9> ManateeLazyCat: cool, damned censorship
21:34:50 <lars9> is GAE's 1G/day free?
21:34:52 <ManateeLazyCat> lars9: Yes, and because GAE use Google server, it's much much faster than other free proxy tool
21:34:56 <ManateeLazyCat> lars9: Yes.
21:35:00 <ManateeLazyCat> lars9: Free
21:35:24 <ManateeLazyCat> lars9: Just install GAppProxy and call proxy.py when box startup.
21:35:37 <ManateeLazyCat> lars9: And install some proxy-rule extension in Chromium
21:35:40 <lars9> it's too good so i guess it will be blocked soon...
21:36:10 <ManateeLazyCat> lars9: Unless China Gov cut all connect to Google server
21:36:27 <lars9> ManateeLazyCat: thats not impossible
21:36:28 <ManateeLazyCat> lars9: But i think gov won't do that, many gov people use gmail.
21:36:37 <lars9> ManateeLazyCat: depends what they care most
21:36:42 <lars9> *on
21:36:53 <ManateeLazyCat> lars9: Yes, i have many proxy tool, if one down, i can switch other.
21:37:10 <ManateeLazyCat> lars9: The key is, gov can't filter us unless he cut network
21:37:28 <ManateeLazyCat> lars9: Always has new proxy tool create in China.
21:37:28 <lars9> ManateeLazyCat: the best way is to switch physical location :)
21:37:48 <ManateeLazyCat> lars9: yes, if someday gov cut network, i will go other country. :)
21:38:53 <lars9> ManateeLazyCat: for freedom :)
21:39:06 <ManateeLazyCat> lars9: Yay! :)
21:42:58 <ManateeLazyCat> All best sites can't access in China.
21:44:27 <ManateeLazyCat> YouTube.com has 15min limit ?
21:45:05 <danderson> yes.
21:45:25 <ManateeLazyCat> Any video sites support 40 minus video upload?
21:45:53 <danderson> it is possible to get that extended. There are various orgs that publish hour+ videos on youtube, but by default you're stuck with 15m + playlist to chain videos
21:46:06 <lars9> ManateeLazyCat: censorship is a damned thing. but it also gives some change to local companies though.
21:46:10 <monochrom> Play your 40-minute video in 3x speed so it becomes 15-minute :)
21:46:35 <lars9> how is vimeo?
21:46:36 <ManateeLazyCat> monochrom: :)
21:46:51 <lars9> s/change/chance/
21:47:09 <monochrom> you can call it "a very fast introduction to manatee!"
21:47:12 <ManateeLazyCat> lars9: You don't know how *many* sites filter by GFW
21:47:29 <danderson> ManateeLazyCat: vimeo.com, maybe?
21:47:40 <ManateeLazyCat> Ok, i try vimeo
21:47:55 <danderson> I can't find any time limits in their FAQ, only size limits (500M of upload/week)
21:48:14 <danderson> ah, found it
21:48:17 <danderson> "Your video can be as long as you like. The only limit is your file size. If you have a basic account, you are limited to 500 MB per week."
21:48:18 <ManateeLazyCat> danderson: Oh, my video is 700MB
21:48:41 <danderson> if you upgrade to the paid account, apparently you can upload videos up to 2GB
21:48:59 <ManateeLazyCat> vimeo.com in GFW list.
21:51:19 <ManateeLazyCat> In China, have video sites, named tudou.com support 10GB free upload
21:51:31 <danderson> use that then?
21:51:54 <ManateeLazyCat> danderson: If you guys not mind access China site. :)
21:52:27 <danderson> I personally don't care either way. Maybe others do.
21:52:53 <ManateeLazyCat> danderson: Ok, uploading
21:53:26 <ManateeLazyCat> In 3 h 50 m
21:54:53 <ManateeLazyCat> Because i type English in my video, cause video is too long
21:55:31 <ManateeLazyCat> I wonder tudou.com support 10GB/file, and haven't any limit
21:55:38 * monochrom begins contributing to http://www.haskell.org/haskellwiki/Gtk2Hs/Tutorials/Intro
21:55:54 <ManateeLazyCat> monochrom: Great
21:56:31 <ManateeLazyCat> After you guys see my video, you know how to play Manatee, and what it is exactly
21:57:02 <monochrom> I fear that "what is Manatee, really?" will be exactly like "what is Monad, really?"
21:57:23 <ManateeLazyCat> monochrom: What's manatee? Depend on how to use it. :)
21:57:28 <monochrom> Yes!
21:57:59 <ManateeLazyCat> monochrom: You can just use editor, you can just use browser, you can choose use all extension (like me). :)
21:58:09 <monochrom> The answer is "really, just use it, go with your heart"
21:58:55 <ManateeLazyCat> monochrom: Maybe i need develop "video editor" in the future, support record/edit/convert/upload automatically.
21:59:15 <ManateeLazyCat> monochrom: Something, like record your desktop, and press one key to upload to YouTube.com
21:59:25 <monochrom> neato
22:00:23 <ManateeLazyCat> monochrom: Or record everything from Android Camera
22:01:40 <ManateeLazyCat> I guess China gov build super-computer (maybe Top-1) for GFW...
22:04:12 <monochrom> It hurts my heart. Some really esteemed and talented computer scientists at the Chinese Academy of Science work on the computational linguistic part of the GFW. The algorithms they invent are brilliant. But the algorithms are used for such a crappy purpose. It hurts my heart.
22:05:05 <xcthulhu> Well... you know that there's tons of algorithms invented for evil, right?
22:05:17 <monochrom> no, I don't
22:05:27 <ManateeLazyCat> monochrom: "Damn GFW", this is only words i can say everyday.
22:05:35 <xcthulhu> Um, all of the high-speed trading algorithms aren't doing the world much good
22:05:54 <xcthulhu> Neither are many of the algorithms behind corporate walls, like microsoft, apple and wolfram
22:05:54 <Adamant> even worse, they're going to make things nastier when they fail
22:06:18 <Adamant> making systems more efficient tends to make them blow up bigger when shit stops working for whatever reason
22:07:25 <xcthulhu> the ol' "bigger they are/harder they fall" principle
22:07:39 <xcthulhu> I think Galileo called it the square-cube scaling law
22:07:56 <Adamant> the more efficient they are, the more they shit when someone dumps sand into the works
22:08:00 <monochrom> haha, you remind me of my past article: http://groups.google.com/group/comp.lang.functional/msg/81756fe3fe07a61a
22:08:26 <ManateeLazyCat> Let me list the some sites can't access in China: Facebook.com Twitter.com YouTube.com WordPress.com Google.com Blogsopt.com dropbox.com mail-archvie.com ... etc.
22:08:28 <xcthulhu> I have a parsec question
22:09:08 <xcthulhu> I have combinator for parsing positive integers (with leading whitespace) and another one for parsing negative integers
22:09:38 <xcthulhu> But the failure messages for these combinators are incomprehensible
22:10:13 <xcthulhu> How do I set the failure messages?
22:10:15 <monochrom> you may use <?> to change error messages to your liking. but I don't know the right places to put them.
22:10:29 <xcthulhu> monochrom:  Me neither :(
22:10:47 <ddarius> monochrom: Usually you can just put them at the "end" of each "nonterminal" which usually corresponds to a definition.
22:10:48 <monochrom> but maybe start playing with "parse_positive_integer <?> ..."
22:11:40 <xcthulhu> Well, I don't know if I have to parse a positive or negative integer, so I have to wrap the combinators in tries:
22:11:57 <xcthulhu> like "pInt = try negInt <|> try posInt"
22:13:40 <lars9> ManateeLazyCat: but that's why chinese have their own social network, instant message, online video companies while most other countries dont, except the USA.
22:14:16 <xcthulhu> A lot of different countries have social networks.
22:15:08 <xcthulhu> I remember that they have one in Vietnam and another in the Netherlands (although people are migrating to facebook)
22:15:11 <lars9> ManateeLazyCat: i dislike censorship, but i just want to say that it's too complicated for us to judge which is good or bad
22:16:17 <ManateeLazyCat> lars9: Yes, biggest social network is QQ (IM client)
22:16:30 <lars9> xcthulhu: those chinese companies are comparable to facebook, youtube, in number of daily active users. and QQ is the largest IM in the world.
22:16:36 <ManateeLazyCat> lars9: And we have Chinese-Version twitter.
22:16:39 <monochrom> pInt = try negInt <|> try posInt <?> "int"
22:17:05 <ManateeLazyCat> lars9: Yes, QQ is best one.
22:17:10 <monochrom> Oh, I heard the hilarious feud between QQ and the 360 company :)
22:17:23 <ManateeLazyCat> monochrom: Yes.
22:17:31 <ManateeLazyCat> monochrom: Fighting in user's computer
22:17:58 <xcthulhu> monochrom: I get this as an error "expecting digit or int"
22:18:01 <xcthulhu> With that code
22:18:06 <ManateeLazyCat> monochrom:  360 is biggest anti-virus software, QQ is biggest IM client
22:18:43 <lars9> ManateeLazyCat: yeah, so GFW iss not a totally evil thing for chinese ppl. though the intention is evil, but the result is out of their control.
22:18:56 <ManateeLazyCat> monochrom: First, 360 kill QQ, let most features can't work. Then QQ force user un-install 360, otherwise, cut down your QQ connect
22:19:16 <xcthulhu> monochrom:  Here's the code, btw - http://pastebin.com/xUMxvQdS
22:19:23 <ManateeLazyCat> lars9: Yes, most Chinese people don't use Facebook.com, save much time. IMO.
22:19:54 <ManateeLazyCat> lars9: Just little (1%) people know how to fighting GFW.
22:20:03 <ManateeLazyCat> lars9: But not always work.
22:20:23 <ManateeLazyCat> lars9: You need many proxy tools for ready, switch other if one down.
22:20:24 <lars9> ManateeLazyCat: my Facebook is too flooded, so i'm starting to use twitter instead, much simpler :)
22:20:50 <ManateeLazyCat> lars9: If not GFW, i have finish twitter-client in Manatee.
22:20:57 <ManateeLazyCat> lars9: I need build manatee-proxy first.
22:21:05 <papermachine> What's the Chinese variant of twitter?
22:21:53 <ManateeLazyCat> papermachine: Like Sina-microblog, RenRen-microblog, FanFou-microblog ..etc.
22:22:03 <ManateeLazyCat> papermachine: But i won't use those, like QQ, not safe.
22:22:23 <ManateeLazyCat> papermachine: All those message must check by Gov.
22:22:32 <ManateeLazyCat> papermachine: Infact, is check self.
22:22:43 <papermachine> Oh, didn't realize renren had a microblogging kind of thing
22:22:47 <lars9> ManateeLazyCat: it's said QQ had a peak of 100 million users online?
22:22:58 <ManateeLazyCat> lars9: Yes, even more.
22:23:16 <ManateeLazyCat> lars9: Only Facebook.com have so many online people like QQ. 
22:23:27 * ddarius simply doesn't use social networking sites.
22:23:40 <ManateeLazyCat> lars9: In Chinese, most people (99.9999%) use QQ for IM
22:23:44 <lars9> 1/60 human being...
22:24:18 <xcthulhu> ddarius:  I argue there's a pragmatic dimension to them.
22:24:20 <ManateeLazyCat> lars9: I remember 100 million is last year number
22:24:45 <xcthulhu> For instance, I have friends scattered across three continents, and it's just plain hard to keep track of everyone in a conventional address book
22:25:06 <ManateeLazyCat> lars9: Only 0.00..01% people use IRC.
22:25:07 <monochrom> xcthulhu: I have only tried Parsec 2. I give it inputs like "a", " a", " -a", " - ". I get "expecting int", no mention of digit.
22:25:40 <xcthulhu> I'm using parsec 2 also
22:26:11 <xcthulhu> there's other problems with my parser; I should deal with them first before worrying about this.
22:26:42 * xcthulhu is still happier doing it this way than in scheme
22:27:15 <ddarius> Isolationism!  Because it's worked every other time.
22:27:59 <ddarius> xcthulhu: For some reasons it would be prudent to better left factor your grammar, though perhaps you have reasons not to in this case.
22:28:14 <ManateeLazyCat> I need sleep .... bye all. :)
22:29:07 <monochrom> this is why Parsec's Tokenizer decides to eat spaces after token rather than eat spaces before token
22:29:56 <monochrom> it took me a while to reason out why it is not an arbitrary choice
22:31:01 <monochrom> wait, the lazy cat is sleeping at 2:30 pm ??!!!
22:31:33 <xcthulhu> I should probably rework the code to do this...  integer reading is the only thing that's right-factored
22:32:14 <xcthulhu> And I will admit that I am guilty of using "Write Yourself a Scheme" as a tutorial here
22:32:45 <monochrom> Write Yourself a Scheme in 47.99999.... Hours
22:33:43 <monochrom> Write Yourself Scheme R4.999...RS in 47.999... Hours :)
22:34:05 <papermachine> ... 47.999.... = 48
22:34:19 <monochrom> It's a zeno kind of joke!
22:34:25 <lpsmith> Out of curiousity,  has anybody tried using the new LLVM backend to generate ARM code?
22:34:56 * Xilon wonders if that works for iPhone
22:36:45 <lpsmith> Xilon, I had a slightly different target in mind,  but I think somebody has written a Haskell iPhone app.
23:00:11 <kadoban> i have f, g, h, i :: a -> Maybe Int.  is there some cute way i can chain them together so i try f, if it's nothing, try g, if it's nothing, try h, etc.?
23:01:20 <monochrom> f x `mplus` g x `mplus` h x `mplus` i x
23:01:48 <kadoban> ah, thanks
23:02:18 <monochrom> also <|>
23:02:32 <kadoban> that's just an alias for mplus?
23:02:44 <monochrom> approximately.
23:02:45 <lars9> msum ?
23:03:05 <ddarius> or asum
23:03:22 <ddarius> Also mconcat if you wrap in Last.
23:03:37 <monochrom> long story: mplus is from MonadPlus, <|> is from Alternative. Alternative is more general. Maybe is both MonadPlus and Alternative, and when that happens, mplus and <|> do the same thing.
23:03:57 <ddarius> s/Last/First
23:04:01 <kadoban> ahh
23:04:08 <kadoban> okay, thanks all, i'll look at those
23:04:55 <ddarius> If you returned First instead of Maybe you could just f `mappend` g `mappend` h `mappend` i or mconcat [f,g,h,i]
23:05:49 <kadoban> oh, hmm, i haven't seen First before
23:07:12 <ddarius> :t msum . sequence [?f, ?g, ?h, ?i]
23:07:13 <lambdabot> forall (m :: * -> *) a (f :: * -> *). (MonadPlus m, ?f::f (m a), ?g::f (m a), ?h::f (m a), ?i::f (m a), Monad f, Functor f) => f (m a)
23:07:57 <ddarius> :t msum Prelude.. sequence [?f, ?g, ?h, ?i]
23:07:57 <lambdabot> forall (m :: * -> *) a a1. (MonadPlus m, ?f::a1 -> m a, ?g::a1 -> m a, ?h::a1 -> m a, ?i::a1 -> m a) => a1 -> m a
23:08:27 <lars9> ddarius: what is "?"?
23:08:49 <ddarius> It's the syntax for the implicit parameters extension.
23:09:20 <ddarius> It's a mostly crappy extension (particularly the linear implicit parameters), but it is handy for placeholders.
23:09:26 <lars9> ddarius: what does it imply?
23:12:10 <Gracenotes> good for determining which types are expected in an expression
23:19:07 <kmc> linear implicit parameters?
23:19:12 <kmc> are those the ones introduced with %?
23:19:15 <kmc> i could never find docs on that
23:20:26 <kmc> lars9, http://haskell.org/ghc/docs/6.12.2/html/users_guide/other-type-extensions.html#implicit-parameters
23:24:03 <rprije> Does anyone here know anything about legacy adapters in reactive?
23:26:55 <ddarius> rprije: I would tell you to just ask your question, but then, in five minutes, someone will come in and do the same thing, so what's the point?
23:41:00 <rprije> ok. Well here's my question then. This succeeds in performing the getChar calls but doesn't do the putChar calls. Why? http://hpaste.org/41843/legacy_adapter_toy_not_executi
23:43:25 <ddarius> rprije: It never gets to line 6 at all.
23:43:31 <ddarius> Perhaps you wanted to fork in there?
23:44:28 <rprije> Shit. You're right. I'm thinking of this reactive thing as being more magical than it really is. Thanks.
23:45:38 <kmc> ddarius, what are linear implicit parameters?
23:50:48 <allbery_b> I thought those were long dead
23:51:23 <kmc> what were they, then?
23:51:52 <ddarius> http://www.haskell.org/ghc/docs/6.4.2/html/users_guide/type-extensions.html#linear-implicit-parameters
23:53:19 <allbery_b> yeh. that
23:54:04 <kmc> yes, seems it's no longer supported, but the manual still makes passing mention of the %x syntax
23:54:11 <lars9> > iterate (2:)
23:54:12 <lambdabot>   Overlapping instances for GHC.Show.Show ([t] -> [[t]])
23:54:12 <lambdabot>    arising from a us...
23:54:18 <kmc> anyway it's a clever idea; do you know why it was dropped?
23:54:20 <lars9> > iterate (2:) []
23:54:21 <lambdabot>   [[],[2],[2,2],[2,2,2],[2,2,2,2],[2,2,2,2,2],[2,2,2,2,2,2],[2,2,2,2,2,2,2],[...
23:54:49 <lars9> > iterate (1+) 1
23:54:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
23:54:59 <kmc> > iterate (2^) 1
23:55:00 <lambdabot>   [1,2,4,16,65536,20035299304068464649790723515602557504478254755697514192650...
23:55:48 <lars9> :t unfoldl
23:55:50 <lambdabot> Not in scope: `unfoldl'
23:55:57 <lars9> :t unfoldr
23:55:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
23:56:26 <allbery_b> I guess you could say they were a partial implementation of Clean's *x parameters, but theyu turned out to be a really bad fit with Haskell
23:56:44 <kmc> how so?
23:57:12 <allbery_b> aka uniqueness types
23:59:00 <allbery_b> http://www.haskell.org/ghc/docs/6.4/html/users_guide/type-extensions.html#linear-implicit-parameters read through the warnings
