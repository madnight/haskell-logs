00:01:58 <luc_t> ok found it with ghc-pkg list
00:02:13 <philo> hi
00:02:24 <philo> have the ParseLib been deprecated ?
00:30:21 <Mitar> how can i secure FFI calls so that they have locks around so that they can be called only one at the time from haskell? i would like to do this locks in haskell part of the code
00:33:07 <dmwit> Perhaps with MVars?
00:34:42 <Mitar> the point is that i would not like to have special state monad for that
00:34:44 <Mitar> just IO
00:35:37 <Lemmih> Mitar: Use a global MVar.
00:35:53 <Mitar> haskell have globals?
00:36:33 <Lemmih> Kinda.
00:37:20 <Mitar> http://www.mail-archive.com/haskell-cafe@haskell.org/msg09190.html
00:37:24 <Mitar> i found your post ;-)
00:38:57 <Mitar> so how one does lock?
00:39:02 <Mitar> global lock
00:39:39 * hackagebot yesod 0.6.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.1 (MichaelSnoyman)
00:41:49 <ddarius> Often an MVar () is used as a lock, but in this case you could even use an MVar (Foo -> IO Bar) that holds the FFI function.
00:42:54 <Mitar> but then i would have to provide that MVar everywhere I call this function?
00:43:20 <ddarius> You'd have to provide the lock MVar anyway.
00:43:27 <Mitar> yes, how do i provide one?
00:43:49 <Mitar> so that I can hide this from the caller?
00:43:58 <ddarius> I would just pass it around, but you can use the unsafePerformIO hack.
00:45:09 <Mitar> and where can i find more about this hack?
00:45:20 <Mitar> because it seems for me that semantics does not change with use of such lock
00:45:42 <ddarius> @google unsafePerformIO hack
00:45:57 <lambdabot> Plugin `search' failed with: thread killed
00:46:01 <ddarius> @google unsafePerformIO hack
00:46:12 <Mitar> i found
00:46:16 <lambdabot> Plugin `search' failed with: thread killed
00:46:20 * ddarius needs to look at the @google plugin to find out why it's so flaky.
00:46:39 <Mitar> missing locks? ;-)
00:49:16 <Mitar> haskell.org down?
01:01:40 <Veinor> @google stuff
01:01:41 <lambdabot> http://www.storyofstuff.com/
01:01:41 <lambdabot> Title: The Story of Stuff
01:01:54 <Veinor> haskell.org is indeed down
01:01:58 <Veinor> D:
01:02:47 <Mitar> ;-)
01:02:53 <Mitar> but that story is not bad ;-)
01:52:17 <h-cell> I just wrote another cool new web application in Haskell and I would like to share it with the community. http://inputyourdata.com/cgi-bin/random_walk.cgi?n=8&i=0&p=0.5&s=1000
01:56:59 <Mitar> but you draw with gnuplot?
01:00:07 <h-cell> the computation is done in Haskell and yes, I have integrated the Haskell-Gnuplot wraper 
01:06:24 <h-cell> the application itself is based on the Network.CGI framework
01:15:16 * hackagebot language-cil 0.2.0 - Manipulating Common Intermediate Language AST  http://hackage.haskell.org/package/language-cil-0.2.0 (TomLokhorst)
01:37:47 <blueonyx> hi, can "when" abort a do block in the list monad?
01:41:24 <koninkje> > do { x <- [1..] ; when True [] }
01:41:27 <lambdabot>   mueval-core: Time limit exceeded
01:42:09 <blueonyx> ah nice, thanks
01:42:13 <koninkje> > do { x <- [1..10] ; when True [] }
01:42:14 <lambdabot>   []
01:42:43 <blueonyx> > do { x <- [1..10] ; when True [] ; return x }
01:42:44 <lambdabot>   []
01:42:45 <koninkje> Though note that it doesn't "abort" per se, as shown
01:42:53 <blueonyx> jep
01:47:15 <ddarius> See guard.
01:49:42 <pelotom> @type mzero
01:49:43 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
01:50:36 <pelotom> > do { x <- [1..] ; when True mzero }
01:50:40 <lambdabot>   mueval-core: Time limit exceeded
01:51:00 <pelotom> mm, well yeah
01:53:30 <blueonyx> > do { when True mzero ; x <- [1..] ; return x }
01:53:30 <lambdabot>   []
01:53:50 <blueonyx> that's what i need :)
01:54:59 <pelotom> blueonyx: :)
02:13:19 <sipa> is haskell.org down?
02:14:35 <tonkman> seems to be
02:20:00 <dons> yes. we're on it. though it is the yale server, and their admins don't work on sundays
02:23:38 * hackagebot tls 0.3.1 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-0.3.1 (VincentHanquez)
02:33:41 <Rutix> hmm i just encountered this symbol :<-:
02:34:02 <Rutix> What does that mean?
02:34:15 <ziman> it is an infix data constructor
02:34:36 <Rutix> Ty
02:34:37 <ziman> for example, data Foo = Bar :<-: Baz | Moo
02:35:25 <Rutix> Yea
02:35:26 <ziman> no, it's an infix constructor (it can be used for both data and types)
02:35:40 <ziman> and multiparam classes, iirc
02:35:43 <Rutix> I saw it in data Rule= Goal :<-: [Goal]
02:35:51 <Rutix> Thats why i was wondering
02:36:05 <ziman> then it's an infix data constructor in your case
02:36:35 <ziman> its distinguishing feature is the colon at the beginning â€” the other colon is usually added just to maintain symmetry & aesthetics
02:36:42 * hackagebot language-cil 0.2.1 - Manipulating Common Intermediate Language AST  http://hackage.haskell.org/package/language-cil-0.2.1 (TomLokhorst)
02:38:16 <Rutix> Ah right thank you ziman
02:40:42 <ziman> (the distinguishing feature of infix constructors)
02:49:43 <Nibble> is haskell.org down?
02:50:15 <Heffalump> seems to be :-(
02:50:20 <Nibble> -__-
02:50:22 <ManateeLazyCat> Nibble: Looks so
02:50:31 <Nibble> I just accidentaly my xmonad file
02:50:50 <Nibble> and I remember taking some changes from the config archive over there
02:50:53 <ManateeLazyCat> Nibble: Yesterday you install gtk2hs darcs any problem?
02:51:19 <pkrumins> down again!
02:51:34 <Nibble> ManateeLazyCat: hmm
02:51:47 <Nibble> ManateeLazyCat: I can't remember :/
02:51:56 <ManateeLazyCat> Nibble: Can't remember?
02:52:02 <ManateeLazyCat> Nibble: Install ok?
02:52:18 <Nibble> ManateeLazyCat: after using darcs, I cd'd to the dir and ran something
02:52:42 <Nibble> ManateeLazyCat: I will have to come back to you on that, have to fix this config first
02:54:40 <Nibble> any ideas when it will be back up again?
02:56:20 * ManateeLazyCat Damn code.haskell.org/gtk2hs can't connect.
03:10:53 <pkrumins> is it possible to use windows api from haskell? for example do a FindWindow, then call ShowWindow on it?
03:11:07 <ddarius> pkrumins: Of course.
03:11:21 <pkrumins> ddarius: can you give me some further directions on that?
03:11:37 <pkrumins> I looked into Win32 package but it didn't seem to have that
03:11:48 <ManateeLazyCat> How about ghc-7? Stable enough? Where i can find newest ghc-7 ?
03:12:00 <ManateeLazyCat> Axel looks want gtk2hs support ghc-7
03:12:08 <ddarius> There's a package with bindings to various Win32 API functions.  If the function you need is not in it, you can bind it yourself quite easily.
03:12:16 <ManateeLazyCat> Daemn is code.haskell.org down now. 
03:12:34 <pkrumins> ddarius: do you know which package it is?
03:12:58 <pkrumins> ddarius: hmm google indicates it might be the same Win32 package
03:14:38 <Saizan> ManateeLazyCat: www.haskell.org/ghc/
03:15:13 <ManateeLazyCat> Saizan: haskell.org down completely
03:16:03 <ManateeLazyCat> Damn it, How do release new version?
03:19:08 <Saizan> ManateeLazyCat: luckyly it's on another server http://new-www.haskell.org/ghc/dist/7.0.1-rc2/
03:19:34 <Saizan> ManateeLazyCat: it's just the second release candidate though, not the final release
03:19:43 <Saizan> ManateeLazyCat: since that didn't happen yet
03:20:14 <ManateeLazyCat> Saizan: Yes, i know, but Axel want gtk2hs support ghc-7, though, i disagree support RC version.
03:20:28 <ManateeLazyCat> Saizan: It's boring to support RC version.
03:20:51 <Saizan> ManateeLazyCat: hopefully it shouldn't change much
03:21:13 <ManateeLazyCat> Saizan: If not ghc-7 problem, we can new gtk2hs now.
03:21:34 <Nibble> @type openFile
03:21:35 <lambdabot> Not in scope: `openFile'
03:21:49 <Nibble> it should be IO (), right?
03:21:55 <ManateeLazyCat> Nibble: no.
03:22:07 <Nibble> what is it then
03:22:13 <ManateeLazyCat> Nibble: I remember openFile : System.IO openFile :: FilePath -> IOMode -> IO Handle
03:22:54 <Nibble> ManateeLazyCat: I was thiking of the return part only, and there it should have been Handle, my fault for being too general :)
03:24:21 * ManateeLazyCat pasted "openFile" at http://paste2.org/get/1077094
03:24:22 <ManateeLazyCat> Nibble: Remember use bracket wrap openFile, like above. 
03:24:40 <ManateeLazyCat> Nibble: If any exception happened, you can use hClose close File.
03:28:43 <dons> ddarius: did you see the request for parsec 3 info?
03:29:04 <Nibble> hmm
03:29:18 <Nibble> ManateeLazyCat: in haskell, I have imported System.IO how do I create a connection
03:30:49 <dons> ddarius: i think the libraries list wants a definitive statement from the maintainer that parsec 3 is stable and recommended.
03:30:52 <dons> can you provide that?
03:31:04 * ManateeLazyCat Anyway, downloading ghc-7 to test gtk2hs-0.12.0
03:31:40 <ManateeLazyCat> @hoogle connect
03:31:41 <lambdabot> Network.Socket connect :: Socket -> SockAddr -> IO ()
03:31:41 <lambdabot> Network.HTTP.Base CONNECT :: RequestMethod
03:31:41 <lambdabot> Network.Socket Connected :: SocketStatus
03:31:47 <ManateeLazyCat> @hoogle connectTo
03:31:47 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
03:31:48 <lambdabot> Network.CGI.Compat connectToCGIScript :: String -> PortID -> IO ()
03:31:51 <McManiaC> C:\Users\Nils>cabal install gtk
03:31:51 <McManiaC> Resolving dependencies...
03:31:52 <McManiaC> cabal: Codec.Compression.Zlib: incorrect header check
03:32:00 <McManiaC> whats wrong here?
03:32:22 <dschoepe> McManiaC: Possibly missing zlib headers
03:33:32 <ManateeLazyCat> Nibble: Use connectTo
03:34:23 <Nibble> hmm
03:34:29 <Nibble> can one make flyspell support haskell
03:34:53 <McManiaC> dschoepe: nope
03:34:57 <ManateeLazyCat> Nibble: I remember have.
03:34:58 <Nibble> @type connectTo
03:34:59 <lambdabot> Not in scope: `connectTo'
03:35:00 <McManiaC> they're in my path
03:35:06 <Nibble> ManateeLazyCat: because I really need it
03:35:21 <McManiaC> @type Network.connectTo
03:35:22 <lambdabot> Network.Socket.HostName -> Network.PortID -> IO GHC.IOBase.Handle
03:35:37 <ManateeLazyCat> Nibble: I perhaps will add flyspell and hlint support in my editor after i release my project.
03:36:08 <Nibble> ManateeLazyCat: well, I am not really going to switch from emacs any time soon :/
03:36:36 <ManateeLazyCat> Nibble: I will focus my time on IDE feature and terminal after i release.
03:36:55 <ManateeLazyCat> Nibble: I'm sure i can build best development environment for Haskell. :)
03:37:32 <Nibble> ManateeLazyCat: well, sure, but emacs is a lot more :P
03:37:50 <ManateeLazyCat> Nibble: Emacs just can do text work. :)
03:38:55 <Nibble> ManateeLazyCat: that is what  I want it to do
03:41:44 <ManateeLazyCat> Nibble: I want OS, a really OS.
03:42:17 <Nibble> ManateeLazyCat: well, if you make your OS a bit slimmer in interface (emacs way with those mode lines and one echo row is great) then I would be _really_ _really_ interested
03:42:53 <ManateeLazyCat> Nibble: I have, i just hide then when you don't need them.
03:43:10 <McManiaC> I cant even get used to emacs
03:43:11 <McManiaC> ^^
03:43:19 <ManateeLazyCat> Nibble: Example, interactivebar (similar Emacs's minibuffer) just show when you need input something.
03:43:34 <ManateeLazyCat> Nibble: In other time, it hide to save user's screen space.
03:43:59 <Nibble> ManateeLazyCat: link to your album again :)
03:44:01 * hackagebot mtl 2.0.1.0 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/mtl-2.0.1.0 (RossPaterson)
03:44:21 <ManateeLazyCat> Nibble: Oh, my god, http://goo.gl/MkVw
03:44:58 <McManiaC> http://npaste.de/pN/ any ideas what I could try?
03:45:03 * hackagebot HRay 1.2.0 - Haskell raytracer  http://hackage.haskell.org/package/HRay-1.2.0 (KennethHoste)
03:45:11 <Nibble> ManateeLazyCat: that latest screenshot is onto something
03:45:43 <Nibble> wait what
03:45:47 <Nibble> it has integrated translation?
03:46:58 <ManateeLazyCat> Nibble: Yes, translate your mother language to English or any language in irc client.
03:47:10 <Nibble> ManateeLazyCat: nice :)
03:47:17 <Nibble> I will make some lunch now
03:47:18 <Nibble> bbiab
03:47:25 <ManateeLazyCat> Nibble: You can write any language in irc client, then it will translate English to server .
03:49:29 <ManateeLazyCat> Nibble: http://www.flickr.com/photos/48809572@N02/5154125192/lightbox/ global interactive bar.
03:49:41 <ManateeLazyCat> Nibble: http://www.flickr.com/photos/48809572@N02/5154125200/lightbox/ local interactive bar.
03:49:43 <Saizan> McManiaC: that error comes from cabal trying to decompress some tarball, the header is the one of the file where the CRC hash is stored
03:49:57 <ManateeLazyCat> Nibble: Local interactive bar will hide when you don't want input.
03:50:12 * hackagebot HRay 1.2.1 - Haskell raytracer  http://hackage.haskell.org/package/HRay-1.2.1 (KennethHoste)
03:50:21 <McManiaC> Saizan: could I download/unpack it by hand?
03:50:27 <ManateeLazyCat> Nibble: And local interactive bar is local for every buffer, don't like Emacs, just have one minibuffer, when many module want input, it will crazy you.
03:50:45 <Saizan> McManiaC: http://hackage.haskell.org/trac/hackage/ticket/686
03:50:49 <pkrumins> oh snap, haskell was up fo a few mins and now down again -_-
03:51:23 <Igloo> pkrumins: Are you sure it was?
03:51:43 <Saizan> McManiaC: i guess you could download and unpack the package manually from hackage and then run "cabal install" from inside it
03:52:13 * hackagebot digestive-functors 0.0.1 - A general way to consume input using applicative functors  http://hackage.haskell.org/package/digestive-functors-0.0.1 (JasperVanDerJeugt)
03:55:17 * hackagebot Zwaluw 0.1 - Combinators for bidirectional URL routing  http://hackage.haskell.org/package/Zwaluw-0.1 (MartijnVanSteenbergen)
04:00:18 * hackagebot roman-numerals 0.4.0.1 - Parsing and pretty printing of Roman numerals  http://hackage.haskell.org/package/roman-numerals-0.4.0.1 (RoelVanDijk)
04:01:25 <tonkman> how do I combine [12,1,123] to 121123
04:01:34 <Zao> tonkman: concat . show
04:01:42 <tonkman> problem is that the size of the numbers can vary
04:01:43 <Zao> Err, concat . map show, that is.
04:02:01 <tonkman> thanks
04:02:03 <Zao> > map show [42, 3, 5]
04:02:04 <lambdabot>   ["42","3","5"]
04:02:06 <Jafet> You mean concatMap show?
04:02:09 <Zao> Jafet: :D
04:02:11 <tonkman> I tried first with foldl
04:02:13 <Zao> @src concatMap
04:02:13 <lambdabot> concatMap f = foldr ((++) . f) []
04:02:30 <Jafet> > show =<< [1,11,21,1211]
04:02:31 <lambdabot>   "111211211"
04:03:08 <companion_cube> nice
04:03:28 <tonkman> read (show =<< [1,11,21,1211])::Integer would do the trick
04:06:51 <pkrumins> anyonw knows if there is another way to access module documentation than through haskell.org (like http://www.haskell.org/ghc/docs/6.12.2/html/libraries/process-1.0.1.2/System-Process.html)
04:07:19 <monadic_kid> pkrumins: hoogle or hayoo, hayoo has more packages
04:09:50 <pkrumins> thanks!
04:10:35 <pkrumins> monadic_kid: can't quite find hayoo, got the url?
04:10:52 <pkrumins> oh here
04:10:53 <pkrumins> http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:11:04 <monadic_kid> pkrumins: http://holumbus.org/hayoo/hayoo.html
04:11:38 <monadic_kid> pkrumins: you can use types to find something you're roughly looking for as well
04:12:58 <monadic_kid> pkrumins: I have them added to my firefox search toolbar
04:13:29 <monadic_kid> pkrumins: if you're using leksah it has a module broswer
04:13:48 <monadic_kid> *browser
04:15:52 <monadic_kid> pkrumins: probably the eclipse plugin does that too
04:16:22 * hackagebot AC-Boolean 1.0.0 - Handle Boolean values generatically.  http://hackage.haskell.org/package/AC-Boolean-1.0.0 (AndrewCoppin)
04:20:32 <ddarius> dons: I haven't seen that and don't think I will be able to until haskell.org is up again.
04:20:47 <ManateeLazyCat> Have anyone install ghc-7 ? I have push new patch to make gtk2hs can install with ghc-7, i have test, works fine. I also want someone help me test it again. Thanks. 
04:21:44 <ddarius> Actually, I should be able to check via a different means.
04:28:03 <dons> ddarius: yes, ok.
04:30:07 <Nibble> hmm
04:30:16 <Nibble> @type Text.Printf.hPrintF
04:30:17 <lambdabot> Not in scope: `Text.Printf.hPrintF'
04:30:27 <Nibble> what is the name of the printf with handle function
04:30:36 <ManateeLazyCat> Nibble: Good news, i have fix ghc-7 problem with gtk2hs.
04:30:50 <Nibble> ManateeLazyCat: nice, ghc-7 is with llvm right?
04:30:53 <Nibble> That is neat
04:31:05 <ManateeLazyCat> Nibble: I don't think so.
04:31:29 <ManateeLazyCat> Nibble: I just download ghc-7-rc2 from http://new-www.haskell.org/ghc/dist/7.0.1-rc2/
04:31:37 <Ke> llvm is one of the alternative backends
04:31:38 <ManateeLazyCat> Nibble: Install like ghc-6.12.3
04:31:51 <ManateeLazyCat> Nibble: I think it's need configure to build with llvm.
04:32:02 <Nibble> ManateeLazyCat: I am messing with my irc bot right now,
04:32:08 <Ke> llvm and dynamic linking is available for amd64
04:32:26 <Nibble> @type Text.Printf.hPrintf
04:32:27 <lambdabot> forall r. (HPrintfType r) => GHC.IOBase.Handle -> String -> r
04:32:58 <ManateeLazyCat> Nibble: I guess you will love my irc client. :)
04:33:27 <nus> ManateeLazyCat, what was the problem?
04:33:38 <ManateeLazyCat> nus: What about?
04:33:58 <nus> <ManateeLazyCat> Nibble: Good news, i have fix ghc-7 problem with gtk2hs.
04:35:01 <ManateeLazyCat> nus: ghc-7 use Cabal-1.10.0, in Cabal-1.10 installedPkgInfo accept [PackageDB] and not PackageDB
04:35:28 <ManateeLazyCat> nus: So I add some version-macro in gtk2hs to make gtk2hs can compile under ghc-7
04:35:38 <ManateeLazyCat> @hoogle installedPkgInfo
04:35:38 <lambdabot> No results found
04:36:47 <ManateeLazyCat> All gtk2hs-base packages (gtkimageview, gtksourceview, webkit...etc.) have same problem, i'm working on it.
04:38:11 <Nibble> what lib is connectTo in
04:38:17 <nus> uhm, www.h.o is down
04:38:22 <ManateeLazyCat> Nibble: Network
04:38:26 <ManateeLazyCat> @hoogle connectTo
04:38:26 <lambdabot> Network connectTo :: HostName -> PortID -> IO Handle
04:38:26 <lambdabot> Network.CGI.Compat connectToCGIScript :: String -> PortID -> IO ()
04:41:05 <Nibble> thanks
04:43:43 <hpc> nus: is .o even a top-level domain?
04:44:06 <engla> of course not. sometimes it's used for .org
04:45:19 <ManateeLazyCat> I have push new patches to gtk2hs main repository, now should works with ghc-7, please let me know if you found any bug between gtk2hs and ghc-7, thanks! :)
04:47:05 <pkrumins> anyone messed with Win32 module and knows what's the type for C's NULL is?
04:49:13 <pkrumins> found out nullPtr but I can't quite use it for String
04:49:17 <nus> hpc, more precisely, www.haskell.org does not accept HTTP connections on port 80.
04:49:51 <pkrumins> in C I'd pass NULL but in Haskell I am not sure how to pass NULL when it exepcts String
04:50:27 <Saizan> []?
04:50:29 <sipa> you can pass undefined, and hope it is never pattern matches :)
04:50:54 <Zao> Which functino?
04:50:58 <pkrumins> findWindow
04:51:07 <pkrumins> i want to search wndclass only
04:51:14 <pkrumins> first arg, so 2nd is NULL
04:52:04 <pkrumins> http://hackage.haskell.org/packages/archive/Win32/latest/doc/html/src/Graphics-Win32-Window.html#findWindow
04:52:12 <Zao> I'd say that it's improperly wrapped.
04:52:27 <pkrumins> oh?
04:52:35 <Zao> Wrap c_FindWindow properly yourself, and submit a bug.
04:52:37 <FunctorSalad_> use c_FindWindow if it's exported
04:52:51 <ManateeLazyCat> sipa: undefined is bad idea. :)
04:52:54 <Zao> FunctorSalad_: It seems to export everything.
04:53:01 <pkrumins> okay, trying c_FindWindow
04:53:09 <pkrumins> it takes LPCTSTR
04:53:18 <pkrumins> LPCTSTR -> LPCTSTR -> IO HWND
04:53:32 <FunctorSalad_> btw what is an LPCTSTR? :)
04:53:41 <ManateeLazyCat> pkrumins: If you working on binding C library, just pass nullPtr
04:53:44 <pkrumins> local poointer to c string
04:53:54 <Zao> pkrumins: Quite wrong.
04:53:59 <FunctorSalad_> what does 'local' mean here?
04:54:06 <pkrumins> some thing of the past i guess
04:54:09 <Zao> It's not local. It's a far pointer.
04:54:10 <pkrumins> Zao: oh?
04:54:17 <pkrumins> far pointer!
04:54:29 <Zao> From the days where you could have things out of segment.
04:54:37 <pkrumins> i remember that
04:54:40 <Jafet> Redmond's Little Hungary.
04:54:40 <Zao> In any way, it's a char const* or wchar_t const*.
04:54:48 <pkrumins> okai i am gonna try to pass nullPTR
04:54:48 <Zao> Depending on whether you're an ANSI or UNICODE build.
04:55:13 <Zao> You have withTString to get a temporary LPCTSTR from a String.
04:55:25 <pkrumins> oh nice
04:55:31 <Zao> LP is long pointer, C is const, T is TCHAR, STR is c-string.
04:55:37 <nus> "Long pointer"
04:55:48 <pkrumins> right!
04:55:50 <Zao> nus: From the golden age of non-flat memory.
04:55:54 <tonkman> is the mathematica-like PowerMod function for haskell?
04:56:05 <ManateeLazyCat> pkrumins: As Zao said, use withCString
04:56:11 <Zao> ManateeLazyCat: withTString.
04:56:12 <Zao> http://hackage.haskell.org/packages/archive/Win32/2.2.0.2/doc/html/src/Graphics-Win32-Window.html#findWindow
04:56:24 <Zao> Look at the implementation of `findWindow'.
04:56:24 <FunctorSalad_> non-flat? how'd that work? :)
04:56:31 <Zao> FunctorSalad_: segment:offset
04:56:34 <nus> Zao, heh, "my world is so TINY, wait, no, it's SMALL.."
04:56:35 <FunctorSalad_> oh
04:56:43 <ManateeLazyCat> Zao: withTString, what's the difference?
04:57:09 <Zao> ManateeLazyCat: The Windows API has two variants, one MBCS for narrow strings, and one UNICODE for UTF-16 strings.
04:57:28 <Zao> ManateeLazyCat: In the former, all macros like MessageBox, CreateWindow resolve to MessageBoxA, CreateWindowA and take narrow strings.
04:57:41 <Zao> ManateeLazyCat: In the latter, they resolve to MessageBoxW, CreateWindowW, etc, which take UTF-16 strings.
04:57:58 <Zao> A TCHAR is either a `char' or a `wchar_t', depending on build settings.
04:58:31 <Zao> Modern APIs normally only occur in W variants, as the narrow ones are thankfully an artifact of ancient times.
04:58:32 <ManateeLazyCat> Zao: so withTString is narrow string or UTF-16 string depend on build?
04:58:39 <Zao> ManateeLazyCat: Right.
04:58:49 <Zao> As for what kind you get with the Win32 package, I have no idea.
04:58:53 <ManateeLazyCat> Zao: I see, thanks for explain. :)
04:59:04 <Zao> I very rarely use it, as it's quite incomplete in parts.
04:59:11 <Zao> (I'm a native C++ programmer at heart)
04:59:19 <ManateeLazyCat> Zao: Hehe. :)
04:59:24 <nus> Zao, still? (-;
04:59:56 <Ke> !
05:00:07 * nus s/C++//g Zao
05:00:09 <ManateeLazyCat> I'm pure haskeller now. :)
05:00:11 <Zao> It'd be nice if the *A APIs understood UTF-8, but there's way too much risk and work in updating them to support longer MBCS than DBCS charsets like Shift-JIS.
05:01:09 <pkrumins> so: withTString "Chrome" $ \cStr -> do hwnd <- c_findWindow cStr nullPtr
05:01:12 <pkrumins> something like this?
05:02:04 <Zao> You might want to use the ptrToMaybe bits to get a Maybe HWND, but yeah.
05:02:41 <pkrumins> nice, trying this.
05:02:45 <Zao> And for the love of god, NEVER EVER try to rebuild Win32 yourself.
05:02:52 <Zao> Unless you like picking up the pieces of a broken GHC :D
05:02:55 <pkrumins> okay!
05:03:36 <Zao> (I tried once, heh)
05:04:07 <Zao> (GHC depends on Win32, and if you modify it, just about every package in base will want to be rebuilt when you cabal stuff)
05:05:15 <nus> Cabal needs to keep per platform "core" packages exception list
05:06:31 <pkrumins> crazy
05:06:34 <pkrumins> i will never try that
05:07:17 <Zao> (I tried to add peekMessage, heh)
05:08:36 <pkrumins> I hope I don't need it
05:10:37 <monadic_kid> well that is if you're adding it to the origional library right? it's not a big deal if you do it in your own module
05:10:54 <Zao> monadic_kid: Right. I was trying to fix some error in another function while at it.
05:11:11 <AmJa> Hey guys
05:11:21 <AmJa> I forgot my password on #c 
05:11:35 <AmJa> can anyone help me with a simple c program?
05:11:35 <byorgey> hi AmJa, that's unfortunate
05:11:43 <AmJa> yea
05:12:12 <byorgey> just post a link to your code and your question, if someone is feeling extra-nice they might help
05:12:33 <monadic_kid> don't expect someone to do your homework please
05:12:49 <byorgey> also, that doesn't really make sense, passwords are not per-channel
05:13:02 <AmJa> ya they are
05:13:20 <AmJa> well this is what I have to do http://www.cs.ryerson.ca/dhamelin/cps118/labs/manual.html (before the lab portion) 
05:13:33 <Saizan> you can set a password for a single channel, but i'm pretty sure that's not the case for #c
05:13:38 <AmJa> I'm stuck on the void reverse section
05:13:46 <AmJa> how do i write the function
05:13:54 <Botje> AmJa: did you mean that you forgot your nickserv password?
05:13:55 <Saizan> otoh, #haskell doesn't require users to be identified to the server
05:13:59 <AmJa> yes
05:14:04 <Botje> because ##c probably doesn't let unidentified people in.
05:14:10 <Botje> have you tried /msg nickserv help?
05:14:12 <AmJa> yes
05:14:18 <Botje> i'm pretty certain there's a recover command
05:14:19 <Zao> ( http://blogs.msdn.com/b/michkap/archive/2006/10/11/816996.aspx ) <- why UTF-8 and A APIs don't match, for whoever cares :D
05:14:41 <medfly> AmJa, the link is bad.
05:14:47 <medfly> AmJa, need to specify more.
05:14:47 <Zao> Botje: And if you've lost your mail and all, I'm sure that a gullible staffer can help.
05:14:51 <monadic_kid> AmJa: did you attempt to solve the problem first?
05:15:08 <AmJa> wrong link one se
05:15:09 <AmJa> c
05:15:35 <AmJa> the correct link:http://www.cs.ryerson.ca/dhamelin/cps118/labs/lab08.html
05:16:15 <AmJa> monadic_kid: Yes i did, so far i finished the portion where The program asks for the word 
05:16:18 <Zao> Write a Haskell program that solves it. Then compile to .hc
05:16:24 <Zao> :D
05:16:27 <nostrand> Zao: :D
05:16:32 <AmJa> but I'm stuck at the part where the program checks for it
05:16:45 <AmJa> for whether its a palindrome or not
05:16:48 <Zao> What approach do you use then?
05:17:00 <Zao> In words.
05:17:06 <monadic_kid> best thing to do is ask people what are you stuck with, don't expect us to do your homework for you
05:17:22 <AmJa> THATs exactly what i just said
05:17:32 <AmJa> I don't understand how the reverse function works
05:17:37 <monadic_kid> no you asked us how to write it
05:18:01 <Zao> The `reverse' function works in whatever way you write it.
05:18:03 <AmJa> [08:16] <AmJa> but I'm stuck at the part where the program checks for it 
05:18:26 <Zao> You seem to be conflating task 3 and task 4.
05:19:07 <AmJa> but they want us to write it this way void reverse (char before[], char after[]).... but i don't know what after[] is? how can it be an intial variable
05:19:22 <Botje> it's a buffer.
05:19:38 <AmJa> buffer?
05:19:39 <Zao> AmJa: See it as void f(char* src, char* dst)
05:19:43 <Botje> and this really belongs in ##c ..
05:19:56 <Zao> Arrays degenerate rather easily to pointers, and that's how the function parameters really work.
05:19:57 <mornfall> Where's the lift in transformers?
05:20:03 <mornfall> -the
05:20:20 <Zao> @hoogle lift
05:20:21 <lambdabot> Control.Monad.Trans lift :: (MonadTrans t, Monad m) => m a -> t m a
05:20:21 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
05:20:21 <lambdabot> Language.Haskell.TH.Syntax lift :: Lift t => t -> Q Exp
05:20:42 <AmJa> ok so its a buffer but why would you need it there?
05:20:44 <Zao> AmJa: Also, solve your ##c problem.
05:20:54 <Zao> AmJa: Because it's where you write your reversed string, as your spec says.
05:21:13 <Zao> While you can reverse a string in-place, the spec seems to want you to have an output array.
05:21:45 <mornfall> Zao: Yeah, but C.M.T is in mtl but not in transformers?
05:21:57 <Zao> char const* src = "rofl"; char dst[5] = {0}; reverse(src, dst); printf("%s", dst);
05:22:04 <Zao> mornfall: Ah, you meant the package.
05:22:21 <Zao> mornfall: I'd fetch the source and grep, heh.
05:22:51 <AmJa> <Zao> so what does that do
05:23:21 <monadic_kid> mornfall: transformers has all the monad transformers data types, the type-classes using FD are monads-fd (mtl 2.0)
05:23:22 <nostrand> mornfall: Control.Monad.Trans.Class
05:23:52 <Zao> AmJa: You should be able to understand that snippet showing how to call it.
05:24:11 <Zao> AmJa: Also, do not use <Name> to target someone, as it looks like you're quoting what someone said.
05:24:12 <AmJa> why did you give dst a size of 5
05:24:22 <Zao> AmJa: Also, solve your ##c problem. This is horribly off topic.
05:24:32 <Zao> AmJa: Because "rofl" is five chars.
05:25:08 <AmJa> there is a Nickserv command that resets your password but it requires you to enter <Username> <authe> <Email> i don't know what the middle parameter is for
05:25:26 <Botje> it's the code you received when you set up your password
05:25:40 <AmJa> well i did try that one but it didn't work
05:25:51 <mornfall> nostrand: Ah, thanks.
05:26:01 <Botje> then create amJa_ or something and register that..
05:26:04 <Zao> AmJa: Did you try the freenode support channel, or ask a staffer?
05:26:35 <ManateeLazyCat> Zao: IIRC, i remember you create linux package about process, what is it?
05:26:38 <AmJa> im not using an actual IRC client
05:26:42 <AmJa> i use a website
05:26:45 <AmJa> called gogloom
05:26:53 <Zao> ManateeLazyCat: Probably someone else.
05:26:57 <AmJa> and it wont let me logout of AmJa
05:27:11 <AmJa> and it wont let me log out of my username
05:27:15 <AmJa> so I can make another one
05:27:29 <Botje> then get a real irc client or ask staffers to reset your password :/
05:27:37 <ManateeLazyCat> Zao: Oh, my bad, is zygoloid
05:27:39 <Zao> They won't bite. Much :D
05:27:40 <Saizan> AmJa: http://webchat.freenode.net/
05:27:51 <Botje> Saizan: i think ##c bans those
05:28:00 <Zao> Botje: Works for hugging a staffer though.
05:28:02 <nostrand> mornfall: =)
05:28:06 <Zao> Or doing other account-related stuff.
05:28:15 <ManateeLazyCat> @hoogle linux-ptrace
05:28:15 <lambdabot> No results found
05:28:21 <ManateeLazyCat> @package linux-ptrace
05:28:22 <lambdabot> http://hackage.haskell.org/package/linux-ptrace
05:28:31 <Botje> hmm, maybe not
05:28:34 <ManateeLazyCat> Oh, yes, is above package.
05:28:42 <Botje> #perl has a lot more bans than they do :)
05:28:45 <Rutix> Why would you ban webchat?
05:28:46 <Zao> ManateeLazyCat: Geordi uses some kind of ptrace, but I'm unsure if that's in a separate package or self-hacked.
05:29:05 <Zao> Rutix: The recent drone spree, trolls in general, etc.
05:29:21 <Rutix> Well thats possible without webchat too :P
05:30:00 <Rutix> Ah well qwebirc allows you to get a mask anyway so it isnt that bad to just ban general webchat
05:30:33 <ManateeLazyCat> Zao: ptrace looks very interested.
05:31:07 <ManateeLazyCat> I will play linux-ptrace when i have spare time. :)
05:31:41 <mornfall> nostrand: Hm. Or maybe I am supposed to be using mtl 2 afterall?
05:32:20 <nostrand> mornfall: i have no idea :P
05:34:13 <monadic_kid> mornfall: mtl2 is transformers + monads-fd
05:34:46 <mornfall> monadic_kid: I figured now. Great, thanks. :)
05:35:35 * mornfall goes on to recompile all of his installed packages.
05:36:21 <ManateeLazyCat> Use ptrace can modified running program....
05:38:13 <Mitar> i have a problem with haskell making types more strict than necessary
05:38:14 <Mitar> http://hpaste.org/41241/types
05:38:43 <Mitar> i would like to use different types in a for list, but all with same properties
05:38:48 <Mitar> and call the same function on  them
05:38:59 <Mitar> if i have single element in a list it works
05:39:26 <quantumboy> Hi all, could you connect the haskell.org? why cant I. the site have some problem?
05:39:30 <Mitar> but if i have multiple elements, it does not, because they do not have exactly the same type, but they do fulfil constraints
05:39:37 <Mitar> yes, it is down
05:39:48 <ManateeLazyCat> quantumboy: haskell.org is down
05:39:58 <hpc> the server is up, but the site is definitely down
05:39:58 <Nibble> it absolutely sucks
05:40:30 <quantumboy> ok, thankes , its a bad news
05:40:49 <monadic_kid> quantumboy: looking for docs for packages?
05:41:02 <Zao> Mitar: Are the set of types bounded?
05:41:21 <Zao> If so, make a list of the type   OneOf A B C D E
05:41:32 <ManateeLazyCat> Thanks god, i can push patches to haskell.org
05:41:33 <Zao> Or make an existential wrapper and have a suitable typeclass for your function.
05:41:43 <dschoepe> Mitar: you can use existential types if you want the list to consist of different types that are in a particular typeclass
05:41:52 <hpc> ManateeLazyCat: server is up, and telnet can still connect to that port; it just doesn't reply
05:42:10 <Mitar> the problem is that if I use existential types I cannot unpack them
05:42:13 <ManateeLazyCat> hpc: Why haven't mirror server?
05:42:24 <pkrumins> for some crazy reason I am suddenly getting 'Could not find module `Graphics.Win32.Windows`
05:42:34 <pkrumins> it works in the other program, but not in this test program
05:42:36 <hpc> ManateeLazyCat: no idea
05:42:47 <Mitar> i want it to be generic/extendable, defining OneOf is a no option
05:42:49 <hpc> perhaps it is being DoS'd
05:43:01 <dschoepe> Mitar: well, you can only apply the type-class methods to the values, all the other type information is erased
05:43:09 <ManateeLazyCat> hpc: c.h.o break my heart, i put all  my code on patch-tag.com
05:43:56 <Mitar> yes, i need value specific type information
05:44:05 <Mitar> so it works if I have manually
05:44:36 <monadic_kid> which xml package comes with the platform?
05:44:40 <Mitar> if I list manually translateAndSend calls each by each, but now I want to make a wrapper function, which would do that, so I opted for a list
05:44:43 <quantumboy> monadic_kid: yes I need the haskell staff for the program design and global struct template like a example skelton
05:45:11 <dschoepe> Mitar: Perhaps you could move the type-specific bits you need into the type class?
05:46:43 <Mitar> i just want to refactor some code: http://hpaste.org/41244/before
05:46:54 <Mitar> this is what I wish to accomplish
05:51:27 <hpc> :t sequence_
05:51:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
05:52:43 <hpc> Mitar: perhaps this:
05:52:45 <hpc> propogate act args = do
05:52:46 <hpc>   _ <- divideNeuron options $ forever $ do
05:52:48 <hpc>     capture <- getFromNeuron nerveCapture
05:52:50 <hpc>     sequence_ (args <*> [act])
05:53:26 <Mitar> let me dive into this ;-)
05:53:37 <hpc> or something similar; dunno the type of translateAndSend
05:53:40 <hpc> :t sequence
05:53:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
05:53:46 <Mitar> it is in the first paste
05:53:50 <Mitar> type
05:54:01 <Mitar> http://hpaste.org/41241/types
05:54:13 <hpc> oh, yay; mine will work then
05:55:06 <hpc> :t \f g -> f <*> [g]
05:55:07 <lambdabot> forall a b. [a -> b] -> a -> [b]
05:55:37 <Mitar> i think there is something wrong? you use nerveCapture and do not use resulting capture?
05:56:05 <hpc> oh, herp derp
05:57:15 <Mitar> ;-)
05:57:48 <hpc> propogate act args = do
05:57:50 <hpc>   _ <- divideNeuron options $ forever $ do
05:57:51 <hpc>     capture <- getFromNeuron act
05:57:53 <hpc>     sequence_ (args <*> [capture])
05:58:26 <hpc> perhaps replace "capture" with something more generic
05:58:38 <Mitar> of course ;-)
05:58:59 <Mitar> but where is translateAndSend?
05:59:34 <hpc> translateAndSend <$> args <*> [capture]
05:59:36 <hpc> <.<
06:00:23 <hpc> oh, also get rid of '_ <-'
06:00:31 <hpc> or it won't be a valid do block
06:00:40 * hpc is still asleep, clearly
06:01:23 <Mitar> where are <$> and <*> defined?
06:02:03 <ManateeL`> Mitar: Control.Applicative
06:02:11 <ManateeL`> @hoogle (<$>)
06:02:11 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
06:02:18 <ManateeL`> @hoogle (<*>)
06:02:18 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
06:02:35 <Mitar> ok, let me see this magic
06:03:07 <ManateeL`> Mitar: <$> <*> avoid you write temporary variable for constructor.
06:03:19 <hpc> (<$>) = fmap
06:03:24 <hpc> (<*>) = magic
06:03:28 <Mitar> hmm
06:03:34 <Mitar> but this magic does not help me now
06:03:36 <Mitar> i get the same error
06:03:45 <hpc> > [succ, id] <*> [1,2,3]
06:03:45 <lambdabot>   [2,3,4,1,2,3]
06:03:54 <Jafet> @remember hpc (<$>) = fmap; (<*>) = magic
06:03:54 <lambdabot> I will never forget.
06:04:03 <hpc> :D
06:04:13 <Mitar> types still does not work out
06:04:25 <Mitar> it still says that first element of the list does not match the second
06:04:55 <Mitar> http://hpaste.org/paste/41241/try#p41245
06:04:59 <Mitar> this is what i am trying
06:05:49 <pkrumins> Zao: still around?
06:06:49 <pkrumins> Zao: I got that piece working and I am wondering how to test if the returned HWND is actually a HWND or is it null pointer
06:06:59 <hpc> Mitar: look at the types of nerveNXT nerveTarget nerveX11 nerveCapture
06:07:06 <Saizan> Mitar: can you annotate with the error you're getting an the types of some of the definitions?
06:07:18 <pkrumins> since the return type now is IO HWND and not IO (Maybe HWND)
06:07:24 <hpc> they should be the same, or this will be significantly harder to abstract out
06:07:28 <Mitar> sure
06:07:35 <Mitar> they are not the same
06:07:35 <pkrumins> let's see, you mentioned ptrToMaybe
06:07:36 <Mitar> this is problem
06:07:59 <pkrumins> aha, gonna lift ptrToMaybe in the IO monad
06:07:59 <Zao> pkrumins: It returns NULL or a valid HWND.
06:08:02 <hpc> yeah, i don't know enough to help then :(
06:08:09 <Zao> pkrumins: ptrToMaybe, from System.Win32.Types.
06:08:14 <Saizan> Mitar: you can only build a list of things if they all have the same type
06:08:20 <Zao> Indeed.
06:08:25 <pkrumins> thanks!
06:08:48 <pkrumins> if this works i will get this program running pretty quickly
06:08:57 <Saizan> Mitar: otherwise you'll need to wrap them in a tagged union type, or an existential type if you only care that they are all members of some typeclass
06:08:58 <pkrumins> which will be very awesome
06:09:04 <Mitar> yes, they do not have
06:09:17 <Mitar> but they do all satisfy the same conditions
06:09:25 <Mitar> so if I call one after another in a do construct
06:09:27 <Mitar> things work
06:09:32 <Saizan> ok
06:09:34 <Mitar> I just want to move that into the function
06:09:39 <Mitar> http://hpaste.org/paste/41241/error#p41246
06:10:29 <Mitar> so you can understand this like: I have some input Chans and some output Chans, I have a class which defines how I can translate between input and output Chan's values
06:10:33 <Heffalump> what's actually wrong with the c.h.o webserver?
06:11:02 <Saizan> Mitar: that error refers to nerveTarget, but there's no nerveTarget in the code you pasted
06:11:05 <Mitar> and now I want to make a function which takes one Chan in and list of multiple out Chans and for each combination translate and send from input to output
06:11:35 <mornfall> Spot 2 differences... http://pastebin.dqd.cz/v2T7/
06:12:30 <Saizan> Mitar: and the problem is that these out chans have different types, right?
06:12:31 <Mitar> more code: http://hpaste.org/paste/41241/more_types#p41247
06:12:34 <Mitar> yes
06:12:42 <Mitar> but because of that i have a type class
06:12:49 <mornfall> Ah, there's a prime!
06:12:52 <mornfall> I suck.
06:12:57 <Mitar> which translates between those element types
06:13:42 <Mitar> translate is simply: http://hpaste.org/paste/41241/translate#p41248
06:14:44 <Mitar> maybe I should make a test case
06:15:45 <Saizan> Mitar: ok, then afaiu, propagate shouldn't take directly a list of Nerve's, it should take a list of some existential wrapper over Nerve that includes the ImpulseTranslator context
06:15:46 <hpc> mornfall: haha, wow
06:16:07 <Saizan> Mitar: then you can say e.g. "propagate nerveCapture [Wrap nerveX11, Wrap nerveTarget]"
06:16:28 <Mitar> but at the end i want to get unwrapped value
06:17:00 * hackagebot snap-core 0.2.15.1 - Snap: A Haskell Web Framework (Core)  http://hackage.haskell.org/package/snap-core-0.2.15.1 (GregoryCollins)
06:17:04 <Saizan> well, maybe you can unwrap after translation?
06:17:37 <Saizan> anyhow, this whole setup seems extremely overengineered
06:18:58 <Saizan> or maybe isntead of wrapping you could apply the translation
06:20:13 <Mitar> probably it really is overengineered ;-)
06:20:19 <Mitar> i am not yet in phase of simplification
06:21:18 <pkrumins> Zao: it works!
06:21:26 <pkrumins> Zao: can get the hwnd of the window!
06:21:41 <pkrumins> based on window class name
06:22:01 * hackagebot snap-server 0.2.15.1 - A fast, iteratee-based, epoll-enabled web server for the Snap Framework  http://hackage.haskell.org/package/snap-server-0.2.15.1 (GregoryCollins)
06:22:05 <pkrumins> Zao: do you happen to know how to find ALL windows with the given window class? Since several windows can have the same window class?
06:22:16 <Mitar> @hoogle forever
06:22:17 <lambdabot> Control.Monad forever :: Monad m => m a -> m b
06:22:25 <pkrumins> Zao: whould I enumerate windows and check each one's window class?
06:22:32 <ManateeLazyCat> Anyone can access http://code.haskell.org/gtk2hs?
06:22:37 <ManateeLazyCat> I can't pull code now.
06:23:16 <hpc> oh right, you can use const to escape from forever...
06:23:28 <FunctorSalad_> is there some way to zoom with vacuum-opengl?
06:24:43 <Zao> pkrumins: Enumeration is most probably the right route, yes.
06:25:03 <ezyang> Mrr, is haskell.org still down 
06:25:26 <ManateeLazyCat> ezyang: Yes, too bad to me.
06:25:33 <dons> ezyang: back up now.
06:25:34 <ManateeLazyCat> ezyang: I want pull last patches.
06:25:46 <ezyang> oh hey, it is back up now. 
06:25:50 <dons> code.haskell.org is still slow. but haskell.org is up.
06:25:50 <ezyang> \o/ 
06:25:59 <ezyang> Time to submit more GHC patches then :^) 
06:26:16 <pkrumins> Zao: thanks!
06:26:23 <ManateeLazyCat> dons: Can you access code.haskell.org, I want pull last patches (from Axel) to release gtk2hs-0.12.0
06:27:41 <dons> ManateeLazyCat: you can pull via ssh
06:27:53 <dons> just not easily over http (since apache is screwed up)
06:27:54 <ManateeLazyCat> dons: I forgot my ssh password. :(
06:27:59 <dons> we're not sure why the apache is bad.
06:28:12 <dons> but we're moving the entire machine soon
06:29:16 <ManateeLazyCat> dons: Looks http://www.gtk.org/language-bindings.html and search Haskell. :)
06:29:39 * ManateeLazyCat Ok, waiting Axel's patches mail. 
06:30:59 <Mitar> here is simplified version: http://hpaste.org/41249/simplified
06:31:04 * hackagebot HRay 1.2.2 - Haskell raytracer  http://hackage.haskell.org/package/HRay-1.2.2 (KennethHoste)
06:31:07 <Mitar> without all that balast of my types ;-)
06:31:35 <dons> woo!
06:31:39 <Gracenotes> hm.. what's the syntax for package-qualified import? :o
06:32:11 <Gracenotes> parser error.. mumble mumble
06:32:12 <hpc> import "network" Network.Socket
06:32:19 <hpc> with -XPackageImports
06:32:21 <Nibble> what the fuuuck
06:32:44 <hpc> Gracenotes: ^^
06:32:55 <Gracenotes> Error in mtl is biting me >.>
06:32:56 <ManateeLazyCat> Oh, i remember : darcs get AndyStewart@code.haskell.org:/srv/code/gtk2hs  work.
06:33:16 <dons> ddarius: you could respond to the parsec 3 proposal now thiings are working
06:33:21 <pkrumins> Is there a common typing convention for values which are Maybe?
06:33:24 <Gracenotes> waiting for transformers :)
06:33:29 <ManateeLazyCat> dons: Thanks for noticed, i can get gtk2hs from haskell.org.
06:33:35 <dons> ah ok.
06:33:37 <hpc> pkrumins: eh?
06:34:01 <pkrumins> I am asking because of this: let val = FnThatReturnsMaybe; case val of \n Just val2 -> ...
06:34:03 <Mitar> saizan: so any suggestion how could I wrap things here: http://hpaste.org/41249/simplified
06:34:12 <hpc> :t maybe
06:34:13 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:34:16 <hpc> pkrumins: ^^
06:34:20 <pkrumins> see I have val which is Maybe, and then when I do case val of, I have to come up with a new name for the val
06:34:41 <hpc> also, Maybe is a monad
06:34:59 <pkrumins> hpc, how would I use 'maybe'?
06:35:02 <hpc> > do x <- Just 5; y <- Nothing; return (x+y);
06:35:03 <lambdabot>   Nothing
06:35:18 <hpc> > maybe 5 (const 4) Nothing
06:35:19 <lambdabot>   5
06:35:45 <pkrumins> i see.
06:35:46 <hpc> > maybe 5 (join (*)) (Just 4)
06:35:47 <lambdabot>   16
06:35:53 <Saizan> Mitar: give me a sec
06:36:25 <hpc> Maybe is one of the most fleshed-out monads
06:37:19 <ezyang> there's not very much to it... 
06:37:59 <hpc> ezyang: i mean, in terms of the ratio of functions already defined to functions you want to define
06:38:09 <pkrumins> well i was just asking about naming convention actually
06:38:10 <Heffalump> dons: re moving code.haskell, when is soon? hours/days/weeks?
06:38:33 <pkrumins> maybe there is no problem ;)
06:38:33 <ezyang> hpc: Yes. So being compact is helpful :-) 
06:38:54 <hpc> pkrumins: probably; just use the name that fits best
06:39:09 <Saizan> Mitar: http://hpaste.org/paste/41249/sink#p41250
06:39:12 <pkrumins> but you saw what my point was, right?
06:39:39 <hpc> pkrumins: the only really popular naming conventions are "generic variables are generally single-letter" and "lists are generally matched in the form (x:xs)"
06:39:57 <pkrumins> there is also this monadic convention of underscore _
06:40:05 <hpc> and M and '
06:40:11 <pkrumins> aha yes.
06:40:19 <pkrumins> got it.
06:40:23 <hpc> so, there's a fair few then :P
06:40:37 <aavogt> is there a wiki page of them?
06:41:05 <Mitar> seizan: it compiles!
06:41:06 <hpc> should there be? it seems to be something people notice eventually
06:41:15 <hpc> or they come here :P
06:41:20 <raichoo> Mitar: ship it!
06:41:21 <raichoo> :P
06:41:40 <dons> Heffalump: days i think.
06:41:44 <dons> Igloo has the vpn running
06:41:58 <Saizan> Mitar: yep!
06:41:59 <hpc> #haskell needs to stop being interesting so i can finally implement cookies today
06:42:24 <Heffalump> dons: ok, thanks. I want to get a trac going for HTTP; I'll wait for the move I think.
06:42:49 <Mitar> but isn't unwrapping of extensiensals forbidden?
06:42:52 <Heffalump> So, HTTP 4000 has support for defining your own transport datatype. Has anyone ever used this?
06:43:17 <hpc> Mitar: typeclass constraints enable you to operate on them
06:43:20 <hpc> iirc
06:43:22 <Heffalump> (i.e. it's overloaded over whether the data comes in as ByteString etc)
06:43:34 <hpc> so you could fmap over an existential functor
06:43:52 <Saizan> Mitar: what's forbidden is asking for the concrete type they are wrapping, i.e. you wouldn't be able to recover the identity of the 'b' type there
06:44:14 <Saizan> Mitar: but you can still use methods from the Translator typeclass
06:44:17 <hpc> Heffalump: that looks like premature generalization, to me
06:44:20 <Mitar> hm, but translate function does need to know concrete type?
06:44:40 <Mitar> so I will be still able to pattern match inside translate function?
06:44:47 <Saizan> Mitar: no, i just needs to know that you've a Tranlator context for it
06:45:19 <Saizan> ah, wait, translateAndSend only needs the Translator context
06:45:41 <Heffalump> hpc: well, it does overload over strict and lazy bytestrings, at least.
06:45:42 <Saizan> in the instance of Tranlator where you define the implementation of translate you do know the type
06:46:02 <Heffalump> (and String)
06:46:08 * hackagebot HRay 1.2.3 - Haskell raytracer  http://hackage.haskell.org/package/HRay-1.2.3 (KennethHoste)
06:46:19 <Heffalump> I'm not sure it's useful for it to be exposed outside ByteString, though. And the interface you have to implement seems rather fiddly.
06:46:26 <Saizan> Mitar: "instance Translator Foo Baz where translate _ = [Baz]" wouldn't work if you didn't know that j = Baz there
06:46:30 <Mitar> ok, but when I will read from sink Chans I will get normal types out
06:46:46 <Saizan> Mitar: yep
06:47:01 <Saizan> well
06:47:12 <Mitar> this seems to me like unwrapping ;-)
06:47:14 <Saizan> only if you read directly from e.g. chanBar
06:47:28 <Saizan> if you first wrap chanBar in Sink, then you took it outside
06:47:41 <Mitar> yes, i understand that
06:47:43 <Saizan> at that point you won't be able to know that you should expect a Bar
06:47:50 <Mitar> yes
06:48:19 <Mitar> but if I keep chanBar around and read from it, that it doesn't matter that I wrapped it up somewhere else, just to fix on Translator context and then translate
06:48:30 <Saizan> right
06:48:32 <Mitar> because the only thing I was able to do is Translate, so this is OK in that context
06:48:46 <Mitar> but for original chanBar that context does not matter
06:49:22 <Saizan> yep, since the type system still ensurers that only Bar's will be written inside that Chan
06:49:41 <Saizan> even if the code of propagate doesn't really know what types are floating around
06:49:56 <Saizan> *ensures
06:50:30 <Mitar> yes, and only Bar will be written because this is result of translating e
06:51:04 <Saizan> yep, and because when you apply the Sink constructor it packs the information from the Translator Foo Bar instance
06:51:08 <dons> Heffalump: Igloo's working on it.
06:51:12 <Mitar> now I just have to understand this type signature: Chan a -> [Sink a]
06:51:17 <Igloo> What am I working on?
06:51:21 <Mitar> why a in both places
06:51:43 <Heffalump> are you fixing HTTP? That'd be great ;-)
06:51:52 <Heffalump> (I think dons means code.haskell.org)
06:52:20 <dons> hehe
06:52:26 <Saizan> Mitar: because the 'a' in Sink tells us that these are Sink's that accept messages that can be translated from an 'a'
06:52:48 <Heffalump> can anyone suggest an easier way to inspect how things that depend on package foo are using it, than just downloading the whole lot and reading/grepping the code?
06:52:58 * Igloo isn't actively working on it, but I got it a significant step closer to being done yesterday
06:53:03 <Heffalump> In this case there are 88 direct dependencies so it's not going to be fun,.
06:53:21 <Igloo> tibbe is writing or has written a tool
06:53:26 <Igloo> I'm not sure what the status of it is
06:53:31 <pkrumins> Zao: you ever seens this - I am sending WM_CLOSE to a given hwnd and I get access denied errors.
06:56:54 <Mitar> saizan: OK, i will have to go over that a few times, thanks for everything!
06:57:52 <Saizan> Mitar: np :)
07:00:11 * hackagebot gtk2hs-buildtools 0.12.0 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.0 (AndyStewart)
07:00:13 * hackagebot glib 0.12.0 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.0 (AndyStewart)
07:00:15 * hackagebot gio 0.12.0 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.12.0 (AndyStewart)
07:01:12 * hackagebot pango 0.12.0 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.12.0 (AndyStewart)
07:01:14 * hackagebot cairo 0.12.0 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.0 (AndyStewart)
07:01:15 <luite> yay new gtk2hs, is there a changelog?
07:01:24 <ManateeLazyCat> Check darcs changes.
07:01:33 <ManateeLazyCat> luite: Update to GTK+ 2.22
07:01:45 <luite> cool
07:03:13 * hackagebot gtk 0.12.0 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.0 (AndyStewart)
07:03:15 * hackagebot glade 0.12.0 - Binding to the glade library.  http://hackage.haskell.org/package/glade-0.12.0 (AndyStewart)
07:03:17 * hackagebot gstreamer 0.12.0 - Binding to the GStreamer open source multimedia framework.  http://hackage.haskell.org/package/gstreamer-0.12.0 (AndyStewart)
07:03:42 <luite> hmm, the repository seems to be a bit down
07:04:14 * hackagebot gtkglext 0.12.0 - Binding to the GTK+ OpenGL Extension  http://hackage.haskell.org/package/gtkglext-0.12.0 (AndyStewart)
07:04:42 <boegel> for those of you not here: BelHac in action: http://www.youtube.com/watch?v=nvR3ZOvdz0M
07:05:14 * hackagebot svgcairo 0.12.0 - Binding to the libsvg-cairo library.  http://hackage.haskell.org/package/svgcairo-0.12.0 (AndyStewart)
07:06:16 * hackagebot vte 0.12.0 - Binding to the VTE library.  http://hackage.haskell.org/package/vte-0.12.0 (AndyStewart)
07:06:18 * hackagebot gconf 0.12.0 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.12.0 (AndyStewart)
07:06:20 * hackagebot gtkimageview 0.12.0 - Binding to the GtkImageView library.  http://hackage.haskell.org/package/gtkimageview-0.12.0 (AndyStewart)
07:07:08 <Twey> Heh, 100% male :-\
07:07:15 * hackagebot gtksourceview2 0.12.2 - Binding to the GtkSourceView library.  http://hackage.haskell.org/package/gtksourceview2-0.12.2 (AndyStewart)
07:07:17 * hackagebot poppler 0.12.0 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.12.0 (AndyStewart)
07:07:51 <hpc> holy crap
07:08:42 <Twey> I live for the day when CS is an equal-opportunity profession :-\  I don't get or like the bond between tech and testes
07:09:15 * hackagebot webkit 0.12.0 - Binding to the Webkit library.  http://hackage.haskell.org/package/webkit-0.12.0 (AndyStewart)
07:09:30 <ManateeLazyCat> Ok, enjoy all! :)
07:09:35 <dons> nice!
07:09:40 <hpc> Twey: having a penis has not helped me one bit; it isn't even easy to type with!
07:09:41 <ManateeLazyCat> Any bug in above packages can report to me. :)
07:09:57 <Twey> hpc: Haha
07:09:58 <ManateeLazyCat> gtk2hs-0.12.0 is *big* change!
07:10:06 <Twey> It's cool to see so many Haskellers, though.
07:10:14 <ManateeLazyCat> gtk2hs-0.12.0 support all GTK+ APIs from GTK+2.8 ~ GTK+2.20
07:10:16 * hackagebot monads-fd 0.2.0.0 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/monads-fd-0.2.0.0 (RossPaterson)
07:10:16 <ManateeLazyCat> gtk2hs-0.12.0 support all GTK+ APIs from GTK+2.8 ~ GTK+2.23
07:10:23 <ManateeLazyCat> gtk2hs-0.12.0 support all GTK+ APIs from GTK+2.8 ~ GTK+2.22
07:10:30 <ManateeLazyCat> Is GTK+2.22
07:10:33 <Jafet> hpc: is it *->* ?
07:10:41 <ManateeLazyCat> And include newest GIO library (cross-platform file APIs).
07:10:49 <hpc> Jafet: *facepalm*
07:10:57 <hpc> Jafet: nice pun
07:11:16 * hackagebot monads-fd 0.1.0.4 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/monads-fd-0.1.0.4 (RossPaterson)
07:11:49 <ManateeLazyCat> All gtk2hs-base library have fix many *memory leak* we found in GObject binding.
07:12:01 <ManateeLazyCat> So i recommend all gtk2hs user update those packages.
07:12:10 <ManateeLazyCat> My friend have test it on Windows, works fine.
07:12:32 <ManateeLazyCat> I don't know Mac, but i know no problem on Linux and Windows.
07:12:46 <hpc> mac shouldn't see problems if it works on linux
07:12:50 <ManateeLazyCat> Of course, so many new APIs add in gtk2hs-0.12.0, any bug are welcome!
07:13:02 <ManateeLazyCat> hpc: I haven't test it since i haven't Mac.
07:14:07 <ManateeLazyCat> gtk2hs-0.12.0 binding is very complete except some APIs not binding that Haskell library can do better, such as Network APIs.
07:14:32 <ManateeLazyCat> Look http://www.gtk.org/language-bindings.html for details.
07:15:10 <ManateeLazyCat> We also fix some "segfault bug" in new version with (Maybe argument), so gtk2hs-0.12.0 maybe break your program. 
07:15:27 <ManateeLazyCat> But not worried, it's easy to fix by add 'Just' wrap.
07:15:43 <hpc> you should see if you can get gtk2hs to be one of the official bindings
07:16:27 <ManateeLazyCat> hpc: Oh, gtk2hs is not the official bindings.
07:16:51 <hpc> ManateeLazyCat: yeah; talk to the gtk people and see if it can be
07:17:18 * hackagebot haskell-src 1.0.1.4 - Support for manipulating Haskell source code  http://hackage.haskell.org/package/haskell-src-1.0.1.4 (DonaldStewart)
07:18:54 <ManateeLazyCat> hpc: We haven't Haskell library to parse "GObject introspection" like other language.
07:19:14 <hpc> ah, k
07:19:54 <ManateeLazyCat> hpc: We use semiautomatic tool and tweak by hand.
07:20:39 <ManateeLazyCat> hpc: If someone develop "GObject introspection" library, it will make our life easier. :)
07:21:14 <ManateeLazyCat> hpc: BTW, i think most GTK people even haven't heard Haskell. :)
07:21:34 <hpc> haha
07:21:54 <hpc> GTK would be a great way to draw attention to us, i think
07:22:03 <hpc> then again, avoid success at all costs...
07:22:49 <monochrom> don't worry, drawing attention may imply avoiding success too
07:22:53 <ManateeLazyCat> hpc: I think GTK+ + Haskell concurrent thread is awesome. :)
07:23:12 <hpc> yeah, haskell threads make everything awesome
07:23:40 <mauke> hpc: I disagree
07:24:01 <hpc> mauke: i reject your reality and substitute my own
07:24:02 <dons> haskell threads make mauke awesome
07:24:07 <turiya> how to load two files in ghci, :l file1.hs file2.hs does not load the functions in the file2.hs..
07:24:16 <hpc> turiya: use import
07:24:32 <hpc> import File1; import File2
07:24:39 <mauke> preflex's code would be improved a lot by an event loop
07:25:54 <turiya> hpc, did not quite understand.. where do i use import?
07:26:06 <hpc> in ghci
07:26:23 <hpc> alternatively, use :m +
07:26:35 <hpc> and give your files module names
07:26:46 <monochrom> both file1.hs and file2.hs are Main modules? you can't do that.
07:28:01 <monochrom> echo 'module X where x=0' > X.hs
07:28:13 <monochrom> echo 'module Y where y=1' > Y.hs
07:28:24 <monochrom> now you can :l X.hs Y.hs
07:28:50 <turiya> monchrom, i did the same but somehow i can call the functions in Y.hs
07:28:50 <monochrom> now you ask for "y" and it says "not in scope". you infer that Y.hs is not loaded. wrong inference.
07:28:56 <dons> ManateeLazyCat: does gtk2hs build with GHC 7 ?
07:29:06 <monochrom> :m + Y
07:29:07 <ManateeLazyCat> dons: Yes, today i push new patch fix that.
07:29:11 <dons> yay!
07:29:16 <monochrom> now y is also visible
07:29:18 <ManateeLazyCat> dons: I have test, works fine.
07:29:42 <monochrom> scope /= loaded
07:29:57 * ManateeLazyCat Build new darcs2 format gtk2hs mirror repository at patch-tag.com avoid c.h.o down again.
07:30:09 <turiya> monochrom: i see, how does :m + Y work?
07:30:23 <dons> c.h.o is just very slow.
07:30:27 <dons> ssh still works
07:30:33 <monochrom> namespace thing
07:30:35 <dons> but yes, use things like github or patch-tag
07:31:00 <ManateeLazyCat> dons: I hope someday c.h.o can stable like patch-tag.com
07:31:13 <monochrom> the prompts "*X>" and "*X Y>" mean something.  see the docs.
07:31:14 <turiya> ok..
07:31:34 <dons> ManateeLazyCat: well, it should be replaced by patch-tag, I think.
07:31:46 <dons> it was from a long time ago, before github or patch-tag
07:32:21 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/interactive-evaluation.html#ghci-scope
07:33:22 <hpc> :t when
07:33:23 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
07:33:53 <Gracenotes> hm, is there a program using ghc module dependency dags to find out where a given instance is imported from?
07:36:04 <Heffalump> I don't have the feeling that patch-tag has particularly expensive or reliable infrastructure either :-/
07:36:06 <jmcarthur> heh, patch-tag is somewhat instable sometimes too
07:37:25 <mornfall> Yeah, unfortunately.
07:37:41 <aristid> github is pretty stable
07:37:59 <Heffalump> doesn't help us small band of darcs users :-)
07:38:05 <Heffalump> at least unless we get a really nice bridge
07:38:30 <monochrom> ghci :info finds out where a given instance is imported from.
07:38:40 <aristid> Heffalump: you could switch to git :P
07:39:05 <mornfall> aristid: Hush, you...
07:39:23 <monochrom> :info Int â‡’ "instance Show Int -- Defined in GHC.Show"
07:40:02 <monochrom> or :info Num if the instance type is not quite info-able
07:40:04 <Heffalump> aristid: at about the same time I switch to F# from Haskell, yeah
07:40:18 <mornfall> I have investigated a bit about marksfiles and it *seems* to be SMOP.
07:40:36 <dons> Heffalump: a nice github bridge would be a bit of a killer ap
07:40:40 <jmcarthur> i used to think git and darcs were basically just different languages to do the same thing, but i since learned that the difference is a bit more significant
07:40:42 <dons> well, "a bit of one"
07:40:56 <ManateeLazyCat> jmcarthur: Much stable than c.h.o. :)
07:40:58 <mornfall> Which means we aren't *that* far from talking to github.
07:40:59 <aristid> jmcarthur: how so?
07:41:06 <jmcarthur> so the thought of switching back to git again just doesn't appeal to me
07:41:21 <jmcarthur> aristid: darcs allows you to cherry pick almost whatever you want to
07:41:34 <Heffalump> mornfall: I'd like the darcs side to translate git merges nicely
07:41:41 <Heffalump> which I suspect is tricky
07:41:44 <jmcarthur> aristid: without having to screw up your repository's compatibility with other repos
07:41:52 <mornfall> (Of course, you are going to suffer some lossy conversion on both sides, but it should be good enough to do patch management using darcs for a git project.)
07:42:07 <Heffalump> I was rather shocked by how ugly the process of sending git patches by email is
07:42:13 <aristid> jmcarthur: git's cherry-pick command is not the most advanced, but it has worked well for me so far
07:42:23 <jmcarthur> aristid: have you used darcs much?
07:42:25 <stepcut> Heffalump: agreed
07:42:36 <aristid> jmcarthur: no. i don't find darcs appealing at all.
07:42:38 <jmcarthur> aristid: it's something you have to experience to understand, really
07:42:43 <jmcarthur> aristid: why not?
07:42:53 <mornfall> Heffalump: I would say that's pretty optional. Although it wouldn't be impossible, you still don't get much benefit from doing that, for the basic usecase.
07:42:59 <aristid> jmcarthur: i really like the git data model :)
07:43:02 <jmcarthur> aristid: i did too
07:43:24 <jmcarthur> i still do for certain reasons
07:43:32 <jmcarthur> but not for most of my projects
07:43:36 <aristid> jmcarthur: and with github i have a really good hosting service for all of my open source projects
07:43:46 <jmcarthur> github is probably the best reason to use git
07:43:50 <jmcarthur> the model, IMO, isn't
07:43:56 <EvanR> i use repo.or.cz
07:44:16 <aristid> jmcarthur: the git model IS good. maybe the darcs model is slightly better, but then, darcs is also a lot slower.
07:44:18 <stepcut> I used patch-tag :p
07:44:25 <jmcarthur> aristid: not so much anymore
07:44:30 <ManateeLazyCat> Looks so many haskeller use git, i still use darcs, it's enough for me. :)
07:44:40 <jmcarthur> aristid: darcs annotate is still slow... but that only affects you if you use that command... i don't really
07:44:46 <monochrom> I still use CVS
07:44:54 <jmcarthur> monochrom: willingly?
07:45:02 <monochrom> willingly
07:45:05 <FauxFaux> /o\
07:45:07 <aristid> jmcarthur: darcs build everything from a series of patches, right? my understanding of that is a bit superficial
07:45:11 <monochrom> \âˆ©/
07:45:21 <stepcut> jmcarthur: I think I saw something about making annotate fast being a high priority recently
07:45:24 * jmcarthur adds monochrom to his list of people that like CVS (there are now two people on it)
07:45:38 <jmcarthur> stepcut: yes, it's next in the plans
07:45:44 <ManateeLazyCat> jmcarthur: Another one?
07:45:55 <Heffalump> a couple of people (mornfall and beschmi) have been working on different aspects of making annotate fast
07:45:56 <aristid> jmcarthur: if i understand it correctly, git's model stores snapshots each time, and applies diffs basically as a compression technique, allowing it to make sure the patch chain does not become too long
07:45:59 <FauxFaux> You're all supposed to be advocating http://projects.haskell.org/camp , aren't you?  Wait, the website seems down.
07:46:30 <aristid> jmcarthur: i used to use monotone, and that had huge problems with its diff chains
07:46:42 <mornfall> aristid: There are no diff chains in git, actually. :)
07:46:51 <EvanR> aristid: well there is no patch chain in git
07:46:51 <FauxFaux> mornfall: Depends how you count the packfile compression.
07:46:58 <jmcarthur> aristid: yeah. basically, git uses diffs as a nicer way to do what people do without version control: backup copies
07:46:58 <aristid> EvanR: that's my point
07:47:00 <EvanR> its compressed just for space
07:47:03 <FauxFaux> aristid: I don't see how the storage is even remotely relevant; you can construct either from either.
07:47:20 <aristid> FauxFaux: you can, but does darcs do that?
07:47:30 <aristid> git's storage model brings performance
07:47:30 <jmcarthur> aristid: and git does some three way merge magic so you can merge versions
07:47:38 <mornfall> FauxFaux: That's not actually true. Patches capture strictly more info.
07:47:55 <FauxFaux> aristid: What, have the ability to reconstruct a given revision?  I should hope so.  (I'm a git user.)  Git's model utterly sucks as diff is hilariously cpu bound.
07:48:03 <jmcarthur> aristid: the darcs repo format is packed too, iirc, but i don't actually know much about it so i can't say
07:48:11 <stepcut> FauxFaux: the time required to convert from one format to another can be high when you have a lot of patches 
07:48:12 <aristid> FauxFaux: no, the ability to be fast
07:48:19 <jmcarthur> aristid: and that brings me to another point. one of the nice *and* not nice things about git is its exposed guts
07:48:32 <FauxFaux> mornfall: More info when they're applied..?  Do explain.
07:48:43 <aristid> jmcarthur: sometimes i wish they were more exposed so it would be more possible to build things on it :)
07:48:47 <mornfall> FauxFaux: Well, you can't capture a file rename with a series of snapshots.
07:48:56 <mornfall> FauxFaux: You can *guess* them. Which is what git does.
07:49:05 <EvanR> jmcarthur: worse is better! ;)
07:49:10 <FauxFaux> Mmm, true.  unified diffs don't support renames, though, do they?
07:49:13 <jmcarthur> EvanR: i hate that saying
07:49:18 <FauxFaux> Nor context diffs, literally the worst thing ever.
07:49:23 <jmcarthur> EvanR: simpler is better. not worse
07:49:26 <EvanR> also better is better
07:49:36 <EvanR> but its not as widely known
07:49:36 <jmcarthur> EvanR: *composable* is better
07:49:39 <jmcarthur> that's what most people mean
07:49:41 <jmcarthur> when they say either
07:49:46 <aristid> cheaper is better, too
07:50:03 <copumpkin> omnom
07:50:22 <EvanR> just switch between worse is better and better is better when you want to advocate something or apologize for something as the case may be
07:50:26 <monochrom> freedom is slavery
07:50:41 <jmcarthur> aristid: i can pull ghc without having a cache and without --lazy in 3 minutes now, and once i've done it once i can pull it in 3 seconds
07:51:03 <aristid> jmcarthur: well i don't know how long it would take with git :)
07:51:06 <jmcarthur> aristid: and clones are also 3 seconds
07:51:08 <FauxFaux> But git does support patch composition. Â¬_Â¬  http://pastie.org/1279298  Example from http://www.youtube.com/watch?v=iOGmwA5yBn0
07:51:12 <jmcarthur> aristid: git would probably be faster
07:51:22 <jmcarthur> aristid: but my point is that darcs is acceptably fast to me
07:51:28 * hackagebot minesweeper 0.9 - Minesweeper game which is always solvable without guessing  http://hackage.haskell.org/package/minesweeper-0.9 (PeterDivianszky)
07:51:37 <EvanR> cloning could be rather slow in git
07:51:37 <ManateeLazyCat> aristid: How long time if use git push 2569 patches?
07:51:40 <aristid> jmcarthur: and my point is, git has a pretty good data model, it is fast, and it has github :)
07:51:53 <EvanR> if the repo is bloated
07:52:02 <jmcarthur> aristid: i don't really care about git's data model... unless you mean its semantic model
07:52:02 <monochrom> I like CVS because there is no longer a need to debate over it.
07:52:17 <jmcarthur> aristid: in which case i very much like darcs model better :)
07:52:20 <ursthegizmo> Dear All, need help with GreenCard on Windows, is this library actively in use? Have troubles with the standard DIS, like Int, Fload, ... Message is "Don't know how to marshall ...
07:52:22 <aristid> jmcarthur: when i say data model i mean both the semantic and the storage model
07:52:35 <Vanadium> monochrom: is your name monochrome because your monitor is still such
07:52:39 <jmcarthur> aristid: it's saddening to me that those are the same thing in git
07:52:40 <FauxFaux> ManateeLazyCat: That depends on the size of the changes in the patches, not directly on the number of patches or anything.
07:52:40 <aristid> jmcarthur: well i don't really understand what's better about darcs' semantic model
07:52:43 <monochrom> GreenCard is not active.
07:53:06 <monochrom> my ink is monochrome
07:53:07 <jmcarthur> aristid: the darcs model allows you to treat patches as first class
07:53:18 <jmcarthur> aristid: git's it just glorified backups and mergings
07:53:19 <mornfall> monochrom: I actually like CVS because it's transparent. Stupid, broken but I know how it's going to break. Unlike git.
07:53:23 <jmcarthur> *is just
07:53:53 <aristid> jmcarthur: git trained me to stop thinking in terms of patches, and brought me benefits with that. i am psychologicaly trained to think that patches are not good :)
07:54:05 <jmcarthur> aristid: really, i think i could only make a good case with a few elaborate workflow examples, which i don't really want to get into right now ;\
07:54:08 <jmcarthur> :\
07:54:08 <EvanR> reminds me of 'i like oop because i just think that way'
07:54:10 <Vanadium> I generate patches from my git commits a lot :<
07:54:13 <Vanadium> Or rebase, or whatever
07:54:19 <jmcarthur> aristid: hm?
07:54:20 <ursthegizmo> By the way, I like Mercurial, its something like git but with Python background
07:54:23 <ursthegizmo> easy to use
07:54:25 <mornfall> aristid: You are probably wrong on that count, since git can't merge without using patches.
07:54:47 <jmcarthur> Vanadium: rebase makes your branch incompatible with other branches if you actually do any patch management with it
07:54:52 <mornfall> All text merges we have are based on patches...
07:54:52 <aristid> mornfall: well, it uses patches lazily :)
07:55:06 <Vanadium> oh well
07:55:09 <ursthegizmo> If GreenCard is not active, which FFI tool is, c2hs?
07:55:14 <EvanR> ursthegizmo: 'it uses dynamic language X in the background' is usually a warning that youre dwelling on something irrelevant
07:55:16 <mornfall> Well, gotta run. :)
07:55:24 <ManateeLazyCat> FauxFaux: I think number of patches is also a big factor of push time.
07:55:31 <mornfall> Will hack darcs-fastconvert on train.
07:55:32 <mornfall> -->
07:55:33 <jmcarthur> monochrom: git's merges doesn't actually use each diff as a patch though. it just generates two big patches as in a three way merge
07:55:45 <ManateeLazyCat> FauxFaux: Yes, size is big one.
07:55:52 <jmcarthur> arguably, that's actually a good thing
07:55:56 <monochrom> monochrom? mornfall?
07:55:56 <jmcarthur> but it comes with limitations
07:56:00 <aristid> EvanR: well, the benefits i get from git are real. and i don't understand enough about the theory to replace my empirical findings with robust theory
07:56:21 <jmcarthur> aristid: the real benefits i get from darcs are what convinced me to switch to it from git though
07:56:26 <jmcarthur> not the theoretical
07:56:32 <jmcarthur> the theory didn't convince me
07:56:40 <Vanadium> mercurial has slowly driven three or four git users on our project mad until each of them came up with a seperate solution to use git for their own work and only check in to the mercurial repository eventually
07:56:48 <roconnor> Was applicative introduce only in 2008?
07:56:49 <aristid> jmcarthur: don't the real benefits derive from some theoretical benefits?
07:56:59 <bos> mercurial and git are very very similar.
07:57:00 <EvanR> aristid: i manage a project at work on git, while i never have any problems, i infuriate the other developers when i explain the git command solutions ;)
07:57:00 <roconnor> Applicative Programming with Effects
07:57:01 <roconnor> Conor McBride and Ross Paterson. in Journal of Functional Programming 18:1 (2008), pages 1-13. 
07:57:07 <jmcarthur> aristid: they do, but i didn't not understand how i would get real benefit from that theory until i just used it for a while
07:57:14 <jmcarthur> *but i did not
07:57:17 <monochrom> not only in 2008. look for "idiom"
07:57:29 * hackagebot deepseq 1.1.0.2 - Deep evaluation of data structures  http://hackage.haskell.org/package/deepseq-1.1.0.2 (DonaldStewart)
07:58:29 <jmcarthur> aristid: here's a simple example though:   in darcs, you can work on two features simultaneously in the same branch with interleaved patches, then you can push all the patches for one feature upstream without pushing the others and without having to rebase or break compatibility with other branches
07:58:33 <Heffalump> jmcarthur: I think the two big patches and merges are an important difference with darcs
07:58:47 <EvanR> aristid: also they still dont get it really, they like to rebase wildly, and actions are taking to make the tree 'look nicer' despite the effects on the development workflow. maybe git really is too complex?
07:59:02 <aristid> EvanR: i avoid rebase. why don't they?
07:59:08 <nus> roconnor, Hughes, John. (2000). "Generalising monads to arrows."
07:59:22 <EvanR> because i told them about it as a way to fix their personal history *before* sharing it
07:59:26 <roconnor> nus: but thy didn't mention applicative then
07:59:27 <jmcarthur> EvanR: rebase is great when you understand the model
07:59:45 <EvanR> so it turned into 'share it' then rebase wildly
07:59:52 <jmcarthur> ugh
08:00:00 <Botje> because if you don't rebase, almost every commit becomes a merge
08:00:02 <aristid> EvanR: right, that's good advice when they know git well enough already ;)
08:00:05 <Botje> i guess :P
08:00:05 <jmcarthur> see, with darcs that would have been a non-issue
08:00:16 <ursthegizmo> Short question to all: what's the current main-stream FFI tool, to use for moderate sized interface? (350 C routines)? 
08:00:34 <ManateeLazyCat> Use darcs push 2569 patches time : 26m14.108s
08:00:43 <jmcarthur> ManateeLazyCat: :o
08:00:45 <aristid> jmcarthur: but then, maybe there are other issues you have when using darcs :)
08:00:52 <EvanR> jmcarthur: how so
08:00:52 <jmcarthur> aristid: there are
08:00:55 <aristid> ManateeLazyCat: 26 minutes is not fast :)
08:00:57 <jmcarthur> aristid: i miss git stash, for example
08:01:12 <jmcarthur> aristid: although there is an equivalent coming up soon i think
08:01:23 <aristid> jmcarthur: git stash is a dirty hack, but useful :D
08:01:29 <EvanR> no its not
08:01:33 <jmcarthur> i don't think it's a dirty hack
08:01:35 <ManateeLazyCat> aristid: Maybe real time is shorter, because i compile gtk2hs at same time.
08:01:46 <ManateeLazyCat> aristid: And yes, it not fast enough.
08:01:47 <jmcarthur> ManateeLazyCat: what was cpu time?
08:01:49 <jmcarthur> hmm
08:01:51 <jmcarthur> bad questions
08:01:54 <ManateeLazyCat> jmcarthur: 100%
08:01:54 <jmcarthur> *question
08:02:03 <FauxFaux> ManateeLazyCat: git clone --bare foo bar.git  0.00s user 0.00s system 2% cpu 0.178 total, 17k revisions, 300mb HEAD. Â¬_Â¬
08:02:05 <aristid> jmcarthur: well it bloats the semantic model of git
08:02:07 <ManateeLazyCat> real	26m14.108s
08:02:08 <ManateeLazyCat> user	2m8.150s
08:02:08 <ManateeLazyCat> sys	0m3.520s
08:02:08 <ManateeLazyCat>  
08:02:09 <jmcarthur> ManateeLazyCat: well, i meant the cpu *time*, but it was a bad question
08:02:14 <EvanR> it makes normal commits, and adds auto generated refs to them. an example of the composability of simple models that we were discussing before
08:02:15 <ManateeLazyCat> jmcarthur: ^^^
08:02:23 <jmcarthur> aristid: i don't see how it bloats it
08:02:32 <aristid> EvanR: it uses normal commits? did not know that
08:02:43 <EvanR> whats different about them?
08:02:49 <Saizan> ursthegizmo: c2hs or hsc2hs
08:02:52 <jmcarthur> aristid: the semantic model is a DAG and the stash is just a stack of pointers into the DAG
08:03:01 <aristid> but right, compared to many other models, git uses composability more
08:03:07 <FauxFaux> git clone --bare file://$(pwd)/foo bar2.git  32.54s user 2.68s system 102% cpu 34.381 total # etc.
08:03:20 <ursthegizmo> Saizan: thanks, will look at those
08:03:30 <jmcarthur> FauxFaux: ew
08:03:42 <jmcarthur> FauxFaux: what repo was that?
08:03:58 <FauxFaux> Work's codebase.  (17k revisions on master, 300mb head).
08:04:12 <EvanR> whats a revision
08:04:21 <hpc> whoa
08:04:21 <jmcarthur> darcs would have been a lot faster there i think
08:04:40 <EvanR> a commit?
08:04:45 <FauxFaux> EvanR: Yes.
08:05:16 <jmcarthur> FauxFaux: i thought git did smart things like hard links into a cache dir and such, like darcs does
08:05:43 <FauxFaux> jmcarthur: The time for that is the one above; the file:// url causes it not to do that.
08:05:50 <jmcarthur> oh!
08:06:03 <FauxFaux> jmcarthur: 07/16:01:38 < FauxFaux> ManateeLazyCat: git clone --bare foo bar.git  0.00s user 0.00s system 2% cpu 0.178 total, 17k revisions, 300mb HEAD. Â¬_Â¬
08:06:34 <jmcarthur> alright then i feel like my reality is back to normal
08:07:07 <EvanR> jmcarthur: finishes evaluating a runAlternateReality
08:07:30 <EvanR> or a local inside a Reader
08:07:33 <aristid> FauxFaux: and if you run git gc before doing the clone?
08:07:48 <FauxFaux> aristid: The repo is fully packed.
08:08:16 <aristid> FauxFaux: hmm, i wonder why it's not faster then
08:08:21 <EvanR> i might have to look into CVS
08:08:32 <aristid> EvanR: cvs? oO
08:08:37 <EvanR> it sounds wonderfully counter-culture
08:08:43 <nus> roconnor, IdiomLite.pdf - "Strong Lax Warm Monoidal Fuzzy Functor Things", Idiom.pdf - "this version got out of hand", Idiom-abort.pdf "this version was never in hand"
08:08:57 <EvanR> aristid: exactly
08:09:00 <jmcarthur> EvanR: http://www.gnu.org/software/rcs/
08:09:07 <EvanR> i enjoy making people go wtf
08:09:16 <EvanR> for example, using haskell
08:09:17 <FauxFaux> aristid: The time seems to be spent running what I understand to be git-index-pack; i.e. it's optimising for transfer (i.e. avoiding 100mb of "download") at the cost of 30s of cpu time.
08:09:21 <EvanR> or C
08:09:39 <monochrom> oh interesting, non-monad applicatives can be obtained from composing applicatives
08:09:45 <monochrom> s/from/by/
08:09:55 <jmcarthur> monochrom: yes it's lovely
08:10:07 <aristid> FauxFaux: heh, ok that doesn't really make sense, but then you trick it into that by using file://
08:10:08 <hpc> monochrom: eh? you mean like (<*>) . (<*>)?
08:10:15 <hpc> :t (<*>) . (<*>)
08:10:16 <lambdabot> forall a b a1. (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
08:10:19 <EvanR> jmcarthur: whats this
08:10:22 <jmcarthur> monochrom: you can also get monads that way but it's more work because you have to write out some sort of distribution rule
08:10:30 <monochrom> I mean like composing functors
08:10:32 <jmcarthur> EvanR: a not much used VCS
08:10:35 <hpc> :t (<*>) <$> (<*>)
08:10:35 <lambdabot> forall a b a1. (a -> a1 -> b) -> ((a -> a1) -> a) -> (a -> a1) -> b
08:10:36 <aristid> FauxFaux: but i guess if you were using gigabit ethernet, you would see the same problem. git needs a better cost model of transfers ;)
08:10:45 <jmcarthur> EvanR: you were talking about making people wtf
08:10:46 <EvanR> jmcarthur: is it cvs like or git/mercurial like
08:10:57 <jmcarthur> EvanR: it's OLD
08:11:00 <EvanR> lol
08:11:01 <hpc> :t (<*>) (<*>)
08:11:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (f (a -> b) -> f a) -> f (a -> b) -> f b
08:11:04 <monochrom> need to remember it for the next time someone asks "examples of non-monad applicatives?"
08:11:11 <FauxFaux> aristid: Indeed.  Give me a minute to patch it. Â¬_Â¬
08:11:13 <jmcarthur> monochrom: right, like composing functors
08:11:26 <aristid> FauxFaux: ok, but not more than a minute, slacker
08:12:14 <aristid> is this functor composition? type Compose f g a = f (g a)
08:12:18 <monochrom> "applicative" was "idiom" but it's hard to find the paper on "idiom"
08:12:26 <jmcarthur> monochrom: composing monads just requires some polymorphism in the composition operator so you can use different distribution rules for different monads
08:12:29 <monochrom> yes, that's functor composition
08:12:50 <identity_> I have a feelin I'm missing an obvious way to do this differently. Anyone? fmap catMaybes . sequence $ liftM2 foo ["foo"] ["bar", "baz"] :: WriterT [String] (ReaderT IrrelevantType IO) [String]
08:13:47 <hpc> identity_: StateT perhaps
08:14:13 <hpc> that looks a lot like StateT [String] IO [String]
08:14:15 <jmcarthur> EvanR: if you use rcs as your version control system and ed as your editor you will get a lot of WTFs
08:14:20 <identity_> hpc: Oh, nah, not referring to the monad. I'm referring to the combination of sequence, fmap and catmaybes
08:14:25 <hpc> oh
08:14:34 <pkrumins> How can I return a Bool from a function that messes with monads in between?
08:14:34 * hackagebot poppler 0.12.1 - Binding to the Poppler.  http://hackage.haskell.org/package/poppler-0.12.1 (AndyStewart)
08:14:43 <ManateeLazyCat> Sorry, typo in poppler.cabal
08:14:45 <EvanR> jmcarthur: i wrote a large portion of a MOO using the built in lambdamoo text editor
08:14:46 <identity_> pkrumins: What monad?
08:14:56 <pkrumins> identity_: Maybe monad
08:15:00 <EvanR> it was actually not that bad
08:15:04 <EvanR> not sure if ed is that good ;)
08:15:05 <nus> monochrom, http://strictlypositive.org/Idiom.pdf
08:15:17 <identity_> pkrumins: So it would return Maybe Bool?
08:15:23 <identity_> Is that what you're referring to d?
08:15:25 <identity_> -d
08:15:31 <monochrom> nice, thanks
08:15:32 <hpc> identity_: i think he wants Maybe a -> Bool
08:15:35 <pkrumins> I would like to return Bool only
08:15:35 <jmcarthur> EvanR: ed is basically just vi without the live view of the file
08:15:44 <pkrumins> hpc, yeah that's it
08:15:54 <pkrumins> or maybe that's not possible cause of purity/impurity
08:16:00 <EvanR> jmcarthur: a command prints out a chunk of lines?
08:16:04 <jmcarthur> EvanR: yeah
08:16:10 <hpc> in which case, you can do something like foo blah = let blah = do something; somethingElse; in fromJust blah
08:16:10 <EvanR> ah thats how it was in moo
08:16:13 <hpc> or similar
08:16:13 <identity_> pkrumins: (\x -> if isNothing x then False else True) Nothing
08:16:16 <jmcarthur> EvanR: it's horrible and obscure :)
08:16:21 <identity_> > (\x -> if isNothing x then False else True) Nothing
08:16:22 <lambdabot>   False
08:16:24 * EvanR switches immediately
08:16:28 <identity_> > (\x -> if isNothing x then False else True) (Just undefined)
08:16:29 <lambdabot>   True
08:16:33 <Saizan> identity_: "fmap something . sequence" often feels dirty but just as often can't be simplified
08:16:33 <hpc> a do block ends up being just another value, in the end
08:16:39 <pkrumins> oh interestsing
08:16:40 <identity_> Saizan: I see
08:16:46 <identity_> Well, I'll stick with it
08:16:54 <hpc> :t \f -> fmap f . sequence
08:16:55 <lambdabot> forall b (f :: * -> *) a. (Functor f, Monad f) => ([a] -> b) -> [f a] -> f b
08:17:24 <identity_> oh wait
08:17:34 <identity_> > sequence [Just 3, Nothing]
08:17:34 <lambdabot>   Nothing
08:17:35 * hackagebot gtk-serialized-event 0.12.0 - GTK+ Serialized event.  http://hackage.haskell.org/package/gtk-serialized-event-0.12.0 (AndyStewart)
08:17:38 <identity_> oh.
08:17:46 <identity_> :t catMaybes
08:17:47 <lambdabot> forall a. [Maybe a] -> [a]
08:17:48 <identity_> :t sequence
08:17:49 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:17:59 <jmcarthur> EvanR: http://www.gnu.org/software/ed/manual/ed_manual.html
08:18:00 <EvanR> jmcarthur: for a real programming system, the source code is small enough that you could ed it easily ;)
08:18:00 <EvanR> or functions are that small
08:18:03 <identity_> ah
08:18:08 <monochrom> I guess the "idiom" papers were drafts, eventually it came out as the "applicative" paper.
08:18:13 <pkrumins> what does sequence do?
08:18:20 <hpc> @src sequence
08:18:21 <lambdabot> sequence []     = return []
08:18:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
08:18:21 <lambdabot> --OR
08:18:21 <lambdabot> sequence xs = foldr (liftM2 (:)) (return []) xs
08:18:36 <hpc> the first version is more readable
08:18:37 <identity_> pkrumins: You can look at it like it 'executed all computations in a list of computations'
08:18:40 <identity_> monadic computations
08:18:48 <hpc> yeah, and collect the values
08:18:51 <identity_> aye
08:18:58 <pkrumins> oic
08:19:03 <EvanR> @src forM
08:19:03 <lambdabot> forM = flip mapM
08:19:07 <EvanR> @src mapM
08:19:07 <lambdabot> mapM f as = sequence (map f as)
08:19:08 <hpc> sequence looks a lot like monadic flip
08:19:10 <hpc> :t flip
08:19:11 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
08:19:22 <pkrumins> i have never used flip
08:19:23 <ManateeLazyCat> Hi all, i build gtk2hs mirror repository at : https://patch-tag.com/r/AndyStewart/gtk2hs-mirror/home , if code.haskell.org down, you can fetch code from there. Enjoy! :)
08:19:24 <pkrumins> so far
08:19:46 <hpc> pkrumins: flip isn't anything special; flip f x y = f y x
08:19:59 <identity_> But sometimes it's beautiful to use
08:20:04 <pkrumins> oh!
08:20:09 <EvanR> i wouldnt use it inline
08:20:09 <hpc> the generalization of it is crazy fun
08:20:15 <identity_> flip (/) 1 2
08:20:19 <identity_> > flip (/) 1 2
08:20:19 <EvanR> just as a definition like forM above
08:20:20 <lambdabot>   2.0
08:20:21 <pkrumins> hah!
08:20:22 <pkrumins> i see
08:20:24 <jmcarthur> @instances Traversable
08:20:24 <lambdabot> Couldn't find class `Traversable'. Try @instances-importing
08:20:32 <jmcarthur> @instances Data.Traversable.Traversable
08:20:32 <lambdabot> Maybe, []
08:20:35 <pkrumins> forM = flip mapM
08:20:41 <pkrumins> this i have yet to understand
08:20:42 <hpc> :t flip map
08:20:43 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
08:20:45 <tab> ManateeLazyCat: i've got a mirror on github as well btw
08:20:47 <jmcarthur> i guess ((->) a) can't really be Foldable
08:20:48 <pkrumins> :t map
08:20:48 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
08:20:53 <pkrumins> oic
08:20:55 <identity_> :t mapM
08:20:56 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
08:21:05 <ManateeLazyCat> tab: Link ?
08:21:24 <tab> ManateeLazyCat: http://github.com/vincenthz/gtk2hs
08:21:31 <identity_> pkrumins: mapM is just a monadic map. An example of its use would be to, say, pritn all strings in a list: mapM putStrLn ["foo", "bar"]
08:21:33 <hpc> :t flip fmap
08:21:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
08:21:50 <pkrumins> identity_: yeah I know monadic map
08:22:00 <jmcarthur> @let ffor = flip fmap
08:22:02 <lambdabot>  Defined.
08:22:03 <pkrumins> identity_: but don't quite know what monadic for is.
08:22:03 <identity_> forM is just a convenience function
08:22:03 <jmcarthur> :P
08:22:15 <monochrom> "My campaign to burn my thesis has not yet succeeded." haha
08:22:16 <identity_> idiomatic convenience, etc
08:22:30 <hpc> jmcarthur: perhaps apply = flip fmap
08:22:33 <pkrumins> identity_: can you give an example using it?
08:22:41 <hpc> [1, 2, 3] `apply` succ
08:22:47 <identity_> pkrumins: forM ["foo", "bar"] putStrLn
08:22:53 <pkrumins> OH!
08:22:54 <jmcarthur> hpc: it was a reference to forM
08:22:54 <pkrumins> so easy
08:22:55 <EvanR> jmcarthur: i rather enjoyed line editting back in the day. the mouse is quite clunky, and vim has a lot of typing involved
08:22:56 <identity_> it's literally just mapM with the arguments flipped
08:22:59 <pkrumins> just flip it around, right!
08:22:59 <hpc> jmcarthur: ah
08:23:03 <ManateeLazyCat> tab: Automatic synchronous?
08:23:12 <pkrumins> awseome
08:23:14 <jmcarthur> :t forM `asTypeOf` flip mapM
08:23:15 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
08:23:23 <identity_> It is more idiomatic in some cases.. "for every element in list l do coputation m"
08:23:37 <pkrumins> identity_: got it
08:23:45 <identity_> Oh ffs. I can't type for shit today it seems
08:23:50 <identity_> and this is even a new keyboard
08:23:55 <jmcarthur> > ffor [1, 2, 3] succ
08:23:56 <lambdabot>   [2,3,4]
08:24:02 <pkrumins> ffor!
08:24:05 <hpc> identity_: that's probably why; different physics on the keys, etc
08:24:25 <pkrumins> identity_:  your keys are flipped!
08:24:31 <Jafet> > 2 `flip id` succ
08:24:32 <lambdabot>   <no location info>: parse error on input `id'
08:24:33 <tab> ManateeLazyCat: you mean, automatically synchronized ?
08:24:40 <ManateeLazyCat> tab: yes.
08:24:41 <Jafet> > 2 `(flip id)` succ
08:24:42 <lambdabot>   <no location info>: parse error on input `('
08:24:45 <tab> ManateeLazyCat: should be yes
08:24:46 <jmcarthur> > flip id 2 succ
08:24:47 <lambdabot>   3
08:24:48 <hpc> :t (<$)
08:24:48 <identity_> hpc: somewhat cold fingers as well, but yes
08:24:49 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
08:24:49 <Jafet> Pft
08:24:56 <identity_> it is probably a contributor to my perpetual typoing
08:25:07 <hpc> :t flip id
08:25:08 <EvanR> identity_: where are you?
08:25:08 <lambdabot> forall a b. a -> (a -> b) -> b
08:25:15 <identity_> EvanR: At home. And you?
08:25:17 <ManateeLazyCat> tab: Your git repository will pull again when someone push new patch to gtk2hs main repository?
08:25:17 <tab> ManateeLazyCat: every couple of hours, the cronjob should try mirroring
08:25:22 <EvanR> siberia? norway?
08:25:28 <tab> ManateeLazyCat: yes
08:25:29 <identity_> The southern pole
08:25:35 <EvanR> im in south louisiana
08:25:35 <identity_> Nah, in denmark
08:25:38 <EvanR> and its damn cold
08:25:40 <identity_> I'm not sure why my fingers are cold
08:25:44 <identity_> room is warm
08:25:47 <EvanR> so i figure its another ice age
08:25:49 <ManateeLazyCat> tab: I update patch-tag.com manually . :)
08:25:54 <jmcarthur> EvanR: alabama here. cold here too, currently
08:25:57 <identity_> I have my 2500 dollar gaming computer heating up the place + an age old router
08:26:06 <tab> ManateeLazyCat: you should try the cronjob, it save a bit of typing :)
08:26:16 <EvanR> jmcarthur: confederate pride!
08:26:18 <EvanR> lol
08:26:24 <jmcarthur> ha
08:26:42 <ManateeLazyCat> tab: I intended to that. :)
08:26:42 <jmcarthur> we should have a southeastern haskell thingy sometime
08:26:55 <EvanR> rebel haskell
08:27:00 <medfly> southeast of what?
08:27:03 <jmcarthur> usa
08:27:10 <hpc> medfly: the north pole ;)
08:27:16 <aristid> identity_: so gaming computers ARE good for something
08:27:16 <ManateeLazyCat> tab: I just synchronous patches when i sure patch in gtk2hs main repository is right. :)
08:27:25 <medfly> lol
08:27:33 <jmcarthur> the Southeast
08:27:42 <identity_> I finally got a friend to start learning haskell. Naturally, he is in love, but he suffering from the delusion that he has to be an expert to enter this godly domain or some such. It may be because of my descriptions
08:27:45 <jmcarthur> hpc: you suck :P
08:27:51 <EvanR> medfly: our states broke away and started a civil war, because were cool like that
08:27:51 <hpc> :D
08:28:06 <identity_> aristid: Yes. Heating up your place and emptying your bank account
08:28:07 <tab> ManateeLazyCat: that's quite sensible. i can't do that in the cronjob :)
08:28:10 <Jafet> identity: uh, it's not a delusion?
08:28:23 <identity_> Jafet: sure it is
08:28:36 <identity_> I've been here pestering all of you with my lowly fledgling questions for months
08:28:39 <Jafet> Dunno why expertise is considered a bad thing
08:28:49 <identity_> what
08:29:07 <identity_> I'm saying that he things being an expert at haskell is a prerequisite for being in this channel
08:29:13 <jmcarthur> EvanR: actually the confederate states didn't really start the war. i'm sure they would have preferred to just break away without being attacked ;)
08:29:19 <identity_> I'm trying to tell him that this channel is the best resource for learning haskell
08:29:27 <Jafet> #haskell is a domain? I thought it was a semiring
08:29:35 <identity_> Damn you. 
08:29:35 <Jafet> Well ok then
08:29:38 * hackagebot libtagc 0.12.0 - Binding to TagLib C library.  http://hackage.haskell.org/package/libtagc-0.12.0 (AndyStewart)
08:29:42 <medfly> identity_, it's awesome not to be an expert here. you ask questions that you think are difficult and they are so easy to others that they are all excited to explain it to you.
08:29:58 <identity_> medfly: Hehe. Yes, the excited part is so true
08:30:01 <Twey> Haha
08:30:05 <Twey> That's a great description
08:30:15 <identity_> A single question: "guys, how do I do this differently?" sparks a wave of suggestions
08:30:21 <EvanR> there should be a 'tutorial' or something to show how to write haskell code without using fancy stuff
08:30:28 <jmcarthur> @remember medfly it's awesome not to be an expert here. you ask questions that you think are difficult and they are so easy to others that they are all excited to explain it to you.
08:30:28 <lambdabot> Good to know.
08:30:34 <aristid> medfly: and sometimes you ask questions but they are too boring for everyone :)
08:30:36 <Jafet> @quote IO.String
08:30:36 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
08:30:40 <aristid> that happens to me a lot :P
08:30:51 <identity_> Jafet: hahaha.
08:31:19 <aristid> @quote ennobunktor
08:31:19 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
08:31:20 <medfly> heh.
08:31:24 <EvanR> jmcarthur: im designing a mud again, im definitely going to embed ed into it ;)
08:31:30 <medfly> Jafet, I did that once.
08:31:30 <medfly> but it was honest!
08:31:50 <identity_> aristid: lul.
08:32:02 <ManateeLazyCat> I have re-install all gtk2hs-base packages, works fine. Please let me know if have any problem on gtk2hs-0.12.0
08:32:08 <ManateeLazyCat> Thanks,
08:33:32 <ManateeLazyCat> Hmm, hackage server re-build package very fast.
08:33:39 <identity_> @pl (\a b c -> (a, b, c))
08:33:39 <lambdabot> (,,)
08:33:42 <identity_> oh.
08:33:48 <Twey> Hehe.
08:33:59 <Twey> Don't feel bad.  It's a special case.
08:34:12 <identity_> I don't like magic >:(
08:34:16 <identity_> @src (,,)
08:34:16 <lambdabot> Source not found. stty: unknown mode: doofus
08:34:18 <danr> @pl (\a -> (a,a,a))
08:34:18 <lambdabot> join (join (,,))
08:34:37 <Jafet> Ho, but it can't pattern match on them.
08:34:37 <aavogt> > (,2,) 1 3
08:34:38 <lambdabot>   <no location info>: parse error on input `2'
08:34:40 <EvanR> identity_: syntactic sugar for data Triple a b c = Triple a b c
08:34:50 <jmcarthur> EvanR: lol awesome
08:34:56 <Twey> @pl \a -> (a *** a)
08:34:56 <lambdabot> join (***)
08:35:04 <Twey> HA, wrong.
08:35:19 <Twey> :t (\a -> a *** a, join (***))
08:35:20 <lambdabot> forall (a :: * -> * -> *) b c (a1 :: * -> * -> *) b1 c1. (Arrow a, Arrow a1) => (a b c -> a (b, b) (c, c), a1 b1 c1 -> a1 (b1, b1) (c1, c1))
08:35:53 <Twey> Oh, not wrong until applied to arguments, I guess.
08:35:54 <jmcarthur> Twey: i tend to use asTypeOf for such demonstrations ;)
08:35:57 <aavogt> the lambda is monomorphic
08:36:18 <Twey> Yeah.  >.>
08:36:35 <EvanR> jmcarthur: im seeing a spatial database as a substrate to arrange objects physically. of course i am stuck on sane semantics of the not yet existing scripting language. is it possible to escape imperative programming?
08:36:46 <Twey> Can't really demonstrate that with lambdas, I guess.
08:37:14 <aavogt> @type (+) *** (+)
08:37:15 <lambdabot> forall b b'. (Num b, Num b') => (b, b') -> (b -> b, b' -> b')
08:37:30 <Twey> Yeah
08:37:44 <Twey> :t ((+) *** (+), join (***) (+))
08:37:45 <lambdabot> forall b b' b1. (Num b, Num b', Num b1) => ((b, b') -> (b -> b, b' -> b'), (b1, b1) -> (b1 -> b1, b1 -> b1))
08:38:03 <jmcarthur> EvanR: what does the scripting language need to do?
08:38:49 <Jafet> :t (\a -> a *** a) (+)
08:38:50 <lambdabot> forall b. (Num b) => (b, b) -> (b -> b, b -> b)
08:38:54 <Jafet> It's correct.
08:39:38 <Twey> Yeah.
08:39:46 <EvanR> jmcarthur: query the database, modify the database, interpret user commands, compute output text, define who sees that output text
08:39:50 <aavogt> well it emphasizes that polymorphic functions aren't terribly first class
08:40:18 <EvanR> probably an incomplete list
08:40:27 <EvanR> concurrent processes...
08:40:46 <jmcarthur> EvanR: that's a very operational description. what is it supposed to *mean*? are the user commands the language of the scripting language or is this just the scripting language to script the game itself?
08:41:06 <EvanR> the user commands are distinct
08:41:11 <jmcarthur> EvanR: if it's the latter, i'd say just use an existing language, personally
08:41:23 <jmcarthur> EvanR: unless you have some very specific semantics in mind
08:41:51 <EvanR> there arent many operations possible
08:42:00 <jmcarthur> EvanR: so basically this is a language for creating muds?
08:42:02 <EvanR> the rest is computational
08:42:46 <EvanR> yes, log in with the default user and line edit your way to greatness
08:42:50 <jmcarthur> concurrent things are tough to define
08:44:04 <EvanR> the system must react to user input, so we could remove concurrency as put scheduled artificial inputs in its place
08:44:33 <jmcarthur> if users can interact in any way then that implied some sort of concurrency i think
08:45:02 <EvanR> yes, but i was suggesting short-running processes that complete immediately
08:45:05 <EvanR> like javascript
08:45:18 <jmcarthur> i'm not very familiar with muds so i'm only going on basic information i picked up somewhere
08:45:21 <jmcarthur> ah
08:45:30 <EvanR> so in principle you could do one reaction at a time
08:45:41 <jmcarthur> yeah, that sounds like a very operational model then
08:45:56 <jmcarthur> because it's going to be all about carrying out actions
08:46:25 <EvanR> well, consider a reaction limitted to printing text to all connected players
08:46:35 <EvanR> and that text is a function of some user input
08:46:51 <jmcarthur> no changes to db?
08:46:53 <EvanR> then you could define it using pure/lazy language
08:47:05 <jmcarthur> yeah
08:47:08 <EvanR> the listening and reading is outside the system
08:47:17 <jmcarthur> something like Verb -> Noun -> String or something
08:48:20 <EvanR> so added refinements could be, which connected players to notify this to, rather than all of them
08:48:29 <EvanR> does that break everything?
08:48:44 <jmcarthur> Verb -> Noun -> (String, [Player])
08:49:17 <jmcarthur> ah but those Players have to come from somewhere
08:49:36 <jmcarthur> also i'm sure that the system has some sort of state
08:49:43 <pkrumins> suppose I have an IO Bool, how can I take the Bool out of it and use in pure code?
08:49:56 <jmcarthur> pkrumins: you can lift pure code to use IO Bool
08:50:03 <jmcarthur> not the other way around
08:50:05 <pkrumins> but not the other way around?
08:50:07 <pkrumins> aha, got it.
08:50:11 <EvanR> runIO :: IO Bool -> Bool
08:50:14 <Botje> pkrumins: (pure code) `fmap` (something of IO::Bool)
08:50:32 <EvanR> :t unsafePerformIO
08:50:33 <lambdabot> Not in scope: `unsafePerformIO'
08:50:36 <jmcarthur> nooooo
08:50:41 <pkrumins> thanks Botje, EvanR and jmcarthur!
08:50:44 <EvanR> lol
08:50:48 <jmcarthur> pkrumins: EvanR is screwing with you
08:50:54 <pkrumins> i know ;)
08:50:56 <pkrumins> i wont do that
08:50:59 <jmcarthur> :)
08:51:15 <EvanR> i didnt do anything, blame whoever invented unsafePerformIO
08:51:23 <Twey> pkrumins: fmap foo ioBool = foo <$> ioBool = ioBool >>= return . foo = do bool <- ioBool; return $ foo bool
08:51:42 <EvanR> jmcarthur: in practice i would select players based on the results of querying the spatial database
08:51:55 <Twey> pkrumins: Where foo is your pure function
08:52:22 <pkrumins> trying to understand that
08:53:34 <Twey> pkrumins: Basically, you can't take the Bool out of the IO, because an IO Bool is not a value that *contains* a Bool, but it's a sort of â€˜recipeâ€™ for generating a Bool (so there's no Bool there yet â€” but there will be once it runs)
08:53:56 <pkrumins> i wonder how I could do `if val`, where val is IO Bool
08:53:58 <Twey> pkrumins: What you *can* do is append a new instruction to the end of the IO Bool, which says â€˜and then do <something else> with the resultâ€™
08:54:03 <pkrumins> that's why I wanted to "take it out"
08:54:14 <pkrumins> can't quite figure out now how to do branching when the result is IO Bool
08:54:18 <pkrumins> based on Bool's value.
08:54:21 <mauke> pkrumins: do you know javascript?
08:54:21 <EvanR> yn <- ioBool
08:54:28 <EvanR> when yn (do something)
08:54:29 <pkrumins> mauke, I do!
08:54:36 <Twey> pkrumins: That's what the >>= operator is for.
08:54:37 <Saizan> pkrumins: do b <- yourIOBool; if b then .. else ..
08:54:40 <mauke> pkrumins: do you know asynchronous XmlHttpRequest?
08:54:44 * hackagebot attoparsec 0.8.2.0 - Fast combinator parsing for bytestrings  http://hackage.haskell.org/package/attoparsec-0.8.2.0 (BryanOSullivan)
08:55:06 <pkrumins> mauke, yeah, you should look into Socket.IO
08:55:14 <Twey> pkrumins: There's also â€˜do notationâ€™, which is what EvanR and Saizan are demonstrating for you, which is a sort of wrapper over this sort of code.
08:55:17 <mauke> pkrumins: this is how IO works
08:55:26 <mauke> pkrumins: you attach a callback to do stuff
08:56:31 <bos> mauke: what?
08:56:47 <pkrumins> mauke, i am a bit confused.
08:57:02 <mauke> bos: Haskell IO is callback based
08:57:09 <pkrumins> mauke, i see what you mean now
08:57:30 <pkrumins> mauke, at first i thought you asked for an advice ;)
08:57:38 <mauke> "how do I get Bool out of IO Bool?" is not entirely different from "how do I sleep() in Javascript?"
08:57:56 <bos> mauke: that is a bizarre assertion.
08:58:06 <jmcarthur> :t (>>=)
08:58:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
08:58:08 <pkrumins> haha.
08:58:13 <mauke> but true
08:58:16 <pkrumins> i like that.
08:58:17 <jmcarthur> that second parameter looks like a continuation to me
08:58:27 <Jafet> :t callCC
08:58:28 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
08:58:34 <EvanR> IO is continuation based!
08:58:38 <jmcarthur> (>>=) :: m a -> Cont (m b) a
08:58:43 <pkrumins> oh right, so b <- myIOBool.
08:58:50 <EvanR> monads generally
08:59:06 <jmcarthur> the continuation monad is continuation based!
08:59:12 <pkrumins> oh snap
08:59:16 <hpc> EvanR: someone posted an article about implementing all the standard monads using continuations
08:59:20 <pkrumins> it all became so easy.
08:59:22 <pkrumins> code just works.
08:59:29 <Saizan> http://blog.sigfpe.com/2008/12/mother-of-all-monads.html
08:59:30 <EvanR> pkrumins: of course it does ;)
08:59:30 <jmcarthur> i don't like this view of monad though
08:59:31 <hpc> it works too, if you don't mind the wonky strictness
08:59:34 <pkrumins> thanks ;)
08:59:40 <jmcarthur> :t (=<<) -- i prefer this
08:59:41 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
08:59:47 <hpc> haha, it would be sigfpe
08:59:48 <EvanR> :t (>=>)
08:59:49 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
08:59:52 <jmcarthur> which doesn't look (as much) like a continuation
09:00:02 <Jafet> That conclusively proves that continuations should never be used in real programs
09:00:04 <jmcarthur> :t (<=<) -- EvanR: the true way
09:00:05 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
09:00:37 <Saizan> kleisli star ftw!
09:00:40 <hpc> jmcarthur: one kleisli arrow to rule them all
09:01:06 <pkrumins> talking about continuations, isn't there two meanings to the word? continuation like a collector, and continuation as a language construct (like call/cc)?
09:01:07 <EvanR> pkrumins: congrats you triggered yet another haskell nerd-out
09:01:31 <jmcarthur> pkrumins: call/cc itself isn't a continuation. it just uses one
09:01:43 <jmcarthur> pkrumins: i don't see the "collector" analogy you are using
09:02:04 <Saizan> more precisely, call/cc reifies the implicit continuation
09:04:21 <pkrumins> this is still beyond me.
09:04:59 <tibbe> dons: how's hacking?
09:05:22 <jmcarthur> pkrumins: by "collector" do you mean in the sense that you can apply every element of a list to a continuation?
09:06:19 <jmcarthur> pkrumins: if so, that's not a fully general meaning for the word "continuation"
09:07:50 <jmcarthur> pkrumins: "continuation" just means that instead of taking the output of a function foo and using it later, you pass a function of what to do later as a parameter to foo and foo calls that function on your behalf
09:08:22 <jmcarthur> pkrumins: and foo can choose to use the continuation in whatever way it chooses
09:09:04 <pkrumins> oh is ee
09:09:21 <pkrumins> by collector i meant this last case, yes
09:09:32 <pkrumins> that's the term the little schemer used
09:10:04 <jmcarthur> pkrumins: well, call/cc is just a way to create a function out of "the rest of your code" and pass it to another function
09:10:10 <Saizan> the continuation is this "function of what to do later"
09:10:15 <jmcarthur> pkrumins: so it's not any different :)
09:10:26 <Saizan> the whole technique is called Continuation Passing Style
09:10:28 <pkrumins> like a callback!
09:10:37 <jmcarthur> sort of, yes
09:10:41 <nus> tibbe, <Heffalump> can anyone suggest an easier way to inspect how things that depend on package foo are using it, than just downloading the whole lot and reading/grepping the code? <Igloo> tibbe is writing or has written a tool
09:11:13 <aristid> Saizan: this is maybe a stupid question, but... is cps similar to church encoding?
09:11:23 <tibbe> nus: *is* writing
09:11:33 <tibbe> nus: not quite done yet and I need to clear it with google legal
09:11:54 <Jafet> Go to is to call/cc what spaghetti is to lasagna.
09:12:13 <jmcarthur> Jafet: i don't really see it that way
09:12:22 <aristid> tibbe: google legal? oO
09:12:29 <nus> tibbe, aha. kinda grep -C with dependencies ?
09:12:34 <Saizan> aristid: i'd say that church encoding uses CPS
09:12:45 <tibbe> nus: it actually compiles all hackage packages and indexes qualified names
09:12:54 <nus> tibbe, ouch
09:13:07 <aristid> Saizan: so church encoding is a special case of CPS?
09:13:08 <tibbe> aristid: it could be seen as competing with Google code search (although I don't think it does)
09:13:15 <Saizan> i.e. instead of giving you a T it asks for what you'd want to do with that T
09:13:16 <hotaru2k3> Jafet: call/cc is full of nasty cheese?
09:13:26 <aristid> tibbe: does it use google services?
09:13:47 <tibbe> nus: so you can search for "Data.Map.insert" and get all use sites, even though the use site doesn't qualified the identifier
09:13:51 <tibbe> aristid: no
09:14:04 <aristid> tibbe: do you work for google?
09:14:11 <pkrumins> can you sometimes omit 'do'? Like I have this function procExists :: String -> IO Bool, and it seems to work either I start it this way: `procExists proc = do ...`, or without do, this way: `procExists proc = ...`
09:14:17 <jmcarthur> goto is to call/cc as compuserve is to the internet
09:14:18 <tibbe> aristid: yes
09:14:31 <aristid> tibbe: ok, that explains that.
09:14:49 <nus> tibbe, I see.
09:16:09 <jmcarthur> is google hiring haskell devs?
09:16:10 <aristid> pkrumins: yes, you can often omit do
09:16:14 <jmcarthur> (doubtful)
09:16:24 <tibbe> jmcarthur: not because they are haskell devs no
09:16:34 <jmcarthur> yes that is what i meant
09:16:34 <tibbe> jmcarthur: but we have quite a few
09:16:53 <medfly> just curious. jmcarthur, would you move to work for Google?
09:16:58 <aristid> tibbe: but not using haskell at work, i suppose?
09:17:05 <jmcarthur> medfly: yeah
09:17:33 <pkrumins> i once had a google interview, but not haskell related
09:17:34 <jmcarthur> tibbe: do haskell devs at google tend to converge on common projects (whether naturally or by desire)?
09:17:35 <tibbe> aristid: no, although a few of us are thinking about it
09:17:48 <tibbe> jmcarthur: not really, except for 20% projects
09:17:55 <jmcarthur> okay
09:18:37 <hpc> does google use their contrived 'Go' language?
09:18:42 <jmcarthur> medfly: i don't have much holding me down. i've probably move for any job if i thought the job and location were at all desirable
09:18:49 <jmcarthur> *i'd
09:18:50 <medfly> ah.
09:18:50 <aristid> hpc: hahaha
09:19:11 <jmcarthur> medfly: i'm married, but have no kids, and my wife is a freelancer
09:19:28 <jmcarthur> and we don't have a lot of stuff, to boot
09:19:36 <aristid> jmcarthur: and what are you currently doing?
09:19:44 <jmcarthur> aristid: job hunting
09:19:57 <aristid> i see:)
09:20:07 <jmcarthur> aristid: and taking my time because i don't want to end up somewhere i'm not happy with
09:20:41 <jmcarthur> i'm not sure whether my pickiness makes me more or less appealling to potential employers
09:21:13 <aristid> jmcarthur: i guess you can't expect to work with haskell
09:21:21 <jmcarthur> aristid: i'm hoping though :)
09:21:40 <jmcarthur> aristid: i've already interviewed for a scala job and a haskell job
09:22:04 <aristid> jmcarthur: but it didn't work out?
09:22:10 <jmcarthur> the scala one didn't really appeal to me, and the haskell one got stolen by somebody who deserved it more than i
09:22:25 <jmcarthur> the haskell one wasn't high paying anyway. was a research position at a uni
09:23:29 <aristid> jmcarthur: working for a uni sounds pretty unappealing to me
09:23:45 <jmcarthur> aristid: depends on the uni and the research
09:23:46 <medfly> aristid, how come?
09:23:53 * Heffalump disliked writing papers
09:24:00 <Heffalump> and would have disliked grant applications even more
09:24:12 <aristid> medfly: it's not my world i guess
09:24:13 <jmcarthur> i certainly wouldn't want to work (anymore) at the uni that i got my undergrad from...
09:24:39 <medfly> I dunno. I am in no position to be picky. something as free as a university job sounds amazing.
09:24:40 <jmcarthur> Heffalump: yeah, that's probably the scariest thing to me about going into academia is having to go through that stuff
09:24:57 <jmcarthur> well, most annoying anyway
09:25:14 <EvanR> jmcarthur: think of it as the interface to the real world, like the IO monad
09:25:21 <jmcarthur> lol
09:25:23 <writer> and getting featured in phdcomics.com...
09:25:30 <EvanR> it sucks, but without it, nothing happens
09:25:43 <jmcarthur> @remember EvanR think of [grant applications] as the interface to the real world, like the IO monad
09:25:43 <lambdabot> Done.
09:25:46 <aristid> medfly: if you compare for example google or even the best university, it's more likely that you'll end up doing something that will affect millions of people at the former
09:26:08 <Heffalump> it's important, I'm just happier being a developer at a company than being an academic
09:26:21 <medfly> I dunno. I am pretty sure a lot of people in universities do things that don't influence anyone but themselves and their colleagues
09:26:26 <jmcarthur> aristid: this particular research project would have had the potential to influence future javascript standards
09:26:51 <jmcarthur> among other practical things
09:27:29 <tg_> medfly: that seems like a bit of an ignorant statement
09:27:52 <medfly> I don't know.
09:28:16 <medfly> I am helping this guy in history type in his phd thesis. I don't think anyone outside his small field would read it.
09:28:18 <aristid> medfly: i wanted to say that you influence more people at google if my statement wasn't clear
09:28:57 <medfly> oh
09:29:01 <medfly> need to pay more attention.
09:29:02 <tg_> medfly: perhaps that is true if you restrict the field
09:29:12 <tg_> to something like, history
09:29:27 <monochrom> you don't know how much you would influence
09:29:33 <tg_> but in the technical sciences, the body of work that is built by academics is very much in demand in industry
09:30:09 <aristid> monochrom: right, you only get likelihoods
09:30:55 <jmcarthur> honestly i think that the perception that academia is largely useless research is a bigger reason for it being useless than the actual amount of useless research is
09:31:00 <monochrom> if you confine to a short time frame near the current time, it's easy to see google influences more than a nobody historian
09:31:06 <aristid> tg_: but even in technical sciences, researchers often build things that are interesting but simply not practical the way they are built
09:31:15 <jmcarthur> industry only interacts with academia with a ten foot pole, much of the time
09:31:40 <EvanR> mapReduce! ;)
09:31:41 <tg_> aristid: sure. Bell Labs had a long history of getting together researchers to build impractical things.
09:31:54 <EvanR> c++ functors
09:32:05 <monochrom> if you talk about what happens 200 years from now, it is no longer clear whether today's google matters more than today's nobody historian
09:32:05 <aristid> monochrom: you cannot add up all future time slices with an equal weighting, for that would give an infinite sum. you need to do some discounting to give far future less weight than near future
09:32:47 <aristid> tg_: or xerox parc. but others used their stuff to make practical things, fortunately.
09:33:18 <tg_> aristid: yes, but the point was the reason those researchers were together in the first place was basic, fundamental research with no financial goals
09:33:36 <aristid> monochrom: but 200 years from now matters less to us than 50 years from now
09:34:08 <Arthur_> Hello, I'm new to Haskell and trying to figure out how to make this function not lead to a non-exhaustive pattern. I'm a bit confused because this is a list of lists I am dealing with here: http://hpaste.org/41252/nep
09:34:27 <tg_> 5
09:34:32 <ezyang> Arthur_: What is the type of ws's argument? 
09:34:34 <tg_> > ws ([]:nep) = nep
09:34:35 <lambdabot>   <no location info>: parse error on input `='
09:34:43 <EvanR> Arthur_: you didnt handle the case of []
09:34:46 <aristid> Arthur_: you need to hadle ws [] too
09:34:46 <ezyang> I don't think []:nep does what you think it does. 
09:34:46 <ksf> there's no ws [] = .. case.
09:34:48 <EvanR> only (:)
09:34:56 <tg_> that was fast
09:35:06 <Arthur_> the type is [[Int]] -> [[Int]]
09:35:15 <ezyang> Ah, ok. Then what everyone else said. 
09:35:25 <monochrom> a nobody historian's paper today may eventually inspire some bastard to become the 2nd hitler and end humanity 200 years later. this is a bigger influence than google.
09:35:40 <aristid> monochrom: again, not if you do proper discounting.
09:35:41 <monochrom> anyway, think of the butterfly effect.
09:35:56 <Arthur_> so I should replace my first definition with something along the lines of ws [] = .. ?
09:35:58 <EvanR> 2nd hitler at a discount
09:36:10 <EvanR> Arthur_: yes
09:36:13 <aristid> EvanR: buy 1 hitler, get 1 free
09:36:22 <ksf> > let nep = (map . map) (length . show) in nep [[1,20],[49,4]]
09:36:23 <lambdabot>   [[1,2],[2,1]]
09:36:27 <EvanR> []:xs means 'a list of lists where the first element is the empty list'
09:36:37 <EvanR> not 'the empty list'
09:36:39 <EvanR> thats []
09:36:56 <ksf> also, I think you want to take the logarithm of those numbers, not go via show.
09:37:00 <hpc> to be fair, []:xs is a freaky ugly pattern
09:37:04 <aristid> > let nep x = length . show .: x in nep [[1,20],[49,4]]
09:37:05 <lambdabot>   Precedence parsing error
09:37:05 <lambdabot>      cannot mix `L..' [infixr 9] and `L..:' [infix...
09:37:21 <aristid> > let (.:) = fmap.fmap; infixr 5 .:; nep x = length . show .: x in nep [[1,20],[49,4]]
09:37:22 <lambdabot>   [[1,2],[2,1]]
09:37:27 <aristid> \o/
09:37:29 <monochrom> yes, I am discounting "from 2010 to 2200" and just focuing on the interval "from 2200 to 2220"
09:38:01 <ksf> Arthur_, sufficiently confused by now?
09:38:11 <Arthur_> I was just typing I am quite confused :P You beat me to it
09:38:12 <nus> monochrom, perhaps '2nd hitler' would be using '2nd google' to find this paper?
09:38:16 <monochrom> I am not assigning equal weight. I am assigning 0 weight to (-oo,2200) and to to (2220, oo)
09:38:17 <aristid> monochrom: that's not what i mean.
09:38:27 <aristid> monochrom: right, that weighting is stupid.
09:38:53 <ksf> Arthur_, the idiomatic way to write nep is the map . map thing I did above
09:39:09 <monochrom> I agree to disagree.
09:39:14 <Twey> nep?
09:39:22 <ksf> Twey, scroll up.
09:39:39 <aristid> ksf: hmm, with a non-infix version of (.:) i can do this point-free too
09:39:39 <ksf> :t logBase
09:39:40 <lambdabot> forall a. (Floating a) => a -> a -> a
09:39:50 <ksf> > let nep = (map . map) (logBase 10) in nep [[1,20],[49,4]]
09:39:51 <lambdabot>   [[0.0,1.301029995663981],[1.6901960800285134,0.6020599913279623]]
09:40:02 <aristid> > let binary = fmap.fmap; nep = binary (length . show) in nep [[1,20], [49,4]]
09:40:02 <lambdabot>   [[1,2],[2,1]]
09:40:03 <Twey> I did, but didn't see an explanation for why it was called â€˜nepâ€™
09:40:05 <ksf> err, well.
09:40:17 <Twey> Since you used it, I figured it was a standard mathematical name for something
09:40:35 <aristid> Twey: symbols are opaque!
09:40:52 <ksf> well, I tried not to use the possibly newbie-scaring fmap=map thing.
09:41:05 <ksf> (at least scary when it comes to type errors, that is)
09:41:27 * EvanR prefers newbie-scarring
09:41:54 <Arthur_> ksf, would nep x = (map . map) (length . show) be equivalent to what you wrote? And then I just say nep [[23, 32], [43, 45]] for example?
09:42:02 * hackagebot blaze-builder 0.2.0.0 - Efficient construction of bytestrings.  http://hackage.haskell.org/package/blaze-builder-0.2.0.0 (SimonMeier)
09:42:26 <ksf> Arthur_, without the x.
09:42:55 <aristid> ksf: hmm that's actually perfectly suited for $ i think
09:43:03 <aristid> nep = map . map $ length . show
09:43:07 <Twey> Heheâ€¦ fmap fmap fmap
09:43:19 <ksf> nope, it isn't.
09:43:31 <ksf> ...because you can't copy+paste refactor it easily, then.
09:43:34 <aristid> :t map . map $ length . show
09:43:35 <lambdabot> forall a. (Show a) => [[a]] -> [[Int]]
09:43:40 <aristid> ksf: ?
09:43:43 <Arthur_> how would that work in a script? I mean, when I want to call it from GHCi I would need to  say nep [[23, 32], [43, 45]] but if the function does not take an argument then how will I pass one?
09:43:53 <aristid> ksf: it's the same expression, no structural change
09:44:02 * hackagebot blaze-html 0.2.4.0 - A blazingly fast HTML combinator library.  http://hackage.haskell.org/package/blaze-html-0.2.4.0 (SimonMeier)
09:44:27 <EvanR> you would easily copy and paste parenthesized expressions either
09:44:36 <EvanR> not without altering the parentheses at the other end
09:44:39 <ksf> hmm. yes. but I'm not used to it, so it's evil.
09:44:49 <EvanR> s/would/wouldnt/
09:44:59 <ksf> I don't like $ in the middle of (.) . it belongs at the end.
09:45:08 <EvanR> then . $ thing is dogma
09:45:18 <EvanR> the*
09:46:10 <ksf> Arthur_, it does take an argument.
09:46:28 <ksf> :t map . map $ length . show
09:46:29 <lambdabot> forall a. (Show a) => [[a]] -> [[Int]]
09:46:43 <ksf> :t map . map
09:46:44 <lambdabot> forall a b. (a -> b) -> [[a]] -> [[b]]
09:46:48 <Twey> :t fmap fmap fmap $ fmap length show
09:46:49 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Functor f, Functor f1, Show a) => f (f1 a) -> f (f1 Int)
09:46:54 <Twey> }:-)
09:47:18 <aristid> Twey: now we need a way to replace the $ by another fmap
09:47:25 <ksf> cf "pointless style"
09:47:33 <Arthur_> Ah, I get it I think ^^
09:51:39 <Arthur_> So if I want to get a new list with the maximum value per list inside the list of lists returned, would that be done by saying map maximum?
09:51:52 <Jonny> Hi
09:52:13 <Jonny> If I am trying to create a show instance for this data type: data Expr = Num Float | Id String | App String [ Expr ]             deriving (Eq, Ord)
09:52:24 <Jonny> for example if I want it to display "Num n" as just n
09:52:28 <Jonny> how would I write that?
09:52:36 <Botje> show (Num n) = show n
09:52:43 <Jonny> thanks
09:52:46 <ksf> > map maximum $ [[1,20],[49,4]]
09:52:46 <lambdabot>   [20,49]
09:53:01 <Saizan> instance Show Expr where show (Num n) = show n; ...
09:53:07 <Botje> with "instance Show Expr where" before it
09:53:33 <EvanR> constructor Num, bah, confusing non collision
09:53:44 <EvanR> ^ future ghc warnings ;)
09:53:46 <ksf> @check \xs -> (maximum . concat $ xs) == (maximum . map maximum $ xs)
09:53:47 <lambdabot>   "*Exception: Prelude.maximum: empty list
09:53:59 <ksf> @check \xs -> xs == [] || (maximum . concat $ xs) == (maximum . map maximum $ xs)
09:54:00 <lambdabot>   "*Exception: Prelude.maximum: empty list
09:54:16 <aavogt> you need a spoon
09:54:18 <ksf> argh.
09:54:22 <EvanR> @src maximum
09:54:22 <lambdabot> maximum [] = undefined
09:54:22 <lambdabot> maximum xs = foldl1 max xs
09:54:28 <Saizan> @check \xs -> concat xs == [] || (maximum . concat $ xs) == (maximum . map maximum $ xs)
09:54:28 <lambdabot>   "*Exception: Prelude.maximum: empty list
09:54:32 <EvanR> :t max
09:54:33 <lambdabot> forall a. (Ord a) => a -> a -> a
09:54:45 <EvanR> :t foldl1
09:54:46 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
09:54:47 <ksf> :t all
09:54:47 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
09:54:51 <aavogt> @check \xs -> any null xs || (maximum . concat $ xs) == (maximum . map maximum $ xs)
09:54:51 <lambdabot>   "*Exception: Prelude.maximum: empty list
09:54:56 <Jonny> if say I have "App "*" [ 2 ,  3 ]"  what would be the show line for app
09:55:01 <aavogt> @check \xs -> any null xs || null xs || (maximum . concat $ xs) == (maximum . map maximum $ xs)
09:55:02 <lambdabot>   "OK, passed 500 tests."
09:55:14 <Jonny> for it to display as 2 * 3
09:55:27 * aavogt thinks we're using [[()]] though
09:55:33 <Jonny> I tried  show ( App f [ x , y ] ) = show "x f y"
09:55:43 <Jonny> but it just always outputs "x f y"
09:55:47 <Jonny> instead of what x f y are
09:55:57 <aavogt> @check \xs -> any null xs || null xs || (maximum . concat $ xs) == (maximum . map maximum $ (xs::[[Int]])
09:55:57 <lambdabot>  Unbalanced parentheses
09:56:00 <aavogt> @check \xs -> any null xs || null xs || (maximum . concat $ xs) == (maximum . map maximum $ (xs::[[Int]]))
09:56:01 <Saizan> "x f y" is just a string literal
09:56:02 <lambdabot>   "OK, passed 500 tests."
09:56:06 <Eduard_Munteanu> Jonny: App "*" [ 2 ,  3 ] looks malformed
09:56:18 <ksf> unless it's a lisp.
09:56:23 <Jonny> how do you mean?
09:56:32 <Saizan> show (App f [x,y]) = show x ++ f ++ show y
09:56:39 <arnihermann> is there no way to browse on hpaste.org by author?
09:56:39 <Eduard_Munteanu> Jonny: 2 and 3 do not look like Exprs
09:56:47 <Jonny> oh sorry it would be Num 2 and Num 3
09:56:49 <ksf> oh, that, too.
09:56:59 <Eduard_Munteanu> Yeah, that's fine.
09:57:06 <Jonny> thanks
09:57:48 <Saizan> you need to add parentheses though for nested expressions
09:58:32 <Saizan> and if you want to use precedence rules to reduce them you want to implement showsPrec instead of show
09:59:11 <paolino> hello, I'm trying to write a Traversable instance for "data Node m a = Node (Maybe a) [Node m a]" and the [Node m a] part looks complicate , when not wrong "foldr (liftA2 (:) . traverse f) (pure []) ns".  Is there a better way ?
09:59:16 <ksf> and a decent pretty-printing library to care about indentation
09:59:44 <aavogt> paolino: newer ghc can derive Traversable
10:00:03 <Eduard_Munteanu> Really? Nice.
10:00:09 <ksf> Functor, too.
10:00:27 <Eduard_Munteanu> I presume it's an extension though.
10:00:30 <ksf> a lot more derivations come via th from hackage
10:00:30 <paolino> ah, btw, I'd like to learn
10:00:33 <ksf> yep.
10:00:52 <Eduard_Munteanu> paolino: what's the semantics of your 'm' ?
10:01:15 <aavogt> how does that make any difference?
10:01:34 <paolino> it will be a monad , later
10:01:38 <Eduard_Munteanu> It doesn't, but might be a mistake.
10:01:55 <Eduard_Munteanu> Ok.
10:02:57 <paolino> I guess that if "sequence" is not for applicative there should be a reason 
10:03:13 <aavogt> there is a sequence for applicative
10:03:18 <aavogt> @hoogle sequenceA
10:03:18 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
10:03:18 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
10:03:38 <paolino> :t \g -> foldr (liftA2 (:) . g) (pure [])
10:03:39 <lambdabot> forall a (f :: * -> *) a1. (Applicative f) => (a1 -> f a) -> [a1] -> f [a]
10:04:25 <aavogt> paolino: you can probably use  traverse instead of foldr
10:04:38 <aavogt> since you're applying it to a list...
10:04:59 <paolino> with which function ?
10:05:22 <paolino> (traverse f) ?
10:05:54 <paolino> ah, thanks aavogt
10:05:59 <aavogt>  in your    instance Traversable (Node m) where traverse f (Node a b) = Node <$> traverse f a <*> traverse (traverse f) b
10:06:07 <aavogt> which might work
10:07:03 <Jonny> I'm trying to optimise the show function so that things like x * y = 0 if either x or y =0      and also if either x or y are 1 then it displays the other, so ive written...
10:07:21 <Jonny> http://pastebin.com/tBN8SXdC
10:07:35 <paolino> aavogt: then I guess "maybe (pure Nothing) (fmap Just . f) x" is Traverse for Maybe :)
10:07:40 <Jonny> but what if an expr needs to be simplified by both rules
10:07:48 <Jonny> wont it be caught by the first one only?
10:08:27 <Mitar> any suggestion for improving notation here: http://hpaste.org/41253/do_notation
10:09:29 <aavogt> Jonny: maybe that's better as a separate simplification pass
10:10:00 <Jonny> how do you mean sorry
10:10:21 <aavogt> paolino: yeah, if you use traverse to write traverse instances, it's pretty clear that those can be written by a program for most types
10:10:35 <FunctorSalad_> alternative vacuum dotizer :) http://i.imgur.com/BjrDS.png
10:10:57 <aavogt> Jonny: it might be better to do that simplification outside of show
10:11:23 <paolino> -XDeriveTraversable is depending anyway on writing Foldable
10:11:39 <EvanR> jmcarthur: any idea how to write a single . to a line?
10:11:49 <Jonny> I agree that would be best but I think it goes against the spec :\
10:12:43 <aavogt> paolino: you try  -XDeriveFoldable?
10:12:59 <Jonny> aavgot: can show be called recursively?
10:13:13 <paolino> aavogt: it wasn't suggested by compiler
10:13:15 <Eduard_Munteanu> Jonny: yes
10:13:41 <Eduard_Munteanu> Jonny: any function can as long as types are okay.
10:13:51 <aavogt> paolino: it might if you request that
10:14:10 <aavogt> I mean you can file a bug/feature request
10:14:33 <paolino> it suggested Functor only
10:15:19 <paolino> no it didn't , I dreamt it
10:15:47 <aavogt>  -XDeriveDreamable
10:17:41 <aavogt> FunctorSalad_: can has function serialization in ghc?
10:18:13 <FunctorSalad_> aavogt: it doesn't seem to display anything interesting for functions
10:18:48 <FunctorSalad_> just a single node FUN_STATIC or PAP
10:19:11 * hackagebot MonadCatchIO-transformers 0.2.2.1 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.2.2.1 (AriePeterson)
10:21:00 <paolino> traverse doesn't modify the structure, I cannot expand or contract a tree with traverse ?
10:21:25 <ziman> :t traverse
10:21:25 <lambdabot> Not in scope: `traverse'
10:21:31 <aavogt> right
10:22:27 <aavogt> ziman: traverse is mapM in disguise
10:25:20 <roconnor> traverse f = sequenceA . fmap f
10:25:23 <paolino> aavogt: to modify the structure only zippers are available ?
10:25:23 <roconnor> @src mapM
10:25:23 <lambdabot> mapM f as = sequence (map f as)
10:26:13 <aristid> :t sequence .: map
10:26:14 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
10:26:22 <aristid> :t sequence .: fmap
10:26:22 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
10:26:24 <aavogt> paolino: you can look at libraries like syb (scrap your boilerplate )
10:26:58 <Twey> traverse = fmap sequenceA . fmap; mapM = fmap sequence . fmap
10:27:03 <aristid> @pl (fmap.fmap) sequence fmap
10:27:03 <lambdabot> fmap (fmap sequence) fmap
10:27:15 <Twey> It's already point-free :-\
10:27:22 <aristid> Twey: i want more fmap!
10:27:24 <Twey> fmap fmap fmap sequence fmap
10:27:29 <Twey> :Ã¾
10:27:36 <aristid> :t fmap fmap fmap sequence fmap
10:27:37 <lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a1 -> m a) -> [a1] -> m [a]
10:27:41 <aristid> \o/
10:28:07 <Twey> Anywayâ€¦ the important part is the sequence vs. sequenceA
10:28:33 * aavogt wonders how Monad => Functor happened there
10:28:44 <aristid> :t sequenceA
10:28:45 <lambdabot> Not in scope: `sequenceA'
10:28:48 <Twey> aavogt: Hm?
10:29:06 <aavogt> oh list
10:29:15 * hackagebot blaze-builder 0.2.0.1 - Efficient construction of bytestrings.  http://hackage.haskell.org/package/blaze-builder-0.2.0.1 (SimonMeier)
10:29:22 <aavogt> :t fmap fmap fmap Data.Traversable.sequenceA fmap
10:29:23 <lambdabot> forall (f :: * -> *) a a1 (f1 :: * -> *). (Data.Traversable.Traversable f1, Applicative f) => (a1 -> f a) -> f1 a1 -> f (f1 a)
10:29:24 <Twey> Some of those fmaps are on list, some on function
10:29:31 <aristid> none on m
10:29:32 <engla> I wonder why it's called point free when in fact you use a lot of points (.) :-)
10:29:38 <aristid> engla: heh
10:29:40 <Twey> None on monads â€” that comes from the sequence
10:29:56 <aristid> engla: i used to wonder the same
10:30:09 <aristid> now i learned to stop worrying and love riding the bomb
10:30:23 <Twey> aristid: Then you learnt to use more fmap ;)
10:30:24 <engla> I suspected as much. I'll be there soon
10:30:27 <aristid> Twey: yes
10:30:49 <Twey> I prefer >>> really
10:30:52 <aristid> engla: i think the reason is that the x in \x -> f x is called a point
10:31:11 <aristid> Twey: that only works on categories (and monads if you use my package)
10:31:14 <Twey> I see how . makes sense, and it's consistent with the mathematical notation, but >>> is how I construct my pipelines, and it's consistent with >>=
10:31:33 <Twey> aristid: Functions are categories, though the â€˜originalâ€™ >>> is on arrows
10:31:34 <Eduard_Munteanu> engla: "point" as in "pointwise" in math, e.g. "pointwise convergence"
10:31:38 * ziman uses =<< and .
10:31:39 <Twey> (functions are arrows too)
10:31:45 <aristid> Twey: don't you use <=<?
10:31:46 <Twey> ziman: Yeah, I've taken to doing that often
10:31:56 <ziman> then I get: x <- foo . bar =<< baz
10:31:57 <Twey> aristid: Rarely, actually
10:32:10 <ziman> but yeah, it feels weird sometimes
10:32:17 <mercury^> Twey: what are the objects and arrows in the category of a function?
10:32:30 <Twey> mercury^: Don't ask me.  I just know >>> works on 'em.  ;)
10:32:47 <Twey> :t (>>>)
10:32:48 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
10:32:50 <mercury^> Twey: that means that functions are part of a category.
10:32:53 <Twey> :t (id >>> id)
10:32:54 <lambdabot> forall a. a -> a
10:33:01 <mercury^> (In this case Hask)
10:33:04 <aristid> mercury^: we love using category theory words without understanding them :)
10:33:15 <engla> BONUS: great website, best tutorial for any language that I have read. [I'm far from done reading it yet though]
10:33:19 <Twey> mercury^: Here it seems to suggest that cat = (->)
10:33:36 <mercury^> Twey: yep.
10:33:38 <aristid> Twey: category-extras defines Hask = (->)
10:33:58 <Pistahh> hell
10:33:59 <Pistahh> o
10:34:02 <Eduard_Munteanu> Where would I find a formal definition of Hask? Is there any? :/
10:34:14 <Eduard_Munteanu> Or is it a figure of speech?
10:34:20 <hpc> the h' spec, perhaps :P
10:34:32 <mercury^> Well, you have seen the definition just now.
10:34:34 <Eduard_Munteanu> Uh, I'll try and have a look.
10:34:36 <Pistahh> I'm using Data.Binary.Get on a ByteString to process some data but it throws an exception (out of data basically) - how could I catch that exception?
10:35:22 <Eduard_Munteanu> mercury^: I'm looking to see how universal is Hask in Haskell...
10:35:33 <Eduard_Munteanu> Also arrows have another cat
10:35:39 <mercury^> I don't understand you.
10:35:46 <aavogt> @hackage spoon Pistahh
10:35:46 <lambdabot> http://hackage.haskell.org/package/spoon Pistahh
10:36:15 <Pistahh> thanks
10:36:17 <Eduard_Munteanu> mercury^: I was just wondering what's there besides Hask and how much Hask covers.
10:36:30 <mercury^> Hask is the category of Haskell types and functions.
10:36:54 <aristid> mercury^: but not of Haskell values?
10:37:06 <Eduard_Munteanu> I think there was some other Category instance besides (->) = Hask.
10:37:21 <aristid> Eduard_Munteanu: Kleisli? :)
10:37:39 <Eduard_Munteanu> Hm, yeah, though that's kinda trivial.
10:38:00 <Eduard_Munteanu> And doesn't Hask subsume Kleisli?
10:38:08 <Eduard_Munteanu> Like >>> works in place of >=> I think.
10:38:20 <Eduard_Munteanu> :t (>=>)
10:38:21 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:38:24 <Eduard_Munteanu> :t (>>>)
10:38:25 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
10:39:12 <Eduard_Munteanu> > [5] >>= return
10:39:13 <lambdabot>   [5]
10:39:19 <mercury^> Kleisli categories are built from monads. Hask is equivalent to the Kleisli category of the identity monad.
10:39:22 <mercury^> Does that help?
10:39:36 <Eduard_Munteanu> Ah, yes.
10:39:38 <aavogt> Eduard_Munteanu: you need a newtype if you want >>> = >=>
10:39:38 <Eduard_Munteanu> Thanks.
10:39:51 <Eduard_Munteanu> I see.
10:40:15 <aristid> mercury^: hmm so you could have a dialect of haskell where every function returns a monadic value? :)
10:41:12 <mercury^> I don't know if there are any issues with the type system.
10:41:38 <aristid> then you could really use only >>> and would not need >=>
10:41:58 <aristid> which admittedly is a rather minimal benefit for completely changing the language
10:42:11 <copumpkin> aristid: we often assume that "pure" values sit in the Identity monad (functor) when we talk about polymorphic functions being natural transformations
10:42:17 <Eduard_Munteanu> How would you actually write monads then? :/
10:42:27 <aristid> copumpkin: and that's true in a way :)
10:42:28 <aavogt> huh, you could make  >>> = >=> but you can't use the  Category (->) instance
10:42:29 <hpc> transform over the identity monad
10:42:58 <hpc> though then you have the question of how to write the identity monad
10:43:11 <aristid> aavogt: i mean in a dialect of haskell where (->) is the kleisli version
10:43:14 <Eduard_Munteanu> like if you had return = id
10:43:39 <Eduard_Munteanu> It's not appparent to me how stuff will work.
10:46:23 <Eduard_Munteanu> @src Kleisli
10:46:23 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:46:41 <hpc> @google newtype Kleisli
10:46:42 <lambdabot> No Result Found.
10:46:45 <Eduard_Munteanu> Uh, category-extras I suppose.
10:47:05 <hpc> http://haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Arrow.html#t%3AKleisli
10:47:11 <aristid> Eduard_Munteanu: no
10:47:13 <Eduard_Munteanu> Thanks.
10:47:25 <aristid> but hpc showed you already where it is
10:47:30 <Eduard_Munteanu> :t (>=>)
10:47:30 <aristid> @src is not very complete
10:47:30 <lambdabot> Source not found. :(
10:47:31 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:47:45 <Eduard_Munteanu> Is this Caleskell then?
10:47:49 <aristid> no
10:47:55 <aristid> (>=>) is in Control.Monad
10:48:14 <hpc> Caleskell is almost entirely changes of Prelude
10:48:43 <Eduard_Munteanu> Ah, my bad, I think the description was "Kleisli arrow composition" or something like that.
10:49:13 <Eduard_Munteanu> which is different from a Kleisli category.
10:55:18 <aristid> Eduard_Munteanu: i think arrow composition is the same as category composition :)
10:55:31 <aristid> Eduard_Munteanu: it's just that arrows are longer in base
10:57:01 <osaunders> I've heard it said that the perfect number of arguments for a function is one. Is that suggesting that all function definitions should take one argument or that all functions should be curried?
10:58:05 <SubStack> all functions are curried
10:58:22 <Eduard_Munteanu> Perhaps uncurried?
10:58:23 <aristid> osaunders: all functions take one argument
10:58:31 <Eduard_Munteanu> :t uncurry
10:58:32 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:59:20 <aristid> :t let f a b c = undefined in uncurry f
10:59:21 <lambdabot> forall a b t a1. (a, b) -> t -> a1
10:59:30 <aristid> :t let f a b c = undefined in uncurry (uncurry f)
10:59:30 <lambdabot> forall a b t a1. ((a, b), t) -> a1
10:59:46 <aristid> :t let f a b c = undefined in curry (uncurry (uncurry f))
10:59:47 <lambdabot> forall a b t a1. (a, b) -> t -> a1
10:59:52 <aristid> :t let f a b c = undefined in curry (curry (uncurry (uncurry f)))
10:59:53 <lambdabot> forall a b t a1. a -> b -> t -> a1
11:00:52 <osaunders> aristid: What are you doing?
11:01:06 <aristid> osaunders: currying and uncurrying!
11:01:09 <Eduard_Munteanu> Yeah, as in lambda calculus, eventually all functions have a single argument.
11:01:31 <osaunders> Yes, I know all this. Now back to the question...
11:02:17 <osaunders> If I lack the precision of vocabulary to describe the question you'll just have to excuse me and try and interpret what it is I am asking.
11:02:49 <aristid> osaunders: if it's not precise enough, we will be very angry with you!
11:03:19 <osaunders> Are you serious?
11:03:37 <Twey> No.
11:04:44 <osaunders> OK, lets try this, what is the arity of (+)?
11:04:53 <aristid> 1
11:05:18 <osaunders> To yield an answer of 2, what question should I have asked?
11:05:29 <aristid> osaunders: well, it depends on which arity you want
11:05:47 <osaunders> Not the one you just gave me.
11:05:50 <aristid> osaunders: it is two if you ask how many applications you need until you don't get a function
11:06:03 <osaunders> OK, what is the term for that?
11:06:10 <aristid> not sure:)
11:06:14 <osaunders> FFS
11:06:21 <dominikh> currying is a related term
11:06:40 <osaunders> OK, let's give it the term "complete application".
11:06:47 <koala_man> how about the uncurried arity
11:07:15 <osaunders> So, now I revise my question: I've heard it said that the perfect number of arguments for a function is one. Is that suggesting that all function definitions should take one argument for a complete application or that all functions should be curried?
11:09:55 <Twey> osaunders: It's a hard question.  I personally would interpret it as meaning the former, with the latter being one method of achieving that end; this is only possible, though, because your â€˜complete applicationâ€™ is a rather poorly-defined term (there are many functions that can be usefully considered to have taken all the arguments they're intended to take at a point at which they still return a function).
11:10:59 <osaunders> Twey: Yes, I was just thinking about that.
11:11:06 <aristid> > (+) 1 2 3
11:11:07 <lambdabot>   3
11:11:21 <Eduard_Munteanu> Currying can't reduce the number of arguments.
11:11:36 <Eduard_Munteanu> I'm not sure what you mean.
11:11:48 <aristid> Eduard_Munteanu: uncurrying can
11:12:00 <Eduard_Munteanu> Yeah.
11:12:01 <syntaxglitch> in some sense, all functions take one argument either way.
11:12:01 <aristid> if you use complete application as the measure
11:12:22 <syntaxglitch> Either they take a single value and return a function, or they take a single tuple and produce a value
11:12:39 <syntaxglitch> that a tuple contains multiple values is kinda irrelevant
11:12:42 <engla> yuhuu.. haskell is absolutely crazy!  *goes back to tutorial*
11:13:31 <osaunders> But the person who said that thing must have intended to distinguish between functions that take a single argument and functions that take more otherwise they'd be no need to say it. If perfect functions take one argument and all functions take one argument then the number of arguments that functions take ceases to have any baring on their perfection.
11:14:16 <syntaxglitch> osaunders, I really can't speculate what the person who said that meant
11:14:28 <syntaxglitch> without context, it's so vague that it could easily be either
11:16:13 <osaunders> OK
11:16:55 <manateeUser> Night all. :)
11:17:24 <syntaxglitch> osaunders, I suppose you could interpret it as meaning that they think the equivalence I described should hold
11:18:30 <syntaxglitch> but that'd be a silly thing to suggest in a general mathematics context, and not a terribly useful statement in a programming context since it's almost always true
11:18:44 <osaunders> Yes
11:18:49 <stroan_> I'm having trouble making this type: Num a . (a -> a -> a) -> NumRealRep -> NumRealRep -> NumRealRep. Where NumRealRep has 2 constructors, one of which wraps an Integer and the other wraps a Float.
11:18:49 <Eduard_Munteanu> manateeUser: g'night
11:19:41 <Eduard_Munteanu> stroan_: should be (Num a) => ...
11:19:45 <stroan_> it seems to be forcing the operator to whichever type it sees first in the implementation
11:20:00 <stroan_> aye, my syntax is fine. unicode error with leksah / irssi
11:20:05 <aristid> stroan_: you need some conversion function
11:20:41 <Eduard_Munteanu> @src Integral
11:20:42 <lambdabot> class  (Real a, Enum a) => Integral a  where
11:20:42 <lambdabot>     quot, rem, div, mod :: a -> a -> a
11:20:42 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
11:20:42 <lambdabot>     toInteger           :: a -> Integer
11:21:27 <tonkman> is there mathematica-like PowerMode function for haskell?
11:21:33 <tonkman> *PowerMod
11:21:43 <stroan_> I never use the operator with two different types
11:21:45 <sipa> :t modPow
11:21:46 <lambdabot> Not in scope: `modPow'
11:21:47 <Eduard_Munteanu> tonkman: what does it do?
11:21:51 <sipa> :t powMod
11:21:52 <tonkman> raises a number to power n and counts modulo m
11:21:52 <lambdabot> Not in scope: `powMod'
11:22:05 <sipa> :t modpow
11:22:05 <lambdabot> Not in scope: `modpow'
11:22:08 <sipa> hmm
11:22:09 <stroan_> I just use the operator in two different contexts, in one given to floats, one given two integers
11:22:11 <tonkman> a^n `mod` m is too slow
11:22:19 <sipa> tonkman: should be easy to implement i think
11:22:19 <stroan_> two floats*
11:22:48 <tonkman> ok, I just thought that there could be one already
11:23:15 <tonkman> Im not sure how it is implemented in mathematica
11:23:22 <Eduard_Munteanu> tonkman: is it too slow on Integer or Int?
11:23:30 <tonkman> Integer
11:23:36 <tonkman> Im working on RSA
11:23:41 <Eduard_Munteanu> Oh.
11:24:01 <Eduard_Munteanu> I guess Int is out of the question.
11:24:31 <tonkman> just a school project, nothing serious
11:25:11 <tonkman> but still I want to use slightly bigger numbers
11:25:56 <Eduard_Munteanu> I'm not sure you're supposed to naively do powmod.
11:26:39 <Eduard_Munteanu> Look if there's a more efficient algorithm than the mathematical description of RSA.
11:26:59 <tonkman> Im aware of that
11:27:06 <Eduard_Munteanu> "This can be done quickly using the method of exponentiation by squaring."
11:27:15 <Eduard_Munteanu> from Wikipedia
11:27:17 <tonkman> but this is more a technical demo than something "real world"
11:27:21 <Eduard_Munteanu> tonkman: do you know how to do that?
11:27:25 <tonkman> nope
11:27:34 <Eduard_Munteanu> tonkman: simple example...
11:27:55 <sipa> i just implemented it in haskell.. you want to see it, or do you prefer to do it yourself?
11:27:59 <Eduard_Munteanu> a^6 = (a^2)^2) * a^2
11:28:04 <tonkman> sipa: please
11:28:34 <tonkman> Eduard_Munteanu: Ok, simple
11:28:37 <Eduard_Munteanu> a^9 = (a^2)^2)^2 * a
11:28:51 <sipa> http://hpaste.org/41255/modpow
11:28:56 <novicio> Hi! A question: In the type signature addVectors :: (Num a) => (a,a) -> (a,a) -> (a,a) the different a's do not have to be of the same type right? The signature only tells us that the types of the a's have to be included in the class Num right? That means I can add vectors off diferent Num types mixed, right?
11:29:00 <Twey> Trickier with odd and prime powers
11:29:05 <Eduard_Munteanu> tonkman: it's faster than simply multiplying with 'a' at every step
11:29:09 <pelotom> novicio: yep
11:29:17 <novicio> pelotom, thx
11:29:17 <stroan_> http://hpaste.org/paste/41254 here's a cut down example of the issue I'm having and the error I'm getting
11:29:28 <stroan_> The types seem like they should work to me
11:29:36 <pelotom> novicio: oops, I misread what you said
11:29:39 <tonkman> Im familiar with those modulo "tricks"
11:29:44 <pelotom> novicio: the a's all *do* have to be the same type
11:30:04 <tonkman> but implementing those is not trivial, at least not for me
11:30:11 <aristid> @pl f (a,b) (c,d) = g a b c d
11:30:11 <lambdabot> f = uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . g)
11:30:13 <damex> is code.haskell.org moved somewhere or still down?
11:30:21 <pelotom> novicio: it's a type variable; once you pick a type to substitute for a, you must stick with it
11:30:32 <tonkman> sipa: thank you a lot
11:30:44 <sipa> tonkman: there is a small mistake still
11:30:44 <novicio> pelotom: but if I call for example (3.0,4) (4,3) everything functions, no error - why?
11:31:04 <Eduard_Munteanu> novicio: 4 can be the same type as 3.0
11:31:11 <Eduard_Munteanu> > 4 :: Float
11:31:11 <lambdabot>   4.0
11:31:13 <pelotom> novicio: because it can infer that you're using all floats there
11:32:00 <aavogt> @pl f x y = uncurry (uncurry g x) y
11:32:00 <lambdabot> f = uncurry . uncurry g
11:32:04 <sipa> tonkman: move lines 5 and 6 in between lines 2 and 3
11:32:21 <aavogt> @type \f x y -> uncurry (uncurry g x) y
11:32:22 <lambdabot> forall t a b a1 b1 c. (Show a, Show b, Show a1, Show b1, SimpleReflect.FromExpr c) => t -> (a, b) -> (a1, b1) -> c
11:32:35 <tonkman> sipa: ok, thanks
11:32:41 <aavogt> @type \f x y -> uncurry (uncurry f x) y
11:32:42 <lambdabot> forall a b a1 b1 c. (a -> b -> a1 -> b1 -> c) -> (a, b) -> (a1, b1) -> c
11:32:43 <novicio> pelotom: So, I can call the function addVectors with Int, Integer, Double and Float mixed?
11:33:13 <Eduard_Munteanu> novicio: no
11:33:27 <pelotom> novicio: it'll infer the most general type that them all
11:33:36 <pelotom> that *contains* them all
11:34:17 <aavogt> pelotom: no
11:34:34 <pelotom> no?
11:34:47 <aavogt> > (1::Int) `asTypeOf` (1::Double) -- same reason as this
11:34:48 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:34:48 <lambdabot>         against inferred type ...
11:34:53 <Eduard_Munteanu> As in "not exactly", but 3 can be a representation of 3 :: Float
11:35:06 <pelotom> aavogt: that's not what I meant
11:35:14 <aristid> :t curry .: curry
11:35:15 <Eduard_Munteanu> It doesn't mean 3 is an Integer just because ".0" is missing.
11:35:15 <lambdabot> forall a b c a1. ((a1, (a, b)) -> c) -> a1 -> a -> b -> c
11:35:42 <aristid> :t let (.::) = fmap.fmap.fmap in curry .:: curry
11:35:43 <lambdabot> forall a b c a1 b1. ((a1, b1) -> (a, b) -> c) -> a1 -> b1 -> a -> b -> c
11:35:45 <Eduard_Munteanu> > 3 :: Float
11:35:46 <lambdabot>   3.0
11:35:50 <Eduard_Munteanu> > 3.0 :: Integer
11:35:51 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Integer.Internals.Integer)
11:35:51 <lambdabot>    aris...
11:35:51 <LordMetroid> Hmm, Oracle is kicking on Java so I am thinking I should start writing Haskell
11:35:54 <aristid> @let (.::) = fmap.fmap.fmap
11:35:55 <lambdabot>  Defined.
11:36:06 <pelotom> @type addVectors
11:36:07 <lambdabot> Not in scope: `addVectors'
11:36:11 <novicio> what would be a function call of addVectors that would produce an error?
11:36:15 <Eduard_Munteanu> There is no conversion taking place!
11:36:17 <sipa> tonkman: you understand it?
11:36:35 <pelotom> novicio: if you said addVectors (3::Int, 4.0) that would be an error
11:36:46 <Eduard_Munteanu> Indeed.
11:37:35 <novicio> Does not have 3::Int the same value as 3?
11:37:42 <Eduard_Munteanu> novicio: no
11:37:50 <pelotom> novicio: "3" by itself is not specifying a type
11:37:52 <pelotom> @type 3
11:37:53 <lambdabot> forall t. (Num t) => t
11:37:57 <Eduard_Munteanu> novicio: not if you ask whether 3 :: Int is equal to 3 :: Float
11:38:29 <Eduard_Munteanu> 3.0 is certainly a Float, but 3 could be either an Int or Float.
11:38:33 <sipa> novicio: in certain circumstances, depending on how you use it, '3' will be of type Int
11:38:36 <Eduard_Munteanu> (could be a Double too, though)
11:38:50 <sipa> but it does not need to be
11:38:54 <pelotom> 3 can be inferred to be any number you need it to be
11:39:08 <pelotom> sorry, any type of number
11:39:09 <novicio> I see, like it is said in "learn you a haskell" it is a kind of polymorphic constant
11:39:19 <pelotom> novicio: exactly
11:39:26 <Eduard_Munteanu> novicio: and note ':: Foo' isn't a cast or anything, it's merely specifying the type, not doing any kind of casting or conversion
11:40:08 <novicio> Eduard_Munteanu: you mean like saying: "Watch out, I want 3 to be understood as an Int!" ?
11:40:16 <pelotom> novicio: exactly like that
11:40:39 <Eduard_Munteanu> Yeah.
11:41:06 <pelotom> novicio: and as long as it's even possible to understand something as an Int, the compiler will comply
11:41:18 <pelotom> @type "hi" :: Int
11:41:19 <lambdabot>     Couldn't match expected type `Int' against inferred type `[Char]'
11:41:19 <lambdabot>     In the expression: "hi" :: Int
11:41:38 <Eduard_Munteanu> > (1 :: Int) :: Float
11:41:39 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
11:41:39 <lambdabot>         against inferred typ...
11:41:43 <aristid> there is no instance Num for [Char]
11:41:55 <Eduard_Munteanu> > 1 :: Float
11:41:56 <lambdabot>   1.0
11:42:12 <novicio> Now I get it. :-) Thanks alot, pelotom, Eduard_Munteanu!
11:42:14 <shachaf> > let x = 1 in x :: Float
11:42:14 <lambdabot>   1.0
11:42:17 <Eduard_Munteanu> In that case it was a contradiction.
11:42:21 <shachaf> Ah, lambdabot probably has that disabled.
11:42:34 <pelotom> novicio: np
11:42:37 <tonkman> sipa: yeah, I get it
11:49:02 <pelotom> it'd be cool if haskell had a "type application" syntax, e.g. `id {Int}` :: Int -> Int
11:49:44 <sipa> you have (id :: Int -> Int) :)
11:49:57 <copumpkin> @ ?
11:50:09 <mauke> type TId a = a -> a
11:50:09 <pelotom> copumpkin: oh, did I just embarass myself?
11:50:13 <mauke> id :: TId Int
11:50:24 <pelotom> is there already a syntax for this?
11:50:25 <copumpkin> pelotom: nah, but GHC core does have explicit type application syntax that is @
11:50:30 <copumpkin> but you can't write it
11:50:35 <pelotom> aw
11:50:50 <pelotom> copumpkin: not even thru an extension?
11:50:55 <copumpkin> nope
11:51:01 <pelotom> bummer
11:58:14 <mikeg> Do ByteString's Char8 and Word8 more or less share the same internals (similar memory use+speed), or is there an advantage to using one or the other, when I don't care if I get Word8's or Char's out?
11:58:36 <Twey> mikeg: They're exactly the same internally, I think
11:58:48 <Twey> Word8 is just an instance of Num and so on
11:59:01 <Enigmatic> use the Word8 instance if you don't care
11:59:09 <Enigmatic> Char8 will silently truncate unicode chars
11:59:43 <mikeg> And code involving Char (8bit)'s will generally take up more memory than Word8's, right?
12:00:42 <Enigmatic> a Char takes up more space than a Word8, yes.
12:00:57 <Enigmatic> but in the ByteString case, Char8 and Word8 have the same storage overhead.
12:01:20 <Twey> A Char and a Char8 are not the same thing
12:01:39 <Twey> A Char will take up more memory, and can represent any Unicode character, but a Char8 only takes a byte, the same as a Word8
12:01:49 <copumpkin> a Char8 isn't a type
12:04:37 <Twey> Huh, so it isn't â€” I guess it stores Word8 internally?
12:05:02 <copumpkin> ByteString.Char8 lets you stick Char into it and take Char out of it
12:05:11 <copumpkin> but it ignores anything above the low 8 bits
12:06:47 <Eduard_Munteanu> Are you aware of any bitstream implementation in Haskell?
12:07:23 <Eduard_Munteanu> I want it to pack/unpack arbitrary numbers of bits and convert them internally to bytes; I intend to use it to implement something like Shannon-Fano
12:23:23 <LordMetroid> Is OpenGL easy to work with in Haskell>
12:23:43 <tonkman> imo, is
12:24:01 <tonkman> ...depends on what you are doing
12:24:07 <hpc> depends on the package too
12:24:24 <hpc> graph packages are pretty much a solved problem
12:27:30 <number9> I am trying to figure out which GUI toolkit to learn right now it is between FranTK and Gtk2Hs, FranTK for its portability native look & feel and hopefully declarative nature, but hear more about Gtk2Hs, and appreciate glade, any input or reason that I shouldn't ignore wxHaskell?
12:27:51 <conal> LordMetroid: OpenGL is a low-level imperative API, even in Haskell.
12:27:56 <revenantphx> *sigh*
12:28:00 <revenantphx> I wish I has more time for haskell :(
12:28:02 <revenantphx> too much work.
12:28:27 <hpc> revenantphx: combine the two!
12:28:33 <revenantphx> Ive been trying.
12:28:44 <revenantphx> Right now I have two internships, and schoolwork.
12:29:05 <revenantphx> besides, I dread trying to get this very stateful simulation into haskell.
12:29:35 <hpc> State is a very simple monad to learn
12:29:55 <hpc> and StateT isn't conceptually any harder
12:30:52 <pelotom> monad transformers should be called "monad voltrons" instead
12:31:43 <hpc> comonads should be called "skeletors"
12:32:02 <conal> revenantphx: you might learn more if you rethink your stateful design and looked for a functional alternative.  (haskell can be used for functional programming, not just imperative.)
12:33:32 <MonadCaptainPlan> HeartT h SpiritT s FireT f Water ()!
12:34:07 <MonadCaptainPlan> oops I forgot wind or something
12:34:55 <MonadCaptainPlan> WITH OUR POWERS COMBINED
12:35:10 <nostrand> :D
12:36:32 <LordMetroid> I would like to write in Haskell but the severely BDSM-strict typing of Haskell scares me. I get so many complaints and I do not like to get scolded when I am programming!
12:36:48 <cizra> mm
12:36:48 <CaptainMonad> GOOOO MONAD!
12:36:56 <cizra> Ever tried to write C++?
12:37:03 <copumpkin> LordMetroid: as you get better, you avoid doing things that would make it scold you
12:37:22 <LordMetroid> I may have missed something but how easy is it to use OpenGL in Haskell
12:37:22 <sipa> the type system can be a bitch, but it has advantages af well... ofen, when your code compiles, it also means it works :)
12:37:23 <copumpkin> besides, being scolded by a compiler is nicer than being scolded by millions of users after deploying your app
12:37:24 <copumpkin> :P
12:37:33 <sipa> *often
12:37:37 <LordMetroid> I know in Java it is a mess as there is completely different paradigms
12:39:39 <LordMetroid> I like Erlang but Haskell has always been very alluring
12:44:13 <teratorn> E is a very awesome language, it just has no libraries
12:44:33 <teratorn> but you have access to java (yuck), or CL with E-on-CL
12:44:43 <boegel> good news everyone!
12:44:56 <boegel> I think attending BelHac got me back into Haskell, permanently
12:45:06 <medfly> never say ever
12:45:10 <boegel> meeting people like dons and dcoutts makes me want to code Haskell 24/7
12:45:17 <medfly> :-)
12:45:32 <Botje> boegel: hmm. I wanted to go but ..
12:45:32 <teratorn> reading Learn You a Haskell made me want to do that
12:45:35 <boegel> solidsnack: btw, loved your footwear
12:45:38 <Botje> nasty paper deadlines.. :(
12:45:42 <boegel> Botje: but?
12:45:58 <boegel> teratorn: oh, I met the author, had beers with him ^_^
12:46:14 <teratorn> BONUS sounds like a cool guy
12:51:31 <number9> any input on useable, portable, native looking and liberally liscenced graphical toolkits?
12:52:10 <teratorn> wx... gtk...
12:52:13 <teratorn> qt?
12:52:30 <Botje> swt
12:52:34 <Botje> but i think it's java only
12:52:58 <number9> thinking between gtk and FranTK mostly, not a big fan of the restrictions on qt
12:53:13 <teratorn> number9: you mean lgpl?
12:54:01 * hackagebot MonadCatchIO-transformers 0.2.2.2 - Monad-transformer compatible version of the Control.Exception module  http://hackage.haskell.org/package/MonadCatchIO-transformers-0.2.2.2 (AriePeterson)
12:55:17 <number9> teratorn: yeah though I guess there are options to change that
12:55:42 <boegel> fap fap fap, haha
13:02:59 <_y_> I seem to remember some blog entry written in the past year about writing a Haskell DSL lexer/parser for the PDF specification, and then parsing the specification directly, and how the author had revealed a number of inconsistencies in the format in such a way ... but my google-fu is failing me ... figured I'd ask in the Haskell nexus on IRC
13:06:48 <identity_> Any way to do a multi line do like this: foo <- do .. *newline* if condition *newline* etc
13:06:55 <identity_> Doesn't seem to want to parse
13:07:15 <sipa> if ... then ... else
13:07:18 <sipa> you need all three
13:07:23 <identity_> yes
13:07:27 <identity_> I know that much
13:07:41 <Saizan> the then has to be indented more than the if
13:08:10 <identity_> http://pastebin.com/TurQwtrw
13:08:45 <identity_> oh
13:08:47 <identity_> never mind
13:08:53 <identity_> Once again I fix it right after asking it
13:08:53 <ezyang> yer indents are wrong. 
13:09:06 <identity_> No?
13:09:07 <identity_> They're fine
13:09:20 <identity_> I removed the do and simply made it liftIO $ .. 
13:09:28 <identity_> foo <- liftIO $ *
13:09:53 <ezyang> Yes. When you have the do you need more indent. 
13:10:03 <identity_> how so?
13:10:16 <Saizan> no
13:10:33 <ezyang> oh. 
13:10:37 * ezyang goes and checks his ghc 
13:10:38 <Saizan> it's just that liftIO on the same like as the do fixed the indentation level
13:11:08 <Saizan> and the position of the if made it close that do-block
13:11:48 <ezyang> No, I'm right... 
13:12:00 <ezyang> Ok, sure :-) 
13:12:08 <identity_> Youy're definitely not being very specific in your explanation
13:12:10 <Saizan> *same line
13:12:11 <ezyang> "you need more indent on the if block" 
13:13:44 <hush2> is there something similar to pypi for haskell?
13:13:51 <ezyang> hush2: Hackage. 
13:14:12 <hush2> alright thanks
13:14:20 <kmc> http://hackage.haskell.org/packages/archive/pkg-list.html
13:14:41 <kmc> this will sound bitchy but i think it's best to describe what you want, rather than asking for an equivalent to something from another language, which we may or may not know
13:14:47 <hush2> yeah thats it
13:15:07 <pygmalion> If I wanted to set up a web interface for a MySQL database (something I would typically do in PHP) as a learning experiment with Haskell, what would be the best framework(s)/Apache modules etc. to use? I am assuming I will utilize HDBC-mysql as well.
13:16:03 <pygmalion> or is it not worth my time.
13:16:28 <kmc> how much Haskell do you know?
13:17:12 <pygmalion> pygmalion: About eight weeks of an honors university course worth. 
13:17:26 <pygmalion> whoops that should've been to kmc
13:17:52 <dolio> dolio: You're awesome!
13:18:18 <pygmalion> ha ha
13:18:41 <shachaf> dolio: You're awesome!
13:18:46 <shachaf> Whoops, meant to address that to shachaf.
13:18:47 <dolio> Yow!
13:19:33 <pygmalion> kmc: what's the verdict?
13:20:04 <shachaf> pygmalion: How much is that?
13:20:53 <kmc> pygmalion, well, it's certainly doable
13:21:04 <kmc> web frameworks for haskell include happstack, snap, and yesod
13:21:11 <kmc> but you asked "is it worth my time"
13:21:16 <kmc> and to answer that i have to know what your goals are
13:21:37 <pygmalion> shachaf: Not sure how to quantify it. I can tell you specific things that we've learned about if you thing there are important elements.
13:22:26 <pygmalion> kmc: dual goals of completing this relatively quickly and learning something in the process that i can take back to my Haskell class
13:22:46 <kmc> ok
13:22:55 <kmc> i don't think it's a good idea for the first goal
13:23:03 <kmc> and i don't think webdev is a good showcase for Haskell's strengths
13:23:07 <kmc> but i haven't done any Haskell webdev
13:23:16 <pygmalion> kmc: ah okay fair enough.
13:23:23 <pygmalion> thanks
13:24:01 <Cale> Yesod is turning into its own language with all the quasiquoters that it uses :)
13:25:42 <pygmalion> Cale: yeah i started skimming the Yesod book and was slightly discouraged but I have seen a few other more minimalistic frameworks
13:26:46 <merijn> kmc: Actually, some of the example web coding stuff I saw done in Haskell looked pretty slick
13:27:21 <merijn> Such as someone using introspection to automate rendering HTML forms from a type
13:29:34 <kmc> that's cool, but probably much easier in a dynamic language
13:29:55 <kmc> anyway bbl
13:37:35 <Jonny> I've added     show ( Id x ) 		  = show x           to the show class, so when I type in:    > Id "x"
13:37:38 <Jonny> it returns "x"
13:37:49 <Jonny> but is there a way for it to return    x    without the paranthases
13:37:54 <Jonny> parentheses*
13:38:14 <sipa> show i = case i of Id x -> show x
13:38:16 <sipa> :p
13:39:14 <Jonny> that doesnt work I'm afraid
13:40:33 <hpc> :t lookup
13:40:34 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:40:36 <Lemmih> Jonny: You want to do what?
13:40:38 <hpc> :(
13:41:03 <Jonny> I want to edit the show class so that when I type in:     > Id "x"
13:41:06 <Jonny> it outputs     x
13:41:11 <Jonny> without the parenthesis
13:41:23 <Lemmih> Jonny: That's not possible. 'show' gives you a String.
13:41:55 <Lemmih> Jonny: And Strings are printed with quotes.
13:42:35 <Lemmih> Jonny: This will do the trick, though: putStrLn (show (Id "x"))
13:43:45 <Lemmih> Jonny: You could also do: newtype MyWeirdString = MyWeirdString String; instance Show MyWeirdString where show (MyWeirdString str) = str
13:43:56 <Jonny> thanks
13:44:46 <Jonny> but howcomes that when I've added this line to the show class:  show ( App "sin" [ x ] ) = "sin(" ++ show x ++ ")"
13:45:11 <Jonny> when I type in    > App "sin" [ 30 ]
13:45:17 <Jonny> it outputs sin 30  without the parenthesis
13:45:30 <A1kmm> Has anyone else seen this: "cabal: Codec.Compression.Zlib: premature end of compressed stream" on Cabal update with cabal-install-0.8.2
13:45:40 <Botje> Jonny: that can't happen
13:45:44 <A1kmm> I found a bug report for 0.8.0 which implied it had been fixed.
13:46:00 <Cale> Jonny: I don't think parenthesis means what you think it does.
13:46:11 <stepcut> Jonny: is 30 an an number (Int, etc) not a String?
13:46:13 <Cale> (this is in parentheses)
13:46:20 <Cale> "this is in quotation marks"
13:46:26 <Jonny> oh god sorry
13:46:30 <Jonny> I meant quotation marks
13:46:30 <monochrom> but the string is explicitly "sin(" and ")
13:46:44 <A1kmm> And in my case it occurs even after removing ~/.cabal, ~/.ghc, /usr/lib/ghc-*, and /usr/local/lib/*/ghc-*, and reinstalling ghc and re-running cabal-install/bootstrap.sh
13:47:17 <Lemmih> Jonny: That's the same as writing: print (App "sin" [ 30 ])
13:47:19 <A1kmm> (it worked fine on the same system on Ubuntu 10.04, the problem was first noticed after upgrading to Ubuntu 10.10, so it could be related to system libraries)
13:48:02 <Lemmih> Jonny: You'd get the same effect with MyWeirdString.
13:48:25 <A1kmm> and monitoring it in Wireshark shows that the cabal-install closes the connection before the download of the package index is finished.
13:50:19 <monochrom> Jony: http://codepad.org/jzaKk5qL
13:52:26 <osaunders> How long is an overlong pattern match?
13:52:27 <Jonny> thanks, I understand
13:52:41 <osaunders> This is pretty long:
13:52:42 <osaunders> nextAppleState (GameState (SnakeState snake _) level (AppleState (Apple n co) rGen)) =
13:53:33 <Cale> Jonny: A general principle for the design of instances of the Show class is that as much as possible, the result of applying show to a value should be valid source code for constructing the value. So, if the value is a String, it gets quoted.
13:53:58 <Jonny> ok
13:54:20 <A1kmm> hmm, I'm going through a couple of transparent proxies which add extract headers at the moment, maybe that is causing cabal-install / the HTTP library problems.
13:54:25 <Cale> And when ghci prints a value in response to an expression that you typed, it applies show to it.
13:54:40 <Cale> So if the value was a string, it will get quoted for display.
13:54:52 <Saizan> A1kmm: there's a ticker about that
13:59:35 <gwern> hm. my web archiver program is more than a screen long. I need to start golfing it
14:00:18 <dmwit> nnnnooooooooo
14:00:22 <dmwit> resist the golf!
14:00:43 <Heffalump> Saizan: which we could read if only code.haskell were working? :-)
14:01:23 <Saizan> Heffalump, A1kmm: http://hackage.haskell.org/trac/hackage/ticket/686 <- works!
14:01:37 <Saizan> different server, i guess
14:01:38 <monochrom> I know an algorithmic way to convert one long module into many small modules.
14:02:32 <douglaz> Hello, I'm just learning haskell and I was wondering how I could write a program like that: http://hpaste.org/41258/freq_count (in fact I'm just interested on the frequency count function, not the I/O part)
14:02:50 <Heffalump> Saizan: ah, hackage is on the same server as the GHC trac
14:02:59 <mauke> douglaz: Data.Map
14:03:09 <Cale> douglaz: Look at the group function in Data.List
14:03:17 <Cale> > group "aaabbbccbbaaa"
14:03:18 <lambdabot>   ["aaa","bbb","cc","bb","aaa"]
14:03:22 <Cale> > group . sort $ "aaabbbccbbaaa"
14:03:23 <lambdabot>   ["aaaaaa","bbbbb","cc"]
14:03:25 <Heffalump> actually, I think I've run into that problem at work too
14:03:37 <Cale> > group . sort . words $ "a a a b b b c c b b a a a"
14:03:38 <lambdabot>   [["a","a","a","a","a","a"],["b","b","b","b","b"],["c","c"]]
14:03:39 <Heffalump> we have a virus scan in there somewhere so it probably decompresses at the same time
14:03:54 <Cale> > map (length &&& head) . group . sort . words $ "a a a b b b c c b b a a a"
14:03:55 <lambdabot>   [(6,"a"),(5,"b"),(2,"c")]
14:05:06 <douglaz> humm
14:05:51 <monochrom> @type foldl'
14:05:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
14:06:10 <gwern> dmwit: why? it's more readble?
14:06:23 * gwern moans: BREEVVVITTTTYYYYY
14:08:43 <A1kmm> Saizan: Thanks - I'll try the latest cabal-install from Darcs and see if that patch fixes it.
14:10:12 <douglaz> mauke, nice, I didn't know this module
14:10:57 <douglaz> Cale, thanks, it's a very good solution
14:14:02 <monochrom> douglaz: http://hpaste.org/paste/41258/freq_count#p41259
14:17:22 <Mitar> help: http://hpaste.org/41260/convert_to_monad
14:19:24 * monadic_kid wished people would stop using signed integral types for counts/sizes when they should never be negative numbers
14:19:47 <Zao> monadic_kid: How else are you going to represent the magic sentinel values?
14:20:13 <Zao> monadic_kid: They do have benefits though, as you tend to often want to do arithmetic with them.
14:20:52 * monochrom wishes type zealots would go all out for dependent predicate subtype
14:21:29 <monadic_kid> Zao: when you actually need to do that use -1, Maybe, or signed integral type, all other times it is completely unnccessary and should be inforced with the type
14:23:18 <monadic_kid> Zao: does it makes sense to have an function that deals with width/height or position within an offset within an image/surface using signed integral type? that just opens up for error
14:23:31 <dolio> Dependent predicate subtype?
14:24:04 <dmwit> :t sequence -- Mitar?
14:24:05 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
14:24:22 <dmwit> It doesn't do bracketing, of course.
14:24:41 <dmwit> But perhaps the bracketing can be done inside each IO Growable.
14:24:45 <monadic_kid> Zao: if you're dealing with functions that return indicies with a possible failure (like indexOf) then it might make sense to use a signed integral type
14:25:11 <dolio> Nah.
14:25:17 <dmwit> Mitar: You may also like
14:25:20 <dolio> Then it makes sense to return a Maybe.
14:25:28 <monochrom> such as "this function maps x, of type (odd prime number), to type (mersenne prime bigger than or equal to x)"
14:25:49 <dmwit> ?unmtl MaybeT IO Growable
14:25:49 <lambdabot> IO (Maybe Growable)
14:25:49 <dolio> Refinement types?
14:26:05 <dmwit> ?unmtl MaybeT IO [Growable]
14:26:05 <lambdabot> IO (Maybe [Growable])
14:26:26 <monochrom> if you want to use types to enforce things, merely "signed int" vs "unsigned int" is wimpy. you will need "int bigger than or equal to x" eventually.
14:26:30 <dmwit> sequence ~:: [IO (Maybe Growable)] -> IO (Maybe [Growable])
14:27:36 <dolio> I guess you might not care exactly how that is presented.
14:28:05 <Rembane> I want "int within interval x - y"
14:28:43 <rcharles> Is there any program for beautifying haskell code?
14:28:47 <dolio> n : Odd versus Sigma (n : Nat) (Odd n)
14:28:48 <CaptainMonad> "int between x and y" requires dependent typing, where as "natural" is perfectly well definable in haskell
14:29:15 <CaptainMonad> whereas*
14:31:45 <douglaz> Cale, this &&& operator is the one from Control.Arrow?
14:31:54 <roconnor> douglaz: yes
14:31:56 <Mitar> hmm
14:32:32 <Mitar> ok, but don't you agree that current growNeurons looks like it could be transformed?
14:32:43 <dobblego> how do I configure cabal to have an executable Main module that depends on another module in the same package?
14:32:48 <Mitar> it is in continuation pass style already
14:34:05 <Cale> douglaz: If you prefer, a lambda will do about as well...
14:34:15 <stroan_> sorry, to post this again, but I'm still stumped by it.                  do work :(
14:34:26 <stroan_> http://hpaste.org/paste/41254
14:34:27 <Cale> map (\x -> (head x, length x)
14:34:31 <Cale> er, tsk, )
14:34:34 <stroan_> do work was not intended to be what I pasted :P
14:35:16 <dolio> dobblego: How do you mean? That's pretty much automatic. Or do you mean that the other module gets installed as a library, and then the executable depends on it?
14:35:32 <dobblego> dolio, I think I want Extra-Source-Files -- just testing
14:35:44 <stroan_> I have no idea how to construct the right type for what I intend if it's not that
14:36:22 <dobblego> dolio, that's what I was missin
14:36:22 <Cale> stroan_: The function's type signature says that for any type a, so long as a is an instance of Num, the function func will take a function of type (a -> a -> a), and a couple values of type Foo, and produce a value of type Foo
14:36:33 <aristid> stroan_: the code compiles but gives runtime errors?
14:36:39 <stroan_> compile time error
14:36:40 <Cale> stroan_: What you probably want is for the function to require a polymorphic function as its parameter
14:37:03 <stroan_> Cale: indeed. And I thought that's what I specified.
14:37:04 <Cale> stroan_: That would be:  func :: (forall a. Num a => a -> a -> a) -> Foo -> Foo -> Foo
14:37:05 <dolio> Okay.
14:37:16 <Cale> instead of:
14:37:26 <Cale> func :: forall a. Num a => (a -> a -> a) -> Foo -> Foo -> Foo
14:37:40 <Cale> (The forall is implicitly at the top level of the type signature)
14:38:42 <stroan_> ah kay. I see why I need to specify a polymorphic function. I'm just not completely sure why what I wrote isn't.
14:38:57 <douglaz> monochrom, thanks for the code using Map
14:39:17 <Cale> stroan_: It's all about where the 'a' is selected. The type signature you provided means that I would be okay just passing a function of type (Int -> Int -> Int)
14:39:27 <Cale> Or just (Float -> Float -> Float)
14:39:42 <Cale> and func would have to deal with it
14:40:08 <stroan_> ah, now I see it
14:40:13 <stroan_> cheers
14:40:16 <Cale> (because it's supposed to work no matter what type 'a' is)
14:40:18 <Cale> yeah
14:46:11 <Mitar> still puzzled by: http://hpaste.org/41260/convert_to_monad
14:46:19 <Saizan> dobblego: for haskell modules you should use other-modules
14:46:31 <dobblego> Saizan, ok cheers
14:46:41 <halberd> hey suppose you have a computer like a Turing machine except instead of having an ordered list of symbols for your tape, you have a number of unordered sets
14:47:11 <stroan_> Cale: that all works perfectly. Thanks for that.
14:47:24 <halberd> at each step the Turing machine may mark an element of any set as viewed, mark an element of the set as unviewed, find the next viewed element of the set, or find the next unviewed element of the set
14:47:35 <halberd> is this equivalent in power to a regular Turing machine?
14:48:19 <dmwit> halberd: Sounds homeworky.
14:48:23 <halberd> it's not
14:48:37 <ezyang> halberd: I think so. 
14:48:48 <halberd> the elements of the sets are chosen from a finite alphabet and they are multisets
14:49:10 <ezyang> In particular, sets seem to give you random access memory but by Von Neumann this is known not to give you more computational power, just better efficiency. 
14:49:27 <halberd> well the question is whether it has less power than a turing machine
14:49:30 <halberd> of course it doesn't have more
14:50:06 <roconnor> unordered sets can simulate ordered sets and vice versa, right?
14:50:58 <ezyang> On an unrelated note, is the universe uncomputable? 
14:51:01 <A1kmm> Saizan: Turns out it is obviously a different bug - it still gets the same error with the latest Darcs versions of Cabal and cabal-install
14:51:30 <halberd> roconnor, only if the unordered sets can contain other sets
14:51:37 <Saizan> A1kmm: or maybe the fix is incomplete, though i'm not familiar with the details
14:51:37 <halberd> in this case the elements of the sets are drawn from a finite alphabet
14:51:41 <roconnor> oh
14:51:43 <roconnor> ok
14:52:01 <ezyang> I'm still guessing yes, but I'll have to think this through more carefully. 
14:52:21 <dobblego> Saizan, my version of cabal doesn't seem to recognise other-modules
14:52:30 <yav_> do we have any GHC hackers logged in?
14:52:59 <ezyang> halberd: What do you mean by "find"? as in "read"? 
14:53:01 <dmwit> yav_: #ghc
14:53:02 <roconnor> yav_: see #ghc
14:53:15 <yav_> ah, thanks, i'll try that
14:53:21 <ezyang> In which case, I think I can just encode a traditional turing tape with your set of sets of lexicographical elements. 
14:53:30 <Saizan> dobblego: weird, maybe you're filling it with file names instead of module names?
14:54:04 <dobblego> Saizan, nope; also the error message makes it clear "Warning: CheckoutAll.cabal: Unknown fields: other-module (line 12) Fields allowed in this section:..."
14:54:17 <dobblego> oh also other-modules (I removed the s for giggles)
14:55:09 <halberd> ezyang, the sets are only sets of the alphabet elements
14:55:11 <halberd> they are not sets of sets
14:55:34 <ezyang> Multisets of alphabet elements then? 
14:55:36 <halberd> yes
14:55:37 <ezyang> Still think it works. 
14:55:38 <halberd> and find = read
14:55:51 <halberd> so for example you can iterate over a set
14:56:00 <Saizan> dobblego: are you putting it inside the Executable section?
14:56:04 <halberd> by repeatedly marking an element as viewed, and then finding the next element
14:56:12 <dobblego> Saizan, I tried it there as well
14:56:15 <ezyang> Do something silly like . = 1, .. = 2, ... = 3, maybe use - for negation, and then some other symbol to represent marked or unmarked. 
14:56:16 <pelotom> a turing machine is really an overly complicated model of computation
14:56:20 <halberd> and then at the end, repeatedly marking each element as unviewed, and then finding the next viewed element, to clear it
14:56:32 <dobblego> Saizan, er I thought I had 
14:56:55 <dobblego> Saizan, cheers
14:56:58 <aristid> packages should not depend on QuickCheck if they are not testing packages *declare*
14:57:05 <halberd> of course one question is how to even encode a complex string
14:57:10 <halberd> using a finite number of multisets
14:57:13 <Saizan> dobblego: np
14:57:29 <halberd> how could you encode a bit string using a finite number of multisets?
14:57:40 <ezyang> As described above. 
14:57:47 <aristid> haha, wonderful, Crypto installs binaries with wonderful names like SymmetricTest
14:59:35 <halberd> no I think it is not equivalent in power
14:59:52 <halberd> how would the machine read the next or previous bit in that encoding?
15:00:40 <halberd> hmm well we can divide the number of elements in the set by 2 by marking every other one as visited
15:01:14 <halberd> no but we would not know when we are done
15:02:18 <halberd> I think we should get rid of marking elements as viewed or unviewed, but rather just as adding or removing elements from a set
15:02:42 <halberd> at each step we can add or remove an element from a set, or pick a random element from any set
15:04:19 <pelotom> If a logical system S is consistent, then S + "S is inconsistent" is also consistent #boggle
15:04:30 <Veinor> wait, what?
15:04:37 <Veinor> oh yeah
15:04:50 <halberd> I think it's then equivalent just to a register machine
15:04:52 <Veinor> assumgin you can express "S is inconsistent" inside S
15:05:15 <pelotom> veinor right
15:05:57 <Veinor> because you can't prove S is consistent within S, unless S isn't powerful enough to express "S is consistent" inside itself... agh
15:06:19 <dolio> That's not necessarily true.
15:06:20 <pelotom> Veinor: exactly :)
15:06:58 <pelotom> dolio: how so?
15:06:59 <dolio> There are systems that are strong enough to express 'S is consistent' without being subject to Goedel's incompleteness theorem.
15:07:12 <pelotom> dolio: orly?
15:07:23 <dolio> Look up self-verifying theories by Dan Willard.
15:07:39 <pelotom> systems which can't support basic arithmetic but which can talk about their own consistency?
15:07:55 <dolio> Generally you can't prove multiplication is total in them.
15:08:03 <dolio> So, that's kind of a bummer.
15:08:10 <dmwit> If you could prove "S is consistent" in S, would you trust that proof? You can prove it whether or not S is consistent...
15:08:15 <dolio> I think you get addition, though.
15:08:33 <pelotom> dmwit: not prove, assume as an axiom
15:09:03 <pelotom> S + "S is consistent" means, take "S is consistent" as an axiom in addition to all the theorems of S
15:09:22 <pelotom> "S is inconsistent" i mean
15:09:24 <dmwit> You're making claims about S + "S is inconsistent", not S + "S is consistent".
15:09:24 <pelotom> but either way
15:09:38 <dmwit> I'm mostly musing about a totally unconnected thing.
15:09:39 <pelotom> dmwit: typo :)
15:09:40 <dolio> The folks back in the early 1900s really wanted their theories to prove their own consistency, though.
15:09:50 <dolio> And thought that would make everything kosher.
15:09:57 <pelotom> dolio: fools!
15:10:02 <dolio> I don't really understand why they thought that, though.
15:10:17 <dolio> Even in the absence of Goedel's theorem, that doesn't hold.
15:10:49 <nus> so you have to define "is" and "consistent" in S-terms?
15:11:24 <pelotom> well... aside from proving their own consistency I think what they were really after was being able to prove everything that is true, with enough axioms
15:12:01 <Veinor> how can you prove that logic is consistent, maaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaan?
15:12:15 <dolio> Yeah. I guess that makes the first theorem more devastating.
15:12:41 <dolio> People frequently act like the second one is the bigger problem, though.
15:12:45 <ddarius> Veinor: Assume it as an axiom.
15:14:05 <dankna> I think that's similar to what we "really do"
15:14:43 <dankna> in "hypothetical logic system S-omega", defined as the logic system to which you must adhere if you want to get a paper published
15:15:25 <dankna> for example, nobody would accept a paper "Theorem: 2^n + 3^n = 5^n for all n.  Proof: Assume the theorem as an axiom.  QED."
15:16:11 <dankna> but we can't agree on what logic we actually must adhere to to be discussing something that relates to the real world
15:16:17 <dankna> which is why it's a hypothetical system
15:16:37 <monochrom> we agree on a subsystem
15:16:38 <pelotom> dankna: no one would accept that because that axiom would make the system inconsistent :)
15:16:43 <dankna> haha
15:16:46 <dankna> true too
15:16:51 <Cale> dankna: That's more because it's a boring proof than anything else.
15:17:07 <dankna> Cale: perhaps so.  in which case my concept of hypothetical logic system S-omega doesn't make sense.
15:17:18 <pelotom> inconsistent systems are not interesting. everything is provable in them, and everything is true
15:17:20 <dankna> Cale: but I'd like to think that there is a line somewhere that if you cross it you get labeled as illogical.
15:17:20 <Cale> If you could prove 2^n + 3^n = 5^n in a sufficiently interesting way, in an interesting setting, then your paper might get accepted ;)
15:17:30 <pelotom> they're degenerate
15:17:38 <dankna> hmm.
15:17:39 <dankna> maybe.
15:18:01 <Cale> pelotom: *Unless* there's more to the meaning of the proofs than just determining the truth/falsity of statements.
15:18:26 <pelotom> Cale: there isn't... proof irrelevance :)
15:18:31 <Cale> pelotom: For example, Haskell as a type system is inconsistent (every type has a member), but it's still quite an interesting system.
15:18:44 * dankna blinks
15:18:45 <dmwit> pelotom: Or nothing is provable, and nothing is true. But it's not quite as common for some reason. =)
15:18:48 <Twey> Void!
15:18:50 <pelotom> Cale: that's because Haskell isn't a proof system
15:19:04 <dankna> dmwit: haha
15:19:09 * ddarius will find an inconsistency in set theory and then collect all of the Millennium Problems.  I'll be nice and prove P = NP rather than P /= NP for you guys.
15:19:17 <Cale> It is a proof system, it's just an inconsistent intuitionist one with an interesting semantics.
15:19:49 <dmwit> I just read a Ted Chiang story in which the main character finds a proof that 1 = 2 (without using the usual divide-by-zero or other undefined behavior tricks).
15:19:55 <pelotom> Cale: it is a proof system where I can prove anything, therefore it's useless as a proof system
15:20:01 <dmwit> quite amusing
15:20:11 <dankna> dmwit: so did he go to court to argue that his bank account contained a million dollars?
15:20:21 <Twey> Heheh
15:20:24 <dankna> dmwit: and that the bank was in the wrong not to recognize this? :)
15:20:24 <Cale> You can prove anything, but some things only have boring proofs.
15:20:45 <ddarius> dankna: Yes, but they successfully counter-argued that his bank account contained zero dollars.
15:20:52 <dankna> haha, nicely done
15:20:56 <copumpkin> pelotom: if you're using the type system to show any interesting properties about your program, I'd say that's some form of proof. Sure, it may not be 100% trustworthy but it does catch common cases and if you avoid undefinedness you're generally okay
15:21:21 <dmwit> spoilers: ...ab, fur pbzzvggrq fhvpvqr
15:21:50 <pelotom> copumpkin: ok... assuming a subset of haskell without bottom, I suppose it's a proof system
15:22:05 <dolio> Even with bottom it can be a proof system.
15:22:18 <ddarius> You just need to normalize the proof terms.
15:22:23 <pelotom> dolio: sure, an inconsistent one
15:22:23 <dankna> dmwit: ah - that's a shame
15:22:27 <copumpkin> it's a "pretty sure it's right" system, maybe, instead of a proof system
15:22:27 <dolio> You just have to keep checking the proofs to make sure they normalize.
15:22:30 <ddarius> (If you want an actual proof.)
15:23:34 <dankna> the irony is that I came here to make my head hurt less
15:23:42 <dankna> because I needed to de-stress after reading a difficult paper
15:23:51 <copumpkin> ddarius: you wouldn't happen to know much about .msi files on windows?
15:24:02 <Cale> dankna: Nice try
15:24:09 <dankna> Cale: indeed
15:24:42 <ddarius> copumpkin: I know what they are and I've probably made a few with tools (Visual Studio), but I don't have any special knowledge.
15:25:12 <ddarius> dankna: Start reading through TTT, then you can read that paper to wind down.
15:25:38 <dankna> hahahahaha
15:25:39 <dankna> noted
15:25:59 <ezyang> What is TTT? 
15:26:01 <dankna> what is ....
15:26:03 <dankna> TTT?
15:26:10 <dolio> Toposes, Triples and Theories.
15:26:17 <ezyang> Mmmm. Evening math. 
15:26:57 <nus> ...then find yourself reading in early morning.
15:27:55 <pelotom> bad idea to read math late at night...
15:28:09 <pelotom> category-theory-induced insomnia is not fun
15:28:13 <dankna> indeed
15:28:20 <dankna> "Can't.... sleep... not sure I exist..."
15:28:22 <ddarius> pelotom: What are you talking about ?!
15:28:36 <dolio> It's the best kind of insomnia.
15:28:41 <pelotom> I mean it's sorta like alcohol... it's fun at the time, but you pay for it the next day
15:28:44 <monochrom> TTT is Theory of Theories of Theories
15:28:55 <companion_cube> rather "can't... sleep... must compile... kernel..."
15:29:08 <dankna> hmm
15:29:10 <monochrom> can't sleep has new modem
15:29:12 <dankna> TTT is available for free in pdf form, it seems
15:29:17 <ddarius> Yes.
15:29:19 <koninkje> http://www.cwru.edu/artsci/math/wells/pub/ttt.html
15:30:08 <Cale> Sleepy mathematics: Duuuude, what if every structure that humans could possibly find interesting is some composite of a certain finite set of operations applied to higher dimensional categories?
15:30:20 <A1kmm> It looks like the reason "cabal update" doesn't work for me can't be solely because of the proxy sending decompressed data - I hacked cabal-install to send "Accept-Encoding: gzip"
15:30:45 <A1kmm> which makes the proxy send compressed data again - but it still gets the same error despite the data being sent being valid compressed data.
15:30:53 <ddarius> Cale: Unfortunately, that creates objects that are interesting because they aren't such a composite.
15:30:57 * pelotom adds TTT to his Dropbox
15:31:03 <A1kmm> (and still disconnects from the HTTP stream early).
15:31:09 <ddarius> pelotom: Have fun.
15:31:22 <pelotom> :)
15:34:00 <Cale> ddarius: It sometimes feels as if every sort of diagram we could possibly draw will probably show up in some natural way in higher dimensional CT.
15:34:20 * dankna also adds TTT to his to-read list
15:34:59 <dobblego> is there any way to cabal list against a specific source when you have more than one (hackage) source
15:35:04 <pelotom> well every graph has a free category
15:35:59 <rovar> I have just discovered (embarassingly recently) Tangible Values.  I don't see anything on this topic in any recent papers or posts. I am particularly interested in developing frameworks for enterprise level data translation and migration.   In this light, is it fairly safe to assume that the concept of TV was subsumed by FRP? 
15:36:38 <rovar> they seem to overlap, but I don't know if I'm missing something important
15:36:50 <dolio> That'd be a little weird considering FRP came first.
15:37:08 <rovar> a little 
15:37:15 <rovar> but not impossible
15:37:21 <BleuM937> gday
15:37:32 <ddarius> Cale: You should read Gray's "Formal Category Theory: Adjointness for 2-categories" which contains quotes like "It turns out that in the things treated in Parts III and IV - fibrations, the Yoneda lemma, adjointness, etc., -- the crucial structure is provided by the functors and natural transformations between 3 and 2x2." and "All this structure transports itself throughout Cat by exponentiation."
15:37:39 <dolio> Conal may have changed his vocabulary.
15:37:46 <dorkitude> what's TTT?  is there a PDF?
15:38:34 <dolio> Read the chat log from 10 minutes ago.
15:38:58 <rovar> looking at Conal's papers and his tech talk. It seems like the evolution is towards FRP. It seems that the subject of TV drops off,  but I don't see anything that directly says, TV is dead, long live FRP. 
15:39:07 <BleuM937> Noobie question, how do I use a String as [Char]?
15:39:16 <Cale> ddarius: That already makes some amount of sense out of context, though I'll have to read it and understand it properly to see if it really means what I think it does.
15:39:22 <dmwit> BleuM937: A String *is* a [Char].
15:39:41 <dmwit> :t take 30 :: String -> String
15:39:42 <lambdabot> String -> String
15:39:48 <dmwit> :t take 30 :: [Char] -> [Char]
15:39:49 <lambdabot> [Char] -> [Char]
15:39:58 <koninkje> BleuM937: String *is* [Char]
15:40:01 <BleuM937> That's what I thought
15:40:03 <dmwit> ?src String
15:40:03 <lambdabot> type String = [Char]
15:40:14 <dmwit> :t id :: [Char] -> String
15:40:15 <lambdabot> [Char] -> String
15:40:16 <BleuM937> but for some reason I can't get concatMap . show to typecheck
15:40:30 <koninkje> :t show
15:40:31 <lambdabot> forall a. (Show a) => a -> String
15:40:35 <koninkje> :t concatMap
15:40:36 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:40:41 <BleuM937> :t concatMap . show
15:40:42 <lambdabot>     Couldn't match expected type `a -> [b]'
15:40:42 <lambdabot>            against inferred type `[Char]'
15:40:42 <lambdabot>     Probable cause: `show' is applied to too many arguments
15:40:43 <dobblego> @type concatMap show -- perhaps you want this
15:40:44 <lambdabot> forall a. (Show a) => [a] -> [Char]
15:40:45 <dmwit> :t concatMap show
15:40:46 <lambdabot> forall a. (Show a) => [a] -> [Char]
15:40:58 <dmwit> :t concat . map show -- for comparison
15:40:59 <lambdabot> forall a. (Show a) => [a] -> [Char]
15:42:26 <ddarius> Cale: That's pretty much all the context I had other than a trivial demonstration that natural transformations and functors into the arrow category are the same via "logic in the exponent" until years later when I finally managed to get a copy of "Formal Category Theory."
15:42:36 <AmunRa> Hello! What would be a good data-type for fixed-sized 5x5 grid?
15:42:52 <dmwit> Array
15:43:05 <dmwit> Or, if you need mutation, STArray/IOArray.
15:43:06 <mauke> list, tuple
15:43:39 <rovar> or [list]
15:43:40 <dmwit> Tuple operations are almost certainly going to drive you mad, as you'll want Int-based indexing before long.
15:43:52 <dmwit> Lists can work, but will still probably drive you a bit batty.
15:44:06 <rovar> depends on your constraints? is this time sensitive? 
15:44:24 <rovar> I'm sure there is a Matrix type around
15:44:35 <rovar> let's ask hoogle
15:44:36 <ddarius> If C has taught us nothing, clearly Ptr Foo is the best choice.
15:44:51 <dmwit> What's wrong with Array (Int, Int)?
15:45:25 <hpc> if Java has taught us nothing, clearly Com.Haskell.Core.Collections.Matrix.FiveByFive is the best choice
15:47:50 <roconnor> Zooko's Triangle argues that names cannot be global, secure, and memorable, all at the same time. 
15:48:42 <Saizan> secure?
15:48:46 <pelotom> what does secure mean?
15:48:53 * hpc chooses to keep memorable and swap between global and secure as needed
15:49:05 <pelotom> unique?
15:50:15 <ddarius> Secure = unique (more or less)
15:50:19 <ddarius> (in this context)
15:50:39 <dobblego> how do 
15:50:45 <dobblego> I get haddock to enerate links to source?
15:51:04 <dobblego> i.e. with cabal haddock
15:51:42 <rovar> roconnor, luckily global is almost never necessary
15:51:58 <ddarius> ...
15:52:07 <rovar> ---
15:52:11 <aavogt> dobblego: use    runghc Setup haddock --hyperlink-source
15:52:36 <dobblego> aavogt, can I pass that option to cabal?
15:53:02 <aavogt> no, unless something changed last I checked
15:53:29 <Saizan> cabal haddock --hyperlink-source works
15:53:46 <Saizan> but that's mostly because it's just calling Setup haddock
15:54:01 <aavogt> hmm, for some reason I read  cabal install
15:54:26 <dobblego> so it does, thanks
15:55:14 <dobblego> it can't be passed to cabal install?
15:56:44 <Saizan> no
15:59:30 <unkanon> ok, only now did I realize that when somebody here today asked what editors people here use to program haskell in, nobody mentioned Yi. how come? 
15:59:56 <hpc> probably nobody uses it
16:00:03 <copumpkin> that's what I'd have guessed
16:00:18 <Twey> I think there are a couple who use it
16:00:28 <copumpkin> they clearly were not present when unkanon asked
16:00:32 <dmwit> To be fair, my understanding of unkanon's question was "how come nobody uses it", not "how come nobody mentioned it".
16:00:37 <copumpkin> :P
16:00:39 <Twey> Clearly
16:00:49 <unkanon> how come nobody uses it, yes, sorry
16:00:49 <Twey> Could be
16:00:50 <monochrom> the yi people weren't around
16:01:21 <pelotom> A proof of the undecidability of Goldbach's conjecture in Peano Arithmetic would at the same time be a proof of the conjecture #boggle
16:01:50 <monochrom> just like if you ask "what debuggers do people use", no one will answer "mind" if I am not around. does not mean no one uses mind.
16:01:50 <dankna> pelotom: doesn't that constitute a proof that the conjecture is undecidable?
16:01:55 <unkanon> anybody using vim for haskell?
16:02:19 <pelotom> dankna: a proof that it is undecidable in a powerful enough system is also a proof that it is true... that's what I'm boggling about
16:02:21 <dmwit> yes
16:02:35 <unkanon> dmwit: you? cool
16:03:01 <dankna> pelotom: yes - I'm boggling about it too - but doesn't that fact alone mean that it's undecidable, because you can't prove something both true and undecidable?
16:03:59 <pelotom> dankna: something can be both undecidable in a given system and universally true
16:04:06 <dankna> hmm I guess so
16:05:53 <rschnck_> For the merge sort algorithm, when you're left with just two sorted lists, the algorithm still has to go through each of those list to determine where to put each number, right?
16:06:05 <dankna> correct
16:06:06 <pelotom> the proof of the undecidability of a proposition P in system S would have to be carried out in a stronger system than S... in that system, P would be provable
16:06:07 <rschnck_> And it just happens that you can sort two sorted list into one sorted list much faster than two unsorted lists?
16:06:23 <monochrom> yes
16:06:26 <rschnck_> Right.
16:06:44 <pelotom> err, if P is "goldbach-like"
16:06:55 <rschnck_> I have to implement merge sort on a virtual cpu with super a limited instruction set...not sure how I'm going to conquer the recursion
16:07:14 <rschnck_> Anyway, thanks again ever-helpful #haskell.
16:10:17 <rovar> unkanon, I use vim for Haskell.  I think I remember looking at a graph (maybe the State of Haskell) which indicated that most Haskellers use vim
16:10:25 <ddarius> dankna: If the Goldbach conjecture was false, then there'd be an even number that could not be expressed as the sum of two primes.  Peano arithmetic can check that condition for any number.  If Goldbach's conjecture were undecidable in Peano arithmetic, then such a number couldn't exist and thus Goldbach's conjecture must be true.
16:11:06 <ddarius> At one point there was a survey (many years ago) and vim and emacs were by far the most commonly used editors of the respondents and were on par with each other.
16:11:12 <dankna> hmmmmm
16:11:13 <dankna> I see
16:11:45 <ddarius> I suspect that has changed significantly due to the influx of people and improvement of other editors, but I'm sure vim and emacs are both still very well represented in the Haskell community.
16:12:52 <Pseudonym> G'day everyone.
16:13:23 <Pseudonym> I have an academic question.  How do you organise your responses to reviewers?
16:14:07 <Pseudonym> Should I just write a slab of text covering everything, or should I structure it with a section for every reviewer and a subsection for every comment?
16:14:55 <pelotom> it seems paradoxical... the fact that something is undecidable can imply its truth... of course it's not paradoxical because we are operating in a system outside the system under study
16:15:18 <unkanon> rovar: thanks for letting me know, it helps me stay motivated
16:15:25 <Pseudonym> We're proof theorists.  What is this "truth" of which you speak?
16:16:05 <ddarius> pelotom: The Goedel statement is another (more canonical) example.
16:16:47 <pelotom> ddarius: right
16:16:49 <Pseudonym> Quid est veritas?
16:20:01 <ddarius> Pseudonym: One arm of the subobject classifier pullback wedge.
16:21:19 <Axman6> what's the best way to build up a strict bytestring one element at a time?
16:21:52 <Axman6> it's possible for me to compute the length of the final result before creating the bytestring if necessary
16:22:11 <ddarius> Axman6: Use Binary.Put
16:22:25 <Axman6> yeah, i was thinking something like that would do it
16:23:12 <djahandarie> I think Put builds a lazy bytestring
16:23:35 <djahandarie> Though you can feed it strict ones
16:23:35 <Heffalump> Pseudonym: is this a review response period?
16:23:40 <Axman6> maybe i can use cereal's put
16:23:47 <pelotom> Pseudonym: statements of the form "every natural number has the property P" where P is a computable property, if proven in a consistent system, are known to be provable in any sufficiently powerful system
16:23:55 <pelotom> those are true, wouldn't you agree?
16:24:22 <djahandarie> Axman6, they are fairly similar...
16:25:10 <Axman6> yeah, maybe it was just the parsing side that was a lot nicer in cereal
16:25:18 <mauke> quid est amor? infans, ne me violaveris, non iam ne me violaveris.
16:26:03 <Axman6> ah, and cereal used strict bytestrings, good
16:27:49 <pelotom> Pseudonym: so for instance it's enough to know that Fermat's last theorem is provable in ZFC, to know that it is true
16:27:56 <ddarius> mauke: You'd be a hit back in the day.
16:28:16 <pelotom> because it's true in all sufficiently powerful systems
16:28:29 <pelotom> s/true/a theorem
16:28:48 <ddarius> Though I don't think infans was used the same way.
16:30:08 <pelotom> "a theorem in all sufficiently powerful systems" seems like as good a criteria for truth as you could imagine
16:30:59 <pelotom> criterion*, heh
16:31:03 <djahandarie> Axman6, looks like the only difference is that Cereal uses strict's concat, while Binary uses lazy's fromChunks
16:32:52 <Axman6> hmm, neither seem to implement a putChar :\
16:33:16 <Axman6> @pl (\x s' -> Bin.putWord8 x >> go s)
16:33:17 <lambdabot> const . (>> go s) . Bin.putWord8
16:33:25 <Axman6> @pl (\x s' -> Bin.putWord8 x >> go s')
16:33:25 <lambdabot> (. go) . (>>) . Bin.putWord8
16:35:53 <Pseudonym> pelotom: So by "truth" you mean "valid in all models".
16:36:25 <pelotom> Pseudonym: provable in all sufficiently powerful models, yes
16:37:14 <pelotom> Pseudonym: or maybe it'd be more appropriate to say that that is a sufficient condition for truth
16:37:40 <Pseudonym> If you try to come up with a formal notion of "truth", you end up with Curry's paradox.
16:37:58 <Pseudonym> That's my problem there.
16:38:52 <Pseudonym> Heffalump: Sorry missed your question earlier.  Yeah, I have a journal submission for which I have written my response to reviewers as a big slab o'text
16:39:03 <Pseudonym> I was wondering if I should take more care.
16:39:10 <rschnck_> Anyone have an idea of which channel it'd be best to ask for help with programming using a cpu's instruction code?
16:39:15 <Pseudonym> OK, I did break it into paragraphs.
16:39:18 <Pseudonym> But it looks pretty dense.
16:39:23 <rschnck_> or instruction set, rather
16:39:49 <pelotom> Pseudonym: I don't think I follow
16:40:05 <Pseudonym> pelotom: You mean Curry's paradox?
16:40:12 <hpc> rschnck_: assembly language is what it is called; maybe #asm, if it exists
16:40:21 <Axman6> rschnck_: you mean programming using assembly?
16:40:21 <pelotom> Pseudonym: yes, how does it apply?
16:40:30 <Pseudonym> You know Curry's paradox, right?
16:40:41 <halberd> a cpu's instruction code is machine language, not assembly language
16:40:47 <Pseudonym> If this sentence is true, then the Loch Ness Monster exists.
16:41:01 <rschnck_> Err, my prof "made up" the language on a virtual cpu he made in java
16:41:11 <pelotom> Pseudonym: yes...
16:41:31 <Pseudonym> The problem with the paradox is that "truth" is not formally encodable in _any_ formal system, only provability.
16:42:08 <pelotom> Pseudonym: it depends on your definition of truth... I gave you a consistent definition
16:42:12 <ddarius> rschnck_: Your professor is then probably the best person to ask.
16:42:44 <Pseudonym> I was thinking of plane geometry with straight edge and compass constructions as another example.
16:42:56 <Pseudonym> The system is decidable.
16:43:12 <Pseudonym> But it's only "true" to the extent that geometry is Euclidean.
16:43:21 <rschnck_> ddarius: Yeah, but I'd like to get it done now
16:43:34 <pelotom> Pseudonym: not all theorems in number theory have the property I described
16:43:44 <rschnck_> ddarius: I just have a little "hick-up" and am unsure in which direction to go
16:44:44 <pelotom> for instance, Goldbach's conjecture, if proven in ZFC, would be provable in any sufficiently powerful system... but the Collatz conjecture, even if proven in ZFC, would not necessarily be provable in other similar systems
16:46:31 <pelotom> it has to do with the idea that certain things, if false, would be provable in any of these systems... and therefore their undecidability makes them true in all these systems
16:46:43 <pelotom> disprovable*
16:47:01 <pelotom> anything that can be disproven by a counterexample
16:51:01 <elitheeli> If I have "data A = B x | C x" and I have a list of As, and I want to only get the Bs, is there some way to do "filter usedBConstructor" without separately having to define usedBConstructor (B x) = true, usedBConstructor (C x) = false?
16:53:16 <mikeg> elitheeli, you can pattern match in list comps. [x | x@(B _) <- l]
16:53:17 <nkpart> I'm getting an odd error back from cabal when I try upload an update to a package I maintain: A package using 'cabal-version: >=1.2' must use section
16:54:28 <nkpart> syntax. See the Cabal user guide for details.
16:55:17 <nkpart> can't find any reference to that in the user guide. anyone seen this?
16:55:35 <nkpart> the only thing I changed since the last upload was the version
16:57:43 <elitheeli> mikeg: tanks
17:00:04 <ddarius> elitheeli: Often in these situations you want to do more than that though.  Why produce a list of As that you know are all Bs?  You'll likely either have to recheck or unsafely trust that this is true later.  It is usually better encode that the filtered list contains only Bs in the type, in simple cases, by having the contents of B rather than an A.
17:02:22 <astroboy> I'm trying to define an Either Monad, but I've got troubles: http://hpaste.org/41267/boh
17:02:49 <copumpkin> astroboy: what's the type of fail?
17:03:05 <copumpkin> fail :: Monad m => String -> m a
17:03:23 <JohnnyL> http://dpaste.com/272082/
17:03:25 <copumpkin> what's the type of Left :: Either SemError a?
17:03:36 <aristid> :t Left
17:03:37 <lambdabot> forall a b. a -> Either a b
17:04:16 <astroboy> copumpkin: oh right. so I can't define a fail, can I?
17:04:39 <copumpkin> not nicely
17:05:20 <aristid> fail = error
17:05:20 <astroboy> mhm my idea was to shortcircuit the monad when I encounter an error
17:05:34 <astroboy> aristid: no I want to return that error...
17:05:52 <aristid> astroboy: then you need to construct an Either from a stirng
17:06:00 <aristid> Control.Monad.Error does that
17:06:16 <astroboy> aristid: ok, I didn't know that it existed already
17:06:31 <aristid> :)
17:06:48 <astroboy> thanks
17:08:10 <nus> nkpart,  3.1 "...This fiï¬le should contain of a number global property descriptions and several sections."
17:09:48 <nus> nkpart, {Library*,Executable+}
17:14:20 <nkpart> nus: Ah I see, thanks
17:16:33 * hackagebot kit 0.4.4 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.4.4 (NickPartridge)
17:18:39 <nkpart> ^ success!, thanks again nus. surprised the previous uploads were working
17:20:47 <nus> nkpart, np (-: perhaps some linting on the upload server has changed
17:33:38 * hackagebot csv 0.1.2 - CSV loader and dumper  http://hackage.haskell.org/package/csv-0.1.2 (JaapWeel)
17:40:40 * hackagebot data-binary-ieee754 0.4.2.1 - Parser/Serialiser for IEEE-754 floating-point values  http://hackage.haskell.org/package/data-binary-ieee754-0.4.2.1 (JohnMillikin)
17:42:06 <Axman6> ooo, how handy
18:15:36 <xscroll> I'm trying to write a function to check user input. if I pass the output of getLine to [Char], I'm having trouble.  could someone explain how I fix this?  http://paste.lisp.org/display/116364
18:17:00 <kmc> xscroll, the lines of your "do" block need to be IO actions
18:17:05 <kmc> incN returns an Integer
18:17:13 <kmc> maybe you want: print incN (next, pl)
18:17:34 <jmcarthur> print $ incN (next, pl)
18:17:34 <kmc> also, it's more common to take two arguments rather than a tuple
18:17:41 <kmc> incN :: [Char] -> Integer -> Integer
18:17:43 <kmc> incN x p = ...
18:17:57 <jmcarthur> print $ incN next pl
18:33:20 <JohnnyL_> > applyTwice f x f (f x)
18:33:21 <lambdabot>   Not in scope: `applyTwice'
18:33:35 <JohnnyL_> > let applyTwice f x = f (f x)
18:33:36 <lambdabot>   not an expression: `let applyTwice f x = f (f x)'
18:33:47 <JohnnyL_> > applyTwice f x = f (f x)
18:33:48 <lambdabot>   <no location info>: parse error on input `='
18:33:52 <JohnnyL_> wtf?
18:34:07 <Eduard_Munteanu> @let applyTwice f x = f (f x)
18:34:08 <lambdabot>  Defined.
18:34:15 <JohnnyL_> thanks
18:34:22 <Eduard_Munteanu> JohnnyL_: or...
18:34:39 <Eduard_Munteanu> > let applyTwice f x = f (f x) in applyTwice (+2) 1
18:34:39 <lambdabot>   5
18:34:52 <Eduard_Munteanu> JohnnyL_: you should rather use the latter
18:34:58 <JohnnyL_> > applyTwice (++ " haha") "hey"
18:34:59 <lambdabot>   "hey haha haha"
18:35:28 <JohnnyL_> why does 'hey' come before the sets of haha?
18:35:56 <JohnnyL_> Eduard_Munteanu: ok
18:36:05 <Eduard_Munteanu> JohnnyL_: (++ " haha") == \x -> (x ++ " haha")
18:36:46 <Eduard_Munteanu> JohnnyL_: ("haha " ++) == \x -> "haha " ++ x
18:37:51 <JohnnyL_> ah ok
18:37:59 <JohnnyL_> simple, yet confusing
18:38:10 <JohnnyL_> The later example makes sense.
18:39:26 <JohnnyL_> Eduard_Munteanu: how can I break down GHCi so that it produces the example you gave; is it even possible?
18:39:49 <monochrom> not possible
18:40:28 <JohnnyL_> monochrom: With *any* tool?
18:41:05 <Eduard_Munteanu> JohnnyL_: that rule holds up for any infix, not sure how such a tool would help you.
18:41:26 <monochrom> not possible with ghci
18:41:29 <JohnnyL_> ah ok, so it's an infix thing.
18:42:59 <Eduard_Munteanu> a <o-o> b == (a <o-o>) b == (<o-o> b) a, forall <o-o> infixes
18:43:18 <Eduard_Munteanu> (that's not something real)
18:43:40 <Eduard_Munteanu> and it's further equal to (<o-o>) a b
18:43:46 <JohnnyL_> beautiful symmetry.
18:43:48 <JohnnyL_> sweet stuff.
18:44:37 <Eduard_Munteanu> JohnnyL_: it's just partial application
18:44:39 <JohnnyL_> Eduard_Munteanu: thanks much! :)
18:44:50 <JohnnyL_> Eduard_Munteanu: Yeah thats the chapter I'm on.
18:50:32 <dented42> I have a potentially silly question, what sort of useful QuickCheck properties could you write for a fixed point combinator?
18:51:44 <monochrom> perhaps I will test it with the factorial function
18:52:00 <aristid> dented42: fix id == _|_
18:52:42 <monochrom> "for all x, fix (\f x -> if x<=0 then 1 else x*f(x-1)) x = product [1..x]"
18:52:44 <Axman6> > fix is 1
18:52:45 <lambdabot>   Not in scope: `is'
18:52:51 <Axman6> > fix id 1
18:52:55 <lambdabot>   mueval-core: Time limit exceeded
18:53:12 <monochrom> there is also "for all x, fix (const 0) x = 0"
18:53:12 <pelotom> > let bogusFix x = bogusFix x in bogusFix id
18:53:16 <lambdabot>   mueval-core: Time limit exceeded
18:53:23 <xscroll> kmc: I'm a bit lost.  how do I make the lines IO actions?
18:53:38 <dented42> Yeah, ok.
18:53:43 <kmc> xscroll, what did you want to do with the value of Â«incN next plÂ»?
18:53:44 <kmc> print it?
18:53:50 <kmc> print (incN next pl)
18:53:52 <dented42> > :t id
18:53:52 <lambdabot>   <no location info>: parse error on input `:'
18:53:54 <monochrom> > fix (const 0) 5
18:53:55 <lambdabot>   Ambiguous type variable `t' in the constraint:
18:53:55 <lambdabot>    `GHC.Num.Num t' arising f...
18:54:01 <monochrom> > fix (const 0) 5 :: Integer
18:54:02 <lambdabot>   0
18:54:02 <kmc> the stuff inside "do" is a sequence of things to do
18:54:05 <xscroll> kmc: I wanted to check it, and change pl based on different string values
18:54:09 <kmc> (incN next pl) isn't a thing to do; it's a number
18:54:14 <xscroll> p rather
18:54:19 <kmc> change?
18:54:23 <kmc> you can't change variables
18:54:30 <kmc> but you could call a function with some different argument
18:54:39 <monochrom> Obama can change variables. :)
18:54:53 <xscroll> I'm trying to move a player on a map; it's a text adventure
18:55:07 <kmc> it looks like you're treating pl as a global variable that you update
18:55:08 <EvanR> variables arent (tm)
18:55:09 <kmc> it doesn't work that way
18:55:28 <xscroll> I was going to put it in a let statement, but for now, yes
18:55:44 <kmc> you can't change the value of a variable
18:55:51 <xscroll> for now, I'm just trying to pass getLine output to a function. how do I do that?
18:55:55 <kmc> you are doing it
18:56:03 <kmc> the problem is that what the function *returns* is incompatible with the do block
18:56:07 <kmc> because it returns an Integer
18:56:15 <kmc> but the lines in a do block are things to do
18:56:18 <kmc> you can't do an Integer
18:56:21 <xscroll> I get the error "Couldn't match expected type `String -> t -> IO ()'" when I try
18:56:22 <EvanR> > let f x = x^2 in (f 4, f 6)
18:56:23 <lambdabot>   (16,36)
18:56:29 <EvanR> i just changed the variable!
18:56:34 <pelotom> Obama can do an integer
18:56:46 <kmc> xscroll, do you want an example of how to count up or down based on user input?
18:56:55 <kmc> i feel a complete example might be more useful
18:56:57 <xscroll> kmc: yes
18:57:01 <kmc> ok, one sec
18:57:13 <monochrom> "main = do { x <- getLine; print (length x) }" is how you "pass getLine output to function length". But you have to say what to do with the result, e.g., "print".
18:57:55 <pkrumins> If I have a PortID, how can I convert it to a string?
18:58:04 <EvanR> show ?
18:58:08 <xscroll> monochrom: I'm not having any problem with that.  I'm having trouble passing the results of getLine to my own function
18:58:09 <pkrumins> like `port :: PortID; port = PortNumber 5000`
18:58:21 <monochrom> replace "length" by your own function
18:58:23 <roconnor> > show PortNumber 5000
18:58:24 <lambdabot>   Not in scope: data constructor `PortNumber'
18:58:25 <pkrumins> EvanR: let me try that, i think i tried and it didn't work, but trying again.
18:58:34 <pkrumins> roconnor: :m Network
18:58:36 <EvanR> > show (PortNumber 5000)
18:58:36 <lambdabot>   Not in scope: data constructor `PortNumber'
18:58:41 <roconnor> > show (Network.PortNUmber 5000)
18:58:41 <lambdabot>   Not in scope: data constructor `Network.PortNUmber'
18:58:46 <roconnor> > show (Network.PortNumber 5000)
18:58:47 <lambdabot>   Not in scope: data constructor `Network.PortNumber'
18:59:02 <pkrumins> yeah:
18:59:03 <pkrumins> No instance for (Show PortID)
18:59:22 <Eduard_Munteanu> pkrumins: write one
18:59:24 <EvanR> showPort (PortNumber n) = "PortNumber " ++ (show n)
18:59:31 <pkrumins> oh!
18:59:41 <pkrumins> nice, thanks!
18:59:57 <aristid> EvanR: unnecessary parentheses!
18:59:59 <kmc> xscroll, http://hpaste.org/41270/for_xscroll
19:00:03 <EvanR> oops
19:00:17 <EvanR> i dont like precedence
19:00:40 <pelotom> for some reason I can't seem to cabal install anything graphics-related on MacOS... always fails with "setup: The pkg-config package glib-2.0 is required but it could not be found."
19:00:40 <EvanR> i think someone Twey probably brought up some syntax to eliminate that
19:00:50 <pelotom> anyone know about this?
19:01:08 <shachaf> pelotom: Probably you should install glib. :-)
19:01:12 <kmc> xscroll, note that any kind of interactive IO is not a good place to start learning Haskell
19:01:18 <pelotom> I've installed glib-2.12 from scratch
19:01:23 <pelotom> no dice
19:01:33 <kmc> as a beginner one should probably write functions that don't do IO, and use ghci to test them
19:01:44 <Eduard_Munteanu> pelotom: maybe that's the problem
19:01:45 <shachaf> pelotom: Does it require glib of version exactly 2.0, or >=?
19:01:53 <xscroll> kmc: I didn't start here, I've been learning for a while
19:01:56 <kmc> ok
19:02:12 <kmc> do you understand how my code works? i can answer questions
19:02:16 <pelotom> hm, that could be it I guess
19:02:28 <kmc> note that we never actually modify the value of n.  we just make another call to "go" with a different value of n
19:02:29 <xscroll> kmc: yes
19:02:42 <xscroll> kmc: I understand that aspect of functional programming, yes
19:02:57 <Eduard_Munteanu> Pure
19:03:15 <kmc> there are things in Haskell which have values that can be changed over time
19:03:18 <kmc> but they're not variables
19:03:19 <EvanR> kmc has interactive capability
19:03:19 <xscroll> someone called it a "global variable", but it was a constant for the place the player would start on the map in my code
19:03:21 <kmc> they're called reference cells
19:03:26 <Eduard_Munteanu> kmci :)
19:03:28 <kmc> ok
19:03:44 <kmc> but xscroll you said you'd "change pl based on different string values"
19:03:45 <shachaf> kmc: That code would probably be clearer with StateT, though.
19:03:51 <Eduard_Munteanu> I need to install that.
19:03:56 <kmc> shachaf, i doubt it
19:04:04 <kmc> keep it simple
19:04:14 <xscroll> kmc: I come from a Pascal/C background, so it was a slip :)
19:04:17 <kmc> ok
19:04:37 <xscroll> I expect the final result to just be a let statement
19:04:45 <hpc> oh man; Pascal -> Haskell is not only touch conceptually, but phonetically
19:04:48 <monochrom> I came from a BASIC background.
19:05:00 <hpc> *tough
19:05:09 <xscroll> I don't remember basic anymore, but I did some  :)
19:05:15 <EvanR> i came from a The Matrix background
19:05:29 <EvanR> which i use as my screen saver
19:05:29 <Eduard_Munteanu> monochrom: oO
19:05:41 <monochrom> I do not miss BASIC limitations a tiny bit.
19:06:02 <m3ga> is there anything in GHC that will give me things that work like __func__, __FILE__ and __LINE__ in C?
19:06:12 <monochrom> I was like "gosub doesn't take parameters, doesn't return value, I have to use global variables? wtf"
19:06:15 <EvanR> m3ga: yes. the c preprocessor
19:06:36 <JohnnyL_> EvanR: The first iterations were versions of mathematical art!
19:06:37 <Eduard_Munteanu> monochrom: did you do programming around math people?
19:06:44 <monochrom> no
19:06:50 <EvanR> at least they didnt try to confuse functions with subprocedures
19:07:11 <Eduard_Munteanu> Ah, I thought that was the explanation.
19:07:27 <monochrom> the explanation is I actually have good taste
19:08:19 <JohnnyL_> I come from a backround of typing decimal values into a vic with a datacassette.
19:08:33 <kmc> xscroll, so did i answer your question?
19:08:37 <xscroll> hey, me too!
19:08:40 <xscroll> kmc: yes
19:09:12 <xscroll> but I didn't have the data cassette at first.  so I had to leave it on to keep running the code
19:09:22 <shachaf> kmc: http://hpaste.org/paste/41270 -- hmm, you're probably right.
19:09:22 <Eduard_Munteanu> I kinda get your point, but I wouldn't call that good taste, just like I wouldn't call Matlab or FORTRAN good taste
19:09:30 <shachaf> But that's unfortunate.
19:09:52 <monochrom> Of course by good taste I mean the "gosub doesn't have ....?! wtf" part
19:10:17 <monochrom> I had access to BASIC-only computers only.
19:10:29 <Eduard_Munteanu> I meanif you're comparing to C, well, there are some points to that.
19:10:33 <Eduard_Munteanu> Oh.
19:10:47 <monochrom> You may say the explanation is "I'm really old"
19:10:48 <xscroll> kmc: is there a benefit to go over let?
19:11:03 <Eduard_Munteanu> monochrom: heh, that could make sense
19:11:12 <m3ga> EvanR: thanks. supports __FILE__ and __LINE__, but not __func__
19:11:41 <Eduard_Munteanu> monochrom: was it straight from BASIC to Haskell? Just curious.
19:12:02 <kmc> xscroll, i don't follow
19:12:37 <monochrom> haha, no. there were pascal, c, various assembly, prolog, lisp, mathematica, matlab, perl, sml, ocaml in-between
19:12:44 <xscroll> kmc: is it preferable to use go as opposed to using let for that code?
19:13:00 <kmc> xscroll, those don't make sense as alternatives
19:13:09 <kmc> "go" isn't a keyword; it's a function i defined there
19:13:14 <kmc> could name it anything
19:13:30 <xscroll> oh! haha
19:13:32 <kmc> if you rewrite the code using "let" i can give advice on whether it's better or worse
19:13:36 <Eduard_Munteanu> Heh, that makes more sense than thinking old mono knows only BASIC and Haskell, and he stuck with the latter :)
19:13:43 <JohnnyL_> xscroll: :)
19:13:49 <xscroll> I thought that was like goto
19:14:06 <kmc> xscroll, the idea is we keep state by having this function call itself with different args
19:14:14 <xscroll> right
19:14:38 <EvanR> xscroll: maybe you want comefrom
19:14:44 <Eduard_Munteanu> :)
19:15:04 <Eduard_Munteanu> (it actually exists)
19:15:14 <ddarius> instance Monad Intercal where 
19:15:43 <monochrom> I condemn augustss for completing my circle with http://hackage.haskell.org/package/BASIC
19:16:02 <Eduard_Munteanu>     please = do
19:16:50 <shachaf> monochrom: That is one of the more horrible ways I've seen Haskell abused.
19:17:21 <Cale> http://www.flickr.com/photos/cgibbard/ -- moar magnetic constructions :)
19:17:23 <Eduard_Munteanu> Poor mr Curry.
19:17:34 <kmc> shachaf, i think the StateT code is all right, but harder to explain to a beginner.  it adds something that looks like magic but is really sugar
19:18:43 <Veinor> monochrom: augh
19:18:50 <monochrom> hehehe
19:19:01 <fengshaun> is it conventional to use "Either Int ResultType" where Int refers to error code, instead of error string?  The possible codes will be explained in the documentation.
19:19:02 <kmc> Cale, shiny!
19:19:02 <shachaf> kmc: Fair enough. But I'm of the opinion that a beginner should learn about State etc. before learning about IO. :-)
19:19:15 <kmc> shachaf, fair enough
19:19:41 <fengshaun> what is State?
19:19:43 <shachaf> fengshaun: Maybe use data ErrorCode = A | B | C?
19:19:47 <Axman6> fengshaun: i'd make an error datatype, and have data MyError = IOError | StupidUserError | ..., Either MyError ResultType
19:19:49 <shachaf> fengshaun: The State monad, Control.Monad.State.
19:19:58 <Eduard_Munteanu> @src State
19:19:58 <lambdabot> Source not found. Are you on drugs?
19:20:06 <fengshaun> shachaf, that's a better idea!
19:20:07 <Eduard_Munteanu> Strange
19:20:26 <kmc> fengshaun, the type (State S T) represents computations that produce a "result" of type T while also using and updating a "state" of type S.  it merely provides syntactic sugar for functions of type S -> (T, S)
19:21:15 <EvanR> type State s a = s -> (a,s)
19:21:18 <fengshaun> kmc, oh cool!  I still have some time before I get to Monads (following learnyouahaskell.com now), but that sounds good
19:21:36 <shachaf> fengshaun: Forget that I used the word "monad". It's a warm fuzzy thing.
19:21:53 <fengshaun> oh alright then, I'll check it out now!
19:22:03 <monochrom> learn strong lax warm fuzzy functor thing first. (i.e., Applicative)
19:22:03 <shachaf> fengshaun: The type S -> (T,S) isn't nearly as complicated-sounding, is it? :-)
19:22:06 <EvanR> lets rename monad, monoid, functor, and applicative right now
19:22:09 <kmc> fengshaun, yeah, there's a simple API for combining (State S T) values, and it so happens this API is useful for lots of other things, and the general name of the API is "monad"
19:22:26 <kmc> fengshaun, but it's not so important to know what the word "monad" means, if you're focusing on one use case like State
19:22:31 <EvanR> mushroom, bear, fairy, and cuddly
19:22:31 <Eduard_Munteanu> Probably an example will make more sense, then working out how it works.
19:22:50 <EvanR> hmm swap bear and fairy
19:22:53 <fengshaun> EvanR, I doubt those overlap
19:23:03 <EvanR> so applicative functor is cuddly bear
19:23:14 <fengshaun> kmc, shachaf, Axman6: thanks!
19:23:33 <shachaf> EvanR: Functor, Applicative, Monad are superclasses of each other -- you need to take that into account with your naming scheme.
19:23:43 <EvanR> no they arent
19:24:04 <Veinor> they should be
19:24:30 <EvanR> not at issue here, trying to make them more cuddly, not more theoretically sexy
19:25:05 <shachaf> EvanR: What's not cuddly about that?
19:25:17 <EvanR> well its not haskell
19:25:18 <EvanR> atm
19:26:18 <shachaf> @quote fuzzy
19:26:18 <lambdabot> Botje says: fuzzy feelings aren't always aerodynamic, unfortunately.
19:26:23 <shachaf> @quote fuzzy
19:26:24 <lambdabot> Botje says: fuzzy feelings aren't always aerodynamic, unfortunately.
19:26:27 <shachaf> Hmm.
19:26:51 <shachaf> @quote fuzzy
19:26:51 <lambdabot> gzl says: <ricebowl> what does >>= do? <basti_> ricebowl: monads are cute pink fuzzy little things. <gzl> with plutonium inside.
19:27:18 <stepkut> why do I get this when I try to install the latest STM: Control/Monad/STM.hs:34:9: Not in scope: `throwSTM'
19:27:40 <EvanR> anti-haskell propaganda: monads cause cancer
19:28:06 <stepkut> >:(
19:28:27 <stepkut> monads are the cancer that is killing Haskell ?
19:28:30 <monochrom> perhaps don't install the latest STM yet?
19:29:00 <pelotom> monads are bad for you but make you feel sexy
19:29:13 <EvanR> pelotom: everybodys doing them
19:29:28 <stepkut> monochrom: I am trying to update the stm dependencies in happstack-state.cabal.. I can just do, stm < 2.2, but I thought maybe I should understand what is going on first ?
19:29:43 * EvanR peer pressures pelotom to try monads
19:29:49 <pelotom> I only use monads at parties, to fit in
19:30:08 <stepkut> I use monads at ServerPartTs all the time..
19:30:09 <EvanR> once you get into them, you wont be able to stop
19:30:31 <roconnor> > forever (Left "stop")
19:30:32 <lambdabot>   Left "stop"
19:30:32 <shachaf> EvanR: That's right. Once you're in a monad, you *never* get out.
19:30:37 <EvanR> lol
19:30:53 <Veinor> first monad injection's free!
19:31:12 <stepkut> cofree monads for everyone!
19:31:23 <Veinor> everyone for cofree monads!
19:31:32 <pelotom> once you inject that pure value into your monad, you'll feel like you've never felt before
19:31:47 <shachaf> So warm and fuzzy.
19:31:58 <stepkut> monochrom: also, it appears that hackage build STM 2.2 fine, so why can't I ?
19:32:17 <EvanR> no one can explain to you what a monad is, its something you have to see for yourself
19:33:16 <Cale> Eugenia Cheng can explain to you what a monad is: http://www.youtube.com/watch?v=9fohXBj2UEI
19:33:31 <stepkut> I bet it is because I am using an old GHC 6.13 which has base >= 4.3.0, but which does not actually have throwSTM in base
19:33:36 <monochrom> interesting, builds fine for me. version 2.2.0.1
19:33:49 <Eduard_Munteanu> Haskell on Youtube? :/
19:33:56 <EvanR> moe nads
19:34:04 <pelotom> category theory on youtube :P
19:34:05 <shachaf> Eduard_Munteanu: Those aren'
19:34:13 <pelotom> there's nothing about haskell in those vids
19:34:15 <shachaf> t watered-down Haskell monads. Those are the real thing.
19:34:29 <pelotom> yeah, this is the GOOD shit
19:34:47 <Cale> High octane abstract nonsense
19:35:24 <EvanR> whats T^2
19:35:35 <Cale> The composite of T with itself
19:35:50 <Cale> T^2 X = T (T X)
19:36:01 <Eduard_Munteanu> Brb, will look at that soon
19:36:26 <EvanR> there are women in higher up math?
19:36:46 <Cale> Of course there are
19:37:16 <pelotom> "T^2 ->T" is the signature of join
19:37:59 <Cale> In the context of Haskell, you can pretty much specialise "natural transformation" to "polymorphic function"
19:38:07 <stepkut> monochrom: yeah, it is because i have a stupid version of base 4.3.0, so the #ifdefs do not do the right thing
19:38:27 <EvanR> ok so whats the actual pronuncation of monad
19:38:29 <monochrom> yeah, I just looked at the source code, seems like it
19:38:35 <stepkut> monochrom: I would like to upgrade to GHC7, but the way overlapping instances work has changed and HSP does not compile anymore
19:38:41 <Cale> eta is return, and mu is join
19:38:56 <stepkut> monochrom: and I have not been able to figure out of if that is a bug or feature of GHC 7
19:39:21 <pelotom> moe-nads is how I've always said it
19:39:32 <pelotom> mo' nads, mo' problems
19:39:34 <kmc> data Nat f g = Nat (forall a. f a -> g a) -- ?
19:39:56 <EvanR> its damn spelling is like monoid, which she pronounces differently
19:40:11 <Cale> Yeah, it's actually a portmanteau of monoid and triad
19:40:42 <Cale> Which is why I usually pronounce the mon- the same way as in monoid.
19:40:51 * shachaf has a tendency to mispronounce "portmanteau" too...
19:41:24 <Cale> Monad for monoids = list monad
19:41:34 <Cale> (strict list monad)
19:42:15 * hackagebot happstack-util 0.5.0.3 - Web framework  http://hackage.haskell.org/package/happstack-util-0.5.0.3 (JeremyShaw)
19:42:17 * hackagebot happstack-data 0.5.0.3 - Happstack data manipulation libraries  http://hackage.haskell.org/package/happstack-data-0.5.0.3 (JeremyShaw)
19:43:08 <Cale> One thing that I wish the videos covered (I now understand it, but I'd still like to see it explained by those guys) is exactly how to construct the monad for an arbitrary algebraic theory.
19:43:19 <aristid> @quote ennobunktor
19:43:19 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
19:44:11 <aristid> i could pull that quote all day
19:44:15 * hackagebot happstack-ixset 0.5.0.3 - Efficient relational queries on Haskell sets.  http://hackage.haskell.org/package/happstack-ixset-0.5.0.3 (JeremyShaw)
19:44:18 * hackagebot happstack-state 0.5.0.3 - Event-based distributed state.  http://hackage.haskell.org/package/happstack-state-0.5.0.3 (JeremyShaw)
19:44:20 * hackagebot happstack-server 0.5.0.3 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-0.5.0.3 (JeremyShaw)
19:45:16 * hackagebot happstack 0.5.0.3 - The haskell application server stack + code generation  http://hackage.haskell.org/package/happstack-0.5.0.3 (JeremyShaw)
19:47:17 * hackagebot redis-hs 0.0.7 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.0.7 (WillLangstroth)
19:49:53 <stepkut> happstack-stack > redis-hs :p
19:55:30 <aristid> stepkut: i think there are two redis packages now
19:56:10 <aristid> right. redis and redis-hs
19:57:07 <aristid> and there's also redis-simple wrapping redis
19:57:36 <aristid> stepkut: does happstack-stack support redis? then there are four packages :D
19:58:07 <sohum> @src intersperse
19:58:07 <lambdabot> intersperse _   []     = []
19:58:07 <lambdabot> intersperse _   [x]    = [x]
19:58:07 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
19:58:19 <sohum> oh, duh
20:01:03 <stepkut> aristid: happstack-state is a competitor to redis. It is an in-memory, NoSQL database system. But it uses native haskell types and functions -- so you get the full awesomeness of Haskell..
20:01:45 <aristid> stepkut: i don't trust it. (for that matter i don't really trust redis either)
20:02:34 <blackdog> stepkut: we really do need to work on our naming
20:02:51 <stepkut> redis only supports strings, lists, sets, and ordered sets. happstack-state supports almost any haskell data structure.
20:03:00 <EvanR> nosql brand is about no relational
20:03:04 <stepkut> aristid: you should totally trust happstack-state -- we have quickchecks!
20:03:25 <stepkut> blackdog: oh ?
20:03:45 <aristid> stepkut: last time i read, happstack was limited by the amount of available memory. which sounds like a real limitation
20:04:00 <blackdog> stepkut: well, look at the competition. redis, riak, mongo, cassandra: they all sound sorta cool, you know?
20:04:01 <aristid> stepkut: i think i'd probably use postgresql as a database
20:04:09 <stepkut> blackdog: :)
20:04:15 <aristid> blackdog: right, the name happstack-stack sucks
20:04:26 <blackdog> happstack-state tells you its provenance and how it's related, but it's not very memorable
20:04:43 <stepkut> aristid: if slow disk access and high query time variability are not issues, postgres can be a fine solution !
20:04:46 <blackdog> descriptive names are fine for things like bytestring :)
20:04:52 <stepkut> blackdog: how about .. MACID
20:05:09 <stepkut> blackdog: MACID-25
20:05:16 <blackdog> stepkut: i wouldn't even bother trying to make it slightly relevant
20:05:26 <blackdog> just pick something that sounds snazzy :)
20:05:32 * blackdog clearly missed his calling in marketing
20:05:55 <EvanR> aristid: youre also the git guy!
20:06:09 <aristid> EvanR: you see i can be pretty conservative
20:06:13 <blackdog> f'rinstance: there are lots of technical things in my project i'd do differently now, but the name? Hubris is inspired :)
20:06:13 <EvanR> what are you trying to do espousing git and postgres!
20:06:24 <EvanR> i guess you also want to use linux!
20:06:30 <blackdog> (and not mine, really. a couple of people suggested it independently...)
20:06:41 <EvanR> wheres the fire in your heart
20:06:45 <aristid> EvanR: i want to infiltrate the world.
20:06:54 <Boxo> > let inters sep = tail . concatMap (\x -> [sep, x]) in inters 'a' "hhh"
20:06:55 <lambdabot>   "hahah"
20:07:54 <EvanR> ive been reading about this thing, concurrent updating of a bank account
20:08:04 <EvanR> and how its supposedly hard
20:08:33 <medfly> supposedly
20:08:33 <EvanR> storage engines implement row level locking for it
20:08:52 <EvanR> and i saw, just add up the sum of their transactions ;)
20:08:55 <EvanR> say*
20:09:10 <EvanR> genius
20:09:33 <medfly> just declare multiple transactions as atomic? :)
20:09:52 <EvanR> no need
20:10:19 <EvanR> when you add or remove money, record a transaction which is either + or - some amount
20:10:25 <EvanR> if you want the balance, its the sum of those
20:10:37 <EvanR> you cant delete transactions
20:12:30 <medfly> let's say you can't go negative. (pretty normal)
20:12:43 <EvanR> not in banks ive seen
20:12:52 <ddarius> This is what is often done.  I'd imagine this is actually practically required by law in some cases.
20:12:53 <EvanR> when you go negative they charge you and you go even more negative
20:13:09 <medfly> there is some lower limit
20:13:26 <ddarius> > minBound :: Int
20:13:27 <lambdabot>   -9223372036854775808
20:13:45 <EvanR> before a debit, you can check the current balance to see if it would 'in some sense' not be allowed
20:13:55 <stepkut> > minBound :: Integer
20:13:56 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Internals.Integer)
20:13:56 <lambdabot>    arising...
20:13:56 <EvanR> for example, its already negative
20:14:46 <EvanR> ddarius: i would like to know these laws so i can tell people how to do this crap right with databases
20:15:43 <EvanR> how our data is represented should be a serious topic because we do data collection, but this fool runs the place likes its a hipster website 2.0
20:15:45 <ddarius> EvanR: This is a simple case of journalling and is an idea that came out of the database community.
20:16:19 <aristid> EvanR: banks don't really use transactions for bank accounts
20:16:35 <Eduard_Munteanu> EvanR: I assume banks would want to collapse multiple transaction after a while and not maintain that much state. But it might be cheap though, I'm not really sure.
20:16:46 <EvanR> Eduard_Munteanu: erase history?
20:16:46 <aristid> EvanR: you send your order and it will later be processed in batch. totally not transactional :)
20:17:08 <Eduard_Munteanu> EvanR: well then, your total amount will be wrong.
20:17:20 <EvanR> i dont see a need to erase history
20:17:41 <ddarius> Eduard_Munteanu: Again, as part of journalling they've thought of these issues and know how to solve them.
20:17:48 <EvanR> aristid: after reading up on this, it seems that you swipe the card, MasterCard gets the order, then they do some secret stuff with the bank
20:18:08 <aristid> EvanR: well i was thinking about normal wire transfers
20:18:11 <ddarius> That said, for, say, a personal account or even many business accounts, the entire transactional history of the account is probably not very large.
20:19:10 <EvanR> so storing a transaction rather than a x = x + 1 side effect is smart, well known, and common?
20:19:21 <ddarius> EvanR: Yes.
20:19:23 <EvanR> great!
20:19:26 <Eduard_Munteanu> ddarius: ah, the kind of journalling I know (from filesystems) usually keeps short journals, to aid in doing atomic transactions rather than preserve any form of history. I presume you're referring to a broader concept.
20:19:43 <ddarius> Eduard_Munteanu: The filesystems people got it from the database people.
20:19:46 <aristid> EvanR: doesn't stop database tutorials from using that example as an example for transactions, of course :)
20:20:12 <EvanR> aristid: yes! i wish i knew enough to separate crap from sanity in that area
20:20:27 <EvanR> i only know functional programming which doesnt have this problem ;)
20:20:50 <aristid> EvanR: only knowing functional programming is bad :/
20:20:55 <ddarius> There are filesystem/database approaches that operate on the view that the FS/DB is nothing -but- the collection of transactions.
20:20:56 <Eduard_Munteanu> EvanR: how so? I think it's merely concealed.
20:21:04 <ddarius> This has relations to revision control.
20:21:16 <EvanR> aristid: obviously
20:21:19 <Eduard_Munteanu> ddarius: ah, like logging filesystems?
20:21:24 <ddarius> Eduard_Munteanu: Yes.
20:21:50 <Eduard_Munteanu> That's indeed interesting, never had the chance to try one though. There are a couple in Linux I think, or close to enter.
20:22:23 <EvanR> ddarius: i did notice this, basically any attempt i make at making updating state non insane leads to a revision control system
20:22:50 <aristid> EvanR: mvcc-like?
20:23:04 <EvanR> marvel vs capcom?
20:23:12 <Eduard_Munteanu> I wonder if there's any connection between purity and reversible computing (in the thermodynamic sense).
20:23:14 <aristid> multi version concurrency control
20:23:27 <Eduard_Munteanu> Though that's very very speculative.
20:23:29 <EvanR> no, dont know what that is
20:23:37 <aristid> EvanR: your interpretation of the acronym is funnier tho
20:23:46 <Eduard_Munteanu> Yeah :).
20:24:01 <aristid> EvanR: http://en.wikipedia.org/wiki/Multiversion_concurrency_control :P
20:24:25 <ddarius> Eduard_Munteanu: Mutation (particularly erasing) is clearly not reversible.
20:24:42 <aristid> EvanR: i think mvcc is cool :)
20:25:11 <EvanR> yes this solves the inevitable objection that my manager will instantly and maybe naively raise, that it will take up too much space
20:26:01 <blackdog> dobblego: you stirring the pot at HN? reversejar seems down...
20:26:19 <dobblego> wasn't me and yes my little machine in the kitchen is broke
20:26:53 <EvanR> a bank account balance is the sum of transaction diffs, but theres a case where this breaks. if you store instead of diffs the 'new version' which you based on the 'old version'
20:26:53 <Eduard_Munteanu> ddarius: I know, I mean I wonder if there has been any research in that area.
20:27:10 <EvanR> if someone committed a new version before you, then their version is erased without you knowing about it
20:27:16 <EvanR> 'erased' meaning, not latest
20:27:27 <Eduard_Munteanu> Or rather, any positive results.
20:27:37 <blackdog> dobblego: ah, and the immediate "it's not a problem if you don't care about types" response. how enlightening.
20:27:52 <dobblego> blackdog, I don't know what you mean
20:28:00 <EvanR> i guess git resolves this by committing versions with a parent reference
20:28:08 <blackdog> dobblego: the comment about dynamic languages and satisfying the compiler
20:28:26 <dobblego> blackdog, I wrote that weeks ago, I'll have to reread it :)
20:28:36 <Eduard_Munteanu> EvanR: I don't think so, Git merely asks you to solve conflicts, unless they're trivial :)
20:28:53 <EvanR> in this case there is no conflict
20:28:58 <aristid> EvanR: if you store the old and the new balance in each transaction, you can combine parallel transactions, similar to a rebase in git :D
20:29:01 <EvanR> because you would not ask it to merge anything
20:29:28 <EvanR> aristid: it wont work, that leads to the original problem of having the wrong total
20:29:44 <stepcut> aristid: I think I did that in my  double entry book keeping web app
20:29:46 <aristid> EvanR: you change the transaction of course to fix that
20:29:59 <dobblego> blackdog, oh that comment was by an ignorant colleague of mine, I just dismiss him :)
20:29:59 <aristid> stepkut: is it online?
20:30:00 <EvanR> dejavu...
20:30:09 <EvanR> if the 'transaction' consists of the total balance only
20:30:12 <EvanR> what is there to fix
20:30:22 <aristid> EvanR: it consists of total balance and old balance.
20:30:32 <EvanR> ah, parent ref
20:30:43 <EvanR> its effectively a diff
20:30:47 <aristid> yup
20:30:54 <stepcut> aristid: no. I had the stupid idea that switching to quickbooks would be easier than writing my own accounting package and stopped maintaining it.
20:31:16 <EvanR> well that leads back to the original working version of this scheme
20:31:43 <Eduard_Munteanu> I think you still need some degree of atomicity somewhere, don't you?
20:31:55 <EvanR> no
20:32:10 <EvanR> except for the atomicity of committing a transaction or not
20:32:21 <aristid> stepcut: and you have been proven wrong?
20:32:24 <EvanR> inserting into a table or not
20:32:42 <EvanR> (not half insertions)
20:33:09 <stepcut> aristid: yeah. For example, quickbooks only does average cost inventory tracking, which is *not* a method of inventory tracking that the IRS allows..
20:33:36 <aristid> stepcut: that's business acounting?
20:33:42 <stepcut> aristid: yes
20:33:58 <EvanR> Eduard_Munteanu: if you dont have an auto increment counter for instance, then you dont need a lock anywhere
20:34:02 <stepcut> aristid: that's what quickbooks is for (different than quicken)
20:34:06 <aristid> stepcut: isn't there better accounting software for businesses that actually follows the myriad IRS rules?
20:35:13 <stepcut> aristid: accounting firms use multi-thousand dollar packages. But most small businesses use quickbooks. If you want to work with a small business accountant, it is a system they will know.
20:35:30 <aristid> stepcut: and they just fix the mistakes by hand?
20:35:52 <EvanR> the irs has fixed all my mistakes to date
20:35:53 <EvanR> for me
20:36:26 <aristid> EvanR: heh
20:36:41 <stepcut> aristid: dunno. We just shutdown the old version of the company and restarted it fresh with an accountant that does everything. Now we don't have to use quickbooks at all :)
20:36:42 <EvanR> its like a compiler!
20:36:54 <kmc> http://achewood.com/index.php?date=02272003 pic is related
20:37:03 <stepcut> EvanR: my manager got audited once.. he said it was great, they found a bunch of deductions he missed..
20:37:14 <aristid> EvanR: but hopefully not like a c++ compiler
20:37:18 <Eduard_Munteanu> EvanR: not really a lock, but I rather meant atomic r/w or testing
20:37:34 <EvanR> Eduard_Munteanu: atomic what?
20:37:45 <Eduard_Munteanu> EvanR: atomic read/write operations
20:38:24 <Eduard_Munteanu> or stuff like test and set.
20:38:33 <EvanR> well inserting records (ignoring auto incrementing ids) dont interact with each other
20:38:34 <Eduard_Munteanu> It isn't truly locking.
20:39:18 <Eduard_Munteanu> EvanR: hm, I was looking at the total balance + old balance idea ^
20:39:29 <EvanR> yeah i throw that idea out ;)
20:40:10 <Eduard_Munteanu> EvanR: do you mean that for each transaction or just for the total?
20:40:19 <EvanR> it would need not just the old balance, but the old account state identifier
20:40:40 <EvanR> so that when two transactions were applied to the same state, they can be 'rebased'
20:40:45 <EvanR> later
20:41:16 <EvanR> you cant rebase all transactions that were applied to when the account was at a certain amount of money
20:41:54 <kmc> git finance?
20:42:01 <aristid> EvanR: with that method you can easily look up the account balance at any point
20:42:12 <Eduard_Munteanu> EvanR: do you accept the possibility of a transaction failing? (cleanly)
20:42:18 <EvanR> aristid: in several branches of history no less!
20:42:19 <Eduard_Munteanu> kmc: sorta :)
20:42:32 <EvanR> Eduard_Munteanu: in what scheme?
20:42:32 <aristid> EvanR: not if it's fully rebased :)
20:42:43 <Eduard_Munteanu> EvanR: the one you just mentioned.
20:42:56 <EvanR> aristid: the process of rebasing sounds like we have to reconsider everything all over again so IT works out
20:43:23 <EvanR> Eduard_Munteanu: assuming you dont rebase anything, nothing can fail except the act of completing your transaction
20:43:35 <EvanR> like you never send the atomic OK 
20:43:38 <aristid> EvanR: we could introdcue merges
20:43:50 <Eduard_Munteanu> EvanR: I'm not sure it works out if two independent retailers want to substract an amount from your total, and you have less than the sum.
20:44:08 <aristid> Eduard_Munteanu: it depends on if they subtract at the same time
20:44:10 <Eduard_Munteanu> EvanR: the transaction can be recorded, but it can never be cleanly rebased
20:44:10 <EvanR> Eduard_Munteanu: it works out just like my original uch simpler plan
20:44:33 <EvanR> you have negative because there was no way to know not to debit
20:44:34 <aristid> but no we have rebase and merge and all this wonderful complexity
20:44:42 <aristid> *now
20:44:44 <Eduard_Munteanu> aristid: same time, I'm bringing in worst case concurrency :)
20:45:00 <EvanR> in the case of git finance, you have two histories, both above zero! ;)
20:45:08 <Eduard_Munteanu> EvanR: hm, that's interesting.
20:45:09 <EvanR> i like that
20:45:15 <aristid> only when you merge them does it become negative
20:45:18 <EvanR> quantum bank account
20:45:24 <EvanR> just dont merge
20:45:34 <Eduard_Munteanu> Just don't query it :)
20:45:38 <EvanR> yeah
20:45:51 <EvanR> Eduard_Munteanu: well you have to choose which branch to commit future debits to
20:46:00 <EvanR> and so query its head
20:46:07 <EvanR> which may branch more ;)
20:46:14 <Eduard_Munteanu> Ouch.
20:46:47 <Eduard_Munteanu> Lock-free algos are certainly interesting.
20:47:07 <ddarius> EvanR:  I didn't read all of the previous, but I believe a typical approach to trim down the log is to checkpoint.  The way you do that is by -adding- a checkpoint transaction.  Once it is safely committed you can delete all previous transactions.
20:47:10 <aristid> EvanR: you should totally implement that
20:47:40 <EvanR> aristid: yes.  ....  no.
20:47:49 <ddarius> Usually there will be sequence numbers handed out so that a transaction knows what's before and after it.
20:47:50 <Eduard_Munteanu> So... lock every once in a while?
20:48:07 <aristid> EvanR: :(
20:48:16 <EvanR> ddarius: so this checkpoint has the balance up to that point?
20:48:46 <aristid> EvanR: i was expecting you to revolutionse banking with the git-quantum-finance package
20:48:52 <ddarius> EvanR: In this simple case, yes, where "up to that point" is from every transaction with a sequence number earlier than the checkpoint transaction.
20:49:11 <Eduard_Munteanu> Public finance is already kinda quantum.
20:49:12 <EvanR> ah ok, checkpoint is a transaction of +0
20:49:25 <ddarius> EvanR: That's one way to view it.
20:49:32 <aristid> ddarius: i think with the "git" approach you can always kill old transactions
20:49:38 <EvanR> then after ward you can check the balance there, do whatever with it, and possibly delete previous history
20:49:44 <aristid> because every transaction is a snapshot of the state
20:50:04 <EvanR> aristid: i thought we established that it was a joke
20:50:09 <ddarius> Yes, the checkpoints optimize "summing" the transaction log even if you don't remove the earlier transactions.
20:50:31 <EvanR> the act of merging or rebasing is just too many cans of worms
20:50:55 <aristid> EvanR: it's an intellectual exercise, and as such to be taken seriously! :)
20:51:03 <EvanR> alright
20:51:24 <EvanR> why would you go this route if the end result is to fix it so its like the original simpler version
20:51:27 <aristid> EvanR: also i think merging would be pretty trivial in that case.
20:51:34 <EvanR> and you must fix it as soon as possible so balances are possible
20:52:23 <aristid> EvanR: dunno, maybe it has some other advantages. that's why thought experiments are useful :)
20:52:42 <EvanR> grumble grumble
20:53:42 <EvanR> since the goal is a single history as soon as possible, and is in principle possible to achieve, the only advance could be in the time between the commit and the repairing of history
20:53:46 <Eduard_Munteanu> Last time they did a thought experiment they dropped local realism, how's that useful? :P
20:53:50 <EvanR> only advantage
20:55:11 <EvanR> i came to this topic because i was reading about the idea of modifying data
20:55:54 <EvanR> modifying data in haskell amounts to effectively making a copy and changing parts of it, or making a modified copy of parts of it and sharing the rest
20:56:11 <EvanR> this seems to be generally useful
20:56:21 <EvanR> in concurrency
20:57:37 <Eduard_Munteanu> This sounds a bit like RCUs.
20:57:44 <EvanR> RCU?
20:57:54 * Eduard_Munteanu looks up...
20:58:05 <ddarius> There's a wikipedia page.
20:58:07 <Eduard_Munteanu> http://en.wikipedia.org/wiki/Read-copy-update
20:58:12 <Eduard_Munteanu> Yeah.
20:58:16 <ddarius> http://en.wikipedia.org/wiki/Read-copy-update
20:58:40 <Eduard_Munteanu> It's used quite a lot in Linux.
20:59:12 <EvanR> hm. well on a more coarse grained scale the gc takes care of this
20:59:36 <Eduard_Munteanu> Well, don't choke on the C magic there though.
21:00:26 <Eduard_Munteanu> EvanR: yeah, eventually everything is a copy in HaskellWorld, though things may be better in RealWorld.
21:01:39 <EvanR> i almost invented this
21:01:51 <ddarius> Databases have been around almost as long as computers have been around, and they are nothing but a big chunk of highly contended shared state.  The database community knows concurrency control (and many other things.)
21:02:43 <EvanR> unfortunately i havent been working with databases and the database community simultaneously
21:02:49 <EvanR> only the former
21:03:07 <EvanR> i figured they knew what they were doing and would tell me, i was wrong
21:03:11 <EvanR> now i have to tell them
21:03:29 <ddarius> EvanR: By "database community" I mean the implementors not the users.
21:03:35 <EvanR> oh
21:03:40 <Eduard_Munteanu> They usually deal with solutions optimized to perform well on a large variety of access patterns.
21:03:44 <EvanR> so users are as clueless as me?
21:03:58 <ddarius> EvanR: It varies.
21:03:58 <Eduard_Munteanu> EvanR: you can bet on that.
21:04:04 <Eduard_Munteanu> Take the average PHP coder.
21:04:08 <ddarius> A good DBA is paid more than a good coder.
21:04:44 <Eduard_Munteanu> Analysts in general yeah.
21:04:58 <Eduard_Munteanu> (unless you meant admin)
21:05:28 <Eduard_Munteanu> s/analyst/architect   whatever.
21:05:56 <ddarius> EvanR: I highly recommend reading even old papers on database implementation.  Database implementors have to solve a lot of hard problems simultaneously, and they've been working at it for almost 60 years.
21:06:14 <EvanR> what a novel idea
21:06:29 <EvanR> i seem to be implementing a database
21:07:04 <ddarius> EvanR: It's very unlikely that you have all the requirements of an actual database, but a lot of the problems they've faced and solved apply more widely.
21:07:11 <ddarius> Where do you think STM comes from?
21:07:28 <Eduard_Munteanu> I'd take "database" with a grain of salt. Highly specialized storage solutions are concieved in a different mindset than databases. For example filesystems.
21:07:30 <EvanR> high performance is not a requirement, unless it is
21:08:17 <EvanR> ddarius: well im thinking the spatial configuration of things in a mud should really be a relation rather than an oop heirarchy
21:09:48 <EvanR> when i hacked lambdamoo, i found that i kept wanted to expand out of the 'object is in some object, or not' box
21:09:57 <EvanR> so i did by adding extra lists
21:10:19 <EvanR> on top of, under, next to, behind, attached to
21:10:22 <EvanR> wearing
21:11:44 <EvanR> ddarius: do you have a link to these papers? google thinks im trying to design tables
21:12:00 <rryan> EvanR: google scholar ? 
21:12:24 <kmc> http://hpaste.org/41272/numbers_from_a_string is there an existing function for this, or some nicer idiom?
21:12:29 <ddarius> Let me see if Google Desktop wants to be useful (and take rryan's advice), but I haven't read anything particularly general purpose/significant in like 6-7 years.
21:13:10 <kmc> in particular breaking a string into groups of stuff satisfying a predicate
21:13:14 <kmc> maybe 'split' does it?
21:14:05 <EvanR> kmc: Data.List.Split seems to have combinators to build such things
21:14:16 * Eduard_Munteanu tries to read the wikipedia article on lambdamoo but finds it incredibly opaque at this hour
21:14:23 <EvanR> it is
21:14:56 <EvanR> both the architecture, the culture, the system, and the existing lambdamoo world
21:15:03 <EvanR> s/both/all of the above/
21:16:02 <Eduard_Munteanu> Also the "rape" thingy. Anyway, maybe I need more sleep.
21:16:09 <EvanR> lol. that.
21:16:20 <Eduard_Munteanu> Yeah, 
21:16:28 <Eduard_Munteanu> I double-checked if that wasn't uncyclopedia.
21:16:48 <EvanR> after researching that extensively, i was left with an inexorible urge to say 'welcome to the internet'
21:17:11 <EvanR> but it was like 1992 so maybe people thought differently then
21:17:24 <Eduard_Munteanu> Oh.
21:17:59 <Eduard_Munteanu> '   One user whose avatar was a victim, called his voodoo doll activities "a breach of civility" while, in real life, "post-traumatic tears were streaming down her face".   '
21:18:37 <Eduard_Munteanu> I'm having difficulties understanding basic words here.
21:18:44 <EvanR> well, if the voodoo dolls were working, i would be upset too
21:19:05 <EvanR> but that would be a security flaw, not a breach of civility
21:19:56 <EvanR> probably some social engineering involved
21:20:05 <EvanR> he was psychopathic
21:21:38 <Eduard_Munteanu> Still, that article sounds like the writers doing D&D in-character.
21:22:04 <EvanR> is that the article by the journalist?
21:22:10 <Eduard_Munteanu> '   Additionally, upon his return from his business trip, LambdaMOO's main creator, Pavel Curtis (screenname Archwizard Haakon), set up a system of petitions and ballots  where anyone could put to popular vote anything requiring master-programmer (known as "wizardly") powers for its implementation.    '
21:22:27 <Eduard_Munteanu> EvanR: just the wikipedia coverage http://en.wikipedia.org/wiki/A_Rape_in_Cyberspace
21:22:42 <Eduard_Munteanu> Dunno, sounds 'remote' to me.
21:22:52 <EvanR> remote?
21:22:55 <EvanR> thats what happened
21:23:32 <EvanR> lambdamoo was more hands-on than say irc or a typical mud
21:23:46 <Eduard_Munteanu> Yeah, I don't understand any of those details, perhaps I need to take a look at lambdamoo itself.
21:23:58 <Eduard_Munteanu> EvanR: somewhat like Second Life or something?
21:24:03 <EvanR> yes
21:24:25 <Eduard_Munteanu> Oookay... people take this stuff a bit too seriously.
21:24:49 <EvanR> i dont know about second life, but see also this curiosity ;)
21:24:59 <EvanR> http://www.activeworlds.com/
21:25:53 <Eduard_Munteanu> Hm, it looks interesting. I never tried stuff like that.
21:26:14 <EvanR> Eduard_Munteanu: in a mud/mmo you spend 1000s of hours hitting a certain monster
21:26:34 <EvanR> in moo or these other systems probably, you spend that long crafting things
21:26:51 <EvanR> you could get attached, and it would suck if someone did things to them/you
21:27:04 <Eduard_Munteanu> Ah, it makes sense then.
21:27:09 <ddarius> EvanR: Google Desktop wasn't too helpful, but it did bring up one paper that had some useful references.
21:27:27 <EvanR> i downloaded something...
21:28:16 <Eduard_Munteanu> This looks a bit like what WorldForge is trying to accomplish, unfortunately they're nowhere. :/
21:28:26 <dancor> hm how is read-copy-update different from copy-on-write?
21:28:37 <ddarius> EvanR: There's the Starburst system (http://www.almaden.ibm.com/cs/starwinds/starburst.html) which has a reference to ARIES (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.109.2480), the EXODUS system which became SHORE (http://www.cs.wisc.edu/shore/), there's, of course, POSTGRES (http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.48.2909).
21:29:22 <Eduard_Munteanu> dancor: COW describes semantics, RCU is a concurrency solution.
21:29:25 <Eduard_Munteanu> dancor: in more detail...
21:30:40 <ddarius> There's something indirectly related to Starburst that preceded it about which I remember reading a decent amount, but I can't remember the name.
21:30:41 <Eduard_Munteanu> RCU is a scheme you use to solve concurrency problems, the fact that it works like it does is merely secondary.
21:31:28 <Eduard_Munteanu> While in COW, you expect an update to actually make updated copies instead of altering the original. The original never goes away after a grace period.
21:31:36 <ddarius> There are also others that are more logging/transaction oriented like ARIES whose names I'm also not remembering right now.
21:32:18 * dancor implodes
21:32:27 <EvanR> lol
21:32:31 <ddarius> EvanR: Obviously check the references and citations to the publications related to those projects.
21:32:35 <EvanR> yes
21:32:38 <ddarius> You really want to follow references for this stuff.
21:33:02 <EvanR> i wonder if ill be better at databases after this
21:33:03 <Eduard_Munteanu> dancor: take how mmap() is used to map libraries into programs.
21:33:11 <EvanR> and be able to actually do my job, and my managers job
21:33:39 <Eduard_Munteanu> dancor: there's no actual concurrency issue there, you simply want each update to occur for that specific users, they're not propagated.
21:34:21 <Eduard_Munteanu> dancor: that's copy on write.
21:34:43 <Eduard_Munteanu> Multiple programs using the same mmaped lib never actually step on each other's toes.
21:35:15 <EvanR> mmapped libs dont need to be mutated, i dont understand
21:35:25 <dancor> a program never modifies the library code it's using (unless the programmer is very evil)
21:35:28 <dancor> ya
21:36:05 <EvanR> theres some writable state but its not 'in the lib'
21:36:45 <ddarius> I think Eduard_Munteanu's point is that even if you did mutate them, the change doesn't need to and shouldn't be propagated to others.
21:37:12 <dancor> maybe if you update the library
21:37:35 <EvanR> discussion has gotten out of hand!
21:37:35 <dancor> only new program-instances with see the new version
21:37:42 <dancor> we've gone too far
21:37:51 <dancor> ok anyway i think i understand COW
21:38:02 <dancor> but not RCU
21:38:59 <EvanR> i almost invented RCU. in real time audio dev, you have to mess with an audio thread which runs to get samples and cant be interrupted (without causing drop outs). in order to modify a sequencer state from the gui thread, you need to be able to safetly modify shared data without locking
21:39:32 <Eduard_Munteanu> EvanR: they do.
21:39:47 <Eduard_Munteanu> EvanR: actually the writable state is mapped in the lib
21:39:58 <dancor> i guess RCU doesn't let "old viewers" continue to see an old copy beyond a grace-period?
21:40:06 <Eduard_Munteanu> EvanR: but behind the scenes, the kernel makes a private copy of that page.
21:40:21 <EvanR> so the update is to a copy of the data which is atomically swapped out when ready. but apparently RCU has a facility to deallocate the old one as soon as its not needed, which was too much for me
21:40:27 <EvanR> and anyway you need to be able to undo so
21:41:03 <Eduard_Munteanu> Anyway, they suit different purposes.
21:41:21 <Eduard_Munteanu> One solves concurrency, the other does sharing.
21:42:02 <EvanR> at this point the idea of writing to data structures, much less concurrently shared structures, seems very alien to me
21:42:20 <dancor> i guess COW still allows write clobbering
21:42:22 <dobblego> is Data.Tree isomorphic to (a, a -> [a]) ?
21:42:26 <EvanR> all that makes sense is foo { field = bar }
21:45:55 <Eduard_Munteanu> dancor: that problem isn't formulated in COW. In COW, everybody has its own private copy, but which is shared somewhere behind the scenes.
21:46:29 <Eduard_Munteanu> (the unaltered parts are shared)
21:46:56 <ddarius> dobblego: Clearly not.
21:47:16 <dobblego> I just finished table tennis so it's not clear to me, but it will be soon
21:47:42 * Eduard_Munteanu leaves to school...
21:47:57 <EvanR> Eduard_Munteanu: COW is annoying. the presense or absense of that optimization completely alters the semantics of imperative algorithms
21:48:23 <ddarius> dobblego: I think I know what you are trying to get at, which is roughly a coalgebraic presentation of a tree.
21:48:26 <Eduard_Munteanu> EvanR: well COW is a plumbing thingy after all.
21:48:35 <EvanR> well it doesnt, but you completely have to change the algorithm or face extreme inefficiencies
21:48:50 <Eduard_Munteanu> EvanR: makes more sense in C than in Haskell.
21:49:01 <Eduard_Munteanu> In Haskell memoization and all that happens behind the scenes.
21:49:15 <EvanR> COW is a php python thing really
21:49:31 * Eduard_Munteanu really has to go...
21:49:33 <dobblego> ddarius, how would that look?
21:49:33 <Eduard_Munteanu> Bye :).
21:49:35 <EvanR> never!
21:52:07 * hackagebot copilot 0.25 - A stream DSL for writing embedded C monitors.  http://hackage.haskell.org/package/copilot-0.25 (LeePike)
21:52:18 <ddarius> data Tree a = Tree { leaf :: a, children :: [Tree a] } would be most direct, but we could also represent that as data Tree a = forall t. Tree t (t -> a) (t -> [t]) which I think is what you were getting at.
21:52:37 <dobblego> forall t. Tree t (t -> a) (t -> [a]) ?
21:52:54 <dobblego> oh yes
21:53:01 <ddarius> dobblego: No, that wouldn't allow subtrees.
21:53:04 <dobblego> right
21:55:36 <benl23> Alright, so (c a1 -> c a2) is to fmap as  (c1 a -> c2 a) is to what??
21:55:57 <ddarius> factors n = Tree n id (\n' -> let ff = firstFactor n' in [ff, n' `div` ff])
21:56:38 <copumpkin> benl23: applyNatTrans? :P
21:57:57 <benl23> copumpkin: I want a typeclass for it, like Functor. Do you know if there is one?
21:58:30 <copumpkin> nope, but typically it's a value-level thing. I've seen something like type NatTrans f g = forall a. f a -> g a
21:58:35 <copumpkin> in category-extras, probably
21:59:00 <copumpkin> like, there are multiple ways to go from Maybe to []
21:59:04 <benl23> copumpkin: ok thanks, I'll look
21:59:05 <ddarius> copumpkin: But that's different from having a distinguished family.
21:59:13 <copumpkin> a typeclass wouldn't let you name them
22:01:04 <copumpkin> I could see it being a two-parameter typeclass
22:01:23 <copumpkin> class Moo f g where baa :: f a -> g a
22:01:34 <copumpkin> but I'm not sure what the benefit of that would be
22:03:32 <EvanR> copumpkin: another revolutionary idea goes out the window ;)
22:03:47 <copumpkin> hey, I'm not saying it wouldn't be beneficial
22:03:50 <copumpkin> just that I can't see it :)
22:04:29 <copumpkin> it reduces your naming ability from an arbitrary haskell name to an ordered pair of haskell types
22:04:43 <copumpkin> but in return gives you the ability to look that up implicitly
22:05:33 <ddarius> @src Typeable1
22:05:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:10:03 <Pseudonym> All right, paper submitted.
22:10:13 <Pseudonym> Hope the reviewers are happy this time.
22:13:20 <EvanR> Pseudonym: did you use your nick as the author
22:13:55 <Pseudonym> That'd be amusing, wouldn't it.
22:14:07 <Pseudonym> Hey, I should use it next time I have to review something.
22:32:08 <dkannan> does anyone still use gofer?
22:32:20 <Pseudonym> Hugs is Gofer
22:45:09 <Twey> dkannan: So no ;)
22:47:40 <dkannan> ok. my prof still uses gofer (learning independently).
22:47:44 <dkannan> wiki says that the gofer type system has something "extra". whats that?
22:48:51 <benl23> TREX, rank-2 types.
22:48:57 <benl23> Other things not a part of Haskell 98
22:49:28 <benl23> Though gofer isn't Haskell, some of the syntax is different
22:49:40 <benl23> similar though
22:51:54 <Pseudonym> Also, some of the semantics of the HM extensions might not be qutie the same.
22:54:35 <dkannan> right, will learn over a period of time i guess :-P
22:55:37 <dkannan> is there a wiki or discussion-thread explaining this - would be useful after learning for sometime to compare hugs and gofer   
22:56:26 <ddarius> Gofer is extremely old.
22:56:40 <benl23> dkannan: It only needs one line "forget about Gofer, use Hugs"
22:56:57 <benl23> or better, GHCi unless you really need a small memory footprint
22:57:04 <benl23> IIRC Hugs is less greedy
22:57:42 <dkannan> ok. will discuss with the prof
22:58:45 <benl23> dkannan: who is your prof? better make sure they didn't WRITE Gofer though :P
23:32:44 <Unforgiv> I've been looking into the Prelude file and I found something I dont understand
23:32:54 <Unforgiv> curry          :: ((a,b) -> c) -> (a -> b -> c)
23:32:54 <Unforgiv> curry f x y     = f (x,y)
23:33:02 <Unforgiv> where are the x and y coming from?
23:33:15 <Unforgiv> I thought that f was the ((a,b) -> c)
23:33:19 <dmwit> It is.
23:33:30 <dmwit> The x and y have types 'a' and 'b', respectively.
23:33:31 <arcatan> x and y are the latter a and b
23:33:36 <Unforgiv> the same applies for the uncurry, I dont understand that as well
23:33:36 <dmwit> Would it be clearer if it was written as
23:33:42 <dmwit> curry f = \x y -> f (x,y)?
23:33:45 <dmwit> This is equivalent.
23:33:53 <Unforgiv> hm 
23:33:58 <Unforgiv> that makes a bit more sense
23:34:23 <Unforgiv> but how come that works there ?
23:34:30 <Unforgiv> when man has the uncurry:
23:34:33 <dmwit> It works everywhere.
23:34:34 <Unforgiv> uncurry        :: (a -> b -> c) -> ((a,b) -> c)
23:34:38 <Unforgiv> uncurry f p     = f (fst p) (snd p)
23:34:43 <dmwit> foo = \a -> bar === foo a = bar
23:34:46 <Unforgiv> its the same I guess?
23:34:56 <lars9> feeling sorry about haskell, i worked on a problem using haskell for several days, then fall back to python ...
23:35:10 <dmwit> Another way to say this is that (a -> (b -> c)) and (a -> b -> c) are the *same* types.
23:35:39 <dmwit> So, curry :: ((a,b) -> c) -> (a -> b -> c) is the same as saying curry :: ((a,b) -> c) -> a -> b -> c
23:35:43 <Unforgiv> so its just an assumption about parameters used there
23:35:52 <lars9> because i found my haskell code is as ugly as c's, but as elegant as i read on the book LYAH, RWH, YAHT...
23:36:01 <dmwit> Unforgiv: assumption? what assumption?
23:36:07 <Unforgiv> oh wait
23:36:18 <Unforgiv> curry :: ((a,b) -> c) -> a -> b -> c
23:36:32 <Unforgiv> with that you have the f as ((a,b) -> c) and x and y as a and b right?
23:36:45 <dmwit> Yes. (...as I said above. ;-)
23:36:50 <Unforgiv> ah now I understand
23:37:04 <Unforgiv> still kinda weird that normally thats also written as a f or something
23:38:38 <Unforgiv> so when i get this correctly, with the uncurry man has the '(a -> b -> c) as 'f', and the (a,b) as 'p' ?
23:39:05 <dmwit> yes
23:39:27 <Unforgiv> aha, but why in the case of curry isnt the first (a,b) like 'f' and the next c the a ?
23:39:32 <dmwit> uncurry f ~(a,b) = f a b -- is another, perhaps clearer, way of writing it
23:39:49 <dmwit> uh, what?
23:40:09 <Unforgiv> well when you have curry its ((a,b)->c) -> (a -> b -> c)
23:40:17 <Unforgiv> so that would make the (a,b) the f
23:40:22 <dmwit> nooo
23:40:23 <Unforgiv> and the c a
23:40:29 <Unforgiv> or do I misread this :p
23:40:47 <Unforgiv> this notation doesnt make a lot of sense to me :p
23:40:47 <dmwit> No, in curry, f :: (a,b) -> c, not f :: (a,b).
23:41:13 <Unforgiv> then why is it in curry (a,b) -> c and in uncurry its (a,b)
23:41:18 <Unforgiv> while it says nearly the same
23:41:32 <dmwit> Because "nearly the same" is not "the same", of course.
23:41:42 <Unforgiv> yeah but the input is the output from the other
23:41:49 <Unforgiv> so that part is identical
23:41:59 <Unforgiv> but in the curry case its (a,b) -> c and in uncurry its (a,b)
23:43:20 <dmwit> uncurry f = \p -> f (fst p) (snd p) -- the same trick as before
23:43:35 <dmwit> uncurry f :: (a,b) -> c, as before
23:44:10 <Unforgiv> hm
