00:05:03 <Cale> havranek78: hmm
00:06:14 <havranek78> Cale, did you work with STFT?
00:07:02 <Cale> havranek78: Well, I'm not intimately familiar with it, but I get the basic idea.
00:07:18 <Cale> (I know how the FFT works, for example)
00:08:03 <havranek78> I am not sure, what should be the optimal approach - I expect, that using "fft" binding to "fftw3" will be unavoidable, when a decent speed is needed, ok? But how to implement the initial signal segmentation to get STFT?
00:08:36 <havranek78> Which data types should I use to avoid too much overhead?
00:09:47 <Cale> Well, what format is your initial data in? Probably at some point you'll be using ByteStrings (probably lazy for the stream, maybe strict for small chunks of it)
00:11:33 <havranek78> My initial data is in the PCM (.wav) format, currently I am using the "hsndfile" together with "vector" to read and process the data - this seems fast enough
00:11:33 <Cale> hmm, the fftw binding is apparently pretty low-level and wants the data as a CArray (which is the Haskell type for an array in the C language sense)
00:12:23 <Cale> Ah, so your data is already in Vectors...
00:12:29 <Cale> http://hackage.haskell.org/package/vector-fftw
00:12:35 <Cale> ^^ that might be appropriate then
00:16:49 <havranek78> Thanks - this package is new to me, I could try. And what should then be the optimal or at least good data representation of the segmented signal or the spectrogram?
00:20:30 <Cale> havranek78: Well, the slice function in Data.Vector is O(1), apparently. You could just make a list of slices to be iterated over.
00:22:37 <havranek78> Thank you very much, this is exactly, what I needed - I only was a little bit confused from all the possible data types, not being too experienced with Haskell at this level. 
00:45:50 <mm_freak> what's the preferred iteratee package?  i noticed that the 'enumerator' package is much simpler, but also much less powerful than the 'iteratee' package
01:02:26 <love_robot> Hello every body. :)
01:09:12 <Jafet> mm_freak: the one you write after you become dissatisfied by all the others
01:09:50 <mm_freak> Jafet: i tried to and failed horribly
01:10:13 <mm_freak> when trying to write the monad instance for my iteratee type
01:12:28 <love_robot> Would anybody suggest fastcgi or maybe an alternate cgi to serve a simple Haskell webpage?
01:15:04 <mm_freak> love_robot: what's "a simple haskell webpage"?  most web frameworks in haskell assume a persistent daemon
01:20:47 <love_robot> mm_freak: I didn't want to use a framework yet.
01:21:14 <love_robot> I was going to use fastcgi + apache... and just wondered if some thing else rather than fascgi would be recommended
01:23:12 <Jafet> There's certainly a fastcgi library somewhere
01:25:18 <Jafet> mod_haskell_main :: (Monad m) => Request -> m Response
01:25:43 <love_robot> Jafet: :)
01:26:31 <love_robot> Yeah, I see a fastcgi library in hackage ( of course).
01:51:15 <yitz> love_robot: Not too long ago I did a low-load project using just regular cgi. worked out great!
01:51:39 <yitz> fastcgi should be fine too
01:53:01 <Jafet> I've written some small cgi programs, with only getContents, getEnvironment and putStr
01:53:27 <yitz> love_robot: another option to consider, if it works for your project, is static site generators like hakyll.
01:54:16 <yitz> Jafet: yep, if you don't need to do any serious form processing, that's also great.
02:02:01 <iron> hi
02:02:44 <iron> i want to show a function for debugging reasons. i hava a type FList a = [a] -> [a]
02:03:01 <iron> now i am stuck.
02:03:32 <love_robot> opps I didn't see you guys responded... thanks
02:03:36 <iron> i tried: showFList :: (Show a) => ([a] -> [a]) -> String
02:03:37 <iron> showFList xs ys = show xs ++ " -> " ++ show ys
02:03:49 <love_robot> yitz: Thanks for the suggestion.
02:04:01 <iron> but i get a type mismatch
02:04:21 <b_jonas> iron: that doesn't make sense. what would xs be?
02:04:25 <yitz> love_robot: we're a little slow today
02:04:33 <opqdonut> iron: showFList takes _one_ argument, a function from [a] to [a]
02:04:42 <iron> b_jonas: i thought the first part of my list
02:04:47 <opqdonut> your equation for it has _two_ arguments, xs and ys
02:05:16 <iron> at least what i intended
02:05:27 <b_jonas> showFList f = show xs ++ " -> " ++ show (f xs) where xs = [3,1,4,1,5,9,2]
02:05:33 <yitz> iron: showFList :: Show a => [a] -> [a] -> String
02:05:34 <b_jonas> or something
02:06:06 <yitz> iron: "->" is right-associative, not left-associative
02:07:10 <iron> i will try.
02:08:39 <iron> i get [b] -> [b] does not match [a]
02:12:50 <b_jonas> iron: look, 'showFList xs ys = show xs ++ " -> " ++ show ys' won't ever do you more than show two lists
02:12:57 <b_jonas> that won't show you a function
02:13:22 <b_jonas> if you want to show a function using a sample input, you need to somehow need to get a sample input, haskell won't just make you up one
02:14:21 <iron> yeah i have anther function to generate my input
02:14:31 <iron> fromList        :: [a] -> FList a
02:14:32 <iron> fromList l      = \ xs -> l ++ xs
02:14:55 <b_jonas> > let { showFList :: ([Int] -> [Int]) -> String; showFList f = show xs ++ " |-> " ++ show (f xs) where { xs = [3,1,4,1,5]; }; } in showFList tail
02:14:55 <iron> so i call: showFList fromList [1,2,3]
02:14:56 <lambdabot>   "[3,1,4,1,5] |-> [1,4,1,5]"
02:15:48 <b_jonas> huh? what's FList now? I don't understand what you're doing
02:16:05 <iron> FList is a function that holds data
02:16:10 <b_jonas> could you explain from the beginning what you're trying to do?
02:16:31 <b_jonas> FList is a tycon there
02:16:46 <iron> whats a tycon?
02:16:52 <b_jonas> type constructor
02:16:57 <b_jonas> when I'm lazy to type
02:17:10 <iron> type FList a = [a] -> [a]
02:17:20 <love_robot> lol nice @ tycon
02:17:37 <b_jonas> oh, so it's just a type synonym
02:17:46 <iron> i just want to print out both lists
02:17:48 <iron> thats all
02:17:50 <b_jonas> so you have fromList :: [a] -> [a] -> [a]
02:17:57 <iron> yeah thats my problem
02:18:06 <iron> i saw examples for data FList ...
02:18:09 <b_jonas> what both lists?
02:18:13 <iron> yeah
02:18:21 <b_jonas> you don't have any lists, only a function that acts on lists
02:18:26 <iron> yeah
02:18:30 <iron> wait
02:18:34 <b_jonas> you have to supply some example lists or you can't display anything
02:19:02 <iron> hmmm
02:19:16 <iron> so it is not possible as i planned it?
02:19:27 <b_jonas> @let showFList :: ([Int] -> [Int]) -> String; showFList f = show xs ++ " |-> " ++ show (f xs) where { xs = [3,1,4,1,5]; };
02:19:28 <lambdabot>  Defined.
02:20:02 <b_jonas> > let { fromList l = \ xs -> l ++ xs; } in showFList (fromList [1,2,3])
02:20:03 <lambdabot>   "[3,1,4,1,5] |-> [1,2,3,3,1,4,1,5]"
02:20:29 <b_jonas> it certainly is, but you do need an example input like the [3,1,4,1,5] above
02:20:38 <b_jonas> the example could be [] if you can't find any better one
02:21:01 <iron> ok i need to look a while at the code :)
02:21:58 <iron> can't i pass xs?
02:22:21 <iron> i mean as a parameter.
02:22:22 <b_jonas> you could
02:22:50 <iron> ok now i understand the problem :)
02:23:10 <iron> thanks.
02:27:09 <polypus> i'd like to write a function f :: g -> a, where g is a function of generic type, and a is the return type of the fully applied function. is this possible?
02:27:56 <Botje> polypus: f undefined
02:28:17 <Botje> err, well
02:28:22 <Botje> f g = g undefined
02:28:30 <Botje> that's about the best you can do i think
02:28:57 <Jafet> @djinn (a -> b) -> b
02:28:57 <lambdabot> -- f cannot be realized.
02:29:47 <Botje> hah! i'm smarter than @djinn!
02:29:54 <sipa> if g is t -> t, you can use fix
02:30:24 <sipa> @djinn (a -> a) -> a
02:30:24 <lambdabot> -- f cannot be realized.
02:30:31 <polypus> Batje: ty, i'll have a look see at undefined (haskell noob here)
02:30:50 <Botje> undefined is a value of any type
02:31:02 <Botje> and if you evaluate it your interpreter crashes
02:31:05 <Botje> > undefined
02:31:06 <lambdabot>   *Exception: Prelude.undefined
02:31:48 <Jafet> polypus: what would you want f to do with its argument?
02:32:03 <Jafet> polypus: all Haskell functions take an argument.
02:32:22 <Botje> "hello, i'm here for an argument"
02:34:23 <polypus> Jafet: f ideally takes a function g of generic type. i don't want to specify what kind of function it accepts. but i'd like to be able to say that it returns the same thing that g returns
02:35:10 <opqdonut> how can it return anything?
02:35:37 <Jafet> :t let f :: (a -> b) -> b; f g = g undefined in f
02:35:38 <lambdabot> forall a b. (a -> b) -> b
02:35:50 <opqdonut> anything meaningful, that is
02:36:11 <Jafet> I suspect polypus does not understand his own question, though.
02:36:21 <Jafet> > let f :: (a -> b) -> b; f g = g undefined in f (const 42)
02:36:22 <lambdabot>   42
02:37:50 <polypus> Jafet: g might take more than one argument
02:38:20 <polypus> maybe this must be specified at compile time though
02:38:28 <sipa> functions in haskell take exactly one argument :)
02:38:39 <sipa> the rest is currying
02:38:50 <Jafet> > let f g = g undefined; g has a whole bunch of arguments here = 42; in f g
02:38:51 <lambdabot>   <no location info>: parse error on input `of'
02:38:57 <Jafet> > let f g = g undefined; g has a whole bunch o' arguments here = 42; in f g
02:38:58 <lambdabot>   Overlapping instances for GHC.Show.Show
02:38:58 <lambdabot>                              (t -> ...
02:39:47 <sipa> polypus: still, can you give a useful example of wat f could do?
02:40:29 <Jafet> You could do it by abusing Functor, probably
02:42:28 <polypus> it was a distilled example. f would actually take a list of functions, some other data, choose one, and call it based on that data
02:43:11 <polypus> but i'd like the "arity" (currying aside) and the types of [f] to be generic
02:43:50 <polypus> i mean types of [g]
02:44:04 <sipa> you can
02:44:31 <sipa> but you'll need to know something about those functions
02:44:50 <sipa> or you can't aplly them to anything
02:45:36 <sipa> eg. foo :: [a -> b] -> a -> b
02:45:38 <polypus> sipa: can i know something reflectively?
02:45:52 <Jafet> polypus: motivate us with an example of why you want to do that.
02:46:06 <Jafet> Your question is still foggy
02:47:36 <polypus> Jafet: it's for a grammar based genetic programming lib where i can't know ahead of time the signatures of the functions the use might use
02:47:44 <polypus> user*
02:47:58 <b_jonas> you have to keep the invariant of instances not being overlapping. it's a rule you can't just work around. 
02:48:52 <b_jonas> polypus: store the functions in some wrapped state so they take a list of distinguished unions or something
02:48:57 <b_jonas> if you want to interpret stuff
02:50:18 <polypus> b_jonas: ty. is there some good tutorial/resource on dynamic/reflective haskell
02:50:54 <b_jonas> it's not haskell that's dynamic or reflective (in this case), it's how you interpret the grammar you mention
02:51:28 <Jafet> Distinguished unions?
02:51:40 <b_jonas> Jafet: algebraic data types
02:52:11 <b_jonas> Jafet: that is, passing an Either Int Bool instead of trying to pass either an Int or a Bool and messing with classes without understanding the type system
02:53:01 <Jafet> Right. That depends on how complicated that "genetic programming" really is
02:54:40 <b_jonas> "interpreter" is the key word here
02:55:10 <Jafet> Now that I've actually read rwh, I keep getting tempted to just toss it at people who ask these questions. It's pretty cookbook.
02:56:35 <polypus> i'm waiting for my copy in the mail (i'm a week into haskell). does it contain a relevant section?
02:56:58 <b_jonas> polypus: look that up on the internet
02:57:25 <b_jonas> table of contents at http://book.realworldhaskell.org/read/
02:58:07 <b_jonas> then there's also Write Yourself a Scheme
02:58:57 <polypus> b_jonas: i'm considering it
02:59:00 <Jafet> polypus: parsing and doing stuff to data is one of the running themes in the book.
03:00:44 <polypus> Jafet: ty
03:01:23 <polypus> b_jonas: i see you meant http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours . i was actually considering it, so good resource
03:09:43 <Itkovian> !tell relix go score you http://www.hln.be/hln/nl/7996/showbizz/photoalbum/detail/1185578/902350/0/Kandidates-Miss-Belgie-vertrokken-naar-Thailand.dhtml
03:09:50 <Itkovian> oops :-)
03:09:55 <Itkovian> wrong channel sorry bout that
03:30:33 <DeadPanda> Hi, I'm having some trouble building a model for playing around with algorithms monitoring information flow; my current code's at http://hpaste.org/41701/information_flow_model - I'm torn between a model that is rigidly correct (a flow can never be instantiated on a pair of static objects, and must always involve an actor) that seems difficult to work with, or a more relaxed model that's easier to work with (repositories and actors share a common typ
03:30:33 <DeadPanda> e, guards on input prevent repository->repository flows).  Can anyone offer any advice?
03:42:10 <MrAI> data Tree a = Leaf Int | Node (Tree a) a (Tree a)
03:42:19 <MrAI> What am I doing wrong in this definition?
03:42:54 <osaunders> MrAI: Why is Leaf have an Int?
03:42:58 <osaunders> s/is/does
03:43:08 <MrAI> Oops that should be an a type
03:43:22 <MrAI> I tried doing: Leaf :: (Leaf a) -> Int
03:43:26 <DeadPanda> data Tree a = Leaf a | Node (Tree a) a (Tree a)
03:43:32 <DeadPanda> type IntTree = Tree Int
03:43:41 <ivanm> MrAI: unless you're meant to be writing your own version, I'd say the other problem is that you're not using a pre-existing type...
03:43:46 <osaunders> And you probably don't want an «a» in the «Node» type constructor if you have a «Leaf» type constructor.
03:44:51 <osaunders> Alternatively you could make «Leaf a» something like «Empty» and keep the «a» in «Node».
03:45:29 <MrAI> data Tree a = Leaf a | Node (aTree a) a (aTree a). Error: Malformed head of type or class declaration
03:45:31 <dibblego> s/type constructor/data constructor
03:45:40 <ivanm> osaunders: *shrug* I've seen tree types where both the leaves and nodes had values
03:45:50 <quicksilver> MrAI: it's complaining about the 'aTree a' part
03:45:52 <ivanm> MrAI: you can't start a type name with a lowercase letter
03:45:56 <quicksilver> MrAI: should just be (Tree a) surely
03:46:02 <MrAI> Ah of course
03:46:37 <osaunders> dibblego: Really? Interesting.
03:46:46 <MrAI> showLeaf :: Leaf -> Int
03:46:46 <MrAI> showLeaf (Leaf a) = 0
03:46:55 <MrAI> Why is Leaf not in scope?
03:47:02 <ivanm> MrAI: different module?
03:47:03 <quicksilver> MrAI: Leaf is a constructor not a type
03:47:09 <osaunders> MrAI: The type isn't called Leaf.
03:47:12 <ivanm> oh, right, in the type sig
03:47:14 <quicksilver> MrAI: the type of your function there is Tree a -> Int
03:47:25 <dibblego> osaunders, Tree is a type constructor, Leaf and Node are data constructors
03:47:32 <MrAI> Ah I get it
03:47:59 <osaunders> dibblego: Wow, I'm glad I just found that out. Thanks.
03:47:59 <MrAI> I thought as as Leaf was a constructor you could use it directly when defining a function
03:48:08 <dibblego> osaunders, np
03:48:35 <quicksilver> MrAI: you can use it directly but it's not a type!
03:48:47 <quicksilver> MrAI: showLeaf (Leaf a) = 0 is fine (although strange)
03:48:47 <MrAI> I see
03:49:01 <quicksilver> but that expression gives showLeaf the type Tree a -> Int
03:49:09 <MrAI> I get it
03:49:13 <MrAI> Thanks all.
03:51:15 <MrAI> osaunders makes an interesting question: How would I change it so  that values are only contained at the leafs would that be: data ATree a = Leaf a | Node (ATree a) (ATree a) ?
03:51:33 <ivanm> yes
03:51:39 <MrAI> Thanks
03:53:17 <osaunders> MrAI: Yeah, I think so.
04:00:28 <MrAI> Where is the elementary wiki haskell page?
04:00:34 <MrAI> I cant seem to locate it at the moment
04:01:13 <merijn> Anyone here looked at the Omega language? Is it anything interesting?
04:02:38 <osaunders> merijn: It is interesting. I don't know much more.
04:02:54 <osaunders> MrAI: Elementary?
04:03:24 <MrAI> Found it: http://en.wikibooks.org/wiki/Haskell/Type_declarations
04:03:27 <lars9> i read the category theory & haskell article on wikibook, http://en.wikibooks.org/wiki/Haskell/Category_theory ,it does not mention what term in category thoery is monad coresponding to?
04:03:45 <dibblego> lars9, monad
04:04:06 <merijn> @quote wadler monoid
04:04:06 <lambdabot> wadler says: A monad is a monoid in the category of endofunctors, what's the problem?
04:04:10 <osaunders> I'm guessing if Omega is decent enough and the author can prove it, then Haskell will adopt the ideas.
04:04:38 <merijn> osaunders: From what I read so far I'm not sure its possible
04:05:09 <merijn> The same way haskell can't adopt the ideas from Epigram. I mean you could, but then it wouldn't be haskell anymore
04:05:21 <lars9> dibblego: i see..
04:05:24 <osaunders> :(
04:05:33 <osaunders> Damn
04:06:19 <merijn> osfameron: Instead of taking the new languages to haskell we can take haskell to the new languages :p
04:06:19 <lars9> merijn: hey i've got Tu-Dresden's L4 run in qemu, dunno if its possible to make haskell RTS compile on it
04:06:24 <quicksilver> merijn: haskell can certainly adopt many interesting ideas from epigram.
04:06:46 <lars9> osaunders: what is Omega?
04:06:47 <quicksilver> merijn: including some ways it handles the problems of dependent types and some of the intelligent editing stuff.
04:07:07 <merijn> quicksilver: Oh, sure it can adopt some ideas. But you can't adopt all of it without turning it into a new syntax for epigram :p
04:07:08 <osfameron> s/osfameron/osaunders above?
04:07:32 <merijn> osfameron: Ah, yeah. Tab complete fail >.>
04:07:38 <merijn> lars9: New language that was being discussed on LtU
04:07:44 <osaunders> lars9: Haskell inspired experimental language that allows you to program a type level, kind level, and everything else above. I don't really understand it.
04:08:02 <lars9> merijn: osaunders: thanks
04:08:18 <osaunders> s/a/at/
04:08:35 <merijn> quicksilver: From what I understand so far Epigram programs are structured quite differently from haskell programs
04:08:48 <osaunders> But I do know that there's lots of stuff I'd like Haskell types to be able to do that it can't.
04:08:49 <lars9> merijn: hey see my msg? is it possible to compile haskell rts on a almost-bare microkernel os? is posix libraries needed?
04:09:10 <merijn> lars9: I'm not sure, I'd check their mailing list/IRC channel if any exist
04:09:28 <merijn> osaunders: Like dependent typing and strong sum types? :p
04:09:39 <osaunders> merijn: Yes, exactly.
04:09:55 <osaunders> I'd like to be able make subsets of things too.
04:10:05 <merijn> Mind you, I'm not enlightened yet about exactly how Epigram works so I might be miss estimating the difficulty of adopting its paradigms in haskell
04:10:06 <osaunders> I guess that comes under dependent typing.
04:10:21 <lars9> osaunders: is your need come from practical programming, or PLan research?
04:10:39 <merijn> lars9: Strong sum types have very practical applications
04:10:41 <osaunders> There's also a language Bondi which claims to be doing very clever things with pattern matching.
04:11:05 <osaunders> lars9: Impractical practicality, I'd say. 
04:11:18 <osaunders> I'm a language nazi but I want to write web apps.
04:12:03 <merijn> lars9: They let you create tuples where the types of the entries can depend on the previous entries. Say you implement a messaging protocol and various messages require different contents. You could make the first type in tuple the message type ID and make the remaining entries depend on that.
04:13:33 <merijn> Instead of mucking around with Maybe's, or empty fields like you would in other type systems/languages
04:15:58 <lars9> merijn: seems like dynamic typing?
04:17:31 * dibblego curses at not being able to have category-extras and xmonad on the same account
04:17:33 <merijn> lars9: The idea of strong sum types and dependent typing is to be able to statically check this at compile time
04:18:28 <geheimdienst> dibblego: on the same account ...?
04:18:29 <merijn> lars9: Dependent typing for example lets you define a type for "lists which contain only the number 1", or "lists of length 5"
04:18:41 <dibblego> geheimdienst, in the same cabal --user space
04:18:59 <merijn> lars9: Its interesting stuff, but there's no real practical programming language that does this yet
04:19:43 <quicksilver> merijn: lists of length 5 works reasonably well in haskell's limited support for dependent types
04:19:47 <geheimdienst> i see
04:20:01 <lars9> merijn: sounds really interesting, especially if the range of a num or length of a list can be encoded in the type constructer, many errors can be eliminated
04:20:12 <merijn> lars9: That's the hope, yes
04:20:19 <osaunders> quicksilver: I dislike Data.Vec, if that's what you're suggesting.
04:20:32 <osaunders> It's a kludge and it shows.
04:20:34 <merijn> quicksilver: I'm not really up to speed on haskell's support for dependent typing, so I'll take your word for it
04:21:27 <osaunders> merijn: I doesn't have any, but you can sort of hack things together that approximate certain things.
04:21:33 <dibblego> geheimdienst, I know of know way to have them simultaneously installed, despite gymnastic efforts otherwise
04:26:33 <geheimdienst> dibblego, sounds like it sucks. what is the conflict?
04:27:14 <dibblego> geheimdienst, xmonad 0.9.1 doesn't compile unless I restrict the mtl version to <2 but that causes conflicts for Control.Monad.Either with transformers, which category-extras needs
04:29:40 <lars9> I already have a EitherT IO String, now I want to add a State into it, what should I do?
04:29:51 <dibblego> StateT
04:30:31 <lars9> StateT String (EitherT IO String) ?
04:30:53 <dibblego> @type StateT
04:30:54 <lambdabot> forall s (m :: * -> *) a. (s -> m (a, s)) -> StateT s m a
04:34:33 <lars9> dibblego: then to get the string, i need to runStateT . runEitherT to get the either, then case of Left & Right?
04:37:24 <lars9> is there a debugging interface, which implemented with non-haskell code, forexample dbg :: (Show a) => a -> a, does nothing but print (show a) to console?
04:38:02 <dibblego> lars9, Debug.Trace
04:38:32 <lars9> dibblego: thanks great
04:40:01 <lars9> @hackage trace
04:40:01 <lambdabot> http://hackage.haskell.org/package/trace
04:40:05 <lars9> @hackage debug
04:40:06 <lambdabot> http://hackage.haskell.org/package/debug
04:42:19 <yitz> @hackage write_anything_you_want_here
04:42:19 <lambdabot> http://hackage.haskell.org/package/write_anything_you_want_here
04:42:47 <yitz> ah, lars9 left.
04:57:49 <Jafet> @index trace
04:57:49 <lambdabot> Debug.Trace
04:58:28 <marinosi> Using ghci why am I not allowed to specify the type of a function before actually declare the function?e.g sumAll :: Num a => [a] -> a
04:58:53 <hpc> marinosi: ghci is basically a giant do block
04:59:03 <hpc> marinosi: lots of stuff doesn't work in it
04:59:22 <hpc> marinosi: as a nice workaround, you can edit a file in a separate terminal and use :r to reload the module
04:59:30 <Jafet> let sumAll :: Num a => [a] -> a; sumAll = sum
05:00:03 <marinosi> so what should I use? hugs or ghci?
05:00:14 <hpc> ghci
05:00:21 <Jafet> Whichever you like.
05:00:33 <hpc> hugs last updated in 2008, didn't it?
05:00:53 * hackagebot SoccerFun 0.5 - Football simulation framework for teaching functional programming  http://hackage.haskell.org/package/SoccerFun-0.5 (JanRochel)
05:01:00 <arcatan> you could use the new multiline feature in GHCi, like this: http://hpaste.org/41705/ghci_type_def
05:01:02 <Jafet> It's a usable implementation of Haskell, last time I heard
05:04:12 <freiksenet> what is the reason that Ocaml (and coq) uses separate definer operator for recoursive functions and why haskell does not do that? is that for (simplier?) optimization or there is some other reason?
05:04:55 * hackagebot EnumContainers 0.1 - Simple Enum-class-based int containers  http://hackage.haskell.org/package/EnumContainers-0.1 (EyalLotem)
05:05:00 <hpc> coq is a proof system, isn't it?
05:05:20 <freiksenet> well it can be seen as a programming language too.
05:05:31 <freiksenet> in this context at least.
05:05:47 <merijn> freiksenet: I think it's mostly to calm the mathematicians?
05:05:58 <freiksenet> merijn: what do you mean?
05:07:12 <merijn> freiksenet: There is no clear reason to treat functions and recursive functions differently. But you could argue that making recursive functions distinct from normal functions can make it easier to notice a function is recursive for very complicated functions.
05:07:41 <freiksenet> ok, thanks.
05:07:44 <merijn> freiksenet: Coq's syntax (seems to me) to be aimed very much at copying the way mathematicians would normally write their proofs in pseudocode
05:08:01 <jaredj> doesn't it have something to do with binding?
05:08:14 <freiksenet> it's quite ocaml-like tbh, probably recoursive functions are there because they are like that in Ocaml
05:08:28 <jaredj> like if nothing you're letting depends on anything else you're letting right now, it's semantically simpler?
05:08:28 <hpc> couldn't it also have something to do with the fact that general recursion lets you write fix?
05:08:31 <merijn> Having the compiler detect whether a function is recursive is pretty trivial, so you can just as easily have the compiler do it for you
05:08:38 <hpc> and the type signature of fix is a "proof of everything"
05:08:45 <quicksilver> freiksenet: in ocaml, at least, the top-level-module-language is sequential.
05:08:49 <merijn> hpc: It doesn't
05:08:54 <quicksilver> there is a real sense in which each declaration is 'executed'
05:08:57 <marinosi> where I could find a good tut or list of excercises/project to practice haskell?
05:09:12 <quicksilver> so recursion requires special treatment
05:09:15 <merijn> hpc: You can have general recursive functions in the simply typed lambda calculus and you can't write fix in that
05:09:24 <quicksilver> otherwise it will complain that it depends on an unknown function.
05:09:36 <merijn> marinosi: Have you looked at Learn You A Haskell?
05:09:38 <hpc> ah, nifty
05:09:49 <freiksenet> quicksilver: I see.
05:09:55 <freiksenet> quicksilver: now this makes more sense.
05:09:57 <marinosi> merijn: Just looking to Haskell for C programmers
05:10:07 <freiksenet> quicksilver: thanks :)
05:10:24 <merijn> marinosi: There is no Haskell for C programmers because everything you know about programming is wrong when you start Haskell
05:10:34 <quicksilver> freiksenet: if you get this wrong, in iterative development, then when you write  f & g intended to be mutually recursive, there is a real danger that f depends on 'the old g' not the new one.
05:10:44 <quicksilver> freiksenet: I made that mistake at least once. 
05:10:51 <quicksilver> very confusin.
05:11:23 <freiksenet> ok
05:11:53 <hpc> merijn: haha, so true
05:12:36 <merijn> hpc: For example recursive functions like "sum x:xs = x + sum xs; sum [] = 0" with type "[Int] -> Int" are valid in simply typed lambda calculus
05:13:03 <marinosi> merijn: yeap I understand what you are saying. Meant that tutorial makes some comparisons . I am referring to this: http://www.haskell.org/~pairwise/intro/section1.html
05:13:19 <merijn> marinosi: I can highly recommend (and most here will agree) "Learn You A Haskell" for starting out with Haskell, no matter if you have programmed before or not
05:14:06 <marinosi> merijn: fine! Thanks for the info!
05:14:07 <merijn> marinosi: IMO as someone who has done plenty of C/python making comparisons between C and Haskell will only confuse you more
05:14:29 <quicksilver> merijn: the meaning of 'simply typed lambda calculus' with which I am familiar does not admit recursion.
05:14:43 <quicksilver> merijn: it does no have named functions, so there is no way to write 'sum' above.
05:14:45 <hpc> the best background for haskell is abstract math, from what i can tell
05:14:54 <marinosi> merijn: I can guess why :) but it's always interesting how something you know how is implemented in C , is done in haskell 
05:15:03 <merijn> marinosi: The address is: http://learnyouahaskell.com/
05:15:24 <quicksilver> merijn: simply typed lambda calculus (the way I understand the term) is strongly normalizing and has no recursion.
05:15:56 <merijn> quicksilver: Actually, you may be right now that I think about it >.>
05:16:05 <hpc> yeah, looking through the wikipedia page, it looks like [] isn't a valid type
05:16:37 <quicksilver> you can sensibly talk about adding recursive types to STLC, but then it isn't just STLC any more
05:16:44 <quicksilver> it's STLC + recursive types
05:16:57 <quicksilver> (and you can encode function recursion through the type recursion)
05:18:12 <merijn> I'm not entirely convinced (yet) you couldn't write a recursive function, but that would involve me trying to work out for example something like factorial in STLC with Church numerals and that though makes me cry...
05:18:23 <merijn> s/though/thought
05:20:01 <merijn> On unrelated note, having to pay for papers should be a crime...
05:20:13 <quicksilver> merijn: well, the proof, assuming you believe all the steps, is simply: strongly normalizing => all functions total => no general recursion.
05:22:23 <merijn> Hmm, I think the confusion may be in the "general recursion"
05:23:10 <merijn> Wolfram tells me there's two different interpretations of the term in common use
05:24:52 <Nibble> The confusion is fusion
05:24:56 <merijn> One is to mean primitive recursive functions, the other total recursive functions. I know STLC can't do Y combinator because it's strongly terminating, but primitive recursion *IS* terminating so that should be possible in STLC, no?
05:26:28 <merijn> Or did I miss something else which means primitive recursion is also out in STLC?
05:31:34 <meditans> A little question. I have a huge number of nonordered lists, which I have to process in order to cancel duplicates.
05:32:08 <meditans> speed is a concern here. I thougth to use Data.Set module
05:32:30 <meditans> is there a faster method than converting in a set (n*log n) and converting back again to a list?
05:33:09 <merijn> meditans: I highly doubt a faster method exists for unsorted lists
05:33:45 <hpc> and sorting the list is n*log n anyway
05:34:10 <merijn> n log n for sorting + n to go over the list removing duplicates, so that's hardly going to be faster
05:34:26 <meditans> No, I know that, but how do you structure your code if you had to do this? Passing through the Data.Set module?
05:34:36 <meditans> or is there a clever way to do that?
05:34:37 <quicksilver> sorting the list is n log n, putting it into a set is n log k
05:34:47 <quicksilver> so it's asymptotically faster and has asymptotically better space
05:34:52 <quicksilver> (k = number distinct elements)
05:34:53 <merijn> quicksilver: What's k there?
05:34:55 <merijn> Ah
05:34:58 <hpc> oh, nifty
05:35:03 <meditans> quicksilver: what is k?
05:35:16 <quicksilver> but probaby k is almost equal to n so this isn't a real difference.
05:35:48 <meditans> yes, it's almost equal but i think i will use Data.Set anyway
05:35:51 <hpc> set is probably as good as you can get then
05:36:08 <meditans> thanks a lot
05:36:19 <merijn> quicksilver: Is primitive recursion impossible in STLC as well? I've quickly googled, but haven't found anything definitive
05:36:36 <meditans> i have another question but before asking i have to study some libraries. See later :D
05:40:04 <merijn> Hmm, my logical verification course notes seem to say primitive recursion *is* indeed possible
05:42:45 <ray> what's an STLC? presumably not southern template law center
05:43:17 <merijn> ray: Simply Typed Lambda Calculus
05:45:12 <ray> i see
05:46:37 <kosmikus> merijn: yes, primitive recursion is possible in simply typed LC
05:47:36 <merijn> kosmikus: Ok, then my understanding hasn't suddenly gone away and I just got confused by a sudden onset of ambiguous terminology :p
05:50:24 <lars9> makedepends=(ghc happy perl)
05:50:53 <lars9> i see this line in ghc's PKGBUILD, does it mean ghc can not be compiled without ghc?
05:51:17 <merijn> lars9: Yes
05:51:25 <ray> it's self-hosting yes
05:51:28 <Nibble> where is stewart
05:51:33 <Nibble> :/
05:51:43 <merijn> lars9: Its not like you can compile ghc using gcc :p
05:51:54 <lars9> merijn: hmm... is there a standalone haskell rts pkg?
05:52:16 <Nibble> hmm
05:52:30 <merijn> Don't really know, House and stuff was still somewhere down on my todo list
05:54:18 <Nibble> cabal global installs
05:54:39 <Nibble> how do I force cabal to install something globally
05:54:53 <hpc> run as root, iirc
05:55:00 <kosmikus> merijn: the whole "Church encoding" trick is to use an induction principle as the encoding for a datatype, so if you play the game for natural numbers you get structural recursion for free, which can relatively easily be extended to primitive recursion
05:55:29 <aristid> Nibble: --global, with root right
05:55:31 <ray> change the preference in the file or pass the commandline flag
05:55:42 <ray> i forget both
05:55:55 <Nibble> is it just me or is darcs really painfully slow?
05:56:04 <merijn> kosmikus: That's what I figured, the confusion came up due to the use of "general recursion" which apparently is in common use with two different meanings.
05:56:09 <Nibble> like this time when I tried to put my home under source control
05:57:20 <merijn> kosmikus: I always understood it as primitive recursion, but wolfram tells me general recursion is also commonly used for total recursive functions, which the STLC of course can't contain because it's strongly terminating.
05:57:23 <ray> it's not really terribly slow, but git is fast, consider that
05:57:31 <kosmikus> merijn: oh, I only know one (as the kind of recursion Y gives you)
05:58:18 <merijn> kosmikus: So that kinda derailed the conversation whether or not STLC can do general recursion
05:58:29 <Nibble> does cabal install it to /usr/bin if I use --global?
05:59:32 <lars9> Nibble: are you sure to do that? cabal can not uninstall
05:59:40 <Nibble> lars9: yes
05:59:48 <Nibble> lars9: if I want it removed
05:59:57 <Nibble> I just use pacman and install xmonad from there, and remove again
06:00:00 <kosmikus> merijn: total recursive usually implies that it's total, as in "defined everywhere", right?
06:00:06 <Nibble> but it didn't install there
06:01:02 <merijn> kosmikus: As in, it also includes Y combinator like recursion, yes.
06:01:32 <kosmikus> merijn: well "Y" is certainly not total in my understanding of the word
06:02:24 <kosmikus> merijn: "general recursion" more or less corresponds to partial (mu-)recursion
06:02:37 <lars9> anyone interested in a easier tool to do find ... -exec ...`sed` ...? personally i use it everyday https://code.google.com/p/fordo/
06:02:59 <lars9> Nibble: you can test it with chroot first
06:03:18 <Nibble> I got it to work, just added it to path
06:03:36 <merijn> kosmikus: I need to read more for this discussion :p
06:05:00 <quicksilver> merijn: 'primitive recursion' gives you programming languages with bounded loops (like FOR i IN 1 TO 100), 'general recursion' gives you loops on arbitrary predicates like WHILE
06:05:16 <yitz> lars9: very nice! on hackage?
06:05:16 <quicksilver> merijn: .... that is a very practical programmer's intuition for it, at least.
06:05:48 <merijn> quicksilver: Yeah, I realize. As I said the confusion comes from the fact that general recursion is also in use as a term for primitive recursion :p
06:05:54 <lars9> yitz: you mean fordo? not on hackage yet. but it's a cabal project, easy to compile :)
06:06:14 <yitz> lars9: why not? takes a few seconds.
06:07:06 <merijn> On completely unrelated note, is my intuitive understanding that cut rule is basically the transitivity of proofs correct?
06:08:27 <lars9> yitz: hah, this proj is too small and i doubt it fits hackage
06:08:37 <lars9> yitz: only one file.
06:10:59 <aristid_> lars9: that's no problem for hackage.
06:11:03 <yitz> lars9: it doesn't matter
06:11:34 <merijn> @quote dons hackage
06:11:34 <lambdabot> dons says: it scares me that if I wrote a review of one hackage package per day, it would take me 6 years to complete.
06:11:42 <yitz> lars9: when it's on hackage, you don't have to go looking for the project, download, etc. you just type cabal install fordo and it
06:11:43 <merijn> Dammit, of course now it turns up the wrong one
06:11:46 <yitz> sit's done
06:12:00 <merijn> I meant: "dons says: [on whether a library is wanted] *yes* put it on Hackage!"
06:12:09 <aristid_> lars9: if you have no hackage account, i can upload it for you, or you can get a hackage account by sending an email
06:12:30 <lars9> aristid_: thanks, i'm applying account
06:12:56 <aristid_> great
06:18:08 <lars9> yitz: aristid_: have applied but it should take some time. next weekend i'll improve the file counter a little bit, so that {001} will be replaced to 001,002,003.. etc
06:18:39 <aristid_> lars9: i got my account in 30 minutes, but that was luck
06:20:06 <micahjohnston> what is the difference between product and sum types?
06:21:06 <yitz> lars9: great!
06:21:13 <merijn> micahjohnston: Good, time to see if I understood this well enough to explain. Lemme see if I can conjure up an example
06:24:18 <merijn> micahjohnston: AFAIK the main difference is that product types can also exist for calculi that are not dependently typed, where they essentially just allow quantification over types. Strong sum types are dependently typed by definition I think
06:24:57 <micahjohnston> well, haskell's not dependently typed, but I thought [] was a sum type
06:25:53 <merijn> micahjohnston: [] is a pretty straight forward product type
06:26:08 <micahjohnston> merijn: oh :/
06:26:43 <ray> sum types are unions
06:27:08 <Maddas> Hi. I'm trying to compile some Haskell code with ghc, and I'm getting the error "Could not find module `Network.Socket'". Isn't that a built-in/standard module?
06:27:10 <micahjohnston> is Either a sum type because it has Left and Right?
06:27:19 <Botje> merijn: uh, data [a] = [] | a : [a]
06:27:22 <merijn> micahjohnston: "Πx:* . [x]" that is, [] takes any x which is a type and returns the type of the list containing only elements of type x
06:27:24 <Botje> that's a sum type, surely :P
06:27:40 <[swift]> yeah, was about to say: [] is a sum type as far as i know
06:27:57 <Maddas> Actually, let me check whether it's just my ~/.cabal being hosed...
06:27:59 <ray> it only takes 1 argument
06:28:02 <merijn> Botje, [swift]: My understanding is far from complete, feel free to correct me :p
06:29:02 <merijn> My course notes illustrate lists [] as a product type...
06:29:31 <quicksilver> [] has sum, product, and recursive nature.
06:29:38 <lars9> yitz: thanks, if you have any suggestion please let me know:)
06:29:45 <quicksilver> Either is a simple sum
06:29:50 <quicksilver> (,) is a simple product
06:30:06 <ray> i was about to tongue-in-cheek suggest that [] was an exponential type
06:30:18 <micahjohnston> heh
06:30:18 <ray> but then people started getting confused
06:30:42 <Maddas> Aah, it was me using sudo for cabal that broke things, apparently. Thanks for listening :-)
06:30:47 <quicksilver> in haskell terms, product == constructor with several parameters (fields); sum = data type with multiple constructors.
06:31:11 <micahjohnston> Maddas: yeah, be careful to either always use sudo or never use sudo; that's gotten me in the past
06:31:13 <quicksilver> [] has both mulitple constructors, and a constructor with several (well, two) fields
06:31:15 <[swift]> yeah, now that i think about it, i guess a : [a] does constitute a product
06:31:23 <[swift]> my bad; it's early in the morning =)
06:31:29 <micahjohnston> ok, I get it :) thanks
06:32:09 <engla> quicksilver, what are the multiple constructors?  [] and x:[] ?
06:32:54 <quicksilver> engla: [] and (:), yes
06:33:31 <Maddas> micahjohnston: Yeah, I always used sudo for cabal, but I didn't use sudo for ghc.
06:33:59 <applicative> Maddas, I only keep the Haskell platform libs is /usr/... ; everything else is in my ~/.cabal otherwise I get totally confused
06:34:22 <ray> same
06:34:49 <ray> i wouldn't get confused :) but it's nicer like that
06:35:10 <applicative> it's a simple solution; it wouldnt work for everyone of course
06:35:34 <merijn> quicksilver: Then "Foo a = Foo a | Bar a" is a sum type, "Foo a b = Foo a " is a product type and "Tree a b = Left a | Right b | Branch (Tree a b) (Tree a b)" is both?
06:36:00 <applicative> it makes it easy to chuck everything you've installed yourself, for example, when there's some impenetrable cabal nightmare
06:36:40 <merijn> Oh wait, no product type would be "Foo a = Foo a a"?
06:36:55 <quicksilver> product type would be data Foo a b = Foo a b
06:37:04 <quicksilver> it's a product because it's isomorphich to a x b
06:37:24 <ray> think of cartesian products
06:38:06 <applicative> Tree a b is the solution of x = a + b + x^2   
06:38:45 <merijn> quicksilver: Something being a product type is visible in the type system, while that's not the case for sum types?
06:39:22 <quicksilver> don't really understand that question.
06:39:31 <ray> a simple product and simple sum both look like T a b
06:39:38 <quicksilver> data IntChar = MkIntChar Int Char is a product too
06:39:46 <quicksilver> the type parameters are neither here not there
06:40:12 <ray> but one's data T a b = A a ^ B b
06:40:21 <merijn> Freaking type theorists should stop giving everything the same freaking names to confuse me :<
06:40:22 <ray> ^ used instead of vertical bar
06:40:23 <applicative> data IntError = Bad String | Good Int is a sum type
06:40:26 <quicksilver> type parameters are a way of making types parametric but they're not directly relevant to the question of whetehr a type is a some or a product.
06:40:28 <ray> because of my phone
06:40:41 <ray> and one's data T a b = C a b
06:41:22 <zygoloid> quicksilver: is sum vs product meaningful without type parameters? is 4 a product (Bool,Bool) or a sum (Either Bool Bool)?
06:41:42 <merijn> I'm thinking I'm getting tripped up by being confused with types of the form "Πx:X . foo x".
06:41:50 <engla> a harder question is how you interpret the product stuff in "the zipper type is the derivative of the container type"
06:41:52 <lars9> how to allow {, }, \ etc chars in .cabal file?
06:41:57 <lars9> in the description part
06:41:58 <quicksilver> zygoloid: technically, neither.
06:41:59 <ray> 4 is an integer
06:42:03 <applicative> zygloid,  ?
06:42:08 <applicative> 4 ?
06:42:12 <quicksilver> zygoloid: Bool x Bool is a product, Bool + Bool is a sum.
06:42:22 <quicksilver> zygoloid: other types are merely isomorphic to these.
06:42:40 <quicksilver> zygoloid: (and these two happen to both be isomorphic to 4 and indeed each other)
06:42:53 <quicksilver> zygoloid: but of course, we often use 'sum type' to mean 'isomorphic to a sum' etc.
06:43:13 <quicksilver> being a sum or product is then, technically, a syntactic property not a semantic one.
06:43:27 <micahjohnston> Integer is a simple sum type, right?
06:43:32 <quicksilver> and in haskell sum types are | and product types are constructors with > 1 parameter.
06:43:42 <zygoloid> quicksilver: right. it's the implicit isomorphism which i think i'm objecting to, since (imo) sum versus product is a syntactic property
06:43:46 <merijn> Every paper keeps using the terms product and sum types and every single time I think I understand them it turns out my understanding is even more wrong then it used to be...
06:43:50 <quicksilver> micahjohnston: an infinite one yes.
06:44:05 <quicksilver> zygoloid: agreed. As I just said while you were typing that :)
06:44:07 <zygoloid> applicative: 4 is the type with 4 values
06:44:10 <ray> just think of set sum and set cartesian product
06:44:10 <applicative> quicksilver, but if they're polymorphic, can't there be some generalization made.  Maybe not, there can be a general isomorpism
06:44:13 <zygoloid> quicksilver: :)
06:44:43 <[swift]> i prefer to say union and cartesian product, but yeah
06:44:59 <[swift]> that's really all that's going on. confused me when i first learned about them too, tho
06:45:04 <ray> usually people say union for sets i guess
06:45:12 <zygoloid> applicative: where "the" is up-to-isomorphism in this context
06:45:36 <applicative> zygoloid, right, I wasn't getting your use of 4, I was distracted by the  Haskell (Bool, Bool)  i.e. 2 * 2
06:45:50 <merijn> So, assuming no knowledge beyond STLC can someone once and for all explain to me the meaning of sum and product type?
06:46:05 <applicative> disjoint union, of course
06:46:07 <quicksilver> merijn: they are operations for an inductive construction of types.
06:46:13 <quicksilver> merijn: sum = (,), product = Either.
06:46:15 <micahjohnston> a sum type is one that has multiple constructors, i.e. data Foo a b = A a | B b
06:46:17 <quicksilver> story ends there.
06:46:46 <applicative> if you use | its a sum 
06:46:59 <zygoloid> applicative: well, ghc permits 1 as a type at least ;)
06:47:03 <micahjohnston> if you have a constructor with multiple arguments it's a product
06:47:09 <zygoloid> > (undefined :: 1) `seq` ()
06:47:10 <lambdabot>   *Exception: Prelude.undefined
06:47:23 <applicative> really?  
06:47:34 <zygoloid> really
06:47:39 <zygoloid> it's for the generics stuff iirc
06:47:47 <applicative> > const 3 (undefined :: 1)
06:47:47 <lambdabot>   3
06:47:50 <applicative> ha
06:48:04 <applicative> > const 3 (undefined :: 2)
06:48:05 <lambdabot>   Only unit numeric type pattern is valid
06:48:19 <merijn> quicksilver: That's not really any different then saying "sum types are frobble, whereas product types are burble"
06:48:26 <applicative> mysterious, why bother with 1, if you're not going to have 2, 3 etc
06:48:35 <quicksilver> merijn: yes, it's very different from that.
06:48:48 <quicksilver> merijn: it's assuming that, since we are in #haskell, you understand (,) and Either and you can apply that to STLC.
06:49:26 <lars9> i found the problem is that {} will be seen as layout symbols in cabal file. how to use literal {} in cabal file? \{\} does not work
06:49:28 <applicative> merijn, can you restate the difficulty?  this jargon is beautiful and worth understanding. 
06:50:01 <merijn> quicksilver: I figured I understood that distinction when I first encountered a few weeks back. But since I was wrong a bit back apparently I did not actually get it before...
06:50:12 <zygoloid> applicative: you'd need to give names to the distinct values of 2 for it to be useful
06:50:18 <quicksilver> merijn: otherwise, try : "Sum types: for all types A, B, we define a type A + B. For every value a \in A, there is a value (INL a) in A + B. For every value b \in B, there is a value (INR b) in A + B. Furthermore these are the *only* values in A+B.
06:50:36 <applicative> zygoloid, i see. 
06:51:16 <quicksilver> merijn: "Product types: for all types A,B we define a type A x B. For every value a \in A and b \in B, there is a (distinct by construction) value (a,b) \in A x B. Furthermore these are the only values in A x B.
06:51:29 <quicksilver> merijn: clear?
06:51:51 <applicative> quicksilver, I think it isn't clear.  
06:51:59 <merijn> quicksilver: Well, more helpful at any rate. Let me meditate on this for a bit
06:53:21 <quicksilver> applicative: not clear how?
06:55:51 <applicative> well, I'm thinking that in application to haskell saying something like Int + String or a + b should mean an isomorphism class of types
06:56:06 <applicative> i mean, an isomorphism class of Haskell types
06:56:11 <quicksilver> ok, but it doesn't.
06:56:18 <quicksilver> sum types are not an isomorphism class
06:56:27 <merijn> Am I right then that this also follows: "It is possible that there is no value in A+B where (INL a) *and* (INR b)"?
06:56:29 <quicksilver> they are, by definition, a unique and definitional construction.
06:56:31 <applicative> String + String is 
06:56:50 <quicksilver> and I was deliberately not using haskell since that apparently wasn't what merijn wanted.
06:56:54 <applicative> There are indefinitely many String Int sum types in Haskell
06:57:11 <quicksilver> merijn: yeah, (INL a) and (INR b) are indeed guaranteed to be distinct.
06:57:34 <applicative> e.g. Either String Int  and ErrInt = Bad String | Good Int etc. etc. 
06:57:54 <applicative> why not say, these are all so many sums of String and Int
06:58:15 <applicative> It's not an objection, I just think the jargon is clearer that way
06:58:33 <quicksilver> I do indeed speak that way sometimes, applicative 
06:58:40 <quicksilver> but as zygoloid pointed out, to do so is wrong
06:58:44 <quicksilver> although the meaning is clear
06:58:45 <marens> which book would you recommend for a beginner: learn you a haskell or real world haskell? i know both are available online which is really nice but i'm still thinking about buying a book. i took a look at the first chapters of both and liked both of them.
06:58:54 <quicksilver> and merijn apparently wanted a definition which didn't abuse notation.
06:59:00 <applicative> I'm not following, how is it wrong?
06:59:12 <merijn> marens: I'd start with learn you a haskell, then continue from there to RWH
06:59:16 <quicksilver> it's wrong, because it is not what the terms mean.
06:59:20 <applicative> there are indefinitely many 4's in haskell too
06:59:23 <quicksilver> sum types are a clear and precise technical notion.
06:59:44 <quicksilver> they are a syntactic construction of types
06:59:53 <quicksilver> enabling you to built up inductive collections of types
06:59:54 <merijn> I'd have to say that 90% of my type theory problems boils down to jargon mismatch between papers and languages >.>
07:00:11 <merijn> (also between papers and papers, of course)
07:00:17 <quicksilver> (() x ()) x () and () x (() x ()) are distinct types
07:00:32 <quicksilver> although equally useless and indeed isomorphic to each other.
07:00:51 <applicative> yes, but Either String Int and ErrInt = Bad String | Good Int build up inductive collections in the same way
07:01:34 <adu> Either is more standard
07:01:35 <lambdabot> adu: You have 2 new messages. '/msg lambdabot @messages' to read them.
07:01:41 <quicksilver> yes, they are both isomorphic to String + Int
07:01:54 <quicksilver> however neither of them *is* String + Int. Or at most one of them is.
07:01:57 <applicative> but in Haskell String + Int doesn't exist
07:02:04 <quicksilver> the last is a question of how you interpret type theory in haskell.
07:02:13 <quicksilver> the natural canonical thing is to interpret + as Either.
07:02:14 <adu> wow
07:02:22 <quicksilver> and, most importantly, merijn isn't talking about haskell
07:02:29 <applicative> they are isomorphic to each other; the name of the equivalence class is "String + Int" -- I'm just trying this
07:02:30 <quicksilver> which is why I'm trying not to talk about haskell.
07:02:31 <merijn> applicative: That'd be relevant if the question was about haskell, but the orignal conversation was not about haskell, but type theory
07:02:55 <applicative> this is about type theory
07:03:18 <quicksilver> applicative: this is a stupid conversation in which we have no substantial dispute. I do not wish to continue it!
07:03:36 <quicksilver> It is sometimes convenient to confuse isomorphism classes and/or pick distinguished representatives.
07:03:47 <quicksilver> but this is not what merijn was asking and does not represent the answer to his question.
07:04:14 <merijn> I think the product and sum type distinction has finally resurfaced in my brain. Which now makes me wonder why I ever forgot it in the first place
07:05:29 <applicative> quicksilver, fine; I don't think this fits with the whole of the foregoing history though.
07:05:49 <applicative> many questions arose in consequence of the original one
07:05:56 <marens> merijn: think i'll buy rwh (~700 pages) and continue reading lyah(~400 pages) online then
07:06:59 <merijn> marens: I think LYAH is easier to understand, whereas RWH is a better bridge between understanding and actually coding something useful
07:08:32 <nostard_> i think RWH and LYAH are great togheter =)
07:08:45 <[swift]> yeah i got value from each
07:08:46 * hackagebot fordo 0.1 - Run a command on files with magic substituion support (sequencing and regexp)  http://hackage.haskell.org/package/fordo-0.1 (ChengqiSong)
07:10:16 <co_dh> @where lyah
07:10:16 <lambdabot> http://www.learnyouahaskell.com/
07:12:09 <lars9> @where coq
07:12:10 <lambdabot> http://coq.inria.fr/
07:12:29 <applicative> quicksilver, for example, this intervention: MICAHJOHNSTON  what is the difference between product and sum types?
07:12:42 <micahjohnston> o_o
07:13:15 <micahjohnston> product types are when a type has multiple arguments to one constructor, and sum types are when a type has multiple constructors
07:13:18 <co_dh> @where agat
07:13:18 <lambdabot> I know nothing about agat.
07:13:25 <co_dh> @where list
07:13:25 <lambdabot> I know nothing about list.
07:13:34 <co_dh> how many where lambdabot knows?
07:13:44 <aristid> @where list-of-wheres
07:13:45 <lambdabot> I know nothing about list-of-wheres.
07:13:54 <applicative> and then "well, haskell's not dependently typed,.." and then, "is Either a sum type because it has Left and Right?"
07:13:58 <aristid> lars9: become self-aware!
07:14:01 <aristid> argh
07:14:04 <aristid> i meant lambdabot
07:14:33 <aristid> applicative: Either a has kind * -> *, so i don't think that statement makes a lot of sense :)
07:14:34 <applicative> quicksilver, all of these amply justified my questions, I'd have thought, and not made vicious attacks sensible
07:14:59 <quicksilver> applicative: wow. If my comment appeared as a vicious attack then it came across badly.
07:15:17 <lars9> aristid: i can not figure it out in 5sec, what do you mean?
07:15:24 <applicative> aristid, I am quoting fragments from earlier, they were mostly embedded in questions
07:15:28 <quicksilver> applicative: all I was trying to say is "it is clear to me that we both understand this issue and I don't see the value in continuing this frustrating line of argument"
07:15:36 <applicative> quicksilver, of course it was vicious. 
07:15:46 <quicksilver> then I apologise unreservedly.
07:16:11 <applicative> quicksilver, no, I don't totally understand it; but others were hoping for lucidity
07:16:18 <applicative> others too, I mean
07:16:55 <applicative> "applicative: this is a stupid conversation in which we have no substantial dispute. I do not wish to continue it!" is a vicious statement
07:17:26 <quicksilver> I was calling the conversation stupid, not you.
07:17:33 <quicksilver> I have already apologised!
07:18:43 <applicative> Yes, I'm sorry for continuing, I give up
07:19:17 <merijn> I recommend he doesn't hang out in #python and ##c if that was vicious :>
07:19:34 <aristid> lars9: i was trying to say something to lambdabot, but accidentally typed your name (tab completion...)
07:21:50 <lars9> err, if xlib is like nightmare, then xcb is like hell. haskell's bind does not make them easier at all.
07:22:20 <co_dh> what generic tools do you guys use ? 
07:22:42 <mornfall> Someone's been playing too much Diablo.
07:22:55 <co_dh> I've tried polyp a little bit . 
07:28:42 <applicative> quicksilver, merijn, sorry, back briefly to link the familiar sacred text http://www.haskell.org/haskellwiki/IRC_channel#Principles
07:29:31 <quicksilver> On the off-chance that you read the logs, applicative, I repeat my unreserved apology for any offense my comment caused.
07:32:35 <lars9> anyone read about that L4-verified work?
07:34:26 <micahjohnston> I think I've heard a little about that
07:34:38 <micahjohnston> although I might be thinking of completely the wrong thing
07:35:40 <lars9> briefly, some NICTA & UNSW guys implemented L4 spec with haskell, verified it, then convert to C.
07:37:15 <lars9> the formal verification part looks amazing to me
07:37:39 <[swift]> l4 as in the microkernel?
07:37:51 <[swift]> that sounds impressive indeed
07:37:51 <lars9> [swift]: yep.
07:38:23 <merijn> lars9: Did they do multiple verifications using different theorem provers? If not, how are they proving their theorem prover?
07:39:53 <lars9> merijn: can you access their website? i didn't read their paper carefully because i'm not trained in plan and dont understand formal verification.
07:40:20 <lars9> *PLan
07:43:42 <lars9> yitz: hi, fordo hackage uploaded, hope i'm not the only one needs it
07:45:09 <yitz> lars9: it's one of those things you use - you only need it after you are used to it and don't want to live without it anymore.
07:51:15 <yitz> lars9: here is an idea - if -flag, where flag /= c, appears after the first path and before -c, then run the find command and take its output as the list of files
07:51:48 <yitz> lars9: do it lazily so that it will work when a lot of files match
07:52:10 <yitz> lars9: this is still easier than -exec in the simple cases
07:54:08 <lars9> yitz: could you please make an example? what will the command look like?
07:58:00 <yitz> fordo ~/my-dir -type f -name '*.bmp' -maxdepth 3 -c convert {} {s/bmp$/jpg/}
07:58:50 <lars9> yitz: oh i see what you mean, that will be like an enhanced find?
08:00:05 <yitz> lars9: right. if there are flags, then the file search is like find - complicated but more powerful - but the command is still fordo-style
08:01:19 <reinout_> hi, i'm new here i just have a question 
08:02:18 <yitz> lars9: another idea - a -q option to just do it without printing each command
08:02:32 <quicksilver> reinout_: go ahead and ask it :)
08:02:36 <quicksilver> reinout_: we can't answer until you do.
08:02:46 <yitz> lars9: and a --dry-run option to do the oposite - just print it without doing it
08:03:10 <reinout_> well i wrote this
08:03:24 <yitz> reinout_: wait don't paste it here
08:03:25 <reinout_> test :: [a] ->  Maybe a
08:03:26 <reinout_> test [] = Nothing
08:03:26 <reinout_> test a = foldl Just(last (x:xs))
08:03:29 <lars9> yitz: i will consider the find idea next weekend. i thought about the print-only problem, it's easy to add an echo right after -c :)
08:03:33 <reinout_> ok sorry
08:03:38 <yitz> that
08:03:44 <yitz> that's short it's ok :)
08:03:52 <yitz> we have a paste bin for longer things
08:03:57 <yitz> @hpaste
08:03:57 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
08:04:06 <reinout_> well want to have a list to input
08:04:13 <yitz> oh, still moonpatio ?
08:04:13 <reinout_> an the output has to be 
08:04:32 <reinout_> like Just 3 for example
08:04:38 <yitz> @where hpaste
08:04:39 <lambdabot> http://hpaste.org/
08:04:43 <yitz> that's better
08:04:49 <reinout_> where Just 3 is the last element of the list
08:04:55 <reinout_> with 3 as input
08:05:06 <reinout_> using foldl
08:06:07 <reinout_> dunno if that was clear
08:06:41 <quicksilver> I guessed as much, but I think you are violating the spirit of that exercise by using 'last'
08:07:06 <quicksilver> I think the intention of the "write last as a fold" exercise is not to use the Prelude 'last' funciton at all.
08:07:08 <yitz> reinout_: the variable "a" is a type variable, it is only used in the type signature, it cannot be used as a variable in the equation
08:08:41 <yitz> > let squared x = x * x in squared 7
08:08:42 <lambdabot>   49
08:09:06 <reinout_> yitz: is Maybe Int correct way to indicate a type
08:09:09 <reinout_> yitz: ?
08:09:19 <yitz> yes that's fine
08:09:28 <reinout_> yitz: ok 
08:09:32 <reinout_> yitz: thx
08:10:03 <aristid> yitz: use @where hpaste
08:10:17 <yitz> aristid: yeah I did that afterwards
08:10:35 <yitz> aristid: who is in charge of fixing \bot? that has got to go
08:11:08 <aristid> yitz: not sure
08:11:22 <quicksilver> yitz: Cale, mostly
08:11:37 <Cale> I don't maintain the code of lambdabot
08:11:42 <yitz> quicksilver: I thought Cale only starts and stops it, and joins it to channels
08:11:45 <Cale> I just make sure it stays running.
08:11:58 <Cale> (and yeah, join it to channels)
08:12:03 <yitz> Cale: who does maintain it?
08:12:04 <quicksilver> Cale: @hpaste is compiled-in then?
08:12:24 <Cale> gwern, mostly, though I'm not sure he considers himself the maintainer or not
08:12:37 <yitz> preflex: seen gwern
08:12:38 <preflex>  gwern was last seen on #xmonad 1 day, 22 hours, 22 minutes and 55 seconds ago, saying: this is an FAQ
08:12:46 <Cale> quicksilver: Well, I'd need to be able to recompile lambdabot to fix it.
08:13:05 <Cale> quicksilver: At some point I'll have to look into why that was a problem last time I tried it.
08:13:19 <Cale> Might be okay now. I think it was an available-GHC-version thing.
08:13:27 <quicksilver> Cale: who compiles the copy which lives on the machine that runs it?
08:13:33 <yitz> Cale: maybe because you don't have GHC 6.6? :)
08:14:25 <romildo> I want some examples of code using Text.HTML.TagSoup.Parsec, from the tagsoup-parsec package.
08:33:01 <Veinor> installing ghc 7.0.1, whoo
08:34:37 <HaskellNoob> hi, i have a question. I need to write a Haskell code that returns the last element of a list. And i have to use foldl. The beginning has to be maybeLast :: [x] -> Maybe x. Can anyone help me? Thanks in advance
08:34:43 * hackagebot SoccerFunGL 0.5 - OpenGL UI for the SoccerFun framework  http://hackage.haskell.org/package/SoccerFunGL-0.5 (JanRochel)
08:35:13 <Rembane> HaskellNoob: Have you got any code?
08:35:59 <HaskellNoob> Rembane: the second line is maybeLast [] = Nothing, but that's all i have :(
08:36:17 <HaskellNoob> it's the third (and probably last) line i'm looking for
08:36:47 <Rembane> HaskellNoob: Okay. Do you have an idea of how to go forward?
08:37:14 <HaskellNoob> no, i'm pretty new to Haskell, hence my name
08:37:29 <Rembane> HaskellNoob: Okay. Lets seee.
08:37:35 <HaskellNoob> i know what the foldl command does
08:38:54 <Cale> HaskellNoob: You know that  foldl f z [] = z  and that you want  maybeLast [] = Nothing
08:39:01 <Cale> HaskellNoob: You can solve for z like that.
08:39:16 <Veinor> oh dear
08:39:30 <Veinor> cabal requires filepath <1.2, but I have filepath 1.2 installed
08:39:44 <Cale> (supposing that you want maybeLast = foldl f z)
08:40:07 <lars9> @pl \x, y -> Just y
08:40:07 <lambdabot> Just . snd
08:40:33 <dcoutts> Veinor: you can continue using your current cabal binary until there's a new release that builds using ghc 7
08:40:33 <opqdonut> @pl \x y -> Just y
08:40:34 <lambdabot> const Just
08:40:43 <lars9> @pl \x y -> Just y
08:40:43 <lambdabot> const Just
08:40:45 <Cale> HaskellNoob: Does that much make sense?
08:41:09 <Veinor> base >=4 && <3 && >=1 && <5
08:41:11 <Veinor> um
08:41:18 <Cale> HaskellNoob: The trickier part will be solving for f. You should also know that foldl f z (x:xs) = foldl f (f z x) xs
08:41:22 <HaskellNoob> not really... i want this output when i type the command: maybeLast "thelastletterisx" = x
08:41:22 <opqdonut> Veinor: nice
08:41:35 <Cale> HaskellNoob: Actually you want Just 'x'
08:41:44 <Veinor> i guess cabal loves me
08:41:47 <HaskellNoob> Cale: indeed
08:42:13 <Cale> HaskellNoob: So the stuff I said about solving for z didn't make sense?
08:42:56 <HaskellNoob> i'm sorry, no...
08:43:09 <Cale> If  maybeLast [] = Nothing, and  maybeLast = foldl f z  for some f and z, then we can plug that equation into the first one to get that  (foldl f z) [] = Nothing
08:43:18 <Cale> and we know that (foldl f z) [] = z
08:43:24 <Cale> So z = Nothing
08:43:38 <HaskellNoob> ok
08:43:39 <lars9> the @pl is awesome, does it have a local version?
08:43:55 <mm_freak> better not
08:44:05 <mm_freak> @pl helps people write weird, unreadable code
08:44:05 <lambdabot> (line 1, column 25):
08:44:05 <lambdabot> unexpected ","
08:44:05 <lambdabot> expecting variable, "(", operator or end of input
08:44:06 <lispy> lars9: you can install lambdabot locally
08:44:16 <Cale> So, all we need to do is determine what f should be. It'll be a little more subtle, but let's look at what we know.
08:44:24 <lispy> lars9: or you can message lambdabot directly in a private chat
08:44:35 <lars9> lispy: i see thanks
08:44:52 <Cale> We know that foldl f z (x:xs) = foldl f (f z x) xs
08:45:06 <Cale> Suppose for the moment that xs = []
08:45:07 <lispy> lars9: there was (briefly) a web version, but then the lambdabot api changed and I was too lazy to rewrite the CGI bits
08:45:26 <HaskellNoob> then the function has to return x
08:45:34 <Cale> Not x
08:45:39 <Cale> The value (Just x)
08:45:46 <c_wraith> I'm pretty sure lambdabot's @pl plugin calls a standalone binary that you can install
08:45:46 <HaskellNoob> indeed
08:46:15 <fryguybob> lars9: http://hackage.haskell.org/package/pointfree
08:46:33 <lars9> lispy: i see, i'll worry about it when i was going to lose access to internet then
08:46:33 <quicksilver> I don't think LB calls pointfree; it has "Plugin.Pl"
08:46:33 <c_wraith> yeah, that's what I was looking for :)
08:46:39 <quicksilver> but I think pointfree was extracted from it
08:46:55 <roconnor> mm_freak:  what part of "flip flip const . (ap .) . flip flip id . (ap .) . liftM2 (.) (.) (. const)" don't you understand?
08:46:57 <Cale> So, maybeLast (x:[]) = foldl f Nothing (x:[]) = foldl f (f Nothing x) [] = f Nothing x
08:47:18 <Cale> HaskellNoob: and we know that we want f Nothing x to be Just x
08:47:30 <HaskellNoob> Cale: indeed
08:47:43 <Cale> HaskellNoob: So that tells us at least part of how we want to define f :)
08:47:59 <jmcarthur> Cale: would you say that using yampa is nicer than not using any frp library?
08:48:19 <Cale> jmcarthur: Sometimes, I suppose it is.
08:49:13 <Cale> jmcarthur: But it seems to easily result in oversized definitions, since there's no way to give names to individual signals except inside the proc notation.
08:49:13 <jmcarthur> cool. was just wondering. i've not really used it
08:49:20 <jmcarthur> yeah...
08:50:27 <roconnor> @djinn (((a -> b) -> a) -> b -> ((a -> b) -> a)) -> (a -> b) -> a
08:50:27 <lambdabot> -- f cannot be realized.
08:50:48 <roconnor> @djinn ((((a -> b) -> a) -> b) -> ((a -> b) -> a)) -> (a -> b) -> a
08:50:49 <lambdabot> f a b = a (\ c -> b (c b)) b
08:51:33 <roconnor> @. pl djinn (((a -> b) -> a) -> b -> ((a -> b) -> a)) -> (a -> b) -> a
08:51:34 <lambdabot> (line 1, column 1):
08:51:34 <lambdabot> unexpected "-"
08:51:34 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:52:18 <Snis> I am trying to load a .lhs file in GHCi and it keeps giving me the following error: Main.lhs line 78: unlit: Program line next to comment phase `Literate pre-processor' failed (exitcode = 1), now looking at line 78 I see absolutely nothing wrong :s what should I look out for?
08:52:36 <roconnor> @. pl djinn ((((a -> b) -> a) -> b) -> ((a -> b) -> a)) -> (a -> b) -> a
08:52:37 <lambdabot> f = join . (. ap (.) (flip id))
08:53:28 <Cale> HaskellNoob: By thinking about what should happen with a 2-element list, you should get it. I'm not sure this is really the simplest way to look at writing the function like this, but when you haven't built up a decent intuition for things, sometimes it's nice to be mechanical or algebraic about it.
08:55:26 <Cale> http://upload.wikimedia.org/wikipedia/commons/5/5a/Left-fold-transformation.png -- this is a diagram which shows what foldl does to a 5-element list.
08:55:44 <Cale> oh, pinged out
08:56:44 <Cale> HaskellNoob: You might find this diagram helpful: http://upload.wikimedia.org/wikipedia/commons/5/5a/Left-fold-transformation.png
08:56:50 <Cale> errr
08:56:51 <mm_freak> roconnor: ;)
08:56:54 <Cale> wat.
08:57:06 <Cale> oh well. Someone show that to him if he comes back :)
08:59:09 <EvanCarroll> I for one understand folds (I think), but not those graphs
09:01:30 <EvanCarroll> I often wonder if those really help people understand folds, or if people that already understand folds don't just look at them and say, "ya, they're pretty"
09:02:57 <Romero_> I'm having some list comprehension trouble, does anyone have a moment to help me out?
09:03:26 <c_wraith> Romero_, I'm sure someone will answer. :)
09:04:31 <mun> hi
09:04:47 <sleepynate> hi
09:04:53 * hackagebot improve 0.1.4 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.1.4 (TomHawkins)
09:05:13 <mun> is \lambda a. a (a (a b)) eta equivalent to a b?
09:06:18 <quicksilver> mun: surely not. the former has only 'b' free, the latter has 'a' and 'b' both free.
09:06:56 <Romero_> Here is the paste, along with my question as comments: http://hpaste.org/41708/list_compr I just put a snippet as that's the only part of the code giving me trouble, no need to show anything else but do let me know if you feel like it will help if I paste the entire thing
09:07:39 <quicksilver> Romero_: indeed, it is not in scope
09:07:54 <quicksilver> Romero_: z is only in scope inside the list comp
09:07:58 <Romero_> I'm a bit puzzled by how I can make it in scope, I thought it would be
09:08:09 <quicksilver> you can, instead, put "let (x,y) = resultPlate s z" inside the list comp
09:08:31 <quicksilver> at the end, after a comma, after the call to checkSt
09:08:39 <quicksilver> (or before the call to checkSt, it doesn't make any difference)
09:08:55 <Romero_> Thanks, I will give that a shot quicksilver.
09:08:57 <quicksilver> or you could just forget about x and y entirely
09:09:08 <quicksilver> and write [(resultPlace s z, [z]) | z <- ...... ]
09:09:09 <mun> quicksilver, right. so what is the most simplest form of \lambda a. a (a (a b))?
09:09:30 <quicksilver> mun: that is already in its simplest form.
09:13:44 <mun> quicksilver, right. but then, what do you get for \lambda a. a (\lambda b. a) f? same as (\lambda b. a) f?
09:16:37 <quicksilver> mun: I don't see the connection between your recent question and the one before
09:16:43 <quicksilver> what's with these unused 'b's now?
09:17:00 * kosmikus is puzzled, too
09:17:15 <quicksilver> (\lambda b. a) f ====> a
09:17:32 <mun> quicksilver, i'm just trying to figure out why this prover gives me so many different instantiations to a variable. they are long nested abstractions.
09:18:13 <quicksilver> well, \lambda a . a (a (a b)) is the abstract which, given a function, applies it 3 times to b.
09:18:22 <quicksilver> \f -> (f^3) b
09:20:28 <mun> quicksilver, i see. so something like, \lambda a. a (\lambda b. a (\lambda b. a)), given f, is equivalent to f^3? is this eta-equivalence?
09:21:04 <quicksilver> mun: no, now you've changed it into something else!
09:21:08 <quicksilver> you keep changing what you say.
09:21:25 <quicksilver> I was talking \a . a (a (a b))
09:21:38 <quicksilver> not \a . a (\b . a (\b . a))
09:21:42 <quicksilver> which is quite different.
09:22:08 <mun> quicksilver, sorry, i was just verifying my understanding with a different example.
09:22:12 <quicksilver> f^3 is not eta-equivalent, it's just another notation (used mostly by mathematicians) which I thought you might have been familiar with.
09:23:14 <quicksilver> if you're not, ignore it, it's not helping in the way I hoped ;)
09:25:31 <mun> quicksilver, ok, sticking to \a. a ( a ( a b)) then i'd guess \a. a (\c. a (\c. a b)) is not equivalent to it from my last example (which confused you). but doesn't \c. a give you a, so that should give you \a. a (a (a b))?
09:25:43 <quicksilver> no.
09:25:53 <quicksilver> "\c . a" and "a" are completely different, 
09:26:12 <quicksilver> "\c . a" is a function which, given any parameter returns "a".
09:26:16 <quicksilver> this is not "a".
09:31:29 <EvanCarroll> cool, just sent in patch for => ⇒ and <= ⇐ incompose
09:31:38 <mun> quicksilver, right. please bear with me.. then is \a. a (\c. a (\c. a b)) equivalent to \a. a a, since the first parenthesis returns a?
09:32:01 * hackagebot vector-algorithms 0.4 - Efficient algorithms for vector arrays  http://hackage.haskell.org/package/vector-algorithms-0.4 (DanDoel)
09:32:49 <quicksilver> mun: the first parenthesis?
09:33:01 <dschoepe> Is it just me or is the (new) time library somewhat lacking in terms of convenience functions? for example, just to get the current date one seems to have to do something like this: fmap (localDay ∘ zonedTimeToLocalTime) ∘ utcToLocalZonedTime =<< getCurrentTime
09:33:06 <tolkad> there doesn't seem to be an Ωmega channel. Does anyone know the Ωmega equivalent of import Prelude ()?
09:33:07 <quicksilver> mun: the first parenthesis doesn't turn anything, you never gave it an argument.
09:37:03 * hackagebot attoparsec-enumerator 0.2.0.1 - Convert an Attoparsec parser into an iteratee  http://hackage.haskell.org/package/attoparsec-enumerator-0.2.0.1 (JohnMillikin)
09:37:28 <mun> quicksilver, oh ok. so if \a. a( \c. a (\c a b)) is given f, then it becomes f(\c. f (\c. f b)), and that's the most simplest form.
09:37:44 <freiksenet> do any one of you guys happen to know what happened to Cayenne language? All it's sites are offline
09:38:05 <freiksenet> I'd love to see the code :|
09:38:17 <quicksilver> mun: yes.
09:38:38 <mun> quicksilver, thanks a lot.
09:43:30 <romildo> Can the regex libraries available in Haskel be used with an arbitrary list type [a], or just with string-like types (like String and ByteSting)?
09:44:11 <Jafet> You can write your own instances, romildo, but it's probably not trivial.
09:44:28 <ab9rf> heh, i'm user #666
09:44:48 <c_wraith> I seem to remember an article in TMR about building an arbitrary type regex engine.
09:44:56 <c_wraith> I wonder if that library is on hackage
09:46:02 <romildo> I would like to do web scrapping with using the tagsoup package to tokenize a web page, obtaining a [Tab str] type, and then use a regex library to collect information from the list of tags.
09:46:33 <micahjohnston> is parsec a good idea?
09:46:52 <micahjohnston> it's pretty simple to instantiate for non-string sequences, if I recall correctly
09:47:06 <romildo> So, there is no ready to use regex library that would let me match on the list of tags?
09:47:37 <romildo> micahjohnston, yes, I am looking at parsec as option too.
09:47:56 <c_wraith> yeah, parsec is well-designed to handle arbitrary token types
09:48:02 <c_wraith> it might be your best option
09:48:12 <copumpkin> parsec is industrial-strength!
09:48:13 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
09:48:30 <copumpkin> ski: what about it?
09:48:38 <copumpkin> (apfelmus' operational monad)
09:48:42 <djahandarie> I have industrial strength
09:49:37 <Jafet> This sounds suspiciously like not having a hammer and wanting to build a hammer from scratch to use to fasten a bolt
09:49:37 <ski> copumpkin : i wondered what it was .. but someone linked to the hackage page
09:49:55 <copumpkin> ski: ah, okay :) it's basically a free monad library like the prompt monad
09:50:03 <ski> ok
09:50:09 <ski> i'll look into it later
09:50:15 <ab9rf>  Jafet hah
09:50:21 <tolkad> omg type constructors in Ωmega can't be self referential? that's annoying
09:50:51 <byorgey> preflex: seen augustss
09:50:51 <preflex>  augustss was last seen on #haskell 22 days, 57 minutes and 56 seconds ago, saying: ddarius: and by induction, all finite numbers are nothing?
09:50:53 <tolkad> wait
09:50:59 <copumpkin> byorgey: they fixed the agda bug
09:51:02 <tolkad> nevermind I see why that wont work
09:51:11 <byorgey> freiksenet: I was going to say ask augustss, but it looks like he hasn't been around in a while
09:51:15 <byorgey> copumpkin: cool
09:51:39 <freiksenet> byorgey: pity :( 
09:52:12 <byorgey> freiksenet: is there a reason you're interested in Cayenne in particular?  you may also be interested in taking a look at Agda.
09:52:12 <freiksenet> byorgey: I am trying to find a "general-purpose" programming language with dependent types. Coq and Agda are too proof-oriented :|
09:52:24 <byorgey> freiksenet: ah, I see.
09:52:36 <byorgey> freiksenet: try idris.
09:52:49 <freiksenet> I want to see if it's worth to have dependent types in a general-purpose langauge and what limitations taht brings
09:53:02 <copumpkin> freiksenet: I wouldn't say agda is too proof-oriented for programming, but it still needs lots of work
09:53:07 <copumpkin> yeah, idris is more practical probably
09:53:47 <freiksenet> copumpkin: well it's obviously better than coq in that sense. but it's still quite focused on prooving
09:53:55 <freiksenet> I will take a look at idris
09:54:10 <copumpkin> freiksenet: if you want something sort-of dependent, try ATS
09:54:34 <djahandarie> I like Idris but I hardly have any experience with this stuff so listen to the other people. :P
09:54:58 <copumpkin> the syntax isn't quite as pretty as agda's
09:55:02 <freiksenet> ok
09:55:04 <copumpkin> but it's designed to actually _do_ things with
09:55:48 <jmcarthur> i think adga is not too focused on proving. you can write proof free code all you want in it
09:55:53 <jmcarthur> i agree that it needs work though
09:56:12 <copumpkin> with any luck with the upcoming compiler for it
09:56:15 <copumpkin> a real compiler
09:56:18 <jmcarthur> :D
09:56:21 <copumpkin> it'll be usable for general-purpose stuff
09:56:29 <jmcarthur> how far off is that?
09:56:51 <jmcarthur> will the new one still be using haskell as an intermediate language?
09:57:37 <copumpkin> it will be, yeah
09:57:50 <copumpkin> still quite far off, I'd guess
09:57:54 <copumpkin> not even sure if the project has started
09:58:11 <copumpkin> I remember seeing someone tweet that he'd gotten GHC to compile hand-written core though
09:58:23 <copumpkin> so the project could be rerouted to generate core at least
09:58:37 <jmcarthur> nice
09:59:21 <copumpkin> dolio: ooh, what's new in the new vector-algorithms?
10:00:03 <freiksenet> hm, what I actually liked in Cayenne is anonymous data types. looks like both Agda and Idris use haskell style named-only types
10:05:19 <aristid> freiksenet: i wonder why haskell has no anonymous types
10:05:47 <freiksenet> aristid: me too. that's the thing I would really love to have tbh.
10:05:57 <aristid> there are other things too
10:06:01 <aristid> like a decent records system
10:06:12 * hackagebot data-accessor 0.2.1.5 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.1.5 (HenningThielemann)
10:06:23 <aristid> how apropos
10:07:06 <Jafet> Get Haskell and ML into the same room while drunk
10:07:35 <micahjohnston> haha
10:08:44 <freiksenet> I'd also love to have real metaprogramming, so we also need Common Lisp there.
10:09:30 <dolio> copumpkin: What's new is that I removed the apply combinator and bumped the minimum vector version to 0.6.
10:09:39 <copumpkin> dolio: I liked that combinator!
10:09:41 <copumpkin> :(
10:09:47 <dolio> It's in vector now.
10:09:49 <dolio> Called modify.
10:09:51 <copumpkin> oh excellent
10:10:25 <dolio> I wouldn't have noticed, except GHC 7 keeps breaking type checking for what I had as the implementation of apply.
10:11:47 <dolio> I probably would have tweaked some other things before putting out 0.4, but I deleted all my 6.12 stuff, and accidentally included cabal install.
10:12:03 <dolio> Which isn't updated for 7 yet, so I'm running on what little I can install by hand.
10:12:34 <dolio> And I wanted to stop getting e-mails telling me vector-algorithms doesn't build.
10:16:17 <copumpkin> hah okay
10:16:26 <freiksenet> oh, another "why haskell is not something" question. why haskell was designed to be so heavily "non-reflective"?
10:16:43 <freiksenet> so almost no runtime information is accessible
10:16:52 <monochrom> get haskell and ml in the same room drunk - they will beget a language with eager evaluation, mutable variables, and no records, no parameterized modules. :)
10:17:04 <freiksenet> (maybe I don't know haskell well enough)
10:17:10 <dolio> The first e-mail I got was from Roman suggesting 'apply = modify', at which point I decided to just get rid of it.
10:17:15 <dolio> But I've gotten two since then.
10:17:23 <dolio> monochrom: F#?
10:18:04 <mrd> freiksenet: what runtime information?
10:18:21 <copumpkin> freiksenet: you don't want to be passing around type information at runtime... unless you do, in which case you have Data and Typeable
10:18:46 <copumpkin> freiksenet: the type system was designed so the types could all be erased at runtime
10:18:54 <Adamant> freiksenet: typing system restrictions
10:19:10 <freiksenet> well cayenne (and probably Coq/Agda) keep type infromation during runtime
10:19:15 <freiksenet> information*
10:19:23 <copumpkin> freiksenet: yeah, that kind of comes with dependent types
10:19:34 <dolio> I don't think they do.
10:19:45 <dolio> I don't know Cayenne well, but I doubt it does.
10:19:52 <copumpkin> really?
10:20:02 <dolio> Unless it has type case, it has no reason to.
10:21:00 <freiksenet> dolio: it states that in article
10:22:03 <lostlogic> if I have a function that generates an infinite list of things and I take the first 14 of them for one calculation and then take the first 19 of them for another calculation, are they all recalculated for the second take?
10:22:16 <dolio> Epigram, for instance, is not too different from those languages, and it does type erasure.
10:22:20 <dolio> Epigram 1, that is.
10:23:17 <freiksenet> well they are all slightly different I guess.
10:25:35 <dolio> "Cayenne treats types like first class values. Does this mean that the types have to be present at run time, passed around as arguments, stored in data structures, etc? No, they do not."
10:26:34 <freiksenet> dolio: hm, I've seen a line that says completely opposite thing somewhere
10:26:37 <freiksenet> maybe I misread
10:26:39 <dolio> "The compiler parses Cayenne, does type checking and various other checks, erases types and then translates the resulting code to LML."
10:27:44 <freiksenet> dolio: ok. then i misread. sorry for the confusion
10:27:49 <mrd> lostlogic: do you use the same list?
10:28:41 <tolkad> I'm playing with Omega and I can't figure out why my code isn't working: http://pastebin.com/EL8wZZzz
10:29:09 <tolkad> it says on line 32 "Different Types Natural_(1+cL) ~> Natural -> NBool   !=   a -> b"
10:29:23 <tolkad> (Natural_(1+tno) ~> Natural -> NBool,enp -> fnp)
10:29:53 <tolkad> sorry, I just can't find an omega channel and this error message is terrible
10:31:16 <copumpkin> wow, you really like long names :P
10:31:20 <copumpkin> IncrementNatural? :P
10:32:10 <copumpkin> tolkad: I'm going to guess you want a ~> NBool
10:32:19 <copumpkin> I say that knowing nothing at all about the language
10:32:27 <copumpkin> except what I read in the paper
10:33:38 <zygoloid> tolkad: what's the difference between -> and ~> ?
10:33:54 <tolkad> zygloid: one is more squiggly
10:33:55 <sleepynate> pizzaz
10:34:22 * hackagebot NXT 0.1.3 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1.3 (MitarMilutinovic)
10:34:56 <IceGuest_75> HI
10:35:00 <IceGuest_75> Hi* :/
10:35:16 <zygoloid> > ((-) `on` ord) '-' '~'
10:35:16 <lambdabot>   -81
10:35:18 <tolkad> what the heck are these error message supposed to mean. I have no idea where it is getting these 3 letter combinations
10:35:20 <tolkad> :P
10:35:24 <zygoloid> @bot
10:35:24 <lambdabot> :)
10:35:49 <copumpkin> tolkad: I'm going to guess they're autogenerated names representing universe levels
10:36:22 <copumpkin> at least some of them
10:37:06 <Goosey124> So I'm followed a tutorial to write a bot in Haskell, and I'm trying to use the rpn solver from Bonus's tutorial in it, the problem is.... String -> Float, but the bot expects a different datatype
10:37:18 <Goosey124> I'm lost :/
10:38:00 <tolkad> Goosey124: sorry, that wasn't a description of a problem
10:38:06 <tolkad> Goosey124: could you elaborate?
10:38:13 <Goosey124> Um, can I give you the error?
10:38:31 <Goosey124>  Couldn't match expected type `ReaderT Bot IO ()'
10:38:32 <Goosey124>            against inferred type `Float'
10:39:33 <Goosey124> I'm rather new to this, and thought that it would be rather simple to add a commnad to the bot..
10:39:57 <copumpkin> if you can give us a reference
10:40:05 <copumpkin> for those of us who don't know BONUS' tutorial by heart :)
10:40:11 <Goosey124> Alright
10:40:12 <copumpkin> or its URL
10:40:18 <Botje> Goosey124: can you put the code you have now on hpaste.org, together with the error you got?
10:40:24 <Botje> then we can help more better..er.
10:40:38 <tolkad> oh wait I guess there is a difference between ~> and ->
10:40:52 <copumpkin> tolkad: people don't generally make up separate syntax for shits and giggles :P
10:40:59 <copumpkin> tolkad: and the error seemed to be referencing that
10:41:06 <Goosey124> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot/Source
10:41:09 <Goosey124> That is the bot...
10:41:12 <mrd> sounds like the bot monad
10:41:40 <Goosey124> http://pastebin.com/Rf7KKMVK
10:41:56 <bos> anyway, it's (shits &&& giggles)
10:42:18 <Goosey124> Anyways, I was just starting, so all I really did was copy and paste it...
10:42:27 <Botje> Goosey124: you might squeak by with adding a "return ." in front of the head there
10:42:28 <tolkad> Goosey124: the problem is that the compiler is expecting something with the type ReaderT Bot IO ()
10:42:41 <tolkad> Goosey124: but you gave it something with the type Float instead
10:42:42 <Goosey124> Yeah, so I want to know how to the convert the Float to that
10:42:49 <Botje> Goosey124: but that won't print it.
10:43:00 <Botje> on second thought
10:43:03 <Goosey124> I was just starting it...
10:43:03 <tolkad> Goosey124: we wont know unless you show us your source code?
10:43:07 <Botje> Goosey124: stick a "privmsg ." in front of that head
10:43:36 <Goosey124> Tolkad, Just take that bot, appened the pastebin code to the end, and add this under dispatch a command...
10:43:37 <Goosey124> eval x | "!rpn" `isPrefixOf` x = solveRPN x
10:43:57 <Goosey124> I was just checking to see if it would even run
10:44:03 <Botje> myeah.
10:44:11 <Botje> if you do what I say it will at least typecheck.
10:44:28 <Goosey124> I'll see what happens
10:44:43 <Botje> but to actually run you will need at least "privmsg . head . foldl foldingFunction [] . tail . words"
10:44:59 <Botje> (and remove your explicit type annotation)
10:45:43 <Nibble> is it just me
10:45:46 <Nibble> oh wait
10:45:48 <Nibble> wrong channel
10:46:27 <tolkad> Goosey124: the problem is, it's not expecting a Float, a Float doesn't mean anything in this context. you need to return a type of Net () which is a synonym for ReaderT Bot IO ().
10:47:29 <Goosey124> That's what I thought, but I really have no idea how to do do that.
10:47:39 <Goosey124> Datatypes were what I needed to go back to :/;
10:47:43 <mrd> well you're not supposed to return the result, you're supposed to send the result
10:47:49 <tolkad> Goosey124: so what about: « eval x | "!rpn" `isPrefixOf` x = privmsg (show (solveRPN x)) »
10:47:53 <mrd> and the privmsg function returns Net ()
10:48:12 <Botje> 19:44 < Botje> but to actually run you will need at least "privmsg . head .  foldl foldingFunction [] . tail . words"
10:48:20 <Botje> that. will. work.
10:48:32 <Goosey124> I tried that Botje, I get this error:
10:48:50 <Goosey124> No instance for (Floating String)
10:48:50 <Goosey124>       arising from a use of `foldingFunction' at Test.hs:148:34-48
10:48:52 <tolkad> Goosey124: botje forgot the "show"
10:49:20 <tolkad> Goosey124: just do what I said and leave solveRPN alone
10:49:26 <Goosey124> It works I think
10:49:40 <Goosey124> No, nevermind :P
10:50:00 <tolkad> Goosey124: did you do what I said? « eval x | "!rpn" `isPrefixOf` x = privmsg (show (solveRPN x)) »
10:50:11 <Goosey124> Oh, should I roll back Botje's advice and only apply yours?
10:50:14 <tolkad> Goosey124: yes
10:50:41 <Goosey124> Yours actually makes sense to me
10:50:43 <Botje> hmm. that's nicer :P
10:51:00 <Botje> mine just shoves the IO gunk into solveRPN
10:51:31 * hackagebot has-th 0.1 - Template Haskell function for Has records.  http://hackage.haskell.org/package/has-th-0.1 (ChrisDone)
10:51:32 <Goosey124> Thanks for the help
10:51:38 <Goosey124> I think I'm going to stick around here
10:55:35 <Botje> Goosey124: welcome to the club!
10:55:39 <Goosey124> :D
10:56:14 <Goosey124> Anyways I just started haskell a few days ago, I'm also learning lisp, and I know some Prolog..
10:56:26 <Goosey124> I'm somewhat new to functional languages.
10:56:30 <Rutix> :)
10:56:55 <DanielGomezRico> Hi to everyone
10:57:05 <DanielGomezRico> I have a problem
10:57:15 <DanielGomezRico> I'm starting with haskell
10:57:30 <Botje>   
10:57:33 <Botje> oops
10:57:40 <mrd> DanielGomezRico: that's not a problem
10:57:51 <Rutix> For some it is mrd.
10:57:51 <Rutix> :p
10:58:49 <DanielGomezRico> Can you help me with a code?
10:58:56 <DanielGomezRico> I'm trying to do a simple counter
10:59:02 <Botje> sure, put it on hpaste.org
10:59:03 <DanielGomezRico> that prints 1... 2.. 3.. 4.. 02
10:59:15 <mrd> > [1..]
10:59:16 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:59:20 <Rutix> pow!
10:59:38 <lostlogic> mrd: sorry for not seeing your response sooner - I do not use the same list -- I call the function with two different takeWhiles
10:59:44 <Rutix> :P lambdabot actually cuts it?
10:59:51 <mrd> lostlogic: then no, it will return two different lists
10:59:58 <DanielGomezRico> This is the  code #41711
11:00:06 <Rutix> paste the link
11:00:11 <mrd> ?hpaste
11:00:11 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
11:00:16 <mrd> huh
11:00:20 <Rutix> wut
11:00:23 <DanielGomezRico> Look it http://hpaste.org/41711/code_haskell
11:00:41 <DanielGomezRico> Why it's wrong???
11:00:56 <mrd> DanielGomezRico: "c" is not type ()
11:01:13 <mrd> not type IO ()
11:01:27 <Nibble> "c" is of type String
11:01:49 <DanielGomezRico> c must be an Integer
11:01:52 <lostlogic> mrd: thanks!
11:02:01 <DanielGomezRico> I'm trying to do a recursive counter
11:02:18 <tolkad> DanielGomezRico: http://codepad.org/FQMeKoUg
11:02:20 <mrd> DanielGomezRico: what is the purpose of the code snippet "else c" ?
11:02:46 <DanielGomezRico> Nothing
11:02:58 <DanielGomezRico> I don't know how to say don't do nothing
11:03:00 <mrd> well that's the reason for your type error
11:03:01 <mrd> ah
11:03:08 <mrd> what you want is "else return ()"
11:03:31 <c_wraith> hmm.  "else return ()" implies you should probably be using the when function
11:03:33 <c_wraith> :t when
11:03:34 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:03:39 <DanielGomezRico> :D:D:D
11:03:39 <DanielGomezRico> Thanks!!!!
11:03:41 <DanielGomezRico> :)
11:04:02 <DanielGomezRico> :D
11:04:30 <mrd> @type return () :: IO ()
11:04:30 <djahandarie> I still think there should be a version of > and :t which work off of a vanilla Haskell setup
11:04:31 <lambdabot> IO ()
11:04:34 <DanielGomezRico> tolkad; Thanks, but im trying to do it by hand
11:04:35 <DanielGomezRico> to learn
11:04:41 <DanielGomezRico> Thanks to all
11:04:41 <mrd> djahandarie: ghci ?
11:04:42 <DanielGomezRico> :)
11:04:52 <djahandarie> mrd, for the channel obviously. :)
11:06:00 <tolkad> is it good practice to make a module named EVERYTHING?
11:06:07 <tolkad> so you can do import EVERYTHING
11:06:20 <mrd> no
11:06:29 <djahandarie> That seems pretty antithetical to the point of modules
11:06:43 <c_wraith> What if it didn't have anything in it?  That'd be pretty awesome.
11:06:54 <tolkad> import NOTHING
11:07:32 <mrd> import Beer
11:07:43 <djahandarie> unsafeDrinkBeer
11:08:08 <monochrom> the trouble is that the module can't possibly contain everything.
11:08:09 <proq> unsafeIOVomit
11:08:23 <djahandarie> import Beer.Unsafe; drink >>= unsafeDrive
11:08:30 <sleepynate> wget morebeer:!/
11:08:39 <tolkad> I don't understand -> vs. ~>, it looks like -> is for types and ~> is for kinds but if you have a level polymorphic data type then it might be either one
11:09:18 <tolkad> I wish Carl Sagan were still alive so I could ask him for help
11:10:42 <byorgey> tolkad: are you talking about (~>) in the type of Arrow stuff?
11:10:51 <byorgey> (~>) is not built into the language like (->) is
11:10:58 <byorgey> and -> is used for kinds as well
11:11:16 <monochrom> ~> is a type variable just like f
11:11:19 <tolkad> byorgey: I'm talking about Ωmega
11:11:24 <byorgey> ahhh
11:11:56 <Goosey124> Of course....
11:12:30 <Goosey124> http://pastebin.com/VR39sPaR
11:12:47 <byorgey> tolkad: just a minute, I'm refreshing myself on Omega syntax...
11:14:34 <tolkad> lol if you type :k (~>) in the prompt it crashes
11:15:11 <byorgey> haha
11:15:37 <byorgey> yes, ~> is for function types at the kind level and above
11:15:53 <byorgey> I'm not sure why you need different syntax for -> and ~> though
11:17:16 <byorgey> Goosey124: do you need help?  There's not really enough information in that paste to know what is wrong
11:17:48 <tolkad> I'm still trying to figure out why this wont compile: http://codepad.org/GDLxU6cz
11:18:02 <tolkad> now it's on line 21:
11:18:05 <tolkad> "Natural_(1+cL) ~> Natural_(1+dL) ~> NBool   !=   a -> b"
11:18:29 <tolkad> maybe I need to clarify they are on the same level!
11:22:19 <tolkad> oh wait. I think this doesn't have scope in the same way I think it does
11:22:50 <tolkad> shouldn't matter though I guess
11:23:24 <Goosey124> Byorgey, yes I do D:
11:23:36 <Goosey124> I'm trying to import another module xD
11:24:06 <byorgey> Goosey124: can you paste your code along with the error message?
11:24:12 <Goosey124> Okay
11:24:38 <Goosey124> Here is the Markov Module
11:24:39 <Goosey124> http://pastebin.com/CXLM0NHH
11:24:46 <Goosey124> its obvious that I just need to change datatypes
11:25:15 <Goosey124> The bot itself:
11:25:16 <Goosey124> http://pastebin.com/Yy7L4hmc
11:25:24 <Goosey124> neither one is my original work btw
11:26:07 <Goosey124> The error: http://pastebin.com/p9aLKTw3
11:27:07 <byorgey> ok, on line 97 of Bot.hs, x has type String (since eval takes a String as an argument)
11:27:17 <tolkad> > do { a <- [1..10]; b <- [11..20]; c <- return (a, b); return (c, c) }
11:27:18 <lambdabot>   [((1,11),(1,11)),((1,12),(1,12)),((1,13),(1,13)),((1,14),(1,14)),((1,15),(1...
11:27:29 <byorgey> Goosey124: but M.run has type  Algor -> Word -> [Word]
11:27:36 <byorgey> so calling M.run on a String does not make sense
11:27:49 <byorgey> Goosey124: I am not exactly sure how to fix it though
11:28:01 <tolkad> > do { a <- [1..10]; b <- [11..20]; c <- [(a, b), (b, a)]; return (c, c) }
11:28:02 <lambdabot>   [((1,11),(1,11)),((11,1),(11,1)),((1,12),(1,12)),((12,1),(12,1)),((1,13),(1...
11:28:26 <Goosey124> hmm
11:28:41 <byorgey> Goosey124: what is it supposed to do if the string starts with !evolve ?
11:30:43 * hackagebot shaker 0.5.0 - simple and interactive command-line build tool  http://hackage.haskell.org/package/shaker-0.5.0 (AnthoninBonnefoy)
11:30:45 <byorgey> Goosey124: so, M.run is expecting first an Algor (which is a list of rules) and then a Word, which is the same as String (a bit odd to use Word as a synonym for String but whatever =)
11:31:35 <Goosey124> So, what should I do to fix this?
11:31:43 <byorgey> Goosey124: so I can imagine two scenarios: (1) you always want to run it using the same algorithm, in which case you want to replace (M.run x) with something like  (M.run suc (drop 8 x))
11:32:14 <byorgey> which will use the 'suc' algorithm (defined in the Markov module, you can use whatever algorithm you want) using whatever the user types after !evolve as input
11:32:50 <byorgey> Goosey124: or maybe you want to allow the user to type their own rules along with an input, which would be more complicated and would require you to parse the string into a list of rules
11:32:51 <Goosey124> what if I want it to accept this
11:33:02 <Goosey124> !evolve bun 10110
11:33:05 <Goosey124> bin*
11:33:28 <Goosey124> the markov module works offline like that
11:33:33 <Goosey124> run bin 10110 
11:33:47 <byorgey> Goosey124: ah, that's not too hard, let me paste an example of how you could do that
11:34:16 <Goosey124> could i just do eval :: String -> String -> Net()
11:34:21 <Goosey124> then eval x y |
11:34:41 <Goosey124> There is still the problem of the datatype differences even if that did work though
11:36:44 <byorgey> http://pastebin.com/savBwkCQ
11:37:12 <byorgey> the idea is to break x into pieces with 'words', then use the first piece to decide on the algorithm to use, and the second piece as input
11:39:06 <Goosey124> not in scope :P
11:39:18 <Goosey124> 'bin' 'suc'
11:41:23 <nostrand> would it be possible to use rewrite rules to compute things at compile time?
11:42:20 <djahandarie> Perhaps... but why would you want to use rewrite rules for that?
11:42:39 <djahandarie> You can already compute things at compile-time with type-level functions or template haskell
11:44:11 <monochrom> you may be able to determine from http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/rewrite-rules.html
11:44:48 * hackagebot contstuff 0.6.0 - Fast, easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.6.0 (ErtugrulSoeylemez)
11:44:50 * hackagebot yesod-examples 0.6.0.2 - Example programs using the Yesod Web Framework.  http://hackage.haskell.org/package/yesod-examples-0.6.0.2 (MichaelSnoyman)
11:45:45 <byorgey> Goosey124: oh, sorry, since Markov is imported qualified, you have to use M.bin and M.suc
11:45:55 <Goosey124> I figured it out :p
11:47:37 <Goosey124> Thank you Byorgey
11:47:40 <Goosey124> +2
11:47:52 <byorgey> Goosey124: you're welcome.
11:48:30 <Goosey124> I guess I should make it output only the final evolution...
12:02:23 <SonOfLilit> aah
12:02:43 <SonOfLilit> I have monads-fd and monads-tf competing for module definitions
12:02:46 <SonOfLilit> which should I hide?
12:03:29 <Scala_> I'm looking at a substring example: (take 2 . drop 2) "abcdefg"
12:03:44 <Scala_> why can't you do: take 2 ( drop 2 "abcdefg" )
12:03:56 <Scala_> and what does the . signify in the first example
12:03:56 <monochrom> monads-fd uses functional dependency. monads-tf uses type families. which one do you like more, functional dependency or type families?
12:04:30 <alpounet> Scala_, the one you want to do and the other are actually the same
12:04:36 <alpounet> . is just function composition, like in math
12:04:52 <alpounet> so (f . g) x is f (g x)
12:05:09 <djahandarie> (You like type families more if you aren't sure ;))
12:05:17 <SonOfLilit> monochrom: I like libraries I cabal install to work out of the box instead of complaining
12:05:29 <SonOfLilit> I don't care much for tf or fd right now, I still don't grok either
12:05:42 <monochrom> functional dependency is more traditional
12:05:47 <Scala_> alpounet: I get an error if I try it the second way though:
12:05:47 <Scala_> <interactive>:1:15: lexical error at character '\8220'
12:05:48 <Scala_> *Main> take 2 (drop 4 “abc32wxyz”)
12:06:08 <FauxFaux> Scala_: Something is crapping on your ""s.
12:06:10 <monochrom> what you like is attainable in utopia only
12:06:19 <alpounet> > take 2 (drop 4 "abc32wxyz")
12:06:20 <lambdabot>   "2w"
12:06:35 <alpounet> so, as FauxFaux says, you have inserted some weird char in there
12:06:44 <Scala_> FauxFaux: Oh you're right, thanks
12:07:02 <SonOfLilit> well, when I get deep into a project, I'll decide for that project
12:07:08 <monochrom> in socialist utopia where the government decrees which module names and type classes are legal in which package so there is no clash
12:07:10 <Scala_> I was confused since I figured they should be identical but I got the error on the one.  Thanks for the help
12:07:26 <SonOfLilit> but right now I have a Linear Programming package that I just want to use form ghci
12:07:32 <SonOfLilit> from*
12:07:33 <djahandarie> SonOfLilit, if you need some sort of analogy, Type Families is sort of like Haskell on the type level, while Functional Dependencies is sort of like Prolog on the type level
12:07:36 <SonOfLilit> so I need to hide one
12:07:44 <SonOfLilit> you're saying I should hide fd?
12:07:49 <SonOfLilit> dF*
12:07:52 <SonOfLilit> df*
12:07:54 <SonOfLilit> fd*
12:07:56 <SonOfLilit> lol
12:08:05 <djahandarie> It doesn't matter. I prefer monads-tf.
12:08:20 <monochrom> I prefer monads.fd
12:08:28 <djahandarie> Hey, stop that!
12:08:58 <monochrom> but seeing that you keep trying to put the letter "f" last rather than first, maybe your subconsciousness really wants monad-tf
12:09:20 <mornfall> :)
12:09:40 <monochrom> wait, that's what your subsconsciousness really wants to hide, haha
12:09:52 <SonOfLilit> monochrom: I just want the issue resolved. If you're saying my libraries will work with both, I'll just choose one arbitrarily
12:10:07 <SonOfLilit> and hope that if I ever grok and decide to switch, all my code won't break
12:10:14 <monochrom> I do not know which works with what.
12:10:25 <djahandarie> In theory they should do the exact same thing
12:10:30 <Goosey124> Hey help...
12:10:31 <djahandarie> fd maybe be a safer choice
12:10:37 <Goosey124>  choose   _   = M.bin
12:10:39 <djahandarie> may be*
12:10:44 <Vizard> hello, can i pass a default param to a function ?
12:10:50 <djahandarie> Since fds have been around longer
12:10:58 <Goosey124> How would I prevent crashing from an unknown rule
12:10:58 <SonOfLilit> thanks, all :)
12:11:02 <mornfall> Vizard: Default param? :)
12:11:17 <mornfall> Vizard: As in C++ style? No.
12:11:32 <Vizard> ok i wanna leanr haskell style :)
12:11:35 <mornfall> Vizard: But you can bind the partial application.
12:11:39 <mornfall> (To some new name.)
12:12:15 <mornfall> Like, fun1 a b = ...
12:12:31 <mornfall> fun2 x = fun1 some_value
12:12:35 <mornfall> fun2 x = fun1 some_value x
12:12:37 <Vizard> you mean passing the value i wanna to the same func again ?
12:12:59 <mornfall> (My brain refuses to un-eta-reduce!)
12:13:21 <Vizard> sorry im very new to haskell please be patient :)
12:13:47 <djahandarie> Vizard, where is your knowledge at right now? Do you understand currying?
12:13:57 <Vizard> a little
12:14:57 <mornfall> djahandarie: You don't need currying, actually. You can do the exact same thing in C++. But you can't eta-reduce (in C++).
12:15:32 <djahandarie> True
12:16:21 <djahandarie> Vizard, but I imagine you want something like the ability to call some function f like this?     f 1    or     f no_value      where "no_value" is some magic thing which says "I'm not passing anything"?
12:17:15 <djahandarie> Because then in the function f you could specify some behavior to happen when no_value is passed in.
12:17:29 <djahandarie> Of course no_value doesn't actually exist, it is called something else. But is this what you want?
12:17:44 <mornfall> It's called Nothing. :D
12:18:24 <djahandarie> Right. And it involves changing the type signature of your function to say "You can pass in Nothing for this value, or an actual value"
12:18:24 <Vizard> i wanna count two different elements in a string and compare the result
12:18:45 <djahandarie> Do you have some code already?
12:19:27 <Vizard> f a_list n1 n2 <- if n1 mathes the head of list increment n1
12:19:52 <mornfall> Errm. There's no such thing as increment n1 in Haskell.
12:19:52 <djahandarie> What is the type of f?
12:20:19 <Vizard> f :: [list] -> a -> a -> Bool I thought
12:20:37 <djahandarie> A list of what?
12:20:41 <Vizard> string
12:21:09 <mornfall> You can't compare a to a Char.
12:21:24 <djahandarie> Vizard, the type 
12:21:26 <djahandarie> Oops
12:21:32 <mornfall> From what you say, it'd be more like [a] -> a -> Int -> Int
12:21:34 <djahandarie> Vizard, the type "a" is too generic to do anything useful with it
12:21:52 <djahandarie> mornfall, even then it'd need to have (Eq a) or some similar thing
12:21:54 <mornfall> Hm. Not even that.
12:22:14 <mornfall> djahandarie: Yeah, but it still doesn't do what he said. And n2 was even redundant.
12:22:21 <djahandarie> Vizard, could you describe your problem with more detail?
12:22:22 <mornfall> Well, nvm. Let me come up with some food. : - )
12:23:05 * hackagebot yesod-auth 0.2.0.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-0.2.0.2 (MichaelSnoyman)
12:24:41 <Vizard> yes i have an assignment that i should check if a string has all brackets closed -> that is not the problem, the problem is when i have lets say a string like that "())" where 2 ')''s are closed even if there is no 2 '(' before
12:25:17 <Vizard> i wanna could all brackets and compare the result
12:25:27 <Vizard> count
12:25:30 <djahandarie> Okay
12:26:17 <djahandarie> So to count brackets you want something like   countBrackets :: [Char] -> Int
12:26:30 <djahandarie> You can write that function using recursion and pattern matching
12:27:36 <Vizard> yes, maybe more specific cBrackets :: [Char] -> countLeft -> countRight -> Bool (True or false) if they match and wise versa
12:28:08 <Vizard> i hope you understand my problem :)
12:28:11 <djahandarie> If you already have the counts for the left and right brackets why would you pass in the list?
12:28:26 <monochrom> accumulator parameter
12:29:17 <Vizard> i wanted to solve it recursively so i thought i could take the head and pass the tail to function again and increment the left/right
12:30:39 <monochrom> specification: (cBrackets xs countLeft countRight) iff (countLeft + number of lefts in xs == countRight + number of rights in xs)
12:31:57 <Vizard> can i paste in my code so you can cee my current progress ?
12:32:12 <djahandarie> Personally I wouldn't try to sandwich the whole problem into one function and try to solve it like that
12:32:15 <djahandarie> Yes
12:32:17 <djahandarie> http://hpaste.org
12:34:29 <Vizard> http://hpaste.org/41713/cbracket
12:34:30 <djahandarie> I'd start out just by counting the left brackets in a list, which will have the type [Char] -> Int -> Int.
12:35:27 <roconnor> Is there a monoidWrapper for m () where m is a monad?
12:35:31 <djahandarie> Vizard, your first two lines are correct
12:36:11 <djahandarie> Vizard, you only want to finally return the Bool when you are entirely finished with the String though right?
12:36:19 <Vizard> yes
12:36:35 <Vizard> or in case of "()))" -> False
12:37:04 <Vizard> i stated with list comprehension but faild to check the above case
12:37:14 <djahandarie> You'd only know that you have a count mismatch when you've reached the end of the string, though.
12:37:23 <monochrom> since you are not psychic, you actually must finish with the whole string
12:37:27 <Vizard> [ x ==')' | x <- " ())(()"] == [ x =='(' | x <- " ())(()"]
12:37:35 <monochrom> nor is the computer psychic
12:37:48 <djahandarie> Vizard, in the hpaste code you stop whenever you hit a non-bracket.
12:37:53 <djahandarie> Vizard, but you want to keep on going.
12:37:53 <monochrom> list comprehension does not mean that.
12:38:36 <Vizard> hmm
12:39:47 <djahandarie> Vizard, try thinking through your hpaste function with this string:   "(()abc)"
12:40:20 <dolio> all (`notElem` "()")
12:41:45 <dolio> @check \l -> all (`notElem` "()") l == ([ x == ')' | x <- l] == [x == '(' | x <- l])
12:41:46 <lambdabot>   "OK, passed 500 tests."
12:42:18 <therp> is there a way to combine Data.Binary.Get with a Handle such as a network socket? (Background: I am using Data.ASN1 which implements parsing based on the Get monad of Data.Binary, however, I want to make my source not a bytestring but a network handle..) I guess the answer is no, as Get seems to be side-effect free, and there is no way IO would fit in here.. 
12:42:20 <c_wraith> @check True
12:42:21 <lambdabot>   "OK, passed 500 tests."
12:42:26 <c_wraith> @check False
12:42:27 <lambdabot>   "Falsifiable, after 0 tests:\n"
12:42:53 <Vizard> what does \l mean ?
12:43:11 <djahandarie> Vizard, dolio wasn't solving your problem btw
12:43:14 <c_wraith> \ introduces an anonymous function
12:43:16 <djahandarie> Just doing something random. -_-
12:43:24 <Vizard> ah cool
12:43:32 <c_wraith> f = \x -> x + 1 is the same as f x = x + 1
12:43:39 <Vizard> ok
12:44:20 <dolio> I imagine what I was doing was a demonstration of "list comprehension does not mean that."
12:44:22 <Vizard> i learn more from this channel than in the books :)
12:44:26 <dolio> Although I haven't bothered reading the context.
12:44:49 <ivanm> preflex: seen lispy 
12:44:49 <djahandarie> dolio, yeah, but if anyone could follow that code they'd know that already. :P
12:44:50 <preflex>  lispy was last seen on #darcs 2 hours, 56 minutes and 17 seconds ago, saying: ?tell iago oh, and dons showed me this link too: http://code.haskell.org/~ivanm/Sample_SourceGraph/SourceGraph/SourceGraph.html#overall-cyclomatic-complexity
12:47:33 <iago> good
12:47:33 <lambdabot> iago: You have 2 new messages. '/msg lambdabot @messages' to read them.
12:47:36 <iago> ops
12:47:45 <ivanm> heh
12:48:49 <iago> thanks lispy 
12:50:05 <ursthegizmo> Hi all, short question on c2hs, help largely appreciated: how to marshal "const wchar_t *" ? Instead of "wchar_t *" this gets transformed not to Ptr CWchar, but to Ptr CUShort, which is annoying. any help?
12:52:44 <dmwit> > let l = "(" in (all (`notElem` "()") l, [ x == ')' | x <- l] == [x == '(' | x <- l])
12:52:45 <lambdabot>   (False,False)
12:54:43 <ader111> I am looking for a function like unfold but that will give me the final state in addition to the list, does it exist?
12:56:06 <byorgey> ader111: I don't think there's anything like that in the standard libraries.
12:57:01 <dmwit> :t unfoldM
12:57:02 <lambdabot> Not in scope: `unfoldM'
12:57:07 <dmwit> =P
12:57:26 <ader111> ok that's what I thought
12:57:33 <dmwit> :t unfoldForestM
12:57:34 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (b -> m (a, [b])) -> [b] -> m (Forest a)
12:59:43 <dmwit> ?hoogle State s (Maybe a) -> State s [a]
12:59:43 <lambdabot> No results found
13:00:01 <ader111> dmwit: I am unable to decode the type. is [b] the state?
13:00:09 <dmwit> s is the state
13:00:17 <dmwit> Oh, in unfoldForestM?
13:00:21 <ader111> yes
13:00:23 <dmwit> I don't think unfoldForestM really does what you want.
13:00:31 <djahandarie> It doesn't
13:00:31 <ader111> yeah ok
13:01:18 <djahandarie> I think unfoldrN from ByteString happens to do it, but that is obviously just for Chars, not lists in general
13:01:35 <mm_freak> @whereis comparing
13:01:36 <lambdabot> Maybe you meant: where where+
13:01:39 <mm_freak> @where comparing
13:01:40 <lambdabot> I know nothing about comparing.
13:01:44 <mm_freak> @hoogle comparing
13:01:45 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
13:02:03 <ader111> I'll write it myself no problem
13:02:05 <dmwit> :t let f s = s >>= maybe (return []) (\a -> fmap (a:) (f s)) in f
13:02:06 <lambdabot> forall (m :: * -> *) a. (Functor m, Monad m) => m (Maybe a) -> m [a]
13:02:07 <ader111> thank you all
13:03:17 <dmwit> ader111: Something like that should work...?
13:04:24 <ursthegizmo> c2hs String, withCWString not working on "const wchar_t *" types, since there is a mismatch between CUShort and CWchar handling, any ideas?
13:04:25 <byorgey> that is slightly different
13:04:48 <byorgey> in particular dmwit's version may keep updating the state once it has already yielded Nothing
13:04:58 <dmwit> eh?
13:05:06 <dmwit> Oh, well, yes.
13:05:11 <byorgey> well, I should say, it *allows* for that
13:05:19 <byorgey> but if you write it carefully it won't necessarily do that
13:10:49 <ader111> byorgey: how would it keep updating the state? fmap doesn't run if s in nothing, am i wrong?
13:11:13 <dmwit> s itself would update the state before making it past (>>=)
13:11:59 <dmwit> e.g. (modify (+1) >> return Nothing) would always give an empty list, but also always modify the state.
13:18:57 <therp> is there any class that abstracts over input/output streams?
13:19:50 <therp> as monad class..
13:21:15 <ursthegizmo> need some help: any idea, how to marshall "const wchar_t *" in c2hs (withCWString does not work, since the type get mapped to CUShort !) ???
13:22:51 <ader111> dmwit: ok got iy
13:22:54 <ader111> t
13:28:41 <Goosey124> question
13:28:46 <Goosey124>  >>= brainfuck
13:28:59 <Goosey124> how would i import the parameter of main into brainfuck
13:29:48 <Goosey124> something like this even close:
13:29:49 <Goosey124> main :: String
13:29:49 <Goosey124> main x = do
13:29:49 <Goosey124>     x >>= brainfuck
13:29:49 <Goosey124>     return ()
13:31:57 <byorgey> Goosey124: by 'parameter of main' do you mean a command-line argument?
13:32:09 <Goosey124> byorgey, basically
13:32:17 <byorgey> main :: IO ()
13:32:29 <Goosey124> I want to be able to do !bf <bfcode>
13:32:32 <Goosey124> and have it output 
13:32:41 <Goosey124> originally it was like this: 
13:32:42 <Goosey124> main :: IO ()
13:32:42 <Goosey124> main = do
13:32:42 <Goosey124>     readFile "helloworld.bf" >>= brainfuck
13:32:42 <Goosey124>     return ()
13:33:10 <Goosey124> I thought this might work in the bot: eval x | "!bf " `isPrefixOf` x = privmsg (show (BF.main x))
13:33:35 <byorgey> it's not that simple, it appears that brainfuck uses the IO monad
13:33:43 <Goosey124> Yeah
13:34:08 <djahandarie> But IIRC the Net type in that bot tutorial is just a wrapper around IO
13:34:16 <byorgey> yeah
13:34:25 <byorgey> Goosey124: how is Net defined?
13:34:47 <Goosey124> type Net = ReaderT Bot IO
13:34:47 <Goosey124> data Bot = Bot { socket :: Handle, starttime :: ClockTime }
13:34:49 <djahandarie> So you should be able to do a monadic bind over the lifted result and pass the result to privmsg or whatever function
13:36:18 <byorgey> unfortunately it looks like the brainfuck function prints its output on the screen instead of returning a result =(
13:36:25 <djahandarie> Yuck
13:36:28 <byorgey> which makes it very hard to use with anything else.
13:36:44 <byorgey> Goosey124: how is the 'brainfuck' function defined?
13:36:45 <djahandarie> There isn't any internal function exposed in the library to just drop it in IO a?
13:36:54 <Goosey124> should I paste the code?
13:36:57 <byorgey> sure
13:37:17 <Goosey124> http://pastebin.com/rh3duzSq
13:37:38 <jmcarthur> :t getArgs
13:37:39 <lambdabot> Not in scope: `getArgs'
13:37:46 <jmcarthur> :t System.Environment.getArgs
13:37:47 <lambdabot> IO [String]
13:38:17 <byorgey> Goosey124: unfortunately, that bf interpreter is defined in such a way that it actually prints stuff on the screen, instead of returning a String
13:38:34 <Goosey124> Oh...D:
13:38:34 <byorgey> which means you won't be able to use it unless you change it so that it returns a String
13:38:41 <djahandarie> Goosey124, make bfPrint accumulate a String rather than print to the screen
13:39:15 <djahandarie> It'll also get IO out of your types :)
13:39:28 <byorgey> you would want to change the VM type so it includes the output so far
13:39:34 <Goosey124> That's a little over my head...or a lot
13:39:44 <Goosey124> I'll just save this and work on it when i can figure it out
13:39:52 <byorgey> Goosey124: ok, sounds good =)
13:40:03 <byorgey> Goosey124: are you following a particular book or tutorial?
13:40:06 <djahandarie> Goosey124, if you didn't write the BF interpreter there are other ones other there with better interfaces if I remember correctly
13:40:32 <Goosey124> Well, I'm just going through learnyouhaskell.com or whatever to get the basic idea
13:40:42 <Goosey124> Really, I'm just screwing around 
13:40:49 <byorgey> OK =)
13:40:52 <Goosey124> dj, is that right?
13:40:58 <djahandarie> http://hackage.haskell.org/package/brainfuck for example
13:41:28 <Goosey124> I'm running windows and I was missing a lot of dependencies...
13:41:56 <djahandarie> Ah
13:42:01 <djahandarie> That only can be used on unix
13:42:05 <djahandarie> unix dependency ftl
13:42:19 <Goosey124> I'll install linux again, I just haven't gotten around to it
13:43:23 <monochrom> probably won't make a difference
13:43:37 <monochrom> oh oops, nevermind, wants the unix package
13:43:55 <monochrom> use a virtual machine such as virtualbox then.
13:44:06 <Kaidelong> why do we have IO instead of a separate I for nondeterminism and O for side-effects?
13:44:16 <Kaidelong> and something that combines the two for IO?
13:44:31 <monochrom> historical accident
13:45:06 <Kaidelong> so if someone were to write a pure functional language from the ground up that'd be a consideration
13:45:11 <ivanm> I believe there have been attempts at probability/non-determinism monads
13:45:15 <Kaidelong> or is there some major engineering tradeoff?
13:45:39 <ivanm> Kaidelong: *shrug* probably easier to combine them, that's all (since your source for random numbers involves side-effects, etc.)
13:46:24 <Kaidelong> ivanm: but what about something like nondeterministic concurrency? That involves "input" in that the environment determines the order in which things happen but it need not cause side effects outside of the model
13:46:24 <byorgey> Kaidelong: you could imagine splitting up IO into a lot more fine-grained pieces than that.
13:46:32 <ursthegizmo> Hi all, anybody with c2hs experience, need help, how to marshall "const wchar_t *" to String? This is not as easy, as it seems, since "const wchar_t *" gets mapped to Ptr CUShort instead of Ptr CWchar, which makes the normal marshalling functions useless. Any Idea?
13:46:43 <byorgey> the engineering is more difficult since now you have to start tracking sets of possible effects.
13:48:56 <mightybyte> Does Haskell have a way to get an integral sub-second timestamp ala Java's currentTimeMillis()?
13:50:46 <Goosey124> http://haskell.org/haskellwiki/Short_examples/BF_interpreter
13:50:59 <Goosey124> How's that look to you guys for integrating?
13:52:23 <monadic_kid> mightybyte: what do you need a timer for exactly, you might be better off with higher frequency timer and/or certain guarantees like non-decreasing values on multi-cores
13:52:47 <byorgey> Goosey124: worse.
13:53:24 <Goosey124> Figured..
13:53:28 <Goosey124> I couldnt even figure out how to use
13:53:49 <mightybyte> monadic_kid: I was wanting to build high-resolution time limits into some processing code I've got.
13:54:14 <djahandarie> mightybyte, you can get a fractional one
13:54:34 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/time-1.1.4/Data-Time-Clock.html#v%3AgetCurrentTime seems to be beyond subsecond and even beyond submillisecond
13:54:37 <mightybyte> djahandarie: Ugh, I hate working with fractional numbers.
13:54:47 <mightybyte> God created the integers...all else is the work of man. :)
13:55:35 <copumpkin> *naturals
13:55:37 <copumpkin> integers are icky too
13:55:48 <mightybyte> lol
13:56:12 <monadic_kid> mightybyte: what frequencey? nanoseconds? (billionth of a second). Well there is a posix clocks (clocks various kinds) binding for haskell on hackage, but windows doesn't implement those posix functions I believe
13:56:15 <monochrom> implementation of UTCTime is Data.Fixed.Pico so it's integral.
13:56:23 <mightybyte> monochrom: Yeah, I saw that.  Just noticed getCPUTime though...maybe that's better.
13:56:24 <ivanm> byorgey: btw, are you still working on that combinatorial-species-based alternative to quickcheck?
13:56:25 <djahandarie> Yeah monochrom is right
13:56:28 <ab9rf> mightybyte: the natural numbers all follow from the existence of two
13:56:32 <ivanm> (I'm pretty sure it was you who was telling me about that...)
13:56:33 <mightybyte> monadic_kid: milliseconds is fine for me
13:56:57 <monochrom> Data.Fixed.Pico is integral with a fractional disguise.
13:56:59 <byorgey> ivanm: I probably did tell you about it, but it is not I who is working on it
13:57:09 <byorgey> ivanm: I don't know what the progress is
13:57:11 <ivanm> ahhhh
13:57:26 <mightybyte> Maybe the better thing to do is just spawn another thread and have it sleep for the desired time and then set an IORef or something to tell the worker thread to stop.
13:57:31 <pygmalion> is anyone familiar with writing simple AIs in haskell?
13:57:42 <mightybyte> pygmalion: What kind of AI?
13:57:48 <monadic_kid> got be wary of some of these timer, they can do funny things on multicore chips. Monotonic clock is the best thing to use
13:57:56 <pygmalion> mightybyte: for a mancala game
13:57:57 <monochrom> getCPUTime looks good too
13:58:10 <monadic_kid> mightybyte: http://hackage.haskell.org/package/clock
13:58:12 <Goosey124> http://sabbatical-year.blogspot.com/2008/01/brainfuck-its-last-one-i-promise.html
13:58:15 <Goosey124> what about that one?
13:58:52 <mightybyte> pygmalion: Funny you should ask, because that's what I'm working on too.
13:59:20 <ivanm> ... are mightybyte and pygmalion working on the same assignment?
13:59:21 <ivanm> :p
14:00:01 * mightybyte is long finished with assignments
14:00:18 * pygmalion is not
14:00:50 <mightybyte> But if I go the separate thread route, then I need a sleep function with subsecond resolution.
14:01:29 <monochrom> "assignment" takes on a different meaning in my previous school. "assessment" is homework to be handed in and affects grades. "assignment" is just suggested exercises, no obligation.
14:01:43 <jmcarthur> threadDelay is subsecond
14:01:49 <mightybyte> Ahh, thanks.
14:02:14 <sm> threadDelay is reputed to be choppy on different platforms
14:02:17 <monochrom> threadDelay is so extremely subsecond that it has problems sleeping for more than 21 minutes.
14:02:20 <sm> I heard minimum 40ms on windows
14:02:32 <jmcarthur> 40ms is still less than a second ;)
14:02:47 <mightybyte> monochrom: Ooooh, that could be a problem...although it would be rare.
14:03:06 <mightybyte> I guess I could just put a ceiling on the sleep time and check manually.
14:03:09 <monochrom> I just wrote my own loop over it.
14:03:14 <jmcarthur> mightybyte: there's always SIGALRM
14:03:36 <FauxFaux> Is there a succinct way to write "(\x y -> [x,y])", i.e. two bs to a list: b -> b -> [b]?
14:03:48 <jmcarthur> you end up having to write FFI to use it though
14:03:56 <ezyang> @pl (\x y -> [x,y]) 
14:03:57 <lambdabot> (. return) . (:)
14:03:59 <byorgey> FauxFaux: nothing more succinct than \x y -> [x,y]
14:04:00 <ezyang> lol 
14:04:05 <ezyang> mmm list monad 
14:04:10 <FauxFaux> Thanks ezyang, my head hurts now.
14:04:10 <dmhouse> FauxFaux: what's wrong with exactly that?
14:04:21 <byorgey> I prefer the robot monkey operator
14:04:23 <dmhouse> FauxFaux: it's succinct and clearer than any pointsfree alternative you're going to find
14:04:28 <byorgey> :t (.(:[])).(:)
14:04:29 <lambdabot> forall a. a -> a -> [a]
14:04:38 <mightybyte> jmcarthur: Hmmm, never used SIGALRM
14:04:44 <FauxFaux> byorgey: /o\
14:04:44 <jmcarthur> > length "(:[])" `compare` length "pure"
14:04:44 <monochrom> @free (.(:[])).(:)
14:04:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
14:04:45 <lambdabot>   GT
14:04:53 <monochrom> oh well
14:05:30 <byorgey> FauxFaux: hehe =)
14:05:38 <ursthegizmo> How to do withCWString for Ptr CUShort ? (c2hs)
14:05:48 <ursthegizmo> (last try :-) )
14:05:50 <codolio> @free whatever :: a -> a -> [a]
14:05:50 <lambdabot> $map f . whatever x = whatever (f x) . f
14:06:05 <byorgey> ursthegizmo: is there a mailing list for c2hs or something like that?
14:06:28 <byorgey> ursthegizmo: there probably are people out there who can help you but the chance they are reading #haskell at the moment is slim
14:06:38 <byorgey> ursthegizmo: you might also try sending a message to the haskell-cafe mailing list
14:06:50 <ezyang> ursthegizmo: You might have to manually write the function yourself. 
14:06:54 <ezyang> It wouldn't be too difficult. 
14:07:30 <monadic_kid> ursthegizmo: have you seen the Foreign.Marshal.Utils module?
14:07:34 <ezyang> alternatively, cast the pointer. 
14:07:50 <monadic_kid> ursthegizmo: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/Foreign-Marshal-Utils.html
14:07:51 <ursthegizmo> cast the pointer sound good
14:07:52 <ezyang> I don't recall what kind of guarantees you get about wchar_t versus ushort_t 
14:08:04 <ezyang> Maybe you can tell c2hs explicitly what type to generate? 
14:08:28 <ezyang> I'm a bit confused why c2hs is getting the type wrong. Can you hpaste? 
14:09:04 <monadic_kid> :t Foreign.Marshal.Utils.with
14:09:05 <lambdabot> forall a b. (Foreign.Storable.Storable a) => a -> (GHC.Ptr.Ptr a -> IO b) -> IO b
14:09:40 <monadic_kid> :t Foreign.Marshal.Utils.moveBytes
14:09:41 <lambdabot> forall a. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr a -> Int -> IO ()
14:10:21 <ursthegizmo> wchar_t * ends up in a Ptr CWchar, const wchar_t * in a Ptr CUShort, seems to be the default behaviour
14:10:38 <ezyang> See, that makes no sense at all. 
14:11:25 <ezyang> Sounds like a bug. 
14:12:30 <ursthegizmo> jup, will try the mailing list and the utils, thanks for help so far
14:12:42 <monadic_kid> well you could just not use c2hs for those functions and write the high-level functions yourself
14:12:42 <Quadrescence> Cale: you around
14:13:06 <ezyang> I mean, the point of c2hs is that it gets the types right. 
14:13:10 <mm_freak> what's the easiest way to get a recent haskell platform to run on debian lenny?
14:13:22 <ezyang> I hear every once in a while xmonad gets some segfault and its because some FFI binding's type was wrong. 
14:13:23 <mm_freak> the repositories only provide GHC 6.8, which is quite a bit outdated
14:13:30 <ezyang> So if it's getting it wrong, this should be fixed. 
14:13:53 <ursthegizmo> need to leave, keep you updated on progress
14:15:28 <monadic_kid> ezyang: I'm not saying it shouldn't, just saying if he really needs to for now he can write the high-level functions/types himself without c2hs. There is also that newish tool for generating FFI imports from c-headers called HSFFIG
14:16:09 <monadic_kid> i got to try this out at some point: http://hackage.haskell.org/package/HSFFIG
14:16:23 <ezyang> ooh, that didn't exist when I was knee deep in c2hs last summer 
14:17:32 <monadic_kid> well it's not a complete replacement for c2hs, c2hs can generate high-level more haskell like functions
14:19:09 <monadic_kid> although you end up writing withX functions and manually implementating Storable with c2hs anyway
14:19:14 <litb> hello folks
14:20:15 <litb> it just appeared to me: liftM2 must be like   do a <- m1; b <- m2; return f a b; or am i wrong?
14:20:27 <ezyang> :t liftM2 
14:20:30 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
14:20:51 <ezyang> :t (\m1 m2 -> m1 >>= \a -> m2 >>= \b -> return (f a b)) 
14:20:52 <lambdabot> forall (m :: * -> *) a a1 b. (Show a, Show a1, SimpleReflect.FromExpr b, Monad m) => m a -> m a1 -> m b
14:21:09 <monadic_kid> c2hs's aligment support is broken if i remember correctly, you'll end up mixing with hsc2hs to get better cross-platform code
14:21:19 <ezyang> monadic_kid: Yeah, that was my experience. 
14:21:35 <ezyang> er, lambdabot, wut 
14:21:44 <ezyang> oh 
14:22:04 <ezyang> :t (\f m1 m2 -> do {a <- m1; b <- m2; return (f a b)}) 
14:22:05 <lambdabot> forall (m :: * -> *) t b t1. (Monad m) => (t -> t1 -> b) -> m t -> m t1 -> m b
14:22:20 <monadic_kid> litb: you can think of it like that
14:22:31 <ezyang> the types are right :-) 
14:22:32 <litb> @src liftM2
14:22:32 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
14:22:53 <monadic_kid> litb: ap is interesting function for you ;)
14:23:00 <litb> oh i needed the parens around it?
14:23:23 <litb> yeah i forgot them. i confused it with the C return haha
14:23:31 <monadic_kid> > (+) `ap` Just 3 `ap` Just 5
14:23:31 <lambdabot>   Couldn't match expected type `(a -> b) -> a -> b'
14:23:31 <lambdabot>         against inferred ...
14:24:17 <monadic_kid> > (+) <$>  Just 3 <*> Just 5
14:24:18 <lambdabot>   Just 8
14:24:27 <litb> neat!
14:24:32 <Vizard> is haskell really hard to learn ?
14:24:45 <litb> :t ap
14:24:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:25:10 <byorgey> Vizard: yes.  But it is worth it.
14:25:22 <monadic_kid> litb: basically instead of liftM1/2/3/4... you can use ap or <*> for any number
14:25:33 <byorgey> Vizard: however, there are good tutorials, e.g. Learn You a Haskell
14:25:35 <byorgey> @where lyah
14:25:35 <lambdabot> http://www.learnyouahaskell.com/
14:25:37 <monadic_kid> litb: but you need to lift the pure function first
14:25:39 <litb> looks like that   ap [(+ 3), (* 3)] [3, 3] should yield   [6, 9]   ?
14:25:52 <ezyang> litb: Nope. 
14:25:56 <litb> hm :/
14:26:03 <ezyang> > [(+3), (*3)] `ap` [3,3] 
14:26:04 <lambdabot>   [6,6,9,9]
14:26:11 <Vizard> i'm desperately trying to write a function which converts an uncurried function to curryed function
14:26:13 <ezyang> because the list monad is nondeterministic, not zipper. 
14:26:30 <byorgey> Vizard: ok, what is its type?
14:26:34 <byorgey> that's the best place to start.
14:26:35 <ezyang> it's an understandable mistake to make though, and there is totally a valid applicative instance. 
14:26:43 <Vizard> a->a->a
14:26:59 <byorgey> Vizard: what is that the type of?
14:27:07 <ab9rf> Vizard: uh, currying in haskell is so easy it's rather hard to not do it
14:27:14 <monadic_kid> > return (+)  `ap`  Just 3 <*> Just 5
14:27:15 <lambdabot>   Just 8
14:27:24 <litb> @src ap
14:27:25 <lambdabot> ap = liftM2 id
14:27:29 <byorgey> ab9rf: no discouraging people who are just learning, please.
14:27:33 <litb> ohh that looks simple!
14:27:33 <ezyang> Another idiom is to use <$> to elide lifting the pure function. 
14:27:43 <ezyang> > (+) <$> Just 3 <*> Just 5 
14:27:44 <lambdabot>   Just 8
14:27:50 <ab9rf> byorgey: that would be me, but thanks :)
14:27:53 <monadic_kid> thanks for copying me ;)
14:27:55 <ezyang> I personally like this function. 
14:28:04 <Vizard> the  type is f :: (a,b) -> c 
14:28:05 <hpc> <$> is one magic function
14:28:07 <ezyang> Oh, lol, it was already mentioned on IRC. 
14:28:21 * ezyang is not paying close attention 
14:28:23 <shachaf> > (+) . Just 3 <*> Just 5
14:28:25 <lambdabot>   Just 8
14:28:31 <byorgey> Vizard: that's the type of the uncurried function, right?
14:28:31 <profmakx> ww
14:28:36 <Vizard> yes it seems so easy but i'm not that smart for it i thing
14:28:36 <ezyang> schachaf: Mean. 
14:28:46 <Vizard> yes
14:28:54 <byorgey> Vizard: ok, and what should the type of the curried version be?
14:29:05 <monadic_kid> litb:  the other form is using something called applicative functor
14:29:13 <Vizard> f :: a -> b -> c
14:29:23 <monadic_kid> :t <$>
14:29:23 <lambdabot> parse error on input `<$>'
14:29:28 <shachaf> ezyang: I think that should be directed at Cale. :-)
14:29:28 <monadic_kid> :t (<$>)
14:29:29 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
14:29:33 <byorgey> Vizard: right.  except f can't have both those types =)
14:29:36 <monadic_kid> :t (<*>)
14:29:36 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:29:48 <byorgey> Vizard: so what should be the type of a function to convert uncurried functions to curried functions?
14:29:51 <Vizard> ok than f' :: a -> b -> c
14:29:53 <monadic_kid> :t ap
14:29:54 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:29:56 <monadic_kid> :t (<*>)
14:29:57 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
14:29:58 <byorgey> Vizard: yes, great.
14:30:34 <hpc> (<*> looks vaguely like flip...)
14:30:36 <Vizard> i dont know byorgey
14:31:15 <byorgey> Vizard: well, as input it will take an uncurried function, and as output it will give a curried version of that function, right?
14:31:24 <Vizard> yes
14:31:30 <byorgey> so it will look like  (...) -> (...)
14:31:35 <byorgey> with some stuff in the ...
14:31:45 <Vizard> ok
14:32:02 <byorgey> the type of its input goes in the first ...
14:32:08 <byorgey> and the type of its output goes in the second ...
14:32:13 <byorgey> and you have already told me what those types are
14:32:18 <litb> so if i call ap  with a function as first arg, it seems it will activate the  ((->) e)  monad?
14:32:42 <byorgey> litb: yup
14:32:45 <he2> i would like to execute a second comamnd after a first one
14:32:50 <he2> hwo can i do so?
14:33:17 <byorgey> he2: perhaps with >> ?  what exactly do you mean by command?
14:34:07 <Vizard> i have a simple function lets say plus (a,b) = x + y and i want a curryFunc but writing curryFunc = curry(plus) dowsnt work
14:34:52 <Vizard> or curryFunc f = curry (plus) ??
14:37:10 <ion> Why plus (a,b) = x + y? What do x and y refer to if not the arguments? Do you mean plus x y = x + y? (Or the equivalent plus = (+))
14:37:24 <BrianHV> could someone please translate the following warning for me?  https://gist.github.com/710857
14:37:57 <Vizard> but the thype of plus (x,y) and plus x y arent the same arent they ?
14:38:05 <byorgey> Vizard: curryFunc = curry plus  ought to work.  What error do you get?
14:38:06 <he2> http://pastebin.com/KHzfLQyi <- this script should print a specific line of the pascal triangle
14:38:13 <he2> but ther is n error
14:38:20 <byorgey> Vizard: I thought you were trying to implement your own curry.
14:38:21 <he2> but i can't find it
14:38:34 <ezyang> BrianHV: It means that GHC couldn't figure out what concrete type rgb should be, because it was underspecified, and decided to just use Integer. 
14:38:40 <ion> vizard: plus (x,y) takes a single tuple of two items, plus x y takes two separate arguments.
14:38:41 <ezyang> You can make it go away with an explicit type somewhere. 
14:38:44 <Vizard> *Main> curryFunc = curry plus
14:38:46 <Vizard> <interactive>:1:10: parse error on input `='
14:39:11 <Vizard> oh ok with let 
14:39:27 <BrianHV> ezyang: where should I put it?  I tried (arbitrarily) (rgb 255::Integral 0 0) and it didn't take
14:39:36 <byorgey> Vizard: ah, yes, usually you make definitions in a file and then load it into ghci
14:39:48 <ezyang> BrianHV: Integral is a typeclass, not a type. 
14:39:50 <BrianHV> on rgb, perhaps?  hm...
14:39:52 <byorgey> Vizard: you can then change the file and just type  :r  to reload it in ghci
14:40:03 <Vizard> ok
14:40:44 <BrianHV> ezyang: ermph.  good point.
14:41:00 <ion> > let plus (a,b) = a + b; plus' = curry plus in plus' 3 4
14:41:01 <lambdabot>   7
14:41:34 <Vizard> byorgey: thank you i got it :)
14:41:39 <byorgey> Vizard: good =)
14:41:59 <ion> In that example, plus' is equivalent to (+), and plus is equivalent to uncurry (+).
14:42:00 <BrianHV> ezyang: ok, got it.  thanks!
14:42:08 <ezyang> cool. 
14:43:24 <Vizard> but what is the sense of curry/uncurrying ?
14:43:42 <Vizard> arent the functions the same ?
14:43:55 <ezyang> Vizard: Curried functions can be partially applied. 
14:44:10 <ezyang> Uncurried functions can sometimes be convenient 
14:44:39 <ezyang> > uncurry (/) . foldl' ((+) <&> (flip (const (+1)))) (0,0) $ [2,3,4,5,6] 
14:44:40 <lambdabot>   Not in scope: `<&>'
14:44:59 <ezyang> > let f1 <&> f2 = \(r1, r2) a -> (f1 r1 a, f2 r2 a) in uncurry (/) . foldl' ((+) <&> (flip (const (+1)))) (0,0) $ [2,3,4,5,6] 
14:44:59 <lambdabot>   4.0
14:45:06 <ezyang> \o/ 
14:45:46 <Vizard> partially applied means that i can use a function lets say with 5 arguments, with 4 arguments ?  
14:46:10 <danharaj> it means you can apply the 5 argument to 1 argument and get a function of 4 arguments.
14:46:19 <danharaj> function of 5*
14:47:08 <EvanCarroll> why isn't there a Data.Text.fromList
14:47:08 <Vizard> ah ok now i understand ty
14:47:48 <byorgey> EvanCarroll: what about Data.Text.pack ?
14:47:57 <monochrom> because it's called pack
14:48:11 <byorgey> oh, I see.
14:48:28 <EvanCarroll> byorgey: nifty
14:48:33 <EvanCarroll> why call it pack
14:48:35 <byorgey> well, in that case I expect bos's keyboard was out of L's, or something
14:48:39 <EvanCarroll> bleh
14:48:46 <monochrom> now, why isn't there a Data.Text.字串變文字 ? XD
14:48:47 <bos> hrrrm?
14:48:59 <byorgey> EvanCarroll: probably because it does a lot more than 'fromList' would indicate.
14:49:08 <byorgey> bos: see scrollback =)
14:49:12 <bos> ah
14:49:13 <monochrom> no, it does a lot less.
14:49:21 <byorgey> oh?
14:49:26 <EvanCarroll> ait only takes a String ?
14:49:38 <EvanCarroll> erg, why not fromString then =(
14:49:39 <monochrom> "fromList" implies [a] -> Text. it does too much.
14:49:42 <djahandarie> monochrom, I have little clue what that says, and I speak Japanese. :( Chinese too hard.
14:49:52 <EvanCarroll> I just use tab-completion, I kind of expected the from* to be there.
14:49:59 <EvanCarroll> that's cool though, live andlearn
14:50:00 <byorgey> monochrom: oh, I see your point.
14:50:28 <djahandarie> Let's have an argument about the naming in Data.Text
14:50:32 <djahandarie> You know
14:50:36 <monochrom> "meaningful" identifiers ftw
14:50:37 <byorgey> EvanCarroll: FWIW, I think it parallels the names of functions available in the bytestring library.
14:50:38 <djahandarie> It's a past-time
14:50:52 <monochrom> all names should be in Chinese
14:51:26 <djahandarie> monochrom, I expect ChinesePrelude to be released on Hackage by tomorrow
14:51:37 <monochrom> in principle, all functions are eligible for the "from*" naming meme.
14:51:50 <byorgey> hahaha
14:52:02 <byorgey> curry = fromUncurried
14:52:08 <byorgey> and so forth
14:52:11 <djahandarie> I demand all functions to be named fromXtoY
14:52:13 <byorgey> I like it ;)
14:52:14 <dabblego> why can't I declare: data a /\ b ?
14:52:19 <ion> > {- Vizard: perhaps this example about currying is helpful -} let plus = \a -> \b -> a + b {- The definition plus a b = a + b is syntactic sugar for that one -}; plus3 = plus 3 {- Expanding it, ‘plus3 = plus 3’ → ‘plus3 = (\a -> \b -> a + b) 3’ → ‘plus3 = \b -> 3 + b’ → ‘plus3 b = 3 + b’ -} in plus3 4
14:52:20 <lambdabot>   7
14:52:25 <djahandarie> We need as much as redundancy as possible
14:52:25 <hpc> dabblego: '/' is lower case
14:52:32 <jmcarthur> dabblego: try data a :/\ b
14:52:32 <byorgey> dabblego: constructors must start with a colon
14:52:34 <dabblego> oh bugger
14:52:39 <dabblego> yeah thanks
14:52:47 <hpc> oh, constructors need a colon?
14:52:49 <byorgey> I find it annoying too =(
14:52:59 <danharaj> I never understood the naming of constructors as unS
14:53:04 <dabblego> do I need -XTypeOperators?
14:53:11 <jmcarthur> you might yeah
14:53:11 <byorgey> probably
14:53:16 <dabblego> ok cheers
14:54:01 <romildo> How can one write the following code in a more compact way, without using the case expression? 
14:54:02 <romildo>          case lookup "src" xs of
14:54:02 <romildo>            Just src -> return src
14:54:02 <romildo>            Nothing -> parseZero
14:54:22 <dabblego> maybe parseZero return lookup
14:54:59 <Vizard> ion, that is a good example ty :)
14:55:39 <romildo> :t maybe parseZero return lookup
14:55:40 <lambdabot> Not in scope: `parseZero'
14:56:08 <dabblego> @type \parseZero lookup -> maybe parseZero return lookup
14:56:08 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> Maybe a -> m a
14:56:15 <monochrom> maybe parseZero return (lookup "src" xs)
14:56:32 <dabblego> oh I missed that bit
14:56:48 <dabblego> @type \parseZero xs -> maybe parseZero return (lookup "src" xs)
14:56:48 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> [([Char], a)] -> m a
14:56:57 <litb> how can i list the instance source for  ((->)e) for Monad?
14:57:11 <hpc> @src (->) return
14:57:11 <lambdabot> return = const
14:57:13 <litb> i don't understand what >>= could do. i think  return should be  const
14:57:17 <hpc> @src (->) (>>=)
14:57:18 <lambdabot> f >>= k = \ r -> k (f r) r
14:57:21 <litb> oh that way
14:57:29 <hpc> when in doubt, follow the types
14:57:46 <monochrom> follow the piper
14:58:01 <aristid> @pl \f k r -> k (f r) r
14:58:01 <lambdabot> flip flip id . (ap .) . flip (.)
14:58:01 <litb> :P
14:58:17 <osaunders> What's that «k = » in @src (->) (>>=)?
14:58:26 <osaunders> Is that legal?
14:58:30 <aristid> lambdabot: why not just (>>=)?
14:59:09 <dabblego> @pl \ r -> k (f r) r
14:59:10 <lambdabot> k =<< f
14:59:31 <litb> > (do { x <- (+ 3); return (x 2); }) 4
14:59:31 <lambdabot>   7
14:59:35 <litb> how can that work?
15:00:09 <hpc> litb: funky num instances
15:00:16 <litb> oh wait i think i see now
15:00:18 <hpc> litb: try it in your ghci and it will not typecheck
15:00:52 <litb> hm nope i don't see now lol
15:01:01 <litb> hpc: oh
15:01:17 <hpc> litb:
15:01:19 <hpc> > 5 4
15:01:20 <lambdabot>   Ambiguous type variable `t' in the constraint:
15:01:20 <lambdabot>    `GHC.Num.Num t' arising f...
15:01:24 <hpc> > 5 4 :: Int
15:01:25 <lambdabot>   5
15:01:42 <litb> will it not do   return (4 2)   in the end?
15:02:00 <litb> err.   return (7 2)   i think  ?
15:02:02 <hpc> > (do {x <- (+); return (x 3)}) 4
15:02:03 <lambdabot>   7
15:02:17 <litb> hpc: oh weird
15:02:50 <hpc> litb: in the case of functions, fromIntegral = const; it makes the extra numbers in your thing ignored
15:03:04 <dancor> shouldn't Data.Ord have a revOrd function (LT -> GT, EQ -> EQ, GT -> LT)?
15:03:44 <hpc> dancor: why not flip the comparitors?
15:03:49 <dancor> ah
15:04:01 <litb> ah so   (->) e  is an instance of  Num so this works
15:04:07 <dancor> :t comparing snd
15:04:08 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
15:04:12 <dancor> :t flip $ comparing snd
15:04:13 <lambdabot> forall a b. (Ord b) => (a, b) -> (a, b) -> Ordering
15:04:15 <hpc> litb: (a -> e), but yeah
15:04:46 <litb> ah
15:04:53 <hpc> instance Num a => Num (a -> e) where fromIntegral = const
15:04:55 <hpc> etc etc
15:05:24 <litb> a -> e   seems to be also a monad?
15:05:28 <hpc> yep
15:05:35 <hpc> > do 5; 4; 3
15:05:36 <lambdabot>   No instances for (GHC.Num.Num (m a),
15:05:36 <lambdabot>                    GHC.Num.Num (m a1),...
15:05:40 <hpc> > do 5; 4; 3 :: Int
15:05:41 <lambdabot>   Couldn't match expected type `m b'
15:05:41 <lambdabot>         against inferred type `GHC.Types...
15:05:48 <hpc> > 5 >> 3
15:05:49 <lambdabot>   No instances for (GHC.Num.Num (m a), GHC.Num.Num (m b))
15:05:49 <lambdabot>    arising from a u...
15:05:51 <hpc> pah
15:05:52 <litb> @src Monad
15:05:52 <lambdabot> class  Monad m  where
15:05:52 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
15:05:52 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
15:05:52 <lambdabot>     return      :: a -> m a
15:05:53 <lambdabot>     fail        :: String -> m a
15:06:02 <litb> hmm  it only supplies one type argument to "m"
15:06:14 <hpc> ((->) e) is the monad
15:06:19 * hackagebot statistics 0.8.0.4 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.8.0.4 (BryanOSullivan)
15:06:25 <litb> ah i see
15:07:53 <litb> but if i do    x <- (+)  the monad seems to be   (->)   needing two type arguments -.- but "m a" only supplies one
15:08:06 <litb> confusing
15:08:30 <hpc> :t do {x <- (+); return x}
15:08:31 <lambdabot> forall a. (Num a) => a -> a -> a
15:09:17 <litb> ohh i see now. i confused it with value arguments
15:10:20 <hpc> :t do {(+); return ()}
15:10:21 <lambdabot> forall a. (Num a) => a -> ()
15:11:26 <litb> oO
15:11:35 <ion> vizard: http://hpaste.org/41719/currying_example
15:13:12 <romildo> Isn't there a stripSuffix, similar to stripPrefix, in the standard library?
15:13:14 <ion> vizard: In that example, plus 3 returns the function (\b -> 3 + b), so (plus 3) 4, which is the same as just plus 3 4, results in 3 + 4.
15:13:41 <Vizard> got it :)
15:14:21 <Vizard> why hpaste suggest that lambda should be avoided ?
15:15:01 <hpc> because it's trivial to make pointfree
15:15:07 <Vizard> is it not good practice ?
15:15:13 <Vizard> ok
15:15:17 <ion> It just says \a -> (\b -> a + b) is the same as just (+), so if that were real code and not an illustrative example, might as well use (+) instead.
15:15:33 <hpc> haskell is expressive enough that lambdas are rarely necessary
15:16:16 <ion> Just like (plus 3) 4 isn’t something you’d want to write in real code.
15:16:36 <Vizard> ok
15:16:43 <osfameron> sometimes lambda is easier to read...
15:17:03 <hpc> i doubt hpaste can detect those situations
15:17:32 <hpc> (as in, notice and know how to remove the lambda)
15:17:48 <napping> as a rule, if the variable is used more than once, or there is more than one variable, it's probably cleaner to use the lambda
15:18:00 <aavogt> romildo: that doesn't seem to be the case. But it's easy enough to write in terms of reverse and stripPrefix
15:18:12 <napping> unless it's just eta: (\x -> myfun x) is almost always a bad idea
15:19:12 <osfameron> well, (\some_descriptive_parameter -> myfun some_descriptive_parameter) might make more sense
15:19:15 <osfameron> but yes
15:19:27 <danharaj> why?
15:19:30 <blackdog> in which case myfun might be better named:)
15:19:38 <osfameron> heh, true
15:19:47 <danharaj> the parameter's purpose should be evident from the function name and the type of the parameter
15:20:16 <Vizard> interesting read from expirienced people :) i use alot lambda in python with filter or map
15:20:43 <mee> Bikeshed Q: What's the conventional/idiomatic way to write something like:  case (a,b) of { (x,y) *or* (y,x) -> f1; } ?
15:20:52 <hpc> python's lambdas are a horrid vestige of what a real lambda can be
15:21:00 <ion> indeed
15:21:04 <aavogt> mee: or patterns
15:21:05 <napping> mee: dunno, that's one of the nice things in ocaml
15:21:31 <napping> I don't think Haskell has that sort of or-pattern
15:21:38 <monochrom> I would write the undesired { (x,y) -> f1; (y,x) -> f1 }
15:21:54 <ion> But the equivalent python lambda expression: (lambda a: lambda b: a + b) (3) (4)
15:22:20 <aavogt> napping: you can with ghc-7's template-haskell
15:22:35 <ion> If python did haskell-style currying in function calls, f (3) (4) would be equivalent to f (3, 4). But it doesn’t.
15:22:45 <napping> and abstract as { C1 x y -> f1 x y; C2 y x  -> f1 y x } where f1 x y = ..., if the size is really objectionable 
15:23:01 <osfameron> ion: yes, but python and most similar languages have functions that accept multiple parameters
15:23:02 <napping> actually, if it's just about commutativity, sometimes it makes sense to recurse on the swapped pair
15:23:05 <osfameron> so you wouldn't write it like that
15:23:29 <ion> Yes, just illustrating currying in terms of python syntax. :-)
15:23:34 <napping> Vizard: I think the most important thing about lambdas is just that you figure out what you like
15:23:54 <napping> Vizard: and what makes it convenient enough that you are not discouraged from using higher order functions by the syntactic cost
15:23:56 <osfameron> though I have a perl extension somewhere to do auto-currying...
15:24:55 <monochrom> javascript supports higher-order functions too but there is just too much "function" "()" "return" to type in.
15:25:28 * hackagebot bktrees 0.3.1 - A set data structure with approximate searching  http://hackage.haskell.org/package/bktrees-0.3.1 (JosefSvenningsson)
15:25:43 <monochrom> interesting, approximate searching
15:26:19 <osfameron> monochrom: did you see piers's slides on higher order javascript?  he was recommending a preprocessor "coffeescript" on the basis that the default syntax was too unwieldy
15:26:24 <ion> The Prelude curry/uncurry functions are perhaps named in a bit unclear fashion, since currying is a larger concept than converting between f (a,b) and f a b style functions.
15:26:55 <ion> s/unclear/confusing/
15:27:00 <monochrom> I haven't seen it. But I will invent something greater some day. It will be dependently typed javascript.
15:27:28 <ion> Meh, let’s just make browsers run Haskell. :-)
15:27:50 <osfameron> http://jashkenas.github.com/coffee-script/ # square = (x) -> x * x
15:27:52 <ion> I’m sure Microsoft™ woudl be happy to implement that in IE.
15:28:07 <osfameron> which compiles to square = function(x) { return x * x; };
15:28:29 <osfameron> doesn't one of the haskell compilers already have a javascript backend?
15:28:38 <onteria|i7> heck, let's make the whole browser in haskell while we're at it
15:28:41 <monochrom> "darjeeling script" may be a good name for mine.
15:28:53 <ion> Let’s make the whole INTERNETS in Haskell!
15:28:58 <blackdog> osfameron: there's a ghc backend, and uhc had one too
15:29:02 <napping> Vizard: It sounds like you are recently starting Haskell. I wonder what things people are reading to get started today?
15:29:02 <hpc> onteria|i7: alias 'firefox'='mueval' :P
15:29:40 <napping> monochrom: have you read that dynamic policy stuff from Ur?
15:29:41 <onteria|i7> hpc: let me just open up my .bashrc
15:30:22 <Vizard> napping: i read learnyouahaskell.com and "The Haskell Road To Logic, Math and Programming"
15:30:37 <monochrom> no.
15:30:45 <onteria|i7> I remember seeing something on twitter about a multi-threaded download manager in haskell or something like that
15:30:57 <Vizard> yes i just started, i alwys wanted to learn haskell
15:30:58 <onteria|i7> no code for it though, just screenshots
15:32:18 <onteria|i7> I started out on the Channel 9 haskell vids. Thought it did a nice job of really breaking everything down.
15:32:33 <Vizard> i found "the craft of functional programming" not that good
15:32:56 <napping> Vizard: it's been a while since I was starting. I think I mostly read the "Gentle Introduction" and papers and things
15:33:30 <napping> learnyouahaskell hadn't been written yet.
15:33:40 <CalJohn> if you live near an academic library, Richard Birds book is a good way to learn functional programming
15:33:49 <ion> onteria: Channel 9 Haskell videos, huh? Thanks for the pointer, hadn’t noticed them.
15:33:57 <Vizard> channel 9 seems interestin ty onteria|i7
15:34:30 <monochrom> I read the gentle introduction, then wadler's monad lectures, then the monadic parser combinator thing. Then I understood monads. Proves my conjecture "the 3rd tutorial you read is the best".
15:34:48 <CalJohn> wadler's monad lectures?
15:34:48 * copumpkin just abused #haskell to learn
15:34:51 <napping> If yourg0t_ (Ping timeout: 255 seconds)
16:12:05 <ivanm> lispy: I just did a "cabal unpack darcs", and ran SourceGraph on it
16:12:16 <ivanm> seems to have worked, but I've got to work out why there's so much red...
16:12:36 <lispy> ivanm: oh cool
16:12:45 <lispy> ivanm: on ghc6?
16:12:58 <lispy> I wonder if I should reinstall my ghc
16:13:11 <ivanm> yeah; haven't bothered to install 7 yet
16:13:18 <ivanm> I'm uploading the result now so you can see it
16:13:49 <lispy> It's weird that it tries to install haskell98 and I already have haskell98, even the same version it wants to build
16:14:13 <ivanm> lispy: does "ghc-pkg check" bitch? how about doing a "ghc-pkg recache" and seeing if that fixes it?
16:14:13 <aavogt> perhaps the version you have is broken?
16:15:42 <lispy> It keeps trying to rebuild process-1.0.1.4 even though I have that installed
16:16:08 <lispy> It's in the middle of a build so I can do the pkg check just yet
16:17:05 <ivanm> lispy: http://code.haskell.org/~ivanm/darcsSourceGraph/darcs.html
16:17:44 <ivanm> I'm not sure if there's so much red because a) that's stuff that's exported as the library but not used in the executable, or b) it silently failed trying to parse a module which actually used that stuff
16:18:00 <ivanm> does darcs use any pre-processors, TH, etc.?
16:18:11 <lispy> ivanm: CPP is used extensively
16:18:17 <lispy> No TH
16:18:23 <ivanm> then yeah; it can't cope with CPP yet
16:18:44 <ivanm> to do so requires me to fix up my cabal support to be able to specify/get flags, and then use them with cpphs
16:19:08 <ivanm> *sigh* it isn't like I don't have enough projects to hack on...
16:20:10 <ivanm> and someone was asking about getting one of their students to adapt the call-graph parsing part of SourceGraph for their own project, so I was kinda hoping I could get foist that off onto them... :p
16:22:33 <lispy> ivanm: I don't know the answer to the question you asked me in email about SourceGraph :(
16:22:54 <ivanm> heh, fair enough
16:23:05 <ivanm> if you don't get what I mean, see the SG report on itself
16:23:19 <ivanm> there's a _huge_ line there (width of 32 IIRC)
16:25:01 * hackagebot NXT 0.1.4 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1.4 (MitarMilutinovic)
16:29:28 <ivanm> how does one get the new stylesheets, etc. with haddock?
16:31:07 <dabblego> I cabal install haddock and got them already
16:31:30 <Mitar> where i namespace should i put my data-flow framework?
16:31:39 <ezyang> Data.Flow? 
16:31:40 <Mitar> control? data?
16:31:43 <Mitar> hmm ;-)
16:31:52 <Mitar> control.data.flow?
16:31:58 <byorgey> I think Data ought to be for data structures
16:32:05 <byorgey> Or maybe just Control.Dataflow =)
16:32:14 <byorgey> or maybe DataFlow
16:32:24 <Mitar> it is not really general data flow thing, more my approach to it
16:32:44 <byorgey> that's fine.
16:32:59 <Mitar> so i see data.flow to "official" for that
16:33:12 <Mitar> but control.* is already quite polluted
16:33:44 <Mitar> maybe i could do new top category
16:33:49 <Mitar> DataFlow.MyDataFlow ;-)
16:34:15 <byorgey> that's I would think Data.Flow would be a module about a new kind of data structure called a Flow
16:34:22 <byorgey> s/that's//
16:34:31 <hpc> i get the impression that Control was meant to be entirely for typeclasses
16:34:32 <lars9> omg, this pic... http://i.imgur.com/SwkCP.png
16:35:03 <ezyang> "we have that, it's unsafePerformIO"... 
16:35:49 <ivanm> dabblego: *sigh* just realised that for some reason cabal-install is using ghc's haddock instead of the new one I just built :s
16:36:09 <Mitar> ivanm: restart your bash session ;-)
16:36:15 <ivanm> (despite the newer one being first in the path)
16:36:24 <ivanm> Mitar: what good would that do?
16:36:39 <ivanm> hpc: well, it's for things that affect program control
16:36:49 <Mitar> it will clear its cache
16:37:18 <Mitar> i had the same problem, which haddock pointed me to new version, but haddock --version was still running the old version
16:37:28 <osfameron> ok, I'm asking on #coffeescript if they'd accept a syntax for currying partial application
16:37:31 <osfameron> they're asking for a use-case
16:37:33 <Mitar> after i made a new bash session things worked as expected
16:37:41 <osfameron> beyond "sum = reduce add"
16:37:41 <monochrom> Control ends up being "computation" e.g. "monad as computation" so monad goes to Control.
16:37:44 <ivanm> I started a new bash session; didn't seem to do anything
16:37:50 <hpc> osfameron: slap them silly
16:37:52 <osfameron> any suggestions?  (relevant to a javascript programmer)
16:38:02 <byorgey> osfameron: does it have higer-order functions?
16:38:03 <osfameron> their syntax is already so close it seems silly *not* to have it
16:38:07 <osfameron> byorgey: yes
16:38:12 <osfameron> javscript is practically lisp
16:38:21 <kmc> sumSquares = sum . map (^2)
16:38:24 <osfameron> and with coffeescript it has really convenient syntax for currying, almost
16:38:28 <kmc> that's three partial applications
16:38:37 <osfameron> e.g.:  add = (x)->(y)-> x + y
16:38:38 <hpc> osfameron: here's a good one, actually
16:38:56 <osfameron> but then you have to:  alert (add 5) 4    # e.g. note the parens
16:39:00 <hpc> wrap before after mid = do print before; mid; print after
16:39:10 <hpc> then html = wrap "<html>" "</html>"
16:39:14 <hpc> etc for all the good tags
16:39:17 <ivanm> Mitar: looks like I had to reconfigure it... :s
16:39:18 <osfameron> hpc: yay, thanks
16:39:24 <Mitar> aha
16:39:25 <hpc> then to build a page
16:39:32 <hpc> main = html . body $ contents
16:39:48 <hpc> auto-closing tags ftw
16:41:23 <hpc> (technically, that is an example of point-free sanm> mm_freak: this is the main module anyway: http://code.haskell.org/~ivanm/wl-pprint-text/Text/PrettyPrint/Leijen/Text/Lazy.hs
19:53:03 <kmc> unsafe import as an alternative to defining a new ghc primop
19:53:05 <kmc> makes sense to me
19:53:18 <lispy> dmwit: er, my point is that I think you have to provide a proof of why it's safe.  Just like how unsafePerformIO is not safe a priori in haskell.
19:53:31 <dmwit> Well, of course.
19:54:02 <c_wraith> what's the implementation of unsafeInterleaveIO?  return . unsafePerformIO?
19:54:44 <dmwit> http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/GHC-IO.html#unsafeInterleaveIO
19:54:47 <lispy> c_wraith: IIRC, yes
19:55:02 <c_wraith> ah.  right.  those frightening primitives
19:55:29 <c_wraith> that looks a lot like bytestring's implementation of inlinePerformIO
19:55:29 <kmc> c_wraith, that's supposed to be a faithful implementation, but not actually what GHC does
19:56:36 <c_wraith> Hmm.  Does the noDuplicate stuff actually work in the threaded runtime?
19:58:23 <kmc> good question
19:58:43 <kmc> i was under the impression that there's a short race period between entering a thunk and blackholing it
19:58:55 <kmc> which would normally result only in wasted effort
19:59:12 <kmc> my guess is that noDuplicate# explicitly adds the locking to prevent that
20:08:10 * hackagebot nano-cryptr 0.1.1 - A threadsafe binding to glibc's crypt_r function  http://hackage.haskell.org/package/nano-cryptr-0.1.1 (CarlHowells)
20:08:43 <c_wraith> Oh, I think I failed to follow the package versioning policy there.  Should have been 0.1.0.1.  Oops.
20:10:13 <ivanm> c_wraith: :o how could you?!?!??!? :o
20:10:21 <ivanm> not that it makes that much of a difference...
20:10:38 <c_wraith> well.  a minor version bump suggest an API addition
20:10:42 <ivanm> yeah
20:10:43 <dino-> c_wraith: Could issue another update to fix version.
20:10:45 <onteria> hmm.. my twitter #haskell search is being invaded by scalaz talk
20:10:54 <c_wraith> dino-, you can't really issue a previous release number
20:10:58 <ivanm> but it's nowhere near as bad as doing a minor version bump when you did an API change
20:11:00 <c_wraith> You can, but hackage ignores it
20:11:09 <dino-> Oh, yeah, that's less than. bleh
20:11:11 <ivanm> c_wraith: well, it will be there but who looks at _old_ versions?
20:11:24 <dabblego> onteria, I don't use twitter so I don't know what that means, but I author scalaz
20:11:50 <xmonad-user> where does xfork live? Trying to install xmonad from darcs sources and compile fails because this function is missing
20:12:03 <onteria> dabblego:  wow, this channel really DOES have everything
20:12:23 <xmonad-user> maybe I shoulda used xmonad chan ;)
20:12:47 <onteria> dabblego:  You can setup saved searches for certain keywords (in my case the haskell tag) and I notice that searches for haskell related tweets are showing a lot of scalaz related content lately
20:13:39 <dabblego> onteria, that doesn't surprise me
20:14:30 <dabblego> @hoogle parElem
20:14:30 <lambdabot> No results found
20:14:43 <dabblego> I was totally not expecting that!
20:14:55 <dabblego> @hoogle parMap
20:14:55 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
20:16:06 <dmwit> Have you really got an expensive enough (==) operation that parElem would be worth all the sparking overhead?
20:16:25 <dmwit> Remember that traversing the spine of a linked list must be done sequentially, so all you can spark is the actual comparison...
20:17:11 <dino-> c_wraith, ivanm: I've been using something sort of like this lately, where you start at 1.0.0.0 and it means "version 1.0, alpha, release 0": http://en.wikipedia.org/wiki/Version_number#Designating_development_stage
20:17:24 <ivanm> @where PVP
20:17:25 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
20:17:30 <ivanm> dino-: ^^ that's the official policy
20:17:55 <dino-> Long had this feeling that the 0.x... is artificial. What happens when you're working on v 2.x and can't use the zero anymore for pre-release?
20:18:14 <dino-> So, that moves the alpha, beta, etc into the 3rd pos.
20:18:16 <ivanm> huh?
20:18:38 <ivanm> <major>.<major>.<minor>.<patch>
20:18:45 <dino-> Different than that.
20:18:55 <ivanm> that's the official haskell package versioning policy
20:19:10 <hiredman> <major>.<major>.<major>.<minor>.<patch>
20:19:15 <hiredman> more major
20:19:26 <dmwit> alt.swedish.chef.bork.bork.bork
20:19:28 <dino-> Running up to 1.x we did numbers like 0.4.2 and 0.9.7 right?
20:19:35 <dabblego> no I don't want parElem
20:19:39 <ivanm> bumping the first major typically denotes some kind of major rewrite; the second major indicates backwards-incompatible changes; the minor version denotes additions/extensions to the API (so if it works with x.y.z it should also work with x.y.z+1) and the patch denotes bug fixes that don't change the API
20:19:42 <dino-> Ok, so now we've released and even patched a little, great we're at v1.4.0
20:19:54 <dino-> How do we number the "alpha" up to 2.x now?
20:19:56 <ivanm> dabblego: huh?
20:20:15 <ivanm> dilinger: if you really want to denote an "alpha", something like 1.9999 or something
20:20:17 <dmwit> ivanm: He's continuing a somewhat old conversation, don't worry baout it. ;-)
20:20:17 <ivanm> that's what darcs does
20:20:19 <dabblego> I wish to intersect two Set String, but I was going to use a Trie
20:20:22 <ivanm> dmarker: ahhh
20:20:51 <dilinger> ivanm: ?
20:21:00 <dilinger> oh, not me
20:21:05 <ivanm> dilinger: sorry, should have been dino
20:21:07 <dmwit> ivanm is mis-tabbing all over the place =P
20:21:13 <ivanm> I'm not used to quassel's nick-completion
20:21:25 <ivanm> and I don't have xchat on this machine...
20:21:41 <djahandarie> I wish there was something more than the PVP to ensure packages don't break across versions.
20:21:50 <ivanm> djahandarie: what do you mean?
20:21:52 <djahandarie> Since when did Haskellers depend on the programmer to do anything right? :)
20:22:16 <ivanm> there has been talk about writing a tool to verify the PVP, but no-ones really bothered to sit down and write a thorough one yet
20:22:34 <dmwit> Not to mention it's an undecidable problem.
20:22:36 <holmak> I'm hoping Hackage 2.0 will at least verify that the packages build on the latest GHC
20:22:39 <dmwit> Thank you, Rice's Theorem.
20:23:13 <ivanm> holmak: how doesn't the current hackage do that?
20:23:16 <dabblego> I uploaded a package earlier and it failed because it depends on category-extras
20:23:24 <ivanm> (though unless told otehrwise it will only check new uploads)
20:23:31 <ivanm> dabblego: ahh, dep issues
20:23:33 <djahandarie> dmwit, it doesn't need to be perfect by any means. It's just, the more checking the better
20:23:53 <djahandarie> I haven't really thought about this but I'm sure there is some way to partially verify this stuff
20:24:34 <ivanm> djahandarie: I was thinking of doing something like this way back, but realised that for cases where the programmer doesn't write type sigs you have to have a type checker, and that sounded like too much effort (even if I was to try and use ghc-lib)
20:25:10 <Gracenotes> are there any hackage packages involving go?
20:25:27 <ivanm> @hackage wyvern
20:25:27 <lambdabot> http://hackage.haskell.org/package/wyvern
20:25:32 <lispy> Gracenotes: hmm...I haven't seen any
20:25:34 <Gracenotes> yeah that's all I'm founding
20:25:36 <Gracenotes> finding
20:25:41 <Gracenotes> which seems network-protocol-ish
20:25:46 <lispy> Well, I'll be an uncle's monkey...
20:26:10 <Gracenotes> oh there's dgs which is depends on... and sgf
20:26:31 <Gracenotes> which dmwit wrote :)
20:27:14 <Gracenotes> I'm wondering, since I believe I have access to a cray supercomputer, if I can get haskell running on it.. doing monte carlo Go AI...
20:27:57 <Gracenotes> but there are pretty much no open source monte carlo Go AIs and I'm probably not the person to write it
20:28:13 <kadoban> Gracenotes: yeah, i think they're all closed source...and probably not in haskell
20:28:31 <Gracenotes> yeah, they're not
20:28:43 <kadoban> last i checked, there wasn't even much info on exactly how they work, like mogo or whatever that one is :(
20:29:06 <lispy> Gracenotes: monte carlo webscale?
20:29:15 <lispy> Gracenotes: verb missing: is
20:29:39 <Gracenotes> kadoban: mogo just has an executable and data to train it
20:29:58 <kadoban> yeah
20:30:01 <Gracenotes> I'm looking at a paper by the people who wrote gobble, a somewhat weak one, may I have a chance of getting the source..
20:30:32 <kadoban> ya, i've been semi-waiting for someone to do some open source stuff based on that idea, too lazy to do it myself
20:30:33 <dino-> About the version numbering, non-standard-ish but it made a lot of sense to me: http://en.wikipedia.org/wiki/Version_number#Designating_development_stage
20:30:52 <Gracenotes> lispy: webscale?
20:31:09 <Gracenotes> yeah, I swore I wouldn't get involved with computer go, but it would be tempting if I could adapt others' code
20:31:52 <ivanm> *sigh* haddock doesn't like my code example :(
20:32:27 <lispy> Gracenotes: Sorry bad joke making fun of NoSQL crowd
20:32:46 <lispy> Gracenotes: (but if your monte carlo algorithm is not webscale, we could try adding sharding ... )
20:33:19 <djahandarie> Gracenotes, http://nosql.mypopescu.com/post/1016320617/mongodb-is-web-scale
20:33:43 <Gracenotes> you have a link, but there is no computer go source code o_o
20:34:08 <dabblego> dmwit, I think I want parFilter
20:35:58 <dmwit> Gracenotes: Yeah, there's nothing particularly useful on Hackage just now in terms of computer go engines.
20:36:10 <BeginnerHakell> Hello Haskell, I'm trying to do a KenKen puzzle in Haskell. Can anyone help me?
20:36:39 <dmwit> BeginnerHakell: Definitely not with that description. =)
20:36:42 <Gracenotes> or evidently on the internet
20:36:59 <dmwit> Well, there's GnuGo if you don't mind C, yeah?
20:37:12 <onteria> I thought there was some python go engine somewhere
20:37:12 <dmwit> And there are some computer-go mailing lists; you might ask on there.
20:37:15 <Gracenotes> mostly I just want a fun program I can make embarrassingly parallel and run it fast
20:37:19 <BeginnerHakell> dmwit: Would you like me to paste you the link?
20:37:28 <Gracenotes> monte carlo AI falls under that
20:37:35 <dmwit> BeginnerHakell: If you have a more focused question, perhaps that would be a good start.
20:37:39 <Gracenotes> to some extent
20:38:01 <dmwit> BeginnerHakell: We're cool with answering questions about Haskell, but we're not so cool with doing other people's work in Haskell just because we like the language so much. ;-)
20:38:31 <onteria> The "Give a man a fish, feed him for a day. Teach a man to fish, feed him for a lifetime." policy
20:38:40 <BeginnerHakell> dmwit: I have this  applyOp :: Op -> CellList -> CellValue  and     applyOp op cells = ?
20:39:04 <Gracenotes> wat
20:39:32 <BeginnerHakell> Ok that's fine, I'm trying to figure out how to do some of this
20:39:35 <Gracenotes> I think people have attempted to parallelize GnuGo -- SlugGo -- but that seems dead, both in terms of development and usefulness of approach
20:39:51 <debblego> <_<
20:40:39 <Gracenotes> now where did copumpykins run off to
20:41:07 <BeginnerHakell> applyOp is suppose to take an operation and all the value in the list must equal the operation value
20:41:08 <debblego> ssh, I'm hunting dobblegos
20:41:29 <dobblego> can I parallelise: \as s -> filter (`member` s) as using parFilter s p x = filter p x `using` parList s ?
20:41:41 <Gracenotes> ooooh... http://senseis.xmp.net/?Fuego
20:41:47 <Gracenotes> yes yes yes yes
20:42:28 <mtnviewmark> somehow I should have known that the intersection of Haskell programmers and Go players would be a higher than average percentage of any such intersection
20:43:16 <mtnviewmark> I've played Go for years - and programmed for years (actually, I think I learned both in the same year) -- but oddly, have no interest in programming Go playing programs....
20:43:21 <dmwit> Wow! 2k is quite good
20:43:37 <lispy> mtnviewmark: nah, we're too busy enjoying the fun of programming to breaks for games :)
20:43:40 <dmwit> I was under the impression that 1k on 9x9 was about the best you could hope for, and that 19x19 games were hopelessly weaker.
20:43:41 <kadoban> yeah, pretty much same mtnviewmark...it just seems like such an annoying problem
20:43:42 <mtnviewmark> I have written Go utilities and and fully automated goban and go center
20:44:09 <Gracenotes> mtnviewmark: yeah.. I'm not into AI at all.. but if I can throw 40 cores at it, it should be fun to see what comes out
20:44:17 <mtnviewmark> heh
20:44:38 <dmwit> BeginnerHakell: In case you think you've asked a good question, let me prompt you to give a bit more background, plus explicitly say what it is you've done and what you wish you were able to do.
20:44:56 <mtnviewmark> at the other extreme of programming from Haskell, I'm the author of the Go Center in Second Life - an automated Go board and club written in Second Life
20:44:58 <Gracenotes> okay, fuego looks like a good candidate, C++ though
20:45:18 <dmwit> BeginnerHakell: As it is, I want to help you, but I'm not really sure how. =)
20:45:42 <debblego> the nick alone makes the OCD parts of me twitch
20:46:10 <BeginnerHakell> I try to do this for applyOp   applyOp op cells = foldl1 op cells     but it will give an error message
20:46:14 * bbdeeglo stops twitching
20:46:21 <debblego> :O
20:46:42 <BeginnerHakell> This is the message: Couldn't match expected type `a -> a -> a'            against inferred type `Op' 
20:46:53 <dubblego> codobblego: I am twice the man you are!
20:47:05 <gobbledygook> Prepare for Thanksgiving! gobble gobble
20:47:12 <dubblego> oh god
20:47:27 <ivanm> you lot had enough yet?
20:47:30 <mtnviewmark> what is the type Op?
20:47:35 <copumpkin> anyone have any thanksgiving haskell projects?
20:47:49 <ivanm> doesn't apply here!
20:48:00 <copumpkin> BeginnerHakell: you want to translate your Op to a function
20:48:05 <mtnviewmark> copumpkin - I think I have three.....
20:48:14 <copumpkin> something like sem Plus = (+); sem Times = (*)
20:48:19 <copumpkin> then foldl1 (sem op) cells
20:48:25 <copumpkin> I'm assuming, knowing nothing about your code
20:48:35 <osaunders> copumpkin: What is a thanksgiving Haskell project?
20:48:45 <copumpkin> osaunders: I dunno, ask mtnviewmark 
20:49:54 <ivanm> osaunders: presumably a project to do over the thanksgiving long weekend I'm assuming is soon going to be celebrated in the USA
20:49:55 <BeginnerHakell> copumpkin: I have something like that in my code
20:50:17 <mtnviewmark> I wuz guessin' a project in Haskell that you want to get done over Thanksgiving... ya know, while the rest of your relatives are in a tryptophan induced stupor, watching professional sports, you'll be in the corner with your laptop decoding cryptic error messages from GHC
20:50:43 <copumpkin> BeginnerHakell: then use it!
20:51:10 <osaunders> mtnviewmark: Read papers.
20:51:15 <osaunders> I have a backlog of papers to read.
20:52:07 <BeginnerHakell> copumkin : I have this also   data Op        = Add | Subtract | Multiply | Divide deriving (Show, Eq) and I define these operations already
20:53:11 <mtnviewmark> BeginnerHaskell: do you have a function with signature:    Op -> CellValue -> CellValue -> CellValue  ?
20:56:08 <BeginnerHakell> mtviewmark: I have this    applyOp :: Op -> CellList -> CellValue
20:56:19 <BeginnerHakell> is that what u r talking about
20:56:20 <BeginnerHakell> ?
20:56:45 <copumpkin> that's not enough
20:57:04 <copumpkin> oh I guess it is
20:57:25 <copumpkin> oh wait that's the function that's missing
20:59:28 <BeginnerHakell> Here was my guess again:   applyOp :: Op -> CellList -> CellValue applyOp op cells = foldl1 op cells
21:00:30 <copumpkin> the word "guess" there worries me
21:00:46 <copumpkin> did you paste your code?
21:04:48 <BeginnerHakell> copumpkin:  to the http://haskell.org   ???
21:04:58 <copumpkin> http://hpaste.org
21:05:00 <onteria> Looking at getting "Fifteen years of functional pearls" by Richard Bird. Worth the purchase?
21:05:11 <c_wraith> I bought his recent book, and like it.
21:05:19 <c_wraith> his newest book, in fact
21:05:25 * hackagebot gloss 1.2.0.0 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.2.0.0 (BenLippmeier)
21:06:25 * hackagebot gloss-examples 1.2.0.0 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.2.0.0 (BenLippmeier)
21:08:25 <BeginnerHakell> copumpkin:  http://hpaste.org/41728/kenken
21:08:39 <BeginnerHakell> sorry its so long
21:10:26 <copumpkin> there
21:10:27 <copumpkin> opFn
21:10:27 <dmwit> opFn looks just like the "sem" function that copumpkin was suggesting.
21:10:41 <copumpkin> and idElt would allow you to avoid the foldl1
21:13:03 <BeginnerHakell> I have not learned idElt
21:13:14 <copumpkin> I mean
21:13:23 <copumpkin> it's about 20 characters long
21:13:29 <BeginnerHakell> o I what u mean haha
21:13:41 <BeginnerHakell> i c what u mean *
21:18:34 <BeginnerHakell> I'm trying to figure out how to test this:   applyOp op cells = idElt op 
21:18:57 <copumpkin> that is not correct
21:18:57 <dmwit> Have you used ghci before?
21:18:58 <BeginnerHakell> I run this: applyOp (+) [3,4] 
21:19:16 <copumpkin> nope
21:19:27 <copumpkin> applyOp Add [3,4]
21:19:29 <dmwit> copumpkin: Well, the former is type-correct, anyway. =P
21:19:57 <copumpkin> BeginnerHakell: maybe you should try something more basic before tackling this problem?
21:20:15 <BeginnerHakell> I have to do this one
21:20:53 * mee throws an S at BeginnerHakell
21:21:16 * dmwit catches it
21:22:08 <BeginnerHakell> I have to go now, but I will come back later thank you copumpkin and dmwit
21:22:14 <BeginnerHakell> :-)
21:22:18 <copumpkin> BeginnerHakell: good luck! :)
21:22:36 <copumpkin> BeginnerHakell: even if your assignment doesn't make you do simpler things, you might want to do them just for your own preparation, so things like this will be easier to you later
21:23:00 <BeginnerHakell> okay thank you
21:23:01 <dobblego> is there ignore :: m a -> m () so that I don't get a warning about discarding a result in do-notation?
21:23:23 <dmwitS> No, but you can "_ <- foo".
21:23:35 <dmwitS> And many people write their own ignore for this reason (and others).
21:24:15 <jmcarthur> dobblego: the error message informs you of two ways to fix it (change the code or use a flag, which is gives you)
21:24:20 <jmcarthur> *which it
21:24:25 <jmcarthur> -fno-warn-unused-do-bind
21:24:31 * hackagebot gloss 1.2.0.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.2.0.1 (BenLippmeier)
21:24:43 <dobblego> jmcarthur, yes, thanks
21:25:00 <jmcarthur> i would like to see an ignore function though
21:25:16 <jmcarthur> i thought there was a proposal for something like that somewhere
21:25:33 * hackagebot gloss-examples 1.2.0.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.2.0.1 (BenLippmeier)
21:26:51 <copumpkin> I vaguely reember one too
21:32:26 * mee takes his S back :[
21:34:41 <dmwit> heh
21:52:59 <nejucomo> If I say:  f = do { x }  -then must x have the same type as f ?
21:54:20 <nejucomo> Ah, that would make sense.
21:54:41 <Cale> nejucomo: yes
21:55:02 <Cale> do { x } is always equal to x
22:10:46 <lispy> Cale: The proof would be a trivial one based on the transformation of do-notation to haskell syntax?
22:12:07 <c_wraith> > do 5
22:12:08 <lambdabot>   5
22:12:24 <c_wraith> > do f
22:12:26 <lambdabot>   Ambiguous type variable `a' in the constraints:
22:12:26 <lambdabot>    `SimpleReflect.FromExpr ...
22:12:30 <c_wraith> > do f :: Expr
22:12:31 <lambdabot>   f
22:12:48 <c_wraith> :t \a -> do a
22:12:49 <lambdabot> forall t. t -> t
22:12:55 <lispy> :t do 5
22:12:56 <lambdabot> forall t. (Num t) => t
22:14:26 <kmc> > do ()
22:14:26 <lambdabot>   ()
22:14:30 <kmc> :t do ()
22:14:31 <lambdabot> ()
22:18:42 <kmc> > do 2 + do 3
22:18:42 <lambdabot>   5
22:19:25 <duaneb> hi guys
22:20:29 <duaneb> here's something  I really hate to think about in haskell, but is there any way to have a type-agnostic list?
22:20:36 <duaneb> or a variable-length tuple?
22:20:41 <duaneb> essentially the same thing
22:22:00 <apanda> duaneb: What are you trying to do with your type agnostic list? It doesn't really fit in with the model, and perhaps if we knew what you needed this for we could suggest alternates
22:22:06 <JoeyA> I think you want existential types
22:22:13 <duaneb> yea, it's really not haskellish at all
22:22:18 <duaneb> but it's for foreign functions
22:22:18 <kmc> duaneb, what good would a list be if you had no idea what type of stuff is inside?
22:22:27 <duaneb> kmc: talking to python :/
22:22:29 <kmc> what operation could you possibly perform on that value
22:22:44 <kmc> duaneb, «data PyVal = PyInt Integer | PyString String | ...»
22:22:47 <kmc> then you'd use [PyVal]
22:22:57 <duaneb> yea, I was thinking about that
22:23:05 <duaneb> and an opaque type, I guess
22:23:41 <kmc> why opaque / what do you mean by that?
22:24:04 <kmc> duaneb, so that's one option, and the cleanest fit with Haskell's type system
22:24:16 <duaneb> it's as I suspected!
22:24:20 <kmc> there's been a number of Haskell-Python bridge projects, so maybe you can find such a type already in existence
22:24:25 <duaneb> by opaque I mean a c pointer
22:24:29 <kmc> ok, sure
22:24:32 <duaneb> I couldn't find anything
22:24:35 <kmc> ... | Opaque (Ptr ())
22:25:22 <kmc> as JoeyA suggested you could also use an existential
22:25:29 <duaneb> no, I couldn't find anything on the haskell-python bridges
22:25:36 <kmc> i hesitate to give that answer right away as i think a simpler solution is often better
22:26:28 <duaneb> I do, too
22:31:38 <kmc> or you could use Data.Dynamic
22:38:14 <Cale> lispy: yes
22:41:01 <dmead> oh ho ho ho
22:42:54 <lispy> duaneb: HList
22:45:00 <lispy> duaneb: oh, actually I read the scroll back.  For what you're doing, you want to make a "universal" type in Haskell that represents the python values
22:45:20 <duaneb> yea
22:45:29 <duaneb> I've actually decided not to do the project at all :P
22:45:40 <lispy> heh
22:46:30 <lispy> Funny because I was trying to save my rant that needing heterogeneous lists usually indicates a bad design.  I hadn't even noticed the python mention :)
22:47:06 <lispy> (not implying python is the end of the world, simply that it's meant for very hackish things)
22:49:23 <lispy> I never really thought of [a] as being type 1/(1-a)
22:50:22 <lispy> if you had the equation, y = 1 / (1-x), it would have integer solutions y = 1, x = 0
22:50:43 <lispy> So then i was trying to think if that gives any new insight about the list type
22:50:50 <lispy> But, what type is 0?
22:50:56 <Cale> empty type
22:51:17 <lispy> so, in that case y is the unit type and x is void?
22:51:22 <Cale> yeah
22:52:00 <lispy> Hm...that makes sense but i'm not really seeing anything new in this equation
22:52:14 <Cale> Well, it tells you that the empty list exists, I guess.
22:52:31 <lispy> didn't I already assume that?
22:52:49 <Cale> Well, what are you trying to get from it?
22:52:58 <Cale> 1/(1-x) = 1 + x + x^2 + x^3 + ...
22:53:21 <Cale> (In the ring of formal power series)
22:53:39 <lispy> someone on list pointed out that [a] = 1 + a*[a], and someone pointed out that it would have solution [a] = 1/(1-a)
22:53:47 <Cale> yes
22:54:26 <lispy> So, what is the "solution" in this case?  Does that concept have some other name like a least fixed point?
22:55:20 <Cale> Well, it's sort of odd because 1-a isn't itself a meaningful type.
22:55:49 <lispy> yeah, negative types seem like imaginary quantities in this context
22:56:04 <lispy> They are solutions to equations but they have no representation themselves
22:56:53 <Cale> But an analogue to this occurs in combinatorics with generating series (or functions).
22:57:05 <lispy> hm...go on
22:57:12 <lispy> I'm unfamiliar with that
22:57:57 <Cale> Okay, so the basic idea of generating series is that in combinatorics there are lots of problems where we want to know how many things of a particular sort there are of a given 'size'.
22:58:20 <lispy> 1/(1-x) = 1 + x + x^2 + x^3 + ... ~= [] + a + (a,a) + (a,a,a) + ...
22:58:22 <Cale> So we have some set A together with a function w: A -> N (N being the natural numbers)
22:58:57 <Cale> and it can be assumed (usually) that for any n there are only finitely many elements a of A for which w(a) = n
22:59:09 <Cale> Right
22:59:15 <Cale> (the equation there)
23:00:01 <Cale> So, the ordinary generating series for A with respect to the weight w is the formal power series  sum over a in A of x^(w(a))
23:00:03 <lispy> does w have other properties, like bijective?
23:00:09 <lispy> Oh, wait that' sa silly example
23:00:11 <Cale> Not in general
23:00:30 <Cale> If w is a bijection, then there will be only one thing of each given weight.
23:00:47 <lispy> Yeah, I realized that bijection wouldn't work out well as soon as I said it :)
23:01:13 <Cale> Now, the coefficient of x^n in the generating series for A with respect to w is the number of elements of A whose weight is n.
23:01:41 <lispy> ah
23:01:49 <lispy> That's makes sense
23:01:51 <Cale> Disjoint union of subsets of some weighted set corresponds to addition of generating series
23:01:59 * lispy nods
23:02:56 <Cale> If we have weighted sets A, B, with weights u, v respectively, then we can form the Cartesian product AxB, and put the additive weight on it: w(x,y) = u(x) + v(y)
