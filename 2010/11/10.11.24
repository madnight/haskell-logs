00:00:03 <ski>   vEx :: Expr Integer  -- ?
00:00:10 <sinelaw> ski, automatically inferred
00:00:29 <sinelaw> i want vEx to have the type that it would have in 'b'
00:00:34 <ski> well, it infers that, more or less, by inferring a more general type
00:01:13 <ski> usually, the more polymorphism one gets, the better
00:01:32 <ski> i think you is the first one i can recall who has wanted less :)
00:01:37 <sinelaw> ski, not if i'm trying to decipher the types of an ESL expression
00:02:08 <sinelaw> ski, i agree in general, but here's a case where i want the type to be monomorphic
00:02:20 <sinelaw> or whatever word i should've said
00:02:40 <sinelaw> maybe instead of a let i can define a Monad
00:03:03 <ski> (re the MLs : in OCaml, and i think in some of the SML implementation, sometimes a definition can't be made polymorphic (because of interaction with side-effects), so then, what they do is infer a type like `Expr a', but `a' is *not* polymorphic, but is fixed by the *uses* of the value defined (and all those uses had better agree about the type))
00:03:06 <sinelaw> or any other structure for definitions
00:03:50 <sinelaw> ski, that's basically what I want, but of course i want to control like and get the usual haskell behavior elsewhere
00:04:14 <sinelaw> maybe i could have seomthing like
00:04:15 <ski> (so if it is used like in your `b', then `a' becomes `Integer', so the type is actually `Expr Integer')
00:04:38 <sinelaw> do; vEx <- define (VarExp v);  ... ; b <- define ... ;
00:04:39 <ski> sinelaw : you could mention this on one of the mailing lists ?
00:04:53 <sinelaw> ok, maybe i will.
00:04:55 <ski> yes, that could be a workaround
00:05:33 <sinelaw> ok, better go to work
00:05:33 <ski> (also, lambda-bound variables are monomorphic (unless you provide an explicit signature))
00:05:47 <sinelaw> ski, yes but what syntax will I have to eat for that
00:06:09 <sinelaw> in a way, the monad is the way to go
00:06:22 <sinelaw> since i'm trying to work out an imperative ESL anyway
00:06:55 <ski> *nod*
00:06:59 <sinelaw> ski, btw typeable helped me get what i want
00:07:11 <ski> (i was just mentioning lambda-bound for completeness)
00:07:13 <sinelaw> Variable "v" = (Literal 3, Literal 3)
00:07:29 <ski> ?
00:07:30 <sinelaw> and my type function prints: Exp<Tuple<Integer, Integer>>
00:07:59 <ski> .. and you needed to change the type of `Literal', yes ?
00:08:16 <sinelaw> the first is the _expression structure_ of the assignment
00:08:21 <sinelaw> the second is it's _type_
00:08:33 <sinelaw> (well, i don't really want assignments to have that type, but that's a different story)
00:09:37 <sinelaw> so in theory my code generator could transform "v <- define (Tuple Literal 3 Literal 3)" into: "Tuple<Integer,Integer> v = Tuple(3,3);"
00:09:40 <sinelaw> which is what i'm aiming at
00:09:59 <sinelaw> excluding pseudo-syntax
00:10:09 <ski> oh, you meant `Assignment (Variable "v") (Tuple (Literal 3) (Literal 3))'
00:10:14 <sinelaw> yes
00:10:23 <sinelaw> i just print out what my show does
00:10:35 <sinelaw> i mean, i was just showing that, nvm
00:10:45 <sinelaw> showing what show shows
00:10:46 <sinelaw> :)
00:10:48 <ski> imo, `show' should always give a valid Haskell expression
00:11:07 <sinelaw> fair enough, i can use a different type class / function
00:11:13 <c_wraith> ski: even for things that can only be created from IO?
00:11:22 <c_wraith> like, say an MVar?
00:11:26 <ski> i.e., if you want something else, define another function (like `displayExpr :: Expr a -> String', or something)
00:11:44 <ski> (and if you really need overloading, make your own type class)
00:12:05 <ski> c_wraith : those oughtn't have a `Show' instance
00:12:09 <sinelaw> ski, yeah. anyway, looks like i'm set to go on this. my aim is to generate a variety of imperative language syntaxes as output (c# , java, ...)
00:12:21 <sinelaw> something like AwesomePrelude but more simplistic
00:13:47 <wagle> haskell.org is /topic'd, long live haskell.org
00:14:40 <ski> sinelaw : ooi, how did you use `Typeable'
00:15:25 <sinelaw> ski, http://hpaste.org/41765/gadts_for_imperative_el
00:16:53 <ClaudiusMaximus> damn, firefox sucks :( error console say "too much recursion" :(
00:17:37 <ClaudiusMaximus> well, at least it goes up to 11 (but 12 is too much for it)
00:17:50 <ddarius> ClaudiusMaximus: You should use edwardk's JS to JS compiler written in JS that he never implemented because he found Haskell instead.
00:18:12 <Lycurgus> ClaudiusMaximus, on what platform?
00:18:21 <sinelaw> thanks for the help ski, gtg
00:18:31 <ski> ok
00:19:08 <ClaudiusMaximus> Lycurgus: gnu/linux/ubuntu/lucid/64bit
00:19:14 <Lycurgus> anyway it's open source so you could always ...
00:19:22 <ClaudiusMaximus> :)
00:20:43 * ddarius owes a woman some pictures.  I haven't talked to her in almost a year, but...
00:20:53 <Lycurgus> 64 bit config could be different from behavior elsewhere, but as I was saying it's open source so you could change it.
00:20:54 <kmc> :t foldr (>=>) return . replicate n
00:20:54 <ddarius> ... harass the maintainer.
00:20:55 <lambdabot>     Couldn't match expected type `Int' against inferred type `Expr'
00:20:55 <lambdabot>     In the first argument of `replicate', namely `n'
00:20:55 <lambdabot>     In the second argument of `(.)', namely `replicate n'
00:21:19 <kmc> :t \n -> foldr (>=>) return . replicate n
00:21:19 <lambdabot> forall (m :: * -> *) c. (Monad m) => Int -> (c -> m c) -> c -> m c
00:23:14 <ddarius> Hmm... building a custom version of Firefox...  why not?
00:23:36 <ClaudiusMaximus> anyway, my "quick hack" to generate an abstract mandelbrot set tree took about 10 hours (i took a scenic route) >> http://claudiusmaximus.goto10.org/g/mandelbrot/abstract/eg/9.html (javascript infovis toolkit with haskell-generated data)
00:24:07 * wagle ponders the fact that he come here to this channel to find out why haskell.org was down, and how long it'd stay that way, and that the topic simply states the obvious..  </whinge>
00:24:53 <ddarius> wagle: You act as if people know what's going on.
00:25:04 <ski> @type foldr (=<<) . return  -- dancor
00:25:05 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
00:25:06 <arcatan> wagle: yes, we occassionally take haskell.org down so that people would come to IRC
00:25:20 <wagle> heh/rofl
00:26:27 <ddarius> It's all part of an evil conspiracy by the original inventors of IRC to take over the world with netspeak.  It's frightening how successful that campaign has been, despite the many who've valiantly opposed it.
00:28:31 <lars9> :t (foldl (>=>) return [a -> m a])
00:28:32 <lambdabot> Pattern syntax in expression context: a -> m a
00:28:51 <lars9> :t (foldl (>=>) return [Just])
00:28:52 <lambdabot> forall c. c -> Maybe c
00:29:06 <lars9> :t (foldl (>=>) return [[], []])
00:29:06 <lambdabot>     Couldn't match expected type `c -> m c' against inferred type `[a]'
00:29:07 <lambdabot>     In the expression: []
00:29:07 <lambdabot>     In the third argument of `foldl', namely `[[], []]'
00:39:29 <ManateeLazyCat> Which "haddock markup" is for indent line? 
00:40:07 <ManateeLazyCat> markup "." indent line 4 spaces, have a markup can indent line deeply?
00:40:29 <ski> @type (foldr (=<<) . return) [Just]
00:40:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => [[a -> Maybe a] -> m [a -> Maybe a]] -> m [a -> Maybe a]
00:40:36 <ski> er, right
00:40:42 <ski> @type (foldr (=<<) . return) `flip` [Just]
00:40:43 <lambdabot> forall b. b -> Maybe b
00:41:46 <blackh> Hi yall. Anyone know about this on Mac OS/X: "user error (unknown GLUT entry glutSetOption)" ?
00:41:51 <guest2425> do yuo guys know 
00:42:15 <guest2425> where I can get web programming help with Servlets and JSP and beans
00:42:17 <guest2425> ???
00:42:45 <blackh> guest2425: Have you tried #java ?
00:43:17 <guest2425> not
00:43:20 <ski> s/#java/##java/
00:43:37 <ski> guest2425 : try writing :
00:43:37 <ski> /join ##java
00:43:47 <guest2425> ok
00:43:51 <guest2425> thank you
00:45:19 <guest2425> ski: i get this ##java Cannot join channel (+r) - you need to be identified with services
00:45:45 <kmc> guest2425, you need to be identified with services
00:45:53 <kmc> http://freenode.net/faq.shtml
00:46:06 <kmc> see "User Registration"
00:46:22 <blackh> guest2425: Forget Java. Stay here and learn Haskell. It's much better.
00:46:41 <guest2425> blackh: oh yeah
00:47:25 <blackh> guest2425: Yeah!
00:47:47 <guest2425> you need to be identified with services how i do this?
00:47:52 <guest2425> for Java
00:48:17 <kmc> guest2425, i pasted the link up there
00:48:17 <guest2425> i dont have to do that for Haskell
00:48:29 <ski> that's not it
00:48:33 <kmc> correct
00:48:40 <kmc> it's not ski?
00:48:40 <ski> you don't have to do that for #haskell
00:48:53 <guest2425> kmc: is not showing anything about identifer
00:48:58 <kmc> the ##java channel is set up differently
00:48:58 <guest2425> in the link
00:49:03 <ski> "#haskell" is this IRC channel, about "Haskell", which is the programming language
00:49:16 <kmc> <kmc> see "User Registration"
00:49:18 <kmc> do that
00:49:23 <guest2425> ok
00:51:05 <guest2425> kmc: sorry but I dont see any link for registration
00:51:09 <guest2425> in there
00:51:56 <ski> guest2425 : <http://freenode.net/faq.shtml#userregistration>
00:52:36 <kmc> guest2425, does your browser have a "search for text in page" feature?
00:52:46 <kmc> usually it's / or control-F
00:52:48 <guest2425> kmc: omg 
00:52:50 <guest2425> yes
00:53:08 <guest2425> anyway I will do web programming tomorrow 
00:53:24 <guest2425> blackh: I have a question for you
00:53:32 <guest2425> blackh: for Haskell
00:54:09 <ski> @faq Can Haskell solve guest2425's question?
00:54:09 <lambdabot> The answer is: Yes! Haskell can do that.
00:54:22 <ski> (.. sorry, i couldn't resist)
00:56:36 <guest2425> guys I need to do this http://pastebin.com/J6QhgFFu
00:56:44 <guest2425> any idea how to start
00:57:13 <guest2425> blackh: since you told me Haskell is fun How would you solve this problem http://pastebin.com/J6QhgFFu
00:57:41 <blackh> guest2425: Gotta run... but someone else will answer
00:57:58 <guest2425> oh my
00:57:59 <guest2425> ok
00:58:33 <kmc> guest2425, ask a more specific question
00:58:41 <kmc> not "do my homework [300 line paste]"
00:58:50 <guest2425> oh ok
00:59:09 <guest2425> I am only asking for the approach
00:59:19 <kmc> the file has a lot of comments and such
00:59:22 <guest2425> I dont understand that assigment
00:59:23 <kmc> presumably put there by your instructor
00:59:28 <guest2425> yes
00:59:35 <kmc> so... that's the approach
00:59:39 <guest2425> kmc: but I am still confuse
01:02:42 <kadoban> guest2425: that's what instructors are for, they like questions
01:03:04 <guest2425> kadoban: not My believe me
01:03:11 <kadoban> :(
01:04:07 <ski> hm .. /me str someone solving KenKen in Prolog quite recently
01:05:00 <guest2425> ski: oh prolog is similar to Haskell
01:05:08 <guest2425> not exactly but similar
01:05:40 <ski> well, both use recursion for looping, and both have immutable variables
01:05:51 <ski> .. and have matching
01:06:35 <guest2425> yeah
01:06:36 <lars9> in do block, let f = xxx, what is f? a value?
01:06:44 <lars9> or just syntax sugar?
01:07:07 <ski> (i saw this in ##prolog .. and helped that one a little bit, with understanding basic Prolog approaches and such)
01:07:08 <kmc> we like questions too
01:07:17 <kmc> "i am confused" is not a question
01:07:31 <kmc> if you are so confused by this task that you cannot formulate a specific question
01:07:36 <kmc> then that means you need to try a simpler task first
01:07:42 <ski>   ?- confused(guest2425).
01:07:43 <ski>   Yes
01:07:44 <ski> ?
01:08:03 <ski> kmc : .. it could be a question in Prolog :)
01:08:09 <kmc> ;)
01:08:39 <ski> lars9 : `f' could be any pattern, there
01:08:53 <ski> lars9 : in this case, `f' will be bound to the value of `xxx'
01:09:41 <kmc> lars9, 'let' (inside or outside 'do') is for binding local variables
01:09:45 <ski> lars9 : `do {let {f = xxx}; ..f..}' is the same as `let {f = xxx} in do {..f..}'
01:10:01 <kmc> you could say that f is a value, or you could say that f is a variable which stands for a value
01:10:16 <kmc> a short name for that value
01:10:31 <edlinde> whats a good place to learn about Monads in detail?
01:10:36 <edlinde> other than LYAH
01:10:51 <kmc> gentle introduction to haskell
01:10:53 <kmc> all about monads
01:10:57 <kmc> probably RWH too
01:11:08 <kmc> there isn't much detail about monads
01:11:20 <kmc> "Monad" is the name of a small generic API implemented by lots of different types
01:11:27 <kmc> there's more to say about the specific types than about the API itself
01:11:30 <kmc> sleep, bbl
01:12:46 <osaunders> I heard someone was working on an improved Hackage.
01:13:07 <osaunders> Is that correct and if so when will it be done and what will it do?
01:13:20 <osaunders> Or where can I find out those things.
01:13:53 <ski> "Notions of Computation and Monads" at <http://www.disi.unige.it/person/MoggiE/ftp/ic91.pdf> by Eugenio Moggi in 1991
01:15:01 <Painted> is haskell.org down?
01:15:55 <edlinde> kmc: is "all about monads" a book?
01:18:17 <ski> edlinde : <http://www.haskell.org/all_about_monads/html/index.html>, but haskell.org is currently down
01:18:42 <edlinde> okie
01:18:46 <ski> google suggests <http://horna.org.ua/books/All_About_Monads.pdf> might be a pdf version of the same -- i haven't checked
01:18:51 <Painted> FUCK YOU.
01:18:54 <Painted> PERL SUCKS
01:18:56 <Painted> YOU NIGGERS
01:18:58 <Painted> THAT'S RIGHT
01:19:01 <Painted> BLACK PEOPLE
01:19:08 <ski> @where ops
01:19:08 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
01:19:14 --- mode: ChanServ set +o quicksilver
01:19:18 <quicksilver> too slow
01:19:22 <ski> yeah
01:19:39 <quicksilver> curious kind of troll
01:19:49 <quicksilver> do you think 'perl sucks' was aimed to get our sympathy first of all?
01:20:09 <ski> i suppose s/he actually read the topic, when entering :)
01:20:29 --- mode: quicksilver set -o quicksilver
01:20:36 <edlinde> ski: thanks for the tutorial
01:20:47 <edlinde> who was that dude? Crazy ass
01:20:47 <ski> it's not mine :)
01:21:15 <edlinde> ski: man we had this guy from a maths dept talk about monads... and he was super crap
01:21:31 <edlinde> confused the shit out of everyone and got lost in his own notations himself in the end
01:21:39 <edlinde> so are monads really that tough?
01:22:08 <ski> well, monads come from category theory ..
01:22:27 <ski> monads in programming aren't really very tough, imo
01:22:50 <ski> of course, you should probably have a grip about higher-order functions before tackling them
01:23:40 <ski> also, learning monads in Haskell is more about learning about some standard useful monads, than learning about the monad API (which is small, and doesn't by itself say very much)
01:24:12 <ski> monads are "just" a useful API that several datatypes happen to support
01:24:53 <edlinde> ok
01:25:09 <edlinde> the LYAH suggests to understand applicative functors first before learning monads
01:25:10 <ski> (and, to learn about the `Monad' *type*class*, you should first understand type classes, and parameterized types)
01:25:28 <edlinde> but then the prof I spoke to was like.. applicative functors are crap and no one even uses them
01:25:42 <edlinde> I understand that stuff ... well ok enough
01:25:50 <ski> i don't think it matters much whether you learn applicative functors before or after
01:25:50 <Twey> Applicative functors have their uses
01:25:57 <edlinde> I just have to practise the syntax
01:26:09 * ski learned monads when applicative functors hadn't been invented
01:26:22 <Twey> But the reason it's suggested that you learn them before monads is not because they're useful but because Monad builds on some of the functionality of Applicative
01:26:36 <edlinde> wondering how best to get hang of haskell syntax... maybe just keep coding in it... but I am unable to think of problems to solve in haskell at the moment :)
01:26:58 <edlinde> Twey: Yeah I see the similarities 
01:27:04 <Twey> edlinde: If you have a problem, solve it in Haskell; not too tricky :þ
01:27:08 <ski> yeah .. but you could as well say that groups build on functionality of quasi-groups .. but someone, algebra students usually learn about groups before, anyway :)
01:27:24 <edlinde> true
01:27:30 <Twey> ski: I have no idea what you just said but I suspect that it should not be the case :þ
01:28:05 <ski> Twey : <http://en.wikipedia.org/wiki/Quasigroup>
01:28:18 <edlinde> :)
01:28:19 <shachaf> ski: I've seen monoids introduced before groups.
01:28:39 <ski> roughly, a quasi-group is a group, in which the combination need not be associative, and there need not be an identity element
01:28:51 <ski> (if there's an identity element, it's called a loop)
01:29:12 <kfish> edlinde, btw. i would disagree with applicative not being widely used :)
01:29:24 <ski> (Twey : you suspect that *what* should not be the case ?)
01:29:30 <edlinde> kfish: fine by me :)
01:29:40 <kfish> also, applicative is fun!
01:29:46 <edlinde> do you guys like using list comprehensions?
01:29:49 <ski> shachaf : yeah, i think that's probably common
01:30:02 <Twey> edlinde: When they're appropriate
01:30:12 <edlinde> I think our prof has a thing for them
01:30:14 <edlinde> :)
01:30:27 <quicksilver> if I was teaching algebra, I'd introduce groups and/or monoids via familiar examples (perhaps addition or multiplication of real numbers).
01:30:46 <quicksilver> I'd probably introduce them together since it's easy enough to think of contexts where inverses do/do not exist.
01:30:46 <edlinde> ok am off.. thanks guys
01:30:52 <Twey> edlinde: List comprehensions are surprisingly unuseful
01:30:56 <ski> > [() | False]
01:30:57 <lambdabot>   []
01:31:04 <Twey> They have their place, but most of the time a map seems to be better
01:31:04 <kfish> edlinde, ask your prof if he likes miranda :)
01:31:08 <edlinde> Twey: I disagree :)
01:31:15 <Twey> They're best when you need pattern-matching
01:31:18 * ski thinks `[... | ]' also ought to work ..
01:31:35 <Twey> Oh, or combination
01:31:37 <quicksilver> the problem with haskell is that really you want to teach how to use do notation before you introduce all the other bits and pieces they depend on
01:31:38 <edlinde> Twey: I seen some pretty cool combinatorial problems solved with it ... in just a single line... quite cool
01:31:56 <Twey> edlinde: In the real world, though, they don't come up that much :þ
01:32:08 <quicksilver> going off and explaining typeclasses and higher order functions at the beginning is a bit of a distraction.
01:32:24 <quicksilver> list comprehensions are mostly just a quirky special case of do notation.
01:32:38 <quicksilver> quirky because the return statement is at the beginning not the end.
01:32:53 <ski> > [(x,y) | x <- "ab" | y <- "cd"]
01:32:54 <lambdabot>   [('a','c'),('b','d')]
01:33:14 <quicksilver> I do find them occasionally convenient precisely when I want to put the return statement first; it's a bit like choosing between 'let' and 'where'.
01:33:16 <shachaf> quicksilver: You think do-notation should come before a basic understanding of what type classes are?
01:33:36 <ski> (hm, maybe there should be an `--fdo-is-IO' option ?)
01:33:55 <quicksilver> shachaf: not quite saying that I think that. But I am saying I can understand why you might want to do it in that order.
01:34:13 <quicksilver> shachaf: I can understand why you might want to teach some simple IO because it makes it easier to make programs which 'do things'.
01:34:19 <shachaf> quicksilver: I liked the way _Programming In Haskell introduced it.
01:34:27 <quicksilver> shachaf: of all the actual pedagogical approaches I've seen, I like LYAH's.
01:34:30 <shachaf> s/ll/ll_/
01:34:38 <quicksilver> Hutton?
01:34:41 <shachaf> Yes.
01:34:51 <theorbtwo> Is it even possible to write a program in haskell that does something when you run it at the command line, doesn't use do notation, and doesn't look like crap?
01:34:51 <quicksilver> I've not read it, although I've heard good things about it from some.
01:34:58 <quicksilver> grahamhutton++
01:35:15 <quicksilver> preflex: seen grahamhutton
01:35:15 <preflex>  grahamhutton was last seen on #haskell 25 days, 11 hours, 36 minutes and 48 seconds ago, saying: thanks!
01:35:43 <quicksilver> theorbtwo: in theory that's what "interact" is for, for example. I've not seen any really convincing arguments though.
01:35:55 <theorbtwo> You can start by not writing complete programs that you can simply run, certianly, or by writing out lots of >>= operators, but neither makes Haskell seem like something you would want to use.
01:36:30 <dibblego> is there a preferred convention for the case of the first character of packages on hackage?
01:36:53 <quicksilver> dibblego: lower case seems preferred but there is a definite lack of consistency.
01:37:02 <quicksilver> hackage being case-sensitive feels like a bug.
01:37:02 <dibblego> ok ta
01:37:14 <ski> quicksilver : wow, retroactive thanks :)
01:37:20 <quicksilver> ski: :)
01:38:18 <theorbtwo> Interact is a good answer, I think.
01:39:36 <shachaf> @ty \x -> fromMaybe x . listToMaybe -- Does this have a name?
01:39:37 <lambdabot> forall a. a -> [a] -> a
01:40:28 <dibblego> I've used "headOr" before
01:40:51 <shachaf> I meant a name in the standard library. :-)
01:41:05 <dibblego> I've used "headOr" before, since it wasn't in the standard library :)
01:41:41 <theorbtwo> @pointless \x -> fromMaybe x . listToMaybe
01:41:41 <lambdabot> (. listToMaybe) . fromMaybe
01:41:48 <theorbtwo> Well, that didn't help.
01:42:08 <shachaf> theorbtwo: Even if it had helped, I don't think the Maybe should be explicit.
01:43:17 <quicksilver> shachaf: head . (++[x])
01:43:20 <quicksilver> ;)
01:44:09 <shachaf> quicksilver: Fair enough, I suppose. Still not very pretty. :-)
01:44:29 <quicksilver> shachaf: foldr const
01:44:53 <quicksilver> > foldr const 5 []
01:44:54 <lambdabot>   5
01:44:55 <shachaf> Better.
01:44:57 <quicksilver> > foldr const 5 [1,2,3]
01:44:58 <lambdabot>   1
01:45:15 <quicksilver> this is not a stupid point - it's an instance of a catamorphism, just like 'fromMaybe' is.
01:45:34 <romildo> Is there a shorter way of writing the expression following monadic expression, maybe using some library function?
01:45:35 <romildo>   do x <- action1
01:45:36 <romildo>      action2
01:45:36 <romildo>      return x
01:45:52 <shachaf> Yes. Is there a general name for a "one-level catamorphism" like that?
01:46:08 <quicksilver> shachaf: I think so, but I don't know what.
01:46:18 <quicksilver> romildo: action1 <* action2
01:46:35 <quicksilver> romildo: mnemonic is, the arrow in <* points to the return value you 'want'.
01:47:01 <quicksilver> romildo: (action3 *> action1 <* action2) works as well
01:47:12 <quicksilver> (and it's the return value of action1 you get)
01:47:34 <romildo> quicksilver, from which module are those operators?
01:47:42 <quicksilver> Control.Applicative, I suspect
01:47:44 <shachaf> Control.Applicative.
01:48:34 <shachaf> @src (<*)
01:48:34 <lambdabot> (<*) = liftA2 const
01:49:04 <ski> @index (<*)
01:49:05 <lambdabot> bzzt
01:54:57 <Ke> so anyone know of any ghc option to make built binary load all libraries upon startup
02:01:15 <romildo> More specifically, I am looking for a rewriting of the code in http://hpaste.org/41767/case_in_a_do_expression, as I think it is somewaht ugly when the sub-expression are not too small. Any suggestion?
02:12:36 <ivanm> is there any way of saying that if a type is () do one thing, otherwise do something else?
02:12:37 <dibblego> @pl \s -> (decode . B.unpack) `fmap` B.readFile s
02:12:37 <lambdabot> ((decode . B.unpack) `fmap`) . B.readFile
02:13:02 <ski> romildo : you could use `(<*)', as quicksilver suggested
02:13:03 <dibblego> ivanm, Either?
02:13:08 <ski> or you could define
02:13:17 <shachaf> I think SYB had a type-safe cast of some sort?
02:13:20 <ski>   ma `after` mb = do
02:13:21 <ivanm> I have a type class Labellable, for which () returns an empty label
02:13:23 <ski>     b <- mb
02:13:25 <ski>     ma
02:13:28 <ski>     return a
02:13:31 <ski> and then use
02:13:46 <ManateeLazyCat> Haskell Wiki down again?
02:13:48 <ski>   action3 `after` case x of
02:13:50 <ski>     ...
02:13:58 <shachaf> Oh, not SYB. Data.Typeable.
02:14:03 <ivanm> when doing quick`n`dirty previews of graphs, I want to be able to say "if it's (), then use the default label; otherwise use the Labellable instance"
02:14:13 <ivanm> ManateeLazyCat: /topic
02:14:15 <shachaf> > cast () :: Maybe ()
02:14:16 <lambdabot>   Just ()
02:14:17 <shachaf> > cast 5 :: Maybe ()
02:14:18 <lambdabot>   Nothing
02:14:33 <ManateeLazyCat> ivanm: sad.
02:14:50 <ManateeLazyCat> shachaf: Yes, Typeable is safe, it will got "Maybe a" 
02:14:51 <ivanm> I _could_ make the Labellable class return a Maybe, but that will make using it more difficult
02:16:07 <shachaf> cast will work, or a type class with FlexibleInstances and OverlappingInstances.
02:16:30 <shachaf> It seems like you should use a Maybe, though...
02:16:36 <ivanm> yeah, I'm already using a type class...
02:16:42 <ivanm> stupid () values... :@
02:18:12 <ivanm> maybe it would just be easier not to make () an instance of the class...
02:18:32 <ivanm> and let the users deal with it if they have () as a graph label type
02:18:58 <ski> > (uncurry (++) . second (drop 5) . splitAt 2) "Labellable"
02:18:59 <lambdabot>   "Lable"
02:19:44 * ivanm wonders why ski just did that...
02:20:54 <Jafet> > "Label" ++ cycle "able"
02:20:55 <lambdabot>   "Labelableableableableableableableableableableableableableableableableablea...
02:20:58 <ski> hm, just playing around .. "Labellable" reminded me of `dissociated-press'
02:21:34 <ClaudiusMaximus> suppose i want a set of every ordered product (with 1 excluded for obvious reasons) resulting in a given number - what's a good way to do this?  eg> f 12 = S.fromList [[12], [3,4], [4,3], [3,2,2], [2,2,3], [2,3,2], [6,2], [2,6]]
02:23:32 <ski> hm, you don't want s/S.fromList/S.fromList . map S.fromList/ ?
02:23:45 <ClaudiusMaximus> ski: no, order is important here
02:27:29 <ClaudiusMaximus> > let factors n = [ m | m <- [2 .. n], n `mod` m == 0 ] ; f n = [ k : f (n `div` k) | k <- factors n ] in f 12 -- perhaps?
02:27:30 <lambdabot>   Occurs check: cannot construct the infinite type: t = [t]
02:27:39 <romildo> ski,  isn't there something similar to your "after" above in the standard library?
02:27:43 <Twey> ClaudiusMaximus: I would probably break it down into prime factors first, then make all the different combinations
02:27:50 <quicksilver> ClaudiusMaximus: that's basically what I was going to suggest, yes.
02:28:34 <c_wraith> If you use the primes package, that can only help
02:28:41 <ClaudiusMaximus> > let factors n = [ m | m <- [2 .. n], n `mod` m == 0 ] ; f n = [ k:ks | k <- factors n, ks <- f (n `div` k) ] in f 12 -- if this doesn't work i try locally :)
02:28:42 <lambdabot>   []
02:28:48 <gal_bolle> ivanm: do you have a data NoLabel = NoLabel somewhere that users can take as the label type instead of ()?
02:30:42 <ivanm> gal_bolle: no
02:30:51 <ivanm> but it will cause the same problems as ()
02:30:55 <ivanm> so () doesn't have an instance
02:31:09 <ski> romildo : `(<*)'
02:31:23 <gal_bolle> it's clearer to define a dummy instance for NoLabel than for (), imo
02:31:43 <ivanm> this is only a big deal if users use the preview function: http://hackage.haskell.org/packages/archive/graphviz/2999.10.0.1/doc/html/Data-GraphViz.html#v:preview
02:32:16 <ivanm> in the new version, the constraint is (Ord el, Graph g, Labellable nl, Labellable el) => ...
02:32:26 <romildo> ski, yes, (<*) and after do the same thing, but the arguments are reversed.
02:33:39 <ivanm> but the whole point of the Labellable class is to save users from having to do: Label . StrLabel . v
02:34:00 <romildo> ski, "m1 <* m2" is the same as "m2 `after` m1".
02:37:10 <ski> > let split n = [(d0,d1) | d0 <- [1 .. n] , (d1,0) <- [n `divMod` d0]]; factorize 1 = mzero; factorize n = return [n] `mplus` do {(d0,d1) <- split n; guard (n `notElem` [d0,d1]); concat `liftM` (factorize `mapM` [d0,d1])} in factorize 12
02:37:11 <lambdabot>   [[12],[2,6],[2,2,3],[2,3,2],[3,4],[3,2,2],[4,3],[2,2,3],[6,2],[2,3,2],[3,2,...
02:37:18 <ski> > let split n = [(d0,d1) | d0 <- [1 .. n] , (d1,0) <- [n `divMod` d0]]; factorize 1 = mzero; factorize n = return [n] `mplus` do {(d0,d1) <- split n; guard (n `notElem` [d0,d1]); concat `liftM` (factorize `mapM` [d0,d1])} in nub (factorize 12)
02:37:19 <lambdabot>   [[12],[2,6],[2,2,3],[2,3,2],[3,4],[3,2,2],[4,3],[6,2]]
02:37:21 <ClaudiusMaximus> > let factors n = filter((==0).(n`mod`))[2..n] ; f 1 = Data.Set.singleton [] ; f n = Data.Set.fromList [ k : ks | k <- factors n, ks <- Data.Set.toList $ f (n `div` k) ] in f 12
02:37:21 <lambdabot>   Not in scope: `Data.Set.singleton'Not in scope: `Data.Set.fromList'Not in s...
02:37:50 <ClaudiusMaximus> > let factors n = filter((==0).(n`mod`))[2..n] ; f 1 = S.singleton [] ; f n = S.fromList [ k : ks | k <- factors n, ks <- .S.toList $ f (n `div` k) ] in f 12
02:37:51 <lambdabot>   <no location info>: parse error on input `.'
02:37:58 <ClaudiusMaximus> > let factors n = filter((==0).(n`mod`))[2..n] ; f 1 = S.singleton [] ; f n = S.fromList [ k : ks | k <- factors n, ks <- S.toList $ f (n `div` k) ] in f 12
02:37:59 <lambdabot>   fromList [[2,2,3],[2,3,2],[2,6],[3,2,2],[3,4],[4,3],[6,2],[12]]
02:38:02 <ClaudiusMaximus> :)
02:38:55 <ClaudiusMaximus> > let factors n = filter((==0).(n`mod`))[2..n] ; f 1 = S.singleton [] ; f n = S.fromList [ k : ks | k <- factors n, ks <- S.toList $ f (n `div` k) ] in S.size $ f 3600
02:38:55 <ski> romildo : you could use `(<* m2) m1' (possibly also using `$') ... 
02:38:56 <lambdabot>   11008
02:39:31 <ski> ClaudiusMaximus : what do you think about my approach ?
02:39:42 <ski> (you can probably adapt it to use `Set', instead ..)
02:40:55 <ClaudiusMaximus> ski: interesting - not sure i understand it :)
02:41:07 <ivanm> you know, it helps when example code in the documentation actually works... :s
02:42:27 <ClaudiusMaximus> @instances-importing Monoid Data.Set
02:42:27 <lambdabot> Couldn't find class `Data.Set'. Try @instances-importing
02:42:33 <ClaudiusMaximus> @instances-importing Data.Set Monoid
02:42:34 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Set a, Sum a, [a]
02:42:44 <ski> > let split n = [(d0,d1) | d0 <- [1 .. n] , (d1,0) <- [n `divMod` d0]]; factorize 1 = []; factorize n = [n] : [fs0 ++ fs1 | (d0,d1) <- split n , n `notElem` [d0,d1] , fs0 <- factorize d0 , fs1 <- factorize d1] in nub (factorize 12)
02:42:45 <lambdabot>   [[12],[2,6],[2,2,3],[2,3,2],[3,4],[3,2,2],[4,3],[6,2]]
02:42:58 <ski> ClaudiusMaximus : that's basically the same thing, written with list comprehensions instead
02:44:04 <ClaudiusMaximus> ski: aha, clearer to me now
02:44:15 <ski> (instead of checking for `1' and `n', one could of course change `split' to use `[2 .. n - 1]', instead)
02:44:58 <ski> (though the result for the input `1' would be different .. unless you caught that in the top call)
02:45:32 <ClaudiusMaximus> ski: i think it will probably generate just as many duplicates as mine?
02:46:04 <ClaudiusMaximus> ski: anyway, i don't plan on using it on large numbers :)
02:46:34 <ski> i suppose one could try to use dynamic programming ..
02:46:49 <ClaudiusMaximus> > 60 * 60 * 120 / 1000
02:46:50 <lambdabot>   432.0
02:47:14 <ClaudiusMaximus> > 60 * 60 * 1000 / 120 -- oops; this is about the largest sane input
02:47:15 <lambdabot>   30000.0
02:48:44 <ClaudiusMaximus> the larger context is for finding interesting periodic points in the Mandelbrot Set to sonify, if the period is 30k then the output will be an hour long which will get a bit dull to listen to...
02:50:25 <ivanm> any windows users here atm?
02:52:15 <ClaudiusMaximus> is there a multi-dimensional root-finding library out there that works with something higher-precision than Double ?
02:53:10 <ClaudiusMaximus> or one that works with any sufficiently instanced type?
02:53:26 <ivanm> ClaudiusMaximus: the only available floating-point type that I know of is CReal, and it's _slow_
02:53:45 <genewitch> i noticed that the site was down. What package do i install on ubuntu 10.4(i think) to get haskell?
02:53:56 <genewitch> i see haskell-cabal and a few others
02:54:13 <ClaudiusMaximus> ivanm: i wrote bindings to libqd (which I still haven't finished...)
02:54:17 <ski> (`CReal' is floating point !?)
02:54:56 <ClaudiusMaximus> ivanm: it's also slow; but probably not as slow as CReal
02:55:13 <ivanm> ski: well, in that it isn't an Integral type...
02:55:27 <ivanm> genewitch: if there's a haskell-platform package, you probably want that
02:56:15 <genewitch> ivanm: checking now
02:56:45 <ivanm> I think it's in a PPA though
02:56:50 <quicksilver> ClaudiusMaximus: http://hackage.haskell.org/package/AERN-Real has some solvers in
02:56:58 <ski> (to me, "floating-point" means that you have a digit representation, plus a scaling factor corresponding to where to place the dot)
02:57:12 <genewitch> ivanm: there is not
02:57:40 <genewitch> ski: that sounds like scientific notation. mind you, i just got here.
02:57:45 <ski> (so, `CReal' being floating point would then probably mean that it used a stream of digits, plus an `Integer' for the dot)
02:57:53 <ivanm> genewitch: http://hackage.haskell.org/platform/linux.html
02:58:18 <ivanm> ski: it's also an instance of Floating... ;-)
02:59:33 <genewitch> ivanm: oh, i suppose this means i need to figure out how to add universe to aptitude on a cli
02:59:41 <ski> well, `Floating' is a misnomer
03:00:04 <ski> .. hm, possibly `RealFrac' could be renamed into `Floating' ?
03:00:59 <quicksilver> Floating should possibly be called Transcendantal
03:01:15 <quicksilver> since it's mostly about the existance of various transcendental functions.
03:01:19 <quicksilver> (unless I have them mixed up)
03:01:27 <ski> yeah
03:01:28 <ivanm> @src Floating
03:01:29 <lambdabot> class  (Fractional a) => Floating a  where
03:01:29 <lambdabot>     pi                                                      :: a
03:01:29 <lambdabot>     exp, log, sqrt, sin, cos, tan                           :: a -> a
03:01:29 <lambdabot>     asin, acos, atan, sinh, cosh, tanh, asinh, acosh, atanh :: a -> a
03:01:29 <lambdabot>     (**), logBase                                           :: a -> a -> a
03:01:35 <ski> @src RealFrac
03:01:35 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
03:01:36 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
03:01:36 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
03:01:39 <ClaudiusMaximus> quicksilver: hm, only 1D as far as i can tell - i need 4D
03:01:49 <quicksilver> ClaudiusMaximus: Ah. Then no, I don't know.
03:02:02 <quicksilver> ClaudiusMaximus: a binding to a decent maths library would be the way to go I imagine.
03:02:05 <ClaudiusMaximus> hmatrix/GSL has it, but only for Double
03:10:00 <ivanm> preflex: seen lispy
03:10:00 <preflex>  lispy was last seen on #haskell 1 day, 3 hours, 54 minutes and 46 seconds ago, saying: * lispy >>= bed
03:10:14 <ivanm> preflex: seen lispy1 
03:10:14 <preflex>  lispy1 was last seen on #darcs 1 hour, 44 minutes and 56 seconds ago, saying: * lispy1 must go to sleep now
03:12:02 <genewitch> oddly, i just needed to install GHC
03:12:12 <genewitch> that solved my problem. thanks for the chatting.
03:41:58 <lars9> silence
03:46:08 <mm_freak_> noise
03:49:47 <mm_freak_> ManateeLazyCat: i've written a new library, which you might find interesting for your IRC client:  http://hackage.haskell.org/package/dnscache
03:50:00 <mm_freak_> ManateeLazyCat: also i'm finally planning to work on fastirc again =)
03:50:14 <ManateeLazyCat> mm_freak_: Looking, thanks! :)
03:50:39 <mm_freak_> but prepare for some interface changes
03:51:16 <ManateeLazyCat> mm_freak_: I will refactory my code then. :)
03:51:38 <ManateeLazyCat> mm_freak_: Next version will support SSL?
03:51:53 <ManateeLazyCat> mm_freak_: I also want some "number parser code" to support number command. :)
03:52:44 <mm_freak_> ManateeLazyCat: i can't say when i will add SSL support…  most likely i'll completely rewrite the session handler from scratch using iteratee instead of attoparsec and contstuff instead of monadLib
03:53:15 <mm_freak_> so adding SSL support will become a matter of writing a corresponding Enumeratee
03:53:36 <ManateeLazyCat> mm_freak_: I suggest you split session code from protocol implement, because framework have limit, less useful for other people.
03:53:36 <ManateeLazyCat>  
03:54:07 <mm_freak_> yes, it will be separated, but anyway, protocol implementation will be done using iteratee
03:54:21 <ManateeLazyCat> mm_freak_: Any improve?
03:54:29 <mm_freak_> currently i'm writing an SMTP client library using the new concept
03:54:38 <mm_freak_> yes, better composability and probably even higher speed
03:54:52 <ManateeLazyCat> mm_freak_: SMTP library? Wow, i plan to develop mail-client in Manatee
03:54:54 <mm_freak_> also more control over resources
03:55:10 <ManateeLazyCat> mm_freak_: Wow, i will looking forward it.
03:55:11 <mm_freak_> attoparsec gives you no control at all, and iteratee gives you full control
03:55:17 <ManateeLazyCat> mm_freak_: attoparsec is fast enough.
03:55:25 <ManateeLazyCat> mm_freak_: Cool!
03:55:28 <quicksilver> smtp is the easy part of writing a mail client, though.
03:55:33 <mreh> monad transformers, they're not so scary afterall
03:55:44 <quicksilver> the hard part is the imap / folder management (if you use local folders)
03:56:05 <ManateeLazyCat> quicksilver: I plan develop mail-client to support IMAP-Offline
03:56:18 <ManateeLazyCat> mm_freak_: How about your SMTP library? 
03:56:19 <mm_freak_> yeah, SMTP is really easy…  i'm writing it for a project i need at work
03:56:21 <tab> mm_freak_: have you looked at the enumeratee ssl interface of http-enumeratee ?
03:56:36 <mm_freak_> tab: not yet, but that sounds like what i need
03:56:55 <quicksilver> ManateeLazyCat: good. IMAP-offline is hard. Not many people have ever got it working well.
03:57:08 <tab> mm_freak_: it should be easy to take apart from the http protocol in any case
03:57:22 <tab> mm_freak_: potentially i'll move it into my TLS library as well
03:57:26 <ManateeLazyCat> quicksilver: Yes, IMAP-offline is best solution, i plan use it replace Emacs-Gnus.
03:57:30 <mm_freak_> tab: that would be great
03:57:45 <ManateeLazyCat> quicksilver: Just let user input mail/password.
03:58:03 <ManateeLazyCat> quicksilver: Other thing manatee-mailclient will do for you. :)
03:58:07 <mm_freak_> i'm doing a lot of stuff from scratch right now, SMTP is such an example, because the client libraries on hackage don't really fit
03:58:25 <tab> mm_freak_: yeah i know this feeling :\
03:58:50 <ManateeLazyCat> mm_freak_: I will build newest GUI client for it once you finish library. :)
03:58:50 <tab> mm_freak_: had to redo a bunch of things too (crypto and asn1)
03:59:02 <quicksilver> ManateeLazyCat: what about org-mode? ;0
03:59:12 <ManateeLazyCat> quicksilver: Yes, it's in my plan.
03:59:19 <mm_freak_> ManateeLazyCat: meanwhile you can use one of the other SMTP packages on hackage…  they are fine for sending mail, but not very fine for almost anything else =)
03:59:27 <ManateeLazyCat> quicksilver: I will write manatee-ordmode compatible Emacs's one.
03:59:35 <ManateeLazyCat> mm_freak_: Yes,
03:59:45 <ManateeLazyCat> mm_freak_: All mail library on hackage is not good enough.
03:59:50 <mm_freak_> ManateeLazyCat: in fact, my library might provide more control than you need, so you may be faster, if you just use hsmtpclient or something like that
04:00:17 <mm_freak_> tab: which crypto packages did you do?  any on hackage?
04:00:26 <ManateeLazyCat> mm_freak_: I believe you. :)
04:00:34 <tab> mm_freak_: cryptohash and cryptocipher
04:01:02 <mm_freak_> tab: ok, then i'm actually using your stuff already =)
04:01:10 <tab> ah cool ;)
04:01:13 <quicksilver> ManateeLazyCat: well, you have to stop somewhere. To make it completely compatible you'd have to have an elisp interpreter.
04:01:26 <mm_freak_> at least cryptohash
04:01:29 <quicksilver> ManateeLazyCat: (because org-mode files can have literal elips chunks in various places)
04:02:09 <ManateeLazyCat> quicksilver: Well, i will do my best.
04:02:12 <tab> mm_freak_: great :) just hope it's generally useful to everyone and just to my libraries
04:02:18 <tab> and not just*
04:02:21 <ManateeLazyCat> quicksilver: If some feature need elisp, drop it. :)
04:02:26 <quicksilver> ManateeLazyCat: is the manatee editor scriptable?
04:02:48 <mm_freak_> tab: well, i can say it's working so far and it's fast, so it's probably awesome =)
04:02:56 <ManateeLazyCat> quicksilver: Still in develop.
04:03:04 <ManateeLazyCat> quicksilver: I plan mix pdynload code in manatee.
04:03:07 <ManateeLazyCat> quicksilver: Still in test.
04:03:15 <quicksilver> ManateeLazyCat: do you envisage haskell as a scripting language? Something a little like Yi?
04:03:23 <quicksilver> with it's BufferM monad and stuff
04:03:46 <ManateeLazyCat> quicksilver: Well, Something like Yi perhaps easier. But Manatee is not just for *text*.
04:03:56 * hackagebot manatee-core 0.0.3 - The core of Manatee.  http://hackage.haskell.org/package/manatee-core-0.0.3 (AndyStewart)
04:03:58 <ManateeLazyCat> quicksilver: Some stream state hard to save/restore
04:03:59 * hackagebot manatee-anything 0.0.3 - Multithread interactive input/search framework for Manatee  http://hackage.haskell.org/package/manatee-anything-0.0.3 (AndyStewart)
04:04:01 * hackagebot manatee-browser 0.0.3 - Browser extension for Manatee.  http://hackage.haskell.org/package/manatee-browser-0.0.3 (AndyStewart)
04:04:03 * hackagebot manatee-editor 0.0.3 - Editor extension for Manatee.  http://hackage.haskell.org/package/manatee-editor-0.0.3 (AndyStewart)
04:04:17 <mm_freak_> (never throught i'd upload anything to hackage, when i started using haskell…  now i have already four (useful) packages there)
04:04:20 <ManateeLazyCat> Wow, i like script, easy to upload manatee now . :)
04:04:50 * quicksilver nods
04:04:57 * hackagebot manatee-filemanager 0.0.3 - File manager extension for Manatee.  http://hackage.haskell.org/package/manatee-filemanager-0.0.3 (AndyStewart)
04:05:20 <mm_freak_> ManateeLazyCat: for n in this.tar.gz that.tar.gz; do cabal upload $n; done
04:05:23 <mm_freak_> ;)
04:05:37 <mm_freak_> but i do it through my Makefile
04:05:40 <mm_freak_> make upload
04:05:46 <ManateeLazyCat> quicksilver: My first aim is build *safe* environment, then dynamic.
04:05:59 * hackagebot manatee-pdfviewer 0.0.3 - PDF viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-pdfviewer-0.0.3 (AndyStewart)
04:06:00 <quicksilver> ManateeLazyCat: fair enough
04:06:01 * hackagebot manatee-mplayer 0.0.3 - Mplayer client extension for Manatee.  http://hackage.haskell.org/package/manatee-mplayer-0.0.3 (AndyStewart)
04:06:03 * hackagebot manatee-ircclient 0.0.3 - IRC client extension for Manatee.  http://hackage.haskell.org/package/manatee-ircclient-0.0.3 (AndyStewart)
04:06:05 * hackagebot manatee-processmanager 0.0.3 - Process manager extension for Manatee.  http://hackage.haskell.org/package/manatee-processmanager-0.0.3 (AndyStewart)
04:06:07 * hackagebot manatee-imageviewer 0.0.3 - Image viewer extension for Manatee.  http://hackage.haskell.org/package/manatee-imageviewer-0.0.3 (AndyStewart)
04:06:12 <ManateeLazyCat> quicksilver: I hate crash like Emacs.
04:06:39 * quicksilver doesn't find emacs crashy.
04:06:42 <mm_freak_> ManateeLazyCat: what exactly is manatee?  i always throught it's just an IRC client =)
04:06:46 <quicksilver> maybe it depends how you use it though.
04:06:54 <ManateeLazyCat> mm_freak_: http://goo.gl/MkVw
04:06:54 <quicksilver> mm_freak_: it's an application framework.
04:07:07 <mm_freak_> i see
04:07:09 <quicksilver> it's like the lovechild of lotus notes + xmonad
04:07:09 * hackagebot manatee-reader 0.0.3 - Feed reader extension for Manatee.  http://hackage.haskell.org/package/manatee-reader-0.0.3 (AndyStewart)
04:07:11 * hackagebot manatee-curl 0.0.3 - Download Manager extension for Manatee.  http://hackage.haskell.org/package/manatee-curl-0.0.3 (AndyStewart)
04:07:12 <ManateeLazyCat> mm_freak_: Irc client just one extension of Manatee.
04:07:13 * hackagebot manatee 0.0.7 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.7 (AndyStewart)
04:07:17 <mm_freak_> so i can write arbitrary GUI applications with manatee?
04:07:25 <ManateeLazyCat> mm_freak_: Yes.
04:07:32 <mm_freak_> cool, sounds interesting
04:07:37 <ivanm> quicksilver: lol
04:07:39 <mm_freak_> does it work under windows?
04:07:51 <ManateeLazyCat> mm_freak_: No.
04:07:57 <ManateeLazyCat> mm_freak_: But not hard to portable
04:08:07 <ManateeLazyCat> mm_freak_: I just too busy, haven't time work on Windows.
04:08:14 <ManateeLazyCat> mm_freak_: It's base on Haskell/GTK+
04:08:26 <mm_freak_> well, if it's planned, that's fine
04:08:54 <ManateeLazyCat> mm_freak_: I want build perfect feature on Linux, then do portable work.
04:09:05 <mm_freak_> from time to time i need to write GUI apps, and unfortunately getting haskell GUIs to work in windows is anything but easy
04:09:19 <ManateeLazyCat> Hi all, i have release new version Manatee, framework refactory and intro new extension : manatee-curl
04:09:34 <ManateeLazyCat> manatee-curl is "Multi-Threads Download Manager" base on libcurl.
04:10:37 <ManateeLazyCat> manatee-curl use "disk cache" to support resume feature when your computere crash.
04:11:18 <ManateeLazyCat> @package manatee
04:11:18 <lambdabot> http://hackage.haskell.org/package/manatee
04:11:20 <ManateeLazyCat> mm_freak_: ^^^^
04:11:59 * hackagebot graphviz 2999.11.0.0 - Graphviz bindings for Haskell.  http://hackage.haskell.org/package/graphviz-2999.11.0.0 (IvanMiljenovic)
04:12:01 * hackagebot Graphalyze 0.11.0.0 - Graph-Theoretic Analysis library.  http://hackage.haskell.org/package/Graphalyze-0.11.0.0 (IvanMiljenovic)
04:12:40 <ManateeLazyCat> quicksilver: Next hard work is mix pdynload and "customize system", then power user can write Haskell code customize Manatee, and generic user use mouse click "Graphics Interface* customize it. :)
04:13:07 <ManateeLazyCat> quicksilver: Best not need user touch it, much easier than Emacs.
04:13:26 <quicksilver> ManateeLazyCat: the best thing about emacs is that it *forces* you to get to grips with the real system.
04:13:47 <quicksilver> it's a programmable editor, and it's only actually a good thing if you use the programmability
04:13:57 <quicksilver> however, manatee doesn't have the same objectives
04:14:00 * hackagebot SourceGraph 0.7.0.0 - Static code analysis using graph-theoretic techniques.  http://hackage.haskell.org/package/SourceGraph-0.7.0.0 (IvanMiljenovic)
04:14:12 <mm_freak_> ManateeLazyCat: thanks…  sounds like great stuff
04:14:18 <ManateeLazyCat> quicksilver: Yes, dynamic is fun, but it's less useful if it not safe.
04:14:49 <ManateeLazyCat> quicksilver: I write many elisp code make Emacs work like OS, and result is what? Emacs crash even some little mistake.
04:14:52 <mm_freak_> ManateeLazyCat: then you can actually integrate dnscache into the core and let it run globally
04:15:25 <ManateeLazyCat> quicksilver: If a environment is not safe, i won't use it, even it's a programmable environment.
04:15:28 <quicksilver> ManateeLazyCat: interesting. That's not been my experience at all. I have written less elisp than you.
04:15:37 <quicksilver> ManateeLazyCat: but I am not disagreeing. Safe is good.
04:16:07 <ManateeLazyCat> quicksilver: Infact, i have some code test hot-swapping core.
04:16:14 <ManateeLazyCat> quicksilver: Just speed is not fast enough.
04:16:20 * quicksilver nods
04:16:39 <ManateeLazyCat> quicksilver: So i need test more before i mix *hot-swapping* code in core.
04:16:57 <mm_freak_> i'm using emacs for many years now and have never written a single line of elisp outside of ~/.emacs =)
04:17:02 <ManateeLazyCat> mm_freak_: I also plan build *proxy rule* in core, then i can use it fighting GFW!:)
04:17:30 <ManateeLazyCat> mm_freak_: Emacs is powerful, but it's not support multi-threads, not safe, too slow, graphics engine is slow....
04:17:55 <quicksilver> ManateeLazyCat: it would be insane for emacs to support threads - too much dangerous mutable state.
04:17:59 <radioactive_man> this again leads to the conclusion: vim ftw!
04:18:09 <ManateeLazyCat> quicksilver: Yes
04:18:10 <quicksilver> ManateeLazyCat: much better to rewrite in haskell for that :)
04:18:14 <ManateeLazyCat> quicksilver: yes.
04:18:26 <quicksilver> actually emacs' sentinel-based asynchrony works quite well.
04:18:32 <quicksilver> but, that doesn't mean it's the best way.
04:18:34 <ManateeLazyCat> quicksilver: elisp have too much mutable state will crash you completely. :)
04:18:38 <quicksilver> right.
04:18:39 <lars9> mm_freak_: i used to use emacs a lot, but now the only thing i write in emacs is latex...
04:19:13 <ManateeLazyCat> quicksilver: Asynchronous can't work when many I/O operation.
04:19:26 <ManateeLazyCat> quicksilver: Think about open 30 W3m-Tab in Emacs. 
04:19:45 <ManateeLazyCat> quicksilver: Emacs will freeze though w3m code is asynchronous-IO
04:20:10 <ManateeLazyCat> quicksilver: So asynchronous is solution, but not natural solution to solve problem.
04:20:33 <mm_freak_> ManateeLazyCat: well, i think emacs is still the best editor out there for me, but it shows its age
04:20:44 <mm_freak_> lars9: what do you use now?
04:21:04 <lars9> vim
04:21:06 <ManateeLazyCat> mm_freak_: Yes, i agree, Emacs still is best editor in this world, for vi user: vi is best one too. :)
04:21:15 <mm_freak_> ah, ok
04:21:25 <lars9> i flipped from vim to emacs, then flopped back
04:21:51 <jkramer> Ahoy
04:21:58 <mm_freak_> i seldomly see people switch between emacs and vim, and mostly they switch from one to the other to switch back some time later
04:22:02 <jkramer> Is there a way to shorten this?  (\ todo -> todo { status = Done })
04:22:11 <ManateeLazyCat> quicksilver: Many people ask me why not improve Emacs like Manatee? I answer: it's harder to improve those and not brak compatible, harder than rewrite new one. 
04:22:40 <ManateeLazyCat> mm_freak_: Emacs just can play Text and Static picture, less fun....
04:22:55 <ManateeLazyCat> mm_freak_: But Emacs is really best one for programming....
04:23:06 <ManateeLazyCat> mm_freak_: For people just want Text. :)
04:23:08 <lars9> jkramer: what is that? seems strange
04:24:03 <tab> jkramer: i never found one, but i'm interested as well
04:25:14 <ManateeLazyCat> quicksilver: The right way is not write bug-free code, is write some framework minimize your losses when unexpected exception throwed..
04:25:19 <lars9> ManateeLazyCat: did you pay attention to Yi-Editor?
04:25:29 <ManateeLazyCat> lars9: I know it, but it's not my aim
04:25:31 <ivanm> @tell lispy1 OK, got a new SourceGraph release out; can you please see if this one builds on GHC 7?
04:25:31 <lambdabot> Consider it noted.
04:25:44 <ManateeLazyCat> lars9: I'm not just want editor, i want OS
04:26:13 <gal_bolle> ManateeLazyCat: you could use yi as the editor-component of your os
04:26:13 <jkramer> lars9: It updates the status field in a record
04:26:17 <lars9> ManateeLazyCat: awesome
04:26:35 <mm_freak_> ManateeLazyCat: i love eye candy, and emacs has none, but i still use it, because of its intelligent modes
04:26:36 <ManateeLazyCat> gal_bolle: Infact, i don't like Yi' policy that use multi-backend.
04:26:47 <Saizan> jkramer: no, unless you write yourself a function for that
04:26:49 <mm_freak_> i can't imagine hacking XML without the nxml-mode, for example
04:27:17 <ManateeLazyCat> mm_freak_: Yes, next step, i will write many IDE features in manatee-editor.
04:27:29 <ManateeLazyCat> mm_freak_: I hope someday manatee-editor can powerful as Emacs. :)
04:27:33 <ManateeLazyCat> mm_freak_: It's need time.
04:27:42 <Saizan> jkramer: you could be interested in the fclabels or data-accessor packages though
04:28:16 <ManateeLazyCat> gal_bolle: Infact, Yi clone many feature of Emacs, i want clone some awesome feature from Eclipse
04:28:22 <jkramer> Nah, it's not so important, I just wondered if I could get rid of the todo -> todo for prettyness :)
04:29:29 <lars9> i would like to see a vim clone in haskell...
04:29:30 <ManateeLazyCat> lars9: You can access http://goo.gl/MkVw, then you know what's i need. :)
04:29:36 <mm_freak_> ManateeLazyCat: it needs people extending it
04:30:03 <ManateeLazyCat> mm_freak_: Yes, but i need mix "hot-swapping" feature in it.
04:30:07 <mm_freak_> i don't think emacs and vim are difficult to beat quickly, if there are enough smart people, who are interested
04:30:20 <ManateeLazyCat> mm_freak_: Then people can extension it like Emacs, run-and-go in the runtime. :)
04:30:45 <lars9> ManateeLazyCat: looks cool, out of my capability
04:30:46 <ManateeLazyCat> mm_freak_: Haskeller is smart. :)
04:31:09 <ManateeLazyCat> lars9: I want build OS control by keyboard like Emacs, work extremely...
04:31:32 <ManateeLazyCat> lars9: But Emacs or Yi just design for Text world
04:31:39 <ManateeLazyCat> lars9: That's not my aim. 
04:32:41 <companion_cube> you do not need emacs to control your os with keyboard
04:32:48 <ClaudiusMaximus> anyone used the 'ad' package?  the documentation seems terse, not many examples...
04:33:27 <ManateeLazyCat> I will create a video to show how to play Manatee...
04:33:43 <ManateeLazyCat> Maybe VirtualBox image is good thing ...
04:33:53 <mm_freak_> ManateeLazyCat: haskeller is smart, but also lazy =)
04:34:05 * hackagebot alpino-tools 0.0.2 - Alpino data processing tools  http://hackage.haskell.org/package/alpino-tools-0.0.2 (DanielDeKok)
04:34:06 <ManateeLazyCat> mm_freak_: yes
04:34:33 <ManateeLazyCat> mm_freak_: I'm looking for people help me, i just have two hand, but too many TODO....
04:35:03 <ManateeLazyCat> Haskell wiki is down, I have write TODO list in http://haskell.org/haskellwiki/Manatee
04:36:15 <ManateeLazyCat> If you guys looking for download manager, i recommend use manatee-curl, it's use cache technology, so it just use 2MB memory whatever how large download file.
04:36:22 <Entroacceptor> ManateeLazyCat: have you figured out the issues between xmonad and manatee?
04:36:30 <ManateeLazyCat> Entroacceptor: Yes.
04:36:39 <ManateeLazyCat> Entroacceptor: XMonad can't focus correctly
04:36:48 <ormaaj> I do hear good things about nxml-mode. Vim is too ingrained in my brain to switch atm.
04:37:05 <ManateeLazyCat> Entroacceptor: When Manatee popup input window, XMonad can't focus correctly
04:37:16 <Entroacceptor> so there's no fix yet?
04:37:21 <ManateeLazyCat> Entroacceptor: I try to fix it, unfortunately, i'm not XMOnad guy, i give up last
04:37:23 <lars9> imo, xml is not for human processing...
04:37:25 <ManateeLazyCat> Entroacceptor: Yes.
04:37:32 <ManateeLazyCat> Entroacceptor: I don't know how to fix it.
04:37:49 <ManateeLazyCat> Entroacceptor: Looks XMonad just ignore Manatee's focus request and use it's own rule
04:38:14 <Entroacceptor> ManateeLazyCat: even with the takeFocus patches from issue 117? (I think that's the number)
04:38:32 <Entroacceptor> no, 177
04:38:33 <snoyberg> hi all
04:38:51 <snoyberg> i'm trying to run c2hs on windows, and i keep getting a "does not exist" error
04:38:56 <ManateeLazyCat> Entroacceptor: I'm *very very* busy on new features in Manatee, i perhaps won't speed time on XMOnad, of course, any patches are welcome! :)
04:39:09 <ManateeLazyCat> s/speed/spend
04:39:17 <snoyberg> a preliminary search implies this has to do with gcc, any thoughts on how to fix this?
04:39:21 <ormaaj> lars9: If that were true then standardizing a format for serializing datastructures verbosely in character data would be (is?) a very stupid idea.
04:39:37 <Entroacceptor> ManateeLazyCat: just asking if you've tried that 
04:39:49 <ManateeLazyCat> Entroacceptor: Thanks, yes, i have try it.
04:40:07 <ManateeLazyCat> Entroacceptor: I have test Manatee on Gnome and KDE, works fine.
04:40:11 <Entroacceptor> ok
04:40:40 <ManateeLazyCat> Entroacceptor: I think Manatee can works well in WM that support floating window.
04:42:11 <ManateeLazyCat> mm_freak_: If have same number developers help develop Manatee, i think it's not hard to beyond Emacs or vi.
04:44:49 <ManateeLazyCat> And manatee-process flash issue has fix in new version.
04:46:12 <ormaaj> Ha, I read /topic before pasting http://downforeveryoneorjustme.com/haskell.org. Do I win?
04:46:27 <ivanm> yes, you win an "attaboy" :p
04:46:35 <Entroacceptor> ormaaj: and a "yay!"
04:47:06 <mm_freak_> ManateeLazyCat: well, i'll certainly have a look at manatee
04:51:38 <ManateeLazyCat> mm_freak_: Any code repository for your Mail library? I perhaps rewrite code in the near future..
04:51:55 <ManateeLazyCat> All mail library on hackage is not powerful enough..
04:52:15 <ManateeLazyCat> Semi-finished products
04:54:00 <mm_freak_> ManateeLazyCat: it's not even online yet
04:54:08 <ManateeLazyCat> mm_freak_: Oh
04:54:32 <ivanm> ManateeLazyCat: http://www.haskellers.com/teams/1/
04:55:26 <mm_freak_> ManateeLazyCat: but i think i'll get the first revision done today
04:55:33 <mm_freak_> working on it right now
04:55:36 <ManateeLazyCat> mm_freak_: Cool. :)
04:56:05 <ManateeLazyCat> mm_freak_: You and John are really cool guys write protocol implement . :)
04:56:14 <mm_freak_> if you want to use it, you really should familiarize yourself with the iteratee package
04:56:50 <ManateeLazyCat> I can't believe how fast next fastirc...
04:57:30 <mm_freak_> and my function signatures are as scary as always =)
04:57:34 <ManateeLazyCat> mm_freak_: My next plan for Manatee: customize system (pdynload), IDE features, temrinal-emulator, mail-client...
04:58:33 <ManateeLazyCat> About IDE features: Code-Completion, Code-Snippet, Fly-Check (hlint)
04:58:55 <ManateeLazyCat> After terminal-emulator finish, i will integrate ghci in it.
04:59:23 <ManateeLazyCat> First step: perfect Haskell development environment, then C, and other language....
04:59:27 <mm_freak_> type MailT r m a = StateT r MailConfig (Iteratee ByteString m) a
04:59:27 <mm_freak_> runMailT :: (Functor m, Monad m) => MailConfig -> MailT a m a -> Iteratee ByteString m a
05:00:12 * hackagebot FM-SBLEX 3.0.1 - A set of computational morphology tools for Swedish diachronic lexicons.  http://hackage.haskell.org/package/FM-SBLEX-3.0.1 (MarkusForsberg)
05:00:42 <quicksilver> I love that package description.
05:00:51 <mm_freak_> hehe
05:01:10 <ManateeLazyCat> mm_freak_: I always avoid write too many monad..... keep code easy understand..
05:01:11 <quicksilver> "computational morphology" and "diachronic lexicons" are two couplets which mean absolutely nothing to me, but they definition sound good.
05:01:24 <geheimdienst> what on earth is diachronic ...
05:01:27 <geheimdienst> @wn diachronic
05:01:29 <lambdabot> *** "diachronic" wn "WordNet (r) 2.0"
05:01:29 <lambdabot> diachronic
05:01:29 <lambdabot>      adj : used of the study of a phenomenon (especially language) as
05:01:29 <lambdabot>            it changes through time; "diachronic linguistics" [syn:
05:01:29 <lambdabot>             {historical}] [ant: {synchronic}]
05:01:33 <mm_freak_> ManateeLazyCat: i don't know how to make it easier
05:01:42 <mm_freak_> without losing flexibility that is
05:02:38 <ManateeLazyCat> mm_freak_: Split framework code out, because framework can't suitable for everybody even it's really cool.
05:04:40 <yitz> quicksilver: have you ever done ffi on windows?
05:05:31 <mm_freak_> ManateeLazyCat: the protocol implementation will use a raw SMTP, and there will be a MailT for session handling…  it looks much scarier than it actually is
05:05:37 <mm_freak_> uhm
05:05:40 <mm_freak_> raw SMTP → raw Iteratee
05:06:49 <lars9> what is .hsc about?
05:06:56 <ManateeLazyCat> mm_freak_: Why not split session code out? Just plain API, let user build it's own framework
05:07:19 * hackagebot clash 0.1.2.2 - CAES Language for Synchronous Hardware (CLaSH)  http://hackage.haskell.org/package/clash-0.1.2.2 (ChristiaanBaaij)
05:07:32 * ManateeLazyCat pasted "StockItems.hsc" at http://paste2.org/get/1107067
05:07:34 <ManateeLazyCat> lars9: Something like above
05:07:44 <mm_freak_> ManateeLazyCat: i'm doing that
05:08:01 <mm_freak_> the protocol implementation will use raw Iteratee, only the session handler will use a custom monad transformer
05:08:19 * hackagebot dnscache 0.1.1 - Caching DNS resolver library and mass DNS resolver utility  http://hackage.haskell.org/package/dnscache-0.1.1 (ErtugrulSoeylemez)
05:08:21 <ManateeLazyCat> mm_freak_: Too many monad is limit, IMO.
05:08:35 <yitz> http://downforeveryoneorjustme.com/haskell.org
05:09:10 <ManateeLazyCat> mm_freak_: When i first time seen your fastirc session code, it's scary to me, i don't know how to use it flexibility, looks i need change my code to suitable your framework..
05:09:20 <ManateeLazyCat> mm_freak_: Then i develop my own irc parser.
05:09:46 <mm_freak_> ManateeLazyCat: yes, the old session code in fastirc is not flexible, but that's not because it uses monads
05:09:51 <ManateeLazyCat> mm_freak_: Lucky, i back to fastirc at last.
05:10:03 <lars9> wrapper for c lib?
05:10:08 <mm_freak_> the new one will use a monad transformer, so you can simple add it to your stack
05:10:21 <mm_freak_> simple → simply
05:10:24 <Saizan> lars9: hsc2hs is a preprocessor to help writing bindings to C libs
05:10:28 <silver_> yitz, http://new-www.haskell.org/ !
05:10:44 <lars9> Saizan: i see thanks
05:11:40 <mm_freak_> ManateeLazyCat: also it's very easy to split things out using concurrency, if you really don't want to have another monad transformer in your stack
05:11:56 <mm_freak_> ManateeLazyCat: to see how this works, read the source code of dnscache, which makes extensive use of this concept
05:12:09 <ManateeLazyCat> mm_freak_: Thanks, i will read it. :)
05:12:41 <mm_freak_> that way you can adapt an existing interface in any way you want
05:12:59 <yitz> silver_: thanks but i want the mailman archives
05:13:00 <ManateeLazyCat> mm_freak_: IMO, if you write *library* code, best don't mix framework code, let user build it's own framework....
05:13:15 <mm_freak_> i don't, so don't worry =)
05:13:34 <mm_freak_> although dnscache /is/ a framework, a think layer around the 'dns' package
05:13:40 <mm_freak_> think → thick
05:13:44 <mm_freak_> man, i can't type today
05:13:46 <ManateeLazyCat> mm_freak_: I wonder how stable your irc parser, i haven't found any bug in fastirc. :)
05:14:02 <mm_freak_> hopefully you won't, because i test my code very extensively
05:14:28 <mm_freak_> safety is my number one concern
05:14:48 <silver_> yitz, this may be http://www.mail-archive.com/haskell-cafe@haskell.org/ ?
05:15:07 <ManateeLazyCat> mm_freak_: I always test manatee-ircclient and ERC (emacs irc client), your fastirc is really fast, perhaps is Haskell much faster than elisp. :)
05:15:38 <mm_freak_> the dnscache code has been tested with a database of about 100k domain names =)
05:15:53 <ManateeLazyCat> mm_freak_: Wow,
05:15:53 <yitz> silver_: yeah i know. i like the original mailman archives best, but there are always those gmane-like things as an alternative.
05:15:55 <mm_freak_> lots of redundancy to test, if the cache is actually working
05:16:26 <ManateeLazyCat> @package dnscache
05:16:27 <lambdabot> http://hackage.haskell.org/package/dnscache
05:16:52 * ManateeLazyCat Installing dnscache
05:17:14 <mm_freak_> and it's very fast, if you use -threaded and multiple resolver threads (using them is a matter of giving a number greater than 1 to withDnsCache)
05:17:44 <ManateeLazyCat> mm_freak_'s code is always fast.... i believe that. :)
05:18:07 <mm_freak_> you can actually try out dnscache without writing code…  it comes with a command line utility 'massdns' =)
05:19:01 <ManateeLazyCat> Cool
05:20:59 <mck> hello
05:21:25 <mck> Does anyone know if there is a version of mapM that works with maps from Data.Map instead of lists?
05:21:39 <mck> I wanted to check hoogle, but it's down
05:21:48 <mm_freak_> :t Data.Foldable.mapM
05:21:49 <lambdabot> Not in scope: `Data.Foldable.mapM'
05:22:05 <mm_freak_> :t Data.Traversable.mapM
05:22:06 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
05:23:00 <gds> @hoogle is Data.Map a functor?
05:23:00 <lambdabot> Parse error:
05:23:00 <lambdabot>   --count=20 "is Data.Map a functor?"
05:23:00 <lambdabot>                     ^
05:23:02 <gds> fmap?
05:23:17 * gds starts typing one thing, and finishes another :/
05:23:21 <gds> @hoogle Data.Map
05:23:22 <lambdabot> module Data.Map
05:23:22 <lambdabot> Data.Map data Map k a
05:23:22 <lambdabot> Data.ByteString map :: (Word8 -> Word8) -> ByteString -> ByteString
05:23:47 <mm_freak_> > succ <$> M.fromList [(1,1), (2,2)]
05:23:48 <lambdabot>   fromList [(1,2),(2,3)]
05:23:55 <mm_freak_> yes, it is
05:24:12 <gds> then presumably mck wants fmap?
05:24:26 <mm_freak_> no, mck wants mapM from Data.Traversable
05:24:32 <mck> yeah
05:24:32 <gds> Oh :/
05:24:39 <mck> mapM from Traversable
05:24:54 * gds re-reads scrolback, and facepalms.
05:25:02 <mck> thanks
05:25:21 <mck> do you know what's going on with hoogle and haddock?
05:25:50 <mm_freak_> they might be married by now
05:26:11 <mm_freak_> but we won't know because of the oleg/haskell/norris paradox
05:27:20 <mm_freak_> to find out, we would need to type-check an expression, for which it takes many millions of years to finish
05:28:02 <lars9> @instances Tranversable
05:28:02 <lambdabot> Couldn't find class `Tranversable'. Try @instances-importing
05:28:32 <lars9> @instances-importing Data.Tranversable Tranversable
05:28:32 <lambdabot> Couldn't find class `Tranversable'. Try @instances-importing
05:28:45 <mm_freak_> lars9: how about leaving out the 'n'?
05:29:14 <radioactive_man> does referential transparency guarantee evaluation order independece?
05:29:25 <lars9> @instances-importing Data.Traversable Traversable
05:29:26 <lambdabot> Maybe, []
05:29:42 <mm_freak_> radioactive_man: it guarantees the the result is independent of the evaluation order
05:30:08 <radioactive_man> thx mm_freak_
05:31:52 <ManateeAuthor> gds: Hello from manatee-ircclient. :)
05:32:47 <ManateeAuthor> gds: Can you talk something in manatee-ircclient, just type words and press M-m
05:59:08 <revenantphx> Oh, haskell.org is back up.
05:59:13 <revenantphx> Might want to fix the topic now.
06:02:14 <ManateeLazyCat> Cool, haskell.org is back.
06:02:22 <ManateeLazyCat> Write some Manual on http://haskell.org/haskellwiki/Manatee
06:06:22 <ManateeLazyCat> Ok, manatee-curl manual finish now. Enjoy! :)
06:06:35 <revenantphx> So I'm curious as to how ST works >_>
06:06:53 <revenantphx> Does it just do sub-haskell level magic when ST actions are executed?
06:07:02 <revenantphx> Or is there some magic way it's implemented AS haskell.
06:07:28 <quicksilver> revenantphx: magic.
06:07:48 <quicksilver> you could say, it's implemented using IORefs behind the scenes.
06:07:52 <revenantphx> I mean, witchcraft or magic was kind of a given, since this is haskell.
06:07:52 <quicksilver> although that's not entirely honest.
06:07:58 <revenantphx> Be honest thne!
06:08:19 <quicksilver> in GHC, IO and ST are both implemented using the same underlying primitive.
06:08:30 <revenantphx> Hm.
06:08:36 <quicksilver> in fact, IO is a special case of ST rather than the other way around.
06:08:40 <revenantphx> 0.o
06:08:46 <quicksilver> but that's an implementation detail, not a semantic one.
06:08:57 <quicksilver> Unfortunately, it appears to be impossible to implement ST in pure haskell
06:09:02 <quicksilver> because of 'newSTRef'.
06:09:30 <quicksilver> you can easily enough manage a heap of typed values, but being able to construct a new reference of arbitrary type is hard.
06:09:39 <quicksilver> I personally think this is quite an interesting problem.
06:09:43 <quicksilver> but I'm not sure what to learn from it.
06:09:54 <revenantphx> right >_>
06:10:31 <quicksilver> you could use Data.Dynamic to get something quite close
06:10:44 <quicksilver> you'd get newSTRef :: Typeable a => ST (STRef a)
06:10:50 <quicksilver> i.e. not quite fully polymorphic.
06:10:59 <quicksilver> But, of course, you can't implement Data.Dynamic in pure haskell either.
06:11:53 <Palmik> Hi, do you folks know of any clever function converting [Bool] to [Word8] and vice versa? So that it would convert [Bool] of size 16 to [Word8] of size 2, or [Bool] of size 3 to [Word8] of size 1, etc.
06:12:09 <ManateeLazyCat> If you want to how to play see http://haskell.org/haskellwiki/Manatee , i will create some video soon, thanks! :)
06:12:40 <ManateeLazyCat> @hoogle Bool -> Word8
06:12:40 <lambdabot> Foreign.Marshal.Utils fromBool :: Num a => Bool -> a
06:12:40 <lambdabot> Control.Exception assert :: Bool -> a -> a
06:12:40 <lambdabot> Control.OldException assert :: Bool -> a -> a
06:12:54 <ManateeLazyCat> Palmik: fromBool
06:13:03 <ManateeLazyCat> @hoogle toBool
06:13:03 <lambdabot> Foreign.Marshal.Utils toBool :: Num a => a -> Bool
06:13:12 <ManateeLazyCat> Palmik: ^^^^
06:13:56 <Palmik> Hmm, from the signature it seems it does not convert list of Bools...
06:14:16 <ManateeLazyCat> Palmik: List is simple. map . fromBool
06:14:22 <ManateeLazyCat> :t map . fromBool
06:14:23 <lambdabot> Not in scope: `fromBool'
06:14:33 <ManateeLazyCat> :t map . Foreign.Marshal.Utils.fromBool
06:14:34 <lambdabot> forall a b. (Num b) => Bool -> [a] -> [b]
06:14:39 <ManateeLazyCat> :t map . Foreign.Marshal.Utils.toBool
06:14:40 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Bool'
06:14:40 <lambdabot>     Probable cause: `Foreign.Marshal.Utils.toBool' is applied to too many arguments
06:14:40 <lambdabot>     In the second argument of `(.)', namely
06:14:41 <Palmik> Sure... but that is not really what I meant by "clever" conversion
06:14:58 <Palmik> "So that it would convert [Bool] of size 16 to [Word8] of size 2"
06:15:38 <ManateeLazyCat> I don't know what you mean.
06:15:41 <ClaudiusMaximus> preflex: seen edwardk
06:15:41 <preflex>  edwardk was last seen on #haskell 3 days, 9 hours, 40 minutes and 26 seconds ago, saying: osunders: yes
06:16:39 <quicksilver> ManateeLazyCat: palmik means packing the bits
06:17:38 <quicksilver> I think one of the uvector things has a bit-packed bool vector but I'm not sure.
06:17:45 <Palmik> Well, Bool can be represented in 1 bit of data... Word8 can store 8 bits of data, so I thought that there might be some function doing the conversion from [Bool] to [Word8] and vice versa. Of course if the [Bool]'s length would not be multiple of 8, it would have to add some "redundant" bits
06:18:31 <Palmik> quicksilver, ah, did not know the expression of bit-packing, thanks, it should help while searching :)
06:18:33 <ManateeLazyCat> Palmik: you can write some code do that, not hard to implement
06:20:44 <Palmik> ManateeLazyCat, I hope I can :D If I can not find some existing solution that is :)
06:22:03 <ManateeLazyCat> Any exist tool scan .cabal file to get foo-x.x.x.tar.gz and do "cabal sdist && cabal upload ./dist/foo-x.x.x.tar.gz" ? I perhaps try write some code for this.
06:25:22 <Palmik> Hmm, found this in PNG library http://codepad.org/fe0BX25n
06:26:15 <revenantphx> so... does newTVarIO just do the something equivallent to atomically $ newTVar
06:26:34 <revenantphx> do something*
06:27:48 <ManateeLazyCat> revenantphx: Much faster than that.
06:27:56 <revenantphx> So it's some low level optimized version?
06:28:00 <ManateeLazyCat> revenantphx: Read the comment of newTVarIO
06:28:12 <ManateeLazyCat> revenantphx: Yes, optimized version
06:28:14 <revenantphx> "IO version of newTVar. This is useful for creating top-level TVars using System.IO.Unsafe.unsafePerformIO, because using atomically inside System.IO.Unsafe.unsafePerformIO isn't possible."
06:28:21 <revenantphx> I don't exactly know what unsafe stuff is.
06:28:37 <ManateeLazyCat> @package cabal-query
06:28:38 <lambdabot> http://hackage.haskell.org/package/cabal-query
06:28:41 * hackagebot regex-tdfa 1.1.7 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-tdfa-1.1.7 (ChrisKuklewicz)
06:31:34 <ClaudiusMaximus> @tell edwardk managed to hack some hacky multi-dimensional root-finding together with 'ad' and 'Vec', if you're interested: http://hpaste.org/41772/4d_root_finding_with_ad_and
06:31:34 <lambdabot> Consider it noted.
06:33:34 <revenantphx> ... so it seems that STM could be used for general state too.
06:34:21 <revenantphx> Well, in my ant simulation it'd work just fine.
06:34:22 <ManateeLazyCat> revenantphx: Yes, STM is lock-free concurrent solution.
06:34:30 <revenantphx> It's quite nice :P
06:34:59 <quicksilver> the main advantage over MVar is transactional semantics though
06:35:11 <revenantphx> MVar?
06:35:20 <revenantphx> Is that for ST?
06:35:25 <ManateeLazyCat> revenantphx: You can read book "Beautiful Code", have one chapter describe STM "how to work"
06:35:35 <ManateeLazyCat> revenantphx: MVar is lock solution.
06:35:42 <revenantphx> ManateeLazyCat: I spent 4 hour last night, and I went all the way through that ManateeLazyCat 
06:35:57 <revenantphx> That specific PDF
06:38:20 <ManateeLazyCat> revenantphx: Simple, STM is implement by "Thread Log", many concurrent threads do calculate on TVar, current thread will check TVar value when it do *write* operation, it will rollback action if conflict with other threads.
06:38:45 <revenantphx> Yes, I saw that.
06:39:31 <ManateeLazyCat> revenantphx: If keep STM code little enough, it's won't conflict too much, and performance is improve.
06:40:04 <ManateeLazyCat> revenantphx: Of course, STM is not silver bullet, some situation, MVar (lock solution) is better. :)
06:40:18 <revenantphx> of course
06:42:06 <ManateeLazyCat> revenantphx: Most important is, STM frees up your head, you don't need think : when time lock, when time unlock, lock is enough? Or too much lock? Those problem will crazy you when project is very big.
06:42:18 <revenantphx> Yep.
06:42:29 <revenantphx> I've written servers and had to deal with shared state.
06:42:46 <revenantphx> My general solution is to restrict access to shared state through queueing.
06:42:53 <Jafet> It's crazied enough of our eminent theorists in the past already
06:43:03 <\mjd> revenantphx:  the original STM paper is very readable; I found it extremely inspiring.
06:43:10 <revenantphx> Yeah, I'm reading it right now.
06:43:21 <revenantphx> I like the queueing plan too in any case.
06:43:48 <revenantphx> The only catch 22 is that you have to ensure everything is willing to wait asynchronously for it to get state.
06:43:50 <ManateeLazyCat> revenantphx: Yes, queueing can work, but bad performance, you know . :)
06:43:53 <revenantphx> So it's not modular at *all*
06:44:11 <revenantphx> ManateeLazyCat: Not always, I've gotten perfectly good performance from queueing access to a buffer of data.
06:44:21 <revenantphx> libdispatch helps significantly.
06:44:48 <mm_freak_> IMO STM generally doesn't reduce performance, because it just does implicitly, what you would otherwise do explicitly:  add threads
06:44:50 <ManateeLazyCat> revenantphx: Maybe you can write STM version to compare. :)
06:44:55 <revenantphx> heh
06:44:58 <revenantphx> it lets me have the queue enqueue the actual state transformations, which is nice.
06:45:21 <quicksilver> mm_freak_: well, STM causes a problem if you get excessive retrying
06:45:35 <revenantphx> So I can have each thing passing in transformations and accesses to the state, which are done one at a time.
06:45:36 <quicksilver> being more abstract, it's possibly harder to anticipate and diagnose that kind of thing.
06:45:42 <revenantphx> In a sense, it's actually kind of reminiscent of ST.
06:46:12 <ManateeLazyCat> quicksilver: Sometimes, retry is better than lock crazy. :)
06:47:28 <quicksilver> ManateeLazyCat: retrying is not a problem. Excessive retrying is a problem.
06:47:34 <quicksilver> livelock is just as bad as deadlock.
06:47:37 <ManateeLazyCat> quicksilver: Yes.
06:48:11 <ManateeLazyCat> quicksilver: I found STM will fall in infinite retry in some situation... :)
06:48:19 <quicksilver> revenantphx: almost all ways to make concurrency deterministic are based on serialisation. In a sense, that makes them all like ST.
06:48:42 <mm_freak_> quicksilver: true
06:48:44 <revenantphx> Yeah.
06:51:22 <RichardBarrell> quicksilver: I'd say that livelock is distinctly worse.
06:51:41 <quicksilver> RichardBarrell: yes, I think I agree.
06:51:59 <Cale> Well, it's a harder problem to solve
06:52:07 <RichardBarrell> Having hit livelock happen on a production webserver once on an important site, I can say for certain that having everything else on the same machine suddenly slow to a crawl for several hours sucks.
06:53:38 <RichardBarrell> Cale: I'm speaking here as a sysadmin then rather than as a programmer. (I do both jobs to a certain extent, though I prefer to think of myself primarily as a programmer). Deadlock kills *one* process, livelock takes the entire machine down.
06:54:03 <mm_freak_> what's a livelock?
06:54:16 <Cale> Well, not necessarily... livelock just means that the system makes progress but some transactions never get to finish.
06:54:25 <sipa> starvation?
06:54:33 <quicksilver> mm_freak_: generically, it's any circumstance in which a program keeps running but some part 'fails to progress'
06:54:46 <mm_freak_> ghci took my machine down several times (i remember my first memory leak, which did that:  sort [1..])
06:55:02 <RichardBarrell> That's not a memory leak, that's an attempt to use infinite space. :)
06:55:07 <mm_freak_> quicksilver: doesn't sound like something, which would take the entire machine down
06:55:12 <Cale> This can result in ridiculous resource usage, but it might not -- there might just be one thing which is supposed to happen and never does.
06:55:31 <mm_freak_> RichardBarrell: yes, it was rather ironical
06:56:23 <Cale> A nice thing about STM is that it's an abstraction which is independent of transaction scheduling.
06:56:52 <mm_freak_> can you give me an example of a livelock?
06:56:53 <Cale> So GHC can be fixed up to help ensure that progress will be made on long-lived transactions.
06:57:00 <mm_freak_> i'm not sure i understand what it is
06:57:07 <Cale> mm_freak_: Do you know about STM?
06:57:10 <mm_freak_> sounds like something like a race condition
06:57:15 <sipa> i'm not sure even everyone here defines it the same way :)
06:57:21 <mm_freak_> Cale: only how to use it, not how to implement it
06:58:03 <RichardBarrell> mm_freak_: we had a big livelock incident a while back. We use a graph database called ZODB in production, which implements (approximately) persistent STM, and we had a piece of code that caused a single specific object to get written to on by very large number of concurrent transactions.
06:58:32 <Cale> mm_freak_: Okay, well, when transactions complete, they check to see if any TVar they read up to that point still has the value that they read. If it doesn't, it means that some other transaction completed first and invalidates the computation which was done. So the transaction retries.
06:59:23 <Cale> mm_freak_: If you schedule transactions naively, short transactions which write to some variables can stomp all over long transactions which read from a bunch of stuff.
06:59:34 <RichardBarrell> mm_freak_: (by "we" I mean the company I work for). So some of those transactions did succeed, but the back-out-and-retry-on-conflict process caused the box to get pegged at 100% CPU.
06:59:36 <Cale> (GHC is somewhat naive still)
06:59:58 <mm_freak_> i see
07:00:14 <RichardBarrell> Cale: if you can stomach Python, I recommend that you have a look into ZODB. You may find it more familiar than enlightening. :)
07:00:37 <mm_freak_> so my intuition wasn't that far off
07:00:39 <Cale> and it's bad because the long-running transactions are usually the most expensive to compute, and they're the ones which are going to be reattempted over and over
07:01:08 <mm_freak_> sounds really like a special race condition
07:01:19 <Cale> So, to fix this, one thing that the system could do is to prioritise transactions according to how many times they've been blocked like this.
07:01:24 <ManateeLazyCat> mm_freak_: Worse than that. :)
07:01:37 <ManateeLazyCat> mm_freak_: STM never stop in that situation. :)
07:01:50 <Cale> Well, worse and better.
07:02:03 <Cale> The system doesn't stop or compute incorrect results.
07:02:11 * geheimdienst was taught "try to lock, if you didn't get it retry" was called busy waiting and was generally a smelly thing
07:02:48 <Cale> geheimdienst: It's also not quite the same as busy waiting.
07:02:52 <mm_freak_> hmm…  but that sounds like a problem, which you can't really solve at the STM user level
07:02:55 <zygoloid> seems like you could quite easily make STM guarantee to run at at least 1x the sequential speed of the code
07:02:59 <Cale> geheimdienst: Though it can approximate that behaviour.
07:03:08 <mm_freak_> in other words:  if your code suffers from a livelock, get a better STM library
07:03:49 <Cale> When the transaction retries, it's sure to be different in some way, because some of the variables that it observed must have changed already.
07:03:54 <geheimdienst> cale, i was referring more to the story of nomming 100% of the production server's cpu ...
07:03:58 <Cale> yeah
07:04:50 <geheimdienst> cale: that's a good point. so in the same state, you don't try a million times, only once
07:05:20 <FunctorSalad> zygoloid: if you have multiple cpus? ;)
07:05:34 <revenantphx> mm_freak_: livelock is when a system is "deadlocked in motion"
07:05:41 <revenantphx> Like a sine wave, it's stuck in the same repetition.
07:06:05 <revenantphx> ie, you're walking in the opposite direction of some one on the sidewalk, and when you move to the side to let them pass, they move the same way.
07:06:10 <revenantphx> And you keep doing that back and forth.
07:06:10 <mm_freak_> well, it isn't certain that a retrying transaction retries in a changed environment
07:06:18 <revenantphx> You two are now livelocked.
07:06:33 <mm_freak_> revenantphx: yeah, i got that
07:06:34 <Cale> revenantphx: The difference in STM is that someone's always making progress.
07:06:50 <Cale> revenantphx: But there might be some threads which never do.
07:07:06 <Cale> (using GHC's existing scheduler, at least)
07:07:28 <mm_freak_> that also means, livelocks can actually only happen in looping code…  if the code is guaranteed to have a path to the result, then a livelock is guaranteed to be resolved, right?
07:07:31 <geheimdienst> so starvation can still occur
07:07:57 <revenantphx> I can see how STM would be *really* easy to use for a server though.
07:08:12 <revenantphx> You have one thread reading from each client, which just tries to perform transformations on TVars
07:08:16 <mm_freak_> i've never used STM in production
07:08:28 <revenantphx> mm_freak_: what do you do?
07:08:38 <ManateeLazyCat> mm_freak_: I use STM lots in Manatee.
07:08:38 <mm_freak_> revenantphx: mostly MVar and concurrency
07:08:46 <revenantphx> How does MVar work?
07:08:46 <ManateeLazyCat> mm_freak_: I always mix TVar and MVar
07:08:52 <ManateeLazyCat> revenantphx: MVar is lock
07:08:55 <revenantphx> I see.
07:09:09 <revenantphx> so... it's a lock in monad form?
07:09:10 <mm_freak_> revenantphx: an MVar is a basket…  one thread puts, the other takes
07:09:26 <mm_freak_> taking an empty MVar blocks, putting a full MVar blocks
07:09:26 <revenantphx> I... see...
07:09:31 <revenantphx> Oh ok.
07:09:38 <revenantphx> That sounds reasonable.
07:09:48 <revenantphx> I'm noticing that concurrency in functional languages is a bit easier.
07:09:54 <quicksilver> that's not the only way to use an MVar
07:10:01 <quicksilver> there are a number of MVar disciplines.
07:10:01 <mm_freak_> yeah, it's a great concept especially when collecting results from many threads
07:10:11 <revenantphx> Since mutable state has to be so... "wrapped"
07:10:12 <mm_freak_> or when many threads talk to a single one
07:10:27 <revenantphx> mm_freak_: like a bunch of client threads talking to the main run loop.
07:10:27 <quicksilver> you can also use it as a shared variable, where the rule is "always put it back straight after you read it"
07:25:07 --- mode: lindbohm.freenode.net set +o ChanServ
07:27:03 <mm_freak_> @src readMVar
07:27:03 <lambdabot> readMVar m = block $ do
07:27:03 <lambdabot>     a <- takeMVar m
07:27:03 <lambdabot>     putMVar m a
07:27:03 <lambdabot>     return a
07:27:27 <mm_freak_> hmm
07:27:38 <mm_freak_> i always thought readMVar is atomic
07:27:51 <paolino> @src block
07:27:52 <lambdabot> Source not found. My mind is going. I can feel it.
07:28:14 <mm_freak_> but anyway, IORefs are probably better for shared variables…  they are faster and have an atomic modifier
07:29:02 <revenantphx> What is an IORef defined as?
07:29:02 <mm_freak_> i'd say if you need to take and put back, then you're using MVars improperly
07:29:13 <mm_freak_> revenantphx: it's just a mutable variable
07:29:14 <ClaudiusMaximus> arghh, i don't know which is worse, or how to solve this...
07:29:15 <ClaudiusMaximus> The first argument of `Functor' should have kind `* -> *', but `Vec4 a' has kind `*' In the instance declaration for `Functor (Vec4 a)'
07:29:18 <ClaudiusMaximus> Type synonym `Vec4' should have 1 argument, but has been given 0 In the instance declaration for `Functor (Vec2)'
07:29:41 <ClaudiusMaximus> first is with type variable, second is without - neither works
07:29:53 <mm_freak_> ClaudiusMaximus: you can't use partially applied type synonyms in instances
07:29:56 <paolino> newtype ?
07:30:11 <ClaudiusMaximus> mm_freak_: so i've gathered
07:31:09 <ClaudiusMaximus> paolino: hm, the type synonyms aren't mine - i'm trying to integrate 'Vec' with 'ad' in a way that doesn't smell like hammers
07:33:00 * ManateeLazyCat pasted "What is manatee-curl ?" at http://paste2.org/get/1107320
07:33:13 * ClaudiusMaximus tries with newtypes
07:35:07 <paolino> ClaudiusMaximus: I have no idea if a type synonym can be instantiated to a class for * -> * types
07:36:35 <paolino> it has to be a * -> * kind which Vec4 is not
07:36:43 <quicksilver> mm_freak_: hmm. it's a good point. for some reason I've always not done that because I just think 'multiple threads, you should use MVar'
07:36:55 <quicksilver> mm_freak_: but you're right, there seems to be no good reason not to use IORefs for that.
07:37:14 <quicksilver> (unless you have to modify multiple ones transactionally. In which case you might consider STM anyway)
07:37:50 <paolino> ClaudiusMaximus: can you say type MyVec = Vec ?
07:37:56 <ManateeLazyCat> G'night all. :)
07:37:56 <quicksilver> paolino: no.
07:38:06 <quicksilver> you can't create instances for partially applied type synonyms.
07:38:10 <quicksilver> newtypes will work.
07:38:28 <revenantphx> newtype vs data?
07:38:36 <quicksilver> you can only create instances with type synonyms in cases where just substituting the definition of the type would also be legal.
07:38:37 <revenantphx> optimizatio nthing?
07:38:47 <quicksilver> revenantphx: newtype is no runtime cost
07:38:55 <quicksilver> revenantphx: data is adding another box
07:39:42 <revenantphx> ...right
07:39:46 <revenantphx> so what's the advantage of data then.
07:40:01 <quicksilver> data allows multiple constructors.
07:40:10 <revenantphx> ah, gotcha
07:40:17 <sipa> and allows more lezyness in the case of only a single constructor with one element 
07:40:25 <sipa> *lazyness
07:40:36 <ClaudiusMaximus> newtypes seem to be working, now i'm into hairier errors
07:40:36 <sleepynate> can we leave it at lezyness?
07:40:44 <paolino> quicksilver: is that unavoidable "you can't create instances for partially applied type synonyms." or is a difficult task for the compiler ?
07:41:56 <quicksilver> paolino: it makes the system much more expressive. 
07:42:08 <quicksilver> it perhaps arbitrary type-lambdas in class instances
07:42:12 <quicksilver> s/haps/mits/
07:42:26 <quicksilver> so, yes, it makes it much harder to write the compiler
07:42:35 <quicksilver> and it creates ambiguity/instance search problems
07:42:44 <quicksilver> (or overlap detection problems, depending how you view it)
07:43:08 <quicksilver> because a particular thing might be interpreted as a partially applied type synonym in multiple different ways
07:43:22 <paolino> so rule of the thumb, always export newtypes
07:43:42 <quicksilver> rule of thumb - never use type synonyms
07:43:45 <quicksilver> they're almost useless :)
07:43:55 <paolino> uh, I use tons
07:43:55 <revenantphx> How o?
07:44:02 <revenantphx> they can make the code a lot easier to read >_>
07:44:08 <paolino> signatures
07:44:09 <quicksilver> they're a kind of weak documentation or slightly strange macro for saving the number of chars you have to type.
07:44:13 <quicksilver> but they're not really an abstraction.
07:44:32 <revenantphx> But they do serve some purpose then.
07:44:53 <quicksilver> sure.
07:45:00 <quicksilver> "almost" useless ;)
07:45:08 <revenantphx> >_>
07:45:33 <paolino> @hoogle Vec
07:45:34 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
07:45:43 <paolino> @hoogle Vec4
07:45:44 <lambdabot> No results found
07:46:32 <ClaudiusMaximus> @hackage Vec
07:46:32 <lambdabot> http://hackage.haskell.org/package/Vec
07:46:57 <paolino> if it's a type synonym , write the instance for the concrete type it refers to which must be partially applyable 
07:47:35 <ClaudiusMaximus> i'm in a world of pain of functional dependencies and type-level numbers and trying to derive Functor
07:47:51 <ClaudiusMaximus> maybe i should give up while i can still think :)
07:48:31 <paolino> instance Functor (a :.) where ...
07:48:33 <paolino> eheh
07:50:27 <revenantphx> :t ($=)
07:50:27 <lambdabot> Not in scope: `$='
07:50:34 <revenantphx> :\, what the hell is $=
07:50:35 <ClaudiusMaximus> it's more the "type Vec4 a = a :. a :. a :. a :. ()" stuff, for which i have made a newtype with a Functor instance, but the general case is hard...
07:50:52 <revenantphx> @hoogle $=
07:50:52 <lambdabot> No results found
07:50:55 <revenantphx> >_>
07:50:56 <ClaudiusMaximus> @hoogle ($=) +StateVar
07:50:56 <lambdabot> No results found
07:51:07 <revenantphx> @hoole ($=)
07:51:08 <lambdabot> No results found
07:51:18 <revenantphx> @hoogle ($=)
07:51:19 <lambdabot> No results found
07:51:33 <ClaudiusMaximus> http://hackage.haskell.org/packages/archive/StateVar/1.0.0.0/doc/html/Data-StateVar.html#2
07:51:43 <mm_freak_> quicksilver: yeah, you can't modify MVars transactionally anyway
07:52:08 <quicksilver> mm_freak_: yes, you can. You take all the ones you need, modify them all, and then put them all back
07:52:13 <revenantphx> So what is Data.StateVar?
07:52:34 <quicksilver> mm_freak_: but of course this blocks other threads, and can deadlock if you don't observe some disciplines about the order of acquiring/releasing MVars
07:52:41 <quicksilver> mm_freak_: a.k.a. it's not a great solution :)
07:52:48 <ClaudiusMaximus> the only time i really use 'type' is things like 'type N = Integer; type Q = Ratio N; type R = Double ; type C = Complex R', but this may be obfuscatory and only to save typing...
07:52:52 <paolino> STM!
07:53:05 <quicksilver> paolino: yes. We know. It is STM we are discussing.
07:53:21 <ClaudiusMaximus> revenantphx: it's an abstraction over various kinds of state-storing variable references
07:53:24 <quicksilver> revenantphx: Data.StateVar is an openGL abstraction over "things in IO which have getters and setters in IO"
07:53:33 <revenantphx> I see.
07:53:39 <revenantphx> So it's used for OGL related stuff?
07:53:46 <quicksilver> revenantphx: IORefs are an instance of it, but so could various C-library-maintained state
07:53:48 <paolino> quicksilver: I'm just a fan, sorry 
07:53:51 <quicksilver> paolino: :)
07:53:56 <quicksilver> paolino: and rightly so. It's great.
07:54:37 <paolino> when I type `orElse` I feel happy
07:54:53 <quicksilver> revenantphx: eg, if libfoo provides functions foo_set_frobnicator(void*frobnicator) and void* foo_get_frobnicator() you could FFI bind that and make it into a StateVar
07:55:19 <revenantphx> I see.
07:55:35 <paolino> (because javaers don't have it )
07:55:56 <revenantphx> When I type "common sense" I feel happy
07:56:01 <revenantphx> (because javaers don't have it)
07:56:08 * jmcarthur isn't a huge fan of StateVar
07:56:22 <jmcarthur> but i'm not a fan of opengl's statefulness in the first place
07:56:26 <revenantphx> I can use the use for something like OpenGL
07:56:37 <revenantphx> jmcarthur: how else would you have OpenGL?
07:56:43 <jmcarthur> umm stateless? :)
07:56:45 <revenantphx> I mean, the shader model addresses a lot of that concern.
07:56:51 <revenantphx> It's significantly less stateful in general.
07:57:14 <revenantphx> All traces of stacks, matrices and such are gone (and left to you to manage however you'd like)
07:57:35 <quicksilver> jmcarthur: are you really not a fan of StateVar? Or just not a fan of random chunks of state in IO?
07:58:11 <quicksilver> jmcarthur: I'm not a fan of random chunks of state hidden in IO, but given that such thing exist, particularly in C libraries, it seems quite cromulent to have a standard interface to make them look like lvalues.
07:58:27 <revenantphx> cromulent :3
07:58:29 <jmcarthur> quicksilver: for one i normally don't want an operator for get/set, so there's the syntactic part of it. aside from that, yeah, it's mainly that i just don't like those random chunks of state.
07:58:57 <jmcarthur> quicksilver: well, my preference would be for bindings to make it more idiomatic or to use wrappers to do the same
07:59:06 <jmcarthur> it's more work to make of course
07:59:09 <quicksilver> jmcarthur: thanks to StateVar, I can simply and easily write "with [ foo := bar ] doThis
07:59:26 <quicksilver> jmcarthur: without a common interface to statevars, I'd have special cases for all foo.
07:59:30 <jmcarthur> revenantphx: you still end up having to screw around with bindings and texture units and all kind of fun stuff
07:59:37 <revenantphx> This is ture.
07:59:48 <revenantphx> But hey, it's way more fun to just have it all procedurally generated :D
08:00:14 <jmcarthur> quicksilver: that assumes the presence of state in the first place though
08:00:31 <quicksilver> jmcarthur: right.
08:00:38 <revenantphx> I find this incredible
08:00:39 <revenantphx> http://www.youtube.com/watch?v=i1KWhPKlvY4
08:00:41 <jmcarthur> my point is just that opengl doesn't really *need* state, especially now that we are largely on the programmable pipeline and stuff
08:00:45 <revenantphx> procedural and mind blowing.
08:00:56 <quicksilver> jmcarthur: ok, well you're preaching to the choir there.
08:00:58 <jmcarthur> statevar is just something for me to attack out of frustration
08:01:04 <jmcarthur> :)
08:01:25 <ManateeLazyCat> Many haskeller work for Microsoft, i wonder Microsoft support them develop Open-Source project. :)
08:01:48 <ManateeLazyCat> Why Microsoft support Haskell?
08:01:49 <quicksilver> microsoft research is an interesting place, ManateeLazyCat, and not much like Microsoft Corp.
08:02:14 <jmcarthur> revenantphx: yeah i started writing a little sphere tracer like that recently too
08:02:17 <mm_freak_> quicksilver: that's my point
08:02:25 <quicksilver> mm_freak_: then we agree :)
08:02:33 <mm_freak_> =)
08:02:38 <jmcarthur> revenantphx: the technique is actually very simple
08:02:46 <revenantphx> I'm no GL expert :P
08:02:47 <revenantphx> explain?
08:03:03 <ManateeLazyCat> quicksilver: I'm looking for Haskell job, i wonder Microsoft need haskell programmer now. :)
08:03:10 <jmcarthur> revenantphx: i'm not sure if RGBA is using the gpu for that at all, but it's possible to do
08:03:20 <revenantphx> Its done entirely in a shader/
08:03:22 <revenantphx> Under 4kb.
08:03:24 <jmcarthur> revenantphx: basically you just throw up a big quad and use the fragment shader to do raytracing
08:04:00 <jmcarthur> revenantphx: personally i think there are far more impressive examples of the technique out there
08:04:06 <revenantphx> True.
08:04:09 <revenantphx> what's the other one
08:04:20 <revenantphx> Leizex is cooler imo.
08:04:26 <revenantphx> but there was another I'd seen before...
08:04:27 <revenantphx> nmd
08:04:55 <jmcarthur> revenantphx: i think this uses the technique http://www.youtube.com/watch?v=VG2Fomp4aXc
08:05:10 <revenantphx> I'd like to know how the hell Elevated was done :P
08:05:21 <jmcarthur> revenantphx: elevated is more traditional
08:05:31 <jmcarthur> directx
08:06:08 * hackagebot tskiplist 0.0.0 - A Skip List Implementation in STM  http://hackage.haskell.org/package/tskiplist-0.0.0 (PeterRobinson)
08:06:29 <revenantphx> The flashing cubes in that one are pretty . >
08:06:31 <revenantphx> so shiiiny.
08:06:42 <RichardBarrell> ManateeLazyCat: you know that it's Microsoft Research who employ Peyton `Simon` Jones, right? :)
08:06:52 * ManateeLazyCat Write some code to implement cabal pack/upload automatically.
08:07:02 <ManateeLazyCat> RichardBarrell: Yes,
08:07:09 <revenantphx> Why are you infixing his name?
08:07:15 <ManateeLazyCat> RichardBarrell: I remember Simon is also at Microsoft research...
08:07:15 <revenantphx> Out of curiosity.
08:07:24 <ManateeLazyCat> RichardBarrell: Another Simon..
08:07:27 <jmcarthur> marlow
08:07:38 <ManateeLazyCat> jmcarthur: Yes.
08:07:45 <RichardBarrell> jmcarthur: thanks, that was going to bug me all day.
08:07:45 <jmcarthur> "the Simons" they are sometimes called
08:08:00 <geheimdienst> the [Simon]
08:08:03 <revenantphx> OH GOD IT'S A MENGER SPONGE
08:08:13 <jmcarthur> Pair Simon
08:08:19 <jmcarthur> well
08:08:23 <jmcarthur> data Pair a = Pair a a
08:08:24 <revenantphx> (IfI saw a giant menger sponge hurtling through space, I'd be terrified.
08:08:39 <ManateeLazyCat> Axel Simon (author of gtk2hs), so many Simons... :)
08:08:53 <tab> revenantphx: the borg ?
08:09:00 <revenantphx> No no, a menger sponge.
08:09:04 <revenantphx> Borg cube is not nearly as bad.
08:09:07 <ManateeLazyCat> RichardBarrell: And i found many haskeller at UK. 
08:09:18 <tab> revenantphx: look fairly similar to a menger sponge :P
08:09:31 <revenantphx> Are borg cubes fractal?
08:09:34 <revenantphx> No. didn't think so.
08:09:44 <RichardBarrell> Surprisingly many universities in the UK teach Haskell at undergrad level in order to introduce students to FP.
08:09:50 <tab> well for starter they are both cubes ;p
08:09:54 <dons> skip lists, interesting!
08:10:02 <revenantphx> Not really.
08:10:09 <ManateeLazyCat> dons: Looks manatee-curl
08:10:12 <revenantphx> also, the borg cube has volume, the menger sponge doesnt. :P
08:10:13 <ManateeLazyCat> @package manatee-curl
08:10:13 <lambdabot> http://hackage.haskell.org/package/manatee-curl
08:10:27 <dons> good work!
08:10:29 <revenantphx> borg cube has limited surface area, menger sponge has infinite surface area.
08:10:38 <ManateeLazyCat> dons: Less memory usage than download-curl and support multi-threads and resume download.
08:11:00 <ManateeLazyCat> dons: Like this : http://www.flickr.com/photos/48809572@N02/5201586350/lightbox/
08:11:29 <dons> nice!
08:11:33 <tab> revenantphx: they should probably upgrade the borg cube then
08:11:36 <ManateeLazyCat> dons: Thanks code for download-curl, i copy some code (gather) in it. ;p
08:11:39 <revenantphx> Yeah seriously.
08:11:51 <dons> i'm glad you found it useful.
08:12:07 <ManateeLazyCat> dons: 4MB 1 thread need 30s, 4MB 4 threads just need 20s or less.
08:12:19 <ManateeLazyCat> dons: I plan add "mirror download" in the future version.
08:12:26 <quicksilver> RichardBarrell: really? that many? I thought it was just a handful.
08:12:36 <ManateeLazyCat> dons: That's mean you can download different part of file from *different* server.
08:13:00 <ManateeLazyCat> dons: Then you can fork 100+ threads download file and don't care the "thread limit* of server.
08:13:25 <ManateeLazyCat> dons: Now just can download different part of file from *same* server.
08:13:32 <dons> huh. that's interesting. distributed downloads.
08:13:39 <ManateeLazyCat> dons: Yes.
08:13:50 <dons> you'll end up with a bittorrent client :)
08:14:06 <tab> is using curl better than using a native haskell client ?
08:14:10 <dom96> wow, nice idea.
08:14:17 <ManateeLazyCat> dons: Oh, i will write standalone BT-client, because it's need handle upload.
08:14:29 <ManateeLazyCat> dons: And BT protocol is special need special code..
08:15:03 <tab> i guess my question is, what's missing from native client lib compared to curl ?
08:15:12 <RichardBarrell> quicksilver: that's still surprisingly many. ;)
08:15:22 <ManateeLazyCat> tab: curl can use for many protocol....
08:15:34 <dons> yep. we have some code already: http://hackage.haskell.org/package/Combinatorrent
08:16:31 <quicksilver> RichardBarrell: ;) 
08:16:33 <tab> ManateeLazyCat: right ok, i didn't know that
08:16:59 <ManateeLazyCat> dons: Only difference with BT, i don't need upload to other people, i just need "smart spider* search same file in internet. :)
08:18:10 <ManateeLazyCat> dons: Something like build distributed spider use different proxy server search special link through Google, but Google don't know that. :)
08:19:56 <ManateeLazyCat> I hope i can find some time write Twitter-client....
08:20:19 <revenantphx> I just had a bad premonition.
08:20:27 <revenantphx> I realized that if I learn how to use GLUT with haskell...
08:20:34 <revenantphx> I may throw myself into months of fractals.
08:20:52 <RichardBarrell> Go for it.
08:21:20 <Darkone> Bloody hell.
08:21:31 <Darkone> Haskell is easy compared to trying to figure out grobocode >.<
08:21:40 <ManateeLazyCat> revenantphx: Why not use gtk2hs? :)
08:21:49 <revenantphx> Well, for GL drawing :P
08:21:57 <ManateeLazyCat> revenantphx: gtk2hs is complete and stable. :)
08:22:12 <ManateeLazyCat> revenantphx: You can use GL code in gtk2hs.
08:22:24 <romildo> Is there a standard function to convert from "Either a b" to "Maybe b" ?
08:22:32 <ManateeLazyCat> revenantphx: http://code.haskell.org/gtkglext/demo/
08:22:33 <revenantphx> But I'd have to go through more of a pain in the ass >_>... the basics provided by GLUT are enough for now.
08:22:42 <quicksilver> romildo: I don't think so.
08:22:51 <quicksilver> :t either (const Nothing) Just
08:22:51 <revenantphx> I'll use a more complex windowing system when the need arrives.
08:22:52 <lambdabot> forall a a1. Either a1 a -> Maybe a
08:23:30 <edlinde> has anyone here read "The craft of fp" - Thompson?
08:23:44 <quicksilver> :t \y -> (do Right x <- y; return x)
08:23:44 <lambdabot> forall (m :: * -> *) b t. (Monad m) => m (Either t b) -> m b
08:23:53 <ManateeLazyCat> tab: You can try to use manatee-curl, that support all protocol that curl support, and support multi-threads that curl not support. :)
08:23:53 <edlinde> am wondering if chap 18 is supposed to be the chapter on monads?
08:24:50 <jmcarthur> revenantphx: actually, that example that ManateeLazyCat linked to doesn't look that complicated
08:24:53 <tab> ManateeLazyCat: i'm more interested in just http/https
08:25:07 <revenantphx> No, it's not, I just don't want to deal with widgets and timers right now :P
08:25:10 <ManateeLazyCat> tab: yes, it's support it.
08:25:15 <revenantphx> As I said, GLUT is enough to learn how the GL bindings in haskell work.
08:25:27 <revenantphx> (for now
08:25:27 <tab> ManateeLazyCat: i know, but i'ld rather use http-enumeratee
08:25:42 <ManateeLazyCat> tab: Ok, choose you like .:)
08:26:01 <jmcarthur> revenantphx: if you know opengl already you could use OpenGLRaw and not really have to learn anything new
08:26:08 <ManateeLazyCat> revenantphx: gtkglext is simple enough, but i think you more like GLUT, ok. :)
08:26:24 <revenantphx> I don't "like" GLUT more, it's jsut barebones, and that's want I want for now > >
08:26:32 <tab> it provide native http and https support .. so i was wondering what was missing regarding HTTP compared to curl
08:26:44 <jmcarthur> i'd say gtk2hs is more barebones. i think you just mean simple to use
08:27:02 <quicksilver> glut is more x-platform.
08:27:07 <revenantphx> GTK2HS is an entire windowing system.
08:27:12 <revenantphx> That I don't want to deal with right now.
08:27:17 <revenantphx> TT_TT
08:27:22 <revenantphx> It's not very complicated to understand.
08:28:13 <ManateeLazyCat> tab: Curl's code is more robust, i think. 
08:29:40 <ManateeLazyCat> Curl + Multi-threads + spider : Most powerful download manager.... spider can implement same feature like "wget clone page"
08:30:22 <tab> ManateeLazyCat: well, http-enumeratee is pure haskell. i'm pretty sure it does works with multi-threads too ;)
08:31:57 <ManateeLazyCat> tab: The most feature i like curl is : i can use same APIs handle all those protocols (not just http/https)
08:32:17 <ManateeLazyCat> tab: Curl give clearer logic for me. 
08:32:43 <eigenspace> join #logicstudio
08:33:52 <ManateeLazyCat> If a library have do awesome work, i prefer to binding it instead re-implement it by Haskell
08:34:09 <Cale> ManateeLazyCat: I just saw your flickr photostream. You're doing an interesting variety of stuff! :)
08:34:22 <ManateeLazyCat> Cale: For OS. :)
08:34:49 <ManateeLazyCat> Cale: Now, just beginning, have more extension will create in the future. :)
08:35:02 <Cale> :)
08:35:18 <ManateeLazyCat> Cale: I hope i just have haskell/C code running in my box. :)
08:35:23 <ManateeLazyCat> someday
08:36:13 <ManateeLazyCat> I also hope more people help me buld coolest system in this world! :)
08:36:36 <ManateeLazyCat> Please let me know if you suggestion or contribution!
08:37:34 <ManateeLazyCat> Of course, i hope haskell expert point out bad code in Manatee, i will fix it soon. :) 
08:38:17 * hackagebot arrow-list 0.2.0 - List arrows for Haskell.  http://hackage.haskell.org/package/arrow-list-0.2.0 (SebastiaanVisser)
08:39:44 * ManateeLazyCat Hmmm, type so fast, typo everywhere. ;p
08:42:28 <Cale> I'm currently working on a game with the iPwn guys. Hopefully we'll be able to get some insights into how to do FRP better.
08:43:30 <tab> ManateeLazyCat: it has downside though, curl has poor control of SSL related stuff
08:43:36 <revenantphx> FRP?
08:44:14 <Cale> Functional reactive programming
08:44:20 <revenantphx> Like event based?
08:44:25 <revenantphx> But with functions.
08:44:30 <Cale> Sort of :)
08:44:35 <revenantphx> hm, cool.
08:45:11 <Cale> It's not really one thing, more like a bunch of related approaches to libraries which people haven't really completely figured out yet.
08:45:17 <revenantphx> Hm.
08:46:01 <quicksilver> specifying time-varying systems implicitly as how outputs are a function of inputs
08:46:19 <quicksilver> rather than explicitly as algorithms which run on events or sequentially, etc.
08:46:21 <Cale> But the classical idea is this: there are two types of state which need to be managed in an interactive system. There are things which are like sequences of values that occur at particular points in time (events)
08:46:36 <Cale> and there are things which always have a value whenever you look at them (behaviours)
08:46:54 <Cale> Examples of events include key presses, mouse clicks
08:47:05 <Cale> Examples of behaviours include things like the position of the mouse
08:47:10 <Cale> or the current time
08:47:14 <revenantphx> Alright.
08:48:16 <geheimdienst> sounds interesting
08:48:19 <geheimdienst> is FRP more a useful thing or more an academic thing?
08:48:26 <Cale> We can abstract these two sorts of things into type constructors  Event a  and  Behaviour a, and provide operations for combining and manipulating them, hoping to make it possible to express programs as functions from a set of input events and behaviours to a set of output events and behaviours
08:48:51 <quicksilver> geheimdienst: it's intended to be a useful thing, but it has so far proven hard to implement efficiently.
08:48:56 <Cale> geheimdienst: It's an academic thing which is struggling to turn into a useful thing.
08:49:15 <Cale> We're using an FRP system in our game.
08:49:24 <quicksilver> for me, the most convincing formalism is conal's, and I highly recommend his paper.
08:49:25 <Cale> (A modified version of Yampa)
08:49:32 <quicksilver> but he ahs an implementation which has problems
08:49:38 <quicksilver> and I have an implementation which has (other) problems.
08:49:49 <quicksilver> I find yampa less elegant, but the advantage of 'working' is substantial.
08:50:18 <Cale> Yeah, I agree with that. Conal's library is clearly the one that we want, but his implementation isn't :)
08:50:22 <quintessence> yampa is the push-based arrows one?
08:50:58 <Cale> I've managed to build a little specialised applicative library on top of our Yampa and graphics system.
08:51:05 <Cale> For constructing GUIs.
08:51:50 <Cale> and that seems to be working well. I think maybe Yampa-like arrow libraries might be a good way to form a substrate on top of which more convenient FRP libraries can be built.
08:52:14 * quicksilver wishes he had more time to think about the problems in his implementation.
08:52:19 <quicksilver> (jobs-which-aren't-haskell)--
08:52:26 <ManateeLazyCat> I still can't understand how to use FRP in product.
08:52:52 <Cale> My applicative is almost a monad. I'll have to think some more about how Yampa switching works to see if I can fix my switched join into a real join.
08:53:16 <Cale> I have a primitive WSwitch :: a -> Widget (Event (Widget a)) -> Widget a
08:54:14 <ManateeLazyCat> Cale: Looks need build middle-layer between FRP and low-level graphics toolkit.
08:55:03 <Cale> in terms of that switched join, I have  wEventBind :: b -> Widget (Event a) -> (a -> Widget b) -> Widget b
08:55:24 <Cale> So, it's really really close to being a monad, but not quite :)
08:56:24 <Cale> I think if I were to make it into a monad in the most obvious way, I would lose efficiency by switching constantly.
08:56:29 <ManateeLazyCat> I will found some time write FRP gtk2hs code.
08:57:01 <ManateeLazyCat> And see the advantage... 
08:57:11 <elliott> hmm, there's Int8, but is there a UInt8 anywhere conveniently standard?
08:57:18 <Cale> elliott: Word8
08:57:27 <elliott> Cale: ah, of course. thanks :)
08:57:31 <byorgey> Goose124: I'm here now
08:57:31 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
08:59:39 <ManateeLazyCat> leafnode is slow....
09:00:05 <Cale> On the other hand, I could bake the Event into the Widget type (Widgets are interactive things which can draw stuff on the screen and handle user input, and also continuously produce values of a specified type)
09:00:22 <Cale> Event in this setting is currently isomorphic to Maybe
09:00:25 <elliott> Does there happen to be a convenience function from String -> Word8? Okay, okay, that's not actually kosher, bleh. :)
09:00:33 <Cale> elliott: read?
09:00:43 <elliott> Cale: I mean, treating it as ASCII :)
09:00:53 <elliott> "map ord" works I think
09:00:54 <Cale> map fromEnum
09:00:56 <Cale> yeah
09:00:59 <Cale> or map ord
09:01:10 <elliott> ah, just fromEnum; ord is Int only
09:01:14 <Cale> (maybe compose a fromIntegral on there)
09:01:14 <elliott>     Couldn't match expected type `Word8' against inferred type `Int'
09:01:17 <elliott> indeed :P
09:01:24 <monochrom> String -> [Word8] ?
09:01:25 <ManateeLazyCat> @hoogle fromEnum
09:01:25 <lambdabot> Prelude fromEnum :: Enum a => a -> Int
09:01:28 <ManateeLazyCat> @hoogle toEnum
09:01:29 <lambdabot> Prelude toEnum :: Enum a => Int -> a
09:01:35 <elliott> monochrom: call it "pretendUnicodeDoesn'tExist".
09:01:41 <elliott> map (fromIntegral . ord) works
09:01:53 <geheimdienst> ceiling cat will be watching you for that
09:01:58 <monochrom> @type map (fromIntegral . ord)
09:01:58 <alpounet> heh
09:01:59 <lambdabot> forall b. (Num b) => [Char] -> [b]
09:02:04 <monochrom> that is what I mean.
09:02:04 <elliott> Ahaa, I actually have to translate it back the other way, never mind. :)
09:02:13 <elliott> So chr . fromIntegral. Or whatever.
09:02:49 <Cale> Note also that utf8-string includes a function  encode :: String -> [Word8]
09:03:20 <elliott> Cale: Thankfully, I've successfully reversed the problem so I can forget UTF-8 exists. :)
09:04:07 <Cale> (and a decode :: [Word8] -> String)
09:05:25 <ManateeLazyCat> Convert UTF8 String to ByteString use utf8-string package, if Convert UTF8 String to CString, use withUTFString (http://code.haskell.org/gtk2hs/glib/System/Glib/UTFString.hs)
09:05:34 <ManateeLazyCat> @hoogle fromString
09:05:34 <lambdabot> Data.String fromString :: IsString a => String -> a
09:06:21 <ManateeLazyCat> @hoogle Data.String.UTF8.fromString
09:06:21 <lambdabot> No results found
09:06:26 <ManateeLazyCat> @hoogle Data.String.UTF8.toString
09:06:26 <lambdabot> No results found
09:06:32 <ManateeLazyCat> hmmm
09:06:43 <monochrom> hackage is too large for hoogle
09:07:13 <ManateeLazyCat> too large?
09:07:53 <aristid> too large
09:08:00 <ManateeLazyCat> Indeed, so many package on hackage....
09:11:21 <freyrs3141> Does anybody know of any good Haskell libraries for working with polynomials, i.e. (Groebner basis, LLL kind of stuff) ?
09:11:43 <ManateeLazyCat> Any APIs parse .cabal file to get value of field 'name' and 'version'?
09:13:36 <lars9> @hoogle cabal
09:13:37 <lambdabot> No results found
09:13:52 <lars9> @hackage cabal
09:13:53 <lambdabot> http://hackage.haskell.org/package/cabal
09:13:54 <ManateeLazyCat> Perhaps is Distribution.PackageDescription.Parse 
09:14:01 <ManateeLazyCat> Reading...
09:17:23 <ManateeLazyCat> @hoogle FieldDescr
09:17:24 <lambdabot> No results found
09:20:56 <ManateeLazyCat> Ah, readPackageDescription then GenericPackageDescription => packageDescription => PackageIdentifier => (pkgName, pkgVersion)
09:21:04 <ManateeLazyCat> Haha, write some code test.
09:29:20 <monochrom> yo hackage is too fat for hoogle. yo hackage is too fat to be indexed. yo hackage is so fat, the ratio of its circumference to its diameter is 4. http://spikedmath.com/083.html
09:29:32 <revenantphx> OOOOOH SNAP.
09:29:35 <revenantphx> MONOCHROM INDA HOUSE.
09:30:50 <revenantphx> How could you even have a ratio of 4 anyhow.
09:30:59 <revenantphx> The ratio of circumference to diameter is π > >
09:31:04 <quicksilver> it's a joke :P
09:31:10 <quicksilver> you could, e.g., be a square.
09:31:15 <quicksilver> depending how you define 'diameter'
09:31:17 <revenantphx> Yeah, true.
09:32:21 * shachaf defines diameter as "twice radius".
09:32:25 <shachaf> Squares don't have a radius.
09:33:07 <FauxFaux> Manhattan squares have a radius.
09:33:33 <quicksilver> shachaf: diameter is quite often defined for non-circles.
09:33:37 <sipa> if you use a 1-norm, circles (defined as the set of points on a constant distance from a given point) are square
09:34:04 <quicksilver> shachaf: normally as something like the maximum distance between two points on the path
09:34:32 <quicksilver> (which would make my square sqrt(2) and the ratio would not be 4)
09:35:13 <shachaf> Hmm. I suppose.
09:35:31 <quicksilver> but it's not completely standard, and it was only a joke, anyway.
09:35:34 <revenantphx> I always though of a circle as a special case of an ellipse, in which the two foci coincide.
09:35:39 <revenantphx> It's the most basic locus possible.
09:36:00 <quicksilver> I always thought of a circle as the shape of God's face.
09:36:40 <Cale> God's face is obviously a 120-cell.
09:36:48 <revenantphx> I always though of a circle as a shape in which, if you take half of it, and draw inscribed triangles with the hypotenuse defined as the diameter, are always right triangles.
09:37:33 <elliott> revenantphx: I always thought of a circle as a perfectly round thing.
09:37:35 <revenantphx> In fact, you could go so far as to say the angle opposite the side defined by a chord AB, is proprtional to the length of said chord from the center of the circle...
09:37:45 <revenantphx> Geometry is resurging in my head right now.
09:38:14 <monochrom> why do you people over-analyze a joke?
09:38:39 <shachaf> Cale: I would've thought it was a point.
09:40:28 <Cale> Actually, it's the empty set.
09:40:56 <RichardBarrell> monochrom: over-analysis is also fun.
09:41:22 <quicksilver> monochrom: because people are bored.
09:41:24 <quicksilver> and/or boring.
09:41:26 <Cale> A circle is an involute of a point.
09:41:26 <mightybyte> Is there a type class capturing the commonalities of both Maybe and Either String?
09:41:35 <quicksilver> mightybyte: MonadPlus, to some extent.
09:41:48 <quicksilver> MonadOrElse, perhaps (which is fictional, but exists on the wiki)
09:42:01 <mightybyte> I don't see a MonadPlus instance for Either String
09:42:18 <quicksilver> > Right "hi" `mplus` Left "there"
09:42:19 <lambdabot>   Right "hi"
09:42:21 <quicksilver> I do.
09:42:29 <shachaf> mightybyte: Control.Monad.Error
09:42:30 <yitz> A circle is the set of the inverses in the complex plane of all the points on the circle.
09:42:34 <mightybyte> Ahhh
09:43:05 <mightybyte> Ok, that's what I'm looking for.
09:43:32 <mightybyte> Is there a good way to search for type class instances?
09:43:50 <revenantphx> hoogle probably?
09:43:58 <revenantphx> @hoogle Num
09:43:58 <lambdabot> Prelude class (Eq a, Show a) => Num a
09:43:58 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
09:43:58 <lambdabot> module Numeric
09:44:05 <revenantphx> Er, that's not it.
09:44:43 * hackagebot ecu 0.0.7 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.7 (TomHawkins)
09:44:43 <stulli> revenantphx: like :info in ghci?
09:44:48 <revenantphx> idk
09:45:08 <revenantphx> I guess that does what you want mightbyte
09:45:10 <revenantphx> :info Num
09:45:14 <revenantphx> :i Num
09:45:23 <revenantphx> > :info Num
09:45:24 <lambdabot>   <no location info>: parse error on input `:'
09:45:31 <revenantphx> @list
09:45:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
09:45:38 <mightybyte> revenantphx: No, I was looking for a way to find where the MonadPlus instance of Either String is defined.
09:45:54 <revenantphx> @hoohgle Either String
09:45:54 <lambdabot> Did you mean: :: Either String a /count=20
09:45:54 <lambdabot> No results found
09:46:04 <revenantphx> @hoogle Either String
09:46:04 <lambdabot> Did you mean: :: Either String a /count=20
09:46:04 <lambdabot> No results found
09:46:07 <revenantphx> >_>
09:46:07 <mightybyte> :info Either String
09:46:14 <revenantphx> info doesn't do anything here
09:46:16 <mightybyte> @info Either String
09:46:16 <lambdabot> Either String
09:46:18 <revenantphx> try it in ghci
09:46:31 <lars9> what's the meaning of 2^pi? 2^0.17 can be seen as root(2^17, 100), but 2^pi?
09:46:31 <revenantphx> data Either a b = Left a | Right b 	-- Defined in Data.Either
09:46:31 <revenantphx> instance (Eq a, Eq b) => Eq (Either a b) -- Defined in Data.Either
09:46:45 <mightybyte> Yeah, in GHCI it doesn't help me unless I have the right module imported already.
09:46:49 <Veinor> lars9: limit as x approaches pi of 2^x
09:46:51 <revenantphx> lars9: It's 2 to the pi :P.
09:47:03 <revenantphx> mightybyte: Oh I see.
09:47:14 <mightybyte> > mzero :: Either String Int
09:47:14 <lambdabot>   Left ""
09:47:32 <lars9> Veinor: that's a feasible explaination...
09:47:38 <revenantphx> http://www.haskell.org/hoogle/?hoogle=Either
09:47:38 <mightybyte> I guess I could just leverage lambdabot's large number of default imports.
09:47:45 <revenantphx> @hoogle Either
09:47:45 <lambdabot> module Data.Either
09:47:45 <lambdabot> Prelude data Either a b
09:47:45 <lambdabot> Data.Either data Either a b
09:48:18 <monochrom> 2^pi = limit of 2^3, 2^3.1, 2^3.14, 2^3.141, 2^3.1415, ...  for each term like 2^3.1415, use your root(2^31415, 10000) rule.
09:50:18 <lars9> monochrom: that explains
09:50:36 <monochrom> we are very glad that this sequence converges :)
09:51:16 <byorgey> to prove the limit exists is it enough to know that \x -> 2^x  is monotonic, i.e. if p < q then  2^p < 2^q ?
09:51:54 <monochrom> we also find 2^pi = exp(pi * ln 2)
09:53:08 <lars9> pi is easy to understand, but e is real magic...
09:53:34 <Veinor> byorgey: i want to say that that plus the fact that \x -> 2^x is total is enough
09:53:36 <Veinor> but my analysis escapes me
09:56:06 <byorgey> Veinor: oh yes, totality too, good point
09:56:20 <byorgey> total on the rationals you mean
09:57:32 <revenantphx> How exactly does liftM work? It takes a function that takes a and returns a, and makes it ma -> ma?
09:57:34 <revenantphx> :t liftM
09:57:35 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:57:42 <revenantphx> er, a1 and r
09:57:43 <revenantphx> w/e
09:58:24 <revenantphx> I think I get the gist of it :\
09:58:32 <shachaf> revenantphx: liftM = fmap
09:58:39 <revenantphx> ..what?
09:58:48 <c_wraith> :t liftM
09:58:49 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
09:58:51 <c_wraith> :t fmap
09:58:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:59:00 <revenantphx> I see the similarity.
09:59:08 <shachaf> revenantphx: Look up "Functor" (in a Haskell context) for more information.
09:59:08 <c_wraith> the only difference between the two is the constraint
09:59:10 <Veinor> byorgey: not necessarily. consider the function \x -> 1/(x-pi)
09:59:17 <revenantphx> c_wraith: I see.
09:59:28 <Cale> Given a category C equipped with a functor F from C to chain complexes of groups, we define a _circle_ to be an object X in C for which F_0(X) = F_1(X) = Z, and F_i(X) = 0 for all other i.
09:59:30 <Veinor> it's total on the set of rationals greater than pi
10:00:31 <Veinor> you can probably come up with a criteria where monotonicity over a set + totality over the set implies limits, but I dunno what. anyway, I gotta go. o/
10:03:00 <c_wraith> revenantphx, the difference is that fmap is the only thing Functor supports.  liftM is just one of many things Monad supports.  so Functor is the more general interface
10:05:52 * hackagebot ecu 0.0.8 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.8 (TomHawkins)
10:07:52 * ManateeLazyCat pasted "auto upload cabal package." at http://paste2.org/get/1107537
10:08:07 <ManateeLazyCat> It's okay for you above? ^^^
10:08:38 <JoeyA> At the risk of nerd-sniping a bunch of people: I wonder if it's possible to get Haskell's type checker to figure out "Einstein's Puzzle"  http://www.stanford.edu/~laurik/fsmbook/examples/Einstein%27sPuzzle.html
10:09:07 <JoeyA> (would probably require several extensions, like functional dependencies and multi-parameter type classes)
10:09:49 <JoeyA> e.g. class HasPet n p | n -> p
10:12:18 <byorgey> JoeyA: might be difficult, since the type checker does not do backtracking search.
10:12:51 <byorgey> and if you could encode the puzzle in such a way that finding the solution does not require backtracking, you've basically solved it already.
10:13:13 <lars9> JoeyA: i saw a solution in haskell before. very elegant, though i didnt read the details.
10:19:49 <augur> Combinatorial Species ~ Liner Logic?
10:19:51 <augur> discuss!
10:21:28 <Gabbie> No
10:21:48 <byorgey> is there a particular connection you're getting at?  I'm not sure I see it.
10:21:56 * hackagebot dist-upload 0.0.1 - Generate/Upload cabal package to Hackage.  http://hackage.haskell.org/package/dist-upload-0.0.1 (AndyStewart)
10:22:30 <ManateeLazyCat> Haha, automatic generate/upload package to Hackage.
10:22:34 <ManateeLazyCat> Enjoy! :)
10:22:39 <byorgey> ManateeLazyCat: what does it do?
10:23:51 <ManateeLazyCat> byorgey: It scan .cabal file under current directory and get packageName/Version : "foo-x.x.x", then do "cabal sdist && cabal upload ./dist/foo-x.x.x".
10:24:15 <ManateeLazyCat> byorgey: I will use 'dist-upload' in my script to upload packages batch
10:24:32 <byorgey> oh, I see, nice
10:24:46 <ManateeLazyCat> byorgey: Simple, dist-upload scan your .cabal file and upload corresponding version..
10:25:09 <byorgey> great, I will probably use it too =)
10:25:16 <ManateeLazyCat> byorgey: If you have add username/password in ~/.cabal/config, all upload process is fully automatic. :)
10:25:35 <byorgey> oh!  I didn't know you could put your Hackage username/password in ~/.cabal/config =)
10:26:04 <ManateeLazyCat> byorgey: Yes, then you don't need type username/password everytime "cabal upload" running. :)
10:26:09 <ManateeLazyCat> byorgey: Save time.
10:26:32 <augur> byorgey!
10:26:47 <augur> combinatorial species! \o/
10:28:17 <nus> ManateeLazyCat, do you use glade?
10:28:27 <ManateeLazyCat> nus: No.
10:28:30 <ManateeLazyCat> nus: Any problem?
10:28:37 <byorgey> hi augur =)
10:29:11 <augur> byorgey: i read your Oh my! paper
10:29:33 <nus> ManateeLazyCat, sure, tons of them, starting with GObject :-P (-;
10:29:50 <ManateeLazyCat> nus: I never use Gloade.
10:30:01 <nus> ManateeLazyCat, how many people is gtk2hs currently?
10:30:01 <ManateeLazyCat> nus: Of course, glade is very useful for GTK+ newbie.
10:30:05 <augur> byorgey: its quite beautiful! i like these things.
10:30:16 <ManateeLazyCat> nus: You mean developer?
10:30:22 <nus> ManateeLazyCat, yep
10:30:24 <jmcarthur> i've read some stuff about combinatorial species (probably some of byorgey's writings), but while i think it's interesting i still haven't managed to make it click as something "useful"
10:30:34 <augur> i had an idea while dreaming last night, you know. relating combinatorial species operations to linear logic operators
10:30:43 <ManateeLazyCat> nus: Axel and Me are main developer.
10:30:50 <tab> ManateeLazyCat: glade has nothing to do with newbie or not
10:31:03 <nus> ManateeLazyCat, you following GTK3?
10:31:04 <jmcarthur> i like that it seems to be a way to reason about irregular data, but i haven't absorbed how powerful or not powerful it is
10:31:19 <ManateeLazyCat> nus: And there have many other people will provide patches.
10:31:40 <ManateeLazyCat> nus: I just follow official version.
10:31:53 <ManateeLazyCat> nus: I will update gtk2hs when GTK3 release.
10:31:57 <byorgey> augur: thanks! glad you liked it.
10:32:11 <tab> should be gtk3hs at this point :P
10:32:22 <monochrom> haha
10:32:25 <ManateeLazyCat> tab: No.
10:32:34 <ManateeLazyCat> gtk To haskell
10:32:37 <monochrom> oh!
10:32:41 <byorgey> jmcarthur: yeah, we need some killer apps for combinatorial species.  I'm not sure I did such a good job in my paper explaining what they might be.
10:32:46 <tab> ManateeLazyCat: joke :)
10:32:50 <byorgey> jmcarthur: they are coming though, don't worry =)
10:32:53 <ManateeLazyCat> tab: I know . :)
10:32:56 <jmcarthur> byorgey: i can't wait
10:33:04 * hackagebot memcached 0.2.1 - haskell bindings for memcached  http://hackage.haskell.org/package/memcached-0.2.1 (OlegKatsitadze)
10:33:20 <byorgey> augur: so what's the connection between species and linear logic?
10:34:38 <lars9> is there an easier way to tell if a string represent an integer or float number?
10:34:44 <Cale> byorgey: I really like your combinatorial species library, but we need to fix the underlying mess in Henning's numeric-prelude.
10:35:46 <Cale> lars9: Easier than simply attempting to parse it as both and seeing if one of the parsers match? :)
10:35:50 <byorgey> Cale: indeed.  It's the best I've found so far, but it does need some work.
10:36:09 <byorgey> Cale: are you referring specifically to the way he organizes modules and type/class names, or something more mathematical?
10:36:11 <Cale> byorgey: Well, specifically, I'd be pretty happy with it if it just had saner naming conventions.
10:36:12 <Cale> yes
10:36:17 <byorgey> ok, indeed =)
10:36:54 <Cale> I wonder how long it would take me just to repair the damage by hand.
10:37:13 <lars9> @hoogle showIntAtBase
10:37:14 <lambdabot> Numeric showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
10:37:28 <lars9> @hackage Numeric
10:37:29 <lambdabot> http://hackage.haskell.org/package/Numeric
10:37:34 <byorgey> Cale: a day of tedious drudgery would probably suffice.
10:37:47 <Cale> lars9: Numeric is part of the Haskell standard.
10:38:11 <byorgey> Cale: or a day of mucking about with haskell-src-exts.
10:38:29 <Cale> byorgey: Yeah. I started on writing a tool to do it automatically, but module imports in Haskell are pretty complicated
10:38:40 <lars9> Cale: what's the opposite func to showIntAtBase?
10:39:09 <Cale> byorgey: Especially as technically you can import multiple libraries qualified in the same way, though I don't know if any of that actually exists.
10:39:31 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Numeric.html#v%3AreadInt
10:39:34 <Cale> lars9: ^^
10:39:42 <lars9> Cale: thanks:)
10:40:42 <Cale> Heh, that's old documentation apparently. It was generated when haddock still had the bracketing bug.
10:41:25 <augur> byorgey: sorry, computer died, and now i have to go and TA a class; when i get back i'll explain
10:42:03 <lars9> Cale: wonder why read not return Maybe a
10:42:07 * hackagebot dist-upload 0.0.2 - Generate/Upload cabal package to Hackage.  http://hackage.haskell.org/package/dist-upload-0.0.2 (AndyStewart)
10:42:26 <ManateeLazyCat> Haha, works very well. 
10:43:20 <byorgey> augur: ok, I look forward to it =)
10:43:47 <byorgey> ManateeLazyCat: you used it to upload itself? =)
10:43:56 <ManateeLazyCat> byorgey: Yes.
10:44:25 <Gabbie> Rude
10:44:53 <augur> byorgey: scratch that; it seems that since today is the day before thanksgiving, class is cancelled
10:44:58 <augur> hooray
10:45:12 * mightybyte <3 MaybeT
10:45:17 <augur> ok, byorgey, are you ready for this?! :D
10:45:18 * ManateeLazyCat pasted "repos.sh" at http://paste2.org/get/1107689
10:45:18 <ManateeLazyCat> byorgey: Once you use "dist-upload" in script, you will know how handy it is. :) Some script like above. 
10:46:03 <augur> byorgey: so in linear logic, you basically reason over multisets of resources, instead of propositions that are always true
10:46:19 <augur> thus you have different versions of conjunction and disjunction depending on how they behave
10:46:44 <byorgey> right
10:47:04 <augur> so you have two conjunctions:   C :- F   C :- G   =>   C :- F&G   ;   C :- F   D :- G   => C,D :- F*G
10:47:47 <augur> the second says that if C proves F, and D proves G, then the union of C and D proves both F and G at the same time
10:48:02 <byorgey> disjoint union, I suppose?
10:48:18 <augur> on the left hand side? no, just union
10:48:35 <augur> the first says that if C proves F and also G, then C can prove both F and G but not at the same time
10:48:49 <byorgey> but then you might be reusing the same resource in the proof of F and G?
10:48:55 <augur> (keep in mind: this is not xor, both F and G could be true simultaneously, you just cant prove it from C alone)
10:49:02 <byorgey> right
10:49:11 <augur> byorgey: sure, you can reuse resources, but these are multisets, right
10:49:28 <byorgey> ohhhh, multisets, ok, I'm with you =)
10:49:36 <augur> so the fact that you have C,D :- F*G just means that if some proposition P is in both C and D, you now have two instances of it instead of just one
10:49:40 <augur> you can think of it like a recipe
10:49:42 <byorgey> right
10:50:08 <augur> 6 eggs :- Omelette   6 eggs :- Meringue   =>   6 eggs :- Omelette & Meringue
10:50:11 * hackagebot manatee 0.0.8 - The Haskell/Gtk+ Integrated Live Environment  http://hackage.haskell.org/package/manatee-0.0.8 (AndyStewart)
10:50:18 <ManateeLazyCat> Haha, very cool.
10:50:21 <byorgey> yes, I get it
10:50:30 <augur> whereas 6 eggs , 6 eggs :- Omelette * Meringue
10:50:43 <augur> you also have another kind of operation like so
10:50:51 <byorgey> augur, you had better hurry up because you are making me hungry ;)
10:50:55 <augur> lol
10:51:39 <augur> you also have another operation, C :- F   =>   C :- F+G
10:51:49 <augur> which basically says you can "forget" which it is that you can get from C
10:51:55 <augur> you only get one, but you dont remember which
10:52:10 <byorgey> yup
10:52:17 <augur> and then theres another mysterious operation (par) which i wont even try to understand
10:52:20 <augur> so what i was thinking, right
10:52:31 <augur> is that this is vaguely like species operations
10:52:42 <ManateeLazyCat> Hmm, i should use waitForProcess wait upload process.
10:52:45 <byorgey> hmm, interesting
10:52:58 <augur> that is, if I can build some species F[U] and another G[V], then surely i can also build (F*G)[U,V]
10:53:08 <augur> where U,V is the multiset union of labels
10:53:13 <byorgey> right
10:53:35 <augur> but thats just the rule for the tensor produce * in linear logic, with labels as assumptions!
10:53:54 <byorgey> mmmhmm
10:53:55 <augur> and also surely if I can build F[U] and also G[U] I can build (FxG)[U]
10:54:00 <byorgey> and & is like cartesian product
10:54:13 * hackagebot dist-upload 0.0.3 - Generate/Upload cabal package to Hackage.  http://hackage.haskell.org/package/dist-upload-0.0.3 (AndyStewart)
10:54:15 <ManateeLazyCat> Hmmm, works well after add waitForProcess, otherwise script can't works well.
10:54:27 <augur> ehh..
10:54:48 <byorgey> sort of.
10:55:28 <byorgey> & corresponds to a weird sort of cartesian product that gives you structures where you can observe one structure or the other, but not both
10:55:40 <augur> indeed
10:55:45 <augur> it seems vaguely like + to me
10:55:47 <byorgey> normal cartesian product is not linear since it lets you reuse labels
10:56:05 <byorgey> no, + corresponds to +
10:56:25 <augur> mm... oh, you're right, yes, sorry
10:56:33 <byorgey> with + you don't get to choose which structure you want
10:56:47 <byorgey> you can only find out which it is.
10:57:06 <augur> im not saying tho that this correspondence is exact
10:57:15 <augur> but it seems like there are some similarities
10:57:24 <byorgey> no, but I see the connection now.  Very neat. =)
10:57:43 <augur> the last thing i would suggest tho is we need a fourth species operator
10:57:45 <byorgey> I saw a nice presentation once that made the other operation clear to me
10:57:55 <augur> so if * is splitting and distributing labels to make pairs
10:58:00 <byorgey> it is dual to + in the same way that * and & are dual
10:58:04 <augur> and x is not splitting labels to make pairs
10:58:08 <byorgey> but I forget what that way is =)
10:58:16 <augur> and + is not distributing labels to union the results
10:58:33 <augur> then surely we need, say, #, which splits the labels, but unions the results
10:59:10 <augur> e.g. (X # 1)[{a}] = {X a, 1}
10:59:57 <byorgey> hmm
11:00:12 <byorgey> I'll have to think about it more, but I think you have hit upon something interesting for sure
11:00:13 <byorgey> anyway, now I really am going to go eat something =)
11:00:13 <augur> and i think this would correspond vaguely to par
11:00:29 <byorgey> augur: can you pm me your email address?
11:01:05 <augur> there you go.
11:01:07 <augur> what for?
11:01:08 <byorgey> thanks =)
11:01:25 <byorgey> just in case we want to correspond about it at more length
11:01:26 <augur> DONT SIGN ME UP FOR SPAM >|
11:01:43 <Botje> are you skipping out on nice, tasty spam?
11:02:26 <byorgey> hehe
11:03:03 <augur> byorgey: also, can you explain subtraction?
11:03:30 <byorgey> augur: sure, I can explain it to you sometime
11:03:31 <augur> like, what exactly does M = 1 + X mean when written as X = M - 1
11:03:43 <byorgey> remind me later
11:03:44 <augur> i dont get this whole pairs thing that Yeh and others talk about
11:03:57 <augur> too much math not enough haskell :\
11:05:28 <Scala> I'm learning about monads, and ran across this type specification:   m >> n = m >>= \_ -> n
11:05:40 <Scala> what does the \_ -> mean?
11:05:49 <Scala> \_ -> n
11:05:58 <augur> \_ -> M is the same as \x -> M
11:06:04 <augur> assuming that x is not free in M
11:06:16 <augur> its a function that discards the argument you give to it
11:06:35 <Scala> augur: Something like (\x -> 1) ?
11:06:48 <augur> sure
11:07:04 <augur> the _ basically just throws away whatever you try to bind to it.
11:07:09 <augur> so why give it a name at all
11:07:15 <Scala> gotcha
11:07:19 <augur> \_ _ _ -> 1 is that function of three variables that always returns 1
11:07:20 <augur> etc
11:07:56 <aristid> @pl \_ _ _ -> 1
11:07:56 <lambdabot> const (const (const 1))
11:08:15 <augur> :)
11:08:21 <aristid> :t const . const . const
11:08:21 <lambdabot> forall b b1 a b2. a -> b -> b1 -> b2 -> a
11:10:24 * hackagebot dist-upload 0.0.4 - Generate/Upload cabal package to Hackage.  http://hackage.haskell.org/package/dist-upload-0.0.4 (AndyStewart)
11:11:50 <jmcarthur> Scala: to be precise, what you pasted was a definition, not a type specification
11:12:30 <Scala> jmcarthur: Thanks, I'm not familiar with the terminology completely yet.  What's a type specification?  Is it anything?
11:12:44 <Quadrescence> forall b b1 a b2. a -> b -> b1 -> b2 -> a
11:12:48 <Quadrescence> that is a type
11:12:52 <Quadrescence> spec
11:12:58 <ManateeLazyCat> G'night.
11:13:17 <jmcarthur> Scala: well, a type *signature* is a declaration that the expression bound to a given variable must have the given type
11:13:44 <jmcarthur> Scala: and a type annotation is something you can stick next to an expression that constrains it to the given type
11:13:53 <Scala> jmcarthur: Right, which would be like multiply :: Int -> Int -> Int
11:13:54 <Scala> ?
11:14:06 <jmcarthur> Scala: "type specification" is sometimes tossed around informally i think, but i don't know if it means something specific or not
11:14:15 <jmcarthur> Scala: yeah, that looks like a type signature
11:14:29 <Scala> Okay
11:14:55 <jmcarthur> Scala: i suppose you could say that a type signature is a type specification if you wrote it before you wrote the implementation
11:15:35 <jmcarthur> or more generally if you wrote it without inferring it from the implementation
11:15:53 <jmcarthur> implying that you intend for the compiler to make sure that the implementation fits that specification
11:15:57 <Scala> jmcarthur: Gotcha.  I see those often in source code
11:16:28 * hackagebot wai-extra 0.2.4.2 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-0.2.4.2 (MichaelSnoyman)
11:16:34 <jmcarthur> sometimes people just use the compiler to tell them the type and then paste it in. i'm not sure i would call that a specification though because it's derived from the implementation
11:20:31 * hackagebot data-object-yaml 0.3.3.2 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.3.2 (MichaelSnoyman)
11:25:46 <Scala> What does it mean when you have a object (not sure if that's the correct term here) what has a ' after it.  Sorry for the lack of context, but the line I'm looking at is this: safeLogSqrt' = safeLog <=< safeSqrt
11:25:57 <kmc> Scala, nothing in particular
11:25:57 <Scala> s/what/that
11:26:01 <kmc> names can contain the character '
11:26:03 <Cale> lars9: You can use reads
11:26:12 <Scala> oh okay, I wasn't sure if it had any signifigance
11:26:25 <kmc> there are some conventions about it
11:26:32 <kmc> like foldl' is a less-lazy form of foldl
11:26:33 <mux> conventionally, it's often used to denote an alternate version of a function
11:26:35 <Cale> Scala: Usually it indicates something related to the name without the ' in some way
11:26:38 <kmc> but it's used in other ways too
11:26:57 <kmc> and since you're talking about syntax, i'd say "variable" or "identifier"
11:27:12 <kmc> not "object" -- even if Haskell had objects, they're not a syntactic construct
11:28:50 <edlinde> kmc: did you say you read the book "Craft of Functional Programming" earlier on?
11:28:56 <kmc> no
11:29:00 <edlinde> kmc: cannot remember if that was you
11:29:04 <edlinde> ok cool
11:29:05 <kmc> i have not read that book
11:29:41 <edlinde> okie
11:29:50 <edlinde> wondering if I should read through it 
11:30:03 <edlinde> or just read up LYAH a bit more + All About Monads
11:30:04 <edlinde> :)
11:31:33 <onteria|i7> All About Monads refers to this I assume? http://www.haskell.org/all_about_monads/html/index.html
11:32:47 <kmc> yeah
11:32:53 <kmc> it's not perfect, has some misleading wording some places
11:32:55 <kmc> but i found it useful
11:33:05 <kmc> also if you're going to read monad tutorials you should first read
11:33:06 <kmc> @where burrito
11:33:06 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
11:34:06 <onteria|i7> noted in my ever increasing haskell bookmarks list
11:49:15 <xarch> what is the use of g_cata from category extras?
11:50:24 <kmc> faulty assumption: things in category-extras have a use
11:50:37 <kmc> i'd guess it's like 
11:50:41 <kmc> http://knol.google.com/k/catamorphisms#
11:50:42 <kmc> but more so
11:51:20 <copumpkin> that actually mentions g_cata
11:51:42 <copumpkin> "However, a generalized catamorphism can be shown to add no more expressive power to the concept of a catamorphism. "
11:52:09 <djahandarie> xarch, I had this question awhile ago
11:52:26 <djahandarie> Yet I didn't get that link even though I asked the question like 10 times -_-
11:52:27 <xarch> yeah, I found this knol
11:52:40 <copumpkin> djahandarie: it's cause people hate you
11:53:12 <xarch> but well, I didn't learn a lot about why I should use g_cata
11:53:16 <djahandarie> xarch, a g_cata is basically isomorphic to the cata. It's pretty easy to convert it over given the dist and fmap and the FW algebra
11:53:32 <xarch> and the paper I found about recursion scheme rom comonads contains too much math for me
11:53:35 <xarch> *from
11:53:47 <xarch> yeah, I know about this
11:53:57 <djahandarie> I suppose if you ever have a comonad that'd be what you want to use
11:54:04 <xarch> cata = g_cata distCata . lift!algebra or something like thaht
11:54:10 <djahandarie> I asked edwardk about this and didn't really get a good answer. :P
11:54:11 <xarch> *that
11:54:32 <copumpkin> I mean
11:54:33 <mreh> @help
11:54:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:54:36 <copumpkin> the knol says so
11:54:37 <mreh> @list
11:54:38 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
11:54:46 <copumpkin> what isn't clear from there?
11:54:56 <mreh> @instances MonadIO
11:54:56 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
11:55:42 <xarch> hum well
11:56:25 <xarch> it's only used to define other functions like zygo and all that stuff ?
11:59:26 <mreh> :t lift
11:59:27 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
11:59:46 <djahandarie> xarch, I don't think g_cata is really used anywhere else in category_extras but I could be wrong
12:00:06 <djahandarie> Oh
12:00:07 <djahandarie> It is
12:01:05 <mreh> can a monad simultaneous be two instances of MonadState s, for two different ss
12:01:05 <djahandarie> Hmmm... I see how this works now. It seems to use g_cata for a reusable distributive law
12:01:27 <mreh> adverbs... pfft
12:06:38 <jmcarthur> mreh: i don't see why not
12:06:57 <jmcarthur> unless there is a fundep or type family there that i wasn't aware of
12:07:38 <jmcarthur> if it's just a multiparam then it should be fine
12:08:00 <Saizan> there's a fundep
12:08:06 <jmcarthur> ah then ignore me
12:08:10 <Saizan> last time i looked at least
12:08:29 <Saizan> it's a bit silly to have a fundep there though
12:13:58 <ezyang> Oh, haskell.org is still down? Curiouser and curiouser. 
12:14:06 <ezyang> > 1.0/2.0 
12:14:07 <lambdabot>   0.5
12:14:10 <ezyang> > 1.0/0.0 
12:14:11 <lambdabot>   Infinity
12:14:14 <ezyang> > Infinity 
12:14:15 <lambdabot>   Not in scope: data constructor `Infinity'
12:14:18 <aristid> > 1.0/1.0
12:14:18 <lambdabot>   1.0
12:14:22 <ezyang> that's... not a data constructor? 
12:14:26 <aristid> @let infinity = 1.0/0.0
12:14:27 <jmcarthur> > 1.0/(-0.0)
12:14:27 <lambdabot>  Defined.
12:14:27 <lambdabot>   -Infinity
12:14:29 <ketil> ezyang, I got a list email returned, no space on device. Somebody needs to give the server some love, I think.
12:14:32 <aristid> :t infinity
12:14:33 <lambdabot> forall t. (Fractional t) => t
12:14:34 <jmcarthur> > 0.0 == (-0.0)
12:14:35 <lambdabot>   True
12:14:37 <aristid> > infinity
12:14:38 <lambdabot>   Infinity
12:14:42 <aristid> > -infinity
12:14:43 <lambdabot>   -Infinity
12:14:46 <jmcarthur> > 1.0/0.0 == 1.0/(-0.0)
12:14:48 <lambdabot>   False
12:14:49 <ezyang> ketil: Oof. 
12:15:01 <aristid> > 0.0/0.0 == 0.0/0.0
12:15:02 <lambdabot>   False
12:15:05 <ketil> That was earlier today, though.
12:15:11 <aristid> floating point is great fun
12:15:29 <ezyang> I think the emails have started flowing again. 
12:15:54 <ezyang> aristid: Indeed ^_^ 
12:16:01 <jmcarthur> > let a = 0.0 ; b = -0.0 in (a == b, 1/a == 1/b)
12:16:02 <lambdabot>   (True,False)
12:16:48 <jmcarthur> @src infinity
12:16:48 <lambdabot> Source not found. I feel much better now.
12:16:59 <jmcarthur> oh it was a @let from earlier
12:17:17 <copumpkin> @let infinity = fix (Mu . Just)
12:17:17 <lambdabot>  <local>:2:0:
12:17:18 <lambdabot>      Multiple declarations of `L.infinity'
12:17:18 <lambdabot>      Declared at: <l...
12:17:22 <copumpkin> :t infinity
12:17:22 <lambdabot> forall t. (Fractional t) => t
12:17:26 <copumpkin> pff
12:17:30 <jmcarthur> @undef
12:17:43 <jmcarthur> @let infinity = fix (Mu . Just)
12:17:45 <lambdabot>  <local>:1:16: Not in scope: data constructor `Mu'
12:18:10 <copumpkin> @type fix (In . Just)
12:18:11 <jmcarthur> :o
12:18:11 <lambdabot> Mu Maybe
12:18:12 <copumpkin> @let infinity = fix (In . Just)
12:18:12 <jmcarthur> ah
12:18:13 <lambdabot>  Defined.
12:18:18 <copumpkin> man, lambdabot is sloow
12:18:20 <ezyang> lambdacow says mu 
12:18:26 <jmcarthur> ni!
12:19:39 <aristid> @let (.:) = fmap.fmap; infixr 9 .:
12:19:40 <lambdabot>  Defined.
12:19:54 <aristid> every @undef loses our glorious (.:)
12:19:55 <aristid> :(
12:20:44 <copumpkin> aristid: you can always ask Cale to add it
12:23:15 <Cale> Sure, I'll add it
12:23:28 <mreh> :t (.:)
12:23:29 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:23:52 <mreh> :t fmap . fmap
12:23:53 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:24:02 <djahandarie> :t fmap fmap fmap
12:24:02 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:24:12 <djahandarie> :t (.) . (.)
12:24:13 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:24:15 <Cale> infixr 9 okay?
12:24:19 <mreh> :t fmap `fmap` fmap
12:24:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:24:20 <byorgey> the sound of one Functor clapping
12:24:32 <byorgey> actually I suppose it is three Functors
12:24:38 <mreh> cluntor fapping
12:24:43 <djahandarie> :t (Prelude..) (Prelude..) (Prelude..)
12:24:45 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
12:25:19 <mreh> :t (.) (.) (.)
12:25:20 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
12:25:22 <Cale> :re
12:25:24 <Cale> er
12:25:29 <Cale> @undefine
12:25:36 <Cale> :t (.:)
12:25:36 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
12:26:00 <djahandarie> :t flip
12:26:01 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
12:26:08 <djahandarie> :t (.)
12:26:08 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:26:15 <aristid> Cale: thx
12:26:34 <aristid> :t (+1) . (+2) .: (+)
12:26:35 <lambdabot> forall a. (Num a) => a -> a -> a
12:26:51 <aristid> > ((+1) . (*2) .: (+)) 4 2
12:26:52 <lambdabot>   13
12:27:16 <djahandarie> > ((+1) *2 .: (+)) 4 2
12:27:17 <lambdabot>   Occurs check: cannot construct the infinite type: a = a -> b
12:27:24 <djahandarie> > (((+1) *2) .: (+)) 4 2
12:27:25 <lambdabot>   14
12:29:49 <mreh> dude, I learned some haskell today
12:30:08 <mreh> I think I might be a genius or something
12:34:49 <Mitar> can somebody please answer this: http://hpaste.org/41776/types
12:37:27 <Saizan> Mitar: i don't understand the question
12:38:09 <Mitar> shouldn't there be (Chan from) instead of just from?
12:38:47 <Saizan> that'd make sense i guess, but isn't that something you've defined?
12:39:14 <Mitar> i cannot define it otherwise, i get occurs check if i define it
12:39:32 <Mitar> and furthermore (Chan from) is not an instance of Impulse, but this code above still compiles
12:39:39 <Mitar> so i am not sure what is going on
12:40:51 <Saizan> http://hpaste.org/paste/41776/edit#p41777 <- this gives you an error?
12:41:56 <dancor> > ((+) `on` (+ 1) . (* 2)) 4 2
12:41:57 <lambdabot>   14
12:42:49 <Mitar> saizan: thanks for the help, i think that i found the problem somewhere else and this was just a symptom
12:42:55 <Mitar> i will try something else now
12:43:08 <paolino> Mitar, you are not using first parameter of data Axion, is it correct ?
12:43:34 <Mitar> em, i am?
12:43:41 <Mitar> not sure what you mean by not using?
12:44:25 <mightybyte> If I have to use a --constraint flag when I build something with cabal, is there a way I can specify that in my .cabal file?
12:45:09 <Saizan> mightybyte: only if the constraint is on something in your build-depends
12:45:15 <paolino> Mitar: nevermind, I'm not getting GADT's yet
12:45:22 <Mitar> me neither ;-)
12:45:40 <Mitar> currently i am still in trial&error phase ;-)
12:45:46 <mightybyte> Saizan: Hmmm, there's no way to put a constraint on a dependency several packages deep?
12:46:05 <onteria|i7> Hmm, I notice many people picking up haskell have qualms with understanding the logic behind what monads are and why they're needed
12:46:16 <mightybyte> Saizan: Or can I just include that package anyway as a top-level dependency?
12:47:53 <Saizan> mightybyte: 1) no, afaik 2) you can, i'm sure there's some downside but nothing comes to mind atm
12:48:08 <mreh> onteria|i7: they are never needed
12:48:17 <mreh> apart from IO...
12:48:35 <mightybyte> Saizan: Hmmm...
12:49:15 <Saizan> even for IO the fact that it's a Monad is not something transcendental, it's just a basic part of the API
12:49:38 <mightybyte> ...if I was using my own hackage server to serve in-house packages, it wouldn't be a problem.  But since I'm not I have to build things separately and one of my packages has wider inferred dependencies than another package that depends on it.
12:50:31 <mreh> I always liked the explaination of monadic IO
12:50:44 <mreh> anyway don't be scared by monads
12:51:01 <mreh> everyone gets them in the end
12:51:23 <paolino> when you run them
12:51:27 <mreh> death and monads
12:51:39 <mreh> two things guaranteed in life
12:52:33 <paolino> data Death = forall m . Monad m => Death m
12:53:02 <onteria|i7> hmm, bring up monads and all the sudden there's a post on -cafe titled "Monadic function purity"
12:53:02 <aristid> that's pretty existential
12:53:05 <Mitar> it compiles!!!!
12:53:21 <kmc> onteria|i7, there's a lot of confusion about monads, and a lot of people looking for them to be something more than they are
12:53:28 <kmc> "Monad" is just the name of a generic API (a type class)
12:53:30 <Saizan> mightybyte: i see, i guess the main downside is lack of modularity, but that might be the lesser evil, the proper solution would be being able to point cabal-install to a whole bunch of source dirs at once
12:53:37 <kmc> a small API at that
12:53:43 <kmc> it's used by a bunch of different types
12:53:53 <kmc> but there's more to say about each individual type than about the monad abstraction in general
12:54:17 <kmc> you could do IO exactly the way it's done in Haskell, and just pretend that (>>=) is an IO-specific operator
12:54:27 <kmc> you can use lists or Maybe without ever noticing that they're monads
12:56:21 * kmc should set a macro in his IRC client to type all of that
12:56:27 <mreh> could I suggest that you learn specific monads, and don't worry about what they are
12:57:01 <mreh> start with Maybe
12:58:22 <Saizan> kmc: nah, then the meme wouldn't have a chance to evolve
13:00:32 <mreh> @instances Monad
13:00:33 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:00:46 <mreh> where does Monad (Either a) live?
13:02:24 <Saizan> depends, it was in Control.Monad.Instances in mtl, now it's somewhere in base though
13:03:08 <orlandu63> mreh: Control.Monad.Error
13:03:26 <mreh> it's in Control.Monad.Either in loads of places
13:03:53 <igstan> hi, what are some good articles/tutorials on error/exception handling in Haskell? Except for RWH.
13:04:18 <mreh> @google 8 ways to report errors in haskell
13:04:19 <lambdabot> http://www.randomhacks.net/articles/2007/03/10/haskell-8-ways-to-report-errors
13:04:19 <lambdabot> Title: 8 ways to report errors in Haskell
13:05:31 <igstan> I know the article, but is a 2007 article still actual? not to mention the fact that that guy was complaining about the state of error handling in haskell
13:05:47 <igstan> isn't anything better right now?
13:05:48 <mreh> igstan, that one ^^^
13:06:24 <monochrom> I know of older articles still actual.
13:07:05 <igstan> I had hope that an article that complains about something isn't actual anymore
13:07:10 <Saizan> now the IO way to handle exceptions is much better organized an flexible
13:07:41 <mightybyte> Maybe and Either are to MonadPlus as MaybeT and EitherT are to what?
13:07:55 <mightybyte> Is that abstraction implemented?
13:07:59 <monochrom> MonadPlusPlus
13:08:03 <mightybyte> lol
13:08:09 <Saizan> MonadPlus (t m) ?
13:09:02 <Saizan> anyhow that article is of the kind "omg, the language doesn't make this choice for me, what can i do?"
13:09:25 <mightybyte> Well...I have a function written using MaybeT, and some of its arguments involve Maybe.  I would like to generalize that function so that it will work with things that use Either instead of Maybe.
13:09:37 <Saizan> though error is really not about reporting errors
13:09:45 <kmc> existence of multiple choices is a problem when crossing API boundaries
13:09:48 <Saizan> (the function, i mean)
13:10:06 <mreh> Saizan: it's about partial functions?
13:10:31 <sipa> mightybyte: what's the function's type now?
13:11:06 <Saizan> mreh: yeah, and hopefully such functions should have a clear side-condition under which they are total
13:11:32 <acemo> how should i make something like this? (\heap a -> do putStrLn (show heap) put heap a)
13:12:18 <Saizan> acemo: use ; to separate statements
13:12:57 <acemo> is that semicolon or colon?
13:13:05 <monochrom> semicolon
13:13:11 <acemo> great, thanks
13:13:12 <kmc> \heap a -> putStrLn (show heap) >> put heap a
13:13:35 <sinelaw> does it make sense to have an AST data type be a functor?
13:13:45 <monochrom> yes
13:13:46 <Saizan> sure
13:13:52 <mightybyte> sipa: It's kind of complex.  Here's the basic idea.
13:14:07 <acemo> kmc: how do you call the >> in haskell? google doesn't lets me search for >>
13:14:08 <sinelaw> that's what i thought, but i'm running into walls
13:14:26 <kmc> :t (>>)
13:14:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:14:44 <Saizan> it's often the free monad of some shape functor, actually
13:14:47 <mightybyte> sipa: foo :: (MyState :-> Map k a) -> MyMonadT m (Maybe a) -> k -> MyMonadT m (Maybe a)
13:14:50 <kmc> acemo, it's typeclass-overloaded so it can have a different definition for each type.  but it's supposed to be equivalent to
13:14:57 <kmc> x >> y  ===  x >>= \_ -> y
13:15:30 <Saizan> acemo: try hoogle :)
13:15:39 <mightybyte> sipa: It's a generic caching function.
13:16:39 <sinelaw> Saizan, i have my expr as a gadt
13:16:44 <hirschen> why can't I send messages to #erlang?
13:16:58 <sinelaw> data Expr a where  TupleExp :: Expr a -> Expr b -> Expr (a,b)
13:17:02 <ddilinger> hirschen: random guess, nickserv registered?
13:17:06 <acemo> what would be better to print the status to console in a lambda in a foldl putStrLn ; actual function or putStrLn >> actual function?
13:17:14 <sinelaw> Saizan, what would fmap do to TupleExp?
13:17:33 <hirschen> ddilinger: fsck
13:18:06 <hirschen> any erlang knowledge here?
13:18:34 <sinelaw> Saizan, it should be fmap :: ((a,b) -> (c,d)) -> Expr (a,b) -> Expr (c,d), for that constructor, right?
13:18:35 <alpounet> probably more on #erlang
13:18:58 <hirschen> Is there a fast way to reload modules in the erlang shell (for the sake of fast turn-around times)?
13:19:18 <Saizan> sinelaw: no, you end up needing to define "fmap :: ((a,b) -> c) -> Expr (a,b) -> Expr c"
13:19:27 <sinelaw> ah
13:19:33 <sinelaw> yeah
13:19:46 <Saizan> i.e. you can't
13:20:11 <sinelaw> hirschen, i just asked in #erlang and they require nickserv registration
13:20:20 <sinelaw> Saizan, so what to do
13:21:04 <hirschen> sinelaw: thx
13:21:51 <acemo> hirschen: i thought #haskell needed nickserv registration aswell? it doesn't lets me talk unless i confirm myself :s
13:22:07 <sinelaw> acemo, weird, me too
13:23:44 <sinelaw> Saizan, so it's not really possible to define Functor instances for gadt-based ASTs?
13:24:09 <copumpkin> depends how you go about it
13:24:42 <Saizan> i think it might be possible with some cleverness
13:26:02 <sinelaw> that's why i asked if it makes sense
13:27:08 <ddilinger> :t pure
13:27:09 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
13:27:26 <Saizan> one way is to add a Fmap constructor
13:27:57 <Saizan> that way fmap is actually part of your object language, and the functor laws will hold up to interpretation
13:30:21 <sinelaw> you mean Fmap :: a -> b -> Expr a -> Expr b?
13:30:37 <sinelaw> that is Fmap :: (a -> b) -> Expr a -> Expr b?
13:30:45 <Saizan> yep
13:31:17 <pkrumins> has anyone experience writing windows programs in haskell
13:31:18 <sinelaw> i still don't know what it would mean
13:31:22 <pkrumins> mine always starts in a DOS box
13:31:31 <pkrumins> i'd like it to start as a regular windows program
13:31:34 <sinelaw> Saizan, what's the interpretation of that for the tuple case
13:31:37 <pkrumins> not as a DOS one...
13:31:42 <pkrumins> anyone knows how to do that?
13:31:46 <sinelaw> i mean an AST that contains tuples and non-tuples mixed
13:32:34 <Saizan> if you've eval :: Expr a -> a; then you'll have "eval (Fmap f e) = f (eval e)"
13:33:04 <sinelaw> ah
13:33:07 <copumpkin> fmap ?
13:33:09 <Saizan> so if that e produces a tuple you'll just pass it to f
13:33:16 <Saizan> mh
13:33:29 <copumpkin> ah, no
13:33:43 <Saizan> so this Fmap constructor will be a way to embed the host language functions into your object language
13:33:53 <Saizan> s/embed/apply/
13:34:19 <sinelaw> Saizan, except what i really want to do with my Exprs is generate code in some target language
13:34:25 <sinelaw> so this doesn't help much
13:34:39 <Saizan> no :)
13:34:45 <copumpkin> I wouldn't expect fmap to help with that in general
13:34:50 <copumpkin> fmap is "structure-preserving"
13:35:08 <sinelaw> copumpkin, right, but i was thinking about playing with my ASTs
13:35:10 <Saizan> another common reason to make an AST a function is if you're parametrizing on e.g. the type of variable names
13:35:24 <Saizan> it becomes a monad where (>>=) is substitution
13:36:21 <Saizan> but for the Expr you've shown it doesn't make much sense
13:36:41 <Saizan> (to make it a Functor, i mean)
13:36:55 <sinelaw> yeah i guess the question is what i want the functor to do
13:37:03 <sinelaw> i could say it works on variable names
13:37:41 <sinelaw> but i still wouldn't know how to eat those tuples
13:37:50 <sinelaw> type-wise
13:38:27 <copumpkin> omnom
13:38:31 <sinelaw> or on literals
13:38:45 <sinelaw> nah
13:39:27 <Saizan> Expr would need another type parameter
13:39:37 <sinelaw> the problem lies in the fact that my GADT has (at least) one constructor who'se resulting type is different from the rest
13:40:21 <osaunders> Is there a lisp that translates to Haskell?
13:40:54 <sinelaw> Saizan, how do you mean? 
13:41:15 <sinelaw> you mean the fmap will be on that other more consistent type parameter?
13:41:48 <Saizan> yep
13:42:25 <gustavderdrache> G
13:42:31 <gustavderdrache> oh, bah
13:42:47 <gustavderdrache> i'm having trouble figuring out why GHC is giving me a type error
13:43:04 <sinelaw> i'll need to invent a meaning for that though :)
13:43:19 <gustavderdrache> i'm writing an xmonad.hs configuration, and while the exact same lines of code worked for the previous version, they don't now
13:43:44 <gustavderdrache> i have no idea how to even diagnose the problem
13:43:51 <copumpkin> gustavderdrache: start by pasting your code and error :P
13:44:03 <gustavderdrache> copumpkin: on it :)
13:44:11 <Saizan> sinelaw: it's not a moral imperative to have a Functor instance :D
13:44:54 <gustavderdrache> copumpkin:  http://hpaste.org/41775/xmonadhs_problems
13:44:59 <sinelaw> Saizan, sure, that was my sarcastic point
13:45:32 <sinelaw> The question was "does it make sense for an AST to be a Functor?"
13:45:47 <sinelaw> Saizan, we went from "sure" to "err....you can't, and you don't need to"
13:46:28 <Saizan> i guess i should have asked "what kind of AST?"
13:47:50 <sinelaw> :)
13:47:58 <sinelaw> what kind did you have in mind
13:48:30 <acemo> i'm getting this error but i'm not really sure how to fix it. Could someone give me some pointers in the right direction? http://hpaste.org/41779/error  code: http://hpaste.org/41778/heapsort
13:48:35 <sipa> what kind? i'd say * ;)
13:49:01 <sinelaw> grinding laughter comes to a halt
13:49:16 <sinelaw> screeching, even
13:49:49 <Saizan> one with a "Var :: a -> Expr a" constructor, and where 'a' doesn't change among constructors
13:50:04 <Saizan> if you want it to be typed you add another type parameter
13:50:59 <sinelaw> how so
13:51:56 <copumpkin> sinelaw: the a there is a variable's name
13:52:05 <Cale> acemo: If you're going to turn the list into an IO action, then even the empty list must become an IO action.
13:52:20 <Cale> acemo: But put also doesn't take an IO action as a parameter.
13:52:28 <Cale> (which x would be)
13:52:31 <Saizan> e.g. data Expr t v where Lit :: Int -> Expr Int v; Tuple :: Expr a v -> Expr b v -> Expr (a,b) v; Var :: v -> Expr t v
13:52:39 <Cale> er, no, set would be
13:52:48 <Cale> (since this is foldl)
13:52:56 <Cale> :t foldl
13:52:57 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
13:52:57 <Saizan> then (Expr t) is even a Monad
13:53:27 <acemo> Cale: your a genius.. i was thinking hey where is Cale he helped me so good the other night and poof there you are
13:53:29 <sinelaw> the first param is the type?
13:53:29 <Cale> acemo: So if a = IO (), as it seems you want there, set :: IO ()
13:53:31 <copumpkin> that's one of those Monad instances where bind makes a lot more sense than join
13:53:41 <sinelaw> and the second is what?
13:53:48 <copumpkin> sinelaw: the variable name
13:53:55 <sinelaw> what's the variable name of a literal?
13:54:09 <Cale> But it looks like you're having trouble deciding whether you want to be doing IO or sorting ;)
13:54:16 <sinelaw> what type of name does a literal have, rather?
13:54:18 <copumpkin> sinelaw: I mean, you could use Int for de bruijn indices
13:54:32 <Cale> It's probably best to keep those things separate.
13:54:50 * sinelaw looks up de bruijn indices
13:55:04 <acemo> Cale: i just had the sorting working.. but my teacher wants a status output after each step
13:55:06 <sinelaw> holy macro
13:55:40 <sinelaw> ooh, i just thought of that idea myself (except of how to actually do it)
13:55:46 <Cale> acemo: Maybe produce a list of the results after each step. If your sort was a foldl before, it will become a scanl.
13:55:54 <Cale> acemo: Then you can print those results out.
13:56:01 <mightybyte> @seen edwardk
13:56:01 <preflex>  edwardk was last seen on #haskell 3 days, 17 hours, 20 minutes and 46 seconds ago, saying: osunders: yes
13:56:01 <lambdabot> Unknown command, try @list
13:56:24 <ClaudiusMaximus> what does * mean in the type field of   +RTS -hy   ?
13:57:08 <Cale> > foldl (+) 0 [1,2,3,4,5]
13:57:09 <lambdabot>   15
13:57:13 <Cale> > scanl (+) 0 [1,2,3,4,5]
13:57:14 <lambdabot>   [0,1,3,6,10,15]
13:57:45 <acemo> Cale: so if i'd change foldl for scanl it would produce something for each step and i could just print them all in the end? I wonder how that would go for 15000 numbers.. :)
13:58:02 <Cale> acemo: Just fine. It's lazy, so it'll only compute them as it prints them.
13:58:14 <Cale> (and 15000 is tiny)
13:58:37 <acemo> Cale: it all depends on your perspective :)
13:58:47 <ClaudiusMaximus> i have an annoying memory leak i'm trying to debug - don't know if it's my fault or if it's the 'ad' package...
13:59:09 <acemo> but if you say 15000 is tiny, then it should go fine for large lists :)
13:59:18 <Cale> I have a VM running and using ~700MB of memory even when I'm not using it :P
13:59:32 <sinelaw> Saizan, if you replied i missed it. disconnected
13:59:58 <ClaudiusMaximus> ..it runs fine for ~45 seconds, then memory usage shoots up at around 100MB/s
14:00:09 <acemo> Cale: i was thinking of actually forcing the program to do external sorting.. as in .. i have 4 gb ram, so make a file of 6 gb of numbers and sort that
14:00:13 <Saizan> sinelaw: the first param is the type, the second is the type of variable names
14:00:39 <Cale> acemo: Yeah, things get difficult once you start swapping :)
14:01:00 <sinelaw> Saizan, thanks
14:01:18 <acemo> ahh thats not fair... swapping is cheating.. then it might still be having everything "in memory"
14:01:47 <Cale> Well, that's what it'll do.
14:02:05 <Cale> Unless you rewrite it to handle swapping things out to disk on its own.
14:02:56 <acemo> meh..
14:03:10 <acemo> i guess i won't have to do such things then..
14:08:35 <sinelaw> Saizan, thanks! I'm progressing now :)
14:09:15 <Saizan> sinelaw: np :)
14:10:36 <Mitar> i am using GADTs so I have different constructors for different resulting types - is it possible to tell haskell by resulting type which constructor should it use to create the value? currently I have to tell this information twice: by values which selects proper constructor and then I have to match the type
14:11:05 <copumpkin> a typeclass is the mechanism you use to select by type
14:11:29 <Mitar> but i have gadts?
14:11:34 <copumpkin> so?
14:11:52 <copumpkin> class Moo a where stickIntoGADT :: a -> MyGADT a
14:12:10 <copumpkin> instance Moo Int where stickIntoGADT = MyGADT'sIntConstructor
14:13:29 <Mitar> example: http://hpaste.org/41780/gadts
14:13:29 <sinelaw> copumpkin, what was the monad you talked about in the context of the variable name types?
14:13:46 <copumpkin> sinelaw: Expr a -> (a -> Expr b) -> Expr b
14:14:01 <Mitar> in growNerve i have to pass a value (Conductivity) and also match a type
14:14:09 <copumpkin> basically gives you a chance to rename variables and graft the ASTs together
14:14:32 <sinelaw> graft?
14:14:37 <copumpkin> stick together
14:14:40 <sinelaw> oh
14:14:53 <Mitar> it would be great that it would create the neuron of proper values based on the context type
14:15:15 <sinelaw> you mean fix the ambiguities
14:15:24 <sinelaw> do the required alpha conversions
14:15:28 <sinelaw> so to speak
14:15:43 <sinelaw> that's cool!
14:15:53 <sinelaw> a form of lexical scoping
14:15:54 <Mitar> so that if I say growNerve :: IO (Nerve Something AxonConductive Something AxonConductive) i would one value
14:15:59 <copumpkin> sinelaw: it basically gives you the opportunity to take every free variable name in your source expression tree
14:16:15 <copumpkin> and replace it with another expression tree that has a (possibly different) kind of free variable
14:16:21 <copumpkin> so it's substitution for your variables
14:16:42 <copumpkin> Mitar: a typeclass
14:17:07 <Mitar> hmm
14:17:26 <copumpkin> Mitar: as I said a month or two ago, I'd advise you start with simple examples
14:17:28 <copumpkin> to understand the stuff
14:17:34 <copumpkin> rather than poking around blindly, as you've admitted you're doing
14:17:46 <copumpkin> because the latter teaches you very little and makes us do the hard stuff :P
14:17:57 <finnomenon> is LYAH a good place to start?
14:17:57 <Mitar> no, but things already play nice
14:18:17 <Mitar> it is just that there are some rough edges
14:20:05 <Mitar> the other way would be to do growNerve valueForConductivity :: IO (NerveTypeFun Something)
14:20:21 <Saizan> finnomenon: yep
14:20:50 <Mitar> but it does not work to have: type NerveTypeFun n = forall fromConductivity forConductivity. Incubation (Nerve n fromConductivity n forConductivity)
14:21:16 <finnomenon> thank you
14:22:14 <sinelaw> is it normal to do this for the sake of defining different type class instances on different type parameters? 
14:22:34 <sinelaw> type FExpr v t = FExpr  (Expr t v)
14:22:42 <sinelaw> err, data that is
14:23:26 <sinelaw> and then
14:23:35 <sinelaw> instance Functor (Expr a) ...
14:23:44 <sinelaw> instance Monad (FExpr a)
14:24:10 <copumpkin> you can't do that
14:24:23 <copumpkin> oh newtype
14:24:25 <copumpkin> yeah
14:24:39 <sinelaw> k
14:24:45 <copumpkin> why are you defining them on different indices?
14:24:55 <copumpkin> Functor and Monad (and Applicative) are all on the variable name index
14:25:07 <sinelaw> copumpkin, i'm thinking of a different monad
14:25:11 <copumpkin> :O
14:25:47 <Phyx-> Monad all the way down man
14:25:56 <sinelaw> copumpkin, one that forces a variable to have the same type in a series of statements
14:27:53 <davekong__> When I try to "xmonad --recompile" I get the linking error: collect2: ld terminated with signal 9 [Killed], anyone know how to fix this?
14:28:14 <copumpkin> sinelaw: you'd still run into the issue of Functor on a GADT then
14:28:38 <sinelaw> hmm
14:28:57 <sinelaw> :(
14:29:12 <copumpkin> what would you want the Functor to do?
14:29:15 <copumpkin> or the Monad to do?
14:29:42 <sinelaw> i don't really care how it's done, but i want a way to tie the type of a variable between different expressions
14:29:54 <sinelaw> since variables are polymorphic
14:30:50 <copumpkin> variable?
14:31:13 <copumpkin> the other parameter is the type of the whole expression
14:31:19 <sinelaw> copumpkin, data Expr t v where Variable :: v -> Expr t v
14:31:27 <sinelaw> ...
14:31:29 <sinelaw> then later:
14:31:35 <copumpkin> that's the one with the easy monad instance
14:31:37 <copumpkin> that we talked about
14:32:26 <sinelaw> let v = Variable "blabla"; a = ... expression involving v .... ; b = ... different expression involving v ....
14:32:48 <sinelaw> normally v would have a different 't' type parameter in 'a' and 'b', if that's what comes out
14:32:59 <sinelaw> i want to force it to have the same type in both
14:33:16 <sinelaw> if possible, and fail if not
14:33:31 * copumpkin is confused
14:33:41 <copumpkin> (Expr t) is easily a Monad
14:33:48 <copumpkin> Expr _ v is not
14:33:56 <sinelaw> copumpkin, i know
14:34:01 <sinelaw> but how do i get what i want?
14:34:07 <copumpkin> I don't understand what you want
14:34:24 <sinelaw> do you get what i meant by that "let" example?
14:34:39 <sinelaw> not so clear, but i don't know another way to explain it
14:34:44 <copumpkin> how are you even dealing with binders?
14:35:17 <mreh> @instances MonadWriter
14:35:18 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
14:35:29 <sinelaw> copumpkin, what?
14:35:48 <copumpkin> sinelaw: oh you mean let in haskell, not let in the language you're modeling?
14:35:55 <sinelaw> yes
14:37:49 <djahandarie> @tell chrisdone Add SQL to hpaste?
14:37:50 <lambdabot> Consider it noted.
14:41:19 <Apocalisp> > let times n m = if n < 1 then m else (m >> times (n - 1) m) in evalState (times 10 State(uncons)) fibs
14:41:20 <lambdabot>   1
14:41:31 <Apocalisp> > take 20 fibs
14:41:32 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765]
14:42:18 <Apocalisp> Why doesn't evalState give me the 10th fib?
14:42:56 <Apocalisp> > let uncons xs = (head xs, tail xs); times n m = if n < 1 then m else (m >> times (n - 1) m) in evalState (times 10 State(uncons)) fibs
14:42:57 <lambdabot>   1
14:43:47 <Cale> > let uncons xs = (head xs, tail xs); times n m = if n < 1 then m else (times (n - 1) m >> m) in evalState (times 10 State(uncons)) fibs
14:43:48 <lambdabot>   1
14:44:40 <Cale> > let uncons xs = (head xs, tail xs); times n m = replicateM n m in evalState (do x <- State uncons; y <- State uncons; z <- State uncons; return (x,y,z)) fibs
14:44:41 <lambdabot>   (1,1,2)
14:44:47 <copumpkin> > (let times n m = if n < 1 then m else (m >> times (n - 1) m) in evalState (times 10 State(uncons)) fibs, evalState (replicateM 10 (State(uncons)))
14:44:48 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
14:44:51 <copumpkin> boo
14:44:59 <Cale> > let uncons xs = (head xs, tail xs); times n m = replicateM n m in evalState (replicateM 10 (State uncons)) fibs
14:45:01 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
14:45:11 <sinelaw> maybe I can do without that tuple constructor
14:46:14 <Cale> > let uncons xs = (head xs, tail xs); times n m = if n < 1 then m else (m >> times (n - 1) m) in evalState (times 10 (State(uncons))) fibs
14:46:15 <lambdabot>   89
14:46:23 <Cale> ^^ :)
14:46:32 <Cale> Parens were wrong
14:46:39 <Cale> > let uncons xs = (head xs, tail xs); times n m = if n < 1 then m else (m >> times (n - 1) m) in evalState (times 10 (State uncons)) fibs
14:46:40 <lambdabot>   89
14:46:42 <Apocalisp> Hah!
14:47:04 <Apocalisp> Too much Scala
14:47:48 <Apocalisp> Speaking of Scala, Cale... when are you coming to work with me, edwardk and copumpkin?
14:48:05 * copumpkin would also like to know
14:48:24 <Phyx-> you guys plotting to take over the world?
14:48:30 <copumpkin> Phyx-: pretty much
14:48:41 <Saizan> za warudo
14:49:05 <Phyx-> copumpkin: great, can I be the court jester?
14:49:10 <Cale> Write a Haskell -> Scala compiler.
14:49:22 <Apocalisp> I've a partial one
14:49:30 <Apocalisp> it only works for ADTs
14:49:43 <sinelaw> Apocalisp, if you need a janitor
14:49:59 <sinelaw> ...don't call me! hah.
14:50:18 <sinelaw> time to sleep
14:50:57 <djahandarie> lol
14:55:21 <Phyx-> huh, Haskell.org is down again?
14:55:29 <djahandarie> Did it ever come back up?
14:55:48 <Phyx-> yes..
14:55:51 <Phyx-> it's up even
14:55:59 <Zao> Worked for me today when I fetched GHC7.
14:55:59 <Phyx-> well.. something is
14:56:12 <Zao> (also, the lack of obviousness what GHC version is in a HP is sad)
14:56:26 <Zao> (you have to maze your way to the changelog for a particular HP for it)
14:56:40 <Phyx-> and the fact that there's no direct link to GHC anymore and the haskell.org page
14:57:09 <Watermind> I was looking at  Richard Birds book  and it talks about a space leak in QuickSort when using partition
14:57:18 <Phyx-> Zao: aren't changelogs typically where such information resides?
14:57:48 <Phyx-> Zao: it's the first entry on the page! it's not that hard :P
14:58:02 <Watermind> the idea is that in:  qs (x:xs) = qs ys ++ [x] ++ qs zs where (ys,zs) = partition (<=x) xs
14:58:23 <Watermind> the pair (ys,zs) is only discarded when it is not needed anymore
14:58:38 <Watermind> so if zs is always empty we have a problem
14:58:45 <Watermind> but is this still really the case?
14:59:22 <Watermind> is there a reason why the compiler wouldn't be smart enough to store a pointer for ys and another for zs
14:59:22 <byorgey> well, that's not the sorting algorithm used in the standard libraries, if that's what you're asking
14:59:38 <byorgey> if you're asking about the state of compiler/optimization technology, I have no idea
14:59:42 <dobblego> can I somehow have record selectors to exist on a type-class rather than the data type?
14:59:48 <Watermind> byorgey: yeap it was the 2nd :S
15:00:17 <byorgey> dobblego: I'm not sure what you're asking, can you give an example?
15:00:44 <Watermind> byorgey: there's a quicksort in the libraries?
15:00:49 <byorgey> no
15:01:14 <Watermind> right didn;t think so
15:01:21 <Phyx-> Watermind: it does store a pointer, but Haskell values are immutable. so it'll never update the value
15:01:27 <dobblego> byorgey, given data T = T { t :: Int }, then somehow get class T' t where :: set :: Int -> a -> a; get :: a -> Int and instance T' T where ...
15:01:31 <Zao> Phyx-: Once you manage to walk randomly to find it, sure.
15:01:40 <Zao> Phyx-: The GHC version is not mentioned anywhere relevant.
15:02:04 <dobblego> s/class T' t/class T' a
15:02:17 <Phyx-> Zao: Idk, I find the changelog a pretty relevant place, and it's easy to get to. It's the same place I find which svn server version my svn server uses etc
15:02:54 <Watermind> Phyx-: I understand that Phyx-, it's not what I meant
15:03:17 <Watermind> Phyx-: the leak happens because the pair (ys,zs) is kept until it is not needed anymore
15:03:40 <Phyx-> right
15:04:04 <Watermind> Phyx-: I was wondering why the compiler wasn't smart enough to, instead of keeping a pointer to the pair, keeping a pointer to each component after the pair is evaluated to head normal form
15:04:40 <Watermind> Phyx-: since the pair is pattern matched and then not used elsewhere... only its components
15:04:56 <byorgey> dobblego: perhaps you are interested in a package such as data-accessor, fclabels, or lenses?
15:05:31 <Watermind> I didn't try profiling to see if there's an actual space leak yet... to be honest... just reading the books on it
15:06:15 <Saizan> Watermind: "let (a,b) = ... in .. a .. b .." is really "let p = ... in ... fst p .. snd p ..", i.e. the tuple is not forced immediately
15:07:08 <Watermind> Saizan: true... good point the pattern matching in lets is lazy
15:07:34 <Watermind> Saizan: but what if it was substitued with a strict pattern match, using ! or a case
15:08:26 <Saizan> Watermind: then i think referring to just one field wouldn't keep the other alive
15:09:08 <Watermind> Saizan: ah alright then
15:11:53 <dobblego> byorgey, I'll take a look at those cheers
15:12:08 <augur> byorgey!
15:12:10 <augur> \o/
15:12:21 <mreh> http://pastebin.com/LmQ0cAaa
15:12:29 <mreh> this is a big load of munge
15:13:58 <byorgey> hey augur! \o/
15:14:06 <byorgey> augur: I'm writing up a blog post explaining species subtraction
15:14:15 <augur> :o
15:14:17 <augur> :D
15:14:27 <augur> link to your blog?
15:16:33 <djahandarie> > evalState (foldM (\_ _ -> State $ head &&& tail) undefined [1..10]) fibs
15:16:34 <lambdabot>   55
15:16:38 <djahandarie> Blarge.
15:17:40 <copumpkin> > evalState (foldM (\_ _ -> State $ head &&& tail) undefined (replicate 10 undefined)) fibs
15:17:41 <lambdabot>   55
15:17:46 <djahandarie> Hehe
15:18:06 <copumpkin> > evalState (replicateM 10 (State $ head &&& tail)) fibs
15:18:07 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
15:18:49 <djahandarie> There is annoyingly no function that "discards everything until the last one" in Control.Monad
15:19:15 <ddarius> last <$> sequence
15:19:33 <djahandarie> I don't like how that builds a list intermediately
15:21:10 <djahandarie> Someone should really teach @pl about arrows
15:21:21 <ddarius> djahandarie: Go ahead.
15:21:25 <byorgey> augur: byorgey.wordpress.com
15:21:42 <djahandarie> ddarius, last time I looked at the pl code I remember not wanting to look again
15:21:48 <byorgey> augur: it's also syndicated on Planet Haskell, if you're subscribed to it
15:22:30 <ddarius> djahandarie: So rewrite it completely.
15:28:15 <augur> byorgey: <3
16:26:47 <orbital_fox> hi
16:26:54 <Mitar> is there a way to find out if two values are in fact the same value by its reference?
16:27:03 <orbital_fox> what would you call a function that converts a set to another set?
16:27:11 <ddarius> reallyUnsafePtrEq
16:27:19 <ddarius> A function.
16:27:28 <Mitar> :t reallyUnsafePtrEq
16:27:53 <orbital_fox> ive been looking into "transform" but that applies more to geometric transformations
16:28:23 <Mitar> but maybe there is a better way: i want to keep track how many times some function was called on particular Chan
16:28:35 <orbital_fox> mapping is the next to it, but its too generic, and does not imply conversion (this is in C++)
16:28:38 <Mitar> so the result of newChan
16:30:42 <Mitar> hm, MVar has Eq
16:30:46 <Mitar> why Chan does not?
16:32:51 <ddarius> Mitar: There's probably no good reason.
16:33:06 <Mitar> and is there a way to hack it in?
16:33:36 <Mitar> i would like to know if I have to call dupChan or not
16:33:42 <Mitar> if there are multiple consumers
16:34:16 <Mitar> and this i could do by storing a list of all current consumers and if there are more then one i wold dupChan for this new one
16:34:51 <Mitar> ehm, not a list of consumers, but a list of chans which already have consumers
16:39:13 <ivanm> preflex: seen lispy
16:39:13 <preflex>  lispy was last seen on #darcs 51 seconds ago, saying: So, is http://darcs.net going away?
16:40:08 <lispy> ivanm: hey, I saw your request to try out SourceGraph but I've been at work so I didn't try it.  Due to US holiday I may not try it till next week :(
16:40:16 <ivanm> fair enough
16:40:23 <ivanm> what was that about darcs.net going away?
16:40:45 <lispy> ivanm: Nothing to worry about.  People are shuffling urls
16:40:52 <Mitar> where is sameMVar# defined?
16:40:56 <ivanm> oh? what's the new darcs URL going to be?
16:40:59 <Heffalump> it's not.
16:41:15 <Heffalump> the website will stay where it is, the main public darcs repo is still there and will remain there.
16:41:17 <lispy> ivanm: I was just asking about the url of the developers active branch for darcs.
16:41:24 <ivanm> ahhhhhh
16:41:29 <Heffalump> it's just that we're using a new branch to keep work that's under review
16:41:35 <ivanm> *nod*
16:41:43 <lispy> Nothing to see here :)
16:41:54 <ivanm> heh
16:42:13 <ivanm> lispy: anyway, hackage says Graphalyze at least builds on ghc-7, so maybe SourceGraph will as well
16:43:11 <lispy> ivanm: ah, that's encouraging, although IIRC, Graphalyze was fine out of the box and the main issue was with getting cabal to correctly resolve the dependencies for SourceGraph such that it didn't reinstall the libraries that ship with GHC7.
16:43:21 <ivanm> *nod*
16:43:40 <ivanm> it appears that Hackage doesn't bother testing executable-only packages...
16:44:17 <lispy> ivanm: I think I want a feature where cabal knows (per GHC install) which libraries it should not re-install and complains (requires --force or something) when an install plan requires older versions of "core" libs
16:44:33 <ivanm> as do I
16:44:47 <ivanm> (though I want it from a distro package management point of view)
16:44:59 <ivanm> ghc-pkg at least should indicate which libraries are boot libraries
16:45:06 <lispy> yes
16:45:44 <lispy> "Installing another version of this library can lead to headaches.  Proceed? [y/N]"
16:46:17 <ivanm> heh
16:46:32 * hackagebot libxml-sax 0.6.1 - Bindings for the libXML2 SAX interface  http://hackage.haskell.org/package/libxml-sax-0.6.1 (JohnMillikin)
16:46:33 <ivanm> but with a special exception for Cabal that you can upgrade it, just not unregister the old one
16:48:02 <augur> byorgey!
16:48:10 <augur> wheres my subtraction explanation >|
16:48:44 <ivanm> augur: well, you see, you have two numbers...
16:48:48 <ivanm> :p
16:49:04 <nus> >|-|<
16:49:57 <augur> ivanm: YOU ARE NOT BYORGEY
16:50:08 * ivanm looks down, then up again
16:50:14 <ivanm> waddaya know, you're right! :o
16:50:15 <ivanm> ;)
16:57:47 <monochrom> oh, old version can be installed, this is going to be funny
16:59:38 * hackagebot redis-hs 0.1.0 - A simple Redis library for Haskell  http://hackage.haskell.org/package/redis-hs-0.1.0 (WillLangstroth)
17:01:38 * hackagebot libxml-enumerator 0.4.0.3 - Enumerator-based API for libXML's SAX interface  http://hackage.haskell.org/package/libxml-enumerator-0.4.0.3 (JohnMillikin)
17:02:53 <ivanm> monochrom: hmmm?
17:10:57 <onteria> Anyone around to update the "haskell.org is down" part of the topic?
17:11:14 <ion> > {- Is this the best translation of the list comprehension [x | x <- [0..9], even x] to the do notation? I'm trying to figure things out with this entirely hypothetical example. -} do x <- [0..9]; guard $ even x; return x
17:11:34 <Cale> ion: That's correct
17:11:42 <ion> thanks
17:11:44 --- mode: ChanServ set +o monochrom
17:11:55 --- topic: set to '["GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
17:12:09 <onteria> cheers
17:12:30 --- mode: monochrom set -o monochrom
17:23:05 <djahandarie> monochrom, you probably want to add haskell.org back in the topic since it isn't anywhere else ;)
17:25:15 <robink> I'm having issues compiling GHC 6.12.3
17:25:22 <robink> It complains that it cannot find HsBase.h
17:56:51 --- mode: ChanServ set +o monochrom
17:57:20 --- topic: set to '["GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
17:57:28 --- mode: monochrom set -o monochrom
17:58:22 <monochrom> where is haskell weekly news? :)
17:59:57 <djahandarie> ┐(´ー｀)┌
18:24:31 <orlandu63> what is the definition of pure for Pointed ((->) e)?
18:24:50 * edwardk waves hello.
18:25:02 <mightybyte> edwardk: Ahh, just got your message.
18:25:15 <mightybyte> > mzero :: Either String Int
18:25:59 <edwardk> mightbyte the instance for Either is a bit busted. the mtl version relies on a crappy Error constraint on the left hand argument
18:26:23 <mightybyte> edwardk: I was thinking it would be the same as it is for Either.
18:27:01 <mightybyte> Just today I was wanting to use the MonadPlus behavior for Either in the context of EitherT
18:27:08 <mm_freak> orlandu63: const
18:27:25 <edwardk> yeah, the reason Either and EitherT have separate instances category-extras from the broken Either and ErrorT in mtl is that the Error constraint on Either to support fail screws up the symmetry that allows us to define apomorphisms using the Either monad
18:27:49 <mightybyte> Hmmm
18:27:57 <mm_freak> orlandu63: this is easy to see, if you interpret the ((->) e) functor properly
18:27:58 <edwardk> you need to have the very valid Either instance that doesn't require the Error on the left hand argument.
18:28:05 <mm_freak> orlandu63: it's the reader monad
18:28:35 <edwardk> the version in the (old) mtl broke a perfecty good monad to better support fail. ;)
18:28:54 <mightybyte> Heh
18:29:16 <mightybyte> Is there an abstraction that unifies the monadplus behavior of Maybe and Either String?
18:29:24 <edwardk> personally i rather like the devil's advocate proposal that the definition of fail for (Either a) should be fail s = Left (error s)
18:30:00 <mm_freak> mightybyte: Either does
18:30:14 <edwardk> that lets you use the cheesy [ x | Right x <- xs, … ] hacks
18:30:24 <mm_freak> mightybyte: Maybe is a special case of Either, where the left type is ()
18:30:30 <kmc> hi edwardk :)
18:30:33 <edwardk> mm_freak: right now
18:30:37 <edwardk> heya kmc
18:30:38 <mightybyte> mm_freak: No, that's not what I'm looking for.  I was wanting to write a generic function that could work with both Maybes and Eithers.
18:30:51 <mm_freak> mightybyte: then you need to write a typeclass
18:31:01 <kmc> hmm, i was wondering recently how to define what "codata" is
18:31:20 <mm_freak> mightybyte: if you want a ready-made one, try my contstuff library, which includes a class HasExceptions, of which both are instances
18:31:31 <kmc> i have a vague idea that it has to do with coinduction
18:31:45 <mm_freak> Control.ContStuff> do raise () :: Maybe Int
18:31:45 <mm_freak> Nothing
18:31:48 <kmc> but i can only describe induction vs. coinduction in terms of the checking one would use in a theorem prover
18:31:57 <mm_freak> Control.ContStuff> do raise () :: Either () Int
18:31:57 <mm_freak> Left ()
18:31:58 <edwardk> kmc: drop the need for the base case ;)
18:32:00 <kmc> (structurally decreasing vs. ctor-guarded recursion)
18:32:15 <kmc> are all Haskell "data" types actually codata?
18:32:16 <edwardk> kmc: (that being the somewhat glib way to talk about it)
18:32:23 <edwardk> kmc: unless you use !
18:32:29 <kmc> even non-recursive types?
18:32:59 <edwardk> kmc: when you are talking about non-recursive types it doesn't really matter
18:33:10 <mm_freak> doesn't codata /have to/ be recursive?
18:33:15 <mightybyte> mm_freak: Hmmm, I would want Either to be Left ""
18:33:24 <mightybyte> ...to go with the Monad instance.
18:34:09 <mm_freak> mightybyte: then raise "" instead of () =)
18:34:13 <edwardk> codata just says you talk about how you take it apart. you can think of codata being something that you know how to peel off the outermost constructor from so you want it to be 'productive' in that you should be able to get to the next layer in bounded time
18:34:21 <Mitar> why does this not work? http://hpaste.org/41787/eqbox
18:34:32 <mightybyte> Ahh
18:34:42 <Mitar> deriving does not succeed
18:34:51 <edwardk> but that data you are concerned with it being well founded, you want to know you can reach your base case eventually, so you know that the computation will finish.
18:35:12 <mm_freak> edwardk: i see
18:35:37 <byorgey> Mitar: try writing an Eq instance yourself.  I think you will find it difficult.
18:36:03 <byorgey> Mitar: the problem is that if you have two different EqBox values, you have no idea whether the things inside have the same types
18:36:18 <byorgey> all you know is that each is an instance of Eq.
18:36:27 <byorgey> but that doesn't help you compare them against each other.
18:37:03 <monochrom> "GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem."
18:37:10 <byorgey> Mitar: in order to do this you would have to add a Typeable constraint.
18:37:13 <monochrom> It is your problem.
18:37:29 <byorgey> Mitar: then you could do a type-safe cast to first see whether they are the same type, and if not, return False.
18:37:40 <Mitar> hmm
18:38:29 <monochrom> the boilerplate code probably looks like "EB x == EB y = x==y" and it obviously cannot typecheck, x and y are almost guaranteed different types.
18:38:56 <Mitar> ok, but in fact they are all (Chan something)
18:39:18 <monochrom> or rather since it's existential, x and y are of unknown types.
18:40:02 <monochrom> well nothing in "EB :: Eq e => e -> EqBox" says they are in fact Chan or whatever.
18:40:50 <Mitar> ok
18:40:51 <Mitar> i agree
18:41:10 <monochrom> I am sorry if the computer is not psychic.
18:41:14 <Mitar> i just want to have a list of unique elements
18:41:31 <Mitar> where if types are different it should be seen as different element
18:42:22 <Mitar> so using existential allows me to have such list, but then i loose types
18:48:48 <edwardk> i actually had my first experience writing a scala library that turned out nicer than the equivalent in haskell the other day
18:49:16 <djahandarie> No! You just aren't good enough at Haskell
18:49:18 <Mitar> so something like this: http://hpaste.org/paste/41787/so#p41788
18:49:37 <edwardk> djahandarie: clearly =)
18:51:15 <ivanm> edwardk: wtf?
18:51:20 <ivanm> heretic!!!!!!!
18:51:22 <ivanm> :p
18:51:53 <edwardk> basically because of the crazy duck-typing things you can do, lenses make a pretty sexy scala library. you can use them directly as state monadic getters, etc. the result is pretty much invisible
18:52:05 <monochrom> need a #co-haskell for refugees from haskell and the "I left the church" kind
18:52:12 <eigen> Is there such a thing as haskell mode for emacs?
18:52:18 <monochrom> yes
18:52:20 <eigen> Is there a haskell mode for vim?
18:52:40 <ddarius> yes
18:52:41 <edwardk> eigen: yes on both counts
18:52:45 <monochrom> http://projects.haskell.org/haskellmode-emacs/
18:53:32 * applicative is looking for his haskell.nanorc
18:53:51 <eigen> Is the emacs haskell mode the best mode to use when editing haskell source?
18:54:12 * ddarius feeds text into language implementations and thus uses a text editor to edit the input.
18:54:14 <monochrom> yes
18:54:48 <edwardk> eigen: honestly, i just use vim with the haskell source highlighting and avoid the editor modes. the emacs mode fights with me on indentation too much and the vim one is just odd
18:55:00 <eigen> Does anyone have experience using both vim and emacs' haskell modes? Do you prefer the one over the other?
18:55:07 * ivanm for one uses fortran-mode when editing haskell source
18:55:08 <ivanm> :p
18:55:27 <ivanm> edwardk: which of the three indentation modes are you referring to?
18:55:32 * ddarius also just uses plain vim with the pre-packaged Haskell source syntax highlighting and is perfectly happy.
18:55:52 <monochrom> the emacs mode guesses all of my indentations correctly
18:56:19 <ivanm> the newest emacs mode fails for me when I have split strings :(
18:56:21 * applicative thinks monochrom is just obeying haskell-mode
18:56:42 * applicative obeys the typechecker
18:56:44 <edwardk> ivanm i thought there was something odd about your indentation. now i understand. that and all those lines with C on the left...
18:56:53 <ddarius> applicative: monochrom is all about putting things in forms that are easier for computers.
18:57:16 <ivanm> edwardk: can't be my source; I have it set to fortran-90, not -77
18:57:25 <applicative> 'man is not made for programming languages, but ...." no forget that
18:57:31 <ivanm> ddarius: so, machine code?
18:58:17 <monochrom> it does if-then-else correctly too
19:00:25 <lars9> @instances Monoid
19:00:56 <eigen> Why don't I get anything if I type "cabal list emacs"?
19:01:00 <lars9> omg, lambdabot is not here
19:01:04 <lars9> what happened
19:01:09 <monochrom> because it is not on hackage.
19:01:14 <ddarius> lars9: The beginning of the end.
19:01:20 <lars9> ddarius: indeed
19:01:23 <eigen> cabal list *a*
19:01:26 <eigen> returns nothing too
19:01:31 <ivanm> eigen: as monochrom told you already: http://projects.haskell.org/haskellmode-emacs/
19:01:35 <lars9> where else can i query @instances?
19:01:47 <ivanm> there is I think ghc-mod that does emacs integration...
19:01:55 <ivanm> lars9: the documentation for that class?
19:02:14 <ddarius> lars9: I believe :info will tell you instances in scope.
19:02:19 <ddarius> But I could be wrong.
19:02:30 <byorgey> @tell augur geez, hold your horses, can't a guy eat some dinner and play Wii with his little brother? =)
19:02:47 <ivanm> lol
19:02:50 <eigen> What I mean to ask is: how do you use the "cabal list" facility? Does it take a string like "cabal list <string-to-search-for>?
19:02:51 <ddarius> byorgey: Magic 8 ball says, "Try again later."
19:02:58 <ivanm> ddarius: yeah, it does (:info)
19:05:58 <monochrom> "cabal list monad" works
19:06:19 <monochrom> in fact "cabal list *a*" also works correctly.
19:06:28 <djahandarie> Stuff sure seems to enjoy breaking.
19:07:10 <monochrom> since no package has name with substring "*a*", cabal list gives you an empty list correctly.
19:07:19 <ddarius> djahandarie: I blame the physicists.
19:07:30 <eigen> I'm used to "find . *a*"
19:08:17 <ddarius> "Why does GHC complain when I put python code in my .hs files?"
19:08:36 <ivanm> monochrom: `cabal list *a* ' returns a whole bunch of packages here...
19:09:05 <monochrom> oh fun
19:09:13 <djahandarie> ddarius, because you forgot to enable the python quasiquoter?
19:09:32 <monochrom> you need to cabal install pythonmonad
19:12:12 <ddarius> @hackage berp
19:13:33 <monochrom> http://hackage.haskell.org/package/berp
19:13:59 <copumpkin> dons: there's someone impersonating you on the haskell reddit
19:14:10 <monochrom> oh what fun
19:14:55 <copumpkin> http://www.reddit.com/user/Donald_Stewart
19:14:59 <ivanm> copumpkin: yeah, we were discussing that earlier on -blah
19:15:03 <copumpkin> oh
19:15:14 <ivanm> I liked the list comment
19:15:16 <copumpkin> well since dons is a mod on /r/haskell, he can at least ban him
19:15:35 <ivanm> yeah
19:15:41 <copumpkin> and on /r/programming, really
19:15:50 <ivanm> monochrom: are you lambdabot's replacement or something? :p
19:16:04 <monochrom> I sometimes emulate lambdabot
19:16:40 <ivanm> @quote
19:17:11 <ivanm> awwwwwww...... you obviously aren't emulating the quote part of lambdabot :(
19:17:31 <monochrom> ray says: programmers are people who voluntarily use 1970 terminals. you can't reason with them.
19:17:39 <ivanm> hooray!
19:17:43 <ivanm> ;)
19:19:14 <applicative> the impersonator is not a haskeller, s/he doesn't put a space before right parentheses
19:19:17 <applicative> "think(You'" ... "Haskell(Solution" ... "work(which" ..."make.(I "
19:19:33 <applicative> left parentheses.  co-right-parentheses
19:20:42 * applicative is thinking of impersonating jdh, recent haskell convert
19:21:05 <ivanm> lol
19:21:08 <Wolfspaw> copumpkin: yeah, the impersonator is cleary a troll. Making stupid comments everywhere @_@
19:21:15 <copumpkin> yeah
19:23:45 <ivanm> monochrom: with emacs haskell-mode, do you find it not indenting individual cases in a case statement enough?
19:24:39 <monochrom> it indents enough. there is a variable to tune it too.
19:25:39 <monochrom> look under the group "haskell-indentation"
19:25:42 * applicative gives up his plan of impersonating Harrop.  But googling around, he's thinking of 'friending' him on F_ceb__k
19:27:10 <monochrom> alternatively if your style is "case x of Nothing -> haha <newline> Just y -> hoho" there is no such thing as not enough
19:27:32 <ivanm> heh
19:27:57 <ivanm> I find that by default the first case gets indented to two spaces in compared to the previous line, and not lined up under the case
19:28:47 <ivanm> hmmm, there's nothing under haskell-indentation to tune how case statements are indented...
19:29:02 <monochrom> "case x of <newline> Nothing" is 2 spaces. "case x of Nothing -> blah <newline> Just" is lined up.
19:30:09 * applicative thinks this is why God made what are called "touch-pads," then you just go move the second case a little when your two bit indenter makes a hash
19:30:35 <monochrom> "Haskell Indentation Left Offset"
19:30:47 <ivanm> yeah, but that affects _everything_
19:31:09 <ivanm> applicative: I use something called a "space bar" to do that
19:31:42 <augur> byorgey!
19:31:49 <ivanm> I don't see how a touch pad would help
19:32:09 <augur> regale me with stories of negative species :3
19:34:07 * applicative thinks, space bar space bar .. oh yeah above what is called the "touch pad".
19:34:32 <kmc> :∃
19:35:02 * applicative is trying case expressions in all the two-bit editors he uses for Haskell.  All but nano is doing fine....
19:35:26 <ivanm> wow, there are editors that load up in only two bits of RAM? :o
19:35:27 <JoeyA> What's a common naming convention for continuations?
19:35:35 <ddarius> k
19:35:42 <monochrom> c
19:35:46 <ddarius> c, cont
19:35:50 <monochrom> kont
19:36:00 <JoeyA> thanks
19:37:14 <monochrom> so touch pad means space bar?
19:37:49 <kmc> κ
19:38:03 <ivanm> kmc: stop showing off!
19:38:06 * applicative notices that yi seems to be a monster fail.  return after "case x of" puts him flush left... maybe return is the wrong key?
19:38:35 <monochrom> yi is a 2-bit editor?
19:38:56 <applicative> it is god's editor.  doesn't care about the whitespace rule.
19:38:57 <ivanm> monochrom: so for you, if you have something like "foo x = case x of" and then hit enter, where does it indent to for you?
19:39:03 <mwc> Any Finns around right now? How is Tuevo pronounced (need to know when citing something in a talk tomorrow), Two-Ay-Vo or Tway-vo?
19:39:26 <ivanm> I would have guessed Two-eh-vo, but I'm not a Finn
19:39:39 <ivanm> (or maybe Twe-vo)
19:39:50 <monochrom> 2 spaces after "f"
19:39:51 <ddarius> ivanm: Exactly like haskellmode indents and whatever that is is exactly what monochrom wants.
19:39:59 <ivanm> fair enough
19:41:50 <applicative> mwc the listen button thingy on http://translate.google.com/#fi|en|Teuvo  isn't as helpful as it might have been...
19:42:28 * applicative intones "TAY - oo - vuh"
19:42:51 <ivanm> dammit, what I need to do with my planar-graph library is clashing with the API I wanted for it :s
19:42:54 <mwc> applicative: well, it's Tuevo, not Teuvo, but it looks like it's similar
19:43:25 <kadoban> i have a function, f, that calls last, and i'm getting an empty list exception.  is there some easy way i can get what the arguments to f are when that happens?
19:43:30 * applicative tries http://translate.google.com/#fi|en|Tuevo with much better results
19:43:31 <mwc> Also, I found an article on Finnish phonology on Wikipedia (hurray, learned a new taxonomy) and apparently ue isn't a dipthong
19:43:49 <mwc> applicative: thanks for pointing htat out
19:43:57 <lars9> applicative: how to do that:  * applicative intones "TAY - oo - vuh"
19:44:21 <applicative> iv :: Int
19:45:07 <applicative> lars9, i begin \me  -- except because I confuse \ and /, monad and comonad, etc, results are mixed
19:45:32 <lars9> \me thanks to applicative 
19:45:37 * lars9 thanks to applicative 
19:45:53 <mwc> lars9: the to isn't needed there
19:45:54 <applicative> haha, sorry, i messed up with the instruction.  typical....
19:46:42 <lars9> > let 天 = "sky" in 天
19:47:05 <ivanm> lars9: that would require lambdabot to be here...
19:47:30 <lars9> ivanm: yea i notice that now...
19:47:45 <applicative> lars9 thinks lambabot is tired of ascii
19:48:13 <mwc> you know, I don't wnat to sound like an english supremacist here, but I hope that Unicode identifiers don't catch on
19:48:20 <ivanm> mwc: agreed
19:48:28 <eigen> anyone use xmonad?
19:48:32 <ivanm> since they're a PITA for anyone not from that region, etc.
19:48:36 <applicative> why not?  i don't use them
19:48:41 <mwc> the limitation to ascii means most code is written in english or the identifiers are at least intelligible between different speakers
19:48:43 <ivanm> eigen: yes; there's also #xmonad
19:49:09 <mwc> once idiographs and cyrillic starts taking over we'll see open source code get balkanized into asian and russian and other regional communities
19:49:11 <applicative> eigen, I AM AN XMONAD USER.  but a moron too, alas. 
19:49:28 <eigen> ?
19:49:42 <ivanm> anyone willing to discuss/be a sounding board on dealing with graphs?
19:49:50 <applicative> mwc, isn't that how it is with ruby? no one complains
19:50:25 <mwc> applicative: isn't that because the Japanese-using-Japanese and the rest of the world are basically disjoint communities?
19:51:46 <applicative> mwc, my impression was, yes. Not sure where I learned of it.  But I assume major developments go both ways.  
19:52:22 <mwc> If I see "katana" or "flugzeug" in code, I can at least mentally track it in short term memory
19:52:25 <applicative> mwc, we would have heard about monads for Haskell, even if they had come from Japanese Haskellers
19:52:36 * applicative loves german language haskell
19:52:49 <mwc> applicative: sure, but if the Xmonad source was in chinese ideographs, I'd be completely lost with it
19:52:58 <mwc> more so than if it were in french or german I think
19:53:16 <mwc> at least I can read and recognize words in those languages, even if I don't grok the meaning
19:53:31 * applicative would just think, how do they get away with using operators for everything, and I have to use camelCase like HLint says?
19:53:54 <ivanm> lol
19:54:12 <eigen> ivanm: what did you say you use as your haskell editor of choice?
19:54:19 <ivanm> emacs
19:54:31 <eigen> with what setup? scion?
19:54:33 <lars9> mwc: maybe you want some seperation between writing & speaking language, 100 years ago korean, japanese, vietnamese, chinese, all use chinese as writing language. they can "pen-talk" with each other without knowing each other's speaking language.
19:54:43 <applicative> eigen, editor wars are not the #haskell way.  ... except that they sort of are ...
19:54:56 <ivanm> just plain 'ol haskell-mode, along with the hlint emacs integration
19:55:12 <ivanm> applicative: lol
19:55:14 <mwc> actually, that's a good point, does "letter case" exist in Chinese? Would make data/type constructors vs. bindings interesting
19:55:47 <kadoban> since there's no letters, i doubt there's anything similar
19:55:50 <lars9> mwc: no, chinese has no letter.
19:55:54 <monochrom> letter case does not exist in Chinese
19:56:00 <mwc> hence the ""
19:56:24 <mwc> but there's no way to "capitalize" and ideograph?
19:56:53 <mwc> so you'd almost have to use a character set for which capitals exist for at least the initial letter of each data or type constructor
19:56:56 <monochrom> no distinction between capital and not-capital
19:57:05 <mwc> cyrillic or latin, maybe some others
19:59:05 <lars9> mwc: is latin still about "sound"?
19:59:09 <monochrom> isUpper and isLower both return False. however, using them for identifiers is allowed.
19:59:38 <kmc> > map generalCategory ['a', 'A', '⊕', 'ه', '하', '发']
19:59:40 <mwc> monochrom: my guess is that the lexer classifies based on isUpper . head
19:59:44 <kmc> lamdabot!
20:00:15 <mwc> lars9: by latin I meant the a-z alphabet or its variants used in most of western europe and the new world
20:00:42 <lars9> mwc: i see.
20:01:32 <mwc> lars9: Haskell's syntax cares about upper vs. lowercase letters in identifiers to differentiate data constructors from bindings and type constructors from type variables, so you'd need to respec that in whatever character set you write your code in
20:01:54 <lars9> mwc: a pure writing system should focus on shape and meaning/feeling/emotion i think, thats how they can break through oral barriers
20:02:04 <mwc> lars9: off the top of my head, only Latin and Cyrillic alphabets make that distinction
20:02:40 <mwc> lars9: well, my concern is more that we'd balkanize the community along linguistic groups and lose the global collaboration we enjoy now
20:02:45 <mauke> Λαμβδα
20:03:10 <ivanm> lars9: wtf? a writing system should focus on "emotion"? :/
20:03:18 <ivanm> mwc: definitely
20:03:42 <mwc> ivanm: it's not unheard of, it removes ambiguity. Lojban has something like that, but it's at the linguist rather than orthographic level
20:03:46 <lars9> mwc: indeed, english is the only language popular enough to support a global community
20:03:57 * applicative didn't know about Data.Char.generalCharacter;  map generalCategory "? ? ? ?" =[OtherSymbol,Space,OtherSymbol,Space,OtherSymbol,Space,OtherSymbol]
20:04:14 <applicative> "? ? ? ?"
20:06:14 * lars9 finished reading L4.verified, amazed by haskell
20:07:00 <ddarius> If only Charlemagne's empire had conquered China, then they too would have Carolingian miniscule.
20:07:50 <monochrom> Charlemagne couldn't even get past the Moors.
20:08:06 <ivanm> monochrom: which is why he should have set up a wormhole to get past them!
20:08:07 <ivanm> duh
20:08:28 <monochrom> you give him the wormhole needed
20:12:23 <eigen> what does .cabal contain?
20:12:46 <copumpkin> a specification of your package
20:12:52 <eigen> More specifically, what does .cabal/bin contain? All the tools which cabal installs?
20:12:55 <applicative> the directory?  it contains bin lib 
20:12:55 <ivanm> it contains the configuration for cabal-install as well as all the stuff you installed via cabal-install
20:13:01 <ivanm> eigen: yes
20:13:38 <flippo> (Charlemagne also never really learned how to read, so I doubt miniscule was high on his list of priorities.)
20:14:23 * applicative hadn't noticed the mysterious file "world" inside .cabal, right after "share"
20:14:31 <eigen> Okay. So I just installed xmonad via cabal install. If I type xmonad at the cmd prompt I get "xmonad is currtnly not installed. You can install it by typing: sudo apt-get install xmonad. I take this to mean two things: 1) .cabal/bin is not by default on my path 2) there exists more than one way to install xmonad. 
20:14:37 <ivanm> applicative: oh, I heard they were working on that
20:14:40 <ivanm> never knew it got implemented
20:14:48 <eigen> Should I set .cabal/bin on my path?
20:15:00 <applicative> eigen heck yes
20:15:18 <applicative> eigen paradise is only a few characters away
20:15:28 <eigen> Is using cabal generally the best way of installing haskell packages? Preferred over apt-get?
20:15:40 <ivanm> I don't think so
20:15:44 <ivanm> but most people disagree with me
20:15:57 <ivanm> http://ivanmiljenovic.wordpress.com/2010/03/15/repeat-after-me-cabal-is-not-a-package-manager/
20:16:53 <applicative> my impression was that haskellers inevitably cabal install; but if you are not a haskeller, but just using an executable like xmonad darcs pandoc, your package manager I guess
20:17:05 <eigen> Okay. So if I typed apt-get install xmonad right now. I'd actually have two installations of xmond installed. One in .cabal/bin and one elsewhere. That would be -- not nice.
20:17:44 <lars9> eigen: just a reminder, there is not "cabal uninstall" :)
20:18:03 <applicative> right, so you do rm /.cabal/bin/xmonad  for example.    
20:18:20 <applicative> er, ~/.cabal/bin/xmonad  for example.    
20:18:44 <ivanm> and "ghc-pkg unregister xmonad"
20:19:35 <eigen> But at the same time, if I intend to develop in haskell, there are probably packages (yes?) which are available via cabal which aren't available via apt-get, and keeping all of those related to haskell in one place would be nice, no?
20:19:42 * applicative is writing a blog post, "repeat-after-me-apt-get-is-not-a-cabal"
20:20:24 * applicative is writing a new post:  "pacman: a cabal install for C programs!!!"
20:20:46 <ivanm> eigen: the debian haskell people are working on tools to automagically generate apt packages from hackage
20:20:57 * ivanm sighs at applicative
20:21:28 <applicative> eigen, yes, but the torture of getting the right connections to C - libraries is much helped by the evil dwarves who do the C-cabals
20:23:04 * applicative is making a new website, "cackage" for C programs, and a special download system with subtle inference mechanisms.
20:23:39 <djahandarie> Were you by chance involved in naming Coq?
20:23:53 <ivanm> @slap applicative
20:24:12 * applicative reels, ...
20:25:23 * applicative is wondering, does ivanm's account entail that 'cabal install' is only for like Windows....?
20:26:17 <ivanm> applicative: well, my POV is that its mainly only useful for windows, machines you don't have root access to (and can't install system packages), etc.
20:26:27 <ivanm> oh, and for testing packages that you write
20:26:58 <ivanm> e.g. I use cabal-install on my uni box since I don't have root access to be able to install system packages (plus its ubuntu, which seems to have horrible haskell support)
20:27:23 <ivanm> I also use it at home since "cabal" is shorter than "runhaskell Setup.[l]hs"
20:27:29 <applicative> seems like a lot of human intellect has been devoted to a rather feeble end then.  
20:27:43 <dankna> it's a build system primarily
20:27:51 <dankna> installing is just one of the things it happens to be able to do
20:28:04 <dankna> that said I don't see why you say it's not useful for global installs
20:28:11 <dankna> can't always wait for Debian to package everything
20:28:13 <ivanm> applicative: heh
20:28:31 <ivanm> dankna: well, you can help out by _creating_ said packages then...
20:28:50 <dankna> or I can use cabal-install and be up and running today instead of next year, since I'd have to learn all the fiddly details of Debian packaging
20:29:15 <dankna> also I can run cabal-install on my Mac, too
20:29:20 <ivanm> see m3ga, etc.
20:29:32 <dankna> I don't want to.  I have better things to do with my life than learn that stuff.
20:29:33 <ivanm> they're working on a cabal-to-apt program
20:29:39 <ivanm> so you don't _have_ to learn it
20:29:42 <dankna> I wish them luck
20:29:59 * ivanm is quite happy to write ebuilds for haskell packages
20:30:01 <dankna> but if I make the package I also have to push it through the process
20:30:03 <applicative> cabal install is the same on all platforms.  its so wonderful, all you need is the ghc, which you should have anyway.
20:30:05 <m3ga> ivanm: see m3ga what?
20:30:19 <m3ga> oh, debian packaging?
20:30:20 <dankna> and take responsbility when it breaks
20:30:23 <ivanm> m3ga: trying to get you more helpers for debian packaging of haskell packages
20:30:25 <dankna> and I have no desire to do that
20:30:41 <ivanm> applicative: until you want to uninstall, upgrade, etc.
20:31:02 * applicative thinks: the true purpose of a package manager is to get GHC on the machine.
20:31:12 <applicative> what's the problem with ghc-pkg?
20:31:13 <dankna> eh.  I don't normally want to uninstall Haskell packages, because I rebuild ghc and wipe everything out every three months or so anyway.
20:31:20 <dankna> ghc-pkg is not a build or install system
20:31:30 <dankna> ghc-pkg is purely a mechanism for FINDING packages that have already been installed "somehow"
20:31:46 <applicative> no, it's part of cleanup.  ghc-pkg unregister
20:32:03 <ivanm> applicative: which doesn't actually remove the installed files...
20:32:05 <m3ga> dankna: every three months? i've got debian systems that have been running for years on debian testing. never once a complete wipe
20:32:21 <applicative> nobody is going to find them. 
20:32:23 <dankna> m3ga: wipe of Haskell stuff
20:32:28 <dankna> m3ga: not of the machine as a whole
20:32:45 <dankna> I tend to need things that rely on ghc head, somehow
20:32:51 <m3ga> still, sounds like more trouble than its worth
20:32:58 <dankna> well, it works for me
20:33:21 <m3ga> to each his own
20:33:31 * ivanm is planning on writing a exhere-generating program that would also periodically check for upgrades, etc. to packages
20:33:40 <ivanm> so hopefully it'd be almost automatic
20:34:02 * applicative suggests that he integrate cabal install into this exciting new system
20:34:43 <ivanm> applicative: kinda defeats the whole point, doesn't it?
20:35:07 <ivanm> I know that kolmodin shoved a copy of cabal-install inside hackport, but I think that was out of laziness...
20:35:18 <ivanm> (though having cabal-install exposing a library version would be cool)
20:36:22 <dankna> there IS a library version of cabal-install.  it is called cabal.  cabal-install is a thin wrapper layer on its functionality.
20:37:35 <ivanm> dankna: except that cabal itself doesn't have the downloading, the listing, the "what is installed but not the latest version", etc. functionality
20:37:48 <ivanm> cabal-install isn't _that_ thin a wrapper :p
20:37:52 <applicative> whatever else cabal may be, it isn't thin
20:38:00 <applicative> cabal install
20:38:13 <ivanm> it has 40 modules in it!
20:38:17 <dankna> hmm okay
20:38:35 * applicative studies the repo
20:38:44 <ivanm> Cabal itself manages the .cabal file format, building packages, registering with ghc-pkg, etc.
20:38:53 <ivanm> but it doesn't know anything about hackage
20:40:30 * applicative notices that this one is only four steps down the Hierarchy: module Distribution.Client.Init.Heuristics (guessPackageName, scanForModules, SourceFileEntry(..), neededBuildPrograms,guessAuthorNameMail, knownCategories) where ...
20:42:38 <monochrom> it can guess author name email too?
20:42:39 <applicative> ivanm, can i make of graph of the internal dependencies in the 'cabal-install' package?
20:42:55 * monochrom sends a patch that adds guessAuthorPassword :)
20:43:01 <ivanm> applicative: sure, SourceGraph can do that
20:43:03 <ivanm> monochrom: lol
20:43:25 <ddarius> Between split-objs and that, packages will never build.
20:43:36 <ivanm> applicative: there's also cabal-mod or something that does just that
20:43:46 <ivanm> ddarius: hmmm?
20:46:00 <maurer_> |(20:13:36) bob2: mdeboard: it depends in what way the result is formed from the input                                                                       |
20:46:05 <applicative> let darcsEmailEnv = maybe mempty nameAndMail (lookup "DARCS_EMAIL" env)
20:48:08 <leoncamel> hey. Did anyone compile ghc-6.12.3/ghc-7.0.1 for Mac in x64 arch?
20:48:54 <applicative> leoncamel,  the macports one is x64, is that ghc 6.10 still?
20:49:11 <lars9> can binary executable file generated by ghc --make run on machines without ghc? i can test this myself but i have to remove my ghc first...
20:49:33 <applicative> leoncamel, sure enough
20:49:46 <leoncamel> applicative: yes. in macports, only ghc-6.10
20:50:27 <leoncamel> applicative: I saw some message before, that crosscompiling on mac is buggy ? 
20:52:21 <ivanm> leoncamel: there's a haskell platform installer for 6.12.3 on OSX I think
20:52:27 <ivanm> (that is 64bit)
20:52:50 <applicative> no, its 32 bit.  the macports is older but 64 bit, this is our paradox
20:53:01 <applicative> at least, so it has been for a while
20:53:09 <Veinor> lars9: yep
20:53:52 <ion> I, being a Haskell newbie, finally got around to studying the State monad closely enough to intuitively grasp how it works. :-)
20:54:15 <ben> What is the difference between the lazy and the strict state monad, then?
20:54:17 <applicative> lars9, sure.  there can be delicacies.  for the Vulgar platforms there are various helps to bulletproof it, see e.g. cabal-macosx and similar packages
20:54:21 <leoncamel> ivanm: hmm, yes. the ghc-6.12.3 and ghc-7.0.1 of i386 arch works fine in my macbook. but, I want use a x64 one
20:54:34 <ivanm> I thought they were x64...
20:54:50 <leoncamel> ivanm: Oh .. I will check it now.. 
20:54:59 <ivanm> ion: hooray! have some cake (which you'll have to get yourself)!
20:57:50 <applicative> lars9, what operating system are you using?
20:59:01 <ab3> what is a decent json lib 
20:59:34 <ab3> the json package is verry bady documentated 
20:59:49 <leoncamel> ivanm: oh.. only i386 version ghc-6.12.3 in haskell-platform.
21:00:11 <ivanm> :(
21:00:23 <ivanm> ab3: I believe the one from galois (forget the name) is usually recommended
21:00:32 <leoncamel> It seems on mac, ghc only provide i386 version of ghc. both 6.12.3 and 7.0.1
21:03:03 <ion> ben: The strict one’s bind operator uses a pattern match to force the evaluation of the arguments, whereas the lazy one’s bind operator may pass thunks forward instead. Am i anywhere close to the truth?
21:03:34 <lars9> Veinor: thanks
21:03:38 <lars9> applicative: archlinux
21:03:56 <lars9> applicative: 64bit
21:04:09 <ben> ion: I do not actually know ;)
21:04:51 <applicative> ab3, doesn't the library developed in http://book.realworldhaskell.org/read/writing-a-library-working-with-json-data.html have a lot of documentation
21:05:23 <ivanm> applicative: yeah, that's the one now maintained by galois
21:05:52 <applicative> can ab3 use it, is it on hackage?
21:06:27 <ivanm> yes
21:06:41 <ab3> the json lib by galois doesn't have any doc, there is no omepage listed in the cabal file
21:07:18 <ab3> ow ok so the json package is the same as from real world haskell?
21:07:20 <ivanm> ab3: ummm.... not all packages have homepages
21:07:37 <ivanm> and the RWH one was based on an earlier version of that I believe
21:07:45 <applicative> i see http://hackage.haskell.org/package/json  but is it true the main ideas are in rwh.  that would be worth pointing out on the hackagepage
21:07:55 <ivanm> ab3: json seems to have _heaps_ of documentation
21:08:17 <lars9> is there a linear way to find k-th largest number in an array? the standard algorithm requires destructive update on original array
21:08:52 <ivanm> lars9: not that I know of off the top of my head; the usually approach has a log factor in there as well
21:08:57 <lars9> by the standard algorithm i mean the method similar to qsort
21:09:04 <ivanm> i.e. (!! k) . sort
21:09:13 <monochrom> http://hpaste.org/41790/controlmonadstatelazy demonstrate a use of Control.Monad.State.Lazy
21:10:49 <lars9> ivanm: can mutable array improve it?
21:11:00 <ivanm> no
21:11:21 <ivanm> since comparison-based sorting is n * log n at best
21:11:25 <monochrom> lazy evaluation > mutable array
21:11:53 <lars9> ivanm: the complexity on updating in mutable array is not constant?
21:12:05 <ivanm> lars9: nothing to do with the updates
21:12:07 <lars9> *of
21:12:09 <ivanm> it has to do with the actual sorting
21:12:26 <lars9> k-th largest, you dont need to do sorting
21:12:32 <ivanm> and I would probably get the list version anyway
21:12:36 <ivanm> lars9: how then?
21:12:39 <jmcarthur> i'm not sure there is a way to get the kth largest element of an array in linear time
21:12:52 <lars9> like in quick sort
21:12:57 <ivanm> IIRC (don't have it with me), Bird's new book has this as the second or third chapter
21:13:12 <ivanm> lars9: that's still sorting, and is O(n*log(n))
21:13:24 <jmcarthur> i think bird's new book has an algorithm to find the smallest number *not* in a list. i don't know about this algorithm
21:13:26 <ivanm> but I would do it as a list rather than an array
21:13:38 <applicative> ab3, if the RWH discussion is too remote from the current form, you might look for examples on http://bifunctor.homelinux.net/~roel/cgi-bin/hackage-scripts/revdeps/json-0.4.4#direct if this hasn't occurred. I am usually more helped by examples than documentation. 
21:13:45 <ivanm> jmcarthur: next chapter I think; something like this anyway (I remember the !!k)
21:13:49 <jmcarthur> ah okay
21:13:51 <ivanm> maybe I'm getting mixed up though
21:14:01 <jmcarthur> i dunno. i haven't even read through it
21:14:02 <lars9> ivanm: not, in quicksort, after a partition, you need to sort both sides, but now we only need to work on one side
21:14:04 <jmcarthur> or have a copy, even
21:14:14 <monochrom> due to a combination of laziness and some details of ghc's sort, (!! k) . sort may be as fast as any other algorithm.
21:14:23 <ivanm> lars9: *sigh* it's still n*log(n)
21:14:28 <monochrom> there was an old haskell-cafe thread on this
21:14:36 <jmcarthur> lars9: if you take a lazy list and do a mergesort or quicksort and then take the nth element then you get pretty good complexity
21:14:44 <ivanm> if you want the kth largest, then that might shrink to k*log(k) with the right sorting algorithm (can't recall)
21:15:13 <ivanm> but you still have that log factor in there
21:15:22 <ivanm> laziness means you just don't need to sort the entire thing
21:15:46 <lars9> ivanm: not really, in avg case, its n + n/2 + n/4 + ...
21:16:09 <ivanm> WHICH IS A LOG FACTOR!!!!!!!!!!!
21:16:10 <lars9> ivanm: im talking about k-th, not k largest
21:16:27 <ivanm> kth-_what_?
21:17:09 <jmcarthur> lars9: if you sort a list and then take the kth element, you can get it in (n + k log k), iirc
21:17:14 <ivanm> for Data.Map, is there a way of performing a map on the keys and the values in one pass?
21:17:16 <jmcarthur> lars9: because it's lazy
21:17:33 <lars9> in 1,4,2,3 the 2-th(0 based) largest is 3.
21:17:36 <ivanm> jmcarthur: right; that is still O(k * log k)
21:17:48 <ivanm> lars9: yes, so the kth-largest
21:17:49 <lars9> ivanm: and n + n/2 + n/4... = 2n
21:17:53 <ivanm> or whatever
21:18:03 <jmcarthur> ivanm: yeah i was just being more clear about how that can be
21:18:07 <ivanm> lars9: methinks you're doing your O(...) calculations wrong
21:18:15 * applicative is trying to think what insane claim about the type system would be powerful enough to break up an O(foo) fight
21:18:17 <JoeyA> If I'm not mistaken, lazy mergesort produces its first item in O(n * log n), but I may be wrong.
21:18:23 <ivanm> applicative: lol
21:18:31 <jmcarthur> JoeyA: no it produces the first in O(n)
21:18:32 <JoeyA> It first needs to split the list in half, which is O(n)
21:18:37 <ivanm> jmcarthur: yeah
21:18:50 <ivanm> that sounds about right
21:19:13 <JoeyA> Really?  I'm having trouble seeing why.
21:19:43 <lars9> ivanm: maybe you got a little bit stucked now, but sum[1,1/2,1/4,1/8...] = 2 ...
21:20:06 <lars9> *stuck
21:20:08 <ivanm> lars9: yeah, that's right; but your values are wrong
21:20:19 <ivanm> I mis-read what you wrote; that isn't the correct values for quicksort
21:20:20 <JoeyA> It first needs to split the list in half, which is O(n).  Then it needs to get (head . mergesort) of both the lower and upper lists, so it can see which one is smallest.
21:20:24 <ivanm> or merge-sort
21:20:50 <jmcarthur> JoeyA: i think it splits the list by evens and odds
21:20:57 <lars9> no, to find k-th largest, we only need to consider one side
21:20:59 <jmcarthur> JoeyA: so the split is lazy
21:21:27 <ivanm> lars9: only if you know where to split it...
21:21:36 <JoeyA> cool
21:21:50 <JoeyA> didn't think to do it that way.
21:22:54 <lars9> any pilot node
21:23:07 <lars9> a randomized one is ok
21:23:57 <lars9> http://en.wikipedia.org/wiki/Selection_algorithm   check this
21:24:03 <jmcarthur> lars9: the point is that you don't know which side of a pivot the kth smallest element is going to be in until you have already compared all the elements against the pivot. and that's only one step of the algorithm...
21:24:15 <ivanm> lars9: fine, you know better than us; so why the hell are you asking us?
21:25:40 <lars9> but that method requires destructive update to be efficient
21:27:36 <copumpkin> lars9: we do have destructive update
21:27:50 <copumpkin> implicitly
21:27:53 <copumpkin> in lazy evaluation ;)
21:28:00 <copumpkin> (as well as explicitly, but we try to avoid that)
21:28:22 <copumpkin> anyway, I'm pretty sure sort xs !! k is about that efficient, asymptotically
21:28:48 <lars9> copumpkin: what's implicit destructive update?
21:29:12 <copumpkin> call-by-need, write once :P
21:29:42 <leoncamel> Igloo: Hey. I check the track #4163. Are you working on cross-compiling of ghc now?
21:29:42 <jmcarthur> unobservable mutation!
21:31:01 <jmcarthur> i'm pretty sure that sort xs !! k is going to be a little slower than this in-place quicksort-based algorithm, actually... but not slower enough to realistically matter
21:31:07 <lars9> copumpkin: are you talking about this case: f x k = m !! k; m = fromList... ?
21:31:58 <jmcarthur> take k . sort   is about optimal on getting the k smallest elements, but i'm convinced that   (!! k) . sort   is not optimal
21:31:59 <kmc> lars9, when you do «let a = 2+2 in a*a», a typical Haskell implementation will create a structure in memory to represent "a = 2+2", which is destructively updated to "a = 4" once "a" is evaluated once
21:32:20 <kmc> that's how laziness is able to defer work without duplicating it
21:32:28 <ivanm> jmcarthur: why not?
21:32:35 <ivanm> how is !! worse than take?
21:32:39 <jmcarthur> ivanm: did you read the link that lars9 pasted here?
21:32:50 <ivanm> nope
21:32:59 <djahandarie> You can do a O(n) selection
21:33:19 <djahandarie> I think it should be possible to do a slight modification of merge sort to do it in Haskell fairly cleanly
21:33:20 <jmcarthur> ivanm: the algorithm in that article is able to throw out elements on either side of the kth element, not just the ones that are greater like in our version
21:33:40 <jmcarthur> djahandarie: the article says it requires mutation, but maybe you know something i don't?
21:34:15 <djahandarie> Hmm, maybe for the memory bounds. Not entirely sure at the moment
21:35:19 <jmcarthur> hmm... did i imagine reading that?
21:35:21 <jmcarthur> i can't find it now
21:35:27 <ion> The database-related chunk of my brain whispers: “need the nth largest item? add an index!”
21:36:23 <djahandarie> I think you would need mutation if you wanted to get O(1) space complexity
21:36:25 <jmcarthur> the article does rightly point out that a priority queue can do this more quickly, so if it was really that important for this operation to be fast then i would use that
21:36:32 <ion> But i’m sure you have deemed that to be a non-solution already.
21:37:11 <jmcarthur> or perhaps even just a simple tree
21:38:22 <kadoban> jmcarthur: err, isn't just building the heap/tree nlogn then? what is that faster than?
21:39:09 <jmcarthur> kadoban: i mean to have such a structure in the first place
21:39:12 <jmcarthur> instead of a list/array
21:39:18 <lars9> ivanm: hey please dont get mad, i should find a link before i explains, too hard to describe an algorithm with this awkward irssi readline :)
21:39:26 <lars9> *explained
21:39:29 <jmcarthur> kadoban: it's of a course a "when it's possible" kind of thing
21:39:47 <ivanm> what does irssi have to do with it?
21:39:49 <kadoban> jmcarthur: ah, okay, i get what you're saying
21:39:57 <djahandarie> Point is that this is just a variation on the sort where it doesn't sort parts of the array.
21:40:25 <jmcarthur> djahandarie: in a sense the algorithm described in that article is "more lazy" than our sort
21:40:26 <djahandarie> Modifying either non-in-place quicksort or merge sort should give you O(n) time complexity and O(n) aux space complexity
21:41:14 <jmcarthur> hmm... i wonder if completely lazy or optimal evaluation would give us something like this cheaply
21:41:28 <lars9> ivanm: it matters when combined with my limited skills in english :)
21:41:33 <djahandarie> Would be interesting to look into.
21:42:34 <lars9> jmcarthur: that would be a very cool example to show ppl how awesome laziness is
21:43:07 <jmcarthur> lars9: unfortunately it would require more laziness than all the haskell implementations i know of have to offer
21:43:22 <jmcarthur> lars9: i think that (take k . sort) is pretty compelling as it is though
21:43:46 <jmcarthur> lars9: that is, get the k smallest elements rather than the kth smallest element
21:43:52 <jmcarthur> good time on that one
21:44:26 <kadoban> yeah, that seems pretty good for k smallest...kth smallest seems harder to me. of course i'm really bad at haskell so far, so i dunno
21:44:32 <jmcarthur> and i'm pretty sure now that that is O(n + k log n)
21:44:40 <jmcarthur> yeah kth smallest does seem harder
21:44:49 <jmcarthur> but maybe with a more lazy evaluation order...
21:45:15 <lars9> maybe an algorithm opitimized for ordering operations in haskell could do that?
21:45:42 <jmcarthur> lars9: you mean a new evaluation order? that's what i'm talking about
21:47:44 <lars9> jmcarthur: i mean a new sorting algorithm with time complexity of nlogn, but also optimized for linear !!k
21:47:50 <lars9> jmcarthur: can laziness do that?
21:48:22 <copumpkin> lars9: have you tested that our current one doesn't do that?
21:48:53 <jmcarthur> lars9: it certainly depends on what kind of laziness you are talking about. ghc's laziness can be different from the laziness of another compiler/interpreter
21:49:08 <jmcarthur> lars9: my suggestion was that some kinds of laziness might be able to do it and others might not
21:49:35 <jmcarthur> lars9: perhaps requiring a different sort as well, but i don't know
21:50:19 <ManateeAuthor> I found WM openbox is awesome, also lightweight, perfect with Manate.
21:50:46 <kmc> i found wm awesome is openbox
21:51:08 <ManateeAuthor> Infact, i just want try LXDE, and found openbox can use standalone.
21:51:16 <ManateeAuthor> kmc: Sorry, i'm drinking..
21:51:16 <jmcarthur> it would take a lot to replace xmonad for me :)
21:51:44 <ManateeAuthor> xmonad is bad support floating window.
21:51:52 <jmcarthur> works fine for me
21:52:02 <ManateeAuthor> My head so hurt.
21:52:13 <jmcarthur> IMO, apps that only work when they float need to be rethought a little
21:52:26 <ManateeAuthor> Today is my brother's birthday.
21:53:18 <ManateeAuthor> jmcarthur: I think floating windows is good choose sometims.
21:53:34 <ManateeAuthor> Oh, my god, head is so heavy.
21:54:04 <ManateeAuthor> I drink 2L beer.
21:54:48 <lars9> ManateeAuthor: as far as i know, xmonad by default just ignores windows' focus hint/request. the only thing it auto focuses is new windows
21:54:51 <ManateeAuthor> I need sleep now, i will build VirtualBox image that just include OpenBox and Manatee.
21:55:06 <ion> If you’re drowning, you can try to hang on to a floating window, yes.
21:55:09 <ManateeAuthor> lars3: Yes, that rule break Manatee.
21:56:00 <ManateeAuthor> lars9: Manatee always focus on main window even popup new floating window, but XMOnad don't allow that, XMonad always focus new popup winodw.
21:56:11 <ManateeAuthor> largs9: Maybe change XMOnad config can fix that.
21:56:17 <jmcarthur> floating windows are a fine choice... for the user to make :)
21:56:43 <ManateeAuthor> jmcarthur: Look third screenshot of http://goo.gl/MkVw
21:57:04 <ManateeAuthor> jmcarthur: I popup floating window for display search result, but focus always at main window.
21:57:23 <ManateeAuthor> jmcarthur: This works fine on most WM that support floating winodw.
21:57:29 <jmcarthur> looks like it should be more of a menu sort of thing
21:57:31 <jmcarthur> not a popup
21:57:39 <jmcarthur> chrome manages to pull it off fine
21:57:44 <lars9> ManateeAuthor: maybe some config or plugin can fix it but i only use xmonad with its default setting.
21:57:58 <ManateeAuthor> I have test Gnome, KDE, XFCE, LXDE, works fine.
21:58:07 <ManateeAuthor> Sadly, XMOnad can't work.
21:58:42 <jmcarthur> xmonad is not making any assumptions it's not allowed to
21:58:53 <ManateeAuthor> lars9: IMO, XMOnad should support floating window with generic rule even floating windows is not XMOnad's style.
21:59:18 <jmcarthur> IMO apps just shouldn't use floating windows when they don't want them to be windows
22:00:32 <ManateeAuthor> jmcarthur: You mean use other way instead floating windows?
22:01:03 <jmcarthur> right
22:01:09 <ManateeAuthor> I wonder i can type correct spell even i drink so much.
22:01:20 <ManateeAuthor> jmcarthur: I need think a bout that.
22:01:29 <jmcarthur> it doesn't really make sense (to me) to use a window for something that isn't intended to be a moveable, resizeable part of the interface
22:01:36 <ManateeAuthor> jmcarthur: Thanks for your suggestions.
22:01:59 <jmcarthur> np
22:02:43 <jmcarthur> if lambdabot was here i would totally @remember ManateeAuthor I wonder i can type correct spell even i drink so much.
22:03:05 <lars9> jmcarthur: smplayer is the only window i move, all other windows in my xmonad are fixed, maximized :)
22:03:50 <jmcarthur> lars9: i have a special key binding for when i want to launch a program with a floating window instead of a tiled window :)
22:04:01 <ManateeAuthor> jmcarthur: In GTK+, only Dialog and Popup window support effect in my screenshot.
22:04:09 <ManateeAuthor> jmcarthur: But Dialog can't customize 
22:04:19 <ManateeAuthor> jmcarthur: So i use Floating window instead.
22:04:24 <jmcarthur> :(
22:04:27 <JPablo> hey....new guy question
22:04:35 <ManateeAuthor> I don't other widget can do that not use Floating window.
22:04:37 <jmcarthur> hey....old guy answer?
22:04:38 <JPablo> how do you use let in hugs?
22:04:47 <JPablo> keeps giving me syntax error
22:04:48 <ManateeAuthor> Ok, i need sleep now.
22:04:57 * jmcarthur has no idea
22:04:58 <ManateeAuthor> I hope i cna think clearer when i wake up.
22:05:03 <jmcarthur> most of us probably don't use hugs
22:05:03 <JPablo> damn
22:05:11 <JPablo> thought so
22:05:12 <ManateeAuthor> Sorry, guys drink so much, i can't think now.....
22:05:21 <jmcarthur> JPablo: in ghci you would just say "let foo = bar" and then hit enter
22:05:24 <ManateeAuthor> Bye.
22:05:25 <ManateeAuthor> :)
22:05:37 <JPablo> cool
22:05:46 <JPablo> too bad i'm stuck with hugs
22:05:47 <jmcarthur> JPablo: something that should work in both is "let foo = bar in baz"
22:05:55 <jmcarthur> it just isn't persistent that way, of course
22:06:15 <jmcarthur> stuck with hugs due to school stuff?
22:06:22 <JPablo> that's correct
22:06:25 <jmcarthur> yeah that sucks
22:07:37 <JPablo> but it's almost 2 years since my last encounter with functional programming, I was doing great progress in GHCi, but then i read: in Hugs
22:10:27 <copumpkin> TacticalGrace: you around?
22:10:39 <ivanm> preflex: seen TacticalGrace
22:10:39 <preflex>  TacticalGrace was last seen on #ghc 13 days, 6 hours, 26 minutes and 4 seconds ago, saying: ok
22:10:50 <ivanm> evidence suggests not...
22:22:22 <copumpkin> anyone know how repa's slices work?
22:24:14 <c_wraith> If I could remember what feature they are...
22:24:42 <copumpkin> you can take arbitrary slices of a multidimensional array
22:24:49 <copumpkin> but I'm not quite sure how you specify the slice
22:25:20 <kmc> does the repa paper know?
22:25:43 <copumpkin> oh good point
22:26:09 <jmcarthur> the repa paper isn't actually very helpful on that matter
22:26:16 <jmcarthur> let me see if i can recall how it works...
22:27:17 <c_wraith> don't you supply it a function from n indices to n-1 indices, or the like?
22:31:15 <jmcarthur> copumpkin: well, i couldn't find what i was looking for, but i did find this: http://hpaste.org/41791/some_repa_stuff
22:31:26 <jmcarthur> i did have some notes on repa somewhere though...
22:32:42 <jmcarthur> hah, yay for outdated comments
22:32:57 <jmcarthur> i say in a comment there that i don't know how to make an instance of Elt and then i do exactly that later in the file
22:34:07 <jmcarthur> copumpkin: okay i think i remember how slice works now
22:34:13 <jmcarthur> copumpkin: it's like a crontab :)
22:34:32 <jmcarthur> All = *
22:39:01 <copumpkin> jmcarthur: ah
22:40:21 <copumpkin> I got that, but how about smaller slices?
22:40:53 <jmcarthur> what do you mean?
22:41:36 <copumpkin> oh I see
22:41:41 <copumpkin> it doesn't let you select a subarray
22:41:45 <copumpkin> it's just for specifying things like replicate?
22:42:00 <copumpkin> oh I guess it does, but it's only entire axes at a time
22:42:16 <jmcarthur> it reduces dimensionality by slicing
22:42:22 <copumpkin> yeah
22:42:45 <copumpkin> but can I say, "take all of the first dimension, the range 2-5 on the second dimension, and ignore the third dimension"
22:43:00 <jmcarthur> you'll notice that hpaste link has a drop function. i thought i had a take function as well, but maybe there was some fundamental reason that i didn't...
22:43:24 <jmcarthur> what does "ignore the third dimension" mean? wildcard?
22:43:35 <copumpkin> oh I guess, yeah
22:44:34 <jmcarthur> so that would be "take all of the first dimension, the range 2-5 on the second dimension, and all the third dimension" then
22:44:41 <copumpkin> yeah
22:45:03 <jmcarthur> dang, where is my take function?
22:45:16 <jmcarthur> a composition of drop and take would do that
22:45:28 <copumpkin> oh yeah, I just mean as a specified slice
22:45:29 <augur> byorgey wheres my damn subtraction >O
22:45:42 <jmcarthur> copumpkin: i think it doesn't work like that
22:45:52 <copumpkin> I'm just trying to figure out semantically what a slice is
22:45:59 <jmcarthur> you'll notice i had to implement drop as a backpermute
22:46:13 <copumpkin> it's a specification of a subrectangle of the original rectangle
22:46:20 <jmcarthur> not really
22:46:25 <copumpkin> oh okay
22:46:31 <copumpkin> that's what I'd expect it to be
22:46:32 <jmcarthur> say it's a 2d array
22:47:39 <jmcarthur> for an mxn matrix, slice can give you (a) a scalar, (b) an m-vector, (c) an n-vector, or (d) the original mxn matrix
22:47:48 <copumpkin> oh
22:48:05 <copumpkin> so you can pick all or 1 element from each axis
22:48:07 <jmcarthur> if my memory serves me correctly
22:48:11 <jmcarthur> yeah
22:48:20 <jmcarthur> using All or an index, respectively
22:48:30 <jmcarthur> that's the sense that it's like a crontab
22:48:34 <copumpkin> I see
22:48:38 <copumpkin> ick :P
22:48:41 <jmcarthur> each dimension is just a constraint
22:48:49 <copumpkin> the whole shape stuff is rather messy in haskell, but without DTs you can't really do better
22:49:12 <jmcarthur> i got used to it, but then obviously forgot it once i stopped :\
22:49:19 <jmcarthur> i was enjoying it for a while there
22:49:29 <copumpkin> I like the general idea
22:49:39 <copumpkin> but I think the whole thing is a lot cleaner in agda
22:49:46 <jmcarthur> i'd hate to see what repa-static would look like
22:49:52 <copumpkin> without shapes being type and value-level and represending indices and shapes at once and so on
22:49:56 <copumpkin> representing
22:50:37 <copumpkin> reshape : ∀ {n} {sh sh' : Shape n} {A} → Array sh A → Array sh' A
22:51:00 <copumpkin> data Index : ∀ {n} → Shape n → Set where
22:51:08 <copumpkin> stuff like that
22:52:25 <copumpkin> but I do like the library a lot :P
22:52:34 <copumpkin> I just think it's a big argument for DTs
22:53:17 * jmcarthur shrugs
22:54:17 <jmcarthur> i've found that i don't mind singleton types so much anymore
22:55:02 <JPablo> factorial :: (Integral a) => a -> a
22:55:03 <JPablo> factorial x = x + factorial (x-1)
22:55:03 <JPablo> factorial 1 = 1
22:55:09 <JPablo> what am I screwing up?
22:55:18 <JPablo> it keeps saying stack overflow...
22:55:18 <copumpkin> JPablo: + instead of *
22:55:23 <JPablo> yup
22:55:25 <JPablo> not that
22:55:42 <mauke> JPablo: not using warnings
22:55:44 <eagle-runner> JPablo: pattern match 1 first
22:55:51 <JPablo> thanks
22:56:19 <JPablo> mauke: using hugs :S
22:56:31 <eagle-runner> fac x = foldl1 (*) [1..x]
22:56:40 <mauke> fac x = product [1..x]
22:57:25 <jmcarthur> fac = product . enumFromTo 1
23:01:40 <eagle-runner> fac = scanl1 (*) [1..] !!
23:01:56 <kolmodin> ivanm, dankna: cabal does not do everything that cabal-install does. cabal only handles one package, cabal-install has code for package index, dependency resolution, to talk to hackage, amongst other things. also, there is no library version of cabal-install, thus hackport has a copy of the code.
23:03:19 <byorgey> to make things more confusing, by cabal kolmodin really means Cabal, and the name of the executable installed provided by the cabal-install package is called cabal.
23:03:29 <ivanm> kolmodin: yeah, I know ;-)
23:03:31 <byorgey> s/installed//
23:04:13 <ivanm> byorgey: unless I specifyi "cabal install", "cabal configure", etc. when I refer to cabal I mean Cabal-the-library ;)
23:05:15 <byorgey> well, fine, but hitting the shift key to capitalize it correctly is not that hard, and things are already confusing enough =)
23:05:33 <Enigmatic> that's why i try to avoid using cabal-install :P
23:05:48 <ivanm> Enigmatic: to increase confusion? Ґп
23:05:53 <ivanm> *:p
23:05:56 <byorgey> Enigmatic: you try to avoid using the term, or the tool itself?
23:06:01 <ivanm> (accidentally switched keyboard layouts)
23:06:15 <byorgey> it's really quite a lovely tool. just confusingly named.
23:06:50 <augur> byorgey! :D
23:06:51 <Enigmatic> term and tool
23:07:04 <augur> also, to not-byorgey: whats rank-3 polymorphism
23:07:35 <Enigmatic> I have a tool that uses Cabal to parse .cabal files and then it translates them into a Waf compatible execution graph
23:07:45 <byorgey> wait, why can't I answer? ;)
23:07:50 <ivanm> byorgey: well, last I heard from dcoutts, cabal-2 will be the tool, with cabal-library or something
23:07:52 <Enigmatic> multithreaded, multiproject, multilanguage builds = win
23:08:01 <byorgey> ivanm: oh, nice
23:08:12 <augur> byorgey: well, you can, but ive been byorgey!-ing all day so.. :p
23:08:22 <byorgey> Enigmatic: oh, in that case, by all means.  sounds nice. =)
23:08:58 <ivanm> Enigmatic: ooohhh, cool; I've heard nice things about waf from a talk by Andrew Tridgell (specifically how they use it for Samba)
23:09:09 <byorgey> augur: rank-N polymorphism is when you have foralls to the left of (N-1) arrows
23:09:12 <ivanm> if it wasn't in Python I would consider looking at it more deeply :p
23:09:22 <augur> byorgey: example?
23:09:28 <augur> vs non-example?
23:09:34 <byorgey> augur: forall a. a -> b   is rank-1 polymorphic
23:09:57 <byorgey> (forall a. a -> Int) -> Char is rank-2 polymorphic
23:09:59 <Enigmatic> ivanm: eh it's just a build system. ghc uses GNU Make and nobody seems to mind that much ;)
23:10:15 <byorgey> since the forall a is on the LHS of the  ... -> Char arrow
23:10:19 <kolmodin> byorgey: eh.. that's right. I hope it's understandable anyway :) the name of the projects are Cabal and cabal-install, so I hope it's understandable when I say cabal and cabal-install
23:10:25 <ivanm> Enigmatic: yeah, but for my own packages it thus doesn't really provide anything extra over Cabal
23:10:26 <augur> aha ok
23:10:39 <augur> i see
23:11:43 <byorgey> kolmodin: it is to most people who have been around a while, I just want to make sure newbies don't get confused.  not that ivanm and dankna are.
23:11:59 <Enigmatic> ivanm: yah. i have particular needs that aren't met by cabal-install.
23:12:05 <byorgey> mostly I am just anal about proper capitalization =P
23:12:10 <ivanm> well, I keep telling people to say cabal-install when they mean the tool ;)
23:12:19 <ivanm> Enigmatic: what specifically, if I may ask?
23:12:27 <augur> byorgey: so wheres this blog post :x
23:12:47 <byorgey> augur: half of it is in a file on my computer
23:12:47 <kmc> <ivanm> if it wasn't in Python I would consider looking at it more deeply :p ← really?
23:12:51 <byorgey> augur: the other half is in my brain
23:12:53 <augur> aww
23:12:55 <augur> so slow :(
23:13:07 <ivanm> kmc: it sounds really cool
23:13:14 <ivanm> not that I would have much use for it... >_>
23:13:30 <kmc> i mean, why does it matter what language they used
23:13:36 <kmc> "i would use xmonad if only it weren't written in haskell"
23:13:47 <kmc> i've heard this, and i think it's dumb
23:13:59 <byorgey> augur: in between writing it I ate dinner, played super smash brothers Wii with my little brother, talked with my sister, and played bridge with my wife =P
23:14:02 <kmc> (though slightly more legit, as the xmonad config language has a certain resemblance to Haskell)
23:14:05 <arcatan> "i would play this Flash game if only it weren't made using Flash"
23:14:10 <kmc> hehe
23:14:13 <augur> byorgey: you have too much of a life
23:14:23 <byorgey> yeah, it's pretty terrible
23:14:53 <augur> actually i'll be entirely honest, i have no life and i hate having to engage in life-like things
23:15:00 <ivanm> kmc: it's a bit weird IMHO to use a build tool in Python for libraries/applications written for/in Haskell
23:15:02 <augur> except where scifi and certain video games are concerned.
23:15:15 <Enigmatic> ivanm: multilanguage support (haskell, llvm, c++, scala, java) and a single 'build' command that only uses checked in source code, and doesn't use ghc-pkg
23:15:19 <kmc> i don't see why ivanm
23:15:25 <kmc> there are specific disadvantages yes
23:15:29 <byorgey> augur: hehe, I see
23:15:31 <ivanm> kmc: and we already have Cabal
23:15:54 <augur> im thinking of writing a blogpost
23:16:02 <augur> "The Reader monad for Linguists"
23:16:04 <ivanm> and even plain 'ol ghc --make seems to do some of what waf's advantages over Make
23:16:10 <augur> or more, "~ for Semanticists"
23:19:30 <sinelaw> what are the cases where a variable is restricted to have the same type in two expressions?
23:19:40 <sinelaw> someone said something about lambda-bound variables
23:20:13 <byorgey> augur: sounds good
23:20:17 <byorgey> augur: what's stopping you?
23:20:36 <sinelaw> preflex, seen lambdabot
23:20:36 <preflex>  lambdabot was last seen on #xmonad 7 hours, 55 minutes and 13 seconds ago, saying: Consider it noted.
23:21:12 <byorgey> sinelaw: perhaps you are thinking of let-bound variables in GHC 7 ?
23:21:19 <sinelaw> byorgey, yes
23:21:25 <sinelaw> but in ghc 6
23:21:35 <augur> byorgey: reading academic papers and working on syntax
23:21:42 <byorgey> sinelaw: in GHC 7, variables bound with a let will be given *monomorphic* types, unless you specifically give a polymorphic type signature
23:22:01 <sinelaw> byorgey, yeah, i want to achieve the same effect in ghc 6
23:22:41 <arcatan> what are let-bound variables in GHC 7?
23:22:54 <byorgey> sinelaw: well, you can always give an explicit monomorphic type signature?
23:23:04 <sinelaw> byorgey, i want type inference
23:24:08 <kmc> sinelaw, -XMonoLocalBinds
23:24:16 <kmc> this is not the default in GHC7
23:24:25 <kmc> (that would break H98 / H2010 compatibility)
23:24:32 <jmcarthur> it's enabled with GADTs or TypeFamilies i think
23:24:34 <sinelaw> byorgey, actually i don't care specifically for variables. the problem is this: i have an embedded language in which one of the data constructors denotes variables in the embedded lang.  
23:24:37 <jmcarthur> in ghc7
23:24:38 <kmc> what is new in GHC7 is that TypeFamilies and GADTs imply MonoLocalBinds
23:24:39 <kmc> yes
23:24:52 <jmcarthur> sinelaw is actually using GADTs in this case thoug
23:24:55 <jmcarthur> *though
23:25:09 <sinelaw> i want to take two expressions from my lang and unify the types of variable-values within without implementing type inference myself
23:25:09 <jmcarthur> but apparently not ghc 7
23:25:17 <sinelaw> no, not ghc 7
23:25:30 <jmcarthur> you could just not use let if you can help it
23:25:32 <sinelaw> the real problem isn't directly related to haskell variables
23:25:34 <kmc> sameType :: a -> a -> (); sameType _ _ = ()
23:25:41 <jmcarthur> asTypeOf
23:25:43 <sinelaw> kmc, i thought of that
23:25:44 <kmc> right
23:25:44 <sinelaw> but
23:25:52 <kmc> :t asTypeOf
23:25:57 <kmc> gr
23:26:04 <jmcarthur> asTypeOf :: a -> a -> a
23:26:14 <jmcarthur> asTypeOf = const -- iirc
23:26:22 <ski> @src asTypeOf
23:26:25 <jmcarthur> no LB
23:26:30 <byorgey> yes, it's a type-restricted version of const
23:26:30 <ski> ah
23:26:32 <ski> augur : an example of rank-3 polymorphism is `callCC'
23:26:34 <sinelaw> the thing is i actually need to traverse two ASTs and force the same types only on language variable values that have the same name
23:26:40 <augur> ski: i hate you
23:26:46 <ski> why ?
23:27:07 <augur> DONT GET YOUR CONTINUATIONS IN MY POLYMORPHIC TYPES >|
23:27:19 <ski> don't you like continuations in natural language ?
23:27:39 <augur> sort of.
23:28:15 <sinelaw> hmm, come to think of it
23:28:27 <sinelaw> this is exactly the problem that GHC needs to solve when doing haskell's typing
23:28:35 <sinelaw> so I wonder how it's done
23:28:52 <sinelaw> does anybody know?
23:29:04 <copumpkin> unification?
23:29:10 <sinelaw> copumpkin, no
23:29:18 <ski> hm .. i suppose if you have `((forall a. F a) -> T) -> U', you can probably get `forall a. (F a -> T) -> U' out of that ..
23:29:29 <sinelaw> i mean does ghc have different types for different syntax expressions? i'm guessing no
23:29:30 <ski> sinelaw : which problem ?
23:29:50 <sinelaw> probably all expressions are represented by a single type
23:30:21 <ski> all expressions, or all (or most) syntactic categories ?
23:30:24 <sinelaw> ghc does typing in runtime, i'm want to do it in compile type
23:30:51 <sinelaw> it's a different problem...
23:31:12 <sinelaw> ski, dunno, but now it doesn't seem to be the same problem anymore :)
23:31:24 * ski still isn't sure what the problem is/was ..
23:32:00 <sinelaw> ski: the original problem is how to unify embedded language variables' types when compiling an AST
23:32:24 <ski> example ?
23:32:42 <sinelaw> if I know the vars should be the same type, I can use asTypeOf. but I can only know that if they have the same name
23:32:44 <jmcarthur> so you need a type unification algorithm
23:32:45 <kmc> wouldn't they get unified when you use them?
23:33:00 <jmcarthur> if you need unification at runtime, that is
23:33:05 <sinelaw> i don't
23:33:05 <kmc> data Exp a where { Var :: Exp a; Equals :: Exp a -> Exp a -> Exp Bool }
23:33:09 <sinelaw> i don't think i do
23:33:14 <kmc> now if we say (Equals Var Var), the two Vars get unified
23:33:21 <jmcarthur> "the thing is i actually need to traverse two ASTs and force the same types only on language variable values that have the same name"
23:33:29 <jmcarthur> having the same name sounds like a runtime check to me
23:33:29 <sinelaw> hmm
23:33:31 <sinelaw> maybe I do
23:33:34 <sinelaw> :)
23:33:49 <sinelaw> jmcarthur, but i was thinking about ASTs that are built only in compile time
23:33:54 <sinelaw> literals
23:34:04 <sinelaw> if that's what I should call them
23:34:12 <jmcarthur> but they still are compared based on value, aren't they?
23:34:21 <ski> i'm not sure if this is what you want .. but something like lambdaProlog's "local constructors" would be quite useful to model object language variables, i think (it's, kindof, a HOAS representation)
23:34:26 <sinelaw> yes, but compile-time value
23:34:34 <jmcarthur> template haskell then?
23:34:51 <sinelaw> i've never used it, don't know much about what it can do and how
23:34:58 <jmcarthur> it's just a macro system
23:35:05 <jmcarthur> but it has access to compile time values
23:35:24 <jmcarthur> i don't know how i would use it to do this though
23:35:55 <sinelaw> jmcarthur, maybe I could generate asTypeOf calls using TH after figuring that two variables have same name?
23:36:04 <sinelaw> sounds complicated, anyhow
23:36:05 <jmcarthur> i think your hopes to use haskell's type inference while depending on value equality are doomed to disappointment
23:36:10 <jmcarthur> that wouldn't work at all
23:36:16 <jmcarthur> asTypeOf is compile-time only
23:36:24 <sinelaw> that's why I mentioned TH
23:36:35 <jmcarthur> i don't think that's quite the right idea
23:36:40 <sinelaw> neither do I :)
23:36:41 <jmcarthur> TH is *just* a macro system
23:36:44 <sinelaw> yeah
23:36:46 <ski> (`asTypeOf' is just a constraint, just like a type ascription)
23:37:00 <sinelaw> i'm stuck
23:37:06 <jmcarthur> maybe you need a dependently typed language
23:37:13 <sinelaw> or
23:37:13 * ski would still like to see some actual code ..
23:37:16 <kmc> sounds like you want a non-embedded domain specific language
23:37:16 <jmcarthur> types can depend on values then
23:37:19 <sinelaw> ski, sec
23:37:39 <jmcarthur> well, a deeply embedded language would work too
23:37:52 <jmcarthur> it's just that there has to be a coded-in type checking step
23:39:18 <sinelaw> you mean implementing type inference 
23:39:20 <sinelaw> ?
23:39:27 <jmcarthur> yeah
23:39:31 <jmcarthur> i admit that would suck
23:39:37 <jmcarthur> type inference is not an easy algorithm
23:39:43 <jmcarthur> as i understand it, at least
23:40:24 <jmcarthur> personally, i think your requirements are kind of unnecessary, but i don't know the use case either
23:40:56 <jmcarthur> all i know is that you want to generate some C# or Java from an imperative DSL and for some reason you don't want to use haskell type annotations
23:41:33 <copumpkin> jmcarthur: 
23:41:33 <copumpkin> data Selector : ∀ {n m} → Shape n → Shape m → Set where
23:41:34 <copumpkin>   Z   : Selector Z Z
23:41:34 <copumpkin>   _∷_ : ∀ {p q m n} {sh : Shape p} {sh' : Shape q} → Selector sh sh' → Vec (Fin n) m → Selector (sh ∷ n) (sh' ∷ m)
23:41:38 <copumpkin> generalized slice? :P
23:41:53 <copumpkin> except it can't specify an arbitrary replicate
23:42:17 <jmcarthur> okay i need a minute to absorb this crap :)
23:42:33 <sinelaw> ski, http://hpaste.org/paste/41749/compile_time_type_inference_fo#p41792
23:43:24 <copumpkin> jmcarthur: not even sure it makes sense, but I think it does
23:43:26 <sinelaw> ski, with ghc 7 i could force the type of 'v' to be determined from its use in 'a' and 'b'
23:43:42 <jmcarthur> copumpkin: okay so it basically allows you to give vectors of indices instead of just single indices?
23:43:53 <copumpkin> yeah, and preserves the shape
23:44:28 <sinelaw> uh wait
23:44:30 <sinelaw> mistake
23:44:47 <jmcarthur> preserves the shape in what way?
23:45:04 <copumpkin> jmcarthur: just in the index, it maintains the resulting shape
23:45:27 <copumpkin> in some way Selector x y is a recipe for translating between Array x a and Array y a
23:45:35 <jmcarthur> why both m and n then?
23:46:15 <sinelaw> ski, http://hpaste.org/paste/41749/compile_time_type_inference_fo#p41793
23:46:19 <copumpkin> n is the size of the current dimension in the source array, and m is the size of the corresponding dimension in the result array
23:46:26 <jmcarthur> oh!
23:46:31 <jmcarthur> this is repa-static
23:46:32 <copumpkin> so you could select the same row multiple times
23:46:34 <copumpkin> yeah
23:46:41 <jmcarthur> okay that just wasn't clicking
23:46:47 <copumpkin> sorry :)
23:46:58 <copumpkin> select : ∀ {n m} {sh : Shape n} {sh' : Shape m} {A} → Array sh A → Selector sh sh' → Array sh' A
23:47:21 <jmcarthur> well i should have at least inferred n:Nat due to Fin
23:47:27 <jmcarthur> i had forgotten your earlier definition of Shape
23:47:31 <sinelaw> ski, in ghc 6.12  v has polymorphic type although i've used it in an expression 'b' where its type must be Variable Integer
23:47:57 <sinelaw> so a's type is also not determined, although it involves using 'v'
23:48:15 <jmcarthur> sinelaw: must you use let?
23:48:23 <sinelaw> jmcarthur, no
23:48:32 <sinelaw> i'm looking for a way to force it to have the same type everywhere, OR any equivalent way of forcing a Variable value to have the same type in several places
23:48:54 <jmcarthur> for that matter, does ghc 6 not support -XMonoLocalBinds? i don't have a clue, but if it does then this is a non-issue
23:49:14 <sinelaw> jmcarthur, you also mentioned something about using lambda-bound variables yesterday, didn't you?
23:49:33 <jmcarthur> wasn't me, but it sounds like somebody tried to explain HOAS to you
23:49:36 <jyper> I'm having some trouble with arrays,(cellstatelist is [[CesllState]], [((x,y),((cellStateList!!y)!!x))|  x <- [0 .. maxlen-1], y <-[0..numlines-1], x < (length (cellStateList!!y))] gives me a full list with no exceptions  but  IArray.array ((0,0),(1000,1000)) [((x,y),((cellStateList!!y)!!x))|  x <- [0 .. maxlen-1], y <-[0..numlines-1], x < (length (cellStateList!!y))]::Array (Int,Int) CellState
23:49:51 <jyper> give me "*** Exception: (Array.!): undefined array element"
23:50:04 <sinelaw> jmcarthur, what's HOAS?
23:50:21 <sinelaw> and I think ghc6 does have MonoLocalBinds
23:50:41 <sinelaw> yip, it does
23:50:53 <jmcarthur> higher order abstract syntax. usually people do something like data Exp a where Lam :: (Exp a -> Exp b) -> Exp (a -> b) ; App :: Exp (a -> b) -> Exp a -> Exp b
23:51:21 <jmcarthur> allows you to bind variables in haskell syntax rather than having to worry about it yourself
23:51:42 <sinelaw> how?
23:51:44 <jmcarthur> really saves a lot of trouble concerning beta reduction and alpha equivalence and all that silliness
23:52:17 <jmcarthur> sinelaw: e.g.    Lam (\myVar -> stuffGoesHere) `App` stuffBoundToMyVar
23:52:27 <jmcarthur> sinelaw: stuffGoesHere can then just use myVar as a haskell variable :)
23:52:40 <sinelaw> ooh
23:52:52 <jmcarthur> sinelaw: the difficulty comes in when you need to inspect the things inside the Lam constructor
23:53:06 <jmcarthur> sinelaw: since it's just a function there isn't much you can do with it, so you have to be... creative
23:53:20 <sinelaw> I see
23:53:48 <jmcarthur> sinelaw: the Finally Tagless, Partially Evaluated paper covers doing some fancy things with HOAS syntax
23:54:11 <jmcarthur> HOAS is a much older idea though
23:54:16 <sinelaw> it's on my reading list already
23:55:03 <sinelaw> and what exactly does MonoLocalBinds do?
23:55:17 <jmcarthur> sinelaw: it makes let not polymorphic
23:55:25 <jmcarthur> and where, i assume
23:55:36 <copumpkin> *it doesn't infer the most general type
23:55:47 <sinelaw> copumpkin, really? why
23:55:55 <sinelaw> oh
23:55:55 <copumpkin> because it's hard when GADTs are around
23:55:56 <jmcarthur> sinelaw: that's exactly what you were wanting
23:56:07 <copumpkin> sinelaw: if you do want the most general type, just add a type signature for it
23:56:32 <sinelaw> copumpkin, do you mean it DOESNT pick the most general monomorphic type ?
23:56:43 <jmcarthur> err
23:56:48 <sinelaw> or that it doesn't pick the most general polymorphic type
23:56:54 <sinelaw> which is what i want
23:57:00 <jmcarthur> MonoLocalBinds causes that behavior, yes
23:57:05 <jmcarthur> such that it doesn't generalize
23:57:07 <copumpkin> what would more general monomorphic type mean?
23:57:35 <copumpkin> I can think of an interpretation with subtyping, I guess
23:57:51 <jmcarthur> hmm
23:57:59 <jmcarthur> but is subtyping not a form of polymorphism?
23:58:28 <copumpkin> hm, not in the parametric sense
23:58:41 <jmcarthur> more general parametric monomorphic type
23:58:45 <sinelaw> copumpkin, what i mean is that if two uses of the variable + monorphic typing mean that the variable is limited to some less-general type, than it would be otherwise, but still ghc would pick the most general type that satisfies the monomorphism
23:58:50 <jmcarthur> *parametrically
23:59:11 <jmcarthur> err
23:59:20 <sinelaw> or are you saying that ghc somehow misses out and doesn't pick the most general type that satisfies monorphism
23:59:25 <sinelaw> *monomorphism
23:59:31 <copumpkin> I wouldn't use the word monomorphism there
23:59:33 <sinelaw> (or whatever word i should put there)
23:59:34 <copumpkin> but I'm not sure actually
23:59:41 <jmcarthur> sinelaw: i think that if you use a let bound variable as two different types then you will get an error if you are using MonoLocalBinds
23:59:46 <copumpkin> I'd hope it would pick the combination that fits
