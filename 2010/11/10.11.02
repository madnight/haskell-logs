00:07:07 <Eduard_Munteanu> o.
00:12:38 <lars9> how to build ByteString from String ?
00:13:01 <Ke> pack
00:13:47 <Ke> @hoogle String -> ByteString
00:13:47 <lambdabot> Data.ByteString.Char8 pack :: String -> ByteString
00:13:47 <lambdabot> Data.ByteString.Lazy.Char8 pack :: [Char] -> ByteString
00:13:47 <lambdabot> Prelude read :: Read a => String -> a
00:14:11 <lars9> wow hoogle can do this....
00:14:19 <Ke> yup
00:14:29 <lars9> awesome
00:15:23 <lars9> what if i need to support utf8?
00:17:32 <dancor> lars9: Codec.Binary.UTF8.String
00:17:34 <pelotom> @hoogle UTF8
00:17:34 <lambdabot> No results found
00:18:06 <dancor> there is Data.ByteString.UTF8 as well
00:18:22 <dancor> that builds-in the utf8 conversion
00:19:04 <lars9> i see, thanks
00:21:34 * hackagebot http-enumerator 0.2.0.3 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.2.0.3 (MichaelSnoyman)
00:22:44 <lars9> I imported two packages, ByteString and ByteString.Char8, both provide pack, how to hide ByteString.pack ?
00:23:00 <mauke> don't import ByteString
00:23:36 <Saizan> in case you really need it, import Data.Bytestring hiding (pack)
00:23:54 <lars9> oh, what's the relationship between them?
00:24:02 <pelotom> lars9: if you're in ghci, ':module -Data.ByteString' will remove it
00:24:07 <lars9> ByteString and ByteString.Char8?
00:24:27 <Saizan> the latter just adds more functions
00:24:51 <Saizan> they work on the same ByteString type
00:26:05 <lars9> i see
00:26:08 <tianyi> Newbie question: why can't I evaluate assighment like a = [1,2,3] in ghci? Thanks.
00:26:26 <mauke> because there is no assignment in haskell
00:26:46 <mauke> and ghci is like a do-block, so you can't add equations
00:26:52 <mauke> 'let a = [1,2,3]' works, though
00:27:09 <tianyi> Oh I see, thanks a lot.
00:27:40 <adu> why does this not work? http://hpaste.org/41047/data_family_int
00:28:49 <lars9> can emacs-haskell mode do auto completion like ghci does?
00:29:24 <Saizan> adu: because numeric literals don't denote any type (currently)
00:30:05 <adu> Saizan: oh, i thought there was an -X flag for that
00:30:14 <Saizan> also, data families need a constructor, they are like data, not type
00:30:34 <Saizan> adu: i think that's not implemented yet, but icbw
00:47:05 <FunctorSalad> what's the etymology of the lambda in lambda calculus again?
00:47:29 <adu> Greek
00:47:58 <FunctorSalad> :p I mean why he chose this letter
00:48:54 <adu> maybe cuz it's cooÎ»
00:48:59 <Eduard_Munteanu> :)
00:49:05 <Saizan> iirc, he actually used ^ above the variable name, but some typography issues morphed it into a lambda
00:49:44 <tolkad> why isn't the state monad implemented as Â«Â type StateT s m = WriterT (ReaderT m s) s Â»?
00:50:40 <Eduard_Munteanu> Hm, interesting, never thought about that.
00:51:28 <FunctorSalad> Saizan: hehe
00:55:45 <tolkad> I'm curious if there is some disadvantage to that?
00:57:09 <c_wraith> efficiency?
00:57:28 <Saizan> the Monad instance wouldn't match State's semantics
00:57:29 <c_wraith> adding a spurious Monoid requirement
00:57:43 <Saizan> not just that
00:57:52 <c_wraith> oh, it wouldn't be spurious.
00:57:54 <tolkad> Saizan: it wouldn't?
00:58:03 <tolkad> Saizan: what would be different?
00:58:03 <c_wraith> the monoid requirement would be real
00:58:05 <Saizan> it would be doing something completely different
00:58:28 <tolkad> the writer monad lets you write stuff
00:58:33 <tolkad> the reader monad lets you read stuff
00:58:41 <tolkad> the combination of those two is what monad state does
00:58:50 <tolkad> it lets you write stuff and then read what you wrote
00:58:50 <c_wraith> in a broad picture, sure
00:58:50 <arcatan> the coder monad lets you code stuff
00:58:56 <c_wraith> but the details are very different
00:59:15 <Saizan> tolkad: if you remove the newtypes you'd get "return x = \s -> (mempty,x)" while for state you need "return x = \s -> (s,x)"
00:59:30 <c_wraith> tolkad, think about the monoid requirement for writer.  think about how writer actually works.
00:59:31 <Saizan> and similarly different for (>>=)
01:00:03 <tolkad> c_wraith: oh didn't see the monoid requirement
01:00:13 <tolkad> so we would need a new monad
01:00:14 <FunctorSalad> @unmtl WriterT (ReaderT m s) s a
01:00:14 <lambdabot> s (a, ReaderT m s)
01:00:19 <tolkad> MonadPut or something
01:00:37 <c_wraith> we have that.  It's half of MonadState
01:00:41 <Saizan> @untml WriterT s (ReaderT m s) a
01:00:41 <lambdabot> Maybe you meant: unmtl unpl
01:00:46 <Saizan> @unmtl WriterT s (ReaderT m s) a
01:00:46 <lambdabot> m -> s (a, s)
01:00:46 <FunctorSalad> @unmtl WriterT s (ReaderT s m) a
01:00:47 <lambdabot> s -> m (a, s)
01:01:00 <FunctorSalad> :D
01:01:09 <tolkad> c_wraith: but if we split it up, then I could easily lift read operations
01:01:17 <tolkad> or reverse-lift write operations
01:01:32 <tolkad> :t unlift
01:01:32 <lambdabot> Not in scope: `unlift'
01:01:38 <tolkad> :t lower
01:01:39 <lambdabot> Not in scope: `lower'
01:01:50 <tolkad> what's reverse lift anyway...
01:02:56 <nimiezko> Hello #haskell
01:03:04 <Saizan> hi
01:03:31 <c_wraith> tolkad, I don't see how you can meaningfully reverse MonadTrans's lift function.
01:04:08 <nimiezko> There is something I don't get with tail call optimisation and patter matching
01:04:40 <nimiezko> why does http://hpaste.org/41048/seems_tail_recursive and http://hpaste.org/41049/seems_not_tail_call_optimised behave differently ?
01:04:51 <nimiezko> (or at least seems so to me)
01:05:44 <nimiezko> (I am using ghc if that matters)
01:05:50 <c_wraith> there are no tail tails in there
01:05:55 <c_wraith> in fact, there's no recursion in there at all
01:06:54 <nimiezko> It is in the "foldl" call. I tried with my own recursive function and I have the same results
01:07:21 <nimiezko> When I use pattern matching in a callee, I have "stack overflow"
01:09:03 <c_wraith> ah.  there is a fundamental difference between "if" and pattern-matching
01:09:25 <c_wraith> at least, the way you have those functions written
01:10:46 <tolkad> c_wraith: the == instance can't be lazy...
01:10:51 <tolkad> c_wraith: neither can the if statement
01:10:56 <tolkad> c_wraith: what's the difference?
01:11:03 <tolkad> oh
01:11:16 <tolkad> the evaluation of the whole thing is
01:11:47 <c_wraith> actually, I think this is a case of the optimizer seeing the "if" is fully redundant in the first case, but not seeing the pattern matches are
01:12:36 <nimiezko> You say that if I have a non-redundant "if" I will have the same problem
01:12:44 <c_wraith> yeah
01:13:00 <c_wraith> it's only succeeding because the strictness analyzer sees that it's strict
01:13:06 <c_wraith> the problem has nothing to do with tail calls
01:13:14 <c_wraith> those are optimized out either way
01:13:41 <c_wraith> It's whether the result of the function is evaluated before moving on to the next step or not.
01:13:51 * hackagebot asn1-data 0.2.1 - ASN1 data reader and writer in RAW, BER, DER and CER forms  http://hackage.haskell.org/package/asn1-data-0.2.1 (VincentHanquez)
01:13:52 <Saizan> nimiezko: btw you should use foldl', foldl is almost never what you want
01:14:10 <c_wraith> yes, foldl' will fix the problem, either way.  at least, as long as your accumulator is strict
01:14:16 <c_wraith> which it is in your case
01:14:37 <tolkad> don't worry about foldl'/foldl, the compiler should be able to optimize anything you throw at it
01:14:50 <c_wraith> tolkad, that's exceptionally false
01:15:14 <Eduard_Munteanu> foldl bites too many times, I wonder whether something should be done about it.
01:16:02 <tolkad> > foldl (+) [1..10000]
01:16:02 <lambdabot>   Overlapping instances for GHC.Show.Show ([[t]] -> [t])
01:16:03 <lambdabot>    arising from a us...
01:16:15 <Saizan> tolkad: that's often not the case, like in the code pasted
01:16:18 <Eduard_Munteanu> > foldl (+) 0 [1..10000]
01:16:19 <lambdabot>   50005000
01:16:24 <tolkad> whoops
01:16:27 <nimiezko> my problem here is not with foldl but with a homemade recursive call
01:16:28 <tolkad> > foldl (+) 0 [1..10000]
01:16:29 <lambdabot>   50005000
01:16:30 <Saizan> > foldl (+) 0 [1..10000000]
01:16:39 <lambdabot>   mueval: ExitFailure 1
01:16:46 <Saizan> nimiezko: then you need to make sure you're strict in your accumulator
01:16:48 <tolkad> > foldl' (+) 0 [1..10000000]
01:16:55 <lambdabot>   mueval-core: Time limit exceeded
01:17:11 <Saizan> nimiezko: and make sure you compile with -O2
01:17:12 <tolkad> @src sum
01:17:13 <lambdabot> sum = foldl (+) 0
01:17:15 <Eduard_Munteanu> So it didn't blow up the stack, but it did finish?
01:17:24 <tolkad> what about sum?
01:17:26 <Saizan> Eduard_Munteanu: *didn't finish
01:17:31 <tolkad> @src sum'
01:17:31 <lambdabot> Source not found. That's something I cannot allow to happen.
01:17:39 <Eduard_Munteanu> Saizan: oh, right, thanks for the s//
01:17:46 <tolkad> sum seems to use foldl without the '
01:17:56 <tolkad> I thought you almost never wanted to use foldl?
01:18:05 <Saizan> that definition of sum is wrong
01:18:13 <Eduard_Munteanu> Mmm, isn't foldr tail-recursive?
01:18:13 <c_wraith> tolkad: and in my benchmarking, sum is slower than "foldl' (+) 0"
01:18:26 <c_wraith> no, foldr is definitely *not* tail-recursive
01:18:35 <Saizan> the haskell report doesn't define a foldl', so sum is not defined with it
01:18:50 <xarch> > foo p d g f a = if p a then d else let (a', b) = g a in f a' (foo p d g f b) 
01:18:51 <Eduard_Munteanu> Well I imagine at least one fold should be tail-recursive.
01:18:52 <lambdabot>   <no location info>: parse error on input `='
01:19:04 <Saizan> though there are rewrite rules for Int and Integer to turn it into a strict loop
01:19:06 <c_wraith> > foldr f 0 [1..5] :: Expr
01:19:07 <tolkad> Saizan: ghc should just optimize foldl to foldl' when necessary
01:19:08 <lambdabot>   f 1 (f 2 (f 3 (f 4 (f 5 0))))
01:19:19 <c_wraith> that is not tail recursive.  Just can't be. :)
01:19:31 <c_wraith> tolkad: strictness analysis is not as easy as you pretend
01:19:53 <tolkad> > (+) :: Expr
01:19:54 <xarch> >  cons x c n = c x n
01:19:54 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
01:19:54 <lambdabot>         against inferred ...
01:19:55 <lambdabot>   <no location info>: parse error on input `='
01:20:01 <Saizan> tolkad: ghc does a lot of optimizations that exploit strictness, but it doesn't cover all cases
01:20:25 <xarch> > let cons x c n = c x n
01:20:27 <Eduard_Munteanu> Ah, it makes sense after all, but why not use an accumulator by default in foldl/r?
01:20:27 <lambdabot>   not an expression: `let cons x c n = c x n'
01:20:27 <c_wraith> nimiezko, your problem *is* with foldl.  foldl is tail-recursive, but because the language is lazy, that doesn't mean what you think it does.
01:20:38 <tolkad> c_wraith: humans seem to be able to do it
01:20:57 <Saizan> nimiezko: you could also paste your real recursive function, so we can comment directly on that
01:20:59 <bremner> tolkad: humans can also solve the halting problem, mostly
01:21:07 <tolkad> bremner: no, they can't
01:21:18 <Eduard_Munteanu> I imagine foldl' should better be the theoretical fold for purism.
01:21:25 <Eduard_Munteanu> and have them swapped.
01:21:46 <Eduard_Munteanu> bremner: I'm not really sure about that.
01:22:06 <FunctorSalad> the purist one is foldr anyway :)
01:23:14 <Saizan> tolkad: humans do it by a whole lot of ad-hoc heuristics, i'm not sure i want something like that in ghc
01:23:17 <c_wraith> > foldl (+) 0 [1..5] :: Expr -- nimiezko, this is what is happening.
01:23:18 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
01:23:19 <Eduard_Munteanu> Anyway, when would it make sense to use the lazier fold?
01:23:25 <Saizan> it's already quite unpredictable.
01:23:29 <nimiezko> indeed after rethinking my subject : my own function is just a less readable way to writ foldl
01:23:31 <c_wraith> blah, expr threw out the parens.  boo!
01:23:59 <c_wraith> but in any case.  when it's blowing up, it's not because the recursion isn't being optimized.
01:24:07 <Saizan> Eduard_Munteanu: you mean foldl or foldr?
01:24:21 <c_wraith> It's because the value it's building is not getting evaluated.  It's just becoming a huge chain of thunks.
01:24:23 <Eduard_Munteanu> Saizan: say, when does foldl make sense over foldl'?
01:24:32 <nimiezko> and my examples where not carefully  choosen, they both give a "stack overflow"
01:24:49 <nimiezko> so I will search for "foldl'" if I can find it
01:24:56 <c_wraith> it's in Data.List
01:25:18 <Saizan> Eduard_Munteanu: it makes sense when you're just building up constructors, there's nothing to evaluate there, e.g. "reverse = foldl (\xs x -> x : xs) []"
01:25:39 <Eduard_Munteanu> c_wraith: hm, isn't that thunk chain equivalent to non-optimized recursion in a reasonable sense?
01:26:11 <c_wraith> Eduard_Munteanu, sure.  But the problem isn't that TCO isn't happening.  It's that it doesn't help.
01:26:21 <Eduard_Munteanu> Saizan: would accumulating a-la foldl' hurt at all there?
01:26:37 <tolkad> > foldl' (+) 0 [1..5]:: Expr
01:26:38 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
01:26:46 <tolkad> > foldl (+) 0 [1..5] :: Expr
01:26:47 <lambdabot>   0 + 1 + 2 + 3 + 4 + 5
01:26:50 <Eduard_Munteanu> I see.
01:26:53 <tolkad> no difference, it becomes the same code
01:26:55 <Saizan> Eduard_Munteanu: not much, it would potentially waste some cycles making sure (:) is indeed a constructor
01:27:13 <nimiezko> thanks a lot for the explaination. that works now
01:27:17 <c_wraith> tolkad, please don't tell me you think you actually demonstrated something there.
01:27:23 <tolkad> c_wraith: I'm kidding
01:27:59 <tolkad> c_wraith: wait, haskell doesn't compute things be preforming textual transformations on strings of haskell code?
01:28:07 <tolkad> by performing*
01:28:35 <tolkad> s/haskell/ghc/
01:28:35 <WalterMundt> I'm doing a programming puzzle in Haskell as a learning exercise, and I'm running into stack overflow issues.
01:28:40 <tolkad> you'll notice a lack of /g
01:28:48 <tolkad> it didn't change the second one
01:28:55 <Eduard_Munteanu> Heh.
01:29:08 <Saizan> WalterMundt: heh, can you share the code?
01:29:11 <tolkad> WalterMundt: use foldl'
01:29:35 <lars9> :hoogle
01:29:35 <Eduard_Munteanu> tolkad: that's just the Show instance at play there.
01:29:46 <WalterMundt> It's a graph problem; I have a tail-recursive function that currently builds two big Data.Map instances, one which maps names to ints and the other which maps ints to a (flag, adj-list) set.
01:29:56 <lars9> :hoogle ByteString -> String
01:30:08 <tolkad> Eduard_Munteanu: that show instance is impossible
01:30:23 <WalterMundt> I can, but anyone planning on doing the puzzle, Facebook's liarliar, should be good and not look (the solution is correct AFAICT for small input)
01:30:24 <Saizan> WalterMundt, nimiezko: btw, http://www.haskell.org/haskellwiki/Stack_overflow and http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' are both relevant articles
01:30:24 <nimiezko> It is not  really intuitive that lazyness causes "stack overflow"
01:30:26 <c_wraith> tolkad: it could have lots of seqs i it :)
01:30:34 <WalterMundt> Saizan: thanks, read both already
01:31:02 <Saizan> WalterMundt: so, have you made sure you're strict enough in your accumulating parameters?
01:31:11 <tolkad> c_wraith: the show instance for expr?
01:31:13 <tolkad> Expr*
01:31:18 <c_wraith> yes
01:31:24 <lars9> :src either
01:31:31 <lars9> @:src either
01:31:31 <lambdabot> either f _ (Left x)     =  f x
01:31:31 <lambdabot> either _ g (Right y)    =  g y
01:31:36 <tolkad> @src Expr
01:31:36 <lambdabot> Source not found. Take a stress pill and think things over.
01:31:52 <tolkad> @src Expr
01:31:52 <lambdabot> Source not found. My brain just exploded
01:31:53 <Eduard_Munteanu> @vixen Be nice!
01:31:53 <tolkad> @src Expr
01:31:56 <lambdabot> nice is such a bland word
01:31:56 <lambdabot> Source not found. Maybe if you used more than just two fingers...
01:32:06 <tolkad> @src Expr
01:32:06 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:32:10 <WalterMundt> Saizan: I think so, but I'm about to pastebin the code to see if anyone is kind enough to sanity check, since I'm really-really-new to the language
01:32:20 <Saizan> WalterMundt: another possible problem is if the values of the Maps become big unevaluated expressions, like (1+1+1+1) .. because of multiple inserts
01:32:21 <tolkad> umm I can't get @src to work
01:32:25 <tolkad> uh I'll try again
01:32:27 <tolkad> @src Expr
01:32:27 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
01:32:34 <Saizan> WalterMundt: k :)
01:32:34 <Eduard_Munteanu> I think lambdabot might turn on us...
01:32:41 <Saizan> tolkad: can you stop acting silly?
01:32:42 <WalterMundt> that sounds likely, is there a way to tell/ameliorate that?
01:33:20 <tolkad> I don't see how you could write a Show instance for Expr that does that
01:33:38 <Eduard_Munteanu> I don't think 'write' is appropriate.
01:33:44 <tolkad> code?
01:33:51 <WalterMundt> http://pastebin.com/yrJJnmBL
01:34:32 <Eduard_Munteanu> How do you write a Show instance for Int? It's just there. Though I'm not a GHC expert at all...
01:34:35 <tolkad> wait I think I might understand it
01:34:44 <WalterMundt> a bunch of trace statements are scattered through; it crashes on large input somewhere in readChunks as is.  Without the trace on line 14 the first output from colorR will appear
01:35:11 <Saizan> tolkad: it's from the SimpleReflect module, i don't remember the name of the package though
01:35:37 <WalterMundt> which leads me to conclude that the overflow happens the first time the runtime attempts to evaluate the 'graph' Map
01:36:11 <Eduard_Munteanu> tolkad: I mean some things are handled internally by the compiler.
01:36:29 <tolkad> Eduard_Munteanu: I'm thinking about how you might write this in haskell... there might be a way
01:37:08 <tolkad> Eduard_Munteanu: and that can't be it
01:37:13 <tolkad> Eduard_Munteanu: lambdabot doesn't have a compiler
01:37:15 <Eduard_Munteanu> Well yeah, I can't really tell doing ':: Expr' would be written :/
01:37:20 <Eduard_Munteanu> *how
01:37:30 <WalterMundt> this is literally my first Haskell program so please forgive anything particularly silly
01:38:33 <tolkad> Eduard_Munteanu: I don't understand how it knows which function is which
01:38:38 <tolkad> Eduard_Munteanu: I don't think that's possible
01:39:13 <WalterMundt> oops, that's the version with foldl instead of foldl' on line 60; ignore that, it never gets reached in the cases that matter anyway
01:39:23 <tolkad> > (+) ::Expr
01:39:25 <lambdabot>   Couldn't match expected type `SimpleReflect.Expr'
01:39:25 <lambdabot>         against inferred ...
01:40:01 <tolkad> Eduard_Munteanu: Expr is not provided by the compiler
01:40:08 <tolkad> err environment
01:40:11 <tolkad> whatever
01:40:57 <tolkad> oooh
01:41:07 <tolkad> :t foldl
01:41:09 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
01:41:24 <WalterMundt> Saizan: If you're right about unevaluated map inserts, how do I force evaluation?
01:41:35 <tolkad> Expr only works with functions that are part of classes
01:41:42 <Saizan> WalterMundt: well you're completely lazy on graph everywhere
01:42:49 <Saizan> WalterMundt: i'd add {-# LANGUAGE BangPatterns #-} at the top of the file, and change the "graph" patterns in both readNames and readChunks to "!graph"
01:43:17 <Saizan> WalterMundt: this might not solve anything, but it's a first start, compile with -O or -O2, also
01:43:49 <WalterMundt> thanks.  already did -O2, too, though ;)
01:44:43 <Saizan> s/anything/everything/
01:44:47 <tolkad> :t next
01:44:47 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
01:44:54 <Saizan> quite a typo there :D
01:45:07 <WalterMundt> so just change graph to !graph on lines 26/27/42/43?
01:45:29 <Saizan> yes
01:46:46 <WalterMundt> awesome, that seems to have helped a loit
01:46:48 <WalterMundt> er, lot
01:47:59 <WalterMundt> yup, that took care of the problem
01:48:31 <Saizan> "let (!nameIndex, !nextMap) = .." on lines 30 and 45 might also have a noticeable effect, but i'm not sure
01:49:42 <WalterMundt> heh, runs to completion now on the biggest set I've tried.  Reading the input file and building the graph takes 80-90% of the processing time
01:49:45 <Saizan> anyhow, the problem with graph is that the readNames and readChunks recursion could continue with no problems without ever looking at the value of graph
01:50:16 <WalterMundt> right, I just didn't know the bang-pattern bit, that's not in any haskell guide or anything I've seen so far
01:50:45 <WalterMundt> and in this case I don't know of any cleaner way to let the compiler know that laziness is not helpful there
01:51:04 <Saizan> it's a ghc extension, "foo !x = .." is syntactic sugar for "foo x = x `seq` .."
01:52:22 <WalterMundt> ahh, I see
01:52:27 <Saizan> a common idiom before bang patterns was to have "foo x y z | x `seq` y `seq` z `seq` False = undefined" that guard gets compiled away but it makes the function strict on those arguments
01:53:12 <WalterMundt> *nods* I can see how that would be handy
01:53:33 <pelotom> Saizan: wouldn't False make it never match?
01:54:13 <WalterMundt> pelotom: that's the idea, you want to evaluate it while still doing whateer else the function does, which is presumably attached to other guards
01:54:25 <pelotom> oh, I see
01:54:49 <pelotom> you put that line as the first equation and put the real equations below it
01:55:14 <WalterMundt> right; feels messy and side-effecty to me but I guess that's why the ghc folks added bang patterns
01:55:41 <pelotom> why side-effecty?
01:56:05 <WalterMundt> because you have a line of code that is guaranteed not to affect the return of the function, but is still vitally important
01:56:10 <scree> if evaluating computations is a side-effect we have problems
01:56:36 <pelotom> mm
01:56:59 <pelotom> WalterMundt: you could say the same of function type annotations in some case :)
01:57:04 <pelotom> cases*
01:57:12 <WalterMundt> mm, very true :0
01:57:14 <WalterMundt> er. :)
01:57:16 <pelotom> but they're not side-effecty
01:57:28 <WalterMundt> I suppose that's a good point
01:57:31 <pelotom> both are just clues to the compiler
01:58:14 <tolkad> it would be cool if haskell let you pattern match for bottom
01:58:43 <pelotom> tolkad: no it wouldn't
01:58:48 <tolkad> when you ask the ghc devs for that feature they just complain
01:58:57 <tolkad> pelotom: why not?
01:58:58 <pelotom> then you'd have java's null
01:59:04 <tolkad> pelotom: no
01:59:12 <tolkad> pelotom: bottom is more useful
01:59:23 <pelotom> tolkad: how so?
01:59:28 <tolkad> pelotom: for example, if a computation doesn't halt the result is bottom
01:59:58 <pelotom> tolkad: oh... so uh... you're going to figure out if something didn't halt by checking it for bottom?
02:00:03 <tolkad> yeah
02:00:08 <pelotom> cool idea, man
02:00:18 <tolkad> thx
02:00:22 <pelotom> I think you just solved the halting problem
02:00:26 <Enigmatic> i did that once.
02:00:36 * dancor still in the process
02:04:32 <dancor> the closest reasonable thing to pattern-match-for-bottom might be conal's improving-values
02:04:47 <dancor> http://hackage.haskell.org/packages/archive/reactive/0.8.3/doc/html/FRP-Reactive-Improving.html
02:04:50 <rothwell> 'lo. having a bit of trouble understanding MVar semantics. given f :: MVar Integer -> IO (), can f "mutate" the value in the mvar in a way visible to other threads?
02:04:57 <dibblego> is there not an ifM on hackage and if not should I just darn well write it?
02:05:25 <rothwell> having trouble understanding how i should be passing around mvar values...
02:06:28 <dancor> dibblego: http://holumbus.fh-wedel.de/hayoo/hayoo.html
02:06:52 <pelotom> you don't *want* a useful bottom... that's what java's null is, and people use it to indicate "no result"... which leads to NPEs
02:07:37 <tolkad> pelotom: haskell works the same way
02:07:41 <dibblego> dancor, I think that's a no
02:07:49 <pelotom> tolkad: no it doesn't
02:08:01 <tolkad> pelotom: don't you often catch undefined exceptions?
02:08:03 <dancor> dibblego: i see some ifM's there
02:08:06 <pelotom> you can't inspect bottom to see if it's bottom... and that's good
02:08:17 <dancor> the answer to "is there an ifM on hackage" is "yes"
02:08:18 <tolkad> pelotom: you can catch undefined
02:08:18 <pelotom> tolkad: only in IO
02:08:19 <dibblego> oh so there is
02:08:29 <dibblego> I got different results second time around
02:08:45 <pelotom> tolkad: you can't do anything useful with undefined in pure code
02:09:01 <tolkad> pelotom: yes you can, just use unsafePerformIO
02:09:10 <dancor> whether or not you should write your own more-specific package with it, is unclear
02:09:13 <pelotom> tolkad: that's not pure code 9_9
02:09:28 <dancor> MonadicVersionsOfPreludeThings-1.0
02:09:51 <dibblego> I'm thinking yes
02:09:56 <dancor> could be a big hit
02:10:10 <dibblego> the most appropriate ifM I found has the arguments around the wrong way and is missing many other functions
02:10:14 <dibblego> e.g. findM
02:10:43 <tolkad> um why not just write liftM find?
02:10:49 <tolkad> :t find
02:10:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
02:11:12 <dancor> :t liftM find
02:11:13 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m ([a] -> Maybe a)
02:11:21 <tolkad> :t liftM2 find
02:11:22 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m (Maybe a)
02:11:26 <dibblego> because findM :: (a -> m Bool) -> m [a] -> m (Maybe a)
02:11:39 <tolkad> :t liftM2 find
02:11:40 <lambdabot> forall a (m :: * -> *). (Monad m) => m (a -> Bool) -> m [a] -> m (Maybe a)
02:11:44 <tolkad> oh
02:11:54 <tolkad> (a -> m Bool)? hmm
02:12:02 <dancor> one thing is that in general you are supposed to separate out monadic stuff
02:12:38 <dancor> but i'm not sure what that maxim would have to say about findM
02:12:40 <lars9> regex-posix is not monadic... when a regex does not compile, it exit the program, instead of Either ErrorInfo Regex
02:12:47 <tolkad> dibblego: if you could specify the behavior of this kind of lifting, you might be able to implement it with flexible instances
02:12:56 <tolkad> dibblego: not sure
02:13:17 <Eduard_Munteanu> lars9: maybe you're supposed to catch that as an exception
02:13:52 <tolkad> hmm, I'll see if I can write it
02:14:18 <lars9> Eduard_Munteanu: how to catch it?
02:14:59 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html
02:15:21 <lars9> EvanR-work: catch expection involves IO
02:15:56 <Eduard_Munteanu> Yes.
02:16:24 <Eduard_Munteanu> Most likely that regex stuff lives in IO or something.
02:17:05 <lars9> yeah, it uses C lib
02:17:42 <lars9> no good
02:17:49 <pelotom> is there a regex library for haskell that does replacement in addition to finding?
02:18:49 <lars9> regex-pcre and regex-pcre-light are too simple, their 'match' only returns 1st match.
02:19:38 <lars9> so if you search for "boy$" in "boy oh boy", the result is simply "boy", but i only want the one in the end of string!
02:21:25 <exDM69> @hoogle regex
02:21:25 <lambdabot> module Text.Regex
02:21:25 <lambdabot> Text.Regex.Posix.ByteString data Regex
02:21:25 <lambdabot> Text.Regex.Posix.Sequence data Regex
02:22:25 <lars9> pelotom: posix regex does substitute
02:22:55 <pelotom> lars9: it dos?
02:22:59 <pelotom> does*
02:23:06 <lars9> yep
02:23:19 <lars9> but it's not monadic, and very inefficient
02:23:20 <rothwell> am i missing something here? http://paste.lisp.org/display/116168 -- prints '0'
02:23:27 <rothwell> i thought it would print '256'
02:24:48 <Enigmatic> if you call takeMVar again it will be 256
02:25:14 <Enigmatic> try using newEmptyMVar instead of newMVar
02:26:50 <rothwell> Enigmatic: you're right
02:26:55 <rothwell> i... don't understand why
02:27:17 <ketil> After using monoid builders a tiny bit, I'm looking at blaze-html.  I seem to remember some sneering being done at using monads instead of monoids for this - but, isn't the syntax worth it?
02:27:26 <Enigmatic> 'newMVar 0' fills it with 0, so the first read will return 0, and switch the mvar state to Empty
02:27:40 <Enigmatic> once it is empty, putMVar will unblock and fill it with 256
02:27:49 <rothwell> Enigmatic: ah, right!
02:28:07 <rothwell> that explains the weird results in my 'real' program...
02:28:37 <Enigmatic> :)
02:28:43 <rothwell> thanks
02:29:06 <tolkad> OverlappingInstances doesn't work with associated type families?
02:29:16 <tolkad> : / that forces me to use functional dependencies
02:29:55 <tolkad> I guess it's bad anyway
02:44:08 <Saizan> ketil: well, as long as it's easy to use it as a simple monoid too i don't see much of a problem in exposing a mostly Writer oriented interface for such a thing
02:45:34 <Saizan> ketil: though with a shortand like (<>) = mappend it'd be much nicer to use the monoid directly
02:56:03 <Samantha> hello
02:56:14 <Samantha> is the room empty?
02:56:49 <elliott>   show (Conj xs) = map (\x -> '(' : show x ++ ")") xs
02:56:56 <Eduard_Munteanu> Samantha: yes, everybody is out today.
02:56:58 <elliott> I have no idea why this is type erroring. I feel as if my brain has broken.
02:56:59 <elliott> OH! oh i see
02:57:04 <elliott> forgot to join them
02:57:05 <elliott> disregard me
02:57:37 <Samantha> hahaha
02:57:37 <Samantha> I have a question if you guys dont mind
02:58:41 <Nibble> Samantha: throw it out
02:58:46 <Nibble> don't ask about asking
03:00:37 <Saizan> elliottcable: btw, '(' : show x ++ ")" is seriously ugly
03:01:06 <Saizan> elliottcable: "(" ++ show x ++ ")" is so much more elegant
03:01:11 <Samantha_> Sorry
03:01:16 <Samantha_> ok
03:01:27 <elliott> @hoogle (x -> y -> [z]) -> [x] -> [y] -> [z]
03:01:28 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
03:01:28 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
03:01:28 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:01:38 <elliott> hmm
03:01:45 <elliott> @hoogle (x -> y -> z) -> [x] -> [y] -> [z]
03:01:45 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
03:01:45 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
03:01:45 <lambdabot> Control.Parallel.Strategies parZipWith :: Strategy c -> (a -> b -> c) -> [a] -> [b] -> [c]
03:01:51 <elliott> concat . zipWith
03:01:51 <elliott> right
03:01:58 <elliott> oh, should have done that in /msg :)
03:02:06 <Eduard_Munteanu> :t liftM3
03:02:07 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
03:02:14 <Eduard_Munteanu> :t liftM2
03:02:15 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
03:02:19 <elliott> ah
03:02:21 <elliott> that'd work :)
03:02:24 <elliott> thanks Eduard_Munteanu
03:02:33 <Samantha_> Ok here is my code and my error message
03:02:36 <Samantha_> Link http://pastebin.com/jUaAmXv6
03:02:43 <Samantha_> hello
03:02:57 <Samantha_> Why my name is showing this == Samantha [98830ac3@gateway/web/freenode/ip.152.131.10.195] has quit [Ping timeout: 265 seconds]
03:02:58 <elliott> oh wait
03:03:08 <elliott> Eduard_Munteanu: my function there actually gives Maybe [foo]
03:03:11 <elliott> I need, uh
03:03:19 <elliott> (a -> b -> Maybe [c]) -> [a] -> [b] -> Maybe [c]
03:03:21 <Samantha_> Eduard_Munteanu: hello
03:03:24 <elliott> don't suppose there's anything premade for that? :)
03:04:13 <Eduard_Munteanu> elliott: hm, and you're actually getting a maybe as an arg?
03:04:25 <Samantha_> Nibble : Link http://pastebin.com/jUaAmXv6
03:04:29 <elliott> Eduard_Munteanu: hmm? none of the arguments are maybes
03:04:36 <elliott> Eduard_Munteanu: but my function is
03:04:43 <elliott> @hoogle (a -> b -> Maybe [c]) -> [a] -> [b] -> Maybe [c]
03:04:43 <lambdabot> No results found
03:04:44 <elliott> worth a try
03:04:45 <elliott> aww!
03:05:04 <Twey> Samantha_: Exactly what it says: you're meant to give a one-argument function as wayAheadFn, but you've given it a two-argument function instead.
03:05:21 <Samantha_> in which line
03:05:22 <Samantha_> ?
03:05:32 <Eduard_Munteanu> Ah, if it were like (a -> b -> c) -> [a] -> [b] -> Maybe [c], then return . liftM2 would've done
03:05:40 <elliott> Eduard_Munteanu: yeah, unfortunately not :)
03:05:50 <Twey> Samantha_: The one it indicatesâ€¦
03:06:00 <elliott> @hoogle [Maybe [a]] -> Maybe [[a]]
03:06:00 <lambdabot> No results found
03:06:03 <elliott> huh?
03:06:09 <elliott> @hoogle [m a] -> m [a]
03:06:09 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:06:09 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
03:06:09 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
03:06:11 <elliott> right
03:06:19 <elliott> concat . sequence . map
03:06:29 <elliott> erm, still zipWith actually
03:06:32 <elliott> :t zipWith
03:06:33 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
03:06:42 <Eduard_Munteanu> Erm, not return . liftM2, but something along those lines.
03:06:51 <Samantha_> Twey: I dont understand
03:06:53 <Samantha_> ?
03:07:00 <elliott> :t \(f::a -> b -> Maybe [c]) xs ys -> concat . sequence $ zipWith f xs ys
03:07:01 <lambdabot>     A pattern type signature cannot bind scoped type variables `a', `b', `c'
03:07:01 <lambdabot>       unless the pattern has a rigid type context
03:07:01 <lambdabot>     In the pattern: f :: a -> b -> Maybe [c]
03:07:15 <elliott> :t \(f::a -> b -> Maybe [c]) (xs::[a]) (ys::[b]) -> concat . sequence $ zipWith f xs ys
03:07:16 <Twey> Samantha_: On the line the error message says, in the expression the error message says, you've made the error the error message says
03:07:16 <lambdabot>     A pattern type signature cannot bind scoped type variables `a', `b', `c'
03:07:16 <lambdabot>       unless the pattern has a rigid type context
03:07:16 <lambdabot>     In the pattern: f :: a -> b -> Maybe [c]
03:07:21 <elliott> oh to hell with that, i'll just try it
03:07:22 <Eduard_Munteanu> Yeah, zipWith probably made more sense for lists.
03:07:48 <Twey> Samantha_: â€˜Sorting.hs:15:4:â€™ â€” these are line and column numbers
03:07:56 <Samantha_> Twey: How can I fix that problem?
03:08:09 <Twey> Samantha_: By passing a one-argument function instead
03:08:28 <elliott> @hoogle Bool -> m a
03:08:29 <lambdabot> Control.Monad.STM check :: Bool -> STM a
03:08:29 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
03:08:29 <lambdabot> Data.Generics.Aliases unGM :: GenericM' m -> a -> m a
03:08:34 <elliott> hmm, no genericGuard? :)
03:08:40 <Samantha_> in here    (\x1(x:xs) -> if x1 > (x) then (x:x1:xs) else if x1 < (xs) then (x1:x:xs) else (x:xs:x1))
03:08:42 <Samantha_> ?
03:09:00 <Samantha_> Twey: in here    (\x1(x:xs) -> if x1 > (x) then (x:x1:xs) else if x1 < (xs) then (x1:x:xs) else (x:xs:x1))
03:09:02 <Twey> Samantha_: Yes, that is the expression given to you as the source of the error in the error message.
03:09:32 <Samantha_> Twey: is supoosed to be this (\(x:xs) -> if x1 > (x) then (x:x1:xs) else if x1 < (xs) then (x1:x:xs) else (x:xs:x1))
03:09:49 <Twey> Samantha_: Where does the â€˜x1â€™ come from?
03:10:05 <Samantha_> I am trying to sort the list
03:11:23 <elliott> @hoogle (a -> b -> m c) -> m a -> m b -> m c
03:11:23 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
03:11:23 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
03:11:23 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:13:34 <Samantha_> Twey: any clue
03:14:22 <Twey> Samantha_: I've asked you a question, but you didn't answer it
03:14:44 <Twey> I'd love to help, but I'm afraid I don't have very much time at the moment â€” I have to go out shortly.  Sorry.
03:14:59 <Samantha_> Twey: I am trying to sort the list so I need an extra variable to compare the head and the tail
03:15:22 <Twey> That doesn't explain where you define said variable
03:19:04 <haskellElephant> @pl \a b c d -> a b (c d)
03:19:05 <lambdabot> ((.) .)
03:20:52 <sipa> @pl \a b c d -> a (b c d)
03:20:53 <lambdabot> (.) . (.)
03:21:05 <haskellElephant> hmm I was expecting the owl  ((.)$(.)) ...
03:21:29 <haskellElephant> @pl \a b c d -> (a b) (c d)
03:21:29 <lambdabot> ((.) .)
03:21:45 <Kaidelong> @unpl ((.)$(.))
03:21:46 <lambdabot> (\ b c e f -> b c (e f))
03:22:17 <elliott> @hoogle Maybe a -> Bool
03:22:17 <lambdabot> Data.Maybe isJust :: Maybe a -> Bool
03:22:17 <lambdabot> Data.Maybe isNothing :: Maybe a -> Bool
03:22:17 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
03:22:23 <elliott> @hoogle [Maybe a] -> [a]
03:22:23 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
03:22:23 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
03:22:23 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
03:22:25 <haskellElephant> Seems like unpl . pl /= id
03:23:05 <Kaidelong> @pl (\ b c e f -> b c (e f))
03:23:05 <lambdabot> ((.) .)
03:23:16 <Kaidelong> well
03:23:18 <Kaidelong> that's the same thing
03:24:00 <haskellElephant> Yea but \ b c e f -> b c (e f) is the same thing as ((.) .) so I was thinking about syntactic equality...
03:24:26 <haskellElephant> and ((.) .) is the same thing as ((.)$(.)) ...
03:24:48 <haskellElephant> I'm not saying it should be either though =D...
03:28:31 <sajkr> @pl (\f a -> f a a)
03:28:31 <lambdabot> join
03:29:00 <sajkr> lol
03:32:19 <elliott> anyone totally in the mood for de-uglifying ugly code? :)
03:33:08 <tomh> you mean to translate php, perl or lisp to haskell? :P
03:34:11 <sipa> i think if you'd do that (automatically), you'll get some of the worst looking haskell code there is
03:35:01 <tomh> nah depends on the program you are translating
03:35:29 <elliott> no, i mean ugly haskell to non-ugly haskell :)
03:35:29 <tomh> oh, automatically, then probably yes
03:35:42 <Kaidelong> I want to shuffle a mutable vector but I get some error if I try to return something like m (v s a) where m isn't s
03:36:16 <Kaidelong> and v is MVector and m is MonadRandom
03:37:06 <elliott> specifically this gem
03:37:07 <elliott>   case catMaybes $ map (\(l,r) -> fmap ((,) r) (unify l x)) ys of
03:37:07 <elliott>     (x',bs):_ -> rewrite x' (map (\(s,b) -> (atom s, b)) bs ++ ys)
03:37:07 <elliott>     [] -> x
03:37:14 <elliott> "gem"
03:37:31 <Kaidelong> perhaps I should just not use MonadRandom, keep it in ST, and parameterize the RNG as part of the state?
03:38:01 <aleator> Anyone know if I can have common options for several modes with CmdArgs?
03:39:32 <Kaidelong> oh looks like I should use the monad transformer RandT
03:39:57 <Kaidelong> not that I really know how to use a monad transformer
03:40:04 <haskellElephant> Oh yea elliott !!!
03:40:10 <haskellElephant> my favorite past time! =D
03:40:16 <elliott> haskellElephant: the code is up there, have fun :)
03:41:12 <dschoepe> aleator: One approach would be to use something like data Modes = Mode1 CommonOptions SpecificOptions1 | Mode2 CommonOptions SpecificOptions2 ...
03:41:26 <haskellElephant> elliott: where is the code you say?
03:42:00 <aleator> dschoepe: Ah. How does that work in the modes line?
03:42:14 <elliott> 31<elliott>30   case catMaybes $ map (\(l,r) -> fmap ((,) r) (unify l x)) ys of
03:42:14 <elliott> 31<elliott>30     (x',bs):_ -> rewrite x' (map (\(s,b) -> (atom s, b)) bs ++ ys)
03:42:14 <elliott> 31<elliott>30     [] -> x
03:42:17 <elliott> haskellElephant: there :P
03:43:19 <haskellElephant> definitly ugly ! how about putting it on hpaste for me !
03:43:51 <elliott> haskellElephant: those are the only three lines :) but okay
03:43:55 <elliott> @hpaste
03:43:55 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
03:44:04 <elliott> heh, that's out of date
03:44:29 <elliott> haskellElephant: http://hpaste.org/41050/ugly
03:44:33 <elliott> hey, those suggestions there are useful, though
03:44:38 * elliott implements them
03:45:13 <elliott> haskellElephant: http://hpaste.org/paste/41050/2#p41051
03:45:18 <elliott> haskellElephant: second one on that page is the ugly code :)
03:46:02 <haskellElephant> wonder what pl would say about your lambda ...
03:46:06 <haskellElephant> @pl \(l,r) -> fmap ((,) r) (unify l x)
03:46:07 <lambdabot> uncurry (flip (fmap . (,)) . flip unify x)
03:46:54 <elliott> i'm not convinced that's more readable :D
03:47:00 <elliott> (r,) would be nicer than ((,) r) but that's not standard :-(
03:48:03 <haskellElephant> not a whole lot better, but if you flip the definition of unify it might help...
03:48:15 <dschoepe> aleator: I didn't try it, but I guess specifying modes [Mode1 commonOpts specialOpts, Mode2 ...] would work
03:49:51 <aleator> dschoepe: I'll try and see :)
03:50:46 <elliott> haskellElephant: unify makes more sense this way around, though
03:50:47 <elliott> well, i think
03:50:55 <elliott> holes on the left, mirror but with holes plugged in on the right
03:53:24 <Kaidelong> Oh no
03:53:39 <dschoepe> aleator: Hm, I tried it and it doesn't seem to work
03:54:13 <aleator> dschoepe: Me too. I guess I can live with repeating the arguments..
03:56:37 <Kaidelong> how do I string together monad transformers like I'd have to to do an iterative shuffle on a mutable vector?
03:56:51 <Kaidelong> looks like there is no >>= for monad transformers
03:58:09 <haskellElephant> elliot: How about adding a function in a where clause wich is:  unifyPair = second (\l -> unify l x) , then the first line becomes mapMaybe (fmap unifyPair) ys ... Either that or just inline unifyPair ...
04:01:11 <haskellElephant> elliot: It would really be nice if you changed the order in your definition of unify though, because then it would be mapMaybe (fmap . second . (unify x))
04:08:34 * hackagebot xss-sanitize 0.2.3 - sanitize untrusted HTML to prevent XSS attacks  http://hackage.haskell.org/package/xss-sanitize-0.2.3 (GregWeber)
04:09:38 <Twey> elliott: (psst: uncurry fmap . (flip unify x *** (,)))
04:10:25 <elliott> Twey: you're awful :)
04:23:46 * elliott thinks haskellElephant was wrong, even after swapping the order those simplifications don't work
04:24:41 * hackagebot haskell-src-exts 1.9.5 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.9.5 (NiklasBroberg)
04:26:34 <elliott> @hoogle (a, Maybe b) -> Maybe (a,b)
04:26:34 <lambdabot> No results found
04:26:40 <elliott> @hoogle (a, m b) -> m (a,b)
04:26:41 <lambdabot> No results found
04:27:03 <ClaudiusMaximus> @djinn (a, Maybe b) -> Maybe (a, b)
04:27:03 <lambdabot> f (a, b) =
04:27:04 <lambdabot>     case b of
04:27:04 <lambdabot>     Nothing -> Nothing
04:27:04 <lambdabot>     Just c -> Just (a, c)
04:27:44 <elliott> well, yeah :)
04:28:21 <Twey> f (a, b) = fmap ((,) a) b; f = uncurry fmap . first (,)
04:28:38 <elliott> Twey: I'm trying to *simplify* this :-)
04:28:53 <Twey> That is simplified!
04:29:03 <elliott> Twey: Yeah, but it doesn't simplify the whole thing :-P
04:29:03 <Twey> elliott: Can you paste the whole function?
04:29:07 <Twey> It's hard to simplify a snippet
04:29:16 <elliott> Twey: That is the entire function.
04:29:25 <elliott> Well, modulo "rewrite x ys =".
04:29:27 <Twey> Hm?  What you pasted was a case expression
04:29:29 <Twey> Aha
04:29:36 <Twey> See, that makes quite a lot of difference
04:29:41 <elliott> Okay :-)
04:29:42 <elliott> Twey: Oh, and unify has had its arguments swapped since that paste.
04:29:49 <elliott> Since it probably does make things more convenient.
04:29:53 <elliott> So s/unify l x/unify x l/...
04:30:03 <Twey> Okay
04:30:57 <elliott> I can get
04:30:59 <elliott> second . unify $ undefined
04:30:59 <elliott>   :: (d, HoleyE) -> (d, Maybe [(String, SolidE)])
04:31:11 <elliott> but that doesn't help me turn that into a -> Maybe (d, [(String, SolidE)]) which I can pass to mapMaybe.
04:31:27 <elliott> "into a", not "into (a -> ...)".
04:36:51 <Twey> elliott: http://hpaste.org/paste/41050/twey#p41054
04:38:33 <elliott> Twey: Impressive... but I don't really consider that more readable :-) I think I'll steal that last bit for the mapMaybe, though!
04:39:18 <Twey> It is somewhat more readable than the one you used, though still not particularly nice
04:39:49 <elliott> Well, at least I can understand what mine does once it gets past the case :-) My fu is not strong enough to say that about yours :(
04:40:41 <Twey> elliott: Try evaluating it by hand
04:40:44 <Twey> It's good practice
04:40:56 <elliott> Sure :) I think I'll still use a case though.
04:41:11 <Twey> No, the case is the easiest part to factor out
04:41:19 <Twey> Your â€˜caseâ€™ is entirely redundant for â€˜maybeâ€™
04:41:39 <elliott> It is?
04:41:51 <Jafet> :t maybe
04:41:52 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
04:42:05 <elliott> Yeah, I know of maybe. But hmm, yeah...
04:42:09 <elliott> Twey: Wait, are you sure?
04:42:21 <elliott> With listToMaybe, sure...
04:42:25 <scan> Hello, just a question: Does anyone know some source for OSDev in Haskell? My first approach was finding the libraries the ghc links and replace them, I just wanna know if there's already some of that done before.... or perhaps a ghc --ffreestanding mode?
04:42:27 <Twey> Oh, yeah
04:42:30 <Twey> With listToMaybe
04:42:42 <elliott> Twey: So it's not *that* easy to factor out. :)
04:42:43 <Twey> Or my â€˜listâ€™ function
04:43:06 <Twey> Sure it is.  It just takes two symbols instead of one.
04:43:11 <elliott> scan: http://programatica.cs.pdx.edu/House/ (modified ghc) http://www.ninj4.net/kinetic/haskell-independent.html (cheating)
04:43:16 <elliott> scan: Good luck with that :P
04:43:24 <lars9> is either a monad like maybe?
04:43:41 <scan> elliot: thanks, I think this will occupy me for some minutes ^^
04:44:14 <elliott> My nick is a great way of finding the people who don't use tab-complete. :)
04:44:29 <Twey> lars9: Not usually.
04:44:56 <Twey> lars9: There's an instance in Control.Monad.Instances, but it requires an Error instance on the Left value
04:45:19 <scan> elliott: my client is prolly too basic for tab-complete
04:45:34 <elliott> scan: I think even Pidgin lets you tab-complete.
04:45:36 <elliott> Not sure, though.
04:46:03 <scan> elliott: oh it does... well, another thing learned
04:46:15 <elliott> :)
04:47:35 <scan> elliott: well first I must find out if ghc has a 32 bit compilation mode
04:47:56 <lars9> Twey: when passing a string step by step to return a Either ErrorInfo String, each time when parsing "x:xs" i need to "case parse xs of" "Left err -> Left err" "Right result -> x:result"
04:48:08 <lars9> kind of repeating myself
04:48:42 <Twey> lars9: That doesn't require Monad
04:48:54 <lars9> there are several parsing steps
04:48:59 <aleator> Gah. My cabal complains that it can't find data.char, which it seems to think is only in base3 whereas my .cabal asks for base4
04:49:05 <Twey> lars9: It's just: fmap (x :) (parse xs)
04:49:19 <Twey> Or (x :) <$> parse xs, if you prefer that sort of thing
04:49:20 <aleator> How do I fix that?
04:49:23 <elliott> scan: " I recommend building on a modern 32-bit Linux system. House does not build on 64-bit linux directly; you'll need to use a 32-bit chroot. You'll also need to install genext2fs."
04:49:26 <elliott> scan: as far as house goes.
04:50:04 <scan> elliott: I will first take a look at house and hOp to find out how much C is actually required
04:50:35 <dcoutts> aleator: details please
04:50:36 <lambdabot> dcoutts: You have 2 new messages. '/msg lambdabot @messages' to read them.
04:50:57 <lars9> Twey: is that parsec? im not using it
04:51:10 <lars9> :i <$>
04:51:18 <lars9> @:i <$>
04:51:19 <lambdabot> Maybe you meant: . ? @ bf bid do ft id pl rc v wn
04:51:44 <aleator> dcoutts: http://hpaste.org/41055/cabal_problem
04:52:01 <elliott> I'm on Debian testing and have the Debian ghc package; what's the least painful way for me to get cabal(1)?
04:52:10 <Twey> lars9: No
04:52:22 <dcoutts> elliott: I thought it had a package for it
04:52:24 <Twey> (<$>) = fmap, restricted to Applicative
04:52:27 <Twey> Control.Applicative
04:52:34 <dcoutts> aleator: ah, you've listed the build-depends in the wrong place
04:52:36 <elliott> dcolish: It might. But is it up to date?
04:52:42 <dcoutts> aleator: it goes in the executable section
04:52:45 <hpc> :t (<$>)
04:52:46 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:53:00 <dcoutts> aleator: there's an open ticket about it incorrectly being accepted in the global section
04:53:45 <dcoutts> elliott: if it's recent enough to work with your ghc, then it's ok since it can self-update
04:53:53 <aleator> dcoutts: Ah. Thanks! If I've got a library and executable, I need to make two build depends?
04:53:56 <Twey> lars9: The Functor instance is in Control.Monad.Instances (for some bizarre reason)
04:54:15 <Twey> Oh, doesn't look like there's an Applicative instance, though, so I guess <$> won't work
04:54:17 <elliott> dcoutts: Even when it's in /usr/bin?
04:54:27 <elliott> dcoutts: Tampering package files, yaaay!
04:54:36 <elliott> Or just installing in duplicate to ~, I guess...
04:54:38 <dcoutts> aleator: no, there's no library, just the exe
04:54:56 <dcoutts> elliott: no, it'll install itself in the usual place, not /usr/bin
04:55:05 <elliott> dcolish: not as a debian package it won't
04:55:19 <aleator> dcoutts: I meant in a hypothetical situation where I add a lib to the cabal :)
04:55:28 <hpc> Twey: look at the type of (<$>); it is just an alias; it so happens to be in the Applicative package, but still uses Functor
04:55:35 <dcoutts> elliott: right, the default place that cabal-install installs things is ~/.cabal/ and it'll do that with itself too
04:55:47 <dcoutts> aleator: right, they're independent
04:55:58 <Twey> :t (<$>)
04:55:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
04:56:19 <Twey> hpc: Oh, I thought it was restricted, like â€˜mapâ€™ and â€˜(.)â€™
04:56:20 <elliott> dcoutts: right, so i'll have an out of date /usr/bin/cabal :) Eh, whatever.
04:56:22 <Twey> Good-ho
04:56:26 <hpc> Twey: easy mistake to make
04:56:29 <dcoutts> elliott: yep
04:56:47 <aleator> dcoutts: Thanks again. Now haskell controlled robotic arms can take over the world.
04:56:59 <dcoutts> elliott: if that displeases you, you can always uninstall it :-) you were asking for a painless method
04:57:30 <elliott> dcoutts: Yeah, but then I realised that the parsec package is probably up to date and it became academic! :)
04:57:45 * Kaidelong wonders if he understands the idea behind RandT now
04:58:48 <Kaidelong> if you have RandT m g a, you can get a m (a, g) and then make an m (Rand T m g b) and then an m (m (Rand T m g c) by extension
04:58:56 <Kaidelong> and then you're able to join the wrapping monad
05:04:52 <elliott> Wow -- the new Haddock design is very nice.
05:05:06 <elliott> Although what happened to the vertical type summaries? I liked those.
05:08:56 <Twey> elliott: They're in the sidebar, I think?
05:09:17 <elliott> Twey: No, I meant, the type of a function would be displayed with each argument's type on one line, and to the right of that the function summary would be there.
05:09:24 <elliott> Oh, or maybe that only happened when each argument was documented.
05:09:30 <elliott> Whatever, it was easier to read.
05:09:38 <Twey> elliott: Oh, yeah, that still happens if you document the arguments
05:09:49 <Twey> E.G. http://hackage.haskell.org/packages/archive/network/2.2.1.10/doc/html/Network.html#v:listenOn
05:11:17 <elliott> Twey: It should happen for everything else, too, rather than a big vertical stretch :)
05:11:25 <elliott> But that's just my opinion.
05:11:39 <elliott> Sidenote: Why is hackage.h.o so slow?
05:13:03 * elliott gives up on parsec 3...
05:25:22 <Kaidelong> hmm
05:25:30 <Kaidelong> I wonder if I can get a type like
05:25:58 <Kaidelong> Rand StdGen (MVector s a -> s ()) working
05:26:15 <Kaidelong> basically think of the shuffle as a function that is generated randomly
05:26:20 <Kaidelong> but the function itself is deterministic
05:29:02 * hackagebot Clipboard 2.0.0 - Access to the (Windows) clipboard.  http://hackage.haskell.org/package/Clipboard-2.0.0 (DanielDiaz)
05:35:48 <Axman6> hmm, i wonder if that clipboard package could work on OS X as well, using the pbpaste and pbcopy commands (i'm sure there's *nix equivalents)
05:36:30 <elliott> xsel(1) is *nix equivalents
05:36:38 <elliott> *equivalent
05:36:39 <elliott> well.
05:36:41 <elliott> X equivalent
05:36:49 <Axman6> yeah
05:36:59 <Twey> xclip too
05:37:08 <elliott> Axman6: but you have to handle primary vs. secondary selection vs. clipboard
05:37:16 <elliott> which is rather subtle
05:37:24 <Twey> But neither of those work with OS X, because it doesn't use X
05:37:34 <Axman6> thank god
05:37:57 <elliott> except when it does (X11.app)
05:38:00 <Twey> For proprietary, inextensible layers of crud?  No thanks :Ã¾
05:38:02 <Twey> Yeah
05:38:23 <elliott> Twey: X11 is a billion inextensible layers of crud made extensible.
05:38:37 <elliott> It's in my top list of worst designed systems ever...
05:38:46 <Twey> It has its issues, but it's pretty flexible
05:38:56 <elliott> It's terrible, just admit it. :)
05:39:01 <Twey> I don't think you can Cocoa over a network, for exampleâ€¦
05:39:16 <Twey> It is terribly designed, but it has obvious features that all the alternatives seem to lack
05:39:23 <elliott> Using X over a network is a little section of my memories right next to pain and eternal anguish of lag.
05:39:40 <elliott> It'd be a *lot* faster and smoother if, e.g. GTK did its own network stuff and rendered widgets locally.
05:39:44 <Twey> Well, networks are like that
05:39:59 <Twey> Mmm, probably
05:40:00 <elliott> Not if they're communicating "this and that widget" rather than "this pixel, and this pixel, and this..."
05:40:20 <Twey> A higher level of abstraction in X in general would be nice
05:40:36 <Twey> Or a secondary layer between X and the toolkit
05:40:49 <Twey> I'm not happy with the idea of putting such functionality into the toolkits themselves
05:41:34 <elliott> "holey >>= (`fmap` (string "-->" >> solid)) . (,)" Well this is ugly.
05:41:40 <elliott> Twey: It's not nice but... neither is X.
05:42:13 <Twey> True
05:42:23 <lars9> in a chapter of a tutorial, the author shows how to eliminate ugly recursive if/else's, anyone remember?
05:43:08 <Twey> elliott: Not that uglyâ€¦
05:43:31 <lars9> all those if/else's are like: "if error then return else go on next"
05:43:39 <Twey> elliott: "holey >>= flip fmap (string "-->" >> solid) . (,)
05:43:45 <Twey> â€¦ one less level of brackets
05:44:10 <Twey> lars9: Depending on what you're doing in the branches, that could involve monads, functors, or applicatives
05:44:13 <Twey> Or maybe arrows
05:44:24 <ClaudiusMaximus> > liftM4 (,,,) [Just 1, Just 2, Just 3, Just 4]
05:44:24 <lambdabot>   Overlapping instances for GHC.Show.Show
05:44:25 <lambdabot>                              ([a2] ...
05:44:30 <ClaudiusMaximus> oops
05:44:48 <ClaudiusMaximus> takes arguments not a list
05:44:53 <lars9> Twey: for example parsing a list sequentially
05:44:54 <Twey> > liftM4 Just Just Just Just 1 2 3 4
05:44:55 <lambdabot>   Couldn't match expected type `a2 -> a3 -> a4 -> t1 -> t2 -> t'
05:44:55 <lambdabot>         agai...
05:45:00 <Twey> Oops
05:45:02 <Twey> > liftM4 (,,,) Just Just Just Just 1 2 3 4
05:45:04 <lambdabot>   Couldn't match expected type `t1 -> t2 -> t3 -> t'
05:45:04 <lambdabot>         against inferred...
05:45:08 * Twey gives up
05:45:19 <Twey> lars9: It depends exactly what you're doing
05:45:32 <ClaudiusMaximus> > liftM4 (,,,) (Just 1) (Just 2) (Just 3) (Just 4)
05:45:33 <lambdabot>   Just (1,2,3,4)
05:45:43 <ClaudiusMaximus> > liftM4 (,,,) (Just 1) (Just 2) Nothing (Just 4)
05:45:44 <lambdabot>   Nothing
05:45:56 <Twey> lars9: If you need to be able to change the constructor, e.g. Right â†’ Left or Just â†’ Nothing, you need a monad
05:46:14 <Twey> lars9: If you only care about modifying the value inside the constructor, you can use a functor
05:46:21 <ClaudiusMaximus> instead of  \ a b c d -> if isJust a then if isJust b then if isJust c ...
05:46:47 <hpc> question: does backtick syntax work in type signatures?
05:46:49 <ClaudiusMaximus> @where sec
05:46:49 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
05:46:59 <hpc> ie, can i do Int `Either` String
05:47:10 * hackagebot Clipboard 2.1.0 - Access to the (Windows) clipboard.  http://hackage.haskell.org/package/Clipboard-2.1.0 (DanielDiaz)
05:47:24 <ClaudiusMaximus> :t Right "foo" :: Int `Either` String
05:47:25 <lambdabot> Either Int String
05:47:28 <elliott> Twey: I feel like we need more things like <$>, *> and <*.
05:47:37 <lars9> Twey: for example, the regex substitute i made: http://hpaste.org/41056/regex_replace
05:47:39 <Twey> elliott: We have a lot of them
05:47:41 <elliott> Things to control what values to discard and not in a monadic chain...
05:47:53 <elliott> Twey: I know, but I still end up flipping fmaps and the like :)
05:48:00 <lars9> Twey: it supports back referencing, for example \1 is 1st submatch, \2 is 2nd submatch
05:48:04 <Twey> Nowt wrong with that
05:48:28 <lars9> Twey: this code works but rather ugly... exactly like c
05:48:39 <Darkone> Silly question now. How do I import a script from the directory the main script is in? Just import blah or import blah.hs
05:48:47 <elliott> Twey: Sometimes I feel like do-notation must write terrible poetry and slit its wrists.
05:48:50 <elliott> It never gets any love :)
05:48:55 <elliott> Points, too.
05:48:57 <Twey> lars9: In that case it looks like you could do with some application of â€˜eitherâ€™
05:48:58 <ClaudiusMaximus> Darkone: import Blah  -- case matters
05:49:04 <Darkone> kk
05:49:14 <Darkone> Thanks :)
05:49:44 <ClaudiusMaximus> Darkone: also, if you have subdirectories, the inner modules should declare eg   module Foo.Bar.Baz    in Foo/Bar/Baz.hs
05:49:51 <lars9> Twey: how to do something about those 'Either'? Left means error msg, right is answer
05:49:59 <Twey> lars9: And â€˜fmapâ€™ for the innermost
05:50:15 <hpc> ClaudiusMaximus: :D
05:50:42 <lars9> Twey: any example of using fmap?
05:51:03 <Twey> > map (fmap (+ 1)) [Left 1, Right 2]
05:51:04 <lambdabot>   [Left 1,Right 3]
05:51:53 <lars9> @:i fmap
05:51:53 <lambdabot> Maybe you meant: . ? @ bf bid do ft id pl rc v wn
05:52:01 <lars9> :i fmap
05:52:43 <Twey> So e.g. Right repl' -> (++) (mrBefore ++ repl') <$> subRegexRe mrAfter re repl
05:52:47 <Twey> Instead of that innermost case
05:53:02 <Twey> It's useful when you don't want to do anything if the argument is a Left
05:53:09 <elliott> Woohoo, I managed to write a Parsec parser recursive enough that it hangs.
05:53:26 <Twey> (and don't want to change from a Right to a Left in the Right branch)
05:53:28 <Darkone> I take it readNote "O shit!" something     is not proper readNote syntax? :X
05:54:25 <wlangstroth> anyone here using the redis driver? I'm at a loss as to how to use the "BS" type class, since everything I write produces ambiguous type variable errors
05:54:38 <lars9> :i (<$>)
05:54:42 <lars9> @:i (<$>)
05:54:42 <lambdabot> Maybe you meant: . ? @ bf bid do ft id pl rc v wn
05:55:01 <Darkone> Nevermind, fixed it.
05:55:08 <ClaudiusMaximus> > [ x | y <- map Just "foo" ++ [Nothing], let Just x = y ] -- this failure bit me in some code, i ended up inserting ', isJust y' which is ugly :(
05:55:10 <lambdabot>   "foo*Exception: <interactive>:1:177-186: Irrefutable pattern failed for pat...
05:55:11 <Darkone> For some reason one of my $'s got deleted :|
05:55:14 <lars9> > (<$>)
05:55:15 <lambdabot>   Overlapping instances for GHC.Show.Show ((a -> b) -> f a -> f b)
05:55:15 <lambdabot>    arising...
05:55:41 <Twey> lars9:
05:55:49 <Twey> :t (<$>)
05:55:50 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
05:55:54 <Twey> @index (<$>)
05:55:54 <lambdabot> bzzt
05:55:58 <Twey> Silly thing
05:56:01 <lars9> Twey: :i does not work?
05:56:01 <Twey> Control.Applicative
05:56:11 <Twey> It works, but it's not very useful in Î»b
05:56:15 <Twey> :i Either
05:56:22 <Twey> Well, it used to work.
05:56:26 <Twey> :-\
05:56:28 <lars9> :D
05:56:30 <Axman6> ClaudiusMaximus: use [ ... | y@(Just x) <- map ...]
05:56:52 <Axman6> actually, you want [ x | Just x <- map...]
05:56:55 <lars9> Twey: where is <$> defined?
05:56:59 <Twey> Axman6: mapMaybe
05:57:03 <Twey> 12:55:36 < Twey> Control.Applicative
05:57:09 <Twey> :t mapMaybe
05:57:10 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
05:57:12 <Axman6> :t mapMaybe
05:57:13 <lambdabot> forall a b. (a -> Maybe b) -> [a] -> [b]
05:57:21 <Twey> @index mapMaybe
05:57:21 <lambdabot> Data.Maybe
05:57:41 <Axman6> guessing it's catMaybes . map?
05:57:43 <Twey> Axman6: mapMaybe = catMaybes . map
05:57:44 <Twey> Yep
05:57:44 <ray> spoilers: it's infix fmap
05:57:50 <Axman6> heh
05:57:52 <ray> <$> that is
05:58:07 <Twey> Axman6: Well
05:58:11 <Twey> fmap catMaybes . map
05:58:17 <lars9> Twey: is Either a functor?
05:58:19 <Axman6> :t catMaybes
05:58:20 <lambdabot> forall a. [Maybe a] -> [a]
05:58:26 <Twey> lars9: Yes, if you import Control.Monad.Instances
05:59:05 <Twey> Axman6: You want to do catMaybes (map func list), not catMaybes (map func) list
05:59:17 <Twey> So you need a fmap to lift it over to the next argument
05:59:24 <Twey> Or an extra (.)
05:59:31 <Axman6> so, (catMaybes .) . map
05:59:33 <Twey> Yeah
05:59:35 <Darkone> ......
05:59:40 <Darkone> WHAT?!
05:59:43 <Axman6> i feel ashamed i can do that so easily now :(
05:59:49 <Twey> fmap is the general version of that
05:59:50 <Darkone> That's clearly not possible, computer!
05:59:54 <lars9> Twey: why fmap (+1) Left 1 returns Left 1?
05:59:55 <Twey> Plus, I don't like brackets :Ã¾
06:00:06 <Darkone> Guys, I think I have a serious problem here. Like, gremlins.
06:00:08 <ray> axman6: what a pointless skill
06:00:08 <Twey> lars9: Because that's how it's defined (but you're missing some brackets)
06:00:22 <Darkone> read is failing on "4.3605e-3"
06:00:23 <Axman6> ray: indeed, i dislike i have acquired it
06:00:24 <lars9> Twey: i didn't get clear about functors yet :(
06:00:26 <Darkone> The problem is
06:00:27 <ray> twey: NO THORNS
06:00:39 <Darkone> "4.3605e-3" DOES NOT EXIST IN THE FILE IT IS BEING FED D:
06:00:39 <Twey> lars9: The idea of the Functor instance on Either is that it applies a further transformation to the value inside a Right (a success value) but leaves a Left (an error value) alone
06:01:01 <ray> what a twist
06:01:03 <Jafet> > read "4.3605e-3" :: Double
06:01:04 <lambdabot>   4.3605e-3
06:01:05 <Axman6> lars9: the type of fmap for Either is: fmap :: (a -> b) -> Either c a -> Either c b
06:01:06 <ray> you are the demons
06:01:17 <Twey> lars9: A functor is a data type that has a value â€˜insideâ€™ it, to which you can apply a transformation
06:01:30 <Twey> ray: Life is a bed of roses ;)
06:01:55 <lars9> Twey: cool, you are more helpful that YAHT i read
06:02:10 <Axman6> Darkone: does it have 0.0043605 anywhere in it?
06:02:26 <Axman6> lars9: has LYAH been recommended to you?
06:02:26 <elliott> It appears that Parsec simply cannot handle my immense genius^W^Winsane recursion.
06:02:27 <Twey> lars9: Read RWH and/or LYAH instead
06:02:36 <Darkone> apparently now.
06:02:39 <Darkone> not**
06:02:40 <Axman6> LYAH, then RWH
06:02:43 <Saizan> Darkone: iirc your code, you keep doing read and show, so it might be the result of a previous show, rather than something from the input
06:02:48 <Twey> Reasonable
06:02:58 <Darkone> Saizan, this is the very first "read" performed
06:03:52 <ray> it is a mystery -(o.o)-
06:04:07 <elliott> ugh, i'll have to roll my own parser
06:04:07 <Jonny> Hello
06:04:44 <lars9> This tool is what i'm working on now: fordo: http://code.google.com/p/fordo/
06:05:04 <hpc> elliott: writing your own parser isn't that irritating
06:05:07 <lars9> previously i made it in shell script, now converting to haskell to improve it
06:05:11 <elliott> "fordo is a command line tool to can easily apply a command on multiple files." er, isn't this just xargs(1)?
06:05:17 <elliott> well, find(1) really
06:05:32 <lars9> not just that
06:05:48 <elliott> hpc: It is when your types are this tangled.
06:05:56 <hpc> oh, yikes
06:05:57 <Jonny> When I try to run this... http://pastebin.com/nUfYSKzH    I get an "undefined variable f" error, but I have defined f in the where clause?
06:05:59 <Darkone> ....
06:06:03 <lars9> it's neater, and with this {} you can do replace and more,
06:06:07 <Darkone> This is very very wroooonnggg o.o
06:06:34 <Axman6> Darkone: are you running the right program, are you in the correct directory?
06:06:37 <Darkone> I added a snippet to readnote to give me the array that's failing, which, in effect, gives me what line of text has failed.
06:06:39 <Darkone> Yes! D:
06:06:59 <Darkone> The line of text given does not exist
06:07:03 <lars9> elliott: for example you can use shell's for or find to to that convert photo job. much more code is needed.
06:07:04 <Darkone> In the file.
06:07:05 <Axman6> Jonny: the where clause only applies to the apply s ( x : xs ) case, not to the apply s ( x : [] ) case
06:07:23 <Jonny> oh so I have to write the where clause twice?
06:07:39 <lars9> elliott: fordo *.bmp -c convert {} {bmp/jpg}, very neat :D
06:07:43 <hpc> wait, since when does where work that way?
06:08:01 <Axman6> Jonny: yes
06:08:02 <hpc> oh, it's guards that share the same where clause
06:08:07 <Axman6> hpc: yeah
06:08:15 <hpc> subtle
06:08:31 <Axman6> Jonny: or you could use case to pattern match on the list
06:08:47 <hpc> yeah, because it's easier to compile the where when it only reads from one pattern
06:10:05 <hpc> how is "fordo" pronounced? is it like "for-do" or "frodo"?
06:10:43 <Darkone> Urk.
06:10:47 <Darkone> May have found it.
06:10:57 <wlangstroth> hmm ... okay, more general question, then: what would possess someone to write their own bytestring type class and call it "BS"?
06:10:58 <Darkone> Is "show" supposed to use scientific notation?
06:11:08 <lars9> hpc: im not sure :D
06:11:11 <hpc> wlangstroth: irony :D
06:11:17 <hpc> lars9: i vote the latter
06:12:08 <Axman6> > show 0.004605
06:12:09 <lambdabot>   "4.605e-3"
06:12:13 <Axman6> sure is
06:12:19 <Darkone> ... :|
06:12:23 <Darkone> That's... urrghhh
06:12:31 <Axman6> > read . show $ 0.004605 :: Double
06:12:32 <lambdabot>   4.605e-3
06:12:40 <Twey> I like /fÉ”ËdÉ™ÊŠ/ :Ã¾
06:12:51 <Darkone> read . show $ 0.004605
06:12:52 <Twey> wlangstroth: Demons
06:12:57 <Darkone> > read . show $ 0.004605
06:12:58 <lambdabot>   *Exception: Prelude.read: no parse
06:13:02 <lars9> now i'm add regex substitution into {bmp/jpg}, and also the increasing sequence like {#4}
06:13:03 <hpc> Twey: :D
06:13:04 <Darkone> So why does it do that?
06:13:13 <Darkone> Without the type dec I mean
06:13:14 <Axman6> > read "()"
06:13:15 <lambdabot>   ()
06:13:25 <Axman6> it defaults to reading ()
06:13:26 <hpc> :t read . show $ 0.004605
06:13:27 <lambdabot> forall a. (Read a) => a
06:13:31 <Axman6> > read "((((()))))"
06:13:32 <lambdabot>   ()
06:13:43 <wlangstroth> oh, the irony of demons
06:13:49 <lars9> in shell, it's very hard to rename a bounch of files to 1.txt, 2.txt, 3.txt...
06:13:51 <Twey> We have such flexibility in defining our units!
06:14:16 <elliott> http://hpaste.org/41057/recursive Can anyone think of a way to make this parser... less uselessly over-recursive?
06:14:18 <Darkone> Shouldn't it be able to tell that  4.605e-3 is a float/double without you explicitly stating so?
06:14:28 <elliott> As it stands it hangs on anything more complex than (parse solid "" "abc").
06:14:46 <Axman6> Darkone: no, how would it?
06:15:03 <Axman6> (+
06:15:14 <Axman6> (+) can't add two numbers unless it knows their types
06:15:58 <Darkone> So, to add the type dec, just put it at the end of the line?
06:16:14 <ClaudiusMaximus> :t showFFloat
06:16:15 <lambdabot> forall a. (RealFloat a) => Maybe Int -> a -> String -> String
06:16:16 <Axman6> sure
06:16:29 <Kaidelong> why can't I match the type returned from Data.Vector.thaw and Data.Vector.Generic.thaw?
06:16:30 <Darkone> KAy, thanks. Definitely not expected behavior :P
06:16:39 <Kaidelong> do I need to require type families in my own code or something?
06:16:44 <lars9> elliott: is parsec good for passing arguments ?
06:16:57 <ClaudiusMaximus> > showFFloat (Just 5) 0.004605 ""
06:16:58 <Jafet> data RealNum = { val :: (Num a) => a }
06:16:58 <lambdabot>   "0.00461"
06:17:02 <elliott> lars9: Uhh ... considering it's designed to parse source code and data, I find that unlikely ...
06:17:06 <Axman6> lars9: it could be used for that, i don't see why you would though
06:17:16 <elliott> *could* be, but...
06:17:41 <ClaudiusMaximus> > showFFloat (Just 5) 0.0000000004605 ""
06:17:42 <lambdabot>   "0.00000"
06:18:11 <Axman6> lars9: think of parsec more as something that you define languages with, and parse them with. short things like command line arguments wouldn't make much sense
06:18:29 <lars9> Axman6 i see thanks
06:18:33 <Darkone> Uhhmm
06:18:43 <Darkone> Arguments are already passed "parsed" really.
06:18:50 <Darkone> getArgs returns a list.
06:18:54 <Twey> Darkone: No they aren't
06:19:00 <Twey> They're tokenised, not parsed
06:19:02 <Darkone> Well, depends on what you mean by parse :/
06:19:46 <Kaidelong> requiring type families doesn't help
06:20:44 <Darkone> Woops. Not a good idea there!
06:20:45 <lars9> hey an important experience i got today is that regex-tdfa is the only useable regex lib in haskell
06:21:07 <zygoloid> lars9: for i in *.bmp; do convert $i ${i/bmp/jpg}; done
06:21:13 <Darkone> Had a think to fix turn speeds, but I forgot to convert RPS into RPM, and put the RPM number in my script :X
06:21:17 <Kaidelong> http://hpaste.org/41058/type_error_with_mutable_vector
06:21:25 <Kaidelong> can anyone tell me why this won't work?
06:21:41 <Jonny> In http://pastebin.com/krPkE3ZB    how should I write the lookup list so that the second item in each pair is a function
06:21:57 <Jonny> because if I write it like ("*",(*)) I get an error
06:22:04 <lars9> zygoloid: yeah, but it can not do regex replacement, and can not do increasing numbering etc
06:22:08 <Kaidelong> everything compiles up until shuffle itself where I get a type error
06:22:16 <Jonny> *** Expression     : [("cos",cos),("*",(*))] *** Term           : ("*",(*)) *** Type           : ([Char],a -> a -> a) *** Does not match : ([Char],(a -> a) -> a -> a) *** Because        : unification would give infinite type
06:22:41 <Axman6> :t cos
06:22:42 <lambdabot> forall a. (Floating a) => a -> a
06:22:44 <Axman6> :t (*)
06:22:45 <lambdabot> forall a. (Num a) => a -> a -> a
06:23:07 <Darkone> Oh nice.
06:23:11 <Axman6> they need to have the same type, which means they need to take the same number of arguments
06:23:24 <Darkone> I feel stupid now, I forgot to account for floating point error, and now all my ships have negative acceleration :V
06:24:07 <Saizan> Kaidelong: can you annotate with the error?
06:24:15 <Kaidelong> Saizan: okay
06:24:17 <Kaidelong> thank you
06:24:25 <Jonny> but they can never have the same number of arguments?
06:24:35 <lars9> zygoloid: and you'll need "$f" incase f has spaces
06:24:42 <Jonny> actually
06:24:45 <Jonny> forget that
06:24:54 <Jonny> Ill just use the 2 where clauses properly
06:24:56 <Jonny> thanks
06:25:06 <Saizan> Kaidelong: anyhow, i think the solution is to add a constraint like Mutable v ~ MVector (+ qualifications)
06:25:08 <Axman6> well, since when does cos take two arguments?
06:25:15 <Axman6> or multiplication only take one?
06:25:22 <Kaidelong> Saizan: I added it
06:25:27 <Kaidelong> the annotation
06:26:00 <zygoloid> lars9: not if you use zsh. and numbering can be done with $((n++)). regexps are a bit trickier (i usually use sed) and might be a compelling argument
06:27:27 <lars9> zygoloid: yeah, and i dont want to type too many in/do/;/done etc which is not what i care about: files and command.
06:29:31 <Kaidelong> Saizan: so I just put "Mutable v" in my constraints?
06:29:37 <Kaidelong> well I'll try that
06:29:40 <Kaidelong> hang on
06:32:27 <Kaidelong> wait
06:32:34 <Kaidelong> Mutable isn't a class
06:32:39 <Kaidelong> I can't do that
06:34:08 <Saizan> i said "Mutable v ~ MVector" but i was wrong anyhow
06:37:03 <Darkone> Huhm.
06:37:15 <Darkone> Haskell doesn't crash on div by 0?
06:37:26 <Darkone> MAybe floating point error was saving it :X
06:37:48 <kmc> > 1 `div` 0
06:37:49 <lambdabot>   *Exception: divide by zero
06:37:51 <kmc> > 1 / 0
06:37:52 <lambdabot>   Infinity
06:38:06 <kmc> not sure what "Haskell" does, i.e. what the spec requires
06:38:40 <kmc> but GHC allows the special case floating values (Â±âˆž, NaN)
06:39:08 <kmc> there's no such values for integer types, so you get an exception
06:39:09 <ketil> GHC follows IEEE 754 - anything else would be...less than sane, I think.
06:40:08 <Kaidelong> so nobody here has any idea how I'd make this work then?
06:40:25 <Jafet> That's what you get for "going with your heart" and doing numerical analysis instead of an MBA
06:41:16 <Darkone> Haha, that's where I was getting the problem.
06:41:23 <DeFrag> Hi people. Wandering what is the most elegant way to express a cross product of three-dimensional vectors in Haskell. Any ideas?
06:42:13 <Jafet> DeFrag: uh, there's an inelegant way?
06:42:45 <burp> maybe DeFrag wants to see something fancy :D
06:42:54 <sipa> first of all, how are your vectors represented?
06:43:19 <DeFrag> Jafet: I find this one http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg11763.html looking awful.
06:43:31 <Jafet> Now if the question was an elegant seven dimensional cross product, it might be more interesting
06:43:40 <scree> cross a b = [sum [epsilon i j k * (a !! j) * (b !! k) | j <- [1..3], k <- [1..3]] | i <- [1..3]]
06:43:48 <DeFrag> burp: Yep, point-free solution would be fancy to see.
06:44:00 <scree> then just define epsilon in terms of signs of permutations in a generic way
06:44:53 <Saizan> Kaidelong: this typecheck, not exactly sure if it's how the library is intended to be used though http://hpaste.org/41060/works?pid=41060&lang_41060=Haskell
06:45:06 <scree> presumably you'll have to do cycle finding or something
06:45:12 <elliott> What's the simplest way to check if a list has any duplicates?
06:45:27 <Axman6> xs == nub xs
06:45:29 <elliott> Or, specifically, return all the duplicates in a list.
06:45:34 <Kaidelong> Saizan: I suppose I'll have to look at MonadSplit then
06:45:37 <elliott> Which is rather less trivial :)
06:45:43 <Axman6> indeed
06:45:44 <EvanR-work> nub xs \ xs
06:45:50 <EvanR-work> hmm no
06:45:52 <Jafet> DeFrag: it merely looks like the author had a putrid hate of pattern matching
06:45:55 <sipa> first sort it, probably
06:46:29 <scree> fmap head . filter (\l -> case l of [] -> False; [_] -> False; _ -> True) . group . sort
06:46:47 <Jafet> Oh, the author uses Array. Array makes everything look ugly, so there.
06:47:16 <Kaidelong> Saizan: hmm I still end up needing a monad transformer if I'm trying to return a random modification?
06:47:16 <elliott> xs \\ nubBy (...) xs *almost* works.
06:47:57 <scree> elliott: do you care about time complexity?
06:48:01 <Jafet> > (head.) . filter ((>1).length) . group . sort $ [1,2,3,2,2,4,2,3]
06:48:02 <lambdabot>   [2,3]
06:48:11 <EvanR-work> is there Array slice?
06:48:21 <EvanR-work> like matlab
06:48:37 <elliott> scree: Yes. Yes I do :)
06:48:46 * Jafet slices quiche
06:49:00 <scree> elliott: in that case nub is probably bad, as it's n^2
06:49:35 <Saizan> Kaidelong: yeah, though maybe you want to use some other random source/mechanism, like mwc-random, if you care about performance
06:49:43 <Jafet> So is (\\), incidentally
06:49:52 <EvanR-work> elliott you want the simplest way that is sublinear? ;)
06:49:59 <Jafet> Wait no, neither have to be quadratic.
06:50:06 <ClaudiusMaximus> > ceil $ 0/0
06:50:07 <lambdabot>   Not in scope: `ceil'
06:50:13 <elliott> Heh, I almost give up. :)
06:50:13 <ClaudiusMaximus> > ceiling $ 0/0
06:50:14 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
06:50:14 <EvanR-work> :t ceiling
06:50:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
06:50:23 <ClaudiusMaximus> that one smells
06:50:25 <scree> Jafet: with only equality they do surely
06:50:35 <EvanR-work> ClaudiusMaximus: floating point is a hack
06:50:39 <Jafet> :t nub
06:50:40 <lambdabot> forall a. (Eq a) => [a] -> [a]
06:50:42 <ClaudiusMaximus> EvanR-work: yes!
06:50:53 <Jafet> Oh well, shannon no cry.
06:51:02 <Jafet> @quote and.beyond
06:51:03 <lambdabot> identity says: "To " ++ (show $ log (2^1024)) ++ " and beyond!"
06:51:51 <benmachine> http://hackage.haskell.org/packages/archive/http-enumerator/0.2.0.3/logs/failure/ghc-6.12 ouch - the network version increase should *really* have been a major
06:53:19 <Kaidelong> Saizan: thanks. It actually seems to me that MonadRandom could potentially be made an instance of PrimMonad
06:53:43 <EvanR-work> classes can be instances?
06:54:00 <Kaidelong> err
06:54:05 <Kaidelong> sorry
06:54:08 <Kaidelong> RandT Int
06:54:14 <Kaidelong> err
06:54:23 <Kaidelong> wait I suppose not
06:54:45 <EvanR-work> Random is a cool monad
06:54:52 <benmachine> sigh I would notice this the day after I unsubscribed from -cafe wouldn't I
06:55:06 <lars9> is functor like container?
06:55:19 <Kaidelong> I seem to have run into its limitations when trying to shuffle a vector
06:55:33 <EvanR-work> @src Functor
06:55:34 <lambdabot> class  Functor f  where
06:55:34 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
06:55:44 <Kaidelong> lars9: basically. The idea is that a functor is anything for which a function a -> b can be turned into one F a -> F b
06:56:37 <EvanR-work> anything F where (a -> b) -> (F a -> F b)
06:56:48 <lars9> Kaidelong: so Maybe, Either, List are functors?
06:57:00 <EvanR-work> @instances Functor
06:57:01 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:57:37 <EvanR-work> lars9: basically any tree-like data can be a functor in an obvious way
06:57:46 <EvanR-work> but thats not required
06:58:41 <lars9> EvanR-work: so containers are functors, like Data.Set, Data.Map etc?
06:58:57 <Kaidelong> yes
06:58:59 <benmachine> lars9: Data.Set in fact is not a Functor
06:59:01 <Kaidelong> well
06:59:05 <Kaidelong> there is a problem with Set
06:59:10 <Kaidelong> due to its internal representation
06:59:16 <Kaidelong> and map by extension
06:59:29 <benmachine> lars9: the key thing about fmap is that the function you lift into the functor must be from *any* type to *any* other
06:59:56 <benmachine> lars9: but Set only makes sense containing types that can be tested for equality (and in fact is implemented using ordering)
07:00:32 <benmachine> lars9: so I can't fmap putStr on a Set String and get a Set (IO ()) because the latter doesn't make sense
07:00:38 <lars9> benmachine: oh, yeah, Eq is required for Set, Map
07:00:46 <benmachine> lars9: Map actually doesn't require Eq
07:00:54 <Kaidelong> Map requires it on its keys
07:00:58 <benmachine> it does for the keys (actually Ord) but that's ok because you fmap over the value
07:01:01 <benmachine> s
07:01:15 <Kaidelong> hmm, oh I see what you are saying
07:01:19 <kmc> Functor is a lot more general than what is usually meant by "container"
07:01:20 <lars9> for List, fmap is identical to map?
07:01:21 <benmachine> so you have instance (Ord k) => Map k where
07:01:22 <kmc> yes
07:01:23 <benmachine> and it's fine
07:01:25 <Kaidelong> Map k is a functor
07:01:33 <benmachine> eeer
07:01:39 <kmc> a functor need not have a concrete representation as zero or more values, which is how we think of a container
07:01:40 <benmachine> so you have instance (Ord k) => Functor (Map k) where
07:01:43 <benmachine> there we go
07:02:27 <benmachine> data Tagged a = Tagged -- is a functor but doesn't contain anything
07:02:44 <kmc> if F is a functor, then Â«F tÂ» could be represented as a collection of several 't' values (list, Maybe), or a function producing 't' values (((->) r), State, Reader, etc.), or a "recipe" for doing IO and producing a 't' value, or something else entirely
07:03:26 <Kaidelong> anyway the easiest explanation is just to say that a functor allows you to lift abritary functions into functions on the functor
07:03:42 <Kaidelong> arbitary
07:03:48 <EvanR-work> obituary
07:03:51 <EvanR-work> oops
07:04:18 <EvanR-work> arbitrary! ;)
07:04:55 <lars9> i think i'm starting to understand functor now :D
07:05:13 <EvanR-work> its like the simplest class
07:05:50 <kmc> simpler than Show? ;)
07:05:52 <Kaidelong> why does shuffling a mutable array have to be so difficult?
07:06:05 <EvanR-work> is there an identity class
07:06:16 <lars9> :t Show
07:06:17 <lambdabot> Not in scope: data constructor `Show'
07:06:22 <lars9> :t show
07:06:23 <lambdabot> forall a. (Show a) => a -> String
07:06:26 <kmc> @src Show
07:06:26 <lambdabot> class  Show a  where
07:06:27 <lambdabot>     showsPrec :: Int -> a -> ShowS
07:06:27 <lambdabot>     show      :: a   -> String
07:06:27 <lambdabot>     showList  :: [a] -> ShowS
07:06:29 <EvanR-work> Kaidelong: fischer yates right
07:06:55 <zygoloid> i'd agree that Functor is simpler than Show, fwiw
07:07:05 <kmc> because it's more parametric?
07:07:09 <lars9> :k Int
07:07:10 <lambdabot> *
07:07:33 <lars9> :k Either
07:07:34 <lambdabot> * -> * -> *
07:07:41 <zygoloid> because of the precedence handling and ugly special-case list handling in Show.
07:07:46 <kmc> true
07:07:49 <Kaidelong> EvanR-work: I think?
07:08:12 <EvanR-work> fischer yates is pretty easy
07:08:13 <kmc> fmap is a higher-order function, which is considered an omg so advanced topic in most programming education, but probably shouldn't be
07:08:23 <Kaidelong> the idea I had was to swap the first element with a random one from a higher index, then the second, then the third etc
07:08:35 <lars9> :k *
07:08:36 <lambdabot> parse error on input `*'
07:08:40 <Kaidelong> but short of putting everything in IO I can't figure out how to do it
07:08:53 <EvanR-work> thats may or may not be fisher yates, and if you do one particular thing in that algorithm wrong, it wont be a uniformly distributed shuffle
07:09:23 <shapr> Good Morning #haskell!
07:09:25 <EvanR-work> i.e. dont swap with anything to the left of the write head
07:09:31 <EvanR-work> as you move right
07:09:36 <Kaidelong> yeah, that's the idea I had
07:09:38 <Jafet> Using crummy random number generation is probably orders of magnitudes worse than an off-by-one indexing error.
07:09:46 <EvanR-work> http://en.wikipedia.org/wiki/Fisherâ€“Yates_shuffle
07:09:48 <Jafet> Why not use ST, then?
07:10:00 <EvanR-work> Jafet: i wasnt talking about off by 1 indexing errors
07:10:12 <Jafet> Well, Kaidelong was
07:10:18 <EvanR-work> oh
07:10:19 <Kaidelong> Was I?
07:10:20 <Jafet> <Kaidelong> swap the first element with a random one from a higher index
07:10:34 <Kaidelong> oh
07:10:36 <Kaidelong> or equal
07:10:41 <Kaidelong> you can just leave it where it is
07:10:56 <Kaidelong> but never swap with something of a lower index
07:11:02 <EvanR-work> so you either invented FY or got it from somewhere without the trademark ;)
07:11:13 <EvanR-work> why are you having trouble?
07:11:14 <Kaidelong> Well it's not a hard algorithm
07:11:33 <Kaidelong> EvanR-work: probably because I want to use MonadRandom rather than the normal RNG
07:11:45 <Kaidelong> but I suppose I will give up on that and pass around a seed in ST
07:11:54 <EvanR-work> pass around a seed?
07:12:01 <EvanR-work> you mean pass around the generator state
07:12:01 <Kaidelong> as part of the state, yes
07:12:18 <EvanR-work> seed once
07:12:28 <Kaidelong> I have never actually used ST so it'll be new
07:12:41 <zygoloid> fisherYatesShuffle [] = return []; fisherYatesShuffle xs = do (x,xs) <- removeRandomElement xs; xs' <- fisherYatesShuffle xs; return (x:xs') ?
07:13:01 <EvanR-work> there you go, use the Random monad
07:13:18 <Kaidelong> zygoloid: what I have in mind won't make sense on lists
07:13:31 <Kaidelong> well it would but you'd essentially just be turning it into an array
07:14:00 <EvanR-work> it shouldnt be hard to just do it on an array. but what im wondering is how you are using mutable arrays without IO
07:14:08 <zygoloid> Kaidelong: probably a good idea; that code was quadratic-time :)
07:14:15 <EvanR-work> DiffArray?
07:14:19 <Kaidelong> Well hopefully with ST so that I can use Data.Vector.Generic.modify
07:14:28 <EvanR-work> ah ST
07:15:06 <EvanR-work> so you can write a pure function Array -> Generator -> Array
07:15:18 <EvanR-work> hmm return the new generator 
07:15:26 <EvanR-work> so you can write a pure function Array -> Generator -> (Array,Generator)
07:16:21 <Kaidelong> EvanR-work: it's quite possible that I want RandT and my main problem is that I'm not quite getting how to do the equivalent of >>= for monad transformers
07:16:53 <EvanR-work> transformers are too much for this in my opinion
07:16:59 <EvanR-work> a single monad or bust
07:17:14 <Kaidelong> okay, so then I guess I'll not use the random monad here?
07:17:22 <Kaidelong> that should make things simpler to reason about
07:17:52 <EvanR-work> you should do the transformer anyway to at least get how to use them
07:17:59 <Kaidelong> it could be wrapped into MonadRandom later by giving it a random starting state
07:18:26 <EvanR-work> but IO or ST can be used to just update the generator as you iterate
07:18:39 <EvanR-work> or fix
07:18:59 <Kaidelong> oh
07:19:03 <EvanR-work> IO or ST for mutation ;)
07:19:25 <Kaidelong> RWH says that a monad transformer becomes a monad if it has its first type argument
07:19:39 <Kaidelong> so I can just string up RandT m g a with >>= and be done with it?
07:20:11 <EvanR-work> yes
07:20:28 <Kaidelong> err
07:20:28 <Kaidelong> RandT g m a
07:20:28 <Kaidelong> hmm
07:20:36 <Kaidelong> okay, wlel that should make things a bit easier
07:20:36 <EvanR-work> common one is ReaderT S IO a
07:20:52 <EvanR-work> which can use ask and asks (and local), and to use IO you need liftIO
07:21:21 <EvanR-work> :t liftIO
07:21:22 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
07:21:34 <EvanR-work> IO a -> ReaderT S IO a
07:22:18 <Kaidelong> oh I see, that's what Saizon did here, hence the MonadRandom (t m) context
07:22:22 <EvanR-work> sometimes you dont need to lift anything because the inner monad is an instance of the outer one, ones methods lift for you
07:22:33 <EvanR-work> s/ones/whose/
07:22:56 <EvanR-work> its a funny system :(
07:23:35 <EvanR-work> Kaidelong: the classes are basically so you dont need to lift
07:33:36 <ketil> Using cmdArgs, is it possible to have optional file arguments?  I.e.  allow "foo --format=outputfile input" as well as "foo --format input > outputfile"?
07:33:55 <ketil> My guess would be not, but I've been surprised by cmdargs before...
07:38:10 * sm would guess yes, but doesn't know
07:43:21 * dom96 would guess yes too
07:46:15 <endojelly> simple question: 'data Foo Int String'. I can call the Int and String value which I have to supply the 'arguments' of the constructor. but when I'm presented with a Foo, can I also call it its 'data'? or is that uncommon?
07:46:46 <endojelly> I somehow don't want to say argument when I'm not actually applying a constructor
07:47:21 <endojelly> err
07:47:28 <endojelly> data Foo = Foo Int String
07:47:28 <Lemmih> What?
07:48:18 <endojelly> it's only about terminology
07:48:53 <endojelly> I want to say something like 'it contains the following data'
07:49:01 <Lemmih> I sometimes call them fields. Or data fields.
07:49:24 <endojelly> field is common? I thought that's maybe only really for records
07:50:31 <endojelly> well I'll start out with 'data' and see if my advisor likes it.
07:56:14 <endojelly> Comment column set to 37
07:56:45 <zygoloid> Engines to warp factor 12
07:56:46 <endojelly> just accidentally learned how to set comment columns in emacs, while trying to expand an abbrev. neat.
07:57:20 <ketil> sm: I can specify '&= opt <default-value>'.  nice!
07:57:43 <roconnor> does the concept of an initial applicative functor make any sense?
07:57:52 <endojelly> zygoloid, that's stupid. warp just goes up to 10, and that's infinite speed!
07:59:14 <zygoloid> endojelly: as i recall, the final episode of TNG ends with future Riker ordering the ship to warp factor 12
07:59:28 <thefeds> functional languages are better than procedural langs right?
07:59:39 <thefeds> can you verify a functional lang?
07:59:40 <roconnor> thefeds: you bet
07:59:47 <merijn> thefeds: In the same way knives are better then forks, yes.
07:59:51 <roconnor> thefeds: it's much easier
07:59:54 <zygoloid> thefeds: depends what you want to do. fortunately, haskell is both
08:00:25 <thefeds> isn't it a pain in the ass doing recursion for loops?
08:00:44 <zygoloid> thefeds: you don't have to use recursion for loops.
08:00:45 <zygoloid> @type forM
08:00:46 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
08:01:06 <zygoloid> many control structures can be implemented as first-class citizens
08:01:31 <thefeds> What's a first-class citizen?
08:01:34 <Jafet> @hoogle callCC
08:01:34 <lambdabot> Control.Monad.Cont.Class callCC :: MonadCont m => ((a -> m b) -> m a) -> m a
08:01:50 <roconnor> thefeds: control structures can be passed as parameters to functions
08:01:55 <EvanR-work> thefeds: procedural is a loaded paradigm
08:02:05 <thefeds> loaded paradigm?
08:02:07 <thefeds> ??
08:02:14 <EvanR-work> alternatively its marketting hype for spore
08:02:28 <EvanR-work> procedural is not the antethsis of functional, oop, or anything else
08:02:36 <endojelly> zygoloid, according to wikipedia, it has been established in TNG that "In the half-open interval from warp 9 to warp 10, the exponent of w increases toward infinity. Thus, in the Okuda scale, warp velocities approach warp 10 asymptotically.", and warp 13 was apparently in an 'alternative timeline'
08:02:41 <endojelly> zygoloid, whatever...
08:03:03 <EvanR-work> careful or ill pull out my TNG technical manual
08:03:10 <endojelly> :D
08:03:15 <thefeds> I just heard that you can prove a functional program is correct.
08:03:20 <EvanR-work> or all 3 of them since i somehow accumulated multiple copies
08:03:22 <thefeds> Can you automatically prove it?
08:03:30 <EvanR-work> in some languages
08:03:31 <thefeds> Or you have to manually construct proofs?
08:03:34 <zygoloid> thefeds: not in general; that's not computable for any turing-complete language.
08:03:42 <endojelly> thefeds, not if the language is turing complete, you can't. otherwise, yes, of course
08:03:58 <thefeds> Is Hasle;; turing complete?
08:04:00 <thefeds> Haskell
08:04:07 <Ke> =oP
08:04:24 <zygoloid> however, you can write programs where the source code carries a proof of something, and you can get a lot done in languages which aren't turing-complete.
08:04:34 <endojelly> thefeds, there's Agda for example, a functional language that looks very much like Haskell but that uses dependent types. you can prove parts or the whole program with internal logic (as part of your data types) or external logic
08:04:34 <zygoloid> thefeds: yes, haskell is turing-complete.
08:04:38 <Jafet> @vixen hey baby, I'm Turing-hard.
08:04:38 <lambdabot> hello
08:05:08 <thefeds> Then why use functional languages if it offers no more proof of correctness over procedural langauges?
08:05:26 <zygoloid> thefeds: why eat bananas if they offer no more protection from lightning strikes than apples?
08:05:28 <SubStack> aesthetics
08:05:49 <roconnor> thefeds: it is usually easier to prove correctness in functional languages
08:06:05 <thefeds> How do you prove correctness?
08:06:09 <roconnor> thefeds: a type system is actually a simple proof langauge, so we prove simple properties all the time
08:06:11 <zygoloid> thefeds: also, functional languages versus procedural languages is a false dichotomy
08:06:11 <endojelly> thefeds, there are tons of reasons. one may be that it may still be easier to prove a program written in a function language correct (provided that it's decideable).
08:06:47 <roconnor> thefeds: with a dependent type system (such as Agda, Coq, Epigram) you can state and prove arbitrary propositions about functions using the types system.
08:06:56 <zygoloid> thefeds: functional versus procedural versus whatever-else is a property of code, not really of a language (though some languages make one style easier than another)
08:07:11 <Jafet> Functional languages verses functional languages is a false dichotomy
08:07:13 <roconnor> GADTs in GHC provide Haskell with a weak dependent type system.
08:07:25 <thefeds> Does anyone actually bother writing proofs about their programs in Haskell?
08:07:26 <zygoloid> Jafet: haha :)
08:07:30 <Jafet> (And a weak dynamic type system...)
08:07:34 <merijn> This seems time to bring out the old truism
08:07:46 <roconnor> thefeds: I belive the Xmonad people proved that their stack manager was correct.
08:07:58 <thefeds> So only one part?
08:07:59 <merijn> Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
08:08:32 <roconnor> thefeds: better than no parts.  Proving correctness is very hard at the moment.  I typically estimate it is 10x harder to prove code correct than to write the code.
08:08:32 <thefeds> Why should I use Haskell over X language?
08:08:53 <zygoloid> thefeds: you shouldn't, if you don't want to :)
08:09:04 <roconnor> thefeds: the type system allows you to establish moderately complex invariants about your code.
08:09:05 <merijn> roconnor: Not to mention, the fact that code my be correct to a given spec, but who says the spec is correct?
08:09:09 <Zao> merijn: With the corrolary: "Java more than the others"
08:09:18 <merijn> s/my/may/
08:09:31 <zygoloid> thefeds: but you might find it an interesting experience to learn another way of thinking about programming (even if you ultimately go back to your favourite procedural language)
08:10:08 <roconnor> merijn: well, usually you eventually notice when you try to integrate the code into another system and try to make further deductions.
08:10:17 <thefeds> !tutorial]
08:10:29 <EvanR-work> merijn: that taxonomy is the most accurate assessment i have heard so far
08:10:46 <thefeds> I know guards
08:10:54 <thefeds> and if
08:11:04 <EvanR-work> i dont use guards and if much
08:11:13 <merijn> EvanR-work: Like many wise words I stole it from someone in #python :p
08:11:19 <EvanR-work> nice
08:11:23 <EvanR-work> (explains a few things)
08:11:35 <merijn> My theory is that not learning type theory leaves them plenty of hours of Zen like meditation
08:12:14 <zygoloid> thefeds: reasons that some people prefer Haskell over X: strong, static, inferred types, with a very rich and powerful type system. laziness-by-default. enforced purity (with explicit side-effects). clean, simple syntax. clean, simple denotational semantics.
08:12:40 <merijn> zygoloid: I just like it because it makes me look smart >.>
08:12:50 <EvanR-work> merijn: kind of like theology vs science? ;)
08:13:03 <Jafet> Haskell is my favourite nine-iron.
08:13:10 <zygoloid> merijn: hehe :) it's certainly an interesting thing to put on a CV.
08:13:30 <merijn> I'm hoping to become a super genius by hanging around here via learning through osmosis
08:13:41 <EvanR-work> e-osmosis
08:13:57 <dRbiG> hehe
08:14:05 <dRbiG> :)
08:14:24 <thefeds> http://www.willamette.edu/~fruehr/logos/PNGs/HaskellLogo.png
08:14:24 <merijn> That sentence is not grammatically incorrect, my semantics are just to deep to be contained by the pitiful English grammar...
08:15:38 <EvanR-work> merijn: i advocate fully ad-hoc polymorphic parts of speech
08:15:45 <merijn> On unrelated note, Haskell's type families are based on "inductive families"?
08:16:06 <roconnor> oh ya, denotational semantics is a good reason to use haskell
08:17:36 <Twey> merijn: ko se jbobau ;)
08:19:05 <_Matt_J_W_> hey guys, could someone shed some light on the precednece rules regarding funcitons in Haskell, please?
08:19:57 <merijn> _Matt_J_W_: I'm betting the terms haskell and fixity should turn up a better explanation then I can give
08:20:24 <alej> _Matt_J_W_: what's the problem you're having
08:20:38 <Twey> _Matt_J_W_: They're infixl 9 by default.  You can define them as you want.
08:20:56 <_Matt_J_W_> Not a problem as such. I'm just curious as to the way the compiler processes the syntax
08:21:07 <zygoloid> _Matt_J_W_: one way of thinking about it is: there are 10 levels of precedence, with 10 being the highest (binds first) and 0 being the lowest (binds last). level 10 is function application, and is not available for anything else. precedence levels for standard operators are listed here: http://control.monad.st/haskell/operator-precedences/
08:21:08 <_Matt_J_W_> precedence, associativity ...
08:21:24 <Twey> Oh, I thought you were talking about using them infix.
08:21:38 <zygoloid> *11 levels ;)
08:21:48 <alej> Twey, `f` is infixl 9?
08:21:54 <Twey> alej: Yes
08:22:02 <zygoloid> in the haskell standard, there are 10 levels from 0 to 9 with function application being treated as a separate thing.
08:22:41 <_Matt_J_W_> does it go from left to right, or the other way?
08:22:49 <alej> function application is left associative
08:23:12 <zygoloid> when a function is used infix, the associativity can be specified by the programmer using infixl or infixr
08:23:25 <_Matt_J_W_> ah
08:23:35 <_Matt_J_W_> that explains the strange results I was getting earlier :)
08:25:01 <thefeds> http://c2.com/cgi/wiki?FunctionalWeenie
08:26:24 <_Matt_J_W_> If you had two functions, times and plus, if applied `times 3 plus 1 2' then the compiler would start complaining
08:27:00 <_Matt_J_W_> and it's understandable. I'd like to know how it goes about processing `2`times`1`plus`4'.
08:29:54 <fryguybob> > let times = (*) in let plus = (+) in 1 `plus` 2 `times` 5
08:29:55 <lambdabot>   15
08:29:59 <fryguybob> > 1 + 2 * 5
08:29:59 <lambdabot>   11
08:32:06 <roconnor> @free (a -> b) -> (f a -> f b)
08:32:06 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
08:32:13 <roconnor> @free (a -> b) -> (a -> b)
08:32:13 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
08:32:27 <roconnor> @free (id :: (a -> b) -> (a -> b))
08:32:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
08:32:34 <roconnor> @free id
08:32:35 <lambdabot> f . id = id . f
08:32:57 <roconnor> @type fmap
08:32:58 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:33:04 <roconnor> @free fmap
08:33:05 <lambdabot> Expected variable or '.'
08:34:04 <j3ssi> hi
08:35:10 <j3ssi> can someone help with a haskell problem ?
08:36:05 <Ke> just ask
08:36:35 <haskellElephant> ask away j3ssi!
08:37:38 <lars9> what's the meaning of Just 3 <*> Just 5
08:37:55 <roconnor> lars9: that is effectively a type eror
08:38:44 <zygoloid> lars9: f <$> Just 3 <*> Just 5  is  (f <$> Just 3) <*> Just 5
08:39:03 <lars9> how is (\x y z -> [x,y,z]) <$> (+3) ?
08:40:17 <lars9> roconnor: zygoloid oh yeah Just 3 <*> Just 5 is error...
08:40:36 <zygoloid> lars9: that's using <$> (that is, fmap) from the ((->) r) Functor
08:40:45 <zygoloid> which means that, in this case, (<$>) = (.)
08:41:13 <zygoloid> so that's (\x y z -> [x,y,z]) . (+3) == \w y z -> [w+3,y,z]
08:42:10 <j3ssi> I need a function which searches if the pairs (a,b) and (b,a) are both in a list which is defined as [(a,[a])] 
08:42:12 <lars9> zygoloid: i see thanks
08:44:48 <j3ssi> can someone just give me an idea what instructions are appropriate for this task
08:45:39 <zygoloid> j3ssi: the question has a type error in it.
08:46:16 <zygoloid> if you have a list of (a,[a]), then you can't have both (a,b) and (b,a) in that list, since that would imply that the type a and [a] are the same, which haskell doesn't allow
08:46:58 <roconnor> j3ssi: is this a graph theory problem?
08:47:13 <j3ssi> yes it s a graph theory problem
08:47:48 <j3ssi> it is the question if the graph is coherent
08:49:08 <roconnor> zygoloid: j3ssi wants to know if the (y,x) is "in" a list of type [(a,[a])] whenever (x,y) is "in" the list.
08:51:07 <zygoloid> j3ssi: ok, let's restate your problem as follows: you want to consider the pairs (a,b) such that (a,bs) is within your list, where b is in bs, and you want to check whether, for each such pair, (b,a) is also in that list.
08:51:33 <j3ssi> yes thats my problem
08:52:19 <zygoloid> ok. well, one approach might be to build the set of such (a,b) pairs, flip each pair to make a set of (b,a) pairs and check whether they're the same set.
08:53:02 <zygoloid> that'd require a (<) on your type a. you can also do it requiring only an (==), but it'll be slower
08:55:01 <j3ssi> my problem is not how to approach the problem but the functions that can be usefull .... i began to learn Haskell a week ago
08:55:18 <nus> @hoogle member
08:55:18 <lambdabot> Data.IntMap member :: Key -> IntMap a -> Bool
08:55:18 <lambdabot> Data.IntSet member :: Int -> IntSet -> Bool
08:55:18 <lambdabot> Data.Map member :: Ord k => k -> Map k a -> Bool
08:55:43 <lars9> how is (,,,) defined, each length is defined indipendedly?
08:55:48 <opqdonut> yes
08:56:46 <lars9> isn't it kind of repeating?
08:57:24 <Cale> > let g = [(1,[2,5]),(2,[1,3,4]),(3,[2,4]),(4,[2,3,5]),(5,[1,4])] in [(x,y) | (x,ys) <- g, y <- ys]
08:57:25 <lambdabot>   [(1,2),(1,5),(2,1),(2,3),(2,4),(3,2),(3,4),(4,2),(4,3),(4,5),(5,1),(5,4)]
08:57:28 <lars9>  A 129-tuple is too large for GHC
08:57:28 <lars9>       (max size is 62)
08:57:34 <zygoloid> j3ssi: you might want to look into the Data.Set module. the rest you can do with list comprehensions.
08:57:40 <Cale> j3ssi: ^^
08:57:56 <Cale> That might be a useful first step
08:58:14 <zygoloid> j3ssi: you might also want to look at sort, concat and map
08:58:18 <EvanR-work> lars9: if you want an unlimited list of something, use a list
08:58:25 <EvanR-work> not a tuple
08:58:52 <EvanR-work> ive never used triple
08:58:58 <joell> Hello, everyone.  Have any of you ever encountered difficulty with GHCi failing to locate DLLs on Windows?
08:59:00 <j3ssi> Thank fpor your help
08:59:44 <joell> Specifically, I have a foo.dll in a directory c:\temp\test and when I run "ghci -lfoo -Ltest" from c:\temp, GHCi fails to locate foo.dll.
09:00:00 <joell> However, if I were to run "ghci -lfoo" within c:\temp\test, it has no difficulty loading it.
09:00:08 <joell> Does this problem sound familiar to anyone?
09:02:48 <nus> joell, why would it search in subdirectories for something to link?
09:03:33 <lars9> liftA2 (,) [1..5] [2..4]
09:04:02 <joell> This is a simplified version of a larger problem I have building a project.  The project includes Haskell code and C code which ultimately must be linked.
09:05:32 <joell> Because the C library (also part of the project) isn't already installed when I'm building or debugging the project, I need to link to it in its non-standard location.
09:05:44 <joell> Hence the attempt at using the "-L" switch.
09:06:20 <joell> What confuses me is that the output from GHCi, seems to indicate that it looks in c:\temp\test, but somehow doesn't see the DLL.  c.f.,
09:06:23 <joell> C:\temp>ghci -lfoo -Ltest GHCi, version 6.12.3: http://www.haskell.org/ghc/  :? for help Loading package ghc-prim ... linking ... done. Loading package integer-gmp ... linking ... done. Loading package base ... linking ... done. Loading package ffi-1.0 ... linking ... done. : foo: The specified module could not be found. Loading object (dynamic) foo ... failed. <command line>: user specified .o/.so/.DLL could not be loaded (addDLL: c
09:06:42 <lars9> how to add guard to lifeA2 (*) [1..10] [2..8] to remove those ones >= 50? like [x*y | x<-[1..10], y<-[2..8], x*y < 50]
09:06:48 <nus> joell,  -L<absolutepath>
09:07:22 <nus> joell, GHC User's Guide 2.6
09:07:41 <nus> joell, 2.6.2 "Extra Libraries"
09:08:20 <joell> nus, the absolute path doesn't seem to help.  See: http://hpaste.org/41064/ghci_link_problem
09:09:14 <stepkut> where equality constaints, ~, added in 6.12? or 6.10?
09:10:26 <stepkut> s/where/were/
09:10:51 <pumpkin> probably 6.10
09:11:00 <pumpkin> maybe even 6.8 but I wasn't around for that
09:19:03 <shapr> Good Morning Again #haskell! How's code treating everybody?
09:19:16 <dnm> Hey shapr. =]
09:20:47 <shapr> y0 dnm! Long time no see! How you doin? Writing some Haskell?
09:20:49 <stepkut> shapr: swell!
09:21:09 <shapr> stepkut: y0 y0, what's up with the consonant change?
09:21:36 <stepkut> shapr: irc does not support sign-on from multiple locations :p
09:21:39 <shapr> ah, right.
09:21:47 <EvanR-work> cool
09:22:06 <merijn> Sure it does, it's called server + screen/tmux + irssi :>
09:22:20 <dnm> shapr: Likewise! I'm doing OK, how about you? No serious Haskell lately beyond little experiments, toys, and ideas, but I keep my toes in the water, as usual.
09:22:25 * stepkut waits for someone on haskell-cafe to suggest replacing #haskell with a jabber server
09:22:27 <EvanR-work> just started a survey running on php and mysql, and the number of respondents responding to email has our server at load average 20 and the site is abysmally slow ;)
09:22:33 <EvanR-work> sucks
09:22:44 <shapr> stepkut: I've often wanted to try that actually. lambdabot supported xmpp at one point.
09:22:50 <EvanR-work> we are not web scale
09:23:07 <shapr> EvanR-work: Considered trying snap or yesod instead?
09:23:09 <stepkut> shapr: I added xmpp support to lambdabot at one time
09:23:13 <shapr> with the latest HaskellDB?
09:23:18 <joell> Does anyone know what specific filenames GHCi would look for trying to find the "foo" library when executed as "ghci -lfoo -Ltest"?  It claims to be looking in "test", and "foo.dll" exists in "test", but it's not finding it.
09:23:19 <stepkut> shapr: or happstack !! :(
09:23:31 <shapr> oh right, happstack!
09:23:32 <joell> (Trying with an absolute path for -L doesn't seem to change anything.  See: http://hpaste.org/41064/ghci_link_problem )
09:23:39 * stepkut shuns shapr
09:23:41 <EvanR-work> personally i run my own hobby dynamic site on haskell and it seems good
09:23:48 <shapr> D-8
09:23:50 <EvanR-work> rewriting the entire thing in haskell is unlikely ;)
09:23:56 <Kaidelong> I just caught myself using >>= instead of filter
09:24:00 <EvanR-work> for the next project
09:24:05 <EvanR-work> dunno ;)
09:24:17 <Kaidelong> that's not good I don't think
09:25:13 <Kaidelong> while writing pseudocode for "intersect"
09:25:35 <Kaidelong> (assignment wanting a brute force solution as opposed to a smarter one)
09:28:34 <nus> joell, hmm.. try "-lc:\temp\test\foo" ?
09:29:03 <joell> OK.  That works.
09:29:14 <nus> meh, that's a bug
09:29:21 <joell> I'm not sure it will solve my original problem, though.
09:29:41 <nus> joell, are you using Cabal?
09:29:52 <joell> Yes
09:30:14 <joell> The actual system this is for involves cabal, linking in a C lib built separately, and it's getting hung up when Template Haskell code is interpreted during the compilation phase.
09:31:06 <joell> (Which is ironic, since linking that lib isn't really necessary at that point; it only really needs to be done during the final link that generates the executable.)
09:32:54 <Darkone> How can I force show to print a value without scientific notation?
09:33:44 <joell> Darkone: Are you trying to generate a string from a floating-point type of some kind, then?
09:34:09 <Darkone> Yes.
09:34:29 <Darkone> Show prints it as 5.2xxxxxe-2 for example
09:34:41 <Darkone> Which causes X3TC to throw a wobbly :P
09:34:46 <joell> Darkone: I'm not sure you could alter the format of output you'd get from "show" for a given type, but have you considered using Text.Printf?
09:35:20 <joell> Darkone: That would give you a bit more control over the format of your output, and "printf" can be used to generate either a String or genuine output to standard IO.
09:36:31 <joell> nus: Thanks for the help.  I'm gonna see if I can get things working with the "-l" hack and then file a bug report.
09:36:47 <Silvah> What's the best Haskell tutorial for an absolute beginner?
09:36:49 <EvanR-work> shapr: haskelldb has drivers for real databases
09:36:53 <EvanR-work> or is its own database
09:38:22 <joell> Silvah: Well, some people are fond of "Learn You a Haskell" (http://learnyouahaskell.com/) which is a rather light-hearted approach.  I suppose it would depend really on what you're looking for.
09:38:23 <shapr> EvanR-work: drivers for databases as far as I know. But now that you mention it, it would be awesome to have a backend for the happsdb.
09:38:42 <EvanR-work> so that would not solve the mysql problem ;)
09:38:54 <EvanR-work> happsdb is web scale?
09:39:11 <merijn> Silvah: I second Learn You a Haskell as a good intro
09:39:12 <alip> I'm writing haskell-ffi bindings to a C library and I'm looking for the best way to represent "struct in_addr" .. right now I call inet_ntop() on the address and return a String which I think is not optimal
09:39:27 <stepkut> EvanR-work: happstack-state is web scale ;)
09:39:42 <merijn> There's also Real World Haskell, which is good for more advanced topics such as networking, etc but not as pleasant for the beginner topics imo
09:40:01 <joell> Silvah: A longer, but pretty comprehensive approach is "Real World Haskell" (http://book.realworldhaskell.org/).  If you have a bit more time, I'd recommend that one.
09:40:19 <Silvah> Well, maybe I'm not an absolute beginner - I wrote several things in Haskell long ago, I just forget some things, that is, almost everything.
09:40:43 <nus> joell, please file it... It isn't fixed in the darcs head too, addDLL just fires Win32 API's LoadLibrary with whatever you specify to '-l'
09:40:45 <joell> Silvah: Ah, in that case there is one that serves as a pretty good quick refresher.
09:41:12 <joell> nus, so it doesn't even look at the '-L' argument?  GHCi at least claims to in its output.
09:41:46 <joell> nus, could you link me to the source for addDLL if it's online somewhere?  I wouldn't mind taking a bit of a deeper look before I file the bug report, just so I can give them a better start.
09:41:48 <nus> joell, it does look at '-l'. it *doesn't* look @ '-L'
09:41:52 <EvanR-work> stepkut: whats that
09:42:06 <nus> http://darcs.haskell.org/ghc-7.0/ghc/rts/Linker.c
09:42:15 <joell> Silvah: I recall a rather nice tutorial for rapid-learning / refresher.  Give me a sec to hunt it down.
09:42:27 <joell> nus: Thanks. :)
09:42:43 <joell> Silvah: 
09:42:50 <joell> Silvah: "A Gentle Introduction to Haskell" (http://www.haskell.org/tutorial/)
09:43:02 <stepkut> EvanR-work: an in-memory database system that supports native haskell datatypes with queries written in Haskell. But still retaining the ACID properties.
09:43:23 <joell> It's really anything but gentle, but works great for people who already know a bunch of programming languages and some of the familiar idioms and just want to get the quick facts.
09:43:37 <EvanR-work> stepkut: ok but what about disk?
09:43:46 <stepkut> EvanR-work: disk is sloooooow
09:44:39 <stepkut> http://glinden.blogspot.com/2009/11/put-that-database-in-memory.html
09:45:21 <Silvah> joell: Thanks, I'll take a look.
09:45:26 <EvanR-work> stepkut: i know
09:45:29 <Darkone> > printF "%.7f\n" 0.000056
09:45:30 <lambdabot>   Not in scope: `printF'
09:45:32 <EvanR-work> but how do you keep a database in memory
09:45:48 <EvanR-work> thats the scale part
09:45:51 <joell> @hoogle printf
09:45:51 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
09:45:51 <lambdabot> module Text.Printf
09:45:51 <lambdabot> Text.Printf class PrintfArg a
09:46:06 <joell> Darkone: "printf" is all lower-case.
09:46:12 <stepkut> EvanR-work: I am not sure what your question is.. keeping it in memory is the easy part
09:46:25 <EvanR-work> but i have 4.001 gigs of data
09:46:43 <stepkut> EvanR-work: so? My desktop machine has 10GB of RAM
09:46:47 <EvanR-work> thats nice
09:47:16 <stepkut> well, you can have fast or you can have cheap..
09:47:37 <EvanR-work> you cant sit there and say its obvious how this would work when there are obvious reasons why not, i guess i just have to go somewhere and read about it
09:48:01 <stepkut> I am not clear on which aspect you think will not work?
09:48:28 <EvanR-work> server crash
09:48:31 <Darkone> > printf "%.7f\n" 0.000056
09:48:32 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:48:32 <lambdabot>    `Text.Printf.PrintfType ...
09:48:35 <EvanR-work> data gone
09:48:49 <EvanR-work> 9 months with no single bit errors
09:48:50 <Darkone> > printf "%.7f\n" (0.000056 :: Float)
09:48:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
09:48:51 <lambdabot>    `GHC.Show.Show a'
09:48:51 <lambdabot>      a...
09:48:52 <EvanR-work> unlikely
09:48:56 <Darkone> I'm clueless :(
09:49:04 <stepkut> EvanR-work: happstack-state has write-ahead logging, so all updates are logged to disk and can be recovered after a crash
09:49:06 <joell> > printf "%.7f\n" 0.000056 :: String
09:49:07 <lambdabot>   "0.0000560\n"
09:49:26 <joell> Darkone: printf uses a bunch of "magic" to let you interpret its output in different ways.
09:50:03 <joell> Darkone: As a result, sometimes you need to provide a type ascription so the compiler knows what to do with it.
09:50:05 <Silvah> Everything in Haskell uses magic ;)
09:50:35 <EvanR-work> stepkut: what about replication
09:51:23 <stepkut> EvanR-work: there is some support for replication in the code base now. Happstack 7 is going to focus a lot on replication and sharding.
09:51:24 * shapr replicates EvanR-work to another server with rsync
09:51:37 <conal> Silvah: the best kind of magic: well-defined, user-accessible magic!
09:52:35 <merijn> Depending on your definition of user-accessible :p
09:52:45 * hackagebot cgi 3001.1.8.2 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.8.2 (AndersKaseorg)
09:53:39 <merijn> If something requires some funky ununderstandable type theory voodoo I wouldn't call it accessible no matter how easy it is to actually do :p
09:54:10 <EvanR-work> Simplify[ununderstandable] -> derstandable
09:54:26 <EvanR-work> new word: invented
09:55:04 <Silvah> :D
09:56:02 <therp> can anyone think of a nicer way of writing this:
09:56:03 <therp> @pl (\x -> if x == "" then "" else init x) 
09:56:04 <lambdabot> ap (flip if' [] . ([] ==)) init
09:57:20 <therp> I am using init to shorten a string when hitting backspace, and therefore I need a version of init that doesn't bottom on ""
09:57:44 <conal> merijn: i bet you could get pointers here for learning type theory voodoo.
09:57:46 * hackagebot crypto-api 0.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.2 (ThomasDuBuisson)
09:58:51 <shapr> EvanR-work: So, what do you think about happstack-state and in-memory databases?
09:58:53 <Silvah> Even if you understand it, it's still voodoo.
10:01:45 <EvanR-work> shapr: sounds good in principle
10:02:02 <EvanR-work> housing of database data isnt something easy to sell people
10:02:09 <conal> Silvah: yep.  powerful!
10:02:25 <shapr> EvanR-work: What do you mean?
10:03:00 <merijn> conal: Yeah, I've managed to struggle my way up to the extended calculus of constructions with extensive bugging of people here. Type theorists unfortunately seem to have nothing better to do then think up new terms/symbols every other paper leaving me in a twisty maze of terms and symbols all alike :p
10:03:01 <EvanR-work> i would not be able to walk into a meeting and tell them we are switching to happstack-state
10:03:06 <Silvah> conal: yeah. And ugly.
10:03:37 <conal> Silvah: good luck.  you might find the inner beauty yet.
10:03:47 <shapr> EvanR-work: Technical merit and meeting persuasiveness are rarely connected, in my experience.
10:04:06 <shapr> EvanR-work: I tend to tell people that I know how to make things cost less and go faster.
10:04:13 <stepkut> EvanR-work: not yet. When 7 is released, hopefully
10:05:04 <Silvah> brb
10:07:57 <EvanR-work> shapr: yes i do that too, when i know im right ;)
10:08:34 <EvanR-work> my database experience in haskell so far, limited to hdbc-mysql has been not the greatest
10:09:03 <EvanR-work> it would be adequate if there wasnt a bug that tries to allocate 4GB when reading a huge blob column
10:09:35 <EvanR-work> so my expectation is that there will be other things like that in other systems
10:09:40 <shapr> EvanR-work: So, set up a testing suite for it?
10:09:43 <EvanR-work> some fixable by me, some not
10:09:53 <merijn> I know what the turnstile symbol "|-" means, but what does "||-" mean?
10:09:54 <EvanR-work> yes id need some investigation
10:10:16 <shapr> EvanR-work: Go for it! It would be especially valuable if you write up your goals, approach and results!
10:10:28 <EvanR-work> shapr: on the other hand you dont set up a testing suite for mysql ;)
10:10:37 <EvanR-work> everyone knows it works, and doesnt, as the case my be
10:10:44 <shapr> huh?
10:10:50 * hackagebot wai-handler-devel 0.1.1 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-0.1.1 (MichaelSnoyman)
10:10:58 <EvanR-work> you dont have to evaluate the working-ness of mysql
10:11:03 <EvanR-work> its industry standard
10:11:21 <shapr> Er, I think you and I may define standards differently.
10:12:26 <merijn> The fact that MySQL can be considered an industry standard makes me sad and depressed about the industry :\
10:12:34 <EvanR-work> yes
10:12:57 <shapr> I would totally setup a testing suite for MySQL if I wanted to evaluate its effectiveness for a particular application. I would do that with several different SQL databases, if I had determined I needed a SQL db.
10:13:34 <EvanR-work> sounds smart
10:14:18 <shapr> So, if you want to find out stuff about happstack-state, try it out!
10:15:42 <shapr> Personally, I'm convinced that the in-memory database approach is superior, and that the language-native db is also superior (LINQ is a good example).
10:16:22 <EvanR-work> did i already ask this, what about interoperability with haskell databases and crap systems like php
10:16:24 <Saizan> merijn: more or less the same thing usually, but at a different level, e.g. maybe the former is used for the algorithmic rules and the other for the simpler ones that specify the semantics
10:17:19 <shapr> For most LAMP stacks, the database chunk is used for both transactional safety and state management, at the cost of expensive marshalling in and out of the language used to do formatting.
10:17:25 <conal> iirc, "||-" vs "|-" is about truth vs provability
10:17:36 <shapr> EvanR-work: Try it out, come back and tell us what you find.
10:17:53 <conal> (provability in a given formal system)
10:17:53 <EvanR-work> i mean, is SQL involved at any level
10:17:53 * shapr hugs stepkut
10:17:57 <Saizan> conal: yeah, a more concise phrasing :)
10:18:14 <merijn> WolframAlpha claims it's to be read as "forces" (I wonder why it never occurred to me before to use WolframAlpha to find the meaning of symbols)
10:18:34 <EvanR-work> shapr: is happs state relational?
10:18:37 <merijn> Which makes sense in this context
10:18:42 <conal> merijn: oh, good idea.
10:19:31 <jmcarthur> EvanR-work: not inherently
10:19:44 <jmcarthur> EvanR-work: it's whatever you make it
10:19:48 * stepkut purrs
10:19:49 <EvanR-work> hm
10:19:52 <merijn> conal: Only downside seems to be is that while WolframAlpha supports LaTeX codes (which I can find via detexify!) it doesn't seem to really discriminate between capitalization of \vDash and \Vdash.
10:20:03 <jmcarthur> EvanR-work: you could certainly make a relational database with it, but that's not its only purpose
10:20:07 <conal> merijn: oops
10:20:24 <EvanR-work> jmcarthur: im guessing that it would be efficient at relational operations?
10:20:37 <EvanR-work> or does that depend on my ingenuity at writing a driver
10:20:50 <jmcarthur> EvanR-work: IxSet has a few ways to make that pretty handy
10:21:06 <jmcarthur> EvanR-work: i'm not going to claim it will be super efficient for relational operations
10:21:31 <jmcarthur> EvanR-work: it of course has that requirement that everything fit into memory
10:21:36 <notabel> merijn: do you have access to a copy of mathematica? the documentation enumerates its latex compatibility codes, and also gives the Mathematica-preferred form for everything
10:22:03 <notabel> (WolframAlpha speaks a superset of Mathematica, basically)
10:22:07 <jmcarthur> EvanR-work: really though, the idea is that you shouldn't worry about whether your model is relational
10:22:27 <jmcarthur> EvanR-work: happstack-state is intended to mold to whatever shape your algorithms demand :)
10:22:58 <jmcarthur> you just make a data structure like you would if it was intended to just stay in memory only, then you add some serialization boilerplate
10:22:58 <merijn> notabel: Yeah, don't have much experience with using it though. I'll keep that in mind for the future
10:23:26 <jmcarthur> well, you have to clearly define what operations to serialize
10:23:38 <jmcarthur> but i'd just call that good abstraction anyway
10:31:13 <EvanR-work> jmcarthur: i do like normalized databases, i dont necessarily like sql
10:31:29 <EvanR-work> i do like the option to store a more expressive data value
10:31:35 <EvanR-work> which mysql doesnt have
10:31:40 <shapr> EvanR-work: So, go try it :-P
10:32:04 <EvanR-work> actually right now the php code is falling apart critically
10:32:11 <EvanR-work> no one wants to hear my opinion
10:32:13 <stepcut> industry norms are pretty bogus. If everyone in the industry was using Haskell for web development, could you really go into your bosses office and say, "Hey, I think we should use this PHP language for our mission critical website. It's interpreted and has no type safety, and makes it really easy to forget to escape strings, doesn't support multicore, etc"
10:32:40 <Twey> stepcut: Probably, yes
10:32:48 <bremner> php supports botnets for distributed computing
10:33:02 <Twey> PHB don't know nuttin'.
10:33:02 <stepcut> bremner: true :)
10:33:13 <shapr> jmcarthur: You think you'll be at the knitting & type theory meeting tonight? I wanted to ask you some questions about pre-processing Asterisk source in order to stuff it into Language.C.
10:33:30 <EvanR-work> stepcut: that list of horribly incomplete
10:33:32 <shapr> Or perhaps I should hit Google a bit harder...
10:33:34 <EvanR-work> that list is*
10:33:45 <Twey> Hehehe, knitting & type-theory meeting
10:34:03 <shapr> Twey: Hey, it'll be fun! Last week we did both knitting and Haskell teaching.
10:34:13 <Twey> Whereabouts is this?
10:34:24 <shapr> Huntsville, Alabama at the Maker's Local 256 hackerspace.
10:34:24 <stepcut> EvanR-work: and yet, Haskell is the hard sell, not PHP :)
10:34:27 <Twey> Ah.
10:34:32 <Twey> Wrong continent.  :Ã¾
10:34:39 <EvanR-work> stepcut: well ill figure it out
10:34:59 <EvanR-work> if i have enough technical facts, business has no chance against me
10:35:21 <EvanR-work> but the minute i leave they wont be able to hire a replacement
10:35:42 <dnm> shapr: What's new with you? Where are you these days?
10:35:53 <shapr> EvanR-work: What about http://www.haskell.org/haskellwiki/Consultants ?
10:36:13 <zopa> Hi all--a question. I'm trying to do some stuff with Data.Time.Calendar (the time-1.1.4 library). Am I crazy, or is Day not an instance of Read, despite various documentation claiming otherwise? 
10:36:24 <zopa> It's very, very possible that I'm crazy.
10:36:25 <shapr> dnm: I'm in Huntsville, AL. Doing tech support at Digium at the moment, while I finish my degree. For fun, I'm learning knitting and electronics, and C & C++ for school.
10:36:36 <dnm> Nice.
10:36:49 <dnm> What did you end up doing with the Cell blade server?
10:36:59 <EvanR-work> shapr: likely they cant afford it
10:37:25 <shapr> dnm: It's gathering dust in my room. I have almost enough spare funding to crank it up at the hackerspace, probably next month I'll have it running.
10:37:33 <jmcarthur> shapr: dunno if i will be there. maybe
10:37:43 <stepcut> EvanR-work: that is  one of the aims of haskellers.com.. to create a place for business to find haskell developers. Or at least believe it is possible if they need to..
10:37:50 <jmcarthur> shapr: i really can't tell you much about Language.C though
10:37:56 <EvanR-work> ah
10:38:12 <Twey> zopa: I don't see an instance.
10:38:36 <Twey> Ah
10:38:39 <Twey> zopa: It's in Data.Time.Format
10:41:24 <shapr> jmcarthur: according to Aaron Tomb, I just need to throw a bunch of pre-processed C into Language.C, and it'll work.
10:42:06 * hackagebot monadcryptorandom 0.1 - A monad for using CryptoRandomGen  http://hackage.haskell.org/package/monadcryptorandom-0.1 (ThomasDuBuisson)
10:42:33 * shapr tries to pre-process the Asterisk codebase
10:42:51 <identity_> @src and
10:42:51 <lambdabot> and   =  foldr (&&) True
10:43:19 <identity_> @qc
10:43:20 <lambdabot> Not enough privileges
10:43:22 <roconnor> how do I prove stuff about parametric functions with class constraints?
10:43:31 <identity_> How does one quickcheck with lambdabot?
10:43:41 <roconnor> @check 1 + 1 = 2
10:43:41 <lambdabot>   Parse error at "=" (column 7)
10:43:44 <roconnor> @check 1 + 1 == 2
10:43:45 <lambdabot>   "OK, passed 500 tests."
10:43:51 <identity_> thanks
10:44:03 <dolio> roconnor: Add all the class functions as arguments.
10:44:18 <roconnor> dolio: okay
10:44:33 <dolio> There may be a better way, I guess.
10:45:00 <Cale> bos, dons: I like the tagline for the Japanese version of RWH :)
10:45:07 * hackagebot DRBG 0.1.0 - A deterministic random bit generator (aka RNG, PRNG) implementing DRBGs from NIST SP 800-90  http://hackage.haskell.org/package/DRBG-0.1.0 (ThomasDuBuisson)
10:45:12 <roconnor> how do I proof things about parametric stuff with higher rank polymorphism and parametric type constructor
10:46:44 <jmcarthur> shapr: yeah that's basically my understanding
10:47:14 * therp wonders why "(s -> s) -> StateT s ()" is absent.
10:47:43 <dolio> roconnor: I'm pretty sure Wadler's paper covers stuff like that.
10:47:51 <zopa> Twey: using Data.Time.Format works great.  Thanks!
10:47:59 <Cale> therp: In what library?
10:48:00 <roconnor> @hoogle modify
10:48:00 <lambdabot> Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
10:48:00 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
10:48:00 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
10:48:08 <roconnor> therp: ^^
10:48:10 <Cale> therp: That's usually called modify
10:48:41 <roconnor> ok
10:48:44 <roconnor> dolio: ok
10:48:55 <therp> cale & roconnor: thanks! hoogling this type signature wasn't successfully. #haskell++!
10:48:56 <dolio> Certainly higher-rank stuff.
10:49:14 <dolio> Or if not Wadler's paper, other papers on the subject.
10:49:47 <dolio> Actually, maybe Wadler's paper would be more likely to have stuff about type constructors.
10:49:57 <dolio> Since he proves things about one or two list functions.
10:53:41 <roconnor> dolio: the thing is that I'm trying to proof stuff that isn't parametric in types, rather it is parameteric in the functor.
10:54:51 <dolio> So, you need an interpretation of higher kinds.
10:56:08 <dolio> I don't know if I've seen that.
10:56:32 <dolio> However, there is a paper on parametricity in dependent type theories, and they have rules for arbitrary pis and such.
10:57:00 <dolio> Which should get you * -> * by specialization.
10:57:06 <dolio> I don't remember if there are caveats.
10:57:48 <companion_cube> are kinds just some sort of types for types ?
10:58:01 <merijn> companion_cube: Yes
10:58:25 * companion_cube wonders if something like system-F exists, with 3 levels instead of 2
10:58:49 <merijn> companion_cube: Extended Calculus of Constructions goes up to infinite levels
10:59:02 <merijn> But I need to run :>
10:59:27 <companion_cube> yeah, 3 does not make sense, just go to infinite 
10:59:41 <companion_cube> good run
11:01:00 <dolio> In the lambda cube, there's values, types, kinds, and then a single sort [] that classifies all kinds.
11:01:34 <dolio> There's also System U, which has a triangle above the box.
11:02:03 <dolio> Although it doesn't have rules that would allow you to form types like [] -> [].
11:02:10 <companion_cube> nice :)
11:02:14 <EvanR-work> we would need dedicated ram machines to store all this data
11:02:22 <companion_cube> if you need [] -> [], better directly use CIC
11:02:39 <EvanR-work> thats going to cost
11:02:48 <dolio> It has things like [] -> *, though, I think.
11:02:59 <dolio> ([] -> *) : []
11:03:25 <dolio> Anyhow, system U is an illustration of how impredicativity can lead to paradox.
11:03:57 <exDM69> what's the difference between mapM and mapM_?
11:04:06 <exDM69> hlint is suggesting me to replace mapM with mapM_
11:04:24 <Cobra_> exDM69: mapM_ discards the results
11:05:00 <exDM69> Cobra_: thanks
11:06:49 * tommd releases DRBG, monadcryptorandom, and crypto-api
11:11:11 <dons> good work, tomh 
11:11:13 <dons> tommd: 
11:15:52 <tab> tommd: great !
11:16:46 * tab wonders if DRBG could becomes the standard haskell CPRNG
11:19:37 <tommd> tab: I'd think people would gravitate toward an AES based CPRNG, but if not then the Hash DRBG gives good performance (and the performance doesn't measurably change when you reseed a Hash DRBG with the HMAC DRBG every 32kB).
11:21:48 <c_wraith> tommd, does the interface allow reseeding the DRBG transparently, or does it require a different call?
11:22:44 <c_wraith> tommd, I guess my question is "what layers of the NIST-recommended architecture does it expose?"
11:23:17 <c_wraith> :t strength
11:23:18 <lambdabot> Not in scope: `strength'
11:24:01 <tab> tommd: ok
11:24:57 <c_wraith> @hoogle a -> m b
11:24:58 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
11:24:58 <lambdabot> Control.Monad.Reader runReaderT :: ReaderT r m a -> r -> m a
11:24:58 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:33:30 <roconnor> @seen edwardk
11:33:30 <lambdabot> Unknown command, try @list
11:33:30 <preflex>  edwardk was last seen on #haskell 2 days, 14 hours, 29 minutes and 57 seconds ago, saying: overlappinginstances lack a type family equivalent, data families let you do all sorts of things
11:34:58 <dolio> I could have sworn he was in here last night.
11:37:02 <tommd> c_wraith: It exposes instantiate, generate, and reseed functions.
11:37:43 <c_wraith> So..  due to the impurity inherent in the NIST design, you didn't really map it directly into haskell?
11:37:49 <tommd> cwraith: I have build compositions of generators (ex: GenAutoReseed, GenXor) that will use two generators in some manner (auto-reseed one generator with another, auto combine generators using xor)
11:38:07 <tommd> c_wraith: impurity?  I think we are talking past each other.
11:38:13 <tommd> There is nothing impure here.
11:38:52 <c_wraith> tommd, I'm talking about the NIST design, as specified in whatever FIPS document.  It has inherent impurity in its design, as it talks about automatic reseeding from external sources in the generate function in certain cases.
11:39:03 <tommd> You instantiate a generator with some seed.  You generate bytestrings (and a new generator) using an existing generator.  You can reseed a generator using input entropy (a bytestring).
11:39:41 <tommd> c_wraith: No, I do not implement automatic reseeding in that manner.  The closest you can do is "g :: GenAutoReseed HashDRBG SystemRandomDRBG"
11:40:20 <tommd> c_wraith: I included a "SystemRandomDRBG" not that it's part of the NIST document but just because I knew some people would want it.
11:48:54 <nus> preflex, @seen edwardk_
11:48:54 <preflex>  edwardk_ was last seen on #haskell 74 days, 5 hours, 23 minutes and 19 seconds ago, saying: * edwardk_ waves hello.
11:51:49 <jmcarthur> preflex: @seen edwardk
11:51:49 <preflex>  edwardk was last seen on #haskell 2 days, 14 hours, 48 minutes and 16 seconds ago, saying: overlappinginstances lack a type family equivalent, data families let you do all sorts of things
11:51:55 <jmcarthur> preflex: @seen ekmett
11:51:55 <preflex>  ekmett was last seen on #haskell 299 days, 1 hour, 6 minutes and 21 seconds ago, saying: jmcarthur: accident =)
11:53:13 <tommd> cwraite: If you're really interested then see SP 800-90 and look at section 10.1.1 and 10.1.2.  Those are pure (and more or less what I implemented)
11:53:57 <tommd> c_wraith: ^^
11:55:10 <c_wraith> yeah, I just remember going over the fips document early this year, and noting that while the primitives were pure, the required packaging for them wasn't.
12:00:32 <EvanR-work> whats the easiest way to get a sha1 hash in haskell
12:01:04 <Twey> EvanR-work: Data.Digest.SHA1?
12:01:23 <Twey> I think you're not supposed to use SHA1 now, though
12:01:26 <Twey> Wasn't it broken?
12:01:33 <tab> EvanR-work: cabal install cryptohash :)
12:01:39 <endojelly> yeah, use SHA-256 for example
12:01:45 <EvanR-work> not practically but it means there could be other weaknesses
12:02:30 <EvanR-work> Word160 eh
12:02:33 <tab> sha1 is fine for some usage
12:03:03 <kw317> kosmikus: Ping
12:03:04 <tab> and if you got a choice of hashes, just use something better than sha256
12:03:11 <chrisdone> Î»> :i Functor
12:03:11 <chrisdone> class Functor f where
12:03:11 <chrisdone>   fmap :: (a -> b) -> f a -> f b
12:03:11 <chrisdone>   (<$) :: a -> f b -> f a
12:03:12 <preflex>  chrisdone: you have 2 new messages. '/msg preflex messages' to read them.
12:03:14 <chrisdone>   	-- Defined in GHC.Base
12:03:18 <chrisdone> when did (<$) happen?
12:03:19 <tab> sha256 is the next in line to be broken :)
12:03:23 <endojelly> heheh
12:03:26 <EvanR-work> whats the best?
12:03:28 <EvanR-work> ;)
12:03:41 <tab> personally i really like skein
12:03:48 <endojelly> EvanR-work, the best is, and this is just a guess, mind you, probably some AES based thing with too many bits.
12:03:49 <tab> it's a sha3 candidate
12:03:56 <roconnor> okay, I wrote down on the whiteboard something that at least resembles a free theorem for my type.
12:04:00 <roconnor> dolio: okay, I wrote down on the whiteboard something that at least resembles a free theorem for my type.
12:04:12 <EvanR-work> AES? i thought that was suspect as well
12:04:21 <dolio> Okay.
12:04:30 <endojelly> EvanR-work, it is?
12:05:05 <chrisdone> heh, I found a funny log of someone WTF'ing at map being renamed to fmap: http://www.mail-archive.com/glasgow-haskell-bugs@haskell.org/msg01849.html
12:06:10 <chrisdone> seriously, when did (<$) come in?
12:06:23 <roconnor> dolio: if I have some arbitrary functor F that i know nothing about, can I create a natural function between it and the identity functor in some way?
12:06:33 <roconnor> *natural transformation
12:07:31 <conal> roconnor: iiuc, equivalent to asking whether you can always define a g :: F a -> a
12:07:43 <conal> (forall a. ...)
12:07:45 <roconnor> or a -> F a
12:07:49 * roconnor sighs
12:07:58 <dolio> I doubt it.
12:08:16 <roconnor> conal: thanks for clairfying the category theory
12:08:22 <EvanR-work> endojelly: guess i made it up
12:08:23 <conal> which sounds pretty unlikely. :(
12:08:33 <roconnor> that's fine
12:08:51 <stepkut> GHC 7 says I need to enable IncoherentInstances (but 6.12 does not). But it only lists one matching instance >:(
12:09:15 <roconnor> my free theorem quantifies over natural transformations.  I'm trying to find a useful instance.
12:09:24 <tehgeekmeister> what's a nice way to express (in haskell) only doing a computation if neither of a pair are nothing, and otherwise performing a different calculation on whichever is a just, or returning nothing?
12:10:14 <sproingie> probably easiest as a pattern match
12:10:19 <roconnor> foo (Just a) (Just b) = f a b
12:10:19 <dolio> roconnor: What's your type?
12:10:39 <sproingie> followed by foo _ _ = Nothing
12:10:51 <sproingie> or whatever is appropriate for f
12:10:51 <tehgeekmeister> (in concrete terms, the function compares two justs and returns the max, otherwise returns the one just, otherwise returns nothing.)
12:10:57 <sproingie> (mempty perhaps)
12:11:10 <EvanR-work> foo (Just a) Nothing = g a
12:11:16 <EvanR-work> foo Nothing (Just b) = h b
12:11:18 <sproingie> > liftM2 max (Just 3) (Just 5)
12:11:19 <lambdabot>   Just 5
12:11:29 <tehgeekmeister> ah, so i'll want an auxiliary function for this
12:11:30 <tehgeekmeister> okay
12:11:31 <roconnor> dolio: it is actually twanvl's type.  I have an object Lens of type forall f:Functor, (B -> f B) -> (A -> F A)
12:11:32 <tehgeekmeister> that makes it cleaner
12:11:52 <EvanR-work> dont be afraid to write new functions, there are plenty to go around
12:12:06 <tehgeekmeister> yeah, i just didn't think of it
12:12:17 <tehgeekmeister> and i didn't like the idea of nesting case statements
12:12:37 <EvanR-work> you can make it more generic by passing f g and h in
12:12:38 <sproingie> > liftM2 ++ (Just "hi") Nothing
12:12:39 <roconnor> dolio: I believe the free theorem says that forall n : forall x, F1 x -> F2 x where n is a natural transformation, then forall h1 : B -> F1 B, n . (Lens h1) = Lens (n . h1)
12:12:39 <lambdabot>   Couldn't match expected type `t
12:12:39 <lambdabot>                                -> (a1 -> a2...
12:12:46 <EvanR-work> like maybe and either
12:12:48 <Saizan> if we had a Max monoid we you could just use \x y -> fmap unMax $ mappend (fmap Max x) (fmap Max y)
12:13:03 <sproingie> i guess liftM2 isn't quite it.  back to pattern match
12:13:16 <Twey> >.>
12:13:43 <sproingie> oh duh
12:13:49 <roconnor> > liftM2 (++) (Just "hi") Nothing
12:13:49 <sproingie> > liftM2 (++) (Just "hi") Nothing
12:13:50 <lambdabot>   Nothing
12:13:50 <lambdabot>   Nothing
12:14:13 <sproingie> i gotta quit sniffing the cheap glue
12:14:17 <Twey> Haha
12:14:45 <tehgeekmeister> @hoogle liftM2
12:14:45 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:15:05 <tehgeekmeister> ah!
12:15:06 <tehgeekmeister> yes.
12:15:09 <tehgeekmeister> in the maybe monad.
12:15:11 <tehgeekmeister> that's what i want.
12:15:18 <Twey> > liftM2 mappend `flip` Nothing $ Just "hi"
12:15:19 <lambdabot>   Nothing
12:15:22 <Twey> \o/
12:15:30 <Saizan> but "liftM2 max (Just x) Nothing == Nothing", is that what you want?
12:15:50 <tehgeekmeister> > liftM2 (>) (Just 1) Nothing
12:15:51 <lambdabot>   Nothing
12:15:57 <tehgeekmeister> oh, no, that's not quite what i want.
12:16:14 <tehgeekmeister> pattern matching it is!
12:16:18 <Saizan> i guess you can add `mplus` return x `mplus` return y
12:16:38 <sproingie> tehgeekmeister: you wanted max, right?  just lift max
12:16:47 <sproingie> > liftM2 max (Just 10) (Just 5)
12:16:48 <lambdabot>   Just 10
12:17:02 <tehgeekmeister> > liftM2 max (Just 10) Nothing
12:17:04 <lambdabot>   Nothing
12:17:06 <Twey> > -0 / 0
12:17:07 <lambdabot>   NaN
12:17:10 <tehgeekmeister> nope, i need it to return 10 then.
12:17:17 <Twey> > 5 / 0
12:17:18 <lambdabot>   Infinity
12:17:25 <sproingie> oh.  then you're probably looking for a pattern match
12:17:26 <Twey> > negate $ 5 / 0
12:17:26 <tehgeekmeister> i need the max if they both exist, whichever does exist otherwise
12:17:27 <lambdabot>   -Infinity
12:17:32 <tehgeekmeister> and nothing if they both don't exist
12:17:33 <Twey> > -Infinity
12:17:34 <lambdabot>   Not in scope: data constructor `Infinity'
12:17:37 <roconnor> tehgeekmeister: perhaps this will help you: http://hackage.haskell.org/packages/archive/monoids/0.1.31/doc/html/Data-Ring-Semi-Tropical.html
12:17:41 <Twey> It is irritating that I can't construct this
12:17:54 <sproingie> > (Just 1) `mplus` (Just 2)
12:17:55 <lambdabot>   Just 1
12:18:00 <roconnor> newtype Tropical a 	Source
12:18:01 <roconnor> The SemiRing (min,+) over a extended with infinity. When a has a Num instance with an addition that respects order, then this is transformed into a tropical semiring. It is assumed that 0 is the least element of a. 
12:18:21 <twanvl> > let mplusWith f (Just a) (Just b) = Just (f a b); mplusWith f Nothing b = b; mplusWith f a Nothing = a in mplusWith max (Just 10) Nothing
12:18:22 <lambdabot>   Just 10
12:18:58 <twanvl> this function should be in Data.Maybe (but isn't)
12:18:58 <sproingie> > (\f a b -> liftM2 f (a `mplus` b) (b `mplus` a)) max (Just 2) (Just 3)
12:18:59 <lambdabot>   Just 3
12:19:04 <sproingie> > (\f a b -> liftM2 f (a `mplus` b) (b `mplus` a)) max (Just 5) (Just 3)
12:19:05 <lambdabot>   Just 5
12:19:09 <sproingie> > (\f a b -> liftM2 f (a `mplus` b) (b `mplus` a)) max (Just 5) Nothing
12:19:10 <lambdabot>   Just 5
12:19:23 <sproingie> @pl \f a b -> liftM2 f (a `mplus` b) (b `mplus` a)
12:19:23 <lambdabot> (`ap` flip mplus) . (ap .) . (. mplus) . (.) . liftM2
12:19:32 <sproingie> ... i'd take the lambda
12:19:56 <Twey> I'm sure there's a nicer way to write that
12:20:01 <Twey>  @pl usually gives hideous output
12:20:17 * tehgeekmeister uses pattern matching
12:20:44 <Twey> Hmm
12:21:01 <sproingie> frankly i can't think of many general uses for that function tho.  i think defining it with pattern matches would be a lot clearer
12:21:42 <tehgeekmeister> @hoogle maxBy
12:21:42 <lambdabot> No results found
12:21:52 <Twey> :t join . join
12:21:53 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m (m a)) -> m a
12:22:21 <roconnor> @free const
12:22:22 <lambdabot> f . const x = const (f x) . g
12:23:41 <twanvl> I think mplusWith should be added to the libraries, I needed this exact same function today as well
12:24:08 <twanvl> it is very similar to Data.Map.unionWith
12:24:17 <twanvl> maybe there is some type class hiding here
12:25:00 <roconnor> dolio, conal: const b is a natural transformation from the Id functor to the (Const b) functor, right?
12:25:33 <twanvl> intersectionWith ~= liftA2, unionWith ~= ??, differenceWith ~= ??
12:25:46 <tehgeekmeister> > sort [5,6,7]
12:25:47 <lambdabot>   [5,6,7]
12:25:51 <tehgeekmeister> right, that's what i thought.
12:26:10 <tehgeekmeister> > sortBy (<) [5,6]
12:26:11 <lambdabot>   Couldn't match expected type `GHC.Ordering.Ordering'
12:26:11 <lambdabot>         against inferr...
12:26:18 <conal> roconnor: maybe Const b . unId
12:26:24 <twanvl> > sortBy (flip compare) [1,2,3]
12:26:25 <lambdabot>   [3,2,1]
12:26:30 <tehgeekmeister> oh right
12:26:35 <roconnor> conal: ya, modolo wrapping and unwrapping
12:27:12 <conal> yeah
12:27:36 <Twey> Hm
12:27:59 <Twey> sproingie: I've got: flip id (flip mplus) . flip id mplus . liftM2 . liftM2 . liftM2
12:28:04 <Twey> But I feel there must be a nicer way :-\
12:28:20 <Twey> I guess sections
12:28:29 <sproingie> badger . badger . badger . badger . badger . badger . badger . badger $ mushroom . mushroom
12:28:39 <Twey> ($ flip mplus) . ($ mplus)  . liftM2  . liftM2 . liftM2
12:28:44 <Twey> sproingie: Hehe
12:29:32 <sipa> @unpl badger . badger . badger . badger . badger . badger . badger . badger $ mushroom . mushroom
12:29:32 <lambdabot> (badger (badger (badger (badger (badger (badger (badger (badger (\ z -> mushroom (mushroom z))))))))))
12:30:36 <Twey> Well, it's at least a lot nicer than the @pl version.
12:30:46 <sproingie> there should be a genetic algorithm using @pl and @unpl that apply random transforms of the code and user feedback on what looks the prettiest as a fitness function
12:30:54 <Twey> I suspect I can't make it any nicer because it will unify the type of those liftM2's.  I always run into that :-\
12:35:55 <tehgeekmeister> i wish i could follow these threads
12:35:57 <tehgeekmeister> =/
12:37:16 * hackagebot diagrams 0.2.2 - An EDSL for creating simple diagrams  http://hackage.haskell.org/package/diagrams-0.2.2 (BrentYorgey)
12:41:09 <tehgeekmeister> is there a way to use quickcheck to test things in the IO monad?
12:41:37 <conal> tehgeekmeister: what kind of properties would you want to specify?
12:42:12 <conal> tehgeekmeister: or maybe that's part of your question.
12:42:26 <Twey> tehgeekmeister: \f a b -> liftM2 f (a `mplus` b) (b `mplus` a) = \f a b -> liftM2 f (mplus a b) (flip mplus a b) = \f a -> liftM2 (liftM2 f) (mplus a) (flip mplus a) = \f -> liftM2 (liftM2 (liftM2 f)) mplus (flip mplus) = \f -> ($ flip mplus) (liftM2 (liftM2 (liftM2 f)) mplus) = \f -> ($ flip mplus) (($ mplus) (liftM2 (liftM2 (liftM2 f)))) = \f -> ($ flip mplus) . ($ mplus) . liftM2 . liftM2 $ liftM2 f = ($ flip mplus) . ($ mplus) . liftM2 . liftM2 .â€¦
12:42:32 <Twey> â€¦ liftM2
12:42:38 <tehgeekmeister> Twey: wat.
12:42:39 <Twey> â€¦ okay, that wasn't as readable as I'd hoped
12:42:50 * Twey hpastes
12:43:07 <tehgeekmeister> conal: i have certain sql queries that, after a certain number of items are in a certain table, should always return results.  (and i can determine how many results/which ones in haskell to test that the results returned are correct.)
12:43:38 <byorgey> tehgeekmeister: have you looked at Test.QuickCheck.Monadic ?
12:43:39 <tehgeekmeister> i can make an instance of arbitrary for the values such that the data going in is sensible test data
12:43:46 <tehgeekmeister> byorgey: no!  didn't know it existed.
12:44:13 <tehgeekmeister> (err, for the types.)
12:45:20 <roconnor> @free id
12:45:21 <lambdabot> f . id = id . f
12:47:12 <Twey> tehgeekmeister: http://hpaste.org/41066/pointfree_derivation
12:47:37 <tehgeekmeister> #haskell is pure unintentional nerd sniping.  all day, every day.
12:47:40 <tehgeekmeister> i love it.
12:47:58 <tehgeekmeister> i've already solved my problem and moved on and people are still poking at it because it's shiny.
12:48:02 * tehgeekmeister reads hpaste
12:50:25 <tehgeekmeister> can not follow that.
12:50:31 <tehgeekmeister> at least with the limited attention i can give it
12:50:40 <djahandarie> tehgeekmeister, which step?
12:50:53 <tehgeekmeister> three is where i first have trouble
12:50:57 <conal> tehgeekmeister: a thought: wrap up sql in a pure interface. for testing at least.
12:51:22 <tehgeekmeister> conal: i'm trying to test the actual behavior of postgresql
12:51:28 <tehgeekmeister> conal: not the ideal behavior of a query
12:51:38 <Twey> tehgeekmeister: The Monad instance of functions is such that liftM2 c f1 f2 = \v -> c (f1 v) (f2 v)
12:51:49 <tehgeekmeister> conal: but also, i'm not entirely sure what you mean, come to think of it?
12:52:25 <conal> tehgeekmeister: i mean, assuming postgresql is deterministic, you might wrap it up in a pure interface.
12:53:28 <tehgeekmeister> use some unsafe function or something?
12:53:38 <tehgeekmeister> do the io outside of the io monad?
12:53:43 <conal> tehgeekmeister: to remove the IO aspect and give it a simple enough semantics & interface so that you can state properties and test them.
12:53:57 <Twey> tehgeekmeister: You can use it to â€˜forkâ€™ an argument between two functions, and then combine the results with another function
12:54:31 <tehgeekmeister> Twey: ah, okay
12:55:13 <conal> tehgeekmeister: implemented via unsafePerformIO, and justified by the externally-side-effect-free nature of your hypothetical restricted interface.
12:55:15 <djahandarie> Probably the combination with the eta-reduce made it confusing
12:55:27 <Twey> Could be.  Sorry.
12:56:15 <tehgeekmeister> @hoogle unsafePerformIO
12:56:15 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:56:15 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
12:56:21 <conal> tehgeekmeister: the same justification for primitives like sin & cos having IO-free interfaces, in spite of coming from an imperative substrate.
12:56:35 <tehgeekmeister> conal: yeah, that makes sense.
12:56:56 <tehgeekmeister> conal: i would do testing on a throwaway database/inside transactions, anyway, so it would really be effectively deterministic.
12:56:59 <conal> in this sense, all of haskell is implemented via unsafePerformIO, except for IO.
12:57:12 <conal> tehgeekmeister: cool.
12:57:41 <tehgeekmeister> oh god.  what happens to debugging haskell when you use unsafePerformIO too much and make your code nondeterministic?
12:57:49 <tehgeekmeister> that would drive a person insane.
12:58:23 <conal> tehgeekmeister: use safePerformIO instead.
12:58:26 <sipa> conal: and that IO is eventually combined to something that is returned by the main function, where it is implicitly fed to unsafePerformIO ? :)
12:58:34 <osaunders> preflex: seen KitB_
12:58:34 <preflex>  KitB_ was last seen on #haskell 330 days, 2 hours, 29 minutes and 12 seconds ago, saying: And is there a nicer way of doing that? :P
12:58:38 <osaunders> preflex: seen KitB
12:58:38 <preflex>  KitB was last seen on #xmonad 40 days, 5 hours, 37 minutes and 3 seconds ago, saying: Zao I'll check that
12:58:41 <conal> (safePerformIO == unsafePerformIO with a side-condition)
12:58:49 <tehgeekmeister> @hoogle safePerformIO
12:58:49 <lambdabot> Foreign unsafePerformIO :: IO a -> a
12:58:49 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
12:59:25 <tehgeekmeister> conal: oh i wasn't saying i was going to do it, i was just wondering what insanity would take place with nondeterminism inside haskell.
12:59:31 <zygoloid> tehgeekmeister: liftM2 ap ((.) `on` flip mplus) (liftM2 max)
12:59:37 <conal> tehgeekmeister: yep
13:02:33 <bblum> hey all, i'm looking for a function similar to takeWhile that leaves the first predicate-failing element at the end of the list - e.g., "takeWhile (/= 3) [1,2,3,4,5]" returns "[1,2]" but i want "[1,2,3]". is there a function for this; if not, is there a recommended best-performance way to implement it?
13:02:41 <Twey> I think Î»b always goes for the shortest point-free form, but not always the clearest or prettiest
13:03:05 <zygoloid> Twey: \b doesn't seem to know about the liftM2 ap trick
13:03:36 <tehgeekmeister> bblum: i can only imagine one way of implementing that, and it's the obvious way.
13:03:38 <zygoloid> at least it generated something horrible when i asked it
13:03:50 <Twey> zygoloid: Yeahâ€¦ there's a lot she doesn't know
13:03:58 <zygoloid> @pl \a b -> liftM2 max a b `mplus` a `mplus` b
13:03:58 <lambdabot> join . (mplus .) . (flip =<< fmap mplus . liftM2 max)
13:04:02 <tehgeekmeister> takeWhile p (x:xs) = if p x then x else [])
13:04:08 <bblum> tehgeekmeister: and it's not tail-recursive, is it?
13:04:09 <tehgeekmeister> errr was still typing
13:04:33 <tehgeekmeister> bblum: i don't see why it shouldn't be?
13:04:44 <bblum> oh hm
13:04:46 <tehgeekmeister> takeWhile' p [] = []
13:04:57 <Lemmih> bblum: You want it to be lazy, not tail-recursive.
13:05:07 <tehgeekmeister> Lemmih: err, that.  yes.
13:05:16 <bblum> Lemmih: hmm
13:05:25 <bblum> i haven't got a good grasp of what makes a function lazy vs not
13:05:37 <tehgeekmeister> takeWhile' p (x:xs) = (if p x then x : takeWhile p xs else x)
13:05:47 <tehgeekmeister> slightly ugly, but i think that's right.
13:05:55 <zygoloid> \p xs -> zipWith const xs (undefined:takeWhile p xs)
13:05:57 <zygoloid> :)
13:06:20 <jtummond> @pl \f s0 -> = tail . scanl f s0
13:06:20 <lambdabot> (line 1, column 10):
13:06:20 <lambdabot> unexpected "="
13:06:20 <lambdabot> expecting lambda abstraction or expression
13:06:27 <jtummond> @pl \f s0 -> tail . scanl f s0
13:06:27 <lambdabot> ((tail .) .) . scanl
13:06:28 <dolio> roconnor: Well, I'm having trouble figuring out how to prove that free theorem from the general parametricity theorem.
13:06:48 <dolio> Not that that means it's wrong.
13:07:38 <conal> jtummond: (result.result.result) tail scanl
13:07:44 <conal> @where SEC
13:07:44 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
13:07:57 <zygoloid> fmap (fmap fmap fmap) fmap tail scanl
13:07:59 <conal> or use fmap for result
13:08:20 <tehgeekmeister> i hate it when i have to do fmap . fmap . fmap and crap like that.
13:08:30 <conal> though result generalizes nicely to deep arrows.
13:08:33 <jtummond> @conal where does result come from?
13:08:33 <lambdabot> Unknown command, try @list
13:08:46 <zygoloid> jtummond: result = (.)
13:09:02 <conal> jtummond: or DeepArrow or TypeCompose
13:09:13 <djahandarie> dolio, context?
13:09:13 <conal> for more general forms than result = (.)
13:09:35 <dolio> roconnor: For some reason I'm having trouble making the natural transformation into a relation. Agda's complaining about the types.
13:10:09 <conal> jtummond: if you read the SEC post, you'll see that there's a more general game going on here, which is very easy to follow from the types.  and includes first & second as well.  e.g. result.first.result.second
13:10:11 <roconnor> I might have a mistake in my theorem.
13:10:12 * zygoloid prefers (fmap . fmap . fmap), but is probably in the minority
13:10:46 <tehgeekmeister> zygoloid: there's an alternative?
13:10:54 <conal> zygoloid: i like that form also.  but not 'fmap fmap fmap', since the suggested generality isn't so.
13:10:59 <zygoloid> tehgeekmeister: (result . result . result)
13:11:05 <tehgeekmeister> @hoogle result
13:11:05 <lambdabot> Network.Stream type Result a = Either ConnError a
13:11:06 <lambdabot> Test.QuickCheck data Result
13:11:08 <lambdabot> Test.QuickCheck Result :: Maybe Bool -> [String] -> [String] -> Result
13:11:11 <conal> zygoloid: ie the first fmap *must* be (.)
13:11:23 <conal> @hackage TypeCompose
13:11:23 <lambdabot> http://hackage.haskell.org/package/TypeCompose
13:11:29 <conal> @hackage DeepArrow
13:11:29 <lambdabot> http://hackage.haskell.org/package/DeepArrow
13:11:38 <zygoloid> conal: fmap fmap fmap just isn't very readable, i find.
13:11:52 <tibbe> @seen kolmodin
13:11:52 <lambdabot> Unknown command, try @list
13:11:52 <preflex>  kolmodin was last seen on #haskell 12 days, 22 hours, 38 minutes and 56 seconds ago, saying: ketil: I think that should work fine
13:12:17 <Olathe> Is there a Haskell library for reading the screen and controlling the mouse?
13:12:45 <conal> Olathe: rather than controlling the screen and reading the mouse?
13:12:58 <conal> Olathe: i think we use *people* to read the screen and control the mouse.
13:13:12 <tehgeekmeister> is something like statement = prepare connection sqlString a CAF even though it returns something in the IO monad?
13:13:30 <Lemmih> Olathe: Find a C library that does that and write a binding to it.
13:13:34 <conal> as haskell-program-peripheral wetware devices
13:13:40 <tehgeekmeister> and does that mean that the action is only performed once or not?
13:13:45 <Olathe> Ahh, OK.
13:13:53 <conal> tehgeekmeister: type doesn't matter.
13:14:12 <conal> tehgeekmeister: has nothing to do with execution (performing)
13:14:17 <dolio> roconnor: Oh, wait, I figured something out. Apparently Agda doesn't like you filling holes of type Set with things of type Set ?, with a metavariable.
13:14:21 <tehgeekmeister> conal: what about semantics?  does the action get performed each time i use it?
13:14:51 <conal> tehgeekmeister: if you execute 'statement >> statement', then yes.
13:15:28 <conal> tehgeekmeister: (i'm trying to be careful with language here.  there are other ways to 'use it' that won't perform the action)
13:15:37 <tehgeekmeister> conal: okay.  well that's not what i wanted, but i can fix that later.
13:15:46 <conal> CAFness has to do with evaluation, not execution
13:15:50 <tehgeekmeister> conal: i'm trying to avoid recompiling queries each time they're used.
13:15:57 <tehgeekmeister> conal: right, that's what i thought
13:16:02 <tehgeekmeister> i just wanted to check
13:16:23 <conal> tehgeekmeister: yeah. the interface you're given may be overly IO'd
13:16:48 <tehgeekmeister> i may switch to a different database library at some point
13:16:48 <tehgeekmeister> f
13:16:51 <tehgeekmeister> or now this will do
13:17:13 <conal> tehgeekmeister: does the result of query compilation depend solely on the value of the query string?
13:17:39 <conal> tehgeekmeister: if so, maybe safePerformIO would be useful.
13:17:39 <tehgeekmeister> yep.  the execution depends on the parameters, the query compilation depends on just the query itself.
13:18:21 <conal> tehgeekmeister: you could check with the library author and ask if he knows a reason for having the compilation function yield IO.
13:18:35 <conal> tehgeekmeister: maybe is a design flaw in the binding.
13:18:53 <tehgeekmeister> it may actually affect the state of the connection/server
13:18:58 <conal> or maybe there are legit reasons not to.
13:18:59 <djahandarie> I liked that idea of Safe Haskell
13:19:09 <tehgeekmeister> it may not be just compiling and storing a query
13:19:22 <conal> tehgeekmeister: yeah -- that's the sort of thing to look out for.
13:19:23 <tehgeekmeister> but rather setting that as the "query in progress" on the server, or something of that sort
13:19:40 <tehgeekmeister> it means i have to have three lines of code for every single database query, though.
13:19:43 <tehgeekmeister> do not like this.
13:19:44 <Saizan> well, you've to send it to the server for compilation, no?
13:19:53 <tehgeekmeister> Saizan: yeah
13:20:08 <tehgeekmeister> wait!  i can make this a bit more concise!
13:25:31 <dolio> roconnor: So, I think I could eventually prove this. But it'd be a pain.
13:26:34 <astroboy> I have a problem with cabal, it keeps reinstalling stuff that's already install. In my case, I want to install the darcs version of xmonad, but after I installed it when I try to install xmonad-contrib it reinstall the hackage version of xmonad
13:26:36 <tehgeekmeister> is it bad (style wise) to do things like result <- fmap someFunctionThatProcessesTheResultOfTheAction action
13:26:57 <roconnor> dolio: it is supposed to be free!
13:27:27 <dolio> I have to fill one hole that says: n B (h y) = n B (map B B f (h x)), on the condition that x = y, and forall x. x = f x. That's easy, but I need to add premises about the behavior of map on the identity function.
13:28:10 <dolio> Another hole is more complicated.
13:28:40 <Saizan> astroboy: does the darcs version of xmonad have a version number that matches the constraints in xmonad-contrib's .cabal ?
13:29:38 <astroboy> Saizan: yes
13:30:04 <astroboy> the darcs version has the same version number as the hackage version anyway
13:30:14 <Saizan> astroboy: ah, then that's the problem
13:30:35 <Saizan> astroboy: bump the version number of the darcs version before installing it
13:30:35 <astroboy> and I'm asking because xmonad-contrib fails to compile with the hackage version
13:30:42 <astroboy> Saizan: ok
13:31:22 <Saizan> hackage's xmonad-contrib doesn't build against hackage's xmonad? that seems weird
13:31:23 <c_wraith> Does GHC not require types with a phantom type variable to have a concrete type at compile-time?
13:32:15 <Saizan> c_wraith: if there are no typeclass constraints they might end up "defaulting" to Any
13:32:47 <c_wraith> I'm just surprised I'm not getting some errors for underspecifying types somewhere.
13:32:50 <astroboy> Saizan: I changed the version in xmonad.cabal but it says it's installed 0.9.1 anyway, do I have to change it somewhere else?
13:33:07 <roconnor> I wish I had a Wadler
13:33:22 <Saizan> astroboy: that should be enough, did you run "cabal install" again from there?
13:33:30 <astroboy> Saizan: yes
13:33:40 <c_wraith> I guess it's fully possible GHC is just defaulting them to () when it's underspecified.
13:33:52 <astroboy> Saizan: still it reinstalls it
13:34:40 <Saizan> astroboy: well, you can add --dry-run -v to see why it thinks it needs to be reinstalled
13:35:24 <astroboy> Saizan: ok. it reinstalls some packages everytime, it's weird
13:36:25 <astroboy> Saizan: http://pastebin.com/AxQvLiKM
13:37:05 <Saizan> astroboy: ghc-pkg list xmonad ?
13:38:10 <astroboy> Saizan: http://pastebin.com/hrwiZtcg
13:38:36 <astroboy> Saizan: ghc-pkg check gives http://pastebin.com/UmE0YRJ1
13:38:42 <Saizan> astroboy: so you didn't manage to install the darcs version with a bumped version
13:39:37 <Saizan> you should edit the .cabal file to say "version: 0.9.1.1" instead of "version: 0.9.1" and then run "cabal install" from there
13:39:43 <Saizan> without other arguments
13:40:00 <Saizan> xmonad.cabal, i mean
13:40:15 <astroboy> oh ok now it works, before I tried 0.9.2 and something went wront
13:40:51 <astroboy> Saizan: now this http://pastebin.com/0Szc4Sxm :P. Thanks a lot for the help btw
13:41:54 <astroboy> Saizan: I really can't figure out that error message lol
13:42:26 <Saizan> astroboy: that's a sign there's something cabal doesn't understand about your packages, i suspect, can you paste the whole "ghc-pkg list" ?
13:43:50 <astroboy> Saizan: http://pastebin.com/FJSB20x8 it seems I have two different versions of xmonad...
13:46:07 <Saizan> astroboy: you've the same version of both haskell98 and Cabal in both global and user dbs, you've to get rid of one of each
13:46:22 <Saizan> you should probably keep the global ones and remove the others
13:46:31 <Saizan> you might need --force 
13:46:53 <Saizan> same for random..
13:47:12 <Saizan> and process
13:47:26 <astroboy> oh I see... maybe it's easier just to stick with the package manager. How do I remove cabal and everything that comes with it?
13:47:38 <Saizan> astroboy: did you use "cabal upgrade" btw?
13:47:53 <astroboy> Saizan: yes
13:47:57 <Saizan> since that's the usual way to screw up your installation :)
13:48:28 <Saizan> you can rm -fr ~/.ghc to forget about the packages installed via cabal
13:48:39 <astroboy> Saizan: ok thanks
13:55:01 <c_wraith> Bah.  I feel like using phantom types *and* a typeclass so that behavior can key off what the phantom type is indicates I'm doing something wrong.
14:00:28 <zygoloid> c_wraith: i'm not sure whether i'd consider it a phantom type in that context (since the implicit dictionary parameter depends on it). i've done the same thing myself on occasion...
14:01:23 <c_wraith> zygoloid, there are *very* few cases where the type class would matter. possibly just one.  But I really want them to be different types, but to be able to vary behavior based on the type in one or two functions.
14:01:38 <c_wraith> varying behavior based on type implies a typeclass
14:01:57 <shapr> tommd: y0, DRBG requires transformers >= 0.2.2.0 it won't build with transformers == 0.2.1.0
14:04:02 <zygoloid> c_wraith: this is what i did: http://control.monad.st/archive/2010/08/faking-dependent-types-for-fun-and-profit/
14:05:54 <c_wraith> ah.  I think that's different from what I want, in that I want the same constructor for everything.  I just want to get compiler errors when I try to mix things I shouldn't.
14:13:41 <anto> hey
14:16:19 <sipa> @pl \x -> zipWith (+) x (tail x)
14:16:19 <lambdabot> ap (zipWith (+)) tail
14:16:44 <kyagrd> :t ap
14:16:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
14:17:00 <dobblego> how would one write takeM when you may sequence one or the other effects in m Int and m [a] ?
14:17:25 <gregor3005> hi, is there under the default functions a function to search an element in an list?
14:17:33 <dobblego> gregor3005, Data.List.elem
14:17:40 <fserb> When using Text.JSON.Generic / Data.Generics, is there any way to specify a transform function for the field names?
14:17:47 <kyagrd> :t elem
14:17:48 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
14:18:26 <gregor3005> nice function
14:18:30 <kyagrd> :t find
14:18:31 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
14:18:43 <gregor3005> good to know that i doesn't need to write my own
14:18:45 <kyagrd> this one is more geneal one since elem requires Eq
14:18:47 <gregor3005> thanks for the very fast help
14:18:50 <fserb> basically I have a data X = X { xAttr :: String } and I want this to map to a "attr" field on the json object. I know how to do this "by hand" (constructing the JSON instance), but I wonder if there's a way to do this with Data.Generics.
14:20:26 <dobblego> > undefined && False -- is && too strict?
14:20:27 <lambdabot>   *Exception: Prelude.undefined
14:21:12 * hackagebot monads-fd 0.1.0.3 - Monad classes, using functional dependencies  http://hackage.haskell.org/package/monads-fd-0.1.0.3 (RossPaterson)
14:21:26 <danr> so && is strict in its first argument yes
14:21:35 <danr> @src (&&)
14:21:35 <lambdabot> True  && x = x
14:21:35 <lambdabot> False && _ = False
14:21:38 <dobblego> it is, but is this appropriate?
14:21:48 <dolio> Yes.
14:21:56 <danr> Well, yes it has to be strict in one of its arguments
14:22:55 <dobblego> ah yeah, <insert sleep excuse here>
14:23:04 <jmcarthur> i disagree that it *has* to be strict in its first argument, but i don't think it's unexpected that it is
14:23:38 <jmcarthur> but in order to make it not strict in either argument you have to use unamb or lub or something
14:25:12 <jmcarthur> well, "more lax" would be more accurate, probably
14:26:21 <jmcarthur> a &&& b = (a && b) `lub` (b && a)
14:26:59 <jmcarthur> doh, my attempt not to override another operator failed
14:27:13 <dobblego> @hoogle lub
14:27:13 <lambdabot> No results found
14:27:21 <jmcarthur> ?hackage lub
14:27:22 <lambdabot> http://hackage.haskell.org/package/lub
14:27:48 <jmcarthur> :t lub
14:27:49 <lambdabot> Not in scope: `lub'
14:27:53 <jmcarthur> i wish lambdabot had that
14:28:24 <danr> ew lub is in a way hideous! (and in a way fantastic, too)
14:28:33 <jmcarthur> hideous implementation
14:28:55 <dolio> Let's spawn a thread every time we want to and two booleans.
14:28:58 <jmcarthur> but the semantics is nice
14:29:04 <jmcarthur> dolio: yeah :(
14:31:58 <Zhuangzi> @remember dolio Let's spawn a thread every time we want to and two booleans.
14:31:58 <lambdabot> Nice!
14:36:15 <Lemmih> Damn, that sentence is hard to parse.
14:36:35 <tehgeekmeister> @hoogle >=>
14:36:35 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
14:37:42 <tehgeekmeister> > Just >=> const Nothing
14:37:43 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a1)
14:37:43 <lambdabot>    arisi...
14:37:58 <tehgeekmeister> > Just >=> (const Nothing)
14:37:59 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> Data.Maybe.Maybe a1)
14:37:59 <lambdabot>    arisi...
14:38:12 <tehgeekmeister> @hoogle const
14:38:12 <lambdabot> Prelude const :: a -> b -> a
14:38:12 <lambdabot> Data.Function const :: a -> b -> a
14:38:12 <lambdabot> Control.Applicative newtype Const a b
14:38:52 <shapr> I hear rumors the Haskell guys in Portland are releasing a new document type. Soon document.pdx will be the standard document type everywhere!
14:39:02 <_andy_> a quick question: is it possible to convert int to some Ix?
14:39:15 <_andy_> (for having an MArray instance with dynamic bounds)
14:39:31 <tehgeekmeister> > (\x -> Just x) 1 >=> (\y -> Nothing)
14:39:32 <lambdabot>   <no location info>: lexical error at character '\FS'
14:39:50 <tehgeekmeister> > ((\x -> Just x) 1) >=> (\y -> Nothing)
14:39:51 <lambdabot>   Couldn't match expected type `a -> m b'
14:39:51 <lambdabot>         against inferred type `Data...
14:40:15 <tehgeekmeister> @hoogle >>=
14:40:15 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:40:15 <lambdabot> Control.Monad (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:40:15 <lambdabot> Control.Monad.Instances (>>=) :: Monad m => m a -> (a -> m b) -> m b
14:40:17 <Lemmih> _andy_: Ix is a type-class.
14:40:47 <tehgeekmeister> (\x -> Just x) 1 >>= (\y -> Nothing)
14:40:51 <_andy_>  i guess i have no issue going Ix a => (a, a) -> Int
14:40:51 <kmc> Int is an instance of Ix
14:40:59 <_andy_> is there a way to do the reverse, forall Ix?
14:41:03 <tehgeekmeister> . (\x -> Just x) 1 >>= (\y -> Nothing)
14:41:06 <kmc> @src Ix
14:41:07 <lambdabot> class (Ord a) => Ix a where
14:41:07 <lambdabot>     range           :: (a,a) -> [a]
14:41:07 <lambdabot>     index           :: (a,a) -> a -> Int
14:41:07 <lambdabot>     inRange         :: (a,a) -> a -> Bool
14:41:07 <lambdabot>     rangeSize       :: (a,a) -> Int
14:41:14 <tehgeekmeister> > (\x -> Just x) 1 >>= (\y -> Nothing)
14:41:15 <lambdabot>   <no location info>: lexical error at character '\FS'
14:41:17 <_andy_> @src getBounds
14:41:17 <lambdabot> Source not found. You untyped fool!
14:41:21 <_andy_> @src MArray
14:41:21 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:41:22 <kmc> _andy_, you could use fromEnum
14:41:24 <Lemmih> _andy_: As in 'index'?
14:41:26 <kmc> if it's also Enum
14:41:27 <c_wraith> Oh, hey. Add a typeclass constraint and suddenly my phantom types aren't happy being unconstrained.  At least now I see the errors I expected all along. :)
14:41:37 <_andy_> which i can't guarantee given getBounds definition
14:41:38 <kmc> or am i backwards
14:41:51 <_andy_> @src Data.Array.MArray
14:41:51 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:41:51 <pumpkin> cmk
14:42:21 <tehgeekmeister> > Nothing >>= Just
14:42:22 <lambdabot>   Nothing
14:42:29 <_andy_> > import Data.Array.MArray
14:42:30 <lambdabot>   <no location info>: parse error on input `import'
14:42:31 <tehgeekmeister> > Just 1 >>= Nothing
14:42:31 <lambdabot>   Couldn't match expected type `t -> Data.Maybe.Maybe b'
14:42:32 <lambdabot>         against infe...
14:42:40 <Lemmih> _andy_: I don't understand your question.
14:42:44 <pumpkin> > join (>=>) Just 5
14:42:45 <lambdabot>   Just 5
14:42:47 <tehgeekmeister> > Just 1 >=> (\y -> Nothing)
14:42:47 <lambdabot>   <no location info>: lexical error at character '\FS'
14:43:02 <_andy_> i am trying to define an MArray instance
14:43:08 <tehgeekmeister> > Just 1 >>= (\y -> Nothing)
14:43:09 <lambdabot>   Nothing
14:43:15 <tehgeekmeister> win!
14:43:18 <tehgeekmeister> bind saves the day.
14:43:20 <_andy_> the backing array is  provided by a particular file format that represents tabular data
14:43:39 <_andy_> which can be resized
14:43:42 <tehgeekmeister> @hoogle headMay
14:43:42 <lambdabot> No results found
14:43:57 <pumpkin> @let pumpkinJust = join (>=>) Just
14:43:58 <lambdabot>  Defined.
14:44:00 <pumpkin> :t pumpkinJust
14:44:01 <lambdabot> forall b. b -> Maybe b
14:44:05 <_andy_> the returned type is MyArray (Int, Int) (Maybe Attribute)
14:44:13 <_andy_> but i cannot define getBounds
14:44:18 <kmc> _andy_, i'm not a huge fan of the Array APIs personally; is there a particular reason you want to make a new MArray?
14:44:27 <_andy_> because i cannot rely on (Int, Int) being the Ix instance
14:44:36 <_andy_> just to make its use more general
14:44:40 <_andy_> will be merging files
14:44:56 <_andy_> would be nice to represent it has merging arrays
14:44:57 <Lemmih> _andy_: Don't force the index to be an Int.
14:45:13 <kmc> _andy_, is there some MArray-generic code you want to use with it?
14:45:23 <_andy_> only code i plan on writing
14:45:33 <kmc> well, you can also define a new class
14:45:33 <_andy_> so i could just cheat
14:45:35 <kmc> which is a better fit
14:45:37 <_andy_> ok
14:45:45 <kmc> and make instances for IOArray, STArray, etc if you want compatibility
14:46:59 <_andy_> just to make sure, there is nothing along the lines of: resize :: Ix a => (a, a) -> Int -> (a, a)
14:47:28 <Lemmih> _andy_: No.
14:47:43 <shapr> @hoogle (a,a) -> Int -> (a,a)
14:47:43 <lambdabot> Data.Graph.Inductive.Graph delNode :: Graph gr => Node -> gr a b -> gr a b
14:47:43 <lambdabot> Data.Graph.Inductive.Graph delNodes :: Graph gr => [Node] -> gr a b -> gr a b
14:47:43 <lambdabot> System.Random randomR :: (Random a, RandomGen g) => (a, a) -> g -> (a, g)
14:47:50 * shapr shrugs
14:48:32 <_andy_> would i might do then is (and pretty sure getting this from somewhere else):
14:48:42 <_andy_> class HasMutableBounds ... resize ...
14:49:17 <_andy_> *what
14:49:52 <_andy_> something odd: i am defining the datatype as so:
14:50:07 <_andy_> data HandleArray i e = forall i. (Ix i, Num i) -> ...
14:50:22 <_andy_> but am unable to treat the bounds as Num i => ...
14:50:25 <_andy_> is this expected?
14:51:09 <Lemmih> _andy_: Did you mean to bind 'i' twice?
14:51:13 <_andy_> sorry, that datatype should be: ... Num i) => ...
14:51:25 <_andy_> i believe so
14:51:31 <_andy_> should i not?
14:51:39 <Lemmih> _andy_: You should not.
14:51:55 <Lemmih> _andy_: Just remove the 'forall' and the class constraints.
14:52:01 <stepkut> I have a module that gets overlapping instances when the compiler can compiles that module and the module that defines the other instances at the same time. But if the other instances are in a separate package and i link against it, it compiles fine :-/
14:52:35 <_andy_> i was hoping to beable to treat the indices as an instance of Num
14:53:19 <Lemmih> _andy_: And you can. Just put the class constraint on the functions that maniputate HandleArray.
14:53:56 <_andy_> (i.e. if i restrict the data type to Num i => a i e, and getBounds :: Ix i => a i e => m (i, i), why can i not treat i as being an instance of both Ix and Num?)
14:54:32 <Darkone> > let derp = 0.0 in printf "%.7f" derp
14:54:33 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:54:33 <lambdabot>    `Text.Printf.PrintfType ...
14:54:51 <Lemmih> _andy_: Your code doesn't restrict the data type.
14:55:50 <Darkone> > let derp = 2.0 * 0.0 :: Float in printf "%.7f" derp
14:55:50 <lambdabot>   Ambiguous type variable `a' in the constraints:
14:55:51 <lambdabot>    `GHC.Show.Show a'
14:55:51 <lambdabot>      a...
14:56:16 <_andy_> is it possible to?
14:56:23 <Lemmih> _andy_: No.
14:56:27 <_andy_> (not forall a, just for this type)
14:56:51 <Darkone> :t 2.0 * 0
14:56:52 <lambdabot> forall t. (Fractional t) => t
14:57:26 <_andy_> does the MArray class define or require anything related to resizing?
14:57:40 <Darkone> :t let derp = 2.0 * 0 :: Double
14:57:41 <_andy_> other than that getBounds is in the IO monad
14:57:41 <lambdabot> <no location info>:
14:57:41 <lambdabot>     not an expression: `let derp = 2.0 * 0 :: Double'
14:57:52 <Darkone> :t (let derp = 2.0 * 0 :: Double)
14:57:53 <lambdabot> parse error on input `)'
14:57:58 <_andy_> i have trouble seeing how getBounds allows for resizeable arrays
14:58:01 <Darkone> :(
14:58:20 <Lemmih> _andy_: No. MArray doesn't have anything to do with resizing.
14:58:32 <_andy_> ok
14:58:37 <_andy_> thank you
14:58:41 <tibbe> Can someone think of a better way to find the next power of 2 bigger than n?
14:58:41 <tibbe> firstPowerOf2 :: Int -> Int
14:58:42 <tibbe> firstPowerOf2 n
14:58:42 <tibbe>     | n <= 0    = 0
14:58:42 <tibbe>     | otherwise = 2^p
14:58:42 <tibbe>   where p = (ceiling . logBase (2 :: Double) . realToFrac) n :: Int
14:59:00 <tibbe> hmm, I should probably use shift
14:59:14 <tibbe> the highest bit by one
14:59:27 <Lemmih> _andy_: You can resizing your array without thinking about MArray.
14:59:46 <_andy_> ok
15:00:11 <_andy_> so its more that MArray allows for the option, but does not define a means
15:01:05 <Lemmih> _andy_: But it seems to me that you're not defining a new general class of arrays. It seems you're defining an array that only supports a specific type of index and a specific type of element. As such, MArray is inappropriate for your needs.
15:01:42 <_andy_> ok
15:02:28 <Lemmih> _andy_: MArray doesn't really have anything to do with resizing.
15:02:29 <_andy_> the reason i had original tried to was to avoid copying the array into memory (again - the c library i am using buffers the data)
15:02:51 <fengshaun> I just found out about programmingpraxis.com.  Seems to be a really good website for doing small exercises for Haskell beginners
15:03:47 <Darkone> I hate silent errors :(
15:04:40 <Darkone> apparently printf "%.7f" $ 2.0 * x    fails if x = 0 or something
15:05:23 <Darkone> But if you define a function such that it checks and binds 0 as a double... it works fine :|
15:05:23 <Lemmih> _andy_: You can use your array even if it's not an instance of MArray.
15:05:34 <unkanon> fengshaun: too bad a lot of those exercises are math-oriented
15:06:00 <_andy_> via another type class, or just directly using?
15:06:25 <fengshaun> unkanon, yea, I'm really looking for programming-oriented website with this kind of problems, but no luck so far.  ProjectEuler.net is also nice, but way too mathy!
15:06:37 <burp> @oeis 13, 17, 31, 37, 71, 73, 79
15:06:38 <lambdabot>  Emirps (primes whose reversal is a different prime).
15:06:38 <lambdabot>  [13,17,31,37,71,73,79,97,107,113,149,157,167,179,199,311,337,347,359,389,701...
15:06:38 <Cale> @let next2 m = foldl' (\n k -> n .|. (n `shiftR` (2^k))) m [0..bitSize m] + 1
15:06:39 <lambdabot>  Defined.
15:06:47 <Cale> > map next2 [0..]
15:06:47 <Lemmih> _andy_: Directly. There's no need for anything else.
15:06:48 <lambdabot>   Ambiguous type variable `a' in the constraints:
15:06:48 <lambdabot>    `Data.Bits.Bits a'
15:06:48 <lambdabot>      ...
15:06:51 <Cale> > map next2 [0..] :: [Int]
15:06:52 <lambdabot>   [1,2,4,4,8,8,8,8,16,16,16,16,16,16,16,16,32,32,32,32,32,32,32,32,32,32,32,3...
15:07:03 <blackdog> fengshaun: maybe go through the rosetta stone examples?
15:07:17 <fengshaun> blackdog, rosetta stone?
15:07:19 <blackdog> i agree that Euler gets you a little way into a new language, but the focus is too tight.
15:07:24 <fengshaun> blackdog, what's the link?
15:07:40 <blackdog> fengshaun: http://rosettacode.org/wiki/Main_Page
15:08:05 <fengshaun> blackdog, cool, thanks a lot!
15:09:18 <Cale> > iterate next2 0 :: [Int]
15:09:19 <lambdabot>   [0,1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,13107...
15:10:38 <_andy_> http://pastebin.com/YuJp7pUu was the quick thing i had tried, but if a leave off the type declaration wherever i operate on it, its pretty much the same
15:11:56 * shapr hugs blackdog 
15:12:09 <Cale> tibbe: Did you catch that? :)
15:12:28 <tibbe> Cale: yes
15:12:34 <tibbe> nextHighestPowerOf2 :: Int -> Int
15:12:34 <tibbe> nextHighestPowerOf2 !n =
15:12:34 <tibbe>     let !n1 = n - 1
15:12:34 <tibbe>         !n2 = n1 .|. (n1 `shiftR` 1)
15:12:35 <tibbe>         !n3 = n2 .|. (n2 `shiftR` 2)
15:12:35 <Lemmih> _andy_: Why resize to an Int instead of a 'Ix i => (i,i)'?
15:12:35 <tibbe>         !n4 = n3 .|. (n3 `shiftR` 4)
15:12:35 <tibbe>         !n5 = n4 .|. (n4 `shiftR` 8)
15:12:36 <tibbe>         !n6 = n5 .|. (n5 `shiftR` 16)
15:12:36 <tibbe>     in n6 + 1
15:12:38 <tibbe> xD
15:13:24 <Lemmih> tibbe: That's a bit too much to paste in here.
15:13:30 <Cale> tibbe: Subtracting 1 beforehand will means that it'll send 2^n to itself
15:13:33 <Cale> mean*
15:13:33 <tibbe> Lemmih: sorry
15:13:37 <_andy_> at the time (5 minutes ago) was trying to make it similar to rangeSize, though i agree with you
15:13:43 <tibbe> Cale: yes
15:13:44 <tibbe> Cale on purpose
15:13:57 <_andy_> means i can remove the MArray context
15:27:22 <blackdog> shapr: oh, hey dude
15:27:40 <blackdog> did i do something, or are you just feeling exuberant?
15:28:38 <dobblego> when cabal tells me to see config.log for a build error, where might this file actually be?
15:29:45 <osaunders> ~/.cabal/logs ?
15:30:00 <sm> oh, really ?
15:30:03 <dobblego> that's what I thought but I see only build.log there
15:30:50 <sm> otherwise: cabal unpack P; cd P; cabal configure; cabal build
15:38:36 <dobblego> so, is config.log a furfy?
15:39:50 <sm> ?
15:40:08 <robreg> erlanger is the gayest language to program in. it is the miata of programming languages. prehaps a more accurate name for it would be gaylanger
15:40:29 <hpc> o.O
15:40:44 <hpc> did i just walk in on something horrible?
15:40:55 <Rembane> A troll it seems.
15:41:01 <Rembane> Or someone very frustrated.
15:41:31 <geheimdienst> @wn miata
15:41:32 <lambdabot> No match for "miata".
15:42:06 <dobblego> sm, are you question marking me?
15:42:08 <mauke> is there actually a language called erlanger?
15:42:33 <sm> dobblego: yes, wondering if you found config.log from my instructions
15:42:33 <BrianHV> is there a module that provides TimeZones for most time zones that are actually used?
15:42:53 <sm> and inviting you to explain furfy. Or not. :)
15:43:00 <hpc> @google tzdata haskell
15:43:01 <lambdabot> No Result Found.
15:43:02 <dobblego> sm, ok give me a moment
15:46:21 <ddarius> @google furphy
15:46:21 <lambdabot> http://en.wikipedia.org/wiki/Furphy
15:46:22 <lambdabot> Title: Furphy - Wikipedia, the free encyclopedia
15:46:25 <ddarius> ?
15:48:03 <dobblego> ah yeah sorry boot that, that's what I mean
15:53:56 <AmunRa> hello, I'm learning haskell and following the (now closed) codejam competition. I have a space leak even though I splattered the code with `seq` http://hpaste.org/41071/amunra .. any tooling I can use? not enough info on http://www.haskell.org/haskellwiki/Memory_leak
15:55:09 <Zhuangzi> Real World Haskell has good, free advice about profiling.
15:55:28 <BrianHV> looks like the time zones are listed in Data.Time.Format.Parse...
15:57:27 <tommd> AmunRa: Use profiling and -hy
15:57:36 <BrianHV> but I can't figure out how to get at them...
15:58:09 <tommd> AmunRa: If you still have a space leak then it might not be due to something you haven't evaluated but rather 1) trying to evaluate too much (lazyness leak) or 2) Holding a reference to some large data unnecessarily
15:59:08 <AmunRa> tommd: I'm not sure I understand (1)
15:59:36 <AmunRa> (1) === too many thunks ?
16:00:18 <tommd> AmunRa: No, 1) is about not evaluating infinite lists and the like.
16:00:45 <tommd> AmunRa: If you force too much evaluation then you have too much data to deal with, often before it's necessary.
16:01:22 <AmunRa> my input: > test 21 3371329  --where 21 is the size of the list, and 3371329 is the number of iterations
16:01:47 <tommd> AmunRa: A great example came up on SO the other week.  Someone wanted to parse all fields in a HUGE spreadsheet.  Instead of running a scanl or fold they wanted (for some unknown reason) to acquire an evaluated list of every field.
16:02:23 <tommd> AmunRa: That means nothing to me.  If you think that proves you aren't being harmed by excessive strictness then you misunderstand the potential issue.
16:03:00 <AmunRa> I'm just running a loop many times on a small amount of data, at each iteration throwing the old data away
16:03:33 <AmunRa> let's see what I get from profiling first :-)
16:05:16 <tommd> AmunRa: That runs in .3 seconds for me.  Is there a problem?
16:05:38 <tommd> How much memory are you expecting it to take?
16:06:01 <AmunRa> 20-30MB? It's taking 2GB
16:06:05 <tommd> AmunRa: Its under 1MB
16:06:11 <tommd> How are you compiling this codE?
16:06:12 <tommd> code
16:06:18 <AmunRa> ghci :load
16:06:35 <tommd> AmunRa: ... you are interpreting it and trying to optimize for space use...
16:06:41 <tommd> AmunRa: Don't.  Do.  That.
16:06:54 <Mathnerd314> is it a good idea to (attempt to) teach Haskell to someone with no computer experience? if so, could anyone recommend a good place to start?
16:07:15 <AmunRa> ok :-) as explained, I'm learning... I thought ghci simply compiled under the covers
16:07:18 <tommd> Mathnerd314: I'd start by asking SimonM - he's been teaching his 5 year old.
16:07:20 <dagle> Mathnerd314: What experiance do he have?
16:07:26 <tommd> AmunRa: Nope.
16:07:49 <Mathnerd314> dagle: none, AFAIK. he went all wide-eyed as soon as I looked as the source of some web page
16:08:12 <tommd> AmunRa: Interpreted (Haskell) code has very different characteristics from its compiled/optimized cousins.  Use ghc --make -O2 for best results.
16:08:24 <dagle> Mathnerd314: I mean like is he into math or building stuff in general?
16:09:10 <Mathnerd314> dagle: not really. he just said "I've been meaning to learn computer programming; you look like a good person to ask"
16:09:53 <ddarius> Mathnerd314: Haskell is arguably not the best language to start with, but it is certainly a better place to start than many other languages people have started with.
16:10:03 <Rembane> Mathnerd314: http://learnyouahaskell.com/
16:10:19 <dagle> Mathnerd314: Tbh those kinds of people is often most easy to learn program in some way that build something easy, extend it and learning by that way.
16:10:28 <hpc> the effects of learning haskell first can be entertaining
16:10:36 <HugoDaniel> hmm
16:10:44 <HugoDaniel> i dont like java as a first programming language
16:11:00 <hpc> i don't like java as an n-th programming language ;)
16:11:09 <Mathnerd314> well, he seemed to want to learn C++ as a first language :p
16:11:13 <HugoDaniel> the ammount of syntax per programming concept is huge
16:11:20 <Rembane> hpc: n+1? :)
16:11:24 <hpc> Rembane: yeah
16:11:33 <mauke> Mathnerd314: that sounds like a pretty terrible idea
16:11:41 <hpc> HugoDaniel: same with haskell; the concepts are just more awesome
16:11:52 <hpc> if you want tiny syntax, learn lisp :P
16:11:52 <HugoDaniel> hpc: in haskell you dont have syntax
16:12:00 <nus> Mathnerd314, does the child grok recursion
16:12:01 <nus> ?
16:12:02 <HugoDaniel> compared to java
16:12:02 <HugoDaniel> :P
16:12:04 <dagle> I don't like C++ as my length [1..] progranning language.
16:12:13 <nostrand> Mathnerd314: i think Scheme is a good place to start
16:12:13 <HugoDaniel> main = putStrLn "hello world"
16:12:18 <HugoDaniel> now do the same with java :)
16:12:28 <Mathnerd314> nus: I have no idea; I only know him as an acquaintance
16:12:58 <nus> Mathnerd314, oh
16:13:23 <Mathnerd314> nus: indeed. he might just change his mind :p
16:14:23 <nus> Mathnerd314, even better feed him(?) some M. Gardner and R. Smullyan books first
16:14:28 <c_wraith> :t realToFrac
16:14:29 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
16:15:52 <Mathnerd314> nus: will do; but he might be more of the engineering type
16:15:54 <Rembane> dagle: last [1..]
16:16:50 <ddarius> hpc: Forth or Joy have significantly less syntax than Lisp.
16:17:04 <hpc> ddarius: neat
16:17:17 <ddarius> In fact, CL syntax is rather complicated.  Scheme isn't bad, but it is also not -that- simple.
16:18:49 <megajosh2> I hate the (loop) form
16:19:25 <kmc> hurrr hurr lisp has no syntax hurrrrr durr
16:20:14 <geheimdienst> lisp has no syntax, lisp has just a boatload of parens
16:20:31 <dobblego> I have not met a person who has spent years with Java and with whom I have spent considerable time learning Haskell, who has looked back and wished they had not learned Java first
16:20:33 <Raynes> geheimdienst: kmc will slap you for saying that.
16:20:42 <kmc> that's true if you think lisp is a syntax for writing nested lists
16:20:46 <ddarius> geheimdienst: CL syntax is probably more complicated that Java's or C's or Haskell's.
16:20:51 <kmc> if you think it's a programming language, then it has syntax beyond parentheses
16:21:04 <hpc> lisp dialects have extra syntax, but lisp can be minimally defined with very light syntax
16:21:09 <kmc> for example, in Scheme you write (let ((x 3) (y 4)) â€¦) but in Clojure you write (let [x 3 y 4] â€¦)
16:21:42 <nus> @wn syntax
16:21:43 <lambdabot> *** "syntax" wn "WordNet (r) 2.0"
16:21:43 <lambdabot> syntax
16:21:43 <lambdabot>      n 1: the grammatical arrangement of words in sentences [syn: {sentence
16:21:43 <lambdabot>           structure}, {phrase structure}]
16:21:43 <lambdabot>      2: a systematic orderly arrangement
16:21:44 <Cale> That's nearly an equal amount of syntax in either case though
16:21:45 <lambdabot>      3: studies of the rules for forming admissible sentences
16:21:49 <alex404_> Is there any consensus on style when it comes to declaring local constants with 'let in' vs 'where'?
16:22:08 <mm_freak> i'd consider lazy k a lisp dialect
16:22:08 <Lemmih> dobblego: They're glad they studied Java first?
16:22:13 <kmc> it's nearly equal, but they are different in a way that is clearly syntax
16:22:16 <dagle> kmc: I bet you kan make that into a macro. :)
16:22:18 <mm_freak> with only three syntactic forms
16:22:22 <dobblego> Lemmih, no, the contrary
16:22:24 <hpc> alex404_: not sure, but i generally use let inside do blocks, and where otherwise
16:22:24 <mm_freak> S, K and application
16:22:25 <kmc> dagle, of course, that's my point
16:22:33 <Cale> The scheme version is maybe easier to lex, but it has just as much syntactic structure beyond that point.
16:22:45 <hpc> i also like to define functions at the top level instead of hiding them, so my opinion might not matter
16:22:53 <mm_freak> and it also proves that minimal syntax at all cost is not something you really want
16:22:58 <kmc> my point is that each special form constitutes syntax above and beyond s-exprs
16:23:00 <alex404_> hpc: No, that's kidn of how I roll too...
16:23:07 <kmc> also each macro, but they're defined in a regular and formal way
16:23:32 <Lemmih> dobblego: You have not met a person who looked back and wished they had not learned Java first. The double negatives makes it hard to understand.
16:23:36 * dagle sings the land of lisp...
16:23:38 <nus> how came nobody has mentioned Forth yet?
16:23:46 <dagle> nus: It has.
16:24:01 <dobblego> Lemmih, sorry, it's a negation on existential, rather than simply universal
16:24:22 <ddarius> From now on let's write all our sentences in HOL.
16:24:23 <dobblego> (in my sample set), all people who have learned Java then Haskell, regretted first learning Java
16:25:14 <Cale> dobblego: ah, it seemed like you were saying the opposite of that
16:25:25 <dobblego> that sample set is probably heavily influenced by the methods that I teach haskell
16:25:41 <dagle> All people being forced to learn haskell and not understanding it hates haskell (in my sample set)
16:25:42 <dobblego> sorry, I knew it was confusing too
16:25:53 <dobblego> I teach voluntarily
16:26:03 <Cale> I never really liked Java though. I liked some other imperative languages.
16:26:19 <dobblego> also, many people who claim to "like Java" barely understand it
16:26:20 * geheimdienst registers regretyouajava.com and makes it point to learnyouahaskell
16:26:24 <dobblego> (in my sample set)
16:26:29 <Twey> nus: Factor is pretty cool.
16:26:30 <Mathnerd314> dobblego: how do you teach it?
16:26:38 <Mathnerd314> (it=haskell)
16:26:54 <dobblego> Mathnerd314, I have a "course" that I have put together but is constantly under revision
16:27:21 <dobblego> Mathnerd314, I run the Brisbane Functional Programming Group (bfpg) and a (totally volunteer) weekly session in the Brisbane CBD
16:27:40 <ddarius> Java was a piece of crap at the beginnning and hasn't really evolved much since then.
16:27:49 <Rembane> It is at least faster.
16:28:07 <ddarius> Rembane: Once it's started, yes.
16:28:16 <Rembane> ddarius: Indeed. 
16:28:18 <dobblego> perhaps, Java was a piece of crap at the beginning and the crap has evolved a little
16:28:30 <Rembane> Or maybe the computers are faster. :/
16:28:34 <nus> Twey, is it cooler than Forth to explain to a child?
16:28:38 <dagle> Java bytecode is stackbased... :D
16:29:35 <ddarius> Factor is a better Forth in many ways, though not in every way that is important for a Forth.
16:29:49 <Twey> So long as you're not doing super low-level stuff, Factor seems better.
16:30:08 <Twey> Well, mind you â€” I've not played with all the low-level gadgetry in Factor yet.
16:30:15 <Twey> It's not as minimal as FORTH.
16:30:58 <dolio> Everything should be super low-level. That's the forth philosophy, no?
16:31:33 <dolio> Everyone should write their own hardware interaction code and whatnot.
16:31:52 <sproingie> weird i was just looking at factor again today
16:32:09 <dagle> dolio: And makning every lib a new language.
16:32:16 <dagle> making*
16:32:24 <sproingie> i just can't get into RPN.  the operation is just way too non-local for me
16:32:53 <sproingie> especially with factor which puts tons of syntax between your args and what you actually do with them
16:33:17 <sproingie> maybe when i finish learning arabic i'll train myself to read it right to left
16:33:49 <nus> sproingie, forth programs are best read from the end
16:34:08 <nus> that's where most abstract words sit
16:34:19 <AmunRa> dobblego, java evolved.. but it's still just an evolution over cobol
16:34:36 <sproingie> forth love if honk then
16:34:55 * ddarius doesn't like the way Forth does control structures.
16:35:11 <sproingie> postscript strikes me as an ideal forth
16:35:34 <ddarius> PostScript is a pretty nice language.
16:35:36 <sproingie> ans forth really doesnt blow my skirt up.  retroforth has some pretty nice stuff
16:36:10 <ddarius> If a PostScript was made with a library that wasn't designed to run in a printer, it'd be pretty nice all around.
16:36:17 <sproingie> tho ANS does have CS-ROLL which has to be the freakiest control structure on the planet
16:36:17 <dagle> What about terminfo?
16:36:44 <nus> some kids were taught to program on these: http://www.taswegian.com/MOSCOW/b3-34.html
16:37:03 <AmunRa> thanks all
16:38:28 <sproingie> postscript syntax-wise is nice but you can't beat manual control over the return stack as control structures go
16:38:32 <shortcircuit> fengshaun: You might also find this page interesting: http://rosettacode.org/wiki/Help:Similar_Sites
16:38:34 <sproingie> pretty sure ps doesn't have anything like the return stack
16:39:40 <sproingie> everyone should make a concatenative language at least once
16:41:23 <pumpkin> strongly typed concatenative language!
16:41:44 <sproingie> strongforth
16:41:51 <nostrand> or a lazy non-pure language =)
16:42:19 <sproingie> factor is also strongly typed, tho not totally static
16:42:37 * ddarius recently made a concatenative language that was a cross between Joy, Forth, and PostScript with Joy being the strongest contributor.
16:42:41 <sproingie> lazy forth would be ... interesting
16:45:16 <Zhuangzi> jmcarthur: Did you make a repo of your Haskell starter pack?
16:46:07 <sproingie> i did one that let you assign arity to words so you could push words on the stack that if their arity wasn't assigned would push a thunk that would evaluate as soon as they were satisfied by another non-thunk
16:46:21 <sproingie> which let you write a lot of things in pretty much any order
16:46:42 <sproingie> e.g. 1 1 +, 1 + 1, + 1 1
16:47:21 <sproingie> er s/assigned/satisfied/
16:47:30 <hpc> until now, i thought arity was a misspelling of parity
16:48:15 <sproingie> if my kung fu were strong, i would do like haskell and make everything arity 1
16:48:23 <sproingie> but my system was a hack
16:48:28 <hpc> haha
16:48:51 <zopa> I have some code that uses Text.Regex.Posix. It loads perfectly well into ghci and does what it ought. But when I try to compile with ghc I get get ugliness like "(.data+0x5b0): undefined reference to `regexzmposixzm0zi94zi1_TextziRegexziPosixziString_zdfRegexLikeRegexZMZN_closure'".  Any hints as to what's going on?  I'm stumped.
16:49:04 <Zhuangzi> Using Windows?
16:49:31 <mauke> zopa: are you using --make?
16:49:42 <sproingie> zopa: it means zalgo comes
16:50:18 <mauke> preflex: calc 1 1 +
16:50:19 <preflex>  2
16:50:22 <hpc> sproingie: no, he waits behind the wall; he doesn't come until you evaluate the thunk
16:50:24 <mauke> preflex: calc 1 + 1
16:50:24 <preflex>  2
16:50:27 <mauke> preflex: calc + 1 1
16:50:27 <preflex>  2
16:50:27 <sproingie> i think if i write a new language i'm going to call it zalgo
16:50:28 <zopa> mauke: ...Now I am.  And I feel a bit silly.   Thanks!
16:50:37 <Twey> preflex: 1 1 + 2 *
16:50:42 <Twey> preflex: calc 1 1 + 2 *
16:50:43 <preflex>  3
16:50:44 <sproingie> mauke: yay.  i did mine in assembly :)
16:50:49 <Twey> Wrong :<
16:50:55 <mauke> Twey: NO U
16:51:10 <mauke> * has higher precedence than +
16:52:21 <Twey> It's RPN.  Operator precedence does not apply.  >.>
16:52:41 <mauke> no one said it's RPN
16:52:43 <hpc> preflex: help calc
16:52:43 <preflex>  calc EXPR - evaluate an arithmetic expression
16:52:51 <hpc> well that is helpful...
16:52:58 <Twey> It *pretends* to be RPN
16:53:07 <hpc> preflex: calc 1 2
16:53:07 <preflex>  Too many operands
16:53:09 <Twey> But then trips you up with silly notation interpretation when you least expect it
16:53:17 <hpc> D: it should totally output the whole stack
16:53:24 <mauke> hpc: it doesn't use a stack
16:53:35 <SenseiScalps> hi all
16:53:36 <hpc> mauke: ah, figures
16:53:45 <dobblego> does a hypothetical takeM :: m Int -> m [a] -> m [a] run the first or second effect first?
16:53:51 <hpc> oh i see; wow
16:54:11 <mauke> dobblego: I don't think that makes sense
16:54:25 <dobblego> mauke, what doesn't exactly?
16:54:38 <mauke> dobblego: takeM takiung m Int and m [a]
16:54:45 <mauke> s/iung/ing/
16:54:49 <hpc> it would be takeM :: Int -> m [a] -> m [a]
16:55:01 <hpc> it makes (>>=) less yuck
16:55:06 <mauke> more like Int -> [m a] -> m [a], maybe
16:55:16 <hpc> or that
16:55:22 <dobblego> what criteria did you use to determine that?
16:55:27 <mauke> still, it doesn't seem very useful
16:57:36 <aavogt> @src liftM2
16:57:36 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:57:54 <aavogt> @type liftM2 take
16:57:55 <lambdabot> forall a (m :: * -> *). (Monad m) => m Int -> m [a] -> m [a]
16:58:02 <aavogt> @type flip (liftM2 (flip take))
16:58:03 <lambdabot> forall a (m :: * -> *). (Monad m) => m Int -> m [a] -> m [a]
16:58:10 <aavogt> dobblego: ^^
16:58:15 <dobblego> that's not the function I was thinking of
16:58:31 <hpc> wait, does flip . f . flip = f?
16:58:41 <dobblego> \n a -> n >>= \n' if n <=0 then a else ... for example
16:58:44 <mauke> @free flip
16:58:45 <lambdabot> Expected variable or '.'
16:58:46 <aavogt> is your  m  an instance of Monad?
16:58:53 <dobblego> yes
16:59:12 <mauke> @free flip :: (a -> b -> c) -> b -> a -> c
16:59:13 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
16:59:16 <aavogt> well if your function is supposed to work like take, it'll be one of those using liftM2
16:59:32 <dobblego> there seems to be a choice of which effect to run since you may not execute the first if the second is an empty list or not execute the second if the first is <= 0
16:59:40 <hpc> @help free
16:59:40 <lambdabot> free <ident>. Generate theorems for free
16:59:46 <dobblego> liftM2 will run both effects
17:05:17 <aavogt> dobblego: sure, or you could not get the  m Int  effects, if the  m [a]  turns out to be empty
17:05:27 <dobblego> aavogt, right, that's my question
17:05:50 <MiggyX> Can anyone recommend any screencast / tutorials on Haskell?
17:06:20 <dobblego> MiggyX, Erik Meijer Channel 9 Programming in Haskell series
17:06:32 <MiggyX> dobblego: awesome thanks
17:07:16 <aavogt> dobblego: so what's the problem if we've constructed functions that evaluate in either order, possibly short-circuiting on the effects of the one to happen later
17:07:35 <dobblego> aavogt, so you think, write all variants of the function?
17:08:38 <aavogt> dobblego: that we have covered all variants?
17:08:54 <aavogt> ignoring partial functions
17:09:23 <dobblego> aavogt, right, I'm asking if there is a correct one, or if not, if it is practical to have all variants?
17:09:58 <aavogt> it takes longer to explain what the variant is, than to have somebody write the one they want
17:10:09 <aavogt> so I'd say none are correct
17:10:26 <aavogt> in the sense that you'd want to write any variants
17:12:22 <dobblego> I'm sceptical of that criteria
17:19:31 <shapr> jmcarthur: http://homepages.cwi.nl/~tromp/cl/cl.html
17:19:38 <shapr> hoi tromp! Hoe gaat het?
17:20:19 <luite> oh meer nederlands in dit kanaal!
17:22:18 <endpoint_david> nub is O(n^2), right?
17:22:33 <tromp> hi shae
17:22:49 <tromp> het gaat zijn gangetje:)
17:23:52 <endpoint_david> I'm trying to find the period of this function via (length $ nub), and assume that's why it's not working that quickly:
17:23:56 <endpoint_david> length $ nub $ take (2^32) $ scanl (\a b -> (31 * a + b)) 0 (repeat (1 :: Word32))
17:24:40 <aavogt> > 2^32^2
17:24:41 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
17:25:01 <endpoint_david> so I can probably count on my laptop battery dying first, eh? :-)
17:25:20 <endpoint_david> suggestions for analysis?
17:25:21 <nostrand> endpoint_david: you could make a version of nub that don't preserve the order of the elements. Maybe there already is one =) (or make a set of it)
17:26:56 <endpoint_david> hmm, since I start at element 0, I could just zip against take until it's = 0
17:27:19 <MiggyX> dobblego: thanks for the heads up on these webcasts - going well so far :)
17:28:58 <endpoint_david> I suspect this will be much kinder to the machine:
17:28:58 <endpoint_david> (1+) $ length $ takeWhile (/= 0) $ scanl (\a b -> (31 * a + b)) 1 (repeat (1 :: Word32))
17:29:55 <endpoint_david> I'm sure this could be further optimized because I don't actually care about the elements beyond their enumeration
17:30:47 <nostrand> endpoint_david: won't Word32 overflow?
17:31:24 <dobblego> is there a solution to http://paste.pocoo.org/show/285280/ ?
17:31:31 <endpoint_david> nostrand: Word32 is intentional; it doesn't overflow, it'll truncate the calculation to the lowest 32 bits
17:31:43 <endpoint_david> you can see wiht Word8 much quicker
17:31:51 <nostrand> endpoint_david: ah
17:37:37 <endpoint_david> nostrand: that's in fact how it's able to cycle; I'm aiming to see how well of a mixing function that in fact is for a given constant input by analyzing where it cycles.  For Word8, it has a shorter cycle than the range of the datatype itself (16 only) for Word16, it has a period of 4096.  I'm trying to look at the next step up.
17:38:18 <nostrand> endpoint_david: ah =)
17:39:40 <endpoint_david> > 2^32
17:39:41 <lambdabot>   4294967296
17:42:27 * hackagebot bindings-bfd 0.1.3 - Bindings for libbfd, a component of the GNU `binutils'  http://hackage.haskell.org/package/bindings-bfd-0.1.3 (MichaelNelson)
17:46:28 <MiggyX> Can Haskell figure out itself? For example if you had say  x  =  (funca 12)  + (funcb 46), would it be able to calculate those in two 'threads' without being told to ?
17:46:59 <stepcut> MiggyX: no
17:47:02 <jmcarthur> MiggyX: ghc doesn't try to be that smart. too error prone
17:47:14 <jmcarthur> MiggyX: on the other hand, it's very easy to make that parallel with explicit annotations
17:47:39 <MiggyX> Why would it be error prone? Not challenging it, just trying to understand it :)
17:47:58 <jmcarthur> MiggyX: how should it decide when to introduce parallelism?
17:48:26 <MiggyX> jmcarthur: I suppose just because it could be made parallel doesn't neccesarily mean it should
17:48:32 <jmcarthur> right
17:48:36 <stepcut> MiggyX: it's not that it produces errors, per se, but that it often makes performance worse
17:48:52 <MiggyX> fair point 
17:50:12 <stepcut> MiggyX: it's been studied / attempted, but not with any great success
17:50:46 <MiggyX> stepcut: I suppose trying to automatically figure out when to do parallel processing is not exactly easy
17:50:46 <ddarius> Indeed, it would actually be (almost) trivial to simply make every application evaluate its arguments in parallel.
17:51:29 <stepcut> MiggyX: yep. Things like data parallel haskell attempt to do it in a much more confined space
17:51:47 <stepcut> that looks promising, but still very hard
17:52:30 <MiggyX> if it's really easy parallelise explicitly it's not much of an issue - but being able to automatically figure it out would be pretty awesome - especially with massively multicore systems on the consumer horizon 
17:54:08 <blackdog> MiggyX: the way it's typically handled is to separate the evaluation strategy from the computation
17:54:25 <blackdog> so you can pass in different strategies to see how it affects performance without changing your code.
17:54:51 <MiggyX> that also makes sense
17:56:33 <MiggyX> I'm hoping to do some Haskell related research :) Though obviously I have a lot to learn before I can really do that :)
18:07:07 <MiggyX> for the example I gave, how easy is it to parallelize ?
18:10:36 <unkanon> can anyone help me visualize something?
18:11:11 <unkanon> if unit is   . -> [.]   and join is  [[.]] -> [.]    then how do we draw bind?
18:11:20 <unkanon> i got these drawings from: http://en.wikibooks.org/wiki/Haskell/Category_theory#Monads
18:11:56 <unkanon> there's an error on this wikipage though, in that it says it will define unit and join but ends up defining unit and bind
18:12:17 <hpc> unkanon:
18:12:20 <hpc> :t fmap
18:12:21 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:12:36 <unkanon> yes i know :)
18:12:40 <hpc> so we say a is something and b is m a
18:12:43 <unkanon> but I want to come up with a drawing.
18:12:43 <hpc> and f is m
18:12:47 <hpc> oh
18:12:48 <unkanon> I understand that part :)
18:12:54 <hpc> well
18:13:06 <hpc> sorry, used to monad newbs :P
18:13:15 <unkanon> hehe that's fine
18:13:19 <unkanon> i'm trying to draw it now
18:13:25 <unkanon> by draw i mean "draw"
18:13:34 <hpc> perhaps do it with the list monad
18:13:49 <FunctorSalad> unkanon: in category theory, one of the "->" in bind would indicate "set function on the metalevel" and two of them indicate "morphism (on the object level)"
18:13:50 <unkanon> [.] -> (. -> [o]) -> [o]
18:13:52 <hpc> draw fmap making a list of lists
18:13:57 <hpc> then draw it being joined back into one
18:14:06 <FunctorSalad> (and you need to use (=<<) actually, not (>>=))
18:14:47 <hpc> so, ill hack something up in paint real quick
18:14:48 <FunctorSalad> bind :: Hom(a,m b) -> Hom(m a, m b)
18:14:56 <unkanon> FunctorSalad: about your last statement:  but is the wikipage right when it says that you can either have bind and unit, or join and unit, to define the monad laws?
18:15:05 <FunctorSalad> yes
18:15:06 <unkanon> you dont need to define =<<, right?
18:15:08 <unkanon> oh ok
18:15:12 <unkanon> how do you call =<< ?
18:15:29 <unkanon> hpc: cool :)
18:15:37 <FunctorSalad> I've heard 'extend'
18:15:47 <FunctorSalad> though I just call it bind too ;)
18:15:49 <unkanon> ok we'll go with that
18:16:19 <ddarius> Often (=<<) is written as a superscript *, so f^* :: m a -> m b where f :: a -> m b
18:16:24 <unkanon> no let's no do that! i'm on the verge of having all this recentlygotten knowledge spill out my brain, let's not confuse things! ;)
18:16:51 <unkanon> ddarius: hmm haven't come across that occurrence yet
18:17:10 <ddarius> Read Moggi's work or some related papers.
18:17:29 <djahandarie> Wow, you can identifier a symbol by which paper it was in?
18:17:35 <djahandarie> Skill
18:19:46 <hpc> unkanon: http://dl.dropbox.com/u/37707/Untitled.png
18:19:53 <hpc> hastily drawn
18:19:56 * unkanon is looking
18:20:06 <hpc> supplementary drawings of fmap and join will help get the point across
18:21:17 <unkanon> hpc: were you pretending that foo was a real function or is the result of foo irrelevant here?
18:21:44 <djahandarie> hpc, it isn't really clear what the object is there
18:21:49 <hpc> in this case, foo is \x -> [x..x+5]
18:22:01 <hpc> the object is that first list >>= foo
18:22:52 <djahandarie> I'm talking in the category-theoretical sense
18:23:10 <FunctorSalad> hpc: haha I like how the movements become increasingly more drunk
18:23:11 <FunctorSalad> ;)
18:23:14 * unkanon is still looking
18:23:20 <hpc> FunctorSalad: yeah, touchpad :P
18:23:34 <djahandarie> The fmap should probably give some sense that you have two categories
18:23:58 <unkanon> hpc: i understand the picture, but what was this supposed to help me understand again?
18:24:13 <hpc> (>>=) as implemented with fmap and join
18:24:17 <unkanon> ?t id
18:24:17 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
18:24:20 <hpc> that's what you wanted, yes?
18:24:40 <unkanon> hpc: hmm hold on
18:24:56 <Funktorsalat> hpc: oh I just meant increasing sideways movements, wasn't criticizing the steadiness of hte lines
18:25:28 <hpc> Funktorsalat: ah
18:25:30 <hpc> :D
18:25:49 <djahandarie> I thought he wanted the diagram to help him understand the category theory idea of monads using bind
18:26:23 <unkanon> hpc: so if i have [1,2,3,4,5] and I go: [1,2,3,4,5] >>= foo I will get [1,2,3,4,5, 2,3,4,5,6 3,4,5,6,7 ...]  ?
18:26:35 <hpc> unkanon: indeed
18:26:51 <unkanon> hpc: oh then that is very helpful :D
18:26:55 <hpc> > [1..5] >>= (\x -> [x..x+5])
18:26:56 <lambdabot>   [1,2,3,4,5,6,2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10]
18:27:13 <unkanon> wow
18:27:23 <djahandarie> Or maybe not
18:27:23 <unkanon> I am amazed
18:27:32 <hpc> lists are a fun monad
18:27:36 <djahandarie> unkanon, this of course only holds for the list monad
18:27:57 <unkanon> djahandarie: but it will work for every monad, mutatis mutandi
18:28:19 <djahandarie> unkanon, the only things that work for every monad are the monad laws
18:28:34 <djahandarie> I don't think the list monad provides any intuition to the abstraction
18:28:59 <unkanon> > join (fmap [1,2,3,4,5] (\x -> [x..x+5]))
18:28:59 <lambdabot>   Couldn't match expected type `a1 -> m a'
18:29:00 <lambdabot>         against inferred type `[a2]'
18:29:25 <hpc> flip the stuff you give fmap
18:29:42 <unkanon> > join (fmap (\x -> [x..x+5] [1,2,3,4,5]))
18:29:43 <lambdabot>   Couldn't match expected type `t -> a' against inferred type `[a1]'
18:29:50 <unkanon> > join (fmap (\x -> [x..x+5]) [1,2,3,4,5])
18:29:50 <lambdabot>   [1,2,3,4,5,6,2,3,4,5,6,7,3,4,5,6,7,8,4,5,6,7,8,9,5,6,7,8,9,10]
18:29:51 <unkanon> there we go
18:29:52 <unkanon> lol
18:30:22 <unkanon> djahandarie: that's really unfortunate :(
18:30:27 <hpc> yeah, lists are hard to intuit about, but easy to make into a visual example
18:30:44 <unkanon> djahandarie: what's a better monad to provide a better understanding of the abstraction?
18:30:45 <hpc> make sure it is abundantly clear how fmap is working, and how join is working
18:30:59 <djahandarie> unkanon, nothing in particular, just do a bunch
18:31:00 <hpc> unkanon: Maybe is the simplest monad
18:31:06 <unkanon> hpc: oh i'll be going over this many times
18:31:07 <djahandarie> And yeah, start with Maybe
18:31:31 <djahandarie> Hell, List is an awful monad to think about until late in the game
18:31:32 <geheimdienst> > fmap (+1) (Just 5)
18:31:33 <unkanon> djahandarie: should I draw fmap and join and bind for Maybe? or will that not make any sense?
18:31:33 <lambdabot>   Just 6
18:31:34 <hpc> i would go Maybe -> Either -> List -> roll your own -> IO
18:31:46 <geheimdienst> > fmap (+1) (Nothing)
18:31:47 <lambdabot>   Nothing
18:31:57 <djahandarie> hpc, I'd say roll your own before List
18:32:08 <geheimdienst> > join (Just (Just 3))
18:32:09 <lambdabot>   Just 3
18:32:11 <hpc> djahandarie: perhaps make them the same? :P
18:32:23 <geheimdienst> > join (Just (Nothing))
18:32:23 <lambdabot>   Nothing
18:32:24 <unkanon> roll my own list
18:32:26 <Funktorsalat> hmm not sure why you think this way about list
18:32:38 <geheimdienst> > join Nothing
18:32:39 <lambdabot>   Nothing
18:32:53 <djahandarie> The recursion in List makes it confusing
18:33:14 <Funktorsalat> it's zeh free monoid, which is a pretty prototypical example I'd guess
18:33:54 <hpc> i figured he wouldn't be starting his students off with the bind/join relationship right off the bat
18:34:22 <djahandarie> This is for a class?
18:34:25 <Funktorsalat> Tree isn't bad either
18:34:42 <hpc> in that context, list is a fine example; making visuals of join with Maybe would be easier
18:34:52 <unkanon> i'm not giving nor taking any classes, if that answers anything
18:35:04 <Funktorsalat> since 'bind' is a familiar operation with trees: substitution
18:35:50 <unkanon> Funktorsalat: when you say that, you mean bind with what other argument (the first is the tree, the second is.. ?)
18:35:51 <Funktorsalat> (think of the tree as an expression tree)
18:36:02 <djahandarie> Funktorsalat, I think recursion in the monad interface just makes it really magical looking
18:36:10 <Funktorsalat> unkanon: the substitution mapping
18:36:20 <ddarius> List is pretty close to what you'd get if you imposed only the MonadPlus axioms.
18:36:51 <hpc> @where pastebin
18:36:51 <lambdabot> http://hpaste.org
18:36:53 <Funktorsalat> e[x/t] is like e >>= (\a -> if a==x then t else return a)
18:37:42 <hpc> can someone give thoughts on this? http://hpaste.org/41072/some_simple_cgi
18:37:59 <hpc> it's a barebones beginning to a website i am working on
18:38:27 <Eduard_Munteanu> There's actually a (>>=) definition in terms of fmap.
18:39:03 <unkanon> Eduard_Munteanu: x >>= f = join (fmap f x)
18:39:18 <Eduard_Munteanu> Yeah.
18:39:20 <unkanon> hpc: a website or a website framework?
18:39:27 <unkanon> Eduard_Munteanu: that's the one the tutorial uses :)
18:39:41 <hpc> unkanon: a little of both; i am starting from scratch because the others seem to be type tarpits
18:39:53 <hpc> html :: IO () -> IO ()
18:39:54 <Eduard_Munteanu> Yeah, and if your particular fmap works like a map, then it's easy to see how a bind is a map.
18:39:59 <geheimdienst> hpc, looks nice to me. what's "out" take as an argument?
18:40:02 <hpc> same general pattern continues down inside the do
18:40:05 <hpc> out = putStrLn
18:40:23 <hpc> i might put some <br> at the end at some point, when it becomes necessary
18:40:23 <geheimdienst> okay :)
18:41:24 <hpc> i have some somewhat hideous code that pulls stdin into a [(String, String)] too, but i have yet to clean it up
18:41:30 <dobblego> Identity is a simpler monad
18:41:41 <hpc> Identity is too simple to teach with, i think
18:41:51 <dobblego> I use it all the time
18:42:00 <Eduard_Munteanu> hpc: you surprised me though...
18:42:05 <dobblego> it's too simple to demonstrate practical implications
18:42:05 <unkanon> it's too simple because it doesnt do anything
18:42:11 <Eduard_Munteanu> With the imperative Identity stuff.
18:42:14 <geheimdienst> any thoughts yet on how to add attributes to a tag? Â«table' [("class", "blah")] $ do ...Â» ...?
18:42:39 <dobblego> sure it does
18:42:48 <hpc> Eduard_Munteanu: i was showing off how it can be used to warp haskell into something odd
18:43:08 <djahandarie> Warping haskell into something odd?
18:43:13 <unkanon> dobblego: what?
18:43:21 <dobblego> applies a function to a value
18:43:21 <hpc> djahandarie: or more accurately, normal :P
18:43:21 <djahandarie> You haven't seen odd till you've seen augustss' BASIC implementation in Haskell
18:43:26 <geheimdienst> sure, because haskell is not quite odd enough
18:43:38 <Eduard_Munteanu> hpc: for some things that style is probably the only sane way, at least without doing lots of research beforehand.
18:44:03 <unkanon> dobblego: but it doesnt transform the value
18:44:07 <hpc> anyhoo, i was worried with my paste i would end up with people saying to pull more out of IO
18:44:11 <unkanon> hpc: so you can't see anythign happening
18:44:14 <hpc> good to know i am on the right track
18:44:17 <dobblego> sure it does
18:44:18 <Eduard_Munteanu> And if you're expressing it imperatively, it's not that bad.
18:45:19 <Eduard_Munteanu> hpc: I was concerned because I'll have to implement some numerical stuff soon. It's a good thing to try like ^
18:46:31 <ddarius> The craziest thing about augustss' BASIC implementation is that it might well be one of the fastest BASICs implemented.
18:46:39 <Eduard_Munteanu> Although if there were some nice functional trick to write stuff like matrix algorithms... well, I'd appreciate to know it.
18:47:52 * Eduard_Munteanu remembers to take another look at hmatrix
18:48:02 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= id
18:48:02 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:48:15 <djahandarie> ddarius, yeah, it's impressive
18:48:34 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= (\x -> x+1)
18:48:35 <lambdabot>   No instance for (GHC.Num.Num [t])
18:48:35 <lambdabot>    arising from a use of `e_11234567891' ...
18:48:48 <kmc> Eduard_Munteanu, read the Repa paper(s)
18:48:49 <kmc> and DPH
18:49:18 <hpc> unkanon: too much [] in that last one;
18:49:18 <kmc> to make the nice functional approaches work without lots of copying, you need fusion
18:49:20 <kmc> by rewrite rules
18:49:22 <Eduard_Munteanu> kmc: thanks, I'll have a look
18:49:23 <kmc> which is currently finicky
18:49:27 <hpc> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= id >>= (\x -> x+1)
18:49:28 <lambdabot>   No instance for (GHC.Num.Num [b])
18:49:28 <lambdabot>    arising from a use of `e_11234567891' ...
18:49:34 <hpc> :(
18:49:43 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= [(\x -> x+1)]
18:49:44 <lambdabot>   Couldn't match expected type `[t] -> [b]'
18:49:44 <lambdabot>         against inferred type `[a]'
18:49:50 <hpc> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= id >>= (\x -> return x+1)
18:49:51 <lambdabot>   No instance for (GHC.Num.Num [t])
18:49:51 <lambdabot>    arising from a use of `e_11234567891' ...
18:49:53 <ddarius> hpc: To little.
18:49:57 <ddarius> s/o/oo
18:49:58 <Eduard_Munteanu> > concatMap (\x -> x + 1) [ [1,2,3], [4], [], [], [5,6], [7,8,9] ]
18:49:59 <lambdabot>   No instance for (GHC.Num.Num [b])
18:49:59 <lambdabot>    arising from a use of `e_11123456789' ...
18:50:03 <Eduard_Munteanu> Strange.
18:50:07 <ddarius> [x+1]
18:50:09 <hpc> bah, humbug
18:50:14 <Eduard_Munteanu> Oh.
18:50:18 <Eduard_Munteanu> Right.
18:50:25 <hpc> i am going to sleep before i start being stupider
18:50:38 <Eduard_Munteanu> > concatMap (\x -> [x + 1]) [ [1,2,3], [4], [], [], [5,6], [7,8,9] ]
18:50:39 <lambdabot>   No instance for (GHC.Num.Num [t])
18:50:39 <lambdabot>    arising from a use of `e_11123456789' ...
18:50:39 <ddarius> That said, you'll need a Num instance for []
18:50:47 <ddarius> x is bound to a list
18:50:56 <Eduard_Munteanu> :t concatMap
18:50:57 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
18:51:09 <Eduard_Munteanu> Hm, yeah.
18:51:29 <Eduard_Munteanu> > concatMap (map (\x -> x + 1)) [ [1,2,3], [4], [], [], [5,6], [7,8,9] ]
18:51:30 <lambdabot>   [2,3,4,5,6,7,8,9,10]
18:51:50 <unkanon> hpc: lol
18:52:22 <unkanon> Eduard_Munteanu: how do we do that with bind?
18:52:42 <Eduard_Munteanu>  [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= map (\x -> x + 1)
18:52:47 <Eduard_Munteanu> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= map (\x -> x + 1)
18:52:47 <lambdabot>   [2,3,4,5,6,7,8,9,10]
18:53:00 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= (map (\x -> x+1))
18:53:01 <lambdabot>   [2,3,4,5,6,7,8,9,10]
18:53:12 <Eduard_Munteanu> (>>=) = flip concatMap for lists IIRC
18:53:27 <Funktorsalat> [] could be understood as polynomials
18:53:32 <Funktorsalat> for that Num instance
18:53:39 <unkanon> so this means that
18:53:43 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= (map (\x -> x))
18:53:44 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:53:48 <Eduard_Munteanu> Which makes sense if you take 'fmap = map', 'join = concat'
18:53:54 <unkanon> id = (map (\x -> x)) ????
18:54:19 <unkanon> i thought id was \x -> x
18:54:21 <dobblego> forall x. map id x = id x 
18:54:40 <Eduard_Munteanu> unkanon: here id takes a list into a list
18:54:41 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= (map . id)
18:54:42 <lambdabot>   Couldn't match expected type `[b]'
18:54:42 <lambdabot>         against inferred type `[a] -> [b...
18:54:46 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= (map id)
18:54:47 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:54:55 <Eduard_Munteanu> > id 1
18:54:55 <lambdabot>   1
18:55:00 <Eduard_Munteanu> > id [1, 2]
18:55:00 <lambdabot>   [1,2]
18:55:06 <unkanon> Eduard_Munteanu: right, it's all about the types
18:55:46 <Funktorsalat> > map id undefined `seq` "oh hai"
18:55:47 <lambdabot>   "*Exception: Prelude.undefined
18:55:55 <Funktorsalat> damn ;)
18:55:58 <Eduard_Munteanu> unkanon: on the other hand, you can't do (+) on lists
18:56:16 <unkanon> > [ [1,2,3], [4], [], [], [5,6], [7,8,9] ] >>= (map (+1))
18:56:17 <lambdabot>   [2,3,4,5,6,7,8,9,10]
18:56:35 <Funktorsalat> so "map id x = id x" is actually literally true? :o
18:56:44 <Funktorsalat> or = x for what matter
18:57:06 <Eduard_Munteanu> Why would it?
18:57:19 <Eduard_Munteanu> id :: a -> a
18:57:23 <Eduard_Munteanu> map id :: [a] -> [a]
18:57:38 <Funktorsalat> assuming it types
18:58:04 <Eduard_Munteanu> Oh... well, yeah.
18:58:23 <Eduard_Munteanu> @free map id
18:58:23 <lambdabot> Extra stuff at end of line
18:58:27 <Eduard_Munteanu> @free (map id)
18:58:27 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
18:58:42 * Eduard_Munteanu forgets that syntax all the time...
18:58:46 <Eduard_Munteanu> @free map
18:58:47 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
18:58:58 <Eduard_Munteanu> @free id
18:58:59 <lambdabot> f . id = id . f
18:59:07 <Eduard_Munteanu> Not much help there.
18:59:27 * Eduard_Munteanu can't really use djinn, but will try...
18:59:27 <unkanon> > join [ [1,2,3], [4], [], [], [5,6], [7,8,9] ]
18:59:28 <lambdabot>   [1,2,3,4,5,6,7,8,9]
18:59:38 <Eduard_Munteanu> @djinn map id
18:59:38 <lambdabot> -- f cannot be realized.
18:59:51 <Funktorsalat> Eduard_Munteanu: my concern is just about seq
18:59:59 <Eduard_Munteanu> Anyway. I was hoping it was something subtle.
19:00:19 <Eduard_Munteanu> Oh.
19:00:42 <unkanon> yeah, still hazy for me, but i gotta go now. will study more tomorrow. thanks for the help, guys.
19:00:55 <Funktorsalat> > (id . undefined) `seq` "meow"
19:00:56 <lambdabot>   Ambiguous type variable `f' in the constraint:
19:00:56 <lambdabot>    `GHC.Base.Functor f'
19:00:56 <lambdabot>     ...
19:01:07 <Funktorsalat> > (id . undefined :: Int -> Int) `seq` "meow"
19:01:08 <lambdabot>   "meow"
19:01:18 <Funktorsalat> > undefined `seq` "meow"
19:01:19 <lambdabot>   "*Exception: Prelude.undefined
19:01:27 <Funktorsalat> thus, id . f = f fails
19:01:36 <Funktorsalat> (as an example of seq probs)
19:05:19 <Funktorsalat> > fst . (undefined &&& negate :: Int -> (String,Int)) `seq` "done"
19:05:20 <lambdabot>   "done"
19:05:36 <Funktorsalat> another failed one that ought to be true
19:05:43 <Funktorsalat> (fst . (f &&& g) = f)
19:06:09 <Funktorsalat> for (,) to be a categorical product with mediating arrow constructed by (&&&) tha tis
19:08:03 <Eduard_Munteanu> :t (&&&)
19:08:04 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
19:08:28 <Funktorsalat> but "map id" is fine I suppose, as there aren't any lambdas involved in the expansion
19:09:01 <Funktorsalat> Eduard_Munteanu: I meant the specialization of (&&&) to a = (->)
19:09:23 <Funktorsalat> (f &&& g) x = (f x , g x)
19:09:38 <Eduard_Munteanu> Ah.
19:09:56 * Eduard_Munteanu only partially remembers category products from Awodey...
19:10:41 <Eduard_Munteanu> Got TAPL and I kinda liked it, Awodey is on hold at the moment.
19:11:11 <Funktorsalat> they're usually defined in terms of "for all [...] there exists a unique morphism into the product [...]"
19:11:20 <Funktorsalat> (&&&) makes that 'exists a unique' constructive
19:11:52 <Funktorsalat> then the properties of the product imply that fst . (f &&& g) = f and snd . (f &&& g) = g should hold
19:12:10 <Funktorsalat> (and (fst . h &&& snd . h) = h, due to uniqueness)
19:12:13 <Eduard_Munteanu> Some sort of universal mapping property?
19:12:15 <Funktorsalat> yes
19:12:20 <Eduard_Munteanu> Makes sense.
19:12:46 <jmcarthur> @faq Does Q do anything?
19:12:46 <lambdabot> The answer is: Yes! Haskell can do that.
19:14:04 <Funktorsalat> jmcarthur: the Q monad?
19:14:30 <Funktorsalat> iirc Q a = Q (forall m. MonadQuasi m => a)
19:14:35 <Funktorsalat> iirc Q a = Q (forall m. MonadQuasi m => m a)
19:15:05 <Funktorsalat> maybe you could call that a sort of free implementation of the typeclass :)
19:35:58 <kyagrd> Is there a good way to derive instances for nested datatypes?
19:37:53 <kyagrd> http://hpaste.org/41075/deriving_instance_for_nested_d
19:38:17 <kyagrd> This one doesn't work it
19:38:30 <kyagrd> It compiles but when you try to print out can't
19:39:03 <kyagrd> If you delcare the nested data directly instead of encoding them as Functor and Fix then it works
19:49:45 <Funktorsalat> kyagrd: no idea but what happens when you try to use it?
19:50:17 <Funktorsalat> "deriving instance" for funny types used to refuse to work, but has been changed to "at your own risk" recently :)
19:51:08 <kyagrd> Funktorsalat: well I am making a type that use non-regular recursion
19:51:36 <kyagrd> its shape is like Cons 1 (Cons (1,1) (Cons ((1,1),(1,1)) Nil)))
19:51:51 <kyagrd> So the problem is instances of type gets larger
19:52:11 <kyagrd> So when try to print out it complains that it cannot construct instance after trying 20 times expanding
19:52:47 <Funktorsalat> ah. you have UndecidableInstances on I assume
19:52:50 <kyagrd> However, data Nest a = NNil | NCons a (Nest (a,a)) derving Show   works
19:53:12 <kyagrd> Funktorsalat: yes I think I used UndecidableInstances maybe I should remove that
19:53:35 <Funktorsalat> the '20 times' thing is due to that usually, but I think your code won't compile without it
19:53:49 <Funktorsalat> deriving instance (Show a, Show (nest (a,a))) => Show (NestF a nest)
19:53:57 <dolio> That instance for NFix necessarily uses undecidable instances.
19:54:01 <kyagrd> Funktorsalat: it doesn't compile i need the undecidable instance
19:54:05 <kyagrd> right
19:54:43 <kyagrd> This is from the paper http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.42.1517 generalized folds for nested datatypes
19:54:58 <Funktorsalat> I think that fails because "nest (a,a)" in turn gets unified with the RHS of that instance?
19:55:05 <Funktorsalat> causing a loop or divergence
19:55:27 <Funktorsalat> with what ist that 'nest' var instantiated in the end/
19:55:28 <Funktorsalat> ?
19:56:29 <Funktorsalat> NFix NestF?
19:57:21 <kyagrd> something like that
19:57:40 <dolio> Does just deriving the NFix instance work?
19:58:08 <Funktorsalat> so it searches like... Nest Int  = NFix NestF Int <= NestF Int (NFix NestF) <= NFix NestF (Int,Int)
19:58:38 <Funktorsalat> <= NestF (Int,Int) (NFix NestF) <= NFix NestF ((Int,Int),(Int,Int))
19:58:42 <Funktorsalat> you can see how it diverges
19:58:46 <kyagrd> right and goes on and on
19:59:23 <kyagrd> The question is even if I were to write manual instance where should I break this loop is the question.
19:59:36 <kyagrd> If it is going to work at all
19:59:56 <Funktorsalat> IIRC this makes balanced binary trees or so?
20:01:40 <kyagrd> Yes
20:02:36 <kyagrd> Well one can write isntances for (Nest a) manually
20:02:51 <kyagrd> I was just wondering if that was the only way
20:03:05 <lars9> can anyone explain this: [] >> return 5 results in [], but [()] >> return 5 results in [5]
20:03:16 <lars9> what is [()]?
20:03:23 <ddarius> :t [()]
20:03:23 <lambdabot> [()]
20:03:30 <kyagrd> how great
20:03:45 <kyagrd> > () : []
20:03:46 <lambdabot>   [()]
20:03:57 <ddarius> @src ()
20:03:57 <lambdabot> data () = ()
20:04:01 <lars9> () is just a meanlingless item, to take a slot?
20:04:11 <roconnor> > "four" >> return 4
20:04:12 <lambdabot>   [4,4,4,4]
20:04:13 <kyagrd> lars9, every constructor is meaningless
20:04:17 <Funktorsalat> kyagrd: maybe "Show (Nest a) => Show (Nest (a,a))"?
20:04:19 <kyagrd> meaning is givn by its use
20:04:30 <Funktorsalat> (or the equivalent for NestF)
20:04:39 <ddarius> kyagrd: This one is a little more meaningless than others...
20:04:43 <lars9> kyagrd: i see
20:04:43 <Funktorsalat> as an overlapping instance with "Show a => Show (Nest a)"
20:04:51 <Funktorsalat> not sure...
20:05:33 <kyagrd> trying
20:07:52 <kyagrd> Funktorsalat: it almst worked except that there is overlapping instance :)
20:08:26 <Funktorsalat> {-# LANGUAGE OverlappingInstances #-}
20:08:59 <kyagrd> Yes I am going on that path :)
20:09:05 <Funktorsalat> it's generally discouraged but I don't see any other way
20:09:32 <kyagrd> Funktorsalat: it wokrs, I think in this case it is harmless
20:10:05 <kyagrd> Funktorsalat: by the way just a question on logic-TPTP design
20:10:38 <kyagrd> Funktorsalat: It seems that we can factor out T and F and just use one newtype Fix = In { ... }
20:11:53 <kyagrd> It saves some lines from the library side (especially the stand alone isntance derving since we only need to do it once), I'm not sure if it would be practically a good idea for library users though.
20:12:14 <Funktorsalat> I don't remember, I think I tried something similar but had similar concerns ;)
20:12:57 <kyagrd> Funktorsalat: there was also discussion on this subejct recently on haskell mailing list
20:13:29 <Funktorsalat> of course, one could have both with converter functions between them ;)
20:14:03 <Funktorsalat> I'd say the explicit recursion makes it harder to use due to having to write the extra In's when pattern matching something
20:15:16 <Funktorsalat> I once started writing a package that makes the closed-recursive datatype from the open one automatically (or maybe the other way)
20:15:23 <Funktorsalat> but that folds get so complicated for gadts ;)
20:15:27 <Funktorsalat> s/that/the/
20:15:50 <kyagrd> Funktorsalat: yes in the discussion there were discussions about the extension of the pattern 
20:16:04 <kyagrd> to make pattern matching syntax a bit simple I 
20:16:24 <Funktorsalat> (actually they're complicated for nested type already, too)
20:16:28 <kyagrd> I'm trying to dig that out there's a lot of load comming up in h-cafe these days
20:16:51 <Funktorsalat> especially if you try to give the strongest possible type for the fold, rather than demanding that the argument function to the fold is totally polymorphic
20:19:28 <Funktorsalat> I think preprocessing is the way to go here instead of trying to encode very high abstractions in the type system, if you want to produce something usable
20:19:42 <lars9> what's the physical meaning of Sum in Data.Monoid?
20:20:02 <lars9> @:src Sum
20:20:02 <lambdabot> Source not found. Are you on drugs?
20:20:08 <Axman6> > (Sum 3) `mappend` (Sum 5)
20:20:09 <lambdabot>   Sum {getSum = 8}
20:20:22 <kyagrd> Funktorsalat: "Scrap your rolls/unrolls" was the title 
20:21:07 <kyagrd> Funktorsalat: http://comments.gmane.org/gmane.comp.lang.haskell.cafe/82377
20:23:37 <Funktorsalat> kyagrd: good idea :) (in that posting)
20:23:40 <kyagrd> hmm that gmane link is missing may of the postings in the discussion
20:23:57 <kyagrd> there are actually more articles in the thread still it's interesting
20:24:13 <kyagrd> I'll put those notes into the logic-TPTP repository as well
20:25:30 <Funktorsalat> I'll look in kmail
20:33:04 <kyagrd> Funktorsalat: oh it does have all the messages in that gmane webpage too It is just abbreviated and have to click on (continue to read)
20:41:22 <Funktorsalat> I underestimated type synonym families :)
20:43:05 <Funktorsalat> I filed them under "equivalent to a bunch of type syns with suffixes" but something is going on there
20:43:08 <Kaidelong> I am having trouble grasping why the people who made Chart figured variadic functions are a good thing
20:44:53 <fengshaun> is there any library to do combinations and permutations?
20:45:17 <Martty> > permutations [1..4]
20:45:17 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
20:45:31 <fengshaun> Martty, damn, it's built-in :O
20:45:39 <fengshaun> thanks
20:45:54 <fengshaun> :t combinations
20:45:55 <lambdabot> Not in scope: `combinations'
20:46:00 <fengshaun> :(
20:46:11 <fengshaun> :t `comb`
20:46:12 <lambdabot> parse error on input ``'
20:46:18 <fengshaun> :t comb
20:46:19 <lambdabot> Not in scope: `comb'
20:47:39 <fengshaun> > [[a, b, c] | a <- [1..4], b <- [1..4], c <-[1..4]]
20:47:40 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1,3,1],[1...
20:47:50 <fengshaun> that should work
20:51:02 <lars9> how to run 'src' command in ghci?
20:59:03 <dancor> lars9: http://www.haskell.org/ghc/docs/6.12-latest/html/users_guide/ghci-commands.html
20:59:20 <dancor> lars9: i think you want :l
21:01:07 <lars9> dancor: thanks:)
21:05:19 <Funktorsalat> hmm say the ghc 7 release notes: "# It is now possible to quasi-quote existentials and GADTs. "
21:05:31 <Funktorsalat> but doesn't seem to work for me
21:15:24 <colin_> Does anyone know a way around this error when building a Haskell program? "could not read symbols: Memory exhausted"
21:15:32 <colin_> I'm on a VPS with limited resources
21:20:02 <colin_> I also tried building the lib on a different computer and pasting the files in .cabal/lib but cabal still tries to compile it.  Is there a way to manually mark a package as build built/installed in cabal?
21:20:18 <monochrom> not sure if -split-objs helps
21:21:42 <monochrom> ghc does not consult .cabal/whatever for what libs are installed. ghc keeps its own metadata. in fact "cabal install" begs ghc to update that metadata.
21:21:59 <colin_> I tried split-objs and it didn't help
21:22:16 <colin_> but how does cabal know if a package is installed or not?
21:22:30 <monochrom> cabal begs ghc too for that query
21:24:54 <colin_> so if I have a folder with .a, .o and .hi files how can i register the lib with ghc?
21:28:07 <monochrom> least typing: on build host, "cabal unpack the-package", "cd the-directory", "cabal configure", "cabal build", now transfer the whole directory to target host, "cabal copy", "cabal register". This procedure is fragile; some preconditions apply.
21:28:16 <monochrom> there are other ways. all fragile.
21:29:45 <colin_> hmm
21:31:46 <monochrom> My planned article of "storage and identification of cabalized packages" is long overdue.
21:32:14 <monochrom> and yes I deliberately ensure it enjoys the acronym "sicp"
21:33:34 <colin_> I wish I could just build it...
21:37:23 <u_quark> hello, is there a way to make lists unboxed, eg. put them in a IOUArray for faster access ?
21:38:48 * hackagebot cgi 3001.1.7.4 - A library for writing CGI programs  http://hackage.haskell.org/package/cgi-3001.1.7.4 (AndersKaseorg)
21:42:00 <injection> in GHCi, is there a way to "pop" an environment/let frame/whatever?
21:42:49 <Saizan> what do you mean by pop?
21:42:57 <Axman6> u_quark: Dons has a package that uses specialised lists for each type, using type families. check it out
21:43:09 <injection> restore the state to what it was before the last 'let'
21:43:35 <Saizan> then no
21:44:59 <injection> thanks
21:46:19 <u_quark> Axman6: the name of the package ?
21:46:28 <Axman6> not sure, check his blog
21:46:31 <u_quark> ok
21:49:41 <u_quark> Axman6: this one http://donsbot.wordpress.com/2009/10/11/self-optimizing-data-structures-using-types-to-make-lists-faster/ ?
21:49:53 <Axman6> looks like it
21:50:25 * EvanR walks into the channel and sits at the bar
21:50:31 <EvanR> lambdabot, get me a beer
21:53:05 <EvanR> :t genericReplicate
21:53:06 <lambdabot> forall i a. (Integral i) => i -> a -> [a]
21:53:22 <EvanR> > genericReplicate (-6) '0'
21:53:23 <lambdabot>   ""
22:11:24 <pelotom> what's the flag to suppress a library when running ghc?
22:12:15 <pelotom> and which should I suppress, mtl or monads-fd?
22:13:47 <pelotom> ah, -hide-package
22:13:48 <u_quark> pelotom: -hide-package package-name ... I am not sure witch one you should hide
22:13:58 <Eduard_Munteanu> :t traverse4
22:13:59 <lambdabot> Not in scope: `traverse4'
22:14:01 <pelotom> u_quark: thanks :)
22:14:08 <Eduard_Munteanu> @hoogle traverse4
22:14:09 <lambdabot> No results found
22:14:34 <Eduard_Munteanu> Anyway, Repa looks nice, though the fun sigs are a bit long.
22:23:53 <tianyi> newbie question: in ghci, how can I unload a module loaded using ":load SomeModule"? How can I unload Prelude? Thanks.
22:24:09 <Funktorsalat> instance [overlap ok] (Typeable1 s, Typeable a) => Typeable (s a) -- why the (Typeable a)?
22:24:34 <Funktorsalat> for reference: class Typeable2 t where typeOf2 :: t a b -> TypeRep
22:24:58 <Funktorsalat> er, better reference ;) : class Typeable1 t where typeOf1 :: t a -> TypeRep
22:25:21 <Funktorsalat> instance (Typeable1 s) => Typeable (s a) where typeOf x = typeOf1 x
22:25:27 <Funktorsalat> is how I'd do it
22:26:55 <Axman6> how do you use exists x. in types?
22:27:34 <Funktorsalat> hmm I think I answered my own question...
22:27:50 <Funktorsalat> the implementations of typeOf2 ignore the 'a' and the 'b'
22:28:05 <Funktorsalat> they return just the unapplied TypeRep
22:28:19 <Funktorsalat> not the TypeRep of 't a b'
22:28:39 <Funktorsalat> so I guess I need my own class "AllTypeable2" for what I have in mind.
22:29:10 <Eduard_Munteanu> Axman6: you don't, 'exists' isn't defined as a keyword (at least by GHC).
22:29:25 <Axman6> hmm
22:29:34 <Funktorsalat> Axman6: translate to forall
22:29:49 * Axman6 will check how dons does it
22:29:51 <Eduard_Munteanu> Axman6: for existentials / rank-N types use forall
22:30:13 <u_quark> doesn't all type classes imply an exists in the type ?
22:31:09 <Saizan> u_quark: how?
22:31:52 <Eduard_Munteanu> According to a few people in here, a true 'exists' can't really be implemented.
22:32:15 <u_quark> Show a => a -> String doesn't imply an existential type for the parameter a ... it's like writing there exists a type a that ... not ?
22:32:22 <Eduard_Munteanu> Hence the forall that constructs an existential.
22:32:45 <dolio> Can't be implemented?
22:33:19 <Eduard_Munteanu> dolio: I'm not sure about that. Can it?
22:33:33 <dolio> What do you mean by that?
22:34:07 <Eduard_Munteanu> I mean, is it consistent from a type-theoretic POV to allow 'exists' in any place in a type, like forall?
22:34:16 <dolio> Yes.
22:35:09 <dolio> See, for instance, First-Class Polymorphism with Existential Types by Daan Leijen.
22:35:20 <Eduard_Munteanu> dolio: "but..." ? There must be a but, some were skeptical about the possibility of an 'exists'. Not sure in what way.
22:35:24 <Saizan> u_quark: not anymore than "a -> String" would, and since we generally consider type vars to be implicitly introduced by a forall it doesn't at all
22:35:35 <Eduard_Munteanu> dolio: I'll look it up if it's somewhere online, thanks.
22:35:42 <dolio> SPJ has complained before that it makes the type system too complex for his tastes.
22:35:51 <dolio> Or something like that.
22:36:05 <Eduard_Munteanu> Admittedly rank-N types isn't far from that.
22:36:23 <dolio> UHC has an exists keyword, too.
22:36:28 <Saizan> u_quark: foo :: Show a => a -> String, means that foo is a function that given a type 'a' such that it's an instance of Show then you get a function from that type to String
22:36:41 <dolio> It doesn't allow you to package type classes with them, though.
22:36:44 <Saizan> u_quark: it doesn't at all imply that such an 'a' exists
22:36:52 <Eduard_Munteanu> dolio: ah, I heard some did, but I thought they were simply mapped to 'forall', just like in the proposal.
22:37:37 <Eduard_Munteanu> http://hackage.haskell.org/trac/haskell-prime/wiki/ExistentialQuantification#Syntaxofexistentials 
22:37:55 <Eduard_Munteanu> ... or this ^ is a bit misleading.
22:38:25 <Eduard_Munteanu> I'm referring to "exists before the constructor"
22:39:02 <dolio> Well, say what you want about the existential syntax in GHC, I don't think exists before the constructor makes sense.
22:39:04 <u_quark> Saizan: i see
22:39:37 <Eduard_Munteanu> dolio: yeah, I agree, I got misled by that too before.
22:39:52 <dolio> If you want to use exists, it should come after the constructor.
22:40:15 <dolio> Although, that doesn't work well with types like 'data Foo = forall s. Foo s (s -> s) ...'
22:40:35 <dolio> It'd have to become 'data Foo = Foo (exists s. (s, s -> s, ...))'.
22:40:46 <dolio> At which point, you'd want newtypes.
22:40:51 <Eduard_Munteanu> Yeah, I'm aware about the forall <-> exists relationship, though I'm not sure how/if it translates to 'data'.
22:41:03 <Saizan> this is purely cosmetic anyway
22:41:23 <Saizan> a real exists would be allowed in types, not just in data declarations
22:41:30 <dolio> Yes.
22:41:43 <Eduard_Munteanu> Yeah, rank-N types.
22:42:27 <Eduard_Munteanu> Maybe it makes more sense to see exists to build an existential / rank-N with existential semantics.
22:43:01 <Eduard_Munteanu> dolio: is UHC's a true 'exists' or simply an alias for 'forall'?
22:43:22 <dolio> It's real exists, as far as I know.
22:43:39 <Eduard_Munteanu> Ah, maybe I'll have some fun with it some time.
22:43:49 <dolio> If it were an alias, you'd probably be able to use it with type classes, but you can't.
22:43:59 <dolio> Unless they've improved that.
22:44:26 <Eduard_Munteanu> I wonder if they make sense at all in type classes.
22:44:54 <dolio> No, I mean you can't do: (exists t. Show t => t).
22:45:08 <dolio> Or, a better syntax would be: (exists t. Show t *> t)
22:45:19 <dolio> Or something like it.
22:45:20 <Eduard_Munteanu> Oh, 'with'. With typeclass constraints.
22:45:44 <dolio> You can only do: (exists t. (t -> String, t)) and the like
22:46:36 <Eduard_Munteanu> I see. Thanks for the info, I have to go.
22:46:37 <Eduard_Munteanu> o/
22:47:37 <mtnviewmark> uh oh -- Hayoo is down
22:52:30 <Axman6> dolio, would you be able to have a look at this for me, and help me figure out what i need to do to make what i'm trying to do work? http://hpaste.org/41081/specialised_stream_fusion
22:52:46 <Axman6> uh, i'll paste the error too
22:53:07 <Axman6> http://hpaste.org/paste/41081/error#p41082
22:55:16 <dolio> Axman6: You have dictionaries for (Steps s a) and (Steps s b), but there's no guarantee that s is the same one packaged in the existential.
22:55:46 <Axman6> any idea how i might fix this? :\
22:56:05 <Axman6> is what i;m trying to do something that even makes sense?
22:56:10 <dolio> Put the constraint on Stream.
22:56:24 <Axman6> which constraint?
22:56:53 <dolio> data Stream a = forall s. Steps s a => Stream (s -> Step s a) !s Int
22:57:10 <Axman6> ah, ok, i'll try that
22:57:19 <dolio> That actually doesn't solve all the problems, though.
22:57:33 <dolio> Because you can't use Steps s a to get a Steps s b.
22:58:53 <Axman6> is that fixable?
22:58:59 <Funktorsalat> is there a name for this property of G and P: if G a b has property P, then a and b have it too
22:59:07 <dolio> I don't think it's fixable with that setup.
22:59:14 <Axman6> :(
22:59:21 <Funktorsalat> ah, 'reflects P' is what I was thinking of
22:59:46 <Axman6> making specialised data types in haskell is never as easy as i'd hope it would be
22:59:48 <dolio> But, s doesn't need to be an index.
22:59:55 <dolio> As far as I can tell.
23:00:08 <Axman6> what do you mean by an index?
23:00:30 <dolio> So: class Steps k where { data Step k :: * -> * ; ... }
23:00:57 <dolio> instance Steps Int where { data Step Int s = YieldInt {-# UNPACK #-} !Int !s | ...
23:01:34 <Axman6> i'll give that a go
23:01:40 <dolio> A better name for the class might be unpack, or something.
23:01:44 <dolio> Unpack, even.
23:02:57 <Axman6> ooo, it compiled :O
23:03:03 <dolio> data Stream a where Stream :: Unpack a => (s -> Step a s) -> !s -> Int -> Stream a
23:03:15 <dolio> mapS :: (a -> b) -> Stream a -> Stream b
23:03:27 <dolio> Wait, that's still wrong. :)
23:03:45 <dolio> I guess you can put the constraints on mapS with that setup.
23:06:53 <pelotom> it's too bad there's not a way to tell haskell that any monad instance is also an applicative
23:07:05 <pelotom> No instance for (Applicative STM)
23:07:19 <pumpkin> it will be applicative soon
23:07:20 <pelotom> or is there?
23:07:24 <c_wraith> you *can* tell it that.
23:07:34 <c_wraith> But it will create horrible overlapping instances everywhere
23:07:44 <pelotom> ah
23:09:06 <Axman6> dolio: it's working :D thanks a lot, remind me to buy you a beer if we ever meet
23:09:14 <dolio> Heh, all right.
23:11:25 <pelotom> will Monad ever be defined as Applicative m => Monad m where...?
23:15:38 <Axman6> dolio: reckon anyone would find this stuff interesting/useful? i'm hoping it's slightly faster than dons' stream fusion stuff
23:16:26 <dolio> I'll be interested to see if it's faster.
23:17:00 <pelotom> c_wraith: so you're saying this is a bad idea? http://hpaste.org/41083/bad_idea
23:17:15 <Axman6> i ahev a feeling it won't, or it'll only be slightly faster due to there being less indirection
23:17:29 <dolio> I'm not really sure how much boxing goes on in most stream fusion stuff.
23:17:49 <dolio> Ideally, once GHC does constructor specialization, it could also do unboxing.
23:18:10 <Axman6> hm, true
23:18:22 <dolio> But, I haven't looked at any examples, really.
23:18:35 <Axman6> though this might be a way to be able to provide more specialised versions for more exotic types, like Either
23:21:58 <EvanR> Either is exotic? ;)
23:22:30 * dolio hits the hay.
23:22:32 <Axman6> well, for this sort of thing it could be
23:24:49 <JoshTriplett> How can I create a UArray or similar backed directly by a Ptr or ForeignPtr that I already have?
23:25:56 <pelotom> c_wraith: ahh, I see how it can be problematic
23:26:50 <Saizan> JoshTriplett: http://hackage.haskell.org/packages/archive/storablevector/0.2.7/doc/html/Data-StorableVector-Base.html
23:28:13 * JoshTriplett just found unsafeForeignPtrToStorableArray, as well.
23:28:24 <JoshTriplett> Saizan: Any particular reason to use one over the other?
23:28:42 <Saizan> JoshTriplett: i wouldn't know
23:29:49 <lars9> how to write [x*y|x<-[1..10],y<-[2..9]] with >>= and >> notation?
23:31:01 <pelotom> > [1..10] >>= \x -> [2..9] >>= \y -> return (x*y)
23:31:02 <lambdabot>   [2,3,4,5,6,7,8,9,4,6,8,10,12,14,16,18,6,9,12,15,18,21,24,27,8,12,16,20,24,2...
23:31:29 <EvanR> there needes to be a '>>=' for monoids
23:31:43 <pumpkin> @undo [x*y|x<-[1..10],y<-[2..9]]
23:31:43 <lambdabot> concatMap (\ x -> concatMap (\ y -> [x * y]) [2 .. 9]) [1 .. 10]
23:31:52 <EvanR> mcatmap :: Monoid m => [a] -> (a -> m) -> m
23:31:54 <pumpkin> @@ @redo @undo [x*y|x<-[1..10],y<-[2..9]]
23:31:54 <lambdabot> Plugin `compose' failed with: Unknown command: "redo"
23:32:01 <pumpkin> @@ @do @undo [x*y|x<-[1..10],y<-[2..9]]
23:32:01 <lambdabot>  concatMap (\ x -> concatMap (\ y -> [x * y]) [2 .. 9]) [1 .. 10]
23:32:05 <pumpkin> @@ @do @undo [x*y|x<-[1..10],y<-[2..9]]
23:32:05 <lambdabot>  concatMap (\ x -> concatMap (\ y -> [x * y]) [2 .. 9]) [1 .. 10]
23:32:09 <pumpkin> @@ @do @pl @undo [x*y|x<-[1..10],y<-[2..9]]
23:32:10 <lambdabot>  ([2 .. 9] >>=) . flip flip [] . ((:) .) . (*) =<< [1 .. 10]
23:32:17 <JoshTriplett> ow
23:32:18 <lars9> is it possible to not use (\x ->) ?
23:32:18 <Saizan> ?type Data.Foldable.foldMap -- EvanR 
23:32:19 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
23:32:35 <pumpkin> @@ @do @unpl @pl @undo [x*y|x<-[1..10],y<-[2..9]]
23:32:35 <lambdabot>  (\ k -> do { g <- ([2 .. 9]); ((:)) ((do { a <- ([1 .. 10]); (*) a}) k g) []})
23:32:39 * pumpkin gives up
23:32:42 <JoshTriplett> lars9: well, if you prefer...
23:32:43 * EvanR gets washed away in spam
23:32:50 <JoshTriplett> > liftM2 (*) [1..10] [2..9]
23:32:51 <lambdabot>   [2,3,4,5,6,7,8,9,4,6,8,10,12,14,16,18,6,9,12,15,18,21,24,27,8,12,16,20,24,2...
23:33:14 <lars9> JoshTriplett: yeah, great
23:33:20 <JoshTriplett> (*) <$> [1..10] <*> [2..9]
23:33:24 <JoshTriplett> > (*) <$> [1..10] <*> [2..9]
23:33:25 <lambdabot>   [2,3,4,5,6,7,8,9,4,6,8,10,12,14,16,18,6,9,12,15,18,21,24,27,8,12,16,20,24,2...
23:33:37 <EvanR> Saizan: cool
23:33:41 <lars9> JoshTriplett: not possible with monad notation?
23:33:50 <EvanR> Foldable seems to think theres a connection between folding and monoids?
23:33:56 <JoshTriplett> lars9: possible, just ugly. :)
23:34:00 <pelotom> lars9: you could do it with do notation if you really wanted
23:34:20 <pelotom> > do x <- [1..10]; y <- [2..9]; return (x*y)
23:34:20 <lambdabot>   [2,3,4,5,6,7,8,9,4,6,8,10,12,14,16,18,6,9,12,15,18,21,24,27,8,12,16,20,24,2...
23:35:03 <Saizan> EvanR: foldable is mostly about those types that can be seen as lists, and list is the free monoid
23:35:17 <JoshTriplett> > [1..10] >>= \x -> [2..9] >>= \y -> (x*y)
23:35:18 <lambdabot>   No instances for (GHC.Num.Num [b], GHC.Enum.Enum [b])
23:35:18 <lambdabot>    arising from a use...
23:35:25 <kyagrd>  You can also use InfixApplicative package
23:35:40 <JoshTriplett> > [1..10] >>= \x -> [2..9] >>= \y -> return (x*y)
23:35:41 <lambdabot>   [2,3,4,5,6,7,8,9,4,6,8,10,12,14,16,18,6,9,12,15,18,21,24,27,8,12,16,20,24,2...
23:35:48 <kyagrd> > [1..10] <^(*)^> [2..9]
23:35:49 <lambdabot>   Not in scope: `<^'Not in scope: `^>'
23:35:54 <kyagrd> ah lambdabot
23:35:55 <JoshTriplett> > [1..10] >>= \x -> [2..9] >>= return . (x*)
23:35:56 <lambdabot>   [2,3,4,5,6,7,8,9,4,6,8,10,12,14,16,18,6,9,12,15,18,21,24,27,8,12,16,20,24,2...
23:36:04 <JoshTriplett> kyagrd: those look like fascinating operators. ;)
23:36:26 <kyagrd> http://hackage.haskell.org/package/InfixApplicative
23:36:33 <EvanR> ah so its a connection between lists and monoids
23:36:33 <EvanR> monoid is the generalization of list
23:36:37 <Axman6> @src enumFromTo
23:36:37 <lambdabot> Source not found. I am sorry.
23:36:49 <Axman6> @src Enum
23:36:49 <lambdabot> class  Enum a   where
23:36:50 <lambdabot>     succ                     :: a -> a
23:36:50 <lambdabot>     pred                     :: a -> a
23:36:50 <lambdabot>     toEnum                   :: Int -> a
23:36:50 <lambdabot>     fromEnum                 :: a -> Int
23:36:51 <lambdabot> [3 @more lines]
23:36:53 <EvanR> no, doesnt make sense
23:37:22 <pelotom> list is just the free monoid
23:37:29 <EvanR> that foldMap is clearly using not the foldable (list like) to combine them
23:38:02 <EvanR> so im wondering why normal folding doesnt have anything to do with monoids
23:38:16 <JoshTriplett> @pl [1..10] >>= \x -> [2..9] >>= return . (x*)
23:38:17 <lambdabot> (`fmap` [2..9]) . (*) =<< [1..10]
23:38:40 <EvanR> this decaf tea is terrible
23:39:55 <kyagrd> @pl [x*y|x<-[1..10],y<-[2..9]]
23:39:55 <lambdabot> [x * y | x <- [1..10], y <- [2..9]]
23:39:58 <kyagrd> well
23:40:30 <pelotom> EvanR: foldable is more general than monoid... it can be defined for any inductive data structure
23:40:50 <Funktorsalat> mtl is transformers now?
23:41:24 <Saizan> foldMap doesn't have much to do with foldr in spirit, it's more like a composition of toList :: Foldable t => t a -> [a] and toMonoid :: Monoid m => (a -> m) -> [a] -> m
23:41:31 <EvanR> monoids are underappreciated, you only hear about monads and applicative functors
23:41:44 <Saizan> Funktorsalat: yeah, as orwellian as that might sound
23:42:03 <Funktorsalat> no more ambiguity errors at least...
23:42:48 <EvanR> pelotom: makes sense
23:42:58 <Saizan> even Foldable is a bit misguided as a name if you think of the datatype-generic concept of "fold"
23:43:24 <Saizan> it should be DesctructableAsIfItWasAList, except that it's ugly
23:44:53 <EvanR> toMonoid, thats mconcat right
23:45:57 <Saizan> toMonoid f = mconcat . map f
23:46:15 <EvanR> funny i just wrote that
23:47:08 <pelotom> kyagrd: that infix applicative thing is cool
23:47:35 <pelotom> kyagrd: is there a library that provides sugar for applicatives like [[f a b c d]]?
23:47:44 <EvanR> its the function i wanted in the first place
23:47:44 <EvanR> whats the foldable for then?
23:48:34 <pelotom> that would be even more useful to me
23:48:49 <kyagrd> I don't know
23:51:30 <Funktorsalat> Saizan: "Listable"? :)
23:52:22 <Funktorsalat> @ty Fold.toList
23:52:23 <lambdabot> Couldn't find qualified module.
23:52:31 <Funktorsalat> @ty Foldable.toList
23:52:32 <lambdabot> Couldn't find qualified module.
23:52:43 <Funktorsalat> @ty F.toList
23:52:43 <lambdabot> Couldn't find qualified module.
23:52:51 <Funktorsalat> I thought the bot had it.
23:57:23 <Saizan> ?type Data.Foldable.toList
23:57:24 <lambdabot> forall (t :: * -> *) a. (Data.Foldable.Foldable t) => t a -> [a]
