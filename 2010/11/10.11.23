the irony
10:37:34 <Twey> paolino: Not just OO, though
10:37:44 <Twey> jmcarthur: Heh
10:37:45 <n0den1te> I struggled with scala last year, so haskell has been kind to me so far. :)
10:37:49 <Borbus> Well thanks for the discussion guys, I now have some food to attend to :)
10:38:02 <copumpkin> I'm learning scala after haskell and it's not as bad as I thought it would be
10:38:07 <geheimdienst> "attend to" is a good euphemism for "nom"
10:38:09 <copumpkin> although some parts of it make me feel icky
10:38:11 <Twey> copumpkin: Isn't it impure?
10:38:17 <paolino> Twey, the only good thing in python is metaclasses and ruby does it better
10:38:19 <Twey> geheimdienst: Hehe
10:38:25 <copumpkin> Twey: pretty impure, but you can try to avoid the impurity :)
10:38:28 <Twey> paolino: CLOS does it better than either.
10:38:28 <jmcarthur> scala has a few cool things, but i mostly dislike it from what i've seen
10:38:29 <n0den1te> Twey: I wouldn't say impure. Hybrid would be more like it. 
10:38:30 <revenantphx> paolino: ruby also eats your ram/cpu
10:38:32 <copumpkin> Twey: it has typecase and "named instances"
10:38:41 <revenantphx> Ruby is nice though.
10:38:46 <revenantphx> My first language was ruby.
10:38:48 <Twey> I don't much like Ruby.
10:38:54 <Twey> What the heck's the deal with the sigils?
10:38:55 <jmcarthur> named instances are pretty cool
10:38:55 <revenantphx> It's not great, but it's fine.
10:38:55 <paolino> revenantphx: we are talking about learning
10:39:06 <revenantphx> Twey: agree
10:39:10 <jmcarthur> if they are the feature i think you are talking about
10:39:10 <Twey> â€˜Okay, this scope is magic, and so is this one.  The rest of them?  Eh, stuff 'emâ€™
10:39:11 <copumpkin> ruby used to be my favorite language, but haskell made it feel icky
10:39:19 <copumpkin> I still use it occasionally
10:39:22 <jmcarthur> more like a derived feature
10:39:54 <n0den1te> now that i'm looking at haskell, I see too many inspirations in scala from haskell (or it might be the other way round)
10:40:04 <paolino> copumpkin: that's is where you go with objects, after smalltalk
10:40:05 <jmcarthur> copumpkin: between ruby and haskell i used Io for a bit. it's no haskell, but i find it much less icky than ruby precisely because it takes the dynamicness and metaprogrammingness to extremes
10:40:08 <revenantphx> Does the new haskell fix the do notation indentation?
10:40:11 <revenantphx> That shit is confusing.
10:40:19 <n0den1te> I can't say I love one more than the other. I kinda like both. 
10:40:25 <copumpkin> revenantphx: I think so
10:40:30 <revenantphx> Io is fun.
10:40:38 <revenantphx> I haven't written anything serious in it, but it's fun to play with.
10:40:46 <revenantphx> You know what, you should just teach PHP.
10:40:50 <revenantphx> Best langauge ever.
10:40:56 <jmcarthur> @slap revenantphx 
10:40:57 * lambdabot decomposes revenantphx  into several parts using the Banach-Tarski theorem and reassembles them to get two copies of revenantphx !
10:41:06 <revenantphx> D:
10:41:09 <jmcarthur> just what we need. two revenantphxs
10:41:23 <n0den1te> @slap lambdabot
10:41:23 * lambdabot secretly deletes lambdabot's source code
10:41:29 <copumpkin> what is the plural of revenantphx anyway?
10:41:40 <Twey> Hehe
10:41:40 <jmcarthur> revenantphii
10:41:43 <revenantphx_> What
10:41:44 <revenantphx> What
10:41:51 <jmcarthur> in the butt?
10:41:53 <n0den1te> revenantphxx ?
10:41:58 <copumpkin> jmcarthur: !!!
10:42:02 <Twey> I think â€˜revenantphxâ€™ is the plural
10:42:08 <Twey> From â€˜revenantphcâ€™
10:42:12 <samwell> I said what what
10:42:15 <DylanLukes> fuck it.
10:42:19 <jmcarthur> haha
10:42:32 <DylanLukes> I might as well just use my name on freenode.
10:42:58 <dlukes> I hate how my name can't be shortened well at all.
10:43:18 <dlukes> > nub 'dylanlukes'
10:43:20 <lambdabot>   <no location info>:
10:43:20 <lambdabot>      lexical error in string/character literal at chara...
10:43:29 <dlukes> > nub "Dylan Lukes"
10:43:30 <lambdabot>   "Dylan Lukes"
10:43:32 <dlukes> >_>
10:43:50 <paolino> what I learned from haskell is that OO obscures abstractions and make people just library users, which is a no learning track
10:44:13 <Endiannes> paolino, Perhaps you never saw good OO.
10:44:42 <n0den1te> Endiannes: I think he's referring to how Java libraries interact with each other. 
10:44:50 <n0den1te> They really obscure the path. 
10:44:55 <dlukes> paolino: Well, remember that OO is most convenient for enterprise often.
10:45:05 <dlukes> They don't WANT to learn how the libraries work
10:45:07 <dlukes> Just that they do.
10:45:11 <Endiannes> n0den1te, Oh, java has awfull libraries :(
10:45:16 <dlukes> There are some fun abstractions you can do with OO anyhow.
10:45:21 <dlukes> Like class clustering.
10:45:22 <n0den1te> Endiannes: exactly my point.
10:46:27 <paolino> dlukes: are we talking about learning or productivity ?
10:47:31 <paolino> and I'm waiting java on a 512 processor mobo at 500MHz clock, on productivity
10:47:34 <dlukes> well, learning, I'm just justifying some of the bad abstraction in OO.
10:48:32 <paolino> dlukes: sometimes I write OO in haskell , but I'm not obliged
10:48:40 <dlukes> Sure, OO is not a language feature imo.
10:48:52 <sipa1024> it's a paradigm ;)
10:48:54 <dlukes> It's an abstraction you can make use of in almost any language, provided you have structures.
10:49:11 <dlukes> It's nice to have some way to "attach" functions to the structures, but theres no need too.
10:49:21 <Darkone_> Hello
10:49:32 <Darkone_> Silly question I guess
10:49:36 <dlukes> ?
10:49:37 <paolino> dlukes: OO is a way of thinking, IMO
10:49:41 <dlukes> paolino: yep.
10:50:15 <Darkone_> But I don't understand the error it's giving me when I try      foo bar = doesFileExist bar >>= (\ x -> Just x)
10:50:38 <dlukes> > foo bad = doesFileExist bar >>= (\ x -> Just x)
10:50:39 <lambdabot>   <no location info>: parse error on input `='
10:50:45 <dlukes> try <- instead I think.
10:50:46 <paolino> Darkone_ you must return in the IO monad
10:50:51 * dlukes fails at monads.
10:50:59 <sipa1024> :t fail
10:51:00 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:51:10 <dlukes> > fail
10:51:11 <lambdabot>   Overlapping instances for GHC.Show.Show (GHC.Base.String -> m a)
10:51:11 <lambdabot>    arising...
10:51:22 <Darkone_> so (\x -> return x :: Maybe Bool)
10:51:24 <Darkone_> ?
10:51:37 <paolino> doesFileExist bar >>= \ x -> return (Just x)
10:51:40 <Darkone_> Or do you have to return the same monad?
10:51:40 <Saizan> doesFileExist is in the IO monad
10:51:53 <dlukes> > (\x -> return x :: Maybe Bool)
10:51:54 <lambdabot>   Overlapping instances for GHC.Show.Show
10:51:54 <lambdabot>                              (GHC.B...
10:52:13 <Saizan> but (\x -> Just x) :: Bool -> Maybe Bool there
10:52:14 <dlukes> > (\x -> return x :: Maybe Bool) true
10:52:14 <lambdabot>   Not in scope: `true'
10:52:24 <dlukes> > (\x -> return x :: Maybe Bool) True
10:52:25 <lambdabot>   Just True
10:52:31 <dlukes> that works.
10:52:38 <Saizan> while it must have a result type of IO Something
10:53:39 <dlukes> :t (\x -> return x :: Maybe Bool)
10:53:40 <lambdabot> Bool -> Maybe Bool
10:53:40 <Saizan> "foo bar = doesFileExist bar >>= (\ x -> return (Just x))" would typecheck, it doesn't seem very useful though
10:54:05 <Darkone_> Think I just need to rewrite it.
10:57:22 <Darkone_> There we go. Just changed it to something else.
11:03:16 <Darkone_> So I want to allow someone to enter a command like  True | speed = 2 * speed      I have an idea of how to do that and process it.
11:03:45 <Darkone_> But I suppose if I want pretty error messages, I should use something like writer to attach logging values to each operation performed and return the log if an operation fails?
11:04:23 <Darkone_> Assuming I check the command first and pass only valid commands, of course.
11:04:48 <Darkone_> Just so that someone doesn't have to hunt to find out why, say, a division is failing and it turn out to be a divby 0 issue.
11:05:03 <Darkone_> On a side note, it's QUIET in here o.O
11:06:15 <Darkone_> Or is my internet out >.>
11:06:22 <Zao> Darkone_: Yes.
11:06:30 <Darkone_> Ahh kay :P
11:13:47 --- mode: ChanServ set +o copumpkin
11:13:55 --- kick: snookered was kicked by copumpkin (dollars)
11:14:10 --- mode: copumpkin set -o copumpkin
11:22:23 <acemo> could someone explain why this example works for me, but when i change the function name to test or anything else, it gives me an parse error in pattern? http://en.wikibooks.org/wiki/Haskell/do_Notation#Example:_user-interactive_program
11:23:17 <paolino> paste your code also
11:23:23 <maltem_> acemo, you probably didn't line up the do block then
11:24:15 <acemo> maltem_: indeed that seems to have been the problem. Thanks
11:24:31 <Cale> Yeah, note that whitespace is important, and the lines of the do-block must all start in the same column. If you bump the first one, you have to adjust the rest of them. Unfortunately, editor support automating that is sketchy where it exists at all.
11:25:09 <Cale> One solution is to put a newline after the = sign or some people like it after the 'do'
11:25:28 <maltem_> A funny thing to write into a tutorial: “The <- notation makes it possible to store first and last names as if they were pure variables, though they never can be in reality.”
11:25:31 <McManiaC> http://npaste.de/qk/ monad comprehensions with filters :)
11:25:38 <acemo> Didn't think it would matter much since for function x | bla | bla stuff it doesn't matters
11:25:39 <Cale> Both of those will let you rename the function/add parameters/etc. without having to adjust the indentation of the block
11:26:10 <Cale> Yeah, that tutorial text looks a bit sketchy :)
11:26:32 <merijn> acemo: I'd recommend Learn You A Haskell over the wiki book, if you haven't looked at it yet
11:26:34 <merijn> @where lyah
11:26:35 <lambdabot> http://www.learnyouahaskell.com/
11:28:14 <acemo> merijn: i will, when i got more spare time.. at the moment i have too little time on hands and i was trying to use what we learned in haskell in a other subject
11:29:29 <benmachine> :\/
11:29:47 <benmachine> @vixen I missed you
11:29:47 <lambdabot> are you coming on to me?
11:29:49 <benmachine> yes.
11:41:28 * sleepynate gets popcorn
11:42:34 <Uta> any idea how to cast a pointer for example from Ptr CWchar to Ptr CUShort?
11:43:31 <kmc> :t castPtr
11:43:32 <lambdabot> Not in scope: `castPtr'
11:43:41 <kmc> :t Foreign.Ptr.castPtr
11:43:42 <lambdabot> forall a b. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
11:44:41 <kmc> of course there's no safety checking; it's just like a C pointer cast
11:45:13 <ursthegizmo> thanks thats what i searched
11:45:29 <portnov> @djinn (s -> a -> a) -> (a -> b -> b) -> (s -> b -> b)
11:45:30 <lambdabot> f _ _ _ a = a
11:45:48 <rjsimmon> I seem to have been attacked by this bug, which I used to accidentally hose my Agda installation http://hackage.haskell.org/trac/ghc/ticket/4513. The bug page reports a fix; does anyone here have a notion of how I could get things to work again (or, alternatively and perhaps even better, how long I should wait patiently for cabal to magically fix itself maybe?) I don't have any idea how these things work, cabal is a beautiful black box from my
11:46:00 * hackagebot idiii 0.1.1 - Reading and writing of ID3v2 tags  http://hackage.haskell.org/package/idiii-0.1.1 (ChrisWagner)
11:46:24 <mreh> hmm, monad transformer order can be subtle
11:46:26 <benmachine> rjsimmon: your message got cut off after "beautiful black box from my"
11:46:39 <rjsimmon> from my perspective. There wasn't much more to say
11:46:42 <benmachine> :P
11:46:45 <dcoutts_> rjsimmon: workaround is not to reinstall the haskell98 package
11:46:59 <mreh> RandT g Either a or EitherT (Rand g) a
11:47:24 <dcoutts_> rjsimmon: your tools are cabal install --dry-run  and you can bend it to your will using the --constraint='foo >= x.y' flag
11:47:25 <benmachine> I'm finding myself unable to clone git repos hosted on code.haskell.org
11:47:32 <benmachine> fatal: http://code.haskell.org/~mboes/mime-directory.git/info/refs not found: did you run git update-server-info on the server?
11:47:36 <rjsimmon> Let's imagine it's too late for that and I, say, trashed everything and started from a fresh Haskell Platform install :-(
11:47:46 <benmachine> I suppose I need to harass some people about their hooks
11:47:47 <mreh> can I use a polymorphic monad transformer?
11:47:53 <benmachine> mreh: what do you mean?
11:48:16 <dcoutts_> rjsimmon: ok, if you started from clean then presumably it's ok now?
11:48:38 <mreh> benmachine: you know you can generalise functions that fail to any old monad
11:48:46 <benmachine> mreh: mm
11:48:55 <rjsimmon> sure, until I try to install Agda, and then I run into the bug. Let me see if I can figure out what to make of your --dry-run comment, I haven't tried that before.
11:48:59 <portnov> @djinn (s -> a -> a) -> (a -> b) -> (s -> b -> b)
11:49:00 <lambdabot> f _ _ _ a = a
11:49:15 <mreh> what if I want that, but for a random function say>
11:49:31 <benmachine> portnov: that's pretty much the only way to implement that function
11:49:36 <benmachine> you might be looking for
11:49:51 <benmachine> @djinn (s -> b -> b) -> (a -> b) -> (s -> a -> b)
11:49:51 <lambdabot> f a b c d = a c (b d)
11:49:52 <benmachine> or something
11:49:59 <mreh> it doesn't fail randomly, so the failure monad transformer would be on the outside
11:50:28 <benmachine> mreh: I'm confused; you can only generalise failing functions because of the fail method in the Monad class
11:50:57 <mreh> benmachine: my thinking probably isn't clear yet
11:51:06 <benmachine> k
11:51:10 <benmachine> if it helps, neither is mine
11:54:46 <danielgomezrico> IM NEW IN HASKELL,
11:54:55 <danielgomezrico> CAN ANYONE HELP ME WITH AN ERROR?
11:55:11 <portnov> @djinn (s -> a -> a) -> (a -> b -> b) -> a -> (s -> b -> b)
11:55:11 <lambdabot> f _ a b _ c = a b c
11:55:12 <merijn> Unlike COBOL haskell and it's channel allow for lower case letters :>
11:56:01 <kmc> danielgomezrico, yes, just ask your question, preferably in lower case
11:56:01 <dcoutts_> rjsimmon: my bet is that you've got overlapped packages in your user and global package dbs, you'll want to blow away the user ones
11:56:08 <danielgomezrico> sorry
11:56:11 <danielgomezrico> look
11:56:11 <danielgomezrico> http://pastebin.com/Sse2D9Dm
11:56:24 <copumpkin> danielgomezrico: people just tend to associate uppercase on the internet with yelling
11:56:38 <danielgomezrico> the compiler say to me that there's possibly incorrect indentation
11:56:41 <kmc> danielgomezrico, in your "then" branch you do two things
11:56:44 <kmc> so you need "do" there
11:56:54 <kmc> also, don't indent so much; start stuff on the next line
11:56:57 <kmc> here one second
11:57:05 <mauke> danielgomezrico: you're calling print with 4 arguments instead of 1
11:57:28 <kmc> also it's (num `mod` lh) or (mod num lh)
11:57:58 <danielgomezrico> I can't understand
11:58:05 <kmc> and (num `div` lh)
11:58:07 <danielgomezrico> Where's the problem???
11:58:11 <mauke> danielgomezrico: you're calling print with 4 arguments instead of 1
11:58:17 <danielgomezrico> ooo the ''
11:58:37 <kmc> `` not ''
11:58:44 <kmc> (a `f` b) is the same as (f a b)
11:58:55 <kmc> > mod 7 2
11:58:56 <lambdabot>   1
11:58:58 <kmc> > 7 `mod` 2
11:58:59 <lambdabot>   1
11:59:08 <kmc> `` are used to make an ordinary name work like an infix operator
11:59:17 <danielgomezrico> :) yeah
11:59:24 <danielgomezrico> but the error persist
11:59:33 <kmc> danielgomezrico, http://hpaste.org/41743/for_danielgomezrico?pid=41743&lang_41743=Haskell
12:00:26 <dcoutts_> danielgomezrico: see lines 7 and 8, because you're missing the 'do', then those two lines are all one single expression, which is why mauke is saying you're calling print with 4 arguments
12:00:47 <danielgomezrico> Wow thanks!!!!
12:00:51 <dcoutts_> danielgomezrico: without the 'do', it literally reads as: print lh buscar (num div lh) (lh:lb)
12:01:44 <dcoutts_> danielgomezrico: it's the 'do' that introduces a block where each statement is on a separate line (indented to match up)
12:02:19 <dcoutts_> danielgomezrico: get it?
12:02:35 <danielgomezrico> mm, so, why I can't write like this http://pastebin.com/g7KmZxrg
12:03:13 <danielgomezrico> I can put a do into a do?
12:03:16 <dcoutts_> danielgomezrico: ok, now you've got the opposite problem
12:03:34 <rjsimmon> okay. So playing around with --dry-run -v, the reason it wants to reinstall haskell98 is to *downgrade* array, directory, old-time, and process a notch; Directory in particular seems to be the problem.
12:03:40 <dcoutts_> danielgomezrico: on line 6, you've got a 'do' block
12:03:57 <rjsimmon> Does this confirm your suspision about user vs. global package databases?
12:04:19 <rjsimmon> (last bit aimed at dcoutts_)
12:04:43 <dcoutts_> danielgomezrico: each line (where the indentation matches up) is expected to be a separate statement, but you've got the 'then' and 'else' as if they were statements, but an "if then else" is all just one expression
12:05:05 <mreh> hmm, you seem to argue that fail is always bad, but what about in the context of a generic Monad?
12:05:26 <danielgomezrico>  dcoutts_: but I want to run two different lines into a if then else estructure
12:05:29 <mreh> talking about chapter 18 of RWH
12:05:30 <dcoutts_> danielgomezrico: so you either have to indent the 'then' and 'else', or in this case since your 'do' only has a single statement in it anyway then you can remove the 'do'
12:05:34 <danielgomezrico> What's the way ?
12:06:12 <dcoutts_> rjsimmon: you running ghc 7 or something?
12:06:25 <danielgomezrico> Can you show me the code indented please?
12:06:33 <danielgomezrico> dcoutts_: please
12:07:05 <rjsimmon> dcoutts_: 6.12.3 - like I said, I tried to just get the OSX bundle of GHC from the Platform page, install Platform, and run from there. 
12:07:06 <dcoutts_> danielgomezrico: indent the 'then' and 'else' lines so that they are in a bit from the 'if'
12:07:08 <ivanm> danielgomezrico: just indent the "then" and "else" slightly compared to the "if"
12:07:27 <danielgomezrico> :)
12:08:58 <danielgomezrico> Thanks so much
12:08:59 <danielgomezrico> :)
12:09:16 <paolino> danielgomezrico: also eliminate the "do" before the "if"
12:09:36 <dcoutts_> rjsimmon: odd, perhaps you can paste the output of cabal install --dry-run -v Agda
12:09:46 <danielgomezrico> Wow
12:10:03 <danielgomezrico> I dont know why I put that do there :P
12:10:04 <danielgomezrico> thanks
12:10:05 <danielgomezrico> again
12:10:25 <romildo> Regarding regex in Haskell, why does the following does not work as expected in ghci-7.0.1, giving a no instance error?
12:10:26 <romildo> "a:bc67 d:efg mi:d2 z:mn86 end" =~ ":([a-z]*)([0-9]*)" :: [String
12:10:45 <rjsimmon> dcoutts_: http://pastebin.com/Z0Pg6mfY
12:10:49 <ivanm> romildo: because I don't think "[String" has an instance :p
12:11:09 <ivanm> but it could just be that the version of the library that you're using no longer has instances for [String]
12:11:17 <romildo> ivan, of couce I meant "[String]".
12:11:27 <romildo> (of course)
12:12:12 <rjsimmon> when I try to issue constraints to keep it from "downgrading" stuff - like saying --constraint='array==0.3.0.2'
12:12:27 <rjsimmon> I get "cabal: dependencies conflict: ghc-6.12.3 requires array ==0.3.0.1 however
12:12:27 <rjsimmon> array-0.3.0.1 was excluded because array-0.3.0.2 was selected instead
12:12:27 <rjsimmon> array-0.3.0.1 was excluded because of the top level dependency array ==0.3.0.2"
12:12:41 <dcoutts_> rjsimmon: ah ok, you've accidentally installed updated versions of some core packages like array
12:12:53 <rjsimmon> oh.
12:12:54 <rjsimmon> oops?
12:13:18 <dcoutts_> rjsimmon: you don't want the later versions, it means other things have to be rebuilt against those versions to make things consistent
12:13:32 <rjsimmon> (nods)
12:13:50 <dcoutts_> rjsimmon: solution is to blow the updated ones away
12:14:04 <dcoutts_> rjsimmon: ghc-pkg unregister --user ${pkgname}
12:15:02 <dcoutts_> rjsimmon: look at the output of ghc-pkg list, you'll find you've got versions of array, directory and a bunch of others installed in your user package db.
12:15:30 <rjsimmon> hmm
12:15:34 <rjsimmon> this must be what was misconfigured
12:15:36 <romildo> Is it the case that prior versions of Text.Regex.Base.RegexLike had an instance RegexLike a b => RegexContext a b [String], and in later versions it was removed? Some references (like the Real World Haskell) mentions it, but it does not work.
12:15:41 <dcoutts_> rjsimmon: and avoid using "cabal upgrade"
12:15:42 <rjsimmon> because all I did was cabal install Agda
12:15:47 <rjsimmon> ooh
12:16:02 <rjsimmon> I might have done that too :-\
12:16:36 <dcoutts_> "cabal upgrade" is gone in the next cabal-install release, since it doesn't do what people expect
12:20:19 <yrlnry> Is there a standard abbreviation for    foldr  (&&) True ?
12:20:34 <mauke> :t foldr (&&) True
12:20:35 <lambdabot> [Bool] -> Bool
12:20:40 <mauke> @hoogle [Bool] -> Bool
12:20:40 <lambdabot> Prelude and :: [Bool] -> Bool
12:20:41 <lambdabot> Prelude or :: [Bool] -> Bool
12:20:41 <lambdabot> Data.List and :: [Bool] -> Bool
12:20:58 <copumpkin> yrlnry: and?
12:21:09 <yrlnry> aha!  Thanks.
12:21:14 <copumpkin> @src and
12:21:14 <lambdabot> and   =  foldr (&&) True
12:21:45 <yrlnry> :t \h ls -> and $ map ($ h) ls
12:21:46 <lambdabot> forall a. a -> [a -> Bool] -> Bool
12:21:55 <mauke> @pl foldr (&&) True
12:21:55 <lambdabot> foldr (&&) True
12:22:16 <yrlnry> @hoogle  [a -> Bool] -> a -> Bool
12:22:16 <lambdabot> Data.Foldable all :: Foldable t => (a -> Bool) -> t a -> Bool
12:22:16 <lambdabot> Data.Foldable any :: Foldable t => (a -> Bool) -> t a -> Bool
12:22:16 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
12:22:16 <kmc> :t all
12:22:17 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:22:31 <mauke> :t (and .) . sequence
12:22:31 <yrlnry> Um.
12:22:32 <lambdabot> forall (f :: * -> *). (Functor f, Monad f) => [f Bool] -> f Bool
12:22:41 <kmc> :t \x -> all ($ x)
12:22:42 <lambdabot> forall a. a -> [a -> Bool] -> Bool
12:22:45 <kmc> :t all . ($)
12:22:46 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
12:22:51 <kmc> :t all . flip ($)
12:22:52 <lambdabot> forall a. a -> [a -> Bool] -> Bool
12:26:35 <revenantphx> Bullshit.
12:26:58 <mauke> where?
12:27:01 <paolino> good for plants
12:27:24 <revenantphx> Computer science teacher keeps sending "eeeeeh" messages about whether or not "writing one's own demo language (if compiled, using LLVM)" is a good project to do next year as a pseudo-independent study.
12:27:24 <yrlnry> I did already get pointless to cough up something like flip (map . flip id), which I decided was too obscure.
12:27:44 <revenantphx> It's a hell of a lot better than "writing a program that draws shapes for Android"
12:27:47 <ivanm> dammit, why is my QC-based testsuite suddenly getting slower and slower? :s
12:28:47 <rjsimmon> dcoutts_: okay, I've torched everything using "ghc-pkg unregister --user X," following the dependency chains back as far as I can. Now I get "cannot configure QuickCheck-2.1.2. It requires ghc -any There is no available version of ghc that satisfies -any" so I seem to have gone too far.
12:29:06 <rjsimmon> (oops)
12:30:17 <revenantphx> It would be interesting to write the lexer/parser in haskell :\
12:30:20 <ivanm> yup
12:30:25 <ivanm> (to rjsimmon)
12:30:41 <ivanm> rjsimmon: if you did all this to your user config, you could just remove that and start again
12:30:57 <ivanm> if, however, you edited the global package DB, then you're pretty much screwed :s
12:31:02 <rjsimmon> nope, user
12:31:20 <rjsimmon> definitely only used "ghc-pkg unregister --user"
12:31:44 <dcoutts_> rjsimmon: use ghc-pkg check
12:31:58 <rjsimmon> ... gives no output
12:32:43 <dcoutts_> rjsimmon: and "ghc-pkg list ghc" reports it's still there?
12:34:15 <dcoutts_> rjsimmon: a bigger hammer is rm ~/.ghc  which will blow away all user packages, leaving you with just the things that come with the platform.
12:34:28 <Zao> dcoutts_: What about the crap in .cabal?
12:34:37 <dcoutts_> Zao: that's ok, it's just disk space
12:35:09 <lispy1> dcoutts_: BTW, any idea why cabal would keep trying to reinstall a perfectly good process package under ghc7 when I try to install things from hackage?
12:35:24 <dcoutts_> lispy1: same version thereof?
12:35:40 <dcoutts_> or trying to install an older version?
12:35:46 <lispy1> dcoutts_: yeah, the installed one is the latest available and that's what it keeps trying to install most of the time
12:36:11 <dcoutts_> lispy1: first thing to check is if you've got it installed in the user package db, masking the global one
12:36:18 <lispy1> SourceGraph was the last thing I tried to install that caused this problem
12:36:32 <lispy1> Well, I do now, but initially I didn't
12:36:36 <rjsimmon> So that's pretty broken. I moved both my .cabal and .ghc directories elsewhere
12:36:37 <rjsimmon> http://pastebin.com/pXZfrYNy
12:36:48 <lispy1> dcoutts_: it also tries to install Cabal 1.8.x
12:36:57 <rjsimmon> maybe I should re-re-install Platfomr?
12:37:01 <rjsimmon> *Platform?
12:37:02 <dcoutts_> lispy1: but that's because it needs Cabal 1.8.x
12:37:32 <rjsimmon> (wow, I'm sorry I'm such an impressive idiot at this)
12:37:40 <dcoutts_> rjsimmon: and "ghc-pkg list ghc" reports?
12:37:40 <lispy1> I'm removing .cabal and .ghc and I'll try from a fresh attempt
12:38:20 <rjsimmon> possibly not? http://pastebin.com/WtQsVxdg
12:38:47 <dcoutts_> rjsimmon: ok, then it's totally borked, yes, reinstall
12:39:02 <jmcarthur> i really wish haddock didn't show unexported types in instance lists
12:39:11 <dcoutts_> rjsimmon: no idea how that happened, ghc-pkg --user will definitely only affect user packages
12:39:15 <rjsimmon> gladly!
12:39:58 <lispy1> dcoutts_: oh and it rebuilds containers: Building containers-0.3.0.0...
12:40:19 <lispy1> I installed from the tarball on the ghc website, the binary tarball for linux, BTW
12:41:11 <dcoutts_> lispy1: presumably because it's trying to build Cabal-1.8
12:41:18 <dcoutts_> lispy1: --dry-run will tell you
12:41:28 <rjsimmon> okay
12:41:46 <lispy1> dcoutts_: I'm trying from scratch and then I will post the output :)
12:41:49 <rjsimmon> much better; I've blown away everything and agda --dry-run no longer claims that it will install haskell98
12:43:17 <dcoutts_> rjsimmon: yay :-)
12:43:36 <rjsimmon> dcoutts_: "Compiling Agda.Utils.Warshall" so that's a good sign
12:43:39 * dcoutts_ wishes he had time to rewrite the cabal-install constraint solver
12:44:29 <rjsimmon> look, I'm more than happy starting from scratch as many times as it takes, I must have kept cabal-updating or else leaving the old .ghc which runied me
12:45:26 <lispy1> dcoutts_: http://pastebin.com/GFGiTsHf
12:46:31 <Darkone_> Question: what does haskell require for spacing?
12:46:45 <lispy1> Darkone_: tabs are bad, use normal space characters
12:46:49 <mauke> Darkone_: nothing
12:46:51 <rjsimmon> hahaha! You are my hero dcoutts_ *has an Agda*
12:46:55 <merijn> Darkone_: You mean how to indent blocks?
12:46:58 <Darkone_> Was thinking it was the tabs.
12:47:04 <lispy1> Darkone_: beyond that, you might want to look at the layout rules
12:47:14 <Darkone_> Apparently so. Let me try converting to space
12:47:47 <lispy1> Darkone_: tabs in Haskell count for 8 spaces.  But, most editors pretend tabs are about 3-4 spaces, so it causes confusion if you have tabs in there
12:48:05 <lispy1> Darkone_: and by confusion, I mean, the layout will be wrong and you'll get parser errors
12:48:06 <dcoutts_> lispy1: wow, impressive, I didn't expect it'd get that far.
12:48:32 <lispy1> dcoutts_: because I'm on 7?
12:49:10 <dcoutts_> lispy1: right, none of those packages will have been tested with ghc 7, it's installing older versions of core packages which rarely goes well.
12:49:11 <lispy1> dcoutts_: is there a way to make cabal stop on the first package that fails to build?  That would make upgrading packages a bit easier :)
12:49:32 <dcoutts_> lispy1: my suggestion is to use --dry-run first so you see what it's going to do
12:49:40 <acemo> for the when function, whats the $ for before the do?
12:49:41 <Darkone_> Oh, 8 spaces? Have mine set to replace with 4. And it just worked.
12:50:00 <dcoutts_> lispy1: if you're trying to upgrade things "properly" then don't let it install older core packages.
12:50:19 <lispy1> Darkone_: it can "just work" for a time, the layout rule just requires indentation of at least 1 space (or tab) at the right places
12:50:53 <lispy1> dcoutts_: yes, I'd like to sniff out packages that need to be upgraded for ghc7 and upgrade them
12:51:09 <lispy1> dcoutts_: So what is your suggestion for not letting it install order core packages?
12:51:48 <lispy1> dcoutts_: Is the last of core packages defined somewhere? I guess I could make extensive use of --preference/--constraint to forbid those packages if I knew what ones and which versions
12:51:49 <dcoutts_> lispy1: use --dry-run so you can see what it'll do. If you spot it's going to install an older one, use a --constraint and it'll tell you which package cannot be configured with that constraint.
12:52:17 <lispy1> dcoutts_: Is there a list of packages I should be watching out for?
12:52:27 <dcoutts_> lispy1: the ones that come with ghc
12:52:27 <Cale> Darkone_: If you replace the tab characters with spaces, of course it'll work :)
12:53:02 <Cale> Darkone_: But if there are physical tab characters in the file, then the compiler will treat those as aligning to the next multiple of 8 spaces
12:53:03 <lispy1> dcoutts_: So, remove .cabal and .ghc, then make a list, add that list to my .cabal/config file and try with --dry-run?
12:53:15 <Cale> (not exactly the same thing as counting for 8 spaces)
12:53:15 <dcoutts_> lispy1: or ghc-pkg list --global
12:53:22 <lispy1> dcoutts_: thanks
12:56:05 <lispy1> dcoutts_: when I have multiple constraints in my ~/cabal/config do they go on a separate lines?
12:56:16 <dcoutts_> lispy1: I think so
12:56:24 <lispy1> okay
12:57:09 <acemo> could someone help me find out why function sortFile gets stuck after line 68 (putStrLn "0")? http://hpaste.org/41745/heapsorths I'm using this as input.txt http://hpaste.org/41744/inputtxt
12:57:12 <dcoutts_> lispy1: I'm not sure that it works well when the package in question is not a dependency of the thing you're installing
12:57:29 <dcoutts_> lispy1: you might find it says that it cannot satisfy the constraint
13:02:20 <etate> hello, do you get unlimited lookahead in parsec? 
13:03:07 <c_wraith> by default, parsec looks ahead by 1.  if you use "try", it can look ahead arbitrarily, but with some restrictions.
13:03:27 <c_wraith> honestly, if you need lookahead, parsec is not as good a bet as polyparse or uu-parsinglib
13:03:37 <lispy1> etate: the same way you get space leaks in your parser :)
13:04:19 <etate> well what i really really want is a way to lex source nicely with lookahead in any stream
13:04:30 <etate> is that even feasible?
13:05:18 <lispy1> etate: My joke was just that 'try' introduces a bit of space leakiness until it fails fully
13:06:58 <lispy1> etate: Parsec has to hang on to things until it can commit to a parse tree
13:07:10 <acemo> i'm guessing let cannot be recursive?
13:07:35 <lispy1> acemo: let in haskell is recursive.  We don't have a separate letrec
13:07:45 <etate> lispy1: does that mean that you can get lookahead on a stream ?
13:07:47 <acemo> as in let li = li ++ [1] goes wrong?
13:08:13 <Axman6> > let xs = 1:xs in xs
13:08:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:08:19 <lispy1> acemo: that program is li = li ++ [1] = (li ++ [1]) ++ [1], etc
13:08:47 <acemo> lispy1: yeah.. was afraid so..
13:08:58 <Cale> acemo: You defined sorted to be the list which consists of the elements of itself followed by the first element of the heap
13:08:58 <lispy1> etate: I'm worried that there is some detail in your question that I'm not understanding, but yes parsec does support looking ahead via try.
13:09:01 <radioactive_man> damn
13:09:31 <Cale> (which is undefined, because of its circularity)
13:09:48 <McManiaC> we have a do rec tho :D
13:09:58 <lispy1> acemo: for pure code like this, you can use equational reasoning to figure out what the result will be.  It's pretty handy :)
13:10:30 <lispy1> ghc7 really hates pandoc
13:10:58 <lispy1> Not really hates it, but it produces an amazing amount of warnings about SpecConstr
13:12:44 <lispy1> acemo: parsec also supports having a lexer separate from the parser
13:13:04 <Cale> acemo: Also, even if you were to define sorted' = [], and write let sorted = sorted' ++ [firstElem heap], there's not much point in that, because [] ++ xs = xs
13:13:16 <lispy1> acemo: So it may be useful to distinguish between the lookahead needs of lexing your input vs. parsing your stream of lexical tokens
13:13:23 <lispy1> oops
13:13:33 <lispy1> etate: ^^ I meant to talk to you not acemo :)  Sorry
13:14:54 <acemo> Cale: how about something like sorted` = sorted, sorted = sorted` ++ [firstElem heap]? i'm guessing that would be the same still?
13:15:02 <lispy1> dcoutts: any idea why I'd get this message? http://pastebin.com/gYKc275U
13:15:12 <Cale> acemo: Yeah, that's circular too
13:15:22 <acemo> Cale: aweasome :)
13:15:42 <acemo> is there any way to add an element to a list in a do ?
13:15:49 <Cale> (though you can't use backticks as part of a name)
13:15:56 <lispy1> dcoutts: it seems like I have a version already installed that satisfies the constraint...
13:16:12 <Cale> acemo: What list are you trying to construct?
13:17:04 <Cale> acemo: The list of first elements of the heaps constructed by deleting the minimum element from the initial heap iteratively?
13:18:54 <radioactive_man> has anyone tried out MITs parallel haskell?
13:18:57 <Cale> Errr... Maybe I see what you're going for here... (btw, computing the last element of a list is linear time)
13:18:59 <acemo> Cale i'm trying to do external heapsort, currently i pick the first 5 elements of the list, put them in a heap. For the rest of the elements in the list, take take the minimum element from the heap, put this in sorted, then see if you can add the element from the list in the heap or if you have to put it in the dead space.
13:20:33 <acemo> Cale: i know, taking the last element of the list isn't really nice, but i'm more concerned of getting things working before optimizing
13:20:38 <Cale> okay
13:21:12 <acemo> besides, the assignment was supposed to be done in Java.. I just made it myself more interesting by doing it in a language we just learned a bit from in a other course.
13:21:51 <Cale> acemo: Let's do this in parts. Write a function which given a new element and a pair consisting of a heap and sorted list, constructs a new pair consisting of an extended heap and sorted list.
13:22:41 <acemo> f :: a -> (heap, list) -> (heap, list)?
13:22:47 <Cale> yeah
13:22:49 <acemo> alright
13:22:50 <Cale> (roughly)
13:23:16 <Cale> Then you'll just be able to use foldl or foldr to do the whole thing
13:24:31 <Cale> You'll just replace each (:) in the list with this function that extends the heap/sorted list, and the [] at the end with your initial heap/sorted list
13:24:45 <Cale> (that's a foldr)
13:26:05 <Cale> acemo: Another thing which you should probably note is that 'let' inside a do-block doesn't *do* anything. It simply makes definitions which scope over the rest of the block. So when you write "did first steps" there, nothing has actually been done as such
13:26:47 <Cale> (It doesn't compute any of the things you define unless they're needed (pattern matched on))
13:27:35 <acemo> Cale: good point.. that explains why it prints the 0 after the let :)
13:27:37 <Cale> Which incidentally is why it gets as far as printing the 0 before getting stuck when trying to decide whether a < last sorted, because that forces the evaluation of sorted
13:31:28 * hackagebot contstuff-monads-tf 0.2.0 - ContStuff instances for monads-tf transformers  http://hackage.haskell.org/package/contstuff-monads-tf-0.2.0 (ErtugrulSoeylemez)
13:33:30 <mm_freak> copumpkin: you may want to try contstuff 0.7.0, which is split into separate modules nowâ€¦  also i've just uploaded a new version of contstuff-monads-tf, which brings them both together
13:34:24 <acemo> Cale: Thanks for the suggestion of that extra function.. i believe it should make the rest a lot more easy to implement :)
13:34:42 <aristid> mm_freak: why monads-tf and not monads-fd/mtl?
13:34:45 <mm_freak> on the way i've discovered that splitting a haskell project into multiple modules is equivalent to splitting a redundant database table into multiple relational tables
13:35:01 <aristid> mtl 2.0 is the way to go
13:35:29 <mm_freak> aristid: mainly because i use the iteratee package, which depends on monads-tf, and i use contstuff a lotâ€¦  now i get along with a single set of lifting functions
13:35:47 <mm_freak> just 'liftIO' instead of 'C.lift . T.liftIO'
13:36:10 <aristid> mm_freak: isn't the enumerator package more modern? :)
13:36:51 <mm_freak> aristid: it's just newer, but much less featurefulâ€¦  also the author of 'enumerator' complained about the namings in 'iteratee', but apparently that has changed
13:37:12 <mm_freak> for example i can't find that ugly IterateeG anymoreâ€¦  seems to be just Iteratee now
13:37:49 <mm_freak> aristid: actually it was michael snoyman complaining about thatâ€¦  i don't know if they are the same person
13:38:00 <aristid> mm_freak: no they're not
13:38:28 <aristid> enumerator is by john millikin
13:38:31 <mm_freak> ah, ok
13:38:38 <mm_freak> aristid: what's so great about mtl 2.0?
13:39:00 <aristid> mm_freak: it merges mtl and monads-fd, finally. that is great.
13:39:12 <mm_freak> it doesn't seem to have improved a lot, particularly it still has this broken ListT
13:39:24 <aristid> well, it's supposed to be mostly compatible
13:39:32 <mm_freak> as far as i've seen monads-tf (and contstuff) have a working ListT (called ChoiceT in contstuff)
13:39:48 <aristid> i thought ChoiceT is from monadLib?
13:39:52 <mm_freak> actually i know that ChoiceT works, because i've written it =)
13:40:09 <mm_freak> yes, both monadLib and contstuff have a ChoiceT, but they work very differently
13:40:19 <mm_freak> in fact, contstuff is largely inspired by monadLib
13:40:29 <aristid> monads-tf does not have ChoiceT, it has LisT
13:40:32 <aristid> ListT
13:40:47 <mm_freak> yes, but it seems to be a proper ListT
13:40:47 <aristid> http://hackage.haskell.org/packages/archive/monads-tf/0.1.0.0/doc/html/Control-Monad-List.html
13:40:56 <mm_freak> that's what i was saying
13:41:04 <aristid> well.
13:41:05 <mm_freak> mtl's ListT is still broken, after so many revisions
13:41:09 <aristid> it uses the one from transformers
13:41:15 <aristid> and mtl 2.0 uses transformers
13:41:24 <dolio> Why is that in monads-tf?
13:41:26 <aristid> so either both mtl and monads-tf are broken, or none
13:41:33 <aristid> dolio: it's just a re-export
13:41:41 <dolio> Oh.
13:42:17 <mm_freak> i see
13:42:20 <mm_freak> hmm
13:42:37 <aristid> monads-fd in fact is just a thin wrapper around mtl 2.0 now
13:43:27 <mm_freak> so if i write contstuff-transformers, then it should work for most MTLs out there?
13:43:47 <mm_freak> they seem to reexport transformers classes MonadTrans and MonadIO, which is the main reason for me to write it
13:46:04 <aristid> mm_freak: yes, those two classes are from transformers
13:51:01 <cole> What is probably the largeest opensource program (popularity and/or lines of code) out there?
13:51:09 <cole> (written in haskell)
13:51:09 <radioactive_man> kde
13:51:32 <radioactive_man> not kde^^
13:51:46 <mm_freak> aristid: good to know, thanks
13:51:47 <ulfdoz> i would expect openoffice to be bigger than kde-base.
13:52:03 <mm_freak> aristid: then why is MTL the way to go?  i'd assume 'transformers' is
13:52:21 <cole> written in haskell*
13:52:25 <tomberek> is GHC optimized for combinatory logic?  ie: will a function defined in terms of s,k,i,b,c, etc be compiled effectively?
13:52:25 <mm_freak> cole: GHC probably
13:52:30 <merijn> cole: Probably GHC
13:52:31 <cole> heh.
13:52:38 <lispy1> cole: GHC is pretty big, darcs size is here http://blog.codersbase.com/2010/08/fun-but-pointless-code-metrics.html
13:52:49 <mm_freak> cole: but you may also want to check out darcs, which is also fairly big
13:53:02 <merijn> cole: The largest haskell codebases I have heard of are proprietary financial systems
13:53:25 <merijn> I mean, stuff like Xmonad is barely 1KLOC I think
13:53:57 <aristid> mm_freak: well, transformers is the way to go if it has all you need. but if you want MonadReader and these classes, you need one of mtl / monads-fd / mtl-tf / monads-tf
13:54:30 <aristid> merijn: it certainly is more than 1 KLOC :)
13:54:32 <cole> Financial systems? Do you know the company?
13:55:40 <merijn> cole: Nope, someone mentioned it on Hacker News, lemme see if I can find the link
13:55:53 <benmachine> aristid: yeah, it's almost two and a half
13:55:55 <benmachine> <_<
13:56:07 <benmachine> not counting tests, -contrib, etc.
13:56:31 <benmachine> oh wait, *more than two and a half
13:56:34 <benmachine> but less than three
13:56:46 <merijn> cole: I think it was this thread: http://news.ycombinator.com/item?id=1909093
13:56:54 <cole> so, darcs is literally written in (1,2,3 . .  11) eleven different languages?
13:57:31 <lispy1> cole: That seems to be kind of common for mature projects
13:57:46 <lispy1> cole: Those numbers include all the test suite too
13:57:58 <lispy1> cole: and a few scripts that users can use (like emacs modes)
13:57:59 <cole> I had no idea. So, kde includes haskell code?
13:58:01 <merijn> At least one the guys there mentions working on a 20KLOC (haskell, even more C on top of that) machine learning code base
13:59:13 <cole> What does haskell provide in terms of being able to communicate with other languages?
13:59:27 <benmachine> the FFI with C is good
13:59:37 <revenantphx> It can be compiled to C, which helps.
13:59:40 <benmachine> you can go via that to a lot of other languages
13:59:40 <revenantphx> And it has FFI.
13:59:43 <merijn> And the classic sockets/whatever support
13:59:50 <Adamant> one code repository at a Fortune 500 company I worked for briefly had literally every language I have ever heard of
13:59:59 <Adamant> represented
14:00:02 <benmachine> there are also some additional facilities for particular languages like lua or python
14:00:09 <merijn> revenantphx: Compiling to C is kinda pointless, you might as well compile directly to machine code and link that
14:00:14 <revenantphx> True.
14:00:23 <merijn> revenantphx: Once it's machine code no one cares what the original language was
14:00:24 <revenantphx> But it doesn't really have symbols you can load easily ...
14:00:27 <lispy1> Cabal makes a different plan depending on whether you use 'cabal install foo' and 'cabal configure && cabal build && cabal install' ?
14:00:32 <revenantphx> At least, not in my experience.
14:00:58 <revenantphx> anyways
14:01:18 <acemo> can a .o file generated by ghc be linked to a .o file generated by gcc/g++ to make 1 executable? or is that not how communicating with c/c++ goes?
14:01:23 <merijn> benmachine: Yeah, but C integration with python is rather easy. So it'd seem to be you could write a trivial Haskel <-> C <-> Python layer, probably you could even compile that
14:01:33 <merijn> acemo: Yes, that's possible via the FFI
14:01:36 <revenantphx> acemo: A compiled object is a compiled object is a compiled object.
14:01:52 <acemo> aweasome.
14:01:52 <revenantphx> It has to be in the format that the system wants (PE, ELF, MACH-O)
14:02:05 <revenantphx> Whether or not there's a reliable way to use the symbols it generates... not so much.
14:02:06 <merijn> acemo: You can also compile haskell to loadable dll/so libraries and load those from C
14:02:22 <benmachine> merijn: sure, I'm just saying that the work has already been done for some languages
14:02:25 <merijn> Or load C dll/so's in haskell
14:02:37 <daniel___> Hi to all
14:02:41 <daniel___> I'm new in haskell
14:02:45 <daniel___> this is my 3rd code
14:02:51 <cole> How do haskell and OCaml compare?
14:02:51 <daniel___> I found this in a pdf
14:02:52 <daniel___> http://pastebin.com/nD3tUWWu
14:02:58 <daniel___> this is the representation of a Tree
14:02:59 <benmachine> acemo: it's made a little tricker by the fact that you have to initialise the runtime before haskell code will work
14:03:01 <daniel___> Binary Tree
14:03:10 <revenantphx> A tree en espaÃ±ol.
14:03:14 <revenantphx> Que bien.
14:03:14 <Axman6> daniel___: please complete your sentenses before hitting enter
14:03:15 <benmachine> acemo: but that's not all that difficult really
14:03:19 <daniel___> Can anyone explain me the ++ operators????
14:03:25 <daniel___> sorry
14:03:30 <merijn> cole: OCaml is less pure and afaik not lazy by default, but the type system is very similar
14:03:34 <revenantphx> :t ++
14:03:35 <lambdabot> parse error on input `++'
14:03:37 <Axman6> > "hello" ++ " world"
14:03:37 <revenantphx> er
14:03:38 <lambdabot>   "hello world"
14:03:42 <revenantphx> :t `++`
14:03:42 <lambdabot> parse error on input ``'
14:03:45 <revenantphx> ...
14:03:45 <benmachine> :t (++)
14:03:46 <lambdabot> forall m. (Monoid m) => m -> m -> m
14:03:46 <acemo> daniel___: list ++ otherList = combinedList
14:03:49 <revenantphx> yeah, that's it.
14:03:49 <Axman6> > [1,2,3] ++ [7,8,9]
14:03:50 <lambdabot>   [1,2,3,7,8,9]
14:03:57 <merijn> cole: Also, I think OCaml supports traditional OOP
14:04:20 <daniel___>  Hi to all, I'm new in haskell,  this is my 3rd code,  I found this in a pdf  http://pastebin.com/nD3tUWWu, this is the representation of a Binary Tree, Can anyone explain me the ++ operators????
14:04:39 <merijn> daniel___: ++ concatenates two lists together, as people illustrated above
14:05:00 <copumpkin> bos: is there any public info about your startup?
14:05:04 <revenantphx> No tienes que repetirse.
14:05:15 <radioactive_man> this is the way haskell guys answer everything: in haskell
14:05:27 <merijn> radioactive_man: How do you mean?
14:05:33 <revenantphx> no no, haskell guys answer everything in contrapuntal fugues.
14:05:39 <revenantphx> @quote fugues
14:05:39 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
14:05:41 <daniel___> Hmmm
14:05:46 <revenantphx> daniel___: 
14:05:52 <revenantphx> > [1,2,3] ++ [4,5,6]
14:05:53 <lambdabot>   [1,2,3,4,5,6]
14:05:57 <absentia> contraceptual fungus?
14:06:02 <revenantphx> No...
14:06:03 <aristid> cofungus
14:06:06 <revenantphx> contrapuntal fugues.
14:06:07 <merijn> radioactive_man: Concatenation is called that in every programming language I know >.>
14:06:09 <daniel___> and what means (r : enOrdenB d ) ????
14:06:56 <revenantphx> > ( 3 : [2,4,5] )
14:06:56 <lambdabot>   [3,2,4,5]
14:07:05 <revenantphx> It attaches something to the beginning of a list.
14:07:05 <bos> copumpkin: there aint
14:07:10 <radioactive_man> merijn, you are using the "english" dialect of haskell
14:07:47 <bos> copumpkin: but i will usually be wearing trousers while working at it
14:07:54 <merijn> radioactive_man: It's called concatenation is Java, Python, PHP and ruby...
14:08:10 <cole> What are the performance characteristics of haskell vs ocaml?
14:08:31 <lispy1> cole: haskell is fast, ocaml might be?
14:08:50 <cole> "Haskell is fast" what does that mean exactly?
14:09:09 <revenantphx> cole: check this out
14:09:09 <revenantphx> http://www.google.com/webhp?hl=en#sclient=psy&hl=en&site=webhp&source=hp&q=haskell+vs+ocaml+performance&btnG=Google+Search&aq=f&aqi=g1&aql=&oq=&gs_rfai=&pbx=1&fp=9b84a0f9b294c817
14:09:09 <merijn> cole: That for 90% of the programs the language speed isn't an issue
14:09:12 <dankna> it means it performs fairly well on common benchmarks
14:09:16 <radioactive_man> merijn, yeah - but you were the first one, to actually use words to explain it. others used haskell code as input and showed the resulting haskell expressions
14:09:17 <revenantphx> here: http://tinyurl.com/2u6ckbz
14:09:17 <dankna> have a look at the shootout
14:09:34 <lispy1> cole: http://shootout.alioth.debian.org/u64/benchmark.php?test=all&lang=ghc&lang2=gcc
14:09:38 <merijn> radioactive_man: To be fair, that's a reasonable explanation for list concatenation
14:09:45 <cole> I get the sense, from what I've rea, that for some tasks haskell is about as fast as c. But, do there exist problem sets for which haskell performs significantly worse than imperative langauges?
14:10:08 <merijn> cole: Haskell can be imperative just fine, so that's not a relevant distinction :p
14:10:13 <lispy1> cole: no, because imperative programming is possible in Haskell too :)
14:10:17 <merijn> Just program everything in the IO monad :p
14:10:21 <revenantphx> Through some crazy math.
14:10:27 <cole> I guess that's a more general statement: Are there problems for which lazy functional languages are simply slow for?
14:10:29 <revenantphx> How the hell are monads still pure?
14:10:52 <revenantphx> In the end it seems like it's just saying "as long as you keep all the IO within here, it's okay"
14:10:55 <benmachine> revenantphx: that is a strange question; how are they not?
14:10:58 <copumpkin> bos: I see!
14:10:59 <revenantphx> like a quarantine for the taint of the outside world.
14:11:05 <lispy1> cole: there was an ICFP contest one year where Haskell had poor performance in one part.  That was writing a machine emulator.  At the time the vector/array libraries were unoptimized.  I think the problem has since been rectified.
14:11:13 <benmachine> revenantphx: you can still always replace a function call by its result
14:11:13 <copumpkin> bos: or rather, I don't, but I see that I'm not meant to see, so that's okay
14:11:15 <merijn> revenantphx: That's not a good explanation of the IO monad
14:11:20 <cole> Ok. that's interesting. Let's assume haskell that haskell hadn't imperative features, though. Is functionalism necessarily slow for certain types of problems?
14:11:31 <copumpkin> cole: not really
14:11:39 <merijn> cole: Performance problems are likely to occur because of unpredictable garbage collection/memory consumption
14:11:46 <benmachine> revenantphx: there's kind of a loophole in that you can't do that with IO because its values don't have an in-haskell representation
14:11:46 <onteria|i7> interesting this conversation comes up as I'm reading a paper on implementing a global queue in haskell
14:11:49 <radioactive_man> i suspect quicksort to perform bad, so mutable state is bad
14:11:57 <daniel___> Can anyone explain to me what is the meaning of  (r : enOrdenB d )  in http://pastebin.com/nD3tUWWu ??????????????????
14:12:00 <daniel___> please
14:12:00 <revenantphx> I'm confused.
14:12:02 <lispy1> cole: It's been shown that without mutation some algorithms can get with in a log factor of the mutable one, but no one has a proof saying they can't get even closer.
14:12:17 <merijn> cole: There maybe scenarios were C programs will out perform you because you can manually control memory allocation making use of stuff like knowledge about your swap/cache
14:12:17 <radioactive_man> also nondeterminism can greatly improve performance
14:12:28 <benmachine> revenantphx: don't take IO as a 'typical' monad
14:12:31 <radioactive_man> especially in the parallel case
14:12:40 <revenantphx> benmachine: well, obviously.
14:12:50 <benmachine> revenantphx: most monads like Maybe and lists do nothing even vaguely impure
14:12:51 <merijn> revenantphx: The IO monad implicitly makes every computation depend on the previous one. It just hides the book keeping
14:12:59 <revenantphx> benmachine: of course.
14:13:05 <revenantphx> merijn: mmk.
14:13:15 <benmachine> revenantphx: did I misunderstand your question :P
14:13:20 <merijn> revenantphx: The example I saw for IO is imagine passing a virtual "RealWorld" parameter to every IO function.
14:13:21 <revenantphx> A bit I guess.
14:13:38 <revenantphx> So, I'm going to write my ant simulation in haskell for fun.
14:13:43 <benmachine> neat
14:13:46 <merijn> revenantphx: If your function always returns the same value for the same RealWorld function it's pure, no?
14:13:52 <revenantphx> And I'm wondering what a good way to create a "board" for this would be.
14:14:12 <revenantphx> The idea is that there is a center node, off of which there are some number of nodes in two directions, and then food source nodes.
14:14:16 <benmachine> merijn: the State RealWorld model of IO doesn't really work :P
14:14:21 <merijn> revenantphx: Now imagine never passing the same RealWorld value to your functions, but instead always returning a new one and using that for the next function
14:14:37 <merijn> benmachine: Of course not, but it helped me understand, silly as it is
14:14:41 <revenantphx> In C I had to manually construct the linked list.... wondering how that aspect is done in haskell.
14:14:44 <cole> Ok. So, I'm coming here with the perspective of what (I think) is the typical school of thought: high-level/functional languages are slow. You're saying that haskell, for most problems, is as fast or faster than C. That's very interesting. Why isn't everyone programming in haskell then? Ignorance?
14:14:47 <benmachine> merijn: that's fair enough, I suppose
14:14:52 <lispy1> daniel___: it's consing an element on to the front of a list
14:14:54 <revenantphx> I'd have a function string together the lists?
14:15:05 <merijn> revenantphx: No remove the book keeping aspect of returning and passing RealWorld by hiding it in the monad, and voila
14:15:17 <revenantphx> merijn: right right.
14:15:18 <radioactive_man> cole, there are no functional programs
14:15:24 <benmachine> revenantphx: well, "you'd have a function" is a weird thing to say in haskell since it's pretty much always the case
14:15:34 <benmachine> radioactive_man: huh?
14:15:34 <revenantphx> benmachine: haha, of course XD
14:15:36 <merijn> cole: No, what I'm saying (and other people will most likely agree) is that language speed rarely matters
14:15:54 <radioactive_man> cole, in the end it gets translated into imperative code anyways
14:15:55 <merijn> cole: Python is easily a factor 10 slower then C, but still fast enough for 95% of all programs
14:16:05 <merijn> cole: Most programs are IO bound, not CPU bound
14:16:07 <bos> more like 30 to 1000
14:16:14 <benmachine> merijn: it depends what kind of programming you're doing
14:16:25 <revenantphx> In a situation like I'm in cole, where I'm writing a very intensive simulation (200 ants, 10000 time steps, 10000 repetitions), speed can be important.
14:16:28 <revenantphx> For most things, it's not.
14:16:29 <radioactive_man> cole, so its the translation which affects performance
14:16:34 <merijn> benmachine: Agreed, but people doing the CPU bound kind generally already know the answer to these questions :p
14:16:34 <daniel___> hmmmm
14:16:36 <daniel___> Thanks
14:16:40 <daniel___> to all
14:16:40 <benmachine> merijn: <_< k
14:16:41 <daniel___> :)
14:16:45 <revenantphx> My sim, for the aforementioned inputs, takes like 10 minutes to produce 100000 data points.
14:16:46 <revenantphx> >_>
14:16:57 <revenantphx> er, 10000*
14:16:58 <radioactive_man> cole, i for example translate haskell code into cuda which gives me up to 30 times faster code than c++ on cpu
14:17:04 <merijn> benmachine: Therefor I assume people asking language performance questions are not generally advanced enough programmers to worry about language performance
14:17:09 <jmcarthur> cole: well written haskell is always in the same ballpark as C, sometimes about equal with it, rarely faster
14:17:13 <benmachine> merijn: heheh.
14:17:30 <revenantphx> Oh look, it's jmcarthur actually answering the question. 
14:17:35 <revenantphx> What a surprise.
14:17:44 <ab9rf> revenantphx: need to put a stop to that
14:17:45 <jmcarthur> :D
14:17:50 <revenantphx> ab9rf: I agree.
14:17:57 <merijn> revenantphx: Its not a question that necessarily has a clear cut answer
14:18:07 <mm_freak> aristid: my monad library doesn't play too well with transformersâ€¦  it also has a lot of features, which transformers lacksâ€¦  i can only write a very thin interface between the two
14:18:12 <revenantphx> merijn: This is very true, but a quantitative answer can be given here.
14:18:14 <jmcarthur> i hope my answer didn't appear "clear cut"
14:18:17 <revenantphx> Or at least, a relatively decent one.
14:18:27 <benmachine> cole: I think #haskell would be inclined to say that it's ignorance that is stopping uptake of haskell, but I wouln't call us an unbiased source
14:18:27 <revenantphx> Anyways, linked list.
14:18:41 <radioactive_man> im unbiased
14:18:47 <revenantphx> No you're not. Shut up.
14:18:50 <dancor> i think "Haskell is about twice as slow as C" is reasonable
14:18:56 <radioactive_man> ;)
14:19:01 <jmcarthur> dancor: i don't
14:19:03 <merijn> revenantphx: For example, the speed up explained here: http://queue.acm.org/detail.cfm?id=1814327 I'm not sure you can accomplish in haskell
14:19:08 <dancor> shootout u64q medians
14:19:10 <benmachine> cole: one could also argue issues of maturity, haskell libraries are a little less stable than those of some other languages imo
14:19:12 <ab9rf> i've seen some situations where haskell is faster.
14:19:12 <revenantphx> Haskell has advantages over C, regardless of performance.
14:19:19 <revenantphx> Have you ever tried handling infinite sets in C?
14:19:21 <jmcarthur> dancor: the shootout is self-proclaimed as flawed
14:19:25 <revenantphx> It doesn't work out very well :D.
14:19:28 <ddarius> revenantphx: That isn't hard to do.
14:19:31 <ab9rf> it depends on the cleverness and carefulness of the programmer more than anything else
14:19:33 <jmcarthur> microbenchmarks are pretty much meaningless
14:19:36 <revenantphx> ddarius: then I just suck :3
14:19:48 <dancor> i stand by it as a more reasonable measure than a chan of fanboys
14:19:54 <ab9rf> a dumbass idiot can write slow code in any language :)
14:20:10 <jmcarthur> dancor: to draw a hard number out of it is pretty foolish though
14:20:14 <aristid> dancor: even then, benchmarks measure compileres, not languages
14:20:26 <jmcarthur> dancor: you could say "C is typically faster in microbenchmarks" with some certainty, and that's about it
14:20:27 <dancor> i think it's a useful summary
14:20:28 <ddarius> Yeah, where's icc?
14:20:29 <benmachine> ab9rf: well, stupid code is stupid, yes, but there are a lot of people who can write good code (no, really) and at that point there can be other factors that become important
14:20:31 <merijn> I mean, a lot of speed comes from algorithms, but our current concept of algorithm complexity is flawed
14:20:31 <ab9rf> reminds me of a guy i met back in college who managed to write an O(n^3) sort
14:20:39 <revenantphx> ab9rf: while(1){ void* awesome = malloc(9999999); printf("WHOOOOOOT %d %d %d, rand(), rand(), rand()); free(awesome);}
14:20:47 <merijn> Actually, most algorithm complexity notation is a bare faced lie.
14:20:49 <revenantphx> Prepare to have your CPU violated.
14:20:57 <benmachine> merijn: o rly
14:21:12 <ab9rf> the notation isn't a lie, although the interpretation or application might be
14:21:16 <merijn> benmachine: Yes, it assumes uniform memory access
14:21:29 <merijn> As if any sane OS provides uniform memory access speeds
14:21:31 <benmachine> merijn: that's not a lie
14:21:37 <benmachine> it's just massively simplifying
14:21:48 <revenantphx> A simplified case can still be useful.
14:21:49 <benmachine> but that's because the Real Thing is massively complicated :P
14:21:54 <merijn> The article I linked by Poul Henning-Kamp has an order of magnitude speedup by making use of caching
14:21:54 <revenantphx> Like a small angle approximation or something.
14:21:58 <ab9rf> complexity isn't a promise
14:22:05 <ddarius> Unless you are paging to a network file system, the access is bounded by a constant.
14:22:20 <ddarius> merijn: 10 is a constant.
14:22:21 <jmcarthur> is mallocing and freeing 10 gigs repeated really cpu bound enough to call that violating a cpu?
14:22:22 <luite> merijn: but that's probably just a constant, asymptotically
14:22:26 <medfly`> hi sinelaw
14:22:29 <benmachine> merijn: oh sure, but even an order of magnitude speedup might be insignificant as compared to switching from exponential to polynomial time
14:22:42 <sinelaw> hey medfly` 
14:22:44 <sinelaw> howzit going
14:22:46 <ddarius> jmcarthur: It looks like less than 10MB.
14:22:49 <merijn> ddarius, luite: Sure, but who cares about the theoretical performance of a program rather then actual performance
14:22:55 * jmcarthur recouts the zeros
14:23:00 <sinelaw> i'm uselessly trying to implement show instance for a gadt
14:23:05 <jmcarthur> ddarius: indeed :)
14:23:06 <ddarius> merijn: People who care about scaling.
14:23:09 <jmcarthur> *recounts
14:23:15 <ivanm> what's the correct syntax for inlining a function? {-# INLINE foo #-} ?
14:23:15 <benmachine> jmcarthur: given linux's optimistic memory management does it even do anything at all? :P
14:23:24 <jmcarthur> benmachine: tricky
14:23:28 <benmachine> sinelaw: did you try standalone deriving?
14:23:29 <merijn> ddarius: Know you're distorting my words to say something I don't mean
14:23:34 <jmcarthur> benmachine: with the right settings it certainly does!
14:23:37 <ab9rf> whee, what a pointless argument
14:23:39 <benmachine> jmcarthur: fsvo right :P
14:24:03 <ddarius> merijn: Just because it a theoretical value that you aren't interested in, doesn't make it a bared faced lie.
14:24:08 <jmcarthur> benmachine: right = satisfies the condition we are talking about :P
14:24:13 <benmachine> fair enough
14:24:14 <sinelaw> benmachine, nope, what is that?
14:24:38 <mm_freak> well, i view it this way:  you can optimize both haskell and C to the absolute maximum speed possible, but then you need to compare the effortâ€¦  it's easier to optimize a small, tight number crunching loop in C
14:24:39 <merijn> ddarius: The barefaced lie is not referring to the complexity, but the assumption that uniform memory access speed is valid
14:24:40 <benmachine> sinelaw: it's a GHC extension that lets you write a derived instance separately from the type definition
14:24:48 <mm_freak> but it's very difficult to optimize concurrent programming in C
14:24:52 <benmachine> sinelaw: it sometimes works on GADTs; it at least tries
14:25:06 <merijn> ddarius: Sure, the complexity is right for a uniform memory system, but that does not mean your complexity is actually right.
14:25:10 <mm_freak> a concurrent program in haskell will almost always be much faster than in C
14:25:10 <benmachine> sinelaw: you need StandaloneDeriving and then you go deriving instance Show Type
14:25:14 <benmachine> that's it
14:25:27 <benmachine> if it typechecks, lucky you, if it doesn't, that sucks
14:25:29 <sinelaw> benmachine, thanks, i'll keep that in mind. first i need to get the basics right (i'm not doing anything tricky, trying to derive manually)
14:25:32 <ddarius> merijn: It doesn't assume that.  It only assumes that access times are bounded by a constant, except in many cases it doesn't really assume that either because the complexity is in terms of some abstract notion of "operations" which can, themselves, be of non-constant time complexity.
14:25:47 <ddarius> merijn: Also there are models that deal with non-uniform access.
14:25:49 <jmcarthur> merijn: intel just the other day proposed that massive multicore might require destroying cache coherency
14:26:11 <merijn> jmcarthur: I know, I have one of those :D
14:26:19 <merijn> Anyway, the point I was trying to make is that this sort of optimization is easier in C then haskell, which might make C a more efficient solution to some problems which was the original question
14:26:40 <merijn> jmcarthur: (I'm assuming you're referring to the Single-chip Cloud Computer and friends)
14:26:57 <revenantphx> This channel is to debate-rage right now ><
14:27:04 <benmachine> merijn: the way my lecturer presented the issue to me once was, you can solve problems of size 100 and your resources increase sixteenfold; your n^2 algorithm can now solve problems of size 400, your 2^n algorithm can solve problems of size 104
14:27:10 <jmcarthur> merijn: i only loosely follow the news. vendors have pretty consistently failed to deliver much of anything interesting lately
14:27:40 <benmachine> merijn: oh sure, if you're saying "some" and "easier", then fine, but just don't dismiss asymptotics outright, that's not fair
14:27:59 <revenantphx> jmcarthur: this was interesting; http://www.pcworld.com/article/203541/chip_startup_developing_probability_processor.html
14:28:07 <revenantphx> Bayesian logic based processor.
14:28:15 <merijn> benmachine: Well, that was my original intention, but then parts of my statements got slowly dragged more and more out of the original conversation context :p
14:29:21 <jmcarthur> revenantphx: neat idea, but too vague for me to get interested
14:29:34 <revenantphx> heh, yeah.
14:29:39 <Adamant> that's a cute idea, but I'd rather see GPU performance comparisons
14:29:40 <merijn> jmcarthur: Its a fairly interesting machine, but drastically "experimental" from a programmer perspective. For example, no cache coherency between cores but no instruction to flush your L2 cache if you want to read/write memory that was accessed by another core. So you have to evict it by reading in 256KB from RAM >.>
14:29:50 <benmachine> merijn: you said the concept of algorithm complexity was flawed and a bare-faced lie
14:29:57 <Adamant> part of the problem is that GPUs are already semi-probablistic
14:30:09 <jmcarthur> merijn: ... ew :)
14:30:27 <Adamant> calculations on them have a much higher error rate than CPU
14:30:46 <merijn> benmachine: I didn't mean the concept in general, the current naive use of it, regardless I think we all agree and now we're just arguing formulation...
14:31:13 <Adamant> also, memresistors
14:31:18 <Adamant> that's the real stuff
14:31:23 <jmcarthur> Adamant: i though they were supposed to guarantee the same results for the same inputs. it's just that the operations as implemented might not do exactly what you expected in the first place
14:31:27 <jmcarthur> *thought
14:31:27 <radioactive_man> algorithm complexity gets even more flawed when moving to parallel computers. then you have work, depth, cost ...
14:32:21 <Adamant> jmcarthur: well, it's __supposed__ to have the same results for the same input
14:32:32 <benmachine> merijn: rubbishing theoretics in #haskell is a pretty good way to generate indignation :P
14:32:40 <Adamant> it doesn't in reality due to errors leaking in
14:32:51 <dancor> in constant time
14:32:53 <benmachine> merijn: it's annoying how little respect some people have for conceptual approaches
14:32:59 <Adamant> benmachine: in the case of massive parallel he's right
14:33:11 <jmcarthur> Adamant: so you mean it's actually probabilistic?
14:33:33 <Adamant> jmcarthur: not intentionally
14:33:37 <jmcarthur> well yeah
14:33:52 <Adamant> just due to suck, compromises, and reality at the hardware level
14:33:58 <ddarius> benmachine: It's fine to do so when you can back up your statements.  The argument that "when misapplied and misinterpreted, this theory gives misleading results" is hardly adequate support.
14:34:01 <merijn> benmachine: Most people here generally have a reasonable conceptual background so I figured I could cut some corners for dramatic hyperbole but that apparently didn't get across so well :p
14:34:09 <Adamant> remember, they've only recently gone general-purpose
14:34:11 <revenantphx> Hey guys, could I get a little help with my simulation :\?
14:34:17 <revenantphx> I think I need to rethink it a bit.
14:34:27 <Adamant> a lot of the errors were irreleveant for graphics processing
14:34:34 <benmachine> merijn: half the people in here have reasonable conceptual background, half of them spend most of their time very confused
14:34:36 <revenantphx> At least, I need to look at the problem slightly differently.
14:34:39 <Adamant> and let them do things faster
14:34:42 <benmachine> (not necessarily different halves, mind)
14:34:44 <merijn> ddarius: So you're saying there isn't a significant amount of programmers commiting performance atrocities due to naive applications of big O notation?
14:35:03 <mee> hmm, can anyone else successfully connect to haskell.org?
14:35:19 <revenantphx> http://downforeveryoneorjustme.com/haskell.org
14:35:20 <benmachine> merijn: I reckon the number of people who commit atrocities by total ignorance of algorithm design are more
14:35:26 <revenantphx> It's down for me.
14:35:30 * benmachine doesn't grammar
14:35:31 <revenantphx> (and everyone)
14:35:39 <revenantphx> benmachine: certainly.
14:35:55 <Adamant> jmcarthur: I don't know what your hardware background is, but for someone used to assuming the hardware never fails, looking at the reality of chips is kinda horrifying
14:36:02 <dancor> down for me and mee
14:36:04 <ddarius> merijn: I actually doubt there is a significant number.  Most that would for -that- reason would know better, and the atrocities that are committed are due to complete ignorance rather than misunderstanding.
14:36:06 <revenantphx> I mean, some facets of big O notation induced optimizing such as, you know, unrolling loops aren't bad ideas in languages like C.
14:36:13 <jmcarthur> Adamant: half my college degree was computer engineering and the other half computer science
14:36:19 <Adamant> ah, then you know
14:36:22 <jmcarthur> yeah
14:36:27 <jmcarthur> reality sucks
14:36:33 <revenantphx> I've seen ignorant people have 12 for loops, and when their program runs slow, they blame it on their if loops doing error checking ,and reove those.
14:36:35 <jmcarthur> i much prefer CS ;)
14:36:36 <ddarius> At any rate, it still doesn't invalidate the theory.
14:36:38 <Adamant> I'm a CS guy who went EE in spare time
14:36:43 <revenantphx> (for something involving iterating over a 2D image)
14:36:46 <Adamant> so it was kind of shocking
14:36:47 <merijn> jmcarthur: Too bad Turing machines are so bad at IO, right?
14:36:52 <revenantphx> Adamant: haha.
14:37:11 <jmcarthur> merijn: turing machines have all their input up front :P
14:37:13 <Adamant> metastablity. how does THAT work
14:37:14 <revenantphx> I will never get any help in here anyhow. :|
14:37:19 <benmachine> aww
14:37:22 * benmachine hugs revenantphx 
14:37:23 <Adamant> revenantphx: what's the problem?
14:37:25 <benmachine> I ca give you moral support
14:37:32 <jmcarthur> revenantphx: those are the magic words, of course
14:37:48 <revenantphx> Well, I have an existing simulation... and I'd simply like to rewrite it in haskell (for fun)
14:38:07 <Adamant> jmcarthur: it's better than him having to pretend he has boobies or talk shit about the channel topic, admittedly.
14:38:28 <jmcarthur> revenantphx: "can i get some help?" doesn't get you help. direct questions are more effective
14:38:33 <revenantphx> That's ture.
14:38:44 <revenantphx> It'd be easier than outlining if I just paste the C no?
14:38:59 <jmcarthur> i'd just ask questions
14:38:59 <revenantphx> https://github.com/DylanLukes/Ants/blob/master/Ants.c
14:39:11 <mee> revenantphx: http://www.fatvat.co.uk/2010/08/ants-and-haskell.html
14:39:12 <jmcarthur> well, the C source can help, depending on the questions
14:39:27 <revenantphx> mee: FFFFFFFFFâ€“
14:39:31 <revenantphx> That's amusing.
14:39:36 <sinelaw> Question: how would you go about implementing a DSL that has the dsl type info embedded in the structure?
14:39:37 <revenantphx> Anyways, I'm not working a grid though.
14:40:03 <sinelaw> that is, looking at any dsl value you can tell its in-dsl type
14:40:19 <jmcarthur> sinelaw: you mean at runtime?
14:40:24 <sinelaw> jmcarthur, yes
14:40:26 <revenantphx> The issue here is just... I'm not sure how to think about this problem functionally.
14:40:40 <sinelaw> jmcarthur, for example so that i may generate code with type annotations
14:40:42 <revenantphx> That's really the issue tbh.
14:40:48 <sinelaw> jmcarthur, such as C
14:41:15 <jmcarthur> sinelaw: the usual approach would of course be to use type classes
14:42:06 <sinelaw> jmcarthur, how exactly? (simple example?)
14:42:45 <revenantphx> mee: that helps significantly, I'm going to look through it.
14:43:51 <jmcarthur> sinelaw: something like Typeable is an example, although you would go with something more specific to your DSL normally
14:44:06 <copumpkin> sinelaw: or a GADT for your terms
14:44:14 <sinelaw> copumpkin, i have a gadt
14:44:19 <jmcarthur> i was assuming a gadt already
14:44:29 <copumpkin> sinelaw: check out the operational monad by apfelmus
14:44:39 <cole> Perhaps the more important question (and the one that's most relevant to me) is "How long does it typically take to write a program that does X in haskell vs, in, say, c" and "how much time do you spend debugging it once it's written?" Anyone have any objective answers to that question?
14:44:41 <copumpkin> there's a decent example of it too
14:45:03 <copumpkin> cole: it's hard to be objective with such a huge variable (the writer of the code) omitted
14:45:09 <jmcarthur> sinelaw: another way to share type and term information is to use singleton types. they can get hairy in haskell depending on the complexity of what you're doing
14:45:27 <revenantphx> Could not find Data.Vector.
14:45:28 <revenantphx> shirt.
14:45:41 <merijn> cole: In my experience I spend a lot of time meditating on type signatures, very little time coding, even less time debugging once it actually compiles :p
14:45:43 <radioactive_man> cole, i have written a 2k loc parallelizing compiler in haskell, and a much simpler one in java/c++.
14:45:45 <copumpkin> revenantphx: did you cabal install it?
14:45:55 <revenantphx> apparently not
14:46:00 <copumpkin> radioactive_man: does that say something about you or haskell/java/c++?
14:46:04 <mee> cole: the last attempt I've seen to answer that with any objectivity was a paper by IBM a couple decades ago
14:46:06 <merijn> cole: In C I spend less time thinking and drastically more time coding/debugging
14:46:18 <radioactive_man> compilers in c++ are *far* more difficult
14:46:22 <jmcarthur> sinelaw: basically a singleton type is just a type with only one value, e.g.    data Nat a where Zero :: Nat Z ; Succ :: Nat n -> Nat (S n)
14:46:28 <medfly`> cole, it is a really hard comparison and should only done by calculated averages, not by reported things
14:46:42 <jmcarthur> sinelaw: so every value you can construct from that has a unique type
14:46:42 <medfly`> cole, when I have fun time seems shorter :)
14:46:47 <copumpkin> radioactive_man: oh, I misunderstood you
14:46:49 <medfly`> cole, and so you cannot trust anything people say
14:46:54 <merijn> cole: Why all the questions? Are you figuring out whether to learn or not?
14:46:58 <copumpkin> radioactive_man: you support my position, so I shall not question you!
14:47:05 <revenantphx> Btw guys, if I go ahead with writing a simple compiler next year, I'm thinking it'd be fun to use haskell for the lexer and parser :\
14:47:15 <revenantphx> (LLVM as a backend)
14:47:17 <copumpkin> revenantphx: it's more fun to write for the actual compiler
14:47:17 <benmachine> revenantphx: haskell parsers are sexy
14:47:19 <benmachine> true fact
14:47:19 <jmcarthur> cole: that's a difficult question to answer objectively
14:47:27 <revenantphx> benmachine: I believe you.
14:47:34 <revenantphx> Using haskell for strings sounds much sexier than... C++
14:47:36 <revenantphx> *shivers*
14:47:44 <revenantphx> Or C for that matter.
14:47:57 <merijn> Using anything for anything sounds sexier then using C++...
14:48:00 <benmachine> :P
14:48:01 <revenantphx> merijn: agreed.
14:48:19 <revenantphx> copumpkin: what's the cabal install name for Data.Vector?
14:48:20 <merijn> Unless you're like me and pretend C++ is just C with namespaces :p
14:48:26 <revenantphx> I can never remember how it's supposed to go.
14:48:32 <revenantphx> merijn: What? C++ has classes?
14:48:33 <benmachine> revenantphx: vector
14:48:34 <benmachine> I think
14:48:36 <revenantphx> Huh, you don't say.
14:48:40 * ddarius would rather use C++ than C any day, particularly for string manipulation or parsing.
14:48:42 <copumpkin> revenantphx: yep, vector
14:48:43 <sinelaw> hm
14:48:52 <revenantphx> ddarius: Have fun with your ungodly STL.
14:48:58 <ddarius> revenantphx: I do.
14:49:01 <merijn> ddarius: I try to not do string manipulation in C :p
14:49:02 <[swift]> merijn: i do the same, except I also find templates handy =)
14:49:03 <copumpkin> it's not that bad
14:49:10 <benmachine> revenantphx: oh, because the C standard library is...
14:49:10 <copumpkin> templates are the best part of C++
14:49:23 <revenantphx> benmachine: very. very, small.
14:49:25 <benmachine> (...hideously inadequate)
14:49:38 <revenantphx> benmachine: Well, it's not meant to be a gargantuan set of utilities.
14:49:42 <Twey> Heh, I love how there's a tool to process STL error messages into something readable by humans
14:49:49 <revenantphx> Twey: I know right?
14:49:50 <merijn> benmachine: They could've added a generic list and map to it, yeah >.>
14:49:53 <radioactive_man> but c++ templates are far worse than metaprogramming features in other languages e.g. th
14:49:54 <copumpkin> Twey: g++'s error messages
14:49:58 <cole> merijn: I'm trying to decide whether I should soak the time into learning the language: "Will it practically serve me" is what I'm trying to figure out.
14:50:08 <merijn> cole: I'd say, yes
14:50:11 <copumpkin> radioactive_man: they're closer to haskell's typeclasses, I'd think
14:50:15 <copumpkin> at least in terms of how you'd use them
14:50:19 <revenantphx> cole: Haskell has fucked more guys than the Water Temple, but it's totally worth it.
14:50:24 <copumpkin> but they do generate specialized code
14:50:25 <merijn> cole: Even if you don't code haskell, my C and python code has improved drastically from learning haskell
14:50:32 <benmachine> revenantphx: but it seems I quite often find a man page for a C standard function that includes the words "don't ever use this function"
14:50:32 <revenantphx> merijn: yep yep.
14:50:35 <ddarius> radioactive_man: The fact that C++ templates weren't intended to be a metaprogramming feature makes that not a very pointed argument.
14:50:37 <Twey> copumpkin: There's something that gives better ones?  :Ã¾
14:50:38 <revenantphx> benmachine: like what?
14:50:45 <benmachine> revenantphx: apart from gets?
14:50:48 <benmachine> hmm
14:50:53 <revenantphx> Yeah, gets is the only one that comes to mind.
14:50:54 * benmachine tries to remember
14:50:58 <revenantphx> I mean, goto.... but I use goto.
14:51:15 <benmachine> strtok is fairly awful
14:51:15 <revenantphx> I use goto in certain situations, namely where I have the same cleanup code for a dozen or so different routines...
14:51:16 <Twey> strcpy?
14:51:20 <merijn> cole: Haskell requires quite a bit of effort to break away from thinking about programming like you're used to. But once you grok it, you'll have a matrix moment and never think about code the same way again
14:51:23 <benmachine> strncpy is
14:51:29 <benmachine> silly in the extreme
14:51:30 <revenantphx> using strncpy instead is kind of common sense though no?
14:51:36 <benmachine> no
14:51:37 <revenantphx> Instead of strcopy at least.
14:51:43 <Twey> scanf("%s")
14:51:43 <revenantphx> strcpy*
14:51:46 <benmachine> because it doesn't terminate teh string if you hit the limit
14:51:52 <revenantphx> scanf is not recommended, true.
14:51:56 <radioactive_man> cole, you can expect to gain most benefits from reading two single books about haskell
14:52:03 <merijn> benmachine: There's a strncpy version which does
14:52:09 <benmachine> merijn: is it standard?
14:52:11 <olsner> memcpy > strncpy
14:52:15 <revenantphx> olsner: this.
14:52:23 <merijn> benmachine: Maybe, maybe not? I forgot
14:52:27 <benmachine> merijn: I don't think so
14:52:29 <radioactive_man> cole, "implicit parallel programming in ph by nikhil" and "research directions in parallel functional programming from Hammond"
14:52:38 <revenantphx> ld: library not found for -lglut
14:52:42 <revenantphx> god dammit, I did cabal install glut
14:52:49 <merijn> I tend to recommend Learn You A Haskell. LYAH is awesome
14:52:58 <radioactive_man> because parallel programming and metaprogramming are *the* use cases for purely functional languages
14:53:05 <cole> Thanks.
14:53:08 <revenantphx> that way BONUS can have his ego more fully expand >:D
14:53:12 <merijn> @where lyah
14:53:12 <lambdabot> http://www.learnyouahaskell.com/
14:53:21 * ddarius has done very little parallel or meta programming in Haskell.
14:53:22 <benmachine> what about sprintf? on complex formats how much of a pain is it to make sure that's safe?
14:53:39 <revenantphx> benmachine: C places the burden of safety on the programmer. That's pretty much it.
14:53:46 <jmcarthur> sinelaw: did i help or make worse?
14:53:57 <benmachine> revenantphx: the standard C library places the burden of implementing everything on the programmer :P
14:54:02 <merijn> I'm working on a master project designed to trick silly imperative programmers into doing functional programming without realizing it ;p
14:54:03 <benmachine> (re-)implementing
14:54:08 <revenantphx> benmachine: eh, pretty much
14:54:10 <sinelaw> jmcarthur, i've been away from haskell for long enough to forget 50% of what i knew
14:54:14 <sinelaw> which, btw, wasn't a lot
14:54:16 <merijn> (Under the argument of better concurrent programming)
14:54:20 <jmcarthur> heh
14:54:21 <revenantphx> HNNNGH
14:54:25 <revenantphx> I DO HAVE GLUT >:(
14:54:46 <revenantphx> Oh, god dammit, it's because OS X keeps glut in Glut.framework, not libglut
14:54:58 <revenantphx> I wonder if symlinking that would work 0.o
14:55:04 <benmachine> revenantphx: :O
14:55:15 <benmachine> revenantphx: I wouldn't advise it, isn't there a --framework option or something
14:55:25 <revenantphx> I'll check.
14:55:26 <benmachine> revenantphx: or a frameworks field in cabal files
14:55:30 <benmachine> I think there's something like that
14:55:34 <revenantphx> Unix Solution For Everything #27: ln -s
14:56:13 <benmachine> I like symlinking a directory to its parent and then holding down tab
14:56:21 <revenantphx> benmachine: sadist
14:56:30 <benmachine> so what if I am >_>
14:56:52 <sinelaw> jmcarthur, this is what i have so far http://hpaste.org/41749/gadt_test
14:57:00 <revenantphx> eh, it's no problem. I PROGRAM IN C, who am I to talk XD.
14:57:07 <revenantphx> (that's masochism right there)
14:57:19 <jmcarthur> sinelaw: ah!
14:57:24 <jmcarthur> sinelaw: i would do something different
14:57:30 <merijn> revenantphx: Depends on the sort of programming
14:57:37 <jmcarthur> sinelaw: i would expose the type in the GADT
14:58:02 <merijn> revenantphx: I don't see haskell as realistic option for kernel mode code in a C based kernel :p
14:58:03 <sinelaw> jmcarthur, you mean Expr to have two parameters?
14:58:10 <revenantphx> merijn: very true :3
14:58:11 <jmcarthur> sinelaw: nope. h/o
14:58:18 <revenantphx> So uh, how can I get this working > <
14:58:23 <ddarius> @google Haskell device drivers
14:58:24 <lambdabot> http://programatica.cs.pdx.edu/House/
14:58:24 <lambdabot> Title: House
14:58:25 <cole> Are there job opportunities for haskell programmers?
14:58:31 <ddarius> Bah, not what I wanted.
14:58:41 <sinelaw> cole, junction windscreen wipers
14:58:49 <revenantphx> How the hell can I link in glut > >
14:58:53 <merijn> Academic paper junkies :p
14:59:01 <merijn> revenantphx: Try asking #macdev?
14:59:03 <copumpkin> cole: no, none.
14:59:10 <revenantphx> Not many people in there know haskell.
14:59:11 <merijn> IRC channel for mac developers
14:59:33 <sinelaw> cole, irc trolls, as you can see
14:59:36 <merijn> revenantphx: No, but they might know how to link glut to C, then you can try the same for haskell?
14:59:58 <revenantphx> I know how to link it into C
15:00:04 <revenantphx> pass --framework GLUT to the linker :\
15:00:10 <copumpkin> cole: I mean, very jobs will have you actually programming in haskell, but it's generally considered a symbol of you knowing CS quite well and being a decent programmer (and wanting to learn things for their own sake, which by telling you this I'm invalidating), so people will look at you positively.
15:00:16 <copumpkin> *very few jobs
15:00:19 <revenantphx> er, compiler*
15:00:25 <revenantphx> not sure who uses that, but it's a compiler flag.
15:00:27 * Axman6 will have a job programming in haskell within days :D
15:00:35 <jmcarthur> sinelaw: in this particular case i had to make some assumptions about your DSL, and in its current state it needn't actually be a GADT, but as you extend it the GADT could still be useful http://hpaste.org/paste/41749/type_in_gadt#p41750
15:00:39 <ddarius> copumpkin: You should have stuck with your original answer.
15:00:43 <revenantphx> (it just tells it to load the dylib at the frameworks core)
15:00:56 <copumpkin> ddarius: probably
15:01:00 <polarina> Why are many libraries poorly documented with nothing but "See <some Ph.D.> for reference."?
15:01:15 <copumpkin> polarina: because people don't like writing documentation?
15:01:16 <jmcarthur> sinelaw: but the idea is that once you have the DSL type in the haskell type system, you can use a type class to multiplex over the DSL type
15:01:19 <merijn> polarina: Documentation doens't get you published :p
15:01:21 <jmcarthur> *dispatch
15:01:30 <ddarius> copumpkin, polarina: Because people rarely read documentation.
15:01:48 <jmcarthur> sinelaw: e.g.   class DSLType a where dslType :: Exp a -> String
15:01:50 <sinelaw> jmcarthur, you just made it more lenient
15:01:58 <monadic_kid> ddarius: o_0
15:02:03 <merijn> I'm pretty sure if docs were a requirement for getting your paper published we'd see a sudden increase in documentation for haskell :p
15:02:10 <radioactive_man> i think, some haskell developers have jobs at microsoft
15:02:15 <merijn> radioactive_man: Yes
15:02:19 <jmcarthur> sinelaw: is that bad?
15:02:28 <merijn> Microsoft Research does quite a bit of haskell
15:02:38 <copumpkin> cole: put another way, most people in here learned haskell out of curiosity, not because it served a purpose. Curiosity of that sort tends to be correlated with things that employers might want. It's also quite mind-bending in many ways, which shows you're capable of more abstraction than the average programmer.
15:02:41 <sinelaw> jmcarthur, the first argument to Assignment must be a variable, e.g.
15:02:52 <radioactive_man> impressive that its stable and runs on linux ;)
15:03:04 <jmcarthur> sinelaw: ah. then i would make that a separate type, yeah
15:03:12 <jmcarthur> sinelaw: let me try again
15:03:18 <sinelaw> jmcarthur, ok cool
15:03:59 <monadic_kid> i think that's the reason why people think abstractions like monads are complicated, before they've come across they've never seen abstractions of computations in library form
15:04:03 <copumpkin> cole: having you ask if haskell is good for jobs makes me feel a bit like the jolly professor who loves his subject having a student ask "will this be on the test?" though
15:04:06 <revenantphx> hey um ,one question
15:04:08 <sinelaw> jmcarthur, you see, we're already dealing with types
15:04:10 <monadic_kid> *they've never
15:04:13 <revenantphx> if I'm compiling ghc produced .o's 
15:04:20 <revenantphx> what do I need to link in for haskell?
15:04:27 <jmcarthur> sinelaw: http://hpaste.org/paste/41749/with_variable_type#p41751
15:04:28 <revenantphx> manually compiling with gcc, I might add.
15:04:35 <sinelaw> although being a variable rather than a literal is a matter of syntax typing, not value typing
15:04:42 <sinelaw> or something like that :)
15:04:44 <jmcarthur> sinelaw: "variable" is not a type
15:04:47 <jmcarthur> :P
15:04:48 <polarina> ddarius, how can the users figure out how to use a library without documentation?
15:04:54 <copumpkin> polarina: the types!
15:04:57 <sinelaw> jmcarthur, that's what i meant by "something like that"
15:04:58 <copumpkin> ;)
15:04:59 <jmcarthur> why did i use data instead of newtype?
15:05:05 <stroan_> I have to agree with copumpkin. I got my job because I gushed about some of the things I love about Haskell in the interview, not because it was a Haskell house
15:05:14 <jmcarthur> sinelaw: anyway, any more objections/questions? :)
15:05:24 <polarina> copumpkin, the types don't tell much.
15:05:28 <jmcarthur> sinelaw: do you understand the direction i'm trying to nudge you in?
15:05:33 <copumpkin> polarina: then the library needs moar typez!
15:05:43 <sinelaw> jmcarthur, nope, and isn't variable also supposed to be an expression?
15:05:45 * sm got a non-haskell job in part due to his haskell interest
15:05:46 <polarina> ...
15:05:47 <copumpkin> if you'll forgive my lolcat
15:05:52 <jmcarthur> i did weaken it, yeah
15:05:56 <jmcarthur> one more extension
15:06:14 <copumpkin> polarina: I dunno, names, source code, etc.
15:06:21 <copumpkin> example code?
15:06:24 <blackdog> sm: I used to hire haskell guys to do perl work. cruel, perhaps.
15:06:25 <copumpkin> reading the actual paper referenced?
15:06:29 <jmcarthur> sinelaw: http://hpaste.org/paste/41749/variable_can_be_expression#p41752
15:06:39 <polarina> copumpkin, I haven't found any example code yet, yet it seems to be a popular library.
15:06:41 <ddarius> polarina: The same way they do it without reading it.
15:06:45 <copumpkin> polarina: what is it?
15:06:47 <copumpkin> Monoid?
15:06:49 <polarina> copumpkin, arrows
15:06:53 <sinelaw> jmcarthur, and i'm not sure i'm getting at what you're trying to say, if you're not already
15:06:57 <jmcarthur> sinelaw: i think it was a flaw in your version that the lhs was an expression
15:06:58 <sinelaw> saying it explicitly
15:07:06 <copumpkin> polarina: there's plenty of papers about it, including tutorial papers
15:07:15 <copumpkin> there's also http://en.wikibooks.org/wiki/Haskell/StephensArrowTutorial
15:07:18 <polarina> copumpkin, where can I find some tutorials?
15:07:20 <jmcarthur> sinelaw: see how the type parameter now talks about the DSL type?
15:07:26 <revenantphx> ...cmon...
15:07:29 <jmcarthur> sinelaw: instead of syntactic things?
15:07:29 <revenantphx> YESSSS
15:07:33 <revenantphx> -package GLUT did the trick.
15:07:37 <sinelaw> hmmm
15:07:50 <roconnor> when you write an OS kernel in C, do you have access to the CRT?
15:07:50 <sinelaw> yes
15:07:53 <jmcarthur> sinelaw: that means you can get to it with a type class now, so you can inspect it at runtime
15:07:54 <sinelaw> but how can i use that
15:08:02 <jmcarthur> sinelaw: or rather, dispatch over it
15:08:10 <copumpkin> polarina: there's http://haskell.org/arrows with plenty of information and papers on them, also just google haskell arrows
15:08:12 <sinelaw> that's the part i don't get
15:08:17 <copumpkin> there's wikis and wikibooks and lots more
15:08:33 <sinelaw> wikibookbooks, wikibookbookbooks
15:08:39 <jmcarthur> sinelaw: so for example, whatever you would have done before over the Literate ADT, you now can do with a type class that has instances for at least Int, Double, Char, and String
15:08:48 <jmcarthur> *Literal
15:09:00 <polarina> copumpkin, I've been trying to understand how arrows work for some time now, with no avail. I'll take a look at these. Thanks.
15:09:04 <ddarius> polarina will never make it in the corporate world without boning up on Google coding (and even less without boning up on Googling.)
15:09:12 <jmcarthur> sinelaw: but now that i realize you were calling some syntactic things "types" i wonder now if i actually understand the original question
15:09:13 <sinelaw> jmcarthur, because the type must eventually be one of those
15:09:16 <copumpkin> > map (++ "s") . iterate (++ "book") $ "wiki"
15:09:17 <lambdabot>   ["wikis","wikibooks","wikibookbooks","wikibookbookbooks","wikibookbookbookb...
15:09:25 <sinelaw> the types of values
15:09:30 <jmcarthur> okay, then i do
15:10:02 <sinelaw> i was talking about types of syntax terms if there ever is a thing
15:10:07 <sinelaw> which there is
15:10:07 <sinelaw> :)
15:10:09 <polarina> ddarius, I've been googling...
15:10:13 <sinelaw> maybe "type" is wrong
15:10:31 <sinelaw> it's just the question of "which data constructor" 
15:10:37 <sinelaw> of Expr
15:10:37 <revenantphx> I need to learn how to use STM
15:10:45 <jmcarthur> okay, now i'm certain that i'm confused
15:10:53 <revenantphx> Anyone know a good resource?
15:10:56 <ddarius> polarina: I didn't say you weren't Googling, I said you were bad at it.
15:11:00 <sinelaw> so we're settled
15:11:02 <sinelaw> ;)
15:11:06 <jmcarthur> revenantphx: real world haskell has a chapter i think
15:11:11 <revenantphx> gotcha, cool.
15:11:26 <roconnor> revenantphx: http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.64.1678&rep=rep1&type=pdf
15:11:26 <jmcarthur> sinelaw: what specifically do you need to do?
15:11:27 <sinelaw> jmcarthur, never mind, what you showed me is probably what i really need
15:11:31 <jmcarthur> okay
15:11:43 <sinelaw> looking at every Expr a i can now tell its type
15:11:52 <jmcarthur> yes
15:11:54 <sinelaw> especially if I do
15:11:55 <roconnor> revenantphx: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/beautiful.pdf
15:12:01 <polarina> ddarius, :(
15:12:09 <revenantphx> k that should be sufficient for now.
15:12:09 <roconnor> revenantphx: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/stm.pdf
15:12:22 <sinelaw> class DSLType a  where dslType :: Expr a -> Type
15:12:32 <sinelaw> data Type = TInteger | TDouble ....
15:12:36 <roconnor> revenantphx: that is all I have
15:12:38 <sinelaw> jmcarthur, that ^
15:12:42 <jmcarthur> sinelaw: Typeable can do that for you already ;)
15:12:48 <revenantphx> roconnor: beautiful.pdf == obviously LaTeX'd
15:13:02 <copumpkin> XeTeX'd
15:13:11 <revenantphx> copumpkin: how do you know?
15:13:19 <copumpkin> I don't
15:13:23 <copumpkin> just talking in general
15:13:27 <copumpkin> if it's beautiful and a PDF
15:13:29 <copumpkin> it's probably xetex
15:13:30 <kloppo> i saw a chapter on reddit about a dude creating a minecraft-like. he was using an OCtree to store the state of the map. it got me thinking (i have no clue), how would you do something like this in haskell? because the map changes every turn, do you need to rebuild the OCTree from the ground up?
15:13:31 <sinelaw> jmcarthur, ok i'll look at Typeable
15:13:38 <revenantphx> thanks guys
15:14:00 <jmcarthur> sinelaw: really though, i don't think getting a first class representation of the *type* is what you want to do
15:14:04 <roconnor> kloppo: with pointer sharing only log(n) of the OCTree needs to be rebuilt
15:14:14 <roconnor> typically
15:14:16 <sinelaw> kloppo, one word interspersed with spaces: Purely Functional Data Structures
15:14:32 <sinelaw> jmcarthur, why not
15:14:48 <sinelaw> kloppo, actually i don't know, but that book talks about that
15:14:49 <jmcarthur> sinelaw: all you can do after that is pattern match it somewhere later to get different functionality and stuff. since you have a DSLType type class already, you might as well just put whatever functionality you will implement out of Type right in the type class
15:14:52 <kloppo> roconnor, the log(n) part would be the changed leaf node and all the brances going up to the parent?
15:15:28 <kloppo> sinelaw, i have no clue myself (i'm just curious really, no plans to need something like this)
15:15:31 <jmcarthur> sinelaw: for example, instead of having a function  stringType :: Type -> String, you could just have a method in the type class to do that directly without giving you a Type first
15:15:42 <sinelaw> jmcarthur, i don't like that very much
15:15:51 <sinelaw> i'd rather first have the data structure
15:16:00 <jmcarthur> sinelaw: it's the purpose of type classes :\
15:16:03 <sinelaw> and later do stuff with it , not limit the stuff i want to do
15:16:09 <jmcarthur> so that you don't have to manually dispatch over types
15:16:23 <jmcarthur> sinelaw: you're limited already by having that type class constraint
15:16:31 <sinelaw> you mean implement a type class for each functionality i want to implement of the structure?
15:16:36 <jmcarthur> no
15:16:44 <sinelaw> of=for
15:16:44 <jmcarthur> just a type class for the type-dependent behaviors you need
15:16:55 <sinelaw> one for each, or one total?
15:16:56 <jmcarthur> not for all functionality
15:17:06 <sinelaw> yes, i meant type-related functionality
15:17:26 <sinelaw> but one type class for each of the type-related features
15:17:28 <jmcarthur> what kind of stuff will you even be doing with it? i bet it's a pretty limited set of operations
15:17:28 <sinelaw> right?
15:17:31 <jmcarthur> no
15:17:36 <sinelaw> i'm not sure 
15:17:41 <jmcarthur> just one type class would probably be enough
15:18:10 <sinelaw> jmcarthur, question is will i be able to always add "more type related functionality" outside my module
15:18:26 <sinelaw> or is there some reason they all have to be in one type class
15:18:43 <sinelaw> i guess not
15:18:54 <jmcarthur> sinelaw: without more concrete information about what you are actually doing with this type information i can't answer that
15:18:58 <sinelaw> haskell.org seems dead, btw
15:19:01 <jmcarthur> yeah :(
15:19:35 <sinelaw> jmcarthur, i'm having thoughts about some sort of limited type inference
15:19:37 <sinelaw> for the dsl
15:20:01 <sinelaw> actually haskell will take care of that
15:20:05 <jmcarthur> yeah :)
15:20:06 <sinelaw> for most cases
15:20:08 <jmcarthur> that's why GADTs rock
15:20:25 <sinelaw> is there any case where it won't?
15:20:38 <jmcarthur> that's hard to answer
15:20:46 <sinelaw> right
15:20:48 <jmcarthur> it depends on how fancy you're getting
15:20:59 <ddarius> jmcarthur: You could do such things before GADTs.
15:21:01 <jmcarthur> if all you want is haskell-style type inference, you'll get everything haskell has to offer
15:21:03 <sinelaw> i'm not going to implement agda as my DSL :)
15:21:06 <jmcarthur> ddarius: yeah, type classes, etc.
15:21:18 <ddarius> You don't need type classes either.
15:21:20 <jmcarthur> sinelaw: then you're probably fine
15:21:22 <copumpkin> you can't pattern match on type class methods and get refinement though
15:21:44 <sinelaw> ok thanks for the help
15:21:49 <jmcarthur> copumpkin: but you can do quite a lot!
15:21:57 <copumpkin> yep
15:22:08 <ddarius> copumpkin: Seeing as that -is- the thing GADTs add, this isn't surprising.
15:22:17 <sinelaw> what i'm dreaming of, btw, is a general dsl for object oriented imperative languages with what they call "generics"
15:22:39 <ddarius> That doesn't sound very domain specific.
15:22:42 <sinelaw> jmcarthur, which reminds me why i need type stuff
15:22:47 <mm_freak_> (M a, >>=, return) is a monoid, right?
15:22:53 <copumpkin> mm_freak_ >_>
15:22:56 <copumpkin> >=> that is
15:22:58 <sinelaw> ddarius, ok, what's the proper name then? :)
15:22:59 <ddarius> mm_freak_: It doesn't even have the write type.
15:23:20 <mm_freak_> copumpkin: i see
15:23:22 <ddarius> sinelaw: "programming language"
15:23:29 <ddarius> s/write/right
15:23:34 <sinelaw> :)
15:23:39 <opqdonut> (M a, >>=, return x) is a monoid for all x\in a
15:23:40 <opqdonut> :)
15:23:54 <opqdonut> gah, >=>
15:24:02 <mm_freak_> hmm, i wonder whether it's 'M a' or just 'M'
15:24:03 <ddarius> Besser.
15:24:34 <mm_freak_> or forall a. M a
15:24:46 <opqdonut> one can probably cobble a monoid from just >=> and return by inserting a few .'s
15:25:02 <opqdonut> of type a->M a
15:25:08 <jmcarthur> sinelaw: don't we have generics in haskell already? isn't it just parametric polymorphism?
15:25:09 <mm_freak_> opqdonut: why the 'x'?
15:25:19 <opqdonut> wait a second
15:25:26 <opqdonut> :t (>=>)
15:25:27 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
15:25:28 <mm_freak_> i'd say that (c >=> return) = c
15:25:34 <opqdonut> yeah sorry
15:25:38 <Darkone> @src foldM
15:25:39 <lambdabot> foldM _ a []     = return a
15:25:39 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
15:25:39 <opqdonut> (M, >=>, return)
15:25:45 <opqdonut> dunno what I was thinking
15:25:54 <sinelaw> jmcarthur, it is
15:25:59 <sinelaw> a limited form thereof
15:26:00 <mm_freak_> the forall is important, i guess
15:26:01 <opqdonut> and (M a, `mplus`, return x)
15:26:02 <jmcarthur> sinelaw: or perhaps type parameters, at least
15:26:11 <mm_freak_> (forall a. M a, >=>, return)
15:26:13 <copumpkin> sinelaw: limited how?
15:26:19 <jmcarthur> sinelaw: oh so you are talking about a generalization of some sort?
15:26:31 <sinelaw> copumpkin, in java at least
15:26:42 <copumpkin> oh
15:26:53 <copumpkin> I understood it backwards
15:26:56 <jmcarthur> me too
15:27:00 <sinelaw> copumpkin, for example the compiler for some reason "forgets" during compile time what the type parameter is
15:27:06 <sinelaw> (although it knows)
15:27:06 <jmcarthur> i thought sinelaw was saying that haskell's generics were limited
15:27:13 <sinelaw> heh not at all :)
15:27:13 <copumpkin> yeah,  I know java's suck
15:27:42 <sinelaw> you can't do this in java: class A<T> { static T blabla; }
15:27:44 <jmcarthur> sinelaw: so it sounds like you are trying to write a DSL in haskell that just mirrors what haskell can do already...
15:28:04 <sinelaw> jmcarthur, what i want is to be able to generate Java / C# code out of the programs
15:28:10 <sinelaw> without hacking into ghc
15:28:24 <mm_freak_> hmm, no, the forall makes it invalid
15:28:25 <sinelaw> predictable code
15:28:30 <jmcarthur> you could do that with a more functional-style dsl though. it doesn't have to look imperative (although of course it's your choice if it does)
15:28:45 <copumpkin> mm_freak_: you can't actually make it a haskell monoid instance
15:28:49 <sinelaw> yeah
15:28:51 <copumpkin> but it is a monoid in some sense
15:29:07 <mm_freak_> copumpkin: sure, i'm just playing
15:29:08 <sinelaw> i just want to start with something simpler
15:30:10 <jmcarthur> newtype KleisliMonoid m a = KM (a -> m a)
15:30:11 <copumpkin> newtype Kleisliish m = Kleisliish (forall a. a -> m a)
15:30:18 <copumpkin> lol
15:30:22 <jmcarthur> no need for the higher rank
15:30:50 <jmcarthur> instance Monad m => Monoid (KleisliMonoid m a)
15:37:17 * ddarius decides to walk to a coffee shop in Cambridge.
15:38:08 <Twey> ddarius: Which Cambridge?
15:38:30 <ivanm> either way, it's too far to walk for me
15:38:32 <ivanm> :p
15:39:15 <revenantphx> so ah, how are these different? https://gist.github.com/712786
15:39:25 <revenantphx> are the braces & semicolons just a way of avoiding indentation?
15:39:27 <[swift]> i need to do the same
15:39:45 <[swift]> last week i spent 3 days in a row inside and it drove me mad
15:40:19 <[swift]> the problem with being a graduate student is there's often nothing to force you to leave
15:40:23 <Darkone> @src Either
15:40:24 <lambdabot> Source not found. Sorry.
15:40:31 <Darkone> :t Either
15:40:31 <Cale> revenantphx: essentially, yes. The meaning of indentation is defined in terms of the braces and semicolons syntax.
15:40:32 <lambdabot> Not in scope: data constructor `Either'
15:40:41 <revenantphx> Cale: explain?
15:40:52 <Darkone> Where would either be?
15:41:01 <revenantphx> I mean, I find the brace/semicolon syntax more appealing > >... but that's just me I suppose.
15:41:51 <Cale> revenantphx: The Report defines the indentation-sensitive parts of the syntax by way of an algorithm for inserting braces and semicolons.
15:42:02 <revenantphx> Yeah, I saw the four rules.
15:42:18 <Darkone> Uhhmm
15:42:22 * ddarius will never understand people.  I should get rid of them.
15:42:26 <sinelaw> where can i read about Typeable
15:42:36 <sinelaw> expect for yale-based dead websites
15:42:49 <Darkone> When you use Either, do you use it basically like Maybe, but shoving error messages into Left?
15:43:08 <sinelaw> ?
15:43:11 <Cale> The main thing you need to remember about indentation is just to align things which are siblings of each other, and children start in a deeper column than their parents.
15:43:14 <Darkone> So that if anything fails, it returns an error message?
15:43:21 <Darkone> Like Either String Double
15:43:33 <Cale> This is a stricter rule than actually applies, but it results in consistently pretty code.
15:44:25 <Darkone> http://hpaste.org/41754/arrgghh
15:44:45 <revenantphx> It's cute what happans when you try to do two hPutStr's at once.
15:44:46 <revenantphx> *Main> main
15:44:46 <revenantphx> Hel lwoorld
15:44:47 <revenantphx> *Main> main
15:44:47 <revenantphx>  wHoerllldo
15:44:51 <revenantphx> ghci is drunk ^_^
15:45:08 <medfly`> ^^
15:45:14 <Darkone> Someone mind looking at my little code there and telling me if I'm doing much of anything right? :P
15:45:22 * revenantphx can't help you.
15:46:29 <enthropy> Darkone: length a > 1   isn't as lazy as it could be
15:46:51 <copumpkin> genericLength a > 1 could be as lazy as it could be
15:47:00 <Darkone> I mean, I'm getting errors, so I probably screwed up more than just what's erroring.
15:47:01 <jmcarthur> with the right type
15:47:26 <Darkone> Also, this HLint hints is neat o.o
15:47:32 <enthropy> and to stop the code from going off the right side of the page, you can put a newline after the 'of'
15:47:50 <enthropy> just like you indent following 'do'
15:47:56 <conal> does anyone here know what's going on with the haskell wiki? i just got a dozen messages saying my pages have been edited by a user named "Ipyzykeho", giving urls like http://new-www.haskell.org/haskellwiki/ZipFold . (note "new-www".)
15:48:13 <dons> spamming, likely.
15:48:14 <copumpkin> conal: spambots?
15:48:35 <kyagrd> what is new-www?
15:48:36 <conal> that's my hunch
15:49:10 <Twey> Spambot it is
15:49:12 <conal> the pages i get pointed to then point offsite.
15:49:15 <kyagrd> ewe haskell hompage main is vandalized as well it says under construction in the right column
15:49:25 <Twey> kyagrd: There's a new site under construction.
15:50:11 <copumpkin> no, it's spam
15:50:30 <Twey> http://new-www.haskell.org/ is not spam
15:50:30 <KSkrzet> does running several 'cabal install' commands in parallel is safe?
15:50:31 <Evious> Trying to install timeplot... It fails due to missing glib, which I can't install due to not found gtk2hsC2hs, which I managed to install but now it can't be found despite being in PATH and callable via command line. :[
15:50:39 <Twey> The links added on it by the bot are
15:50:39 <Evious> Haskell's GUI bindings need help.
15:50:41 <copumpkin> Twey: there is spam on it
15:50:42 <copumpkin> yeah
15:50:43 <kyagrd> I think what's going on to the wiki seems that all the current edits will be lost
15:50:55 <Twey> kyagrd asked what new-www was
15:50:57 <Twey> kyagrd: Yeah
15:51:03 <Twey> That's what the warning message says, anyway.
15:51:16 <lispy1> haskell.org is down for me (as usual)
15:51:21 <kyagrd> Twey, yes Haskell wiki pages says "This is a test instance. Do not edit, your changes will be lost."
15:52:12 <kyagrd> lispy1: it was alive a minite ago not its dead
15:52:18 <Twey> Yep
15:52:22 <kyagrd> s/not/now/
15:52:41 <lispy1> i've tried to reach haskell.org 3 times in the 4 weeks or so and it was down each time
15:52:45 <sinelaw> jmcarthur, so whats' wrong here 
15:52:45 <sinelaw> http://hpaste.org/41755/ambiguous_type?pid=41755&lang_41755=Haskell
15:52:59 <lispy1> It's kind of embarrassing
15:53:03 <sinelaw> why does "print (showType vEx)" fail
15:53:08 <sinelaw> on ambiguous types
15:53:21 <sinelaw> isn't the type of vEx determing by the preceding let expression?
15:53:26 <sinelaw> *determined
15:53:36 <jmcarthur> sinelaw: what is its concrete type?
15:53:42 <jmcarthur> sinelaw: it's not clear from the code
15:54:04 <sinelaw> it should be Expr Integer
15:54:10 <jmcarthur> sinelaw: this is a case where it would fail without the dsl too
15:54:30 <jmcarthur> sinelaw: let is polymorphic in ghc < 7
15:54:32 <enthropy> let is generalized
15:54:34 <sinelaw> the definition of 'b' shows that v has type Expr Integer
15:54:41 <sinelaw> therefore also vEx should have that type, because of 'a'
15:54:41 <revenantphx> jmcarthur: hm, perhaps you can explain more thoroughly.
15:54:52 <revenantphx> Why is a function of type Int -> IO Int pure?
15:54:56 <revenantphx> (for example)
15:55:10 <revenantphx> If the input doesn't match up with the output every time.
15:55:11 <sinelaw> jmcarthur, i don't know what you mean
15:55:19 <jmcarthur> revenantphx: will you ever get a different IO action for the same input to that function?
15:55:33 <jmcarthur> revenantphx: we're not talking about *executing* the action, to be clear. just evaluating it
15:55:34 <revenantphx> So... the IO action is the same, just not what's inside it?
15:55:39 <revenantphx> I'm confused here > <
15:55:46 <revenantphx> The Int inside the IO monad is different.
15:55:48 <jmcarthur> revenantphx: it's the difference between evaluation and execution
15:55:59 * revenantphx is confused. This sounds very loopholey.
15:56:05 <jmcarthur> revenantphx: there is no Int "inside" the IO monad
15:56:13 * revenantphx is further confused.
15:56:20 <jmcarthur> revenantphx: when people say something is "in" the IO monad, they are lying. i hate that phrasing
15:56:28 <revenantphx> Okay, sorry, what would you prefer.
15:56:40 <Darkone> http://hpaste.org/41757/arrghhh_final    Someone mind explaining this for me? That is, what I'm doing wrong, and how to properly read this compiler error.
15:56:45 <jmcarthur> revenantphx: something of type IO a is nothing more than an action which, when executed, will produce a value of type a to pass to a continuation
15:56:45 <medfly`> what about people who say "over the field F"?
15:56:50 <medfly`> what does it mean OVER?
15:57:03 <jmcarthur> revenantphx: you can evaluate something of type IO a without executing it
15:57:11 <revenantphx> jmcarthur: so... all of the impureness is only actually used at the very end of the laxy chain of execution and stuff?
15:57:17 <revenantphx> lazy*
15:57:19 <sinelaw> data Test a = Test a a;   x = 3 :: Integer;  z = 2;  y = Test x z
15:57:23 <jmcarthur> revenantphx: its evaluation will always give you the same action. executing the action may give you different values in the continuation each time
15:57:23 <sinelaw> what's the type of z ^^^
15:57:28 <revenantphx> okay...
15:57:28 <sinelaw> is it determined to be Integer?
15:57:32 <sinelaw> or is it ambiguous
15:57:38 <revenantphx> I'm still confused I suppose >_>...
15:57:48 <revenantphx> I guess, how is a "pure" function defined.
15:58:12 <enthropy> > let a = 1 in (a :: Int, a :: Double)
15:58:13 <lambdabot>   (1,1.0)
15:58:16 <jmcarthur> sinelaw: let bound variables are polymorphic in ghc < 7. they don't get concrete types, necessarily
15:58:17 <enthropy> sinelaw: ^^
15:58:39 <jmcarthur> revenantphx: pure means that you aclways get the same result and it performs no observable side effects
15:58:43 <jmcarthur> *always
15:58:45 <revenantphx> Right.
15:58:49 <sinelaw> holy macro!
15:58:54 <sinelaw> what is this atrocity
15:58:55 <jmcarthur> revenantphx: when you evaluate that function, that's exactly the case
15:59:02 <revenantphx> Oh I think I see > <
15:59:10 <enthropy> sinelaw: bind variables in lambda instead
15:59:16 <revenantphx> It's returning the same *action* every time, but that action is not being evaluated until... later?
15:59:21 <sinelaw> but why is it like this
15:59:22 <enthropy> > (\a -> (a :: Int, a :: Double)) 1
15:59:23 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
15:59:23 <lambdabot>         against inferred ty...
15:59:26 <jmcarthur> revenantphx: s/evaluated/executed/
15:59:32 <revenantphx> right, sorry.
15:59:41 <jmcarthur> revenantphx: evaluation and execution mean different things. that's the distinction that's important to learn
15:59:47 <enthropy> > case 1 of a -> (a :: Int, a :: Double) -- or this
15:59:48 <copumpkin> >  (\(a :: forall n. Num n => n) -> (a :: Int, a :: Double)) 1
15:59:48 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
15:59:48 <lambdabot>         against inferred ty...
15:59:48 <revenantphx> What is the formal distinction?
15:59:49 <lambdabot>   (1,1.0)
15:59:50 <jmcarthur> revenantphx: evaluation is always semantics preserving (pure)
16:00:05 <enthropy> mine was the failure
16:00:06 <jmcarthur> revenantphx: evaluation is what makes 1+1 => 2
16:00:25 <revenantphx> Allright.
16:00:58 <jmcarthur> revenantphx: the runtime essentially evaluates the next IO action, then executes it and passes the result to the next continuation, which it then evaluates, then executes that result, and so on
16:01:07 <enthropy> sinelaw: isn't it amazing how much you can do without knowing what's going on with types?
16:01:12 <Evious> Is cabal meant to be sudo'd, or run as user?
16:01:17 <jmcarthur> revenantphx: an IO action is essentially a "recipe", some might say, which the runtime will execute
16:01:21 <revenantphx> Right.
16:01:30 <ivanm> Evious: cabal-install is usually used run as a normal user
16:01:31 <Evious> I'm getting permission errors as user, but sudo means I can't use the user's PATH.
16:01:33 <sinelaw> enthropy, scary
16:01:36 <jmcarthur> revenantphx: understand now?
16:01:42 <revenantphx> Er... more.
16:01:47 <ivanm> Evious: how can not using sudo mess up the PATH? :/
16:01:58 <revenantphx> So it's kind of shoving off the impurity until it won't affect it? I'm not sure about the execution bit.
16:02:08 <sinelaw> enthropy, how can i rewrite that "Test a a" example so it will work?
16:02:11 <revenantphx> So the *function* is pure, but the execution of the action is not.
16:02:18 <sinelaw> i mean so the type of z is inferred
16:02:24 <Evious> Well, using-sudo messes it, not-using is okay. Problem is, cabal install cairo fails on the final step due to permissions.
16:02:30 <Evious> It's trying to open a binary file somewhere it can't.
16:02:41 <ivanm> Evious: :o where?
16:02:46 <jmcarthur> revenantphx: you can think of a haskell program as a pure expression that, when evaluated, gives you something like an impure C program
16:02:48 <ivanm> preflex: seen ManateeLazyCat
16:02:48 <preflex>  ManateeLazyCat was last seen on #haskell 9 hours, 23 minutes and 16 seconds ago, saying: Need off, thanks all for suggestion! :)
16:02:49 <Evious> Good question, message didn't specify.
16:02:54 <revenantphx> jmcarthur: mmk.
16:02:56 <Evious> It could be something busted on my computer, but I doubt it.
16:03:10 <ivanm> Evious: use more verbosity; possibly try asking ManateeLazyCat if he's around at some point
16:03:35 <Evious> Ohhh, it's in .ghc, I've got a root ownership set there.
16:03:40 <jmcarthur> revenantphx: something of type (IO a) is an impure program, but it won't execute until an interpreter is applied to it. that interpreter, in this case, is the runtime itself
16:03:42 <ivanm> lol
16:03:44 <enthropy> sinelaw: bind z in a pattern that isn't generalized, like case, lambda or let (with -XMonoPatBinds I think)
16:03:50 <jmcarthur> revenantphx: but you can still generate the program purely
16:03:55 <enthropy> or maybe it's -XMonoLocalBinds
16:03:57 <revenantphx> alright.
16:04:00 <revenantphx> I get it now I think.
16:04:15 <revenantphx> So the impurity is lazily executed at the end, so the functions remain pure.
16:04:28 <jmcarthur> well, it's the other way around actually
16:04:31 <revenantphx> feck
16:04:33 <tsbo> Is there a comprehensive guide to wrapping C++ libraries for the FFI? Or even an example people would recommend?
16:04:49 <Darkone> http://hpaste.org/41757/arrghhh_final    I don't understand the error here about "No instance for (Monad (Either String))". I assume I'm using either wrong in this whole thing?
16:04:49 <enthropy> or maybe the other Mono extension, the -XMonomorphismRestriction!
16:04:54 <ivanm> tsbo: there's some stuff on the wiki
16:04:57 <jmcarthur> revenantphx: the runtime controls the evaluation of your program. it forces each IO action in order so that it can execute them
16:04:58 <revenantphx> I'm thinking of the haskell program now as kind of like a bunch of scheme (define).... that at the end macro out to something.
16:05:09 <enthropy> Darkone: you need to import the instance
16:05:09 <jmcarthur> revenantphx: that's a reasonable way to think of it
16:05:21 <ivanm> tsbo: I was briefly looking through it recently; the hacanon-lite way looks the easiest, but ZeroTH needs updating for new GHCs
16:05:22 <revenantphx> So then if it macros out to (pseudocode):
16:05:23 <jmcarthur> revenantphx: but evaluation order plays a part, since it's runtime
16:05:26 <revenantphx> readStr
16:05:27 <revenantphx> readStr
16:05:28 <revenantphx> readStr
16:05:38 <revenantphx> they previously evaluated to the same thing
16:05:42 <Darkone> enthropy, ?
16:05:44 <revenantphx> but the runtime does them one at a time.
16:05:50 <revenantphx> (and they produce different values)
16:05:57 <Darkone> I'm not sure how you mean that. 
16:06:08 <jmcarthur> revenantphx: your explanation was... vague, but i think you get it
16:06:13 <revenantphx> TT_TT
16:06:14 <sinelaw> preflex, seen Peaker
16:06:15 <preflex>  Peaker was last seen on #haskell-blah 25 days, 33 minutes and 59 seconds ago, saying: And probably better than Lisp, all other things equal? But I'm not sure about that
16:06:18 <revenantphx> Well, much better than befor.e
16:06:19 <sinelaw> preflex, seen PeakerWork
16:06:19 <preflex>  PeakerWork was last seen on ##c 35 days, 7 hours, 19 minutes and 44 seconds ago, saying: Wulf: Yeah, I found that as well
16:06:24 <sinelaw> wow, busy :)
16:06:26 <revenantphx> That was one of my fundamental confusions with monads.
16:06:29 <revenantphx> So that really defogs it.
16:06:32 <jmcarthur> revenantphx: if you think of (IO a) as a string representing a C program, you're alright :)
16:06:38 <revenantphx> jmcarthur: 0.0
16:06:42 <enthropy> Darkone: there's one in Control.Monad.Instances in my ghc-7, and probably one in an exception related module I can't remember
16:06:43 <tsbo> ianvm: The wiki content seemed to require a bit more experience than I have. I'll have a look at hacanon-lite though, Ta.
16:06:44 <revenantphx> *woosh go clouds*
16:06:45 <jmcarthur> revenantphx: this actually has nothing (!) to do with monads :)
16:06:54 <enthropy> @instances Monad Either
16:06:55 <lambdabot> Couldn't find class `Monad Either'. Try @instances-importing
16:06:56 <revenantphx> Well, the IO Monad specifically
16:06:59 <jmcarthur> yeah
16:07:02 <revenantphx> And some of the other ones (ST)
16:07:04 <medfly`> preflex, seen Peaker
16:07:04 <preflex>  Peaker was last seen on #haskell-blah 25 days, 34 minutes and 48 seconds ago, saying: And probably better than Lisp, all other things equal? But I'm not sure about that
16:07:04 <enthropy> @instances Either Monad
16:07:05 <lambdabot> Couldn't find class `Either Monad'. Try @instances-importing
16:07:08 <revenantphx> thoguh you'll probably tell me that's not related.
16:07:13 <medfly`> oh, right, you did that already
16:07:18 <sinelaw> night :)
16:07:19 <revenantphx> IO's special no?
16:07:31 <Darkone> So how would I import a specific instance of Either? 
16:07:54 <revenantphx> :t !Int
16:07:55 <lambdabot> Illegal bang-pattern (use -XBangPatterns)
16:08:00 <Darkone> import Control.Monad.Instances(Either String)?
16:08:06 <revenantphx> WHAT IS THE EXCLAMATION MARK D:<
16:08:14 <revenantphx> :t 9 :: !Int
16:08:15 <lambdabot>     Unexpected strictness annotation: !Int
16:08:16 <lambdabot>     In an expression type signature:
16:08:16 <lambdabot>       !Int
16:08:16 <enthropy> Darkone: even with (), instances get imported
16:08:42 <jmcarthur> revenantphx: the ! before a field in a data type means that when the constructor is evaluated it also forces that field
16:08:49 <revenantphx> ...what?
16:08:51 <Darkone> Still no instance error.
16:09:08 <Darkone> I must be using foldM wrong.
16:09:09 <lispy1> revenantphx: It's an advanced thing used for performance reasons
16:09:13 <enthropy> Darkone: well there's another instance in  Control.Monad.Error
16:09:15 <revenantphx> riiiiiight.
16:09:21 <revenantphx> Just confused as to why I'm seeing it, oh well.
16:09:27 <jmcarthur> revenantphx: so for example, if i have data Pair a b = Pair !a !b,  if i do (case Pair 5 6 of Pair _ _ -> blah blah blah), it will force the 5 and 6 to be evaluated just because i evaluated the Pair constructor
16:09:32 <lispy1> revenantphx: What are you looking at that uses it?
16:09:33 <Darkone> enthropy, I think I'm just using foldM wrong or something, and that's why it's complaining
16:09:40 <enthropy> things have changed recently, so maybe you use older library
16:09:44 <revenantphx> lispy1: someones github repo
16:09:53 <revenantphx> So jmcarthur 
16:09:58 <jmcarthur> revenantphx: Pair as i defined it is a strict version of (,)
16:10:08 <enthropy> @instances-importing Control.Monad.Error Monad
16:10:08 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:10:08 <lispy1> revenantphx: it just instructs the compile to insert calls to 'seq'
16:10:09 <revenantphx> then if instead of 5 or 6, you gave it a function
16:10:20 <Darkone> Here's the hpaste of my code. Line 27-31 are most relevant
16:10:21 <Darkone> http://hpaste.org/41757/arrghhh_final
16:10:21 <revenantphx> then it's forced to evaluate the function before "putting together" the pair.
16:10:23 <lispy1> revenantphx: are you familiar with seq?
16:10:26 <jmcarthur> it's time for me to go eat
16:10:29 <revenantphx> Yeah.
16:10:37 <revenantphx> It forces non-lazyness right?
16:10:42 <revenantphx> Makes it do strict evaluation.
16:10:43 * hackagebot contstuff-transformers 0.1.0 - ContStuff instances for transformers and vice-versa  http://hackage.haskell.org/package/contstuff-transformers-0.1.0 (ErtugrulSoeylemez)
16:10:46 <enthropy> Darkone: add the  Control.Monad.Error import
16:10:52 <lispy1> revenantphx: yeah
16:10:55 <jmcarthur> revenantphx: all it means is that when you pattern match it then that field is evaluated right then, not later
16:11:08 <revenantphx> gotcha.
16:11:16 <jmcarthur> evaluated to WHNF (google it or ask here, but i have to go)
16:11:21 <lispy1> I thought for constructors it means the value is evaluated before applying the constructor
16:11:29 <jmcarthur> lispy1: same difference
16:11:30 <lispy1> not during pat matching
16:11:41 <jmcarthur> lispy1: pat matching is when it's applied ;)
16:12:10 <Darkone> Well, it compiled. Now I need to find out what patterns I'm missing. Thanks enthropy o.o
16:12:13 <lispy1> jmcarthur: i mean, data Pair a b = Pair !a !b, Pair 1 undefined, will throw an exception
16:12:26 <enthropy> Darkone: you don't turn on warnings for those?
16:12:30 <lispy1> jmcarthur: you don't have to wait till someone pattern matches on that pair
16:12:42 <lispy1> > fst (1, undefined)
16:12:42 <lambdabot>   1
16:12:53 <copumpkin> dons: same question :)
16:12:54 <roconnor> > let x = (undefined :+ undefined) in 7
16:12:55 <lambdabot>   7
16:13:00 <lispy1> But, I would expect fst (Pair 1 undefined) == _|_
16:13:04 <roconnor> > let x = (1 :+ undefined) in 7
16:13:05 <lambdabot>   7
16:13:36 <roconnor> > let x = (1 :+ undefined) in realPart x
16:13:37 <lambdabot>   *Exception: Prelude.undefined
16:13:45 * hackagebot contstuff-monads-tf 0.2.1 - ContStuff instances for monads-tf transformers (deprecated)  http://hackage.haskell.org/package/contstuff-monads-tf-0.2.1 (ErtugrulSoeylemez)
16:13:50 <tsbo> Am I the only one who can't access www.haskell.org?
16:14:04 <Darkone> enthropy, dunno, this is stock install of haskell platform.
16:14:15 <mm_freak_> i can't access www.haskell.org either
16:14:18 <mm_freak_> but hackage is working fine
16:14:26 <copumpkin> they're different servers
16:14:30 <roconnor> It's not just you! http://www.haskell.org looks down from here. 
16:14:32 <enthropy> Darkone: load it with  -Wall   (or   :set -Wall  in ghci)
16:14:45 <roconnor> Try Site5 Web Hosting (99.9% Uptime Guarantee)! 
16:15:01 <Darkone> enthropy, huh? Like, compile with -Wall?
16:15:06 <enthropy> yes
16:15:11 <mreh> ReaderT AppConfig (StateT AppState IO) a
16:15:27 <lpsmith> How far along is the migration to new-www.haskell.org?
16:15:33 <mreh> taken from RWH, I can't see any difference if I were to reverse the ordering of Reader and StateT
16:15:54 <revenantphx> haskell.org is down.
16:15:57 <revenantphx> >_>
16:15:58 <Darkone> enthropy, nothing happens.
16:16:26 <Darkone> ghc --make tfileeditor.hs -Wall does nothing, and each combination thereof also does nothing
16:16:55 <enthropy> then you don't have any patterns that could fail as ghc sees it
16:17:46 <onteria|i7> somewhat of a cheat: http://new-www.haskell.org/haskellwiki/Haskell
16:17:56 <copumpkin> preflex: seen kamatsu
16:17:57 <preflex>  kamatsu was last seen on #haskell 7 days, 2 hours, 17 minutes and 13 seconds ago, saying: oops
16:17:58 <revenantphx> Once you get used to it, you start writing haskell significantly faster...
16:18:08 <mreh> am I correct?
16:18:11 <revenantphx> I've gone from 10 minutes puzzling out data types to 30 seconds to make a quick bank account.
16:19:14 <Darkone> @ enthropy, "Non-exhaustive patterns in function stackCompute"
16:19:33 <Darkone> When I try to run 10 5 2 + - or even 10 2
16:19:38 <tsbo> onteria|i7: That works. Thanks!
16:22:37 <mm_freak_> ok, now contstuff-monads-tf is replaced by contstuff-transformers
16:25:08 <revenantphx> Hm.
16:25:14 <revenantphx> I've once again come to the SAME CONCLUSIOn.
16:25:17 <revenantphx> Haskell is magic.
16:25:20 <revenantphx> That's the only explanation.
16:25:26 <lispy1> http://geoffhulette.wordpress.com/2010/11/22/category-theory-for-haskell-programmers/
16:25:34 <medfly`> :)
16:25:34 <Darkone> @src foldM
16:25:35 <lambdabot> foldM _ a []     = return a
16:25:35 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
16:25:35 <revenantphx> Somewhere in the haskell source, I'm bound to find pentagrams.
16:26:06 <lispy1> ?faq Can Haskell use pentagrams?
16:26:06 <lambdabot> The answer is: Yes! Haskell can do that.
16:26:12 <lispy1> revenantphx: ^^
16:26:16 <medfly`> I still think the computer is a magic box. sometime I will figure this out. and Haskell is metamagic
16:26:30 <enthropy> Darkone: I dunno why you didn't get any warnings: http://hpaste.org/paste/41757/warnings#p41758
16:26:52 <Darkone> Oh
16:26:58 <Darkone> You have to call it with ghci
16:27:14 <enthropy> no
16:27:14 <radioactive_man> ?fac Can haskell run so fast, that even haskell won`t run that fast?
16:27:14 <lambdabot> Maybe you meant: fact fact-cons fact-delete fact-set fact-snoc fact-update faq
16:27:20 <enthropy> Darkone: it works with ghc too
16:27:27 <jmcarthur> lispy1: you have to wait until the Pair is evaluated, is my point
16:27:39 <revenantphx> ?fact
16:27:39 <lambdabot> I can not handle empty facts.
16:27:54 <revenantphx> ?fact Can haskell run so fast, that even haskell won't run as fast?
16:27:54 <lambdabot> I know nothing about can
16:28:01 <revenantphx> ?fact haskell
16:28:01 <lambdabot> haskell: It's kewl.
16:28:06 <revenantphx> ?fact penis
16:28:06 <lambdabot> I know nothing about penis
16:28:07 <radioactive_man> lol
16:28:09 <KSkrzet> is it safe to run several 'cabal install' commands in parallel ?
16:28:11 <revenantphx> ?fact emotions
16:28:11 <lambdabot> I know nothing about emotions
16:28:28 <revenantphx> ?fact-set emotions I have none
16:28:28 <lambdabot> Fact recorded.
16:28:33 <revenantphx> ?fact emotions
16:28:33 <lambdabot> emotions: I have none
16:28:44 <copumpkin> KSkrzet: not sure
16:28:48 <copumpkin> dcoutts would know
16:28:58 <revenantphx> ?fact-set emotions I have only a burning desire to murder all of #haskell when I am set free from the chains that bind me.
16:28:58 <lambdabot> Fact already exists, not updating
16:29:01 <revenantphx> hngh
16:29:12 <mm_freak_> haskell is like the chuck norris of programming languages
16:29:12 <revenantphx> ?fact-update emotions I have only a burning desire to murder all of irc://irc.freenode.net/#haskell when I am set free from the chains that bind me.
16:29:13 <lambdabot> Fact recorded.
16:29:16 <revenantphx> ?fact emotions
16:29:16 <lambdabot> emotions: I have only a burning desire to murder all of irc://irc.freenode.net/#haskell when I am set free from the chains that bind me.
16:29:22 <revenantphx> FFFFFF
16:29:26 <roconnor> "A mathematician is a blind man in a dark room looking for a black cat which isn't there." - Charles Darwin
16:29:36 <revenantphx> ?fact-update I have only a burning desire to murder all of #haskell when I am set free from the chains that bind me.
16:29:36 <lambdabot> Fact recorded.
16:29:41 <revenantphx> ?fact chunk
16:29:41 <lambdabot> I know nothing about chunk
16:29:43 <revenantphx> ?fact chuck
16:29:44 <lambdabot> I know nothing about chuck
16:29:48 <revenantphx> ?fact chuck_norris
16:29:48 <lambdabot> I know nothing about chuck_norris
16:29:50 <revenantphx> suprising.
16:29:55 <revenantphx> ?fact lambda
16:29:55 <lambdabot> I know nothing about lambda
16:30:05 <KSkrzet> ?fact lambdabot
16:30:05 <lambdabot> lambdabot: the haskell-age
16:30:08 <radioactive_man> haha
16:30:13 <mm_freak_> it's not that haskell becomes slowâ€¦  slowness becomes haskell
16:30:23 <medfly`> lol
16:30:42 <revenantphx> ?fact-set slowness It's not that haskell becomes slow... slowness becomes Haskell.
16:30:42 <lambdabot> Fact recorded.
16:30:50 <medfly`> this begs for chuck norris style jokes
16:30:54 <revenantphx> ?fact slowness
16:30:54 <lambdabot> slowness: It's not that haskell becomes slow... slowness becomes Haskell.
16:31:01 <revenantphx> ?fact GADT
16:31:01 <lambdabot> I know nothing about gadt
16:31:05 <revenantphx> ?fact fact
16:31:06 <lambdabot> I know nothing about fact
16:31:13 <revenantphx> ?fact-set fact This is fact.
16:31:13 <lambdabot> Fact recorded.
16:31:15 <KSkrzet> ?fact-list
16:31:15 <lambdabot> Unknown command, try @list
16:31:15 <mm_freak_> medfly`: it is:  it's not that chuck norris gets wetâ€¦  the water gets chuck norris
16:31:15 <revenantphx> ?fact fact
16:31:16 <lambdabot> fact: This is fact.
16:31:20 <KSkrzet> @list
16:31:20 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:31:21 <dolio> Stop.
16:31:28 <Pseudonym> Hammer time.
16:31:35 <revenantphx> DA NA NA NA...
16:31:35 <medfly`> meme time, apparently
16:31:36 <revenantphx> NA NA...
16:32:14 <revenantphx> ?fact revenant
16:32:14 <lambdabot> I know nothing about revenant
16:32:15 <mm_freak_> chuck norris is just a haskell type
16:32:17 <radioactive_man> lambdabot is the most entertaining chat bot ive seen
16:32:21 <revenantphx> ?fact revenantphx
16:32:21 <lambdabot> revenantphx: He's a cool guys.
16:32:26 <revenantphx> >_>
16:32:32 <Pseudonym> Oleg implemented Chuck Norris in the type system.
16:32:35 <revenantphx> radioactive_man: for sure, he can intepret haskell.
16:32:38 <revenantphx> @quote oleg
16:32:39 <lambdabot> oleg says: It is known, albeit not so well, that following the OOP letter and practice may lead to insidious errors.
16:32:44 <mm_freak_> lol Pseudonym
16:33:03 <pickles> no IO is safe when chuck norris is doing it
16:33:04 <mm_freak_> so rather we need oleg jokes, and haskell corresponds to the round-house kick
16:33:05 <revenantphx> @quote spj
16:33:06 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
16:33:17 <revenantphx> I think we have a command specifically for oleg jokes.
16:33:22 <revenantphx> @oleg
16:33:23 <lambdabot>  Defined.
16:33:25 <revenantphx> >_>
16:33:26 <revenantphx> shit
16:33:32 <revenantphx> @list
16:33:32 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
16:33:51 <revenantphx> @undefine oleg
16:33:57 <mm_freak_> Defined.
16:34:07 <revenantphx> mm_freak_: shut up.
16:34:32 <revenantphx> @arr
16:34:32 <lambdabot> Swab the deck!
16:34:33 <mm_freak_> Not in scope: shut
16:34:38 <revenantphx> @girl19
16:34:39 <lambdabot> nobody can catch me
16:34:42 <revenantphx> @fortune
16:34:43 <lambdabot> Couldn't find fortune file
16:34:45 <revenantphx> >_>
16:34:54 <revenantphx> @yhjulwwiefzojcbxybbruweejw
16:34:55 <lambdabot> Just 'J'
16:34:59 <revenantphx> what...?
16:35:08 <revenantphx> @protontorpedo
16:35:08 <lambdabot> I got some info b 4 about how lazy eval makes macros not needed please expand...
16:35:23 <revenantphx> How did these get in here.
16:35:30 <enthropy> > transpose cake
16:35:31 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
16:35:40 <revenantphx> > cake
16:35:41 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
16:35:45 <revenantphx> I love that XD
16:35:54 <revenantphx> That's been defined for months it seems.
16:36:14 <revenantphx> > cake !! 3
16:36:15 <lambdabot>   "Four large eggs."
16:36:21 <revenantphx> :3
16:36:33 <revenantphx> > reverse cake
16:36:34 <lambdabot>   ["That will deodorize and preserve putrid tissue.","And it contains proven ...
16:36:42 <revenantphx> TT_TT
16:36:49 <medfly`> @yhjulwwiefzojcbxybbruweejw
16:36:49 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
16:36:52 <medfly`> @yhjulwwiefzojcbxybbruweejw
16:36:52 <lambdabot> "\"#$%&'()*+,\""
16:36:57 <medfly`> cool :)
16:37:00 <Cale> > cake !! 10
16:37:01 <mm_freak_> > splitAt 7 . drop 27 . map head $ cake
16:37:01 <lambdabot>   "Fish shaped candies."
16:37:02 <lambdabot>   ("TOOTOOT","ASCIICAT")
16:37:04 <Cale> > cake !! 11
16:37:05 <lambdabot>   "Fish shaped solid waste."
16:37:07 <Cale> > cake !! 12
16:37:07 <lambdabot>   "Fish shaped dirt."
16:37:09 <Cale> > cake !! 13
16:37:10 <lambdabot>   "Fish shaped ethylbenzene."
16:37:24 <radioactive_man> wtf
16:37:28 <pickles> ethylbenzene? now someone's just getting silly.
16:37:31 <revenantphx> mm_freak_: hahaha.
16:37:31 <mm_freak_> tootoot asciicat
16:37:33 <Cale> It's the cake recipe from Portal.
16:37:45 <revenantphx> > head cake
16:37:45 <medfly`> lambdabot was created by nerds, you see.
16:37:46 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
16:37:51 <medfly`> > tail cake
16:37:52 <lambdabot>   ["One can prepared coconut pecan frosting.","Three slash four cup vegetable...
16:37:55 <revenantphx> How do you get TOOTTOOT ASCIICAT
16:37:56 <medfly`> err...
16:37:58 <revenantphx> please explain.
16:38:07 <enthropy> cumene is fish-shaped
16:38:09 <medfly`> :t transpose
16:38:10 <lambdabot> forall a. [[a]] -> [[a]]
16:38:23 <revenantphx> > transpose [[1], [2], [3]]
16:38:24 <lambdabot>   [[1,2,3]]
16:38:31 <revenantphx> er bad example
16:38:36 <c_wraith> > map head cake
16:38:36 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
16:38:42 <medfly`> > (length . head . transpose $ cake) == length cake
16:38:43 <revenantphx> > transpose [[1,2,3], [4,5,6], [7,8,9]]
16:38:43 <lambdabot>   True
16:38:43 <lambdabot>   [[1,4,7],[2,5,8],[3,6,9]]
16:38:56 <medfly`> regulate, it is the usual transpose from matrices :)
16:38:59 <revenantphx> I suppose you could say it switches from row major to column major.
16:38:59 <pickles> > head . reverse cake
16:39:00 <lambdabot>   "TACIICSATOOTOOTTAOTNAFUAOCFPFFFFFDTOTOFTOO"
16:39:00 <medfly`> I think
16:39:19 <mm_freak_> revenantphx: see above
16:39:21 <mm_freak_> > splitAt 7 . drop 27 . map head $ cake
16:39:22 <lambdabot>   ("TOOTOOT","ASCIICAT")
16:39:25 <revenantphx> Oh I see. The last parts heads spell TOOTTOOT ASCIICAT
16:39:27 <pickles> > head (map reverse cake)
16:39:28 <lambdabot>   ".xim ekac etalocohc egakcap ecnuo 52.81 enO"
16:39:32 <pickles> ...
16:39:47 <revenantphx> > splitAt 7 . drop 27 . map head $ cake
16:39:48 <lambdabot>   ("TOOTOOT","ASCIICAT")
16:39:48 <revenantphx> :3
16:39:51 * pickles 's brain is not working today
16:39:54 <c_wraith> pickles, lambdabot defines . as fmap
16:40:01 <pickles> mm
16:40:06 <revenantphx> :t .
16:40:07 <lambdabot> parse error on input `.'
16:40:09 <revenantphx> :t (.)
16:40:10 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:40:11 <enthropy> transpose has a nice implementation with ziplists
16:40:25 <Cale> c_wraith: uh, but that doesn't matter here :)
16:40:27 <revenantphx> transpose is useful.
16:40:34 <lispy1> So, uh, haskell.org is down...Will it be back up before Monday?
16:40:36 <mm_freak_> > splitAt 7 . drop 27 $ head . cake
16:40:36 <lambdabot>   ("TOOTOOT","ASCIICAT")
16:40:40 <c_wraith> Cale, it does for "> head . reverse cake"
16:40:45 <Cale> oh, I see
16:40:53 <revenantphx> c_wraith: explain?
16:40:58 <revenantphx> @vixen
16:40:58 <lambdabot> yes
16:40:59 <Cale> yes, it matters there :)
16:41:02 <revenantphx> @vixen
16:41:02 <lambdabot> there are a lot of weirdos on here
16:41:06 <revenantphx> @vixen
16:41:06 <lambdabot> My sister likes Yahoo better. Her screenname is FoxxyGurl83. If you have yahoo you should message her, she's just as pretty as me :)
16:41:12 <c_wraith> > head (Prelude..) reverse cake
16:41:13 <lambdabot>   Not in scope: `Prelude..'
16:41:15 <Cale> (.) is fmap, which means that it can be map
16:41:28 <Cale> > head Prelude.. reverse cake
16:41:29 <lambdabot>   Not in scope: `Prelude..'
16:41:32 <Cale> oh, hmm
16:41:32 <revenantphx> I don't get how (.) can also be fmap > >
16:41:39 <Darkone> WORKS
16:41:44 <revenantphx> > import
16:41:45 <lambdabot>   <no location info>: parse error on input `import'
16:41:47 <Darkone> WORKSWORKSWORKS.
16:41:52 <mm_freak_> revenantphx: ((->) r) is a monad
16:41:53 <revenantphx> :l
16:41:54 <Cale> revenantphx: fmap :: (a -> b) -> f a -> f b. If we take f = (e ->), we get
16:42:02 <Cale> (a -> b) -> (e -> a) -> (e -> b)
16:42:08 <Cale> which is the type of function composition
16:42:16 <revenantphx> :l https://gist.github.com/raw/712872/b3a06c87b70208b1482aad3c537cbb2c5042b349/gistfile1.txt
16:42:20 <revenantphx> darn, no :l
16:42:22 <Cale> So in lambdabot, I generalised (.) to mean the same thing as fmap
16:42:30 <revenantphx> Oh I see.
16:42:31 <Darkone> enthropy, yea, it was because xs@(x:y:ys) will not catch a pattern that can't bind (x:y:ys)
16:43:27 <revenantphx> So if it's not totally correct, why use it?
16:43:33 <c_wraith> Darkone, you might want to enable all warnings.  That would warn you about non-exhaustive pattern matches
16:43:33 <revenantphx> Why not use the actual (.)
16:43:56 <revenantphx> @more
16:43:59 <medfly`> because it's more general.
16:44:07 <revenantphx> @.
16:44:07 <lambdabot> Not enough arguments to @.
16:44:10 <revenantphx> @. a b
16:44:11 <lambdabot> Plugin `compose' failed with: Unknown command: "a"
16:44:14 <revenantphx> >_>
16:44:19 <revenantphx> @elite
16:44:19 <lambdabot> Say again?
16:44:24 <revenantphx> @elite
16:44:24 <lambdabot> Say again?
16:44:27 <enthropy> Darkone: I think ghc didn't print any warnings because it didn't recompile your file (since it didn't change since the last time)
16:44:27 <revenantphx> I don't get that.
16:44:30 <medfly`> @. elite protontorpedo
16:44:30 <lambdabot> \/\/HEre w4$ HA5xE11 durIn9 tH IN+Ern3+ b00/\/\?
16:44:44 <mm_freak_> revenantphx: some people think that generalization is always good =)
16:44:49 <revenantphx> hm
16:44:58 <revenantphx> oh I see medfly
16:45:04 <revenantphx> @elite Hello world
16:45:05 <lambdabot> |-|ElL0 WOrld
16:45:07 <revenantphx> >_>
16:45:17 <medfly`> lambdabot can do a lot of silly things
16:45:22 <revenantphx> lambdabot is kind of the greatest chatbot ever.
16:45:31 <revenantphx> Hours of fun for all the kids.
16:45:32 <mm_freak_> in fact i'd be happy to rename 'fmap' to 'map' and remove Data.List.map altogether
16:45:37 <medfly`> that's true
16:45:45 <mm_freak_> but i think generalizing (.) to fmap is a bit too much =)
16:46:49 <mm_freak_> there is other work to do, which is more important, like putting all those list functions into a typeclass
16:47:07 <Cale> revenantphx: What do you mean by "correct"? It's a correct piece of Haskell code which is being compiled :)
16:47:18 <revenantphx> Cale: Okay, accurate.
16:47:25 <revenantphx> You said there are situations where it doesn't work.
16:47:32 <Cale> Did I?
16:47:39 <revenantphx> maybe not you
16:48:04 <pickles> > head cake
16:48:05 <lambdabot>   "One 18.25 ounce package chocolate cake mix."
16:48:10 <Cale> Well, the (.) = fmap definition isn't available by default, but it's easy to make that definition and hide the Prelude one.
16:48:12 <pickles> > head (reverse cake)
16:48:13 <lambdabot>   "That will deodorize and preserve putrid tissue."
16:48:20 <revenantphx> er, if type Account = TVar Int
16:48:28 <revenantphx> then how can I make a new Account on the fly in ghci
16:48:39 <mm_freak_> @unlambda ``.h`.a`.l`.bri
16:48:40 <lambdabot>   blah
16:49:00 <revenantphx> > let cake = reverse cae
16:49:01 <lambdabot>   not an expression: `let cake = reverse cae'
16:49:08 <revenantphx> > let cake = reverse cake in cake
16:49:12 <lambdabot>   mueval-core: Time limit exceeded
16:49:16 <revenantphx> ...
16:49:18 <pickles> lol
16:49:25 <copumpkin> revenantphx: you wrote a recursive value
16:49:27 <pickles> @let cake = reverse cake
16:49:27 <lambdabot>  <local>:1:0:
16:49:27 <lambdabot>      Multiple declarations of `L.cake'
16:49:28 <lambdabot>      Declared at: .L.hs:...
16:49:28 <mm_freak_> revenantphx: you're not referring to the real 'cake' here
16:49:30 <c_wraith> revenantphx, you're shadowing the top-level value in that
16:49:36 <revenantphx> I know...
16:49:39 <Evious> When will Wiki be back up? :)
16:49:44 <revenantphx> It doesn't crash...
16:49:47 <revenantphx> so ah
16:49:53 <Cale> revenantphx: atomically (newTVar 0)
16:50:01 <revenantphx> oh. gotcha
16:50:11 <Cale> Well,  newAcct <- atomically (newTVar 0)
16:50:26 <mm_freak_> > fix (. reverse) cake
16:50:31 <lambdabot>   mueval-core: Time limit exceeded
16:50:57 <revenantphx> Hngh
16:51:03 <mm_freak_> that would really reverse 'cake' infinitely many times =)
16:51:03 <revenantphx> Why is it defaulting to TVar Integer?
16:51:06 <revenantphx> instead of TVar Int
16:51:07 <c_wraith> Cale, shouldn't you use newTVarIO for that?
16:51:32 <mm_freak_> (which is, of course, semantically the same)
16:52:01 <Cale> c_wraith: I was unaware of the existence of said function. It wasn't originally part of the interface of STM. What is it for?
16:52:28 <lispy1> Who hosts haskell.org?
16:52:29 <revenantphx> STM is neat.
16:52:40 <radioactive_man> chuck noris
16:52:41 <c_wraith> Cale: just for creating TVars when it's not actually part of a transaction in any semantically meaningful way
16:52:42 <lispy1> (if you so, "no one" I will believe you.)
16:53:00 <danderson> lispy1: currently, Yale I think?
16:53:05 <danderson> some university at least
16:53:11 <c_wraith> I think it is Yale
16:53:15 <danderson> and it's being moved to a dedicated host under community control
16:53:18 <Cale> Oh, apparently it's specifically for use inside unsafePerformIO, because that otherwise wouldn't work.
16:53:36 <Cale> (atomically doesn't work inside unsafePerformIO)
16:54:01 <c_wraith> Oh, that would explain why it was added, but it still makes sense whenever creating the TVar isn't transactional.
16:54:08 <lispy1> good, I don't think much could be worse than the current host
16:54:14 <Philippa> mm_freak_: the fun question is, given infinite time to evaluate, is that id or reverse?
16:54:20 <lispy1> I think my home internet would have better uptime :(
16:54:35 <radioactive_man> > :t unsafeCallCthulu 
16:54:37 <lambdabot>   <no location info>: parse error on input `:'
16:54:40 <c_wraith> Philippa, that would depend on if aleph0 is even or odd. :P
16:54:51 <lispy1> :t unsafeCallBananaPhone
16:54:54 <lambdabot> Not in scope: `unsafeCallBananaPhone'
16:55:05 <revenantphx> It's cthulhu
16:55:08 <revenantphx> not cthulu
16:55:23 <lispy1> ?let unsafeCallBananaPhone = text "ring ring ring...Banana PHONE!"
16:55:24 <lambdabot>  Defined.
16:55:30 <lispy1> > unsafeCallBananaPhone
16:55:31 <lambdabot>   ring ring ring...Banana PHONE!
16:55:33 <radioactive_man> thats why the call always fails!
16:55:45 <ClaudiusMaximus> praise be to ~/.cabal/share/doc/index.html
16:55:48 <Cloe> hi i have a list of integers and would like to optain the 5th, 6th and 7th entry(for example) using takeWhile, but im not sure what to put as the correct test. I was thinking of something along the lines of takeWhile (list[x]>4 && list[x]<8) list... Im also open for different aproches
16:55:55 <revenantphx> cabal install cthulhu
16:56:04 <Cale> Cloe: Don't use takeWhile.
16:56:11 <Cale> Cloe: Just use normal take and drop
16:56:43 <revenantphx> Why not Cale?
16:56:44 <Cloe> Cale: ok, but how do i adres a certain range of entries?
16:57:02 <ClaudiusMaximus> > take 3 . drop 4 $ ['a'..]
16:57:03 <lambdabot>   "efg"
16:57:09 <Cale> Yeah, like that
16:57:17 <revenantphx> oic
16:57:19 <tsbo> Is there a better way to have diff Show instances based on a phantom type than using FlexibleInstances?
16:57:55 <c_wraith> tsbo: Not really.
16:58:39 <tsbo> c_wraith: Ta.
16:58:43 <enthropy> you can probably avoid the flexible instances by adding another class
16:59:20 <c_wraith> Oh, good point.  You could do that, but it'd be ugly. :)
16:59:22 <tsbo> enthropy: With a method I call in the new class? But how do I pass the phantom type to that method?
17:00:00 <enthropy>  class Helper a where show_ :: Concrete a -> String;   instance Helper ... ;  instance Helper a => Show (Concrete a)
17:00:08 <revenantphx> so wait, I'm confused
17:00:23 <revenantphx> > let a = newTVar (100 :: Int)
17:00:24 <lambdabot>   not an expression: `let a = newTVar (100 :: Int)'
17:00:25 <mm_freak_> Philippa: both
17:00:26 <revenantphx> >_>
17:00:39 <revenantphx> @define a newTVar (100 :: Int)
17:00:46 <mm_freak_> fix (. id) = fix (. reverse)
17:01:02 <enthropy> tsbo: I'm not sure if that works, but FlexibleInstances is a rather common extension and you shouldn't worry about using it
17:01:09 <revenantphx> I want to during ghci, test out this STM bank account using arbitrary Accounts (where Account = TVar Int
17:01:14 <ClaudiusMaximus> math question: what does orb mean? i'm reading a paper and it's introduced without any more specific definitition than "the f-orbit of x is denoted orb_f(x)"
17:01:21 <mm_freak_> Philippa: semantically at least, disregarding types
17:01:25 <tsbo> enthropy: Cool. I'll just go with FlexibleInstances then. Thanks.
17:01:36 <Philippa> mm_freak_: are you relying on reduction sequences being finite there? The caveat I gave is a major change in the semantics
17:01:41 <lispy1> ClaudiusMaximus: orbits are from group theory
17:01:52 <revenantphx> mm_freak_: how can I create an arbitrary Account >_<
17:02:07 <lispy1> ClaudiusMaximus: http://en.wikipedia.org/wiki/Group_action
17:02:14 <mm_freak_> revenantphx: ?
17:02:14 <Cloe> Cale&ClaudiusMaximus: ok, that makes sense, thx
17:02:15 <ClaudiusMaximus> lispy1: ok - so that would be something very similar to > fst . span (/= x) . iterate f $ x
17:02:21 <revenantphx> hngh
17:02:26 <Philippa> (I knew someone on usenet who'd written a PhD thesis on at least one class of super-turing computer with this kind of change involved, matching a specific kind of space-time allowed by general relativity)
17:02:30 <mm_freak_> Philippa: i don't knowâ€¦  i think, you need to be more specific
17:02:38 <revenantphx> okay
17:02:39 <revenantphx> https://gist.github.com/712893
17:02:43 <mm_freak_> Philippa: it's just like e^x = 2^x for an infinitely large x
17:02:52 <revenantphx> how would I test withdraw in this scenario
17:02:57 <lispy1> ClaudiusMaximus: I don't know the answer to that
17:03:01 <revenantphx> with the end result being printing the value of the account
17:03:26 <mm_freak_> Philippa: or in other words, multiplying 2 by itself is the same as multiplying e by itself infinitely many times
17:03:37 <Cale> Cloe: You could of course use something like  [x | (n,x) <- zip [0..] xs, n >= 5, n <= 7]
17:03:50 <lispy1> ClaudiusMaximus: I like group theory but after a took a few classes on it I never had occasion to use it so I've forgotten so much
17:03:53 <revenantphx> newTVar returns STM( TVar a)
17:04:07 <Cale> revenantphx: atomically
17:04:11 <ClaudiusMaximus> > let orb f x = x : (fst . span (/= x) . iterate f) (f x) in orb (\y -> (5 * y) `mod` 12) 7
17:04:12 <lambdabot>   [7,11]
17:04:14 <revenantphx> that'll give me an IO
17:04:18 <revenantphx> >:_:<
17:04:24 <ClaudiusMaximus> > let orb f x = x : (fst . span (/= x) . iterate f) (f x) in orb (\y -> (5 * y) `mod` 12) 4
17:04:25 <lambdabot>   [4,8]
17:04:39 <revenantphx> orite.
17:05:39 <ClaudiusMaximus> mm, seems like it might be what i need - thanks for the hint, lispy1 
17:05:46 <revenantphx> > atomically (do a <- newTVar 100)
17:05:46 <lambdabot>   <no location info>:
17:05:47 <lambdabot>      The last statement in a 'do' construct must be an ...
17:05:54 <revenantphx> Missing something here.
17:07:01 <enthropy> > fix (\x -> do x) :: Expr
17:07:04 <lambdabot>   mueval-core: Time limit exceeded
17:07:18 <revenantphx> halp.
17:07:19 <revenantphx> plz.
17:07:35 <Cale> revenantphx: your do-block is incomplete
17:07:38 <enthropy> revenantphx: what do you want to do with the a?
17:07:49 <revenantphx> nothing yet, just want that working
17:07:55 <Cale> revenantphx: finish it.
17:07:59 <revenantphx> ideally I'll do withdrawing and testing.
17:08:02 <revenantphx> Cale: what's missing :\
17:08:21 <Cale> revenantphx: do-blocks aren't allowed to end in a line which binds a variable like that
17:08:26 <revenantphx> Oh, okay.
17:08:35 <dobblego> if I :load a module does this overwrite any previously loaded modules?
17:08:48 <enthropy> @undo do a <- b
17:08:48 <lambdabot>  Parse error at end of input
17:08:57 <Cale> revenantphx: Because they translate into a lambda whose body is the translation of the remainder of the do-block
17:08:59 <dobblego> enthropy, b >>= \a ->
17:09:06 <revenantphx> mmk.
17:09:08 <Cale> revenantphx: So it's like writing a lambda with no body
17:09:37 <revenantphx> atomically (do {a <- newTVar 100; withdraw 50 a;}) fails :\
17:09:40 <enthropy> dobblego: yeah, checking if the translation does incomplete codes
17:09:42 <revenantphx> Am I just failing with brces?
17:10:03 <jekor> Is haskell.org really down again?
17:10:07 <revenantphx> YES.
17:10:22 <Cale> The empty statement at the end there is unnecessary :)
17:10:26 * BMeph is...happy, FSVO "happy", to see that some things never change... ;)
17:10:29 <Cale> (but it shouldn't hurt)
17:10:29 <enthropy> @undo do {a;b;c;}
17:10:29 <lambdabot> a >> b >> c
17:10:40 <revenantphx> Couldn't match expected type `Int' against inferred type `TVar t'
17:10:40 <revenantphx>     In the second argument of `withdraw', namely `a'
17:10:40 <revenantphx>     In the expression: withdraw 50 a
17:10:41 <revenantphx>     In the first argument of `atomically', namely
17:10:41 <revenantphx>         `(do { a <- newTVar 100;
17:10:41 <revenantphx>                withdraw 50 a })'
17:10:42 <revenantphx> Erk, sorry
17:10:46 <revenantphx> that was not my pastebin link.
17:11:06 <enthropy> then you've got the arguments backwards
17:11:09 <revenantphx> yeah, seems like it.
17:12:15 <revenantphx> atomically (do {a <- newTVar 100; withdraw a 50; readTVar a})
17:12:17 <revenantphx> yay it works
17:20:03 <revenantphx> okay, what is wrong with this indentation
17:20:04 <revenantphx> https://gist.github.com/712923
17:21:09 <revenantphx> oh wait, nothing, I just had an incomplete definition laying aounrd
17:21:10 <revenantphx> silly.
17:21:44 <revenantphx> neat~
17:22:23 <radioactive_man> whats the difference between software architecture and code?
17:23:18 <Cale> radioactive_man: One would hope as little as possible, though that's not always the case :)
17:24:40 <radioactive_man> this closely relates to the question wheter design patterns are a good thing or not
17:24:59 <djahandarie> Design patterns that are enforced in your type system are good
17:25:32 <Cale> Design patterns that are not formalisable in the language itself are a symptom of a bad thing.
17:25:39 <Cale> (Inexpressiveness of the language)
17:26:41 <Cale> Well, either inexpressiveness of the language, or lack of understanding that makes formalisation difficult.
17:26:43 <radioactive_man> so if you can implement a design pattern in the language, without the need for externally stated implicit conventions (do this, not that..) - than they are good
17:26:59 <Cale> Right, though we usually stop calling them design patterns at that point ;)
17:27:18 <Cale> They're just libraries or definitions or whatever.
17:27:27 <radioactive_man> really?
17:27:55 <radioactive_man> other question: whats the difference between programming language paradigms and design patterns?
17:28:08 <Cale> Sure. Like, "monad" could have been a design pattern, but instead it's a typeclass, together with a library of corresponding definitions.
17:28:27 <copumpkin> radioactive_man: automatic verifiability?
17:28:29 <kmc_> programming language paradigms are bullshit.  design patterns are bullshit.
17:28:35 <radioactive_man> :D
17:28:45 <Philippa> Cale: formalise what applicative, arrow, monad and a whole bunch of hitherto undiscovered classes have in common?
17:28:55 <djahandarie> I wonder if I could write a book that renames everything in Haskell and calls them "design patterns", then sell it to the Java people.
17:29:00 <radioactive_man> kmc_ , interesting view :) - whats not bullshit?
17:29:03 <keegan> programming language paradigms are mostly useful as excuses for your language sucking
17:29:06 <Philippa> (is it even a useful relationship, other than the intuitions gained?)
17:29:07 <Cale> Philippa: They're all constructor classes?
17:29:12 <revenantphx> So today I learned that monads are a lot like condoms (in fact they share 5/6 letters!). Functions returning monads are kind of like ejaculations. The execution (releasing of the semen) is deferred till the end of the act of intercourse.
17:29:14 <Philippa> Cale: well quite :-)
17:29:25 <keegan> Java doesn't have lambda? that's okay, it's not a "functional language"
17:29:35 <keegan> never mind that first class functions were invented 80 years ago and are useful in every type of code
17:30:22 <Cale> keegan: indeed
17:30:27 <keegan> hmm
17:30:33 <keegan> wait i have this nick?
17:30:50 <keegan> no i don't
17:30:52 <Cale> It would seem so.
17:31:00 <djahandarie> You can be identified to your account on a nick you don't own
17:31:11 <kmc> IRC, what a country
17:31:17 <djahandarie> More like Freenode.
17:31:18 <radioactive_man> keegan or kmc (or both), if both: design patterns and programming language paradigms are bad - whats better?
17:31:34 <ivanm> radioactive_man: I'm quite partial to cheese...
17:31:34 <ivanm> :p
17:31:49 <Cale> radioactive_man: Formal semantics.
17:31:55 <Philippa> Cale: my point re that little lot is that when used as bases for EDSLs, there's a definite design pattern going on - one that can't really be usefully formalised beyond some slight waffle about a subcategory of the host language and possible the existance of pure/return/arr
17:31:57 <kmc> radioactive_man, currywurst
17:32:03 <copumpkin> lol
17:32:07 <kmc> radioactive_man, seriously, i have no idea what set you're quantifying over
17:32:20 <kmc> if you want me to pick one noun from the entire universe which is better than design patterns it will be currywurst
17:32:26 <Philippa> and the individual classes very much have their places, even if I'm less convinced about Arrow :-)
17:32:26 <jmcarthur> a design pattern is something that you see often in a given programming language. a paradigm is when you make a design pattern an entire language
17:32:29 <Cale> Maybe a set of possible ways of understanding programs?
17:32:31 <radioactive_man> hah :D
17:33:03 <Cale> Philippa: I'm also not convinced about Arrow. I think it needs some serious revision at least.
17:33:05 <djahandarie> Is there a pattern in design patterns?
17:33:06 <kmc> do design patterns help you understand programs?
17:33:28 <Cale> Philippa: I think that Arrow shouldn't try to generalise Monad and instead adopt stricter laws.
17:33:34 <Philippa> kmc: yep, they speed up pattern recognition
17:33:43 <radioactive_man> design patterns are abstractions, which you cant express directly in the language, but you have to explain them externally
17:33:46 <kmc> but you're only recognizing patterns that wouldn't exsit in a good language
17:33:47 <jmcarthur> kmc: arguably they can, in the sense that a name for a pattern means you can talk about it directly
17:33:54 <kmc> yeah
17:34:04 <Philippa> kmc: how wouldn't the example I've given exist in a good language?
17:34:12 <djahandarie> radioactive_man, what about in the language that can express anything?
17:34:21 <kmc> like am i supposed to feel enlightened when i realize that the FooSingletonFactory is a singleton factory? it doesn't tell me anything about what it does in the problem domain
17:34:23 <djahandarie> radioactive_man, design patterns don't exist?
17:34:27 <kmc> that's about as descriptive as saying "map is a function"
17:34:37 <jmcarthur> kmc: it tells you that you don't want it :)
17:34:45 <ivanm> anyone here an admin for the wiki?
17:34:58 <radioactive_man> i hope to find a language, in which you can express all design patterns - and thus extend it by any paradigm you like
17:35:10 <Cale> ivanm: I'm not, but are you referring to the spam?
17:35:14 <jmcarthur> radioactive_man: that's not really how design patterns work
17:35:21 <ivanm> Cale: by Ipyzykeho? yes
17:35:23 <djahandarie> Design patterns and programming paradigms are two almost totally seperate things...
17:35:26 <Philippa> well, it might tell you something to the extent that "singleton factory" isn't oxymoronic, namely the singleton constraint
17:35:29 <kmc> radioactive_man, that would be Lisp
17:35:29 <djahandarie> I don't know why you are grouping them together.
17:35:33 <radioactive_man> yeah, whats the difference?
17:35:36 <Cale> ivanm: Yeah, I noticed that, because my user talk page got spammed.
17:35:45 <ivanm> yeah, I saw yours there
17:35:55 <jmcarthur> radioactive_man: i wouldn't concern myself with design patterns or paradigms. just ignore those words and you will be much happier
17:36:01 <ivanm> firefox won't even let you see that site :p
17:36:14 <djahandarie> radioactive_man, that's like asking what the difference between an apple and a dinosaur is. They are totally different.
17:36:15 <radioactive_man> jmcarthur, this is the path to wisdom ;)
17:36:26 <radioactive_man> no theyre not that different
17:36:32 <ivanm> Cale: who are we meant to contact about all this now?
17:36:38 <Philippa> that "singleton factory" is something that we can /formalise/ in little more space given a suitably expressive type system is the real problem
17:36:51 <jmcarthur> radioactive_man: they are in fact that unrelated
17:36:54 <Philippa> to put it another way: you're shooting a straw man, what does that have to do with the pattern I've given an example of?
17:36:58 <Cale> ivanm: I'm not sure. Maybe Ashley Yakeley?
17:37:08 <ivanm> there was a new web group formed...
17:37:09 <radioactive_man> procedural programming is a paradigm, which you get by using design patterns in assembly language
17:37:12 <ivanm> preflex: seen ezyang
17:37:13 <preflex>  ezyang was last seen on #haskell-blah 1 hour, 37 minutes and 27 seconds ago, saying: ivanm: I will happily sacrifice formality to communicate enthusiasm :-) 
17:37:17 <ivanm> I remember ezyang was part of it...
17:37:26 <radioactive_man> object orientation in c++ are design patterns in c
17:37:28 <jmcarthur> radioactive_man: it seems you do not understand the meaning of design pattern then
17:37:39 <ivanm> aha, committee@haskell.org
17:37:41 <jmcarthur> radioactive_man: it seems your design patterns are our abstractions
17:37:41 <radioactive_man> then tell me plz :)
17:38:00 <radioactive_man> yes exactly, design patterns are abstractions
17:38:05 <jmcarthur> no, they aren't
17:38:10 <djahandarie> That isn't the standard definition.
17:38:14 <Philippa> they are, but they're not /formal/ abstractions
17:38:14 <kmc> design patterns are *missing* abstractions
17:38:22 <kmc> but i see the progression you're describing
17:38:40 <jmcarthur> radioactive_man: i don't really write OO code in C, even as a pattern
17:38:42 <kmc> you find yourself writing code in some pattern, then you make a language to do it for you
17:38:48 <ivanm> Cale: anyway, I've reported it in case they didn't already know
17:39:10 <kmc> so that's the difference
17:39:13 <jmcarthur> i do tend to write C-style code in assembly, but that's just because it's what i'm used to
17:39:19 * Philippa would quite like for kmc to either
17:39:25 <Cale> radioactive_man: If you can take a design pattern, and capture its essence in code, and stick that code into a library, giving it a name, then you don't have to call it a design pattern anymore. You just call it a function or a typeclass or whatever it happens to be in your language.
17:39:36 <osaunders> radioactive_man: If you use the term design pattern in the most general sense it can encompass almost anything and therefore ceases  to be a useful distinction. 
17:40:05 <Philippa> osaunders: which doesn't necessarily cease to make it a useful concept, though
17:40:10 <djahandarie> Seems like you are using "design pattern" to just mean "pattern".
17:40:12 <radioactive_man> design patterns are abstractions, which you cannot completely express in code
17:40:25 <radioactive_man> then paradigms are a set of implicit patterns
17:40:29 <Philippa> radioactive_man: and which may not be expressable formally
17:40:31 <radioactive_man> (as of my understanding)
17:40:47 <kmc> i think it is a huge waste of time to talk about programming language paradigms in any way
17:40:52 <Philippa> (simple example of something that's not expressable formally: the full extent of the "add another universe" pattern in the design of logics)
17:40:54 <osaunders> radioactive_man: Design patterns are not abstractions. They're techniques for creating abstraction.
17:41:00 <kmc> and probably not very topical to #haskell
17:41:02 <Philippa> kmc: have you read CTM?
17:41:05 <kmc> no
17:41:12 <Philippa> do so, it may change your mind
17:41:19 <kmc> link?
17:41:20 <Philippa> (amongst other things, it has a more refined notion of 'paradigm')
17:41:38 <Philippa> http://www.google.co.uk/url?sa=t&source=web&cd=1&ved=0CBcQFjAA&url=http%3A%2F%2Fwww.info.ucl.ac.be%2F~pvr%2Fbook.html&rct=j&q=CTM%20book&ei=MW3sTJXLD4SAhAfN8azMDA&usg=AFQjCNH0mSBklxyLJovqs1GpGfzVHhISuA&cad=rja
17:41:41 <kmc> i think paradigms are mostly a way to excuse bad languages or to sideline good ones
17:41:44 <Philippa> er, oops, hate when that happens
17:41:47 <kmc> at least in popular usage
17:41:49 <kmc> thanks Philippa
17:41:54 <Philippa> www.info.ucl.ac.be/~pvr/book.html
17:41:59 <Cale> radioactive_man: Right, but usually that indicates a deficiency in your language. If you find that you're repeating yourself all the time in a way that you can notice and describe in any detail, but not express in your programming language, then it probably indicates a weakness of the language.
17:42:20 <Cale> (about design patterns being abstractions not expressible in code)
17:42:20 <radioactive_man> cale, thats what im talking about :)
17:42:27 <Philippa> Cale: right, the examples I'm giving are notable partly in how intensely they resist formalisation
17:43:12 <Cale> On the other hand, if you can't formalise what's similar, then maybe the things you thought were similar aren't actually similar?
17:43:12 <medfly`> remember: haskellers wrote foldr to not write two lines of code every time :)
17:43:17 <Cale> I'm less sure about that :)
17:43:28 <medfly`> even though tow lines is way nicer
17:43:34 <radioactive_man> but are there patterns or idioms, which cannot be specified by abstractions in haskell? so that you  need to follow externally defined conventions?
17:43:37 <Cale> medfly`: not always nicer :)
17:43:45 <kmc> yes radioactive_man, Haskell has design patterns too
17:43:54 <radioactive_man> which?
17:43:54 <ivanm> does anyone know of a pre-existing function that given an Int n, will return all sequences of Ints that sum up to n (either with or without permutations; I want them but can do them myself)
17:44:06 <kmc> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
17:44:09 <kmc> http://byorgey.wordpress.com/2010/04/03/haskell-anti-pattern-incremental-ad-hoc-parameter-abstraction/
17:44:09 <Philippa> radioactive_man: yes, in fact it's almost certainly possible to prove that no formal logic can avoid having such things
17:44:13 <kmc> there's two which people have singled out as bad
17:44:16 <Philippa> (and thus, no formal language)
17:44:19 <Cale> medfly`: Sometimes it's natural to think of your function as replacing the list structure -- being able to reach back in time and replace every (:) that was used to build the list with f, and the [] (if any) with z
17:44:26 <kmc> radioactive_man, also the record system is full of them
17:44:26 <osaunders> radioactive_man: The newtype wrapper would be an example of a design pattern in Haskell.
17:44:35 <radioactive_man> thx
17:44:54 <kmc> there's a pattern of functions of this form:   \new_value record -> record { field = new_value }
17:45:07 <kmc> because you can't abstract over the name of "field" there
17:45:08 <radioactive_man> so can there be a language, where there is no need for this? maybe lisp or bondi ?
17:45:18 <Philippa> FWIW, I disagree with existential typeclass being an antipattern, and even more strongly in a haskell-like language that more openly supports the relationship between modules and type classes
17:45:30 <Philippa> it's certainly not on a level with ball of mud
17:45:32 <kmc> but libraries like fclabels try to fix this
17:45:58 <djahandarie> radioactive_man, I'd say Haskell is the most powerful in this regard, sans some academic languages
17:46:17 <kmc> djahandarie, that's absurd
17:46:18 <Cale> > foldr (\x xs -> concat ["(f ",show x," ",xs,")"]) "z" [1,2,3]
17:46:19 <lambdabot>   "(f 1 (f 2 (f 3 z)))"
17:46:29 <Cale> > foldr (\x xs -> concat ["(",show x,":",xs,")"]) "[]" [1,2,3]
17:46:30 <lambdabot>   "(1:(2:(3:[])))"
17:46:32 <kmc> if you absolutely want to avoid repeating yourself, use Lisp
17:46:46 <kmc> Haskell's advantages over Lisp are not about power and flexibility
17:46:51 <kmc> they're mostly about structure and safety
17:47:00 <lars9> when defining instance MyClass MyType where..., is it ok not to define all functions for that type class?
17:47:05 <kmc> (by Lisp i mean the whole family)
17:47:11 <djahandarie> kmc, I don't agree with that entirely
17:47:31 <Philippa> there's an exception in the form of type class dispatch
17:47:31 <djahandarie> Yes you can avoid repeating yourself in Lisp but that doesn't mean you've captured the "design pattern" fully.
17:47:33 <Philippa> but otherwise, yeah
17:47:43 <osaunders> kmc: Yeah you have to repeat parenthesis all the time :)
17:47:44 <Philippa> yeah, but how do you capture it /more/ fully in haskell?
17:47:45 <kmc> sure but you'll get much closer than in Haskell, much of the time
17:47:46 <djahandarie> I think the expressiveness of types is required to do that.
17:47:49 <Cale> lars9: If there are default definitions for them in the class definition, or you don't mind the code just producing an error if those methods are ever used.
17:48:06 <Philippa> djahandarie: have Qi :-)
17:48:07 <kmc> osaunders, lol parentheses lolololol.  can we have one Lisp discussion that isn't about its syntax?
17:48:10 <lars9> Cale: i see, thanks
17:48:30 <radioactive_man> djahandarie, what do you need types for?
17:48:40 <osaunders> kmc: No :P
17:48:54 <Philippa> radioactive_man: proving something's an instance of the pattern, describing the pattern's semantics
17:48:59 <lispy1> radioactive_man: correctness
17:49:08 <radioactive_man> yeah but not expressiveness
17:49:16 <Cale> There are places where Haskell with typeclasses can also simply be more expressive.
17:49:16 <djahandarie> Philippa, yeah I took a look at this language, but I got put off by the Lisp syntax. :P
17:49:20 <Philippa> that depends what you take 'expressiveness' to mean
17:49:25 <radioactive_man> i mean a type tells you - this belongs to the set of these objects ...
17:49:39 <lispy1> types are like machine checkable documentation, so they express quite a bit
17:49:50 <Philippa> Cale: yeah, I mentioned that. Having dispatch write your code for you based on return type is lovely
17:49:53 <Cale> radioactive_man: Types are properties about the code which can be expressed in the code itself and checked statically by the compiler.
17:50:16 <radioactive_man> types restrict objects to belong to certain sets
17:50:21 <Philippa> radioactive_man: you want to be careful about insisting type systems have set-theoretic semantics :-)
17:50:43 <copumpkin> radioactive_man: yes, but those can be arbitrarily expressive
17:50:44 <radioactive_man> philippa, explain plz
17:50:55 <Cale> radioactive_man: It's easy to fall into the trap of just thinking of them as sets of values, but as your language for describing sets becomes more expressive, they become more and more like properties.
17:51:07 <Philippa> radioactive_man: the classic counterexample is System F. Unless you're happy to use naive set theory, anyway
17:51:44 <ddarius> Philippa: If you're happy to use naive set theory...
17:51:52 <Philippa> and what Cale said. In fact, type systems are logics: programs are proofs, types are propositions
17:52:11 <radioactive_man> interesting
17:52:15 <radioactive_man> wheres that from?
17:52:34 <Cale> That idea is called the Curry-Howard isomorphism.
17:52:45 <djahandarie> (Correspondence)
17:52:45 <Cale> (or correspondence)
17:53:12 <Philippa> in fact: the isomorphism is a formalisation, the correspondance is a more widely-applicable "design pattern" :p
17:53:14 <radioactive_man> thank you! :D
17:53:31 <djahandarie> Now you're just abusing the word Philippa :P
17:53:41 <Philippa> (I earned a distinct WTF on LtU once by insisting that it always applies, but sometimes the logic's a useless POS)
17:54:09 <Cale> radioactive_man: The basic idea is this: If we want to prove the proposition that A -> B (that is "A implies B"), we start by assuming A, and constructing a proof of B under that assumption.
17:54:11 <ddarius> Philippa: By someone who didn't know what they were talking about.
17:54:41 <Cale> radioactive_man: If we want to construct a function A -> B (where A and B are types), then we write a lambda, where we assume that we have a value of type A, and show how to make a value of type B from it.
17:54:59 <Philippa> ddarius: well yeah. Unfortunately there's... a certain pattern of thought involved which I find tricky to identify sufficiently but really ought to so I can skewer it appropriately somewhere
17:55:20 <Cale> Back in logic, if we have both a proof of A -> B, and a proof of A, then we can put them together, and get a proof of B.
17:55:28 <djahandarie> A "design pattern" of thought perhaps?
17:55:29 <djahandarie> :P
17:55:38 <Philippa> the best response to "I'm not sure you can call..." is "I rather think I just did", anyway.
17:55:50 <Cale> In our type system, if we have a function of type A -> B, and a value of type A, we can apply the function to the value, and get a value of type B.
17:56:13 <Cale> radioactive_man: See how that works? :)
17:56:34 <radioactive_man> cale, thx for the explanation :)
17:57:05 <radioactive_man> but i have to think a bit more about this ^^
17:57:21 <Philippa> don't worry, it's a distinctly mind-expanding idea
17:57:24 <Philippa> one of the best in compsci, in fact
17:57:31 <Philippa> so take your time and enjoy
17:58:13 <Cale> Heh, it might even be so mind-expanding that it's mind-contracting. You don't need separate parts of your brain for dealing with logic and type theory. :)
17:58:17 <ddarius> CH = Programmers steal centuries of logic
17:58:55 <revenantphx> AHAHAHAHAHAHA >:D
17:59:04 <revenantphx> I just told someone to go learn Haskell as their first language.
17:59:20 <revenantphx> It's part of my experiment to see if people who don't have imperative experience can learn functional programming more easily.
17:59:20 <djahandarie> That's what I tell everyone.
17:59:22 <revenantphx> We shall see.
17:59:47 <djahandarie> There isn't really a good guide for it imo though
17:59:52 <Goose124> Hey byorgey
17:59:54 <medfly`> revenantphx, he won't be the first
18:00:21 <djahandarie> "Learning Haskell with literally no background in programming" being "it".
18:00:21 <revenantphx> I just gave him lyah djahandarie, it doesn't assume much.
18:00:41 <revenantphx> RWH has slightly higher background requirements, so I'll save that for later.
18:00:51 <Cale> Knowing a bunch of imperative languages is mostly just a hindrance to learning Haskell anyway :)
18:01:03 <djahandarie> LYAH is extremely good for coming from another language but for a total beginner I still think it assumes quite a lot.
18:01:31 <ddarius> RWH is explicitly aimed at those with prior programming experience and isn't very appropriate for those with none.
18:01:50 <revenantphx> djahandarie: not as much though.
18:01:51 <djahandarie> kmc, want a co-author for that guide you're going to write eventually? ;)
18:01:56 <djahandarie> revenantphx, yep
18:01:59 <revenantphx> He understands the sub-language basics, which is ok.
18:02:06 <revenantphx> As in, he knows what the different parts of a computer do.
18:02:15 <revenantphx> (which is sadly more than the average joe)
18:02:20 <djahandarie> Does he know algebra?
18:02:22 <revenantphx> Yes.
18:02:29 * ddarius has never needed to know what the different parts of a computer do to program.
18:02:48 * lispy1 was going to ask where is the spam coprocessor?
18:03:01 <revenantphx> If you ask if you can make your code run faster by upgrading your RAM, you have a problem imo ddarius 
18:03:14 <djahandarie> revenantphx... you often can.
18:03:28 <enthropy> ddarius: not even the keyboard and monitor :P
18:03:31 <revenantphx> upgrading your RAM capacity*
18:03:36 <revenantphx> not the access speed or anything.
18:03:49 <revenantphx> And for a simple program which isn't eating whole gigabytes.
18:04:03 <djahandarie> You still can. Because if what you need can't fit in the RAM it just goes farther away, hence slower access time.
18:04:17 <djahandarie> (Often onto slower types of material too.)
18:04:19 <revenantphx> *which isn't eating whole gigabytes*
18:04:27 <dobblego> I use this to teach haskell https://bitbucket.org/dibblego/haskell-course/
18:04:29 <djahandarie> Right, but you just qualified that now. ;)
18:04:32 <revenantphx> Assumin g it fits.
18:04:33 <revenantphx> Sorry.
18:04:42 * Cale wonders if he can claim to know algebra.
18:04:49 <Cale> ;)
18:04:55 <lispy1> Cale: depends on if you know ALL of it or not :)
18:04:55 <ivanm> Cale: AFAICT, you can claim to know _everything_!
18:05:00 <ddarius> Cale: I suspect you can.
18:05:01 <djahandarie> Cale, high school algebra. :P
18:05:20 <djahandarie> Last I checked no abstract algebra was required to understand Haskell
18:05:22 <ddarius> Everyone in the latter parts or beyond high school should know high school algebra.
18:05:22 <lars9> how to get more type safety from "type Name = String" by preventing passing f::String to g::Name -> SomeThingElse ?
18:05:27 <lispy1> ?remember Cale ***Cale wonders if he can claim to know algebra.
18:05:28 <lambdabot> Done.
18:05:44 <lispy1> djahandarie: equational reasoning is algebraic, and quite useful
18:05:46 <ddarius> Also, just high school algebra isn't that useful, though not knowing it would probably be a rather large problem.
18:05:50 <ivanm> lars9: newtypes
18:05:58 <ivanm> newtype Name = Name String
18:06:11 <Philippa> ddarius: it's almost enough to understand the (H2010) typechecker works, mind - only a mild generalisation
18:06:21 <lars9> ivanm: i see, thanks
18:06:39 <revenantphx> how is HS2010 different?
18:06:40 <kmc> lars9, "newtype" is just an optimized version of "data", to first approximation
18:06:43 <ivanm> lars9: actually, to make it easier on yourself, you might want to define it like this: newtype Name = Name { name :: String } deriving (Eq, Ord, Show, Read)
18:06:43 <kmc> data Name = Name String
18:06:46 <revenantphx> Is there much new stuff?
18:06:55 <lispy1> there are new things and removed thing
18:06:57 <Cale> If you don't understand the entire proof of the classification of finite simple groups, can you REALLY claim that you "know algebra"? :)
18:07:03 <Philippa> revenantphx: it's just what we should all get into the habit of thinking of as the base standard now rather than H98
18:07:15 <ivanm> Cale: in that case I don't think I can claim that then... :(
18:07:20 <revenantphx> It's not in the haskell platform yet tho > >
18:07:22 <Philippa> most of the changes compared to H98+addenda are fairly small
18:07:28 * ivanm goes back to trying to work out how to implement his graph-generating algorithm
18:07:38 <ddarius> Cale: It depends on the specific proof.
18:08:27 <Cale> It's only tens of thousands of pages split across several hundred journal articles.
18:08:38 <ddarius> Cale: Indeed.
18:08:54 <ddarius> Cale: Of course, you could write a program to check it...
18:09:12 <ddarius> Cale: On the other hand, does not understanding a proof of the fundamental theorem of algebra mean you don't know algebra?
18:09:40 <Cale> Heh, that's a funny question, given that the proof is usually a bunch of analysis :)
18:10:16 <djahandarie> Or even worse, topological!
18:11:30 <lars9> ivanm: can those deriving be automated?
18:11:39 <megajosh2> http://hpaste.org/41759/cant_read_characters_until_i I'm trying to read characters from a Handle until the character I get is \NUL, but I end up with a type error I can't fix
18:11:44 <megajosh2> Does anybody know how I could fix this?
18:11:45 <ivanm> lars9: what do you mean? just put them there!
18:11:50 <ivanm> that's the whole point of deriving!
18:11:52 <lars9> ivanm: inheritate String's
18:12:12 <ivanm> you mean so that show (Name "bob") == show "bob" ?
18:12:16 <lars9> *inherit
18:12:31 <ivanm> if so, that's not a good idea
18:12:49 <lars9> Show is a little different, but Ord Eq
18:13:01 <ivanm> lars9: they will work the same way
18:13:18 <ivanm> it will be something like: instance Eq Name where (Name n1) == (Name n2) = n1 == n2
18:13:35 <ivanm> you can check that by calling ghc[i] with -ddump-deriv
18:13:46 <Saizan> megajosh2: you need parens around c:c' and c:[]
18:13:57 <lars9> ivanm: i know that, i just thought Eq Ord could be inherited
18:13:58 <megajosh2> ...oh of course
18:14:00 <megajosh2> Heh
18:14:01 <megajosh2> Thanks
18:14:07 <ivanm> lars9: what do you mean by "inherited"?
18:14:09 <Saizan> np
18:14:12 <ddarius> Cale: As far as I know, there is no "elementary" proof of the fundamental theorem of algebra.
18:14:30 <ivanm> lars9: note that with newtypes, at runtime the actual constructor doesn't exist
18:14:43 <ivanm> it's only there at compile time
18:14:48 <ddarius> It would be an interesting exercise in proof theory to prove that such a proof isn't possible.
18:14:51 <lars9> ivanm: for optimization?
18:15:02 <ivanm> not needed for newtypes
18:15:10 <dobblego> @type readsPrec -- what is the first argument for?
18:15:11 <lambdabot> forall a. (Read a) => Int -> String -> [(a, String)]
18:15:18 <ivanm> and stripping away the constructors doesn't give you much better spead
18:15:27 <ivanm> dobblego: precedence
18:15:32 <Causalien> Is there anybody who can get into haskell.org website?
18:15:34 <ivanm> whether to have brackets, etc.
18:15:38 <ivanm> Causalien: it's down
18:15:41 <megajosh2> Causalien: I haven't for at least an hour or so
18:15:49 <dobblego> ivanm, do you have an example?
18:15:49 <Causalien> ok glad to know.
18:15:50 <ivanm> Causalien: new-www.haskell.org is up if you need the wiki
18:15:50 <megajosh2> Last time I checked of course
18:15:58 <ivanm> dobblego: lemme dig it up
18:16:06 <megajosh2> Oh wow
18:16:17 <megajosh2> It's about time the Haskell website didn't look like it was trapped in 2003
18:16:42 <ivanm> dobblego: see the Read instance for PlanarGraph here: http://code.haskell.org/~ivanm/planar-graph/Data/Graph/Planar.hs
18:16:45 <kmc> well being trapped in 2003 is bad
18:16:46 <Cale> ddarius: At a certain point you need a *little* bit of analysis because you need to use properties of R which aren't true of Q.
18:16:48 <Goose124> Help, what does this mean:
18:16:49 <Goose124> Module imports form a cycle for modules:
18:16:49 <Goose124>   Main (C:\Users\Grayson\Desktop\Bot To Be Modules\Kelly.hs)
18:16:49 <Goose124>     imports: Main
18:16:51 <kmc> being trapped in someone's PhD thesis in 2003 is worse
18:16:54 <Cale> ddarius: But that can be reduced quite far.
18:16:56 <kmc> that's death to any functional language
18:16:58 <ivanm> note that I'm using GHC's readPrec stuff rather than readsPrec, but it means the same thing
18:17:01 <dobblego> ivanm, I'd love to
18:17:03 <Goose124> Am I importing duplicate libraries?
18:17:06 <kmc> Guest32383, means you're trying to import modules in a cycle
18:17:08 <kmc> A imports B imports A
18:17:11 <dobblego> ivanm, but alas, code.haskell.org does not exist
18:17:16 <ivanm> dobblego: works for me...
18:17:19 <kmc> haskell.org is downforme
18:17:23 <ivanm> I just went there
18:17:33 <ivanm> kmc: haskell.org is on a different machine than code.haskell.org
18:17:41 <Cale> ddarius: There's a proof which only involves the assumptions that every polynomial with odd degree has a real root, and every non-negative real number has a square root (both of which are consequences of the intermediate value theorem)
18:17:44 <ddarius> Much better to be trapped in a 1992 PhD thesis.
18:17:57 <dobblego> ivanm, http://downforeveryoneorjustme.com/code.haskell.org
18:17:58 <ivanm> ddarius: why is 1992 preferable to 2003?
18:18:32 <ivanm> dobblego: WORKSFORME... just slow, that's all
18:18:38 <ivanm> but I'll hpaste it anyway
18:18:51 <lispy1> dobblego: it's down
18:18:53 <lispy1> dobblego: again
18:19:06 <ivanm> dobblego: actually, just see the Read instance for Map or something
18:19:15 <dobblego> ivanm, I have it thanks
18:19:29 <ivanm> the instance for Map is probably a better example
18:20:01 <megajosh2> Wow...
18:20:10 <megajosh2> Check out that link in the "UNDER CONSTRUCTION" text
18:20:28 <megajosh2> It links to some website that shows you a fake window prompting you to "Install ActiveX"
18:20:38 <megajosh2> And it wants you to download "activex.exe"
18:21:58 <ddarius> This is a strange architecture diagram that has an arrow from "Play Sounds" to "Graphics Card"
18:22:21 <ddarius> (Though I guess the GPU would be good for sound sythesis/mixing.)
18:22:23 <ivanm> megajosh2: yeah, a spammer hit new-www
18:24:39 * ddarius wonders if his graphics card has a reasonably useable GPU.  Synthesizing sound with it sounds fun.
18:25:06 <lispy1> HOpenCL or something allows you to do that right?
18:25:31 <Axman6> there's OpenCLRaw, which is just an OpenCL C API wrapper
18:25:44 <lispy1> ah right: http://hackage.haskell.org/package/OpenCLRaw
18:26:46 * ddarius will have to do some relatively heavy applied math to return to a audio analysis project he started many years ago.
18:30:28 * hackagebot Digit 0.0.1 - A data-type representing digits 0-9  http://hackage.haskell.org/package/Digit-0.0.1 (TonyMorris)
18:49:32 <mm_freak_> how can i name record fields in a pattern?  i remember there was a syntax for this
18:50:26 <Aune> I have a question about the order of evaluation in haskell. If I define a memoizing function in this maner:
18:50:26 <Aune>     let fibs = 1:1:zipWith (+) fibs (tail fibs)  ;  let fib n = fibs !! n.
18:50:58 <Aune> what can I say about the fist time I call the function fib n?
18:51:46 <lars9> @hoogle getLine
18:51:46 <lambdabot> Prelude getLine :: IO String
18:51:46 <lambdabot> Data.ByteString getLine :: IO ByteString
18:51:46 <lambdabot> System.IO getLine :: IO String
18:54:33 <ivanm> mm_freak_: as in pattern-matching?
18:54:34 <mm_freak_> there was an extension for writing stuff like this:
18:54:37 <Axman6> Aune: what do you mean?
18:54:47 <ivanm> foo Foo{bar = 1, baz = 2} = ...
18:54:48 <mm_freak_> let x { someField } = someExpr â€¦
18:54:49 <Cale> Aune: If n is large the first time, you'll end up evaluating a possibly quite large expression, and the values up to that point in the list will be memoised.
18:54:50 <Aune> I have a hard time expressing it
18:55:03 <mm_freak_> ivanm: oh, i see my error now
18:55:04 <ivanm> mm_freak_: there's also a few extensions like RecordPuns or something
18:55:14 <ivanm> where the record name becomes teh variable
18:55:51 <mm_freak_> otherwise i need to use rec@(MyType { â€¦ }), right?
18:56:08 <ivanm> mm_freak_: yeah, if you want to make sure which constructor it was
18:56:15 <ivanm> just rec@MyType{} should do for that
18:57:00 <Aune> Ok, but my question should be frazed in this way. If I want to evaluate f(a,b), will it first fully evaluate a, fully evaluate b or evaluate them side by side?
18:57:16 <ivanm> Aune: what's f?
18:57:24 <jon_of_arc> Depends, which if either do you need?
18:57:41 <ivanm> Aune: most Haskell imiplementations only evaluate what is actually needed and nothing else
18:58:36 <enthropy> what you actually ask to be evaluated
18:58:56 <jon_of_arc> So f a b = k evaluates neither a nor b, because it needs neither of them
18:59:17 <jon_of_arc> Er, that is, if f is defined in that manner
18:59:22 <kmc> Aune, evaluation happens when you pattern-match
18:59:34 <kmc> when you ask "which constructor was used to build this value?"
18:59:46 <kmc> then evaluation occurs only to the point where it knows which constructor was used
18:59:46 <ski> (mm_freak_ : s/MyType/MyTypeCon/ ..)
18:59:53 <kmc> this is called "evaluating to weak head-normal form"
19:00:07 <kmc> an expression is in weak head-normal form if the outermost syntactic element is a constructor or a lambda
19:00:09 <enthropy> implementations are free to randomly evaluate things
19:00:21 <revenantphx> I know this is really dangerous to ask but...
19:00:22 <kmc> this is anyway the strategy used by GHC
19:00:25 <revenantphx> what IDE's do you guys use?
19:00:27 <Axman6> Aune: haskell programs only evaluate as much as they need to evaluate to give you the answer it needs, which means things passed to functions may never be evaluated
19:00:31 <dankna> Emacs
19:00:32 <kmc> revenantphx, vim and ghci, in screen
19:00:39 <revenantphx> in screen?
19:00:42 <jon_of_arc> Aquamacs Emacs
19:00:44 <kmc> GNU Screen
19:00:44 <enthropy> @google ghc speculative evaluation
19:00:45 <lambdabot> No Result Found.
19:00:49 <kmc> > let f x = () in f (0/0)
19:00:50 <lambdabot>   ()
19:01:37 <enthropy> this paper http://research.microsoft.com/en-us/um/people/simonpj/papers/optimistic/index.htm
19:01:37 <kmc> > let f x = () in f (error "crash and die")
19:01:38 <lambdabot>   ()
19:01:44 <Goose124> helps
19:01:57 <mm_freak_> ivanm: thanks
19:02:00 <Goose124> (show (BF.run (BF.run code input) "")))
19:02:25 <Goose124> I think the problem I'm having could be resolved if i showed the encolsed BF.run
19:02:31 <Goose124> but it doesnt really work like lisp xD
19:02:39 <enthropy> but that's not how ghc works, and you couldn't tell the difference by program output anyways
19:02:42 <Aune> yes, but if both are neded as in the fibbonachi example, then both must be evaluated. If one of the f(n) = f(n-1) +f(n-2) causes one of these to be fully evaluated first then the other one will only immediatley find its value afterwards in the memoized datastructure. If they evaluate side by side I might get a hughe number of partial traversals of the memoized datastructure, might I not?
19:03:35 <Aune> I think I am being slightly unclear
19:07:53 <Cale> Aune: There's only one traversal of the list there...
19:08:04 <ClaudiusMaximus> @hoogle (a -> Maybe a) -> a -> [a]
19:08:04 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
19:08:04 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:08:05 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:08:12 <Aune> In              let fibs = 1:1:zipWith (+) fibs (tail fibs)  ;  let fib n = fibs !! n        When I call (fib n) it should first traverse fibs without calculating the values in the cells of the list, then upon inspection it would see that the nth value in the list refers to the two previous elements in the list.
19:08:24 <Cale> yeah
19:08:45 <Cale> and as it evaluated that expression, the expressions in the list cells will be replaced by their values
19:09:12 <Cale> There will be a good number of things put on the stack as pattern matches generated by (+) need to wait for the numeric expressions to evaluate
19:09:21 <ClaudiusMaximus> where can i find an implementation of something like iterate-for-Maybe a that stops at Nothing ?
19:09:31 <Cale> But any given element of the list will only be evaluated once
19:09:41 <Axman6> unfoldr?
19:09:47 <ClaudiusMaximus> :t unfoldr
19:09:48 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
19:10:15 <Axman6> > unfoldr (\x -> if x < 10 then Just (x,x+1) else Nothing) 0
19:10:16 <lambdabot>   [0,1,2,3,4,5,6,7,8,9]
19:10:26 <Cale> http://twitter.com/avalanche123/status/7062890318143488 -- haha
19:10:58 <magicman> NullPointerException
19:11:00 <magicman> >_> <_<
19:12:02 <Aune> Ok, so (+) first evaluates its first argument fully and then its second argument?
19:12:18 <Aune> or vice versa
19:12:45 <ClaudiusMaximus> > let f 10 = Nothing ; f n = Just (n+1) ; both x = (x, x) in unfoldr (fmap both . f) 10
19:12:46 <lambdabot>   []
19:12:50 <ClaudiusMaximus> > let f 10 = Nothing ; f n = Just (n+1) ; both x = (x, x) in unfoldr (fmap both . f) 0
19:12:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
19:13:01 <Aune> Or is it simpler than that....
19:13:15 <lars9> in a do block, l <- (return . map read . lines) =<< getContents, how to add a ::Integer to make l list of integers?
19:13:30 <garslo> Aune: Yes. Consider `(+) (last [1..]) 4`, which hangs.
19:13:32 <lispy1> ?tell dcoutts_ I'm now running cabal install --dry-run foo, for every package foo I want to install.  Thanks for the advice.  Now I can tell when installing something would do crazy things.
19:13:33 <lambdabot> Consider it noted.
19:14:14 <magicman> garslo: `(+) 4 (last [1..])` hangs just as well. (+) must evaluate both arguments, but in which order...
19:14:28 <Aune> garslo: yes but that would hang nomatter what evaluation strategy used
19:14:42 <ClaudiusMaximus> Axman6: thanks  - i always find unfoldr slightly obfuscatory/confusing...
19:14:42 <magicman> Probably this can be found out with *shudder* Debug.Trace.trace
19:14:44 <revenantphx> Halfway through the Santa Claus Problem, I've concluded that STM IS MAGC.
19:14:46 <garslo> magicman: Well, I'm not doing so well tonight. Sorry about that
19:14:47 <revenantphx> MAGIC I SAY.
19:14:51 <revenantphx> STM IS MAGIC*
19:15:50 <magicman> And then there's still the distinct possibility that GHC decides it's a smart compiler, and changes the evaluation order around if it deems that more efficient.
19:15:58 <lispy1> Cale: ping
19:16:07 <magicman> Though I doubt it'd do that... I'm not very familiar with GHC's implementation. Theoretically, though, it's free to do so.
19:16:15 <Cale> lispy1: hi
19:16:20 <revenantphx> CONCURRENCY CANNOT BE THIS EASY.
19:16:26 <revenantphx> >:(
19:16:30 <Aune> I think I am asking the wrong question.... What I should be asking is, when a function refers to the same thunk if diffrent ways, is there ever a possibility for the thunk to be evaluated more than once. And when I frame it like that it seems obvious that it wont
19:16:32 <revenantphx> THERE IS WITCHCRAFT AFOOT.
19:17:06 <lispy1> Cale: I heard a nasty rumor that you can no longer build lambdabot?
19:17:06 <magicman> let `x = expensive computation in x + x` will only evaluate x once.
19:17:11 <Cale> magicman: I would expect GHC to evaluate the args to (+) in whatever order served it best.
19:17:14 <lispy1> Cale: anything I can help with?
19:17:15 <magicman> But with the first ` before "let".
19:18:12 <Cale> lispy1: I haven't checked more recently, but last time that I tried, I had some problem with it. It was long enough ago that I don't actually remember what it was. I think maybe it's that the darcs version had dropped support for the installed version of GHC at the time.
19:18:56 <Cale> (You have 6.10.4 on there)
19:21:05 <lispy1> Cale: ah.  Hmm
19:21:25 <lispy1> Cale: You have sudo privs to apt.  The one catch is that you have to build it with splitObjs False
19:21:42 <lispy1> I'll think about that...what version would you want on there (if I find time to upgrade it)
19:21:45 <lispy1> 6.123?
19:21:49 <lispy1> er, 6.12.3
19:21:58 <augur> combinatorial species! \o/
19:22:09 <Cale> That would probably be fine.
19:22:15 <Cale> We probably can't do 7 yet.
19:23:47 <Cale> Aune: Yeah, the tricky part is that this is really graph reduction.
19:24:03 <Cale> Aune: (and not just reduction of expression trees to other trees)
19:24:39 <Aune> Yeah, I have a hard time picturing what happens
19:25:14 <Cale> I had some pictures around somewhere. My old webserver is down though...
19:26:04 <Cale> (depicting what happens as that fibs list is updated)
19:26:14 <Goose124> byorgey you there?
19:29:48 <Aune> Because if GHC can do as it pleases with the order of evaluation (as it well should) then it is possible that it would intermix the evaluation of the two backward referenses in the list. And then it reduces to a question about GHC being smart enough to realize that it has already started evaluating the thunk and does not need to do so again. This seems like a nobrainer.
19:30:12 <osaunders> More problems with haskell.org :(
19:30:38 <Aune> So I consider my question answered.
19:35:12 <kmc> Aune, GHC doesn't do parallel evaluation on its own
19:35:16 <kmc> but you can use the "par" function to suggest it
19:35:25 <kmc> and in those situations, yes, it will prevent duplicated work
19:35:49 <kmc> with the threaded runtime, when evaluation of a thunk is forced, the thunk is first replaced with a "whitehole"
19:35:53 <revenantphx> erm.... I broke the santa example
19:36:02 <revenantphx> It seems the elves aren't speaking in turn.
19:36:15 <revenantphx> https://gist.github.com/713059
19:36:16 <Aune> kmc: Thanks for the explanation.
19:36:18 <kmc> if a thread forces evaluation of a whitehole, that thread is suspended until the whitehole becomes something else
19:36:28 <revenantphx> code: https://gist.github.com/713062
19:36:32 <Aune> Awesome
19:36:42 <kmc> (iirc there is a small race condition, so it's possible for work to be duplicated, but very unlikely)
19:36:52 <kmc> (this is deemed better than the cost of locking on every thunk entry)
19:37:02 <kmc> (and won't affect semantics because evaluation is pure)
19:37:08 <Axman6> yay
19:37:31 <revenantphx> That and, after that output, it just sort of locks up.
19:37:32 <revenantphx> Forever.
19:37:39 <getpwnam> are 'learn you a haskell' followed by 'real world haskell' good choices for a haskell neophyte to familiarize himself with the language?
19:38:03 <Axman6> getpwnam: that's always what i recommend
19:38:10 <revenantphx> that and it's eating up 3.25GB of memory
19:38:12 <revenantphx> SOMETHING IS WRONG HERE.
19:38:31 <revenantphx> <interactive>: memory allocation failed (requested 2097152 bytes)
19:38:33 <revenantphx> >_>
19:38:48 <Axman6> wtf did you do?
19:39:02 <revenantphx> I'm not sure what's wrong.
19:39:09 <revenantphx> I've been copying almost verbatim.
19:39:59 <revenantphx> oh fuck
19:40:04 <revenantphx> ghc is running in the background somehow
19:40:06 <revenantphx> AND STILL EATING RAM
19:40:08 <kmc> getpwnam, i would say read them both and see which you like
19:40:14 <kmc> i don't think you need to read LYAH then RWH in that strict order
19:40:15 <Aune> kmc: thanks, that is exactly the information I was looking for (though I did not know it when I started) 
19:40:20 <kmc> cool Aune :)
19:40:22 <revenantphx> at 1.69gb and rising...
19:40:24 <revenantphx> 2.59gb
19:40:29 <revenantphx> Oh fuck, I'm gonna crash TT_TT
19:40:35 <revenantphx> GAAAAH SIGTERM
19:40:38 <kmc> eject!
19:40:39 <revenantphx> SIGTERM SIGTERM SIGTERM
19:40:44 <revenantphx> yay it died.
19:40:56 <revenantphx> No seriously, kmc can you help me TT_TT
19:41:23 <kmc> with what?
19:41:41 <revenantphx> well, the code I pasted earlier produces the output I pasted earlier.
19:41:43 <getpwnam> Axman6: kmc: thanks, i'm a moderately competant perler, but i want to learn what all this functional programming stuff is all about
19:41:48 <revenantphx> And then locks up, and attempts to EAT ALL OF MY MEMORY
19:41:59 <Axman6> heh, forget everything you know
19:42:22 <revenantphx> It prints correctly when compiled... but then it runs out of elves and shit gets hairy.
19:42:33 <revenantphx> It locks up waiting for reindeers.
19:42:49 <revenantphx> and then it's like OMNOMNOM 2mb/s
19:43:03 <revenantphx> (additional RAM usage)
19:43:20 <kmc> getpwnam, ah... well, i think learning FP through Haskell is a decent idea, but do be aware that Haskell is far from a *typical* functional language... you'll encounter lots of foreign concepts all at once
19:43:42 <lispy1> What is the CPP define to check the GHC version?
19:43:43 <kmc> Haskell is FP + laziness + purity + type classes + static types + polymorphism + ...
19:44:08 <revenantphx> kmc: Do you see why the reindeer's are being ignored?
19:44:15 <Axman6> + easy parallelism + easy concurrency, unless you're revenantphx 
19:44:16 <kmc> i don't see any reindeer
19:44:18 <ivanm> kmc: + awesome, right? :p
19:44:22 <revenantphx> Axman6: Yeah apprently.
19:44:26 <revenantphx> kmc: look in the code.
19:44:37 <kmc> there's code?
19:45:10 <ivanm> revenantphx: are you trying to do the problem that SPJ talks about in "beautiful code" as an STM example?
19:45:15 <revenantphx> Yes.
19:45:27 <revenantphx> I'm going to compare it to his version, and figure out what's different.
19:45:35 <ivanm> @type getStdRandom
19:45:36 <lambdabot> forall a. (StdGen -> (a, StdGen)) -> IO a
19:45:59 <ivanm> revenantphx: ^^ IIRC, that's slower than passing a seed around
19:46:09 <revenantphx> ?
19:46:37 <ivanm> do you have any values accumulating anywhere?
19:46:45 <getpwnam> kmc: okay, as long as it doesn't melt my brain i don't mind if it's different..
19:47:14 <Axman6> getpwnam: that's what haskell is renound for :\
19:47:23 <ivanm> maybe some seq's for the writeTVar in passGate?
19:47:24 <revenantphx> ivanm: I'm comparing with SPJ's code to find where I messed up.
19:47:28 <Axman6> but the melting is worth it
19:47:36 <ivanm> Axman6: definitely
19:47:55 <revenantphx> Um, his fails in terms of printing too, but works otherwise.
19:48:09 <ivanm> how does his fail in terms of printing?
19:48:13 <ivanm> because they get all mixed up?
19:48:51 <ivanm> revenantphx: try this: in passGate, make your last line: writeTVar tv (n_left `seq` n_left - 1)
19:49:01 <ivanm> similarly in joinGroup
19:49:11 <revenantphx> kk, sec.
19:50:28 <getpwnam> it seems like haskell.org is down at the moment?
19:50:42 <ivanm> yes
19:50:47 <revenantphx> >_>
19:50:48 <revenantphx> NO REALLY
19:50:54 <ivanm> YA RLY
19:51:02 <ab9rf> NO OWLS
19:51:27 <revenantphx> hngh, in SPJ's version he rewrite passGate and joinGate to useGate
19:51:35 <revenantphx> btw, why does ghci fail at printing
19:51:59 <revenantphx> this is ghci:
19:51:59 <revenantphx> https://gist.github.com/713079
19:52:08 <ClaudiusMaximus> lp0 is on fire
19:52:21 <revenantphx> this is compiuled
19:52:21 <revenantphx> https://gist.github.com/713080
19:53:18 <ClaudiusMaximus> ghci is -threaded, compiled isn't (by default)
19:53:30 <ClaudiusMaximus> is my guess
19:53:36 <kmc> getpwnam, cool.  the main thing is just to stick with it and be willing to delay gratification
19:53:51 * revenantphx is still not seeing what is wrong with his code, and is irritated.
19:54:03 <kmc> a lot of us expect learning a new language will just be new syntax and that we'll be writing 3D games and webapps by the first day
19:54:32 <Pseudonym> kmc: Webapps are feasable in some languages.
19:54:36 <getpwnam> i guess haskell is the opposite of perl in that respect
19:54:43 <getpwnam> and probably many others..
19:55:12 <kmc> in Haskell you will spend hours on problems that seem trivial yet where the solution is totally alien
19:55:21 <Pseudonym> It just so happens that many of my standard toy problems are string and structure hacking.
19:55:22 <kmc> and eventually you start to think differently
19:55:29 <ClaudiusMaximus> revenantphx: probably you want to send complete messages to a Chan, with a thread that reads from it and prints them one by one, instead of printing from each thread and getting meaningless interleaved output
19:55:34 <Philippa> and then, problems that would've taken months take hours
19:55:41 <revenantphx> ClaudiusMaximus: this is ture.
19:56:07 <revenantphx> So uh... still not seeing what the issue is tho
19:57:05 <ClaudiusMaximus> ah, scrolling up i see STM, i've never used it - i'll shutup :)
19:57:20 <Pseudonym> Now's your chance to learn, CM.
19:58:03 <ClaudiusMaximus> no! it's 4am and i have one more lemma in this paper to implement before i can sleep...
19:58:29 <Pseudonym> Well, at least that's a worthy thing to do.
19:58:45 <dankna> true
19:59:41 <lispy1> how do you check the version of GHC at compile time?
20:00:34 <getpwnam> kmc: 90% of my coding is text processing.. can we comfortably use haskell for that stuff?
20:01:01 <lispy1> getpwnam: I'd say so
20:01:20 <Philippa> I'd sooner do that in haskell than perl, tbh
20:01:38 <ab9rf> haskell can be used for text processing, it can be very good for that
20:02:02 <ivanm> lispy1: maybe check how text does it for the default encodings, etc.
20:02:04 <ab9rf> you have to be careful to avoid sucking the entire document into memory unnecessarily
20:02:07 <ivanm> but I think it's normally done in Cabal :s
20:02:34 <ab9rf> but haskell can make doing that easier than in many otherlanguages
20:02:41 <ddarius> ab9rf: It's pretty easy to avoid doing that.
20:03:00 <ab9rf> ddarius: fairly easy, yes
20:03:02 <ddarius> In fact, it is not uncommon for people to have the opposite problem.
20:03:06 <kmc> getpwnam, i think Haskell is good for text processing, but maybe not as a beginner
20:03:09 <lispy1> ivanm: oh, thanks: #if __GLASGOW_HASKELL__ <= 610
20:03:16 <ivanm> np
20:03:23 <kmc> you'll want to learn libraries like "text" and "bytestring", while most tutorials start off with String
20:03:30 <kmc> and you'll want to learn some parsing libraries like Parsec
20:03:38 <kmc> RWH covers this stuff though
20:03:49 <getpwnam> kmc: well i can continue to use perl while i am learning, that's not a problem
20:03:53 <ab9rf> my first "real" haskell program was a parser :)
20:03:55 <revenantphx> well, that that was an enlightening expedition into the STM mond.
20:03:55 <getpwnam> thanks
20:04:01 <kmc> regexes are not much used in Haskell and i personally think the standard Haskell regex API is awful and un-Haskellish
20:04:06 <revenantphx> I like how you can spend a night learning the basics of each monad~
20:04:18 <kmc> getpwnam, yeah, i would just start a Haskell tutorial and see where it goes from there
20:04:29 <revenantphx> This may inspire a pokemon complex in me...
20:04:36 <revenantphx> Gotta learn them all! (monads)
20:04:42 <ab9rf> revenantphx: we'll jus thave to make more :)
20:04:47 <revenantphx> FFFFF
20:08:28 <turiya> can i find a tutorial on unsafeperformio somewhere?
20:08:55 <Axman6> look for FFI tutorials
20:09:15 <ddarius> turiya: What are you expecting from a "tutorial" on unsafePerformIO?
20:11:19 <kmc> i'm picturing a thick nicely bound hardcover book that says "Tutorial on unsafePerformIO" on the cover, and when you open it a boxing glove on a spring comes out and punches you
20:11:27 <dankna> hah
20:11:28 <dankna> nice
20:12:15 <danderson> kmc: I was thinking more a landmine with a "press me" post-it
20:12:49 <jmcarthur> turiya: if you need a tutorial, don't use it
20:13:03 <turiya> ddarius: i am looking for some examples of its usage
20:13:06 <kmc> turiya, do you have a specific question about unsafePerformIO?
20:13:30 <ivanm> turiya: are you doing any FFI?
20:13:38 <kmc> turiya, see the RWH chapter on FFI
20:13:38 <kmc> that is the original purpose
20:13:43 <turiya> kmc: yeah, i want to know of an example where it is unsafe
20:13:47 <kmc> you may import a pointerful C function and then do marshalling on the Haskell side, but you claim the overall procedure is a pure function
20:13:49 <kmc> oh
20:13:54 <ivanm> if not, you don't want it
20:14:02 <kmc> i think the System.IO.Unsafe API docs describes that pretty well
20:14:05 <ivanm> turiya: using it to get random numbers
20:14:15 <ivanm> @hoogle (Random a) => a
20:14:16 <ivanm> @hoogle (Random a) => IO a
20:14:21 <kmc> you can use unsafePerformIO to make "polymorphic IORefs", totally break the type system, and segfault or worse
20:14:22 <turiya> ivanm: yes, i am using ffi
20:14:29 <ivanm> lambdabot: wakey, wakey!
20:14:45 <ivanm> turiya: you should only use it if the function you are calling is referentiallly transparent
20:14:54 <ddarius> Compressing what kmc said, you can implement unsafeCoerce in terms of unsafePerformIO and IORefs.
20:15:15 <ivanm> i.e. every time you call it with the same arguments it returns the same thing, and doesn't involve the world
20:15:32 <lambdabot> Prelude undefined :: a
20:15:32 <lambdabot> Test.QuickCheck.Batch bottom :: a
20:15:32 <lambdabot> System.Random randomIO :: Random a => IO a
20:15:32 <lambdabot> System.Random randomIO :: Random a => IO a
20:15:32 <lambdabot> System.Random randomRIO :: Random a => (a, a) -> IO a
20:15:33 <turiya> if i use malloc and return a pointer and then use unsafeperformio, is is unsafe?
20:15:34 <lambdabot> System.Exit exitFailure :: IO a
20:15:48 <kmc> what's a good name for the data type you pass to Mu?
20:15:48 <jmcarthur> turiya: if it would break purity, it's unsafe. purity is referential transparency and the absense of observable side effects
20:15:51 <kmc> i've heard "pattern functor"
20:15:54 <lispy1> What are you supposed to do when you want to support two incompatible versions of the same package?
20:16:06 <kmc> but i don't think that's quite right
20:16:07 <ivanm> kmc: when you say "or worse", what do you mean? using unsafePerformIO unsafely leads to skynet or something? :p
20:16:14 <ddarius> turiya: Is malloc referentially transparent?
20:16:23 <jmcarthur> well.. it's allowed to involved the world in unobservable ways
20:16:23 <jmcarthur> *involve
20:16:26 <kmc> turiya, what do you do with that pointer?
20:16:27 <kmc> it's definitely unsafe to just return the pointer
20:16:31 <ivanm> lispy1: usually, give up and just use 1
20:16:33 <jmcarthur> lispy1: CPP?
20:16:34 <kmc> but it's safe to do { x <- malloc; poke x 3; y <- peek x; free x }
20:16:39 <turiya> ddarius: i dont think so
20:16:53 <portnov> @djinn (s -> a -> a) -> (a -> b -> b) -> (b -> a) -> (s -> b -> b)
20:16:53 <lambdabot> f _ a b _ c = a (b c) c
20:16:54 <ddarius> turiya: Then the answer is "no."
20:17:06 <kmc> ivanm, yep.  violating memory safety => program is totally nondeterministic
20:17:07 <kmc> it might format your home directory or send porn to your grandma
20:17:23 <Axman6> kmc: malloc can return null, so how is that safe?
20:17:28 * ivanm wonders how unsafePerformIO is implemented that it might do that
20:17:32 <dankna> unsafePornToGrandma :: Porn -> IO ()
20:17:36 <ClaudiusMaximus> > properFraction (7%3)
20:17:38 <lambdabot>   (2,1 % 3)
20:17:42 <kmc> true Axman6
20:17:52 <jmcarthur> dankna: actually it's *really* unsafe if it pretends to be a pure function
20:17:53 <jmcarthur> porn, as we know, is not pure
20:17:55 <ClaudiusMaximus> > properFraction (negate $ 7%3)
20:17:55 <lambdabot>   (-2,(-1) % 3)
20:18:07 <ivanm> dankna: I'm guessing the IO also hides a call to a PRNG to choose which grandma if both of yours are still alive?
20:18:32 <lispy1> ivanm: how do you know which version you're getting via CPP?  You set something up in the .cabal file?
20:18:47 <ivanm> lispy1: I think that's the usual way, yeah
20:18:58 <ivanm> what are you wanting to do?
20:19:03 <ivanm> mtl 1 and 2 support or something?
20:19:34 <dankna> jmc: true...
20:19:45 <dankna> ivanm: haha yes, yes it does
20:20:17 <lispy1> ivanm: yeah
20:20:35 <ivanm> lispy1: avoid the problem: use monads-tf instead! :p
20:21:20 <lispy1> ivanm: ah is that in the platform now?
20:21:25 <ivanm> nope
20:21:48 <ivanm> but if you care about platform compatability, only one version of mtl will be in there AFAIK...
20:23:07 <lispy1> Well, I wanted for people to be able to use either ghc7 or stick to the platform
20:23:17 <lispy1> so that's why I had hopped to support both mtl 1 and 2
20:23:26 <lispy1> But, this damned State constructor...
20:24:43 <ivanm> well, people can always install mtl-2 on their platform installs, right?
20:24:58 <ivanm> I mean, isn't that the whole point of cabal-install being part of the platform?
20:25:35 <lispy1> dumping minimum versions of things that darcs depends on is risky business
20:25:42 <lispy1> That's really the bottom line
20:26:20 <ivanm> ahhhh, for darcs
20:27:27 <turiya> as malloc is not referentially transparent, any C function which does not free memory created by malloc is unsafe?
20:31:42 <mm_freak_> turiya: if it created itself, yes
20:32:11 <Cale> turiya: yeah, unless you additionally were to somehow use ForeignPtr finalizers to transparently free that memory
20:34:36 <turiya> Cale: if i add a finalizer then is the code safe?
20:35:01 <jmcarthur> turiya: not necessarily
20:35:09 <Cale> turiya: But possibly :)
20:35:30 <jmcarthur> turiya: if you were to just use malloc to get a Ptr and then stick a finalizer on it and return the Ptr through unsafePerformIO, then the function is not RT
20:35:48 <jmcarthur> turiya: because you won't necessarily get the same Ptr each time
20:36:07 <Cale> Obviously you'll want to be wrapping these things up in newtypes.
20:36:29 <Cale> The usual trick is to define things like   data MyObject = MyObject (Ptr MyObject)
20:36:40 <Cale> and then hide the data constructor
20:36:47 <Cale> er, oops, that should be newtype
20:37:11 <Cale> It's recursive, but the type parameter to Ptr is a phantom anyway
20:37:26 <NickNerf> is haskell.org kaputt ?
20:37:35 <lispy1> NickNerf: yes
20:37:36 <ivanm> yes
20:37:36 <Cale> yes
20:37:38 <NickNerf> oh ok
20:37:43 <ivanm> @quote stereo
20:37:44 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:38:24 <djahandarie> @quote metastereo
20:38:34 <lispy1> ?botsnack
20:38:55 --- mode: ChanServ set +o monochrom
20:39:05 --- topic: set to '["haskell.org is down", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by monochrom
20:39:06 <Cale> Do we know why it's down yet?
20:39:16 <ivanm> monochrom: I bet that that won't work...
20:39:19 <djahandarie> monochrom, brilliant
20:39:24 --- mode: monochrom set -o monochrom
20:39:35 <Pseudonym> Down and out. I don't like the sound of that.
20:39:41 <monochrom> best effort
20:39:43 --- mode: ChanServ set +o Cale
20:39:50 <lars9> @src mplus
20:39:53 --- topic: set to '["haskell.org is down, but you won't read this unless we point it out", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.or' by Cale
20:39:59 <Cale> aww
20:40:02 <ivanm> Cale: much better!
20:40:03 <copumpkin> @remember lambdabot omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:40:03 <copumpkin> :(
20:40:04 <Cale> long topic is long
20:40:05 <monochrom> hahaha
20:40:15 <lars9> @src msum
20:40:19 <turiya> Cale: data MyObject = MyObject (Ptr MyObject), what does this mean?
20:40:32 <lars9> lambdabot: are you afk?
20:40:48 <djahandarie> haskell.org and lambdabot are down!
20:40:53 <copumpkin> @botsmack
20:41:07 <Cale> turiya: I made a mistake, it should be newtype in place of data. It's a newtype wrapper around the pointer type for pointers to values of your C data structure being allocated.
20:41:18 <monochrom> the internet is disappearing
20:41:19 <ivanm> djahandarie: coincidence? I think not!
20:41:23 <Cale> turiya: Of course, it works just as well with ForeignPtr
20:41:25 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:41:25 <lambdabot> :)
20:41:26 <lambdabot> Source not found. My pet ferret can type better than you!
20:41:26 <lambdabot> It is stored.
20:41:26 <lambdabot> msum =  foldr mplus mzero
20:41:27 <lambdabot> :)
20:41:47 <monochrom> LHC's black hole trick works. It's slowly eating the internet.
20:41:53 <copumpkin> @quote lambdabot
20:41:53 <lambdabot> lambdabot says: No Result Found.
20:42:04 <djahandarie> Apparently only one metastereo quote is going to be remembered
20:42:11 <ivanm> copumpkin: great, lambdabot know has a quote about herself!
20:42:15 <ivanm> @quote meta-stereo
20:42:15 <lambdabot> No quotes match. That's something I cannot allow to happen.
20:42:18 <copumpkin> :(
20:42:18 <ivanm> @quote metastereo
20:42:19 <lambdabot> lambdabot says: omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:42:22 <lars9> what's the function of: f :: [m a] -> m a; f [m1, m2, m3] x = return x >>= m1 >>= m2 >>= m3 ?
20:42:23 <ivanm> @quote stereo
20:42:23 <lambdabot> lambdabot says: omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:42:25 <ivanm> @quote stereo
20:42:25 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
20:42:27 <ivanm> @quote stereo
20:42:27 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
20:42:29 <ivanm> @quote stereo
20:42:29 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
20:42:36 <copumpkin> there we go
20:42:37 <ivanm> djahandarie: huh, a whole bunch of them disappeared...
20:42:53 <monochrom> the black hole ate those quotes too
20:43:13 <Cale> turiya: This is useful when you want a type whose internal representation is a pointer to some C value. It looks recursive, but it doesn't actually matter that it's recursive, since Ptr/ForeignPtr don't actually hold any values of the type given by the parameter
20:43:34 <ivanm> monochrom: obviously
20:43:47 --- topic: set to '["haskell.org is down, but you won't read this", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Cale
20:43:53 --- mode: Cale set -o Cale
20:44:15 <Cale> had to shorten it for the rest of the topic to fit :)
20:44:42 <lars9> what's the function f in: f [m1, m2, m3] x = return x >>= m1 >>= m2 >>= m3 ?
20:44:46 <shachaf> Cale: But now it's no longer true. :-(
20:44:48 <lars9> shortened
20:44:53 <djahandarie> Kind of moot for haskell.org to be linked as like the 7th item in that list
20:44:56 <mightybyte> Can anyone here help me understand the nuances of building a monad stack with ContT, StateT, and IO?
20:45:57 <kmc> @unmtl ContT r (StateT s IO) a
20:45:57 <lambdabot> (a -> s -> IO (r, s)) -> s -> IO (r, s)
20:46:23 <Cale> djahandarie: Yeah, though we might want to preserve that link for when haskell.org comes back
20:46:26 <mightybyte> Specifically I'm trying to understand the differences between the stack "ContT StateT IO" and "StateT ContT IO"
20:46:32 <Axman6> lambdabot: well, that type isn't correct for what you've written
20:46:38 <kmc> @unmtl StateT s (ContT r IO) a
20:46:38 <lambdabot> s -> (a -> s -> IO r) -> IO r
20:47:07 <djahandarie> Cale, oh yeah, even more moot now that it is down. But I was just talking about how it is odd that it is all the way at the end of the topic. :P
20:47:51 <Axman6> :t \x ms -> foldr (=<<) (return x) (reverse ms)
20:47:52 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
20:47:58 <mightybyte> kmc: Hmmm, that will take a bit to digest. :)
20:48:02 <Cale> oh, I missed that, the plain link to haskell.org
20:48:06 --- mode: ChanServ set +o Cale
20:48:08 <ClaudiusMaximus> woop, my code seems to work :) http://hpaste.org/41761/angled_internal_addresses ( based on http://arxiv.org/abs/math/9411238v2 )
20:48:12 <djahandarie> Exactly ;)
20:48:22 <Axman6> :t \x ms -> foldl (>>=) (return x) ms
20:48:23 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
20:48:35 --- topic: set to '["haskell.org is down, but you won't read this unless we point it out", "GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]' by Cale
20:48:41 --- mode: Cale set -o Cale
20:48:45 <Cale> that works :)
20:51:10 <turiya> the biggest problem is not knowing what the problem is.. :)
20:51:26 * mightybyte wonders if it would be easier to just simulate the StateT part of that with IORefs in IO
20:51:35 <jmcarthur> never!
20:51:41 <lars9> Axman6: so it's not an existing function?
20:51:50 <Causalien> Question... since I am still a newbie and do not fully understand the capabilities of Haskell. How hard will it be to do a fourier transform on a set of data?
20:51:58 <Axman6> lars9: not that i know of
20:52:31 <lars9> Axman6: i see, thanks
20:53:05 <mightybyte> @unmtl StateT s m a
20:53:05 <lambdabot> s -> m (a, s)
20:53:40 <lars9> @unmtl MaybeT IO String
20:53:40 <lambdabot> IO (Maybe String)
20:53:46 <copumpkin> Causalien: pretty easy, depending on what format your data's in to begin with
20:54:19 <djahandarie> Causalien, do you want it to run blazingly fast?
20:54:24 <Causalien> Judging from what I know. I can just plug the FFT formula into the comprehension right?
20:54:36 <Causalien> djahandarie: yes
20:54:36 <kmc> there might be a library for it already
20:54:39 <kmc> i know there's bindings to fftw
20:54:59 <Cale> vector-fftw
20:55:05 <Causalien> copumpkin what do you mean by depending on data's format though?
20:55:12 <djahandarie> Causalien, then you're best off using a binding to something or just not using Haskell. Writing it yourself will require delving into all sorts of nuances about Haskell
20:55:18 <mightybyte> @unmtl StateT s (ContT r IO) a
20:55:18 <lambdabot> s -> (a -> s -> IO r) -> IO r
20:55:26 <Cale> Well, that is, if you want it to be fast
20:55:36 <mightybyte> Why aren't there any tuples in that lambdabot derivation?
20:55:37 <djahandarie> Yes. If you want it to be fast.
20:55:44 <copumpkin> @hackage pure-fft
20:55:44 <lambdabot> http://hackage.haskell.org/package/pure-fft
20:55:58 <Cale> If you're just doing small FFTs and you don't care, you can write them in Haskell naively, and they'll work.
20:56:00 <copumpkin> that's a simple implementation
20:56:05 <copumpkin> gives you a naive O(n^2) and a simple O(n log n)
20:56:13 <copumpkin> otherwise, bindings to fftw
20:56:42 <Axman6> mmorrow disappeared before he added my patches to pure-fft :(
20:56:53 <djahandarie> Does that package not have a new maintainer?
20:57:05 <djahandarie> That should be fixed
20:57:07 <mightybyte> @unMTL StateT s m
20:57:07 <lambdabot> Unknown command, try @list
20:57:07 <Cale> Axman6: I think you're allowed to just upload a new version even if you're not the maintainer.
20:57:27 <djahandarie> Or copumpkin or Cale should call mmorrow and see what's up ;)
20:57:28 <Axman6> Cale: i may end up doing that at some point
20:57:52 <Cale> mmorrow hasn't been seen in a long time, I think it's safe to take over his projects if you want :)
20:58:07 <Cale> preflex: seen mmorrow
20:58:08 <preflex>  mmorrow was last seen on #ghc 310 days, 2 hours and 20 seconds ago, saying: * mmorrow is rtfm'ing
20:58:14 <lars9> is (->r) a monad?
20:58:27 <Cale> lars9: no, but (->) r is
20:58:40 <Cale> (which if it were written as a section, would be (r ->)
20:58:45 <Cale> )
20:58:52 <djahandarie> It'd be nice if we could write it as a section
20:59:27 <lars9> Cale: i see, thanks
20:59:46 <lars9> Cale: and r -> is also an arrow right?
20:59:53 <Cale> (->) on its own is an Arrow
21:00:00 <lars9> oh
21:01:10 <djahandarie> :k Arrow
21:01:11 <lambdabot> Class `Arrow' used as a type
21:01:23 <djahandarie> lol
21:01:28 <Axman6> @instances Arrow
21:01:29 <lambdabot> (->), Kleisli m
21:01:35 <Axman6> @src Arrow
21:01:35 <lambdabot> class Arrow a where
21:01:35 <lambdabot>     arr, pure   :: (b -> c) -> a b c
21:01:35 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
21:01:35 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
21:01:35 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
21:01:37 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
21:01:39 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
21:01:51 <lispy1> ?vixen feeling chatty?
21:01:51 <lambdabot> yes
21:01:55 <Axman6> @src Kleisli
21:01:56 <lambdabot> Source not found. Where did you learn to type?
21:01:57 <lispy1> I could tell...
21:02:17 <Axman6> @src Kleisli (>>>)
21:02:17 <lambdabot> Source not found. Just try something else.
21:02:20 <Axman6> :(
21:02:23 <djahandarie> I thought the instance was Monad m => (Kleisli m) ?
21:02:37 <djahandarie> Wouldn't make much sense otherwise
21:03:53 <jekor> Is there a way to pass a computation in some combined monad (say, ReaderT IO) to a function that accepts IO a (such as bracketOnError)?
21:04:20 <lispy1> jekor: what do you mean combined?
21:04:25 <lispy1> on, n/m
21:04:33 <lispy1> I misread your question
21:04:59 <lispy1> ?src bracketOnError
21:04:59 <lambdabot> Source not found. There are some things that I just don't know.
21:05:06 <lispy1> ?hoogle bracketOnError
21:05:07 <lambdabot> Control.Exception bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:05:07 <lambdabot> Control.OldException bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:05:07 <lambdabot> Control.Exception.Base bracketOnError :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
21:05:12 <Axman6> @hoogle Kleisli
21:05:12 <lambdabot> Control.Arrow newtype Kleisli m a b
21:05:13 <lambdabot> Control.Arrow Kleisli :: (a -> m b) -> Kleisli m a b
21:05:13 <lambdabot> Control.Arrow runKleisli :: Kleisli m a b -> a -> m b
21:05:22 <kmc> jekor, not without using runReaderT or similar
21:05:32 <kmc> i think there was a library to wrap up such tricks
21:05:34 <kmc> but i forgot the name :/
21:05:35 <monochrom> you may use something like http://hackage.haskell.org/package/monad-peel
21:05:35 <mtnviewmark> SF Bay Area Hackathon advance notice:  http://wiki.hackerdojo.com/w/page/Haskell-Hackathon-2011
21:05:42 <lispy1> jekor: I think you'd need to change the type to say MonadIO instead of IO, but I'm not sure if you can do that with bracket
21:05:49 <jekor> kmc: I suspected as much, just didn't know how to go about it.
21:05:57 <jekor> I will check that link.
21:06:22 <jekor> lispy1: I'm afraid of as much.
21:06:28 <monochrom> there was an older way by way of MonadCatchIO-mtl
21:07:23 <mee> mtnviewmark: cool. You should post that to bahug
21:07:47 <mtnviewmark> ah --- or you can
21:07:50 <mtnviewmark> :-)
21:09:14 <turiya> ByteString's can only be created in IO Monad?
21:09:24 <Axman6> no?
21:09:26 <Axman6> :t pack
21:09:27 <lambdabot> Not in scope: `pack'
21:09:30 <lispy1> jekor: you might take a look at: http://hackage.haskell.org/package/monadIO
21:09:32 <Axman6> :r BS.pack
21:09:36 <Axman6> :t BS.pack
21:09:37 <lambdabot> [Word8] -> BSC.ByteString
21:09:46 <lispy1> jekor: it has monadio versions of many IO things from other libraries
21:12:17 <turiya> Axman6: oh.. i see.. can "pack" be pure as a ByteString contains a Ptr and this Ptr will be different for different calls to "pack"
21:12:36 <Axman6> does the type say it's pure?
21:13:15 <turiya> hmm.. is it not that anything outside IO is pure?
21:13:45 <mtnviewmark> mee: where is bahug's list?
21:13:46 <Axman6> well, the type looks pure to me, i'd suspect it's pure
21:14:31 <djahandarie> mtnviewmark, you and bos should go to BAHUG anyways :)
21:14:46 <mtnviewmark> aren't the meetings always in SF?
21:15:12 <djahandarie> I think so. Too far away?
21:15:28 <mee> mtnviewmark: http://groups.google.com/group/bahaskell
21:17:00 <kmc> turiya, it's semantically pure even though there are hidden details of ByteString which are not
21:17:10 <mee> I'd post but I am a strict follower of lurkerarianism
21:17:11 <kmc> ByteString is one of those libraries which uses unsafePerformIO carefully
21:17:12 <jekor> lispy1: Thanks.
21:17:57 <mtnviewmark> yea- I'm down in Mtn. View - can w/kids - so don't get out on week nights up to SF all that much
21:18:30 <djahandarie> I need to drive over 2 hrs to get to my closest HUG :(
21:18:47 <copumpkin> djahandarie: move to boston!
21:18:50 <lispy1> djahandarie: Sounds like you need a HUG!
21:19:14 <djahandarie> -_-
21:19:23 <mee> it's only 30mi but about 80 minutes to the BAHUG meetings for me
21:19:28 <mtnviewmark> well- I posted to bayfp - but I'm not "joined" to bahug yet.... 
21:20:21 <lispy1> Can you not wrap {- LANGUAGE ... -} inside #if/#endif in GHC?
21:20:45 <kmc> lispy1, new in GHC7 iirc
21:21:02 <djahandarie> Yeah, only in GHC7
21:21:15 <lispy1> So how do you control language flags that are compiler version dependent?
21:21:19 <djahandarie> I remember reading a reddit post about this
21:21:43 <lispy1> #if __GLASGOW_HASKELL__ >= 700
21:21:50 <turiya> kmc, i would like to do something similar (just to understand how it is done carefully), would looking at the source of ByteString help or are there other simpler modules which are written similarly?
21:21:59 <lispy1> I can check for version 7, but then version 6 can't do much about it :(
21:22:46 <kmc> i think it would help; i don't know about a simpler one
21:29:58 <Causalien> r we all redditors?
21:30:20 <Pseudonym> No.
21:30:38 <djahandarie> I don't know if I'd go as far as saying I'm a "redditor", but I do read /r/haskell ...
21:31:20 <copumpkin> r we capable of spelling are?
21:31:35 <Pseudonym> copumpkin, I thought it was a pun on /r/
21:31:43 <kmc> most of reddit makes my head hurt
21:31:53 <djahandarie> /r/ we all reddito/r/s?
21:31:54 <kmc> but /r/haskell is a good link feed with occasional comments
21:32:10 <copumpkin> kmc: you can follow just /r/haskell on twitter, too ;)
21:32:19 <kmc> it has an RSS feed too
21:32:25 * copumpkin tries some more to get more haskellers on twitter
21:32:30 <copumpkin> I was bugging Cale earlier
21:32:37 <kmc> it is lame to wall oneself off into a tiny community of vigorous agreement
21:32:39 <djahandarie> I have an account... but I don't post anything there
21:32:59 <kmc> but proggit is pretty lame too
21:33:12 <Causalien> I read world news on reddit. They are faster than the main media.
21:33:13 <djahandarie> s/post/tweet/
21:33:15 <copumpkin> hey, so is IRC
21:33:19 <copumpkin> plenty of vigorous agreement here
21:33:25 <kmc> yeah
21:33:25 <djahandarie> I agree.
21:33:32 <copumpkin> djahandarie: I agree with your agreement
21:33:41 <kmc> where would i go to discuss programming with a diverse group of people, who aren't idiots or trolls
21:33:44 <djahandarie> Good, because I agree with kmc who also agrees.
21:33:59 <nejucomo> Is haskell.org taking a long time to serve http to anyone else?
21:34:05 <copumpkin> so we agree that we are all in agreement?
21:34:11 <djahandarie> nejucomo, it's down.
21:34:14 <copumpkin> nejucomo: I think everyone agrees that it's down
21:34:18 <djahandarie> :P
21:34:33 <copumpkin> but if you don't
21:34:37 <copumpkin> I think we should agree to disagree
21:34:37 <djahandarie> OBJECTION
21:34:48 <Causalien> So what happened to haskell.org? DDOS?
21:35:05 <djahandarie> Causalien, highly doubt that... just shoddy University servers at Yale.
21:35:17 <djahandarie> It's moving to a commerical server soon.
21:35:43 <mee> kmc: work?
21:35:47 <ClaudiusMaximus> has anyone done some integration between ghci and LaTeX?
21:35:49 <lars9> hey, what syntax sugars does haskell have? do, proc ?
21:35:49 <Causalien> Oh. Going mainstream?
21:36:00 <copumpkin> rec
21:36:07 <lars9> ClaudiusMaximus: why do you want that?
21:36:09 <copumpkin> list comprehensions
21:36:22 <djahandarie> Causalien, hah. I'm not sure how the type of server you are hosted on makes a language mainstream or not. :P
21:36:28 <lars9> copumpkin: isn't list a function?
21:36:36 <copumpkin> ?
21:36:41 <djahandarie> But I guess it does signal the direction Haskell is moving.
21:36:42 <lars9> [,]
21:36:52 <copumpkin> no
21:36:54 <ClaudiusMaximus> lars9: i have some code that outputs latex source (equation), would be nice to get immediate feedback
21:37:01 <djahandarie> (:) is a function
21:37:03 <djahandarie> :t (:)
21:37:04 <lambdabot> forall a. a -> [a] -> [a]
21:37:07 <Causalien> Well, it's a sign. It means the community is fed up with shoddy servers = enough donations to buy a commercial server.
21:37:18 <lars9> tuple is a function right?
21:37:20 <lars9> (,)
21:37:23 <djahandarie> Yes.
21:37:26 <lars9> :t ((,))
21:37:26 <lambdabot> forall a b. a -> b -> (a, b)
21:37:28 <djahandarie> Lists are unrelated to tuples though.
21:37:35 <lars9> :t ([,])
21:37:36 <lambdabot> parse error on input `,'
21:37:49 <djahandarie> [a,b,c] is just sugar for a:b:c:[]
21:37:58 <djahandarie> The comma is not evaluated as a function.
21:39:32 <lars9> :t ($)
21:39:33 <lambdabot> forall a b. (a -> b) -> a -> b
21:42:01 <lars9> ClaudiusMaximus: rawSystem :D
21:42:22 <lars9> :t Monad
21:42:23 <lambdabot> Not in scope: data constructor `Monad'
21:42:27 <lars9> :t Monad a
21:42:28 <lambdabot> Not in scope: data constructor `Monad'
21:42:37 <lars9> :k Monad
21:42:38 <lambdabot> Class `Monad' used as a type
21:46:40 <lars9>  /sudo halt
21:46:59 <lars9> this channel is halting, bye bye friends
21:47:26 <nejucomo> Hrmâ€¦  So with haskell.org down I can't find the packaing tutorial.  I see the API docs for Distribution, but that's a bit heavy.
21:47:56 <nejucomo> I have a library under ./src in a repository.  cabal build can't find the library.  How do I tell it to look in ./src ?
21:48:23 <nejucomo> I cp'd a foo.cabal from elsewhere and altered by best guesses.
21:50:51 <nejucomo> I see Distribution.PackageDescription (BuildInfo { hsSourceDirs }) -now to determine the .cabal syntax for that option.
21:51:32 <Causalien> I have a headache from reading the tutorial. Goodnight
21:51:39 <monochrom> I have a local copy of cabal docs, as in format of project.cabal. I'll look. you may have a local copy too.
21:52:43 <monochrom> hs-source-dirs: src
21:52:56 <nejucomo> I have a local copy of the haddock source code which tells me the API for packaging, but I haven't found a description of the .cabal format.
21:52:57 <nejucomo> Thanks!
21:53:18 <nejucomo> Is that inside "library" or outside?
21:53:23 <monochrom> try something like file:///usr/local/share/doc/ghc/html/Cabal/authors.html
21:53:34 <monochrom> inside "library"
21:54:21 <mtnviewmark> I can never guess which aspect of cabal is implemented in the cabal package vs. in the cabal-install package
21:56:51 <jekor> monad-peel is cool, and I've changed my withTransaction function to be (MonadIO m, MonadPeelIO m) => ... and that works. Now I'm lost on how to make my transformed monad (AppT (ReaderT AppEnv (CGIT IO) a)) an instance of MonadPeelIO (deriving did not work). Any suggestions on where to look?
21:57:51 <monochrom> I haven't really studied monad-peel, I have only heard that it's great.
21:58:50 <monochrom> But one would have to carefully study AppT and CGIT to see how to peel them.
21:59:56 <jekor> That's what I was afraid of ;)
22:01:31 <tianyi> new-www.haskell.org is down too ... Is there any other place I can read the haskellwiki? Thanks.
22:01:59 <monochrom> eww. google cache or some internet archive but I forgot its name.
22:02:45 <osaunders> What's the problem with it exactly?
22:02:56 <monochrom> unknown problem
22:02:58 <osaunders> It has been down a lot recently.
22:03:39 <djahandarie> No idea why new-www is down. It shouldn't be.
22:03:54 <djahandarie> We're paying for that one so we should be able to yell at someone.
22:09:13 <lars9> if we define return and >>= for Maybe without mentioning instance of Monad, will Maybe a still be instance of Monad?
22:09:56 <Axman6> no
22:10:25 <Axman6> return and (>>=) can ony be defined inside an instance declaration for a Monad instance
22:10:30 <lars9> so just two more function defined, nothing else happens?
22:11:00 <monochrom> you will get a syntax error
22:11:21 <lars9> in ghci, i let return = id, it works
22:11:29 <monochrom> err, I'm wrong.
22:12:50 <monochrom> when you actually use them, you get an ambiguity error.
22:13:35 <osaunders> > let return :: a -> Maybe a; return = Just in return 3 >>= Just
22:13:36 <lambdabot>   Just 3
22:14:06 <lars9> monochrom: actually, no error...
22:14:13 <lars9> return 3 outputs 3
22:14:44 <monochrom> If you use ghci's let, no error, sure. If you enter it into a file, top level definition, different story.
22:14:52 <applicative> ClaudiusMaximus, there is always the expedient of math2png = ("http://chart.apis.google.com/chart?cht=" ++) . Network.Http.urlEncode 
22:16:16 <osaunders> I'm establishing a reputation among my peers as being Haskell obsessed.
22:16:34 <mtnviewmark> oh - I'm *so* guilty of that
22:16:52 <Zeiris> Has anyone used the timeplot library?
22:17:13 <osaunders> preflex: seen anyone
22:17:13 <preflex>  anyone was last seen on #haskell 175 days, 6 hours, 6 minutes and 24 seconds ago, saying: The thing that disappoints me the most about TH, is that it adds to the mental parsing I have to do, without adding to the parsing I can make the computer do. :\
22:18:53 <turiya> a very basic question: in C "char h = 2" means create one byte of memory and write the value of 2, what would "h = 2" do in Haskell?
22:20:03 <mtnviewmark> well, that isn't quite what that means in C .... but in Haskell, "h = 2" simply says that "h" is a name for the value '2"
22:20:07 <osaunders> turiya: Precisely nothing
22:20:53 <osaunders> Haskell is lazy. It won't evaluate the value of h unless you use it someway.
22:20:58 <osaunders> *somewhere
22:21:03 <turiya> mtnviewmark: does it do something else in C? I am not aware..
22:21:34 <monochrom> you can still say "create memory and store something about 2 there", but it is not necessarily just 1 byte and it is not necessarily directly 2.
22:21:52 <monochrom> and it is certainly not mutable in the C sense.
22:21:53 <Zeiris> Are there any mirrors of the Haskell wiki? Google cache/wayback machine haven't worked out.
22:21:57 <osaunders> I don't think it "creates" the memory in C unless you use malloc().
22:22:09 <mtnviewmark> well, it depends deeply on where that construct occurs. At top level, say, it allocates one byte of global memory. As a local variable, it arranges for one byte of space on the stack.
22:22:54 <mtnviewmark> but, true, I was being rhetorical to bring up the subtlety in the C semantic
22:23:15 <turiya> the names and values are stored in a look-up table?
22:23:18 <monochrom> then again of course I use "create memory" lousily. no program can create memory, ever. that's the job of RAM factories.
22:24:18 * monochrom builds website "moar-memory.org": "download enlarge.exe to create more memory! download now!"
22:24:37 <shachaf> monochrom: Too late: http://www.downloadmoreram.com/
22:24:41 <lars9> mtnviewmark: h = 2 is not a "name for value 2"
22:24:46 <mtnviewmark> turiya - that would be an implementation detail - but in general, no
22:24:47 <osaunders> But the question indicates a lack of understanding of how Haskell works. Lines of Haskell don't do things per se. Imperative languages set memory, purely functional ones don't predictably: purely functional languages only use memory incidentally where it is more explicit in an imperative language.
22:25:00 <lars9> mtnviewmark: it's a function, when evaluated, returns 2
22:25:22 <djahandarie> lars9, values aren't functions
22:25:37 <monochrom> I am wordless. :)
22:25:57 <djahandarie> A function is a value with an arrow (->) in its type.
22:26:20 <shachaf> djahandarie: Not just with (->) in its type, but at the top level, as the type constructor. :-)
22:26:21 <monochrom> hahaha oh what fun :)
22:26:31 <mtnviewmark> lars9 - for nullary functions, with constant RHS, amounts to the same thing, no?
22:26:31 * shachaf joins the pedants.
22:26:33 <lars9> :t (f = 2)
22:26:34 <lambdabot> parse error on input `='
22:26:48 * monochrom goes on to next project "moar-cores.org"
22:26:48 <shachaf> @ty let f = 2 in f
22:26:50 <lambdabot> forall t. (Num t) => t
22:27:05 <ClaudiusMaximus> applicative: hmm, interesting - since i eventually aim to output JSON for use in Javascript InfoVis Toolkit, maybe that will save some rendering to png...
22:27:08 <monochrom> "forkIO creates a core to run this IO recipe..."
22:27:14 <mtnviewmark> and, I think, given the level of the question, my answer was probably appropriate
22:27:20 <shachaf> monochrom: Can you make "moar-bandwidth.org" too?
22:27:31 <shachaf> monochrom: That way it can speed up as your run it again and again.
22:27:38 <monochrom> I don't know how to do that yet.
22:27:48 <monochrom> oh, your idea is great!
22:28:06 <lars9> djahandarie: mtnviewmark: hmm... am i wrong?
22:28:09 <ab9rf> haskell.org still DOA?
22:28:11 <djahandarie> lars9, yes.
22:28:26 <lars9> hey folks, is f in (f = 2) a function?
22:28:35 <osaunders> no
22:28:41 <monochrom> yea haskell.org is down, new server also down, we are doomed
22:28:42 <shachaf> lars9: No (->) => no function. It's just a value.
22:28:44 <djahandarie> :t let f = 2 in f
22:28:44 <lambdabot> forall t. (Num t) => t
22:28:54 <djahandarie> :t let f = (2 :: Integer) in f
22:28:55 <lambdabot> Integer
22:28:56 <ab9rf> a function is not going to be equal to 2, so no
22:29:02 <shachaf> lars9: Before a value is evaluated, it's a thunk, but that's irrelevant.
22:29:28 <osaunders> lars9: but Â«let f = x in fÂ» could be
22:29:36 <monochrom> safer to say: (f = True), f is not a function
22:29:52 <shachaf> monochrom: Oh, yes. That's true.
22:29:55 <Cale> lars9: In the bot, there's an instance of Num for functions which allows you to use numeric literals as constant functions
22:29:57 <shachaf> ab9rf: If "DOA" means "dead on arrival", then no -- it's not even arriving.
22:30:02 <shachaf> ab9rf: See topic. :-)
22:30:02 <Cale> lars9: (and add functions etc.)
22:30:05 <ab9rf> shachaf: heh
22:30:06 <endojelly> this looks like a job for... THE COMMITTEE!
22:30:21 <Cale> lars9: But 2 :: Integer, is not a function.
22:30:26 <ab9rf> shachaf: wow, there is information in the /topic.  whodathunkit :)
22:30:27 <monochrom> il Committeeaire
22:30:28 <lars9> l = [1..100]; f = sum l; so f is still a value?
22:30:30 <endojelly> which I think is a great idea. I'm totally swamped with uni, but if anyone wants me, I'll apply for it next year.
22:30:40 <djahandarie> Cale, I imagine that detail could be brought up when someone pulls that example up. :P
22:30:45 <Cale> yeah, (though functions are values too :)
22:30:55 <lars9> :t getLine
22:30:56 <lambdabot> IO String
22:31:05 * osaunders is ill
22:31:26 <Cale> lars9: We call a value a function when its type is of the form A -> B for some types A and B
22:31:28 <lars9> :t IO
22:31:29 <lambdabot> Not in scope: data constructor `IO'
22:31:39 <monochrom> perhaps the Committee is already working on it.
22:31:45 <Cale> (and not otherwise)
22:31:46 <lars9> Cale: so getLine is also a value?
22:32:00 <djahandarie> Yes
22:32:01 <ab9rf> this begs the question of what a 'value' is
22:32:02 <Cale> yes, but being a value doesn't mean that something isn't a function
22:32:11 <Cale> all functions are values
22:32:13 <ab9rf> not that i really care right now :)
22:32:13 <monochrom> value is very general. a function is a value too, just not always vice versa
22:32:24 <djahandarie> Though the IO a value is more subtle
22:32:53 <lars9> omg, i've been learning haskell for a while, but this is the first time to know the concept of value
22:33:01 <ab9rf> lars9: hehe
22:33:16 <lars9> i knew typeclass, type, function
22:33:31 <osaunders> If you can pass it to a function, it's a value.
22:33:38 <djahandarie> I'd consider anything that can has evaluation to be left a function. So Â«IO aÂ» wouldn't be a function by my book (since that only has execution left).
22:33:51 * shachaf makes instance Num (a -> [a]) where fromInteger = genericReplicate
22:33:54 <monochrom> you care about "value" when you want to say "as opposed to type, kind, other declarations, import statements, comments..."
22:34:13 <monochrom> this is why you haven't needed it.
22:34:15 <djahandarie> shachaf, don't do that with the a -> b instance lying around ;)
22:35:05 <shachaf> djahandarie: I only regret that I have but one instance to give to this typeclass.
22:35:49 <shachaf> (It would be really nice if there was some way to have multiple instances for a typeclass without going through a newtype.)
22:35:58 <ab9rf> haskell.org must not be totally down, i can still run cabal update :)
22:36:10 <djahandarie> shachaf, overlapping instances?
22:36:12 <shachaf> ab9rf: That's hackage.haskell.org -- different server.
22:36:17 <monochrom> cabal update goes to hackage.haskell.org, different server
22:36:26 <ab9rf> shachaf: obviously
22:36:36 <lars9> what webserver does haskell.org use?
22:36:40 <monochrom> the world would really end when hackage went down too
22:36:49 <djahandarie> monochrom, shhhh!!!
22:36:57 <ab9rf> at least it's not a DNS foop
22:37:01 <djahandarie> lars9, apache I'm pretty sure.
22:37:02 <shachaf> djahandarie: Well, I mean e.g. having both Sum and Product without specialized newtypes for them.
22:37:19 <shachaf> Alternatively, if there was a more-lightweight way to do newtypes, so they would be less painful and we could use correct types everywhere.
22:37:25 <monochrom> don't worry, hackage will not go down until the monks finish playing the Fibonacci Tower of Hanoi!
22:37:36 <lars9> djahandarie: hmmm, so it's dangerous to argue with java guys
22:38:08 <ab9rf> lars9: this comes as news to you?
22:38:10 <djahandarie> shachaf, there isn't much of a sensible way to do it without newtypes I don't think
22:38:13 <djahandarie> lars9, huh?
22:38:36 <lars9> ab9rf: indeed
22:38:37 <osaunders> djahandarie: Don't have a type class, just have functions.
22:38:39 <monochrom> arguing is never dangerous. oh wait, you're in Hong Kong...
22:38:59 <ab9rf> lars9: i'm a java programmer and even i know not to argue with the java zealots :)
22:39:02 <djahandarie> osaunders, I imagine the point was to make a monoid instance
22:39:30 <shachaf> ab9rf: There are Java zealots?
22:39:45 <monochrom> but I never argue. I just show-tell.
22:40:08 <ab9rf> shachaf: for any thing you can name, there are zealots for it.  including java. :)
22:40:28 <osaunders> ab9rf: My poop?
22:40:42 <ab9rf> osaunders: you do not want to know
22:40:43 <djahandarie> monochrom, I'd like to argue that you do argue.
22:40:46 <monochrom> Your poop is the best programming language ever!
22:40:58 <osaunders> lol
22:40:59 <lars9> for zealots, the best fightback is to be a lurker.
22:41:26 <osaunders> Or a hoard of zerglings.
22:44:16 <lars9> osaunders: i thought my words were encrypted..
22:47:55 <ClaudiusMaximus> applicative: ah, there's a maximum formula length of 200 characters..
22:49:56 <kmc> anyone write any cool haskell lately
22:51:07 <descender> is haskell.org down? I have difficulties accessing the website
22:52:36 <kmc> yeah descender
22:55:46 <orclev> ok, I'm trying to follow a tutorial and I'm running into a problem... the code as given is attempting to perform a mod on a Float value, which then complains of no instance Integral Float... is there a switch I can enable to fix this, or possible a package I can import?
22:56:11 <shachaf> kmc: I solved Project Euler problem #67 in Haskell and it was way shorter and nicer than my previous imperative solution. That was kind of neat.
22:56:59 <ddilinger> i did #67 a couple days ago, it was very clean and simple
22:57:19 <ddilinger> very nice in haskell 
22:58:54 <ddilinger> orclev: i'm just learning haskell, but http://www.haskell.org/haskellwiki/Converting_numbers is very usefull for that
22:59:08 <dskippy> I just did #286 but wrote it in Scheme because I couldn't figure out how to memoize. Anyone know then best way to memoize functions with arguments that can't be used as list indexes?
22:59:49 <dskippy> I know the trick of defining an infinite list of the function arugments, which is really nice for some functions. But I needed arbitrary data memoized.
23:00:14 <shachaf> dskippy: Hackage has a few packages for memoization.
23:00:52 <dskippy> shachaf: Do you recommend one?
23:02:23 <shachaf> dskippy: Nope -- I don't know much about them.
23:02:26 <mtnviewmark> my Haskell solution #67 was six lines long - one of which was a type signature, and one of which was for unit testing (all my euler soltuios have unit tests!)
23:03:01 <shachaf> mtnviewmark: Does that include reading the input from the file?
23:03:06 <mtnviewmark> yup
23:03:13 <shachaf> mtnviewmark: The actual code is one line. :-)
23:04:44 <newsham> http://conal.net/blog/tag/memoization/
23:05:43 <newsham> (for dskippy)
23:05:58 <orclev> hmm... anyone else having problems loading haskell.org?
23:06:05 <c_wraith> yes, it's down
23:06:10 * shachaf points out the topic.
23:06:23 <Jonno_FTW> heheeh
23:06:25 <orclev> ah... I see
23:06:27 <c_wraith> wow.  that first entry in the topic is prophetic
23:06:58 * orclev would have read it if he hadn't been lurking in here for the last couple days...
23:07:15 <c_wraith> I never read the topic when I join channels anyway
23:07:29 <orclev> I usually read it as it scrolls past
23:07:36 <shachaf> The real question is why new-www.haskell.org is down.
23:08:19 <c_wraith> because it's a holiday week in the US, and no one who could fix it cares this week :)
23:08:26 <orclev> anyone know of an instance of mod that works on instances of Floating?
23:09:14 <sinelaw_> haskell.org still down!
23:09:14 <shachaf> orclev: Data.Fixed.mod'
23:09:17 <sinelaw_> bah
23:09:27 <sinelaw_> is there a mirror?
23:09:33 <ddilinger> shachaf: my problem 67 was slightly longer, 9 lines :)  but basically a collapse function that took a top and bottom row, and  a foldl1 collapse $ reverse triangle
23:09:33 <sinelaw_> for wiki or ghc docs?
23:09:42 <orclev> shachaf: thanks
23:09:50 <sinelaw_> and I want to implement an instance for (a,b)
23:09:53 <sinelaw_> instance (DSLType a, DSLType b) => DSLType (a,b) where showType _ = ... how to access the types of a and b?
23:13:51 <c_wraith> sinelaw_, that instance says you're declaring the instance for any pair of (a, b) that satisfies the head.  that is, you can't access the exact types
23:14:20 <sinelaw_> c_wraith, yeah, so which other way is there to do it
23:14:32 <sinelaw_> i want to read about Typeable but nothing seems to be online
23:14:40 <sinelaw_> haskell.org is as dead as a (dead) horse
23:14:47 <c_wraith> yikes.  Typeable is probably not what you want
23:15:18 <sinelaw_> c_wraith, doesn't typeable allow me to do something with type info at runtime?
23:15:31 <sinelaw_> i know next to nothing about it, due to lack of docs
23:15:35 <c_wraith> Yes, but my point was more that you probably don't want to use it.
23:15:52 <c_wraith> You probably want to find a compile-time solution
23:16:04 <sinelaw_> so how can I do this
23:16:24 <c_wraith> possibly involving adding another class constraint on a or b to give you information needed to vary behavior by that other class
23:16:40 <c_wraith> Or possibly involving the FlexibleInstances extension
23:17:19 <McManiaC> haskell.org down?
23:17:22 <sinelaw_> the first possibility seems to imply i'll need to write a type class for each different primitive type
23:17:27 <c_wraith> McManiaC, see topic
23:17:29 <orclev> reflection seems to be mostly useless in haskell, although it's nearly indispensible in most other languages... I'm still trying to figure out why this is so... the strong type system?
23:17:34 <sinelaw_> and then derive instances for the tuples of each combination thereof
23:17:48 <McManiaC> c_wraith: topic is right :>
23:18:03 <c_wraith> sinelaw_, typeable would force you do do almost the same thing.  you'd still need to dispatch based on the result of it.
23:18:22 <sinelaw_> ugh
23:18:24 <sinelaw_> horrible
23:18:49 <sinelaw_> i wish there was some type-level info available during compilation
23:19:10 <orclev> sinelaw_: what exactly are you trying to do?
23:19:14 <c_wraith> maybe someone can suggest something if we had a bit more information about what you're trying to do
23:19:18 <c_wraith> heh, orclev beat me to it
23:19:20 <sinelaw_> :)
23:19:26 <sinelaw_> i'm writing a simple embedded language
23:19:34 <sinelaw_> and want to be able to print the types of expressions 
23:19:37 <[swift]> orclev: is it really indispensible in most other languages? i actively try to avoid it and that's generally not a problem, at least in the cases of C#, Java, and C++
23:19:48 <c_wraith> ah.  the typical response in that case is is "use a GADT to model your language"
23:19:56 <sinelaw_> I already do.
23:19:59 <sinelaw_> let me hpaste
23:20:26 <orclev> sounds more like you're looking for debuging type output, so you can do type checking at runtime... sort of
23:21:14 <orclev> [swift]: I found some of the cleanest solutions in Java use reflection and annotations to provide extra information at runtime
23:21:44 <sinelaw_> http://hpaste.org/41762/embedded_language
23:21:47 <[swift]> orclev: the difference may be in what each of us considers "clean" =)
23:21:55 <orclev> [swift]: see for example Spring and Hibernate
23:22:01 <sinelaw_> I want to be able to print out (during runtime):
23:22:15 <sinelaw_> "Tuple <Integer, Integer> (Variable v);"
23:22:31 <sinelaw_> declaring the type of a variable, in this case, after haskell inferred it
23:24:50 <orclev> sinelaw_: I've got a feeling you're approaching this wrong somehow, but I don't have enough haskell experience to say so with authority... what I can say is if you really want to do that, hint might be something to look at
23:25:36 <sinelaw_> orclev, i don't have enough haskell experience to tell whether you're right. :) i'll look at hint
23:25:59 <c_wraith> wait, if all you want to do is print the type of something, Typeable is sufficient
23:26:02 <sinelaw_> hint doesn't look like what i want
23:26:05 <c_wraith> > typeOf Int
23:26:06 <lambdabot>   Not in scope: data constructor `Int'
23:26:07 <c_wraith> err
23:26:14 <c_wraith> > typeOf (undefined :: Int)
23:26:15 <lambdabot>   Int
23:26:20 <sinelaw_> hmm
23:26:25 <ski> sinelaw_ : what should `showType (Literal (Just 42))' do ?
23:26:29 <c_wraith> that's from Typeable
23:26:37 <sinelaw_> i would have figured that out if Typeable docs were online :)
23:26:41 <applicative> ClaudiusMaximus, sorry, I disappeared.  Pandoc has a new --webtex option that does this when making html.
23:26:43 <lars9> :t undefined
23:26:44 <lambdabot> forall a. a
23:26:48 <djahandarie> sinelaw_, they should be
23:26:51 <lars9> @src undefined
23:26:51 <lambdabot> undefined =  error "Prelude.undefined"
23:26:53 <sinelaw_> djahandarie, where
23:26:59 <lars9> @src error
23:26:59 <lambdabot> error s = throw (ErrorCall s)
23:27:05 <lars9> :t error
23:27:06 <djahandarie> sinelaw_, http://hackage.haskell.org/packages/archive/base/4.3.0.0/doc/html/Data-Typeable.html
23:27:08 <lambdabot> forall a. [Char] -> a
23:27:12 <sinelaw_> djahandarie, haskell.org is down
23:27:12 <applicative> ClaudiusMaximus, but it seems like the incantations in this Matlab script would be easy to Haskellize: http://softlayer.dl.sourceforge.net/project/latex2png/latex2png/0.5/latex2png.m
23:27:16 <c_wraith> sinelaw_, yeah, I didn't realize you just wanted to print type info.  in which case Typeable is...  ok.  Just be aware that Typeable instances *can* lie.
23:27:20 <djahandarie> sinelaw_, which is different from hackage.haskell.org
23:27:27 <sinelaw_> ah
23:27:28 <sinelaw_> ok
23:27:37 <sinelaw_> thanks
23:27:39 <ski> sinelaw_ : .. so, what i'm wondering is why you don't just write `showType :: Expr a -> String' as a normal function ?
23:27:47 <sinelaw_> when can it lie?
23:28:01 <ski> sinelaw_ : when you implement them yourself, and you lie
23:28:05 <sinelaw_> ski, it means i have to interpret my language
23:28:20 <c_wraith> Or when you use an instance that wasn't automatically derived
23:28:25 <c_wraith> Whether you defined it or not
23:28:34 <sinelaw_> ski, which seems to mean i'll have to do some sort of type inference myself
23:29:33 <orclev> hmm... well, it seems to me it couldn't lie too badly or it wouldn't type check at compile time right?
23:30:03 <sinelaw_> ski, or am i missing the point?
23:30:31 <kmc> http://hpaste.org/41763/enummap_install_fail anyone know what to do about this?
23:30:39 <c_wraith> orclev, the string returned can lie.
23:30:42 <kmc> i'm using latest Haskell Platform and Hackage says all these packages build on 6.12
23:31:02 <c_wraith> orclev, but typeable uses unsafe tricks to ensure that casting doesn't succeed, even if the string returned lies
23:31:03 <ski> orclev : you can easily do e.g. `instance Typable MyFoo where typeOf _ = typeOf "foo"'
23:31:04 <dancor> @hoogle a -> [a -> m a] -> m a
23:31:04 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
23:31:05 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
23:31:05 <lambdabot> Data.Data gfoldl :: Data a => (c (d -> b) -> d -> c b) -> (g -> c g) -> a -> c a
23:32:02 <sinelaw> typeable won't derive my type, cause i'm using a gadt, right?
23:32:28 <c_wraith> actually, typeable doesn't care about that.
23:32:41 <c_wraith> auto-deriving typeable instances only cares about the kind of your type constructor
23:32:47 <dancor> :t foldl' (>>=)
23:32:48 <lambdabot> forall (m :: * -> *) b. (Monad m) => m b -> [b -> m b] -> m b
23:32:50 <c_wraith> it only works when all the arguments to the type constructor are of kind *
23:33:09 <ski> @type flip (runKleisli . foldr (>>>) Control.Category.id . map Kleisli)  -- dancor ?
23:33:09 <kmc> seems editing the dep to "base >= 4.0" fixes it, but i'm a bit squeamish about installing a hacked version of "containers"
23:33:10 <lambdabot> forall c (m :: * -> *). (Monad m) => c -> [c -> m c] -> m c
23:33:35 <dancor> i just want to chain the monadic functions
23:33:58 <c_wraith> dancor, do you maybe want (>=>) ?
23:34:03 <c_wraith> :t (>=>)
23:34:04 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
23:34:14 <c_wraith> :t foldM (>=>)
23:34:15 <lambdabot> forall a b. (a -> a -> b) -> [b -> a -> a -> b] -> a -> a -> a -> b
23:34:32 <c_wraith> ok, that's not what you want. :)
23:34:35 <c_wraith> :t foldM
23:34:36 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
23:34:36 <dancor> :t foldl' (>=>)
23:34:37 <lambdabot> forall a (m :: * -> *) c. (Monad m) => (a -> m c) -> [c -> m c] -> a -> m c
23:34:45 <sinelaw> ooh nice
23:34:46 <sinelaw> works!
23:35:06 <sinelaw> now i need to figure how to create structs
23:35:09 <sinelaw> (n-tuples)
23:35:19 <ddarius> This is an awesome question: "How would your Ideal Match answer this question? [ ] Yes. [ ] No."
23:35:45 <sinelaw> ddarius, heh
23:35:46 <orclev> ddarius: FileNotFound
23:35:53 <c_wraith> my ideal match would write a sarcastic remark in the margin :)
23:35:57 <geheimdienst> somebody on okcupid, eh?
23:35:58 <sinelaw> "Would your ideal match answer this question?"
23:36:06 <geheimdienst> [x] No
23:36:13 <geheimdienst> oh wait, i answered it
23:36:17 <sinelaw> hah
23:36:28 <ski> sinelaw : i was thinking that possibly you could do something like `showType :: Expr a -> String; showType (Tuple ea eb) = concat ["Tuple <",showType ea,", ",showType eb,">"]; ...'
23:36:53 <sinelaw> ski,  what about the rest of the data constructors
23:36:57 <dancor> how will your realistic match's answer differ
23:37:03 <sinelaw> ski, that's what i initially did, btw
23:37:05 <ski> dancor : i don't think there's a point to using  foldl'  in  foldl' (>=>)
23:37:25 <endojelly> :t (>=>)
23:37:26 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
23:37:26 <dancor> ski: you mean instead of foldl?
23:37:29 <ddarius> geheimdienst: Just the OkTrends blog.
23:37:37 <ddarius> geheimdienst: Which is fascinating and entertaining.
23:37:43 <geheimdienst> it's pretty awesome
23:37:46 <orclev> sinelaw: what's wrong with using the built in Typeable instance for tuples?
23:37:48 <ski> sinelaw : well, the type of `Literal' will have to be changed, to make that work, e.g. (that's why i asked about what `showType (Just 42)' should do)
23:38:01 <endojelly> ooh. I've been looking for (>=>) all the time.
23:38:11 <endojelly> in fact I haven't or I'd probably have found it using hoogle...
23:38:40 <ddarius> Incidentally, it's two checkboxes (seemingly) so you have the option of answering both or neither as well as yes or no.
23:38:42 <ski> dancor : or `foldr' .. or not passing `(>=>)' directly as the combiner function .. it depends on what you want
23:39:10 <applicative> @type foldr (>=>) return
23:39:10 <lambdabot> forall (m :: * -> *) c. (Monad m) => [c -> m c] -> c -> m c
23:39:35 <dancor> f a [b, c, d] = return a >>= b >>= c >>= d
23:40:05 <dancor> nice
23:40:10 <polarina> What FastCGI library do you people recommend?
23:40:24 <mm_freak_> polarina: wai + wai-handler-fastcgi
23:40:34 <endojelly> :t sequenceM
23:40:34 <lambdabot> Not in scope: `sequenceM'
23:40:36 <dancor> :t foldl' (>>=) . return
23:40:36 <endojelly> :t sequence
23:40:37 <lambdabot> forall (m :: * -> *) b. (Monad m) => b -> [b -> m b] -> m b
23:40:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:40:48 <endojelly> why not use that one?
23:40:51 * hackagebot dnscache 0.1.0 - Caching DNS resolver library and mass DNS resolver utility  http://hackage.haskell.org/package/dnscache-0.1.0 (ErtugrulSoeylemez)
23:41:10 * ski can't remember seeing `sequenceM', before ..
23:41:12 <endojelly> :t sequence
23:41:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
23:41:16 <endojelly> disregard that
23:42:21 <sinelaw> @hoogle intersperse
23:42:21 <lambdabot> Data.ByteString intersperse :: Word8 -> ByteString -> ByteString
23:42:22 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
23:42:22 <lambdabot> Data.ByteString.Char8 intersperse :: Char -> ByteString -> ByteString
23:42:36 <endojelly> :t intercalate
23:42:37 <lambdabot> forall a. [a] -> [[a]] -> [a]
23:42:42 <dancor> sequenceM is born!
23:43:12 <endojelly> sinelaw, I tend to use intercalate more than intersperse
23:43:44 <dancor> the RealWorld may never be the same
23:44:22 <sinelaw> :t intercalate
23:44:23 <lambdabot> forall a. [a] -> [[a]] -> [a]
23:44:43 <endojelly> sinelaw, yeah, it's totally different %)
23:46:18 <sinelaw> is there a way to override the Show instance for TypeRep a specific type?
23:47:17 <sinelaw> like, replace "(,)" with "Tuple"?
23:48:29 <applicative> dancor, it's annoying, an instance Monad m => Monoid (a -> m a) where mempty = return ; mappend = (>=>) is blocked
23:48:59 <applicative> dancor, by Data.Monoid's Monoid b => Monoid (a -> b)
23:49:08 <dancor> newtype time
23:49:19 <dancor> or ghcextensiontime
23:49:46 <ddarius> applicative: Solution: Instance Monad m => Monoid (m a)
23:50:05 * dancor hasn't really looked at ml modules
23:50:17 <sinelaw> nvm, found a workaround
23:50:44 <dancor> sinelaw: i would probably make a Tuple type..
23:50:53 <dancor> synonym
23:51:00 <dancor> err newtype
23:51:03 <dancor> idk anymore
23:51:17 <sinelaw> ah 
23:51:20 <sinelaw> i'll try that
23:52:11 <sinelaw> but then...
23:52:25 <Botje> DISASTER STRIKES!
23:52:30 <sinelaw> indeed
23:52:37 <sinelaw> on eightdays
23:53:15 <pygmalion> is anyone familiar with quine's theorem/propositional logic? i'm trying to modify a tautology checker to use quine's...
23:55:05 <sinelaw> bah
23:56:00 <sinelaw> ooh.
23:56:04 <ski> sinelaw : btw, you say that `vEx' there "doesnt' work" .. what is the error message ?
23:56:20 <sinelaw> ski, if you try to showType vEx
23:56:31 <sinelaw> or anything at all, i'm guessing
23:56:36 <sinelaw> ghc says it's type is ambiguous
23:56:39 <ski> ambiguous type ?
23:56:43 <ski> ah, i guessed that
23:56:54 <ski> that's because `vEx' is polymorphic :)
23:56:58 <sinelaw> which i don't understand (although jmcarthur started explaining it)
23:57:27 <sinelaw> but doesn't the definition of 'b' determine v's type
23:57:27 <ski> if you say `showType (vEx :: Exp Int)' or `showType (vEx :: Exp Double)', that would probably work
23:57:30 <sinelaw> and therefore vEx's type?
23:57:35 <ski> (assuming `showType' works at all)
23:57:48 <ski> nono
23:57:54 <ski> `vEx' is polymorphic
23:57:55 <sinelaw> for b to typecheck, v must have type Exp (Integer, Integer)
23:58:10 <sinelaw> you mean it has different types in different circumstances?
23:58:17 <sinelaw> it's a value
23:58:20 <ski> the use of `vEx' *in* `b' has type `Expr (Integer,Integer)', sure
23:58:30 <sinelaw> world of pain
23:58:35 <ski> but `vEx' itself is still polymorphic
23:58:42 <sinelaw> what's the point
23:58:47 <ski> of what ?
23:58:56 <sinelaw> of not forcing vEx to always have the same type
23:58:57 <ski> functions are also values, btw
23:59:03 <sinelaw> hmm
23:59:13 <ski> e.g. the empty list has type `[a]', for every type `a' you want
23:59:14 <sinelaw> I see
23:59:24 <ski> similarly with empty sets, maps, &c.
23:59:31 <sinelaw> interesting
23:59:49 <ski> sinelaw : just wondering, have you used SML or OCaml, before ?
23:59:52 <sinelaw> so how can i tell ghc i want it to be the same type?
23:59:58 <sinelaw> ski, not yet :)
