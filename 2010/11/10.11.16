00:00:36 <guest2425> please help how can I type list as a type
00:00:47 <dmwit> > [1, 2, 3] :: [Int] -- ?
00:00:48 <lambdabot>   [1,2,3]
00:00:52 <guest2425> :t map
00:00:53 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:01:22 <guest2425> Cale: so the type for map is this  (a -> b) -> [a] -> [b] why I cant use the same thing
00:01:23 <guest2425> ?
00:01:45 <dmwit> guest2425: What makes you think you can't use the same thing?
00:01:51 <Tefaj> Perhaps you wanted structureMap ((a->b)->[a]->[b])
00:01:59 <guest2425> yes
00:02:00 <Tefaj> ... whatever that's useful for.
00:02:45 <dmwit> Okay, just read the problem description.
00:02:51 <dmwit> "data" does not declare classes.
00:03:01 <guest2425> dmwit: oh ok
00:03:11 <dmwit> data types and classes are very different (and have something of a non-standard interpretation in Haskell compared to other mainstream languages)
00:03:37 <dmwit> You can think of a "class" as just a set of types with a common interface.
00:04:14 <ChongLi> hmm
00:04:16 <ChongLi> this is cool
00:04:19 <ChongLi> print $ map ( map toUpper ) vs
00:04:33 <dmwit> Use "class Foo a where ..." to specify the common interface they must satisfy; use "instance Foo Bar where" to add "Bar" to the set of types that implement the "Foo" class.
00:04:35 <guest2425> is this a class data Foo = Foo {x :: Integer, str :: String}
00:04:41 <dmwit> No.
00:04:48 <ChongLi> how to get rid of the parens in that expression?
00:04:48 <dmwit> "data" does not declare classes.
00:05:21 <dmwit> ChongLi: Why bother?
00:05:23 <guest2425> this is a class class Eq a where   (==) :: a -> a -> Bool   (/=) :: a -> a -> Bool
00:05:30 <ChongLi> dmwit: just wondering
00:05:31 <dmwit> yes
00:05:35 <guest2425> ??
00:05:48 <dmwit> ChongLi: Something like let foo = map toUpper in print $ map foo vs, I suppose
00:05:58 <dmwit> hardly seems worth the effort.
00:05:59 <ChongLi> ah
00:06:15 <dmwit> "let" and "in" are basically acting as parens there.
00:06:26 <guest2425> i need to do this Define a type class 
00:06:33 <ChongLi> haskell has so many ways of doing things, I'm always looking for the most readable in each situation
00:06:45 <ChongLi> seems the parens in that case are the best
00:06:53 <dmwit> ?pl \vs -> print $ map (map toUpper) vs
00:06:54 <lambdabot> print . map (map toUpper)
00:07:09 <dmwit> ?pl foo vs = print $ map (map toUpper) vs
00:07:10 <lambdabot> foo = print . map (map toUpper)
00:07:11 <dmwit> (similar)
00:07:23 <guest2425> dmwit: i need to do this Define a type class (you may want to call it Structure) whose functions include a generic map function and a generic foldr function.
00:07:31 <dmwit> guest2425: Yes, I know.
00:07:48 <guest2425> is this a type class class Eq a where   (==) :: a -> a -> Bool   (/=) :: a -> a -> Bool
00:07:52 <dmwit> yes
00:07:55 <guest2425> oh ok
00:08:00 <dmwit> ...as I said before.
00:10:35 <guest2425> dmwit: is this a class class Structure structureMap where   (==) :: (a -> b) -> [a] -> [b]  
00:11:46 <guest2425> dmwit: I getting an error message http://pastebin.com/PVCG26im
00:12:32 * hackagebot shivers-cfg 0.1 - Implementation of Shivers' Control-Flow Analysis  http://hackage.haskell.org/package/shivers-cfg-0.1 (JoachimBreitner)
00:13:45 <dmwit> "class Structure foo" declares a new class named Structure, and says that the functions in the body of any following "where" clause will have a type variable "foo" that tells how members of the "Structure" class get supplied to the functions there.
00:14:22 <dmwit> If you don't mention "foo" as a type variable in one of the type signatures, that member will have no way of disambiguating between the different instances of the class.
00:14:25 <dmwit> So this is not legal.
00:14:44 <dmwit> Every member of the class must mention "foo" (or, in your case, "structureMap") in their signature.
00:14:50 <dmwit> Does this help?
00:16:06 <guest2425> dmwit: like this class Structure f where  fstructureMap :: (a -> b) -> f a -> f b 
00:16:32 <guest2425> dmwit: i got rite?
00:16:35 <dmwit> Well... try it. What does GHC say? =)
00:16:59 <guest2425> :t fstructureMap
00:16:59 <lambdabot> Not in scope: `fstructureMap'
00:17:09 <guest2425> fstructureMap :: (Structure f) => (a -> b) -> f a -> f b
00:17:11 <guest2425> this
00:17:25 <guest2425> dmwit: this fstructureMap :: (Structure f) => (a -> b) -> f a -> f b
00:17:36 <dmwit> yup
00:17:39 <guest2425> ok
00:17:46 <dmwit> ?src Functor
00:17:46 <lambdabot> class  Functor f  where
00:17:46 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
00:17:49 <dmwit> (by the way)
00:17:57 <guest2425> oh ok
00:18:00 <guest2425> oh man
00:18:15 <guest2425> dmwit: now I got do foldr
00:19:44 <guest2425> dmwit: but i need to use the same class nam
00:19:52 <guest2425> *name 
00:19:58 <guest2425> How can I do that?
00:20:57 <dmwit> Just put more lines in your "where" block, I guess.
00:21:03 <dmwit> e.g.
00:21:05 <dmwit> ?src Monad
00:21:05 <lambdabot> class  Monad m  where
00:21:05 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
00:21:05 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
00:21:05 <lambdabot>     return      :: a -> m a
00:21:06 <lambdabot>     fail        :: String -> m a
00:22:13 <guest2425> but foldr takes f p arguments and map only takes f
00:22:44 <dmwit> eh?
00:22:45 <guest2425> so this it will be trouble class Structure f where
00:23:00 <guest2425> so this it will be trouble class Structure f  p where
00:23:45 <dmwit> I don't get it. Why would you write the latter? What's wrong with the former?
00:24:06 <paolino> yay for 7.0.1, 114 meg , almost java :)
00:24:40 <luite> hmm, hmatrix doesn't build with 7.0.1, but it did with an earlier build from last week
00:24:49 <guest2425> dmwit; hold on
00:25:03 <guest2425> dmwit: hold on
00:27:35 <guest2425> dmwit: I getting an error message class Structure f where  fstructureMap :: (a -> b) -> f a -> f b | fstructureFoldr :: (a -> b -> b) -> f b -> f [a] -> b
00:27:59 <guest2425> class Structure f where  fstructureMap :: (a -> b) -> f a -> f b | fstructureFoldr :: (a -> b -> b) -> f b -> f [a] -> b
00:28:33 <dmwit> where blocks use indentation for separation, not |
00:28:48 <dmwit> See the output of "?src Monad" above for an example.
00:29:24 <dmwit> You may also use explicit braces and semicolons, e.g. "class Monad m where { return :: a -> m a; fail :: String -> m a; ... }", but very few people do.
00:30:47 <luite> I get this error when building hmatrix with ghc 7.0.1: lib\Numeric\LinearAlgebra\Tests.hs:242:33: Context reduction stack overflow; size = 21
00:33:46 <dmwit> luite: You should probably say so on #ghc.
00:33:54 <guest2425> dmwit: is this ok http://pastebin.com/vJtZSWKP
00:34:05 <dmwit> The GHC folks seem pretty conscientious about regressions.
00:34:50 <dmwit> guest2425: Seems somewhat reasonable. As a sanity check, does the type of fstructureFoldr degenerate to the type of foldr when f is []?
00:35:06 <dmwit> (hint: no, and you should fix it until the answer is yes ;-)
00:35:48 <luite> dmwit: already did
00:36:15 <guest2425> dmwit: so like this fstructureFoldr :: (a -> b -> b) -> f b ->  [a] -> b
00:37:49 <dmwit> errr... that wasn't quite what I was getting at
00:37:52 * hackagebot ConfigFileTH 0.1 - Template haskell for reading ConfigFiles.  http://hackage.haskell.org/package/ConfigFileTH-0.1 (VilleTirronen)
00:38:27 <guest2425> dmwit: I am confuse and tired I got the map ok correct
00:38:33 <dmwit> What I was getting at was that, if you replace "f" with "[]" as you're going to, soon, when you write instances for this class, you get the type
00:38:48 <dmwit> fstructureFoldr :: (a -> b -> b) -> [b] -> [[a]] -> b
00:38:54 <dmwit> which doesn't quite match the type of foldr.
00:39:11 <dmwit> So either foldr is wrong, or you haven't written the type for fstructureFoldr quite correctly yet.
00:40:06 <guest2425> foldr is not wrong
00:40:22 <dmwit> Alright, then, by process of elimination... =)
00:40:29 <guest2425> i am wrong
00:40:33 <dmwit> heh
00:40:39 <guest2425> omg
00:40:46 <guest2425> :t foldr
00:40:46 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
00:40:56 <guest2425> :t map
00:40:56 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:41:28 <guest2425> i just dont see it
00:41:30 <guest2425> at all 
00:41:35 <guest2425> I am blink
00:41:41 <guest2425> i am blind
00:41:43 <guest2425> omg
00:41:48 <guest2425> blink blink
00:41:55 <dmwit> Maybe you'd better get some sleep and have another go in the morning.
00:42:00 <guest2425> who can tell a joke
00:42:10 <guest2425> a joke to kill the nite out
00:42:53 <guest2425> guys come on 
00:42:58 <guest2425> a Haskell joke
00:43:26 <guest2425> hey my new name will be guest2425 Haskell
00:43:55 * hackagebot syb-with-class 0.6.1.1 - Scrap Your Boilerplate With Class  http://hackage.haskell.org/package/syb-with-class-0.6.1.1 (AndreaVezzosi)
00:45:28 <guest2425> good nite nite
00:45:32 <guest2425> every one
00:45:41 <guest2425> in the sweet Haskell Channel
00:45:46 <guest2425> I am so tired
00:46:10 <guest2425> why nobody reply??????????????????????
00:47:45 <Cale> Sorry, I'm a little busy atm :)
00:47:56 <Cale> good night :)
00:48:50 <guest2425> Cale: atm
00:48:52 <guest2425> ??
00:48:58 <Cale> at the moment
00:49:05 <guest2425> Cale: oh ok
00:49:15 <guest2425> Cale: do you know any jokes
00:49:17 <guest2425> ?
01:03:07 <luite> Cale: not sure if you're the maintainer, but I get this problem when installing MonadRandom 0.1.5 with ghc 7.0.1: Control\Monad\Random.hs:59:10: Could not deduce (Functor m) from the context (Monad m)
01:07:10 <Cale> luite: Oh, that's odd. I wonder what could have produced that...
01:07:57 <luite> It's easily fixed by adding Functor m to the context, but I don't know what change caused it
01:08:00 <Cale> luite: I'm the original author of the module, but other people have done stuff with it since I wrote it and stuck it on the Haskell wiki.
01:09:14 <Cale> Oh, maybe that Applicative depends on Functor?
01:09:41 <Cale> But that was already there since the beginning...
01:09:44 <luite> yeah, but it already did in 6.12
01:15:11 <ksf> well, I would be off and porting xmonad to wayland, the problem is it crashes my X. and kms support is disabled in source, for some time now.
01:17:17 <jkramer> Ahoy
01:17:27 <jkramer> I'm having a weird problem I don't understand: http://pastie.org/1302043
01:18:23 <ksf> welcome to the magic of defaulting.
01:18:50 <dolio> Yep. Monomorphism restriction.
01:19:13 <ksf> second-most hated haskell feature.
01:19:14 <vegai> ksf: how close is wayland to being a real option?
01:19:19 <ksf> the most hated is unary minus.
01:19:31 <ksf> _allegedly_ darn close.
01:19:34 <dolio> Really?
01:19:47 <ksf> maybe it's nouveau that's messing up stuff on my box.
01:20:08 <dolio> I actually don't dislike unary minus much.
01:20:14 <vegai> weird. I was following projects such as Berlin and GGI when they were mildly hot
01:20:19 <vegai> they worked for years without getting anywhere
01:20:22 <vegai> what's different now?
01:20:32 <ksf> wayland is a quite small bit of glue.
01:21:28 <ksf> graphics drivers in the kernel, and wayland doesn't care whether you talk to the card directly, use mesa or some other lib.
01:22:11 <dolio> I'd probably say n+k patterns were more hated, because they're gone now, unless you're excluding them for that reason.
01:22:15 <ksf> it's more or less a slightly more featureful (and vastly cleaner) glut
01:22:30 <ksf> I never even considered using those.
01:22:38 <ksf> but ifthenelse is gone, too.
01:22:50 <Cale> I like unary minus.
01:22:52 <luite> ksf: hmm, is it good to have the drivers in the kernel? microsoft moved them out of the kernel (at least partially) with vista
01:22:56 <dmwit> Calling n+k patterns the most-hated feature elevates them to the status of feature. ;-)
01:23:00 <vegai> did any non-academic user hate n+k?
01:23:07 <ksf> well, "in the kernel" is a relative thing.
01:23:10 <vegai> wait, there were no non-academic users back then :P
01:23:13 <dolio> Am I an academic?
01:23:34 <Cale> (Sure it's a weird compromise, but it's one which complies with my expectations of how things ought to work ;)
01:23:38 <ksf> just tried out the 2.6.37 lately and my nic driver stumbled across a NULL. the rest of the kernel didn't care.
01:24:06 <dolio> I suppose I may qualify.
01:24:19 <dolio> Since I read lots of papers and stuff.
01:24:51 <ksf> whether linux is a mono- or microkernel is more a question of what runs in what mode and uses what interface, not so much about code design.
01:25:04 <ksf> what kind of interface, I mean.
01:25:05 <dolio> fail in Monad is also way more hated, if that qualifies.
01:25:52 <ksf> we might see linux becoming more hybrid or even micro as soon as IOMMUs become widespread.
01:25:53 <luite> so what's the long-term goal of the new haskell revisions? remove one hated feature per year? :)
01:26:06 * hackagebot email-validate 0.2.6 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-0.2.6 (GeorgePollard)
01:26:16 <dmwit> That would be damn good progress.
01:26:35 <ksf> hmmm ipv6 would even make exo feasible. just give every process that wants one a separate address.
01:26:48 <ksf> ...and let them implement tcp/whatever themselves.
01:27:39 * ksf could try switching back to the binary nvidia drivers and try out wayland under X, but somehow I don't like that approach.
01:29:15 <ksf> oh, and in general xmonad would have to switch from xlib to either gl or cairo for drawing decorations etc.
01:30:17 <ksf> I'd opt for cairo, as it's going to be quite standard on wayland, virtually every system already has it and it handles _fonts_.
01:30:51 <zkenyon> how do I deal with an ambiguous occurrence of map
01:30:59 <ksf> you qualify it.
01:31:05 <ivanm> add a type sig!
01:31:13 <ksf> or you fix your imports so it's not ambigious.
01:31:25 <zkenyon> ok, let me be more specific
01:31:59 <zkenyon> I have imported Data.Set as L, because it's membership function is more robust, 
01:32:18 <ksf> ...import it qualified?
01:32:43 <ksf> import qualified Data.Set as L
01:32:48 <zkenyon> ok
01:32:48 <ksf> improt Data.Set (Set)
01:33:34 <ksf> or as a quick fix import Data.Set as L hiding (map)
01:33:43 <ksf> (or as and hiding the other way round, I always forget)
01:34:02 <zkenyon> thank you, this was effective.
01:34:32 <ziman> does the LLVM backend of GHC mean that we'll be able to generate code for other archs than x86 or amd64?
01:34:49 * ksf wants ocaml-style functors and renaming stuff on import.
01:34:52 <merijn> ziman: Well, I assume the runtime has to support your architecture
01:35:02 <ksf> ziman, it's not that easy.
01:35:06 <dcoutts__> ziman: we already can generate code for several arches, which ones are you interested in?
01:35:15 <ksf> but porting sholud become a bit easier.
01:35:19 <ziman> dcoutts__, mainly arm
01:35:27 <dcoutts__> ziman: you're in luck
01:35:29 <ziman> merijn, ah, I see
01:35:47 <dcoutts__> ziman: it already works, there's a debian package and everything
01:36:28 <ziman> dcoutts__, cool! I thought the ARM porting movement ceased a while ago... now that's good news :)
01:36:38 <dcoutts__> ziman: what is missing on arm is a high performance code generator, and that's what LLVM might help with
01:36:46 * ksf is going to disable gallium and try wayland under X, again.
01:37:27 <dcoutts__> ziman: the portable "unregisterised" C backend works, but it's 1/2 the performance of any of the other high perf backends
01:38:06 <ksf> mesa, btw, by now uses llvm, too.
01:38:13 <dcoutts__> ziman: there's of course a lot more to make a useful dev platform than just an ARM code gen
01:38:28 <dcoutts__> e.g. cross-compilation is rather useful
01:39:01 <ksf> compiling gl/glsl/gles/whatever -> gallium -> llvm -> gpu/cpu
01:39:02 <Cale> Took a break to take a couple photos of some structures I hadn't recorded yet: http://www.flickr.com/photos/cgibbard/5180846247/#/photos/cgibbard/5180846247/lightbox/
01:39:17 <dcoutts__> zomg: the ghc on iphone people have various modifications to make it work well enough in their case, but it's not yet upstream
01:39:22 <therp> ksf: wow. that's not a bad idea
01:39:39 <zomg> dcoutts__: cool.
01:39:53 <ziman> dcoutts__, yes, I've heard about the iphone initiative
01:39:57 <ksf> they're completely disregarding fixed function pipelines.
01:40:07 <dcoutts__> zomg: oops, wrong nick, I meant ziman :-)
01:40:13 <ziman> it's great that it works, even non-high-performance ;)
01:40:20 <ksf> but can still offer gl 2.1 on them...
01:42:04 <Ke> how about ghc on n900
01:42:18 <Ke> or meego/arm
01:42:31 <ksf> I'd like to see it on pandora.
01:42:42 <dcoutts__> Ke: needs people to work on it
01:42:59 <ksf> shouldn't be much of a problem, pandora's linux is quite standard.
01:43:16 <zomg> Porting things to N900 is relatively straighforward from what I hear
01:43:29 <zomg> At least if you just want it to run from terminal
01:43:54 <Ke> well mostly I care about GNU/linux/arm anyways
01:44:17 <Ke> with real glibc and all
01:45:13 <ksf> glibc needs defossilisation.
01:45:33 <ksf> dunno why they're wasting disk space with ebcdic codepages by default.
01:45:59 <ksf> ...I rather doubt you need it for posix compatibility.
01:46:20 <Ke> you need it for glibc compatibility ;o)
01:47:10 <ksf> ...another advantage of wayland: it's going to be able to switch graphics drivers on the fly.
01:48:06 <zkenyon> testList = [(x-1000,y) | y<-[1,1000] , x <- [1..2000], (L.member y primes)]
01:48:11 <zkenyon> this line fails
01:48:37 <zkenyon> haha
01:48:38 <zkenyon> nvm
02:09:21 * hackagebot instant-zipper 0.0.0 - Heterogenous Zipper in Instant Generics  http://hackage.haskell.org/package/instant-zipper-0.0.0 (BramSchuur)
02:10:03 <Biggles> i just realised what a glorious pun xmonad is because leibniz's windowless monads
02:11:07 <bastl> hello, my glade / gtk2hs program emits the following GTK warning, how can I debug it? (casestudy:5047): Gtk-WARNING **: Can't set a parent on widget which has a parent. what does casestudy:5047 refer to? (casestudy is the name of the package and the executable ...)
02:11:34 <ksf> ...wayland doesn't like mesa/llvmpipe
02:12:21 * hackagebot convertible-text 0.3.0.7 - Typeclasses and instances for converting between types  http://hackage.haskell.org/package/convertible-text-0.3.0.7 (MichaelSnoyman)
02:12:23 * hackagebot wai 0.2.2.1 - Web Application Interface.  http://hackage.haskell.org/package/wai-0.2.2.1 (MichaelSnoyman)
02:12:25 * hackagebot web-routes-quasi 0.6.1.1 - Define data types and parse/build functions for web-routes via a quasi-quoted DSL  http://hackage.haskell.org/package/web-routes-quasi-0.6.1.1 (MichaelSnoyman)
02:32:27 * hackagebot neither 0.2.0 - Provide versions of Either with good monad and applicative instances.  http://hackage.haskell.org/package/neither-0.2.0 (MichaelSnoyman)
02:44:12 <Cale> Someone should inform Apple that Spinning Rainbow Ball is not an acceptable substitute for a progress bar :P
02:44:33 <ksf> )(*^&!^!!!
02:45:28 <ksf> in the mean-time, while I grumble about nouveau/wayland and think about what to do next, you may discuss the naming issue that arises when xmonad doesn't happen to be specific to X, any more.
02:46:17 <Jafet> xtensible
02:46:58 <engla> we'll finally go back to a W window system then
02:47:44 <ksf> wmonad would fit, w not for wayland but for wm.
02:47:55 <engla> wxmonad for extra confusion
02:47:59 <ksf> ...so there's going to be newtype WM a
02:49:07 <ksf> ...XState and XConf not being the most X-specific part, anyway.
02:58:53 <Entroacceptor> ksf: well, x can be a variable...
03:00:42 <ksf> oh, there's _one_ xmonad core sourcefile that doesn't import X.
03:01:29 <Jafet> xsmonad, now with GDI support
03:01:40 <tab> ksf: do you know if there's an equivalent of xprop on wayland ?
03:02:02 <ksf> there's per-window user data, yes.
03:02:25 <tab> great
03:02:25 * ksf really needs to have another look at the interface
03:02:42 <ksf> at least that's what wayland apps use to store themselves in.
03:03:11 <tab> otherwise xmonad might struggle to run on wayland without the filtering/hooking
03:03:43 <ksf> it might be nice to have someone who knows windows, though, running xmonad as a shell there would make it useabel.
03:03:59 <ksf> (last time I had to use it regularly I used bb4win)
03:04:38 <Entroacceptor> there's a tiling wm for windows
03:04:43 <Entroacceptor> but I forgot its name
03:05:46 * ksf is still wondering how wayland's credo "we don't do no drawing" fits into giving clients a cairo surface to render on.
03:07:00 <Entroacceptor> no drawing?
03:07:20 <ksf> well, it's a compositor.
03:07:25 <ksf> clients do their own drawing.
03:08:26 <Entroacceptor> so it can't be accelerated?
03:08:49 <ksf> clients are supposed to do the accellerating.
03:09:06 <ksf> wayland sits between the drm kernel drivers and clients.
03:09:20 <ksf> if you want gl, link to mesa, it knows how to talk to drm.
03:09:48 <ksf> ...and cairo knows how to talk to gl.
03:10:19 <Entroacceptor> so I can forget it for my old laptop
03:10:28 <ksf> nope.
03:10:35 <ksf> at least not per se.
03:10:50 <ksf> what kind of gpu do you have?
03:11:35 <tab> ksf: i supposed wayland just do copy surface around (or pass them to the hardware directly), not actual drawing
03:11:39 <Entroacceptor> narly non existand
03:11:42 <Entroacceptor> existant
03:11:46 <ksf> tab, exactly.
03:11:54 <ksf> ...but it still hands out cairo surfaces.
03:12:03 <Entroacceptor> 2d accel is ok, the gl interface is so bad software rendering is faster for most stuff...
03:12:13 <tab> ksf: why would that be a problem ?
03:13:06 <vegai> ksf: can mesa talk with 3d hardware?
03:13:24 <vegai> or are they gonna finally put 3d drivers in the kernel
03:13:47 <tab> vegai: definitely no 3d drivers in the kernel
03:14:09 <ksf> mesa is the one and only floss gl stack.
03:14:22 <ksf> yes, it can talk to drm drivers
03:15:29 <vegai> so how will 3d hardware work in this setup?
03:15:59 <Entroacceptor> not at all if you use nvidia 
03:16:03 <vegai> afaik, all the current unix 3d drivers are for the most part in X11's side
03:16:05 <ksf> the drm drivers expose the general capabilities, userspace mesa knows how to use it.
03:16:09 <guest2425> hello I have a problem http://pastebin.com/sAFmjTe4
03:16:24 <tab> Entroacceptor: nvidia drivers doesn't work with wayland :)
03:16:31 <ksf> yep, either proprietary or, in the floss case, part of mesa.
03:16:44 <ksf> not even nouveau does, or I wouldn't be talking here right now.
03:16:53 <luite> how about the binary ATI/AMD drivers?
03:17:04 <tab> luite: same thing
03:17:05 <ksf> binaries don't work
03:17:15 <ksf> they don't use the right stuff on the kernel side.
03:17:17 <ksf> drm, kms
03:17:19 <guest2425> hello I have a problem http://pastebin.com/sAFmjTe4
03:17:37 <vegai> so when the world moves to wayland, all linux 3d games will stop working
03:17:49 <ksf> hell no, why should they?
03:17:51 <tab> ksf: while nouveau doesn't work yet, it's closer from working than nvidia binaries :)
03:18:01 <blackh> guest2425: What seems to be the problem with it?
03:18:07 <vegai> because only the binary drivers can drive those games
03:18:28 <vegai> because (I suppose) writing quality drivers for 3d hardware is too difficult 
03:18:32 <guest2425> the      fstructureFoldr :: (a -> b -> b) -> f b ->  [a] -> b has the wrong type
03:18:33 <ksf> nouveau can drive those games. 
03:18:46 <ksf> not very fast, mind you, but it does.
03:18:47 <tab> vegai: some opensource drivers are getting good at 3d
03:18:48 <vegai> I have no reason to believe that is true
03:18:49 <guest2425> blackh: the      fstructureFoldr :: (a -> b -> b) -> f b ->  [a] -> b has the wrong type
03:19:11 <blackh> guest2425: Should it be (a -> b -> b) -> b -> [a] -> b ?
03:19:12 <companion_cube> wait, nouveau works ?
03:19:14 <ksf> ut2004 is not a problem at low settings, doom3 kills the stack, though.
03:19:16 <Entroacceptor> vegai: it's difficult because the manufacturers  don't give out their specs
03:19:29 <vegai> Entroacceptor: doesn't ATI/AMD?
03:19:33 <blackh> guest2425: Actually that can't be right.
03:19:35 <ksf> spring runs just as fine. didn't try tuxracer but it's bound to work.
03:19:51 <guest2425> no not this (a -> b -> b) -> b -> [a] -> b 
03:19:57 <blackh> guest2425: What are you trying to do?
03:20:00 <vegai> well, I've just mainly played dwarf fortress and enemy territery
03:20:18 <guest2425> blackh: not this (a -> b -> b) -> b -> [a] -> b  since I am doing a generic class
03:20:21 <vegai> both were unplayable with the opensource radeon driver and perfectly fine with fglrx. 
03:20:29 <ksf> companion_cube, it's 2d accel is better than the binary blob
03:20:29 <vegai> but sorry, this is off-topic
03:20:42 <vegai> -blah anyone?
03:20:43 <companion_cube> thanks, ksf, i'm gonna try it
03:20:47 <monoidal> > 10^^34 == 1e34
03:20:47 <lambdabot>   False
03:20:51 <tab> vegai: when times come, binary drivers will be ported to wayland anyway ..
03:20:54 <ksf> 3d support is unsupported but nicely coming.
03:20:59 <monoidal> is there a way to create the exact function 10^^n?
03:21:02 <blackh> guest2425: What the type should be depends on what you are trying to do.
03:21:15 <monoidal> > 10^34 - 1e34
03:21:16 <lambdabot>   1.152921504606847e18
03:21:21 <guest2425> this Define a type class (you may want to call it Structure) whose functions include a generic map function and a generic foldr function
03:21:22 <vegai> tab: yeah, if it succeeds, that's probably true
03:21:30 <ksf> I don't even care about drivers, I'd be content with wayland running on an svga framebuffer, right now.
03:21:40 <guest2425> blackh: Define a type class (you may want to call it Structure) whose functions include a generic map function and a generic foldr function
03:21:41 <ksf> just give me a running server to mess with.
03:22:12 <ksf> :t gfoldl
03:22:13 <lambdabot> forall (c :: * -> *) a. (Data a) => (forall d b. (Data d) => c (d -> b) -> d -> c b) -> (forall g. g -> c g) -> a -> c a
03:22:49 <blackh> guest2425: How about (a -> b -> b) -> b -> f a -> b ?
03:23:02 <guest2425> let me try that
03:23:12 <guest2425> blackh: let me try that out
03:23:51 <guest2425> blackh: yeah is working
03:23:54 <guest2425> thank you
03:24:30 <guest2425> blackh: How you knew that
03:25:40 <blackh> guest2425: Well, I figured that the container must be the container of a's, since foldr works on a container.
03:26:12 <guest2425> oh ok
03:26:25 <guest2425> nice figure
03:26:41 <guest2425> bye bye
03:27:27 <blackh> I've never been told I have a nice figure before.
03:30:12 <guest2425> hahah
03:30:24 <blackh> :)
03:36:58 <paolino> Is there any standard to be respected for uploading code on hackage ?
03:38:50 <blackh> paolino: Take a look at the 'upload' page. There are a few things mentioned on there.
03:40:25 <blackh> paolino: Also http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
03:41:11 <paolino> blackh: aside technical notes I don't see mentions to hackage philosophy
03:41:38 <blackh> paolino: There isn't much, I think.  There are some versioning policies, too.
03:42:05 <blackh> That tells you if you change the API, which number you should change in the version number, etc.
03:42:48 <paolino> I was just guessing if making a module Data.Reactor was unfair
03:43:34 <blackh> I don't think people only start to get worried about namespacing if the package gets really popular.
03:43:47 <blackh> Sorry... not enough sleep.
03:44:06 <blackh> I think people are only worried about the structure of the namespace if your package starts to get popular.
03:44:49 <blackh> I don't think there is any actual policy on naming of modules.
03:45:48 <Cale> paolino: Reactor?
03:46:11 <paolino> it would be nice to have a subroot Contribute , but that is just postponing the problem
03:46:40 <blackh> I hope you have good lead shielding.
03:47:02 <paolino> ok, I will put it somwhere else, random
03:47:44 <paolino> Cale, that is the best name I've found
03:48:25 <paolino> and I thought Data was better than Control and System because it focuses on logic 
03:48:49 <blackh> What does your package do?
03:49:54 <paolino> mh, I took it out from a service I developed for collaborative group buying
03:50:22 <paolino> I don't kwnow the english/rest of the world name for these groups
03:51:28 <blackh> syndicate?
03:51:42 <paolino> people gather to decide what to buy 
03:52:29 <paolino> some of them do some market analysis for each good and then they make a collective bargain
03:53:16 <paolino> the part I took out deals with their declaration and state update
03:53:20 <blackh> I don't know how that works, or if there's a proper name for it, but you could call it a syndicate.
03:56:24 <paolino> so it's fair complex logic, like if the guy responsabile for businnes A decide that it's too late the money gets back in the people account, which compete with the fact that half of the staff has to give the permission for him to close the bargain, and other complexities
03:58:21 <paolino> all these reaction are to be programmed and they produce new reactions to different events and internal events and it must be serializable and serialization has not to contain unnecessary events
03:59:02 <paolino> so I called this object that control them a Reactor 
03:59:37 <blackh> That sounds like really great stuff!
03:59:59 <paolino> I think it's something very useful for game programming
04:00:12 <paolino> but that is not my field really
04:00:21 <blackh> That is my field.
04:00:39 <paolino> eh
04:00:56 <blackh> I'm doing a video game in Haskell: iPwn Studios' BloodKnight
04:01:18 <paolino> if Cale says I can upload Data.Reactor I do it :)
04:02:00 <Cale> paolino: ah, neat
04:02:48 <blackh> Well, it's fine with me to call it Data.Reactor, but what would I know?
04:06:40 <Cale> It's okay because people can choose what packages their project uses, and it's pretty unlikely that there will already be a Data.Reactor (and if there is, there's syntax for disambiguating in GHC at least)
04:07:22 <Cale> Putting lots of stuff under Data or Control randomly seems kind of pointless to me though.
04:07:45 <blackh> You might get a clash if you had a project where you buy and sell Uranium for a nuclear reactor. :)
04:09:48 <ManateeLazyCat> I'm use libcurl code develop "Multi-Thread curl client", you can use multi-thread fetch different part of remote file to accelerate. So i need the size of remote file before download it. Anyone now how to use curl or libcurl get the size of remote file?
04:10:37 <blackh> ManateeLazyCat: You could read RFC 1945.
04:10:52 <ManateeLazyCat> blackh: Thanks,
04:11:04 <zenzike> blackh: you're using Haskell for an iphone app?
04:11:05 <blackh> I think it's possible to get the timestamp of a remote file - not sure about the size.
04:11:17 <blackh> zenzike: Yes, I am
04:11:23 * hackagebot reaction-logic 2010.11.14 - pluggable pure logic serializable reactor  http://hackage.haskell.org/package/reaction-logic-2010.11.14 (PaoloVeronelli)
04:11:41 <zenzike> blackh: I thought apple had restrictions about which language the source had to be in?
04:11:52 <blackh> zenzike: They got rid of that.
04:12:01 <blackh> They did have for a while.
04:13:13 <zenzike> blackh: ooh. I wasn't aware of that. how hard has it been to develop for the iphone in haskell?
04:13:13 <ManateeLazyCat> blackh: I found someone use Option CurlHeaderFunction to get the file size from http header.
04:13:30 <ManateeLazyCat> blackh: I have write some code to try, but looks size is not right...
04:14:56 <blackh> zenzike: We made a version of GHC that cross-compiles to iPhone, but since we got that working, it's not hard.
04:15:20 <zenzike> blackh: cool, sounds interesting :-)
04:15:20 <blackh> You have to do your own glue code with all the objective-C stuff directly in FFI, though.
04:15:26 <blackh> There's no library for doing that.
04:16:17 <zenzike> blackh: oh right, you're using the objective-C interface to work with the phone.
04:17:07 <blackh> zenzike: You have to do at least some objective-C to get things working. http://projects.haskell.org/ghc-iphone/
04:17:47 <blackh> Just take some bit of sample code from Apple, and hack your Haskell code into it using FFI.
04:17:48 <ManateeLazyCat> blackh: I know how to do.
04:17:57 <zenzike> blackh: I had assumed that the GHC-iPhone stuff was a pipe dream that nobody managed to pull off. I'm glad you did :-)
04:18:29 <ManateeLazyCat> blackh: When i use "curl -I http://site/file.mp3", i can get Header string, 'Content-Length' will tell you the size of file.
04:19:03 <blackh> zenzike: We've done it and it works well. Not very fast, but we're working on that too.
04:19:12 <orlandu63> nice, arch linux already has ghc 7 in its repos :)
04:19:34 <ManateeLazyCat> orlandu63: Many packages haven't update to ghc-7
04:19:35 <blackh> ManateeLazyCat: Of course... that will work.  Just start the download, and it'll tell you the size at the beginning.
04:19:35 <silver> gcc 4.5
04:19:41 <silver> which is... 
04:19:44 <silver> not so good
04:19:52 <blackh> ManateeLazyCat: Content-Length is not guaranteed to be there, though.
04:20:44 <ManateeLazyCat> blackh: I will add some error handle in libcurl, if file size is wrong, then stop download...
04:21:37 <blackh> If a URL gives no Content-Length, that is quite legal in HTTP, and your client should support that if it wants to comply with the standard.
04:22:21 <ManateeLazyCat> blackh: Thanks for your suggestion, i will consider it. :)
04:22:54 <MasseR> What do you guys use for vim folding? Indent? Manual? Marker? Or do you have some syntax files that allow folding
04:24:18 <blackh> ManateeLazyCat: I'm not telling you what to do. :) If you ignore the standard we can call you MicrosoftLazyCat
04:24:31 <ManateeLazyCat> blackh: I'm Linux guy. :)
04:24:44 <Cale> I turned folding on for a while, but didn't find that I really got any use from it, so I turned it off again.
04:25:07 <blackh> ManateeLazyCat: Me too.  I'm just saying that because Microsoft likes to ignore internet standards.
04:25:43 <Entroacceptor> there's always been a "fix internet explorer" option in Apache...
04:25:45 <ManateeLazyCat> blackh: Microsoft want create it's own standard, then let people follow ... you know ... evil... 
04:25:52 <Cale> Most definitions are so short that it's worthless to fold them.
04:29:59 <ManateeLazyCat> blackh: Use Content-Length is not perfect way since it just for HTTP.
04:30:04 <ManateeLazyCat> blackh: I found better way.
04:30:38 <ManateeLazyCat> blackh: In libcurl have option CurlProgressFunction can tell the total size of file.
04:31:27 <blackh> Perfect!
04:31:42 <ManateeLazyCat> blackh: So my policy use one thread start download file, then get filesize by option 'CurlProgressFunction', then i can create new thread accelerate download
04:31:53 <ManateeLazyCat> blackh: Then all protocol that curl support this way should work.
04:33:24 <ManateeLazyCat> blackh: I do not know why the inspiration will come out when I chat with people.  ;p
04:33:57 <Jafet> stty echo
04:34:55 * ManateeLazyCat Don't know how to fix problem, bla bla in #haskell then inspiration will come out.... :)
04:35:27 <blackh> ManateeLazyCat: That happens all the time. It works well with bugs, too.
04:36:22 <blackh> Jafet: Are you named after Noah's son out of the Bible?
04:37:48 <blackh> (I have always been curious about your nick.)
04:38:46 <silver> the one that mocked his father?
04:39:03 <Jafet> I thought that was rendered as Yefet.
04:40:09 <blackh> Jafet: Well, I always thought it was a little-known fact that the name is actually Yefet.  It's just that it happens to be written in pause (since it's at the end of the verse) so it comes out as Yafet (or Jafet).
04:40:55 <Jafet> I don't know hebrew nearly that well. Anyway, no.
04:41:06 <blackh> Oh - never mind, then. :)
04:49:36 * hackagebot reaction-logic 2010.11.17 - pluggable pure logic serializable reactor  http://hackage.haskell.org/package/reaction-logic-2010.11.17 (PaoloVeronelli)
04:57:25 <ManateeLazyCat> Bye all, coding time...
04:58:20 <tibbe> .
04:58:51 <engla> all depends on transliteration how it's done and to which language. So I don't know if you can say it "really is" Jafet or Yafet
04:58:53 <engla> Yefet
05:07:16 <Jigboot> Tired of negroes?
05:07:22 <Jigboot> Sick of their monkeyshines?
05:07:29 <Jigboot> Then join Chimpout Forum!
05:07:37 <Jigboot> http://www.chimpout.com/forum
05:07:38 --- mode: ChanServ set +o quicksilver
05:07:43 --- mode: quicksilver set +b *!*c9a0f27e@*.201.160.242.126
05:07:43 --- kick: Jigboot was kicked by quicksilver (foad)
05:21:47 * hackagebot HsOpenSSL 0.9 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.9 (MasatakeDaimon)
05:30:19 <diabolo_> hello haskell people
05:32:34 <diabolo_> I have a question regarding walking around some kind of implicit graph, anyone with a take on that?
05:33:15 <Entroacceptor> diabolo_: maybe?
05:33:39 <Entroacceptor> we'll never find out if you don't ask the question, will we?
05:34:34 <diabolo_> ok, so let's say I have an (Int,Int)->[(Int,Int)] function that gives me the neighboring indexes for a given index
05:35:01 <diabolo_> eg. in a square grid (i,j) -> [(i-1, j), (i, j-1) ,(i+1, j), (i, j+1)]
05:36:47 <diabolo_> I also have another function to limit the indexes i'm interested in, for example (i,j) in a given range
05:37:41 <diabolo_> question is: how can I make a function that would do a depth first search and return a tree of the visited indexes
05:38:03 <Botje> are you allowed to visit squares more than once?
05:39:12 <Jafet> The trivial way is to remember which ones you've visited before, and not visit them again. Do you have a more specific question?
05:39:43 <ibt> which isn't anything unique for a depth first traversal..
05:40:35 <Jafet> instance Show ((Int, Int) -> [(Int, Int)]) where
05:45:55 * hackagebot array 0.3.0.2 - Mutable and immutable arrays  http://hackage.haskell.org/package/array-0.3.0.2 (RossPaterson)
05:45:57 * hackagebot base 4.3.0.0 - Basic libraries  http://hackage.haskell.org/package/base-4.3.0.0 (RossPaterson)
05:46:00 * hackagebot Cabal 1.10.0.0 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.10.0.0 (RossPaterson)
05:46:37 <Botje> visit next valid visited start = Tree $ map (visit next valid (start:visited)) $ filter valid $ next start
05:46:40 <Botje> diabolo_: ^ ^
05:46:55 <Botje> hmm
05:47:02 * hackagebot containers 0.4.0.0 - Assorted concrete container types  http://hackage.haskell.org/package/containers-0.4.0.0 (RossPaterson)
05:47:04 * hackagebot directory 1.1.0.0 - library for directory handling  http://hackage.haskell.org/package/directory-1.1.0.0 (RossPaterson)
05:47:06 * hackagebot filepath 1.2.0.0 - Library for manipulating FilePaths in a cross platform way.  http://hackage.haskell.org/package/filepath-1.2.0.0 (RossPaterson)
05:47:08 * hackagebot haskell98 1.1.0.0 - Compatibility with Haskell 98  http://hackage.haskell.org/package/haskell98-1.1.0.0 (RossPaterson)
05:47:10 * hackagebot hpc 0.5.0.6 - Code Coverage Library for Haskell  http://hackage.haskell.org/package/hpc-0.5.0.6 (RossPaterson)
05:47:17 <Botje> visit next valid visited start = Tree $ map (visit next valid (start:visited)) $ filter (not . (`elem` visited)) $ filter valid $ next start
05:47:23 <quicksilver> RossPaterson++ # quality hackage spam
05:47:25 <hpc> i have been pinged by hackagebot
05:47:27 <Botje> there. non-backtracking depth-first search
05:47:37 <Botje> in one line
05:47:42 <Botje> I'm a bit surprised myself :)
05:47:59 <quicksilver> Botje: the O(n^2) is a bit unfortunate, but easily fixed.
05:48:07 <quicksilver> at the cost of an Ord constraint.
05:48:12 * hackagebot old-time 1.0.0.6 - Time library  http://hackage.haskell.org/package/old-time-1.0.0.6 (RossPaterson)
05:48:14 * hackagebot pretty 1.0.1.2 - Pretty-printing library  http://hackage.haskell.org/package/pretty-1.0.1.2 (RossPaterson)
05:48:16 * hackagebot process 1.0.1.4 - Process libraries  http://hackage.haskell.org/package/process-1.0.1.4 (RossPaterson)
05:48:18 * hackagebot random 1.0.0.3 - random number library  http://hackage.haskell.org/package/random-1.0.0.3 (RossPaterson)
05:48:20 * hackagebot template-haskell 2.5.0.0 -   http://hackage.haskell.org/package/template-haskell-2.5.0.0 (RossPaterson)
05:48:27 <quicksilver> Botje: actually, no, it's wrong :)
05:48:48 <quicksilver> Botje: you don't thread the visited between the conceptually 'parallel' functions executed by 'map'
05:49:14 <Botje> quicksilver: then it depends on which branch you evaluate, surely?
05:49:22 * hackagebot unix 2.4.1.0 - POSIX functionality  http://hackage.haskell.org/package/unix-2.4.1.0 (RossPaterson)
05:49:48 <quicksilver> if A has neighbour set [B,C] and B,C both have neighbour 'D'
05:50:00 <quicksilver> then when you recurse on B (resp. C) your visited list is only [A]
05:50:05 <quicksilver> so you get D twice
05:50:10 <quicksilver> no?
05:50:15 <Botje> hmm. yes
05:50:27 <Jafet> Indeed. You need a fold, ST or equivalent
05:50:32 <quicksilver> the way to fix that but keep it in the same form is to change map to mapM
05:50:32 <Botje> boo :(
05:50:36 <quicksilver> where the monad is a state monad
05:50:40 <quicksilver> which stores visited for you
05:50:41 <Jafet> And by then it is no longer one line, so you might as well use Set
05:50:54 <Botje> you could do the boring stack thing too
05:50:59 <Botje> but that's not as sexy :P
05:51:16 <quicksilver> mapM in the state monad is precisely the thing which threads things like visted among sub calls :)
05:51:21 <quicksilver> it's a classic example.
05:51:41 <quicksilver> mapM in the state monad is so significant it also exists in an unrolled version
05:51:42 <byorgey> on the other hand, Botje's code is a nice way to generate all possible paths of maximal length ;)
05:51:44 <quicksilver> :t mapAccumR
05:51:45 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
05:52:39 --- mode: ChanServ set +o copumpkin
05:52:46 --- mode: copumpkin set +b girl22!*@*
05:52:47 --- kick: girl22 was kicked by copumpkin (no spam please)
05:53:05 * cathper gets "zsh: segmentation fault  ghci" when running his program :-(
05:54:05 <cathper> Or, running ghci, actually.
05:54:12 <diabolo_> ok... so in a simple question and 5min here I got 3years of stuff to research and try to understand
05:54:17 <diabolo_> this place is awesome
05:54:37 <cathper> But running a compiled version also segfaults.
05:56:03 <therp> diabolo_: we call it the #haskell problem
05:57:44 --- mode: copumpkin set -o copumpkin
05:58:01 <lars9> what is "..." ?
05:58:11 <lars9> instance Monad IO where return a = ... 
05:58:24 <Cale> lars9: An omission
05:58:33 <Cale> (not Haskell syntax)
05:59:06 <Cale> lars9: The exact implementation of the monad operations on IO is implementation dependent.
05:59:18 <lars9> Cale: i see, thanks
05:59:20 <Cale> (they're primitive)
06:00:10 <lars9> i see
06:01:14 <byorgey> diabolo_: =)
06:01:57 <byorgey> cathper: how did you install it?
06:02:54 <cathper> byorgey: It's installed via the package system on ubuntu as far as I know. (I run it on one of the servers at the department.)
06:05:16 <byorgey> cathper: I see. that's unfortunate =(
06:06:17 <cathper> byorgey: I'll try on my mac.
06:06:30 <therp> I have some custom monad M. I would like to write something in the ST Monad that interacts with the M monad. I cannot figure out a way to stack these monad properly, the first thing that comes to my mind is to lift the actions of m into ST, but lift doesn't work with the kind of ST.
06:06:34 <cathper> It's 6.12.1 btw.
06:09:07 <byorgey> therp: you will need one of the two to be a monad transformer.
06:09:36 <byorgey> therp: there is a transformer version of ST in a package on hackage, but you have to be careful with it (it is not safe for use with all monads)
06:10:06 <therp> byorgey: I turned my monad into a transformer, and added a monad class so to make everything transformed an instance of that monad class
06:10:26 <therp> byorgey: still, I feel clueless..
06:10:58 <byorgey> therp: so now the thing you need to apply 'lift' to is ST computations
06:11:16 <byorgey> to lift them to computations of type   MyMonadT (ST s) ...
06:11:24 <therp> byorgey: but how would I then run an ST computation?
06:11:36 <therp> runMyMonadT $ runST ?
06:11:56 <byorgey> no, more like  runST . runMyMonadT
06:12:03 <byorgey> you have to run the outer monad first
06:12:05 <tomh> hey anyone can explain the advantages of using FRP vs not using FRP? I read some stuff but I still don't entirely see why it improves software
06:12:22 <therp> ok.. hmm
06:13:02 <therp> oh that works indeed at least typecheck wise
06:14:03 <xplat> tomh: basically the reason FRP is better than traditional event-based programming is the same reason STM is better than locks
06:14:24 <byorgey> therp: have you read http://cale.yi.org/index.php/How_To_Use_Monad_Transformers ?
06:14:39 <tomh> xplat, care to eleborate?
06:14:42 <therp> byorgey: nope, not yet. thanks for the pointer
06:14:59 <xplat> composability; meaning that you are able to create reusable pieces whose meaning doesn't depend on everything else going on in the entire program in a weird and counterintuitive way
06:16:27 <tomh> what would such behavior piece be?
06:16:42 <tomh> if you have a character in a game for example
06:16:56 <tomh> and you have it moving around and there is physics
06:17:30 <tomh> physics updates the characters position and pressing keys updates the characters position
06:17:33 <chrisdone> can someone explain why this works without a type signature but not with? http://hpaste.org/41527/what_the_hell
06:18:36 <Cale> chrisdone: huh...
06:18:38 <therp> byorgey++ thanks! that approach seems to be the right one!
06:18:39 <chrisdone> it's the Data.Has library which uses those magic type families
06:18:56 <xplat> tomh: FRP is actually very good for that scenario.  you can express your character physics in a functional way instead of iterative.
06:19:02 <Cale> chrisdone: Which GHC?
06:19:12 <chrisdone> Cale: I can reduce it to a single test-case file if you don't see anything obvious
06:19:16 <Cale> chrisdone: That might be worth reporting if it happens with the new type system
06:19:19 <chrisdone> 6.12.3
06:19:19 <tomh> xplat, what if you use a 3rd party physics library
06:19:43 <Cale> I can't think of a good reason for that to happen.
06:19:58 <chrisdone> hmm. I see
06:20:42 <Cale> GHC 7 came out today, and it has an overhauled typechecker
06:20:52 <xplat> tomh: then it really depends on how much you are putting on top of the 3rd-party library, whether it is worthwhile to wrap it for FRP
06:21:14 <copumpkin> omg chrisdone is alive
06:21:21 <chrisdone> a proper release?
06:21:26 <Cale> yep
06:21:27 <chrisdone> oh, nice
06:21:35 <chrisdone> I'll install it
06:21:36 <xplat> oh wow
06:22:04 <chrisdone> hi copumpkin :)
06:22:07 <tomh> xplat, so if I understand correctly, the x,y position of a character would be a "behavior" ?
06:22:18 <chrisdone> I grabbed RC2 the other day but didn't have time to try it
06:22:24 <Rutix> chrisdone is an undead :>
06:23:42 <xplat> tomh: usually.  (terminology is a little inconsistent between different libs, but that seems to be the mainstream...)
06:25:00 <gds> xplat: Do you recommend a particular FRP lib for haskell atm?
06:25:20 <gds> (last time I was curious, there were many alpha/beta ones, and no clear community leaders)
06:26:12 <tomh> I dont think there is a commonly accepted idea yet of what FRP encapsulates right
06:29:21 <Yvemath> What's a word32 :S in haskell lang. ?
06:29:47 <luite> you mean a Word32 (from Data.Word) ?
06:30:00 <luite> that's a 32 bit unsigned integer
06:30:01 <Yvemath> possibly, yeah.
06:30:49 <Yvemath> luite: How to convert (x,y) dimension into a Data.Word ?
06:31:39 <luite> Yvemath: you may want to look into bitwise operations from Data.Bits
06:31:58 <Yvemath> luite: okay, thanks :)
06:32:31 <luite> I'm not sure what you want to do though, do you want to pack those dimensions to write it to a file?
06:33:07 <paolino> chrisdone: what is the type of xxx at ghci instead of () ?
06:34:02 <chrisdone> Î»> :t xxx
06:34:02 <chrisdone> xxx :: ()
06:34:59 <paolino> it couldn't be anything else I suppose
06:36:03 <Cale> Yvemath: Yeah, what is it that you're trying to accomplish?
06:36:56 <Nibble> where is manatee :(
06:37:11 <chrisdone> Nibble: being a lazy cat, sleeping
06:37:12 <Yvemath> Cale,luite : New to haskell, and trying to dig Xmonad.Core files [Just trying to interpret]
06:37:18 <Nibble> chrisdone: :(
06:37:24 <Nibble> I thought them asians didn't do that shit
06:37:29 <Cale> Nibble: <ManateeLazyCat> Bye all, coding time...
06:37:57 <Cale> (that was around 8am EST)
06:38:09 <lars9> Yvemath: xmonad is hard for new...
06:38:33 <Yvemath> lars9: yeah, looking like it from experience, hehe.
06:38:50 <Nibble> xmonad is neat
06:39:20 <lars9> Nibble: that means you are not new
06:39:44 <lars9> Yvemath: hi how to pronounciate "yv"?
06:39:47 <chrisdone> cabal: cannot configure curl-1.3.5. It requires base <3 There is no available version of base that satisfies <3
06:39:53 <chrisdone> ah, I can see upgrading to 7 is going to be fun
06:40:05 <Yvemath> lars9: evematt
06:40:24 <lars9> Yvemath: great, i can read it now:)
06:40:26 * chrisdone sings the manual-editing-of-package-configs song
06:40:51 <Yvemath> :-)
06:41:37 <xplat> gds: i'll be able to give a better recommendation in a couple of weeks, i'm starting a big project based on FRP in haskell then, i've been doing it in scala lately where there's really only one library.  if i had to choose something right now i'd go with Reactive (Data.Reactive)
06:42:04 <gds> xplat: I'll be here - if you have thoughts, I'd love to hear them :)
06:42:40 <Boxo> I'm trying to install a package using cabal. I did "cabal install blah", but when I try to import it into ghci, it's not found
06:42:46 <Boxo> What are you supposed to do here?
06:42:58 <Cale> chrisdone: whoa, base less than 3?
06:43:01 <Nibble> Boxo: do ghc-pkg check or something like that
06:43:02 <chrisdone> Boxo: restart ghc
06:43:10 <paolino> chrisdone: it is strange the typechecker do different paths when you give a signature but it doesn't need it
06:43:15 <Boxo> chrisdone: I did
06:43:31 <chrisdone> boxo: how are you importing it?
06:43:37 <Boxo> :m +
06:43:38 <Cale> chrisdone: That constraint has been unsatisfiable for a long time
06:43:54 <Cale> I don't even remember which ghc had a base-2
06:44:03 <Boxo> ghc-pkg check says "WARNING: cache is out of date"
06:44:39 <Nibble> Boxo: do something about it then
06:44:41 <Nibble> off you go
06:44:44 <Cale> ummm
06:44:50 <Cale> Boxo: which package?
06:44:56 <Boxo> "Probability"
06:45:27 <Boxo> it said to use "ghc-pkg recache" to fix, but that didn't work.
06:45:36 <chrisdone> Cale: http://hackage.haskell.org/package/curl
06:45:43 <chrisdone> hehe
06:45:53 <Cale> chrisdone: yeah, so base 3.* is okay
06:45:55 <chrisdone> I'll bump Sigbjorn
06:46:05 <Cale> chrisdone: Does ghc not have any base-3 at all?
06:46:12 <Cale> ghc 7, that is
06:46:13 <Boxo> I'm on Windows btw
06:46:16 <chrisdone> ghc7 stopped supporting it. I read that in the change log somewhere
06:46:35 <chrisdone> "GHC 7 doesn't support base 3 because that was old years ago" kind of thing
06:46:49 <chrisdone> http://haskell.org/haskellwiki/Upgrading_packages/Updating_to_GHC_7
06:46:56 <chrisdone> There is no base 3 now, after being deprecated for several years, so dependencies on base 3 won't compile with GHC 7.
06:47:33 <Cale> And you're using something like  :m + Numeric.Probability.Distribution
06:47:34 <Cale> ?
06:47:47 <Cale> (Boxo)
06:47:51 <Boxo> I'm just trying to impoty Numeric.Probability to start with
06:47:57 <Boxo> s/impoty/import
06:48:03 <Cale> Boxo: That module doesn't exist.
06:48:27 <Boxo> oh! :D
06:48:29 <chrisdone> the modules aren't properly hierarchical, it's flat. X.Y doesn't have to exist for X.Y.Z.Foobar
06:48:37 <Boxo> cool, Numeric.Probability.Distribution does work
06:49:57 <Cale> Unfortunately, that library is maintained by Henning Thielemann, so it's pretty annoying to use.
06:50:58 <Cale> He sabotages almost every piece of code he touches by naming all his types T and all his typeclasses C.
06:50:59 <Boxo> I'm writing a literate haskell blog post, just want to have as well-known a probability librarry as possible
06:51:57 <arcatan> Cale: has somebody told him that it's not the common naming convention, anyway?
06:52:09 <Cale> arcatan: He knows, I'm sure.
06:52:43 <arcatan> okay
06:52:47 <Cale> I've considered writing a tool to try to undo this kind of sabotage systematically, but it's kind of tricky.
06:53:46 <Rembane> Build and electrifying keyboard instead?
06:53:49 <quicksilver> Cale: if qualified imports were a bit more thorougly implemented - including renaming of individual values/types, and re-exporting qualifications or renames - it would be fine.
06:54:11 <quicksilver> Cale: 'fine' in the sense that you could undo the sabotage but also 'fine' in the sense that the .T .C thiing wouldn't be that hard to use either.
06:54:25 --- mode: quicksilver set -o quicksilver
06:56:11 <cathper> byorgey: I have a line like foo a = lst where lst is a list of length 15400; for a list of length 4845 it doesn't segfault.
06:56:15 <Cale> Perhaps the worst thing about the .T/.C thing is that tools like Haddock have no idea how or if they ought to qualify the names, and so don't qualify them. (though Haddock should probably do better at borrowing qualifications from the source code where it can)
06:56:18 <chrisdone> quicksilver: didn't haskell 1.4 or earlier have the `renaming' clause on imports?
06:58:48 * Cale wonders why the ProbabilityMonads package reimplements WriterT and (,) w despite depending on mtl
06:59:20 <lars9> it seems mtl is talked a lot, what do you use it for?
06:59:47 <Cale> lars9: It's the library containing all the standard monad transformers and a bunch of basic monads.
07:01:01 <Cale> State, Reader, Writer, Cont, and the associated monad transformers
07:01:38 <Cale> Oh, I see, they didn't want to implement tell, listen and pass
07:01:43 <Cale> For some reason
07:01:51 <Cale> Despite those being quite implementable.
07:02:29 <quicksilver> Cale: to be fair, it's not really fair to rule out a valid use of the module system just because haddock can't cope. That's a haddock deficiency.
07:02:33 <lars9> @hoogle Reader
07:02:33 <lambdabot> module Control.Monad.Reader
07:02:33 <lambdabot> Control.Monad.Reader newtype Reader r a
07:02:33 <lambdabot> Control.Monad.Reader Reader :: (r -> a) -> Reader r a
07:03:09 <lars9> @hoogle Tell
07:03:10 <lambdabot> Control.Monad.Writer.Class tell :: MonadWriter w m => w -> m ()
07:03:10 <lambdabot> System.IO hTell :: Handle -> IO Integer
07:03:27 <Cale> quicksilver: Well, I suppose if Haddock were to just rely on the way in which the source code qualified things, that would be mostly fixed.
07:03:29 <quicksilver> Cale: however, it's not just haddock - it's also the fact that you can't 'abstract' your chosen nicknames/naming conventions, so you need multiple lines of the form 'import Foo.Bar(T,C) qualified as X' at the top of each file.
07:04:05 <lars9> @google lambdabot
07:04:05 <Mitar> how can I make a link to heading with haddock?
07:04:06 <quicksilver> Cale: that's the part that annoys me. If I could refactor those bits into a single "module CommonRenames where ...." then I'd be just about happy with it.
07:04:08 <lambdabot> http://www.haskell.org/haskellwiki/Lambdabot
07:04:08 <lambdabot> Title: Lambdabot - HaskellWiki
07:05:06 <Cale> quicksilver: Sure.
07:05:45 <Cale> (though it still sucks to have to build things like that to isolate yourself from poor naming conventions)
07:06:42 <roconnor> anyone here know much about UHC?
07:06:53 <sipa> :t gmap
07:06:54 <lambdabot> Not in scope: `gmap'
07:07:54 <quicksilver> Cale: there is an argument which can be made that 'mapM' and 'sequenceA' are poor naming conventions
07:08:11 <quicksilver> ...but we're forced into them because we find our module/qualification scheme too ugly to actually use in practice.
07:12:05 <HaskellElephant> Talking to you from manatee now =D, seems to be veeery beta!
07:12:06 <Cale> I think of qualification as always being an ugly necessity.
07:12:54 <Cale> It's something which we support because if we didn't then it would be impossible for the world to scale up, because eventually you're going to run into two modules defining the same name. But it's not something that you want to use.
07:14:29 <quicksilver> Cale: I think I would find it quite pleasant if "List.map" was rendered by my editor as "map_{\small List}"
07:14:30 <joe6> are  a lot of guys checking out ghc 7?
07:14:48 <quicksilver> Cale: (although that would mess up any fixed-width font alignment tricks)
07:14:58 <Cale> quicksilver: It'd still be annoying to type.
07:15:09 <Cale> (unless the editor could guess for you)
07:15:26 <Cale> joe6: I will be
07:16:01 <joe6> cool. are you excited about it? I was, when I saw the announcement. but, then was scared too about how many of the libraries might work..
07:16:56 <quicksilver> Cale: I'm not sure annoying to type is the right argument.
07:17:05 <quicksilver> Cale: M.map is not substantially harder to type than mapM
07:17:33 <osaunders> Do you think you can compile GHC with 64MB of RAM?
07:17:55 <Nibble> osaunders: I don't think so
07:18:18 <monochrom> perhaps you will like my Rename When Import: http://article.gmane.org/gmane.comp.lang.haskell.cafe/83298/
07:18:20 <osaunders> What about 128MB?
07:18:40 <Mitar> how can I make a link to heading with haddock?
07:18:50 <Nibble> osaunders: most likely not
07:19:27 <Botje> cabal update hard-locked my 1GB netbook
07:19:39 <dcoutts> exciting
07:19:46 <Botje> so i would say two, at least :)
07:20:09 <Cale> monochrom: We'd also want to be able to export the renamed stuff.
07:20:12 <Cale> (of course)
07:20:31 <dcoutts> Botje: was it swap death? e.g. perhaps it was using up all memory
07:20:41 <Botje> yes
07:20:53 <dcoutts> Botje: are you able to reproduce it?
07:20:59 <Botje> hitting ctrl-c, ctrl-z and ctrl-\ enough times eventually got me through
07:21:04 <Botje> dcoutts: it was a long time ago
07:21:05 <dcoutts> Botje: perhaps using a ulimit for safety
07:21:10 <monochrom> ha, I haven't thought of exporting renamed stuff.
07:21:19 <Botje> i'll try stealing my netbook back sometime
07:21:34 <Botje> have to update it to ubuntu 10.10 anyway
07:21:40 <dcoutts> Botje: ah ok, well if it recurs then more details would be great
07:21:43 <Cale> monochrom: Importing with a whole bunch of renames every time would get tedious
07:21:56 <Cale> It's already tedious enough that I end up doing:
07:21:59 <dcoutts> Botje: my suspicions would fall on the HTTP lib :-)
07:22:02 <Cale> import qualified Data.Set as S
07:22:07 <quicksilver> monochrom: the main problem with qualifications is that they can't be re-exported.
07:22:07 <Cale> import Data.Set (Set)
07:22:13 <Cale> every single damn time
07:22:29 <quicksilver> monochrom: renaming is also useful but would also be a similar issue.
07:23:07 <Cale> (same issue with Data.Map, Data.Sequence, and a bunch of others)
07:23:36 <Cale> Another thing I hate about qualified names is that the module path separator looks like function composition
07:23:48 <Cale> (quicksilver's idea would solve that)
07:24:28 <Cale> and for some reason that I don't understand, I just cannot tolerate qualified names in types
07:26:29 <osaunders> Cale: What's Quicksilver's idea?
07:26:45 <quicksilver> osaunders: just an idea of graphical presentation
07:26:56 <Cale> osaunders: Displaying Foo.bar as bar with a small Foo as subscript
07:26:57 <osaunders> I think pointfree actually sees module qualification as function composition.
07:26:59 <quicksilver> osaunders: display M.map as map_M (the M subscript in a small font)
07:27:27 <Cale> osaunders: It does.
07:27:34 <quicksilver> it's reasonably consistent with mathematical convention
07:27:38 <Cale> osaunders: Because it has no idea that modules even exist
07:27:42 <quicksilver> and it even doesn't look too bad on operators
07:27:46 <quicksilver> *_vec
07:27:47 <Cale> osaunders: Or list comprehension syntax for that matter
07:27:57 <quicksilver> (as long as the font size is really quite small)
07:28:35 <osaunders> @pl f xs = [ x  * 2 | x <- xs ]
07:28:36 <lambdabot> f = return . (x *) . ((2 | x) <-)
07:28:55 <osaunders> Interesting
07:29:34 <Botje> how hard would it be to hack list comprehensions into @pl?
07:30:21 <leo2007> what's the most popular IDE for haskell?
07:30:24 <osaunders> Botje: You could probably just have it ignore them fairly easy as a reasonable start. Better than getting it wrong.
07:31:06 <osaunders> leo2007: vi (src: http://blog.johantibell.com/2010/08/results-from-state-of-haskell-2010.html)
07:31:08 <Botje> leo2007: leksah is nice
07:31:34 <osaunders> leksah won't install for me :(
07:31:41 <gds> leo2007: If no-one else is going to mention it, then I'll say "emacs" :)
07:31:51 <osaunders> gds: Emacs is 2nd
07:32:02 <gds> osaunders: Oh, there are stats? :)
07:32:09 <osaunders> ^^ see my link
07:32:12 <gds> heh :)
07:32:14 <gds> Cheers :)
07:32:38 <lars9> i like vim now
07:32:54 <lars9> emacs cannot do indent of if/else well
07:33:06 * gds switches between vim and emacs every 6 months or so.
07:33:13 <ChongLi> hi
07:33:14 <ChongLi> I love vim
07:33:19 <gds> I'm also quite curious about this manatee thing....
07:33:30 <ChongLi> the whole if/then/else thing is weird
07:33:44 <ChongLi> half a tabstop indent :P
07:33:59 <monochrom> emacs indents if-then-else correctly for me.
07:34:06 <chrisdone> Cale: monadrandom fails to build too
07:34:15 <gds> Indeed, it seemed fine to me just recently.
07:34:17 <Cale> chrisdone: I'm aware
07:34:47 <Cale> (If someone wants to fix it and upload a new version, go for it)
07:34:50 <gds> (it==emacs "if" indeting)
07:35:32 <Cale> The correct way to indent if/then/else looks like:
07:35:34 <Cale> if foo
07:35:36 <Cale>    then bar
07:35:38 <Cale>    else quux
07:36:00 <Cale> (or any other variation where 'then' and 'else' start in the same column)
07:37:22 <leo2007> gds: I use emacs. what's the favourite emacs setup for haskell devel? Is there something similar to slime (for common lisp)?
07:38:03 <Cale> http://projects.haskell.org/haskellmode-emacs/
07:38:10 <gds> Yeah, that :)
07:38:25 <gds> In ubuntu, a lot of things work pretty well out of the box.
07:38:29 <Cale> (I use vim more than I use emacs though)
07:38:36 <Entroacceptor> leo2007: and there's an addon for autocomplete
07:38:43 <ski> @where haskell-mode
07:38:44 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
07:39:11 <onteria> I like leksah, though the on demand compiling can get kind of weird if you don't hide the log window
07:39:54 <quicksilver> lars9: if you think emacs can't indent if/then/else correctly then you're using the wrong haskell mode, or you're using it wrong.
07:40:02 <quicksilver> it is absolutely fine for if/then/else
07:40:19 <gds> leo2007: Take a look at the wiki there - if you're running ubuntu then a lot of the stuff is already set up for you. I only had to add one or two things for getting mmm-mode to work how I wanted with literate haskell sources.
07:40:48 <gds> leo2007: If you're just editing .hs files, or .lhs files without extensive markup, then it may well do everything you want already.
07:41:02 <onteria> Honestly though the best way to find out which IDE works best is to give them all a shot and see which one is the most comfortable to work with
07:41:04 <gds> Try hitting C-c C-l in your source file and see what happens :)
07:41:28 <monochrom> the 3rd IDE you try is the best
07:42:03 <lars9> quicksilver: my emacs indent else to the same colum of if...
07:43:15 <gds> lars9: Oh yeah, mine is doing that too - I guess I don't use if statements all that often ;)
07:44:10 <quicksilver> lars9: sounds like you're using the wrong haskell mode, yes
07:44:17 <quicksilver> get the one from the URL cale posted.
07:44:29 <quicksilver> if will allow then/else to indent as the same column as if in an expression context
07:44:36 <quicksilver> but it will never do so in a do block
07:44:40 <quicksilver> which is correct.
07:45:36 <Cale> I could never get used to hitting tab to indent lines properly after typing the first keyword on the line
07:46:46 <lars9> quicksilver: i installed haskell-mode from archlinux's repo. anyway, i've switched to vim, and the haskell mode for vim is good too
07:46:52 <gds> leo2007: Heh - so I guess the out-of-the-box stuff in ubuntu isn't as good as the stuff being bandied about here - ignore me :)
07:47:21 <lars9> quicksilver: i didn't use any of emacs haskell-mode's advanced feature
07:47:30 <quicksilver> fair enough :)
07:48:07 <lars9> quicksilver: it seems the only thing i used is indent :D
07:48:57 <lars9> @instances Arrow
07:48:58 <lambdabot> (->), Kleisli m
07:49:13 <lars9> @instances Control.Arrow
07:49:13 <lambdabot> Couldn't find class `Control.Arrow'. Try @instances-importing
07:49:27 <lars9> @instances-importing Control.Arrow
07:49:28 <lambdabot> Couldn't find class `Control.Arrow'. Try @instances-importing
07:49:37 <lars9> @instances-importing Control.Arrow Arrow
07:49:37 <lambdabot> (->), Kleisli m
07:50:03 <ksf> we badly, badly need to rewrite k-nucleotide.
07:50:12 <ksf> 34 times slower than c++
07:51:52 <quicksilver> Cale: I forgive it that because haskell syntax is such that there must be some compromise
07:52:00 <quicksilver> Cale: I'm happy with the compromise it chose
07:53:53 <leo2007> ok, thanks guys. I am installing haskell mode.
07:56:55 <lars9> found a interesting post: More on Haskell's hash table problems http://flyingfrogblog.blogspot.com/2009/04/more-on-haskells-hash-table-problems.html
07:57:21 <lars9> is it true that hash table performs poorly in haskell because a bug of gc?
07:58:31 <luite> hehe the author of that blog might be slightly biased though... he's well known in the haskell community for that :)
07:59:44 <monochrom> however, our current hash table is slow.
08:00:06 <Cale> Where by "slightly biased" you mean "troll"
08:00:06 <roconnor> C++ has runtime type information?
08:00:07 <ksf> the entry was faster, once.
08:00:31 <ksf> it's age-old optimisation tricks hitting the fan.
08:00:32 <Botje> roconnor: stored in the vtables, yes
08:00:56 <roconnor> Botje: hmm
08:01:04 <monochrom> they even have the acronym RTTI for that
08:01:09 <Botje> roconnor: look up dynamic_cast
08:01:29 <Botje> for one use case
08:01:29 <ksf> omg how can a 114m bz2 expand to a 830m install.
08:02:23 <monochrom> oh haha scary
08:02:48 * monochrom postpones trying ghc 7!
08:02:58 <Nibble> monochrom: llvm yay!
08:02:59 <roconnor> Botje: this is horrible!
08:03:21 <lars9> Nibble: llvm where?
08:03:31 <Nibble> lars9: ghc 7?
08:03:41 <roconnor> that means C++ is the worst of C++ and python combined.
08:03:56 <Botje> roconnor: you can disable it with -fno-rtti, iirc, and almost everyone does :]
08:04:17 <roconnor> everyone does?
08:04:23 <Zao> Botje: I reject that opinion.
08:04:31 <Zao> Only idiots disable a fundamental part of the language.
08:04:38 <roconnor> Botje: that is a relief though
08:04:44 <ben> I do not think a lot of people do that.
08:04:54 <ben> Does that break exceptions?
08:04:57 <Quadrescence> Hm, how would you guys write a function f :: (a -> a -> b) -> [a] -> [b] such that f [] = []; and f [q1,q2,q3,q4,..] = [f q1 q2, f q2 q3, f q3 q4, ...]
08:05:05 <Zao> "oh hi, I'm going to remove fundamental parts of the language. I hope you weren't using things that depend on it, lol"
08:05:15 <Zao> ben: Probably.
08:05:20 <roconnor> Zao: how is it fundamental if "In the original C++ design, Stroustrup did not include run-time type information, because he thought this mechanism was frequently misused[1]."
08:05:24 <ben> well that sounds like a great plan
08:05:34 <sipa> Quadrescence: what about f [a] ?
08:05:38 <ben> roconnor: because removing it breaks exceptions
08:05:48 <Zao> roconnor: How does Bjarne's original design matter with modern standardized C++?
08:05:49 <Cale> Quadrescence: zipWith f xs (tail xs)
08:05:54 <Quadrescence> sipa: eh let's just say f [a] = [f a]
08:06:05 <Quadrescence> Cale: coolio
08:06:08 <Zao> In any way, anyone who attempts to foresee all possible uses of a tool are foolish.
08:06:17 <Zao> I quite doubt that anyone foresaw modern TMP.
08:06:18 <Botje> Zao: well, at least game developers disable it. which is still a lot of code, no ? :)
08:06:40 <Zao> Botje: On consoles, you're a freestanding very special implementation.
08:06:46 <Jafet> Games don't have that much code. Not enough for all this to be on-topic, anyway.
08:06:58 <roconnor> ben: how are exceptions broken?
08:07:01 <Zao> Botje: On PC games, you don't really need to, but there's a lot of bad guidelines.
08:07:18 <Zao> Botje: As for total amount of code, I'd say business applications far outweigh games.
08:07:38 <Quadrescence> Cale: and woops, I just realized I said that problem incorrectly, but you still said what I wanted.
08:07:59 <Zao> Heck, does dynamic_cast even work with RTTI disabled?
08:08:01 <sipa> Quadrescence: you left out the function as argument
08:08:06 <Quadrescence> sipa: I know.
08:08:49 <roconnor> clearly dynamic_cast won't work
08:09:20 <ben> roconnor: Okay, I was wrong there. According to the manpage, exception handling generates rtti even with -fno-rtti.
08:09:34 <roconnor> oh
08:09:46 <roconnor> ben:  I consider you mostly right
08:09:59 <diabolo_> Quadrescence, f g xs = zipWith g xs (tail xs) ?
08:10:32 <Quadrescence> Cale: how about something a little more challenging:   mystery :: ([a] -> b) -> Integer -> [b], which does the same thing, but:  mystery f 3 [a,b,c,d,e] ==> map f [[a,b,c], [b,c,d], [c,d,e], [d,e], [e]]
08:10:49 <ben> I think exceptions are fundamental for C++ because a lot of what they call modern C++ revolves around using exceptions for error handling augmented by their RAII, but I guess C++ without either wouldd still be an interesting langauge for games programmers.
08:11:01 <Jafet> C++ is normally on-topic here, but disabling RTTI makes it no longer standard C++, and thus off-topic, Zao.
08:11:16 <Quadrescence> Jafet: haha
08:11:18 <Zao> :D
08:11:24 <Jafet> But if you made a comparison to the dreaded monomorphism restriction in Haskell, it would be on-topic again!
08:11:31 <Cale> map (f . take 3) . iterate (drop 1)
08:11:42 <lars9> ghc7 has a llvm built-in? not a patch?
08:11:52 <Cale> lars9: yes
08:12:21 <Quadrescence> :t \n -> (map (f . take n) . iterate (drop 1))
08:12:22 <lambdabot> forall b a. (Show a, SimpleReflect.FromExpr b) => Int -> [a] -> [b]
08:12:28 <lars9> wow, dunno how much it improves
08:12:31 <Quadrescence> :t \f -> \n -> (map (f . take n) . iterate (drop 1))
08:12:32 <lambdabot> forall b a. ([a] -> b) -> Int -> [a] -> [b]
08:12:46 <Quadrescence> Cale: it looks like we have a winner
08:13:16 <Quadrescence> what is the pointless^H^H^H^Hfree command again?
08:13:54 <ben> @pl \a b c d e f g -> g f e d c b a
08:13:55 <lambdabot> flip (flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .) . flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id)))))
08:14:05 <Jafet> No pointfree command, only pointless
08:14:19 <roconnor> ben: catch needs RTTI to operate?
08:14:22 <Quadrescence> @pl \f -> \n -> (map (f . take n) . iterate (drop 1))
08:14:22 <lambdabot> flip flip (iterate (drop 1)) . (((.) . map) .) . (. take) . (.)
08:14:34 * Quadrescence shakes head...
08:15:03 <ben> roconnor: I figure the naive implementation of throw would loop through all recorded catch statements and compare their caught type against the type of the thrown object, or something?
08:15:28 <roconnor> ben: it does seem that way doesn't.
08:15:46 <Jafet> ben: which requires that the type info be available at runtime?
08:15:59 <ben> Of the few types that are thrown/caught, at least
08:16:04 <Botje> how do you add RTTI to 'int', then?
08:16:05 <roconnor> IIRC JHC used RTTI to do typeclass dispatching in Haskell.
08:16:18 <roconnor> Botje: I was wondering that myself.
08:16:44 <ben> Botje: At compile time, you know that you are throwing an int. So you grab the std::type_info object for ints.
08:17:12 <Botje> ah, cool :)
08:17:50 <ben> In that case, the type info is not actually in the vtable, though, yeah ;)
08:17:58 <roconnor> ben: so it wraps in int in what is effectively an object wrapper?
08:18:26 <roconnor> Like Java's Java.whatever.Integer class?
08:18:48 <ben> roconnor: on the catch site it is an int again, nobody really handles it as an object of unknown type :3
08:18:53 * hackagebot websockets 0.2.0.1 - Create WebSocket servers  http://hackage.haskell.org/package/websockets-0.2.0.1 (SinisaBidin)
08:19:11 <ben> I am not familiar enough with the details but I do not think ints get boxed.
08:19:16 <roconnor> ben: understood
08:19:41 <roconnor> oh? not boxed?
08:19:44 <ben> Note that the catch-all specifier "catch (...) { }" does not let you refer to the object
08:20:00 <roconnor> but catch (int i) { } does
08:20:15 <ben> Yeah, but then it is statically known that you are throwing and catching an int
08:20:43 <ben> The really run-time part of rtti only happens with classes with virtual functions
08:22:14 <roconnor> It isn't statically known that you are throwing and catching an int.  It may be statically know you are throwing and int, and somewhere else it may be statically known you are catching an int, but not statically known together
08:22:32 <roconnor> for example if I call a virtual function that may or may not throw an int exception.
08:22:56 <Quadrescence> @pl \lst -> (sum lst)/(length lst)
08:22:57 <lambdabot> liftM2 (/) sum length
08:23:15 <ben> I suspect comparing std::type_info objects happens there
08:23:37 * roconnor looks up std::type_info
08:24:45 <roconnor> ben: so the integer is paired up with this object in the exception?
08:25:18 <ben> I suppose
08:25:42 <roconnor> I guess that is what I was thinking by "boxed".  But I supposed you are right that "boxed" isn't really the right term for this.
08:26:14 <ben> I did not think of it as "boxed" because you only ever get an int out at the other end and there is no evidence there is ever a single object containing both the int and the type_info object :)
08:26:45 <roconnor> ok
08:32:38 <quicksilver> there is a distinction between rtti as a tool for exceptions, and rtti as a language feature.
08:32:52 <quicksilver> C++ implementations are free to implement try/catch in any way which makes sense to them.
08:33:11 <quicksilver> they may or may not re-use some of the implementation ideas they use to implement rtti-the-language-feature.
08:33:49 <roconnor> quicksilver: are expetions, in general, possible to handle without RTTI?
08:33:51 <quicksilver> a C++ interpreter might take a different approach to a C++ compiler.
08:34:25 <quicksilver> roconnor: that depends on a lot of other things, like whether your implementation supports separate compilation.
08:34:40 <quicksilver> (AFAIK that's not a requirement of the C++ standard. ICBW. I certainly havent' read the standard)
08:35:03 <roconnor> quicksilver: I'll give you liberty on that.  You are allowed whole program compilation and no dynamic libraries.
08:35:36 <quicksilver> then there are a whole class of programs which certainly need no such mechanism because all the throw/catch paths can be statically detected.
08:36:02 <roconnor> quicksilver: yes, but can all programs be done without RTTI
08:36:03 <quicksilver> I think you can probably use whatever mechanism you use for template instantiation too.
08:36:15 <roconnor> you compiler has to compile all programs.
08:36:18 <roconnor> *your
08:36:24 <quicksilver> having a "catch (foo f) { ... }" statement somewhere 
08:36:39 <quicksilver> is a rather similar problem to automatically instantiatiating the code for vector<foo>
08:36:56 <roconnor> quicksilver: it doesn't really seem all that similar to me
08:37:30 <quicksilver> certainly you don't need full RTTI - it suffices to assign a tag to all the types that will ever be caught
08:37:53 <quicksilver> and you only actually tag values that are thrown
08:37:54 <roconnor> isn't RTTI assinging a tag to types.
08:38:13 <quicksilver> RTTI means that you can work out, at runtime, the type of every single value
08:38:22 <quicksilver> generally that's a fairly high cost.
08:38:28 <roconnor> sure you don't need to put runtime typeing information on all types, but you will probably need to do it in some cases for some programs.
08:38:44 <quicksilver> I don't remember if C++ has a polymorphic catch
08:38:58 <quicksilver> can you say catch (vector<T> v) { ... }
08:39:00 <quicksilver> for unknown T?
08:39:22 <roconnor> that seems unlikley.  God I hope you can't do that.
08:41:04 <Jafet> No; vector <T> and vector <U> are totally unrelated types.
08:41:05 <ben> You would have to say template<typename T> somewhere and there really is no room for it
08:41:13 <Jafet> They just happen to have similar names.
08:41:45 <Jafet> (Otherwise, you would need RTTI for vectors, and think of the number of game programmers who would balk at that.)
08:42:01 <quicksilver> won't somebody PLEASE think of the game programmers!?!?
08:42:09 <ben> What are they going to do about it, switch to java?
08:42:22 <Botje> bwahaha
08:42:45 <ben> I have never been clear on what the runtime cost of haskell polymorphism is, if any, either
08:42:58 <ddilinger> trying to learn a little about haskell by applying it to project euler problems, I've solved problem 11 just wondering if anyone could peek at the code and tell me what should be done better(it does get theright answer though): http://hpaste.org/41528/euler_11 
08:43:21 <roconnor> ben: in haskell, laziness boxes everything already, so there is essentially no extra cost for polymorphism.
08:43:46 <ben> What is actually stored in the boxes?
08:44:02 <roconnor> ben: thunks?  or is it pointers to thunks?
08:44:32 <Jafet> Pointers to; the thunks may be overwritten
08:44:42 <Jafet> That is, if haskell is ghc
08:44:45 <roconnor> ben: is your next question, what is a thunk?
08:44:47 <aristid> roconnor: does that mean that unboxed values cannot be polymorphic?
08:44:48 <ben> No
08:44:56 <ben> aristid: yeah
08:45:12 <aristid> interesting
08:45:16 <Jafet> @quote unsafeCoerce
08:45:16 <lambdabot> ghc says: Dangerous-looking argument. Probable cause: bad unsafeCoerce#
08:55:09 <lars9> @hoogle mapFst
08:55:10 <lambdabot> Data.Graph.Inductive.Query.Monad mapFst :: (a -> b) -> (a, c) -> (b, c)
08:56:43 <roconnor> for those too lazy to write (map fst) ?
08:57:13 <roconnor> oh wait
08:57:22 <roconnor> map fst is a totally different function.
08:57:24 <roconnor> :)
08:57:59 <Botje> this is 'first', really :P
08:58:18 <roconnor> @type first
08:58:19 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
08:58:25 <roconnor> yes
08:58:45 <chrisdone> Cale: yeah I'm fixing it, just thought I'd tell just in case. I have to fix it, my project uses it, hah
08:59:26 <chrisdone> nice library, too
08:59:28 <ddilinger> what does that typesignature mean(@type first), i havent seen '*' or '.' in a type signature
08:59:54 <monoidal> it's the same as forall a b c d. Arrow a => ...
09:00:11 <monoidal> but specifies additionaly that a is of kind * -> * -> *
09:00:44 <roconnor> @type fmap
09:00:45 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:00:54 <monoidal> and forall is usually skipped, so it can be written as Arrow a => a b c -> a (b,d) (c,d)
09:01:02 <ddilinger> intersting
09:01:10 <roconnor> ddilinger: beginners can ignore everything before the .
09:01:49 <roconnor> @type (+)
09:01:49 <lambdabot> forall a. (Num a) => a -> a -> a
09:02:14 <roconnor> oh they write "a" instead of "(a :: *)"
09:06:45 <chrisdone> Cale: is it alright if I use enable -fno-warn-orphans in your file which defines instances for your own library-local classes anyway?
09:10:05 <chrisdone> hehe, shime makes it so easy to load up a haskell project, edit it, test in ghci, configure, rebuild, upload to hackage, ... it even does your laundry
09:11:08 <chrisdone> wait for it...
09:11:14 * hackagebot MonadRandom 0.1.6 - Random-number generation monad.  http://hackage.haskell.org/package/MonadRandom-0.1.6 (ChrisDone)
09:11:17 <chrisdone> boom!
09:12:52 <jmcarthur> i used cabal upload for the first time the other day. i don't know what took me so long
09:13:32 * chrisdone does the secret hand-shake with jmcarthur
09:13:45 <Mitar> isn't cabal upload a bit old?
09:13:58 <chrisdone> what do you mean?
09:14:23 <jmcarthur> Mitar: you are suggesting that it's been superceded by something?
09:14:51 <Mitar> no, just that this put me off from trying it
09:14:59 <jmcarthur> why?
09:14:59 <Mitar> when i checked the version
09:15:03 <jmcarthur> huh?
09:15:09 <jmcarthur> cabal-install is updated all the time
09:15:17 <Mitar> http://hackage.haskell.org/package/cabal-upload ?
09:15:20 <jmcarthur> no
09:15:22 <Mitar> Upload dateFri Aug 24 08:04:40 UTC 2007
09:15:28 <jmcarthur> upload is a command for cabal-install
09:15:37 <chrisdone> jmcarthur: I read your literate planet wars file, it was very well written and help. very literate. I didn't end up doing anything yet, but damn it just take a complement like a man!
09:15:54 <jmcarthur> chrisdone: heh. thanks :)
09:16:00 <Mitar> planet wars?
09:16:08 <chrisdone> Mitar: yeah, from the google ai competition
09:16:20 <Mitar> a, yes
09:16:31 <jmcarthur> chrisdone: unfortunately it's not much of a starter. more of a specification with accomanying code
09:16:33 <Mitar> does this cabal upload also checks if everything is correct?
09:16:37 <Mitar> the same as web version?
09:16:40 <bblum> i have a non-polymorphic datatype that i'd like to implement Traversable for, but the particular type that i want the traversing function to operate over isn't parameterized in the main type; is there a way to declare 'instance Traversable' for my datatype while specifying the particular type that the function should operate on?
09:17:05 <jmcarthur> Mitar: dunno. i just use cabal check first. i don't know if that is sufficient to cover everything the hackage web interface does
09:17:06 <chrisdone> jmcarthur: yeah, I later did see japserdjv &co's full starter packs, but it was a nice guide on how the protocol worked
09:17:39 <chrisdone> the server side does the checks too, it will reject bad packages
09:18:02 <jmcarthur> chrisdone: that literate haskell file is actually just the specification slightly reworded to fit the code
09:18:12 <jmcarthur> although i did write the specification too ;)
09:18:13 <chrisdone> :-)
09:18:29 <quicksilver> bblum: traversable doesn't make sense for non-polymorphic types.
09:18:50 <chrisdone> ah, so that's why your name on the forum is something like 'jmcarthur, mastermind and super power of the universe'
09:18:53 <jmcarthur> chrisdone: things have changes since i wrote it though. major things should be the same, but minor details...
09:18:55 <quicksilver> bblum: the key operation of traversable is T (m a) -> m (T a)
09:18:56 <jmcarthur> haha
09:19:02 <jmcarthur> *changed
09:19:06 <bblum> quicksilver: sorry, i meant Functor
09:19:18 <jmcarthur> chrisdone: i'm not actually participating anymore. it was taking too much of my time
09:19:20 <bblum> the idea here is, i could fairly easily parameterize the type that i want to operate over
09:19:47 <bblum> but i don't want to depend on the definition of the datatype to determine which sub-things of the datatype i can fmap over
09:20:28 <quicksilver> bblum: you lost me :)
09:20:53 <quicksilver> Functor only has one method, fmap, which takes a parameter of type (a -> b) and uses it to turn all the as into bs...
09:20:53 <chrisdone> it's nice when uploading to hackage is part of my job
09:21:07 <quicksilver> how can that make sense if you can't have (T a) and (T b) ?
09:21:21 <bblum> ah, right, good point
09:21:39 <bblum> so, the function i want to map/traverse/whatever over the datatype will be of type a -> a
09:21:45 <chrisdone> quicksilver: did you notice that Functor in recent GHC versions (I don't know how recent) has an extra method? (<$) :: a -> f b -> f a
09:22:05 <quicksilver> chrisdone: well, it's been missing for a long time
09:22:12 <bblum> i feel like it would be neat to be able to say, "here's a datatype that has Foos within its structure; here's a function that takes a Foo and turns it into a different Foo without changing the type, have at"
09:22:13 <osaunders> Is it fair to say left folds are faster than right folds?
09:22:15 <quicksilver> (<$) x = fmap (const x)
09:22:15 <Jafet> :t (<$)
09:22:16 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
09:22:23 <jmcarthur> osaunders: nope
09:22:29 <Jafet> :t ($>)
09:22:30 <lambdabot> Not in scope: `$>'
09:22:34 <osaunders> jmcarthur: Why not?
09:22:50 <quicksilver> bblum: OK. That's something else. You might call it 'Functor0' in a vague analogy of some other typeclasses
09:23:06 <quicksilver> but it doesn't have a name, and it's hard to make sense of without type functions
09:23:54 <bblum> interesting
09:24:03 <bblum> does it exist? >_> i.e., can i make use of it?
09:24:28 <conal> osaunders: a more specific question might help. "why" questions are usually pretty vague.
09:26:28 <conal> osaunders: or you might offer an informal reasoning to support the idea that left folds are faster, and then people can help you debug that reasoning.
09:26:39 <osaunders> My understanding is that a right fold goes to the end of the list and works forward. A left fold starts from the beginning and works back. A left fold doesn't require the first step of going to the back of the list.
09:26:56 <osaunders> conal: Yep, thanks :-)
09:27:04 <conal> osaunders: np :)
09:27:13 <bblum> quicksilver, i'm finding myself writing very sml-style code that just walks manually over every construct in the datatype... and i feel like i want to be able to tack on some sort of 'deriving' on my datatypes to have the language do this for me
09:27:13 <jmcarthur> > foldr (++) [] $ repeat "foo"
09:27:18 <lambdabot>   mueval-core: Time limit exceeded
09:27:23 <jmcarthur> silly lambdabot
09:27:25 <jmcarthur> > foldr (++) [] $ repeat "foo"
09:27:27 <lambdabot>   "foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofo...
09:27:32 <jmcarthur> > foldl (++) [] $ repeat "foo"
09:27:42 <lambdabot>   mueval: ExitFailure 1
09:27:48 <jmcarthur> ^^ that one will never work
09:27:51 <jmcarthur> osaunders: ^^
09:27:52 <quicksilver> bblum: well just write the function once and then use it
09:28:00 <quicksilver> bblum: you don't need a typeclass to write your own functions :P
09:28:05 <JimmyRcom> foldr isn't tail recursive
09:28:08 <osaunders> > foldl (+) 0 [0..]
09:28:13 <jmcarthur> osaunders: right folds don't go to the back of the list first
09:28:13 <lambdabot>   mueval-core: Time limit exceeded
09:28:16 <osaunders> > foldr (+) 0 [0..]
09:28:19 <lambdabot>   *Exception: stack overflow
09:28:22 <conal> osaunders: maybe you're assuming strictness.
09:28:24 <ski> bblum : i think one somewhat related thing is functional references / lenses / accessors .. one could imagine a value of type `Sub X Y', which one could use together with an operation `modify :: forall a b. Sub a b -> (b -> b) -> (a -> a)'
09:28:30 <jmcarthur> osaunders: the direction is only about the associativity, not about evaluation order
09:28:30 <quicksilver> bblum: mapInts :: (Int -> Int) -> T -> T
09:28:39 <quicksilver> bblum: (assuming that 'a' was actually Int in your case)
09:28:57 <jmcarthur> osaunders: well, they don't *necessarily* go to the back of the list first
09:29:02 <JimmyRcom> is there a way to match multiple things in a case that point to the same code without making another function, eg "case char of ' ' | '\t' | '\r' | '\n' -> dothis". I know I could use a function and use it for each patter, just wondering if can do it all on one line
09:29:03 <ski> bblum : note that (afaik), the current fun.ref.s only support marking one element of type `Y' inside an element of type `X', though ..
09:29:22 <bblum> quicksilver: yeah, but what if i want to map all Ints in the datatype in one place, and in another place map all the Strings, and ...
09:29:22 <jmcarthur> osaunders: for strict functions like (+), foldr must indeed go to the end of the list first
09:29:22 <ManateeLazyCat> How to terminate libcurl connect immediately and don't care function 'perform' whether finish?
09:29:29 <osaunders> > scanr (+) 0 [0..]
09:29:30 <lambdabot>   [*Exception: stack overflow
09:29:33 <bblum> suddenly i have to write the traversing function multiple times
09:29:34 <ksf> Data.Hashtable likes to blow my stack.
09:29:35 <osaunders> > scanl (+) 0 [0..]
09:29:36 <lambdabot>   [0,0,1,3,6,10,15,21,28,36,45,55,66,78,91,105,120,136,153,171,190,210,231,25...
09:29:49 <ski> bblum : "map all `String's" is vague
09:29:49 <quicksilver> JimmyRcom: No. Although you can write case char of char | char `elem` " \t\r\n" -> dothis
09:29:57 <jmcarthur> osaunders: but for lazy functions like (++), it doesn't. in fact, foldl will have a lot of trouble with something like (++) because it will have to keep traversing to the end of the accumulated list over and over
09:29:58 <quicksilver> JimmyRcom: which is called a guard
09:30:06 <ski> bblum : what if your `T' type uses a library type `L', which internally happens to use `String' ?
09:30:15 <quicksilver> bblum: what you are describing sounds like what Uniplate does.
09:30:18 <JimmyRcom> chanks quicksilver
09:30:20 <quicksilver> bblum: it's also, often, code smell.
09:30:22 <ski> bblum : should those `String's be changed, as well ?
09:30:36 <bblum> ski: a good point...
09:31:41 <osaunders> jmcarthur: OK, but generally I want the one where you can Â«take n $ foldX1 f anInfiniteListÂ»
09:31:45 <osaunders> ?
09:31:46 <chrisdone> good god! did you see http://dictionary.reference.com/ ?  holy crap. I need a new dictionary web site
09:32:01 <ski> JimmyRcom : unfortunately, Haskell doesn't have disjunctive patterns ..
09:32:15 <JimmyRcom> in erlang guards only accept a limited set of built in functions, can I use any function in haskell?
09:32:29 <osaunders> chrisdone: dictionary.reference.com is very poor quality dictionary.
09:32:32 <Twey> chrisdone: Why were you using that piece of crap in the first place? :Ã¾
09:32:33 <bblum> ok, i will just cave and write the function by hand today >_>
09:32:35 <monoidal> JimmyRcom: a guard can be any boolean
09:32:44 <quicksilver> chrisdone: wordnik?
09:33:12 <ski> (jmcarthur : `foldr', by itself, doesn't go to the end of the list first)
09:33:16 <JimmyRcom> monoidal: any function that returns a boolean works?
09:33:23 <monoidal> JimmyRcom: yes
09:33:26 <ski> JimmyRcom : yes
09:33:28 <JimmyRcom> thanks
09:33:55 <quicksilver> JimmyRcom: technically, "no"
09:34:00 <quicksilver> JimmyRcom: not a function that returns a boolean.
09:34:05 <quicksilver> an actual boolean :)
09:34:07 <ski> an expression of type `Bool'
09:34:07 <jmcarthur> osaunders: i wouldn't say there is a hard and fast rule you can follow
09:34:18 <jmcarthur> osaunders: they have different behaviors for different things
09:34:20 <quicksilver> including those calculated using functions which returns booleans :)
09:34:39 <chrisdone> Twey: it seems to have good range, usually quite a few definitions and etymology... let me see oed to compare
09:34:42 <osaunders> jmcarthur: OK, dw, I'm pretty sure I have the right one.
09:34:46 <jmcarthur> ski: was that a correction to my wording?
09:34:52 <osaunders> For what I'm doing
09:34:54 <chrisdone> Twey: do I have to be logged in to use OED?
09:35:01 <Twey> chrisdone: Yes
09:35:19 <ski> osaunders : if you want to handle infinite lists,  foldl  doesn't work, but  foldr  does. if you want to strictly use a whole list, then  foldl'  is probably what you want
09:35:57 <ski> jmcarthur : what you said sounded like `foldr' will work differently, depending on what argument function you give it
09:36:12 <chrisdone> Twey: I would be most interested in an aggregate dictionary. something involving wordnik, as quicksilver mentioned, preferably -- I like how it follows word use more than it prescribes
09:36:36 <Twey> chrisdone: It has a lot of definitions, but they're mostly from rubbish dictionaries
09:36:45 <Twey> And they're stupid and don't know IPA
09:36:47 <Nibble> hello, xmonad's defaultConfig function
09:36:55 <ski> jmcarthur : `foldl' always traverses the list to the end, before returning any result (simply because it is tail-recursive) -- i.e. it is a bulky operation, not an incremental one
09:36:59 <Twey> chrisdone: The OED is also descriptive
09:36:59 <chrisdone> Twey: Dictionary.com's?
09:37:02 <Twey> chrisdone: Yes
09:37:03 <Nibble> how does it work
09:37:21 <Twey> And the OED is probably the most comprehensive English dictionary in the world
09:37:34 <ski> jmcarthur : otoh, `foldr' hands the control over to the argument function, for each element in the list .. then depending on what that function does, the list will or won't be traversed to the end
09:37:39 <Twey> No aggregate dictionary will come close
09:37:42 <jmcarthur> ski: before returning a *result*, not before performing incremental computation
09:37:46 <chrisdone> Twey: sounds good to me. where do I sign! oh, right here :-)
09:37:49 <Twey> Plus you get quotations going back as far as can be traced
09:37:54 <Twey> Hehe
09:38:06 <jmcarthur> not *necessarily
09:38:46 <chrisdone> wait, I have to pay for it?
09:39:04 <ski> jmcarthur : "incremental computation" here to me means that it computes its result in small chunks (which the environment can then consume, incrementally) .. instead of the environment having to wait until the whole list has been traversed
09:39:10 <Twey> chrisdone: You're meant to get it free via your county library
09:39:17 <magicman> :o GHC7.
09:39:18 <Twey> (if you're in the UK)
09:39:19 <jmcarthur> ski: ah, well, that's not what i mean
09:39:33 * magicman is only now catching up on stuff.
09:39:36 <chrisdone> Twey: it's limited to the UK?
09:39:41 <ski> jmcarthur : ok
09:39:45 <jmcarthur> ski: i'm speaking from an operational behavior point of view
09:40:06 <Twey> chrisdone: They have a variety of partnerships with various universities, libraries, &c., or you can subscribe yourself (which costs)
09:40:18 <ski> jmcarthur : so, what is the difference between incremental and non-incremental, in your use of the terms ?
09:40:34 * magicman is only now catching up on stuff.
09:40:38 <magicman> Arq, sorry >_>
09:41:21 <jmcarthur> ski: i was intending "incremental" to mean "accumulating while traversing the list rather than waiting until the end"
09:41:36 <ski> ah, ok
09:42:59 <jmcarthur> but thanks for calling me out on how unclear i was being. i should be more careful
09:43:00 <kmc> osaunders, did someone show you Cale's fold diagrams already?
09:43:11 <osaunders> No
09:43:25 <jmcarthur> is there a @where entry for that?
09:43:29 <ski> jmcarthur : yeah, the reason i reacted was because i thought you were unclear, and could be misinterpreted
09:43:29 <kmc> @where fold
09:43:29 <jmcarthur> @where fold
09:43:29 <lambdabot> I know nothing about fold.
09:43:30 <lambdabot> I know nothing about fold.
09:43:42 <kmc> seems cale.yi.org is down :/
09:43:48 <kmc> http://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg
09:43:50 <kmc> @where+ fold http://upload.wikimedia.org/wikipedia/en/3/3f/Fold-diagrams.svg
09:43:51 <lambdabot> Nice!
09:43:55 <ski> @where folds
09:43:55 <lambdabot> http://cale.yi.org/index.php/Fold_Diagrams
09:44:13 <kmc> osaunders, so Â«foldr f zÂ» just replaces each (:) in a list with f, and [] with z
09:44:20 <kmc> foldr (:) [] = id
09:44:43 <kmc> whereas foldl has to re-string the list in a different order
09:45:22 <kmc> > foldr f z (1:2:3:[])
09:45:24 <lambdabot>   f 1 (f 2 (f 3 z))
09:45:38 <kmc> > foldr (+) 0 (a:b:c:[])
09:45:40 <lambdabot>   a + (b + (c + 0))
09:46:41 <kmc> i really like the scanr diagram too
09:46:57 <c_wraith> I'm still not completely sure when scanr is useful.
09:47:13 <jmcarthur> > scanr (++) [] $ repeat "foo"
09:47:15 <lambdabot>   ["foofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoofoof...
09:47:21 <jmcarthur> heh
09:47:30 <pkrumins> Anyone knows how to resolve this error: Not in scope: data constructor `IOException'
09:47:31 <jmcarthur> i had a good example the other day, and that wasn't it
09:47:45 <c_wraith> remember, the head of the list scanr results in is the value foldr would have resulted in.  :P
09:47:59 <pkrumins> I have `import Control.Exception (Exception(..))`
09:48:12 <pkrumins> but stil getting the IOException not in scope data constructor error.
09:48:22 <jmcarthur> > scanr (flip (:)) [] "foo"
09:48:23 <lambdabot>   Occurs check: cannot construct the infinite type: b = [b]
09:48:31 <kmc> pkrumins, Control.Exception does not define IOException but rather a newer system of extensible exceptions
09:48:47 <pkrumins> Oh I see.
09:48:50 <jmcarthur> > scanr (:) [] "foo"
09:48:52 <lambdabot>   ["foo","oo","o",""]
09:48:53 <kmc> perhaps you should import System.IO.Error
09:48:58 <pkrumins> Trying that one!
09:49:00 <jmcarthur> it's tails!
09:49:20 <jmcarthur> > tails "foo"
09:49:21 <lambdabot>   ["foo","oo","o",""]
09:49:28 <jmcarthur> @src tails
09:49:28 <lambdabot> tails []         = [[]]
09:49:28 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
09:49:29 <chrisdone> I understand foldr but the diagrams are always non-obvious to me
09:49:50 <pkrumins> Module `System.IO.Error' does not export `IOException'
09:50:09 <kmc> it's called IOError
09:50:16 <chrisdone> (I find it easier to write out the substitution steps, personally)
09:50:18 <pkrumins> oh
09:50:25 <Nibble> is there some sort of something that does nothing?
09:50:30 <kmc> though, actually, Control.Exception does export IOException
09:50:31 <jmcarthur> Nibble: ??
09:50:37 <Nibble> if I have a do statement
09:50:38 <kmc> the problem is that it's a type but not a data constructor
09:50:39 <chrisdone> Nibble: probably, sort of, but it might not exist
09:50:40 * hvr is getting "SpecConstr / Function `$j_s643{v} [lid]' / has two call patterns, but the limit is 1 / ..." quite frequently with ghc-7.0.1... what does this mean?
09:50:41 <c_wraith> Nibble: "return ()"
09:50:44 <kmc> what's your code pkrumins
09:50:45 <ddilinger> Nibble: a noop essentially?
09:50:46 <fysx> Nibble: id ?
09:50:51 <Nibble> fysx: ah
09:50:53 <jmcarthur> Nibble: in do notation you could just say return ()
09:50:56 <pkrumins> kmc, this one: http://sequence.complete.org/node/257
09:51:03 <chrisdone> hahaha
09:51:05 <zygoloid> Nibble: what do you want this something for?
09:51:07 <Nibble> lots of answers here :)
09:51:10 <chrisdone> this. is. #HASKELL!
09:51:18 <Nibble> zygoloid: long story
09:51:21 <chrisdone> someone asks the vaguest question ever, five lines of answers in under five seconds
09:51:34 <pkrumins> kmc, it uses IOException but never improrts it nor IOError
09:51:41 <pkrumins> kmc, so I am getting that error.
09:51:45 * hvr is still waiting for his <5 sec answers 
09:51:52 <Nibble> return () worked
09:51:54 <kmc> pkrumins, oh, that's using the system now in Control.OldException
09:52:03 <kmc> but it might be better to port it to use the new extensible exceptions
09:52:12 <pkrumins> beyond me currently
09:52:16 <kmc> i can help you
09:52:23 <pkrumins> oh that would be great
09:52:30 <pkrumins> kmc, i actually have a smaller subset of that code
09:52:33 <kmc> anyway if you import Control.OldException instead of Control.Exception it should work fro now
09:52:36 <pkrumins> kmc, let me paste it up somewhere
09:52:40 <kmc> pkrumins, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-OldException.html
09:52:48 <pkrumins> kmc, let me try that, and we can proceed with converting to the new exceptions
09:52:52 <kmc> note how Exception used to be a big algebraic type with a bunch of constructors, one of them IOException
09:53:05 <kmc> but this is not extensible; you can't define new exceptions
09:53:12 <pkrumins> aha
09:53:15 <kmc> so now each different sort of exception is its own type
09:53:29 <kmc> Exception is now a type class, and the type SomeException existentially quantifies over it
09:54:05 <pkrumins> aha, i see the improvement there
09:54:05 <kmc> also i bet this use of catch/finally could be done with 'bracket'
09:54:22 <pkrumins> seen bracket before in Networking code
09:54:53 <Nibble> I have a great idea for haskell mode in emacs
09:54:54 <mornfall> kmc: Everything can be done with bracket. Rarely is it more readable though. :P
09:55:00 <dcoutts> jmcarthur, Mitar: cabal upload and the web site upload do the same thing, because they use the exact same entry point (http POST)
09:55:02 <kmc> mornfall, i don't agree
09:56:09 <jmcarthur> dcoutts: cool, thanks
09:56:55 <mornfall> kmc: How would the bracket look like, in this case?
09:57:09 <zygoloid> Nibble: i was asking mostly so i could point you in the direction of 'when' if it was appropriate
09:57:33 <Nibble> zygoloid: I don't care if it is appropriate, and return () is probably the only option, just that it works :)
10:00:11 <mornfall> (Well, in *this* case it's presumably redundant anyway, given how it is in main and it just closes an fd...)
10:05:06 <chrisdone> ciao folks
10:05:08 <ksf> mornfall, don't try to do that in a code assignment, or you're going to end up arguing sanity vs. sanity for an hour.
10:07:15 <mornfall> ksf: At this point, I would be the guy doing the grading. :P
10:07:54 <roconnor> @src when
10:07:54 <lambdabot> when p s = if p then s else return ()
10:08:28 <roconnor> Nibble: ^^
10:11:02 <pkrumins> kmc, so I changed the code to use OldException, it now works in a sense that it runs, but when I try to connect to a nonexisting host/port, the exception doesn't seem to be caught, instead haskell just prints "pinger.hs: connect: does not exist (Connection refused)" and quits.
10:11:09 <pkrumins> kmc, the code is here http://pastebin.com/HqYfcku9
10:11:46 <kmc> well the handler is only set up to catch an EOF error
10:11:47 <pkrumins> kmc, the idea of this program is to ping a service on the given host:port forever. (to announce that the computer that this program is running on is online)
10:12:02 <pkrumins> kmc, there are two handlers, aren't there?
10:12:08 <kmc> btw are you building with -Wall
10:12:10 <pkrumins> kmc: one for EOF and the other for error 'e'
10:12:16 <kmc> oh, right
10:12:16 <pkrumins> kmc, no
10:12:21 <kmc> well it's one handler, with two cases
10:12:51 <pkrumins> kmc, i get tons of warnings from OldException
10:12:54 <kmc> so maybe the error is not within "start"?
10:12:58 <kmc> but rather connectTo
10:13:01 <kmc> which is not within the catch
10:13:04 <pkrumins> kmc, sure it's in connectTo
10:13:11 <pkrumins> oh, it's not!
10:13:51 <pkrumins> kmc, can you suggest how to make connectTo to be within the catch?
10:14:10 <pkrumins> kmc, i can't figure it myself because I am doing assignment there, handler <- connectTo
10:14:20 <pkrumins> kmc, not sure at all how to wrap an assignment in a catch handler
10:14:22 <kmc> why not put it on "pinger"
10:14:26 <kmc> in main
10:14:30 <pkrumins> looking
10:14:36 <kmc> (also, that's not really assignment)
10:14:37 <pkrumins> oh!
10:14:48 <pkrumins> okay, wrapping pinger in main in that catch loop!
10:14:49 <kmc> anyway, you can do x <- stuff `catch` otherstuff
10:14:52 <kmc> yeah
10:15:06 <pkrumins> kmc, let's see if it works, and if it does, we can then convert to new style exceptions!
10:15:10 <kmc> ok
10:15:12 <pkrumins> kmc, what is <- called?
10:15:19 <kmc> hmm, i don't know a name for it
10:15:21 <pkrumins> kmc, extracts value from a monad
10:15:29 <pkrumins> bind maybe
10:15:34 <kmc> (>>=) is bind
10:15:38 <pkrumins> oh
10:15:53 <kmc> i mean "assignment" is an ok name?
10:16:05 <kmc> it just has associations with mutable state variables
10:16:09 <kmc> which isn't accurate here
10:16:20 <roconnor> some people call it "gets"
10:16:36 <roconnor> assignment is a pretty okay name
10:16:47 <pkrumins> not sure at all
10:16:47 <pkrumins> it's monadic afterall
10:16:50 <pkrumins> kmc, just realized you can't do it in main, cause pinger recursively calls itself
10:16:57 <pkrumins> so i got to separate that part out
10:17:02 <kmc> why not
10:17:30 <kmc> it will still cover that recursive call
10:17:37 <pkrumins> oh right!
10:17:44 <pkrumins> kmc, so basically in case of error, i want it to retry
10:17:56 <pkrumins> hacking that in now.
10:19:26 <pkrumins> kmc, some trouble - http://pastebin.com/vcx04ANc
10:19:32 <pkrumins> kmc, notice the places where I put ???
10:19:56 <pkrumins> kmc, I don't really know what to put there now, since I don't have a handle yet
10:20:53 <pkrumins> kmc, oh mistake on my part, I can fill the first ??? 
10:20:56 <pkrumins> with handler as before
10:21:00 <pkrumins> now just the `finally` part
10:21:07 <pkrumins> well i can make it call main again!
10:21:14 <pkrumins> since i want this code to run forever
10:21:53 <pkrumins> kmc, it works :D
10:21:55 <pkrumins> kmc, let me show you
10:22:04 <kmc> seems kind of inside out
10:22:04 <kmc> so is 'main' supposed to keep retrying when there *isn't* an error?
10:22:04 <kmc> or should it quit on success
10:22:05 <kmc> also i don't think you can use "where" there
10:22:07 <kmc> it might be easier to use "try" rather than "catch"
10:22:11 <kmc> ok
10:22:16 <kmc> my connection just lagged
10:22:24 <pkrumins> kmc, http://pastebin.com/fnWifXjn
10:22:34 <kmc> also imo hpaste.org is nicer than pastebin.com
10:22:39 <kmc> ok
10:22:40 <pkrumins> kmc, kk
10:22:51 <pkrumins> kmc, the purpose of the code is to run forever
10:22:51 <kmc> er, it's going to keep re-entering withSocketsDo
10:22:54 <augur> who's totally awesome with CT
10:23:05 <pkrumins> kmc, is that a problem?
10:23:09 <kmc> in theory yes
10:23:17 <kmc> in practice that function is a no-op except on Windows
10:23:24 <copumpkin> I hate that thing
10:23:28 <pkrumins> this code will run on windows
10:23:40 <pkrumins> it notifies the nexus windows machines are up
10:24:00 <kmc> you have two places where it can loop forever
10:24:06 <kmc> pinger can call itself, or main can call itself
10:24:08 <kmc> so you can simplify
10:24:11 <augur> copumpkin! you know CT
10:24:11 <kmc> make pinger just do one ping
10:24:12 <augur> surely
10:24:18 <kmc> then have main catch
10:24:19 <copumpkin> nah, I just pretend to
10:24:20 <kmc> drop the finally
10:24:26 <kmc> and then just put "main" at the end
10:24:27 <augur> copumpkin: well you can pretend to answer my question :p
10:24:35 <pkrumins> kmc, good thinking
10:24:43 <pkrumins> kmc, i will also make it not call withSocketsDo more than once
10:24:46 <kmc> it's weird to use "main" as a handler and as the "finally"
10:24:51 <pkrumins> just factor the whole part of code in main out to a new function
10:25:06 <pkrumins> and then we can finally do those new style exceptions!
10:25:08 <copumpkin> augur: the easiest way is to just ask the question and someone will see it :)
10:25:14 <augur> copumpkin: im reading a paper that has a categorical approach to the syntactic calculus, and in it there are these .. inference rules, i guess you could say
10:25:55 <augur> for instance, heres one one might have: f : A*B -> C => f* : A -> C/B
10:26:21 <augur> which seem to be ways of reasoning about the morphisms in a category
10:27:20 <augur> or another one is perhaps more familiar to you:   f : A -> B   g : C -> D   =>   f*g : A*C -> B*D
10:27:36 <augur> what are these things called?
10:27:37 <copumpkin> C/B being the slice category?
10:27:47 <copumpkin> functors?
10:27:57 <copumpkin> that's just telling you what to do with morphisms in that case
10:27:58 <copumpkin> it seems
10:28:16 <augur> copumpkin: no, i dont know what to call it, but you might think of C/B as the object representing the type B -> C, the function is a postfix
10:28:24 <augur> er, prefix
10:28:29 <augur> whereas B\C is B -> C postfix
10:28:29 <copumpkin> C^B then?
10:28:35 <augur> sure, but directional
10:29:07 <copumpkin> f : A*B -> C => f* : A -> C^B is uncurry, more or less
10:29:21 <augur> basically
10:29:56 <copumpkin> but anyway, not sure what words you're really looking for... natural isomorphism? functor? natural transformation?
10:29:57 <copumpkin> :P
10:30:10 <augur> well lets just look at the product case
10:30:29 <augur> f : A -> B   g : C -> D   =>   f*g : A*C -> B*D
10:30:31 <augur> what is this now
10:30:32 <augur> ?
10:30:49 <copumpkin> bifunctor?
10:30:53 <copumpkin> product category? :P
10:31:04 <augur> well, assume this all exists in one category
10:31:10 <augur> bifunctor eh
10:31:15 <augur> so it'd be a bi-endofunctor?
10:31:34 <augur> or an endo-bifunctor, if you will
10:31:55 <copumpkin> never heard either of those, but a monoidal category has such a bifunctor
10:32:05 <copumpkin> of C x C -> C
10:32:13 <augur> well, i presume its an endofunctor because its from a category to itself
10:32:14 <copumpkin> but has a few additional conditions
10:32:25 <copumpkin> yeah, it is, I just haven't seen it called that
10:32:30 <augur> :P
10:32:32 <copumpkin> but that's probably what it should be called?
10:32:48 <augur> ok, so then these are indeed functors
10:32:57 <augur> i just need to know what these are
10:33:05 <augur> in the paper im reading, they're not called functors
10:33:12 <copumpkin> what are they called?
10:33:12 <augur> they're just called rules of inference
10:33:15 <pkrumins> kmc, http://hpaste.org/41532/pkrumins
10:33:17 <copumpkin> ah
10:33:19 <augur> because its done in a proof theoretic sense
10:33:28 <pkrumins> kmc, i was unable to get rid of `finally`
10:33:54 <augur> where you build up these things with what are essentially rules of logic
10:33:56 <pkrumins> kmc, as i removed `finally` and moved the forever part to the end of forever function itself, i got the following error: 
10:34:02 <copumpkin> yeah
10:34:08 <pkrumins> kmc, pinger.hs:22:4: parse error on input `forever'
10:34:23 <pkrumins> kmc, that line said `forever host port`, so I moved it back into `finally`
10:35:10 <pkrumins> kmc, also hpaste is nasty, requires to enter name and title every time
10:35:27 <pkrumins> kmc, good for one time thing, annoying for multiple pastes/quick changes/updates.
10:37:02 <kmc> yeah i don't know why it requires that
10:37:13 <kmc> but the formatting is way better than pastebin.com and it doesn't try to sell me teeth whitening cream
10:37:20 <kmc> you can use codepad.org too
10:37:43 <pkrumins> kmc, do you like gist?
10:37:46 <kmc> yeah
10:37:51 <pkrumins> yeah, i'll use that then.
10:38:08 <pkrumins> kmc, okay, so the code works now, can you give me some hints on how to move it to new style exceptions?
10:38:27 <kmc> look through the API: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Exception.html
10:38:35 <pkrumins> reading now.
10:38:47 <kmc> catch :: Exception e => IO a -> (e -> IO a) -> IO a
10:38:52 <kmc> catches :: IO a -> [Handler a] -> IO a
10:39:01 <kmc> you might want to use "catches"
10:39:09 <pkrumins> aha
10:39:16 <kmc> but actually, no
10:39:17 <pkrumins> i just have to figure out how to tie catches in the code
10:39:20 <kmc> because you're only catching one thing
10:39:26 <pkrumins> ah.
10:39:29 <pkrumins> well catching everything
10:39:31 <kmc> i think you can convert this to new exceptions without much change at all
10:39:37 <kmc> just switch the import
10:39:42 <kmc> i bet it will complain of an ambiguous type
10:39:47 <kmc> and all you need to do is put a signature on "handler"
10:39:51 <pkrumins> gonna import Control.Exception and get rid of OldException
10:39:59 <kmc> handler :: SomeException -> IO ()
10:40:18 <pkrumins> kmc, and where do I put that?
10:40:25 <pkrumins> since handler is like inline function in that code
10:40:46 <pkrumins> i don't really define it outside the forever function
10:40:54 <pkrumins> gonna try putting it outside of all functions
10:40:58 <pkrumins> see if it works that way
10:41:33 <pkrumins> right, The type signature for `handler' lacks an accompanying binding
10:41:37 <pkrumins> doesn't quite work
10:41:59 <ClaudiusMaximus> > let { x :: Double ; x = 4 + y where { y :: Double ; y = 3 } } in x
10:42:00 <lambdabot>   7.0
10:42:41 <pkrumins> kmc, here is what i did: https://gist.github.com/702248
10:43:08 <kmc> you'd put it right above "handler" and indented as much
10:43:31 <pkrumins> oh wow
10:44:39 <pkrumins> kmc, parse error, https://gist.github.com/702248
10:44:44 <pkrumins> kmc, maybe i had to put it where part
10:45:05 <pkrumins> kmc, works :D
10:45:31 <augur> copumpkin: ok, heres another question then
10:45:42 <augur> oh, wait nevermind :D
10:45:45 <pkrumins> kmc, final version: https://gist.github.com/702248
10:47:27 <copumpkin> augur: no go ahead!
10:47:34 <augur> no, it wasnt a real question
10:47:43 <augur> it was based off of a misinterpretation of the article
10:53:12 <Eduard_Munteanu> /topic says "GHC 7 is out: http://is.gd/hb8vE"
10:53:40 <Eduard_Munteanu> It just sends me to the platform on a mirror or something oO
10:54:24 <copumpkin> weird
10:54:25 <engla> Eduard_Munteanu: then you are clicking through too quickly
10:54:26 <augur> copumpkin: can we talk about composing functors and morphisms? or is that impossible?
10:54:44 <copumpkin> augur: a functor with a morphism, or functor . functor and morphism . morphism?
10:54:53 <augur> eh
10:54:54 <Eduard_Munteanu> engla: strange, it worked now
10:55:03 <lispy> is {-# GHC_OPTIONS ... #-} missing in ghc7?
10:55:15 <Eduard_Munteanu> engla: the first time it sent me to http://hackage.haskell.org.nyud.net/platform/
10:55:23 <copumpkin> augur: composing a functor with a morphism only gives you one half of what the functor does, and composing only that part might not give you a functor
10:55:23 <Eduard_Munteanu> What is that anyway? A mirror?
10:55:50 <augur> well, suppose i have f : 1 -> A^B and g : 1 -> B, then f*g = 1*1 -> (A^B)*B
10:56:02 <engla> Eduard_Munteanu: that's strange. I meant there is a link to the haskell platform directly on top of the ghc page, so maybe you somehow clicked through on that link
10:56:06 <lispy> Seems to be just {-# OPTIONS ... #-} now
10:56:09 <engla> or it was just cosmic radiation
10:56:12 <augur> and app[(A^B)*B] : (A^B)*B -> A
10:56:23 <Eduard_Munteanu> Hm, that's possible, anyway.
10:56:30 <Eduard_Munteanu> Heh.
10:56:36 <copumpkin> augur: well 1 -> object is basically isomorphic to the object itself
10:56:42 <copumpkin> assuming 1 is your terminal object
10:56:43 <augur> so   app[(A^B)*B] . (f*g) : 1 -> A
10:57:36 <augur> copumpkin: meaning? :\
10:58:39 <kmc> it's OPTIONS_GHC lispy
10:58:44 <kmc> or OPTIONS
10:58:50 <kmc> and that's not new in 7 iirc
10:58:55 <kmc> maybe GHC_OPTIONS was also accepted before
10:59:22 <copumpkin> augur: in haskell, f :: () -> a is mostly the same as a, because you can just write f () to get the value inside
10:59:36 <lispy> byorgey: I'm sending you a patch
10:59:37 <augur> sure
10:59:47 <augur> but im not sure what that means in this context
10:59:51 <lispy> byorgey: your split package isn't building on ghc7
11:00:10 <kmc> when will hackage start doing ghc7 builds?
11:00:36 <alexis> hi haskell ppl !
11:00:46 <kmc> hi alexis
11:01:36 <alexis> I do have a little problem understanding what have to be done in order to compile a really simple haskell exemple using ghc.
11:01:41 <lispy> byorgey: sent
11:02:51 <kmc> ghc --make foo.hs
11:02:59 <alexis> I have that: https://gist.github.com/702281 what am I missing ?
11:03:03 <kmc> it will compile foo.hs as well as any modules it depends on from the current directory
11:03:16 <kmc> alexis, main has to have type Â«IO ()Â»
11:03:23 <kmc> that is, it has to be a "recipe" for performing IO
11:03:27 <kmc> problem1 is a list, not a recipe
11:03:31 <kmc> so maybe you want:  main = print problem1
11:03:36 <kmc> however, why not just do this at the prompt in ghci?
11:03:42 <alexis> okay, I dunno recipes
11:03:57 <kmc> alexis, http://www.haskell.org/haskellwiki/Introduction_to_IO
11:04:05 <alexis> kmc: well, it's working in ghci, but I want to have it working compiled, just to understand how it's working.
11:04:15 <kmc> what would that help you understand?
11:04:20 <alexis> kmc thx
11:05:08 <chrisdone> anyone got a fixed version of the split library for ghc7?
11:05:17 <alexis> well, I guess I will make some more complex things later, and having haskell described in a file seems more reliable than just having to c/p it on hgci
11:05:42 <chrisdone> some Tolkienesque error messages about skolems escaping
11:06:07 <copumpkin> damn skolems
11:06:14 <copumpkin> I always lock them up in my basement but they keep escaping
11:06:16 <chrisdone> "because this skolem type variable would escape"
11:06:23 <copumpkin> lucky SPJ is here to catch them again
11:06:34 <chrisdone> "filthy fat haskellers"
11:06:51 * Eduard_Munteanu lols at GHC's manual: 7.3.10. Generalised (SQL-Like) List Comprehensions
11:06:58 <jmcarthur> yeah that error has caught me off guard a lot as well, ever since the type system rewrite
11:06:58 <kmc> alexis, you can also write it in a file, without "main", then load it ito ghci
11:07:01 <chrisdone> Eduard_Munteanu: what's funny about it?
11:07:15 <Eduard_Munteanu> chrisdone: it's a bit surprising how that code looks.
11:07:17 <kmc> alexis, if you just have the "problem1" line then run "ghci foo.hs" you can access "problem1" from the prompt
11:07:22 <chrisdone> jmcarthur: if it appears a lot I'll look up what skolem types are. I thought it might be something obscure and particular to this lib
11:07:29 <Eduard_Munteanu> chrisdone: not in a bad way though.
11:07:55 <copumpkin> skolem is just a variable that doesn't unify with anything else, afaik
11:08:05 <copumpkin> used when existentials appear
11:08:06 <chrisdone> oh, nice
11:08:14 <alexis> kmc: okay thx
11:08:19 * hackagebot persistent 0.3.1 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-0.3.1 (MichaelSnoyman)
11:08:19 <copumpkin> unless I'm misunderestimating the difficulty
11:08:20 <chrisdone> that makes sense, regarding "escaping"
11:08:43 <copumpkin> so if you had data Pumpkin'sBasement = forall skolem. Basement skolem
11:08:52 <copumpkin> and then f (Basement s) = s
11:08:56 <jmcarthur> it's not just existentials
11:08:59 <copumpkin> then those damn skolems would escape
11:09:03 <chrisdone> heh, yeah
11:09:04 <copumpkin> yeah, it's used in various situations
11:09:06 <jmcarthur> it will appear with runST as well
11:09:09 <jmcarthur> for example
11:09:10 <kmc> fun fact: Skolem's first name was Thoralf
11:09:19 * hackagebot persistent-postgresql 0.3.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.3.1 (MichaelSnoyman)
11:09:48 <jmcarthur> chrisdone: here's the biggest gotcha in the new stuff: http://hackage.haskell.org/trac/ghc/blog/LetGeneralisationInGhc7
11:10:05 <jmcarthur> it's nothing major though. you just have to be more careful with let/where
11:10:17 <yrlnry> Fun fact: Skolemization is illegal in 14 U.S. States.
11:10:19 <lispy> actually, that gotcha is pretty big
11:10:29 <jmcarthur> as usual, type sigs help
11:10:40 <copumpkin> yrlnry: damn, I'm probably guilty of it 
11:10:42 <lispy> Everything i've tried to compile on ghc7 has run into type errors because o fit
11:10:57 <jmcarthur> lispy: okay, it's big, but it's a pretty easy fix
11:10:57 <lispy> I'm just now looking at cmdlib type errors
11:11:04 <lispy> jmcarthur: not always :)
11:11:30 <sproingie> i'm going to name my next D&D character "Thoralf Skolem" 
11:11:33 <jmcarthur> i ran into something i couldn't fix a while ago, but it was a actually a bug
11:11:38 <jmcarthur> *was actually
11:11:49 <jmcarthur> sproingie: lol
11:11:57 <kmc> @remember chrisdone anyone got a fixed version of the split library for ghc7? some Tolkienesque error messages about skolems escaping
11:11:58 <lambdabot> It is stored.
11:11:58 <lispy> jmcarthur: take a look at cmdlib and tell me if you see how to fix it
11:12:17 <lispy> chrisdone: I just sent a patch for split to brent
11:12:18 <jmcarthur> lispy: i don't have ghc7 installed at the moment. was thinking about doing it though
11:12:20 * hackagebot yesod 0.6.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.6.2 (MichaelSnoyman)
11:12:23 <lispy> chrisdone: what is your email address?
11:13:20 <chrisdone> lispy: nice one. chrisdone@gmail.com (exciting, I know)
11:13:53 <lispy> chrisdone: oh, the one i have is @googlemail.com
11:14:00 <chrisdone> they are equivalent
11:14:09 <lispy> cool, I sent you the same patch I gave brent
11:14:18 <chrisdone> thanks!
11:14:30 <jmcarthur> wow, there ghc7 binaries for freebsd already
11:14:42 <Zao> Ooh?
11:14:56 <jmcarthur> Zao: http://www.haskell.org/ghc/download_ghc_7_0_1.html
11:14:58 <Zao> jmcarthur: I assume it's just x86/amd64?
11:15:10 <Zao> My sparc64 gently weeps :D
11:15:14 <jmcarthur> correct
11:15:34 <jmcarthur> why do you have a sparc64?
11:15:37 <jmcarthur> just curious
11:15:48 <lispy> jmcarthur: I'm currently seeing this on ghc7 only:     Could not deduce (a ~ (String -> rec -> rec))
11:15:48 <lispy>       from the context (Eq (Record rec), Data rec, Attributes rec)
11:16:13 <sproingie> i look at the code and i see it needs porting // while my old sparc gently weeps
11:16:16 <lispy> jmcarthur: Not sure how I'm going to resolve it, the tricks on the GHC wiki page don't seem to elucidate the problem
11:16:18 <jmcarthur> lispy: i will be giving this a shot. i just have to install ghc7 first
11:16:34 <Eduard_Munteanu> SPARC is way nicer in some regards.
11:16:44 <Zao> jmcarthur: I used to run FreeBSD on my Ultra10 as firewall/irc/web/svn/whatever machine.
11:17:07 <Zao> Well, it still does, it's just not in production.
11:17:18 <jmcarthur> i don't really have any experience with spark aside from simply using a machine running on it a few times
11:17:32 <jmcarthur> *sparc
11:17:41 <Zao> It's quite nice to have a big-endian machine handy to test code on.
11:18:05 <jmcarthur> i have a powerbook for that
11:18:14 <lispy> I'm thinking we should submit a bug report regarding the skoelem error message.  I think the phrasing is too obscure and should be changed
11:18:26 <Eduard_Munteanu> It's probably cheaper to get QEMU for that.
11:18:28 <jmcarthur> i do agree that the error message is kind of... shocking?
11:18:45 <jmcarthur> Eduard_Munteanu: i already had it :P
11:19:49 <Eduard_Munteanu> Sigh... how popular crap like x86 can become...
11:20:21 <jmcarthur> i think ARM is kind of elegant... and it's *very* popular
11:20:27 <Eduard_Munteanu> Mmm...
11:20:51 <jmcarthur> also, you have to admit that x86 may be a crap instruction set and all that, but the CPUs are typically very fast
11:21:06 * Eduard_Munteanu remembers he has an ARM7TDMI around, he could make a board and solder it when he's got some time.
11:21:11 <jmcarthur> probably not due to the instruction set though ;)
11:21:26 <Eduard_Munteanu> Yes, x86 is really advanced in terms of performance.
11:21:59 <kmc> Eduard_Munteanu, it's in a hand-solderable package? or would you do home reflow because you're hardcore? ;)
11:22:02 <chrisdone> jmcarthur: interesting, useful read, thanks. seems like it probably won't hurt most of my programs. most of my polymorphism is class polymorphism in which I'm used to having to annotate anyway and I don't mind it
11:22:38 <Eduard_Munteanu> kmc: it's SMD, but not BGA or stuff like that. I think it's SOIC or TSSOP.
11:23:06 <kmc> ok, that's doable :)
11:23:08 <Eduard_Munteanu> kmc: with a good iron is quite doable
11:23:11 <kmc> i assumed they were all BGA these days
11:23:19 <Eduard_Munteanu> Nah, I fear those.
11:24:17 <kmc> hot plate :D
11:24:52 <chrisdone> class Foo a where foo :: a -> Int
11:24:53 <chrisdone> instance Foo Int where foo _ = 0;  instance Foo Char where foo _ = 1
11:24:53 <chrisdone> bar = (f 'a',f 1) where f :: Foo a => a -> Int; f = foo
11:24:53 <chrisdone> above, the `1' is shown as ambiguous when I compile it, understandably, it's a Num a => a. so it seems integer defaulting is disabled for class-polymorphic uses? has it always been this way? I seem to recall it but I don't remember giving it much attention
11:24:55 <Eduard_Munteanu> Well, not that, but I fear the costs and time wasted looking for people to reflow it for me.
11:25:25 <Nibble> what package are fdClose, intToFd, try, isEOFError in
11:25:43 <Eduard_Munteanu> @hoogle fdClose
11:25:44 <lambdabot> No results found
11:25:52 <Eduard_Munteanu> (was worth a try)
11:26:01 <chrisdone> fdClose is probably in unix or posix, try in is base and other areas, isEOFError, I think, is in System.IO.Error, etc... 
11:26:13 <chrisdone> use Hayoo!
11:26:38 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-IO.html
11:27:03 <Eduard_Munteanu> Though that has closeFd
11:28:23 <Nibble> Eduard_Munteanu: this is most likely from an old ghc version
11:28:43 <Nibble> @hoogle closeFd
11:28:43 <lambdabot> No results found
11:29:11 <Eduard_Munteanu> Nibble: yeah, the first hit on Google "fdclose Haskell" shows GHC 6.2
11:29:20 <Nibble> where is closeFd then?
11:29:30 <Eduard_Munteanu> There ^
11:29:34 <Eduard_Munteanu> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-IO.html
11:30:02 <Nibble> how do I do search and replace in vim
11:30:53 <Eduard_Munteanu> Nibble: you select the text somehow and do :s/foo/bar/
11:31:06 <Eduard_Munteanu> Nibble: or :1,$s/foo/bar/ for the whole file
11:31:33 <Eduard_Munteanu> (you can use v or V to select, then press : and type the sed expression)
11:31:37 <Nibble> intToFd then
11:31:39 <Nibble> hmm
11:31:42 <jmcarthur> lispy: libcmd seemed easy to clean up to me
11:31:55 <jmcarthur> lispy: i pretty much just added type signatures and constraints as it requested them
11:31:55 <ben> :%s/foo/bar/g !
11:32:06 <lispy> jmcarthur: huh
11:32:15 <Eduard_Munteanu> ben: whole file? I thought there was a shorter way than 1,$
11:32:15 <lispy> jmcarthur: I guess I don't know anything about type families
11:32:30 <roconnor> Mmm, coarrows
11:32:31 <jmcarthur> i had to add several Eq constraints and a type signature to something in a where clause
11:32:44 <jmcarthur> lispy: i didn't have to do anything relating to type families
11:32:56 <jmcarthur> i don't know why you got that error message
11:33:08 <jmcarthur> maybe because of something else you changed?
11:33:21 <Eduard_Munteanu> Yeah, and don't forget 'g' unless you want only a single replace per line.
11:35:04 <jmcarthur> lispy: http://hpaste.org/41538/cmdlib
11:35:06 * Eduard_Munteanu also uses Vimperator for Firefox, it makes sense with xmonad
11:35:52 <roconnor> where can I find the definition of CoArrow?
11:36:06 <jmcarthur> lispy: it's possible that those Eq constraints could be cleaned up a little. maybe the Eq (Record foo) ones could be removed? i didn't try it
11:36:08 <lispy> http://hackage.haskell.org/trac/ghc/ticket/4499
11:36:46 <lispy> jmcarthur: could you post that as a unified diff or send me a darcs patch?  dagitj at g mail dot com?
11:37:37 <jmcarthur> lispy: got a link to the darcs repo handy?
11:37:42 <jmcarthur> i just used cabal unpack
11:38:09 <jmcarthur> n/m i'll just find it
11:39:07 <lispy> jmcarthur: Default Remote: http://repos.mornfall.net/cmdlib
11:39:13 <jmcarthur> lispy: ah the darcs repo is very different from the hackage version
11:39:35 <jmcarthur> i'll try this one separately
11:39:58 <mornfall> jmcarthur: Not very, but it's working up towards a new version. :)
11:40:37 <chrisdone> /home/chris/Programs//lib/ghc-7.0.1/package.conf.d
11:40:38 <chrisdone>    time-1.2.0.3
11:40:38 <chrisdone> /home/chris/.ghc/i386-linux-7.0.1/package.conf.d
11:40:38 <chrisdone>    time-1.1.4
11:40:41 <chrisdone> what's the usual resolution to this? usually I attempt, in vain, to unregister/reinstall but typically end up with a broken package set in which I can't recover because time-1.2.0.3 is depended on by fundamental GHC packages. even if I cleared everything and started from scratch, some libraries just depend on the later time version. and I can't ignore the "This is highly likely to cause a compile failure." message because it does indeed
11:40:44 <chrisdone> cause a build failure
11:41:45 <jmcarthur> mornfall: do you want a patch too if i get it building?
11:41:54 <mornfall> jmcarthur: Certainly. Ideally a .dpatch. :)
11:42:16 <chrisdone> http://hpaste.org/41539/packages
11:42:20 * chrisdone sighs deeply
11:42:33 <mornfall> chrisdone: Welcome to hell.
11:42:41 <jmcarthur> yay it works
11:42:46 <jmcarthur> well, builds
11:42:52 <kmc> hehe
11:42:55 <mornfall> chrisdone: I went through that a week ago...
11:43:02 <chrisdone> mornfall: so how did you solve it?
11:43:19 <yrlnry> A mathematician has written to me to question my claim that "CS grad students often have to take classes in category theory."  Any comments?
11:43:22 <mornfall> chrisdone: I ended up rm -rf'ing everything I had installed in ~/.cabal.
11:43:29 <mornfall> chrisdone: And then gradually working towards something a bit more sane.
11:43:51 <chrisdone> the nuke and pray technique is a last resort
11:43:56 <mornfall> chrisdone: It also turns out that if you have the same package version in system that links mtl < 2 as you try to install in .cabal, it's going to screw you.
11:44:30 <mornfall> chrisdone: Just hope you won't need to compile xmonad-contrib anytime soon. ...
11:44:50 <mornfall> (Since it doesn't with mtl >= 2. And introducing mtl < 2 back is likely to screw you right there again.)
11:45:12 <chrisdone> the joys of cabal
11:45:18 <mornfall> :)
11:46:00 <jmcarthur> lispy: sent
11:46:03 <jmcarthur> mornfall: ^^
11:46:04 <lispy> jmcarthur: thanks
11:46:28 <jmcarthur> lispy: are you sure you are using ghc 7.1? i never saw that error you mentioned
11:46:35 <jmcarthur> 7.01 or whatever
11:46:41 <mornfall> Hm. I only got empty mail?
11:46:46 <jmcarthur> lol
11:46:47 <lispy> $ ghc --version
11:46:48 <lispy> The Glorious Glasgow Haskell Compilation System, version 7.0.1
11:46:48 <jmcarthur> i forgot to attach
11:46:52 <jmcarthur> sorry guys
11:48:00 <jmcarthur> okay i actually sent the patch this time
11:48:05 <acemo> can i give my self made data type a context? like with a function it would be f :: Ord a => [a] -> [a]
11:49:05 <jmcarthur> i really need to get darcs send working properly
11:49:36 <lispy> jmcarthur: it's kind of a pain to setup due to sendmail, I tend to just use darcs send -O these days and attach to an email
11:49:53 <jmcarthur> yeah
11:50:04 <lispy> (sendmail was nicer back when everyone had open relays, but these days, how do you securely send to a gateway that requires auth?)
11:50:25 <chrisdone> mornfall: well, bugger me: http://hpaste.org/paste/41539/well_i_be_damned#p41541
11:50:43 <chrisdone> the proper unregister/reinstall method actually worked for the mtl case
11:50:52 <chrisdone> pleasant surprising is pleasant
11:51:22 <lispy> jmcarthur: thanks, that worked
11:51:37 <chrisdone> also, that installed really fast. is GHC7 actually faster or is it placebo? :-)
11:52:09 <jmcarthur> chrisdone: i don't know about the general case, but i can testify that vector and dph type stuff compiled *very* slowly
11:52:13 <jmcarthur> *compiles
11:52:20 <chrisdone> slower than 6?
11:52:24 <jmcarthur> yes
11:52:30 <chrisdone> intrestin
11:52:37 * hackagebot split 0.1.2.3 - Combinator library for splitting lists.  http://hackage.haskell.org/package/split-0.1.2.3 (BrentYorgey)
11:52:44 <chrisdone> hurrah!
11:53:09 <jmcarthur> chrisdone: my ai contest entry took about a minute and a half to build with ghc head... majority in one file
11:53:13 <jmcarthur> not a big file, either
11:53:14 <chrisdone> Î» Go team Haskell! Î»
11:53:41 <lispy> byorgey: thanks!
11:53:53 <jmcarthur> chrisdone: whenever i added a function that marked the end of a large chain of fused functions it would add like another 10 seconds to it :o
11:54:24 <chrisdone> wow, that's sucky
11:54:33 <lispy> hashed-storage also fails on ghc7
11:54:35 <chrisdone> is that type checking stage or compilation stage?
11:54:41 <jmcarthur> probably compilation
11:54:47 <lispy> I'm going to stop fussing with stuff for now
11:54:58 <jmcarthur> vector etc. relies on lots of inlining a fusion and stuff
11:55:00 <jmcarthur> *and
11:55:07 <chrisdone> sure
11:55:29 <acemo> how could i make a data type that exists of 2 lists of Orderable elements? i can use 2 lists of Ints, but it would be nicer to be able to use my heap for any orderable elements
11:55:31 <jmcarthur> and i noticed that it sped up a *lot* if i removed some INLINE pragmas
11:55:51 <kmc> acemo, it's best just to put the Ord constraint on your functions
11:55:55 <kmc> like how Data.Map does it
11:56:40 <chrisdone> mornfall: now.. that method works when both packages have been installed by hackage. but for time, one is a system package. I can't remove that package without breaking the packages GHC installs and which Cabal, if I remember correctly, in turn, depends on and thus will break and leave me helpless. what to do... what to do...
11:57:10 <mornfall> chrisdone: You can cabal install cabal-install and use that.
11:57:17 <mornfall> chrisdone: What distro are you on?
11:57:33 <mornfall> And is your ghc7 from the distro?
11:57:36 <chrisdone> mornfall: I don't mean Cabal Install, but Cabal itself usually breaks
11:57:48 <chrisdone> nah my ghc is from the tarball
11:57:56 <mornfall> Oh wait.
11:58:02 <pelotom> @src groupBy
11:58:02 <lambdabot> groupBy _  []       =  []
11:58:02 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:58:02 <lambdabot>     where (ys,zs) = span (eq x) xs
11:58:10 <mornfall> I see.
11:58:24 <mornfall> But you only have 1 mtl. So you are good, no?
11:58:39 <acemo> kmc: if you say so.. It just feels more logical to allow any orderable elements in the lists instead of only integers or whichever i choose to use now
11:58:49 <kmc> yes, this would allow any orderable elements
11:58:55 <chrisdone> yeah, the mtl problem is solved. it's the time problem now. but it seems only one package depends on it: ghc-pkg: unregistering time-1.1.4 would break the following packages: time-extras-1.1.4 (use --force to override) so I can probably procede with this successfully
11:58:59 <kmc> data Heap a = MkHeap [a] [a]
11:59:07 <kmc> insert :: (Ord a) => a -> Heap a -> Heap a
11:59:19 <chrisdone> mornfall: that is, if I can convince time-extras to use the old time
12:00:13 <mornfall> chrisdone: You shouldn't need to worry about the old time, should you?
12:00:13 <acemo> kmc: hmm yea.. makes sence, thanks!
12:00:13 <pelotom> @src span
12:00:14 <lambdabot> span _ xs@[]                     =  (xs, xs)
12:00:14 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
12:00:14 <lambdabot>                   | otherwise    =  ([],xs)
12:00:22 <mornfall> chrisdone: Unless you need to link ghc-pkg, that is.
12:00:44 <mornfall> Not ghc-pkg.
12:00:49 <mornfall> The ghc API thingy.
12:00:57 <mornfall> Or maybe not even that.
12:01:02 <chrisdone> ghc-pkg: unregistering time-1.2.0.3 would break the following packages: haskell98-1.1.0.0 random-1.0.0.3 haskelldb-hdbc-postgresql-2.1.0 haskelldb-hdbc-2.1.0 HDBC-postgresql-2.2.3.1 HDBC-2.2.6.1 convertible-1.0.9.1 ConfigFile-1.0.6 MissingH-1.1.0.3 haskell98-1.1.0.0 random-1.0.0.3 hslogger-1.1.0 has-0.4.1.1 has-0.4.1.0 QuickCheck-2.4.0.1 MonadRandom-0.1.6 (use --force to override)
12:01:11 <chrisdone> the one that worries me is random-1.0.0.3
12:01:22 <mornfall> Hm. I only have time-1.1.4. Interesting.
12:01:30 <chrisdone> which is installed in system and local
12:01:39 <copumpkin> preflex: seen tomberek
12:01:40 <preflex>  tomberek was last seen on #haskell 2 days, 37 minutes and 34 seconds ago, saying: not bad
12:02:00 <chrisdone> mornfall: global or local?
12:02:03 <mornfall> Global.
12:02:11 <mornfall> Came with Debian.
12:02:16 <chrisdone> hmm
12:03:11 * jmcarthur starts actually coding the things he intended to code
12:03:15 <jmcarthur> finally
12:03:29 <jmcarthur> seems like i never get started until about 2pm
12:03:38 * chrisdone starts pasting project euler problems to jmcarthur in pm
12:03:51 <chrisdone> fwuhaha! you'll never get anything done!
12:04:13 <kmc> @quote euler
12:04:14 <lambdabot> lament says: <HaskellLove> Can eulers be solved in Prolog? <lament> HaskellLove: no <lament> prolog is not euler-complete
12:04:15 <jmcarthur>  /ignore chrisdone 
12:04:16 <jmcarthur> :P
12:04:19 <tarrasch> Hello, I've been looking around for some interesting implementations of reactive GUI (like the fruit family of projects), but that seem to lack any active development. Is there any reason for that? I think it's very interesting with reactive GUI.
12:04:20 <chrisdone> :o
12:04:23 <jmcarthur> i jest
12:04:40 <chrisdone> haven't seen lament in a while
12:05:17 <jmcarthur> tarrasch: frp is still a very open problem and hasn't seen many practical applications yet. the existing frp gui libraries were all research projects, afaik
12:06:47 <tarrasch> jmcarthur, ah ok, why is it a "open problem"?
12:07:05 <tarrasch> jmcarthur, seems like a quite powerful paradigm
12:08:41 <chrisdone> speed problems and confusion are what I've heard about it
12:09:04 <tarrasch> ok, I've heard about some sort of memory leak
12:09:20 <jmcarthur> tarrasch: there has been a struggle to get the semantics right, and implementations have also proved to be difficult. some people would really like a continuous-time semantics, and that's been leading to space leaks in most implementations. the implementations of discrete semantcs (e.g. yampa) have done a bit better. from a semantic angle, it's been difficult to keep it simple, junk free, etc.
12:10:38 <tarrasch> how many implementations are their besides yampa?
12:10:50 <jmcarthur> difficult to say off the top of my head
12:11:06 <conal> and denotative GUIs haven't been explored much. my guess is there's a lot of beautiful & useful work to be done.
12:11:40 <conal> the fruit paper contained some hints in the direction of denotative (and thus highly compoable) guis.
12:11:43 <conal> (composable)
12:11:50 <jmcarthur> tarrasch: reactive comes to mind as the other major one (continuous time semantics, space leaks)
12:13:04 <sproingie> continuous time semantics sound nice for animation, but how does that help with, say, coding a button?
12:13:28 <jmcarthur> tarrasch: it turns out that the space leaks can probably be solved by an optimal evaluation order, but that's a lot of bookkeeping, hard to implement. i've been looking for an evaluation order that compromises enough to be simple and fast while still eliminating these space leaks
12:13:34 <conal> reactive's semantic model isn't very friendly to space/time-modular interaction.
12:13:45 <jmcarthur> sproingie: you don't always click a button exactly on a discrete time step :P
12:14:14 <tarrasch> what does 'continuous time semantics' mean? Doesn't yampa send a time-stamp along with every alpha?
12:14:47 <tarrasch> (if alpha is input and beta output, if that makes any sense to say)
12:15:07 <jmcarthur> sproingie: more importantly though, this is about defining the interface. you may disagree, but i believe that continuous time fits my intuition about how time works more accurately
12:15:10 <sproingie> 99% of guis simply don't care about the time factor, they're purely discrete events
12:15:23 <jmcarthur> sproingie: you mean 99% of gui toolkits
12:15:51 <sproingie> no, guis.  interfaces.  the irc client i'm using.  the terminal program it's in.  most of the stuff in my browser that isn't multimedia.
12:15:55 <conal> sproingie: button presses occur discretely but in continuous time
12:16:26 <jmcarthur> sproingie: all of those things still have live interaction and are expected to be responsive.
12:16:37 <conal> sproingie: guis that have mouse position interaction would be more naturally expressed with continuous time.
12:17:26 <sproingie> the pointer is obviously a different case
12:18:11 <jmcarthur> even your irc client is based on discrete events on a continuous timeline
12:18:17 <conal> sproingie: may be obvious to you.  it's non-obvious to a lot of folks.
12:18:43 <jmcarthur> you may not need integration in an irc client, but you definitely care about time
12:19:09 <jmcarthur> i certainly wouldn't want my key presses to be processed out of order relative to each other, for example
12:19:50 <conal> i think continuity of time & space is mainly an issue of naturalness and modularity/composability
12:20:48 <sproingie> so the state of the gui, such as the rendering of lines in my irc client, is, if i get this correctly, expressed as a function over all the events, rather than some implicit notion of repeatedly handling them?
12:20:58 <jmcarthur> i think it's perfectly possible that discrete time might make sense for some things. i don't want you to get me wrong. i just think such things are special cases of continuous time :)
12:21:06 <sproingie> and in order to sequence those events, you have the timeline?
12:21:13 <shepheb> @boxofdoom I didn't have myself set up at the main UW library. The separate math/CS library did things their own way. Didn't use it much anyway. Everything is online.
12:21:13 <lambdabot> Unknown command, try @list
12:21:19 <shepheb> mischan
12:21:43 <jmcarthur> sproingie: well, we might not have some explicit timeline or something, but the basic idea is correct. we want a declarative way to describe the behavior of an irc client rather than statefully arranging event handlers and such
12:22:42 <chrisdone> yaaay! upgrading to GHC7 (only three hours later!) has fixed the type inference bug!
12:23:06 <chrisdone> @tell Cale it worked! ghc7 solved all my problems and bought me an ice cream
12:23:06 <lambdabot> Consider it noted.
12:23:24 <conal> sproingie: sounds pretty close, though i'm unsure what distinction you're going for between "function over all the events" vs "repeatedly handling them". if you think of how we use lazy lists in FP vs for-loops in imperative, you'll get a good feel for FRP.
12:23:46 <tarrasch> Is there any good resource explaining why frp is having memory problems?
12:24:28 <sproingie> conal: instead of having a bag of "handler" functions floating off in space, the visible state of your gui becomes a function over the whole stream of events
12:24:58 <sproingie> still not sure most require explicit time except insofar as "this happened after that"
12:25:03 <conal> tarrasch: no. my guess is that it's just the usual difficulty of time & space leaks in lazy functional programming.
12:25:41 <sproingie> conal: at least that's my understanding.  i'm trying to get a clearer understanding, because the descriptions i've been reading are sometimes so vague as to belong in philosophy texts
12:25:53 <conal> sproingie: yep. and compositionally constructed.
12:26:10 <tarrasch> conal, your guess? I thought you were the frp-guy? :)
12:26:31 <sproingie> cabal install frp-guy
12:26:41 <conal> tarrasch: i struggle with operational subtleties also.
12:27:02 <jmcarthur> tarrasch: www.cs.yale.edu/~hl293/download/leak.pdf
12:27:03 <conal> and i really don't know the causes of reactive's operational glitches.
12:27:48 <conal> that leak paper describes one operational issue. i don't know what other issues there are.
12:27:52 <sproingie> it seems the docs on some frp implementations suggest they actually use polling, which might be okay for a game UI but seems pretty ridiculous for a chat client
12:28:04 <chrisdone> I don't think ghc7 is any faster at compiling my project. if anything it's slower. I think that use of haskelldb is what is slowing compilation times. I use it quite extensively. it's probably time to rewrite haskelldb with more recent technologies (indexed type families and the awesomeprelude) anyway
12:28:31 <conal> sproingie: right. almost all frp implementations use polling.  see "push-pull functional reactive programming" for an alternative.
12:28:36 <tarrasch> thanks jmcarthur ! I'll read that
12:28:59 <conal> sproingie: http://conal.net/papers/push-pull-frp
12:29:01 <jmcarthur> tarrasch: yeah, keep in mind that there many be more issues than just the one in that paper
12:29:20 <sproingie> conal: where a keypress or a button would be "push" and polling would be "pull"?
12:29:21 <tarrasch> jmcarthur, oh ok
12:29:33 <chrisdone> alright I'm off to bed
12:29:50 <jmcarthur> tarrasch: the one mentioned in the paper is the one that i'm exploring fixing with different evaluation orders (the paper fixes it by changing the api completely)
12:30:13 <conal> sproingie: where event response is push and continuous animation is pull
12:30:15 <tarrasch> jmcarthur, are you much into frp?
12:30:15 <jmcarthur> s/the paper fixes/the authors fix/
12:30:29 <jmcarthur> tarrasch: yeah, it's always on my mind it seems
12:31:07 <conal> push implementations are easy if you don't mind getting them wrong. otherwise, tricky.
12:31:15 <kmc> :t let foldr (%) z = go where go [] = z; go (x:xs) = x % go xs in foldr
12:31:16 <lambdabot> forall t t1. (t -> t1 -> t1) -> t1 -> [t] -> t1
12:31:31 <jmcarthur> conal: funny wording ;)
12:32:07 <conal> jmcarthur: i've seen a lot of wrong implementations.
12:32:10 <kmc> > (\(+) -> 3 + 3) (*)
12:32:11 <lambdabot>   9
12:32:17 <jmcarthur> conal: wrong how?
12:32:30 <kmc> > case (*) of (+) -> 3 + 3
12:32:31 <lambdabot>   9
12:32:32 <sproingie> conal: i did start reading that a while back.  is reactive the implementation?
12:32:40 <jmcarthur> i've seen many implementations that i don't like, but i don't know about "wrong"
12:32:52 <jmcarthur> most of those implementations didn't give a specification anyway
12:32:52 <conal> jmcarthur: mis-ordering of event occurrences.
12:32:57 <jmcarthur> ouch
12:33:14 <conal> jmcarthur: yeah. even worse than wrong is no definition of right.
12:34:41 <conal> sproingie: yes. the push-pull paper describes reactive.
12:35:57 <conal> one question i was exploring in that work is what "push" could even mean in functional programming, which is heavily pull-biased.
12:36:31 <sproingie> conal: to me it suggests something like "clocked" vs "clockless"
12:37:01 <sproingie> i'd say synchronous and asynchronous which literally mean the same thing but they've grown a vastly different connotation
12:37:50 <conal> sproingie: keep in mind that there is a semantic specification, and the question is how to implement that spec (correctly) using pull.
12:38:13 <conal> sproingie: ie i don't throw out the spec/semantics when thinking about a push-based implementation.
12:38:26 <sproingie> i like simulations, so to me a clock is just another event that carries other events with it
12:38:36 <sproingie> and it may or may not be tied to real world time
12:38:46 <jmcarthur> "push" to me evokes thoughts of imperative actions... stateful objects and message passing or something. very operational-sounding
12:39:31 <conal> jmcarthur: exactly! that's what made the question of reconciling with FP so fascinating to me.
12:39:46 <sproingie> active objects, ala timber?
12:40:12 <olsner> oh, I wonder if I've read the push-pull paper
12:40:36 <jmcarthur> i don't know timber. the kind of thing i have in mind is erlang objects, where you can send a message without necessarily expecting a response. "send a message and magic happens"
12:41:10 <conal> jmcarthur: pure FP is full of imperative actions, but we keep them safely inside of the implementation of functional semantics. i like to wonder how we can move more imperative stuff out of our programming models into the implementation of clear & simple semantics. eventually eliminating IO altogether.
12:41:13 <jmcarthur> kind of like anything having type  IO ()
12:41:21 <ddilinger> trying to compile (ghc foo.hs) a file, its returning 'undefined reference to __stginit_mtlzm1zi1zi0zi2_ControlziMonadziState_
12:41:28 <ddilinger> what could that mean?
12:41:52 <conal> i haven't looked into timber much. looked pretty imperative to me.
12:42:03 <tarrasch> ddilinger, isn't that a clear enough error message? :p
12:42:03 <penelope> ddilinger: try ghc --make
12:42:08 <conal> anyone here know timber?
12:42:30 <sproingie> i only read some of the tutorials, didn't get around to using it
12:42:32 <ddilinger> yea, make does the trick, thanks :)
12:43:11 <sproingie> didn't older haskells use a stream-based IO approach instead of the IO monad?
12:43:38 <sproingie> you see echos of that in the dialog pattern in the Gentle Introduction
12:43:39 <conal> sproingie: yeah.
12:43:43 <jmcarthur> sproingie: yes. it was pretty horrible
12:43:56 <jmcarthur> sproingie: IO came along and made everything better, which is itself a curse
12:44:06 <jmcarthur> sproingie: because now many people see the problem as "solved"
12:44:08 <penelope> I miss monadic comprehensions...
12:44:38 <conal> the stream model's horribleness was a blessing. it urged people to keep searching. 
12:45:21 <conal> there was a quest for "functional I/O", and monadic IO side-stepped the question rather than solving it.
12:45:23 <jmcarthur> It's funny to me that the accepted solution to writing interactive programs in a purely functional language is to embed an impure, imperative language into it.
12:45:47 <conal> jmcarthur: funny and tragic.
12:46:05 <conal> since doing so doesn't solve the problems of imperative programming.  just repackages them.
12:46:10 <jmcarthur> exactly
12:46:48 <engla> it sounds like it's not even known if a functional solution exists(?)
12:47:01 <conal> if imperative programming is a paradigm for incomprehensible and non-composable programming then haskell's IO is a power-tool for incomprehensible and non-composable programming 
12:47:05 <penelope> We could just rename main to runIO
12:47:07 <jmcarthur> engla: need it be known?
12:47:26 <sproingie> i've written plenty of imperative code in compositional style
12:47:41 <jmcarthur> sproingie: ?
12:47:49 <sproingie> heck that's probably been haskell's single best contribution to my coding style
12:48:06 <arcatan> i've recently started documenting my code
12:48:08 <arcatan> dunno why
12:48:13 <conal> what's sad to me is that it's relatively unknown (compared with the 1980s) that that it's unknown whether there's a functional I/O solution 
12:48:48 <engla> jmcarthur: I'm just wondering if the "other" solution exists and what it looks like in that case
12:49:06 <sproingie> jmcarthur: writing transformations as folds.  each step alters the state, but i express the pipeline as a simple list of very high level steps that i can rearrange at will
12:49:17 <conal> engla: there might not be just one ("the")
12:49:37 <sproingie> all nicely orthogonal. composable
12:49:41 <engla> conal: ok, well that wasn't the important part
12:49:55 <sproingie> jmcarthur: it might not be very pure but i got halfway there
12:50:16 <jmcarthur> engla: this might seem a strange analogy, but bear with me. does a hammer do anything?
12:50:22 <sproingie> make more FP idioms in perl stop looking so hideous and i'd go even further
12:50:24 <conal> engla: i'm wondering also. and i talk about it in the hopes that others will start wondering again.
12:50:26 <tarrasch> Do anyone have any other solution than the IO-monad for IO? I think it's working quite well, doesn't it?
12:50:51 <engla> jmcarthur: ok, .. no, it just lies around
12:51:19 <jmcarthur> engla: now let's skip some increasingly complex examples and go straight to a computer. does a computer do anything?
12:51:20 <sproingie> tarrasch: Clean has a different approach
12:51:56 <sproingie> i'm not sure i'd go for clean's approach but it's an alternative anyway
12:52:10 <engla> jmcarthur: in analogy with the hammer no of course not. I mean, computers "do" as they are told
12:52:24 <conal> tarrasch: check out the intro to John Backus's Turing award paper, in which he discusses the fundamental weaknesses of imperative programming and recommends functional programming as a solution. haskell IO has the same weaknesses Backus decried.
12:52:24 <jmcarthur> tarrasch: IO is working well in that we can do the same things as imperative languages in exactly the same ways with exactly the same flaws :(
12:52:32 <sproingie> computers >>= \x -> ... as they're told :)
12:52:40 <jmcarthur> engla: what do you mean by "as they are told?"
12:52:44 * conal high-fives jmcarthur 
12:53:25 <engla> computers carry out instructions one bye one, the instruction list is basically "what to do"
12:54:04 <tarrasch> Well, bear in mind IO can't be pure, and side-effects do happen and the programmer must specify in what order they should happen.
12:54:19 <jmcarthur> engla: why do we use instruction lists?
12:54:38 <sproingie> because there isn't a single PORN instruction
12:54:43 <jmcarthur> engla: actually, ignore that question. wrong direction
12:55:07 <jmcarthur> engla: i see an apparent contradiction in what you just said and the fact that you said computers don't do anything
12:55:27 <jmcarthur> i think that's an interesting contradiction and is where we could be exploring
12:55:28 <conal> tarrasch: if you want to find functional/denotative alternatives to monadic IO, better watch out for limiting assumptions.
12:55:50 <proq> well *my* computer carries out instructions two by two
12:55:51 <engla> hm
12:56:36 <jmcarthur> engla: does a hammer do anything while you are using it or dropping it?
12:56:41 <conal> tarrasch: if you try to make that argument precise, i bet you'll find some of those assumptions.
12:56:48 <engla> I have no idea what you mean by 'do'
12:56:51 <sproingie> the ops go marching two by two, haroo, haroo
12:57:00 <jmcarthur> engla: neither do i. confusion is the first step :)
12:57:11 <conal> so as to avoid "proof by lack of imagination".
12:57:28 <engla> no it doesn't do anything
12:57:37 <penelope> The hammer is the proof, the theorem is your will.
12:57:38 <jmcarthur> engla: in what sense?
12:57:50 <tarrasch> conal, you mean we should abstract away from side-effects? (we don't have to assume that order of side-effects have to be specified etc.)
12:57:57 <engla> everything that happens with the hammer is the user doing something with it
12:58:12 <jmcarthur> awesome
12:58:12 <sproingie> most people prefer side effects happen in the order specified unless otherwise mentioned
12:58:18 <sproingie> "world, hello!"
12:58:29 <conal> tarrasch: for instance.
12:58:31 <jmcarthur> engla: and you can probably guess that i will pull this line of thinking toward computers
12:59:05 <engla> yes. do you object to computers as carrying out instructions? they are both tools I see that
12:59:12 <jmcarthur> engla: and my main point is that computers merely exist
12:59:12 <conal> tarrasch: we already abstract away from side-effects quite a lot in FP. so why not more?
12:59:36 <jmcarthur> engla: and i typically think of mere existence as a declarative approach to something
12:59:59 <engla> ok
13:00:11 <shepheb> tarrasch: that's sort of tthe problem. it works well enough that nobody (except conal) is sufficiently bothered by it to search for a better solution.
13:00:39 <tarrasch> conal, because we wan't to be able to control the machine. The language would be less expressful if we couldn't choose in which order we want side-effects to occur.
13:00:46 <jmcarthur> engla: i would like to be able to write programs that "merely exist"
13:01:05 <jmcarthur> engla: like am able to craft a hammer
13:01:11 <tarrasch> shepheb, you mean most people are happy with how IO is working today?
13:01:25 <conal> shepheb: exactly. the opium den i mention in a comment on http://conal.net/blog/posts/the-c-language-is-purely-functional/
13:01:47 <engla> ok well, so with the program done and ready you install it on the computer and they are like one thing, something that just exists
13:02:02 <engla> if you see what I mean, computer is just a mechanism and you make the program like that too
13:02:05 <shepheb> whoops I was scrolled up
13:02:17 <sproingie> conal: what's the functional equivalent of the turing tarput?
13:02:19 <sproingie> tarpit
13:02:25 <jmcarthur> engla: that sounds reasonable to me
13:03:26 <jmcarthur> engla: while this isn't an existence proof, i think it's strongly indicative that declarative programming could be very natural if we could but ignore the notion that computers "do" things
13:03:57 <conal> sproingie: there could be many, couldn't there?
13:04:15 <conal> sproingie: e.g., SKI
13:04:28 <sproingie> trying to come up with something cleverly alliterative with "Church ____" and failing
13:05:12 <sproingie> programming could indeed be very natural if we ignored computers
13:05:24 <jmcarthur> shepheb: i'm bothered by it as well, and conal and i are not the only ones either
13:05:39 <engla> jmcarthur: do you mean some actual constraint is needed?
13:05:52 <jmcarthur> engla: i don't understand the question
13:05:53 <sproingie> my make-me-a-sandwich-language has only one instruction
13:06:23 <engla> jmcarthur: when we ignore that computers 'do' things, do you mean that you want to (excuse me) "change what computers do"?
13:06:47 <olsner> sproingie: IMO the "functional" tarpit is exactly the turing tarpit
13:06:55 <engla> Still somewhere, instead of hitting the nail, the computer will say "hello" when you use it.
13:08:39 <drhodes> "Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy." --Alan Perlis
13:10:31 <jmcarthur> engla: i want to think of the reactions that take place when i provide input to a computer the same way that i think of the reactions that take place when i drop something from a height
13:11:00 <ddarius> Unfortunately sproingie's make-me-a-sandwich instruction simply launches missiles and otherwise does nothing.
13:11:26 <sproingie> ddarius: i'm still working out the bugs
13:11:37 <copumpkin> it doesn't make a sandwich, but the missile inadvertently drops a pre-made sandwich off the top of it as it takes off
13:11:41 <copumpkin> thus achieving the desired goal
13:11:51 <Twey> Haha
13:12:03 <engla> jmcarthur: this could be chinese philosophy :-)
13:12:06 <copumpkin> and yes, inadvertently does suggest that the missile is aware
13:12:17 <sproingie> i was wondering why i needed to enter coordinates and elevation every time i wanted a sandwich
13:12:38 <shepheb> sproingie: what have you been entering?
13:12:43 <mornfall> drhodes: You wish. :) There are lot more things that are impossible in the Turing tar pit than there are that are possible.
13:12:44 <roconnor> what do I say in my .cabal file to say that my library requires RankNTypes?
13:13:06 <sproingie> shepheb: oh just fed it from /dev/random
13:13:08 <conal> tarrasch: do you *really* want "to be able to control the machine"? my guess is that you really want something else and you're having a hard time imagining any other way to get it.
13:14:06 <erikc> he prolly wants performance *duck*
13:14:39 <shepheb> I was puzzling in the summer of 2009 about declarative web frameworks. request, response. operations specifying their inputs from the data store which are provided as arguments to a pure function, and the result includes instructions on changes to the DB. whether that would be any better is unclear.
13:15:00 <conal> from one perspective, declarative programming is about *giving up* control of the machine, i.e. expressing the "what to be" rather than the "how to do".
13:15:18 <tarrasch> conal, well, by "control the machine" I meant to have side-effects that actually do something.
13:16:01 <conal> tarrasch: that's what i figured you meant. you think you really want operational control.
13:16:12 <shepheb> conal: I was reminded a lot of that during a comparative religion course (fascinating to say the least), wherein it was shown how most western traditions emphasize what one is to do (or think), whereas others emphasize how one is to be.
13:16:26 <tarrasch> conal, we mostly do pure programming in haskell. But since we also want ide-effects (print the result on the screen), something like IO is necessary 
13:16:34 <jmcarthur> dang, engla left
13:16:50 <jmcarthur> i felt like engla was getting it
13:16:54 <conal> tarrasch: that's the sort of informal argument that i'm encouraging you to clarify & dispel.
13:16:56 <sproingie> shepheb: counterexample A, confucianism.
13:17:30 <conal> tarrasch: (proof by lack of imagination)
13:17:33 <jmcarthur> lol that last thing i said did look like chinese philosophy :P
13:18:38 <shepheb> sproingie: yeah, not just from the west. that was a day 1, broad-strokes kind of comparison. the geography doesn't match up well at all, but I didn't want to list a half-dozen traditions for each of those categories, plus the further category emphasizing how one is too see/experience.
13:19:02 <sproingie> "To be is to do" --Socrates.  "To do is to be" --Sartre.  "Do be Do Be Do" --Sinatra.
13:19:05 <jmcarthur> we need side effects, therefore we need side effects
13:19:27 <tarrasch> conal, ok, I'll sleep on it, and tomorrow, if I find you here I will try to give you refined, well-motivated arguments why IO in haskell is good (not optimal, but why side-effects are wanted in a imperative non-declarative way). Maybe I've changed my mind by then. Does that sound good? :)
13:19:34 <jmcarthur> that wasn't how i meant to say that
13:19:54 <conal> tarrasch: Daniel C Dennett : Philosophers' Syndrome: mistaking a failure of the imagination for an insight into necessity.
13:20:04 <jmcarthur> "If we need side effects then we need side effects, therefore we need side effects."
13:20:08 <jmcarthur> :t fix
13:20:09 <lambdabot> forall a. (a -> a) -> a
13:20:16 <jmcarthur> circular logic! :D
13:20:18 <conal> tarrasch: you bet. sweet dreams.
13:20:31 <roconnor> jmcarthur: hey, if haskell says it is logically sound ...
13:20:32 <conal> jmcarthur: thx for that rephrasing.
13:20:43 <conal> also called "begging the question" iiuc
13:20:54 <jmcarthur> i think that is correct
13:21:01 <conal> http://en.wikipedia.org/wiki/Begging_the_question
13:21:40 <shepheb> I hesitate to use "begging the question" in the original sense, because it's more often used for "raises the question". "circular logic/reasoning" is much safer re: preventing misunderstanding.
13:22:09 <jmcarthur> they do seem to be different things according to wikipedia, but the difference seems subtle
13:22:49 <conal> shepheb: me too. i didn't know i didn't know what "begging the question" meant until recently.
13:24:11 <roconnor> Is it better to put language extensions as pragmas in files or into the .cabal file? (or both?)
13:24:16 <jmcarthur> roconnor: both
13:24:45 <conal> roconnor: please put them in your files! otherwise i can't play with your code in ghci.
13:24:56 <roconnor> conal: indeed
13:24:59 <jmcarthur> roconnor: the .cabal file is really only meant to verify that the compiler supports those extensions, not to actually enable them. that it enables them is kind of a bug, but fixing it would not be backward compatible
13:25:02 <conal> jmcarthur: both??
13:25:16 <jmcarthur> roconnor: i think dcoutts plans to add another field with the originally intended behavior
13:25:18 <roconnor> jmcarthur: I'm good with that
13:25:19 <jmcarthur> conal: ^^
13:25:25 <conal> jmcarthur: thx
13:25:46 <shepheb> I think the OED marks the "circular reasoning" meaning of "begging the question" as obsolete; even many people with a background in logic don't know that meaning.
13:25:47 <roconnor> jmcarthur: is it a comma separated list or a space separated list?
13:25:54 <jmcarthur> roconnor: comma
13:26:01 <jmcarthur> roconnor: i tend to put each on a different line
13:26:11 <jmcarthur> but that's optional ;)
13:26:45 <roconnor> jmcarthur: do you know if MIT is now a valid License type?
13:27:17 <jmcarthur> roconnor: i think it is. dunno for sure. i tend to use ISC anyway
13:27:23 <jmcarthur> roconnor: cabal init lists MIT as an option though
13:27:37 <roconnor> oh what is ISC
13:27:43 <jmcarthur> i always have to say OtherLicense in order to use ISC
13:27:43 <roconnor> sounds intruging
13:27:54 <jmcarthur> ISC is like MIT, just slightly simpler
13:28:01 <jmcarthur> close to BSD2 i think
13:28:19 <jmcarthur> http://en.wikipedia.org/wiki/ISC_license
13:29:09 <aristid> jmcarthur: cabal proposes BSD3 by default, not BSD2, tho
13:29:24 <jmcarthur> aristid: yeah. in fact, i don't think BSD2 is even a supported option
13:29:34 <roconnor> Hmm, I wonder if I should use it instead
13:29:49 <conal> i've been thinking lately about generalized lazy evaluation.
13:29:55 <jmcarthur> roconnor: i only use it because i like the simple wording
13:29:56 <conal> by which i mean semantically benign, automatic side-effects that improve some measure of performance.
13:29:56 <jmcarthur> conal: :D
13:30:21 <jmcarthur> conal: any examples of what you have in mind?
13:30:26 <roconnor> jmcarthur: hmm the fsf says it is ambiguous and suggests teh Expat license instead
13:30:46 <roconnor> oh
13:30:52 <conal> jmcarthur: one example is warren burton's "improving values". another is colin runciman's natural numbers.
13:30:53 <roconnor> and the Expat license is the MIT license
13:30:58 <conal> i want to find other examples.
13:31:09 <jmcarthur> roconnor: ambiguous how? it's basically bsd2 with some wording left out due to some internationally agreed convention
13:31:36 <roconnor> ``[The ISC] license does have an unfortunate wording choice: it provides recipients with "Permission to use, copy, modify, and/or distribute this software...." This is roughly the same language from the license of Pine that the University of Washington later claimed prohibited people from distributing modified versions of the software.
13:31:50 <roconnor> ``ISC has told us they do not share the University of Washington's interpretation, and we have every reason to believe them. Thus, there's no reason to avoid software released under this license. However, to help make sure this language cannot cause any trouble in the future, we encourage developers to choose a different license for their own works. 
13:32:01 <jmcarthur> conal: i don't know if it's actually related, but i was recently thinking about the ability to add dynamic reduction rules to data structures
13:32:17 <conal> jmcarthur: ah, interesting. may be very related.
13:32:18 <sproingie> UW claiming that black is white does not make black ambiguous
13:32:30 <conal> jmcarthur: do you have some examples in mind?
13:33:00 <roconnor> sproingie: well... you know how case law is ...
13:33:13 <roconnor> sometimes case law says black is white
13:33:55 <jmcarthur> roconnor: huh
13:34:00 <jmcarthur> roconnor: maybe i should move to MIT then
13:34:06 <mgsloan> UW?
13:34:14 <roconnor> jmcarthur: ya I don't know.
13:34:16 * mgsloan is junior undergrad
13:34:22 <roconnor> jmcarthur: that is what the FSF says.
13:34:26 <mgsloan> I wish there was more functional research here :/
13:34:36 <nostard> hi, I'm having som problems with simple concurrency: http://hpaste.org/41545/forkio
13:34:57 <wavewave> hello. I am confused about mtl and monads-fd and ....
13:35:55 <roconnor> wavewave: you may want to forget about all that nonsense and simply use monadlib instead.  It is better anyways.
13:36:06 <conal> jmcarthur: do the data structure reduction rules preserve semantics?
13:36:13 <wavewave> I would like to use MaybeT monad but when I cabal-install it, the system seems to install MonadIO instances for MaybeT . 
13:36:35 <jmcarthur> conal: i was working on a lambda calculus interpreter at the time that i thought of it. i was thinking it would be neat if i could define the interpreter as a set of graph reduction rules that don't unnecessarily transform a DAG into a tree
13:36:49 <c_wraith> wavewave, there are two versions of MaybeT.  get the one for either mtl or transformers, whichever you're using.
13:36:51 <mgsloan> (but otherwise UW is pretty ass-kickin)
13:36:52 <jmcarthur> conal: yes the idea is to only do semantics preserving reductions
13:37:06 <jmcarthur> conal: fit it into the runtime's graph reducer or something
13:37:06 <wavewave> Ahh... I see... 
13:37:25 <wavewave> Let me check it.. thanks. 
13:37:33 <conal> jmcarthur: cool. that's the sort of thing i have in mind also.
13:37:43 <wavewave> but just a general question. 
13:37:45 <c_wraith> wavewave, fortunately this sort of thing should be getting cleaned up now, with the release of mtl 2
13:38:07 <c_wraith> still a lot of work to be done, but eventually everything using either mtl 1 or transformers should be moved to mtl 2.
13:38:35 <wavewave> ghc-pkg seems selectively installing an instance of a type. 
13:38:44 <wavewave> Is it right?
13:38:49 <conal> jmcarthur: currently the run-time system performs a very limited collection of side-effects for improving performance. i want extend that collection, for the same reasons: to have both composability and efficiency.
13:39:03 <c_wraith> wavewave, No.  ghc-pkg doesn't work with anything more finely-grained than packages.
13:39:14 <wavewave> In the source code of MaybeT, it has instances of MonadIO.
13:39:31 <c_wraith> Yes, that's a natural spot to put them.
13:39:32 <wavewave> but when I check it using :i MaybeT in ghc, 
13:39:42 <wavewave> it does not have an instance of MonadIO. 
13:40:01 <conal> jmcarthur: colin runciman gives a nice example in his paper "What about the natural numbers?". our numerical types sacrifice composability for efficiency. and they don't have to.
13:40:10 <c_wraith> it's possible GHCi doesn't report an instance unless the type class is in scope.  import Control.Monad.Trans and ask it again
13:40:18 <jmcarthur> conal: i'll check it out
13:40:40 <conal> jmcarthur: cool. let me know what you think.
13:40:56 <conal> jmcarthur: colin is wonderfully old-school. still remembers the dream of FP.
13:40:57 <wavewave> c_wraith: Aha.. I do not have Control.Monad.Trans 
13:41:29 <c_wraith> wavewave, that's the module that's exported by both mtl and transformers.
13:41:33 <c_wraith> well, one of several
13:42:07 <wavewave> c_wraith: I see. Thank you.. 
13:42:16 <_mpu> why is monadlib better than mtl ?
13:42:31 <jmcarthur> conal: my basic idea is to be able to perform *in-place* reductions where they are semantics preserving, if i wasn't clear
13:42:45 <jmcarthur> conal: do you have a more general idea?
13:42:53 <conal> jmcarthur: that was my guess. and exactly what i want to do as well.
13:43:05 <conal> jmcarthur: i don't think my idea is any more general.
13:43:14 <jmcarthur> okay. just making sure we were on the same page
13:43:25 <jmcarthur> i have to go now. i would love to discuss this later
13:43:37 <conal> jmcarthur: you bet.  take care.
13:43:50 <jmcarthur> i have downloaded "What about the natural numbers?" and will read it when i get home
13:43:53 <wavewave> hmm, I really got messed up with all the monad transformer classes.. 
13:46:41 <roconnor> _mpu: it doesn't have broken instances of StateT Cont
13:48:14 <proq> is there a pdf version of LYAH?
13:49:42 <_mpu> roconnor: StateT is broken in mtl ?...
13:50:35 <roconnor> _mpu: yes
13:50:56 <roconnor> _mpu: to be fair it was not at all clear what the proper implemenation was when it was written many many years ago
13:51:12 <roconnor> but now we know better
13:51:17 <_mpu> hmm
13:51:23 <roconnor> (at least we think we know better)
13:52:24 <roconnor> _mpu: specifically the MonadCont instance of StateT is broken.
13:53:03 <roconnor> _mpu: so if you aren't using that instance, you don't have to worry about that problem. (you have other problems to worry about though)
13:55:16 <shepheb> is mtl 2 GHC 7 only?
13:55:40 <roconnor> wow, transformers is really nice.
13:58:54 <roconnor> Data.Functor.Identity++
13:59:05 <[swift]> am i right in thinking that ghc 7 won't land in the haskell platform until january?
13:59:47 <Igloo> [swift]: You are
14:00:34 <roconnor> I suppose Data.Functor.Constant is prefered over Data.Applicative.Const ?
14:00:35 <kamatsu> join #ooc-lang
14:00:36 <kamatsu> oops
14:00:55 <aristid> shepheb: no. it works JUST FINE on ghc 6.12 :)
14:05:55 <alex404> So I'd love to comply with GHC's request, but how do I switch to base 4*?
14:06:40 <aristid> alex404: you're writing a cabal package?
14:07:02 <alex404> aristid: Oh... yah... I suppose I can just write it in there.
14:07:08 <alexis> I have a function that return a integer, how can I call this function in the main (IIUC, I need to put some text here, not int)
14:07:15 <alex404> aristid: Sorry bout that.
14:07:45 <Botje> alexis: is that function pure?
14:07:49 <roconnor> alexis: what do you want to do with the integer?
14:07:51 <penelope> alexis: main = putStrLn $ show f
14:08:07 <roconnor> penelope: show f?!
14:08:17 <alexis> Botje: I dont now what do you mean by pure
14:08:20 <penelope> f:: ? -> Int
14:08:22 <orlandu63> main = print f
14:08:26 <alexis> roconnor: just print int
14:09:20 <roconnor> main = print (f <parameters>)
14:09:26 <roconnor> or
14:09:33 <roconnor> man = do print (f <parameters>)
14:10:16 <alexis> it doesnt print anything here
14:10:23 * hackagebot data-category 0.3.0.2 - Restricted categories  http://hackage.haskell.org/package/data-category-0.3.0.2 (SjoerdVisscher)
14:11:04 <penelope> alexis: Paste the line?
14:11:16 <orlandu63> roconnor: don't you main = print (f <arguments>)?
14:12:49 <roconnor> tomato tomato
14:13:05 <roconnor> ... that saying doesn't come out so well in text
14:13:26 <alexis> penelope: https://gist.github.com/702623
14:13:29 <roconnor> oh ya
14:13:32 <roconnor> main not man
14:14:12 <alexis> penelope: hmm, sry, it's working
14:14:24 <alexis> I was expecting the result after the compilation
14:14:32 <alexis> without laucnching the executable
14:14:42 <penelope> GHCI!
14:15:01 <alexis> why dont you like ghc ?
14:15:18 <orlandu63> alexis: use runhaskell
14:15:31 <orlandu63> if you want that kind of behavior (compile -> results)
14:15:41 <alexis> orlandu63: okay thx
14:15:58 <penelope> ghci is interactive. After hitting ^c^l, in emacs, you can just run it with: main
14:16:32 <alexis> well, I've a makefile and I use the vim's :make 
14:17:31 <penelope> Ah. You might want to look at cabal. I don't know vi much, but you could run ghci in another terminal.
14:18:13 <alexis> okay, I'm looking at it thx
14:18:33 <penelope> you could use it to show the results of a pure function, eg. Main> sumlist [1..10]
14:19:02 <alexis> okay cool
14:21:36 <penelope> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/ghci.vim
14:22:33 <penelope> http://www.vim.org/scripts/script.php?script_id=2356
14:23:11 <alexis> oh, rly cool
14:25:29 <asdfsdlfjsdlfjsl> hello
14:25:41 <asdfsdlfjsdlfjsl> hello haskell noobie here
14:25:52 <asdfsdlfjsdlfjsl> can anyone hear me
14:25:59 <str1ke> Nope.
14:26:04 <penelope> shh!
14:26:35 <alexis> :)
14:27:31 <asdfsdlfjsdlfjsl> stupid question but I can't figure out how to use the documentation for libghc6-hjscript-doc even though I have it installed on my ubuntu -- anyone care to give the one line magic command?
14:28:18 <penelope> cd /usr/share/doc/libghc6-hjscript-doc ?
14:28:35 <int80_h> oh snap!
14:28:42 <penelope> Do you have dwww installed?
14:28:55 <penelope> (or the ubuntu equiv?)
14:29:07 <asdfsdlfjsdlfjsl> what's dwww
14:29:15 <int80_h> get thee behind me ubuntu!
14:29:28 * hackagebot hscurses-fish-ex 1.3.1 - hscurses swimming fish example  http://hackage.haskell.org/package/hscurses-fish-ex-1.3.1 (DinoMorelli)
14:29:49 <c_wraith> the ubuntu package is dwww
14:29:56 <penelope> For debian, it presents all of your documentation for your browser: e.g. http://localhost/dwww
14:30:51 <asdfsdlfjsdlfjsl> ok thanks so much I will go try those out
14:31:49 <penelope> sudo apt-get install dwww
14:34:45 <int80_h> good afternoon dagit :)
14:35:00 <int80_h> lispy too
14:38:10 <Mathnerd314> is there an equivalent of MVar for the ST monad?
14:38:12 <roconnor> So running runhaskell Setup.lhs haddock   yeilds the error
14:38:20 <roconnor> <command line>: cannot satisfy -package-id transformers-0.2.1.0-83bd04c7d756a68d4480a7c48ea90dcc
14:38:27 <roconnor> any tips on dealing with this?
14:38:48 <penelope> It might be installed via apt-get--sometimes there are weird conflicts
14:39:07 <penelope> You can try removing it via apt...
14:39:38 <penelope> and then directing installing via cabal--cabal install transformers-0.2.1.0
14:39:40 <kmc> Mathnerd314, ST doesn't allow concurrency, because the result would be nondeterministic
14:39:54 <kmc> what are you trying to do?
14:40:39 <Mathnerd314> nothing much.
14:41:06 <roconnor> runhaskell Setup.lhs build works fine
14:41:41 <penelope> It's a weird package error.
14:42:14 <andy__> so this is going to sound like a test question or something along those lines
14:42:36 <andy__> but how would you find all sets of numbers (duplicates in each "set" allowed, so really lists) that sum to N?
14:42:50 <andy__> what complexity would you expect?
14:43:10 <penelope> 2 n log n 
14:44:02 <sproingie> sounds like the change problem
14:44:26 <sproingie> given x quarters, nickels, dimes, etc how many combinations sum up to $x.xx
14:44:47 <kmc> Mathnerd314, there are unsafe ways to embed IO actions in ST, but this is equivalent to simply using IO and using unsafePerformIO in place of runST
14:44:55 <kmc> in GHC, unsafePerformIO and runST have nearly identical implementations
14:45:23 <kmc> the ST magic is all in the types and the limited set of primitives
14:45:39 <penelope> sort, iterate, binary search
14:46:03 * ddarius should make a declarative concurrency monad.
14:46:24 <andy__> sproingie: the minimization part is not required, but otherwise, yeah
14:46:33 <kmc> ddarius, how would it work?
14:46:34 <andy__> thanks, that gave me something to read though
14:47:10 <ddarius> kmc: It would be ST restricted to data flow variables with concurrency additions.  I'd probably wrap IO with an ST-like veneer.
14:48:06 <Mathnerd314> kmc: Var s a with newVar :: a -> ST s (MVar s a) ought to be thread-safe under runST
14:48:30 <ddarius> I could be even more evil and allow a lazyRead :: DCVar a -> a so that you could use these things pleasantly.
14:49:33 <Mathnerd314> s/MVar/Var
14:55:28 <roconnor> haddock doesn't call the ghc binary does it :(
14:55:50 <ddarius> Why would it do that?
14:56:12 <roconnor> ddarius: because I have a ghc-wrapper to make it work.
14:56:13 <c_wraith> to extract type signatures if they weren't annotated?
14:57:46 <kmc> haddcok uses ghc's parser i thought
14:57:53 <kmc> it also expands TH splices
14:58:06 <kmc> Mathnerd314, yeah, you could make MVars in ST, but not use them in any interesting way, since you can't forkST safely
14:58:09 <KSkrzet> which vector library is the right one to go for high level, fast (fused?) code?
14:59:37 <Mathnerd314> kmc: with forkST :: ST s () -> ST s ThreadId ?
15:00:43 <ddarius> KSkrzet: There are several depending on what exactly you are doing.  Look at vector, repa, and dph, though vector is probably the one you want if you aren't doing something domain specific.
15:00:49 <aavogt> haddock must use the ghc-api: it writes inferred type signatures when you leave them out
15:01:03 <kmc> Mathnerd314, yeah
15:01:14 <kmc> Mathnerd314, if you allow that, it's very hard for runST to enforce deterministic computation
15:01:49 <ddarius> kmc: If you haven't already, you should read Peter van Roy and Seif Haridi's CTM.
15:01:51 <zachk> ghc 7.01 is out WOOT WOOT 
15:01:54 <kmc> ok
15:02:02 <zachk> is that book really that good ddarius? 
15:02:18 <KSkrzet> ddarius: what about uvector? is it worth a look?
15:02:28 <ddarius> zachk: I don't know what "that good" means, but the answer is probably "yes."
15:02:31 <ddarius> KSkrzet: No.
15:02:39 <ddarius> uvector has been subsumed by vector.
15:04:11 <KSkrzet> ddarius: ah, ok. About repa: it depends on dph -- is it available for 7.0.1 ?
15:06:37 <danharaj> is there a type class for types that are 'like' functions in the sense that they have an eval and curry function?
15:07:15 <mauke> eval?
15:07:16 <roconnor> danharaj: cartesian closed category
15:07:36 <roconnor> danharaj: http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Category-Cartesian-Closed.html
15:08:21 <danharaj> roconnor: thanks. that looks really heavy-weight though.
15:08:33 <danharaj> roconnor: but I guess I can specialize a lot of those parameters
15:08:46 <roconnor> ya it is heavy weight
15:08:54 <roconnor> I wonder if there is anything lighter around
15:08:55 <ddarius> ArrowApply technically is that plus a bit more.
15:09:32 <danharaj> mauke: the way I usually see exponentials defined is by adjunctions, eval and curry are the unit and counit of the adjunction. Might have gotten that backwards. Never can remember which is the unit.
15:09:59 <ddarius> danharaj: That's not just backwards, it's mixed up.
15:10:03 <roconnor> mauke: eval is called apply in my link
15:10:18 <thom_logn> what is the state of haskell to javascript development? Mostly sorta working or mostly experimental?
15:10:19 <danharaj> ddarius: ultimately possible, cause I never worked out that example for myself :|
15:10:20 <ddarius> eval is the counit and curry is part of the isomorphism, not a unit or counit.
15:10:36 <danharaj> ddarius: what is the unit of the adjunction?
15:10:38 <roconnor> ugh
15:10:45 <ddarius> :t curry id
15:10:46 <lambdabot> forall a b. a -> b -> (a, b)
15:10:47 * roconnor doesn't even want to know what coexponentials are
15:10:50 <ddarius> That.
15:10:53 <danharaj> fair enough.
15:11:17 <kmc> "The problem is (->) lacks an initial object, since every type is inhabited in Haskell. Consequently its coproduct is merely a semigroup, not a monoid as it has no identity, and since we want to be able to describe its dual category, which has this non-traditional form being built over a category with an associative bifunctor rather than as a monoidal category for the product monoid."
15:11:33 <kmc> from now on, i am going to answer every Haskell question with that
15:11:59 <kmc> thom_logn, there's active work on a Javascript backend for UHC, check out their blog
15:12:03 <roconnor> oh come on
15:12:08 <kmc> there's also ghcjs
15:12:14 <copumpkin> kmc: it's not too obscure :)
15:12:17 <kmc> i don't know how usable either is
15:12:19 <roconnor> newType InitalObject = InitalObject InitalObject
15:12:23 <roconnor> ^^ how about that one
15:12:32 <copumpkin> kmc: however, most of us ignore the presence of bottom and pretend that data Void is initial :P
15:12:34 <ddarius> roconnor: That's terminal.
15:12:44 <roconnor> newType TerminalObject = TerminalObject
15:12:50 <roconnor> er
15:12:51 <copumpkin> that's not even valid
15:12:53 <roconnor> not a newtyupe
15:12:55 <thom_logn> thanks for the pointer. 
15:12:57 <roconnor> data TerminalObject = TerminalObject
15:13:03 <roconnor> ^^ that is the terminal object
15:13:03 <danharaj> that's neither
15:13:08 <ddarius> roconnor: Nope.
15:13:09 <roconnor> pft
15:13:10 <copumpkin> newtype X = X X and data X = X have the same size
15:13:16 <thom_logn> haskell still makes my head spin at times
15:13:20 <danharaj> the initial object would be the empty type if it could exist.
15:13:21 <roconnor> you guys must have the wrong morphisms
15:13:29 <mauke> copumpkin: huh?
15:13:36 <thom_logn> mophically wrong...
15:13:40 <copumpkin> mauke: both types contain one element
15:13:43 <copumpkin> oh wait
15:13:45 <copumpkin> no
15:13:46 <copumpkin> :)
15:13:47 <ddarius> Arguably InitialObject isn't terminal either, insofar as there is more than one function A -> InitialObject.
15:13:56 <copumpkin> the latter one has two inhabitants
15:14:09 <danharaj> right, because \bot is also an element of (A -> InitialObject)
15:14:19 <roconnor> lame
15:14:23 <roconnor> :)
15:14:25 <copumpkin> -XTotalHaskell
15:14:28 <danharaj> heh
15:14:52 <ddarius> Of course, Haskell doesn't form a category at all in the naive way so all this talk of "objects" is mere claptrap.
15:14:59 <roconnor> next you are going to tell me Haskell isn't even a cateagory
15:15:15 <danharaj> no, he already did :p
15:16:18 <int80_h> how can I create a type in ghci? I'm trying to do this (//) :: String -> String -> String
15:16:29 <mauke> that doesn't create a type
15:16:41 <danharaj> that states that (//) has a type.
15:17:07 * ddarius spawns 30 instances of TuxGuitar all at once.
15:17:11 <ddarius> Yay RAM.
15:17:19 <danharaj> accidentally all the ram?
15:17:22 <int80_h> the type String -> String -> String specifically right?
15:17:28 <danharaj> yes
15:17:36 <danharaj> and the parentheses mean it is an infix operator
15:17:45 <mauke> what
15:18:02 <int80_h> okay, so how do I get that type expressed in ghci so that when I type :t (//) is returns the type above?
15:18:10 <int80_h> s/is/it
15:18:10 <copumpkin> you can never have too much RAM
15:18:18 <int80_h> that's what she said?
15:18:19 <copumpkin> man, before I quit my program I had a server with 32G of it
15:18:21 <mauke> int80_h: is (//) in scope?
15:18:21 <copumpkin> :(
15:18:27 <danharaj> you have to define (//) in ghci's scope
15:18:36 <osaunders> I really really wish I could use ? at the end of identifiers.
15:18:38 <danharaj> you don't even have to state the type, ghci can figure out a simple type like that.
15:19:03 <kmc> osaunders, Lisp user detected, activating kill-bots
15:19:14 <osaunders> kmc: Ruby actually
15:19:19 <osaunders> Not any more though
15:19:30 <copumpkin> I came from ruby too
15:19:44 <Raynes> I came from Alabama with a banjo on my knee.
15:19:45 <copumpkin> just over a couple of years ago I'd never even seen a line of haskell
15:19:53 * copumpkin twangs Raynes 
15:20:10 <osaunders> copumpkin: :P
15:20:13 <osaunders> *:O
15:20:25 <osaunders> P and O are too close together
15:20:29 <copumpkin> OOP
15:20:34 <copumpkin> (it was a mistake)
15:21:14 <int80_h> I came from Lisp, which I never used to do anythign heavy anyway.
15:21:30 <int80_h> Lisp is the gateway language of the functional world.
15:21:54 <mauke> I disagree
15:21:58 * ddarius came from Alabama without a banjo and also came from Alabama owning but physically possessing a banjo.
15:22:21 <ddarius> +not
15:22:36 <zachk> i infer you came from alabama at least twice in your life
15:22:37 * ddarius fiddles.
15:22:47 * mauke came
15:22:51 <int80_h> mauke, really?
15:22:51 <zachk> i once came from alabama as well yall
15:23:01 <int80_h> yee, and haw
15:23:12 <zachk> so vector is what i want if i want fast mutable arrays? 
15:23:53 <copumpkin> zachk: or immutable
15:24:04 <zachk> can immutable be fast? 
15:24:26 <fieldd> ok, so I'm in the scratch buffer... and when I press the tab key, nothing happens. How do I indent?
15:24:28 <zachk> cause i read that regular arrays are very slow with mutations (even being immutable ummm...) 
15:24:38 <fieldd> whoops, nevermind, wrong channel
15:24:40 <zachk> use the space bar :( 
15:24:52 <fieldd> (that was supposed to be asked in emacs)
15:25:07 * zachk figured as much :) 
15:25:16 <roconnor> zachk: STArrays are reasonably good
15:25:20 <roconnor> for mutation
15:25:36 <int80_h> mauke, don't you think that as one becomes dissatisfied with Lisp it might lead one to a language like Haskell or Ocaml?
15:25:46 <c_wraith> shouldn't STUArrays be basically as good as possible, aside from the Ix bounds-checking?
15:25:47 <zachk> i kinda wanna do my own misc architecture and i want to emulate memory so ok thank you ill look at that 
15:25:52 <mauke> int80_h: from personal experience, no
15:26:01 * roconnor used Lazy STArrays for awesome dynamic programing jobs.
15:26:26 <int80_h> <Elizabot> mauke, tell me about your personal experience </Elizabot>
15:26:31 * int80_h giggles
15:26:35 <int80_h> but seriously...
15:27:13 <mauke> I went from C and Perl to Common Lisp, learned a bit, and was completely underwhelmed
15:27:20 <mauke> ("WTF is this shit?!")
15:27:57 <mauke> later on someone asked an OCaml question in a Perl channel, and that got me into OCaml
15:28:13 * ddarius didn't learn Haskell (or O'Caml or SML) until years after learning and not really using Scheme and CL.
15:28:36 <mauke> then I found Haskell, had a short look, didn't understand anything, and went back to OCaml and Perl
15:28:36 <ddarius> Moral of mauke's story: spam other channels with off-topic questions.
15:28:45 <danharaj> I saw OCaml once
15:28:50 <danharaj> wasn't pretty :\
15:28:57 <ddarius> Now danharaj can't see at all.
15:29:05 <danharaj> heh
15:29:05 <mauke> much later: I tried Haskell again and kept at it
15:29:14 <mauke> now I find OCaml unbearably ugly
15:29:27 <mauke> Perl is ok, though
15:29:29 <lucca> ocaml's improved a lot, but it's still a mess
15:29:54 <danharaj> You would think the French would have more investment in aesthetics.
15:30:25 <lucca> well the built-in object system was pretty worthless.  caml itself is also sorta meh
15:30:52 <lucca> from an operational standpoint, My main gripes were lack of stacktraces unless you used the bytecode version
15:31:03 <lucca> and related trouble
15:31:06 <lucca> but they fixed that
15:31:15 <mauke> doing string stuff in OCaml was also pretty ugly compared to Perl
15:31:16 <Cale> int80_h: I'm not sure since I only really tried Lisp after having a few years experience with Haskell, but I found Common Lisp to be really annoying for trying to do functional programming in.
15:31:16 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
15:31:21 <aristid> ddarius: which languages did you actually use before haskell?
15:31:40 <mauke> OCaml has immutable strings with mutable characters ... what's the point of that?
15:31:46 <Cale> (Scheme was better, though I still find it really hard to live without a type system)
15:32:49 <aristid> mauke: is that a joke?
15:32:55 <mauke> no
15:33:06 <aristid> mauke: they use mutable arrays for strings?
15:33:10 <mauke> yeah
15:33:20 <aristid> well that maps perfectly to C.
15:33:29 <mauke> also, lists, strings and arrays are separate types
15:33:39 <mee> mauke: you give me (a perl programmer) hope that I'll eventually find Haskell syntax pleasant -- I've just been putting up with it to get to all the other goodness
15:33:42 <aristid> mauke: strings SHOULD be separate types from lists.
15:33:47 <mauke> aristid: no, I can actually change the length of a string in C
15:33:53 <aristid> String should be a newtype, not a type synonym
15:33:57 <aristid> :)
15:34:10 <copumpkin> aristid: then you lose easy pattern matching for newbies
15:34:13 <danharaj> We should be able to parametrize types over implementations.
15:34:16 <copumpkin> which seems to be what h98 was designed for, sadly
15:34:29 <copumpkin> danharaj: data families ? :P
15:34:33 <danharaj> maybe? I don't know.
15:34:40 <danharaj> I haven't touched the latest and greatest extensions.
15:35:01 <ddarius> aristid: QBASIC, C, C++, assembly (primarily x86), Prolog, Scheme, CL, Smalltalk, Javascript, Perl, Java.  C++ was by far my language of choice through that time, with assembly and Scheme probably being distant seconds.
15:35:22 <danharaj> I am nervous about adding such a parametrization in a language where you can't prove in the language that it is actually an implementation.
15:35:26 <mauke> mee: what do you hate about Haskell syntax?
15:36:03 <hpc> mee: having done my most useful code in perl, you will find haskell to be simultaneously completely different and quite comfortable
15:36:05 <danharaj> if List a is parametrized over implementations, say arrays, finger trees, ropes, whatever, there should be a guarantee that two lists with different representations should be observationally equivalent.
15:36:11 <c_wraith> everyone should hate "modify $ \s -> s { foo = bar}".  Which is why there are so many libraries that try to do better.
15:36:26 <hpc> :t modify
15:36:27 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
15:36:48 <hpc> yeah... that idiom is a pain in the ass
15:37:18 <aristid> ddarius: seems like there's a fair number of people coming from c++ to haskell (including myself)
15:37:33 <danharaj> I hobbied in c++
15:37:36 <alex404> If I've got a list xs, and I create a new list x:xs, how does ghc maintain these two lists distinctly?
15:37:56 <danharaj> alex404: they share the common part (at least for that case)
15:38:10 <alex404> danharaj: How does it do that, though?
15:38:12 <danharaj> since in Haskell you can't mutate data, you can do such things.
15:38:23 <alexis> I dont understand what's wrong with that https://gist.github.com/702739
15:38:25 <alexis> any hint ?
15:38:35 <danharaj> alex404: It depends on the compiler. A compiler doesn't even have to share them.
15:38:37 <mee> mauke: A bit hard to express, but I like parens and dislike having to depend on operator precedence, and it's taking me a long time to really get those down in Haskell. I find I make a lot of annoying mistakes with parens (or lack thereof) and $'s, etc.
15:39:19 <danharaj> alex404: if you know C you should be able to figure out a simple scheme for basic data sharing on your own.
15:39:21 <ddarius> aristid: I wouldn't say I "came" from C++.  C++ was one of the earliest languages I learned, and I still rather like C++ and use it now and then.
15:40:07 <c_wraith> alexis, you're having precedence errors.  infix operators are always lower precedence than function application.
15:40:10 <mauke> mee: you like parens? I'm afraid we can't be friends :-)
15:40:11 <orlandu63> alexis: functino application (spaces) has a higher precedence than infix operators
15:40:27 <alex404> danharaj: Well the real case I'm considering is a zipper. If I'm moving through even a simple list monad, (xs,ys) by popping elements back and forth, how is ghc maintaining this structure?
15:40:33 <aristid> ddarius: you probably use a lot less c++ now, and you used to use mostly c++. why is "came from" not appropriate then?
15:40:33 <danharaj> doesnt application have the highest precedence period?
15:40:41 <alexis> infix ?
15:40:52 <c_wraith> alexis, + is an infix operator.
15:41:00 <alex404> danharaj: moving through a list zipper, that is
15:41:02 <mauke> danharaj: r{ ecord = update }
15:41:05 <danharaj> alex404: I don't know. Maybe someone else does.
15:41:05 <c_wraith> you are saying "(fibo x) + y"
15:41:10 <alexis> ah right
15:41:24 <alex404> danharaj: Cheers
15:41:25 <c_wraith> of course, the type isn't right anyway.  But that's your immediate problem. :)
15:41:43 <orlandu63> and even if you put parenthesis around (x + y), the code won't compile because you're not applying enough arguments to fibo
15:42:12 <c_wraith> yeah, you probably want "fibo y (x + y)"
15:42:36 <alexis> exactly
15:43:15 <alexis> that's a bit strange to write those functions this way, I'm not used to that :)
15:43:18 <alexis> (yet !)
15:44:29 <c_wraith> Just remember the two basic rules.  operators always come after function application, and function application needs no special syntax.  it just needs to lex into multiple adjacent tokens
15:44:51 <alexis> hmm, strange, the fibonacci sequence is starting to go mad after 1836311903
15:45:04 <alexis> then it's starting to loop on negative numbers
15:45:12 <ddarius> aristid: I mostly just don't write as much code as I used to.  I don't think I've written much more Haskell than C++ during the time that I've known Haskell.  I will say that I did move from a C++ community to the Haskell community.
15:45:12 <alexis> -1323752223, â¦
15:45:17 <c_wraith> you're using 32 bit signed Int as your type
15:45:21 <c_wraith> change the type to Integer
15:45:24 <c_wraith> that's not bounded
15:45:35 <alexis> okay
15:45:39 <aristid> ddarius: i see.
15:45:49 <alexis> thanks a lot for you help, it's priceless
15:45:57 <copumpkin> ddarius: we need a good boston hackathon to fix that
15:46:11 <copumpkin> when I stop feeling like a nomad :P
15:46:30 <copumpkin> I'd prefer being conomadic right now
15:46:39 <c_wraith> places move around you?
15:46:51 <copumpkin> the world has always revolved around me
15:46:55 <copumpkin> ever since I was conceived
15:47:02 <c_wraith> well, yes, but not as usefully as it could have
15:48:26 <ddarius> copumpkin: How goes the brick box hunt?
15:48:44 <copumpkin> ddarius: just visited a so-so place but it's pretty expensive for what I'm getting (beyond location) :/
15:48:59 <copumpkin> will probably start looking around somerville/cambridge too
15:51:13 <ddarius> copumpkin: If you get a place near a metro station it shouldn't really affect your commute that much and I'm fairly confident the price will be -much- lower.
15:51:35 <copumpkin> yeah
15:53:25 <alexis> still in my exemple, how can I stop my list to build from a certain number ?
15:53:48 <alexis> say that I want to get the list of the first N elements of the fibonacci suite.
15:57:56 <alexis> okay, take n mylist
16:02:45 <danharaj> So after much thought, I think that a good model for FRP is hidden markov models.
16:04:24 <conal> danharaj: blog post, please! i'd love to read about your ideas.
16:04:49 <c_wraith> alexis, you might alternatively want takeWhile (< n) 
16:05:34 <copumpkin> danharaj: take time out of the thing completely?
16:05:50 <copumpkin> pchiusano wrote a blog post recently on something like that
16:06:06 <copumpkin> http://pchiusano.blogspot.com/2010/07/reification-of-time-in-frp-is.html
16:06:42 <alexis> c_wraith: yep, that's the one I'm trying by now
16:06:53 <alexis> this eulers problems are really a good exercise
16:07:28 <c_wraith> alexis, they're good for introducing you to the base syntax, and for testing your math knowledge.  They don't do much for teaching you how to program things other than math exercises. :)
16:07:44 <alexis> true
16:07:52 <alexis> but I need to get started with something by now
16:08:02 <shepheb> they run out eventually, though... I've done around 105, and I don't have the math to penetrate most of the ones in the 100-120 range
16:08:08 <ddarius> danharaj: Now all you have to do is attempt to implement and find out why you are wrong.
16:08:18 <danharaj> ddarius: do you know why I am wrong? ;)
16:08:28 <copumpkin> danharaj: because you're trying to implement FRP!
16:08:33 <danharaj> heh
16:08:35 <alexis> shepheb: yep, I'm just at 2, I've a lot of time so
16:08:43 <copumpkin> just kidding, of course
16:09:07 <shepheb> alexis: definitely. Programming Praxis has some more good small exercises. then write an interpreter for something.
16:09:15 <danharaj> copumpkin: well I have that sentiment too. It's a hard problem that has had quite a few talented and hard working guys attack it.
16:09:42 <copumpkin> danharaj: just means it needs more math jargon thrown at it
16:09:46 <copumpkin> eventually it'll work
16:09:49 <alexis> shepheb: okay, I note that 
16:09:51 <danharaj> heh
16:10:24 <danharaj> I just want to enforce causality and eliminate leaks caused by keeping the past around implicitly.
16:11:02 <conal> danharaj: while having a precise semantic foundation (and thus definition of correctness)?
16:11:27 <danharaj> conal: Well, I hope that by drawing on a well understood mathematical theory, that will fall out for free!
16:11:38 <conal> danharaj: good!
16:12:41 <danharaj> I am curious to know if ddarius knows more about what I'm going to be thinking about for the next couple of days than I do.
16:15:21 <ddarius> danharaj: That is unlikely, though I partially understand your motivation.
16:17:34 <thom_logn> trying to understand what this is telling me: fmap (+) :: (Num a, Functor f) => f a -> f (a -> a)
16:18:10 <hpc> thom_logn: look at the type of (+) first
16:18:12 <shepheb> thom_logn: fmap isn't really intended to work on binary functions...
16:18:13 <hpc> :t (+)
16:18:14 <lambdabot> forall a. (Num a) => a -> a -> a
16:18:29 <zygoloid> shepheb: works fine if you have a <*> ;)
16:18:35 <hpc> this should actually be a -> (a -> a), because currying is awesome
16:18:46 <hpc> so our fmap takes a function a -> b
16:18:51 <hpc> b == (a -> a)
16:18:56 <shepheb> zygoloid: true, and of course it's curried. the above is just f a -> f b with b = a -> a, after all.
16:19:00 <hpc> so the rest of fmap is f a -> f b
16:19:05 <hpc> which is f a -> f (a -> a)
16:19:25 <mee> shepheb/alexis/c_wraith: re: coding exercises, codequarterly.com has promise
16:19:40 <shepheb> mee: haven't seen this before, checking it out
16:19:57 <thom_logn> what would be a evaluable expression for ghci "fmap (+) ??? ???"
16:20:29 <sipa> :t fmap (+)
16:20:30 <lambdabot> forall a (f :: * -> *). (Num a, Functor f) => f a -> f (a -> a)
16:20:33 <mauke> :t fmap (+) (+)
16:20:34 <lambdabot> forall a. (Num a) => a -> (a -> a) -> a -> a
16:20:59 <mauke> > fmap (+) (+) 1 negate 12
16:21:03 <lambdabot>   1
16:21:18 <shepheb> O_o
16:21:21 <zygoloid> > map ($ n) (fmap (+) [a, b, c, d, e])
16:21:21 <lambdabot>   [a + n,b + n,c + n,d + n,e + n]
16:22:19 <shepheb> > fmap (+) (Just 3) <*> (Just 5)
16:22:20 <lambdabot>   Just 8
16:22:58 <shepheb> more typically written (+) <$> Just 3 <*> Just 5
16:23:25 <copumpkin> or liftA2
16:23:43 <mornfall> Wow.
16:23:43 <mornfall> cabal.exe: dependencies conflict: pathlib-0.1 requires ansi-terminal ==0.5.4
16:23:43 <mornfall> however
16:23:43 <mornfall> ansi-terminal-0.5.4 was excluded because pathlib-0.1 requires ansi-terminal
16:23:43 <mornfall> ==0.5.5
16:24:30 <thom_logn> what do I have to load in ghci to get <*> in scope?
16:24:38 <hpc> Control.Applicative
16:24:42 <aristid> import
16:24:52 <Cale> :m + Control.Applicative
16:25:20 <hpc> (the cool modules are Control.Applicative, Control.Monad, Control.Monad.Trans, and Control.Arrow)
16:27:30 <aristid> Control.Monad.Instances, too
16:27:48 <copumpkin> you can get <$> from Data.Functor, too
16:27:52 <copumpkin> surprisingly enough
16:30:13 <hpc> i have never ever imported Data.Functor
16:30:29 <hpc> i don't even know what's in it besides fmap and <$>
16:30:42 <copumpkin> there you have it
16:30:47 <hpc> oh, instances
16:31:15 <hpc> and (<$)
16:34:35 <warrenharris> can anyone tell me what I have to do to load Data.Binary into ghci 6.12.3?
16:34:38 <warrenharris>     Could not find module `Data.Binary':
16:34:38 <warrenharris>       It is a member of the hidden package `ghc-binary-0.5.0.2'.
16:34:53 <hpc> hidden package?
16:35:17 <warrenharris> that's what it says
16:35:17 <kmc> cabal install binary
16:35:35 <orlandu63> what does (<$) perform? some kind of functor coercion?
16:35:46 <hpc> @src (<$)
16:35:46 <lambdabot> (<$) = (<$>) . const
16:35:56 <kmc> @type (<$)
16:35:56 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
16:36:01 <c_wraith> heh.  amusing to not write it as fmap . const
16:36:03 <warrenharris> kmc: isn't Data.Binary part of the ghc distribution?
16:36:06 <kmc> i think there's only one thing it can do from its type
16:36:15 <kmc> warrenharris, apparently only the binary modules for GHC itself to use are
16:36:17 <hpc> > 5 <$ [1..6]
16:36:17 <kmc> that's why it's hidden
16:36:18 <lambdabot>   [5,5,5,5,5,5]
16:36:22 <kmc> "binary" is part of Haskell Platform, though
16:36:29 <warrenharris> ok, thanks
16:36:35 <c_wraith> > 5 <$ Nothing
16:36:36 <lambdabot>   Nothing
16:36:37 <kmc> anyway i bet 'cabal install binary' will fix your problem
16:36:42 <c_wraith> > 5 <$ Just "shrimp"
16:36:43 <lambdabot>   Just 5
16:37:01 <hpc> > 5 <$ "shrimp"
16:37:02 <lambdabot>   [5,5,5,5,5,5]
16:37:03 <hpc> :D
16:37:45 <kmc> > (,) <$ "abc" <*> "de" <*> "fg"
16:37:46 <lambdabot>   [('d','f'),('d','g'),('e','f'),('e','g'),('d','f'),('d','g'),('e','f'),('e'...
16:38:18 <aristid> > 1 <$ "abc"
16:38:19 <lambdabot>   [1,1,1]
16:38:48 <aristid> > 1 <$ guard True
16:38:49 <lambdabot>   No instance for (GHC.Show.Show (f t))
16:38:49 <lambdabot>    arising from a use of `M5468679174...
16:38:53 <hpc> kmc: that trick is sneaky code-golf
16:38:58 <aristid> > 1 <$ guard True :: [Int]
16:38:59 <lambdabot>   [1]
16:41:42 <Cale> You know your build times are too long when you can forget that you were building the code and come back, and it's still linking. :)
16:43:41 <aristid> Cale: at work, i have this happening with C.
16:50:14 <ddarius> Cale: Or you have a really short attention span.
16:50:42 <Cale> ddarius: That's possible :)
16:50:44 <hpc> you know your sentences are long when you can forget you are typing them and oh look, a school bus
16:59:44 <ojisan> so this
16:59:48 <ojisan> is the IRC chat? :D
16:59:57 <hpc> this
17:00:00 <hpc> is the IRC chat
17:00:05 <ojisan> great
17:00:06 <ojisan> i have a 
17:00:10 <ojisan> super newbie question
17:00:44 <ojisan> I'm going through the "Learn You a Haskell for Great Good!" tutorial
17:00:54 <mauke> oh yeah, this is the internet relay chat chat
17:01:11 <ojisan> <_<
17:01:19 <ojisan> not the #haskell irc?
17:01:21 <kmc> this is CNN
17:01:28 <kmc> i mean, this is the #haskell irc
17:01:32 <kmc> ask your question :)
17:01:35 <ojisan> oh phew. ok. :D
17:01:37 <ojisan> so it says
17:01:39 <mauke> this is johnny knoxville and welcome to #jackass
17:01:40 <hpc> haha
17:01:50 <kmc> this is cash cab
17:01:56 <ojisan> xD
17:02:07 <fieldd> DINGDINGDING
17:02:17 <ojisan> "open up your favorite text editor and punch in this function: ~~~"
17:02:20 <ojisan> then later
17:02:33 <ojisan> "save this as baby.hs or something. now navigate to where it's saved and run ghci from there."
17:02:49 <hpc> you would run ghci baby.hs
17:02:49 <ojisan> how exactly do i run ghci "from there"? o.o
17:03:00 <kmc> ojisan, from a command-line prompt
17:03:08 <kmc> you'd type:   ghci baby.hs
17:03:15 <kmc> what OS are you using?
17:03:28 <hpc> (if you are on windows, this means dealing with the woefully inadequate cmd.exe)
17:03:29 <ojisan> Mac OS X
17:03:33 <hpc> ah
17:03:37 <ojisan> i'm on terminal
17:03:52 <hpc> he means cd into the directory with baby.hs
17:03:53 <ojisan> prompt is prelude
17:04:12 <hpc> then run "ghci baby.hs"
17:04:29 <ojisan> tried that
17:04:31 <ojisan> it returned
17:04:33 <mauke> why is your prompt prelude?
17:04:41 <ojisan> i set it to ghci
17:04:45 <mauke> what
17:04:49 <ojisan> this is what it returned
17:04:51 <ojisan> <interactive>:1:0: Not in scope: `ghci'
17:04:51 <ojisan> <interactive>:1:5: Not in scope: `baby'
17:04:51 <ojisan> <interactive>:1:10: Not in scope: `hs'
17:04:56 <kmc> you're already in ghci
17:04:57 <ojisan> o.o
17:05:05 <hpc> to quit ghci, type :q
17:05:05 <ojisan> yeah i am, i just restarted it
17:05:09 <ivanm> :load baby.hs
17:05:12 <ojisan> ahh
17:05:15 <hpc> or that
17:05:24 <ojisan> it says
17:05:27 <ojisan> can't find file
17:05:29 <ojisan> no location info?
17:05:40 <ojisan> ?_?
17:05:41 <Cale> ojisan: Make sure that you're in the directory where the file is located
17:05:47 <hpc> are you in the directory with baby.hs?
17:06:03 <ojisan> how do i make sure i'm in the directory with baby.hs? xD
17:06:09 <ojisan> sorryâsuper newbie
17:06:10 <mauke> ojisan: how are you running ghci?
17:06:11 <ojiisan> ojisan: _<_
17:06:20 <ojisan> through terminal?
17:06:22 <Cale> ojisan: Use ls (outside ghci in the terminal) to see what files are in the current directory, cd to change directory
17:06:24 <Cale> yeah
17:06:53 <hpc> ojisan: http://dl.dropbox.com/u/37707/88383-1.png
17:07:04 <hpc> ojisan: set that as your desktop background until it becomes intuitive :D
17:07:16 <ojisan> lol, good idea
17:07:48 <hpc> also, something it doesn't mention on there:
17:07:56 <hpc> ".." is the next directory up
17:07:59 <ojisan> what do you mean by outside ghci in the terminal?
17:08:00 <hpc> "." is the current directory
17:08:20 <hpc> ojisan: when you open a terminal, you are at a terminal prompt
17:08:25 <ojisan> mmhmm
17:08:29 <hpc> ojisan: when you start ghci, it has its own prompt
17:08:40 <hpc> ojisan: so you need to exit ghci
17:08:53 <ojisan> ok
17:08:57 <ojisan> so basically, terminal prompt
17:09:05 <Cale> yes
17:09:20 <ojisan> "Use Is"
17:09:28 <ojisan> "command not found"
17:09:34 <hpc> "ls"
17:09:41 <ojisan> *facepalm* ok
17:10:02 <Cale> It's short for LiSt :)
17:10:05 * hpc is always surprised to see how patient this channel can be
17:10:16 <ojisan> OHHH! (yes, thank you for putting up with me)
17:10:29 <ojisan> most ppl are pretty harsh on newbies xD
17:10:54 <Cale> No problem :)
17:10:58 <mauke> I thought it stood for "list shit"
17:11:12 <hpc> haha
17:11:13 <ojisan> ok so
17:11:19 <ojisan> i've got my current directories liested
17:11:30 <mauke> no, it lists the contents of the current directory
17:11:39 <ojisan> ohh
17:11:40 <mauke> there's only one (per process)
17:11:46 <ojisan> so i should choose the directory
17:12:46 <Cale> ojisan: Yeah, you need to change directories with cd, until you're inside the one which your source code is in.
17:13:05 <ojisan> so just type in cd
17:13:11 <Cale> cd DirectoryName
17:13:16 <ojisan> right
17:13:23 <Cale> Will change to another directory which is inside the current one
17:13:32 <Cale> cd ..  will move up a level
17:13:42 <hpc> (helpful tip: press tab when you have only part of the name typed)
17:13:50 <Cale> right, I was going to mention that too
17:14:06 <Cale> tab will automatically complete stuff, so you don't have to type it all
17:14:15 <kmc> this is kind of off topic
17:14:15 <hpc> so to start with, just so we know where exactly you are, type "cd ~"
17:14:20 <kmc> could you maybe go to #haskell-overflow?
17:14:33 <ojisan> ahh ok
17:14:43 <ojisan> if it's fine with hpc
17:14:52 <ojisan> oh sorry for stealing your ID
17:15:04 <ojisan> xD nice touch with the extra i, by the way
17:15:11 <copumpkin> lol, nah, it wasn't mine
17:15:17 <copumpkin> I was just fooling around
17:15:21 <ojisan> :D
17:15:25 <ojisan> lol ok
17:15:42 <ojisan> i'll go to haskell overflow after i figure this out
17:15:43 <ojisan> is that ok?
17:16:17 <ojisan> okay
17:16:24 <ojisan> i navigated to cd "Haskell Files"
17:16:29 <mauke> you know you can be in multiple channels at once, right?
17:16:37 <ojisan> :O
17:16:39 <ojisan> no i did not
17:17:00 <copumpkin> :)
17:24:14 <jmcarthur> conal: i just finished reading that paper. was the example you were referring to the part about having natural numbers represented by (machine int, lazy nat)?
17:24:52 <conal> jmcarthur: yes.
17:25:10 <conal> jmcarthur: and mutating as the lazy nat gets evaluated
17:25:13 <jmcarthur> right
17:27:03 <jmcarthur> hmm
17:27:35 <conal> jmcarthur: another example of generalized lazy evaluation might be lazy unevaluation.
17:28:01 <conal> jmcarthur: optimizing for space over speed. especially with a LRU policy.
17:28:11 <conal> jmcarthur: for reachable but not recently used values
17:28:11 <jmcarthur> ah i see
17:28:28 <conal> jmcarthur: and in particular when the values are huge and live in video/gpu memory.
17:28:30 <jmcarthur> would be neat in a memo trie or something
17:29:27 <jmcarthur> turn entire subtrees back into thunks
17:29:28 <conal> jmcarthur: ah yeah. another nice example!
17:29:42 <fruight> hm, i just defined some recursive stuff without edge condition in ghci while having htop open and in seconds ghci had filled up over 4.5 GiB
17:29:54 <conal> jmcarthur: awesome. i hadn't thought of that one.
17:30:11 <fruight> i ^C'd it, but now im wondering, what does ghci do if memory is full? will it bring my system down?
17:31:07 <fruight> btw, even after Interrupting the calculation in ghci the memory stays allocated until i :q
17:31:39 <kmc> yeah, the GHC 6 runtime system never gives memory back to the OS
17:31:43 <kmc> this is fixed in GHC 7
17:32:03 <cdsmithus> fruight: runtime systems rarely release memory to the OS.  If you're worried about it being a memory leak in GHCi, though, I wouldn't be
17:32:03 <lambdabot> cdsmithus: You have 1 new message. '/msg lambdabot @messages' to read it.
17:33:01 <fruight> cdsmithus: i was just concerned about what would happen if i didnt interrupt... i didn't blame ghci for anything :P
17:33:22 <kmc> fruight, depends.  does your OS return an error on attempted allocation when there's no memory left?
17:33:41 <kmc> or does it (like default config Linux) blindly continue and then choke and die when the memory is actually demanded
17:34:00 <fruight> kmc: i didn't dare to try that yet :P
17:34:07 <fruight> im running archlinux btw
17:34:16 <jmcarthur> conal: so the core of this is the ability to modify the representation of pure values in place. this is similar to the implementation of DiffArray
17:34:23 <kmc> so any process (Haskell or no) which tries to use all your memory will invoke the OOM killer
17:34:35 <kmc> which is a kernel routine which decides,  based on a somewhat arbitrary heuristic, what process to kill
17:34:35 <cdsmithus> Wow... apparently I haven't talked on #haskell for at least 3 months... and I had a message!
17:36:11 <conal> jmcarthur: yeah, that's the core idea. ah, i'd forgotten about DiffArray. might be a different sort of thing, iirc.
17:36:46 <conal> jmcarthur: searching my memory. does a DiffArray get mutated when it's "changed" rather than evaluated?
17:37:01 <jmcarthur> conal: the array itself does
17:37:30 <cdsmithus> Random useless fact of the day: apparently if you try to compile Haskell on a system with 256 MB of RAM, GHC does okay, but the linker sometimes takes 30 minutes.
17:37:44 <hpc> haha
17:38:02 <jmcarthur> conal: the thing you are passing around is an MVar, and when you update the array, the value in the MVar is turned from the array itself to a (reference to a new mvar containing the array, a change to make to the array to get the old version back)
17:38:51 <jmcarthur> conal: so the updated version of the array is a new MVar to the array, and the old variable you have is the same old MVar but with different data in it
17:38:59 <ddarius> cdsmithus: Turn off split-obs.
17:39:02 <ddarius> s/obs/objs
17:39:29 <cdsmithus> ddarius: I chose to solve the problem by ordering 8 GB of RAM, instead.  Thanks, though!
17:39:33 <conal> jmcarthur: thx. i see there may be some helpful tricks there.
17:39:47 <Cale> I hate the linker. The amount of time that it takes almost defeats the purpose of separate compilation.
17:41:09 <Cale> It should clearly be doing more to retain the work that it did last time it linked the modules.
17:41:18 <copumpkin> damn right
17:41:38 <conal> jmcarthur: i bet there's also a nice application of generalized lazy eval to efficient exact real arithmetic.
17:42:01 <jmcarthur> conal: i suspected that was one of your motivating examples :)
17:42:07 <conal> jmcarthur: yeah :)
17:42:08 <conal> jmcarthur: as with the naturals, i think there's a tension between
17:42:13 <Cale> (maybe produce a balanced tree of partially linked results?)
17:42:17 <cdsmithus> Cale: I'm not complaining too much about performance with an amount of RAM that rival's some cache levels. :)
17:42:35 <Cale> cdsmithus: Yeah, I have plenty of ram and it's still too slow.
17:42:42 <conal> composability, which wants lots of partial info structure, vs efficiency, which wants little.
17:43:01 <conal> jmcarthur: and generalized lazy eval can perhaps resolve that tension.
17:43:52 <ddarius> Cale: Implement an ld compatible linker that is smarter.
17:44:57 <jmcarthur> conal: is generalized lazy evaluation a very accurate name for this?
17:45:20 <jmcarthur> conal: i'm a bit more tempted to call it generalized sharing, which i think might be a bit more precise
17:45:32 <conal> jmcarthur: sharing? hm.
17:45:44 <jmcarthur> well...
17:45:56 <jmcarthur> one of your examples contradicts that though, so maybe i should rethink
17:46:06 <conal> jmcarthur: "this" being semantically inert, efficiency-enhancing side-effects?
17:46:21 <conal> (in-place updates)
17:46:22 <jmcarthur> yes
17:46:43 <conal> oh -- in-place == shared?
17:46:55 <jmcarthur> right
17:47:35 <jmcarthur> but one example that i think doesn't *quite* fit was unevaluation
17:47:50 <conal> jmcarthur: i wouldn't have guessed that interpretation unless i already knew what you meant. and even then not easily.
17:47:52 <jmcarthur> the in-placeness fits, but the idea of sharing "work" doesn't
17:48:32 <jmcarthur> in what sense is it generalized lazy evaluation?
17:48:36 <kmc> gold is an ld-compatible (?) linker that's faster
17:48:39 <kmc> i'm not sure if it's really smarter
17:48:41 <conal> jmcarthur: different uses of a value share the effort one a single unevaluation, right?
17:48:53 <ddarius> kmc: It's faster but not in the right way (enough).
17:49:15 <kmc> Cale, my dream language is semantically whole-program, with caching throughout the compilation process to provide benefits of separate compilation transparently
17:49:27 <conal> jmcarthur: in that lazy evaluation is simply a semantically inert assignment (in-place update) whose purpose is to improve performance.
17:49:28 <jmcarthur> conal: i'm not sure if i would say that. the first use would reverse the effect
17:49:50 <ddarius> The benefit of separate compilation is being able to link in files after the fact.
17:49:52 <conal> jmcarthur: oh yeah. iswym.
17:50:47 <conal> jmcarthur: ... improve performance by sharing work. i see, the sharing part is important. it motivates the assignment.
17:51:47 <conal> jmcarthur: i'm thinking of lazy evaluation as a way of reusing the effort that went into improving a representation.
17:51:52 <jmcarthur> i think the most descriptive thing we've agreed on so far is that it's a "semantically inert update" in the name of some notion of efficiency
17:52:09 <conal> yeah. me too.  clear & accurate.
17:52:26 <conal> jmcarthur: though not catchy.
17:52:39 <jmcarthur> :)
17:52:56 <ddarius> "non-destructive destructive update"
17:53:02 <conal> :)
17:53:08 <jmcarthur> yeah i think the unevaluation example doesn't fit your motivation for associating it with lazy evaluation either
17:53:28 <conal> ddarius: i like it. the update destroys a representation but preserves a meaning.
17:53:44 <conal> "immutable mutation"
17:53:58 <penelope> Wasn't paying attention, but I always thought that graph vs tree was a nice image for lazy eval.
17:54:08 <jmcarthur> pure mutation?
17:54:14 <conal> oooh!
17:54:56 <conal> though i have a gripe with the increasingly popular use of "pure" to mean "side-effect free".
17:55:13 <jmcarthur> this is a counter example
17:55:35 <conal> i'd say "purely functional" to mean side-effect free. 
17:56:03 <conal> and i'd expect a "pure oo" or "pure logic" or "pure imperative" language to be very different.
17:56:23 <conal> i'm baffled about how this current use of "pure" evolved.
17:56:42 <aavogt> pure semantics
17:56:57 <conal> i'd expect pure semantics to mean no implementation.
17:57:07 <aavogt> or maybe lack thereof
17:57:10 <conal> or no syntax
17:57:14 <conal> sure
17:57:36 <conal> for instance "the pure semantics of imperative programming"
17:58:03 <penelope> But you still need a representation for abstraction.
17:58:14 <conal> ?
17:58:16 <penelope> In order to talk about it.
17:58:49 <penelope> You can get away from numbers with abstract algebra, but not syntax.
17:58:50 <jmcarthur> a pure function always gives the same results for the same arguments and does not cause any *semantically observable* side effects
17:58:54 <conal> in order to talk about pure semantics.  the semantics part is pure, and the talking part is talking.
17:59:02 <jmcarthur> "unobservable mutation"?
17:59:09 <conal> hm!
17:59:13 <ddarius> penelope: Abstract algebra is very "syntactic."
17:59:23 <conal> jmcarthur: nice one!
17:59:40 <conal> jmcarthur: which generalizes lazy evaluation
17:59:47 <conal> jmcarthur: and lazy unevaluation
17:59:51 <jmcarthur> indeed
17:59:55 <conal> i like it.
18:00:34 <penelope> If an unobservable mutates in the woods, does anyone notice?
18:01:22 <conal> :)
18:01:35 <winxordie> penelope: Depends, does its wave function collapse?
18:01:59 <penelope> :-)
18:02:50 <jmcarthur> conal: can you think of any cases where we would want to generalize it further to unobservable side effects? i honestly am not even sure if that's meaningful, but the question hit me
18:03:02 <jmcarthur> as in, things that are not just mutation
18:03:45 <jmcarthur> conal: oh! one example might be uploading data to the gpu
18:03:46 <ski> @tell roconnor re coexponentials, see "Subtractive Logic" at <http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.33.5588> by Tristan Crolard in 1999. (also a few comments at <http://ncatlab.org/nlab/show/exponential+object#related_notions_23>)
18:03:46 <lambdabot> Consider it noted.
18:04:03 <jmcarthur> it's basically most things i would use unsafePerformIO for i guess
18:04:17 <Cale> Wave function collapse is garbage collection for quantum mechanics.
18:04:20 <fruight> how could i define a fibonacci function thats more efficient than the recursive "fib x | x <= 1 = x | otherwise = fib (x-1) + fib (x-2)" ?
18:04:48 <Cale> It has no semantic effect, but it makes calculation take less space :)
18:04:55 <ski> conal,jmcarthur : splay trees
18:04:57 <conal> jmcarthur: hm. i've been thinking in terms GPU memory as being an extension of RAM. and mangaged by the same GC.
18:05:00 <conal> (managed)
18:05:05 <penelope> Cale: Interesting: We only need energy to forget, with large enough ram.
18:05:08 <jmcarthur> conal: finalizers?
18:05:16 <ski> conal : "lazy unevaluation" refering to replacing a value by its generating thunk ?
18:05:21 <johnnowak> fruight: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Using_Binet.27s_formula
18:05:31 <ddarius> Wave function collapse is garbage collection in the mind of the observer.
18:05:35 <jmcarthur> ski: that's a pretty good one
18:05:43 <conal> ski: yeah
18:06:05 <jmcarthur> ski: actually, i'm not 100% convinced on splay trees
18:06:14 <conal> jmcarthur: sort of. or something more dependable and integrated than finalizers.
18:06:15 <jmcarthur> ski: is there a way to keep it persistent?
18:06:18 <ski> conal,jmcarthur : generally, any quotient type -- you can change representation within the equivalence class
18:06:31 <fruight> johnnowak: thanks, i'll read up on that... i dont really grasp it on first glimpse :P
18:06:43 <dobblego> @type \x -> maybe x . const -- in the stdlib?
18:06:44 <lambdabot> forall b a. b -> b -> Maybe a -> b
18:06:46 <Cale> ddarius: Yeah, exactly. Once all the observers we care about are safely entangled with the system being studied, we can treat the wave function as having collapsed.
18:06:51 <conal> ski: yeah. that's what i mean by "semantically benign" or "semantically inert".
18:06:54 <jmcarthur> conal: i hate to admit i experimented with monadic regions for gpu resources once. very reliable, but not the kind of code i wanted to continue writing
18:06:59 <dobblego> @hoogle b -> b -> Maybe a -> b
18:07:00 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
18:07:00 <lambdabot> Language.Haskell.TH InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
18:07:00 <lambdabot> Language.Haskell.TH.Syntax InfixE :: Maybe Exp -> Exp -> Maybe Exp -> Exp
18:07:28 <ski> conal,jmcarthur : one could view lazy thunks as an instance of this .. either `Thunk :: (() -> a) -> Lazy a' or `Value :: a -> Lazy a' .. iirc, the Mercury implementation of `lazy' used a quotient type, with mutation
18:07:42 <ski> jmcarthur : keep what persistent ?
18:08:00 <jmcarthur> ski: if you update a splay tree how easy is it to keep the old version?
18:08:08 <conal> persistence is my concern about splay trees also
18:08:22 <jmcarthur> ski: i suppose you could go the DiffArray route
18:08:35 <jmcarthur> store instructions to recreate the old version
18:08:35 <ski> (Cale : how much entangled do they have to be .. or is there no degrees here ?)
18:08:55 <aavogt> @type \x -> fromMaybe x . ($>)
18:08:56 <lambdabot> Not in scope: `$>'
18:09:02 <aavogt> @type \x -> fromMaybe x . (<$)
18:09:03 <lambdabot>     Couldn't match expected type `Maybe a'
18:09:03 <lambdabot>            against inferred type `f b -> f a1'
18:09:03 <lambdabot>     Probable cause: `<$' is applied to too few arguments
18:09:37 <aavogt> @type \x y m -> fromMaybe x (y <$ m)
18:09:38 <lambdabot> forall a b. a -> a -> Maybe b -> a
18:09:49 <jmcarthur> conal: okay i can't convince myself to generalize it to unobservable side effects, so i'll just with unobservable mutation for now
18:09:54 <ski> jmcarthur : do you mean a semantic update, or just an implementation-update done by an access ?
18:09:57 <jmcarthur> *i'll just stick with
18:10:17 <conal> jmcarthur: and we'll see how the idea evolves.
18:10:27 <ski> jmcarthur : unobservable indeterminacy ?
18:11:13 <aavogt> hey dobblego, do you recall the difference between  f x = e    and  f = \x -> e?
18:11:17 <ski> jmcarthur : some subsystem might be indeterminate, because of concurrency e.g., but a larger system is not, because the result at that level turns out the same anyway
18:11:23 <Cale> ski: Er, I'd have to think carefully about how to formalise it, but enough that all the observables we care about are entangled with the states of the observers.
18:11:25 <jmcarthur> ski: was your suggestion for splay trees specifically about splay trees that you can't modify?
18:11:34 <jmcarthur> ski: as in, only query?
18:11:42 <jmcarthur> ski: if that's the case then i'm with you on splay trees
18:12:12 <ski> aavogt : what about it ?
18:12:13 * ddarius was not anthropomorphizing when he used the word "mind."
18:12:14 <conal> jmcarthur: so, pure functional programming is not programming without mutation; it's programming without observable mutation.
18:12:31 <ski> Cale : is "are entangled with" a boolean property ?
18:12:48 <conal> or rather *lazy* functional programming
18:12:56 <dobblego> aavogt, hmm, I thought there was a way with bottom values, but I am unable to reproduce it atm
18:12:58 <aavogt> ski: they are supposed to be distinguishable in strictness
18:13:13 <ski> jmcarthur : i'm talking about normal splay trees what you could have in Haskell, but where query/access can change the representation, under the covers
18:13:26 <ski> jmcarthur : not anything in `IO' or `ST s' or `STM', i.e.
18:13:33 <jmcarthur> ski: how would deletion work?
18:13:39 <ski> return a new tree ?
18:13:40 <Cale> ski: In a basic sense, yeah, but there are different subsystems of any given quantum system that we can talk about.
18:13:59 <jmcarthur> ski: so create an entirely new tree?
18:14:08 <jmcarthur> ski: because if you are modifying the original then you can't share it
18:14:09 <aavogt> @type (|||)
18:14:10 <ski> aavogt : if you only have that equation for `f', then i don't know about that
18:14:10 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
18:14:24 <jmcarthur> operationally
18:14:39 <jmcarthur> let me try that again
18:14:41 <Cale> ski: Basically, "entangled" means that it's not possible to factor the state of a tensor product of quantum systems into a product of pure states on each system separately.
18:14:42 <dobblego> aavogt, I might have to take that back until I figure it out better
18:14:46 <ski> conal : i'm not seeing how "lazy" is essential for that ..
18:15:00 <jmcarthur> if you are *mutating* the original then you can't really share parts of it with semantically updated versions
18:15:36 <conal> ski: i mean that in strict pure functional programming, we don't even have unobservable mutation.
18:15:45 <ski> jmcarthur : yeah, i see that could be a problem
18:15:59 <jmcarthur> ski: but a read-only splay tree would still be a good example
18:16:09 <Cale> ski: But even when that's impossible, maybe it's still possible when restricting to certain subspaces, so it's hard to measure.
18:16:30 <conal> ski: ditto for call-by name
18:16:44 <jmcarthur> ski: that is, when the API either doesn't expose ways to insert/delete elements, or when the API's insertion and deletion functions do deep copies of the tree
18:16:50 <conal> while for lazy, we add mutation, but only unobservable mutation
18:17:01 * ddarius guesses a read-only splay tree isn't -completely- pointless.
18:17:31 <ski> Cale : that sounds like a similar problem as whether two variables are independent, or a real number is zero .. i.e. problems where you can be closer or further from the "goal", not just "yes"/"no"
18:17:45 <jmcarthur> Reader (Splay r)
18:18:01 <conal> and maybe "unobservable" is just a way of saying "operational, not denotational"
18:18:33 <Cale> ski: If you have two quantum systems A and B, whose state spaces are H_A and H_B respectively, then the state space of the composite system is the tensor product of H_A with H_B, and if they're not entangled, then the state of the composite system can be written as a pure tensor |phi>_A \otimes |psi>_B
18:18:47 <ski> conal : well, i can imagine splay-things in strict pure functional programming (and i wouldn't be that surprised if there's something splay- or diff-array -like in Mercury)
18:19:37 <conal> ski: i think there's a communication glitch somewhere.
18:20:07 <Cale> But in general, the states of that system are sums of the form  sum over i,j of c_ij |i>_A \otimes |j>_B (where i,j range over an index set for the bases of each)
18:20:10 <jmcarthur> conal: i think ski's suggestion is that you can still hide otherwise observable mutation behind an opaque type in a strict language
18:20:31 <jmcarthur> conal: so if you had an opaque, read-only splay tree...
18:21:06 <Cale> and it's possible that such a sum can't be written as the tensor product of two individual vectors
18:21:19 <conal> jmcarthur: i guess my dissonance comes from looking at these mutations as shifts into laziness.
18:21:45 <Cale> (In finite dimensions, this is because the tensor product has dimension equal to the product of the dimensions of the spaces, rather than the sum)
18:21:46 <ski> Cale : ok
18:22:23 <ski> jmcarthur : or a diff-array
18:23:43 <jmcarthur> conal: i don't believe that unobservable mutation is a *sufficient* condition for laziness. therefore it is a generalization
18:24:39 <Cale> So that's what it really means to be entangled, but to really formalise when it's okay to consider the state to have collapsed, I think you'd need some specification of the observables which are really under consideration. (Observables are linear transformations on the state space, and may only depend on the orthogonal projection onto certain subspaces.)
18:25:51 <ddarius> The blueness of my laptop screen leads to me having a yellow shadow.
18:25:58 <jmcarthur> i could have been more precise: unobservable mutation is necessary but insufficient for lazy evaluation
18:26:20 <ski> "A new algebraic type in Miranda can be is introduced by using the symbol `::='. For instance, the type `tree' can be introduced as follows: `tree ::= Leaf num | Node num tree tree'  The tree-constructor `Leaf' has a type `num -> tree', and `Node' has a type `((num -> tree) -> tree) -> tree' (the `->' operator denotes currification and is left-associative)."
18:26:25 <ski> wtf !?
18:26:37 <jmcarthur> currification!
18:26:45 <ski> look at the type !
18:26:56 <mauke> I can be is introduced?
18:26:57 <ddarius> ski: You don't like infinitely wide trees?
18:27:43 <ski> ddarius : i hardly think that is what the authors of this paper intended
18:27:51 <ski> mauke : sic !
18:27:59 <mauke> sik
18:28:04 <ddarius> ski: Yeah and it wasn't quite what I thought anyway.
18:28:13 <ddarius> The author is simply insane.
18:28:57 <ddarius> ski: Is this actually a (published) paper, or just some article or the internets?
18:29:05 <penelope> help? I want to recast this: http://hpaste.org/41549/uardigits in terms of this: http://hpaste.org/41522/unfoldm but I'm not so good with monads...
18:29:11 <alex404_> If I've got a list zipper (xs, ys), how does ghc maintain the zipper in roughly the same time and space as (xs ++ ys), assuming it does?
18:29:23 <ski> "Functional Programming and Interval Arithmetic" by R. D. Lins,M. A. Campos,M. de B. Correia at <http://www.cs.utep.edu/interval-comp/apic.95/lins.ps>
18:30:11 <mauke> alex404_: uh, it stores a pair of lists
18:30:19 <ski> "APIC'95, El Paso, Extended Abstracts, A Supplement to the international journal of Reliable Computing", it says
18:30:28 <ski> i'm not sure if this is from a pre-print or not
18:30:33 <ivanm> preflex: sw17ch
18:30:39 <ivanm> preflex: seen sw17ch
18:30:39 <preflex>  sw17ch was last seen on #haskell 46 days, 19 hours, 17 minutes and 8 seconds ago, saying: lol
18:31:55 <aavogt> penelope: you've considered that you need to use State?
18:31:58 <LegendaryPenguin> what does the function ($[]) do
18:32:17 <wlangstroth> you guys know where I could find a good guide to profiling?
18:32:20 <ddarius> LegendaryPenguin: How do you read that?  I.e. what would you say to someone on the phone?
18:32:25 <aavogt> > ($[]) (\x -> 1:2:x)
18:32:26 <lambdabot>   [1,2]
18:32:30 <penelope> aavogt: I don't need to use it, but I'd like to get more practice with monads...
18:32:40 <ski> LegendaryPenguin : it is the same as `\f -> f []', i.e. the function that, given any function `f', applies it to the empty list (and returns the result of that)
18:32:42 <LegendaryPenguin> dollar braces
18:32:44 <alex404_> mauke: Well, yes. But when you move left or right through the zipper, does ghc just shift pointers around so as to not have to copy anything?
18:32:47 <LegendaryPenguin> lol
18:33:03 <aavogt> @src State
18:33:03 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:33:12 <aavogt> @unmtl State s a
18:33:12 <lambdabot> s -> (a, s)
18:33:13 <ddarius> alex404_: GHC does what you tell it to do.
18:33:14 <ski> LegendaryPenguin : "application on the empty list", e.g.
18:33:43 <ski> alex404_ : probably a new cons cell is made each time you move around
18:33:52 <aavogt> penelope: the unfoldM can make the explicit passing of the  acc  implicit
18:34:07 <LegendaryPenguin> so does $ lower the precedene of []?
18:34:11 <LegendaryPenguin> er, of the function
18:34:19 <alex404_> ski: Cool, that's what I was trying to understand.
18:34:36 <ski> (alex404_ : unless it is smart enough to see that the lists have only one reference to them (if that's the case), so that it might reuse the existing cell, mutating it)
18:35:33 <ddarius> Maybe people will understand why I just say ($) is the identity function and leave it at that.
18:35:39 <ddarius> +begin to
18:35:57 <ski> LegendaryPenguin : `($ [])' is just a shorter way to say `\f -> f []' .. the function application "operator" (juxtaposition) can't really be used in a section
18:35:59 <pelotom> LegendaryPenguin: in that case it has nothing to do with precedence, since it's surrounded in parens
18:36:12 <penelope> aavogt: yes, that's the motivation. But it's difficult the first time around...
18:36:26 <LegendaryPenguin> @src ($[])
18:36:26 <lambdabot> Source not found. You type like i drive.
18:36:34 <pelotom> @src ($)
18:36:34 <lambdabot> f $ x = f x
18:36:37 <alex404_> ski: Right. Does ghc ever do that?
18:36:42 <ddarius> The source of ($[]) is ($[])
18:36:46 <LegendaryPenguin> really?
18:36:54 <LegendaryPenguin> hmm
18:37:23 <aavogt> @hoogle unfoldAccumR
18:37:23 <lambdabot> No results found
18:37:50 <LegendaryPenguin> how would i google ($[])
18:38:04 <LegendaryPenguin> or find it in the haskell docs
18:38:19 <ski> conal : anyway, re exact real arithmetic, i remember seeing a paper (really hand-written notes, iirc) about using intervals with rational ends for this, where the appoximations could be improved, so that they could code interval-halving algorithms, using `min' and `max' to give intermediate approximate bounds, but still recur on
18:38:39 <jmcarthur> searching for "unobservable mutation" on google gives me a paper about the meaning of immutability in java and two links with the same text: "Being gay is an unobservable mutation, with out knowledge that it is so." ...
18:38:50 <lars9> Arrow is a lot of fun
18:38:53 <pelotom> @let dollar = (id :: (a->b)->a->b)
18:38:55 <lambdabot>  Defined.
18:39:01 <ski> conal : i wonder if that could be implemented in Haskell
18:39:15 <lars9> makes programming like drawing diagrams
18:39:28 <pelotom> > length `dollar` [1,2,3]
18:39:28 <lambdabot>   3
18:39:30 <ski> conal : unfortunately, i can't seem to find that paper/notes .. (that's how i found the above type gibberish in Miranda)
18:39:59 <ski> alex404_ : i don't know .. i know Clean and Mercury can do that sort of thing, though
18:40:16 <alex404_> ski: Cool. Thanks.
18:40:35 <conal> ski: sounds vaguely familiar to me also. and fits nicely with one of the applications of "generalized lazy evaluation"/"unobservable mutation" i have in mind, namely warren burton's "improving values".
18:40:43 <pelotom> ddarius: it's the identity function with a more restricted domain
18:40:48 <ski> alex404_ : in Clean, uniqueness of references are expressed in the type system. in Mercury, it's expressed in the mode system
18:40:56 <conal> ski: which was my original motivation for this line of thought.
18:41:40 <Yamagushi> http://www.youtube.com/watch?v=zAhJTxC1C8w
18:41:40 <conal> ski: and i'm making notes right now on interval analysis. on fixing the huge abstraction leak and improving performance.
18:41:44 <ski> alex404_ : so, they have an "overloaded" variant of `(++) :: [a] -> [a] -> [a]' which will mutate the first list, if the function gets the only reference to it
18:42:03 <alex404_> ski: Trippy.
18:42:28 <ski> alex404_ : i.e. overloaded in the sense that there's probably difference code for the mutation-variant than for the normal one .. but the source code is the same, and is only written once
18:42:34 <ski> alex404_ : why trippy ?
18:43:13 <ski> conal : yeah .. i'd like to read those Burton papers
18:43:52 <conal> ski: he was after exploiting parallelism w/o compromising/complicating semantics. very timely!
18:44:34 <conal> now that we have cheap, massively parallel computers, i'd like to see a revival of warren burton's ideas.
18:45:01 <jmcarthur> conal: in what paper is improving values given a good treatment?
18:45:12 <alex404_> ski: Well, I guess I only just came up on the problem with thinking about zippers... that is how to maintain the references with immutable state. So the 'overloaded' solution is something entirely dependable, but still not immutable really. I don't know anything about the languages you mentioned so I don't know what they're philosophy is to make those kinds of decisions.
18:45:41 <conal> jmcarthur: looking ...
18:46:19 <jmcarthur> i know you have mentioned it a lot in your blog and papers. i could just see if you cited it anywhere
18:46:41 <ski> alex404_ : why "not immutable really" ? .. lazy thunks use mutation underneath, as well !
18:47:38 <conal> jmcarthur: i had to ask warren himself for copies of his papers.  see http://conal.net/papers/warren-burton/
18:47:46 <jmcarthur> conal: thanks!
18:47:53 <conal> jmcarthur: :) 
18:48:07 <jmcarthur> ooh these look like nice titles
18:48:14 <jmcarthur> i had seen some on google scholar, but no downloads
18:48:26 <ski> alex404_ : both Clean and Mercury remove the "side" from "side-effects", like Haskell does .. both in Clean and in Mercury, you pass the world state (or smaller fragments thereof) around, returning new variants of it (which are operationally the same, just mutated)
18:48:33 <conal> jmcarthur: especially "Encapsulating nondeterminacy in an abstract data type with deterministic semantics" or "Indeterminate behavior with determinate semantics in parallel programs".
18:48:34 <ski> alex404_ : similarly with arrays
18:48:56 <jmcarthur> conal: those sound quite promising. thanks again
18:49:06 <conal> jmcarthur: you bet.  it's all great stuff.
18:50:10 <alex404_> ski: Yah, I was just looking into them. The rabbit hole goes so deep with programming languages as a field. I think I'll just stick with Haskell ;) Though mercury seems neat. I miss that zen feeling of coding prolog. Anyway, I still have no bird's eye view of the implementational details of haskell, so I get caught up with simple questions.
18:51:15 <pelotom> I hope the rabbit hole never ends! (I don't think it does)
18:52:42 * ski snarfs Burton papers
18:52:55 <alex404_> Some of us have real work to do ;) Not everyone can spend their lives generating tools for generating tools
18:53:39 <penelope> I thought that was the job of the fraternities?
18:54:22 <ski> alex404_ : ok. Mercury is basically a statically typed and moded, pure declarative Prolog, with functions and type classes added as a bonus
18:54:32 <winxordie> wow O.O
18:54:49 <ski> alex404_ : no cut, no (is)/2 for arithmetic, no assert[az]/1,retract/1, no side-effecting I/O (only declarative, by passing `io'-states around)
18:54:52 <winxordie> that's pretty harsh penelope
18:55:04 <penelope> Wink?
18:55:22 <alex404_> Oh I get it!
18:55:23 <ski> alex404_ : and you get automatic reordering of calls in rule bodies to fit the mode you call the predicate in :)
18:55:34 <alex404_> penelope: Twasn't kind!
18:56:09 <penelope> alax404: That was my foot talking out of my mouth.
18:57:11 <alex404_> ski: Man, I've never even heard of modes before. Even wikipedia hasn't! Scares me.
18:57:20 <jmcarthur> i like how burton mentioned machines with an infinite number of processors and notes that we don't have machines like that *yet*
18:58:02 <kmc> do Mercury's modes mean anything like the modes of modal logic?
18:58:15 <ski> alex404_ : remember how you can call `append([0,1],[2,3],List)' as well as `append([0,1],Suffix,[0,1,2,3])',`append([0,42],Suffix,[0,1,2,3])' and even `append(Prefix,Suffix,[0,1,2,3])' sensible
18:58:17 <ski> ?
18:58:23 <alex404_> yah
18:58:30 * ddarius works on compiler generator generators so he can generate tools to generate tools to generate tools to generate tools.
18:58:51 <kmc> i herd you like compilers
18:58:55 <ski> alex404_ : that first call is a call to append/3 in the mode (+,+,-), the next two are in the mode (+,-,+), and the last is in the mode (-,-,+)
18:58:57 * kmc very sorry
18:59:21 <alex404_> ski: Ahh. So it's just logic programming terminology?
18:59:22 <jmcarthur> ddarius: what futamura projection is *that*?
18:59:29 <ddarius> The third.
18:59:30 <kmc> prolog's case convention for variables vs. constants is opposite Haskell's, right?
18:59:38 <ski> alex404_ : Mercury compiles each mode of a predicate separatedly (but there's only one piece of source code for all the modes (unless you specifically ask to do a different algorithm in one mode))
18:59:47 <Mathnerd314> jmcarthur: Burton just says "they're not for sale". so the NSA might have them :-)
18:59:50 <jmcarthur> ddarius: i thought that was just compiler generators
19:00:08 <alex404_> ski: And why does it need to do that?
19:00:33 <ski> alex404_ : well, it does it for efficiency
19:00:52 <alex404_> ski: Okay, it's not something to do with purity which I can't wrap my head around.
19:01:03 <ski> alex404_ : .. and for call reordering, which gives more flexibility (which you're bound to discover the hard way, if you code enough Prolog)
19:01:23 <ddarius> Mathnerd314: How do you think the NSA reads encrypted communications?
19:01:54 <ski> alex404_ : also, Mercury statically associates each mode of a predicate with "determinisms" : `det' means that mode will have exactly one solution, `semidet' means it will have at most one solution, `multi' means it will have at least one solution, and `nondet' means it can have any number of solutions
19:02:22 <ski> alex404_ : the (+,+,-) mode of append/3 is det, (+,+,+) and (+,-,+) are both semidet, and (-,-,+) is multi
19:02:32 <ski> alex404_ : and the (-,+) mode of member/2 is nondet
19:03:11 <alex404_> ski: Interesting...
19:03:24 <ski> alex404_ : the determinisms also help with efficiency (and is also a statically checked piece of documentation about the semantic properties of the predicate .. whether some arguments functionall determine others, &c.)
19:04:00 <ski> alex404_ : yeah, it's cool :)
19:04:02 <ski> anyway
19:04:08 * ski -> _|_
19:04:17 <alex404_> Sounds like you like this language ;)
19:04:46 <alex404_> Is it targeted at different problems than prolog or it's just a pure prolog?
19:06:35 <ski> (kmc : more or less, yes. (known) predicates and functors (~= "data constructors") begins with lower case. variables (including arguments being predicates or goals) begins with upper case (or `_')))
19:07:19 <ski> alex404_ : it is meant to be useful for larger systems (so efficiency and static checking), also having a proper module system
19:07:31 <ski> (anyway, i need to leave now ..)
19:07:43 <alex404_> ski: Cheers
19:14:12 <lars9> @index char
19:14:12 <lambdabot> Graphics.HGL.Window, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE, Language.Haskell.TH.PprLib, Text.ParserCombinators.Parsec.Char, Text.ParserCombinators.Parsec, Text.ParserCombinators.ReadP,
19:14:12 <lambdabot> Distribution.Compat.ReadP, Text.PrettyPrint.HughesPJ, Text.PrettyPrint
19:19:18 <lars9> @where PArrows
19:19:18 <lambdabot> I know nothing about parrows.
19:19:27 <lars9> @hoogle PArrows
19:19:27 <lambdabot> No results found
19:20:10 <turiya> hi
19:20:39 <lars9> does PArrows really work better than Parsec? (i just read wikibooks' Arrow chapter)
19:21:25 <turiya> i have some haskell code which can display many ppm images simultaneously in X11.. is it useful to any?
19:21:50 <kmc> turiya, definitely, you should put it on Hackage
19:22:43 <turiya> kmc, i am not sure about how to do this
19:23:26 <penelope> turya: cabal
19:24:02 <turiya> penelope: yeah, thought of that.. will check how it is packaged..
19:26:38 <kmc> turiya, http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
19:28:04 <turiya> kmc, thanks, will look it up..
19:54:41 <dobblego> @type [minBound ..]
19:54:42 <lambdabot> forall a. (Bounded a, Enum a) => [a]
19:54:55 <shepheb> so torn... writing Blackberry Java is painful, but getting paid well for it is sweet. /me pours a bourbon and reads Basic Category Theory for Computer Scientists, and tries to forget.
19:55:36 <dankna> let me put it this way
19:55:40 <kmc> shepheb, how many hours per week do they make you work?
19:55:40 <dankna> at least you have a job :)
19:56:06 <dobblego> is enumFrom minBound around somewhere?
19:56:26 <kmc> not afaik
19:56:31 <shepheb> contract job, so it varies from "OMG as much as you can give us" to "eh, whenever". also they're running out of money so they're being conservative and trying to get version 1.0 out to paying customers.
19:57:01 <djahandarie> Some people can relate to that ;)
19:57:03 <dobblego> shepheb, do what I do, write haskell while all the other guys write java
19:57:04 <LegendaryPenguin> are jobs hard to find now?
19:57:26 <djahandarie> At the career fair at my university, there were as many CS companies as there were graduating CS students
19:57:41 <kmc> yeah, every career fair i've been to has been 80%+ CS
19:57:52 <kmc> and by CS i mean programming
19:57:55 <dankna> oh to have a degree ><
19:58:07 <djahandarie> 15 companies and 15 graduates
19:58:11 <djahandarie> Good odds
19:58:14 <kmc> haha
19:58:35 <danharaj> Hey, let's say I want to define a type class for implementation details, and I want my users to use that type class to make their own objects, but I don't want the type class interface to leak out. How do I do?
19:58:42 <djahandarie> Real question is why there were only 15 gradutes
19:59:00 <kmc> djahandarie, can you be more specific?
19:59:18 <monochrom> > "djahandarie
19:59:19 <lambdabot>   <no location info>:
19:59:19 <lambdabot>      lexical error in string/character literal at end o...
19:59:20 <shepheb> how big was the graduating class?
19:59:27 <djahandarie> Not sure
19:59:28 <monochrom> > "djahandarie" == "danharaj"
19:59:29 <lambdabot>   False
19:59:31 <djahandarie> This is what my teacher told me
19:59:36 <kmc> err yes
19:59:40 <kmc> danharaj, can you be more specifci?
19:59:55 * monochrom still doesn't understand why he is psychic.
20:00:00 * kmc facepalm
20:00:01 <Cale> danharaj: Export the class, but don't export its methods?
20:00:28 <kmc> the question is how is the user making their "own object" if they can't see the methods
20:00:30 <danharaj> Yeah. Working on a FRP idea. I want a signal type class, which should only have an "observe" method visible in code, but it should also have internal methods that are used by my framework to actually run the signal code.
20:00:36 <monochrom> Data.Array is probably full of examples of that if I understand correctly
20:01:06 <danharaj> The reason I want to do this is because different sorts of signals (time varying behaviors, whatever) have different sorts of efficient representations.
20:01:28 <kmc> ok, but when the user declares a new type of signal, they should not get the benefit of different sorts of efficient representations?
20:01:30 <Cale> danharaj: If you just put the class name in the export list for the module, the class will be exported, but none of its methods will be, (and nobody will be able to write any instances outside the module)
20:02:03 <cncl> oh wow i tabbed to IRC to ask a question about FRP, and people are talking about FRP
20:02:09 <kmc> danharaj, you want to force the user to accept the class's default implementation of these internal methods?
20:02:19 <kmc> basically i don't understand why they're in the class at all
20:02:19 <danharaj> kmc: they should be able to define their own representations, and hence need to define the 'internal' methods. But if I let them see the internal methods of the type class, they can use them on my types, which would have opaque representations (or ought to be)
20:02:30 <monochrom> there are probably 12 "default" implementations to choose from
20:02:43 <kmc> danharaj, ah, that's a tricky one
20:02:52 <dankna> danharaj: hmm
20:03:04 <danharaj> Now, I need this because I will be writing signals that do tricky IO stuff
20:03:07 <dankna> danharaj: I think you need two separate type-classes
20:03:12 <danharaj> dankna: that is a good idea.
20:03:32 <kmc> danharaj, a simple design that comes to mind is to have Foo and Foo.Internals
20:03:36 <dankna> BuiltinSignal, UserSignal
20:03:46 <kmc> the latter exports the whole class, the former omits the methods
20:04:01 <dankna> and then perhaps both of them have library-provided implementations for Signal
20:04:03 <danharaj> kmc: I hate trusting the user not to do silly things :[
20:04:03 <kmc> and users are made aware that if they import Internals, they have to be careful w.r.t. your stuff
20:04:14 <dankna> kmc's suggestion doesn't seem bad to me either
20:04:27 <kmc> i agree danharaj but at the same time this is the solution taken by a lot of respected Platform libs
20:04:33 <danharaj> oh, is it?
20:04:33 <kmc> which need encapsulation yet extensibility in weird ways
20:04:46 <kmc> yeah, like bytestring
20:04:53 <monochrom> I use use SML-like parameterized modules.
20:05:02 <danharaj> I can just do it that way. I was wondering if there was a Better Way (TM) though.
20:05:03 <cncl> i'm playing around elerea (FRP) right now, it's cool and works, but i wonder what happens when i need good performance out of it
20:05:04 <danharaj> monochrom: that would be awesome
20:05:15 <cncl> i'm assuming most people who do working FRP projects are using yampa right now?
20:05:17 <kmc> danharaj, there may be a better way, i just suggest to consider this solution among the others
20:05:18 <djahandarie> cncl, you jump ship
20:05:30 <monochrom> parameterized modules will appear in Haskel 2100
20:05:32 <kmc> once you import Data.ByteString.Internal you can get the direct ForeignPtr to the bs contents and do all kinds of terrible things
20:05:39 <cncl> djahandarie: have you tried it yourself?
20:05:51 <djahandarie> No. And what I said applies to all FRP
20:06:08 <danharaj> I think FRP is still trying to find the One True Way
20:06:10 <djahandarie> One of the local experts would have to elaborate
20:06:44 <cncl> it doesn't have to be great or anything, i'm writing a simulation for a project i'm working on and i thought it would be interesting to do it with FRP rather than traditional methods
20:07:06 <danharaj> You can use Reactive.
20:07:12 <danharaj> That is probably the most modern FRP library.
20:07:21 <danharaj> actually I lied
20:07:26 <danharaj> I don't know how Yampa's been doing.
20:07:29 <danharaj> I should not slander them like that :)
20:07:37 <cncl> i saw that someone wrote a 3d game engine that uses yampa and it works
20:07:46 <cncl> so i'm assuming performance cannot be all that bad
20:07:59 <Cale> cncl: We're using a rather heavily modified Yampa at iPwn, which is slowly turning into something entirely different. I personally rather dislike Yampa (and the Arrow interface in general), but it works, which is more than can be said of the FRP libraries that are pretty. ;)
20:08:12 <djahandarie> FRP isn't "bad" in terms of performance.
20:08:18 <jmcarthur> yampa has discrete semantics and an efficient implementation. reactive has continuous semantics, a nicer api, and a reasonably efficient implementation... if you ignore the occasional space leak :\
20:08:24 <djahandarie> But it has fundemental problems that no one has cracked yet
20:08:26 <Cale> The performance is fine.
20:08:31 <Cale> In Yampa.
20:08:42 <cncl> my simulation will use steps, so discrete semantics are preferred
20:08:48 <Cale> But if you want something like Reactive, I don't think anyone's figured that out yet.
20:09:18 <cncl> Cale: that is what i figured from playing with elerea and then looking at yampa
20:09:58 <cncl> being able to use a monad gives you more dynamic power but at the cost of uncertainty (and lost optimizations)
20:10:08 <jmcarthur> "my simulation will use steps" sounds like a self fulfilling prophesy
20:10:16 <cdsmithus> I looked at Yampa and Elerea for a discrete time FRP project... I used Elerea because I understood it!  Yampa may be awesome, but it looked like learning it for a weekend hacking project would have eaten the weekend and left me with no hacking project.
20:10:16 <Cale> Last time I tried it, Reactive was extremely unusable.
20:10:28 <jmcarthur> Cale: unusable? really?
20:10:28 <danharaj> was it?
20:10:33 <Cale> (because of performance -- the interface is lovely)
20:10:45 <cncl> i don't see what's wrong with using ticks in a simulation
20:10:46 <jmcarthur> i haven't found its performance to be that bad
20:10:50 <jmcarthur> again, ignoring those space leaks
20:10:54 <Cale> heh
20:10:55 <danharaj> well it's haskell
20:10:58 <cncl> well, i know things that are wrong with it
20:11:03 <danharaj> not only is it haskell, it's a complicated library on top of haskell
20:11:04 <jon_of_arc> Is there a recommendable library using the Essence of Dataflow Programming comonadic approach to FRP?
20:11:08 <danharaj> reasoning about performance is hard :|
20:11:20 <jmcarthur> cncl: discrete steps are your implementation dirtying up your semantics, IMO
20:11:28 <jon_of_arc> (It wasn't about FRP as such, but I seem to remember it looking applicable)
20:11:34 <cncl> not when the thing i'm simulating uses discrete steps :)
20:11:42 <cdsmithus> cncl: continuous time is in theory nice because it allows you compose things in interesting new ways... but having something that works is nice, too.
20:11:51 <cncl> yeah i know
20:11:58 <Cale> I did a simple example where I integrated the user input a couple times to produce an acceleration for an object, and istr that worked okay. Then I added friction and it didn't work. Conal didn't know why and told me that it was supposed to have worked.
20:12:13 <cncl> i would prefer it if it worked, but i'm not going to write a working continuous time FRP library for my little simulation
20:12:27 <cncl> and i'm simulating something that uses steps itself anyway
20:12:32 <Cale> Where by "didn't work" I mean that it just hung.
20:12:37 <conal> yep. i haven't poked at Reactive for a while.
20:12:56 <cncl> it seems like a hard problem
20:14:08 <cncl> have you ever used the software Reaktor?
20:14:23 <cncl> it has both continuous and discrete time, and is a dataflow programming language
20:15:09 <cncl> it has a static compiler for the parts that need to run efficiently
20:19:47 <dankna> hmmmm....  so I'm writing a parser generator (I'm not satisfied with Happy)
20:20:07 <dankna> I'm running into a little design problem with the syntax of monadic parse actions
20:20:23 <dankna> non-monadic ones, aka expressions, are not an issue because they only ever need a single line
20:20:24 <cncl> Cale: is your recommendation to use yampa? elerea looks nice but i'm not sure how solid it is without having dug through it
20:20:38 <dankna> with monadic ones I need to effectively have an implicit do-block wrapped inside generated code
20:20:48 <dankna> and figuring out the smart way to indent it is a bit of a problem
20:21:13 <copumpkin> dankna: parser generator monad? :o
20:21:16 <dankna> for example, should I attempt to strip indentation that's already present?  but what about the first line, which "starts" further to the right
20:21:27 <dankna> copumpkin:  pardon?  not sure what you're asking
20:21:45 <copumpkin> it seems difficult to inspect a monadic parser because it uses functions in all the binds
20:21:48 <Cale> cncl: To be honest, I haven't really shopped around for FRP libraries that seriously recently, so it's probably still worth looking around a bit. If you go with Yampa, well, it works okay. I'm not really very happy with it as an abstraction.
20:21:53 <copumpkin> inspect to generate a static parser
20:22:02 <dankna> oh, it runs as a preprocessor
20:22:03 <cncl> Cale: i see
20:22:04 <dankna> it has its own syntax
20:22:17 <dankna> Haskell code inside the BNF-like file format is delimited by { ... }
20:22:22 <copumpkin> ah
20:22:33 <copumpkin> but it seems like BNF is more closely modeled by applicative than monad, still
20:22:46 <copumpkin> since monads give you more than context freeness
20:22:51 <copumpkin> freedom? :P
20:22:53 <dankna> well, I'm not that familiar with applicative actually, but,
20:23:10 <dankna> the purpose of allowing monadic actions is to allow the user to break the context-free abstraction in certain ways
20:23:15 <dankna> for example to implement parser-lexer interactions
20:23:21 <dankna> actually that may be the only example
20:23:31 <conal> does anyone happen to remember the CSS property that is the text to be inserted at the start of a div (or whatever)?
20:23:35 <copumpkin> ah
20:23:47 <dankna> conal: div:before { content: "foo"; } I think
20:24:02 <dankna> it's a virtual element, not a property exactly
20:24:16 <djahandarie> Yeah dankna is correct
20:24:16 <conal> dankna: ah. thanks. there's so much i don't know about css.
20:24:19 <monochrom> you may use :before for many things, not just div
20:24:22 <dankna> conal: np
20:24:32 <danharaj> CSS is a nice language
20:24:36 <danharaj> it is declarative
20:24:38 <dankna> CSS is well-designed, yeah
20:24:51 <copumpkin> well
20:24:54 <dankna> anyway, I'd consider using applicative, but it still wouldn't solve my immediate problem
20:25:08 <dankna> what /is/ applicative exactly?  does do-notation work with it?
20:25:15 <copumpkin> nope
20:25:20 <copumpkin> it's "idioms"
20:25:24 <copumpkin> which also means nothing I guess
20:25:27 <monochrom> it just needs a Hindley-Milner type system, type classes, monads, and kinds.
20:25:34 <copumpkin> but it supports liftAn, basically
20:25:39 <dankna> then the solution to my problem could simply be to disallow multiple-line expressions, which means no indentation necessary, haha
20:25:40 <dankna> hmm
20:25:41 <copumpkin> if you know liftM2
20:25:43 <copumpkin> liftM3
20:25:48 <monochrom> you use fmap and <*> when you use Applicative
20:25:51 <dankna> I vaguely know those
20:25:53 <dankna> I know fmap
20:25:57 <copumpkin> (a -> b -> c) -> (f a -> f b -> fc)
20:26:03 <copumpkin> basically a higher-arity fmap
20:26:08 <dankna> ah!  okay
20:26:09 <monochrom> <*> is like ap.
20:26:24 <copumpkin> turns out a plain ol' functor can't support higher-arity fmap
20:26:35 <copumpkin> but add a couple of properties to it and you can do it at any arity
20:26:46 <mm_freak> CSS as a language is well defined
20:26:50 <djahandarie> copumpkin, did you see rl's blog post?
20:26:53 <copumpkin> as a model it sucks
20:26:54 <djahandarie> It was awhile ago
20:26:59 <copumpkin> djahandarie: the small vector thing?
20:27:02 <dankna> hmm
20:27:02 <djahandarie> Yeah
20:27:06 <copumpkin> yep, it was nice
20:27:07 <mm_freak> yes, and even as a language, it has a lot of disadvantages
20:27:19 <mm_freak> lots and lots of redundancies
20:27:33 <dankna> > liftA2 (+) (4, 5)
20:27:34 <lambdabot>   Overlapping instances for GHC.Show.Show ((t, a) -> (t, a))
20:27:34 <lambdabot>    arising from ...
20:27:42 <mm_freak> it should be more relational, so you don't have to use CPP all the time
20:27:56 <mm_freak> (or whatever preprocessor you use for your CSS)
20:28:27 <dankna> I agree that CSS has some improvements possible - I'd like the ability to declare variables.  but I think the value of CSS is that it's a lingua franca that your CMS can emit.
20:28:38 <dankna> you can internally store your CSS rules in a datababase or whatever.
20:28:49 <mm_freak> you don't even need variablesâ¦  just a relational style
20:28:58 <mm_freak> like a little database
20:29:05 <dankna> yeah, but then you'd have to deal with namespacing
20:29:13 <cncl> Cale: i think i'll give elerea a try, and if performance is an issue, switch to yampa. (i'm doing a game simulation combined with a genetic algorithm, so while it's a simple simulation, it needs to run many many times)
20:29:24 <dankna> the "cascading" property would be compromised
20:29:58 <conal> if I want the CSS :before content to flow with the content that follows (in the same paragraph), rather than vertically separated, is there another property i can set?
20:29:59 <mm_freak> dankna: not really, because each time you add style you have to refer to the element in question, which is a relational operation
20:30:06 <dankna> copumpkin: okay, so I don't totally get why I can't do the liftA2 (+) (4, 5) thing, but let's assume that I spend a couple hours and read some information on how to use it.  how does applicative apply to parsing?
20:30:15 <mm_freak> dankna: the DOM is cascading, but CSS as a language, isn't
20:30:24 <copumpkin> dankna: you can do
20:30:37 <copumpkin> liftA2 (+) (Just 5) (Just 6)
20:30:41 <copumpkin> > liftA2 (+) (Just 5) (Just 6)
20:30:42 <lambdabot>   Just 11
20:30:44 <copumpkin> > liftA2 (+) (Just 5) Nothing
20:30:45 <dankna> mm_freak: yeah, I see that.  well.  I guess what I meant to say was, the features I would want are things like making named sets of selectors and named sets of style rules and applying them to each other.
20:30:45 <lambdabot>   Nothing
20:30:53 <dankna> mm_freak: for which you'd have to have namespacing.
20:31:09 <dankna> copumpkin: ah!  cool
20:31:10 <monochrom> oh! I forgot dependent types. so, CSS is nice, just add dependent types and parameterized first-class modules and kinds and GADTs and it will be perfect. XD
20:31:11 <copumpkin> dankna: with parsers, you use it to express syntax productions
20:31:27 <mm_freak> dankna: i don't know whether that would be a problem
20:31:30 <dankna> but my syntax productions are already expressed in the outer file format :)
20:31:35 <copumpkin> aha :)
20:32:01 <dankna> I have a working implementation of the LALR1 table-generation algorithm at this point, and I'm just working on the output pass
20:32:57 <dankna> yes, I know, it's arguably un-Haskelly, this approach, but I think at least there's an important niche for it
20:33:37 <dankna> (my immediate target is parsing of defined subsets of natural language, which really really can't be done with LL techniques)
20:33:46 <dankna> (it can barely even be done with LR techniques)
20:34:39 <conal> i'm sure curious what a well-designed alternative to CSS might look like -- dropping constraints like compatibility. i mean something with a simple & precise underlying semantic model
20:34:57 <dankna> conal: it would be interesting, that much is clear
20:35:00 <djahandarie> It's too bad XHTML2 got killed
20:35:02 <conal> something really elegant.
20:35:24 <dankna> conal: another issue which one might wish to address is the frequent need to "wrap" things so that you can apply separate style rules to the wrapper
20:35:40 <dankna> this is common if, for example, you want to put a highlight gradient on top of something, or a double border around it
20:35:54 <dankna> there needs to be some way to do arbitrary generated content in css
20:36:12 <dankna> or at least, it's a reasonable thing to put on the table for a next-generation stylesheet language
20:36:12 <conal> dankna: definitely
20:37:02 <dankna> copumpkin: so I think Applicative is not that, er, pardon the pun, applicable to my situation :)
20:37:08 <copumpkin> :P
20:37:10 <dankna> copumpkin: but I thank you for the suggestion
20:37:18 <copumpkin> no problem :)
20:41:58 <dskippy> I am trying to compile a program and I'm getting some messages I don't understand. Like "compilation is not require" and undefined reference stuff. http://hpaste.org/41550/ghc_cluehs_o_clue
20:42:37 <dskippy> Weird that it warn me that compilation is not required. Doesn't that go without saying just a little bit?
20:43:05 <kmc> ghc --make
20:43:28 * hackagebot CHXHtml 0.1.4 - A W3C compliant (X)HTML generating library  http://hackage.haskell.org/package/CHXHtml-0.1.4 (PaulTalaga)
20:44:00 <dobblego> does anyone know of a cabal package that manages to deal with mutually dependent modules?
20:44:28 <jmcarthur> i've use hs-boot files before, but it wasn't worth it
20:44:31 <jmcarthur> *used
20:44:51 <dobblego> do you propose putting it all in one module instead?
20:45:33 <jmcarthur> dobblego: i ended up having hidden internal modules and then rexporting a subset of the functionality from exposed modules
20:45:53 <jmcarthur> instead of doing mutual imports
20:45:58 <dobblego> I have two data types that depend on each other
20:46:12 <jmcarthur> dobblego: i'd put them both in the same file
20:46:19 <dobblego> that's what I currently have
20:46:31 <dobblego> was just wondering if dealing with the split is worth it
20:47:01 <jmcarthur> dobblego: and if you want to separate some things into separate files you could export the implementations of those data types from an internal module and just not expose that module
20:47:27 <jmcarthur> i really hated using hs-boot
20:47:32 <dobblego> furry nuts
20:50:13 <ivanm> I want to make custom Show and Read instances for newtypes around Ints such that: show (Node 1) == "node_1"
20:50:23 <ivanm> what do I need to do with the precedence parameter for showsPrec?
20:51:06 <kmc> dskippy, did that solve your problem?
20:51:39 <dskippy> kmc: Yes, thank you so much. --make was the answer.
20:52:06 <dskippy> kmc: Sorry I didn't write back. Got too excited running my program. It's playing Clue. :)
20:52:51 <ivanm> well, --make is default as of ghc 7.0
20:54:05 <kmc> cool dskippy :)
20:54:12 <kmc> ivanm, thank god for that
20:54:44 <ivanm> kmc: I dunno, I'm kinda in two minds about it
20:54:53 <ivanm> yes, it makes it easier; but does it _need_ to be easier?
20:55:01 <ivanm> isn't --make or something still required for gcc for example?
20:56:04 <dskippy> ivanm: I think easier is usually better. 
20:56:11 <ksf> why aren't there tuple instances for STUArray?
20:56:12 <kmc> gcc has no equivalent flag, and the C language does not provide the necessary information
20:56:25 <kmc> to me it's not about easier vs. harder, it's about the default being what most people want
20:57:27 <monochrom> I believe you may ignore the precedence parameter of showsPrec. It is only useful when your data type is some AST and therefore you want to remind yourself to add parentheses.
20:57:30 <ivanm> I'm just wondering, though: if Cabal becomes smart enough to start doing parallel builds (rather than just ghc --make), will making --make default make it harder to specify the necessary flags for sub-compilations?
20:57:42 <kmc> you can unset --make i think
20:57:43 <ivanm> monochrom: ta; that's what I thought, just wanted to check
20:57:43 <kmc> with -c ?
20:57:48 <guest2425> hello
20:57:49 <ivanm> kmc: yeah, probably
20:57:59 <kmc> i wouldn't support this change if it's more than a UI switch
20:58:01 <ivanm> but dealing with different versions of ghc would be a pain (then again, it already is)
20:58:03 <kmc> cabal can deal with a new UI
20:58:06 <kmc> true
20:58:31 <kmc> i think it's small compared to the number of beginners who show up here with cryptic linker errors, and many more who don't find IRC or the manpage and just give up
21:00:01 <ivanm> kmc: though I'm kinda amazed by how many do; do the tutorials not spell it out clearly enough?
21:00:31 <kmc> there's lots of documents about learning haskell, of varying quality
21:00:40 <kmc> and anyway people don't read thoroughly
21:00:43 <kmc> which yes is a problem
21:00:52 <kmc> but this seems like a clear win for usability
21:01:04 <ivanm> yeah
21:01:11 <shepheb> my old roommate, with whom I've had a long-running debate over the merits of Haskell, just compared it to a drug addiction. "You're showing withdrawal symptoms now that you're writing BB Java. It does make you more productive though, and doesn't destroy your health. even so, not going to find many companies condoning its use. :P"
21:01:13 <kmc> the C compilation model is archaic anyway; it's kind of embarrassing for it to be the default with ghc
21:01:19 <kmc> haha
21:01:40 <ivanm> shepheb: heh
21:01:42 <dobblego> shepheb, ignorance is not bliss
21:01:59 <kmc> i've found that lots of companies find it to be a big plus when an applicant says they know haskell
21:02:06 <kmc> even if they have no intention for you to use haskell there
21:02:28 <monochrom> at least I did my part about --make in http://www.haskell.org/haskellwiki/A_brief_introduction_to_Haskell#Compilation
21:02:35 <shepheb> kmc: I've seen the same. lots of people have an impression of it as a hardcore language to know, which can't hurt.
21:03:00 <kmc> shepheb, there's that aspect.  and there's the fact that knowing an obscure language means you like programming and study it for fun
21:03:07 <ksf> it really wouldn't hurt if uarrays had tuple instances.
21:03:14 <kmc> for which the properties of that language don't matter
21:03:32 <ivanm> hmmm.... when parsing with ReadS, how do I say "read this particular String"? use lex and guard or something?
21:03:58 <shepheb> also true. open source projects listed helps too. pretty clear message that you love programming
21:04:00 <ivanm> ksf: I think I've come across a reason why it wouldn't work
21:04:02 <kmc> *nod*
21:04:18 <ivanm> something about not being able to guarantee the unboxed version of arbitrary types being tupled together or something
21:04:44 <copumpkin> it's combinatorially painful
21:04:48 <copumpkin> you could make instance Moo (Int, Int)
21:04:53 <copumpkin> Moo (Int, Int, Bool)
21:05:05 <copumpkin> you can't do it generally
21:05:16 <ivanm> copumpkin: "Moo"?
21:05:22 <ksf> well yes. I just need a handfull of entries.
21:05:22 <copumpkin> you know, Moo, UArray
21:05:24 <copumpkin> same thing
21:05:28 <monochrom> Meh
21:05:31 <ivanm> copumpkin: oh, right, of course
21:05:37 * ivanm backs away slowly...
21:05:44 <kmc> unboxed arrays of composite data would require data families in the implementation, yes?
21:05:46 <ksf> but going Ptr would be painful, as I intend to lock the buggers.
21:06:01 <kmc> that's how 'vector' manages it
21:06:14 <kmc> ksf, you could just use a pair of arrays
21:06:24 <monochrom> may kill cache locality
21:06:30 <kmc> yeah :/
21:06:31 <ksf> NO I COULDNT
21:06:44 <ksf> if I weren't caring about cache performance I'd use a boxed one.
21:06:52 <kmc> you could use vector
21:07:06 <ksf> neither. I'm targeting the language shootout.
21:07:09 <kmc> :(
21:07:14 <kmc> yay artificial restrictions
21:07:27 <kmc> then you'll have to reproduce some of the cleverness of 'vector' locally, i'm afraid :/
21:07:30 <monochrom> Moo, the language shootout.
21:07:31 <ksf> can't even have proper compare and swap
21:07:44 <ksf> otoh, I could just do the whole thing for singlecore.
21:07:53 <ksf> and let dons worry about the rest.
21:07:55 <ivanm> is it possible to use -ddump-derive in ghci?
21:08:32 <ivanm> doing ":set -ddump-derive" doesn't work :s
21:08:52 <ivanm> gah, because it's -ddump-deriv; no e on the end :s
21:12:15 <ivanm> preflex: seen byorgey 
21:12:15 <preflex>  byorgey was last seen on #haskell 14 hours, 57 minutes and 51 seconds ago, saying: therp: have you read http://cale.yi.org/index.php/How_To_Use_Monad_Transformers ?
21:12:49 <ivanm> @ask byorgey with cabal --init, how come it offers the MIT license as an option but then says it's unknown when trying to generate the LICENSE file?
21:12:50 <lambdabot> Consider it noted.
21:13:04 <monochrom> hehehe
21:13:37 <ksf> ...even vector wouldn't let me put an MVar in there.
21:13:53 <ksf> and as it seems the only type of cas we have is via C
21:14:32 <monochrom> which shootout entry are you aiming? is it saying "the point of this entry is to absolutely benchmark cas and nothing else"?
21:14:53 <ksf> no the benchmark is saying "bleeding provide a decent hashtable implementation"
21:15:14 <djahandarie> Someone see how LLVM does on the shootout programs
21:15:21 <djahandarie> And tell the guy who runs it to add the flag
21:15:28 <ksf> it doesn't do better on nucleotide.
21:15:29 <djahandarie> Shootout is running GHC 7.01 now
21:15:42 <monochrom> I am wondering if you must be literally honest about the "hash" part.
21:15:51 <ksf> there's something wrong with the hand-optimisations in the current code, and Data.Hashtable is even worse.
21:15:57 <ksf> yes.
21:16:03 <kmc> it'd be great to get ghc + llvm added as a second "language"
21:16:06 <kmc> so we can compare
21:16:47 <djahandarie> I'd rather not have bleeding-edge stuff on shootout just for our sake
21:16:54 <djahandarie> Just put it on there if it makes us look good
21:17:08 <djahandarie> Is it possible to run local instances of shootout?
21:17:18 <ksf> sure, just download the whole thing
21:17:44 <monochrom> One thing we should learn from Jon Harrop: post our own comparisons, play with our own rules.
21:19:43 <monochrom> Comparing our Data.Map (or btree, or trie, or judy thingies...) with another languages lookup thingie is meaningful. Being obsessed with the 4 letters H A S H is meaningless.
21:20:23 * ksf is going to be cheap and do a single-core specialised-to-the-problem-at-hand version.
21:21:13 <shepheb> ksf: feel no shame; that's basically what the shootout is all around. a blog post on how the non-hash structures stack up would be valuable though, even if not legal for the shootout.
21:21:37 <lars9> monochrom: what about adding elems into a map one by one? comparing Data.Map with python's dict
21:21:44 <ksf> that is, (Ptr Char8, COfs) as keys (indexing into the strict bytestring that's the input, plain Int32 as value.
21:21:44 <lars9> c's map
21:22:06 <monochrom> yeah, adding elements too.
21:22:20 <lars9> will haskell be a lot slower?
21:22:26 <monochrom> I don't know.
21:22:39 <ksf> monochrom, all bickering aside, hopscotch hashes actually make sense.
21:23:21 <ksf> because they've got excellent bounds, only weak point being rehashing, and they're very, very cache-friendly, a lookup taking usually 2 cache misses.
21:23:24 <shepheb> phew, I got the non-soul-penetrating version of Jimmy Wales when I looked up hopscotch hashing
21:23:29 <ivanm> gah, how do I use read on a particular String? i.e. I want to be able to have the Read instance for "newtype Node = Node Int" to read Strings like "Node_0"
21:24:27 <Zao> ivanm: Make an instance for Read Node?
21:24:29 <ksf> just don't take Data.Hashtable as a comparison. that one is _abysmal_.
21:24:48 <Cale> Hashtables are overrated.
21:24:50 <ivanm> Zao: right, but _how_?
21:24:51 <shepheb> ksf: worth including just to demonstrate why one should never use it
21:24:59 <lars9> i dunno why Hash can be slow, in C we can just scratch up a simple hashtable by an array of linked list with a prime size (1000007)
21:25:08 <ivanm> I can't use lex, because it will take the entire String, not just the "Node" bit
21:26:10 <ksf> linear lookup isn't very good performance-wise.
21:26:29 <ksf> and especially vulnerable to bad hashes/malicious input
21:26:31 <Cale> It's really hard to write a *good* hashtable, but it's much easier to cobble together a mediocre one than it is to implement even a mediocre balanced tree in many imperative languages.
21:26:37 <lars9> ksf: it's O(1) for average case
21:26:50 <ksf> no it isn't.
21:26:56 <ivanm> unless I just stuff it and use ReadP rather than ReadS...
21:26:56 <Cale> lars9: You're forgetting about the time needed to compute the hash.
21:27:08 <Cale> lars9: It's logarithmic in the size of the hashtable.
21:27:13 <Zao> ivanm: Check the prefix in a guard, drop the prefix, then read an int, return the remainder?
21:27:28 <Cale> (Lots of people do that)
21:27:33 <ivanm> Zao: oh, duh, just manipulate the String directly?
21:27:39 <ksf> and you're forgetting about the n/buckets lookup 
21:27:51 <ivanm> I was reading something the other day (but forget to remember where :s) that even array lookups arent' really O(1) but O(log n) for large arrays...
21:28:00 <ksf> hashs being O(1) is just a popular myth.
21:28:20 <copumpkin> let's just say that if hashes are O(1) then so are bit tries
21:28:28 <ksf> nowadays you have to count cache misses for your big-O, anyway.
21:28:34 <lars9> Cale: well, in that sense, array's at() is also logarithmic..
21:28:50 <monochrom> You may refer to me when you want to claim array lookup is Î©(log n).
21:28:53 <ivanm> I keep finding and losing the page about how red-black trees are better than hashtables
21:29:08 <ivanm> monochrom: and for showing off by actually typing big omega? :p
21:30:25 <Zao> Of course, I don't know how Read instances work, as I've never built one :D
21:30:37 <monochrom> I can explain it in one sentence. I know hardware. A memory system of n bytes must be organized into a hierachy of Î©(log n) levels deep. No known way around it.
21:30:54 <lars9> ivanm: at least the hashing is good for resampling keys to change their distribution...
21:31:40 <monochrom> The deep hierachy is actually just for decoding each address to decide where to find the wanted byte.
21:33:12 <Cale> lars9: Yes, we often ignore log costs.
21:33:29 <Cale> lars9: In fact, memory accesses are really worse than logarithmic at the end of the day.
21:33:41 <lars9> monochrom: there is another angle to understand why ppl like hashtable, that's because when using a 64-bit system, you can not reduce the complexity of mem-lookup for an array of size <= 2^64bits.
21:33:53 <Cale> lars9: Because there's no way that you can grow memory without bound while keeping it all the same distance from the machine.
21:34:37 <Cale> (It's more like O(n^(1/2)) or O(n^(1/3))
21:34:46 <Cale> )
21:34:56 <monochrom> I sometimes say everything is O(1). Proof: this universe is finite anyway.
21:35:04 <Cale> heh, yes
21:35:20 <lars9> monochrom: you can prove that?
21:35:24 <Eduard_Munteanu> With a cosmological constant indeed.
21:35:32 <lars9> monochrom: see you on next nobel prize day :D
21:35:38 <guest2425> Cale: I want to do this myself but I am stuck
21:36:19 <Cale> I might be able to help while waiting for compiles, but not if you don't ask me anything ;)
21:36:44 <guest2425> Cale: i have to create this function take 4 (listComprehension (^2) [(>5), odd] [1 .. ])
21:37:02 <guest2425> Cale: this is the type listComprehension :: (a -> b) -> [a -> Bool] -> [a] -> [b]
21:37:13 <monochrom> If you say, array access is O(1) because your memory is only 4GB, I can also say, linked list traversal is O(4GB)=O(1) because my linked list is only 4GB. Do you really want to do that?
21:37:25 <guest2425> Cale: this is what I have listComprehension mapFn filters xs = mapFn 
21:37:39 <guest2425> am I in the correct track
21:37:41 <guest2425> ?
21:38:04 <Cale> Well, your definition has the right number of parameters at least
21:38:19 <guest2425> ok ha ha ha
21:39:07 <guest2425> listComprehension mapFn filters xs = mapFn  i need to add filters im here
21:39:28 <lars9> monochrom: i mean, with an array of size <= 2^64, the lookup time is constant, not related to its actual size. but for linked list, it's linear to its actual size
21:39:35 <monochrom> You have to decide whether you want to assume "my computer is bounded" or "my computer is unbounded in principle", and stick with it.
21:39:39 <Cale> guest2425: Look at the 'all' function.
21:39:42 <Cale> :t all
21:39:43 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
21:39:53 <danharaj> Hey guys, what do you think of FRP where you can't directly observe event streams, only continuous signals?
21:40:04 <monochrom> with a linked list size <= 2^64, the lookup time is constant.
21:40:11 <monochrom> the constant is 2^64.
21:40:31 <lars9> monochrom: lol
21:40:44 <lars9> monochrom: let's use cpu flop as time unit
21:40:53 <geheimdienst> monochrom, how about this linked list: cell 1 points to cell 2 and cell 2 points to cell 1
21:40:54 <monochrom> I'm just borrowing your logic. Is it funny? Is your logic funny?
21:41:04 <Eduard_Munteanu> Considering the size of the known universe, something like 2^100-ish is pretty much intractable.
21:41:44 * geheimdienst got a new laptop which can run an infinite loop in around 20 seconds
21:41:53 <monochrom> You are wise to give up on O() and count cpu flops. This means you should benchmark for real rather than ideologically toss around "tree is slow" myth.
21:41:55 <ivanm> geheimdienst: that's rather slow, isn't it?
21:42:41 <guest2425> Cale: how the all function will help me
21:42:43 <guest2425> ?
21:43:07 <geheimdienst> ivanm, i'm happy with it, i shopped for maximum battery time, the faster cpu is just a gimmick to me
21:43:08 <danharaj> What about the myth where you apply asymptotics to small data sets :|
21:43:18 <Gracenotes> geheimdienst: my infinite loop is more correct than your infinite loop, but it takes a bit longer
21:43:26 <Gracenotes> it's just one of those trade-offs
21:44:15 <monochrom> well haven't I just shot down the myth of applying O() to small data sets? small means 2^64.
21:44:17 <Eduard_Munteanu> monochrom: well if you don't do inserts every nanosecond, but rather build the hashtable and then use it, it's still some very good O(1) on lookups and updates. And you can fallback on a tree-ish O(log n) depending on how you solve collisions.
21:44:35 <lars9> monochrom: lol, im not tossing anything. i just want to say hashing and hashtable is indeed a good thing
21:44:42 <danharaj> monochrom: most programs are not going to deal with data sets larger than 2^16
21:45:19 <Eduard_Munteanu> And you can get that with quite simple ht designs.
21:46:56 <Eduard_Munteanu> You also get cache-friendliness for free.
21:47:01 <lars9> Eduard_Munteanu: or maybe Tree is better at update?
21:47:02 <monochrom> I don't say hash tables must be slow. I say you should give the correct reason.
21:47:24 <conal> how do i ask lambdabot for class instances? for instance the Monad instance for pairs
21:47:26 <conal> ?
21:47:28 <Cale> guest2425: It checks to see if some function gives True for all the elements of a list.
21:47:36 <Cale> > all even [2,4,6,8,10]
21:47:37 <lambdabot>   True
21:47:40 <Cale> > all even [2,4,5,6,8,10]
21:47:41 <lambdabot>   False
21:47:42 <ulfdoz> from my experience, a well implemented tree-based hash table performs considerably better than an array based one for practical sizes, that is around a few 100 elements. Especially in concurrent workloads they easily outperform array based implementation due to better locality of the acquired locks.
21:47:43 <kmc> did anyone talk about hash tries yet?
21:47:46 <Eduard_Munteanu> lars9: I'm talking about updating values already inserted.
21:48:11 <Cale> conal: It's something like...
21:48:14 <kmc> hash tries actually make a decent pure-functional data structure, unlike array-based hash tables
21:48:18 <Cale> @src Monad (,)
21:48:18 <lambdabot> Source not found. You type like i drive.
21:48:22 <Cale> hmm
21:48:30 <Cale> @src Monad (->)
21:48:30 <lambdabot> Source not found. It can only be attributed to human error.
21:48:31 <kmc> @src Maybe (>>=)
21:48:31 <lambdabot> (Just x) >>= k      = k x
21:48:31 <lambdabot> Nothing  >>= _      = Nothing
21:48:33 <Eduard_Munteanu> lars9: consider you have a hashtable of (key, value) entries. You simply do a O(1) lookup by key and modify the value.
21:48:36 <Cale> oh, right
21:48:40 <Cale> split into parts
21:48:50 <Cale> @src (,) (>>=)
21:48:50 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
21:49:00 <conal> okay, thanks. type and method.
21:49:03 <kmc> @src (->) (>>=)
21:49:04 <lambdabot> f >>= k = \ r -> k (f r) r
21:49:08 <lars9> Eduard_Munteanu: it's easy for old/new trees to share most part
21:49:13 <Cale> I guess we don't have writer in there.
21:49:27 <kmc> honestly though @src is full of lies, you can just get the source link off hackage
21:49:53 <kmc> @type (>>=)
21:49:53 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:50:04 <conal> hm. and for pairing?
21:50:10 <Eduard_Munteanu> lars9: yeah, though the average case is pretty much worse, O(log n)
21:50:13 <kmc> @djinn (r -> a) -> (a -> (r -> b)) -> (r -> b)
21:50:14 <lambdabot> f a b c = b (a c) c
21:50:30 <Eduard_Munteanu> Hashtables could have O(n) or O(log n) worst-case.
21:50:33 <xplat> array-based hashtable where you only change the values is fast, but only if you never need an old version of the table
21:50:43 <Eduard_Munteanu> (in fact not depending on n, but on collisions)
21:51:12 <Cale> conal: Well, the instance of Monad for (,) w just has  return x = (mempty, x), and join (w1,(w2,x)) = (w1 `mappend` w2, x)
21:51:18 <lars9> Eduard_Munteanu: yeah, hashtable is practically good, though theorectically not good for purists
21:51:49 <conal> Cale: yeah, thanks. i sometimes forget, and i'd like to know how to ask lambdabot.
21:52:04 <Cale> conal: It doesn't seem to have the definition in its textfile.
21:52:12 <guest2425> Cale: yeah but how the function will work in my function?
21:52:17 <conal> Cale: ah. thx.
21:52:18 <Eduard_Munteanu> lars9: there are ways to imagine a hashtable as a pure data structure. The line is pretty thin.
21:52:27 <Eduard_Munteanu> The underlying machine isn't pure anyway :)
21:52:29 <xplat> the thing is, there are all sorts of workloads for which hashtables of some kind or another are blazing fast, but any kind of hashtable that is really fast at one thing will fall over and die if you give it the wrong kind of job
21:52:39 <monochrom> lots of theorists work on hash tables.
21:52:42 <kmc> yeah
21:52:55 <kmc> in particular the whole "don't need old versions" restriction becomes crippling once you get to concurrency
21:53:04 <kmc> lock the whole table? copy the whole thing?
21:53:15 <xplat> there are fairly simple trees that will be 'pretty fast' no matter what you do to them
21:53:26 <kmc> while pure hash tries support lock-free snapshotting
21:53:33 <Eduard_Munteanu> kmc: that seems to be a problem only on insertions.
21:53:38 <kmc> and update by a single atomic op, in the uncontended case
21:53:48 <kmc> Eduard_Munteanu, how do you mean?
21:54:05 <Jafet> Use a DiffArray
21:54:12 <kmc> doesn't diffarray basically suck?
21:54:16 <guest2425> Cale: Like this  listComprehension mapFn filters xs = mapFn xs . all (filter xs) 
21:54:20 <lars9> kmc: locking a trunck is good enough
21:54:20 <Jafet> Yeah, it does
21:54:21 <Eduard_Munteanu> kmc: you seem to emphasize locking the whole table, that makes sense only when extending it (e.g. due to insertions), which cause it to change its whole layout.
21:54:24 <kmc> i've been recommending people use IntMap over DiffArray for some time now
21:54:31 <monochrom> probably means pre-computed hash table, no subsequent change.
21:54:38 <Jafet> Eduard_Munteanu: there are incremental insertion schemes.
21:54:42 <kmc> lars9, ?
21:54:43 <Eduard_Munteanu> kmc: but for very naive (albeit quite good designs), you don't need that.
21:54:45 <Eduard_Munteanu> Yeah.
21:54:59 <kmc> Eduard_Munteanu, i mean to suppose that a thread needs access to a consistent snapshot of the hash table for a period of time
21:55:04 <Eduard_Munteanu> A favourite of mine is just tacking linked lists into ht cells to solve collisions.
21:55:16 <Eduard_Munteanu> Oh.
21:55:19 <kmc> that thread may not be doing any inserting, but it can't deal with inserts by others
21:55:35 <kmc> if you're just doing single lookups, i assume there's way to make that lock-free
21:56:05 <ulfdoz> if the structure is not mutable, than you do not need locks at all.
21:56:14 <kmc> yeah, which is why i was arguing for pure hash tries before
21:56:15 * Eduard_Munteanu figures RCUs make sense for updates in hts
21:56:19 <kmc> or you can just not lock your hash table and hope for the best
21:56:26 <kmc> and your code works fine for 7 years
21:56:37 <kmc> and then one day it crashes at the money-losingest part of the day
21:56:42 <kmc> whoooops
21:56:52 <Eduard_Munteanu> :)
21:57:06 <kmc> RCU?
21:57:26 <Eduard_Munteanu> kmc: read-copy-update.
21:58:15 <Cale> guest2425: Don't just guess randomly
21:58:16 <kmc> immutable data + atomic-swap cells + STM are a natural fit
21:58:16 <Eduard_Munteanu> kmc: basically you hang newer versions somewhere until a grace period expires. Old readers keep seeing older versions until then.
21:58:20 <Cale> guest2425: That doesn't work :)
21:58:25 <guest2425> yeah
21:58:43 <kmc> Eduard_Munteanu, and what if they take too long and the grace period expires?
21:58:50 <guest2425> Cale: I want to understand not guess
21:59:08 <Jafet> Is it theoretically possible to do better than DiffArray?
21:59:22 <Eduard_Munteanu> kmc: that's enforced.
21:59:29 <xplat> the main problem with the hashtable orthodoxy is not anything like 'you should never use hashtables', it's more 'you should always use hashtables thoughtfully based on exactly what you're doing with your finite map'
21:59:30 <guest2425> Cale: ok for me I have this listComprehension mapFn filters xs = mapFn  ? ?  which is ok correct? I believe this is correct
21:59:37 <Eduard_Munteanu> kmc: http://en.wikipedia.org/wiki/Read-copy-update
21:59:56 <guest2425> Cale: since the mapFunction is going to be applied to the all list
21:59:58 <xplat> which doesn't fit with using hashtables as a default go-to structure for finite maps
22:00:31 <xplat> the default should be treeish
22:00:32 <Cale> guest2425: not quite, since you're going to want to apply mapFn to each element of a list, not to a single value
22:00:43 <Jafet> xplat: unless you're programming C, in which case the default is an assoc list
22:00:45 <Eduard_Munteanu> kmc: interestingly it's been used in imperative programming for some time, e.g. the Linux kernel
22:01:18 <monochrom> I welcome all the locking mutexing CAS RCU things as potentially nice for implementing STM. Then I just use STM and immutable data structures on top of that.
22:01:43 <guest2425> Cale: oh ok then is like this listComprehension mapFn filters xs = mapFn ( ?  ? )
22:02:30 <Eduard_Munteanu> monochrom: CAS?
22:02:44 <shepheb> compare-and-swap
22:02:47 <Eduard_Munteanu> Ah.
22:03:09 <Eduard_Munteanu> cmpxchg
22:03:10 <kmc> there's also a lot of people who learn "hash table" as a synonym for "associative data structure" / "finite map"
22:03:17 <kmc> which confuses the issue tremendously
22:03:23 <Cale> guest2425: that would be the same thing?
22:03:51 <shepheb> anyone got a PDF/DJV of SICP? or an online version for that matter.
22:04:21 <kmc> shepheb, not to be that guy, but google SICP
22:04:31 <Eduard_Munteanu> BTW, is there any type system that can express arrays like we do with trees in Haskell?
22:04:34 <kmc> or "the wizard book"
22:04:44 <guest2425> Cale: this is what I understnad http://pastebin.com/AXybSGuy
22:04:54 <Eduard_Munteanu> Might be a dumb thing to ask :/
22:05:14 <shepheb> kmc: yeah, my bad.
22:05:25 <xplat> Eduard_Munteanu: can't tell what you're asking
22:05:54 <lars9> where is Arrow used in practice?
22:05:54 <Eduard_Munteanu> xplat: rephrasing: is there any language where you could express an array as an ADT?
22:06:27 <guest2425> Cale: this is what I need filter even (map (*2) [1,2,4]) 
22:06:33 <guest2425> :t filter even (map (*2) [1,2,4]) 
22:06:33 <lambdabot> forall a. (Integral a) => [a]
22:06:44 <Eduard_Munteanu> like fill in the blanks in... data Array i e = [...]
22:06:58 <Eduard_Munteanu> where Array indeed behaves like an array, not some (!!) on lists.
22:07:02 <xplat> ah, yeah, that wouldn't work
22:07:22 <Jafet> Eduard: that depends on what you allow to be "ADT"
22:07:41 <lars9> Eduard_Munteanu: matlab?
22:07:42 <Eduard_Munteanu> Dunno, I was also considering dependent types and stuff like that.
22:07:44 <monochrom> I don't know of such type system. Array has always been primitive everywhere.
22:07:55 <xplat> i mean, in a dependent type system you could express them as a dependent tuple, but that's not really 'array' per se, it just might happen to act like one sometimes, if you're lucky
22:08:06 <Eduard_Munteanu> lars9: no, not language features, something that arises from a background, more general theory.
22:08:28 <Cale> guest2425: Sorry, I'm rather busy right now.
22:08:29 <lars9> Eduard_Munteanu: ehh...
22:08:29 <Eduard_Munteanu> xplat: oh, I see.
22:08:46 <monochrom> Oh oops, I know of one, but non-executable. In the theorem prover PVS, "data Array (those integers from m to n) e" = function from (those integers from m to n) to e.
22:09:26 <monochrom> But this begs the question. Can you user-define the function type without function type being primitive? No.
22:09:56 <Jafet> That definition also doesn't extend to updating
22:10:30 <ivanm> Cale: am I missing anything obvious in terms of getting info out of a graph here? http://hpaste.org/41552/current_planar_graph_draft
22:10:38 <ivanm> I haven't done any construction/decomposition yet
22:10:38 <Eduard_Munteanu> I see.
22:11:16 <xplat> yeah, a function that just happens to be defined on a finite range is the closest algebraic thing in most languages to an array.  but if you want polymorphism on size you have to get pretty fancy...
22:11:47 <Eduard_Munteanu> xplat: not really, I'd settle with naturals.
22:12:02 <Eduard_Munteanu> From that you could extend to 2D, 3D etc. reasonably.
22:12:25 <monochrom> And PVS has dependent type. You can absolutely say: define a record type, first field "n" is natural number, second field is function [1..n] -> e
22:12:50 <xplat> it really depends a lot what you mean by 'array'.  you do seem to care about constant-time indexing, and a function type can't guarantee that.
22:13:01 <Eduard_Munteanu> Yeah.
22:13:02 <Jafet> The usual computational model for functional languages (for which I don't know the name) cannot express random-access mutable arrays
22:13:08 <guest2425> I need help please http://pastebin.com/33PQDcMc
22:13:16 <Jafet> That is, pure functional languages
22:13:33 <guest2425> Please guys check my function http://pastebin.com/33PQDcMc
22:13:39 <Eduard_Munteanu> Jafet: well mutability could be achieved via strictness analysis.
22:13:46 <Zao> guest2425: We saw you the first time.
22:13:48 <Eduard_Munteanu> Jafet: I only care about the memory layout
22:13:52 <Jafet> So, it depends on how ugly you are willing to make your formalism to get to use arrays.
22:13:56 <Zao> guest2425: Well, what is the function supposed to do?
22:13:56 <xplat> jafet the computational model might be term rewriting, graph rewriting, or pointer machine, depending which functional language and which implementation and how pure
22:14:03 <Zao> Has line 8 any relevance to anything?
22:14:06 <guest2425> Zao: sorry
22:14:34 <guest2425> Zao: no this is the test Prelude> take 4 (filter (odd,(<5) (map (^2) [1..])))
22:14:49 <xplat> for true arrays, though, you need a RAM, which functional languages like to avoid as much as possible
22:15:07 <Jafet> xplat: okay, computational complexity model. Term rewriting doesn't measure that very accurately, wrt implementation on a Real Computer
22:15:07 <guest2425> Zao: this is the test take 4 (listComprehension (^2) [(>5), odd] [1 .. ])   [49,81,121,169] 
22:15:13 <Zao> guest2425: Test for what? It doesn't involve your function at all.
22:15:15 <xplat> (although haskell's FFI stuff is only meaningful on a RAM)
22:15:16 <ivanm> guest2425: use the filter function to apply each filter
22:15:18 <monochrom> term rewriting is the most popular, as in, 3 people supports it and 0 people support anything else for normal use in beginner education. the 3 people are: Cale, Bird, me.
22:15:23 <ivanm> then apply the mapping function
22:15:42 <guest2425> Zao: yeah you are right
22:15:46 <ivanm> there are two ways of doing the former: apply each filter one at a time, or combine them all into one big filtering function
22:16:18 <ivanm> either way, you probably want a fold
22:16:41 <guest2425> ivanm: fold
22:16:42 <guest2425> ??
22:16:45 <kmc> this isn't so relevant but i liked the suggestion of defining (->) as:  data a -> b = Fun (exists fv. (a, fv) #-> b)
22:16:50 <ivanm> guest2425: foldr or foldl
22:16:51 <Zao> @type foldl
22:16:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
22:16:56 <ivanm> @type foldr
22:16:57 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:17:04 <Eduard_Munteanu> Well the thing is functional languages seem not to care about the underlying machine by tradition. Which suits lists and trees quite well.
22:17:06 <Cale> If term rewriting isn't enough, graph rewriting is a lot closer.
22:17:19 <guest2425> ivanm: foldr for what?
22:17:39 <ivanm> guest2425: the filtering functions
22:17:43 <Zao> guest2425: Either over your filters into a superfilter, or with your data over all filters.
22:17:44 <Eduard_Munteanu> While at least some imperative languages specify a lot in terms of an underlying machine.
22:18:03 <guest2425> ivanm: oh ok
22:19:24 <guest2425> ivanm: Like this listComprehension mapFn filters xs = foldr (filter filters (mapFn xs))
22:19:36 <xplat> kmc: what is #->?
22:19:38 <ivanm> no
22:19:42 <ivanm> that's wrong on at least two levels
22:19:53 <ivanm> 1) where you do the mapping; 2) what you do with the filters
22:19:57 <kmc> xplat, a notional "unboxed function" tycon
22:19:58 <ivanm> read above where I said what you need to do
22:20:11 <kmc> it's not actually a thing in any haskell impl. i know of
22:20:40 <kmc> but it would represent a function with no free variables, like a C function, and would be represented by a code pointer directly
22:21:15 <kmc> like other unboxed data, it's not a pointer to a heap-allocated closure
22:21:23 <monochrom> Oh! with fv you effectively have a closure
22:21:25 <guest2425> ivanm: like this listComprehension mapFn filters xs = mapFn (foldr (filter filters  xs))
22:21:33 <xplat> kmc: ah, cute
22:21:44 <kmc> right, this just makes the idea of lambda-lifting and closure visible in the type system
22:21:56 <kmc> and maybe you enable something clever by letting the user see #->
22:22:33 <kmc> for example data SerializableFun a b = SFun (exists fv. (Binary fv) *> (a, fv) #-> b)
22:22:49 <ivanm> guest2425: does that type check?
22:22:58 <ivanm> guest2425: let's do this a bit at a time
22:23:00 <xplat> i guess when defining an unboxed function there's a syntactic check that there's no free variables.  doesn't seem to go well with currying, though...
22:23:00 <guest2425> no
22:23:01 <guest2425> ok
22:23:04 <monochrom> neato
22:23:12 <ivanm> guest2425: we have a list of functions we want to filter with
22:23:22 <guest2425> yes
22:23:26 <kmc> xplat, yeah, i'm not sure if you provide "unboxed lambda" or something
22:23:27 <ivanm> so we have two options: 1) do them one at a time, or 2) combine them all into one big filtering function
22:23:38 <ivanm> monochrom: what does graphviz have to do with it? :p
22:23:45 <guest2425> 2 combine them
22:23:51 <kmc> i know ATS provides more explicit control of these things
22:24:00 <ivanm> guest2425: either option works, but you want to do option 2?
22:24:03 <kmc> but i haven't learned ATS, i found the "tutorial" to be utterly impenetrable
22:24:04 <monochrom> I don't know what graphviz has to do with "it". "it" = ?
22:24:09 <guest2425> yes
22:24:10 <ivanm> monochrom: "neato"
22:24:12 <Eduard_Munteanu> kmc: ATS?
22:24:14 <xplat> #->s would have to be either tupled or multiadic
22:24:23 <kmc> http://www.ats-lang.org/
22:24:27 <ivanm> guest2425: in that case: we need to write a function of type: [a -> Bool] -> a -> Bool
22:24:40 <ivanm> which can also be read as [a -> Bool] -> (a -> Bool)
22:24:48 <monochrom> graphviz has nothing to do with "neato".
22:24:53 <guest2425> ivanm: we have one all
22:24:54 <kmc> xplat, well, if you actually interpret A -> B -> C as A -> (B -> C) then it works out
22:24:58 <guest2425> :t all
22:24:59 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:25:03 <ivanm> monochrom: *sigh* just my feeble attempt at humour
22:25:11 <kmc> but implementations like GHC uncurry at the backend
22:25:14 <kmc> for efficiency
22:25:16 <ivanm> guest2425: your type signature says otherwise
22:25:17 <kmc> so yeah that would change things
22:25:25 <guest2425> yeah is true
22:25:27 <geheimdienst> ivanm, if humour doesn't work, try humor
22:25:45 <kmc> yeah, i've heard the British sense of humour is different
22:25:59 <ivanm> kmc: I'm not a brit though...
22:26:17 <xplat> canadian sense of humour is different yet ...
22:26:22 <ivanm> guest2425: what is true?
22:26:28 <ivanm> xplat: I'm not canadian either
22:26:32 <kmc> ivanm, you might want to work on that, i hear all the elite haskell haxorz are brits
22:26:37 <guest2425> ivanm
22:26:39 <monochrom> ATS is very verbose and cryptic at the same time (an unusual achievement!). I mean the type proof part. I say this is why the ATS tutorial is difficult.
22:26:45 <guest2425> ivanm: what u mean?
22:26:52 <kmc> monochrom, do you have any suggestions on how to learn ATS?
22:26:56 <ivanm> guest2425: you said "yeah is true"; what do _you_ mean?
22:27:03 <xplat> ah, cobol did it long before ATS
22:27:16 <ivanm> kmc: yeah, well, that was my original plan that fell through due to lack of funds
22:27:16 <guest2425> ivanm: all have a different type
22:27:23 <guest2425> all function
22:27:27 <guest2425> :t all
22:27:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
22:27:32 <ivanm> guest2425: what does it have to do with it?
22:27:41 <Eduard_Munteanu> I'm gonna kill a cute bunny if you start talking COBOL!
22:27:44 <ivanm> we want: [a -> Bool] -> a -> Bool
22:27:55 <xplat> mm, rabbit stew
22:27:55 <guest2425> ok
22:27:57 <shepheb> no shame in hailing from the same land as dons
22:28:02 <ivanm> i.e. take a list of functions and a value and return True if and only if all of those functions are satisfied
22:28:03 <guest2425> so all doesnt apply here
22:28:22 <kmc> in my programming languages class we made a big table of languages and their features; one of them was COBOL but nobody (including the prof) knew anything about it other than it had the most deployed lines of code ever
22:28:28 <kmc> kind of scary
22:28:33 <ivanm> so, we want: mergePredicates [f,g,h] x = f x && g x && h x
22:28:35 <ivanm> etc.
22:28:43 <ivanm> guest2425: we _can_ use all
22:28:46 <ivanm> but inverted
22:28:52 <xplat> kmc: and that was just the one program
22:28:56 <guest2425> oh ok
22:29:08 <guest2425> so the all function is ok
22:29:35 <ivanm> guest2425: to use all, consider it this way: are all of these functions True when we apply this value to it?
22:29:44 <monochrom> probably learn dependent type per se before tackling ATS
22:29:45 <Eduard_Munteanu> I hate it when my stupid textbooks say "This is a <blah> and can be implemented in an *adequate* programming language, like COBOL, FORTRAN, ..."
22:29:52 <guest2425> ok
22:29:55 <Eduard_Munteanu> Who says that in 2010?!
22:30:04 <guest2425> ivanm
22:30:09 <ivanm> yes?
22:30:14 <guest2425> ivanm: this is so hard
22:30:24 <ivanm> Eduard_Munteanu: well, they _are_ adequate... not necessarily nice, but adequate
22:30:29 <guest2425> ivanm: the more the worse
22:30:30 <ivanm> guest2425: not really
22:30:41 <ivanm> guest2425: a foldr makes much more sense though
22:30:46 <kmc> monochrom, i've done a fair amount of coq and a little agda
22:30:48 <guest2425> i feel like dumb a**
22:30:53 <kmc> i'm pretty comfortable with the basic idea of dt
22:30:56 <xplat> i don't even want to know how to implement a linked list in fortran, thanks
22:30:57 <ivanm> > foldr f a [b,c,d]
22:30:57 <lambdabot>   f b (f c (f d a))
22:31:02 <guest2425> :t foldr
22:31:03 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:31:11 <ivanm> xplat: Fortran 90+ is a lot nicer
22:31:14 <ivanm> (than 77)
22:31:15 <guest2425> oh ok
22:31:15 * Eduard_Munteanu also heard vague references to Miranda, but the same prof. used COBOL as a prime example usually.
22:31:22 <monochrom> practice a lot more agda.
22:31:26 <kmc> Fortran is still a respectable domain-specific language, afaik
22:31:30 <guest2425> so foldr can check every filter function
22:31:31 <kmc> for.... formula translation
22:31:33 <xplat> i used to know how to do them in MS BASIC, and my brain works so much better now that i forgot
22:31:47 <guest2425> ivanm: so foldr can check every filter function
22:31:53 <monochrom> typically, type proofs in ATS requires more work from you than type proofs in adga. my impression.
22:32:25 <kmc> http://toddhodes.com/Pics/old-fortran.jpg pic very related
22:32:42 <Eduard_Munteanu> Maybe. But I wouldn't say "hey, let's implement an SQL RDBMS in FORTRAN.".
22:32:46 <ivanm> guest2425: you can use foldr to combine all the filter functions into one big filter function
22:32:51 <guest2425> ivanm;  so I choose plan 1
22:32:57 <guest2425> ivanm:  so I choose plan 1
22:33:00 <xplat> i'm not sure an adequate proof system has been invented yet
22:33:10 <Eduard_Munteanu> (that's an actual example of *adequate*)
22:33:13 <ivanm> OK, so you can use foldr to apply every filter function to the list of values
22:33:23 <guest2425> ok
22:33:52 <kmc> let's implement an SQL RDBMS in FORTRAN
22:34:03 <guest2425> ivanm:  so like this listComprehension mapFn filters xs = foldr filters 
22:34:04 * Eduard_Munteanu snaps the bunny's neck
22:34:33 * xplat boils the water
22:35:11 <monochrom> use an array to hold all list nodes, used and free. use a global variable to point to your "free list". provide "new" and "free" operations.
22:35:49 <lars9> what in haskell is coresponding to ADT?
22:35:51 <ivanm> guest2425: no
22:36:03 <ivanm> guest2425: that still doesn't type-check for starters
22:36:03 <lars9> *difinition of
22:36:08 <monochrom> "data Hello = You | YouAgain Hello" is an ADT
22:36:09 <Eduard_Munteanu> lars9: data declarations
22:36:12 <ivanm> you need to apply each filter one at a time
22:37:06 <guest2425> one at time?
22:37:37 <lars9> Eduard_Munteanu: so is Data.Array ADT?
22:37:40 <guest2425> ivanm:  so like this listComprehension mapFn filters xs = foldr (filters) 
22:37:44 <Eduard_Munteanu> xplat: actually this reminds me of http://www.savetoby.com/
22:37:46 <monochrom> no, Data.Array is not an ADT
22:38:01 <ivanm> guest2425: *sigh* no, just putting parentheses there doesn't make a difference
22:38:14 <ivanm> guest2425: you aren't folding over the supplied list of values; you have to fold over the _filtering functions_
22:38:15 <guest2425> hahaha
22:38:34 <guest2425> foldr f (a,bc)
22:38:40 <ivanm> well, I take that back: you're not _meant_ to fold ver the supplied list of values, but that's what you're trying to do
22:38:51 <ivanm> guest2425: what is that supposed to be?
22:38:57 <guest2425> nothing
22:39:05 <xplat> "data Missile = Missile; data StarWars = Ballistic Missile | Anti StarWars Missile
22:39:22 <ivanm> xplat: lol
22:39:30 <guest2425> i need to do this foldr f (a,b,c)
22:39:35 <monochrom> star wars beget moar star wars
22:39:38 <ivanm> no, that doesn't type check either
22:39:46 <guest2425> oh man
22:39:58 <monochrom> you mean foldr f (+) [a,b,c] ?
22:40:32 <guest2425> :t foldr f (+) [a,b,c]
22:40:33 <lambdabot> forall a. (Show (a -> a -> a), Num a, SimpleReflect.FromExpr a) => a -> a -> a
22:40:55 <kmc> nice xplat
22:41:03 <monochrom> but in general you must communicate successfully with either computer or human. if you fail both, you're doomed. I'm sorry, that's how communication works.
22:41:53 <guest2425> ivanm: like this listComprehension mapFn filters xs = foldr f [filters]
22:42:08 <ivanm> guest2425: *sigh* no
22:42:23 <monochrom> that is a great misunderstanding of foldr.
22:42:24 <ivanm> 1) what is f? 2) does that type-check? 3) why make a singleton list containing a list of predicates?
22:42:29 <ivanm> @type foldr
22:42:30 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
22:42:57 <ivanm> guest2425: foldr takes in three values: the combining/folding function; the initial value and the list of values to fold over
22:43:09 <ivanm> in this case, the initial value is your xs and the list of values to fold over is your filters
22:43:16 * ivanm wonders if BigBlackDog is any relation to blackdog 
22:43:50 <monochrom> the final solution for listComprehension is unlikely to be just one call to foldr like that. it is not that easy.
22:44:29 <monochrom> BigBlackDog > blackdog  is probably the relation
22:44:37 <kmc> monochrom, that's what they want you to think
22:44:43 <geheimdienst> > foldr (+) 17 [2,3,4]
22:44:44 <lambdabot>   26
22:45:04 <ivanm> monochrom: well, no, but I told him to do the filtering first before the mapping
22:45:07 <geheimdienst> > (((17 + 2) + 3) + 4)
22:45:08 <lambdabot>   26
22:45:16 <ivanm> since that is trivial in comparison
22:45:35 <ivanm> > foldr f a [b,c,d,e]
22:45:36 <lambdabot>   f b (f c (f d (f e a)))
22:45:44 <ivanm> geheimdienst: isn't that what you did a foldl?
22:46:20 <geheimdienst> ivanm, you're right
22:46:24 * geheimdienst is embarrassed
22:46:34 <HWSOD> Hey I have a class Hashable, and I want to define for each Hashable type a maxHash :: Int that is the maximum the hash can reach.  But that doesn't work as maxHash's type doesn't mention any of the type variables of the class...what should I do? 
22:46:39 <ivanm> in your case, it's (2 + (3 + (4 + 17)))
22:46:53 <guest2425> ivanm: ok the f can be the all and a can be the filters and  [b,c,d,e] the list
22:47:13 <ivanm> HWSOD: two options: make it take a type, or don't have it return an Int but some kind of newtype with a phantom type parameter
22:47:23 <ivanm> guest2425: NOOOOOOOOO!!!!!!!!!!!!!!!!!!!!!!!
22:47:33 <guest2425> ivanm: oh man
22:47:36 <guest2425> ivanm: oh man
22:47:39 <ivanm> guest2425: don't you read _anything_ I write here?
22:47:44 <guest2425> ivanm: I do
22:47:46 <ivanm> I already said what the list of values should be
22:47:47 <monochrom> ivanm: do you intend [b,c,d,e] to be an example of "filters"?
22:47:54 <ivanm> monochrom: yes
22:47:59 <guest2425> but is really hard for me to follow
22:48:04 <ivanm> <ivanm> in this case, the initial value is your xs and the list of values to fold over is your filters
22:48:25 <Eduard_Munteanu> His relentless guessing is annoying.
22:48:29 * ivanm gives in
22:48:43 <ivanm> > foldr filter [1..10] [even,odd]
22:48:44 <lambdabot>   []
22:48:50 <ivanm> voila
22:48:57 <ivanm> work the rest of it out yourself
22:49:16 <HWSOD> ivanm: Is one a better option then the other?
22:49:24 <monochrom> you have two lists, "xs" and "filters". when ivanm suggests you to call foldr, well foldr wants a list parameter, but you have two lists to choose from, "xs" and "filters". you may like to consider all your options.
22:50:21 <monochrom> in general, unification is hard for computers and impossible for humans
22:50:40 <HWSOD> Unification?
22:51:15 <ivanm> HWSOD: the former is uglier in that it requires a useless value; the latter, however, may make it harder to use
22:51:26 <ivanm> then again, it has the advantage that you don't want to mix hash values up, so it's more strictly typed
22:51:28 <monochrom> unification is for example "foldr wants a list" "I have lists xs and filters" "hmm maybe I give filters to foldr"
22:51:29 <xplat> HWSOD: it's something you do while figuring out types in the presence of polymorphism
22:51:37 <Eduard_Munteanu> Or just don't put it in the typeclass.
22:51:55 <dankna> impossible for humans?
22:51:57 <Eduard_Munteanu> It makes little sense if Hashable is not an MPTC that's indexed by a polymorphic type.
22:52:21 <guest2425> ivanm: so in my case will be like this listComprehension mapFn filters xs = foldr filter xs [filters]
22:52:38 <Eduard_Munteanu> :O
22:52:41 <xplat> guest2425: alllllmost.
22:52:43 <HWSOD> Eduard_Munteanu: Why doesn't it not make sense?
22:52:46 <dankna> slightly more formally, unification is taking two abritrary data structures and combining them into one, when data structures may contain variables that have to match each other in place of any field.
22:53:10 <guest2425> Eduard_Munteanu: I am not guessing i am trying to understand I know you are a master in haskell
22:53:17 <dankna> I hadn't previously thought of it as connected to what I think of as the automatic-programming problem
22:53:17 <lars9> why this does not work? im expecting (1, "2"):  let a = second show; a (1, 2)
22:53:23 <xplat> if you want to learn a lot about unification, download any prolog and play with a tutorial
22:53:27 <dankna> but after monocrhom's comment I see that it is, so I'm pleased
22:53:35 <dankna> I can also recommend a survey paper on the subject
22:53:57 <Eduard_Munteanu> HWSOD: say you have a Hashable type. How could the type influence maxHash at all?
22:54:04 <guest2425> Eduard_Munteanu: but I want to learn thats all no need to be mean or rude it really hurts, I know another languages that you may dont have any idea 
22:54:18 <guest2425> how to write or read
22:54:19 <xplat> dankna: which one?
22:54:40 <guest2425> Eduard_Munteanu: how to write or read
22:54:48 <Eduard_Munteanu> guest2425: ok, I'm sorry. But I still think you need to read more before attempting something.
22:54:54 <monochrom> dankna: unification is impossible for humans because humans, well most of them anyway, try to be too creative.
22:55:03 <fdsf3> what does class Foo a b => Bar f a b | f a -> b where ... mean?
22:55:13 <fdsf3> the | f a -> b part specifically
22:55:16 <dankna> "Unification: A Multidisciplinary Survey" by Kevin Knight
22:55:26 <dankna> ACM Computing Surveys 21.1
22:55:28 <Eduard_Munteanu> guest2425: you don't want to simply stumble across the correct solution.
22:55:42 <dankna> monochrom: ah!  a reasonable position :)
22:55:54 <HWSOD> Eduard_Munteanu: because the number of posible values of the type is less then the hash feld, hmm hash is bad name for what I am doing.
22:55:57 <xplat> one thing i'm interested in lately is a more systematic approach to type inference
22:56:24 <guest2425> Eduard_Munteanu: i do read but not of the assignments are simple or follow the same structure as the book, the professor creates his owns higher higher higher functions 
22:56:46 <xplat> when treading outside of HM(X) the waters can get pretty murky
22:57:03 <Eduard_Munteanu> guest2425: are you following the same class as others that came in here and asked about mapReduce?
22:57:10 <guest2425> Eduard_Munteanu: yes
22:57:29 <guest2425> Eduard_Munteanu: MapReduce dont exists in haskell
22:58:03 <monochrom> Example of human creativity: I tutored a highschool student a simple version of income tax laws, 10% for the first $10000, 15% for the second $10000, etc. Walked through examples I worked out step by step. Then I let the student do it. Student took 30% of the first $10000. Why? Answer: "because I feel like it".
22:58:05 <xplat> and as far as i'm aware, the guiding mathematical light of type theory, curry-howard, has a fat lot of nothing interesting to say about type inference
22:58:09 <guest2425> Eduard_Munteanu: or Recursion Engine or Tail Recursion Engine the proff never write any code in class
22:58:37 <xplat> and somebody please tell me if i'm missing something, it will cure my headache
22:58:40 <dankna> that is.... quite an example of creativity haha
22:59:07 <monochrom> I basically define creativity = randomization.
22:59:09 <guest2425> Eduard_Munteanu: so I dont know how to correct errors or to follow a pattern for write code 
22:59:13 <kmc> yeah, under the curry-howard-debruijn isomorphism, type inference is a very strange thing indeed
22:59:16 <dankna> I don't think they're the same thing at all
22:59:20 <kmc> "given this proof, what's the most general statement we can prove"
22:59:36 <dankna> you should really use a different word
22:59:37 <xplat> monochrom: if you want to teach the student about tax laws, confiscate his wallet after he says that
23:00:06 <xplat> that's the main thing about tax laws: you can't do whatever you feel like
23:00:12 <guest2425> ok after that back to my function
23:02:01 <guest2425> Eduard_Munteanu: and then for HW9 he wants to write this puzzle KenKen is a relatively newly popular puzzle . The assignment is to write a solver for it.
23:02:57 <xplat> kmc: i tried looking at it like that, but really the proof normally includes the types, so it's more like when you see a formal proof in a maths class and it's written with statements on the left and things like '3 and 5, modus ponens' on the right, and you're figuring out what's the most general thing you can prove that fits just the right side
23:03:05 <kmc> yep
23:03:07 <kmc> which is even stranger
23:03:36 <xplat> it seems to make a little more sense from the categorical perspective
23:03:42 <xplat> er, categorial
23:03:46 <Eduard_Munteanu> guest2425: grr, that way of teaching really sucks. Did he link you to LYAH?
23:03:50 <Eduard_Munteanu> @where lyah
23:03:50 <lambdabot> http://www.learnyouahaskell.com/
23:04:13 <guest2425> yes
23:04:20 <monochrom> Eduard_Munteanu: you may like to know http://cs.calstatela.edu/wiki/index.php/Courses/CS_332F/Fall_2010
23:04:41 <xplat> where it's a diagram-completion process sort of similar to finding limits
23:04:49 <monochrom> special mention: the textbook!
23:05:01 <guest2425> xplat: so I am close 
23:05:48 <kmc> monochrom, reading is hard
23:05:54 <guest2425> Eduard_Munteanu:  see the scores for midterm 1 Midterm numerical scores: 100, 90, 68, 65, 50, 48, 45, 45, 40, 40, 38, 38, 35, 33, 30, 30, 30, 20, 20, 20, 20, 18, 17, 10, 10, 10, 0, 0, -30
23:05:59 <monochrom> Then again, perhaps you ask "did he link you to LYAH" in anticipation of "yes" so you can continue with "then the prof is beyond sucks" :)
23:06:06 <xplat> guest2425: your error is filters is already a list, so you don't have to enclose it in brackets
23:06:15 <guest2425> oh ok
23:06:20 <Cale> lol, someone got -30?
23:06:30 <guest2425> Cale: yes
23:06:34 <Cale> How do you get -30?
23:06:43 <Eduard_Munteanu> Linking to something else ain't bad if your textbook sucks. Actually it's better than to come up with something worse than average.
23:06:43 <guest2425> Cale: the proff 
23:06:45 <monochrom> I say that's a great prof just because -30 is possible with him.
23:07:02 <guest2425> Cale: his idea
23:07:05 <Cale> What did he do, egg the prof's car?
23:07:09 <Eduard_Munteanu> :)
23:07:32 <dobblego> sometimes I want to put print on a type-class so that I can "show" with multiple lines
23:07:46 <kmc> generally in a class where 30% is the median score, 30% will somehow end up a passing grade
23:07:51 <xplat> what, do you get a 0 if you leave the test blank, but yoou can get less than 0 points for an answer that is wrong?
23:07:58 <kmc> so i don't think complaining about the numeric scores in isolation is meaningful
23:08:03 <monochrom> No no, the "beyond sucks" part is a joke. I just want you to know, this course uses LYAH as textbook. I fully support it!
23:08:08 <Gracenotes> I've recommended LYAH to 3 people in real life lately
23:08:46 <Cale> I wonder if the guy who got 100% is in here
23:08:59 <Gracenotes> I think it is the easiest way to trick people into learning haskell, by recommending a haskell-learning tutorial :|
23:09:06 <kmc> i TAed a class that used min grading: your score on an assignment is the min, not avg, of your scores on its parts (and recursively a second level down)
23:09:08 <monochrom> perhaps the 100% guy is BONUS
23:09:16 <kmc> but it allowed reworks for full credit
23:09:21 <Eduard_Munteanu> guest2425: which of those monochrom linked is your assignment?
23:09:30 <geheimdienst> banging the prof's wife â -30
23:09:37 <kmc> geheimdienst, only if you leave her unsatisfied
23:09:38 <geheimdienst> banging the prof â 100
23:09:43 <kmc> hehehe
23:09:58 <xplat> what do you get if you bang both?
23:10:09 <monochrom> the look of the faces of #haskell netizens â priceless
23:10:24 <guest2425> Eduard_Munteanu: I am doing 8.2
23:10:26 <dankna> xplat: 70
23:10:32 <geheimdienst> kmc, true. banging and satisfying the wife would be -60
23:10:32 <guest2425> Eduard_Munteanu: I am doing HW 8.2
23:10:38 <pelotom_> Gracenotes: I've recommended it to 2 java dev coworkers... they're falling for it!
23:11:36 <monochrom> banging both should throw an overflow exception
23:12:04 <pelotom_> Gracenotes: one of them came back to me with a question that I couldn't answer, forcing me to learn about the monomorphism restriction :P
23:12:18 <Gracenotes> aha :)
23:12:27 <monochrom> introduce them to #haskell
23:12:39 <geheimdienst> monochrom, i do not want the term "overflow" mentioned in conjunction with banging people. it upsets my brain
23:12:47 <monochrom> hehehehe
23:12:57 <guest2425> I am getting this error message http://pastebin.com/0wBQFE7P
23:12:59 <pelotom_> yeah, when the time is right
23:13:09 <Gracenotes> well, the closer haskell's organization is to a cult structurally, the better
23:13:10 <Eduard_Munteanu> guest2425: have you identified how listComprehension's parameters match the basic list comprehension definition he gave? [(g x) | x <- <set>, filter_1 x, filter_2 x, . . . filter_n x]
23:13:27 <Gracenotes> he needs to initialize them as acquaintances first
23:13:36 <pelotom_> Gracenotes: funny you mention that, the other one is convinced it's a cult of some kind
23:13:44 <monochrom> I want to get their money. We all want their money, right?
23:13:59 <guest2425> Eduard_Munteanu: what you mean?
23:14:05 <geheimdienst> aren't cults often led by shady cabals?
23:14:11 <pelotom_> he says I'm making up these words "functor" and "monad"
23:14:23 <monochrom> we have a shady cabal, yes.
23:14:25 <pelotom_> they're strange ritualistic incantations
23:14:38 <Eduard_Munteanu> guest2425: ok, you're close.
23:14:39 <Zao> pelotom_: You need to learn how to roll your eyes back into your head.
23:14:40 <monochrom> it can sometimes chase dependencies.
23:14:53 <guest2425> ok
23:15:01 <xplat> the word monad is over 300 years old i think
23:15:16 <xplat> and functor is at least 80
23:15:18 <guest2425> Zao: You are funny
23:15:23 <kmc> geheimdienst, :/
23:15:31 <pelotom_> xplat: I don't think leibniz had category theory in mind :P
23:15:34 <Gracenotes> pelotom_: leave a cassette tape on his desk, with "zygohistomorphic prepromorphisms" repeating on a loop for 6 hours
23:15:38 <monochrom> Leibniz started our cult and our cult is 300 years old.
23:15:38 <guest2425> Zao: You are funny pelotom_: You need to learn how to roll your eyes back into your head.
23:15:46 <kmc> "monad" in the CT sense is a portmanteau of "monoid" and "triad" iirc and is fairly new
23:15:54 <kmc> they used to be called "triples", so descriptive
23:16:01 <Gracenotes> it must be a cassette tape, this is important
23:16:01 <geheimdienst> xplat, i thought leibniz's monad stuff is derived indepently of our word monad
23:16:08 <guest2425> Eduard_Munteanu: but I am getting that error message
23:16:22 <xplat> pelotom_: he should have, he might have overshadowed newton then
23:17:05 <xplat> certainly a better idea than the mystic garbage he DID have in mind.  well, i guess all one's ideas can't be as good as the calculus ...
23:17:08 <monochrom> our cult denounces newton's mutable variable approach to physics
23:17:09 <Gracenotes> monads aren't terribly monoidal in any just-Haskell abstraction
23:17:25 <kmc> they're monoid objects in the category of endofunctors!
23:17:37 <monochrom> @quote ennob
23:17:37 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
23:17:38 <Gracenotes> pssh, hask is the only category I need
23:17:44 <pelotom_> I heard Mac Lane was actually a pseudonym of L. Ron Hubbard
23:17:54 <kmc> http://blog.sigfpe.com/2008/11/from-monoids-to-monads.html http://monoidal.blogspot.com/2010/07/kind-polymorphism-in-action.html
23:18:34 <guest2425> Eduard_Munteanu: What can I do
23:18:36 <guest2425> ?
23:18:54 <xplat> geheimdienst: category theory pioneers had a tradition for a while of actively mining philosophy for words so i doubt it's unrelated
23:19:02 <kmc> xplat, leibniz may have been a crank philosopher but newton was an alchemist and occultist
23:19:12 <Gracenotes> yeah, the types are the main thing.. brain is too dumb at the moment for much else
23:19:18 <HWSOD> Eduard_Munteanu: so something like "newtype Hash a = Hash :: Int -> Hash"?
23:19:21 <xplat> they never took much care for the meanings, though, just used them where they sounded good
23:19:51 <guest2425> xplat: Help http://pastebin.com/0wBQFE7P
23:20:20 <dankna> yeah, I noticed that...  re things having different meanings in category theory and in philosophy
23:20:47 <xplat> kmc: yes, but newton had other ideas outside of just calculus in the 'actually profound rather than profound-sounding crap' category that are remembered, liebniz not so much, in fact voltaire managed to memorialize him for his philosophy ...
23:20:48 <pelotom_> CT also borrowed from programming languages... for instance it got "functor" from C++
23:20:51 <geheimdienst> xplat, i don't really know. somebody around here said to me that it was independently derived, that's all i know
23:20:53 <kmc> hahahaha
23:20:58 <pelotom_> :)
23:21:11 <Gracenotes> also http://en.wikipedia.org/wiki/Dualism does not explain comonads
23:21:19 <dankna> hahaha
23:21:19 <xplat> i thought it got it from prolog?  :)
23:21:44 <ksf> monadic pattern guards?
23:21:47 <dankna> @quote Gracenotes also http://en.wikipedia.org/wiki/Dualism does not explain comonads
23:21:47 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
23:21:52 <dankna> @remember Gracenotes also http://en.wikipedia.org/wiki/Dualism does not explain comonads
23:21:52 <lambdabot> Nice!
23:22:02 <dankna> @quote Gracenotes
23:22:02 <lambdabot> Gracenotes says: Firefox, for all its other faults, never fails to respond to a SIGTERM. firefox++
23:22:05 <dankna> @quote Gracenotes comonads
23:22:06 <lambdabot> Gracenotes says: also http://en.wikipedia.org/wiki/Dualism does not explain comonads
23:22:11 <dankna> there we go
23:22:12 <lars9> what does this mean? 
23:22:12 <guest2425> @remember
23:22:13 <lambdabot> Incorrect arguments to quote
23:22:14 <lars9> class MonadState m s | m -> s where  get :: m s put :: s -> m ()
23:22:25 <lars9> what is that m->s thing?
23:22:33 <kmc> functional dependency
23:22:34 <ksf> a functional dependency
23:22:34 <dankna> that is a functional dependency
23:22:40 <kmc> @quote fugue
23:22:40 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
23:22:44 <Gracenotes> lars9: you can't put any m there
23:22:51 <guest2425> How can I correct this error message http://pastebin.com/0wBQFE7P
23:22:51 <Gracenotes> m = Int makes no sense
23:22:52 <dankna> it indicates that any choice of monad m implies a particular choice of state s
23:23:13 <kmc> right, says you can't have Â«instance MonadState T S1Â» and Â«instance MonadState T S2Â»
23:23:17 <ksf> it means that a certain cohice of m fixes s to be something.
23:23:22 <Eduard_Munteanu> guest2425: look at mapFn
23:23:26 <kmc> the compiler checks this restriction, and in turn uses it to eliminate ambiguity where you use get/put
23:23:29 <guest2425> ok
23:23:49 <Eduard_Munteanu> guest2425: obviously that's your g in the list comprehension syntax
23:23:57 <lars9> so you can not define two MonadSate's instances, with the same m, different s?
23:24:02 <kmc> right
23:24:02 <dankna> correct
23:24:05 <monochrom> You may use Int for s, (State Int) for m.
23:24:08 <geheimdienst> what extension allows the Â«class C | m -> sÂ» stuff?
23:24:15 <kmc> FunctionalDependencies
23:24:16 <dankna> FunctionalDependencies
23:24:19 <Eduard_Munteanu> guest2425: but g works only on a single element
23:24:19 <dankna> jinx
23:24:25 <kmc> and they're pretty useless without MultiParamTypeClasses
23:24:26 <lars9> thanks
23:24:42 <geheimdienst> thanks. i *could* have seen that coming i guess
23:24:54 <Eduard_Munteanu> guest2425: the original syntax implied that g is applied to each element. How would you do that in your function?
23:25:04 <Axman6> so what are functional dependencies anyway?
23:25:11 <dankna> we.... just said what they are :)
23:25:13 <kmc> they're like burritos
23:25:20 <dankna> no no no, here's how it works
23:25:32 <Gracenotes> not having fundeps wouldn't be crippling
23:25:40 <geheimdienst> kmc, burritos in what category?
23:25:42 <dankna> a multi-parameter type class is like a bad metaphor.
23:25:44 <ClaudiusMaximus> mm, just spent an hour debugging: i had foldr (.) id (reverse ...) and changed it to foldl (.) id (id ...) at some point, along with some other things - oops
23:25:47 <Eduard_Munteanu> HWSOD: not really, aren't you comfortable with having maxHash
23:25:51 <pelotom_> I hear fundeps might go the way of the dodo
23:25:57 <Eduard_Munteanu> HWSOD: maxHash :: a -> Int ?
23:26:02 <dankna> the parameters of it are like the metaphors you're mixing
23:26:23 <monochrom> (this sounds like a disaster)
23:26:43 <pelotom_> isn't there something that supersedes them?
23:26:47 <Gracenotes> dankna: I can see you're burning out on this analogy, why don't you put it on the back burner and let it germinate
23:26:49 <monochrom> (but hahaha)
23:26:50 <kmc> pelotom_, yeah, most (all?) uses of fundeps can be translated to use associated type (or type synonym) families
23:26:52 <Eduard_Munteanu> HWSOD: you'd just use it like maxHash foo, where foo inhabits the type you'd like to figure out maxHash for
23:26:53 <dankna> Gracenotes: hahaha
23:26:58 <guest2425> Eduard_Munteanu: use map
23:27:07 <kmc> if you allow the class to have a superclass constraint which is a type equality constraint on the family
23:27:13 <kmc> which i think GHC allows now, but is still controversial and buggy?
23:27:14 <Eduard_Munteanu> guest2425: yep
23:27:29 <dankna> the compiler is like the person trying to make sense of the metaphor
23:27:48 <dankna> when the compiler can't tell what the metaphor is referring to, that's a problem
23:27:53 <geheimdienst> dankna, thanks for clearing that up
23:27:59 <lars9> and "instance MonadState (State s) s where" garantees that for SomeType, you can only define "instance MonadState (State SomeType) SomeType"?
23:28:00 <dankna> you're welcome :)
23:28:18 <monochrom> Yes
23:28:28 <kmc> "It's kind of like... It's kind of like playin' a basketball game.  I am there, and the other player is there, and it's just the two of us, and I put the other player's body in my van, and I am the winner"
23:28:42 <HWSOD> Eduard_Munteanu: I guess...just seems in elegant/counterintuivive to have an argument that is used only for types.  and  what I actualy do with hashes is rather limited.
23:28:51 <lars9> great.
23:28:54 <dankna> so you use functional dependencies, which are like condiments but for metaphors instead of food, to dress up the metaphor and give it a new flavor.  umm......  I think I'm confusing metaphors with burritos though.
23:29:14 <xplat> metaphors give me gas
23:29:18 <dankna> ha
23:29:37 <guest2425> Eduard_Munteanu: Still error message  http://pastebin.com/fb0CyfUr
23:29:38 <monochrom> I don't see why it clears anything up, but whatever the audience likes.
23:29:47 <kmc> dankna, since the burrito is a monoid in the category of bad explanations, you have a natural transformation Î· which lets you lift that metaphor to a burrito
23:29:50 <kmc> right?
23:29:52 <Eduard_Munteanu> HWSOD: well, consider you'd actually use that maxHash. How else could you specify the type?
23:29:57 <dankna> kmc: yes precisely!  ahahaha :D
23:30:04 <geheimdienst> monochrom: that was complete irony on my part
23:30:09 <monochrom> hahaha
23:30:15 <Gracenotes> I lift my coburritos into comonads
23:30:21 <guest2425> Eduard_Munteanu: I got it
23:30:28 <pelotom_> :D
23:30:44 <Gracenotes> or is that colift? I forget the variance of the lifting
23:31:04 <Eduard_Munteanu> guest2425: yeah, it's in the wrong place.
23:31:10 <HWSOD> oh hmm..yeah it was making more sense in my head, some how thought the array I am hashing into would know what I am hashing..but it doesn't.
23:31:15 <xplat> colift = bury?
23:31:16 <HWSOD> Thanks.
23:31:21 <guest2425> yeah I change it
23:31:44 <Eduard_Munteanu> guest2425: your function is something of a type [...]  -> [a] -> [b]
23:32:02 <pelotom_> everyone makes reference to the burrito explanation of monads, but I've never seen it... was there actually a real burrito metaphor?
23:32:05 <Eduard_Munteanu> guest2425: so the idea is to transform [a] into [b] using (a -> b)
23:32:21 <kmc> @where burrito
23:32:21 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
23:32:22 <Eduard_Munteanu> guest2425: the [a] is exactly foldr filter xs filters
23:32:23 <kmc> pelotom_, ^^^^
23:32:24 <shachaf> pelotom_: "burrito" is a parody of other monad explanations, like space suits and nuclear waste.
23:32:32 <guest2425> Eduard_Munteanu: oh ok
23:32:33 <kmc> pelotom_, and then i think someone tried to make one for serious, just because
23:32:34 <pelotom_> ah, ok
23:32:36 <xplat> anyway, eta wraps any bad explanation into a burrito, and epsilon unwraps any coburrito leaving only a bad explanation
23:32:50 <Eduard_Munteanu> I think byorgey made that up.
23:33:02 <Eduard_Munteanu> Not far from what other people have suggested though.
23:33:04 <kmc> a lot of the "monad analogies" are analogies for IO and little else
23:33:11 <pelotom_> now that you mention it I have seen that link
23:33:16 <Eduard_Munteanu> Indeed.
23:33:25 <xplat> some of them are analogies for maybe and list and little else
23:33:30 <pelotom_> kmc: they usually tend to favor either IO or collections
23:33:38 <kmc> i like the Typeclassopedia approach... definition, properties, examples
23:33:39 <Axman6> is there a reference anywhere for the things .cabal/config accepts?
23:33:41 <kmc> you know, math
23:33:50 <Eduard_Munteanu> kmc: yeah, Typeclassopedia is really good.
23:33:51 <shachaf> @quote think.of.a.monad
23:33:52 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
23:33:58 <geheimdienst> kmc, i think teaching by example is pretty okay
23:34:02 <Eduard_Munteanu> kmc: I wish it got wikified somehow
23:34:05 <dankna> Axman: unfortunately not, but it conveniently has all of the possible keys right there in the source file
23:34:08 <kmc> Dummit and Foote doesn't start out with "A group is like a burrito"
23:34:09 <Eduard_Munteanu> I only know his entry in a journal.
23:34:17 <Eduard_Munteanu> Ha.
23:34:22 <Axman6> dankna: -_-
23:34:28 <shachaf> @remember dons Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *but* the apples are carried around anyway, and you just take what you need.
23:34:28 <lambdabot> I will remember.
23:34:32 <xplat> there often is a motivation deal talking about symmetries
23:34:32 <pelotom_> the problem is, most people's brains are not wired for pure abstract math... which makes trying to understand anything about CT pretty hopeless
23:34:35 <ivanm> Axman6: the initial config?
23:34:39 <dankna> er, I mean in the initial config file
23:34:45 <xplat> in group theory books
23:34:49 <Gracenotes> meh, I am not feeling like learning today. where has my intellectual curiosity gone.
23:35:05 <kmc> pelotom_, yeah, but you can understand Monad as a Haskell API without understanding what it means in CT
23:35:17 <dankna> soooo many things wrong with the spacesuit/nuclear-waste explanation...
23:35:19 <kmc> typeclassopedia isn't particularly categorical
23:35:20 <Axman6> ivanm: hmm, good idea. do you know where it is? i installed cabal-install before there was one afaik
23:35:22 <Eduard_Munteanu> You can.
23:35:25 <monochrom> eat some intellectual burritos
23:35:28 <pelotom_> kmc: true
23:35:35 <ivanm> Axman6: ~/.cabal/config
23:35:36 <kmc> "But I have a Ph.D. in Mathematics, and I'm sure a Circle is a kind of an Ellipse! Does this mean Marshall Cline is stupid? Or that C++ is stupid? Or that OO is stupid?"
23:35:51 <ivanm> if it's already tehre, just move it somewhere and then do a "cabal update" to get a new one
23:35:54 <dankna> if you rename your ~/.cabal/config and ... right
23:36:02 <xplat> a monad is like a spacesuit, in that like a spacesuit, you can wrap a monad into a delicious burrito and eat it
23:36:32 <dankna> xplat: bonus points for making no sense in that you can't wrap a spacesuit into a burrito
23:36:35 <Gracenotes> subtyping is overrated
23:36:38 <kmc> sure you can
23:36:41 <pelotom_> xplat: a burrito wrapped in a burrito is just a burrito
23:36:57 <dankna> so the burrito constructor is idempotent?  nice trick
23:37:02 <kmc> pelotom_, you'd think that, then you bite into a nice chunk of aluminum foil
23:37:03 <kmc> *ouch*
23:37:19 <monochrom> alumimium foil is delicious
23:37:34 <kmc> gotta keep those bones strong somehow
23:37:50 <pelotom_> hehe
23:37:53 <monochrom> gold foils too
23:37:58 <lars9> we can use State Monad to hide random generator inside a State Monad, but how can we hide rand gen in a IO Monad?
23:38:01 <Eduard_Munteanu> Is there a coburrito analogy? :P
23:38:13 <kmc> shit, what kind of taqueria wraps your burrito in gold?
23:38:15 <xplat> aluminum foil is a coburrito, you unwrap it before you eat
23:38:23 <monochrom> japanese kind
23:38:27 <kmc> lars9, IO comes with a rng built in, see randomIO etc
23:38:29 <pelotom_> burrito and spacesuit are different kinds of monads, so if you want to wrap a spacesuit in a burrito you need a BurritoT
23:38:32 <kmc> but it's slow, as is all of System.Random
23:38:41 <kmc> i like the mwc-random package
23:38:48 <dankna> it's not called BurritoT, it's called Tortilla
23:39:04 <monochrom> my sister brought back a dessert from japan. it had little sprinkles of gold. the japanese like to eat gold.
23:39:34 <Eduard_Munteanu> Then you end up like the blue guy.
23:39:42 <xplat> that's silver
23:39:57 <Eduard_Munteanu> xplat: I hear gold can do something similar.
23:39:59 * kmc wonders which is a more excessive display of wealth: eating flakes of gold or taking a shit in a bowl of clean drinkable water
23:40:28 <lars9> kmc: i used randomIO before. now im trying to understand the State way. is what I said right?
23:40:36 <kmc> what did you say lars9?
23:40:37 <pelotom_> kmc: shitting gold flakes that you just ate into potable water
23:40:43 <monochrom> or using a 3GHz quad-core computer to watch youtube
23:40:49 <Eduard_Munteanu> That would be fun, seeing a blue monochrom :P
23:41:25 <lars9> kmc: we can not hide rand gen in IO monad using State monad
23:41:34 <kmc> i don't follow
23:41:42 <kmc> if you want to use State and IO together, you'd use StateT
23:41:43 <xplat> using a 3GHz quad-core computer to simulate a 6502 on the transistor level in javascript
23:41:48 <kmc> @unmtl StateT s IO a
23:41:48 <lambdabot> s -> IO (a, s)
23:41:58 <monochrom> hahaha xplat wins
23:42:06 <kmc> xplat, based on an actual die image! that was so badass
23:42:13 <lars9> kmc: oh i see, thanks
23:42:35 <kmc> lars9, unless you need precise control of the seed etc, i think it's better to use randomIO and friends
23:42:41 <xplat> kmc: yes it was
23:42:51 <monochrom> wait, on top of that simulation, what do you do? play pacman?
23:42:52 <geheimdienst> xplat, but can your 6502 thingy display youtube videos of cats falling out of the drawer?
23:44:03 * Eduard_Munteanu wonders if 3GHz is enough to get a ua741 simulated real time
23:44:20 <Eduard_Munteanu> *even a
23:45:30 <lars9> @instances MonadReader
23:45:31 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
23:45:32 <ClaudiusMaximus> > take 10 . scanl (+) 0 . map (2^) $ [1..]
23:45:33 <lambdabot>   [0,2,6,14,30,62,126,254,510,1022]
23:45:36 <lars9> @instances MonadState
23:45:36 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
23:45:39 <ivanm> preflex: seen Cale 
23:45:39 <preflex>  Cale was last seen on #haskell 36 minutes and 53 seconds ago, saying: I wonder if the guy who got 100% is in here
23:46:28 <Eduard_Munteanu> preflex: seen preflex 
23:46:28 <preflex>  what
23:46:34 <Eduard_Munteanu> Had to try.
23:46:40 <monochrom> heh
23:46:50 <ivanm> preflex: seen ivanm 
23:46:50 <preflex>  ivanm was last seen on #haskell 1 minute and 11 seconds ago, saying: preflex: seen Cale 
23:47:00 <ivanm> OK, so preflex isn't _that_ smart...
23:47:16 <dankna> preflex: seen dankna
23:47:16 <preflex>  dankna was last seen on #haskell 8 minutes and 28 seconds ago, saying: it's not called BurritoT, it's called Tortilla
23:47:21 <dankna> preflex: seen dankna
23:47:21 <preflex>  dankna was last seen on #haskell 5 seconds ago, saying: preflex: seen dankna
23:47:56 <monochrom> it is not about smart. it is about 0-based or 1-based.
23:48:26 <ClaudiusMaximus> my algorithm takes O(3^N) time, where size of output is O(2^N) - should i try harder to optimize or is the asymptotic complexity equivalent?
23:48:29 <monochrom> which is like arguing hyperlink colours
23:48:43 <dankna> BLUE
23:48:47 <dankna> but yes
23:49:05 <monochrom> no, 3^N and 2^N are not just a constant multiple apart.
23:49:18 <Jafet> Claudius: they're clearly not equivalent -- so what?
23:49:21 <Eduard_Munteanu> ClaudiusMaximus: usually a^n is hellish any way you take it.
23:50:10 <Eduard_Munteanu> anyway, O(3^N) = O(2^N), except a constant
23:50:25 <monochrom> which constant?
23:50:36 <ivanm> monochrom: he means the growth either way is exponential
23:50:40 <Jafet> 1.5^N, negligible for all negligible N
23:50:46 <Jafet> Or something
23:50:50 <monochrom> haha
23:51:00 <ilab> ClaudiusMaximus: what's the typical size of your input?
23:51:39 <ClaudiusMaximus> input is a small integer (eg, i can go up to about 17 before i have to wait more than 3 minutes...)
23:52:57 <Eduard_Munteanu> 3^N vs 2^N  -->   log 3^N vs log 2^N    -->  by changing bases you end up with a log/log constant on one side
23:53:39 <dankna> uh but...  am I missing something, or is 3^N not the same thing as log 3^N?
23:53:54 <Eduard_Munteanu> Which you can take back into the exponential, but it doesn't matter much.
23:54:00 <kmc> O(2^N) â  O(3^N).  this much is mathematically certain
23:54:07 <Eduard_Munteanu> Yeah.
23:54:07 <xplat> 2^N vs 3^N is a huge difference
23:54:13 <kmc> however, whether you care is a fuzzier question
23:54:14 <ilab> aka little o becomes big o when you do the log transformation
23:54:16 <Jafet> But also â  â  â 
23:54:36 <pelotom_> haha
23:54:36 <kmc> > let (â ) = (/=) in (â ) â  (â )
23:54:37 <lambdabot>   *Exception: (/=): No overloading for function
23:54:49 <geheimdienst> > "â " /= "â "
23:54:50 <lambdabot>   False
23:55:02 <dankna> I don't think you can treat it like an equation and say O(2^N) has some relationship with O(3^N) and apply a transformation to both sides and obtain an also-true statement, like you're doing
23:55:04 <ilab> Eduard_Munteanu you shoudn't bother . you will save about 2 seconds on a modern computer at n=17
23:55:16 <kmc> > let x = 0/0 in x == x
23:55:17 <lambdabot>   False
23:55:19 <kmc> > let x = 0/0 in x /= x
23:55:19 <lambdabot>   True
23:55:20 <Eduard_Munteanu> Yeah... though this was for ClaudiusMaximus 
23:55:21 <dankna> the definition of O(n) actually overrides the meaning of the equals sign, in fact
23:55:26 <kmc> yeah :/
23:55:37 <kmc> but i meant it in the true sense, as set equality
23:55:58 <xplat> like, if you have a 3^N algorithm, and you discover an optimization that makes it faster by 2^N, it's still exponential
23:56:03 <dankna> oh - set equality eh, yeah.
23:56:22 <kmc> but when people write Â«f(n) = O(n)Â» to mean Â«f(n) â O(n)Â», that's annoying
23:56:34 <dankna> I can't see whatever character it is you're using there
23:56:36 <dankna> it shows up as blank
23:56:38 <kmc> set element
23:56:41 <dankna> oh, okay
23:56:53 <pelotom_> = there is not bad usage... what seems like more of an abuse is when people say "some algorithm x = O(log n)"
23:56:57 <kmc> \in
23:57:01 <Eduard_Munteanu> O(f(n)) = O(g(n)) <=> \exists h(n) so that f(n) e O(h(n)) and g(n) e O(h(n))
23:57:02 <pelotom_> kmc: er, yeah
23:57:06 <Eduard_Munteanu> s/e/belongs to/
23:57:35 <Jafet> You mean \forall?
23:57:36 <Eduard_Munteanu> Err actually that makes sense for big theta.
23:57:38 <kmc> if you can't see â might i suggest â¬
23:57:49 <dankna> haha Euro sign
23:57:53 <Eduard_Munteanu> kmc: I don't have a keybinding, but I see it.
23:57:53 <dankna> I can see it now for some reason
23:57:57 <kmc> @let (â¬) = flip ($)
23:57:58 <lambdabot>  Defined.
23:57:59 <dankna> I can see it in your most recent line, that is
23:58:09 <Jafet> @remember kmc if you can't see â might i suggest â¬
23:58:09 <lambdabot> It is stored.
23:58:09 <HWSOD> Hey so I am using "True =>>" as a way to lift a boolean to a property but is there more standard way to do that?
23:58:23 <Eduard_Munteanu> Anyway, people _usually_ mean theta rather than O
23:58:59 <HWSOD> yep..
23:59:02 <xplat> nah, usually they have only one bound
23:59:04 <kmc> HWSOD, don't things usually take (Testable a) => a rather than Property?
23:59:09 <kmc> if so you can use the Boolean directly
23:59:15 <ilab> Eduard_Munteanu: I disabree upper bounds are far easier to establish than lower bounds. Usually people mean O
23:59:28 <kmc> otherwise it seems reasonable but i'm no QC expert
23:59:56 <ksf> yep. upper bounds are trivial.
