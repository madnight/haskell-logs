00:00:12 <kmc> pretty sure it's 1x now and even that is slightly optimistic
00:00:19 <kmc> btw java will get lambda in late 2012
00:02:14 <JoeyA> http://cosmos.constellationmedia.com/~funsite/pic/lambda-calculator.png  :-)
00:15:47 <pistacchio> hi, i have a a problem understanding the following: http://hpaste.org/41639/problem_with_setfold 
00:15:52 <ziman> JoeyA, cool ;)
00:16:04 * ziman would like to have the power of haskell in a portable device :)
00:16:41 <pistacchio> x in the lambda is clearly a BoardTile, but shoul'd it be not relevante as i'm not using it an the accumulator is a string?
00:17:03 <Twey> pistacchio: You got the arguments backwards
00:17:11 <Twey> The first is the item, the second the accumulator
00:17:16 <Twey> :t Data.Set.fold
00:17:17 <lambdabot> forall a b. (a -> b -> b) -> b -> S.Set a -> b
00:17:34 <pistacchio> oh, so it workd like foldr?
00:17:42 <Twey> Yes
00:18:08 <Twey> Also, I hope you realise that boardToString = const ""
00:18:37 <Twey> (but slower :þ)
00:19:18 <pistacchio> yes, i know :)
00:19:25 <pistacchio> it's a placeholder for now
00:20:20 <Twey> Alright
00:45:29 <ttm> Suppose I have a 32-bit floating point number, and I want to turn it into a string equivalent to the output of printf("%d", myFloat) in C. e.g. 0.1 goes to "1036831949", -0.1 goes to "-1110651699", etc. What would be the simplest way to do this in Haskell?
00:47:51 <maurer_> ttm: Why do you want to do that?
00:48:51 <ttm> I'm writing software to control with a Parrot AR.Drone, and unfortunately, that's the format in which it wants its directional commands.
00:48:55 <Starfire> You can probably accomplish that using decodeFloat in some manner.
00:50:03 <engla> ttm: that's crazy
00:50:04 <ziman> or Data.Binary(.IEEE754 ?)
00:51:41 <maurer_> ttm: OK, just wanted to check you were sane. Check out Data.Bits, see if there's an instance of Floats. If not, you can use the dreaded unsafeCoerce to an approriate type from Data.Int
00:51:53 <ziman> i'd say the wrong way is unsafeCoerce; you can use it to test that it's possible, however
00:52:14 <ziman> I don't know how unsafeCoerce interacts with endianity and stuff...
00:52:45 <maurer_> ziman: I don't think it interacts with endianness at all. I think it just does the equivalent of a C reinterpret cast
00:53:07 <maurer_> i.e. *((*thenewtype)(&x))
00:53:34 <ttm> Data.Bits was the first place I looked. Unfortunately since the Haskell specification is intentionally vague on what a "Float" is, it doesn't seem to interact with floating point numbers
00:53:39 <ziman> yes, but does the IEEE754 representation reverse when the int representation reverses by switching to a different endian?
00:53:51 <ttm> Data.Binary looks like it might be just what I needed though
00:55:33 <ziman> (it works here, however:) > unsafeCoerce (0.1 :: Float) :: Int
00:55:33 <ziman> 1036831949
00:57:03 <ttm> oh, excellent. Thanks!
01:02:30 <engla> The C standard doesn't require a particular float representation either so
01:03:31 <Zao> engla: It doesn't?
01:04:09 <kmc> yeah, unsafeCoerce is a run-time no-op
01:04:30 <Zao> C++ thankfully has ways to test for IEEE 754.
01:04:41 <kmc> ttm, you could also literally use the c (sn)printf, via FFI
01:04:55 <Zao> Well, they call it IEC 559 or somesuch.
01:05:27 <kmc> i would steer clear of unsafeCoerce unless you need crazy performance
01:05:44 <kmc> you can coerce stuff through Storable; this has a number of advantages
01:06:09 <kmc> the representation is guaranteed to match your system's C ABI
01:06:18 <kmc> and you can check that the sizes match
01:06:44 <engla> Zao: no it can't, it's a free parameter so that C can be as fast as possible on any crazy platform
01:06:54 <onteria> So I had a dream that I was floating in a sky full of lambda symbols. That's okay though, probably nothing to worry about.
01:07:20 <ttm> Using the FFI seems to me to be roughly equivalent to using unsafeCoerce. It's just a matter of who has to do the semantic ugliness of reinterpreting the bits.
01:07:41 <Zao> engla: They could still have provided a macro or so to test for it.
01:07:53 <Zao> Much like std::numeric_limits<T>::is_iec559;
01:08:44 <ziman> > let conv = runGet getWord32le . runPut . putFloat32le :: Float -> Word32 in conv 0.1
01:08:45 <lambdabot>   Not in scope: `runGet'Not in scope: `getWord32le'Not in scope: `runPut'Not ...
01:08:47 <kmc> using Storable lets you test that Float and Int are the same size on your platform
01:08:47 <ziman> 1036831949
01:08:48 <ziman> ^^ Data.Binary
01:08:57 <kmc> which should prevent the behavior from being nondeterministic or memory-unsafe
01:08:58 <engla> Zao: why? There's nothing you can do in ISO C if the test fails
01:09:37 <Zao> engla: Eh? It would give you the information on whether you can abuse a float/double as 754-conformant or not.
01:09:46 <Zao> Of course, in whatever application you talk about here, it would not help anything.
01:10:13 <ziman> a little bit longer than unsafeCoerce and *much* nicer
01:10:30 <engla> Zao: ok I see, so it would enable some bit hacks on floats (like the invsqrt2 hack)
01:12:47 <Zao> Or shoving one as-is into a network stream if the protocol mandates 754.
01:12:50 * hackagebot NXT 0.1.2 - A Haskell interface to Lego Mindstorms NXT  http://hackage.haskell.org/package/NXT-0.1.2 (MitarMilutinovic)
01:12:51 <Zao> But yeah.
01:40:14 <JaffaCake> quicksilver: did you want something?
01:41:35 <quicksilver> JaffaCake: indirectly :)
01:41:48 <quicksilver> JaffaCake: ndm had some questions about garbage collection which went beyond my knowledge
01:41:57 <quicksilver> JaffaCake: I think he may have emailed g-h-u and/or you
01:42:30 <JaffaCake> don't see any messages from him
01:43:23 <quicksilver> JaffaCake: well, the specific question was, which is gen 0 and which is gen 1 and what, precisely, does performGC force to occur?
01:44:00 <JaffaCake> performGC does a full GC (all generations)
01:44:14 <JaffaCake> gen 0 is the young generation
01:44:44 <quicksilver> does RTS -S only show the oldeest?
01:44:54 <quicksilver> so when the log says 'Gen : 1' it means gen 0 + gen 1?
01:45:11 <quicksilver> (ndm's output : http://hpaste.org/41613/rts_s_output )
01:45:16 <JaffaCake> +RTS -S shows all collections
01:45:39 <JaffaCake> right, in generational GC you always collect generations 0..K
01:46:15 * quicksilver nods
01:49:05 <Toxaris> Someone understands GPL? Does it make sense / is it allowed to release a "script" for pandoc under BSD3 when pandoc is released under GPL? I didn't copy code from pandoc, and I do not release a binary, but the code doesn't make much sense without pandoc.
01:49:42 <Jafet> The GPL does not cover the output of software (unless the output happens to contain copyrighted parts of the software)
01:50:05 <ziman> yes, it is okay; you are just not allowed to link with pandoc (which you do not do)
01:51:03 <merijn> Actually, you could distribute *your* code as BSD3 even if it did link with the GPL
01:51:07 <quicksilver> actually you could be allowed to link
01:51:15 <Toxaris> Jafet: I mean "script" in the sense of a Haskell program doing "import Text.Pandoc"
01:51:15 <quicksilver> since BSD3 is very permissive, and does not contradict the GPL
01:51:47 <quicksilver> you'd just be saying "the bits I wrote, you can do whatever you like with, the bits which are pandoc, you must adhere to the GPL"
01:52:04 <quicksilver> (BSD3 approximately says 'whatever you like' - simplifying a little ;)
01:52:06 <merijn> The GPL says "any extension of this code is not allowed to take away anyway GPL rights", BSD3 gives you more rights then GPL. Now you can't relicense the original code to BSD3 (since it's GPL), but you can distribute BSD3 code with GPL
01:52:37 <Jafet> I was wondering, when did pandoc support scripting
01:53:37 <Toxaris> Jafet: pandoc supports custom template files which are kind-of scripts in the sense of "pandoc interprets them"; but pandoc also has a wonderfull Haskell API, and using that API is called "scripting" by John: http://johnmacfarlane.net/pandoc/scripting.html
01:54:27 <Toxaris> ok I see, so if I want to say: "Do whatever you want to *my* code here", BSD3 is the way to go, independently of pandoc's license
01:56:15 <Toxaris> the part about "output of software", however, makes me wonder about the template files
01:56:17 <Jafet> "...except remove the parts that say I wrote it, or do this other thing which is of questionable legality anyway"
01:57:14 <merijn> Toxaris: Pretty much, BSD3 basically says "this has no warranty, you can't say you wrote it or remove my name from it and you can't claim I support whatever program you use this code in"
01:58:33 <Toxaris> Jafet, merijn: Yeah I am aware that BSD3 is not public domain, so I paraphrased wrongy :) The cool thing about BSD3 is that one can actually read it to understand it
01:58:55 <Jafet> ...I read the GPLs and understood them.
01:59:48 <merijn> The GPL is considerably longer and therefore more boring then BSD, though :p
02:01:11 <Toxaris> So if I copy and change a template file distributed with pandoc, and distribute it with my "script", that template file should contain a comment saying that it contains text written by John (i.e., pandoc's author). Would that be enough?
02:01:54 <Jafet> It would be considered a derivative work, and thus covered by the GPL.
02:06:36 <Toxaris> Ok thanks everyone.
02:07:46 <Jafet> No wonder this channel is so big... we're assimilating #gnu now
02:11:06 <merijn> Jafet: They're confused because they think GHC stands for GNU Haskell Compiler :D
02:11:39 <merijn> Also, most GNU programs lead me to believe GNU hackers are fundamentally incompatible with Haskell coding philosophy :p
02:11:53 <Cale> oh?
02:11:53 <lambdabot> Cale: You have 3 new messages. '/msg lambdabot @messages' to read them.
02:11:56 <pkrumins> GNU's hello world is 500 loc.
02:12:02 <Cale> heh
02:12:07 <pkrumins> true fact.
02:12:17 <Jafet> pkrumins: in how many different languaes?
02:12:22 <ksf> GNU is the holy catholic cathedral.
02:12:40 <pkrumins> Jafet: in just C!
02:12:42 <Jafet> Sunday market.
02:12:50 <Jafet> pkrumins: oh, impressive
02:13:01 <Cale> As opposed to a false fact
02:13:12 <pkrumins> http://www.gnu.org/software/hello/
02:13:27 <merijn> Cale: You could have an undetermined fact if you don't do classic logic :p
02:14:02 <merijn> pkrumins: Holy crap, you weren't joking? :O
02:14:08 <pkrumins> no
02:14:27 <Jafet> This manual [for hello world] is available in the following formats: * HTML (48K bytes)
02:14:34 <Cale> Well, the size sort of makes sense once you realise what they're doing.
02:14:53 <Jafet> I could never get to terms with their bureaucracy, either.
02:15:07 <Jafet> It's good bureaucracy, but it's difficult in a way.
02:15:30 <ksf> it's not hierarchy, it's the RMS willed hierachy.
02:15:38 <ksf> er it's not bueroucracy.
02:15:47 <ksf> bureaucracy, even.
02:16:19 <ksf> It's also not freedom, it's GNU/freedom.
02:16:23 <Jafet> I refer to their programming and packaging rules.
02:16:27 <Cale> It all just code for making sure that the locale is respected, parsing commandline options and printing informational messages
02:16:30 <engla> it also demonstrates code bloat by supplying options to choose between Hello, World and hello, world
02:16:31 <Cale> It's*
02:17:27 <Jafet> How many loc would be needed to do that in haskell?
02:17:38 <Jafet> With base
02:17:56 <ksf> with proper i18n, I'd say at least 10k.
02:18:09 <Cale> Fewer, since the default String I/O respects locale, but still a fair number of lines with all the messages.
02:18:10 <ksf> most of that being grammatical framework grammar definitions, though.
02:18:21 <Cale> lol
02:18:22 <Jafet> ksf: snob
02:19:10 <ksf> I call out a competition to create the most horribly bloated hello world program.
02:19:59 <Cale> Actually, hello.c itself is only 215 lines (including all the comments)
02:20:33 <ksf> ./hello --name Joe --irregular-catalan=Joee
02:20:40 <merijn> ksf: Take a look at the IOCCC archives, bound to be one there?
02:20:42 <ksf> (not that I know catalan, but you get the idea)
02:21:08 <Jafet> I think he means functionality-bloated, not code-size-bloated
02:21:14 <ksf> yep.
02:21:18 <Jafet> ("Necessary bloat"?)
02:21:26 <Jafet> "Minimal bloat"
02:21:29 <Toxaris> sounds like a possible \bot plugin
02:21:35 <Toxaris> @greet 
02:21:35 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-23
02:22:02 <ksf>  @noob, which translates pointless code to long painful chains of awkwardness?
02:22:19 <Jafet> I thought that was called @unpl
02:22:30 <ksf>  @unpl is usually quite reasonable.
02:22:51 <ziman> "When in doubt whether something is needed or not, include it. It's better to include too much than to leave out something important."
02:23:07 <engla> functional/options for everything bloat is horrible
02:23:54 <merijn> ziman: That's the opposite of my well loved YAGNI philosophy :>
02:24:31 <Jafet> import Network.Mail
02:25:02 <Cale> engla: On the other hand, I'm getting sick of the over-minimalism that seems to have infected Gnome and related services and tools. In Ubuntu's default configuration, I can't even separately control my headphone volume from my speaker volume. It's all just one big volume knob.
02:25:29 <merijn> Cale: minimalism and Gnome seems a contradiction...
02:25:45 <Jafet> Minimalist bloat strikes again
02:26:05 <Jafet> The pulseaudio control program is decent, though.
02:26:13 <Cale> I HAET IT
02:26:17 <Cale> hehe
02:26:28 <Jafet> It lets me overdrive the audio output
02:27:24 <Cale> It's awful. Sure it provides volume controls for each program separately, but no controls for controlling various outputs from my soundcard.
02:27:48 <Cale> (Despite the fact that ALSA sees them)
02:27:54 <Jafet> alsamixer, then?
02:28:05 <Cale> Yeah.
02:28:08 <Tychom> I'm trying to understand the difference between these two expressions: (take m $ drop n (iterate (1+) 1)) and (take m $ drop n [1..])
02:28:08 <Tychom> given a large value for n it's possible to out-of-memory on the former but not the latter, i'm wondering how that would be avoided.
02:28:20 <Jafet> You can probably apply the OSI layer model to linux audio these days
02:29:08 <Cale> (and the old gnome volume mixer, though now I have to compile that myself along with a bunch of other things, since Ubuntu decided it would be better to turn off ALSA support.)
02:29:25 <osfameron> ubuntu has too many music subsystems :-(
02:29:31 <sipa> Tychom: i may be because of fusion performed in the second case
02:29:47 <osfameron> I like that when using windows or mac I don't even *know* what the audio subsystem is called ;-)
02:30:08 <sipa> the nice thing about standards is that there are so many to choose from
02:30:10 <Jafet> Even without fusion, the first shouldn't leak space
02:30:35 <Cale> Tychom: The difference is really sneaky.
02:30:53 <Cale> iterate f x = x : iterate f (f x)
02:31:11 <Toxaris> Jafet: it might be a lazyness leak :)
02:31:21 <geheimdienst> gnome does seem to hit exactly the sour spot of using lots of bloat to disappointingly little
02:31:22 <Jafet> Oh, so it would.
02:31:24 <Cale> So, if you think about what iterate (1+) 1 produces, it looks like this, supposing we're only forcing the spine of the list (as the drop will)
02:31:27 <Entroacceptor> how would they turn off alsa support?
02:31:32 <Entroacceptor> what do they use as driver, then?
02:31:33 <geheimdienst> *accomplish
02:32:03 <Cale> iterate (1+) 1 -> 1 : iterate (1+) ((1+) 1) -> 1 : (1+) 1 : iterate (1+) ((1+) ((1+) 1)) -> ...
02:32:21 <Cale> Eventually the unevaluated expressions are going to get rather large.
02:32:30 <engla> Cale: ah that sounds irritating. although I in general don't want to include options for everything
02:32:39 <Cale> (If we never force any other them)
02:32:58 <Jafet> > head . drop 1000000 $ iterate succ 0
02:32:59 <lambdabot>   *Exception: stack overflow
02:33:10 <Jafet> > let iterate' f x = let x' = f x in x' `seq` x : iterate f x' in head . drop 1000000 $ iterate' succ 0
02:33:11 <lambdabot>   *Exception: stack overflow
02:33:51 <Toxaris> Jafet: maybe the seq is still hidden inside the (:) cell
02:34:14 <Toxaris> Jafet: and you want iterate' for the recursive call
02:34:28 <Cale> So after dropping 1000000 elements from the head of the list, we'll be left with a giant expression (using up memory in the heap), and the evaluation of that expression will tend to use lots of stack space, because (1+) needs to "pattern match" on its argument, so you'll end up with lots of pattern matches waiting to happen.
02:34:54 <Tychom> ok, i sort of expected the issue to disappear at -O2 but c'est la vie
02:35:00 <Jafet> Oh, durr
02:35:30 <Jafet> > let iterate' f x = x `seq` x : iterate' f (f x) in head . drop 1000000 $ iterate' succ 0
02:35:32 <lambdabot>   1000000
02:35:41 <Cale> It may actually disappear with strictness analysis, you've checked and it doesn't?
02:36:35 <Cale> Yeah, okay, it doesn't.
02:36:50 <Toxaris> Cale: but it is *not* strict
02:38:02 <Toxaris> (or is it? depends on what you do with the head, maybe)
02:38:09 <Cale> So, the instance of Enum for Integer is more clever. It knows that addition for Integer values is strict and the cost is negligible (at least for small values), and makes use of that, forcing the elements of the list as the spine is traversed.
02:38:19 <Cale> Toxaris: Well, we're printing it :)
02:38:44 <Aune> Is it true that   Aut(Cn * Cm) is isomorpic to Aut(Cn)*Aut(Cm) where * is the direct product and Cn, Cm is a cyclic groups of prime order?
02:39:21 <Cale> Aune: yes
02:39:35 <Cale> Aune: Actually you just need that n and m are coprime to each other
02:39:42 <Cale> (that is, they have gcd of 1)
02:39:53 <Cale> Aune: This is called the Chinese Remainder Theorem
02:40:06 <Aune> Oooh, nice. Thanks a lot
02:40:11 <Cale> Er, wait, I missed your Auts.
02:40:28 <Cale> (I just woke up)
02:40:34 <Cale> I'll have to think a little more now :)
02:40:48 <Aune> Ok
02:40:49 <Cale> C_n x C_m is isomorphic to C_(nm)
02:40:53 <Cale> Is the CRT
02:41:47 <ksf> :t max
02:41:48 <lambdabot> forall a. (Ord a) => a -> a -> a
02:41:58 <ksf> hey cool I can max pointers.
02:43:25 <Jafet> @instances Ord
02:43:26 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), (a, b, c, d, e), All, Any, Bool, Char, Double, Dual a, Either a b, First a, Float, Int, Integer, Last a, Maybe a, Ordering, Product a, Sum a, [a]
02:44:15 <Cale> Aune: Okay... I think it fails. Let's see if I can contstruct a minimal example...
02:44:20 <Aune> Cale: ok, but my problem is that I need to classify Aut(C7*C11). I want to do this by breaking it apart and studying its parts. But that only works if the above statement is true. Am I doing it wrong?
02:44:44 <ksf> lambdabot doesn't import anything dealing with IO, which includes Foreign.*
02:47:35 <Toxaris> > head . drop 1000000 . foldr (liftM2 (.) seq (:)) [] . iterate succ $ 0 -- no need to define your own versions of prelude functions
02:47:37 <lambdabot>   1000000
02:47:51 <Saizan> which is a shame, there's no need not to
02:50:08 <Cale> Aune: Actually, maybe it does work. I was confused for a moment there.
02:51:36 <Cale> Aune: It certainly works in your specific case, Aut(C7 x C11) is isomorphic to (C2 x C3) x (C5 x C2) is isomorphic to C6 x C10 which is iso to Aut(C7) x Aut(C11)
02:51:55 <Aune> It would be awesome if it did. But I am not able to prove it myself.
02:53:41 <medfly> hi cale
02:54:28 <Cale> medfly: hello :)
02:55:37 <Cale> Aune: Yeah, hmm. Wikipedia claims that it's true that if a finite Abelian group G splits as a direct sum of subgroups H and K of coprime order, then Aut(G) ~= Aut(H) x Aut(K)
02:55:46 <Cale> (But it doesn't say why)
02:57:28 <Aune> If we consider F in Aut(A*B) and A*B is a cyclic group then F is uniquely determined by the image F(1) since A*B is generated by 1.
02:58:00 <Cale> Oh, yeah, of course. There, you're done ;)
02:58:30 <Cale> (You don't need the more general result.)
02:58:33 <Aune> I hate proving things, I never know when Im actually there
02:58:50 <kmc> ksf, lambdabot imports plenty of IO stuff
02:58:56 <kmc> it will even evaluate IO actions for you
02:58:57 <Cale> C_7 x C_11 is of course isomorphic to C_(7 x 11) by the CRT
02:58:58 <kmc> just won't execute them
02:59:03 <Cale> and so it's cyclic
03:00:37 <Cale> and so every automorphism is an inner one
03:00:53 <Cale> errr
03:00:57 <Cale> no
03:01:13 <Cale> We just want what you said, that it's determined by F(1)
03:01:28 <Cale> Or F(a) where a is a generator
03:02:23 <Cale> This is what shows that the map Aut(C_7) x Aut(C_11) -> Aut(C_7 x C_11) which sends (f,g) to (x,y) |-> (f(x), g(y))
03:02:32 <Cale> is actually surjective
03:02:59 <Aune> yeah, and so Aut(Cm) is isomorphic to Cn where n is the number of p < m | p,m coprime
03:03:56 <Cale> That doesn't ring true... that's the right number of elements...
03:04:17 <Cale> Aut(C_m) is isomorphic to the multiplicative group of units modulo m
03:08:56 <Cale> If it were true that that was always cyclic, then there would always be a primitive root modulo m, but that only happens when n is equal to 1, 2, 4, p^k or 2 p^k, where p is an odd prime.
03:10:01 <Cale> (when m is ...)
03:10:18 <Cale> But we don't really care about that ;)
03:10:41 <Aune> It takes a while to wrap my head around this
03:11:02 <Cale> We can take any pair of automorphisms on two groups separately, and lift it up to an automorphism on their direct product
03:11:40 <Cale> and we really ought to show that this is a homomorphism of groups... (is it?)
03:12:29 <Aune> Well, yes.
03:12:32 <Cale> yep
03:12:57 <Cale> Moreover it's injective (always)
03:13:25 <Aune> true
03:13:58 <Aune> So when is it surjective?
03:14:04 <Cale> So we only need to show that it's surjective in our specific case of Aut(C_p) x Aut(C_q) where p and q are distinct primes.
03:14:46 <Cale> actually, I'm pretty sure it works for Aut(C_n) x Aut(C_m) where n and m are coprime
03:14:56 <Cale> Let's do that :)
03:15:09 <Cale> That's the assumption that we really need.
03:15:09 <Aune> Ok
03:15:54 <Cale> So elements f of Aut(C_n x C_m) are determined by f(1,1) (where 1 is a generator for the respective group)
03:16:19 <Aune> True
03:16:23 <Cale> This is because C_n x C_m is a cyclic group isomorphic to C_nm with generator (1,1)
03:17:06 <guest2425> Hello
03:17:13 <guest2425> someone here
03:17:15 <guest2425> ????
03:17:18 <Zao> guest2425: Depends.
03:17:32 <guest2425> Zao: Today while getting dressed, i realized that my underwear had pockets. I'm still confused. 
03:17:49 <Aune> Yes
03:18:38 <guest2425> Zao: so what u think
03:19:38 <Aune> Cale: I dont see where to go from there
03:19:51 <Cale> Aune: We know from lifting the automorphisms from C_n and C_m separately, that we can get f(1,1) = (x,y) where x and y are any particular non-identity elements.
03:19:59 <Cale> (that is, both not 0)
03:20:07 <Aune> yes
03:20:19 <Cale> Aune: If one of them were 0, then would f be an automorphism?
03:21:05 <Aune> no, it would only be a homomorphism
03:21:09 <Cale> right
03:21:17 <Cale> and so those are the only possibilities
03:21:30 <Aune> Oh, nice.
03:21:53 <Cale> and the map Phi: Aut(C_n) x Aut(C_m) -> Aut(C_n x C_m) is in this case actually surjective and not just injective
03:22:16 <Aune> So bijective and thus an isomorphism
03:22:19 <Eduard_Munteanu> Looks like he told us what was on his mind and went away.
03:22:20 <Cale> right
03:23:15 <Aune> This was awesome, now Im going to sit down and go through all the details on paper to make sure that I understand it correctly
03:23:23 <Cale> cool :)
03:24:04 <Aune> So I might be back with questions later
04:43:14 <diPython> hi
04:43:54 <diPython> i'm having a problem upgrading time through cabal
04:44:00 <diPython> it's basically giving me
04:44:00 <diPython> cabal: Error: some packages failed to install:
04:44:01 <diPython> time-1.2.0.3 failed during the configure step. The exception was:
04:44:09 <diPython> ExitFailure 11
04:44:15 <diPython> any ideas?
04:45:16 <dcoutts> diPython: perhaps segfault, signal 11 is segfault
04:46:44 <diPython> i run it this because i'm trying to install uulib, and it's giving me
04:46:46 <diPython> Bad interface file: /Users/mabs/.cabal/lib/haskell98-1.1.0.0/ghc-6.12.3/Monad.hi
04:46:46 <diPython>         Something is amiss; requested module  haskell98:Monad differs from name found in the interface file haskell98-1.1.0.0:Monad
04:46:46 <diPython> cabal: Error: some packages failed to install:
04:46:46 <diPython> uulib-0.9.12 failed during the building phase. The exception was:
04:46:46 <diPython> ExitFailure 1
04:47:37 <dcoutts> diPython: don't re-install the haskell98 package, that's a bad idea
04:48:07 <diPython> why?
04:48:09 <dcoutts> I suggest you get rid of the haskell98-1.1.0.0 instance from your per-user package db
04:54:45 <jkff> Hi #haskell. I accidentally came up with this http://hpaste.org/41642/lazy_split and I wonder, is it useful for anything? Maybe for some very lazy kind of very special merge sort? :)
04:58:11 <aristid> @src first
04:58:11 <lambdabot> Source not found. Sorry.
04:59:51 <merijn> @src fst
04:59:51 <lambdabot> fst (x,_) =  x
05:01:12 <Saizan> jkff: might be, but merge sort is usually done bottom up :)
05:05:19 <jkff> Saizan: Yeah, I know :) It's just that I'm reading Bird's "pearls of functional algorithm design" and he uses quite frequently things like "let mid = length xs `div` 2; (as,bs) = splitAt mid xs"
05:07:03 <Saizan> jkff: yeah, that feels wrong :)
05:12:50 <bsod1> I can't define a function in ghci, it says <interactive>:1:11: parse error on input `='
05:13:01 <bsod1> but when I define this function in a seperate file and the load from ghci, it works
05:14:00 <Botje> bsod1: in ghci you have to do "let f x = x" instead of just "f x = x"
05:14:01 <Zao> bsod1: You can use let in ghci.
05:14:57 <bsod1> k thanks, and how can I compile and run a haskell script with one key in vim?
05:18:32 <hpc> ...vim isn't an ide
05:18:43 <hpc> you can have ghci open in another terminal though
05:18:46 <hpc> edit the file you want
05:18:48 <pkrumins> vim is an operating system
05:18:50 <hpc> and in ghci, :r
05:19:02 <pkrumins> with everything except emacs :(
05:21:36 <koala_man> bsod1: :nmap <F9> :!ghc --make % -o lol && ./lol<CR>
05:24:07 <aristid> pkrumins: emacs in turn is an operating system, with everything INCLUDING vim
05:24:39 <MasseR> I do, :noremap <F6> :!ghci %
05:25:02 <hpc> i bind the menu key to terminal :P
05:26:13 <Eduard_Munteanu> Or if you use xmonad it should be pretty simple to keep two terminals around and mod+j/k around
05:33:50 <kaf3ii> is there a 'oneline' way of makeing a 'cat' program with 'readFile', 'doesFileExist' and 'getArgs' ? 
05:34:50 <mm_freak> kaf3ii: you can write every haskell program in one line, but that's probably not what you're asking for
05:34:58 <mm_freak> it's possible in four beautiful lines
05:35:20 * hpc suggests you write it out longhand and @pl
05:35:53 <mm_freak> do args <- getArgs; case args of [] -> getContents >>= putStr; files -> mapM_ (readFile >=> putStr) files
05:35:56 <mm_freak> something like that
05:36:38 <kaf3ii> mm_freak: ok.. thx =)
05:36:38 <Cale> getContents >>= putStr = interact id
05:36:59 <mm_freak> Cale: true, but somehow i prefer the other variant
05:37:19 <kaf3ii> semicolons kinda ruins my point =/
05:37:31 <mm_freak> kaf3ii: why?
05:37:39 <hpc> if you don't need the interactive part, it becomes much nicer
05:37:51 <hpc> getArgs =>> mapM_ (readFile >=> putStr)
05:37:57 <hpc> er
05:38:03 <hpc> getArgs >>= mapM_ (readFile >=> putStr)
05:38:05 <kaf3ii> mm_freak: sure its 'oneline', but semicolons do split up the line ? 
05:38:17 <mm_freak> kaf3ii: no
05:38:46 <mm_freak> kaf3ii: besides layout syntax, a "line" has no meaning in haskell
05:39:19 <mm_freak> in fact, semicolons are the only way to get a single line 'case'
05:39:25 <mm_freak> at least with multiple patterns
05:39:26 <hpc> a "line" of do block desugars to nested lambdas
05:39:59 <hpc> in this case, you can dodge the case using "when" and "unless"
05:40:02 <mm_freak> you might want to use 'if' and monadic combinators instead to get rid of semicolons, if they bother you
05:40:26 <mm_freak> but you will get the same thing, just uglier looking (YMMV)
05:40:30 <hpc> and you can @undo the block to get rid of semicolons
05:41:09 <Twey> Hmph
05:42:26 <Twey> list def _ [] = def; list _ f (x : xs) = f x xs
05:43:55 <Twey> getArgs >>= list (getContents >>= putStr) (fmap (mapM_ $ readFile >=> putStr) . (:))
05:46:29 <Twey> infix 2 `list`; getArgs >>= fmap return getContents `list` fmap (mapM_ readFile) . (:) >>= mapM_ putStr
05:47:30 <Jafet> Is that fixity declaration even legal
05:47:53 <Twey> No
05:48:04 <Twey> It was meant to go with the ‘list’ definition
05:48:13 <Twey> But it was an afterthought, so :þ
05:48:22 <Jafet> Well, is it legal when put there?
05:48:26 <Twey> I think so
05:49:20 <Jafet> Should it be illegal for one to use it for obfuscation?
05:49:29 <Twey> Yep, works for me
05:49:44 <Twey> Errr, possibly.  Do you see obfuscation here?  :þ
05:50:49 <hpc> i see pointlessness, which is just as bad :P
05:51:41 <Jafet> Change the precedence of a monad transformer, and see if your code still typechecks
05:52:07 <Twey> I'm allowed to change the precedence of a function I just defined >.>
05:52:12 <hpc> haha
05:52:23 <hpc> Jafet: change the fixity of (>>=) :D
05:52:34 <Jafet> (If it doesn't, it wasn't abstract enough!)
05:56:02 <onteria> hmm, snapframework's homepage is 500'ing
06:00:32 <rovar> newb question here:   I am working through the exercises on typeclassopedia. I need to create a functor for (->) e   
06:01:31 <rovar> i had assumed the result would be  something like    fmap  g a = a . g    
06:01:57 <rovar> where I apply the function to the 2nd parameter of the function then pass it  in
06:02:01 <ski> what are the types of `g' and `a', there ?
06:02:30 <rovar> g would be  (a -> b) 
06:02:42 <rovar> and a  is ((->) e) 
06:03:10 <rovar> so it should actually end up being    (e -> b)   if i understand this
06:03:19 <Nibble> hmm
06:03:28 <Toxaris> rovar: but ((->) e) is not a proper type, it has kind * -> *
06:03:37 <rovar> but maybe I can't know that before this
06:04:10 <rovar> Toxaris,  so it's a type constructor
06:04:16 <Toxaris> rovar: yes
06:04:22 <ski>   fmap :: (a -> b) -> (f a -> f b)
06:04:29 <ski> so, `g :: a -> b', yes
06:04:39 <ski> and `a :: f a'
06:04:40 <Nibble> if I have a data type using record syntax, is there any way I can like inherit it in another data type
06:04:54 <ski> in your case `f' is `(->) e', so that makes the type of `a' into ?
06:05:06 <rovar> Nibble,  you can aggregate it into another data type :) 
06:05:13 <Nibble> aggregate?
06:05:18 <rovar> compose
06:05:18 <Toxaris> Nibble: you can just use it in the definition of that other type
06:05:26 <hpc> data Record = Record {someField :: Int, someName :: String}; data Nested = Nested {record :: Record, foo :: Foo}
06:05:34 <hpc> Nibble: ^ ?
06:05:38 <ski> rovar : and yes, the result type is `f b', which becomes `((->) e) b', i.e. `(->) e b', i.e. `e -> b'
06:05:39 <Nibble> ah
06:05:45 <Nibble> so using it would be something like this
06:06:17 <hpc> there's no inheritance, but it is contained in the other data type
06:06:18 <Nibble> someField (record var)
06:06:28 <hpc> as far as i know, inheritance is impossible/very damn hard
06:06:32 <Toxaris> Nibble: Yes
06:07:15 <rovar> i think I saw somewhere where someone did embedded record auto forwarding with templates.. but I can't find it now
06:07:34 <rovar> so it pretended to be inheritance, much like go
06:08:09 <rovar> ski, okay.. so my assumption about the resulting type was correct.. but i'm obviously missing something.. 
06:08:16 <hpc> you can fake inheritance with "action records"
06:08:37 <hpc> like data Graphics = Graphics {paint :: IO (), swapBuffers :: IO (), ...}
06:08:42 <Toxaris> rovar: so what's the type of fmap in your functor instance?
06:09:30 <ski> rovar : what is the type of `a' ?
06:09:32 <rovar> well.. it needs to be  (a -> b) -> f a -> f b.. so I guess it's not :)
06:10:15 <ski> rovar : and if you replace `f' by `(->) e' in that ?
06:11:27 <Toxaris> hpc: with such "action records" (I would call them "objects"), you have late binding, but no inheritance or prototyping
06:11:31 <rovar> (a -> b) -> (e -> a) -> (e -> b) 
06:13:18 <Toxaris> rovar: yes. and now you can try to implement that function
06:13:37 <kosmikus> :t \ g a -> a . g
06:13:38 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> (a -> b) -> f b
06:13:47 <kosmikus> grr
06:13:51 <Toxaris> :)
06:14:36 <kosmikus> :t let (f . g) x = f (g x) in \ g a -> a . g
06:14:37 <lambdabot> forall t t1 t2. (t2 -> t) -> (t -> t1) -> t2 -> t1
06:14:59 <Twey> :t (Prelude..)
06:15:00 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
06:15:07 <Twey> :t flip (Prelude..)
06:15:08 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
06:15:08 <kosmikus> ah, thanks
06:16:10 <Toxaris> rovar: you take two functions and return a function: fmap f g = \x -> ...
06:16:51 <rovar> Toxaris, that's what i've got so far
06:16:52 <hpc> Toxaris: ah
06:17:00 <Toxaris> rovar: now we want to apply both f and g to something, and the only thing we have is x. So we look at the types and figure which of (f x) or (f g) is type correct
06:17:23 <Toxaris> rovar: and then we keep doing that until we have a type-correct result :)
06:17:30 <Toxaris> rovar: its programming by searching :)
06:18:21 <Toxaris> hpc: the hard thing about objects is that you can interact with one part of an object without knowing about its other parts
06:18:32 <rovar> i understand being able to apply f  (a -> b)  to the result of g (e -> a)  but I don't understand how I could meaningfully construct the function e -> b
06:19:10 <Toxaris> rovar: well, to construct a function, you use a lambda expression
06:19:49 <Toxaris> rovar: and before you can apply f to the result of applying g to something, you need that something, so the lambda will come in handy to get a something into scope
06:20:36 <rovar> right.. 
06:20:52 <rovar> i need to pass the result of  e -> a  to  a -> b
06:21:01 <litb> flip f a b is    f b a  
06:21:08 <rovar> but I thought that was  just    f . g
06:21:31 <Toxaris> hpc: but in Haskell, we usually know either nothing or everything about a type. So to model OO, we need to use polymorphism to model this "partly knowing"
06:21:49 <Toxaris> rovar: yes it is
06:21:51 <litb> rovar: yes that is just   f . g
06:22:04 <rovar> or  \x -> f (g x) 
06:22:14 <Toxaris> rovar: but you had (g . f) in your original code
06:22:17 <litb> yes that is correct
06:22:19 <rovar> did I?
06:22:22 <rovar> meh
06:22:26 <litb> @pl \x -> f $ g x
06:22:26 <lambdabot> f . g
06:22:41 <rovar> you're right
06:22:44 <rovar> it compiles now
06:23:27 <Jafet> :t (<<<)
06:23:28 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
06:23:40 <rovar> thanks for your help.. it was obvious that i needed to work through that a bit more
06:23:49 <rovar> :t (fmap fmap fmap)
06:23:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:24:03 <rovar> :t (***)
06:24:04 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:25:13 <litb> fmap == map 
06:27:21 <Toxaris> @type ((<$>) . (<$>)) -- greedy eyes combinator
06:27:22 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
06:27:38 <litb> @instance Functor
06:27:39 <lambdabot> Maybe you meant: instances instances-importing
06:27:42 <hpc> :t (<$> $ <$>)
06:27:43 <lambdabot> parse error on input `$'
06:27:47 <litb> hm
06:27:54 <litb> @src Functor
06:27:55 <lambdabot> class  Functor f  where
06:27:55 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
06:27:55 <hpc> :t (<$>) $ (<$>)
06:27:56 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => f (a -> b) -> f (f1 a -> f1 b)
06:27:59 <litb> oh
06:28:06 <Toxaris> @type ((<$>) <*> (<$>)) -- a version with bigger nose
06:28:06 <lambdabot> forall b (f :: * -> *). (Functor f) => (f b -> b) -> f (f b) -> b
06:28:10 <litb> that's all?
06:29:04 <zygoloid> > ((<$>) <*> (<$>)) sum [[1,2,3],[4,5,6]]
06:29:05 <lambdabot>   21
06:30:07 <hpc> whoa, that's one funky type
06:30:16 <hpc> (for functor, at least)
06:30:23 <Toxaris> zygoloid: cool, its actually useful
06:30:32 <litb> lol
06:31:02 <litb> why does Functor only define "fmap" ? what makes it special
06:31:12 <dixie> @babel uk de Time
06:31:12 <lambdabot> Plugin `babel' failed with: Error: Language uk not supported
06:31:19 <dixie> @babel en de Time
06:31:19 <lambdabot> Plugin `babel' failed with: Prelude.head: empty list
06:31:20 <litb> Zeit
06:31:31 <Toxaris> litb: more special than what for example?
06:31:36 <litb> Timeghost == Zeitgeist
06:31:53 <litb> Toxaris: than other functions?
06:32:01 <litb> why aren't other functions in Functor ?
06:32:11 <hpc> Zeitgeist ~~ Zeitgeist (i have heard the term used unironically in english)
06:32:14 <Toxaris> litb: because Functor is the type class of types which supports fmap :)
06:32:24 <litb> hmm
06:32:39 <p-p-s> All a functor is is a mapping from one type to another
06:32:40 <litb> "Functor" sounds like "something that is a function"
06:32:40 <applicative> litb, well the constructor already moves the types to other types, in say Maybe a ,
06:32:41 <hpc> applicative only defines <*>
06:32:43 <hpc> :P
06:32:49 <litb> ohh
06:33:05 <quicksilver> litb: that's how some C++ libraries use the term but it's not what it means in category theory or haskell.
06:33:05 <applicative> litb, so fmap moves the functions a -> b to fucntions  Maybe a -> Maybe b too
06:33:15 <Toxaris> @type pure -- and that one, hpc
06:33:16 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
06:33:42 <litb> every parameterized data can be made an instance of Functor, it seems?
06:34:05 <Toxaris> litb: no.
06:34:12 <quicksilver> if they're well-behaved, in some sense.
06:34:26 <Toxaris> data Foo a = Foo (a -> a) 
06:34:34 <quicksilver> parameterized data types which 'contain' members of the parameter type will normally be members of functor.
06:36:14 <litb> i mean if we do   data Foo a = Bar a | Baz a   then we can say  instance Functor Foo  where fmap f Bar a -> Baz b = Baz (f a)
06:36:20 <applicative> instance Functor Foo where fmap f (Foo fun) = Foo id    Not too exciting, does it break a law, like composition
06:36:42 <litb> ohh i think i have a bug
06:36:54 <litb> i mean to say  instance Functor Foo  where fmap f Bar a = Baz (f a)
06:37:34 <litb> so   Foo is a functor that when applied to functions transforms a Bar into a Baz ?
06:37:56 <Toxaris> litb: but every functor instance needs to adhere to two laws
06:38:02 <Toxaris> litb: fmap id = id
06:38:12 <applicative> fails that one...
06:38:13 <quicksilver> applicative: yes, because fmap id is not id.
06:38:23 <Toxaris> litb: and   fmap (f . g) = fmap f . fmap g
06:38:48 <litb> ah i guess those are semantic constraiints. if violated, behavior is undefined?
06:38:50 <Toxaris> litb: in effect (and cool enough), that means: a Functor may not do crazy things.
06:39:29 <Toxaris> litb: Well, these are like invariants attached to "class Functor": A writer of "instance Functor ..." is supposed to make sure that are kept, and every user of fmap is entitled to believe them
06:39:30 <litb> oh then my functor instance was not actually a functor instance :/
06:40:27 <litb> i take it that [a] is a functor instance most probably
06:40:42 <Toxaris> applicative: I guess you are right. Not too exciting.
06:40:59 <Toxaris> litb: yes. and what would fmap be for [a]?
06:41:23 <Aune> Cale: You there?
06:41:56 <Aune> I have a new question:
06:42:12 <litb> instance Functor [a] where fmap f = map f
06:42:31 <litb> ah haven't checked whether it suffices the  fmap (f . g) rule -.-
06:42:59 <litb> also, fmap = map should suffice i think?
06:43:03 <Aune> How do I show that in a if H normal subgroup in G and G cyclic then there exist a subgroup of G isomorphic to G/H?
06:43:26 <Toxaris> litb: yes and yes, and you are lucky: the rule holds
06:43:27 <litb> yes   map should suffice  the (f . g) rule just fine
06:43:32 <applicative> Aune easy look it up in Lang
06:43:34 <zygoloid> "fmap (f . g) = fmap f . fmap g" is a free theorem
06:43:35 <litb> lol
06:43:58 <zygoloid> )once you know fmap id = id)
06:43:59 <litb> lol
06:44:23 <Toxaris> @type fmap
06:44:24 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
06:44:30 <Aune> Thanks, I'll go look for it in the library
06:45:22 <Toxaris> zygoloid: why?
06:45:31 <litb> are there more funky instances than lists and Maybe  ?
06:46:59 <litb> s,funky,Functor,
06:47:00 <litb> o_O
06:47:10 <zygoloid> Toxaris: fmap id = id means fmap preserves the structure in some sense. the rest is just normal free-theroems stuff due to parametricity.
06:47:33 <Toxaris> @instances Functor
06:47:34 <lambdabot> ((,) a), ((->) r), Cont r, ContT r m, Either a, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
06:47:41 <litb> free-theorems? does that means a theorem arbitrarily enforced?
06:47:54 <zygoloid> basically fmap id = id means fmap works pointwise on the "contained" values, in some sense
06:47:59 <litb> wow that's crazy!
06:48:50 <zygoloid> and parametricity means that the action on each point is either const undefined or applying f. proving all this is /tricky/.
06:48:57 <Toxaris> litb: free-theorems means that given the type of a function, you can conclude something about the function's behavior. and since there is one big proof that this method always works, you need no small proofs if you apply it, and there you are: a free theorem
06:48:58 <litb> ((,) a) must be the merriage operator
06:49:37 <Jafet> @djinn a -> (a -> b) -> b
06:49:37 <lambdabot> f a b = b a
06:49:45 <litb> oh
06:50:11 <Toxaris> @. pl djinn a -> (a -> b) -> b
06:50:12 <lambdabot> f = flip id
06:50:17 * Toxaris likes @.
06:50:38 <applicative> Aune, just kidding about Lang, but that's the material of Ch. 1, sections 3 and 4  ...
06:50:39 <merijn> Is lambdabot's quote database online somewhere?
06:50:45 <litb> djinn is a free theorem monkey?
06:50:55 <Toxaris> litb: No.
06:51:07 <Botje> @where quoets
06:51:07 <lambdabot> I know nothing about quoets.
06:51:09 <Botje> @where quotes
06:51:10 <lambdabot> I know nothing about quotes.
06:51:10 <litb> it seems to have concluded what the function does based on its type
06:51:12 <Botje> boo.
06:51:20 <Toxaris> litb: djinn gives you *one* possible implementation of a type, but free theorems tell you something which holds for *all* possible implementations
06:51:25 <Botje> @where source
06:51:25 <lambdabot> I know nothing about source.
06:51:28 <Botje> stupid \bot
06:51:30 <Toxaris> @djinn (a, a) -> a
06:51:31 <lambdabot> f (a, _) = a
06:51:31 <litb> oh
06:51:32 <ziman> @. pl djinn (((a -> b) -> c) -> d) -> a -> b -> c -> d
06:51:32 <lambdabot> f = const . const . (. const)
06:51:36 <applicative> that's what a free theorem is like, right
06:51:40 <zygoloid> Toxaris: another way of getting the same result:
06:51:44 <zygoloid> @free fmap :: (a -> b) -> (F a -> F b)
06:51:44 <lambdabot> g . h = k . f => $map_F g . fmap h = fmap k . $map_F f
06:52:08 <Botje> merijn: http://code.haskell.org/lambdabot/State/quote
06:52:10 <zygoloid> ^^ here $map_F is the real functorial map for F. now let k = g, h = f = id.
06:52:13 <litb> i see now. it's like a meta constraint
06:52:29 <litb> but something which is really redundant
06:52:40 <applicative> litb, well, its not a constraint, it follows from the type.  
06:52:49 <litb> i see
06:52:54 <zygoloid> then we see $map_F g . fmap id = fmap g . $map_F id. so if fmap id = id then $map_F g = fmap g. so there's a unique fmap with fmap id = id.
06:52:56 <applicative> @djinn a -> a
06:52:56 <lambdabot> f a = a
06:53:13 <merijn> Botje: Awesome, my productivity is now officially shot to hell :p
06:53:17 <applicative> not much info
06:54:15 <merijn> Botje: And which format would that file be? >.>
06:54:32 <Botje> it should be plaintext
06:54:37 <Botje> isn't it? :(
06:54:50 <merijn> Well, it might be but then it's not UTF-8 :p
06:54:54 <Botje> ah, it's gzipped
06:54:57 <Botje> gunzip it first :p
06:55:23 <Toxaris> zygoloid: cool. Thanks.
06:56:01 <litb> @. pl djinn a b -> a
06:56:02 <lambdabot> Error : kind error : (KVar 0, KStar)
06:56:12 <litb> i hoped this would give "const"
06:56:31 <Toxaris> @. pl djinn a -> b -> a
06:56:31 <lambdabot> f = const
06:56:35 <litb> what is that weird "kind error"
06:56:40 <Toxaris> litb: you missed an "->"
06:56:40 <litb> oh
06:56:49 <Toxaris> litb: so you the type constructor a applied to b
06:57:04 <Toxaris> litb: but then a occured on its own on the right-hand side of the arrow 
06:57:19 <litb> i see
06:57:32 <litb> can type constructors not be curried?
06:57:32 <Toxaris> litb: so djinn figured that a has to be both a type constructor of kind (* -> *), and a proper type of kind *, and these do not match
06:57:41 <litb> liek it would return an  a that can be applied to a type ?
06:58:01 <Toxaris> litb: *type* functions can do that, but not usual *value* functions
06:58:07 <litb> ohh
06:58:25 <Toxaris> litb: because Haskell is not dependently typed
06:58:34 <litb> i see
06:58:43 <litb> can template haskell do that?
06:59:11 <Toxaris> you can have a TH macro which takes an expressions and produces a type (or a type constructor)
06:59:18 <merijn> I don't think template haskell is dependently typed
06:59:20 <applicative> merijn, my os wouldn't open the gunzipped file either but I could do cat to it, don't know why
06:59:20 <roconnor> the answer is yes template Haskell can do that.
06:59:35 <roconnor> wait, what's the question?
06:59:36 <merijn> applicative: Had to rename it to quote.gz then it worked
06:59:45 <Toxaris> but you need to use that TH macro in a position where a type (or type constructor, or whatever it produces) can occur
07:00:46 <applicative> merijn i see, mine recognized it as gz. Its OS X they probably got involved somehow to protect me....
07:01:04 <Toxaris> litb: so that's staging (expressions are evaluated at compile time to produce part of the program), but not dependent types (types can depend on values, including values not yet known)
07:01:16 <merijn> applicative: I'm on OSX here too, but I generally do everything (minus epsilon) in Terminal.app anyway :p
07:01:42 <ziman> @type let in let wtf (In wft) = In wtf in wtf
07:01:43 <lambdabot> forall (t :: * -> *). Mu t -> Mu ((->) (Mu t))
07:02:05 <applicative> merijn, yeah, but I downloaded it from the browser, which asked me if I wanted to decompress. 
07:06:55 <ziman> merijn, mine too, sigh.
07:07:37 <litb> "let in" ? is that a noop declaration ?
07:08:00 <applicative> > let in 1 + 1
07:08:00 <lambdabot>   2
07:08:14 <litb> Toxaries: i see now
07:08:21 <litb> Toxaris*
07:09:16 * hackagebot uni-util 2.2.1.0 - Utilities for the uniform workbench  http://hackage.haskell.org/package/uni-util-2.2.1.0 (ChristianMaeder)
07:09:31 <ziman> > let { fix f = fix where fix = f fix } in fix (\f n -> if (n == 0) then 1 else n * f (n-1)) 6
07:09:32 <lambdabot>   720
07:10:32 <applicative> > let in "the light"
07:10:32 <lambdabot>   "the light"
07:10:52 <litb> ohh i havent known you can write  let { ... }
07:11:06 <litb> but that's just for clarity i guess?
07:11:16 * hackagebot uni-events 2.2.1.0 - Event handling for the uniform workbench  http://hackage.haskell.org/package/uni-events-2.2.1.0 (ChristianMaeder)
07:11:32 <zygoloid> > let in the light
07:11:33 <lambdabot>   light
07:11:47 <sipa> :t the
07:11:48 <lambdabot> forall a. a -> a
07:11:52 <Cale> Aune: Still around?
07:12:09 <litb> :t light
07:12:10 <lambdabot> forall a. Sym a
07:12:13 <litb> hmm weird
07:12:17 * hackagebot uni-reactor 2.2.1.0 - Reactors for the uniform workbench  http://hackage.haskell.org/package/uni-reactor-2.2.1.0 (ChristianMaeder)
07:12:29 <litb> :t doesitworkforeverything
07:12:30 <lambdabot> Not in scope: `doesitworkforeverything'
07:12:45 <litb> why is light and the defined? do they something useful?
07:12:55 <merijn> @src light
07:12:55 <lambdabot> Source not found. The more you drive -- the dumber you get.
07:12:59 <merijn> hmm
07:13:04 <Cale> litb: Probably someone defined them
07:13:10 <litb> ohh
07:13:17 * hackagebot uni-posixutil 2.2.1.0 - Posix utilities for the uniform workbench  http://hackage.haskell.org/package/uni-posixutil-2.2.1.0 (ChristianMaeder)
07:13:17 <litb> ¹src Sym
07:13:20 <litb> @src Sym
07:13:20 <lambdabot> Source not found. Maybe if you used more than just two fingers...
07:13:27 <litb> seems like a Sym 
07:14:19 * hackagebot uni-htk 2.2.1.0 - Graphical User Interface for Haskell Programs  http://hackage.haskell.org/package/uni-htk-2.2.1.0 (ChristianMaeder)
07:14:21 * hackagebot uni-graphs 2.2.1.0 - Graphs  http://hackage.haskell.org/package/uni-graphs-2.2.1.0 (ChristianMaeder)
07:14:48 <ziman> litb, you can use @let to define symbols in lambdabot's query; you can use all other services like @pl and @quote there as well, if they would be too flooding here.
07:15:26 <zygoloid> > ap (the fmap) (+5) (*3) 3
07:15:27 <lambdabot>   42
07:15:52 <Aune> Cale: yes, now
07:17:12 <Aune> I found the "fundamental theorem for cyclic groups" and that seems to make the problem easy to solve. Just need to see if I can manage to put the pieces together
07:17:14 <litb> ziman: ohh i see now!
07:17:19 <Cale> Aune: okay, great
07:17:24 <litb> i had no idea
07:17:53 <litb> who created lambdabot?
07:19:41 <Cale> litb: A collection of people. I think Pseudonym was the initial guy. dons maintained it for a long time
07:19:52 <roconnor> litb: lambdabot mysteriously appeared on #haskell 25,000 years ago.  She says she was created at the end of time by herself.
07:19:52 <ziman> Cale is her current master, afaik :)
07:19:52 <Cale> (and did a lot of restructuring)
07:19:53 <litb> oh
07:20:01 <aristid> and Cale is responsible for (.) being fmap
07:20:05 <aristid> in lambdabot
07:20:06 <Cale> I am not the current maintainer of lambdabot, but I run it.
07:20:27 <Cale> lispy provides the hosting
07:21:07 <Cale> Gwern could probably be considered the maintainer.
07:21:27 <merijn> Cale: The lambdabot quote file suggests you exceed the witty threshold for mathematicians and should probably hand in your math license :>
07:21:27 <litb> now i'm confused. you run it, lispy hosts ir and gwern maintains it?
07:21:43 <litb> what constitutes "running it" 
07:21:50 <Cale> merijn: What do you mean?
07:22:21 <litb> oh god i think i know now. you execute all its requests. haha
07:22:38 <applicative> > vcat . map text $ take 3 cake
07:22:39 <lambdabot>   One 18.25 ounce package chocolate cake mix.
07:22:39 <lambdabot>  One can prepared coconut pecan...
07:22:56 <sipa> > cake
07:22:57 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
07:22:59 <Cale> litb: When it goes down, I log into lispy's machine and make sure that it comes back up again.
07:23:42 <Cale> (It's running in my user account there)
07:24:14 <merijn> Cale: I mean that it A) has quite a large amount of quotes attributed to you and B) the wittiness of said quotes exceeds the average by about 2 standard deviations :p
07:24:24 <Cale> haha
07:25:02 <applicative> > vcat . map text . take 2 $ reverse cake
07:25:03 <lambdabot>   That will deodorize and preserve putrid tissue.
07:25:03 <lambdabot>  And it contains proven pre...
07:26:19 <quicksilver> win 22
07:27:25 <aristid> <lambdabot> Plugin `more' failed with: thread killed
07:27:27 <aristid> haha
07:30:08 <applicative> @quote colour
07:30:08 <lambdabot> Conor says: So, taking Void to be the colour of the empty bikeshed ...
07:31:01 <applicative> @quote laptops
07:31:01 <lambdabot> Conor says: We could all sit in a long line with laptops, and talk to each other on #haskell
07:31:20 <roconnor> we totally need a floating point monad
07:31:33 <merijn> applicative: You can use @quote in PM to not spam the channel
07:31:52 <roconnor> which has the nice side effect of discouraging use of floating point numbers
07:32:29 <merijn> I once had a problem, so I though "I know, I'll use floating points!".
07:32:37 <merijn> Then I had 2.0000000000000026476 problems
07:32:57 <roconnor> :D
07:33:24 <megatron242> Hi - a quick noob question: How do I cast a variable of Nothing type to Int?
07:33:44 <merijn> megatron242: uh...you don't cast things in haskell
07:33:53 <merijn> megatron242: And converting Nothing to Int makes no sense
07:34:10 <byorgey> megatron242: do you mean you have something of type  Maybe Int  and you want an  Int ?
07:34:15 <megatron242> I mean, I'm dooing a lookup on a map, and I know that the result won
07:34:21 <megatron242> won't really be nothing
07:34:31 <Yvemath> i've installed xmonad application with cabal but i can't seem to "run" it. :( 
07:34:34 <merijn> megatron242: Use pattern matching
07:34:43 <megatron242> byorgey: yes
07:34:46 <Yvemath> I've $HOME/.cabal/bin inside ~/.profile but still.  
07:34:52 <merijn> Or Maybe monad I guess
07:34:59 <byorgey> megatron242:   case (lookup blah) of  Nothing -> error "o noes!"   Just x ->  ...
07:35:13 <byorgey> megatron242: you can also use the 'fromMaybe' function from Data.Maybe
07:35:25 <megatron242> thanks
07:35:26 <byorgey> megatron242: there is also 'fromJust' but I do not recommend using it
07:35:47 <byorgey> because in the case that you ever do get a Nothing (because of a bug, say) you will just get a generic error message
07:36:13 <byorgey> but if you really believe it can never be Nothing, then at least you can use error to give a descriptive error message in case something ever does go wrong
07:36:48 <merijn> Also, I'm pretty sure LYAH covers this somewhere?
07:37:28 <megatron242> Also, I want to convert an algorithm to Haskell, that uses a lookup array. Is there a simple way to have a random access array in haskell (I'm using Map as an alternative, instead of having a O(1) data structure) ?
07:37:42 <byorgey> megatron242: you can use Data.Array
07:37:51 <applicative> merijn I was thinking they were especially memorable :)  ; we were exhibiting features to litb
07:38:12 <byorgey> megatron242: immutable arrays are nice for lookups
07:38:25 <maurer_> Warning: Data.Array has slow insertion. It's fine for write-once read many, but if you're going to write a lot, you're going to want something else.
07:38:31 <byorgey> megatron242: but if you need to be modifying the lookup table along the way I would stick with Data.Map
07:38:55 <maurer_> One thing I will frequently do is accumulate/build up a table using an IntMap or sommat, then flatten it to an Array and pass it to a function that does read only ops
07:39:00 <merijn> applicative: I like this one better
07:39:05 <merijn> @quote mathematicians
07:39:05 <lambdabot> <luqui> says: sigh: mathematicians.  can't live with 'em, can't prove 'em wrong.
07:39:53 <megatron242> How come, such a trivial thing (having a random access array) is complicated (in term of perfomance)?
07:40:09 <quicksilver> megatron242: "Just use a Map" is not complicated.
07:40:09 <byorgey> Yvemath: is there an 'xmonad' in $HOME/.cabal/bin ?  Does it work if you run it explicitly with the full path?
07:40:11 <maurer_> megatron242: Recall that previous versions of the array are accessible.
07:40:17 <merijn> megatron242: Because Haskell only has immutable variables
07:40:34 <Aune> Cale: Could you take a look at this argument: http://hpaste.org/41646/cyclic_groups
07:40:43 <megatron242> Map has O(LogN) complexity
07:40:44 <maurer_> megatron242: As a result, any implementation either requires fancy diffing (DiffArray), or full array copy on every insertion.
07:40:50 <quicksilver> megatron242: who cares.
07:40:55 <quicksilver> megatron242: O(logN) is fine.
07:41:05 <merijn> megatron242: IntMap has O(log k) with k length of an integers
07:41:06 <maurer_> megatron242: You are not google, ergo O(logN) \approx O(1) for you.
07:41:10 <maurer_> ;p
07:41:20 <megatron242> LOL
07:41:34 <quicksilver> megatron242: compiled haskell Maps are faster than the O(1) arrays in all those popular interpreted languages like python, perl, javascript, ruby, etc.
07:41:49 <maurer_> But in all seriousness, cut the premature optimization.
07:41:50 <megatron242> I come from C...
07:41:50 <mux> that's a pretty bold assumption
07:41:51 <merijn> megatron242: The reason mutable things are "hard" is that you're not changing a value in an array, you create a new array. However, because of this the compiler can be rather radical in optimizing your code which are simply impossible in C
07:41:58 <maurer_> I don't believe that Map is your bottleneck.
07:41:58 <applicative> Yvemath what OS are you using
07:42:02 <quicksilver> it's a real waste of time to obsess about such differences until you have proved that your solution is too slow for your needs.
07:42:03 <mux> as the number of elements increases, this is also likely to be wrong
07:42:23 <Yvemath> byorgey: Yes, there is a file. Not necessarily a binary one. but even if i am inside that directory i.e. ~/.cabal/bin and i run "xmonad" it doesnt.
07:42:35 <byorgey> Yvemath: what does it do instead?  Nothing?
07:42:46 <Yvemath> applicative: Arch Linux Linux Kernel 2.6.35
07:42:49 <maurer_> megatron242: If you can convince me you absolutely need a mutable array, I will explain to you how to get one. We do have them, but teaching beginners how to use them frequently causes them to think wrong.
07:42:54 <byorgey> Yvemath: and what do you mean "not necessarily a binary one"?
07:43:03 <Yvemath> byorgey: it shows, command not found.
07:43:24 <byorgey> Yvemath: did you type  './xmonad' ?
07:43:27 <applicative> Yvemath, hm, baffling.   you type ./xmonad --help and nothing even there
07:43:29 <byorgey> or just 'xmonad' ?
07:43:45 <merijn> megatron242: I took a compiler course, in which we implemented C-lite. We were discussing optimizations and about 90% of the once we came up with we couldn't do because variables weren't immutable. GHC can do stuff like reordering function calls because it *knows* the order does not matter. A C compiler can never know for sure
07:43:46 <megatron242> Guys, all I'm saying is that for someone new to this language, who comes with a theoretical background in algorthims, switching from O(1) to O(Log N) can not simply be ignored.
07:43:49 <Yvemath> byorgey: just 'xmonad' one sec.
07:44:04 <byorgey> Yvemath: bash will not execute something in your current directory that is not on your path, unless you type  ./ in front of it
07:44:12 <Cale> megatron242: You're ignoring a logarithmic factor already if you think array lookups are O(1)
07:44:13 <maurer_> megatron242: Sure, but what kind of algorithm are you trying to run?
07:44:14 <Yvemath> byorgey: yes, it does spits something now :)
07:44:21 <byorgey> Yvemath: ok, good =)
07:44:22 <quicksilver> megatron242: I am quite aware of the theoretic background - I have studied algorithms.
07:44:36 <quicksilver> megatron242: there are a variety of sense in which array looks are not really O(1).
07:44:45 <Cale> (Actually, provably worse than logarithmic in reality.)
07:44:52 <xplat> > let in let in let in let in let in 1
07:44:52 <lambdabot>   1
07:44:53 <quicksilver> megatron242: I assert that, in practice, Data.Map is a 'fast lookup structure' and that's what you need to know.
07:44:53 <maurer_> My point at least is that most algorithms where you think you need an O(1) modification array you actually do not, and is just a poor phrasing of the algorithm.
07:45:03 <xplat> weird ...
07:45:06 <Yvemath> byorgey: but the problem isnt solved yet, when i do xmonad --recompile, it returns the error command not found
07:45:18 <sipa> Yvemath: ./xmonad --recompile
07:45:19 <megatron242> I come from the field of computational geometry
07:45:23 <sipa> don't forget the ./
07:45:23 <Yvemath> sipa: oh.
07:45:27 <Cale> megatron242: Any function whose domain has n elements takes at least O(log n) time to compute.
07:45:28 <xplat> just like haskell to allow the trivial case for consistency though ...
07:45:48 <Cale> Sorry, any injective function ;)
07:45:54 <applicative> Yvemath, so there's a problem with PATH still.  or maybe you need a new instance of your terminal, won't it keep the old one
07:45:57 <p-p-s> Yvemath, did you just put the ~/.cabal/bin in your path?
07:46:03 <xplat> Cale: you mean range
07:46:06 <Yvemath> p-p-s: yes, i did put
07:46:09 <maurer_> megatron242: Your field doesn't change these assertions.
07:46:11 <Cale> mm, yes, that's what I mean
07:46:20 <byorgey> Yvemath: and if you  echo $PATH, what does it say?
07:46:23 <p-p-s> Yvemath, e.g. bash only reads .bashrc when it starts
07:46:32 <Yvemath> /bin:/usr/bin:/sbin:/usr/sbin:/opt/java/jre/bin:/usr/lib/perl5/core_perl/bin:/opt/qt/bin
07:46:35 <Yvemath> byorgey: there ^
07:46:42 <byorgey> so, .cabal/bin is not in your path
07:46:49 <maurer_> A large part of this language is learning to think in terms of non-mutable data structures. We do have mutable data structures, but you likely don't need them.
07:46:51 <xplat> and that's worst-case, it could still take sublogarithmic or constant expected time depending on encoding
07:47:06 <xplat> (and on the input distribution)
07:47:09 <p-p-s> Yvemath, run bash again or open a new terminal. It should be there after that
07:47:12 <megatron242> OK, thanks for the help
07:47:14 <Yvemath> byorgey: but when i do cat ~/.profile it does show the path.
07:47:18 <Yvemath> p-p-s: ah, okay
07:47:21 <Aune> could some mathemagician review my argument in this one: http://hpaste.org/41646/cyclic_groups
07:47:29 <Yvemath> killall X
07:47:53 <merijn> megatron242: I'd just write the easy code, then if it turns out to be to slow come back here for help
07:47:57 <ziman> megatron242, if you insist on C-like O(1) mutable array access, you can still use the ST monad
07:48:19 <maurer_> ziman: I was avoiding mentioning that intentionally.
07:48:24 <litb> i got the haskell book of hutton but i never read it
07:48:29 <litb> instead i like bugging #haskell
07:48:34 <Cale> Aune: That argument seems needlessly fancy...
07:48:53 <ziman> I can imagine heavy bitmap crunching would feel the difference, for example...
07:49:05 <Aune> Well, Im not surprised
07:49:24 <Cale> Aune: Since G is cyclic, it has subgroups of every order that divides |G|, and since cyclic groups are Abelian, they're all normal.
07:49:27 <Aune> Could you help me get rid of the superfluous parts?
07:49:48 <Cale> (actually, you don't even need that second bit)
07:50:33 <applicative> Yvemath, have you got it working?
07:51:24 <Cale> (and they're all cyclic, as are all quotients of G)
07:53:42 <Aune> So since G cyclic and H subgroup we know that there exist a subgroup C of G such that |H||C|=|G|. 
07:54:02 <Cale> yeah
07:54:38 <Cale> and it has to be cyclic, since it's a subgroup of G.
07:54:51 <Cale> Just as G/H has to be cyclic.
07:55:04 <Aune> And C must be cyclic and so must G/H and since |C| = |G/H| C isomorphic to G/H
07:55:20 <Cale> yep
07:56:36 <Aune> Nice. Thanks :)
07:58:21 <xplat> i'm always amused that there's a whole big important theory of abelian groups.  they seem too simple for that when you learn they're all polycyclic ... but then again, number theory.
08:13:53 <arcatan> n!e
08:13:55 <arcatan> !e
08:14:06 <arcatan> .
08:14:21 <arcatan> whoops, sorry
08:17:14 <roconnor> anyone have a comonad tutorial?
08:28:27 <Sporadics> scientists have discovored sub human like life on other planets close to us http://tinyurl.com/2whmtpe as you must be aware of this
08:31:29 <Jafet> And some of it even seems to have made it to earth
08:32:30 <xplat> a comonad is like an inside-out spacesuit
08:32:51 <pkrumins> copumpkin knows all about inside-out spacesuits
08:33:15 <xplat> i don't know if people do tutorials for them yet
08:34:04 <xplat> what i've seen that was understandable was mostly on sigfpe's blog
08:35:14 <Saizan> we need an "All About Comonads" or "the essence of functional programming" but with comonads (there's "the essence of dataflow programming" but i didn't find it compelling as much as the other)
08:37:32 <xplat> it seems like, you know, how you write your typical effects under the function arrow?  there's a sense in which comonads can represent effects OVER the arrow, but i'm not quite there on the details yet
08:39:00 <xplat> in particular, propagating the opposite way on the stack, from caller to callee
08:42:17 <litb> w00t!
08:45:06 <xplat> the thing is it's hard to find good examples of effects that are like that
08:45:28 <xplat> the container-y angle works out nicer
08:46:23 <quicksilver> yes, interesting examples of comonads are few and far between
08:46:31 <xplat> for every sufficiently nice container, there is a comonadic zipper
08:46:40 <quicksilver> that's only really one example though :)
08:46:59 <quicksilver> but my real question is - what do we gain from treating the zipper as a comonad?
08:47:12 <xplat> cellular automata
08:47:19 <quicksilver> does the general theory of comonads or general combinators give us anything we wouldn't have if we'd written the zipper by hand?
08:47:41 <xplat> or localized evaluation in general
08:48:35 <xplat> a cokliesli arrow for a zipper is a function that computes a new value for the cursor point based on access to the zipper
08:49:39 * quicksilver nods
08:49:47 <quicksilver> as a theorist, I find this interesting.
08:49:52 <quicksilver> as a programmer, I don't know if I should care.
08:50:02 <xplat> the comonad structure lets you lift this to a function that computes a new value for every point in the zipper based on points near it
08:50:18 <quicksilver> the advantage of making something an instance of Monad is taking advantage of the relatively rich family of polymorphic combinators which work on all monads
08:50:31 <quicksilver> comonad doesn't seem to bring some concomitant perks
08:50:38 <quicksilver> (a criticism which I also level at Arrow)
08:51:22 <xplat> hm, yes, well, neither of them has been around as long or had the same level of syntactic support
08:52:08 <xplat> (yes, arrows have had a notation for a while, but it is an extension not supported on all compilers)
08:52:53 * quicksilver nods
08:52:56 <quicksilver> I've used arrows
08:53:01 <xplat> also, arrows could really work a lot better with better language support for polytypic operations on product types
08:53:03 <quicksilver> I did not see cases where the notation would suport me.
08:53:31 <quicksilver> it was only one experiment, maybe it was atypical and maybe I just didn't see.
08:54:23 <xplat> i think that's an even bigger issue than arrow-specific notation, it would get rid of a lot of pair-related plumbing
08:55:37 <quicksilver> perhaps you're righ
08:55:44 <quicksilver> although I didn't see pairs as all that important.
08:55:53 <quicksilver> I prefered to do applicative-type-stuff
08:56:01 <quicksilver> i.e. apply 2-arg functions directly
08:56:08 <quicksilver> rather than going via pairs + arr
08:56:47 <xplat> so i think mostly these nice combinator libraries have just not been written yet, and nobody much wants to write them because monads covered most of the cases and applicatives took most of the rest
08:56:59 <quicksilver> what I should do, is put my code where my mouth is, and turn it into a mailing list post and get people to explain to me how arrow notation would help.
08:57:16 <sshc> For an x by y matrix, is x usually the number of collumns or rows of the matrix?
08:57:34 <sshc> Ah, not sure how that was in my paste buffer
08:57:45 <pkrumins> sshc: rows
08:57:55 <quicksilver> depends if you're french or not.
08:57:57 <quicksilver> or something ;)
08:58:15 <sshc> I know.  Not sure how that was pasted
08:58:39 <ksf_> hmmm. I got an idea.
08:58:55 <quicksilver> sshc: could have been worse :)
08:59:01 <ksf_> reddit is doing coderaids, so we could go ahead and teach X people haskell in 2 days.
08:59:04 <xplat> rows makes more sense because in x_ij i is usually the row, but a lot of people say columns first anyway
08:59:34 <quicksilver> einstein-summation-convention++
08:59:51 <quicksilver> implicit notation is *such* a great way to produce fallacious proofs that look right.
09:00:01 <pkrumins> i am good at that
09:00:02 <sshc> I think they accidentally the verb in http://hackage.haskell.org/platform/mac.html
09:00:17 <xplat> math people hate indices for some reason
09:00:51 <monochrom> not my experience. they seem to love indices and moar indices.
09:00:57 <ksf_> actually, make that "we could get X people to check how good our entry-level tutorials are"
09:01:02 <quicksilver> depends entirely on the kind of maths people.
09:01:15 <xplat> traditionally physics people are the ones who prefer them
09:01:21 <quicksilver> indices generally implies a choice of basis, in some sense
09:01:27 <monochrom> Even look at TaPL
09:01:30 <quicksilver> and basis-independent statements are inherently more elegant.
09:01:56 <quicksilver> (warning, the previous comment may contain subjective elements)
09:02:13 <pkrumins> cristoffel symbols!
09:02:26 <xplat> math people prefer wedge products and such
09:02:54 * Funktorsalat agrees with quicksilver, depends on the subculture
09:03:19 <sshc> Who accidentally in charge of the Haskell Platform?
09:03:19 <xplat> (at least in the differential geometry area of math that the einstein summation convention mostly applies to)
09:04:07 <quicksilver> xplat: yes, and there is an objective reason.
09:04:23 <Funktorsalat> hmm some differential geometers only use coordinates as a last resort
09:04:31 <quicksilver> xplat: if you prove a theorem w.r.t a basis, you have to then separately prove it's basis-independent.
09:04:38 <sshc> Ah, it makes sense now.
09:04:44 <quicksilver> staying away from indices makes it easier.
09:04:44 <xplat> indices only imply a basis by convention, though
09:05:18 <Funktorsalat> if we're talking about manifolds, they imply more (that you're working in a single local coordinate chart)
09:05:44 <Funktorsalat> or so I think. maybe the index people somehow deal with the transitions nicely ;)
09:06:30 <xplat> a more important anti-index point is that they don't do well when you're working with things that would get n-k indices, like volume forms and such
09:07:15 <Funktorsalat> you just need MORE indices ;)
09:07:26 <Funktorsalat> cf. brute force
09:08:33 <xplat> index notation tends to get vague when you deal with variable numbers of indices.  there are some notational ideas from logic that might be stealable. though ...
09:11:10 <xplat> the thing that attracts me to indices is not the interpretation in terms of coordinates and summation, which i agree is a burdensome detail better eliminated, it's how it makes things more explicit as to which forms eat which vectors, etc
09:11:43 <quicksilver> you view them as type annotations, then?
09:12:22 <Funktorsalat> hmm but if you make sure to distinguish tangent and cotangent stuff, you get that without indices too, no?
09:12:24 <xplat> more like name bindings a la lambda calculus
09:12:52 <xplat> it's like modern differential geometers are doing all their geometring in pointfree style
09:13:23 <xplat> (not to be confused with point-free in the geometric sense)
09:13:37 <Funktorsalat> yeah, and it feels like a "strongly typed" field of math :)
09:14:05 <Funktorsalat> (if you *don't* identify everything with R^n that is ;))
09:14:10 <EvanCarroll> What's the best way to take a list and segment it in groups of smaller lists of x or more elements
09:14:27 <Cale> x or more?
09:14:34 <EvanCarroll> so like [1..10], gets segmented into [1,2,3], [4,5,6] [7,8,9], [10]
09:14:36 <EvanCarroll> or less *
09:14:56 <Cale> map (take 3) . takeWhile (not . null) . iterate (drop 3)
09:15:29 <EvanCarroll> quick.
09:15:48 <EvanCarroll> cool, beans I'll now go disect that and learn
09:16:22 * Funktorsalat considers adding the 'tac' command to HSH.ShellEquivs just because of the name
09:16:26 <litb> EvanCarroll: so if  [1..] is lazy evaluated it is segmented in 3 pieces each time?
09:16:39 <litb> oh wait i see now
09:18:11 <Funktorsalat> when ultimately generating textual source code, do you think it pays off to have an ADT for the output language? the alternative being just string combinators
09:18:23 <Cale> Yes.
09:18:29 <Funktorsalat> the former is cleaner, but it sometimes feels like pointless work
09:18:47 <Funktorsalat> especially since the result will be checked by the target lang parser/typechecker anyway
09:18:50 <monochrom> less error prone
09:20:15 <litb> an explicit ADT feels more OOP
09:20:15 <Saizan> you could have smart constructors corresponding to the AST ones that build the String directly, assuming you never need to post-process
09:20:45 <quicksilver> you could use a type-class to switch between ones which actually generate an AST and ones which just generate a string directly
09:20:48 <quicksilver> to keep you honest.
09:20:54 <Cale> Algebraic datatypes are pretty functional :)
09:21:05 <Funktorsalat> visitor pattern! ;)
09:21:06 <xplat> > takeWhile (not . null) . unfoldr (Just . splitAt 3) $ [1..10]
09:21:07 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10]]
09:21:09 <litb> oh i read it as abstrcat data type
09:21:51 <EvanCarroll> @src iterate
09:21:52 <lambdabot> iterate f x =  x : iterate f (f x)
09:21:57 <Funktorsalat> quicksilver: hmm that's interesting. sounds similar to newtype Foo String phantom = Foo String
09:22:07 <EvanCarroll> I wish ghci had @src
09:23:02 <EvanCarroll> does it not have @src, because of the added work (technical reason)? or, because of a social reason?
09:23:08 <quicksilver> EvanCarroll: you can run lambdabot in ghci if you wish
09:23:14 <quicksilver> GOA it is/was called
09:23:24 <quicksilver> not sure if anyone tried to compile it recently.
09:23:33 <quicksilver> I just keep the standard libraries web pages open in a browser
09:23:38 <quicksilver> and browse the source that way.
09:23:46 <Funktorsalat> the issue with the adt is just that you do have to type everything several times... and when in a hurry, you might to just write raw strings for language constructs of the target language you use just once or so
09:23:47 <quicksilver> (as long as haskell.org doesn't go down!)
09:24:12 <Funktorsalat> when making a library it's different, sure
09:24:22 <litb> ohh!
09:24:37 <litb> is map (take 3) . takeWhile (not . null) . iterate (drop 3) not inefficient?
09:24:55 <Twey> Quite efficient
09:24:56 <Fuco> it's quite ugly ;D
09:25:00 <Twey> No it isn't
09:25:03 <xplat> i'd like to have some kind of grammar library that would generate all of an AST, CST, parser, pretty-printer, compact printer from one grammar specification
09:25:08 <Twey> Nothing wrong with that
09:25:11 <quicksilver> I think it's quite beautiful, actually
09:25:14 <litb> the iterate seems to generate lots of redundant data
09:25:19 <quicksilver> I generally name it 'chunksOf'
09:25:20 <Twey> litb: Laziness to the rescue!
09:25:34 <quicksilver> litb: all the redundant stuff is actually shared
09:25:34 <Twey> Or simply ‘chunk’
09:25:35 <EvanCarroll> litb: iterate generates 0 redundant data.
09:25:40 <quicksilver> it's cleverer than it looks.
09:25:42 <litb> like, take 3 only takes 3 items  but iterate will produce much more -.-
09:25:51 <litb> oh
09:25:52 <Twey> litb: Nothing's produced until it's used
09:25:58 <Cale> litb: It's map (take 3)
09:26:01 <Twey> litb: If you only use three items, you only generate three items
09:26:05 <Cale> Maybe all the lists are infinite even.
09:26:11 <Funktorsalat> xplat: bnfc?
09:26:13 <litb> but it will create unaccessd pointers in the end?
09:26:19 <Cale> > map (take 3) . iterate (drop 3) $ [0..]
09:26:20 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16,17],[18,19,20],[21,22,...
09:26:21 <monochrom> Grammatical Framework does it all. http://www.grammaticalframework.org/
09:26:24 <xplat> the only possible problem i see with it is that iterate generates nested 'drop 3' thunks
09:26:27 <Fuco> it produces this [[1,2,3,4,5,6,7,8,9,10],[4,5,6,7,8,9,10],[7,8,9,10],[10]]
09:26:29 <Twey> litb: One
09:26:40 <litb> oh
09:26:43 <Fuco> on that map (take 3) is called
09:27:00 <Funktorsalat> xplat: http://www.ohloh.net/p/12800
09:27:06 <Cale> Fuco: Yeah, though that's not the order in which things happen at all :)
09:27:09 <Twey> litb: (not sure if I'd call it ‘unaccessed’; it's there in case you need more data)
09:27:20 <aristid> :t (.:)
09:27:21 <lambdabot> Not in scope: `.:'
09:27:27 <Fuco> Cale: how come
09:27:36 <McManiaC> how do you pass arguments to ld via ghc?
09:27:36 <Cale> Fuco: Lazy evaluation is outermost-first
09:27:38 <aristid> @let (.:) =fmap.fmap; infixr 7 .:
09:27:39 <lambdabot>  Defined.
09:27:56 <aristid> > take 3 .: iterate (drop 3)
09:27:56 <lambdabot>   Overlapping instances for GHC.Show.Show ([a] -> [[a]])
09:27:56 <lambdabot>    arising from a us...
09:28:00 <aristid> :t take 3 .: iterate (drop 3)
09:28:01 <lambdabot> forall a. [a] -> [[a]]
09:28:11 <litb> Twey: oh i see. the list is a cons
09:28:24 <aristid> :t takeWhile (not.null) . (take 3 .: iterate (drop 3))
09:28:25 <lambdabot> forall a. [a] -> [[a]]
09:28:35 <Twey> litb: All lists are either nils or conses, yes
09:28:42 <Funktorsalat> er, actually this seems to be the official homepage http://www.cse.chalmers.se/research/group/Language-technology/BNFC/
09:28:46 <aristid> > takeWhile (not.null) . (take 3 .: iterate (drop 3)) $ [0..5]
09:28:47 <lambdabot>   [[0,1,2],[3,4,5]]
09:28:57 <monochrom> all lists are either discovered or invented
09:29:06 <xplat> hm, those both look pretty interesting
09:29:17 <Cale> map (take 3) (iterate (drop 3) [0..]) --> map (take 3) ([0..] : iterate (drop 3) (drop 3 [0..])) --> take 3 [0..] : map (take 3) (iterate (drop 3) (drop 3 [0..]))
09:29:31 <Cale> and then if we're evaluating the first element of the list first...
09:30:08 <jaredj> is there a way to catch exceptions purely?
09:30:10 <Cale> --> (0 : take (3-1) [1..]) : map (take 3) (iterate (drop 3) (drop 3 [0..]))
09:30:22 <Fuco> I think I get it
09:30:22 <Cale> and so on...
09:30:51 <xplat> i do think this would be a good case for a strict iterate, though
09:31:10 <xplat> not spine-strict, though
09:31:24 <litb> Cale: ohh
09:31:55 <litb> it's all like a pipeline
09:32:10 <Twey> Yep
09:32:11 <quicksilver> xplat: as long as you access the elements as you go, there is never more than one (drop 3) thunk at once
09:32:14 <aristid> @let iterateUntil f = takeWhile (not . f) .: iterate
09:32:15 <lambdabot>  Defined.
09:32:38 <aristid> > take 3 .: iterateUntil null (drop 3) $ [0..8]
09:32:39 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8]]
09:32:46 <xplat> oh, right, the thunks are shared, so they disappear from everywhere at once
09:32:51 <quicksilver> xplat: exactly.
09:32:54 <gds> jaredj: I think there's not. Exceptions can't be thrown until you're excecuting an IO action anyway, so you can't catch them unless you're also in IO....
09:33:03 <monochrom> isn't lazy evaluation exciting!
09:33:03 <quicksilver> xplat: (the thunks are actually the same thunk)
09:33:11 <jaredj> gds: except for error, right?
09:33:13 <litb> is this "sharing of chunks" some ghc internal thing?
09:33:20 <litb> or a haskell wide priciple?
09:33:20 <quicksilver> litb: yes, it is
09:33:24 <aristid> ski: i love (.:)
09:33:30 <quicksilver> although it's widely understood to be what lazy evaluation should involve
09:33:37 <litb> oh
09:33:41 <quicksilver> the language report does not specify the details of sharing
09:33:51 <quicksilver> but if you don't make any effort to share thunks, you're merely non-strict, not lazy
09:33:53 <xplat> :t (.:)
09:33:54 <lambdabot> forall a b (f :: * -> *) (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
09:33:55 <gds> jaredj: You can type 'error "foo"' in pure code, but the error doesn't actually get thrown until the code is being evaluated....
09:34:20 <jaredj> right
09:34:23 <litb> @djinn (.:)
09:34:23 <lambdabot> Cannot parse command
09:34:26 <xplat> @src (.:)
09:34:26 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:34:28 <gds> jaredj: so I can do something like 'foo = error "bar"'
09:34:28 <litb> :P why does it fail?
09:34:36 <litb> oh i have it wrong
09:34:40 <aristid> (.:) = fmap.fmap
09:34:46 <aristid> i defined it that way
09:34:54 <litb> oh
09:35:01 <aristid> with @let
09:35:05 <gds> jaredj: and then I can pass foo around - store it in data structures...
09:35:07 <aristid> @let litb = "little bear"
09:35:08 <lambdabot>  Defined.
09:35:20 <jaredj> sure
09:35:21 <aristid> > litb ++ " is what litb stands for"
09:35:22 <lambdabot>   "little bear is what litb stands for"
09:35:32 <litb> lol
09:35:34 <gds> jaredj: like blort = [1, 2, foo]'
09:35:48 <gds> jaredj: then I can do 'take 1 blort' and there's no error....
09:35:55 <xplat> so why is it called (.:)?
09:36:02 <gds> But if I try to print the whole thing, the error will get thrown.
09:36:07 <jaredj> gds: right, right
09:36:14 <aristid> xplat: because it's like an extension of (.)
09:36:19 <jaredj> gds: i have an array which i'm misindexing somewhere
09:36:28 <jaredj> gds: i thought to figure out where by writing a quickcheck
09:36:30 <aristid> xplat: (..) is not legal haskell, so we use another similar symbol: (.:)
09:36:48 <aristid> xplat: you can take this further.
09:36:53 <litb> hmm  fmap.fmap will need a Functor that wraps itself a Functor?
09:36:58 <aristid> @let (.::) = fmap.fmap.fmap
09:36:59 <lambdabot>  Defined.
09:37:08 <aristid> litb: yes. and note that all functions are functors
09:37:09 <jaredj> gds: but i can't catch the error caused by the out-of-bounds array index in the property function (thus exposing via quickcheck the indices that failed)
09:37:15 <quicksilver> litb: yes, like [[Int]]
09:37:25 <litb> oh i haven't known that yet about functions
09:37:29 <quicksilver> > (fmap.fmap) negate [[1,2],[3,-4,5]]
09:37:30 <lambdabot>   [[-1,-2],[-3,4,-5]]
09:37:39 <litb> what does the function functor instance do i wonder
09:37:41 <xplat> so like
09:37:48 <gds> jaredj: I'm afraid I must admit to almost 0 experience with quickcheck :/
09:37:49 <ben> litb: composition
09:38:01 <aristid> litb: well, for functions, fmap = (.) -- the version of (.) from Prelude
09:38:12 <jaredj> gds: the reason it's nice and simple is because the top layer is pure ;o
09:38:15 <xplat> > let (-+) = negate .: (+) in 1 -+ 2
09:38:16 <lambdabot>   -3
09:38:34 <xplat> that is handy
09:38:38 <Kaidelong> gds: you should fix that as soon as you can
09:38:42 <Kaidelong> it's quite handy
09:38:46 <gds> Kaidelong: I plan to :)
09:38:48 <jaredj> gds: you write instances of the Arbitrary typeclass for your custom types, then write a property :: YourType -> SomeOtherStuff -> Bool, and quickcheck it
09:39:31 <jaredj> gds: the quickcheck mechanism obtains arbitrary values of the types needed for your property, and if the property does not hold true, tells you what the values were
09:39:51 <gds> I've read at least one paper about quickcheck, but never actually used it in practice.
09:40:16 <litb> > (+1) . [1,2,3]
09:40:17 <lambdabot>   [2,3,4]
09:40:20 <litb> nice :)
09:40:25 <jaredj> gds: i think lyah got me really started; i read the paper but failed several times to write real code based on it
09:40:36 <jaredj> gds: still a faltering beginner with it myself
09:40:39 <xplat> quickcheck >> any other testing framework unrelated to it
09:40:49 <gds> So, I don't know what part of the quickcheck mechanism would be exposed to the exception that your array mis-index throws....
09:41:04 <gds> I guess it doesn't report errors as failures then?
09:41:17 <gds> If you're trying to catch them yourself?
09:42:02 <Jafet> > ((++).).(++) <$> ["hello ", "hi ", "hey ", "howdy "] <*> ["", "there "] <*> ["dude", "pal", "buddy"]
09:42:03 <lambdabot>   ["hello dude","hello pal","hello buddy","hello there dude","hello there pal...
09:42:17 <xplat> people who i introduce to quickcheck or scalacheck or whatever seem to practically have orgasms over it once they try it
09:43:05 <litb> :P
09:43:07 <xplat> even when they're learning it they're like 'i had to look up how to do 15 things but those were still the easiest tests i ever wrote'
09:43:16 <ski> aristid : glad you like it :)
09:43:21 <gds> @check 1==(error "foo")
09:43:22 <lambdabot>   "*Exception: foo
09:43:26 <gds> @check 1==2
09:43:27 <lambdabot>   "Falsifiable, after 0 tests:\n"
09:43:37 <aristid> ski: was your original version (.:) = (.).(.) or (.:) = fmap.fmap?
09:43:41 <ski> > error "foo" :: String
09:43:41 <litb> exceptions feel unfunctional -.-
09:43:42 <gds> heh - didn't tell me the input in either case :)
09:43:42 <lambdabot>   "*Exception: foo
09:43:50 <gds> So I still don't know :)
09:43:54 <Jafet> It's real easy to do something without knowing how to do it. Unless you need to do it correctly.
09:43:55 <quicksilver> litb: they are.
09:44:11 <quicksilver> litb: or exceptions in pure code are unfunctional
09:44:17 <Jafet> @check (\xs -> xs == reverse xs)
09:44:17 <lambdabot>   "OK, passed 500 tests."
09:44:24 <quicksilver> litb: exceptions in IO are kind-of fine; they're just one more interesting propery of the IO monad.
09:44:24 <ski> aristid : the former .. but taking the Caleskell `(.)' into account, the latter is also useful
09:44:29 <aristid> quicksilver: why? they are just bottom
09:44:40 <Jafet> @check (\xl@(x:xs) -> xl == reverse xl)
09:44:40 <lambdabot>   "*Exception: <interactive>:1:149-178: Non-exhaustive patterns in lambda
09:44:48 <quicksilver> and other (pure) monads have exception type things in.
09:44:57 <ski> (aristid : the `.:' symbol name was a mnemonic for the three `.' in `(.) . (.)' :)
09:44:57 <aristid> ski: it's very useful IMO, more useful than Caleskell (.), because you can always use <$> for fmap
09:45:23 <xplat> i've just realized that setting (.) = fmap is basically just interpreting containers as functions from position to element
09:45:26 <aristid> it's funny how fmap is more popular than (<<<)
09:45:53 <ski> aristid : `(.) . (.)' or `fmap . fmap' being "useful, more useful than `(Caleskell..)'" ?
09:46:05 <aristid> ski: (.:)=fmap.fmap
09:46:14 <Jafet> If you want to take the container view of Monad.
09:46:26 <ski> xplat : except that in real containers the allowed positions can depend on the actual container, rather than just the container type
09:46:35 <xplat> of functor, actually
09:47:05 <xplat> ski: hey, just because haskell semantics can't deal with the dependent type doesn't mean the syntax can't :)
09:47:11 <Jafet> Er, yeah. Got buzzed by memories of tutorials.
09:47:44 <ski> xplat : is you like, figure out how to interpret `flip' in a related way
09:47:47 <ski> @type flip
09:47:48 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:47:51 <monochrom> you can obtain dynamic dependent type by catching exceptions
09:47:56 <xplat> ski: oh, i already did that
09:48:16 <Jafet> > succ . Just 1 == (Just . succ) 1
09:48:16 <lambdabot>   True
09:48:24 <ski> @type (<<<)
09:48:25 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
09:48:32 <xplat> flipF = flip $ fmap . flip id
09:48:51 <ski> aristid : ok
09:49:43 <ski> aristid : how about `succ . [0,1,2]',`succ .: [[],[0],[1,2],[3,4,5]]',&c. ?
09:50:03 <ski> aristid : with `fmap' the former is  succ `fmap` [0,1,2]
09:50:51 <litb> since when is flip a Functor function?
09:51:02 <ski> litb : since i suggested it to Cale
09:51:04 <kwuxalot> how do you check if a given value in Python is of a specific type, like <type 'str'>? I'm sure there's a simple boolean check
09:51:24 <Jafet> :t return
09:51:25 <bloops> how do I read formatted input? I want to read a pair of integers separated by a space
09:51:25 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
09:51:31 <kwuxalot> I know this is a #python question, but the people there are being asses, and their answer is "you shouldn't"
09:51:31 <litb> oh
09:51:47 <Jafet> kwuxalot: don't take us lightly, we can be asses too
09:51:54 <Jafet> (I hope)
09:52:09 <kwuxalot> Jafet: I've been hanging out here for at least a year, and in my experience you're wrong ;)
09:52:21 <engla> kwuxalot: you can check it in Python but generally you shouldn't. isinstance("", basestr) or isinstance("", str)  (if I didn't get argument order wrong)
09:52:23 <ski> litb : take `flip :: (e -> (a -> b() -> (a -> (e -> b))', and generalize `(e ->)' to `f' such that `Functor f'
09:52:33 <kwuxalot> engla: thanks ;)
09:52:40 <engla> kwuxalot: basestring  (str and unicode base class in Py 2)
09:52:41 <endojelly> kwuxalot, like that:
09:52:45 <ski> litb : it's the same process as with `(.) :: (a -> b) -> (e -> a) -> (e -> b)'
09:52:46 <endojelly> >>> import types
09:52:47 <endojelly> >>> type("foo") == types.StringType
09:52:47 <endojelly> True
09:52:52 <endojelly> kwuxalot, you inbred imbecile!
09:52:54 <Saizan> > map read . words $ "123 123" :: [Int] -- bloops 
09:52:55 <lambdabot>   [123,123]
09:53:02 <Jafet> You all disappoint me.
09:53:10 <ddilinger> bloops: write a quick function to go Char -> [String] -> [[String]]. walk the array splitting if neccessary(takeWhile (/=char)
09:53:27 <ddilinger> err, Char -> String -> [String]
09:53:28 <ski> Jafet : how could we but ?
09:53:39 <Jafet> :t reads -- bloops
09:53:40 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:54:19 <bloops> thanks
09:54:30 <ski> litb : exercise : find operations in libraries which have `(w ,)' in their types, and generalize that to `f', where one of `Functor f',`Applicative f',`Monad f' is assumed
09:54:38 <engla> kwuxalot: I agree, #haskell is very nice
09:55:02 <ski> @type reads :: Read a => ReadS a
09:55:03 <lambdabot> forall a. (Read a) => String -> [(a, String)]
09:55:09 <litb> fo rthe life of me i don't understand flip's type
09:55:09 <ski> @src ReadS
09:55:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:55:11 <litb> > flip [(*3)] 4
09:55:12 <lambdabot>   [12]
09:55:15 <litb> hmm
09:55:22 <ski>   type ReadS a = String -> [(a,String)]
09:55:24 <litb> w00t
09:55:25 <xplat> it's too nice, i can't leave :-7
09:55:50 <ski> litb : it applies each function in a container of functions to the same value
09:56:43 <ski> litb : another exercise : use this `flip' to define `loeb :: Functor f => f (f a -> a) -> f a'
09:56:45 <Jafet> > flip readP_to_S "123 456" $ do { x <- many1 (satisfy isDigit); char ' '; y <- many1 (satisfy isDigit); eof; return (x, y); }
09:56:46 <lambdabot>   Not in scope: `readP_to_S'Not in scope: `many1'Not in scope: `satisfy'Not i...
09:56:48 <litb> ski: i don't know what you mean with "`flip :: (e -> (a -> b() -> (a -> (e -> b))', and generalize `(e ->)' to `f'"  what's that weird flip :: (e -> (a -> b() -> (a -> (e -> b))   type ?
09:57:17 <kmc> flip :: (e -> a -> b) -> (a -> e -> b)
09:57:17 <litb> that looks like fun c++ pointer code but not like any haskell i have ever written lol
09:57:25 <ski> litb : sorry, typo, that should have been `flip :: (e -> (a -> b)) -> (a -> (e -> b))'
09:57:30 <ski> that's the same as
09:57:41 <ski>   flip :: (e -> a -> b) -> (a -> e -> b)
09:57:42 <ski> or even
09:57:46 <ski>   flip :: (e -> a -> b) -> a -> e -> b
09:57:50 <ski> but with more brackets
09:58:21 <ski> (i added more brackets to emphasize the generalization of `(e ->)' to `f'
09:58:23 <ski> @type flip
09:58:24 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
09:59:50 <kmc> kwuxalot, i think "you shouldn't" is often a good answer, but i prefer "you shouldn't, but here's how..."
10:00:07 <kmc> #python gets so many beginners that they assume you must be an idiot if you want something slightly odd
10:00:32 <ski> @let strength :: Functor f => (w,f a) -> f (w,a); strength = uncurry (fmap . (,))
10:00:34 <lambdabot>  Defined.
10:00:55 <ski> compare `strength' to the generalized `flip'
10:01:40 <litb> i sure have seen today that  (, w) is a functor and i called it the "marriage operator" :)
10:01:51 <ski> well, `(,) w' rather
10:01:59 <ski> (which i was writing as `(w,)')
10:02:04 <engla> I've been in trouble in #Python for not providing pedagogical enough answers. It's partly correct, and partly just a struggle to keep the monopoly on how python is taught
10:02:12 <kmc> it would be nice to write (w,) or (e ->) etc. but sections are not allowed in types :/
10:02:18 <xplat> strength is actually a pretty handy function, you can add source annotations to every element of a container before you concatenate it to something else
10:02:20 <Jafet> "Hi guys, what's the best way to check if my rear lights are working?" "That's not how you do it around here, you just drive off and if the lights aren't working you'll find out eventually"
10:02:49 <ski> kmc : surely now that we have tuple sections, we ought to have type type sections !?
10:02:52 <Jafet> Couldn't (,w) be a functor? You'd just flip the semantics.
10:02:55 <kmc> hehe
10:03:14 <ski> Jafet : yes, but `\a -> (a,w)' is not an allowed type
10:03:42 <ski> `(w,)' would be `(,) w', which is ok, rather than `\a -> (w,a)', which is not
10:04:02 <Jafet> Well, that just feels a bit arbitrary.
10:04:04 <xplat> it would be nice to finally be able to write (e ->) rather than ((->) e)
10:04:11 <kmc> arbitrary but unavoidable
10:04:13 <ski> (we want some useful restriction of higher-order unification in the type system !)
10:04:15 <kmc> if you're lacking functions at type level
10:04:19 <ski> Jafet : indeed
10:04:27 <kmc> you can't even do this with type families, can you?
10:04:35 <ski> i think you can't
10:04:47 <kwuxalot> kmc: yeah I totally agree, and also understand the #python atmosphere
10:05:29 <xplat> i'd live with the arbitrariness of only left sections just for (e ->)
10:05:31 <quicksilver> we essentially need types of kind * -> * -> * to take their arguments in a fixed order
10:05:50 <quicksilver> otherwise various parts of the system would need a lot more work
10:06:05 <quicksilver> do you really want to distinguish between the types (Int,Char) and Flip (,) Char Int ?
10:06:09 <xplat> the other way of writing it is so anti-mnemonic
10:06:31 <litb> @src flip
10:06:31 <lambdabot> flip f x y = f y x
10:06:34 <ski> having an involutive `Flip' would go a long way
10:06:50 <kmc> lambdabot's @src doesn't match its own types
10:07:00 <kmc> that's the simple Prelude flip, not the crazy functor one
10:07:01 <litb> ski: i don't understand how the heck that is compatible to its type. how will this  accept   flip [(*3)] 4  ?
10:07:01 <ski> litb : the Caleskell version is obviously not that .. can you figure it out ?
10:07:20 <litb> it would call a list -.-
10:07:26 <xplat> i pasted it a little while ago
10:07:33 <ski> > flip (Just (^2)) 5
10:07:34 <lambdabot>   Just 25
10:07:38 <ski> not just a list
10:07:47 <xplat> more instructive to figure it out yourself tho
10:07:48 <ski> any functor-collection
10:08:04 <litb> ohh
10:08:31 * ski ponders what it would take to make something like `flip f x y = f y x' generate the general version ..
10:08:44 <litb> yes it should be   flip f a b = fmap a b
10:08:51 <ski>   flip f x ! y = (f ! y) x  -- ?
10:09:00 <ski> (for some generic `(!)')
10:09:04 <litb> but i wonder what is "flipped" there?
10:09:10 <ski> litb : not quite
10:09:14 <litb> oh -.-
10:09:24 <ski> @type let flip f a b = fmap a b in flip
10:09:25 <lambdabot> forall t a b (f :: * -> *). (Functor f) => t -> (a -> b) -> f a -> f b
10:09:25 <litb> ah i think it should be flip (f a) b  
10:09:44 <ski> do you mean `fmap (f a) b' ?
10:09:51 <ski> @type let flip f a b = fmap (f a) b in flip
10:09:51 <kwuxalot> ski: that's a crazy sort of pattern matching on source code
10:09:51 <lambdabot> forall t a b (f :: * -> *). (Functor f) => (t -> a -> b) -> t -> f a -> f b
10:10:01 <ski> kwuxalot : indeed. great fun !
10:10:07 <litb> so flip is defined as   flip (f a) b = fmap a b
10:10:20 <bos> preflex: seen tibbe
10:10:20 <ski> litb : no, that's not allowed
10:10:20 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
10:10:20 <preflex>  tibbe was last seen on #ghc 1 hour, 57 minutes and 37 seconds ago, saying: I need to get some rest and have a look over the weekend
10:10:25 <litb> oh
10:10:35 <ski> @type let flip (f a) b = fmap a b in flip
10:10:36 <lambdabot> Parse error in pattern
10:11:12 <kwuxalot> ski: I think this makes more sense: flip (\f x y) = f y x
10:11:43 <ski> kwuxalot : hm ?
10:11:43 <litb> one needs a way to get the function out of the functor
10:12:16 <ski> kwuxalot : maybe you wanted `flip (\y x -> z) = \x y -> z' (which i think would make sense) ?
10:12:16 <litb> because fmap wants the function as first argument not just the functor -.-
10:12:52 <kwuxalot> ski: you're right, what I wrote doesn't really make sense. Still, either of your versions are mind twisting
10:13:34 * ski waits for the cogs to turn inside litb's head
10:13:51 <litb> lol
10:14:36 <ski> (kwuxalot : of course, that last version would not be the generalized `flip', just the ordinary one)
10:15:45 <aristid> :t flip
10:15:45 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:15:51 <ski> kwuxalot : another idea i've been pondering is allowing something like `flip <f> a = <f a>'
10:16:07 <litb> ah can you pattern match like  flip (\y x -> z) = ...  ?
10:16:21 <ski> kwuxalot : where `fmap f <a> = <f a>' .. though `< ... >' would basically just expand to `fmap', here :)
10:16:25 <aristid> :t flip (Just id)
10:16:26 <lambdabot> forall a. a -> Maybe a
10:16:31 <aristid> > flip (Just id) 3
10:16:32 <lambdabot>   Just 3
10:16:35 <aristid> \o/
10:16:44 <ski> litb : not in Haskell. it was hypothetical syntax i've been pondering a little
10:16:50 <litb> ohh
10:16:57 <litb> i see now :)
10:17:19 <litb> so this flip seems to be impossible with the only thing being fmap in functor?
10:17:25 <aristid> ski: but with flip being that way, you could also have a reverse flip?
10:17:51 <ski> aristid : you mean `Functor f => (a -> f b) -> f (a -> b)' or what ?
10:18:05 <aristid> ski: yeah
10:18:14 <ski> litb : `flip :: Functor f => f (a -> b) -> (a -> f b)' is not impossible to write, no
10:18:29 <ski> aristid : it would not work for every functor `f' .. which `f' would it work for ?
10:19:35 <ski> btw, this reminds me of a `reverseFmap :: forall a b. (f a -> f b) -> (a -> b)' someone was pondering putting into a typeclass `RevFunctor f'
10:20:09 <litb> i can see how it works if oyu write    flip (Maybe a) = fmap a
10:20:26 <litb> and  flip [a] = fmap a 
10:20:34 <ski> that's not correct
10:20:40 <litb> oh :/
10:20:45 <litb> i'll give up lol
10:20:49 <ski>   flip  Nothing  a = Nothing
10:21:01 <ski>   flip (Just f ) a = Just (f a)
10:21:07 <ski> would be the instance for `Maybe'
10:21:16 <litb> oh right i have the pattern matching wrong :(
10:21:27 <litb> i'm still rusty
10:21:27 <aristid> :t \f a -> f >>= \i -> return (i a)
10:21:28 <lambdabot> forall t (m :: * -> *) b. (Monad m) => m (t -> b) -> t -> m b
10:21:49 <ski> but the task is to not pattern-match on the argument of type `f a' (since you don't know what `f' is), instead using the operation in the type class `Functor'
10:22:28 <ski> er, of type `f (a -> b)', i should say
10:22:43 <litb> ah now i got a idea i think
10:24:31 <aristid> @pl \f a -> f >>= \i -> return (i a)
10:24:31 <paolino1> :t \g x -> fmap ($x) g
10:24:31 <lambdabot> flip (fmap . flip id)
10:24:32 <lambdabot> forall a b (f :: * -> *). (Functor f) => f (a -> b) -> a -> f b
10:24:54 <ski> aristid,(litb) : another exercise : write generalized `flip' in terms of `strength', and vice versa (also using `fmap' in both directions)
10:25:13 <aristid> :t flip (fmap . flip id)
10:25:14 <lambdabot> forall b (f :: * -> *) a. (Functor f) => f (a -> b) -> a -> f b
10:25:20 <ski> (of course anyone can try doing that)
10:25:34 <aristid> ski: it seems like writing reverse flip is possible in Functor :)
10:25:44 <ski> aristid : hehe
10:25:49 <ski> hm, that's not the reverse one
10:25:51 <ski> @type flip
10:25:52 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
10:25:54 <litb> @src strength
10:25:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
10:26:04 <ddilinger> is there already a function with this def: (\f (x,y) -> (f x, f y)
10:26:13 <ski> <ski> @let strength :: Functor f => (w,f a) -> f (w,a); strength = uncurry (fmap . (,))
10:26:14 <aristid> > flip (fmap . flip id) (/) 1 2
10:26:15 <lambdabot>   2.0
10:26:16 <ski> litb : ^
10:26:28 <litb> oh
10:26:52 <ski> ddilinger : `join (***)'
10:26:58 <aristid> ski: the awesome thing is that both generalised flip versions "degrade" to Prelude.flip :)
10:27:02 <ski> > join (***) succ (3,5)
10:27:03 <lambdabot>   (4,6)
10:27:15 <aristid> ski: oh, wait.
10:27:28 <aristid> ski: it's the same type?!
10:27:41 <ddilinger> ski: ok, thanks!
10:27:44 <ski> ddilinger : note that using `join' entails using the same monomorphic instance of `f' in both places. if you need different instances, use `(f *** f)' instead of `join (***) f'
10:27:47 <aristid> so i want a -> f b -> f (a -> b)
10:27:49 <aristid> hmm
10:27:54 <aristid> @djinn a -> f b -> f (a -> b)
10:27:54 <lambdabot> -- f cannot be realized.
10:27:55 <ski> > join (***) succ (3 :: Integer,5 :: Rational)
10:27:56 <lambdabot>   Couldn't match expected type `GHC.Integer.Internals.Integer'
10:27:56 <lambdabot>         agains...
10:28:08 <ski> er, actually bad example
10:28:08 <aristid> @hoogle a -> f b -> f (a -> b)
10:28:09 <lambdabot> No results found
10:28:16 <ski> > join (***) succ (3,LT)
10:28:17 <lambdabot>   No instance for (GHC.Num.Num GHC.Ordering.Ordering)
10:28:17 <lambdabot>    arising from the lit...
10:28:22 <ski> > (succ *** succ) (3,LT)
10:28:23 <lambdabot>   (4,EQ)
10:28:27 <ski> ddilinger : ^
10:28:45 <ski> @djinn (a -> f b) -> f (a -> b)
10:28:45 <lambdabot> -- f cannot be realized.
10:28:49 <ski> aristid : actually ^
10:29:03 <aristid> ski: hmmm
10:29:14 <ski> aristid : "it's the same type?!", what is ?
10:29:15 <aristid> :t (>=>)
10:29:16 <lambdabot> forall a (m :: * -> *) b c. (Monad m) => (a -> m b) -> (b -> m c) -> a -> m c
10:29:37 <aristid> ski: my previous failed attempt at "reverse flip"
10:30:00 <ski> aristid : first, figure out why "reversed `flip'" doesn't work for `Maybe' or for `[]' as `f', e.g.
10:30:20 <aristid> :t (>>=)
10:30:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:30:29 <ski> @type (=<<)
10:30:30 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
10:31:00 <ski> @type (>>=) :: (e -> a) -> (a -> e -> b) -> (e -> b)
10:31:01 <lambdabot> forall e a b. (e -> a) -> (a -> e -> b) -> e -> b
10:31:12 <ski> @type (=<<) :: (a -> e -> b) -> (e -> a) -> (e -> b)
10:31:13 <lambdabot> forall a e b. (a -> e -> b) -> (e -> a) -> e -> b
10:31:25 <aristid> ski: the problem is, i must make sure i don't mix them up again :D
10:31:25 <ski> @type ap
10:31:26 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:31:40 <ski> @type ap :: (e -> a -> b) -> (e -> a) -> (e -> b)
10:31:41 <lambdabot> forall e a b. (e -> a -> b) -> (e -> a) -> e -> b
10:31:54 <ski> so `ap' and `(=<<)' is almost the same, in this case ..
10:31:58 <aristid> (a -> Maybe b) -> Maybe (a -> b)
10:32:05 <ski> yeah
10:32:11 <ski> you see why that's hard ?
10:32:21 <aristid> ok, the problem there is you can't have a non-partial (a -> b) in the Maybe
10:32:44 <ski> the input might give `Nothing' on some `a' inputs, and `Just b' on others
10:32:53 <ski> there is no canonical one to return
10:33:20 <ski> now consider
10:33:23 <ski>   data Pair a = P a a
10:33:40 <ski> what is the problem with `(a -> Pair b) -> Pair (a -> b)' ?
10:33:51 <ski> (that's a simpler case than the `[]' one)
10:34:01 <ski> .. or is there a problem ?
10:34:02 <aristid> fmap f (P a b) = P (f a) (f b) ?
10:34:21 <ski> hm, you're right, that one is ok
10:34:38 * ski tries to recall what the other common bad case was
10:34:39 <silver> is there any version of darcs which is compilable by ghc 7.0.1?
10:34:43 <ski> (if i didn't imagine it)
10:34:59 <ski> hmhm
10:35:00 <ski> no
10:35:07 <aristid> ski: somehow my totally bogus internal pattern matcher tells me something about comonads :D
10:35:15 <ski> @type revFlip f (P a b) = P (f a) (f b) in revFlip
10:35:16 <lambdabot> parse error on input `='
10:35:18 <ski> bah
10:35:26 <ski> @type revFlip f (a,b) = (f a,f b) in revFlip
10:35:27 <lambdabot> parse error on input `='
10:35:29 <aristid> let
10:35:33 <ski> @type let revFlip f (a,b) = (f a,f b) in revFlip
10:35:34 <lambdabot> forall t t1. (t -> t1) -> (t, t) -> (t1, t1)
10:35:36 <ski> (yeah, *sigh*)
10:35:49 <ski> so, that's not the right type
10:36:40 <aristid> (a -> (a, a)) -> (a -> a, a -> a) ?
10:36:58 <ski> you need something like `revFlip p = P (\a0 -> ?b0?) (\a1 -> ?b1?) where P b0 b1 = p ?a?'
10:37:06 <aristid> @djinn (a -> (a, a)) -> (a -> a, a -> a)
10:37:06 <lambdabot> f a =
10:37:06 <lambdabot>     (\ b -> b,
10:37:06 <lambdabot>      \ c ->
10:37:06 <lambdabot>      case a c of
10:37:06 <lambdabot>      (d, _) -> d)
10:37:18 <ski> @djinn (a -> (b,b)) -> (a -> b,a -> b)
10:37:19 <lambdabot> f a =
10:37:19 <lambdabot>     (\ b ->
10:37:19 <lambdabot>      case a b of
10:37:19 <lambdabot>      (c, _) -> c,
10:37:19 <lambdabot>      \ d ->
10:37:21 <lambdabot>      case a d of
10:37:23 <lambdabot>      (e, _) -> e)
10:37:23 <litb> > strength 4 [1, 2, 3, 4]
10:37:25 <lambdabot>   (4,4)
10:37:44 <litb> lol
10:38:17 <bloops> how can I detect EOF from stdin? 
10:38:41 <ski> litb : that's using `instance Num a => Num [a]', or something like that .. try
10:38:52 <ski> > strength (4,[1, 2, 3, 4])
10:38:53 <lambdabot>   [(4,1),(4,2),(4,3),(4,4)]
10:39:03 <ski> > 4 ++ []
10:39:04 <lambdabot>   No instance for (GHC.Num.Num [a])
10:39:04 <lambdabot>    arising from a use of `e_14' at <inter...
10:39:06 <ski> hm
10:39:16 <ski> > 4 :: (Integer,Integer)
10:39:17 <lambdabot>   (4,4)
10:39:22 <ski> > 4 :: (All,Integer)
10:39:24 <lambdabot>   No instance for (GHC.Num.Num Data.Monoid.All)
10:39:24 <lambdabot>    arising from the literal `...
10:39:31 <ski> > 4 :: (Rational,Integer)
10:39:32 <lambdabot>   (4 % 1,4)
10:39:37 <ski> ok
10:39:44 <EvanCarroll> bloops: not . System.IO.isEOF
10:39:55 <ski> so `instance (Num w,Num a) => Num (w,a)' apparently
10:39:55 <aristid> :t let f a = (\b -> fst $ a b, \c -> snd $ a d) in f
10:39:56 <lambdabot> forall a b t. (Expr -> (a, b)) -> (Expr -> a, t -> b)
10:40:06 <aristid> :t let f a = (\b -> fst $ a b, \c -> snd $ a c) in f
10:40:07 <lambdabot> forall t a b. (t -> (a, b)) -> (t -> a, t -> b)
10:40:20 <aristid> ski:  would that be an OK instance? :)
10:40:24 <ski> aristid : yeah, that's a good try
10:40:40 <aristid> ski: we have no laws to check if we have a good version
10:40:46 <litb> it is    fmap ((,) 4) [1, 2, 3, 4]  why isn't that  [(4, 1), (4, 2), (4, 3), (4, 4)]  ?
10:40:59 <litb> > fmap ((,) 4) [1, 2, 3, 4]
10:41:00 <lambdabot>   [(4,1),(4,2),(4,3),(4,4)]
10:41:08 <roconnor> @type unfoldr
10:41:09 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
10:41:10 <litb> oh so strength does something else
10:41:13 <ski> aristid : now, i recall asking the person who brought this up what laws `revFmap' should support
10:41:27 <aristid> ski: the last person?
10:41:34 <aristid> :t strength
10:41:35 <lambdabot> forall w (f :: * -> *) a. (Functor f) => (w, f a) -> f (w, a)
10:41:40 <litb> ah missed the uncurry before it
10:41:57 <litb> :t uncurry
10:41:58 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
10:42:09 <aristid> :t curry strength
10:42:10 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a -> f a1 -> f (a, a1)
10:42:36 <sproingie> looks suspiciously monadish
10:43:45 <Molten> hey all!
10:43:58 <sproingie> oh i read it wrong.  moar coffee.
10:44:10 <ski> sproingie : yeah, but it only requires `Functor'
10:44:19 <roconnor> @hoogle unfoldr
10:44:20 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
10:44:20 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
10:44:20 <lambdabot> Data.ByteString.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
10:44:35 <litb> it calls   uncurry $ fmap ((,)4)     but that doesn't seem to make sense to me, because  uncurry wants a (a -> b -> c)   but  fmap ((,)4)  is of type  a -> b   !
10:44:39 <Molten> Quick question... can you define a list comprehension without needing a parameter?
10:44:40 <Molten> Like: divideToGetDigits = [n | n <- 10 + [1..]]
10:44:49 <ski> litb : `strength' is in some sense a counterpart to the generalized `flip'
10:45:19 <aristid> ski: but not in the same way as revFlip
10:45:48 <ski> aristid : no
10:45:50 <Hk118> Can anyone tell me what is wrong with these type signatures by any chance? http://hpaste.org/41649/fib
10:46:06 * ski ponders aristid's `revFlip' for `Pair'
10:46:14 <aristid> ski: i think with Copointed, we could use extract?
10:46:15 <sproingie> > [n | n <- 10 + [1..]]
10:46:15 <lambdabot>   No instance for (GHC.Num.Num [t])
10:46:15 <lambdabot>    arising from a use of `e_1101' at <int...
10:46:22 <sproingie> i thought there was something odd
10:46:49 <aristid> (a -> f b) -> f (a -> b)
10:46:54 <litb> > take 10 $ [n | n <- (+10) . [1..]]
10:46:54 <ski> Hk118 : remove the `n' from the type signature
10:46:55 <lambdabot>   [11,12,13,14,15,16,17,18,19,20]
10:46:58 <litb> :P
10:47:24 <sproingie> wonder if @pl understands listcomps
10:47:26 <Hk118> ski: thanks. I have gone to a whole new level of stupid after this :(
10:47:36 <sproingie> @pl [n | n <- (+10) . [1..]]
10:47:36 <lambdabot> (line 1, column 1):
10:47:36 <lambdabot> unexpected "["
10:47:36 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
10:47:36 <lambdabot> ambiguous use of a right associative operator
10:47:39 <ski> aristid : and `return' to rewrap, yes
10:47:52 <sproingie> looks like a no
10:48:10 <litb> i seem to remember that listcomps are just syntax sugar for >>= and friends
10:48:14 <sproingie> nice caleskell dot in that listcomp tho
10:48:24 <litb> xD
10:48:37 <ski> Hk118 : it might be nice (or "nice") to allow `fib (_ :: Integer) :: (Integer,Integer)' or maybe even `fib Integer :: (Integer,Integer)'
10:49:42 <ski> Hk118 : we already allow a similar thing with e.g. `data Person = P Name Age' giving 'P :: Name -> Age -> Person' .. compare with `P Name Age :: Person' or `P (_ :: Name) (_ :: Age) :: Person' as per above
10:49:52 <Hk118> ski: I've never seen that syntax before (I'm pretty new) but it seems to make sense. It's actually much more understandable Thanks for that
10:50:28 <ski> Hk118 : if you know C or C++, you'll note that this would be a similar way to write type signatures as prototypes (and `typedef's) are written in those languages
10:50:48 <aristid> ski: (\f -> point (extract . f)) :: (Copointed f, Pointed f) => (a -> f b) -> f (a -> b)
10:50:53 <aristid> ski: using category-exras
10:51:09 <ski> Hk118 : `data Person = P Name Age' means that we're creating a new type `Person' out of two types `Name' and `Age' (e.g. `Name' might be `String' and `Age' might be `Integer')
10:51:14 <aristid> i'm not particularly fond of it
10:51:47 <ski> Hk118 : then `P someName someAge' has type `Person', and you can write a function `getAge :: Person -> Age' by pattern-matching like `getAge (P name age) = age', &c.
10:52:50 <ski> (Hk118 : if you want to try that out, add `type Name = String' and `type Age = Integer' to your code .. those doesn't create new types, as `data' does, they only give new names to existing types, so e.g. `Name' is the same as `String')
10:53:01 <ski> Hk118 : have fun !
10:53:23 <Hk118> That's brilliant, it actually makes type signatures much more understandable than they have been so far for me. Thanks again :)
10:53:54 <ski> :)
10:53:58 <litb> hmm the pattern match  "(,) a" is built-in is it?
10:54:08 <litb> does that mean  "tuple with first argument of type a" ?
10:54:11 <Molten> Hey guys... do you know how to do this endless list in haskell: [10,100,1000..]?
10:54:14 <ski> you can only pattern-match like `(x,y)'
10:54:24 <ski> hm, maybe it works with desugared syntax, as well
10:54:35 <ski> > let (,) x y = (2,3) in [x,y]
10:54:36 <lambdabot>   [2,3]
10:54:38 <ski> *nod*
10:54:40 <litb> [ 10 ** i | i <- [1..] ]
10:54:53 <ski> > iterate (* 10) 10
10:54:54 <lambdabot>   [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000...
10:54:57 <ski> > iterate (* 10) 1
10:54:58 <lambdabot>   [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000...
10:55:02 <ski> > tail (iterate (* 10) 1)
10:55:03 <lambdabot>   [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000...
10:55:10 <litb> > [ 10 ** i | i <- [1..] ]
10:55:11 <lambdabot>   [10.0,100.0,1000.0,10000.0,100000.0,1000000.0,1.0e7,1.0e8,1.0e9,1.0e10,1.0e...
10:55:15 <litb> oh
10:55:19 <litb> fail :)
10:55:30 <ski> > (10 ^) . [1..]
10:55:31 <lambdabot>   [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000...
10:55:38 <Molten> wow
10:55:40 <litb> hehe
10:55:45 <Molten> thats a lot of results :D
10:55:53 <ski> (that last is using non-standard `(.)')
10:56:01 <Molten> But I cant seem to 'define' a variable to an endless sequence like this: divideToGetDigits = [ 10 ** i | i <- [1..] ]
10:56:09 <ski> why not ?
10:56:11 <litb> will   (10 ** i) :: Int    work ?
10:56:14 <ski> what's the problem ?
10:56:15 <sproingie> > fix (*10) 1
10:56:16 <lambdabot>   *Exception: stack overflow
10:56:18 <sproingie> doh
10:56:25 <litb> haha
10:56:25 <ski> litb : work for what ?
10:56:29 <sproingie> that's just if you want the last one :)
10:56:31 <litb> to produce an Int list ?
10:56:43 <Molten> okay it worked nevermind!!
10:56:44 <Molten> Haha
10:56:57 <Molten> Thanks alot guys :)
10:57:03 <ski> > fix ((1:) . ((10 *) .))
10:57:04 <lambdabot>   [1,10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,100000000...
10:57:12 <litb> lol
10:57:17 <sproingie> > fix error
10:57:18 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
10:57:25 <litb> > [ (10 ** i) :: Int | i <- [1..] ]
10:57:26 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
10:57:26 <lambdabot>    arising from a use of...
10:57:27 <ski> (the last `.' there is also the non-standard one)
10:57:30 <litb> ou -.-
10:57:49 <ski> > [ 10 ^ i :: Int | i <- [1..] ]
10:57:49 <lambdabot>   [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000...
10:57:52 <ski> > [ 10 ^ i | i <- [1..] ]
10:57:53 <lambdabot>   [10,100,1000,10000,100000,1000000,10000000,100000000,1000000000,10000000000...
10:57:54 <litb> ah
10:57:55 <ski> @type (^)
10:57:56 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
10:57:57 <ski> @type (^^)
10:57:57 <lambdabot> forall a b. (Fractional a, Integral b) => a -> b -> a
10:57:58 <ski> @type (**)
10:57:59 <lambdabot> forall a. (Floating a) => a -> a -> a
10:58:03 <sproingie> someday i'll actually understand the whole fixpoint thing
10:58:13 <sproingie> er fixed point thing
10:58:58 <Molten> OKAY got it sorted thanks a bunch guys :)
10:59:10 <Molten> I used lambalot's answer :D
10:59:23 <Molten> Perfect integer endless list :)
10:59:29 <ski> hehe, lambdabot didn't provide any of the solutions
10:59:34 <EvanCarroll> hrm (10 ^) . [1..] doesn't work here
10:59:37 <ski> she only provided the evaluation results
10:59:39 <sproingie> i mean i get f(x) = x, just not the "least defined x" part
10:59:48 <EvanCarroll> yet, i see it working with ski
11:00:02 <roconnor> @hoogle Category
11:00:02 <lambdabot> module Control.Category
11:00:02 <lambdabot> Control.Category class Category cat
11:00:02 <lambdabot> Data.Char data GeneralCategory
11:00:09 <ski> EvanCarroll : you need `import Prelude hiding ((.))' and then `(.) :: Functor f => (a -> b) -> (f a -> f b)' and `(.) = fmap'
11:00:21 <ski> @src (.)
11:00:21 <lambdabot> (f . g) x = f (g x)
11:00:21 <lambdabot> NB: In lambdabot,  (.) = fmap
11:00:29 <litb> EvanCarroll: it's using the list Functor instance
11:00:33 <EvanCarroll> ski: why isn't (.) defined like that by default
11:00:46 <ski> EvanCarroll : some people don't like it, fer'instance
11:00:59 <ski> also, that idea wasn't around when it got standardized
11:01:11 <EvanCarroll> would changing it be backwards compatable?
11:01:32 <ski> (well, i suppose it was for Haskell2010, but probably they didn't think it useful enough / serious to include)
11:01:57 <ski> EvanCarroll : good question. i'm not sure
11:01:59 <Molten> [ 10 ^ i | i <- [1..] ]
11:02:08 <ski> you need `> '
11:02:08 <Molten> @ski i used that one :D
11:02:08 <lambdabot> Maybe you meant: ask src wiki
11:02:08 <EvanCarroll> I read about it in LYAH under the Applicatives section
11:02:09 <litb> hmm why do some people write the last argument and the result in parentheses?  like  (a -> b) -> (a -> b)  instead of   (a -> b) -> a -> b   ?
11:02:15 <ski> Molten : ok, that's fine
11:02:16 <EvanCarroll> I asked a question on StackOverflow but got some shitty answers
11:02:22 <litb> is there a particular reason beyond style?
11:02:27 <Molten> BTW how do you get lambdabot to do haskell for you in irc?
11:02:31 <Cale> litb: Depends on how you're thinking about the function
11:02:32 <Molten> what do you type in?
11:02:33 <Twey> litb: Sometimes you want to emphasise the curried function it produces rather than the result of calling it
11:02:33 <EvanCarroll> also it was poorly worded =(
11:02:33 <ski> litb : it's more symmetric
11:02:51 <Cale> litb: If you're thinking of it as taking a function and producing another function, then it makes sense to write it like that.
11:03:14 <Twey> E.G. fmap is often seen :: (a -> b) -> (f a -> f b) to show that it converts a ‘pure’ function to a function on functors
11:03:17 <ski> litb : consider `map :: (a -> b) -> ([a] -> [b])'. that looks nicer to me than `map :: (a -> b) -> [a] -> [b]' or even `uncurried_map :: (a -> b,[a]) -> [b]'
11:04:11 <Twey> It's a nice artefact of currying that a unary function that lifts a function onto functors and a binary function that applies a function to a functor are one and the same
11:04:12 <ski> litb : same with `(.) :: (b -> c) -> (a -> b) -> (a -> c)'
11:04:40 <aristid> litb: (a -> b) -> (f a -> f b) looks much more symmetrical than (a -> b) -> f a -> f b :)
11:05:09 <ski> litb : of course, in practice, you often apply `map' to both arguments (and you don't need to write `(map f) as', then) .. but it is nice to be reminded of the partial application interpretation in the types
11:06:01 <ski> litb : similarly, i sometimes want a variant of `foldr' with arguments in another order : `(a -> b -> b) -> ([a] -> b -> b)'
11:06:37 <ski> @type flip . foldr
11:06:38 <lambdabot> forall b a. (a -> b -> b) -> [a] -> b -> b
11:07:05 <ski> Molten : you first write `> ', then a haskell expression
11:07:21 <ski> Molten : you can also say `@type <expression>' and `@kind <type expression>'
11:08:04 <ski> Molten : note that this also works to talk to lambdabot in private (`/msg lambdabot > reverse "foo"')
11:08:52 <ski> aristid : anyway, one law i suggested for `revFmap' was `forall f. revFmap . fmap = id'
11:09:01 <ski> s/forall f. //
11:09:11 <aristid> :t fmap
11:09:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:09:21 <roconnor> stupid Data/Control categories
11:09:24 <ski> aristid : the `fmap . revFmap = id' direction is not as obvious
11:09:28 <aristid> revFmap :: (f a -> f b) -> (a -> b) ?
11:09:36 <ski> yeah, for every `a' and 'b'
11:09:39 <ski> for specific `f's
11:10:10 * ski backtracks to look at aristid's `revFlip' code above
11:10:44 <ski> aristid : yeah, `\f -> point (extract . f) :: (Copointed f, Pointed f) => (a -> f b) -> f (a -> b)' seems sad ..
11:11:41 <ski> @type let revFlip f = (\a0 -> fst (f a0), \a1 -> snd (f a1) in revFlip
11:11:42 <lambdabot> parse error on input `in'
11:11:49 <ski> @type let revFlip f = (\a0 -> fst (f a0), \a1 -> snd (f a1)) in revFlip
11:11:50 <lambdabot> forall t a b. (t -> (a, b)) -> (t -> a, t -> b)
11:12:33 <ski> so, which of `flip . revFlip = id' and `revFlip . flip = id' is the most sensible, here ?
11:12:43 <ski> @type flip
11:12:44 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
11:13:40 <ski> i suppose `flip . revFlip = id' seems the more sensible one
11:14:02 <aristid> ski: hmm. revFlip must also become flip for functions
11:14:04 <ski> `flip' squishes a lot a functions which could do different things together, passing them always the same input
11:14:31 <ski> so `flip' seems like a candidate retraction, and `revFlip' its corresponding section
11:15:08 <roconnor> @seen jeffwheeler
11:15:08 <lambdabot> Unknown command, try @list
11:15:08 <preflex>  jeffwheeler was last seen on #haskell 27 days, 13 hours, 1 minute and 7 seconds ago, saying: dolio: haha, is it?
11:15:39 <ski> (similarly, `fmap' copies the same relationship between `a' and `b' to the whole map, while `revFmap' is trying to squish/extract out a single map from all parts, so `revFmap . fmap = id' appears the most sensible, there)
11:15:54 <ski> aristid : yeah, i expect that
11:16:10 <aristid> ski: i'm not sure if it is true for my definition of revFlip
11:16:43 <Molten> Hey guys, I'm really struggling with this... I need to implement a Reverse Add Then Sort algorithm... and for that I need to convert the integer eg 4123 to [4,1,2,3] I really don't know the best way to do this?
11:16:48 <ski> let's compute
11:16:50 <Twey> Are we teaching newbies about cofmap now? :þ
11:17:30 <aristid> Twey: are you referring to me as a newbie? :P
11:17:35 <fxr> hi, I'm looking at Control.Parallel.Strategies source and couldn't find how they make the bind operator of Eval as a strict bind? It's writen that the Eval is a strict identity monad, where is that strictness comes from?
11:17:52 <alex404> Molten: You can do map read . show, though that's not the best way
11:18:02 <ski>      flip (revFlip f)
11:18:03 <Molten> hmm
11:18:08 <ski>   =  flip (\a0 -> fst (f a0), \a1 -> snd (f a1))
11:18:29 <ski>   =  \a -> ((\a0 -> fst (f a0)) a,(\a1 -> snd (f a1)) a)
11:18:50 <ski>   =  \a -> (fst (f a),snd (f a))
11:18:57 <ski>   =  \a -> f a
11:19:00 <ski>   =  f
11:19:15 <McManiaC> is there a way to test on NaN/Inf ?
11:19:21 <Molten> Sorry ski I don't fully follow you :(
11:19:22 <ski> aristid : seems fine, assuming eta-conversion for pairs as well (which is not strictly true, in haskell)
11:19:24 <wisepumpkin> :t isNaN
11:19:25 <lambdabot> forall a. (RealFloat a) => a -> Bool
11:19:28 <wisepumpkin> :t isInf
11:19:29 <lambdabot> Not in scope: `isInf'
11:19:33 <wisepumpkin> hmm
11:19:35 <ski> Molten : i was talking to aristid for the moment
11:19:36 <monochrom> @src RealFloat
11:19:36 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:19:44 <Molten> ohh okay
11:20:03 <Molten> alex404... i get what you're doing
11:20:09 <Molten> though I'd rather not do it that way lol :P
11:20:18 <ski> Twey : hm, was `cofmap' the name that person used for `forall a b. (f a -> f b) -> (a -> b)' ?
11:20:21 <monochrom> :type isInfinite
11:20:25 <monochrom> @type isInfinite
11:20:26 <lambdabot> forall a. (RealFloat a) => a -> Bool
11:20:29 <Philonous1> When did the "fail" implementation for the Either monad change from Left to an exception?
11:20:53 <monochrom> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4 and look for RealFloat methods
11:21:09 <McManiaC> thx
11:21:17 <ski> Molten : hint, you probably want to use the `div' and `mod' (or better, `divMod') functions
11:21:21 <gapeme> yes hello
11:21:39 <ski> > either Left Right (fail "foo")
11:21:40 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:21:40 <lambdabot>    `Control.Monad.Error.Cla...
11:21:41 <monochrom> hrm, I wonder why atan2 is in RealFloat but not Floating
11:21:41 <Molten> @ski ATM I got this: reverseDig n = [n `mod` x | x <- divideToGetDigits]
11:21:41 <lambdabot> Maybe you meant: ask src wiki
11:21:58 <ski> > either Left (const (Right 'x')) (fail "foo"
11:21:59 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
11:22:05 <ski> > either Left (const (Right 'x')) (fail "foo")
11:22:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
11:22:06 <lambdabot>    `GHC.Show.Show a'
11:22:06 <lambdabot>      a...
11:22:17 <ski> > fail "foo" :: Either Int String
11:22:18 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Types.Int)
11:22:18 <lambdabot>    arising ...
11:22:20 <ski> > fail "foo" :: Either String String
11:22:21 <lambdabot>   Left "foo"
11:22:25 <aristid> :t > either Left (const (Right 'x')) (fail "foo")
11:22:26 <lambdabot> parse error on input `>'
11:22:30 <aristid> :t either Left (const (Right 'x')) (fail "foo")
11:22:31 <ski> Philonous1 : not in lambdabot, at least
11:22:31 <lambdabot> forall a. (Error a) => Either a Char
11:22:33 <monochrom> oh, now I know.
11:23:05 <alex404> Molten: If you want the nth single digit, do div x 10^n-1, and then take that and do mod x 10^n
11:23:08 <ski> (the "x13-1350006.4" anchors in the report are truly ugly ..)
11:23:09 <alex404> Molten: Or something like that
11:23:29 <ski> alex404 : better to extract the least significant digit, first, imo
11:23:37 <Molten> alex404: Ahh I'll give it a try!
11:23:47 <ski> Molten : s/@ski/ski :/
11:23:48 <Philonous1> ski: System.TimeIt> fail "abc" :: Either String a
11:23:48 <Philonous1> Loading package transformers-0.2.2.0 ... linking ... done.
11:23:49 <Philonous1> *** Exception: abc
11:24:06 <Blkt> good evening everyone
11:24:07 <Molten> ski: huh?
11:24:26 <monochrom> ski says don't use @ski. but you already know.
11:24:34 <ski> Molten : don't say `@someone something', say `someone : something' or `someone, something', &c.
11:24:56 <Molten> ski : like this? Sorry about second time using IRC
11:25:10 <alex404> ski: Yah fair enough
11:25:31 <ski> Molten : yeah, try typing the first couple of characters (like two or three) and pressing tab until the correct nickname appears
11:25:32 <monochrom> let's invade twitter and use "name: " to upset people
11:25:46 <Molten> ski ooh like this! :)
11:26:02 <ski> e.g., yes
11:26:20 <alex404> monochrom: That will be like throwing a pebble into a vast sea of nonsense. It will only remind you of your own insignificance.
11:26:42 <monochrom> make that a radioactive pebble
11:26:49 <roconnor> @hoogle in
11:26:50 <lambdabot> Network.Socket iN6ADDR_ANY :: HostAddress6
11:26:50 <lambdabot> Network.Socket iNADDR_ANY :: HostAddress
11:26:50 <lambdabot> Text.Parsec incSourceColumn :: SourcePos -> Column -> SourcePos
11:26:52 <alex404> Good point
11:26:57 <ski> (also try with other, longer names, like `mono<tab> thank you for teaching this lowly twitter user the ways of IRC' ;)
11:27:02 <ski> Molten : ^
11:27:37 <Philonous1> "@name" is much older than twitter. 
11:28:18 <ski> Philonous1 : ok, i didn't know that. where does it occur, earlier ?
11:28:36 <Philonous1> ski: I've seen it in web chats and IRC
11:28:37 <ski> Philonous1 : hm, i suppose having `fail s = Left (error s)' might be better
11:28:47 <monochrom> "@name" appearing here is newer than twitter. that's what matters in this context.
11:29:05 <ski> Philonous1 : i think they probably changed this to allow the `instance Monad (Either e)' instead of the obnoxious `instance Error e => Monad (Either e)'
11:29:43 <Twey> ski: I thought it was the usual name for the cofunctor operation
11:29:56 <ski> Twey : what do you mean by "cofunctor"
11:30:32 <ski> Twey : note that `forall a b. (f a -> f b) -> (a -> b)' is very different from `forall a b. (b -> a) -> (f a -> f b)'
11:30:32 <Philonous1> ski: Is that really what's going on? Why don't I see "Left ***exception: abc", surely Either didn't become strict overnight? 
11:30:41 <Philonous1> ski: Never mind, I'll just check the sources
11:31:02 <Twey> The… uh… inverse?… of the functor, class Cofunctor f where cofmap :: (f a -> f b) -> a -> b
11:31:05 <ski> Philonous1 : presumably because you have `fail = error' (the default method), instead of `fail s = Left (error s)', which i suggested might be better
11:31:06 <Twey> Oh, maybe that's so
11:31:51 <Twey> Oh, I don't know :þ
11:32:06 <ski> Twey : i've seen people use the naming `class CoFunctor f where cofmap :: (b -> a) -> (f a -> f b)' (or sometimes s/cofmap/cfmap/, i think) .. but note that this is bad naming
11:32:16 <Twey> Hm
11:32:26 <ski> Twey : that class describes what is known as "contravariant functors"
11:32:39 <ski> Twey : the ordinary `Functor' class describing "covariant functors"
11:33:26 <Twey> Hrm, okay
11:33:59 <onteria|i7> I'm wondering if "The Haskell Road to Logic, Math and Programming" is a good book for trying to learn the mathmatical concepts behind Haskell, as I find it hard sometimes to follow along with explanations of Haskell features because my math background isn't so hot.
11:34:08 <ski> (example instances of `ContraFunctor' are `Flip (->) b' and `IOWriteRef' (like `IORef' but for writing) and `Sink' (a possible variant of `Chan' for writing only))
11:34:28 <ski> Twey : i just wondered if by `cofmap' you maybe had the contravariant functors in mind
11:34:51 <Philonous1> Btw. it would be great if ghci could tell the path of imports that brought a particular definition/instance into scope
11:35:01 <ski> Twey : btw, i can't recall seeing the `forall a b. (f a -> f b) -> (a -> b)' operation on `f' being described in Category Theory
11:35:34 <Causalien> Hi everyone. Haskell newbie here. Just thought I'd introduce myself first before I start lurking around and absorbing knowledge.
11:35:37 <ski> onteria|i7 : try it, and report complaints^Wproblems here (and possibly to the author) ?
11:35:42 * ski hasn't read it
11:36:13 <ski> Causalien : hiya. just ask when you get any questions
11:36:24 <ski> io hope you've found a book or a tutorial to read from
11:36:38 <Twey> ski: I did, but pass on the CT :þ
11:36:59 <Cale> Causalien: Cheers! Don't be afraid to ask any questions you might have.
11:37:13 <ski> Philonous1 : indeed ! .. it's irritating (and confusing for newbies) to have implementation details exposed that way
11:37:14 <mikeg1> Is there a ByteString instance of Ord, so I can sort a [ByteString] ?
11:37:15 <aristid> ski: \f -> extract . f . point
11:37:16 <Twey> Causalien: Welcome o/
11:37:19 <Causalien> I will start once I finished some tutorials.
11:37:33 <Twey> Philonous1: Doesn't :i do that?
11:37:34 <Causalien> Thanks everyone. I am off to do some coding.
11:37:41 <ski> Philonous1 : imo, it should only use qualifications that are actually accessible in the current GHCi (or GHC) context
11:37:53 <litb> do you guys code in java or c++ or so or do you program FP for a living?
11:38:14 <Twey> class IsString a where fromString :: String -> a -- Defined in Data.String
11:38:24 <Cale> onteria|i7: A lot of the mathematics that's in it is not really stuff that you'd normally say underlies Haskell in any fundamental way, though there's some which does too.
11:38:34 <ski> aristid : so your `revFlip' for `Pair' seems to work fine, at least as regards that natural-sounding law ..
11:38:44 <Fuco> you can do FP for a living?
11:38:46 <Fuco> wow :D
11:39:09 <litb> hmm
11:39:17 <aristid> Fuco: it's insane. these days people can make money with art, and research and all kinds of crazy things
11:39:28 <jmcarthur> Fuco: some of us do. i'm trying
11:39:29 <mikeg1> Woops, it's in Data.ByteString :)
11:39:31 <Philonous1> Twey: No, :i only shows which module implemented it in the first place, but not how I (accidently?) imported it indirectly
11:39:38 <Twey> Philonous1: Ah
11:39:54 <conal> Causalien: welcome!
11:40:10 <Cale> litb: I'm working for iPwn on a game in Haskell for iPhones and other mobile devices.
11:40:14 <Fuco> hopefuly with new languages like F# or Scala FP can get more into foreground
11:40:23 <Fuco> C# and Java are pushing for some functional style as well
11:40:46 <ski> @type let point :: a -> f a; extract :: f a -> a; (point,extract) = undefined in \f -> point (extract . f)
11:40:46 <Causalien> Ummm. Question, should I change my environment to Linux? Or am I going to encounter strange problems under windows 7?
11:40:47 <lambdabot>     Cannot match a monotype with `forall a (f :: * -> *). a -> f a'
11:40:47 <lambdabot>       Expected type: (forall a (f :: * -> *). a -> f a,
11:40:47 <lambdabot>                       forall (f :: * -> *) a. f a -> a)
11:40:51 <onteria|i7> Python also has some fp in it. Not sure to what extent
11:41:03 <ski> @type let point :: a -> f a; extract :: f a -> a; point = undefined; extract = undefined in \f -> point (extract . f)
11:41:04 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *) (f2 :: * -> *). (Functor f1) => f1 (f a) -> f2 (f1 a)
11:41:13 <ski> @type let point :: a -> f a; extract :: f a -> a; point = undefined; extract = undefined in \f -> point (extract Prelude.. f)
11:41:14 <lambdabot> forall (f :: * -> *) a a1 (f1 :: * -> *). (a1 -> f a) -> f1 (a1 -> a)
11:41:24 <onteria|i7> ski: will do thanks. I hope I won't have problems though!
11:41:32 <monochrom> staying with windows is fine.
11:41:37 <ski> @type let point :: a -> f a; extract :: f a -> a; point = undefined; extract = undefined; (.) = (Prelude..) in \f -> point (extract . f)
11:41:38 <lambdabot> forall (f :: * -> *) a a1 (f1 :: * -> *). (a1 -> f a) -> f1 (a1 -> a)
11:41:39 <Causalien> Thkx mono.
11:41:54 <monochrom> you also enjoy WinGHCi
11:41:58 <ski> @type let point :: a -> f a; extract :: f a -> a; point = undefined; extract = undefined; (.) = (Prelude..) in \f -> extract . f . point
11:41:59 <lambdabot> forall (f :: * -> *) a a1 (f1 :: * -> *). (f1 a1 -> f a) -> a1 -> a
11:42:20 <ski> oh
11:42:25 <ski> @type let point :: a -> f a; extract :: f a -> a; point = undefined; extract = undefined in \f -> extract . f . point
11:42:26 <lambdabot> forall (f :: * -> *) a a1 (f1 :: * -> *). (f1 a1 -> f a) -> a1 -> a
11:42:38 <monochrom> use virtualbox to run linux if you suspect a windows-specific bug
11:42:40 <onteria|i7> Cale: For me it's just that I hate it when I hear about some particular feature that sounds cool, but has enough math background to it that I hit a roadblock and can't figure it out
11:42:55 <Causalien> Would cygwin be enough?
11:42:56 <onteria|i7> Cale: I've hit that with other programming languages as well
11:43:16 <Cale> onteria|i7: Like what? Essentially all the features of Haskell should be comprehensible without a significant mathematics background.
11:43:26 <ski> aristid : i see
11:43:28 <monochrom> cygwin is enough. ghc seems to like mingw more. I don't know the difference.
11:43:58 <Cale> onteria|i7: You might appreciate them more here and there if you know some category theory for example, but it should be possible to understand them without it.
11:44:02 <ski> Causalien : not required. but might be nice if you're familiar with unixy things
11:44:16 <monochrom> I haven't used either cygwin or mingw. I mostly use linux. But I sometimes try out things in windows with just console and notepad.
11:44:17 <litb> Cale ohh nice
11:44:23 <ski> Causalien : note that the default GHC for windows is non-Cygwin
11:44:56 <onteria|i7> Cale: I was watching this video lecture this morning on Data Parallel Haskell by Simon Peyton Jones, and there was talk about vectors of some sort that got hard to follow
11:45:18 <Cale> onteria|i7: Sparse vectors?
11:45:24 <onteria|i7> Cale: yes, that was it
11:45:45 <Molten> alex404: So far I got this: reverseDig n = [(n `mod` 10^(x)) `div` 10^(x-1) | x <- [1..INSERTHERE]] I'm not fully sure what to put at INSERTHERE though :(
11:45:53 <Cale> onteria|i7: Okay. So imagine you have a finite sequence of numbers, but you expect that most of them will be 0.
11:46:12 <onteria|i7> Cale: okay following along
11:46:43 <alex404> Molten: Have you tried just sticking a random number in there?
11:46:55 <ski> Molten : i think using  n `mod` 10  and  n `div` 10  (or  n `divMod` 10  ), recursively using the result would be easier than doing that iterative thing
11:47:08 <Cale> onteria|i7: That's what the "sparse" part means -- that nearly all of them are expected to be 0. So the obvious representation in that case is to store the indices of where the nonzero elements occur, along with their values.
11:47:18 * monochrom trolls alex404 with "but how do I generate a random number" :)
11:47:32 <ski> (hm "sparse" is a bit similar to "finite support", i think)
11:47:39 <onteria|i7> Cale: ah, that makes sense
11:47:39 <ski> monochrom : `4'
11:47:47 <aristid> monochrom: that's where unsafePerformIO becomes very useful.
11:47:52 <alex404> Close eyes. Hit keyboard.
11:47:55 <monochrom> \∩/
11:48:18 <Molten> alex404: basically I did 1..3 and it worked :) But don't know how to figure out what number to make it stop at
11:48:23 <Cale> onteria|i7: He also talks about computing the dot product of two sparse vectors. The dot product of two vectors is just the sum of the products of corresponding elements. So, the dot product of (a,b,c) and (x,y,z) is ax + by + cz, for instance.
11:48:35 <Molten> ski: recursively...
11:48:39 <Cale> Or maybe it was sparse*dense multiplication, I forget.
11:48:46 <ski> Molten : instead of using a list comprehension and `[1 .. ?]', use recursion
11:48:59 <Molten> ski: what exactly should I make my base case?
11:49:01 <ski> > 142857 `mod` 10
11:49:01 <lambdabot>   7
11:49:04 <ski> > 142857 `div` 10
11:49:05 <lambdabot>   14285
11:49:06 <ski> > 14285 `mod` 10
11:49:07 <lambdabot>   5
11:49:09 <ski> > 14285 `div` 10
11:49:10 <lambdabot>   1428
11:49:11 <ski> > 142 `mod` 10
11:49:12 <alex404> Molten: I'm not trying to be rude, but you're not really asking a haskell question, and I'm not here to do your homework ;) You're on the right track. Just play around some more.
11:49:12 <lambdabot>   2
11:49:22 <Molten> oooh
11:49:22 <ski> er, &c. anyway, until you reach zero
11:49:59 <Molten> alex404: Haha yeah sorry... your 'nudge' got me in the right direction anyways :P
11:50:11 <litb> lulz
11:50:13 <Molten> ski: I get what you mean I'll try that :)
11:50:22 <ski> Molten : note that
11:50:26 <onteria|i7> Cale: I see.. I think I should just step back a bit, keep on with the learn you haskell for great justice tutorial I'm working with, and actually wait till I'm completely confused before I stop and ask for clarification
11:50:29 <ski> > 142857 `divMod` 10
11:50:30 <lambdabot>   (14285,7)
11:50:32 <ski> > 14285 `divMod` 10
11:50:32 <lambdabot>   (1428,5)
11:50:34 <ski> &c.
11:50:45 <onteria|i7> Cale: I think I'm spending too much time expecting the worst and less time actually sitting down and learning things
11:50:54 <Molten> ski: OMG I didn't even know divMod existed!
11:51:00 <ski> Molten : so you can compute both `div' and `mod' at the same time (that might be slightly more efficient)
11:51:03 <Cale> onteria|i7: That is sort of a mathematical example, but it's sort of intended as an example of an application, rather than a key part of the language features.
11:51:17 <Molten> ski: A lot more... I'll see what I can do about this
11:51:46 <ski> Molten :  n `divMod` d = (n `div` d,n `mod` d)  -- but possibly implemented a little bit more efficiently
11:52:40 <Molten> ski: Basically the right side part of the tuple is what I should output isn't it?
11:53:04 <ski> onteria|i7 : it is probably better to ask when you're a bit confused, rather than completely confused. in the former case, hopefully it will take less time to remove the confusion
11:53:32 <ski> Molten : yeah, the right hand side parts will be the digits (as numbers), in base ten
11:53:41 <kamoricks> I'm having a bit of trouble implementing a math procedure: http://eugeneciurana.com/pastebin/pastebin.php?show=43582 (question, not code) <- What's the logic behind what I need to do here? (The paper calls it a "downward closure")
11:53:56 <ski> Molten : if you want to convert to digits in a string, you'll need to convert from numbers to characters
11:54:12 <ski> > intToDigit 4
11:54:13 <lambdabot>   '4'
11:54:21 <ski> > intToDigit `map` [0 .. 9]
11:54:21 <lambdabot>   "0123456789"
11:54:24 <ski> > intToDigit `map` [0 .. 15]
11:54:24 <lambdabot>   "0123456789abcdef"
11:54:33 <ski> > intToDigit `map` [0 .. 35]
11:54:33 <lambdabot>   "0123456789abcdef*Exception: Char.intToDigit: not a digit 16
11:54:38 <Molten> ski: what about digit to int?
11:54:45 <ski> @type digitToInt
11:54:46 <lambdabot> Char -> Int
11:54:56 <ski> that's if you want/need to go in the other direction
11:55:19 <Molten> ski: ahh okay
11:55:20 <ski> you shouldn't in any case convert back and forwards inside the main algorithm
11:55:29 <ski> only convert at the interfaces, if you need to
11:56:05 <ski> > digitToInt ['A' .. 'Z']
11:56:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
11:56:06 <lambdabot>         against inferred type...
11:56:10 <ski> > digitToInt `map` ['A' .. 'Z']
11:56:11 <lambdabot>   [10,11,12,13,14,15,*Exception: Char.digitToInt: not a digit 'G'
11:57:00 <Evious> What are the requirements for getting a hackage account, and uploading a package?
11:57:29 <Saizan> asking for one
11:57:33 <tonkman> digitToInt is onyl for hex digits
11:57:38 <ski> kamoricks : paste your current Haskell code ?
11:57:39 <Evious> The last time I looked at it, I got an intimidating-looking email asking me about my online blog and repository presence, which intimidated me the hell out :D
11:57:42 <ski> @where paste
11:57:42 <lambdabot> <http://hpaste.org/>, <http://paste.lisp.org/new>, <http://codepad.org/>
11:57:43 <onteria|i7> Cale, ski: thanks for all the suggestions and help! Time to lunch and code some haskell
11:57:50 <Evious> That was a while ago, though. And I've got a github page now.
11:57:57 <ski> onteria|i7 : yw
11:58:38 <Evious> Request for feedback on library package: is this useful?  https://github.com/amtal/tables
11:58:54 <ski> tonkman : yeah, but why not go all the way to the common base-36 encoding, then ?
11:59:31 <Saizan> Evious: the idea is to have some confidence that you're a real person :)
11:59:48 <tonkman> just saying, I just saw "digitToInt" and some exceptions
11:59:52 <stroan_> does anyone know any algorithms for distributing data across networks of peers. for doing replication and redundency stuffs. Just need a starting point for my googling really
12:01:18 <Evious> stroan_, for ordering there's Lamport time stamps, and then vector clocks. Ordering and reliable messaging being the main requirements afaik.
12:01:37 <Evious> Then there's the byzantine generals problem, eventual consistency, DHTs...
12:01:48 <stroan_> ah, perfect. many thanks
12:02:49 <Molten> alex404: I figured it out! :D
12:03:01 <alex404> Molten: Cheers :)
12:03:07 <Molten> ski: Thanks a lot for that... I'll go on with the question and get back to you guys with what happens :)
12:03:22 <Molten> alex404: Thanks a lot :) I'll get back to you when I progress more :)
12:04:21 <kamoricks> ski: http://hpaste.org/41651/bad_attempt has the bad attempt. ghc keeps complaining about indention. And I probably need to pick an easier project to learn haskell, but I thought that familiarity with F# would go farther than it did.
12:04:51 <aristid> kamoricks: you forgot to close the paren
12:05:08 <aristid> add an ) to the end
12:05:31 <aristid> kamoricks: also, if needs an else
12:05:37 <aristid> if-then-else, not just if-then
12:08:28 <sm> remove old package versions broken by upgrades: alias ghccleanpkgs="for p in `ghc-pkg check 2>&1  | grep problems | awk '{print $6}' | sed -e 's/:$//'`; do echo unregistering $p; ghc-pkg unregister $p; done"
12:09:38 <aristid> sm: i think i'd use cut instead of awk
12:09:57 <sm> I tried that first, but couldn't figure out how to drop the last char
12:13:03 * sm gets hakyll updating his page again after rebuilding the world
12:13:37 <kamoricks> Okay. http://hpaste.org/paste/41651/test_and_merge_for_two#p41652 compiles and runs, but only works for two. Assuming that I know what's in AB, and what's in BC, how would I get ABC? I don't want to have to check A cross B cross C, since every A would have a B and every B would have a C.
12:15:48 <ski> kamoricks : i'm not quite sure what you're actually wanting
12:16:04 <jmcarthur> kamoricks: you mean you want some foo such that   foo (merge a b) (merge b c) = merge a (merge b c)  ?
12:16:05 <ski> could you provide a small test example, with the expected output ?
12:16:43 <monochrom> I hope the example does not look like random output to you.
12:17:36 <Cale> kamoricks: Maybe you could just sum the lists beforehand, and then filter out the elements you're interested in?
12:17:38 <ski> (a sensible test case can go a long way towards removing wrong interpretations)
12:17:57 * ski is still not sure whether kamoricks wants a join, or something else
12:18:15 <ski> (`join' in the Database sense ..)
12:18:15 <Cale> Yeah, I'm not really sure either.
12:18:17 <kamoricks> The idea is that the list is too large to apply this operation to every element. I'll attempt to do a test case real quick.
12:18:27 <monochrom> oh, for the author's own sake, yes.
12:19:09 <ski> monochrom : and hopefully also for deciphering <http://eugeneciurana.com/pastebin/pastebin.php?show=43582>
12:19:12 <Cale> kamoricks: So, you're looking for pairs of corresponding elements for which the sum is larger than 5. What generalisation of that to three lists do you want?
12:19:31 <jmcarthur> > let merge xs ys = filter ((>5) . uncurry (+)) $ zip xs ys in merge [1,2,3] [1,2,3]
12:19:32 <lambdabot>   [(3,3)]
12:19:35 <ski> Cale : see that link you too, if you haven't yet
12:20:28 <monochrom> I think it can't be deciphered, not even with examples, because there is a "the predicate" unspecified.
12:20:34 <jmcarthur> kamoricks: you hint at AxBxC... you realize that your merge function is not checking every combination of elements, right?
12:20:46 <jmcarthur> kamoricks: it's only checking them component-wise
12:21:27 <ski> monochrom : "the predicate" might be the one implemented by the association list, e.g.
12:21:54 <jmcarthur> > let merge xs ys = [(x,y) | x <- xs, y <- ys, x + y > 5] in merge [1..5] [1..5]
12:21:55 <lambdabot>   [(1,5),(2,4),(2,5),(3,3),(3,4),(3,5),(4,2),(4,3),(4,4),(4,5),(5,1),(5,2),(5...
12:22:34 <ski> > let merge xs ys = [(x,y) | x <- xs, y <- ys, x + y > 5] in merge [1..3] [1..3]
12:22:35 <lambdabot>   [(3,3)]
12:22:41 <jmcarthur> > let merge xs ys = filter ((>5) . uncurry (+)) $ liftA2 (,) xs ys in merge [1..5] [1..5]
12:22:41 <lambdabot>   [(1,5),(2,4),(2,5),(3,3),(3,4),(3,5),(4,2),(4,3),(4,4),(4,5),(5,1),(5,2),(5...
12:22:42 <ski> > let merge xs ys = [(x,y) | x <- xs, y <- ys, x + y > 5] in merge [1..4] [1..4]
12:22:43 <lambdabot>   [(2,4),(3,3),(3,4),(4,2),(4,3),(4,4)]
12:24:28 <Molten> hey quick question... say I have a list [4,3,2] and [100,10,1] how to I define a function the returns a list [400,30,1]? Till now I can only get every element dividing with every element which is what I don't want!
12:24:48 <Molten> [400,30,2] sorry
12:24:48 <paolino1> :t zipWith
12:24:49 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
12:24:56 <Molten> ooh
12:24:58 <Molten> Thanks
12:26:00 <megatron242> Hi, a small question: I'm trying to do a bitwise or operation: a `.|.` b. The compiler doesn't like it. Any ideas?
12:26:20 <mauke> megatron242: a .|. b
12:26:20 <monochrom> add some type annotations or signatures.
12:26:29 <monochrom> > 5 .|. 3
12:26:30 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:26:30 <lambdabot>    `Data.Bits.Bits a'
12:26:30 <lambdabot>      a...
12:26:36 <monochrom> you were seeing that.
12:26:42 <ski> > 126 .|. 48 :: Integer
12:26:43 <lambdabot>   126
12:26:43 <monochrom> > 5 .|. 3 :: Word8
12:26:44 <lambdabot>   7
12:26:46 <mauke> > 5 `.|.` 3
12:26:46 <lambdabot>   <no location info>: parse error on input `.|.'
12:26:49 <monochrom> happiness ensues
12:27:05 <ski> > (.|.) 5 3 :: Integer
12:27:06 <lambdabot>   7
12:27:16 <osaunders> :t (.|.)
12:27:17 <lambdabot> forall a. (Bits a) => a -> a -> a
12:27:37 <osaunders> :i Bits
12:27:39 <megatron242> I thought that if a function is between to arguments, it needs to be surrounded by ``.
12:27:40 <paolino1> @instances Bits
12:27:41 <lambdabot> Couldn't find class `Bits'. Try @instances-importing
12:28:10 <ski> @instances-importing Data.Bits Bits
12:28:11 <lambdabot> Int, Integer
12:28:11 <monochrom> % is a function between two arguments and does not need ``
12:28:18 <monochrom> > 4 % 2
12:28:19 <lambdabot>   2 % 1
12:28:33 <ski> @instances-importing Data.Bits Data.Word Bits
12:28:33 <lambdabot> Int, Integer, Word, Word16, Word32, Word64, Word8
12:28:35 <megatron242> OK, so it's a special case..
12:28:37 <Cale> megatron242: That's if it's not made of symbol characters. Names composed of symbols are infix by default.
12:28:57 <monochrom> mod is a function between two arguments and needs ``
12:29:03 <monochrom> > 5 `mod` 4
12:29:04 <lambdabot>   1
12:29:16 <megatron242> Also, I couldn't find in the Bits module docs, how to do bitwise "not" operation.
12:29:27 <ski> megatron242 : ordinary function identifiers, like `elem' and `div' needs those, to be turned into infix operators, but things like `%' and `+' are already infix operators
12:29:38 <mauke> @hoogle (Bits a) => a -> a
12:29:38 <lambdabot> Data.Bits complement :: Bits a => a -> a
12:29:38 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
12:29:38 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
12:29:46 <mauke> megatron242: complement
12:29:48 <monochrom> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Bits.html#v%3Acomplement
12:29:49 <ski> megatron242 : in the other direction, you turn an infix operator into an expression on its own by `(%)'
12:29:55 <megatron242> Thank!
12:30:13 <megatron242> The most usefull IRC room I've ever been to :)
12:30:14 <ski> > complement 0 :: Integer
12:30:15 <lambdabot>   -1
12:30:24 <ninly> > (%) 4 2
12:30:25 <lambdabot>   2 % 1
12:30:32 <monochrom> > 5 `shift` 1
12:30:33 <lambdabot>   Ambiguous type variable `a' in the constraint:
12:30:33 <lambdabot>    `Data.Bits.Bits a'
12:30:33 <lambdabot>      a...
12:30:34 <ski> @source Data.Bits
12:30:34 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bits.hs
12:30:35 <ninly> mod 5 4
12:30:37 <monochrom> > 5 `shift` 1 : Word8
12:30:37 <lambdabot>   Not in scope: data constructor `Word8'
12:30:38 <ninly> >mod 5 4
12:30:42 <monochrom> > 5 `shift` 1 :: Word8
12:30:43 <lambdabot>   10
12:30:48 <ski> > mod 5 4
12:30:48 <lambdabot>   1
12:30:53 <ninly> thanks :)
12:30:55 <ski> > 5 `mod` 4
12:30:56 <lambdabot>   1
12:31:08 <ski> ninly : you forgot the space after the `>'
12:31:26 <ninly> yeah my thumb missed the bar on this netbook.
12:31:40 <monochrom> @type foldl
12:31:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:32:04 <monochrom> > ((+) `foldl` 0) [1,1,1,1]
12:32:05 <lambdabot>   4
12:32:17 <ski> megatron242 : note that you can use  `foo`  for any name at all (iirc, that assumes  infixl 0  `foo`  then, if nothing else is declared)
12:32:47 <ski> > 2 `Node` []
12:32:48 <lambdabot>   Node {rootLabel = 2, subForest = []}
12:32:56 <ski> > (3 `Just`)
12:32:57 <lambdabot>   Just 3
12:33:00 <ninly> here's a question, then: a lot of the intro stuff i have read (lyah and rwh, mostly) recommend using infix notation (with the backticks) for certain functions -- is that mainly a convenience for beginners, or is it something experienced haskellers continue to use?
12:33:43 <ski> ninly : we usually use infix for when it's conventional, and when it makes code more readable
12:34:03 <monochrom> you decide when to use infix. for example "div 5 4" looks wrong to most people, they like "5 `div` 4". I'm sure you like it too.
12:34:25 <ninly> actually i don't, that's why i asked! i use an RPN calculator
12:34:29 <monochrom> ((+) `foldl` 0) [1,1,1,1] is just being naughty.
12:34:34 <Boxo> (flip f) b = (`f` b) -- that's nice
12:34:39 <monochrom> oh, RPN, you're doomed.
12:34:42 <ski> @src elem
12:34:42 <lambdabot> elem x    =  any (== x)
12:34:51 <ninly> which is different, but it has loosened my expectations for argument orders
12:34:54 <ski> hm, doesn't that have a fixity declaration ?
12:35:02 <monochrom> just follow your heart
12:35:30 <ninly> hah ok :) where necessary i will comment judiciously
12:35:37 * ski wonders whether RPN calculators actually use RPN .. or instead a stack
12:35:58 <proq> > (flip f) b
12:35:59 <lambdabot>   No instance for (GHC.Show.Show (f b))
12:35:59 <lambdabot>    arising from a use of `M4887350882...
12:36:03 <revenantphx> RPN is a style of notation, not an implementation no?
12:36:04 <monochrom> RPN as UI, stack is implementation detail
12:36:09 <revenantphx> monochrom: ^
12:36:16 <monochrom> revenantphx: ^
12:36:16 <ninly> ski, they use a stack, if i understand correctly
12:36:18 <ion> RPN is by definition based on a stack.
12:36:29 <revenantphx> It doesn't have to be though...
12:36:33 <revenantphx> I could implement it as a binary tree.
12:36:34 <ion> at least in the context of RPN calculators
12:36:42 <Boxo> @unpl (flip f) b
12:36:42 <lambdabot> (\ d -> f d b)
12:36:45 <revenantphx> Makes me think of haskell zipper monads actually.
12:36:48 <monochrom> you can just do term rewriting on RPN directly if you like
12:36:50 <revenantphx> But I don't know much about those...
12:37:01 <ski> afaiuc, RPN is each operator has a lexically known arity, so no brackets are needed, and the operator are written last
12:37:11 <ski> i.e. mirrored Polish notation
12:37:11 <EvanCarroll> if you understand monads, how much more difficult is it to understand comonads?
12:37:15 <monochrom> yes, fixed arity is key
12:37:31 <paolino1> :t (3 `Just`)
12:37:31 <monochrom> comonad is co-difficult to understand
12:37:32 <lambdabot> forall t. (Num t) => Maybe t
12:37:40 <djahandarie> EvanCarroll, it'd harder to think of what they'd be used for
12:37:43 <ski> with stack you can do `2 dup *', which you can't do in a pure RPN
12:37:44 <djahandarie> Since they aren't used as much
12:38:04 <EvanCarroll> hrm fair enough
12:38:24 <EvanCarroll> I just saw them on hackage and was wondering how complex they are
12:38:30 <djahandarie> Not complex
12:38:38 <Boxo> Monad Reader #14 had a way to write down binary trees without parenthesis with RPN, it was cool
12:38:44 <monochrom> find a tutorial with a million examples.
12:38:49 <djahandarie> The Cofree Comonad is particularly cool
12:38:54 <ski> EvanCarroll : i guess one could say we're still feeling them out, looking for applictions they might be useful for
12:39:07 <monochrom> oh, so there are not a million examples
12:39:13 <djahandarie> Cofree Identity is an infite stream, Cofree [] is a rose tree, Cofree Maybe is a stream
12:39:21 <djahandarie> infinite*
12:39:46 <ski> djahandarie : s/infinite stream/stream/ & s/stream/potentially finite stream/ ;)
12:40:08 <djahandarie> Yeah yeah
12:40:29 * ski wants to reserve the unqialified "stream" for the unconditionally infinite case
12:40:53 <megatron242> :r
12:40:53 <monochrom> in some communities "stream" is finite.
12:41:06 <megatron242> Oops, wrong terminal :)
12:41:15 <roconnor> I'm thinking of slicing out a Haskell 98 portion of category-extras
12:41:17 <monochrom> when iTunes says "streaming video" no one wants it infinite :)
12:41:24 <djahandarie> megatron242, again? :P
12:41:25 <ski> #haskell reloaded, no files needed to be compiled
12:41:36 <megatron242> No, the first time ;)
12:41:38 <djahandarie> roconnor, do it
12:41:45 <djahandarie> megatron242, I distinctly remember this happening before
12:42:09 <megatron242> With three open terminals, you might be right...
12:42:28 <ski> megatron242 : have you tried GNU screen ?
12:42:43 <monochrom> the real questions is why do you tolerate your irc software looking visually indistinguishable from terminals.
12:42:49 <ninly> i have to re-up my familiarity with screen
12:43:02 <djahandarie> Three open terminals? That only happens on my system after a reboot
12:43:04 <mauke> monochrom: because it runs in a terminal
12:43:15 <djahandarie> mauke, but you can change the colors!
12:43:25 <mauke> they're still terminal colors
12:43:36 * ski waits for the 70s quote ..
12:43:39 <djahandarie> Unless you change the terminal's colors!
12:43:52 <megatron242> I'm using screen on a Linux machine. Right now, I'm on windows + cygwin
12:43:54 <monochrom> observe that none of one using xchat etc ever wrongly enter "rick rolled" into irc and then go "oops, that was for google".
12:44:07 <monochrom> s/one/us/
12:44:14 <mauke> except they do
12:44:25 <ninly> i liked "none of one"
12:44:37 <onteria|i7> I've see people with gui clients messup on /join a few times
12:44:46 <mauke> also, I sometimes enter browser commands in my irc window, but I notice before I hit <enter>
12:44:48 <djahandarie> I'd really like some rendition of irssi which actually properly formated your text in a GUI, but was still keyboard-driven
12:44:49 <onteria|i7> but that's somewhat different
12:45:05 <ski> megatron242 : there's screen for cygwin
12:45:19 <mauke> fortunately ^L is basically a no-op in irssi
12:45:25 <megatron242> ski : I tried it a while ago, and it wasn't that good.
12:45:40 <paolino1> 5th google on cofree+monad link is monad lisa coffee 
12:45:48 <proq> djahandarie: you can run irssi in ansi-term mode in emacs
12:46:16 <djahandarie> paolino1, maybe cofree comonad would do better :P
12:46:25 <djahandarie> It does :)
12:47:07 <onteria|i7> curious, are there still some activity on newsgroups for haskell or is it pretty much just mailing lists now?
12:47:09 <djahandarie> Comonads are not monads! They are the categorical dual of monads!
12:48:02 <kamoricks> I'm having a bit of trouble implementing a mathematical algorithm. http://hpaste.org/41654/attempt_with_test_case has the problem description, a bad attempt at solving it, and the test case I'm running against. What should be the thought process to get from output one to output 2?
12:51:04 <sm> has anyone got a one-liner to extract a cabal file's description field ?
12:51:45 <ski> kamoricks : next time, try to annotate the original paste (here <http://hpaste.org/41651/bad_attempt>) instead of making separate pastes
12:52:18 <kamoricks> ski: Okay. Sorry.
12:52:52 <jaredj> @check 1 == error "foo"
12:52:53 <lambdabot>   "*Exception: foo
12:53:06 <kamoricks> (Also apologize for the long delay. I was tasked with moving heavy things around.)
12:53:34 <ski> kamoricks : can you explain why you want those two stages of output, for the inputs `[1, 2]', `[2, 3]', `[4, 5]' ?
12:55:41 <kamoricks> ski: First would run merge over ( [1,2] [2,3]), giving all pairs of points that add up to five, which would be [(2,3)] (a single tuple) for those two. Next step would do the same, but for [2,3] and [4,5], giving the second set of results, and the final one woudl be [1,2] and [4,5]. Stops there, since the predicate (addition) is communitive.
12:56:08 <ski> jaredj : however, see
12:56:09 <ski> @hoogle mapException
12:56:09 <lambdabot> Control.Exception mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
12:56:09 <lambdabot> Control.OldException mapException :: (Exception -> Exception) -> a -> a
12:56:09 <lambdabot> Control.Exception.Base mapException :: (Exception e1, Exception e2) => (e1 -> e2) -> a -> a
12:57:22 * ski wonders why that isn't `forall e0. Exception e0 => (e0 -> exists e1. Exception e1 *> e1) -> (a -> a)', then realizes that's probably `forall e. Exception e => (e -> SomeException) -> (a -> a)'
12:58:11 <sm> cat cabalfile | perl -ne 'print if (/^description:/../^$/)' , if there's a blank line after the desc.. close enough
12:58:24 <ski> kamoricks : all pairs of points that add up to five, where the first component of the pair comes from the first list, and the other component comes from the other list ?
12:58:34 <kamoricks> ski: Right.
12:59:17 <ski> kamoricks : ok, i follow to stage 1, then
12:59:21 <ski> what about stage 2 ?
13:00:57 <kamoricks> Stage 2 we take the results from stage 1, and combine them. We know that every pair resultant from the first stage adds to five, so we try to match the first of each pair. If there's a match, we create a new tuple of the first item, plus the two parts that don't match. Every triplet now sums to greater than five, and we don't have to add again.
13:01:33 <paolino1> ah triplets
13:02:14 <ski> "so we try to match the first of each pair" <- match it against what ?
13:02:26 <kamoricks> The first item of each other pair in the results.
13:02:50 <paolino1> the filtered out ones
13:03:07 <paolino1> ?
13:03:55 <kamoricks> The first item from each pair of the results from stage 1 are checked against the first item of each other pair from the results of stage 1.
13:04:11 <ski> e.g., explain in more detail why the triple `(2, 3, 4)' is in the output stage 2 `[(2, 3, 4), (2, 3, 5)]', reasoning from the data in output stage 1 `[[(2, 3)], [(2, 4), (2, 5), (3, 4), (3, 5)], [(1, 4), (1, 5), (2, 4), (2, 5)]]'
13:05:04 <ski> hm, so you're actually doing this matching on `[(2, 3), (2, 4), (2, 5), (3, 4), (3, 5), (1, 4), (1, 5), (2, 4), (2, 5)]' rather than on `[[(2, 3)], [(2, 4), (2, 5), (3, 4), (3, 5)], [(1, 4), (1, 5), (2, 4), (2, 5)]]' ?
13:05:27 <augur> monads!
13:05:39 <ski> or are you matching the first component of each pair in each list against the pairs only in the other (or later ? or succedent ?) lists ?
13:05:48 <kamoricks> Sort of. (3, 4, 5) isn't included in the output, becuase (3,4) and (3,5) are in the same list. (2,3) has a (2,4) in a different list, so (2,3,4) is in the output.
13:05:51 <augur> chris barker decided that list monads are the appropriate way to handle certain linguistic semantic facts
13:05:58 <augur> relating to possible worlds
13:06:24 <kamoricks> And (2,4,3) isn't included because it's the same as (2,3,4).
13:06:42 <ski> kamoricks : so `(2, 3)' being in the first list and `(2, 4)' in the last list is a valid reason for including `(2, 3, 4)' in the result list ?
13:06:48 <kamoricks> Yes.
13:07:10 <ski> ok, so the compared pairs don't need to come from adjacent lists, only from different lists
13:07:16 <paolino1> 3 and 4 comes from the second list 
13:08:02 <ski> .. but i suppose you don't care for taking the second pair of the comparision from an earlier list than the first pair, since that means that if `(x, y, z)' is included, then `(x, z, y)' will also be included (unless you filter it out afterwards)
13:08:23 <ski> augur : not set or bag monads, then ?
13:09:44 <augur> ski: apparently not!
13:10:01 <ski> why the ordering is relevant (generally) ?
13:10:11 <kamoricks> The idea is to go from first to last, so that the algorithm is stable (to preserve sorted data). Could filter them out later.
13:10:11 <ski> (i can see how in specific cases ordering can be important)
13:10:52 <ski> kamoricks : is it a problem if you get duplicate triples in the output (due to different pairs) ?
13:11:17 <ski> kamoricks : or "duplicate, up to swapping of the last two components of the triple, at most", i.e.
13:11:21 <kamoricks> Yes. The result needs to be unique, since the result of this algorithm is passed to one which counts occurances versus totals.
13:12:13 <kamoricks> Or, rather, elaborate, since I'm not sure what I said applies?
13:13:11 <roconnor> > 5 : [6] >>= \x -> [x,x]
13:13:12 <lambdabot>   [5,5,6,6]
13:13:17 <roconnor> > 5 : ([6] >>= \x -> [x,x])
13:13:18 <lambdabot>   [5,6,6]
13:13:32 <Molten> hey ski are you familiar with RATS by any chance? :\
13:13:35 <roconnor> heh, I have a bug
13:14:19 <Molten> ski: are you familiar with the RATS sequence by any chance? :\
13:14:33 <ski> kamoricks : so if the inputs are `[3,4]',`[3]',`[4]', then the stage 1 outputs are `[[(3,3),(3,4)],[(3,4)],[(3,4),(4,4)]]' so the stage 2 outputs are `[(3,3,4),(3,4,4),(3,4,4)]' i think .. unless you remove that duplicate solution
13:14:54 <sproingie> Molten: Roberts, Alito, Thomas, and Scalia?
13:14:56 <kamoricks> ski: That's fine.
13:15:10 <ski> Molten : only as "Rapid Access Transport System" in "Eye of the Beholder" game :)
13:15:17 <Molten> sproingie: LOL
13:15:22 <Molten> ski: LOLOL xD
13:15:34 <Molten> hold on
13:15:41 <ski> rats ..
14:06:46 --- topic: '["GHC 7 is out: http://is.gd/hb8vE", "Haskell Platform 2010.2: http://is.gd/dCGPn", "Haskell 2010 is out: http://hackage.haskell.org/trac/haskell-prime/wiki#Status", "Haskell News: http://reddit.com/r/haskell", "The Haskell programming language", "http://haskell.org", "Paste: http://hpaste.org", "Logs: http://tunes.org/~nef/logs/haskell/"]'
14:06:46 --- topic: set by monochrom!trebla@toronto-hs-216-138-220-146.s-ip.magma.ca on [Mon Nov 15 18:51:15 2010]
14:06:46 --- names: list (clog djl aconbere kwos Kaidelong rryan` pkrumins rubendv d3910584193 timebomb Boxo lispy proq faust45 knobo` lokydor dysinger dom96 LouisJB Dashkal willb Eridius JoeyA goldbergus bos bench1 thetallguy1 jrib alvivi hoknamahn zachk twanvl_ tensorpudding abcd- danharaj _nickel erg0t olauzon jeltsch bgs100 Ziphilt traviscj xenyl levitation[A] JaffaCake1 revenantphx snorble imran_sr megatron242 ion Jantaro dolio ninly fgump jsgf alek_br_ Martijn_ MigoMipo)
14:06:46 --- names: list (osaunders Obfuscate hotaru2k3 basti_ arnihermann IIcke ofeone Blkt gapeme MrFahrenheit brachiel asflierl Icewing ski baba_bubba raichoo slaye joerisamson Evious tcatipax phenom_ luckman212 BCoppens mrsolo Fullma lispy_ mjrosenb c_wraith panopticon Rayne hc SyntaxNinja fengshaun tapwater fruight ivan`_ lopex ivan wisemanby babusri ceii dRbiG carlocci sm programble krainboltgreene dnm MayDaniel idoru cozmic_ RayNbow dimmy path[l] arcatan damex mun lars9 dual)
14:06:46 --- names: list (Palmik wisepumpkin leo2007 roconnor Philonous1 litb Darkone augur wuj danten dschoepe Nibble kaustuv Ke Athas psychicist_ ksf_ ddilinger sbahra THC4k amiri fryguybob diPython FireFly Axman6 lomeo edon mceier integral jsk Fuco writer phyrex1an hrehf MoALTz novas0x2a ricky danvet ormaaj jmv nocture Azrael- dibblego lanthan_afh gdsx caligula_ araujo joeytwiddle Zeiris xinming_ thetallguy dogmaT Rutix xarch_ insomniaSalt arrummzen s76__ clanehin m3ga hackagebot)
14:06:46 --- names: list (engla Alleria janbanan ExtraSpice BigBlackDog msieradzki shintah jb55 monochrom orclev mileschet iNode onteria ps-auxw otto_s srh wasabisnooters jonafan_ leoncamel Apocalisp MrAI znutar ernst mejalx joe6 wagle Draconx|Laptop hgolden jrockway dancor skaar theorbtwo mightybyte Cobra Khisanth sohum shachaf cheater99 sonnym cpa perlite ville orlandu63 somnium slabanja gueux Vq parshime1s vili hzh qz onteria|i7 dmarker HWSOD Sunhay _sh3 mee JimmyRcom __nickm__)
14:06:46 --- names: list (kalven sophacles gbeshers prokos profmakx Alan adnam EvilAdmin felipe_ kl0n thoughtpolice geekounet drbean Muad_Dibber__ dMazz Paradox924X nchaimov Valodim jvoorhis_ dcolish ankit9 b_jonas ninegrid wires ilab stepkut jaspervdj sixpoint8 Starfire jmcarthur Cthulhon| srcerer OnionKnight danly hellige beek jon_of_arc dropdrive lostman blackrain andersk kadoban preflex Quadrescence PsiOmega liyang Mitar CalJohn dariusH kmc kermit Saizan quicksilver mattam)
14:06:46 --- names: list (Unforgivable Apocalisp_ jenga mjgoins zax mauke Olathe Counter-Strike The_third_man sshc tonkman Gilly Lanther Sunhay_ atude jercos metasyntax` mm_freak KaneTW fxr Raynes jedai HugoDaniel codemac TacticalGrace bwr anthony `0660 alios EvanCarroll alip lsthemes tafryn iFire tbarik Maxdamantus ChongLi bbee Xorlev StoneToad mikeg thom_logn nniro Twey [swift] arkx helgikrs klugez Fingerzam magicman yiannis_t FDFlock Zao dmwit MacCoaster alpounet jkramer ddarius)
14:06:46 --- names: list (saccade Jonno_FTW ve companion_cube Guest84777 xplat DrSyzygy muhtimin Aisling ksandstr raek newsham mietek akamaus jpatota bblum tessier guerrilla niko untwisted encryptio kniu shutch borism earthy milli Eelis Draconx marienz int80_h Itkovian Hugglesworth chromakode mrshoe dino- Cale waterlaz Nshag bolmar smiler frerich jayne MilLionsOfLions Bleadof `0660_ jd10 Jiten bezik pastorn janne opqdonut exDM69 deadguys joni6128 hiredman pantsd TML teratorn)
14:06:46 --- names: list (Lycurgus alexsuraci semifor wto anders^^ dons inimino endpoint_david kwuxalot muep musically_ut akosch sidek thorkilnaur Vorpal mortberg catface ahihi cncl Miciah jdsc absentia lantti _2x2l DustyDingo stroan_ gereedy_ Zol shawn dilinger davean HalfWayMan yahooooo elliottcable ziman duairc AnAdorableNick aavogt aempirei davidL djahandarie nominolo Reisen franksh_ idnar cynick @ChanServ _br__ fihi09 svk_ d-snp mindwarp shortcircuit hvr Lemmih pettter bd_)
14:06:46 --- names: list (osfameron regulate Carneus bremner` bremner int-e guybrush erk_ tomaw cyanoacry SimonRC jamwt ixzkn taruti CosmicRay kaol itsjar dixie defn solidsnack allbery_b Martty pigoz tridactyla bqf tamiko flori_ olsner netcat emias lambdabot mlh burp iratsu` robinsmidsrod nimred freedrull byorgey canvon andern Guest35776 saurik sid3k koala_man NotRoot danderson aj| Nanar majoh mux nlogax Nereid michie1 harlekin samulihs BrianHV noj Liskni_si Firegolfer ray ibid)
14:06:46 --- names: list (m4thrick jvogel boyscared dorkitude fabjan jml ido luite Etherael pygmalion palyboy dax tromp__ qebab aiko_ aleator faj ath jlouis ehamberg johs jql stepnem aristid eyck jix saiam da-x palmje ortmage nornagon dcoutts ede_ ben Boney_ jbauman lucca __marius__ danr Innominate sajkr jrk_ noddy maurer_ andrewsw zygoloid david` Baughn helgim__ tmuki norm2782 chitragupt kolmodin Blub\0 Rembane nasloc__ metasyntax agemo deavid ahf anonym ibt iveqy zecrazytux epmf)
14:06:46 --- names: list (kloeri Laney Heffalump pix| mrothe Rooz_ rokoteko zomg BONUS MasseR schroedinbug dumael tab eregon And[y] Jaak mvid yrlnry suiside fpletz koninkje_away inr_ Belgarion_ alexsdutton dqd Botje steve_himself trez sbok drhodes derekwright Vulpyne eno FauxFaux shutdown_-h_now Colours kosmikus dionoea sipa electrogeek cognominal mercury^ mrd nathanic greap shepheb MacCoaster_ jre2 snr Sisu Ornedan brisbin orbitz Deewiant Entroacceptor Veinor mornfall dimensia flux)
14:06:46 --- names: list (Igloo cathper cjay gds Raku^ birkenfeld jaredj fnordus rdd alexbobP dcoutts_ ToRA cYmen hyko welterde Gabbie brailsmt alexis McManiaC obraun xmikedavis liesen zakwilson jcapper duckinator cizra aasmith_ Xorlev2 Ytinasni sproingie srobertson npouillard Hunner finnomenon)
14:12:43 <ski> JoeyA : why can a thunk get copied by that ?
14:15:17 <JoeyA> Value *v2 = apply(v->thunk.f, v->thunk.x); // this may return another thunk
14:15:40 <JoeyA> *v = *v2; // this would copy the thunk
14:17:14 <Zao> What languages are you smoking?
14:17:20 <JoeyA> lol
14:17:57 * monochrom prints out the Haskell 2010 report, rolls up the paper, burns, smokes...
14:18:30 <monochrom> "ah, monomorphism has never smelt so sweet"
14:19:31 * monochrom now tries it on ECMA 262-5.
14:23:03 <EvanCarroll> uh oh http://snapframework.com/
14:23:05 <EvanCarroll> 500
14:23:50 <megatron242> Hi, another small question: I have foo :: (Num a) => (a,a,a,a) , how can you tell the compiler that a should be Word32 ?
14:25:14 <JoeyA> Are you calling foo, or using it?
14:25:20 <JoeyA> err, calling foo, or implementing it?
14:25:28 <megatron242> I'm declaring foo
14:25:41 <megatron242> or should I say, implementing it
14:26:59 <megatron242> I mean, I can have foo :: (Word32,Word32,Word32,Word32), but than, I can't do + operation on it, cause it's not a part of Num (this is what I figured out from the error)
14:27:28 <monochrom> > (3 :: Word32) + 1
14:27:29 <lambdabot>   4
14:27:32 <monochrom> works
14:29:06 <megatron242> foo :: (Word32,Word32,Word32,Word32) -> (Word32,Word32,Word32,Word32)
14:29:14 <megatron242> foo a = a+a
14:29:28 <megatron242> gives:
14:29:29 <megatron242>     No instance for (Num (Word32, Word32, Word32, Word32))
14:29:29 <megatron242>       arising from a use of `+' at md5.hs:71:8-10
14:29:29 <megatron242>     Possible fix:
14:29:29 <megatron242>       add an instance declaration for
14:29:31 <megatron242>       (Num (Word32, Word32, Word32, Word32))
14:29:34 <megatron242>     In the expression: a + a
14:29:36 <megatron242>     In the definition of `foo': foo a = a + a
14:29:38 <wisepumpkin> megatron242: I'd expect it to
14:29:39 <megatron242> Failed, modules loaded: none.
14:29:51 <wisepumpkin> please don't paste much directly into the channel
14:29:59 <megatron242> Sorry
14:30:06 <wisepumpkin> megatron242: if you're using small fixed-length vectors, you should try the package rl just released
14:30:31 <wisepumpkin> but currently you should do foo (a, b, c, d) = (a + a, b + b, c + c, d + d)
14:30:43 <wisepumpkin> or you can write a Num instance for yourself
14:31:07 <megatron242> What does it mean - to write my own Num instance?
14:31:14 <wisepumpkin> + is a method of Num
14:31:26 <wisepumpkin> so if you want to call it on a 4-tuple of Word32s
14:31:36 <wisepumpkin> you need to make that 4-tuple of Word32s an instance of Num
14:31:47 <megatron242> What is the syntax? I'm new to Haskell (as you could probably guess)
14:32:04 <monochrom> I think you should just stick to foo (a, b, c, d) = (a + a, b + b, c + c, d + d)
14:32:30 <wisepumpkin> megatron242: I wouldn't use 4-tuples of anything much except as a temporary type
14:32:38 <Kaidelong> monochrom: that wouldn't carry properly
14:32:49 <litb> you can make your own operators and then implement the op
14:33:04 <megatron242> Exactly, I'm using it as a temporary variable
14:33:10 <Kaidelong> making an instance of num would be sensible but I'd do it differently from making the tuple one
14:33:27 <Kaidelong> (if the point here is to make a 128 bit integer)
14:33:43 <wisepumpkin> I assumed it was just a vector of 4 words
14:33:53 <monochrom> I assume nothing.
14:34:01 <litb> lol
14:34:02 * wisepumpkin makes an ass of monochrom and him
14:34:05 <megatron242> wisepumpkin - your assumption is correct
14:34:13 <wisepumpkin> HAH!
14:34:14 <wisepumpkin> I WIN
14:34:29 <Kaidelong> then making it an instance of num would be silly
14:34:44 <megatron242> So, in the bottom line - there is no simple way to add two 4-tuples?
14:34:52 <Kaidelong> write a function for it
14:34:52 <litb> yes because it would not logially have a single number
14:34:58 <Kaidelong> also why not use Data.Vector.Unboxed instead
14:35:06 <wisepumpkin> Kaidelong: yeah, there isn't
14:35:09 <wisepumpkin> they're too flexible
14:35:24 <wisepumpkin> (Int, Bool, (), Int -> Ordering)
14:35:27 <litb> is there a functor instance for  tuples like there is for lists?
14:35:38 <wisepumpkin> > fmap (+1) (5, 6)
14:35:39 <lambdabot>   (5,7)
14:35:48 <megatron242> OK, thanks for the help
14:35:49 <litb> that you can use like  fmap (*2) (1, 2, 3)  <- would be  (2, 4, 6)  ?
14:35:54 <litb> ohh
14:35:58 <wisepumpkin> litb: that type doesn't work
14:36:03 <monochrom> what-does-the-beginner-mean guess games gives the wrong evolutionary pressure.
14:36:11 <monochrom> s/guess/guessing/
14:36:21 <wisepumpkin> monochrom: you're just bitter cause I was right and you were WRONG!
14:36:24 <litb> wisepumpkin: what do you mean by "that type doesn't work" ?
14:36:35 <wisepumpkin> litb: what's the type of (1, 2, 3) ?
14:36:38 <wisepumpkin> (approximately)
14:36:45 <litb> tuple of 3 INt
14:36:52 <wisepumpkin> (Int, Int, Int)
14:36:55 <litb> ohh wait now i see
14:36:59 <wisepumpkin> (assuming no polymorphism)
14:37:03 <wisepumpkin> okay
14:37:18 <litb> th functor instance makes  calls  the function on second argument and leaves the first one alone
14:37:36 <litb> why doesn#t it do the same as fo rlists? i.e maps?
14:37:37 <wisepumpkin> yeah, and the type forces it to
14:37:39 <Kaidelong> does lambdabot have unboxed vectors?
14:37:50 <wisepumpkin> litb: because the type forces it to do it differently
14:38:06 <jmcarthur> honestly, tuples should have Num instances
14:38:07 <wisepumpkin> > fmap even (5, 7)
14:38:08 <lambdabot>   (5,False)
14:38:23 <wisepumpkin> litb: tuples are heterogeneous so (Int, Bool) is fine
14:38:32 <litb> what do you mean by "the type forces it" ?
14:38:33 <wisepumpkin> a list where the second argument is Bool and the rest are Ints doesn't make any sense
14:38:59 <Kaidelong> you could use a disjunct type
14:39:06 <jmcarthur> i guess there would be a choice between the applicative functor lifted Num and the all-elements-instantiate-num versions
14:39:13 <litb> would it not work to say   instanc Functor (,) a b where fmap f (a, b) = (f a, f b)   ?
14:39:25 <wisepumpkin> litb: no
14:39:28 <litb> wisepumpkin: imean the other way around
14:39:35 <monochrom> perhaps "hahamap :: (forall a b. a -> b) -> (x,y) -> (fx, fy)" makes sense as a "map for pairs".
14:39:43 <litb> tuple should do it like lists, not lists like tuples i mean :)
14:39:48 <wisepumpkin> litb: Functor takes things of * -> *
14:39:56 <wisepumpkin> there's no way a tuple can behave like lists
14:40:20 <Kaidelong> anyway if you are playing around with 4-tuples of integers why not just write a function that does it?
14:40:24 <jmcarthur> litb: you could do something like that for a Bifunctor type class...     instance Bifunctor (,) where bimap f g (a, b) = (f a, g b)
14:40:35 <wisepumpkin> that would still take two functions
14:40:37 <jmcarthur> litb: notice how that looks very similar to (***) though :)
14:40:51 <jmcarthur> :t (***)
14:40:52 <litb> "Functor takes things of * -> *" doesn't make sense to me. Functor [a] is, and it does not take any other parameters anymore :/
14:40:52 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
14:40:57 <Kaidelong> f (a1,b1,c1,d1) (a2,b2,c2,d2) = (a1+a2,b1+b2,c1+c2,d1+d2)
14:41:00 <jmcarthur> litb: no
14:41:02 <Kaidelong> simple enough
14:41:03 <litb> so itn't it  "*" for [a] ?
14:41:03 <jmcarthur> litb: Functor []
14:41:10 <litb> oh
14:41:17 <Kaidelong> and if you need something more general
14:41:59 <Kaidelong> f g (a1,b1,c1,d1) (a2,b2,c2,d2) = (g a1 a2,g b1 b2,g c1 c2,g d1 d2)
14:42:17 <litb> so if we have   Functor f => f a    then  a contains only the information about a list, not about the list's elements?
14:42:50 <litb> i guess i'm asking too stupid questions today lol
14:43:02 <Kaidelong> litb: functors need to work on ANY input type so clearly the implementation of functor does not need to know anything about the other type
14:43:27 <Kaidelong> so you'd make an instance for [] rather than [] a
14:43:35 <kmc> @src Functor
14:43:36 <lambdabot> class  Functor f  where
14:43:36 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
14:43:54 <kmc> litb, the class variable is "f" but it's used like "f a" and "f b"
14:44:05 <kmc> so f has to be a 1-argument type constructor
14:44:07 <kmc> like [] or Maybe
14:44:10 <Kaidelong> kind * -> *
14:44:41 <kmc> (a -> b) -> Maybe a -> Maybe b
14:44:45 <kmc> f = Maybe
14:44:51 <Kaidelong> @kind []
14:44:52 <lambdabot> * -> *
14:44:54 <Kaidelong> @kind [] a
14:44:55 <lambdabot> Not in scope: type variable `a'
14:45:06 <Kaidelong> @kind forall a. [a]
14:45:07 <lambdabot> *
14:45:51 <litb> oh now i understand i think
14:46:16 <litb> it supplies a partial type constructor when it says   instance Functor []    and in a use  if one says  f a it provides that arg
14:46:50 <Kaidelong> basically
14:46:59 <osaunders> Can you write multiple pattern matches for a lambda?
14:47:29 <lispy> osaunders: Only if you use a case, so not really
14:47:32 <Kaidelong> case xxx of {pattern1 -> expr; pattern2 -> expr ...}
14:47:50 <Kaidelong> you could just factor the function out
14:48:09 <lispy> osaunders: This is related to the back arrow used in do-notation, do Just 1 <- foo; ...
14:48:10 <Kaidelong> if you have an explicit module declaration you can also hide top level definitions that aren't type abbreviations
14:48:11 <osaunders> > (\x -> case x of {1 -> 2}) 3
14:48:12 <lambdabot>   *Exception: <interactive>:1:152-169: Non-exhaustive patterns in case
14:48:22 <Kaidelong> so there isn't anything wrong with putting it on the top level
14:48:49 <lispy> > (\x -> case x of {1 -> 2; 3 -> 22/7}) 3
14:48:50 <lambdabot>   3.142857142857143
14:49:11 <mikeg> Is ByteString.copy necessary for lazy traversal with hexpat?
14:49:14 <osaunders> > 22/7 - pi
14:49:14 <lambdabot>   1.2644892673496777e-3
14:49:37 <osaunders> lispy: Can you do a case on a back arrow?
14:49:54 <litb> > (\x -> case x of {1 -> 2}) 1
14:49:55 <lambdabot>   2
14:50:06 <litb> wow it doesn't care about that
14:50:15 <Kaidelong> a <- anyexpression == anyexpression >>= \a ->
14:50:16 <lispy> > 52163 / 16604 - pi
14:50:17 <lambdabot>   -2.662132572162079e-7
14:50:50 <lispy> osaunders: You have to name it first, do x <- foo; case x of ...
14:51:09 <osaunders> Hm, OK. TY
14:54:25 <kmc> osaunders, to define a function locally with multiple patterns, you can use "let"
14:54:37 <kmc> > (let f True = "foo"; f False = "bar" in f) True
14:54:38 <lambdabot>   "foo"
14:55:01 <kmc> you can think of «\p -> e» as sugar for «let f p = e in f»
14:55:23 <Heffalump> kmc: does it have the same polymorphism?
14:55:36 <kmc> good question
14:55:37 <Heffalump> oh, yes it does. I was confusing with something else.
14:55:54 <Heffalump> no, I take that back; it doesn't.
14:56:04 <kmc> example?
14:56:08 <Heffalump> hangon
14:56:53 * osaunders considers realizing a new quantum physics quarterly called Hangon Hadron
14:56:56 <kmc> > let f x = x in (f 'x', f 3)
14:56:57 <lambdabot>   ('x',3)
14:57:10 <Heffalump> now I'm not sure :-)
14:57:15 <kmc> but not with -XMonoLocalBinds
14:57:28 <kmc> but then you can still write the polymorphic sig
14:57:37 <litb> does that have anything to do with the mono project?
14:57:42 <kmc> nope
14:58:53 <Heffalump> I can't construct a difference.
14:58:56 <osaunders> Oh actually I remember hearing something about how polymorphic let binding represented a problem for GHC in some way.
14:59:11 <kmc> yeah
14:59:18 <osaunders> And the solution was that you have to qualify them with a type sig.
14:59:27 <kmc> well specifically, *inferring* poly local binds
14:59:31 <kmc> yeah, with a signature it's fine
14:59:31 <osaunders> I'm not sure what version of GHC that's true for though.
14:59:34 <litb> can ghc 6.12.3 print llvm code?
14:59:41 <kmc> litb, if it's built with the llvm patches
14:59:56 <litb> is it not officially shipped with ghc?
15:00:01 <kmc> not in ghc6
15:00:04 <kmc> yes in ghc7
15:00:07 <litb> -.-
15:00:15 <kmc> osaunders, i'm not clear on details but the issue has to do with type equality coercions
15:00:17 <osaunders> Yeah LLVM is mentioned in GHC 7 release notes
15:00:24 <kmc> which are enabled if you're using GADTs or TypeFamilies
15:00:33 <kmc> so in GHC7, either of those extensions implies MonoLocalBinds
15:00:55 <kmc> which means let bindings are monomorphic unless given a signature
15:01:05 <litb> functionals programs should be very speedy since all types are statically known
15:01:19 <osaunders> kmc: OK, thanks for clarifying
15:01:20 <litb> so it should be able to apply many optimizations
15:01:57 <kmc> litb, what do you mean?
15:02:18 <jmcarthur> the functionalness of haskell is not what makes it possible to compile efficiently
15:02:26 <litb> kmc: i mean for example in python, the compiler cannot do many optimization because all the language is too dynamic
15:02:44 <litb> but in haskell, it knows precisely what names are integers and all, since everything is known when compiling
15:02:51 <stroan_> is there any way to not have to give the fully resolved module name in a file? I have thrift generating module X, and I would rather it be X.A, and would rather not have to process the generated code if possible
15:02:53 <kmc> litb, that has nothing to do with Haskell being "functional"
15:02:59 <litb> oh
15:03:03 <kmc> it has to do with, as you said, static typing
15:03:05 <stroan_> A.X*
15:03:15 <kmc> there are dysfunctional languages with static typing, and plenty of functional languages with dynamic typing
15:03:37 <litb> i dunno of functional languages with dynamic typing
15:03:43 <jmcarthur> even a lack of static typing doesn't necessarily mean it's slow
15:03:43 <Kaidelong> kmc: what'd be an example of a dysfunctional language?
15:03:43 <sipa> javascript
15:03:51 <kmc> litb, Lisp, Scheme, Clojure for sure
15:04:00 <litb> oh
15:04:04 <kmc> depending on how you define "functional language", Javascript, Python, Ruby
15:04:12 <kmc> they all support first-class functions
15:04:22 <kmc> (of course they do; it's an 80-year-old language feature)
15:04:23 <litb> wasn't aware they are all dynamically typed
15:04:25 <jmcarthur> look at assembler, for example. there is a very tiny amount of static typing in that certain opcodes are only valid with certain kinds of registers sometimes
15:04:34 <kmc> but they don't have nicer stuff like tail-call optimization
15:04:39 <jmcarthur> and of course assembler can be quite fast ;)
15:04:42 <kmc> (by which i mean, mandated by the spec)
15:04:50 <jmcarthur> it's not dynamically typed eithe rhtough
15:04:52 <kmc> Kaidelong, C++ or Java
15:04:53 <jmcarthur> *either though
15:04:57 <jmcarthur> it's just *untyped* ;)
15:05:05 <Kaidelong> jmcarthur: assembler is probably more weakly typed than dynamically typed isn't it?
15:05:07 <jmcarthur> i guess the hardware has a few checks
15:05:08 <kmc> Kaidelong, languages where basic forms of abstraction like passing a function to a function are hilariously cumbersom
15:05:14 <kmc> "dysfunctional" is the antonym of "functional"
15:05:16 <jmcarthur> Kaidelong: more like just untyped ;)
15:05:26 <osaunders> Briefly, what's do GADTs give you that you can't do otherwise?
15:05:31 <osaunders> kmc: Along with non-functional
15:05:54 <wisepumpkin> osaunders: refinement of type constructor indices in data constructors
15:05:57 <Kaidelong> kmc: why is passing a function to a function hard in C++?
15:06:04 <jmcarthur> osaunders: GADTs give you the ability to assign different type parameters for different constructors
15:06:08 <Kaidelong> because you lose type information?
15:06:10 <Zao> Kaidelong: Free functions, not at all.
15:06:16 <kmc> Kaidelong, try it.  and by function i don't mean "function pointer", i mean something with free variables
15:06:21 <Zao> Kaidelong: It's not hard if you use std::function and std::bind.
15:06:24 <sipa> you mean a closure
15:06:34 <wisepumpkin> sipa: don't tell Cale 
15:06:37 <Zao> Kaidelong: Get with the times.
15:06:50 <kmc> osaunders, GADTs let you take the type system of a language you're implementing and push it down into Haskell's type system
15:06:54 <litb> it's definitely hard with bind for the general case
15:07:03 <kmc> for example, proving that the transformation passes of your compiler are type-preserving
15:07:04 <jmcarthur> you can create a closure in C++ using some ugly tricks (slightly less ugly with c++0x, but still ugly)
15:07:10 <jmcarthur> boost has a way too, iirc
15:07:16 <jmcarthur> don't know how ugly that is
15:07:32 <litb> but folks, i hear c++ is going to have lambdas soon xD
15:07:38 <kmc> java too.  late 2012
15:07:39 <jmcarthur> yeah, really ugly ones
15:07:46 <kmc> we'll all have to give up Haskell and switch to Java then
15:07:47 <litb> lol
15:07:50 <osaunders> FP is winning!
15:07:55 <jmcarthur> in C++0x you have to define the closure explicitly
15:07:58 <kmc> osaunders, if you call it FP, people won't use it
15:08:11 <pkrumins> [](){}
15:08:20 <osaunders> kmc: :-(
15:08:20 <litb> c++0x has implicit capture too
15:08:36 <pkrumins> litb what does it capture over, current scope?
15:08:40 <kmc> osaunders, e.g. the much loved features of C# such as <s>lambda</s> delegates and <s>monad comprehensions</s> LINQ
15:08:45 <Kaidelong> I like that you can basically program C# in an entirely functional style now without too much masochism
15:08:49 <thoughtpolice> the fact you have to define the closure's references/values sucks, but it still got them before java
15:08:49 <kmc> yep
15:08:51 <mreh> Java doesn't even have higher order functions
15:08:56 <thoughtpolice> *closures
15:09:09 <Kaidelong> kmc: delegates are more like language support for the visitor pattern aren't they?
15:09:13 <litb> pkrumins: yes, current local scope + this pointer
15:09:16 <jmcarthur> it makes sense though, that you have to do that in c++
15:09:25 <thoughtpolice> i write C++ for the day job, and I would mostly look forward to lambdas, auto and range-based for loops
15:09:37 <jmcarthur> the whole point is fine grained control over resources and a transparent cost model
15:09:40 <kmc> Kaidelong, you tell me, i'm no C# expert
15:09:47 <kmc> anyway
15:09:49 <kmc> let's talk about Haskell
15:09:52 <litb> lol
15:09:53 <kmc> osaunders, i like the GADT example in the GHC manual
15:09:56 <jmcarthur> even at the cost of destroying the rest of the language ;)
15:09:58 <kmc> it's short and gets the point across
15:10:05 <mreh> where do you think you are? #haskell?
15:10:08 * osaunders looks it up
15:10:08 <kmc> osaunders, http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/data-type-extensions.html#gadt
15:10:10 <ben> haskell needs stacktraces >:[
15:10:19 <monochrom> the GHC user guide is underappreciated.
15:10:31 <litb> hilarious. haskell has no stack traces?
15:10:34 <mreh> ben: it's kind of useless with lazy evaluation
15:10:35 <litb> hmm
15:10:44 <kmc> litb, use the ghci debugger
15:11:01 <kmc> osaunders, when we declare "data Term a" we pick specific types for these constructors.  GHC doesn't care which types we pick -- those could all be "... -> Term Char" for all GHC cares.  but when we go to write "eval", our choice of constructor types matters
15:11:18 <litb> mreh: because errors by evaluation will be detected at other points than were their expression were formed?
15:11:31 <Kaidelong> better yet, break up your code and write run tests on the individual parts
15:11:33 <litb> kmc: ohh
15:11:34 <ben> mreh: To be honest I would be happy if I found a thing to make an exception object tell me in which line it was thrown
15:11:35 <monochrom> don't shoehorn your c## debugging paradigms into haskell. yes you should ask for debugging but not "stack trace"
15:12:04 <litb> lol
15:12:08 <mreh> :t exception
15:12:09 <lambdabot> Not in scope: `exception'
15:12:14 <mreh> :t error
15:12:15 <lambdabot> forall a. [Char] -> a
15:12:19 <kmc> see sharp sharp
15:12:26 <mreh> > error "error in line 1"
15:12:26 <lambdabot>   *Exception: error in line 1
15:12:31 <monochrom> Control.Exception.assert tells you line numbers
15:12:43 <ben> I guess it does not help that my error only happens rarely, in a thread
15:12:50 <kmc> litb, there's also the RTS option -xc
15:12:52 <kmc> see http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html#rts-options-debugging
15:13:00 <litb> ohh
15:13:33 <ben> How do I make cabal build my thing for profiling?
15:13:38 <monochrom> the very same technique used by Control.Exception.assert can be used for Prelude.error, yes, just nobody has got around to change it.
15:14:42 <monochrom> ghci debugger already has tracing, i.e., execution history.
15:14:54 <Axman6> ben: cabal install thing -P i think, or -p
15:15:07 <mreh> I've rarely used the debugger
15:15:17 * Kaidelong wonders why the prelude is still around
15:15:33 <monochrom> "Execution can take place in tracing mode, in which the evaluator remembers each evaluation step as it happens, but doesn't suspend execution until an actual breakpoint is reached. When this happens, the history of evaluation steps can be inspected." and "Exceptions (e.g. pattern matching failure and error) can be treated as breakpoints, to help locate the source of an exception in the program." You don't need "stack traces".
15:16:27 <monochrom> Straight from the Underappreciated GHC User Guide
15:16:59 <osaunders> Do people here get tired of writing import Control.Monad et al?
15:17:19 <kmc> Kaidelong, because it provides some useful stuff?
15:17:19 <osaunders> kmc: I think I get it.
15:17:30 <monochrom> Yes. See http://hackage.haskell.org/package/prelude-plus
15:17:34 <osaunders> kmc: GADTs that it
15:17:36 <osaunders> *is
15:17:42 <kmc> Kaidelong, anyone can publish an alternative Prelude on hackage.  several people have, but none of them is widely popular within the community, which would be the first step towards a true replacement
15:17:45 <Kaidelong> kmc: but if I write Control.Monad Data.List etc I can qualify them and swap them out if I want
15:18:13 <kmc> there's also the problem that afaik you can't have a module which re-exports some module under a qualified name
15:18:42 <Manifesto> hey, I have to translate this lambda to a haskell lambda: (\x.x*x)(
15:18:46 <Manifesto> op
15:18:48 <Manifesto> *ops
15:18:55 <Manifesto> wait a minute
15:18:57 <Kaidelong> (\ x -> x * x)
15:18:59 <Kaidelong> probably?
15:19:03 <Manifesto> hehehe
15:19:08 <Axman6> join (*)
15:19:10 <Manifesto> I didnt finished
15:19:28 <osaunders> *I didn't finish
15:19:31 <Kaidelong> @instances Monad
15:19:31 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
15:19:42 <Kaidelong> I had no idea (->) r was a monad
15:19:51 <Manifesto> hey, I have to translate this lambda to a haskell lambda: (\x.x*x)(\y.y), and my atempt was (\x -> x*x) (\y -> y). Whats wrong?
15:19:51 <monochrom> we're call-by-need. we don't need to wait for finish.
15:19:57 <mreh> Kaidelong: you knew Reader was a monad?
15:19:59 <wisepumpkin> Kaidelong: it's like Map
15:20:12 <monochrom> wrong type. (\y -> y) not a number.
15:20:17 <Kaidelong> mreh: yes but I haven't really used a reader yet, I suppose I should learn it
15:20:20 <Manifesto> sorry for the repetition and english erros, by the way.
15:20:29 <wisepumpkin> Kaidelong: Reader is exactly (->)
15:20:33 <monochrom> you could do it in scheme and python, yes.
15:20:34 <Manifesto> hmmm
15:20:37 <ddarius> > (id * id) 3
15:20:38 <lambdabot>   9
15:20:40 <Causalien> I've been reading too much lately. Does any of you get dry and twitchy eyes?
15:20:42 <mreh> Kaidelong: patience
15:20:51 <Manifesto> not in haskell?
15:21:04 <monochrom> not in haskell.
15:21:12 <ddarius> Today was the first snow sprinkle and also (somewhat independently) the first day I closed all my windows.
15:21:13 <Kaidelong> Causalien: if you don't wear glasses get reading glasses
15:21:25 <wisepumpkin> ddarius: snow?!
15:21:27 <Manifesto> I see, thanks.
15:21:28 <wisepumpkin> I missed that
15:21:28 <monochrom> several things valid in scheme are not allowed in haskell just for types.
15:21:31 <mreh> eye spasms are fun
15:21:53 <ddarius> wisepumpkin: It was just a few flakes around lunch time.  Probably nothing in Boston itself.
15:21:58 <wisepumpkin> ah
15:22:01 <monochrom> (\x -> x x) (\x -> x x) is a fun thing to do in scheme and not allowed in haskell. again types.
15:22:08 <ddarius> wisepumpkin: Find a promising place yet?
15:22:22 <ddarius> > (\x -> x * x) (\y -> y) 3
15:22:23 <lambdabot>   9
15:22:29 <wisepumpkin> ddarius: sort of! I walked over to the nice area it's in, and am actually visiting the place on sunday
15:22:29 <Causalien> Kaidelong I do.  Probablly need to cut back my coding hours to less than 12 per day
15:22:31 <wisepumpkin> so I'm crossing my fingers
15:22:45 <wisepumpkin> next to the park near fenway
15:22:50 <ddarius> wisepumpkin: What's the nice area?
15:22:55 <ddarius> ah.
15:22:56 <Manifesto> I tried that on ghci, nothing.
15:23:11 <monochrom> someone changed lambdabot to allow it.
15:23:13 <Manifesto> I guess the lambdabot isnt just related to haskell?
15:23:14 <wisepumpkin> very peaceful and walking distance to work, symphony hall, and fine art
15:23:20 <Manifesto> oh, ok.
15:23:25 <wisepumpkin> and the christian science center ;)
15:23:52 <monochrom> after you know "type class" and "the Num type class" you may be able to change it yourself, too.
15:24:22 <ddarius> wisepumpkin: All important places.
15:24:34 <jmcarthur> you guys have snow there already?
15:24:48 <kmc> not yet
15:25:23 <jmcarthur> it's totally still in the low-70s high and the high-30s low, here
15:25:34 <Manifesto> Change what?
15:25:36 <Kaidelong> Hmm, would anything (Enum a, Num b) => a -> b be a Num?
15:25:42 <Manifesto> The very interpreter?
15:25:45 <iago> hi all, there is some library for typed-handles ?
15:25:56 <jmcarthur> when i visited boston it was like the hottest week of the year, of course :\
15:26:12 <monochrom> you just need to write an load a module to allow (\y -> y)*(\y -> y)
15:26:28 <ddarius> wisepumpkin: There's a Japanese restaurant in Boston that I'd like to go to on the off chance that they have yuzu-shu.  I know they have some alcoholic drink with yuzu juice in it, but I'm hoping against hope that they might have some actual yuzu-shu.
15:27:06 <wisepumpkin> ddarius: ooh, I think I had some of that in japan, but not sure
15:27:15 <wisepumpkin> ddarius: there's a nice japanese restaurant downstairs from me
15:27:17 <Manifesto> hmm, sweet.
15:27:18 <wisepumpkin> I could ask on my way home if you want
15:27:26 <wisepumpkin> "home"
15:27:35 <ddarius> I had quite a bit of it in Japan, but it is extremely rare in America.
15:27:55 <ddarius> wisepumpkin: If you want you can ask, but it'll probably be a waste of time.
15:28:00 <wisepumpkin> I'll try
15:28:19 <wisepumpkin> it's quite fancy
15:28:24 <proq> ddarius: what is it?  a drink?
15:28:52 <Manifesto> thank you, by the way.
15:29:39 <ddarius> @google yuzu komachi
15:29:40 <lambdabot> No Result Found.
15:29:45 * ddarius curses @google.
15:32:38 <ddarius> Cale: I don't know if you responded yesterday night about the actual running version of lambdabot's code being online somewhere.
15:33:40 <ddarius> Technically, @google should support things like 2+2 but lambdabot doesn't seem to and I'm wondering if that was removed (for good reason.)
15:34:52 <ddarius> Cale: If it was removed, then I'll just remove it from the Hackage version because fixing it doesn't seem too worthwhile.
15:35:26 <monochrom> @google let me confirm it for you
15:35:26 <lambdabot> No Result Found.
15:35:34 <monochrom> @google let me google it for you
15:35:35 <lambdabot> http://lmgtfy.com/
15:35:35 <lambdabot> Title: Let me google that for you
15:35:59 <monochrom> ok, at least it doesn't look like a const function
15:36:51 <kmc> @google google
15:36:52 <lambdabot> http://www.google.com/
15:36:52 <lambdabot> Title: Google
15:36:57 <dixie> > readFile "/etc/passwd"
15:36:58 <lambdabot>   <IO [Char]>
15:37:13 <kmc> @google the list of all web pages that do not link to themselves
15:37:14 <lambdabot> http://codex.wordpress.org/Pages
15:37:15 <lambdabot> Title: Pages « WordPress Codex
15:39:11 <ddarius> I don't know exactly what the rule is, but there's something that makes "I'm Feeling Lucky" return a search page instead of a redirect.  Adding "http://www.google.com/" to the Referers "fixes" that seemingly.
15:39:37 <ddarius> So when @google returns "No Result Found." for something that clearly has a result, that is what's happening.
15:40:03 <ddarius> And when you get thread kills, that's due to some completely incorrect HTTP response reading code.
15:40:11 <Axman6> Monaduck, I choose you!
15:40:17 <ddarius> +
15:40:45 <ddarius> (Which is probably why the 2+2 support was removed from lambdabot.)
15:40:58 <Kaidelong> 2+2 support?
15:41:15 <ddarius> http://www.google.com/search?hl=en&q=2%2B2&aq=f&aqi=h1g10&aql=&oq=&gs_rfai=
15:41:39 <Axman6> we need more haskell pokemon
15:42:35 <aristid> Axman6: wut
15:42:59 <Axman6> Monaduck, Functoice
15:43:08 <Causalien> LOL. 10 pages in the tutorial and I am already lost.
15:43:18 <Kaidelong> which tutorial?
15:43:21 <kmc> Causalien, :D
15:43:23 <kmc> can we help?
15:43:24 <ben> LOL!
15:43:31 <Causalien> Gentle introduction to haskell
15:43:40 <Axman6> use lyah Causalien 
15:43:45 <Axman6> @where lyah
15:43:45 <lambdabot> http://www.learnyouahaskell.com/
15:43:47 <kmc> Causalien, that one's not so gentle
15:43:53 <kmc> i recommend LYAH and RWH
15:43:54 <kmc> @where rwh
15:43:55 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
15:44:06 <kwos> bird's book is good
15:44:13 <Causalien> Heh. People need to know that some of us take the title to its face value.
15:44:17 <Axman6> lyah, then rwh
15:44:17 <kwos> if you want more cs-like book, less practical
15:44:17 <kmc> oh, we know
15:44:21 <kmc> it is a Known Bug
15:44:37 <Causalien> Ok, starting lyah
15:44:46 <kmc> Causalien, that was written at a time when the only people who would possibly be interested in Haskell were, like, graduate students in programming languages research
15:45:10 <kmc> so it's "gentle" compared to the alternative of "read the damn spec"
15:45:18 <monochrom> I disagree. the gentle introduction is just fine. you just have to proceed slowly. not 10 pages in half an hour, no.
15:45:34 <monochrom> and lyah is not a 10-pages-in-half-an-hour deal either.
15:45:46 <ddarius> I read the Gentle Introduction at a normal pace and had no problems and enjoyed it quite a bit.
15:45:52 <Causalien> So it seems. I thought with lisp background I'd have an easier time, but no.
15:46:08 <monochrom> if you expect to read a programming book like you read harry potter, there is no "accessible" tutorial.
15:46:19 <aristid> monochrom: it's possibly more about perception of time than about how much time actually elapses
15:46:31 <kmc> Causalien, Haskell has a bunch of unusual features
15:46:37 <kmc> it is not a typical functional language
15:46:53 <kmc> coming from Lisp, static types, laziness, type classes, algebraic data may be quite foreign
15:47:01 <Causalien> I know. I need to "Open" my scalp to the possibilities.
15:47:02 * ddarius reads theses and research papers like he reads fiction novels.
15:47:16 <Heffalump> kmc: I'd say Haskell is one of the standard functional languages these days, so calling it "not typical" is rather odd.
15:48:17 <kmc> Heffalump, "typical" is judged wrt the design space of functional languages
15:48:29 <kmc> not by a popularity contest or today's fads
15:48:41 <ddarius> Really?
15:48:45 <kmc> that's how i meant it
15:49:30 <kmc> Haskell has some features which are logical consequences of "functional language", but a lot of important features which aren't
15:49:37 <kmc> and there's considerable confusion on this issue
15:50:22 <aristid> are type classes such an important "not-typical-functional" feature?
15:51:18 <kmc> i think so
15:51:49 <Axman6> don't type classes basically just make code smaller?
15:51:56 <monochrom> type class is certainly important to me. ocaml and/or sml's + .+ ..+ ...+++ become laughable after a while
15:52:16 <Heffalump> type classes are pretty much orthogonal to "functional", I'd agree.
15:52:33 <kmc> without type classes, stuff like the "do" notation wouldn't work
15:52:35 <Heffalump> I think algebraic datatypes and static typing are both typical of functional language.
15:52:44 <kmc> and generic containers like Map would get a lot trickier
15:52:45 <Heffalump> kmc: not true, look at F# :-)
15:52:51 <ddarius> Axman6: You -could- say that about any language feature.
15:52:59 <Axman6> heh, true
15:53:03 <Heffalump> that has a do-equivalent without having higher-kinded type variables or constructor classes
15:53:08 <sipa> do notation could be used specifically for IO, without any type classes
15:53:16 <ddarius> Axman6: At any rate, type classes are not implementable by a local change to your code, so, no, they aren't just some nice sugar.
15:53:17 <kmc> Heffalump, does it depend on an OO-style interface, or on plain old duck typing
15:53:21 <kmc> sipa, yes, but it would be much less useful
15:53:23 <wisepumpkin> yeah, do being polymorphic is too confusing for beginners
15:53:28 <wisepumpkin> we should make do specific to IO
15:53:28 <Heffalump> duck typing, in effect
15:53:35 <wisepumpkin> ;)
15:53:41 <Heffalump> and you can't make things that are overloaded on the monad
15:53:53 <Axman6> ddarius: all i means is that it stops you having to write mapList, mapSet, mapEither etc.
15:53:58 <kmc> Heffalump, which functional languages are popular today, in teaching and use?  Clojure, Scheme, Javascript, Erlang, Haskell, (arguably) Python, Ruby, Javascript
15:54:07 <ddarius> wisepumpkin: IO is clearly too confusing.  We should return to streams.
15:54:08 <kmc> ML
15:54:11 <Heffalump> F#, O'Caml, SML
15:54:19 <ddarius> Axman6: It does more than that.
15:54:44 <Heffalump> arguably Scala
15:54:59 <monochrom> @quote monochrom hard
15:54:59 <lambdabot> monochrom says: If you're having trouble learning monads, try to learn something harder, like algebraic geometry.
15:55:08 <ddarius> We should hold Ruby up as a paragon of FP.
15:55:08 <kmc> of those 10, i count 5 with algebraic data built-in-ish, and 4 with static typing
15:55:15 <kmc> anyway it's a kinda arbitrary argument
15:55:44 <ddarius> FP languages are slow. Ruby is slow.  Check.
15:55:59 <ddarius> FP languages are interpreted.  Ruby is interpreted.  Check.
15:56:12 <monochrom> FP languages are esoteric. Ruby is esoteric.
15:56:15 <kmc> FP languages are used by insane people
15:56:27 <aristid> Ruby is used by insane people. Check.
15:56:33 <monochrom> FP languages are plain text. Ruby is plain text.
15:56:57 <monochrom> FP languages are executable. Ruby is executable.
15:57:13 <iago> FP languages are functional :)
15:57:52 <Twey> … Ruby is dysfunctional.  Close enough?
15:58:15 <kmc> FP languages are ideal for agile scrum ajax html5 css javascript event-based websockets social media microblog trend content platform portal development system frameworks
15:58:22 <Funktorsalat> what is a functional language? *troll* :)
15:58:30 <kmc> what is love? baby don't hurt me
15:58:32 <Funktorsalat> "you know what I mean"
15:58:36 <monochrom> what is functional language, really?
15:58:55 <aristid> Funktorsalat: "i know functional languages when i see them"
15:58:59 <Funktorsalat> :)
15:59:00 <monochrom> love is like math, a simple idea but can get complicated.
15:59:00 <kmc> i like that if you type "what is love" into google, it pops up a definition in the autocomplete box
15:59:08 <monochrom> math is like love, a simple idea but can get complicated.
15:59:14 <Funktorsalat> the definition by enumeration of instances kinda makes most sense
15:59:28 <sipa> functional languages are like love
15:59:38 <sipa> nobody can tell you are using one
15:59:49 <sipa> you just know it, thunk to thunk
16:00:21 <Axman6> anyone know why the snap site is down?
16:00:22 <monochrom> everyone loves my functional language but my functional language loves only me.
16:00:34 <iago> Funktorsalat, synta sugar for lambda calculus
16:00:48 <ddarius> Axman6: Because it is written in Haskell.
16:00:57 <kmc> oh snap
16:01:07 <sipa> what is the definition of enumeration by instances?
16:01:14 <sipa> *of
16:01:21 <monochrom> hahahaha
16:01:38 <Funktorsalat> sipa: a definition of the form "a foo is an element of { foo1, .... foon }"
16:01:49 * sipa mixed things up
16:01:50 <Funktorsalat> or generalized to "something similar to an element of ..." :)
16:02:17 <Axman6> Three Category Theorists walk into a bar.
16:02:21 <Axman6> How did they get there?
16:02:26 <iago> sipa, a language is functional if it is Haskell, ML, etc etc
16:02:35 <ddarius> Axman6: By walking.
16:02:43 <sipa> iago: haha
16:02:48 <monochrom> I think they commute there? :)
16:03:01 <Axman6> By comuting on public transitive
16:03:03 <Axman6> >_>
16:03:07 <monochrom> hehehe
16:03:12 <ddarius> monochrom: I think they consume alcoholic beverages there.
16:03:50 <Axman6> mm*
16:03:56 <Boxo> A coconut is just a nut.
16:04:05 <monochrom> I can go to school (from home) two ways. One way is bus south, subway east. Another way is bus east, subway south. They take about the same time. It's really a commuting diagram.
16:05:19 <SaMuRai> Welcom to >>>> http://salon-rhone-alpes.skyrock.com/ <<<< ;)
16:05:30 <wisepumpkin> lol
16:05:39 <ddarius> Except that the legs are different lengths as we learn from non-Euclidean geometry.
16:05:46 <ddarius> The Riemann tensor would be non-trivial.
16:08:01 <ddarius> It would actually require slightly less distance to go east first and then south.
16:09:09 <Funktorsalat> the "east" bug probably isn't following a circle of latitude :p
16:09:12 <Funktorsalat> bus
16:10:14 <monochrom> you know too much math.
16:14:33 <Funktorsalat> ddarius: what about a rectangle made of geodesics?
16:14:40 <Funktorsalat> I'm not so sure
16:15:03 <Funktorsalat> (with the 'east' edges just starting out eastward)
16:16:06 <dibblego> I have two unix packages registered, causing GHC to crash -- deregistering either breaks all sorts of dependencies -- is it broken?
16:18:29 <ddarius> Funktorsalat: The only geodesic on (perfect sphere) Earth that goes east at any point is the equator.
16:18:49 <Funktorsalat> ddarius: yes, hence 'just starts out east'
16:20:08 <Funktorsalat> I'm not sure whether such a 'rectangle' makes sense
16:21:13 <Funktorsalat> (what would the definition be if we can't take 'all corners are right angles'?)
16:41:29 <lars9> how to pattern match "abc" in "{abc}" when defining a function?
16:41:44 <Botje> what does defining a function have to do with it?
16:42:18 <lars9> f '{':xs = ...
16:42:27 <lars9> f ('{':xs) = ...
16:42:38 <Botje> ah.
16:42:39 <lars9> how to match last one?
16:42:41 <Botje> yeah, you can't :)
16:42:56 <kmc> you could use ViewPatterns
16:43:03 <Botje> unless you use guards or view patterns
16:43:23 <lars9> let me check view patterns
16:43:47 <ddarius> > let f ('{':a:b:c:"}") = [a,b,c] in f "{abc}"
16:43:48 <lambdabot>   "abc"
16:45:57 <lars9> ddarius: that works when the length is known
16:46:23 <monochrom> if length unknown, you really have to do it outside pattern matching.
16:47:39 <lars9> monochrom: i see, thanks
16:47:53 <ddarius> monochrom: View patterns could still be used for this.
16:48:18 <dibblego> is there any way to move packages from global to user?
16:48:19 <aavogt> > let f ('{': (reverse -> '}': (reverse -> xs))) = xs in f "{abcd}"
16:48:20 <lambdabot>   "abcd"
16:49:03 <monochrom> necessary condition for view pattern: write your own string functions. it doesn't make anything easier.
16:49:18 <ddarius> Agreed
16:49:25 <aavogt> user packages can depend on global packages
16:49:36 <osaunders> @src concat
16:49:36 <lambdabot> concat = foldr (++) []
16:49:46 <ddarius> No one said anything about easier though.
16:49:53 <dibblego> I have a unix in both global and user and it causes GHC to crash
16:50:16 <aavogt> you could move some files to ~/.ghc/x86_64-linux-6.12.3/package.conf.d
16:50:20 <monochrom> it doesn't eliminate the need to write functions that parses the thing outside pattern matching.
16:52:36 <aavogt> dibblego: then you ask ghc-pkg recache
16:53:57 <monochrom> 1. "ghc-pkg --global describe unix > save_it_up"  2. "ghc-pkg --global --no-user-package-conf unregister unix"  3. "ghc-pkg --user register save_it_up"
16:54:16 <monochrom> ("3 easy steps to move!")
16:54:52 <ddarius> "Make a copy of yourself.  Delete your old self.  Relocate the copy of yourself."
16:55:17 <aavogt> dibblego: how does one end up with two unix?
16:55:28 <aavogt> perhaps cabal upgrade?
16:55:34 <monochrom> I know two ways. same version too.
16:55:45 <ddarius> As the name suggests, unices reproduce asexually.
16:55:54 <monochrom> actually they are one way, just look different
16:56:18 <monochrom> 1. cabal install --user unix  2. cabal install --global unix
16:56:57 <monochrom> the "looks different" way: 1. cabal install --user unix  2. apt-get install libghc6-unix
16:58:25 <monochrom> here is yet another "looks different" way but more deceiving: 1. cabal install --user (something that deps on unix)  2. apt-get install (something that deps on libghc6-unix)
16:59:26 <monochrom> I am writing an article that discusses this (and many other cabal, package issues). The section on this is planned to be "unsafeInterleaveUserGlobal"
16:59:52 <dibblego> I've no idea but it is on a dying disk, so I might just start again
16:59:57 <monochrom> I mean the title of that section.
17:08:06 <ski> @tell JoeyA i'm still not sure why `*v = *v2;' would be problematic -- unless you (or someone else) uses `v2' after this, i.e.
17:08:06 <lambdabot> Consider it noted.
17:09:15 <JoeyA> ski: It's because of where that v2 comes from
17:09:15 <lambdabot> JoeyA: You have 1 new message. '/msg lambdabot @messages' to read it.
17:09:34 <JoeyA> that v2, before being returned, may be thrown into a cons, a lambda context, etc.
17:09:45 <JoeyA> and thus, someone else could use v2 after it.
17:09:58 <ski> (oh, sorry, i didn't notice you were back)
17:10:10 <ski> ok, i see
17:10:46 <JoeyA> I'm really not sure what a decent way to allocate memory in a lazy functional language is.
17:11:06 <ski> you might check the papers on what GHC (roughly) does, i suppose
17:11:16 * ski tries to recall the title of the paper ..
17:11:24 <JoeyA> When you allocate on the producing side, in many cases it ends up in a thunk, which is already allocated.
17:11:58 <JoeyA> When you allocate on the consuming side, you don't get to reuse existing buffers.
17:12:42 <JoeyA> e.g. Value *if_f(Value *pred, Value *on_true, Value *on_false) {return force(pred)->b ? on_true : on_false;} // producing-side allocation
17:13:23 <JoeyA> void if_f(Value *out, Value *pred, Value *on_true, Value *on_false) { ??? }
17:13:37 <JoeyA> It could allocate thunks that simply point to the value.
17:13:48 <JoeyA> or it could copy the value, in which case you run into the thunk copying problem again.
17:14:52 <JoeyA> A third option would be to provide an optional buffer to callers.  If the caller uses it, it must return it.  Otherwise, you can't set the optional buffer to the thunk object.
17:15:14 <JoeyA> Then again, maybe the idea of the thunk being replaced by the value is a bit absurd.
17:15:38 <JoeyA> Maybe an evaluated thunk should be set to link to its result rather than contain it.
17:15:51 <JoeyA> That might just be the source of my confusion.
17:16:33 <polypus> what's a good option for a simple, preferably declaritive, gui that will run on a mac w/o too much fuss? i don't care at all about native look and feel
17:17:41 <ski> well, we'd like to avoid a "force thunk0 by (force thunk1 by (...); then overwrite value into thunk1); then overwrite value into thunk0" non-tail-recursive chain
17:18:26 <ski> so "force thunk0, getting either a value or a new thunk1, overwrite the old with the new, and then loop back" seems better from that perspective
17:19:12 <ski> but, as you say, that could have bad consequences, if one's not careful
17:19:41 * ski doesn't really know enough of how to handle this
17:21:31 <JoeyA> I think what I should have done is made a Box type that's distinct from a Value.
17:21:59 <JoeyA> When a Box's value is requested, it's forced if necessary.
17:22:43 <JoeyA> e.g. struct Box {BoxTag tag; union {Thunk *thunk; Value *value};};
17:23:48 <lars9> what's the Monad version of concatMap? liftM concat . mapM ?
17:23:56 <dibblego> (=<<)
17:24:08 <JoeyA> Also, instead of using a force(Box *b) function, maybe it should take a continuation so the stack can be managed.
17:24:38 <McManiaC> my first blog ever: http://nschde.wordpress.com/2010/11/19/simplex/
17:24:39 <lars9> dibblego: thanks
17:24:39 <McManiaC> :D
17:24:39 <JoeyA> well, that's what concatMap equals in the list monad.
17:24:53 <JoeyA> :t concatMap
17:24:54 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
17:24:57 <JoeyA> :t map
17:24:58 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
17:25:00 <JoeyA> :t mapM
17:25:02 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:25:19 <JoeyA> (a -> m [b]) -> [a] -> m [b]
17:25:38 <JoeyA> maybe
17:26:03 <JoeyA> In this case, it maps over a list, performing list-returning actions.  Those lists are concatenated.
17:26:38 <ben> What am I doing wrong if at runtime I get a pattern match failure in do expression at a line beyond the end of my program even if main is just return ()?
17:26:53 <ski> > let stripSuffix = fmap reverse .: stripPrefix `on` reverse in let f ('{':rest) | Just abc <- stripSuffix "}" rest = abc in f "{abc}"
17:26:53 <lambdabot>   "abc"
17:26:55 <ski> > let stripSuffix = fmap reverse .: stripPrefix `on` reverse in let f ('{' : (stripSuffix "}" -> Just abc)) = abc in f "{abc}"
17:26:56 <lambdabot>   "abc"
17:26:57 <JoeyA> :t let concatMapM f = liftM concat . mapM f in concatMapM
17:26:59 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m [a1]) -> [a] -> m [a1]
17:27:06 <ski> lars9 : ^ just two variants
17:27:53 <ski> @type liftM concat .: mapM  -- lars9 ?
17:27:54 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
17:28:09 <monochrom> ben: are you sure? re-saved, re-compiled, re-installed?
17:28:11 <Botje> McManiaC: nice post!
17:28:37 <ben> No. Oh well.
17:29:13 <aristid> ski: that looks like .::, no?
17:29:14 <ben> Ignore me. <:)
17:29:32 <ben> Never noticed that cabal did not output the binary into . because so far I mostly started my program from ghci instead of actually compiling it after changes.
17:29:39 <aristid> @type (fmap.fmap.fmap) concat mapM
17:29:40 <lambdabot> forall a a1 (m :: * -> *). (Functor m, Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
17:29:41 <ski> aristid : hm ?
17:29:52 <aristid> @let (.::)=fmap.fmap.fmap
17:29:52 <lambdabot>  <local>:8:0:
17:29:52 <lambdabot>      Multiple declarations of `L..::'
17:29:53 <lambdabot>      Declared at: <local>...
17:30:00 <aristid> @type concat .:: mapM
17:30:01 <lambdabot> forall a a1 (f2 :: * -> *). (Monad f2, Functor f2) => (a1 -> f2 [a]) -> [a1] -> f2 [a]
17:30:17 <McManiaC> Botje: thanks :)
17:30:26 <lars9> ski: thanks, but reverse is a little bit too much here :D
17:31:07 <ski> lars9 : you can traverse to the end, and start matching on the way back -- but that's not really much better than `reverse' anyway
17:32:23 * ski wonders whether it would be better to try to match (with backtracking ?) at any position, working towards the end, succeeding if they end at the same time
17:32:33 <lars9> ski: yeah, ive done it with ugly take & drop way
17:33:20 <ski> @type let (.::) = (.) . (.) . (.) in concat .:: mapM
17:33:21 <lambdabot> forall a a1 (f :: * -> *). (Functor f, Monad f) => (a1 -> f [a]) -> [a1] -> f [a]
17:33:39 <ski> @type let (.) = (Prelude..); (.::) = (.) . (.) . (.) in concat .:: mapM
17:33:40 <lambdabot> forall a a1 a2. (a1 -> a2 -> [a]) -> [a1] -> a2 -> [a]
17:36:22 <ski> aristid : ok, now i see. the `liftM'/`fmap' became the last `fmap' in `fmap . fmap . fmap' (the others are all `(Prelude..)')
17:36:31 <aristid> ski: :)
17:36:59 * ski was for some reason first thinking it should be the first `fmap' there, but couldn't make it fit together
17:37:49 <ski> still, while we have the `Functor'-not-being-superclass-of-`Monad' issue, i prefer using `liftM' in polymorphic cases like this
17:38:06 <ski> nice spotting, though :)
17:38:25 <aristid> ski: yeah the additional Functor constraint is making it a bit uglier
17:39:36 * ski wonders whether lars9 also perchance is making a mini-Prolog implementation in Haskell
17:40:25 <ski> (i saw `liftM concat . mapM f' before today, in such a one)
17:43:24 <aristid> @unpl \f -> liftM concat . mapM f
17:43:24 <lambdabot> \ f c -> liftM concat (mapM f c)
17:44:05 <aristid> :t \f c -> mapM f c >>= \x -> return (concat x)
17:44:06 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a -> m [a1]) -> [a] -> m [a1]
17:50:21 <ski> @pl ma >>= \a -> return (f a)
17:50:21 <lambdabot> f `fmap` ma
17:50:45 <lars9> if f :: IO String may fail, how to handle it with Maybe or Either?
17:51:46 <lars9> for f, g, h ... :: Maybe String, we can use f >> g >> h to get the first right answer
17:52:18 <aristid> ski: see, my manual @unpl was more complete
17:52:43 * ski is half asleep, so didn't notice the `unpl'
17:53:19 <ski> lars9 : `f :: IO (Maybe String)' or `f :: IO (Either YourError String)' ?
17:54:11 <ski> or better, `MaybeT IO String' alt. `EitherT YourError IO String' (or whatever `EitherT' is called in your favourite monad library)
17:54:51 <lars9> ski: how to use MaybeT to do that?
17:55:27 <aristid> > fail "Failure!" :: Maybe ()
17:55:28 <lambdabot>   Nothing
17:55:35 <ski> usae `lift' (or `liftIO') to convert from `IO Foo' to `MaybeT IO Foo'
17:55:47 <lars9> ski: let me try:)
17:56:05 <ski> `mzero' (i think) for failing in `MaybeT IO'
17:56:46 <lars9> how to get IO String back from MaybeT IO String?
17:56:51 <ski> your `EitherT' should have some kind of `throw'/`raise' operation of type `YourError -> EitherT YourError IO a' (in your specific case)
17:57:10 <ski> there should be a `runMaybeT :: MaybeT m a -> m (Maybe a)'
17:57:35 <ski> so you get `IO (Maybe String)' back, and you have to check then the `Nothing' case manually, at the top call
17:57:36 <lars9> then return . fromJust ?
17:58:05 <ski> don't `fromJust' unless you're really sure there won't be a `Nothing' (and in that case, why use `Maybe'/`MaybeT' at all ?)
17:58:28 <ski>   do ...
17:58:30 <lars9> ski: i see
17:58:38 <ski>      ma <- runMaybeT myAction
17:58:43 <ski>      case ma of
17:58:54 <ski>        Nothing -> ..handle failing case..
17:59:05 <ski>        Just s -> ..you've got your `s' string..
17:59:58 <lars9> ski: thanks, let me see if it works :D
18:05:00 <byorgey> hrmph, how come transformers has Data.Functor.{Identity,Constant,Product,Compose}, but no Sum ?
18:05:30 <byorgey> maybe I will make a patch.
18:07:28 <lars9> ski: it seems Maybe and Error are used to stop on error, what else is designed to stop on success?
18:08:18 <ski> maybe you're looking for `mplus' ?
18:08:45 <lars9> > mplus Nothing (Just 1)
18:08:46 <lambdabot>   Just 1
18:08:47 <ski> > Nothing `mplus` Nothing `mplus` Just 2 `mplus` Just 3 `mplus` Nothing `mplus` Just 5
18:08:47 <lambdabot>   Just 2
18:08:55 <lars9> ski: awesome
18:09:05 <ski> > msum [Nothing,Nothing,Just 2,Just 3,Nothing,Just 5]
18:09:06 <lambdabot>   Just 2
18:09:09 <lars9> > Left 1 `mplus` Right 2
18:09:10 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:09:10 <lambdabot>    `GHC.Num.Num t'
18:09:10 <lambdabot>      ari...
18:09:22 <lars9> > Left 1.1 `mplus` Right 2.1
18:09:24 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:09:24 <lambdabot>    `GHC.Real.Fractional t'
18:09:24 <lambdabot> ...
18:09:25 <ski> > msum [[],[],[2],[3],[],[5]]
18:09:25 <lambdabot>   [2,3,5]
18:09:42 <lars9> msum [Left 1, Right 3]
18:09:48 <lars9> > msum [Left 1, Right 3]
18:09:49 <lambdabot>   Ambiguous type variable `t' in the constraints:
18:09:49 <lambdabot>    `GHC.Num.Num t'
18:09:49 <lambdabot>      ari...
18:10:05 <lars9> > msum [Left 'a', Right 'c']
18:10:06 <lambdabot>   No instance for (Control.Monad.Error.Class.Error GHC.Types.Char)
18:10:06 <lambdabot>    arising...
18:10:16 <ski> > msum [Left "a",Left "b",Right 2,Right 3,Left "c",Right 5]
18:10:17 <lambdabot>   Right 2
18:10:21 <ski> > msum [Left "a",Left "b"]
18:10:22 <lambdabot>   Left ""
18:10:41 <lars9> ski: oh it has to be Error
18:10:51 <lars9> awesome, thanks
18:11:03 <thoughtpolice> gah
18:11:17 * thoughtpolice hates it when messages to g-h-u or cvs-ghc get pushed into the approval queue :/
18:11:26 <thoughtpolice> apparently my message was too big :(
18:17:19 <ski> lars9 : i think at least in recent libraries, the insistence on `Error' for `Either' is removed
18:18:50 <lars9> ski: apparently maybeT is not in mtl... but in a single maybet pkg
18:19:10 <ski> yeah
18:19:15 <ski> (for some strange reason)
18:19:44 <lars9> how strange?
18:24:29 <byorgey> MaybeT is in the most recent version of transformers, which 
18:24:54 <lars9> byorgey: you mean MTL?
18:25:05 <byorgey> no, I mean the transformers package
18:25:28 <byorgey> the newest version of mtl is just a compatibility wrapper around transformers + monads-fd anyway
18:25:38 <aristid> byorgey: no, other way round
18:25:52 <aristid> mtl now depends on transformers, and monads-fd is a thin shim around mtl
18:26:30 <byorgey> oh, I see, I was confused.
18:26:42 <byorgey> at any rate transformers exports some stuff that mtl does not re-export.
18:26:43 <geheimdienst> how does monads-tf fit in the picture?
18:27:48 <aristid> geheimdienst: ugh. maybe it reexports mtl-tf, or not. i have not checked that. and sane people simply use mtl, without -tf
18:29:12 <geheimdienst> k, thanks :)
18:29:30 <geheimdienst> i only know monads-tf because it occasionally clashes with mtl and needs to be hidden
18:30:00 <Kaidelong> occassionally?
18:32:18 * hackagebot multiplate 0.0.1 - Lightweight generic library for mutually recursive data types.  http://hackage.haskell.org/package/multiplate-0.0.1 (RussellOConnor)
18:33:02 <aristid> geheimdienst: heh, yeah. some crazy people seem to use it, so i unfortunately have it installed too
18:33:24 <lars9> in f :: MaybeT IO String, how to return a Nothing and how to return a just "abc" ?
18:34:55 <roconnor> lars9: mzero will give you nothing
18:35:09 <roconnor> return "abc" for the other
18:35:18 <lars9> thanks:)
18:35:27 * roconnor isn't 100% sure about mzero
18:35:28 <lars9> return mzero or just mzero?
18:35:43 <aristid> lars9: just mzero
18:35:43 <roconnor> return mzero is definitely wrong
18:36:54 <aristid> > mzero :: MaybeT Maybe ()
18:36:55 <lambdabot>   Not in scope: type constructor or class `MaybeT'
18:38:02 <alex404> Is the ghc stack unreasonably small or am I probably doing something wrong if I'm causing an overflow?
18:38:54 <aristid> alex404: probably doing something wrong:)
18:39:41 <alex404> aristid: What would typically cause it?
18:39:54 <aristid> alex404: uh, depends :D
18:41:54 <alex404> aristid: I'll ask wikipedia ;)
18:54:17 <lispy>  :t return mzero
18:54:32 <lispy> ?botsnack
18:54:33 <lambdabot> :)
18:54:39 <lispy> :t return mzero
18:54:40 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (MonadPlus m, Monad m1) => m1 (m a)
18:54:44 <lispy> tricksy spaces
19:09:19 <miggyx> Hi guys, what would you call the type of testing that involves a third party service? For example a web API or a price feed etc...
19:12:04 <danderson> probably end to end testing. Maybe integration testing at a stretch, depending on how much of your own code you exercise.
19:12:24 <danderson> but tests involving third parties with code you don't control are inherently brittle, so I'd go with end-to-end.
19:12:26 <wisepumpkin> fuzzing? :P
19:12:28 <danderson> that said, what does it matter?
19:12:30 <danderson> it's testing.
19:12:32 <wisepumpkin> pen testing? ;)
19:12:41 <wisepumpkin> hax
19:12:46 <danderson> write the tests instead of worrying over terminology.
19:16:45 <miggyx_> sorry, connection timed out :)
19:17:30 <miggyx_> I'm interested in finding a better way to test the "impure" components
19:19:51 <miggyx_> I've been hunting around for papers and other attempts at doing this, but there doesn't seem to be a specific name for what I'm looking for - which makes searching for it somewhat challenging :)
19:22:33 <onteria> one day I'll actually understand what lambdabot spews out
19:26:49 <monochrom> call it "cloud testing" if your testing needs external web services. it's a catchy name. everyone loves "cloud thingy".
19:26:58 <lars9> in f's do block, where f::MaybeT IO String, how to use l <- getLine ?
19:27:06 <miggyx__> third internet connection lucky....
19:27:18 <monochrom> l <- liftIO getLine
19:27:34 <miggyx__> not sure if these messages got through so:
19:27:39 <miggyx__> I'm interested in finding a better way to test the "impure" components
19:27:40 <lars9> @hoogle liftIO
19:27:40 <lambdabot> Control.Monad.Trans liftIO :: MonadIO m => IO a -> m a
19:27:43 <miggyx__> I've been hunting around for papers and other attempts at doing this, but there doesn't seem to be a specific name for what I'm looking for - which makes searching for it somewhat challenging :)
19:27:44 <monochrom> also try: liftIO (putStrLn l)
19:30:42 <lars9> monochrom: liftIO is defined mtl, but the MaybeT i used is defined in transformers... why aren't they in the same pkg
19:31:47 <monochrom> it's in transformers too. I just used it half an hour ago. import Control.Monad.IO.Class
19:32:22 <lars9> monochrom: thanks
19:32:26 <lars9> hoogle didnt see it
19:32:48 <miggyx__> Does anyone know where the concept of pure / impure functions originates?
19:48:36 <revenantphx> hm...
19:48:44 <revenantphx> tomorrow... I think I'll write my ant simulation in haskell!
19:49:05 <revenantphx> Using only pure functions should actually end up making it the code very very close to the mean field models...
19:59:09 <roconnor> revenantphx: are you doing an ICFP contest?
19:59:23 <revenantphx> what?
19:59:33 <revenantphx> no, I'm writing simulations in C for a math professor.
20:13:54 * monochrom successfully confuses ghc and cabal-install to hell :)
20:14:15 <alex404> monochrom: Oh?
20:15:31 <monochrom> cabal install enumerator-fd => "Warning: This package indirectly depends on multiple versions of the same package. ... package enumerator-0.4.2 requires transformers-0.2.2.0 ... package monads-fd-0.1.0.4 requires transformers-0.2.2.0 ... enumerator-fd-0.1 failed during the building phase." :)
20:15:35 <jre2> any idea how I can send/recv euc-jp encoded strings over a handle in haskell? I haven't seen any libraries for non-unicode multibyte encodings
20:16:01 <alex404> hah
20:16:22 <monochrom> (disclaimer: this is not the fault of enumerator-fd etc. I deliberately screwed with multiple installs and uuids to achieve it.)
20:19:50 <alex404> I used to think profiling was a chore... now I find it one of the most fun parts.
20:20:11 <alex404> Just tripled the speed of my program by rewriting a core function...
20:20:17 <alex404> I love all these profiling tools.
20:21:03 <byorgey> alex404: nice =)
20:21:14 <monochrom> is euc-jp also known as one of the iso-something or windows cp-something? http://hackage.haskell.org/package/encoding has a bunch of those.
20:21:34 <monochrom> or jis-something
20:26:51 <Causalien> @_@
20:27:14 <monochrom> does not win you any sympathy
20:27:32 <Causalien> Yes slave driver whip me more
20:38:17 <jre2> monochrom: it's based on some iso standard but isn't JIS or shift-JIS. I'll look at encoding though
20:39:37 <lars9> fordo now updated, the magic brackets {} now support sed {s/\(.*\)\.\(.*\)/\2.\1/} and file counter {9}. https://code.google.com/p/fordo/
20:40:38 <kmc> jre2, i think iconv can do every encoding ever
20:40:55 <kmc> there's a haskell binding, plus you could just run your text through the command-line tool
20:42:00 <jre2> kmc: i just tried it before you said that and got iconv to work (more or less)
20:42:06 <kmc> cool!
20:42:12 <kmc> the haskell binding?
20:42:18 <jre2> yea
20:43:19 <jre2> question though, since iconv uses lazy bytestrings- how do I print a bytestring to stdout and get it to display correctly?
20:43:44 <kmc> well, a bytestring represents bytes
20:43:54 <kmc> and your terminal is going to interpret those bytes as characters in some encoding
20:44:11 <kmc> so displaying correctly is a matter of converting the bytestring to the right encoding
20:44:11 <jre2> kmc is there a way to specify or at least hint what it should use though?
20:44:49 <kmc> i don't think you can tell the terminal what encoding to use
20:45:20 <kmc> you can determine what encoding your terminal uses by inspecting various environment variables like $LANG
20:45:34 <kmc> and GHC ≥6.12 does this, when doing text IO
20:45:37 <Ziphilt> i have a custom type, and it is based on a list. i want it to be an instance of Show, but without the brackets and commas from the list appearing. i know how to derive Show on the type inside the list, but that gets brackets and commas around the symbols. how can i do this?
20:45:43 <jre2> kmc currently I'm reading input from a file, converting utf8>euc-jp, doing my work, then converting back to utf8 and writing to a file. it works, but it's a little convoluted
20:45:45 <kmc> but bytestring isn't text; it's binary bytes
20:46:03 <kmc> you're converting *to* euc-jp to do your work?
20:46:31 <kmc> Ziphilt, instance Show MyType where show (MyConstructor xs) = intercalate " " $ map show xs
20:47:15 <jre2> kmc: I'm trying to write a library for mecab, which afaik only uses euc-jp
20:47:20 <kmc> ok
20:47:27 <Ziphilt> um, that might work, thanks kmc
20:47:48 <kmc> in a native Haskell text-processing app you would not use utf8 or euc-jp or any other encoding
20:47:56 <kmc> you'd use a type that represents characters, not bytes
20:48:00 <kmc> such as String or Text
20:48:08 <kmc> however if you're talking to some external library, i guess you have no choice
20:49:17 <jre2> kmc: yea, Text was my first try until I realized I needed a non-unicode multibyte character encoding
20:49:50 <kmc> i thought Data.Text had a function for "decode my ByteString into Text using the system locale"
20:49:57 <Ziphilt> kmc, can i only do that with type constructors, not type synonyms?
20:50:08 <Ziphilt> GHCi complained when i tried it with a synonym
20:50:15 <kmc> Ziphilt, you can't declare an instance for a synonym.  the instance for the synonym has to be the same as the underlying type
20:50:20 <kmc> otherwise it wouldn't be much of a synonym
20:50:36 <Ziphilt> that makes sense
20:50:51 <kmc> (you can *use* a synonym in an instance head, if you turn on an extension, but it's the same as just expanding the synonym yourself)
20:50:58 * hackagebot hs2bf 0.6.2 - Haskell to Brainfuck compiler  http://hackage.haskell.org/package/hs2bf-0.6.2 (DaikiHanda)
20:51:06 <kmc> you can't have a different instance for String and for [Char]
20:51:53 <Ziphilt> so my underlying type is called CellState, and i want [CellState] to show up like ◌●◌ instead of [Dead, Alive, Dead]
20:52:01 <kmc> ah ok
20:52:05 <kmc> do you want to redefine show for CellState?
20:52:23 <kmc> instance Show CellState where show Dead = "◌"; show Alive = "●"
20:52:27 <Ziphilt> i already hacked a show' so it would work, because i could not get instancing to work
20:52:32 <kmc> yeah
20:52:35 <kmc> i think you shouldn't use Show at all
20:52:39 <Ziphilt> but i now want it to look nice
20:52:43 <kmc> just make a custom function [CellState] -> String
20:52:50 <Ziphilt> okay
20:53:05 <kmc> Show is mostly useful *because* you can derive it
20:53:11 <Ziphilt> i just assumed i should be making it an instance of Show
20:53:15 <kmc> nah
20:53:16 <Ziphilt> that makes sense
20:53:29 <Ziphilt> (what you just said about being able to derive it)
20:53:32 <kmc> i mean, if you have to interface to some particular library that wants to use Show
20:53:33 <kmc> then go ahead
20:53:53 <Ziphilt> then, can i call it show too?
20:53:54 <kmc> but in general Show is used for barebones abstract syntax tree, not so much for pretty printing
20:53:57 <Ziphilt> would that break it?
20:53:59 <kmc> then you'd have to call it show
20:54:04 <kmc> you can't call your custom function show
20:54:09 <Ziphilt> okay
20:54:16 <kmc> or, you can, but you'd have to use it with a qualified module name -- a pointless hassle
20:54:20 <Ziphilt> i'll keep it show' i guess?
20:54:31 <kmc> there's probably a better name than that
20:54:36 <kmc> like "pretty" or "render"
20:54:48 <Ziphilt> universeToString
20:54:53 <Ziphilt> is what i was thinking
20:54:57 <kmc> render is shorter ;)
20:54:57 <Ziphilt> anyway, thanks
20:55:00 <kmc> but whatever you like :)
20:55:01 <kmc> no prob
20:55:17 <kmc> jre2, so, you have utf8 in a ByteString, and you want to print it on your terminal in whatever encoding your terminal uses?
20:55:33 <kmc> i'm working off "how do I print a bytestring to stdout and get it to display correctly?"
20:55:44 <alex404> If my GC is taking up 60% of my time, that's a bad thing right?
20:55:52 <kmc> alex404, probably.  try raising the allocation area size
20:55:58 <kmc> ./myprog +RTS -A400M
20:56:05 <alex404> cool
20:56:15 <Axman6> try profiling and finding out what's allocating so much
20:56:18 <kmc> that too
20:56:33 <Axman6> changing the allocation area is just stick a bandaid on when you have the flu ;)
20:56:39 <Axman6> sticking*
20:56:42 <alex404> It's matrix operations
20:56:52 <alex404> InnerProduct and Outerproduct
20:56:52 <kmc> not entirely; some programs will pretty much have to allocate a lot
20:56:55 <alex404> using generate on vectors
20:57:23 <kmc> lots of allocation does not imply a space leak or lots of live data
20:57:23 <alex404> That's 40% of it anyway, and there are some other vector operations
20:57:28 <jre2> kmc: ah, it seems explicitly converting the bytestring back to utf8 is good enough to display it
20:57:30 <Axman6> kmc: is there's a lot of GC'ing going on though, it's allocating a lot then trashing it, which may not be needed at all
20:57:40 <kmc> jre2, because it happens that your terminal uses utf8
20:57:49 <kmc> yeah
20:58:10 <alex404> There's not really anyway around generating these huge arrays all the time...
20:58:34 <kmc> ST ;)
20:58:37 <alex404> Though I don't know why inner product is taking so much space... it's just a zip
20:58:48 <alex404> Well, outerproduct can't be inplace
20:59:06 <alex404> And ST makes me sad :(
20:59:12 <alex404> Well
20:59:15 <alex404> It's a nice interface
20:59:19 <alex404> But it's not why I'm here ;)
20:59:28 <kmc> yeah
20:59:38 <kmc> using ST is giving up ;)
21:00:13 <kmc> pure functional > ST > IO > FFI > C++
21:00:14 <kmc> ;)
21:01:07 <alex404> Yah
21:01:11 <alex404> Well
21:01:23 <alex404> pure functional > ST > IO > FFI > C > C++
21:01:31 <kmc>  > PHP
21:01:36 <alex404> heh
21:01:38 <alex404> Really?
21:01:44 <alex404> C++ > PHP?
21:01:46 <kmc> i dunno bout you but i use PHP for all my numerical matrix code
21:01:55 <alex404> I've never used PHP
21:02:00 <alex404> Umm...
21:02:20 <alex404> but isn't it a scripting language ;P
21:02:47 <alex404> Okay, but seriously
21:02:53 <alex404> Shouldn't this: innerProduct v1 v2 = V.sum $ V.zipWith (*) v1 v2
21:03:04 <alex404> Fuse and be all constant space and happy?
21:03:49 <kmc> that question is beyond my pay grade :/
21:04:06 <kmc> i would hope so anyway
21:04:17 <kmc> you could look at the Core, debug output about rules firing, etc
21:04:20 <alex404> It's beyond mine too, but that seems like as simple a case as possible
21:04:52 <alex404> *sigh* Core.
21:05:07 <alex404> This is why I tell people I am but a brown belt in haskell
21:06:27 <mejalx> BROWN BELT
21:06:29 <mejalx> KUNG FU
21:06:44 <alex404> KARATE?
21:07:12 <monochrom> catamorphism brown belt
21:07:39 <mejalx> sorry, i had to buy a few crates of Four Loko before it got removed from all shelves
21:07:53 <kmc> mejalx, where are you?
21:08:01 <mejalx> Atlanta, GA, USA
21:08:04 <kmc> cool
21:08:18 <mejalx> I use haskell for real work, I'm awesome
21:08:18 <monochrom> oh, is that the caffeine overdose alcohol overdose drink?
21:08:19 * kmc ♫ dueling banjos ♫
21:08:22 <mejalx> yeah it is
21:08:23 <kmc> really mejalx, cool
21:08:41 <deech> Hi all, is there a simple way of running a shell command and capturing the result in Haskell? I looked in System.Process and couldn't figure it out.
21:09:05 <alex404> mejalx: Woah. That sounds delicious.
21:09:10 <alex404> Or disgusting.
21:09:20 <alex404> Hmm...
21:09:22 <Causalien> what kind of real work mejalx?
21:09:25 <kmc> yes, it's System.Process deech 
21:09:33 <kmc> deech, for example readProcess
21:09:44 <mejalx> Causalien: automated trading
21:09:45 <alex404> It's the necker cube of drinks...
21:09:58 <kmc> process's_stdout <- readProcess "/path/to/file" ["list", "of", "args"] "stuff on stdin"
21:10:06 <mejalx> it's the the best kinda fuck up
21:10:10 <kmc> nice mejalx
21:10:12 <mejalx> four loko
21:10:12 <deech> kmc: I'm trying to run a curl command and using  readProces doesn't seem to work.
21:10:13 <Causalien> oh cool. that's why i am learning haskell too
21:10:14 <kmc> high frequency?
21:10:22 <kmc> deech, strange.  doesn't work how?
21:10:32 <mejalx> no, i just mostly do exotic FX work, pricing models, sometimes risk models
21:10:37 <kmc> ah, that makes sense
21:10:44 <kmc> Haskell is used at lots of banks for derivatives modeling
21:10:52 <alex404> That's pretty sweet
21:10:53 <mejalx> nothing we do here is HFT
21:11:00 <kmc> it's not a good fit for HFT unless you're using it to implement DSLs that output C or something
21:11:06 <alex404> It's nice to know there's interesting work outside of academia
21:11:32 <kmc> finance sector has a whole host of problems though
21:11:35 <kmc> not that other sectors don't
21:11:50 <deech> for eg. readProcess "curl http://google.com" returns a result on the command prompt .... oh I just figured it out
21:11:52 <Causalien> Do you do the modelling in haskell? Or you output to matlab for that?
21:12:00 <kmc> readProcess "curl" ["http://google.com"]
21:12:13 <alex404> Why would you output to matlab?
21:12:21 <deech> kmc: Yeah Ijust got it. Thanks!
21:12:22 <kmc> because matlab has some library you want to use
21:12:45 <monochrom> generally academia actually love to get involved in industry but there are too many NDAs obstructing.
21:13:11 <alex404> I've yet to encounter a matlab library I've *needed*... though I guess I've yet to do anything really esoteric...
21:13:17 <alex404> monochrom: NDA?
21:13:25 <monochrom> non-disclosure agreements
21:13:31 <alex404> ah
21:13:32 <alex404> right
21:13:33 <mejalx> agreed, i was mostly a C++ programmer, got introduced to Lua because the firm I work for embeds Lua into everything
21:13:43 <alex404> Yah, I guess that would be a bitch
21:13:43 <mejalx> but then our credit derivatives person got into haskell
21:13:43 <Causalien> Well, it just beats rewriting the models in a language I don't understand for now.
21:13:51 <mejalx> brought a whole change to the software dev environmen
21:13:52 <mejalx> t
21:14:08 <kmc> i like Haskell but i've had enough of finance and i'm not sure i'd go back even for a Haskell job
21:14:11 <kmc> language isn't everything
21:14:16 <kmc> but, if you enjoy it, more power to you
21:14:27 <alex404> Also $$?
21:14:34 <kmc> well that depends
21:14:46 <kmc> you might get paid average salary for a year with the promise of a big bonus
21:14:49 <kmc> you may or may not get that bonus
21:14:58 <alex404> Noted
21:15:06 <kmc> for reasons that you may or may not have any control over
21:15:28 <alex404> I don't know about you, but I have a recession switch under my desk
21:15:30 <onteria> I'd rather program as a hobby then get paid for it. 
21:15:40 <mejalx> working in the financial industry should be another topic imo. good group of us in #redditfinance
21:15:52 <kmc> and by average salary i mean the same as google, microsoft, etc
21:16:11 <kmc> which is not bad money at all, but not the huge sacks of cash that people are promised
21:16:22 <kmc> anyway yeah, i'll be in #haskell-blah if you want to talk more
21:23:22 <turiya> what does unsafePerformIO do?
21:25:00 <Jafet> Unsafely performs IO
21:25:10 <Jafet> @hoogle unsafePerformIO
21:25:10 <lambdabot> Foreign unsafePerformIO :: IO a -> a
21:25:10 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
21:25:35 <cdsmithus> turiya: the answer depends on your mental model of how Haskell operates: if you see Haskell as a language with side effects that controls their scope with I/O annotations in the type system, then unsafePerformIO just cheats with the type annotations and performs IO where the type system should preclude it.  Does that match your mental model?
21:26:40 <turiya> cdsmithus: yes, sort of..
21:27:05 <cdsmithus> turiya: then that's what it does... it takes something that does I/O, and forges a pure type for it
21:27:05 <JoeyA> let xs = 0 : 1 : unsafePerformIO readLn
21:27:18 <turiya> if i write unsafePerformIO (putStrLn "here")
21:27:18 <JoeyA> then try xs a couple of times
21:27:27 <turiya> what happens
21:27:47 <cdsmithus> turiya: then you have a value of type ()... which if you force it, will as a side effect of its evaluation print to the console
21:29:07 <turiya> oh..
21:29:29 <turiya> what is the advantage of unsafePerformIO? 
21:29:43 <Jafet> trace!
21:30:13 <Jafet> Well, it's used for implementation details.
21:30:18 <cdsmithus> turiya: By one way of thinking, there should only be two values of type (): namely, bottom, and ().  But in reality, there are all sorts of "side effects" -- for example, the computer spends some time computing -- that we just consider "unimportant" and therefore okay to have as side effects.  Essentially, unsafePerformIO lets you add other "unimportant" side effects.
21:31:05 <cdsmithus> trace is indeed an example: printing debug statements as the program runs is thus defined to be an "unimportant" side effect
21:32:00 <Jafet> It's also used to implement things with "pure" interfaces, like spoon.
21:32:00 <turiya> cdsmithus: is it also used to make impure code look like pure code?
21:32:17 <onteria> I have a question regarding list comprehensions and word replacements. It's somewhat long to explain so I've put it here with code and comments: http://hpaste.org/41656/word_replacement
21:32:27 <cdsmithus> turiya: Yes, it take impure code, and causes it to type-check as pure code.  Of course, making it *act* like pure code is up to you.
21:32:41 <onteria> well, two questions actually...
21:33:00 <turiya> so, where can one go wrong in using unsafePerformIO?
21:33:12 <cdsmithus> turiya: pretty much everywhere.
21:33:13 <turiya> what are the "blunders" that one should not do
21:34:19 <cdsmithus> turiya: That's too broad of a question, I think.  You need to have a very specific reason for *using* unsafePerformIO, and you generally work pretty hard to prove correctness.  If you don't, then everything else is a place where something can go wrong.
21:34:24 <Jafet> It's not a blunder, just an illegal move
21:34:36 <turiya> cdsmithus: supposing I malloc an array in C and return it using unsafePerformIO, what possible problems will i face?
21:35:08 <Jafet> turiya: none. Until you try to use it.
21:35:08 <Cale> onteria: You can use the tails function to treat the tails of a list.
21:35:22 <Cale> onteria: (perhaps along with isPrefixOf)
21:35:46 <turiya> Jafet: hmm..
21:35:54 <turiya> Jafet: why?
21:36:00 <Cale> Also, unwords is the "opposite" of words.
21:36:28 <Jafet> turiya: why what?
21:36:38 <cdsmithus> turiya: if you allocate memory in unsafePerformIO, first of all, it's in general unspecified whether that memory is reallocated every time the expression is evaluated, or just allocated once... since you don't know how many times malloc was called, it's generally impossible to avoid memory leaks or multiple frees.
21:37:38 <cdsmithus> So you end up writing compiler pragmas.... and it's messy
21:37:56 <Xilon> I've made two instances of a class, one for String and the other for Num. Why would they overlap? http://hpaste.org/41657/overlapping_instances_num_st
21:38:16 <Jafet> Xilon: because Num isn't a type
21:38:21 <cdsmithus> Xilon: Num is a typeclass.  It's entirely possible someone might write an "instance Num String"
21:38:35 <cdsmithus> in which case both of your instances would apply
21:38:39 <Cale> Xilon: There's no way to determine a-priori that there won't be an instance of Num for String in some future module.
21:38:51 <turiya> cdsmithus: so, if I make impure code look like pure code, haskell compiler need not evaluate the expression twice?
21:39:06 <onteria> Cale:  ah, that's what I was looking for. Thanks!
21:39:32 <Jafet> turiya: if it looks like pure code, your compiler will arbitrarily decide how many times to evaluate it
21:39:43 <cdsmithus> turiya: indeed, generally if something is not inlined and has a monomorphic type, lazy evaluation means it will only be evaluated once.  But inlining can mess with that, as can type polymorphism
21:39:58 <Jafet> If that doesn't match up with how many times you want it evaluated, then you may have a problem
21:40:52 <cdsmithus> turiya: Then again, nothing in the Haskell spec guarantees that the Haskell *does* lazy evaluation... only non-strict evaluation... hence, these details are not specified in general
21:40:59 <turiya> ok, so the unsafe operation is prone to such problems?
21:41:11 <Xilon> Right, was confused because there isn't a String instance.
21:41:57 <cdsmithus> Xilon: for Num String, you mean?  Right, there isn't yet.  But type classes are open; one can be added later
21:42:01 <turiya> cdsmithus: i dont understand what inlining and monomorphic types are..
21:42:08 <Jafet> Can instances be scoped?
21:42:21 <cdsmithus> turiya: Don't worry about it then.  They are just reasons that the answer is "it depends"
21:42:29 <Cale> Xilon: For that reason, when the compiler selects which instance to use, it relies entirely on the structure of the type itself, and not on which typeclasses it belongs to.
21:43:28 <Cale> So, for the purposes of committing to a choice of instance, it's sort of like an  instance (Num a) => Foo a  is like  instance Foo a
21:43:54 <Cale> (The test to ensure the type is in Num happens after committing to the instance)
21:44:04 <turiya> cdsmithus: i was surprised to see that in order to use the library hsmatrix we dont need to use a "do" block, even though there were a lot of foreignptr's flying around
21:44:13 <turiya> hmatrix*
21:44:58 <turiya> it looks like the library is using some unsafe operations
21:45:04 <cdsmithus> turiya: Sure, it's fairly common to encapsulate foreign libraries in a pure interface using unsafePerformIO... but it's tricky in general to get it right.
21:45:12 <Xilon> So is there any way for me to make a "generic" function that applies to all number-like types? I don't actually need anything from Num, just that it was conveniant.
21:45:32 <Jafet> Xilon: what's "number-like"?
21:45:44 <Jafet> (String isn't very number-like.)
21:46:06 <cdsmithus> Xilon: You can make something work for all number-like types.  You can also make it work for Strings, but... since Strings *might* be number-like, you can't do both without overlapping instances
21:46:09 <turiya> as someone with not much experience with "unsafe" actions, can i assume that such libraries have gotten it right?
21:46:38 <Xilon> Jafet: Int, Integer, Float, etc
21:46:52 <cdsmithus> turiya: Yes, I think hsmatrix is pretty trustworthy.  Maybe they got something wrong, but it's unlikely.
21:47:02 <Cale> Xilon: Well, you can just make it a normal typeclass-polymorphic function of type  (Num a) => a -> ...
21:47:18 <ddarius> turiya: It depends on what you mean.  If you mean can you assume it for the purpose of using the code, then one typically assumes library code is (more or less) right.  If you mean can you assume it for the purpose of copying their approach, then I'd say no.
21:47:30 <turiya> cdsmithus, ok.. i wont bother writing all that matrix stuff by myself..
21:47:45 <turiya> ddarius: no, i just want to use it as a library
21:47:47 <Jafet> Xilon: what do those types have in common that make them "number-like"?
21:49:04 <Xilon> They represent numbers.
21:49:29 <Jafet> "Define numbers" "Numbers represent numbers"
21:49:41 <Jafet> @src Num
21:49:42 <lambdabot> class  (Eq a, Show a) => Num a  where
21:49:42 <lambdabot>     (+), (-), (*)           :: a -> a -> a
21:49:42 <lambdabot>     negate, abs, signum     :: a -> a
21:49:42 <lambdabot>     fromInteger             :: Integer -> a
21:50:30 <cdsmithus> Xilon, the Num type class is almost surely the right way to do what you want with numbers.  The only question is why you want your function to also work for Strings.
21:51:29 <turiya> i am very happy to find that something impure can be made pure by an unsafe operation.. it helps a lot to have a library like hmatrix.. :)
21:51:55 <Jafet> turiya: you need look no further than hGetContents
21:52:17 <Xilon> The function serializes data in a way. The serialized format is data_type[:length]:data. So depending on the input type it would determine the data_type correctly.
21:52:27 <Jafet> In that case it relaxes the definition of "pure" to "this file won't go away as long as the program runs"
21:52:28 <cdsmithus> Xilon: if it *has* to work that way, then you might need to wrap your numeric types in a newtype to make it clear they should be treated with the Num-based instance rather than a more specific one.
21:52:34 <turiya> how do i ask lambdabot about hGetContents
21:52:45 <Jafet> @src hGetContents
21:52:46 <lambdabot> Source not found. The more you drive -- the dumber you get.
21:52:55 <cdsmithus> @info hGetContents
21:52:55 <lambdabot> hGetContents
21:52:58 <cdsmithus> oops
21:52:59 <Jafet> You can't -- try the ghc library source.
21:53:09 <Jafet> It uses unsafeInterleaveIO.
21:53:24 <Xilon> It doesn't have to work that way. I'm just playing around with it. Just trying to avoid writing an instance for every number type (since they would be identical).
21:53:24 <turiya> ok, the other unsafe operation..
21:53:44 <Jafet> One of the other unsafe operations.
21:54:09 <Jafet> Xilon: why not use an existing serialization library?
21:54:26 <Jafet> Well, I bet those libraries use overlapping instances internally.
21:54:30 <turiya> Jafet: why are there only two listed in System.IO.Unsafe?
21:54:33 <Jafet> But you should still look at them.
21:54:58 <Jafet> Because unsafeCoerce is in Unsafe.Coerce for some otherworldly reason
21:55:13 <onteria> list comprehensions are unusually fun
21:55:31 <ddarius> Jafet: Why would it be under System.IO?
21:55:31 <Xilon> Jafet: It's pretty much a toy project to learn Haskell, so it's more about learning the language than actually serializing it properly.
21:55:31 <turiya> @src unsafeCoerce
21:55:31 <lambdabot> Source not found. Wrong!  You cheating scum!
21:55:44 <ddarius> Also unsafeCoerce is insanely unsafe.
21:56:41 <cdsmithus> Xilon: I question the wisdom of trying to serialize *all* numeric types in the same way, which is unlikely to be a reasonable thing to do.  For example, one of my projects has a Num instance for (computable) row-finite matrices.  Your serialization code won't work on it, I promise. :) 
21:56:57 <Axman6> @pl \f xs ys -> f <$> xs <*> ys
21:56:58 <lambdabot> (. (<*>)) . (.) . (<$>)
21:57:02 <Axman6> :\
21:57:18 <dsunshine> @src RunResult
21:57:18 <lambdabot> Source not found. You speak an infinite deal of nothing
21:57:35 <Jafet> How do you plan to unserialize that data, Xilon?
21:57:40 <ddarius> More simply, deserialize (serialize pi) :: Int probably won't do the right thing.
21:57:45 <Xilon> cdsmithus: Yeah I'd probably want to limit to the "primitive" Int, Integer, etc types. Using Num is pretty naive.
21:58:14 <cdsmithus> Xilon: So you probably actually want either the Integral or Real type classes, I suppose... but in that case, why not just provide instances for Integer or Rational, and let people put in the fromIntegral or toRational calls explicitly?
21:58:16 <Xilon> Jafet: That is an issue :D. Haven't corssed that bridge yet
21:58:17 <ddarius> deserialize (serialize (2^200) :: Int) probably won't do the right thing either.
21:58:55 <ddarius> Er move the last parethesis left some.
21:59:02 <Jafet> Xilon: if you're going that way, you can look at a json serialization library or other
21:59:46 <dsunshine> Given a class definition (on hackage) how do you reteive data from that type?
21:59:52 <Jafet> There just so happens to be a chapter explaining a json library in rwh.
22:00:09 <cdsmithus> dsunshine: It depends very much on which class.
22:00:21 <cdsmithus> Did you have one in mind?
22:00:26 <dsunshine> I'm looking at RunResult which is part of HSH
22:01:30 <cdsmithus> dsunshine: Okay, so that's actually used in the result of a function... you can just coerce the function call to your choice of types.
22:02:27 <cdsmithus> For example:  r <- run "ls *.txt" :: IO Bool
22:02:33 <Xilon> cdsmithus: Good point, Integral/Real would probably do nicely.
22:03:31 <cdsmithus> Xilon: or alternatively, if you want to take advantage of knowledge about precision and stuff to pick the right serialized representation, then you may want to provide separate instances for Int, Float, Double, etc.
22:03:38 <dsunshine> cdsmithus: The problem I'm having is that the listed set of results doesn't quite fit my needs, so I wondering how because I don't think I can coerce it into multiple types
22:04:13 <cdsmithus> dsunshine: You do need to pick only one type to coerce it to.  Is there no single type that's sufficient?
22:05:33 <dsunshine> cdsmithus: I'm was hoping to reteive the result as a String as well as something that indicates how the program exited and it doesn't seem to be there
22:06:43 <cdsmithus> dsunshine: Offhand, it looks like you want (String, ProcessStatus)
22:07:58 <dsunshine> cdsmithus: Where is that? I don't see it under the RunResult definition.
22:08:50 <cdsmithus> dsunshine: Oh, I was looking at an old version... just the forst one Google gave me.  Let me check a later version and make sure it's still there
22:09:19 <dsunshine> cdsmithus: Thanks
22:09:41 <cdsmithus> Okay, so it's now (String, ExitCode)
22:10:07 <cdsmithus> Or wait
22:10:22 <cdsmithus> Hmm... actually, that says it does something different
22:11:10 <cdsmithus> IO (String, IO (String, ExitCode)) would work... does require a second I/O action though
22:11:44 <dsunshine> Let me try that
22:12:14 <cdsmithus> The first string is the ouput.  The second String (available from the inner I/O action) is just a text error message
22:18:34 <markovdid> hello 
22:18:59 <markovdid> is there an existing library to turn csvs into a list
22:19:16 <ddarius> Yes (for a particular csv format)
22:19:24 <markovdid> ex: "2,3,4,5" -> [2,3,4,5]
22:19:45 <jmcarthur> you could just do an in-page search on hackage and find stuff
22:19:51 <jmcarthur> @hackage csv
22:19:52 <lambdabot> http://hackage.haskell.org/package/csv
22:19:53 <jmcarthur> for example
22:20:42 <markovdid> cool, checking now
22:26:05 <dsunshine> cdsmithus: How do I retreive the first String?
22:28:21 <Cale> dsunshine: In the result of the IO (String, IO (String, ExitCode))?
22:28:35 <dsunshine> Cale: YEs
22:28:55 <Cale> dsunshine: You run the action (inside a do-block), and pattern match on its result
22:29:19 <Cale> (s,x') <- x
22:29:29 <Cale> Where x :: IO (String, IO (String, ExitCode))
22:29:44 <Cale> and s then has type String, and x' has type IO (String, ExitCode)
22:30:28 <dsunshine> attempting..
22:32:15 <deech> Hi all, is it possible to do irrefutable pattern matching with a '@',eg. list@~(x:y:ys) ?
22:33:00 <ddarius> Sure
22:33:04 <ddarius> Use more parentheses.
22:33:12 <ddarius> That defines a @~ operator.
22:33:48 <deech> So something like list@(~(x:y:ys)) ?
22:33:53 <ddarius> Sure.
22:34:21 <deech> Cool!
22:34:25 <deech> Thanks!
22:35:41 <mee> is there a way to write f x y = 2 * (x+y) in point-free style? I thought it'd be (2*) . (+) but that tells me there is no instance of Num for (a->a) as though it were taking the function (+) as an argument rather than composing the two functions like I want.
22:36:07 <ddarius> Use @pl.
22:36:50 <kmc> @pl f x y = 2 * (x+y)
22:36:51 <lambdabot> f = ((2 *) .) . (+)
22:37:28 <kmc> some people have like (.:) = (.) . (.)
22:37:44 <mee> oh.
22:37:44 <kmc> :t (Prelude..) . (Prelude..)
22:37:45 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
22:37:56 <kmc> :t let (.:) = (Prelude..) . (Prelude..) in (2*) .: (+)
22:37:58 <lambdabot> forall a. (Num a) => a -> a -> a
22:38:14 <kmc> :t curry ((2*) . uncurry (+))
22:38:15 <lambdabot> forall a. (Num a) => a -> a -> a
22:38:51 <mee> oh I think I see
22:38:52 <mee> thanks.
22:40:19 <dsunshine> Cale: Thanks I got it working
22:41:40 <mee> that uncurry/curry way is damn ugly, but really makes it clear what my mistake was :)
22:49:16 <kmc> yeah it made me a little sad to type it
22:51:39 <ddarius> > showHex (ord ':') ""
22:51:40 <lambdabot>   "3a"
22:56:19 <ddarius> @gwiki foo
22:56:20 <lambdabot> No Result Found.
22:56:24 <ddarius> @wiki foo
22:56:25 <lambdabot> http://www.haskell.org/haskellwiki/foo
22:56:54 <ddarius> @gwiki Monad
22:56:55 <lambdabot> No Result Found.
22:56:59 <ddarius> @gwiki  Monad
22:57:00 <lambdabot> No Result Found.
23:00:35 <jre2> how do I resolve a duplicate symbol definition problem with ghci? (specifically process' waitForProcess)
23:01:27 <Cale> jre2: Either put things in different modules, or rename one of them?
23:09:20 <jre2> oh, nvm, the old version of process didn't get uninstalled when I "updated" it
23:12:46 <Causalien> @TagSoup Monad
23:12:46 <lambdabot> Unknown command, try @list
23:12:52 <Causalien> @list
23:12:53 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
23:15:29 <ddarius> @wikipedia foo
23:15:31 <lambdabot> http://wikimediafoundation.org/wiki/Special:Search?search=foo
23:20:02 <ddarius> > showHex (ord '+') ""
23:20:03 <lambdabot>   "2b"
