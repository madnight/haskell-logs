00:01:47 <ski> Heffalump : yeah, but i was thinking about cases where it (probably) can't be done until run-time
00:02:05 <ski> ksf : indeed
00:02:58 <ski> (Heffalump : also, some functions are not inlined, but we might still want to propagate demands through those to other functions)
00:06:37 <augur> anyone know where i might look for research into proofs of equivalence in axiom/inference-rule schemas?
00:08:16 <chrisdone> `mark' is the rank2Type to stop "marked values" from leaking outside of a db session
00:10:13 <chrisdone> the "runDB" type of functions are (Typeable a,MonadIO m,MonadState State m) => (forall mark. DBM mark Session a) -> m a
00:10:28 <ksf> this is all just _way_ too integrated.
00:10:43 <augur> ksf: quoi
00:10:51 <ksf> the whole cal toolchain.
00:11:14 <FunctorSalad> IO isn't a MonadPlus? :o
00:11:16 <ksf> heck with javac you can at least compile a single module without setting up workspaces and moon phases.
00:11:27 <FunctorSalad> or did I just forget to import something
00:11:37 <FunctorSalad> I was pretty sure it is one
00:11:59 <FunctorSalad> (mplus x y = x `catch` const y)
00:13:12 <FunctorSalad> hmm. works in ghci...
00:14:20 <chrisdone> FunctorSalad: did you import control.monad?
00:14:46 <FunctorSalad> chrisdone: yeah. and it works in ghci as opposed to cabal install
00:14:49 <augur> no? noone? :\
00:15:16 <chrisdone> FunctorSalad: ah, strange
00:15:29 <chrisdone> FunctorSalad: well in control.monad there's no IO instance for monadplus
00:15:41 <chrisdone> at least, documented
00:15:43 <chrisdone> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Control-Monad.html#t%3AMonadPlus
00:16:19 <chrisdone> maybe it comes from a mtl/transformers type of package
00:16:27 <FunctorSalad> I just thought that as well
00:16:46 <FunctorSalad> ah, must be my .ghci
00:16:51 <chrisdone> I'm guessing mzero = error?
00:17:05 <FunctorSalad> (since I'm not importing anything from mtl/transformers)
00:17:40 <FunctorSalad> *** Exception: user error (mzero)
00:18:46 <Jonno_FTW> I need ideas for my team name for a programming contest
00:19:13 <dolio> Slitherin.
00:19:30 <dolio> Or Voldemort.
00:19:37 <Jonno_FTW> It needs to be somewhat programming related
00:19:47 <chrisdone> surely in the harry potter them it should be quidditch
00:19:59 <chrisdone> codeitch
00:20:24 <Jonno_FTW> slightly functional programming related?
00:20:39 <chrisdone> qualifieditch
00:20:41 <FunctorSalad> chrisdone: "mtl" Control.Monad.Error is it...
00:20:50 <chrisdone> FunctorSalad: ohh
00:20:58 <FunctorSalad> (grep ftw)
00:21:37 <FunctorSalad> hmm might as well use 'catch' instead of adding a dep on mtl for that ;)
00:23:57 <FunctorSalad> should I send in my favourite orphan instances for inclusion in C.M.Error too? ;)
00:23:58 <Jonno_FTW> I still need a name
00:24:54 <Heffalump> we should get that into base
00:25:12 <chrisdone> I can't think of another instance other than throw io error
00:26:19 <chrisdone> for a monad transformer ontop of it, however...
00:26:49 <ski> when is `mplus' on `IO' useful ?
00:26:50 <FunctorSalad> chrisdone: for mzero you mean? mplus is catch . const
00:27:18 <ski> (as opposed to catching specific exceptions, and handling those)
00:27:23 <FunctorSalad> ski: cols = (read<$>system"tput cols")`mplus`return 80
00:27:24 <FunctorSalad> ;)
00:27:40 <chrisdone> that's nice
00:27:49 <FunctorSalad> (isn't the end of the world if I assume 80 columns)
00:27:59 <ski> FunctorSalad : what if the `system' call gives a permission error, or something ?
00:28:02 <FunctorSalad> so I don't really care what went wrong
00:28:18 <FunctorSalad> hmm ok, maybe printing the exception wouldn't be a bad idea
00:28:29 <ski> or if some other thread sends a kill ?
00:29:17 <FunctorSalad> actually I don't know if it is a catch on IOError or SomeException
00:29:19 <Heffalump> a monad transformer on top can ignore the underlying instance if it wnts
00:29:44 <FunctorSalad> but admittedly, catching SomeException carelessly isn't something I'd to in more important code
00:30:36 <FunctorSalad> ski: or out of memory... (is that even an exception?)
00:30:51 * ski doesn't recall
00:31:15 <chrisdone> true, some exceptions just shouldn't be catch
00:32:04 <FunctorSalad> the conscientous thing to do would be to rethrow anything you aren't sure to have handled
00:32:10 <FunctorSalad> (handled appropriately)
00:32:17 <younder> Hi all
00:32:18 <ski> (.. maybe chrisdone just caught an exception that shouldn't be caught, ending up invalidating the connection ?)
00:33:17 <ski> it would be interesting if something similar to Common Lisp's or MIT Scheme's condition system (with restarts) could be done in Haskell
00:33:22 <Axman6> it was a grammar exception
00:33:23 <younder> Just finished Chris Osaka's purely functional data structures. And in the process learned a bit if ML.
00:33:44 <ski> younder : nice :)
00:33:54 <ski> (s/Osaka/Okasaki/)
00:36:09 <younder> I do have a question. Is a trie a good way to implement a large dictionary?
00:36:24 <ski> "Condition Handling in the Lisp Language Family" <http://www.nhplace.com/kent/Papers/Condition-Handling-2001.html>, Kent Pitman, 2001
00:36:43 <ski> younder : possibly
00:37:43 <luite> younder: you might look into patricia tries
00:38:32 <ski> "Restarting conditions" (draft) <http://mumble.net/~campbell/proposals/restart.text>, Taylor Campbell
00:38:43 <ksf> younder, in general, yes.
00:39:17 <luite> younder: if your data set is static, you can also use minimal perfect hashing
00:39:45 <ksf> if in doubt, write yourself a dictionary module that just re-exports functions from Data.Map and forget about it until you actually have a performance problem.
00:41:50 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29627#a29627 << how can i fix types here?
00:42:07 <younder> luite, like Pascal..
00:42:26 <ksf> Mitar, by pasting the error alongside?
00:43:04 <ksf> that looks awfully imperative.
00:43:07 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29627#a29628
00:43:20 <Mitar> it is ;-)
00:43:37 <Mitar> it is an IO wrapper around pure code which will be in "live" function
00:43:41 <Axman6> younder: tries are good if you have a lot of list keys which have common prefixes i think
00:43:59 <ski> Mitar : is there a reason you provide default implementations for `grow',`dissolve',`live' ?
00:44:22 <ski> also, do `attach' need to be a class method ?
00:44:35 <ksf> ...and a and a1 don't match up because you're not bringing the a that you bind in the class head into attach's scope.
00:45:25 <ksf> looks like a thing better done with a graph library
00:45:53 <Mitar> ehm, probably there should not be a default for live, yes
00:45:53 <ski> Mitar : .. and i think the error occurs because it doesn't know which type `a' to use in `attach'
00:46:19 <ski> Mitar : `return undefined' looks next to worthless, to me, as well
00:46:55 <Mitar> it is for cases where there is no need to initialize/deinitialize, just run live
00:46:55 <ski> generally, defaults should give implementations of an operation in terms of other operations, that is to be interpreted as a law
00:47:41 <ski> so that instances may override the default if they have a more efficient implementation, but it should typically (afaiu) still give the same results as the default did
00:47:47 <Mitar> there is no need for attach to be a part of class, but i have it there so that it would be possible to fix types ;-)
00:48:33 <Mitar> in my case they override it if they have some special initialization/deinitialization
00:48:34 <ski> anyway, in `attach' it doesn't know *which* type `a' it should `grow', pass to `live', and then `dissolve'
00:48:52 <Mitar> it should be that of a class a
00:49:14 <ski> `a' can't be a class, since it doesn't start with an upper case letter
00:49:34 <Mitar> a from class defintion
00:49:37 <Mitar> Neuron a b
00:49:40 <ski> perhaps you meant it should be the `a' in `Neuron a b', i.e. the current instance ?
00:49:46 <Mitar> yes
00:49:54 <ski> maybe you even intend `b' to fully determine `a' ?
00:50:05 <Mitar> in fact a fully determine b
00:50:20 <Mitar> or, they are in both ways determined
00:50:25 <ski> or do you want to allow `instance Neuron A0 B' as well as `instance Neuron A1 B', for differing types `A0' and `A1' ?
00:51:07 <ski> hm, you're saying that `a' should determine `b', *and* `b' should determine `a', in `Neuron a b' ?
00:51:07 <Mitar> in theory, one neuron could send multiple types of impulses
00:51:22 <ksf> class Neuron a b | a -> b
00:51:25 <Mitar> but this will probably not work because neuron should be initialized only once
00:51:45 <ksf> ...says that each "a" may only be used with a specific "b".
00:51:46 <Mitar> so they are combined, a and b are connected to each other
00:51:57 <Mitar> so I add class Neuron a b | a -> b, b -> a ?
00:51:59 <ksf> the same b can be used with multiple a's, though.
00:52:15 <ski> Mitar : that would express that each of `a' and `b' determines the other, yes
00:52:40 <ski> Mitar : incidentally, the `b -> a' direction would remove the ambiguity in `attach' (which was why i brought FDs up)
00:53:08 <Mitar> hm, is , in between or something else?
00:53:20 <ski> sorry ?
00:53:46 <Mitar> uaaa
00:53:48 <Mitar> it works ;-)
00:53:58 <Mitar> (sorry, i made a typo when testing)
00:54:12 <ski> what do you mean by "hm, is , in between or something else?" ?
00:54:50 <Mitar> i meant if between a -> b and b -> a I should use comma or some other operator
00:54:57 <ski> `class Neuron a b | a -> b, b -> a' is parsed as `class Neuron a b | (a -> b), (b -> a)'
00:55:01 <ski> yes, a comma
00:55:05 <Mitar> yes, it works now
00:55:15 <ski> (semantically, the comma means conjunction)
00:55:17 <Mitar> it even gets rid of "The class method mentions none of the type variables of the class" error i was having
00:55:30 <ski> yeah ..
00:55:47 <ski> .. but you should only add an FD if the problem domain requires it ..
00:55:54 <ski> .. not just out of convenience
00:55:56 <Mitar> so this will now not allow me to define Neuron a b0 and Neuron a b1?
00:56:11 <ski> (the convenience being less ambiguity to resolve manually)
00:56:19 <ski> Mitar : correct
00:56:39 <Mitar> but what if those definitions are in different modules?
00:56:55 <Mitar> so just those which are used at the same time should not be in conflict?
00:56:58 <ski> `Neuron a b | a -> b, b -> a' means `(forall a. unique b. Neuron a b) /\ (forall b. unique a. Neuron a b)'
00:57:42 <ski> which means `(forall a b0 b1. (Neuron a b0,Neuron a b1) => b0 = b1) /\ (forall b a0 a1. (Neuron a0 b,Neuron a1 b) => a0 = a1)'
00:58:11 <ski> Mitar : it checks all the instances that are used together in a single program
00:58:20 <Mitar> ok
00:58:23 <Mitar> thanks ski
00:58:36 <ski> every module implicitly exports all the instances in it, as well as all the instances (implicitly) exported by modules it imports
00:58:49 <Mitar> i read about FD but didn't know that this is the case where I should use them
01:00:34 <ski> FDs can be used to reduce ambiguity .. and to allow class method type signatures to not mention all the class parameters .. but adding an FD should be semantically motivated, not *just* motivated out of a desire to avoid ambiguity or allow method signatures
01:00:36 <Mitar> that's a helpful channel
01:00:57 <Mitar> i understand, in my case it is semantically valid
01:01:17 <Mitar> each neuron can produce only one kind of impulses
01:01:28 <ski> (because if it isn't semantically motivated, then probably sooner or later some person will want to add an instance that makes sense in the problem domain, but which the FD forbids .. which is quite frustrating)
01:01:34 <wioux> i recall being told once that there is a convention as to the order of arguments to a function.. something like ascending generality? or is it descending?
01:01:34 <Mitar> and those impulses can be from only one kind of neuron
01:02:18 <ski> wioux : arguments which "vary less often" should be given earlier
01:02:27 <ksf> wioux, decreasing specialisation power.
01:02:31 <Mitar> i know only hope that i will be able to use different kind of inpulses over the same Chan
01:02:47 <Mitar> s/know/now/
01:02:52 <ski> wioux : e.g. in `map f xs', it is more common to call `map' with the same `f' but different `xs', than the other way around
01:03:09 <ksf> i.e. you would'nt pass the list to map first and then the function, as a [Foo] -> [Bar] method is useful on its own.
01:03:12 <Mitar> i have been told that using Dynamic is not a very nice way to do it
01:03:16 <wioux> ah.. thank you. the justification being that currying it thus easier?
01:03:19 <ski> > map (map (^2)) [[],[0],[1,2],[3,4,5],[6,7,8,9]]
01:03:19 <lambdabot>   [[],[0],[1,4],[9,16,25],[36,49,64,81]]
01:03:24 <ski> wioux : yes
01:03:28 <ski> or rather
01:03:31 <ski> partial application
01:03:37 <ski> @type curry
01:03:38 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
01:03:40 <wioux> right
01:03:48 <wioux> didn't mean Haskell's curry
01:03:58 <ski> currying is going from `(a0, a1, ...) -> b' into `a0 -> a1 -> ... -> b'
01:04:12 <ksf> currying as in curried function application
01:04:43 <ski> ksf : yeah, but you can only do that because `curry' itself is curried !
01:04:52 <ski> @type uncurry curry
01:04:53 <lambdabot> forall b b1 c. ((b, b1) -> c, b) -> b1 -> c
01:05:01 <ski> would be an alternative valid type for `curry'
01:05:23 <ski> er, not that's wrong
01:05:44 <ski> rather, it's a type signature of a (non-curried) partial application function
01:06:09 <ski> while `curry' can both be used as a currying function, as well as a (curried) partial application function
01:06:27 <ski> `curry f' translates an uncurried `f' to a curried version
01:06:50 <ski> `curry f x' partially applies an uncurried `f' to an early argument
01:07:05 <ksf> I won't argue that using "currying" is the technically correct term to pass a single argument to a curried function, but it's a darn convinient one.
01:07:22 <ski> `(uncurry curry) (f,x)' partially applies an uncurried `f' to an early argument -- but this time, in an uncurried fashion
01:08:58 <ski> (also, according to some, one ought to only call a function "curried" / curry a function, if the function does non-trivial work when applied to early argument(s))
01:09:31 <ski> (e.g. then `(++) :: [a] -> [a] -> [a]' ought to traverse the input list before waiting for the second argument)
01:10:47 <ksf> let foo = ("bar"++) in (foo "foo", foo "baz") should traverse "bar" only once.
01:11:00 <ksf> @src (++)
01:11:00 <lambdabot> []     ++ ys = ys
01:11:01 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
01:11:01 <lambdabot> -- OR
01:11:01 <lambdabot> xs ++ ys = foldr (:) ys xs
01:11:40 <ksf> hmmm. I sense a gap in my understanding.
01:11:44 <ski> using the above definitions, assuming naïve evaluation (no optimization tricks), `(++)' will wait for both arguments before doing anything
01:12:54 <ksf> well foo is lifted, doesn't that introduce the right kind of sharing?
01:14:04 <ski>   (++) = foldr ((.) . (:)) id  -- this, however, will be seriously curried
01:14:33 <ski> ksf : no
01:15:16 <ski> > foldr ((.) . (:)) id "abc" "xyz"
01:15:17 <lambdabot>   "abcxyz"
01:16:27 <ski> (you can probably figure the direct recursive version of that ..)
01:17:30 <ksf> @src foldr
01:17:30 <lambdabot> foldr f z []     = z
01:17:30 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
01:19:07 <ski>   foldr f z as = foldr ((.) . f) id as z  -- conjecture
01:19:48 <ksf> yeah it's transforming "abc" into \xs -> 'a':'b':'c':xs
01:19:48 <Mitar> hm, how can I define Nerve which would could accept different types of Impulses?
01:20:05 <ski> @check \f z as -> foldr f z (as :: [Int]) == (foldr ((.) . f) id as z :: Bool)
01:20:05 <lambdabot>   Overlapping instances for GHC.Show.Show
01:20:06 <lambdabot>                              (GHC.T...
01:20:09 <ski> bah !
01:20:33 <ski> ksf : right
01:20:42 <ksf> I still don't get why it would do it only once if the other ++ definitions would do it twice.
01:21:19 <ski>      let foo = ("bar"++) in (foo "foo", foo "baz")
01:21:41 <ski>   =  ("bar" ++ "foo", "bar" ++ "baz")
01:21:51 <ski>   =  ("barfoo", "barbaz")
01:22:06 <ksf> ("bar" ++) = \xs -> 'b':'a':'r':xs
01:22:21 <ksf> ...because foo is a binding on its own.
01:22:24 <ski> first `foo' is forced, but that doesn't do anything, because `(++)' is defined to not do anything before it can see two arguments
01:22:44 <ski> that's using the two definitions of `(++)' that lambdabot gave
01:22:46 <ski> using
01:22:51 <ski>   (++) = foldr ((.) . (:)) id
01:22:53 <ski> however
01:23:04 <ski>      let foo = ("bar"++) in (foo "foo", foo "baz")
01:23:20 <ski>   =  let foo = foldr ((.) . (:)) id "bar" in (foo "foo", foo "baz")
01:23:21 <ksf> ...and the second time round it's not using the evaluated thunk but a fresh, original one.
01:23:55 <ski>   =  let foo = ('b' :) . ('a' :) . ('r' :) . id in (foo "foo", foo "baz")
01:24:11 <ksf> ...the whnf differs.
01:24:20 <ski>   =  ((('b' :) . ('a' :) . ('r' :) . id) "foo", (('b' :) . ('a' :) . ('r' :) . id) "baz")
01:24:26 <ksf> which is what the stg matches on.
01:24:33 <ski>   =  ("barfoo", "barbaz")
01:25:25 <ski> here `(++)' was replaced by its definition (requiring even zero arguments), then `foo' continues to be forced, to whnf
01:26:12 <ski> actually, just forcing `foo' to whnf would not reduce it to `('b' :) . ('a' :) . ('r' :) . id', but rather to `('b' :) . foldr ((.) . (:)) id "ar'
01:26:48 <ski> but that doesn't matter much, since the two calls in the pair will apply, and thus force the rest (which is then *shared* with the other call in the pair)
01:27:12 <ski> ksf : yes
01:27:25 <ksf> that's not at all completely intuitive.
01:28:39 <ski> ('b' :) . foldr ((.) . (:)) id "ar"  (or rather  \x -> 'b' : foldr ((.) . (:)) id "ar" x  ) contains the thunk `foldr ((.) . (:)) id "ar"'
01:29:48 <ksf> why doesn't the prelude use your definition?
01:30:17 <ski> when this function is applied to e.g. `"foo"', that thunk will be fully forced (to  ('a' :) . ('r' :) . id  ), and since that thunk already existed before the application -- since it was present in the  \x -> 'b' : foldr ((.) . (:)) id "ar" x  function -- the forcing of that thunk will be remembered, so that the next call too `foo' doesn't need to force again
01:30:30 <ski> ksf : maybe GHC's Prelude does .. i don't know
01:30:36 <ksf> or is that what that magic rules pragma is there for?
01:30:46 <ksf> I'm looking at my local haddocks.
01:31:11 <ski> (another possibility could be that some optimization in GHC gives us the effect of the above, while still writing the more naïve code)
01:31:51 <ski> or maybe it could be that doing this even in cases where both arguments are given at the same time is wasteful
01:32:14 <ski> (i.e., that it would not always be a gain)
01:33:43 <ski> (well, whether `f . g' is in whnf or whether it reduces to `\x -> f (g x)' would depend on whether `(.)' is defined like `(f . g) x = f (g x)' or like `f . g = \x -> f (g x)' ..)
01:33:50 <ksf> Prelude Debug.Trace> let foo = (('b':'a':trace "hey" 'r':[]) ++) in (foo "foo", foo "baz")
01:33:50 <ksf> ("bahey
01:33:50 <ksf> rfoo","barbaz")
01:34:25 <ski> ksf : that's to be expected, in any case
01:34:36 <ksf> oh, yes.
01:34:49 <ski> your `"bar"' list is forced once, but maybe traversed twice
01:35:47 * ski doesn't really know how GHC handles this kind of thing ..
01:36:33 <ski> .. i was just reasoning in a simple naïve evaluation model which reads the definition equations "on the nose", and which has sharing (laziness)
01:36:57 <ksf> ...timing says it's traversed twice.
01:38:35 <ski> note that applying the function `("bar" ++)' will also take time proportional to the length of the list `"bar"'
01:39:25 <ski> however, in some cases, one can do some analysis of a data structure up-front, so that the subsequent work is not proportional to that initial work
01:40:16 <ski> (e.g. if the up-front work determines which path in a tree to traverse, then if the tree isn't used anywhere else, it could be GC:ed at this point, before applying the function to the rest of the arguments)
01:41:15 <ksf> well, your foldr starts to thrash for the same 10000000-element "bar"
01:41:28 <ksf> ...in the two calls case, that is.
01:41:43 <ski> did the other implementation also thrash ?
01:41:46 <ksf> nope
01:41:52 <ski> interesting
01:43:00 * ksf hopes jdh isn't listening
01:44:01 <ski> (i suppose the function representation might take some constant factor more memory .. but other than that, i don't see a possible reason .. maybe my argument above is flawed .. or maybe the observed results occur because of some optimizations or something GHC does)
01:44:32 <ksf> yep it works fine with a 0 less.
01:46:18 <ksf> that is, after the first result is printed, the second is almost instant
01:46:37 <ksf> (it still has to do length, after all)
01:47:34 <ski> "do length" ?
01:47:50 <ksf> ...I didn't feel like printing a gazillion elements.
01:48:04 <ski> ah,ok
01:48:31 <ksf> show is notoriously slow under ghci
02:11:04 * hackagebot chp-plus 1.3.1 - A set of high-level concurrency utilities built on Communicating Haskell Processes  http://hackage.haskell.org/package/chp-plus-1.3.1 (NeilBrown)
02:13:12 <vilhonen> is it possible to build a parser with parser combinators for this grammar? http://pastebin.com/z644KHwS
02:13:39 <fasta> vilhonen, you can parse anything with parser combinators, so, yes.
02:14:08 <vilhonen> how do I define the rule for anyline and separator
02:14:09 <fasta> vilhonen, assuming the grammar is semi-decidable to begin with. 
02:14:56 <vilhonen> matcher for anyline will also match the separator
02:15:07 <fasta> vilhonen, read the manual very carefully and lookup tryu. 
02:15:12 <fasta> vilhonen, try
02:15:25 <fasta> vilhonen, read RWH if it is not clear then yet. 
02:15:47 <vilhonen> I've been trying all kinds of combinations but can't figure out this
02:16:40 <vilhonen> I'm not sure that I can parse any kind of grammars with parser combinators
02:17:18 <fasta> vilhonen, you can easily write a parser that only accepts prime numbers. 
02:17:51 <fasta> vilhonen, since the parser can be computed based on the input, you can do arbitrary things. 
02:18:14 <fasta> vilhonen, you can even write a parser based on the amount of people currently in the IRC channel (that is, on I/O).
02:18:28 <vilhonen> example parser for my imaginary grammar would help to understand
02:18:43 <fasta> vilhonen, I think there are already enough examples out there.
02:19:08 <fasta> vilhonen, by the time you have read 10 Parsec parsers, you will know.
02:19:43 <fasta> I mean, you don't even have a single line of Haskell, nor a minimal problem.
02:20:24 <vilhonen> I've read that parsec can parse context-sensitive, infinite look-ahead grammars so I was just wondering if my grammar doesn't belong to that group
02:25:30 <bastl> Can anyone recommend a good "from-haskell-to-scala" guide ? I need an overview about pros and cons.
02:26:02 <ksf> bastl, there's also cal
02:26:23 <ksf> ...which is very, very close to haskell98
02:27:00 <bastl> it's not that I have a chocie, you know :-)
02:27:08 <bastl> *choice
02:27:51 <ksf> well, both, unlike haskell, run on the jvm so I assumed that's the area where you have no choice.
02:28:09 <wal> help
02:28:48 <wal> Sorry. Mis-typed
02:32:48 <Starfire> :t ($$)
02:32:49 <lambdabot> Doc -> Doc -> Doc
02:48:43 <sepp2k> > putStrLn "Ã¶Ã¤Ã¼"
02:48:44 <lambdabot>   <IO ()>
02:51:10 <sajkr> > 2 + 2
02:51:11 <lambdabot>   4
02:55:17 <bss03> > let 2 + 2 = 5 in 2 
02:55:18 <lambdabot>   2
02:55:19 <bss03> > let 2 + 2 = 5 in 2 + 2
02:55:20 <lambdabot>   5
02:55:40 <sajkr> n+k patterns?
02:56:25 <bss03> sajkr: I don't believe that's an n+k pattern.  I think that's just a local definition of (+) that is only defined for arguments "2" and "2".
02:56:33 <opqdonut> yes.
02:56:39 <bss03> > let 2 + 2 = 5 in 2 + 2 + 2
02:56:40 <lambdabot>   *Exception: <interactive>:1:161-169: Non-exhaustive patterns in function +
02:56:51 <opqdonut> > let subtracttwo (x + 2) = x in subtracttwo 5
02:56:52 <lambdabot>   3
02:56:55 <opqdonut> that's an n+k pattern
02:57:38 <sajkr> ah.
02:58:11 <fasta> Why do some compilers not support such trivial features, btw? Arguing about it takes longer than implementing it. 
02:59:09 <bss03> Trivial features?  I suppose it is tirival if you assume every (+) is (Prelude.+), but that's not cool.
03:01:39 <bss03> Plus, n+k patterns are ugly. :P
03:02:25 <fasta> bss03, are you sure the + depends on scope?
03:02:35 <fasta> bss03, I am pretty sure it does not.
03:04:07 <fasta> http://www.mail-archive.com/haskell@haskell.org/msg01272.html <- Wadler seems to support my assertion. 
03:04:25 <bss03> Oh, I'm pretty sure you are right.
03:04:49 <fasta> In 1993 they already had a ban the n+k patterns group. 
03:05:05 <fasta> Interesting how it then ends up in the 98 standard. 
03:05:36 <bss03> I think it got dropped from the 2010 standard.
03:21:37 <kowey> is there any reason to believe test-framework would be hard to install on Windows?
03:36:25 <Ke> is there some IO Maybe a monad that uses Maybe monad for flow control for multiple IO Maybe actions
03:38:15 <Ke> (>>=) ::a -> IO (Maybe a)
03:38:36 <Ke> etc
03:38:58 <opqdonut> @unmtl MaybeT IO
03:38:58 <lambdabot> err: `MaybeT IO' is not applied to enough arguments, giving `/\A. IO (Maybe A)'
03:39:01 <opqdonut> @unmtl MaybeT IO a
03:39:01 <lambdabot> IO (Maybe a)
03:39:19 <opqdonut> the MaybeT monad transform will maybe do what you want
03:40:02 <geheimdienst> > sequence [Just 42, Just 3]
03:40:03 <lambdabot>   Just [42,3]
03:40:14 <geheimdienst> > sequence [Just 42, Nothing]
03:40:15 <lambdabot>   Nothing
03:40:28 <geheimdienst> ^^ this might be part of the flow control that you mentioned
03:40:29 <Ke> hmm (>>=) actually takes 2 parameters
03:40:34 <Ke> ...
03:41:00 <FunctorSalad> "The null box, which has no content and no size. It is quite useless. " =)
03:43:44 <Ke> (>>=) :: IO (Maybe a) -> (a -> IO (Maybe a) ) -> IO (Maybe a)
03:44:03 <opqdonut> yes, that's >>= for (MaybeT IO a)
03:48:55 <geheimdienst> and what kinda unwashed vulgar pragmatist came up with the name "null box"?! in my book this is called a cratal nihiloid, as established by muller-bloomfuss et al. in the 1997 proceedings of conference on abstract nonsense
03:58:36 <Botje> haha :)
04:01:11 <FunctorSalad> artsy elitists using big words like 'null'. Let me give you a car analogy...
04:02:51 <FunctorSalad> ( I haven't actually thought of one, sorry )
04:03:50 <geheimdienst> well, first of all, think of a car. the car is a space suit in earth orbit
04:04:46 <koala_man> No contents, no size and quite useless? That would be a Skoda
04:05:25 <geheimdienst> only for a null box, there is no car in the spacesuit and there is no spacesuit around the car. which isn't there anyway. boom, you got a null box
04:05:43 <koala_man> it's all so much clearer now
04:07:17 <FunctorSalad> 'cratal nihiloid' sounds pretty awesome btw =)
04:30:47 <malorie> I'm having issues with an exercise from RWH. namely, how can I transform something like [1,2,3,4,5] into [[1,2,3],[2,3,4],[3,4,5]]?
04:31:44 <BONUS> > tails [1,2,3,4,5]
04:31:45 <lambdabot>   [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
04:32:29 <BONUS> now all you have to do is throw out those whose size is 2 or smaller and truncate the longer ones
04:32:46 <geheimdienst> malorie, in what RWH chapter is that?
04:33:03 <BONUS> > map (take 3) . filter ((>2) . length) $ tails [1,2,3,4,5]
04:33:04 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
04:33:06 <jpcooper> hello
04:33:14 <BONUS> hi
04:33:17 <malorie> geheimdienst: chapter 3 exercise 11
04:33:23 <jpcooper> does anyone know of a way to get the args as a single string?
04:33:35 <jpcooper> instead of their being split by spaces
04:34:04 <malorie> BONUS: I see what you mean.
04:34:18 <jpcooper> in fact I will be reading a single argument which may have spaces in it
04:35:26 <malorie> jcapper: by using '"'?
04:35:34 <malorie> jpcooper: ^
04:35:40 <jpcooper> malorie, command line arguments
04:35:46 <geheimdienst> jpcooper, the shell splits the arguments and gives them to your program as an array. if you don't want that, you can run your program with Â«echo "this that"Â»
04:36:07 <writer> jpcooper: C RTL splits the command-line into array
04:36:13 <geheimdienst> (granted, echo is a silly example, but you get the idea)
04:36:20 <jpcooper> oh, thank you
04:38:04 <jpcooper> also is there a reason why, while ghc --make is running, a module in the same directory as the one being made, should not be seen?
04:38:45 <jpcooper> yes: typo
04:44:30 <malorie> BONUS: this is what I came up with: http://codepad.org/LzvH0cGF
04:45:06 <BONUS> that's pretty cool too
04:45:43 <malorie> :)
04:47:18 <Saizan> except that length xs is O(n), so it's not a good habit to use it so liberally :)
04:48:58 <geheimdienst> ... code first, ask the profiler later ...
04:53:34 <BONUS> i kinda wish the prelude had a lengthLessThan function
04:54:03 <zachk> Ambiguous module name `Control.Monad.Writer':
04:54:03 <zachk>       it was found in multiple packages: mtl-1.1.0.2 monads-fd-0.1.0.1
04:54:09 <zachk> how do i get around that
04:54:15 <daimrod> malorie: you could also make your own function to do this (ex11 :: (Enum a) => [a] -> [[a]]) with succ.
04:55:14 <BONUS> zachk: im not sure but i think maybe you can do ghc-pkg unregister monads-fd
04:56:26 <geheimdienst> yeah, do as bonus says or use "cabal init" in your project. it asks you a few simple questions and from then on, you can use "cabal build" to build your program. you might want to have that in the long run anyway
04:58:08 <fryguybob> There is also ghci -hide-package if you are just trying to test something short term.
04:59:10 <zachk> k got it to work 
04:59:13 <zachk> thank you 
04:59:47 <geheimdienst> i swear, the rationale for the monads-fd package has gotta be to expose more people to weird "Ambiguous module name" compiler errors
05:00:24 <BONUS> what is it supposed to improve over mtl anyway
05:01:27 <auser> Hello! length $ group $ [1..10] ++ [1..10] is returning 20 but I believe it should be 10.  What's wrong with my group & groupBy functions?  Am I doing something wrong?
05:01:49 <geheimdienst> well mtl can be used without knowledge of ghc-pkg unregister. monads-fd cannot. that's an improvement, right?
05:01:56 <BONUS> > group $ [1..10] ++ [1..10]
05:01:57 <lambdabot>   [[1],[2],[3],[4],[5],[6],[7],[8],[9],[10],[1],[2],[3],[4],[5],[6],[7],[8],[...
05:01:59 <hpc> > length . group $ [1..10] ++ [1..10]
05:02:00 <lambdabot>   20
05:02:10 <auser> how do I group?
05:02:12 <BONUS> you probably want them sorted first
05:02:18 <fryguybob> > group [1,1,2,2,3,3]
05:02:19 <lambdabot>   [[1,1],[2,2],[3,3]]
05:02:20 <BONUS> group only groups adjecent ones
05:02:29 <BONUS> > group [1,1,2,2,1,1]
05:02:29 <lambdabot>   [[1,1],[2,2],[1,1]]
05:02:35 <auser> Oh thanks
05:02:46 <BONUS> > length . group . sort $ [1..10] ++ [1..10]
05:02:46 <lambdabot>   10
05:03:03 <auser> group :: (Eq a) => [a] -> [[a]]
05:03:09 <auser> sneaky - no mention of Ord
05:03:13 <geheimdienst> (similar to the command-line tool "uniq". you generally have to sort stuff before you pass it to uniq, too)
05:03:53 <auser> Is group that only works on sorted data really useful?
05:04:01 <hpc> yes
05:04:05 <hpc> it works on infinite lists
05:04:30 <BONUS> for instance
05:04:47 <BONUS> > groupBy ((==) `on` isSpace) "wah wah woo wah"
05:04:48 <lambdabot>   ["wah"," ","wah"," ","woo"," ","wah"]
05:05:20 <auser> Interesting thanks.
05:08:36 <jpcooper> what is the easiest way to write millions of lines to disk without taking up too much RAM?
05:10:46 <hpc> a buffered file handle, perhaps?
05:11:13 <jpcooper> right
05:11:14 <hpc> it's not as easy as appendFile, but it will go quicker, i think
05:11:29 <jpcooper> I'll look into this
05:11:43 <geheimdienst> why would you want it buffered? that will only burn ram
05:12:02 <hpc> not much RAM though
05:12:10 <hpc> and it saves on disk writes
05:12:14 * hackagebot data-object-yaml 0.3.1.1 - Serialize data to and from Yaml files  http://hackage.haskell.org/package/data-object-yaml-0.3.1.1 (MichaelSnoyman)
05:12:16 <jpcooper> well actually I don't mind using lots of RAM. I just don't want things going out of control
05:12:28 <jpcooper> I'd like the quickest way to write these millions of lines onto disk
05:12:46 <frerich> BONUS: Hmm, interesting wish (the lengthLessTham). I wonder: would ghc optimize an expression like 'length l < 5' so that 'length' doesn't continue running if it found found five items?
05:12:53 <geheimdienst> i'd just do the simplest thing (lots of appendFile all over the place) and see how it goes. optimize as necessary
05:13:08 <jpcooper>  @hoogle appendfile
05:13:10 <hpc> appendFile reopens every time
05:13:20 <hpc> it's in prelude
05:13:24 <hpc> @src appendFile
05:13:24 <lambdabot> appendFile f txt = withFile f AppendMode (\ hdl -> hPutStr hdl txt)
05:13:27 <BONUS> frerich: that's an interesting question. so far i don't think it optimizes that, but i wonder if doing such an optimization would be cool
05:13:35 <hpc> it's going to be hellishly slow
05:14:16 <hpc> oh wow, really hellishly slow; it writes the whole file every time
05:14:50 <jpcooper> and from there I want to go to billions of lines
05:15:01 <frerich> BONUS: I think it would be quite impressive! I'm a total newbie at Haskell, but I've seen some amazing optimizations already (which were possible because of the nature of functional languages). So maybe the compiler could see that in this case 'length' is used in an expression which doesn't care about values > 5.
05:15:11 <frerich> I'm impressed enough to assume that anything is possible :)
05:15:34 <Twey> (flip withFile AppendMode .) . flip hPutStr
05:15:44 * Twey now compulsively point-frees thingsâ€¦
05:15:55 <BONUS> yeah i mean such an optimization would certainly be possible, but the question is do you really want it? since it kind of not only optimizes your program but changes its meaning
05:16:02 <Twey> It actually happens
05:16:14 <Twey> If you use a lazy number type (e.g. Natural) you get that behaviour.
05:16:19 <BONUS> like without optimization length [1..] < 5 would not terminate, but with the optimization it would
05:16:32 <hpc> haha, twey
05:16:34 <Twey> It only checks the whole list because the number type you're using is strict
05:16:42 <frerich> BONUS: It should be okay, given that 'length' has no side effects
05:16:49 <Twey> Lazy numbers are considerably slower, though
05:17:19 <Twey> BONUS: In my book, so long as the only difference is to cause non-terminating pure programs to terminate successfully, there's no problem.
05:17:28 <Twey> The only things that change are things that would have been broken anyway.
05:17:38 <frerich> Twey: I think having a 'lazy number type' is nice for values which are only known at runtime, but in this example, the constant is known at build time, so maybe a compiler optimization could kick in.
05:18:01 <Twey> frerich: Supercompilation will do this if/when it hits the mainstream
05:18:16 <Twey> (wellâ€¦ Haskell mainstream :Ã¾)
05:18:46 <JHoglund> Why can I not have "Int -> Int -> Bool" as a type signature to "comparePower1 n k = power n k == power2 n k"?
05:18:59 <hpc> :t power
05:19:00 <lambdabot> Not in scope: `power'
05:19:03 <Twey> frerich: Follow it here: http://hackage.haskell.org/trac/ghc/wiki/Supercompilation
05:19:13 <hpc> JHoglund: what are the types of power and power2?
05:19:27 <frerich> Twey: Thanks for the pointer! That's the first time I heard about 'Supercompilation'. :-)
05:19:36 <JHoglund> hpc: power is a misspelling of power2, not existing in my scope :)
05:19:44 <Twey> JHoglund: You can with appropriately-typed â€˜powerâ€™ and â€˜power2â€™ (Eq n => Int -> Int -> n for both)
05:19:49 <JHoglund> hpc: I fixed it now and it works :)
05:19:54 <hpc> :D
05:20:29 <JHoglund> hpc: One could have expected that the compiler would complain about an undefined function, rather than the type signatures...
05:20:33 <JHoglund> Thanks anyway :)
05:21:22 <Twey> JHoglund: It will, if you try to compile something using â€˜powerâ€™
05:21:53 <hpc> Twey: he did
05:21:57 <Twey> It won't be able to deduce the type for the function, since it doesn't know the type of â€˜powerâ€™
05:22:04 <hpc> oh
05:22:12 <Twey> hpc: They *say* they did.  That's not quite the same thing.  :Ã¾
05:22:48 <hpc> what is that character?
05:22:56 <hpc> it looks sorta like phi
05:23:06 <geheimdienst> a thorn, dude
05:23:10 <JHoglund> I've read that syntactic sugar as guards and if-then-else is "bad practice" and that the function if' should be used instead, however, I've only managed to find documentation, which I can't understand, but no clear examples. Would you agree that if' is a better way than guards, generally?
05:23:11 <geheimdienst> iirc
05:23:15 <theorbtwo> Thorn, pronounced "th".
05:23:42 <Twey> As in â€˜thingâ€™, not as in â€˜thatâ€™
05:23:43 <hpc> i prefer guards
05:23:49 <hpc> if' is sugar for if-then-else
05:24:08 <BONUS> no, guards are often much more readable than if-then-esle
05:24:11 <JHoglund> Oh, I've understood it as if-then-else is sugar?
05:24:11 <Twey> It looks nothing like phi (Ï†, Î¦)
05:24:12 <BONUS> also i wouldnt use if'
05:24:28 <hpc> it does in my font
05:24:32 <Twey> (y ?? n) p = if p then y else n
05:24:35 <Twey> hpc: Crazy font
05:24:56 <hpc> well, it looks like half of a capital phi
05:24:57 <geheimdienst> twey, delete the phi's left arm and make the middle stem a little higher
05:25:00 <theorbtwo> It should look like a p and a b.
05:25:21 <Twey> geheimdienst: And if you delete the whole stem, you get an â€˜oâ€™ :Ã¾
05:25:48 <JHoglund> http://www.haskell.org/haskellwiki/Syntactic_sugar/Cons <-- At that page, if-then-else is labeled as syntactic sugar and the author recommends guards to be dropped in the future
05:26:39 <BONUS> thing is
05:27:06 <BONUS> f (x:xs) = ...; f [] ) ... is also syntactic sugar for f x = case c of (x:xs) -> ...; [] -> ...
05:27:22 <hpc> also, guards allow fall-through
05:27:40 <hpc> so you can have f x | length x > 5 = x; f _ = []
05:27:41 <BONUS> yeah, so i wouldn't really trust that page
05:27:51 <BONUS> it seems *very* opinionated
05:27:51 <JHoglund> BONUS: x:xs means "x in a list of x'es"?
05:27:51 <geheimdienst> jhoglund, i wouldn't take that page too seriously. the opinions there are a little far out
05:28:05 <hpc> JHoglund: (x:xs) means a list that starts with x
05:28:09 <hpc> and the rest of the list is xs
05:28:19 <BONUS> JHoglund: nah, it means: call the first element x and the rest of the list xs
05:28:20 <JHoglund> Ah, ok
05:28:36 <hpc> to get technical, (:) is the list constructor
05:28:36 <BONUS> let x:xs = [1,2,3,4,5] in (x,xs)
05:28:40 <BONUS> > let x:xs = [1,2,3,4,5] in (x,xs)
05:28:41 <lambdabot>   (1,[2,3,4,5])
05:28:51 <hpc> data [] a = [] | a : [a]
05:28:55 <JHoglund> hpc: By the way, the misspelled power function wasn't the one causing my troubles, I'll drop a few lines in a pastebin and hope you could have a quick look :)
05:29:46 <JHoglund> http://pastebin.com/TypuAgce <-- Why is the type signature of the comparePower1 functio invalid?
05:30:24 <hpc> also, BONUS: your new chapter on monads is exactly how i would have taught it; i think i will be linking to it frequently
05:30:35 <BONUS> cool :D
05:30:58 <geheimdienst> when can we expect a chapter on "writing your own monad tutorial"?
05:31:07 <hpc> JHoglund: compare types
05:31:15 <hpc> comparePower1 n k = power1 n k == power2 n k
05:31:22 <co_dh> :t on
05:31:22 <hpc> power1 :: Int -> Int -> Int
05:31:22 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:31:26 <Martty> you accidentally put the parameters in the type signature JHoglund 
05:31:27 <hpc> so n and k are both Int
05:31:43 <JHoglund> Ahh!
05:31:46 <hpc> oh wow, didn't see that
05:31:47 <JHoglund> There it was!
05:32:36 <Martty> if you are getting an invalid type signature, where types arent matching, you can just remove it altogether, let ghci infer it and check it manually with :t if possible
05:32:40 <JHoglund> Do you guys think it would be possible to improve the compiler messages more?
05:33:08 <JHoglund> Martty: I did, I removed the types and did a :print on the function, ghci replied with the same types as I had
05:33:16 <hpc> i think they get a bit long, but the messages themselves are fine
05:33:30 <JHoglund> Martty: My mistake was that I had included the input parameters (are they called that) in the type signature :)
05:34:20 <itsmonktastic> JHoglund: are you using ghc or hugs?
05:34:32 <itsmonktastic> I tend to find ghc's error messages are more useful
05:34:55 <JHoglund> itsmonktastic: ghci, I'm reloading my .hs file with :r
05:34:59 <hpc> i think they get a bit long, but the messages themselves are fine
05:35:15 <hpc> (not sure if you got that before i dc'd)
05:35:23 <JHoglund> hpc: Well, I included the paramters in the type signature and it didn't complain...?
05:35:38 <hpc> heh
05:37:22 <mreh> I asked this yesterday, but I lost it in my scrollback: how does one get real values to be displayed in decimal rather than standard form
05:38:11 <mreh> > inits "hello"
05:38:12 <lambdabot>   ["","h","he","hel","hell","hello"]
05:38:21 <mreh> > init "hello"
05:38:22 <hpc> standard meaning scientific notation?
05:38:22 <lambdabot>   "hell"
05:38:34 <mreh> hpc: yeah, 0.012 not 12e-3
05:38:57 <fasta> It is official: even Debian has removed hat .
05:39:18 <hpc> i think you will have to roll your own
05:39:20 <fasta> I always like it when people fix bugs by simply dropping the feature. 
05:39:34 <hpc> fasta: what is that feature?
05:39:51 <mreh> "hat"?
05:39:58 <fasta> hpc, the feature being providing application named X, with X=hat in this case.
05:40:17 <fasta> They can fix all bugs by simply stopping distribution. 
05:40:58 <nooodl> is there a way to call a function with the contents of a list/tuple in haskell? (in python, it's "foo(*bar)")
05:41:06 <geheimdienst> except maybe if the application as a whole is a bug ...
05:41:29 <hpc> > let list = [1..] in head list
05:41:30 <lambdabot>   1
05:41:44 <hpc> > let tuple = (1,2) in fst tuple
05:41:45 <lambdabot>   1
05:41:46 <mreh> :t printf
05:41:47 <lambdabot> forall r. (PrintfType r) => String -> r
05:42:07 <hpc> nooodl: ^
05:42:08 <nooodl> no, i mean, let a tuple/list be the arguments of a function
05:42:15 <hpc> :t uncurry
05:42:15 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
05:42:34 <hpc> uncurry is the only one i know of
05:42:40 <mreh> > uncurry (+) (1,2)
05:42:41 <lambdabot>   3
05:42:46 <nooodl> that's what i need :)
05:43:16 <Martty> theres no list uncurry!?
05:43:50 <hpc> there could be, if you feel like making a variadic function class for it
05:44:24 * Martty pass
05:47:15 <mreh> > printf "%.10d" 0.12 :: String
05:47:16 <lambdabot>   "*Exception: Printf.printf: bad argument
05:47:19 <mreh> wat
05:48:27 <hpc> > printf "%.9d" 0.12
05:48:27 <lambdabot>   Ambiguous type variable `a' in the constraints:
05:48:28 <lambdabot>    `Text.Printf.PrintfType ...
05:48:36 <mreh> oh, argument and type mismatch
05:48:41 <mreh> > printf "%.10f" 0.12 :: String
05:48:42 <lambdabot>   "0.1200000000"
05:48:51 <mreh> > printf "%.10f" 0.00000012 :: String
05:48:52 <lambdabot>   "0.0000001200"
05:49:22 <mreh> that's what I would call decimal, not floating point
05:49:41 <mreh> > printf "%.10e" 0.00000012 :: String
05:49:42 <lambdabot>   "1.2000000000e-7"
05:50:04 <syntaxfree> I'm getting spanked by the type system, for a change.
05:50:07 <syntaxfree> data MagMat a = (Num a) => Array (Int, Int) a
05:50:27 <syntaxfree> why does that have existential type variables, and how do I make that a plain type?
05:50:51 <hpc> i think the syntax is data (Num a) => MagMat a = ...
05:50:59 <hpc> maybe
05:51:55 <syntaxfree> oh. cool.
05:52:35 <hpc> it worked?
05:52:56 <hpc> i mean, i knew it all along :P
05:53:47 <syntaxfree> that's still weird though, because I'm overloading Data.Array.Array with Main.Array
05:54:00 <mreh> I wish I could run ghci on compiled modules
05:54:01 <syntaxfree> but it checks somehow. 
05:54:38 <hpc> it could be that Data.Array doesn't export a /constructor/ by the name of "Array"
05:54:41 <hpc> only a type
05:55:11 <hpc> mreh: you can, if you have the .hi and .o files
05:55:45 <mreh> hpc: is that the difference between the asterisk after the module name and not in the ghci prompt?
05:55:49 <hpc> yes
05:55:50 <syntaxfree> anyway, I should fix that for clarity & giggles.
05:56:21 <Saizan> syntaxfree: that wasn't really an existential type, but a typeclass context on a constructor is not haskell98 and they didn't feel like making up a special extension for it i guess :)
05:56:24 <hpc> also, it will compile modules to bytecode if it's interpreted, otherwise it straight-up loads them
05:56:41 <hpc> so you shouldn't see lots of [Compiling Foo ...] lines
05:57:12 <Saizan> btw, "data Num a => MagMat a = .." is only going to cause trouble, drop the Num a =>
05:57:17 <mreh> hpc is this all in the manual?
05:57:43 <syntaxfree> Saizan: yeah, I just realized I need the class constraint in every type declaration.
05:57:47 <hpc> not sure, but i just tried it myself and it works as i described
05:58:40 <mreh> I'm not sure how to compile without linking
05:58:52 <lantti> In my opinion the type constraint syntax is not the most friendly in haskell anyway.
05:59:27 <syntaxfree> well, type constraints are Haskell's analog to method inheritance.
05:59:31 <lantti> The whole type signature stuff is getting really crowded sometimes.
05:59:47 <hpc> mreh: try ghc $file.hs
06:00:09 <hpc> it whines about not finding main, but the intermediate files still get created
06:01:09 <syntaxfree> @type array
06:01:10 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
06:01:20 <syntaxfree> er,
06:01:25 <hpc> @instances Ix
06:01:26 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
06:01:37 <hpc> @instances-importing Data.Array Ix
06:01:37 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
06:01:39 <syntaxfree> what's wrong with this:?
06:01:40 <syntaxfree> testmat :: Array (Int, Int) Floating
06:01:53 <Saizan> Floating is not a type
06:01:57 <syntaxfree> I'm giving MagMat a pause while I get arrays straight.
06:01:59 <syntaxfree> OH.
06:02:20 <syntaxfree> @instances Floating
06:02:21 <lambdabot> Double, Float
06:02:40 <syntaxfree> testmat :: Array (Int, Int) Float -- is stil bust
06:03:10 <syntaxfree> and just writing out the definition of testmat b0rks type inference
06:03:36 <syntaxfree> Ambiguous type variables and the usual story of when type inference fails.
06:04:32 <quicksilver> > let testmat :: Array (Int,Int) Float; testmat = listArray ((0,0),(1,1)) [0.0,1.0,2.0,3.0] in testmat
06:04:33 <lambdabot>   array ((0,0),(1,1)) [((0,0),0.0),((0,1),1.0),((1,0),2.0),((1,1),3.0)]
06:04:38 <quicksilver> syntaxfree: ^^
06:04:57 <jpcooper> in BlockBuffering, how many bites corresponds to 1?
06:05:00 <jpcooper> bytes*
06:05:08 <syntaxfree> I must be doing something invisible and wrong.
06:05:17 <quicksilver> I disagree with "type constraints are Haskell's analog to method inheritance" btw.
06:05:54 <quicksilver> I don't think haskell has anything analogous to method inheritance as a basic language structure, although you can imagine all kinds of ways of encoding it.
06:06:11 <syntaxfree> quicksilver that's not really a thoroughly thought out idea. shoot away, I'll likely learn something.
06:06:24 <syntaxfree> oh. yes.
06:06:40 <syntaxfree> it might be a strange artefact or my own programming education.
06:06:43 <quicksilver> I don't have time for my rant on typeclasses today ;)
06:06:46 <syntaxfree> see, I actually got started with Haskell.
06:07:08 <quicksilver> quicksilver's first rule says "If you think you want to define a new typeclass, you don't. Think again"
06:07:24 <syntaxfree> Back in 2007. I even had a pedantic blog slamming Python and going for rabid defenses of smart typing.
06:07:27 <Saizan> "testmat = listArray ((0,0),(1,1)) [0.0,1.0,2.0,3.0]" would get an inferred type like "(Floating a, Ix i, Num i) => Array (i,i) a" but the monomorphism restriction prevents that.
06:07:47 <quicksilver> quicksilver's second rule is "typeclasses are for overloading, they are not a general abstraction"
06:07:50 <fasta> Smart typing? Wow, a technical term I haven't heard about. 
06:07:57 <quicksilver> that's as much as I have time for today.
06:08:13 <syntaxfree> Then I mostly stopped programming, and back in 2009 when I needed some programming done that exceeded Stata/Mata abstraction capabilities, I went with Python, which is quite forgiving.
06:08:20 <hpc> anonymous typeclasses would be a funny way to do duck typing though
06:08:44 <syntaxfree> smart typing = made-up term for type inference but not duck typing.
06:08:57 <fasta> syntaxfree, do not make up terms 
06:09:24 * ezyang could sort of see smart typing catching on as a term 
06:09:29 <syntaxfree> duck typing is annoying. It infers any "naked" number to be an integer, so you'll end up with numeric bugs because 4/3 =1 
06:10:06 <syntaxfree> so code ends up laced with .0 everywhere, because you never know where you're gonna need it. 4.0/3.0 and so on.
06:10:13 <syntaxfree> my code anyway.
06:10:23 <hpc> syntaxfree: that's implementation more than an ideological problem; interpreting integers as floats would be the better approach
06:11:00 <itsmonktastic> I don't think 4/3 = 1 is duck typing
06:11:11 <hpc> > 4/3 == 1
06:11:11 <lambdabot>   False
06:11:15 <syntaxfree> hpc: I know. But it's never clear how the general case would work. It's on a case-by-case basis. And it doesn't look like Python is going to bulge from that problem any sooner. Thus Matlab retains dominance.
06:11:15 <itsmonktastic> more that 4 and 3 aren't denotations for concrete types
06:11:16 <Starfire> I think Haskell has the best approach to numeric literals that I have seen.
06:11:19 <hpc> > 4/3 == 2
06:11:20 <lambdabot>   False
06:11:40 <itsmonktastic> for values of concrete types*
06:11:42 <fasta> Starfire, Qi does it in a better way. 
06:12:00 <fasta> Starfire, in Haskell it is all hard-coded into the compiler. 
06:12:06 <Starfire> fasta: I'm not familiar with Qi, could you paste an example link?
06:12:22 <fasta> Starfire, links are so 1990s. Google and learn.
06:12:55 <syntaxfree> anyway, I  got used to Python for throwaway prototyping (that's all I do anyway) and got used to thinking of (Python-type OO) class inheritance as type class constraints in new data types.
06:14:03 <syntaxfree> (nb: I do realize OO classes just share the word "class" with type classes)
06:15:33 <syntaxfree> "Lacks an accompanying binding" should just means there's no function definition to match the explicit type declaration. Or am I radio gaga on this whole Array thing?
06:16:02 <Saizan> the former
06:16:42 <syntaxfree> man, all the pastebins I knew are dead.
06:16:47 <syntaxfree> pastebin.net, rfb.net/paste. 
06:16:53 <syntaxfree> @paste
06:16:54 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
06:17:00 * osfameron is mostly using github's gists these days
06:17:01 <Saizan> pastebin.com
06:17:25 <hpc>  @paste needs to be updated
06:17:55 <syntaxfree> http://pastebin.com/mEzpRciW
06:18:02 <syntaxfree> that's the full code. 
06:18:10 <Saizan> oh, hpaste.org is working
06:18:23 <Saizan> syntaxfree: typo
06:18:29 <Saizan> tesmat /= testmat
06:19:00 <Saizan> also s/log(x)/log x/ to be more haskelly :P
06:19:06 <syntaxfree> now I get a type error on line 14 (the definition of testmat
06:19:32 <syntaxfree> ah, yes. To quote Weezer, "I gotta get back to the good life"
06:19:39 <Saizan> ?type array
06:19:40 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
06:19:49 <Saizan> i has to be Int
06:19:57 <Saizan> but then you can't call log on it.
06:20:04 <Saizan> ?type listArray
06:20:05 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
06:20:10 <Saizan> i'd use that ^^^
06:20:34 <syntaxfree> yeah, I'm discovering that just now.
06:20:38 <Saizan> > listArray (1,10) [ log x | x<-[1..10]]
06:20:39 <lambdabot>   array (1,10) [(1,0.0),(2,0.6931471805599453),(3,1.0986122886681098),(4,1.38...
06:21:22 <syntaxfree> oh cool. what's the quickest way to get an N by N array from an Integer->Integer->Float function anyway?
06:22:22 <hpc> you mean you want f :: (Integer->Integer->Float) -> Integer -> Integer -> [[Float]]?
06:22:33 <Saizan> array /= list
06:22:51 <syntaxfree> (I just tried your version and get "No instance for (Num (Int,Int)) arising from literal 1)
06:23:03 <syntaxfree> I mean array.
06:23:46 <Saizan> syntaxfree: yeah, well, was it supposed to be a 2-dimensional or 1-dimensional array? the type says 2 and the code seems to imply 1
06:23:53 <syntaxfree> row boundary -> colum boundary -> function of Integer x Integer -> Array
06:25:01 <syntaxfree> define array size up front.
06:25:25 <Saizan> ?type \f m n -> listArray ((0,m),(0,n)) [ f x y | (x,y) <- range ((0,m),(0,n)) ]
06:25:26 <lambdabot> forall t t1 t2 e. (Num t, Num t2, Ix t2, Ix t1, Ix t) => (t2 -> t1 -> e) -> t1 -> t1 -> Array (t, t1) e
06:26:02 <Saizan> ?type \f m n -> listArray ((0,m),(0,n)) [ f x y | (x,y) <- range ((0,m),(0,n)) ] :: (Integer -> Integer -> Float) -> Integer -> Integer -> Array (Integer,Integer) Float
06:26:03 <lambdabot>     Couldn't match expected type `(Integer -> Integer -> Float)
06:26:03 <lambdabot>                                   -> Integer
06:26:03 <lambdabot>                                   -> Integer
06:26:22 <Saizan> ?type (\f m n -> listArray ((0,m),(0,n)) [ f x y | (x,y) <- range ((0,m),(0,n)) ]) :: (Integer -> Integer -> Float) -> Integer -> Integer -> Array (Integer,Integer) Float
06:26:23 <lambdabot> (Integer -> Integer -> Float) -> Integer -> Integer -> Array (Integer, Integer) Float
06:26:58 <syntaxfree> Oh. Indices include a start and an end because they can be any Enum so there's no natural "floor" or whatever they were called in some class epsilon-stronger than Enum.
06:27:30 <quicksilver> @type \f minx miny maxx maxy -> listArray ((minx,miny),(maxx,maxy)) $ map (\(x,y) -> (f x y)) (range ((minx,miny),(maxx,maxy)))
06:27:30 <lambdabot> forall e t t1. (Ix t, Ix t1) => (t -> t1 -> e) -> t -> t1 -> t -> t1 -> Array (t, t1) e
06:27:40 <quicksilver> well that's pretty much what Saizan is doing too.
06:27:56 <quicksilver> take your pick on the details
06:29:07 <syntaxfree> fmat a :: (Integer -> Integer -> a) -> Integer -> Integer -> Array (Integer,Integer) a  fails to check. I just replaced Float for a type variable.
06:29:36 <Saizan> mh, mine is wrong.
06:29:51 <syntaxfree> there are no hints. "Invalid type signature". I hate those.
06:29:51 <Saizan> it should've been ((0,0),(m,n))
06:30:27 <Saizan> syntaxfree: remove the 'a' on the left of fmat
06:30:38 <Saizan> err, on the left of ::
06:32:19 <syntaxfree> :t uncurry f(x,y)
06:32:20 <lambdabot> forall c. (SimpleReflect.FromExpr c) => c
06:32:51 <syntaxfree> heh. cool answer. not going for cute tricks while I don't get a prototype going, though.
06:33:24 <otto_s> :t uncurry
06:33:25 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:33:47 <syntaxfree> yeah, I think I actually want to curry f, not to uncurry the parameters. But laisse tomber.
06:38:20 <tommd> No, all Johns new packages are a result of the new Text version BOS released.  John is updating his packages to use the newest text.
06:41:05 <Axman6> zomg, i managed to implement inplace heapsort for STArrays first try :D
06:41:13 <Axman6> no testing, just worked first time
06:41:44 <Axman6> now need to get it working for unboxed arrays too
06:42:08 <syntaxfree> cool. this works. fmat f m n = listArray ((0,0),(m,n)) $ map (uncurry f) (range ((0,0), (m,n)))
06:43:17 <syntaxfree> thanks everyone. I think my coding time's up. Real, boring work to do.
06:47:53 <Mitar> I read somewhere that i should not use "fail"? or i mixed something?
06:48:04 <Nibble> Mitar: fail.
06:48:18 <Mitar> and what should i use?
06:48:42 <Nibble> I don't see what is wrong with fail
06:48:44 <syntaxfree> I read somewhere that the Error monad is the recommended practice, but I don't see why you shouldn't use a dirty failure mode while learning abut other things.
06:49:02 <Mitar> difference between fail = throw?
06:49:25 <Nibble> Mitar: I have no idea, ask someone with more experience
06:49:47 * hackagebot proc 0.0.7 - Parse process information for Linux  http://hackage.haskell.org/package/proc-0.0.7 (AndyStewart)
06:50:13 <Saizan> Mitar, Nibble: fail would be ok if it wasn't in Monad
06:50:17 <syntaxfree> they're here. They're just waiting to see if us peons can answer :) Wait  a minute and some star researcher will answer your question.
06:50:44 <Saizan> Mitar, Nibble: since currently there are many instances of Monad where fail doesn't really make sense.
06:51:20 <cogline> anyone know a good way to open a file in write mode, write some stuff, open the same file in read mode, read the stuff? seems I can't get the output to flush before the read occurs...
06:51:24 <Mitar> aha, and what is its comparisong to throw? and exceptions?
06:51:28 <roconnor> Mitar: I guess the alternatives are to either use throw or mzero
06:51:29 <Mitar> if i use forkIO threads?
06:51:43 <roconnor> Mitar: what monad are you using?
06:52:11 <Saizan> if you use fail in a context where you know which exact monad you're using it's quite fine
06:52:22 <Saizan> for IO fail is the same as ioError iirc
06:52:42 <Saizan> ?type ioError
06:52:43 <lambdabot> forall a. IOError -> IO a
06:52:46 <Saizan> no.
06:52:51 <Saizan> ?src IO fail
06:52:52 <lambdabot> fail s  = failIO s
06:52:57 <Saizan> ?src failIO
06:52:58 <lambdabot> failIO s = ioError (userError s)
06:53:09 <Mitar> aha
06:54:24 <Saizan> so it's the same as "throw (userError s)" afaiu, sincce IOError is an instance of Exception and ioError should be using the same mechanism
07:03:20 <syntaxfree> cogline: dude, this is a referentially transparent language. to quote Infected Mushroom, you have to change the formality and everything about it.
07:03:28 <syntaxfree> leave the I/O stuff for the end. 
07:05:34 <syntaxfree> cogline: http://www.google.com/search?btnG=1&pws=0&q=file+handling+in+haskell+tutorial
07:07:08 <Saizan> cogline: forgot to hClose after writing?
07:07:44 <cogline> no hFlush..hClose... file size remains incorrect and ByteString.hGet fails to read any data
07:08:07 <cogline> even tried `seq` hClose on the chance that it would help...
07:08:27 <cogline> tried all buffering options
07:09:26 <Saizan> cogline: can you paste the code?
07:11:05 <evant_> Heh
07:11:13 <evant_> I'm starting to <3 haskell
07:11:20 <evant_> I tweak like 2 lines and then half my test cases pass
07:12:31 <ksf_> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29634#a29634
07:12:36 <ksf_> that's an inferred type.
07:12:37 <cogline> not sure how to use this hpaste thing: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29633#a29633
07:12:42 <ksf_> I think that's usable.
07:13:55 <Saizan> ksf_: some infix declarations could help, or maybe ghci is not smart enough to use them to reduce parens?
07:14:15 <ksf_> ...especially with a custom type for everything involving PlainStyle
07:14:19 <ksf_> it's using infix.
07:14:35 <ksf_> ...mostly.
07:15:13 <ksf_> and no, ghci isn't smart enough to remove them.
07:15:37 <ksf_> the important thing, though, is that the context is readable.
07:15:47 <ksf_> no unecessary constraints, that is.
07:16:17 <ksf_> needs some specialisation and re-exporting of grapefruit-records' stuff, though.
07:16:45 <Saizan> cogline: i'd be inclined to think that the data you're writing doesn't match your expectations
07:17:44 <cogline> yeah I thought that as well... except printing the length of the BS.replicate shows 100100 bytes, and the read is occuring at ~ 20000 bytes and returning 0 bytes
07:19:18 <ksf_> I can't believe it oo in haskell actually works
07:19:28 <cogline> if it is supposed to work though I will mess around with it some more, just thought it may have something to do with laziness in the file io
07:21:36 <Saizan> if BS is Data.ByteString (not .Lazy) then there's no "lazy I/O" used at all there, and i don't think that'd be a problem anyhow
07:22:15 <cogline> yeah it is Data.ByteString, thanks Saizan :) Ill keep poking
07:37:11 <smorg> Anyone know if multivariable lambdas in haskell (and other languages) are ONLY syntactic shortcuts for curried lambda expressions or is there a theoretical difference between \x y -> ... and \x -> \y ... you just can't tell due to implicitly curried type inference? The thing I'm reading about the actual lambda calculus sort of implies that it isn't just a shortcut. (afaict the behavior is the same for haskell/scheme/python).
07:37:56 <Tomsik> it's not a shortcut in lambda calculus, what?
07:38:17 <Tomsik> and I think there shouldn't be a difference in haskell that would matter
07:38:26 <smorg> It sounds like the basic lambda calculus only allows a single variable bound to each lambda
07:38:30 <geheimdienst> afaik in haskell, "\x y ->" is in fact syntactic sugar for two lambdas of one argument. i'm pretty sure i read that somewhere
07:38:44 <Tomsik> smorg: yeah, \x y -> is just a notation
07:38:45 <geheimdienst> (although you'd never know)
07:38:51 <copumpkin> they're equivalent, but the compiler doesn't actually implement it that way
07:39:04 <Tomsik> if you want two at the same time, you can uncurry to \(x,y) ->
07:39:53 <geheimdienst> tomsik, that looks suspiciously like a lambda of one arg, which is a 2-tuple ;)
07:40:39 <smorg> Yeah that's pretty much what I was wondering if \x y == uncurry \x -> \y and then it just was inferred back to the curried form
07:41:08 <doofer> how long does it usually take to get a hackage account?
07:42:01 <Tomsik> geheimdienst: that's what uncurrying is about, isn't it?
07:42:13 <copumpkin> currying isn't that
07:42:26 <Tomsik> :t uncurry
07:42:27 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
07:42:28 <copumpkin> (un)currying is switching back and forth between a tupled representation of the arguments
07:43:22 <Axman6> doofer: depends, i'm not sure who's looking after it at the moment
07:45:49 <cogline> Saizan: aha, need to pay more attention, open in WriteMode truncates file so it was getting truncated in later code. Thanks again for the help
07:46:09 <doofer> Axman6: okay, I guess I'll have to exercise patience
07:46:22 <Tomsik> > (\x y -> x+y) 5 
07:46:23 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
07:46:23 <lambdabot>    arising from a use of `...
07:46:32 <Tomsik> it's just \x->\y-> then
07:46:44 <geheimdienst> doofer, i heard that it should take around one day
07:47:05 <doofer> gehimdienst: okay, I've waited 5 now
07:47:10 <doofer> +e
07:47:25 <Axman6> smorg: i'm pretty sure that \x y is puerly just syntax for \x -> \y -> designed to save a lot of typing
07:49:26 <roconnor> Axman6: it's a little different
07:49:34 <roconnor> technically
07:50:30 <int80_hSLEEPYTIM> @seen ski
07:50:30 <lambdabot> Unknown command, try @list
07:50:46 <int80_h> @list
07:50:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
07:50:51 * roconnor tries to remember how to observe the difference
07:50:56 <doofer> sleepy tim!
07:51:12 <int80_h> it cut off the e
07:51:12 <copumpkin> roconnor: I didn't think it was possible to observe the difference
07:51:19 <doofer> oh :(
07:51:20 <roconnor> I think I can
07:52:10 <ksf_> Axman6, \x y = \x -> \y -> case (x,y) of (x,y) -> 
07:52:27 <int80_h> @users
07:52:27 <lambdabot> Unknown command, try @list
07:52:32 <int80_h> @seen
07:52:32 <lambdabot> Unknown command, try @list
07:52:34 <int80_h> bah
07:53:00 <copumpkin> it's not going to suddenly remember how to interpret those commands
07:54:34 <roconnor> oh, maybe I needed to use patterns
07:54:45 * quicksilver wonders where mauke + preflex are
07:55:00 <roconnor> maybe they were only different when using patterns
07:56:02 <jmcarthur> MY EYES http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
07:56:17 <roconnor> > ((\(p:q) -> \(h:t) -> undefined) undefined) `seq` 5
07:56:18 <lambdabot>   *Exception: Prelude.undefined
07:56:18 <jmcarthur> if i was going to troll #haskell, this is what i would refer to
07:56:23 <roconnor> > ((\(p:q) (h:t) -> undefined) undefined) `seq` 5
07:56:25 <lambdabot>   5
07:56:34 <ksf_> jmcarthur, they're nicer when you look at the source. haddock messes them up.
07:56:48 <jmcarthur> yeah haddock does that
07:56:53 <roconnor> copumpkin: I think that is what I was thinking of.  So Axman6 was probably right, that \x y -> is the same as \x -> \y ->
07:57:01 <BONUS> jmcarthur: ahaha what the hell is that
07:57:06 <ksf_> ...and I've got the feeling sessions is using way more type magic than necessary.
07:57:28 <jmcarthur> BONUS: http://blog.ezyang.com/2010/09/my-type-signature-overfloweth/
07:57:36 <jmcarthur> ksf_: it almost certainly is
07:58:13 <quicksilver> roconnor: that looks like it's probably a bug in ghc, to me.
07:58:19 <quicksilver> roconnor: (as in, a violation of the report)
07:58:22 <roconnor> quicksilver: I think it is Haskell 98
07:58:27 <quicksilver> although probably not one that many people care about.
07:58:29 <quicksilver> really?
07:58:34 <roconnor> that's what I think
07:58:51 <roconnor> The following identity holds:
07:58:52 <roconnor> \ p1 ... pn -> e 	= 	\ x1 ... xn -> case (x1, ..., xn) of (p1, ..., pn) -> e
07:58:53 <roconnor> where the xi are new identifiers. 
07:59:47 <roconnor> all pattern matches in a lambda expression are "done at the same time"
08:00:01 <roconnor> er
08:00:03 <roconnor> wait
08:00:25 <roconnor> anyhow
08:00:31 <roconnor> the report is kinda screwy here
08:00:37 <jmcarthur> waitaminute...
08:00:51 * jmcarthur just looked up at the seq examples above
08:01:08 <malorie> why isn't `(\(_:x:[]) -> x)' a valid implementation for `last'?
08:01:20 <roconnor> I guess it is that if you have one pattern then the match is done immedately, but if you have two patterns the matches are delayed lazily?
08:01:34 <Axman6> because what about the list 1:[]?
08:01:34 <roconnor> malorie: because your _ isn't a list
08:01:49 <Axman6> and how does it match 1:2:3:[]?
08:01:50 <jmcarthur> oh i see
08:01:59 <jmcarthur> that's disgusting :)
08:02:03 <roconnor> malorie: you are thinking of '(\(_ ++ x:[]) -> x)
08:02:11 <roconnor> malorie: which isn't legal syntax
08:02:13 * hackagebot satchmo 1.8.0 - SAT encoding monad  http://hackage.haskell.org/package/satchmo-1.8.0 (JohannesWaldmann)
08:02:21 <Nibble> roconnor: why not
08:02:28 <malorie> roconnor: I see.
08:02:32 <roconnor> Nibble: because ++ isn't a constructor
08:02:44 <Nibble> I see
08:03:00 <Nibble> if someone made a constructor that does that
08:03:14 <ksf_> ...because making pattern matching a pushdown language is a bad idea.
08:03:33 <ksf_> well that example is actually regular but anyway.
08:04:05 <ksf_> (++) is touring complete, there's no sane way to unroll it into a pattern.
08:04:06 <roconnor> Nibble: there are view patterns which can do something similar however in the case of ++ there are generally multiple ways to decompose a list into (x ++ y).
08:04:07 <smorg> ah. I guess it's just harder to conceptualize how scoping and binding free variables works in scheme s-expressions than haskell
08:04:32 <roconnor> Nibble: so pattern matching would become nondeterministic
08:04:40 <Nibble> I see
08:14:30 <ksf_> ok, typelevel code golf. Does anyone see any possibility to get "remainder" out of the context when calling "narrow" in    http://code.haskell.org/grapefruit/main/grapefruit-records/src/Data/Record.hs  ?
08:15:17 * hackagebot satchmo-backends 1.8.0 - driver for external satchmo backends  http://hackage.haskell.org/package/satchmo-backends-1.8.0 (JohannesWaldmann)
08:15:26 <ksf_> for the record, it works for looking up a single field:  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29636#a29636
08:47:13 <acowley> Is it possible to generate rewrite rules using TH?
08:52:53 <cch> how can I convert a String to a ByteString in GB2312 encoding
08:53:57 <cch> I can use Data.ByteString.UTF8.fromString to convert a String to a Bytestring in utf8
08:54:11 <cch> but how to get one in GB2312 encoding?
08:54:23 <acowley> does text-icu cover it?
08:55:18 <Axman6> aren't String's utf-8 encoded to begin with?
08:55:32 <cch> ok, let me read its doc
08:56:31 <tommd> Wahoo, System.Crypto.Random exists.
08:56:45 <tommd> err, Data.Crypto.Random
08:57:09 <copumpkin> Axman6: no
08:57:41 <copumpkin> Axman6: strings are just lists of Char, which are simply unicode codepoints (UCS4 encoding, I guess)
08:58:13 <mreh> is it possible to enable profiling of functions from the system libraries?
08:58:39 <mreh> can I install the profiling versions of base?
08:59:06 <aristid> copumpkin, i don't think UCS4 applies, because there are no bytes involved. it's a list of numbers, not a list of bytes.
08:59:28 <jmcarthur> mreh: if you couldn't i don't see how you could link a profiling version of anything...
09:01:33 <mreh> why not?
09:01:53 <mreh> I'm already profiling, but functions such as "readFile" don't appear
09:03:47 <Mitar> where is "error" function defined?
09:04:18 <Mitar> should i use error or throwIO?
09:04:21 <cwb> Memoization/caching question: Is there something obviously wrong about using a state monad as a memory cache for various functions in my program?
09:04:35 <mreh> error is the definition of a partial function, I don't think it has a visible implementation
09:04:54 <mrsolo> hmm what is stream fusion?
09:05:40 <ksf_> mrsolo, do you know unix pipes?
09:05:51 <Axman6> mrsolo: it's a technique that can be used for things like list processing which removes intermediate data structures
09:06:04 <acowley> cwb: it's a fine technique, but that decision can have wide-ranging effects on your code.
09:06:17 <ksf_> imagine say 10 programs piped together: each will iterate over their input and output something.
09:06:30 <ksf_> stream fusion goes ahead and fuses all 10 loops into a single one.
09:06:44 <mrsolo> ksf_, ya
09:06:51 <mrsolo> i see
09:06:52 <mrsolo> so
09:06:55 <ksf_> (if it's possible, that is. it obviously won't work with sort)
09:06:55 <Mitar> :t error
09:06:56 <lambdabot> forall a. [Char] -> a
09:06:57 <cwb> acowley: in the sense that I'll have to restructure it significantly or in that it might produce other performance side-effects?
09:07:13 <mrsolo> is this new for haskell
09:07:20 <acowley> cwb: just the restructuring
09:07:33 <mrsolo> seem like some libraries are converting to that
09:07:36 <ksf_> afaik, yes, it's new.
09:07:36 <acowley> cwb: In many other languages, you can add memoization fairly transparently
09:08:00 <acowley> cwb: but since you're making the shared state explicit in Haskell, the consumer of your State-memoized function must also be used within State.
09:08:01 <cwb> acowley: Is it a common technique, or should I really be looking to understand something deeper?
09:08:03 <ksf_> most other functional languages seem to be stuck with build/foldr or similar
09:08:29 <Axman6> memoisation can be really elegant in haskell
09:08:31 <acowley> cwb: I think it's a good approach. You can look at Conal's writings on functional memoization, but using State to thread ... state ... is pretty idiomatic :)
09:08:34 <ksf_> fusing in general isn't a new idea in functional land, though, it's just that stream fusion can fuse more than every other scheme.
09:08:48 <Axman6> as long as the universe of values is restricted anyway
09:09:16 <acowley> cwb: In particular when you have a really large domain (e.g. Int), it can make sense to carry around an IntMap to cache results.
09:10:00 <acowley> ksf_: I think that lazy evaluation is a key ingredient in its success in Haskell.
09:10:01 * mrsolo reads the paper
09:10:10 <mrsolo> hmm look like performance gain isn't universal
09:10:22 <mrsolo> oh well can't dumb fire the thing then...
09:10:31 <ksf_> recent versions improve upon the paper
09:10:41 <ksf_> ...but you shouldn't trust anything without profiling it.
09:10:44 <cwb> acowley: Thanks, that's very helpful. My code has a shared (reader) environment anyway so adding a state monad should be fairly natural I think.
09:11:03 <mreh> is "read" slow?
09:11:12 <Axman6> mrsolo: reading up on dons' blog about stream fusion might help a lot
09:11:26 <ksf_> mreh, faster than parsec, slower than happy, I'd say.
09:12:17 <ksf_> it only parses regular grammars, so it isn't particularily hard to optimize the parsing.
09:12:27 <mreh> well indeed
09:12:44 <Nibble> 77777777777777777777777
09:12:45 <mreh> reading these lists takes the majority of my execution time
09:12:50 <Nibble> oh damn, wrong button
09:13:06 <mrsolo> Axman6, oh? where is it? 
09:13:17 <Axman6> @google donsbot blog
09:13:18 <lambdabot> http://donsbot.wordpress.com/
09:13:18 <lambdabot> Title: Control.Monad.Writer
09:13:42 <mrsolo> thanks
09:14:46 <mreh> can you read nested records with a regular grammar?
09:15:10 <monochrom> I can't.
09:15:17 <mreh> pumping lemma?
09:15:31 <monochrom> Yes.
09:15:41 <ksf_> *cough* yes and no.
09:15:43 <mreh> if my computer science classes serve me well
09:15:48 <ksf_> you can, if you allow for infinite grammars.
09:15:54 <mreh> not an arbitary number of nested records
09:15:56 <Axman6> mrsolo: http://www.cse.unsw.edu.au/~dons/papers/CLS07.html also
09:16:10 <monochrom> Oh oops, I can design a regular grammar. Say, RPN.
09:16:20 <mreh> unfortunately computers aren't infinite :(
09:16:35 <mrsolo> Axman6, ya the paper i got.. that blog is very nice :-)
09:16:37 <ksf_> and as ReadP constructs+minimises the DFA on the fly, yes, it can parse nested expressions.
09:17:29 <ksf_> it's an infinite automaton only in the sense that it's always finite. that is, big enough to parse your stuff.
09:17:31 <monochrom> what is a nested record? is recursion involved?
09:18:27 <mreh> i'm lost!
09:18:27 <ksf_> recursive ADT, yes.
09:18:46 <monochrom> recursion is hopeless
09:19:26 <gigamonkey> Hey guys, I'd love to get some Haskell entries for this http://www.codequarterly.com/code-challenges/markup/
09:19:29 <Mitar> is there a function which takes value from monad and simply discards it?
09:19:44 <malorie> is it somehow possible to have "subfunctions" inside functions? like http://codepad.org/Mz0TpLgE
09:19:51 <Mitar> so that i can make a wrapper function with partially defined parameters and also remove return value?
09:20:23 <mreh> malorie: yes, just drop the guards
09:20:31 <mreh> write the function definition directly in the where
09:20:35 <ksf_> :t (>> return ())
09:20:36 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
09:21:17 * Axman6 often wonders why unit = return () isn't defined as a standard function somewhere
09:21:38 <ksf_> because RTS implementations need the name.
09:21:41 <fasta> gigamonkey, what is the point to give a spec that is broken? 
09:21:57 <fasta> gigamonkey, broken specs lead to broken software in many cases.
09:22:16 <Axman6> well, some other name would do
09:22:28 <malorie> mreh: I'm getting "incorrect indentation" errors then, though ...
09:22:40 <mreh> malorie: did you paste a revision?
09:22:42 * BONUS would prefer done = return ()
09:22:47 <Axman6> yeah
09:22:59 <Axman6> has the right semantics
09:23:07 <Axman6> as least for where i was using it
09:23:08 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29638#a29638 << am not sure how to use return () here?
09:23:11 <gigamonkey> fasta: what's broken about it?
09:23:17 <monochrom> do { x<-getLine; done; putStrLn x }
09:23:31 <malorie> mreh: here http://codepad.org/6b6ZcvpM
09:23:34 <Axman6> sure, it can be misused
09:23:37 <monochrom> forever (do { x<-getLine; done; putStrLn x })
09:23:42 <gigamonkey> It's not intentionally broken. It just exists in the real world so therefore is unlikely to be perfect.
09:23:45 <ksf_> aka "return, the most misnamed function in all of haskell"
09:24:04 <monochrom> no, return is misnamed in the "real" world
09:24:27 <mreh> malorie, http://codepad.org/VkqGtA2e
09:24:28 <BONUS> i'd prefer return in haskell be called lift and lift be called, well, something else
09:24:37 <mreh> raise
09:24:41 <ksf_> pure. let's call it pure.
09:24:48 <mreh> yeah, pure!
09:24:48 <Mitar> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29638#a29638 << how can i partially do that?
09:24:57 <Axman6> > pure genius
09:24:58 <lambdabot>   Not in scope: `genius'
09:25:04 * Axman6 -> sleep
09:25:07 <ksf_> actually, fromPure but that's quite long.
09:25:26 <mreh> and put in the Pointed restriction in Monad
09:25:27 <ksf_> wrap, inject and point are possibilities, too.
09:25:45 <malorie> mreh: aaah, that makes sense now. thanks.
09:27:56 <Mitar> anyone?
09:29:18 <Zao> Mitar: What library is this using, and what do you mean by "partially do"?
09:29:47 <ksf_> waitFor (-1) >> return ()
09:29:51 <Zao> If you want to ignore the result, >> return ()
09:29:58 <acowley> Mitar: ((>> return ()) .) . waitForCaptureImpulse' (-1)
09:30:02 <ksf_> Mitar, you want to read a monad tutorial.
09:30:08 <Zao> There's probably some `ignore' function defined somewhere too.
09:30:25 <monochrom> ignore is defined in SML prelude
09:30:40 <Zao> Oh right. The definition of it would be annoying for non-nullary actions.
09:31:12 <Zao> @type (>>)
09:31:13 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
09:31:27 <Zao> @type return ()
09:31:28 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
09:31:36 <int80_h> coudl someone tell me what the "@ (d:_)" part of this line does, I will paste more context if needed. unprocessed @ (d:_) <- getArgs
09:31:37 <monochrom> I am not thrilled about "Prelude.Twitter has every function writable in 140 words or less"
09:31:56 <Zao> int80_h: @ lets you name the whole of the RHS.
09:32:04 <Zao> a@(x:xs) calls the whole list a.
09:32:15 <ksf_> int80_h, args@(x:xs) binds args to (x:xs)
09:32:23 <ksf_> ...the rest is your usual pattern match.
09:32:45 <monochrom> > case Just "hello" of b@(Just (x:xs)) -> (b, x, xs)
09:32:45 <lambdabot>   (Just "hello",'h',"ello")
09:32:47 <acowley> int80_h: http://en.wikibooks.org/wiki/Haskell/Pattern_matching#As-patterns
09:33:00 <monochrom> > case Just "hello" of b@(Just c@(x:xs)) -> (b, c, x, xs)
09:33:01 <lambdabot>   (Just "hello","hello",'h',"ello")
09:33:03 <int80_h> (d:_) means "don't do anything with the rest of the list, we just want the head", right?
09:33:12 <ksf_> yep
09:33:28 <int80_h> acowley: thanks!
09:33:38 <ksf_> ...so does not doing anything with the xs in (x:xs)
09:33:55 <ksf_> (modulo -Wwarnunusedvariables or whatsitcalled)
09:34:29 <monochrom> -fwarnPEBKAC
09:38:49 <cch> how to 
09:39:04 <monochrom> by hand.
09:39:20 <cch> how to "sleep" some time, like that one in python or bash
09:39:33 <monochrom> Control.Concurrent.threadDelay
09:39:54 <tommd> Take note - threadDelay is in microseconds and is an integer value
09:40:11 <tommd> On most (32 bit) systems this limits your sleep to just over 2 minutes iirc.
09:40:27 <cch> ok thanx
09:40:31 <tommd> You can string multiple threadDelays together or use one of the more advanced event systems.
09:40:40 <tommd> ^^^ for longer sleeps, that is.
09:40:43 <cch> good :)
09:40:54 <cch> you are so kind, thanx
10:07:34 <int80_h> ski: you in?
10:07:53 <duckinator> hi
10:08:00 <int80_h> duckinator: hi
10:24:00 <sunfun> ciao a tutti
10:24:35 <int80_h> notabel: you there?
10:26:07 <Nibble> A quick question
10:26:10 <Nibble> or nvm
10:26:16 <Nibble> :t >>=
10:26:17 <lambdabot> parse error on input `>>='
10:26:21 <Nibble> :t (>>=)
10:26:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
10:26:37 <Nibble> so, it does the action to the right first?
10:27:09 <Kaidelong> :t join . ($)
10:27:10 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
10:27:32 <Kaidelong> :t join . flip ($)
10:27:33 <lambdabot>     Occurs check: cannot construct the infinite type:
10:27:33 <lambdabot>       m = (->) (a1 -> m a)
10:27:33 <lambdabot>     Probable cause: `$' is applied to too few arguments
10:28:12 <c_wraith> Nibble: it evaluates the second argument (the function), as if the first argument wasn't in the monadic wrapping.
10:28:35 <c_wraith> What precisely that means is entirely up to the monad in question
10:30:31 <Kaidelong> > [5,6] >>= (\x->[1..x])
10:30:32 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,6]
10:31:52 <c_wraith> for the list monad, it unwraps the first argument by passing in each value of it, and concatting their results together.
10:32:22 <Kaidelong> well for the list monad, join and concat are the same idea right?
10:32:25 <roconnor> > let foo = flip concatMap in [5,6] `foo` (\x->[1..x])
10:32:27 <lambdabot>   [1,2,3,4,5,1,2,3,4,5,6]
10:32:40 <Kaidelong> > join [[1,2],[3,4]]
10:32:41 <lambdabot>   [1,2,3,4]
10:33:29 <Kaidelong> do monads imply functors?
10:33:42 <copumpkin> yeah
10:33:46 <copumpkin> not in haskell though
10:33:57 <copumpkin> but you can trivially make a Functor instance if you have something with only a Monad instance
10:34:22 <Cale> instance Functor M where
10:34:25 <Cale>   fmap = liftM
10:34:53 <Twey> Might as well stick it on one line
10:34:59 <Twey> instance Functor M where fmap = liftM
10:35:41 <Kaidelong> doesn't haskell, or GHC at least, actually have language support allowing you to say something like that for all monads?
10:36:28 <Twey> :t flip $ fmap (>>=) . (return .)
10:36:28 <lambdabot> forall a (m :: * -> *) a1 b. (Monad m) => a -> (a -> a1) -> (a1 -> m b) -> m b
10:36:36 <Twey> Hm
10:36:50 <Twey> Kaidelong: Not AFAIK
10:37:14 <jmcarthur> Kaidelong: well, you could requires that all Monads already be instances of Functor
10:37:17 <jmcarthur> *require
10:37:27 <jmcarthur> class Functor m => Monad m where ...
10:37:32 <Kaidelong> that'd require changing Monad though
10:37:34 <jmcarthur> yeah
10:37:50 <Kaidelong> but what I was thinking of would probably imply overlapping instances to be useful anyway
10:37:59 <copumpkin> undecidable?
10:38:02 <copumpkin> typically
10:38:02 <jmcarthur> Kaidelong: with some extensions you can also define instance Functor m => Monad m where fmap = liftM, but then you can introduce all kinds of ambiguities
10:39:06 <chrisdone> chris donium up in this channel
10:39:14 <Kaidelong> a shame then that a binding is wasted on liftM
10:39:34 <Twey> :t flip $ (. (return .)) . (>>=)
10:39:34 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> m a1 -> m a
10:40:04 <Twey> I like how every time I write that, it turns out a little different
10:40:17 <chrisdone> if you're writing generic functions, liftM, fmap, liftA etc are important to have distinct
10:40:28 <Twey> chrisdone: How so?
10:40:49 <chrisdone> because you need a class constraint for each
10:41:02 <chrisdone> trying to use fmap when you've already got a Monad constraint, for example, is more work for nothing
10:41:21 <Twey> Sure, but the class constraints of liftM and liftA are superclasses of the class constraint of fmap
10:41:34 <chrisdone> theoretically but not actually
10:41:38 <c_wraith> liftA is
10:41:39 <Twey> So long as you provide a type signature, you only need to use fmap
10:41:40 <c_wraith> liftM is not
10:41:48 <Twey> Sure
10:42:03 <chrisdone> that's what I mean by generic function
10:42:17 <chrisdone> x :: Monad m => m foo
10:42:23 <chrisdone> if I use fmap in x, then I need to add Functor m
10:42:23 <int80_h> chrisdone: hey there I noticed your paste amelie is it called?
10:42:30 <chrisdone> int80_h: mhm
10:42:36 <chrisdone> http://github.com/chrisdone/amelie
10:42:54 <int80_h> chrisdone: ah nice, google didn't help me any in finding it
10:43:04 <orbital_fox> hello people
10:43:05 <int80_h> it's a nice study in how to use takusen, which I need.
10:43:43 <Kaidelong> chrisdone: if Monad implies Functor, wouldn't you not need to anything extra in the type signature?
10:43:50 <Kaidelong> I mean, if you wrote Monad that way to begin with
10:43:54 <chrisdone> int80_h: yeah, I kind of turned it into a way to learn takusen
10:44:21 <chrisdone> Kaidelong: if Monad was defined with Functor as the superclass then yeah
10:45:23 <chrisdone> int80_h: I actually made a whole "gitcast" out of the project: http://github.com/chrisdone/amelie-emacs-cast I'm working on making a javascript renderer for it now
10:45:46 <orbital_fox> anyone knows of a mercurial web interface written in haskell? (i feel the chances are remote.. but ill take my chances :P)
10:46:28 <roconnor> http://www.kevinvanaelst.com/cantorsetweb.jpg
10:46:35 <chrisdone> @faq can Haskell increase the chances of me getting what I want?
10:46:36 <lambdabot> The answer is: Yes! Haskell can do that.
10:46:59 <int80_h> chrisdone: your work is appreciated, I may be bugging you very soon to help me with my own takusen project. Right now I'm having trouble prepping flatefiles for populating tables.
10:47:21 <chrisdone> int80_h: what's a flatefile?
10:48:52 <copumpkin> bos: haskell at your job!?
10:49:02 <Nibble> am I stupid or should this work?
10:49:03 <Nibble>     putStrLn "Opening image: " ++ $ concat args
10:49:11 <Nibble>  parse error on input `$'
10:49:16 <bos> copumpkin: crazy, nu?
10:49:23 <jmcarthur> Nibble: putStrLn $ "Opening image: " ++ concat args
10:49:23 <Kaidelong> if you want the left side to be a slice
10:49:26 <copumpkin> bos: indeed! what is the world coming to
10:49:30 <Kaidelong> put it in parenthesis
10:49:37 <Nibble> I see
10:49:49 <Nibble> jmcarthur: that makes sense :)
10:50:04 <int80_h> chrisdone: doh, I meant flat file
10:50:29 <Nibble> is there any function to check if a string contains a string at any point in it?
10:50:37 <copumpkin> bos: any hints on what it's used for, or would you have to kill me?
10:50:43 <jmcarthur> Nibble: if you *really* wanted to write it that way, you would have to say something like this:   putStrLn . ("Opening image: " ++) $ concat args
10:50:48 <bos> copumpkin: xmpp messaging
10:51:02 <copumpkin> ooh
10:51:07 <jmcarthur> bos: where are you working and are they hiring?
10:51:11 <jmcarthur> :)
10:51:12 <copumpkin> lol
10:51:24 <bos> jmcarthur: :-)
10:51:52 <copumpkin> damn, you made it sound like a rhetorical question
10:52:08 <jmcarthur> that wasn't rhetorical at all
10:53:10 <monochrom> Aune makes me think Aunt. "Everyone and their aunts are learning haskell!"
10:53:28 <Makoryu> Isn't that pronounced "OW-neh"?
10:53:42 <monochrom> But I don't pronounce. I spell.
10:53:52 <Nibble> what is this shit with where and indention?
10:54:02 <monochrom> there is no shit.
10:54:04 <Makoryu> Nibble: What shit do you mean exactly?
10:54:15 <chrisdone> Nibble: clean your language, straighten that shirt
10:54:58 <BONUS> btw, lyah preorders on amazon are like 33% off!
10:55:00 <djahandarie> edwardk, ping. You here?
10:55:10 <edwardk> yep
10:55:10 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:55:15 <copumpkin> omg it's edwardk
10:55:29 <edwardk> @tell ivanm no
10:55:30 <lambdabot> Consider it noted.
10:55:34 <Makoryu> BONUS: Amazon always has low prices for books, because the list price is optimized for storefront booksellers
10:55:44 <edwardk> heya copumpkin
10:55:50 <BONUS> yeah? hmm
10:55:59 <Makoryu> BONUS: Typically, a bookstore will receive two copies for every one copy they actually sell
10:56:00 <BONUS> i have no idea how book pricing works, so possibly yeah
10:56:09 <jmcarthur> Makoryu: it also used to be the case that they did per-customer price optimization, but they stopped that after a big backlash
10:56:26 <Makoryu> And then rather than send a copy back to the publisher, they're supposed to destroy their unsold copies
10:56:29 <djahandarie> edwardk, any idea if a monad transformer has a category theory representation?
10:56:31 <Makoryu> jmcarthur: Amazon did? Huh.
10:56:32 <copumpkin> edwardk: I'm working on a fingertree vector hybrid ;)
10:56:51 <edwardk> copumpkin: i have one of those half baked around here somewhere
10:56:57 <applicative> whats a fingertree vector hybrid.  sounds like gm food.
10:57:08 <jmcarthur> copumpkin: that sounds awesome :)
10:57:08 <monochrom> finger vector
10:57:10 <copumpkin> edwardk: was going to use your rope, but it wasn't what I needed
10:57:16 <monochrom> fish finger vector
10:57:35 <jmcarthur> i'm a little confused about what exactly a fungertree vector hybrid is
10:57:36 <edwardk> yeah
10:57:39 <jmcarthur> haha
10:57:41 <jmcarthur> *fingertree
10:57:47 <edwardk> the current rope lib is a bit simplistic
10:57:57 <applicative> are there vectors at the nodes of the fingertree
10:58:00 <Makoryu> BONUS: So, generally speaking, the list price of a book is double (or almost double) the "ideal" price, which in turn already accounts for the slice of profit that goes to the bookseller and everything that goes to the publisher
10:58:16 <Makoryu> BONUS: And the cost of printing is a small fraction of the list price
10:58:18 <edwardk> jmcarthur: vectors for leaves, fingertree for structure. fast appends, but glue together leaves when they are small enough
10:58:33 <Makoryu> Most of the cost the customer sees is for shipping/handling and storage
10:58:36 <jmcarthur> and what would be the measure?
10:58:37 <edwardk> jmcarthur: same asymptotics as the fingertree, lower constants.
10:58:40 <BONUS> ah, i didn't know prices were inflated like that
10:58:53 <jmcarthur> oh i see, so the measure would be a fold over the vector?
10:59:03 <applicative> edwardk, so the point is that the leaves will all be assured to have some sensible size?
10:59:03 <copumpkin> jmcarthur: my goal was to model a sparse vector with an interval map
10:59:07 <edwardk> jmcarthur: length is a good one.
10:59:11 <copumpkin> jmcarthur: so it's a bit like a Vector (Maybe a)
10:59:17 <copumpkin> hence, I called it SparseVector :P
10:59:24 <edwardk> jmcarthur: for bytestring ones i like also measuring "# of UTF8 tail bytes"
10:59:38 <copumpkin> (I'm using this for a reverse engineering purposes, to simulate memory)
10:59:49 <edwardk> copumpkin: ah, you're using a different vector fingertree than i
10:59:54 <copumpkin> yeah :)
11:00:07 <edwardk> applicative: yeah
11:00:26 <jmcarthur> edwardk: see, i was thinking that for a container like vector at the nodes you could just have the measure be over the elements in the containers rather than over the container itself, which would be more general :)
11:00:31 <edwardk> applicative: if you track the bytecount and # of tail bytes you can do things like have a utf8 string that has fast append, and fast indexing for the common cases
11:00:31 <applicative> whats an interval map, nothing is coming into my little head
11:00:57 <edwardk> jmcarthur: yeah
11:01:04 <copumpkin> applicative: a tree that allows efficient intersection queries, and whose keys are ranges
11:01:19 <edwardk> applicative: you associate input ranges with values. then can query points to get all intervals that contain the point and their values
11:01:31 <applicative> i get it.
11:01:39 <edwardk> applicative: (or query windows to get all windows that are contained or that overlap it)
11:01:45 <copumpkin> I think CLRS calls it something else
11:01:49 <copumpkin> can't remember though
11:01:56 <applicative> how do you represent them, they're not regular maps.
11:01:59 <copumpkin> it's pretty trivial to make with a fingertree
11:02:00 <jmcarthur> copumpkin: do you have a specific reverse engineering application in mind for this?
11:02:19 <applicative> jmacarthur, you have to ask?
11:02:21 <jmcarthur> copumpkin: i've also considered using a fingertree to represent memory, but not for reverse engineering specifically
11:02:36 <Nibble> Is it possible to construct an if check that if True, then dosomething, else nothing happens?
11:02:37 <copumpkin> jmcarthur: just a suite of static analysis tools that need an easy/efficient representation of memory
11:02:40 <Nibble> I am having problems with this.
11:02:41 <jmcarthur> applicative: i mean a target ;)
11:02:57 <jmcarthur> copumpkin: ah okay
11:02:58 <copumpkin> macho-arm programs, of course ;)
11:03:02 <copumpkin> who knows what that might be fore
11:03:04 <copumpkin> *for
11:03:08 <Botje> Nibble: if foo then bar else error "might as well stop now"
11:03:18 <Botje> Nibble: or are you working in a monad?
11:03:28 <applicative> is the fingertree somehow representing the ranges? ( I should just look up interval map)
11:04:00 <Nibble> Botje: I am not working in a monad
11:04:04 <copumpkin> applicative: http://hackage.haskell.org/packages/archive/fingertree/0.0.1.0/doc/html/Data-IntervalMap-FingerTree.html
11:04:15 <Botje> then it doesn't make sense to have an if that "does nothing"
11:04:29 <applicative> copumpkin thanks.  the best explanation is always a haskell module...
11:04:30 <Botje> Nibble: can you show what code you're working on?
11:04:34 <monochrom> time to ask "what is your real question"
11:04:47 <Makoryu> Nibble: An if/then/else expression (not a statement) always has to return a value
11:04:48 <copumpkin> applicative: well, they cover it in the fingertree paper too, iirc :)
11:05:02 <copumpkin> applicative: but basically you can construct a simple (fairly obvious) monoid out of intervals
11:05:05 <Nibble> Warning for shitty code, but here it comes( just a few lines)
11:05:06 <Nibble>     if check doesFileExist $ concat args
11:05:06 <Nibble>         then image <- loadImage $ concat args 
11:05:07 <Nibble>         else error $ "File does not exist: " ++ concat args
11:05:22 <monochrom> you are working in a mond
11:05:28 <monochrom> s/mond/monad/
11:05:30 <copumpkin> der mond
11:05:48 <monochrom> this is why I don't trust liars
11:06:02 <c_wraith> doesFileExist isn't going to return a type that can be converted to Bool
11:06:14 <lispy1> monochrom: you don't trust liars??  Man, you're harsh...
11:06:22 * lispy1 trusts liars
11:06:31 <copumpkin> lispy1: I have a business proposal for you, pm please
11:06:36 <fryguybob> Liar!
11:06:43 <c_wraith> gah, copumpkin beat me to the joke
11:06:49 <Nibble> monochrom: are you sure? I tried to add Nothing but it didn't work
11:06:51 * lispy1 needs more bridges
11:07:06 <c_wraith> Nibble, if you're using doesFileExist, you need to be in IO
11:07:12 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29639#a29639
11:07:17 <c_wraith> otherwise you can't do anything with the return value from it
11:07:35 <Makoryu> Nibble: That "foo <- bar" syntax is only valid directly inside a do block
11:07:39 <edwardk> nibble: try restructuring that to call something else. guard (check doesFileExists $ concat args); image <- loadImage ...
11:07:50 <int80_h> lispy1, please to tranfer your bank account numbers to the following nigerian prince in exile...
11:07:54 <edwardk> nibble er or to something like the code fragment above
11:08:51 <Nibble> ok
11:11:26 <int80_h> @faq can haskell square a circle?
11:11:26 <lambdabot> The answer is: Yes! Haskell can do that.
11:11:37 <int80_h> goly, is there anythign haskell can't do?
11:11:59 <cuba> syscalls
11:12:08 <copumpkin> cuba: hmm
11:12:28 <copumpkin> vararg ffi bindings
11:12:29 <copumpkin> how about that
11:12:48 <lispy1> cuba: that's not true.  There is a Haskell based OS and also you can use ffi to make syscalls :)
11:12:57 <Nibble> haskell based os?
11:13:04 <Kaidelong> House
11:13:04 <Nibble> nice
11:13:11 * ksf wonders why he's calling methods by accessing a record instead of sending the object a record that specifies which functions he wants to call.
11:13:23 <cuba> yea ffi woukld work :X
11:13:26 <chrisdone> int80_h: now I investigate if takusen handles dates and how well
11:13:27 <cuba> blame on me
11:13:28 <Kaidelong> I think someone figured out how to make variadic functions in haskell
11:13:36 <Nibble> Kaidelong: indeed
11:13:43 <Nibble> black magic with the type system, I heard
11:13:46 <ksf> yessss.
11:13:49 <ksf> kind of.
11:13:52 <jmcarthur> copumpkin: you can't do business proposals with haskelly people and keep it to yourself! </jest>
11:13:56 <Nibble> Raynes: you like haskell?
11:14:01 <Twey> Yeah, Oleg's done lots of stuffâ€¦
11:14:04 <Nibble> I didn't know that
11:14:13 <applicative> I see the interval maps are nice, search 1783 composers
11:14:13 <applicative> [(Interval {low = 1732, high = 1809},"Haydn"),(Interval {low = 1756, high = 1791},"Mozart"),(Interval {low = 1770, high = 1827},"Beethoven"),(Interval {low = 1782, high = 1840},"Paganini")]
11:14:16 <int80_h> chrisdone: do you have a moment to take a look at my hpaste?
11:14:30 <jmcarthur> Nibble: how do you know raynes?
11:14:32 <copumpkin> applicative: yeah :) they're handy!
11:14:35 <chrisdone> int80_h: maybe. I'll look..
11:14:43 <Raynes> jmcarthur: Different network.
11:14:45 <Raynes> Nibble: Totally.
11:15:13 <Nibble> jmcarthur: by black magic
11:15:16 <copumpkin> jmcarthur: muahaha, I've already made lots of money off of
11:15:20 <copumpkin> I mean, with lispy1
11:15:23 <jmcarthur> Raynes: ah, was just wondering if it was IRL because, IIRC, you live in alabama
11:15:28 <Nibble> and some red, but that does not belong in this discussion
11:15:45 <Raynes> jmcarthur: Correct.
11:15:50 <Raynes> Except for the IRL part.
11:16:23 <chrisdone> int80_h: the intent isn't clear to me, sorry. i'm working amelie. might check it out later
11:16:25 <applicative> or more tastefully, > map snd $ search 1781 composers ...  > ["Haydn","Mozart","Beethoven"]
11:16:40 <copumpkin> applicative: isn't it awesome!
11:16:50 <int80_h> chrisdone: no worries, I will try and articulate my intent better
11:17:24 <applicative> it's all very lucid;  i just have to figure out a use I could make of them for my generally unexciting purposes.
11:17:55 <ksf> what we don't have is a map working on ranges, though. that is, one optimised for non-overlapping intervals.
11:18:16 <aristid> applicative, interval maps? which package?
11:18:23 <copumpkin> aristid: fingertree
11:18:26 <ksf> which would allow one to have a Map Char (Parser Char)
11:18:31 <aristid> @hackage fingertree
11:18:31 <lambdabot> http://hackage.haskell.org/package/fingertree
11:18:33 <ksf> ...for the whole unicode range.
11:18:37 <copumpkin> aristid: they're simple and are mostly provided as an example
11:19:11 <copumpkin> ksf: that would be a generalization of what I'm working on now, but I don't feel like making that one
11:19:21 <aristid> copumpkin, why only as an example? aren't they useful?
11:19:23 <copumpkin> since this is just some yak shaving for something I do want to do
11:19:25 <applicative> aristid, i was just learning about them, there are some concrete illustrations in Data.IntervalMeasure.FingerTree that aren't exported.
11:19:35 <copumpkin> aristid: oh they are, but it's not a very complete module if you look
11:19:58 <copumpkin> someone should release a bigger, more robust one (still based on fingertree) as an independent package
11:20:30 <applicative> the fingertree package could do with a few more such illustrative modules, i hadn't grasped that that's what this was.
11:24:32 <Nibble> is there like a function fromIO ?
11:24:44 <applicative> you mean IO () -> ()
11:24:48 <bss03> applicative: The paper is fairly easy to find; I thought the ilustrations in the paper made things very clear.
11:24:57 <Nibble> applicative: indeed
11:25:00 <monochrom> :type liftIO
11:25:06 <monochrom> @type liftIO
11:25:07 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
11:25:15 <monochrom> that's "fromIO"
11:26:36 <bss03> There's also unsafePerformIO, but keep in mind that it is well-named.
11:27:38 <Twey> :t const () :: IO () -> ()
11:27:39 <lambdabot> IO () -> ()
11:27:45 <monochrom> not sure why you would want to "escape from IO" for this. it is not like loadImage is outside IO anyway.
11:27:59 <Nibble> monochrom: hasn't to do with loadImage
11:29:53 <applicative> bss03, i read it, but over a year ago, maybe not too comprehendingly, then read about fingertrees here and there.  somehow the stupid composer example is giving me an Aha!-Erlebnis maybe I will try the paper again.
11:30:32 * Twey learns â€˜Aha-Erlebnisâ€™
11:31:14 <monochrom> what is Aha-Erlebnis?
11:31:42 <lantti> Erlebnis is german for experience.
11:31:55 <applicative> aha is when you say 'aha1'
11:32:05 <applicative> see http://en.wikipedia.org/wiki/Eureka_effect third paragraph.  
11:32:12 <applicative> i'm remembering it from my childhood somehow
11:32:12 <monochrom> and aha1 is when you say aha11? etc?
11:32:28 <Nibble> Has anyone in here worked with sdl? How do I get width and heigh of an image
11:32:28 <applicative> monochrom, i'm not a pro, i type like a two year old
11:32:29 <monochrom> > let aha = aha ++ "1" in aha
11:32:33 <lambdabot>   mueval-core: Time limit exceeded
11:33:03 <applicative> > let aha = "aha! " ++ aha in aha
11:33:03 <lambdabot>   "aha! aha! aha! aha! aha! aha! aha! aha! aha! aha! aha! aha! aha! aha! aha!...
11:33:45 <maltem> Twey, so they lied when I learnt that â€œAha-Erlebnisâ€ had made it into the English language
11:34:27 <applicative> maltem, I learned it as English.  It comes to me I learned it from reading Martin Gardner as a boy.  Not sure
11:34:32 <monochrom> > let aha = aha ++ "!" in aha
11:34:36 <lambdabot>   mueval-core: Time limit exceeded
11:35:04 <applicative> > let aha = aha ++ "!" in reverse aha
11:35:05 <monochrom> I learned sic bo in english
11:35:08 <lambdabot>   mueval-core: Time limit exceeded
11:35:31 <applicative> well that was moronic
11:36:04 * shapr advocates Haskell at Digium, yay!
11:36:14 <monochrom> where is Digium?
11:36:18 <applicative> or what?
11:37:00 <applicative> we know that Haskell makes us stronger, because we know that what does not kill us makes us stronger. 
11:37:21 <shapr> Digium is the open source company where I work.
11:37:23 <tommd> There is a hidden assumption in that statement
11:37:39 <monochrom> is it in the palestinian territories? oklahoma? XD
11:37:44 <applicative> that haskell won't kill us
11:37:49 <applicative> i agree, that isn't clear
11:38:13 <monochrom> advocating haskell at work is so awkward
11:38:21 <Twey> maltem: Apparently it has.
11:38:29 <Twey> Just not very well.
11:38:50 <Twey> monochrom: Is it?
11:39:15 <Twey> I like to just peer over someone's shoulder at a huge twenty-line Java function, chuckle knowingly, and go â€˜of course, that's a one-liner in Haskellâ€¦â€™
11:39:39 <monochrom> that's just mean.
11:39:49 <applicative> isn't it often a one-liner in perl too?  that's not a completely decisive argument
11:39:52 <Twey> Another good one is to demonstrate in Haskell when someone asks you how to do something, then translate when they ask you to.
11:40:02 <Twey> applicative: Sure, but we don't mention that
11:40:11 <monochrom> ok I do that in #math too
11:40:32 <int80_h> Twey: when I was doing an x86 assembler lab, the java monkey next to me informed me that assembler was now obsolete because of java.
11:40:42 <Twey> Hahahaha.
11:40:45 <monochrom> hahaha
11:41:03 <monochrom> not even cobol is obsolete
11:41:10 <int80_h> oh yeah I laughed wickedly, and they never knew why.
11:41:40 <Adamant> eh, while Java monkey is wrong, in terms of jobs he's correct.
11:41:40 <applicative> i met a young brainy student the other day who's deep into Fortran studies
11:41:49 <int80_h> monochrom : would you look at my hpaste?
11:41:57 <monochrom> I looked thrice.
11:42:01 <Adamant> hey, if you like science shit and simulations, Fortran isn't that bad.
11:42:12 <int80_h> oh is it totally incomprehensible?
11:42:20 <yrlnry> "COBOL isn't dead; it just smells that way."
11:42:22 <arw> Adamant: in terms of jobs he would have been correct in telling his "you are obsolete because of me" to a cobol guy.
11:42:24 <monochrom> not my cup of tea
11:42:53 <applicative> yeah, that's what he was doing, fluids and engineering.  still it seemed a drag to me, proving the eternity of all the ugly languages. (not that I have any Fortran knowledge.  I do know my father learned it....)
11:43:20 <monochrom> there of course exists a one-mile-diameter "reality" bubble in which assembly is obsolete.
11:43:27 <yrlnry> I was appalled to discover  last month that RPG is not only still used, but it is still under active development.
11:43:32 <Adamant> arw: while assembler is useful for any serious dev to know, you can barely even get a job just being an assembler god in EE anymore.
11:43:53 <arw> Adamant: yes. but more thanks to good c compilers than thanks to java...
11:43:54 <applicative> how hard is it to learn assembler?  maybe i should give up on my ever-dilletantish C studies.
11:43:55 <yrlnry> Adamant:  It's not even easy to get a job as a C god.
11:44:14 <Adamant> yrlnry: that I would disagree with more for the present.
11:44:16 <arw> Adamant: no assembler job has ever been replaced by java i would guess.
11:44:18 <int80_h> yrlny: go talk to barracuda netowkrs. they loves them some C gods.
11:44:29 <int80_h> networks too
11:44:48 <Adamant> C is not going away anytime soon for systems programming and is only increasing in actual use in embedded/special purpose
11:44:50 <bnonym> Adamant: that's when you realize you should get into reverse engineering ;)
11:44:53 <monochrom> You can barely get a job just being a java god too. You have to know also version control, for example.
11:45:00 <applicative> it seems for example that knowledge of assembler would help you figure out how to optimize haskell.
11:45:02 <yrlnry> int80_h:  noted, thanks!
11:45:19 <applicative> i was studying dons' blog post about the LLVM generator, now that I've installed it
11:45:35 <Adamant> applicative: assembler would be part of the puzzle for understanding ghc's code optimization
11:45:39 <int80_h> and let me know if you get a job there, we may be co-workers!
11:45:42 <arw> applicative: problem with learning assembler is, its more like learning the quirks of a certain architecture.
11:45:58 <Adamant> arw: any assembler god can do multiple archs
11:46:02 <jonrafkind> im trying to install cabal-install, so i ran bootstrap.sh, it downloaded and built some stuff and I ended up with: Setup: At least the following dependencies are missing: time ==1.1.*
11:46:11 <applicative> arw, yeah, that's what i was thinking.  C doesn't have that problem, or not so much
11:46:19 <wli> IA64 is pretty interesting as far as assembly goes.
11:46:23 <arw> applicative: the building blocks are quite trivial, but the architecture itself is often weird beyond description.
11:46:40 <Adamant> with modern CPU's, beyond the quirks endemic to each processor, the fundamentals are pretty similar
11:46:45 <arw> applicative: c is an assembler dialect, that hides most of the architecture, yes.
11:47:08 <Saizan> jonrafkind: how did you get your ghc?
11:47:09 <Adamant> now super high performance shit, that's to a significant degree individual quirks
11:47:16 <jonrafkind> through ubuntu
11:47:18 <jonrafkind> i think
11:47:29 <jonrafkind> i have 6.8.2
11:47:30 <applicative> i was just wondering about the kind of inspection dons does in that post, and I've seen elsewhere.  http://donsbot.wordpress.com/2010/02/21/smoking-fast-haskell-code-using-ghcs-new-llvm-codegen/
11:47:37 <arw> Adamant: yes, but usually you program in assembler because of the quirks, not because of the common parts. making the easy stuff is a c compilers job.
11:47:51 <int80_h> applicative: would you mind looking at my hpaste?
11:47:55 <Saizan> jonrafkind: then the time lib, which is usually shipped with ghc, is in a separate ubuntu package, it should be libgh6-time-dev
11:48:00 <jonrafkind> ok
11:48:12 <Adamant> Fortran didn't get smooshed by C largely due to it's lack of referencing
11:48:13 <int80_h> or Saizan :)
11:48:18 <applicative> he's just taking a gander at the assembler and seeing, "good work ghc+llvm, the loops are ..."
11:48:20 <Saizan> jonrafkind: ghc-6.8.2 is also quite old, we're at 6.12.3 now
11:48:27 <Adamant> which lets it be better optimized
11:48:42 <Adamant> and there's 60 years of work on FORTRAN optimization
11:48:45 <jonrafkind> how old is 6.8.2
11:48:55 <applicative> maybe 3 years?
11:49:04 <yrlnry> Adamant:  Fortran dates back to only 1955.
11:49:04 <applicative> it's the debian superstable one
11:49:08 <monochrom> 6.8.2 is like many versions of ubuntu ago.
11:49:15 <maltem> int80_h, maybe you could just formulate some more specific questions that we may know better how to answer?
11:49:29 <Adamant> yrlnry: I was thinking it was being worked on from 1950 to that era
11:49:34 <int80_h> okay, I will try
11:49:36 <jonrafkind> ok i just need haskell as a prerequisite to getting agda working, so i dont really care about haskell (unless I need 6.12 to run agda)
11:49:36 <Adamant> I could be way wrong
11:49:41 <applicative> jonrafkind, I thought ubuntu had a better ghc now.  what does it say for 'haskell-platform' a combo package
11:49:49 <jonrafkind> im on an old ubuntu I think, 9.04
11:50:11 <applicative> jonrafkind, if you want agda, you;ll probably want a solid ghc + cabal machinery too, i'd think
11:50:13 <wli> The high performance stuff is mostly SMP/SSI affairs that don't mean a whole lot at the assembly level. The exceptions would be vector machines like the Hitachi whatever.
11:50:19 <monochrom> ubuntu doesn't have haskell-platform per se
11:50:35 <applicative> what does the platform page say.
11:50:53 <bss03> monoshrom: Really?  It should soon; Debian has haskell-patform in Squeeze.
11:50:56 <yrlnry> Adamant:  the first proposal was in late 1953.  The draft spec was ready by mid 54.  The first compiler was delivered in 57.
11:51:05 <monochrom> yes, in debian not in ubuntu
11:51:21 <jonrafkind> i guess i have to install haskell-platform
11:51:21 <Adamant> yeah; optimizing for a single machine is different than optimizing for a highly parallel computer
11:51:28 <Adamant> with lots of nodes
11:51:57 <applicative> jonrafkind, it's good to have those libs for sure.  what ubuntu are you using?  i'm out of ubuntuland 
11:52:06 <Adamant> yrlnry: ah, my mistake. "nearly 60 years", then
11:52:15 <jonrafkind> 9.04, current is 10.04
11:52:42 <Saizan> int80_h: i think you want "data Loader = forall a. Loader (ProgramName a) ([String] -> a)"
11:52:48 <arw> Adamant: depends. many desktop computers are now parallel systems, and even embedded stuff is going multicore for certain tasks
11:52:48 <bss03> monochrom: Maverick looks like it will have haskell-platform, not that I recommend anyone install Maverick packages today.
11:53:04 <monochrom> marvellous
11:53:09 <applicative> jonrafkind, your ghc is working though?
11:53:16 <jonrafkind> yea
11:53:24 <monochrom> is it going to be Marvellous Maverick? or some other adjective?
11:53:27 <Saizan> int80_h: so that loaders = [("students", Loader PNStudents loadStudentIDs), ...]
11:53:35 <arw> Adamant: so many steps like splitting up loops for parallelization are common to all current computer systems.
11:53:37 <bss03> Maverick is the adjective.
11:53:43 <monochrom> darn
11:53:47 <bss03> The animal is the Meerkat, IIRC.
11:53:57 <Adamant> arw: right, but currently multicore is still very different than 128 to thousands of nodes linked up, even if the nodes themselves are multicore
11:53:59 <arw> Adamant: you just have slightly different communication costs.
11:54:45 <jonrafkind> ok cabal barfed when building agda: base-4.2.0.0 was excluded because of the top level dependency base -any
11:54:46 <arw> Adamant: yes, if course the network in between makes for some additional headaches since you need some fancy vm/middleware stuff.
11:54:48 * maltem decides to wait for hardware graph-reduction to catch on and declare lambda calculus the new assembler ;)
11:54:59 <Adamant> arw: I don't think anyone's gotten stuff like STM or (S?)HTM  working over networked nodes in a supercomputer
11:55:20 <Adamant> that tends to be all conceptual message passing
11:55:27 <arw> Adamant: they have. its called a database and its utterly useless for that kinds of computations.
11:55:50 <Adamant> arw: right, I mean for computation, not data integrity.
11:55:53 <monochrom> message-passing is much easier to reason with
11:55:56 <Adamant> and storage
11:55:58 <Adamant> it is
11:56:17 <monochrom> and much faster on tomorrow's computers
11:56:20 <Adamant> tends to be safer and more secure as well, which tends to flow from "easier to reason about"
11:56:25 <monochrom> as well as 1970s transputers
11:56:27 <arw> Adamant: no, i mean the aspect of a database beeing a transactional system.
11:56:31 <jonrafkind> http://pastebin.com/qvDdTH7B ;; more cabal failures. should I just install the latest ghc and try again?
11:56:34 <applicative> jonrafkind, I wish we had an ubuntu expert here.  I was thinking you could just build a new ghc with your old one, then cabal install with that, but there's the question of getting things in the right places
11:56:40 <arw> Adamant: even that is pretty useless in that domain.
11:56:56 <Adamant> arw: right, I agree with you, I'm sure there are huge node count versions of Oracle or whatever
11:56:59 <Ke> I'd bet ubuntu == debian in that sense
11:57:06 <arw> Adamant: its just impossible to ensure proper synchronisation with any useful speed.
11:57:11 <applicative> jonrafkind, type "ghc-pkg list" and see what it says for base
11:57:20 <Adamant> we agree it's not being done for computation-oriented computing
11:57:22 <jonrafkind> base-3.0.1.0,
11:57:28 <applicative> base is the inbuilt lib-like stuff that comes with your version of ghc
11:57:39 <jonrafkind> 'cabal list base' shows 4.x, so i tried to install that
11:57:47 <jonrafkind> is that a Bad Idea (TM) ?
11:57:56 <applicative> oh, right, you can't install base.
11:58:01 <jonrafkind> rofl
11:58:03 <monochrom> base version is locked in with ghc version. futile to upgrade.
11:58:04 <applicative> thats what i was saying too late
11:58:12 <arw> Adamant: yes, but i would also suggest that beyond UMA systems, S/HTM seems too expensive and slow, therefore useless to implement.
11:58:15 <jonrafkind> well im glad it doesnt tell me that.. ok ill just install a newer ghc
11:58:18 <applicative> so you definitely need a new ghc
11:58:34 <applicative> the question is whats the best way to do it, since the package manager isn't helping.
11:58:36 <Adamant> arw: agreed; I think it's optimal for local multicore stuff.
11:58:37 <monochrom> does adga really need base-4?
11:58:47 <jonrafkind> cabal itself should say "you can't install base"
11:58:47 <applicative> it needs base-17!
11:58:50 <kmc> HTM?
11:58:56 <kmc> hardware transactional memory?
11:58:58 <monochrom> h = hardware
11:59:00 <copumpkin> monochrom: yeah, it actually wants 4.1
11:59:02 <Adamant> yes.
11:59:04 <applicative> jonrafkind, this point is sometimes made.
11:59:09 <copumpkin> monochrom: for the new unicode IO stuff
11:59:22 <monochrom> I see.
11:59:25 <Adamant> possibly HSTM (hardware assist)
11:59:45 <monochrom> hardware transaction memory library XD
11:59:56 <applicative> should jonrafkind just install the new ghc tarball into /usr/local together with cabal install?
12:00:01 <Adamant> yeah, there's no good word for it yet
12:00:10 <jonrafkind> should I just get some haskell-platform?
12:00:13 <Adamant> mostly because most approaches are one or the other
12:00:53 <applicative> jonrafkind, i think you should, it gives you cabal and the fundamental libs, and if it were managed by a proper package manager the links to the relevant c libs would be taken care of
12:00:56 <monochrom> one option: upgrade ubuntu. another option: keep old ubuntu, install ghc tarball by hand to /usr/local
12:01:12 <applicative> monochrom, and the downsides of the latter?
12:01:15 <arw> Adamant: i've heard ASTM, for assisted software TM. but I guess its not commonly used.
12:01:38 <monochrom> there is no downside of hand-installed ghc IMO
12:01:47 <applicative> jonrafkind, secretly, i reinstall my os whenever i reinstall ghc, but i'm a haskell zombie
12:01:50 <int80_h> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29641#a29641
12:01:58 <int80_h> okay I tried to ask a sensible question.
12:02:08 <jonrafkind> fwiw, upgrading ubuntu is akin to reformatting your hard drive.. so I don't like doing that :p
12:02:27 <int80_h> that's why I don't use ubuntu
12:02:29 <applicative> monochrom, then he needs cabal install to get adga, what can go wrong with that?
12:02:29 <monochrom> If you want to install ghc and haskell-platform by hand, http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
12:02:39 <jonrafkind> ok this ubuntu package will install ghc 6.10.4, maybe thats good enough
12:02:44 <applicative> he wants the usual ~/.cabal/bin/agda i suppose
12:03:12 <jonrafkind> http://sitr.us/2009/07/02/how-to-install-haskell-platform-on-ubuntu-jaunty.html -- this one
12:04:44 <Nibble> lol
12:04:45 <Nibble> > let 2 + 2 = 5 in 2 + 2
12:04:46 <lambdabot>   5
12:05:00 <applicative> jonrafkind, it looks like the link you put up is installing the platform with ghc-6.3
12:05:21 <applicative> albert lai (whats his nicl?) is I think pretty knoweldgeable
12:05:30 <jonrafkind> its installing 6.10
12:05:32 <wli> monochrom
12:05:40 <jonrafkind> .../ghc6_6.10.4-1.0~ppa2_i386.deb
12:05:56 <applicative> oh, indeed
12:06:10 <applicative> whats the base version for 6.10
12:06:42 <int80_h> Nibble I sense a T-Shirt in the making.
12:06:44 <applicative> must be okay, the base for 6.12 is 4.2
12:07:02 <Nibble> int80_h: I found it on haskell wiki
12:07:22 <Ke> were ghc threads cheap enough for 10^6 scales on a home computer?
12:07:44 <applicative> @faq , Ke
12:07:44 <lambdabot> The answer is: Yes! Haskell can do that.
12:07:55 <kmc> Ke, about that
12:08:01 <monochrom> 6.10.x base is 4.0.x
12:08:05 <kmc> Ke, i've done 10^5 on my fairly slow laptop iirc
12:08:12 <kmc> it depends on what the threads are doing, obviously
12:08:16 <applicative> uh oh, he needs 4.1.1 for agda, they were saying
12:08:27 <jmcarthur> shapr: so, have you converted anyone at digium yet?
12:08:36 <copumpkin> monochrom: there's a bug in the agda cabal file, I think
12:08:42 <jonrafkind> agda says: base >=4.0 && <4.3, syb ==0.1.*
12:08:45 <monochrom> albert lai is not that knowledgeable. but definitely scientific.
12:08:51 <jonrafkind> why do you think it needs 4.1.1?
12:08:57 <copumpkin> jonrafkind: yeah, but there's agda-pkg that constrains it further
12:09:01 <copumpkin> even though it's not necessary
12:09:20 <monochrom> if he bothers to speak up, it's fallible observable reproducible.
12:09:33 <applicative> jonrafkind, i think there's no way out of getting a state of the art haskell, despite it's being agda you want.  
12:09:48 <applicative> copumpkin has way more agda-consciousness tho
12:09:49 <jonrafkind> ok, well lemme see what happens with 6.10
12:10:01 <jonrafkind> it seemed like i need to build 6.12 from source so that i can build haskell-platform
12:10:08 <copumpkin> anyway, I'd recommend getting agda head if possible
12:10:16 <copumpkin> and upgrading ghc isn't bad
12:10:22 <jonrafkind> yes, its been fun so far
12:10:40 <applicative> yeah, thats what i recommend, 6.12 folloqwing lai's advice. if you have the c libs he mentions via synaptic, there is little problem
12:10:52 <applicative> it takes a little while for old ghc to build new one of course
12:11:11 <applicative> but i built ghc-head yesterday, not too much trouble.
12:11:17 <jonrafkind> actually i should just do this in a vm, i dont know why i waste my time with ubuntu when i have gentoo sitting around
12:11:33 <applicative> of course thats another possibility....
12:11:40 <monochrom> why do you need to build ghc?
12:11:45 <shapr> jmcarthur: I persuaded one of the kernel driver developers to borrow RWH, because my thirty second 'elevator pitch' involved "no other way to write decent code for lots of cores without STM".
12:11:48 <applicative> not like you;ll be getting smoking hot code with agda!!
12:12:12 <jonrafkind> monochrom, to get the latest ghc which agda requires
12:12:26 <monochrom> you can just use the binary tarball
12:12:59 <jonrafkind> theres a binary for 6.12?
12:13:01 <applicative> jonrafkind, i wonder if gentoo is up to date, the link via the haskell platform page mentions 6.10
12:13:15 <monochrom> http://darcs.haskell.org/download/dist/6.12.3/ghc-6.12.3-i386-unknown-linux-n.tar.bz2
12:13:19 <applicative> i really think downloading the 6.12 tarball albert lai links is no great shakes
12:13:28 <monochrom> more generally http://darcs.haskell.org/download/download_ghc_6_12_3.html#x86linux
12:13:32 <applicative> then there's a separate general linux platform tarball
12:13:35 <applicative> then itll be
12:13:39 <applicative> cabal update
12:13:46 <applicative> cabal install agda
12:14:04 <jmcarthur> shapr: nice
12:14:07 <copumpkin> I wouldn't install the agda on cabal
12:14:18 <jonrafkind> i have the agda source, 2.2.6
12:14:19 <jmcarthur> shapr: although that's a bit of a lie you told him :P
12:14:39 <jmcarthur> or at least overstated
12:14:40 <Tomsik> @instance Data
12:14:41 <lambdabot> Maybe you meant: instances instances-importing
12:14:48 <Tomsik> @instances Data
12:14:49 <lambdabot> Couldn't find class `Data'. Try @instances-importing
12:14:49 <applicative> i was about to say, or rather, get the source, darcs get ..., then cd agda, cabal install.... is that wrong, copumpkin
12:14:53 <shapr> jmcarthur: How so?
12:14:55 <Tomsik> @instances Data.Data
12:14:55 <lambdabot> Couldn't find class `Data.Data'. Try @instances-importing
12:15:05 <jmcarthur> shapr: *no* other decent way?
12:15:21 <shapr> jmcarthur: We'd already talked about Erlang earlier, and I argued that separate process space is significantly less efficient than shared memory.
12:15:27 <edwardk> technically it is Data.Data.Data
12:15:34 <edwardk> it is right next to Mushroom.Mushrom
12:15:34 <Tomsik> @instances Data.Data.Data
12:15:35 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Maybe a, Ordering, [a]
12:15:37 <shapr> jmcarthur: Mostly because edwardk convinced me of that sometime back
12:15:46 <copumpkin> applicative: nope, that's right
12:15:59 <jmcarthur> shapr: if all you're concerned with is using more cores, i find par and strategies to be far more effective than STM and other concurrency abstractions
12:16:02 <applicative> jonrafkind, your ghc-6.12 could be built by now!
12:16:11 <copumpkin> edwardk: if you have a machine with massive amounts of RAM, you should join the category theory on agda effort :P
12:16:20 <applicative> once you have cabal install you can cabal install pandoc too and be cooler than all your friends
12:16:24 <copumpkin> edwardk: but nobody can actually typecheck the monoidal category module right now :P
12:16:25 <jmcarthur> and of course eventually things like DPH will have a good level of maturity, too
12:16:25 <jonrafkind> well actually agda is building, so ill see if that works
12:16:29 <shapr> jmcarthur: I haven't used them, do they compose as well as stm?
12:16:33 <edwardk> i do, but i already burned through one machine trying to do CT in agda ;)
12:16:39 <copumpkin> lol
12:16:50 <jmcarthur> shapr: they are kind of different things. STM would be for concurrency. par and strategies would be for parallelism
12:16:54 <applicative> edwardk, i blame the machine
12:17:05 <edwardk> actually i don't have a desktop with more than 12gigs of ram atm
12:17:08 <jmcarthur> shapr: since your problem statement was to take advantage of multicore, my leaning is toward parallelism though
12:17:16 <edwardk> you might try renting a large instance on amazon
12:17:18 <jonrafkind> what is bnfc, is that a haskell program?
12:17:21 <edwardk> worked for jaffacake ;)
12:17:24 <jonrafkind> bnf-compiler?
12:17:39 <shapr> jmcarthur: Is there a compare and contrast for stm and par/strat?
12:17:47 <shapr> I don't know anything about par/strat.
12:17:48 <applicative> edwardk, i have 4 gigs, but so far i've done peano numbers and a few other things in agda!
12:17:49 <jmcarthur> shapr: but if your problem really does boil down to something pure, STM is probably inappropriate by definition
12:17:52 <monochrom> bnf = backus-naur form? grammar?
12:18:11 <edwardk> applicative: 4 gigs to be able to do some basic counting.. that is efficiency for ya ;)
12:18:22 <jmcarthur> shapr: i doubt there are any direct comparisons because they are so different
12:18:26 <kmc> shapr, they solve different problems.  STM is for executing actions with concurrent semantics.  par allows you to do regular pure Haskell evaluation (no concurrent semantics) on multiple cores
12:18:27 <applicative> edwardk, yes, it's the principle!
12:18:31 <kmc> concurrency vs. parallelism
12:18:40 <applicative> soon there will be agda compilers on cellphones
12:18:58 <monochrom> yeah, when cellphones have 128 GB of RAM
12:19:00 <edwardk> applicative: i'm sure shapr has tried ;)
12:19:02 <applicative> what with the new agda webframework, the sky's the limit
12:19:15 <jmcarthur> applicative: agda web framework?
12:19:25 <applicative> in addition to the peano num, i installed the Lemmimachine
12:19:30 <jmcarthur> i'm working on a web app and this idea scares me
12:19:30 <ray> my droid 48 has only 64GB of RAM
12:19:52 <applicative> jmcarthur, check it out.  http://github.com/larrytheliquid/Lemmachine
12:20:20 <edwardk> ray: that would be fairly impressive ;)
12:20:41 <copumpkin> yeah, he's got to be one of two people who have ever compiled/run agda code
12:20:41 <Saizan> 3GB are almost enough to load all of the stdlib on a 64bit machine :P
12:20:50 <applicative> the ancillary documentation is very amusing.  he started with ruby, imbibed its 'culture of testing'.  then skipped haskell and went straight to agda for total correctness
12:20:57 <jmcarthur> copumpkin: i must be the other then...
12:20:57 <ray> i have the protein folding live wallpaper
12:21:02 <copumpkin> jmcarthur: fine, three
12:21:09 <applicative> he gave a speech to fellow rubyizers, in which he suggest they give up ruby for agda
12:21:17 <jmcarthur> applicative: !
12:21:21 <ray> that must have gone over well
12:21:22 <applicative> it was an awesome work of madness, i aspire to his condition!
12:21:24 <jmcarthur> i think he targetted the wrong audience
12:21:45 <ray> ruby users are a bunch of flamehappy flaming flamers
12:21:53 <ray> or at least that's the impression i get
12:22:01 <applicative> i think he was a notable among them, so it was like the pope converting to islam.  I think he's in scotland.
12:22:20 <jmcarthur> shapr: http://www.haskell.org/~simonmar/papers/strategies.pdf  <-- pretty good intro to strategies
12:22:32 <jmcarthur> shapr: also don't forget the existence of DPH!
12:22:45 <jmcarthur> although it still has a ways to go (as always)
12:22:45 <shapr> Yeah, I like DPH
12:22:59 <jonrafkind> gentoo has 6.12.3, all i needed was the ~x86 keyword
12:24:00 <monochrom> no, it was like St. Augustus converting to skepticism
12:24:00 <Nick> sinusoid234
12:24:36 <applicative> monochrom, right
12:25:32 <monochrom> interesting journey
12:25:45 <Mitar> why is threaded ignored by ghci?
12:26:01 <monochrom> did he start programming in ruby? no prior programming hobby?
12:26:43 <copumpkin> you talking about larrytheliquid?
12:27:27 <Saizan> Mitar: ghci always uses the threaded runtime 
12:27:52 <jmcarthur> i want to do that. become a god among men in some language community and then completely convert to something else, dragging people along with me
12:27:57 <monochrom> yeah, larrytheliquid
12:28:33 <jmcarthur> beats what _why did, i guess
12:28:36 <int80_h> http://www.hpaste.org/fastcgi/hpaste.fcgi/view?id=29641#a29641
12:29:08 <Saizan> int80_h: seen my messages about Loader above?
12:29:42 <monochrom> if you have the EQ, you can go become a god in the java community too. you need the EQ to tolerate java long enough until you are famous
12:30:07 <edwardk> jmcarthur: ahahaha
12:30:11 <edwardk> jmcarthur: good plot.
12:30:17 <edwardk> jmcarthur: but where to drag them?
12:30:26 <monochrom> haskell or agda
12:30:27 <jmcarthur> edwardk: kata, of coursew
12:30:29 <jmcarthur> *course
12:30:35 <edwardk> jmcarthur: right answer ;)
12:30:43 <monochrom> what is kata?
12:30:49 <Saizan> as implementers?:)
12:30:50 <jmcarthur> monochrom: edwardk's toy language
12:31:06 <monochrom> what is its greatness?
12:31:10 <jmcarthur> although maybe it's not a toy anymore? how's it going?
12:31:31 <jmcarthur> monochrom: edwardk should probably do the evangelism. i haven't been following it
12:31:49 <chrisdone> kata is a cool name for a language
12:31:52 * chrisdone ticks that box
12:31:54 <edwardk> hah, if we're going to have this conversation it should probably be over on #kata ;)
12:31:59 <jmcarthur> that's its best quality, chrisdone 
12:32:00 <monochrom> sounds almost japanese
12:32:02 <alecbenzer> is there a function like lookup on Maps that returns a 'v' on success and throws an error on failure, instead of returning a 'Maybe v'?
12:32:29 <jmcarthur> :t M.lookup
12:32:30 <lambdabot> forall k a. (Ord k) => k -> M.Map k a -> Maybe a
12:32:32 <chrisdone> monochrom: kata is japanese for a series of movements, usually in dance/martial arts
12:32:40 <Saizan> alecbenzer: compose with fromMaybe 
12:32:40 <jmcarthur> :t (M.!) -- maybe?
12:32:41 <lambdabot> forall k a. (Ord k) => M.Map k a -> k -> a
12:32:43 <jmcarthur> there is it
12:32:50 <jmcarthur> *it is
12:32:59 <Saizan> oh, right :)
12:33:06 <applicative> copumpkin  i brought up larrytheliquid
12:33:29 <copumpkin> applicative: aha
12:33:30 <applicative> thinking, soon we will have agda compilers for the iphone
12:33:45 <applicative> what with his webframework
12:33:53 <int80_h> Saizan: oops I did not. I will scroll
12:33:55 <applicative> i tried it, not quite snap...
12:34:23 <copumpkin> applicative: :P I actually really want agda on my ipad
12:34:27 <copumpkin> but no way with 256MB of ram
12:34:35 <copumpkin> the iphone4 has 512 though
12:34:40 <monochrom> yeah you need 256GB :)
12:34:42 <copumpkin> might start approaching usable agda range
12:34:45 <copumpkin> lol
12:34:55 <applicative> then the sky's the limit.
12:35:01 <monochrom> new ipod touch may have same amount of ram as iphone4
12:35:19 <applicative> of course, the agda compiler should be rewritten in c. this haskell dependency is nonsense :)
12:35:23 <alecbenzer> Saizan, ah, thx, I had written that myself, didn't know it existed
12:35:50 <Saizan> alecbenzer: seen jmcarthur's suggesting (M.!)?
12:35:55 <edwardk> monochrom:: the short short version is that it is an untyped haskell like language, which, due to the lack of traditional HM types has to rederive the functionality lost by giving up typeclasses using novel techniques
12:35:59 <monochrom> is agda self-compiling yet? :)
12:36:23 <copumpkin> monochrom: lol, no
12:36:28 <monochrom> aw
12:36:34 <copumpkin> three people compile it at all
12:36:45 <applicative> i cant seem to find larrytheliquid's argument that ruby people, in view of their principled approach to testing and correctness, must go over now to agda. ruby was merely a temporary stopping point for the correctness crowd.  we can do better, etc.
12:37:26 <applicative> his madness inspired me
12:37:31 <copumpkin> applicative: you could ask him
12:37:33 <copumpkin> he's in #epigram now
12:37:36 <copumpkin> or #agda
12:37:38 <int80_h> Saizan, could we talk about what data Loader = forall a. Loader (ProgramName a) ([String] -> a)
12:37:40 <applicative> oh of course
12:37:42 <monochrom> I can guess the argument. lim n->oo (n tests) = proof
12:37:46 <jonrafkind> in what sense is ruby correct about anything
12:37:46 <int80_h> about what the above means?
12:38:06 <shapr> Wait, who converted from Ruby to Agda?
12:38:17 <monochrom> also, lim n->oo (n test cases) = formal specification
12:38:18 <copumpkin> larrytheliquid!
12:38:22 <copumpkin> he still works at engineyard I think
12:38:36 <shapr> I like Agda
12:38:39 <shapr> It's way nifty.
12:38:47 <lispy1> shapr: !!
12:38:50 <lispy1> shapr: hi
12:38:52 <applicative> seems larrytheliquid is asleep on #agda
12:39:02 <chrisdone> the inventor of ruby admits he wrote ruby because he is too stupid to understand haskell or lisp
12:39:07 * lispy1 has been meaning to use agda more
12:39:14 <Saizan> int80_h: maybe it makes more sense with gadt syntax, data Loader where Loader :: ProgramName a -> ([String] -> a) -> Loader
12:39:21 <shapr> lispy1: Hiya! Where's your older brother lispy0 ?
12:39:35 * applicative has been meaning to use agda more.  one week away and he forgets all the keybindings
12:39:36 <chrisdone> shapr: making out with your mom!
12:39:45 <shapr> :-P
12:39:47 * chrisdone hands his head in shame
12:39:53 <Saizan> int80_h: it's essentially a pair, but the interesting thing is that the value you use for the first field determines the type of the second field
12:39:57 <applicative> i'm sure that is a very laudable enterprise
12:40:01 <lispy1> shapr: As per the standard with mpd, I don't acknowledge the existence of my other personalities!
12:40:09 <shapr> hah
12:40:30 <copumpkin> anyway, it's loads of fun
12:40:33 <copumpkin> more people should try it
12:40:45 <Saizan> int80_h: so while it is an existential type and so you superficially forget what the actual 'a' was when you construct a loader, by pattern matching in the ProgramName you can recover that information
12:41:07 <applicative> it is, its wonderful, just the first few steps of agda and i had a much better understanding of some of the fancier type nonsense in haskell
12:41:11 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/26350/
12:41:24 <int80_h> Saizan, okay now I think I have somewhere to go with this!
12:41:42 <int80_h> Saizan, or at least be able to write something that breaks. Which is more progress than I have been able to do so far.
12:41:53 <Saizan> int80_h: heh :)
12:42:33 <lispy1> c_wraith: I think I figured out how to implement the cons cells of my external list.
12:42:52 <lispy1> c_wraith: I'm going to try using UUIDs (generated from random bits) for the cons cells and then give them mutable pointers
12:43:05 <sinusoid234> @type 2
12:43:06 <lambdabot> forall t. (Num t) => t
12:43:07 <lispy1> c_wraith: that way I don't have to rebuild the lists from scratch when I update elements
12:43:22 <sinusoid234> huh
12:43:26 <sinusoid234> sry bout that
12:43:31 <lispy1> sinusoid234: no worries
12:43:43 <lispy1> sinusoid234: Do you know what that type signature means?
12:43:57 <sinusoid234> yeah
12:44:06 <sinusoid234> just trying test out the lambdabot
12:44:22 <sinusoid234> oh
12:44:24 <lispy1> sinusoid234: there is a shorthand for it too
12:44:26 <lispy1> :t 1
12:44:27 <lambdabot> forall t. (Num t) => t
12:44:48 <lispy1> Although, the short hand doesn't work in private
12:44:57 <lispy1> Not sure why that bug still exists...
12:45:25 <sinusoid234> yeah, thats kinda strange
12:46:27 <int80_h> lispy1, hiya
12:46:51 <lispy1> int80_h: yo!
12:46:52 * hackagebot web-encodings 0.3.0.1 - Encapsulate multiple web encoding in a single package.  http://hackage.haskell.org/package/web-encodings-0.3.0.1 (MichaelSnoyman)
12:47:28 <int80_h> Snoyman is at it again, I'm a fan of his work.
12:47:54 <lispy1> Snoyman, cool name
12:48:11 <lispy1> int80_h: Do you like the new takusen main page?
12:49:43 <frerich_> Hi all; I'm currently learning Haskell and while doing so, I tried to write an efficient function which determines whether a given list is a palindrome. I quickly had a simple check (ispalindrome xs = xs == reverse xs) working but since I feared that it might be too inefficient, I attempted a more complex solution: http://pastebin.com/NiKdPhx6
12:49:57 <int80_h> lispy1: that was some good work!
12:50:11 <frerich_> What I'd be interested in is whether there are better solutions, and whether there are style issues with my code. For instance, I can't remember having every seen verbose function arguments like 'leftlen' or so :}
12:50:34 <int80_h> lispy1: the best I can do is steal someone else's design.
12:52:06 <lispy1> int80_h: the current page was heavily inspired by another project page :)
12:52:21 <lispy1> int80_h: the important part is that it looks nice now and it's valid HTML :)
12:53:01 <kmc> frerich_, verbose arg names aren't necessarily bad
12:53:04 <kmc> they do take up space
12:53:08 <kmc> in this case i think it's nice and clear
12:53:43 <kmc> i'm not sure how this works and i don't think it'll be any faster
12:53:53 <int80_h> lsipy1, my naive hope is that this tutorial is available for review next week.
12:53:57 <kmc> each time you do (left++[x]) you have to walk to the end of the "left" list one element at a time, copying the spine of that list as you go
12:54:24 <kmc> i think those traversals will add up to far more than the one "reverse", which is sort of inevitable -- you have to get to the end of the list before you can start comparing to the beginning
12:54:28 <frerich_> kmc: that's true; that's what worries me, too. I couldn't find an idiom for copying a list as I go
12:54:46 <kmc> frerich_, we almost never explicitly copy data in Haskell
12:54:55 <kmc> because it's immutable
12:54:59 <frerich_> hm
12:55:11 <kmc> you just define new data in terms of old, and if you do it right, sometimes part of it is shared with the old data in memory
12:55:13 <tommd> frerich_: By and large the Haskell community considers premature optimization (what you are doing) an evil.  Particularly when lacking real performance requirements.
12:55:19 <monochrom> here is the idiom to copy a list: y=x
12:55:29 <kmc> s/Haskell community/programming community/
12:55:31 <tommd> frerich_: If you are concerned about performance then use bytestrings so you can get to the end of the list really fast.
12:55:34 <frerich_> tommd: Well my experience is that this is true in any engineering discipline ;-)
12:55:36 <tommd> then comparing is trivial
12:55:41 <frerich_> tommd: I'm just learning Haskell, so I'm playing around
12:55:46 <djahandarie> It isn't premature if you feel like doing it
12:55:53 <kmc> frerich_, did you profile / benchmark the two solutions?
12:56:02 <monochrom> I can give my definition of "premature" if you want.
12:56:14 <tommd> frerich_: See the bytestring package - that is what you want wrt performance.
12:56:40 <kmc> frerich_, if you have a list xs, the list (x:xs) will share most of its storage in memory with the list xs.  but it's not observably different from making a copy of xs and then sticking x on the beginning
12:56:49 <frerich_> kmc: No, not yet. I have a chapter about profiling Haskell programs (but I'd like to postpone it for now). I couldn't find a simple way to 'time' the runtime of Haskell programs on Windows.
12:57:05 <kmc> frerich_, myprogram.exe +RTS -s
12:57:07 <Mitar> how can i wait for thread to finish?
12:57:07 <kmc> might work
12:57:26 <kmc> Mitar, make it write to a Chan or an MVar, and block reading that
12:57:46 <kmc> Mitar, here's my little example: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29642#a29642
12:57:48 <tommd> frerich_: Criterion is the benchmarking library of choice for Haskell
12:57:56 <djahandarie> Man I swear there needs to be a better way to handle concurrency
12:58:00 <tommd> @hoogle Control.Concurrent
12:58:01 <lambdabot> module Control.Concurrent
12:58:05 <jmcarthur> djahandarie: better than what?
12:58:16 <Mitar> thanks
12:58:20 <jmcarthur> chan and mvar?
12:58:26 <jmcarthur> there's STM, of course
12:58:32 <djahandarie> jmcarthur, better than forkIO
12:58:35 <jmcarthur> and also FRP, for whatever state it's in
12:59:25 <djahandarie> Is there a non-arrow implementation of FRP for Haskell anywhere?
12:59:27 <jmcarthur> yeah FRP would be something without forkIO in its interface, preferably
12:59:33 <jmcarthur> there are a few, but not so great
12:59:45 <jmcarthur> djahandarie: Reactive is a reasonable one, but with some semantic and implementation bugs
13:00:21 <tommd> having sat next to two people trying to use reactive, I'd say the bugs make it a package to avoid.  Note I haven't used reactive myself for anything.
13:00:38 <jmcarthur> i've written my own implementations of reactive, and variations on its semantics
13:00:51 <djahandarie> What is the blockade to fixing the bugs? Theoretical issues?
13:00:52 <jmcarthur> i would also stay away from Reactive for anything serious, but it's great for learning about FRP in general
13:01:06 <jmcarthur> the main problem is some semantic bugs
13:01:13 <jmcarthur> for example, the Event monad break the monad laws
13:01:18 <djahandarie> lol
13:01:48 <jmcarthur> there are also one or two space leaks if you use it in subtley wrong ways, iirc
13:01:55 <djahandarie> Can't we enforce the monad laws on the type level? :)
13:02:01 <Ke> is there really no easy to use FilePath -> IO CheckSum libraries
13:02:05 <kmc> in Agda sure
13:02:06 <jmcarthur> in agda we could :)
13:02:08 <Ke> *are
13:02:16 <kmc> Ke, ?
13:02:26 <djahandarie> How about with multi-param type classes and fun deps?
13:02:27 <tommd> Ke: I still don't understand
13:02:37 <Ke> Still?
13:02:48 <tommd> "not easy to use"
13:02:54 <tommd> "no easy to use" ?
13:02:55 <copumpkin> djahandarie: no
13:03:27 <tommd> humm, my brain missed the "libraries" word at the end and thought of it as a type sig -sorry
13:03:38 <Ke> there doesn't seem to be any easy to use checksum libraries for haskell
13:03:42 <djahandarie> copumpkin, they can emulate dependent types to some level, where do they fall short for enforcing monad laws?
13:03:44 <kmc> ah
13:03:46 <kmc> i see
13:03:51 <alecbenzer> is it not possible to pattern match against Map.empty like you can with []?
13:03:52 <tommd> Ke: Why do you not like "liftM checksum readFile"
13:04:08 <kmc> alecbenzer, not directly -- Map is an abstract type
13:04:12 <lispy1> alecbenzer: you could use view patterns, but no you can't pattern match it
13:04:13 <kmc> meaning it exports no constructor
13:04:15 <Ke> tommd: does it work for huge files?
13:04:15 <copumpkin> djahandarie: they can?
13:04:20 <copumpkin> djahandarie: GADTs come closest 
13:04:22 <kmc> but you could use guards or view patterns
13:04:25 <tommd> Ke: yes, use Data.ByteString.Lazy
13:04:36 <Ke> ok
13:04:39 <kmc> f m | null m = ...
13:04:41 <lispy1> alecbenzer: http://hackage.haskell.org/trac/ghc/wiki/ViewPatterns
13:04:47 <kmc> f (null -> True) = ...
13:04:52 <copumpkin> djahandarie: but the issue with monads is that they're polymorphic
13:04:53 <kmc> the latter requires the ViewPatterns extension
13:04:58 <tommd> Ke: Do you actually want a Hash or are really fine with a checksum?
13:05:26 <tommd> Hashes has the better interface right now - the only checksum library is 'digest', I think, and it isn't very high level.
13:05:34 <tommd> s/has/have/
13:05:36 <copumpkin> djahandarie: you could probably prove something about Maybe () :)
13:05:51 <copumpkin> djahandarie: well, something that looks like it
13:06:06 <copumpkin> djahandarie: and assume by parametricity that it holds for other things in the same monad
13:07:14 <djahandarie> Oh whoops
13:07:23 <djahandarie> I meant GADTs
13:07:28 <djahandarie> And okay
13:07:55 <frerich_> kmc: Fun stuff, thanks for pointing out +RTS -s; unfortunately, as it is, my solution is worse than the simplistic version in about every aspect you can think of (except pride of the author, maybe)
13:08:46 <Ke> tommd: not sure, if it is relevant here
13:11:59 * hackagebot explicit-iomodes 0.5 - File handles with explicit IOModes  http://hackage.haskell.org/package/explicit-iomodes-0.5 (BasVanDijk)
13:12:01 * hackagebot explicit-iomodes-text 0.1.0.1 - Extends explicit-iomodes with Text operations  http://hackage.haskell.org/package/explicit-iomodes-text-0.1.0.1 (BasVanDijk)
13:12:03 * hackagebot explicit-iomodes-bytestring 0.1.0.1 - Extends explicit-iomodes with ByteString operations  http://hackage.haskell.org/package/explicit-iomodes-bytestring-0.1.0.1 (BasVanDijk)
13:12:05 * hackagebot regions-monadstf 0.3.1.3 - Monads-tf instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadstf-0.3.1.3 (BasVanDijk)
13:12:39 <djahandarie> copumpkin, is this already done somewhere in Agda so I can look?
13:12:56 <copumpkin> djahandarie: not really, because it's rather in agda too
13:13:10 <copumpkin> but people (including me) are working on a category theory package for agda
13:13:22 <copumpkin> but they wanted to build monads from adjunctions and the adjunctions module isn't done yet
13:13:26 <acowley> Anyone have any tips for debugging why a rewrite rule isn't firing?
13:13:46 <djahandarie> copumpkin, it's rather in agda? Huh?
13:13:56 <copumpkin> djahandarie: the main issue for monads Ã  la haskell is that we need extensional equality of functions, which is a tough issue
13:13:59 * hackagebot regions-monadsfd 0.3.1.3 - Monads-fd instances for the RegionT monad transformer  http://hackage.haskell.org/package/regions-monadsfd-0.3.1.3 (BasVanDijk)
13:14:00 <copumpkin> rather ugly
13:14:02 * hackagebot regions 0.7 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.7 (BasVanDijk)
13:14:03 <copumpkin> sorry
13:14:03 * hackagebot safer-file-handles-bytestring 0.1.0.1 - Extends safer-file-handles with ByteString operations  http://hackage.haskell.org/package/safer-file-handles-bytestring-0.1.0.1 (BasVanDijk)
13:14:06 * hackagebot safer-file-handles 0.7 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.7 (BasVanDijk)
13:14:08 * hackagebot safer-file-handles-text 0.1.0.1 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.1.0.1 (BasVanDijk)
13:14:09 <djahandarie> Ah okay
13:14:17 <djahandarie> And damn this guy is uploading a bunch of packages
13:14:36 <tommd> Looks to be Oleg SafeHandle related
13:14:36 <djahandarie> Gracenotes, bulk upload? ;)
13:14:37 <copumpkin> djahandarie: epigram 2 would allow us to prove the properties without jumping through too many hoops
13:14:42 <copumpkin> we can do it in agda, but it's just uglier
13:15:10 * hackagebot regional-pointers 0.3 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.3 (BasVanDijk)
13:15:12 * hackagebot usb 0.5.0.1 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.5.0.1 (BasVanDijk)
13:15:14 * hackagebot usb-enumerator 0.1.0.1 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.1.0.1 (BasVanDijk)
13:15:16 * hackagebot usb-safe 0.9 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.9 (BasVanDijk)
13:15:25 <Gracenotes> djahandarie: for hackagebot, you mean? :~
13:15:43 <copumpkin> you either go through a setoid or write specific monad laws for a single category of functions
13:16:33 <jmcarthur> woot new regions package
13:18:18 <frerich_> kmc: Ha! With just a small change, I was able to change my program so that it outperforms the simple version in both runtime as well as 'bytes copied during GC'. However, it's worse in 'bytes allocated on the heap'. Whatever that means. http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29643#a29643 
13:18:53 <frerich_> kmc: I can avoid the left++[x] construction by just using x:left, which effectively reverses the left half (which I would have done with the right half otherwise, using a reverse call)
13:20:57 <chrisdone> /home/chris/Projects/me/amelie/src/Main.hs:307:38: Error: Redundant id
13:20:57 <chrisdone> Found:
13:20:58 <chrisdone>   A.id "created"
13:20:58 <chrisdone> Why not:
13:21:00 <chrisdone>   "created"
13:21:04 * chrisdone spanks hlint
13:21:06 <chrisdone> bad!
13:21:18 <frerich_> kmc: And by reordering the guards slightly (so that the common case, rightlen - leftlen > 1, comes first), the performance is improved even more so that this version is 25% faster than 'x == reverse x'
13:22:01 <kmc> cool :)
13:23:11 <kmc> oh, hmm
13:23:19 <kmc> it should have been obvious to me that Â«xs == reverse xsÂ» is suboptimal
13:23:23 <kmc> because it duplicates every comparison :)
13:23:26 <frerich_> Yes
13:23:56 <frerich_> Is there a common Haskell naming scheme for separating a function f from the recursion step (I always called it 'f_recursion' so far)?
13:24:06 <frerich_> The recursion function usually takes more arguments.
13:24:11 <kmc> frerich_, common to define the latter in a "where" block
13:24:16 <kmc> and call it something like "go"
13:24:24 <frerich_> Ah, cool idea, a local function
13:24:49 <Martty> prime
13:24:50 <kmc> and if there's an argument that doesn't change between the recursive calls
13:25:04 <kmc> then you don't need to repeat it in the "go" function
13:25:09 <kmc> it'll be in scope from the outer one
13:25:23 <kmc> that's the "static argument transformation" and it can improve performance
13:26:18 <aristid> what's the syntax for bijective fundeps again?
13:26:36 <Saizan> aristid: specify both directions
13:26:41 <monochrom> is it "a<->b"? or must you write "a->b, b->a"?
13:26:41 <Saizan> | a -> b , b <- a
13:27:14 <c_wraith> what?
13:27:22 <aristid> Saizan: thanks, the "," is what i did wrong
13:30:14 <aristid> bijective fundeps are a nice feature.
13:32:24 <Saizan> yup, i wish they composed better though
13:36:14 <mosowski> hi, i'm quite new to haskell. i'm writing simple 2d game module based on Hopengl and i have to manage a state. what should i do to "hide" state in game "loop" function? What is the best way to manage a game state in Haskell?
13:37:23 <jmcarthur> @let isPalindrome = all (uncurry (==)) . uncurry zip <<< id &&& uncurry take . first (`div` 2) . foldl (flip $ (succ ***) . (:)) (0, [])  -- frerich_: the obvious solution
13:37:24 <lambdabot>  Defined.
13:37:30 <Cale> mosowski: There are a few options. Since you'll be in IO anyway, you could just use an IORef.
13:37:32 <jmcarthur> frerich_: but i jest
13:37:44 <Cale> mosowski: Another common option is to put the state into function parameters.
13:37:57 <jmcarthur> > isPalindrome "abcdedcba"
13:37:58 <lambdabot>   True
13:38:00 <jmcarthur> > isPalindrome "abcdedcb"
13:38:01 <lambdabot>   False
13:38:03 <Cale> (that is, make the loop a function of the current state, and have it call itself with an updated state)
13:38:12 <Philippa> I'd run with the latter, it's nice for isolating components of your state
13:38:15 <mosowski> Cale: should i use monad transformer? treat my state as a monad and "glue" it with IO?
13:38:31 <Cale> I tend to shy away from transforming the IO monad
13:38:34 <Philippa> you can do, that gets you the same effect as passing manually
13:38:37 <Cale> But you could indeed do that
13:39:00 <Philippa> transforming IO's mildly painful because IO functions need lifting, but that's the only major reason to avoid it
13:39:46 <Cale> Well, that, and the fact that IO already has everything but the kitchen sink (kitchen sink = continuations?).
13:39:52 <jmcarthur> for IO i'm kind of a fan of the MonadPrompt style of transforming
13:40:06 <jmcarthur> because you can carefully limit the effects you are allowed to perform
13:40:11 <jmcarthur> and you can also write different backends for it
13:40:14 <mosowski> monadprompt?
13:40:32 <jmcarthur> i don't think i would recommend it for somebody unused to transformers, mosowski 
13:41:30 <jmcarthur> mosowski: but here is it if you still want to check it out http://hackage.haskell.org/package/MonadPrompt
13:42:06 <monochrom> would be krad if IO had continuations too.
13:42:21 <Cale> MonadPrompt is cool, but it's not something I'd recommend to a beginner. It basically lets you construct monads built in terms of an arbitrary datatype representing your primitive computations abstractly. You can then plug in implementations of those operations separately.
13:42:24 <monochrom> I guess DelContT IO sufficies
13:43:04 <Cale> IO with continuations + ability to save arbitrary IO actions to disk as executable files.
13:43:21 <Cale> (would be cool)
13:43:49 <monochrom> that is scary
13:44:04 <monochrom> that is how many 1980 FPL compilers did it
13:44:44 <Cale> I would have been surprised to have thought of it first :)
13:45:19 <mosowski> i've heard FRP is a good concept for managing real time simulations
13:45:25 <jmcarthur> in theory
13:45:35 <Cale> mosowski: If only someone knew how to do it :)
13:45:58 <monochrom> compile "source_file" = readFile "source_file" >> source_to_thunks >> save_process_state "source_file.exe"
13:46:08 <Cale> Well, that's a bit glib, you can make fragments of it work in specific situations, but the overall concept hasn't been perfected to any degree.
13:46:14 <jmcarthur> sufficiently smart compilers are also pretty cool, i hear
13:46:30 <acowley> Will instantiation of a polymorphic function at concrete types in Core stop a rewrite rule from firing?
13:46:49 <mosowski> so arrows are no use in realtime?
13:47:03 <jmcarthur> mosowski: arrows and frp are different things
13:47:23 <Mitar> how can i convert handle to fd?
13:47:26 <mosowski> yes, but i've seen frp implementation based on arrows
13:47:37 <jmcarthur> yeah, but that's not all arrows are good for
13:47:55 <jmcarthur> and frp is not the only possible arrow-based approach to real time simulations, i imagine
13:47:58 <Cale> mosowski: The arrow implementations of FRP have been the most practically-successful ones in Haskell so far.
13:48:09 <jmcarthur> Cale: and the ugliest :(
13:48:12 <Cale> mosowski: But we don't really want to have to encode our computations in that style
13:48:16 <Cale> jmcarthur: agreed
13:48:28 <djahandarie> What would be a better model for FRP?
13:48:42 <jmcarthur> djahandarie: that is precisely the question that nobody can answer yet
13:48:46 <jmcarthur> if you mean semantics
13:48:52 <djahandarie> Yes I mean semantics
13:49:13 <Cale> djahandarie: I'd like to use something like Conal Elliott's Reactive, except that it doesn't work (yet)
13:49:26 <jmcarthur> Cale: reactive is fundamentally flawed, IMO
13:49:55 <aristid> @where reactive
13:49:56 <lambdabot> I know nothing about reactive.
13:50:05 <djahandarie> @hackage reactive
13:50:05 <lambdabot> http://hackage.haskell.org/package/reactive
13:50:08 <jmcarthur> djahandarie: my current leaning, along with a few others who are researching it, is that a nice model would be something that doesn't allow access to the past or future, but gives some sort of ability to accumulate over time
13:50:24 <jmcarthur> like a generalized form of integration
13:50:38 <djahandarie> A generalized form of integration?
13:51:00 <frerich_> jmcarthur: Well your solution doesn't seem too obvious to somebody like me who picked up his first Haskell book two days ago :-) it seems like a good example to dissect and benchmark tho
13:51:04 <jmcarthur> yeah, something that not only could do normal integration, but could also perform other sorts of accumulation (e.g. summing the values of events over time)
13:51:15 <jmcarthur> frerich_: it's not a readable solution
13:51:25 <jmcarthur> frerich_: i was just golfing and trying to be somewhat efficient at the same time
13:51:47 <jmcarthur> it's funny that i consider something golfing and yet i still leave in whitespace and stuff
13:52:37 <frerich_> jmcarthur: I can only paste it into gvim at this point and pray that ghc won't complain, because fixing it is like hex-editing a ZIP file in the hope of fixing a broken archive. :-}
13:52:52 <jmcarthur> frerich_: it will require at least Control.Arrow
13:53:44 <mosowski> could you tell me guys a good way to familiarize myselft with monad transformers?
13:53:54 <Cale> isPalindrome xs = xs == reverse xs  -- ;)
13:54:05 <jmcarthur> Cale: yeah that was the trivial version he pasted earlier
13:54:06 <Mitar> jmcarthur do you have some site where i could see what are you doing in this area?
13:54:19 <frerich_> Cale: that's the trivial (and inefficient) solution I came up with first, too :)
13:54:23 <jmcarthur> Mitar: no i don't. it's just one of my many toy projects
13:54:41 <jmcarthur> it's not that inefficient frerich_ 
13:54:46 <Mitar> what about researches you mentioned working on this? you had any particular in mind?
13:54:53 <Cale> frerich: It's only a little bit inefficient though. Asymptotically it's optimal, but there's a not-so-great constant factor.
13:54:57 <jmcarthur> it could be improved sure, but it's still just a constant factor worse than a more efficient version
13:55:21 <Martty> the more efficient version is written in C, obviously
13:55:32 <jmcarthur> Mitar: just people that have blogged about it, not really formal projects
13:55:43 <jmcarthur> Mitar: conal elliot and... sinelaw (forgot his name)
13:55:49 <Mitar> aha
13:55:55 <Cale> Also, note that for non-palindromes, it will stop checking as soon as it finds a flaw.
13:56:05 <Mitar> because i am also doing some things in this field currently ;-)
13:56:07 <Mitar> playing around ;-)
13:56:12 <frerich_> Cale: good point
13:56:14 <jmcarthur> Mitar: ah
13:56:29 <jmcarthur> Mitar: sinelaw has a few good writeups about his ideas, and i'm sure he would love to discuss it next time you see him online
13:56:42 <frerich_> Cale: however, it also needs to reverse the complete list before doing a single comparison
13:56:43 <jmcarthur> Mitar: conal has been busy with other projects lately i think
13:56:56 <jmcarthur> frerich_: not fully
13:57:15 <jmcarthur> frerich_: it does have to traverse to the end first, but any algorithm would have to do that
13:57:16 <Mitar> do you have any link for sinelaw?
13:57:49 <jmcarthur> Mitar: http://noamlewis.wordpress.com/
13:58:00 <Mitar> thans
13:58:03 <Martty> not if it used a doubly linked list and stored the last elems addy O_o
13:58:11 <Cale> frerich: It just has to find the first element of the reverse, which means walking to the end, necessarily.
13:58:38 <Cale> @let half xs = zipWith const xs (takeWhile (not . null) . iterate (drop 2) $ xs)
13:58:39 <lambdabot>  Defined.
13:58:57 <Martty> is there such list with such implementation in the std lib?
13:59:13 <Martty> e.. a list*
13:59:50 <Cale> > let isPalindrome xs = and (zipWith (==) (half xs) (reverse xs)) in isPalindrome "amanaplanacanalpanama"
13:59:51 <lambdabot>   True
14:00:22 <Cale> ^^ how to go out of one's way to avoid length :)
14:00:39 <Cale> > half [0..]
14:00:40 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
14:00:55 <Cale> Apparently half an infinite list is still infinite ;)
14:01:00 <djahandarie> > half [1..20]
14:01:01 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
14:01:39 <c_wraith> What's the name of the extension for data types with 0 constructors?
14:01:46 <Cale> This does perhaps one more test than is required
14:01:46 <c_wraith> EmptyDataDecls or something?
14:01:49 <acowley> EmptyDataDecls
14:01:55 <c_wraith> thanks, acowley 
14:01:57 <frerich_> Cale: Neat, thanks for the 'half' function. I recently tried to do something like that myself, but it was really clumsy. I have no hopes of grok'ing your version but I will save it in my file of little things to dissect once I know more :)
14:02:11 <Cale> frerich: It's not hard to understand in pieces
14:02:12 <malorie> > half [1..21]
14:02:13 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11]
14:02:26 <Cale> > iterate (drop 2) [1..10]
14:02:27 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10],[3,4,5,6,7,8,9,10],[5,6,7,8,9,10],[7,8,9,10],[9,10]...
14:02:39 <Cale> > iterate (drop 2) [1..5]
14:02:40 <lambdabot>   [[1,2,3,4,5],[3,4,5],[5],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
14:02:52 <Cale> > takeWhile (not . null) . iterate (drop 2) $ [1..5]
14:02:54 <lambdabot>   [[1,2,3,4,5],[3,4,5],[5]]
14:03:00 <Mitar> how can i search a lib function by type?
14:03:04 <Mitar> like Handle -> Fd ;-)
14:03:14 <Cale> This is a list whose length is the ceiling of half the length of the list.
14:03:20 <Martty> Mitar: hoogle
14:03:33 <Cale> and so now all we need is a way to crop the original list to that length
14:03:49 <Cale> zip and zipWith automatically stop when either of the lists you give them stop
14:03:59 <kmc> hoogle and hayoo
14:04:07 <Cale> > zip "this sentence is longer" "short"
14:04:08 <lambdabot>   [('t','s'),('h','h'),('i','o'),('s','r'),(' ','t')]
14:04:17 <Cale> > zipWith const "this sentence is longer" "short"
14:04:18 <lambdabot>   "this "
14:04:24 <Cale> const x y = x
14:04:38 <kmc> System.Posix.IO.handleToFd :: Handle -> IO Fd
14:04:46 <frerich_> Cale: I remember zip (and zipWith) from other languages (Python has the same functionality, ven with the same names). Thanks for dissecting this, I'm currently trying it myself in ghci :)
14:04:55 <kmc> "This function has the side effect of closing the Handle and flushing its write buffer, if necessary."
14:05:27 <Mitar> why it closes the handle?
14:05:41 <Mitar> i would like to use threadWaitRead on it
14:06:10 <jmcarthur> :t all id $ zipWith (==) =<< uncurry take <<< (`div` 2) . fst . head &&& map snd <<< reverse . zip [1..]
14:06:11 <lambdabot>     Couldn't match expected type `[Bool]'
14:06:11 <lambdabot>            against inferred type `[a] -> [Bool]'
14:06:11 <lambdabot>     In the first argument of `(=<<)', namely `zipWith (==)'
14:06:16 <jmcarthur> oops
14:06:35 <tommd> Well Handle abstracts over Fd to provide some safty guarantees.  Those are bogus if you are playing around with the Fd yourself.
14:06:36 <jmcarthur> > all id $ zipWith (==) =<< uncurry take <<< (`div` 2) . fst . head &&& map snd <<< reverse . zip [1..] $ "abcdedcba"
14:06:37 <lambdabot>   True
14:06:53 <kmc> Mitar, i think the way the GHC RTS handles its handles is incompatible with most direct uses of the Fd
14:07:04 <drhodes> > iterate half [1..]
14:07:05 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
14:07:11 <Mitar> ok
14:07:23 <tolkad> Why doesn't this work? http://codepad.org/sgOJNaMq
14:07:36 <tolkad> it's not "multiply defined"
14:07:44 <frerich_> I remember seeing the 'iterate' function and wondering "When would you *ever* use this?!" :-} It's a little odd to construct things from functions which do so little. I guess it becomes easier if you know them from the top of your head, if you know your building blocks.
14:07:46 <tolkad> I only defined it for some values the first time
14:07:52 <kmc> all equations for a function must have the same number of args
14:07:53 <acowley> tolkad: g is funny
14:08:04 <tolkad> acowley: what?
14:08:05 <copumpkin> tolkad: you're just not allowed to do that
14:08:11 <copumpkin> g 2 = 3
14:08:13 <copumpkin> g x = f x
14:08:14 <kmc> in particular, you can't define something partially with a pattern-decl and partially with a function-decl
14:08:23 <acowley> golkad: what copumpkin said
14:08:27 <acowley> sorry, tolkad
14:08:33 <tolkad> but I want to
14:08:38 <Cale> frerich: absolutely
14:08:40 <tolkad> there's no reason I shouldn't be able to
14:08:50 <jmcarthur> > let power a n = iterate (*a) 1 ! n in power 2 10
14:08:51 <lambdabot>   Couldn't match expected type `GHC.Arr.Array i e'
14:08:51 <lambdabot>         against inferred t...
14:09:00 <jmcarthur> > let power a n = iterate (*a) 1 !! n in power 2 10
14:09:01 <lambdabot>   1024
14:09:08 <jmcarthur> frerich_: ^^ one example :)
14:09:20 <tolkad> is there any way to specify the codomain of a function?
14:09:21 <Cale> > map (take 2) . takeWhile (not . null) . iterate (drop 2) $ "abracadabra"
14:09:21 <lambdabot>   ["ab","ra","ca","da","br","a"]
14:09:28 <tolkad> so that GHC knows it's not being multiply defined?
14:09:32 <tolkad> then it would work
14:09:34 <kmc> that's not the issue here
14:09:37 <kmc> the issue here is syntactic
14:09:47 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 478219079120473928
14:09:49 <lambdabot>   [8,2,9,3,7,4,0,2,1,9,7,0,9,1,2,8,7,4]
14:09:56 <Cale> > reverse .map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 478219079120473928
14:09:57 <lambdabot>   [4,7,8,2,1,9,0,7,9,1,2,0,4,7,3,9,2,8]
14:10:00 <kmc> each name can be bound by a) one pattern-decl, or b) a consecutive list of function-decls with the same number of formal parameters
14:10:01 <jmcarthur> nice one Cale 
14:10:16 <kmc> you're also not allowed to do Â«f True = ...; g = ...; f False = ...Â»
14:10:32 <tolkad> kmc: I can use a consecutive list of function decls?
14:10:39 <tolkad> huh, I'll try that instead
14:10:47 <Cale> This is a common pattern. We've somewhat captured it with unfoldr, but I often feel like we should have a special name for map/takeWhile/iterate like that
14:10:52 <kmc> tolkad, yes, you haven't run into that before?
14:10:56 <Martty> bit OT, but probably the best chan to ask in: http://codepad.org/3Wxik1GM
14:11:03 <kmc> tolkad, like Â«length [] = 0; length (x:xs) = 1 + length xsÂ»
14:11:20 <tolkad> oh I guess I misunderstood the meaning of pattern-decl/function-decl
14:11:33 <kmc> Martty, it will only tail-optimize the last call to deltree
14:11:47 <kmc> for the first call it has to remember that it still needs to make the second call
14:11:58 <kmc> and in the non-commented version, it needs to remember for both calls t hat it still needs the delete
14:12:11 <monochrom> do your own CPS-transform :)
14:12:15 <tolkad> you would think "pattern-decl" would be f 0 = 1 and "function-decl" would be f = g
14:12:24 <jmcarthur> :t unfoldr
14:12:26 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:12:41 <jmcarthur> i would use that more if it was easier to write point free expressions of type (b -> Maybe (a, b))
14:12:54 <kmc> > let (Just x, y) = (Just 3, 4) in x
14:12:55 <lambdabot>   3
14:13:00 <kmc> that's a pattern decl
14:13:07 <kmc> the lhs "(Just x, y)" is a pattern
14:13:07 <Martty> kmc: neat explanation. so the commented version is definitely better?
14:13:14 <kmc> *shrug*
14:13:22 <kmc> C++ doesn't guarantee TCO anyway
14:13:25 <Martty> well, it would use half the stack space
14:13:27 <kmc> see which one happens to be better with your compiler
14:13:47 * Martty goes implement btrees in haskell
14:14:11 <monochrom> I don't see any "function-decl" in the haskell report
14:17:15 <inetic> hi, I'm beeing confused by google, are delimited continuations implemented using standard functions and data structures or are those shift/reset thingies some special language operators? or both? in case of "both", what advantages does one over the other? sorry if I sound too confused, I think I got continuations and CPS right, it's just the "delimited" keyword that I'm having problems with
14:17:54 <kmc> ah, the terms the report uses are "function binding" and "pattern binding"
14:19:48 <monochrom> inetic: you could do either. the api will look slightly different.
14:21:35 <monochrom> if built-in, you could have a function of type Int->Int and it uses continuations internally. but then you can no longer expect referential transparency from functions of type Int->Int. but then you probably didn't expect it to begin with, e.g., sml, ocaml.
14:23:05 <monochrom> if normal functions and data structures, you could only use continuations for functions of type Cont Int or Int -> Cont Int, i.e., monadic. but you get to keep your referential transparency for Int->Int.
14:23:33 <inetic> monochrom, aha, so does that mean that built-in delimited continuations are not possible in pure language (without the IO monad of course)?
14:23:44 <monochrom> right
14:23:54 <inetic> aha
14:25:56 <frerich_>  I have a hard time reading such highly compact functions (like those which Cale posted) but somehow I can't shake the feeling that it's like little Zen koans. Confusing to the uninitiated but elegant (through simplicity) for the enlightened :-)
14:26:13 <frerich_> It's fun to watch all these oneliners and try to figure out what they do, without actually running them
14:26:20 <monochrom> new slogan: "avoid succ^H^H^H^H referential opacity at all costs" :)
14:26:44 <monochrom> sometimes running them still tells you little
14:27:05 <monochrom> the solution: don't think. calculate.
14:29:06 <inetic> in my original question I had haskell in mind, so (forgive me this repeating) the conclusion is that haskell does not have built in delimited continuations. this is actually very important for me to get it right as it's only one step in undesrtanding something that I've been wresling for quite some time now (http://stackoverflow.com/questions/3436559/zipper-like-data-structure-with-more-then-one-cursor)
14:29:58 <monochrom> an example of calculation trumping thinking: http://article.gmane.org/gmane.comp.lang.haskell.cafe/23231/
14:33:30 <Paczesiowa> why does inlining depend on types?
14:36:08 <acowley> Paczesiowa: how do you mean?
14:36:30 <Paczesiowa> acowley: let p = satisfy isLetter; p2 = many p
14:37:07 <Paczesiowa> acowley: if p :: GenParser Char st Char there's no inlining, if p:: GenParser Char () Char it works
14:38:24 <acowley> Paczesiowa: I'm not sure. I'm actually really wrestling with inlining at the moment, too.
14:39:25 <Paczesiowa> there should be something like INLINECALLER f, that would inline every g = f
14:40:04 <Cale> Does an INLINE pragma change anything?
14:41:08 <Paczesiowa> Cale: g is supposed to be client code, I can't tell people to put pragmas everywhere
14:41:21 <Philippa> the 'cost' of inlining something that needs specialising/instantiating might be considered too high
14:41:25 <Cale> uh, hmm
14:41:45 <Philippa> using a pragma to specialise on () might help?
14:42:08 <acowley> Philippa: I thought he had the reverse problem
14:42:25 <acowley> Philippa: The polymorphic case isn't being inlined
14:42:25 <Paczesiowa> Cale: I wrote a parsec optimization for many (satisfy p), but it won't fire up is satisfy p is bound to another identifier that's not inlined
14:44:08 <Philippa> oh, right, p2 also has general type
14:44:43 <acowley> Paczesiowa: I think you just have to tell your clients to annotate their code.
14:44:55 <Paczesiowa> if the only downside of inlining is code bloat, shouldn't everything be inlined and after optimizations some uninliner should split the code into small blocks?
14:45:14 <monochrom> hmm, uninliner
14:45:37 <Philippa> you mean, a generaliser? That sounds suspiciously like higher-order unification, which in the general case is undecidable
14:46:05 <lodi> Hello #haskell.  Does anyone have experience using the CC-delcont package?  Or continuations in general?
14:46:23 <Paczesiowa> no, something that would e.g. detect an expression that has depth of 10 and split that into its own function.
14:46:38 <theorbtwo> I always get worried when people say that things are, in the general case, impossible/undecidable.
14:46:59 <theorbtwo> Is there a useful subset that is possible/decidable?
14:47:04 <Paczesiowa> especially if there aren't many arguments to lift
14:47:21 <Philippa> Paczesiowa: that's not the problem, the problem is you have to find duplicates
14:47:34 <Philippa> to put it another way: when you inline, you lose sharing
14:47:41 <Philippa> the loss of sharing is what bloats your code
14:48:06 <Paczesiowa> theorbtwo: I don't see any problems with such solution, only performance could suffer
14:48:31 <Philippa> well yes, that's what the problem with the bloat is too
14:48:59 <Philippa> you're not worried about the executable size so much, more the tendency to blow the cache
14:49:09 <Paczesiowa> Philippa: the problem with bloat is because the function is too big and doesn't fit into the cache, right?
14:49:24 <Philippa> no, the problem is that the set of code you're running at a given time is
14:49:28 <Philippa> the CPU doesn't know what a function is
14:49:33 <Philippa> nor does it care
14:49:57 <Philippa> it's about the total size of code being run over a period of time
14:50:21 <Philippa> if it fits within the cache all is good, if it doesn't then you need some time to shift what's in the cache
14:51:23 <Philippa> well-factored code is smaller, massively-inlined code is (barring optimisations enabled by the inlining) larger
14:54:44 * djahandarie uses phoenix down
14:56:18 <acowley> Nothing is inlined into an INLINE function. How does that interact with phase control on INLINE? Also, what is the corresponding property for NOINLINE?
14:57:35 * hackagebot yesod 0.5.0.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-0.5.0.3 (MichaelSnoyman)
14:58:43 <acowley> To be very concrete, I have a pair of rules that attempt a kind of fusion then roll back that effort if no fusion opportunity arrises. I'm having trouble getting these rules to fire properly on user code, and it seems to have to do how (or whether or not) the user code is marked with an INLINE pragma.
14:59:04 <acowley> "...seems to have to do with..."
14:59:35 * hackagebot hebrew-time 0.1.0 - Hebrew dates and prayer times.  http://hackage.haskell.org/package/hebrew-time-0.1.0 (MichaelSnoyman)
15:01:48 <hpc> well, NOINLINE means that GHC won't ever inline a particular function, which is occasionally does over the course of optimization
15:03:35 <acowley> gah this is frustrating. I found a combination of phase controls that does what I want, but it's ridiculous.
15:04:25 <acowley> hpc: right, but I'm wondering about inlining into the function in question
15:04:41 <acowley> hpc: If you have {-# INLINE f #-}, then nothing is inlined into f.
15:04:56 <acowley> hpc: If you have {-# INLINE [2] f #-} will things be inlined into f up to phase 2?
15:05:17 <acowley> hpc: Or does the pragma mean that nothing will be inlined into f, but f won't be inlined into anything else until phase 2 or later?
15:05:59 <acowley> I really hate having to put INLINE pragmas in client code.
15:08:00 <Paczesiowa> acowley: take a look at stream-fusion/vector libraries, they have a lot of inlining usage
15:08:23 <acowley> Paczesiowa: I will look again, but they don't always do what you want either.
15:08:37 <malorie> a little offtopic probably: does #haskell read the "Journal of Functional Programming"? if so, would you suggest it a beginner to read?
15:09:48 <monochrom> some people read it. not for beginner.
15:10:12 <monochrom> with some exceptions for beginners.
15:10:51 <notabel> does anyone know if hs-plugins is broken with the latest GHC/platform?  it fails to install from hackage on two ubuntu boxes with GHC 6.12.1 and 6.12.3, but does install on OS X with 6.10.4 (sorry for the fuzzy data)
15:11:19 <acowley> notabel: I believe there has been chatter on haskell-cafe to that effect, yes
15:11:22 <monochrom> which is a bit strange if you compare the growth of haskell beginners to the growth of humanity beginners
15:12:14 <Philippa> malorie: most of us don't read it directly, many of us have read at least one paper that's been published in it
15:12:33 <tommd> notabel: The 'hint' package is taking over somewhat.
15:12:34 <monochrom> although humanity beginners are given introductory books to read, once in a while they attempt grown-up books, grown-up TV... they periodically try, until one day they suddenly find that they get it.
15:12:36 <Philippa> it's an academic journal about FP research, so it's not really the thing for beginner programmers
15:12:48 <Mitar> is there some common list of difference running under ghc interpretter or compiled?
15:13:00 <malorie> monochrom, Philippa: I see.
15:13:09 <notabel> tommd: thanks, i'll take a look
15:13:13 <monochrom> they don't behave like haskell beginners' "I vow that I will not touch grown-up material until 20"
15:13:38 <Mitar> because if i compile program and run it in ghci, it works, if i run directly (interpreted) it hangs
15:13:56 <notabel> Mitar: what kind of differences are you looking for?  obviously performance characteristics differ, but the only semantic differences are extended defaulting and TH staging/reification limitations
15:13:56 <Philippa> read if you're curious, but it's not high up the priority list for a working programmer of any experience level
15:14:28 <notabel> can you put the problematic code somewhere we can look at it?
15:14:35 <Mitar> sure
15:14:41 <Mitar> i just made a test case
15:14:46 <Mitar> it is not really sort
15:14:56 <Mitar> but it self-sustained
15:14:58 <Taejo> monochrom: although I think a subscription might not be worth a beginner's money, I absolutely agree. I attended ICFP 2007, and had very little knowledge of FP at the time, but diving in the deep end was fascinating and challenging
15:15:29 * Kaidelong subscribed to print of the ICFP proceedings
15:15:38 <Kaidelong> just recently, so can't give any feedback on that
15:15:50 <malorie> Philippa: will do. (mainly because RWH suggested a paper in it covering folds in-depth, or something)
15:15:52 <Philippa> diving in the deep end definitely picks you up good stuff if you've got the confidence to not panic
15:16:09 <Philippa> malorie: yeah, if you've been recommended a specific paper That's Different too
15:16:18 <monochrom> yeah, humanity beginners don't panic, they just skip.
15:16:30 <monochrom> (and they try again next year)
15:16:43 <Philippa> right, it's harder to skip and still be coherent with FP but you can do
15:16:51 <monochrom> it's a bit strange that haskell beginners don't behave like humans.
15:16:54 <Philippa> (reading TaPL but skipping the proofs is a good example)
15:17:07 <Philippa> *cough*
15:17:10 <tommd> Lame proofs, not even mechanically verified.
15:17:26 <tommd> Now Software Foundations - that's a book you've got to follow proofs in ;-)
15:17:28 <Philippa> yeah, but also eminently skippable if you're having a slow maths day/week/month
15:17:31 <Mitar> notabel: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29648#a29648
15:17:37 <notabel> tommd: do you know if anyone has a version of hint that doesn't depend on mtl so heavily?
15:18:03 <Martty> the numeric types in haskell are such a pain for me
15:18:08 <tommd> notabel: I haven't heard of a version if it exists - but I wouldn't have heard of it either as I'm not really involved with hint.
15:18:19 <notabel> kk, thanks
15:18:23 <tommd> Martty: There is a prototype prelude (Numeric-Prelude) that fixes those.
15:18:31 <Martty> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29649#a29649
15:18:33 <tommd> not saying it helps you with your problem though.
15:18:44 <Martty> i want to understand whats going on though
15:19:14 <tommd> Oh, so simply numerical computation?
15:19:37 <Martty> indeed
15:20:45 <Martty> no instance for fractional int on line 3
15:20:45 <Mitar> any success replicating?
15:21:05 <tommd> Martty: Use `div` and not (/)
15:21:12 <Martty> O_o
15:21:15 <Martty> :t div
15:21:16 <lambdabot> forall a. (Integral a) => a -> a -> a
15:21:18 <tommd> (/) is for fractional while `div` is integer division
15:21:27 <Martty> but i dont want integer division
15:21:31 <Martty> i want real numbers
15:21:32 <tommd> Martty: If you actually want this to be floating point, not integer division, then consider "fromIntegral"
15:21:33 <Martty> everywhere
15:21:47 <Martty> i tried that but then if i pass non integers i get an error
15:21:49 <Martty> (wtf)
15:21:51 <monochrom> fromIntegral 4 / fromIntegral 5
15:22:06 <Martty> > fromIntegral 2 / fromIntegral 4
15:22:07 <lambdabot>   0.5
15:22:10 <Martty> > fromIntegral 2 / fromIntegral 4.0
15:22:11 <lambdabot>   Ambiguous type variable `t' in the constraints:
15:22:11 <lambdabot>    `GHC.Real.Integral t'
15:22:11 <lambdabot>   ...
15:22:53 <tommd> Martty: Consider genericLength instead of 'length' for a start
15:23:01 <Martty> :t length
15:23:02 <lambdabot> forall a. [a] -> Int
15:23:04 <Martty> :t genericLength
15:23:05 <lambdabot> forall b i. (Num i) => [b] -> i
15:23:08 <Martty> good 
15:23:27 <tommd> Martty: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29649#a29650
15:25:30 <Martty> thanks
15:25:40 <Martty> why isnt length genericLength instead
15:25:47 <tommd> Less efficient.
15:32:26 <fryguybob> @botsnack
15:32:27 <lambdabot> :)
15:41:07 <mathijs> Hi all, I'm toying around a bit with parsec, and I'm a bit stuck... I need to parse some text (any character) until some string is found... so basically I have "some text blah blah - 20100902" and need the part before the " - "
15:42:04 <mathijs> I tried with "many anyChar" but that doesn't stop (no lookahead I think?)
15:42:43 <monochrom> many (noneOf "- ") >> string " - "
15:43:20 <mathijs> won't the noneOf "- " disallow spaces and - in the text before it?
15:43:32 <monochrom> oh, there are spaces.
15:43:47 <monochrom> many (noneOf "-") >> string "- "
15:43:56 <mathijs> yep, and maybe - signs as well
15:44:09 <monochrom> now that's very hard
15:44:19 <revenantphx> ... parse from the right?
15:44:34 <c_wraith> It's not hard if you use a backtracking parser library.
15:44:41 <revenantphx> I'm totally new to Haskell, but my general intuition says if there can be minus signs to the left of that one, you need to parse from the back.
15:44:42 <c_wraith> Why is parsec so popular?
15:45:05 <mathijs> basically everything is allowed in the text, just when " - " is encountered, I know to proceed
15:45:27 <mathijs> parsing from the back is not gonna do the trick... further down the right there's another thing like that
15:46:04 <nkpart> @src nub
15:46:04 <lambdabot> nub = nubBy (==)
15:46:09 <nkpart> @src nubBy
15:46:09 <lambdabot> nubBy eq []             =  []
15:46:10 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
15:46:17 <c_wraith> mathijs, try a parser library that defaults to backtracking
15:46:46 <monochrom> whee = try (string " - ") <|> (anyChar >> whee)
15:47:15 <mathijs> c_wraith: like what? just regexp? I already have a regexp that does the trick, but I was trying to learn a bit of parsec
15:47:27 <c_wraith> mathijs, uu-parsinglib or polyparse
15:49:32 <mathijs> monochrom: very clever :)  seems to get further now
15:49:33 <revenantphx> One question, is importing in Haskell lazy? I noticed if I load a program into ghci, it loads and links the package only at the point it's used.
15:49:42 <revenantphx> I'm guessing this doesn't occur with compiled code though.
15:50:05 <c_wraith> revenantphx, importing doesn't actually do anything except make names available.
15:50:12 <c_wraith> No code is executed by imports
15:50:21 <monochrom> no animals are harmed
15:50:44 <revenantphx> c_wraith: I'm noticing if I have a .hs file which imports, say ByteString
15:50:49 <Saizan> imports are a compile-time thing
15:51:00 <revenantphx> c_wraith: Until I use ByteString in some way, it doesn't display this
15:51:04 <revenantphx> Loading package bytestring-0.9.1.7 ... linking ... done.
15:51:08 <Saizan> ghci being a repl blurs the line though :)
15:51:09 <c_wraith> ghci will only load packages when they're needed, yes
15:51:11 <revenantphx> Saizan: That's what I used too.
15:51:15 <c_wraith> But that's not importing.
15:51:24 <revenantphx> c_wraith: okay, got it.
15:52:16 <c_wraith> compiled code..  Well, if it's statically linked, everything's part of the compiled program.  If it's dynamically linked, I don't actually know if it links at program start up or first use.
15:54:55 * hackagebot kit 0.4 - A dependency manager for XCode (Objective-C) projects  http://hackage.haskell.org/package/kit-0.4 (NickPartridge)
15:55:06 <revenantphx> c_wraith: In C at least, dynamic linking involves loading the symbols from the shared object file (.so) at runtime.
15:55:43 <revenantphx> or .dylib on os x
15:56:01 <revenantphx> static libraries have their symbols added to the final binary at compile time.
15:56:13 <revenantphx> It seems GHC compiles to C as an intermediate?
15:56:24 <Philippa> c_wraith: parsec was the first good lib that was decently strong in the set of languages it'll parse
15:56:31 <monochrom> not always. in fact seldom.
15:56:46 <revenantphx> monochrom: explain please, I'd love to know how it works.
15:57:03 <revenantphx> I'm totally new to Haskell, started yesterday. My background is in C, Objective-C, Python and Ruby
15:57:04 <monochrom> on popular platforms, ghc now has its own asm generator
15:57:11 <revenantphx> Oh, that's nice.
15:57:41 <dmwit> ?djinn (a -> b) -> ((a -> r) -> (b -> r))
15:57:41 <lambdabot> -- f cannot be realized.
15:57:52 <Philippa> mathijs: there's a function that's something like manyUntil
15:58:02 <monochrom> on unixes it still counts on ld for linking
15:58:22 <revenantphx> monochrom: makes sense 
15:58:29 <siim> Hi. how can I concat 2 .. n files? I mean something like: concat $ map readFile ["foo","bar"]
15:58:38 <revenantphx> How is the OS X haskell relative to the other OS implementations?
15:58:54 <cch> i use threadDelay in a function SingleFunc s :: String -> IO (), and try to apply SingleFunc to a list of String, like this:  main = mapM_ SingleFunc xs. I mean to main looping over xs and deley something before looping to next element of xs
15:58:59 <revenantphx> does it use the direct to asm compiler or does it use C as a midway.
15:59:02 <cch> am i right
15:59:19 <krey_> hello, what's the difference between EitherT and ErrorT?
15:59:23 <mathijs> Philippa: ah... how did I overlook that :)   manyTill indeed, thanks
15:59:31 <monochrom> I don't know the os x story. I think I heard still through gcc.
15:59:33 <dmwit> cch: sounds good to me
15:59:42 <revenantphx> mmk
16:00:03 <dmwit> :t mapM -- siim
16:00:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
16:00:20 <revenantphx> Really
16:00:40 <revenantphx> or
16:00:44 <cch> actually it doesnot work
16:01:05 <revenantphx> cch:
16:01:08 <siim> ty, I will try out 
16:01:26 <revenantphx> cch: did you see the message?
16:01:41 <dmwit> cch: I don't suppose you are also forking? If so, only the thread that calls threadDelay actually delays, of course.
16:01:43 <cch> which one
16:01:55 <dmwit> cch: If not, then perhaps it is time for a minimal test case, plus what you expect to happen, plus what actually happens.
16:02:45 <revenantphx> cch: I'm going to say "chunky bacon" in a second
16:02:48 <revenantphx> if you see it, tell me.
16:02:48 <cch> I expect to loop over a list, and get some delay between each loop step 
16:02:56 <revenantphx> chunky
16:02:59 <revenantphx> okay I said it.
16:03:02 <cch> but got no such delay between each step
16:03:08 <monochrom> (where is the bacon?)
16:03:17 <revenantphx> :\
16:03:20 <revenantphx> didn't work
16:03:21 <revenantphx> damnit
16:03:22 <fryguybob> @where bacon
16:03:22 <lambdabot> I know nothing about bacon.
16:03:30 <monochrom> threadDelay 1000000
16:03:40 <dmwit> cch: You're still missing one of the three things I asked for.
16:03:54 <cch> revenantphx: I do not understand your words
16:04:04 <revenantphx> cch: I'm trying to inject some irc packets.
16:04:09 <revenantphx> I have my reasons.
16:04:13 <revenantphx> They aren't being seen though.
16:04:13 <monochrom> but yeah, the scientific method. how to reproduce your observation.
16:04:16 <revenantphx> Just simple PRIVMSG
16:05:18 <cch> sorry i am new to IRC
16:05:41 <int80_h> notabel, you there?
16:05:45 <revenantphx> cch: mm :\
16:05:53 <int80_h> crap just missed
16:07:57 <dmwit> ?hpaste the code you are trying, cch
16:07:57 <lambdabot> Haskell pastebin: http://moonpatio.com/fastcgi/hpaste.fcgi/
16:08:24 <dmwit> well
16:08:28 <dmwit> that's broken
16:08:32 <cch> ok
16:08:35 <dmwit> But something like codepad or nopaste or whatever.
16:11:20 <cch> i post my code on http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29656#a29656
16:11:27 <monochrom> and I thought the problem resolved itself by having no evidence
16:11:46 <dmwit> 2000 microseconds is 2ms
16:11:53 <dmwit> Are you sure you could notice that small of a delay?
16:13:13 <cch> aha 
16:13:22 <cch> what a stupid mistake
16:15:12 <cch> it works now, thank you all so much, and sorry for this mistake 
16:18:13 <int80_h> Cobra, will you just defeat G.I Joe already.
16:18:25 <revenantphx> PRIVMSG is the irc command to send a message to a person or channel
16:18:32 <revenantphx> PRIVMSG #haskell Hello world\r\n
16:18:42 <revenantphx> for example.
16:18:55 <cch> PRIVMSG #haskell Hello world
16:18:59 <cch> Hello
16:19:14 <cch> seems not work 
16:19:20 <cch> Hello world
16:19:35 <copumpkin> your client is taking care of the PRIVMSG stuff for you
16:19:50 <monochrom> This is why when someone asks me "can we take it to pm?" I answer "we're already in pm"
16:19:54 <copumpkin> if you connect to IRC using a telnet client, you'll need it
16:20:10 <copumpkin> nc irc.freenode.net 6667
16:20:21 <monochrom> /privmsg #haskell I use privmsg
16:20:22 <cch> i use erc in emacs
16:20:23 <Veinor> monochrom: you silly
16:21:12 <cch> hihi
16:21:53 <int80_h> hey!, I'm the HskNoob around these parts!
16:22:57 <cch> hi
16:29:15 <revenantphx> one question, if you have a type of Maybe b (where b is say, Num)
16:29:36 <revenantphx> can some value of type Just b be used as if it were of type b?
16:29:40 <revenantphx> or are there some restrictions?
16:31:08 <Saizan> Just doesn't belong in types
16:32:04 <revenantphx> er... correct my terminology please > <
16:32:05 <copumpkin> revenantphx: no, you can't use it
16:32:08 <Saizan> it's a data constructors that builds values of type "Maybe a" given a value of type 'a'
16:32:18 <copumpkin> the whole point of it is to prevent you from ignoring the fact that there might be nothing there
16:32:25 <revenantphx> right.
16:32:42 <copumpkin> having said that, monads help you pretend 
16:32:48 <copumpkin> or applicatives or functors :)
16:32:56 <revenantphx> I've not gotten to monads or applicatives or functors yet :P
16:33:10 <revenantphx> getting there though.
16:33:12 <Saizan> > fmap (+1) (Just 3)
16:33:13 <lambdabot>   Just 4
16:33:17 <Saizan> > fmap (+1) Nothing
16:33:18 <lambdabot>   Nothing
16:33:36 <revenantphx> is lambdabot piped to ghci or something?
16:33:42 <revenantphx> or some other interpreter?
16:33:58 <revenantphx> > 4 `div` 0
16:33:59 <lambdabot>   *Exception: divide by zero
16:34:04 <revenantphx> :D
16:34:05 <c_wraith> It uses a couple layers of wrappers around the ghc api, which is the same interpreter ghci uses
16:34:12 <revenantphx> neat.
16:34:20 <c_wraith> the wrapper layers are to prevent exploits
16:34:32 <hpc> the one that does the magic is called mueval, iirc
16:34:44 <revenantphx> so what's a functor?
16:34:54 <hpc> a functor is a thing that can be mapped over
16:35:05 <revenantphx> okay, got it.
16:35:09 <c_wraith> a functor is anything that lets you apply a function to its "contents"...  however you want to define contents.
16:35:09 <revenantphx> applicative?
16:35:34 <c_wraith> applicative lets you apply a function inside a functor to values in that functor
16:35:41 <c_wraith> Which makes little sense by itself
16:35:43 <c_wraith> but..
16:35:44 <revenantphx> what?
16:35:47 <c_wraith> :t (<*>)
16:35:47 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:35:55 <c_wraith> that type signature kind of explains it better.
16:36:00 <dankna> yeah, I finally get the idea of functors I think
16:36:04 <revenantphx> I'm not sure what (<*>) is though haha
16:36:09 <dankna> at least, I've started using fmap on Maybes in my code
16:36:10 <hpc> here, say you have (+2)
16:36:12 <revenantphx> :t ([*])
16:36:13 <lambdabot> parse error on input `]'
16:36:16 <hpc> and you want to apply it to a maybe
16:36:22 <revenantphx> right.
16:36:24 <dankna> as opposed to casing out the value that might be in it and then re-wrapping it in another Maybe
16:36:24 <hpc> > fmap (+2) (Maybe 3)
16:36:25 <lambdabot>   Not in scope: data constructor `Maybe'
16:36:27 <c_wraith> <*> is the main function applicative supports.
16:36:30 <hpc> > fmap (+2) (Just 3)
16:36:31 <lambdabot>   Just 5
16:36:41 <hpc> now say you want to add two Maybe values together
16:37:11 <hpc> there's an alias for fmap, the functor function
16:37:15 <hpc> called <$>
16:37:18 <hpc> so we can do
16:37:30 <hpc> > (+) <$> Just 3 <*> Just 2
16:37:31 <lambdabot>   Just 5
16:37:40 <revenantphx> <*> is...?
16:37:52 <c_wraith> <*> is one of the functions defined by the Applicative class
16:37:57 <c_wraith> @src Applicative
16:37:57 <lambdabot> class Functor f => Applicative f where
16:37:57 <lambdabot>     pure  :: a -> f a
16:37:57 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:37:58 <hpc> <*> takes a thing with a function inside
16:38:06 <hpc> and applies it to a similar thing with a value inside
16:38:11 <revenantphx> says "sequential application"
16:38:23 <revenantphx> in the docs. :\
16:38:35 <hpc> docs aren't a great way to learn concepts
16:38:38 <hpc> @where lyah
16:38:39 <lambdabot> http://www.learnyouahaskell.com/
16:38:44 <revenantphx> > :t (<*>)
16:38:45 <c_wraith> @where typeclassopedia
16:38:45 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:38:45 <lambdabot>   <no location info>: parse error on input `:'
16:38:49 <burp> > Just (3+) <*> Just 2
16:38:50 <lambdabot>   Just 5
16:39:04 <revenantphx> > :t (<*>)
16:39:05 <lambdabot>   <no location info>: parse error on input `:'
16:39:13 <hpc> many other cool things are applicatives
16:39:18 <revenantphx> :t (<*>)
16:39:19 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:39:21 <revenantphx> hm...
16:39:32 <revenantphx> I'm reading lyah at the moment
16:39:37 <hpc> > [id, succ, (**2)] <*> [1,2,3]
16:39:38 <lambdabot>   [1.0,2.0,3.0,2.0,3.0,4.0,1.0,4.0,9.0]
16:39:42 <c_wraith> lyah is a good intro
16:39:52 <revenantphx> c_wraith: seems to be.
16:40:13 <c_wraith> its author is often in here, too. :)
16:40:16 <revenantphx> heh.
16:40:27 <revenantphx> Well, I don't even know what monads are really.
16:40:51 <hpc> don't worry about monads yet
16:41:22 <revenantphx> I started this yesterday > <
16:41:28 <mm_freak> > [(+), (*)] <*> [1,2,3] <*> [4,5,6]
16:41:29 <lambdabot>   [5,6,7,6,7,8,7,8,9,4,5,6,8,10,12,12,15,18]
16:41:32 <hpc> honestly, just going through lyah chapter-by-chapter should be enough to get you to coding things
16:41:33 <revenantphx> my head is hurting a bit :P
16:42:10 <revenantphx> so hpc
16:42:13 <revenantphx> in this
16:42:14 <revenantphx> > [id, succ, (**2)] <*> [1,2,3]
16:42:15 <lambdabot>   [1.0,2.0,3.0,2.0,3.0,4.0,1.0,4.0,9.0]
16:42:20 <hpc> yeah
16:42:28 <revenantphx> <*> is basically mapping each of the first list to the elements of the second list?
16:42:31 <mm_freak> revenantphx: i agree with hpcâ€¦  look at functors for now and don't worry about monads (which are just special functors)
16:42:41 <mm_freak> functors are very easy to understand
16:42:42 <hpc> revenantphx: indeed
16:42:50 <revenantphx> :t (<*>)
16:42:51 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:42:53 <revenantphx> lemme read this again...
16:43:05 <hpc> revenantphx: in the context of lists, you can think of <*> as trying every combination
16:43:14 <revenantphx> thats what I was thinking.
16:43:18 <mm_freak> revenantphx: <*> is about applicative functors, while <$> is about all functors
16:43:33 <mm_freak> > (+1) <$> Just 4
16:43:34 <lambdabot>   Just 5
16:43:42 <revenantphx> I've only studied up to Calculus II. I'd love to study category theory and all that when I have the chance though!
16:44:05 <hpc> you have more than enough math to start learning haskell right now
16:44:12 <mm_freak> i don't understand category theory much either =)
16:44:17 <revenantphx> hpc: I'm sure :P
16:44:25 <revenantphx> Seems to be an interesting language.
16:44:27 <hpc> if you study category theory, you will find that haskell deviates in a few places, much to certain people's annoyance
16:44:37 <revenantphx> hpc: haha
16:44:39 <mm_freak> hpc: in what places?
16:44:58 <copumpkin> seq and bottom break most of the nice theoretical bits
16:45:01 <hpc> mm_freak: monads aren't category-theoretic monads
16:45:01 <copumpkin> but we choose to ignore them
16:45:04 <hpc> i don't think
16:45:08 <copumpkin> why not?
16:45:09 <mm_freak> hpc: why?
16:45:26 <revenantphx> I should buy some books on category theory and such
16:45:28 <hpc> not sure, but i remember it being said a while back
16:45:35 <hpc> i haven't taken category theory either
16:45:36 <revenantphx> first I'll need to see what maths would be necessary to understand it.
16:45:45 <monochrom> ... bottom doesn't, seq does.
16:45:45 <revenantphx> But I'm not beyond teaching myself a bit.
16:45:54 <wli> Isn't bottom just a lifted domain thing?
16:45:56 <mm_freak> hpc: monads are the CT monads, but just a special case
16:46:04 <mm_freak> they are functors from Hask to Hask
16:46:09 <monochrom> the "nice" theory already has bottom everywhere. not so nice actually.
16:46:11 <copumpkin> well, if you had no bottom and had seq, it wouldn't break
16:46:21 <hpc> mm_freak: yeah, that's what it was
16:46:34 <revenantphx> seq is what?
16:46:36 <mm_freak> well, obviously you can't have all monads in haskell =)
16:46:41 <monochrom> oh if you speak like that... if you had bottom and seq but no recursion...
16:46:52 <hpc> revenantphx: seq is strict computation, where haskell is usually lazy
16:46:57 <revenantphx> example?
16:47:05 <wli> I think H1.4 had adjoint functors floating around.
16:47:10 <hpc> let's define a function that takes two arguments and ignores the second
16:47:13 <hpc> > const 4 3
16:47:13 <lambdabot>   4
16:47:14 <mm_freak> > snd (undefined, 3)
16:47:15 <lambdabot>   3
16:47:26 <hpc> it will not compute the second argument at all
16:47:31 <revenantphx> right
16:47:33 <mm_freak> > let (x,y) = (undefined, 3) in x `seq` y
16:47:34 <lambdabot>   *Exception: Prelude.undefined
16:47:36 <revenantphx> it's short circuit behavior.
16:47:37 <hpc> seq is basically flip const
16:47:48 <hpc> it returns the second argument
16:47:55 <hpc> but! it also computes the first
16:48:01 <hpc> > const 4 undefined
16:48:02 <lambdabot>   4
16:48:05 <hpc> > undefined `seq` 4
16:48:06 <lambdabot>   *Exception: Prelude.undefined
16:48:21 <revenantphx> stil a bit confused, i'll figure it out
16:48:28 <revenantphx> by short circuit I mean like
16:48:32 <revenantphx> if(v && func(v)){... in C
16:48:38 <revenantphx> if v is true, then func(v) is never called.
16:48:49 <revenantphx> Seems like that behavior is VERY common in haskell...
16:48:49 <mm_freak> > let x = undefined in length [x, x, x]
16:48:50 <lambdabot>   3
16:48:54 <monochrom> yeah, short-circuit is pervasive in haskell
16:48:56 <mm_freak> > let x = undefined in x `seq` length [x, x, x]
16:48:56 <lambdabot>   *Exception: Prelude.undefined
16:49:10 <burp> revenantphx: hm, but it depends on the compiler, doesn't it?
16:49:10 <revenantphx> mm_freak, I'm not sure I follow?
16:49:37 <monochrom> I'm pretty sure ansi c demands short-circuit &&
16:49:48 <revenantphx> so wait mm_freak
16:49:50 <mm_freak> revenantphx: honestly i've never used seq in production codeâ€¦  there is always some data structure or combinator, which does the necessary optimizations for you
16:49:50 <revenantphx> so in the first one its not actually evaluating x
16:49:52 <revenantphx> so there's no error
16:49:57 <mm_freak> so don't worry about seq for now =)
16:50:02 <revenantphx> but if seq forces it too, then it would throw an exception?
16:50:03 <mm_freak> exactly
16:50:10 <revenantphx> so in the first example
16:50:16 <mm_freak> haskell is lazyâ€¦  it doesn't need the elements themselves to calculate the length of a list
16:50:19 <revenantphx> if you then tried to use x, it'd crash
16:50:31 <revenantphx> mm_freak: okay
16:50:34 <mm_freak> it wouldn't exactly "crash", but it would give you undefined =)
16:50:36 <revenantphx> so seq forces strict evaluation
16:50:46 <mm_freak> eager evaluation, yes
16:50:59 <revenantphx> and sequential
16:51:04 <revenantphx> so it will do things in order, and immediately 
16:51:05 <revenantphx> I see.
16:51:06 <monochrom> "avoid evaluation at all costs"?
16:51:55 <revenantphx> monochrom: that seems to be haskells dogma so far > >
16:51:59 <mm_freak> sequential in a certain senseâ€¦  seq x y guarantees that x is fully evaluated, before the value of y is returned
16:52:06 <revenantphx> mm_freak: right.
16:52:16 <mm_freak> but the value of y might be calculated earlier
16:52:19 <revenantphx> mm_freak: I'm guessing though, it's playing the as-if game like c.
16:52:23 <mm_freak> so it doesn't guarantee sequencing
16:52:30 <revenantphx> It just needs to be "as if" y is evaluated after x.
16:52:58 <revenantphx> to the end user, as long as thats the behavior they see, it doesn't matter what crazy out of order instructions the processor runs through.
16:53:10 <revenantphx> C has made me lose faith in processors.
16:53:23 <revenantphx> I can't trust them, doing everything behind my back all sneaky like.
16:53:25 <monochrom> why lose faith? what's wrong?
16:53:35 <mm_freak> i don't understand
16:53:42 <monochrom> as-if is a logical conclusion of abstractions
16:53:50 <revenantphx> right.
16:53:57 <revenantphx> But "lose faith" I mean "lost trust"
16:54:00 <revenantphx> lose*
16:54:04 <monochrom> anti-thesis to control freaks
16:54:12 <revenantphx> hehe, yep
16:54:12 <revenantphx> You don't actually 
16:54:16 <revenantphx> know whats going on :P
16:54:21 <revenantphx> then again, I suppose you don't need too.
16:54:34 <burp> you know more what's going on than in c :P
16:54:39 <burp> in the end
16:54:58 <revenantphx> You could be bitchy and enforce memory barriers between EVERY SINGLE function call :D
16:55:10 <burp> talking about side effects
16:55:19 <mm_freak> well, in C you always know what's going on, unless your functions have side effects, so pratically you never know what's going on =)
16:55:34 <revenantphx> mm_freak: no, you never know what's going on
16:55:39 <mm_freak> C safety fallacy
16:55:39 <por> :r
16:55:46 <por> whoops :p
16:55:49 <revenantphx> since C plays the as-if game.
16:55:54 <revenantphx> At the processor level.
16:56:11 <revenantphx> The processor can execute instructions in whatever order it pleases, as long as to the C user, it's as if they're in order.
16:56:16 <revenantphx> or thye have the same affect.
16:56:20 <revenantphx> effect*
16:56:20 <revenantphx> dammit.
16:56:27 <mm_freak> yes, sure
16:56:31 <mm_freak> but haskell is no different
16:56:34 <revenantphx> Of course
16:56:38 <revenantphx> all programming languages have that.
16:56:39 <mm_freak> and in fact, no high level language is different
16:56:39 <burp> you want assembler? :D
16:56:46 <revenantphx> burp: even assembler is as-if
16:56:50 <revenantphx> assembly*
16:56:50 <c_wraith> Hell, assembler is no different at this point
16:56:50 <mm_freak> if you want exact sequencing at the processor level, you need to program in assembler
16:57:00 <revenantphx> weakly ordered memory is here to stay.
16:57:03 <arw> mm_freak: nope, won't work.
16:57:06 <burp> then take an ancient cpu
16:57:06 <revenantphx> mm_freak: nope
16:57:12 <revenantphx> You'd need a REALLY old CPU
16:57:15 <burp>  then you have it
16:57:22 <revenantphx> though a lot of modern ones allow enforcing of order
16:57:29 <mm_freak> it will, as long as you use DOS and no relative memory locations =)
16:57:38 <mm_freak> a DOS .COM program
16:57:46 <arw> mm_freak: there are some very fancy debugging extensions for certain embedded architectures which disable out-of-order execution...
16:57:59 <arw> mm_freak: but short of that, no modern processor will do exact sequencing.
16:58:01 <revenantphx> powerpc had an instruction to enforce ordered execution.
16:58:08 <revenantphx> I forget what it was.
16:58:17 <mm_freak> arw: sure
16:58:25 <mm_freak> but i don't get what's wrong with the "as-if game"
16:58:45 <revenantphx> mm_freak: nothing's wrong with it.
16:58:49 <arw> mm_freak: nothing is wrong. its one important component of why modern cpus are so fast compared to "back then"
16:58:54 <monochrom> it discomforts certain feeble minds
16:58:55 <revenantphx> arw: precisely.
16:58:58 <revenantphx> monochrom: hey!
16:59:04 <mm_freak> after all that "as-if game" gives us OS level memory security, because to your program it looks as if it is located at a certain RAM location, while it may just as well live on disk
16:59:08 <revenantphx> monochrom: it just discomforts me because I don't entirely understand it.
16:59:21 <revenantphx> mm_freak: memory mapping :D
16:59:29 <monochrom> I have given up on "understanding" as an end to itself.
16:59:31 <mm_freak> =)
16:59:36 <revenantphx> monochrom: heh.
16:59:52 <mm_freak> the only downside is higher complexity and more complicated compiler optimization code
17:00:00 <monochrom> The counterintuitive result is I understand more as a side effect.
17:00:26 <mm_freak> "back then" you needed only one optimization strategyâ€¦  now you need one for each CPU model
17:00:55 <revenantphx> mm_freak: more work for compiler writers, but hey, i'm not writing compilers ^_^
17:01:26 <revenantphx> !
17:01:29 <monochrom> Besides, I know the modern computer down to the quantum level.
17:01:36 <revenantphx> I know what my first self-challenge in Haskell will be.
17:01:40 <revenantphx> classic Tower of Hanoi solver.
17:01:48 <revenantphx> recursive of course :P
17:02:11 <mm_freak> revenantphx: actually just more people working on the same compiler, because a single person can't handle so many models
17:02:16 <monochrom> being informed about semiconductors renders the "bare metal" phrase totally hilarious
17:02:17 <arw> mm_freak: there were attempts like EPIC to get around doing too much out-of-order and letting the compiler provide a sane ordering.
17:02:29 <revenantphx> monochrom: ?
17:02:31 <revenantphx> how so?
17:02:34 <arw> mm_freak: problem was, nobody got good enough compilers for that.
17:02:44 <monochrom> bare semiconductor maybe. not bare metal.
17:02:44 <revenantphx> Since they're not bare metals but doped metals or what?
17:03:13 <arw> seminconductors are technically not really metals.
17:03:28 <revenantphx> it's in the acronym MOSFET itself "metal oxide semiconductor field-effect transistor"
17:03:31 <revenantphx> metal OXIDE
17:03:48 <burp> more important is semiconductor though
17:03:49 <revenantphx> and silicon isn't even a metal, it's a metalloid.
17:03:51 <mm_freak> > last [1..]
17:03:52 <arw> or at least not entirely. depends wether you have an elemental semiconductor or a compound crystal.
17:03:55 <lambdabot>   mueval-core: Time limit exceeded
17:04:30 <burp> mosfet is just one possible transistor
17:04:35 <arw> revenantphx: the metal oxide is only half of that transistor. the important part is actually the transition between the metal oxide and the semiconductor layer.
17:04:52 <revenantphx> arw: my understanding is somewhat limited, but I understand what you mean.
17:04:57 <revenantphx> > let fibs = fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:04:58 <lambdabot>   <no location info>: parse error on input `='
17:05:00 <revenantphx> damn
17:05:07 <revenantphx> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
17:05:08 <lambdabot>   not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
17:05:12 <revenantphx> grr
17:05:14 <monochrom> let ... in ...
17:05:18 <revenantphx> yeah, thats :P
17:05:20 <revenantphx> thanks*
17:05:28 <monochrom> let me in
17:05:29 <revenantphx> > let fibs = fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10000 fibs
17:05:30 <lambdabot>   <no location info>: parse error on input `='
17:05:37 <revenantphx> blargh, I'm doing it wrong
17:05:45 <revenantphx> oh rofl
17:05:48 <revenantphx> double = again
17:05:49 <monochrom> two many "fibs ="
17:05:52 <mm_freak> > fix (\r x y -> x : r y (x+y)) 0 1
17:05:53 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:05:56 <burp> keep calm ;)
17:05:59 <revenantphx> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in take 10000 fibs
17:05:59 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
17:06:04 <revenantphx> ^_^
17:06:26 <revenantphx> what's fix do?
17:06:32 <monochrom> recursion
17:07:13 <mm_freak> revenantphx: give it a function, which takes itself as the first argument
17:07:33 <mm_freak> > fix (\r x -> x : r (x+1)) 0
17:07:33 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:07:37 <c_wraith> the best way to think of fix is with a couple examples.
17:07:44 <revenantphx> oh I see.
17:07:47 <revenantphx> thats kind of magic.
17:07:48 <c_wraith> > let ones = 1 : ones in ones
17:07:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:07:51 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml
17:08:02 <c_wraith> > let ones = fix (1 :) in ones
17:08:03 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
17:08:10 <burp> http://www.vex.net/~trebla/haskell/fix.xhtml â† I like this one
17:08:18 <burp> once you read it, it's clear
17:08:18 <c_wraith> fix factors out the recursive reference to itself
17:08:22 <revenantphx> > fix (\r x -> x : r ( x -1)) 0
17:08:22 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
17:08:26 <revenantphx> and the final value of 0?
17:08:26 <monochrom> I like it very much, too.
17:08:34 <revenantphx> at the end there?
17:08:35 <arw> < revenantphx> thats kind of magic. <- most of haskell looks like that on the first impression :)
17:08:38 <burp> oh, already posted
17:08:39 <mm_freak> i like the chapter on denotational semantics on wikibooks
17:08:42 <revenantphx> arw: that it does.
17:08:52 <mm_freak> it's dry, but it helps a lot, not just with fix, but with haskell
17:08:57 <revenantphx> hrm, well I need to work on my internship stuff in C#
17:09:03 <revenantphx> need to go write some sharepoint web part stuff
17:09:07 <mm_freak> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
17:09:07 <monochrom> denotational semantics is dry
17:09:10 <revenantphx> not as much fun a haskell, but it has to be done.
17:09:19 <revenantphx> I'll be back once I install mirc on my other partition
17:10:29 <mm_freak> mircâ€¦
17:10:51 <mm_freak> i didn't expect people still use it
17:11:10 <Kaidelong> mIRC is still the most popular client out there
17:11:19 <Kaidelong> that said, I don't like it
17:11:35 <burp> didn't expect people still use windows for serious business ^^
17:11:42 <copumpkin> there should be a cabal test
17:11:47 <copumpkin> to run testsuite for you :P
17:11:51 <monochrom> I no long expect anything
17:11:57 <monochrom> s/long/longer/
17:12:55 <monochrom> actually I still expect something when it comes to haskell, agda, ...
17:16:24 <tommd> what do you expect?
17:17:02 <monochrom> I expect their type systems to be consistent
17:17:09 <revenantphx> huzzah
17:17:27 <por> Is it possible to provide an implementation for a derived function in a record?
17:17:35 <revenantphx> 0.o
17:17:42 <revenantphx> Anyhow, time to work on some sharepoint ...
17:17:43 <revenantphx> whooooo
17:17:46 <revenantphx> way more fun than haskell!
17:17:59 <monochrom> what is sharepoint?
17:18:17 <por> oh, nm
17:18:28 <revenantphx> It's Microsoft's closed source pseudo-CMS group-work framework
17:18:40 <arw> monochrom: microsoft wiki/cms/document management/whatever system.
17:18:49 <revenantphx> arw: pretty much
17:18:50 <monochrom> so they are in the habit of calling things *points?
17:19:05 <revenantphx> I intern at a registered microsoft software consultancy.
17:19:17 <monochrom> wonder when they will rename excel to numberpoint
17:19:25 <revenantphx> It's good experience learning how to work in a real world environment, and it looks great on a CV
17:19:35 <mm_freak> revenantphx: if you don't /have to/ use C#, try F#
17:19:50 <revenantphx> mm_freak: I have the choice of VB, C# and F#
17:19:50 <mm_freak> microsoft's functional language, which borrowed a lot from haskell
17:19:54 <arw> revenantphx: for certain kinds of "real world"
17:19:57 <revenantphx> F# I need to use actually if I do Dynamics GP work.
17:20:08 <revenantphx> But for sharepoint I believe it has to be VB/C#
17:20:10 <revenantphx> C# is easy to work with
17:20:15 <mm_freak> revenantphx: so you already understand monads =)
17:21:12 <mm_freak> i always think of C# as being F# with ugly syntax and less useful abstractions
17:21:15 <revenantphx> mm_freak: I do???
17:21:17 <revenantphx> o.i
17:21:25 <revenantphx> C# is not a functional langauge though
17:21:29 <mm_freak> it is
17:21:42 <mm_freak> i've even written a parser monad in C# ;)
17:21:53 <monochrom> ...
17:22:07 <revenantphx> I wouldn't call C# functional :\
17:22:19 <mm_freak> well, F# has syntax support for monadic values, but they call them computation expressions
17:22:23 <revenantphx> It's a damn clone of Java for f's sake.
17:22:30 <mm_freak> i wouldâ€¦  C# is a multiparadigm language
17:22:40 <revenantphx> mm_freak: oh okay
17:22:42 <mm_freak> C# is much more functional than java is
17:22:47 <n00p> C# isn't functional.
17:22:49 <Pseudonym> mm_freak: Yet another language fails to call them "warm fuzzy things".
17:22:51 <revenantphx> mm_freak: That I agree with
17:23:11 <revenantphx> Well, in any case
17:23:13 <mm_freak> n00p: have a look at LINQ
17:23:15 <revenantphx> this is great experience
17:23:17 <Pseudonym> Every sufficiently useful language is multi-paradigm.
17:23:20 <monochrom> I am just happy that you're happy with it.
17:23:27 <revenantphx> it means if during college I need a job... I may promote unpayed internship to payed part time worker
17:23:35 <Pseudonym> Unless it's domain-specific.
17:23:42 <mm_freak> well, C++ is not functional in my view, because for a language to be functional, it should support closures at least
17:23:44 <revenantphx> so monochrom, how are monads used in C#?
17:23:49 <arw> even java is somewhat functional if you consider ugly hacks using Runnable...
17:23:54 <n00p> mm_freak: Look at an extension to the language and expect that to be there?
17:23:59 <mm_freak> (although C++ will support pseudo-closures in C++0x)
17:23:59 <revenantphx> mm_freak: apple added support for blocks (closures) in C and C++ :P
17:23:59 <monochrom> I don't know.
17:24:10 <revenantphx> syntax is 
17:24:10 <mm_freak> n00p: ?!
17:24:14 <Pseudonym> And it already has boost.bind, which is about 80% of what you want closures to do.
17:24:19 <revenantphx> ^(int i){...};
17:24:28 <revenantphx> looks like a function pointer, but with a ^
17:24:29 <n00p> mm_freak: LINQ is a .NET framework component, not a C# language component.
17:24:31 <Pseudonym> OK, 75%.
17:24:37 <revenantphx> LINQ is sexy.
17:24:40 <revenantphx> :P
17:24:49 <mm_freak> n00p: it's a C# language component, too, because it has syntactic support for LINQ
17:25:02 <mm_freak> anyway, every .NET language must support closures, even VB.NET
17:25:12 <revenantphx> I don't like VB.net...
17:25:24 <revenantphx> things like having to use end while, end if and so on are just silly
17:25:29 <revenantphx> theres no good reason for that
17:25:49 <mm_freak> revenantphx: there is no good reason for {} either
17:26:08 <mm_freak> that's why haskell doesn't use them in favor of indentation
17:26:28 <pickles> haskell has ruined me for other languages
17:26:30 <revenantphx> mm_freak: there are plenty of arguments against white space having meaning
17:26:37 <monochrom> I like "end" or } or )
17:26:43 <revenantphx> monochrom: same
17:26:51 <revenantphx> One nice little story
17:26:57 <mm_freak> revenantphx: layout is optional in haskell, but you really want to use it
17:27:02 <pickles> anyone use vhdl? their "end" constructs are weird
17:27:03 <revenantphx> In my schools required art courses I decided to make a mosaic
17:27:07 <revenantphx> its comprised of over 4000 tiles
17:27:14 <arw> mm_freak: there is also no reason for using more than 1 space for indentation, yet everybody does that...
17:27:20 <revenantphx> I generated the layout from an image using some filters through imagemagick
17:27:23 <enigmus> f :: a -> (String, String); g :: String -> String -> b; Would there be a way to do: g $ f x? I.e. break the pair into two arguments?
17:27:24 <mm_freak> arw: readability
17:27:29 <arw> mm_freak: same for {}
17:27:30 <revenantphx> and then used processing to give me a count of each color in the image.
17:27:42 <revenantphx> So I knew exactly how many tiles I needed, and how much school money I'd get to spend.
17:27:43 <mm_freak> arw: but in a perfect world, everybody would use tabs and the editor would figure out the correct indentation
17:27:51 <revenantphx> mm_freak: soft tabs :P?
17:27:51 <pickles> random performance question, if anyone has a second
17:27:58 <revenantphx> mm_freak: also that's called python
17:27:59 <mm_freak> revenantphx: yeah
17:28:07 <Axman6> enigmus: curry
17:28:09 <Axman6> :t curry
17:28:09 <monochrom> random performs poorly, is the answer. :)
17:28:10 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
17:28:16 <pickles> lol
17:28:20 <Axman6> curry g $ f x
17:28:20 <pickles> not about random :-P
17:28:28 <enigmus> Axman6: thanks, will look it up.
17:28:28 <pickles> since haskell is lazy
17:28:29 <arw> mm_freak: depends, tabs often break haskell code. and converting tabs to spaces means your editor must know about the syntax, which is just as ugly.
17:28:40 <pickles> im assuming that the following are esseintailly the same
17:28:41 <arw> mm_freak: the only really sane way is using braces imho.
17:29:03 <mm_freak> arw: so you think haskell's syntax is worse than C's?
17:29:06 <pickles> foldl' fn2arg Map.empty (somefunc list)
17:29:06 <pickles> and
17:29:20 <arw> mm_freak: in the aspect of indentation, yes, definitely.
17:29:21 <revenantphx> haskells syntax is inconsistent and has a learning curve.
17:29:25 <revenantphx> with all the different statements
17:29:29 <Axman6> arw: uh, since when does the editor need to know about the syntax?
17:29:31 <pickles> foldl' (flip (fn2arg . somefunc)) Map.empty list
17:29:44 <mm_freak> revenantphx: i understood it immediately, because it's intuitive
17:29:48 <mm_freak> and i was coming from C/C++
17:29:53 <mm_freak> anyway
17:29:55 <arw> Axman6: to figure out the correct indentation level?
17:29:57 <mm_freak> let's talk about something else
17:30:00 <arw> Axman6: to align stuff?
17:30:01 <n00p> mm_freak: For future reference, here's the C# specification: http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-334.pdf
17:30:03 <mm_freak> because that's a matter of taste
17:30:11 <revenantphx> mm_freak: second time I've had that linked to me today
17:30:13 <revenantphx> rofl.
17:30:18 <n00p> mm_freak: Work out what the standard thinks of LINQ.
17:30:20 <pickles> would that be correct?
17:30:33 <Axman6> arw: my editor, you tell it how many characters a tab is, and when it converts a tab to spaces, it replaces each tab with n spaces
17:30:37 <mm_freak> n00p: so?
17:30:44 <Axman6> which, as far as i'm aware, is how most editors do it
17:30:47 <mm_freak> C# is still functional (i haven't read the standard, btw)
17:31:06 <mm_freak> arw: and btw, editors do know about the syntax of your programming language
17:31:10 <arw> Axman6: yes. but often, thats not the right number for aligning with the '|' on the line above.
17:31:13 <mm_freak> at least smart editors do
17:31:17 <Pseudonym> Haskell's syntax has never prevented me from saying what I wanted to say in the way I wanted to say it.  At least not after I discovered braces.
17:31:18 <arw> mm_freak: sometimes.
17:31:25 <Pseudonym> Miranda's did, though.
17:31:35 <Axman6> arw: workes perfectly fine for me, if i convert tabs to spaces, everything looks exactly the same
17:31:37 <arw> mm_freak: but they shouldn't need to know too much beyond pairing braces or parentheses.
17:31:38 <revenantphx> my parents seem to think that unless you have a mentor, self-study is useless.
17:31:45 <mm_freak> Pseudonym: i use braces only where they are necessary, like records
17:31:46 <revenantphx> 99% of my knowledge of programming begs to differ
17:31:48 <Pseudonym> Right.
17:31:52 <Pseudonym> Me too.
17:32:01 <Pseudonym> One-line do statements are sometimes very handy.
17:32:01 <revenantphx> self-teaching isn't as effective as learning by mentor, but it sure as hell is effective nontheless.
17:32:02 <mm_freak> and in fact i find them extremely ugly for records
17:32:09 <Pseudonym> And lets in list comprehensions.
17:32:14 <revenantphx> list comprehensions are fun!
17:32:19 <mm_freak> Pseudonym: you don't need braces for single line dos
17:32:30 <mm_freak> > do x <- [1,2,3]; [x+1, x-1]
17:32:31 <lambdabot>   [2,0,3,1,4,2]
17:32:38 <Pseudonym> Sorry, I used "braces" as shorthad for "braces and/or semicolons".
17:32:45 <mm_freak> ah, ok
17:32:49 <Pseudonym> Caffeine hasn't kicked in yet.
17:32:49 <monochrom> pickles: they are different in results
17:32:49 <mm_freak> i use semicolons sometimes
17:32:49 <burp> <revenantphx> self-teaching isn't as effective as learning by mentor â† I think it's just reversed
17:32:55 <mm_freak> hehe
17:32:57 <pickles> erm, i meant: foldl' fn2arg Map.empty (map somefunc list)
17:33:12 <burp> you really learn when you have to work out things yourself
17:33:38 <burp> it's just comfortable to have a teacher
17:33:42 <Pseudonym> revenantphx: Everyone learns differently.
17:33:53 <Pseudonym> My supervisor, back in the day, worked really well by himself.
17:33:58 <Axman6> i learn well when being taught
17:34:01 <Pseudonym> And thought everyone else worked the same way.
17:34:04 <Axman6> but, experience is also necessary
17:34:07 <arw> Axman6: i want to press tab exactly once to increase indentation by one level and press backspace once to decrease. that won't work with haskells layout, space-converted tabs and editors not knowing haskells syntax.
17:34:13 <Pseudonym> Which made him a bad supervisor for me. :-)
17:34:26 <Axman6> arw: works in my editor
17:34:29 <arw> Axman6: of course if you manually adjust your indentation it will look fine.
17:34:39 <Pseudonym> I actually prefer a colleague to a mentor.  I learn more by having someone I can explain what I discovered to.
17:34:44 <arw> Axman6: yes, because it knows the syntax, which is ugly.
17:35:03 <Axman6> i don't use tabs anyway, they're not necessary, and non standard between systems and editors
17:35:06 <mm_freak> i learn better for myself
17:35:08 <Pseudonym> It's the teddy bear thing.
17:35:09 <burp> it's ugly because it knows the syntax? :O
17:35:20 <Axman6> well, yes my editor knows the syntax, i does syntax highlighting
17:35:24 <arw> Axman6: there is a standard for tabs. 1 \t character :)
17:35:41 <mm_freak> arw: you should really look at emacs' haskell-mode
17:35:48 <jaredj> arw: soft tabs work well enough for me in vim
17:35:50 <Axman6> their width isn't standard though
17:35:51 <arw> mm_freak: i really hate emacs
17:36:10 <mm_freak> arw: ok, but emacs' haskell-mode is great for programming in haskell
17:36:20 <mm_freak> it seems to understand what you want to do most of the time
17:36:20 <arw> Axman6: thats intentional to accomodate people who complain about "code marching off the right margin"
17:36:24 <monochrom> pickles: they are different in results iff fn2arg is non-commutative
17:36:32 <jaredj> i haven't checked yi lately. is it awesome?
17:36:39 <pickles> hm
17:36:52 <mm_freak> jaredj: leksah is getting some attention lately
17:37:00 <jaredj> ah
17:37:07 <pickles> monochrom: it is non commutative, but does seem to work in the one form
17:37:09 <jaredj> never tried it, it said "ide" in the blurb :)
17:37:10 <pickles> ill test it with the other
17:37:14 <mm_freak> i've never got yi to compile on my system
17:37:20 <arw> Axman6: i can give my c code to somebody with an editor setting of tab == 2 spaces and it will look exactly as he likes it. he will give me back tab-indented code and i can use it in my almost-traditional tab == 8 spaces editor :)
17:37:29 <mm_freak> and i didn't feel like resolving the compiler errors
17:37:41 <arw> Axman6: soft-tabs totally break that
17:38:04 <burp> have fun with tab/space mixes :>
17:38:14 <burp> in principle it works what you mention
17:39:05 <mm_freak> arw: i'd say haskell is much more convenient with an intelligent editorâ€¦  you shouldn't expect that people edit haskell code with notepad
17:39:09 <arw> in reality it also does. its easier than forcing everybody to use soft-tabs and then re-indent for everybody.
17:39:28 <pickles> gah, still needed the flip
17:39:32 <pickles> sorry about that
17:39:35 <pickles> lets try this again
17:39:50 <arw> mm_freak: as soon as a language starts to rely on an intelligent editor it starts to get unusable.
17:40:01 <pickles> foldl' (flip (fn2arg . somefunc) Map.empty liss
17:40:03 <arw> mm_freak: just look at java and its hordes of horrible IDEs
17:40:04 <pickles> *list
17:40:05 <pickles> and
17:40:09 <burp> what about python then?
17:40:17 <burp> you need an "intelligent" editor for it?
17:40:19 <pickles> foldl' (flip fn2arg) Map.empty (map somefunc list)
17:40:21 <burp> so it's unusable?
17:40:23 <Rotaerk> arw, that's BS
17:40:38 <pickles> essentially the same performance wise b/c of being lazy
17:40:38 <mm_freak> arw: java doesn't rely on an intelligent editorâ€¦  i can use it just fine in my emacs using the c-mode (of course, there is a java-mode, too)
17:40:39 <pickles> correct?
17:41:02 <mm_freak> but layout-based languages do rely on intelligent tabbing, otherwise they get inconvenient to write
17:41:05 <mm_freak> that's true
17:41:08 <mm_freak> but let's face it
17:41:13 <mm_freak> you don't write haskell code in nano or notepad
17:41:19 <arw> mm_freak: it relies on your IDE telling you which object has which methods which in many cases would be utterly futile to try to find in 20 layers of object hierarchy
17:41:31 <mm_freak> you use a suitable editor
17:41:38 * wli does just fine editing Haskell with nvi (not even vim).
17:41:39 <monochrom> pickles: I guess so
17:41:48 <mm_freak> arw: no, that's optional
17:41:53 <Axman6> arw: haskell does not need an intelligent editor, you're being stupid
17:41:54 <mm_freak> you can just as well use the documentation =)
17:42:10 <pickles> monochrom: trying to make my code more readable
17:42:11 <Axman6> all you need to do is not use tabs, whch has nothing at all to do with the editor
17:42:17 <Pseudonym> mm_freak: Java very much depends on intelligent editors. You _can_ write code without it, but integrating all those libraries and frameworks, packages, refactoring... very difficult without it.
17:42:20 <pickles> monochrom: and i think the latter would be
17:42:32 <Rotaerk> needs an intelligent programmer though
17:42:33 <arw> Axman6: all i need is not using too much of layout, which works equally well.
17:42:36 <mm_freak> Pseudonym: i haven't written complicated java code yet
17:42:46 * wli has edited Haskell with ed before, too.
17:42:49 * Pseudonym is doing GWT as we speak
17:42:54 <Pseudonym> Sadly.
17:42:59 <mm_freak> i have written haskell code in notepad
17:43:08 <mm_freak> it works, but it's ugly and inconvenient
17:43:18 <monochrom> I wrote haskell code in "cat > haha.hs"
17:43:19 <mm_freak> so i'd say you should have an intelligent editor for haskell
17:43:20 <wli> It's far from a line editor.
17:43:30 <Axman6> there's a good reason not many people use an IDE for haskell, because any usable text editor will do
17:43:32 <mm_freak> wli: i know, but it still sucks
17:43:45 <arw> mm_freak: java IDEs got better in telling programmers what they could do next. and knowing that they "improved" their software by adding more and more complexity, because their IDE helped them to find their way.
17:43:47 <pickles> monochrom: thx for answering my question :)  room seems busy tonite!
17:43:54 <burp> I just need syntax highlighting
17:43:56 <mm_freak> Axman6: most "usable" editors /are/ half-way IDEs ;)
17:44:07 <jaredj> arw: i think good haskell code looks like someone reasoning on a whiteboard. and curly braces are crap for reasoning with on a whiteboard
17:44:16 <arw> mm_freak: which usually results in utterly unusable libraries and frameworks.
17:44:19 <Axman6> i'd write haskell just fine in a text editor that just does syntax highlighting
17:44:25 <Axman6> in fact, that's basically all my editor does
17:44:30 <Axman6> with a few snippets
17:44:33 <burp> Axman6: I agree
17:44:39 <mm_freak> arw: well, that's not java's faultâ€¦  it's the library designers' fault
17:44:51 <mm_freak> the language itself isn't much more complicated than C++ or C#
17:44:52 <monochrom> talk to Dijkstra about reasoning on a whiteboard with { }
17:45:08 <jaredj> Axman6: depending on syntax highlighting is as scary to me as depending on a fancy java ide
17:45:30 <Pseudonym> mm_freak: Here's the irony of complexity.
17:45:34 <Axman6> jaredj: i don't depend on it, it's just very helpful to have
17:45:35 <shachaf> Axman6: Does that mean that you can't edit Perl? :-)
17:45:36 <Pseudonym> A program needs to be this complex:
17:45:36 <mm_freak> Axman6: you'll want an intelligent tab key
17:45:39 <jaredj> monochrom: Dijkstra hand-wrote his EWD notes. i'm confident he reasoned a lot before writing anything :)
17:45:41 <Pseudonym> |<----------------------------------------------------->|
17:45:45 <arw> mm_freak: of course. i'm mixing "java the language" with "java the software environment"
17:45:48 <Axman6> shachaf: i wouldn't know, i choose not to :P
17:45:49 <Pseudonym> Which means that if your language is this complex:
17:45:51 <monochrom> http://userweb.cs.utexas.edu/users/EWD/ewd12xx/EWD1294a.PDF
17:46:02 <Pseudonym> |<------>|----------------------------------------------|
17:46:05 <Axman6> mm_freak: i can live without, but it is nice also
17:46:05 <Pseudonym> You need to write this much:
17:46:07 <monochrom> { } surrounds every reason
17:46:08 <shachaf> Axman6: (Perl isn't statically syntax-highlightable; you need to run a program before you know how to parse it.)
17:46:20 <Pseudonym> |--------|<-------------------------------------------->|
17:46:31 <Pseudonym> Sorry for everyone with a proportional font.
17:46:43 <jaredj> Pseudonym: is that with 8 char tabs or 2 char tabs? ;)
17:46:47 <Axman6> proportional fonts on irc--
17:46:49 <mm_freak> proportional font should work =)
17:47:01 <shachaf> @karma irc
17:47:02 <lambdabot> irc has a karma of 2
17:47:05 <Pseudonym> mm_freak: The pipes in the second two lines may not line up.
17:47:10 <mm_freak> Axman6: i like proportional fonts much more than fixed width fonts, but irssi obviously doesn't support them
17:47:10 <shachaf> irc++
17:47:28 <Axman6> shachaf: thanks :P
17:47:39 <Axman6> mm_freak: indeed
17:47:57 <mm_freak> in xchat i always used a serif font
17:48:03 <mm_freak> a proportional one, that is
17:48:39 <mm_freak> and in my browser i force all fonts to be with serifs
17:48:42 <arw> terminals with proportional fonts are some kind of abomination... nobody wants that i guess :)
17:48:45 <mathijs> is it possible to fmap a function to MonadPlus and have that MonadPlus fail (mzero) based on the result of that?
17:48:46 <mm_freak> because i'm a typography enthusiast
17:49:16 <jaredj> arw: fixed width terminals are a sad holdover from the 70s which has been refined
17:49:33 <mm_freak> mathijs: fmap transforms (a -> b) to (f a -> f b), but you want to transform (a -> f b) to (f a -> f b), which calls for monads
17:49:59 <jaredj> arw: have you ever used acme?
17:50:05 <arw> jaredj: yes and no. the only sane non-fixed-width terminal is a proper gui.
17:50:11 <Pseudonym> mm_freak: So what you're saying is that when web browsing, you prefer fonts that are easier to chisel?
17:50:14 <jaredj> that sort of thing
17:50:16 <Makoryu> :t (>>=)
17:50:17 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
17:50:17 <burp> so, whats the next topic? :D maximum line width of 70, 80 chars?
17:50:19 <arw> jaredj: no?
17:50:40 <mm_freak> Pseudonym: i don't understand
17:50:51 <jaredj> arw, http://www.caerwyn.com/acme/
17:51:00 <arw> Pseudonym: serif fonts are also somewhat easier to read, at least in printouts.
17:51:01 <Pseudonym> Serifs were invented because they make for cleaner chiselled text.
17:51:02 <mm_freak> Pseudonym: (english is not my primary language)
17:51:08 <mm_freak> yes
17:51:11 <monochrom> @quote ray 1970s
17:51:11 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
17:51:16 <mathijs> mm_freak: I was affraid of that :)  but that will work
17:51:16 <Pseudonym> Does your primary language use a Roman alphabet?
17:51:16 <jaredj> arw: it has no soft tabs. maybe you would like it ;)
17:51:29 <mm_freak> in fact, if there weren't so many technical limitations, i'd even use ligatures on my website =)
17:51:32 <Pseudonym> But point taken.
17:51:38 <mm_freak> Pseudonym: yes
17:51:52 <Pseudonym> I tend to find sans serif fonts eaiser to read on a monitor.
17:52:21 <Pseudonym> Now, if I had one of the new iPhone 4 displays, this may be different.
17:52:47 <mm_freak> i always found serif fonts easier to read, because they make the font richer and words easier to recognize for the brain
17:52:47 <int80_h> @hoogle getProgName
17:52:48 <lambdabot> System.Environment getProgName :: IO String
17:52:54 <mm_freak> and that's their point anyway
17:52:55 <Pseudonym> Serifs might indeed be better if you had a real 300dpi display.
17:53:03 <Pseudonym> But at 72dpi, I'm sticking with sans.
17:53:10 <arw> jaredj: hm, sounds like emacs, only the kitchen sink seems missing :)
17:53:31 <jaredj> :)
17:53:41 <mm_freak> Pseudonym: or with good antialiasing and smart hinting =)
17:53:58 <monochrom> I find it easier to impose fonts, spacing, colours on users, then rationalize it by making up fake ergonomic arguments as though "I'm trying to help you".
17:54:21 <int80_h> @seen notabel
17:54:22 <lambdabot> Unknown command, try @list
17:54:30 <jaredj> do you work for apple?
17:54:30 * int80_h grumbles
17:54:42 <arw> mm_freak: antialiasing and smart hinting only make fonts look like printed on wet paper.
17:54:46 <monochrom> perhaps all those "serif is better for people" "sans is better for people" arguments are of the same kind.
17:55:14 <mm_freak> arw: it's a monitor after allâ€¦  you just need to get used to it
17:55:18 <arw> monochrom: there are real arguments about reading speed to it. but they are not as easy as "serif good, sans bad"
17:55:22 <jaredj> antialiasing wouldn't matter if we all had 300dpi displays by now
17:55:52 <mm_freak> monochrom: well, there is some good reasoning for serif fonts on printed material, and i took it to the monitor for myself
17:56:06 <int80_h> > :t unwords
17:56:07 <mm_freak> other people may prefer sans, but that's their business =)
17:56:07 <lambdabot>   <no location info>: parse error on input `:'
17:56:13 <int80_h> @hoogle unwords
17:56:13 <lambdabot> Prelude unwords :: [String] -> String
17:56:13 <lambdabot> Data.List unwords :: [String] -> String
17:56:13 <lambdabot> Data.ByteString.Char8 unwords :: [ByteString] -> ByteString
17:56:16 <arw> mm_freak: no, i just use a proper monitor with no antialiasing and stuff and get proper sharp fonts :)
17:56:21 <monochrom> every 5 years I switch between serif and sans
17:56:37 <mm_freak> arw: my fonts are sharp, too, because of hinting
17:56:51 <mm_freak> AA only makes them appear blurred
17:56:51 <arw> mm_freak: then your glasses are too weak :>
17:56:58 <monochrom> currently I'm in my serif cycle
17:57:03 <pyfgc> pointfree converts h x = f (g x) (i x) to h = liftM2 f g i . i tried using this definition of h, but got the error "No instance for (Monad ((->) [Char]))". So what does the output mean?
17:57:46 <monochrom> import Control.Monad.Instances
17:58:01 <pyfgc> ok
17:58:01 <mm_freak> arw: http://streitmacht.eu/scrshot.png 
17:58:07 <mm_freak> does that look blurred to you?
17:58:56 <arw> mm_freak: yes, and i have colored seams. your monitor has a different subpixel ordering :)
17:59:04 <pyfgc> monochrom: thanks!
17:59:06 <Pseudonym> It doesn't look blurred to me, but I really don't like the look of those lower-case m's.
17:59:38 <Veinor> yeah
17:59:44 <mm_freak> Pseudonym: well, yesâ€¦  that's why i prefer proportional fonts
18:00:22 <Pseudonym> Also, I don't like the inter-character spacing in the yellow-on-blue headers.
18:00:39 <mm_freak> it's the same as everywhere
18:00:46 <mm_freak> i don't use varying fonts
18:00:56 <mm_freak> it just appears a bit wide because of the colors
18:01:03 * Pseudonym nods
18:01:08 <cinayakoshka> I have a noob question...  about the cause of an Occurs check: cannot construct the infinite type: a = [a]
18:01:14 <Pseudonym> It looks like the characters are too small for the cells that they're in.
18:01:28 <Veinor> cinayakoshka: pastebin your code?
18:01:33 <cinayakoshka> okay.
18:01:43 <cinayakoshka> although, it's four lines.
18:01:50 <Veinor> still
18:01:52 <mm_freak> Pseudonym: i can live with thatâ€¦  the font i'm using is a good compromise, i guess
18:01:56 <wolfspaw> Im very newbie to linux, arch, haskell , xmonad... well, everything. In my xmonad config i use an already maded config by importing it. But i want to alter it, the problem is... i don't know where it is in my system (Arch), My import is: "XMonad.Config.Arossato" , where/how should i search for the source file containing it?
18:02:06 <mm_freak> as long as i don't have to use bitmap fonts, i'm fine =)
18:02:15 <Pseudonym> The font that I like to do my programming in is Andale Mon.
18:02:16 <Pseudonym> Mono
18:02:32 <cinayakoshka> http://pastebin.com/agfeS1BQ
18:02:35 <mm_freak> i use luxi mono
18:02:40 <Pseudonym> Mostly inertia, of course.  But I've found it the cleanest so far.
18:02:43 <mm_freak> both for coding and for terminals
18:02:52 <Pseudonym> Mind you, I haven't looked to see what's around for at least 7 years.
18:03:03 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29641#a29659
18:03:31 <Pseudonym> Droid Sans Mono looks quite good.
18:03:58 <mm_freak> well, as said i prefer serif fonts =)
18:04:04 <mm_freak> luxi mono has serifs
18:04:05 <cinayakoshka> iit's about finding Mersenne primes...
18:04:14 <Veinor> cinayakoshka: could you post the definition of augmentPrimes?
18:04:16 <Martty> i prefer ê¸€ë¦¼
18:04:19 <cinayakoshka> okay
18:04:37 <arw> mm_freak: how does http://wwwcip.cs.fau.de/~snalwuer/UTF-8-demo.txt look in that terminal? aka does it have proper unicode support?
18:04:44 <Veinor> cinayakoshka: but I think I found one issue
18:05:00 <cinayakoshka> yes?
18:05:08 <Veinor> (\x -> x <= last) is comparing the value x to the function last
18:05:19 <cinayakoshka> no, last is now just avalue.
18:05:21 <cinayakoshka> woops.
18:05:31 <cinayakoshka> I will rename it.
18:05:35 <cinayakoshka> it's an integer.
18:05:48 <Veinor> could you post your entire file so I can look at the types of everything?
18:06:06 <cinayakoshka> I kinda did.  it's all there now.
18:06:27 <Veinor> I'm not seeing the augmentprimes definition
18:06:52 <cinayakoshka> it's right below isprime
18:07:01 <Veinor> I don't see any of the new stufff you put up
18:07:07 <Veinor> oh, found it
18:07:40 <cinayakoshka> here's my errror:
18:07:41 <cinayakoshka> mps.lhs:183:0:
18:07:41 <cinayakoshka>     Occurs check: cannot construct the infinite type: a = [a]
18:07:41 <cinayakoshka>     When generalising the type(s) for `fnMP'
18:08:19 <Veinor> right
18:09:11 <Veinor> you still have the problem with last
18:09:15 <cinayakoshka> I think you were right.
18:09:57 <cinayakoshka> still the same error, after changing 'last' to 'n'.
18:11:18 <Veinor> wait, where do you define that variable
18:11:20 <Veinor> ?
18:11:39 <Veinor> I don't see a definition for it
18:11:45 <cinayakoshka> reload the page.
18:12:04 <cinayakoshka> fnMP is called like this: fnMP 2 [2]
18:12:20 <cinayakoshka> should give us 3 [3, 2]
18:12:35 <cinayakoshka> well, really (3, [3, 2])
18:13:06 <mm_freak> cinayakoshka: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29660#a29660
18:13:29 <Saizan> arw: fun, that file is better supported in my terminal than in my browser
18:13:51 <Veinor> oh, now I see the problem
18:14:10 <Veinor> cinayakoshka: you're using the variable prs twice in the list comprehension
18:14:18 <cinayakoshka> mm_freak: interesting.  I kinda wanted to understand what was wrong with mine.
18:14:31 <Veinor> in prs <- foldl (\y x -> augmentPrimes x y) prs cans
18:14:32 <arw> Saizan: yes, as long as there is general utf-8 support it mostly depends on what glyphs your font provides. 
18:14:43 <cinayakoshka> I thought prs is an accumulator?
18:14:54 <arw> Saizan: and probably the box-drawing and alignment tests will fail if your browser uses a proportional font.
18:15:27 <Axman6> cinayakoshka: it's the initial value of the accumulator
18:15:36 <mm_freak> cinayakoshka: i don't knowâ€¦  yours appears quite complicated to me
18:15:40 <cinayakoshka> when it's on the right side of the paren
18:15:49 <Axman6> hmm
18:16:00 <mm_freak> unnecessarily complicated that is
18:16:03 <cinayakoshka> I know, mm_freak, but just finding someone else's answer isn't my plan.
18:16:09 <cinayakoshka> I'm trying to learn haskell.
18:16:13 <mm_freak> true
18:16:14 <Saizan> arw: that doesn't explain the failure on combining characters though :)
18:16:38 <mm_freak> what does fnMP do?
18:16:48 <mm_freak> or what is it supposed to do?
18:16:48 <cinayakoshka> finds next _____ prime.
18:17:03 <mm_freak> next prime or next mersenne prime?
18:17:07 * Axman6 would suggest using better names
18:17:12 <cinayakoshka> mersenne
18:17:18 <cinayakoshka> thanks, Axman.
18:17:36 <cinayakoshka> I changed the names for posting .
18:18:02 <wolfspaw> what is the default place for the haskell-platform(in linux)? Im searching for the source files (i want to see some implementations) but i can't find them and i don't know how to search for them =(
18:18:33 <Axman6> does it come with the source by default?
18:18:52 <cinayakoshka> problem solved8!!
18:18:55 <cinayakoshka> yay.
18:19:00 <cinayakoshka> add two parens.
18:19:18 <mm_freak> cinayakoshka: sorry, i didn't understand your code
18:19:19 <wolfspaw> Axman6: hm... i dont know
18:19:26 <mm_freak> try to simplify it, both for yourself and for others
18:19:28 <mm_freak> and use better names
18:19:44 <wolfspaw> Axman6: i can find the binaries but i can't find the sources, i guess i dont have them then
18:19:55 <cinayakoshka> mm_freak, I really didn't ask you.  I changed the names on purpose, for posting.
18:20:11 <cinayakoshka> I am not writing this code for others.
18:20:16 <mm_freak> cinayakoshka: no reason to get offending
18:20:19 <Axman6> wolfspaw: the source is all online though
18:20:25 <blackh> Axman6: Hello!
18:20:25 <cinayakoshka> well, you're just very... rude.
18:20:31 <cinayakoshka> you know?
18:20:35 <blackh> Axman6: What do you think of this? http://hip-to-be-square.com/~blackh/haskell/k-nucleotide.hs
18:20:44 <mm_freak> i didn't mean to be rude, sorryâ€¦  i just want to help
18:20:51 <Axman6> hey blackh :) i'll take a look!
18:21:09 <Axman6> holyjesusimportlist
18:21:09 <blackh> It's about 1/7th of the speed of the one on the shootout.
18:21:14 <Axman6> haha
18:21:14 <cinayakoshka> another way to say things is " I have trouble understanding your code."  When you said that, you got your point acress without being a jerk.
18:21:18 <Axman6> oh wow, nice :D
18:21:26 <blackh> But instead of the code being hideously ugly, it's nice.
18:21:38 <Axman6> cinayakoshka: i don't think he was being rude at all
18:21:48 <Veinor> haskell programs tend to have large import lsits
18:21:51 <Veinor> *lists
18:22:32 <blackh> Axman6: So, it'd be nice to make this really fast and get rid of that ugly one I did.
18:22:53 <mm_freak> cinayakoshka: anyway, sorry for that, but it was nothing for badâ€¦  you should really reconsider your coding styleâ€¦  try to use more combinators and less nested abstractionsâ€¦  it really helps avoid such errors
18:23:12 <cinayakoshka> omg, you continue.
18:23:15 <cinayakoshka> shove off, man.
18:23:32 <cinayakoshka> that is not my usual coding style.
18:23:36 <Martty> anyone know how to simulate right control when my laptop keyboard has only the left one?
18:23:55 <mm_freak> Martty: operating system?
18:23:56 <cinayakoshka> I *do* write nice code when I expect it to see the light of day.
18:24:09 <cinayakoshka> quickly hacking stuff to learn a language is not the same.
18:24:23 <cinayakoshka> You have not seen my coding style, mm_freak.
18:24:25 <wolfspaw> Martty: well, if you're in linux i read about xBindkeys , but i didn't tried yet
18:24:27 <cinayakoshka> get it!
18:24:46 <mm_freak> Martty: when using linux, xmodmap is the way to go
18:25:15 <mm_freak> (or when using X, actually, which isn't only linux=
18:25:16 <mm_freak> )
18:25:18 <blackh> Axman6: The only function that needs to be sped up is htIncs
18:25:36 <Martty> im on winxp
18:25:48 <DaveS> Cinayakoshka: Let me guess, you do write some nice code, but it's all proprietary and you can
18:25:50 <Rotaerk> mm_freak, what do you mean by "nested abstractions"?
18:25:51 <Martty> my problem is the IME for korean which requires right control to use hanja
18:25:52 <DaveS> t show it =)
18:25:53 <Axman6> cinayakoshka: settle down, far out. he's trying to help you. you're the only being rude and defensive here
18:26:08 <mm_freak> Rotaerk: foldl inside of list comprehensions
18:26:16 <mm_freak> for example
18:26:27 <wolfspaw> the guys in the linux channel aren't very talkfull. So as a bit of offtopic: how to do a search based in a word inside a text file? like "search the entire system for files having the "Foo" word". 
18:26:44 <arw> wolfspaw: rgrep "word" *
18:26:45 <mm_freak> wolfspaw: grep
18:26:47 <copumpkin> grep -R "foo" .
18:26:48 <copumpkin> or that
18:26:48 <DaveS> wolfspaw: That is an easily googlable question
18:26:54 <Axman6> blackh: i wish i had time to look at it at the moment, i may have time tomorrow afternoon
18:27:18 <blackh> Axman6: Well, I'm not in any hurry.  I probably won't work on it again for a while, either.
18:27:24 <mm_freak> wolfspaw: if you're searching for a /word/ you'll want to use:
18:27:34 <mm_freak> grep "\<myWord\>"
18:27:38 <wolfspaw> DaveS: ok, sorry ;-; .   arw mm_freak : thanks!
18:27:47 <mm_freak> possibly combined with -R
18:27:51 <mm_freak> and -i
18:28:41 <copumpkin> preflex: seen preflex
18:29:31 <mm_freak> btw, my code found the first twenty mersenne primes in a few minutes in ghci =)
18:30:38 <copumpkin> mm_freak: the question is, did it also find non-primes :P
18:30:42 <copumpkin> cause if so that's very easy :P
18:32:24 <mm_freak> copumpkin: no, i verified it =)
18:32:32 <DaveS> Is there some value to finding larger and larger values of a certain class of primes?
18:32:38 <DaveS> or calculating Pi to ridiculous lengths
18:32:57 <Veinor> calculating pi to ridiculous lengths is a good way to stress-test a CPU
18:33:02 <mm_freak> DaveS: yeah, satisfying curiosity
18:33:17 <mm_freak> or do you see any point in writing functions likeâ€¦
18:33:53 <DaveS> Veinor: I don't mean like that
18:34:03 <DaveS> I mean trying to find "the next biggest one ever found"
18:34:19 <mm_freak> @let myPerms = foldM (\x y -> zipWith (\a b -> a ++ y:b) <$> inits <*> tails $ x) []
18:34:20 <lambdabot>  Defined.
18:34:23 <Veinor> there's no practical purpose to calculating the trillionth digit of pi
18:34:26 <mm_freak> > myPerms "abc"
18:34:27 <lambdabot>   ["cba","bca","bac","cab","acb","abc"]
18:34:45 <mm_freak> that's a great example of overusing abstractions =)
18:35:02 <hpc> :t myPerms
18:35:03 <lambdabot> forall a. [a] -> [[a]]
18:35:47 <Saizan> Veinor: easy to say that until someone points a gun at you asking for that digit.
18:35:53 <mm_freak> @let mySubseqs = filterM (const [True, False])
18:35:54 <lambdabot>  Defined.
18:36:03 <mm_freak> > mySubseqs "abc"
18:36:04 <lambdabot>   ["abc","ab","ac","a","bc","b","c",""]
18:36:28 <DaveS> myPerms "lambdabot"
18:36:38 <DaveS> =(
18:36:41 <DaveS> oh
18:36:45 <DaveS> > myPerms "lambdabot"
18:36:46 <lambdabot>   ["tobadbmal","otbadbmal","obtadbmal","obatdbmal","obadtbmal","obadbtmal","o...
18:37:08 <dstcruz> hxt is making my head hurt!
18:37:26 <mm_freak> @let myPerms2 = foldM (\x y -> zipWith (\a b -> a ++ y:b) <$> tails <*> inits $ x) []
18:37:27 <lambdabot>  Defined.
18:37:35 <mm_freak> > myPerms2 "lambdabot"
18:37:36 <lambdabot>   ["lambdabot","ambdabotl","mbdabotla","bdabotlam","dabotlamb","abotlambd","b...
18:37:39 <mm_freak> that's better
18:38:37 <dstcruz> input <- readFile; let xml = parseHtmlContent body; let body = xml !! 3; body >>> deep isText  <--- no likes me :(
18:38:47 <DaveS> > myPerms (myPerms "test")
18:38:47 <lambdabot>   [["test","tets","ttes","ttes","tset","tste","ttse","ttse","stet","stte","st...
18:39:02 <mm_freak> dstcruz: readFile is missing an argument
18:39:19 <dstcruz> sorry, typo while transcribing here
18:39:58 <dstcruz> neither does 'getChildren body' work
18:40:15 <dstcruz> I'm missing something very fundemental somewhere
18:40:41 <Saizan> well, you need a run function for the arrow type you've chosen
18:41:10 <Saizan> runX probably
18:41:18 <mm_freak> dstcruz: first of all 'xml' is not a list
18:41:39 <mm_freak> if (!!) is the list indexer, then it can't work
18:42:10 <mm_freak> also according to your code 'body' is a string
18:42:18 <mm_freak> so (body >>>) doesn't make much sense either
18:42:58 <dstcruz> ok: let xml = parseHtmlContent input
18:43:00 <dstcruz> that does work
18:43:08 <dstcruz> and returs [XmlTree]
18:43:09 <mm_freak> if (f >>> g) is a function, then you pass a value x like:  (f >>> g) x
18:43:15 <mm_freak> not like:  (x >>> f >>> g)
18:43:29 <FunctorSalad_> it would probably help if you made "no likes me" a bit more specific ;)
18:44:00 <mm_freak> dstcruz: unless your parseHtmlContent is different from mine, the result should be of type XmlTrees
18:44:08 <mm_freak> and that's not a list =)
18:44:10 <dstcruz> at this point "body" is Data.Tree.NTree.TypeDefs.NTree XNode
18:44:21 <FunctorSalad_> (type error? logic error?)
18:44:33 <dstcruz> I believe it is a type error
18:44:52 <FunctorSalad_> as Saizan mentioned, it'd be surprising if it does anything at all without runX ;)
18:45:14 <int80_h> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29641
18:45:22 <FunctorSalad_> Text.XML.HXT.Arrow.XmlIOStateArrow runX :: IOSArrow XmlTree c -> IO [c]
18:45:33 <int80_h> saizan, I implemented your suggestion, but am now stuck on a new problem.
18:45:55 <int80_h> saizan, I mean ^^^
18:45:58 <int80_h> ack
18:45:58 <mm_freak> well, that runX would be runIO
18:46:02 <mm_freak> according to the code
18:46:06 <mm_freak> so that doesn't make much sense =)
18:46:49 <mm_freak> unless, again, his readFile is different from mine
18:47:32 <dstcruz> I probably typed something wrong here, let me double check what I have
18:48:41 <dstcruz> inputText <- readFile "filepath"; let xml = parseHtmlContent inputFile; let body = xml !! 3;
18:48:56 <Saizan> int80_h: that error is unrelated to the gadt, you've to use "unwords (fst $ unzip loaders)" otherwise it thinks unwords is the whole second argument to ++
18:49:02 <dstcruz> and then :t body gives: Data.Tree.NTree.TypeDefs.NTree XNode
18:49:30 <Saizan> int80_h: you'll get another error after you solve that though, since "loader" won't be a function.
18:49:40 <revenantphx> hello again folks.
18:49:50 <mm_freak> welcome back revenantphx 
18:49:53 <dstcruz> having trouble figuring how to run anything on it
18:49:56 <revenantphx> Apparently my parents have decided that spending 6 hours a day (or more) on the computer is unhealthy.
18:50:11 <revenantphx> Despite the fact that I spend all of it on Skype socializing or learning programming stuff.
18:50:24 <mm_freak> "socializing" =)
18:50:28 <revenantphx> No, really.
18:50:32 <revenantphx> Conference calls
18:50:34 <revenantphx> (with maybe 20 minutes of "other activities" at most)
18:50:37 <FunctorSalad_> lol 6 hours?
18:50:43 <revenantphx> if not more...
18:51:01 <FunctorSalad_> . o O ( 23 hours ... )
18:51:03 <revenantphx> they think limit should be 1 1/2
18:51:06 <revenantphx> > >
18:51:07 <lambdabot>   <no location info>: parse error on input `>'
18:51:09 <mm_freak> well, since my PC is about the only electronic device here, it does almost everything
18:51:16 <revenantphx> damn I can't use that emoticon here.
18:51:19 <mm_freak> and so i naturally spend a lot of time in front of it =)
18:51:24 <copumpkin> mm_freak: your program counter?
18:51:26 <revenantphx> > printStrLn "> >"
18:51:27 <lambdabot>   Not in scope: `printStrLn'
18:51:37 <mm_freak> copumpkin: Personal Computer
18:51:41 <copumpkin> :)
18:51:47 <mm_freak> ;)
18:51:51 <mm_freak> > putStrLn "abc"
18:51:52 <lambdabot>   <IO ()>
18:52:03 <mm_freak> of course lambdabot won't run IO actions for you =)
18:52:25 <dstcruz> dangerous side-effects there could be!
18:52:29 <revenantphx> > putStrLn " > >"
18:52:30 <lambdabot>   <IO ()>
18:52:36 <revenantphx> oh COME ON 
18:52:37 <revenantphx> :(
18:52:44 <FunctorSalad_> but seriously, it's not like they don't hace any point at all... try to keep it at 6 hours ;o
18:52:45 <revenantphx> putStrLn "> >"
18:52:50 <revenantphx> > putStrLn "> >"
18:52:50 <lambdabot>   <IO ()>
18:52:52 <mm_freak> > "> >"
18:52:53 <lambdabot>   "> >"
18:52:59 <revenantphx> lol
18:53:02 <FunctorSalad_> s/hace/have/
18:53:06 <revenantphx> > print "> > "
18:53:07 <lambdabot>   <IO ()>
18:53:13 <revenantphx> how is that an IO though?
18:53:13 <Saizan> > text "> >"
18:53:15 <lambdabot>   > >
18:53:19 <revenantphx> more importantly what IS a n IO ()
18:53:22 <int80_h> Saizan: I'm still getting complaints about the Nothing -> error ... line. I will post, with your suggested changes.
18:53:24 <mm_freak> it's not
18:53:27 <Kaidelong> :t text
18:53:27 <mm_freak> :t "> >"
18:53:28 <lambdabot> String -> Doc
18:53:28 <lambdabot> [Char]
18:53:36 <revenantphx> :t "> >"
18:53:36 <lambdabot> [Char]
18:53:40 <Kaidelong> @src text
18:53:40 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:53:43 <revenantphx> :t print
18:53:44 <lambdabot> forall a. (Show a) => a -> IO ()
18:53:45 <dstcruz> :t putStrLn
18:53:46 <lambdabot> String -> IO ()
18:53:47 <revenantphx> yeah there we go.
18:53:56 <revenantphx> so WHAT IS an IO ()
18:53:57 <Saizan> int80_h: 'k
18:53:59 <revenantphx> I still dont get that :P
18:54:07 <mm_freak> revenantphx: an IO action resulting in a value of type ()
18:54:18 <revenantphx> action as in a function?
18:54:21 <revenantphx> or is it something more?
18:54:23 <mm_freak> no, action as in action
18:54:26 <Saizan> something else
18:54:29 <revenantphx> it definitely seems to connect to lower level stuff.
18:54:41 <revenantphx> read: C/asm/kernel stuff
18:54:42 <Saizan> think of it as a recipe for the side-effects that will be performed
18:54:43 <copumpkin> nah
18:54:53 <revenantphx> Saizan: that's kinda what I mean
18:55:00 <mm_freak> revenantphx: for now, view IO as a sublanguage to write imperative and side-effectful stuff in
18:55:02 <int80_h> Saizan: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29641#a29661
18:55:09 <revenantphx> mm_freak: that's kind of how I am.
18:55:17 <revenantphx> one thing I AM wondering
18:55:27 <revenantphx> say you have a server, and you want to keep track of the name of people who connect.
18:55:41 <dstcruz> maybe I should change my approach.  Can someone kindle show me how to get all the text nodes (or do any other operation) on an html document by using hxt?
18:55:49 <revenantphx> I could see it being managed by having each connection concurrent with a local variabel for the name of the person...
18:55:55 <dstcruz> preferrably ghci
18:55:58 <revenantphx> But I'm missing how you'd express something like that
18:56:12 <mm_freak> revenantphx: concurrency is precisely the way to deal with concurrent clients
18:56:14 <Saizan> int80_h: ah, yeah, "error $"
18:56:21 <revenantphx> mm_freak: who knew
18:56:22 <revenantphx> but
18:56:28 <revenantphx> what if you have shared state between them liek
18:56:32 <Saizan> int80_h: or "error (... ++ ...)" if you prefer
18:56:42 <revenantphx> oa large mutable binary blob which you send to new clients and update afterwards
18:56:46 <mm_freak> revenantphx: add another concurrent thread
18:56:49 <mm_freak> a manager thread
18:56:54 <revenantphx> the very word MUTABLE is the issue there.
18:57:34 <mm_freak> don't worry about system resourcesâ€¦  haskell threads are not operating system threads =)
18:57:36 <int80_h> Saizan: okay now I'm onto the problem of loaders, not being a function.
18:57:38 <revenantphx> You can't work with a 5MB binary blob by recreating it every time you mess with it.
18:57:44 <revenantphx> mm_freak: not system
18:58:05 <monochrom> ? who is recreating a 5MB blob?
18:58:06 <revenantphx> how do you deal with a situation that fundamentally requires mutable data.
18:58:09 <Kaidelong> well depending on how you implement the data structure you won't recreate the whole thing
18:58:13 <mm_freak> revenantphx: you don'tâ€¦  personally i write a manager thread using a state monad
18:58:23 <revenantphx> okay: state monad.
18:58:26 <revenantphx> something I dont know, 
18:58:28 <int80_h> Saizan: this code was written by someone else and I am trying to adapt it, what does the "Just loader -> do" part of the case statement mean?
18:58:28 <Kaidelong> if you do want a large mutable binary blob, use mutable arrays, I guess
18:58:32 <revenantphx> but you seem to think it could do something.
18:58:50 <mm_freak> revenantphx: a state monad is a type encoding a function of type s -> (a, s)
18:59:02 <mm_freak> i.e. a function taking a state and returning a new state along with a result value
18:59:18 <revenantphx> the other issue
18:59:25 <revenantphx> it can't be stack memory
18:59:32 <revenantphx> obviously, putting 5MB on the stack causes problems
18:59:38 <Saizan> > lookup "foo" [("foo",1),("bar",2)] -- int80_h 
18:59:39 <lambdabot>   Just 1
18:59:44 <Saizan> > lookup "baz" [("foo",1),("bar",2)] -- int80_h 
18:59:45 <lambdabot>   Nothing
18:59:47 <mm_freak> there is no "stack memory" in haskell
19:00:01 <mm_freak> revenantphx: i'll code you an example
19:00:05 <revenantphx> wait
19:00:14 <revenantphx> code me an example of managing some large binary blob which changes FREQUENTLY
19:00:19 <Saizan> int80_h: so it means that "name" matched one of the first elements of the tuples in loaders
19:00:19 <revenantphx> or theoretically would
19:00:25 <revenantphx> in C i'd just edit specific bytes as needed.
19:00:42 <int80_h> Saizan, so this is just a typo.
19:00:46 <Saizan> dstcruz: this should help http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml
19:00:59 <Saizan> int80_h: what is a typo?
19:01:36 <Saizan> or, better, what do you mean by "this"?
19:01:53 <FunctorSalad_> let arr = readDocument [] "blah.xml" in runX (arr >>> deep isText)
19:01:55 <revenantphx> basically mm_freak: how do you manage state that directly contradicts haskell's principles for "variables"
19:01:57 <revenantphx> :P
19:01:59 <FunctorSalad_> ^^^ dstcruz 
19:02:06 <int80_h> Saizan, N/m, I was thinking it should be loaders, instead of loader. If this was the case, the neglect of typing the s at the end of loader would be a typo - or typographical error.
19:02:13 <FunctorSalad_> I'm afraid that's as far as my memory of hxt goes ;)
19:02:19 <revenantphx> I assume the answer involves functions
19:02:36 <int80_h> Saizan: this, as in "this problem is caused by a"
19:02:45 <mm_freak> revenantphx: by using IO
19:02:58 <Saizan> int80_h: ah, no, loader there is bound to the second element of the tuple that matched
19:03:03 <mm_freak> it's not a contraction, because you /can/ encode stateful computations in haskell
19:03:08 <mm_freak> including side effects
19:03:13 <revenantphx> mm_freak: im sure theres some way
19:03:15 <mm_freak> but you need to be explicit about that
19:03:17 <revenantphx> do show
19:03:18 <Saizan> int80_h: which is fine, but we want to pattern match it to extract the function
19:03:42 <mm_freak> revenantphx: for example you can use IOUArray
19:03:58 <revenantphx> I don't owe you any array!
19:04:04 <monochrom> heh
19:04:06 <mm_freak> hehe
19:04:07 <revenantphx> And you certainly don't owe me one.
19:04:10 <mm_freak> that's a real array just like in C
19:04:26 <monochrom> or STUArray
19:04:41 <int80_h> Saizan: I'm not sure how to do that. Am I using at notation for this?
19:04:44 <mm_freak> yeah, STUArray is better, but i don't want to confront revenantphx with ST for now =)
19:04:52 <revenantphx> haha
19:05:07 <Saizan> int80_h: so it's look like "Just (Loader pname loader) -> do ..."
19:05:10 * revenantphx is hoping ST doesn't involve the words "standard" or "template"
19:05:13 <revenantphx>  > >
19:05:25 <Axman6> State Transformer
19:05:34 <Axman6> of thread. hmm, i can never remember
19:05:34 <revenantphx> RIGHT :D
19:05:38 <revenantphx> anyhow
19:05:42 <revenantphx> mm_freak, example?
19:05:47 <Axman6> anyway, ST is awesome
19:05:48 <mm_freak> revenantphx: think of ST as a safe subset of IO
19:05:54 <mm_freak> so you can escape from ST into pure world
19:06:00 <mm_freak> you can't escape from IO
19:06:20 <mm_freak> revenantphx: you know the sieve of eratosthenes?
19:06:21 <int80_h> Saizan, and pname holds the seconjd element of the tuple?
19:06:27 <mm_freak> for calculating the first n prime numbers
19:06:31 <revenantphx> mm_freak yes
19:06:42 <revenantphx> I wrote a few implementations of it in C, and a few euler's
19:06:47 <mm_freak> revenantphx: that's one obvious use case for STUArray/IOUArray
19:07:12 <revenantphx> hwo so?
19:07:25 <revenantphx> that you have to manage state between function calls (recursively)?
19:07:39 <mm_freak> revenantphx: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29662#a29662
19:07:40 <Saizan> int80_h: the whole (Loader pname loader) is the second element, e.g. if name was "students", it'd be "Loader PNStudents loadStudentIDs", so in that case "pname = PNStudents; loader = loadStudentIDs"
19:08:08 <revenantphx> how is " ST s (STUArray s Int Bool)" read?
19:08:19 <mm_freak> revenantphx: the point of a state monad is that you don't have to pass state around explicitly
19:08:24 <monochrom> you have an array (and array is really the best data structure for the task) and you mutate it often
19:08:34 <revenantphx> monochrom: I agree.
19:08:36 <Saizan> int80_h: using gadts before being familiar with pattern matching might be doing things backwards :)
19:08:40 <revenantphx> I think
19:08:45 <revenantphx> I should get ot learning how monads work
19:08:48 <revenantphx> and then come back to this ;D
19:08:49 <mm_freak> revenantphx: 'ST s' is a safe subset of IO
19:08:51 <int80_h> Saizan: yeah I do things backwards :)
19:08:52 <revenantphx> once I get there.
19:09:17 <mm_freak> a subset, for which the runST function is allowed (or in this case runSTUArray)
19:09:20 <int80_h> Saizan: not used to seing pattern matching inside a do
19:09:22 <revenantphx> also
19:09:31 <revenantphx> > [i*i, i*i+i .. n]
19:09:32 <lambdabot>   *Exception: not a number
19:09:34 <mm_freak> :t runST
19:09:34 <revenantphx> >:(
19:09:35 <lambdabot> forall a. (forall s. ST s a) -> a
19:09:45 <revenantphx> > let m = [i*i, i*i+i .. n]
19:09:45 <lambdabot>   not an expression: `let m = [i*i, i*i+i .. n]'
19:09:50 <revenantphx> oh, right
19:09:51 <mm_freak> > [2, 5, ..]
19:09:52 <lambdabot>   <no location info>: parse error on input `..'
19:09:56 <int80_h> Saizan, it compiles. I may now be forced to move on and define those undefined functions
19:09:57 <mm_freak> > [2, 5 ..]
19:09:58 <revenantphx> > let m = [i*i, i*i+i .. n] in take 10 m
19:09:59 <lambdabot>   [2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,77...
19:09:59 <lambdabot>   *Exception: not a number
19:10:08 <revenantphx> grr
19:10:13 <revenantphx> I want ot know what that expands out too.
19:10:24 <monochrom> use concrete numbers
19:10:31 <revenantphx> I assume i*i + 2i, i*i + 31
19:10:33 <revenantphx> 3i*
19:10:34 <revenantphx> etc
19:10:36 <mm_freak> revenantphx: it's i+i and i+i+i
19:10:42 <mm_freak> which is 2*i and 3*i =)
19:11:01 <revenantphx> thats pretty neat that the .. is smart enough to figure out series like that
19:11:05 <monochrom> lambdabot has not attained consciousness yet
19:11:07 <revenantphx> so I could do...
19:11:07 <Saizan> int80_h: dealWithTable should really get the pname too, otherwise it won't be able to know the type of its other argument
19:11:11 <mm_freak> if the i-th number is prime, then cross out the 2*i-th number, the 3*i-th number, etc.
19:11:12 <revenantphx> theoretically
19:11:16 <mm_freak> up to n
19:11:27 <mm_freak> if 3 is prime, cross out 6, 9, 12, etc.
19:11:32 <revenantphx> [(i + 0)^2, (i + 1)^2 ... n]
19:11:43 <revenantphx> and that would give me all results of i+2^n up to n?
19:12:18 <Axman6> no
19:12:28 <Axman6> it's just enumFromThenTo
19:12:34 <Axman6> :t enumFromThenTo
19:12:34 <lambdabot> forall a. (Enum a) => a -> a -> a -> [a]
19:12:47 <Axman6> > enumFromThenTo 1 4 20
19:12:47 <lambdabot>   [1,4,7,10,13,16,19]
19:12:55 <int80_h> Saizan, okay but now I want to know the type of tbl. GHCI isn't helping me any. I loaded main.lhs into it but tbl is out of scope
19:13:04 <mm_freak> revenantphx: you're confusing enumeration syntax with iteration
19:13:10 <revenantphx> sems like it.
19:13:15 <mm_freak> > iterate (^2) 2
19:13:16 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
19:13:18 <revenantphx> I just wonder how this expands
19:13:19 <revenantphx> [i*i, i*i+i .. n]
19:13:22 <revenantphx> with n of say, 5
19:13:31 <revenantphx> up to i*i+5i?
19:13:34 <revenantphx> or 4i, w/e
19:13:46 <revenantphx> no, 5i, it's inclusive isn't it
19:13:47 <mm_freak> an enumeration is always linearâ€¦  the first number gives the starting point, the second number gives a step
19:13:53 <mm_freak> > [3, 3.5 ..]
19:13:54 <lambdabot>   [3.0,3.5,4.0,4.5,5.0,5.5,6.0,6.5,7.0,7.5,8.0,8.5,9.0,9.5,10.0,10.5,11.0,11....
19:13:58 <int80_h> Saizan, this has happened before. I want to examine types in my code but variables and functions are somehow out of scope even if I load in the code
19:14:00 <revenantphx> oh, those evaluate first right
19:14:03 <mm_freak> > [10, 9 ..]
19:14:04 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,...
19:14:09 <revenantphx> it's not actually going to figure out an enumeration of equations
19:14:13 <revenantphx> like a sum notation type thing.
19:14:19 <revenantphx> npto equations
19:14:21 <revenantphx> expressions
19:14:31 <mm_freak> revenantphx: no, haskell is not a CAS =)
19:14:35 <revenantphx> mm_freak :P
19:14:48 <int80_h> so how can a module be loaded in ghci, yet varibales in that module be out of scope?
19:14:56 <Saizan> int80_h: from ghci you can only ask the type of toplevel definitions, anything in a nested scope is out of reach
19:15:05 <int80_h> dang
19:15:29 <int80_h> now I'm in trouble then because I don't know what type to give to "dealWithTable"
19:15:44 <int80_h> if I can't examine the type of tbl
19:15:53 <int80_h> or pname, for that matter
19:15:55 <mm_freak> > [False ..]
19:15:56 <lambdabot>   [False,True]
19:16:03 <Saizan> it won't tell you much there, anyhow
19:16:30 <Saizan> int80_h: but i'd go with "dealWithTable :: ProgramName a -> a -> IO ()"
19:17:04 <revenantphx> the iterate function is useful for one lining stuff :P
19:17:20 <revenantphx> and just making nice recursion in general
19:17:25 <Saizan> int80_h: which is derived from the type of the fields of Loader, considering that you've already applied the function to a [String]
19:18:10 <mm_freak> revenantphx: it's useful for a lot of stuff
19:18:14 <revenantphx> one question
19:18:31 <revenantphx> I noticed ghc has unicode forward support, can it actually use the lamba charcter instead of \ in lambdas?
19:18:41 <Makoryu> Nope
19:18:42 <mm_freak> @let groupsOf i = takeWhile (not . null) . map (take i) . iterate (drop i)
19:18:43 <lambdabot>  Defined.
19:18:51 <mm_freak> > groupsOf 3 "This is a test."
19:18:52 <lambdabot>   ["Thi","s i","s a"," te","st."]
19:18:59 <revenantphx> as in (Î»n -> n^2)
19:19:02 <Makoryu> revenantphx: The lexer doesn't support that, much to the chagrin of many Emacs users
19:19:15 <revenantphx> why emacs specifcally?
19:19:16 <Zao> revenantphx: Lambda is classified as a letter or somesuch.
19:19:22 <Zao> revenantphx: Because all the unicode wankers use it.
19:19:26 <Zao> http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource
19:19:29 <revenantphx> Zao: poo
19:19:42 <Zao> revenantphx: Or rather, people who care about inserting silly glyphs into their source.
19:19:51 <revenantphx> hehe, yeah
19:20:06 <mm_freak> Zao: or people not accepting that english is the one and only language in the world
19:20:29 <Zao> mm_freak: There's a difference between using letter-type glyphs in identifiers and fapping around with punctuation.
19:21:10 <mm_freak> well, i find the choice of the lambda character quite unfortunate
19:21:20 <mm_freak> also the dot
19:21:40 <mm_freak> in fact i find haskell lambdas easier to read than real lambdas
19:21:50 <monochrom> who really wants to write like "nineteen eighty-four"?
19:21:59 <Makoryu> Urgh
19:22:42 <monochrom> "add nineteen eighty-four to forty-two" cobol?
19:22:53 <mm_freak> =)
19:23:03 <mm_freak> well, haskell approaches that
19:23:12 <mm_freak> forever . print $ "I'm stupid!"
19:23:12 <monochrom> sadly some OOP freaks really want that. x.add(y)
19:23:42 <mm_freak> well, that syntax would be nice for a few things, especially records
19:23:47 <revenantphx> loop do puts "Wheeeee" end
19:24:14 <revenantphx> brownie points if you can name the language.
19:24:16 <mm_freak> main = putStrLn "I'm stupid!" >> main
19:24:29 <revenantphx> #include <stdio.h>
19:24:40 <revenantphx> int main(int argc, char* argv[]) {
19:24:40 <adu> monochrom: they want '.'?
19:24:53 <Makoryu> revenantphx: Er, Ruby
19:24:57 <revenantphx> printf("%s\n", "I'm stupid, but efficient");
19:24:58 <revenantphx> }
19:25:03 <revenantphx> well not quite, fwrite would be better.
19:25:08 <revenantphx> printf has much overhead.
19:25:16 <adu> ya, or puts()
19:25:33 <revenantphx> I never use gets() or puts()
19:25:33 <revenantphx> :\
19:25:41 <revenantphx> dunno why
19:25:43 <Martty> main = putStrLn "Im jealous :("
19:25:45 <adu> puts adds the "\n" for you
19:25:54 <revenantphx> adu, eh, not hard to do it yourself ;)
19:26:18 <adu> i know, but thats C/POSIX
19:27:30 <Olathe> > concatMap (\x -> "putChar("++show(ord x)++"); ") "hello"
19:27:31 <mm_freak> main = withArrayLen "I'm stupid!\n" $ \len ptr -> hPutBuf stdout ptr len
19:27:31 <lambdabot>   "putChar(104); putChar(101); putChar(108); putChar(108); putChar(111); "
19:27:35 <mm_freak> sorry
19:27:41 <mm_freak> main = withArrayLen "I'm stupid, but efficient!\n" $ \len ptr -> hPutBuf stdout ptr len
19:27:44 <mm_freak> ;)
19:29:29 <mm_freak> or, to make a point against overusing abstractions againâ€¦
19:29:39 <mm_freak> main = withArrayLen "I'm stupid, but efficient!\n" $ flip (hPutBuf stdout)
19:30:21 <mgsloan> if there's a data structure which derived Show, and should have derived Read, but its in a library, what should I do?
19:30:29 <mgsloan> use Data.Derive?
19:30:49 <dmwit> standalone deriving?
19:30:58 <dmwit> + send a patch to the library author?
19:31:51 <dstcruz> FunctorSalad_: sorry, got pulled away from the machine.  Thanks, I'll try to dissect you example to see what concepts I'm missing.
19:32:41 <revenantphx> I'm trying to decide if I should use ONLY rpn notation on tuesdays
19:32:44 <revenantphx> to bother my math teacher.
19:32:52 <revenantphx> redundant: rpn notation
19:32:53 <revenantphx> > >
19:32:54 <lambdabot>   <no location info>: parse error on input `>'
19:33:07 <revenantphx> too much effort seems like
19:33:54 <mm_freak> revenantphx: write a lambda program on paper
19:34:07 <mm_freak> tell him that it beta-reduces to the desired result
19:34:23 <revenantphx> haha
19:34:39 <mgsloan> dmwit - ahh, thanks.  I dunno how important this is, most people don't need to Read XEvents :D
19:34:56 <mgsloan> Graphics.X11.Xlib.Extras.Event, that is
19:35:30 <dmwit> If it's got a Show instance, it might as well have a Read instance.
19:35:35 <mgsloan> indeed
19:35:40 <dmwit> Go for it, send a patch.
19:35:42 <ezyang> What's the easiest way to convert a Bool into an Int? 
19:35:43 <mgsloan> and the show instance appears to be a deriving
19:35:50 <dmwit> :t fromEnum
19:35:51 <lambdabot> forall a. (Enum a) => a -> Int
19:36:03 <ezyang> huh. I could have sworn it claimed it gave an Inteer. 
19:36:06 <ezyang> *Integer 
19:36:43 <revenantphx> oh, mm_freak 
19:36:53 <revenantphx> how is haskell supposed to be pronounced, does it rhyme with rascal?
19:36:54 <dstcruz> this seems to be something that I've hit more than once.  It is not obvious to me from the documentation where to "start".  In this case, it seems that Text.XML.HXT.Arrow.ReadDocument would have been the place to start.  Any tips on how to improve that?
19:37:39 <dmwit> dstcruz: Sure, send a documentation patch that puts a link to T.X.H.A.ReadDocument on the top-level module.
19:38:15 <rschnck_> Why is it that [1.1,1.2..5.0] churns out a big list of numbers with a ton of trailing 9's?
19:38:29 <rschnck_> As in, I get 1.299999999998 instead of 1.3 for the next value
19:38:29 <dmwit> For what I consider (in a totally unbiased way ;-) to be a good example of this, check out http://hackage.haskell.org/packages/archive/sgf/0.1.1/doc/html/Data-SGF.html
19:38:32 <Veinor> rschnck_: welcome to the fun-filled world of floating-point arithmetic!
19:38:35 * revenantphx gets no answer.
19:38:43 <dstcruz>  dmwit: so it is a reasonable expectation to have that at some top level?
19:38:43 <rschnck_> Veinor: Oh boy!
19:38:44 <mm_freak> revenantphx: no idea, i just pronounce it as is
19:38:48 <mm_freak> has-kell
19:38:50 <dmwit> The "Overview of the library" section has links to two starting points in its first sentence. =)
19:38:53 <rschnck_> Veinor: So how exactly does that work?
19:39:01 <jmcarthur> rschnck_: floating point is just inaccurate
19:39:02 <Veinor> revenantphx: I think haskell rhymes with rascal
19:39:03 <dmwit> > [1.1, 1.2 .. 5.0] :: Rational -- rschnck_ 
19:39:04 <lambdabot>   Couldn't match expected type `GHC.Real.Rational'
19:39:04 <lambdabot>         against inferred t...
19:39:07 <revenantphx> mm_freak: stress on the first or second syllable tho
19:39:16 <dmwit> > [1.1, 1.2 .. 5.0] :: [Rational] -- rschnck_ 
19:39:17 <lambdabot>   [11 % 10,6 % 5,13 % 10,7 % 5,3 % 2,8 % 5,17 % 10,9 % 5,19 % 10,2 % 1,21 % 1...
19:39:19 <jmcarthur> rschnck_: if you want it to be correct you are probably better off with Rational (at the cost of some performance)
19:39:22 <rschnck_> jmcarthur: Oh, so it's "approximating" 1.3?
19:39:30 <jmcarthur> > 1.3 :: Float
19:39:31 <lambdabot>   1.3
19:39:33 <dmwit> > [1.1, 1.2 .. 5.0] :: [CReal] -- another solution
19:39:34 <jmcarthur> > 1.3 :: Double
19:39:34 <lambdabot>   [1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2....
19:39:35 <lambdabot>   1.3
19:39:46 <revenantphx> :t foldl
19:39:47 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:39:57 <revenantphx> ty lambdabot :D
19:39:58 <rschnck_> Well I'm lost :<
19:39:58 <jmcarthur> rschnck_: it's able to express 1.3, but the addition operation is just not precise enough to get the right result
19:40:03 <dstcruz> for instance this: http://www.fh-wedel.de/~si/HXmlToolbox/hdoc/index.html
19:40:07 <dstcruz> I have no idea where to start
19:40:11 <revenantphx> wait
19:40:19 <jmcarthur> rschnck_: floating point is a gigantic hack
19:40:19 <revenantphx> what the crap is the period after the b
19:40:22 <revenantphx> :t foldl
19:40:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
19:40:26 <Veinor> > 1.3 + 2 * (1.2 - 1.1)
19:40:27 <lambdabot>   1.4999999999999998
19:40:27 <rschnck_> jmcarthur: Oh. Okay...but how can you get imprecesion from adding 0.1?
19:40:34 <rschnck_> as in, why isn't it just adding...0.1?
19:40:42 <Draconx> rschnck_, 0.1 is not exactly representable in binary floating point.
19:40:43 <jmcarthur> rschnck_: it's the addition operation that's flawed in this case
19:40:46 <Veinor> revenantphx: the period separates the forall part from the rest of it
19:40:50 <dmwit> dstcruz: When you find out, send a documentation patch that just adds a sentence to the end of the description giving some pointers. It will almost certainly get accepted, and people will love it!
19:40:51 <jmcarthur> Draconx: sure it is
19:40:53 <jmcarthur> > 0.1
19:40:54 <lambdabot>   0.1
19:40:55 <Draconx> jmcarthur, no, it isn't.
19:40:56 <revenantphx> Veinor: okay thanks
19:40:58 <dmwit> dstcruz: Better documentation starts with you! =)
19:41:01 <Draconx> jmcarthur, 0.1 has an infinite binary expansion.
19:41:01 <revenantphx> this is a REALLY active channel btw
19:41:07 <revenantphx> compared to the other lang channels.
19:41:18 <dstcruz> dmwit: got it, thanks
19:41:26 <jmcarthur> Draconx: okay okay, but IEEE can express it in the sense that its rounding error gives it the correct value
19:41:34 <Draconx> jmcarthur, no, it doesn't.
19:41:39 <jmcarthur> > 0.21
19:41:40 <lambdabot>   0.21
19:41:42 <jmcarthur> > 0.1
19:41:42 <lambdabot>   0.1
19:41:44 <revenantphx> wow, 11 less people than C++
19:41:47 <revenantphx> pretty popular channel XD
19:41:58 <Axman6> we're smaller than C+++ now?
19:41:59 <jmcarthur> Draconx: it doesn't work out properly for addition, sure
19:42:01 <Draconx> jmcarthur, that's because _show_ is rounding it.
19:42:10 <copumpkin> revenantphx: we've been up to 699 in my experience
19:42:11 <jmcarthur> err
19:42:16 <revenantphx> cool
19:42:17 <Axman6> :t showFloat
19:42:17 <lambdabot> forall a. (RealFloat a) => a -> String -> String
19:42:18 <rschnck_> Typing [1..] is fun :3
19:42:28 <jmcarthur> > showFloat 0.1 ""
19:42:29 <lambdabot>   "0.1"
19:42:42 <Axman6> > 1/10
19:42:42 <lambdabot>   0.1
19:42:58 <dmwit> :t toRational
19:42:59 <lambdabot> forall a. (Real a) => a -> Rational
19:43:09 <Axman6> printf "%.20d" (1/10) :: String
19:43:13 <Axman6> > printf "%.20d" (1/10) :: String
19:43:14 <lambdabot>   "*Exception: Printf.printf: bad argument
19:43:19 <jmcarthur> > realToFrac (0.1 :: Double) :: Rational
19:43:19 <Axman6> bah
19:43:20 <lambdabot>   3602879701896397 % 36028797018963968
19:43:23 <dmwit> > toRational (0.1 :: Double)
19:43:24 <lambdabot>   3602879701896397 % 36028797018963968
19:43:27 <Draconx> > printf "%a" (0.1 :: Double)
19:43:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
19:43:28 <lambdabot>    `GHC.Show.Show a'
19:43:28 <lambdabot>      a...
19:43:28 <jmcarthur> Draconx: okay you're right :)
19:43:32 <mm_freak> @unlambda `r``.r`.e`.h`.c`.a`.e`.t`. `.e`.m`.o`.s`.e`.w`.a`. `.g`.n`.i```.u`.f`. `.e`.n`.o`. `.e`.r`.a`. `.y`.l`.e`.r``````.Y.o.u. .s.u.c.k.!i
19:43:32 <lambdabot>   You surely are one fucking awesome teacher!
19:43:40 <Draconx> lame, Haskell's printf doesn't support %a?
19:43:42 <mm_freak> find the secret message
19:43:47 <mm_freak> ;)
19:43:59 <Axman6> what's %a?
19:44:15 <Veinor> mm_freak: :O
19:44:23 <jmcarthur> now i wonder why show has that behavior
19:44:43 <revenantphx> Also mm_freak
19:44:44 <revenantphx> wow.
19:44:45 <Veinor> > printf "%a" (0.1 :: Double) :: String
19:44:46 <lambdabot>   "*Exception: Printf.printf: bad formatting char a
19:44:48 <revenantphx> point-free style is growing on me fast.
19:45:00 <jmcarthur> i guess it's fine that show does that because if you read it back you get the same result
19:45:00 <Draconx> jmcarthur, because the people who put floating point in Haskell were clueless.
19:45:01 <revenantphx> It's getting a lot easier to read/think about too.
19:45:08 <mm_freak> revenantphx: unlambda is extraordinarily points-free
19:45:14 <mm_freak> and pointless, too =)
19:45:19 <revenantphx> unlambda...?
19:45:21 <revenantphx> anyhow
19:45:22 <jmcarthur> @check \x -> (x :: Double) == read (show x)
19:45:23 <lambdabot>   "OK, passed 500 tests."
19:45:24 <revenantphx> floating point numbers are inherently base 2.
19:45:29 <revenantphx> That's their problem
19:45:31 <djahandarie> @pl \a b c d -> a (b c >>= (\z -> d z))
19:45:31 <lambdabot> (. flip (flip . (((.) . (>>=)) .)) id) . (.) . (.)
19:45:37 <jmcarthur> @check \x -> (x :: Double) == read (show x)
19:45:38 <lambdabot>   "OK, passed 500 tests."
19:45:39 <djahandarie> revenantphx, how about now
19:45:41 <mm_freak> revenantphx: that's not a problem
19:45:43 <revenantphx> for high precision base TEN numbers you need specialized data types.
19:45:45 <mm_freak> it makes them fast
19:45:49 <Axman6> revenantphx: IEEE floating point numbers are
19:45:50 <Draconx> revenantphx, no, decimal floating point is found in many financial applications.
19:45:50 <mm_freak> decimal numbers are limited, too
19:45:56 * jmcarthur is tempted to run that check with a lot more tests
19:45:59 <revenantphx> Draconx: that's what I meant
19:46:03 <Draconx> revenantphx, you can use floating point with any base.
19:46:09 <revenantphx> Draconx: I KNOW...
19:46:11 <mm_freak> you can have an exact 1/5 in decimal, but not an exact 1/3
19:46:18 <Draconx> revenantphx, so why did you say that floating point was inherently base-2?
19:46:23 <mm_freak> and you can't have floating point numbers with an infinite base =)
19:46:26 <revenantphx> because your computer runs on base 2
19:46:33 <revenantphx> If you're storing them as primitives...
19:46:34 <mm_freak> in other words: floating point numbers aren't supposed to be exact
19:46:40 <revenantphx> you better f'ing believe they'l be base 2.
19:46:40 <mm_freak> if you want to be exact, use Rational
19:46:44 <revenantphx> mm_freak: exactly.
19:46:46 <mm_freak> (and beware of memory horrors)
19:46:53 <revenantphx> for exact floating point you need specialized data object
19:46:57 <revenantphx> and yes, you will have memory issue.s
19:47:03 <Draconx> revenantphx, base-16 floating point used to be commonly found in hardware.
19:47:04 <revenantphx> floating point decimal* you need...
19:47:12 <jmcarthur> unless, of course, you want to express a computable real, in which case you should obviously use a computable real instead of a rational
19:47:13 <revenantphx> Draconx, sure, but accounting isn't in base 16 is it.
19:47:20 <revenantphx> It's base 10.
19:47:26 <mm_freak> Draconx: but base 16 is stupidâ€¦  it doesn't have any advantage over base 2
19:47:35 <mm_freak> base 2*3*5*7*11 would be useful
19:47:37 <Draconx> mm_freak, hence why it is no longer commonly found :P
19:47:39 <jmcarthur> > toRational (0.1 :: CReal)
19:47:40 <lambdabot>   *Exception: CReal.toRational
19:47:45 <jmcarthur> dang, not implemented
19:47:58 <Veinor> what's the C stand for in CReal?
19:48:02 <Draconx> computable.
19:48:04 <Veinor> mm_freak: base 16 is shorter!
19:48:04 <jmcarthur> computable, i imagine
19:48:14 <Axman6> > 1/10 :: CReal
19:48:14 <lambdabot>   0.1
19:48:23 <revenantphx> Veinor: Surprise, base 16 and base 2 convert losslessly.
19:48:27 <mm_freak> Veinor: how is it shorter?  you need four bits for a digit anyway
19:48:29 <jmcarthur> > sqrt 2 * sqrt 2
19:48:30 <lambdabot>   2.0000000000000004
19:48:32 <jmcarthur> > sqrt 2 * sqrt 2 :: CReal
19:48:32 <lambdabot>   2.0
19:48:36 <Veinor> mm_freak: I mean, to write out
19:48:37 <Veinor> ;)
19:48:40 <mm_freak> Veinor: it's just shorter on paper =)
19:48:43 <mm_freak> yeah
19:49:00 <mm_freak> but still quite pointless =)
19:49:17 <mm_freak> same as BCD numbers, which were common in the early days of x86
19:49:26 <etpace> @hoogle (a -> a -> Ordering) -> [a] -> a
19:49:26 <lambdabot> Data.List maximumBy :: (a -> a -> Ordering) -> [a] -> a
19:49:26 <lambdabot> Data.List minimumBy :: (a -> a -> Ordering) -> [a] -> a
19:49:26 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
19:49:38 <revenantphx> Endall: computer floating points are not accurate. They are PRECISE, but not accurate.
19:49:45 <jmcarthur> > exp $ sqrt (-1) * pi :: Complex Double
19:49:46 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
19:49:48 <jmcarthur> > exp $ sqrt (-1) * pi :: Complex CReal
19:49:49 <lambdabot>   (-1.0) :+ 0.0
19:49:51 <revenantphx> Which is why almost every language worth its salt has a Decimal type.
19:50:15 <revenantphx> Because in accounting and such, you only need precision to a certain degree, but you need absolute numerical accuracy.
19:50:17 <jmcarthur> decimal isn't all that accurate either
19:50:26 <jmcarthur> ah
19:50:29 <jmcarthur> distinction i missed
19:50:31 <revenantphx> jmcarthur: You don't get what Decimal types are do you?
19:50:36 <revenantphx> decimal types are for example, 
19:50:42 <jmcarthur> i know what they are
19:50:45 <revenantphx> types that represent every decimal place with an integer
19:50:58 <jmcarthur> yes
19:51:01 <revenantphx> takes up a LOT more memory, much slower.
19:51:02 <jmcarthur> now represent 1.3 in it
19:51:04 <jmcarthur> err
19:51:07 <jmcarthur> 1/3
19:51:14 <revenantphx> exactly, you end up with infinites
19:51:15 <mm_freak> revenantphx: not really
19:51:18 <revenantphx> but thats a machine restriction
19:51:23 <revenantphx> mm_freak: I'm trying to simplify > >
19:51:24 <revenantphx> sssh
19:51:26 <revenantphx> :P
19:51:27 <mm_freak> revenantphx: decimals are just fixed point numbers represented as a single integer
19:51:36 <jmcarthur> revenantphx: the fact that it's decimal has nothing to do with it
19:51:46 <jmcarthur> revenantphx: you could do the same thing with a binary representation
19:52:00 <mm_freak> what makes them "decimal" is that the point is moved in a base of 10, not 2
19:52:07 <jmcarthur> 1/3 is an infinite expansion in both decimal and binary for exactly the same reason in both cases
19:52:16 <revenantphx> the fact of the matter is, binary representation is not effective for base 10 floating points.
19:52:43 <jmcarthur> that's true, but that doesn't seem to be the assertion you were making earlier
19:52:59 <jmcarthur> it seemed that you were claiming that decimal was more accurate
19:53:18 <revenantphx> more accuracy in calculations
19:53:26 <revenantphx> and usually precision is upwards bounded only by memory
19:53:27 <jmcarthur> which is true if you only care about decimal numbers. that's kind of a tautology though
19:53:51 <jmcarthur> if you make that claim about decimal then the same applies to binary
19:54:02 <revenantphx> mm.
19:54:14 <revenantphx> the numbers are the same in any case, but how they're stored is not.
19:54:34 <jmcarthur> well, the numbers are the same if you admit infinite space
19:54:40 <revenantphx> IEEE 794 floats do not give the accuracy required for calculations.
19:54:46 <revenantphx> jmcarthur: of course.
19:54:53 <revenantphx> accounting calculations(
19:54:57 <revenantphx> and other such decimal work.
19:55:10 <mm_freak> well, you can represent algebraic numbers finitely
19:55:11 <jmcarthur> IEEE floats suck, but their inaccuracy isn't really due to not being decimal
19:55:21 <Draconx> revenantphx, IEEE 754 specifies both decimal and binary floating point, so "IEEE 754 floats" is ambiguous.
19:55:23 <revenantphx> 754*
19:55:30 <jmcarthur> ha, and that
19:55:52 <mm_freak> but as said earlier haskell is not a CAS =)
19:56:06 <revenantphx> anyhow, this is going nowhere. It's a fact that decimal types exist for the purpose of proper accuracy for decimal numbers
19:56:17 <jmcarthur> there, you finally said it properly :)
19:56:17 <revenantphx> and they only exist because the standard primitve fails to fullfill that.
19:56:27 <revenantphx> fulfill*
19:56:29 <Draconx> Just leave it at "binary floating point arithmetic is not good for financial applications because, in this case, exact representations of decimal fractions is important".
19:56:40 <mm_freak> it has some tendencies (most notably in that the = sign really makes an equation), but it only allows equating thingsâ€¦  it cannot solve equations
19:56:44 <jmcarthur> i think the word you want is precise though, not accurate
19:56:44 <mm_freak> â€¦ unfortunately
19:56:46 <revenantphx> okay, thats the right way to put it draconx
19:57:01 <Draconx> for a lot of applications, exact representation of decimal fractions is _not_ important.
19:57:17 <jmcarthur> i don't care about decimals in my physics engine, for example
19:57:27 <revenantphx> jmcarthur: yeah, no reason too.
19:57:51 <revenantphx> but when something is say, a financial application, those fractions of pennies matter.
19:57:58 <jmcarthur> indeed
19:58:03 <jmcarthur> i think nobody disagrees with that
19:58:11 <revenantphx> okay then, thats all.
19:58:13 <revenantphx> XD
19:58:25 * jmcarthur hugs revenantphx because we were hard on him
19:58:32 <revenantphx> > putStrLn "Thats all folks"
19:58:33 <lambdabot>   <IO ()>
19:58:37 <revenantphx> ...god dammit XD
19:58:40 <jmcarthur> lol
19:58:49 <jmcarthur> > text "Thats all folks"
19:58:49 <Veinor> lambdabot doesn't execute IO actions :P
19:58:50 <lambdabot>   Thats all folks
19:58:56 <revenantphx> Velnor: yeah apparently.
19:59:08 <revenantphx> > text "That's all folks!"
19:59:09 <lambdabot>   That's all folks!
19:59:12 <Veinor> :t text
19:59:13 <lambdabot> String -> Doc
19:59:17 <mm_freak> revenantphx: better for lambdabot
19:59:22 <Veinor> oh, and Docs show without quotes?
19:59:28 <mm_freak> > removeFile "/etc/passwd"
19:59:29 <lambdabot>   Not in scope: `removeFile'
19:59:35 <mm_freak> uhhh
20:00:02 <jmcarthur> @hoogle removeFile
20:00:03 <lambdabot> System.Directory removeFile :: FilePath -> IO ()
20:00:15 <mm_freak> > sort [1..]
20:00:20 <jmcarthur> > System.Directory.removeFile "/etc/passwd"
20:00:20 <mm_freak> (don't try this at home)
20:00:23 <lambdabot>  Terminated
20:00:32 <lambdabot>   mueval-core: Time limit exceeded
20:00:32 <jmcarthur> ...
20:00:35 <revenantphx> > text . unwords . map (reverse . words "Hello world")
20:00:37 <lambdabot>   Couldn't match expected type `a -> [GHC.Types.Char]'
20:00:37 <lambdabot>         against inferr...
20:00:43 <revenantphx> well I messed up.
20:00:47 <revenantphx> :P
20:00:52 <jmcarthur> no error for my command?
20:01:04 <jmcarthur> > System.Directory.removeFile "/etc/passwd"
20:01:05 <lambdabot>   Not in scope: `System.Directory.removeFile'
20:01:08 <jmcarthur> oh
20:01:11 <revenantphx> > System.Directory.removeFile "/"
20:01:11 <lambdabot>   Not in scope: `System.Directory.removeFile'
20:01:17 <revenantphx> pooh.
20:01:55 <mm_freak> > unwords . map reverse . words $ "This is a test."
20:01:57 <lambdabot>   "sihT si a .tset"
20:02:57 <revenantphx> there we go :\
20:03:09 <mm_freak> > splitAt 7 . drop 27 $ cake
20:03:10 <lambdabot>   (["Two slash three cups granulated rhubarb.","One tablespoon all-purpose rh...
20:03:17 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
20:03:18 <lambdabot>   ("TOOTOOT","ASCIICAT")
20:04:27 <revenantphx> cake
20:04:29 <revenantphx> > cake
20:04:30 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:04:36 <revenantphx> ... why is this... defined
20:04:42 <revenantphx> > cake.nub
20:04:43 <lambdabot>   Couldn't match expected type `a -> b'
20:04:43 <lambdabot>         against inferred type `[[GHC....
20:04:47 <mm_freak> i don't know
20:04:52 <revenantphx> lol ouch, I relapsed to python for a sec
20:04:57 <mm_freak> > map head cake
20:04:58 <lambdabot>   "OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT"
20:04:59 <revenantphx> > nub cake
20:05:00 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
20:05:00 <EvanCarroll> why not use `:` for ByteStrings, why did they go with `cons`
20:05:19 <EvanCarroll> that seems awkward, why not just make TypeClass Listable that requires `:` and pop/push stuff
20:05:42 <revenantphx> > unwords . map reverse . words $ cake
20:05:43 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:05:43 <lambdabot>         against inferred type...
20:05:51 <revenantphx> rage.
20:05:52 <jmcarthur> maybe because (:) is not an efficient ByteString operation in the first place
20:06:14 <mm_freak> EvanCarroll: i complained about that a few times, but you don't want to use 'cons' anyway
20:06:17 <jmcarthur> > map (unwords . map reverse . words) $ cake
20:06:18 <lambdabot>   ["enO 52.81 ecnuo egakcap etalocohc ekac .xim","enO nac deraperp tunococ na...
20:06:41 <jmcarthur> :t cake
20:06:44 <lambdabot> [[Char]]
20:06:50 <revenantphx> ah, thats why
20:07:35 <revenantphx> > map (unwords . map reverse . words) $ cake
20:07:36 <lambdabot>   ["enO 52.81 ecnuo egakcap etalocohc ekac .xim","enO nac deraperp tunococ na...
20:07:42 <revenantphx> hm...
20:07:47 <EvanCarroll> mm_freak: because I want cons'?
20:08:05 <revenantphx> > map $ unwords . map reverse . words $ cake
20:08:06 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
20:08:06 <lambdabot>         against inferred type...
20:08:12 * revenantphx is playin
20:08:13 <mm_freak> EvanCarroll: you don't want to prepend characters to bytestrings
20:08:21 <jmcarthur> EvanCarroll: but why do you want cons? perhaps you are using the wrong data structure
20:08:25 <mm_freak> EvanCarroll: because that involves some heavy memory operations
20:09:00 <EvanCarroll> mm_freak: I want to prepend one bytstring, to another ByteString
20:09:06 <mm_freak> EvanCarroll: (unless you use lazy bytestrings)
20:09:06 <revenantphx> > map (unwords . map head . words) $ cake
20:09:07 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:09:07 <lambdabot>         against inferred ty...
20:09:11 <EvanCarroll> ghci> foldr B.cons B.empty [50..60]  
20:09:12 <mm_freak> EvanCarroll: then 'append' is your friend
20:09:16 <jmcarthur> EvanCarroll: sounds like concatenation, not cons
20:09:22 <EvanCarroll> why is append my friend?
20:09:26 <EvanCarroll> I'm reading learn you a haskell
20:09:31 <jmcarthur> because append concatenates
20:09:34 <jmcarthur> cons doesn't
20:09:34 <mm_freak> EvanCarroll: because 'cons' prepends a single character
20:09:39 <mm_freak> :t B.cons
20:09:40 <lambdabot> Couldn't find qualified module.
20:09:46 <mm_freak> :t Data.ByteString.cons
20:09:47 <EvanCarroll> mm_freak: No in Data.ByteString
20:09:47 <lambdabot> Word8 -> BSC.ByteString -> BSC.ByteString
20:09:59 <mm_freak> :t Data.ByteString.append
20:10:00 <jmcarthur> :t Data.ByteString.cons
20:10:00 <lambdabot> BSC.ByteString -> BSC.ByteString -> BSC.ByteString
20:10:01 <lambdabot> Word8 -> BSC.ByteString -> BSC.ByteString
20:10:07 <revenantphx> :t Data.ByteString.append
20:10:07 <lambdabot> BSC.ByteString -> BSC.ByteString -> BSC.ByteString
20:10:09 <copumpkin> his example looks like he wants cons
20:10:13 <jmcarthur> EvanCarroll: if you have two bytestrings, you want append
20:10:13 <copumpkin> but it's not good for bytestrings
20:10:16 <mm_freak> ah, it's named BSC in lambdabot
20:10:18 <sbahra> Hi copumpkin 
20:10:19 <EvanCarroll> I'm confused.
20:10:24 <copumpkin> hi sbahra 
20:10:25 <EvanCarroll> copumpkin: you speak!
20:10:28 <copumpkin> :)
20:10:36 <mm_freak> EvanCarroll: 'cons' corresponds to (:) for lists
20:10:39 <mm_freak> not to (++)
20:10:46 <mm_freak> > 'a' : "bc"
20:10:47 <lambdabot>   "abc"
20:10:53 <sbahra> copumpkin, bored? Have some minutes to spare looking over a project I plan on releasing end of this month? 
20:10:57 <mm_freak> > "Hello " ++ "world!"
20:10:57 <copumpkin> [05:08:47 AM] â€¹ EvanCarroll â€º ghci> foldr B.cons B.empty [50..60]  
20:10:58 <lambdabot>   "Hello world!"
20:11:04 <copumpkin> why do people keep suggesting append to him? :P
20:11:08 <EvanCarroll> what do I want, what is wrong with cons? how does it compare with append? and why isn't the behavoir of a list encompassed in a typeclass that all of the other stuff (ByteStrings, ByteStrings.Lazy etc) use
20:11:14 <copumpkin> sbahra: about to go to sleep, but I can take a quick glance :)
20:11:19 <sbahra> cool
20:11:31 <sbahra> let me tar it up for you, PM good?
20:11:34 <copumpkin> sure
20:11:41 <mm_freak> EvanCarroll: ah, in that case you want snoc and foldl =)
20:11:46 <mm_freak> or 'pack'
20:11:51 <EvanCarroll> mm_freak: you're confusing the shit out of me.
20:11:54 <EvanCarroll> =(
20:11:58 <mm_freak> :t BSC.pack
20:11:59 <lambdabot> String -> BSC.ByteString
20:12:32 <EvanCarroll> I'll ask on SO
20:12:46 <EvanCarroll> I'm not yet convince irc is a suitable medium for any Haskell questions.
20:13:36 <mm_freak> EvanCarroll: on IRC you should always give source code, otherwise your question will lead to confusing answers, because we don't magically know your application
20:14:09 <jmcarthur> copumpkin: we keep suggesting append because he keeps insisting that he wants to put two ByteStrings together
20:14:13 <revenantphx> whuch is why theres hpaste and gist
20:14:19 <revenantphx> @where paste
20:14:19 <lambdabot> http://hpaste.org/ http://codepad.org/
20:14:20 <copumpkin> aha :)
20:14:22 <revenantphx> :)
20:14:26 <copumpkin> his example didn't look like it though
20:14:28 * copumpkin shrugs
20:14:30 <jmcarthur> agreed
20:15:06 <mm_freak> jmcarthur: that's probably because in other languages there is no distinction between an element and a singleton list
20:15:32 <jmcarthur> mm_freak: i can't think of many like that
20:15:38 <mm_freak> that makes those languages get along with a single operation for putting lists together
20:15:44 <EvanCarroll> I'm learning, there is no source code:"22:12 < EvanCarroll> that seems awkward, why not just make TypeClass Listable that requires `:` and pop/push stuff
20:15:48 <EvanCarroll> "
20:16:09 <jmcarthur> EvanCarroll: a ByteString is more like an array than like a list
20:16:20 <jmcarthur> cons is not an efficient operation for ByteStrings
20:16:22 <mm_freak> EvanCarroll: because it would be difficult to incorporate into the base library without breaking stuff
20:16:29 <pikhq> Yeah, I can't think of any languages like that. I can only think of some which have overloaded list joining to allow elements as well.
20:16:44 <mm_freak> pikhq: exactly
20:17:24 <mm_freak> but that's not even the pointâ€¦  in other languages with a string type, you would just append/prepend singleton strings
20:17:58 <mm_freak> TCL, python, PHP, etc.
20:18:26 <pikhq> To be fair, Tcl doesn't know what non-strings are.
20:18:32 <mm_freak> in fact some languages don't have a separate character type
20:18:35 <mm_freak> yeah
20:18:41 <mm_freak> anyway
20:18:43 <jmcarthur> well, ruby isn't in that list. i just checked
20:18:48 <mm_freak> that fold really looks like BS.pack
20:19:00 <mm_freak> :t BS.pack
20:19:01 <lambdabot> [Word8] -> BSC.ByteString
20:19:10 <mm_freak> > BS.pack [65, 66, 67, 68]
20:19:12 <lambdabot>   "ABCD"
20:19:21 <EvanCarroll> what is wrong with assembling a bytestring using cons' ?
20:19:28 <EvanCarroll> why should i do it using append in the reverse order?
20:19:38 <EvanCarroll> :src Data.Bytestring.cons'
20:19:41 <mm_freak> EvanCarroll: you should use snoc, when appending single characters
20:19:42 <EvanCarroll> @src Data.Bytestring.cons'
20:19:43 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:20:00 <jmcarthur> EvanCarroll: every time you use cons you have to copy the entire bytestring
20:20:21 <jmcarthur> EvanCarroll: same applies to append, but at least with append you can add more than one element at a time
20:20:22 <mm_freak> the reason is this:  the string has a certain memory location and you can't extend allocated memory in the left direction, only in the right direction and only sometimes
20:20:39 <mm_freak> so using 'cons' requires copying the entire bytestring
20:21:04 <mm_freak> using 'snoc' only extends the buffer in certain steps
20:21:23 <mm_freak> not with every character that is
20:22:05 <EvanCarroll> @src snoc
20:22:05 <lambdabot> Source not found. Wrong!  You cheating scum!
20:22:13 <EvanCarroll> @src Data.List.snoc
20:22:13 <lambdabot> Source not found. You untyped fool!
20:23:04 <revenantphx> mm_freak: It probably goes through realloc
20:23:07 <mm_freak> there is no snoc for lists
20:23:29 <mm_freak> revenantphx: yes, but realloc may need to copy memory, if the buffer grows
20:23:34 <revenantphx> realloc checks if it can allocate consecutive blocks of memory, and if it can't fit directly to the "right" it allocates somewhere else and copies.
20:23:51 <revenantphx> mm_freak, if it can't fit in the free space to the write of the currently allocated space ,it has to copy/grow
20:24:36 <jmcarthur> well, it doesn't actually allocate a new block to the right. it actually attempts to resize the current block. if it had the former behavior then freeing the first block wouldn't free the second ;)
20:24:55 <revenantphx> it attempts to allocate additional blocks to the right and merges their records somehow
20:25:05 <jmcarthur> that would be growing the original block :P
20:25:10 <revenantphx> the result is as if it were growing, yes.
20:25:33 <EvanCarroll> http://stackoverflow.com/questions/3623612/in-haskell-why-isnt-there-a-typeclass-for-things-that-can-act-like-lists
20:26:11 <jmcarthur> EvanCarroll: the answer to your question is that people just don't use cons for ByteString, like we've been saying all along
20:26:28 <jmcarthur> it hasn't been seen as important enough to push for
20:26:37 <djahandarie> It also exists
20:26:43 <jmcarthur> ListLike is horrible
20:26:50 <djahandarie> :-(
20:26:52 <EvanCarroll> oh nifty
20:26:54 <jmcarthur> it has waaaay more than just (:)
20:27:02 <Veinor> I think part of it is to let you reason about big-O performance
20:27:03 <EvanCarroll> What has List.Like?
20:27:13 <Veinor> in a nice way
20:27:14 <djahandarie> @hackage ListLike
20:27:14 <lambdabot> http://hackage.haskell.org/package/ListLike
20:27:28 <jmcarthur> EvanCarroll: http://hackage.haskell.org/packages/archive/ListLike/1.0.2/doc/html/Data-ListLike.html#t%3AListLike
20:27:30 <jmcarthur> have fun
20:28:15 <EvanCarroll> that's nifty!
20:28:22 * jmcarthur facepalms
20:28:27 <EvanCarroll> that's exactly what I'm talking about.
20:28:39 <jmcarthur> it's an abomination
20:29:22 <EvanCarroll> I don't think so, it is a typeclass for things that can act like a list..
20:29:26 <djahandarie> Oh sweet, new Oleg e-mail
20:29:32 <djahandarie> Why doesn't he just start a damn blog?
20:30:04 <jmcarthur> EvanCarroll: it's completely ad hoc and has no real specification or theory behind it at all. nothing justifies its complexity
20:30:31 <jmcarthur> djahandarie: which mailing list? i'm not seeing it
20:30:41 <EvanCarroll> why do you feel like a typeclass the makes states a contract for list-like stuff is complex?
20:31:00 <EvanCarroll> why do you prefer having to memorize `cons` and `:` and which list-like structure requires which
20:31:19 <jmcarthur> EvanCarroll: i don't prefer memorizing cons. i prefer not *using* cons. it's a horrible fit for ByteString
20:31:33 <jmcarthur> i can't help but feel that you're trolling. you're not really listening to anybody's advice
20:31:35 <djahandarie> jmcarthur, haskell
20:31:44 <EvanCarroll> You still haven't made clear /why/ it is horrible for bytestring and : is preferred for lists.
20:31:50 <mm_freak> EvanCarroll: in general for different data structures you use different manipulations
20:31:59 <EvanCarroll> In fact 95% of your rant has been educational at a level that I don't appreciate yet.
20:32:02 <jmcarthur> EvanCarroll: because (:) is O(1) for lists, but O(n) for ByteStrings. we've said this several times now
20:32:24 <jmcarthur> EvanCarroll: if you want (:), use lists
20:32:30 <mm_freak> EvanCarroll: in simple words: cons is slooooooow
20:32:32 <mm_freak> get it?
20:32:46 <EvanCarroll> why are bytestrings not lists, they're just lists of [Word8] why would someting work totally different..
20:32:54 <mm_freak> no, they are not
20:33:01 <mm_freak> they are byte arrays in memory
20:33:04 <mm_freak> lists are linked lists
20:33:13 <jmcarthur> djahandarie: ah it's from earlier. that's why i missed it
20:33:20 <EvanCarroll> that would have been important to emphacize.
20:33:31 <jmcarthur> EvanCarroll: we also already told you that
20:33:49 <jmcarthur> "EvanCarroll: a ByteString is more like an array than like a list"
20:34:25 <EvanCarroll> so you're not supposed to use : on arrays?
20:34:34 <jmcarthur> you can if you want, but it's not encouraged
20:34:38 <mm_freak> EvanCarroll: ever programmed in C?
20:34:41 <jmcarthur> because you have to copy the whole thing
20:34:53 <EvanCarroll> mm_freak: much more than haskell at this point
20:35:11 <mm_freak> EvanCarroll: good, now given an array:  char foo[32];
20:35:18 <mm_freak> what do you do to /prepend/ a character to it?
20:35:29 <EvanCarroll> jmcarthur: right, I follow. I'm just reading learn you a haskell and didn't know that lists were linked-lists, or that arrays/bytestrings were set up to be contigious blocks of memmory
20:35:43 <jaredj> mm_freak: foo[-1] = c; 
20:35:45 <jmcarthur> yeah, and we cleared that up earlier
20:35:47 <EvanCarroll> jaredj: haha
20:35:48 <mm_freak> jaredj: lol
20:35:53 <EvanCarroll> I follow now.
20:35:53 <jmcarthur> awesome jaredj 
20:36:12 <mm_freak> EvanCarroll: alright, question answered =)
20:36:20 <jaredj> :)
20:36:42 <EvanCarroll> Is there a guideabout the underlying implimentations with gotchas or something for the different modules in the prelude?
20:36:49 <mm_freak> in fact, even appending a character is a heavy operation in C, unless you keep a pointer to the end of the string =)
20:36:51 <EvanCarroll> I'd like not to travel down this path again
20:37:02 <mm_freak> but a ByteString knows its end, so it's a fast operation
20:37:21 <djahandarie> http://www.reddit.com/r/haskell/comments/d8dck/lemmachine_a_web_framework_in_agda/
20:37:24 <djahandarie> Awesome
20:37:27 <djahandarie> I met the guy who did that too
20:37:30 <jaredj> EvanCarroll: i'm reading "Real World Haskell" and so far it has warned of several pitfalls that everyone in here but me knows about 
20:38:07 <EvanCarroll> jaredj: please do warn me too.
20:38:27 <EvanCarroll> because I didn't pick them up.
20:39:22 <mm_freak> EvanCarroll: the documentation usually gives you performance hints
20:39:29 <mm_freak> mostly in form of big-O notation
20:42:33 <jaredj> EvanCarroll: example: it said foldl could cause stack overflows if used on huge (millions) lists, owing to the stacks of thunks created; someone from a non-lazy language wouldn't know that
20:48:37 <mm_freak> in fact prepending a single character is a fast operation for lazy lists
20:48:57 <mm_freak> uhm
20:49:00 <mm_freak> for lazy bytestrings
20:49:19 <mm_freak> so using foldr with cons for lazy bytestrings is a fast operation
20:49:48 <mm_freak> also with some minor modifications prepending single characters can be a fast operation even for strict bytestrings
20:51:38 <mm_freak> data ByteString = BS { bsMemory :: Ptr Word8, bsBufferSize :: Int, bsOffset :: Int, bsLength :: Int }
20:55:39 <EvanCarroll> How should I remember fromChunks and toChunks, how do you think of these functions
20:55:58 <lispy> EvanCarroll: lazy bytestrings are [ByteString]
20:56:13 <lispy> EvanCarroll: so I think of lazy bytestring as list of chunks of strict bytestrings
20:56:24 <lispy> EvanCarroll: so then it's easy.  fromChunks must convert to strict
20:56:25 <EvanCarroll> LYAH has me kind of confused, because it defines a chunked bytestring as a lazy one, and yet toChunks takes a lazy bytestring and returns a stricict ones
20:56:42 <EvanCarroll> strict*
20:56:56 <lispy> Wait, what is the type?
20:57:07 <lispy> L.ByteString -> [S.ByteString] ?
20:57:10 <EvanCarroll> ghci> B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]  
20:57:17 <EvanCarroll> lispy: yar
20:57:17 <lispy> ?hoogle toChunks
20:57:18 <lambdabot> Data.ByteString.Lazy toChunks :: ByteString -> [ByteString]
20:57:18 <lambdabot> Data.ByteString.Lazy.Char8 toChunks :: ByteString -> [ByteString]
20:57:25 <kmc> toChunks :: Lazy.ByteString -> [Strict.ByteString]
20:57:35 <kmc> EvanCarroll, Haddock never shows qualified names even when there's a clash
20:57:36 <lispy> EvanCarroll: ah, okay.  so toChunks is giving you the chunks that compose the lazy bs
20:57:47 <kmc> so it says "toChunks :: ByteString -> [ByteString]" but those are two different "ByteString" types
20:57:49 <kmc> confusing eh
20:57:56 <kmc> you can click through to see it
20:57:58 <EvanCarroll> lispy: ah!
20:58:01 <EvanCarroll> lispy: I love it
20:58:03 <EvanCarroll> lispy: thanks.
20:58:08 <EvanCarroll> lispy: that makes perfect sense.
20:58:45 <EvanCarroll> toChunks isn't a cast, it is an unbox
20:59:06 <lispy> EvanCarroll: right
20:59:15 <kmc> EvanCarroll, btw take a look at Data.Sequence as well
20:59:22 <kmc> as a kind of "middle ground" between lists an arrays
20:59:42 <lispy> EvanCarroll: and actually, it makes a lot of sense because you can stream a lazy bs into a list of strict ones.  So you haven't evaluated it, you've just changed the type
21:00:10 <kmc> you can add elements to the beginning/end, append two Seqs, or index by an Int all with reasonable efficiency
21:00:18 <lispy> if lazy IO were safe, lazy bytestring would be one of the coolest things ever...
21:00:39 <EvanCarroll> rock on.BON	/ms/win next
21:00:51 <kmc> and you can update with only a logarithmic amount of copying
21:01:25 <EvanCarroll> lispy: I'm wish I could star IRC and ask questions about that statement in a few months..
21:01:29 * lispy met shachaf today.  Seems like a nice lad.
21:01:37 <EvanCarroll> I think Google needs to work on irssi.
21:01:52 <lispy> EvanCarroll: hehe.  Well, no worries.  We like questions
21:02:03 <kmc> most of the update is shared with the original
21:02:03 <kmc> it's a cool data structure, check it out
21:02:23 <kmc> you could copy it to a text file
21:03:12 <kmc> EvanCarroll, btw lists in Haskell are, aside from syntactic sugar, equivalent to this data type:
21:03:16 <kmc> data List a = Nil | Cons a (List a)
21:03:33 <kmc> from this you know that they're singly linked lists
21:03:50 <kmc> (with some assumptions about how your Haskell compiler implements Haskell)
21:04:12 <kmc> @src []
21:04:12 <lambdabot> data [] a = [] | a : [a]
21:04:33 <EvanCarroll> kmc: some assumptions that I wasn't ready to make.
21:04:50 <EvanCarroll> I'm still reading a tutorial with pictures of robots drawn by a drunk 8 year old with his left hand ;)
21:04:53 <kmc> haha
21:05:21 <lispy> We need a learn you an agda
21:05:41 <EvanCarroll> I'm not sure how you would impliment a real array in haskell.. so it seems unfair to for me to assume only a List is implimented like that.
21:05:45 <kmc> EvanCarroll, assume for now that each data constructor is like a struct in memory, and each field of a data constructor is a pointer to another constructor
21:06:01 <lispy> That's a good question, how is IOUArray implemented?
21:06:05 <kmc> EvanCarroll, you can't implement a "real array" (meaning contiguous blocks of memory) without some support from the implementation
21:06:11 <kmc> it's not an algebraic data type
21:06:15 <lispy> is it a wrapper around a foreign ptr to a block of memory?
21:06:31 <EvanCarroll> kmc: so without knowing how to do that, it doesn't make sense for me to assume anything about List, unless someone smarter like yourself tells me it is.
21:06:43 <EvanCarroll> And, that space was taken up by the Robot.
21:06:52 <lispy> heh
21:07:24 <kmc> newtype IOUArray i e = Data.Array.IO.Internals.IOUArray (Data.Array.Base.STUArray GHC.Prim.RealWorld i e)
21:07:26 <EvanCarroll> j/k (I actually like the robot, I'd probably mail bomb the RWH address if not for a reasonable tutorial with comic relief)
21:07:35 <kmc> not so informative
21:07:38 <kmc> but let's look at STUArray
21:07:52 <EvanCarroll> kmc: I will in due time, I don't want to go down the RWH learning path
21:07:58 <kmc> data STArray s i e = GHC.Arr.STArray !i !i !Int (GHC.Prim.MutableArray# s e)
21:08:06 <kmc> i was responding to lispy
21:08:11 <EvanCarroll> I'm perfectly content with accepting it is implimentaiton voodoo, for the time being
21:08:14 <EvanCarroll> ah
21:10:19 <kmc> GHC.Prim is the magical module with no Haskell source
21:10:44 <jaredj> newtype GenParser tok st a = ...
21:10:50 <jaredj> i know what tok and st are
21:10:56 <jaredj> what's a? (brainfart)
21:11:01 <kmc> the result type of the parser
21:11:06 <jaredj> ah thanks
21:11:23 <kmc> GenParser Char () MyProgramType
21:11:24 <wli> I wonder if I'm the only one who uses whole word type variable names.
21:11:25 <QtPlatypus> Typically "a" is used for arbitory result type
21:12:10 <QtPlatypus> :t undefined
21:12:11 <lambdabot> forall a. a
21:12:34 <QtPlatypus> wli: I tend to use them as well.
21:13:19 <tehgeekmeister> modules export all definitions by default, no?
21:13:20 * QtPlatypus dislikes that most of the libaries don't use them.
21:13:33 <jaredj> mwahahaha.
21:14:36 <jaredj> night all.
21:14:41 <enigmus> Is there a 'placeholder' expression in Haskell? Something that would have type a, like ... in Perl, pass in Python or ? in Agda ?
21:15:05 <tehgeekmeister> enigmus: think you want undefined
21:15:10 <QtPlatypus> enigmus: undefined
21:15:26 <lispy> enigmus: error "Blaha!!!!!" -- this works too
21:15:27 <QtPlatypus> :t undefined
21:15:28 <lambdabot> forall a. a
21:15:41 <jaredj> :t error
21:15:41 <lambdabot> forall a. [Char] -> a
21:15:44 <lispy> enigmus: but you don't want to evaluate it
21:15:49 <lispy> > fix undefined
21:15:49 <lambdabot>   *Exception: Prelude.undefined
21:15:56 <tehgeekmeister> yes, they both blow up
21:15:58 <lispy> > fix error
21:15:58 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
21:16:12 <enigmus> Thanks guys.
21:16:21 <lispy> enigmus: YOU ARE VERY WELCOME
21:16:29 <lispy> i mean, np
21:16:31 <jaredj> yeah, thanks for getting to the bottom of that
21:16:37 <jaredj> ;o
21:16:44 <lispy> jaredj: oh, bad pun!
21:16:52 <tehgeekmeister> oh that's horrible
21:17:24 <tehgeekmeister> why would some, but not all, of my definitions in a module be exported/imported (i'm using vanilla imports and module lines)
21:17:26 <tehgeekmeister> ?
21:17:49 <lispy> tehgeekmeister: What error are you getting?
21:18:03 <tehgeekmeister> lispy: src/Main.hs:41:6: Not in scope: `importWiktionaryTitles'
21:18:06 <kmc> enigmus, there is a patch somewhere to add Agda-like holes to GHC, meaning you could put ? in your editor and ask for its type
21:18:06 <lispy> tehgeekmeister: and by vannila you mean "module Foo where <code starts here>" ?
21:18:12 <tehgeekmeister> lispy: yeah
21:18:18 <tehgeekmeister> lispy: and import Foo
21:18:34 <kmc> tehgeekmeister, it won't re-export stuff you imported unless you say so explicitly
21:18:41 <lispy> tehgeekmeister: Is it possible you have a spelling or case mismatch?
21:18:55 <tehgeekmeister> lispy: two lines above the call to importWiktionaryTitles i call another function from the same file with no issues
21:19:02 <tehgeekmeister> lispy: thought of that, used copy and paste
21:19:06 <kmc> enigmus, "pass" in python is another thing entirely.  it's not an expression, it's a do-nothing statement.  the equivalent in Haskell would be "return ()"
21:19:09 <tehgeekmeister> kmc: nah, this is in the file i'm importing itself
21:19:52 <lispy> tehgeekmeister: I'm not sure I can comment further without seeing an hpaste :)
21:19:59 * QtPlatypus has been playing with "data Node index a = Node index a a" to create binary tree like structures but rapidly found that searching a tree of aribitory depth requires a function that seems impossable to type.  Am I missing something or is this a passage down wich others more intelegent then I have passed and discovered failure as well"
21:21:08 <tehgeekmeister> lispy: nested do expressions wouldn't hide something?
21:21:23 <tehgeekmeister> lispy: okay, i'll poke at it for a few more minutes and if i don't figure it out i'll paste
21:21:49 <kmc> QtPlatypus, you want that, as opposed to "data Node index = Node index (Node index a) (Node index a)"?
21:21:55 <tehgeekmeister> wait, it's not compiling enough files
21:21:57 <tehgeekmeister> that's a problem
21:22:02 <tehgeekmeister> i'll investigate that first
21:22:26 <lispy> tehgeekmeister: cool.  Don't hesitate to ask if you get stuck again
21:22:28 <kmc> QtPlatypus, because you want to know the depth in the type?
21:22:37 <tehgeekmeister> lispy: i won't, thanks.  =]
21:22:52 <kmc> err drop the 'a' from mine
21:23:39 <kmc> anyway, Â«Node i ()Â» is the type of depth-1 trees, Â«Node i (Node i ())Â» the type of depth-2 trees, etc
21:23:39 <QtPlatypus> kmc: Yes I wish to know the dept as a part of the type so that operations force the tree to remain compleatly balanced.
21:23:51 <kmc> the type of infinite-depth trees is Â«Mu (Node i)Â»
21:24:20 <QtPlatypus> kmc: Mu is the fixed point operator for types?
21:24:22 <kmc> yes
21:24:23 <kmc> @src Mu
21:24:24 <lambdabot> newtype Mu f = In { out :: f (Mu f) }
21:25:10 <kmc> QtPlatypus, maybe something like this will be easier to work with: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29664#a29664
21:26:32 <kenjin2201> I want to do something like (setf (funcall ...) obj). What should I look up?
21:26:50 <kmc> kenjin2201, i have no idea what setf / funcall are, or indeed what language you intend that to be
21:27:06 <Zao> kmc: Smells like a LISP.
21:27:06 <kmc> maybe you can describe the problem rather than giving us solutions in another language?
21:27:16 <kenjin2201> Sorry. I thought I was in Lisp channel. Sorry again :)
21:27:21 <kmc> ah, no problem :)
21:27:26 <Martty> this is me coding c++ a la haskell
21:27:32 <Martty> http://codepad.org/WRYUWVOd
21:27:34 <Martty> and failing
21:27:50 <Martty> not sure why its getting in an infinite loop ..
21:27:50 * kmc coded the Y combinator in C++ once
21:27:57 <QtPlatypus> kmc: I think I will have to read up more on GADTs to understand that.
21:28:00 <Zao> Martty: You _are_ aware of Boost.Assign, right?
21:28:15 <Martty> no
21:28:21 <kmc> if you want to do "Haskell in C++" look at Boost, it has some helpful libraries
21:28:28 <kmc> e.g. Maybe and tuples implemented in ~5000 lines of code
21:28:33 <Zao> using namespace boost::assign; std::vector<int> v; v += 42, 3, 5, 7;
21:28:39 <Martty> oh that
21:28:42 <Martty> thats no problem
21:28:43 <kmc> actually, if you want to code C++ at all and not make a horrible mess of it, you might should learn boost
21:28:53 <kmc> but it will still be a horrible mess ;)
21:28:54 <Zao> Or say, vector<int> v = list_of(42)(3)(5); // :D
21:29:04 <m3ga> boost::variant is complete crack
21:29:07 <Martty> im more worried at partition right now
21:29:10 <Martty> which is part of the std lib
21:29:13 <Zao> If you want to do things like fold over tuples and such, look at fusion and MPL.
21:29:14 <kmc> QtPlatypus, ok. any particular bit i can help you understand?
21:29:58 <Zao> Martty: Note that partition is not stable, if that matters.
21:30:12 <kmc> boost::variant is cute
21:30:21 <kmc> if you squint just right their "visitors" look like pattern-matching
21:30:47 <Martty> Zao: nope
21:30:52 <ski> QtPlatypus : perfectly balanced tree : `data Tree a = Leaf a | Double (Tree (a,a))'
21:37:22 <lispy> ski: Nice
21:37:49 <lispy> ski: but is that really true?
21:49:23 <periodic> Is there a function that returns the fractional part of a float?
21:49:46 <periodic> I have truncate for the non-fractional part, but I can't seem to find a function for the fractional part.
21:50:01 <periodic> Other than \f -> f - (truncate f)
21:50:29 <Veinor> I don't believe so
21:50:34 <kmc> no mod for floats :/
21:50:47 <Zao> No fmod?
21:50:55 <kmc> @hoogle fmod
21:50:55 <lambdabot> Network.HTTP.Headers HdrIfModifiedSince :: HeaderName
21:51:01 <periodic> apparently not.
21:51:10 <kmc> :(
21:51:13 <Veinor> > snd . properFraction $ 2.71828
21:51:14 <lambdabot>   0.71828
21:51:18 <Veinor> > snd . properFraction $ -2.71828
21:51:19 <lambdabot>   -0.71828
21:51:29 <Zao> Too bad that Float is not CFloat, otherwise it'd be a foreign import away.
21:51:34 <Zao> @type properFraction
21:51:35 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> (b, a)
21:51:58 <periodic> Alright, well, that will do, Veinor.  Thanks.
21:53:03 <revenantphx> Guys.
21:53:07 <revenantphx> I've reached a conclusion.
21:53:09 <revenantphx> Haskell is magic.
21:53:20 <revenantphx> It's powered by magic, it's the only logical conclusion.
21:53:26 <periodic> it is true.
21:53:46 <revenantphx> Using this as my main theorem, I can prove the existence of the Tooth Fairy
21:53:53 <periodic> Carl Sagan agrees.
21:54:01 <tehgeekmeister> is there function that does fmap fmap
21:54:02 <tehgeekmeister> ?
21:54:06 <tehgeekmeister> err
21:54:07 <revenantphx> ?
21:54:09 <tehgeekmeister> fmap . fmap
21:54:14 <Veinor> :t fmap . fmap
21:54:15 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:54:17 <c_wraith> No.  Just use fmap. :)
21:54:21 <mtnviewmark> oh - i thought it was powered by small hairless moles....
21:54:22 <tehgeekmeister> fiiiiiine
21:54:31 <revenantphx> or write one that doubles it  > >
21:55:08 <revenantphx> if its not there, write it.
21:55:14 <mtnviewmark> :t fmap . fmap
21:55:16 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:55:20 <mtnviewmark> :t fmap fmap fmap
21:55:21 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:55:23 <mtnviewmark> !
21:55:39 <tehgeekmeister> yo dawg yo, i heard you like functors, so i put some functors in your functors so you can fmap while you fmap
21:55:51 <Veinor> fmap in the (->) monad is just (.)
21:56:09 <mtnviewmark> :t (.) (.) (.)
21:56:10 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:56:18 <Veinor> and that's caleskell being silly
21:56:35 <mtnviewmark> :t [fmap . fmap, fmap fmap fmap, (.) (.) (.)]
21:56:36 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => [(a -> b) -> f (f1 a) -> f (f1 b)]
21:56:38 <c_wraith> :t (.).(.)
21:56:39 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Functor f1) => (a -> b) -> f (f1 a) -> f (f1 b)
21:56:45 * kmc is nostalgic for the days when he thought Haskell was magic
21:56:55 <revenantphx> :t (.)
21:56:56 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
21:57:09 <revenantphx> :t (magic)
21:57:10 <lambdabot> Not in scope: `magic'
21:57:13 <revenantphx> :O
21:57:16 <tehgeekmeister> kmc: what is it now?
21:57:18 <QtPlatypus> > fix fmap
21:57:20 <lambdabot>   Occurs check: cannot construct the infinite type: a = f a
21:57:23 <kmc> tehgeekmeister, a programming language
21:57:23 <mtnviewmark> mind you, i don't think that is what you'll see from ghci with just Prelude
21:57:23 <revenantphx> > let magic = magic in magic
21:57:27 <lambdabot>   mueval-core: Time limit exceeded
21:57:41 <Veinor> mtnviewmark: yeah, (.) in prelude is only function composition
21:57:42 <kmc> revenantphx, if you put that in a compiled program ghc will detect the infinite loop :O
21:57:43 <revenantphx> see? magic is finfinite.
21:57:51 <revenantphx> infinite*
21:57:58 <mtnviewmark> ghci sez:   > :t (.)
21:57:58 <mtnviewmark> (.) :: (b -> c) -> (a -> b) -> a -> c
21:58:03 <Veinor> > (sin^2 + cos^2) 0.314
21:58:04 <lambdabot>   1.0
21:58:04 <kmc> :t (Prelude..)
21:58:05 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
21:58:08 <Veinor> that also will not work in the Prelude
21:58:11 <Veinor> it works because of evil
21:58:36 <QtPlatypus> Is there a libary you can get to make it caleskell?
21:58:41 <revenantphx>  btw
21:58:47 <revenantphx> is it possible to define actual infix operators?
21:58:52 <Veinor> yep
21:58:55 <revenantphx> I'm noticing (infix) as a pattenr al ot
21:59:00 <revenantphx> I'm guessing just add parnes?
21:59:03 <revenantphx> parens*
21:59:08 <kmc> > let _ +++++ _ = "hello there" in 2 +++++ 3
21:59:09 <lambdabot>   "hello there"
21:59:15 <Veinor> > let a **++ b = a * b + a + b in 2 **++ 3
21:59:16 <lambdabot>   11
21:59:23 <Veinor> > let (**++) a b = a * b + a + b in 2 **++ 3
21:59:24 <lambdabot>   11
21:59:38 <revenantphx> cool
21:59:44 <kmc> revenantphx, when you put symbols in parens it becomes an ordinary prefix name
21:59:51 <QtPlatypus> revenantphx: Only works for punciation type things.
22:00:06 <kmc> revenantphx, conversely, an alphanumeric name in backticks is an infix operator
22:00:07 <revenantphx> I see what you mean
22:00:11 <kmc> > 5 `mod` 2
22:00:12 <lambdabot>   1
22:00:12 <QtPlatypus> > 123 `mod` 4
22:00:13 <lambdabot>   3
22:00:14 <revenantphx> kmc: this i am aware off
22:00:17 <revenantphx> does that mean I can do...
22:00:22 <revenantphx> `+` 4 5
22:00:25 <kmc> no
22:00:28 <revenantphx> damn
22:00:29 <kmc> > (+) 4 5
22:00:31 <lambdabot>   9
22:00:33 <revenantphx> ok
22:00:40 <kmc> > let plus = (+) in 4 `plus` 5
22:00:42 <lambdabot>   9
22:00:56 <revenantphx> I have to say
22:00:58 <kmc> > let x `plus` y = x + y in 4 `plus` 5
22:00:59 <lispy> > `(+)` 3 4 -- might be cool if this worked but it doesn't
22:00:59 <lambdabot>   9
22:01:00 <lambdabot>   <no location info>: parse error on input ``'
22:01:06 <revenantphx> the use of typeclasses is a pretty nifty way to get polymorphism with no objects
22:01:14 <revenantphx> my ruby friend refuses to understand it...
22:01:16 <revenantphx> I just told him
22:01:17 <kmc> they're not very related
22:01:20 <revenantphx> "Chaz. Magic"
22:01:29 <revenantphx> exactly, but to people who are stuck in OO land they are.
22:01:39 <kmc> revenantphx, the typical sort of polymorphism-with-objects is just accomplished by storing functions in records
22:01:42 <mtnviewmark> :t sin^2
22:01:43 <lambdabot> forall a. (Floating a) => a -> a
22:01:50 <mtnviewmark> :t (^)
22:01:51 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
22:01:55 <kmc> revenantphx, objects are a poor man's closures, and closures are a poor man's objects
22:01:57 <QtPlatypus> revenantphx: Ruby isn't statically typed polymorphism isn't a problem for them.
22:02:21 <mtnviewmark> kmc: I always knew that programming was impoverished 
22:02:31 <revenantphx> You know, people say "non-statically-typed languages make things easier"
22:02:38 <revenantphx> but I personally find that backwards
22:02:49 <revenantphx> if I can't tell what the type is... it bothers me.
22:02:50 <kmc> revenantphx, beginners to Haskell often produce over-complicated designs with many typeclasses and typeclass polymorphism, when they could just store functions as first-class values
22:02:58 <revenantphx> explain?
22:03:00 <QtPlatypus> revenantphx: Its more or less a tast thing.
22:03:04 <QtPlatypus> revenantphx: Its more or less a taste thing.
22:04:00 <QtPlatypus> Static vs Dynamic that is.  
22:04:12 <kmc> uh
22:04:28 <kmc> "taste" implies an arbitrary or irrelevant choice
22:04:39 <kmc> the choice of static or dynamic typing has a massive impact on how you do software development
22:04:48 <revenantphx> kmc: yeah I suppoe.
22:04:56 <revenantphx> I like static usually I guess.
22:04:57 <kmc> revenantphx, dynamic typing makes it easier to just jump in and start coding.  the result is often a mess
22:05:05 <revenantphx> kmc: my feeling exactly.
22:05:06 <kmc> static types force you to invest more up front
22:05:08 <kmc> Haskell particularly
22:05:11 <QtPlatypus> kmc: Yes, but diffrent people are suited in diffrent ways to difrent forms of software development.
22:05:12 <kmc> and some people need instant gratification
22:05:26 <revenantphx> i like the mix of static typing and type inference with haskell
22:05:52 <kmc> yeah
22:05:53 * QtPlatypus comes from a dynamic background and often jumps in and lets the type inference sort it out.
22:05:53 <Pseudonym> That up-front investment is actually debugging.  It just happens to be debugging that takes place _before_ the code is run rather than _after_.
22:06:08 <kmc> most of the hate for static typing is based on a pre-1970's conception of what static types are
22:06:19 <revenantphx> kmc: elaborate?
22:06:37 <Pseudonym> revenantphx: Many people think that "static typing" means "Algol and descendents thereof".
22:06:39 <kmc> people get fed up with the verbosity, clumsiness, and poor safety of the C++ and Java type systems
22:06:47 <kmc> they conclude that static types are more trouble than they're worth
22:06:58 * revenantphx likes C's weakly-typed style.
22:07:04 <kmc> ML was developed in the 1970's and has the same sort of type inference as Haskell
22:07:11 <revenantphx> Casting is only messy if you haven't gottne used to it.
22:07:19 <QtPlatypus> kmc: I would contend that there the static type systems that are common use.
22:07:20 <kmc> C's type system is simple and gets out of your way, but provides almost no safety guarantees
22:07:30 <revenantphx> kmc: I don't mind that.
22:07:44 <Pseudonym> When you've spent enough time on Hindley-Milner type systems, you find that the times you need dynamic typing are the exception rather than the rule.
22:07:52 <Pseudonym> Those times do exist.
22:07:52 <kmc> it's a good fit for certain things (e.g. writing kernels) but usually a pain in the ass and a source of massive security holes
22:07:53 <revenantphx> then things like *(int16_t*) (functionReturningAnArrayOfShorts)
22:08:10 <kmc> i mean it's unforgivable that applications software is written in C and lets people take over my machine with a malformed fucking flash movie
22:08:39 <kmc> revenantphx, you asked earlier about my comment about overusing type classes
22:08:42 <revenantphx> thats probably a stack overflow or buffer overflow of some sort.
22:08:44 <wli> Actually it's got a fair number of problems with writing kernels, though they're not in the direction that anything like ML or Haskell address.
22:08:52 <revenantphx> If you use fixed length functions, you can block thsoe out 
22:09:06 <kmc> revenantphx, here's an example of two ways to encode a sort of OO in haskell: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29665#a29665
22:09:06 * Pseudonym points out that the L4 kernel has been _proven_ correct, hence the problem is not necessarily just that it's written in C
22:09:11 <kmc> the second is the one i generally favor
22:09:13 <revenantphx> almost all exploits on C are overflows.
22:09:30 <revenantphx> the upsidedown A is foreach right
22:09:34 <kmc> for all
22:09:47 <kmc> you might want to ignore that part for now
22:10:00 <revenantphx> I don't see why i'm reading this... > >
22:10:02 <kmc> it's establishing an "existential type"
22:10:04 <Pseudonym> When Windows crashes, it's almost always a buggy driver rather than a buggy kernel.
22:10:10 <kmc> which is not part of standard Haskell, though quite useful
22:10:13 <kmc> (it's implemented in GHC)
22:10:22 <QtPlatypus> revenantphx: For all
22:10:26 <kmc> revenantphx, right, a buffer overflow or other unsafe memory access.  which can't happen in a language with a safe type system, static or dynamic.  that's my whole point.
22:10:43 <kmc> revenantphx, it's to illustrate my point with
22:10:44 <kmc> <kmc> revenantphx, beginners to Haskell often produce over-complicated designs with many typeclasses and typeclass polymorphism, when they could just store functions as first-class values
22:10:54 <kmc> the first part is the "overcomplicated" design
22:10:57 <revenantphx> right...
22:11:00 <kmc> the second one is just storing functions in data
22:11:08 <revenantphx> yeah, the second makes much more sense.
22:11:22 <kmc> but the first is what a lot of people with OOP background write first
22:11:32 <revenantphx> hm
22:11:34 <kmc> because there's this idea that new behavior â‡’ new type
22:11:38 <kmc> but this is really nothing to do with OOP
22:11:44 <revenantphx> Well I spend a good month throwing around function pointers in C... :P
22:11:50 <revenantphx> arrays of function pointers and me are good friends.
22:11:56 <kmc> and just a consequence of the fact that two popular OOP languages happen to lack first-class functions
22:12:00 <revenantphx> as are linked lists (queues)
22:12:06 <kmc> ok
22:12:10 <kmc> but function pointers aren't first-class functions either
22:12:18 <kmc> because you have no simple way to close over free variables
22:12:27 <revenantphx> right
22:12:37 <revenantphx> I mean that I'm more friendly with passing functions as "things"
22:12:40 <kmc> sure
22:12:42 <revenantphx> that concept doesn't bother me whatsoevr.
22:12:46 <lispy> kmc: If we gave away everything for free (esp. variables) we'd all be broke
22:12:46 <kmc> that's good :)
22:12:51 <kmc> since it's one of the core concepts in programming
22:12:59 <kmc> despite what the JavaSchools might teach
22:13:03 <revenantphx> hahaha
22:13:15 <revenantphx> yeaah... I'm now taking "AP Computer Science"
22:13:18 <revenantphx> aka "intro to java"
22:13:23 <QtPlatypus> Oddly enought javascript does it right.
22:13:26 <revenantphx> aka "let's gloss over everything useful"
22:13:44 <kmc> JavaScript is a pretty decent language
22:14:01 <kmc> it's starting to get some appreciation
22:14:04 <revenantphx> this is a god book
22:14:07 <revenantphx> http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742
22:14:23 <revenantphx> good*
22:23:09 <Adamant> Javascript is not bad if you subset it and use modern features and practices
22:23:40 <kmc> Lisp with curly braces, no macros, and no TCO
22:23:50 <Adamant> like a lot of languages, it started out as a infix Scheme
22:23:52 <Adamant> yeah
22:24:07 <Adamant> I wish they would add TCO
22:24:16 <Adamant> there is no excuse at this point not to
22:25:01 <Adamant> I can live with curly braces and no macros, since you can just compile your Lisps or Haskell to that then in a reasonable manner
22:25:28 <kmc> talk to edwardk about compiling tail calls to Javascript ;)
22:25:31 <Adamant> well, Haskell laziness would be tricky, along with type enforcement
22:25:56 <Adamant> kmc: what's he using, the usual mini-interpeter trick that Clojure uses?
22:26:14 <kmc> nah you throw an exception every so often to unwind the stack
22:26:18 <kmc> does Clojure target Javascript?
22:26:23 <Adamant> no, the JVM
22:26:31 <kmc> i know it has a JVM target
22:26:32 <Adamant> same problem, no TCO (until maybe recently)
22:26:50 <kmc> typing is easy, Haskell compilers typically erase types anyway
22:26:56 <kmc> once it type checks statically, you don't care
22:27:07 <Adamant> yeah, i thought about that after I said it
22:27:12 <kmc> laziness is not too bad; there's an example in SICP of implementing laziness in strict Scheme
22:27:28 <Adamant> right, you can always use thunks and delay
22:27:39 <kmc> and closure over mutable variables for the lazy part
22:27:43 <kmc> preventing duplicated work
22:27:47 <Adamant> yeah
22:28:14 <kmc> now, can you implement lazy evaluation in a language with strict evaluation and no mutation?
22:28:30 <kmc> i think not, mutation seems essential to the definition of lazy eval
22:29:37 <Adamant> if you're going to design a new language that's compiled, being able to output Java source, JVM and CLR bytecodes, and web-optimized Javascript would probably be good targets in addition to the usual C/LLVM reps
22:29:54 <Adamant> for source to source translations
22:30:33 <Adamant> kmc: I certainly can't think of a way to do it offhand
22:33:12 <kmc> yes
22:33:40 <kmc> Haskell has had JVM-, CLR-, and Javascript-targeting compilers at various points
22:33:46 <kmc> i don't think any of the projects are still active / working
22:34:00 <kmc> no need for a new language
22:35:33 <kmc> i think the interesting part there is platform interop
22:35:47 <kmc> targeting JVM and CLR is well and good, but can you call Java and .NET libraries conveniently?
22:36:05 <kmc> that's a separate problem, one you can also solve with native code compilation
22:36:20 <kmc> and it's tricky to fit the various type systems together.  F# has been criticized on these grounds
22:36:45 <kmc> though it's also one of its biggest strengths
22:39:08 <Adamant> kmc: right; there's serious problems trying to call really imperative or OO modules from functional pieces of code.
22:39:58 <kmc> imperative isn't so bad
22:40:05 <kmc> i mean the IO monad is a perfectly respectable imperative language
22:40:24 <kmc> but OO usually implies some kind of subtyping
22:40:35 <kmc> which isn't a good fit for a language like ML or Haskell
22:41:11 <kmc> and you're right that mutating data structures won't be usable from pure functional code without lots of work
22:41:17 <kmc> and i guess the Java / .NET libraries favor those
23:01:20 <ski> lispy : yes
23:05:16 <ski> lispy : every (total) element of `Tree a' contains a power of two number of elements of type `a'
23:34:03 * hackagebot base64-bytestring 0.1.0.0 - Fast base64 encoding and deconding for ByteStrings  http://hackage.haskell.org/package/base64-bytestring-0.1.0.0 (BryanOSullivan)
23:40:08 <ksf_> bah. even if I give an explicit type signature, ghci reports the type I don't want it to infer.
23:40:19 <ksf_> not that it's wrong, but it's ugly in comparison.
23:43:21 <tehgeekmeister> (foo . bar) doesn't work if bar :: a -> b -> c, foo :: c -> d, what will make that work?
23:44:04 <tehgeekmeister> oh hey!  undefined can help me here.
23:44:26 <Veinor> (bar .) . foo
23:44:27 <Veinor> I think
23:45:43 <tehgeekmeister> eeeeeeeeh i'm just going to use a lambda
23:46:04 <kmc> :t let (f :. g) x y = f $ g x y in (:.)
23:46:05 <lambdabot> Parse error in pattern
23:46:18 <kmc> :t let (f .: g) x y = f $ g x y in (:.)
23:46:19 <lambdabot> Not in scope: data constructor `:.'
23:46:23 <kmc> :t let (f .: g) x y = f $ g x y in (.:)
23:46:24 <lambdabot> forall a b t t1. (a -> b) -> (t -> t1 -> a) -> t -> t1 -> b
23:47:00 <tehgeekmeister> what makes lambdabot do the point free transforms again?
23:47:03 <kmc> how does undefined help?
23:47:03 <kmc> @pl
23:47:04 <lambdabot> (line 1, column 1):
23:47:04 <lambdabot> unexpected end of input
23:47:04 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
23:47:09 <kmc> @pl \f g x y -> f $ g x y
23:47:10 <lambdabot> (.) . (.)
23:47:32 <kmc> pl for "pointless" ;)
23:48:03 <tehgeekmeister> kmc: i can do let foo = undefined::a -> b -> c, and the same for bar, and play with different ways of combining them and seeing what the type is
23:48:12 <kmc> ah, yes
23:48:22 * ksf_ wants a way to re-write inferred types.
23:48:25 <tehgeekmeister> and (.) . (.) is waaaaaaaaay too weird, i'd rather just keep my code readable.
23:48:34 <FunctorSalad_> I madez cabal completion for zsh
23:48:42 <tehgeekmeister> but it does look like a smiley.
23:48:46 <kmc> though, when you write that, you're saying "for *any* types a,b,c, foo has type a â†’ b â†’ c"
23:49:02 <kmc> in particular it will be fine unifying a with d or some such thing
23:49:11 <FunctorSalad_> it's a bit ridiculous but should I send it in as a cabal-install patch?
23:49:13 <ksf_> ...check whether they unify with what ghc infers itself, and if they aren't equal, take mine. that is, a way to generically give stuff e.g. more concrete types.
23:49:36 <tehgeekmeister> kmc: well, actually, in this case it was a -> a -> b and b -> a
23:49:37 <kmc> ksf_, uhc has partial type sigs
23:49:37 <ksf_> ...or re-apply a type synonym, or another class, or something.
23:49:41 <tehgeekmeister> kmc: so unification is fine
23:50:13 <kmc> tehgeekmeister, so maybe you would want to play with Â«f :: A â†’ B â†’ CÂ» and Â«g :: C â†’ DÂ» instead
23:50:39 <ksf_> kmc, that won't help if you get a page full of contexts inferred that could be replaced by a single constraint, with a bit of domain knowledge.
23:50:41 <tehgeekmeister> kmc: that's what i did, except i used foo and bar
23:50:55 <kmc> A,B,C,D being some fixed but irrelevant types, whereas a,b,c,d are universally quantified variables
23:51:04 <kmc> for a type expression, foo and Foo are very different
23:51:49 <kmc> ksf_, ah.  context synonyms might help then?
23:51:49 <ksf_> right now, I don't seem to be able to tell ghc not to unroll a recursive class into a constraint for every step.
23:52:29 <ksf_> kmc, yes. though I want to stress that I want to be able to tell the compiler what to infer.
23:52:54 <FunctorSalad_> (the ridiculous part is mostly a sed script riddled with gotos :D)
23:53:05 <kmc> maybe i could take a look at your recursive class
23:53:10 <kmc> i'm curious where this problem comes up
23:53:13 <ksf_> http://code.haskell.org/grapefruit/main/grapefruit-records/src/Data/Record.hs
23:53:36 <ksf_> bar :: (Subrecord (X :& SetY ::: f :& SetX ::: g ) record) => record PlainStyle -> (f,g)
23:53:36 <ksf_> bar self =  (\(X :& SetY := f :& SetX := g ) -> (f,g) ) (foo self)
23:53:56 <ksf_> :t reports for that (yes, despite the annotation)
23:53:57 <lambdabot> Not in scope: `reports'
23:53:57 <lambdabot> Not in scope: `for'
23:53:57 <lambdabot> Not in scope: `that'
23:54:05 <ksf_> bar
23:54:06 <ksf_>   :: (Dissection record remainder SetX g,
23:54:06 <ksf_>       Dissection remainder remainder1 SetY f) =>
23:54:06 <ksf_>      record PlainStyle -> (f, g)
23:54:08 <FunctorSalad_> I should just have modified `cabal list' to output something ready for zsh
23:55:04 <ksf_> oh, duh.
23:55:24 <ksf_> well, replace "foo" with "narrow"
23:55:33 <kmc> wow someone who actually indents after "module ... where"
23:55:41 <ksf_> that's wolfgang.
23:55:45 <ksf_> and yes, it's atrocious.
23:55:59 <kmc> i've seen C++ code where almost every line is indented 12 spaces
23:56:02 <kmc> three nested namespaces, you know
23:56:55 <ski> ksf_ : wrong type variable names or expanded type synonyms ?
23:57:10 <ksf_> "wrong" classes.
23:57:23 <ksf_> it's unrolling the recursive call.
23:57:59 <ski> kmc : i always indent after `module ... where' ..
