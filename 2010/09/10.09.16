00:01:32 <copumpkin> tomberek: nope
00:01:52 <copumpkin> well
00:01:55 <tomberek> copumpkin: that was multiple choice
00:02:16 <tomberek> i'm thinking just absorb nodesIn with InGraph, etc.
00:02:23 <copumpkin> do you have anything that lets me look up the nodes attached to an edge?
00:02:28 <copumpkin> if so, then you can get rid of it easily
00:02:46 <copumpkin> oh I see
00:02:47 <tomberek> copumpkin:  source , target :: g-> Edge g -> Node g
00:02:52 <copumpkin> yeah
00:02:57 <copumpkin> I wasn't expecting to see it so high up
00:03:05 <copumpkin> seems like if you're planning to support hypergraphs, that's got to go
00:03:12 <tomberek> they are the most basic functions of a graph
00:04:07 <copumpkin> yeah, but make no sense on a hypergraph
00:04:13 <tomberek> hm... makes me think that EdgeGraph and VertexGraph might need to be combined
00:04:16 <tomberek> oh,, yeah!
00:04:19 <tomberek> good point
00:05:28 <copumpkin> having said that, I'm not sure I'd try to support hypergraphs at all
00:05:41 <copumpkin> they complicate things and are barely ever used anywhere :P
00:05:47 <rschnck> Could someone clarify what's going awry here?http://dpaste.com/244270/
00:06:24 <rschnck> I know it's complaining about types, but I don't see how what I did is wrong.
00:06:33 <copumpkin> rschnck: you only pass one parameter to maxHelper
00:06:39 <copumpkin> maxOccurences (x:xs) =  maxHelper(removeDuplicates((x:xs)) (x:xs) 0)
00:07:25 <Entroacceptor> a misplaces bracket, probably
00:07:27 <copumpkin> yeah
00:07:37 <copumpkin> looks like the one after the 0 belongs before the (x:xs)
00:07:48 <tomberek_> gr.. internet broke again
00:07:49 <copumpkin> also, in haskell we typically call functions f x
00:07:52 <copumpkin> instead of f(x)
00:08:05 <tomberek_> copumpkin: did I miss an important pearl of wisdom? 
00:08:06 <copumpkin> tomberek_: [09:05:04 AM] ‹ copumpkin › having said that, I'm not sure I'd try to support hypergraphs at all
00:08:08 <copumpkin> no :P
00:08:14 <copumpkin> [09:05:16 AM] ‹ copumpkin › they complicate things and are barely ever used anywhere :P
00:08:35 <rschnck> copumpkin: That was it. Silly me.
00:08:35 <copumpkin> it's a good goal, but you want to consider usability of your API too
00:08:46 <tomberek_> perhaps BECAUSE no library supports them... eh? eh? eh?   ok, maybe not.....
00:09:18 <copumpkin> tomberek_: well, it's something to strive for, but if supporting them means making everything else ugly, I'd go for something more focussed
00:09:37 <tomberek_> perhaps
00:09:43 <copumpkin> also, what kinds of functions do you want to work on all graphs
00:09:47 <copumpkin> vs. only regular graphs
00:10:47 <copumpkin> anyway, I'm going to sleep :P
00:10:50 <copumpkin> it's 9am
00:14:01 <tomberek_> for now I just moved them into the appropriate In/OutGraph, along with nodesIn/nodesOut
00:14:13 <tomberek_> good night
00:19:34 * hackagebot HFuse 0.2.3 - HFuse is a binding for the Linux FUSE library.  http://hackage.haskell.org/package/HFuse-0.2.3 (TaruKarttunen)
00:20:43 <rschnck> Silly question, but--erm-- what is (:) called?
00:21:23 <c_wraith> cons
00:21:31 <c_wraith> ...  which is a silly name :)
00:21:35 <c_wraith> It comes from lisp
00:22:06 <rschnck> So you'd say by "by using the cons operation"?
00:22:39 <dolio> It's less silly than cdr.
00:22:48 <sinelaw> hey, i was going to order Types And Programming Languages, but it's expensive.
00:22:56 <sinelaw> Can someone recommend other books in the same spirit?
00:23:22 <sinelaw> Books about basic theoretical stuff for functional programming
00:23:27 <dolio> I haven't read TAPL.
00:23:33 <dolio> But, Proofs and Types is pretty cool.
00:23:37 <dolio> By Girard.
00:23:39 <c_wraith> rschnck, in that context, I think I would say something like "by consing <X> to the front of the list"
00:23:42 <dolio> And it's available for free.
00:24:30 <rschnck> c_wraith: Ah, that sounds better. Thanks. Prof requires little notes on our functions :P
00:25:28 <sinelaw> Peaker: hey!
00:26:02 <sinelaw> dolio: ok, maybe I'll just print that
00:26:25 <dolio> It probably doesn't go into as much stuff as TAPL.
00:26:51 <dolio> But it goes into a lot of depth about System F.
00:28:28 <sinelaw> $80 for a book is just too much for me... :)
00:28:58 <sinelaw> sorry, $66
00:29:06 <dolio> That's why I haven't read it yet, either. :)
00:29:50 <sinelaw> dolio: we can wait until it's out of print
00:29:51 <dolio> There's Type Theory and Functional Programming, too. But I haven't read it, so I can't say how it is.
00:30:24 <sinelaw> let's discourage anyone else from reading that book
00:30:26 <dolio> Programming Languages and Lambda Calculi, Programming in Martin Loef Type Theory
00:30:53 <dolio> Type Systems for Programming Languages
00:32:05 <sinelaw> i guess i'll just print that one
00:32:09 <sinelaw> least likely to regret it :)
00:32:22 <sinelaw> there's a few others i intend printing
00:32:40 <sinelaw> The Implementation of Functional Programming Languages being the chief one
00:33:01 <sinelaw> later, then 
00:36:55 <etpace> @pl \n -> x y -> (n, f x y)
00:36:56 <lambdabot> (line 1, column 11):
00:36:56 <lambdabot> unexpected ">" or "-"
00:36:56 <lambdabot> expecting variable, "(", operator or end of input
00:37:21 <etpace> @pl \n  x y -> (n, f x y)
00:37:21 <lambdabot> (. f) . (.) . (,)
01:35:42 <hvr> is there something like python's pprint for haskell? I've got some nested record structures, but printing them via derived show puts them all on one line...
01:36:01 <ManateeIrcClient> @hoogle printf
01:36:01 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
01:36:01 <lambdabot> module Text.Printf
01:36:02 <lambdabot> Text.Printf class PrintfArg a
01:36:36 <Zao> @hoogle pretty
01:36:36 <lambdabot> package pretty
01:36:37 <lambdabot> module Language.Haskell.Pretty
01:36:37 <lambdabot> Language.Haskell.Pretty class Pretty a
01:36:42 <ManateeIrcClient> > printf "Hello, %s! Welcome to %s world!" "hvr" "Haskell"
01:36:43 <lambdabot>   Ambiguous type variable `a' in the constraints:
01:36:44 <lambdabot>    `GHC.Show.Show a'
01:36:44 <lambdabot>      a...
01:38:08 <kmc> hvr, http://hackage.haskell.org/package/groom
01:38:28 <Funktorsalat> hvr: I don't know python's pprint but you might be able to modify the code of gshow appropriately
01:38:32 <kmc> also http://hackage.haskell.org/package/ipprint basically the same
01:38:41 <kmc> this will take your derived show instance and pretty it up
01:38:43 <hvr> thx 4 pointers! :-)
01:39:22 <kmc> &stg_app_pp_entry  ←  a pointer
01:40:06 <Funktorsalat> (I mean gshow from syb / Data.Generics )
01:48:52 <Funktorsalat> I'll try to hook that up to ghci by default with NoImplPrelude
01:49:21 <kmc> this isn't necessarily a haskell question but: is there a cross-platform way to get a file like /usr/share/dict/words (Linux)
01:50:54 <kfish> kmc, download it from the interwebs into $CWD ;-)
01:51:21 <kmc> :/
01:54:13 <Funktorsalat> oh no it doesn't work
01:54:40 <Funktorsalat> did: :set -XNoImplicitPrelude \n let show x = IPPrint.pshow x
01:54:48 <Funktorsalat> let print x = IPPrint.pprint x
01:55:32 <Funktorsalat> etaexpansion to defeat the monodwarfism constriction
02:04:40 <tomberek> hello everyone, i'm back
02:05:54 <danderson> I'm having a little puzzling time with Control.Parallel: http://hpaste.org/30098/parallel_experiments
02:06:37 <danderson> vectors N M produces all M element vectors where N elements are 1 (the other are 0)
02:07:27 <danderson> compiling with -threaded and running with +RTS -N4 on a quad-core machine, I'd expect vectors 20 40 or vectors 200 400 to eat close to 100% of available CPU, parallelizing across all cores
02:07:41 <danderson> instead, CPU utilization levels off at just under 50%
02:07:43 <danderson> why?
02:10:27 <danderson> (and more to the point, what tools are available to peek into the runtime's sparking logic, to help me figure this out by myself in the future?
02:11:46 <Cale> danderson: You might be able to try ThreadScope
02:12:15 <Cale> danderson: Also try -N3
02:12:18 <danderson> huh, actually, the answer just came.
02:12:32 <danderson> if I don't print the output, I top off at 95%
02:12:47 <danderson> oscillating between 60 and 95, presumably due to GC pausing
02:13:11 <danderson> so, the answer is: it's that damn I/O again :)
02:14:32 <danderson> Cale: thanks for the suggestion though. Installing ThreadScope now, I'd like to verify that the oscillations are due to pausing.
02:21:44 <mm_freak> woah!
02:21:55 <mm_freak> instance Alternative m => Alternative (ContT r m) where
02:22:13 <mm_freak> this is one of the most useful instances i've ever written…  i wonder why nobody else has come up with something like that
02:22:48 <mm_freak> runContT (do x <- return 3 <|> return 4; y <- return 10 <|> return 20; when (x == 3) (abort 0); return (x+y)) return :: [Integer]
02:22:51 <mm_freak> [0,0,14,24]
02:28:43 <Cale> mm_freak: nice
02:32:06 <mm_freak> Cale: i wonder whether, given that, you need a list monad transformer at all
02:32:22 <Funktorsalat> :o
02:32:27 <mm_freak> something like monadLib's ChoiceT
02:35:20 <Cale> mm_freak: I have never needed the list monad transformer
02:35:36 <Cale> mm_freak: I always transform the list monad instead.
02:36:36 <Cale> Of course, ListT isn't even a proper monad transformer, so I wouldn't advise using it anyway. ChoiceT and LogicT I believe are fine, but they work differently.
02:37:29 <yaxu> Hi, I'm getting a problem installing clutterhs, it's trying to access a 'hidden module' http://hpaste.org/30099/clutter_build_failure
02:37:39 <yaxu> any tips?
02:37:42 <mm_freak> Cale: i didn't mean ListT in particular, but a real list monad transformer
02:38:45 <ManateeLazyCat> yaxu: You need report this problem to author, clutter can't compatible gtk2hs-0.11.2 now.
02:38:55 <yaxu> ok thanks ManateeLazyCat
02:42:29 <danderson> dayum, GC is dominating my program's runtime almost 3:1
02:44:48 <fasta> danderson, that sounds like a good benchmark.
02:45:17 <fasta> danderson, but it is kind of excessive. 
02:46:12 <danderson> fasta: well, I was running this to see how hard I could push 4 cores with par/pseq (first time trying to use them)
02:46:52 <danderson> the result is that I can push them pretty hard, but evaluating a giant list to WHNF and throwing elements away as I go isn't exactly being polite to the GC
02:47:00 <danderson> so, understandably, it's a little pissed.
02:48:56 <ManateeLazyCat> mm_freak: Any plan to parse NumbericCmd?
02:49:47 <ManateeLazyCat> mm_freak: Something like 332 from irc server...
02:50:22 <mm_freak> ManateeLazyCat: yes, but that's difficult, because besides the standard numerics, many have different meanings on different IRCds
02:50:45 <ManateeLazyCat> mm_freak: So just provide standard numberics.
02:50:57 <mm_freak> ManateeLazyCat: yeah, that's what i'm planning to do
02:51:05 <ManateeLazyCat> mm_freak: Cool.
02:51:28 <mm_freak> ManateeLazyCat: i'll develop that along with the session handler
02:51:36 <mm_freak> but currently i'm focussing on my monad library
02:52:01 <ManateeLazyCat> mm_freak: I will wait new version fastirc release, then i can support numberic message in my irc client.
02:52:04 <mm_freak> i think i will replace the dependence on monadLib with my own, when it's finished
02:52:28 <ManateeLazyCat> mm_freak: Make fastirc depend monadLib?
02:54:31 <mm_freak> ManateeLazyCat: it already depends on monadLib
02:54:44 <mm_freak> but i think i'll remove that dependency as soon as my own library is finished
02:54:50 <ManateeLazyCat> mm_freak: IMO, you should split Messages.hs out, build new package, like 'fastirc-core'....
02:55:21 <ManateeLazyCat> mm_freak: Just suggestion. :)
02:55:45 <mm_freak> ManateeLazyCat: that's a good idea
02:56:06 <mm_freak> btw, if you want to create a derivative work, the full repository is online and linked from hackage
02:56:25 <mm_freak> but you'll risk duplicating work =)
02:56:47 <ManateeLazyCat> mm_freak: Then you keep fastirc-core stable, other people can choose whether use your Session code. :)
02:57:20 <ManateeLazyCat> mm_freak: I think you can do that work faster than me. ;p
02:57:20 <mm_freak> then i should name the core package fastirc and the session handler 'fastirc-sessions'
02:57:27 <mm_freak> and later maybe add a 'fastirc-server'
02:57:35 <ManateeLazyCat> mm_freak: Yes,
02:57:54 <ManateeLazyCat> mm_freak: Maybe fastirc-core and fastirc-client is enough.
02:58:03 <mm_freak> anyway, you'll need to be a bit patient then, because i'll write the monad library first
02:58:27 <mm_freak> fastirc-client would be somewhat misleading, because the session handler will allow writing stuff like bouncers, too
02:58:37 <ManateeLazyCat> mm_freak: Ok, i will waiting new version release, hope it's not too long.... 
02:59:07 <ManateeLazyCat> mm_freak: My point is, put parser code in fastirc-core, other code in another package.
02:59:39 <ManateeLazyCat> mm_freak: Example, fastirc-core just provide parser, then fastirc provide a complete framework let user choose.
02:59:58 <ManateeLazyCat> mm_freak: I'm afraid too many fastirc-* packages confuse user. :)
03:01:11 <handonson> I want to manipulate some Haskell code with GHC API, that is, read-parse-typecheck a code, change it a little bit, and then save. The problem is, I'm almost sure that this will completely destroy the comments, since the GHC-parsed result does not contain any information about comments. Any idea?
03:01:57 <ManateeLazyCat> mm_freak: Please let me know if you release new version, thanks for your great work! :)
03:01:59 <Cale> wtf Yampa:  origin :: AffineSpace p v a => p
03:02:19 <Cale> Oh well, I guess I can define an origin arbitrarily :P
03:02:21 * ManateeLazyCat Skip NumbericCmd ....
03:03:24 <Cale> They also seem to have lumped in distance... that's even worse.
03:04:24 <mornfall> handonson: If there was a way to feed lexed input to GHC, that could possibly help.
03:05:12 <ManateeLazyCat> mm_freak: BTW, if you split Messages.hs to fastirc-core, can you release fastirc-core first even Session code haven't finish?
03:05:13 <mornfall> Actually.
03:05:29 <mornfall> handonson: You probably don't even need that, you just need a lexer (haskell-src-exts may have one?).
03:05:35 <mornfall> Drop the -exts.
03:05:49 <mornfall> handonson: You could then do a lex-based diff.
03:05:58 <mornfall> Actually a 3-way merge or something. :)
03:06:11 <mornfall> Presumably it could be even correct.
03:06:14 <mm_freak> ManateeLazyCat: splitting is a good idea, yes
03:06:21 <ManateeLazyCat> mm_freak: Ok, thanks!
03:06:50 <mm_freak> but maybe i'll call that module just 'fastirc', and the session handler will be moved to 'fastirc-session'
03:06:59 <mm_freak> s/module/package/
03:07:02 <ManateeLazyCat> mm_freak: Cool.
03:08:26 <handonson> mornfall: make a lexer that sees comments as tokens?
03:08:37 <ManateeLazyCat> Advert : If anyone want write irc client, use mm_freak's fastirc, i have test it some time, damn fast and stable... 
03:09:09 <fasta> ManateeLazyCat, does it also come with proxy support?
03:09:24 <ManateeLazyCat> fasta: AFAIK, no.
03:14:11 <mornfall> handonson: Yes.
03:15:05 <mornfall> handonson: What I'd do is, remove all comments, take the result as the "base" revision. Take the original, take that as side A and take the "base", wibble it and take the result as side B.
03:15:28 <mornfall> handonson: Now if you have the right lexer, you can do a 3-way merge on the result. Depending on your transform, it may or may not be guaranteed to succeed.
03:15:28 <mm_freak> fasta: the usable parts of fastirc are currently limited to the parser
03:15:45 <mm_freak> it's fast and very stable
03:15:48 <mornfall> handonson: Beware though, there *may* be a much easier way to do that, I am just not aware of it.
03:16:08 <fasta> mm_freak, so, it is actually the parse-irc-messages-fast package? 
03:16:20 <mm_freak> fasta: currently, yes
03:16:22 <mornfall> It should have been called attoirc : - P
03:16:27 <mm_freak> hehe
03:16:41 <fasta> mm_freak, any plans to extend it? 
03:16:45 <ivanm> that means irc * 10^-18 !
03:17:22 <mm_freak> fasta: yes, i'll add a session handler
03:17:29 <mm_freak> and some time in the future also a server framework
03:17:45 <mm_freak> in fact the session handler is already there
03:17:46 <fasta> mm_freak, what is your specific interest in this? 
03:17:54 <mm_freak> but in my local code it's almost completely rewritten
03:18:05 <mm_freak> using a BotT monad transformer instead of the Bot monad, which you find in the release
03:18:21 <mm_freak> fasta: i wanted to write a bouncer
03:19:07 <mm_freak> but when i started to write fastirc, i thought it should be flexible enough to support real clients
03:20:34 <ManateeLazyCat> mm_freak: I have write real client.
03:20:50 <ManateeLazyCat> mm_freak: Your session framework should simple enough.
03:21:02 <ManateeLazyCat> mm_freak: And flexible enough.
03:21:03 <ManateeLazyCat> :)
03:21:31 <mm_freak> currently it's simple, but not flexible
03:21:36 <mm_freak> the flexibility will come from BotT
03:21:50 <mm_freak> which is already implemented partly, but not very useful yet
03:22:15 <ManateeLazyCat> mm_freak: IMO, it's hard to write session framework that suitable for everyone.....
03:22:29 <mm_freak> ManateeLazyCat: yes, but not in haskell =)
03:22:43 <mm_freak> flexibility is the whole point about monad transformers
03:23:02 <ManateeLazyCat> mm_freak: I have use your fastirc develop irc client : http://www.flickr.com/photos/48809572@N02/4992961239/lightbox/ support time stamp now.
03:23:24 <ManateeLazyCat> mm_freak: Next time provide color for different type message, and different nick.
03:23:51 <mm_freak> ManateeLazyCat: looks promising
03:25:08 <ManateeLazyCat> mm_freak: I build daemon process wrap your fastirc, even user switch to other buffer, irc router still running... :)
03:26:16 <mm_freak> daemon process?  what for?
03:26:22 <mm_freak> i'd just use concurrency
03:27:09 <ManateeLazyCat> mm_freak: My framework is multiple-process model to build an OS : http://www.flickr.com/photos/48809572@N02/ , like irc buffer is running in separate process for protected core won't crash.
03:27:41 <ManateeLazyCat> mm_freak: So i build daemon process (irc router) to receive/send message between irc server and irc client tab.
03:27:55 <mm_freak> i see
03:28:28 <mm_freak> personally i wouldn't do that, because a crashing core is usually an RTS bug =)
03:28:36 <mm_freak> and also it adds a lot of complexity
03:29:43 <ManateeLazyCat> mm_freak: I keep simple enough and test complete, so core won't crash in 99% time, any extension code is running in separate process.
03:29:56 <ManateeLazyCat> Dinner time, back soon.
03:30:48 <mm_freak> hmm
03:30:57 <mm_freak> i have two ways to implement the writer monad using ContT
03:31:26 <mm_freak> one is the traditional one:  type WriterT r w m a = ContT (r, w) m a
03:31:42 <mm_freak> the other one looks very promising and is a completely new approach:
03:32:02 <mm_freak>   tell x = ContT $ \k -> pure x <|> k ()
03:32:13 <mm_freak> this is a very interesting writer monad implementation
03:32:33 <mm_freak> and it doesn't depend on Monoid
03:32:38 <mm_freak> just on Alternative
03:33:18 <mm_freak> i think i'll go with the new one
03:37:38 <nominolo> @pl \z xs f -> foldM f z xs
03:37:38 <lambdabot> flip . flip foldM
03:37:55 <nominolo> :t \z xs f -> foldM f z xs
03:37:56 <lambdabot> forall a b (m :: * -> *). (Monad m) => a -> [b] -> (a -> b -> m a) -> m a
03:38:12 <nominolo> @hoogle a -> [b] -> (a -> b -> m 
03:38:12 <lambdabot> Parse error:
03:38:13 <lambdabot>   --count=20 "a -> [b] -> (a -> b -> m "
03:38:13 <lambdabot>                                       ^
03:38:13 <nominolo>                    a) -> m a
03:38:29 <nominolo> @hoogle a -> [b] -> (a -> b -> m a) -> m a
03:38:29 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
03:38:29 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
03:38:30 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
03:38:55 <ehamberg> parsec users, please enlighten me. when i have elements that may or may not appear, i have done this: http://hpaste.org/30100 but i suspect there might be an easier way. :-)
03:43:26 <mm_freak> ehamberg: 'optional'
03:44:36 <ehamberg> mm_freak: perfect. thanks!
03:46:57 <ddarius> @hoogle option
03:46:57 <lambdabot> Text.Html option :: Html -> Html
03:46:58 <lambdabot> Text.Parsec.Combinator option :: Stream s m t => a -> ParsecT s u m a -> ParsecT s u m a
03:46:58 <lambdabot> Text.ParserCombinators.ReadP option :: a -> ReadP a -> ReadP a
03:47:01 <danderson> this is fun.
03:47:15 <ddarius> @hoogle optionMaybe
03:47:15 <lambdabot> Text.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
03:47:15 <lambdabot> Text.ParserCombinators.Parsec.Combinator optionMaybe :: Stream s m t => ParsecT s u m a -> ParsecT s u m (Maybe a)
03:47:24 <danderson> evaluating a map with a Control.Parallel.Strategies strategy, increasing the number of runtime threads slows down the program linearly.
03:47:25 <ehamberg> yes, even better. :-)
03:47:41 <danderson> 2.5s on one thread, 5s on two, 10s on four (I have a quad-core system)
03:48:01 <mm_freak> does anyone know how to remember a cursor position in emacs, so i can jump back to a certain position more easily?
03:48:19 <ddarius> danderson: Welcome to the reason why "automatic parallelization" has never succeeded.
03:48:25 <danderson> +RTS -sstderr suggests that most of the time wasting goes into GC (GC eats 1.5s on one thread, 8s on four)
03:48:34 <mbuf> can anyone explain how this applyTwice function evaluates? http://fpaste.org/Nwu7/
03:48:44 <mm_freak> i often need to jump to the top of the file to change the imports, then i need to search the previous position, which is kind of annoying
03:48:45 <danderson> which confuses me. Shouldn't the program be generating the same amount of garbage?
03:49:48 <ddarius> danderson: Which strategy are you using?
03:50:04 <danderson> ddarius: parTraversal rdeepseq
03:50:26 <danderson> to evaluate a map (foldl' (+) 0)
03:50:28 <ddarius> rdeepseq is almost certainly the problem
03:50:47 <danderson> (picked pretty much at random, It's 4am, not thinking terribly straight)
03:50:48 <danderson> oh?
03:51:12 <danderson> since I'm computing numbers, evaluating as strictly as possible seemed like a reasonable strategy.
03:54:58 <ddarius> Actually, rseq and rdeepseq should be the same in this case if I'm reading things right.
03:58:11 <ddarius> danderson: If the nested lists are long.  It could simply be that you are significantly increasing the live set and thus putting more pressure on the GC.
03:58:41 <ddarius> What you'd want then is probably a sequential map and a parallel sum.
03:58:52 <copumpkin> danderson: how many lists and how big are they?
03:59:09 <mbuf> (++ "World") "Hello" prints "HelloWorld"; why so? what does the ++ signify here?
03:59:47 <ddarius> If the top level list is long, then you probably want something like parChunk.
04:00:40 <danderson> copumpkin: at the level where I inserted a parallel strategy, it's a list of 20 folds, over 40 elements each.
04:00:49 <danderson> so, yeah, very very small computations.
04:01:19 <ddarius> Why is this taking a long time at all?
04:01:58 <danderson> because I'm computing 2^21 of those ops
04:02:33 <danderson> ... so I should probably put the parallel strategy at that level, not in the inner loop.
04:02:43 <geheimdienst> mbuf, (++) is a function that takes 2 strings and glues them together, as you know
04:02:49 <geheimdienst> > "lol" ++ "cat"
04:02:50 <lambdabot>   "lolcat"
04:03:40 <geheimdienst> you can leave out the first argument: (++ "cat"). you have only given the second argument, the first one is still missing
04:03:44 <ddarius> danderson: Yeah.  You are probably just filling the heap with fizzled sparks.
04:03:52 <mbuf> geheimdienst: I see
04:03:54 <danderson> hah, fun. Inserting the parallel strategy at the top level makes the program take 18s on a single runtime thread.
04:04:01 <danderson> vs. 2.5s with no parallel strategy :)
04:04:10 <geheimdienst> later, you can pass in the first argument, and the (++) does its thing
04:04:24 <geheimdienst> > ("lol" ++ "cat")
04:04:26 <lambdabot>   "lolcat"
04:04:31 <geheimdienst> > (++ "cat") "lol"
04:04:32 <lambdabot>   "lolcat"
04:04:39 <geheimdienst> > ("lol" ++) "cat"
04:04:40 <lambdabot>   "lolcat"
04:04:40 <ddarius> danderson: You need to choose an appropriate strategy, which is probably something like parListChunk for the top level, but it obviously depends on your code.
04:04:42 <mbuf> geheimdienst: so is (++ "World") is like ([] ++ "World")
04:04:57 <medfly> or in #haskell - speak, (++) is like mplus only specific for lists.
04:04:59 <danderson> at least now it doesn't slow down with more runtime threads, that's a start.
04:05:03 <danderson> ddarius: looking, thanks.
04:05:09 * medfly grins
04:05:17 <danderson> (this is really just me experimenting, wanted to play with parallel stuff)
04:05:39 <geheimdienst> mbuf, not really, because ([] ++ "World") is an empty list (empty string) with "World" glued on
04:06:04 <ddarius> It's also possible that your code doesn't have much parallelism, but I doubt that.
04:06:06 <geheimdienst> (++ "World") is basically short for (\x -> x ++ "World")
04:06:31 <mbuf> geheimdienst: okay
04:06:33 <geheimdienst> (if you know the "\" thingies that haskellers love so much)
04:06:42 <mbuf> geheimdienst: lambda functions
04:06:48 <geheimdienst> exactly :)
04:07:07 <mbuf> geheimdienst: thanks for your help!
04:07:13 <geheimdienst> you're welcome
04:11:10 * ddarius considers making a user account on his BackTrack live external hard drive and using that as his primary OS as it feels a lot more responsive than his Ubuntu install.
04:11:17 <ddarius> (or XP)
04:11:50 <geheimdienst> what is a "backtrack live external hard drive"?
04:12:03 <geheimdienst> kids these days have so much computer things
04:12:47 <ddarius> BackTrack is a linux distribution.  I have it set up like a Live CD only on an external USB hard drive.
04:13:14 <geheimdienst> ah i see :-) that makes sense now
04:13:30 * geheimdienst is amazed how there's always one more linux distribution he hasn't heard of
04:13:44 <ddarius> My computer setup (and gadgets in general) is actually rather minimal.
04:14:28 <ddarius> I have a cheap old laptop and an old flip phone that no one would confuse for a "smart phone."
04:14:29 <copumpkin> BackTrack :o
04:14:34 * copumpkin used to have that on a livecd
04:14:58 <copumpkin> ddarius: quick quick, get a macbook pro and an iphone 4!
04:16:06 <geheimdienst> ... and a mouse. http://i.imgur.com/OPWgg.jpg
04:16:23 <copumpkin> lol
04:18:05 * geheimdienst had a macbook once and found it meh
04:18:17 * geheimdienst now has a thinkpad and is impressed with it
04:18:21 <ddarius> Incidentally, the tools for making live USB devices are not at all geared toward handling NTFS.
04:18:29 <Peaker> ddarius, that's weird.. Ubuntu is pretty responsive in most machines I've used it on (in the last couple of years)..
04:18:44 <ddarius> Peaker: BackTrack is based on Ubuntu.
04:19:02 <ddarius> And my Ubuntu install isn't horrible, BackTrack is just noticably faster.
04:19:35 <Peaker> except for some app launching taking a second or two, almost everything else is immediate, on this machine
04:19:51 <ManateeLazyCat> What's 333 message in irc protocol? I haven't 333 document in rfc-2812, looks is return the administrator to set channel topic, like #haskell is copumpkin 1281614707
04:20:10 * geheimdienst makes a little cardboard wrestling ring, putting a usb stick with the BackTrack penetration testing thing in one corner and a usb stick with Damn Vulnerable Linux in the other. geheimdienst stares intently at the setup and expects some kind of awesomeness to happen.
04:20:31 <copumpkin> ManateeLazyCat: I'd guess I was the last one to set the topic, and that's a timestamp?
04:20:36 * copumpkin doesn't know though
04:21:27 <ManateeLazyCat> copumpkin: Looks 333 return (Nick, ChannelName, Administrator, CreateTime)
04:21:48 <ManateeLazyCat> copumpkin: Looks some seconds from some time, let me calculate.
04:22:17 <copumpkin> probably 1970 :)
04:22:25 <ManateeLazyCat> copumpkin: Hmm, i guess so. :)
04:22:54 <ManateeLazyCat> copumpkin: I don't understand why RFC haven't 333 document, not standard numeric message?
04:23:25 <copumpkin> http://www.alien.net.au/irc/irc2numerics.html
04:23:38 <ddarius> From what I hear, when it comes to IRC, the RFCs are only passingly useful.
04:23:51 <copumpkin> ManateeLazyCat: there's a decent reference :)
04:23:59 <copumpkin> apparently it was "coined" by the undernet irc daemon
04:24:26 <ManateeLazyCat> copumpkin: Cool, thanks!
04:24:37 <ManateeLazyCat> 333 mean RPL_TOPICWHOTIME
04:24:43 <copumpkin> ManateeLazyCat: are you integrating this IRC parsing into your GUI, or are you making a separate library for it? it'd be nice to have a reusable library for any IRC application
04:25:38 <ddarius> @hackage irc
04:25:38 <lambdabot> http://hackage.haskell.org/package/irc
04:26:17 <ManateeLazyCat> copumpkin: I use fastirc as parser library for my irc client. But now fastirc not support parse numeric message, so i parse some numeric message myself, when fastirc release new version, i will switch to use fastic's parser code.
04:26:25 <copumpkin> ah
04:26:30 <copumpkin> @hackage fastirc
04:26:30 <lambdabot> http://hackage.haskell.org/package/fastirc
04:26:47 <ManateeLazyCat> copumpkin: fastirc is complete except numeric message.
04:26:57 <copumpkin> ManateeLazyCat: you should send mm_freak a patch :)
04:27:51 <ManateeLazyCat> mm_freak: Do you want my fastirc patch? 
04:29:32 * ManateeLazyCat pasted "332 parse" at http://paste2.org/get/990086
04:29:33 <ManateeLazyCat> copumpkin: I just use some unly way to parse message, like above code snippets.
04:29:40 <ManateeLazyCat> s/unly/ugly
04:30:35 <ManateeLazyCat> copumpkin: I think mm_freak can build more beautiful solution... :)
04:30:51 <copumpkin> :)
04:31:03 <copumpkin> just out of curiosity
04:31:05 <copumpkin> why                    let channel = (!!) messages 1
04:31:12 <copumpkin> are you opposed to infix?
04:31:26 <ManateeLazyCat> copumpkin: I have check "unless (length messages < 3) $ do ... " :)
04:32:01 <ManateeLazyCat> copumpkin: So my code won't failed, that's why i called it ugly, fastest hacking solution . :)
04:32:19 <copumpkin> hm ok :)
04:32:48 <ManateeLazyCat> copumpkin: I love http://www.alien.net.au/irc/irc2numerics.html , very useful.
04:34:48 <Cale> ManateeIrcClient: I think copumpkin was trying to say that you could write that as   let channel = messages !! 1
04:35:14 <ManateeLazyCat> Cale: Ahh. :)
04:35:31 <ManateeLazyCat> Cale: Yeah, copumpkin's better . :)
04:36:54 <mm_freak> ManateeLazyCat: what does your patch change?
04:37:12 <ManateeLazyCat> mm_freak: Forgot it, my solution is ugly. :)
04:37:26 <ManateeLazyCat> mm_freak: http://paste2.org/get/990086
04:38:03 <ManateeLazyCat> mm_freak: Now i use ugliest way to parse some numeric message, change code after you release new version fastirc. :)
04:38:45 <Peaker> I hate "unless".. always prefer "when"
04:38:48 <mm_freak> ManateeLazyCat: yeah, that's really ugly ;)
04:39:08 <ManateeLazyCat> mm_freak: Just temporary solution. :)
04:39:41 <ManateeLazyCat> mm_freak: I will use your beautiful code when you release new version. :)
04:41:31 <mm_freak> hehe ok
04:41:59 <ManateeLazyCat> mm_freak: I found 332 no documentation in RFC-2818, you can found all numeric documentation at http://www.alien.net.au/irc/irc2numerics.html .
04:42:29 <ManateeLazyCat> mm_freak: is 333
04:42:39 <ManateeLazyCat> 333 RPL_TOPICWHOTIME           ircu
04:46:40 <chrisdone> Peaker: yeah I use when . not more often than unless
04:46:54 <ManateeLazyCat> > secondsToDiffTime 1281614707
04:46:55 <lambdabot>   Not in scope: `secondsToDiffTime'
04:46:56 <chrisdone> takes more thinking about
04:47:10 <ManateeLazyCat> > Data.Time.Clock.secondsToDiffTime 1281614707
04:47:11 <lambdabot>   Not in scope: `Data.Time.Clock.secondsToDiffTime'
04:47:17 <ManateeLazyCat> lambdabot: Damn you.
04:47:54 <Peaker> When the "unless" condition is negative, it's just a double negative and is more confusing :)
04:48:34 <geheimdienst> would it make sense for main to return anything? for what could you use that?
04:48:44 <geheimdienst> main is «IO a», right?
04:48:56 <Peaker> I always make it IO ()
04:49:47 <mm_freak> ManateeLazyCat: those numerics not found in the IRC RFCs are nonstandard
04:49:57 <mm_freak> you should separate them from standard numerics
04:50:22 <handonson> it may make sense to make main :: IO Int, or main :: IO ExitCode.
04:50:23 <Zeiris> I'm throwing together an AI for a board game. Trivial type is AI :: GameState -> [Actions], but I want to make it more flexible by threading an optional (GameState,s) -> ([Action],s) persistent state component. To avoid recalculation and whatnot. Is there any neater way to do it than making AI :: GameState -> State s [Action] ?
04:50:35 <ddarius> geheimdienst: Assuming no RTS trickery, the type of main says that it's result must be discarded.
04:50:39 <mm_freak> the session handler will be designed to detect which IRCd you're connected to and assign numerics to their meaning accordingly
04:50:59 <handonson> since applications are supposed to return something to the OS, to tell the OS how well it terminated.
04:51:01 <mm_freak> but it'll take a long time, until i get there =)
04:51:11 <ddarius> It's handy for main to have the more general type so you don't have to add a return () at the end if you happen to use an IO action that returns something you are not interested in.
04:51:35 <geheimdienst> ddarius: yeah, that's what i guessed
04:51:47 <geheimdienst> ok cool. thanks for the answers, guys
04:52:05 <ddarius> :t (() <$)
04:52:07 <lambdabot> forall (f :: * -> *) b. (Functor f) => f b -> f ()
04:53:25 <ManateeLazyCat> mm_freak: Your session code need long time to finish?
04:53:53 <ManateeLazyCat> mm_freak: Can i vote do "numberic parser" first? ;p
04:58:28 <aristid> :t ($>)
04:58:29 <lambdabot> Not in scope: `$>'
04:58:35 <aristid> @hoogle <$
04:58:36 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
04:58:36 <lambdabot> Text.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
04:58:36 <lambdabot> Text.ParserCombinators.Parsec.Perm (<$$>) :: Stream s Identity tok => (a -> b) -> Parsec s st a -> StreamPermParser s st b
05:00:06 <Zeiris> Isn't there a monad that's a combination of State and Reader?
05:00:19 <Zeiris> Or State+Reader+Writer, even?
05:00:20 <copumpkin> RWS gives you Writer too
05:03:19 <ManateeLazyCat> @hoogle DiffTime
05:03:19 <lambdabot> Data.Time.Clock data DiffTime
05:03:20 <lambdabot> Data.Time.Clock data NominalDiffTime
05:03:20 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
05:03:43 <ManateeLazyCat> How to list more result?
05:03:50 <chrisdone> @more
05:03:55 <chrisdone> oh well
05:04:00 <ManateeLazyCat> @hoogle DiffTime
05:04:00 <lambdabot> Data.Time.Clock data DiffTime
05:04:00 <lambdabot> Data.Time.Clock data NominalDiffTime
05:04:00 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
05:04:02 <ManateeLazyCat> @more
05:04:13 <chrisdone> ManateeLazyCat: don't you have a gtk app for hoogle yet? :-P
05:04:22 <copumpkin> manatoogle
05:04:37 <ManateeLazyCat> chrisdone: hoogle is not good enough, i plan to create new one.
05:04:38 <chrisdone> hoogletee
05:04:56 <ManateeLazyCat> chrisdone: I want to support "regular expression search".
05:04:57 <chrisdone> Hoogayootee
05:05:05 <copumpkin> regular type search!
05:05:08 <aristid> > 1E9 :: Rational
05:05:09 <lambdabot>   1000000000 % 1
05:05:12 <chrisdone> so just patch hoogle?
05:05:16 * geheimdienst points out that hayoo is much better than hoogle
05:05:17 <aristid> > 1E-9 :: Rational
05:05:18 <lambdabot>   1 % 1000000000
05:05:25 <chrisdone> geheimdienst: how???
05:05:27 <copumpkin> "Find me a type isomorphic to mu x. 1 + (a, x)
05:05:41 <mm_freak> ManateeLazyCat: i don't know yet, i'll write my monad library first
05:05:43 <copumpkin> granted, that's a context-free type
05:05:47 <mm_freak> and i have a question related to it:
05:05:48 <mm_freak> io :: LiftBase m a => Base m a -> m a
05:06:02 <mm_freak> Base is an associated type of LiftBase
05:06:39 <ManateeLazyCat> geheimdienst: hayoo can use offline?
05:06:45 <mm_freak> how can i restrict Base m a to IO a?
05:06:45 <mm_freak> is this possible?
05:07:09 <copumpkin> Base m a ~ IO a
05:07:11 <copumpkin> does that work?
05:07:34 <copumpkin> not sure whether it likes free variables in there
05:07:57 <geheimdienst> chrisdone: hoogle always seems to not find what i'm looking for. apparently it doesn't look in posix packages at all
05:08:36 <mm_freak> copumpkin: nope, that gives me a syntax error
05:08:37 <geheimdienst> if i could only remember what that hoogle problem was i had the other day ... hang on ...
05:08:43 <copumpkin> mm_freak: wait, really?
05:08:48 <copumpkin> I wouldn't expect a syntax error
05:08:52 <copumpkin> you put it in the context?
05:08:59 <mm_freak> oh, wait
05:09:15 <copumpkin> (LiftBase m a, Base m a ~ IO a) => Base m a -> m a
05:09:18 <mm_freak> copumpkin: that works
05:09:20 <mm_freak> thanks a lot =)
05:09:22 <copumpkin> np :)
05:09:47 <mm_freak> is there a 'not equal to', too?
05:09:51 <copumpkin> nope :(
05:09:56 <copumpkin> it's a lot harder
05:09:58 <mm_freak> hmm, that's sad
05:10:13 <ManateeLazyCat> How to do "DiffTime -> UTCTime" ?
05:10:32 <ManateeLazyCat> @hoogle DiffTime -> UTCTime
05:10:32 <lambdabot> Data.Time.Clock UTCTime :: Day -> DiffTime -> UTCTime
05:10:32 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
05:10:33 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
05:10:45 <mm_freak> another question…
05:10:51 <copumpkin> ManateeLazyCat: I'm guessing you need more information :)
05:10:59 <mm_freak> monadLib defines the transformer class as:
05:11:01 <copumpkin> ManateeLazyCat: as in, a single DiffTime isn't sufficient to give you a UTCTime
05:11:07 <mm_freak> class MonadT t where
05:11:10 <mm_freak>   lift :: Monad m => m a -> t m a
05:11:10 <copumpkin> but I've actually never played with any of the time libs
05:11:29 <ManateeLazyCat> copumpkin: I know it's come from 1970.
05:11:31 <mm_freak> mine looks like this: class Transformer t m where lift :: m a -> t m a
05:11:37 <ManateeLazyCat> copumpkin: Maybe i need build 1970 time first
05:11:41 <ManateeLazyCat> copumpkin: Then add DiffTime.
05:11:49 <copumpkin> hm, maybe :)
05:11:52 <mm_freak> is there any advantage of monadLib's approach (besides not needing MPTCs)?
05:12:26 <Saizan> is there any advantage to yours?
05:12:30 <ManateeLazyCat> @hoogle secondsToDiffTime
05:12:30 <lambdabot> Data.Time.Clock secondsToDiffTime :: Integer -> DiffTime
05:12:30 <lambdabot> Data.Time.Clock picosecondsToDiffTime :: Integer -> DiffTime
05:12:46 <mm_freak> Saizan: hmm, good point
05:12:54 <ddarius> mm_freak: The monadLib one explicitly states that the transformer can transform any monad.
05:13:27 <mm_freak> well, yes, mine has one advantage
05:13:36 <mm_freak> for some monads it gets along without the Monad constraint
05:13:57 <mm_freak> for example my IdT needs only Applicative to be a monad transformer
05:14:15 <geheimdienst> anyhoo, hoogle won't even find anything if you search "data.either" or "data.maybe"
05:14:20 <mm_freak> well
05:14:21 <mm_freak> no
05:14:25 <geheimdienst> so i like hayoo much better
05:14:27 <mm_freak> it doesn't even need Applicative
05:14:32 <mm_freak> it needs no constraint at all
05:14:45 <copumpkin> geheimdienst: I think it might just be what each one chooses to index
05:14:55 <copumpkin> you can install a local hoogle and ask it to index everything you want, if you choose
05:15:26 <mm_freak> ddarius: do you see this as an advantage?
05:15:41 <copumpkin> it makes a stronger logical statement in the type itself
05:16:23 <ddarius> mm_freak: The type guarantees that the transformer is a transformer.
05:16:26 <geheimdienst> i think what it "just" chooses to index is a big part of how useful a search thingy is
05:16:35 <mm_freak> ddarius: i see
05:17:04 <mm_freak> would you consider it bad, if the class doesn't make it explicit?
05:17:21 <ddarius> Yes.
05:17:57 <ddarius> Or more accurately, you'd be defining a class for something other than monad transformers.
05:20:34 <mm_freak> ok
05:20:49 <mm_freak> then i'll follow monadLib's approach
05:22:59 <handonson> How do I get a 'module name' of "Something.hs" with the GHC API?
05:24:22 <enigmus> Is there a way to have GHC check for incomplete case pattern? (like ocaml, or even gcc do)
05:26:53 * ManateeLazyCat Damn, time package don't like me...
05:27:00 <ddarius> -fwarn-incomplete-patterns or just -Wall
05:30:17 <ManateeLazyCat> > fromGregorian 1970 1 1
05:30:18 <lambdabot>   Not in scope: `fromGregorian'
05:30:36 <pchiusano_> I am trying to understand this ArrowLoop impl and it does not make sense to me: http://hpaste.org/30102/arrowloop_impl
05:30:53 <pchiusano_> it is from the causal commutative arrows paper
05:30:55 <MasseR> If I have a monad transformer, can I somehow get the monad "inside it?". IE ReaderT String IO (), can I somehow get the IO ()?
05:31:02 <MasseR> for example for forkIO
05:32:04 <pchiusano_> MasseR: fmap ?
05:33:14 <mornfall> liftIO
05:33:29 <mornfall> But forkIO has a different problem -- the parameter.
05:34:41 <MasseR> mornfall: is it "ok" to do something like this:
05:34:44 <MasseR> g <- asks
05:34:58 <MasseR> forkIO (runReaderT foo g)
05:35:14 <mornfall> MasseR: Well, nothing should prevent that (although you probably mean ask not asks?)
05:35:18 <shajen> hi
05:35:22 <MasseR> Err yeah
05:35:30 <pchiusano_> this is the line I am struggling with: where h f x = let ((y, z), f’) = unSF f (x, z) in (y, SF (h f’))
05:35:30 <mornfall> And you need to say liftIO $ forkIO (...)
05:35:32 <shajen> can you tell me what is wrong with http://pastebin.com/5vhimkaX
05:37:26 <mornfall> shajen: There's no way to make a finite element of that data type.
05:37:31 <mornfall> s/element/value/
05:38:14 <ddarius> The CCA paper is pretty good.
05:38:56 <pchiusano_> ddarius: ya it is cool
05:38:58 <mornfall> shajen: Btw. the data type (if you fix its uninstantiability) is actually a tree.
05:39:12 <shajen> no, not a tree
05:39:16 <ddarius> pchiusano: The z on the right comes from the z on the left.
05:39:22 <ddarius> let is a (recursive) binding form.
05:39:27 <shajen> list of two-way
05:39:31 <mornfall> shajen: Well, whatever you *intended*, the result *is* a tree.
05:39:34 <mornfall> A binary one.
05:39:57 <ManateeLazyCat> @hoogle fromSeconds
05:39:57 <lambdabot> No results found
05:41:20 <pchiusano_> ddarius: something does not make sense still
05:42:01 <pchiusano_> ddarius: if you use the loop state to produce your output, how can you produce the "first" output
05:42:48 <geheimdienst> ManateeLazyCat: here's a fromSeconds: http://hackage.haskell.org/packages/archive/datetime/latest/doc/html/Data-DateTime.html
05:42:56 <ddarius> pchiusano: There will need to be a delay in the loop.
05:43:00 <ManateeLazyCat> geheimdienst: Yeah, i have know it.
05:43:10 <ManateeLazyCat> geheimdienst: Just lambdabot too stupid
05:43:14 <ddarius> shajen: Your code is ugly and you are doing it all wrong.  See the Tying the Knot page on the wiki.
05:43:33 <geheimdienst> (that's why i like hayoo better than hoogle ... hayoo found it rightaway)
05:43:52 <ManateeLazyCat> geheimdienst: hayoo can index local package?
05:44:08 <ManateeLazyCat> @hayoo fromSeconds
05:44:08 <lambdabot> Unknown command, try @list
05:44:24 <dmwit> shajen: In case nobody has said it yet, you can't bind the same variable name twice in one pattern (as in line 7).
05:44:40 <pchiusano_> ddarius: what happens if there is no delay in the loop
05:44:45 <dmwit> shajen: If you want those two values to be the same, you must explicitly check for that condition, after giving them different variable names.
05:44:58 <pchiusano_> ddarius: it seems like it would not terminate
05:45:02 <ddarius> pchiusano: You'll get an infinite loop or a blackhole exception.
05:45:28 <pchiusano_> ddarius: okay, phew, I thought I was going crazy
05:45:51 <pchiusano_> ddarius: so basically, the thing that feeds the loop state back as input needs to have a delay on it
05:46:11 <ddarius> The passed in arrow, yes.
05:46:12 <pchiusano_> although that is not enforced in the type systemm
05:46:42 <ddarius> There's a crummy paper/presentation about using "dependent" type to enforce such constraints.
05:46:44 <pchiusano_> i guess it is similar to how haskell will not tell you if any random program you write won't terminate :)
05:47:26 <ddarius> The paper/presentation doesn't actually use dependent types, just some basic type level computation.  You could encode their system into Haskell.
05:47:37 <pchiusano_> ddarius: i can imagine how it would work
05:48:30 <pchiusano_> ddarius: okay, well this clears things up
05:48:40 <pchiusano_> thank you :0
05:49:16 <pchiusano_> ddarius: incidentally, do you happen to know if there have been extensions to CCAs to handle ArrowChoice ?
05:49:35 <pchiusano_> it doesn't look like anything has been published yet
05:49:43 <pchiusano_> i know they mention it as future work in the paper
05:50:37 <ddarius> I've only read the original paper.
05:52:35 <handonson> What should I do in order for GHC.getBindings to return something other than []?
05:52:45 <pchiusano_> ddarius: okay word
05:53:12 <pchiusano_> I gotta jet, thanks for help :)
05:53:19 <handonson> i've tried load, loadModule, setContext but none seems to work
05:54:50 <geheimdienst> ManateeLazyCat: i don't know if hayoo can do that. i always use http://holumbus.fh-wedel.de/hayoo/hayoo.html
05:56:58 <yitz> handonson: getBindings ?
05:57:06 <yitz> @hoogle getBindings
05:57:06 <lambdabot> No results found
05:57:23 <handonson> yitz: https://haskell.org/ghc/docs/6.12.2/html/libraries/ghc-6.12.2/GHC.html#v%3AgetBindings
06:01:09 <_vlad> pl \x y -> x y
06:01:22 <_vlad> @pl \x y -> x y
06:01:22 <lambdabot> id
06:01:47 <_vlad> @pl  (\acc x -> acc * 26 + (ord x - (ord 'a') + 1))
06:01:47 <lambdabot> (. ((1 +) . subtract (ord 'a') . ord)) . (+) . (26 *)
06:04:24 * frerich reminds himself once more to read up what the 'id' function does which he sees every now and then and which appears to be a strange no-op.
06:04:35 <ManateeLazyCat> Good, 332 and 333 pass...
06:05:03 <theorbtwo> :t id
06:05:04 <lambdabot> forall a. a -> a
06:05:32 <theorbtwo> Oh.  Hm.  That's not actually the signature I expected.
06:05:42 <handonson> i think the only raison d'etre of id is the pointfree school.
06:06:14 <earthy> maybe 0 id $ Just 2
06:06:14 <Philippa> no, there're other times when id gets passed to a HOF
06:06:50 <Philippa> especially if you're factoring everything carefully - there might be a wrapper that passes id in for you, but even so
06:07:20 <Philippa> frerich: id = \x -> x , it's the identity function, returns its parameter unchanged
06:07:35 <earthy> yes, it's a no-op. no, that's not strange
06:07:47 <earthy> you *want* to be able to say 'don't do a thing'
06:08:05 <handonson> you can always say (\x->x)
06:08:12 <handonson> just a little longer.
06:08:26 <visof> hello
06:08:30 <handonson> that's my rationale
06:08:36 <Philippa> yeah, but why /not/ name it?
06:08:45 <handonson> why not not name it? :)
06:08:51 <frerich> earth: Hm so 'id' is used when I'm expected to give a function which maps an 'a' to an 'a' but doesn't actually do anything? Like, when calling a higher order function?
06:08:56 <visof> can i do that , foo = sum[1..10^6] putStr foo ?
06:09:08 <frerich> Ah, HOF == higher order function, I get it now.
06:09:12 <Philippa> naming it's shorter, requires only one token to be understood and doesn't leave people having to check up to alpha-equality
06:09:23 <earthy> frerich: bingo.
06:09:52 <handonson> alpha-equality?
06:09:58 <siracusa> visof: putStr (show foo)
06:10:04 <earthy> \x -> x is alpha-equal to \y -> y
06:10:07 <sepp2k> visof: You can do  let foo = sum [1..10^6] in print foo
06:10:24 <Philippa> or to \twiddle->twiddle
06:10:30 <Philippa> for a more misleading example
06:11:02 <handonson> why should people have to check extra stuff when they use (\x->x) instead of id?
06:11:07 <frerich> earthy: Will GHC do some sort of const folding when I call the map function on a list and I pass 'id' as the functor?
06:11:12 <handonson> :%s/have to//g
06:11:26 <earthy> handonson: because (\x -> x') doesn't look all that different and is *not* equivalent
06:11:31 <Philippa> handonson: it has extra structure to it, which makes checking that it /is/ \x -> x harder
06:11:32 <frerich> earthy: As in, static analysis could show that the 'map' call can be optimized away, right?
06:11:52 <Philippa> frerich: it often inlines things, yes. It's not guaranteed though
06:11:57 <earthy> frerich: I'm not sure if it does always
06:12:09 * frerich nods
06:12:10 <earthy> it tries to, and succeeds often.
06:12:11 <Philippa> that's another good reason for id though: it's much easier to write rewrite rules for itr
06:12:12 <Philippa> *it
06:12:59 <handonson> earthy: you shouldn't be using confusing identifiers at all. if it happens, it's programmers' fault :)
06:13:21 <Philippa> that's not good enough, you still have to expend brain cycles confirming it hasn't happened
06:13:28 <Philippa> also, id is much quicker to type!
06:13:36 * earthy nods
06:13:58 <earthy> handonson: your way lies madness. :)
06:14:19 <handonson> i'm not objecting the naming of \x->x
06:14:33 <Philippa> to go the other way: sure, let's do that. Also, let's replace True and False with expanded out versions of tru and fals!
06:15:02 <earthy> yes! go SKI calculus! :)
06:15:07 <mm_freak> *Main> evalCont $ modifyCont (+1) >> abort 2 >> return 10
06:15:07 <mm_freak> 3
06:15:25 <handonson> i said id is for pointfree style, and Philippa objected it by saying 'no', but he didn't suggest any evidence :)
06:15:31 <earthy> and why not use church numerals. ;)
06:15:52 <Philippa> handonson: she
06:15:58 <frerich> Is there a way in Haskell to get a handle on a function (and possible evaluate it) given a string which represents the function name? If so, then "id" and \x->x would not be equivalent since the former could be caleld by such a code but the latter couldn't, right?
06:16:03 <handonson> oops, my apologies. :)
06:16:11 <earthy> handonson: is   maybe 0 id   for a function  Maybe Int -> Int  not a useful way of using id that is not point-free ?
06:16:31 <Philippa> also, I provided the general case of passing id into a higher-order function as a counter-example
06:16:40 <earthy> frerich: yes, there is, and it is called rewrite-rules
06:16:48 <Philippa> id frequently facilitates refactoring in that manner
06:17:02 <Philippa> and yes, the interaction with rewrite rules /is/ important there
06:17:12 <handonson> no, what you two suggested is, that id is better than (\x->x) with reason A and reason B and etc., but that's exactly the argument for pointfree style
06:17:41 <handonson> "maybe 0 id is better than maybe 0 (\x->x)" is a claim that pointfree style is preferred in this context
06:17:46 <ddarius> "There is no substitute for good manners, except, maybe fast reflexes'
06:17:59 <earthy> *the* reason id is better than \x->x is that you need to be able to pass the function 'don't do a thing' to higher order functions
06:18:21 <earthy> points don't enter into that argument
06:18:35 <handonson> aren't you able to pass the function 'don't do a thing' by (\x->x)? :)
06:18:37 <DrSyzygy> earthy: There's nothing that prevents you from passing \x->x around in that case.
06:19:03 <DrSyzygy> However, rewrite rules and similar reasons are much more solid reasons.
06:19:08 <earthy> you are. however, then we get to 'we'd want to do that more often.. so maybe we should just name the silly thing'
06:19:37 <ddarius> id is important enough to be named
06:19:41 * earthy nods
06:19:50 <handonson> i know!
06:19:51 <handonson> i'm not objecting the pointfree style. i'm saying that id is merely the pointfree version of (\x->x), and the only benefit that id will have over (\x->x) is the benefit of pointfree style
06:20:04 <DrSyzygy> handonson: Not the only reason.
06:20:09 <DrSyzygy> Hrm. Benefit.
06:20:10 <earthy> no! id is *not* the pointfree version of (\x->x)
06:20:21 <handonson> really?
06:20:24 <ddarius> handonson: There is little benefit to id in point-free style.  id . f = f.
06:20:27 * frerich apologizes for kicking off this argument by asking a little question after lurking for days :-}
06:20:32 <earthy> id is the *name* given to \x -> x
06:20:38 <handonson> @pl (\x->x)
06:20:39 <lambdabot> id
06:20:39 <earthy> frerich: no probs. :)
06:21:04 <handonson> earthy: then we have different opinions about what 'version' means. :)
06:22:06 <Philippa> handonson: define id without using a bound variable. That's what earthy means.
06:22:20 <ddarius> id = id
06:22:22 <Philippa> frerich: don't worry about it. Usually someone learns something
06:22:35 <Philippa> ddarius: technically you're binding id :p
06:22:35 <DrSyzygy> ddarius: Wasn't that the definition of undefined?
06:22:57 <ddarius> :t let id = id in id :: a -> a
06:22:58 <lambdabot> forall a. a -> a
06:23:00 <ddarius> Good enough for me.
06:23:08 <handonson> yeah!
06:23:13 <earthy> philippa: quite. plus, check page 110 of the haskell '98 report
06:23:28 <earthy> (which quite clearly defines id in pointful style ;))
06:23:52 <ddarius> instance Monoid a where mempty = undefined; mappend = unamb
06:23:55 <DrSyzygy> :t let undefined = undefined in undefined :: a
06:23:56 <lambdabot> forall a. a
06:23:59 <Philippa> anyway, I don't write an awful lot of code that most people'd describe as pointless and I still use id plenty
06:24:07 * earthy nods
06:24:27 <handonson> who opposes it? :)
06:24:34 <earthy> btw, handonson, would you call const to be only for pointfree code? :)
06:24:47 <earthy> and what about ($)? :)
06:25:03 <ddarius> earthy sets a trap
06:25:06 <Philippa> or <$>, <*>...
06:25:51 <handonson> <del>i think >> and >>= is for pointfree supporters and the do notation is the only orthodox way of building monads</del>
06:25:56 <tab> oh no, another pointless debate
06:26:06 <tab> (someone had to do it :))
06:26:07 * earthy grins at tab
06:26:09 <handonson> is -> are
06:26:40 <DrSyzygy> tab: What's your point?
06:27:02 <tab> DrSyzygy: no point, I'm pointfree
06:27:16 <frerich> Meta-question: is it possible to feed commands to lambdabot (like :t <foo>) privately? Sometimes I'd like to play with it but I don't want to embarrass myself in front of you people. :-] I tried a /query but that doesn't seem to cause any reaction.
06:27:33 <ddarius>  /query should work
06:27:34 <earthy> frerich: yes, but you need to register with nickserv first
06:27:34 <tab> frerich: can't you use ghci for that ?
06:27:53 <ddarius> I've never registered with nickserv and never had trouble talking to lambdabot
06:27:55 <frerich> tab: If I had it around, I could - yes. Or I could use one of the online interpreters, I guess. It's just a convenience thing.
06:28:03 <Philippa> tab: a lot of phones'll run an IRC client but not ghci, for example
06:28:15 <tab> fair enough .. i guess :)
06:28:44 <frerich> earthy: Hmm, I'm registered with nickserver already.
06:28:54 <earthy> and it doesn't work? that's odd.
06:29:09 <yitz> handonson: there must be something called "withGHC" somewhere. I can't find it in the docs tho
06:29:21 <earthy> you do realise that expressions to be evaluated need to be prefixed with > ?
06:30:05 <yitz> handonson: otherwise, it seems you would have to manually write out an entire DynFlags by hand in order to do anything with the Ghc monad.
06:30:06 <frerich> earthy: Ah! No, I didn't. I only saw people writing ":t blah" here all the time without a leading '>'
06:30:10 <ddarius>  :t doesn't work in privmsg
06:30:15 <ddarius> Use @type
06:30:25 <handonson> yitz: apologies for my poor knowledge, but isn't withGHC for doing something outside the GHC monad? i'm currently working inside the GHC monad.
06:31:05 <frerich> ddarius: Perfect! Thanks!
06:31:09 <handonson> yitz: or maybe you are referring to the GHC API up to 6.8. I hear that a huge API change was once made at that moment.
06:31:14 <yitz> handonson: well presumably you would wrap your entire Ghc monad value in withGHC in order to run it
06:31:27 <handonson> oh, sorry
06:31:45 <yitz> handonson: could be. i saw withGHC mentioned in the haddocks, but it was not linked.
06:32:27 <handonson> yitz: could you take a look at my code?
06:32:28 <yitz> handonson: without that, runGhc require a DynFlags argument, and I don't see any obvious way to get one of those ready made
06:33:00 <handonson> http://hpaste.org/30103/ghc_api_test_01
06:34:03 <handonson> sorry for a bad and dirty code :)
06:37:27 <yitz> handonson: why do you have defaultErrorHandler outside the runGhc call instead of inside it?
06:37:27 * ddarius considers using virtualbox as an interpreter.
06:37:28 <handonson> oh, please note that to run that code, there needs to be a valid Haskell module named "Main" in somewhere lookup-able for GHC, or you may change the { example "Main" } part to the path to any valid haskell source code
06:37:35 <yitz> right
06:38:02 <handonson> yitz: uhm, i don't know. that was the way suggested in http://haskell.org/haskellwiki/GHC/As_a_library
06:38:12 <yitz> i see now, DynFlags.defaultDynFlags
06:38:43 <yitz> handonson: really? weird, i don't understand why that even typechecks
06:38:58 <yitz> handonson: oh, ok, i see
06:40:35 <handonson> the code works for other things, and I even managed to run (interpreted) an IO operation of some other haskell module
06:41:20 <handonson> it just doesn't show me the bindings loaded for the current session, which is what getBindings is supposed to do
06:41:55 <yitz> handonson: interesting, that's cool.
06:43:04 <yitz> handonson: but you're not using binding for anything in that code.
06:45:11 <handonson> yitz: yes, i want to load the top-level bindings in Main into the session. i looked up for a function that does it, but couldn't find any.
06:46:01 <handonson> i thought, at least one of load, loadModule and setContext should do it, but apparently i was wrong.
06:47:30 <yitz> what do you mean load the bindings?
06:48:25 <yitz> you did loadModule - shouldn't its names now be in scope?
06:49:14 <yitz> handonson: try printing "binding" at the end, instead of "n".
06:49:48 <handonson> yitz: oops, that's a typo in the paste. the current version has "binding" there.
06:50:03 <yitz> oh ok
06:50:20 <handonson> yitz: they are in scope, and i can runStmt "blah blah", everything's fine, i just want to see the list of available definitions loaded
06:50:27 <handonson> like function definitions, data definitions
06:50:33 <handonson> classes, types, ...
06:50:37 <yitz> yes
06:50:39 <handonson> defined in Main.
06:51:03 <yitz> handonson: try runStmt "let foo=42", then see if that binding shows up
06:51:14 <handonson> sure
06:51:48 <handonson> yitz: it does. now i get ["Identifier `x'"] instead of []
06:52:08 <handonson> now... how can i get this working for the bindings in Main?
06:52:52 <handonson> (and preferably, some other stuff loaded by Main too)
06:53:05 <yitz> good! progress.
06:53:14 <handonson> yes. thanks. :)
06:53:37 <yitz> handonson: i guess you need to do the equivalent of ":m" in ghci
06:54:24 <handonson> hmm. right. i thought loadModule was for that, but there's gotta be something else.
06:55:02 <handonson> or maybe it's impossible, because
06:55:05 <handonson> (Just info) <- getModuleInfo $ ms_mod modSum
06:55:14 <handonson> with this line, i get the info of the Main module
06:55:34 <handonson> and I can inspect the bindings with { modInfoTyThings info }
06:56:02 <handonson> so, maybe i'm not supposed to drag those bindings into the session
06:56:17 <handonson> i should just access it via modInfoTyThings?
07:02:05 * ddarius was looking at how qemu handled full access to networking hardware, and their approach is simple and elegant.
07:10:16 <handonson> yes, they use the ancient esoteric Art of Muesoyu, which channels the structure of this world to a paradimensional networking hardware. The Art is known to have been mastered by Haskell B. Curry
07:12:23 <frerich> Does anybody have a good rule of thumb or something which makes it easier to read pointfree expressions? I find it a bit mind-bending to read longer expressions from the right to the left. I'm sure I'll get used to it at some point, but maybe there's a little trick to make reading it out (or rather: reading it out mentally) nicer.
07:13:39 <leod> http://codepad.org/FXIQgwwD -- dynamic multiple dispatch using type classes, is that possible? (i've asked before, but had to go somewhere)
07:15:20 <handonson> frerich: that's why some people oppose the approach of point-free style, worried about it being overused
07:15:23 <yrlnry> Is there anything handy for dealing with bifunctors?  Hoogle didn't come up with anything.
07:15:53 <yrlnry> Or maybe there isn't because the typeclass system isn't quite powerful enough.
07:15:53 <handonson> i think (caution: i can be severely wrong) a radical example is http://subtextual.org/
07:17:28 <mm_freak> given cf <*> cx, in which order should the computations be carried out?
07:17:35 <mm_freak> first cx or first cf?
07:17:52 <yrlnry> "should"?
07:18:05 <yrlnry> It could go either way, or both, or neither.
07:18:07 <Peaker> mm_freak, unspecified (for IO it's l-to-r)
07:18:16 <mm_freak> i see
07:18:18 <roconnor> @hoogle permute
07:18:18 <lambdabot> Text.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
07:18:19 <lambdabot> Text.ParserCombinators.Parsec.Perm permute :: Stream s Identity tok => StreamPermParser s st a -> Parsec s st a
07:18:19 <lambdabot> System.Console.GetOpt Permute :: ArgOrder a
07:18:25 <mm_freak> what makes sense for a state monad?
07:18:31 <mm_freak> first cf or first cx?
07:20:36 <yrlnry> For a state monad, it's not going to propagate the state changes anyway, so it doesn't matter.
07:22:42 <mm_freak> yrlnry: huh?
07:23:14 <mm_freak> > runState ((put 3 >> pure id) <*> (put 4 >> pure 3)) 0
07:23:15 <lambdabot>   No instance for (Control.Applicative.Applicative
07:23:16 <lambdabot>                     (Contr...
07:23:33 <mm_freak> > runStateT 0 $ (set 1 >> pure id) <*> (set 2 >> pure 3)
07:23:34 <mm_freak> (3,2)
07:23:34 <lambdabot>   Not in scope: `set'Not in scope: `set'
07:23:38 <mm_freak> at least in monadLib
07:23:48 <mm_freak> and my library is going to propagate the state as well
07:28:41 <aristid> mm_freak: is your IdT public somewhere?
07:28:58 * ManateeLazyCat 353 now...
07:30:23 <dankna> I can't install QuickCheck-2.3 because "It requires ghc -any.  There is no available version of ghc that satisfies -any."  This strikes me as a very weird problem, especially considering that I recently wiped my whole Haskell installation and redid it based on Haskell-Platform.
07:30:25 <dankna> Is it a known problem?
07:30:36 <mm_freak> aristid: not yet
07:30:39 <dankna> I'm looking at the cabal file for QC now and I don't see anything obvious
07:30:46 <mm_freak> but i think i'll upload the library today
07:30:53 <mm_freak> aristid: why?
07:31:19 <applicative> danka, does ghc-pkg list show ghc-... as exposed?
07:31:30 <aristid> mm_freak: just curious how it works
07:31:40 <applicative> the Haskell platform hides it by default, i think
07:31:47 <ManateeIrcClient> danka: Use "ghc-pkg check" first
07:31:55 <ManateeIrcClient> danka: Maybe something wrong
07:32:00 <dankna> hmmm
07:32:10 <dankna> doing those things with ghc-pkg reveals some problems
07:32:18 <Saizan> applicative: Cabal doesn't care about the hideness
07:32:22 <ManateeIrcClient> dankna: Any output from "ghc-pkg check"?
07:32:22 <dankna> apparently upgrading Cabal and cabal-install broke my ghc
07:32:34 <applicative> ManateeIrcClient Like I said, I think it is hidden by default, like the parallel haskell
07:32:40 <dcoutts> dankna: current QuickCheck depends on the ghc package, apparently your ghc package is borked
07:32:42 <mm_freak> aristid: well, very obvious:  newtype IdT m a = IdT { getIdT :: m a }
07:32:51 <dankna> dcoutts: hmm yes, it looks like it is
07:32:55 <mm_freak> aristid: but i implemented it just for the sake of completeness
07:33:01 <mm_freak> IdT is not really useful
07:33:02 <Saizan> dankna: did you rm ~/.cabal without rm ~/.ghc ?
07:33:07 <dankna> oh!
07:33:21 <dcoutts> dankna: did you upgrade some core package that ghc depends on?
07:33:24 <aristid> mm_freak: you said it doesn't require m to be a monad?
07:33:25 <applicative> Saizan, how could that be, I hide and expose all the time with eg the four hundred monad transformer libs.
07:33:36 <dankna> what's the global equivalent of ~/.ghc?  I have stuff set to install globally always.
07:33:44 <dankna> I did, I upgraded the cabal library and cabal-install
07:33:53 <dankna> which apparently ghc depends on, since that broke it
07:33:54 <applicative> oh wait, the cabal lib comes with ghc
07:34:23 <Saizan> applicative: cabal only cares about what's in build-depends, hiding/exposing only matters if you manually use ghc or ghci 
07:34:35 <dcoutts> dankna: so what does ghc-pkg check say about the ghc package?
07:34:43 <dankna> oh, let me nopaste it for you
07:34:59 <mm_freak> aristid: no, that was about ContT
07:35:23 <mm_freak> aristid: ContT doesn't require m to be a monad, until runContT
07:35:29 <aristid> mm_freak: oh
07:35:33 <mm_freak> the instance definitions mostly get along without a Monad constraint
07:35:37 <applicative> Saizan, I see, it only comes crying to me when theres a conflict, as with e.g. the monad tranformer libraries?
07:36:05 <aristid> mm_freak: well it's kinda pointless to use a non-Monad m when you can't runContT it ;)
07:36:10 <applicative> Is it right to suspect that danka overwrote his Cabal by installing it globally?
07:36:17 <aristid> but if it makes the instance declarations simpler, sure
07:36:27 <Saizan> applicative: that's a possibility
07:36:38 <dcoutts> applicative: only if he reinstalled the same version, if he installed a new version then it should be fine
07:37:21 <mm_freak> aristid: yes, and i never said it's a great feature, it's just interesting =)
07:38:01 <ddarius> yrlnry: category-extras has some bifunctor stuff
07:38:12 <ddarius> There is no trouble making bifunctor classes in Haskell
07:38:25 <applicative> dcoutts, I see.  I do remember overwriting the same one somehow with ghc head, and witlessly had no local/global distinction.
07:38:29 <ddarius> It's trickier to make a more generic one but still feasible.
07:39:19 <applicative> dcoutts, but is this true, that `cabal install` will use unexposed packages?  But that hiding helps it with conflict?
07:39:59 <dcoutts> applicative: cabal install does not consider the exposed/not-exposed info
07:40:34 <dcoutts> applicative: hiding helps ghci e.g. when there are two packages providing Control.Monad.Foobar
07:40:48 <applicative> I see, i must just be thinking of ghc, not sure how I mixed it in with cabal install.  It's obvious the .cabal file knows which package to use
07:41:06 <dcoutts> ie when using ghci / ghc --make, in the case that you do not specify any packages and just rely on the current environment
07:41:27 <dcoutts> hiding is a way of persistently adjusting the current environment
07:42:39 <applicative> dcoutts, yes, thats when i use it, if e.g. I import a module requiring the avant-garde-transformers version of Control.Monad.Foobar and thus hide mtl, etc
07:42:58 <applicative> stupidly mixed it in with `cabal install`
07:44:51 <dankna> http://hpaste.org/30109/ghcpkg_check_output
07:46:11 <ManateeLazyCat> dankna: I suggest you reinstall ghc-6.12.3 and all cabal packages.
07:46:25 <dankna> yeah, but
07:46:30 <applicative> I see, this is very much the error I had with ghc head a while back.  Perhaps my analysis that I had overwritten the installed Cabal-a.b.c was wrong
07:46:31 <ManateeLazyCat> dankna: That's the simplest way i can think.
07:46:51 <Saizan> dankna: can you also paste ghc-pkg list?
07:46:57 <dankna> I don't mind doing that, but I do want the ability to use a later version of cabal than the one that comes with it.  Saizan: sure, one sec
07:47:18 <applicative> You can do that danka, as dcoutts said.  
07:47:24 <Saizan> dankna: having a later version is fine, deleting/overwriting the installed one is the problem
07:47:25 <dcoutts> dankna: you can install a later Cabal, the problem here is you reinstalled the same version (against different versions of its deps)
07:47:31 <dankna> oh hmm
07:47:54 <applicative> Does the Haskell Platform have the most recent version of Cabal? 
07:48:02 <dcoutts> dankna: btw I'd also suggest using --user installs by default, it's easier to fix things if you make a mistake
07:48:07 <dcoutts> applicative: yes
07:48:26 <applicative> I see. So it's very easy if you don't make a global v. user distinction. 
07:48:46 <dankna> repload http://hpaste.org/30109/ghcpkg_check_output for output of ghc-pkg list
07:48:50 <dankna> *reload
07:48:50 <applicative> I guess you'd have to --reinstall
07:49:14 <dankna> I find it easier to fix things with --global, honestly, because I can wipe the entire thing more easily (I don't have to move aside my config file and move it back)
07:49:37 <dankna> I use a custom path, /usr/local/cabal/, so that it never conflicts with any default installs.  or shouldn't!
07:49:45 <Saizan> dankna: you don't have to remove .cabal, .ghc is enough
07:49:53 <dankna> oh
07:49:55 <dankna> never knew that
07:50:13 <Saizan> anyhow, i don't see the ghc-pkg list at that url :)
07:50:17 <dankna> I still prefer it global because this way I can experience these problems on my laptop before I experience them on my server, where I genuinely need global
07:50:22 <ManateeLazyCat> dankna: If you want re-install ghc, remove ~/.ghc and ~/.cabal is enough.
07:50:23 <applicative> yeah danka it didn't update
07:50:29 <dankna> oh, it didn't update, whoops
07:50:30 <Saizan> but i think we can be quite sure you've overwritten your Cabal
07:50:34 <dankna> yeah, I think so too
07:51:02 <ManateeLazyCat> dankna: Maybe /usr/local/lib/ghc-6.12.3
07:51:11 <dcoutts> dankna: it's not the location of the files that's relevant here, it's the fact that it shares the global package db/
07:51:12 <dankna> http://hpaste.org/30110/ghcpkg_list_output if anyone still needs it
07:51:15 <Saizan> anyhow, it's much easier if you never use "cabal upgrade"
07:51:17 <applicative> swank new hpaste... too much material at the top of the screen though
07:51:27 <dankna> oh hmm
07:51:36 <dcoutts> dankna: oh did you use cabal upgrade ?
07:51:41 <dankna> I may have, I don't remember
07:51:44 <dankna> it's quite possible
07:51:49 <ManateeLazyCat> dankna: cabal upgrade is the do right thing like it's name : upgrade.
07:51:58 <dcoutts> dankna: I've removed the "feature" in the latest cabal-install
07:51:59 <ManateeLazyCat> dankna: s/do/don't
07:52:31 <dankna> dcoutts: oh cool, good
07:53:15 <ManateeLazyCat> dankna: You can use "cabal upgrade" or "cabal list foo" to check whether have new version, then use "cabal install" install the package you want upgrade.
07:53:23 <dankna> right okay
07:53:45 <dankna> anyway, I'll wipe and reinstall and be more careful this time
07:53:55 <ManateeLazyCat> dankna: And don't upgrade *core* package, it's easy to broken basic package like your current situation.
07:54:03 <dankna> I appreciate that --global gets less testing than --user, but I do think it's worth it to me to be one of the people who "tests it with my face"
07:55:08 <dankna> the occasional glitch like this is bearable, and as I say, if I didn't use it here I would run into these problems when doing upgrades on my server and it would be an emergency situation
07:55:15 <dcoutts> dankna: it's not that it's less tested, it's that it means you're modifying the package db that contains the core libs.
07:55:22 <dankna> hmm
07:55:28 <dankna> I suspected after I said it that you might say that
07:55:51 <dcoutts> dankna: there are certainly ways we could make it safer, but they all take time to implement
07:55:55 <dankna> oh of course
07:57:03 <applicative> danka, I use the --global --user distinction to keep track of what ghc+Platform libs contained, vs. the things I may have trashed myself.  
07:57:06 <ManateeLazyCat> dankna: Try to fix like dcoutts' suggestion, if still can't work, best to re-install all packages (include ghc).
07:57:48 <dankna> yeah I can just reinstall
07:57:50 <applicative> If you want things in /usr/local you could try to replicate the distinction somehow, maybe
07:57:55 <dankna> applicative: I see that, yeah, hmm
07:57:59 <Saizan> maybe in the current situation cabal should warn before overwriting
07:58:19 <dankna> ghc-pkg itself supports arbitarily many database files, right?
07:58:29 <dankna> I think a good design for the feature might be to have /three/ domains
07:58:32 <dankna> system global user
07:58:37 <dankna> system you can never install into
07:58:37 <dcoutts> Saizan: I'd accept a patch to do that
07:58:44 <applicative> Saizan, certainly with the libraries that come with ghc
07:59:02 <ManateeLazyCat> dankna: AFAIK, just two : global db, and user db.
07:59:16 <dankna> right, I'm suggesting changing that
08:01:13 <applicative> danka, that does make sense, now that you mention it. The (mercifully for the world) few places where I have things installed for several users, I just end up making local .cabals due to the practice mentioned above. 
08:01:23 <dankna> yeah...  glad you think so
08:03:06 <dankna> if you're curious, my webserver uses a CMS I have written (am perpetually writing) in Haskell and it's easiest and most-Unix-like to install it globally so that it can be run from /etc/init.d/
08:03:13 <dankna> there are other solutions but this one works for me and I like it
08:03:22 <dankna> so that's why I'm so attached to --global
08:03:50 <dankna> but yeah, there's no need for --global to modify the package db that comes with ghc.  just teach ghc where to find the package db that --global uses.
08:04:20 <dankna> which as I understand it is just a matter of modifying a central list or something
08:04:44 <writer> Has anyone noticed the weirdly formatted HTML output generated by Pandoc ?
08:04:47 <dankna> my interest in this idea does not extend to being willing to write code for it though :)
08:04:57 <dankna> as I just don't have time this month :)
08:06:08 <applicative> it like the only real problem is the danger of overwriting the fundamental libs that come with ghc like base, ghc etc 
08:06:14 <applicative> writer, yes
08:06:18 <dankna> right
08:06:20 <applicative> it's due to the XML libs
08:06:24 <dankna> exactly
08:06:35 <applicative> writer, you can run it through "tidy"
08:06:49 <writer> applicative: oh, thanks
08:06:51 <Saizan> it doesn't strictly need code, your system db could be what Cabal/ghc-pkg calls --global and your global could be one you pass with the --package-db/--package-conf flag
08:07:01 <applicative> pandoc -r markdown -html foo.txt | tidy > foo.html
08:07:40 <dankna> hmm
08:07:53 <applicative> writer, it's valid html, and evades some possible ambiguity about line endings.  But it's ugly and in fact, some browsers make a hash of it.
08:08:25 <Saizan> --user won't fit with this scheme, and i don't see a way to have your version of user, but you didn't want it anyway :)
08:09:55 <dcoutts> dankna: I agree, we should have a constant system package db and a /usr/local one plus the per-user one.
08:10:27 <writer> applicative: but it's not valid XML :(
08:10:43 <applicative> writer, it may be to do with quotation marks?
08:11:12 <writer> applicative: quotation marks ?
08:11:18 <applicative> are you using the smart quotes extension
08:11:36 <writer> -:3: parser error : Extra content at the end of the document\n><p <<<< output of xmllint
08:12:03 <applicative> hmmm.  what command are you giving pandoc?
08:12:09 <writer> cat text |pandoc -r markdown -t html
08:12:13 * hackagebot gsl-random 0.4.1 - Bindings the the GSL random number generation facilities.  http://hackage.haskell.org/package/gsl-random-0.4.1 (PatrickPerry)
08:12:27 <applicative> i see, it's a fragment, then, not a standalone doc
08:12:40 <applicative> Is that what you wanted?
08:13:06 <applicative> try cat text |pandoc -r markdown -t html -s 
08:13:23 <writer> applicative: yes, thanks
08:14:19 <applicative> tidy should be run on the complete document.  Now that one thinks of it, that might not be ideal.  
08:15:02 <dankna> dcoutts: cool
08:16:19 <writer> applicative: thanks for your help
08:18:14 * hackagebot contstuff 0.1.0 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.1.0 (ErtugrulSoeylemez)
08:18:25 <mm_freak> i've uploaded the contstuff package now
08:18:32 <yrlnry> http://hpaste.org/30108/duplicate_instance_declaration  I'm puzzled by this.  The message "duplicate instance declaration" is clear enough, but I don't understand why it's a problem in this instance, or if there's a way to work around it.
08:18:44 <mm_freak> it's not finished, but you can already play with it…  i'd be happy to get feedback
08:19:01 <Entroacceptor> I got the basename of a file ("example") and a list of (extension, handler) pairs (currently a map, [("html", htmlHandler), ("markdown", markdownHandler)]...) . There must be a short way to find the first filename+extension that actually exists on the filename
08:19:17 <mm_freak> aristid: there you go, the package is online =)
08:19:26 <Entroacceptor>  filez <- Map.filterWithKey (\k _ -> doesFileExist $ s++"."++k) fileHandlers    obviously can't work.
08:19:52 <applicative> writer, thanks. tell your friends about pandoc: it must take over the world!
08:20:12 <aristid> mm_freak: cool, where?
08:20:31 <mm_freak> aristid: http://hackage.haskell.org/package/contstuff-0.1.0
08:20:44 <geheimdienst> Entroacceptor: you mean it can't work because doesFileExist is IO ...?
08:20:49 <Entroacceptor> geheimdienst: yes
08:21:00 <writer> applicative: sure :)
08:21:11 <geheimdienst> you could say something like: filez <- sequence $ Map.filterWithKey ...
08:21:19 <geheimdienst> :t sequence
08:21:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
08:21:56 <applicative> writer, tell them about #haskell when they have trouble installing it.  I wish it weren't such a nightmare....  
08:22:11 <geheimdienst> it kinda pulls the IO out of the list
08:22:12 <Entroacceptor> geheimdienst: mh, no...
08:22:31 <applicative> writer, I mean, for non programmer types. 
08:22:38 <writer> applicative: that's mostly distro's problems which don't pre-package it, with so many dependencies, and so less time..
08:22:39 <geheimdienst> oh excuse me. you wanted filterWithKey
08:22:56 <Peaker> :t sequenceA
08:22:57 <lambdabot> Not in scope: `sequenceA'
08:23:02 <Entroacceptor> geheimdienst: I don't actually want that, it was just what I had so far ;)
08:23:04 <Peaker> :t Control.Traversable.sequenceA
08:23:05 <lambdabot> Couldn't find qualified module.
08:23:07 <aristid> mm_freak: oh, somehow didn't connect the hackagebot announcement with your statement :)
08:23:12 <Peaker> @hoogle sequenceA
08:23:13 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
08:23:13 <lambdabot> Data.Foldable sequenceA_ :: (Foldable t, Applicative f) => t (f a) -> f ()
08:23:16 <geheimdienst> (what i said would apply if you made a list of IO actions and run that ...)
08:23:40 <aristid> how long does hackage need to generate the haddock docs of new packages?
08:23:49 <Entroacceptor> geheimdienst: well, I get a basename and want to check which file I could handle does actually exist...
08:23:52 <applicative> writer, yeah, but that you refer to 'distro's shows you know far more than the average one called 'writer'.  installing it on macs or windows involves quite a few hoops.
08:24:03 <applicative> jumping through them
08:24:39 <Entroacceptor> maybe I could get a list of existing files and  intersect the extensions or something...
08:24:49 <writer> applicative: I'm monadic writer who dreams of becoming average writer :)
08:25:21 <applicative> 'i'm trapped in the writer monad'
08:25:54 <geheimdienst> Entroacceptor: you should try what Peaker suggested (sequenceA)
08:26:10 <applicative> now i'm thinking i should get back to writing. enough of this haskell nonsense.  it is too beautiful for human beings anyway. 
08:26:53 <writer> applicative: execWriter :)
08:29:29 <Entroacceptor> mhm, and traverse over what?
08:31:58 <ddarius> yrlnry: Haskell doesn't look at context when doing instance resolution so both of those instances simply say: forall type constructors ff and types a/b Functor has an instance.
08:33:07 <yrlnry> Thanks.
08:33:21 <yrlnry> Is there a workaround for this case?
08:33:49 <copumpkin> yrlnry: not a single one, it often just means you need to rethink how you're doing it
08:34:22 <yrlnry> okay.
08:34:24 <ddarius> yrlnry: Not anything pretty.  Also, your instances don't make a lot of sense, particularly the second one.  Your Bifunctor class also doesn't make a lot of sense.
08:34:41 <yrlnry> I think I used the term 'bifunctor' incorrectly.
08:35:10 <ddarius> yrlnry: The weird thing is it being a multiparameter type class.
08:35:11 <cizra> ManateeLazyCat: Is there GTK2 assistant support in gtk2hs?
08:35:20 <cizra> ManateeLazyCat: http://library.gnome.org/devel/gtk/stable/GtkAssistant.html
08:35:48 <ddarius> Also, your second instance would have the wrong type for what you intend.
08:36:17 <yrlnry> I think I'm going to have to leave this for another time when I'm not tired and sick.   Thanks very much for looking at it.
08:36:54 <ddarius> A typical, covariant in each argument Bifunctor class would look like: class Bifunctor f where bimap :: (a -> a') -> (b -> b') -> f a b -> f a' b'
08:37:22 <ddarius> You can then define ltFmap/rtFmap in terms of bimap or have them as defaulted methods.
08:37:58 <yrlnry> I saw that in Control.Monadextras
08:38:17 <yrlnry> (Also, Hoogle did not find it when I searched for "bifunctor".  Do you know why not?)
08:38:58 <ddarius> Hoogle probably doesn't index category-extras.
08:39:18 <copumpkin> hayoo tends to have more breadth 
08:39:45 <copumpkin> is there standard naming for all the (co/contra)variance combinations in bifunctors?
08:39:51 <copumpkin> or do you just explicitly say each
08:42:44 <ddarius> Categorists usually just give the "type" of the functor.
08:42:55 <copumpkin> ah
08:45:16 <Entroacceptor> sequenceA confused me...
08:45:23 <dmwit> :t sequenceA
08:45:24 <lambdabot> Not in scope: `sequenceA'
08:45:32 <dmwit> :t Control.Applicative.sequenceA
08:45:33 <lambdabot> Not in scope: `Control.Applicative.sequenceA'
08:45:34 <geheimdienst> Entroacceptor: i don't understand it either ... never used it
08:46:21 <dmwit> > Data.Traversable.sequenceA [Just 3, Just 4]
08:46:22 <lambdabot>   Just [3,4]
08:46:38 <dmwit> > Data.Traversable.sequenceA [Just 3, Just 4, Nothing]
08:46:39 <lambdabot>   Nothing
08:46:53 <dmwit> > Data.Traversable.sequenceA (Just [3, 4, 5])
08:46:53 <geheimdienst> > sequence [Just 3, Just 4, Nothing]
08:46:54 <lambdabot>   [Just 3,Just 4,Just 5]
08:46:54 <lambdabot>   Nothing
08:47:16 <Entroacceptor> ok, this confused me even more
08:47:39 <geheimdienst> > sequence [Just 3, Just 4]
08:47:40 <lambdabot>   Just [3,4]
08:47:46 <geheimdienst> > sequence [Just 3, Just 4, Nothing]
08:47:47 <lambdabot>   Nothing
08:47:58 <Entroacceptor> I fail to see how to apply that to my filter 
08:48:14 <dmwit> ?quickcheck \x -> let s = Data.Traversable.sequenceA in s (s (s x)) == s x
08:48:14 <lambdabot> Unknown command, try @list
08:48:25 <dmwit> ?list
08:48:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:48:35 <dmwit> ?check \x -> let s = Data.Traversable.sequenceA in s (s (s x)) == s x
08:48:36 <lambdabot>   No instance for (GHC.Classes.Eq (f (f a)))
08:48:36 <lambdabot>    arising from a use of `GHC.Cl...
08:48:49 <dmwit> ?check \x -> let s = Data.Traversable.sequenceA in s (s (s x)) == s x :: [Maybe Int]
08:48:50 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe GHC.Types.Int]'
08:49:14 * dmwit shrugs
08:57:16 <sinelaw> Peaker, 
08:57:22 <dmwit> preflex: seen chrisdone
08:57:23 <preflex>  chrisdone was last seen on #haskell 3 hours, 51 minutes and 58 seconds ago, saying: geheimdienst: how???
08:57:40 <dmwit> ?ask chrisdone if he wouldn't mind adding #xmonad as a channel choice for hpaste.org
08:57:40 <lambdabot> Consider it noted.
08:57:48 <sinelaw> doh, just installed xchat-gnome and shift-letter does not make it uppercase
08:57:50 <sinelaw> weird.
08:57:58 <Peaker> sinelaw, hey hey .. I gotta go, be back in 40-60 min
08:58:09 <sinelaw> Peaker, k
09:01:41 <gbacon> using hxt, I'd like to run two separate extraction passes against the same XML document, but I'm having trouble getting it without parsing the XML twice
09:02:22 <gbacon> and readDoc path >>> (f &&& g) has type [(a,b)] rather than (a, [b])
09:03:36 <sinelaw> i need to record audio 
09:08:27 <geheimdienst> can i somehow pull the returns out of this? «if ... then f >> return () ; else g >> return ()» f and g have different types but i care about none of the returned things
09:10:02 <ddarius> geheimdienst: No, you can't.
09:10:52 <geheimdienst> bah
09:10:56 <Philonous1> geheimdienst: You could write your won combinator: ignore = (>> return ()); IfI p a b = if p then ignore a else ignore b
09:11:18 <fasta> geheimdienst, you can with fundeps.
09:11:53 <fasta> geheimdienst, IMHO, conditionals are pretty much broken in Haskell, but they can be fixed with functional dependencies.
09:12:00 <geheimdienst> so, there's no "when"-like function that takes both a then and an else? when and unless squished together
09:12:06 <ddarius> ignore = (() <$)
09:12:27 <Zao> geheimdienst: "if"?
09:12:45 <geheimdienst> zao, the trouble is that if requires both branches to be of the same type
09:13:08 <Zao> geheimdienst: So you want something like   when p (...); unless p (...)
09:13:17 <geheimdienst> exactly
09:13:33 <geheimdienst> okay i guess i'll just write that function then
09:14:04 <ddarius> :t let mif b t e = if b then () <$ t else () <$ e in mif
09:14:05 <lambdabot> forall (f :: * -> *) b b1. (Functor f) => Bool -> f b -> f b1 -> f ()
09:15:38 <sinelaw> anyone here use haskell for audio processing ?
09:15:39 <geheimdienst> er, it appears i'm not the first one to run into this :-) http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=ifM
09:16:39 <Philonous1> geheimdienst: ifM appears to be something else. "ifM p a b = p >>= \p -> if p then a else b" or something like that
09:16:55 <fasta> geheimdienst, my 'when' can take both Bool and m Bools for example.
09:17:14 <fasta> geheimdienst, and there are a bunch of other features. 
09:17:23 <fasta> geheimdienst, everyone hates it, I think. 
09:18:30 <geheimdienst> Philonous1: yeah it's similar, but not the exact same thing. ifM takes an m Bool, for starters
09:18:32 <geheimdienst> fasta, what package is your «when» in?
09:18:37 <ManateeLazyCat> cizra: Are you there? Sorry, haven't seen your message.
09:19:23 <aristid> :t fmap . const
09:19:25 <lambdabot> forall a b (f :: * -> *). (Functor f) => b -> f a -> f b
09:20:01 <ManateeLazyCat> @tell cizra I forgot this module, i will add it to darcs repository today.
09:20:01 <lambdabot> Consider it noted.
09:20:23 <ManateeLazyCat> @tell cizra Then Assistant will include in gtk-0.12.0
09:20:23 <lambdabot> Consider it noted.
09:20:39 <ManateeLazyCat> brb
09:21:18 <quicksilver> geheimdienst: "when p (...); unless p (...);" ... since you're ignoring the results of both, the (...) are effectively type m ()
09:21:31 <quicksilver> geheimdienst: in that case, if p then (...) else (...) does indeed type check.
09:26:01 <rschnck> Is there a way to write a list in the form of x:y:ys for the input of a function? Like myListfunction (x:y:ys)?
09:26:05 <rschnck> Whenever I try I get an error.
09:26:20 <Twey> rschnck: Nothing wrong with that
09:26:23 <sinelaw> > 1:2:3
09:26:24 <lambdabot>   No instance for (GHC.Num.Num [t])
09:26:25 <lambdabot>    arising from a use of `e_1123' at <int...
09:26:40 <sinelaw> > 1:2:3:[]
09:26:41 <lambdabot>   [1,2,3]
09:26:41 <geheimdienst> > let f (x:y:ys) = y:x:ys in f "lolcats"
09:26:42 <lambdabot>   "ollcats"
09:26:43 <Twey> > (\(x1 : x2 : xs) -> x1 + x2) [1, 3, 5]
09:26:44 <lambdabot>   4
09:27:00 <rschnck> Twey: Had an extra "(" =/
09:27:06 <rschnck> Thanks
09:27:14 <Twey> Heh
09:27:35 <Twey> On the whole, in Haskell, if you think that you ought to be able to do something, then you probably can.
09:28:16 <geheimdienst> ... a few phd theses later
09:28:21 <monochrom> I don't believe that.
09:28:21 * sinelaw 's ears ring painfully, was wearing earphones, pressed play, forgetting the volume at 100%
09:28:33 <sinelaw> *eeggghhhaa*
09:29:22 <monochrom> the average programmers "ought to be able to" is dominated by "IO a -> a" and "a -> b"
09:35:56 <copumpkin> dons: was just looking to sign up on cufp.org, but found http://snapplr.com/308w
09:36:53 <copumpkin> not really sure what belongs in the companies field :) "bungee jumping", maybe
09:38:19 <geheimdienst> the explanatory text is one meta-level too high
09:39:17 <gbacon> can I turn a constructor into a predicate without having to write isFoo (Foo _) -> True?
09:39:26 <copumpkin> no
09:39:32 <gbacon> > span Left [Left 1, Right 2]
09:39:33 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
09:39:33 <lambdabot>         against inferred type ...
09:40:26 <quicksilver> gbacon: no, you can't. Occasionally it seems like a nice idea to have these predicates defined automatically by, e.g., a data.derive or DrIFT thing.
09:40:45 <quicksilver> either, the isFoos, or a shadow data type which is constructors only
09:40:53 <quicksilver> data T = A a | B b;
09:41:04 <quicksilver> data T_Cons = TC_A | TC_B;
09:41:15 <quicksilver> constructor_of :: T -> T_Cons
09:45:51 <quicksilver> in fact, I strongly suspect that's what http://hackage.haskell.org/packages/archive/derive/latest/doc/html/Data-Derive-Is.html is
09:45:55 <quicksilver> but it's not documented
09:46:57 <quicksilver> yes, it is.
10:01:15 <copumpkin> hmm, seem to be getting runaway memory usage on quickcheck in ghci
10:07:09 <enigmus> There is really something difficult with Haskell: whenever I do anything with 10 millions "elements" and over, it is so easy to use 5 GB of RAM (where the same thing would take < 500MB in C). I have some understanding of why that is, but my question is: are there people here who routinely handle large data sets in Haskell (large graphs, for instance)? And what is their approach to minize such problems? Anything under half a billion "elements
10:08:08 <Zao> enigmus: Truncated at "under half a billion "elements
10:08:18 <enigmus> Zao: sorry
10:08:34 <enigmus> w Anything under half a billion "elements" is usually just fine in C these days on a workstation, I'd like to get a feeling of what people would say is an equivalent in Haskell. (an "element" = a small datastructure of 32B, say)
10:09:12 <roconnor> enigmus: what data do you have?
10:09:13 <Zao> If the algorithm is largely sequential or chunked, process a stream instead of loading it all in.
10:09:16 <sproingie> dealing with large data sets is a challenge in any language.  zipper might be good for traversal.
10:09:26 <Zao> If it's random-access, consider some kind of mmap maybe, or a more compact representation.
10:10:30 <enigmus> sproingie: to an extent, but in C, it is very easy to control the memory overhead. In Haskell, I don't have (yet?) a good enough grasp to know in advance: (i) whether it can fit, (ii) what the overhead will be (iii) where to sprinkle `seq`, etc.
10:10:42 <sproingie> laziness lets you deal with a lot of things as a stream, but watch out for space leaks
10:11:03 <sproingie> sometimes its best to enforce the, ah, streaminess of it
10:11:21 <sproingie> the iteratee stuff might help, i've never really looked into it tho
10:12:07 <writer> is there any function in Haskell base library which lets you replace fst or snd of a tuple and return the modified tuple. c -> (a, b) -> (c, b)
10:12:27 <sproingie> enigmus: getting a handle on memory usage in haskell is a bit of a black art sometimes.  best approach so far is just choosing the right algorithm for space usage, same idea as choosing the right one for speed
10:12:31 <roconnor> @type first
10:12:32 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:12:41 <roconnor> > first (+1) (2,3)
10:12:42 <lambdabot>   (3,3)
10:12:55 <writer> aah, thanks roconnor 
10:12:55 <roconnor> > second (+1) (2,3)
10:12:56 <lambdabot>   (2,4)
10:13:29 * writer has completely forgotten about Arrows
10:13:59 <sproingie> forget about Arrows, Slings are where it's at :)
10:14:07 <roconnor> :O
10:14:24 <enigmus> sproingie: Yeah, I do find it hard to have visibility on memory usage. The impact of optimizations on memory usage is something I'm having trouble with.
10:14:30 <sproingie> Slings and Arrows of Outrageous Haskell
10:15:34 <enigmus> Do you know of open source projects that have to deal with the kind of problems I'm talking about?
10:15:53 <sproingie> enigmus: there's various heap profiling options, but it is definitely a pretty advanced area.  bit like an automatic transmission: you don't have to know how to work a clutch, but if you gotta fix it, it gets really hairy
10:15:58 <geheimdienst> don't bring a sling to an arrow fight
10:16:36 <enigmus> geheimdienst: are you saying, don't use Haskell? :)
10:17:19 <sproingie> haskell is more like a hwacha
10:17:36 <geheimdienst> i'm saying don't import import Control.Sling if you can import Control.Arrow. however, Control.Gun would be superior to both
10:17:58 <sproingie> http://www.youtube.com/watch?v=jeQTpmaEkMY
10:18:22 <enigmus> sproingie: hehe
10:19:50 <roconnor> Control.Gun.unsafeShootLeg
10:25:27 <ryo_hazuki> heyho
10:25:28 <copumpkin> I want a haskell refactoring tool that allows you to do "rewrite f", which means that it secretly stashes the old f away somewhere, lets you rewrite the new one, and then runs a bunch of quickcheck tests against them to make sure they're equivalent
10:26:14 <ManateeLazyCat> copumpkin: Consider your ticket. :)
10:28:17 <sproingie> copumpkin: sounds like something that should go into leksah
10:28:23 <ryo_hazuki> how would you write a function that returns (a1,a2) where the a1 is a random number, and the a2 is a1 + 1?
10:29:01 <geheimdienst> > (id &&& succ) 42
10:29:02 <lambdabot>   (42,43)
10:29:16 <sproingie> theres those arrows again
10:29:43 <copumpkin> nobody uses arrows as arrows, though
10:30:10 <sm> wah.. this yesod screencast just freaked me out - http://vimeo.com/14922583 13:00. How does users <- runDB $ selectList [] [] 0 0 know to query the users table ?
10:30:12 <copumpkin> if someone secretly removed the arrow polymorphism on &&&, ***, first, second and restricted it to (->), nobody would ever notice
10:30:37 <sproingie> what if someone replaced them with Folgers Crystals?
10:30:38 <ManateeLazyCat> @tell cizra I have push new patch to add module 'Windows.Assistant', Axel and me quite busy recently, we could not release gtk-0.12.0 in this month, so i suggest you fetch darcs version and test Assistant APIs, if have any bug, we can fix it before gtk-0.12.0. Enjoy! :)
10:30:39 <lambdabot> Consider it noted.
10:30:53 <conal> copumpkin: tangible functional programming would notice.
10:31:14 <c_wraith> copumpkin, that's not true.  lots of people would notice, as they'd suddenly be able to read the type signature for those functions. :)
10:31:14 <conal> copumpkin: but i suspect you're right that most people wouldn't.
10:31:42 <ryo_hazuki> :t &&&
10:31:43 <lambdabot> parse error on input `&&&'
10:31:50 <sproingie> :t (&&&)
10:31:50 <roconnor> :t (&&&)
10:31:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:31:51 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
10:31:52 <geheimdienst> in particular, i don't really know what &&& has to do with arrows ... it's a thing that runs two functions on the same arguments, returning both values in a tuple. this is useful independent of arrows and categories and whatnot
10:32:01 <ryo_hazuki> haha
10:32:09 <ryo_hazuki> hell of type sig :D
10:32:11 <copumpkin> if anything, I'd like it polymorphic on another axis
10:32:17 <copumpkin> any covariant bifunctor
10:32:18 <conal> c_wraith: :)
10:32:24 <copumpkin> instead of on the arrow
10:32:49 <conal> it'd sure help if those type-sigs were changed to use an infix variable for the arrow
10:32:57 <roconnor> :t (&&&) :: (a -> b) -> (a -> b') -> (a -> (b,b'))
10:32:58 <lambdabot> forall a b b'. (a -> b) -> (a -> b') -> a -> (b, b')
10:33:01 <copumpkin> yeah
10:33:03 <sproingie> covariant bifunctor is one of those things that sounds kinky but isnt
10:33:05 <conal> e.g., (b ~> c) instead of a b c
10:33:12 <sproingie> bit like monostable multivibrator
10:33:50 <geheimdienst> @src (&&&)
10:33:51 <lambdabot> f &&& g = arr (\b -> (b,b)) >>> f *** g
10:34:01 <Saizan> copumpkin: (&&&) wouldn't make much sense for Either
10:34:02 <geheimdienst> yeah that helps a lot ...
10:34:02 <ManateeLazyCat> @tell cizra Please send to gtk2hs list if you have any problem, sometimes i perhaps can't see your message on #haskell. 
10:34:03 <lambdabot> Consider it noted.
10:34:11 <copumpkin> Saizan: true, I was mostly talking about *** :)
10:34:19 <copumpkin> which I use more,anyway
10:34:24 <c_wraith> :t left
10:34:25 <copumpkin> and first/second
10:34:25 <lambdabot> forall (a :: * -> * -> *) b c d. (ArrowChoice a) => a b c -> a (Either b d) (Either c d)
10:34:35 <sproingie> :t first
10:34:35 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
10:34:41 <ryo_hazuki> which package has (&&&) ?
10:34:46 <c_wraith> Control.Arrow
10:34:50 <ryo_hazuki> ty
10:35:00 <copumpkin> Saizan: although it wouldn't not make sense, would it?
10:35:29 <copumpkin> oh I guess it would
10:35:37 <copumpkin> @djinn (b -> c) -> (b -> c') -> (b -> Either c c')
10:35:38 <lambdabot> f a _ b = Left (a b)
10:35:39 <copumpkin> :P
10:35:47 <sproingie> forall (a :: * -> * -> *) b c d. (b ~> c) -> ((b, d) ~> (c,d))
10:35:48 <copumpkin> pretty useless
10:35:55 <ManateeLazyCat> Night all! :)
10:36:01 <ryo_hazuki> nn
10:36:02 <sproingie> not too bad, but i have a hard time seeing the ~ vs the -
10:36:42 <sproingie> maybe doubled.  ~~>
10:36:51 <Saizan> ⇒
10:36:57 <geheimdienst> why not use a letter for ~>
10:37:12 <sproingie> the idea is something you can read infix
10:37:31 <geheimdienst> best would be "a", so that it blends in and appears as though it's very similar to b c d, where in fact it's completely different
10:37:31 <ryo_hazuki> i didn't get it yet as it seems - i got the feeling atm:
10:38:00 <ryo_hazuki> randomAddOne = do k <- randomRIO (1,10)
10:38:00 <ryo_hazuki>                   return ((k &&& succ) k)
10:38:23 <ryo_hazuki> that would fit my understanding of it actually... and is wrong :))
10:38:29 <sproingie> (b ~~> c) -> ((b,d) ~~> (c,d))
10:38:35 <sproingie> that totally works for me now
10:39:11 <geheimdienst> ryo_hazuki: in that case you can just do: return (k, k+1)
10:39:53 <geheimdienst> (if you want to use &&&, you would have to use it on two functions. succ is a function, but k is not.)
10:40:13 <ryo_hazuki> if thats the case, what would the type sig of randomAddOne then?! I thought of (IO Int, IO Int)
10:40:15 <ryo_hazuki> oh, ok
10:40:50 <geheimdienst> sproingie, i think you didn't understand. the idea is to make the haddock as impenetrable as possible. you're ruining it with your ~~> things and otherwise intuitive naming
10:41:00 <roconnor> @type (return &&& liftM succ) (randomRIO (1,10))
10:41:02 <lambdabot> forall (m :: * -> *) a1. (Monad m, Enum a1, Num a1, Random a1) => (m (IO a1), IO a1)
10:41:23 <roconnor> @type WrapMonad
10:41:24 <lambdabot> forall (m :: * -> *) a. m a -> WrappedMonad m a
10:41:27 <geheimdienst> "only those who travel the long path of the 18 ICFP papers are worthy of using my library"
10:42:11 <geheimdienst> "only those who meditate for 7 years about the type signature are worthy"
10:42:24 <roconnor> hmm
10:48:22 <sinelaw> Peaker, there now?
10:48:30 <geheimdienst> :t (id &&& id)
10:48:31 <lambdabot> forall b. b -> (b, b)
10:50:23 <geheimdienst> > (id *** succ) 42
10:50:24 <lambdabot>   (42,43)
10:51:36 <zachk> > ((^2) &&& (^4)) 5 
10:51:37 <lambdabot>   (25,625)
10:52:12 <c_wraith> :t (id *** id)
10:52:13 <lambdabot> forall b b'. (b, b') -> (b, b')
10:52:18 <zachk> :t curry 
10:52:19 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
10:52:46 <geheimdienst> > second (id, succ)
10:52:47 <lambdabot>   No instance for (Control.Arrow.Arrow (,))
10:52:48 <lambdabot>    arising from a use of `Control...
10:52:54 <geheimdienst> > second (id, succ) 42
10:52:55 <lambdabot>   Couldn't match expected type `t1 -> t'
10:52:55 <lambdabot>         against inferred type `((d, ...
10:53:20 <c_wraith> second's first argument is a function
10:53:26 <c_wraith> :t second
10:53:27 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
10:53:51 <c_wraith> if you're assuming (->) is the only Arrow instance ever :)
10:53:51 <geheimdienst> *cough* the first argument is a function, as is clearly apparent from the type signature *cough*
10:54:04 <geheimdienst> @instances Arrow
10:54:05 <lambdabot> (->), Kleisli m
10:54:17 <c_wraith> > second (*5) ("foo", 3)
10:54:18 <lambdabot>   ("foo",15)
10:54:27 <c_wraith> look, second = fmap!
10:54:31 <geheimdienst> it's not like there's a whole lot of instances besides (->) ...
10:54:46 <c_wraith> > fmap (*5) ("foo", 3)
10:54:47 <lambdabot>   ("foo",15)
10:54:51 <geheimdienst> ah thanks, right that was how second worked
10:55:31 <monochrom> "Kleisli m" looks like just a few letters but stands for an infinite family of instances.
10:55:41 <gwern> hm. second's first argument is a first-order function applied to the second argument first then the second?
10:55:41 <lambdabot> gwern: You have 1 new message. '/msg lambdabot @messages' to read it.
10:55:46 <gwern> @messages
10:55:46 <lambdabot> xplat said 2d 21h 20m 5s ago: if you ever need to keep a queue of variable-sized items in a file, use one file to add things to and another reversed file to take things off of, you get amortized O(1)
10:55:47 <lambdabot> . either that or assume failure is rare and scan your recent work when you start after failure and bunch atomic queue updates at checkpoints
10:56:26 * gwern wonders how high the fraction of number-words can go in sentences about `second`
10:56:49 <andrewsw> hi, does anyone actually use hpaste.el? noone's updated it on haskellwiki since 2008 and it appears at least part of it is broken
10:58:15 <geheimdienst> i mean, if you use haskell, you must be pretty resistant to gibberish (otherwise you'd have run away long ago) ... but Control.Arrow really takes incomprehensibility to a whole new level
10:58:50 <sinelaw> quick editor poll
10:59:09 <chrisdone> budum tish
10:59:10 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
10:59:10 <sinelaw> i was using emacs till now, considering the alternatives
10:59:15 <chrisdone> @messages
10:59:15 <lambdabot> dmwit asked 2h 1m 36s ago: if he wouldn't mind adding #xmonad as a channel choice for hpaste.org
10:59:25 <sinelaw> any suggestions?
10:59:27 <gwern> I use emacs during a waxing moon, but yi if it's waning
11:00:14 <geheimdienst> chrisdone: i believe what dmwit said was "?ask chrisdone if he wouldn't mind ..."
11:00:19 <chrisdone> dmwit: done!
11:00:21 <gwern> but only when the wind is from the southeast and I can tell a hawk from a handsaw
11:00:32 <sinelaw> gwern, so you use emacs
11:00:44 <sinelaw> i'd love to ditch emacs
11:01:19 <chrisdone> sinelaw: why?
11:01:32 <monochrom> Oh! right, where is amelia?
11:01:40 <sinelaw> i got used to being able to do pretty much everything i want in the editor
11:01:43 <gwern> monochrom: out stealing gnomes and tossing dwarves
11:01:55 <monochrom> ...
11:01:55 <sinelaw> but its annoying to configure
11:01:55 <chrisdone> monochrom: amelia is a beautiful name
11:01:59 <enigmus> Some help with writing signatures for local functions? http://hpaste.org/30114/writing_signature_for_local_fu
11:02:04 <geheimdienst> preflex: seen amelia
11:02:04 <preflex>  amelia was last seen on #perl 2 years, 7 days, 10 hours, 26 minutes and 39 seconds ago, saying: f00li5h: iwkse wants to know who you are... he's priv messaging random people asking about you. could you please tell him or something so i don't have to be bothered by your problem.
11:02:04 * hackagebot Fungi 1.0.2 - An interpreter for Funge-98 programming languages, including Befunge.  http://hackage.haskell.org/package/Fungi-1.0.2 (ThomasEding)
11:02:13 <sinelaw> and i'd like more intelligent assitance when writing code
11:02:19 <geheimdienst> on #perl? 2 years ago?
11:02:33 <monochrom> I mean chrisdone's paste bin
11:02:45 <sinelaw> chrisdone, you're still with emacs?
11:02:50 <sinelaw> (or never was?0
11:02:54 <chrisdone> monochrom: http://hpaste.org/ or http://paste.tryhaskell.org/
11:03:22 <chrisdone> sinelaw: I'm using emacs, still writing code for it regularly http://github.com/chrisdone/haskell-mode-exts
11:03:30 <sinelaw> chrisdone, cool
11:03:31 <monochrom> hrm, they do look identical!
11:03:43 <gwern> what I like about emacs is that it'll be around in another 10 or 20 years
11:03:50 <gwern> which is not something I could say about yi
11:03:51 <chrisdone> monochrom: I left paste.tryhaskell.org up until hpaste.org propagates through the intertubes
11:04:02 <monochrom> I see. Makes sense.
11:04:04 <sinelaw> chrisdone, cool.
11:04:32 <sinelaw> chrisdone, mind to send me your emacs configs? i just reformatted my system
11:04:35 * monochrom mumbles something about "referentially transparent"
11:04:41 <chrisdone> sinelaw: what I like about Emacs is I get out what I put in
11:04:48 <geheimdienst> chrisdone: good work on hpaste, by the way. it looks awesome. thanks a lot
11:04:59 <chrisdone> geheimdienst: thanks! :-)
11:05:08 <monochrom> so this means hpaste.org won't give me another "error 500" again? :)
11:05:14 <sinelaw> chrisdone, yeah, i do love emacs but its age is showing
11:05:16 <andrewsw> I gather the above explains at least part of why hpaste.el is broken??
11:05:27 <chrisdone> monochrom: indeed. -- or *if* it does, I'll fix it
11:05:29 <sinelaw> we really need a haskell-based emacs (which is what yi is supposed to be?)
11:05:39 <sinelaw> with emacs' performance
11:06:04 <monochrom> coolest thing about amelia is that she is self-hosting, i.e., her first paste is her own source code :)
11:06:05 <chrisdone> andrewsw: sorry yeah, I'll make a page that pretends to recieve inputs like hpaste2 sometime this week
11:06:14 <chrisdone> monochrom: haha
11:06:31 <gwern> sinelaw: with emacs' performance? why are you wishing the worst of both worlds on us :(
11:06:50 <sinelaw> gwern, well, i'm comparing emacs to eclipse
11:06:57 <sinelaw> so it's like a bolt of lightning
11:07:00 <andrewsw> chrisdone: I see. I was just going to start hacking on hpaste.el... I've already got hpaste-get-paste working.
11:07:05 <geheimdienst> monochrom: so, can i edit the first paste ...?
11:07:06 <monochrom> lambdabot's first words: "oooohhh, functional programmers are so hot".  amelia's first words: "oooohhh, I'm so hot"
11:07:17 <chrisdone> hahaha
11:07:44 <ryo_hazuki> randomAddOne n = randomRIO (1,10) >>= return . ap (,) (+1)
11:07:51 <ryo_hazuki> i find this one much more elegant and easier to read than the other suggestions
11:07:55 <ryo_hazuki> forget about the n :)
11:08:01 <chrisdone> andrewsw: ah, er, well, I was gonna provide a json interface or something. if you've already patched hpaste.el that's cool! what should I do?
11:08:01 <andrewsw> chrisdone: (and some of the bugs I'm finding are bit-rot, not hpaste.org changes)
11:08:11 <sinelaw> chrisdone, so do you care to share your init.el and whatever?
11:08:31 <chrisdone> sinelaw: err I'd need to share a .zip
11:08:37 <sinelaw> chrisdone, i can eat that
11:08:59 <sinelaw> chew, and spit out in pieces that add up to something bigger
11:09:09 <andrewsw> chrisdone: don't do anything you weren't going to do already (is that english?). 
11:09:31 <chrisdone> andrewsw: yes, that's fine english and okay :-)
11:10:00 <andrewsw> chrisdone: I haven't really started other than a couple line change to make hpaste-get-past work again. Haven't looked at the rest yet...
11:10:15 <andrewsw> heh... get-past...
11:10:39 <chrisdone> sinelaw: k... hang on
11:10:49 <chrisdone> andrewsw: alright
11:12:21 <chrisdone> sinelaw: here's my .emacs http://hpaste.org/30115/emacs uploading a .zip now
11:13:47 <sm> chrisdone: is there a way to play back your emacs-cast repo ?
11:14:03 <chrisdone> sm: I'm working on something to do that
11:14:35 <chrisdone> some in-browser javascript 'gitcast' type thing
11:14:51 <sm> oh, not in emacs itself. I guess that would be harder
11:15:04 <sm> sounds useful
11:15:35 <sm> I suppose you could also record a screen/dtach session somehow
11:15:37 <chrisdone> it'd be easier in emacs too but I want to reach a wider audience
11:15:46 <sm> or just video.. 
11:16:21 <chrisdone> I worked on it over the course of two days so I didn't want to record a video
11:16:47 <chrisdone> like remembering to press pause when I go for a drink, etc. :p
11:16:55 <sm> I see
11:17:43 <chrisdone> sinelaw: http://chrisdone.com/code/Emacs.zip
11:18:57 <chrisdone> sm: plus I like the idea of speeding it up, like etherpad
11:19:55 <mreh> is this kind of thing possible?: (sf1, (b0, c0)) = tf10 (a0, c0)
11:20:10 <copumpkin> mreh: I have no idea what that means
11:20:16 <mreh> D:
11:20:29 <mreh> want some types?
11:20:44 <mreh> I'll show you the source
11:20:57 <mreh> http://hackage.haskell.org/packages/archive/Yampa/0.9.2.3/doc/html/src/FRP-Yampa.html#loopPrim
11:21:01 <copumpkin> just not sure what you're trying to express there
11:21:06 <copumpkin> an irrefutable pattern?
11:21:08 <mreh> it's clearly possible, I'm asking out incredulity
11:21:22 <copumpkin> oh yeah, you can do that
11:21:41 <mreh> seriously?
11:21:46 <copumpkin> you mean the c0?
11:22:02 <copumpkin> > let (x, y) = (y, x) in x
11:22:05 <lambdabot>   mueval-core: Time limit exceeded
11:22:08 <mreh> yah, and the sf1, how is it possible that that can take a value
11:22:26 <ryo_hazuki> small question again, i want two random numbers as a tuple returned by function foo - any suggestions?
11:22:46 <mreh> a value that isn't _|_
11:22:46 <roconnor> > let (x, y) = ((:1) *** (:2)) (y, x) in x
11:22:47 <lambdabot>   Occurs check: cannot construct the infinite type: b' = [[b']]
11:22:59 <roconnor> > let (x, y) = ((1:) *** (2:)) (y, x) in x
11:22:59 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
11:23:29 <mreh> or infinite
11:23:32 <lispy> ryo_hazuki: let foo = (1,2) in foo -- Check with a dice that they are random
11:23:46 <lispy> "with a die"*
11:23:55 <roconnor> > let (x, y) = ((1:) *** (const [])) (y, x) in x
11:23:56 <mreh> in Yampa, an sf is a function encapsulated basically
11:23:56 <lambdabot>   [1]
11:24:04 <mreh> :D
11:24:43 <mreh> I understand what you're all writing, maybe I should just sit and work out what it evaluates to on paper
11:25:04 <copumpkin> that can be helpful :)
11:25:15 <ryo_hazuki> thx lispy, too kind...
11:25:43 <lispy> ryo_hazuki: you can also generate random numbers using randomR if you don't want to hardcode them
11:25:50 <lispy> :t randomR
11:25:51 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
11:26:14 <lispy> randomR (1,3) g -- random numbers between 1 and 3 inclusive
11:26:22 <ryo_hazuki> i tried randomRIO
11:26:38 <mreh> Herro, I raff I roose?
11:27:15 <lispy> ryo_hazuki: how far did you make it?  if you have some example code put it on hpaste.org and we'll try to help you
11:27:39 <c_wraith> Hmm.  I'm solving the same problem in two different ways in the type system in this code.  I have multiple types that have the same internal representation, and many common operations, but need to be kept distinct.
11:27:43 <mreh> that probably wasn't the most politically correct thing to say
11:28:03 <chrisdone> mreh: http://chrisdone.com/images/laugh_i_lose.jpg
11:28:15 <smorg> > newStdGen >>= \g -> return $ take 5 $ curry randomRs (0::Double) 9 g
11:28:17 <lambdabot>   <IO [Double]>
11:28:34 <smorg> ya type can be affected
11:28:38 <mauke> mreh: http://mauke.ath.cx/stuff/img/lol,internet/you-raff-you-ruse.jpg
11:29:01 <mreh> I loose
11:29:04 <mreh> also, the game
11:29:10 <mreh> lose*
11:29:27 <ryo_hazuki> smorg: and now group them to tuples of 2 ;)
11:29:43 <ryo_hazuki> lispy: twoRandoms n = (rand, rand)
11:29:44 <ryo_hazuki>     where rand = randomRIO (0,n) >>= return
11:30:03 <ryo_hazuki> i know where the error is but not how to solve it
11:30:17 <lispy> ryo_hazuki: have you studied monads yet?
11:30:23 <jeltsch> ryo_hazuki: >>= return is redundant.
11:30:25 <ryo_hazuki> thats what i try atm =)
11:30:42 <ryo_hazuki> ye, thats what i already know 
11:30:57 <c_wraith> The two different solutions to that problem I've used are a typeclass & GeneralizedNewtypeDeriving, and phantom types & EmptyDataDecls
11:31:11 <lispy> ryo_hazuki: what is the type of rand?
11:31:27 <lispy> :t \n -> randomRIO (0, n) >>= return
11:31:28 <lambdabot> forall t. (Num t, Random t) => t -> IO t
11:31:37 <c_wraith> what are the pros and cons of each?  What other solutions are there?
11:31:42 <ryo_hazuki> IO Int i thought
11:32:03 <lispy> ryo_hazuki: basically yes.  So , then (rand, rand) will have type (IO Int, IO Int)
11:32:08 <ryo_hazuki> yep
11:32:13 <lispy> ryo_hazuki: but you probably want IO (Int, Int)
11:32:19 <ryo_hazuki> exactly
11:32:30 <c_wraith> liftM2 to the rescue!
11:32:32 <lispy> that means the tuple itself needs to be created inside the monad
11:32:37 <copumpkin> :t uncurry (liftA2 (,)
11:32:38 <lambdabot> parse error (possibly incorrect indentation)
11:32:38 <copumpkin> :t uncurry (liftA2 (,))
11:32:39 <lambdabot> forall a b (f :: * -> *). (Applicative f) => (f a, f b) -> f (a, b)
11:33:00 <ryo_hazuki> ok
11:33:13 <ryo_hazuki> so i have to lift up my function into the monad i guess
11:33:24 <lispy> twoRandoms n = do x <- randomRIO (0, n); y <- randomRIO (0, n); return (x,y) -- this should work
11:33:29 <ryo_hazuki> somehow bad explained, but i think you get the point =)
11:33:38 <lispy> ryo_hazuki: that's one way to do it
11:33:44 <lispy> many ways to do it in this case
11:33:51 <lispy> :t randomRIO
11:33:52 <lambdabot> forall a. (Random a) => (a, a) -> IO a
11:34:33 <lispy> twoRandoms n = randomRIO (0, n) >>= \x -> randomRIO (0, n) >>= \y -> return (x,y) -- this should work too
11:35:16 <mm_freak> aristid: so, what do you think?
11:35:26 <Phyx-> Hi, I'm having trouble tracking down an infinite loop. I've narrowed it down to one function but can't seem to find where inside that. Anyone got any tips other than placing rando trace statements to finding it?
11:35:40 <lispy> ryo_hazuki: and when you get more comfortable with monads you can switch to MonadRandom which makes this a bit easier but requires you to understand more
11:35:55 <aristid> mm_freak: i was hoping that haddock would generate docs for me, so i can browse that conveniently, but it still hasn't
11:36:11 <chrisdone> Phyx-: what's the function?
11:36:39 <mm_freak> aristid: unfortunately
11:36:49 <mm_freak> but you can cabal-install it with docs, then you have local ones
11:37:00 <ryo_hazuki> yep, i acutally had the ideas you wrote - i knew the error, knew how to solve it, but didn't know how to write it :)
11:37:14 <ryo_hazuki> is there a way to use liftM?
11:37:15 <ryo_hazuki> :t liftM
11:37:17 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:37:20 <ryo_hazuki> :t liftM2
11:37:21 <mm_freak> aristid: cabal install --enable-documentation contstuff
11:37:22 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
11:37:36 <ryo_hazuki> mh, nice type sig :P
11:37:39 <Phyx-> chrisdone: a rather large graph creation function. (code is not mine, so not sure I can paste it). I think there's a cycle in the graph and fgl is just endlessly following it
11:38:02 <mm_freak> aristid: most of the interface is quite the same as with the usual monad transformers, but you get a few extras, too
11:38:17 <mm_freak> now i'll finalize ContT and StateT and then add ChoiceT
11:38:34 <aristid> mm_freak: why do you have an Id monad? isn't there Identity in monads-fd?
11:38:55 <mm_freak> aristid: because depending on another monad library seemed pointless to me =)
11:39:14 <mm_freak> this library is not an extension of an existing one, but a complete replacement
11:39:28 <mm_freak> fixing a few things, which i didn't like about mtl/transformers/monads-*/monadLib
11:39:35 <mm_freak> (of which my personal favorite is monadLib)
11:40:10 <Phyx-> > 700^700
11:40:11 <lambdabot>   370363355345898819195197451779050910615293670895468224357754566576174363687...
11:40:27 <mm_freak> particularly contstuff's StateT is much stricter and is implemented using CPS, so you get some extra functionality
11:41:11 <mm_freak> in fact the library implements only two monad transformers (ContT and StateT) and derives all others from them
11:41:23 <mm_freak> WriterT, for example, comes in two flavors and is derived from ContT
11:41:32 <Phyx-> or maybe fgl is just slow with 490,000 vertices
11:41:43 <Phyx-> i'll leave it running for a bit
11:42:09 <mm_freak> Phyx-: usually when using haskell you use GMP, which makes even computations with huge numbers very fast =)
11:42:14 <mm_freak> > 3^100000
11:42:15 <lambdabot>   133497141423040146945891439048978229224524850760627735534562799398412741462...
11:42:17 <ryo_hazuki> c_wraith: what do you mean by "liftM2 to the rescue"?
11:42:17 <gwern> I would expect fgl to be slow. I haven't seen any blog posts heroically benchmarking it with criterion
11:42:26 <aristid> > log (700^700) / log 10
11:42:27 <lambdabot>   Infinity
11:42:28 <mm_freak> > log (3^100000) / log 10
11:42:28 <lambdabot>   Infinity
11:42:32 <mm_freak> hehe
11:42:36 <aristid> > log (700^700 :: Rational) / log 10
11:42:37 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
11:42:37 <lambdabot>    arising from a us...
11:42:44 <mm_freak> > 100000 * log 3 / log 10
11:42:45 <lambdabot>   47712.12547196625
11:42:45 <Phyx-> mm_freak: ah ok
11:42:46 <c_wraith> :t liftM2 (,) -- ryo_hazuki 
11:42:46 <aristid> > log (700^700 :: CReal) / log 10
11:42:47 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
11:42:48 <mm_freak> there you go
11:42:48 <lambdabot>   1991.5686280099797814985513810148453354385007
11:42:57 <mm_freak> > 700 * log 700 / log 10
11:42:58 <lambdabot>   1991.5686280099796
11:43:14 <aristid> CReal is awesome (if slow)
11:43:31 <mm_freak> i heard a lot about CReal, but never used it
11:43:34 <mm_freak> what is it anyway?
11:43:39 <mm_freak> @src CReal
11:43:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
11:43:41 <ryo_hazuki> :t (,)
11:43:42 <lambdabot> forall a b. a -> b -> (a, b)
11:43:42 <gwern> mm_freak: short for constructive real
11:43:50 <ryo_hazuki> thats a type sig i understand ;)
11:43:51 <mm_freak> gwern: and what's that?
11:43:59 <gwern> mm_freak: ie. it's the reals which can be computed; higher accuracy than float
11:44:12 <copumpkin> waay higher accuracy than float :P
11:44:20 <gwern> I used to have some handy examples where tossing in a ::CReal magically gave you the right answer
11:44:20 <mm_freak> ryo_hazuki: my favorite (a very simple function, with an overly complicated type signature):
11:44:23 <mm_freak> :t callCC
11:44:24 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
11:44:33 <copumpkin> > drop 10000 $ showCReal 20000 pi
11:44:37 <lambdabot>   mueval-core: Time limit exceeded
11:44:43 <ryo_hazuki> haha
11:44:44 <copumpkin> > drop 10000 $ showCReal 10100 pi
11:44:44 <gwern> the downside is shitty performance :)
11:44:47 <lambdabot>   mueval-core: Time limit exceeded
11:44:48 <mm_freak> gwern: how is it implemented?  just higher precision?
11:44:49 <ddarius> It's not just a matter of higher accuracy, it's a matter of guarantees.
11:45:01 <copumpkin> mm_freak: nah
11:45:05 <mm_freak> or is it really more accurate?
11:45:10 <copumpkin> mm_freak: it's a function
11:45:12 <gwern> mm_freak: dunno. I'm sure hte papers are linked from the CReal haddocks
11:45:14 <copumpkin> iirc
11:45:16 <mm_freak> seeing the source code of CReal would help =)
11:45:22 <copumpkin> basically giving you progressively tighter bounds
11:45:38 <ryo_hazuki> c_wraith: how would you want to use it? liftM2 (,) <....> ?
11:45:39 <c_wraith> :t liftM2 (,) :: IO a -> IO b -> IO (a, b) -- ryo_hazuki, how about this type signature, substituting IO in for m?
11:45:40 <lambdabot> forall a b. IO a -> IO b -> IO (a, b)
11:45:50 <aristid> and you can get any desired bounds
11:45:53 <ryo_hazuki> oh
11:45:54 <mm_freak> when does hackage regenerate docs the next time?
11:45:56 <c_wraith> ryo_hazuki, in your case, liftM2 (,) rand rand
11:46:00 <ryo_hazuki> a lot easier to understand imo
11:46:24 <c_wraith> mm_freak, I think it's every 6 hours, with the next run being in about 15 minutes
11:46:33 <gwern> didn't it get tightened up?
11:46:34 <mm_freak> c_wraith: ah, great
11:47:06 <c_wraith> oh, maybe the schedule was changed recently.  My knowledge is a few months old
11:47:18 <ryo_hazuki> wow, awesome suggestion ... elegant and very easy to read
11:47:50 <ryo_hazuki> thx lispy and c_wraith 
11:48:02 <c_wraith> It's worth either thinking about how to implement liftM2 yourself, or just looking at the source.  It's a pretty simple function.
11:48:59 <ryo_hazuki> true
11:49:01 <mm_freak> hmm, i don't like liftM2
11:49:07 <mm_freak> i prefer <$> and <*>
11:49:18 <mm_freak> > (+) <$> Just 3 <*> Just 4
11:49:19 <lambdabot>   Just 7
11:49:25 <ryo_hazuki> :o
11:49:38 <c_wraith> if *everything* that was a monad instance was also an applicative instance, I'd like <*> a lot more
11:49:50 <c_wraith> but things like (ST s) aren't instances of applicative
11:50:00 <c_wraith> And so I get annoyed with it.
11:51:06 <earthy> WrapMonad?
11:51:29 <c_wraith> Is much uglier than just using liftM*
11:51:33 * earthy nods
11:51:34 <ryo_hazuki> :t ap
11:51:35 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
11:52:28 <ryo_hazuki> :t liftM
11:52:29 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:52:57 <ryo_hazuki> c_wraith: true
11:53:12 <c_wraith> that type signature is easier to think about with some extra parens in it.
11:53:27 <c_wraith> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> (m a1 -> m r)
11:53:27 <ryo_hazuki> :t ap (,)
11:53:28 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
11:53:45 <c_wraith> ryo_hazuki, on the other hand, *that* is in some dangerous territory :)
11:54:04 <c_wraith> ryo_hazuki, that's using the monad instance for functions, which can be a bit confusing
11:54:44 <ryo_hazuki> i found a lot clearer than <$> <*>, tho i dont know what they exactly do and where the differences are ... just my 2cents hehe
11:55:14 <c_wraith> <$> is the same as liftM, <*> is the same as ap
11:55:21 <c_wraith> They just use a different typeclass
11:55:31 <c_wraith> So they can be implemented for things that don't obey the monad laws
11:56:11 <ryo_hazuki> oh ok
11:58:27 <danderson> et je me sens a l'étroit :P
12:05:02 <bla123> if i specify a type such as "data Foo = Foo !Int !Int" as the element type of an IOUArray, will the array store the plain data or pointers to it?
12:05:53 <Lemmih> bla123: You can't put custom data-types in an unboxed array.
12:06:16 <bla123> Lemmih: i thought so, but ghci does not complain about it
12:06:26 <monochrom> yet
12:06:45 <DukeDave> : 1+1
12:06:50 <DukeDave> > 1+1
12:06:51 <lambdabot>   2
12:07:02 <DukeDave> Hey, it does still work :)
12:07:32 <gwern> bleh. in betting, if someone assigns something >90% odds of occuring, would they take a 1:10 bet or a 1:9 bet?
12:08:07 <tromp> 1:9
12:08:14 <disgrntld> Hi, I'm learning about applicative functors and in the example I'm reading, lists are made an instance of Applicative using the following implementation for <*>: fs <*> xs = [f x | f <- fs, x <- xs]... What allows one to use (<-) on the Applicative f? I tried ":t (<-)" and got a parse error. Is (<-) usable on all type constructors?
12:08:14 <Lemmih> bla123: The array has to be an instance of MArray before you can actually use it.
12:08:55 <monochrom> 1:10 and 1:9 are pretty close.
12:09:17 <mm_freak> disgrntld: do-notation belongs to monads
12:09:28 <monochrom> try this: if probability is 50%, it is 1:1 or 1:2?
12:09:30 <mm_freak> there is no syntactic sugar for Applicative
12:09:42 <disgrntld> ok, I thought it was a monad thing, but I haven't learned about them yet.. So I guess this tutorial is just kind of "hand-waving" right there?
12:10:04 <mm_freak> disgrntld: monads are special applicative functors, and applicative functors are special functors
12:10:14 <gwern> monochrom: ok, I wasn't sure about the summing
12:10:15 <mm_freak> in other words:  Applicative is more general than Monad
12:10:31 <monochrom> <- is list comprehension
12:10:36 <Lemmih> disgrntld: You're looking at list comprehension.
12:10:39 <mm_freak> disgrntld: also most of the time you won't really need syntactic sugar for Applicative
12:11:00 <mm_freak> > (+) <$> [10,20,30] <*> [1,-1]
12:11:00 <lambdabot>   [11,9,21,19,31,29]
12:11:03 <disgrntld> Isn't that kind of circular that the definition for one function in the Applicative type class uses a definition from the more specific Monad class in it's definition?
12:11:07 <bla123> Lemmih: oops, i just defined the type but didn't try to instantiate it
12:11:31 <mm_freak> disgrntld: no, because if something is a monad, then you can define the Applicative instance in terms of the Monad instance
12:11:42 <disgrntld> ohh, ok
12:11:46 <disgrntld> it just clicked
12:11:57 <mm_freak> cf <*> cx = do f <- cf; x <- cx; return (f x)
12:11:58 <gwern> defaults. gotta love them
12:12:06 <disgrntld> this was only List's implementation, which also happens to be a monad
12:12:11 <mm_freak> and, of course:  pure = return
12:12:20 <disgrntld> return is from Monad, correct?
12:12:23 <gwern> I once saw someone claim that the idea of a 'default' is one of the more subtle ideas of the 20th century, and wasn't appreciated at all before that
12:12:23 <mm_freak> yes
12:12:27 <disgrntld> ..all I've seen is pure so far
12:12:38 <disgrntld> ok, cool.. thanks mm_freak, and everyone else
12:12:45 <mm_freak> gwern: i don't know history too well, but i'd probably agree
12:12:53 <mm_freak> disgrntld: you're welcome
12:13:09 <mm_freak> disgrntld: and btw, the order, in which you're learning those interfaces, is very good
12:13:14 <gwern> mm_freak: it's strange, but I can't actually think of any examples to disprove it
12:13:18 <bla123> maybe in earlier times you had more time to choose among the few things you could choose at all
12:13:20 <mm_freak> most start with Monad and then slowly go to Applicative (if at all) and Functor
12:13:30 <mm_freak> gwern: ditto
12:14:04 <disgrntld> that's nice to know mm_freak, I'm using the lyoh tuts
12:14:06 <mm_freak> gwern: and i don't find it that strange at all
12:14:51 <mm_freak> gwern: a lot of concepts are very young, for example group theory…  from today's perspective those concepts appear obvious to us
12:15:02 <gwern> mm_freak: I do. the idea of a default is *extremely* important to any empirically based philosophy, but even the skeptics among empiricists seem not to really appreciate it, talking vaguely about 'habit'
12:15:14 <mm_freak> gwern: when i learned how the RSA cipher works, i thought:  "man, /i/ could have invented that!"
12:15:20 <gwern> mm_freak: economics could be excused on account of its youth, but philosophy?
12:15:42 <monochrom> what is "default" in this context?
12:15:51 <gwern> mm_freak: you did? ...that was not my reaction to learning about pubkey crypto as a child
12:16:07 <ryo_hazuki> where are the differences between liftM and ap?! when do you use liftM and when ap?
12:16:21 <mm_freak> gwern: i was already 18 when i learned it, but i had to learn all the math by myself
12:17:06 <gwern> monochrom: good question. if I had to rigorously define it, I'd try to put it in terms of optimization, connecting it to Bayesian priors
12:17:10 <mm_freak> because my grade is one of the lowest where i live…  you don't even learn trigonometry with my grade
12:17:12 <Saizan> ryo_hazuki: see the types
12:17:44 <Saizan> ryo_hazuki: ap is for when the function to apply is the result of a monadic computation
12:17:52 <gwern> mm_freak: as a kid I was all like 'surely this is possible, what if there's a man in the middle the entire conversation? even assuming the key fingerprint was communicated securely'
12:18:02 <mm_freak> ryo_hazuki: in general you don't use 'liftM' and 'ap' together
12:18:02 <aristid> :t ap
12:18:03 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
12:18:25 <aristid> @hoogle IO (a -> b)
12:18:25 <lambdabot> Data.Generics.Aliases unGQ :: GenericQ' r -> GenericQ r
12:18:26 <lambdabot> Data.Generics.Schemes everything :: (r -> r -> r) -> GenericQ r -> GenericQ r
12:18:26 <lambdabot> Control.Parallel.Strategies sPar :: a -> Strategy b
12:18:27 <mm_freak> > return (+) `ap` Just 3 `ap` Just 4
12:18:28 <lambdabot>   Just 7
12:18:33 <monochrom> kill all men in the middle
12:18:36 <gwern> evolution, on the other hand, I agreed with huxley - how extremely stupid of me not to have thought of that
12:18:37 <mm_freak> but you can
12:18:43 <aristid> mm_freak: why not use liftM and ap together?
12:18:50 <mm_freak> > liftM (+) $ Just 3 `ap` Just 4
12:18:51 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> a1)
12:18:51 <lambdabot>    arising from a use of...
12:18:52 <gwern> mm_freak: I know, and it freaked me out. it was like magic
12:18:58 <aristid> > (+) `liftM` Just 3 `ap` Just 4
12:18:59 <lambdabot>   Just 7
12:19:02 <mm_freak> ah, yeah
12:19:19 <aristid> i'd use Applicative tho.
12:19:24 <mm_freak> me too
12:19:48 <mm_freak> gwern: personally i found it interesting (otherwise i wouldn't have learned it)
12:19:52 <gwern> zero-knowledge proofs were pretty hard on me too, but at least I was older and more resilient
12:20:09 <mm_freak> gwern: i was very interested in crypto back then…  today (25) i'm still interested, but not that much anymore
12:20:12 <mm_freak> FP has my focus now =)
12:20:19 <ryo_hazuki> Saizan, didn't see that when i read the docs... as there it stated "you can use ap instead of liftM in most cases" =) 
12:20:34 <mm_freak> well, i'm lying…  haskell has my focus
12:20:43 <mm_freak> i never liked the other FP languages that much
12:21:04 * gwern sighs. the closest I really get to using crypto these days is generating PAR2 files for my backups. I don't even use firegpg to sign my emails anymore
12:21:36 <mm_freak> i sign my mails and my hard drive is encrypted
12:21:37 <bla123> mm_freak: which did yout try?
12:21:54 <mm_freak> bla123: mainly scheme and F#
12:22:02 <mm_freak> i used F# in production
12:22:08 <mm_freak> and scheme just for hobby
12:22:17 <kmc> did you try Clojure
12:22:25 <bla123> hm, f# is just ocaml for .net, right?
12:22:37 <gwern> I thought about encrypting my drive, until I recovered my sanity and remembred that I've fought the NSA 0 times and wiped my drive 4 or 5 times
12:22:38 <kmc> bla123, it has things ocaml doesn't
12:22:43 <kmc> like syntactic support for monads
12:22:53 <kmc> as does C#
12:22:55 <kmc> though you won't find them by that name
12:23:09 <bla123> kmc: what does c# call them?
12:23:12 <kmc> LINQ
12:23:18 <bla123> *g*
12:23:34 <kmc> LINQ isn't *exactly* "do", but it's definitely inspired by
12:23:56 <dolio> F# lacks things OCaml has, too.
12:24:01 <mm_freak> bla123: no, F# is more than ocaml and has nicer syntax
12:24:04 <mm_freak> more haskell-like
12:24:12 <Twey> gwern: Nobody expects the NSA!  Our chief weapon is surprise!  Surprise and fear!
12:24:14 <bla123> and you can use it for anything monad-like or just containers?
12:24:22 <kmc> gwern, my hard drive is encrypted, not against powerful intelligence agencies, but against the common case of some jackass stealing my laptop at the airport
12:24:25 <kmc> bla123, http://blogs.msdn.com/b/lukeh/archive/2007/08/19/monadic-parser-combinators-using-c-3-0.aspx
12:24:27 <gwern> Twey: and a fanatical devotion to the budget?
12:24:32 * Twey chuckles.
12:24:33 <mm_freak> gwern: well, i see no problem with encrypting my hard drive
12:24:41 <mm_freak> it's easy to do, so i do it =)
12:24:47 <Saizan> ryo_hazuki: hah, well "liftM f m = ap (return f) m" so it's quite correct that you can use ap instead, assuming you don't mind adding a return
12:24:56 <mm_freak> or let me state it differently:  i see no reason not to encrypt my drive
12:25:01 <kmc> if someone steals my laptop, they will probably give up on getting any personal data after a cursory attempt
12:25:06 <gwern> mm_freak: I assume that at some point I will hose my OS and lose the drive key
12:25:09 <bla123> mm_freak: well, ocaml somehow looks ugly to me, so i never had a look at F# ... but now it got my attention
12:25:32 <kmc> mm_freak, if you have enough CPU, no downside.  i had whole disk encryption on a pre-Atom EeePC and man did it suck
12:25:37 <mm_freak> gwern: i'm good at memorizing passwords, but not so good at memorizing anything else =)
12:25:53 <mm_freak> kmc: i have encryption on my netbook (atom)
12:26:03 <kmc> single core?
12:26:06 <mm_freak> it still sucks, but i can live with it
12:26:10 <mm_freak> uhm, good question
12:26:18 <mm_freak> honestly i don't know right out of my head
12:26:24 <mm_freak> i guess single-core with HT
12:26:24 <kmc> heh i had a guy try to sell me a "quad-core Atom" box once
12:26:34 <kmc> of course he meant 2-core with HT
12:26:41 <kmc> hmm i think Atom has AES instructions to
12:26:42 <kmc> not sure
12:26:57 <mm_freak> bla123: i don't think F# is a lot like ocaml, besides not supporting multiple function definition clauses
12:27:43 <bla123> mm_freak: i thought i read somewhere that you can compile ocaml-stuff with F# if you use a very restricted set of the language
12:28:03 <bla123> mm_freak: so i thought it shared the basic syntax
12:29:33 <mm_freak> bla123: it has two types of syntax
12:29:46 <mm_freak> in general you'll use the light syntax, which drops a lot of the ocaml clutter
12:29:52 <mm_freak> and looks a lot more like haskell
12:30:04 <mm_freak> it also supports monadic composition
12:30:15 <bla123> mm_freak: eh? now it definitely got my attention ;) maybe i only saw the ocaml-clutter
12:30:49 <mm_freak> bla123: remember it's still not haskell ;)
12:30:57 <mm_freak> but it's a good FP language for .NET
12:32:19 <sinelaw> chrisdone, thanks, only now i got to trying your files
12:32:32 <sinelaw> chrisdone, it's looking for a TAGS file in .cabal/packages
12:32:33 <bla123> mm_freak: well, i guess it misses laziness and some advanced type system stuff ... anything else important that it lacks compared to haskell?
12:33:04 <sinelaw> chrisdone, how do you generate it? etags?
12:33:12 <mm_freak> bla123: as you said, the type system
12:33:15 <sinelaw> or is it supposed to eat Haskell
12:33:43 <gwern> bla123: purity is pretty important
12:33:53 <mm_freak> bla123: it's impure, strict, eager, etc.
12:33:59 <gwern> didn't .net/f# abandon STM because they couldn't make it work with an impure language?
12:34:16 <kmc> yeah in C#
12:34:29 <bla123> gwern: i thought they even had a prototype for c#?
12:34:38 <gwern> past tense being the relevant aspect
12:34:56 <kmc> though "impure" is a matter of community norms, not technology
12:35:09 <kmc> Haskell lets you run IO actions in STM, it's just the function to do so is named unsafeSomething
12:35:14 <kmc> and the semantics of it are "don't do that"
12:35:18 <bla123> kmc: i thought it had a clear definition?
12:35:21 <kmc> whereas the C# people decided it should have a reasonable semantics
12:35:53 <dolio> And it completely ruined their STM. :)
12:35:53 <kmc> bla123, Haskell is an impure language.  you can make values whose evaluation causes execution.  it's just that there's a stigma against using the functions to do so without a damn good reason
12:36:55 <bla123> kmc: ok, you mean i can be pure in C# too, if i just don't do "bad" things
12:36:57 <sinelaw> kmc, which functions
12:37:09 <kmc> unsafePerformIO in general
12:37:19 <sinelaw> kmc, you can pretty much do anything without using that
12:37:24 <sinelaw> except bindings perhaps
12:37:37 <kmc> for STM there's some kind of unsafe IO a -> STM a
12:37:48 <copumpkin> you REALLY don't want it though
12:37:54 <sinelaw> whereas in C# you can pretty much not do anything without impureness
12:38:06 <kmc> the C# design wanted to allow nested transactions too
12:38:06 <sinelaw> so it's ok to call haskell pure, in my opinion
12:38:32 <mm_freak> kmc: i think what makes haskell pure is that those functions are magic
12:38:33 <kmc> you can't implement certain high performance data structures without it
12:38:38 <mm_freak> you can't implement unsafePerformIO in haskell
12:39:01 <kmc> yeah
12:39:12 <kmc> *shrug* i didn't mean to get into a big philosophical debate about the true nature of purity
12:39:20 <bla123> mm_freak: i find it hard to get programs "right" in haskell. i could hack away in haskell like in other languages, but then i think i could be using the other language in the first place, so i don't want to hack it. and not hacking it is hard.
12:39:26 <Saizan> kmc: not just a "damn good reason", but also some way to say the API is still referentially transparent, even if some cases resort to a relaxed equivalence for that
12:39:49 <kmc> i was just pointing out that Haskell imposes "no IO in STM" ultimately by convention not technology, and C# could do the same
12:40:18 <kmc> a bigger problem is that iirc they didn't have a special type / tag for transactional variables
12:40:22 <gwern> don't worry everyone; in a few decades ghc hq will implement a 'taint bit' for modules and then we'll be able to say pure functions are whatever compiles with 'ghc -safe' :)
12:40:32 <kmc> so every variable update in a transaction has to hit the log
12:40:56 <kmc> not such a big deal in typical Haskell code, but pretty bad for C#
12:41:00 <kmc> i could be mistaken though
12:41:31 <applicative> omg, gwern is here! :)
12:41:37 <sinelaw> kmc, what did you say was bad for C#?
12:41:56 <mm_freak> bla123: at some point it made click for me, and now i can write haskell programs like i can write programs in any other language
12:42:11 <mm_freak> but honestly, i'm depending on certain concepts for that
12:42:22 <mm_freak> for example i couldn't get any program up and running without monad transformers
12:42:33 <bla123> mm_freak: did you grok a special feature of the language or was it just trying for long enough?
12:42:42 <Peaker> bla123, I also get the "perfectionism" problem with Haskell, but I disagree with "might as well use other language" because even when you do "hack" Haskell is better :)
12:43:12 <Peaker> bla123, It is better for the parts where you don't hack, it is better at marking the hacks, it is better at catching null dereferences, it is better at many other things
12:43:33 <kmc> sinelaw, treating *every* variable as transactional
12:43:36 <mm_freak> bla123: i don't know really
12:43:48 <bla123> Peaker: the problem is rather: haskell mentally prohibits me from hacking ;) so when i need to get things done, i take another language, because with them all is lost already, so beauty doesn't matter
12:43:51 <mm_freak> bla123: but one of the most enlightening moments were when it made click for monads =)
12:44:11 <mm_freak> "because with them all is lost already"
12:44:12 <mm_freak> lol
12:44:15 <monochrom> you are just not familiar enough with haskell
12:44:42 <bla123> that may very well be the case
12:45:06 <copumpkin> bla123: I actively forced myself to use haskell for things for the first couple of months
12:45:16 <copumpkin> after that I no longer needed to force myself :)
12:45:39 <bla123> one of the biggest problems for me is to keep io out of my code. sometimes that means turning the control flow inside out
12:46:22 <mm_freak> bla123: turning the control flow inside out is one of the main paradigms in haskell ;)
12:46:24 <c_wraith> really, that's a practice you should be keeping as much as you can in every language
12:47:31 <bla123> c_wraith: yeah, although i don't yet really grok haskell, i feel it already made me a better programmer in other languages, because now i really think about state and control flow
12:47:49 <bla123> that really helps to separate concerns and isolate parts of the program
12:47:58 <mm_freak> haskell makes me write C code, which nobody understands
12:48:09 <bla123> *lol*
12:48:11 <mm_freak> but which is much better than the usual approach in some or another way
12:48:31 <bla123> well, that nobody understands who doesn't know fp i guess?
12:48:47 <prey_alone> How can I convert a Data.Tree to a Data.Graph.Inductive.Graph?
12:48:56 <mm_freak> int parseInt(char *, void *(*k)(char *, int), void *(*err)(char *, char *));
12:49:18 <mm_freak> bla123: not just FP, but in general you also need to understand CPS to understand my code =)
12:49:20 <drhodes> a turning point for me was using pattern matching effectively everywhere.  It helped me move away from the (c like) record syntax.  
12:49:30 <bla123> oookayy, i see ...
12:50:00 <sm> drhodes: how do you mean ? your data types have only positional fields, not named ones ?
12:50:02 <bla123> mm_freak: err, does it do tail call optimization?
12:50:40 <drhodes> sm, not that one couldn't use it the same way, but the realization that isn't always necessary
12:51:03 <sm> I don't understand
12:51:17 <Baughn> case (foo,bar) of ...
12:51:32 <Baughn> It took me /weeks/ to figure out that I could do that
12:52:00 <drhodes> I was stuck using accessors in where blocks, and then using those variable in case statements.
12:52:44 <sm> for me using named record-style fields means code is easier to refactor
12:53:32 <mm_freak> bla123: GCC does
12:56:12 <bla123> mm_freak: great! i didn't know that. and i really like your example. it's like an eye-opener, i wouldn't have thought of that, but it makes me wanna try some nasty fp stuff in c, the next time i have to use c
12:57:15 <kmc> "* 'ghc-options: -O2' is rarely needed. Check that it is giving a real benefit and not just imposing longer compile times on your users."
12:57:17 <kmc> ;P cabal
12:57:20 <kmc> i need MAX SPEED
12:57:43 <mm_freak> bla123: i implemented church lists in, well, 'almost C'
12:57:53 <mm_freak> it uses a GCC extensions
12:57:55 <mm_freak> -s
12:58:20 <mm_freak> bla123: http://ertes.de/techblog/2008-11-17-2-obscure-c.html
12:59:10 <gwern> kmc: well, it doesn't really
13:00:10 <roconnor> kmc: does it really say that about O2?
13:00:50 <roconnor> kmc: is this -O2 vs -O or -O2 vs nothing?
13:01:23 <gwern> roconnor: 2 versus 1
13:01:31 <kmc> ah, cabal uses -O1 by default?
13:01:33 <kmc> that's probably fine
13:02:01 <gwern> kmc: so far it seems to've been
13:02:27 <chrisdone> gwern: I've encrypted my drive once or twice, if you know what I mean
13:02:48 <gwern> chrisdone: no, I don't. what's the key to your implied metaphor?
13:03:10 <chrisdone> there isn't one ;_;
13:03:21 * chrisdone runs away in tears
13:03:58 <olsner> gwern: look what you did, he's crying now
13:04:26 * gwern whips my razor-sharp tongue down, flicking off the fresh blood, and resheathes it in the mouth
13:05:05 <bla123> mm_freak: interesting read, thanks
13:05:39 <chrisdone> smadge: hey you know hpaste.org has literate haskell highlighting?
13:06:18 <roconnor> ``A lot of people think that a good reason to use C is that code written in it is easy to reason about
13:06:25 <mm_freak> bla123: the codes were just a bad joke, actually, but i had to keep them =)
13:06:26 <smadge> chrisdone: I do now
13:06:28 <roconnor> these people clearly haven't reasoned about C programs ...
13:06:35 <smadge> thanks
13:06:36 <chrisdone> who's coming to ghenthack?
13:06:44 <kmc> roconnor, the standard for understanding what code does varies widely by community
13:06:45 <mm_freak> roconnor: i had the impression that it's just freakish control lust
13:06:52 <mm_freak> which makes people stay at C
13:06:54 <gwern> I like to write in assembler because it's so easy to reason about. it does exactly what it says it does
13:07:00 <bla123> mm_freak: they may be just a joke, but i had to bookmark them nonetheless ;)
13:07:01 <gwern> i are so smart
13:07:03 <kmc> in some circles it is acceptable to say "I understand what the FooFactory class does; it creates Foo objects!"
13:07:05 <chrisdone> roconnor: mm_freak: it's obviously talking about memory management
13:07:06 <objorn> I shouldn't, but I find it frustrating learning Scheme through SICP when I know that I want to learn Haskell. 
13:07:07 <kmc> never mind the problem domain
13:07:20 <kmc> objorn, then learn Haskell
13:07:24 <kmc> you should read SICP at some point though
13:07:29 <mm_freak> chrisdone: "it"?
13:07:30 <zachk> ive found sicp kinda of frustrating 
13:07:32 <kmc> you could even do some SICP exercises in Haskell
13:07:32 <chrisdone> objorn: it's not Abelson and Sussman's fault
13:07:33 <gwern> objorn: half my notes on SICP are 'and this is how I would do it in haskell better'
13:07:47 <chrisdone> mm_freak: the quote
13:07:51 <zachk> you should get "programming in haskell" by graham hutton for basic haskell stuff
13:07:55 <roconnor> kmc: There is a difference between operational understanding (semantics), and ease of reasoning (sound program transformation)
13:07:58 <zachk> will quite most of your noobie questions 
13:08:07 <roconnor> kmc: probably the author chose a poor set of words for his idea
13:08:32 <chrisdone> enjoy reasoning about performance in Haskell
13:08:39 <chrisdone> then C will seem like a dream
13:08:41 <objorn> I need the theory that SICP supposedly presents, this is why I'm reading it. It would be nice if there was something like this for Haskell.  
13:08:53 <roconnor> chrisdone: in GHC.  Haskell has no operation semantics hence performance is undefined.
13:09:13 <chrisdone> sorry I forgot to precede my message with "Haskell = GHC"
13:09:13 <c_wraith> reasoning about performance in GHC isn't really that bad, unless you're using a library that doesn't document its choices
13:09:33 <roconnor> c_wraith: well reason about complexity is easy
13:09:40 <roconnor> more or less
13:09:50 <roconnor> I'm not sure if complexity is equal to performance :P
13:09:52 <aristid> chrisdone: when people say "Haskell 6.12", it's clear that Haskell = GHC has become true.
13:10:21 <chrisdone> it was true when I decided to learn Haskell and part of why
13:11:02 <bla123> well ghc has all of this great stuff that they didn't manage to put in the standard
13:11:24 <zachk> i tried hugs , and it turned me off to haskell 
13:11:26 <gwern> no, it's more like nobody is woring on ghc or hugs
13:11:26 <chrisdone> but that everybody uses anyway
13:11:36 <roconnor> zachk: :O
13:11:46 <gwern> *yhc
13:11:48 <zachk> like 2 years latter i tried ghc and stayed 
13:11:48 <gwern> **working
13:12:03 <roconnor> once ghci was made I stopped using hugs
13:12:04 <zachk> whats the point of an interpreter (hugs) that you cant type code into 
13:12:27 <chrisdone> coming from lisp, Haskell having One True Implementation made it very attractive
13:12:58 <zachk> coming from scheme , libraries, a real compiler, and human readable syntax made me quite happy 
13:13:22 <chrisdone> actually I came from scheme, but I said lisp because I used Common Lisp before Scheme
13:13:23 <Baughn> Coming from lisp, purity and pattern matching made me happy
13:13:39 <Baughn> Also its type system, but that took a while to grasp.
13:13:52 <gwern> ('we must take the One True GHC to the fires of Mt. Redmond whence it was made and hurl it into its depths')
13:13:52 <chrisdone> Baughn: BUT YOU CAN WRITE PATTERN MATCHING WITH MACROES!!1
13:13:56 <kmc> scheme has real compilers doesn't it?
13:14:09 <Baughn> chrisdone: Don't make me hurt you.
13:14:13 <kmc> people who say "Haskell 6.12" should definitely be slapped with fish
13:14:21 <ryo_hazuki> "return f `ap` x1 `ap` ... `ap` xn" is the same as "return ap f x1 x2 x3 x4" ?
13:14:33 <zachk> kmc: somewhere , now get them working on windows without mingw/msys 
13:14:33 * Baughn is looking forward to haskell 6.14
13:14:37 <chrisdone>  @yow lisp
13:14:37 <chrisdone> hurt? that's SYNTACTIC SUGAR!
13:14:38 <kmc> haha windows
13:14:43 <p_l> kmc: yes, it has
13:14:44 <wli> I learned Haskell in the midst of a barrage of language learning back in 1997 or 1998. It didn't seem to be so much different from everything else for a while.
13:14:50 <smadge> does anyone want to help make me a better haskell programmer by commenting on my code? http://hpaste.org/30118/shortest_distance 
13:15:29 <gwern> smadge: dunno. what's in it for us?
13:15:39 <objorn> Is there an SICP for Haskell?
13:15:54 <gwern> smadge: hokay, first fix everything hlint and -Wall tell you to
13:15:57 <gwern> smadge: then ask us
13:15:59 <zachk> smadge: the phrase "reduce reducer" makes me think im seeing double 
13:16:13 <bla123> there's sicp code in other languages: http://www.codepoetics.com/wiki/index.php?title=Topics:SICP_in_other_languages
13:16:15 <chrisdone> objorn: SICP covers more than Haskell can do, just stick with Scheme, the lessons still get learned
13:16:25 <gwern> objorn: you mean a version of SICP with all the scheme snippets removed and replaced with hasjell? no 
13:16:32 <smadge> you recieve a feeling of smug superiority?
13:16:38 <Baughn> smadge: A lot of the Data.List functions are very slow for large lists, in particular the ones you're using. You might get a significant speedup by using maps, sets, arrays, anything that fits the task better than a list.
13:16:39 <chrisdone> gwern: I has jell
13:16:56 <gwern> smadge: that goes without saying; how much superiority would I feel?
13:17:10 <smadge> gwern, are those interpreter flags?
13:17:13 <gwern> chrisdone: for mah hair
13:17:13 <Baughn> smadge: I find that I mostly use lists when I want a terminating stream. Or, admittedly, if it's very small.
13:17:22 <gwern> smadge: hlint is a tool, cabal install it; -Wall is a ghc flag
13:17:29 <objorn> chrisdone: That sounds like there is something Scheme can do that Haskell cannot.
13:17:49 <gwern> I stopped reading at '
13:17:49 <gwern> > grouper = (map (\ x -> ((fst.head) x, map snd x)) . ((groupOnIndex . sortOnIndex)))'
13:17:50 <lambdabot>   <no location info>: parse error on input `='
13:17:54 * monochrom 's knowledge of CGI still comes from a 10-year old book :)
13:17:56 <chrisdone> objorn: uh yeah, code as data
13:18:01 <bla123> chrisdone: what do you mean with "more than haskell can do"?
13:18:11 <gwern> chrisdone: nooo what about haskell-src-exts and hint
13:18:16 <chrisdone> lol
13:18:17 <Baughn> bla123: Good luck writing a haskell interpreter as a first-year project. :P
13:18:25 <Baughn> liskell, maybe
13:18:29 <p_l> hahahahahahaha
13:18:29 <smadge> gwern, ok I'll check those tools out.
13:18:44 <wli> Really, the impression I got from learning a large number of languages was that once you know the paradigm, individual languages of that paradigm are easy.
13:18:49 <chrisdone> technically a dumb type-less haskell interpreter is easy but then you might as well do scheme
13:18:56 <smadge> gwern, is there anything in particular wrong with that line?
13:18:58 <bla123> Baughn: well i might stretch it and implement a scheme interpreter in haskell instead, just like the book asked me to do?
13:19:11 <gwern> smadge: well, the first paren pair is superfluous I think
13:19:28 <roconnor> smadge: is that dijkstra's algorithm?
13:19:47 <mornfall> roconnor: Does it look like one? :)
13:19:48 <chrisdone> roconnor: leave him alone, he'll give it back
13:20:00 <roconnor> huh?
13:20:04 <Baughn> bla123: That's easy, of course.
13:20:06 <smadge> rconnor: pretty much, except it's in that there is no destination node
13:20:07 <chrisdone> dijkstra's algorithm
13:20:40 <smadge> *except there is no destination node
13:20:45 <bla123> Baughn: i heard you could do it in 48 hours ;)
13:20:49 <aristid> chrisdone: typeless haskell? how would that work?
13:21:07 <Saizan> aristid: without typeclasses
13:21:10 <chrisdone> aristid: untyped lambda calculus with pattern matching
13:21:15 <zachk> very messily i would assume 
13:21:30 <roconnor> I've been meaning to write a generic gaussian elimiation that works on arbitrary star-semi-rings.  That way you can do shorest path, solve linear equations, etc, all with the same code.
13:22:05 <ryo_hazuki> why does this work: "ap (,) (+1) 0" ?
13:22:16 <aristid> ryo_hazuki: why not?
13:22:18 <Guest9493> :t ap
13:22:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
13:22:23 <Guest9493> :t ap (,)
13:22:24 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
13:22:25 <ryo_hazuki> i dont see a monad
13:22:32 <aristid> ryo_hazuki: (+1) <- there
13:22:37 <aristid> and (,) too
13:22:44 <ryo_hazuki> what kind of monad is it?!
13:22:48 <chrisdone> aristid: two separate monads? :P
13:22:50 <aristid> (e ->)
13:23:03 <Guest9493> The function monad has nothing to do with this
13:23:07 <p_l> bla123: you would then need to reimplement it in scheme, since I recall a big point of the book being about metacircular interpreters :P
13:23:14 <aristid> Guest9493: sure has.
13:23:26 <aristid> :t ap (,)
13:23:27 <lambdabot> forall a a1. (a -> a1) -> a -> (a, a1)
13:23:34 <ryo_hazuki> the type sig sais it needs monads, so they must be there afaik =)
13:23:51 <Guest9493> Oh
13:23:53 <Guest9493> Yeah, it does
13:23:54 <chrisdone> :t id >> id
13:23:55 <lambdabot> forall a. a -> a
13:23:55 <roconnor> > ap (,) (+1) 0
13:23:56 <lambdabot>   (0,1)
13:23:57 <ryo_hazuki> aristid, please tell me which monads those two functions are? (,) and (+1)
13:24:18 <aristid> ryo_hazuki: e -> a can be thought of as ((->) e) a, where (->) e is a monad
13:24:19 <roconnor> both are in the (Int ->) monad
13:24:31 <roconnor> aka the ((->) Int) monad
13:24:40 <ryo_hazuki> interesting :)
13:24:43 <aristid> :t (,)
13:24:44 <lambdabot> forall a b. a -> b -> (a, b)
13:25:10 <Guest9493> aka Haskell needs to have type sections but can't for some complex reasons 
13:25:11 <roconnor> :t (,) :: Int -> (Int -> (Int,Int))
13:25:12 <lambdabot> Int -> Int -> (Int, Int)
13:25:15 <chrisdone> it's called the reader monad, hence the r in (r ->)
13:25:32 <roconnor> it's called the environment monad, hence the e in (e ->)
13:25:33 <Saizan> there's only one way to unify "a -> b -> (a, b)" with "m x", afterall :)
13:25:37 <aristid> the type of (,) (when both arguments have the same type) can be seen as e -> e -> (e, e), which is m (m (e, e)) with m = (e ->)
13:25:48 <smadge> gwern, thanks for the tips, I don't have cabal installed, I am doing that now 
13:25:59 <sinelaw> chrisdone, thanks! my emacs is back to normal
13:26:04 <aristid> > join (,) 1
13:26:05 <lambdabot>   (1,1)
13:26:06 <sinelaw> chrisdone, of course i've had to change the colors :)
13:26:11 <sinelaw> can't see black-on-white
13:26:17 <sinelaw> burns my eyes
13:26:25 <sinelaw> and your totally weird keybindings
13:26:32 <chrisdone> "totally weird"???
13:26:44 <sinelaw> chrisdone, the arrow keys don't seem to control the cursor
13:26:47 <chrisdone> those were my father's keybindings you insensitive clod!
13:26:51 <sinelaw> hah
13:27:02 <sinelaw> no wonder you use them
13:27:08 <sinelaw> no other reason makes sense
13:27:09 <ryo_hazuki> thx for the hints
13:27:24 <chrisdone> the arrow keys move between buffers as Stallman intended
13:27:34 <aristid> oO
13:27:39 <chrisdone> use C-f/b/p/n for cursor movement
13:27:45 <sinelaw> how very natural
13:28:04 <sinelaw> does stallman have 13 fingers?
13:28:07 <Guest9493> Man I've been way off target for the past few days now
13:28:56 <sinelaw> three of which are permanently attached to his keyboard?
13:29:41 <chrisdone> my coworkers use the arrow keys for cursor movement, it's a disgrace
13:29:49 <chrisdone> using emacs outside the terminal!!
13:29:52 * chrisdone pukes a little
13:30:09 * Twey uses M-htncgr
13:30:09 <sinelaw> how do i turn off the highlighting of the 80'th column?
13:30:16 * Twey uses emacs outside the terminal for auctex sometimes
13:30:21 <roconnor> chrisdone: my coworkers use the mouse
13:30:22 <chrisdone> sinelaw: you format your code properly
13:30:33 <sinelaw> sinelaw pukes a lot
13:30:34 <Guest9493> My coworkers use dreamweaver
13:30:34 <Twey> sinelaw: M-x highlight-80+-mode
13:30:37 * chrisdone goes into shock
13:30:48 <sinelaw> sinelaw, uses the mouse to type
13:30:55 <sinelaw> well, not. i hate the mouse
13:30:58 * smadge uses winhugs :/
13:31:10 <aristid> smadge: now THAT is bad.
13:31:21 <chrisdone> M-x column-marker-1
13:31:23 <sinelaw> but when i see a key that has a left arrow on it, i expect it to move my cursor left
13:31:45 <chrisdone> sinelaw: even in a web browser?
13:31:52 <aristid> sinelaw: that's because the imperalists trained you so
13:31:56 <Guest9493> I wish I worked with a bunch of people who were smarter than me and extremely well-versed in Haskell
13:32:21 <sinelaw> chrisdone, if i'm editing text then yes
13:32:51 <chrisdone> sinelaw: ahh, so you don't always expect the left arrow to move the cursor. interesting
13:33:02 <sinelaw> btw, the down arrow on my keyboard is completely worn out, so i'll accept any binding for it
13:33:05 <chrisdone> Twey: did you apply to work at CREATE-NET?
13:33:19 <ryo_hazuki> :t ap (return (+)) (Just 1) (Just 2)
13:33:20 <lambdabot>     Couldn't match expected type `Maybe t1 -> t'
13:33:20 <lambdabot>            against inferred type `Maybe (a -> a)'
13:33:20 <lambdabot>     In the expression: ap (return (+)) (Just 1) (Just 2)
13:33:20 <Twey> I was tempted, but no
13:33:28 <Twey> I'm going through college this time around, I tihnk
13:33:29 <Twey> think**
13:33:47 <chrisdone> sinelaw: that's from reading tonnes of papers right? not yuri comics
13:33:49 <sinelaw> OMG YOU DON'T ACTUALLY WANT 'X' IN EVERY POSSIBLE SITUATION
13:33:59 <chrisdone> Twey: ok ;D
13:34:25 <Guest9493> College...
13:34:27 * Guest9493 sighs
13:34:32 <chrisdone> sinelaw: x?
13:34:42 <sinelaw> chrisdone, i think it's from someone else browsing the web with nails
13:34:58 <ryo_hazuki> :t return (+) `ap` Just 1 `ap` Just 2
13:34:58 <sinelaw> X = "left arrow = move cursor left"
13:34:59 <lambdabot> forall a. (Num a) => Maybe a
13:35:00 <aristid> :t return . (+)
13:35:01 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => a -> m (a -> a)
13:35:27 <sinelaw> it's the only key that's worn out at all
13:36:00 <ryo_hazuki> aristid, why does this not work? ap (return (+)) (Just 1) (Just 2) - got nuts instead of eyes i guess ;)
13:36:17 <Guest9493> :t return (+)
13:36:18 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m (a -> a -> a)
13:36:28 <Guest9493> :t ap (return (+))
13:36:29 <lambdabot> forall a (m :: * -> *). (Num a, Monad m) => m a -> m (a -> a)
13:37:11 <Guest9493> Which is why the form with two aps works
13:37:42 <ryo_hazuki> interesting, i thought it would work coz of the internal call of liftM2
13:38:06 <ryo_hazuki> so
13:38:56 <ryo_hazuki> :t ap (return (+1)) (Just 0)
13:38:57 <lambdabot> forall a. (Num a) => Maybe a
13:39:04 <ryo_hazuki> cool :]
13:39:47 <sinelaw> i'm looking at some old code of mine
13:39:53 <sinelaw> and don't understand something
13:40:02 <sinelaw> i wrote that 'flip member' is the 'semantic function' of sets
13:40:10 <sinelaw> don't remember what i meant by that
13:40:29 <benmachine> sinelaw: well a set is basically defined by, stuff is either in the set or it isn't
13:40:48 <benmachine> so a Set a is *kind* of like, a -> Bool
13:41:10 <benmachine> except that you can also get a list of elements but whatever
13:41:56 * hackagebot Hipmunk 5.1.0 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.1.0 (FelipeLessa)
13:42:45 <Cale> The original Hipmunk
13:43:06 <aristid> ryo_hazuki: because ap only takes two parameters, not three.
13:43:57 * hackagebot HipmunkPlayground 5.1.0 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.1.0 (FelipeLessa)
13:44:13 <ryo_hazuki> :t liftM2
13:44:14 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
13:44:48 <sinelaw> benmachine, i guesss that's what i meant
13:44:57 <sinelaw> with one less s
13:44:59 <ryo_hazuki> aristid, i missed watching at the type, just saw the call of liftM2 inside the function and thought it could work :)
13:45:09 <ryo_hazuki> good night everyone, thanks for the hints/help
13:45:25 <aristid> ryo_hazuki: well it works if you use two ap
13:45:56 <aristid> > ap (ap (return (+)) (Just 1)) (Just 2)
13:45:57 <lambdabot>   Just 3
13:46:09 <ryo_hazuki> yep, saw it ... thx anyways =)
13:46:18 <ryo_hazuki> nn
13:55:41 <Peaker> Can you enumerate every mathematical set?
13:56:11 <Guest9493> If the set is countable
14:03:44 <jeltsch> If the set is countable, there may still be no *computable* function that maps the natural numbers to the set.
14:05:39 <jeltsch> A set that can be enumerated (i.e., its elements can be computed through some algorithm) is called recursively enumerable.
14:06:50 <jeltsch> The set of recursively enumerable sets is countable because the set of algorithms is countable.
14:07:29 <jeltsch> The set of countable sets, however, is itself uncountable.
14:07:32 <sinelaw> Peaker, i'm reviewing some code i wrote once that defines a set typeclass based on zermelo-fraenkel axioms (the basis of modern set theory)
14:07:37 <xplat> > 65535 * 65535 * 65535 * 65535 :: (Int,Integer)
14:07:38 <lambdabot>   (-1125874137300991,18445618199572250625)
14:07:46 <jeltsch> Therefore, not every countable set can be recursively enumerable.
14:07:57 <monochrom> I can enumerate every mathematical set. I'll start now. Just don't complain until I finish. :)
14:08:07 <monochrom> {}, {0}, ...
14:08:41 <monochrom> ah, I have a thesis to write. I'll continue after I finish my thesis!
14:08:52 <sinelaw> ..., {monochrom, bubble gum, monkeys, ...}
14:09:10 <Peaker> There's an instance of (Num a, Num b) => Num (a, b) ?
14:10:06 <monochrom> My ISP runs my cgi programs without a LANG value. So I have to set output encoding inside my program. Yuck.
14:10:13 <jeltsch> > (1 :: Int,2) + (4,4)
14:10:14 <lambdabot>   (5,6)
14:10:24 <jeltsch> Peaker: Seems so.
14:10:42 <jeltsch> Peaker: I didn’t think that there was such an instance.
14:10:56 <jeltsch> Peaker: But lambdabot seems to know about some.
14:11:31 <sinelaw> isomorphic to complex
14:11:34 <jeltsch> Okay, have to go to sleep. Bye.
14:20:16 * hackagebot monte-carlo 0.3 - A monad and transformer for Monte Carlo calculations.  http://hackage.haskell.org/package/monte-carlo-0.3 (PatrickPerry)
14:22:14 <benmachine> > fromInteger 0 :: (Integer, Integer)
14:22:15 <lambdabot>   (0,0)
14:22:17 <burp> oh nice new monte-carlo
14:22:17 <ddarius> It, too, is probably from the vector-space package.
14:22:22 <benmachine> > fromInteger 1 :: (Integer, Integer)
14:22:23 <lambdabot>   (1,1)
14:24:06 <Peaker> "Num" is a bad class.. :(
14:24:26 <Peaker> While I'm criticizing "standard" things, the ByteString API split/duplication of list API is a mess too
14:24:51 <Philippa> yeah, we do need a nice way of making typeclasses do the functor thing with actual modules
14:25:53 <ddarius> My DNS lookups are really slow.
14:26:33 <hewei> Hi there, just notice one interesting thing: 
14:26:34 <hewei> @kind (->)
14:26:35 <lambdabot> ?? -> ? -> *
14:26:44 <hewei> What does it mean pls? 
14:27:08 <magicman> I'd be all for Agda-style modules/records. (which is probably inspired by ML, but I don't speak ML, and have no clue how those work exactly >_>)
14:28:47 <Baughn> ..it used to be that I could read everything on haskell-cafe, but no more. Hm, someone should do some statistics to it.
14:29:10 <sinelaw> Peaker, are you context switching?
14:29:14 <sinelaw> your mind
14:29:20 <Peaker> sinelaw, Not anymore.. I'm stuck at work now
14:29:24 <c_wraith> hewei, ?? and ? are special kinds that have to do with unboxed values
14:29:32 <sinelaw> Peaker, maybe you have a haskell co-processor
14:29:40 <Philippa> Peaker: think about what's involved in building ML functors on top of Haskell modules and Haskell type classes, and write a proposal for some sugar and/or a LANGUAGE extension that'll do it and provide subtyping on signatures cheap or free?
14:29:44 <sinelaw> because you keep popping those questions / comments :)
14:29:46 <Philippa> (that is, /syntactically/ cheap or free)
14:30:05 <xplat> < mm_freak> bla123: no, F# is more than ocaml and has nicer syntax <-- ocaml 3.12 seems to have a lot of new features that are nice and are not in f#
14:31:14 * wli never figured it out.
14:31:27 <hewei> c_wraith: GHC help says that 'kind' shows the kind of a type. But why is (->) a type ?
14:31:28 <poincare101> Hello everyone. I'm writing a neural network (or, trying to). I have a prototype ready in python and I'd like it to run faster, I really don't want to write in c/c++ (because of the need of infinite precision decimals and such), so haskell comes to mind, but will haskell run pretty dang fast? As in, much faster than python?
14:31:35 <poincare101> I won't be using much memory, mostly CPU.
14:31:37 <poincare101> but, tons of CPU.
14:31:40 <Heffalump> F# is missing all the complicated features of OCaml, even before any new ones were added to OCaml.
14:31:40 <lambdabot> Heffalump: You have 3 new messages. '/msg lambdabot @messages' to read them.
14:31:57 <poincare101> It'll be going through 20 years of stock market data, and hundreds of shares
14:32:12 <megajosh2> hewei: I think (->) just means all functions
14:32:14 <sinelaw> poincare101, written properly, haskell can be several orders of magnitude faster than python
14:32:21 <sinelaw> and can compare to c
14:32:38 <sinelaw> but i'm not the one that knows what 'properly' is
14:32:41 <megajosh2> Isn't Haskell USUALLY faster than Python?
14:33:01 <arw> its possible to write stupid and slow code.
14:33:12 <poincare101> sinelaw: I see, now, I've heard ocaml does really well with speed, is this true?
14:33:12 <megajosh2> Well yeah, but I mean usually
14:33:13 <Philippa> isn't bashing it out on paper USUALLY...?
14:33:51 <JoeyA> "Properly" basically means not letting laziness backfire on you, I think.
14:34:10 <wli> No functors in F# sounds like it would hurt and very badly.
14:34:40 <JoeyA> For instance, foldl (+) 0 [1..10000000] causes ghc to explode in memory usage.
14:34:58 <JoeyA> whereas foldl' (+) 0 [1..10000000] runs efficiently.
14:34:58 <Philippa> wli: I suspect the F#ish way to do it's DI
14:35:35 <poincare101> JoeyA: what do you think of ocaml? (for speed)
14:35:42 <hewei> megajosh2: Till now, I only use (->) in type of functions. Where is it defined and is it special than plain haskell types/values? 
14:35:50 <JoeyA> I've never used it, sorry.
14:35:53 <Heffalump> Philippa: I wouldn't call DI very F#ish.
14:36:17 <megajosh2> hewei: You can make typeclasses that have (->) as an instance, like in Applicative
14:37:01 <JoeyA> But I've also heard O'Caml performs well.
14:37:11 <sshc> Where is documentation on System.Cmd?
14:37:15 <hewei> megajosh2: So, (->) is kind-of a GHC built-in type ? 
14:37:18 <Twey> Well, that's ((->) a)
14:37:21 <Philippa> Heffalump: fair enough, what's the usual way of accomplishing the effect though?
14:37:27 <Twey> Yes, it's a magic type constructor
14:37:35 <sioraiocht> Is there a good lib for manipulating CSVs in haskell?
14:37:41 <Philippa> (it /is/ .NETish in the same way that it's JVMish: it's the native paradigm's best attempt at expressing it)
14:38:09 <cakoose> Anybody have experience using Cabal with code generators?  I'm new to Cabal and would like to use hprotoc to generate bindings for a Protocol Buffers definition.
14:38:21 <drhodes> sioraiocht: Text.CSV is one
14:38:31 <sioraiocht> cheers drhodes
14:38:32 <drhodes> at least for reading
14:38:34 <JoeyA> sshc: quick google search yielded http://cvs.haskell.org/Hugs/pages/libraries/base/System-Cmd.html
14:38:35 <Twey> sioraiocht: Google Says: http://hackage.haskell.org/package/csv http://hackage.haskell.org/package/bytestring-csv
14:38:49 <JoeyA> (haskell system.cmd)
14:39:01 <Heffalump> Philippa: objects in general, I guess. I've seen DI used (and even done it myself) but it doesn't feel natural.
14:39:14 <sioraiocht> can't use bytestring
14:39:18 <hewei> Twey: Where can I get more info on the difference between ??, ? and * in: 
14:39:19 <Heffalump> I agree it's .NETish
14:39:23 <hewei> @type (->)
14:39:24 <lambdabot> parse error on input `->'
14:39:32 <hewei> @kind (->)
14:39:33 <lambdabot> ?? -> ? -> *
14:39:46 <Twey> hewei: http://en.wikibooks.org/wiki/Haskell/Kinds
14:40:00 <hewei> Twey: Thanks! 
14:40:03 <Twey> Oh, no, that's no good at all
14:40:08 <kmc> ?? is (* or #)
14:40:08 <lambdabot>  is (* or #)
14:40:18 <kmc> ? is (* or # or (#))
14:40:32 <kmc> * is ordinary boxed types, # is unboxed types, (#) is unboxed tuples
14:40:46 <mreh> .NET doesn't stand for anything does it?
14:40:46 <Philippa> Heffalump: I agree it's horribly unnatural, I suspect it's got the same kind of dualism-with-the-right-answer problem that doing language processing in OO tends to have
14:40:51 <kmc> so a function can take a boxed or unboxed argument, can return a boxed or unboxed value or an unboxed tuple, and is itself a boxed type
14:40:57 <jmcarthur> i would kill for liftA9 right now :o
14:41:08 <Philippa> Now Evaluate This! New Extreme Technology
14:41:34 <Philippa> NET Effervescent Turdpile...
14:41:35 <Twey> Hm.  There does seem to be a dearth of documentation.
14:41:59 <Twey> Heh
14:42:16 <jmcarthur> <$><*><*><*><*><*><*><*><*> ftw
14:42:26 <Twey> I think they claimed it to make it appear to the end-user that it's associated with every .net domain ever registered.
14:42:31 <kmc> Twey, hewei, http://hackage.haskell.org/trac/ghc/wiki/IntermediateTypes
14:42:36 <kmc> see section "Kinds are Types"
14:42:48 <kmc> this is about GHC guts
14:42:56 <hewei> kmc: Thank you very much! 
14:43:04 <Twey> Aha
14:43:11 <kmc> if you want to understand the bit about "coercion kinds" you should read the System Fc papers
14:43:18 <Philippa> Core kinds are /not/ GHC-Haskell-visible kinds insofar as the latter aren't types, but...
14:43:26 <mreh> why not call it .com then?
14:43:36 <mreh> or http://www.
14:43:53 <mreh> rolls of the tongue
14:44:01 <Philippa> I heard someone suggested .xxx, but they weren't pushing any HOT languages at the time
14:44:07 <Twey> Hoho
14:44:19 <Twey> mreh: Because .NET means NETWORKING!
14:44:21 <mreh> <_>
14:44:48 <Twey> And the .com bubble burst already
14:45:00 <Twey> The .NET bubble is NEW! AND! EXCITING!
14:45:07 <Philippa> I think they just wanted to extend NT
14:45:19 <mreh> zing
14:45:28 <mreh> hiyoooo
14:46:41 <mreh> I can't think of any more gags
14:46:44 <Philippa> Heffalump: re DI vs functors/modules, I think the big thing is most OO languages don't have an equivalent of opening a module/signature? I can see it being a lot less fugly in C# if you're careful with your using clauses, actually
14:47:28 <mreh> could someone explain how the recursive syntax in haskell relates to fix?
14:47:38 <mreh> what's the logical connection?
14:47:39 <Philippa> I guess there's also a bit of an inversion that goes on with dependency passing
14:48:01 <Cale> > fix (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
14:48:02 <lambdabot>   3628800
14:48:06 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml connects recursion and fix.
14:48:10 <Cale> mreh: That might give you some idea
14:48:13 <Philippa> mreh: it's more that fix is what you do if you don't have recursive syntax - so it's how you express it in terms of untyped lambda calculus
14:48:44 <Philippa> it's not really a 'logical' level connection as such
14:48:51 <Heffalump> Philippa: I think you would just structure your code rather differently.
14:48:58 <Heffalump> instead of trying to pretend you have them
14:49:28 <Philippa> (naked fix is what you do when you can't find a nicer way of expressing the logicalness of a piece of recursion, same way as general recursion is what you do when no nice HOF captures it for you)
14:49:56 <Philippa> Heffalump: to be fair I've never used DI directly or gone through the pain of converting OO code to use it
14:50:27 <mreh> what I'm thinking of is zeroes = 0 : zeroes
14:50:36 <Philippa> it does seem like the sort of thing that Coq's very deliberately designed to straddle, though - is it a dependency or a free variable, etc etc
14:50:40 <Cale> > fix (\zeroes -> 0 : zeroes)
14:50:41 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
14:50:51 <mreh> hmm
14:51:29 <Philippa> fix "ties knots", you pass it a function that assumes it has access to itself/its own subfunctions and fix generates them for it
14:51:46 <Cale> > fst $ fix (\ ~(evens, odds) -> (0 : map (+1) odds, map (+1) evens))
14:51:47 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
14:51:52 <Cale> > snd $ fix (\ ~(evens, odds) -> (0 : map (+1) odds, map (+1) evens))
14:51:53 <lambdabot>   [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,5...
14:52:02 <Cale> You can do mutual recursion like that
14:52:21 <Philippa> oh for better records :p
14:52:35 <Philippa> but yeah, that's the "own subfunctions" approach
14:53:19 <poincare101> > [1 .. ]
14:53:20 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:53:37 <tbone> fst $ fix (\ (evens, odds) -> (0 : map (+1) odds, map (+1) evens))
14:53:45 <mreh> doesn't terminate
14:53:52 <Cale> > fst $ fix (\ (evens, odds) -> (0 : map (+1) odds, map (+1) evens))
14:53:56 <lambdabot>   mueval-core: Time limit exceeded
14:54:13 <tbone> what does the tilde mean, havent seen that before
14:54:20 <megajosh2> mreh: Tha'ts only because it's a pair of infinite lists
14:54:34 <mreh> lazy pattern matching
14:54:54 <megajosh2> tbone: I'm not completely sure, but I think it's basically "don't evaluate this eagerly when you match it"
14:54:59 <Cale> tbone: It forces the pattern to always match immediately without checking if it really matches until one of the variables it binds is used.
14:55:16 <Twey> And then, if it doesn't, it explodes.
14:56:22 <monochrom> \ eo -> let (evens,odds)=eo in (0 : map (+1) odds, map (+1) evens)
14:56:39 <Cale> Right, you can think of it like that as well
14:56:53 <Cale> > fst . fix $ \ eo -> let (evens,odds)=eo in (0 : map (+1) odds, map (+1) evens)
14:56:54 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
14:57:04 <mreh> what does happen if it doesn't?
14:57:13 <sinelaw> hey Cale 
14:57:23 <Cale> > (\ ~(Just x) -> 5) Nothing
14:57:24 <lambdabot>   5
14:57:25 <megajosh2> Probably something heinous
14:57:27 <Cale> > (\ ~(Just x) -> x) Nothing
14:57:28 <lambdabot>   *Exception: <interactive>:1:134-149: Irrefutable pattern failed for pattern...
14:58:25 <Cale> > (\ ~(Just x) -> [1,2,3,4,x]) Nothing
14:58:26 <lambdabot>   [1,2,3,4,*Exception: <interactive>:1:150-175: Irrefutable pattern failed fo...
14:58:42 <Twey> mreh: 22:54:52 < Twey> And then, if it doesn't, it explodes.
14:58:44 <disgrntld> How do I verbalize "<*>"?
14:59:07 <Cale> disgrntld: Maybe "app"
14:59:21 <disgrntld> good enough for me, thanks
14:59:24 <disgrntld> :D
14:59:46 <mreh> ap = <*>?
14:59:53 <Cale> yeah
15:00:01 <aristid> mreh: yes, for monads
15:00:05 <disgrntld> I was gonna say "applicative application" or something ,lol
15:00:06 <Cale> ap is the implementation of <*> for any monad
15:00:29 <micahjohnston> can't you just say instance Monad a => Applicative a?
15:00:42 <mreh> CURSE YOU HASKELL!
15:00:42 <megajosh2> > return (+) `ap` Just 5 `ap` Just 3
15:00:43 <lambdabot>   Just 8
15:00:46 <megajosh2> Hmm
15:00:53 <aristid> Cale: it would be nice if there was a way to avoid this instance boilerplate (writing (<*>) = ap and fmap = liftM and such things)
15:01:08 <mreh> we should have made all Monads applicative functors
15:01:12 <Philippa> "instance templates" would be nice
15:01:33 <Philippa> just an instance that you make a separate statement to have actually declared as an instance for a specific set of types
15:01:52 <Cale> micahjohnston: No, because that instance overlaps with every instance of Applicative
15:01:59 <megajosh2> Like, make your own default instance so you can use "deriving" on your typelcass?
15:02:05 <megajosh2> Or something like that?
15:02:13 <megajosh2> Well, intuitive
15:02:23 <Cale> micahjohnston: Remember that typeclasses are open, so there's no way for the compiler to ever prove that something won't be an instance of Monad later.
15:02:50 <megajosh2> Okay, now that I think about it, that sounds complicated...
15:03:12 <megajosh2> What about Template Haskell?
15:03:14 <mreh> (Applicative m, Functor m) => Monad m would have made more sense
15:03:24 <kmc> what about C preprocessor
15:03:40 <kmc> #define APP(m) instance Applicative m where { pure = return; (<*>) = ap }
15:03:41 <aristid> mreh: huh? Functor m => Applicative m => Monad m would do, i think
15:03:54 <aristid> kmc: C preprocessor :(
15:04:20 <mreh> aristid: yes, if we had Functor a => Applicative a too :)
15:04:25 <kmc> a lot of the proposed uses of template haskell are just substituting tokens for other tokens
15:04:37 <kmc> and for that kind of thing CPP is far simpler
15:04:56 <aristid> kmc: CPP is still not a good solution.
15:05:44 <kmc> right
15:05:53 <kmc> but it's better than doing the same thing with TH
15:07:42 <notabel> megajosh2: there is something kind of like that in ghc, namely the generic classes extension; instead of using the deriving syntax, it lets you write an instance declaration but leave out the `where` clause, which is filled in by the generic class
15:07:56 <micahjohnston> Cale: I thought you could do instance Class a => OtherClass a where ..., and then you could make more specific implementations of specific typeclasses if you wanted to
15:08:14 <micahjohnston> like you can do default implementations of methods
15:08:45 <Cale> With various extensions, I think you can get it to work. I forget how many of those you need.
15:08:47 <notabel> a more general solution, though, is something like the derive package, which uses template haskell to do derivations for lots of useful classes
15:09:31 <micahjohnston> so I've cleared up some of my problems with LLVM and Haskell, but I still haven't gotten it to work
15:10:43 <mreh> thanks for that fix link, it's great
15:10:44 <mreh> i've been looking for such an explanation for weeks
15:11:12 <benmachine> @type liftIO . fmap
15:11:13 <lambdabot>     Couldn't match expected type `IO a'
15:11:13 <lambdabot>            against inferred type `f a1 -> f b'
15:11:14 <lambdabot>     Probable cause: `fmap' is applied to too few arguments
15:11:24 <micahjohnston> Axman6: are you here?
15:18:53 <kmc> hmm
15:19:04 <kmc> it's not possible to know how many characters there are in a file without reading through it, correct?
15:19:19 <kmc> because usually the locale is not using a fixed size encoding
15:19:30 <JoeyA> oh, characters, not bytes.
15:19:34 <kmc> is there a standard way to estimate?
15:19:51 <kmc> i could assume 1 byte / character, but that will fail spectacularly on some languages
15:20:57 <benmachine> kmc: sample a small amount of the text for an average bytes/character?
15:21:03 <mee> you could generate some estimate ratios from similar pieces of text
15:21:12 <benmachine> seek to somewhere in the middle of the file perhaps
15:21:39 <benmachine> oh but you wanted a "standard" way, I don't know about standards
15:21:43 <sinelaw> @pl (\x s' -> singleton (f x) `union` s')
15:21:44 <lambdabot> union . singleton . f
15:21:49 <sinelaw> ooh
15:21:57 <sinelaw> <3 pl
15:22:33 <enigmus> Is there a "strict map", i.e. evaluate f x1 fully before evaluating f x2 in: map f [x1, x2] == [f x1, f x2] ?
15:23:06 <mreh> we got haskell on the iPhone yet?
15:23:14 <kmc> enigmus, you want evaluation of the first element to force the rest? or you want evaluation of the first (:) cell to force the rest?
15:23:25 <kmc> mreh, http://projects.haskell.org/ghc-iphone/
15:23:32 <kmc> Android support Coming Soon ™
15:23:54 <sinelaw> kmc, how's the android support gonna work?
15:23:58 <mreh> yey!
15:24:13 <sinelaw> i mean how will it be implemented
15:24:14 <kmc> sinelaw, same way as iPhone roughly
15:24:20 <sinelaw> kmc, which is?
15:24:21 <kmc> unregisterised via-C at first
15:24:29 <kmc> later we may add registerised ARM to GHC
15:24:33 <darrint> What's a good library for text formatting so I can avoid a lot of (++) when making strings?
15:24:38 <kmc> (probably no NCG; via-C and LLVM are good enough)
15:24:44 <kmc> darrint, Text.PrettyPrint
15:25:01 <benmachine> darrint: do you know about ShowS?
15:25:17 <benmachine> actually it's probably not what you want
15:25:27 <notabel> enigmus: do you mean that you want the first element to be evaluated fully before the second element is evaluated at all?  or do you want each element to be evaluated completely the first time it is accessed?
15:25:27 <benmachine> worth knowing about though
15:25:58 <benmachine> darrint: also, purely syntactically, you could use concat on lists
15:26:00 <enigmus> notabel: the first version
15:26:07 <kmc> :t foldr'
15:26:08 <lambdabot> Not in scope: `foldr''
15:26:16 <benmachine> so x ++ "foo" ++ y ++ z ++ "\n" -> concat [x, "foo", y, z, "\n"]
15:26:26 <enigmus> kmc: I want it to be "depth first", if that makes any sense
15:26:39 <benmachine> enigmus: can I ask why, out of interest?
15:26:46 <kmc> :t \f -> foldl' (flip ((:).f))
15:26:47 <lambdabot> forall a b. (b -> a) -> [a] -> [b] -> [a]
15:26:52 <kmc> enigmus, ^^^^ ?
15:26:56 <kmc> :t \f -> foldl' (flip ((:).f)) [] --
15:26:58 <lambdabot> forall a b. (b -> a) -> [b] -> [a]
15:27:16 <enigmus> benmachine: well, limit memory usage
15:27:17 <kmc> anyway what i really want is just a progress bar on Data.Text.Lazy.foldl'
15:27:22 <kmc> but without reading all the chunks at once
15:27:40 <benmachine> enigmus: hmm, what type does f produce?
15:27:54 <darrint> concat looks like the right thing here. Thanks all.
15:27:56 <enigmus> benmachine: Int
15:28:06 <benmachine> ah, that's relatively nice
15:28:18 <kmc> or can i get the length of the list of chunks without reading them all into memory?
15:28:25 * kmc doubts it... stupid lazy IO
15:29:28 <sinelaw> @pl (flip member a) || (flip member b)
15:29:29 <lambdabot> flip member a || flip member b
15:29:38 <sinelaw> bah
15:29:53 <benmachine> sinelaw: do you mean, \a b ->?
15:29:58 <sinelaw> yeah
15:30:06 <sinelaw> @pl (\a b -> (flip member a) || (flip member b))
15:30:06 <lambdabot> (. flip member) . (||) . flip member
15:30:09 <benmachine> :t liftA2 (||) (flip member) (flip member)
15:30:09 <sinelaw> baaah
15:30:10 <lambdabot> Not in scope: `member'
15:30:10 <lambdabot> Not in scope: `member'
15:30:12 <benmachine> eerm
15:30:18 <benmachine> :t liftA2 (||) (flip S.member) (flip S.member)
15:30:19 <lambdabot>     Couldn't match expected type `Bool'
15:30:19 <lambdabot>            against inferred type `a -> Bool'
15:30:19 <lambdabot>     Probable cause: `flip' is applied to too few arguments
15:30:25 <benmachine> bah
15:30:32 <benmachine> :t flip S.member
15:30:33 <lambdabot> forall a. (Ord a) => S.Set a -> a -> Bool
15:31:04 <benmachine> sinelaw: surely flip member a || flip member b is ill-typed?
15:31:07 <sinelaw> :t (||) (flip S.member) (flip S.member)
15:31:08 <lambdabot>     Couldn't match expected type `Bool'
15:31:08 <lambdabot>            against inferred type `S.Set a -> a -> Bool'
15:31:09 <lambdabot>     In the first argument of `(||)', namely `(flip S.member)'
15:31:24 <benmachine> sinelaw: flip member takes two arguments
15:31:35 <Peaker> flip means member is of 2 args.. so after giving it just "a" or "b"
15:31:37 <sinelaw> ah oops
15:31:52 <sinelaw> @pl (\a b x -> (member x a) || (member x b))
15:31:52 <lambdabot> (. flip member) . ap . ((||) .) . flip member
15:32:32 <sinelaw> @pl (\a b x -> (flip member a x) || (flip member b x))
15:32:32 <lambdabot> (. flip member) . ap . ((||) .) . flip member
15:32:36 <sinelaw> duh.
15:32:36 <benmachine> enigmus: what you want to do broadly speaking is turn [x,y,z,...] into [x, seq x y, seq (seq x y) z,...]
15:32:40 <benmachine> I think
15:33:00 <sinelaw> @type liftA2
15:33:01 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
15:33:20 <freedrull> is there a parsec function that i can give a list of strings and tell it to match one of them
15:33:23 <sinelaw> @type liftA2 (||)
15:33:24 <lambdabot> forall (f :: * -> *). (Applicative f) => f Bool -> f Bool -> f Bool
15:33:42 <benmachine> enigmus: scanl1 seq *might* do what you want, but I'm not sure
15:33:56 <enigmus> benmachine: yeah, that's what I want, indeed.
15:33:58 <benmachine> freedrull: choice, I think
15:34:13 <Philonous> Is Disjkstra's Algorith the same as A* with a heuristic function h = const 0 ?
15:34:18 <Philonous> algorithm*
15:34:33 <sinelaw> :t (\a -> liftA2 (||) (flip S.member a))
15:34:35 <lambdabot> forall a. (Ord a) => S.Set a -> (a -> Bool) -> a -> Bool
15:35:51 <freedrull> benmachine: i think so
15:36:31 <enigmus> kmc: not sure what you proposed works, even thought it looks like it should
15:36:47 <kmc> !_ is a funny pattern
15:37:04 <benmachine> kmc: seq !_ x = x
15:37:08 <freedrull> but choice :: [GenParser st a] -> GenParser st a
15:37:11 <benmachine> something like that?
15:37:22 <benmachine> freedrull: oh, right, list of strings, yes
15:37:32 <benmachine> freedrull: do the strings all have unique first letters?
15:37:49 <enigmus> benmachine: I don't think scanl1 seq would work, as by then the whole list of thunks is built, which could mean holding a bunch of memory?
15:38:19 <benmachine> enigmus: I don't follow
15:38:24 <freedrull> benmachine: no
15:38:39 <benmachine> freedrull: try choice . map (try . string)
15:38:42 <benmachine> eer
15:38:51 <benmachine> :t choice . map (try . string)
15:38:52 <lambdabot> Not in scope: `choice'
15:38:52 <lambdabot> Not in scope: `try'
15:38:52 <lambdabot> Not in scope: `string'
15:38:55 <benmachine> fff
15:39:00 <benmachine> try that anyway
15:39:04 <enigmus> benmachine: I need to wrap my head around this thing better. I'm not sure I can explain more clearly what I want.
15:39:09 <enigmus> s/want/mean/
15:39:16 <freedrull> benmachine: ok thanks :3
15:39:19 <benmachine> enigmus: first of all, are you hitting a problem, or anticipating one?
15:41:36 <freedrull> benmachine: do i pass my list of strings to the "string" function?
15:41:52 <enigmus> benmachine: I am hitting a problem, hitting a stack overflow. I can fix it by writing a version of map by hand that evaluates fully (f x1) before computing (f x2), but I was looking for a more idiomatic way of doing that.
15:41:52 <benmachine> freedrull: well, the "string" function takes a string and makes a parser that will match it
15:42:01 <benmachine> enigmus: ahh
15:42:02 <freedrull> oh ok
15:42:19 <benmachine> enigmus: can you hpaste your strict map? I think that would be the easiest way for us to see the behaviour you want
15:42:44 <benmachine> oh wow, hpaste has a new look
15:42:45 <enigmus> benmachine: ok, I'll extract it and paste it
15:46:22 <monochrom> @hoogle foldl
15:46:22 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
15:46:23 <lambdabot> Data.ByteString foldl :: (a -> Word8 -> a) -> a -> ByteString -> a
15:46:23 <lambdabot> Data.Foldable foldl :: Foldable t => (a -> b -> a) -> a -> t b -> a
15:46:26 <monochrom> @hoogle foldl'
15:46:27 <lambdabot> Data.ByteString foldl' :: (a -> Word8 -> a) -> a -> ByteString -> a
15:46:27 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
15:46:27 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
15:46:33 <monochrom> @hoogle scanl'
15:46:33 <lambdabot> No results found
15:47:18 <c_wraith> err.  how does pattern matching work with ByteStrings and the OverloadedStrings extension?  Does it generalize pattern-matching of Strings the same way that pattern-matching of numbers is generalized?
15:48:03 <kmc> think so
15:48:26 <kmc> the ByteString OverloadedStrings instance is a lie, anyway
15:48:34 <kmc> ByteString can't hold Char
15:48:35 <c_wraith> that's...  kind of weird, come to think of it.  Though, so is pattern-matching numbers, really
15:48:47 <c_wraith> So?  Word8 can't hold 300
15:48:54 <c_wraith> does that make Num a lie?
15:48:57 <kmc> hmm
15:49:05 <kmc> a fair point
15:49:23 <benmachine> does it encode the string, or just truncate it?
15:49:28 <c_wraith> truncate
15:49:37 <c_wraith> it uses the low 8 bits of each character
15:49:40 <kmc> yeah, you don't even get a runtime error message afaik
15:51:31 <monochrom> Z/256Z is a fine Num
15:51:53 <monochrom> ℤ/256ℤ
15:52:28 <monochrom> probably a strange Integral though
15:53:47 <monochrom> there is something about a few days ago was programmer's day. the 0x100th day of the year.
15:54:19 <benmachine> zero-indexed? :P
15:55:07 <monochrom> I don't know.
15:55:55 <c_wraith> as a programmer, I protest.  0x100 isn't very special.  0xFF is much more special
15:56:44 <monochrom> by choosing between 0-based and 1-based, we can get to an agreement.
15:56:58 <benmachine> ghci> show $ LocalTime (ModifiedJulianDay 0) midnight 
15:56:58 <benmachine> "1858-11-17 00:00:00"
15:57:01 <benmachine> ... huh?
15:57:17 <aristid> benmachine: what's wrong with it?
15:57:26 <benmachine> aristid: odd place to count from, that's all
15:57:42 <aristid> probably a reason for it
15:57:56 <aristid> benmachine: 19th century was when a lot of things were invented and standardised
15:58:04 <benmachine> interesting
15:58:17 <hpc> that particular month has something like 15 days in it
15:58:19 <aristid> don't know the exact reason for that date, though
15:58:30 <hpc> for an odd reason i cannot recall at the moment
15:59:19 <pickles> can anyone see why this would give me an error?
15:59:19 <pickles> http://hpaste.org/30129/why_is_this_erroring_on_compil
16:00:49 <benmachine> pickles: in your second equation, h has type FlowControl a
16:01:03 <benmachine> pickles: the result type is supposed to have type FlowControl b, but you're giving h there
16:01:14 <benmachine> so the types don't match
16:01:19 <pickles> AAahhh, right
16:01:24 <pickles> tyvm benmachine
16:01:39 <benmachine> pickles: it's important to take the fields out of the Halt constructor and then... put them back in as it were :)
16:01:47 <benmachine> allows the value to have a new type
16:02:04 <pickles> hehe, yeah, i was wanting to save myself typing, which is why i did it the way i did, w/o even considering the type thing
16:02:27 <monochrom> yes you have to write (>>=)  h@(Halt es ws) f = Halt es ws
16:02:30 <notabel> benmachine: the modified julian date is the actual julian date minus 2400000.5
16:02:58 <pickles> benmachine: sweet, it compiles, thanks!
16:02:59 <notabel> and the actual julian date is based off of the julian proleptic calendar
16:03:16 <darrint> n00bish question: Can I convert this tail recursive function to something more like a fold? http://hpaste.org/30130/use_fold_or_somthing_instead_o
16:03:38 <monochrom> this is also why sometimes you see code like "f Nothing = Nothing". the two Nothing's have different types. because the next line is "f (Just 4) = Just True"
16:03:45 <notabel> which had a zero moment at noon, 1 januarius, 4713BC
16:04:19 <monochrom> OTOH I could be evil and suggest "f n@Nothing = unsafeCoerce n"
16:04:23 <benmachine> notabel: interesting, thanks, any idea what's behind the 4713 BC
16:04:29 <benmachine> ?
16:04:34 <monochrom> (>>=)  h@(Halt es ws) f = unsafeCoerce h  :)
16:04:54 <benmachine> monochrom: what could possibly go wrong
16:05:01 <monochrom> 4713 BC was when I was born.
16:05:25 <benmachine> was your first act out of your mother's womb to standardise the calendar?
16:05:26 <notabel> hah
16:05:56 <pickles> mm, not familiar w/ unsafeCoerce
16:06:04 <monochrom> no. I didn't know about calendars. I guess the authors of the time package just like to honour me.
16:06:22 <xplat> < benmachine> so a Set a is *kind* of like, a -> Bool <-- and you can get the list of elements too if a is denumerable, just as long as you don't mind if it ends with _|_ if it's a finite set with infinite 'a'
16:06:28 <monochrom> no, don't use unsafeCoerce, it was a joke.
16:06:35 <notabel> benmachine: it has to do with the way the julian proleptic cycle runs, and it's based on the least common multiple of the solar cycle, the lunar cycle, and.....the roman tax cycle (15 years)
16:07:06 <monochrom> hahaha tax cycle
16:07:23 <benmachine> nice :P
16:07:31 <JoeyA> darrint: dumb question from myself: why aren't you using a list for PhysicalBounds?
16:07:32 <benmachine> for those it may concern:
16:07:33 <benmachine> ghci> addDays 256 $ read "2010-01-01"
16:07:33 <benmachine> 2010-09-14
16:07:49 <JoeyA> What you have looks like a right fold.
16:07:59 <benmachine> so that's day 0x100 zero-indexed
16:08:05 <JoeyA> You could write a foldr-type function for your PhysicalBounds
16:08:16 <xplat> (i'm assuming that your `a -> Bool' is computable and total since it comes from `flip member someSet'
16:08:21 <darrint> JoeyA: Mostly because I'm trying to learn to do it the self-consy way.
16:08:29 <pickles> darrint: foldl' (\ls p -> encodePhysicalBounds p : ls) [] bs   ?
16:08:31 <JoeyA> ah
16:09:02 <darrint> pickles: What would be the type of encodePhysicalBounds?
16:09:21 <JoeyA> I suppose you could factor the recursion out so you have data PhysicalBounds = PhysicalDone | PhysicalBound PhysicalBounds
16:09:25 <pickles> same as it is, only w/o the [] on the string
16:09:44 <JoeyA> (and make PhysicalBound consist of PhysicalCircle, PhysicalSegment, and PhysicalPoly without the recursive term)
16:10:01 <pickles> it might be a right fold like JoeyA says, i wasn't looking that closely at it
16:10:20 <benmachine> JoeyA: erm, that'd be PhysicalDone | PhysicalCons PhysicalBound PhysicalBounds and isomorphic to a list :P
16:11:05 <benmachine> darrint: a list seems a much more natural structure, imo, but you could define a fold-like function on your type
16:11:07 <JoeyA> right, my bad
16:12:14 <darrint> Am I allowed to write a function that does only a partial pattern match?
16:12:19 <JoeyA> Yes.
16:12:22 <benmachine> darrint: "allowed"?
16:12:30 <benmachine> you are but if you can avoid it that's nice
16:12:33 <darrint> by the language. sorry.
16:12:45 <benmachine> see: head
16:12:46 <pickles> darring: grr, sorry, i didn't see that the 'bs' var was part of the PhysicalBounds type
16:13:09 <JoeyA> Of course, the onus is on you to prove it won't fail to match.
16:13:27 <pickles> *darrint, sry.
16:13:39 <pickles> maybe a fold w/ functors?
16:13:58 <JoeyA> I guess what you want to start with is encodePhysicalBound :: PhysicalBounds -> String and just neglect to handle the PhysicalDone part.
16:14:30 <JoeyA> (except for in another function which does)
16:14:36 <pickles> yeah, PhysicalDone does make it difficult
16:14:47 <JoeyA> Another way might be to augment said function to prepend to a list of strings.
16:15:08 <JoeyA> as in, PhysicalBounds -> [String] -> [String]
16:15:20 <pickles> might try something like this to get around PhysicalDone
16:15:20 <pickles> (?:) (Just x) xs = x:xs
16:15:20 <pickles> (?:) Nothing  xs = xs
16:15:28 <JoeyA> Which you could subsequently plug into a foldr function for your type.
16:16:43 <JoeyA> :t foldr
16:16:44 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
16:17:19 <JoeyA> pFoldr :: (PhysicalBounds -> [b] -> [b]) -> b -> PhysicalBounds -> b
16:17:21 <JoeyA> err
16:17:29 <JoeyA> pFoldr :: (PhysicalBounds -> b -> b) -> b -> PhysicalBounds -> b
16:17:41 <hpc> almost
16:17:54 <JoeyA> Though this isn't the best use of types.  PhysicalBounds is being used to describe both one and many items.
16:17:58 <darrint> Don't laugh too loudly but for a bit I though I could make encodePhysicalBounds :: (PhysicalBounds -> PhysicalBounds) -> [String], expressing the idea of a single bound in the chain of bounds.
16:18:13 <benmachine> I still think making PhysicalBounds a list is the sensible option
16:18:37 <prey_alone> Is there a way to convert Data.Tree to Data.Graph.Inductive.Tree?
16:19:00 <darrint> Thanks for the help all.
16:19:36 <hpc> @hoogle Data.Tree -> Data.Graph.Inductive.Tree
16:19:37 <lambdabot> Parse error:
16:19:37 <lambdabot>   --count=20 "Data.Tree -> Data.Graph.Inductive.Tree"
16:19:37 <lambdabot>                  ^
16:20:01 <prey_alone> hpc: No results. Thanks, though.
16:20:16 <benmachine> hpc: those are both module names!
16:20:38 <hpc> benmachine: pah
16:20:49 <benmachine> :P
16:21:24 <darrint> for what it's worth I was attempting to pull one of these but failed: http://chplib.wordpress.com/2010/08/23/sharp-cards-in-haskell-drawing-cards/ 
16:21:28 <benmachine> prey_alone: it looks like the only way to make a tree from Data.Graph.Inductive.Tree is via the Graph class and mkGraph
16:21:30 <darrint> walk before you run....
16:21:47 <prey_alone> Data.Tree -> Data.Graph.Inductive.Graph would also suit my purposes.
16:22:35 <benmachine> prey_alone: you want a Gr a b?
16:22:51 <JoeyA> Ride bicycle ramps slowly before riding them quickly (or better yet, don't ride them at all).
16:22:56 <prey_alone> I'm a newbie; all I can think to do is to use for loops to make a list of nodes and edges, and to pass them to mkGraph. I can't wrap my mind around collecting the nodes/edges though.
16:23:06 <prey_alone> benmachine: Yes!
16:24:03 * JoeyA got a grade 3 concussion riding a bicycle ramp at 15mph.  Why oh why don't I do the math before trying stuff?
16:25:07 <JoeyA> If the world were like Haskell, the type checker wouldn't have let me do that.
16:25:38 <benmachine> JoeyA: you're an unsafePerformer?
16:25:49 <JoeyA> lol
16:26:11 <benmachine> umm anyway
16:26:18 <pickles> ah, the programming puns
16:26:24 <hpc> benmachine: his performance is unmatched :P
16:26:28 <benmachine> heh
16:26:48 <JoeyA> unsaveCoerce :: a -> EvelKnievel
16:26:54 <pickles> if you don't do it Just Right you're Left Nothing
16:27:03 <JoeyA> lol
16:27:16 <aristid> :t Just Right
16:27:16 <lambdabot> forall b a. Maybe (b -> Either a b)
16:27:23 <aristid> :t Left Nothing
16:27:24 <lambdabot> forall a b. Either (Maybe a) b
16:27:50 <JoeyA> :t Just $ do it
16:27:51 <lambdabot> Not in scope: `it'
16:27:57 <hpc> haha
16:27:59 <pickles> nice
16:28:40 <JoeyA> (works in GHCi after saying something before it)
16:29:10 <aristid> > Just Right `ap` Just (Left Nothing)
16:29:11 <lambdabot>   Just (Right (Left Nothing))
16:29:28 <hpc> :t (=~)
16:29:30 <lambdabot> forall source1 source target. (RegexMaker Regex CompOption ExecOption source, RegexContext Regex source1 target) => source1 -> source -> target
16:29:42 <aristid> pickles: ^
16:30:09 <JoeyA> > cycle "|/-\"
16:30:10 <lambdabot>   <no location info>:
16:30:10 <lambdabot>      lexical error in string/character literal at end o...
16:30:14 <JoeyA> > cycle "|/-\\"
16:30:15 <lambdabot>   "|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\\|/-\...
16:30:28 <JoeyA> bah, doesn't look as funny as I hoped.
16:30:45 <benmachine> > text (cycle "|/-\\")
16:30:50 <lambdabot>   mueval: ExitFailure 1
16:30:50 <benmachine> eeerm
16:30:57 <benmachine> > text (take 200 $ cycle "|/-\\")
16:30:58 <lambdabot>   |/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-\|/-...
16:31:10 <pickles> aristid: heheh
16:31:30 <pickles> :t ap
16:31:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:31:48 <aristid> :t flip ap . return
16:31:49 <lambdabot> forall (m :: * -> *) a b. (Monad m) => a -> m (a -> b) -> m b
16:32:04 <aristid> @hoogle a -> m (a -> b) -> m b
16:32:04 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
16:32:05 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
16:32:05 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
16:33:01 <aristid> :t (<**>) . return
16:33:02 <lambdabot> forall (f :: * -> *) a b. (Applicative f, Monad f) => a -> f (a -> b) -> f b
16:33:15 <djahandarie> :t (<**>) . pure
16:33:16 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => a -> f (a -> b) -> f b
16:33:29 <JoeyA> > mapM_ ((>> usleep 100000) . putStr . (: "\r")) $ cycle "|/-\\"
16:33:30 <lambdabot>   Not in scope: `usleep'
16:33:37 <JoeyA> lambdabot never sleeps
16:33:39 <djahandarie> lol
16:33:52 <djahandarie> It only dies very frequently?
16:33:53 <djahandarie> :P
16:34:05 <JoeyA> It gets plenty of sleep when it's dead.
16:34:29 <aristid> > let p = (<**>) . return in Just Right `p` Left Nothing
16:34:30 <lambdabot>   No instances for (Control.Applicative.Applicative
16:34:30 <lambdabot>                      (Dat...
16:34:37 <aristid> damn missing instances
16:35:02 <aristid> Control.Monad.Either> let p = (<**>) . pure in Just Right `p` Left Nothing
16:35:02 <aristid> Left Nothing
16:35:47 <Adamant> JoeyA: let's avoid the kill -9, then
16:38:00 <JoeyA> > system "killall ghc"
16:38:01 <lambdabot>   Not in scope: `system'
16:38:21 <aristid> JoeyA: nice try.
16:38:27 <JoeyA> lol, thanks
16:38:42 <aristid> ever heard of irony? :P
16:39:18 <djahandarie> ... don't you mean sarcasm?
16:39:38 <aristid> djahandarie: i guess those can be combined
16:39:38 <benmachine> I think the lol, covered both those options
16:40:54 <Adamant> it's like a black fly, in your chardonnay?
16:41:05 * benmachine giggles
16:41:35 <tbone> is it possible to implement bottom-up parallel tree contraction in haskell?
16:42:10 <tbone> i'm having trouble reconfiguring the algo to work with immutable data structures
16:45:20 <andrewsw> although it doesn't appear to actually announce here, which I think is an hpaste.org problem, I've just patched up hpaste.el to work with the current hpaste.org
16:45:25 <andrewsw> http://www.haskell.org/haskellwiki/Hpaste.el
16:45:43 <andrewsw> and here: http://hpaste.org/30131/reworked_hpasteel_for_the_new pasted directly from emacs :)
16:46:28 <ManateeLazyCat> andrewsw: http://www.emacswiki.org/emacs/Paste2 asynchronous upload to server. :)
16:46:55 <andrewsw> doh!
16:47:13 <ManateeLazyCat> andrewsw: Infact, is get/upload asynchronous. :)
16:47:45 <andrewsw> nic
16:47:45 <andrewsw> e
16:48:19 <ManateeLazyCat> andrewsw: you can see it's source code, key is use function 'url-retrieve'
16:48:39 <andrewsw> ManateeLazyCat: that's what hpaste.el uses as well.
16:48:56 <ManateeLazyCat> andrewsw: Infact, i remember two or three years ago, twb suggest use hpaste.el at #emacs, but hpaste.org have limit.
16:49:03 <ManateeLazyCat> andrewsw: Then i develop paste2.el
16:49:08 <andrewsw> It uses url-retrieve for POST
16:49:21 <ManateeLazyCat> andrewsw: But style like hpaste.el ;p
16:49:50 <andrewsw> ManateeLazyCat: Well, the more the merrier, eh? 
16:50:00 <ManateeLazyCat> andrewsw: Yeah, add callback in 'url-retrieve' to implement asynchronous notice.
16:50:22 <andrewsw> ManateeLazyCat: yup
16:50:26 <ManateeLazyCat> andrewsw: paste2.org allow you paste bigger content.
16:51:05 <andrewsw> ManateeLazyCat: the hpaste-get-paste is synchronous. Not really sure why, but the rest is async.
16:51:42 <ManateeLazyCat> andrewsw: Look paste2-get-paste
16:51:42 <andrewsw> ManateeLazyCat: anyway, it's working again :)
16:52:09 <sshc> What is the standard way to get the current day of month, month, and year?
16:52:18 <ManateeLazyCat> andrewsw: Thanks for build hpaste.el, infact i implement some idea in paste2.el
16:52:29 <ManateeLazyCat> sshc: Data.Time
16:52:31 <ManateeLazyCat> @time
16:52:32 <lambdabot> Local time for ManateeLazyCat is Fri Sep 17 07:52:17 2010
16:52:36 <benmachine> sshc: something involving getZonedTime or getCurrentTime, and toGregorian I think
16:52:36 <ManateeLazyCat> @package time
16:52:37 <lambdabot> http://hackage.haskell.org/package/time
16:52:48 <ManateeLazyCat> sshc: ^^^^^
16:53:07 <sshc> Thanks
16:53:16 <Boney> Hi Haskell Folks,  Today I received an e-mail from someone I've never heard of asking for help with haskell.
16:53:26 <Boney> they had some type signatures and wanted me to fill in the blanks.
16:53:27 <andrewsw> ManateeLazyCat: looks nice. 
16:53:47 <andrewsw> Boney: isn't that what djinn is for?
16:53:50 <Boney> The problem looks simple enough but if I do it for them, they won't learn anything, and they'll keep comming back expecting me to fill in the blanks for them.
16:54:00 <Boney> andrewsw: what's a djinn?
16:54:14 <benmachine> djinn is a thing for implementing a function based on its type
16:54:22 <Boney> Where can I direct this person so they get their problem solved (perhaps with some effort of their own) and I don't get bothered again.
16:54:28 <benmachine> @djinn b -> (a -> b) -> Maybe a -> b
16:54:28 <lambdabot> f a b c =
16:54:28 <lambdabot>     case c of
16:54:29 <lambdabot>     Nothing -> a
16:54:29 <lambdabot>     Just d -> b d
16:54:44 <benmachine> Boney: if you've never heard of them you could just not reply >_>
16:54:54 <Boney> it'd also be nice if they learn to fish rather than have people give them fish (if your familiar with the metaphor)
16:55:03 <sshc> @djinn a -> b
16:55:03 <lambdabot> -- f cannot be realized.
16:55:04 <benmachine> Boney: failing that, this channel is a nice place, or haskell-beginners mailing list
16:55:07 <sshc> @djinn a -> a
16:55:07 <lambdabot> f a = a
16:55:31 <benmachine> Boney: http://www.haskell.org/mailman/listinfo/beginners if you think it appropriate
16:55:32 <Boney> How does djinn know that.
16:55:43 <benmachine> Boney: because it's clever :P
16:55:48 <sshc> @djinn a -> (a -> b) -> (c -> b) -> b
16:55:48 <lambdabot> f a b _ = b a
16:55:49 <benmachine> know what, anyway?
16:55:51 <Boney> how does it know the intended semantics?
16:55:55 <benmachine> oh it doesn't
16:55:57 <benmachine> but
16:55:59 <sshc> How does djinn work?
16:56:05 <benmachine> there's only one total function of type a -> a
16:56:19 <benmachine> for more complex things, like my Maybe example, it just tries to use all the arguments
16:56:26 <benmachine> sshc: I'm not sure exactly, there's a paper on it
16:56:46 <benmachine>     Description:   Djinn uses an theorem prover for intuitionistic propositional
16:56:50 <benmachine>                    logic to generate a Haskell expression when given a type.
16:57:00 <benmachine> sshc: the homepage given is http://www.augustsson.net/Darcs/Djinn/
16:57:01 <Boney> hrm. clever.
16:57:21 <Boney> Anyway. the mailing list is what I want.
16:57:25 <monochrom> djinn just does propositional logic.
16:57:31 <Boney> Thanks.
16:58:01 <Boney> @djinn (a -> b) -> a -> b
16:58:01 <lambdabot> f a = a
16:58:14 <monochrom> it embarasses many a human that propositional logic is fully automatic
16:58:24 <Boney> @djinn (a -> b) -> b -> a
16:58:24 <lambdabot> -- f cannot be realized.
16:58:58 <Boney> @djinn (a -> b) -> [a] -> [b]
16:58:58 <lambdabot> Error: Undefined type []
16:59:32 <monochrom> djinn doesn't know any of the recursive types like lists, trees...
16:59:34 <benmachine> djinn only knows about non-recursive types, if I recall
16:59:40 <benmachine> er, yes, that
17:00:18 <Peaker> Would it be very hard to extend it to recursive types?
17:00:35 <benmachine> it would mean that the process was no longer guaranteed to terminate, I think
17:00:54 <benmachine> @djinn ((a -> r) -> r) -> (a -> (b -> r) -> r) -> (b -> r) -> r
17:00:54 <lambdabot> f a b c = a (\ d -> b d c)
17:00:55 <Saizan> if you want to define the halting problem in lambda calculus, the oracle h should take as input an encoding of the term or the term itself? or maybe it doesn't matter?
17:02:00 <monochrom> it is safe to always encode. avoids certain self-reference fallacies
17:02:07 <djahandarie> Djinn can do recursive types
17:02:24 <djahandarie> You just need to use a seperate file to define them with Fix
17:03:22 <djahandarie> Eg... data ListN a as = Nil | Cons a as; type List a = Fix (ListN a)
17:03:46 <Saizan> the question if is if it can prove theorems involving them then
17:04:04 <sshc> How do I find the month of a Day?
17:04:06 <djahandarie> It can find null
17:04:06 <Saizan> also, Fix is primitive? or do you have to define it?
17:04:12 <benmachine> sshc: toGregorian?
17:04:14 <djahandarie> I think it is primitive
17:04:30 <Saizan> @djinn-add data ListN a as = Nil | Cons a as
17:04:33 <sshc> benmachine: WHere is that?
17:04:41 <benmachine> sshc: Data.Time
17:04:49 <Saizan> @djinn Fix (ListN a) -> Bool
17:04:50 <lambdabot> Error: Undefined type Fix
17:04:57 <sshc> Ah, yes, thanks
17:05:03 <monochrom> @djinn ListN a b
17:05:04 <lambdabot> f = Nil
17:05:04 <sshc> Also I found it in Data.Time.Calendar
17:05:12 <benmachine> probably re-exported
17:05:46 <Saizan> @djinn-add data Fix f = In (f (Fix f))
17:05:46 <lambdabot> Error: Recursive types are not allowed: Fix
17:05:50 <monochrom> re-exported.
17:08:50 <djahandarie> Maybe this version of djinn is too old
17:09:07 <djahandarie> The one in the darcs repo supports them at least
17:12:55 <megajosh2> I can't get the Decimal package to build :./
17:12:59 <megajosh2>  `coarbitrary' is not a (visible) method of class `Arbitrary'
17:14:31 <benmachine> megajosh2: at a wild guess, using the wrong version of quickcheck
17:14:40 <benmachine> are you using Cabal to build it?
17:14:41 <megajosh2> Yeah
17:14:47 <megajosh2> In fact, cabal installed QuickCheck
17:14:47 <benmachine> either Setup.hs or cabal-install
17:14:53 <benmachine> oh ok
17:14:53 <megajosh2> cabal-install
17:15:01 <benmachine> then the dependencies on the package are probably wrong
17:15:01 <megajosh2> It's QuickCheck-2.3
17:15:04 <megajosh2> Hmm
17:15:09 <benmachine> cabal installed version 2.3?
17:15:12 <megajosh2> Yeah
17:15:14 <benmachine> hmm
17:15:22 <megajosh2> Just updated the package list from hackage and installed Decimal
17:15:24 <megajosh2> Gave me 2.3
17:15:41 <megajosh2> Decimal's dependencies don't specify a version for QuickCheck
17:15:47 <benmachine> mm
17:15:51 <benmachine> try specifying < 2
17:16:09 <megajosh2> Err... I honestly don't know how to do that
17:16:39 <megajosh2> You mean, just install another QuickCheck under version 2?
17:16:43 <benmachine> nah
17:16:49 <benmachine> hmm
17:16:57 <benmachine> right
17:17:21 <benmachine> if you do cabal unpack Decimal you should get a folder of the source for the package
17:17:25 <benmachine> Decimal-0.1.0
17:17:28 <benmachine> in your current directory
17:17:38 <benmachine> and then you need to edit the Decimal.cabal file inside
17:17:59 <benmachine> it contains the line
17:17:59 <benmachine> Build-Depends:      base, QuickCheck, HUnit
17:18:03 <benmachine> you want something like
17:18:07 <benmachine> Build-Depends:      base, QuickCheck < 2, HUnit
17:18:21 <megajosh2> Ah, okay
17:18:42 <benmachine> megajosh2: or if you're lazy, email the maintainer to whine :)
17:19:08 <benmachine> but since the package was last updated in 2008, good luck with that
17:19:30 <benmachine> actually if you were really keen, you could email the maintainer anyway
17:19:44 <benmachine> and if they don't respond in a week or so
17:19:45 <benmachine> umm
17:19:59 <Saizan> cabal install Decimal --constraint="QuickCheck < 2" should have the same effect
17:20:02 <benmachine> email haskell-cafe complaining that we haven't come up with a decent missing-maintainer policy yet >_>
17:20:11 <benmachine> yeah Saizan is cleverer than me
17:20:24 <MamboJUmbo> Hello folkz
17:20:24 <lambdabot> MamboJUmbo: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:20:32 <MamboJUmbo> ok
17:20:40 <megajosh2> Aliright, it compiled! Thanks
17:20:44 <megajosh2> ...*alright
17:20:52 <monochrom> oh hahaha, some days ago QuickCheck default was removed
17:21:25 <Saizan> yeah, i'm surprised it took so long :)
17:21:48 <Saizan> for the first such problem, i mean
17:22:24 <monochrom> well, 3 days is hardly long
17:22:49 <monochrom> also don't forget that everyone doesn't update hackage list
17:22:57 <Saizan> true
17:26:41 <Peaker> I wish there was a reasonable way to override over-specified or under-specified deps in some .cabal file on hackage
17:26:43 <aristid> DARCS SLOW!
17:27:05 <Peaker> I can manually install that package, but then every dependency installation attempt will fail because cabal-install will try to install the broken spec again
17:27:23 <Peaker> I can try to manually update the .tar cache of hackage, but that's so painful
17:27:27 <Saizan> Peaker: bump the version number when you manually install
17:27:58 <Peaker> Saizan, in a way that deps still agree with it, hmm, that might work
17:28:24 <Saizan> yeah, you can increment e.g. the fifth component
17:29:50 <Peaker> Saizan, thanks, that might save me much pain in the future :)
17:30:10 <monochrom> augmented fifth, diminished seventh
17:32:21 <darrint> What is the operator for integer division?
17:32:34 <tensorpudding> :t (/)
17:32:35 <lambdabot> forall a. (Fractional a) => a -> a -> a
17:32:49 <monochrom> div
17:33:02 <monochrom> > div 10 3
17:33:03 <lambdabot>   3
17:33:07 <darrint> thx
17:33:13 <monochrom> you can also write: 10 `div` 3
17:33:22 <Saizan> Peaker: np :)
17:33:57 * monochrom wonders why illiterate people bothers to reply
17:34:01 <c_wraith> > let (//) = div in 20 // 3
17:34:01 <lambdabot>   6
17:34:17 <megajosh2> > 1.4 - 1.5
17:34:17 <lambdabot>   -0.10000000000000009
17:34:35 <c_wraith> > 1.4 - 1.5 :: CReal
17:34:36 <lambdabot>   -0.1
17:34:41 <monochrom> <a> in [x+1 | x<-xs] what is <- ?  <b> do-notation, monad
17:34:43 <megajosh2> Hmm...
17:34:58 <monochrom> <a> how to do integer division?  <b> /
17:35:47 <c_wraith> megajosh2, floating point error is something you should learn about.  CReal is neat for experimentation, but it doesn't perform well
17:37:42 <monochrom> unfortunately the array modules also want to use //
17:37:56 <benmachine> floating point error is something you should learn to hate :)
17:38:13 <hpc> s/error // :P
17:38:19 <benmachine> :P
17:38:20 <Saizan> by being tortured in a numerical analysis class
17:38:27 <monochrom> http://floating-point-gui.de/
17:38:31 <benmachine> monochrom: illiterate people bothers? <_<
17:38:56 <monochrom> yeah, typo
17:39:09 <megajosh2> c_wraith: Oh, okay. I'm familiar with floating-point errors. That's why I was looking for a Decimal package
17:39:22 <megajosh2> Ran into some trouble because of that
17:39:26 <benmachine> I like Rational for dealing with non-integer values
17:39:29 <c_wraith> megajosh2, oh, ok.  CReal is not what you want, then. :)
17:39:33 <monochrom> a Decimal package will do poorly on 1/3
17:39:44 <monochrom> so you also need a Tenary package
17:39:54 <monochrom> ah, but both of them do poorly on 1/17
17:40:00 <c_wraith> Yeah, Rational is a good choice, unless you really need irrational values
17:40:23 <c_wraith> in which case, maybe you do need CReal :)
17:40:42 <benmachine> CReal does some odd things
17:40:45 <Saizan> there's Data.Fixed too
17:40:54 <benmachine> it says its equality operations diverge but as far as I can see they just lie instead
17:41:00 <benmachine> they check about 40 digits and then get bored
17:42:27 <monochrom> Data.(\F -> Let x = F x in x)ed
17:47:26 <monochrom> now I see what the "gui" in "floating-point-gui.de" is doing
17:49:07 <benmachine> hah
17:49:11 <benmachine> I wondered about that
17:53:37 <Peaker> > "tam dida tadam"
17:53:38 <lambdabot>   "tam dida tadam"
17:54:06 <hpc> > "badum tish"
17:54:07 <lambdabot>   "badum tish"
18:04:27 <pickles> two drums and a symbol fall off a cliff...
18:04:35 <pickles> *badum* *tssh*
18:08:15 <Chaze> hhm, what exactly is the reason that there is no stringSplit function?
18:08:31 <Chaze> Am I overlooking some function that can be used to easily implement it?
18:08:43 <Draconx|Laptop> what is this hypothetical "stringSplit" function supposed to do?
18:09:32 <Chaze> well, call it "splitAt sep list"
18:10:04 <Chaze> splitAt 0 [1,3,0,4] == [[1,3],[4]]
18:11:01 <Draconx|Laptop> > break (== 'l') "hello"
18:11:02 <lambdabot>   ("he","llo")
18:11:15 <Draconx|Laptop> > splitAt 2 "hello"
18:11:16 <lambdabot>   ("he","llo")
18:11:26 <pickles>  lawl, had just found that in my RWH book
18:11:29 <Draconx|Laptop> is it different from either of those?
18:11:32 <pickles> *break that is
18:13:54 <Chaze> erm, maybe my example was somewhat insufficient
18:14:03 <Chaze> i want to get a list, not just a pair
18:14:22 <Chaze> splitAt ',' "list,of,comma,seperated words"
18:14:49 <Draconx|Laptop> hint: splitAt is already a function that doesn't do that, so you might want to avoid using the name :)
18:14:59 <benmachine> splitOn?
18:15:04 <Chaze> ok, splitOn
18:15:28 <benmachine> are you overlooking some function that can be easily used to implement it, well
18:15:45 <benmachine> not easily, although it can be done quite briefly with unfoldr and break
18:16:00 <benmachine> see the split package on hackage
18:17:12 <cakoose> In Cabal, is there any way to specify a wildcard in "Exposed-Modules"?
18:17:25 <cakoose> I want to say "Just use everything in this directory and subdirectories."
18:17:43 <Chaze> heh, not what i call an easy implementation. but thanks, that's what i was looking for
18:17:44 <benmachine> :t \p -> unfoldr (\xs -> ap (<$) (guard . not null . snd) (break p xs))
18:17:45 <lambdabot>     Couldn't match expected type `Bool'
18:17:45 <lambdabot>            against inferred type `[a] -> Bool'
18:17:45 <lambdabot>     In the first argument of `not', namely `null'
18:17:51 <benmachine> :t \p -> unfoldr (\xs -> ap (<$) (guard . not . null . snd) (break p xs))
18:17:52 <lambdabot> forall a. (a -> Bool) -> [a] -> [[a]]
18:18:00 <Chaze> oh wow
18:18:06 <benmachine> I don't know if that's right
18:18:10 <benmachine> oh it isn't
18:18:15 <benmachine> I need a drop 1 in there somewhere
18:18:58 <Draconx|Laptop> (fmap (drop 1) . break p xs) should do.
18:19:07 <Draconx|Laptop> er, $ not .
18:19:08 <benmachine> (\p -> unfoldr (second (drop 1) . ap (<$) (guard . not . null . snd) . break p)) (== 0) [1,2,3,0,3,4,0,5,6,7]
18:19:13 <benmachine> > (\p -> unfoldr (second (drop 1) . ap (<$) (guard . not . null . snd) . break p)) (== 0) [1,2,3,0,3,4,0,5,6,7]
18:19:14 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a, b)'
18:19:14 <lambdabot>         against infe...
18:19:23 <benmachine> damn it
18:19:37 <benmachine> need to fmap the second
18:19:44 <benmachine> > (\p -> unfoldr (fmap (second (drop 1)) . ap (<$) (guard . not . null . snd) . break p)) (== 0) [1,2,3,0,3,4,0,5,6,7]
18:19:45 <lambdabot>   [[1,2,3],[3,4]]
18:19:50 <benmachine> damn it twice
18:19:51 <Draconx|Laptop> fmap _does_ fmap the second.
18:20:11 <benmachine> Draconx|Laptop: well, I'd need to fmap the fmap, then
18:20:19 <benmachine> it's a Maybe ([a], [a])
18:20:27 <Draconx|Laptop> > fmap (drop 1) breap (==',') "list,of,words"
18:20:28 <lambdabot>   Not in scope: `breap'
18:20:31 <Draconx|Laptop> > fmap (drop 1) break (==',') "list,of,words"
18:20:32 <lambdabot>   Couldn't match expected type `t1 -> t' against inferred type `[a]'
18:20:40 <Draconx|Laptop> > fmap (drop 1) $ break (==',') "list,of,words"
18:20:41 <lambdabot>   ("list","of,words")
18:20:42 <Draconx|Laptop> (I suck)
18:21:03 <megajosh2> You're trying to make something like Perl's split?
18:21:05 <benmachine> oh I could do it at the front
18:21:12 <benmachine> megajosh2: something like that, yeah
18:21:13 <Chaze> :t fmap
18:21:14 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
18:21:36 <benmachine> > (\p -> unfoldr (ap (<$) (guard . not . null . fst) . second (drop 1) . break p)) (== 0) [1,2,3,0,3,4,0,5,6,7]
18:21:37 <lambdabot>   [[1,2,3],[3,4],[5,6,7]]
18:21:40 <benmachine> yessss
18:22:26 <benmachine> > (((unfoldr (ap (<$) (guard . not . null . fst) . second (drop 1)) .) . break)) (== 0) [1,2,3,0,3,4,0,5,6,7]
18:22:27 <lambdabot>   Couldn't match expected type `[a]'
18:22:27 <lambdabot>         against inferred type `([a1], [a...
18:22:30 <benmachine> bugger it
18:23:18 <megajosh2> :t (<$)
18:23:19 <lambdabot> forall a (f :: * -> *) b. (Functor f) => a -> f b -> f a
18:26:12 <objorn> I'm thinking that I will learn Haskell before tackling SICP.
18:26:19 <nejucomo> I keep getting confused about "wrapped" monads.  Say I have an: foo :: IO (Maybe t)
18:26:25 <nejucomo> I want to do something like:
18:26:32 <nejucomo> do mt <- foo
18:27:00 <nejucomo> Oh, nevermind.  I just figured it out.
18:27:01 <nejucomo> :-)
18:27:26 <benmachine> @pl (\p -> unfoldr (ap (<$) (guard . not . null . fst) . second (drop 1) . break p))
18:27:26 <lambdabot> unfoldr . ((ap (<$) (guard . not . null . fst) . second (drop 1)) .) . break
18:29:32 <megajosh2> > return () :: [a]
18:29:33 <lambdabot>   Couldn't match expected type `a' against inferred type `()'
18:29:33 <lambdabot>    `a' is a rig...
18:29:36 <megajosh2> > return () :: [Int]
18:29:37 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
18:29:37 <lambdabot>         against inferred type ...
18:29:54 <nejucomo> No I didn't figure it out.  Here's the code I've just written: http://codepad.org/OJIYL36t
18:30:07 <nejucomo> Now, can I use the Maybe Monad to make it flatter and cleaner?
18:31:06 * nejucomo looks up the do-syntax translation...
18:31:59 <EvanR> you Just do it
18:32:45 <megajosh2> @src Maybe (>>=)
18:32:46 <lambdabot> (Just x) >>= k      = k x
18:32:46 <lambdabot> Nothing  >>= _      = Nothing
18:32:48 <benmachine> nejucomo: it's unusual to put "of" on a new line
18:33:32 <benmachine> it does look like the Maybe monad could help you a little
18:33:33 <nejucomo> I prefer to do so, otherwise my code becomes extremely indented.  (I'm a big fan of deeply nested where-clauses.)
18:33:39 <benmachine> or perhaps MaybeT
18:34:07 <nejucomo> megajosh2: I understand the Maybe Monad's operation, but I'm confused about the do-syntax translation and how that ties into the type system.
18:34:19 <benmachine> nejucomo: it's more usual to put it after the of, is what I meant
18:34:26 <benmachine> one sec I'll paste what I mean
18:34:42 <nejucomo> benmachine: Oh, I see.
18:34:43 <megajosh2> Hmm...
18:34:48 <megajosh2> Lemme think here
18:36:01 <nejucomo> do { a <- f; b <- g a; return b; } -becomes- f >>= (\a -> g a >>= (\b -> return b))  -right?
18:36:23 <hpc> yes
18:36:30 <benmachine> nejucomo: I know this isn't really what you asked for, but http://codepad.org/YZClPt2E is how I'd indent it
18:36:46 <nejucomo> I could write my own monad instance for IO (Maybe t), but that seems a bit excessive.
18:36:47 <benmachine> the Maybe monad can help you a little here
18:37:01 <benmachine> the MaybeT monad transformer is effectively that
18:37:03 <benmachine> @hackage MaybeT
18:37:04 <lambdabot> http://hackage.haskell.org/package/MaybeT
18:37:16 <benmachine> see also http://hackage.haskell.org/package/MaybeT-transformers
18:38:08 <nejucomo> Ah, the of\n style is much better.  I preferred \nof naturally, but it breaks in do syntax.
18:38:14 <nejucomo> Thanks for the ref.
18:38:42 <benmachine> nejucomo: the thing that jars me about \nof is that it means the first pattern looks different from all the others
18:39:21 <benmachine> nejucomo: you realise you're missing a Nothing pattern for the second case?
18:39:27 <nejucomo> Sure.  But of\n can make of look like an argument.  Not important with syntax highlighting, though.
18:39:31 <nejucomo> Yes.
18:39:39 <nejucomo> I haven't actually tried compiling this thing!  :-)
18:39:59 <benmachine> heh okay
18:40:13 <nejucomo> I've been doing type design thrashing on this module a bit…  Keep shuffling type definitions around to see how it affects semantics and clarity.
18:40:19 <benmachine> I was lying before this is how I'd actually indent it http://codepad.org/CN9oiN3Y
18:40:41 <benmachine> can I assume the Nothing branch of that case ends with return Nothing?
18:40:48 <benmachine> if so then normal Maybe can help a little
18:43:00 <benmachine> nejucomo: http://codepad.org/kZEqR5el here's a slightly condensed version
18:43:32 <benmachine> eer wait
18:43:36 <benmachine> that won't work, sorry
18:43:50 <nejucomo> There's a subtle bug because I shadow iter.
18:43:54 <benmachine> yeah
18:43:55 <nejucomo> I'm going to rename it.
18:44:03 <benmachine> you shadow iter and I don't :(
18:44:11 <benmachine> hmm
18:45:04 * benmachine wonders how to easily do (a -> b) -> Maybe (a, c) -> Maybe (b, c)
18:45:18 <benmachine> oh, a -> Maybe b in fact
18:45:18 <nejucomo> Also, I have the wrong type in mind for matchPat which performs IO.  :-/
18:45:24 <benmachine> oh ok
18:45:30 <dolio> @type fmap . first
18:45:31 <lambdabot> forall (f :: * -> *) b c d. (Functor f) => (b -> c) -> f (b, d) -> f (c, d)
18:45:44 <benmachine> in which case the only useful thing I did was turn your last case into an fmap
18:46:05 <benmachine> dolio: neat, thanks
18:46:25 <benmachine> nejucomo: basically my thinking was, both branches of this case start with return
18:46:30 <benmachine> so I can move the return out of the case entirely
18:46:41 <benmachine> then I have a case with a Nothing -> Nothing branch
18:46:58 <benmachine> this smells fmappy to me
18:47:11 <benmachine> (are you familiar with how fmap works with Maybe?)
18:47:36 <Peaker> benmachine, SEC's
18:47:44 <Peaker> @where SEC
18:47:45 <lambdabot> http://conal.net/blog/posts/semantic-editor-combinators/
18:47:49 <benmachine> Peaker: yeah I know :) I just tend to forget them
18:48:00 <benmachine> nejucomo: the 'maybe' function, and fromMaybe, and fmap, and =<<, mean it's quite rare for you to actually need to case-match on a Maybe value
18:48:02 <nejucomo> benmachine: Yeah.
18:48:08 <megajosh2> > (
18:48:09 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
18:48:10 <megajosh2> ...
18:48:11 <benmachine> although often it will make things clearer
18:48:27 <Peaker> I see pattern-matching as a low-level feature :)
18:48:35 <megajosh2> > (\a b -> pure a <*> b) (+1) Maybe (2,3)
18:48:36 <lambdabot>   Not in scope: data constructor `Maybe'
18:48:40 <megajosh2> > (\a b -> pure a <*> b) (+1) Just (2,3)
18:48:40 <Peaker> higher-order functions take care of it for me :)
18:48:41 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe (t, t1)))
18:48:41 <lambdabot>    arising from a ...
18:48:51 <megajosh2> lol Maybe as a type constructor
18:49:05 <Peaker> megajosh2, as a data constructor
18:49:08 <Peaker> (I think you meant)
18:49:10 <megajosh2> Yeah
18:49:20 <benmachine> Maybe *is* a type constructor >_>
18:49:28 <nejucomo> The problem is, in my example paste I thought matchPat resulted in a Maybe [Binding], but it results in (something like) IO (Maybe [Binding])
18:49:34 <Peaker> If we had a good IDE that highlighted the difference between value and type contexts, it would make it so much easier for beginners
18:50:00 <Peaker> nejucomo, what's the problem? Just use it via fmap or (=<<)
18:50:17 <benmachine> nejucomo: looks more and more like a job for MaybeT :)
18:50:35 <nejucomo> Ok, so I'll fmaps within fmaps.  I'll start translating from the branch cases and work my way up.
18:51:50 <benmachine> fmap only applies wher eyou have a Nothing -> Nothing branch, remember
18:52:15 <nejucomo> No, it also applies to IO.  :-)
18:52:37 <nejucomo> That's the source of the difficulty for me:  I have IO (Maybe t) in some places and IO t in others.
18:53:11 <nejucomo> Except, actually it's not IO, but ExOp, which is newtype ExOp t = ExOp (IO (Exceptional t))
18:53:13 <nejucomo> :-)
18:53:28 <nejucomo> I already solved this problem for the IO / Exceptional interaction with a Monad instance.
18:54:39 <nejucomo> Gotta run.
18:54:43 <nejucomo> Thanks for the feedback.
19:16:17 <pickles> > hi
19:16:18 <lambdabot>   Not in scope: `hi'
19:16:24 <pickles> hm
19:16:46 <pickles> > say
19:16:47 <lambdabot>   Not in scope: `say'
19:17:04 <pickles> is it possible to pm lambdabot commands?
19:18:36 <pickles> :let hi = "hi"
19:20:23 <EvanCarroll> is there an average function that can work on Double's
19:21:14 <copumpkin> EvanCarroll: http://hackage.haskell.org/package/statistics
19:21:48 <monochrom> yes, you can just pm lambdabot
19:22:09 <pickles> how do i get it to run a "let..." clause
19:22:26 <monochrom> there is no let clause
19:22:46 <pickles> * how do i get it to run: let hi = "hi"
19:22:56 <copumpkin> @let hi = "hi"
19:22:57 <rschnck> Would this be considered poor code? http://codepaste.net/darapm
19:22:58 <lambdabot>  Defined.
19:22:59 <monochrom> cannot
19:23:07 <pickles> hm
19:23:11 <pickles> it wouldn't do that in pm
19:23:15 <copumpkin> it would
19:23:16 <rschnck> The goal was to make an intersect function that models the intersection of two sequences (where we use lists instead of sequences)
19:23:26 <rschnck> and I was lazy...and just implemented a bunch of old functions I wrote
19:23:33 <pickles> ah, musta typed it wrong
19:23:50 <pickles> aha, it didnt liek the space
19:24:03 <pickles> >there
19:24:22 <pickles> > there
19:24:23 <lambdabot>   "there"
19:24:28 <pickles> hm, seems to be picky about spaces
19:24:33 <ezyang> Is it just me, or does most subtyping literature focus on product types (record types) instead of sum types? 
19:25:02 <monochrom> because it uses a monospace font
19:25:23 <pickles> ah
19:25:33 <pickles> hm...
19:25:44 <monochrom> all of you programmer types use monospace fonts for irc, don't you?
19:26:01 * ezyang raises his hand 
19:26:22 <monochrom> hell, you use terminals for irc
19:26:22 * pickles isn't :(
19:26:34 * pickles is using pidgin...
19:26:34 <monochrom> @quote 1970s.terminals
19:26:34 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
19:26:42 <pickles> does that mean im not a programmer type?
19:26:44 <rschnck> irssi > pidgin
19:27:29 <copumpkin> no, I use proportional fonts for IRC
19:27:40 <pickles> rschnck: i'll have to check that out
19:27:41 <copumpkin> (AND proportional fonts for my terminals and code!!)
19:27:50 <monochrom> I use proportional fonts for irc too. I just want to mock programmers.
19:27:55 <copumpkin> (okay, just kidding about the latter)
19:28:08 <rschnck> I use monospace for IRC :<
19:28:17 <copumpkin> rschnck: YOU LOSE
19:28:18 <rschnck> And I don't really program/know anything.
19:28:31 <monochrom> their monospace fonts and their 1970s terminals and their 1980s irssi
19:28:39 <EvanCarroll> copumpkin: more direction?
19:28:41 <notabel> copumpkin: i've used proportional fonts for my shell
19:28:44 <EvanCarroll> which oneof those modules
19:28:45 <notabel> but never for terminal apps
19:28:46 <rschnck> copumpkin: Well in that case, take a look at my code: http://codepaste.net/darapm
19:28:50 * copumpkin confiscates rschnck's typography license
19:28:53 <rschnck> :<
19:29:05 <pickles> i don't think he had one
19:29:10 <pickles> he was typing w/o a liscense!
19:29:17 <EvanCarroll> normalDistr?
19:29:20 <copumpkin> damn
19:29:20 <EvanCarroll> that's haskell's average
19:29:25 <rschnck> Oh gawd
19:29:31 <EvanCarroll> Mean of distribution
19:29:33 <Saizan> fun that in 30 years they couldn't write a better irc client
19:29:35 <EvanCarroll> I suppose...
19:29:50 <wli> IRC isn't 30 years old.
19:29:51 <copumpkin> rschnck: it's not exactly what I'd call idiomatic
19:29:55 <pickles> a better irc client? hell, look at how long it took them to get a better mouse trap!
19:30:05 <copumpkin> rschnck: in your removeAll, use pattern matching instead of head/tail
19:30:15 <rschnck> copumpkin: Is it "bad"? I was lazy and didn't want to write a ton of new functions...and the goal aws to write the intersect one
19:30:16 <ezyang> I guess the type people aren't online right now... 
19:30:24 <monochrom> well they think irssi is already the better irc client
19:30:26 <rschnck> so I just sort of...mumbled all those together to get an intersect function
19:30:29 <rschnck> Is that "bad" programming?
19:30:46 <copumpkin> rschnck: not bad, but "could be more haskelly"
19:31:00 <copumpkin> intersectHelper((removeDuplicates((x:xs)) ++ removeDuplicates((y:ys))))
19:31:01 <pickles> ttg, nite all
19:31:04 <benmachine> irssi is surprisingly shoddy imo
19:31:05 <pickles> > say goodnight gracy
19:31:06 <lambdabot>   "goodnight gracy"
19:31:07 <benmachine> but I still use it
19:31:07 <copumpkin> lots of parentheses there
19:31:08 <rschnck> Any tips on writing a more...haskelly intersect function?
19:31:14 <rschnck> copumpkin: Yeah, I noticed. I already fixed it.
19:31:26 <copumpkin> rschnck: why pattern match on (x:xs) there if you never use them independently?
19:31:40 <copumpkin> rschnck: but the only issues I'm pointing out are minor style ones :)
19:31:50 <rschnck> copumpkin: Because when I first set out to write it I have no idea waht I'm going to do, so it's just the result of prior thinking
19:31:59 <lispy> lists do not make good sets.
19:32:02 <rschnck> I usually go back and remove any extra"ness"
19:32:13 <copumpkin> rschnck: the logic in intersectHelper is a little suspicious though :)
19:32:23 <rschnck> copumpkin: The >= 2 bit :P?
19:32:35 <rschnck> It seems like such a gimmick
19:32:54 <rschnck> Just remove any duplicates, join 'em together, and if there's two of a single element, that's in the intersection.
19:33:21 <benmachine> rschnck: count x (x:xs) would be count x xs + 1, right?
19:34:01 <lispy> rschnck: in expressions like this: intersectHelper (xs), the parens look funny to experienced haskellers :)
19:34:04 <rschnck> benmachine: Yes
19:34:25 <dolio> (3) + (2)
19:34:34 <rschnck> lispy: I'll tidy it up..I know...I'm not exactly the epitome of a haskeller.
19:34:49 <rschnck> And I'm rather bad at it.
19:34:58 <rschnck> But I'm not asking abotu formatting
19:35:02 <rschnck> I'm asking if the method used
19:35:04 <rschnck> Is a decent one
19:35:08 <rschnck> It seems gimmicky to me.
19:35:44 <lispy> rschnck: another way to implement intersection would be to use elem and check each element for membership in both sets (well, really lists)
19:37:01 <rschnck> lispy: so you'd take the head, run through the second list, and if it's in it, have it "store" that number in some sort of tail recursion?
19:37:03 <lispy> intersection xs ys = filter (\x -> x `elem` xs && x `elem` ys) (xs ++ ys) -- something like this (untested)
19:37:16 <rschnck> I'm not allowed to use filter.
19:37:19 <rschnck> Never heard of it either
19:37:26 <benmachine> rschnck: not allowed?
19:37:27 <rschnck> can't use \ or -> either :P
19:37:35 <rschnck> We have functions we're restricted to
19:37:39 <benmachine> ah
19:37:43 <rschnck> Well
19:37:43 <benmachine> but you can define your own?
19:37:46 <rschnck> if I defined it myself I can use it
19:37:46 <rschnck> Yeah.
19:37:50 <lispy> \ and -> are syntax for lambdas.  You can use them I'm sure.
19:38:14 <rschnck> both \ and -> are greek lambdas o.O?
19:38:21 <benmachine> or you can do filter p (xs ++ ys) where p x = ...
19:38:26 <benmachine> no
19:38:41 <monochrom> \ is ascii art for λ
19:38:42 <benmachine> an anonymous function (\x -> stuff with x) is called a lambda abstraction
19:38:45 <lispy> (my version would leave you with duplicates, BTW)
19:38:48 <benmachine> or a lambda more usually
19:38:54 <EvanCarroll> copumpkin++ # very cool man
19:39:03 <EvanCarroll> I'm almost done writing my first Haskell program
19:39:09 <EvanCarroll> very cool.
19:39:35 <rschnck> OH
19:39:47 <rschnck> Well, I'll look into the lambda stuff.
19:39:56 <benmachine> rschnck: it's just a convenience
19:40:06 <monochrom> in python it's lambda x: return stuff with x
19:40:15 <benmachine> rschnck: does order of the output list matter?
19:40:20 <EvanCarroll> does haskell support a mutable vector
19:40:22 <rschnck> benmachine: No.
19:40:25 <benmachine> rschnck: and you only need to intersect [Int]?
19:40:28 <rschnck> benmachine: It's a set, so we don't care
19:40:29 <lispy> EvanCarroll: yes, several
19:40:35 <rschnck> benmachine: Yes.
19:40:54 <lispy> EvanCarroll: STUArray, IOUArray, STArray, IOArray, Data.Vector, Data.UVector (to name a few)
19:41:09 <benmachine> rschnck: I think you might find it easier if you sorted the lists first
19:41:19 <benmachine> just a thought
19:41:20 <lispy> EvanCarroll: if you're still learning haskell you might want to avoid them for now
19:41:30 <EvanCarroll> I don't think I know enough to finish this program I want to write =(
19:41:33 <EvanCarroll> bleh
19:41:57 <benmachine> EvanCarroll: is it awesome?
19:42:03 <copumpkin> not UVector
19:42:06 <copumpkin> it be deprecated!
19:42:10 <EvanCarroll> I want to loop over appending an element to an array, and then printing toout the average of the array
19:42:16 <monochrom> every unfinished program is awesome
19:42:32 <benmachine> EvanCarroll: do you actually need the whole array afterwards?
19:42:33 <EvanCarroll> It is to display the average BPM of char-entry
19:42:36 <EvanCarroll> yes.
19:42:51 <benmachine> char-entry hmm
19:43:12 <EvanCarroll> the array is of the beat-length
19:43:26 <EvanCarroll> http://www.all8.com/tools/bpm.htm
19:43:28 <EvanCarroll> just like that
19:43:33 <monochrom> not sure if it has to be an array
19:43:50 <Saizan> sounds like you should use Data.Map
19:43:51 <xplat> if you don't need to make random access until the end and you won't be collecting 500,000 samples i would collect as a list first and then turn it into an array if i were you
19:43:55 <lispy> sounds like a stream processing task to me
19:44:01 <monochrom> I understand that c types ask for array because that is the only data structure they know
19:44:43 <xplat> appending to arrays is slow
19:44:45 <lispy> Saizan: oh yeah, that's true
19:45:11 <lispy> Ord a => [a] -> Map a Int
19:45:48 <Axman6> Am i the only one who wishes that where was renamed to with, so that it makes tabs work more nicely (not \t tabs, but spaces as tabs tabs)
19:46:06 <Axman6> @pl (\v s -> v + min x s)
19:46:06 <lambdabot> (. min x) . (+)
19:46:26 <monochrom> why does "with" work with your spaces more nicely?
19:46:33 <xplat> hey guys what is the best database access library for haskell with PostgreSQL support which lets you use custom functions easily?
19:46:40 <Axman6> because it's 4 characters. though i guess that still isn'
19:46:52 <Axman6> t nice, if it were 3 characters it would be better
19:47:01 <monochrom> > even (length "where ")
19:47:02 <lambdabot>   True
19:47:08 <monochrom> At least that's even
19:47:09 <Saizan> go to a new line after where
19:47:16 <Axman6> monochrom: but who uses tabs = 6 spaces?
19:47:23 <EvanCarroll> this is something like what I've got http://github.com/EvanCarroll/haskell-tap-bpm/blob/master/tapbpm.hs
19:47:25 <monochrom> I sometimes do.
19:47:41 <monochrom> call it "3 tabs" if you like
19:48:00 <EvanCarroll> I want to getBeatLength in a loop, appending the result to an array and thn printing the average of it
19:48:26 <xplat> EvanCarroll: again why an array?
19:48:41 <EvanCarroll> xplat: not an array, a Data.Vector
19:48:56 <EvanCarroll> because that's what Statistics.Sample.mean takes
19:48:57 <lispy> xplat: Have you tried takusen?
19:48:57 <benmachine> cabal files don't support any kind of else if, do they?
19:49:06 <benmachine> apart from just an if in an else block
19:49:07 <EvanCarroll> I don't even know what Data.Vector is
19:49:24 <lispy> xplat: I haven't tried using custom functions, but it should work great
19:50:24 <EvanCarroll> anyway I'm heading out, I'll try this again later
19:50:30 <lispy> xplat: http://projects.haskell.org/takusen/
19:50:45 <jahnke> Sup, guys. Is there someone from Brazil here?
19:59:48 <xplat> lispy: hm, takusen doesn't look bad, thanks.  and i have to respect a db interface that supports postgres but not mysql.  :)
20:00:16 * hackagebot Hipmunk 5.2.0 - A Haskell binding for Chipmunk.  http://hackage.haskell.org/package/Hipmunk-5.2.0 (FelipeLessa)
20:00:18 * hackagebot HipmunkPlayground 5.2.0 - A playground for testing Hipmunk.  http://hackage.haskell.org/package/HipmunkPlayground-5.2.0 (FelipeLessa)
20:02:12 <notabel> huh.  i wonder if this package or steve and alexis's new project has an older claim on that name
20:02:17 <notabel> the package, apparently
20:08:54 <roconnor> @faq can haskell find a flight for me to paris?
20:08:54 <lambdabot> The answer is: Yes! Haskell can do that.
20:09:13 <monochrom> just implement dijkstra's algorithm
20:12:41 <ManateeLazyCat> juhp_: Hey.
20:12:51 <juhp_> ManateeLazyCat: hi
20:13:14 <ManateeLazyCat> juhp_: You can fetch newest version, now irc client can use .
20:13:38 <ManateeLazyCat> juhp_: You need upgrade package 'gtksourceview' first.
20:13:40 <juhp_> ManateeLazyCat: I will try to play with manatee again over weekend :)
20:14:05 <juhp_> ManateeLazyCat: spent most of my haskell time recently on fedora packaging and issues
20:14:09 <ManateeLazyCat> juhp_: http://www.flickr.com/photos/48809572@N02/4996012816/lightbox/
20:14:20 <ManateeLazyCat> juhp_: Now have support most message.
20:14:37 <ManateeLazyCat> juhp_: I will finish color message today, include different type message and different nick name.
20:15:34 <juhp_> cool
20:15:41 <ManateeLazyCat> juhp_: Then add /*** action, private talk, multiple-language translate, and popup window notify.
20:15:51 <juhp_> :)
20:16:08 <ManateeLazyCat> juhp_: BTW, i found VTE support pty as backend process, haven't try. 
20:16:29 <ManateeLazyCat> juhp_: If it can work, maybe support MVC design, then i can integrate vte terminal in manatee.
20:17:00 <ManateeLazyCat> juhp_: gio-branch has merge in gtk2hs, now you just need darcs gtk2hs, no need more.
20:17:05 <juhp_> aha
20:17:21 <juhp_> ManateeLazyCat: cool - I noticed your repo gone
20:17:41 <ManateeLazyCat> juhp_: Because still has some encoding issue haven't fix in gio function, so i can't release it now.
20:17:43 <juhp_> will there be a release soon?
20:17:47 <juhp_> ok
20:18:11 <tommd> @faq can Haskell do what Haskell can't do?
20:18:11 <lambdabot> The answer is: Yes! Haskell can do that.
20:18:29 <juhp_> Agda? :)
20:18:37 <ManateeLazyCat> juhp_: Maybe i need binding text-icu first, then test "automatic encoding detect" module test whether can work.
20:18:53 <ManateeLazyCat> juhp_: If work, i will replace some gio functions with ByteString to release new version.
20:19:32 <juhp_> okay - maybe it can wait to later though?
20:19:40 <monochrom> automatic encoding detection does not work. iso-latin1 and utf-8 look too similar
20:19:55 <ManateeLazyCat> juhp_: Sorry, i'm so busy, i have many higher priority todo need finish.
20:20:06 <ManateeLazyCat> monochrom: But have one better than nothing.
20:20:10 <juhp_> right
20:20:37 <ManateeLazyCat> juhp_: If you always use gtk2hs darcs, it's not big problem to use mantee. :)
20:20:38 <juhp_> I think utf8 is enough initially
20:21:04 <ManateeLazyCat> juhp_: Now my irc client just support utf-8 and assci.
20:21:13 <juhp_> :)
20:21:19 <monochrom> you say "better than nothing" because you think it can work with probability 50%. but it fails with probability 100%.
20:21:25 <ManateeLazyCat> juhp_: Do you notice right of http://www.flickr.com/photos/48809572@N02/4996012816/lightbox/ ?
20:22:05 <ManateeLazyCat> monochrom: Example, when you handle unknown encoding file in file-manager? How you to do that?
20:22:20 <monochrom> xchat is an example. it has "hybrid" which means "auto-detect iso-latin1 vs utf-8". when you give it utf-8, it guesses iso-latin-1 100% of the time.
20:23:15 <ManateeLazyCat> monochrom: I think "automatic encoding detect" better than guess eyeless...
20:23:30 <monochrom> I see that you still think that.
20:23:38 <ManateeLazyCat> monochrom: Better idea?
20:24:15 <monochrom> guess eyeless is better than auto-detect. guess eyeless: 50% error rate. auto-detect: 100% error rate
20:24:41 <juhp_> ManateeLazyCat: nice
20:24:46 <ManateeLazyCat> monochrom: Question is how to guess?
20:25:15 <ManateeLazyCat> juhp_: You can find new demo LineNumber.hs in package 'gtksourceview-0.12.1'
20:25:33 <juhp_> ok
20:25:36 <monochrom> I understand that as a programmer it is hard to accept that a fellow programmer's hard work can be worse than tossing coins. "he/she worked so hard on this, it has 1000 lines of code, surely worths something..."
20:25:37 <ManateeLazyCat> juhp_: Use SourceGutter APIs, we don't need insert TimeStamp in TextBuffer, then less bugs.
20:25:44 <juhp_> ManateeLazyCat: gtk is next in queue for fedora...
20:26:56 <ManateeLazyCat> monochrom: If you have best solution just need 1 line, i want use . :)
20:27:16 <monochrom> toss a coin. head->utf-8, tail->iso-latin-1
20:27:34 <ManateeLazyCat> monochrom: Yes, gedit use that way, and works well.
20:27:44 <ManateeLazyCat> monochrom: Maybe i need mix those two way.
20:27:47 <monochrom> toss a coin. head->utf-8. tail->utf-8.
20:28:02 <ManateeLazyCat> monochrom: Guess some encoding list first, if failed, then use "automatic detect"...
20:28:59 <ManateeLazyCat> monochrom: Gedit build a encoding list, when it got some unknown string, it will loop this list to try until some encoding success.
20:29:33 <ManateeLazyCat> monochrom: Thanks for your suggestion, i will consider it. :)
20:29:44 <monochrom> iso-latin-1 always succeeds. this is why detection is so broken.
20:30:13 <ezyang> monochrom: But UTF-8 doesn't always succeed. 
20:30:31 <ManateeLazyCat> monochrom: So put iso-lation-1 at last.
20:30:32 <ezyang> also the high byte distributions are different, iirc. 
20:31:02 <Entroacceptor> try to convert it to utf8, then google for it. whatever gets more hits is correct
20:31:33 <ManateeLazyCat> Entroacceptor: Network test need more time. :)
20:31:57 <ezyang> I think html5 has an algorithm for character encoding detection 
20:32:00 * ezyang goes looks for it 
20:32:32 <roconnor> @type \f -> liftM2 (flip f)
20:32:33 <lambdabot> forall a2 a1 r (m :: * -> *). (Monad m) => (a2 -> a1 -> r) -> m a1 -> m a2 -> m r
20:32:37 <ManateeLazyCat> ezyang: AFAIK, there have two library for that: 'icu' and 'python-chardect'
20:32:43 <roconnor> @type \f -> flip (liftM2 f)
20:32:44 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a2 -> m a1 -> m r
20:33:13 <ezyang> http://dev.w3.org/html5/spec/Overview.html#determining-the-character-encoding 
20:33:16 <ManateeLazyCat> ezyang: I guess html5's silimar 'python-chardetect' 's algorithm. :)
20:33:51 <monochrom> show the user several windows. one window has "好", another window has "å¥½", etc. let the user say which one is right. now you know the right encoding.
20:33:54 <ezyang> enh, unless python-chardetect is in html5lib, I doubt they're exactly the same. 
20:34:07 <ezyang> But yeah. :-) 
20:34:11 <Veinor> @src flip
20:34:12 <lambdabot> flip f x y = f y x
20:35:32 <ManateeLazyCat> monochrom: If have two result are garbled, then you waste user's time.
20:35:36 <ManateeLazyCat> :)
20:36:13 <monochrom> why?
20:36:57 <ManateeLazyCat> monochrom: Example, two result are wrong : å¥½ ½å¥, then user choose which since both are wrong?
20:37:04 <Cale> Obviously the intended text is small a with ring above, Yen symbol, 1/2
20:37:18 <Cale> ;)
20:37:28 <monochrom> then both are wrong. it happens. perhaps the sender is tricking the user.
20:38:50 <ManateeLazyCat> monochrom: So it's not perfect way to decode string 100% accurate ... :)
20:39:24 <ManateeLazyCat> monochrom: We can do is try to guess for user.
20:39:31 <monochrom> Have you heard this joke? "but Mr Babbage, if I enter wrong figures into this machine, can it still produce the right answer?"
20:39:50 <ManateeLazyCat> monochrom: Yeah. :)
20:40:19 <ManateeLazyCat> monochrom: Answer is : "You're stupid?". lol :)
20:40:26 <monochrom> if the incoming data is really invalid, which one wastes more of the user's time?  (A) pretend it is valid, fuck up later.  (B) with the help of the user, discover that it is invalid early.
20:41:54 <ManateeLazyCat> monochrom: Well, i'm not mean "pretend it is valid" since i haven't coding it, just discuss to find best way to handle those. :)
20:43:28 <monochrom> so you shouldn't guess. guess = pretend it's valid.  complete equivalence.
20:43:39 <Saizan> decode as utf8, if it fails send ninjas against the sender.
20:44:04 <ManateeLazyCat> monochrom: I give up... 
20:48:01 <monochrom> It is interesting to observe how programmers unconditionally believe that writing more code is unconditionally better for society.
20:48:19 <kaol> which programmers?
20:48:33 <Tezeract> it depends of what kind of code
20:48:39 <monochrom> the programmers I have just conversed with.
20:52:44 <Chaze> i always feel like i end up writing too many (ugly) conditionals like "if inc then val + 1 else val". it doesn't look like haskell. is there any tutorial on how to get rid of this style?
20:53:16 <copumpkin> Chaze: guards, write yourself a bool :: a -> a -> Bool -> a function, or find out how to avoid Bools in the first place
20:53:17 <monochrom> it looks like haskell to me. I do that all the time.
20:53:35 <ManateeLazyCat> Chaze: | inc = val + 1 | otherwise = val
20:54:12 * copumpkin isn't a big fan of bools, most of the time
20:54:38 <Chaze> yeah, i want to get rid of programming with booleans entirely
20:54:51 <copumpkin> often Maybe can be viewed as a more descriptive boolean
20:55:03 <tommd> And Either is a more descriptive Maybe.
20:55:12 <copumpkin> in dependent types you have an even more descriptive boolean
20:55:24 <monochrom> why do you want to get rid of programming with booleans entirely?
20:55:27 <copumpkin> but it probably isn't very useful here :)
20:57:14 <Chaze> monochrom: probably for the same reason i want to get rid of iterations. bools often seem like a detour to the essence of an algorithm
20:58:02 <copumpkin> I agree in many cases
20:58:09 <copumpkin> I wouldn't get rid of them altogether though
20:58:29 <copumpkin> it's a bit like array indices
20:58:44 <copumpkin> they're necessary for many things but get in the way of elegant descriptions
20:59:05 <Chaze> yeah, i'd sign that
21:01:39 * hackagebot shell-escape 0.0.0 - Shell escaping library.  http://hackage.haskell.org/package/shell-escape-0.0.0 (JasonDusek)
21:03:59 <monochrom> bool is not a detour to the essence of the sieve of erastosthenes. in fact, bool is the essence.
21:04:11 <alatter> tommd: I often think of a list as a more descriptive Maybe
21:04:20 <copumpkin> monochrom: yeah, I'm not advocating getting rid of it altogether
21:04:33 <tommd> alatter: Yeah, I like listToMaybe.
21:04:39 * hackagebot text-icu 0.5.0.0 - Bindings to the ICU library  http://hackage.haskell.org/package/text-icu-0.5.0.0 (BryanOSullivan)
21:05:25 <monochrom> optimization by bitvectors and encoding True as 0 and False as 1 or the other way would be a detour.
21:05:51 <bobzhangatthu> hi, I have a problem, I want to represent the Result type of an expression, e.g it may have int type, string type, and function a -> b, is it possible to parameterize the variable?
21:07:17 <bobzhangatthu> I tried data Val :: (*->*) where Num :: Int -> Val Int | Bl :: Bool -> Val Bool | Fun :: Arrow ar => arr (Val a) (Val b) -> Val (arr a b)
21:07:58 <alatter> bobzhangatthu: I think the llvm package on Hackage pulls tricks like that
21:08:17 <bobzhangatthu> however, arr is quantified, it does not work later, 
21:08:36 <alatter> bobzhangatthu: and there has been some nice work with higher-order abstract syntax, which feels related
21:08:50 <alatter> bobzhangatthu: sorry for being so vague :-)
21:08:58 <bobzhangatthu> alatter: thanks
21:10:04 <bobzhangatthu> alatter: Maybe I make you confused. I just want the datatype parameterized, without such trick type A = (->) , and then replace it each time
21:10:12 <bobzhangatthu> do you know what i mean
21:11:52 <Saizan> maybe you want ... | Fun :: (forall arr. arr (Val a) (Val b)) -> Val (Arr a b) ?
21:12:12 <bobzhangatthu> yeah, but arr is quantified, it will not work later
21:12:18 <Saizan> ... | Fun :: (forall arr. Arrow arr => arr (Val a) (Val b)) -> Val (Arr a b), actually
21:12:55 <Saizan> with the forall there you'll be able to instantiate it to every Arrow you like
21:13:12 <bobzhangatthu> But I can not escape from it
21:13:25 <Saizan> the problem is constructing such a polymorphic value, though
21:14:10 <bobzhangatthu> e.g : I have a concrete datatype : data Exp = ... | Lam String Exp | App Exp Exp
21:14:44 <monochrom> is this valid? data Val arr where ... | Fun :: arr (Val arr a) (Val arr b) -> Val arr (arr a b)
21:15:09 <bobzhangatthu> and I have a correspondingb result type : data Val = ... | Fun (Val -> A Val)
21:15:18 <bobzhangatthu> monochrom: you should add forall
21:16:06 <bobzhangatthu> for concrete example, you should (type A = Maybe like this), is it possible to parameterize A? I mean , factor it out
21:17:08 <bobzhangatthu> Saizan: If i use forall as you said, I cannot pull it out, to calculate App Experssion 
21:18:28 <dmwit> monochrom: That looks okay off the top of my head. Does GHC complain?
21:18:47 <monochrom> I don't know yet. But trying.
21:21:46 <freedrull> @:t choice
21:21:47 <lambdabot> Done.
21:21:54 <freedrull> :3
21:22:51 <lispy> ?:t >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]
21:22:51 <lispy> >++++++++[<++++>-] <.>+++++++++++[<++++++++>-]<-.--------.+++
21:22:51 <lispy> .------.--------.[-]>++++++++[<++++>- ]<+.[-]++++++++++.
21:22:52 <lambdabot> Done.
21:23:01 <lispy> gah
21:23:07 <lispy> Should have been one line!
21:23:36 <freedrull> D:
21:23:51 <lispy> ?:t >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.>>>++++++++[<++++>-]<.>>>++++++++++[<+++++++++>-]<---.<<<<.+++.------.--------.>>+.
21:23:52 <lambdabot> Done.
21:23:56 <lispy> hmm
21:24:03 <dmwit> huh
21:24:07 <dmwit> what does ?:t do?
21:24:14 <lispy> dmwit: it autocorrects to bf
21:24:20 <monochrom> ghc doesn't complain. but I have to correct a typo. either "data Val arr :: (* -> *) where ..." or "data Val arr a where ..."
21:24:20 <dmwit> oh
21:24:36 <dmwit> lispy: Were you wishing for some commas somewhere...?
21:24:40 <lispy> ?bf >+++++++++[<++++++++>-]<.>+++++++[<++++>-]<+.+++++++..+++.[-]>++++++++[<++++>-] <.>+++++++++++[<++++++++>-]<-.--------.+++.------.--------.[-]>++++++++[<++++>- ]<+.[-]++++++++++.
21:24:41 <lambdabot>   Hello world!
21:24:58 <lispy> I'm not sure what's wrong with the one version
21:25:12 <lispy> I'm 95% confident that my bf interpreter is correct
21:27:19 <monochrom> and this also works now: example :: Val (->) (Int -> Int); example = Fun (const (Num 0))
21:31:28 <freedrull> these are the same right
21:31:29 <freedrull> choice ( map (try ( string (a))))
21:31:34 <freedrull> choice . map (try . string (a))
21:31:43 <copumpkin> no
21:32:18 <ezyang> Fedora haskell-platform is kind of annoying. 
21:32:23 <copumpkin> your parentheses are strange :)
21:32:25 <ezyang> since RPM doesn't support installing multiple versions of RPMs 
21:32:30 <monochrom> And this also works: ioexample :: Val (Kleisli IO) (Kleisli IO Int Int); ioexample = Fun (Kleisli (\(Num n) -> print n >> return (Num (n+1))))
21:34:34 <monochrom> Oh! Now I understand the pink borders in hpaste! pink border means "you haven't filled in this field"
21:35:12 <monochrom> http://hpaste.org/30133/gadt_and_parameterized_arrow
21:35:23 <monochrom> my first post on new hpaste!
21:35:29 <lispy> whoa, you have to enter a name and title on hpaste now??
21:35:39 * lispy switches to a different pastbin
21:35:44 <monochrom> hahahahaha
21:35:49 <JoeyA> m lambdabot @src mfix
21:35:53 <JoeyA> oops
21:36:40 <lispy> ugh, you can't even annotate without a title/author
21:36:48 <lispy> chrisdone: !!  What gives??
21:39:11 <monochrom> tomorrow: is it a bug? is it a feature? new hpaste wants you to name names. fight!
21:40:50 <monochrom> also on: is amelia an innocent social butterfly or an evil internet stalker of your identity?
21:41:35 <lispy> if hpaste wants me to name everything I do and provide an identity, the least it could do is suggest a name and let me use openid
21:42:13 <lispy> otherwise, it's just so much simpler to use some other pastebin
21:43:03 <Chaze_> argh: select every n-th element of a list?
21:43:09 <Chaze_> do i have to use !! ?
21:43:19 <copumpkin> no
21:43:37 <monochrom> you can loop over "drop n"
21:43:39 <c_wraith> in fact, !! will hurt your efficiency
21:43:40 <copumpkin> lispy: @tell chrisdone about it :)
21:44:15 <copumpkin> :t take 1 <=< iterate (drop 5)
21:44:15 <lambdabot> forall c. [c] -> [c]
21:44:24 <copumpkin> > take 1 <=< iterate (drop 5) $ [1..100]
21:44:28 <lambdabot>   mueval-core: Time limit exceeded
21:44:30 <copumpkin> lol
21:44:35 <copumpkin> I fail
21:44:45 <monochrom> @tell chrisdone I fully support the new hpaste making "title" and "author" compulsory and furthermore no default or suggestion!
21:44:45 <lambdabot> Consider it noted.
21:44:50 <co_dh> :t (<=<)
21:44:51 <lambdabot> forall b (m :: * -> *) c a. (Monad m) => (b -> m c) -> (a -> m b) -> a -> m c
21:44:52 <lispy> ?tell chrisdone dude?!  Could you change hpaste so that it either a) doesn't need username/pastename; Or b) autonames it and remembers my login (openid?).  As it is, I'm just going to use some other pastebin that doesn't require me to enter fields I don't care about.
21:44:52 <lambdabot> Consider it noted.
21:45:52 <Chaze_> copumpkin: iterate doesn'n end the list though, it doesn't terminate if i don't use take
21:46:34 <copumpkin> Chaze_: yeah
21:47:12 <copumpkin> > take 1 <=< (takeWhile (not . null) . iterate (drop 5)) $ [1..100]
21:47:13 <lambdabot>   [1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96]
21:47:37 <lispy> I was imaging a zipWith
21:47:41 <copumpkin> or use an unfold
21:47:43 <lispy> imagining*
21:47:57 <Chaze_> lispy: i zipWith would use !! right?
21:48:28 <lispy> Chaze_: it doesn't have to
21:49:24 <lispy> > filter (\(x,y) -> y `mod` 5 == 0) zip ['a'..'z'] [1..]
21:49:25 <lambdabot>   Couldn't match expected type `[(t, t1)]'
21:49:25 <lambdabot>         against inferred type `[a]...
21:49:28 <lispy> doh!
21:49:37 <lispy> > filter (\(x,y) -> y `mod` 5 == 0) $ zip ['a'..'z'] [1..]
21:49:38 <lambdabot>   [('e',5),('j',10),('o',15),('t',20),('y',25)]
21:49:40 <applicative> lispy, dont you have a key bound to anything invisible? http://hpaste.org/30135/
21:50:59 <lispy> > filter (\(x,y) -> y `mod` 4 == 0) $ zip ['a'..'z'] [1..]
21:51:00 <lambdabot>   [('d',4),('h',8),('l',12),('p',16),('t',20),('x',24)]
21:51:36 <Chaze_> i see
21:52:38 <applicative> freedrull, were you asking about the Parsec functions, or just about (.) ?  I couldnt parse your example
21:53:51 <freedrull> applicative: i'm just trying to understand composition (.) 
21:54:17 <freedrull> not the parsec functions, sorry
21:54:41 <applicative> so right, f (g (h (k a))) = (f.g) (h (k a))
21:55:02 <freedrull> ok thanks :3
21:55:12 <applicative> (f.g) (h (k a)) = (f.g) ((h . k) a)
21:55:38 <applicative> = (f . g . h . k) a = f . g . h . k $ a
21:56:04 <freedrull> (f . g) h = f $ g h
21:56:15 <applicative> yes
21:56:23 <freedrull> the first example of composition in rwh is (f .g) h
21:56:42 <freedrull> why not just use $
21:58:14 <lispy> $ is generally considered harder to grok
21:58:23 <lispy> so they probably did it to keep things simple
21:58:47 <applicative> freedrull, if we had concrete things, f , g and x, then theyre the same.  (f . g) x is a particular analysis of f (g x) 
21:59:17 <applicative> in the published version isn't there a mess about $?  It is explained well after it is used
21:59:52 <applicative> in any case, in the analysis (f . g) x of f (g x), I have something (f.g) which I can name, and use elsewhere
22:00:44 <etpace> @hoogle DiffTime -> NominalDiffTime
22:00:44 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:00:45 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
22:00:45 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
22:00:52 <etpace> ugh
22:00:57 <applicative> to get hold of it, without the (.) I would have to write \x -> f (g x) instead of f.g
22:01:00 <freedrull> maybe this is not the published version, its a pdf i got from somewhere
22:01:45 <freedrull> i see the usefulness of (.) now i think
22:02:01 <applicative> freedrull, in any concrete case you can write f (g x) or (f.g) x or f . g $ x or f $ g x or f $ g $ x, they're all the same
22:02:13 <freedrull> right
22:02:35 <xiackok> how can i convert Word16 to Int??
22:02:37 <applicative> if you ask, why do they use the second, not the fourth, it's because they're explaining composition, 
22:02:54 <applicative> which appears in the second and third
22:03:17 <copumpkin> xiackok: fromIntegral
22:03:43 <applicative> @type fromIntegral
22:03:44 <lambdabot> forall a b. (Integral a, Num b) => a -> b
22:05:48 <xiackok> copumpkin: thanks it works. damn it sdl mouse motion event woring too slow
22:07:19 <applicative> > 1 :: Word16
22:07:21 <lambdabot>   1
22:07:46 <applicative> > fromIntegral (1 :: Word16) :: Int
22:07:47 <lambdabot>   1
22:16:52 <lispy> > fromIntegral (1 :: Word) :: Char
22:16:53 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
22:16:53 <lambdabot>    arising from a use of `GHC....
22:18:55 <killown> > test
22:18:56 <lambdabot>   Not in scope: `test'
22:24:45 <disgrntld> So, I realized I can think of 4 different ways to nondeterministically multiply numbers: http://pastebin.com/fGast9Uc any other cool ways?
22:25:09 <ezyang> disgrntld: You could use the Logic monad. 
22:25:18 <disgrntld> show me?
22:25:27 <disgrntld> I'm pretty new to monads
22:25:40 <disgrntld> ..just playing around
22:26:13 <copumpkin> the fmap and the <$> ones are exactly equivalent
22:26:28 <copumpkin> you can also use liftA2 (*) [1,2,3] [4,5]
22:26:38 <copumpkin> and the same functions from Monad
22:26:46 <disgrntld> crazy
22:27:05 <copumpkin> disgrntld: I'd recommend avoiding specifics like the lists and operation
22:27:12 <copumpkin> and figuring out laws :)
22:27:20 <copumpkin> they're reasonably easy to derive using equational reasoning
22:27:26 <disgrntld> heh, kk
22:27:36 <copumpkin> things like pure f <*> x == f <$> x
22:27:44 <disgrntld> I kinda skipped the functor laws section *blush*
22:28:00 <copumpkin> well, this is you figuring out the laws through experience, which is arguably better :)
22:28:07 <copumpkin> (applicative laws)
22:28:08 <disgrntld> yay!
22:28:14 * disgrntld nods
22:28:32 <copumpkin> and sequence lives in Monad, but you could write it for Applicative too
22:29:30 <disgrntld> isn't functor enough for sequence?
22:29:48 <copumpkin> nope
22:29:53 <disgrntld> I just did: fmap (\x -> x 2) [(4*), (5*)].. could I generalize that?
22:30:44 <copumpkin> > (sequence [(4*), (5*)] 10, flip [(4*), (5*)] 10)
22:30:45 <lambdabot>   ([40,50],[40,50])
22:30:52 <copumpkin> they behave the same in that case only :P
22:31:04 <copumpkin> so I don't think you could generalize unfortunately
22:31:33 <copumpkin> where flip f x is fmap ($x) f
22:31:44 <disgrntld> ok :(
22:34:51 <copumpkin> preflex: seen rl
22:34:52 <preflex>  rl was last seen on #ghc 27 days, 19 hours, 1 minute and 25 seconds ago, saying: tibbe: no worries, it's vodka time here ;)
22:35:02 <Veinor> oh no!
22:36:12 <lispy> preflex: seen a_language_cooler_than_haskell
22:36:13 <preflex>  Sorry, I haven't seen a_language_cooler_than_haskell
22:36:14 <ddarius> :t sequenceA
22:36:15 <lambdabot> Not in scope: `sequenceA'
22:37:29 <xiackok> lispy: haha geek mod
22:40:06 <applicative> disgrntld, with the she preprocessor and the special  (|   |) brackets, you can write (| [1,2,3]  *  [1,10] |) to get [1,2,3,10,20,30]
22:40:24 <applicative> disgrntld,  perhaps not advisable, but illuminating.
22:40:58 <disgrntld> I've never even heard of the she preprocessor
22:42:12 <disgrntld> "some kit for higgledy-piggledy literate programming" haha, what??
22:42:23 <applicative> disgrntld, there a package she on hackage, it's a difficult haskell extension.  but it does include a mechanism for rewriting 'idiom brackets'
22:43:00 <disgrntld> that's probably the cleanest syntax to someone new like me
22:44:53 <disgrntld> so I guess you could do something lik e(|Just 4 * Just 5 * Nothing|)
22:44:54 <applicative> disgrntld, it's just that aspect of it that i meant to point out, the (| head getArgs  |)  or (| [1,2,3] * [ 1, 10]|) or (| readFile a ++ readFile b |)  bit
22:45:44 <disgrntld> yea, I like it
22:46:08 <applicative> disgrntld, not sure, its a bit more delicate.  basically if f takes four args, then (|f . . . .|) takes four 'lifted' args in the monad or applicative functor
22:46:53 <ddarius> That suggests that head getArgs and head $ getArgs do different things.
22:47:09 <applicative> they are both type violations
22:47:37 <applicative> head <$> getArgs is an IO String, since getArgs is an IO [String]
22:48:32 <applicative> head <$> getArgs = fmap head getArgs = (|head getArgs|) , with the fancy preprocessor
22:48:43 <ddarius> So how is that a type violation?
22:48:52 <applicative> @type head
22:48:53 <lambdabot> forall a. [a] -> a
22:48:58 <applicative> @type getArgs
22:48:59 <lambdabot> Not in scope: `getArgs'
22:49:02 <applicative> figures
22:49:14 <applicative> getArgs is an action that returns a list, it
22:49:17 <disgrntld> @quit
22:49:17 <lambdabot> Not enough privileges
22:49:18 <applicative> isn't a list.
22:49:20 <disgrntld> heh
22:49:35 <ddarius> Yes, I meant inside the (| |).
22:50:34 <applicative> yes, but the (| |) brackets change application, so to say. you don't apply in the sense of $ but in the sense of <$>, crudely speaking
22:50:48 <ddarius> I know this.
22:51:30 <ddarius> I'm saying your description suggests that (| head getArgs |) becomes fmap head getArgs, but (| head $ getArgs |) becomes ($) <$> head <*> getArgs.
22:51:39 <ddarius> One is fine, the other is a type error.
22:51:45 <applicative> "That suggests that head getArgs and head $ getArgs do different things." -- was my starting point
22:53:28 <applicative> i get your meaning. to parse  (| head $ ... |)  we'd have to find a suitable functor that head is in, and a matching  ...
22:55:43 <ddarius> head :: F X for a functor F and type X, namely F = ((->) [a]) and X = a, though that's not particularly relevant.
22:56:08 <copumpkin> preflex: seen dons
22:56:09 <preflex>  dons was last seen on #ghc 1 day, 11 hours, 56 minutes and 40 seconds ago, saying: i was waiting for the main discussion to congeal, then colate bryan's responses.
22:56:22 <copumpkin> dons: you around?
22:58:48 <applicative> ddarius, sorry, there was a moment of confusion I took disgrntld to be saying something you were saying, and thus found ... a contradiction.
23:04:52 <applicative> ddarius, sorry, you intervened even earlier than I thought. yes, of course inside (||) 's 'head getArgs' and 'head $ getArgs' are different. that's sort of what I was saying
23:06:24 <copumpkin> can anyone think of a good use of replicateM on an ST action?
23:06:48 <freedrull> i want something like try (string "foo")...but i want to use it on a list of strings....
23:06:53 <applicative> ddarius, this is part of the reason the (| |) aren't as pleasant as one would like; you need a lot of bracketing you can dispense with elsewhere. 
23:07:04 <freedrull> i have a feeling i need to use map and <|> somehow?
23:10:53 <applicative> freedrull well  fmap string ["foobar", "foodiebar"] will give you a list of parsers
23:15:39 <copumpkin> hmm, I may have just violated etiquette
23:16:23 <copumpkin> is it bad to use darcs send to send a patch to a maintainer without warning him beforehand and telling him about the patch? I just wrote a simple patch for vector and used darcs send on it, assuming it would give me the option to write a brief introduction email
23:16:39 * applicative doesn't have an etiquette-checker
23:19:57 <MasseR> Is there a good guide for algebraic datatypes (data A = B right?) which would go over ~everything, including records and this one weird syntax I've seen (data  (Integral a)      => Ratio a = !a :% !a  deriving (Eq)
23:21:23 <ddarius> @where report
23:21:23 <lambdabot> http://www.haskell.org/onlinereport/
23:22:25 <ddarius> copumpkin: replicateM (do idx <- readSTRef indexRef; writeSTArray someArray idx 0; writeSTRef indexRef (idx+1))
23:25:56 * ddarius had forgotten that the A20 line is set via the keyboard controller.
23:26:55 <copumpkin> ddarius: oh, fair enough :)
23:27:18 <copumpkin> I'd probably use mapM for that, but I forgot about external ST state
23:27:23 <copumpkin> or mapM_ 
23:29:06 <applicative> MasseR, not sure what's a good guide but data (Integral a) => Ratio a = !a :% !a deriving (Eq) has a lot more than algebraic types in it
23:29:54 <MasseR> applicative: Any hints on what to google for?
23:29:59 <applicative> basically this Ratio a it's just a pair or product type -- not too much algebra.  
23:31:34 <MasseR> Can't parse it in my head from that :/
23:32:28 <applicative> the core of it is Ratio a = a :% a where :% is just a fancy 'type operator' (in Haskell it must begin with :)
23:32:41 <copumpkin> hmm, I guess the vector trac isn't editable by any but a select few, anyway
23:32:51 <applicative> so its like Pair a = Pr a a or whatever.
23:32:57 <ddarius> > 0xB4 + 24
23:32:58 <lambdabot>   204
23:33:57 <applicative> but Integral a means that the a's were pairing with each other around the :% have to be of some one type in the  "Integral" type class
23:34:11 <MasseR> applicative: Oh, the :% is like Pr in the second example?
23:34:58 <applicative> yes, with the TypeOperator extension you can use $%^^&&*  infix instead of Pr or whatever, if there's a : first
23:35:47 <MasseR> applicative: Thanks!
23:35:50 <applicative> So Ratio a = a :% a is not really different from Ratio a = Rat a a
23:35:58 <MasseR> Now.. How could I have found this myself :P
23:36:10 <applicative> Masse, the ! points have to dowith strictness
23:36:16 <ddarius> :% is not a type operator and the TypeOperator extensios doesn't do that.
23:36:25 <applicative> %
23:36:30 <applicative> i'm confused
23:36:36 <applicative> i just compiled it
23:37:39 <MasseR> ddarius: Then what is it?
23:37:41 * applicative is losing his mind
23:38:07 <applicative> i'm mixing up the operators in the types and in the constructors, is right
23:38:40 <applicative> but why does data (Integral a) => Ratiom a = !a :% !a deriving (Eq) compile
23:38:50 <applicative> but demand the extension?
23:39:12 <handonson> Can I avoid importing anything (including Prelude)?
23:39:26 <applicative> The answer to all such questions is you google "ddarius".
23:41:15 <applicative> wait, MasseR, indeed, i was getting interference from the she preprocessor, imported earlier.   In any case, apart from the remark about the extension what I said was sound
23:41:20 <ddarius> That's Haskell 98 code that's from the Report.  It should compile fine.  http://www.haskell.org/onlinereport/ratio.html
23:41:21 <tommd> handonson: import Prelude ()
23:41:25 <applicative> MasseR, we have to do with a piar type. 
23:41:35 <MasseR> Piar?
23:42:14 <tommd> handonson: IIRC, there is also a GHC flag NoPrelude or some such - check the man page.
23:42:23 <Zao> NoImplicitPrelude?
23:42:28 <applicative> Of course it does, I was in a muddle, because it was rejected with the demand for type operators.  I was confused for a moment, the answer is that I had the she preprocessor pragma at the top of the page
23:42:41 <Zao> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#rebindable-syntax
23:42:55 <applicative> Masse, a Ratio a, is determined by a couple of a's .  This is what I mean by calling it a pair type.  
23:42:56 <tommd> Zao: Yep, except I was thinking it was "unsafeNoImplicitPrelude" ;-)
23:43:11 <handonson> Thank you very much.
23:44:26 <MasseR> applicative: Ah thanks
23:45:33 <applicative> ddarius, here is the source of my confusion http://hpaste.org/30138/nonsense with the error; the she rewrite is a bit complicated....
23:54:10 <applicative> MasseR, in any case -- pardon interlude of idiocy -- Ratio a = a :% a is to be compared with a x a or a ^2  ; Pair a b = MkPair a b is like a x b , etc. 
23:58:17 <Cale> applicative: It means that a value of type Ratio a is constructed as x :% y, where x and y both have type a
23:58:53 <Cale> applicative: So yeah, it's like the Cartesian product of the set of values of type a with itself.
23:59:14 <applicative> yes, am I contradicting that.  The question was why we speak of 'algebraic' data types
23:59:45 <applicative> and the example was the opaque line:  data (Integral a) => Ratio a = !a :% !a deriving (Eq)
