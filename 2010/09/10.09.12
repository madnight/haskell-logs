00:03:02 <kulin> ahh so my problem isnt with c2hs, its with cpp
00:03:30 <kulin> i think that means my spirit is completely crushed then
00:18:00 <ManateeLazyCat> dom96: Are you there?
00:18:11 <ManateeLazyCat> :preflex seen dom96
00:18:16 <ManateeLazyCat> >preflex seen dom96
00:30:04 <Nibble> what does this operator do?  =?
00:30:11 <medfly> :t (=?0
00:30:14 <lambdabot> parse error (possibly incorrect indentation)
00:30:15 <medfly> :t (=?)
00:30:17 <lambdabot> Not in scope: `=?'
00:30:34 <Nibble> medfly: it is my xmonad config, the manageHook
00:30:54 * medfly doesn't know, is ignorant
00:34:26 <deteego> if you have a tuple as an argument in a function, whats the quickest way to curry the tupe for use in pattern matching?
00:34:34 <deteego> *tuple
00:34:58 <dark> there is no man cabal? :(
00:35:20 <deteego> i.e. doing something like
00:35:22 <deteego> someFunc :: (a -> b -> c) -> d
00:35:24 <deteego> someFunc a b c = ....
00:35:47 <Nibble> deteego: there is a function called curry... but I am not sure what you are trying to achieve
00:35:54 <dark> "Config file /root/.cabal/config not found.", is there a way for having system-wide installations? (or are root installations automatically system-wide?0
00:36:02 <deteego> Nibble: well from the example I gave
00:36:09 <deteego> assume you have a function that takes one massive tuple
00:36:15 <ManateeLazyCat> @hoogle write
00:36:16 <lambdabot> Data.Array.MArray writeArray :: (MArray a e m, Ix i) => a i e -> i -> e -> m ()
00:36:16 <lambdabot> Network.Stream writeBlock :: Stream x => x -> String -> IO (Result ())
00:36:16 <lambdabot> Network.TCP writeBlock :: HStream bufType => HandleStream bufType -> bufType -> IO (Result ())
00:36:18 <Nibble> deteego: well, let me try one thing.
00:36:31 <deteego> I know what I wrote above isn't legal
00:36:38 * hackagebot tagsoup 0.11 - Parsing and extracting information from (possibly malformed) HTML/XML documents  http://hackage.haskell.org/package/tagsoup-0.11 (NeilMitchell)
00:36:41 <deteego> because technically you are getting one argument in the function, not 3
00:36:54 <Nibble> deteego: why would you want to do this?
00:36:55 <deteego> but what is the most concise way to curry a tuple when doing pattern matches
00:37:08 <deteego> Nibble: do what?
00:37:23 <Nibble> deteego: ask someone else than me
00:37:27 <Nibble> you probably know more than me
00:37:29 <Nibble> :P
00:37:32 <deteego> sigh
00:38:05 <deteego> someFunc :: (Int -> Int -> Bool) -> Int
00:38:08 <deteego> someFunc a b c = ......
00:38:10 <deteego> does that make it clearer?
00:38:56 <deteego> want to match a with the first Int, b with the second Int and C with the Bool, but I obviously can't because its an uncurried tuple
00:39:11 <deteego> so whats the most concise way to pattern match in with the curried version of that tuple
00:43:11 <ManateeLazyCat> How many different character-set in IRC channel?
00:45:32 <deteego> what does the @ symbol do in haskell
00:46:29 <medfly> > let sumfin a@(x:xs) = x : a in sumfin "abc"
00:46:31 <lambdabot>   "aabc"
00:47:00 <ManateeLazyCat> deteego: @ split type and it's field
00:47:41 <deteego> sigh
00:47:47 <deteego> im trying to do something so simple
00:47:49 <dark> I need help with http://github.com/jgoerzen/magic-haskell - it looks this package isn't available through the regular cabal repository, right?
00:47:58 <dark> but it has a .cabal file
00:47:58 <ManateeLazyCat> deteego: Example, you have "data Foo {bla :: Bla, bar :: Bar}", you can write foo@{bla = a, bar =b}
00:48:03 <Nibble> dark: cd to the folder
00:48:07 <Nibble> run cabal install
00:48:30 <dark> how to install it system-wide?
00:48:41 <dark> it looks root installations go to /root
00:48:47 <ManateeLazyCat> deteego: is foo@(Foo {bla = a, bar =b})
00:49:18 <deteego> nope thats not what I needed
00:49:21 <ManateeLazyCat> deteego: Then you can use foo or it's field, and don't need write many 'let ... = ...'m
00:49:26 <deteego> I just want to curry a tuple and pattern match against it
00:49:37 <deteego> straight away
00:55:15 <Maxdamantus> Why is ((*) >>= id) 4 == 16?
00:55:40 <ManateeLazyCat> :t ((*) >>= id) 4 == 16?
00:55:42 <lambdabot> parse error (possibly incorrect indentation)
00:55:45 <ManateeLazyCat> :t ((*) >>= id) 4 == 16
00:55:47 <lambdabot> Bool
00:56:03 <Maxdamantus> > ((*) >>= id) 4
00:56:04 <lambdabot>   16
00:56:19 <Maxdamantus> @src join
00:56:19 <lambdabot> join x =  x >>= id
00:56:28 <medfly> @unpl ((*) >>= id)
00:56:28 <lambdabot> ((*) >>= \ a -> a)
00:56:36 <medfly> o.O
00:57:05 <ski> ManateeLazyCat : "you can write foo@{bla = a, bar =b}" is incorrect
00:57:12 <ski> > let foo t @ {rootLabel = a,subForest = ts} = (t,a,ts) in foo Node {rootLabel = 0,subForest = []}  -- error
00:57:13 <lambdabot>   <no location info>: parse error on input `{'
00:57:16 <ski> > let foo t @ Node {rootLabel = a,subForest = ts} = (t,a,ts) in foo Node {rootLabel = 0,subForest = []}  -- ok
00:57:18 <lambdabot>   (Node {rootLabel = 0, subForest = []},0,[])
00:57:25 <NemesisD> hi all. having some trouble figuring out monadic args. addToURI :: URLEncoded -> URI -> URI. for the second argument, i've got something that produces a Maybe URI. how would i pass that to addToURI?
00:57:55 <Maxdamantus> @unpl ((*) >>= \ a -> a)
00:57:55 <lambdabot> ((*) >>= \ a -> a)
00:58:55 <ski> deteego : `@' is not related to the record syntax at all. it's a construct in patterns : a pattern `x @ p', when matched against a value, both binds the variable `x' to the value, *and* matches the value against the (possibly complex) pattern `p' (possibly binding more variables)
00:58:55 <deteego> zzzz
00:59:11 <deteego> ski: I just want to pattern match values with the ones inside a tuple
00:59:18 <ski> > let foo xs0@(x:xs) = (xs0,x,xs) in [0,1,2,3]
00:59:20 <lambdabot>   [0,1,2,3]
00:59:36 <ski> so you both get a name for the whole value, and can match on it, and name parts
00:59:48 <ManateeLazyCat> ski: I fix with "foo@(Foo {bla = a, bar =b})" :)
00:59:50 <deteego> ski: I want to do something like this
00:59:52 <deteego> someFunc :: (Int -> Int -> Bool) -> Int
00:59:54 <deteego> someFunc (a, b, c) = ......
01:00:08 <deteego> eh sorry
01:00:15 <deteego> someFunc :: (Int -> Int -> Bool) -> Int
01:00:18 <deteego> someFunc (a, b) = ......
01:00:27 <ski> ManateeLazyCat : actually `foo @ Foo {bla = a,bar = b}' works as well, as my two example some twenty lines above show :)
01:00:57 <deteego> how do you do something like that (match a with the first argument in a tuple, b with the second)
01:01:07 <ManateeLazyCat> ski: Yes, don't need () , foo@{bla = a, bar =b} is typo. :)
01:01:19 <ski> deteego : that makes no sense, the input to `someFunc' is declared to have function type, but in the pattern for the input you're matching with a tuple pattern
01:01:45 <deteego> someFunc :: (Int -> Int -> Bool) -> Int
01:01:47 <deteego> someFunc (a, b, c) = ......
01:01:51 <NemesisD> Maxdamantus: i can't quite figure out how that would look though, my function takes 2 args so i'm not sure where that bind function would fit
01:01:55 <deteego> well (Int -> Int -> Bool) is a tuple
01:01:56 <Axman6> deteego: those types don't match at all
01:02:05 <deteego> I want to curry the tuple
01:02:08 <deteego> and match types with it
01:02:11 <Axman6> (a -> b -> c) isn;t a tuple at all
01:02:29 <ski> deteego : no `Int -> Int -> Bool' is a *type*
01:02:29 <Maxdamantus> NemesisD: sorry, I wasn't suggesting anything to you if that's how you interpreted what I was asking
01:02:36 <ski> deteego : it is not even a value
01:02:38 <deteego> ffs
01:02:40 <deteego> I need a break
01:02:53 <deteego> my bad
01:03:19 <ski> deteego : maybe what you *meant* to ask was how, if you have `someFunc :: (Int,Int,Bool) -> Int', to match only on the first two parts of the input tuple (having type `(Int,Int,Bool)') ?
01:03:24 <deteego> ski: Im an idiot
01:03:28 <deteego> yes thats what I meant
01:03:38 <deteego> I think thats a sign I need to take a break
01:03:50 <NemesisD> Maxdamantus: oh. i was just looking at bind so i thought it made sense that you were suggesting it
01:04:21 <ski> deteego : well, there is no way in Haskell to (actually) match against a tuple without writing a tuple pattern with sub-patterns for *all* components ..
01:04:40 <ski> deteego : the tuple types are all distinct from each other, and unrelated
01:05:18 <ski> it *might* make sense to want this, but i'm not sure what the typing of such an operation would be
01:05:35 <deteego> ski: I meant (Int,Int,Bool) and not (Int -> Int -> Bool)
01:05:48 <ski> (yes, i surmised so :)
01:05:49 <deteego> ski: as I said I need a break
01:05:57 <ski> deteego : anyway, in this kind of situation, possibly what you *want* to do it change representation from tuple to record
01:06:27 <ski> unfortunately, Haskell only has heavy-weight record types (meaning you've to declare a new record type)
01:06:41 <deteego> yeah I know
01:06:48 <deteego> but in this case I don't really need records, only doing it once
01:07:39 <ski> so, `data Foo = MkFoo {count :: Int , size :: Int , bad :: Bool}' and then you match on `MkFoo {count = c , size = s , ..}'
01:07:44 <ski> ok
01:09:57 <deteego> sorry one last thing
01:10:15 <deteego> lets say you have some types (a and b in this case)
01:10:35 <deteego> and you have a list of a types (lets say [c1,c2,c3])
01:10:42 <deteego> is there a function that does something like this
01:11:17 <deteego> [(a,b,c1),(a,b,c2),(a,b,c3)]
01:13:03 <ski> hm, you want a function that transforms a list like `[c1,c2,c3]' into `[(a,b,c1),(a,b,c2),(a,b,c3)]' ?
01:13:15 <deteego> yeah
01:13:32 <ski> well, `map' does that :) (well, it's more general, so you need to give it a little bit more information)
01:13:53 <ski> > map (\cde -> (a,b,cde)) [c,d,e]
01:13:54 <lambdabot>   [(a,b,c),(a,b,d),(a,b,e)]
01:14:02 <ski> > map ((,,) a b) [c,d,e]
01:14:03 <lambdabot>   [(a,b,c),(a,b,d),(a,b,e)]
01:14:14 <ski> any of those should do what you asked for
01:14:22 <ski> you could also say
01:14:41 <ski> > let frob cde = (a,b,cde) in map frob [c,d,e]
01:14:43 <lambdabot>   [(a,b,c),(a,b,d),(a,b,e)]
01:15:09 <ski> (and in your actual code possibly defining `frob' in a `where'-clause, instead of in a `let')
01:15:23 <ski> deteego : ok ?
01:16:06 <deteego> ski: yup
01:20:14 <deteego> ski: how would you deconstruct a type in a lambda abstraction
01:20:42 <deteego> ski: if the lambda abstraction is taking a variable of that type
01:22:23 <ski> hm
01:22:31 <ski> i'm not sure i understand what you're asking about
01:22:45 <deteego> data someData = someData Int Bool
01:22:46 <ski> do you have an example of what you mean, or can you elaborate more ?
01:22:47 <deteego> (\ someData (x y) -> ..... ) 
01:23:02 <ski> well, ok, assuming you have
01:23:29 <ski>   data SomeData = MkSomeData Int Bool  -- you need upper-case initial letter on both type constructors and data constructors
01:23:33 <ski> then if you say
01:23:45 <ski>   \MkSomeData (x y) -> ..x..y..
01:23:50 <ski> then that's is interpreted as
01:23:58 <ski>   \MkSomeData -> \(x y) -> ..x..y..
01:24:11 <ski> i.e. as a curried function, taking two arguments
01:24:24 <ski> what you want here is expressed by bracketing
01:24:35 <ski>   \(MkSomeData x y) -> ..x..y..
01:25:10 <deteego> ski: thanks that worked
01:25:25 <ski> (no brackets around `x' and `y' since those are to be separate arguments to `MkSomeData' .. as opposed to `y' being an argument to `x', which `\(MkSomeData (x y)) -> ..x..y..' would mean)
01:25:29 <ski> np
01:36:48 <ddarius> XMonad works well with BackTrack.
01:46:58 <NemesisD> could anyone take a look at this predicament i'm in? very new to haskell http://pastie.org/1153394
01:48:22 <Axman6> NemesisD: fmap
01:48:44 <Axman6> addToURI (buildParams r) `fmap` (parseURIReference "http://maps.google.com/maps/api/directions/json")
01:49:11 <Axman6> @src Maybe fmap
01:49:11 <lambdabot> fmap _ Nothing       = Nothing
01:49:12 <lambdabot> fmap f (Just a)      = Just (f a)
01:49:42 <zenzike> Is anybody familiar with Hakyll or arrows?
01:49:43 <ManateeLazyCat> @hoogle Char -> Word8
01:49:45 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
01:49:45 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
01:49:45 <lambdabot> Prelude error :: [Char] -> a
01:50:22 <ManateeLazyCat> @hoogle String -> [Word8]
01:50:24 <lambdabot> Prelude fail :: Monad m => String -> m a
01:50:24 <lambdabot> Control.Monad fail :: Monad m => String -> m a
01:50:24 <lambdabot> Control.Monad.Instances fail :: Monad m => String -> m a
01:50:24 <NemesisD> Axman6: i shoulda known. thanks!
01:50:35 <Axman6> oh weak, c2w is already defined for ByteStrings, haha
01:50:40 <Axman6> could have used that months ago
01:50:50 <Axman6> zenzike: what's your question?
01:51:09 <Zao> Is there any nicer way of writing the predicate here? http://pastie.org/1153396
01:51:12 <Zao> ASE'SHAPEOBJECT is one of the data constructors of the elements in tls.
01:51:41 <zenzike> I'm trying to extract tags from a Context in a HakyllAction, so that I can use the data in a changeUrl function
01:52:02 <Axman6> Zao: i'd make that predicate a function of its own
01:52:29 <ManateeLazyCat> I love c2w....
01:52:40 <Zao> Axman6: I'm anticipating lots of these kinds of queries.
01:52:52 <Zao> Should I really have a bunch of isShapeObject, isFoo, isBar?
01:53:29 <Axman6> i wouldn't have a problem with it, it should make code like that quite clear and concise
01:53:43 * ManateeLazyCat Change gtk2hs APIs support ByteString, then insert/get ByteString directly, don't need convert.... haha...
01:53:44 <Zao> Lots of manual boilerplate to emit :)
01:53:49 <Axman6> i wonder if you could have them generated for you
01:54:21 <zenzike> I get the feeling I'll have something like createPage "foo" >> changeUrl (dateTag) , where dateTag extracts the information from the context somehow
01:54:22 <Axman6> i would love to see some TH thing that could take a type, and define for you all the isFoo functions
01:55:01 <Zao> The capabilities of TH is a vague blob in my knowledge.
01:55:30 <Axman6> mine too
01:58:54 <dom96> Is there a way i can block a thread until a function which returns a boolean, returns True?
02:00:03 <ManateeLazyCat> dom96: MVar, then use readMVar
02:00:15 <ManateeLazyCat> @hoogle takeMVar
02:00:16 <lambdabot> Control.Concurrent.MVar takeMVar :: MVar a -> IO a
02:00:16 <lambdabot> Control.Concurrent.MVar tryTakeMVar :: MVar a -> IO (Maybe a)
02:00:26 <dom96> I'm kinda already using a Chan
02:00:43 <ManateeLazyCat> dom96: Then use readTChanIO
02:00:52 <ManateeLazyCat> @hoogle readTChanIO
02:00:53 <lambdabot> No results found
02:00:53 <ManateeLazyCat> @hoogle readTChan
02:00:54 <lambdabot> Control.Concurrent.STM.TChan readTChan :: TChan a -> STM a
02:01:01 <Jiten> can't you just launch a thread as a reaction to the function returning true?
02:01:27 <ManateeLazyCat> dom96: I think you can fork a new thread listen value from Chan.
02:01:52 <dom96> I have a loop which checks whether the Chan is empty. Although i have to delay it somehow, because it's taking up 100% of the CPU
02:02:17 <Axman6> :t let a x = (x,x); b = a . a; c = b . b in c
02:02:18 <lambdabot> forall t. t -> ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))
02:02:24 <ManateeLazyCat> dom96: I wonder why your bot can receive UTF8 message, are you read Char8.ByteString from socket or read String then convert to Char8.ByteString ?
02:02:37 <Axman6> :t let a x = (x,x); b = a . a; c = b . b; d = c . c in d
02:02:38 <lambdabot> forall t. t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((
02:02:38 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((
02:02:38 <lambdabot> t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((
02:02:38 <lambdabot> t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
02:02:38 <lambdabot> (t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t))
02:02:41 <lambdabot> , ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), (
02:02:43 <lambdabot> (t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
02:02:44 <Axman6> heh
02:02:47 <Axman6> awsome
02:02:59 <dom96> I'm reading a Char8.ByteString
02:03:00 <ManateeLazyCat> Axman6: Fill my irc....
02:03:15 <Axman6> any time, baby
02:03:25 <ManateeLazyCat> dom96: Hmmm, i wonder why Char8.ByteString can work.
02:04:03 <dom96> Does readChan block if there is nothing in the chan?
02:04:24 <ManateeLazyCat> @hoogle readChan
02:04:24 <lambdabot> Control.Concurrent.Chan readChan :: Chan a -> IO a
02:04:51 <ManateeLazyCat> dom96: Yes.
02:05:34 <Axman6> dom96: Chan's are just a lift of MVars
02:06:05 <ManateeLazyCat> dom96: I'm refactory my irc code use Data.ByteString.ByteString instead Char8.ByteString.
02:06:24 <dom96> Axman6: oh
02:06:25 <ManateeLazyCat> dom96: Have you do any decode work after you receive message from socket?
02:06:25 <dom96> ManateeLazyCat: ok
02:06:34 <Axman6> uh, list even
02:07:04 <dom96> no, i just remove the \n or \r\n i can't remember, and parse the message.
02:07:49 <deteego> who the f*** let these mother***** t's in the mother***** irc
02:08:14 <dom96> no swearing! There are children present!
02:08:22 <dom96> :P
02:08:54 <Axman6> deteego?
02:09:07 <ManateeLazyCat> dom96: I'm change gtk2hs APIs, use ByteString directly, then i don't need convert between String and ByteString....
02:09:34 <Zao> Axman6: I find myself laughing maniacally when reading TH guides. Am I doing it right?
02:09:42 <dom96> ManateeLazyCat: ok :)
02:09:44 <ManateeLazyCat> dom96: You use Char8.ByteString send message?
02:09:48 <Zao> ManateeLazyCat: I hear that Data.Text is nice.
02:09:58 <Axman6> Zao: i wouldn't know, i've never really tried
02:10:16 <dom96> ManateeLazyCat: you mean it's hPutStr? Yes
02:10:53 <ManateeLazyCat> Zao: Oh, i'm tired to convert work, i change gtk2hs APIs that support ByteString directly, then i don't care which encode of IRC message, just fill in gtk's C raw string function.
02:10:53 <zenzike> does anybody know if there's a function with this signature?: (>>>=) ∷ Arrow a ⇒ a b c → (c → e) → (e → a c d) → a b d
02:12:45 <deteego> yeah?
02:12:45 <ManateeLazyCat> Zao: If you use Text, you need detect current encoding of IRC message, and convert to String or ByteString (because gtk2hs APIs), it's troublesome, so i just receive/send ByteString, and don't care encoding information..
02:12:55 <deteego> Axman6: yeah?
02:13:14 <Axman6> i was wondering what all the swearing was about
02:13:48 <deteego> its a quote from a Movie, its pointless without the swearing
02:14:00 <deteego> (well actually its a parody of a quote from a movie)
02:16:02 <ManateeLazyCat> Zao: IMO, like IRC client or file manager those have unknown string, need some "automatic detect encoding" module to detect the encoding of unknown string.
02:16:48 <handonson> how do i set a widget's background color in Graphics.UI.Gtk?
02:18:05 <ManateeLazyCat> handonson: widgetModifyBg :: WidgetClass self => self -> StateType -> Color -> IO ()
02:18:23 <handonson> thanks.
02:18:52 <ManateeLazyCat> handonson: Look http://hackage.haskell.org/packages/archive/gtk/0.11.2/doc/html/Graphics-UI-Gtk-Abstract-Widget.html , you will know what's the StateType and Color.
02:20:23 <ManateeLazyCat> handonson: I suggest you run "cabal haddock" before "cabal install gtk", then you can got haddock documentation at gtk/dist/doc/index.html to browse APIs offline.
02:21:04 <handonson> okay, thank you very much, but you're being TOO kind. please stop.
02:21:36 <ManateeLazyCat> handonson: I'm developer of gtk2hs, feel free to ask me any gtk2hs question. :)
02:21:52 <handonson> you are?
02:22:02 <ManateeLazyCat> handonson: Andy Stewart.
02:22:22 <handonson> i always wanted to thank those people for such a great library
02:23:25 <ManateeLazyCat> handonson: Expect gtk-0.12.0, have many APIs add to support gtk+-2.20
02:23:32 <handonson> i mean binding, too be precise
02:23:34 <handonson> to*
02:23:36 <deteego> does anyone know if (literal) is valid in pattern matches in haskell syntax
02:23:41 <handonson> damn, what's wrong with me today
02:23:51 <deteego> hmm wait
02:26:24 <ManateeLazyCat> > pack $ map c2w "gtk2hs"
02:26:25 <lambdabot>   Not in scope: `pack'Not in scope: `c2w'
02:26:51 <ManateeLazyCat> > Data.ByteString.pack $ map Data.ByteString.Internal.c2w "gtk2hs"
02:26:52 <lambdabot>   Not in scope: `Data.ByteString.pack'Not in scope: `Data.ByteString.Internal...
02:27:16 <ManateeLazyCat> lambdabot: Load package! 
02:27:41 <handonson> ManateeLazyCat: forget everything I said and have my infinite gratitude that is currently being sent via IRC packets.
02:28:46 <handonson> i think (Data.ByteString.pack (map Data.ByteString.Internal c2w)) == (Data.ByteString.Char8.pack)
02:38:26 <deteego> is there a function in Haskell which does nothing
02:38:33 <deteego> for use in do statements
02:38:42 <vanadium> 4
02:39:00 <deteego> 4?
02:39:32 <vanadium> I am not sure I see what you are getting at
02:39:42 <vanadium> you could always just say return ()
02:40:28 <deteego> ah right
02:40:31 <deteego> thanks
02:40:53 <handonson> i, too, often find myself writing "_ -> return ()" at the end of a case statement
02:41:26 * ManateeLazyCat pasted "maybe library" at http://paste2.org/get/985044
02:41:27 <ManateeLazyCat> handonson: Above is my maybe library. 
02:41:41 <ManateeLazyCat> handonson: Maybe you like ?>= 
02:41:54 <ManateeLazyCat> handonson: Ignore Nothing branch.
02:42:35 <handonson> huh. :)
02:43:08 <Blkt> good day everyone
02:43:10 <ManateeLazyCat> dom96: I fix it.
02:43:20 <ManateeIrcClient> Haskell 万岁!
02:43:27 <ManateeLazyCat> Cool, my baby.
02:43:31 <dom96> nice
02:44:21 <ManateeLazyCat> dom96: I still use Char8.ByteString, just change gtk2hs APIs that accept ByteString argument.
02:45:43 <vanadium> how?
02:46:03 <ManateeLazyCat> dom96: I guess is Char8.pack and Char8.unpack cut unicode information.
02:46:15 <Zao> C8 truncates.
02:46:21 <dom96> oh
02:46:31 <handonson> yeah. C8.pack and C8.unpack doesn't round-trip
02:46:36 <ManateeLazyCat> dom96: If i avoid unpack/pack, then haven't those problem.
02:46:48 * Phyx- wonders if his irc bot still works
02:46:55 <Phyx-> probably not since my sql server is down
02:47:41 <ManateeLazyCat> dom96: Because i change gtk2hs APIs, now it can support any encoding, and don't care the encoding of IRC message.
02:47:50 <dom96> ugh, how can i get an 'elysia: <socket: 8>: hGetLine: end of file' when i check whether the socket isEOF :\
02:48:32 <ManateeLazyCat> dom96: Automatic reconnect? :p
02:48:45 <ddarius> Your file doesn't end in a newline character (?)
02:48:57 <dom96> i'm writing a server... so...
02:49:25 <dom96> oh, hrm. Unless....
02:49:42 <ManateeLazyCat> dom96: Maybe something is wrong....
02:49:59 <dom96> I just remembered i have another hGetLine there which isn't in that if block lol
02:50:04 * dom96 fails
02:51:08 <ManateeIrcClient> I love my new heart, works well... mmm....
03:07:30 <leod> is there some sort of tutorial for the Typeable / Dynamic / Generic stuff?
03:12:37 <Baughn_> So I've pretty much figured out *how* to use iteratees to read a file.
03:12:47 <Baughn_> What I'd like to know is.. why? Is there a motivating example somewhere?
03:13:06 <Baughn_> Because it looks a lot to me like I could just use the IO monad straight
03:13:18 <ManateeLazyCat> dom96: Now i understand, Char8 just cut unicode when you do some convert function (e.g. pack, unpack), directly use ByteString won't truncated.
03:13:44 <Baughn_> (..and have essentially the same code)
03:13:59 <dom96> ManateeLazyCat: oh
03:14:32 <ManateeLazyCat> dom96: Because IRC protocol is 8 bits, so Char8 is handy to parse protocol, just care don't use Char8 touch the context of IRC message.
03:15:18 <ManateeLazyCat> dom96: I guess you print ByteString in terminal, that why explain same code you can receive/send unicode message.
03:16:04 <handonson> ManateeLazyCat: Can I 'clear' a DrawWindow that has some stuff drawn on it with functions like drawLine?
03:17:23 <ManateeLazyCat> handonson: You use Cairo APIs draw something DrawWindow, so you want redraw DrawWindow?
03:17:33 <Baughn_> dom96: Technically, IRC allows only pure ASCII..
03:17:47 <Baughn_> Not that anyone was satisfied with that
03:17:56 <dom96> I know
03:18:05 <ManateeLazyCat> Baughn_: But many irc client send many other character-set, like utf-8
03:18:27 <dom96> yeah, or some other character-set ...
03:18:47 <handonson> ManateeLazyCat: err, no. I draw with Grapchis.UI.Gtk.Gdk.Drawable.drawLine and want to erase it afterwards.
03:18:49 <Baughn_> ManateeLazyCat: 知 っています
03:20:57 <ManateeLazyCat> handonson: You can use widgetQueueDrawArea redraw widget.
03:22:52 <ManateeLazyCat> widgetQueueDrawArea :: WidgetClass self => self -> Int -> Int -> Int -> Int -> IO ()                                        
03:22:52 <ManateeLazyCat>  
03:24:21 <ManateeLazyCat> handonson: If you need draw line, you need hang drawLine in signal 'exposeEvent', like '  widget `after` exposeEvent $ tryEvent $ liftIO $ ... drawLine ...."
03:25:05 <ManateeLazyCat> handonson: If you don't hang drawLine after signal 'exposeEvent', widget will redraw(area) some area when you call widgetQueueDrawArea
03:25:16 <handonson> ManateeLazyCat: yeah. i stumbled a little bit to figure that out, wondering why the lines didn't show up. :)
03:26:05 <ManateeLazyCat> handonson: Note, use `after` exposeEvent and don't use `on`, for better performance...
03:26:37 <handonson> that's a great tip. thanks again. :)
03:26:45 <ManateeLazyCat> handonson: NP. :)
03:27:35 <ManateeLazyCat> handonson: Another suggestion : use Gdk.EventM monad to handle gtk event, don't use Gdk.Event (has departed)...
03:28:09 <ManateeLazyCat> handonson: EventM catch failed exception automatic, don't need return Bool value like Gdk.Event.
03:28:34 <ManateeLazyCat> handonson: Detail, see the documentation of EventM (http://hackage.haskell.org/packages/archive/gtk/0.11.2/doc/html/Graphics-UI-Gtk-Gdk-EventM.html)
03:28:45 <ManateeLazyCat> brb to dinner, back soon...
03:30:04 <ManateeLazyCat> handonson: I need dinner now, if you have any gtk2hs question, leave message to me, i will answer later. .. :)
03:30:17 <handonson> ManateeLazyCat: enjoy your dinner. :)
03:34:42 * mux wonders what's new in tagsoup 0.11
03:43:55 <illissius> hmm
03:44:23 <illissius> using two's complement for negatives doesn't work if the representation is bitstrings of arbitrary length, right?
03:47:47 <handonson> nope, right.
03:49:13 <Axman6> 0-1 ends up being an infinite string of 1's then, i think
03:49:44 <ManateeIrcClient> Upgrade nick highlight module.....
03:50:23 <illissius> well supposedly it's an "N-bit" two's complement
03:50:28 <illissius> and N would have to be infinite
03:51:14 <illissius> could it work with a marker at the end for "infinite number of 1s from here"? (you already have that implicitly for 0s)
03:51:32 <Axman6> then you can't use binary though
03:51:54 <Axman6> you need something distinct from both 1 and 0 to know if you've reached that point
03:52:05 <Axman6> it may just be a number that keeps going on
03:52:10 <illissius> oh, that's a point
03:52:35 <illissius> but suppose I'm not physically using binary but the typesystem =)
03:52:37 <illissius> and so i can do that.
03:53:06 <dom96> Is there an easy way to parse JSON into a Map?
03:53:11 <Axman6> although, you may be able to get around that by having a special sequence of bits, that will never actually occur in a valid number (PPP does something like this, there's a special byte which marks the beginning and end of the frame, and is quaranteed never to occur in the frame, because they add another special byte infront of it, and then flip the 5th bit)
03:53:29 <bremner> see also, UTF8
03:53:47 <Axman6> dom96: hae you read Real World Haskell?
03:53:50 <Axman6> have*
03:54:01 <dom96> yes, i don't want to parse JSON manually.
03:54:05 <illissius> (so basically a type-level list of type-level True/False -- so I can reasonably easily put in something to represent the rest being infinite 1s rather than 0s, -if- that would work.)
03:54:06 <dom96> I want a library which does it for me.
03:54:16 <dom96> (I've looked at the json package)
03:54:43 <Axman6> well, my understanding of JSON is that it doesn't map particularly well to just a Map
03:55:31 <dom96> I don't see why the json package turns everything into JSValue, JSBool etc. Why not use haskells types?
03:56:07 <Axman6> it does, but they need to be wrapped to make the datatype work
03:56:21 <Axman6> you can;t have a map that holds both Bools and other JSValues
03:56:26 <Axman6> what would its type be?
03:56:36 <dom96> ahh, good point.
03:56:54 <dom96> But parsing JSON with it is very hard.
03:57:00 <Axman6> really?
03:57:13 <dom96> Unless i'm doing it some hard way.
03:57:16 <Axman6> you don't just give it a string, and get back a JSValue?
03:57:34 <dom96> i do
03:58:03 <aristid_> Text.JSON? i don't think it's particularly hard to use
03:58:22 <dom96> I use runGetJSON
03:58:31 <dom96> Don't know if thats right?
03:58:33 <aristid_> dom96: why don't you use encode/decode?
03:59:27 <dom96> aristid_: hrm, i suppose i should use that.
04:00:24 <dark> curiosity: it seems that do notation is suitable for doing a lot of imperative stuff. what if one wanted to write an imperative for or while, what's the best syntactic sugar one could get?
04:01:01 <Botje> :t while
04:01:03 <lambdabot> Not in scope: `while'
04:01:04 <Botje> boo
04:01:09 <ManateeLazyCat> dark: I use mix style. :) Some pure, some imperative...
04:01:30 <Botje> dark: writing something like while :: m Bool -> m b -> m () is not hard
04:01:46 <Axman6> dark: forM
04:01:49 <Axman6> :t forM
04:01:50 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m [b]
04:01:56 <ManateeLazyCat> :t forM_
04:01:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
04:01:59 <dark> yes, but how would be the syntax?
04:02:05 <Botje> dark: however; the m Bool would almost certainly have to use some kind of mutable crap
04:02:10 <dark> I mean, lazy evaluation can actually handle this pretty well
04:02:11 <Axman6> so, you can write: forM [a..b] $ \x -> do ...
04:02:39 <dom96> wow, it gives the exact same output...
04:03:27 <dark> Axman6,  hm
04:03:37 <dom96> https://gist.github.com/32031874772302163b97 I never know how to start parsing something like this...
04:03:50 <Botje> carefully! :)
04:04:23 <dom96> it's really confusing :(
04:04:44 <Botje> dom96: prettyprinting it first would be a good bet
04:04:54 <Axman6> pretty print it... using some kind of human readable representation
04:04:56 <ManateeLazyCat> dom96: Use groom print it.
04:04:59 <Axman6> i suggest JSON :P
04:05:05 <dom96> lol
04:05:11 <ManateeLazyCat> @hoogle groom
04:05:12 <lambdabot> No results found
04:05:16 <dom96> That should help.
04:05:17 <ManateeLazyCat> :t groom
04:05:19 <lambdabot> Not in scope: `groom'
04:05:59 <ManateeLazyCat> dom96: putStrLn will flood your terminal when print complex structure...
04:06:24 <dom96> it's fine. I got it on PostBin anyway.
04:06:36 <dark> can't I do fromIntegral to convert an integer to string/
04:06:41 <dark> (well, "show" works)
04:07:01 <mauke> :t fromIntegral
04:07:02 <lambdabot> forall a b. (Integral a, Num b) => a -> b
04:07:09 <mauke> I don't think String is a Num
04:07:28 <yitz> mauke: i hope hot
04:07:32 <yitz> s/hot/not
04:07:52 <ben_m> I wish I could write `foo (x:x:xs) = ...` instead of `foo (x:y:ys) | x == y = ...`, like in Erlang.
04:08:38 <mauke> foo xs@(_ : xs) =
04:08:49 <ben_m> Huh.
04:08:56 <kingping> Hello
04:09:16 <ben_m> mauke: Idea is that the first two elements in the pattern are the same.
04:09:29 <mauke> I know?
04:09:33 <ben_m> wtf :D
04:09:58 <mauke> my pattern either fails to match or loops forever
04:13:20 <Axman6> mauke: i've never seen a good reason not to allow that Erlang style syntax, until now, thanks :)
04:14:06 <yitz> ben_m: there's always a trade off between error checking and keystrokes
04:14:19 <kingping> !log
04:14:27 <Axman6> :\
04:14:30 <mauke> !exp
04:14:41 <bremner> !wtf
04:14:55 <Axman6> !strict
04:14:58 <mauke> preflex: calc 2 log 1000
04:14:58 <preflex>  9.965784284662087
04:15:01 <Axman6> ~lazy
04:15:01 <kingping> :D  wanted to know the subj mentioned about Erlang
04:15:33 <yitz> ben_m: I wish I could write `foo (x:x:xs) = ...` instead of `foo (x:y:ys) | x == y = ...`, like in Erlang.
04:16:23 <yitz> kingping: ^^ that was the topic. sorry, i guess colloquy isn't very good at quoting previous messages.
04:16:30 <kingping> Uhm, that syntax comes to Erlang from Prolog, right? What's wrong with that?
04:17:11 <kingping> (once I tried to apply it to Haskell though:)
04:17:35 <yitz> > let foo (x:x:xs) = xs in foo  [1,1,2,3]
04:17:36 <lambdabot>   Conflicting definitions for `x'
04:17:37 <lambdabot>  In the definition of `foo'
04:18:02 <illissius> interestingly it works for type functions though :)
04:18:18 <illissius> though problem there is you can't say what to do _otherwise_, because you can't have overlap
04:19:23 <ben_m> > let foo xs@(_ : xs) = xs in foo [1,1,2,3]
04:19:25 <lambdabot>   Conflicting definitions for `xs'
04:19:25 <lambdabot>  In the definition of `foo'
04:19:55 <mauke> > let foo xs@(_ : xs') | xs == xs' = xs in foo [1,1,2,3]
04:19:56 <lambdabot>   *Exception: <interactive>:1:153-185: Non-exhaustive patterns in function foo
04:20:00 <jkarlson> Axman6: should language disallow making programs that do not work
04:20:06 <mauke> > let foo xs@(_ : xs') | xs == xs' = xs in foo (repeat 1)
04:20:13 <lambdabot>   mueval: ExitFailure 1
04:30:36 <ManateeLazyCat> @hoogle md5
04:30:38 <lambdabot> Network.Browser AlgMD5 :: Algorithm
04:30:38 <lambdabot> Network.Browser AlgMD5sess :: Algorithm
04:30:38 <lambdabot> Network.HTTP.Headers HdrContentMD5 :: HeaderName
04:34:53 <ManateeLazyCat> @hoogle "md5 :: ByteString -> String"
04:34:54 <lambdabot> Parse error:
04:34:54 <lambdabot>   --count=20 ""md5 :: ByteString -> String""
04:34:54 <lambdabot>              ^
04:35:09 <ManateeLazyCat> @hoogle md5 :: ByteString -> String
04:35:10 <lambdabot> No results found
04:36:00 <Axman6> @hoogle md5
04:36:00 <lambdabot> Network.Browser AlgMD5 :: Algorithm
04:36:01 <lambdabot> Network.Browser AlgMD5sess :: Algorithm
04:36:01 <lambdabot> Network.HTTP.Headers HdrContentMD5 :: HeaderName
04:36:26 <ManateeLazyCat> @hoogle md5sum
04:36:27 <lambdabot> No results found
04:38:33 <ManateeLazyCat> Data.Digest.OpenSSL.MD5.md5sum is my need
04:42:09 <dom96> ManateeLazyCat: thanks for recommending groom, it's awesome :D
04:42:26 <ManateeLazyCat> dom96: I use groom parse irc data. :)
04:43:51 <Zao> Axman6: http://pastie.org/1153587
04:43:53 <dark> ManateeIrcClient, isn't cryptohash somewhat better?
04:43:54 <Zao> Axman6: Easier than I thought :)
04:46:00 <ManateeLazyCat> dark: I try.....
04:47:41 <dark> would like to know which is faster
04:47:52 <ManateeLazyCat> dark: I'm testing... :)
04:48:28 <leod> so, using existential quantification and typeclasses you can do dynamic dispatch. is there a similar way to do multiple dispatch?
04:49:02 <dark> I think a typeclass with more than one parameter naturally gives multiple dispatch
04:49:43 <Heffalump> yes, if unconstrained by fundeps
04:49:51 <dark> fundeps?
04:49:58 <leod> yes, but.. hm
04:50:04 <Heffalump> functional dependencies
04:50:18 <dark> escapes my comprehension
04:50:56 <dark> wikipedia talks about databases
04:51:01 <dark> but i think i got it
04:51:17 <dark> haskell wiki has an entry about this, too
04:51:27 <leod> but is it dynamic? I have 'data AnyEntity = forall a. Entity a => AnyEntity a' and now i'd somehow like a typeclass '(Entity a, Entity b) => Collision a b' which dynamically dispatches on two AnyEntity
04:51:38 <leod> if that makes any sense at all
04:52:33 <dark> well, types are static in haskell..
04:53:50 <dark> they are resolved at compile-time.. so dispatches that depends on types are resolved at compile-time too. but one could still choose dynamically by doing pattern matching
04:54:12 <leod> well, using existential quantification you *can* do dynamic dispatch
04:55:25 <leod> like this http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
04:59:40 <ManateeLazyCat> dark: Data.CryptoHash.MD5 is faster
05:00:31 <ManateeLazyCat> dark: 100000 times : Data.Digest.OpenSSL.MD5.md5sum need 1.86s,  Data.CryptoHash.MD5.hash need 1.01s
05:02:08 <dark> hm. @.@
05:02:23 <ManateeLazyCat> dark: I switch to Data.CryptoHash.MD5.hash now . :)
05:02:58 <arw> openssl is severely underoptimized in many places.
05:03:13 <dark> leod, forget what I said. I'm slightly confused now
05:03:24 <leod> ok heh
05:03:53 <ManateeLazyCat> arw: You mean OpenSSL is better?
05:04:26 <ManateeLazyCat> arw: I just need MD5 value, have difference?
05:04:33 <arw> ManateeLazyCat: no, on the contrary. if you want something fast, don't use openssl.
05:05:28 <arw> ManateeLazyCat: we do a yearly contest in one lecture where people have to bruteforce md5 password hashes. even the most clueless get it a factor of 2 faster than openssl.
05:05:52 <burp> http://www.peereboom.us/assl/assl/html/openssl.html
05:06:26 <Heffalump> leod: hmm. I think you're right, in that you can't do it that way.
05:06:43 <leod> yea
05:06:46 <Heffalump> because the trick with existentials is that the dispatch result is actually wrapped up in the existential
05:07:31 <ManateeLazyCat> arw: I think i will use Data.CryptoHash.MD5, i use it get unique color value for every nick in my irc client.
05:07:41 <leod> hmm
05:08:52 <arw> ManateeLazyCat: well. not the most performance- or security-critical application :)
05:09:26 <ManateeLazyCat> arw: Yep. :)
05:09:59 <arw> ManateeLazyCat: why not crc32? simpler, faster and good enough i would guess?
05:10:20 <arw> on the other hand, it really doesn't matter.
05:11:53 <Heffalump> leod: I think you just need to add something to the Entity class that expresses it.
05:12:06 <Heffalump> i.e. some member that then dispatches on the second value.
05:12:15 <dark> ManateeIrcClient, xchat has too few colors, so there is a lot of collisions. but too much colors would be confusing. confusing is also when someone change nick, and his color changes. but oh well
05:12:19 <burp> what about sum of digits? :D
05:12:39 <Heffalump> the trouble is that the Collision a b dictionary has to be found somehow
05:13:11 <ManateeLazyCat> arw: I need got 12 length string for every nick, like (substring (md5 "ManateeLazyCat") 0 12) is "49301122e1da", then i split with [4930, 1122, e1da], convert hex volue to #RRGGBB, then it's color.
05:13:22 <arw> dark: the nickchange-problem is easy. just hash the ident and hostname, not the nick.
05:13:42 <Nibble> ManateeLazyCat: great that you aren't overdoing it or something.
05:13:51 <Nibble> that would be shamefull
05:13:55 <burp> are you sure you don't want just the usual 16 irc colors?
05:14:14 <arw> there are terminals that can do 256 colors :>
05:14:15 <ManateeLazyCat> burp: I'm build gtk irc client.
05:14:42 <ManateeLazyCat> burp: http://www.flickr.com/photos/48809572@N02/4943815462/lightbox/
05:15:02 <burp> ManateeIrcClient: ok
05:15:34 <ManateeLazyCat> burp: So gtk irc color will support many color than 256. :)
05:15:52 <Nibble> arw: urxvt
05:16:08 <burp> I was just thinking of xchat, which has color support too, but also just uses 16 colors
05:16:37 <arw> ManateeLazyCat: but you need to take care of the problem that the nick-color might be the same or similar to the background color
05:16:46 <ManateeLazyCat> burp: Infact i have write some elisp extension for erc (irc client for emacs), just clone elisp algorithm to haskell.
05:16:47 <arw> ManateeLazyCat: or you get invisible people
05:17:16 <ManateeLazyCat> arw: I will invert color if it similar to background color.
05:17:28 * ManateeLazyCat pasted "erc-highlight-nicknames.el" at http://paste2.org/get/985168
05:17:34 <ManateeLazyCat> arw: Above is my elisp version.
05:18:12 <ManateeLazyCat> arw: When too dark or too light, invert color.....
05:18:18 <illissius`> leod: what exactly do you need again?
05:18:57 <dark> ManateeIrcClient, consider following the arw's ident/hostname suggestion.=)
05:19:19 <ManateeLazyCat> dark: So you need use speical color track someone?
05:19:56 <dark> hm no it's just that namechanges are confusing
05:20:09 <ManateeLazyCat> dark: Joking, i will consider it.
05:21:25 <ManateeLazyCat> dark: Hash ident/hostname is good idea.... 
05:21:42 <dark> something else i would do if i were making my own client is to leave comments on people. like a mini-buffer where i could write who someone is. (at pidgin, I use the "nickname/alias" field for that)
05:22:15 <dark> (but mostly because of the annoying msn nicks)
05:24:51 <ManateeLazyCat> dark: After i finish color-nick, http://www.flickr.com/photos/48809572@N02/4982618092/lightbox/ will much beautiful, then tag different color for different type message.
05:26:23 <dark> ManateeIrcClient, how to run the 'ghci mode' at emacs?
05:27:18 <dark> actually, http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
05:27:27 <ManateeLazyCat> dark: You need install haskell-mode first.
05:27:57 <ManateeLazyCat> dark: Then type C-c C-l (haskell-ghci-load-file)
05:28:18 <ManateeLazyCat> dark: Then ghci-mode will load.
05:28:43 <ManateeLazyCat> dark: But if you want interactive with ghci, best run ghci in my multi-term.el
05:32:20 <dark> I typed some C-c C-l in sequence and it hanged
05:32:33 <ManateeLazyCat> Or some hash function like this "hash :: String -> [Int, Int, Int]" Int between 0~255
05:34:13 <ManateeLazyCat> dark: My suggestion, you write some elisp code that call multi-term-dedicated-open and send "ghci" ":m HaskellFilePath.hs" to multi-terme.el
05:34:31 <siracusa> ManateeLazyCat: Hi! I have a Gtk problem on Windows, can you please test what's the output of this program on linux? http://pastebin.com/EVYh6H3U
05:34:31 <lambdabot> siracusa: You have 1 new message. '/msg lambdabot @messages' to read it.
05:34:43 <ManateeLazyCat> siracusa: Sure.
05:35:05 <Olathe> @pl \o (n:ns) -> (o:n):ns
05:35:06 <lambdabot> (`ap` tail) . (. head) . ((:) .) . (:)
05:37:55 <ManateeLazyCat> siracusa: I have test,     No instance for (Integral (Ptr a)) arising from a use of `fromNativeWindowId' at Main.hs:31:43-60. If you change getWidgetWindowID to "getWidgetWindowID w = drawableGetID =<< widgetGetDrawWindow w", problem fix.
05:38:19 <ManateeLazyCat> siracusa: Still hacking embedded gtk program? ;p
05:39:10 <siracusa> ManateeLazyCat: Yep. It compiles on windows. It's strange that fromNativeWindowId has different types on different systems. What's the output?
05:39:13 <ManateeLazyCat> siracusa: After i change code on Linux, output : 
05:39:14 <ManateeLazyCat> NativeWindowId 73400323
05:39:15 <ManateeLazyCat> NativeWindowId 73400352
05:39:17 <ManateeLazyCat>  
05:40:47 <siracusa> Ok, thanks. The problem on Windows is, if both IDs are the same, the embedded video looks bad if there are other widgets in the windows.
05:40:57 <ManateeLazyCat> siracusa: drawableGetID is hacking API i add in gtk2hs, it's not native gtk+ API
05:41:34 <ManateeLazyCat> siracusa: So embedded program can work on Windows? ;p
05:41:51 <ManateeLazyCat> siracusa: I even haven't test drawableGetID on Windows.
05:42:10 <siracusa> ManateeLazyCat: It works, but only if there is no other widget than the drawing area. :-(
05:42:36 <dark> ManateeLazyCat, what is multi-term-dedicated-open?
05:42:44 <ManateeLazyCat> siracusa: Strange, i even develop some mplayer-video-client, mix drawWindow with some button, works.
05:42:57 <dark> it's like a 'child' window from current window?
05:43:15 <ManateeLazyCat> dark: multi-term-dedicated-open is dedicate window in Emacs, it won't close by command "close window"...
05:43:35 <ManateeLazyCat> dark: As it's name, "dedicated window" 
05:43:57 <dark> I would like to open it if it weren't opened, and run ghci, but don't just send :e file if it's already open (so it would be more like tuareg or slime)
05:44:08 <dom96> How do i get rid of the 'un-initialized record fields' warnings?
05:44:14 <ManateeLazyCat> dark: IMO, "dedicated window" is not perfect way to display complex layout.
05:44:31 <handonson> with STM, i want to read a TVar, do some IO operation (which depends on the TVar) and write. i want the whole read-operate-write to be atomic. how can i do this?
05:44:47 <dark> http://home.arachsys.com/~chris/haskell-ghci.el
05:45:00 <ManateeLazyCat> dark: Code below multi-term.el, i write many advice protected dedicated window won't close by other window.
05:45:37 <Lemmih> handonson: Is the IO action atomic?
05:46:06 <handonson> what is an atomic IO action?
05:47:07 <Lemmih> handonson: Does it have any side-effects?
05:47:29 <handonson> yes. which is why it's IO, i guess... 
05:47:53 <Lemmih> handonson: Then it can't be done.
05:48:15 <handonson> just curious, how can it be done when it doesn't have any side-effects?
05:48:19 <ManateeLazyCat> @hoogle ptrToIntPtr
05:48:20 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
05:48:54 <hpc> @hoogle TVar a -> (a -> b) -> TVar b
05:48:55 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
05:48:55 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
05:48:55 <lambdabot> Control.Monad fmap :: Functor f => (a -> b) -> f a -> f b
05:49:05 <ManateeLazyCat> siracusa: So getWidgetWindowID will return right WindowId on Windows? 
05:49:08 <Lemmih> handonson: There's an 'unsafeIOToSTM' function.
05:49:17 <handonson> eww. i see.
05:49:23 <Axman6> handonson: depends on the IO action. its side effects may not affect the STM variables, so I would call it atomic, in a sense
05:49:40 <Lemmih> ?type GHC.Conc.unsafeIOToSTM
05:49:41 <lambdabot> forall a. IO a -> GHC.Conc.STM a
05:50:15 <Lemmih> handonson: Your IO action may be invoked multiple times if you use that function, though.
05:50:33 <siracusa> ManateeLazyCat: It returns an IntPtr. Or what do you mean?
05:50:38 <Axman6> unsafeIOToSTM is quite handy for debugging
05:50:43 <handonson> i think i'll just use TMVars instead of TVars, then.
05:50:53 <ManateeLazyCat> siracusa: I mean IntPtr can work?
05:51:05 <ManateeLazyCat> siracusa: Maybe i need change gtk2hs code to adjust return value.
05:51:39 <siracusa> ManateeLazyCat: For mplayer it works, because it can be converted to an Int.
05:52:14 <ManateeLazyCat> siracusa: Can you test vim? Vim support XEmbedded protect too.
05:52:30 <ManateeLazyCat> siracusa: If mplayer and vim both can work, IntPtr is right value.
05:53:21 <siracusa> ManateeLazyCat: Let me see if I find a Windows version ... 
05:53:30 <ManateeLazyCat> siracusa: Okay, thanks.
05:54:51 <ManateeLazyCat> s/protect/protocol
05:55:47 <ManateeLazyCat> siracusa: About other widget issue, i think somewhere is wrong.
05:56:10 <handonson> Lemmih: do you have any intention to make SDL-gfx, SDL-image, and SDL-ttf work on Windows?
05:56:14 <Nibble> ManateeLazyCat: could you link to your album again
05:56:34 <ManateeLazyCat> siracusa: Maybe you can send your code to me, then i help you test on linux, and see what happen.
05:56:40 <ManateeLazyCat> Nibble: http://www.flickr.com/photos/48809572@N02/
05:57:05 <Lemmih> handonson: I don't have access to a Windows box but I will accept patches readily.
05:58:30 <siracusa> ManateeLazyCat: IMO the problem is that the window and the drawing area both have the same ID, so the video is drawn into the complete window not only into the drawing area. But this seems to be an Gtk+ or Windows  problem, I have no idea how to fix that.
05:59:16 <handonson> I've tried a couple of days ago, and couldn't apply the trick that worked for SDL... wasted a day
06:01:05 <Lemmih> handonson: I would have imagined that getting the auxiliary libraries to work would be easier than manhandling the core library into submission.
06:01:34 <ManateeLazyCat> siracusa: Do you mind multiple-processes model?
06:01:38 <handonson> huh?
06:01:48 <handonson> i'm sorry, i don't understand
06:02:19 <Lemmih> handonson: TL;DR: Tough luck.
06:02:51 <ManateeLazyCat> siracusa: My solution is add GtkSocket in your top-window in main process, then startup child process add GtkPlug in it. then add DrawingArea in GtkPlug.
06:03:47 <ManateeLazyCat> siracusa: Because GtkSocket and GtkPlug in different process, GtkPlug will return different windowId to embedded mplayer.
06:04:59 <siracusa> ManateeLazyCat: Ok, this sounds interesting. .. I installed vim, how can I test XEmbedded now?
06:06:22 <ManateeLazyCat> siracusa: IIRC, "vim --help" have an option is like "parent id" something, you pass WindowId as argument of vim, then vim will embedded it's graphics in your window.
06:06:51 <ManateeLazyCat> siracusa: I can embedded emacs, vim, mplayer on Linux.
06:07:14 <Nibble> ManateeLazyCat: what do yuo use that for?
06:07:38 <ManateeLazyCat> Nibble: Test gtk2hs API and my multiple-process framework.
06:07:51 <Nibble> I see
06:07:54 <ManateeLazyCat> Nibble: Infact, my project can't work before gtk-0.11.0
06:08:21 <ManateeLazyCat> Nibble: Like drawableGetID is i add in gtk2hs to support embedded X11 program....
06:09:49 <ManateeLazyCat> siracusa: Infact, natural way is create GtkSocket, and pass id of GtkSocket to mplayer or vim.
06:10:55 <ManateeLazyCat> siracusa: Maybe some secret trick of GtkSocket/GtkPlug, you need create GtkPlug first, and get PlugId to create GtkSocket. otherwise some x11 program can't work.
06:12:19 <ManateeLazyCat> siracusa: Right way is, use child process build GtkPlug, then return PlugId to main process, then create GtkSocket.
06:13:03 <ManateeLazyCat> siracusa: If you create GtkSocket first, then pass SocketId to child process to create GtkPlug, can't work always...
06:13:46 <ManateeLazyCat> siracusa: I think the reason is multiple-processes *race condition* with GtkSocket/GtkPlug.
06:14:13 <siracusa> ManateeLazyCat: Cool, I have embedded gvim to my program :-) But the same problem, it draws over the button. .. I will test socket/plug later today, I'll tell you if it worked.
06:14:29 <fserb> I'm having a problem trying to install crypto-4.2.1, compilation fails because of a "multiple instance declarations" on QuickTest.hs, does anyone had the same problem or would know how'd I proceed to try to solve this?
06:15:12 <ManateeLazyCat> siracusa: When you create GtkSocket and get id with socketGetId, at the time you pass to child process, GtkSocket maybe not realize finish, when you use plugNew with SocektId create GtkPlug, GtkPlug can't find GtkSocket with SocketId.
06:15:34 <ManateeLazyCat> siracusa: Then embedded code will failed.
06:15:37 <Saizan> fserb: i'm guessing that you need to specify an earlier version of QuickCheck using the --constraint flag
06:16:12 <Saizan> fserb: but it'd be easier if you reported which class/instances are causing the error
06:16:13 <ManateeLazyCat> siracusa: So the stable way is you build GtkPlug in child process first, then use some IPC return PlugId to main process, use PlugId create GtkSocket, always works.
06:16:55 <ManateeLazyCat> siracusa: Note, GtkSocket and GtkPlug must in different top-level (different processes), otherwise you will got same windowId...
06:19:20 <siracusa> ManateeLazyCat: By two processes you mean forkIO or forkOS?
06:19:42 <ManateeLazyCat> siracusa: Use runCommand
06:19:51 <ManateeLazyCat> @hoogle forkProcess
06:19:52 <lambdabot> No results found
06:20:06 <ManateeLazyCat> siracusa: Don't use forkProcess
06:20:17 <fserb> Saizan: the error goes like this: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29922#a29922 no idea where to report to though...
06:20:19 <Olathe> If I have a newtype Whatsit = Whatsit Word8, is it better to use data Whatsit = Whatsit !Word8 with -funbox-strict-fields?
06:20:24 <ManateeLazyCat> siracusa: I have write detail reason at "gtk2hs/gtk/demo/embedded/Notes.txt"
06:20:33 <fserb> Saizan, I'll try the constrain 
06:21:03 <ManateeLazyCat> siracusa: runCommand use MVar protected two processes won't *race condition", but forkProcess haven't any protected.
06:21:45 <ManateeLazyCat> siracusa: runProcess and runCommand are good function to spawn child process
06:22:51 <ManateeLazyCat> siracusa: Looks your (ptrToIntPtr . fromNativeWindowId) is right, can you do more test with multiple-processes? After then i change gtk2hs code, okay?
06:23:26 <siracusa> ManateeLazyCat: Oh, I'll need two different Haskell programs and the second calls the first by runCommand?
06:25:25 <ManateeLazyCat> siracusa: main process use runCommand spawn child process, use "plugNew Nothing" create GtkPlug, then use plugGetId get id of GtkPlug, use some IPC (e.g. DBus) return plugId to main process, then "socketNew" and "socketGetId" create GtkSocket.
06:25:38 <ManateeLazyCat> siracusa: Looks complicated, but works well.
06:26:04 <siracusa> ManateeLazyCat: Is ther no demo for socket/plug?
06:26:18 <ManateeLazyCat> siracusa: AFAIK, it's only *stable* way to embedded program from another process.
06:27:00 <ManateeLazyCat> siracusa: I use DBus communication with multiple processes, and complete demo very complicated, so i haven't add it in gtk2hs repository.
06:27:41 <Saizan> fserb: heh, it seems hpaste went down just now :)
06:30:45 <ManateeLazyCat> siracusa: Wait.....
06:31:45 <ManateeLazyCat> siracusa: My project's logic is very complex, but i think paste some code snippets will help you understand my design.
06:32:32 <ManateeLazyCat> siracusa: newTabInternal in https://patch-tag.com/r/AndyStewart/manatee/snapshot/current/content/pretty/Manatee/Action/Tab.hs 
06:32:51 <ManateeLazyCat> is main process use runProcess spawn child process.
06:33:38 <ManateeLazyCat> siracusa: renderMain in https://patch-tag.com/r/AndyStewart/manatee/snapshot/current/content/pretty/Manatee/Render.hs
06:34:04 <ManateeLazyCat> siracusa: Is child process build GtkPlug and return PlugId to main process...
06:34:39 <ManateeLazyCat> siracusa: daemonHandleNewPageConfirm in https://patch-tag.com/r/AndyStewart/manatee/snapshot/current/content/pretty/Manatee/Daemon.hs
06:34:57 <ManateeLazyCat> siracusa: Above is main process catch plugId from child process, then use plugId build GtkSocket.
06:35:14 <ManateeLazyCat> siracusa: Then any program can embedded in main process...
06:36:07 <ManateeLazyCat> siracusa: Maybe best way is search 'socketNew' and 'plugNew' in my code.
06:36:51 <ManateeLazyCat> siracusa: But my project have many other feature around basic framework, it's not best demo to describe my idea.
06:37:38 <siracusa> ManateeLazyCat: Ok, thanks. I'll look at it.
06:37:39 <ManateeLazyCat> siracusa: Sorry, i'm quite busy now, haven't time write simple demo, but it's not hard you re-implement it.
06:39:51 * ManateeLazyCat Maybe i will write some blog to explain this framework....
06:40:10 <ManateeLazyCat> Many trick hide in GtkSocket and GtkPlug.
06:44:45 <ManateeLazyCat> siracusa: If you have linux, you can download gtk2hs and my project (http://patch-tag.com/r/AndyStewart beginning with mantee-*), and play it, then you know 'multiple-processes GtkSocket/GtkPlug" how to work.
06:45:12 <ManateeLazyCat> siracusa: I guess many detail can't work on Windows, so don't play it on Windows.
06:45:55 <ManateeLazyCat> siracusa: And i refuse Window patch now (haven't windows and haven't time)
06:46:22 <Olathe> What does __inline_me mean in core?
06:48:04 <mathijs> would haskell (without -threaded) behave like a reactor? I mean if I fire up 200 haskell threads, each waiting for input on a socket/fd, I essentially end up with 1 OS thread waiting for select() or epoll() on those socket/fds richt?
06:50:43 <Axman6> mathijs: i think that's about right
06:53:01 <mathijs> ok... so no (big) overhead for creating threads in that case like in most languages. a haskell thread is just a programming concept that might turn into a real os thread, or stay simple like a 'fiber' that executes when needed
06:54:06 <Axman6> even with -threaded, haskell threads are extremely lightweight
06:54:26 <Axman6> and without -threaded, you can get some very good performance
06:55:02 <fserb> Saizan, is it? It seems to be working for me
06:56:11 <ManateeLazyCat> Axman6: "even with -threaded, haskell threads are extremely lightweight" ?
06:56:25 <mathijs> well in most languages, switching from threads to a reactor, is a major speedup, since no time is spent on waiting/polling. Of course to make use of multiple execution threads (cores), runnning a reactor per core is useful. So in haskell this is kind of like automatically?
06:56:26 <sshc> Which function should I use for a more efficient implementation of concatMap that uses parallelism?  I think it's also referred to as mapReduce
06:56:35 <Axman6> well, they're even more lightweight without -threaded
06:56:40 <sshc> Is there already an implementation that I can use, or do I need to write it myself?
06:56:49 <copumpkin> sshc: mapReduce (++) [] :P
06:56:51 <fserb> Saizan, --constraint 'QuickCheck == 2.1.1.1" solved for me.
06:57:06 <Saizan> fserb: ah, ok :)
06:57:14 * copumpkin goes back to sleep
06:57:16 <handonson> ManateeLazyCat: Can I turn a DrawWindow (or DrawingArea) to a Pixbuf?
06:57:27 <sshc> copumpkin: *Where* is mapReduce exported?
06:57:28 <ManateeLazyCat> mathijs: Haskell's lightweight thread and STM is my favourite feature.
06:57:41 <copumpkin> sshc: I was just making it up :P
06:57:42 <ManateeLazyCat> handonson: Sceenshot of widget? ;p
06:57:49 <Axman6> it's exported in a library i wrote recently, using concurrent lists...
06:58:01 <copumpkin> sshc: there's a parMap in Control.Parallel
06:58:10 <Axman6> but, i doubt it's actually good enough to get any kind of speed up
06:58:28 <Axman6> copumpkin: he needs a parallel reduction though
06:59:18 <mathijs> ManateeLazyCat: yeah, that's what I'm after.... just trying to determine if it's better to fork 4 processes (on a quadcore) and have them run without -threaded, or to have 1 process, with -threaded, and have haskell figure out what to do
06:59:23 <ManateeLazyCat> handonson: There have widgetGetSnapshot to get snapshot of widget with given rectangle.
06:59:57 <ManateeLazyCat> handonson: It's new APIs in darcs version, not exist in release version.
07:00:41 <copumpkin> Axman6: I guess he'll need the evil monoid dependency then!!
07:01:02 <ManateeLazyCat> handonson: If you want this APIs, you need wait gtk-0.12.0 release....
07:01:07 <mxc> hi..
07:01:12 <ManateeLazyCat> handonson: Or fetch darcs gtk2hs....
07:01:23 <Axman6> mathijs: i'd be inclined to form 4 threads... with -threaded :P
07:02:17 <mxc> having a strange issue trying to build yesod-0.5.0.3 (latest)..  running the command:
07:02:18 <mxc> runghc Setup.lhs configure --enable-library-profiling --enable-optimization --user; ... build; ... install
07:02:18 <mxc> works fine, but cabal install yesod fails with this error:
07:02:26 <handonson> ManateeLazyCat: thanks for the information.
07:02:27 <mxc> scaffold.hs:10:11:
07:02:27 <mxc>     cannot find normal object file `dist/build/yesod/yesod-tmp/CodeGenQ.o'
07:02:27 <mxc>     while linking an interpreted expression
07:03:27 <Saizan> mxc: what if you run "cabal clean && cabal install -p" from within the directory?
07:03:59 <mathijs> Axman6: yeah, but that runs the risk of the RTS scheduling threads strangely. My input stream is just requests that need to be handled by "workers". The workers/threads really don't have to communicate between each other or update global state. So no need for stm or mvars and locking
07:04:12 <mxc> saizan - ty. running it now. that -p switch is somehting i always forget about 
07:04:47 <mxc> saizan - same error as cabal install yesod
07:05:00 <Axman6> mathijs: sounds like exactly what you should be doing then
07:05:08 <mxc> oh, i have an idea
07:05:13 <Axman6> trust that things will get scheduled as they should be
07:05:32 <Saizan> do you have "documentation: True" in the config file?
07:05:50 <mxc> no, i think the problem is tha tI have executable-profiling: True in the config file
07:05:59 <mxc> but, my runghc command didn't have it
07:06:22 <mxc> and, the cabal snippet for the executable doesn't explicitly call require the TH extension
07:06:30 <mxc> yeah, that was the problem
07:06:32 <mathijs> Axman6: I'll have a try :)   and probably ghc7 will improve it further with epoll
07:06:36 <mxc> builds fine
07:06:49 <Axman6> sure, but it's not too bad at the moment anyway
07:07:18 <Axman6> don't forget people have been writing servers with hundreds of threads handling requests for quite some time, and getting quite good results indeed
07:08:21 <mxc> @seen snoyman
07:08:22 <preflex>  Sorry, I haven't seen snoyman
07:08:22 <lambdabot> Unknown command, try @list
07:14:05 <sshc> Why isn't Set made an instance of the Traversable class?
07:14:47 <benmachine> sshc: because Traversables are Functors, and Set isn't a Functor
07:15:51 <sshc> benmachine: Why isn't Set a functor?
07:15:58 <sshc> benmachine: Data.Set exports its own map function
07:16:02 <copumpkin> sshc: it can't be
07:16:07 <copumpkin> :t S.map
07:16:10 <lambdabot> forall a b. (Ord a, Ord b) => (a -> b) -> S.Set a -> S.Set b
07:16:19 <copumpkin> try as you may, you're not cramming that into fmap
07:16:38 <benmachine> sshc: a Functor can have its contents changed arbitrarily, i.e. it can hold any type
07:16:49 <benmachine> but Sets can't hold any type
07:16:49 <sshc> :t fmap
07:16:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:17:06 <copumpkin> it's sad
07:17:22 <benmachine> *Sets can't hold just any type
07:17:54 <mathijs> so that's basically a problem of the type system?
07:17:58 <sshc> "instance Functor S.Set where fmap = S.map" ?
07:18:06 <copumpkin> sshc: nope
07:18:11 <BONUS> :t fmap
07:18:13 <copumpkin> mathijs: sort of
07:18:13 <sshc> Why not?
07:18:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:18:16 <copumpkin> @hackage rmonad
07:18:16 <lambdabot> http://hackage.haskell.org/package/rmonad
07:18:25 <copumpkin> sshc: what about those Ord constraints on map?
07:18:28 <mathijs> sshc: fmap does not have a Ord constraint
07:18:28 <Axman6> fmap needs to work with all functions a -> b
07:19:00 <sshc> Oh
07:19:22 <mathijs> but a set is a functor in the mathematical sense right?
07:19:57 <benmachine> isn't a mathematical functor just a function from type to type?
07:20:50 <sshc> I wonder how could use S.map in parallel
07:21:17 <sshc> I'm not familiar with Haskell's parallelism
07:22:36 <benmachine> I think you'd need an S.parMap
07:22:53 <mathijs> benmachine: probably yes :)  but I mean the "something that can be mapped over" definition holds true for mathematical sets. Just not for Data.Set, which adds the Ord constraint.
07:23:10 <sshc> benmachine: Data.Set doesn't export parMap
07:23:18 <copumpkin> I imagine a general S.map in parallel would be hard
07:23:25 <copumpkin> but a mapMonotonic might be a lot easier
07:24:18 <copumpkin> that's also a way to make Set into a functor, if you promise not to fmap non-monotonic functions :)
07:24:20 <benmachine> sshc: well, I meant a hypothetical such thing
07:24:44 <benmachine> mathijs: I dunno, the thing with sets is mapping over the elements can change the size of the container
07:24:47 <sshc> copumpkin: I can't use mapMonotonic
07:24:48 <ManateeLazyCat> dark: ident/hostname is not perfect since hostname will change......
07:25:14 <benmachine> but I guess that actually wouldn't break the rules
07:25:20 <copumpkin> sshc: then it seems like a parallel map over the set, without first converting it to something else, might be quite difficult, but maybe it's possible
07:25:52 <mathijs> benmachine: I don't think there's a rule that for (a -> b) there should be a inverted (b -> a) available
07:26:06 <sshc> Hah.  S.map f = fromList . List.map f . toList
07:26:26 <benmachine> mathijs: but I'm used to thinking that fmap should not change the structure, just the values inside it
07:26:45 <benmachine> mathijs: but in terms of the laws I think it's not a problem
07:26:47 <mathijs> I agree
07:27:11 <benmachine> fmap id = id and fmap f . fmap g = fmap (f . g)
07:27:14 <sshc> Sounds terribly effecient
07:27:30 <Olathe> How do I get ghc to keep the intermediate .hc file when I do -fvia-C?
07:27:47 <mxc> if there was an AlmostFunctor class
07:28:08 <mxc> with afmap :: (a -> a) -> f a -> f a
07:28:10 <mxc> then you could do it
07:28:29 <Philippa> sshc: I'm not sure you can do any better, given that f will violate all your invariants previously
07:28:37 <copumpkin> mxc: how?
07:28:38 <benmachine> Olathe: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/separate-compilation.html#keeping-intermediates
07:28:59 <mxc> although i'm sure there's a much better, super obscure thing in category theory to call it
07:29:11 <ManateeLazyCat> arw: ident/hostname is not perfect way to unique nick color since hostname will change, better idea?
07:29:36 <Olathe> Ahh, thanks :)
07:30:11 <arw> ManateeLazyCat: you could use only ident or ident and ircname.
07:30:28 <mxc> nevermind, my fingers got ahead of my brain
07:30:46 <arw> ManateeLazyCat: but in certain special cases those can change, too, for example with certain web-to-irc gateways.
07:30:57 <ManateeLazyCat> arw: Yes.
07:31:00 <mxc> anyway, bedtime
07:31:09 <mxc> thanks saizan for the help earlier
07:31:11 <benmachine> copumpkin: well, with (a -> a) you're at least preventing the function from leaving Ord
07:31:12 <ManateeLazyCat> arw: So i think simplest way is track nick name.
07:31:25 <arw> ManateeLazyCat: and for many networks, the hostname or 'almost hostname' part is constant, so its not that much of a problem imho
07:31:33 <mxc> benmachine: yeah, thats what I was thinking, but you still coudln't do it within the haskell typesystem
07:31:34 <benmachine> or would that actually make sense
07:31:40 <benmachine> mxc: mm
07:31:55 <mxc> since the Ord constraint isn't on the Set type itself but rather every function that interacts with it
07:32:05 * benmachine wonders vaguely about GADTs where matching can introduce information, like constraints
07:32:16 <arw> ManateeLazyCat: well, depends. how important is constant colour to you?
07:32:19 <mxc> so if you have a value of type Set a, even though you can prove that a is an instance of Ord, the type system doesn't know it
07:32:29 <mxc> does that make sense?
07:33:00 <arw> ManateeLazyCat: i would create a table on join, assign colours by the initial nickname and write that colour entry to the nickname table.
07:33:01 <mxc> anyway, its bedtime
07:33:04 <mxc> goodnight all
07:33:06 <benmachine> it does, but I'm not convinced there isn't some sufficiently advanced magic that could be applied
07:33:12 <benmachine> 'night
07:33:35 <benmachine> 15:32:36 < arw> ManateeLazyCat: i would create a table on join, assign colours by the initial nickname and write that colour entry to the nickname table.
07:33:57 <ManateeLazyCat> arw: Sorry, emacs crash.
07:34:00 <ManateeLazyCat> arw: I missing something.
07:34:10 <ManateeLazyCat> benmachine: Yes, that i do in elisp version.
07:34:19 <benmachine> ManateeLazyCat: I think that's all you missed
07:34:22 <arw> ManateeLazyCat: http://pbot.rmdir.de/fc11bc0de4c620f89b7d54f617591de2
07:34:28 <benmachine> as long as you got 15:31:52 < arw> ManateeLazyCat: well, depends. how important is constant colour to you?
07:34:35 <benmachine> oh
07:34:38 <benmachine> arw is ahead of me
07:35:17 <ManateeLazyCat> benmachine: Thanks.
07:36:10 <arw> ManateeLazyCat: that way you can also make the additional feature of manually assigning colours work.
07:36:10 <ManateeLazyCat> benmachine: Just suggestion by arw, i plan to just hash nick name to get color.
07:36:58 <ManateeLazyCat> arw: Infact, i think hash nick is enough.
07:37:15 <arw> ManateeLazyCat: you could also apply some heuristics depending on the irc network and hostname of the person whether you hash the hostname or you don't.
07:37:20 <ManateeLazyCat> arw: Hostname will change always in some country...
07:37:21 <benmachine> I think you should start with something simple
07:37:31 <benmachine> and then see by using it how it goes wrong, if it goes wrong
07:38:00 <benmachine> you will never be able to track everyone perfectly
07:38:18 * ManateeLazyCat pasted "erc-highlight-nicknames.el" at http://paste2.org/get/985283
07:38:18 <ManateeLazyCat> benmachine: Above is elisp version, works well, i plan to clone it with Haskell..
07:38:20 <arw> ManateeLazyCat: yes, depending on whether its dialup, hosting provider, university/company or whether the irc network uses hostnames at all or just uses some fancy nick authentication there.
07:38:22 <ManateeLazyCat> benmachine: yes.
07:38:51 <ManateeLazyCat> arw: Like China, hostname is dynamic....
07:39:53 <arw> ManateeLazyCat: depends. often you have something like somebody@x1A2B3C4D.dialup-provider.cn
07:40:15 <arw> ManateeLazyCat: in that case you could hash over somebody@ and .dialup-provider.cn
07:40:16 <ManateeLazyCat> arw: :)
07:40:33 <ManateeLazyCat> arw: I won't do that, indent and hostname will change.
07:40:40 <handonson> ManateeLazyCat: Can I save a Pixbuf as an image file?
07:40:44 <arw> ManateeLazyCat: that way the hash will be constant unless that person changes its dialup provider.
07:40:51 <ManateeLazyCat> handonson: Yes.
07:40:59 <arw> ManateeLazyCat: and the nick will change more often than provider and ident.
07:41:11 <benmachine> arw: my nick hasn't changed in years
07:41:30 <benmachine> I mean apart from when I fell back on my backup nick
07:41:31 <ManateeLazyCat> arw: why people want change nick ?
07:41:38 <benmachine> but that doesn't count
07:41:46 <benmachine> my provider *has* changed several times in that time
07:42:06 <arw> benmachine: yes, but there are some annoying habits like away nicks, changing nicknames for /me or changing nicknames just for fun...
07:42:11 <handonson> because some people show there status on nick
07:42:21 <handonson> yeah exactly
07:42:24 <handonson> ManateeLazyCat: How?
07:42:24 <ManateeLazyCat> handonson: pixbufSave :: Pixbuf -> FilePath -> ImageFormat -> [(String, String)] -> IO ()
07:42:31 <handonson> huh, there it was.
07:42:34 <handonson> thanks. :)
07:42:44 <benmachine> arw: well, I'd suggest that someone changing nick should have colour artificially preserved somehow
07:43:08 <arw> benmachine: that would be the table-ansatz suggested above.
07:44:02 <benmachine> well then less talking and more coding is required :P
07:44:27 <ManateeLazyCat> benmachine: arw Thanks for suggestion, coding now. :)
07:44:39 <arw> ManateeLazyCat: hf
07:44:53 <ManateeLazyCat> arw: hf? What's it?
07:44:57 <benmachine> have fun
07:45:02 <ManateeLazyCat> benmachine: :)
08:10:31 <tromp_> jobs
08:11:06 <JuanDaugherty> wieso?
08:23:01 <Maxdamantus> @pl \x y -> x y y
08:23:02 <lambdabot> join
08:28:19 <erisco> how would I partially apply the cons function when I only want to give the first argument?
08:28:32 <pikhq> (foo:)
08:28:41 <pikhq> Or (:) foo
08:28:42 <erisco> thanks I will try that
08:29:58 <xiackok> hello
08:32:16 <sshc> Is there a way to run a list comprehension in parallel?
08:33:46 <Maxdamantus> sshc: zip?
08:35:39 <Maxdamantus> > zip [n^2 | n <- [1..]] [n^3 | n <- [1..]]
08:35:40 <lambdabot>   [(1,1),(4,8),(9,27),(16,64),(25,125),(36,216),(49,343),(64,512),(81,729),(1...
08:45:03 <erisco> this is a homework assignment. http://pastebin.com/CnewusHd I am pretty sure the type I am aiming for is [*]->*->* but I don't understand how I have a type of [*]->[*]->[*] also, this is Miranda
08:47:18 <erisco> I am thinking that I might have a syntactical error
08:47:52 <monochrom> w00t Richard Bird has a new book. be sure to buy it if you go to ICFP. http://www.comlab.ox.ac.uk/news/237-full.html
08:48:24 <erisco> line 38 btw is line 6 of the paste
08:48:57 <erisco> oh, sorry, I mean line 4 of the paste
08:50:21 <erisco> so the very confusing part for me is identifying where the error really is
08:50:35 <lordrat> erisco: what is wrong with empty list that you cannot revere it?
08:51:00 <erisco> lordrat: the reverseList function can, but the helper should never be handed an empty list
08:52:02 <Maxdamantus> Looks overly complex.
08:52:06 <sshc> erisco: Which school are you attending?
08:52:12 <lordrat> erisco: why not shorten definition and let helper handle empty list too?
08:52:18 <erisco> my presumption is that the type I am inferring by saying (helper xs) [] versus the type helper really has is causing the problem
08:52:26 <erisco> sshc: the university of windsor
08:52:55 <erisco> lordrat: it doesn't work with my current line of thinking... but I can always improve it later
08:53:29 <erisco> Maxdamantus: surely it isn't an optimal solution but, in my mind, the concept should work
08:53:39 <lordrat> erisco: ok. so at first, you should look to type of (:).
08:55:13 <erisco> lordrat: *->[*]->[*]
08:55:31 <erisco> which is not exactly what I expected
08:55:36 <erisco> okay, let me think for a bit
08:56:19 <erisco> no, wait, that is what I expected... it takes something and a list of somethings and returns a list of somethings
08:56:27 <aavogt> * aren't used for type variables
08:56:49 <erisco> what about in Miranda? I don't have a language definition
08:57:31 <erisco> let me type out what I expect to happen when my function runs
08:57:32 <lordrat> erisco: ok. then try not being so cool (=poinfree) at first try and rewrite helper with both arguments
08:57:53 <sepp2k> erisco: When you do (((helper xs) x):), the lhs of : is a list. So the rhs and the result will have to be a list of lists.
08:58:13 <erisco> lordrat: I am not trying to be cool; I am doing that purely because I think it is required to make my algorithm work
08:58:18 <Maxdamantus> Isn't the lhs a function?
08:58:37 <erisco> sepp2k: how can it possibly be a list?
08:58:58 <sepp2k> erisco: Because  helper foo bar  returns a list.
08:59:08 <Maxdamantus> helper [x]    = (x:)
08:59:17 <erisco> that classifies as a list?
08:59:25 <erisco> I must be missing something fundamental here
08:59:38 <sepp2k> Maxdamantus: Right so  helper [x] xs = x:xs, which is a list.
08:59:58 <Maxdamantus> Only if xs is a list
09:00:15 <sepp2k> If xs isn't a list, it's a type error.
09:00:45 * hackagebot amqp 0.2.1 - Client library for AMQP servers (currently only RabbitMQ)  http://hackage.haskell.org/package/amqp-0.2.1 (HolgerReinhardt)
09:00:50 <aavogt> > foldl (flip (:)) [] "hello"
09:00:52 <lambdabot>   "olleh"
09:00:54 <erisco> the idea is that helper gives back (x1 : x2 : x3 .... xn :) back to reverseList
09:00:55 <Maxdamantus> If helper [x] xs is a list, then helper [x] is not
09:01:14 <Maxdamantus> well, it might be a list
09:01:18 <Maxdamantus> but it's not specifically a list
09:01:33 <sepp2k> Maxdamantus: Right, but helper is applied to two arguments here.
09:01:50 <Maxdamantus> Oh.
09:04:14 <aavogt> erisco: you have a bug with your call to error
09:04:37 <erisco> when I removed that line it gave me the same error on line 38
09:04:45 <erisco> so I am thinking the real problem is on line 37
09:04:46 <lordrat> erisco: you are trying to use accumulator, if I'm not mistaken(?).
09:05:02 <aavogt> think about the task as popping elements off one stack and putting them on another... so the first ends up in the last
09:05:28 <Maxdamantus> Isn't the problem as sepp2k described >_<
09:05:47 <erisco> aavogt: that is a good way to think about it
09:05:52 <Maxdamantus> (((helper xs) x):) .. ((helper xs x):)
09:06:05 <Maxdamantus> Too many brackets
09:06:26 <erisco> those brackets are redundant aren't they?
09:06:36 <Phyx-> this isn't lisp...
09:06:47 <Maxdamantus> Other than the outermost ones, I think so
09:07:31 <erisco> then I'm personally not worried about the brackets
09:07:59 <Maxdamantus> Yeah, but he's applying helper to two values there
09:08:28 <Maxdamantus> Bleh, nvm
09:08:45 <Maxdamantus> It's not a list, ignore me :\
09:08:50 <aavogt> also something to think about is how your reverse is related to operations on the list zipper
09:09:38 <lordrat> hm... how to explain it without writing solution :-/
09:09:52 <aavogt> that being     data Zipper a = Zipper { up :: [a], focus :: a, down :: [a] } -- I dunno if this is similar to miranda syntax
09:10:01 <Maxdamantus> But I think it still doesn't make sense.
09:10:11 <Maxdamantus> There's some left assosciative use of (:) I think
09:10:15 <lispy> ?botsnack
09:10:16 <lambdabot> :)
09:10:18 <Maxdamantus> :t (4:5):6
09:10:20 <lambdabot> forall t. (Num t, Num [t], Num [[t]]) => [[t]]
09:10:39 <lispy> lambdabot: stop using 100.3% of the CPU!
09:10:47 <erisco> ah, I removed the point free style notation
09:11:01 <erisco> I'm vaguely recalling things from when I practiced Haskell months ago
09:11:04 <erisco> http://pastebin.com/YGBASZkb
09:11:11 <erisco> same problem, not as bizarre looking
09:11:28 <aavogt> if you want it pointfree, you need   id   and  .  (function composition)
09:11:54 <erisco> partial function application
09:11:57 <erisco> whatever it is called :P
09:12:04 <lordrat> erisco: and there you see problem.. on line 6
09:12:17 <erisco> is the way I am trying to reverse the list clear or should I explain it further?
09:12:46 <erisco> lordrat: ah, you're right...
09:13:06 <erisco> I am giving x as y which is not a list but should be
09:13:16 <lordrat> erisco: it's clear, you are usic accumulator... and you are giving on that line to helper x on position it is expecting list
09:13:28 <erisco> yes
09:13:31 <lordrat> erisco: probably something like...
09:13:42 <lordrat> (x:y) should occur there...
09:13:45 <lordrat> maybe...
09:13:50 <lordrat> somewhere ;-)
09:14:21 <lordrat> erisco: got it?
09:14:31 <erisco> I think I fixed it
09:14:41 <erisco> yes, that is what I changed
09:14:49 <lordrat> ok, let's have a look ;-)
09:15:08 <erisco> I asked myself what I really wanted to pass on instead of x
09:15:25 <erisco> and (x : y) is definitely what I really needed.... so let me run this on some input
09:15:41 <erisco> solid D
09:15:42 <erisco> :D
09:16:09 <lordrat> ok, and now (when it is working) you can push it further with style ;-)
09:16:33 <erisco> this was all largely due to poor memory of how the language worked... syntactical problems it definitely way
09:17:05 <erisco> lordrat: *shrug* you guys are really big on style but I just prefer something I can easily understand, heh
09:17:14 <tmo_> I see a little silhouetto of a man
09:17:29 <lordrat> erisco: with style comes understanding ;-)
09:17:52 <erisco> on language syntactical rules, not on algorithmic thinking
09:18:05 <erisco> but, sure,  how would I style this? revert to partial functions?
09:18:12 <lordrat> come on, we will give you some ... hints... and you can decide.. hm?
09:18:16 <Phyx-> with style comes understanding when someone else has to maintain your code
09:18:24 <spuz> I'm looking for a project to work on to develop my haskell skills. Does anyone have any recommendations for ideas for a nice beginner's project. What kind of thing could I develop that haskell would be suited to?
09:18:29 <lordrat> erisco: this is the way of thinking i like :-)
09:18:41 <lispy> spuz: ical parser
09:19:23 <lordrat> erisco: I would definitelly try fliping arguments for helper
09:19:28 <erisco> Phyx-, at this point we are interpreting vague terms differently... but I understand what you mean
09:19:48 <spuz> lispy: do you mean a calendar application that uses ical?
09:19:52 <spuz> or just the parser?
09:20:12 <lispy> spuz: first the parser: http://github.com/dagit/hICalendar
09:20:19 <lordrat> erisco: and I would try to make helper handle empty list too
09:20:29 <lispy> spuz: er, actually this one http://github.com/robertmassaioli/hICalendar
09:21:15 <spuz> lispy: that could be interesting
09:21:52 * Phyx- throws a lambda at lispy 
09:22:07 * lispy catches twirls it around and tosses it back at Phyx- 
09:22:22 * Maxdamantus shaves the lambda
09:22:39 <lispy> "shaving the lambda" sounds like a euphisim
09:22:40 <Phyx-> oh oh, now we have a naked lambda
09:22:48 <lispy> euphimism*
09:23:02 <spuz> what I'm really wondering is what kind of real applications would haskell be suited to implement with? What real world applications have built in haskell?
09:23:13 <spuz> have *you* built
09:23:20 <lispy> spuz: ghc, darcs and xmonad all come to mind
09:23:54 <lispy> spuz: I've built parsers, compilers, languages, darcs, interpreters, games, opengl stuff
09:23:59 <lispy> spuz: you can do it all!
09:24:04 <Phyx-> I wonder why people evaluate a language not based on the language itself but based on what's been build with it
09:24:30 <copumpkin> "Oh the messiah's just been born
09:24:31 <copumpkin> ?
09:24:35 <lispy> spuz: if you can build it in C you can build it in Haskell (even operating systems)
09:24:37 <copumpkin> "But how many followers does he already have?"
09:25:01 <sm_> morning all. This is getting to be like a daily faq eh
09:25:17 <erisco> I don't think Miranda hides subdefs from the global scope :(
09:25:18 <Nibble> The truth is that haskell can be used for everything
09:25:19 <monochrom> it is cheaper to just find out what has been built with the language
09:25:30 <lispy> spuz: communicating with Java/C# is a bit of a sore spot though.  On win32 we have a .NET bridge and there is a jvm-bridge that a friend of mine is trying furiously to get working again (bitrot)
09:25:31 <copumpkin> *lazier
09:25:34 <copumpkin> :P
09:25:50 <lispy> sm_: yeah, watch this
09:25:55 <lispy> ?faq Can I build this with Haskell?
09:25:55 <lambdabot> The answer is: Yes! Haskell can do that.
09:25:58 <Phyx-> speaking of followers, I wonder, at every Haskell conference or meeting there seems to be the same people... Are those things just excuses to get together and get drunk at night?
09:25:58 <spuz> It's interesting knowing what's actually been built though as it gives you an idea what kind of problems people like to use haskell to solve
09:26:13 <monochrom> in the same way HR approximates evaluating you by evaluating your résumé instead.
09:26:15 <lispy> spuz: have you seen hackage yet?
09:26:19 <copumpkin> Phyx-: yep
09:26:20 <spuz> I'm sure it can do many things but there must be certain things it's good at vs others
09:26:26 <erisco> never mind, the problem seems to be different (whew!)
09:26:32 <lispy> spuz: http://hackage.haskell.org/packages/archive/pkg-list.html  <-- list of things built in Haskell
09:26:38 <copumpkin> spuz: what can you do with c?
09:26:43 <Maxdamantus> You can't build an OS in C
09:26:56 <monochrom> instead of evaluating your ability (for example by giving you test tasks), HR asks what have been builtin by you and what languages you know.
09:26:58 <sm_> Phyx-: I've built an accounting tool and web app and test runner and irc announce bot with it, and misc scripts. It's good.
09:27:07 <spuz> Maxdamantus: me? not much :p
09:27:12 <Phyx-> sm_: think you meant spuz 
09:27:19 <lispy> Maxdamantus: the amount of assembler you need in small enough to not emphasize it.  Or do you refer to something else?
09:27:20 <sm_> excuse me, yeah
09:27:26 <Maxdamantus> Hm, actually, you might be able to, depending on the architecture
09:27:39 <sam_> how do I convert a 2-tuple to an array?
09:27:40 <Maxdamantus> Yeah, assembly needed too usually 
09:27:41 <sam_> *list
09:27:46 <Maxdamantus> does House use assembly too?
09:27:52 * Phyx- goes back to coding, IRC is distracting
09:28:00 <lispy> :t \(x,y) -> [x,y]
09:28:01 <lambdabot> forall t. (t, t) -> [t]
09:28:48 <lispy> spuz: Haskell people like to write compilers.  It's one of the nice ways to solve problems.
09:29:12 <sam_> I'm writing a compiler in haskell
09:29:14 <sam_> :D
09:29:18 <Maxdamantus> I guess with Haskell alone you don't get things like direct access to memory, etc
09:29:19 <sam_> right now
09:29:22 <lispy> spuz: You can make a small language (say, even embedded in Haskell) for the problem domain.  You make a bit of a compiler or interpreter and then solve your problems in the mini-language
09:29:24 <Maxdamantus> need some library to do so
09:29:25 * copumpkin is writing a "decompiler" in haskell :P
09:29:26 <erisco> lordrat: http://pastebin.com/BgBvUsbY
09:29:54 <lordrat> erisco: yes :-)
09:29:55 <lispy> Maxdamantus: Not with pure Haskell 98, but if you use libraries and extensions that ship with GHC you're good.
09:30:05 <lordrat> one line rendundant though...
09:30:09 <tmo_> Are more people on this IRC channel knowledgable about wxHaskell or gtk2hs?
09:30:13 <erisco> also, in the pastebin http://pastebin.com/BgBvUsbY am I correct that the first implementation has O(n^2) time complexity? or is it too hard to tell because of varying complier optimizations?
09:30:30 <Phyx-> copumpkin: i'm writing a untypechecker, we should hook up projects :P
09:30:37 <erisco> lordrat: one entire line is redundant?
09:30:40 <lispy> tmo_: I've only written code using wx, but that was quite some time ago and i'm sure my knowledge is useless now.
09:30:42 <spuz> lispy: that sounds like a nice thing to do for a personal project. might be nice to try given others are doing similar work
09:30:48 <Maxdamantus> Mmm..
09:30:51 * Maxdamantus sleeps
09:30:52 <copumpkin> Phyx-: ooh!
09:30:57 <Phyx-> sam_: for what?
09:31:11 <tmo_> lispy: do you know how to get an app to recognise a modifier + charkey combo?
09:31:14 <lispy> spuz: yes, I did this once for filtering email.  I wrote a mini-language for constructing procmail recipes
09:31:24 <lordrat> erisco: is it necessary to handle one element list separately?
09:31:25 <lispy> tmo_: never done that actually
09:31:43 <lispy> spuz: here is my procmai thing: http://hackage.haskell.org/package/autoproc
09:31:47 <tmo_> Because I've been reading all the standard documentation and can't find anything that suggests how to do that
09:31:50 <lispy> spuz: the code is all very easy to follow and quite simple
09:31:57 <lispy> spuz: should give you an idea how to do things
09:32:13 <spuz> lispy: cheers
09:32:17 <sam_> Phyx-, some compiler coursework
09:32:24 <Phyx-> ah
09:32:34 <erisco> lordrat: yeah I think so
09:32:35 <Phyx-> i used to like those
09:32:43 <Phyx-> I miss those little projects
09:32:50 <Phyx-> Big projects tend to never end :/
09:32:55 <lordrat> erisco: and now I figured it out... you are probablny not handling empty list correctly
09:32:57 <erisco> lordrat: and as I say that I am not entirely sure... heh. let me figure this out
09:33:22 <lordrat> erisco: think about that line once again...
09:33:53 <lordrat> erisco: (line 16)
09:34:10 <sam_> http://dpaste.com/242354/
09:34:12 <sam_> thoughts?
09:34:31 <lordrat> erisco: if handled properly, you can write helper on 2 lines...
09:34:37 <sam_> I'd quite like to reduce all those calls to expToIr
09:35:54 <leod> illissius-: sorry, was away for a while. what I want to do is something like this: http://codepad.org/IyXMp9aJ i.e. dynamic multiple dispatch
09:36:50 <lispy> leod: http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
09:37:51 * lispy now thinks type classes should have been type sets or type relations
09:38:04 <lispy> the 'class' part seems to be misleading
09:38:14 <Phyx-> what would you call dictionaries then?
09:38:28 <lispy> I wouldn't change it
09:39:23 <copumpkin> well, types are already sets
09:39:28 <copumpkin> so sets of sets would be evil!
09:39:29 <copumpkin> :P
09:39:35 <Phyx-> types are sets?
09:39:36 <lispy> type sorts!
09:39:40 * Phyx- 's head explodes
09:39:43 <lispy> Phyx-: yeah, set + interface
09:40:05 <lispy> Phyx-: you know C-H right?
09:40:10 <erisco> lordrat: well, I had the arguments backwards on line 17 so I fixed that
09:40:15 <Phyx-> lispy: C-H?
09:40:24 <lispy> Phyx-: curry-howard correspondence
09:41:19 <lispy> Phyx-: all I was going to say is that if you squint and see your types as propositions then you it becomes clear that the types are sets.
09:42:06 <erisco> lordrat: I might have it
09:42:21 <Phyx-> lispy: looking at the wiki page it seems I know parts of C-H but not the thing as a whole. I should read more...
09:42:39 <erisco> lordrat: hahaha, what a clever little change
09:43:21 <leod> lispy: i see the point, but i'm even more unsure now how to implement multiple dispatch without typeclasses
09:43:42 <erisco> lordrat: http://pastebin.com/n12acXth
09:44:46 <lispy> leod: I don't want to tell you how to write your program, but I suspect that approaching it as a case of multiple dispatch will lead to Haskell solutions that are a bit odd
09:45:06 <leod> yes, I'm starting to think the same
09:45:20 <lispy> leod: For one thing, haskell doesn't need any tricks to get multiple dispatch
09:45:24 <leod> the idiomatic solution would probably to use a plain old ADT
09:45:40 <erisco> I see the issue more clearly... it isn't about tricks and bizarre syntax shortcuts but rather clarity... yes, this is definitely more clear
09:45:48 <lispy> foo :: (Bar a, Baz b) => a -> b -> c -- this will do multiple dispatch without any programming tricks
09:46:23 <erisco> to be fair, I did solely work out an algorithm and implementation for list intersection which is dfinitely kick-ass
09:46:39 <leod> maybe I'm going at this completely wrong
09:46:59 <lordrat> erisco: yes :-) nice work :-)
09:47:11 <erisco> lordrat: thanks
09:47:34 <lispy> leod: you might write up the problem you want to solve (without suggesting a design) and see what people here suggest
09:47:52 <leod> yea, I'll do that
09:48:46 <monochrom> you have got them reversed. types are foundational. sets are built on top of types.
09:49:05 * monochrom tired of set-is-foundational
09:49:25 <lispy> monochrom: well, sets get the hysterical precedence
09:49:47 <monochrom> yeah, I like to be revisionist
09:49:57 <monochrom> (on this topic anyway)
09:50:00 <notabel> lispy: hysterical indeed
09:50:35 <erisco> lordrat: the help was greatly appreciated. I had already satisfied the project because I had the O(n^2) solution but that wasn't good enough for my taste ;)
09:51:01 <monochrom> I also accept: untyped lambda calculus is foundational, types and sets are built on top of that.
09:51:53 <ManateeIrcClient> G'night all. :)
09:52:12 <lordrat> erisco: I like to hear that. And what about that kick-ass (interesting movie by the way) list intersection? ;-)
09:53:53 <erisco> lordrat: http://pastebin.com/0mvtz46S
09:53:55 <lordrat> erisco: may I cite you at my "lecture"? espetially part "I see the issue more clearly... it isn't about tricks and bizarre syntax shortcuts but rather clarity..."
09:54:04 <monochrom> kick-ass list library: with no cons comes no bugs
09:54:20 <erisco> lordrat: heh, sure
09:54:32 <lordrat> erisco: thanks :-).
09:54:43 <erisco> lordrat: "an enlightened student from IRC" will work :P
09:54:54 <lordrat> monochrom: :-)
09:55:12 <sm_> ClaudiusMaximus: hi.. how would you feel about adding a pure haskell alternative to binembed ? Since .s seems a bit platform-specific
09:55:12 <lordrat> erisco: :-) Ok :-)
09:55:25 <aristid_> erisco: the first case is unnecessaey
09:56:13 <erisco> aristid_: ah, good catch. ys or xs will match an empty list
09:56:20 <sm_> I've been looking at the code and it might be more than I want to take on today
09:57:33 <lordrat> erisco: yes :-) one line deleted, let's look at other six :-)
09:57:53 <Olathe> Why does core sometimes contain functions that take unused arguments (the arguments weren't in the original either)? Example: http://codepad.org/9LOR0fmE
09:58:55 <monochrom> the code is rather long. could you mention an example unused argument?
09:59:00 <Olathe> distance1 in core takes six arguments rather than the needed four.
09:59:43 <Olathe> distance in the core is the actual function, distance1 is just a helper function for it, but it takes more arguments than needed.
09:59:53 <erisco> lordrat: I didn't know list intersection could be done in linear time so it was quite exciting to arrive at that
10:00:07 <monochrom> Oh, right, 2 _'s
10:00:11 <Olathe> Yeah.
10:00:44 <Phyx-> :t lift
10:00:45 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
10:01:02 <Phyx-> :t liftM
10:01:03 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:01:26 <Phyx-> @instances MonadTrans
10:01:27 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
10:01:54 <lordrat> erisco: :-)
10:03:53 <lordrat> erisco: other good exercise is writing elem function for sorted lists that can work properly even on infinite ones...
10:04:28 <erisco> what do you mean by an elem function?
10:05:35 <lordrat> > 1 `elem` [1,2,3]
10:05:37 <lambdabot>   True
10:05:38 <chrisdone> bos: did you see my email regarding hpaste?
10:05:39 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
10:05:51 <chrisdone> @messages -- better not be kinky!
10:05:51 <leod> lispy: http://codepad.org/RZBcdb0L hope it makes some sense :p
10:05:51 <lambdabot> Baughn said 2d 22h 37m 48s ago: Well, looks like I can stop worrying about haskell.org and get back to worrying about haskell. Thank Eris.
10:05:51 <lordrat> > 4 `elem` [1,2,3]
10:05:53 <lambdabot>   False
10:06:05 <chrisdone> Baughn: oh?
10:06:23 <Baughn> chrisdone: Since the brand-new haskell foundation is apparently taking over hosting.
10:06:39 <chrisdone> "the haskell foundation"? mrm
10:06:51 <chrisdone> links plox
10:06:52 <lordrat> :info elem
10:07:11 <lordrat> erisco: membership predicate
10:07:40 <lordrat> erisco: in Haskell syntax: elem :: Eq a => a -> [a] -> Bool
10:07:44 <chrisdone> Baughn: what's the brand new haskell foundation?
10:07:59 <lordrat> erisco: but for ordered lists it whould be more like
10:08:06 <Baughn> chrisdone: http://www.haskell.org/pipermail/haskell/2010-September/022309.html
10:08:11 <lordrat> erisco: elem' :: Ord a => a -> [a] -> Bool
10:08:19 <chrisdone> ta
10:08:51 <Baughn> chrisdone: I'd look up something more directly applicable, but my connection appears to be totally broken
10:09:02 <Baughn> "Lag: 10.3"
10:09:16 <monochrom> heh
10:09:52 <monochrom> Baughn is on a mission to outer space, currently 10.3 lightseconds away from us :)
10:10:17 <chrisdone> Baughn: nice (the link). I wonder if this means we can setup paste.haskell.org
10:10:25 <dankna> 5.15 lightseconds away
10:10:28 <dankna> 10.3 is the round-trip time
10:10:32 <monochrom> oh oops
10:10:37 <dankna> hehe
10:10:40 * notabel was just asked in another channel if he "dreams about monads"
10:11:11 <monochrom> I did dream about logic
10:12:01 <notabel> my reply was, naturally, that i did, but only in the cartesian sense
10:12:35 <monochrom> what is the cartesian sense?
10:14:01 <Nibble> monochrom: something like jedi-sense
10:14:18 <dankna> sounds like a very clever response if I could understand it
10:15:51 <lordrat> erisco: and that kick-ass thing... I don't know miranda, so maybe it is not possible, but if you move first two lines (after deleting that unnecessary one) to the end of definition you can marge them to one case (using anonymous (sometimes refferet to as wild) pattern).
10:16:17 <erisco> lordrat: underscores don't seem to exist in Miranda
10:16:29 <lordrat> sad :-(
10:16:37 <lordrat> but you can use variable...
10:16:40 <lordrat> and than...
10:16:44 <lordrat> not use it ;-)
10:17:00 <lordrat> that should work like underscore ;-)
10:17:06 <erisco> true
10:17:17 <monochrom> "f _ _ = 0" -> "f john mary = 0"
10:17:22 <lordrat> (but being less obvious what is it doing ... maybe)
10:17:46 <lordrat> monochrom: exactly :-)
10:18:13 <monochrom> "f first_inaccessible_ordinal second_inaccessible_ordinal = 0"
10:19:02 <lordrat> monochrom: :-D
10:19:15 * Phyx- wonders if he should use ByteStrings instead of Strings to generate his xml files, considering they will never be that big
10:19:27 <lordrat> monochrom: that would be even more evil :-)
10:19:33 <benmachine> Phyx-: why not?
10:19:35 * monochrom is evil
10:19:54 <monochrom> I still use String for my xml and html files
10:20:17 <Phyx-> benmachine: well, I'm wondering if they're really beneficials for such small files
10:20:30 <Phyx-> basically converts cabal files back and to a xml format
10:20:43 <benmachine> Phyx-: small files might get bigger :P question is, is it actually harder to use ByteString
10:20:47 <monochrom> largest one is about 11KB.
10:21:11 <benmachine> if you're doing basic operations only you might find they all have bytestring equivalents anyway
10:21:27 <benmachine> if you're not, then it's probably not worth it
10:21:29 <benmachine> that's my view
10:21:43 <Phyx-> benmachine: I'm only doing basic operations, though I've never used ByteStrings before
10:21:53 <benmachine> Phyx-: ooh, good time to learn then? :P
10:22:25 <Phyx-> benmachine: true, I'll use it :)
10:22:41 <chrisdone> Igloo: oh, you're here. I sent you an email regarding an official haskell paste subdomain. feel free to respond here if more convenient
10:22:58 <gwern> idea question: if you wanted to efficiently delete the first line repeatedly, how would you go about it? I haven't thought of any approach which doesn't have issues with reading the whole file or handles
10:23:18 <gwern> *delete the first line of a file
10:23:42 <benmachine> gwern: of the same file, or lots of different files?
10:23:47 <gwern> benmachine: same file
10:23:50 <benmachine> oh
10:24:04 <chrisdone> afaiknew you can only delete a first line by rewriting the whole file
10:24:09 <benmachine> mm
10:24:22 <monochrom> the whole file must be read eventually
10:24:38 <benmachine> I wonder if there's any advantage to calculating where all the lines are beforehand
10:24:38 <gwern> the idea is that each line is a URL, and I'll be firing off a request to WebCite every 100 seconds or so, and I'd like the computer to be able to crash or reboot at any time and the 'state' in the file be up to date
10:24:56 <benmachine> gwern: how about seeking to the end of the file and deleting from there?
10:25:02 <gwern> monochrom: well sure but at any moment I only want the first line
10:25:05 <chrisdone> gwern: how about reversing the line order? :P
10:25:16 <benmachine> it's a little trickier but much more efficient, probably
10:25:25 <gwern> I don't really see how that's any better? if I can't efficiently delete the first line, why would I be able to delete the last?
10:25:35 <mtnviewmark> (came in late) - is the file large? > 100,000k lines? If not, just re-write the file
10:25:43 <benmachine> gwern: because that's just truncating the file, the rest of the content stays in the same place
10:25:45 <mtnviewmark> compared to the network latency, it's small beans
10:26:02 <benmachine> gwern: to delete the first line, you have to basically move all the other lines up one place
10:26:13 <benmachine> to delete the last line, you just reduce the number of places, as it were
10:26:17 <gwern> mtnviewmark: that's true... I also worry about handles and stomping/blanking the file. haskell functions aren't always so good with that
10:26:23 <chrisdone> int truncate(const char *path, off_t length); 
10:26:24 <chrisdone> int ftruncate(int fd, off_t length);  
10:26:41 <gwern> chrisdone: you mean I need to do this in C? :(
10:26:53 <chrisdone> no no
10:26:54 <chrisdone> man truncate
10:26:54 <monochrom> no, he means it is O(1).
10:26:59 <mtnviewmark> well, even in Haskell, I'd, after the web data was fetched and processed (so you know you can drop the first line), write a new file with all but the first line, then rename it over the original
10:27:29 <chrisdone> NAME  truncate - shrink or extend the size of a file to the specified size
10:27:30 <chrisdone> SYNOPSIS  truncate OPTION... FILE...
10:27:49 <mtnviewmark> again, compared to the URL fetch, this is probably small change (again, unless the file has a very larg number of lines)
10:27:51 <gwern> hm. truncate isn't immediately useful on its own, since it works on size, not per-line
10:27:52 <monochrom> it's called hSetFileSize here
10:28:01 <benmachine> ah
10:28:04 <chrisdone> monochrom: oh, nice
10:28:14 <benmachine> gwern: but you need to find out where the last line is anyway
10:28:19 <chrisdone> @hoogle hSetFileSize
10:28:20 <benmachine> if you want to use that
10:28:20 <lambdabot> System.IO hSetFileSize :: Handle -> Integer -> IO ()
10:28:26 <chrisdone> super win!
10:28:37 <gwern> http://www.haskell.org/ghc/docs/6.12.1/html/libraries/base/GHC-IO-Handle.html#v%3AhSetFileSize
10:28:41 <mtnviewmark> wondering, gwern, is the file management the bottle neck?
10:28:43 <benmachine> gwern: I'd guess at the line length, seek to near the end of the file, and then work backwards
10:28:54 <benmachine> mtnviewmark might have a point, though
10:29:19 <gwern> mtnviewmark: probably not. I would like an elegant efficient solution, though
10:29:23 * mtnviewmark <-- middle name is "simplest thing that could possible work" 
10:29:34 <monochrom> To delete the 1st line: read the whole file, write almost the whole file. To delete the last line: read the whole file, write almost nothing.
10:29:44 <benmachine> gwern: those two don't always go together :P
10:29:50 <gwern> I wrote the hairy code to talk to the Internet Archive & WebCite a long time ago, so the only new part is the file IO
10:30:27 <monochrom> In 5 years, your program will be used on files stored on flash solid-state disks. reading is cheap, writing is frown upon.
10:30:31 <benmachine> I'd think hSetFileSize would be good for atomicity though, since you wanted that
10:30:51 <mtnviewmark> sounds like simplest, easiest to understand, least likely to break, most robust in face of possible failures upon inspection, should be your criteria then
10:30:56 <gwern> benmachine: well as someone pointed out, writing out to a tmp and then moving the tmp also gets you atomicity
10:31:01 <monochrom> and yeah, infinitely better atomicity.
10:31:13 <benmachine> true
10:32:33 <monochrom> it is still "so simple it obviously has no race" vs "so complicated it has no obvious race"
10:39:19 <sam_> how do I boolean xor in haskell?
10:39:35 <sam_> is it built in?
10:39:36 <monochrom> not in prelude
10:39:42 <gwern> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/bytestring-0.9.1.6/Data-ByteString.html#v%3AbreakByte looks nice. I can (url,rest) <- readFile foo >>= breakByte '\n'; archive url; BS.writeFile foo rest; and loop
10:39:50 <monochrom> oh, in prelude. use /=
10:39:52 <gwern> sam_: /=
10:40:00 <gwern> > True /= True
10:40:02 <lambdabot>   False
10:40:08 <gwern> > False /= False
10:40:09 <lambdabot>   False
10:40:12 <gwern> > False /= True
10:40:13 <lambdabot>   True
10:40:20 <gwern> et viola
10:40:28 <sam_> win
10:40:31 <monochrom> > [ x /= y | x<-[False,True], y<-[False,True] ]
10:40:32 <lambdabot>   [False,True,True,False]
10:40:43 <rschnck> Is there a function in Haskell that puts a list in order from least to great?
10:40:48 <dankna> sort?
10:40:51 <rschnck> Oh :3
10:40:55 <dankna> hehe
10:40:59 <monochrom> xor is inequality. xnor is equality.
10:41:01 <gwern> > id [1..10] -- this also works
10:41:02 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:41:04 <gwern> see?
10:41:20 <rschnck> I just wanted to know because I have to make my own...need to see how it works
10:41:29 <gwern> @src sort
10:41:29 <lambdabot> sort = sortBy compare
10:41:31 <gwern> @src sortBy
10:41:31 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
10:41:41 <benmachine> that's one way of doing it
10:41:45 <monochrom> that is pedagogical
10:41:47 <gwern> rschnck: the definitions are not very enlightening :)
10:41:52 <mercury^> It's a mergesort I think.
10:41:54 <rschnck> gwern: Yeah =/
10:42:13 <monochrom> but it is obviously correct if you don't mind the slowness
10:42:20 <rschnck> I'm having trouble making my own. I can only use basic list functions (i.e. head, tail (:) +++, null)
10:42:44 <gwern> rschnck: so write mergesort
10:42:49 <rschnck> And it'd be easy to do if you only had to deal with consecutive integers...but I don't know how to instruct haskell to continously go through the list and then somehow know when to "stop" once they are in order
10:42:49 <chrisdone> pattern matching solves three of those
10:42:55 <rschnck> What does mergesort do?
10:43:08 <chrisdone> look it up
10:43:21 <chrisdone> sorting algorithms are well documented
10:43:22 <monochrom> write mergesort or a variant of quicksort (the variant is about not doing in-place mutation, but rather creating new lists)
10:43:23 <Nibble> rschnck: look up pattern matching
10:44:08 <monochrom> or write insertion sort :)
10:44:25 <rschnck> Nibble: I know what pattern matching is
10:44:27 <chrisdone> well it's probably homework
10:44:39 <benmachine> rschnck: a lot of list functions in haskell can be written by
10:44:58 <benmachine> assuming it's already done for lists of length n, how would you do it for lists of length (n+1)?
10:45:14 <benmachine> then, how would you do it for lists of length 0?
10:45:18 <monochrom> for this homework purpose, pattern matching doesn't give you more algorithms than head, tail.
10:45:20 <benmachine> then, apply foldr
10:46:14 <benmachine> (or explicit recursion if you like)
10:46:49 <rschnck> benmachine: So assuming the list is already sorted for length n?
10:46:55 <qwebirc56661> Hi all. Is there some sort of function that will do the following transform: (a, Either b c) -> Either (a, b) (a, c) ?
10:47:21 <monochrom> and therefore, "how do you know when to stop" --- I know when I see a list of length 0. (for some sorting algorithms, length 1 too)
10:47:29 <benmachine> rschnck: assuming you have a sort function that works on lists of length n, how would you make a sort function that works on lists of length (n+1)
10:47:42 <rschnck> Ah, okay
10:48:02 <qwebirc56661> I tried fmap, but fmap ((,) a) bc only gives me Either b (a, c)
10:48:10 <Phyx-> hrm, is there an alternative in ByteString to B.unlines [ppFull a, ppFull b] ?
10:48:25 <monochrom> Douglas Smith has a great lecture on how insertion sort, mergesort, quicksort are all one happy family of divide-and-conquer.
10:48:34 <benmachine> :t \x -> either ((,) x) ((,) x)
10:48:36 <lambdabot> forall a a1. a -> Either a1 a1 -> (a, a1)
10:48:42 <benmachine> oh hmm
10:48:50 <rschnck> I'm not sure. If you have a list of arbitrary length n, then it seems it would simply work for n+1 o.O
10:48:51 <benmachine> :t \x -> either (Left . (,) x) (Right . (,) x)
10:48:52 <lambdabot> forall a a1 b. a -> Either a1 b -> Either (a, a1) (a, b)
10:49:04 <benmachine> :t uncurry (\x -> either (Left . (,) x) (Right . (,) x))
10:49:06 <lambdabot> forall a a1 b. (a, Either a1 b) -> Either (a, a1) (a, b)
10:49:07 <chrisdone> would it be bad if lists were data List a = Single a | Cons a (List a)? the standard functions would be nicer: head :: List a -> a, map :: (a -> b) -> List a -> List b, filter :: (a -> Bool) -> List a -> Maybe (List a)
10:49:15 <monochrom> Cut the list into two parts "somehow". sort the two lists separately. re-combine them "somehow" preserving sorted order.
10:49:28 <rschnck> Oh!
10:49:37 <benmachine> chrisdone: it would be bad, I think
10:49:43 <benmachine> chrisdone: well, I dunno
10:50:01 <Phyx-> guess not
10:50:04 <benmachine> in your form, our usual lists are Maybe (List a)
10:50:14 <benmachine> in our form, your lists are (a, [a])
10:50:25 <qwebirc56661> benmachine: Thanks, but woah ....
10:50:30 <monochrom> insertion sort: to cut, just do the trivial head-tail. to sort them separately: oh one of them is trivial. to re-combine: here goes the hard work of finding the right place to insert.
10:50:30 <rschnck> So you could take [1,2,3,4] --> [1,2] and [3,4] --> [1],[2],[3],[4]
10:50:36 <rschnck> Sort the integers 
10:50:42 <benmachine> qwebirc56661: :P you could just write it yourself explicitly
10:50:42 <rschnck> Then slap 'em back together?
10:51:00 <benmachine> qwebirc56661: "either" is useful for working on Eithers, sometimes
10:51:08 <monochrom> mergesort: to cut, just trivially at the middle. to re-combine: here goes the hard work of merging.
10:51:28 <qwebirc56661> benmachine: I was hoping fmap would do the "right thing", but guess not.
10:51:30 <rschnck> Okay, I think that's enough to get me started though
10:51:32 <rschnck> I'll try
10:51:43 <rschnck> Should I make seperate functions for cutting/recombining?
10:51:55 <benmachine> make separate functions for everything, it can't hurt
10:51:58 <aristid_> qwebirc56661: do the right thing? fmap does what it is specified to do, nothing less, nothing more.
10:51:59 <monochrom> quicksort: to cut, here goes the hard work of picking a pivot and classifying the whole list into "lower" and "higher". to re-combine: just the trivial ++
10:52:01 <chrisdone> benmachine: (a, [a])??
10:52:06 <benmachine> qwebirc56661: check the type of fmap
10:52:11 <aristid_> :t fmap
10:52:12 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:52:15 <benmachine> chrisdone: yep, that's the type of nonempty lists :P
10:52:19 <qwebirc56661> Right thing as in "what I needed" ;)
10:52:28 <aristid_> note that there is no constraint on a or b
10:53:09 <benmachine> chrisdone: then you define head = fst >_>
10:53:10 <chrisdone> benmachine: doesn't make sense
10:53:14 <benmachine> chrisdone: sure it does!
10:53:25 <benmachine> Single x = (x, [])
10:53:37 <benmachine> Cons x xs = (x, xs)
10:53:39 <benmachine> sorted
10:53:51 <chrisdone> except you still have an emptiable list on the right
10:53:55 <benmachine> right
10:53:59 <gwern> milliseconds... those are 1000 to a second, right?
10:54:00 <benmachine> so what?
10:54:02 <chrisdone> which defeats the point
10:54:06 <benmachine> no it doesn't
10:54:17 <gwern> > 100 / 60
10:54:19 <lambdabot>   1.6666666666666667
10:54:21 <benmachine> your lists are guaranteed to have a head, that is the only way they are different from normal lists
10:54:32 <benmachine> (a, [a]) is guaranteed to have a head
10:54:39 <gwern> need to sleep 1.7 seconds, so threadDelay 1700, I suppose
10:54:42 <ashraf> hello
10:54:44 <ashraf> 100/59
10:54:45 <chrisdone> List a = Nil | Cons a (List a)
10:54:46 <chrisdone> List2 a = Single a | Cons a (List2 a)
10:54:50 <benmachine> gwern: threadDelay is microseconds isn't it?
10:54:52 <ashraf> > 100/59 
10:54:54 <lambdabot>   1.694915254237288
10:54:55 <chrisdone> in List2, the type system guarantees
10:54:59 <gwern> dammit
10:55:03 <gwern> benmachine: yeah, microseconds
10:55:05 <chrisdone> in List, your functions have to guarantee it
10:55:14 <benmachine> chrisdone: type system guarantees *what*
10:55:14 <gwern> 1 millionth of a second
10:55:26 <chrisdone> what do you think?
10:55:32 <gwern> ...ok so threadDelay 1700000
10:55:39 <benmachine> chrisdone: List a is the type of "zero or more a"
10:55:44 <chrisdone> totality
10:55:46 <benmachine> chrisdone: List2 is the type of "one or more a"
10:55:56 <benmachine> chrisdone: (a, [a]) is the type of "one of more a"
10:56:25 <benmachine> Maybe (List2 a) is the type of "zero or more a"
10:56:45 <benmachine> chrisdone: incidentally, List2 isn't a monoid or a MonadPlus
10:56:52 <monochrom> But my real point is: Douglas Smith casts all this nice divide-and-conquer inside category theory!
10:56:56 <gwern> > 1700000 * 60
10:56:58 <lambdabot>   102000000
10:57:08 <chrisdone> benmachine: so?
10:57:21 <benmachine> chrisdone: so, it's useful to have those things
10:57:30 <chrisdone> benmachine: why?
10:57:44 <gwern> > 60 / 100
10:57:45 <benmachine> chrisdone: for the Writer monad for example
10:57:46 <lambdabot>   0.6
10:57:52 <monochrom> damn, google has "douglas smith nude pictures"??!!
10:57:59 <benmachine> we need an identity for concatenation so that we can write return
10:58:22 <chrisdone> how are operations that are useful for working with emptiable data structures useful for working on a non-emptiable data structure
10:58:26 <monochrom> ftp://ftp.kestrel.edu/pub/papers/smith/marktoberdorf.ps
10:58:45 <chrisdone> benmachine: why would you use List2 for writer?
10:58:46 <monochrom> or generally http://www.kestrel.edu/home/people/smith/
10:59:11 <benmachine> chrisdone: your original question was, should lists be List2s, and I'm pointing out that lists are probably more useful as they are
10:59:21 <Xaphania> HellOlAloHallOhayo.. I HI..
10:59:21 * monochrom now goes back to investigate "douglas smith nude pictures"
10:59:31 <benmachine> chrisdone: further, I'm pointing out that (a, [a]) generally speaking does the job of a List2 if you want it to
11:00:02 <benmachine> which is not to say that a newtype for it would be a bad thing, I believe there are packages on hackage for that
11:00:15 <chrisdone> Maybe (List2 a) does a better job than List a
11:00:15 <chris666> Greetings
11:00:20 <chris666> I need some help
11:00:23 <zeroxfe> hi, does anyone know why PCRE is not included with GHC?
11:00:23 <chrisdone> benmachine: what does foldr1 do?
11:00:30 <benmachine> chrisdone: I disagree, it's more verbose
11:00:47 <chris666> can anyone tell me how do i tell the program to select from an array the first object in it, in order
11:00:50 <benmachine> chrisdone: foldr1 is inherently an unsafe operation
11:01:01 <chrisdone> benmachine: what does it do?
11:01:04 <benmachine> chrisdone: if you know that the list has at least one element, you can just use foldr anyway
11:01:15 <chris666> can a good programmer PV me?
11:01:20 <chris666> please
11:01:22 <benmachine> chrisdone: it's basically foldr only it uses the last element in the list as the zero
11:02:01 <chrisdone> with List2 you encode this in the type, and GHC enforces it for you
11:02:06 <chris666> ##programming
11:02:08 <chris666> oops
11:02:12 <zeroxfe> chris666: head list
11:02:17 <chris666> what?
11:02:34 <zeroxfe> chris666: head [a, b, c] returns a
11:02:46 <zeroxfe> chris666: i.e., head returns the first element in a list
11:02:58 <benmachine> chrisdone: but if you know your list is nonempty you can just use foldr anyway
11:03:09 <chris666> #programming
11:03:16 <chris666> how do i connect that channel?
11:03:17 <chrisdone> benmachine: you mean if it's maybe-empty?
11:03:30 <monochrom> > minimum [3,2,4,1,5]
11:03:31 <lambdabot>   1
11:03:35 <notabel> zeroxfe: the set of libraries distributed with ghc itself is kept intentionally small.  the haskell platform fills out the set somewhat, but chooses regex instead of pcre.  you can get any regex lib you want from hackage
11:03:49 <benmachine> chrisdone: no I mean, if you know your list is non-empty i.e. safe to use with foldr1, you have enough information that you can use foldr to achieve the same effect, I believe
11:03:52 <chrisdone> whole point of foldr1 is using it when you know your list is nonempty so that you don't have to use foldr
11:03:59 <chrisdone> :t foldr1
11:04:00 <lambdabot> forall a. (a -> a -> a) -> [a] -> a
11:04:08 <monochrom> I hope that answers chris666's question :)
11:04:26 <chrisdone> foldr1 :: (a -> a -> a) -> List2 a -> a -- oh, this takes a non-empty list
11:04:28 <zeroxfe> notabel: thanks for the reply... i'm particularly curious because haskellwiki says Text.Regex.Posix is "very slow"
11:05:00 <gwern> @hoogle Word8
11:05:01 <lambdabot> Data.Word data Word8
11:05:01 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
11:05:07 <benmachine> chrisdone: you could just as well write foldr1 :: (a -> a -> a) -> a -> [a] -> a -- and it does exactly the same thing
11:05:23 <chrisdone> but now you have foldr
11:05:27 <benmachine> well no not quite
11:05:28 <chrisdone> so you've gained nothing
11:05:42 <benmachine> in this version, the a parameter goes on the front instead of at the end
11:05:44 <chrisdone> it just restricts the type
11:06:08 <benmachine> foldr1 f z [] = z; foldr1 f z (x:xs) = f z (foldr1 f x xs)
11:07:20 <benmachine> chrisdone: basically, it's easy to simulate non-empty lists with isomorphic types. which you choose to be your "basic" type is up to you, but I think you more often want lists that might be empty than lists that aren't
11:07:34 <gwern> @hoogle Char -> Word8
11:07:35 <lambdabot> Data.ByteString.Internal c2w :: Char -> Word8
11:07:35 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
11:07:35 <lambdabot> Prelude error :: [Char] -> a
11:07:55 <chrisdone> benmachine: thanks for putting it basically for me, now I understand why your opinion is correct
11:08:47 <gwern> I always run into this error, I write a char like '\n' and ghc bitches at me that it isn't a Word8
11:09:14 <monochrom> heh
11:09:29 <benmachine> chrisdone: ... my opinion is my opinion, you can have a different one if you like
11:09:37 <chrisdone> thanks
11:09:41 <Nibble> benmachine: nope
11:09:43 <Nibble> that is impossible
11:09:45 <benmachine> I'm confused
11:09:47 <Nibble> like dividing by zero.
11:10:37 <benmachine> chrisdone: I think I might have been misunderstanding you
11:10:41 <gwern> let's see, can't coerce it with a ::Word8, can't use BS.pack since that's for a String, OverloadedStrings doesn't seem to help
11:10:56 <benmachine> chrisdone: but that's not the end of the world, I suppose :P
11:12:03 <monochrom> I think chrisdone means he agrees with benmachine now.
11:12:26 <benmachine> monochrom: the opinion/correct thing set off my sarcasm radar
11:12:37 <benmachine> but said radar is notoriously unreliable
11:12:49 <gwern> hm, let's see, in ASCII, I think 10 is \n
11:12:53 <benmachine> hence my confusion
11:14:07 <gwern> let (url,rest) = BS.breakByte 10 contents
11:14:10 <gwern> well, if it compiles...
11:15:43 <benmachine> gwern: isn't that what Data.Bytestring.Char8 is for?
11:15:54 <monochrom> > let {yay :: Char -> Word8; yay = fromIntegral . Data.ord } in yay '\n'
11:15:55 <lambdabot>   Not in scope: `Data.ord'
11:15:58 <gwern> problem is Char8 doesn't have breakByte
11:16:03 <monochrom> > let {yay :: Char -> Word8; yay = fromIntegral . Data.Char.ord } in yay '\n'
11:16:04 <lambdabot>   10
11:16:09 <Olathe> Apparently, using the UNPACK pragma on something other than the first item in a constructor can cause ghc to create helper functions with unnecessary arguments to hold the unneeded (but UNPACKed) data.
11:16:11 <chrisdone> I don't agree, but I'm tired of re-iterating this same encoding-invariants-in-the-type-system-pros-and-cons argument with you and listening to you sound off your tastes like fact, providing lame alternatives to just using the type system, etc.
11:16:42 <benmachine> chrisdone: oh, but I'm trying to show you how my way of doing things keeps the same invariants in the type system
11:16:57 <benmachine> chrisdone: you seem to think that one way is less expressive than the other, but that's just not true
11:17:11 <benmachine> gwern: it does have break, though?
11:17:35 <chrisdone> ok
11:17:42 <benmachine> chrisdone: from my perspective, we both agree that encoding invariants in the type system is good, I'm jus trying to show you another way of doing it
11:17:45 <gwern> benmachine: hm, so it does
11:18:02 <chrisdone> benmachine: *WHY*?
11:18:09 <Olathe> Let me see if I can create a minimal example case.
11:18:28 <benmachine> chrisdone: why try to show you another way of doing it? because I think that that answers your original question, of why we don't have a type for nonempty lists in the Prelude
11:18:32 <gwern> > 1000000×40
11:18:33 <lambdabot>   Not in scope: `×'
11:18:35 <gwern> > 1000000*40
11:18:37 <lambdabot>   40000000
11:18:50 <chrisdone> benmachine: I didn't ask why it's like that now
11:19:12 <chrisdone> many things in Haskell are stupid. not all things are the way they are because of brilliant design
11:19:42 <benmachine> chrisdone: you asked if changing it would be better, but I'm explaining why I think changing it is not necessary (because there are methods of using the current tools to achieve the same thing)
11:19:42 <chrisdone> bleh
11:19:57 <chrisdone> lol
11:19:58 <chrisdone> I give up
11:19:59 <hpc> chrisdone: it's a matter of details though; the big picture of haskell is nearly flawless
11:20:19 <hpc> there's just minor naggles like the hacky non-recursive non-native tuple definition
11:20:38 <duckinator> hi
11:20:38 * Phyx- wishes you could override instances of classes
11:20:46 <benmachine> chrisdone: I actually don't understand what you think I'm doing wrong
11:20:49 <Phyx-> I would like to override the monad instance of Reader
11:21:06 <hpc> without a newtype
11:21:13 <copumpkin> Phyx-: what else is possible?
11:21:17 <benmachine> chrisdone: and I do care, because I'm not trying to be annoying, at all
11:21:18 <hpc> (i think that's the sole reason for newtype's existence)
11:21:33 <benmachine> chrisdone: but if you want to give up then I won't argue it anymore
11:21:34 <Phyx-> hpc: yeah, But I hate having to write newtypes for everything :/
11:21:57 <monochrom> I know another reason for newtype's existence.
11:22:13 <Phyx-> copumpkin: I'm writing out xml, and I would like to have >>= and >> insert the appropriate indentation based on the environment of the Reader
11:22:23 <gwern> we need the newtypes to take revenge on the Zeon and finish the colony drop
11:22:36 <lordrat> monochrom: share with us
11:22:36 <monochrom> hahaha
11:23:11 <monochrom> today I may have "newtype PortNumber = P Int". Tomorrow I may change it to "P Integer".
11:23:31 <monochrom> I export only the abstract type PortNumber.
11:23:48 <hpc> oh i see
11:23:49 <monochrom> I don't write any instance.
11:24:00 <benmachine> Phyx-: if you override the Monad instance for Reader, um, what's left?
11:24:01 <hpc> sneaky
11:24:09 <benmachine> surely the whole point of Reader is to be a Monad :P
11:24:17 <monochrom> "data PortNumber = P Int" has a slightly different strictness.
11:24:33 <monochrom> I mean it has a small performance hit.
11:24:42 <benmachine> monochrom: and less devious deriving :P
11:26:28 <sshc> Is wxHaskell ghci friendly yet?
11:26:33 <Phyx-> benmachine: It would Still be a monad! just a different one :)
11:26:40 <sshc> What is wrong with gtk2hs also?
11:27:09 <benmachine> Phyx-: but my point is that more or less all there is to Reader is a Monad instance
11:27:18 <benmachine> and admittedly like two other instances and three functions or something
11:29:07 <mornfall> monochrom: That's a far off tomorrow. :)
11:29:39 <mornfall> (Far enough that one might argue for YAGNI, although I understand the hiding of the Int is not the only purpose of the newtype... I presume.)
11:30:43 <benmachine> mornfall: a similar argument would be the way GLfloat and GLdouble are newtypes for their internal representation, which might be different on different platforms, even
11:31:32 <gwern> gah, break doesn't drop the char you match on!
11:31:39 <gwern> rubbish I say
11:31:44 <gwern> pish and tiffle
11:31:47 <benmachine> heh
11:32:44 <mornfall> benmachine: Does a newtpe make a difference, compared to type synonym? (As far as hiding representations for practical purposes is concerned, anyway.)
11:32:56 <gwern> force me to clutter my code with BSC.drop 1 will you
11:33:21 <benmachine> mornfall: back when it was a type synonym lots of people used Float and GLfloat interchangeably, but that's not portable
11:33:34 <benmachine> or at least, that's my understanding
11:33:50 <mornfall> benmachine: I see.
11:33:54 <dankna> actually, I think (I've used GL a fair amount from both Haskell and C) that it /is/ portable
11:34:09 <dankna> as both the GL types and the Haskell types are defined to be particular IEEE types, aren't they?
11:34:30 <benmachine> dankna: well, the people who made the haskell GL binding thought there was a good reason for GLwhatever to be a distinct type
11:34:48 <benmachine> I thought it was something to do with the standard not specifying the actual underlying types, but I could be mistaken
11:34:59 <mornfall> dons: Apparently, GL does not define what a float is, and implementations are free to choose nonstandard ones.
11:35:10 <mornfall> dons: Sorry, mistab.
11:35:13 <mornfall> dankna: ^
11:35:35 <gwern> vindicating my long standing belief that floating point is of the devil
11:35:38 <dankna> hm
11:35:51 <dankna> let me check, I have the GL standard right here
11:36:38 <geheimdienst> http://notanumber.net/archives/33/newtype-in-c-a-touch-of-strong-typing-using-compound-literals <- i'll throw this into the newtype debate
11:36:57 <dankna> "We require simply that numbers? floating-point parts contain enough bits and that their exponent fields are large enough so that individual results of floating-point operations are accurate to about 1 part in 105. The maximum representable magnitude of a floating-point number used	to represent positional, normal, or texture coordinates must be at least 232; the maximum representable magnitude for colors must be at least 210. The 
11:36:57 <dankna> max- imum representable magnitude for all other floating-point values must be at least 232. x?0 = 0?x = 0 for any non-infinite and non-NaN x. 1?x = x?1 = x. x + 0 = 0 + x = x. 00 = 1. (Occasionally further requirements will be specified.) Most single-precision floating-point formats meet these requirements."
11:36:59 <dankna> oops
11:37:05 <dankna> that looks longer in irc than it did in Preview
11:37:10 <dankna> sorry for the huge paste
11:37:19 <dankna> anyway, so yeah, it defines a minimum
11:37:27 <dankna> so yes, there is a portability issue
11:40:10 <iocor> does anyone know of a good prettyprinter for haskell data structures?
11:40:27 <dankna> no :(
11:40:44 <mornfall> There's some stuff under Language.Haskell.Pretty. (Haven't tried.)
11:40:56 <Starfire> iocor: http://blog.ezyang.com/2010/07/groom-human-readable-show-for-haskell/ -- Perhaps you want this?
11:41:06 <kmc> or http://hackage.haskell.org/package/ipprint
11:41:55 <benmachine> http://hackage.haskell.org/package/Extra-1.33 oh now this is an odd package
11:41:58 <copumpkin> dammit, I wish I could put more than one module in a file
11:42:10 <benmachine> copumpkin: how would that work with naming?
11:43:23 <mornfall> benmachine: That's almost like a libwibble. :D
11:43:42 <dankna> that's a practical problem which could be solved.  for example, you could say that the file looks like a directory in the namespace
11:44:46 <mornfall> You could also says that code that wants only the secondary modules will fail to compile. :)
11:45:07 <dankna> true haha
11:45:55 <mornfall> Anyway, if you could only actually compile the modules that are needed (with the above constraint in mind), it'd solve my eternal "tests can't go with the code they test without making cabal unhappy"...
11:46:09 <dankna> hmm
11:46:14 <dankna> that's a much more specific problem
11:46:33 <dankna> honestly I'd solve that through editor extensions, not language extensions
11:46:42 <mornfall> Feels dirty.
11:46:53 <benmachine> dankna: the problem with files looking like a directory is that locating a module is no longer a purely filesystem operation, you have to go around parsing everything all the time
11:46:56 <mornfall> It's actually not a language restriction, it's just cabal suckages.
11:46:59 <mornfall> -s
11:47:41 <dankna> benmachine: I see that, yes, I was about to say something about that
11:47:49 <dankna> mornfall: what's the issue precisely?  in what way is cabal unhappy?
11:48:08 <mornfall> dankna: QC dependencies on libraries
11:48:40 <mornfall> It's bad with all libs, but specially bad with QC1 vs QC2.
11:48:47 <dankna> oh hmmm
11:48:59 <monochrom> haskell allows multiple modules in one file
11:49:30 <monochrom> perhaps better to say: haskell doesn't care how modules and files are related
11:50:05 <mornfall> monochrom: Doesn't?
11:50:06 <mornfall> mods.hs:4:0: parse error on input `module'
11:50:46 <monochrom> your result is one particular compiler defining its own relation.
11:50:58 <mornfall> ERROR "mods.hs":4 - Syntax error in input (unexpected keyword "module")
11:51:00 <mornfall> : - P
11:51:09 <monochrom> of course it is the easiest thing to do for implementers.
11:51:31 <monochrom> find me a clause that says modules and files must be 1-1.
11:51:33 <mornfall> Are you sure the abstract syntax allows multiple modules?
11:51:55 <benmachine> monochrom: I think we're mostly talking about what pacifies GHC/cabal :)
11:52:37 <benmachine> mornfall: at a guess, the abstract syntax defines how modules are constructed, not where they are found
11:54:35 <dankna> in contrast, the C standard defines a file format - it was the first standard to define the format we use today for text files, as I understand it.
11:54:56 <mornfall> benmachine: Well, the CFL says that module can only be either "module modid ... where" body or just body. I'm not sure there's a relation between source files and actual sources.
11:55:14 <benmachine> mornfall: yeah, that's what I meant
11:55:18 <mornfall> (For all I can tell, module is the start symbol.)
11:55:58 <mornfall> benmachine: But EOF is mentioned in the lexer.
11:56:12 <benmachine> ah
11:56:14 <benmachine> weird
11:56:37 <mornfall> I guess it's required for layout.
11:57:15 <lispy> so just insert an EOF between the modules in the file, duh ;)
11:57:29 <mornfall> That'll break on windows.
11:57:29 <hpc> haha
11:57:41 <dankna> haha
11:58:46 <monochrom> EOF is fair game at the lexer level
11:58:47 <mornfall> (You'd then also need to specify that haskell source files are binary not text, at least on platforms where that makes a difference.)
11:59:05 <dankna> (yes, indeed you would)
11:59:15 <dankna> (and if we're doing that we should say they're UTF8 and specify line-endings)
11:59:17 <lispy> Having multiple modules in a file makes about as much sense as mutually recursive modules.  You kind of want it, the language spec is okay with it, but in practice it's not such a good thing
11:59:30 <dankna> (also, more importantly, EOF is not a character, lispy was joking)
11:59:49 <mornfall> I don't see the connection.
12:00:02 <mornfall> dankna: Oh, it is. On windows. :)
12:00:08 <dankna> mornfall: you're kidding me ><
12:00:11 <monochrom> the grammar for module does not have EOF at the end though.
12:00:14 <dankna> mornfall: what codepoint does it have?
12:00:20 <mornfall> dankna: ^Z I think
12:00:23 <mornfall> Or something.
12:00:46 <monochrom> also ^Z is a crime of DOS copied from CP/M IIRC
12:00:47 <mornfall> Text handles will just cut off the stream when encountering EOF char.
12:00:48 <dankna> no - that's a keystroke, not a character
12:01:03 <dankna> ^Z is 0x1A which I see has the ascii name SUB
12:01:42 <lispy> What is SUB an abbreviation of?
12:01:59 <dankna> on Windows ^Z, or more specifically in Command.com because other terminal emulators behave differently (such as putty), it sends EOT (which is not the same as EOF, either, and IS a character, having codepoint 0x04)
12:02:11 <monochrom> we do mean that DOS uses 0x1A to end text files.
12:02:11 <Kaidelong> SUBstitute
12:02:21 <dankna> I have no idea what SUB is for
12:02:29 <Olathe> lispy: http://www.cs.tut.fi/~jkorpela/chars/c0.html
12:02:33 <Kaidelong> apparently you're supposed to put SUB in places where you found a code you weren't expecting
12:02:36 <dankna> huh
12:02:37 <dankna> weird
12:02:42 <Kaidelong> so it's like an error I guess
12:02:51 <ClaudiusMaximus> sm: only if it's as efficient (which pretty-printing to string literals and re-parsing at compile time certainly isn't)
12:02:57 <monochrom> so it means "sub me!"? :)
12:03:26 <Kaidelong> basically, that it was substituted for something wrong and the right thing should be substituted for it? I guess?
12:03:26 <mornfall> dankna: That's what causes the problem, it's not *the* problem. *The* problem is that since ^Z is sent to programs instead of EOF they actually interpret it that way.
12:03:34 <mornfall> dankna: Including command.com, eg.
12:03:36 <lispy> Olathe: interesting
12:03:37 <dankna> ugh!
12:04:11 <dankna> that is a sucky situation, although I'm not sure that it's the platform's fault /precisely/
12:04:26 <mornfall> dankna: In fact, I think (at least in GHC), readFile will cut off at ^Z.
12:04:31 <dankna> huh
12:04:32 <dankna> wow
12:04:34 <dankna> noted
12:04:37 <mornfall> Windows only, of course.
12:04:57 <dankna> yeah, if it weren't for Windows we'd have almost solved the trivial text-encoding problem after, what, 40 years of trying :/
12:05:11 <mornfall> It's important if you ever import Data.ByteString.Char8 instead of Data.ByteString and wonder why your reads aren't complete.
12:05:30 <Kaidelong> Oh pesky windows!
12:05:56 <kmc> i blame windows for all evil in the world
12:06:10 <mornfall> Pesky BS too! The handle behaviour change between ByteString and Char8 took me by surprise.
12:06:15 <Kaidelong> Windows did 9/11
12:06:17 <lispy> kmc: Not _all_ evil.  cygwin gets some blame too
12:06:44 <lispy> kmc: or shall we blame windows for cygwin?
12:06:54 <mornfall> lispy: Just because there's no better POSIX for windows.
12:07:03 <aristid> lispy: yes
12:07:07 <mornfall> The one by MS apparently never took off.
12:07:26 <mornfall> At least not in this (OSS) part of the world.
12:07:30 <lispy> mornfall: that's because it cost $$
12:07:47 <lispy> unix services for windows was the name, IIR
12:07:49 <lispy> IIRC*
12:07:57 <Kaidelong> it was free but you needed the right windows edition
12:08:08 <Kaidelong> it was also not that nice
12:08:18 <Kaidelong> and didn't support anything involving X
12:09:08 <lispy> Kaidelong: hmm...I could have sworn it had a price tag the last time I looked at it, but yeah looks to be a free download
12:09:20 <mornfall> It seems to have X11 even, these days.
12:09:23 <Kaidelong> it just felt like a particularly outdated environment after coming from Linux
12:09:33 <Kaidelong> I was missing stuff like GNU tar
12:09:44 <Kaidelong> which had more bling
12:10:00 <Kaidelong> and I was never a fan of the korn shel
12:10:06 <mornfall> Well, they particularly don't have bash.
12:10:15 <mornfall> Which makes it nearly useless in itself.
12:10:20 <Kaidelong> whole bunch of stuff like that worked together to ruin it for me
12:10:38 <Kaidelong> I mean sure, in theory it's all "native" but MSYS is just more familiar and also native
12:11:43 <mornfall> The problem is, and always will be, that win32 makes a crappy POSIX no matter how much you plaster and paint the userland.
12:11:47 <Kaidelong> that said, I'm sure there are some people who put together a very nice thing on top of SFU, but I wasn't one of those people
12:11:58 <ezyang> mornfall: Hear hear! 
12:15:22 <nejucomo> Can I restrict a data type's member type by class?  I want something like:  data Foo = Eq b => Foo Int b
12:15:54 <vanadium> It is usually a better idea to apply that restriction to all functions that operate on the data type
12:16:32 <nejucomo> vanadium: How do you mean?
12:18:25 <vanadium> I don't know but I shall appeal to the authority of BONUS; http://learnyouahaskell.com/making-our-own-types-and-typeclasses look for "data (Ord k) =>"
12:18:36 <kmc> you can constrain the type like that
12:18:53 <kmc> if you instead want to constrain its value constructor, you probably won't get what you expect
12:19:12 <kmc> if you want to be able to pattern-match the Foo data constructor and get an Eq context for free, you should write it with GADT syntax
12:20:34 <nejucomo> Hm.
12:24:19 <nejucomo> Ah yes, I want to contrain the data type as in: data (Eq a) => Foo a = Foo a Int
12:24:34 <vanadium> why
12:24:38 <kmc> you'll still need to write (Eq a) => on the functions manipulating Foo, iirc
12:24:53 <mornfall> kmc: Indeed, which is teh suck. :(
12:24:53 <vanadium> That gadt thing sounds neat
12:24:59 <vanadium> were those the type-indexed things
12:25:16 <kmc> you won't if you write:  data Foo a where { Foo :: (Eq a) => a -> Int -> Foo a }
12:25:22 <lispy> vanadium: yes
12:25:35 <mornfall> kmc: I don't think that actually helps.
12:25:46 <mornfall> kmc: Not universally, anyway.
12:25:58 <mornfall> It may help when you explicitly match on the ctor.
12:26:12 <kmc> it means that a value of type (Foo a) will carry evidence of (Eq a) with it
12:26:19 <kmc> (because the only constructor available does so)
12:26:36 <mornfall> But if you just have the type in the signature, and all ctors have the constraint, it won't appear automatically on functions that take foos.
12:26:50 <kmc> yeah
12:29:52 <taktoa> anybody home?
12:30:04 <Veinor> nope
12:30:10 <taktoa> ok
12:30:25 <kmc> nope, this channel is notoriously inactive
12:30:32 <taktoa> I'm trying to write a basic definite integral function in haskell
12:30:50 <Ke> adaptive simpson?
12:30:54 <taktoa> but I keep getting a "Parse error in pattern" error
12:30:58 <taktoa> nah
12:31:03 <taktoa> here's my code
12:31:07 <taktoa> integraldef :: Floating a => ((a -> a) -> a -> a) -> Floating
12:31:09 <taktoa> integraldef (f x) y z
12:31:11 <taktoa> 	| (y == z)  					= (0.0)
12:31:13 <taktoa> 	| (y > z)   					= ((-1.0) * integraldef ((f x) z y))
12:31:15 <taktoa> 	| ((y < z) && (z /= (y + h)))	= ((integraldef (f x) y z) + integraldef (f x) y (z - 0.0000001))
12:31:17 <taktoa> 	| otherwise						= f (y + h)
12:31:19 <taktoa> 	where h = 0.0000001
12:31:21 <Ke> taktoa: pastebin please
12:31:21 <taktoa> ugh
12:31:23 <taktoa> the bars are tabbed
12:31:26 <taktoa> ok, one minute
12:31:56 <Ke> well I guess you don't have to repaste that
12:32:10 <JoeyA> codepad.org will let you run your code (if it doesn't take too much CPU time).  hpaste.org will let you give it a title and author to look at later.
12:32:14 <taktoa> http://pastebin.com/hKmHS1h1
12:32:17 <tommd> Any feldspar users here?
12:32:22 <JoeyA> actually, hpaste.org is still down, it seems.
12:32:30 <JoeyA> (at least I can't get to it)
12:32:47 <taktoa> I don't see what's wrong with my code
12:32:54 <wli> Clenshaw-Curtis is probably a better idea.
12:33:06 <Veinor> taktoa: what's the error?
12:33:17 <Ke> taktoa: why do you have (f x)
12:33:20 <taktoa> Parse error in pattern
12:33:23 <taktoa> on line
12:33:27 <taktoa> um
12:33:27 <Ke> taktoa: I think you should have just f
12:33:32 <taktoa> 2
12:33:42 <Veinor> oh, yeah
12:33:43 <taktoa> lemme try that
12:33:59 <tommd> taktoa: You say you have one argument (A weird function) then give it 3 with the first argument poorly formed
12:34:06 <tommd> I mean, what is (f x) as an argument?
12:34:14 <Ke> integraldef (f x) y z
12:34:16 <taktoa> f x is a function
12:34:17 <Ke> integraldef f y z
12:34:24 <tommd> taktoa: no, 'f' is a function
12:34:45 <tommd> (f x) is a function applied to something, which doesn't pattern match/bind.
12:34:51 <Ke> taktoa: functions are just regular people like intergers and such
12:35:00 <taktoa> ah, I see
12:35:13 <taktoa> well, I changed all of the (f x) to f
12:35:21 <Ke> not all
12:35:23 <taktoa> and it gives me this error:
12:35:46 <taktoa> Class Floating used as a type
12:35:49 <Ke> just the one on line 2
12:35:57 <taktoa> ok
12:36:00 <tommd> taktoa: http://pastebin.com/feSUPY2A
12:36:23 <tommd> Oh, taktoa: I should have fixed that too.  "Floating" at the end of the sig should be "a"
12:36:36 <taktoa> ok
12:37:02 <taktoa> it wants all of the (f x) to be f
12:37:06 <taktoa> even after line 2
12:38:04 <tommd> taktoa: Well 'f' is the function, right?  I mean, there is no x.
12:38:09 <taktoa> yeah, I know
12:38:21 <taktoa> but Ke said to only change line 2
12:38:22 <tommd> f :: Floating a => a -> a
12:38:41 <tommd> taktoa: IRC is a hard communication mechanism.  Take everything with a grain of salt.
12:38:50 <taktoa> yeah, I can see that
12:39:07 <taktoa> I get a new error now
12:39:21 <taktoa> test.hs:7:1: parse error on input `|'
12:39:35 <tommd> And by now we need another paste
12:39:42 <taktoa> http://pastebin.com/fGPcgGxT
12:40:37 <tommd> taktoa: Missing closed parens
12:40:50 <tommd> taktoa "))" at the end of the long line.
12:41:01 <taktoa> aha thanks
12:41:29 <hpc> also, you seem to be using tabs, which isn't recommended
12:41:38 <tommd> taktoa: Also, all your paranthesis are messed up
12:41:43 <taktoa> they are?
12:41:47 <taktoa> http://pastebin.com/mQQupuBd
12:42:00 <tommd> So it seems, or perhaps you really do want just one argument?  It isn't clear what you actually want.
12:42:04 <taktoa> I'm getting this error:
12:42:06 <taktoa> test.hs:3:0:
12:42:08 <Ke> taktoa: indeed I meant that the particular error in question was only relevant to line 2
12:42:08 <taktoa>     Occurs check: cannot construct the infinite type: a = a -> a
12:42:10 <taktoa>     When generalising the type(s) for `integraldef'
12:42:12 <taktoa> Compilation failed.
12:42:44 <hpc> you have too many parens inthe type signature
12:42:51 <tommd> taktoa: Yes, you see your function is taking 3 arguments in your definition then when you recursively call it you are only giving one argument.  What do you want? One or 3 arguments?
12:42:56 <hpc> you want (a -> a) -> a -> a -> a
12:43:06 <taktoa> 3 arguments
12:43:17 <taktoa> a function, and two floatings
12:43:21 <tommd> Oh, I didn't notice you didn't change the sig like I suggested
12:43:33 <hpc> a function call in haskell has no parenthesis
12:43:34 <tommd> So see my paste again and fix the sig to take 3 arguments
12:43:45 <hpc> threeParams a b c is how you should do it
12:43:57 <lispy> ?botsnack
12:43:58 <lambdabot> :)
12:44:00 <lispy> hmm
12:44:10 <taktoa> ok...
12:44:13 <taktoa> gimme a minute
12:44:44 <lispy> sorry lambdabot
12:44:48 <lispy> You had gone rogue
12:44:50 <lispy> Cale: ping?
12:45:15 <taktoa> http://pastebin.com/UbYSSdkE
12:45:30 <taktoa> still gives me the infinite type error
12:45:47 <taktoa> test.hs:3:0:
12:45:49 <taktoa>     Occurs check: cannot construct the infinite type: a = a -> a1 -> a1
12:45:51 <taktoa>     When generalising the type(s) for `integraldef'
12:45:56 <lispy> ah, the infinite type error
12:45:59 <lispy> > fix error
12:46:01 <tommd> taktoa: This http://pastebin.com/WP5CJWKZ works
12:46:10 <tommd> Study it
12:46:14 <benmachine> taktoa: you're applying f to two arguments, but the type signature says it only takes one
12:46:37 <taktoa> I'm apply f to one argument
12:46:37 <tommd> benmachine: He things hes calling "def" not applying "f"
12:46:47 <benmachine> ah
12:46:50 <benmachine> yeah
12:46:52 <tommd> taktoa: somefunction (f x z) is not correct. 
12:47:01 <tommd> taktoa: You wanted "somefunction f x z"
12:47:09 <tommd> providing f x and z as arguments to "somefunction"
12:47:25 <taktoa> somefunction has three params
12:47:26 <benmachine> providing f, x, and, z :P
12:47:33 <benmachine> er
12:47:34 <benmachine> and z
12:47:44 <tommd> by calling it "somefunction (f x z)" you said:  "let temp = f x z in somefunction temp"
12:47:53 <taktoa> oh I see
12:48:39 <hpc> () doesn't "group" things the way it would in a language like Java; here, it just does order of operations
12:48:47 <tommd> In C syntax:
12:48:47 <tommd> someFunction f x z ==>  somefunction(f, x, z)
12:48:47 <tommd> someFunction (f x z) ==> someFunction ( f(x, z) )
12:49:00 <taktoa> ahhhh
12:50:11 <taktoa> http://pastebin.com/rzC9sPGW
12:51:42 <t3eblinder> hello, is there a way to track, where an error (which function) is thrown? (i'll get a Prelude.(!!): index too large) but I don't know where it's coming from...)
12:52:20 <tommd> @hoogle interlude
12:52:56 <tommd> t3eblinder: http://hackage.haskell.org/package/interlude
12:54:24 <Phyx-> hmmm, there's a downside to becoming a better programmer.. It takes me alot less code to do things now, but at the end of the day, when you look back, and after all bug fixes and debugging having only 50-100lines to show for a whole weekend's work is depressing
12:56:16 <bremner_> Yeah, and if you use git, it will compress that to like 7 bytes
12:56:19 <sshc> Where is lambdabot??
12:57:00 <Phyx-> lol, 7 bytes
12:57:37 <geheimdienst> measuring a the progress of software development in lines of code is like measuring the building of a plane by weight
12:57:46 <geheimdienst> (sez bill gates)
12:58:15 <geheimdienst> also, don't think "lines of code produced", think lines of code *spent*
12:58:19 <geheimdienst> (sez dijkstra)
13:00:03 <Phyx-> geheimdienst: yeah, I know all that, but when You look back, and all you see is a pageful you go "heh"
13:00:06 <Phyx-> :P
13:00:30 <Saizan> well, you should look at the working program and the millions of users coming to your door
13:00:31 <copumpkin> dammit I want injective type functions!!
13:00:37 <Saizan> with bug reports.
13:00:39 <Phyx-> lol
13:00:53 <Saizan> copumpkin: me too!! let's camp out of SPJ's house.
13:01:15 <Phyx-> I'll bring the marshmellows for the camp fire!
13:01:40 <copumpkin> Saizan: I think it's TacticalGrace's business more, isn't it?
13:01:52 <copumpkin> but I guess he's probably waiting for the new typechecker before moving ahead on new TypeFamilies features
13:02:19 <tommd> t3eblinder: If you haven't noticed by now, don't bother with interlude.  I  didn't know it didn't work with (!!) or any other infix function.
13:02:43 <Phyx-> So.. no camping out?
13:03:04 <Saizan> copumpkin: but UK is much closer than AU :P
13:03:04 <copumpkin> well, I wouldn't mind meeting SPJ anyway
13:03:08 <copumpkin> so sure, let's camp out
13:03:14 <copumpkin> Saizan: good point :)
13:03:16 <t3eblinder> tommd: I found that out just that second... 
13:03:31 <Phyx-> copumpkin: I don't think If we camp out infront of his front yard if he'd come out and talk
13:03:40 <Phyx-> maybe hose us down.. but not talk
13:03:43 <copumpkin> sure he would
13:03:51 <copumpkin> it'd be a very peaceful, courteous camp
13:04:00 <Phyx-> and throw ninja lambdas at us
13:04:01 <Phyx-> lol
13:04:08 <copumpkin> "We're your greatest fans!"
13:04:15 <benmachine> copumpkin: isn't a newtype family basically an injective type function?
13:04:15 <Phyx-> copumpkin: we should arrange the tents ina lambda shape
13:04:28 <benmachine> copumpkin: or do you want injective type functions to existing types
13:04:28 <Phyx-> so we can be spotted from google earth
13:04:34 <tommd> t3eblinder: As a rule of thumb I find use of (!!) rather bad (indexing lists is slow).  Futher, I avoid partial function unless it is clearly safe from local context.  Failure to follow these rules usually leads me to the GHCi debugger eventually.
13:04:39 <copumpkin> benmachine: to existing types :/
13:04:42 <benmachine> oh right
13:04:43 <copumpkin> and I can't newtype around them
13:04:51 <Phyx-> wasn't there a safe variant of !! anyway?
13:04:55 <Phyx-> @hoogle find
13:05:03 <Phyx-> he died again?
13:05:06 <tommd> Phyx-: There is a "safe" library
13:05:20 <tommd> Phyx-: It has safe versions of many typically-partial functions
13:05:33 <tommd> It has the "at" function in place of (!!)
13:05:34 <lispy> Phyx-: for the last 10 hours lambdabot was using over (literally, according to linux) 100% CPU so I killed it
13:05:51 <Phyx-> lispy: what's wrong with her?
13:06:16 <kmc> Phyx-, also, programmer culture emphasizes POUNDING OUT omg so many lines in a CODE BINGE then fixing it all in an EPIC JOLT-FUELED debugging MARATHON
13:06:29 <Phyx-> *phew* converting .cabal to MSBuild sure is alot of work :/
13:06:46 <kmc> thinking hard, writing a small amount of powerful code, then having it work the first time is *so* not cool
13:07:07 <Phyx-> kmc: most managers only understand LOCs, and most programmers also when you show them your days work tend to go "That's it?" lol
13:07:11 <tommd> kmc: Not if you're paid by the line or get bonuses based on the number of bugs fixed.
13:07:31 <Phyx-> tommd: number of bugs fixed.. that's where the optimization loop comes in
13:07:38 <Phyx-> just knock off a 0
13:07:43 <geheimdienst> http://www.csd.uwo.ca/staff/magi/personal/humour/Computer_Audience/The%20Parable%20of%20the%20Two%20Programmers.html
13:07:47 <mart_> hi, can anyone help me get hakyll installed, please?  I've just installed ghc and hs-cabal using macports, but cabal install hakyll is failing on 'text', which has compile errors
13:07:53 <kmc> yeah you can blame management but i think there's a cultural issue among coders too
13:07:59 <tommd> Phyx-: But those damned lazy-evaluated optimization loops!
13:08:04 <kmc> and a psychological issue
13:08:17 <kmc> fixing bugs one by one feels great, it's a fun sort of reward process
13:08:32 <Phyx-> what's hakyll?
13:08:35 <mart_> I'm seeing: Data/Text/IO.hs:123:13: Not in scope: `hGetBuffering'
13:08:36 <kmc> writing the code right the first time is almost a letdown
13:08:41 <Phyx-> tommd: lol
13:08:43 <kmc> "oh, it works, now i have to do the next thing"
13:08:50 <tommd> mart_: Did you "cabal update"?
13:08:58 <mart_> Phyx-: static web site generator.  'text' is some unicode library, apparently.
13:09:00 <Veinor> kmc: yeah :(
13:09:01 <Phyx-> kmc: indeed, but some then you have the other side, bugs that are very very hard to track down
13:09:10 <mart_> tommd: sure I did, forgot to mention that.
13:09:12 <Phyx-> mart_: ah
13:10:16 <tommd> mart_: Well, text-0.8 or 0.9 will probably be in HP, so next release you'll be good to go.  For now, I'd say it isn't importing System.IO for some reason.
13:10:45 <Phyx-> geheimdienst: hehe, Alan did good
13:11:09 <tommd> mart_: cabal unpack text ; vi text-*/src/Data/Text/IO.hs ... import System.IO (hGetBuffering) ... cd text-* ; cabal install
13:11:17 <copumpkin> mart_: why would that be in Data.Text.IO?
13:11:27 <mart_> tommd: oh, wait.  the cabal metadata says cabal-version: >= 1.2.3
13:11:27 <copumpkin> preflex: seen edwardk
13:11:27 <preflex>  edwardk was last seen on #haskell 13 days, 6 hours, 17 minutes and 54 seconds ago, saying: ;)
13:11:41 <tommd> mart_: And?
13:11:53 <tommd> mart_: Don't tell me your cabal is older than 1.2.3!
13:11:58 <mart_> tommd: it's already got an import,
13:12:21 <JoeyA> Is there a monadic version of fromMaybe?  I keep writing this a bunch of times:  x <- actionYieldingMaybe ; case x of Nothing -> return ...; Just x -> ...
13:12:40 <mart_> I'm not sure.  cabal-install version 0.6.2.  using version 1.6.0.3 of the Cabal library
13:13:10 <tommd> mart_: Both are a bit dated.  cabal update ; cabal install Cabal --reinstall ; cabal install cabal-install
13:13:10 <JoeyA> @hoogle m (Maybe a) -> m b -> (a -> m b) -> m b
13:13:31 <JoeyA> nada
13:13:34 <mart_> IO.hs has #if __GLASGOW_HASKELL__ <= 610 ... #else ...  import System.IO (hGetBuffering, ...
13:13:53 <tommd> JoeyA: lambdabot is dead right now.  Use the web hoogle or a locally installed one.
13:14:14 <JoeyA> yeah, did
13:14:15 <tommd> ok
13:14:19 <JoeyA> and it turned up nothing
13:14:25 <tommd> Not surprising
13:14:32 <JoeyA> m b -> (a -> m b) -> m (Maybe a) -> m b -- matches maybe and could be called maybeM
13:15:17 <mart_> tommd: this worked for me yesterday, before I re-installed.  is there any way to make things a bit more robust?
13:16:14 <tommd> mart_: Sure, there is need of a Mac dev team (see the recent reddit discussion on this) there is a leadership vacuum in all non-nix operating systems.  Mac and Windows users make periodic noise about the state of affairs but no one steps up.
13:17:42 <tommd> mart_: macports is in a known-old state that is actually incompatible with the HP release.  I'm not a mac user and not sure what the best fix is (how easy it is to get new packages pused onto macports) but you could investigate.
13:19:00 <mart_> tommd: I wouldn't even know what needs to be done.  :) the whole idea of macports seems flakey enough, and that's before adding another compile-from-source system on top.
13:19:45 <tommd> Well there are plenty of people with ideas if you wanted to take up the challenge.  No lack of directions/solutions to try.
13:20:39 <mart_> tommd: just checked versions: macports is on 6.10.4, and homebrew is on 6.12.3 ...
13:20:57 <mart_> would 6.12.3 give me an easier ride?
13:21:10 <bitstream0101> :quit
13:23:54 <tommd> mart_: 6.12.3 is a good version, I'd try it.
13:24:09 <gwern> I don't think I like sql too much. the syntax is too loose
13:24:11 <gwern> sqlite3 places.sqlite  "SELECT url FROM moz_places, moz_historyvisits WHERE moz_places.id = moz_historyvisits.place_id and visit_date > strftime('%s','now','-1 day')*1000000 ORDER by visit_date;"
13:24:15 <gwern> I mean really
13:24:16 <tommd> mart_: FWIW, though this never seemed in question, I can install hakyll fine on my Linux machine.
13:24:32 <gwern> also, that took like 2 hours to figure out. why isn't it easier to ask firefox for 'all new urls visited in the last day'?
13:24:45 <RichardBarrell> JoeyA: if you keep wanting a monadic fromMaybe for actions that return Maybe values, perhaps it would be a better idea to use a monad with error handling, instead?
13:26:42 <mart_> tommd: yeah,  I don't really understand why this worked yesterday before re-installing. :/
13:27:35 <gwern> well, now I have a solution to archiving all web pages I've seen. I can have cron use that sql to dump URLs to a file, and then invoke the archiver tool I wrote today to submit all the URLs to the Internet Archive & WebCite
13:28:02 <RichardBarrell> JoeyA: such as writing (ErrorT String m a) actions instead of (m (Maybe a)) actions.
13:28:29 <RichardBarrell> JoeyA: (ErrorT from Control.Monad.Error, which is part of the mtl. http://hackage.haskell.org/packages/archive/mtl/1.1.0.2/doc/html/Control-Monad-Error.html <- docs! :)
13:28:56 <JoeyA> Thanks, good thought.
13:29:49 <hpc> :t fail
13:30:09 <kmc> @unmtl ErrorT String m a
13:30:20 <hpc> no bot
13:30:21 <RichardBarrell> hpc: fail :: (Monad m) => String -> m a
13:30:25 <kmc> :(
13:30:36 <hpc> ErrorT String m a = Either String (m a)
13:30:41 <notabel> does anyone know of a library containing type (family) predicates for Signed and Unsigned over integral/word types?
13:30:56 <JoeyA> I just wish that combining multiple monad transformers didn't require weird syntax nesting:  newtype Foo a = Foo {unFoo :: StateT FooState (ErrorT String IO) a} (I guess that's right)
13:30:59 <benmachine> hmm, it seems haskell-src-exts parses unboxed tuple types but doesn't have any facility for unboxed tuple *values*
13:31:13 <JoeyA> But I guess that's how it's usually done.
13:31:16 <benmachine> what do they look like?
13:31:17 <JoeyA> (I'm using transformers, btw)
13:31:45 <tommd> yay, transformers!
13:31:49 <tommd> and monads-fd?
13:31:51 <JoeyA> Maybe I'm just skeered.
13:32:21 <JoeyA> Just transformers
13:33:24 <tommd> JoeyA: I feel like I should know you.  Do I?
13:34:27 <tommd> I'm guessing you aren't the comedian Joey Adams who died in 1999.  If you are, I don't want to know.
13:35:05 <RichardBarrell> On the internet, nobody knows you're a zombie.
13:35:07 <JoeyA> nope.
13:35:24 <aristid> RichardBarrell: well, you are a zombie, that is pretty obvious
13:35:26 <JoeyA> My name is Joey Adams, though.
13:35:47 <aavogt> JoeyA: you could instead have    newtype ComposeT inner outer m a = ComposeT { uncomposeT :: inner (outer m) a } ..., though that doesn't really clean things up
13:35:48 <RichardBarrell> Just don't let my flatmates know, it'd ruin my reputation.
13:39:43 <Olathe> On Linux, nobody can kill a zombie.
13:41:39 <tommd> Olathe: So Linux lacks a zombie killing game, big deal.
13:44:21 <mart_> oh, wait.  there's a thing called haskell platform, and you can torrent it.  who knew? :)
13:44:43 <gwern> but is RichardBarrell a philosophical zombie?
13:44:52 <wli> Games are probably more about armies of graphic artists these days than programming at all.
13:45:05 <gwern> wli: so I hear as well
13:45:11 <RichardBarrell> tommd: no, you literally can't kill (some) zombies. Fucking NFS.
13:46:06 <wli> D-state issues are fairly difficult to deal with.
13:47:08 <tommd> mart_: Yeah, that's what I was referring to when I said macports is actually incompatible with what HP is currently shipping
13:49:16 <mart_> tommd: yeah, that sentence makes a lot more sense now.
13:51:36 <monochrom> in linux, use waitpid() to kill zombies
13:52:36 <monochrom> there is also a more automatic way via sigaction()
13:53:00 <kmc> so anyone solve conal's puzzle yet?
13:53:21 <monochrom> is the puzzle hard?
13:53:24 * monochrom is lazy
13:54:51 <kmc> bottom of http://conal.net/blog/posts/lazier-functional-programming-part-1/
13:55:14 <monochrom> oh darn, conal is even lazier :)
13:55:31 <kmc> :)
13:59:47 <kmc> anyone mind spoilers-wise if i think out loud on this puzzle?
14:01:15 <monochrom> I don't mind.
14:01:26 <benmachine> the post that it links to confused me
14:01:30 <tkahn6> awesome sauce, there's an error in the new ghc6 package in ubuntu
14:01:36 <kmc> which benmachine?
14:01:41 <tkahn6>  hGetContents: invalid argument (invalid UTF-8 byte sequence)
14:01:55 <kmc> ghc 6.12 does locale-aware unicode I/O
14:01:58 <benmachine> oh no I'm silly
14:01:59 <benmachine> I think
14:02:01 <kmc> which is probably UTF-8 on your locale
14:02:06 <kmc> ghc before that did not
14:02:11 <tkahn6> what should i do?
14:02:13 <tkahn6> lol
14:02:15 <kmc> what are you trying to do?
14:02:18 <kmc> read a binary file?
14:02:20 <tkahn6> update ghc6
14:02:22 <tkahn6> like
14:02:28 <tkahn6> aptitude upgrade fails on ghc6
14:02:32 <mart_> tommd: One HP install; a cabal update; and a cabal install later, I now have hakyll installed.  thanks for your help.
14:02:34 <kmc> oh, damn
14:02:37 <tkahn6> yeah
14:02:38 <tkahn6> lol
14:02:43 <tkahn6> im on 10.10
14:02:50 <tkahn6> so it's to be expected i guess
14:03:53 <dolio> I don't see how 'either f g' could be less strict, really.
14:03:54 <tommd> mart_: NP, and sorry I didn't expand on HP.  Its always hard to gauge what people do/do not know over IRC.
14:04:18 <dolio> Unless we assume that f and g are non-strict, and produce compatible answers. But I don't see how to decide if that's the case.
14:04:34 <monochrom> tkahn6: covert your input files to proper UTF-8.
14:05:05 <monochrom> (there are other options of course, but I deplore them. everyone should just use UTF-8 for text files.)
14:05:36 <kmc> yeah
14:06:10 <Olathe> What's the term for a function that's hidden in the where block of another function?
14:06:24 <kmc> maybe a local function or helper function
14:06:28 <Olathe> Ahh, thanks.
14:06:28 <Martty> shadowed
14:06:30 <Martty> ?
14:06:42 <hpc> scoped function
14:06:42 <tkahn6> inner function?
14:06:48 <monochrom> ok I'll compromise. another option is change your program to switch to the encoding your input file uses. see http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-IO.html#23
14:06:58 <kmc> shadowing is when you locally bind a name that's already bound in an outer scope
14:07:27 <tkahn6> didnt know that
14:07:30 <Martty> maybe he meant the .."shadowee"
14:07:46 <monochrom> > let x+y {- shadowing -} =x*y in 2+2
14:07:54 <monochrom> @bot
14:08:28 <monochrom> oh well :)
14:09:51 <monochrom> there is likely a preflex command. I keep forgetting how to use preflex
14:10:01 <monochrom> preflex: > 2+2
14:11:50 <kmc> Cale, lambdabot seems to have vanished again :/
14:12:51 <monochrom> lim_{t→∞} λbot = 0
14:15:13 <Raghs> I when I do "ghci -package gio" - I keep getting the error C:\Haskell\lib\gio-0.11.1\ghc-6.12.3\HSgio-0.11.1.o: unknown symbol `_g_file_has_parent'  Loading package gio-0.11.1 ... linking ... : unable to load package `gio-0.11.1'
14:15:26 <Raghs> Any ideas on fixing this error with gio?
14:16:46 <monochrom> I don't understand conal's puzzle. It seems to be asking subjective things like what would you think what this programming language means.
14:16:58 <tommd> so where is the symbols _g_file_has_parent?  Is that part of the gio library?
14:17:19 <tommd> And why would you use a gnome library on Windows?
14:17:30 <mauke> monochrom: preflex only has a simple calculator
14:17:41 <Raghs> i am trying to use chart library in haskell
14:19:36 <tommd> Ah, GTK needs gio for something.  Hum, grr
14:20:05 <monochrom> oh I think I see, poor wording "interpretation" and "meaning".
14:23:22 <monochrom> the puzzle is better off specified as this: how to implement a function "myeither" less strict than haskell's "either" (but otherwise does the same thing of course), or even minimally strict. perhaps use a different programming language if necessary.
14:23:48 <hpc> :t either
14:23:53 <hpc> argh
14:24:04 <monochrom> either :: (a → c) → (b → c) → Either a b → c
14:24:12 <tommd> preflex: seen either
14:24:12 <preflex>  Sorry, I haven't seen either
14:24:17 <tommd> ;-)
14:24:19 <monochrom> haha
14:24:23 <hpc> how would you make a less strict version?
14:24:24 <kmc> monochrom, "meaning" as in "denotation"
14:24:52 <kmc> "is there a mathematical function consistent with the type and equations of 'either' which is less strict"
14:24:56 <either>  either :: (a → c) → (b → c) → Either a b → c
14:24:57 <kmc> leaving aside whether we can implement it in Haskell
14:25:03 <monochrom> and "interpretation" ?
14:25:23 <kmc> "interpretation" is the operator that maps Haskell code to mathematical objects
14:25:45 <hpc> lol
14:31:41 <monochrom> I would add nondeterminism to the mathematical domain to get things less strict. For the usual deterministic domain, there is likely proof that the usual ifThenElse is already minimally strict, for example.
14:33:14 <copumpkin> I think I finally convinced my most convoluted advanced type system design in haskell yet to work
14:33:22 <copumpkin> not that I'm designing type systems
14:33:31 <copumpkin> I just mean most convoluted use of type system features
14:33:49 <copumpkin> including GADTs, type families, data families, MPTCs, all in one module
14:33:58 * copumpkin feels disgusted
14:34:23 * benmachine feels copumpkin
14:34:32 <copumpkin> :O
14:34:33 <kmc> it seems like you could make «either f g» less strict iff you require «f ⊥ == g ⊥»
14:34:45 <benmachine> any overlapping instances?
14:34:52 <copumpkin> benmachine: eww, no
14:35:00 <benmachine> copumpkin: ah, excellent
14:35:01 <ben_m> When I see symbols like ⊥ my brain turns off.
14:35:05 <copumpkin> although some of my type families are not injective 
14:35:13 <copumpkin> ben_m: turn it back on
14:35:30 <mauke> ⊥ is just undefined
14:35:31 <ben_m> nurrrr.
14:35:34 <kmc> either f g = (\e → case e of Left x → f x; Right y → g y) `unamb` f ⊥ `unamb` g ⊥
14:35:37 <kmc> ben_m, why?
14:35:41 <benmachine> it's also let x = x in x and stuff
14:35:51 <luite> kmc: but that would change the "meaning" of the function, right? (whatever that means)
14:35:53 <ben_m> kmc: I'm not sure why.
14:35:56 <mauke> benmachine: that's also undefined
14:36:03 <kmc> ben_m, do you understand what ⊥ means?
14:36:24 <benmachine> mauke: do you mean Prelude.undefined, or something else?
14:36:26 <monochrom> like some people say, perhaps males sometimes thinks with their lower bodies, or something :)
14:36:33 <ben_m> Not at all, no. Didn't follow the conversation.
14:36:36 <kmc> ok
14:36:44 <kmc> if you'd like an explanation, just ask
14:36:49 <mauke> benmachine: mostly Prelude.undefined
14:36:55 <ben_m> Appreciate the offer :)
14:37:03 <luite> my terminal cuts off the bottoms, so they look like a mirrored L
14:37:06 <kmc> hehe
14:38:17 <benmachine> mauke: ...mostly, okay :P
14:39:06 <kmc> ⊥ just stands for any value which will not evaluate properly
14:39:20 <kmc> due to an infinite loop, an exception, etc.
14:39:41 <kmc> ("any expression", i should say... it's an expression that *doesn't* have a value)
14:40:09 <kmc> so «error "bleh"» and «let x = x in x» are both represented by ⊥
14:40:19 <kmc> and ordinary pure Haskell evaluation cannot tell them apart
14:40:39 <luite> I have to admit that I have no idea how to make it less strict without adding some requirements
14:40:40 <mauke> and undefined can be both
14:40:48 <illissius-> (what are data families good for beyond optimizing implementations for container types and such?)
14:45:40 <benmachine> luite: can you add any requirements that you can verify in some cases?
14:46:35 <luite> benmachine: you mean if f x == g x, you don't care about x?
14:46:48 <monochrom> I see, the usual ifThenElse is not minimally strict. not even among computable functions.
14:47:11 <benmachine> luite: I don't know what I mean, just a thought :P
14:47:51 <luite> I didn't make the puzzle, so you can change the rules as you like ;p
14:48:39 <taktoa> I am writing a definite integral function in Haskell
14:48:45 <taktoa> here's a pastebin: http://pastebin.com/TsFbCrjQ
14:49:33 <taktoa> when I run it it fails with a stack overflow error
14:50:06 <dankna> well, I would assume that your recursion does not terminate
14:50:25 <taktoa> me too.
14:50:35 <taktoa> how should I prevent that
14:50:38 <monochrom> however, known implementations of less strict versions are likely quite an overhead if you don't expect you need it so non-strict most of the time.
14:51:39 <taktoa> oh I see t
14:51:42 <dankna> by understanding the algorithm (which I don't, so I'm not sure how to fix it)
14:51:54 <taktoa> I figured it out
14:52:05 <dankna> and making sure that it always reduces to smaller cases in some sense of smaller
14:52:08 <dankna> oh good
14:52:08 <taktoa> when I call integraldef
14:52:17 <taktoa> on line 6
14:52:27 <taktoa> it goes into an infinite loop
14:52:33 <monochrom> yes, something fails to decrease, that's how to infinite-loop
14:52:57 <Martty> the problem is
14:53:05 <Martty> you are going over the bounds and not terminating i think
14:53:42 <taktoa> ok thanks by
14:54:08 <monochrom> he/she leaves before I manage to say "isn't haskell exciting?"
14:55:00 <tommd> taktoa is rather new - new to IRC too imho.
14:56:31 <monochrom> how do you guess? by the overuse of the enter key?
14:56:51 <dankna> I like
14:56:53 <dankna> short phrases
14:56:55 <dankna> instead
14:56:58 <dankna> of complete sentences
14:57:01 <dankna> it's like
14:57:03 <dankna> a haiku
14:57:05 <dankna> but nerdy
14:57:15 <patrickthomson> if e.e. cummings visited #haskell
14:57:19 <dankna> hah
14:59:59 <astor> where can I find the latest status for (nested) data parallell haskell... and how is the work from "Regular, shape-polymorphic, parallel arrays in Haskell" being integrated?
15:04:18 <copumpkin> astor: DPH appears to sort of be on hold, so I doubt it's advanced much. They're working on more constrained versions of the problems in things like vector/repa/accelerate for now, as far as I know
15:04:40 <copumpkin> (where vector, repa, and accelerate are all hackage package names, all three under fairly active development)
15:05:21 <dolio> kmc: Okay, I thought of an answer.
15:06:20 <dolio> myeither f g e = either f g e `lub` (if f undefined == g undefined then f undefined else undefined)
15:06:52 <copumpkin> yay, lub
15:07:29 <Martty> how do i round to a number of decimals?
15:07:30 <astor> copumpkin: ok. thanks for the update.
15:07:32 <dolio> I still have to ask why I actually care about this behavior, though. It doesn't strike me as being very useful.
15:09:06 <astor> copumpkin: so I understand that 'repa' is the result of the paper I mentioned, and from what you say it is incompatible with DPH, and accellerate is yet another incompatible parallel library?
15:09:28 <benmachine> dolio: you're introducing Eq constraints though, surely?
15:09:33 <copumpkin> astor: yes
15:09:43 <dolio> repa is the parallel arrays part of DPH, I thought.
15:09:48 <dolio> Released as a separate library.
15:09:54 * illissius- had the same impression
15:09:58 <dolio> benmachine: Yeah, that's true.
15:10:03 <copumpkin> I don't think it'll work with the DPH prelude types though?
15:10:19 <tommd> Martty: There are lots of ways to round.  I assume your wanting a Floating to Integral funciton?
15:10:24 <copumpkin> oh, maybe it will
15:10:29 <dolio> I don't really know.
15:10:34 <Martty> tommd: no, float to float with specific number of decimals
15:10:38 <copumpkin> looks like it depends on the DPH packages
15:10:41 <copumpkin> so it probably will
15:10:44 <dolio> I haven't looked at the data parallel stuff very closely.
15:11:13 <Peaker> hermosa seems to spam joiners to #haskell
15:11:14 <copumpkin> no, repa's array is a distinct type from the DPH parallel arrays
15:11:20 --- mode: ChanServ set +o copumpkin
15:11:31 <tommd> Martty: floor and ceiling are the popular ones and you can use fromIntegral to get back to float.  So something like:  (flip (/) 10^nrDec) . fromIntegral . floor .  (* 10^nrDec)
15:11:31 <Peaker> "-hermosa- Hola Peaker entra en mi pagina y hace click en el cuadro rojo para vernos por cam http://lulisoftcrm.blogspot.com te espero bebe"
15:11:35 --- mode: copumpkin set +b *!~ircap@190.189.21.253
15:11:38 --- kick: hermosa was kicked by copumpkin (Your behavior is not conducive to the desired environment.)
15:11:52 <Martty> tommd: ..wow
15:11:58 <dolio> benmachine: You have to ensure that f and g produce compatible output, though.
15:11:59 <tommd> Martty: You need to think about losing precision there, but that is the quick hack
15:12:00 <copumpkin> wow, my irc client puts pretentious kick messages in for me
15:12:07 --- mode: copumpkin set -o copumpkin
15:12:11 <Peaker> copumpkin, heh
15:12:13 <benmachine> neat
15:12:16 <benmachine> who's hermosa?
15:12:18 <tommd> Martty: There is probably a preexisting function.
15:12:21 <dolio> Oh man, copumpkin has ops?
15:12:36 <Peaker> co-ops
15:12:36 <copumpkin> lol
15:12:37 <tommd> Was he private messaging someone?  Or did I have him muted from some time ago?
15:12:57 <Saizan> Peaker quoted the spam
15:12:58 * copumpkin hides
15:13:03 <benmachine> oh right
15:13:14 <astor> copumpkin: do you know whether repa supports the nested data parallelism that Simon Peyton Jones talked about in his talk on nested data parallel haskell http://www.youtube.com/watch?v=NWSZ4c9yqW8 ? 
15:13:58 <copumpkin> astor: nah, the R in repa stands for regular, so you have regularly-shaped arrays only
15:14:16 <copumpkin> astor: as I said, the lofty goals of DPH have been broken down into smaller chunks to be examined separately
15:14:26 <copumpkin> and repa is one of them
15:14:37 <dolio> vector is another offshoot, I believe.
15:14:41 <copumpkin> at least, that was the impression I got from TacticalGrace 
15:15:12 <copumpkin> astor: for example, in DPH you could create a ragged array of arrays of different sizes
15:15:22 <copumpkin> in repa, the nested array has to be rectangular
15:15:27 <tommd> Martty: Ah, decodeFloat and encodeFloat can do it better, if you haven't already seen that.  As you can tell, I don't deal with Floating very often.
15:15:46 <copumpkin> but it can be arbitrarily nested
15:16:05 <Martty> O_o
15:17:11 <copumpkin> Martty?
15:17:17 <Martty> im puzzled
15:18:32 <tommd> Martty: Do you know how to use hoogle?
15:18:38 <Martty> yea 
15:18:40 <tommd> good!
15:18:45 <Martty> im looking at some
15:18:49 <tommd> That should be a start to unpuzzling ;-)
15:26:59 <Martty> http://www.ideone.com/866OU this did the trick
15:32:08 <Peaker> Martty, A single precedence rule worth remembering in Haskell is that normal function application is always "stronger" than infix
15:32:20 <Martty> oh man
15:32:25 <Martty> i have so many languages in my head
15:32:30 <Peaker> Martty, so the () around (f x) and (integ..) are not necessary
15:32:31 <Martty> i prefer putting brackets everywhere
15:32:40 <Peaker> Martty, then you get Lisp! :)
15:32:43 <Olathe> Wait. There's a web-based IDE?
15:32:45 <Martty> yea i do that
15:33:15 <dolio> There's web-based everything these days.
15:33:40 <Peaker> and yet web programming is still so crappy
15:33:54 <Peaker> What will come of Google's native code plugin?
15:33:54 <dolio> Quite a paradox.
15:34:18 <Peaker> Javascript is a pretty crappy client-side language
15:34:22 <tommd> plugin to what exactly?  Chrome?
15:34:43 <Peaker> tommd, I thought it would probably be for the major browsers
15:35:17 <tommd> Not sure I like the idea of web apps having native performance on my system.
15:35:32 <monochrom> I don't mind javascript, apart from tail calls. But I work around even that.
15:36:22 <monochrom> the DOM api is a bit too verbose, but not exactly javascript's responsibility
15:37:01 <monochrom> oh, I forgot lack of unlimited integers. that is a bit inconvenient.
15:41:11 <fxr> http://www.coretal.net/coretal.core javascript is ok but there's a lot of hack in the browser compatibility side.
15:42:07 <monochrom> k20? k123? g21? :)
15:42:42 <fxr> oh they're continuations.
15:42:57 <monochrom> yeah, the letter "k" suggests that. :)
15:43:21 <monochrom> (plus a bit of experience in having done a similar exercise by hand)
15:43:50 <monochrom> oh hi lambdabot ♥
15:44:01 <monochrom> I know lambdabot misses me!
15:44:18 <dankna> @vixen Do you miss monochrom?
15:44:19 <fxr> yep, the compiler generated symbols...
15:44:23 <lambdabot> let's don't talk about that
15:44:27 <monochrom> hahaha
15:44:29 <dankna> hehe
15:53:39 * hackagebot mtlx 0.1.4 - Monad transformer library with type indexes,  providing 'free' copies.  http://hackage.haskell.org/package/mtlx-0.1.4 (MarkSnyder)
15:53:49 <Phyx-> oh, I'm still on irc
15:54:14 <Saizan> Phyx-: actually, this is the inside of your mind
15:55:10 <Phyx-> NOOO, You won't get my secrets Saizan 
15:56:19 <fxr> how many primes can an integer represent?
15:56:35 <mauke> all of them
15:57:00 <dankna> just one at a time though
15:57:09 <mauke> Phyx-: http://www.newgrounds.com/portal/view/33440
15:57:20 <fxr> an int64?
15:57:31 <dankna> some finite, large quantity
15:59:12 <Phyx-> mauke: lol, wth, secret space robots? I get the feeling I'm missing a reference to something...
15:59:36 <Phyx-> Do.. you have more pictures of link? :P
15:59:52 <mauke> there are no more pictures
15:59:54 <Phyx-> awww
16:01:55 <monochrom> Some CPOs do not support 2-argument meet. But it seems those CPOs for non-strict languages and/or data types support 2-argument meet. With meet, there are minimally strict ifThenElse and either, and they are even computable, just more complicated and more overhead if you use them for strict purposes.
16:02:17 <Phyx-> too many accronyms... I can't keep them all straight sometimes
16:02:51 <monochrom> too many acronyms? I haven't even brought in C2PO and R2D2...
16:02:52 <fxr> > maxBound::Data.Int.Int64
16:02:55 <lambdabot>   9223372036854775807
16:03:11 <monochrom> perhaps C3PO
16:03:31 <Phyx-> we all know C1PO and C2PO malfunctioned
16:03:38 <monochrom> haha ok
16:04:10 <mauke> Phyx-: http://www.somethingawful.com/d/icq-pranks/icq-transcript-space.php
16:07:19 <Phyx-> mauke: rofl, hahaha
16:07:49 <pickles> evening all
16:08:04 <pickles> few questions if anyone has a moment
16:08:40 <copumpkin> holy crap
16:08:49 <tommd> Not usually.  usually it's man made.
16:08:50 <Phyx-> a talking pickle!
16:08:52 <copumpkin> standalone deriving + large GADTs + deriving Ord gives fun error messages
16:08:59 <monochrom> Here is an example. (More acronym: "ite" stands for "ifThenElse".) ite True x y = x, ite False x y = y.  ("=" is math equal, not proglang definition) By monotonicity, ite ⊥ x y ⊑ x, ite ⊥ x y ⊑ y. If you now require minimal strictness, ite ⊥ x y = x⊓y.
16:09:03 <pickles> phyx: lol
16:09:13 <Phyx-> pickles: lol, don't ask to ask, just ask :)
16:09:30 <pickles> phyxtru, thot it'd be polite to ask to ask tho :)
16:09:42 <monochrom> More concretely. Suppose x,y are numbers like 3,5, then ite ⊥ 3 5 = ⊥, no surprise here.
16:09:43 <pickles> 1st question is that Control.Monad.Either doesn't seem to be installed by default on my ubuntu ghc by default, was wondering if anyone knew offhand what package to use to get it
16:09:43 <mauke> pickles: how rude. you have to ask to ask to ask first
16:09:44 <Phyx-> pickles: even if they don't have a minute, if you hold a piece of candy infront of them, they'll do anything you want
16:09:50 <Phyx-> and i do mean, ANYTHING
16:09:58 <pickles> lol
16:10:07 <pickles> if candy will get ppl to do anything ,what will beer do?
16:10:19 <tommd> IRC is a low-bandwidth medium so generally you can just get to the point and people don't feel burdened.
16:10:26 <mauke> does Control.Monad.Either exist?
16:10:33 <pickles> apparently it does
16:10:39 <monochrom> But suppose x,y are lists like 0:0:⊥ and 0:⊥. Then ite ⊥ (0:0:⊥) (0:⊥) = 0:⊥.
16:10:40 <pickles> http://comonad.com/haskell/category-extras/dist/doc/html/category-extras/Control-Monad-Either.html
16:10:40 <Phyx-> where?
16:10:47 <mauke> category-extras
16:10:47 <Phyx-> oh
16:10:51 <Phyx-> category-extras
16:10:58 <Phyx-> mauke types fast
16:11:03 <copumpkin> here, this is what GHCI spat back at me when I accidentally tried to derive Ord when it didn't make sense to: http://dl.dropbox.com/u/361503/holyshit.txt
16:11:04 <pickles> heheh
16:11:09 <Phyx-> pickles: you need to install that package
16:11:12 <pickles> mmk
16:11:13 <pickles> thx
16:11:30 <Phyx-> pickles: you know how right
16:11:31 <Phyx-> ?
16:11:36 <pickles> second question is if anyone has done any sort of multi-tier error system
16:11:38 <pickles> yeah
16:11:42 <pickles> should be able to find it
16:11:53 <pickles> either cabal or the package management system
16:12:23 <monochrom> Similarly, minimally strict either does not require f ⊥ = g ⊥. either f g ⊥ = f ⊥ ⊓ g ⊥. Perhaps f ⊥ = 0:0:⊥ and g ⊥ = 0:⊥, so either f g ⊥ = 0:⊥
16:12:25 <Phyx-> pickles: beer will get them drunk and unhelpful, I don't recommend it
16:12:29 <pickles> lol
16:12:37 <Phyx-> especially lambdabot, she gets a bit crazy...
16:14:03 <pickles> im trying to implement an error system in a multi-step program where there are errors that will abort the process, and there are warnings that should be noted but won't necessitate an abort
16:14:14 <pickles> was wondering if anyone here might have insight into this
16:14:27 <monochrom> To implement this: perform "speculative execution" of both branches and find out where they differ. Return whatever is common to both. Where they first differ, now wait for your Bool or Either to return a definite answer before you commit to the correct branch.
16:14:31 <pickles> (I already have something sorta going, but it seems like it could be done better)
16:15:43 <Phyx-> pickles: well, I usually use a State monad 
16:16:02 <Phyx-> and logging errors just writes to stdout and moves on
16:16:05 <Phyx-> err
16:16:07 <Phyx-> warnings
16:16:11 <Phyx-> and errors kills it
16:16:11 <pickles> mm
16:16:51 <Phyx-> and within errors i call exitFailure to stop it all
16:17:02 <pickles> previously i was using a monad stack: state for each pass, and a writer for error logging
16:17:09 <pickles> hm
16:17:22 <benmachine> pickles: you could use ErrorT for aborting a computation
16:17:46 <pickles> i was also using errorT in that stack
16:17:52 <pickles> and a reader too, i think...
16:17:57 <Phyx-> just how long was that monad..
16:17:59 <pickles> currently im trying to string the steps together with an Either monad
16:18:05 <benmachine> monochrom: trouble is finding out where, e.g. functions differ
16:18:06 <pickles> h/o, lemmi look
16:18:33 <benmachine> monochrom: -,
16:18:55 <pickles> ah, was using writer/state on one step, and reader/state on another
16:19:00 <vkumar-0> Hi, I'm a Haskell (GHC) newbie. Why does "main = do putStrLn (show(1))" work, and "main = do putStrLn show(1)" fail? 
16:19:12 <pickles> might have had that all wrapped in an errorT, i forget
16:19:52 <benmachine> vkumar-0: main = do putStrLn show(1) parses as main = do putStrLn show 1, i.e. main = do ((putStrLn show) 1)
16:20:10 <benmachine> vkumar-0: functions in haskell are called by just putting stuff next to each other
16:20:10 <pickles> (the context is an Assembler, if that helps any)
16:20:20 <benmachine> vkumar-0: so what you want is main = putStrLn (show 1)
16:20:42 <vkumar-0> benmachine: Thanks!
16:20:57 <pickles> it wasn't killing execution mid-process, but accumulating errors for each processing step and if an error ocurred in one step, it would check after it finished that step and not do the next step if any errors had been recorded
16:21:29 <NemesisD> anyone do json deserialization in json? i'm looking at Text.Json and Text.RJson, i'm looking for the simplest way possible to turn a json object into [(String,String)] 
16:21:47 <Phyx-> ok, that's it
16:21:51 <Phyx-> i have to ask
16:22:00 <Phyx-> wtf is JSON and why do I keep hearing about it
16:22:27 <tommd> lol
16:22:32 <Phyx-> is this another thing like AJAX? pre-existing techniques slapped together under a marketting name?
16:22:34 <vkumar-0> Phyx: javascript object notation? It's a simple way of serializing objects, I imo
16:22:37 <tommd> Javascript over network
16:22:43 <tommd> basically its "over network"
16:22:48 <tommd> not that that is the name
16:22:56 <mauke> Phyx-: simple data serialization format
16:23:07 <Phyx-> ah ok
16:23:09 <tommd> See wikipedia
16:23:09 <mauke> supports numbers, strings, arrays, and maps
16:23:15 <NemesisD> trolling? json is javascript object notation
16:23:33 <Phyx-> why would I be trolling.. I don't do webdev at all
16:23:41 <NemesisD> i meant tommd
16:23:55 <Phyx-> oh
16:23:56 <Phyx-> lol
16:23:56 <tommd> NemesisD: No, I was trying to say serialization but couldn't get the word out
16:24:01 <Phyx-> carry on :)
16:24:03 <NemesisD> lol
16:25:19 <NemesisD> the types in json are so simple i don't see why there has to be so much boiler plate to deserialize it to a haskell value
16:25:25 <aristid> NemesisD: JSObject String can be converted to and from [(String, String)], and is an instance of class JSON, so you can use encode/decode on it
16:26:10 <aristid> those functions are toJSObject and fromJSObject
16:26:46 <fxr> nested or mutually recursive structures?
16:28:27 <aristid> Text.JSON> encode . toJSObject $ [("a", "b"), ("c", "d")]
16:28:27 <aristid> "{\"a\":\"b\",\"c\":\"d\"}"
16:29:51 <fxr> there must be a way to represent more complex structures, otherwise transformation costs will occupy most of the resources I guess
16:30:05 <NemesisD> aristid: im working on decoding which is a little least straightforward
16:30:49 <Peaker> monochrom, I didn't keep track, was the puzzle solved or not?
16:30:49 <lambdabot> Peaker: You have 1 new message. '/msg lambdabot @messages' to read it.
16:31:36 <aristid> NemesisD: i don't think it is less straightforward
16:33:05 <aristid> Text.JSON> fmap fromJSObject . decode $ "{\"a\":\"b\",\"c\":\"d\"}" :: Result [(String, String)]
16:33:05 <aristid> Ok [("a","b"),("c","d")]
16:33:11 <Peaker> copumpkin, hey, thanks for the link
16:33:16 <Peaker> copumpkin, I can't parse the type of "later" in there
16:33:27 <megajosh2> Hmm...
16:33:28 <Peaker> What does the "infinity symbol" mean in that context?
16:33:32 <Peaker> http://www.cs.nott.ac.uk/~nad/listings/lib/Category.Monad.Partiality.html#194
16:34:37 <megajosh2> > [5, '6'] :: [forall a. a]
16:34:38 <lambdabot>   Couldn't match expected type `a'
16:34:38 <lambdabot>         against inferred type `GHC.Types.C...
16:34:40 <copumpkin> Peaker: oh, a delayed/codata type
16:35:02 <NemesisD> aristid: i guess that line is less straight forward of me to come up with considering this is my second haskell program
16:35:04 <copumpkin> the # is a constructor for infinity
16:35:06 <NemesisD> thank you
16:35:13 <Peaker> copumpkin, why is (x :) used when "x" isn't used later in the type? Isn't the dependent type superfluous?
16:35:27 <copumpkin> you can think of # as "do it later" and b (the flat symbol) as "force"
16:35:47 <aristid> NemesisD: well i guess the fmap might not be totally obvious to a total beginner :)
16:35:51 <copumpkin> Peaker: so when you ask agda-mode to case split a parameter for you, it'll put in nice names, mostly
16:36:03 <copumpkin> Peaker: doesn't really serve any purpose beyond convenience
16:36:24 <ddarius> newsham: Your wep_tool is nice.
16:36:25 <Peaker> copumpkin, seems interesting
16:36:44 <Peaker> copumpkin, the run_for_steps is probably very inefficient :-)
16:37:01 <Peaker> copumpkin, unless inlined/unrolled completely :)
16:39:06 <Phyx-> it
16:41:01 <monochrom> hi Peaker, I have sketched an alleged solution.
16:42:12 <monochrom> benmachine: yeah I'm too lazy to do that part. but then maybe that's exactly the right thing to do, to compute f⊓g lazily.
16:43:10 <joker> guys I have data such as......data Shape = Circle Float Float Float | Rectangle Float Float Float Float
16:43:45 <joker> i read that value constructor Circle Float Float Float is also like a fuction 
16:43:48 <joker> is that correct
16:43:54 <benmachine> joker: yes
16:44:03 <Peaker> monochrom, The "straightforward thing" is to try to somehow compare the outer-most constructors based on Left and Right and if they are the same, recurse on content of constructors.. But not sure how to do that polymorphically
16:44:04 <benmachine> they can be used in the same places
16:44:17 <benmachine> well, value constructors can be used in patterns as well
16:44:28 <benmachine> but a value constructor can be used wherever a function can be, I think
16:44:32 <joker> function that takes 3 paramethars right?
16:44:41 <pickles> right
16:44:42 <ddarius> either f g ⊥ = f ⊥ ⊓ g ⊥ should be minimal
16:44:49 <monochrom> class Meetable t where ... :)
16:44:53 <benmachine> joker: yes, you can check with ghci
16:44:54 <Peaker> monochrom, "lub" and "unamb" both assume the functions agree on a result, right?
16:45:03 <Peaker> (at least, never disagree)
16:45:07 <joker> to show that this is funnction author shows this..map (Circle 10 20) [4,5,6,6]  
16:45:17 <joker> but here Circle has only 2 paramethars
16:45:17 <monochrom> I think so. I am not familiar with lub and unamb.
16:45:47 <Peaker> monochrom, introducing type-class constraints is cheating, I think :)
16:45:48 <ddarius> joker: What's the type of map?
16:45:58 <monochrom> hehe
16:46:13 <mauke> preflex: be BONUS 
16:46:13 <preflex>  CUT MY LIFE INTO PIECES, IM DOING BUBBLE SORT
16:46:20 <mauke> :3
16:46:22 <joker> map returns a list
16:46:49 <ddarius> joker: That wasn't what I asked.
16:47:21 <joker> well map is function that takes 2 paramethras......it takes function and list
16:47:30 <Olathe> preflex: Haha
16:47:32 <joker> and it returns list
16:47:53 <ddarius> joker: Okay, so what type would (Circle 10 20) have to be to be used in map as the first argument.
16:48:32 <joker> exactly..in my opinion Circle would have to have 3 paramethras like this....(Circle 10 20 30 ) for example
16:48:56 <benmachine> joker: but that would make a Shape
16:49:02 <QtPlatyp1s> joker: Have you read about currying?
16:49:03 <mauke> "exactly" doesn't answer "what type?"
16:49:28 <joker> read a little about it
16:49:31 <Olathe> joker: You can partially fill in functions. That gives you something that is waiting for the rest of the arguments to be filled in. Something that's waiting for arguments to be filled in is a function.
16:49:34 <QtPlatyp1s> :t (+)
16:49:35 <lambdabot> forall a. (Num a) => a -> a -> a
16:49:39 <QtPlatyp1s> :t (+) 1
16:49:40 <lambdabot> forall t. (Num t) => t -> t
16:49:52 <mauke> > (+) 2 3
16:49:53 <lambdabot>   5
16:50:00 <Peaker> :t (+) 1 2
16:50:01 <lambdabot> forall t. (Num t) => t
16:50:06 <hpc> > map (2 +) [1,2,3]
16:50:07 <mauke> > map ((+) 2) [1 .. 5]
16:50:07 <lambdabot>   [3,4,5]
16:50:08 <lambdabot>   [3,4,5,6,7]
16:50:28 <Olathe> joker: So, any function that's not completely filled out is still a function.
16:50:44 <Olathe> joker: It's just a function waiting for less arguments.
16:51:02 <QtPlatyp1s> If you have a function that takes 3 arguments and you pass it two, you get a function that takes the last argument (more or less).
16:51:27 <joker> wouldnt that give compiler error
16:51:32 <Olathe> joker: Functions in Haskell are patient like that.
16:51:44 <hpc> haskell is designed with this concept in mind
16:52:08 <Olathe> Yeah, the compiler is smart enough to deal with it correctly.
16:52:13 <Peaker> joker, you have to first understand that technically, *all* Haskell functions are functions of one argument
16:52:28 <hpc> all functions are of type a -> b
16:52:33 <hpc> the thing is, b can be a function
16:52:46 <Peaker> (so can a, but that's less relevant here :-)
16:53:13 <hpc> in this situation, b is called a closure
16:53:20 <mauke> what
16:53:26 <mauke> no
16:53:31 <hpc> oh crap, my bad
16:53:46 <joker> its like max  4 5 is actually.......(max 4 )  5
16:53:57 <Olathe> joker: Exactly.
16:54:04 <Olathe> > max 4 5
16:54:05 <lambdabot>   5
16:54:09 <Olathe> > (max 4) 5
16:54:10 <lambdabot>   5
16:54:12 <joker> max 4 5
16:54:23 <EvanCarroll> max 'a' 'z'
16:54:26 <monochrom> > let f = max 4 in (f 5, f 3)
16:54:27 <lambdabot>   (5,4)
16:54:31 <monochrom> works
16:54:38 <illissius-> copumpkin: holy crap :o
16:54:46 <mauke> > map (max 4) [2 .. 7]
16:54:46 <illissius-> I hope the manual instance isn't that long?
16:54:47 <lambdabot>   [4,4,4,5,6,7]
16:54:59 <joker> how do you get lababot to evaluate expressions here?
16:54:59 <monochrom> that's nice too
16:55:04 <mauke> joker: >
16:55:09 <illissius-> also, the last line ends in 226 consecutive closing parentheses.
16:55:19 <joker> >max 4 5
16:55:19 <illissius-> (and it's not even lisp!)
16:55:21 <monochrom> hahaha 226 parenthesis
16:55:24 <mauke> joker: space
16:55:26 <copumpkin> illissius-: no, I didn't mean to derive Ord on that type :)
16:55:35 <copumpkin> illissius-: but I wasn't expecting such a horrific error!
16:55:35 <Olathe> >4 -- fails
16:55:38 <joker> > max 4 5
16:55:40 <lambdabot>   5
16:55:40 <joker> lol
16:55:41 <Olathe> > 4 -- works
16:55:42 <lambdabot>   4
16:56:00 <joker>  > max 4 5
16:56:07 <Olathe> Also, lambdabot will respond if you do that in /query lambdabot
16:56:29 <Olathe> If you want to see a whole bunch of things.
16:56:45 <joker> i typed space and it didnt return result
16:56:46 <joker> lo
16:56:51 <joker>    > max 4 5
16:56:57 <joker>  > max 4 5
16:57:03 <Olathe> It gets lagged sometimes.
16:57:09 <Olathe> > 27
16:57:10 <lambdabot>   27
16:57:16 <monochrom> yeah, why it doesn't work for you, perhaps it subjective hates you
16:57:27 <monochrom> s/subjective/subjectively/
16:57:29 <joker>  > 27
16:57:30 <ddarius> Just to clarify, it's not that the Haskell implementation is being clever, quite the opposite.
16:57:47 <mauke> joker: no space before >
16:57:48 <joker>  > 27
16:57:53 <joker> >27
16:57:59 <joker> >max 4 5
16:58:00 <rizzix> oh wow man come on
16:58:08 <Phyx-> :t 4
16:58:09 <lambdabot> forall t. (Num t) => t
16:58:10 <mauke> joker: you are now failing manually
16:58:14 <Olathe> @run 4
16:58:14 <lambdabot>   4
16:58:15 <Phyx-> > 27
16:58:16 <lambdabot>   27
16:58:29 <monochrom> do you know how to count spaces?
16:58:52 <Phyx-> > length "       "
16:58:53 <lambdabot>   7
16:58:55 <Phyx-> i do :)
16:58:56 <DanielDiaz> > let loop = loop in loop
16:59:00 <lambdabot>   mueval-core: Time limit exceeded
16:59:01 <ddarius> monochrom: Perhaps all his fingers and toes were burned off in a horrible accident.
16:59:06 <mauke> > fix id
16:59:10 <joker> lol darius
16:59:10 <lambdabot>   mueval-core: Time limit exceeded
16:59:13 <Olathe> > fix internet
16:59:14 <lambdabot>   Not in scope: `internet'
16:59:22 <Phyx-> > id
16:59:23 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
16:59:23 <lambdabot>    arising from a use of `...
16:59:29 <JoeyA> In HDBC, is finish idempotent?  That is, is it safe to call finish on a Statement multiple times?
16:59:33 <Phyx-> wth is it overlapping with
17:00:12 <hpc> Phyx-: Num b => a -> b is an instance of Num
17:00:25 <hpc> that's my guess, at least
17:00:31 <joker> > max 4 5
17:00:32 <lambdabot>   5
17:00:36 <Olathe> (+2) + 5
17:00:38 <Olathe> > (+2) + 5
17:00:39 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:00:39 <lambdabot>    arising from a use of `...
17:00:42 <Phyx-> > id :: String -> String
17:00:44 <lambdabot>   Overlapping instances for GHC.Show.Show
17:00:46 <lambdabot>                              (GHC.B...
17:00:49 <Phyx-> ...
17:00:53 <joker> > :t max
17:00:54 <lambdabot>   <no location info>: parse error on input `:'
17:00:56 <Olathe> :t (+2) + 5
17:00:57 <lambdabot> forall a. (Num a) => a -> a
17:01:04 <aristid> > (cos ^ 2 + sin ^ 2) 0
17:01:05 <lambdabot>   1.0
17:01:06 <Olathe> Wow
17:01:18 <joker> > 6
17:01:20 <lambdabot>   6
17:01:27 <Phyx-> > (+2) + 5 5
17:01:29 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:01:29 <lambdabot>    arising from a use of `...
17:01:35 <Phyx-> > ((+2) + 5) 5
17:01:36 <lambdabot>   12
17:01:42 <Phyx-> wtf....
17:01:46 <Phyx-> :t (+2)
17:01:47 <lambdabot> forall a. (Num a) => a -> a
17:01:56 <c_wraith> > 2 5
17:01:57 <aristid> Phyx-: it is awesome, is it not?
17:01:57 <lambdabot>   Ambiguous type variable `t' in the constraint:
17:01:57 <lambdabot>    `GHC.Num.Num t' arising f...
17:02:00 <Phyx-> :t (+2) +
17:02:01 <lambdabot> parse error (possibly incorrect indentation)
17:02:04 <aristid> > 2 5 :: Integer
17:02:05 <c_wraith> > 2 5 :: Int
17:02:05 <Phyx-> :t ((+2) +)
17:02:05 <lambdabot>   2
17:02:06 <lambdabot>   2
17:02:06 <lambdabot> forall a. (Num a) => (a -> a) -> a -> a
17:02:08 <hpc> fromIntegral = const
17:02:12 <Phyx-> :t ((+2) +) 6
17:02:13 <lambdabot> forall a. (Num a) => a -> a
17:02:25 <Phyx-> aristid: it's brainfuck, haskell style
17:02:35 <mauke> Phyx-: http://mauke.ath.cx/stuff/haskell/fun.hs
17:02:37 <Mathnerd314> is there an instance of Applicative for (a,a) ?
17:02:39 <Phyx-> since when is 6 of type (a->a)
17:03:00 <Olathe> :t fromInteger
17:03:00 * Phyx- looks
17:03:01 <lambdabot> forall a. (Num a) => Integer -> a
17:03:12 <aristid> Phyx-: there's nothing complicated about the Num instance for Num a => e->a
17:03:20 <Olathe> Phyx-: When you use fromInteger to give an a -> a.
17:03:47 <Saizan> 6 has always been polymorphic anyhow
17:03:58 <Phyx-> mauke: I remember sometime ago, when you typed like > id it would give () -> ()
17:04:05 <Olathe> "Haskell: it has polymorphic 6s"
17:04:19 <Phyx-> Saizan: sure, but always to a sane value :P
17:04:20 <aristid> > id
17:04:21 <lambdabot>   Overlapping instances for GHC.Show.Show (a -> a)
17:04:21 <lambdabot>    arising from a use of `...
17:04:27 <Phyx-> Olathe: hax!
17:04:43 <Phyx-> :t fromInteger
17:04:44 <lambdabot> forall a. (Num a) => Integer -> a
17:04:52 <monochrom> there is not an instance of Applicative for (a,a). if you fix a type t and it is a Monoid, there is an instance Applicative ((,) t).
17:04:57 <Phyx-> :t fromInteger 6 :: Num a => a -> a
17:04:58 <lambdabot> forall a. (Num a) => a -> a
17:05:19 <Phyx-> > (fromInteger 6 :: Num a => a -> a) 7
17:05:20 <lambdabot>   6
17:05:25 <Phyx-> so it's just const
17:05:34 <monochrom> that means typical types are like (t,a), (t,b), (t,Int), etc.
17:05:46 <Zao> Phyx-: I expect some clever wanker has @let 6.
17:06:05 <Phyx-> :t ((+2) +) 3
17:06:06 <lambdabot> forall a. (Num a) => a -> a
17:06:08 <Phyx-> :t ((+2) +) 345555
17:06:09 <lambdabot> forall a. (Num a) => a -> a
17:06:24 <Zao> Or otherwise mangled the state of poor botty.
17:06:26 <Phyx-> Zao: nope, seems to just indeel overload to (a->a)
17:06:41 <Olathe> Zao: It's a library they loaded into lambdabot.
17:07:12 <Zao> > 6 6 6 6 6 6 (7 :: Int)
17:07:13 <lambdabot>   6
17:07:15 <Saizan> Phyx-: the instance is very simple, it just lifts everything to the reader monad
17:07:27 <Zao> How useless. Preferably if you want to demonstrate things with lambdabot.
17:07:40 <Zao> (yes, I hate (.) = fmap too)
17:07:51 <Zao> s/Preferably/Especially/
17:07:56 <hpc> i like that one
17:07:56 <Phyx-> Saizan: aha
17:08:13 <hpc> it helps to think of it as (.) = (<$>)
17:08:27 <Phyx-> > () + ()
17:08:28 <lambdabot>   No instance for (GHC.Num.Num ())
17:08:29 <lambdabot>    arising from a use of `GHC.Num.+' at <i...
17:08:42 <Peaker> hpc, why not Control.Category..?
17:08:46 <Phyx-> hpc: i think both of those don't help
17:09:05 <hpc> :t (Control.Category..)
17:09:06 <lambdabot> forall (cat :: * -> * -> *) b c a. (Control.Category.Category cat) => cat b c -> cat a b -> cat a c
17:09:14 <hpc> heh
17:09:15 <Mathnerd314> monochrom: well, instance X for a newtype X a = (a,a)
17:09:44 <Saizan> the places where Control.Category.. works are fairly less common
17:09:46 <ddarius> Zao: The function instance isn't Caleskell, it's comes from the vector-space package.
17:09:47 <Phyx-> > 8 + 8
17:09:47 <monochrom> I don't think it can be done.
17:09:48 <lambdabot>   16
17:09:58 <Phyx-> > (8 + 8) 6
17:09:59 <lambdabot>   16
17:10:34 <mauke> > (sin + 1) 2
17:10:35 <lambdabot>   1.9092974268256817
17:10:39 <Phyx-> :t (0.0)
17:10:40 <lambdabot> forall t. (Fractional t) => t
17:10:46 <Phyx-> an emoticon with type
17:10:55 <Saizan> Applicative X can be done, it's just Applicative (Vec 2), which is quite similar to ZipList
17:10:57 <hpc> whoa, that trig trick is funny
17:11:02 <mauke> > (sin / cos) 1
17:11:03 <lambdabot>   1.557407724654902
17:11:11 <mauke> tan = sin / cos
17:11:14 <hpc> :D
17:11:18 <aristid> > tan 1
17:11:19 <lambdabot>   1.5574077246549023
17:11:29 <hpc> > let tan = sin / cos in tan 1
17:11:30 <lambdabot>   1.557407724654902
17:11:41 <hpc> ah, floats
17:11:51 <aristid> :t liftM2 (==) (sin/cos) tan
17:11:52 <lambdabot> forall a. (Floating a) => a -> Bool
17:11:57 <aristid> @check liftM2 (==) (sin/cos) tan
17:11:58 <lambdabot>   No instance for (GHC.Real.Fractional (a -> a))
17:11:58 <lambdabot>    arising from a use of `GH...
17:12:29 <hpc>  @check has some instance thing that it increments over and over
17:12:30 <Olathe> @check \x -> (sin/cos) x == tan x
17:12:31 <lambdabot>   No instance for (GHC.Real.Fractional (a -> a))
17:12:31 <lambdabot>    arising from a use of `GH...
17:12:35 <hpc> it's QuickCheck or something
17:12:39 <Olathe> Lies!
17:12:55 <aristid> "GH..." makes for a lot of trouble.
17:13:03 <hpc> yeah...
17:13:12 <Olathe> You can do it in private to get a longer message.
17:13:14 <hpc> three guesses what the next letter is :P
17:13:19 <c_wraith> Q?
17:13:30 <Olathe> That's only one guess.
17:13:37 <mauke> QQQ
17:14:00 <c_wraith> I was waiting for an answer before my second guess
17:14:08 <Saizan> @check \x -> (sin/cos) x == tan (x :: Double)
17:14:09 <lambdabot>   No instance for (GHC.Real.Fractional
17:14:09 <lambdabot>                     (GHC.Types.Double ...
17:14:20 <Saizan> i guess they don't have the same instances in scope
17:14:28 <aristid> too bad
17:15:10 <Phyx-> :t cake
17:15:11 <lambdabot> [[Char]]
17:15:26 <Olathe> zomg
17:15:32 <Phyx-> :t unsafeCoerce
17:15:33 <lambdabot> Not in scope: `unsafeCoerce'
17:16:00 <Olathe> sum . map (sum . map ord) $ cake
17:16:03 <Olathe> > sum . map (sum . map ord) $ cake
17:16:04 <lambdabot>   132221
17:16:07 <aristid> > cake
17:16:08 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
17:16:14 <aristid> oh right.
17:16:32 <c_wraith> heh.  L.hs needs "type Delicious = [[Char]]" and "cake :: Delicious"
17:16:39 <Olathe> > length . concat $ cake
17:16:40 <lambdabot>   1393
17:16:52 <Phyx-> :t group $ concat cake
17:16:53 <lambdabot> [[Char]]
17:16:55 <Olathe> > 132221/1393
17:16:56 <lambdabot>   94.91816223977028
17:17:01 <Phyx-> > group $ concat cake
17:17:02 <lambdabot>   ["O","n","e"," ","1","8",".","2","5"," ","o","u","n","c","e"," ","p","a","c...
17:17:15 <hpc> > length . concatMap length $ cake
17:17:16 <lambdabot>   Couldn't match expected type `[a]'
17:17:16 <lambdabot>         against inferred type `GHC.Types...
17:17:21 <hpc> er
17:17:22 <Phyx-> > group $ sort $ concat cake
17:17:23 <lambdabot>   ["                                                                         ...
17:17:24 <c_wraith> > group . sort . concat $ cake
17:17:25 <lambdabot>   ["                                                                         ...
17:17:30 <c_wraith> oh
17:17:35 <hpc> lol
17:17:36 <Phyx-> lmfao
17:17:37 <c_wraith> > map head . group . sort . concat $ cake
17:17:38 <lambdabot>   " ',-.1258:ACDFINOPSTUabcdefghijklmnoprstuvwxyz"
17:18:22 <Olathe> > map (\xs -> (head xs, length xs)) . group . sort . concat $ cake
17:18:23 <lambdabot>   [(' ',162),('\'',3),(',',4),('-',4),('.',43),('1',1),('2',1),('5',1),('8',1...
17:18:46 <Olathe> > sort . map (\xs -> (length xs, head xs)) . group . sort . concat $ cake
17:18:46 <c_wraith> olathe, try &&&
17:18:47 <lambdabot>   [(1,'1'),(1,'2'),(1,'5'),(1,'8'),(1,':'),(1,'D'),(1,'N'),(1,'P'),(1,'U'),(1...
17:18:57 <Phyx-> reverse that
17:19:09 <hpc> > sort . map (head &&& length) . group . sort . concat $ cake
17:19:10 <Olathe> > sort (flip compare) . map (\xs -> (length xs, head xs)) . group . sort . concat $ cake
17:19:10 <lambdabot>   [(' ',162),('\'',3),(',',4),('-',4),('.',43),('1',1),('2',1),('5',1),('8',1...
17:19:10 <lambdabot>   Couldn't match expected type `[a]'
17:19:11 <lambdabot>         against inferred type `a1 -> a1 ...
17:19:13 <Olathe> > sortBy (flip compare) . map (\xs -> (length xs, head xs)) . group . sort . concat $ cake
17:19:14 <lambdabot>   [(162,' '),(156,'e'),(91,'a'),(89,'r'),(85,'s'),(79,'n'),(70,'o'),(62,'t'),...
17:19:25 <Olathe> I hate arrows
17:19:29 <hpc> heh
17:19:32 <Phyx-> lol
17:19:37 <Phyx-> arrows are nice
17:19:42 <aristid> > transpose cake
17:19:43 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
17:19:46 <hpc> i only use them to screw with tuples
17:19:54 <Olathe> aristid: Haha
17:19:55 <hpc> ASCIICAT!
17:19:58 <Phyx-> wth
17:20:01 <Phyx-> :t transpose
17:20:02 <lambdabot> forall a. [[a]] -> [[a]]
17:20:06 <aristid> > nub . concat . transpose $ cake
17:20:07 <lambdabot>   "OTFDPCAUNSInhowiualdrespb j't1cyvg8.f2m5-k,z:x"
17:20:13 <aristid> simplified.
17:20:16 <dankna> > cake
17:20:17 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
17:20:21 <dankna> oh
17:20:31 <mauke> > cake !! 12
17:20:32 <lambdabot>   "Fish shaped dirt."
17:20:36 <dankna> lol
17:22:03 <mauke> > text . map (chr . (0xfee0 +) . ord) . (!! 13) $ cake
17:22:04 <lambdabot>   Ｆｉｓｈ＀ｓｈａｐｅｄ＀ｅｔｈｙｌｂｅｎｚｅｎｅ．
17:23:24 <Phyx-> > cake `is` lie
17:23:25 <lambdabot>   True
17:23:58 <Olathe> :t (is, lie)
17:24:00 <lambdabot> forall a a1. (Typeable a, Typeable a1) => (a -> a1 -> Bool, [[Char]])
17:24:12 <c_wraith> > lie
17:24:13 <lambdabot>   [""]
17:24:18 <aristid> > 4 is 5
17:24:19 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:24:19 <lambdabot>    `Data.Typeable.Typeable a...
17:24:25 <Olathe> > is 4 5
17:24:26 <lambdabot>   True
17:24:35 <aristid> > is 4 4.0
17:24:36 <lambdabot>   False
17:24:40 <hpc> :t is
17:24:41 <lambdabot> forall a a1. (Typeable a, Typeable a1) => a -> a1 -> Bool
17:24:45 <aristid> > is (4 :: Double) 4.0
17:24:46 <lambdabot>   True
17:24:58 <aristid> > lie
17:24:59 <lambdabot>   [""]
17:25:07 <mauke> @let a === b = cast a == Just b
17:25:08 <lambdabot>  Defined.
17:25:10 <aristid> @src transpose
17:25:10 <lambdabot> transpose []             = []
17:25:10 <lambdabot> transpose ([]   : xss)   = transpose xss
17:25:11 <lambdabot> transpose ((x:xs) : xss) = (x : [h | (h:t) <- xss]) : transpose (xs : [ t | (h:t) <- xss])
17:25:17 <Phyx-> :t on typeOf (==)
17:25:18 <mauke> > cake === lie
17:25:18 <lambdabot>     Couldn't match expected type `b -> c'
17:25:18 <lambdabot>            against inferred type `TypeRep'
17:25:19 <lambdabot>     In the first argument of `on', namely `typeOf'
17:25:20 <lambdabot>   False
17:25:25 <Phyx-> :t on (==) typeOf
17:25:27 <lambdabot> forall a. (Typeable a) => a -> a -> Bool
17:25:34 <Phyx-> not right type
17:25:39 <Olathe> > (is False False, is False True, is True False, is True True)
17:25:40 <lambdabot>   (True,True,True,True)
17:26:02 <Olathe> > is ()
17:26:03 <lambdabot>   Overlapping instances for GHC.Show.Show (a1 -> GHC.Bool.Bool)
17:26:03 <lambdabot>    arising fr...
17:26:06 <copumpkin> this is all pretty fascinating
17:26:09 <Olathe> > is () ()
17:26:11 <lambdabot>   True
17:26:22 <Olathe> > lie `is` lie
17:26:23 <lambdabot>   True
17:26:30 <mauke> Olathe: ok, you can stop now
17:26:37 <Olathe> OK :)
17:26:40 <hpc> > [False, True] >>= is [False, True]
17:26:44 <lambdabot>   Couldn't match expected type `[b]'
17:26:46 <lambdabot>         against inferred type `GHC.Bool....
17:26:54 <hpc> > [False, True] >>= is <$> [False, True]
17:26:57 <mauke> hpc: are you looking for liftM2?
17:26:58 <lambdabot>   Couldn't match expected type `[b]'
17:27:03 <hpc> er, yes
17:27:04 <lambdabot>         against inferred type `a1 -> GHC...
17:27:49 <Phyx-> :t liftM2 is
17:27:50 <lambdabot> forall a1 a2 (m :: * -> *). (Typeable a1, Typeable a2, Monad m) => m a1 -> m a2 -> m Bool
17:28:00 <Phyx-> :t liftA2 is
17:28:01 <lambdabot> forall a b (f :: * -> *). (Typeable a, Typeable b, Applicative f) => f a -> f b -> f Bool
17:28:11 <aristid> transpose . tails is the same as tails?
17:28:24 <hpc> > do {x <- [False, True]; y <- [False, True]; return $ is x y}
17:28:25 <lambdabot>   [True,True,True,True]
17:28:32 <c_wraith> > transpose . tails $ "abcd"
17:28:34 <lambdabot>   ["abcd","bcd","cd","d"]
17:28:48 <hpc> > tails "abcd"
17:28:49 <lambdabot>   ["abcd","bcd","cd","d",""]
17:28:57 <hpc> haha
17:28:59 <c_wraith> hmm, yeah.  flip that across its diagonal, and it's the same.
17:29:06 <Phyx-> :t on read is
17:29:07 <lambdabot>     Couldn't match expected type `String'
17:29:08 <lambdabot>            against inferred type `a1 -> Bool'
17:29:08 <lambdabot>     In the second argument of `on', namely `is'
17:29:11 <Phyx-> :t on is read
17:29:12 <lambdabot>     Ambiguous type variable `b' in the constraints:
17:29:12 <lambdabot>       `Typeable b' arising from a use of `is' at <interactive>:1:3-4
17:29:12 <lambdabot>       `Read b' arising from a use of `read' at <interactive>:1:6-9
17:29:33 <Phyx-> :t on is 
17:29:34 <lambdabot> forall b a. (Typeable b) => (a -> b) -> a -> a -> Bool
17:29:54 <Phyx-> :t on is id
17:29:55 <lambdabot> forall a. (Typeable a) => a -> a -> Bool
17:29:55 <mauke> Phyx-: why are you using 'on' in prefix form?
17:30:15 <hpc> oh i see why it complains
17:30:26 <Phyx-> mauke: it honestly hadn't occurred to me to used it infix :)
17:30:29 <hpc> b disappears from the type when you partially apply
17:31:22 <Phyx-> :t is `on` fmap
17:31:23 <lambdabot>     Ambiguous type variable `f' in the constraints:
17:31:23 <lambdabot>       `Functor f' arising from a use of `fmap' at <interactive>:1:8-11
17:31:23 <lambdabot>       `Typeable1 f' arising from a use of `is' at <interactive>:1:0-1
17:31:29 <Phyx-> :t is `on` (+1)
17:31:30 <lambdabot> forall a. (Typeable a, Num a) => a -> a -> Bool
17:31:46 <Phyx-> lol, that's useless
17:32:02 <mauke> because of on's type
17:32:07 <Phyx-> true
17:33:06 <Phyx-> @type ap is id
17:33:07 <lambdabot> forall a. (Typeable a) => a -> Bool
17:33:25 <Phyx-> > ap is id 8
17:33:26 <lambdabot>   True
17:33:30 <Phyx-> > ap is id ""
17:33:31 <lambdabot>   True
17:33:32 <Phyx-> lol
17:33:49 <mauke> :t join is
17:33:49 <mtnviewmark> :t is
17:33:50 <lambdabot> forall a. (Typeable a) => a -> Bool
17:33:50 <lambdabot> forall a a1. (Typeable a, Typeable a1) => a -> a1 -> Bool
17:34:48 <Phyx-> that's basically const True
17:35:10 <Phyx-> which only works for typable instances
17:35:11 <Phyx-> lol
17:35:19 <Phyx-> Typeable*
17:35:35 <Phyx-> :t L.a
17:35:36 <lambdabot> forall a. a -> a
17:35:47 <Phyx-> > cake `is` L.a lie
17:35:48 <lambdabot>   True
17:35:50 <mauke> > a
17:35:51 <lambdabot>   Ambiguous occurrence `a'
17:35:51 <lambdabot>  It could refer to either `L.a', defined at <local...
17:35:53 <mauke> @undefine
17:35:54 <Phyx-> :t quite as catchy
17:35:55 <lambdabot> Not in scope: `quite'
17:35:55 <lambdabot> Not in scope: `as'
17:35:55 <lambdabot> Not in scope: `catchy'
17:35:59 <Phyx-> whoops
17:36:10 <Phyx-> aww mauke killed the fun
17:36:15 * Phyx- heads to bed
17:37:50 <bss03> @hoogle (Eq a) => (b -> a) -> b -> b -> Bool
17:37:50 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
17:37:50 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
17:37:51 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
17:38:11 <mauke> :t const (==)
17:38:12 <lambdabot> forall a b. (Eq a) => b -> a -> a -> Bool
17:38:46 <hpc> :t const const const const
17:38:47 <lambdabot> forall b a b1. b -> a -> b1 -> a
17:38:49 <mauke> :t on (==)
17:38:50 <lambdabot> forall b a. (Eq b) => (a -> b) -> a -> a -> Bool
17:39:10 <bss03> mauke: Yeah, that.
17:39:18 <bss03> I was looking for something like:
17:39:22 <hpc> ah! there's a flip in there somewhere
17:39:24 <hpc> :t const const
17:39:25 <bss03> :t Data.Ord.comparing
17:39:26 <lambdabot> forall a b b1. b1 -> a -> b -> a
17:39:26 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
17:39:41 <mauke> comparing f = compare `on` f
17:39:43 <hpc> that's funny
17:39:44 <bss03> But, you know, for "Eq".
17:39:54 <mauke> (==) `on` f
17:40:01 <hpc> :t const const const
17:40:02 <lambdabot> forall a b. a -> b -> a
17:40:06 * MamboJUmbo hi guys im new here..
17:40:06 <hpc> ahaha
17:40:15 <bss03> Danke.
17:40:31 <Peaker> :t const const "Bazoooga!"
17:40:32 <lambdabot> forall a b. a -> b -> a
17:41:19 <hpc> @let constst = const const
17:41:20 <lambdabot>  Defined.
17:41:30 <hpc> :t constst constst
17:41:31 <lambdabot> forall a b. a -> b -> a
17:42:28 <mauke> hmm. what would 'nst' do?
17:42:56 <hpc> const id, maybe?
17:44:31 <MamboJUmbo> :t showme the money
17:44:32 <lambdabot> Not in scope: `showme'
17:44:32 <lambdabot> Not in scope: `the'
17:44:32 <lambdabot> Not in scope: `money'
17:45:40 <kfish> MamboJUmbo, the money is of type lambda, as are the cats
17:46:19 <MamboJUmbo> kfish lol
17:46:40 <BrianHV> if I have a function foo :: String -> IO ()   and I want to run it on several args, is  mapM foo ["Hello", "world"]  the best choice, or is there a better one?
17:46:48 <tommd> let me = poor ; poor = (`div` 1000) ; the = ($) ; money = 10000 in show (me `the` money)
17:46:50 <tommd> > let me = poor ; poor = (`div` 1000) ; the = ($) ; money = 10000 in show (me `the` money)
17:46:51 <lambdabot>   "10"
17:47:08 <mauke> BrianHV: mapM_
17:47:33 <BrianHV> mauke: thanks.  at least I was close. :)
17:47:36 <MamboJUmbo> tommd thank you
17:48:01 <tommd> New people always should see the money
17:48:11 * MamboJUmbo smiles
17:48:21 <MamboJUmbo> yes
17:48:39 <Peaker> @let iddqd = "God mode activated"
17:48:40 <lambdabot>  Defined.
17:49:27 <mauke> @undefine
17:49:27 <mauke> @let iddqd = text "God mode activated"
17:49:28 <lambdabot>  Defined.
17:49:37 <tommd> Its still weird to me that the iddqd generation is ~30.
17:50:48 <ManateeLazyCat> @hoogle String -> Int -> [String]
17:50:49 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
17:50:49 <lambdabot> Prelude drop :: Int -> [a] -> [a]
17:50:49 <lambdabot> Prelude take :: Int -> [a] -> [a]
17:51:18 <ManateeLazyCat> @hoogle ByteString -> Int -> [ByteString]
17:51:18 <lambdabot> Prelude replicate :: Int -> a -> [a]
17:51:18 <lambdabot> Data.List replicate :: Int -> a -> [a]
17:51:18 <lambdabot> Data.ByteString drop :: Int -> ByteString -> ByteString
17:54:21 <ManateeLazyCat> Have any exist function do "wrapString :: String -> Int -> [String]"? wrapString will wrap string with given column and return lines?
17:55:30 <ManateeLazyCat> @hoogle wrapLine
17:55:31 <lambdabot> No results found
17:55:52 <ManateeLazyCat> :t Distribution.Simple.Utils.wrapLine
17:55:53 <lambdabot> Int -> [String] -> [[String]]
17:56:30 <ManateeLazyCat> > Distribution.Simple.Utils.wrapLine 10 ["Hello", "all", "  haskell  !"]
17:56:31 <lambdabot>   Not in scope: `Distribution.Simple.Utils.wrapLine'
17:58:11 <ManateeLazyCat> Great, wrapLine is i need....
18:04:05 <xiackok> how can i use web services like flickr, google etc. in haskell
18:05:24 <hpc> the same way as in any other language; figure out the URL format and do HTTP requests
18:05:28 <Amadiro> Through their respective APIs, I suppose
18:05:35 <hpc> or that
18:06:13 <xiackok> you mean use curl?
18:06:36 <hpc> :t curl
18:06:37 <lambdabot> Not in scope: `curl'
18:06:57 <Amadiro> xiackok, no, most of them offer APIs through stuff like SOAP, JSON HTTP requests, etc.
18:07:09 <Amadiro> So you can interact with them using that.
18:07:25 <newsham> ddarius: thank you
18:08:01 <xiackok> ok thanks
18:08:10 <xiackok> but which libraries can i use
18:08:28 <tommd> > let function x = x * x in function 52 -- see, I use '>' to evaluate something
18:08:28 <lambdabot>   2704
18:08:33 <Amadiro> xiackok, first you need to find out how those services want you to interface with them
18:08:38 <tommd> :type "blah"
18:08:46 <tommd> :t blah
18:08:47 <lambdabot> Not in scope: `blah'
18:09:00 <tommd> :t "blah"
18:09:00 <tommd> Grrr, so ":t" gives a type
18:09:01 <lambdabot> [Char]
18:09:02 <Amadiro> xiackok, lets say flickr offers you a SOAP api. Then you would use a SOAP library module to access it
18:09:13 <Olathe> @type "Blah"
18:09:14 <lambdabot> [Char]
18:09:19 <roconnor> I don't understand Conal's recent post
18:09:36 <xiackok> Amadiro: can we query hackage database with lambdabot?
18:09:54 <Amadiro> xiackok, I don't know.
18:10:01 <xiackok> Amadiro: ok thanks
18:10:29 <tommd> @dijnn Int -> Int
18:10:29 <lambdabot> Error: Undefined type Int
18:10:34 <tommd> @dijnn a -> a
18:10:35 <lambdabot> f a = a
18:10:40 <MamboJUmbo> tommd yes
18:10:43 <MamboJUmbo> im here..
18:10:47 <roconnor> rather I don't understand the point.
18:10:55 <tommd> There are also plugins (such as dijnn above) which you need to learn one at a time.
18:11:09 <MamboJUmbo> i see
18:11:10 <tommd> @seen MamboJUmbo
18:11:10 <lambdabot> Unknown command, try @list
18:11:11 <preflex>  MamboJUmbo was last seen on #haskell 1 second ago, saying: i see
18:11:23 <MamboJUmbo> lol
18:11:24 <tommd> and preflex will track people
18:11:27 <MamboJUmbo> smart bot
18:11:29 <tommd> preflex: seen MamboJUmbo
18:11:30 <preflex>  MamboJUmbo was last seen on #haskell 2 seconds ago, saying: smart bot
18:11:36 <tommd> Lambdabot used to, but now its dumber.
18:11:46 <MamboJUmbo> i see
18:11:53 <tommd> @tell MamboJUmbo keep hacking on Haskell!
18:11:53 <lambdabot> Consider it noted.
18:12:08 <tommd> MamboJUmbo++
18:12:13 <tommd> @karma MamboJUmbo
18:12:14 <lambdabot> MamboJUmbo has a karma of 1
18:12:15 <MamboJUmbo> lol
18:12:16 <lambdabot> MamboJUmbo: You have 1 new message. '/msg lambdabot @messages' to read it.
18:12:17 * hackagebot text 0.8.1.0 - An efficient packed Unicode text type.  http://hackage.haskell.org/package/text-0.8.1.0 (BryanOSullivan)
18:12:40 <siracusa> xiackok: Use Hayoo for API search: http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:13:46 <tommd> MamboJUmbo: Oh yes, you should know about hackage (hackage.haskell.org)  hoogle (for searching haskell functions by type or name) and hayoo (also searches, but type based searches aren't as good)
18:14:15 <xiackok> siracusa: i searched i found only shoap module. but its too simply. is there any good soap library for haskell
18:14:43 <MamboJUmbo> i see
18:14:54 <tommd> @hoogle ":: Maybe a -> a"  -- I want a function that takes  "Maybe a" and gives me an "a" 
18:14:54 <lambdabot> Parse error:
18:14:54 <lambdabot>   --count=20 "":: Maybe a -> a"  -- I want a function that takes  "Maybe a" and gives me an "a" "
18:14:55 <lambdabot>              ^
18:15:00 <tommd> @hoogle "Maybe a -> a"
18:15:00 <lambdabot> Parse error:
18:15:00 <lambdabot>   --count=20 ""Maybe a -> a""
18:15:00 <lambdabot>              ^
18:15:05 <tommd> darn hoogle
18:15:10 <tommd> @hoogle Maybe a -> a
18:15:11 <lambdabot> Data.Maybe fromJust :: Maybe a -> a
18:15:11 <lambdabot> Data.Maybe fromMaybe :: a -> Maybe a -> a
18:15:11 <lambdabot> Data.Monoid First :: Maybe a -> First a
18:15:26 <tommd> works different in IRC vs command line, FYI.  I always forget ;-)
18:15:48 <tommd> @hoogle head
18:15:48 <lambdabot> Prelude head :: [a] -> a
18:15:48 <lambdabot> Data.ByteString head :: ByteString -> Word8
18:15:49 <lambdabot> Data.List head :: [a] -> a
18:15:51 <MamboJUmbo> i see
18:21:12 <siracusa> xiackok: Maybe this might be interesting: http://www.dcs.shef.ac.uk/~simonf/HAIFA.html
18:21:41 --- mode: ChanServ set +o copumpkin
18:21:50 --- mode: copumpkin set -q tolkad!*@*
18:22:01 --- mode: copumpkin set -q *!*@unaffiliated/tolkad
18:22:16 <copumpkin> tolkad: any luck?
18:22:19 <tolkad> hi
18:22:23 <copumpkin> okay
18:22:33 --- mode: copumpkin set -o copumpkin
18:22:37 <tolkad> I found something interesting in ghci
18:22:44 <tolkad> @let f -1 = True
18:22:45 <lambdabot>  Defined.
18:22:49 <tolkad> @let f _ = False
18:22:50 <lambdabot>  Defined.
18:22:54 <tolkad> > f (-1)
18:22:55 <lambdabot>   Ambiguous occurrence `f'
18:22:55 <lambdabot>  It could refer to either `L.f', defined at <local...
18:22:59 <tolkad> -_-
18:23:03 <tolkad> > L.f (-1)
18:23:04 <lambdabot>   False
18:23:12 <tolkad> why is that false?
18:23:22 <dibblego> let f + 1 = True
18:23:35 <copumpkin> :t L.f
18:23:36 <lambdabot> forall t. t -> Bool
18:23:43 <roconnor> > (L.-) 4 1
18:23:44 <lambdabot>   True
18:23:44 <ddarius> :t (L.-)
18:23:45 <lambdabot> forall t t1. (Num t1) => t -> t1 -> Bool
18:23:45 <tolkad> oh damnit I forgot that stupid syntax :P
18:23:54 <tolkad> aren't they getting rid of that?
18:24:08 <roconnor> not to my knowledge
18:24:31 <roconnor> 4 L.- 1
18:24:33 <roconnor> > 4 L.- 1
18:24:34 <lambdabot>   True
18:24:55 <tolkad> http://en.wikibooks.org/wiki/Haskell/Pattern_matching#n.2Bk_patterns
18:24:58 <tolkad> "However, this exception is generally considered unsightly and has now been removed in the Haskell 2010 standard."
18:25:25 <copumpkin> it isn't an n+k pattern
18:25:52 <tolkad> oh then what is it?
18:26:02 <tolkad> :t L.f
18:26:03 <lambdabot> forall t. t -> Bool
18:26:12 <tolkad> hmm
18:26:19 <tolkad> :t L.-
18:26:20 <lambdabot> parse error on input `L.-'
18:26:24 <tolkad> :t (L.-)
18:26:25 <lambdabot> forall t t1. (Num t1) => t -> t1 -> Bool
18:26:39 <tolkad> is that a constructor...
18:26:40 <lispy> > let f (n + 2) = n in  f 4 -- n+k pattern
18:26:41 <lambdabot>   2
18:26:47 <copumpkin> tolkad: you bound two separate functions up there
18:26:59 <copumpkin> L.- and L.f
18:27:10 <copumpkin> if you look at the type of L.f it should show you that something's wrong
18:27:19 <copumpkin> forall t. t -> Bool
18:27:21 <tolkad> yeah I expected that to be integral
18:27:30 <copumpkin> means that it can't possibly be looking at the value of the parameter
18:27:44 <lispy> :t const False
18:27:45 <lambdabot> forall b. b -> Bool
18:27:58 <tolkad> how did I create two functions? I'm not familiar with this syntax
18:28:09 <tolkad> (I do understand the solution, use parentheses)
18:28:25 <copumpkin> Your @let f -1 = True parsed as let (-) f 1 = True
18:28:54 <copumpkin> you then separately did let f _ = False, which bound f
18:28:56 <tolkad> oh
18:29:08 <EliasAmaral> wasn't n+k patterns removed from language?
18:29:14 <lispy> EliasAmaral: yes
18:29:15 <tolkad> EliasAmaral: in 2010 standard
18:29:20 <copumpkin> EliasAmaral: tis isn't an n+k pattern, either way
18:29:23 <danderson> bah, concurrency is hard :(
18:29:24 <ivanm> but nothing implements Haskell 2010 yet
18:29:40 <xiackok> siracusa: thanks im looking
18:29:43 <tolkad> I was looking at STM
18:29:53 <tolkad> and it's really annoying it can't do IO
18:29:54 <lispy> ivanm: I think with GHC it's just a matter of passing the right flags to the compiler.  Right?
18:29:56 <tommd> Sure, you can get a human Haskell 2010 interpreter - it's just slower than, say, GHC.
18:30:15 <tolkad> I mean
18:30:16 <copumpkin> tolkad: with more flexibility comes less power ;)
18:30:19 <tommd> tolkad: How would you "retry" an IO action?
18:30:24 <tolkad> ok what about this
18:30:35 <ivanm> lispy: well, no _released_ compiler implements it yet ;-)
18:30:39 <danderson> if I want a bounded message channel (same as Control.Concurrent.Chan, but doesn't grow indefinitely) that handles asynchronous exceptions gracefully (ie. lets you use timeout), is using STM my only sane choice?
18:30:48 <tolkad> allow you to do ST outside of an STM and use it inside the STM too
18:30:52 <ivanm> lispy: but with GHC 7.0, IIRC you just have to use haskell2010 rather than base
18:30:54 <tolkad> that would be useful
18:31:02 <tolkad> although maybe you already can
18:31:04 <danderson> I tried to figure out lock ordering and operation cancellation using regular MVars and Chans, and got a headache.
18:31:04 <tommd> danderson: No, use bounded-chan
18:31:08 <copumpkin> tolkad: you can?
18:31:10 <tolkad> ST confuses me very much
18:31:12 <tommd> danderson: See hackage
18:31:12 <copumpkin> tolkad: ST turns pure, magically
18:31:15 <tolkad> I have no idea
18:31:17 <tommd> @hackage bounded-chan
18:31:17 <lambdabot> http://hackage.haskell.org/package/bounded-chan
18:31:27 <danderson> tommd: bounded-chan doesn't handle exceptions correctly
18:31:29 <tolkad> I never really thought of passing ST to something
18:31:45 <danderson> an async exception can leave the chan in a broken state
18:31:47 <tommd> @hackage BoundedChan
18:31:47 <lambdabot> http://hackage.haskell.org/package/BoundedChan
18:31:55 <tommd> danderson: No?
18:31:55 <danderson> yes, I do mean that one.
18:32:00 <tolkad> I don't really understand RankNTypes in general 
18:32:06 <tommd> danderson: Have you complained to Adam?
18:32:25 <copumpkin> tolkad: they're kind of advanced...
18:32:38 <tommd> danderson: And yes, it could be that STM is your only sane choice in the presence of exceptions.
18:32:48 <EliasAmaral> http://lambda-the-ultimate.org/node/4068
18:33:02 <danderson> tommd: not yet, though I will, if only so that it gets added to the package docs.
18:33:21 <EliasAmaral> accordingly to some poster: rank-n types are types with a "forall" in a place other than the beginning of the type
18:33:32 <tommd> Be sure to imply he doesn't have anything else on his plate.  Adam has lots of spare time.
18:33:43 <danderson> (a write to the chan atomically increments the write index, then atomically writes a new value - an exception that hits between the two leaves a hole in the channel that will deadlock readers)
18:33:48 <copumpkin> lol
18:34:26 <EliasAmaral> like forall α. (forall s. ST s α) -> α, instead of just forall α. α -> α (which can be abbreviated to remove the forall)
18:34:55 <EliasAmaral> (but I don't understand it actually)
18:34:57 <danderson> tommd: don't worry, I will make it clear that I expect this unacceptable situation to be fixed promptly. Nothing can be more important, surely!
18:35:59 <monochrom> The damage is done. I have replied to conal's blog.
18:37:27 <aavogt> EliasAmaral: it means the function  ex. ( f :: (forall a. Num a => a -> a) -> ... )   is taking an argument which is a polymorphic function
18:38:11 <aavogt> otherwise you aren't allowed to write a function that takes say  (\x -> x + 1), and apply it to some Double and some Integer
18:40:45 <tolkad> @let test n + k = n - k
18:40:45 <lambdabot>   Parse error in pattern: Var (UnQual (Ident "test"))
18:40:54 <tolkad> huh...
18:41:18 <tolkad> @let test n + 37.2 = n
18:41:19 <lambdabot>   Parse error in pattern: Var (UnQual (Ident "test"))
18:41:26 <tolkad> @let test2 n + 37.2 = n
18:41:26 <lambdabot>   Parse error in pattern: Var (UnQual (Ident "test2"))
18:41:32 <tolkad> @let testx n + 37.2 = n
18:41:32 <lambdabot>   Parse error in pattern: Var (UnQual (Ident "testx"))
18:41:35 <tolkad> @let testx n + 37 = n
18:41:35 <lambdabot>   Parse error in pattern: Var (UnQual (Ident "testx"))
18:41:41 <tolkad> @let testx n = n
18:41:42 <lambdabot>  Defined.
18:41:45 <tommd> Who broke the bot?
18:41:52 <tommd> Oh, it's tolkad, isn't it?
18:41:56 <tolkad> I guess lambdabot doesn't support n + k patterns?
18:41:56 <tommd> nm
18:42:08 <aavogt> you need parentheses don't you?
18:42:13 <tolkad> oh
18:42:16 <aavogt> > let f (x+1) = x in f 3
18:42:17 <lambdabot>   2
18:42:26 <aavogt> > let f (x+1) = x in f 0
18:42:27 <lambdabot>   *Exception: <interactive>:1:145-155: Non-exhaustive patterns in function f
18:42:27 <tolkad> @let test (n + 37.2) = n
18:42:27 <lambdabot>   Parse error in pattern:
18:42:37 <tolkad> > test n
18:42:37 <lambdabot>   Not in scope: `test'
18:42:41 <tolkad> @let test (n + 37.2) = n
18:42:41 <lambdabot>   Parse error in pattern:
18:42:52 <tolkad> oh thanks that's descriptive
18:42:58 <aavogt> tolkad: they let you pretend you're using some natural numbers (I forget if 0 counts here..)
18:42:58 <tolkad> @let test (n + 37) = n
18:42:59 <lambdabot>  Defined.
18:43:06 <tolkad> test n
18:43:09 <tolkad> > test n
18:43:10 <lambdabot>   n - 37
18:43:21 <tolkad> wtf
18:43:23 <tolkad> :t test
18:43:24 <lambdabot> forall t. (Integral t) => t -> t
18:43:39 <NemesisD> im a bit confused by IO. if a function returns IO String, how would i unwrap that to use it in a pure function? fmap or >>= ? can it only be used in other IO functions?
18:43:47 <tolkad> > @let x = (test n) in x `pseq` x
18:43:48 <lambdabot>   <no location info>: parse error on input `@'
18:43:56 <tolkad> whoops
18:44:00 <tolkad> > let x = (test n) in x `pseq` x
18:44:01 <lambdabot>   n - 37
18:44:06 <copumpkin> tolkad: you can test stuff locally, too :P
18:44:11 <tolkad> oh sorry
18:44:11 <copumpkin> or in a PM with lambdbot
18:44:45 <aavogt> > let f (x+1) = x in f 1
18:44:46 <lambdabot>   0
18:44:53 <tolkad> but why did that happen... I thought `pseq` forces stuff into the weak form of the normal head
18:45:28 <aavogt>  x `seq` x is rather useless
18:45:43 <aavogt> you're forcing x when you force x
18:45:51 <lispy> NemesisD: you can unwrap it with (>>=) and fmap.  Which then means that the back arrow (<-) can be used in do-notation as well
18:45:52 <EliasAmaral> :t (\x -> (\y -> y + 1) + x)
18:45:53 <lambdabot>     Ambiguous occurrence `+'
18:45:53 <lambdabot>     It could refer to either `L.+', defined at <local>:1:2
18:45:53 <lambdabot>                           or `Prelude.+', imported from Prelude at State/L.hs:3:0-36
18:46:28 <aavogt> tolkad: and pseq is just seq with less opportunity for the compiler to rearrange things
18:46:44 <lispy> NemesisD: what you're doing is using the pure functions *inside* IO on the String
18:47:10 <lispy> NemesisD: this allows you to stay in the IO monad but also use pure code
18:48:14 <tolkad> I guess because "-" is a built-in function it's ok for it to occur in the feeble head ordinary form
18:48:46 <aavogt> tolkad: what is feeble head ordinary form?
18:48:54 <copumpkin> tolkad: no
18:49:05 <copumpkin> tolkad: first of all, I'm not sure what you expected it to do, given that n isn't bound
18:49:11 <tolkad> aavogt: a play on "weak head normal form" :P
18:49:28 <copumpkin> tolkad: second, the reason it prints an expression (which should be strange to you already) is because of a package that's loaded that does weird things
18:49:38 <NemesisD> lispy: so say a pure function calls this impure function which returns IO String , i use >>= or fmap, or do i have to be in another impure function
18:49:58 <Cale> The things it does are not really that weird
18:50:06 <Cale> :t n
18:50:06 <lambdabot> Expr
18:50:07 <bss03> :t (+) `on` length
18:50:08 <lambdabot>     Ambiguous occurrence `+'
18:50:09 <lambdabot>     It could refer to either `L.+', defined at <local>:1:2
18:50:09 <lambdabot>                           or `Prelude.+', imported from Prelude at State/L.hs:3:0-36
18:50:10 <Cale> > n
18:50:11 <lambdabot>   n
18:50:14 <bss03> :t (Prelude.+) `on` length
18:50:15 <lambdabot> forall a. [a] -> [a] -> Int
18:50:17 <aavogt> tolkad: when you print a value, you're forcing the whole String produced by show... that's almost certainly going to be more than WHNF
18:50:24 <bss03> @unlet (+)
18:50:25 <lambdabot>   Parse error: SemiColon
18:50:25 <aavogt> for the original value
18:50:31 <Cale> The single letter variables are defined as values of type Expr which display as themselves
18:50:39 <bss03> :t (Prelude.+) . length
18:50:39 <lambdabot> forall a. [a] -> Int -> Int
18:50:44 <EliasAmaral> :t (\x -> (\a b c -> (a b, a c)) (\y -> y Prelude.+ 1) (1::Double) (x::Integer))
18:50:45 <lambdabot>     Couldn't match expected type `Double'
18:50:45 <lambdabot>            against inferred type `Integer'
18:50:46 <Cale> and there's an instance of Num for Expr which does an obvious thing
18:50:46 <lambdabot>     In the third argument of `(\ a b c -> (a b, a c))', namely
18:50:49 <Cale> > n + 1
18:50:50 <lambdabot>   Ambiguous occurrence `+'
18:50:50 <lambdabot>  It could refer to either `L.+', defined at <local...
18:51:00 <Cale> @undefine
18:51:01 <Cale> > n + 1
18:51:02 <lambdabot>   n + 1
18:51:06 <lispy> spambdabot
18:51:09 <ivanm> wow, n + 1 == n + 1 ? :o
18:51:10 <ivanm> :p
18:51:19 <Maxdamantus> How is ((f >>= id) n) equivalent to (f n n)?
18:51:30 <EliasAmaral> aavogt, I'm confused about your assertion of taking an (\x -> x + 1) and applying to both integer and double
18:51:31 <Maxdamantus> > ((*) >>= id) 5
18:51:32 <lambdabot>   25
18:51:35 <tolkad> Maxdamantus: uh it's not
18:51:51 <tolkad> I think
18:51:51 <Cale> Maxdamantus: (f >>= g) x = g (f x) x
18:51:52 <tolkad> wait
18:52:07 <tolkad> I forgot id is a built-in function sorry
18:52:07 <Cale> It's the monad instance for functions
18:52:12 <conal> monochrom: thx for blog comment.  i'll delay a little while in passing it through, as i want to encourage people to keep thinking creatively.
18:52:16 <Maxdamantus> Ah.
18:52:17 <bss03> let inc n = n + 1 in (inc 1 :: Double, inc 1 :: Integer)
18:52:21 <bss03> > let inc n = n + 1 in (inc 1 :: Double, inc 1 :: Integer)
18:52:22 <lambdabot>   (2.0,2)
18:52:22 <ivanm> hmmm, if I'm defining classes Foo and Foo => Bar (exposed in separate modules), and Baz's instance of Foo uses its Bar instance, what's the best way of doing this?
18:52:41 <aavogt> > (\f -> (f 1 :: Int, f 1 :: Double))  (\x -> x+1)  -- giving a type for this EliasAmaral
18:52:41 <ivanm> defining Foo and Bar in the same internal module, and re-exporting?
18:52:42 <lambdabot>   Couldn't match expected type `GHC.Types.Double'
18:52:42 <lambdabot>         against inferred ty...
18:52:49 <monochrom> Spoiling the puzzle is exactly the damage I worry about. :)
18:53:28 <conal> :)
18:53:33 <roconnor> conal: I think it is useful to keep in mind that partial values are a means to an end, but isn't the end.  The end is a total value.  IMHO.
18:53:36 <etpace> hmmm, what would be the best way to implement a finite list/map? something with a hard limit of keys but with efficient insert after hitting the limit
18:53:39 <EliasAmaral> .-.
18:53:57 <Maxdamantus> > id (*4) 4
18:53:58 <lambdabot>   16
18:54:07 <tolkad> ghci is kind of buggy when stuff doesn't halt
18:54:18 <tolkad> I accidentally wrote a function that didn't halt
18:54:21 <Maxdamantus> Oh, id is built in, so it can do crazy stuff like that
18:54:22 <Cale> etpace: What?
18:54:29 <Rotaerk> while(true);
18:54:30 <tolkad> then tried to quit it with cntrl+C and it didn't work
18:54:45 <roconnor> Maxdamantus: built-in ?
18:54:51 <roconnor> @src id
18:54:51 <lambdabot> id x = x
18:54:53 <tolkad> I had to kill -9 it which took like 2 minutes because it was using all my CPU
18:54:55 <etpace> I'd like a map which can only contain n keys, where the oldest are replaced first Cale
18:54:58 <ivanm> tolkad: is this running in a terminal?
18:55:05 <tolkad> ivanm: yeah
18:55:09 <tolkad> ivanm: I quit the terminal
18:55:14 <tolkad> ivanm: and the thread stayed alive
18:55:15 <ivanm> tolkad: are you catching exceptions?
18:55:16 <aavogt> which version tolkad?
18:55:22 <ivanm> tolkad: oh, right, threads aren't killed
18:55:27 <tolkad> ivanm: idk I was using ghci
18:55:28 <Maxdamantus> Wait, nvm.. id (*4) 4 = (id (*4)) 4
18:55:43 <tolkad> aavogt: 6.12.3
18:55:58 <ivanm> tolkad: yeah, when you kill a main process in ghci it doesn't automatically kill sub-processes
18:56:06 <ivanm> (using forkIO, etc.)
18:56:07 <Cale> etpace: http://hackage.haskell.org/packages/archive/PSQueue/1.1/doc/html/Data-PSQueue.html
18:56:24 <Cale> etpace: Perhaps a priority search queue keyed on the insertion order?
18:56:25 <tolkad> ivanm: I thought haskell always kills forkIO processes
18:56:40 <etpace> hmm ok, i'll have a look
18:56:50 <taktoa> can anyone figure out why my code fails with a stack overflow?
18:57:14 <Cale> tolkad: Can I see the code?
18:57:19 <ivanm> tolkad: well, it does when a program ends because the running process ends
18:57:28 <taktoa> http://pastebin.com/Y92gXwM3
18:57:29 <ivanm> taktoa: we can't without looking at the code...
18:57:31 <ivanm> ;-)
18:57:39 <taktoa> I know, it just takes a minute
18:57:49 <Cale> Er, I meant taktoa :)
18:57:58 <tolkad> "In a standalone GHC program, only the main thread is required to terminate in order for the process to terminate. Thus all other forked threads will simply terminate at the same time as the main thread (the terminology for this kind of behaviour is "daemonic threads"). "
18:57:59 <taktoa> if I set h to 0.001
18:58:02 <taktoa> it's OK
18:58:14 <taktoa> but any lower, and it stack overflows
18:58:25 <taktoa> even if I set it to 0.000999999
18:58:27 <tolkad> Cale: the code? that caused the crash? I don't remember but it was something very simple, just a recursive function. I could try to cause it again one moment
18:58:53 <Cale> taktoa: Tab warning
18:59:00 <taktoa> eh?
18:59:11 <Cale> taktoa: You should configure your editor to convert tabs into spaces
18:59:17 <taktoa> ok
18:59:35 <monochrom> floating point numbers like Double are not meant to be exact. 0.2 - 0.1 - 0.1 is not going to = 0
18:59:36 <Cale> Now, let's see...
18:59:58 <ivanm> tolkad: well, yes, except in this case _ghci_ is the main thread
19:00:11 <ivanm> tolkad: running something in ghci isn't a stand-alone program ;-)
19:00:27 <tolkad> ivanm: oh so the ui is a seperate thread. I see
19:00:46 <ivanm> tolkad: read that quoted bit again ;-)
19:01:04 <monochrom> of course, 0.2 - 0.1 - 0.1 lucks out.
19:01:27 <monochrom> > 0.3 - 0.1 - 0.1 == 0.1
19:01:28 <lambdabot>   False
19:01:33 <monochrom> now you have a problem.
19:02:01 <taktoa> ok
19:02:06 <taktoa> so, what do I do
19:02:10 <dankna> > 0.2 - 0.1 == 0.1
19:02:11 <lambdabot>   True
19:02:14 <dankna> hm, so it does
19:02:18 <monochrom> don't use (y==z)
19:02:19 <taktoa> I need decimals
19:02:21 <ivanm> taktoa: define and use an epsiol
19:02:24 <ivanm> *epsilon
19:02:30 <taktoa> eh?
19:02:34 <taktoa> what's that
19:02:34 <Cale> Use abs (y - z) < h
19:02:43 <monochrom> In fact, use a better algorithm. There are integration algorithms designed for floating point numbers.
19:03:49 <taktoa> thanks, that worked
19:03:50 <monochrom> "y close to z" is hardly a correct stopping condition anyway. the correct stopping condition is "program's answer has been proven to be close to correct answer"
19:03:51 <Cale> You also forgot to multiply f z by h
19:03:58 <taktoa> yeah, I know
19:05:03 <monochrom> "Houston, we have a problem. Our computer freaks out with floating point madness."
19:05:32 <kmc> tolkad, again, please stop blaming your misunderstandings on "ghc bugs"
19:06:09 <Martty> oh its the integrator guy
19:06:44 <Martty> i pmed him the solution after he left the chan the other time!!
19:06:51 <Martty> and now he left again in case you didnt notice kmc :D
19:07:01 <kmc> ?
19:07:17 <Cale> Martty: kmc wasn't talking to him
19:07:21 <tolkad> kmc: it's not a bug that control+c doesn't halt whatever is running?
19:07:35 <kmc> tolkad, did you read somewhere that it was supposed to?
19:07:43 <Cale> It doesn't?
19:07:53 <Martty> oh haha
19:07:57 <monochrom> perhaps a provocative tactic is being used. perhaps it is intentionally said "it's a ghc bug?!" to accelerate getting help. don't fall for it. two actions you can take: (A) inaction - just don't answer him. (B) tell the ops you consider him poisonous and want him out of the community.
19:07:59 <tolkad> Cale: «let f x = f (x `quot` x); f 3» seems to produce the behavior but it eventually runs out of memory
19:08:00 <copumpkin> during an allocation, it sometimes won't
19:08:18 <copumpkin> I mean, with no allocation
19:08:18 <Cale> Prelude> let f x = f (x `quot` x)
19:08:18 <Cale> Prelude> f 3
19:08:18 <Cale> ^CInterrupted.
19:08:27 <copumpkin> it did that back in 6.10
19:08:29 <copumpkin> maybe he has an old version
19:08:30 <EliasAmaral> I think it's reasonable to expect that C-c interrupts the job
19:08:32 <sm> ClaudiusMaximus: thanks, I understood at last why you do it the way you do.. avoids duplicating possibly large files
19:08:37 <tolkad> copumpkin: it does normally
19:08:43 <EliasAmaral> it's a convention, but not every program follows it
19:08:47 <tolkad> copumpkin: but when running certain recursive functions it doesn't
19:08:53 <copumpkin> tolkad: yes, ones that don't allocate
19:08:58 <copumpkin> tolkad: in 6.10.1
19:09:03 <copumpkin> or other 6.10.* versions
19:09:11 <copumpkin> ctrl-z always works though
19:09:16 <copumpkin> so you can just background and then kill it
19:09:21 <tolkad> oh that's good to know
19:09:40 <sm> I am dealing only with small files right now.. stylesheets etc. I got it pretty close to working my way today
19:09:57 <tolkad> still had to kill -9 though
19:10:38 <ddarius> This is why I like monochrom.
19:10:41 <tolkad> the most surprising thing to me was that it seems to be running parallel on both of my cores
19:11:04 <tolkad> lol and exausting memory messed up firefox
19:11:18 <sm> but in this case where efficiency is not important, I believe I could also use a bit of TH, and no extra build step required
19:11:37 <tolkad> at least I think it was running parallel
19:11:44 <tolkad> should check...
19:11:47 <sm> $(embedFiles ["data/...", ...])
19:13:53 <ddarius> sm: Sounds like a recipe for disaster.
19:14:10 <sm> why ddarius ?
19:14:17 <kmc> monochrom, that's a well-known tactic in much of the open-source world, but i haven't seen it much here
19:14:35 <tolkad> it does seem to be running parallel but it was slowing down my computer from very fast allocation, not CPU usage. it was mostly only using 1 CPU
19:15:43 <ddarius> sm: GHC handles large source files very poorly.
19:16:34 <sm> good to know
19:17:15 <sm> if one module gets too large, I could embed a file per module
19:17:37 <sm> they're all little things - stylesheets, javascripts, icons
19:18:42 <sm> the goal is to have a binary that doesn't depend on additional things being in a particular place on the filesystem
19:19:47 <aavogt> doesn't cabal work well enough for you?
19:20:52 <sm> aavogt: no. For example, if you download a hledger binary right now, the web ui doesn't work
19:24:39 <aavogt> sm: and users can't be expected to unpack some archive?
19:25:42 <Mitar> if i have a nested record (of records), how do i change field in the nested record?
19:26:10 <aavogt> ghc binaries need a few shared libraries anyways
19:26:41 <aavogt> Mitar: it's awkward unfortunately
19:26:49 <ddarius> Mitar: You change the record containing the record.
19:27:23 <Mitar> yes, how?
19:27:29 <aavogt>  outer { a = f (a outer) }  to modify the a field of outer
19:27:36 <Mitar> like for top record it is simple, yes
19:27:41 <Mitar> (i use it as a state)
19:27:56 <Mitar> so it is: modify (\s -> s { outerField = "bla" })
19:27:58 <sm> aavogt: I'd like to make it simpler than that. Even if you allow for that, it will always break some way or other in the field. Fewer moving parts would be better. And it's hard to make the app handle the different places data could be, eg in the cabal installed vs. downloaded binary cases. Eg yesod really wants a fixed compile-time file path
19:28:35 <Mitar> how to modify inner field if it is in record field for example?
19:28:57 <kmc> painfully
19:29:14 <Mitar> great ;-)
19:29:15 <kmc> Haskell 98's record system sucks
19:29:20 <kmc> look at libraries like fclabels
19:29:35 <aavogt>  outer { a = (a outer) { x = f (x (a outer)) } } 
19:29:44 <kmc> they can autoderive some bidirectional accessor functions that make this a lot nicer
19:30:07 <copumpkin> has anyone else ever wanted a dedicated update function in fclabels?
19:33:46 <sm> gotta go, night all
19:34:12 <ivanm> g'night sm 
19:34:45 * ivanm still can't work out how to deal with recursive class instances for restricted type classes
19:35:49 <copumpkin> ?
19:35:55 <Mitar> so like
19:35:56 <Mitar> modify (\outer -> outer { outerField = (outerField outer) { innerField = newValue } })
19:37:32 <Mitar> :t modify (\outer -> outer { outerField = (outerField outer) { innerField = newValue } })
19:37:33 <lambdabot> Not in scope: `outerField'
19:37:34 <lambdabot> Not in scope: `outerField'
19:37:34 <lambdabot> Not in scope: `innerField'
19:37:51 <ivanm> copumpkin: well, if I have Applicative => Monad, but I want to use the default Monad definitions of liftM, etc. to define the Set instance for Applicative, what would be the best way of doing it?
19:37:57 <ivanm> recursive modules?
19:38:16 <ddarius> The syntax is compositional.  You do the same thing to modify the inner field as you do the outer field.
19:38:22 <ivanm> having the classes defined in hidden inner modules and the instances like Set in other inner modules?
19:38:23 <ddarius> There's nothing special about a record in a record.
19:39:55 <tolkad> uh how safe is unsafeIOToST?
19:39:58 <ddarius> Mitar: You could pattern match on outer to get outerField rather than using the accessor, but yes, that would work.
19:40:00 <tolkad> how unsafe
19:40:12 <ddarius> ivanm: What is the context of this?
19:40:32 <tolkad> nevermind I guess it's just unsafePerformIO
19:40:38 <dolio> It allows you to write unsafePerformIO.
19:40:53 <ddarius> Which allows you to write unsafeCoerce.
19:41:04 <Eduard_Munteanu> o/
19:41:14 <ivanm> ddarius: http://osdir.com/ml/haskell-cafe@haskell.org/2010-09/msg00099.html
19:41:19 <ivanm> Eduard_Munteanu: \o
19:42:08 <tolkad> ddarius: I never understood that, unsafePerformIO has a normal looking type signature
19:42:08 <kmc> tolkad, if you use unsafeIOToST only inside stToIO it should be safe; it just turns your ST action into an IO action 
19:42:29 <monochrom> hrm, hidden classes, crouching instances.
19:42:46 <kmc> tolkad, otherwise, it turns an invocation of runST into unsafePerformIO
19:42:52 <kmc> (they are almost identical in implementation)
19:43:10 <kmc> tolkad, unsafePerformIO can implement unsafeCoerce through a trick where you declare a global, polymorphic IORef and then put/take different types from it
19:43:25 <dolio> It doesn't need to be global.
19:44:09 <tolkad> kmc: I've seen the example code for that and it looks like there would be a type error
19:44:48 <kmc> did you try it?
19:44:56 <tolkad> yeah it acted sort of crazy
19:45:16 <tolkad> oh wait I see why it's polymorphic...
19:45:41 <dolio> It takes advantage of the generalization of lets.
19:45:43 <EliasAmaral> is there something at Control.Monad for getting a IO value a, a list of IO values b, and then returning a IO value that applies a, then all values of b?
19:45:55 <Mitar> ddarius: because it does not work, i get a nest type error:     No instance for (MonadState
19:45:55 <Mitar>                        (StateT X11State IO X11Impulse) ((->) (X11State -> X11Impulse)))
19:45:55 <tolkad> huh ok it makes sense now
19:46:00 <dolio> Generalization of types, that is.
19:46:07 <kmc> EliasAmaral, sounds like x >> sequence ys
19:46:23 <dolio> ML would have the same problem, and that's why they have the value restriction.
19:46:44 <NemesisD> http://pastie.org/1154987 I'm still having trouble unwrapping ADTs to get proper return types in my functions
19:46:53 <dolio> Where you can't have polymorphic values (I think that's right).
19:47:02 <EliasAmaral> hm yes
19:48:16 <tolkad> wait no it doesn't make sense
19:48:19 <tolkad> this is a type error: http://codepad.org/55TwlT7k
19:48:32 <tolkad> (sense to me, I'm not saying this is a haskell problem kmc)
19:48:46 <kmc> tolkad, you're not using unsafePerformIO
19:48:58 <tolkad> yeah but I don't understand the difference
19:49:01 <Eduard_Munteanu> That doesn't make sense...
19:49:04 <Eduard_Munteanu> :t newIORef
19:49:05 <lambdabot> Not in scope: `newIORef'
19:49:14 <Eduard_Munteanu> Uh.
19:49:46 <kmc> tolkad, the difference is that lambdas bind at monomorphic type
19:49:54 <Eduard_Munteanu> Maybe they should allow IO stuff for ':t', seems harmless.
19:49:57 <kmc> and the right hand side of the implicit (>>=) here is an implicit lambda
19:50:01 <kmc> Eduard_Munteanu, it is allowed
19:50:03 <kmc> :t print
19:50:04 <lambdabot> forall a. (Show a) => a -> IO ()
19:50:08 <kmc> > print "hello there"
19:50:09 <lambdabot>   <IO ()>
19:50:17 <kmc> Eduard_Munteanu, λbot can evaluate IO, just won't execute it
19:50:24 <Eduard_Munteanu> :t unsafePerformIO
19:50:25 <lambdabot> Not in scope: `unsafePerformIO'
19:50:36 <ivanm> Eduard_Munteanu: that's because lambdabot doesn't know about unsafePerformIO
19:50:42 <ivanm> so she can't find its type
19:50:44 <Eduard_Munteanu> Oh, I see.
19:50:46 <ivanm> @hoogle unsafePerformIO
19:50:46 <lambdabot> Foreign unsafePerformIO :: IO a -> a
19:50:46 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
19:51:01 <ivanm> ^^ that's in a separate index than the one used for running Haskell code, type checking, etc.
19:51:02 <tolkad> kmc: ok that makes some sense now that I at least know what the fundamental difference is
19:52:05 <kmc> though, if i write a (>>=) RHS with an explicit rank-2 type (forall a. IORef a) -> IO (), it still fails
19:52:20 <ddarius> Mitar: There are some assumptions you are apparently not stating.
19:53:46 <Mitar> hmm
19:53:46 <EliasAmaral> http://users.skynet.be/jyp/html/base/Text-Printf.html can printf print to bytestring?
19:53:58 <Mitar> it is a record in record, and i use it as a state in StateT
19:54:17 <ivanm> EliasAmaral: I think so
19:54:19 <ivanm> @hoogle printf
19:54:19 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
19:54:20 <lambdabot> module Text.Printf
19:54:20 <lambdabot> Text.Printf class PrintfArg a
19:54:29 <ivanm> @instances PrintfType
19:54:29 <lambdabot> Couldn't find class `PrintfType'. Try @instances-importing
19:54:37 <ivanm> @instances-importing Text.Printf PrintfType
19:54:38 <lambdabot> (a -> r), IO a, [c]
19:54:48 <tolkad> @instances Data.IO
19:54:48 <lambdabot> Couldn't find class `Data.IO'. Try @instances-importing
19:54:53 <ivanm> EliasAmaral: you could probably make an instance
19:54:53 <tolkad> @instances System.IO
19:54:54 <lambdabot> Couldn't find class `System.IO'. Try @instances-importing
19:55:03 <tolkad> @instances-importing System.IO
19:55:04 <lambdabot> Couldn't find class `System.IO'. Try @instances-importing
19:55:12 <tolkad> heh
19:55:20 <NemesisD> isn't there some pragma involved with functors that i can use? I think my problem is that im feeding fmap something of type Result [(String, String)]
19:55:21 <ivanm> you need a class there still
19:55:40 <ivanm> NemesisD: what are you wanting to do?
19:55:43 <tolkad> @instances-importing System.IO Something
19:55:43 <lambdabot> Couldn't find class `Something'. Try @instances-importing
19:55:48 <EliasAmaral> does ghc implement a char list as cons cells with one character + pointer per cell? or is there some magic to this?
19:55:59 <ivanm> EliasAmaral: it's just a normal list
19:56:17 <ivanm> which yes, I believe is just cons cells with pointers
19:56:18 <ManateeLazyCat> Is there a function break String with first space char, and don't truncated rest blank space char. Example, "newWords "Hello, all    haskellers!" will return ["hello,", "all", "   haskellers!"]
19:56:20 <ddarius> Mitar: And the code you wrote above should work fine in that context so there is something you are not saying or you simply have an error in your code.
19:56:36 <ivanm> ManateeLazyCat: you could write such a one
19:56:42 <ivanm> but no, I don't think there is one by default
19:56:55 <ManateeLazyCat> ivanm: Hmm,, okay i write this one.
19:57:22 <ManateeLazyCat> ivanm: I'm developing newWords for wrap irc message. ... :)
19:57:44 <tolkad> hmm, if I twang this rubber band it appears to change colors between red and blue
19:57:59 <kmc> EliasAmaral, no magic.  in fact Char is boxed too
19:58:05 <tolkad> mostly red
19:58:20 <tolkad> kmc: boxed? do you mean stored as a pointer?
19:58:21 <NemesisD> ivanm: http://pastie.org/1154987 , doit :: String -> String -> [(String, String)], got a function typed String -> Result [(String, String)], and I want to feed it one with a return type IO String, i'm trying to figure out how to pattern match and get what i want out of the Result functor(?)
19:58:32 <kmc> so it's a cons cell of three machine words (info ptr, car, cdr) with the car pointing to a Char cell of (info ptr, Char#)
19:58:40 <kmc> i'm not sure how big Char# is; probably one word as well
19:59:00 <ManateeLazyCat> ivanm: http://www.flickr.com/photos/48809572@N02/4984779665/lightbox/ still not perfect, need newWords replace words. :)
19:59:29 <tolkad> kmc: I thought Char supports unicode, doesn't that have multi-word characters?
19:59:49 <kmc> a machine word is 32 bits on a 32-bit machine; 64 bits on a 64-bit machine
20:00:04 <EliasAmaral> does Char supports unicode?..
20:00:04 <kmc> as of today, there are fewer than 2^32 unicode codepoints defined
20:00:12 <tolkad> oh
20:00:14 <kmc> so UTF-32 can represent all of unicode
20:00:15 <monochrom> Char supports unicode
20:00:20 <kmc> and GHC doesn't work on 16-bit machines ;P
20:00:22 <ManateeLazyCat> EliasAmaral: Yes.
20:00:22 <EliasAmaral> now it looks more interesting
20:00:22 <ddarius> EliasAmaral: The Report states that Char should be able to store a Unicode code point.
20:00:29 <kmc> EliasAmaral, yes, Char represents a Unicode code point
20:00:44 <kmc> (not in any particular encoding; its representation in memory is opaque)
20:01:01 <Eduard_Munteanu> Though there's some confusion over what word really means in computing. On x86 and x86-64 you sometimes see word being 16-bit and dword, qword and so on.
20:01:07 <Mitar> oh, sorry, it is some other line which has that error ;-)
20:01:09 <kmc> yeah, blame intel
20:01:24 <ManateeLazyCat> EliasAmaral: If you need do some encode/decode work, ByteString is you need... :)
20:01:25 <monochrom> word
20:01:29 <Mitar> i mistyped: get outerField instead of gets outerField
20:01:34 <ddarius> kmc: For what?  "Word" means machine word.
20:02:13 <EliasAmaral> ManateeIrcClient, apparently, printf doesn't print to bytestring. [it manages to print to IO and String with the *same function*, but not to bytestring. õ.o]
20:02:18 <Eduard_Munteanu> ddarius: mainly for their asm syntax that kept word == 16 bits as a legacy.
20:02:49 <EliasAmaral> I suppose that, for printing to bytestring, one would need to specify the character encoding. (But, the same to IO a, and it doesn't look like it was specified..)
20:02:54 * ddarius massively prefers Intel syntax to AT&T syntax.
20:02:58 <monochrom> yes, certain commercial assemblers use "word" for 16 bits.
20:02:59 <tolkad> how long until GHC supports 64 bit mac os x code?
20:03:04 <NemesisD> ivanm: ignore my explanation, the pastie does a better job, i just muddled it
20:03:50 <Cale> EliasAmaral: It shouldn't be too hard to write an instance of PrintfType for that
20:04:27 <EliasAmaral> I'm just wandering through docs, no special need right now
20:04:44 <Maxdamantus> @pl f a (g a)
20:04:44 <lambdabot> f a (g a)
20:04:50 <Maxdamantus> @pl \a -> f a (g a)
20:04:51 <EliasAmaral> (Also I think I couldn't do this even if I tried. I'm struggling to combine monads..)
20:04:51 <lambdabot> ap f g
20:05:38 <Cale> Oh, except that it's impossible to do that without modifying the base library, because the implementation isn't exposed.
20:06:07 <Eduard_Munteanu> I'm not sure which I prefer, both are logical in their own ways. AT&T goes src->dest, while Intel is assignment-like (dest=src).
20:07:20 <Eduard_Munteanu> Though AT&T seems stricter in some regards, I mean the '$' value prefixing, how pointers are specified etc..
20:07:24 <EliasAmaral> In the end, I see that main = do { putStrLn "a"; forM [0..10] $ \x -> do putStrLn (show x) } is valid haskell code. It looks a lot like usual imperative syntax, except that "forM xs $ \x -> do" isn't the best syntax sugar in the world
20:07:46 <EliasAmaral> but haskell isn't supposed to be imperative anyway..
20:07:56 <Cale> EliasAmaral: Of course, it's not syntax sugar at all :)
20:08:02 <Cale> forM is a normal library function :)
20:08:45 <EliasAmaral> yes, I see. (but lazy functions seem to be able to perform things that, in strict languages, would need syntax sugars)
20:09:06 <Cale> One way to implement it would be: forM [] f = return []; forM (x:xs) f = do v <- f x; vs <- forM xs f; return (v:vs)
20:09:25 <Cale> But it's actually implemented in terms of sequence :: [IO a] -> IO [a]
20:09:33 <Cale> and map
20:09:34 <EliasAmaral> one can actually use ; to separate top-level declarations?
20:09:39 <Cale> yep
20:09:40 <kmc> EliasAmaral, I don't agree that "haskell isn't supposed to be imperative".  a good language will support many styles
20:09:51 <Cale> Layout is optional
20:10:03 <Cale> (which is handy on IRC)
20:10:09 <kmc> EliasAmaral, what Haskell challenges is the idea that every program should use imperative OO style.  it gives you more freedom to think denotationally
20:10:19 <EliasAmaral> so there is nothing that actually requires \n? like import A; main = ..; .. would be valid
20:10:23 <kmc> but sometimes you do need that imperative style
20:10:30 <EliasAmaral> kmc, but the haskell syntax seems biased towards functional style
20:10:34 <kmc> indeed
20:10:43 <EliasAmaral> ocaml also suffer from this "problem"
20:10:52 * hackagebot buildbox 1.0.2.0 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-1.0.2.0 (BenLippmeier)
20:10:58 <kmc> and the boundary of where you need imperative code is an active research front; e.g. FRP attempts to push pure functional code into the world of interactive graphics and such
20:11:03 <Cale> EliasAmaral: yeah, you could write your entire module on one line
20:12:58 <EliasAmaral> FRP? I saw that 3d game
20:13:14 <EliasAmaral> Cale, haskell seem ready for an obfuscation contest
20:13:50 <tolkad> apparently 64 bit compilation on mac os x wont work until 6.14.2
20:13:55 <tolkad> : (
20:14:04 <tolkad> according to ticket comments
20:14:22 <Eduard_Munteanu> tolkad: 32-bit binaries should still work on MacOS X.
20:14:38 <Eduard_Munteanu> tolkad: just make sure you get a static build.
20:15:54 <JoeyA> Are IORefs really cheap to operate on, sort of like C pointers?
20:16:03 <Cale> JoeyA: yes
20:16:06 <JoeyA> good
20:16:23 <tolkad> are MVars much more expensive than IORefs?
20:16:35 <Eduard_Munteanu> Well I suppose they're not as cheap as pointers, aren't they boxed?
20:16:39 <dolio> Noticeably, I think.
20:16:40 <Cale> A bit, but they're not really a replacement for IORefs
20:16:45 <Eduard_Munteanu> I'm not sure how much they translate to simple dereferencing.
20:17:02 <JoeyA> so it's not really more expensive to say itemUsed :: IORef Bool, itemValid :: IORef Bool than it is to say itemState :: IORef (Bool, Bool)
20:17:52 <Cale> JoeyA: Which one you'd use would depend on convenience and the intended semantics more than performance.
20:18:05 <JoeyA> Are MVars mutexed, by the way?
20:18:32 <JoeyA> Well, I want to update the bools separately.
20:19:10 <roconnor> what does it mean for MVars to be mutexed?
20:19:38 <Cale> Not quite sure what 'mutexed' means there, but when you takeMVar to read the result from an MVar, if it is empty, that will block and wait for it to fill, and if it is full, the MVar is emptied by that operation.
20:19:39 <JoeyA> if there are multiple threads modifying the var at the same time, they won't trample each other.
20:19:56 <Cale> and similarly, putMVar will block if the MVar is already full
20:19:57 <copumpkin> that's the whole point of them
20:20:02 <JoeyA> oh.
20:20:07 <tolkad> and if you just want a lock
20:20:10 <tolkad> you can use MVar ()
20:20:42 <Cale> It's pretty simplistic, but in a lot of cases it's enough.
20:27:47 <EliasAmaral> I find interesting this convention that function' is a strict version of function. the convention I knew was that if I'm updating a structure named tree, I will return a new tree' as result, or something like that
20:28:05 <EliasAmaral> (this other convention seems to be used in Haskell' too)
20:28:25 <kmc> hehe
20:28:31 <kmc> ' is used for a lot of things
20:28:37 <ivanm> yeah
20:28:45 <ivanm> I've used it for "simplified" versions of functions
20:29:12 <Cale> x' is generally just something related to x in some fashion
20:29:12 <Eduard_Munteanu> x' is an equivalent to C's __x() for me.
20:29:19 <EliasAmaral> it isn't syntactically valid everywhere in the identifier, right?
20:29:22 <Eduard_Munteanu> (well, not C's, but a widespread convention)
20:29:27 <ivanm> EliasAmaral: I believe it is
20:29:32 <ivanm> > let a'b = 2 in a'b
20:29:32 <Cale> It's valid everywhere except the beginning
20:29:32 <lambdabot>   2
20:29:37 <ivanm> Cale: oh, right
20:29:49 <kmc> it's valid in identifiers, but is not considered upper or lower case
20:29:51 <EliasAmaral> let rock'n'roll =
20:29:56 <Cale> > let isn't = not in isn't True
20:29:57 <lambdabot>   False
20:29:58 <megajosh2> C identifiers with lots of underscores are so nasty looking
20:30:02 <ivanm> > let a +' b = a + b - 1 in 2 +' 3
20:30:03 <lambdabot>   <no location info>:
20:30:03 <lambdabot>      lexical error in string/character literal at chara...
20:30:04 <Eduard_Munteanu> Sure, a few Prelude functions use it to specify strict semantics.
20:30:07 <kmc> > let don't = const (return ()) in don't $ do { print "hi" }
20:30:08 <lambdabot>   No instance for (GHC.Show.Show (m ()))
20:30:08 <lambdabot>    arising from a use of `M699034606...
20:30:12 <ivanm> bah, looks like it isn't a symbolic character :s
20:30:37 <ivanm> kmc: well, the do block is useless there... ;-)
20:30:38 <kmc> > let 'a = () in 'a
20:30:39 <lambdabot>   <no location info>:
20:30:39 <lambdabot>      lexical error in string/character literal at chara...
20:30:43 <kmc> > let _a = () in _a
20:30:44 <lambdabot>   ()
20:32:49 <Mitar> hpaste down?
20:33:01 <ivanm> Mitar: probably
20:33:16 <ivanm> I've asked someone this before, but I've forgotten: how do I add a type variable to ''Either in TH?
20:33:25 <ivanm> (to get the TH version of "Either a")
20:33:26 <kmc> you don't
20:33:30 <kmc> that quotes a name, not a type
20:33:38 <kmc> maybe you want [t| Either a |]
20:33:46 <ddarius> > let ord'x' = ord 'x' in ord'x'
20:33:47 <lambdabot>   120
20:34:02 <Mitar> http://www.haskell.org/pipermail/haskell-cafe/2010-September/083589.html << then i will paste like this ;-)
20:34:08 <ivanm> kmc: is there a way of taking a Name and adding a variable to it?
20:34:18 <kmc> yes, in the TH API
20:34:31 <EliasAmaral> is [t| Either a |] a type?
20:34:44 <ivanm> kmc: I'm looking through it, but it isn't really documented ;-)
20:34:52 <kmc> EliasAmaral, it's a value of type (Q Type); that is, a Template Haskell quotation of a type
20:34:54 <ireafte> Can anyone help: If I have a definition  data Point = Red Int Int | Blue Int Int | Yellow Int Int  is there anyway to specify a function like projectX (Red x y) = (Red x 0) that will work with either Red, Blue or Yellow?
20:35:05 <EliasAmaral> ah
20:35:09 <kmc> ireafte, yes, by using three cases
20:35:14 <ivanm> kmc: "[t| Either a |]" seems to return an error, at least in ghci
20:35:20 <ivanm> "Not in scope: type variable `a' "
20:35:21 <kmc> ivan, a has to be in scope
20:35:25 <NemesisD> could anyone take a look at http://pastie.org/1154987 i feel like im missing a lift or something. sorry to be so annoying but im working through one of my first haskell programs
20:35:35 <kmc> :t AppT
20:35:36 <lambdabot> Not in scope: data constructor `AppT'
20:35:43 <ivanm> @hoogle appT
20:35:43 <lambdabot> Language.Haskell.TH appT :: TypeQ -> TypeQ -> TypeQ
20:35:44 <lambdabot> Language.Haskell.TH.Lib appT :: TypeQ -> TypeQ -> TypeQ
20:35:44 <lambdabot> Language.Haskell.TH AppT :: Type -> Type -> Type
20:35:48 <ireafte> kmc: no shortcut way to avoid repeating the definition three times?
20:35:54 <ivanm> ireafte: no
20:36:01 <kmc> AppT (ConT ''Either) (VarT $ mkName "a") -- ivanm something like this
20:36:05 <ivanm> ireafte: well, if you use records you can...
20:36:09 <ivanm> kmc: ahhh, ta
20:36:09 <ireafte> ah :( thanks for your help 
20:36:42 <ireafte> unfortunately I cant change the type definition
20:37:05 <ivanm> ireafte: e.g. data Point = Red { x :: Int, y :: Int } | Blue { x :: Int, y :: Int } ... projectX col = col { y = 0 }
20:37:16 <ivanm> ireafte: oh, in that case then yeah, three pattern matches
20:37:36 <ManateeLazyCat> @hoogle isSpaceWord8
20:37:37 <lambdabot> Data.ByteString.Internal isSpaceWord8 :: Word8 -> Bool
20:37:48 <tommd> If you can't change the definition, then change that reality.  If you can't change reality, then change your perception.
20:38:10 <ManateeLazyCat> > let splitWords xs = map (Data.ByteString.map (\x -> if isSpaceWord8 x then c2w ' ' else x)) $ splitWith isSpaceWord8 xs
20:38:11 <lambdabot>   not an expression: `let splitWords xs = map (Data.ByteString.map (\x -> if ...
20:38:17 <blackh> NemesisD: You don't want to just use a case?
20:38:37 <ManateeLazyCat> :t splitWords xs = map (Data.ByteString.map (\x -> if isSpaceWord8 x then c2w ' ' else x)) $ splitWith isSpaceWord8 xs
20:38:38 <lambdabot> parse error on input `='
20:40:02 <NemesisD> blackh: ive got nothing against case, i'd never used it to match value constructors (i hope thats the right term), so it didn't cross my mind
20:40:35 <ManateeLazyCat> :t map (Data.ByteString.map (\x -> if isSpaceWord8 x then c2w ' ' else x)) $ splitWith isSpaceWord8 xs
20:40:36 <lambdabot> Not in scope: `isSpaceWord8'
20:40:37 <lambdabot> Not in scope: `c2w'
20:40:37 <lambdabot> Not in scope: `splitWith'
20:40:40 <blackh> NemesisD: Yes, that's the right term.  Usually with these things it's best to start simple and add all your fmaps and things once you have it worked out
20:40:56 <ManateeLazyCat> lambdabot: Okay, stupid robot.
20:41:51 <blackh> NemesisD: Maybe something like do ; eRes <- fmap parseJSON (get (DirectionsRequest o d)) ; case eRes of ...
20:42:02 * hackagebot gloss 1.1.1.0 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.1.1.0 (BenLippmeier)
20:42:04 * hackagebot gloss-examples 1.1.1.0 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.1.1.0 (BenLippmeier)
20:43:29 <blackh> NemesisD: Also your type is not going to work. It has to be doIt :: String -> String -> IO [(String, String)]
20:43:42 <blackh> NemesisD: IO has a tendency to spread
20:45:37 <NemesisD> blackh: i'm confused, i can't extricate the string from the IO String? any function that at some point calls something returning IO String must prefix the return type with IO?
20:46:52 <kmc> NemesisD, a value of type (IO T) is an "IO action", a "recipe" for how to do some IO and produce a result of type T
20:46:53 <tommd> NemesisD: That is a misnomer.  You don't "extract String from IO String"  the "IO String" is an IO action that results in a String (potentially different every time).  You _call_ the action and obtain a string.
20:46:59 <kmc> the IO hasn't been performed yet
20:47:06 <blackh> NemesisD: That's true in your case.  However, IO values can be passed around as values in pure functions, but they can never be executed in a pure function.
20:47:17 <kmc> in Haskell, evaluation (of function applications) and execution (of IO actions) are two distinct processes
20:47:37 <EliasAmaral> "revise the Numeric class hierarchy, e.g. collapse classes RealFrac, Fractional, and Floating." <- Fractional is a pair of Integers, right?
20:47:46 <EliasAmaral> it's very different than Floating imo
20:48:02 <kmc> and so if you have a value (IO T) you don't *have* to return something in IO, but you probably want to, because the only way IO ultimately happens is to get glued onto other IO and end up as part of the action named "main"
20:48:10 <JoeyA> What's a good action name for "return an item after borrowing it"?
20:48:39 <kmc> JoeyA, withItem :: (Item -> M t) -> M t
20:48:40 <JoeyA> I could use borrowItem and returnItem, but the object returned by borrowItem is a Lease, which is only valid for that instance of borrowing.
20:49:04 <JoeyA> Then that restricts it to operating on a stack.
20:49:13 <kmc> NemesisD, http://haskell.org/haskellwiki/Introduction_to_IO
20:49:13 <JoeyA> rather than being able to borrow/return freely.
20:49:25 <NemesisD> blackh: so anything that's going to use the output from doIt can be typed as String, but doIt itself must have the return type of IO String?
20:49:48 <kmc> right
20:50:01 <kmc> when you do:   do { x <- doIt; ... }
20:50:05 <kmc> x has type String locally
20:50:10 <kmc> but the whole "do" block will have type IO Something
20:50:13 <blackh> NemesisD: What he said. :)
20:50:25 <kmc> that's because under the hood you've written   doIt >>= (\x -> ...)
20:50:26 <kmc> and:
20:50:27 <kmc> :t (>>=)
20:50:28 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
20:50:37 <kmc> iow:  IO a → (a → IO b) → IO b
20:51:16 <kmc> (i assumed there that doIt :: IO String)
20:51:24 <kmc> (sorry, didn't actually read your code)
20:52:00 <NemesisD> so in a way im signalling that hey i contain an IO operation and that is only guaranteed to be performed if this function is called as a consequence of something going on in main
20:52:18 <kmc> NemesisD, sort of
20:52:33 <kmc> but again, the evaluation process (function calls and returns) is distinct from the execution process
20:52:40 <NemesisD> kmc: currently doit is String -> String -> [(String, String)], turns out that needs to be IO [(String, String)]
20:52:49 <tommd> NemesisD: Its often used in the reverse.  It signals it has IO so the compiler can't optimize double calls into a single call with the result used twice.
20:52:53 <kmc> you can call a function of type (A → IO B), from main, without any IO occurring
20:52:53 <blackh> NemesisD: Actually you're not signalling, really.  The key idea is that evaluating and executing IO are two completely separate operations.
20:53:25 <kmc> tommd, i think that's misleading -- implementations might confuddle execution and evaluation, but the language semantics are very clear on the distinction
20:53:40 <tommd> fair enough
20:54:00 <kmc> main = let x = print "a" in print "b"
20:54:02 <kmc> only prints b
20:54:03 <handonson> if i were to 'manipulate' haskell codes, that is, to load/change/save haskell codes, what would be the best library of choice?
20:54:17 <kmc> sure, we called «print "a"», it returned a value 'recipe for how to print "a"'
20:54:21 <kmc> but we never used that recipe
20:54:41 <kmc> main = print "a" >> print "b"
20:54:42 <kmc> prints both
20:54:51 <kmc> because (>>) :: IO a → IO b → IO b
20:54:54 <blackh> NemesisD: You always get at least four answers to any question in #haskell
20:54:57 <kmc> has meaning "glue these two recipes together"
20:55:04 <kmc> @quote contrapuntal
20:55:04 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
20:55:06 <NemesisD> lol
20:55:06 <handonson> (i'm asking this because i think hint is for loading and evaluating, not changing)
20:55:18 <kmc> handonson, you want to represent source code or something else?
20:55:55 <handonson> kmc: i'd say i want something like a haskell version of Text.JSON
20:55:56 <NemesisD> wait if im making doIt into an io function, don't i have to wrap the contents in a do?
20:55:59 <tommd> handonson: haskell-src-exts
20:56:05 <tommd> @hoogle haskell-src-exts
20:56:05 <lambdabot> Text.Parsec.Language haskell :: TokenParser st
20:56:05 <lambdabot> Text.ParserCombinators.Parsec.Language haskell :: TokenParser st
20:56:06 <lambdabot> package haskell-src
20:56:12 <kmc> NemesisD, no; "do" is optional syntactic sugar
20:56:14 <tommd> @hackage haskell-src-exts
20:56:14 <lambdabot> http://hackage.haskell.org/package/haskell-src-exts
20:56:29 <kmc> NemesisD, did you read the link i sent? it starts out without using 'do' and then introduces it as a mere notational convenience
20:56:56 <handonson> tommd: thanks a lot. that one looks quite promising.
20:57:08 <handonson> i'll give it a shot right away.
20:57:21 <kmc> NemesisD, if a function returns (IO t), it must build an IO action somehow, whether by "do" or any other means.  similarly a function returning String must return a String, whether it builds it using (:) or "foo" or any other means
20:58:04 <handonson> tommd: by the way, is that package also capable of evaluating haskell code?
20:58:20 <tommd> handonson: No, you want 'hint'
20:58:23 <tommd> @hackage hint
20:58:23 <lambdabot> http://hackage.haskell.org/package/hint
20:58:35 <kmc> handonson, haskell-src-meta is also useful for combining this stuff with Template Haskell
20:58:42 <NemesisD> kmc: you're right i should chill out and read that rather than trying to guess at the correct solution
20:58:46 <handonson> tommd: i want to both evaluate and manipulate
20:58:47 <kmc> :)
20:58:54 <tommd> handonson: That's based on the older "hs-plugin" work by dons.  See the papers on hs-plugins from Don Stewart.
20:59:31 <tommd> handonson: This is something I only have second-hand knowledge of from being on #haskell too much - my help stops at telling you those two packages.
21:01:22 <Mitar> hmm, how can i catch an exception in a state monad (over io monad) so that on exception i can update the state?
21:02:03 <kmc> Mitar, you're using StateT s IO ?
21:02:14 <Mitar> yes
21:02:25 <kmc> @unmtl StateT s IO a
21:02:26 <lambdabot> s -> IO (a, s)
21:02:38 <kmc> Mitar, write a function of that type, using whatever Control.Exception primitives you like
21:02:54 <kmc> then wrap it in the StateT constructor
21:03:11 <kmc> :t runStateT
21:03:12 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
21:03:18 <Mitar> hmm, but I am already in stateT, so i am already running state
21:03:31 <kmc> yeah i was looking for my own reference
21:07:43 <kmc> :t \(StateT f) -> StateT (\s -> try (f s) >>= \x -> case x of Left e -> return (Left e,s); Right (y,s') -> return (Right y, s'))
21:07:44 <lambdabot> Not in scope: `try'
21:07:50 <kmc> :t \(StateT f) -> StateT (\s -> Control.Exception.try (f s) >>= \x -> case x of Left e -> return (Left e,s); Right (y,s') -> return (Right y, s'))
21:07:51 <lambdabot> forall s e b. (GHC.Exception.Exception e) => StateT s IO b -> StateT s IO (Either e b)
21:08:04 <kmc> Mitar, ^^^ there's probably a nicer way to write it though...
21:09:32 <Mitar> hm, this is not possible to use inside the StateT code?
21:10:05 <megajosh2> @src IO
21:10:06 <lambdabot> Source not found. I am sorry.
21:12:18 <kmc> i don't understand your question Mitar
21:12:27 <kmc> what i wrote above is sort of a variation on "Control.Exception.try"
21:12:33 <kmc> which works on (StateT s IO)
21:12:42 <kmc> you'd use it the same way as "try"
21:12:55 <kmc> and you could use a similar strategy to lift other Exception combinators to StateT
21:12:55 <Mitar> hm, my question is, if I do evalStateT fun initState
21:13:03 <Mitar> how do i catch exception in fun, and update state?
21:13:45 <Mitar> ok, let me see your try again
21:14:07 <kmc> let me rewrite it in non-terrible style
21:14:26 <bos> @pl \n c' -> n `max` maximum c'
21:14:26 <lambdabot> (. maximum) . max
21:14:58 <kmc> hmm "catch" might be a better match
21:15:55 <mcnster> hi.  does anyone know if it is possible to compile/install the Haskell Platform as dynamically loadable .so's....?  (the makefiles don't seem to consider that possibility...)
21:15:57 <Mitar> a ryhme ;-)
21:16:03 <kmc> :)
21:16:07 <mcnster> oh:  x86_64
21:16:20 <mcnster> oh:  linux
21:20:01 <Mitar> :t <<
21:20:03 <lambdabot> parse error on input `<<'
21:20:08 <bos> :t (<<)
21:20:09 <lambdabot> Not in scope: `<<'
21:20:11 <bos> nice
21:20:18 <bos> :-)
21:21:33 <monochrom> In scripts/build.sh: in the lengthy line «tell ../Setup configure etc», somewhere add «--enable-shared --ghc-option=-package-conf="../../${PACKAGE_DB}"».  See also http://article.gmane.org/gmane.comp.lang.haskell.cafe/77575/
21:22:36 <mcnster> monochrom, excellent!  thanks much :)
21:25:39 <kmc> Mitar, like this perhaps: http://codepad.org/2sJr4NQJ
21:26:11 <kmc> Mitar, note that the handler gets the initial state as of the start of the catchStateT
21:26:36 <kmc> you can't catch a "partially updated" state
21:26:44 <kmc> i believe that's impossible with StateT s IO
21:27:19 <Mitar> hmm, i run forever loop in the StateT state
21:27:36 <Mitar> like runStateT (forever $ doMyStuff) initState
21:27:59 <JoeyA> I wonder if it'd ever be a good idea to implement a doubly linked list with IORefs.
21:28:06 <Mitar> so catcStateT will get initState?
21:28:19 <Mitar> hm hm
21:28:21 <kmc> depends where you put the catch Mitar
21:28:50 <kmc> JoeyA, fwiw Chan is a singly linked list of MVar
21:29:03 <kmc> (actually, a pair of MVars pointing into a singly linked list of MVars)
21:29:08 <Mitar> yes, i can do s <- get, catchStateT ..., put s
21:29:13 <JoeyA> I guess it'd be something like data Link a = Link a (IORef Link a) (IORef Link a)
21:29:28 <Mitar> s <- get, s' <- catchStateT ..., put s'
21:29:47 <JoeyA> Those should probably be Maybes though, to handle the end cases.
21:30:06 <kmc> JoeyA, or make them MVars and leave them empty; then you get fun concurrency semantics
21:30:20 <JoeyA> data Link a = Link a (IORef (Maybe Link a)) (IORef (Maybe Link a))
21:30:44 <JoeyA> The main purpose of that would be to efficiently add and remove items from a linked list.
21:31:38 <monochrom> is your purpose just double-end queue? add and remove at both ends, but not in the middle?
21:31:50 <JoeyA> no, add items to a set
21:31:53 <JoeyA> then pull arbitrary ones out.
21:33:21 <kmc> linked lists are generally not good for implementing a set
21:33:43 <ddarius> Ordered linked lists actually do make a reasonable implementation of sets.
21:33:55 <monochrom> not sure which way is arbitrary: implementation chooses arbitrarily as it sees fit, vs user chooses which item to pull out.
21:34:26 <JoeyA> I mean the user pulls arbitrary items out.
21:34:34 <kmc> ddarius, with linear search? or do you have extra structure like a skip list?
21:34:36 <monochrom> see also http://www.vex.net/~trebla/weblog/any-all-some.html
21:35:01 <Mitar> is there some nicer way to write: case foo of Bla -> doSomething; _ -> return ()
21:35:19 <kmc> when (isBla foo) doSomething
21:35:21 <monochrom> do the items enjoy Ord? you could use search trees.
21:35:31 <kmc> assuming you have isBla and don't need to bind names by pattern matching
21:35:32 <Mitar> and isBla is what?
21:35:42 <kmc> isBla Bla = True; isBla _ = False
21:35:57 <Mitar> ok
21:35:58 <tommd> deriving Is via the derive package
21:36:00 <monochrom> Θ(n) deletion is unnice, mutable or not.
21:36:13 <Mitar> kmc: thanks
21:36:29 <Mitar> nice, unicode on IRC ;-)
21:36:30 <tommd> Mitar: You can derive the "isBla" function too
21:36:38 <Mitar> hmm, i can?
21:36:41 <tommd> yes
21:36:49 <Mitar> crazy
21:36:50 <JoeyA> Search trees are needlessly less efficient if all I'm interested in is adding/removing items without examining prior state.
21:36:58 <ddarius> kmc: With linear search for membership, but bulk operations aren't so bad.
21:37:17 <Mitar> where it is defined?
21:37:21 <Mitar> deriving (Eq, Show, Is)
21:37:22 <kmc> JoeyA, what are the operations you need?
21:37:24 <Mitar> does not work?
21:37:33 <kmc> Mitar, you'd have to use the "derive" package off Hackage, and read about how it works
21:37:39 <tommd> Mitar: See the "derive" package.
21:37:39 <tommd> import Data.DeriveTH
21:37:39 <tommd> $( derive makeIs ''NodeHealth)
21:38:05 <tommd> That will derive isConstructor for all constructors of the "NodeHealth" data type
21:39:01 <Mitar> interesting
21:39:03 <Mitar> thanks
21:39:09 <Mitar> i will have to look more into TH
21:39:16 <tommd> Alternatively you can add the "derive" binary as another stage of your compile pipeline (cabal evidently has some support, I think) and instead use:
21:39:16 <tommd> data Blah = Foo | Bar deriving (Eq, Ord, Show {-! Is !-})
21:39:45 <tommd> The "derive" binary will spit out some Haskell code in a file somewhere - this avoids the TH if you don't like TH.
21:39:57 <Mitar> i do not know TH yet ;-)
21:40:03 <tommd> Neither do I, I just use it.
21:40:04 <Mitar> i heard about it but not yet used it
21:40:10 <monochrom> well, if you want to use a doubly-linked list, feel free
21:40:13 <tommd> As in, use the Derive package TH pieces.
21:40:26 <JoeyA> kmc: Not that I need it per se, but it'd be nice to have a stateful list where I can insert and remove links in constant time.  Granted, it wouldn't be hard to implement, and it'd be a fun exercise.
21:40:30 <monochrom> I can't find one on hackage in a hasty 1-minute look.
21:40:49 <tommd> JoeyA: Does dlist not do what you need?
21:41:01 <JoeyA> insert :: a -> List -> m (Link a)
21:41:03 <tommd> not doubly linked, but fills many gaps
21:41:14 <JoeyA> remove :: Link a -> List -> m ()
21:41:29 <tommd> @hackage dlist
21:41:29 <lambdabot> http://hackage.haskell.org/package/dlist
21:41:50 <lispy> JoeyA: does Data.Sequence support insert?
21:42:01 <lispy> if it does, it might be faster than [a]
21:42:04 <monochrom> dlist doesn't even let you remove things
21:42:30 <ddarius> lispy: If it doesn't, splitAt+append should give you the optimal bounds.
21:42:44 <tommd> Not from the middle - I didn't see a list of requirements  "remove links"  is that removing arbitrarily placed nodes?
21:43:35 <JoeyA> Speaking of state, what is ST's s parameter even for, anyway?
21:43:52 <lispy> JoeyA: to isolate side effects
21:43:55 <monochrom> for region, I would say.
21:44:19 * hackagebot criterion 0.5.0.4 - Robust, reliable performance measurement and analysis  http://hackage.haskell.org/package/criterion-0.5.0.4 (BryanOSullivan)
21:44:38 <tommd> oohh, shiny new package!
21:44:49 <JoeyA> Well, who gets to say what s is?
21:44:53 <lispy> tommd: hehe
21:44:55 <JoeyA> Function implementations?
21:45:02 <monochrom> runST gets to say what s is.
21:45:02 <lispy> JoeyA: no one :)
21:45:10 <JoeyA> hmm
21:45:20 * hackagebot statistics 0.8.0.1 - A library of statistical types, data, and functions  http://hackage.haskell.org/package/statistics-0.8.0.1 (BryanOSullivan)
21:45:22 * hackagebot mwc-random 0.8.0.1 - Fast, high quality pseudo random number generation  http://hackage.haskell.org/package/mwc-random-0.8.0.1 (BryanOSullivan)
21:45:25 <JoeyA> why can't it just do without the s variable like IO does?
21:45:33 <monochrom> and runST won't tell you what. so you have to be completely general.
21:45:39 <JoeyA> When does it ever have a concrete type?
21:45:48 <kmc> JoeyA, it has a concrete type in stToIO
21:45:49 <monochrom> no one knows
21:46:00 <kmc> JoeyA, if you use runST then the parameter s is *forced* to be polymorphic
21:46:01 <kmc> :t runST
21:46:02 <lambdabot> forall a. (forall s. ST s a) -> a
21:46:16 <kmc> JoeyA, i'll explain why
21:46:29 <kmc> it ensures that anything tagged with s, like an STRef, can't leak out of runST
21:46:42 <kmc> if we had simply:  runST :: ST s a -> a
21:47:04 <kmc> then (runST $ newSTRef ()) :: STRef s ()
21:47:10 <kmc> an STRef outside the ST monad
21:47:14 <JoeyA> oh, because the STRef also has to carry the tag around
21:47:18 <kmc> much like (unsafePerformIO $ newIORef ()) :: IORef ()
21:47:26 <kmc> but with the rank-2 type for runST, that's not allowed
21:47:47 <kmc> because some context external to that call could constrain 's', yet runST requires that its argument is *fully* polymorphic, no constraint on s.  so it's a type error
21:47:52 <monochrom> you can't escape from IO, you don't need s. you can escape from ST, you need s to restrict what stuff may escape.
21:48:19 <kmc> in fact the difference between IO and ST (in GHC) is solely this type trickery
21:48:26 <kmc> at runtime, runST and unsafePerformIO work identically
21:48:59 <JoeyA>  a confusing bit for me is: when we say forall s. ST s a, does s ever "change" between actions?
21:49:05 <lispy> in the type of runST, the final type 'a' can't depend on 's'.
21:49:12 <JoeyA> Or does s get locked in to a singular type of runST's choosing?\
21:49:36 <kmc> JoeyA, none of the code passed to runST can care what 's' is in any way
21:49:43 <kmc> nor can the code using the result from runST
21:51:06 <JoeyA> When I looked at the ST example in http://www.haskell.org/haskellwiki/Prime_numbers before I really understood monads, and still a bit now, I was confused by:
21:51:12 <JoeyA> a <- newArray (1,m) True :: ST s (STUArray s Int Bool)
21:51:32 <JoeyA> Why don't we have to use a scoped type variable and ensure that s is the same as the other s-es?
21:51:44 <JoeyA> Or why don't we have to say :: forall s. ST s (STUArray s Int Bool) ?
21:51:52 <lispy> JoeyA: if you like reading papers, I think this is the one that explains ST: http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z
21:52:22 <kmc> JoeyA, if s is not in scope, «ST s (STUArray s Int Bool)» is equivalent to «forall s. ST s (STUArray s Int Bool)»
21:53:00 <kmc> furthermore you don't need ScopedTypeVariables to ensure that the two 's' in the same type expression are the same
21:53:08 <kmc> and i don't see what other 's' there is
21:53:12 <lispy> JoeyA: in that type signature, the s will be the same in both uses.  If some part if it was in a nested scope then you'd have to worry about getting them to be the same s.  You'd need something like lexically scoped type variables
21:53:33 <kmc> the type (a,a) is different from (a,b) even without ScopedTypeVariables
21:53:45 <lispy> (asTypeOf is a poor man's lexically scoped type variables, but sometimes it's just too hard to use)
21:55:30 <lispy> JoeyA: rank2 types take a while to sink in
21:56:29 <lispy> this might also help: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_runST
21:56:31 <JoeyA> http://codepad.org/QV8T13oo
21:56:50 <ddarius> JoeyA: The type of (>>=) requires the same s.
21:56:55 <JoeyA> This one tripped me up:  GHC recommended using RankNTypes, so I started thinking forall s. ST s (STUArray s Int Bool) involved rank 2 stuff.
21:57:55 <lispy> JoeyA: runST has a rank2 type
21:58:02 <JoeyA> ScopedTypeVariables also works.
21:58:18 <JoeyA> I can see that now.
21:58:37 <JoeyA> I have a pretty good idea of what rank 2 types are.
21:59:19 <JoeyA> I just had to revisit why I thought using ST required rank 2 types in my code (which I guess it doesn't).
22:00:39 <megajosh2> :t runST
22:00:40 <lambdabot> forall a. (forall s. ST s a) -> a
22:00:45 <megajosh2> Ah
22:01:00 <kmc> ∀a. (∀s. ST s a) → a
22:01:01 <kmc> ;P
22:01:25 <megajosh2> The logic symbols always helps me get it
22:01:27 <megajosh2> *help
22:02:03 <JoeyA> So, if we didn't care about STRef leaking but we still wanted to be jerks and make ST have 2 type variables, could STRef have just 1?
22:02:23 <JoeyA> as in: data STRef a
22:03:13 <JoeyA> I think I get it now.  All of the computations inside of an ST action ultimately lock into a single s type.  The STRefs fall into line so they stay inside the same ST action.
22:03:43 <JoeyA> so two separate ST computations will have their own s (even though they're both called s) so STRefs can't bounce between them.
22:03:52 <EliasAmaral> kmc, this is something I have a lot of doubt. isn't ∀a. (∀s. ST s a) → a equivalent to ∀a. ∀s. (ST s a) → a?
22:03:59 <lispy> JoeyA: basically, yes
22:04:16 <dolio> EliasAmaral: No.
22:04:17 <EliasAmaral> I understand that rank-2 types introduce a "namespace" for this s variable
22:04:27 <EliasAmaral> but it is not found in any other part of the type
22:04:58 <lispy> EliasAmaral: viewed at the outer most level, the forall on the s has an inverted meaning
22:05:19 <kmc> EliasAmaral, ∀a. (T a → B) says that the *caller* gets to choose any A she likes, and supply T A, and we have to supply b
22:05:20 <lispy> EliasAmaral: where it's placed, you can tihnk of it as exists s.
22:05:22 <kmc> have to supply B*
22:05:49 <kmc> EliasAmaral, «(∀ a. T a) → B» says that the caller *must* supply a value x such that x :: T A for any A *we* pick
22:05:49 <monochrom> it always comes down to "who chooses"
22:06:03 <Mitar> is there already some function which will make a timer thread to throw exceptions at regular interval?
22:06:29 <EliasAmaral> kmc, and what "we" would be?
22:06:31 <lispy> I think of the adversarial game analogy of quantifiers to be like an operational semantics for them
22:06:33 <kmc> the function of that type
22:06:41 <monochrom> the implementation.
22:07:00 <monochrom> it's always a power struggle between user and implementation
22:07:01 <kmc> EliasAmaral, an ordinary ∀ at the outside of a type represents a guarantee that function is making to its callers.  a higher-rank ∀ within an argument type represents a demand a function is making of its callers
22:07:14 <monochrom> or caller and callee
22:07:21 <kmc> "i will accept any old type here" versus "i demand you give me a value that works at any type i choose"
22:07:53 <kmc> runST demands that the ST action can't care about the parameter s
22:08:10 <kmc> which is different from saying runST doesn't care about the parameter s
22:08:12 <lispy> This example will help blow your mind about quantifiers: http://okmij.org/ftp/Computation/lem.html
22:08:54 <EliasAmaral> does this have some equivalence in first-order logic?
22:09:04 <lispy> the purify function is a great example of when the callee gets to make the choice
22:09:18 <kmc> EliasAmaral, yes, by Curry-Howard isomorphism
22:09:33 <kmc> it's precisely how you expect ∀ and → to interact in first-order logic
22:09:50 <monochrom> I knew first-order logic before rank-2 types. So it took me just seconds to understand rank-2 types.
22:09:59 <kmc> we can only use «(∀ x. S) → T» if we prove the universally quantified statement «∀x. S»
22:10:17 <kmc> but we can use «∀ x. S → T» if we pick any old x we want
22:10:28 <kmc> we don't need to prove S for all x, just for the x we picked
22:10:37 <lispy> kmc: what input tools do you use that lets you have these symbols ready so fast?
22:10:50 <kmc> lispy, X compose key plus a custom file
22:10:58 <Mitar> what is the easiest way to make monadic function return () instead of a/
22:11:00 <Mitar> ?
22:11:04 <monochrom> Other programmers probably didn't know in that order, or did but took deliberate effort to forget the logic.
22:11:12 <tommd> Mitar: return ()
22:11:19 <EliasAmaral> kmc, what would be → in first order logic? some random binary predicate?
22:11:20 <Mitar> i know, but if i have some other function?
22:11:21 <lispy> Mitar: someMonadicFunction >> return ()
22:11:24 <kmc> EliasAmaral, implication
22:11:29 <EliasAmaral> ah
22:11:30 <Mitar> like forkIO $ do bla bla bla
22:11:31 <tommd> monadicFunc >> return ()
22:11:43 <monochrom> You know, "whee the exam is over! now I can forget this shit"
22:11:44 <tommd> oh, yeah, lispy, sure, beat me to understanding it.
22:11:46 <Mitar> it is ugly to do (forkIO $ do ....) >> return ()
22:11:48 <kmc> to prove that A implies B in (constructive) FOL, write a function that takes a proof of A and returns a proof of B
22:11:59 <lispy> tommd: no worries, Mitar didn't notice :)
22:12:12 <kmc> A ⇒ B  ≡  A → B
22:12:22 <tommd> Mitar: somewhat.  I'd ask yourself why you're ignoring the result of the last part of the "do"
22:12:22 <lispy> Mitar: so define, void m = m >> return ()
22:12:23 <kmc> A ∨ B  ≡  Either A B
22:12:29 <kmc> A ∧ B  ≡  (A, B)
22:12:40 <EliasAmaral> <kmc> but we can use «∀ x. S → T» if we pick any old x we want <kmc> we don't need to prove S for all x, just for the x we picked <- isn't this existencial quantification?
22:12:42 <kmc> ¬A  ≡  A → Void
22:12:44 <lispy> void $ do $ forkIO $ do ...
22:12:57 <kmc> EliasAmaral, there's a duality between ∀ and ∃, yes
22:12:58 <Mitar> there is no void function already defined?
22:13:00 <EliasAmaral> ∀ x. S → T seems to hold for all x, not just for the x you picked
22:13:06 <tommd> Mitar: If you last operation is often a library routine (mapM or some such) then you should be using the _ variants (mapM_)
22:13:13 <kmc> EliasAmaral, yes, it does.  but *in particular* it holds for that x
22:13:20 <kmc> EliasAmaral, i'm talking about *using* that statement, not proving it
22:13:25 <tommd> @hoogle m a -> m ()
22:13:26 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
22:13:26 <lambdabot> Text.ParserCombinators.ReadP optional :: ReadP a -> ReadP ()
22:13:26 <lambdabot> Text.ParserCombinators.ReadP skipMany :: ReadP a -> ReadP ()
22:13:29 <Mitar> forkIO does not have forkIO_ ;-)
22:13:43 <kmc> if you have «∀x. φ» then you also have φ[x] for any particular x you like
22:13:55 <EliasAmaral> yes
22:14:05 <tommd> Mitar: So are you saying forkIO is the last thing called and you want to ignore the threadId, or are you saying what you are calling with forkIO is the issue.
22:14:12 <lispy> tommd: now that we have the warning about unused do binding blah, we should have void :: m a -> m (), in Control.Monad
22:14:25 <Mitar> forkio is the last thing and i would like to ignore threadid
22:14:39 <monochrom> just make "return ()" the last thing
22:14:50 <tommd> lispy: Sounds like a good proposal.  I say we make Mitar propose it to l@h.o
22:15:18 <Mitar> i agree
22:15:26 <lispy> Well then, it's settlede
22:15:32 <lispy> settled*
22:15:33 <Mitar> what??
22:15:39 <EliasAmaral> kmc, but for both (∀x. S) → T and ∀x. S → T, don't I have S[x] → T for any x I like?
22:15:39 <tommd> Mitar: Ok, yes you are correct then, either add "return ()" at the end of the do block or add >> return () to whatever calls that routine.
22:15:40 <Mitar> http://pastebin.com/bv0t3tgM
22:15:41 <kmc> EliasAmaral, and if we have ∀x. S → T, and some particular S[x], then we can prove that particular T[x]
22:15:51 <EliasAmaral> hmm
22:16:00 <kmc> but if we have (∀x. S) → T, and some particular S[x], then we can't do anything
22:16:14 <kmc> because we don't get any thing until we prove S for *every* x
22:16:26 <tommd> @hoogle throwTo
22:16:26 <lambdabot> Control.Concurrent throwTo :: Exception e => ThreadId -> e -> IO ()
22:16:26 <lambdabot> Control.Exception throwTo :: Exception e => ThreadId -> e -> IO ()
22:16:26 <lambdabot> Control.OldException throwTo :: Exception e => ThreadId -> e -> IO ()
22:16:51 <lispy> Mitar: personally, I would have timer return IO ThreadId, or whatever the inferred type is.  Ignore the return value as late as possible. It will make this code more composable.
22:16:54 <EliasAmaral> ok. but if x doesn't appear free in T, then we can go from (∀x. S) → T to ∀x. S → T, right?
22:17:11 <monochrom> no.
22:17:18 <monochrom> and there are counterexamples.
22:18:17 <Mitar> but it is internal small function
22:18:30 <Mitar> and i would like to get rid of that threadid here
22:18:30 <EliasAmaral> monochrom, was that to my assertion?
22:18:34 <monochrom> Yes
22:18:56 <kmc> (∀n. n = 2) → False
22:18:59 <kmc> that's a true statement
22:19:08 <kmc> ∀n. n = 2 → False
22:19:10 <kmc> clearly isn't
22:19:36 <kmc> you can go the other way though
22:19:49 <kmc> if any particular S[x] suffices to prove T, then certainly (∀x. S) suffices
22:19:58 <EliasAmaral> hmm
22:20:05 <kmc> in Haskell terms, you're just writing a more specific type than necessary
22:20:28 <EliasAmaral> (∀x. S) → T is a subtype of ∀x. S → T?
22:20:33 <kmc> (here i am keeping your assumption that x does not appear free in T)
22:21:21 <EliasAmaral> (anyway, already convinced that those two types are different:)
22:21:24 <copumpkin> EliasAmaral: no
22:21:29 <lispy> EliasAmaral: I would avoid the term subtype and say that one generalizes the other
22:21:41 <kmc> :t let f :: forall x. Maybe x -> (); f = undefined; g :: (forall x. Maybe x) -> (); g x = f x in g
22:21:42 <lambdabot> (forall x. Maybe x) -> ()
22:21:52 <monochrom> Do you assume non-empty domains for variables in constructive first-order logic?
22:22:14 <copumpkin> I wouldn't even say one is a generalization of the other
22:22:27 <copumpkin> you can view one as a function of three parameters, and the other as a function of two
22:23:11 <EliasAmaral> Int -> Int is more specific than a -> a, and thus is a subtype
22:23:49 <ddarius> copumpkin: Yes, but T -> ∀x.T [x not free in T]
22:24:24 <copumpkin> yeah, but I thought we were working with x free in S
22:24:27 <monochrom> But I guess I can instantiate ∀x. S to S[()]
22:24:36 <copumpkin> maybe I had it backwards
22:24:43 <lispy> I missed the explanation of S[_]
22:24:48 <ddarius> EliasAmaral: I'd be very careful with that terminology and with the "generalization" terminology.  It's a matter of perspective.  However, in that case, Int -> Int is an instance of ∀a.a -> a.
22:25:25 <ddarius> copumpkin: x is free in S, but not free in ∀x.S
22:25:27 <EliasAmaral> (yes, I had this supposition: x is not free in T. said nothing about S though)
22:25:31 <lispy> I thought generalizing was the standard haskell terminology.  Do we have some slogan like H-M types are the least general type possible?
22:25:36 <copumpkin> ddarius: sure
22:26:30 <lispy> (I think I always think about that backwards.  Maybe it was most general type)
22:26:50 <kmc> H-M always finds principal types
22:26:54 <kmc> most general possible
22:26:58 <ddarius> lispy: Most general.  There is a technical meaning of "generalize" but it doesn't capture all uses of the non-technical meaning and can be misleading at times.
22:27:02 <monochrom> There are 17 standard notations for substitution :)
22:27:17 <kmc> but this fails in numerous ways in Haskell
22:31:55 <monochrom> And that concludes tonight's discussion on sentences and types. Tune in next week for "The Sunday Night Talk Show"
22:34:22 <EliasAmaral> :D
22:34:43 <kmc> → ← ⇒ ⇐ ↦ ↤ ↣ ↢ ⇀ ↼ ⇁ ↽ ⇉ ⇇ ⇄ ⇆
22:34:44 <EliasAmaral> The Lambda Sunday
22:35:32 <geheimdienst> The Sunday Night Talk Read
22:35:58 <geheimdienst> if you missed it, join us for the double feature of The Sunday Night Talk (Read, Show)
22:36:06 <dibblego> bos, have you ever considered splitting FileManip into a module that doesn't require the unix dependency?
22:36:14 <kmc> type a :⇄ b = (a → b, b → a)
22:39:21 <EliasAmaral> kmc, is the : necessary?
22:39:36 <EliasAmaral> for type operators
22:39:48 <EliasAmaral> -> itself doesn't seem to need it
22:44:17 <kmc> -> is a special case
22:44:48 <kmc> otherwise you need :, and -XTypeOperators
22:45:29 <bos> dibblego: yeah
22:45:56 <dibblego> bos, I'd give you a cookie if you did!
22:45:59 <EliasAmaral> but I see no chance for conflict. except maybe the . at forall x.
22:46:16 <EliasAmaral> (but forall being a keyword, one can account for that)
22:46:48 <kmc> EliasAmaral, symbols starting with : are considered "upper case"
22:46:51 <kmc> others are "lower case"
22:46:56 <kmc> if you write «X + Y» in type context then (+) is a type variable
22:47:07 <bos> dibblego: ha!
22:47:11 <EliasAmaral> anywhere? like in expressions too
22:47:13 <kmc> :t let x :: Int + Char; x = undefined in x
22:47:14 <lambdabot> forall (+ :: * -> * -> *). (+) Int Char
22:47:16 <bos> dibblego: well, that code needs some cleanup anyway
22:47:34 <kmc> EliasAmaral, yeah.  if you make infix data constructors they have to start with :
22:47:35 <EliasAmaral> ah
22:47:39 <kmc> following the trend of (:) itself
22:47:53 <EliasAmaral> ah
22:47:56 <megajosh2> @hoogle liftM
22:47:56 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
22:47:56 <lambdabot> Control.Monad liftM2 :: Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:47:56 <lambdabot> Control.Monad liftM3 :: Monad m => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
22:47:58 <lispy> bos: your improvements to mapAccum in Data.Text made me wonder, is the version defined for lists also quadradic?
22:48:21 <EliasAmaral> btw: if the "arrow" typeclass a -> b shares the same type syntax as functions.. then functions are an instantiation of this typeclass?
22:49:04 <lispy> EliasAmaral: functions are an instance of arrow
22:49:12 <EliasAmaral> and then anyone can "apply" any arrow f with syntax f x?
22:49:20 <kmc> no
22:49:26 <kmc> you can't even apply arrows in general
22:49:35 <kmc> i'm not sure what you mean by 'the "arrow" typeclass a -> b shares the same type syntax as functions'
22:50:35 <bos> lispy: no, because cons on a list doesn't take linear time
22:50:43 * hackagebot usb 0.6.0.1 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6.0.1 (BasVanDijk)
22:50:47 <lispy> bos: oh I see
22:50:57 <bos> lispy: but mapAccumL on lists is insufficiently strict, so it suffers fatal space leaks quite trivially
22:51:11 <bos> i.e. it kills you much deader :-)
22:51:22 <lispy> good to know
22:51:47 <lispy> I saw it in some code for the first time just last month and I was wondering if it had any performance side-effects
22:51:55 <EliasAmaral> kmc, err, http://en.wikibooks.org/wiki/Haskell/Understanding_arrows
22:52:17 <kmc> what about it?
22:52:44 <kmc> great, it starts off with a robot factory conveyor belt metaphor
22:52:44 <EliasAmaral> anyway, the type a -> b designates a function, not an arrow?
22:52:53 <kmc> this is impossible to understand, why didn't they use burritos instead?
22:52:58 <kmc> EliasAmaral, yes
22:53:10 <EliasAmaral> :),
22:53:17 <EliasAmaral> so arrows are like Arrow a b?
22:53:18 <lispy> kmc: yeah, that wikibook on arrows had me lost about them for a long time
22:53:26 <copumpkin> no, Arrows replace the (->) there
22:53:34 <kmc> EliasAmaral, an arrow is any type which is a member of the Arrow type class
22:53:44 <kmc> (->) is an arrow, so is (Kleisli Maybe)
22:53:48 <kmc> so are... a few other things
22:53:57 <copumpkin> that nobody ever seems to know
22:54:05 <copumpkin> :)
22:54:25 <EliasAmaral> but "functions are arrows"
22:54:31 <EliasAmaral> what is the type of an arrow, in general?
22:54:39 <dibblego> (->) is an arrow, so is Monad m => Kleisli m
22:54:42 <ddarius> Automatons, coKleisli arrows, signal transducers, hyperfunctions I believe
22:54:57 <kmc> EliasAmaral, i disagree with the statement "functions are arrows".  i think it's the same kind of error as "getChar is a monad"
22:55:07 <megajosh2> @hoogle Text.ParserCombinations.Parsec letter
22:55:08 <lambdabot> No results found
22:55:08 <kmc> (->) is an arrow
22:55:12 <megajosh2> @hoogle Text.ParserCombinations.Parsec.letter
22:55:12 <lambdabot> No results found
22:55:15 <EliasAmaral> it's Arrow a?
22:55:18 <kmc> functions are values whose type has the constructor (->)
22:55:18 <megajosh2> @hoogle letter
22:55:18 <lambdabot> Text.Parsec.Char letter :: Stream s m Char => ParsecT s u m Char
22:55:18 <lambdabot> Text.ParserCombinators.Parsec.Char letter :: Stream s m Char => ParsecT s u m Char
22:55:19 <lambdabot> Data.Char LetterNumber :: GeneralCategory
22:55:23 <EliasAmaral> :t (->)
22:55:24 <lambdabot> parse error on input `->'
22:55:27 <kmc> "the type of an arrow" makes no sense
22:55:28 <copumpkin> :k (->)
22:55:29 <dibblego> @kind (->)
22:55:29 <lambdabot> ?? -> ? -> *
22:55:30 <kmc> arrows are types
22:55:30 <lambdabot> ?? -> ? -> *
22:55:39 <copumpkin> the kind of an arrow!
22:55:41 <megajosh2> ParsecT? Hmm...
22:55:43 <EliasAmaral> kmc, .. aren't arrows *values*?...
22:55:43 <kmc> if A is an arrow, it is a type constructor of kind * → * → *
22:55:54 <kmc> EliasAmaral, not the way i use the word
22:55:57 <kmc> EliasAmaral, monads aren't values either
22:56:03 <copumpkin> they're values of a higher universe
22:56:07 <kmc> the type class Arrow is the class of arrow types, the way Monad is the class of monad types
22:56:11 <kmc> (s/types/type constructors/)
22:56:32 <kmc> EliasAmaral, i'm no arrow expert, but this is the way to make the terminology consistent with Monad, Functor, Applicative, and all the rest
22:56:42 <kmc> we don't say that [1,2,3] is a functor
22:58:10 <EliasAmaral> :t proc
22:58:11 <lambdabot> Not in scope: `proc'
22:58:18 <kmc> 'proc' is part of the arrow syntax
22:58:28 <EliasAmaral> ok, proc is the "do" of arrows
22:58:39 <megajosh2> Special arrow syntax... hmm
22:58:45 <lispy> why proc?
22:58:52 <megajosh2> proc as in process?
22:59:24 <EliasAmaral> is there a function of type (Monad a) => a b -> b?
22:59:32 <ddarius> No.
22:59:51 <EliasAmaral> or a function of type (Arrow a) => a b c -> (b -> c)
22:59:55 <kmc> no
23:00:03 <ddarius> Well, not with that as the most general type (ignoring type annotations.)
23:00:06 <EliasAmaral> this would be like a "choose", right? (of set theory)
23:00:18 <ddarius> No.
23:00:21 <kmc> monads-in-general are "one-way", though most specific monads provide a way to extract values
23:01:07 <dibblego> (Copointed a) => a b -> b
23:01:25 <ddarius> There aren't a lot of copointed monads.
23:01:30 <kmc> what are some good examples of copointed functors?
23:01:35 <copumpkin> Identity!
23:01:42 <copumpkin> any Comonad :)
23:01:47 <dibblego> NonEmptyList
23:01:54 <EliasAmaral> I mean, set theory has this notion of providing an element of a non-empty set. But monads are not sets either
23:01:57 <megajosh2> This metaphor for arrows I just can't follow (referring to the wikibook page)
23:01:57 <kmc> most monads aren't copointed as such, but provide a "way out" with some extra information -- a starting state, an error continuation, etc
23:02:09 <EliasAmaral> dibblego, so List is an instance of Copointed?
23:02:14 <copumpkin> no
23:02:19 <dibblego> no, since [a] -> a is a lie
23:02:20 <copumpkin> NonEmptyList (Cofree Identity) is
23:02:32 <copumpkin> where those are human-level parentheses
23:02:36 <EliasAmaral> [a] -> a can return the top or undefined
23:02:45 <dibblego> ergo, a lie
23:02:52 <EliasAmaral> :)
23:03:02 <dibblego> ((,) a) is another example
23:03:06 <kmc> copumpkin, now you see the awesome power of my guillemets
23:03:10 <EliasAmaral> :t (,)
23:03:11 <lambdabot> forall a b. a -> b -> (a, b)
23:03:11 <copumpkin> lol
23:03:14 <ddarius> Now someone produce an example that isn't a comonad.
23:03:17 <dibblego> @kind (,)
23:03:18 <lambdabot> * -> * -> *
23:03:30 <ddarius> (Here is a more interesting example, that still is a comonad, Monoid m => m -> a)
23:04:08 <ddarius> copumpkin: Cofree Identity is Stream not NonEmptyList
23:04:15 <copumpkin> oh yeah
23:04:15 <copumpkin> Maybe
23:04:16 <copumpkin> :)
23:04:41 <copumpkin> 8am! I need some Cofree
23:05:01 <ddarius> copumpkin: Where are you physically (roughly) right now by the way?
23:05:17 <copumpkin> ddarius: Rome, Italy, until further notice :P
23:05:34 <megajosh2> @src letter
23:05:34 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
23:05:49 <megajosh2> @src Text.ParserCombinators.Parsec letter
23:05:50 <lambdabot> Source not found.
23:05:51 <megajosh2> meh
23:05:53 <copumpkin> but timezone-wise, I'm still somewhere in the US
23:05:55 <ddarius> copumpkin: Yeah, I've heard about potential big life changes but wasn't sure where you were in them.
23:06:03 <copumpkin> much to the annoyance of my parents
23:06:24 <copumpkin> ddarius: ah, just sort of half looking for a job while working on personal projects at my parents' place
23:06:24 <EliasAmaral> it's 3am on brazil
23:06:31 <monochrom> oh, as in, you go to sleep at 8am.
23:06:43 <copumpkin> monochrom: yeah, and wake up mid-afternoon
23:06:49 <copumpkin> it's rather strange
23:06:55 <ddarius> copumpkin: Sounds like me and I'm still in the US.
23:07:16 <copumpkin> wow, what's your excuse? :)
23:07:25 <EliasAmaral> I don't travel, but I woke about 7 hours ago
23:07:26 <monochrom> Kamchatka time or something
23:07:39 <ddarius> copumpkin: I'm living alone in an apartment and between jobs.
23:07:52 <copumpkin> ah, that'll do it
23:09:26 <kmc> ddarius, ok, i worked out the comonad methods for (Monoid m => m -> a)
23:09:34 <kmc> ddarius, but what does it mean / what is it good for?
23:09:57 <kmc> there seem to be two choices for duplicate
23:10:14 <copumpkin> Stream fits one value of that
23:10:24 <copumpkin> as does Rosetree, I think
23:11:15 <megajosh2> :t arr
23:11:16 <lambdabot> forall b c (a :: * -> * -> *). (Arrow a) => (b -> c) -> a b c
23:11:39 <kmc> @arr
23:11:39 <lambdabot> Smartly me lass
23:11:57 <kmc> @. vixen nixon
23:11:58 <lambdabot> wait, back up
23:12:00 <megajosh2> :t arr (+)
23:12:01 <lambdabot> forall b (a :: * -> * -> *). (Num b, Arrow a) => a b (b -> b)
23:12:17 <megajosh2> :t arr (1+)
23:12:18 <lambdabot> forall t (a :: * -> * -> *). (Num t, Arrow a) => a t t
23:13:18 <copumpkin> :t arr matey
23:13:19 <lambdabot> forall b (a :: * -> * -> *). (Num b, Arrow a) => a b b
23:13:22 <copumpkin> dammit
23:13:32 <kmc> arr :: ∀ b c ((⇀) :: ∗ → ∗ → ∗). (Arrow (⇀)) ⇒ (b → c) → (b ⇀ c)
23:13:57 <copumpkin> kmc has become our resident unicode nerd
23:14:21 <kmc> mhm
23:14:23 <medfly> :)
23:14:31 <copumpkin> anyone have any idea when next boston hug will be btw?
23:14:31 <Eduard_Munteanu> Sure looks nice.
23:14:38 <kmc> too bad if you can't tell the difference between ⇀ and → in your font
23:14:42 <NemesisD> man what is up with base? the default version in cabal right now fails
23:14:43 * copumpkin votes for sometime between the 22nd and 26th
23:14:53 <kmc> NemesisD, are you trying to cabal install base?
23:15:01 <NemesisD> kmc: yes. is that wrong?
23:15:01 <Eduard_Munteanu> kmc: barely visible here too, I'm using DejaVu Mono.
23:15:05 <kmc> NemesisD, yes
23:15:08 <Maxdamantus> What's the difference? the former is marginally longer?
23:15:09 <kmc> NemesisD, base comes with ghc
23:15:21 <kmc> ⇀ is missing the bottom part of the arrow head
23:15:24 <Mitar> any suggestion: http://www.haskell.org/pipermail/haskell-cafe/2010-September/083589.html
23:15:27 <Maxdamantus> Oh, so it is.
23:15:33 <kmc> arr :: ∀ b c ((↣) :: ∗ → ∗ → ∗). (Arrow (↣)) ⇒ (b → c) → (b ↣ c)
23:15:36 <kmc> that's probably a better choice
23:15:42 <copumpkin> lol
23:15:46 <copumpkin> I always liked the squiggly ones
23:15:48 <Maxdamantus> and what are you using instead of asterisks? O_o
23:16:03 <megajosh2> I can kind of tell, using Bistream Vera Sans Mono
23:16:04 <copumpkin> kmc: you should make friends with Nils Anders Danielsson of agda stdlib fame
23:16:10 <megajosh2> Maxdamantus: Exactly what I was thinking
23:16:16 <kmc> ASTERISK OPERATOR U+2217
23:16:20 <mm_freak> can i build native windows programs in WINE, such that they run under windows?
23:16:26 <copumpkin> I get the impression he spends hours perusing unicode tables trying to find the next esoteric symbol to use in the agda standard libraries
23:16:38 <Maxdamantus> mm_freak: you'd probably want a cross compiler
23:16:45 <kmc> mm_freak, you can run a windows-targeting cross compiler on linux.  don't know what wine has to do with it
23:16:59 <kmc> (maybe wine would let you run Microsoft's compiler?)
23:17:17 <kmc> yeah, i need to learn me an agda
23:17:33 <kmc> i mean i've done some trivial stuff
23:17:37 <NemesisD> well don't i look foolish
23:17:47 <Maxdamantus> Do you have those keys on your input map?
23:17:55 <copumpkin> kmc: you can write super long arrows in agda!
23:17:55 <mm_freak> Maxdamantus: but there doesn't seem to be a cross compiler for haskell
23:17:56 <kmc> Maxdamantus, yes
23:17:58 <copumpkin> and make them squiggly!!
23:17:58 <Maxdamantus> or do you type unicode sequences in for everything?
23:18:00 <Maxdamantus> Ah.
23:18:05 <kmc> copumpkin, let's use a long arrow to represent the long line
23:18:12 <kmc> the long line is like the real line, but longer
23:18:13 <megajosh2> For stuff like that, I just use the Compose key
23:18:14 <kmc> much, much longer
23:18:15 <mm_freak> and that was @ kmc, too
23:18:16 <copumpkin> lol
23:18:19 <copumpkin> @quote long
23:18:20 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
23:18:27 <copumpkin> @quote longer
23:18:27 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
23:18:30 <copumpkin> :(
23:18:30 <kmc> mm_freak, you can build GHC as a cross compiler but it's not easy
23:18:41 <copumpkin> I thought I'd @remembered that at some point
23:18:44 <kmc> mm_freak, perhaps running GHC in Wine is the way to go, actually
23:18:57 <kmc> or just in a VM ;P
23:19:12 <mm_freak> well, i'd like to avoid having to use a VM =)
23:19:15 <copumpkin> strangely enough, for a brief period, Mac OS understood PE binaries
23:19:15 <kmc> ∗ ∗ ∗ only if you can afford a windows license of course ∗ ∗ ∗
23:19:20 <mm_freak> because VMs are slower than WINE
23:19:30 <copumpkin> I guess they then realized that they didn't want any of that and took it out
23:19:54 <Adamant> Mach-O is all about the cafe babes, anyway.
23:20:02 <copumpkin> :)
23:20:15 <mm_freak> well, i've got WINE installed and working already, just as well as the haskell platform for windows, so i'll probably take that approach…  but the question is:  are the exe files going to work under windows?
23:20:29 <mm_freak> they should, i guess
23:20:50 <Maxdamantus> Why wouldn't they?
23:21:15 <kmc> i think they will, but try it :)
23:21:27 <Maxdamantus> The output of a compiler will depend on what code was used to compile the compiler
23:21:32 <Maxdamantus> not what platform the compiler is running on
23:21:48 <kmc> it could depend on all of that
23:21:55 <kmc> GHC likes to assume it's running on its target platform
23:22:15 <mm_freak> yeah
23:22:23 <mm_freak> ok, so i can't assume that
23:22:24 <Maxdamantus> Yeah,b ut if it's running in Wino..
23:23:00 <mm_freak> Maxdamantus: WINE does a few things different than windows…  that's why not all of my games are working =P
23:23:20 <mm_freak> and GHC might take that into consideration
23:23:38 <Maxdamantus> Was GHC compiled in Wine?
23:23:40 <mm_freak> after all it's one of the smartest compilers i know of =)
23:23:45 <mm_freak> dunno
23:23:50 <mm_freak> it's in the haskell platform
23:24:11 * Maxdamantus has avoided this "haskell platform" stuff so far
23:24:49 <mm_freak> the haskell platform is really handy for windows
23:25:09 <mm_freak> ok, the windows GHCi says:
23:25:10 <mm_freak> System.Info> os
23:25:10 <mm_freak> "mingw32"
23:25:12 <mm_freak> under WINE
23:25:16 <mm_freak> so it will probably work
23:29:21 <ddarius> copumpkin: October at the earliest.
23:30:19 <copumpkin> damn :(
23:32:40 <kmc> that's right, Sept. meeting was canceled due to ICFP
23:32:57 <copumpkin> oh yeah
23:33:08 <copumpkin> damn ICFP, always ruining things
23:34:05 <ddarius> Except that I'll probably be too busy and the drive sucks, I could go down to ICFP.
23:35:05 <NemesisD> why is this an infinite type? lookupKey :: a -> [(a, b)] -> Maybe b
23:35:17 <ddarius> It isn't.
23:35:49 <copumpkin> NemesisD: what you're doing in your definition is making it infinite
23:36:09 <ddarius> s/making it infinite/making an expression whose inferred type is infinite
23:36:27 <ddarius> Also, that is very likely not the type you want, but I'll let you figure that out for yourself.
23:36:28 <NemesisD> then my implementation is: lookupKey k = fmap snd $ find (==k)
23:37:03 <ddarius> NemesisD: That means fmap snd (find (==k))
23:37:28 <NemesisD> tried to be too clever then. fmap snd (find (==k) l)
23:37:33 <copumpkin> you want compose
23:37:40 <copumpkin> fmap snd . find (==k)
23:38:05 <ddarius> lookupKey = (fmap snd .) . find . (==)
23:38:20 <ddarius> (assuming a symmetric (==))
23:40:04 <NemesisD> i don't really have good instincts yet for composition. also that definition still produces cannot construct the infinite type: a = (a, b)
23:40:23 <NemesisD> oh duhh
23:40:25 <ddarius> :t (fmap snd) . find . (==)
23:40:26 <lambdabot>     Couldn't match expected type `(a, b)'
23:40:26 <lambdabot>            against inferred type `Maybe a1'
23:40:27 <lambdabot>       Expected type: [a1] -> (a, b)
23:40:28 <NemesisD> missing a fst in there somewhere
23:40:30 <copumpkin> NemesisD: you probably left the lookupKey k =
23:40:37 <copumpkin> NemesisD: on ddarius's version
23:40:47 <NemesisD> its gotta get the fst out of the tuple to do the ==
23:40:57 <kmc> :t lookup
23:40:58 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
23:41:01 <kmc> *cough*
23:41:13 <copumpkin> oh whoops :)
23:41:27 <copumpkin> I'll take that as a reasonable indication that it's too late
23:41:30 <copumpkin> and I should be asleep
23:41:34 <copumpkin> g'night all
23:41:41 <kmc> 'night copumpkin :)
23:41:57 <NemesisD> later copumpkin 
23:41:58 <etpace> anyone know of a graphing package that handles multiple scales on the y axis easily?
23:43:06 <NemesisD> lol this is like the 5th time today ive started implementing something thats already in prelude
23:43:22 <kmc> NemesisD, sounds familiar
23:43:25 <kmc> it's good practice though :)
23:44:22 <tommd> NemesisD: A reasonable suggestion (that I didn't realize was actually quite reasonable) is to either read all of prelude or just have a print-out next to you as you program (as a Haskell beginner).
23:44:52 <NemesisD> *shakes fist because he lost access to free printing after graduation*
23:44:57 <kmc> there's also http://ww2.cs.mu.oz.au/172/exercises/tourofprelude.html
23:44:57 <tommd> I should say, when I was a beginner I didn't realize how small prelude actually is and reading it or printing it isn't as silly as I thought.
23:45:38 <tommd> NemesisD: Yeah, Coffee Houses really need to get in the printing business too - every business has wifi these days.
23:46:34 <NemesisD> hehe yeah
23:53:14 <ddarius> The tricky thing about Haskell's Prelude is that it often isn't obvious that something is already in the Prelude (or standard libraries) even if you do know every function.
23:57:10 <ddarius> A common example is the following: the cartesian product of two lists can be written \xs ys -> [(x,y) | x <- xs, y <- ys] and you can consider extending that to a function that takes a list of lists instead of just two (and thus produces a list of list of results instead of a list of pairs.)  This function is in the Prelude.  What is it?  If you can answer that you can answer this question: the first function I defined
23:57:10 <ddarius>  can be written very simply with a standard library function.
23:59:24 <ddarius> Once you solve that, here is a highly related question: People occasionally want this function: \x fs -> map ($ x) fs  It is also in the Prelude.
23:59:35 <EliasAmaral> ddarius, probably a (foldl . something) or (something . foldl)
23:59:46 <ddarius> EliasAmaral: Nope.
