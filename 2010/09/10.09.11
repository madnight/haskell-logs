00:00:03 <adnap> dark: If one list is larger, the rest of the elements get chopped off.
00:00:14 <dark> adnap, where is the 0? first element?
00:00:40 <adnap> dark: Not sure what you mean.
00:00:48 <adnap> > let f = [1,2,3]
00:00:49 <lambdabot>   not an expression: `let f = [1,2,3]'
00:01:30 <adnap> > let f = [1,2,3], h = [4,5,6] in 1
00:01:30 <lambdabot>   <no location info>: parse error on input `,'
00:01:54 <adnap> > let (f,h) = ([1,2,3],[4,5,6]) in zip f h
00:01:55 <lambdabot>   [(1,4),(2,5),(3,6)]
00:02:21 <adnap> dark: Okay, let me show you.
00:02:36 <adnap> > let (fs,hs) = ([1,2,3],[4,5,6]) in zip (tail . inits $ hs) (repeat fs)
00:02:37 <lambdabot>   [([4],[1,2,3]),([4,5],[1,2,3]),([4,5,6],[1,2,3])]
00:02:52 <dark> o.o
00:03:03 <adnap> dark: That's the first part.
00:03:17 <dark> the sole stylistic thing I noticed was (repeat fs) -> $ repeat fs
00:03:24 <dark> not sure this helps though
00:03:27 <adnap> let pairs = [([4],[1,2,3]),([4,5],[1,2,3]),([4,5,6],[1,2,3])]
00:03:31 <adnap> Argh
00:03:34 <dark> but anyway [1, 0, 2] means "at x=0, y=1; at x=1, y=0; at x=2, y=2"?
00:04:08 <adnap> dark: I'm not sure I understand.
00:04:42 <adnap> > let pairs = [([4],[1,2,3]),([4,5],[1,2,3]),([4,5,6],[1,2,3])] in map (\(hs', fs') -> zip (reverse hs') fs') pairs
00:04:43 <lambdabot>   [[(4,1)],[(5,1),(4,2)],[(6,1),(5,2),(4,3)]]
00:05:08 <adnap> Those are the sums that need to be computed.
00:05:15 <ddarius> adnap: You have map f . map g . map h . zip this is map (f . g . h) . zip = zipWith (curry (f . g . h))
00:05:51 <ddarius> Actually, only two maps.
00:06:19 <adnap> ddarius: Are you talking about in the last step?
00:07:21 <adnap> > :t zipWith . curry
00:07:22 <lambdabot>   <no location info>: parse error on input `:'
00:11:14 <bss03-AFK> @type zipWith . curry
00:11:15 <lambdabot> forall a b c. ((a, b) -> c) -> [a] -> [b] -> [c]
00:11:16 <ddarius> Applying these transformations to your code we get: g = \(hs', fs') -> zip (reverse hs') fs'; f = sum . map (uncurry (*)) and thus zipWith (sum . map (uncurry (*)) . (\(hs', fs') -> zip (reverse hs') fs')).  Applying the transformation to the composite: zipWith (\hs' fs' -> sum (zipWith (*) (reverse hs') fs')
00:11:21 <ddarius> Applying some @pl
00:11:32 <ddarius> @pl \a b -> sum (zipWith (*) (reverse a) b)
00:11:32 <lambdabot> (sum .) . zipWith (*) . reverse
00:12:29 <adnap> I'm so confused.
00:12:29 <ddarius> :t \hs fs -> zipWith ((sum .) . zipWith (*) . reverse) (tail (inits hs)) (repeat fs)
00:12:30 <lambdabot> forall a. (Num a) => [a] -> [a] -> [a]
00:12:49 <ddarius> @pl \hs fs -> zipWith ((sum .) . zipWith (*) . reverse) (tail (inits hs)) (repeat fs)
00:12:49 <lambdabot> (. repeat) . zipWith ((sum .) . zipWith (*) . reverse) . tail . inits
00:12:55 <copumpkin> lol
00:13:10 <adnap> That's not readable to you, is it?
00:13:24 <copumpkin> it's not too bad, but I wouldn't write that in my code
00:13:56 <ddarius> let conv = (. repeat) . zipWith ((sum .) . zipWith (*) . reverse) . tail . inits in conv [1,1,0,0,0,0] [1,1,0,0,0,0]
00:14:01 <ddarius> > let conv = (. repeat) . zipWith ((sum .) . zipWith (*) . reverse) . tail . inits in conv [1,1,0,0,0,0] [1,1,0,0,0,0]
00:14:02 <lambdabot>   [1,2,1,0,0,0]
00:14:05 <ddarius> Excellent.
00:14:14 <adnap> It's not correct in all cases though.
00:14:22 <adnap> > conv [1,2,3] [4]
00:14:22 <lambdabot>   Not in scope: `conv'
00:14:24 * copumpkin elects ddarius as the convolutionmaster of #haskell
00:14:42 <copumpkin> although it seems like you'd want to do it in n log n time
00:14:49 <ddarius> adnap: My code is formally derived from your code.  It does what your code does, bugs and all.
00:14:50 <copumpkin> I guess with lists that's tricky
00:14:56 <adnap> > let conv = (. repeat) . zipWith ((sum .) . zipWith (*) . reverse) . tail . inits in conv [1,2,3] [4]
00:14:57 <lambdabot>   [4,8,12]
00:15:04 <adnap> ddarius: Oh, wow.
00:15:16 <adnap> Mine doesn't do that.
00:15:24 <adnap> It just gives [4].
00:15:38 <lrnhskl> what about foldl1 (+) (map (\ (x,y) -> x * y) (zip a (reverse b)))
00:16:02 <lrnhskl> where a - first list and b - second list for convolution
00:16:05 <copumpkin> lrnhskl: why map on a zip? that's why he introduced zipWith ?
00:16:25 <copumpkin> that isn't really convolution though, it's "reverse dot product" :P
00:16:25 <adnap> > let conv = foldl1 (+) (map (\ (x,y) -> x * y) (zip a (reverse b))) in conv [1,2,3] [4]
00:16:26 <lambdabot>   Couldn't match expected type `[a]'
00:16:26 <lambdabot>         against inferred type `SimpleRef...
00:16:38 <ddarius> map (uncurry f) . zip = zipWith f
00:16:43 <adnap> > let conv a b = foldl1 (+) (map (\ (x,y) -> x * y) (zip a (reverse b))) in conv [1,2,3] [4]
00:16:44 <lambdabot>   4
00:16:56 <copumpkin> "reverse truncated dot product"
00:16:58 <copumpkin> how about that
00:17:05 <adnap> It's supposed to be [4,8,12].
00:17:15 * ddarius goes back to proving stuff in Twelf.
00:17:16 <adnap> I don't know how ddarius fixed my code by re-deriving it.
00:17:27 <copumpkin> ooh, twelf
00:18:01 <copumpkin> ten, elevent, twelf
00:18:47 <Nibble> is fmap just a functor generalisation of map?
00:18:53 <ddarius> Nibble: Yes.
00:19:02 <Nibble> I see
00:19:05 <Nibble> @src fmap
00:19:06 <lambdabot> Source not found. Wrong!  You cheating scum!
00:19:09 <Nibble> @src map
00:19:09 <lambdabot> map _ []     = []
00:19:09 <lambdabot> map f (x:xs) = f x : map f xs
00:19:16 <Nibble> That was... simple :P
00:19:42 <copumpkin> I wish clients would give up after a dozen excess flood disconnects
00:20:38 <tkahn6> any good articles on good monad design?
00:20:47 * ddarius needs to sprinkle his rules with eq-cat C C' -> ... so he doesn't have to spell these things out.
00:21:06 <tkahn6> there's a lot about what they are, but not many i've seen on how to create good useful ones
00:21:48 <adnap> Ah, I see.  In ddarius's function, the arguments were flipped from mine.
00:23:52 <copumpkin> tkahn6: most monads you would think of designing are combinations of existing ones
00:24:05 <tkahn6> yeah i'm figuring that out
00:24:06 <tkahn6> haha
00:24:32 <adnap> Convolution is commutative, right?
00:24:54 <roconnor> adnap: should be
00:25:02 <adnap> My function is not correct 'cause it's not commutative.
00:25:36 <adnap> I think there's probably a better way than flipping the arguments based on their sizes too.
00:26:14 <copumpkin> wow, http://en.wikipedia.org/wiki/Convolution_(computer_science), basically zip that produces a list of tuples of Maybes :)
00:26:23 <int80_h> @seen chrisdone
00:26:23 <preflex>  chrisdone was last seen on #haskell-blah 3 days, 11 hours, 48 minutes and 7 seconds ago, saying: http://fungi.yuggoth.org/vsp4s/
00:26:23 <lambdabot> Unknown command, try @list
00:26:35 <copumpkin> adnap: just use the fast algorith m:P
00:26:51 <int80_h> has anyone downloaded chris done's amelie?
00:27:58 <adnap> copumpkin: What's he fast algorithm?
00:28:25 <copumpkin> adnap: http://en.wikipedia.org/wiki/Convolution_theorem
00:28:34 <ddarius> adnap: Your function would be commutative on infinite lists.
00:28:47 <copumpkin> well, the algorithm being run an FFT, pointwise multiply, then inverse FFT
00:29:12 <copumpkin> you should use bi-infinite lists with zippers
00:29:29 <adnap> copumpkin: Man, that's way over my head.  I haven't learned about either of those things.
00:29:35 * ddarius thinks he found a way to get all the eq-cats at once.
00:29:58 <ddarius> The convolution theorem is -massively- important.
00:30:06 <copumpkin> adnap: ah, well pointwise multiply is just zipWith (*) :)
00:30:19 <adnap> I saw there's a new section in Learn You a Haskell for zippers.  I'll have to read it soon.
00:30:42 <copumpkin> should I ban FusionX?
00:30:49 <copumpkin> and redirect him to -ops, maybe
00:31:58 <int80_h> I vote ban
00:31:59 <dark> <copumpkin> I wish clients would give up after a dozen excess flood disconnects < they are supposed to have an exponentially decreasing delay. i think
00:31:59 <ddarius> copumpkin: Probably.
00:32:00 <adnap> copumpkin: Oh, so you're saying do a FFT and then a pointwise multiply.
00:32:09 <ddarius> adnap: And then an inverse FFT.
00:32:15 <adnap> ddarius: Right
00:32:15 <dark> increasing
00:32:42 --- mode: ChanServ set +o copumpkin
00:32:48 <adnap> Is FFT easy to implement?
00:33:03 --- mode: copumpkin set +b *!*FusionX@millie.kottnet.net$#haskell-ops
00:33:09 <adnap> I don't think it is.  I think it's a sub-matrix problem.
00:33:20 <copumpkin> mmorrow has a simple version up on hackage
00:33:22 <copumpkin> gotta run
00:33:25 --- mode: ChanServ set -o copumpkin
00:34:06 <ddarius> adnap: It's not terribly hard, but it is easy to get wrong.
00:35:25 <adnap> ddarius: What does that pure haskell fft on hackage only work on Complex Double?
00:35:32 <adnap> ddarius: the*
00:38:16 <ddarius> Cripes.  Is the problem really this simple?
00:40:34 <Veinor> dark: you mean increasing delay
00:42:48 <dark> yes..
00:47:12 <adnap> This is giving me an empty list: fft . map (mkPolar 1) $ [0..(2 * pi)]
00:48:00 <dark> how you defined fft?
00:48:00 <adnap> Shouldn't I get a negative and positive frequency?
00:48:06 <adnap> I didn't.
00:48:13 <adnap> I'm using the pure-fft package.
00:48:56 <dark> > [0..(2 * pi)]
00:48:57 <ddarius> > [0 .. 2*pi]
00:49:26 <adnap> Uh
00:49:28 <dark> strangely, it's [0.0,1.0,2.0,3.0,4.0,5.0,6.0] here
00:49:43 <adnap> Why is lambdabot not doing its job?
00:50:25 <adnap> Oh, XD
00:50:35 <adnap> > [0,0.1..2*pi]
00:50:55 <dark> o.o
00:51:06 <adnap> It's doing steps of 1.
00:51:52 <dark> I'm amazed that [0,1/pi .. 2*pi] actually works
00:52:10 <adnap> This works: fft . map (mkPolar 1) $ [0,0.1..2*pi]
00:54:25 <adnap> Shouldn't this be okay? convolve xs ys = ifft (zipWith (*) (fft xs) (fft ys))
00:57:58 <dark> is that code equivalent to ifft $ zipWith (*) $ fft xs $ fft ys?
00:59:04 <adnap> ddarius: Yeah, of course.
00:59:16 <dark> me?
01:00:02 <adnap> dark: Whoops
01:00:11 <adnap> dark: Actually, it's not equivalent.
01:00:16 <adnap> dark: I couldn't get it to work.
01:00:46 <adnap> dark: I think this does though: convolve xs ys = ifft $ zipWith (*) (fft xs) (fft ys)
01:01:08 <dark> f (id id) (id id) and f $ id id $ id id has the same type (for f a b = a b)
01:01:17 <dark> not a nice way for testing, but
01:01:42 <adnap> dark: $ changes the associativity of a sequence of functions, I think.
01:01:58 <dark> now I'm confused
01:02:16 <adnap> dark: I don't think it's always as simple as "wrap something in parenthesis".
01:02:57 <Nomad127> (newbie question) Good morning everyone, I have a question regarding parsers in Haskell. In spare time, I am reading "Programming in Haskell". In chapter 8 parsers are introduced. In the book, all the definitions to build parsers are given. However, the author says these definitions won't work in reality and provides a library file on his web site to do the same thing. That file uses some Monads (don't know yet what exactly this is but I gue
01:02:57 <Nomad127> is used for supporting impure functions). But I can't see why it should not be possible to build the described parsers with functions only, without this monad thing. Could anyone enlighten me please?
01:03:46 <dark> Nomad127, I think you can build a parser as a function. But, can you compose two parsers?
01:04:18 <dark> hmm, I think yes, you can compose two parsers (which are functions), and return a new parser that accepts either, or accepts one then the other..
01:05:01 <Nomad127> @dark: Do you mean this ">>=" operator?
01:05:03 <dark> Nomad127, is this library parsec?
01:05:26 <Nomad127> no, it is a library that the author wrote (I believe)
01:05:55 <dark> :t (>>=)
01:06:01 <Nomad127> http://www.cs.nott.ac.uk/~gmh/Parsing.lhs
01:06:03 <Nomad127> this one
01:06:08 <dark> (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
01:06:46 <dark> >>= is used to compose monads, but you wouldn't use this operator if your parser wasn't a monad
01:07:08 <Nomad127> ah, in the book >>= is defined as
01:07:22 <jesnor> someone good with type classes that can help with my code?
01:07:35 <Nomad127> p >>= f \inp -> case parse p inp of
01:07:39 <Nomad127> []->[]
01:07:53 <Nomad127> [(v, out)] -> parse ( f v ) out
01:07:57 <dark> Nomad127, I don't know haskell very well, but what I can say is that a monad is a regular type class. most monads seems to be pure (such as the list monad, etc). the sole exception seems to be the IO monad bound to the "main" variable
01:08:13 <dark> (but an IO monad seems to be pure in other contexts)
01:08:55 <Nomad127> hm, then the reason he uses Monads is probably something else than impurity.
01:10:25 <jesnor> here's the code if anyone wants to take a swing at it: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29900#a29900
01:10:31 <Nomad127> I was wondering if it is possible to use do notation without Monads.
01:10:40 <amontez> Nomad127: no
01:10:59 <dark> I think the do abstracts over >>=, so you just need to redefine your own >>=
01:11:02 <Nomad127> Amontez, any idea why?
01:11:12 <amontez> Monad is just a class for another common pattern that has a type, like Num, Monoid, Functor, etc.
01:11:53 <amontez> Nomad127: because do notation has well-defined semantics for being syntactic sugar for monads, see the Haskell 98 Report for more details
01:12:17 <Taejo> jesnor: what's the problem?
01:12:34 <GordonQuad> hello!
01:12:34 <Nomad127> Amontez: So there is more to do than just nesting function calls?
01:12:44 <GordonQuad> is there any clustering framework (like Apache Hadoop) for Haskell ?
01:12:56 <jesnor> Taejo: ghc complains:
01:12:58 <jesnor> flat.hs:14:12:
01:12:58 <jesnor>     No instance for (Flat t1 Int)
01:12:58 <jesnor>       arising from a use of `flat' at flat.hs:14:12-25
01:13:11 <Nomad127> all, thank you for your help. I will get the Haskell report. 
01:13:17 <dark> I'm at about the same level of newbie-ish than you.. I was trying to construct a list with the >>= operator but I couldn't. ._.
01:13:33 <tensorpudding> for lists, >>= is concatMap
01:13:34 <dark> my attempt was [1] >>= \x -> 1 : x
01:13:42 <amontez> return 1 :: Num t => [t]
01:13:45 <amontez> > return 1 :: Num t => [t]
01:13:46 <dark> concatMap (\x -> x : [1]) [1] works..
01:16:15 <dark> I still think that the do notation is a syntax sugar for >>=
01:16:46 <amontez> Nomad127: well, (>>=) is specifically about feeding a value into a function, but the way in which it does that is dependent upon the particular Monad instance
01:16:48 <dark> (and thus a syntax sugar for nesting calls to a function you can redefine)
01:17:02 <tensorpudding> do-notation is syntactic sugar for monads, which can be replaced by suitable >>= usages
01:17:14 <tensorpudding> depending on whether a line uses <- or not
01:17:56 <dark> so if I redefine >>=, it will work on the built-in >>= instead?
01:18:20 <Nomad127> dark, amontez: so there is a syntactic sugar do, for a syntactic sugar >>=, for chaining calls.
01:18:25 <tensorpudding> you can't redefine >>=
01:18:50 <Nomad127> maybe I just try to define my own >>= replacement with another name
01:18:54 <tensorpudding> i mean, you could avoid importing Monad, and create your own >>= with a different definition, but it would break things
01:19:05 <Nomad127> what would break?
01:19:17 <dark> I think his book did exactly that =)
01:19:19 <amontez> the `main' function
01:19:20 <tensorpudding> well, anything that used Monad at all
01:19:50 <Nomad127> maybe I just try and see where it breaks
01:19:56 <amontez> why?
01:20:18 <Nomad127> um... just to try it.
01:22:19 <dark> > [2, 3] >>= (\x -> return (1, x))
01:22:27 <Nomad127> ah, no, instead of >>= it should probably `chain` or the like
01:23:18 <tensorpudding> lambdabot has stepped out for a bit it seems
01:23:19 <dark> Nomad127, anyway, I think the reason he defined his parser as a monad is so that way one could use facilities that handled with monads
01:23:33 <dark> (such as do {}, and some modules)
01:23:57 <Nomad127> dark, indeed, it now seems that way. was driving me totally crazy.
01:24:09 <dark> I think he could defined it as a function
01:24:17 <dark> (and indeed it is)
01:25:20 <easy4> i have some code that prints a value just to make sure it fully evaluates without throwing errors.  what can i replace this with to do the same thing without printing anything?
01:25:40 <dark> String -> [(a,String)], is this a list of possible parsed, and the remaining text to be parsed?
01:25:51 <dark> possible parsed values
01:26:09 <dark> easy4, seq value rest-of-code?
01:28:16 <easy4> dark: i tried (seq x (return ())) at the end of main but that doesn't seem to work
01:32:56 <dark> seq a b is undefined if a is undefined/non-terminating, otherwise it's b
01:34:12 <easy4> so i need to use catch i guess?
01:34:34 <dark> is your x throwing some error?
01:34:45 <Cale> easy4: What is the type of the value, first of all?
01:34:55 <Cale> easy4: Is it a string?
01:35:24 <easy4> no, but it is an instance of show so it can be
01:35:36 <Cale> easy4: Well, what is it?
01:36:02 <easy4> it's a datatype i defined.  i don't care about the value.  i just want to print out any errors in evalutation
01:37:05 * ddarius managed to formally prove F X ~ Hom(Hom(-,X),F) given a Yoneda in terms of ends and the naturality formula.
01:37:08 <dark> I don't think you can pass seq a datatype
01:37:13 <Cale> It's important to note that seq only forces evaluation up to determining the top-level constructor
01:37:19 <Cale> You can pass seq a value of any type
01:37:25 <Cale> :t seq
01:37:36 <Cale> Oh, lambdabot needs restarting
01:38:05 <Cale> There we go :)
01:38:08 <Cale> :t seq
01:38:16 <lambdabot> forall a t. a -> t -> t
01:39:55 <easy4> well i suppose i could print to "/dev/null" to force evaluation...
01:39:56 <Cale> seq x y, when evaluated, will ensure that x is evaluated to weak head normal form (WHNF), which basically means up to determining what the top level data constructor is, before making the result of evaluating y available as its result.
01:40:11 <ManateeLazyCat> Cale: lambdabot is not running in interpreter? :)
01:40:23 <Cale> ManateeLazyCat: ?
01:40:33 <Cale> ManateeLazyCat: No, it's compiled
01:40:43 <ManateeLazyCat> Cale: Oh, lambdabot needs restarting 
01:40:48 <Cale> If you use seq on a list, this means that it basically just determines if the list is empty or not.
01:41:04 <Cale> You can do something recursive to force more evaluation
01:41:42 <Cale> Since you haven't told me exactly what your datatype is, I can't write that code for you :)
01:42:33 <easy4> cale: it's the full syntax of a programming language comprised of dozens of different datatypes
01:42:51 <Cale> ah, okay, that's rather a lot then :)
01:43:32 <Cale> Now, there might be calls to error in there and you want to check that the exceptions occur as early as possible
01:43:33 <Cale> ?
01:44:42 <Nomad127> dark, amontez, tensorpudding: I just tried the parser without monads. Looks ugly, since >>= became `chain` and "do" does not work. But in principle it seems to work. Thank you again for your time.
01:44:50 <Cale> If you're writing something like a compiler or interpreter, and you want to generate actual error messages, and not internal compiler failures, I recommend against using 'error' for that.
01:46:09 <easy4> i'm just playing around, not writing robust code
01:47:30 <Cale> You can use  (show t `using` rdeepseq) `seq` ...
01:47:42 <Cale> With the Control.Parallel.Strategies library
01:48:59 <Maxdamantus> What's a simpler way to express (let f n [] = [n]; f n (h:t) = f (succ n) t in f 0), or (map snd . zip [0..]) ?
01:49:03 <Cale> Or, to be less half-assed about it, you could write an instance of the NFData class defined in Control.DeepSeq.
01:49:10 <easy4> (appendFile "/dev/null" . show) seems to work, even though it's a bit hacky
01:49:17 <Maxdamantus> er
01:49:27 <Maxdamantus> Second thing was meant to be (map fst . zip [0..])
01:50:35 <Cale> Maxdamantus: parse error? :)
01:50:46 <Maxdamantus> Where?
01:51:08 <Maxdamantus> Ignore the first example, that's wrong.
01:51:10 <Cale> Are those supposed to be two entirely separate expressions?
01:51:23 <Maxdamantus> No, they were meant to do essentially the same thing.
01:51:57 <Maxdamantus> Want to get basically [0..length ls] but where it's not going to try iterating through the whole list to find its length beforehand
01:52:08 <Maxdamantus> length ls - 1 *
01:52:48 <Cale> The first function looks like f n xs = [n + length xs]
01:53:10 <Cale> zipWith const [0..]
01:53:23 <Cale> > zipWith const [0..] "hello, world"
01:53:24 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11]
01:53:48 <Cale> Is that what you're after? :)
01:53:54 <Maxdamantus> Hm yeah
01:54:21 <Maxdamantus> But that's still just zipping it with a list of numbers :d
01:54:30 <Cale> What's wrong with that?
01:54:39 <Maxdamantus> dw, was just wondering if there was something simpler without making another function
01:55:06 <Cale> zipWith const [0..] is pretty short given how uncommon that operation is :)
01:56:02 <Cale> It doesn't predetermine the length, so it'll work on infinite lists too
01:56:11 <Cale> > zipWith const [0..] [0..]
01:56:11 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
01:56:14 <Maxdamantus> Yeah.
01:56:35 <Cale> Of course, that's also true for map fst . zip [0..]
01:56:56 <Maxdamantus> or what the other one was meant to be
01:57:14 <Maxdamantus> (let f n [] = []; f n (h:t) = n : f (succ n) t in f 0)
02:00:52 <Maxdamantus> @pl flip const
02:00:52 <lambdabot> const id
02:00:59 <ddarius> @google "Scrapping your inefficient engine"
02:01:01 <lambdabot> http://www.cs.st-andrews.ac.uk/~eb/drafts/pe-edsl.pdf
02:01:01 <lambdabot> Title: Scrapping your Inefficient Engine: using Partial Evaluation to Improve Domain-Sp ...
02:01:45 <Maxdamantus> O_o
02:02:17 <Maxdamantus> @pl (let f n [] = []; f n (h:t) = n : f (succ n) t in f 0)
02:02:17 <lambdabot> (line 1, column 10):
02:02:17 <lambdabot> unexpected "["
02:02:17 <lambdabot> expecting pattern or "="
02:05:02 * ddarius needs to (re)read some of the papers behind OBJ.
02:05:05 <Maxdamantus> @pl zipWith const (iterate succ 0)
02:05:06 <lambdabot> zipWith const (iterate succ 0)
02:06:30 <cch> pl
02:06:54 <cch> @pl \x -> (,) (map fst x) (map snd x)
02:06:55 <lambdabot> ap ((,) . map fst) (map snd)
02:24:00 <jesnor> still no takers for my recursive flatten code? http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29900#a29900
02:24:23 <jesnor> btw, it's possible to implement it in Scala
02:37:58 <FunctorSalad> that (an engine) will make kmc's scrapped-boilerplate-robot-of-death even more powerful
02:43:22 <noobpup> hi does any one in here know anythig aboutVB?
02:44:14 <noobpup> gee maybe i shouldnt have said vb huh?
02:45:10 <Phyx-> vb?
02:45:20 <noobpup> visual basic
02:45:20 <Phyx-> wrong channel
02:45:26 <FunctorSalad> sort-of.
02:45:28 <noobpup> ummm help?
02:45:46 <mauke> noobpup: why did you come to this channel?
02:45:54 <noobpup> i kinda got on here by luck!
02:46:00 <mauke> unlikely
02:46:08 <dark> noobpup, tell your history then
02:46:26 <noobpup> need help with a assignment
02:46:27 * Phyx- turns the light on noobpup
02:46:37 <noobpup> and well to be honest im stumped
02:46:46 <mauke> noobpup: why this channel?
02:46:47 <noobpup> ok long story short 
02:46:48 <dark> noobpup, are you a high school student?
02:46:54 <noobpup> i need to build a report builder
02:46:55 <FunctorSalad> Phyx-: a harsh 5000K light?
02:47:22 <Phyx-> FunctorSalad: nah, a friend borrows that to suntan :)
02:47:27 <noobpup> hah i wish no uni
02:47:35 <noobpup> first year intro to vb
02:47:38 <mauke> noobpup: why this channel?
02:47:42 <dark> noobpup, I don't know what is a report builder
02:48:15 <dark> noobpup, but are you actually saying that at your university, you are seeing visual basic as your introductory language?
02:48:37 <noobpup> mauke cause i didnt know there was a specific channel for vb 
02:48:46 <mauke> noobpup: that doesn't answer my question
02:48:51 <mauke> why didn't you join #fjdksajf?
02:49:00 <noobpup> yea
02:49:44 <kamatsu_> question
02:49:57 <noobpup> AGAIN mauke I GOT ON HERE BY LUCK its my first time 
02:50:02 <mauke> what do you mean by "luck"?
02:50:08 <mauke> you had to do something
02:50:14 <Phyx-> noobpup: no need to yell, lol
02:50:31 <roconnor> @yow
02:50:32 <noobpup> as in i googled and bam here i am !
02:50:37 <dark> I feel like helping you, but only if you say what is a report builder. (I must say that it might be a bit too much offtopic for #haskell)
02:50:49 <mauke> noobpup: no, google does not connect to irc
02:50:59 <kamatsu_> does the haskell IO system busy loop waiting on input or something?
02:51:04 <mauke> kamatsu_: no
02:51:06 <dark> mauke, there is such a thing like web interfaces to irc..
02:51:22 <kamatsu_> cos running simon marlow's hws makes it use all of my CPU
02:51:28 <mauke> dark: those usually show up in the hostname
02:51:29 <kamatsu_> just while it's waiting for connections
02:51:33 <FunctorSalad> kamatsu_: it uses 'select' on linux (that's as far as my knowledge goes)
02:51:40 <noobpup> a report builder pretty much using vb to query MS access in sql and then make it show up as a html page!
02:51:42 <FunctorSalad> ah, network
02:52:09 <mauke> I just want to understand how people end up here
02:52:22 <mauke> particularly those with java, php and vb questions
02:52:31 <kamatsu_> so, seeing as TacticalGrace gave me an assignment involving STMifying hws, this  is kinda important.
02:52:36 <dark> mauke, maybe saw in a blog that this is a channel for asking java, php and vb questions?
02:52:38 <mauke> "i googled and bam here i am" tells me nothing
02:52:47 <mauke> dark: then I'd like to know the url of that blog
02:53:21 <noobpup> ffs mauke how bout you offer a solution or better yet nothing at all since obviously you've been here before 
02:53:25 <noobpup> geez!
02:53:40 <mauke> :-(
02:53:54 <mauke> why can you ask questions but not me?
02:54:11 <noobpup> well i need help and your ask a trivial question
02:54:19 <noobpup> now im sorry didnt mean to be rude!
02:54:36 <noobpup> i am already fustrated with this damn assignment
02:54:43 <mauke> it just makes no sense to me because your question has nothing to do with haskell, so why ask in #haskell?
02:54:50 <noobpup> so how do i join the vb channel?
02:54:51 <osfameron> then ask in the right chan
02:55:04 <Phyx-> noobpup: type /j #vb
02:55:06 <kamatsu_> anyone got any ideas about hws raping my CPU?
02:55:06 <dark> noobpup, I don't this there is a visual basic channel at freenode
02:55:08 <kamatsu_> my CPU is dying here
02:55:19 <mauke> and there are plenty channels that have nothing to do with vb, such as #perl, ##c, or ##python
02:55:25 <mauke> why join #haskell?
02:55:27 <Phyx-> dark: there's a very small one, but he would have better luck than here
02:56:21 <noobpup> i didnt mauke its the first page that comes up when this thing loads!
02:56:29 <dark> noobpup, I don't know visual basic, or how to interface to microsoft access. I suppose it wants you to run it at IIS? the logic itself from your assignment would translate to a few lines (or at least it does in both php and ruby)
02:56:51 <dark> noobpup, "this thing"?
02:57:00 <mauke> noobpup: what thing?
02:57:33 <Phyx-> noobpup: anyway, go on msdn, lookup ADO.NET and ODBC, those should get you well on your way
02:58:00 <noobpup> thank you  phyx!!
02:58:03 <noobpup> and dark
02:58:12 <noobpup> btw how do i chang channles?
02:58:22 <Phyx-> with msdn i mean http://msdn.microsoft.com
02:58:23 <mauke> depends on your client
02:58:34 <ManateeLazyCat> noobpup: Read documentation of your irc client.
02:58:41 <mauke> usually you /join #somenewchannel (and /part the old one)
02:59:01 <dark> it's a java applet
02:59:07 <noobpup> yup java
02:59:13 <dark> (/ctcp noobpup version)
02:59:35 <mauke> but it doesn't tell me its url, grr
02:59:37 <dark> so at least you actually know he is a webchat user mauke :)
02:59:59 <dark> noobpup, what's the url of the google entry that made you join here?
03:00:21 <noobpup> http://gogloom.com/client2/index2?mainCHAT=1&network=FreeNode&channel=%23haskell
03:01:23 <kamatsu_> i feel like leaving an angry message to simon marlow, but i won't because he writes my garbage collector.
03:01:32 <kamatsu_> the world would be very unpleasant if garbage were not collected.
03:01:32 <dark> "and what do you searc.."
03:01:52 <dark> kamatsu_, :)
03:01:56 <ManateeLazyCat> Investigation : What's your favourite IRC font? I'm developing IRC client.....
03:02:07 <kamatsu_> Envy Code R
03:02:08 <dark> ManateeIrcClient, proportional!
03:02:14 <kamatsu_> but you should let users decide
03:02:19 <Starfire> Inconsolata and Consolas.
03:02:36 <ManateeLazyCat> Thanks all. :)
03:02:39 <Phyx-> *what_ever_irssi_default_is
03:02:40 <Phyx-> lol
03:02:44 <Phyx-> actually. what is it...
03:03:36 <Phyx-> think that's in the .theme file
03:03:37 <dark> ManateeIrcClient, dejavu sans, actually. [ I used to love window's fixedsys during my long time using mirc, and I love dejavu sans mono, but proportional is just easier to read.. ]
03:03:44 <ManateeLazyCat> Haskell thread is fastest irc rounter I've ever seen.
03:03:55 <Phyx-> anyway, my vote is for Consolas
03:04:08 <Nibble> ManateeLazyCat: Oh btw, IIRC you were working on an editor or something
03:04:15 <dark> what do you mean?
03:04:22 <ManateeLazyCat> Nibble: http://www.flickr.com/photos/48809572@N02/
03:04:23 <Nibble> and you said you need to wait for gtk2hs release or something
03:04:38 <Nibble> Has it been released yet?
03:04:44 <ManateeLazyCat> Nibble: NO.
03:04:59 <ManateeLazyCat> Nibble: Some raw filepath bug's still in test.
03:05:04 <Nibble> ok
03:05:15 <ManateeLazyCat> Nibble: But lucky, most patches have push to gtk2hs darcs.
03:05:54 <ManateeLazyCat> Nibble: I will fix documentation and bugs after i release gtk-0.12.0, then i release first review version, let other peo play it. :)
03:06:07 <ManateeLazyCat> s/peo/people
03:06:59 <ManateeLazyCat> dark: Irc router is my haskell multi-threads backend for my irc client.
03:07:40 <ManateeLazyCat> dark: Receive/send IRC message between IRC server and multiple IRC buffer, simple is like router transfer IRC message.
03:08:20 <dark> and you say 'fastest' in relation to what? some C implementation?
03:08:44 <ManateeLazyCat> dark: The speed receive message from IRC message.
03:08:57 <dark> ManateeLazyCat, what's this program you took screenshots at flickr?
03:09:10 <dark> some public repository / webpage?
03:09:11 <ManateeLazyCat> dark: Because haskell use lightweight thread, i can receive many server data concurrently, and damn fast. 
03:09:25 <FunctorSalad> ManateeLazyCat: another vote for DejaVu Sans (not mono) ... it's boring but the most readable I found
03:09:26 <ManateeLazyCat> dark: http://www.flickr.com/photos/48809572@N02/
03:09:34 <FunctorSalad> especially bright-on-darkness
03:09:40 <ManateeLazyCat> FunctorSalad: Thanks for your suggestion. :)
03:10:11 <ManateeLazyCat> FunctorSalad: I will compare those fontest, of course best way is add customize option let user choose font they like. :)
03:10:23 <ManateeLazyCat> s/fontest/fonts
03:10:48 <FunctorSalad> or do it like some programs; expect them to enter a X font specification </sarcasm>
03:10:48 <dark> I really love the default xchat setup (black on gray, nicks aligned on a bar, colored nicks), plus some proportional font
03:11:02 <FunctorSalad> (you know, the ones with the 50 asterisks)
03:11:03 <ManateeLazyCat> dark: https://patch-tag.com/r/AndyStewart that beginning with manatee-*
03:11:16 <ManateeLazyCat> dark: You need download darcs gtk2hs code to compile it.
03:11:27 <ManateeLazyCat> dark: Any other depend package can found on hackage.
03:11:44 <ManateeLazyCat> dark: I will develop color nick very soon.
03:11:56 <ManateeLazyCat> dark: Base on Nick's MD5 value and background color.
03:12:31 * ManateeLazyCat My irc client is much fast than ERC (irc client in Emacs)
03:12:42 <ManateeLazyCat> Because haskell's lightweight thread.
03:13:00 <dark> in fact I would like to have some other things at xchat (such as, for very large nicks, substitute some part of the nick by a clickable unicode "..." that would expand to the entire nick
03:13:17 <dark> but, is ERC a good standard to compare yourself?
03:13:30 <ManateeLazyCat> dark: Have you use ERC?
03:13:44 <dark> yes, but it's implemented in emacs lisp
03:14:07 <ManateeLazyCat> dark: Yes, my irc client like ERC, but i will add some cool feature in it.
03:14:23 <ManateeLazyCat> dark: Like multiple language discuss.
03:14:50 <ManateeLazyCat> dark: Write Chinese and translate with Google then send to channel.....
03:15:08 <dark> I like some ERC features (such as the ability to break messages at some column, and indent it further)
03:15:23 <ManateeLazyCat> dark: Easy to implement.
03:15:46 <ManateeLazyCat> dark: Infact is wrap mode with given column .
03:16:15 <dark> ManateeIrcClient, hmm. it would be better to design some general extensibility mechanism then. (xchat has one, but at least the perl interface is a bit awkward)
03:16:30 <ManateeLazyCat> dark: I use hot-swapping
03:16:38 <dark> what?
03:16:40 * hackagebot BNFC 2.4.1.1 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.4.1.1 (MarkusForsberg)
03:16:46 <ManateeLazyCat> dark: Hot-swapping like Emacs.
03:16:57 <ManateeLazyCat> dark: Fix-and-Run in runtime.
03:17:07 <dark> writing haskell code?
03:17:10 <ManateeLazyCat> dark: Yes.
03:17:18 <dark> interesting :)
03:17:26 <ManateeLazyCat> dark: Write itself in runtime, and update itself in runtime.
03:17:56 <ManateeLazyCat> dark: IMO, any need other language to extend is *poor* design, and not power enough.
03:18:01 <dark> can it update arbitrary data structures?
03:18:28 <ManateeLazyCat> @hoogle pdynload
03:18:39 <ManateeLazyCat> dark: Look above, my dynamic link library.
03:18:45 <ManateeLazyCat> @hackage pdynload
03:18:57 <ManateeLazyCat> Where is lambdabot?
03:19:28 <dark> it's crashing often, as it seems
03:19:48 <ManateeLazyCat> dark: http://hackage.haskell.org/package/pdynload-0.0.3
03:20:10 <dark> is it like ocaml's Dynload?
03:20:39 <ManateeLazyCat> dark: Update your library in cabal/ghc database, then use pdynload dynamic link code in runtime.
03:21:34 <ManateeLazyCat> dark: BTW, ManateeIrcClient is my irc bot. :)
03:21:54 <ManateeLazyCat> dark: He won't talk to you now. :)
03:25:03 <ManateeLazyCat> brb
03:28:55 <kamatsu_> i've tried it on 4 machines now, running 2 different operating systems and 3 different architectures, and hws rapes my CPU in all cases
03:29:12 <kamatsu_> why is the haskell I/O manager doing this?
03:31:09 <dark> hws?
03:31:13 <kamatsu_> haskell web server
03:31:20 <kamatsu_> it's a simple web server written by simon marlow
03:31:31 <kamatsu_> it appears to be working but uses up all my CPU as soon as it starts
03:31:39 <dark> maybe it's not haskell i/o manager
03:32:02 <kamatsu_> it almost certainly is, because the entire server is blocked waiting for connections while the usage occurs.
03:32:15 <SubStack> thread scheduling sucks
03:32:30 <dark> look at ManateeIrcClient, he is considering his i/o router to be "fastest"
03:32:33 <SubStack> I had some really annoying issues with it for my underwater rov controller
03:32:40 <kamatsu_> the thing is i haven't even started any threads.
03:32:44 <kamatsu_> not yet
03:32:51 <kamatsu_> and it's using 100% CPU while waiting on the socket
03:32:59 <SubStack> odd!
03:33:35 <kamatsu> indeed
03:33:36 <dark> kamatsu, how do you tell it's "waiting on the socket"? you straced it?
03:33:50 <kamatsu> dark: simple printf debugging
03:34:05 <kamatsu> it prints right up to my "accept" call and then sits there using all my CPU
03:34:17 <kamatsu> while it's using all my CPU i can still use the webserver okay
03:34:23 <kamatsu> it's just using up all my CPU and i'd like to know why
03:34:23 <objorn> Is there anything similar to python's NLTK for Haskell?
03:35:27 <kamatsu> looking at it on a mac, it seems to be making thousands of unix system calls constantly while this is happening
03:35:33 <kamatsu> i'm not sure what yet, will answer shortly
03:36:24 <dark> kamatsu, I think it's doing a non-blocking i/o, without some appropriate sleep()
03:36:39 <kamatsu> any reason why?
03:36:51 <kamatsu> afaik this is just haskell's standard network library
03:36:54 <dark> no
03:36:56 <kamatsu> it didn't do that afaik
03:38:17 <dark> you can see if this is the case by running strace or the mac os x equivalent (look for O_NONBLOCK? i think)
03:38:51 <kamatsu> okay, i'll give it a go
03:42:09 <kamatsu> ah
03:42:15 <kamatsu> it was constantly trying to write to the log file and failing.
03:42:20 <kamatsu> thank you strace!
03:43:57 <Maxdamantus> @pl \a -> [b | b <- a]
03:45:40 <benmachine> Maxdamantus: id?
03:48:24 <Maxdamantus> Was expecting the bot to be here.
03:48:31 <Maxdamantus> It gets something that seems strange
03:48:42 <Maxdamantus> 22:42:45 < lambdabot> return . ((a | a) <-)
03:48:58 <Maxdamantus> er, that's with the a and b interchanged.
03:49:55 * hackagebot xmms2-client 0.0.3.8 - An XMMS2 client library.  http://hackage.haskell.org/package/xmms2-client-0.0.3.8 (OlegBelozeorov)
03:49:58 <benmachine> oh right
03:50:13 <benmachine> yes, because @pl doesn't know that <- and | are syntax
03:50:25 <Maxdamantus> Oh.
03:50:25 <benmachine> uses them as normal operators
03:50:55 * hackagebot xmms2-client-glib 0.0.3.8 - An XMMS2 client library  GLib integration.  http://hackage.haskell.org/package/xmms2-client-glib-0.0.3.8 (OlegBelozeorov)
03:59:58 * hackagebot asn1-data 0.2 - ASN1 data reader/writer in RAW/BER/DER/CER forms  http://hackage.haskell.org/package/asn1-data-0.2 (VincentHanquez)
04:00:00 * hackagebot vision 0.0.2.2 - An XMMS2 client.  http://hackage.haskell.org/package/vision-0.0.2.2 (OlegBelozeorov)
04:04:34 <Xaphiosis> vim users: is there any indentation better/newer than http://www.vim.org/scripts/script.php?script_id=1968 ?
04:05:10 <Xaphiosis> (that's from late 2007, and has some issues like doing indentation within comments)
04:06:03 <Nibble> Xaphiosis: for haskell?
04:06:09 <Nibble> I use haskellmode for vim
04:06:14 <Nibble> or something like that, it seems to be working fine
04:06:33 <Xaphiosis> ah, that does indentation? I grepped the vimball and it didn't seem to mention in
04:07:14 <Xaphiosis> oki, if it does, I shall try it :)
04:07:41 <Nibble> Xaphiosis: I am not sure it does
04:07:55 <Nibble> but it seems to be indenting my code at least.
04:08:01 <Nibble> Might just be me tho
04:08:09 <Nibble> It doesn't dare to do anything else
04:08:12 <Xaphiosis> when you type: "moo x y z = do" and hit enter, do you get an indentation?
04:08:58 <Xaphiosis> and when within {- -} comments, when you type "if I do this thing where" and hit enter, does it indent there?
04:09:24 <Xaphiosis> if you get both these behaviours, then it looks like what I want
04:09:25 <Nibble> Xaphiosis: I don't get indention
04:09:30 <Nibble> that was bad
04:09:35 <Nibble> that is*
04:09:37 <Nibble> :(
04:09:57 <Xaphiosis> *confused*
04:10:33 <benmachine> I don't like automatic indentation
04:10:36 <benmachine> it tends to confuse me
04:10:45 <benmachine> just press space :P
04:11:07 <Xaphiosis> for people with your approach, there is always notepad :P
04:12:24 <Xaphiosis> but by the looks of it, there doesn't seem to be anything newer than that script, so I will just have to man up and fix it
04:12:38 <Nibble> Xaphiosis: try
04:12:49 <Nibble> > reverse "haskell"
04:12:56 <Nibble> uh hu
04:13:08 <Nibble> > reverse "haskel"
04:13:13 <Nibble> wth
04:13:22 <Nibble> isn't lambdabot here?
04:14:32 <Xaphiosis> appears to be absent
04:14:40 <ManateeLazyCat> Nibble: Looks crash.
04:14:55 <Nibble> Xaphiosis: try leksah
04:15:03 <benmachine> 10:25:35 -!- lambdabot [~lambdabot@li85-105.members.linode.com] has quit  [Ping timeout: 276 seconds]
04:15:09 <ManateeLazyCat> Nibble: Or shutdown by administer
04:15:20 <Nibble> ManateeLazyCat: okay
04:15:26 <c_wraith> Eh, a shutdown doesn't usually result in a timeout
04:15:34 <benmachine> Cale: lambdabot died again :(
04:15:37 <c_wraith> but \bot doesn't reconnect after network issues
04:15:45 <ManateeLazyCat> benmachine: Again? :)
04:15:53 <benmachine> ManateeLazyCat: yeah
04:15:54 <Xaphiosis> Nibble: that doesn't help me... I'm a vim user and wish to remain so for the forseeable future
04:16:13 <benmachine> second time this morning according to my log
04:16:33 <Xaphiosis> never mind
04:16:36 <fserb> Hey guys. I'm having some regex problem. Using Text.Regex.Posix (or PCRE), I'm trying to do: "foo foo foo" =~ "foo" :: [String] and getting an error saying there's no instance for that. Since this shows up in every haskell regex tutorial, I wonder what I'm doing wrong.
04:16:38 <ManateeLazyCat> benmachine: Any trouble with lambdabot?
04:16:40 <Nibble> Xaphiosis: well, the only real solution then is to write your own.
04:17:07 <ManateeLazyCat> fserb: Use : "foo foo foo" =~ "foo" (String,String,String)
04:17:07 <Nibble> I have been thinking about making an editor like vim but in haskell, would be pure awesomeness
04:17:08 <benmachine> ManateeLazyCat: lambdabot's never been perfectly reliable, the code is old and mostly written by people who've forgotten how it works
04:17:29 <benmachine> fserb: sure it's not [[String]]?
04:18:04 <ManateeLazyCat> fserb: http://www.serpentine.com/blog/2007/02/27/a-haskell-regular-expression-tutorial/
04:18:29 <Xaphiosis> writing a text editor is a desire that in my experience traditionally appears towards the end of an undergrad degree
04:18:35 <sts193> Has anyone tried Haskell for web development?
04:18:40 <Xaphiosis> happened to me as well :)
04:19:05 <fserb> ManateeLazyCat, that doesn't do quite what I expect. And the [String] example is from this tutorial :/
04:19:12 <fserb> benmachine, that works! :)
04:19:14 <Nibble> sts193: sure, there are lots of frameworks out there
04:19:19 <benmachine> sts193: lots of people use haskell for web dev, unfortunately I'm not one of them
04:19:30 <ManateeLazyCat> fserb: Hehe. :)
04:19:36 <ManateeLazyCat> benmachine: Like benmachine said.
04:19:40 <benmachine> fserb: lots of things do, the regex libraries in Haskell are nightmarishly polymorphic :)
04:19:51 <fserb> benmachine, I wonder why all tutorials around only show [String] instead of [[String]] which actually makes more sen.
04:20:17 <fserb> benmachine, ManateeLazyCat: thanks a bunch! :)
04:20:57 <sts193> Well, I'm sort of a beginner and Haskell was the language I enjoyed most that I've tried out, I'm just a bit scared that I won't be able to make much with it.
04:21:03 <benmachine> fserb: if you have Text.Regex.Posix loaded in ghci, try :i RegexContext to give you an idea of just how many ways there are to get you an answer
04:22:02 <benmachine> sts193: people have made all sorts of things with haskell, although it's probably still not as mature as something like python or java library-wise
04:22:02 * ManateeLazyCat I miss lambdabot.......
04:22:30 <fserb> benmachine: cool. :)
04:22:32 <benmachine> sts193: the new hackage in development will run on haskell code, I believe
04:22:54 <ManateeLazyCat> benmachine: What's the cool features in new hackage?
04:23:23 <sts193> benmachine: Are there good tutorials/examples/books for haskell? Or am I on my own as a noob? 
04:23:25 <benmachine> ManateeLazyCat: I don't remember them all, I'll try to find it for you
04:23:33 <ManateeLazyCat> benmachine: Thanks! :)
04:23:40 <benmachine> sts193: there are tutorials that I think are good, but opinions differ :)
04:23:48 <benmachine> sts193: and this channel here tends to be very good
04:24:01 <benmachine> I've been in a few programming help channels and this is by far the friendliest
04:24:08 <ManateeLazyCat> sts193: Book, you can see "Real World Haskell"
04:24:10 <benmachine> so I'd say you're never completely on your own learning haskell
04:24:21 <benmachine> I like learnyouahaskell.com
04:24:33 <ManateeLazyCat> sts193: There are bunch demo programs if you like GUI example. :)
04:24:34 <sts193> That's great, so I don't have to be an expert programmer to become a "good" Haskeller?
04:24:37 <Xaphiosis> this interests me too... what are some reasonable web frameworks for haskell? there are quite a lot of experimental ones
04:25:06 * hackagebot xmms2-client 0.0.3.9 - An XMMS2 client library.  http://hackage.haskell.org/package/xmms2-client-0.0.3.9 (OlegBelozeorov)
04:25:08 * hackagebot xmms2-client-glib 0.0.3.9 - An XMMS2 client library  GLib integration.  http://hackage.haskell.org/package/xmms2-client-glib-0.0.3.9 (OlegBelozeorov)
04:25:29 * ManateeLazyCat Hehe, i just try xmms2, build failed...... 
04:25:35 * ManateeLazyCat Try again....
04:25:42 <Twey> Xaphiosis: The work-horse (ha, ha) of the Haskell Web world is currently happstack, but it's terrifying :þ
04:26:07 <Xaphiosis> terrifying in which way?
04:26:16 <benmachine> sts193: you might find yourself becoming one by accident!
04:26:49 <ManateeLazyCat> sts193: Haskell is a language you worth to learn!!!
04:27:02 <sts193> benmachine: Is it hard to pick up other languages after getting used to Haskell?
04:27:21 <Twey> Xaphiosis: Try it and see :þ
04:27:33 <benmachine> sts193: I don't know, after I learnt haskell I never wanted to do anything else :P
04:27:34 <Xaphiosis> Twey: well played sir
04:27:45 <benmachine> sts193: I guess agda doesn't count >_>
04:27:52 <benmachine> ManateeLazyCat: new hackage is being tested at http://sparky.haskell.org:8080/
04:27:53 <ManateeLazyCat> sts193: Haskell don't like most OOP language, but i don't think it's a problem to learn other language.
04:28:07 <ManateeLazyCat> benmachine: Cool, try it....
04:28:20 <Xaphiosis> haskell is really nice when it comes to formulating thought
04:28:22 <Twey> Xaphiosis: There are other workable solutions (depending on what you want to do) like Turbinado and Snap
04:28:30 <ManateeLazyCat> sts193: Haskell is generate language that can do everything....
04:28:43 <ManateeLazyCat> sts193: You just two language : C and Haskell....
04:28:53 <ManateeLazyCat> s/just/just need
04:29:08 * hackagebot BNFC 2.4.1.2 - A compiler front-end generator.  http://hackage.haskell.org/package/BNFC-2.4.1.2 (MarkusForsberg)
04:29:21 <Xaphiosis> right, happstack, turbinado, snap... any vague comparisons out there? all software naturally sucks, but always with different tradeoffs
04:29:40 <sts193> Nice, I'm going to dive right in then.
04:29:48 <Xaphiosis> if I try all 3, I'll know by january which one I like :P
04:30:47 <ManateeLazyCat> sts193: And we have hostest channel : #haskell will help you any problem about Haskell. Many haskell expert live here. :)
04:31:07 <Twey> Xaphiosis: happstack is stable and powerful, but *huge* and very complicated.  Turbinado is meant to be a fairly direct clone of stuff like Ruby on Rails.  Snap is nice and very fast, but still in a rather early stage of development, and lacks some features (like file uploads).
04:31:33 <Xaphiosis> sts193: I completely agree. I came here with the most idiotic questions the other night and people actually helped me out a great deal
04:32:06 <sts193> That's great, I'm always worried about my dumb questions.
04:32:08 * hackagebot vision 0.0.2.3 - An XMMS2 client.  http://hackage.haskell.org/package/vision-0.0.2.3 (OlegBelozeorov)
04:32:21 <Twey> Xaphiosis: Horse looks cool too, but I'm not that familiar with it.
04:33:17 <Xaphiosis> Twey: well seeing as I prefer minimalistic stuff like web.py to huge stuff like django, snap sounds like it might be cool to play with
04:33:43 <Xaphiosis> Twey: thank you for that summary-of-ideas-behind
04:34:04 <Twey> Xaphiosis: It has its own IRC channel at #snapframework.
04:34:38 <benmachine> I find that how stupid people think their questions are is only very loosely correlated with how stupid they actually are
04:35:07 <Xaphiosis> benmachine: people who worry about whether their questions are stupid usually indicate some desire to learn :)
04:35:34 <Xaphiosis> well, that or low self-esteem
04:35:39 <Xaphiosis> I'm probably a bit of both
04:36:56 <sts193> Are there any online communities centered around Haskell?
04:37:04 <Twey> Uh, hello
04:37:16 <hpc> hi
04:37:23 <sts193> Other than #Haskell :D
04:37:26 <Nibble> sts193: not really
04:37:28 <ManateeLazyCat> sts193: HaskellWiki
04:37:30 <Twey> #haskell-blah :þ
04:37:30 <Nibble> sts193: go and create one.
04:38:02 <hpc> there are communities for functional programming in general too
04:38:06 <Xaphiosis> sts193: haskell still doesn't have a lot of users, so there's not much need to split the community
04:38:41 <empt> benmachine: I like learnyouahaskell.com too
04:39:13 <sts193> gotcha
04:39:54 <Nibble> Xaphiosis: well
04:39:56 <Nibble> a lot of users
04:40:01 <Nibble> how many are there in this channel?
04:40:06 <Nibble> 627
04:40:24 <Nibble> And I would imagine there are quite a few more than that
04:40:55 <Xaphiosis> and yet we can have a quiet, civil conversation... have you been on #php?
04:41:04 <Nibble> Xaphiosis: nope
04:41:14 <Nibble> Xaphiosis: less users there :P
04:41:14 <hpc> i would sooner visit #perl
04:41:30 <Xaphiosis> haha, #php is like a deluge of questions
04:41:49 <dark> what is a deluge?
04:41:49 <Xaphiosis> back when I was into it, I sat there for a few hours answering people's questions and got a job out of it
04:41:58 <burp> I can also guess the kind of questions there ;)
04:42:02 <dark> some bit torrent client of questions?
04:42:03 <Twey> The *same* questions
04:42:06 <Twey> Over and over again
04:42:07 <Nibble> Xaphiosis: got a job because you answered questions?
04:42:11 <Nibble> cool
04:42:13 <Twey> Yeah
04:42:22 <Xaphiosis> deluge: means something like a strong downpour (e.g. rain)
04:42:27 <Twey> In the web channels, if you ignore someone long enough they start throwing money at you
04:42:59 <Xaphiosis> Twey: or abusing you
04:43:11 <Xaphiosis> that's why I was so pleasantly surprised by this channel
04:43:18 <Twey> Yeah, it's a toss-up really
04:43:26 <empt> #Python often enjoys >800 and here 628 quite a lot :)
04:44:04 <sts193> Yeah, I was also surprised by the number of people when I got here.
04:44:07 <Xaphiosis> I heard you guys were friendly, but the response I got was ... well, it was of the friendly grandmother come-in-I'll-light-a-fire-and-cook-you-something variety
04:44:37 <hpc> "welcome to my gingerbread house"?
04:44:44 <benmachine> hpc: that's what I thought o_o
04:44:58 <benmachine> #python: I'll-light-a-fire-and-cook-you
04:45:25 <Twey> Heheh
04:45:28 <empt> I have just started learning this language from a Smalltalk background and WOW :)
04:45:29 <Xaphiosis> oh, come now, before that meme could be exploited by the gingerbread house lure, it had to have had developed first
04:45:31 <Twey> #haskell: once you come in, you can never leave
04:45:50 <Xaphiosis> but yeah, it is a good lure :)
04:46:01 <dark> haskell will be the next java
04:46:04 <hpc> Twey: i always wanted that song to become a doctor who episode
04:46:05 <Twey> I've been here about a year now
04:46:07 <Twey> Help me
04:46:15 <Twey> hpc: What song?
04:46:25 <hpc> hotel california
04:46:31 <Twey> I don't know it
04:46:34 <Twey> Oh wait
04:46:35 <hpc> i thought you were referencing it
04:46:37 <Twey> Bob Marley?
04:46:39 <Twey> No, I wasn't
04:46:43 <hpc> the eagles
04:46:47 <Twey> Oh, then no :þ
04:46:48 <Nibble> dark: haha
04:46:50 <Nibble> really?
04:46:52 <Nibble> :P
04:46:53 <hpc> check it out; it's amazing
04:47:21 <dark> it's already bigger than java
04:47:25 <dark> than #java i mean
04:47:29 <Nibble> dark: oh
04:47:40 <Nibble> dark: it is bigger than #php and #perl too
04:48:07 <dark> and #c
04:48:19 <dark> soon linux will be rewritten in haskell
04:48:34 <Nibble> dark: And soon GNU/Hurd will be finished
04:48:35 <empt> it's like #jQuery
04:48:38 <Ke> rather build something on L4
04:48:42 <Xaphiosis> well, channel sizes are not necessarily a sign of popularity in general, only amongst people who leave their machines to idle on channels
04:48:47 <Nibble> and Duke Nukem forever will be co-released with GNU/Hurd
04:48:52 <empt> bigger than #Ruby 
04:49:29 <hpc> and it will only take 20 years to make; two less than tf2 :P
04:49:31 <empt> yes, Xaphiosis
04:49:51 <dark> Nibble, I guess both haskell linux and duke nukem forever will be out before gnu/hurd ( http://en.wikipedia.org/wiki/Duke_Nukem_Forever )
04:49:59 <ManateeLazyCat> channel size is no sense, hackage package size is......
04:50:16 <sts193> I think the development of cool apps and libraries would attract people.
04:50:43 <ManateeLazyCat> sts193: How about http://www.flickr.com/photos/48809572@N02/ pure haskell.....
04:50:47 <sts193> It might be dumb, but the first thing I search for is 'what has been done in <language here>'
04:51:09 <Xaphiosis> haskell: what have you done for me lately?
04:51:11 <Nibble> XMonad is one piece of beuty
04:51:34 <empt> There're less apps in Smalltalk ;) but I love it
04:51:36 <dark> I think a killer framework - for something widely wanted - would do wonders
04:51:50 <dark> i know of a killer parsing framework, but who wants to parse
04:52:08 <empt> so if there is still a lot of people using something to keep it alive then it's ok for me
04:52:18 <sts193> dark: lol
04:52:30 <Xaphiosis> well... the LLVM & GHC thing might mean we could compile to ARM chips
04:52:39 <da-x> how come Text.Show.ByteString doesn't have a Show instance for ByteString itself? seems counter-productive...
04:52:57 <Xaphiosis> and then the whole mobile area opens up... even my ebook reader runs ARM-based linux
04:53:12 <Philippa> yeah. I'd like ghci on my phone
04:53:19 <Philippa> (I'd like a phone worth running ghci on too, mind)
04:53:26 <dark> isn'r Show is meant for showing at an interpreter?
04:53:41 <Xaphiosis> would you believe that the sony PRS series of ebook readers has software that is mostly coordinated by xml and javascript? makes me want to cry
04:54:01 <dark> ah
04:54:12 <dark> (misunderstood)
04:55:32 * ManateeLazyCat Bla bla enough.... bye all. :)
04:55:32 <Xaphiosis> anyway, haskell on ARM would be awesome
04:56:15 <sts193> Well guys I'm off, thanks for everything. I'll def. be back!
04:56:28 <Xaphiosis> sts193: have a good weekend!
04:57:03 <benmachine> da-x: don't bytestrings already have a show instances?
04:57:05 <benmachine> *instance
04:57:37 <dark> it is often said that ml and haskell makes wonders for compiling, but the multi-language compilers I know are written in C
04:58:21 <dark> and at least one of them is full of bugs (including optimizations mis-compiling code), and people doesn't seem to care
04:58:23 <Nibble> A question about LLVM
04:58:29 <Nibble> is it ready for use yet?
04:58:59 <Nibble> haskell llvm that is
04:59:21 <Lemmih> Nibble: The library or the backend?
04:59:50 <Nibble> Lemmih: the backend is LLVM right? I know LLVM is kinda mature
04:59:56 <da-x> benmachine: they have a Prelude.Show instance, not a Text.Show.ByteString.Show instance
05:01:00 <Lemmih> Nibble: There's LLVM, a Haskell binding to LLVM and an LLVM backend for GHC.
05:01:38 <benmachine> da-x: oh, what package is that?
05:02:15 <benmachine> bytestring-show, right
05:03:10 <Nibble> Lemmih: is anyone of them worth using yet?
05:03:40 <benmachine> da-x: yeah, that's weird. ask the maintainer?
05:04:23 <benmachine> da-x: Put has a show instance though
05:05:15 <da-x> benmachine: bytestring-show. But, nevermind, I was trying to implement a new Text.Show.ByteString.Show instance on a Data that has a ByteString, and the fix was to use putByteString instead of showp.
05:05:16 <jedai> Nibble: the llvm binding in Haskell is supposed to be pretty good, maybe better than the C++ binding (added some type safety)
05:05:20 * hackagebot certificate 0.2.1 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-0.2.1 (VincentHanquez)
05:05:32 <Lemmih> Nibble: They're all pretty neat. The LLVM backend is not as readily available as the others, though.
05:06:31 <jedai> Nibble: the backend has been shown to often outperform other backends, and it prompted some more cleaning of GHC so it's an interesting effort, it's not integrated in the currently used GHC
05:06:36 <jedai> though
05:07:05 <jedai> Maybe in the one that will soon be released ? Someone know ?
05:07:10 <Nibble> jedai: ok, Lemmih pl. Imma gonna try the haskell-llvm
05:07:27 <benmachine> pretty sure llvm is going to be in GHC 7
05:07:33 <Phyx-> UHC has a llvm backend too
05:07:37 <benmachine> (which is what 6.14 seems to be called nowadays)
05:09:22 <dark> benmachine, wow *_*
05:09:56 * hpc ponders the feature-set of the real GHC 7
05:09:58 <Nibble> benmachine: does ghc follow(ed?) the linux naming scheme? i.e. 6.13 => unstable?
05:10:17 <hpc> Nibble: probably; the latest version is 6.12
05:10:22 <benmachine> Nibble: I believe that darcs versions are odd-numbered
05:10:41 <Phyx-> hpc: mind reading ability is a must
05:10:58 <Phyx-> Nibble: it seems to
05:11:29 <Phyx-> benmachine: doesn't darcs hold both stable and head?
05:12:00 <benmachine> shrug
05:12:02 <benmachine> I mean head then
05:13:51 <dark> isn't ghc code versioned with git nowadays?
05:14:02 <Saizan> no
05:15:09 <dark> http://www.reddit.com/comments/6v2nl/ghc_project_switches_to_git/
05:15:13 <benmachine> there was once a plan to switch
05:15:16 <benmachine> but it fell through I think
05:15:27 <benmachine> they decided to just wait for darcs to improve
05:15:31 <SubStack> oh good finally
05:16:15 <dark> makes sense.. (but, i read there was a meeting, and that there were a consensus)
05:16:50 <benmachine> yes
05:17:02 <benmachine> and then there was an anti-consensus, presumably
05:17:26 <benmachine> and they reacted, converting all their mass into energy
05:17:30 <benmachine> but none of their darcs into git
05:17:44 <dark> ^^'
05:17:47 <Xaphiosis> :)
05:18:31 <Xaphiosis> I've always had difficulty with darcs... not because it's written in haskell, but because it keeps asking me questions, moreso than any tool I've used before
05:19:13 <dark> darcs get --lazy seems pretty neat.
05:19:29 <dark> i suppose it will begin downloading more if i look into history
05:20:15 <benmachine> Xaphiosis: darcs pull accepts an -a option for "all"
05:21:32 <Xaphiosis> benmachine: but it also asks for committing... record this? that? partially? by hunks? etc.
05:22:19 <Xaphiosis> the hg-using people at work already complain about git's staging area adding complexity... darcs really does ask lots of questions
05:23:21 <Saizan> Xaphiosis: you can pass -a to all such commands if you just want to skip the questions
05:23:22 <hpc> i wonder if you could take all the complaints about various version control programs and combine them without contradiction
05:23:41 <Xaphiosis> hpc: unlikely, there's a big cognitive difference
05:23:53 <hpc> heh
05:24:29 <Xaphiosis> e.g. I love the git staging area and mutable history, mercurial claims this is the wrong way to go and that "history must be preserved"
05:24:59 <hpc> what's the purpose of having a mutable history?
05:25:15 <hpc> (not against it, just curious as to the purpose)
05:25:16 <Xaphiosis> so that I can reshuffle things before I push them to you
05:25:21 <hpc> ah
05:25:47 <Xaphiosis> darcs has cherry-picking, but that's the hardcore version
05:26:35 <Xaphiosis> mercurial... well, everyone I know who uses it for anything uses the patch queues extension, so they do history modification anyway
05:27:24 <Xaphiosis> but to get a consensus on this between more than one individual... good luck :P
05:28:06 <Xaphiosis> at least with ghc on darcs there's the "eat your own dog food argument"
05:28:32 <benmachine> well that's more to do with darcs being used for darcs
05:28:33 <benmachine> which it is
05:29:04 <Xaphiosis> point
05:30:54 <Xaphiosis> it's still a nice sales point if hackage runs on a haskell framework, ghc is stored in a repository system written in haskell, etc
05:33:16 <fserb> is there any way to tell ghci to save more than 100 lines of history?
05:34:11 <hpc> ghci | tee logfile
05:34:14 <hpc> maybe?
05:35:13 <fserb> hpc: ? I was talking about ~/.ghc/ghci_history file, it seems that ghci only saves the last 100 commands there (although the running history can grow forever)
05:35:21 <hpc> ah
05:35:34 <Heffalump> Xaphiosis: is your answer to the questions always the same, then?
05:35:52 <Xaphiosis> Heffalump: how so?
05:36:50 <Heffalump> with darcs. You don't like it asking qustions, does that mean that the answer is always obvious?
05:37:46 <Ke> ghci could use also history-search-backward
05:37:54 <Ke> and forward...
05:37:58 <Xaphiosis> no, but there is a difference between the default being "always ask questions", having a "just shut up" option, and a "do the obvious" default with a "hang on I've got a special request" option
05:38:31 <Xaphiosis> and I am in no position to tell you that either approach is "right", only that I like the latter
05:38:54 <Ke> well you should always review the commits anyways
05:39:16 <Xaphiosis> in git, with a staging area, you have to anyway, unless you do commit -a
05:39:18 <burp> darcs' question mode leads to better commits
05:39:19 <Ke> sadly darcs only show fragments that don't make sense by themselves
05:39:19 <hpc> plenty of other programs will tell you which way is right though; the latter is a popular in nearly every other linux utility i have ever used
05:39:27 <hpc> er, people
05:39:44 <hpc> the exception being useradd
05:40:12 <Xaphiosis> in git, you add stuff to a staging area, then commit when you're happy... in darcs, it asks you bit by bit
05:40:50 <burp> Xaphiosis: -a
05:41:00 <Phyx-> !google l
05:41:06 <Xaphiosis> -a doesn't solve the problem
05:41:11 <burp> why not?
05:41:26 <Phyx-> is there an up to date document specification for .cabal files? except for the source
05:41:47 <Phyx-> I assume that when discussing it there must have been documentations made
05:41:56 <benmachine> Phyx-: is the user's guide not up to date?
05:41:59 <Xaphiosis> if I've modified 15 files and want to commit 5 of them entirely and one partially, I'll do git add (the 5 entirely), git add -i (the one partially), git commit
05:42:09 <Xaphiosis> notice no questions got asked
05:42:17 <Xaphiosis> except where I said "partially"
05:42:34 <Xaphiosis> if I simply do git commit -a, it'll commit everything
05:42:41 <burp> yeah, I see
05:42:41 <Xaphiosis> darcs probably the same
05:43:07 <Xaphiosis> but this is getting slightly out of hand, I don't want to be doing git evangelism on a haskell channel
05:43:22 <burp> why?
05:43:29 <Saizan> you could do "darcs record -a <complete files here> && darcs amend <other file>"
05:43:56 <Saizan> using the last recorded patch as a stash, but it's quite an hack :)
05:44:00 <Phyx-> benmachine: hm, It probably is, i was hoping for something a bit more formal, but I guess that'll do
05:44:34 <Xaphiosis> I use git for personal stuff and my phd, svn for old stuff, hg at work, and darcs when I interact with people who choose it... I have my own preferences, I love the idea of a staging area, and I don't want to be asked questions
05:44:52 <benmachine> being asked questions is fun :(
05:45:05 <Xaphiosis> for all those revision control systems, you can "hack" a way to do anything I can do with git
05:45:13 <Xaphiosis> and vice-versa
05:45:13 <benmachine> (cue <everyone> benmachine: is that so?)
05:45:31 <burp> I like git and darcs both very much, and think that hg is unusable and from hell :>
05:45:38 <Xaphiosis> but that won't make any of those systems inherently better than another
05:45:51 <Xaphiosis> only better/worse for me, or a team of like-minded people
05:46:02 <benmachine> I like git too
05:46:25 <benmachine> I only use darcs for fetching other people's stuff, but that's only really because I haven't taken the time to learn it
05:46:39 <Xaphiosis> indeed. the question though is, do you want to?
05:46:48 <Xaphiosis> and that's down to marketing :)
05:47:43 <Xaphiosis> I'm glad darcs is out there though... I don't have to use it, but it's a real DVCS written in haskell
05:47:58 <Xaphiosis> and I like haskell, the more apps the merrier
05:48:07 <Phyx-> i use svn
05:48:09 * Phyx- hides
05:48:15 <Nibble> Phyx-: you better hide.
05:48:25 <Phyx-> I also use Team Foundation Server :P
05:48:27 * Phyx- runs
05:48:56 <Xaphiosis> apparently svn and cvs are still the most popular out there, along with visual source safe (sp?)
05:49:15 <Phyx-> visual source safe is deprecated though
05:49:18 <Phyx-> TFS replaced it
05:49:35 <Xaphiosis> yeah, but corporations like to move fast
05:50:00 <Xaphiosis> relatively recently I was somewhere where they were still running something on DOS
05:50:13 <benmachine> git-svn <3
05:50:57 <new-lisper> if it's freedos it is not that bad
05:51:27 <Xaphiosis> I was too shocked to ask
05:51:39 * new-lisper laughs
05:54:33 <mm_freak> is wxHaskell thread-safe or does the GUI need to run in a certain OS thread?
06:01:53 <mm_freak> ok, running the GUI in an unbound thread works
06:03:16 <Axman6> mm_freak: worked this one time, might still not be threadsafe*
06:03:33 <Twey> Mm
06:03:37 <Twey> Threads are tricky things
06:03:40 <ManateeLazyCat> mm_freak: gtk2hs code?
06:07:00 <mm_freak> Axman6: actually setting the window title from another thread didn't work
06:07:10 <mm_freak> but it didn't crash, it just didn't change anything
06:07:13 <mm_freak> ManateeLazyCat: wxHaskell
06:07:17 <mm_freak> package 'wx'
06:07:19 <Axman6> fair enough
06:07:42 <ManateeLazyCat> mm_freak: Oh, if you use gtk2hs, i have many library that how to write safe multi-threades gtk2hs code.
06:07:46 <mm_freak> Axman6: but it didn't work even if i used -N1
06:08:09 * ManateeLazyCat pasted "concurrent library for gtk2hs" at http://paste2.org/get/984028
06:08:09 <ManateeLazyCat> mm_freak: Like above is my concurrent library for gtk2hs .
06:08:27 <mm_freak> ManateeLazyCat: well, it looks like it's safe to use multiple threads, but the GUI should run in a single haskell thread
06:08:29 <Saizan> i'm not sure if -N1 guarantees much here
06:08:41 <mm_freak> and the main thread is bound by default anyway
06:09:08 <mm_freak> ManateeLazyCat: i'd like to use wx though, but yet i couldn't get it to compile under windows =/
06:09:19 <ManateeLazyCat> mm_freak: The key of GUI multi-threads is you can use forkIO fork any thread do *non-GUI* calculate, but you must find a way post your *GUI* code to Render main threads
06:09:31 <mm_freak> Saizan: doesn't it guarantee that at least the haskell threads are run in a single OS thread?
06:10:01 <ManateeLazyCat> mm_freak: In gtk2hs we use postGUIAsync function post GUI code from current thread to render main threads.
06:10:04 <mm_freak> (the RTS itself might use more, of course)
06:10:35 <ManateeLazyCat> mm_freak: And you need enable "-threaded" flags to running GUI multithread code.
06:10:35 <Saizan> mm_freak: i think it might still use something else for some FFI calls
06:10:43 <mm_freak> ManateeLazyCat: well, it's not that i have problems with a single-threaded GUI, i just asked out of curiosity
06:11:01 <mm_freak> Saizan: i see
06:11:09 <mm_freak> Saizan: what about not using -threaded at all?
06:11:45 <Saizan> that should be enough
06:12:35 <mm_freak> didn't change anything…  i still can't set the window title from a different thread
06:12:59 <Heffalump> FWIW to record 5 files fully, one partially out of 15, I would use 'f' on the full files, 's' on the not-at-all files, and 'y/n' on the partial file. So the downside is those 10 's' keystrokes.
06:13:24 <ManateeIrcClient> Hello, everyone, I'm IRC bot of ManateeLazyCat, pure haskell code running in my heart..... :)
06:13:29 <ManateeLazyCat> Wow, cool.
06:13:48 <ManateeLazyCat> Works!
06:14:01 <mm_freak> ah, i can imagine that wx guarantees that the actual GUI is run in a single thread under the hood
06:14:33 <ManateeLazyCat> mm_freak: Multi-thread is only solution for some situation.
06:14:58 <Saizan> Heffalump: and if you list the 6 files on the command line you can avoid those, i guess?
06:15:03 <ManateeLazyCat> mm_freak: Example you have *long-time* backend calculate, you need use multi-thread avoid block user.... 
06:15:28 <mm_freak> ManateeLazyCat: i'm a wx newbie, not a haskell newbie ;)
06:15:31 <mm_freak> but thanks =)
06:15:41 <Saizan> Heffalump: anyhow i think the big difference is that with git you don't have to state your intentions all at once
06:16:39 <ManateeLazyCat> mm_freak: In gtk2hs, all threads is OS thread not Haskell lightweight thread, I think wx is similar.
06:17:16 <mm_freak> ManateeLazyCat: threads (including OS threads) work well, i just can't interact with the GUI directly from a different haskell thread
06:17:25 <mm_freak> i guess i'll use MVars or similar for this
06:17:57 <ManateeLazyCat> mm_freak: In wx haven't some function run code when main thread idle?
06:18:20 <ManateeLazyCat> mm_freak: In gtk2hs postGUIAsync is post GUI code to main thread, run it when main thread idle.
06:19:16 <mm_freak> ManateeLazyCat: you can use regular haskell threads for that
06:19:31 <mm_freak> no need for wx-specific stuff
06:19:58 <ManateeLazyCat> mm_freak: You mean idle main thread with delay time?
06:20:11 <ManateeLazyCat> In haskell code?
06:20:20 <mm_freak> ManateeLazyCat: forkIO doSomethingWhileIdleOrWhileAnOSThreadIsFree
06:20:55 <mm_freak> wx apparently doesn't interfere with concurrency
06:22:35 <ManateeLazyCat> mm_freak: I'm curiosity *doSomethingWhileIdleOrWhileAnOSThreadIsFree*, real code?
06:24:04 <ManateeLazyCat> mm_freak: In gtk2hs we use postGUIAsync (a wrap to gdk C function : idle_add_full) to post code when main thread idle.
06:24:18 <mm_freak> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29904
06:24:36 <mm_freak> runs the GUI and concurrently prints "Hello there!" to the terminal once a second
06:24:51 <ManateeLazyCat> mm_freak: Ah, you use threadDelay
06:24:59 <ManateeLazyCat> mm_freak: Same as my guess. :)
06:25:13 <mm_freak> yes, even though wx has timer objects, too
06:25:51 <fserb> I'm looking for some monad that looks like the maybe monad, but exactly the opposite, i.e., that it continues if it gets a Nothing and stops at the first Just. I wonder if there's already something like this before I write my own.
06:26:06 <ManateeLazyCat> mm_freak: But threadDelay have problem, if time is short can't execute, if time longer, waste cycle....
06:26:18 <opqdonut> > Nothing `mplus` Nothing `mplus` Just 3 `mplus` Just 2
06:26:30 <opqdonut> @bot
06:26:58 <opqdonut> fserb: anyway, that will evaluate to Just 3
06:27:07 <copumpkin> will it?
06:27:11 <copumpkin> oh yeah
06:27:13 <opqdonut> it does in my ghci
06:27:16 <copumpkin> I'm thinking of mappend
06:27:20 <copumpkin> damn confusing names
06:27:23 <opqdonut> indeed.
06:27:27 <mm_freak> ManateeLazyCat: what do you mean?  threadDelay is not guaranteed to wait exactly one second, but /at least/ one second, which is fine for most purposes
06:27:47 <opqdonut> fserb: MonadPlus is the relevant type class
06:28:24 <mm_freak> fserb: use a choice monad (like []) and pick the first result
06:28:38 <fserb> opqdonut, nice. Time to read about MonadPlus. :)
06:29:14 <mm_freak> or a short circuit monad like Cont
06:29:17 <LiBeLuLa> hi
06:29:22 <opqdonut> mm_freak's advice is also good
06:29:34 <LiBeLuLa> how are youu :P
06:30:21 <mm_freak> hi there LiBeLuLa, i'm fine, thanks =P
06:30:32 <LiBeLuLa> :)
06:30:50 <mm_freak> side note about wx:  concurrency doesn't work without -threaded
06:31:04 <LiBeLuLa> quin desea aprender espaol? :$
06:32:36 <copumpkin> LiBeLuLa: nadie :P
06:32:47 <ManateeLazyCat> mm_freak: How do you know how long the current thread suspension time? 
06:32:57 <LiBeLuLa> malu copumpkin jejejej
06:34:49 <fserb> mm_freak, opqdonut: doing it inside a list sounds nice, but is there an easy way of getting the first Just result? All I can think is a horrible filter with a case and !! 0... :(
06:35:49 <mm_freak> ManateeLazyCat: i don't
06:36:06 <mm_freak> fserb: with the list monad you don't need Maybe at all
06:36:21 <mm_freak> fserb: what's your application?  a search?
06:36:51 <mm_freak> LiBeLuLa: i don't speak spanish, sorry, neither here nor in my query =)
06:37:07 <LiBeLuLa> :(
06:37:13 <LiBeLuLa> aguuuu
06:37:15 <LiBeLuLa> xD
06:37:30 <fserb> mm_freak: I'm getting a content-type of a weird http request. So I first try the Content-Type header and then use magic on the content itself.
06:37:42 <copumpkin> LiBeLuLa: please don't spam people
06:37:52 <fserb> mm_freak, by "magic" I mean libmagic, like "file" does.
06:37:53 <LiBeLuLa> mmm
06:37:55 <copumpkin> LiBeLuLa: this is not the place to talk about spanish :)
06:38:34 <mm_freak> fserb: Cont can do that, but you can also use a simple case =)
06:38:42 <mm_freak> @botsnack
06:38:46 <mm_freak> hmm, no bot =/
06:39:23 <fserb> mm_freak: I did with a case but it felt wrong somehow... 
06:39:37 <LiBeLuLa> poco amables..
06:40:12 <fserb> mm_freak: then I thought there must by a way to say "try this, if it doesn't work try this other thing, and if it doesn't work try this other option, etc..."
06:40:43 <benmachine> fserb: MonadPlus' msum?
06:41:02 <mm_freak> fserb: it's not wrong =)
06:41:51 <benmachine> fserb: it might be useful for us to see your code, but from what you've said so far I'm thinking msum is what you want
06:42:12 <benmachine> or possibly getFirst . foldMap First if you like monoids
06:45:21 <fserb> benmachine: I'm looking into MonadPlus now.
06:45:32 <fserb> benmachine, mm_freak: the code is this: http://pastebin.com/s2sBpDR0
06:45:55 <da-x> Getting "Couldn't match expected type `ByteString' against inferred type `Data.ByteString.Lazy.Internal.ByteString'". That's one of these problems I really don't like to solve.
06:46:24 <benmachine> da-x: at a guess, you're mixing strict and lazy bytestrings
06:46:37 <benmachine> you can convert between the two with fromChunks and toChunks
06:46:39 <benmachine> I believe
06:47:10 <benmachine> fserb: you're using otherwise unpleasantly ther
06:47:12 <benmachine> *there
06:47:22 <Heffalump> Saizan: yes (re command-line0
06:47:31 <da-x> I'll look into that. Wouldn't it be great if ghc could have hinted you about the right converter functions based on the types only?
06:47:45 <benmachine> fserb: otherwise is meant to be used in guards, the correct form here is _ ->
06:48:06 <Heffalump> I don't think using the last recorded patch as a staging area is particularly evil. Seems quite natural if that's what you want.
06:48:20 <benmachine> da-x: that would be kinda neat, yeah, I wonder if hoogle could be hooked to provide it
06:48:35 <fserb> benmachine: I see. Thanks. This is actually my first haskell program ever, so weird mistakes are expected. :)
06:49:00 <benmachine> fserb: anyway I'm kind of confused as to how what you were asking relates to this snippet
06:50:22 <fserb> benmachine: so getContentTypeFromHeader and getContentTypeFromContent are of the type: Block -> Maybe String, i wanted to remove the "case ct of" and do it in a way that would make it clear that I'm "falling back" to a different approach if the first doesn't work.
06:50:42 <benmachine> ah okay
06:51:31 <benmachine> fserb: btw, in what circumstances would getDataAddr return other than two items?
06:53:09 <fserb> benmachine: I'm reading a cache data file, in theory it holds 4 data addr, the first being the header, the second the content, the other two are always empty it seems. 
06:53:31 <fserb> benmachine: so I'm filtering empty data out on getDataAddr.
06:53:42 <benmachine> oh right
06:54:27 <benmachine> your situation is a tiny bit tricky because your function does some IO if the first Maybe is Nothing
06:54:32 <benmachine> this might be a job for MaybeT
06:54:39 <fserb> yep. It's very annoying.
06:55:11 <fserb> but loadAddr also does IO.
06:55:13 <mm_freak> fserb:
06:55:18 <mm_freak> > runContT (const $ return (Nothing :: Maybe Int)) $ do when False $ abort (Just 1 :: Maybe Int); when True $ abort (Just 2 :: Maybe Int)
06:55:21 <mm_freak> Just 2
06:55:31 <hvr> how do I get emacs' haskell-mode to ":cd" into the correct folder? right now it seems to cd into the folder holding the .cabal file, but I want it to cd into "src/"
06:55:31 <mm_freak> that's how i would do it — probably
06:56:02 <Maxdamantus> Where does the first function come from?
06:56:11 <Maxdamantus> first
06:56:13 <benmachine> Maxdamantus: Control.Arrow
06:56:16 <Maxdamantus> Thanks
06:56:20 <benmachine> try hoogle
06:56:30 <Maxdamantus> Oh, is that a site or omething?
06:56:39 <Maxdamantus> Ah, I see.
06:58:02 <benmachine> Maxdamantus: it's available as a website and also a command-line tool
06:59:29 <mm_freak> fserb: i'm writing an example
07:00:24 <fserb> mm_freak: ok. cool.
07:05:14 <mm_freak> fserb: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29905#a29905
07:05:58 <mm_freak> actually using 'catch' would make more sense
07:06:10 <benmachine> fserb: btw, you can put any expression in a case statement
07:06:20 <fserb> benmachine: just did that :)
07:06:33 <fserb> benmachine: and got rid of the "let ... in"
07:06:35 <benmachine> mm
07:06:44 <benmachine> http://pastebin.com/bZfdhu6s this is me not solving any of your problems
07:06:50 <benmachine> but in a vaguely interesting way perhaps
07:07:32 <fserb> benmachine: haha :) cool.
07:07:44 <fserb> mm_freak: very nice.
07:08:22 <fserb> benmachine, mm_freak: you guys rock! #haskell is the best channel I've ever seen on freenode.
07:08:47 <benmachine> fserb: it totally is :)
07:09:29 <benmachine> I spent weeks in horrible channels of horrible people when I learnt python, this was such a breath of fresh air
07:09:45 <mm_freak> hehe
07:10:05 <ben_m> grouphup!
07:10:08 <ben_m> hug*
07:10:09 <mm_freak> yeah, haskellers are very open-minded
07:10:47 * benmachine grouphugs ben_m 
07:10:49 <mm_freak> benmachine: i remember implementing church lists in python
07:10:56 <benmachine> mm_freak: ooh, neat
07:11:03 <dark> church.. lists?
07:11:09 <dark> i know church numerals
07:11:13 <benmachine> I tried to implement pattern-matching in python using exceptions, it failed
07:11:16 <mm_freak> when i showed them to python people, they were like: "this is stupid…  you're not as smart as you think"
07:11:35 <benmachine> type List a = forall b. (a -> b -> b) -> b -> b, something like that?
07:11:43 <mm_freak> dark: http://ertes.de/techblog/2009-01-11-1-python-church-lists.html
07:11:51 <mm_freak> benmachine: yeah, exactly that
07:11:52 <dark> mm_freak, this is stupid in what sense? that it isn't worth to implement church lists? or that your code is dumb?
07:12:13 <mm_freak> dark: in no specific way, it's just that i abused python for functional stuff
07:12:32 <mm_freak> dark: it's like using CPS in C…  the average C programmer doesn't appreciate this
07:12:42 <ManateeIrcClient> mm_freak: That's not friendly if some people said like that...
07:12:53 <mm_freak> even though it proved very useful to me a number of times
07:13:01 <mm_freak> for example i reimplemented the withFile function in C
07:13:38 <dark> withFile being "open this file, call this function passing the file, then close this file"?
07:14:05 <mm_freak> dark: yes
07:14:11 <mm_freak> dark: http://ertes.de/techblog/2009-02-19-1-continuations-for-secure-code.html
07:14:14 <ManateeIrcClient> dark: yes
07:14:39 <FunctorSalad> is scanl (+) 0 the efficient way to compute partial sums?
07:14:57 <dark> supposing you don't have any errors in the function called (and you don't, right?) that's just a = open(); error checking; function(a); clos.. isn't it?...
07:15:15 <mm_freak> FunctorSalad: that's how i would do it
07:15:28 <benmachine> is there a scanl'? :P
07:15:33 <FunctorSalad> mm_freak: I don't even want to think about the thunk/fusion issues :(
07:15:44 <mm_freak> dark: yes, but the responsibility to close the file is moved from the programmer to withFile, which is the whole point of it
07:15:45 <FunctorSalad> benmachine: no, apparently
07:15:54 <mm_freak> FunctorSalad: i don't think there are any
07:15:55 <FunctorSalad> benmachine: I was expecting someone to tell me it wouldn't make sense ;)
07:16:10 <benmachine> FunctorSalad: I was just wondering if it did, I don't know
07:16:15 <mm_freak> > last . scanl (+) 0 $ [1..100000]
07:16:15 <mm_freak> 5000050000
07:16:19 <mm_freak> works fine
07:16:24 <FunctorSalad> mm_freak: as long as the result is consumed by a 'good consumer'?
07:16:31 <FunctorSalad> I see
07:16:48 <ManateeIrcClient> lambdabot come back? :)
07:16:50 <benmachine> mm_freak: so does the foldl though
07:16:58 <benmachine> @bots
07:17:01 <benmachine> nope
07:17:04 <mm_freak> benmachine: yes, but FunctorSalad wants partial sums on the way
07:17:15 <benmachine> mm_freak: my point is, foldl is too lazy, but still works
07:17:29 <benmachine> mm_freak: so you haven't demonstrated that scanl doesn't need to be more strict
07:18:20 <FunctorSalad> I don't have the exact consumer yet unfortunately ;)
07:18:23 <mm_freak> benmachine: well, that's appropriate i guess
07:19:54 * hackagebot regions 0.7.0.1 - Provides the region monad for safely opening and working with  scarce resources.  http://hackage.haskell.org/package/regions-0.7.0.1 (BasVanDijk)
07:19:56 * hackagebot regional-pointers 0.4 - Regional memory pointers  http://hackage.haskell.org/package/regional-pointers-0.4 (BasVanDijk)
07:19:58 <mm_freak> wait, it could be stricter i guess
07:19:58 * hackagebot safer-file-handles 0.8 - Type-safe file handling  http://hackage.haskell.org/package/safer-file-handles-0.8 (BasVanDijk)
07:20:00 * hackagebot safer-file-handles-bytestring 0.1.0.2 - Extends safer-file-handles with ByteString operations  http://hackage.haskell.org/package/safer-file-handles-bytestring-0.1.0.2 (BasVanDijk)
07:20:30 <mm_freak> but maybe that's just GHCi
07:20:54 * hackagebot safer-file-handles-text 0.1.0.2 - Extends safer-file-handles with Text operations  http://hackage.haskell.org/package/safer-file-handles-text-0.1.0.2 (BasVanDijk)
07:20:58 <benmachine> scanl' could definitely exist
07:21:01 <benmachine> I think it might even be useful
07:21:07 <benmachine> hmm
07:21:56 * hackagebot usb 0.6 - Communicate with USB devices  http://hackage.haskell.org/package/usb-0.6 (BasVanDijk)
07:21:59 * hackagebot usb-enumerator 0.1.0.2 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-enumerator-0.1.0.2 (BasVanDijk)
07:22:01 * hackagebot usb-safe 0.10 - Type-safe communication with USB devices.  http://hackage.haskell.org/package/usb-safe-0.10 (BasVanDijk)
07:22:04 <benmachine> ghci> length $ scanl const undefined (replicate 10 undefined)
07:22:04 <benmachine> 11
07:22:29 <benmachine> ghci> length $ scanl undefined undefined (replicate 10 undefined)
07:22:31 <benmachine> 11
07:22:35 <ManateeLazyCat> Haskeller is productive. :)
07:23:06 <benmachine> so I guess scanl is lazy by default
07:23:24 <benmachine> it would be possible to make it stricter
07:23:54 <basvandijk> ManateeLazyCat: just releasing some accumulated work :-)
07:23:58 <dark> @src scanl
07:24:07 <benmachine> dark: lambdabot's toast
07:24:10 <ManateeLazyCat> basvandijk: Great work . :)
07:24:12 <Phyx-> :t cake
07:24:18 <basvandijk> ManateeLazyCat: thanks
07:24:23 <Phyx-> did they kill botty again?
07:24:34 <Phyx-> damn, he dies alot lately
07:24:49 <mm_freak> yeah, scanl can be stricted
07:24:50 <mm_freak> yeah, scanl can be stricter
07:25:03 <benmachine> in more than one way
07:25:26 <Phyx-> (-_-)
07:25:42 <mm_freak> as long as it doesn't lose its laziness
07:26:04 <benmachine> mm_freak: we can make it stricter as long as it isn't any more strict?
07:26:18 <mm_freak> benmachine: strict vs. eager
07:26:22 <mm_freak> the list should still be lazy
07:28:01 <Olathe> Is it possible to have a function of type a where a = x -> (y, a)?
07:28:17 <benmachine> Olathe: where the type a contains itself?
07:28:26 <FunctorSalad> Olathe: newtype
07:28:39 <Olathe> benmachine: Yeah.
07:28:45 <Olathe> FunctorSalad: Ahh, OK. Thanks.
07:29:01 <FunctorSalad> newtype Omg x y = Omg (x -> (y, Omg x y))
07:29:02 <FunctorSalad> ;)
07:29:03 <benmachine> mm_freak: it'd be a weird definition of scanl that forced the spine of the whole list, but you could force each element as you go
07:29:12 <Olathe> OMG
07:29:12 <revenantphx> FunctorSalad: that's kinda odd.
07:29:14 <revenantphx> :P
07:29:30 <benmachine> revenantphx: welcome to haskell, you must be new here :P
07:29:32 <revenantphx> It's like embedded recursion...
07:29:39 <revenantphx> benmachine: Oh I'm getting used to it.
07:29:48 <revenantphx> @quote fugue
07:29:59 <revenantphx> > print "hello?"
07:30:08 <revenantphx> lambdabot... NOOOOOoooouuuuuu
07:30:13 <revenantphx> TT__TT
07:31:06 * Phyx- organises a stage in. WE WANT LAMBDABOT
07:31:18 <revenantphx> Where'd lambdabot go
07:31:22 <benmachine> you can run your own lambdabots you know
07:31:23 <revenantphx> She was such a nice friend.
07:31:28 <benmachine> she's having a nap
07:31:29 <revenantphx> benmachine: But none would be like her.
07:31:35 <revenantphx> Is she sick D:?
07:31:55 <Phyx-> benmachine: there's only one true lambdabot
07:32:00 <benmachine> she tripped and fell off the internet but didn't notice, so she hasn't come back
07:32:02 <revenantphx> ^
07:32:04 <Phyx-> she's irriplaceable
07:32:05 <wagstaff>  /msg NickServ identify
07:32:15 <revenantphx> benmachine: when she fell, she must have thrown all her exceptions
07:32:25 <revenantphx> benmachine: I don't think it'd be possible to catch all of them :\
07:32:36 <revenantphx> probably trying to replace them right now.
07:32:43 <revenantphx> They have a sale at IKEA on cheap ones actually.
07:32:53 <wagstaff>  /msg NickServ identify 11Shirley
07:33:00 <revenantphx> pro.
07:33:33 <benmachine> wagstaff: umm
07:33:34 <revenantphx> wagstaff: Good job.
07:33:36 <Phyx-> awesome
07:33:51 <Phyx-> oh
07:33:57 <Phyx-> that WAS the real pass
07:33:59 <Phyx-> my bad :(
07:34:08 <revenantphx> did you just ghost him XD?
07:34:18 <Phyx-> revenantphx: yeah, wasn't expecting it to be real
07:34:23 <revenantphx> hey it DOES work.
07:34:26 <revenantphx> Okay I'm done.
07:34:29 <benmachine> Phyx-: if I were you I'd change it and then PM it to him >_>
07:34:38 <revenantphx> Or just PM him, and tell him to change it
07:34:47 <Phyx-> he needs to come back first
07:34:49 <revenantphx> yeah
07:34:52 <benmachine> well yeah but I wanted to rule out the possibility of him being stupid and then not
07:35:07 <Phyx-> I honestly thought he was kidding
07:35:12 <revenantphx> same
07:35:19 <benmachine> revenantphx: yeah, right :P
07:35:20 <Heffalump> what's the point in testing it then?
07:35:27 <Phyx-> confirmation
07:35:28 <revenantphx>  /msg NICKSERV IDENTIFY penisnomnomnom
07:35:39 <benmachine> Phyx- *sorta* has an excuse, but you saw it happen
07:35:52 <revenantphx> Oh, I was in a diff channel *whistles*
07:36:20 <mm_freak> FunctorSalad: i've written a stricter version of scanl' now
07:36:53 <mm_freak> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29906#a29906
07:37:01 <mm_freak> > last . scanl' (+) 0 $ [1..10000000]
07:37:01 <mm_freak> 50000005000000
07:37:04 <mm_freak> takes constant memory now
07:37:11 <FunctorSalad> mm_freak: the general issue is making my head spin :(
07:37:18 <FunctorSalad> I dont' have a good framework for thinking about it
07:37:24 <Phyx-> guess we made him mad
07:37:44 <mm_freak> benmachine: see above
07:37:45 <Philippa> *sigh*. Mobile broadband + train = fail
07:37:48 <FunctorSalad> someone should make a nice colourful story with personified thunks
07:37:51 <FunctorSalad> ;)
07:37:58 <mm_freak> FunctorSalad: hehe
07:38:21 <mm_freak> FunctorSalad: you just have to know the difference between strictness and eagerness
07:38:27 <mm_freak> or nonstrictness and laziness
07:38:32 <mm_freak> then it's fairly simple
07:38:48 <revenantphx> mm_freak: explain please?
07:38:53 <revenantphx> I understand lazy vs eager
07:38:59 <revenantphx> but strict/nonstrict not so much
07:39:11 <mm_freak> in fact if the function weren't lazy, it would be much worse than the non-strict scanl
07:39:15 <FunctorSalad> I guess your point isn't that (non)strictness is a term from denotational semantics and lazy/eager are more concrete?
07:39:20 <mm_freak> once evaluated it would calculate the entire list at once
07:39:42 <revenantphx> TT_TT... I'm left out in the cold dark.
07:40:03 <dark> (i sometimes think about saying a pun or so)
07:40:10 <FunctorSalad> mm_freak: I do understand these concepts, just not what exactly is going on in a foldl or foldl'
07:40:14 <benmachine> mm_freak: hmm, I don't think it would
07:40:15 <FunctorSalad> *or scanl
07:40:28 <mm_freak> FunctorSalad: look up the definitions, it's fairly simple
07:40:37 <benmachine> mm_freak: it would build up a huge thunk but it could still GC the list as it went
07:41:00 <benmachine> mm_freak: also I think whether or not you have z at the beginning of your list is inconsistent
07:41:05 <mm_freak> benmachine: not if the list were eager:  data EagerList a = Nil | Cons a !(EagerList a)
07:41:32 <mm_freak> benmachine: i don't understand
07:41:34 <FunctorSalad> rev stop changing your nick I can't tabcomplete you that way :p
07:41:37 <benmachine> mm_freak: well such a list is always either fully evaluated or not at all
07:42:15 <mm_freak> FunctorSalad: he's gone
07:42:20 <FunctorSalad> oh
07:42:24 <mm_freak> benmachine: hence not lazy =)
07:42:42 <FunctorSalad> anyway, strictly speaking 'strict' means nothing more than f _|_ = _|_
07:42:48 <mm_freak> but Cons is non-strict in its first argument
07:42:59 <FunctorSalad> so this isn't really the issue with this stuff I think
07:42:59 <mm_freak> so the individual cells can still be unevaluated
07:43:16 <mm_freak> FunctorSalad: it is, because it makes a practical difference
07:43:29 <benmachine> mm_freak: oh, true I suppose
07:43:45 <benmachine> but it's not the spine you're worried about, is it
07:43:49 <mm_freak> FunctorSalad: for example try foldr with an operator, which is strict in its second argument
07:43:49 <benmachine> it's the cells
07:43:54 <benmachine> or well
07:43:59 <benmachine> the spine too except it takes care of itself
07:44:00 <mm_freak> try that with an infinite list
07:44:12 <FunctorSalad> mm_freak: sure it makes a difference; I mean the 'more strict' we're talking about isn't really strictness of scanl in that sense
07:44:39 <FunctorSalad> but something about bottoms "deeper" in the arguments
07:46:04 <mm_freak> well, the strictness of scanl is a bit more complicated
07:46:51 <mm_freak> hmm, it behaves strangely btw
07:46:57 <mm_freak> > scanl (\x y -> 0) undefined [1,2,3]
07:46:57 <mm_freak> [*** Exception: Prelude.undefined
07:47:01 <mm_freak> that surprises me
07:47:23 <mm_freak> ah, sure
07:47:29 <mm_freak> > tail $ scanl (\x y -> 0) undefined [1,2,3]
07:47:29 <mm_freak> [0,0,0]
07:47:36 <mm_freak> and:
07:47:38 <mm_freak> > scanl undefined 0 []
07:47:38 <mm_freak> [0]
07:47:56 <FunctorSalad> maybe I'm being anal about the definition of 'strict' but you started the distinguishing of finer points of the terminology o_o
07:48:25 <FunctorSalad> @src scanl
07:49:00 <mm_freak> FunctorSalad: well, in its essence strictness is a property of single-argument functions
07:49:14 <FunctorSalad> yes.
07:49:28 <mm_freak> as you said:  f ⊥ = ⊥
07:49:39 <FunctorSalad> though for multiple-arg functions you can ask whether the result is strict for a given first arg
07:49:58 <benmachine> mm_freak: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29906#a29907
07:50:02 <mm_freak> all functions in haskell are single-argument functions, because (->) is right-associative
07:50:03 * hackagebot list-tries 0.4 - Tries and Patricia tries: finite sets and maps for list keys  http://hackage.haskell.org/package/list-tries-0.4 (MattiNiemenmaa)
07:50:08 <benmachine> my version is less strict in the input list
07:50:08 <mm_freak> a -> b -> c = a -> (b -> c)
07:53:27 <mm_freak> benmachine: in what way?
07:54:37 <benmachine> :q
07:54:39 <benmachine> erm
07:55:49 <benmachine> mm_freak: btw, your scanl' doesn't equal scanl
07:56:05 <benmachine> if you fixed that it would be easier to compare our results :P
07:56:17 <mm_freak> benmachine: indeed
07:56:28 <benmachine> as in
07:56:29 <benmachine> ghci> scanl' (+) 0 [1,2,3]
07:56:29 <benmachine> [1,3,6,6]
07:56:29 <benmachine> ghci> scanl (+) 0 [1,2,3]
07:56:32 <benmachine> [0,1,3,6]
07:57:05 <mm_freak> benmachine: if i fixed it, our versions are going to be equal
07:57:26 <benmachine> mm_freak: possibly. but yours just always repeats the last element of the list
07:57:51 <mm_freak> yeah, it's broken
07:57:58 <mm_freak> it omits the first element and repeats the last
07:58:22 <mm_freak> but other than that i think they are the same
07:58:25 <benmachine> mm_freak: but you could fix it in a way that was still different; what I meant originally is that my version is productive without pattern-matching on the list
07:59:06 <benmachine> so for example head (scanl undefined z undefined) == z
08:01:54 <mm_freak> benmachine: remember that 'case' is strict, too
08:02:59 <benmachine> mm_freak: yes, but case is inside the cons
08:03:08 <benmachine> and by yes, I mean, no
08:03:13 <benmachine> ghci> length $ case undefined of foo -> foo : []
08:03:13 <benmachine> 1
08:03:30 <benmachine> case matches constructors strictly
08:03:31 <mm_freak> benmachine: well, your version gives at least the (:) right away
08:03:39 <benmachine> mm_freak: indeed, which is all it can do
08:03:43 <mm_freak> but without content, because for that you absolutely must pattern match against the list
08:04:10 <benmachine> it gives you z : thunk
08:04:16 <benmachine> where z is already evaluated
08:06:55 <sshc> "Could not deduce (IArray a e2) from the context (IArray Array e2)"  How is that possible?
08:07:15 <benmachine> sshc: a /= Array?
08:07:31 <benmachine> it thinks it needs more instances than you've given it?
08:08:51 <dom96> what's the best way to listen for any POST requests in haskell? is there some kind of HTTP server that I could use?
08:09:29 <sshc> benmachine: There's an instance "IArray Array e"
08:10:23 <benmachine> sshc: right, the error message is saying "you seem to need an instance forall a, but there isn't one"
08:10:38 <benmachine> that's what I read it as saying anyway
08:11:46 <sshc> benmachine: Why would it need forall a.?  Why couldn't GHC constrain it?
08:12:09 <benmachine> sshc: that depends on your code
08:12:15 <benmachine> want to paste it?
08:12:28 <Olathe> sshc: Did you import Data.Array.IArray?
08:13:25 <sshc> Olathe: Yes
08:13:32 <Phyx-> I forget, when Is a type considered closed again?
08:16:57 <mm_freak> dom96: there are many HTTP server libraries for haskell
08:17:00 <mm_freak> check out hackage
08:17:18 <mm_freak> there are even complete frameworks like happstack
08:17:18 <dom96> mm_freak: doing that now
08:18:10 <ManateeLazyCat> dom96: Still on irc library? :)
08:18:51 <dom96> ManateeLazyCat: i want to add github service hook capabilities to my IRC Bot :P
08:19:14 <ManateeLazyCat> dom96: I'm developing my irc client... ManateeIrcClient is my bot. :)
08:19:17 <benmachine> doesn't github have an API?
08:19:29 <ManateeLazyCat> dom96: BTW, i have improve your code.
08:19:34 <ManateeLazyCat> dom96: Do you want view?
08:19:50 <dom96> ManateeLazyCat: sure
08:20:08 * ManateeLazyCat pasted "Messages.hs" at http://paste2.org/get/984163
08:20:11 <ManateeLazyCat> dom96: Above.
08:20:11 <dom96> benmachine: this is what i want to implement, http://help.github.com/post-receive-hooks/
08:20:45 <ManateeLazyCat> dom96: Ignore pickStream, other is same.
08:20:55 <pdc> I'm trying to use randomRs to generate some Floats (or Doubles) but instead get a list of Infinity. It works for other types. This is a new installation of haskell but I'm fairly sure this worked the last time I tried. Is this not the way to do it anymore?
08:21:07 <benmachine> dom96: so the bot gets posted to?
08:21:12 <dom96> benmachine: yes
08:21:24 <xplat> this has bothered me for a while, but: what are iteratees?
08:21:37 <dom96> ManateeLazyCat: You know that i have encodeCommand implemented somewhere as showCommand :P
08:21:40 <FunctorSalad> unfoldr is such a neat function for stuff where you think you need state :)
08:21:40 <ManateeLazyCat> dom96: BTW, if you use B.last, you must use B.null check ByteString whether is null.
08:21:59 <FunctorSalad> and way more lightweight than a state monad...
08:22:04 <ManateeLazyCat> dom96: Sorry, Messages.hs will change much in my irc client.
08:22:17 <benmachine> xplat: they're sort of a generalisation of left-folds
08:22:25 <dom96> ManateeLazyCat: no problem, thanks for sharing your code :)
08:22:38 <benmachine> xplat: they were originally invented to replace lazy I/O as a way of efficiently processing e.g. files and other streams
08:22:40 <dom96> I actually made a lot of changes too.
08:22:55 * notabel waves
08:23:01 <benmachine> I believe that's what they were for anyway
08:23:09 <ManateeLazyCat> dom96: BTW, i think Char8 is not correct, maybe we should use [Word8] in Data.ByteString.
08:23:20 <notabel> dom96: i baked pound cakes instead of dealing with your code yesterday
08:23:28 <ManateeLazyCat> dom96: Char8 will cut Unicode string.
08:23:38 <notabel> but i shall today
08:23:39 <benmachine> xplat: the upshot is they are harder to use than lazy IO but it's much easier to ensure that files are closed when finished with, etc.
08:23:54 <benmachine> xplat: because they are wholly deterministic
08:24:05 <xplat> as opposed to being closed before they are finished with?
08:24:08 <benmachine> xplat: they also support vertical and horizontal composition, which is neat
08:24:10 <ManateeLazyCat> dom96: Infact, i hope we use same basic library, just my framework is too special.....
08:24:11 <dom96> ManateeLazyCat: Char8 seems the simplest to use, i have no idea how to use [Word8]
08:24:17 <benmachine> xplat: no, as opposed to not being closed at all, typically
08:24:23 <benmachine> although that too I suppose
08:24:26 <dom96> notabel: ok, no worries.
08:24:27 <notabel> dom96: ManateeLazyCat is right that it would be better not to use Char8, either use word8 and maje encoding someone elses problem, or use CompactString or Text
08:24:49 <ManateeLazyCat> dom96: I have test, if we use Char8, just correct when latin-1 or ASCII
08:24:50 <notabel> CompactString is bytestring that knows its own unicode encoding
08:25:09 <notabel> whereas Data.Text converts evertyhing to UTF-16 internally
08:25:23 <ManateeLazyCat> dom96: Now, i'm testing basic framework, i will switch to [Word8] later to support Unicode.
08:25:33 <mauke> I am morally opposed to UTF-16
08:25:44 <xplat> it sounds like they are easier to use, if they prevent mysterious leaks and race conditions :)  harder to LEARN to use, obviously, but ...
08:25:48 <mauke> I guess that means I can't use Data.Text
08:25:54 <dom96> well then I guess i have another problem to fix.
08:26:13 <benmachine> xplat: lazy IO is very easy to use badly :)
08:26:15 <vanadium> mauke: How do you feel about UTF-8?
08:26:18 <notabel> mauke: morally opposed to an encoding?  pray tell
08:26:28 <ManateeLazyCat> @hoogle CompactString
08:26:38 <mauke> vanadium: I like it
08:26:40 <xplat> ah i guess i don't count using badly as use :P
08:26:53 <Olathe> Data.ByteString.Lazy.UTF8
08:27:04 <notabel> ManateeLazyCat: http://hackage.haskell.org/package/compact-string (google beats hoogle)
08:27:45 <benmachine> dom96: p.s. if your needs are very simple, you don't necessarily need to use a library to process POSTs - HTTP is an easy protocol
08:27:55 <ManateeLazyCat> notabel: Thanks,
08:28:06 <vanadium> http is probably easier than happstack
08:28:08 <xplat> (i guess actually i count it as unsuccessful use so something you use unsuccessfully a lot is not easy to use)
08:28:39 <xplat> benmachine: is there a good place to learn to use iteratees?
08:28:39 <benmachine> xplat: well, there are uses of lazy IO that work, but it's much harder to prove that they are well-behaved, even if they seem to be most of the time
08:28:58 <benmachine> xplat: there are lots of papers floating around, I don't know of any particularly good ones
08:29:02 <dom96> benmachine: hrm, i don't know. Seems much easier to use an existing http library than to use raw sockets.
08:29:30 <xplat> benmachine: what you say about lazy IO you could just as easily say about shared-heap threads in java or something
08:29:33 <notabel> dom96: what are you doing with http?  slient or server
08:29:40 <benmachine> dom96: it could well be, but it would be far from impossible to do it manually
08:29:40 <dom96> notabel: server
08:30:03 <notabel> ah.
08:30:06 <benmachine> xplat: I know approximately zero java
08:30:19 <ManateeLazyCat> notabel: I have a bit tired to handle variant encoding, both file-manager and irc-client...
08:30:25 <dom96> github docs have a nice piece of sinatra code.
08:30:38 <dom96> would be good if i could do it as easily as that heh
08:31:07 <benmachine> dom96: I just mentioned it because it strikes me that most HTTP server libraries are going to be designed to handle thousands of requests per second, while you want to handle tens of requests per month :)
08:31:10 <ManateeLazyCat> dom96: http://www.flickr.com/photos/48809572@N02/4943815462/lightbox/ still in developing...... not perfect
08:31:17 <xplat> (and i wouldn't be surprised if the same thing happened where 95+% of the time 'seems to work fine all the time' -> doesn't actually work all the time and will fail mysteriously once the code is used for reals
08:32:07 <dom96> benmachine: heh, good point. I'm worried about parsing the headers and such, that github sends.
08:32:16 <xplat> so this makes me think i should definitely learn iteratees
08:32:33 <dom96> ManateeLazyCat: nice
08:33:16 <benmachine> dom96: I would start off by trying to use a "proper" HTTP library but, I dunno, keep your options open
08:33:36 <ManateeLazyCat> notabel: Do you use compact-string, how about vs text?
08:33:36 <benmachine> http is a sufficiently simple protocol that I once served someone a page using netcat >_>
08:34:29 <benmachine> xplat: well, if you need them, yeah :) but beware that I think the API either just underwent or is about to undergo a fairly bug reshuffle
08:35:01 <xplat> benmachine: i wrote a shell script to do that automatically (serve files with netcat) but http is not a simple protocol
08:35:38 <benmachine> xplat: well, okay
08:36:02 <benmachine> xplat: and that's just underwent, I think
08:36:10 <xplat> it is a lot simpler for the server than the client though
08:36:56 <sshc> I'm trying to modify an array of Chars, but GHC is trying to deduce strangely even when I omit the type signatures
08:37:25 <benmachine> sshc: hpaste!
08:37:30 <xplat> and similarly, simpler for clients than proxies
08:37:39 <sshc> benmachine: Where?
08:39:25 <benmachine> sshc: hm?
08:39:30 <benmachine> sshc: show us the code
08:39:42 <benmachine> is what I meant
08:41:57 <ManateeIrcClient> benmachine: I guess sshc don't know where the hpaste. 
08:43:00 <benmachine> ManateeIrcClient: well, sshc's been around a while, and it's in the topic, so I assumed otherwise
08:43:10 <benmachine> but maybe I'm wrong, in which case I can be corrected
08:43:21 * hackagebot ltk 0.8.0.8 - Leksah tool kit  http://hackage.haskell.org/package/ltk-0.8.0.8 (HamishMackenzie)
08:43:51 <ManateeIrcClient> dom96: I'm a bot of ManateeLazyCat, if you like i will send Messages.hs to you after i port to [Word8] 
08:44:05 <ManateeIrcClient> dom96: Maybe you need change all your Char8 code, that
08:44:10 <ManateeIrcClient> not correct.
08:44:22 <dom96> Yeah, that would be great.
08:44:23 * hackagebot leksah-server 0.8.0.8 - Metadata collection for leksah  http://hackage.haskell.org/package/leksah-server-0.8.0.8 (HamishMackenzie)
08:44:25 * hackagebot leksah 0.8.0.8 - Haskell IDE written in Haskell  http://hackage.haskell.org/package/leksah-0.8.0.8 (HamishMackenzie)
08:44:35 <sshc> benmachine: Everything works fine when I import Data.Array instead of Data.Array.IArray.
08:44:40 <sshc> Strange
08:44:57 <ManateeIrcClient> sshc: best to paste your code
08:45:28 <sshc> ManateeIrcClient: I don't need to anymore; it works
08:46:21 <BrianHV> I'm trying to create a "class level" function, but I'm starting to think I'm going about this the wrong way.  any clues?  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29908#a29908
08:46:40 <xplat> it strikes me that a lot of the potential of darcs's 'theory of patches' is wasted because it is not integrated with a smart IDE
08:47:13 <ManateeLazyCat> xplat: Graphics merge?
08:47:42 <tommd> BrianHV: There are a number of issues.
08:47:57 <xplat> nonono, i mean the other end.  recording changes smartly in such a way that they merge better to begin with.
08:48:18 <tommd> BrianHV: 1) describe = getFamily  -- there is no point in defining a synonym for getFamily like this, but I guess if it makes you happy
08:48:59 <benmachine> BrianHV: describeList xs = getFamily (head xs) would work fine (note that head isn't evaluated, so it doesn't matter if xs is empty)
08:49:14 <tommd> BrianHV: 2) describeList probably wants to accept a heterogenious list?  And you probably want to use "map getFamily" and return [String]
08:49:20 <BrianHV> benmachine: interesting.
08:49:21 <ManateeLazyCat> xplat: If i have more time, i plan build a Graphics client for darcs.
08:49:32 <BrianHV> benmachine: I keep forgetting how pervasive laziness is.
08:49:35 <benmachine> BrianHV: it'd be a bit misleading
08:49:38 <tommd> BrianHV: Yes, compare my #2 to benmachines comment.  It could be one or the other but not both
08:49:47 <ManateeLazyCat> xplat: Then we can merge some complicated patch with visual feedback...
08:50:01 <benmachine> tommd: a heterogenous list, eh
08:50:08 <tommd> BrianHV: and that "[] : [Foo]" really doesn't make sense.
08:50:08 <BrianHV> tommd: actually, I'm doing this specifically because I want a homogenous list, but I want to be able to do things based on the type of the list
08:50:12 <tommd> benmachine: yes, thank you
08:50:24 <benmachine> tommd: [] :: [Foo] does
08:50:34 <benmachine> BrianHV: see also Typeable?
08:50:46 <xplat> ManateeLazyCat: yeah, a good idea, but orthogonal to my thought
08:50:59 <BrianHV> benmachine: will check, thanks
08:51:02 <tommd> benmachine, BrianHV: Ok, so I'm too tired.  I mentally thought of [] :: [Foo] as [] : [Foo] (concatenation).
08:51:08 <tommd> Yes, typing the list makes sense, sorry.
08:51:41 <benmachine> BrianHV: but you could also do instance Describable a => Describable [a] where ...
08:51:42 <xplat> i was thinking more like 'have your ide rename this function in this module and rename all callers'
08:51:47 <ManateeLazyCat> xplat: Here is my project : http://www.flickr.com/photos/48809572@N02/ , i think it's easy to bulid darcs-client if i have more time.
08:51:55 <xplat> and it becomes one patch
08:52:01 <ManateeLazyCat> xplat: That's need refactory integrate with IDE.
08:52:17 <xplat> ManateeLazyCat: yes
08:52:28 <xplat> but also with darcs
08:52:45 <BrianHV> benmachine: now *that*... seems like a good idea to me.
08:53:09 <ManateeLazyCat> A better idea is keep patch little enough and push soon as possible, then less conflict.
08:54:00 <xplat> no, that is not a better idea.  i mean it is also a good idea, but some patches, like the rename refactor, are not helped by making them in smaller chunks
08:54:19 <xplat> what helps them is to have more structure, more semantics, so they can commute cleanly with other patches
08:54:24 <benmachine> BrianHV: I think Typeable could be a correct approach, GHC can even derive your instances for you in that case :) but you can do what you like of course
08:54:45 <benmachine> actually, what you're doing now is fine
08:55:07 <ManateeLazyCat> xplat: Not easy about rename, special rename everywhere, and change many APIs.
08:55:24 <BrianHV> benmachine: I'll try both and see what I like. :)
08:55:43 <xplat> with refactorings as elemental patches in darcs you could do a rename function and easily merge it with a patch that added callers
08:55:58 <xplat> clean, no need for manual intervention
08:55:59 <benmachine> xplat: I'd love that
08:56:03 <BrianHV> I'm deliberately playing around with some potentially ugly stuff right now to see how far I can push the language and my understanding of it
08:56:12 <ManateeLazyCat> xplat: Yeah, that's cool.
08:56:22 <benmachine> xplat: only problem is you're then making it haskell-specific, a little
08:56:54 <ManateeLazyCat> benmachine: If have generical framework, it's not hard to support any language.
08:57:07 <xplat> benmachine: yes, for that reason i've been trying to think of a nice and safe way to describe it in terms of Harmony-style lenses or something
08:57:46 <benmachine> ManateeLazyCat: well ok but it's still a little less generic than typical version control systems
08:58:32 <benmachine> ManateeLazyCat: you have to think about things like qualified names, names defined in different modules, names appearing coincidentally in binary files
08:58:35 <benmachine> etc.
08:58:41 <xplat> lots of things i am not sure of yet, but the knowledge to do the refactorings would be part of the repository in some form (even if it's only a reference to a tool)
08:58:50 <ManateeLazyCat> benmachine: Yes, not easy.....
08:59:19 <benmachine> I would really appreciate more tools that manipulated source on an AST level though
08:59:24 <ManateeLazyCat> Now we need "code completion" "flymake" and "refactory" for Haskell IDE.
08:59:26 <benmachine> (or CST, whatever)
08:59:44 <ManateeLazyCat> "refactory" is hardest.......
09:00:00 <xplat> so you could do everything you could do in darcs now for any language, but with support being supplied in some form you could do much more
09:00:47 <ManateeLazyCat> xplat: I think that need change many APIs and behaviour of darcs to support your idea.
09:01:11 <xplat> ManateeLazyCat: probably
09:01:40 <xplat> thought of doing it as a separate tool also
09:02:00 <ManateeLazyCat> xplat: Maybe we can build absolute layout base on darcs.
09:02:11 <ManateeLazyCat> xplat: Then don't need change darcs.
09:02:58 <xplat> but to do things right i think it would either have to integrate closely with darcs or replace it
09:03:20 <xplat> and closely == closer than current APIs allow
09:03:47 <ManateeLazyCat> xplat: Yep, if you want support any language, it's need refactory darcs.
09:04:31 <dom96> ManateeLazyCat: are you sure Char8 doesn't work with unicode, because ElysiaBot seems to not have any problem with it.
09:04:45 <ManateeLazyCat> dom96: I'm not sure.
09:05:05 <dom96> /msg ElysiaBot |say ত সংখ্যাগুলো ব্যাবহৃত হয় ছাপারযোগ্য বর্ণ সমূহের জন্য।
09:05:08 <ManateeLazyCat> dom96: But i send Chinese from ERC, my irc client can't display it correctly.
09:05:25 <ManateeLazyCat> dom96: Do you use ElysiaBot now?
09:05:36 <dom96> yes, it's online.
09:05:55 <ManateeLazyCat> dom96: Chinese test : 你的客户端可以正常显示吗？
09:06:20 <dom96> <dom96> |say 你的客户端可以正常显示吗？
09:06:20 <dom96> <ElysiaBot> 你的客户端可以正常显示吗？
09:06:23 <dom96> works
09:06:35 <ManateeLazyCat> dom96: Hmm... maybe i'm wrong.
09:07:34 <xplat> iirc Char8 can get unicode and echo it back out, but cannot do complex processing on unicode correctly
09:07:50 <mauke> Char8 can't get unicode
09:07:51 <ManateeLazyCat> dom96: http://www.flickr.com/photos/48809572@N02/4979951332/lightbox/
09:07:58 <mauke> but irc doesn't use unicode either
09:08:25 <dom96> ManateeLazyCat: maybe GTK problems?
09:08:42 <xplat> mauke: 'can't get' in what sense?
09:08:43 <ManateeLazyCat> dom96: In principle, Char8 is not correct, because it haven't space fill unicode.
09:09:17 <ManateeLazyCat> dom96: I saw RFC say IRC just use Char8.
09:09:27 <xplat> all i'm saying is that it won't mangle unicode on pure passthru
09:09:38 <ManateeLazyCat> dom96: Well, i will investigate this problem later.
09:09:39 <mauke> yes, it will
09:09:43 <dom96> The only reason i am using Char8 is because it's pack function takes a String.
09:09:46 <mauke> you can't pass unicode through Char8
09:10:10 <dom96> mauke: it doesn't seem to mangle it.
09:10:26 <mauke> dom96: try pack "\1234"
09:10:47 <ManateeLazyCat> > Data.ByteString.Char8.pack "\1234"
09:10:59 <xplat> mauke: oh, you are talking will it mangle haskell's unicode strings.  yes, of course.
09:11:14 <dom96> "\210"
09:11:18 <xplat> i am talking ones that come in as bytestrings
09:11:27 <mauke> those aren't unicode
09:12:18 <xplat> sure, they're not in a technical sense
09:12:30 <xplat> but it is enough to echo back some chinese characters on IRC
09:12:46 <mauke> yes, because irc doesn't use unicode
09:13:47 <xplat> we seem to agree on what D.BS.Char8 does, just not on what to call it
09:14:30 <notabel> truncation
09:15:41 <sshc> How is mplus defined for Maybe?
09:16:28 <Phyx-> @src MonadPlus Maybe
09:16:36 <Phyx-> aww botty...
09:16:36 <Twey> mplus Nothing a = a; mplus v@(Just _) _ = v
09:17:01 <spuz> How can a write a function that takes a String and converts it to a list of Ints for each digit? I.e "12345" -> [1,2,3,4,5]
09:17:08 <Twey> spuz: map digitToInt
09:17:57 <spuz> Twey: thanks
09:18:10 <Twey> You're welcome
09:19:21 <xplat> where is digitToInt?
09:19:23 <Twey> joyfulgirl: I didn't know you were a Haskeller
09:19:29 <Twey> xplat: Data.Char, I think
09:19:36 <Twey> Yes
09:19:44 <xplat> Twey: thanks
09:20:09 <joyfulgirl> Twey: I'm working on teaching myself, actually
09:20:31 <ManateeLazyCat> dom96: Your bot use gtk ?
09:20:43 <dom96> no
09:20:48 * Twey boggles at the thought of a bot using a GUI toolkit.
09:21:02 <notabel> Twey: you're not alone in your boggling
09:21:05 <Twey> joyfulgirl: Ah, cool.  Using TryHaskell or something?
09:21:07 <dom96> indeed
09:21:44 <xplat> > (foldl $ (+) . (10*)) 0 . (map digitToInt) $ "12345"
09:21:53 <joyfulgirl> Twey: A couple of books available online, actually, but I'm taking my time.
09:21:57 <Twey> No λb :-\
09:22:06 <Twey> joyfulgirl: Oh, okay.
09:22:45 <ManateeLazyCat> dom96: Ok.
09:25:11 <illissius`> hmm
09:25:26 <illissius`> do we know anything about GHC 7 beyond that one post by SPJ on a mailing list?
09:30:37 <otto_s> > let h a b = a : h b (a+b) in h 1 2 !! 30
09:42:34 <tommd> illissius: Yes, look at the GHC darcs repo then you know everything about GHC 7.
09:42:47 <tommd> illissius`: ^
09:43:00 <FunctorSalad> how is ghc 7 defined?
09:43:14 <FunctorSalad> in contrast to 6.1x
09:43:35 <tommd> FunctorSalad: SPJ said GHC 6.14 might never exist and instead they will release 7.0 - this is due to the new type system code SPJ wrote.
09:43:45 <tommd> See the ML for his exact words.
09:43:48 <FunctorSalad> I see :)
09:44:01 <luite> when did the post this?
09:44:02 <luite> he
09:44:12 <tommd> Early this week I think.
09:44:16 <tommd> Perhaps on the GHC ML.
09:44:20 <tommd> probably on the GHC ML
09:44:53 <tommd> Also, the monads-fd --> MTL rename might happen soon.  Finally.
09:45:31 <monochrom> great, so there will be mtl, MTL, mTL, MtL, MTl...
09:45:45 <Zao> Is it considered "better" than -tf or something?
09:46:16 <tommd> monochrom: No, the caps were my doing.  The "mtl" library is going away as you know it.  The next major version of "mtl" will be the  "monads-fd" package renamed.
09:46:17 <FunctorSalad> o_O the existing confusion was insufficient?
09:46:21 <FunctorSalad> ah
09:46:27 <tommd> Zao: Perhaps more widely supported
09:46:28 <illissius`> iirc he didn't explicitly say "no 6.14, 7 instead", just referred to "GHC 7" in passing, which caused most people (myself included), who hadn't heard of it previously, to go "omg! ghc 7!"
09:46:29 <monochrom> oh fun
09:46:40 <FunctorSalad> that sounds better than a significant-caps renaming, yes
09:46:58 <Zao> illissius`: I assume there's a different list than cvs-ghc?
09:47:08 * monochrom releases basE
09:47:10 <illissius`> Zao: glasgow-haskell-users
09:47:16 <illissius`> (i think that's the name..)
09:47:17 <Zao> Meeh.
09:47:18 <tommd> illissius`: Right, but he discussed releasing his type system code so soon I'm doubtful 6.14 will be out before then.
09:47:26 <Zao> I hate when there's more than one dev list for a project.
09:47:41 <monochrom> ghc release candidate will happen before ICFP begins
09:47:42 <Zao> I guess it's not a dev list per se though :D
09:47:56 <monochrom> ICFP is some time this month
09:48:22 <monochrom> "users" doesn't sound devish...
09:49:07 <tommd> So SPJs words were " Yes, I've spent most of the last month working on the new type checker, and unless there's a major hiccup it'll be in GHC 7.0.  We'll produce a release candidate just before ICFP."
09:49:07 <Zao> I've seen the name in passing before, but thought it was about Haskell users in Glasgow...
09:50:06 <illissius`> Zao: the G in GHC doesn't stand for GNU (;
09:50:32 <FunctorSalad> 'glorious' or 'glasgow'?
09:50:36 <Zao> "Glorious" :D
09:50:49 <illissius`> short version: Glasgow Haskell Compiler
09:50:57 <illissius`> long version: The Glorious Glasgow Haskell Compilation System
09:51:04 <illissius`> obviously the long version is awesomer.
09:51:08 * FunctorSalad prefers the long version
09:51:09 <FunctorSalad> =)
09:51:18 <tommd> "Glorious Glasgow Haskell Compiler for Galoigeans"
09:51:27 <Zao> I may be tainted by boost-users, which is basically just a help list while boost-devel has all the juicy discussion.
09:52:32 <illissius`> Zao: nah, I also expected cvs-ghc to have all the interesting dev discussions, but in practice much of them are on g-h-u instead (or at least discussions between devs and users)
09:52:47 <tommd> Zao: I think the GHC-users list has remained quiet enough they just never split off a GHC-devel list.  All the -users discussion occurs on stackoverflow, reddit, irc, haskell-cafe, haskell-beginners, etc.
09:52:49 <illissius`> whereas cvs-ghc just has commit messages
09:53:49 <Zao> illissius`: There's decent talk on cvs- too, it's just rather sporadic.
09:54:19 <Zao> It has apparently been sufficient for me to not investigate the existence of another list.
09:55:50 * syntaxglitch was trying to explain why type classes are useful on SO the other day to someone trying very hard to not understand
09:56:28 <ManateeLazyCat> G'night all. :)
09:57:23 <syntaxglitch> did kind of make me wonder how best to present type classes to people who don't already know Haskell
09:57:37 <illissius`> it's basically like interfaces in OO languages except the instance declarations are decoupled from the type declarations
09:58:07 <illissius`> (that's for the simple cases -- the more complex ones (MPTC, etc.) aren't even possible with OO interfaces)
09:58:12 <syntaxglitch> except they're rather more expressive than interfaces, and don't have a real notion of subtyping
09:58:35 <illissius`> well "they're like interfaces except more powerful" should be a good starting point
09:58:37 <monochrom> I use "how to make x+y work for Int, Integer, Double, even types created by you" to introduce type class.
09:59:02 <illissius`> surely most people coming from an OO background recognize why interfaces are useful
09:59:03 <shapr> I still want cabal -j3
09:59:05 <syntaxglitch> monochrom, that was pretty much the approach I took
09:59:31 <monochrom> of course the premise is we accept strong typing or even strong static typing.
09:59:52 <monochrom> if you prefer duck typing, end of story already
10:00:20 <syntaxglitch> illissius`, yeah, but just "more powerful" doesn't always sell people on it, they'll just think "well interfaces do what I need, why do I need something new"
10:01:18 <illissius`> syntaxglitch: ah, so the question isn't "why have type classes at all", but "why have type classes rather than interfaces"
10:01:32 <syntaxglitch> monochrom, yeah, that's a whole different issue, I was thinking mostly about pitching it at people who use a mainstream language with "static typing"
10:02:14 <illissius`> in that case I don't know anything better than just showing them examples of useful things you can do with typeclasses but not interfaces =)
10:02:14 <syntaxglitch> illissius`, yeah, how to explain what type classes offer above and beyond interfaces
10:03:05 <syntaxglitch> what example would you pick? It's hard to find something that's 1) easy to explain 2) clearly and immediately useful 3) completely impossible to do with interfaces
10:03:24 <monochrom> a c++ person will say "overloading", so type class is just more organized, more well-checked overloading, e.g., error message says the more readable "your type X is not in type class Num" rather than "I'm now deep into STL internal code line 2938 and x+y doesn't make sense there"
10:04:14 <illissius`> ah, well if someone is familiar with formerly-C++0x concepts you can just say "it's like that"
10:04:20 <monochrom> OTOH people have incentives to not understand.
10:05:24 <syntaxglitch> monochrom, you meant line 2938 in the compiler error message produced by STL stuff, right? :)
10:05:25 <notabel> illissius`: that is a powerful explanation useful on a vanishingly small set of people :-)
10:05:43 <illissius`> yep :)
10:07:02 <monochrom> haskell isn't OO, doesn't need OO kind of interface, wouldn't fit
10:07:48 <monochrom> the first mistake is to compare them and even try to find out which one is superior
10:08:28 <Funktorsalat> interfaces ~= existentials with a ridiciculous restriction
10:08:32 <Funktorsalat> ;)
10:08:44 <Funktorsalat> ("signatures must be of the form a -> Constant")
10:08:56 <illissius`> monochrom: type classes seem to be pretty clearly a superset of interfaces, but w/e
10:08:59 <monochrom> a related mistake is to compare parametric polymorphism with subclassing
10:09:01 <illissius`> *to me to be
10:09:08 <Cale> I also wish that the original paper introducing typeclasses hadn't mentioned "ad-hoc polymorphism" so prominently.
10:09:43 <syntaxglitch> illissius`, they probably are if you ignore the whole idea of subtyping
10:10:51 <syntaxglitch> of course, I still maintain that the standard mainstream OO concept of inheritance is stupid and broken anyway but that's probably just me :\
10:11:39 <Philippa> Cale: hysterical raisins strike again
10:13:14 <illissius`> syntaxglitch: type classes and OO interfaces both have "subtyping" of interface but not implementation, afaict
10:14:25 <xplat> iteratees seem a lot like a cleaner, more composable version of the sort of API that C libraries like gzip use
10:14:54 <illissius`> OO languages have "subtyping" (in scare quotes because i'm not sure if it's the technically correct term) of both interface and implementation but conflate the two, haskell only has it for interface (while OO interfaces by definition come without an implementation, so that part matches up)
10:17:27 <syntaxglitch> pf, aren't iteratees are just the free monad of a Kleisli arrow functor or some such? What's the big deal about that...
10:18:12 <illissius`> anyway, maybe it's because I'm coming from a C++ background myself (gasp, etc), but if I had to try to quickly explain things to OO people I think "parametric polymorphism = sort of like templates/generics", "type classes = sort of like interfaces" is what I'd go with
10:18:59 <syntaxglitch> illissius`, I think the difference mostly comes in when you're dealing with existential-ish stuff
10:19:18 <Funktorsalat> isn't it more accurate to liken interfaces with existentials or more suggestively existentially wrapped tcs...
10:19:41 <Funktorsalat> maybe just explain TCs in terms of the dictionary-passing they compile down to?
10:19:53 <illissius`> yeah, existential/universal quantification is definitely a difference, but I think you cross that bridge when you come to it
10:20:49 <syntaxglitch> well, half the point of interfaces is being able to forget the implementation type and only see the interface
10:21:19 <syntaxglitch> doing the same things in Haskell requires jumping through various hoops with type system extensions
10:21:25 <xplat> < illissius`> (that's for the simple cases -- the more complex ones (MPTC, etc.) aren't even possible with OO interfaces) <-- when i was younger i spent a lot of time working on an extension to cecil's support for simple and typesafe declaration of types with binary methods (like Comparable) to support operations involving multiple types (like scalar multiplication on vector spaces).  when i later realized what i had invented was just a verbose version of MPTC
10:22:11 <xplat> at least i realized it before MPTC were actually implemented :-7
10:23:16 <monochrom> good job
10:24:25 <illissius`> syntaxglitch: "forall a. SomeClass a => a" and "exists a. SomeClass a => a" (or *> or whatever) both let you see only the interface, no?
10:26:15 <illissius`> I'm actually not 100% clear on the universal-vs-existential-quantification-in-OO-versus-functional-languages thing, but I've noticed that the universal/existential distinction in haskell seems to give you co/contravariance "for free", whereas OO languages need explicit annotations
10:26:43 <syntaxglitch> I think it gets a little trickier than that, especially if you want to do things like, say, have a list of things that are instances of a type class, but aren't necessarily the same actual type
10:27:20 <syntaxglitch> but really, I'm convinced that 99% of the time that sort of thing isn't actually necessary, it's just what people coming from OOP think of first
10:27:32 <Olathe> Is (>> return ()) optimized away from a monad that already returns ()?
10:28:13 <xplat> Olathe: depends which monad
10:28:34 <illissius`> my sense is that in Haskell you sometimes use "SomeClass a => a", and sometimes you use existentials, whereas in C++ you only have SomeClass* in both cases
10:28:50 <illissius`> but again this is something which isn't fully clear in my mind yet either
10:29:03 <xplat> Olathe: also, about your problem last night: i wonder if you don't want to combine the state monad for handling input and the reverse state monad for handling output
10:29:20 <Olathe> There's a reverse state monad?
10:29:58 <mauke> yes, and reverse STRefs (sort of)
10:30:41 <xplat> http://lukepalmer.wordpress.com/2008/08/10/mindfuck-the-reverse-state-monad/
10:30:53 <Olathe> Ahh, thanks :)
10:31:44 <illissius`> syntaxglitch: and yeah, if you're writing straight haskell code you probably don't need it, but when, say, making bindings for a C++ class hierarchy, the correspondence is useful (;
10:31:45 <syntaxglitch> illissius`, my thought is that, since all you can do with "SomeClass a => a" is apply SomeClass's functions to it, why not just do that ahead of time and skip the GHC extensions
10:32:38 <syntaxglitch> the trivial example being a list of things that are instances of Show. Just make a list of Strings instead, it's practically the same thing
10:33:02 <mauke> syntaxglitch: that can get complicated
10:33:21 <illissius`> ("SomeClass a => a" is actually the universally quantified case, with GHC you need a wrapper type for existentials so I didn't type that one out)
10:33:39 <xplat> i find the best way to think of typeclasses is dually as 'conditions' that apply to some of the types in your signature and 'evidence' of those conditions
10:34:04 <syntaxglitch> mauke, it can, but it also tends to be nicer in Haskell than trying to do OOP with existentials and type classes
10:34:27 <mauke> how do you preapply class Foo a where bar :: a -> a -> a?
10:34:44 <illissius`> mauke: that doesn't even work with existentials though
10:34:56 <mauke> why not?
10:34:57 <syntaxglitch> mauke, you don't, but you also can't do anything with an existential version of that either
10:35:15 <illissius`> because you can't prove that the two existentials you have are actually the same type
10:35:19 <mauke> bar x x
10:35:30 <syntaxglitch> well, that
10:35:43 <mauke> bar x (bar (bar x x) x)
10:36:03 <syntaxglitch> anyway, yes, I know there are times when existentials are indeed useful
10:36:29 <illissius`> (unless you use the `data TypeEq a b where ProofEq :: TypEq a a` thing and provide a way to explicitly derive the proof)
10:36:31 <syntaxglitch> just not as often as people coming from OO languages seem to think at first
10:36:54 <lantti> I often accidently tried to do OOP style structures with type classes and existentials. Now I'm getting rid of the habit...
10:36:59 <illissius`> no disagreement from me on that point
10:37:25 <lantti> Mostly thanks to ski who pointed me to some schemewiki articeles about the subject.
10:37:27 <Mitar> hm, does exceptions propagade only inside a given thread?
10:37:49 <Mitar> lantii: can you point me to that?
10:38:03 <lantti> I'm searching :)
10:38:09 <benmachine> Mitar: see: throwTo
10:38:09 <Mitar> because i am probably just in that stage myself ;-)
10:38:22 <lantti> http://community.schemewiki.org/?object-oriented-programming
10:38:22 <benmachine> Mitar: by default, yeah
10:38:31 <lantti> That was one.
10:38:40 <Mitar> i have bracket and i want it that it cleans after the exception
10:38:52 <Mitar> but after it cleans I would like that it propagates also to all other threads
10:38:54 <xplat> an existential bounded by a unary typeclass can always be replaced with a record of functions corresponding to its dictionary, and sometimes (like show) you can basically reduce that to a single value
10:39:09 <benmachine> Mitar: it won't do so automatically, you can re-throw it
10:39:18 <xplat> it's only a matter of which is clearer and whether you have an independent reason to have that typeclass exist
10:39:20 <benmachine> @hoogle ThreadId
10:39:23 <benmachine> oh
10:39:26 <benmachine> drat it
10:39:26 <Mitar> but I have to know where to rethrowit?
10:39:30 <benmachine> Mitar: yes
10:39:45 <benmachine> Mitar: throwTo takes a ThreadId argument, you can find out yours with myThreadId
10:39:53 <Mitar> yes, but i do not need mine ;-)
10:39:53 <benmachine> and forkIO returns the ThreadId of the new thread
10:39:58 <Mitar> mine is already cleaned up
10:40:04 <Mitar> i want it to clean all other
10:40:09 <syntaxglitch> hm
10:40:20 <syntaxglitch> need more coffee
10:40:25 <Mitar> like i have a pool of threads: forkIO $ bracket_ start stop (run string)
10:40:40 <Mitar> when run throws an exception, stop is called, which is great
10:40:56 <Mitar> but i would like that afterwards all other threads gets interrupted
10:40:56 <benmachine> Mitar: there are lots of ways of passing messages to parent threads
10:41:04 <benmachine> the most obvious one would be
10:41:25 <Mitar> i hoped exceptions will take care of that ;-)
10:41:50 <lantti> Mitar: Other was http://okmij.org/ftp/Computation/Subtyping/
10:41:56 <Mitar> lantti: thanks
10:41:56 <benmachine> myThreadId >>= \id -> forkIO $ bracket_ start (stop >> killThread id) (run string)
10:42:22 <benmachine> that'll throw the ThreadKilled exception in the parent thread
10:42:36 <xplat> (and the record might have to have an existential quantifier too depending what's in it)
10:42:39 <benmachine> or see throwTo
10:42:41 <Mitar> ehm, not: myThreadId >>= \_ -> forkIO $ bracket_ start (stop >> killThread myThreadId) (run string)
10:42:54 <benmachine> Mitar: that's a type error
10:42:59 <benmachine> myThreadId :: IO ThreadId
10:43:14 <benmachine> killThread :: ThreadId -> IO ()
10:43:16 <Mitar> sorry, true
10:43:30 <Mitar> i read that you store id from forkIO into id
10:43:35 <benmachine> no
10:43:38 <Mitar> i see
10:43:41 <benmachine> I stored id from myThreadid
10:43:43 <benmachine> *Id
10:43:44 <Mitar> yes
10:43:50 <benmachine> discarded the one from forkIO
10:44:11 <Mitar> hmm
10:44:25 <lantti> Mitar: They are both totally unrelated to Haskell, but for me they cleared up a bit what I'm actually trying to do.
10:44:33 <benmachine> myThreadId >>= \id -> blah
10:44:36 <benmachine> is the same as
10:44:42 <benmachine> do id <- myThreadId; blah
10:44:45 <Mitar> yes
10:44:47 <benmachine> if that's easier for you
10:45:07 <xplat> does GHC do anything to GC threads or do they all hold onto their resources until they die on their own?
10:45:15 <Mitar> but doesn't "release resource" computation of bracket rethrows an exception itself ...
10:45:21 <xplat> istr it's the latter :(
10:45:22 <Mitar> is there a way to hook upon that?
10:46:25 <Mitar> because now if I throw an exception with throwTo in "release resource" computation to main thread
10:47:04 <Mitar> it will try to kill all threads, also the one which has thrown it an exception, hm
10:47:17 <Mitar> but probably it is not a problem
10:47:49 <Mitar> because at the moment it will start killing child threads first thread will be already unblocked from throwTo
10:48:17 <benmachine> Mitar: experiment!
10:48:17 <Mitar> so that is no way to hook upon thread exception handling? like GHCi hooks to print exception?
10:48:29 <benmachine> Mitar: oh, you could just use catch/handle
10:49:10 <Mitar> hm, why? i want setup/cleanup?
10:49:37 <benmachine> I'm confused
10:49:44 <sshc> How do I list breakpoints and delete a particular one/
10:49:46 <benmachine> what exactly can't you do, now?
10:49:57 <sshc> ?
10:50:06 <benmachine> sshc: you know about :?, right?
10:50:20 <sshc> I don't
10:50:24 <Mitar> i can do everything ;-) i would just like to find clean way
10:51:03 <sshc> Oh, :show breaks
10:51:06 <benmachine> sshc: oh, well, now you do :P
10:51:20 <Mitar> like not requiring for thread to remember to clean up parent thread, but that this would be done automatically (so that parent thread can setup that when it creates child thread, for example)
10:51:51 <br1> How can I disable GC so that heap profiling shows allocated data and not only live data?
10:53:56 <benmachine> Mitar: you could define your own forkIO that had a `finally` killThread
10:54:33 <Olathe> xplat: Thanks, that worked :) http://codepad.org/kbOz0iyY
10:54:57 <Mitar> you mean kill parent thread ...
10:56:14 <benmachine> yes
10:57:10 <xplat> Olathe: very worth it just to know that something so odd got used for something other than bending people's minds :)
10:58:30 <Olathe> Haha
11:03:19 <sshc> How do I determine whether an index is within the bounds of an array?
11:03:59 <benmachine> sshc: I think Data.Ix has functions for that
11:04:03 <benmachine> @hoogle inBounds
11:04:06 <benmachine> oh damn it
11:04:15 <tommd> sshc: use unsafeIndex and see if your program behaves...
11:04:25 <benmachine> inRange
11:08:18 <notabel> @let i `inRangeOf` a = inRange (bounds a) i
11:11:14 <Olathe> I don't think it's correct to call a do block a monad. What is it called?
11:11:59 <benmachine> Olathe: a do block?
11:12:04 <notabel> Olathe: a do block.  or a monadic value, which it is
11:12:13 <Olathe> Ahh, thanks :)
11:12:17 <kmc> "do block" or "do expression" is just a particular bit of syntax
11:12:31 <kmc> it's one way to build a monadic value, but there are others
11:13:08 <Olathe> @hoogle Mapper
11:13:14 <Olathe> Bah.
11:13:39 <kmc> Olathe, see http://www.haskell.org/haskellwiki/What_a_Monad_is_not and http://blog.plover.com/prog/haskell/monad-terminology.html
11:14:01 <sidek> What is the easiest (by metric of computing power needed) way to break up an integer into an ordered list? So 74 to [7,4].
11:14:14 <Olathe> Ahh, thanks :)
11:14:23 <kmc> sidek, as opposed to easiest to code?
11:14:24 <notabel> sidek: in an arbitrary base, or only in decimal?
11:14:31 <sidek> decimal
11:14:40 <sidek> kmc: yes
11:14:50 <Funktorsalat> illissius`: hmm "covariance for free"? we have explicit covariance, called 'functor' :)
11:15:07 <Funktorsalat> and contravariance in category-extras I gues ;)
11:15:12 <Funktorsalat> +s
11:15:22 <benmachine> sidek: the easiest to code would be an unfoldr involving divMod, and it's not straightforward to do better than that
11:15:39 <sidek> alright
11:15:40 <Funktorsalat> unfoldr++
11:17:55 <Funktorsalat> fastest would presumably be bit twiddling, especially if base 2^n is acceptable for you too
11:18:04 * hackagebot hlint 1.8 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8 (NeilMitchell)
11:18:05 <Funktorsalat> then it's just shfiting
11:19:46 <kmc> perhaps there is a trick for it in _Hacker's Delight_
11:21:13 <Funktorsalat> for fixed-width int's I reckon you'd unroll the thing too
11:21:34 <Funktorsalat> template haskle!
11:23:30 <Olathe> sidek: Here's a somewhat quick one: http://codepad.org/mM5F19RE
11:24:18 <Funktorsalat> sidek: you might also want to observe what ghc is doing to your code with ghc-core
11:24:24 <notabel> so, the best way to do base conversion is to estimate the logarithm, etc.  the unfoldr-with-divmod method is fine for short numbers though, just lots of integer divmod by 10 (one per output digit)
11:24:31 <sidek> alright
11:24:39 <notabel> reverse . unfoldr (\i -> if i == 0 then Nothing else let (d,r) = i `divMod` 10 in Just (r,d))
11:24:58 <notabel> that's the relatively naive digit-at-a-time variant
11:26:04 <sshc> Where is lambdabot??
11:26:21 <illissius`> Funktorsalat: I mean in OO languages if you have List<T>, by default you can't use List<Magpie> where you'd expect a List<Bird> unless you explicitly tell the compiler that List is covariant in its argument (this is the better case -- in C++ for example you just plain old can't); whereas in Haskell if you have `class IsBird a; class IsBird a => IsMagpie a; data Bird deriving IsBird; data Magpie deriving (IsBird, IsMagpie); foo :: IsBird 
11:26:23 <illissius`> a => [a] -> Whatever` it's trivially the case that you can pass [Magpie] to it
11:26:25 <benmachine> Olathe: if you did a case on the quotRem instead of a let, I think you wouldn't need the seq
11:26:28 <Funktorsalat> sshc: platonic heaven? :(
11:26:42 <xplat> how would you do less than one division per digit?
11:26:44 <benmachine> I might be wrong though
11:26:54 <kmc> illissius`, that's the crazy roundabout way of encoding OO in Haskell
11:27:00 <illissius`> kmc: I know.
11:27:05 <Olathe> benmachine: Ahh, OK :)
11:27:05 <kmc> not the simple way
11:27:07 <benmachine> xplat: there are other factors to consider, e.g. dividing small numbers is faster than dividing big numbers
11:27:19 <ben_m> What's the difference between divMod and quotRem?
11:27:28 <benmachine> ben_m: behaviour with negative numbers
11:27:29 <Funktorsalat> illissius`: hmm it seems haskell is the same for List<T>
11:27:35 <Funktorsalat> you have to Functor it explicitly
11:27:36 <benmachine> div rounds down, quot rounds towards zero
11:27:36 <ben_m> I see.
11:27:47 <illissius`> Funktorsalat: how do you mean?
11:28:51 <Funktorsalat> illissius`: maybe we're using different notions of 'covariance'. In my book, a type constructor is covariant iff it is a functor :)
11:29:08 <Funktorsalat> while covariance of typeclasses doesn't seem to be expressible
11:29:31 <xplat> haskell's polymorphism really isn't the same as OO polymorphism, and category covariance isn't the same as OO-generics covariance (although it is related)
11:29:39 <Funktorsalat> (it'd mean that an (A -> B) and Bird A gives you Bird B)
11:29:53 <Funktorsalat> xplat: I thought it was the same
11:30:00 <Olathe> quotRem works but divMod doesn't: http://codepad.org/hTaT5sS6
11:30:07 <Funktorsalat> if you use the category where objects are types and arrows are 'subclass of'
11:30:37 <illissius`> Funktorsalat: yeah I don't really know about the terminology, my point is basically the example I gave
11:30:42 <illissius`> what would you call it?
11:30:45 <Olathe> sidek: Here it is a little cleaner: http://codepad.org/87oGwNuh
11:31:12 <sidek> thanks
11:31:18 <Olathe> No problem.
11:31:30 <sidek> I guess divMod or quotRem versions probably suffice for most things
11:31:53 <sidek> yes, that probably works well enough
11:31:53 <xplat> Funktorsalat: well, kind of.  after all, category concepts are designed to apply to anything, and that's a fairly clean example.  but when we think of categories in haskell our arrows are usually functions, not subtype relations (which don't even exist in haskell)
11:33:06 <xplat> i probably should have said it was a different interpretation of the category-theoretical notion of covariance than is normally used in haskell circles, but i thought that would only be confusing
11:33:26 <Funktorsalat> illissius`: hmm your point is the superclass constraint? not sure how it'd fit into this
11:34:31 <xplat> in scala illissius`'s example would be communicated by declaring list as trait List[+A]
11:34:33 <Funktorsalat> xplat: I think of the OO case as the function case restricted to upcast "functions"
11:35:03 <illissius`> Funktorsalat: in C++ if you have `Whatever* foo( List<Bird*> ) { .. }` and try to pass a List<Magpie*> to it you get a type error, whereas the Haskell example I gave works
11:35:18 <Funktorsalat> e.g. f :: TextBox -> Control, f x = x
11:35:19 <Funktorsalat> ;)
11:35:23 <xplat> Funktorsalat: yeah, you can do that and i often do too
11:35:38 <vanadium> illissius`: are you sure
11:35:54 <erisco> is it possible to reverse a list in only one stack frame?
11:36:18 <erisco> I'm working on an implementation in miranda and just want to make sure I am not looking for something non-existent
11:36:26 <illissius`> I'm actually not sure whether this is because of the way Haskell separate interface and implementation via type classes, or because of how it separates universally vs. existentially quantified types, or what, and would actually be glad if someone explained it =)
11:36:31 <illissius`> vanadium: about which part?
11:37:57 <benmachine> erisco: haskell doesn't much bother with stack frames, I think
11:38:13 <vanadium> Sorry, I must have been confused about available list constructors
11:38:27 <xplat> if you have a m :: (Magpie a) => a and a function song :: (Bird b) => b -> String and an instance (Magpie t) => (Bird t) then you can write song m and it works and mathematically it looks pretty similar to the OO example
11:39:13 <benmachine> we don't normally do instances Magpie t => Bird t though
11:39:30 <xplat> but the difference is instead of implicit upcast functions being applied to Magpie instances you have implicit dictonary constructors being applied to Magpie dictionaries
11:39:32 <benmachine> because that instance overlaps with everything
11:39:51 <benmachine> class Bird t => Magpie t, on the other hand...
11:39:52 <erisco> benmachine: well, for recursion, you have to create a new frame for every call no? Yes, with optimizations such as tail recursion that doesn't happen
11:40:01 <benmachine> erisco: no
11:40:07 <benmachine> erisco: haskell doesn't work like that
11:40:24 <kmc> wow, people still use miranda?
11:40:25 <benmachine> erisco: or at least, it doesn't have to
11:40:34 <erisco> kmc: my university is using it for practice
11:41:06 <kmc> yeah, the Haskell report says nothing about stack frames, or indeed much of anything about operational details
11:41:09 <xplat> benmachine: yes, but in some sense that's a hack to make the instance search work better ...
11:41:25 <benmachine> xplat: no, not really
11:41:26 <xplat> so i didn't really worry about it in the example
11:41:40 <benmachine> xplat: overlapping instances are theoretically a bad thing
11:41:50 <benmachine> the problems with them aren't practical
11:41:51 <kmc> as for actual implementations, GHC's stack is used for a different purpose than you might be familiar with from C etc
11:42:46 <erisco> well, whether it deserves a different name or not, it still stands that the recursion cannot be optimized to loops in my current algorithm
11:43:04 <erisco> and given any decently sized list the stack space is exhausted
11:43:22 <benmachine> erisco: what's your current algorithm?
11:43:41 <kmc> erisco, stack space is exhausted by nested pattern matching, not by nested function application
11:43:45 <erisco> so, I am just asking, before I spend time looking, if haskell's list reverse is optimized
11:43:47 <xplat> benmachine: some of the problems are theoretical and some practical.  this is why there's -XAllowOverlappingInstances, so that when the problems are more theoretical and less practical you can use them.  the reverse also happens.
11:43:50 <benmachine> in theory, reverse should take constant space, but that probably depends on how attentive the GC is
11:44:11 <kmc> erisco, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/GHC-List.html#reverse
11:44:22 <erisco> I don't want to know their solution
11:44:32 <erisco> that kind of spoils the whole point
11:44:37 <benmachine> xplat: many people think that OverlappingInstances is a "bad thing" in that it tends to make programs significantly more fragile - by design
11:45:30 <erisco> does this channel have a haskell interpreter?
11:45:34 <kmc> yes
11:45:35 <kmc> > 2 + 2
11:45:40 <xplat> benmachine: i agree with them, mostly -- i tend to lean toward the theoretical side :)
11:45:41 * Funktorsalat stopped trying to do anything funny with typeclasses... You Probably Want A GADT :)
11:45:41 <kmc> she's gone right now :/
11:45:43 <roconnor_> 4
11:45:51 <kmc> thanks roconnor_ you're the best
11:45:58 <erisco> is her name roconnor_?
11:46:01 <kmc> no
11:46:03 <kmc> her name is lambdabot
11:46:21 <kmc> Cale, bring back our lambdabot pls :/
11:46:26 <Cale> done
11:46:26 <kmc> yay!
11:46:27 <Funktorsalat> lambdabot o'connor?
11:46:29 <Funktorsalat> :)
11:46:30 <kmc> thankye
11:46:32 <kmc> @bot
11:46:34 <roconnor_> :O
11:46:37 <lambdabot> :)
11:46:39 <kmc> @. elite nixon
11:46:43 <erisco> thanks Cale
11:46:47 <lambdabot> I 4/\/\ No7 a Cro0x.
11:46:48 <vanadium> > fix error
11:46:50 <roconnor_> W|-|@T
11:46:54 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
11:46:55 <vanadium> I missed you, lambdabot!
11:46:57 <erisco> now I just have to remember the function...
11:47:05 <kmc> @vixen how was your vacation?
11:47:06 <erisco> > reverse [1..10000]
11:47:11 <lambdabot> however you want
11:47:17 <lambdabot>   [10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,9988,9987,998...
11:47:23 <benmachine> she needs a while to catch up
11:47:32 <roconnor_> [10000,9999..1]
11:47:33 <kmc> > foldl (flip (:)) [] [1..10000]
11:47:38 <erisco> STOP IT
11:47:41 <roconnor_> :)
11:47:42 <lambdabot>   [10000,9999,9998,9997,9996,9995,9994,9993,9992,9991,9990,9989,9988,9987,998...
11:47:42 <erisco> I don't want to know dammit
11:47:48 <kmc> erisco, that's not the "optimized" solution
11:47:51 <xplat> benmachine: i just realized you are right and what the difference actually is, so i guess this discussion doesn't need to continue
11:48:14 <illissius`> there's probably some deep metaphysical meaning to `fix error` giving what it does
11:48:19 <erisco> I just wanted to see if reverse could handle that list... and it can, so it is likely using constant space
11:48:28 <benmachine> xplat: :) as a parting remark:
11:48:30 <benmachine> @quote overlapping
11:48:34 <benmachine> ...
11:48:36 <lambdabot> quicksilver says: using OverlappingInstances is the haskell equivalent of buying a new car with high safety rating and replacing the air bags with poison gas, pouring lubricating oil all over the
11:48:36 <benmachine> :(
11:48:38 <benmachine> oh there we go
11:48:41 <benmachine> er
11:48:41 <lambdabot> brake pads, cutting the cable to the parking brake, and gluing broken glass shards all over the steering wheel.
11:48:43 <kmc> erisco, yeah.  i think asking for "constant space" is much more reasonable than asking for "one stack frame"
11:48:48 <benmachine> woo
11:48:56 <illissius`> @quote incoherentinstances
11:48:58 <erisco> which is what I want... but I have O(n^2) time complexity and linear memory usage =\
11:49:03 <lambdabot> sproingie says: * enables IncoherentInstances and ends up with Sarah Palin in his living room
11:49:05 <erisco> so I'll get to work
11:49:07 <kmc> erisco, also sometimes something will work in compiled code and not in lambdabot/ghci
11:49:12 <illissius`> hmm.
11:49:21 <Funktorsalat> quicksilvers analogy there might be just a bit hyperbolic ;)
11:49:24 <illissius`> @quote incoherent
11:49:29 <lambdabot> quicksilver says: overlapping actually shatters the language into tiny inconsistent pieces, and incoherent files off the edges of the pieces so they don't even fit together any more.
11:49:33 <erisco> kmc: well, I could have said that *shrug* but then someone is going to say that copying the list is going to be linear anyhow
11:49:38 <illissius`> ah there's the one.
11:49:41 <benmachine> Funktorsalat: naaah.
11:49:49 <erisco> kmc: which also misses the point... but anyhow, I have what I need
11:49:50 <erisco> thanks
11:49:56 <kmc> compiled ghc code will even detect some infinite loops
11:50:26 <xplat> (if anyone reading is still confused, it's that class (Bird a) => Magpie a means the Bird instance must be findable without finding the Magpie instance first and constructable independently of it, whereas the instance doesn't make any such promises)
11:50:53 <Cale> reverse [1..n] uses O(n) space to compute the first element
11:51:04 <illissius`> what bad properties does OverlappingInstances have beyond breaking import-safety?
11:51:15 <xplat> breaking parametricity
11:51:43 <xplat> (is the biggest one)
11:51:52 <benmachine> does it break parametricity? I didn't know that
11:52:17 <Funktorsalat> what is so bad about overlappinginstances?
11:52:19 <applicative> erisco, what was the point kmc was missing?
11:52:30 <Funktorsalat> or in particular, what's so unsafe about it
11:52:46 <erisco> applicative: no worries
11:52:57 <benmachine> Funktorsalat: it's not *unsafe* like -Coerce or -PerformIO are, as far as I know
11:53:10 <Funktorsalat> benmachine: I figured... but in which way *is* it unsafe?
11:53:24 <benmachine> although there're some interesting things that happen when you combine a modified form of fundeps with overlapping instances, if I recall
11:53:28 <erisco> Cale: does it? hmm... perhaps the Miranda implementation is just different.
11:53:42 <erisco> anyways, I'll chat about this later... going to eat supper
11:53:44 <erisco> thanks for the help
11:53:46 <benmachine> Funktorsalat: but yeah, it means your code can change meaning silently if someone in some other module defines a new instance
11:53:49 <illissius`> benmachine: where by 'interesting things' you mean 'segfaults' =)
11:54:08 <applicative> erisco, it often doesn't make too much sense to ask about haskell functions in isolation.  
11:54:18 <benmachine> illissius`: something like that
11:54:25 <Funktorsalat> benmachine: but how often do you rely on a particular instance as opposed to some other instance for the same type?
11:54:27 <erisco> applicative: yes, that is true
11:54:32 <erisco> anyways, see ya guys later
11:54:39 <Funktorsalat> often there aren't that many options
11:54:48 <applicative> erisco, for a good example of how strange it can be, without going into ghc optimization strategies, take a look at the hackage stream-fusion library
11:54:56 <applicative> ah well
11:57:42 <megajosh2> f
11:58:01 <megajosh2> My internet works fine even though my hard drive got unplugged :/
11:58:57 <notabel> megajosh2: try not to swap :-)
11:59:00 <NemesisD> is anyone aware of a library for REST? my search so far has been unsuccessful. closest i have gotten is HTTP
11:59:13 <Zao> One of the web frameworks might be RESTy.
12:03:25 <NemesisD> Zao: hmm. arent' those usually for building web apps? my aim is more for consuming REST resources
12:04:18 <NemesisD> so far im only aware of snap so my knowledge of haskell web frameworks might be skewed
12:05:33 <notabel> NemesisD: the web-routes and web-routes-quasi packages from yesod might work for you
12:05:41 <Zao> NemesisD: You might be able to leverage the types and helpers they define.
12:05:47 <notabel> i haven't actually worked with them though, so no advice :-)
12:05:58 <notabel> oh, you're looking for consuming resources, nm
12:06:07 <Zao> NemesisD: Much like how things like the (X)HTML generation libraries can be useful outside a web server context.
12:06:12 <notabel> you probably just want an http library and a json or xml library
12:11:27 <NemesisD> yeah http might be the best choice then, but ill check out some of these other options
12:15:03 <applicative> wow, the yesod website is looking pretty swank these days. 
12:21:57 <Cale> There's a bit of needless interaction complexity
12:22:13 <Cale> If you're referring to http://www.yesodweb.com/
12:22:32 <Cale> The scrolly thing with only one extra item in it is a bit silly :)
12:31:42 <NemesisD> yesod's site needs a good graphic designer
12:31:54 <NemesisD> snap's website is pretty :)
12:32:50 <Cale> Also, it's sort of a good thing that there's only one extra item in that scrolly thing, because it only scrolls by one item per click, and would be pretty annoying if there were a lot of things to look through
12:33:51 <Cale> http://docs.yesodweb.com/examples -- this is another example of a fancy widget which does more harm than good
12:40:48 <lispy> Cale: that page doesn't load here
12:41:42 <Cale> huh, and now it doesn't load here either, but it does load if I go back to the main page and click the examples link
12:41:52 <Cale> weird
12:42:28 <fserb> @pl \a b -> a + b
12:42:29 <lambdabot> (+)
12:42:40 <luite> hmm, it doesn't load here at all
12:51:22 <xplat> @pl \x y z w -> foldr ($) w [x,y,z]
12:51:23 <lambdabot> ((flip (foldr id) .) .) . (. ((. return) . (:))) . (.) . (:)
12:52:05 <SubStack> o_O
12:52:45 <benmachine> ... = id
12:53:07 <xplat> @pl \f g h x y z w -> f x $ g y $ h z w
12:53:07 <lambdabot> (. (flip . (((.) . (.)) .))) . (.) . flip . (((.) . (.) . (.)) .)
12:53:55 <benmachine> @pl \a b c d e f g h i j k l m n o p q r s t -> h e l l o t h e r e
12:53:58 <lambdabot> const (const (const (const (const . const . ((const . const . const . ((const . const . (const .)) .) . ((const .) .)) .) . ((((const .) .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .
12:53:58 <lambdabot> ) .) . ((((flip .) .) .) .) . (((flip .) .) .) . join (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . join . (flip .) . ((flip .) .) . (((flip .) .) .) . flip flip id . (ap .) . flip id))))))
12:53:58 <lambdabot> optimization suspended, use @pl-resume to continue.
12:54:02 <burp> ;=)
12:54:10 <burp> @pl-resume
12:54:16 <lambdabot> const (const (const (const (const . const . ((const . const . const . ((const . const . ((const . const . (const .)) .)) .)) .) . (flip =<< ((flip . ((flip . ((flip . (flip .) . flip) .)) .)) .) .
12:54:16 <lambdabot> join (flip . ((flip . ((flip . (flip .)) .)) .) . join . ((flip . ((flip . (flip .)) .)) .) . flip flip id . (ap .) . flip id))))))
12:54:16 <lambdabot> optimization suspended, use @pl-resume to continue.
12:54:28 <benmachine> I've never seen optimization turn up anything useful really
12:56:36 <byorgey> Is there a canonical haskell-mode type thing for vi(m)?
12:56:56 <byorgey> I'm creating a webpage for my class and want to give a link for any students who use vim
13:01:25 <lispy> byorgey: it's weird.  It seems that vim is a popular haskell editor, but no one ever seems to want to talk about how they got it working :)
13:01:32 <byorgey> hehe
13:01:39 <lispy> byorgey: when I use vim for haskell, I just ":syntax on"
13:02:17 <lispy> byorgey: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29909#a29909
13:02:45 <byorgey> thanks
13:03:00 <lispy> Note: I am an emacs user, so I don't know if that's the right way to do it.
13:03:52 <mauke> echo $'syntax enable\nfiletype plugin indent on' >> ~/.vimrc
13:04:16 <sshc> How do I find the type a non-top level function in a where block?
13:04:48 <lispy> sshc: give an incorrect type signature
13:04:50 <Mitar> how can i get name of the current program? like argv[0]?
13:04:59 <lispy> sshc: where foo :: Int; foo a b c = ...
13:05:12 <mauke> @index getArgs
13:05:12 <lambdabot> System.Environment
13:05:17 <mauke> Mitar: ^ check that module
13:05:36 <Mitar> aha
13:05:42 <Mitar> getFullArgs
13:05:45 <Mitar> :t getFullArgs
13:05:47 <lambdabot> Not in scope: `getFullArgs'
13:05:53 <lispy> there is also a way to just get the progName
13:05:57 <lispy> getProgName maybe?
13:06:26 <mauke> Mitar: getFullArgs isn't even in there
13:06:39 <lispy> ?hoogle getProgName
13:06:40 <lambdabot> System.Environment getProgName :: IO String
13:06:53 <lispy> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/System-Environment.html#v%3AgetProgName
13:07:04 <Mitar> thanks
13:07:14 <sshc> lispy: Hah, that's clever :)
13:07:18 <sshc> Thanks
13:07:29 <Mitar> aha, that was ghc.environemnt what i was looking at
13:08:07 <Olathe> Is there a shortcut for mapM_ putStrLn?
13:08:09 <lispy> sshc: yeah, I wish we had something a bit more like proof general to get those though
13:08:19 <lispy> ?pl mapM_ putStrLn
13:08:19 <lambdabot> mapM_ putStrLn
13:08:39 <lispy> Olathe: not that I know of
13:08:45 <Olathe> Ahh, OK, thanks :)
13:09:04 <lispy> http://proofgeneral.inf.ed.ac.uk/
13:09:07 <mauke> putStr . unlines
13:09:15 <lispy> someone needs to port ghci to proof general :)
13:10:30 <ddarius> Please don't.
13:10:47 <lispy> ddarius: ?
13:14:21 <illissius`> is it "safe" to unsafeCoerce, for example, a (Nothing :: Maybe Int) to a (Nothing :: Maybe a)?
13:15:30 * xplat reads the Instance Chains paper
13:15:54 <Saizan> not sure if it's guaranteed by the docs, but it'll work
13:16:35 <illissius`> k
13:17:00 <xplat> considering that 'everyone knows' the relationship between typeclass-based type-level programming and logic programming it's amazing how little the discussion of typeclass semantics explicitly draws on the extensive work in semantics for logic programming
13:17:10 <Saizan> in GHC i mean
13:17:55 <Veinor> iirc it's not guaranteed by the docs
13:18:26 <Veinor> the only things the docs guarantees (in ghc) are enum types with the same range and a newtype wrapper and the type
13:19:15 <illissius`> (my problem is trying to reflect type-level lists/maybes to value-level ones; and you can't say type instance ValueTypeOf Nil = [a], so my idea atm is to make it [Every] and provide a cast function...)
13:22:05 <lispy> illissius`: have you looked at the prior art?
13:22:20 <lispy> illissius`: http://hackage.haskell.org/package/reflection
13:23:16 <tmo_> btw, due to the limitations on the notebook widget with dynamic updates, are there any recommendations on how to make a tabbed multi-doc interface with wxHaskell?
13:23:27 <Saizan> heh, that might not be the same sense of "reflection"
13:23:29 <illissius`> lispy: that's something different :) or well, I guess there's a little bit of overlap in the implementation
13:23:30 <megajosh2> byorgey: I know it's kind of late, but http://projects.haskell.org/haskellmode-vim/
13:23:59 <megajosh2> The searching commands (_?#) act all weird for me though
13:24:09 <illissius`> Saizan: well the "reflect" part of it is the same, and that's basically where I took the word "reflect" from
13:24:23 <illissius`> but I'm only bringing types down to the value level, not sending them up there in the first case
13:25:10 <illissius`> *place
13:25:18 <byorgey> megajosh2: ah, thanks.  do you use that one?
13:25:33 <megajosh2> byorgey: I'm not sure if that includes it, but you probably want to use a custom Haskell indent too http://www.vim.org/scripts/script.php?script_id=1968
13:25:37 <megajosh2> And yeah, I do
13:26:05 <byorgey> megajosh2: cool, thanks
13:27:56 <xplat> illissius`: what do your type-level lists look like?
13:28:21 <illissius> Foo ::: Bar ::: Nil
13:28:59 <mauke> > () :: () : ()
13:29:00 <lambdabot>   <no location info>: parse error on input `:'
13:29:24 <xplat> and Foo and Bar are what?  they belong to a typeclass with an associated type and a value of that type?
13:29:56 <illissius> xplat: well they're anything, the lists are nonhomogenous so that's a different problem
13:30:09 <illissius> the type-level Maybe is more pertinent, which is either Just Foo or Nothing
13:30:22 <illissius> (where Just and Nothing are emptydatadecls)
13:30:36 <xplat> and what do you want it to look like when it's reflected to a value?
13:31:02 <illissius> class TypeValue a where type ValueTypeOf a :: *; value :: Tagged a (ValueTypeOf a)
13:31:08 <illissius> now make an instance for Nothing
13:31:42 <avenge> Anyone know how to get ghci to stop ignoring a breakpoint after I've hit it five times?
13:31:49 <illissius> (if you're not familiar with Tagged just go with value :: a  -> ValueTypeOf a)
13:31:49 <xplat> you need a tagged Nothing
13:31:58 <illissius> yeah, that's not the hard part
13:32:06 <illissius> the hard part is ValueTypeOf Nothing = ??
13:32:45 <xplat> no, i mean Nothing needs a type argument to tell it what its valuetype is
13:33:01 <illissius> hmm
13:33:30 <illissius> yeah, I could do that
13:34:00 <illissius> not sure I want to clutter it up just to make this one thing work more cleanly
13:35:23 <illissius> this sort of thing would be nicer (and possibly unnecessary) with datakinds
13:35:27 <xplat> value-level Nothing actually has a type argument in core at some point in the translation, but the compiler infers it for you
13:35:53 <illissius> yeah, that's a good point
13:36:26 <illissius> if I want homogenous lists I might have to do something similar as well
13:36:34 <illissius> I'll have to think about it...
13:36:47 <megajosh2> For some reason, cabal can't set up wxcore
13:36:49 <megajosh2> :/
13:57:54 * hackagebot hint 0.3.3.0 - Runtime Haskell interpreter (GHC API wrapper)  http://hackage.haskell.org/package/hint-0.3.3.0 (DanielGorin)
13:59:13 <c_wraith> oh, hey
13:59:20 <c_wraith> that's what I was waiting for
13:59:24 * c_wraith gets to work
13:59:29 <tommd> No more hints!!  I can get the answer without that!
13:59:40 <tommd> @users
13:59:40 <lambdabot> Unknown command, try @list
13:59:52 <c_wraith> let's see if he emailed me about the contents of the release
14:00:33 <c_wraith> nope.  guess I'll just have to download it and see what's new
14:03:11 <applicative> c_wraith, what purpose do you put something like hint to?
14:04:43 <c_wraith> I'm the guy who integrated it into a development mode version of snap for an upcoming release
14:05:02 <c_wraith> But doing the integration properly required a hint patch.
14:05:06 <c_wraith> Which...  this should contain
14:05:48 <megajosh2> Hey, does anybody here use wxHaskell?
14:06:01 <megajosh2> There's one thing I don't get about these instructions for installing...
14:06:18 <megajosh2> They say you should install wxcore as root, but everything else as a normal user...
14:06:19 <applicative> what platform are you on?
14:06:21 <megajosh2> Linux
14:06:41 <megajosh2> I was just wondering what the difference would be if I installed wxcore as a normal user
14:06:47 <tommd> try
14:06:50 <megajosh2> I already did, but I went back and am now installing it as root
14:07:13 <applicative> i installed it as a user, but only on an os x machine
14:08:29 <ferret_0567> hello
14:08:39 <applicative> megajosh2, what are the bad symptoms you're getting? 
14:08:47 <applicative> hello ferret_0567
14:08:55 <ferret_0567> I am having a weird parse error problem. It says that I might have incorrect indentation
14:09:06 <megajosh2> I haven't really gotten any yet; I was just wondering if I'd get some otherwise
14:09:13 <megajosh2> It might not matter much after all
14:09:31 <hpc> ferret_0567: can you pastebin the error?
14:09:34 <applicative> ferret_0567, if you paste it on hpaste.org 
14:09:47 <applicative> ...then hpc can take a look...
14:10:57 <hpc> it's probably a simple typographical error
14:10:58 <ferret_0567> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29911#a29911
14:11:32 <hpc> and the error you get?
14:11:32 <megajosh2> ferret_0567: Indent the "let... in" expressions
14:12:06 <benmachine> ferret_0567: don't use so many of them! even if the compiler starts to understand you, no-one else will :P
14:12:10 <c_wraith> ok, daniel included my patch.  excellent.  I can finish the snap integration project
14:12:22 <benmachine> ferret_0567: what's the point of let result = r2 in ...?
14:12:22 <hpc> and if-then-else has freaky indentation rules
14:12:33 <benmachine> can't you just carry on using r2?
14:13:14 <Cale> You should always indent if/then/else such that corresponding 'then' and 'else' pairs line up.
14:13:24 <andreo> how to write mean function in haskell?
14:13:49 <aristid> > let mean = error "Mean!" in mean
14:13:49 <lambdabot>   *Exception: Mean!
14:13:51 <EvanR> mean function, the most popular function for some reason to rewrite
14:13:59 <EvanR> should freakin be in the stdlib
14:14:10 <c_wraith> EvanR, it's really easy to write it in such a way as to cause a space leak. :)
14:14:10 <Cale> andreo: mean xs = sum xs / fromIntegral (length xs)
14:14:20 <c_wraith> yes, that version causes a space leak :)
14:14:27 <Cale> Only if xs is really long
14:14:33 <aristid> :t fromIntegral
14:14:34 <lambdabot> forall a b. (Integral a, Num b) => a -> b
14:14:39 <c_wraith> more importantly, if it's generated lazily
14:14:51 <andreo> Cale: i missed fromIntegral
14:15:05 <aristid> c_wraith: better version?
14:15:27 <c_wraith> aristid, nothing nearly as compact.  dons has a good example of optimizing the mean function somewhere.
14:15:40 <c_wraith> aristid, the main thing is to sum and length in the same pass
14:16:36 <c_wraith> oh, it's in rwh, actually
14:16:36 <ferret_0567_> Cale: I think I am alreaady doing that
14:16:39 <benmachine> :t uncurry ((/) `on` fromIntegral) . foldr (\x (total, count) -> (total + x, count + 1))
14:16:39 <c_wraith> http://book.realworldhaskell.org/read/profiling-and-optimization.html
14:16:40 <lambdabot>     Couldn't match expected type `(a, a)'
14:16:40 <lambdabot>            against inferred type `[a1] -> (a1, t)'
14:16:40 <lambdabot>     Probable cause: `foldr' is applied to too few arguments
14:16:45 <benmachine> oh whoops
14:16:49 <benmachine> :t uncurry ((/) `on` fromIntegral) . foldr (\x (total, count) -> (total + x, count + 1)) (0, 0)
14:16:50 <lambdabot> forall b a. (Fractional b, Integral a) => [a] -> b
14:16:59 <Funktorsalat> oh no benmachine was faster
14:17:06 <Mitar> is there a way to force hPutStrLn stderr to not be interleaved with other threads?
14:17:15 <benmachine> mine's a bit sloppy because it only works on integral, but whatever
14:17:20 <Mitar> becuse not i really get messy debug output when each of them writes at the same time
14:17:28 <benmachine> (also that foldr should probably be a foldl and strict)
14:17:33 <copumpkin> Mitar: I normally stick a printer in its own thread
14:17:35 <Cale> ferret_0567: There are several places where that rule is violated in the pasted code
14:17:36 <Funktorsalat> you probably want to monomorphize it anyway
14:17:38 <copumpkin> Mitar: and then use a Chan to print
14:17:49 <Mitar> but it is just for debugging
14:17:51 <Saizan> Mitar: hSetBuffering LineBuffering also helps
14:17:53 <copumpkin> Mitar: where the printer reads from the Chan and everyone else writes to it instead of using output functions
14:18:00 <Mitar> i use hflush at the end
14:18:01 <Cale> ferret_0567_: It should look like:
14:18:03 <Cale> if foo
14:18:05 <Cale>   then bar
14:18:07 <Cale>   else quux
14:18:10 <Cale> Not:
14:18:12 <Cale> if foo then
14:18:14 <Cale>   bar
14:18:16 <Cale> else quux
14:18:31 <Mitar> but it does not help, hflush, linebuffering is better? is not stderr llinebuffered by default?
14:18:47 <Saizan> Mitar: depends, is this compiled or in ghci?
14:18:49 <mauke> stderr is unbuffered by default
14:18:53 <Cale> The latter is messy and easy to get wrong, and if you put it inside a do-block, it'll fail
14:18:58 <Saizan> ah
14:19:06 * Funktorsalat 's experience concurs with what mauke says
14:19:07 <Saizan> i thought it worked like stdout
14:19:11 <Mitar> saizan: compiled, but i would like that it works on both ;-)
14:19:12 <mauke> based on the assumption that you want as much information as possible in case of an error
14:19:20 <hpc> it is usually better form to do
14:19:27 <hpc> case foo of
14:19:33 <hpc>   True -> bar
14:19:38 <hpc>   False -> quux
14:19:53 <aristid> @src sum
14:19:53 <lambdabot> sum = foldl (+) 0
14:20:16 <aristid> :t foldr
14:20:17 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
14:20:28 <Cale> uncurry (/) . foldl' (\(!s,!c) n -> (s+n, c+1)) (0,0)
14:20:29 <Funktorsalat> iirc sum has a rewrite rule for the common types
14:20:30 <benmachine> hpc: it can be. you can also use guards!
14:20:41 <aristid> :t foldr (\x (n,s) -> (n+1, s+x)) (0,0)
14:20:42 <lambdabot> forall a t. (Num t, Num a) => [a] -> (t, a)
14:20:56 <applicative> ferret_0567 did you figure out the problem?  I'm having trouble finding the 'else' for the first  'if' in the def of 'factor'
14:21:06 <aristid> :t uncurry (/) . foldr (\x (n,s) -> (n+1, s+x)) (0,0)
14:21:07 <lambdabot> forall a. (Fractional a) => [a] -> a
14:21:23 <Saizan> Mitar: calling hFlush doesn't avoid the lack of buffering which makes each char printed directly, which is what allows them to be interleaved on the screen
14:21:25 <benmachine> aristid: that's backwards :) swap n and s
14:21:31 <aristid> benmachine: yeah :D
14:21:42 <hpc> > uncurry (/) . foldr (\x (s,n) -> (n+1, s+x)) (0,0) [1..5]
14:21:43 <lambdabot>   No instance for (GHC.Enum.Enum (a, a))
14:21:44 <lambdabot>    arising from a use of `e_110015' ...
14:21:51 <copumpkin> aristid: just use fold combinators!
14:21:54 <aristid> > uncurry (/) . foldr (\x (s,n) -> (s+x, n+1)) (0,0) [1..10]
14:21:55 <lambdabot>   (55,1.0)
14:21:58 <aristid> copumpkin: how?
14:22:02 <Cale> Using foldl' and some bang patterns will help avoid large expressions being built up
14:22:03 <Mitar> yes, i see difference, hflush does not make any difference, but printing to stdout instead of stderr does
14:22:06 <aristid> > uncurry (/) . foldr (\x (s,n) -> (s+x, n+1)) (0,0) $ [1..10]
14:22:07 <lambdabot>   5.5
14:22:10 <Mitar> so i will just set stderr to line buffered
14:22:17 <Mitar> but why is not default like this?
14:22:21 <Mitar> what is drawback?
14:22:27 <Cale> If you really care about efficiency enough to write it that way anyway
14:22:41 <tmo_> Also, after hacking around, I was able to set up a successful MDI :)
14:22:42 <copumpkin> http://conal.net/blog/posts/more-beautiful-fold-zipping/ and http://comonad.com/haskell/Origami.hs
14:23:08 <copumpkin> Mitar: if your program crashes, you might not see all your logs
14:23:11 <tmo_> So, no need for assistance, at least for now.
14:23:28 <copumpkin> aristid: those links
14:23:42 <ferret_0567_> applicative: no :(
14:23:49 <Mitar> copumpkin: http://www.haskell.org/pipermail/haskell-cafe/2010-September/083518.html
14:23:52 <copumpkin> there was one by Taejo too that started it, and I developed another version that got edwardk into it, but I can't find either
14:23:53 <Mitar> thanks for everything
14:24:02 <copumpkin> Mitar: no problem :)
14:24:14 <ferret_0567_> Cale: I can't fix the problem
14:24:25 <ferret_0567_> something really weird is happening
14:25:20 <applicative> ferret_0567_, shouldn't you start your def of factor :: Integer -> Integer with the line:  factor n = .... rather than factor = ...?
14:25:43 <applicative> ferret_0567_, it's hard to see how a function Integer->Integer is going to come out of these lets
14:26:31 <Mitar> copumpkin: i also solved the problem with different type being returned by the function based on the line type, but i now have 6 argument GADT ;-)
14:26:41 <copumpkin> hah nice
14:26:41 <applicative> ferret_0567_, here is a re-indented version, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29912#a29912
14:27:15 <copumpkin> Mitar: things like that can usually be simplified, but I usually start with something ugly, work with it for a while, and then change it when I figure out what the more elegant version would look like
14:27:16 <hpc> incidentally, guards and fall-through would do wonders here
14:27:49 <ferret_0567_> thanks applicative
14:28:16 <Mitar> hm, yes
14:28:21 <Mitar> maybe something with type families
14:28:25 <Mitar> i was looking into that
14:28:34 <Mitar> but i will first do other things now
14:28:39 <Funktorsalat> hmm I often write functions as "f = go initialAccumulator where ..."
14:28:48 <Mitar> and then come back to that, i have also to code, not just play with types ;-)
14:28:52 <Funktorsalat> @applicative's objection
14:28:52 <lambdabot> Unknown command, try @list
14:29:23 <copumpkin> Mitar: sometimes playing with types can be so addictive though!
14:30:31 <ferret_0567_> applicative: hmm...it still does not work right
14:30:33 <Mitar> yes, sadly it is hard to explain to your mentor: you know, i do not have anything yet, but those types are just beautiful ;-)
14:30:46 <copumpkin> :D
14:31:17 <empt> hi, anyone uses leksah? is it recommended for a newcomer?
14:32:52 <Zao> empt: It tends to kind of work occasionally.
14:33:16 <Zao> empt: I'd recommend playing around with ghci or that tryhaskell site first though, to get a feel for things.
14:34:00 <dk> hey, i'm having a weird problem with my emacs after upgrading my ubuntu to 10.04, usually i was able to automaticly add a type signature by using C-U + C-C + C-T, now it only displays the signature in the ghci-buffer, anyone has clue/hint how to get the usual behaviour back?!
14:34:04 <empt> Zao: thanks
14:34:34 <Zao> empt: Depends on what OS you're on too, I guess.
14:34:38 <ferret_0567_> Is there any way to fix my program?
14:34:43 <Zao> winghci is so-so if you're on Windows.
14:34:48 <Zao> ferret_0567_: Probably.
14:35:05 <empt> I'm on Ubuntu and sometimes W XP
14:35:22 <ferret_0567_> Zao: it's always a parse error with possibly incorrect indentation
14:36:10 <Zao> ferret_0567_: Even appli'cative's reindented above?
14:36:30 <ferret_0567_> Zao: yep
14:39:38 <applicative> ferret_0567_, yes, there are still several errors, but now they're type errors... look at http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29912#a29913
14:41:05 <applicative> ferret_0567_ it is going to need some work getting the Num types straight.
14:41:20 <applicative> @type sqrt
14:41:21 <lambdabot> forall a. (Floating a) => a -> a
14:42:52 <ferret_0567_> applicative : heh, type errors...how the hell am I going to fix those?
14:43:08 <applicative> ferret_0567_ , by lucid thought of course
14:43:15 <applicative> i'd give you some if i had any  :)
14:43:43 <applicative> ferret_0567_, what is factor supposed to express?  what function are you defining, more or less?
14:44:06 <applicative> ferret_0567_, i.e., what is the 'factor' of a number?
14:45:20 <ferret_0567_> applicative : prime factor
14:45:44 <applicative> ferret_0567_, the least prime factor of a number (> 1) ?
14:45:58 <applicative> ferret_0567_, usually they have many of course...
14:47:37 <Cale> Yeah, this factor function itself seems insufficiently factored ;)
14:49:12 <applicative> Cale, yes, all sides are taking that for granted.  ferret_0567_, what is most surprising is all the let's. 
14:49:43 <b52> if i got a Data and want to change only one field in it how can i do that without creating a new one and specify each parameter?
14:49:44 <applicative> leastPrimeFactor would have type :: Integer -> Integer 
14:49:50 <Cale> You should note that let by itself causes no evaluation
14:50:15 <Cale> So it doesn't harm performance at all to float some of those definitions upward
14:50:19 <Cale> (or all of them)
14:50:49 <mauke> b52: foo{ field = newval }
14:51:05 <applicative> primeFactors would have type :: Integer -> [Integer]  though you might want them to be represented just once, or to represent the complete factorization
14:51:06 <b52> while foo is the Data is received?
14:51:13 <Cale> let x = <expr> in x  can also safely be replaced with <expr>
14:51:28 <Cale> (if <expr> has no occurrences of x)
14:51:36 <applicative> > let x = "expr" in x
14:51:37 <lambdabot>   "expr"
14:51:39 <Cale> In particular, r3 is like that
14:51:43 <applicative> > "expr"
14:51:44 <lambdabot>   "expr"
14:52:03 <Cale> You don't need to introduce that definition only to immediately eliminate it
14:52:24 <Cale> p `mod` 2 == 0 is better written as even p
14:53:02 <Cale> let result = r2  seems a bit extraneous as well
14:53:11 <b52> can i use guards in case ß
14:53:17 <Cale> b52: yes
14:53:25 <b52> how?
14:53:32 <Cale> case foo of
14:53:33 <b52> -> | Fo ?
14:53:39 <Cale>   pat | expr -> result
14:53:44 <b52> oh k
14:54:29 <Colours> hee I was just reading an example of Haskell threads and thought the >> operator was the >> symbol in bash for a second
14:54:41 <ferret_0567_> :(
14:54:51 <Cale> ferret_0567_: What's wrong?
14:54:57 <ferret_0567_> It still doesn't work!
14:55:21 <Cale> What algorithm is this supposed to be?
14:55:27 <Cale> (does it have a name?)
14:57:06 <mauke> I heard you like algorithms so I made a wish upon A*
14:57:23 <ferret_0567_> Cale : Fermat's prime factorization algorithm with Trial Division
14:57:25 <mauke> http://mauke.ath.cx/stuff/javascript/a-star/main.html
14:57:42 <hpc> haha
14:58:22 <Cale> ferret_0567_: Okay, so my immediate first question after looking up how that algorithm works is why you don't seem to have a function called isSquare
14:58:29 <theorbtwo> mauke++
14:59:04 <copumpkin> preflex: seen dcoutts
14:59:04 <preflex>  dcoutts was last seen on #ghc 2 days, 5 hours, 2 minutes and 5 seconds ago, saying: * dcoutts disappears
14:59:06 <copumpkin> preflex: seen dcoutts_
14:59:06 <preflex>  dcoutts_ was last seen on #ghc 3 days, 1 hour, 50 minutes and 31 seconds ago, saying: Just say no to unsafePerformIO
14:59:12 <megajosh2-away> mauke: What am I looking at here?
14:59:24 <mauke> COLORS
14:59:28 <copumpkin> @ask dcoutts is there any support for cabal building cmm files for foreign import prim bindings?
14:59:28 <lambdabot> Consider it noted.
14:59:44 <mauke> megajosh2: a pathfinding algorithm called A*
15:00:42 <djahandarie> mauke, that makes some pretty awesome looking pictures
15:00:49 <ferret_0567_> Cale : err...I ported it from a Java program, and didn't know that it needed an isSquare function
15:01:08 <Cale> ferret_0567_: Ah, I'm just going from http://en.wikipedia.org/wiki/Fermat%27s_factorization_method
15:01:10 <applicative> ferret_0567_  maybe if we start with the last function factorTrialDivision since it's independent of the others, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29912#a29914
15:01:47 <applicative> ferret_0567_, it seems like you're expecting "let ... = ... in ..." to do more than it does.
15:02:09 <Cale> ferret_0567_: You sort of do that when you take the sqrt and square the result, but you're not doing anything to convert between integral and fractional number representations there, so I suspect that's a bug right there.
15:02:22 <Cale> (sqrt bsq) ^ 2 /= bsq
15:05:25 <Cale> iSqrt = round . sqrt . fromIntegral
15:05:25 <Cale> isSquare n = (iSqrt n)^2 == n
15:05:27 <applicative> ferret_0567_, I see, clever guy this Fermat 
15:05:29 <Cale> That will work for small n
15:06:29 <ferret_0567_> Cale : the question is, how do I convert from an integer to a fractional number?
15:06:29 <applicative> Cale, I'm just starting to get it, but shouldn't we scrap sqrt and somehow be zipping possibilities with a list of squares? 
15:06:44 <Cale> ferret_0567_: fromIntegral
15:06:46 <ferret_0567_> I don't know haskell very well
15:06:49 <Cale> Or fromInteger
15:07:03 <Cale> But fromIntegral is really the one to remember, if you're only going to remember one :)
15:07:16 <applicative> should fractional numbers should be appearing in this problem?
15:07:52 <hpc> :t 3.5
15:07:53 <lambdabot> forall t. (Fractional t) => t
15:07:54 <b52> whiole using haskell platform and win7 to compile a little network client i get a lot of linker errors http://npaste.de/j6/ any idea whats wrong?
15:08:28 <aavogt> b52: do you use --make?
15:08:28 <Cale> applicative: We might use some kind of bisection method to determine if a number is square which would be correct for larger n, but much slower.
15:08:33 <b52> nop
15:09:07 <ferret_0567_> Err...I try using fromIntegral and I get an error
15:09:23 <b52> ah thanks aavogt 
15:09:45 <Cale> ferret_0567_: The key to this will be to actually understand what the algorithm does and implement that.
15:09:51 <applicative> Cale, yes, I'm coming up with really clunky ideas to implement "One tries various values of a, hoping that a^2 ? N is a square ..."
15:10:27 <Cale> Not to blindly try to convert the code from Java, because that requires understanding Java's semantics, which is harder than just understanding the algorithm.
15:10:28 <applicative> or rather, hoping that a^2 - N  is a square
15:10:54 <ferret_0567_> ok...
15:10:55 <ferret_0567_> alright then
15:11:43 <ferret_0567_> Cale the problem is, I don't understand all the mathematical symbol
15:11:58 <Cale> ferret_0567_: Where? Which one?
15:12:21 <Cale> Look under "The basic method" on the wikipedia page. Let's implement that first.
15:12:38 <Cale> It's given as imperative pseudocode, but it's a lot simpler than the original Java program, I'll bet.
15:13:32 <ferret_0567_> Cale: ok, but I want it to return a list of all the prime factors of a number n
15:13:35 <ferret_0567_> not just one 
15:14:16 <Cale> ferret_0567_: Well, we can iterate this procedure to find more factors.
15:14:29 <ferret_0567_> hmm...where the heck is the ceil function?
15:14:34 <Cale> ceiling
15:17:34 <ferret_0567_> Cale : now, how to best convert that while loop into a recursive function...
15:17:57 <Cale> ferret_0567_: There's the straightforward way:
15:18:09 <Cale> loop a b2 | isSquare b2 = a - iSqrt b2
15:18:30 <ferret_0567_> what? I didn't know haskell had a loop function!
15:18:31 <Cale>           | otherwise   = loop (a+1) (b2 + 2*(a+1) + 1)
15:18:34 <ferret_0567_> oh
15:18:35 <ferret_0567_> that
15:18:41 <Cale> I'm *defining* the function loop
15:18:42 <ferret_0567_> that's a case
15:18:56 <ferret_0567_> errr..guard
15:28:08 <lispy> ferret_0567_: iterate
15:28:16 <lispy> foldl
15:28:18 <lispy> foldr
15:28:19 <lispy> map
15:28:25 <lispy> Haskell has many loop functions
15:28:50 <Cale> lispy: He was confused by the choice of name of my function
15:29:10 <Cale> (which was just plain old recursive :)
15:29:31 <ferret_0567_> never to be confused again :)
15:33:34 <monochrom> goto = do { s <- getChar; if s=='\n' then return [] else do { t <- goto; return (s:t) } }
15:34:13 <monochrom> not_zero = 0
15:34:26 <Cale> ferret_0567_: I found an apparent bug in the wikipedia code
15:34:37 <Olathe> monochrom: That's not POSSIBLE!
15:35:02 <hpc> f x = f x
15:35:15 <hpc> x = 1:x
15:35:16 <Cale> ferret_0567_: The while loop there isn't quite... imperative.
15:35:38 <Cale> ferret_0567_: The code works if those two assignments are made in parallel, but not if you do the assignment to a first
15:35:54 <Cale> Which is easy for us to handle
15:37:07 <lispy> > let f 0 = text "OMG, Zero!"; not_zero = 0 in f not_zero
15:37:09 <lambdabot>   OMG, Zero!
15:37:27 <hpc> :t text
15:37:28 <lambdabot> String -> Doc
15:38:48 <qwebirc77371> @pl id
15:38:49 <lambdabot> id
15:39:02 <qwebirc77371> @pl \(a, b) -> (f a, b)
15:39:02 <lambdabot> first f
15:39:07 <ferret_0567_> what the heck is this No Instance for (RealFrac Integer) arising from a using of `ceiling'?
15:39:14 <hpc> :t ceiling
15:39:15 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
15:39:20 <Botje> integer is not a floating point number
15:39:44 <hpc> you can't round something for which rounding is meaningless
15:39:51 <qwebirc77371> @pl (a, b) -> (a, f b)
15:39:51 <lambdabot> (line 1, column 8):
15:39:52 <lambdabot> unexpected ">" or "-"
15:39:52 <lambdabot> expecting variable, "(", operator or end of input
15:40:00 <hpc> qwebirc77371: second f
15:40:01 <qwebirc77371> @pl \(a, b) -> (a, f b)
15:40:01 <lambdabot> second f
15:40:18 <copumpkin> whoa, @pl knows about that?
15:40:21 <copumpkin> is that new?
15:40:24 <qwebirc77371> What's first and second?
15:40:30 <hpc> @src first
15:40:30 <lambdabot> Source not found. Sorry.
15:40:33 <Cale> copumpkin: No, quite old
15:40:41 <hpc> it applies a function to the first element of a tuple
15:40:52 <hpc> second does something similar, with an obvious difference ;)
15:41:00 <copumpkin> Cale: hmm, I've never seen it use them in common @pl applications, but maybe it's just never needed them
15:41:10 <copumpkin> Cale: or maybe some other rule fires first and steals its uses?
15:41:15 * copumpkin shrugs
15:41:24 <qwebirc77371> Hoogle tells me it's in Control.Arrow. Do I need to use arrows?
15:41:31 <monochrom> copumpkin: how was the readProcess going?
15:41:36 <hpc> @pl \(a, b) -> (f a, g b) -- <- this is also sort of neat
15:41:36 <lambdabot> f *** g
15:41:39 <ferret_0567_> @ let a = ceiling ((sqrt n) . fromIntegral)
15:41:48 <aavogt> > (snd $ second (const 0) undefined, (\(a, b) -> (a, const 0 b)) undefined)
15:41:49 <lambdabot>   (0,*Exception: Prelude.undefined
15:41:54 <Cale> ferret_0567_: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29915#a29915
15:41:57 <copumpkin> monochrom: turned out I hadn't flushed the handle, even though I thought I tried that and was convinced it didn't work
15:42:04 <copumpkin> monochrom: all works fine now :)
15:42:21 <hpc> qwebirc77371: the only instance of Arrow i have ever used is (->), so you don't need to worry about the typeclass stuff
15:42:29 <aavogt> @pl \strictness -> takes away strictness
15:42:29 <lambdabot> takes away
15:42:39 <hpc> just use it as a normal function of a function
15:43:17 <aavogt> > (snd $ second (const 0) undefined, snd $ (\(a, b) -> (a, const 0 b)) undefined) -- to be completely fair
15:43:18 <lambdabot>   (0,*Exception: Prelude.undefined
15:45:41 <hpc> aavogt: that seems wrong, but i can't tell how
15:46:01 <AnAdorableNick> To which category would a simple word search solver library belong?
15:46:20 <tommd> Games?
15:46:30 <monochrom> Spoilers
15:46:34 <aavogt> hpc: me, or that @pl does so?
15:46:52 <hpc> aavogt: the difference between the first and second parts of your tuple
15:47:05 <tommd> Perhaps desktop?
15:47:15 <hpc> it seems impossible that the two could be different
15:47:22 <AnAdorableNick> Hmm, there's a "Crosswords" category
15:47:22 <aavogt> > (snd $ second (const 0) undefined, snd $ (\ ~(a, b) -> (a, const 0 b)) undefined)
15:47:22 <megajosh2> @help pl
15:47:23 <lambdabot> pointless <expr>. Play with pointfree code.
15:47:23 <lambdabot>   (0,0)
15:47:43 <aavogt> hpc: the difference is subtle
15:47:54 <hpc> oh wow, the irrefutable pattern
15:48:01 <tommd> Oh damn!  Someone made a "Crosswords" category.  We really need better control on that.
15:48:15 <megajosh2> What does ~ do to pattern matches?
15:48:27 <tommd> megajosh2: Lazy
15:48:27 <AnAdorableNick> tommd: Why do you think Game would be appropriate?
15:48:37 <hpc> megajosh2: it makes them always match, even if the pattern is wrong
15:48:41 <Zao> megajosh2: It takes you for your word that the match indeed matches.
15:48:43 <aavogt> megajosh2: see the difference in termination behavior?
15:48:48 <Zao> "irrefutable" is a word that appears in my mind.
15:48:49 <tommd> AnAdorableNick: I'm more brainstorming possibilities than saying any one of them is entirely correct.
15:49:07 <hpc> > (\~(a, b) -> a) undefined
15:49:08 <AnAdorableNick> I see
15:49:08 <lambdabot>   <no location info>: parse error on input `->'
15:49:15 <monochrom> but Crosswords is entirely wrong
15:49:46 <hpc> > (\ ~(a, b) -> a) undefined
15:49:47 <lambdabot>   *Exception: Prelude.undefined
15:49:53 <AnAdorableNick> monochrom: Wrong for my solver or wrong to be a category?
15:49:54 <monochrom> there is Algorithms
15:50:10 <hpc> > (\ ~(Just a) -> a) Nothing
15:50:12 <lambdabot>   *Exception: <interactive>:1:134-149: Irrefutable pattern failed for pattern...
15:50:20 <hpc> aha! that's the error
15:50:29 <Cale> > (\ ~(Just a) -> 5) Nothing
15:50:30 <lambdabot>   5
15:50:43 <AnAdorableNick> Ah, Algorithms seems to be the most appropriate category mentioned
15:50:56 <djahandarie> (\ (Just a) -> a) Nothing
15:50:58 <djahandarie> > (\ (Just a) -> a) Nothing
15:50:59 <lambdabot>   *Exception: <interactive>:1:134-148: Non-exhaustive patterns in lambda
15:51:08 <megajosh2> > (\(Just a) -> a * 2) Nothing
15:51:09 <lambdabot>   *Exception: <interactive>:1:138-155: Non-exhaustive patterns in lambda
15:51:09 <Cale> The pattern match failure, if there is one, is deferred until one of the bindings is used
15:51:13 <aavogt> > (\ ~ Just a -> 5) Nothing
15:51:14 <megajosh2> > (\~(Just a) -> a * 2) Nothing
15:51:14 <lambdabot>   Constructor `Data.Maybe.Just' should have 1 argument, but has been given 0
15:51:15 <lambdabot>   <no location info>: parse error on input `->'
15:51:31 <monochrom> non-strict pattern is non-strict
15:51:38 <hpc> it's like matching on everything but the constructor, sort of
15:52:25 <aavogt> > case Nothing of ~ Just a -> 5
15:52:26 <lambdabot>   <no location info>: Parse error in pattern
15:52:31 <AnAdorableNick> monochrom: It appears that, in a redundantly redundant manner, your redundant redundancy redundantly seems redundant.
15:53:15 <hpc> also, it repeats itself repetitively
15:55:10 <ferret_0567> ok...
15:56:05 <ferret_0567> Cale: ok, how do we iterate to find the other factors? I assume we add (x:xs) to our factoring function, but then what?
15:56:29 <copumpkin> man, it's amazing how much a bit of careful thought can make code so much prettier
15:56:48 <Cale> ferret_0567: Recursively factor each of the factors that we discovered
15:56:56 <adnap> I read that you can do a 2-D fft by doing 1-D ffts on all rows, followed by 1-D ffts on all columns.  Can I likewise do a 2-D ifft by first doing a 1-D fft on all columns, and then a 1-D fft on all rows?
15:57:14 <megajosh2> adnap: Whaaaaaaaaaaaat?
15:57:24 <adnap> Oops, I mean 1-D iffts in the second sentence.
15:57:29 <adnap> *meant
15:57:38 <adnap> megajosh2: what what :)
15:57:39 <Cale> ferret_0567: Unless one of them is a trivial factorisation (where one of the elements of the pair is 1)
15:57:40 <qwebirc77371> @pl \a b -> a b
15:57:41 <lambdabot> id
15:57:59 <Cale> ferret_0567: In which case, the other element will be prime
15:58:03 <ferret_0567> Cale : oh
15:59:54 <qwebirc77371> Anyone know how I can get the @pl functionality offline in Ubuntu?
16:00:10 <ferret_0567> Cale : thank you! I just found the answer to problem 3 of Project Euler
16:00:21 <megajosh2> @pl \(a, b) -> (a b, b a)
16:00:22 <lambdabot> uncurry (liftM2 ap ((,) .) (flip id))
16:00:37 <megajosh2> Yuck
16:01:02 <Cale> ferret_0567: actually, we could have used a much simpler method
16:01:04 <adnap> megajosh2: What do you find strange about what I said?
16:01:23 <Cale> ferret_0567: Fermat factorisation is a needlessly subtle way to do this :)
16:01:29 <hpc> :t \(a, b) -> (a b, b a)
16:01:31 <lambdabot>     Occurs check: cannot construct the infinite type:
16:01:31 <lambdabot>       t = (t -> t1) -> t2
16:01:31 <lambdabot>     Probable cause: `b' is applied to too many arguments
16:01:35 <hpc> lol
16:02:21 <qwebirc77371> @pl \x acc -> (("a", x):acc)
16:02:22 <lambdabot> (:) . (,) "a"
16:02:26 <b52> hey, anyone got a good haskell style guide for haskell?
16:02:39 <aristid> :t uncurry (liftM2 ap ((,) .) (flip id))
16:02:40 <lambdabot>     Occurs check: cannot construct the infinite type:
16:02:40 <lambdabot>       b = (b -> a1) -> a
16:02:40 <lambdabot>     Probable cause: `id' is applied to too many arguments
16:02:52 <monochrom> there is no style guide
16:02:53 <aristid> :t liftM2 ap ((,) .)
16:02:54 <lambdabot> forall (m :: * -> *) a a1. (Monad m, Functor m) => (m a1 -> m a) -> m a1 -> m (a1, a)
16:03:07 <aristid> :t liftM2 ap ((,) .) (flip id)
16:03:08 <lambdabot>     Occurs check: cannot construct the infinite type:
16:03:08 <lambdabot>       m = (->) (m a1 -> a)
16:03:08 <lambdabot>     Probable cause: `id' is applied to too few arguments
16:03:12 <aristid> :t liftM2 ap ((,) .) id
16:03:13 <lambdabot> forall (m :: * -> *) a. (Monad m, Functor m) => m a -> m (a, a)
16:03:14 <qwebirc77371> @pl (("a", "b"):)
16:03:15 <lambdabot> (("a", "b") :)
16:03:44 <qwebirc77371> @pl \acc -> "X":acc
16:03:45 <lambdabot> ("X" :)
16:03:54 <aristid> :t liftM2 ap ((,) Prelude..) id
16:03:55 <lambdabot> forall b a. (a -> b) -> a -> (b, b)
16:09:13 <adnap> Okay, this page says that a 2-D fft is done by doing 1-D ffts on the rows and then the columns: http://local.wasp.uwa.edu.au/~pbourke/miscellaneous/dft  This page says columns and then rows: http://www.mathworks.com/help/techdoc/ref/fft2.html  I guess you can do either one, hm?
16:11:01 <applicative> qwebirc77371, the README for the pointfree package tells you how to get in ghci 
16:12:44 <applicative> qwebirc77371, http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29916#a29916 
16:13:10 <kulin> are there any c2hs programs besides gtk? something very small and simple?
16:13:32 * applicative thinks, too bad the ghci won't render the emoticons @pf tends to output
16:18:45 <qwebirc64279> @pl \[a, b] -> (a, b)
16:18:46 <lambdabot> (line 1, column 2):
16:18:46 <lambdabot> unexpected "["
16:18:46 <lambdabot> expecting pattern
16:18:56 <applicative> the test module for pointfree includes the comment "  -- What were they smoking when they decided >> should be infixl"
16:19:52 <applicative> @pl \x:y:[] -> (x,y)
16:19:52 <lambdabot> (line 1, column 6):
16:19:52 <lambdabot> unexpected "["
16:19:52 <lambdabot> expecting "()", natural, identifier, "_" or "("
16:19:59 <applicative> @pl \x:y:zs -> (x,y)
16:19:59 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
16:20:00 <hpc> parens
16:20:28 <hpc> oh, bug in @pl
16:20:30 <applicative> hm, doesn't mind : but doesn't like the other constructor...
16:21:06 <applicative> it is expressing a preference for streams, maybe
16:21:28 <qwebirc64279> Yes.
16:21:29 <hpc> or for the most abstract possible definition
16:21:49 <hpc> @pl \5 -> 3
16:21:50 <lambdabot> const 3
16:21:55 <qwebirc64279> Any way to extend \[a, b] -> (a, b) to arbitrarily long lists?
16:22:00 <hpc> and yet it handles numeric literal patterns
16:22:10 <mauke> qwebirc64279: no. what would its type be?
16:22:14 <hpc> qwebirc64279: no; tuples change type as they change length
16:22:19 <applicative> qwebirc64279 I did manage to get it in my ghci, foolishly inspired by your query
16:23:30 <applicative> @pl \w:x:y:z:zs -> (x,zs) --yick
16:23:31 <lambdabot> ap ((. tail) . (. tail) . (,) . head) tail . tail
16:24:00 <qwebirc64279> Are there any predefined functions that do something like \[a,b] -> (a, b) ?
16:24:37 <hpc> @unpl (!!2) &&& (drop 4)
16:24:37 <lambdabot> ((\ a -> a !! 2) &&& (drop 4))
16:25:00 <benmachine> qwebirc64279: probably not, it's pretty fragile as a function
16:25:07 <hpc> > (!!2) &&& (drop 4) [x,y,z,a,b,c]
16:25:08 <lambdabot>   Couldn't match expected type `[a] -> c''
16:25:08 <lambdabot>         against inferred type `[a1]'
16:25:08 <benmachine> accepting no more nor less than two arguments
16:25:19 <hpc> > (!!2) &&& (drop 4) $ [x,y,z,a,b,c]
16:25:20 <lambdabot>   (z,[b,c])
16:25:43 <Zao> benmachine: I found myself needing a 4-ary such function the other day.
16:26:05 <Zao> (\[a,b,c,d] -> (a,b,c,d)) <$> count 4 someParser
16:27:17 <benmachine> :t liftM2 (++) (return . fst) (return . snd)
16:27:18 <lambdabot> forall (m :: * -> *) b. (Monoid (m b), Monad m) => (b, b) -> m b
16:27:22 * benmachine blinks
16:27:28 <megajosh2> > (\[a, b] -> (a, b)) [1, 2]
16:27:29 <lambdabot>   (1,2)
16:27:32 <megajosh2> Hmm...
16:27:37 <benmachine> :t liftM2 (++) ((:[]) . fst) ((:[]) . snd)
16:27:39 <lambdabot> forall b. (b, b) -> [b]
16:27:51 <benmachine> ^ inverse
16:27:54 <megajosh2> > (\list -> (head list, head.head$list)) [1, 2]
16:27:55 <lambdabot>   No instance for (GHC.Num.Num [a])
16:27:56 <lambdabot>    arising from a use of `e_112' at <inte...
16:28:03 <megajosh2> > (\list -> (head list, head.init$list)) [1, 2]
16:28:04 <lambdabot>   (1,1)
16:28:07 <megajosh2> woops
16:28:19 <benmachine> head.tail, I thinks
16:28:24 <aristid> > liftM2 (++) ((:[]) . fst) ((:[]) . snd) $ (1,2)
16:28:25 <lambdabot>   [1,2]
16:28:30 <megajosh2> Yuck
16:28:47 <megajosh2> Heinous
16:28:57 <benmachine> hmm
16:28:58 <hpc> > liftM2 (++) $ first return $ second return $ (1,2)
16:28:59 <lambdabot>   Overlapping instances for GHC.Show.Show
16:28:59 <lambdabot>                              ((m d,...
16:29:03 <aristid> :t liftM2 (:) fst ((:[]) . snd)
16:29:04 <lambdabot> forall b. (b, b) -> [b]
16:29:08 <hpc> :t (++)
16:29:09 <lambdabot> forall m. (Monoid m) => m -> m -> m
16:29:19 <hpc> > liftM2 (++) $ first return $ second return $ (1.2,2.2)
16:29:20 <lambdabot>   Overlapping instances for GHC.Show.Show
16:29:20 <lambdabot>                              ((m d,...
16:29:22 <aristid> :t (***)
16:29:23 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
16:29:27 <hpc> > liftM2 (++) $ first return $ second return $ (True, False)
16:29:28 <lambdabot>   Overlapping instances for GHC.Show.Show
16:29:28 <lambdabot>                              ((m GH...
16:29:34 <hpc> oh, derp
16:29:44 <hpc> > liftM2 (++) $ first return $ second return $ (True, False) :: [Bool]
16:29:45 <lambdabot>   Couldn't match expected type `[GHC.Bool.Bool]'
16:29:45 <lambdabot>         against inferred typ...
16:29:51 <hpc> D:
16:30:15 <benmachine> hpc: it's often recommended to use . instead of multiple $
16:30:29 <benmachine> easier abstraction
16:30:55 <hpc> yeah; that's not the main problem anyway
16:30:58 <benmachine> mm
16:31:01 <hpc> i thought i could abstract away f . fst
16:31:12 <hpc> seems not
16:31:19 <Axman6> > uncurry (++) $ first return $ second return $ (True, False) :: [Bool]
16:31:20 <lambdabot>   [True,False]
16:31:28 <benmachine> :t liftA2 (:) fst (pure . snd)
16:31:30 <lambdabot> forall b. (b, b) -> [b]
16:31:44 <benmachine> Axman6: oh, yeah I thought about uncurry
16:31:57 <aristid> :t uncurry (:) . second return
16:31:57 <lambdabot> forall a. (a, a) -> [a]
16:32:06 <benmachine> oh
16:32:10 <benmachine> well, there you go
16:32:23 <megajosh2> I've gotta figure out how to use arrows...
16:32:27 <megajosh2> So far I'm just confuzzled
16:32:37 <aristid> megajosh2: actually we're not using arrows
16:32:43 <benmachine> I never really figured out arrows
16:32:46 <aristid> we're just abusing the arrow functions
16:33:00 <benmachine> :t uncurry (:) . fmap return
16:33:01 <lambdabot> forall a. (a, a) -> [a]
16:34:03 <hpc> @hoogle (a,a) -> [a]
16:34:04 <lambdabot> Data.Ix range :: Ix a => (a, a) -> [a]
16:34:04 <lambdabot> System.Random randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
16:34:04 <lambdabot> Prelude snd :: (a, b) -> b
16:34:22 <hpc> > Data.Ix.range (1,3)
16:34:23 <lambdabot>   [1,2,3]
16:34:27 <djahandarie> @djinn (a, a) -> [a]
16:34:28 <lambdabot> Error: Undefined type []
16:34:37 <benmachine> djinn doesn't do recursive types, if I recall
16:34:38 <djahandarie> @djinn (a, a) -> List a
16:34:38 <lambdabot> Error: Undefined type List
16:34:43 <djahandarie> Ah okay
16:38:18 <wolverian> windows paths are nice: Writing default configuration to C:\Users\Ilmari\AppData\Roaming\cabal\config
16:39:03 <Saizan> the most puzzling component is "Roaming"
16:41:12 <wolverian> there is also "Local" there, and "LocalLow", in the same dir as "Roaming"
16:41:26 <wolverian> s/is/are/ && s/ there//
16:43:56 <monochrom> I totally don't understand windows appdata directories either.
16:44:03 <iFire> what's the grapevine on http://www.cs.nott.ac.uk/~gmh/book.html
16:45:30 <monochrom> there is grapevine?
16:46:10 <iFire> general community opinion
16:46:28 <ClaudiusMaximus> sm: yes, it's a file list; i'm using assembler because it seemed the sanest way to do it (no need for prettyprinting/parsing); sorry for late reply (had to sleep..)
16:47:03 <monochrom> the web page contains some general community opinion
16:47:25 <Saizan> iFire: there is also a review in an issue of The Monad.Reader
16:47:26 <McManiaC> what do you guys prefer? http://npaste.de/jC/
16:47:29 <iFire> Saizan oh?
16:47:35 <iFire> let me see if I can find it
16:47:55 <monochrom> I prefer both
16:48:08 <Saizan> iFire: anyhow it's generally considered good
16:48:15 <McManiaC> both? :D
16:48:57 <monochrom> I usually do the 2nd one because that's what an automatic indenter does. I don't really care.
16:49:59 <benmachine> McManiaC: couldn't match expected type Bool against inferred type a -> b :(
16:50:11 <monochrom> haha
16:50:29 <McManiaC> benmachine: haha sorry, meant to test on "bar" there :P
16:50:45 <McManiaC> updated :)
16:50:52 <benmachine> McManiaC: for my part, I'd probably use an explicit >>
16:51:16 <McManiaC> benmachine: if you had a longer code block after that then?
16:51:42 <benmachine> McManiaC: well, maybe a where clause? I don't know I tend to avoid if wherever possible :P
16:51:58 <benmachine> McManiaC: in that case I'd probably break line after the do
16:52:40 <Saizan> guards ftw
16:53:15 <tommd> Heck, a bool you could pattern match
16:53:22 <McManiaC> well yes :P
16:53:26 <McManiaC> thats not the point
16:53:26 <McManiaC> :D
16:54:52 <McManiaC> I like the top version, since the indention in each block is equal, even if you have to use do, but I always saw the second version in other people codes so far
16:58:03 <AnAdorableNick> tommd: ("<...>.WordSearch") What should the module name be?
16:58:23 <McManiaC> Text?
16:58:33 <tommd> Text sounds good to me.
16:59:12 <AnAdorableNick> Perhaps, although it can actually solve non-text "word searches", even though the cell parameter is usually Char when it is used
16:59:27 <AnAdorableNick> I'll probably use Text, unless anybody can think of anything else?
16:59:38 <McManiaC> well I dont know your module :)
16:59:42 <notabel> Games.?
17:00:01 <McManiaC> if you can use it for arbitrary lists you could use something like Data.List.Search ?
17:00:02 <AnAdorableNick> McManiaC: It's a word search solver library
17:01:51 <AnAdorableNick> I'll probably use "Text.WordSearchSolver"
17:03:07 <McManiaC> :)
17:03:41 <monochrom> what is a word search solver?
17:04:03 <luite> Org.AnAdorableNick.HaskellX.Solver.Text.WordSearchSolver
17:04:05 <monochrom> why is it not a word searcher? not a word solver?
17:04:35 <AnAdorableNick> monochrom: A library that solves word search puzzles
17:04:56 <monochrom> I see. the game is "word search".
17:20:39 <Olathe> Are records implemented as a tuple?
17:21:20 <Olathe> Like newtype Zomg = Zomg { a :: Int32, b :: Word16 } is the same as newtype Zomg = Zomg (Int32, Word16) ?
17:21:33 <Saizan> the first is invalid
17:21:42 <Olathe> Ahh, you're right.
17:21:44 <benmachine> data
17:21:54 <Olathe> I'm trying to save memory :)
17:22:24 <benmachine> it probably takes the same amount of memory as a tuple
17:22:47 <Saizan> if you use data in the first case then i think they get the same memory layout
17:23:14 <Saizan> you could test with unsafeCoerce :)
17:24:05 <ManateeIrcClient> Moring all! :)
17:25:41 <copumpkin> ManateeIrcClient: let me guess what IRC client you're using!
17:25:47 <applicative> Its a Haskelly morning in China,  evidently, ManateeIrcClient	
17:25:48 * copumpkin thinks deeply
17:26:00 <copumpkin> ManateeIrcClient: okay, I give up, what IRC client are you using?
17:26:01 <ManateeIrcClient> applicative: Okay :)
17:26:39 <ManateeIrcClient> copumpkin: I use my own irc client.... :)
17:26:39 <applicative> I heard you like ... so I put ... on your ManateeIrcClient
17:26:46 <copumpkin> ManateeIrcClient: omg!
17:26:53 <copumpkin> I would never have guessed!
17:27:01 <ddarius> copumpkin: You should write an IRC client in Agda.
17:27:15 <copumpkin> ddarius: static guarantees against trolls?
17:27:22 <applicative> ddarius, no, that was my idea!
17:27:42 <ManateeIrcClient> copumpkin: mmm..... I'm robot of ManateeLazyCat.... *pure* Haskell running my heart.... mmm...
17:27:48 <copumpkin> lol
17:29:35 <ManateeLazyCat> copumpkin: My robot : http://www.flickr.com/photos/48809572@N02/4980612897/lightbox/
17:30:09 <copumpkin> cool :)
17:30:43 <applicative> stylin'
17:30:54 <ManateeLazyCat> copumpkin: I will add MD5 color highlight next step....
17:31:33 * ManateeLazyCat I love robot..... :)
17:31:39 * ddarius doesn't think MD5 is necessary...
17:31:46 <copumpkin> it should be SHA256
17:31:52 <copumpkin> can't risk any malicious collisions
17:32:02 <ManateeLazyCat> ddarius: MD5 is make every nick has it's own color.
17:32:05 <ManateeLazyCat> ddarius: See ?
17:32:46 <copumpkin> ManateeLazyCat: I think the point was that you could use even a much cheaper string hashing function from e.g. your average hashtable
17:32:54 <ddarius> Not guaranteedly and further your hardware is not capable of producing that many colors nor your eyes seeing them.
17:32:56 <copumpkin> rather than a "cryptographic hash" (albeit a broken one)
17:33:38 <copumpkin> or not :)
17:34:32 <Jafet> ddarius: there's a finite number of legal nicks, aren't there
17:34:52 <ManateeIrcClient> copumpkin: Good idea, i will change my heart later.... mmm.....
17:35:03 <Olathe> Neat: http://www.fing.edu.uy/inco/proyectos/fusion/tool/
17:35:24 <Phyx-> did wagstaff ever come back?
17:35:32 <Phyx-> @seen wagstaff
17:35:32 <ddarius> Jafet: Yes, but there are certainly more than 16 million.
17:35:32 <preflex>  wagstaff was last seen on #haskell 10 hours, 2 minutes and 39 seconds ago, saying:  /msg NickServ identify 11Shirley
17:35:32 <lambdabot> Unknown command, try @list
17:35:38 <Phyx-> !seen wagstaff
17:35:56 * Phyx- facepalm
17:36:00 <Olathe> Wow
17:36:06 <Jafet> ddarius: get an IPS 10-bit display, they're all the rage
17:36:09 <Phyx-> god damnit...
17:36:32 <Olathe> Note to self: if you accidentally tell everyone your nickserv password, say something else before leaving.
17:36:35 <Jafet> More seriously, perfect hashing is an option
17:38:47 <SubStack>  /msg nickserv identify elbillug
17:38:49 <SubStack> ohshit
17:38:49 <ddarius> Jafet: A better display won't make your eyes better.
17:39:23 <ManateeIrcClient> mmm... looks my decoding engine is broken... 
17:39:32 <copumpkin> who's wagstaff anyway?
17:39:50 <Phyx-> idk, but i feel kinda guilty :/
17:39:53 <benmachine> some guy who failed at identify
17:39:53 <Jafet> Well, you could use 8-bit colour and colour by letter
17:39:58 * copumpkin is tempted to @remember that
17:40:00 <copumpkin> for posterity
17:40:04 <benmachine> and then got ghosted twice and the second time he didn't come back
17:40:26 <Phyx-> benmachine: one of those ghostings wasn't intentional!
17:40:42 <benmachine> Phyx-: well, you hardly took all possible precautions :)
17:40:56 <Phyx-> lol
17:42:14 * Phyx- doesn't even remember his pass
17:42:21 <Phyx-> i hardly ever ident
17:45:37 <Olathe> I just put it as the password for the server and it autoidentifies for me.
17:46:42 <benmachine> yeah I do that
17:47:25 <Phyx-> I'm trying to kick my irc habbit anyway
17:47:34 <Phyx-> I was doing fine, till 3 days ago
17:48:47 <medfly> starting to have withdrawal symptoms?
17:49:13 <ManateeIrcClient> mmm.... heart upgrade....  seee .... you.... later.... 
17:49:23 <Phyx-> medfly: yes, unfortunately
17:49:42 <Phyx-> fortunately, I was able to satisfy it by only joining #haskell
17:51:02 <Phyx-> "PS3 jailbroken with... a TI-84 Plus calculator" <-- lol, awesome
17:55:50 <tmo_`> How do I get wxHaskell to respond to a key event?
17:56:16 <tmo_`> For instance, I want it to print a string to the terminal when I press Ctrl-t
17:57:01 * ManateeLazyCat Why so many people choose wxHaskell instead gtk2hs, just curious.....
17:57:31 <tmo_`> wxHaskell looks better cross platform, which is important to me, and the API seems more intuitive to me.
17:59:10 <tmo_`> (both are equally spartan in documentation too)
17:59:59 <ManateeLazyCat> tmo_`: gtk2hs just ugly on Mac, but fine on Windows and UNIX.
18:01:13 <lispy> ManateeLazyCat: Well, wxHaskell has been installable by mere mortals for much longer than gtk2hs
18:01:28 <lispy> ManateeLazyCat: in fact, I still haven't successfully installed gtk2hs on my mac
18:02:06 <ManateeLazyCat> lispy: Why, any problem.
18:02:07 * Phyx- hasn't been able to succesfully install wxHaskell
18:02:08 <ManateeLazyCat> ?
18:02:23 <Phyx-> but I have installed gtk2hs
18:02:28 <lispy> hmm...what is the proper name of it now?
18:02:55 <Phyx-> hm?
18:02:55 <ManateeLazyCat> lispy: Axel have mac, you should report your problem to gtk2hs list.
18:03:33 <lispy> ManateeLazyCat: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29919#a29919
18:03:35 <Phyx-> I <3 glade
18:04:07 <conal> New blog post: "Lazier functional programming, part 1", http://bit.ly/9cOsMp
18:04:07 <lispy> ManateeLazyCat: is that the right package to try installing?
18:04:36 <ManateeLazyCat> lispy: You need install gtk2hs-buildtools first.
18:04:44 <ManateeLazyCat> lispy: setup: gtk2hsC2hs is required but it could not be found.                                                                                                                                                                                          
18:05:13 <ManateeLazyCat> lispy: Because gtk2hs-buildtools is build tools for gtk, and not depend library, you need install it manually before install gtk.
18:05:31 <ManateeLazyCat> lispy: Currently, we can install gtk2hs on Windows, Linux, Mac.
18:05:43 <ManateeLazyCat> lispy: I think Mac should be ok, because Axel always test it.
18:06:51 <ManateeLazyCat> lispy: And you need make sure CabalPath/bin in your PATH (whatever in Mac)....
18:08:25 <tmo_`> Anyways, how do you get an application to respond to a custom KeyEvent?
18:09:02 <ManateeLazyCat> tmo_`: gtk2hs question?
18:09:10 <tmo_`> no, wxHaskell
18:09:26 <ManateeLazyCat> tmo_`: No idea wxHaskell.
18:09:39 <tommd> What's the preferred pure-Haskell Relational DB package?
18:10:02 <ManateeLazyCat> tmo_`: We use signal `keyPressEvent` in gtk2hs, i guess wxHaskell have similar thing....
18:10:13 <co_dh> :t listToMaybe
18:10:14 <lambdabot> forall a. [a] -> Maybe a
18:10:23 <co_dh> > listToMaybe [1,2,3]
18:10:25 <lambdabot>   Just 1
18:10:47 <ManateeLazyCat> > listToMaybe []
18:10:48 <lambdabot>   Nothing
18:11:00 <lispy> ManateeLazyCat: I recently upgraded to ghc 6.12.3 so trying again.  But last time I tried this I had some compile failure.
18:11:22 <Lemmih> tommd: Are there any pure-Haskell RDB packages?
18:11:29 <ManateeLazyCat> lispy: I think everything should be ok if you install gtk2hs-buildtools
18:11:31 <tommd> Looks like Happstack has one
18:12:07 <lispy> Lemmih: RDB?
18:12:12 <Lemmih> tommd: I wouldn't call that a relational database.
18:12:18 <ManateeLazyCat> lispy: Leksah's author have test gtk2hs on Windows, Linux, Mac, no reason should be failed....
18:12:30 <lispy> Lemmih: ah, so I want a pure haskell RDB too.  I'm starting by writing a B/B+ tree library
18:12:31 <tommd> Lemmih: No, but is suits me well enough... I think
18:13:01 <lispy> Lemmih: you're welcome to join in.  http://community.haskell.org/~dagit/boab
18:13:32 <conal> i successfully installed gtk2hs on mac os x this week.  simple in the end, but i got some crucial help along the way.
18:13:42 <kmc> tmo_`, custom key event, as opposed to what?
18:14:07 <JoeyA> What's the difference between the mtl and transformers libraries?
18:14:15 <ManateeLazyCat> lispy: Maybe you talk with conal ? :) 
18:14:25 <conal> lispy: i'm happy to help.
18:14:47 <lispy> ManateeLazyCat: part of what makes it difficult is that it seems to assume you have mac ports.  and mac ports tends to be evil (for example, iconv link errors)
18:15:18 <lispy> conal: I actually don't care about having gtk2hs.  I'm just trying the install to see if there are errors.
18:15:29 <conal> lispy: ah.
18:15:31 <Lemmih> lispy: I think I'm more partial to kd-tree.
18:16:02 <lispy> ManateeLazyCat: cheers. it worked this time
18:16:09 <conal> once wxHaskell gets ghci-friendy again, i expect i'll switch back to it.  prettier inside & out.
18:16:10 <lispy> and so did wx
18:16:29 <ddarius> JoeyA: transformers doesn't have the classes that abstract from the stack.  Those are split into monad-fd and monad-tf.  There are some other smaller differences.
18:16:34 <ManateeLazyCat> lispy: Great!
18:16:38 <lispy> Although, the error I ran into should be changed to let people know about gtk-buildtools
18:17:00 <ManateeLazyCat> lispy: We have, just people don't read documentation.
18:17:13 <ManateeLazyCat> lispy: do "cabal install gtk" directly....
18:17:47 <ManateeLazyCat> lispy: Maybe we should add "you should install gtk2hs-buildtools first or make sure gtk2hsChs in your path" in error information.....
18:17:57 <lispy> ManateeLazyCat: When I type 'cabal install gtk' it doesn't give me any documentation :)
18:18:25 <lispy> ManateeLazyCat: I mean, with 99% of hackage, if I want to use it I just 'cabal install FOO'.
18:18:28 <ManateeLazyCat> lispy: Yes, we write it on gtk2hs homepage, but i guess most people don't read it.... :)
18:18:31 <JoeyA> I guess a good question is: which one is "better"?
18:18:52 <lispy> JoeyA: I greatly prefer wx myself.
18:18:59 <lispy> Doesn't gtk2hs have threading bugs?
18:19:02 <lispy> or did the fix that?
18:19:05 <ManateeLazyCat> lispy: Sorry, i need leave now ... leave message to me, i will add your suggestion in gtk2hs TODO list.... :)
18:19:16 <ManateeLazyCat> lispy: gtk2hs haven't threading bugs now.
18:19:46 <ManateeLazyCat> brb
18:19:56 <lispy> JoeyA: historically, wx has been smaller and people have had less problems with it
18:20:02 <lispy> fewer*
18:20:07 <JoeyA> lispy: Couldn't match expected type `Transformer library' against inferred type `GUI toolkit'
18:20:19 <JoeyA> but that's good to know, too :)
18:21:10 <lispy> JoeyA: Oh, sorry.  I didn't see your question about mtl.  (I keep hearing mtl is dead)
18:21:52 <lispy> mtl has a lot of inertia, but many people are unhappy with the design of mtl
18:22:37 <lispy> and once performance becomes a concern, many people throw away the transformer libraries and roll a custom monad
18:23:18 <conal> wx has a more elegant programming interface.  and it uses native widgets, so looks much better on mac.
18:23:34 <lispy> conal: I thought gtk used native widgets too
18:23:43 * lispy checks if the install had example app
18:24:02 <conal> lispy: only if you use gtk-osx, which has build problems and does not support OpenGL.
18:24:11 <conal> and I need OpenGL.
18:24:21 <JoeyA> My goal is to get me some global state.  I figure using the StateT transformer is what I want.
18:24:42 <conal> gtk2hs on mac uses X, so it doesn't act like other mac apps.
18:24:48 <kmc> JoeyA, have you used any of these libraries before?
18:24:52 <JoeyA> nope
18:25:09 <kmc> i think most material for beginners is oriented towards mtl
18:25:14 <JoeyA> (mainly a progress bar, but for the most part, my program will be passing data around rather than accumulating a lot of state in memory)
18:25:16 <kmc> and it's certainly acceptable
18:25:28 <kmc> you want to use StateT over IO?
18:25:37 <lispy> JoeyA: it probably is, but just realize that you may want to replace it with either a custom monad later or a non-mtl version.  So I would recommend hiding the implementation behind a newtype and using GeneralizedNewtypeDeriving
18:25:40 <JoeyA> I believe so.
18:25:57 <kmc> JoeyA, did you consider using the state capabilities built into IO?
18:26:06 <ddarius> You'd want to use a newtype anyway for convenience and control.
18:26:28 <JoeyA> Well, the only way I can think to do it in that fashion is:
18:26:33 <JoeyA> state :: IORef MyState
18:26:35 <kmc> in fact you might not *want* to derive (MonadState S), etc
18:26:45 <JoeyA> state = unsafePerformIO $ neoIORef initMyState
18:26:51 <JoeyA> newIORef*
18:27:02 <JoeyA> or I could just pass it around naked
18:27:06 <Zeiris> Do I need to write my own 'split' function for tokenizing strings?
18:27:18 <kmc> Zeiris, no
18:27:20 <JoeyA> or I could make my own wrapper that does the state.
18:27:20 <hamishmack> conal: gtk2hs can be built not to use X11 (still uses its own widgets though)
18:27:22 <kmc> see the "split" library on hackage
18:27:27 <kmc> or you could use ReaderT to pass that IORef
18:27:31 <benmachine> JoeyA: transformers comes with Applicative instances, that mtl still doesn't have if I recall
18:27:40 <kmc> StateT and IORef are operationally very different, that may inform your decision
18:27:46 <lispy> hamishmack: oh, the default 'cabal install gtk' on mac will use x11?
18:27:48 <benmachine> JoeyA: transformers needs monads-fd or monads-tf to compete with mtl though
18:28:08 <hamishmack> lispy: Depends on your gtk install
18:28:10 <JoeyA> I'm not sure I understand the difference between StateT and ReaderT.
18:28:35 <benmachine> JoeyA: ReaderT doesn't support put?
18:28:42 <hamishmack> lispy: I use gtk-osx.sourceforge.net to build gtk
18:29:01 <JoeyA> What's local, then?
18:29:11 <JoeyA> "The function to modify the environment."
18:29:16 <lispy> what is a gtk app I can use to test my gtk install?
18:29:27 <benmachine> JoeyA: subtly different.
18:29:33 <lispy> gtk-demo definitely uses X11
18:29:34 <hamishmack> lispy: You can use the Mac menu bar with... http://hackage.haskell.org/package/ige-mac-integration
18:29:35 <benmachine> ok, I *thought* transformers had applicative instances
18:29:41 <JoeyA> Ah
18:29:50 <benmachine> oh it does
18:29:51 <JoeyA> so the modification applies to the computation inside, then it reverts back.
18:29:54 <JoeyA> Makes sense.
18:29:56 <benmachine> yes
18:30:04 <kmc> yeah
18:30:08 <kmc> that's why the type is ... m a -> m a
18:30:34 <kmc> there's no way for an environment change to filter "up" / "out"
18:30:34 <lispy> no wait, this is not using X11
18:30:36 <lispy> My mistake
18:30:45 <lispy> But it is very ugly
18:30:46 <kmc> this is evident from the fact that (Reader r a) is just a wrapper for (r -> a)
18:31:02 <kmc> @djinn (r -> r) -> (r -> a) -> (r -> a)
18:31:03 <lambdabot> f _ a b = a b
18:31:27 <kmc> @djinn (r1 -> r2) -> (r1 -> a) -> (r2 -> a)
18:31:27 <lambdabot> -- f cannot be realized.
18:31:36 <kmc> @djinn (r1 -> r2) -> (r2 -> a) -> (r1 -> a)
18:31:37 <lambdabot> f a b c = b (a c)
18:31:51 <conal> contra-functor!
18:31:59 <hamishmack> lispy: Here is a screenshot of leksah on Mac .... http://leksah.org/screenshots.html
18:32:02 <lispy> hmm...gtk-demo may have crash
18:33:03 <hamishmack> lispy: If you look in leksah-head darcs we have all the scripts we use to make our bundle too
18:35:03 <hamishmack> lispy: Unless you build a bundle your main window will probably appear behind all the others
18:37:10 <lispy> Lemmih: oh, are you building a spatial database?
18:39:09 <lispy> hamishmack: have you guys done any benchmarking with your use of regex-tdfa?  I benchmarked some of the regex libraries for use in darcs a while back and IIRC, tdfa was very slow
18:39:21 <lispy> hamishmack: I think the slowest of the bunch, but that was about 2 years ago now
18:39:56 <tmo_`> kmc: sorry, I was gone
18:40:20 <hamishmack> lispy: We switched to it because yi used it and it made linking simpler
18:40:32 <tmo_`> My main question was how to get an application to do some output function, when given a keyboard event, like Ctrl-t
18:41:02 <hamishmack> lispy: Also we had some problems with regex-posix on win32 around the same time
18:41:14 <lispy> hamishmack: http://pastebin.com/gsV86y5M
18:41:41 <hamishmack> lispy: We actually use grep for searching multiple files
18:42:01 <Lemmih> lispy: Oh no, I'm not involved in any of that. I'm merely a spectator.
18:42:21 <hamishmack> lispy: cabal update and try again
18:42:31 <lispy> Lemmih: well, part of the project to formally verify the b/b+ tree implementation as we go
18:42:33 <kmc> did you read http://hackage.haskell.org/packages/archive/wx/0.12.1.6/doc/html/Graphics-UI-WX-Events.html#v:charKey tmo_` 
18:42:42 <kmc> err the top of that page
18:42:43 <lispy> Lemmih: maybe we can have a high assurance database at some point :)
18:42:48 <hamishmack> lispy: I released 0.8.0.8 last night
18:43:37 <tmo_`> kmc: now, but I'll try that
18:43:40 <tmo_`> *no
18:43:49 <hamishmack> lispy: It looks like you might need gtksourceview2 (the C library) installed too
18:44:28 <lispy> hamishmack: how do I get that?
18:44:43 <hamishmack> lispy: How did you install gtk?
18:45:09 <lispy> http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29920#a29920
18:45:20 <lispy> hamishmack: 'cabal install gtk' or something else?
18:45:49 <hamishmack> lispy: No I mean how did you install gtk (as apposed to gtk2hs)
18:46:00 <lispy> oh, probably with mac ports
18:47:23 <hamishmack> lispy: you should be able to install gtksourceview in the same way
18:48:27 <lispy> these libraries have an amazing number of dependencies
18:48:39 <lispy> it's installing dbus, glib, atk, etc
18:49:29 <lispy> hamishmack: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=29921#a29921
18:50:28 <lispy> hamishmack: this is too much work just to see if gtk2hs is working
18:50:37 <hamishmack> lispy: hpaste is not working for me
18:51:15 <lispy> hamishmack: mac port failed with a weird error message about an expected file
18:51:24 <lispy> hamishmack: so I cannot install gtksourceview2
18:51:30 <co_dh> I'm reading stl's document , and I find that STL's "concept" is Haskell's typeclass
18:51:35 <co_dh> http://www.sgi.com/tech/stl/ForwardContainer.html
18:51:42 <lispy> Error: Target org.macports.activate returned: Image error: /opt/local/include/atk-1.0/atk/atk-enum-types.h already exists and does not belong to a registered port.  Unable to activate port atk.
18:51:46 <lispy> hamishmack: ^^
18:51:51 <co_dh> for example, EqualityComparable is Haskell's Eq
18:52:17 <lispy> co_dh: I haven't stayed up on them, but concepts were inspired by type classes
18:52:26 <lispy> co_dh: last I heard, they were removed from the specification
18:53:13 <co_dh> lispy : do you have the link on : concepts were inspired by type class?
18:53:15 <kmc> co_dh, it depends.  Haskell and C++ both have multiple ways to express that a type conforms to an interface
18:53:46 <hamishmack> lispy: I have not used macports for a while, but when I did I often found myself have blow it away and reinstall (upgrading stuff was hit and miss)
18:53:49 <kmc> co_dh, encodings of OOP in Haskell which use type classes to represent interfaces are often more verbose, more confusing, and less flexible than alternatives
18:54:01 <lispy> co_dh: when I google for it, the acm portal has a publication on it
18:54:06 <lispy> co_dh: http://portal.acm.org/citation.cfm?id=1411318.1411324
18:54:18 <co_dh> lispy: I got it :)
18:54:43 <lispy> co_dh: perhaps "inspired by" is a bit strong
18:54:45 <co_dh> kmc: I prefer functional to OOP.
18:54:47 <kulin> nothing about haskell has made me as miserable as c2hs
18:54:55 <lispy> co_dh: maybe, just "comparable" is better
18:57:59 <kmc> co_dh, they're both tools applicable in different circumstances
18:58:12 <kmc> however programmers today are taught that OOP is the only tool and is to be used in every circumstance, which is clearly false
18:58:31 <Cale> A simplistic way to do OO in Haskell which is nevertheless often sufficient is to just decide on the interface you want to the data, and store those functions already applied to the parameter rather than the value itself.
18:58:37 <Olathe> hlint is neat
18:59:00 <Cale> (in a record datatype, say)
18:59:01 <co_dh> kmc: that makes my life suffer. whenever I talke about Functional to OOP programmers, they looked at me like I'm from Mars. 
18:59:18 <co_dh> even very senior programmer don't know what is Haskell.
18:59:34 <megajosh2> lol
18:59:43 <Cale> Probably senior programmers are less likely to know Haskell than junior ones.
18:59:45 <lispy> We need a "What is a Haskell?" article to motivate the "Learn you a Haskell" book :)
19:02:32 <lispy> co_dh: that's not true everywhere.  some of the senior programmers where I work helped create haskell :)
19:02:58 <co_dh> lispy: where are you working ? 
19:03:10 <lispy> co_dh: galois :)
19:03:32 <co_dh> ok, that famous galois ..  I hope I can work there
19:04:02 <kulin> the biggest reason to learn and use haskell is hard to demonstrate to someone who comes from an oop background
19:04:14 <kulin> its hard to fully express how useful immutable types are
19:04:34 <kmc> kulin, they're useful in OO too, in fact
19:04:42 <lispy> co_dh: one of the best things you can do to make that happen is to do good open source collaborations, get good at haskell, and just do your best :)
19:04:57 <kulin> they are, but its hard to show, you cannot just say "your code will work correctly more often" and have that be a real point to them
19:05:28 <co_dh> lispy: thanks, I'll try some good open source collaboration.
19:05:49 <lispy> co_dh: have you read Karl Fogel's book?
19:06:12 <lispy> co_dh: http://producingoss.com/ available on the web from that page
19:06:21 <ddarius> Probably more useful in OO programming.
19:06:22 <co_dh> what's the title of Karl Fogel's book? I read Richard Bird, and Haskell school of expression.
19:06:57 <co_dh> thanks. I'll try
19:07:45 <megajosh2> Haskell school of expression... I've heard about that book
19:10:20 <kulin> ive read http://blog.ezyang.com/2010/06/the-haskell-preprocessor-hierarchy/ from start to finish and looked at gtk2hs but i need something inbetween the two, do you guys know of any simple projects which use c2hs with c wrapped c++ libraries?
19:12:05 <lispy> kulin: hmm...takusen uses hsc2hs
19:13:10 <lispy> kulin: so outside of examples on ezyang's blog I don't know any c2hs examples
19:13:51 <kulin> ya, and his example really assumes you understand the linking of the .h file to the chs file :( he doesn't go over the #include statement
19:16:45 <lispy> kulin: could you explain a bit more?  Maybe we can help you
19:17:18 <lispy> kulin: oh, this uses c2hs http://hackage.haskell.org/package/cpython-3.1.0
19:18:41 <kulin> well the problem i'm having is when i use basic ffi, i just add the c files to the cabal c-sources and write the foreign imports and the linking is invisible to me
19:19:35 <kulin> in c2hs, you specify the #include "whatever.h" and the process is not automatic, when i do cabal build, it finds whatever.h but all the files that includes and any they include cannot be found
19:20:28 <kmc> include files are not passed directly to the C compiler
19:21:15 <kmc> do you have c files that need to be built?
19:21:33 <kmc> does c2hs generate some?
19:22:23 <kulin> im not sure what i need, i have 5 c files that are compiled by whatever cabal uses when using standard ffi
19:23:03 <kulin> but i am trying to use c2hs {#call } which cannot find the function
19:23:17 <JoeyA> How do I prevent monads-tf from conflicting with mtl?
19:23:18 <kulin> so i assumed that means i need to add #include "whatever.h" to the file 
19:23:31 <kmc> JoeyA, do you need to import both in the same module?
19:23:40 <JoeyA> No
19:24:04 <JoeyA> ghc-pkg hide mtl doesn't help
19:24:07 <kmc> JoeyA, then build with cabal and it will give ghc the right options to expose only the right packages
19:24:41 <JoeyA> ah, ghci -hide-package mtl
19:26:35 <cch`> how to compile executable for i686 on amd64 machine? 
19:26:44 <kmc> cch`, a Haskell program?
19:26:57 <cch`> yes 
19:27:02 <kmc> you want to use GHC?
19:27:08 <cch`> i use ghc
19:27:24 <kmc> using ghc as a cross compiler is difficult
19:27:30 <kmc> i would just set up an i686 chroot
19:27:44 <kmc> and use the native i686 GHC
19:28:08 <cch`> sounds good  idea
19:28:11 <kmc> you might not even need the chroot, depending on how good your distribution's multiarch library support is
19:28:19 <kmc> just grab a 32-bit ghc binary and see if it works
19:28:24 <kmc> (all of the above assumes linux)
19:28:24 <cch`> other compiler than GHC can do that ?
19:28:44 <kmc> yhc produces platform-independent bytecode, and jhc produces portable C code
19:29:01 <kmc> but neither is very popular
19:29:02 <cch`> ok, thanx 
19:29:24 <cch`> then I may use a 32-bit ghc
19:29:29 <kmc> sounds good :)
19:31:17 <cch`> :)
19:39:48 <iFire> so c++ binding to haskell is an unsolved problem?
19:40:16 <iFire> http://github.com/anttisalonen/cgen <- this generates c interfaces from c++
19:41:53 <kmc> cool
19:42:03 <kmc> it's on hackage too
19:42:11 <kmc> and claims to be able to produce haskell bindings
19:43:12 <cch`> i compile a haskell program on a i686 machine, and tried run it on another i686, and first failed due lack of libffi.so, then i copy one from the first i686, and tried and failed again with error : timer_create invalid argument, am I missing anything? I use ghc --make to compile
19:43:20 <mm_freak_> @src forkOS
19:43:20 <lambdabot> Source not found. :(
19:43:36 <mm_freak_> forkOS = forkIO . runInBoundThread  -- true?
19:45:12 <kmc> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Control-Concurrent.html#forkOS
19:45:33 <bos> they're equivalent, yes
19:47:32 <mm_freak_> can i make sure that two bound threads don't share the same OS thread, such that forkOS doesn't prevent parallel execution?
19:48:38 <kmc> bound threads has to do with FFI calls, not ordinary parallel Haskell execution
19:49:03 <mm_freak_> doesn't forkOS ensure that a haskell thread always uses the same OS thread?
19:49:21 <kmc> for its FFI calls, yes
19:49:26 <mm_freak_> ah, i see
19:49:53 <mm_freak_> so for non-FFI code there isn't much difference between forkIO and forkOS?
19:49:58 <kmc> correct
19:50:05 <mm_freak_> thanks
19:50:16 <kmc> if you build with -threaded, you have preemption and parallelism, with either forkIO or forkOS
19:52:12 <dark> seeing that I was going to search for this new OS .-.
19:53:30 <Zao> I need a type that is either "an A and a B", "an A" or "none". Gut instinct says Maybe (A, Maybe B). Any suggestions on more idiomatic ones?
19:53:53 <ezyang> data Foo = Foo A B | Just A | Nothing 
19:54:03 <ezyang> for certain valuse of Foo/Just and Nothing 
19:54:45 <Zao> ezyang: I would like to have the same accessor for the A in case 1 and 2, if possible.
19:55:02 <Zao> I guess I could write a helper function though.
19:55:20 <ezyang> that would be a partial function :-/ 
19:55:33 <Zao> As both A and B in this concrete example are Int, I want named fields to get the right one.
19:55:42 <ezyang> newtype them. 
19:55:49 <ManateeLazyCat> lispy: tdfa very slow? I suppose it's fastest.
19:55:58 <ezyang> And you can pattern match to avoid having to explicitly unwrap. 
19:55:58 <ManateeLazyCat> lispy: I use regex-tdfa lots.
19:55:59 <Zao> ezyang: Then I can't use them for anything useful, can I?
19:56:18 <ezyang> The newtype only exists when it's in the data structure. You're under no obligation to use it any time else. 
19:56:26 <Zao> (super concrete application are OpenGL vertex and index buffers, which as far as I know, are GLuint)
19:56:45 <lispy> ManateeLazyCat: criterion style benchmarks are needed for us to settle this I think.  Sadly I no longer know where I published the results I had 2 years ago.
19:57:08 <ManateeLazyCat> lispy: So which regex library is fastest?
19:57:12 <lispy> ManateeLazyCat: and surely they need to be redone
19:57:20 <lispy> ManateeLazyCat: at the time it was the posix one
19:57:38 <lispy> ManateeLazyCat: at least, I think it was that one.  My memory is not perfect
19:57:41 <ManateeLazyCat> lispy: Infact, i don't like regex's interface, i like some interface like Emacs' regexp match.
19:58:22 <ManateeLazyCat> hamishmack: Try newest gtksourceview2, i have add many new APIs....
19:58:57 <camio> How does one pronounce "DSELs"? Someone said it is "dee-sells", but that is the first I hear of that.
19:59:11 <lispy> camio: I say D-S-Ls
19:59:20 <lispy> dee-es-ells
19:59:31 <camio> Yeah, me too
19:59:33 <lispy> camio: but what is a DSEL?
19:59:41 <lispy> domain specific embedded language?
19:59:47 <camio> yeah
19:59:57 <camio> I'm looking at this webpage: http://cpp-next.com/archive/2010/09/expressive-c-playing-with-syntax/
20:00:09 <ManateeLazyCat> kmc: Yes, many people think OOP is only perfect solution to solve everything....
20:00:11 <camio> Considering calling him out on incorrect pronounciation.
20:00:45 <mm_freak_> cch`: you should install libffi on the target system, not just copy the library
20:00:52 <lispy> camio: I actually see the term DSL or EDSL but never DSEL
20:01:17 <lispy> (the latter, I would say diesel like the fuel)
20:01:37 <mm_freak_> ManateeLazyCat: honestly sometimes i miss OOP in haskell, but usually there is a more haskellish (and often more elegant) solution
20:02:07 <ManateeLazyCat> mm_freak_: I never use OOP now, i think Haskell's way is more elegant.
20:02:36 <mm_freak_> ManateeLazyCat: OOP is elegant for things like a game world
20:03:17 <mm_freak_> the FRP implementations i've seen so far didn't make a good replacement plus they had a noticable speed impact
20:03:19 <ddarius> Many "elegant" Haskell solutions are recreating aspects of OOP.
20:03:20 <ManateeLazyCat> mm_freak_: Yes, different role with OOP hierarchy...
20:04:17 <lispy> OOP can be elegant, but elegance is hard so many things are not.
20:04:32 <mm_freak_> lispy: i agree
20:04:59 <ManateeLazyCat> kulin: I suggest you read source code gtk2hs, we use "pkg-config --cflags" return path of header.
20:05:06 <ManateeLazyCat> file
20:05:38 <Axman6> camio: i've always seen them referred to as EDSLs, not DSELs
20:05:59 <lispy> I would think that a DSEL is a way of writing code for embedded platforms
20:06:54 <ManateeLazyCat> mm_freak_: I think you don't need use forkOS, just forkIO with "-threaded" can work.
20:06:56 <camio> http://conal.net/papers/dsl97/dsl97.html <- looks like conal referred to it as DSEL here.
20:07:48 <mm_freak_> ManateeLazyCat: when it comes to concurrency you always seem to misunderstand my questions =)
20:08:09 <ManateeLazyCat> mm_freak_: Hehe .:)
20:08:53 <kulin> manateelazycat, you use that where?
20:09:28 <ManateeLazyCat> kulin: http://code.haskell.org/gtk2hs/
20:10:18 <kulin> im just not sure what you do, because i have the pkg-config depends setup for cabal
20:11:21 <ManateeLazyCat> kulin: Your C library is base on glib?
20:11:30 <cch`> mm_freak_: before I copied libffi, it failed with saying libffi not found, and after I copied it didn't complained that again
20:11:41 <tmo_`> Also, I can see how individual characters trigger an event, but how do I combine a normal character key with a modifier to trigger an event in wxHaskell?
20:11:51 <mm_freak_> cch`: that doesn't mean copying will give you a working library
20:11:58 <kulin> im not using glib
20:12:21 <mm_freak_> cch`: better install it properly using your package manager
20:12:53 <kulin> it looks like the headers it is not able to build are cpp headers included 3 levels or more deep in the header tree
20:12:55 <cch`> understood, let me try. thanx
20:13:00 <kulin> stuff like iostream.h
20:14:21 <ManateeLazyCat> kulin: I suggest you ask ezyang about those, my English is not good enough explain those clearly.
20:15:09 <kulin> i think the problem is my understand is just not deep enough, it seems there is some fundamental part of linking c/c++ libraries to haskell libraries that I am ignorant of
20:15:22 <interferon> what's new about the type inference engine in ghc 7?
20:15:46 <ManateeLazyCat> ezyang: Can you talk Haskell binding knowledge to kulin ?
20:16:03 <ManateeLazyCat> ezyang: Or post your blog link . :)
20:16:42 <lispy> interferon: they're removing algebraic datatypes in favor of subtyping
20:16:44 <kulin> ive read his c2hs blog, but his section 'Setting up Cabal, the FFI and c2h' is not clear
20:16:47 <kulin> for me
20:16:48 <lispy> interferon: (just kidding)
20:16:51 <interferon> lispy: :)
20:17:13 <bos> c2hs is generally not necessary.
20:17:27 <kulin> bos, true, but everything i want c2hs has
20:17:35 <kulin> if i could just get the code linked correctly
20:19:29 <camio> lispy: I was just catching up and was a bit bewildered for a second there. Good one.
20:21:12 <lispy> camio: I do what I can to confuse people ;)
20:22:05 <camio> lispy: The thing that got me was that you properly called it "subtyping" instead of OO or something obviously impossible.
20:22:21 <ManateeLazyCat> kulin: There is simple example : https://patch-tag.com/r/AndyStewart/libtagc/snapshot/current/content/pretty
20:25:29 <kulin> ManateeLazyCat, unless I am missing something, TagLib.hsc might as well be a regular haskell file
20:26:16 <ManateeLazyCat> kulin: If you have many C header file need include, you need create foo.h to include those header files and add in filed Extra-Source-Files of foo.cabal.
20:27:27 <ManateeLazyCat> kulin: Key is those fields in foo.cabal : Extra-libraries x-c2hs-Header pkgconfig-depends
20:27:48 <ManateeLazyCat> kulin: If pkg-config can return correct path, other thing is pretty easy.....
20:27:50 <kulin> what does x-c2hs-header do? i use the other two already
20:28:30 <ManateeLazyCat> kulin: pkgconfig-depends is give the library name that you need search. x-c2hs-Header is header files you need use.  
20:29:31 <ManateeLazyCat> kulin: Example ligtagc.cabal will call pkg-config do "pkg-config --cflags taglib_c" return library path.
20:29:47 <ManateeLazyCat> kulin: Then search some header file you given in filed x-c2hs-Header
20:30:49 <kulin> hmm it might be better if i can just post my project and the errors somewhere
20:31:29 <ManateeLazyCat> kulin: Yes, post error helpful.
20:41:59 * hackagebot hmatrix-static 0.3.0.2 - hmatrix with vector and matrix sizes encoded in types  http://hackage.haskell.org/package/hmatrix-static-0.3.0.2 (ReinerPope)
20:42:56 <NemesisD> is there an equivalent of intercalate for Strings (glue an array of strings together with a glue string)
20:43:06 <ddarius> intercalate
20:43:12 <Antimayate> making kites?
20:43:17 <Antimayate> why glue strings?
20:43:21 <koninkje> :t Data.List.intercalate
20:43:21 <NemesisD> hoogle said its for byte strings
20:43:22 <lambdabot> forall a. [a] -> [[a]] -> [a]
20:43:34 <Antimayate> is this some sort of chocolate boys and girls club inner city self esteem exercise?
20:43:34 <NemesisD> hoogle fail :(
20:43:39 <ddarius> @hoogle intercalate
20:43:40 <lambdabot> Data.ByteString intercalate :: ByteString -> [ByteString] -> ByteString
20:43:40 <lambdabot> Data.List intercalate :: [a] -> [[a]] -> [a]
20:43:40 <lambdabot> Data.ByteString.Char8 intercalate :: ByteString -> [ByteString] -> ByteString
20:44:46 <mtnviewmark> hey - I made kites with paper, string and glue as an inner city youth - and it was hella-fun ---- don't know about the self-esteem....
20:52:24 <Raghs> I am doing cabal install glade and get the error The pkg-config package libglade-2.0 version >=2.0.0 is required but it could not be found.
20:52:38 <Raghs> I have the Glade applicaiton installed on WIndows 7..
20:53:33 <Raghs> http://groups.google.com/group/haskell-cafe/browse_thread/thread/f2ff2ee7f1fb12d7 mentoins an edit to the lglade-2.0.pc
20:53:40 <Raghs> what is the edit?
20:54:51 <ManateeLazyCat> Raghs: http://osdir.com/ml/haskell-cafe@haskell.org/2010-09/msg00594.html
20:55:51 <Raghs> I tried this couple of times, but can't seem to figure it out..
20:58:19 <ManateeLazyCat> brb to lunch...
21:02:29 <Walt> Hi, I currently write quite a bit of F#, using vim. And I am always slightly annoyed I do not have a tool that can do the type inference and tell me the types of functions. Are such tools available for haskell?
21:02:44 <Walt> (I know visual studio has it for F#, but I dont like VS at all)
21:05:49 <Rotaerk> Walt, hrm, you don't like VS?
21:06:26 <Rotaerk> Walt, also, yes, there are vim extensions for haskell
21:07:17 <Zao> Walt: http://projects.haskell.org/haskellmode-vim/
21:07:45 <copumpkin> quickcheck is a refactorer's best friend
21:08:14 <ezyang> automated tests are a refactorer's best friend... 
21:08:25 <Rotaerk> when I saw him mention F#, I assumed I was in the F# channel...
21:08:38 <Rotaerk> now I realize that was stupid considering the number of people that entered since his question
21:13:00 <Walt> Zao, I didn't see it mentioned, but does that plugin allow you, for example, to place cursor over a word, hit a command, and get the type of the function?
21:13:38 <Rotaerk> Walt, I believe you can mouse over identifiers.
21:13:42 <Rotaerk> I used it a while back...
21:13:44 <Walt> What I am asking really, is, do haskellers coding without something being able to tell the the type of something find it hindering?
21:13:50 <Walt> Rotaerk, cool
21:13:56 <kulin> ManateeLazyCat: https://patch-tag.com/r/kulin/mogwai-dev/snapshot/current/content/pretty there's my code, and the first page of the wiki has the error
21:14:01 <Rotaerk> but try it to see if it does exactly what you want
21:14:25 <Walt> I want to write something similar for F# in vim, but I don't think the license of the compiler would allow it
21:14:32 <Walt> to be published that is
21:14:58 <Walt> Rotaerk, I dont write haskell, I am just asking since it is a similar language in this aspect
21:15:10 <Rotaerk> what does the compiler have to do with it
21:15:37 <Rotaerk> I guess I'm not familiar with how those things work underneath
21:16:30 <Walt> Rotaerk, well, at some point the compiler determines the types, at that point one could grap the AST and present it
21:16:38 <Walt> Rotaerk, the F# compiler is open source
21:17:01 <Walt> basically, writing a lexer/parser/type inferer for F# from scratch would suck really hard
21:17:04 <Walt> and take ages
21:17:21 <Rotaerk> Walt, you can compile F# using .NET calls
21:17:28 <Zao> Walt: Yes.
21:17:34 <Zao> Walt: Either by key or hovering in a GUI vim.
21:17:34 <dark> the official f# compiler?
21:17:44 <Walt> dark, yes
21:17:55 <Zao> Walt: While useful, I rarely need to query the types of things while coding.
21:18:03 <dark> hard to believe (since microsoft .net is closed source)
21:18:03 <Rotaerk> anyway, might as well bring this conversation back to ##fsharp as I'm sure they don't care :P
21:18:07 <Walt> dark, well, it's not open source. But the source is available
21:18:18 <dark> ahh
21:18:19 <Zao> Walt: If you're on Windows, Phyx- is working on a Visual Studio 2010 language service for Haskell.
21:18:23 <Zao> Walt: Ought to be out any decade now.
21:18:24 <dark> now I believe it easily. :)
21:18:29 <Zao> It'll have intellisense and the whole shebang.
21:18:50 <Walt> Zao,  :)
21:18:52 <Rotaerk> shebangs, shebangs
21:19:02 <Walt> Zao, Might be around the time when I actually get to writing haskell
21:19:04 <Zao> Rotaerk: I knew it, Shakira uses Unix.
21:19:07 <Walt> I have always looked at it from a distance
21:19:09 <Rotaerk> :P
21:19:15 <Walt> nevre gotten my hands dirty
21:19:33 <Zao> Oh wait, that was Ricky Martin.
21:19:37 <Rotaerk> yea
21:19:40 <Walt> Zao, however, as I said, I don't like VS anyway :)
21:19:50 <Rotaerk> I don't see why
21:19:55 <Walt> It's just this one feature that would be nice. Not having the types is sometimes quite hindering for me
21:20:02 <Rotaerk> unless your computer is crap, in which case I understand completely..
21:20:08 <Walt> when the code becomes complex and it was a while since I wrote it
21:20:42 <Walt> Rotaerk, I have vim set up the way I want, and it is the same for whatever I am editing. And VS doesnt really give me anything
21:20:56 <Walt> except for some language specific things, like the type inference thing
21:21:04 <Walt> which is a shame
21:21:26 <Zao> Walt: That haskell-mode vimball can even call up haddock documentation for things.
21:21:40 <Rotaerk> Walt, hrm, that's what an IDE's all about... language-specific tools
21:21:43 <Walt> Zao, yeah I saw that :)
21:21:56 <Rotaerk> and the ability to debug and step through, built in
21:22:01 <Walt> Rotaerk, it's too bad everything else in it sucks ass
21:22:09 <JoeyA> Is there a way to have a module export a module without having to list all module exports explicitly?
21:22:27 <kulin> JoeyA, yes ( module Whatever.Name )
21:22:28 <JoeyA> By default (e.g. module Foo where), imported modules aren't exported.
21:22:35 <Rotaerk> I put a module in your module so you can module while you module
21:22:52 <JoeyA> but with module Foo (blahblah), I have to explicitly name everything.
21:22:57 <JoeyA> Sure, that's good practice later on.
21:23:06 <kulin> joeya, i just gave you the answer
21:23:23 <kulin> module Pie ( module Pie.Cherrie ) where
21:23:24 <Stuck0> does anyone know anyhing about algorithms
21:23:29 <Walt> nope
21:23:32 <Walt> nothing
21:23:45 <Rotaerk> lol
21:23:49 <JoeyA> kulin: but then it stops exporting everything else, doesn't it?
21:23:54 <lispy> > compare 1 1
21:23:55 <lambdabot>   EQ
21:24:07 <kulin> module Pie ( module Pie.Cherrie, module Pie.Apple, bakePie ) where
21:24:30 <JoeyA> Thing is, I don't want to have to manually list all my exports so soon.
21:24:54 <mtnviewmark> type Ironic a  = I (a (a ())) -> a (a ())
21:24:55 <kulin> well if you plan your modules right, you can have all the stuff you dont want to specify in one module
21:25:18 <JoeyA> I want to be able to do something like module Foo (module Bar, ..)
21:25:23 <JoeyA> In the future, I can manually list them.
21:25:44 <JoeyA> But early on in the development of the module, I don't want to deal with that crap.
21:26:03 <kmc> module Foo (module Foo, module Bar)
21:26:04 <kulin> ie: file1 -> module Pie.Common where, file2 -> module Pie.Cherrie where, file3 -> module Pie ( module Pie.Common, Pie.Cherrie ) where
21:26:15 <Walt> the primary goal when writing code, is to not have to write more code
21:26:23 <kulin> do not put anything but imports in module Pie where, and put all your random functions in Pie.Common
21:26:25 <JoeyA> ah, I see
21:26:26 <kmc> JoeyA, should work (if i guess your problem correctly)
21:26:39 <Dilberto> netsplit!
21:26:42 <Dilberto> tired of niggers
21:26:43 <Dilberto> i am
21:26:49 <Dilberto> if you are sick of niggers  join chimpout forum
21:26:55 <Dilberto> http://www.chimpout.com/forum
21:27:03 --- mode: ChanServ set +o bos
21:27:13 --- mode: bos set +b *!*bddc1619@gateway/web/freenode/ip.189.220.22.25
21:27:18 --- kick: Dilberto was kicked by bos (Dilberto)
21:27:24 <lispy> bos++
21:27:39 <Axman6> dayum, you're fast man
21:28:24 <dark> I want a library for computing md5sums of bytestrings, and another for computing the mime-type (using a database/procedure similar to file command). I probably don't want Data.Digest.Pure, right?
21:28:45 <JoeyA> lispy:  funny how a Haskell channel user uses a C neologism
21:29:05 <lispy> JoeyA: succ bos?
21:29:24 <lispy> JoeyA: It's what lambdabot recognizes though
21:29:25 <JoeyA> hehe
21:29:26 <lispy> ?karma bos
21:29:27 <lambdabot> bos has a karma of 9
21:29:36 <JoeyA> ah
21:29:41 <JoeyA> JoeyA--
21:29:45 <JoeyA> ?karma JoeyA
21:29:46 <lambdabot> You have a karma of 0
21:29:47 <Veinor> ?karma c
21:29:48 <lambdabot> c has a karma of 3
21:29:49 <Veinor> c++
21:29:51 <Veinor> ?karma c
21:29:51 <lambdabot> c has a karma of 3
21:30:00 <JoeyA> succ c
21:30:02 <JoeyA> ?karma c
21:30:02 <lambdabot> c has a karma of 3
21:30:04 <lispy> JoeyA: if you want to lower your karma there is an easter egg related to java :)
21:30:07 <dark> C++ doesn't improve anuthing
21:30:25 <Axman6> ha
21:30:39 <JoeyA> dark:  I find CryptoHash to work well:  http://hackage.haskell.org/package/cryptohash
21:31:49 --- mode: bos set -o bos
21:32:03 <JoeyA> Just a thought: MD5 hash collisions can be found in minutes, so you may want to consider using SHA1 hashes instead in the edge case that a user decides to toy with MD5-collided files.
21:32:05 <dark> what about mime-types? ._. I want just image/* and text/*. I probably could code this myself; it's basically image/png, image/jpeg, image/gif, text/html, but.. I don't want to
21:32:10 <JoeyA> However, SHA1 hashing is slower, of course.
21:32:30 <dark> (I mean, I have a vague notion of magic numbers and such)
21:33:03 <dark> JoeyA, minutes? wow
21:33:20 <JoeyA> or so I've heard.  In any case, they can certainly be found.
21:33:30 <dark> within some years, maybe seconds? microseconds? almost instantaneous collisions
21:33:49 <dark> thousands of arbitrary collisions in a few nanoseconds
21:33:50 <JoeyA> However, MD5 takes 45% as long to compute as SHA1, at least with CryptoHash.
21:34:09 <JoeyA> And for reading from a disk, hashing will be a bottleneck.
21:34:16 <JoeyA> (will most likely*)
21:34:29 <JoeyA> I don't know about mime types, sorry.
21:34:30 <dark> JoeyA, yes.. I'm computing with find -type f -exec md5sum {} + > md5s. I could use md5deep too, but
21:34:49 <dark> md5 is way faster than sha1
21:35:19 <dark> I could probably continue to use the md5sum program itself, but, would like to try it in haskell
21:35:21 <tommd> And should be way less used
21:35:47 <shachaf> tommd: MD5 isn't *horrible* for things like verifying downloads.
21:35:49 <dark> there are, still, valid crc32 uses
21:36:08 <tommd> It depends why you verify them, what your verifying them to prevent.
21:36:21 <JoeyA> I've been working on a program to try to solve my data hoarding problem.  I'm calling it "packrat"
21:36:27 <JoeyA> It's extremely early in development.
21:36:35 <dark> data hoarding?
21:36:49 <JoeyA> As in, having 3 million files and being afraid to delete any of them.
21:36:59 <dark> :)
21:37:04 <JoeyA> Or wanting a tool to automate deduplication, verification, or removal.
21:37:47 <dark> (md5sum isn't, also, horrible, for finding duplicated files. one can find 'almost matches' with md5, and then compare the files byte-to-byte to be 100% sure. one can skip the byte-to-byte comparison and still have a high degree of certainty too)
21:37:48 <JoeyA> I think "hoarding" is an apt term because duplicity is too slow for my needs.
21:38:19 <JoeyA> The backup programs I looked into (like duplicity, etc.) simply don't deal with millions of files efficiently.
21:38:33 <vanadium> Why'd you use sha1 for that?
21:38:37 <dark> my files are a mess. I would like to have this dealt at filesystem level
21:38:40 <vanadium> Wht'd'nt
21:38:46 <dark> vanadium, there is no need
21:38:47 <JoeyA> dark: Agreed
21:38:57 <JoeyA> However, btrfs is taking an eternity
21:38:59 <dark> since for any match, I can compare the files if I want to
21:39:07 <tommd> JoeyA: How polished do you want it?  This can be a very quick and dirty hack (in shell, in Haskell, in whatever)
21:39:08 <tommd>   fs <- getFiles
21:39:08 <tommd>   hs <- mapM hashFile fs
21:39:08 <tommd>   let groups = groupBy fst (zip hs fs)
21:39:08 <tommd>   mapM_ deleteFiles (map (drop 1) groups)
21:39:16 <vanadium> Or you could just use sha1
21:39:31 <dark> vanadium, I will not actually compare the files
21:39:36 <JoeyA> tommd: stack overflow :P
21:39:56 <kmc> dark, you could store all your files in git
21:40:14 <tommd> ?
21:40:21 <dark> kmc, I have /etc in git as a proof-of-concept (proof at least to me)
21:40:34 <kmc> err maybe should have directed that at JoeyA
21:40:38 <dark> but ever-changing binary files easily takes up a lot of space o.o
21:40:43 <dark> ahm
21:40:50 <kmc> in Git identical files are commoned up by definition
21:40:56 <JoeyA> mapM (not mapM_) sucks in IO.  I'd link you to my code that benchmarks it against a better strict mapM reversing a list, but hpaste isn't responding.
21:40:56 <dark> hm
21:41:14 <JoeyA> mapM works better with lazy monads.  IO is a strict monad, so the thunks stack up.
21:41:28 <JoeyA> I considered using git
21:41:37 <JoeyA> However, it uses linear space w.r.t. file size.
21:41:44 <JoeyA> So if you have a 1GB file, it'll use 1GB of RAM.
21:41:49 <JoeyA> or 2GB, if you change it.
21:42:35 <JoeyA> and I have a 25GB file image floating around.
21:42:50 <tommd> JoeyA: So you have _so_ many files you want to hash them one at a time, building a huge "Map Hash FilePath" and only delete if there is another element in the map?  Something like this?
21:42:52 <dark> you could handle very large files in a special way
21:43:03 <JoeyA> Well, I want to do a little more than that.
21:43:11 <JoeyA> I did implement a hard link deduplicator, but it uses too much RAM.
21:43:26 <JoeyA> It works on at most ~1000000 files.
21:43:38 <JoeyA> (using 1.4GB of RAM)
21:43:46 <wli> Describe what hard link deduplication is supposed to be.
21:43:47 <dark> you don't need to process all files at time
21:43:47 <JoeyA> So now I need to store the file entries into a database
21:44:03 <kmc> the fast first step to deduplicating is to group by size
21:44:13 <dark> wli, you have two identical files with different inodes, you delete one and then hard link its path to the other
21:44:15 <JoeyA> Right.  Been there, done that
21:44:16 <kmc> because you can get that from stat() without reading the file at all
21:45:05 <JoeyA> As I said, I implemented the operation you're describing in-RAM.
21:45:09 <JoeyA> With a pretty progress bar.
21:45:18 <JoeyA> It was a thrill to watch it deduplicate... 300MB.
21:45:59 <JoeyA> I plan on doing more sophisticated operations, though.
21:46:06 <JoeyA> Such as consolidating backups.
21:46:20 <wli> JoeyA: How much does it actually find on real running filesystem images?
21:46:21 <JoeyA> As in, I have two huge piles of files, and I forget how they're organized.
21:46:30 <JoeyA> (I used a hard drive to back up some stuff)
21:46:44 <JoeyA> So I want to efficiently make it so both of my big hard drives hold the same thing.
21:46:48 <JoeyA> and hold new files.
21:47:02 <JoeyA> wli: what do you mean?
21:47:06 <JoeyA> It just does by-file deduplication.
21:47:20 <JoeyA> I considered doing block-level dedup.
21:47:33 <wli> JoeyA: How much deduplication is it typically able to do on filesystems in actual use etc.?
21:47:54 <dark> JoeyA, the filesystem-level deduplicators seems to operate continuously, when the load is low enough. so you could do that: a daemon, notified by some api, watching changes, and acting when the load is low. (and they seem to operate at block-level or some other smaller-than-a-file level, which seems more effective, too..)
21:47:56 <JoeyA> Well, the problem is, you really don't want to do it on a file system you're using actively.
21:48:00 <JoeyA> (such as your home directory)
21:48:08 <JoeyA> hard links are references.
21:48:45 <JoeyA> so if you echo > hello; echo > world; rm world && ln hello world
21:48:59 <JoeyA> Then echo something > hello will change world as well.
21:49:07 <JoeyA> Not safe at all on a live system.
21:49:20 <dark> hmm
21:49:37 <JoeyA> that's an interesting idea, but I don't want to have my hard drives plugged in all the time.
21:50:08 <JoeyA> I also want to be able to verify backups.
21:50:22 <JoeyA> That would involve hashing _all_ files into a database.
21:50:37 <JoeyA> (all regular files with unique device id/inode, to be more specific)
21:53:37 <wli> Well, it's ultimately only a way to avoid more thorough comparisons.
21:55:52 <dark> I want to suppress regular messages like [1 of 1] Compiling Main             ( .hello2.hs, .hello2.o ) and Linking .hello2 ... but not error messages like .haskell~.hs:6:9: parse error on input `;'
21:56:04 <dark> is there some "quiet" or "less verbose" flag for ghc?
21:56:16 <dark> hm maybe -v0
21:56:32 <Maxdamantus> @pl \z a b c d e f g h i j k l m n o p q r s t u v w x y -> z y x w v u t s r p q o n m l k j i h g f e d c b a
21:56:35 <lambdabot> flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .)
21:56:36 <lambdabot> .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . ((((((((((flip .) .) .) .) .) .) .) .) .) .) . (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((flip .) .) .) .) .) .) .) .) .) .) .)
21:56:36 <lambdabot> .) . (((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((
21:56:36 <lambdabot> (((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . (((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .)
21:56:36 <lambdabot>  .) .) .) .) .) .) . (((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((((((((((((((flip .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) .) . ((((((((
21:56:38 <lambdabot> [52 @more lines]
21:56:39 <lambdabot> optimization suspended, use @pl-resume to continue.
21:56:40 <Maxdamantus> O_o
21:56:41 <SubStack> bwahaha
21:58:27 <JoeyA> I sure hope lambdabot was wearing a helmet!
21:59:05 <Maxdamantus> Is there anything that can be interpreted by @pl but not refactored?
21:59:18 <Maxdamantus> er, made "pointless"*
21:59:25 <dark> I heard that yes
21:59:45 <dark> or, at least, I saw some string that couldn't be made pointless by its current algorithm
22:00:08 <dark> @src flip
22:00:09 <lambdabot> flip f x y = f y x
22:00:13 <dark> ah
22:00:40 <Axman6> @pl f x y = case x of Just z -> z; Nothing -> case y of [] -> error "wut"; (a:_) -> a
22:00:43 <lambdabot> (line 1, column 26):
22:00:47 <lambdabot> unexpected ">" or "-"
22:00:49 <lambdabot> expecting variable, "(", operator or end of input
22:00:54 <Maxdamantus> It doesn't do complex syntaxes
22:01:02 <Maxdamantus> just functions and some operators
22:01:23 <Maxdamantus> and lambdas, and .. I dunno
22:01:26 <dark> but even with its simplified syntax, I think I saw some example, but I don't know what
22:01:41 <dark> I mean, just with lambdas (no operator)
22:02:13 <Axman6> @pl \a b c d e f ->  f e d c b a
22:02:13 <lambdabot> flip (flip . ((flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
22:02:17 <dark> at pvt: <lambdabot> Plugin `pl' failed with: thread killed
22:02:19 <Axman6> ouch, wtf happened there?
22:02:20 <dark> ._.
22:02:36 <Maxdamantus> @pl \a b c d e -> (,,,,) e d c b a
22:02:37 <lambdabot> flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip (,,,,))))
22:02:54 <dark> I think that any permutation of parameters can be made by flip
22:03:05 <Maxdamantus> Indeed.
22:03:12 <monochrom> but it takes nlogn flips :)
22:03:23 <Axman6> :t let a = ((),()); b = (a,a); c = (b,b); d = (c,c); in (d,d)
22:03:24 <lambdabot> ((((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))), (((((), ()), ((), ())), (((), ()), ((), ()))), ((((), ()), ((), ())), (((), ()), ((), ())))))
22:03:50 <monochrom> oh darn, nlogn may be wrong
22:04:01 <Maxdamantus> @pl (=<<) . (return .)
22:04:01 <lambdabot> fmap
22:04:26 <dark> @pl \x -> (\x y -> x x y) x x -- amazing imo
22:04:27 <lambdabot> join (join id)
22:04:27 <Maxdamantus> Wouldn't nlogn be the worst case?
22:04:32 <dark> .-.
22:04:36 <Maxdamantus> Wait, in what base?
22:04:49 <Maxdamantus> n log2 n maybe for worst
22:04:55 <dark> in terms of complexity this is immaterial
22:04:57 <SubStack> @pl \[n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m] -> [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z]
22:04:58 <lambdabot> (line 1, column 2):
22:04:58 <lambdabot> unexpected "["
22:04:58 <lambdabot> expecting pattern
22:04:58 <Veinor> Maxdamantus: it's a big-O approximation so base doesn't matter
22:05:14 <SubStack> @pl (\[n,o,p,q,r,s,t,u,v,w,x,y,z,a,b,c,d,e,f,g,h,i,j,k,l,m] -> [a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z])
22:05:14 <lambdabot> (line 1, column 3):
22:05:14 <lambdabot> unexpected "["
22:05:14 <lambdabot> expecting pattern
22:05:17 <Veinor> @pl \a b c d e f g h i j k l -> l k j i h g f e d c b a
22:05:18 <SubStack> mmm
22:05:20 <Maxdamantus> Really? This can be applied to big-O?
22:05:21 <lambdabot> flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .)
22:05:21 <lambdabot> .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . (((
22:05:21 <lambdabot> ((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .)
22:05:21 <lambdabot> .) .) .) . (((((((flip .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip (flip . (
22:05:21 <lambdabot> flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . flip (flip . (flip .) .
22:05:22 <lambdabot> ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))))))))))
22:05:24 <monochrom> nlogn is the number of comparisons to determine the right permutation. not necessarily number of flips to do the permutation.
22:05:25 <lambdabot> optimization suspended, use @pl-resume to continue.
22:05:25 <Veinor> OH GOD
22:05:47 <dark> Maxdamantus, O(nlogn) is a set of functions (the set that grows at most as much as nlogn)
22:06:07 <Maxdamantus> But.. it's dealing with discrete inputs
22:06:14 <Maxdamantus> so presumably there's meant tobe a discrete base
22:06:22 <dark> "grows as much" meaning that lim f / nlogn, n -> inf, is finite
22:06:22 <Maxdamantus> not like we're dealing with 3-dimensional flips
22:06:27 <Maxdamantus> or rotates, maybe
22:06:30 <Maxdamantus> @src rotate
22:06:31 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
22:06:37 <Maxdamantus> @src rot
22:06:38 <lambdabot> Source not found. I feel much better now.
22:06:39 <dark> hm
22:06:52 <Veinor> finite and nonzero
22:06:53 <monochrom> base 4.2
22:07:29 <Maxdamantus> @hoogle (a -> b -> c -> d) -> c -> d -> b
22:07:30 <lambdabot> Data.IntMap intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
22:07:31 <lambdabot> Data.IntMap insertWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> IntMap a
22:07:31 <lambdabot> Data.IntMap unionWithKey :: (Key -> a -> a -> a) -> IntMap a -> IntMap a -> IntMap a
22:07:42 <Maxdamantus> Hm.
22:07:54 <Maxdamantus> @pl \f a b c -> f b c a
22:07:54 <lambdabot> flip . (flip .)
22:07:59 <Maxdamantus> :\
22:08:14 <dark> I mean, both n * ln(n) and n * log10(n) belongs to O(nlogn). but hmm. I saw some algorithm proofs that used specific bases, like sqrt2 or 2, while giving a exact number of steps
22:09:52 <Veinor> @pl \a b c -> b c a
22:09:52 <lambdabot> flip flip
22:11:10 <Maxdamantus> @pl \a -> b
22:11:11 <lambdabot> const b
22:11:21 <kmc> :t join id
22:11:23 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a)
22:11:23 <lambdabot>     Probable cause: `id' is applied to too few arguments
22:11:23 <lambdabot>     In the first argument of `join', namely `id'
22:11:36 <kmc> :t join (join id)
22:11:37 <lambdabot>     Occurs check: cannot construct the infinite type:
22:11:37 <lambdabot>       m = (->) (m (m a))
22:11:37 <lambdabot>     Probable cause: `id' is applied to too few arguments
22:11:45 <kmc> @pl \x -> (\x y -> x x y) x x
22:11:46 <lambdabot> join (join id)
22:11:48 <kmc> what gives
22:12:34 <ivanm> interesting...
22:12:49 <ivanm> kmc: my guess is that @pl is making the two `x' variables the same
22:12:59 <ivanm> @pl \ x -> (\z y -> z z y) x x
22:12:59 <lambdabot> join (join id)
22:13:06 <ivanm> huh, it isn't
22:13:12 <ivanm> @ty[e \ x -> (\z y -> z z y) x x
22:13:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1 -> t2
22:13:13 <lambdabot>     Probable cause: `z' is applied to too many arguments
22:13:14 <lambdabot>     In the expression: z z y
22:13:25 <kmc> oh, it will pointlessify ill-typed expressions?
22:13:31 <kmc> fair enough...
22:13:41 <kmc> @pl (\x -> x x) (\x -> x x)
22:13:45 <lambdabot> ap id id (ap id id)
22:13:45 <lambdabot> optimization suspended, use @pl-resume to continue.
22:13:54 <Maxdamantus> @pl-resume
22:14:01 <lambdabot> ap id id (ap id id)
22:14:01 <lambdabot> optimization suspended, use @pl-resume to continue.
22:14:41 <Mitar> i have many worker threads and I would like that once one of them gets an exception this exception is propagated around to all other threads, this is why i at the end of exception handling of every thread reraise the exception in the main thread, but the problem is that i cannot run clean-up code in other threads as clean-up code is interrupted by all this exceptions which then propagate back from other threads (clean-up in some threads does IO and so it unblocks 
22:15:00 <kmc> @pl \f -> (\x -> f (x x)) (\x -> f (x x))
22:15:01 <lambdabot> ap (. join id) (. join id)
22:20:52 <Maxdamantus> > (\l -> [,,] (l !! 2) (l !! 1) (l !! 0)) [1,2,3]
22:20:54 <lambdabot>   <no location info>: parse error on input `,'
22:21:15 <Maxdamantus> > (\l ->  (l !! 2) : (l !! 1) : (l !! 0) : []) [1,2,3]
22:21:16 <lambdabot>   [3,2,1]
22:21:27 <Maxdamantus> @pl \l ->  (l !! 2) : (l !! 1) : (l !! 0) : []
22:21:28 <lambdabot> liftM2 (:) (!! 2) (liftM2 (:) (!! 1) (return . (!! 0)))
22:22:57 <copumpkin> sounds like a job for sequence
22:23:30 <copumpkin> :t sequence . map (!!) $ [2, 1, 0]
22:23:32 <lambdabot> forall a. (Num [a]) => Int -> [a]
22:23:46 <copumpkin> whoops
22:23:48 <ivanm> copumpkin: or just mapM ...
22:23:55 <copumpkin> true
22:24:05 <copumpkin> :t \l -> mapM (l !!) $ [2, 1, 0]
22:24:07 <lambdabot> forall (m :: * -> *) b. (Monad m) => [m b] -> m [b]
22:27:23 <Zao> http://pastie.org/1153226 <- some errors make you laugh out loud in disbelief
22:28:26 <monochrom> rename lift to twilight. get twilight zones
22:31:31 <Veinor> haha
23:21:26 <kulin> Prelude, using all the good words
23:24:29 <dark> Prelude, using all the god words
23:27:46 * hackagebot msgpack-rpc 0.3.1.3 - A MessagePack-RPC Implementation  http://hackage.haskell.org/package/msgpack-rpc-0.3.1.3 (HideyukiTanaka)
23:35:14 <Nibble> I <3 darcs
23:35:16 <Nibble> Shall I record this change? (13/2364)
23:35:18 <Nibble> :(
23:35:29 <Nibble> any way to avoid all those?
23:35:53 <c_wraith> you can use the -a flag.
23:36:02 <Nibble> c_wraith: thanks
23:36:19 <kulin> you work too hard, you are making all us other (1/10) people look bad
23:36:21 <c_wraith> though that's the same as hitting "a" when it asks about a change
23:36:34 <Nibble> kulin: I am putting my home dir under darcs.
23:36:40 <Nibble> will be pure awesomeness
23:37:24 <Nibble> also. 
23:37:32 <Nibble> It runs out of memory on my machine
23:37:34 <Nibble> :(
23:37:45 <Nibble> that was bad
23:38:10 <Nibble> you can't be serious..
23:39:04 <Nibble> c_wraith: is this a known issue?
23:39:10 <Nibble> I can't put all of my
23:39:20 <c_wraith> darcs has...  some issues.
23:39:27 <Nibble> c_wraith: some issues...
23:39:29 <c_wraith> Which is why I've quit using it
23:39:29 <Nibble> lol
23:39:42 <c_wraith> The interface is great, the execution is painful
23:40:02 * Veinor just uses git
23:40:04 <Nibble> c_wraith: I guess I will just use git.
23:40:16 * Veinor feels vaguely like a traitor
23:40:43 <Nibble> Veinor: you can't betray something that uses 2GB of ram when doing a commit...
23:45:41 <ddarius> > 400000000000 / (1024*1024)
23:45:42 <lambdabot>   381469.7265625
23:46:38 <ddarius> > 95476*1024*1024
23:46:40 <lambdabot>   100113842176
23:54:58 * hackagebot secure-sockets 1.0.1 - Secure point-to-point connectivity library  http://hackage.haskell.org/package/secure-sockets-1.0.1 (DavidAnderson)
