00:00:09 <kmc> seems like you want a "higher-rank constraint"
00:00:23 <augur> ski: well, you build up this call stack, roughly some sort of stack that behaves like (lambda (x) (+ 1 (* 2 x))))
00:00:32 <ski> yes
00:00:33 <kmc> ∀a. (Ord a, ∀s. MArray (STUArray s) a (ST s)) ⇒ …
00:00:37 <kmc> except GHC doesn't support these
00:00:55 <kmc> Axman6, the caller of heapsort notionally gets to pick an 's', and runST notionally gets to pick a different 's'
00:01:20 <augur> ski: so then you "apply" that proc-ish-thing, call it K, as (K 2), and thats the value for the whole thing (+ 1 (* 2 (call/cc f)))
00:01:31 * Axman6 considers just makeing it all IO and unsafePerformIO'ing it
00:01:35 <ski> (augur : if you want, you could treat the above CPS-transform rules as an interpreter that (effectively) constructs such `(lambda (x) (+ 1 (* 2 x)))' things ..)
00:01:47 <Axman6> which is ok, because i should be pure
00:01:51 <augur> ski: i maybe will in a second :P
00:01:53 <kmc> Axman6, yeah... runST ≃ unsafePerformIO anyway
00:02:01 <Axman6> aye
00:02:03 <kmc> it's just you enforce the discipline that runST enforces
00:02:07 <kmc> but, i think there should be a workaround here
00:02:14 <Axman6> @hoogle unsafePerformIO
00:02:15 <lambdabot> Foreign unsafePerformIO :: IO a -> a
00:02:15 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
00:02:17 <dolio> The CPS transformation essentially turns programs into versions that accept their own 'call stack' as a parameter.
00:02:23 <dolio> In the form of a lambda expression.
00:02:27 * hackagebot contstuff 0.3.0 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.3.0 (ErtugrulSoeylemez)
00:02:30 <augur> ski: but is that roughly right? it then applies that proc-ish-thing to 2, and thats the whole thing
00:02:58 <augur> dolio: im sure it does, i just need to understand this operationally, not in terms of transforms, unless scheme is USING transforms.
00:03:17 <dolio> The compiler may.
00:03:19 <nejucomo> Is this syntax possible:  instance Foo a, Bar b => Quz (a, b) where ...
00:03:29 <kmc> (Foo a, Bar b) => ...
00:03:34 <nejucomo> Thanks.
00:03:35 <ski> augur : yeah, but it is important to realize that the argument given to the function argument of `call/cc' is an *escape* procedure : when it is applied to an argument, it will *discard* the current continuation, instead using the one which was saved by `call/cc'
00:04:07 <kmc> Axman6, haskell-cafe may have more insight into this problem
00:04:09 <augur> ski: sure, thats fine
00:04:14 <ski> augur : one can implement a Scheme compiler by using a CPS-transform, yes
00:04:21 <kmc> it's quite tricky and i think i see why it's an issue, but i'm not sure of the right workaround
00:04:38 <Axman6> i'm happy using IO for this, i already know its a pure algorithm (works fin without using unboxed arrays)
00:04:55 <kmc> you need a way to pass into heapsort evidence that there's an instance «MArray (STUArray s) e (ST s)» for *every* s
00:05:00 <kmc> aww i wanted to use crazy type theory
00:05:01 <ski> (augur : my point being that the `K' you talked about is not *just* the saved continuation/stack .. it also contains code that will discard the current stack, when called)
00:06:51 <ski> augur : it sounds right, as far as your explanation went, yes ..
00:06:54 <augur> ski: ok sure. so lets say K and K' where K is the pre-context and K' is the stuff after return, that gets thrown out
00:06:56 <ski> augur : .. however, do you understand how one can even invoke a continuation `K' *after* the `call/cc' call which generated it has returned -- thus jumping *back* into the dynamic extent of that call, possibly making the call return more than once ?
00:07:40 <augur> ski: probably not, since im half lost on that very question
00:08:02 <augur> ski: im going to take this to /msg
00:09:46 <ski> mhm
00:10:29 <Axman6> kmc: heh, ok, changed it all to IO, works fine :P
00:10:36 <kmc> noooooooo
00:10:39 <Axman6> i love ST, but god it's annoying sometimes
00:11:31 <nickela> hello! how look analog of following code:  [ x*2 | x<-[1..9], even]
00:11:50 <Axman6> > map (*2) [1..9]
00:11:51 <lambdabot>   [2,4,6,8,10,12,14,16,18]
00:12:06 <Axman6> > map (*2) . filter even $ [1..9]
00:12:06 <nickela> here even filter
00:12:07 <lambdabot>   [4,8,12,16]
00:12:44 <nickela> such conversion GHC performs itself?
00:13:03 <Axman6> sort of, why does it matter?
00:13:48 <nickela> just intresting, so list compherenstion is syntax sugar?
00:14:19 <Axman6> sure, they're sugar for >>= and when basically
00:14:29 <mm_freak> Axman6: guard, not when
00:14:32 * hackagebot contstuff 0.3.1 - Easy to use CPS-based monads  http://hackage.haskell.org/package/contstuff-0.3.1 (ErtugrulSoeylemez)
00:14:34 <Axman6> uh, yeah
00:16:11 <nickela> but why following doesnt work following: [1..5] >>= guard . even
00:16:18 <nickela> > [1..5] >>= guard . even
00:16:19 <lambdabot>   [(),()]
00:16:28 <nickela> I hope see here [2,4]
00:16:59 <nickela> and
00:16:59 <Pseudonym> :t guard
00:17:00 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
00:17:07 <Axman6> > [1..5] >>= \x -> guard (even x) >> return x
00:17:08 <lambdabot>   [2,4]
00:17:09 <Pseudonym> You see, guard returns m ()
00:17:15 <nickela> > [ x | x<-[1..5], even]
00:17:16 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
00:17:16 <lambdabot>         against inferred type ...
00:17:25 <Pseudonym> @pl \x -> guard (even x) >> return x
00:17:25 <lambdabot> ap ((>>) . guard . even) return
00:17:31 <kmc> Axman6, solved it
00:17:56 <nickela> Ohh, cool, thanks, now understand!
00:19:41 <kmc> Axman6, http://hpaste.org/40006/woah
00:20:27 <kmc> Axman6, thank you for posing this problem
00:20:51 <Axman6> heh, no worries
00:21:19 <kmc> hmm, now is foo actually callable
00:21:28 <kmc> slash is the type (Elem Word8) inhabited
00:22:19 <kmc> *Main> foo (Elem Evidence) ([1,2] :: [Int])
00:22:19 <kmc> []
00:22:21 <kmc> yay
00:22:50 <Axman6> now! you must already sort!
00:22:59 * Axman6 loves his algorithms lecturer
00:23:00 <mm_freak> does anybody know some code to test, whether a ListT is a proper monad transformer?
00:23:25 <mm_freak> i'm not sure about my ChoiceT
00:28:08 <dibblego> @type (<|>)
00:28:09 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f a -> f a
00:31:50 <ambidextrous> Hello people
00:32:49 <kmc> hello robots
00:33:11 <ambidextrous> New user here, I have just a simple question
00:33:33 <kmc> yay
00:33:39 <kmc> we have a simple answer, or maybe a complicated one
00:33:49 <ambidextrous> ok, I'll ask you :)
00:33:57 <kmc> :)
00:34:12 <ambidextrous> I want an executable file, which returns this: f1 x y = (2*x*y)/(x+y)
00:34:27 <ambidextrous> When I save this in a file f1.hs and compile it, it says parse error
00:34:56 <Botje> and that line is the only thing in the file?
00:34:59 <ambidextrous> yes
00:35:09 <Botje> no funny characters?
00:35:14 <Axman6> no main function?
00:35:16 <ambidextrous> I also tried adding module Main where at the top
00:35:17 <Botje> no unclosed ) or something?
00:35:22 <glguy_> is it supposed to print that equation?
00:35:24 <ambidextrous> no this is the only line
00:35:33 <ambidextrous> No it is supposed to take 2 numbers and return the result
00:35:42 <ambidextrous> am I to have a main function - what would be the syntax
00:35:43 <ambidextrous> ?
00:36:16 <Botje> ambidextrous: can you try ghci filename ?
00:36:25 <ambidextrous> Ok, let me try and get back to you
00:36:47 <ambidextrous> Yes, it worked just fine
00:36:51 <mm_freak> (haskell is really great, but i guess it can't read your mind yet)
00:37:09 <Axman6> main = do { (xs:ys:_) <- read `fmap` getArgs; print ((2*x*y)/(x+y))}
00:37:13 <ambidextrous> GHCi started, loaded the Main module, and when I said f1 3 4 it returned 3.4285
00:37:31 <ambidextrous> Ok Axman6, let me try that
00:37:55 <nickela> s/xs/x/g
00:38:01 <Axman6> uh, should be x:y:_
00:38:25 <dufflebunk> I'm working on a bot for the google ai challenge, and I'm getting a strange warning when it compiles on their server "Warning: 0000000757b12c00 shortened to 0000000057b12c00"
00:38:33 <dufflebunk> has anyone seen anything like that before?
00:38:41 <Axman6> o.O
00:38:47 <ambidextrous> Axman6, I did it with x and y, it says not in scope getArgs
00:38:50 <Axman6> we'd need more context than that
00:39:01 <Axman6> yeah, you need to import System.Environment
00:39:12 <ambidextrous> okay, hold on half a microsec
00:39:17 <Axman6> ambidextrous: you are jnow finding out why no haskell tutorial starts with teaching you IO
00:39:26 <geheimdienst> > 0000000757b12c00
00:39:27 <lambdabot>   Not in scope: `b12c00'
00:39:33 <ambidextrous> Kind of like Java eh?
00:39:42 <Axman6> > 0x0000000757b12c00
00:39:43 <lambdabot>   31536000000
00:39:44 <geheimdienst> > 0x0000000757b12c00
00:39:45 <lambdabot>   31536000000
00:40:00 <nickela> maybe Int64 downcasted to Int32 ?
00:40:01 <Axman6> no, not like Java at all :P
00:40:04 <geheimdienst> > 0x00000099999999990757b12c00
00:40:05 <lambdabot>   725355491768149333847040
00:40:13 <Axman6> > 0x0000000757b12c00 :: Int32
00:40:14 <lambdabot>   1471228928
00:40:22 <geheimdienst> > 0x0000000757b12c00 :: Int
00:40:22 <lambdabot>   31536000000
00:40:32 <geheimdienst> > 0x0000000757b12c00 :: Int16
00:40:32 <lambdabot>   11264
00:40:54 <ambidextrous> Axman6: now it says couldn't match expected type Char against inferred type [Char]
00:41:02 <ambidextrous> in the second argument of fmap
00:41:12 <kmc> ambidextrous, http://www.haskell.org/haskellwiki/Introduction_to_IO
00:41:20 <Axman6> ah, map read `fmap` getArgs
00:41:28 <Axman6> yeah
00:42:15 <ambidextrous> Ok, I'll read up on IO 
00:43:13 <Axman6> i'd staert by learning more haskell, using ghci personally
00:43:17 <Axman6> -e
00:43:27 <ambidextrous> I know - that's how all tutorials start too
00:43:29 <Axman6> IO is less important than you may have been led to believe
00:43:34 <mm_freak> main = map read <$> getArgs >>= print . ((/) <$> product . (2:) <*> sum)
00:43:43 <mm_freak> :t map read <$> getArgs >>= print . ((/) <$> product . (2:) <*> sum)
00:43:44 <lambdabot> Not in scope: `getArgs'
00:43:54 <mm_freak> :t map read <$> return [] >>= print . ((/) <$> product . (2:) <*> sum)
00:43:55 <lambdabot> IO ()
00:43:59 <ambidextrous> I just wondered if I could use it as a simple substitute calculator for typical functions that I use often
00:44:00 <dufflebunk> nickela: not sure... the biggest constant I have is 900000
00:44:55 <ambidextrous> So like, if I have a bunch of arguments to give to a function, have a line of Haskell code that does the computation
00:45:07 <mm_freak> ambidextrous: yes, you can…  ghci is fine for that
00:45:19 <ambidextrous> I guess the way to go is GHCi then - because making it executable with ghc is a bit more complicated than I imagined
00:45:45 <mm_freak> it's not complicated, but you need to know how to write haskell programs, if you want to compile
00:46:21 <nickela> dufflebunk: maybe this constant increased during computaions and result stored into #Int32 ?
00:46:34 <ambidextrous> Ok- well, thanks all for your help, I'll be hanging here very often now, that's for sure :)
00:46:49 <dufflebunk> nickela: the email with the message is for compilation
00:47:31 <dufflebunk> there's no computation I'm doing on the value, it's just a timeout
00:48:01 <mm_freak> > let f1 = (/) <$> product . (2:) <*> sum in f1 3 4
00:48:02 <lambdabot>   No instance for (GHC.Num.Num [t -> a])
00:48:02 <lambdabot>    arising from a use of `e_112134' ...
00:48:13 <dufflebunk> Maybe it's an old ghc and doesn't handle the concurrency stuff?
00:48:21 <mm_freak> > let f1 = (/) <$> product . (2:) <*> sum in f1 [3, 4]
00:48:22 <lambdabot>   3.4285714285714284
00:49:17 <zenzike> Has anybody been following the lastN discussion on the Haskell list? What makes the implementation by Henrique Becker so special? Is there anything particular about using Data.Number.Nat to do the length and drop of a list?
00:49:29 <nickela> dufflebunk: 0x757b12c00 is 31 536 000 000 in decimal, maybe in inlined code millicecond converted to microseconds?
00:49:58 <nickela> Data.Number.Nat is lazy numbers
00:50:34 <nickela> > Data.Number.Nat.lenght [1::Int ..] > 0
00:50:34 <lambdabot>   Not in scope: `Data.Number.Nat.lenght'
00:50:57 <nickela> is computable, because lazyness
00:52:17 <nickela>  > Data.Number.Nat.length[1::Int ..] > 0
00:52:36 <nickela> > Data.Number.Nat.length[1::Int ..] > 0
00:52:36 <lambdabot>   Not in scope: `Data.Number.Nat.length'
00:52:39 <zenzike> I don't quite see how that affects the lastN problem
00:52:41 * hackagebot QuickCheck 2.3.0.1 - Automatic testing of Haskell programs  http://hackage.haskell.org/package/QuickCheck-2.3.0.1 (NickSmallbone)
00:53:22 <dufflebunk> nickela: It's already 900000 microseconds. But there's no info on the architecture of the machines, so I'm not sure what the limits are.
00:54:42 <nickela> becase first argument N.drop ( N.length xs - n') 
00:55:03 <nickela> ( N.length xs - n')  is lazy number 
00:55:42 <Axman6> dufflebunk: i'd assume 32 bit
00:55:58 <dufflebunk> So would I
00:56:41 <nickela> zenzike: for example drop ask given argument:  "you at least have 1?"
00:57:06 <nickela> zenzike: N.length aswer - yes
00:57:35 <nickela> zenzike: and so on, so here doesn't required computation of full length of list
00:58:08 <zenzike> hmm
00:58:11 <xvinyl> dufflebunk:it's Ubuntu LTS 8 or something
00:58:17 <nickela> zenzike: look into Daata.Number.Nat definition
00:58:40 <xvinyl> dufflebunk: and someone mentioned an x64 architecture iirc
00:58:41 <dufflebunk> xvinyl: hmm, probably a pretty old ghc then :/
00:58:48 <zenzike> nickela: I have. I don't have a version of ghci to give things a test, but what would be wrong with using normal Ints?
00:58:54 <xvinyl> yep 6.8 :(
00:58:57 <zenzike> presumably the list in question is finite if we want to drop tings
01:00:30 <zenzike> nickela: oh I get it. it's so that the whoooole list doesn't have to be evaluated
01:00:32 <nickela> zenzike: normal Int is just a value, Data.Number.Nat is natutal value with behavior similar to ist
01:00:47 <nickela> zenzike: absolutely
01:03:27 <zenzike> nickela: hmm. but doesn't the whole list length need to be evaluated anyway if we need to know how many to drop? I'm still missing the point I think
01:04:19 <glguy_> to drop the last n just do:  droplast n xs = zipWith const xs (drop n xs)
01:05:55 <zenzike> glguy_: yup, I understand that version just fine. It's the one that involves lazy nats that confuses me: i'm not sure why it's interesting
01:07:33 <nickela> nickela: true, that N.lenth will consume all list, but they will do this in parallel with drop
01:08:55 <zenzike> nickela: oh, that makes more sense
01:09:20 <nickela> zenzike: and GC will free elements of list from head
01:10:51 <zenzike> nickela: wouldn't ghc free head elements using a normal drop?
01:10:59 <Axman6> wait, hiow does zipWith const xs (drop n xs) work? doesn't that return the length xs - n last elements?
01:11:31 <Axman6> > let f n xs = zipWith const xs (drop n xs) in f 3 [1..10]
01:11:32 <zenzike> Axman6: yeah, I think it does return the (length xs -n) last elements
01:11:32 <lambdabot>   [1,2,3,4,5,6,7]
01:11:55 <zenzike> Axman6: I assumed he meant (drop (length xs - n))
01:12:02 <nickela> zenzike: GC will free if no references to head found
01:12:18 <Axman6> but it still only rteturns the first n elements
01:12:35 <zenzike> nickela: so it's the same whether you use prelude.drop or Nat.drop
01:12:58 <objorn> I'm confused by objects and classes, what's the haskell alternative to this?
01:13:09 <Axman6> objects?
01:13:11 <objorn> no objects, just functions?
01:13:11 <Axman6> eh?
01:13:16 <nickela> zenzike: no, because Prelude.drop require Integral
01:13:18 <Axman6> functions and data
01:13:26 <Axman6> nickela: Integer
01:13:33 <nickela> yep
01:13:42 <Axman6> wait, no, Int
01:13:46 <Axman6> :t drop
01:13:47 <lambdabot> forall a. Int -> [a] -> [a]
01:13:50 <zenzike> nickela: sure, but then there are no references to the head of the list once the drop is perforemd, are there?
01:14:00 <ski> objorn : no direct alternative. it depends on what you're using them for
01:14:41 <ski> (typically, in OO languages, objects and classes are used for many distinct, or possibly distinct, things)
01:15:03 <deteego> or you have a subclass for objects that are distinct but share some common features
01:15:09 <nickela> zenzike: let me show, classic solution : lastn k xs = drop (length xs - k) xs
01:15:11 <Axman6> objorn: objects don't make a whole lot of sense if you can't mutate them
01:15:47 <nickela> zenzike: because haskell is lazy, drop will have referense to head of list, and length too
01:16:46 <nickela> zenzike: later, drop try get value of fist argument (Int), and lenght executed and genereted lot of thunks
01:16:56 <ski> Axman6 : i'm not so sure of that
01:17:10 <nickela>  zenzike: drop still hold rerefense to head of xs
01:17:14 <ski> (of course, it depends on what you mean by "objects" :)
01:17:31 <objorn> I'm confused just what is an object an what is a class. From what I gather, objects are declared within a class, but to instantiate a class, you call the object which then does that. Or something like that. And objects may or may not be everything but variables and functions within a class, its hard to tell.
01:17:35 <zenzike> nickela: ok, I follow so far
01:17:38 <Axman6> i tend to think of objects representing real world objects, which have state
01:17:40 <nickela>  zenzike: and we have full list constructed in memory
01:18:15 <ski> objorn : "Type Classes" in Haskell doesn't have that much to which what is called "Classes" in OO
01:18:53 <ski> objorn : a Type Class is roughly a collection of *types*. i.e. it is a concept that doesn't really "exist" at run-time
01:19:10 <nickela> zenzike: in Nat version of drop and lenth, execution body of N.drop  and N.lenght will performed by  parallel ( by request ),
01:19:37 <kmc> what's a good reference paper / wiki article / etc. about the idea that type classes can be implemented by passing dictionaries?
01:19:52 <ski> objorn : usually we don't talk about "Objects" in Haskell at all .. if we do, then it's often just as a synonym to "Value" (i.e. anything which has some specific type, like forty-two, or a specfic string, or a function, &c.)
01:20:00 <nickela> zenzike: and after each strep N.drop and N.length will step by the list, and leave reference from head from previos step
01:20:53 <nickela> zenzike: so, GC can free head of list on each step
01:21:42 <nickela> zenzike: very similar like: lastn' k xs = foldl' (const.tail) xs (drop k xs)
01:22:19 <nickela> zenzike: lastn' doesn't hold reference at top of xs,
01:22:49 <zenzike> nickela: so the reason the reference to head xs is dropped is becauase of the definition of N.drop, which drops as soon as we have a non-zero n
01:23:56 <nickela> zenzike: yes, but Prelude.drop acts similar way
01:24:21 <nickela> zenzike: all meaning in cooperation N.drop and N.length
01:26:21 <zenzike> nickela: I think I've got it now. It's because the drop can start dropping as soon as length has a partial result, which can't happen in the classic version.
01:27:28 <nickela> zenzike: exactly, and here avoided construction whole list in memory
01:27:48 <zenzike> nickela: thanks a lot! :-) that's really helped
01:28:36 <nickela> zenzike: are you welcome, but I don't meaure performance of this solution too ;-)
01:29:26 <zenzike> nickela: hehe, at least I understand why it's different to the classic version now :-)
01:49:57 * hackagebot flower 0.5 - Analyze 454 flowgrams (.SFF files)  http://hackage.haskell.org/package/flower-0.5 (KetilMalde)
02:06:22 <Jonno_FTW> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++.+++++++++++++++++++++++++.+++++++++++++++..+++++++++.>++++++++++++++++++++++++++++++++.<-----------------------------------------.++++++++++++++++++++++++++++++++++.---.--------.+++++++++++.-----------------.++++++++++++..--------.+++++++++++++.+.>>+++++++++++++++++++++++++++++++++++++++.<.<-----------------------------------------------.+++++++++++++++++++++++++++++.++++++++++++
02:06:23 <lambdabot>   Happy Programmers' Da
02:07:08 <Zao> Half the interweb will misread that as Progamer.
02:08:36 <zenzike> I thoguht programmers day fell on the 13th sept this year
02:08:56 <vanadium> looks like it.
02:09:09 <zenzike> lambdabot is a bit out of sync then
02:10:11 <vanadium> Jonno_FTW is, rather
02:47:18 <chrigi> Hi, I'm looking for a simple way to find out which part of my program uses too much memory. It terminates with "Main: out of memory (requested 1611661312 bytes)". Can anyone point my into the right direction?
02:50:17 <kmc> chrigi, are you using GHC?
02:50:27 <chrigi> yes
02:51:54 <blackh> chrigi: Really there's only one way, which is heap profiling.  It's something you have to learn to do sooner or later.  Once you get the hang of it, it's easy and convenient to use.
02:52:16 <blackh> chrigi: I can tell you exactly what to do if you like.
02:54:10 <chrigi> That would be great.
02:54:30 <deteego> http://en.wikipedia.org/wiki/Chef_(programming_language)
02:54:36 <deteego> that has got to be the coolest thing I have seen
02:55:10 <blackh> chrigi: Well, the first step is to install all your dependencies with the --enable-library-profiling option passed to cabal.  I have it always turned on in ~/.cabal/config and so I never have to think about it.
02:55:28 <ToRA> blackh: that's the second step
02:55:41 <ToRA> the first step is to run your unmodified program with +RTS -hT -RTS
02:55:47 <Adamant> deteego: that's an awesome esolang.
02:56:02 <blackh> ToRA: I have learnt something. What does -hT do?
02:56:15 <ToRA> just trying to find it in the ghc docs
02:56:30 <ToRA> it tells the runtime to do a simple memory profile dumping it to a .hp file
02:56:37 <ToRA> it's not as detailed as recompiling with profiling information
02:56:46 <ToRA> but can sometimes give you information without hte pain
02:56:47 <deteego> Adamant: I know isn't it epic
02:57:05 <Adamant> deteego: in the parlance of you whippersnappers, yes.
02:57:18 <Adamant> :P
02:57:19 <deteego> Imagine listening to an argument over that language
02:57:32 <deteego> IM TELLING YOU, THE CUCUMBER IS IN THE WRONG PLACE
02:57:37 <kmc> chrigi, building with ghc --make -O2 ?
02:57:40 <chrigi> i already compiled my program with profiling enabled. had to find some performance bottlenecks 
02:57:49 <ToRA> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/runtime-control.html#rts-profiling
02:57:56 <ToRA> chrigi: ah well in that case ignore me ;)
02:58:04 <blackh> chrigi: What ToRA said.  When you come to re-install your dependencies, it may seem like pain to get all those libraries reinstalled, but if you make it happen by default, then it won't be pain in future.
02:58:07 <kmc> «+RTS -s» is also useful for quick info
02:58:08 <chrigi> nope ghc -prof -auto-all --make Main.hs
02:58:20 <kmc> chrigi, does it still consume lots of space with -O2?
02:58:27 <kmc> (turn off prof temporarily)
02:58:35 <kmc> the answer is probably yes unfortunately
02:58:56 <kmc> chrigi, http://haskell.org/ghc/docs/6.12.2/html/users_guide/prof-heap.html is the GHC manual chapter to read
02:59:23 <blackh> chrigi: OK - that's good.  So now you just have to run it like this: ./Main +RTS -hc
02:59:32 <kmc> http://book.realworldhaskell.org/read/profiling-and-optimization.html has good info too
02:59:33 <chrigi> kmc: i'll try. will probably take some time. the program runs fine for a long time (usually ~20 minutes) before it crashes
02:59:48 <blackh> Then type the command hp2ps -c Main.hp
02:59:49 <kmc> note that hp2ps supports color with -c; it's basically unusable without
02:59:56 <lantti> deteego: HAve you ever tried programming in Shakespeare?
02:59:57 <blackh> Then view the resulting postscript file.
03:00:13 <deteego> lantti: no I can't say I have
03:00:28 <ToRA> chrigi: you can gently kill it earlier and still get the information out; if something is leaking and growing it'll probably be evident way before 20 minutes
03:02:25 <deteego> lantti: zomg thats even more epic
03:02:44 <lantti> Thought you would like it :)
03:03:59 <deteego> Im gonna hand in one of my assignments in Shakespear
03:06:01 <chrigi> I have a ps file of the heap dump of the last run. It shows one huge (around 90%) bar and a few smaller ones which slowly increase.
03:06:57 <chrigi> is there some documentation on how to interpret this graph?
03:08:34 <ToRA> chrigi: does the ps file have another page?
03:08:40 <ToRA> usually there's an index / key
03:08:52 <chrigi> no, only 1 page
03:09:10 <blackh> chrigi: The GHC manual.  Well, the text on the right associated with that colour is effectively a "stack trace" of the cost centre where the allocation happened.
03:09:38 <blackh> It may be truncated, in which case you might want to re-run it with +RTS -hc -L64 or something similar.
03:11:19 <chrigi> blackh: yes all the labels are truncated. will run with -L64 and see whether i can figure out what to do next by my self :)
03:11:25 * hackagebot jspath 0.1 - Extract substructures from JSON by following a path.  http://hackage.haskell.org/package/jspath-0.1 (KeeganMcAllister)
03:11:25 <chrigi> thanks for your help!
03:12:00 * zygoloid really should get hades to a usable state :o
03:14:51 <kmc> hades?
03:15:25 <kmc> zygoloid, what's hades?
03:17:06 <nominolo> preflex: seen tibbe
03:17:06 <preflex>  tibbe was last seen on #haskell 14 hours, 32 minutes and 21 seconds ago, saying: nominolo: there?
03:19:17 <zygoloid> kmc: it's a gdb-style out-of-process debugger for gdb-compiled binaries
03:19:53 <zygoloid> *ghc-compiled
03:31:04 <geheimdienst> > lines "lol\r\ncats"
03:31:05 <lambdabot>   ["lol\r","cats"]
03:31:36 <geheimdienst> *sigh*
03:31:56 <nickela> @pl \x y -> 2*x*y / (x+y)
03:31:56 <lambdabot> ap (ap . ((/) .) . (*) . (2 *)) (+)
03:32:20 <geheimdienst> so i guess i'll throw away any \r at the end of a string
03:32:45 * hackagebot crc16-table 0.1 - Compute CRC16 checksums using a lookup table.  http://hackage.haskell.org/package/crc16-table-0.1 (KeeganMcAllister)
03:32:58 <zygoloid> geheimdienst: any string other than the first? ;)
03:33:00 <quicksilver> geheimdienst: they will be translated on input if your handles are in text-mode
03:33:19 <quicksilver> (well, OS line endings will be translated to \n on input, that is)
03:33:32 <kmc> zygoloid, nice, will it have superpowers for finding space leaks?
03:33:41 <zygoloid> kmc: that's the plan, yeah :)
03:34:21 <geheimdienst> hm ... i just use interact and have not set stdin to anything
03:34:25 <zygoloid> (specifically, the plan is to look through the heap for the most common type of closure, find an exemplar, then find a path of retainers for it)
03:34:34 <geheimdienst> i guess that means it's binary by default
03:34:38 <geheimdienst> thanks for the hint
03:34:57 <zygoloid> geheimdienst: are you on windows?
03:35:12 <geheimdienst> zygoloid, do i look like a pussy?
03:35:32 <geheimdienst> but some .cabal files i wanted to process have crlf line endings
03:36:33 <zygoloid> geheimdienst: i think you want GHC.IO.Handle.hSetNewlineMode
03:37:52 <kmc> was there a listing somewhere of the module hierarchy across all of hackage?
03:38:00 <kmc> i want to pick appropriate hierarchical names for my packages
03:38:04 <kmc> err my modules
03:38:29 <geheimdienst> easy. start your module name with a UUID
03:38:30 <geheimdienst> ;-)
03:38:40 <zygoloid> kmc: there's this: http://www.haskell.org/haskellwiki/Hierarchical_module_names
03:40:23 <geheimdienst> kmc, i guess i'd extract .cabal/packages/hackage.haskell.org/00-index.tar and grep through all the .cabal files
03:47:41 <sepp2k> > unfoldr (\x -> if x==0 then Nothing else Just (chr(x `mod` 256), x `div` 256)) (foldr (\x acc -> acc*256+fromIntegral (ord x)) 0 "qwertzuiop")
03:47:42 <lambdabot>   "qwertzui"
03:47:58 <sepp2k> Why does it eat the "op"?
03:48:33 <zygoloid> sepp2k: Int overflow
03:49:22 <zygoloid> on a 32-bit machine, you'd just get "qwer" :)
03:49:48 <sepp2k> zygoloid: But where? The foldr seems to return the correct number.
03:50:07 <sepp2k> And I don't see where I force the type to be Int
03:50:14 <zygoloid> @type chr
03:50:14 <lambdabot> Int -> Char
03:50:18 <zygoloid> ^^ that's where
03:50:27 <zygoloid> the foldr returns the right number because it defaults to Integer
03:50:28 <sepp2k> Ah, thanks.
04:11:15 <Cale> http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html is a fun exercise in type hackery. I find it interesting that it seems to be necessary to express the universal quantification on the type s with a separate datatype.
04:12:58 <blackh> It's a bit unexpected. I'd love to know if there's a neater way to solve it.
04:14:54 <Cale> You can construct a type which seems like it ought to be isomorphic to ElemType e by just deleting the s type parameter from the Evidence type, but then you can't refer to that s anymore. :)
04:17:06 <Cale> I like sortP_3. GHC should totally support that syntax :)
04:17:40 <Cale> (I wonder how much work that would be)
04:17:59 <kmc> Cale, yeah.  ElemType *could* be a synonym for the quantified type itself (with LiberalTypeSynonyms), but i think that's misleading to the user -- synonyms aren't first-class, hiding a quantifier in one is a dirty trick
04:18:23 <kmc> things like [ElemType] and Maybe ElemType would become impredicative
04:18:57 <kmc> and i totally agree about allowing the forall syntax from sortP_3
04:19:01 <Cale> kmc: I was really just looking for a way to fuse the ElemType and Evidence types together into a single piece of evidence.
04:19:32 <Cale> Though I suppose the type synonym sort of does that...
04:19:33 <kmc> let's get that in GHC8, and also the *> syntax (with UnicodeSyntax ×>), and first-class existentials, and local instances, and…
04:19:40 <Cale> hehe
04:19:55 <Cale> local instances is a hard call
04:20:04 <kmc> yeah
04:20:25 <kmc> i've heard varying opinions, all the way from pure scala envy to "scala's implicits ruin the point of type classes and make them unusable"
04:20:38 <kmc> GHC already has scoped implicit parameters, they don't seem to be much used
04:20:44 <kmc> but maybe awareness is low
04:21:00 <kmc> i realize not everyone reads the ghc manual section 7 for fun
04:21:09 <Cale> :)
04:21:20 <zygoloid> kmc: they don't?
04:22:36 <deteego> zygoloid: its my bed time reading book
04:22:43 <deteego> zygoloid: can't go to sleep without it
04:22:55 <kmc> what's the least popular extension, i wonder
04:23:14 <zygoloid> that SQL list comprehension thing?
04:23:20 <kmc> i suppose few packages use GHCForeignImportPrim
04:23:36 <kmc> ImpredicativeTypes is on the way out
04:23:41 <Adamant> you know, relational algebra is surprisingly fun.
04:24:13 <kmc> Adamant, yes, i was surprised the first time i cracked open a DB theory book and found out that under all this awful SQL is something kind of cool and elegant
04:24:47 <kmc> ExtendedDefaultRules because what we need is more defaulting!
04:25:19 <kmc> IncoherentInstances has a "really don't use this" name
04:25:27 <kmc> whereas MagicHash is so hard to pass up
04:25:47 <Cale> ExtendedDefaultRules is mostly there so that other tools can behave the same way as GHCi with respect to types.
04:26:22 <Cale> It's somewhat unfortunate that we now have both DoRec and RecursiveDo
04:26:24 <Adamant> kmc: we need to get Alan Kay and E.F. Codd together to write jeremiads against the more misguided of their followers.
04:26:59 <Adamant> "I invented the term object-oriented programming, and I'm pretty sure C++ was not what I meant"
04:27:01 <Cale> (But what are you going to do, this is the right way to help people switch from one syntax to the other. The naming is a bit unfortunate though.)
04:27:45 <deteego> well if you are moving over from C++ to haskell, Syntax switching is probably the wrong approach
04:27:54 <deteego> (since Haskell's syntax is so generic)
04:27:59 <Cale> kmc: I like the newish idea that databases are really representations of categories.
04:28:14 <Adamant> Cale: but what isn't a category :P
04:28:29 <Cale> Adamant: Well, the relationship is rather direct in this case.
04:28:37 <Adamant> Cale: that does sound like a cool idea, though.
04:29:20 <fxr> hmm github down
04:30:14 <Cale> Each table (and each primitive datatype) becomes an object. Columns become a generator for the arrows (and composition of arrows gives you joins)
04:31:26 <atude> Cale: if you had 50 tables of data, each having several thousand rows of informations, each row containing strings of data; given that you're querying for a reference of a word and searching through each table, what would be the shortest path/quickest method to find every reference to each word in each string (the word you've queried)?
04:33:31 <Cale> atude: hmm... it's possible to build an efficient trie-like device for matching any of a dictionary of strings
04:34:13 <Cale> err... I'm not sure I understand the question fully. Is there just one word you're searching for in many strings?
04:34:29 <Cale> Or many words and many strings?
04:34:43 <Cale> (Or many words and one string)
04:34:53 <atude> one word in many many many strings
04:35:52 <atude> trie-like, what is this exactly?
04:36:09 <Cale> Well, on the face of it, there's not a whole lot you can do beyond the naive thing. You can use a good string-searching algorithm like KMP, but if the individual strings are short, that probably won't help so much.
04:36:23 <Cale> However, you may want to build an index.
04:37:30 <Cale> For example, even at one level deep, it might be useful to know exactly which strings contained each letter of the alphabet.
04:38:15 <Cale> (If you're doing many queries)
04:39:06 <Cale> With chains of a few letters, you'll get much more specific information, at the cost of storing a larger index.
04:39:10 <atude> Cale: I thought building an index would be a lot more efficient, but when scraping random strings, that would be a little troublesome considering, everything is being added at a particular frequency. Having said that, a structure for indexing everything upon adding to a db would be ideal but would take longer
04:41:54 <Cale> For example if you have an index of all 3-letter combinations which occur in the database, when the user writes a query like "apple", you can immediately look in the index and refine the set of things you're searching through to the intersection of those containing the string "app", those containing "ppl" and those containing "ple", which gives a rather high likelihood that they actually contain the word "apple".
04:42:41 <Cale> But the index can be pretty large at that size.
04:44:07 <Cale> (you can help things by making everything lowercase and removing punctuation)
04:44:39 <Cale> 26^3 is 17576
04:45:11 <atude> I'm not so worried about size as to speed, though, how exactly could I quanitfy ambigious symbols? if I have an index of words and their pointers to their origin, should I match just the string or should I parse the word for each letter?
04:46:28 <atude> it seems that querying alone would be rather abstract if there's no particular tense to match anything except for the word itself, which I would have to continuously call on and check against
04:46:46 <Cale> Well, once you've used the index to determine which strings the various 3-letter combinations from your search term occur in, you can just do a simple check to verify that the search term actually occurs in those, because there are hopefully not very many things to check anymore.
04:48:18 <atude> I see...
04:48:39 <Cale> Another option is to index based on complete keywords only, but this means that searching for "appl" might not match documents containing "apple"
04:49:07 <atude> that's too messy, a little like politics, governance, and the people of a nation
04:49:44 <atude> I want to avoid that, but... indexing is nearly the same thing and practically doubles the size
04:50:07 <atude> I think the first method is more practical
04:50:35 <Cale> There are always lots of tradeoffs to be made between space and time.
04:50:56 <atude> very true, must find the most efficient one :p
04:50:58 <atude> Cale: Thank you very much! :)
04:52:00 <Cale> no problem
04:52:16 <zygoloid> Cale: http://hpaste.org/40008/higherrank_type_constraints_a
04:52:51 <zygoloid> really doesn't solve the problem though, since the instance still requires something like a (forall a. Foo a) => constraint.
04:54:18 <Cale> zygoloid: Oh, that's a clever approach. Setting id to be a default method for that class would make it a little cleaner still.
04:54:44 <zygoloid> yeah, good idea
04:54:58 <Cale> But the restriction in the way that the evidence is used is a bit unfortunate.
04:55:23 <zygoloid> i couldn't see an easy way around that. the compiler needs to be able to match up the 'a's
04:55:54 <zygoloid> a phantom type could probably take care of that i think
04:57:38 <Cale> @tell ChrisDone Proposal: Set the default language on hpaste to Haskell.
04:57:38 <lambdabot> Consider it noted.
05:12:53 <watermind> does anybody know where to find infortmation about the haskell mode for kate?
05:14:02 <ManateeLazyCat> watermind: http://hackage.haskell.org/package/highlighting-kate ?
05:14:51 <watermind> ManateeLazyCat: thanks but that is the highlighting... kate has both, highlighting and mode
05:14:59 <watermind> I'd like to know about the latter
05:22:15 <aristid> hackagebot: speak!
05:22:17 * hackagebot random-extras 0.16 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.16 (AristidBreitkreuz)
05:26:39 <zachk> whats wrong with this code http://hpaste.org/40009/filling_a_table :(  
05:28:14 <aristid> zachk: it doesn't make sense, that is wrong. what is it supposed to do?
05:28:55 <zachk> fill the table with all the different values of c 
05:29:03 <aristid> which table?
05:29:15 <writer> where is args ?
05:29:25 <zachk> a list (t:ts) turning it into (t,c):ts' 
05:29:30 <aristid> zachk: first, write the type for fillTable that you want.
05:29:34 <zachk> args is just a list 
05:29:36 <zachk> k
05:29:59 <aristid> fillTable :: [a] -> [(a, Int)]?
05:30:37 <aristid> :t map (head *** length) . group . sort
05:30:38 <lambdabot>     Couldn't match expected type `([a], [a1])'
05:30:38 <lambdabot>            against inferred type `[a2]'
05:30:38 <lambdabot>       Expected type: [([a], [a1])]
05:30:50 <aristid> :t (***)
05:30:51 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
05:31:00 <aristid> :t (&&&)
05:31:01 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
05:31:07 <aristid> :t map (head &&& length) . group . sort
05:31:08 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
05:31:20 <aristid> but i suppose that is too abstract for you :D
05:31:42 <aristid> or wait
05:32:08 <aristid> zachk: i still don't understand what the code is supposed to do :)
05:32:56 <zachk> fillTable :: Int -> [(a,a)] -> [[((a,a),a)]]
05:34:03 <zachk> ive done this before. but i forgot how i did it :( 
05:36:22 <aristid> zachk: what does fillTable 2 [('a','m'),('b','n'),('c','o'),('d','p'),('e','q')] return?
05:36:29 <aristid> or what SHOULD it return?
05:40:06 <zachk> it would return a list of tables with a key val pair of (('a','m),'0' or 'a')
05:40:14 <zachk> http://hpaste.org/paste/40009/it_works_now#p40010 it works now
05:40:49 <zachk> ive just always rapped parenthese around return x, like this return (x) 
05:40:59 <zachk> and in this case thats not what i actually need 
05:41:22 <zachk> never knew i could operate on return piecemeal 
05:44:45 <atude> Cale: I'm running ubuntu and I noticed that I have so many extra processes that should not be running because I don't care for them to run...... I also noticed Mathematica runs incredibly slow or the kernel at least slows everything down; any idea?
05:45:02 <ddarius> I'm with aristid.  That code makes no sense.
05:45:59 <Cale> atude: Things run fast here, but I have a new Core i5 machine.
05:46:21 <pumpkin> ooh
05:46:32 <atude> Cale: I see... even mathematica?
05:46:35 <Cale> yes
05:46:46 <atude> Cale: no bump in cpu usage upon starting it?
05:46:56 <Cale> Of course, it's easy to write computations in Mathematica which are hard to perform on any machine.
05:47:12 <atude> well, I mean just starting it
05:47:13 <luite> is there a name for sets with cardinality 2?
05:47:15 * ddarius is using Ubuntu on an oldish laptop and it runs fine for the most part, though he has removed most of the default installed stuff.
05:47:19 <pumpkin> luite: 2
05:47:21 <ddarius> luite: duplets
05:47:47 <luite> hmm, duplet sounds ok, thanks
05:48:42 <atude> find all the integers such that 0 <= w <= x <= y < z < 10^6
05:49:15 <Cale> atude: Well, hmm...
05:49:40 <hpc> > [1..(10 ** 6)]
05:49:40 <lambdabot>   [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0,11.0,12.0,13.0,14.0,15.0,16.0,17....
05:49:47 <Cale> atude: My process manager does appear to indicate that its CPU usage is around 12% somehow, even though it's "Sleeping"
05:49:49 <hpc> do i win a prize?
05:50:02 <hpc> oh, and zero
05:50:07 <kmc> @hoogle IO a -> IO (IO a)
05:50:07 <lambdabot> Network withSocketsDo :: IO a -> IO a
05:50:07 <Cale> atude: That's certainly weird.
05:50:08 <lambdabot> Control.Exception block :: IO a -> IO a
05:50:08 <lambdabot> Control.OldException block :: IO a -> IO a
05:50:24 <atude> Cale: mathematica 7?
05:50:42 <hpc> kmc: the only action i can conceive of that would have that type is JIT compilation
05:50:44 <atude> it seems to run nicely in Windows
05:50:49 <atude> hpc: no
05:51:04 <Cale> atude: yeah
05:51:08 <atude> hpc: "proove"
05:51:18 <atude> Cale: :(
05:51:22 <hpc> atude: eh?
05:51:32 <hpc> oh no, i see; nvm
05:51:35 <Axman6> > [(w,x,y,z) | z <- [1..10^6], y <- [1..succ z], x <- [1..y], w <- [1..x]]
05:51:36 <lambdabot>   [(1,1,1,1),(1,1,2,1),(1,2,2,1),(2,2,2,1),(1,1,1,2),(1,1,2,2),(1,2,2,2),(2,2...
05:51:55 <aristid> :t succ
05:51:56 <lambdabot> forall a. (Enum a) => a -> a
05:52:24 <ddarius> luite: Actually "doubleton" I think is what I wanted.
05:52:34 <atude> Cale: so maybe it's just a linux specific issue
05:53:16 <nickela>  [(w,x,y,z) | z <- [1..10^6], y <- [0..succ z], x <- [0..y], w <- [0..x] ]
05:53:44 <pumpkin> ooh kmc has a blog
05:54:07 <nickela> [(w,x,y,z) | z <- [1..(10^6 - 1)], y <- [0..succ z], x <- [0..y], w <- [0..x] ]
05:54:33 <atude> prove that when n is an integer, n > 4, the equation w^n + x^n + y^n = z^n has no solution in positive integers w, x, y, z.
05:54:38 <aristid> pumpkin: let me guess: monad reader? comonad reader? monad writer? monoid reader? monoid writer?
05:54:46 <pumpkin> none of those :)
05:54:48 <atude> pumpkin: links?
05:55:01 <pumpkin> someone posted it to reddit
05:55:02 <pumpkin> http://mainisusuallyafunction.blogspot.com/
05:55:06 <pumpkin> at least, I'm assuming it's kmc
05:56:17 <nickela> > null  [(w,x,y,z) | z <- [1..10^6], y <- [0..succ z], x <- [0..y], w <- [0..x], n<-[5..10], w^n + x^n + y^n = z^n]
05:56:18 <lambdabot>   <no location info>: parse error on input `='
05:56:24 <nickela> > null  [(w,x,y,z) | z <- [1..10^6], y <- [0..succ z], x <- [0..y], w <- [0..x], n<-[5..10], w^n + x^n + y^n == z^n]
05:56:24 <lambdabot>   False
05:56:51 <nickela> > head [(w,x,y,z) | z <- [1..10^6], y <- [0..succ z], x <- [0..y], w <- [0..x], n<-[5..10], w^n + x^n + y^n == z^n]
05:56:52 <lambdabot>   (0,0,1,1)
05:57:03 <nickela> > take 10 [(w,x,y,z) | z <- [1..10^6], y <- [0..succ z], x <- [0..y], w <- [0..x], n<-[5..10], w^n + x^n + y^n == z^n]
05:57:04 <lambdabot>   [(0,0,1,1),(0,0,1,1),(0,0,1,1),(0,0,1,1),(0,0,1,1),(0,0,1,1),(0,0,2,2),(0,0...
05:57:24 <Cale> atude: http://ubuntuforums.org/showthread.php?t=1488970
05:57:30 <Axman6> > [(w,x,y,z) | z <- [1..10^6], y <- [1..succ z], x <- [1..y], w <- [1..x], n <- [5..10], w^n + x^n + z^n == z^n]
05:57:34 <lambdabot>   mueval-core: Time limit exceeded
05:57:36 <luite> ddarius: ah I also asked in another channel and I now have two votes for doubleton :)
05:58:20 <aristid> kmc: if this is from you... http://mainisusuallyafunction.blogspot.com/2010/09/higher-rank-type-constraints.html
05:58:23 <Cale> atude: Now that you mention it, I remember solving this problem before, quite a long time ago.
05:58:28 <mm_freak> i have no real proof, but i've tested my ChoiceT empirically…  it seems to be a proper monad transformer
05:58:32 <aristid> kmc: why didn't you just use -XScopedTypeVariables?
05:58:42 <Cale> (The solution described there is essentially the same as the one I came up with)
05:59:18 <pumpkin> aristid: I don't think that works?
05:59:23 <aristid> mm_freak: doesn't MonadLib also have that? you could compare the behavior
05:59:32 <aristid> pumpkin: maybe i misunderstand his problem there
05:59:42 <mm_freak> aristid: mine works completely different
05:59:51 <pumpkin> aristid: the issue is that you have no way of introducing the right typeclass dictionary
06:00:00 <aristid> pumpkin: oh right, i see the problem now
06:00:03 <pumpkin> Evidence is explicitly carrying that for you
06:00:07 <aristid> the s type is nowhere to be find
06:00:13 <mm_freak> while monadLib's ChoiceT is basically a tree of choices, mine is a CPS-based left-fold function
06:00:24 <pumpkin> mm_freak: maybe you should change nick to cps_freak
06:00:46 <pumpkin> even when I was first getting started with haskell, I remember you posting your CPS C to ##crypto :P
06:00:51 <mm_freak> pumpkin: well, the library i'm writing focusses on CPS, so naturally i'm talking about it a lot =)
06:00:57 <atude> Cale: excellent, thank you very much! :D
06:01:10 <mm_freak> pumpkin: yes, but it's not real C =)
06:01:12 <pumpkin> :P
06:01:21 <mm_freak> and i wasn't that much of a CPS freak back then
06:01:29 <aristid> pumpkin: how about creating a type class with a fundep / tf that generates the s?
06:01:40 <aristid> mm_freak: well, nicks can be changed!
06:01:44 <mm_freak> but i fell in love with CPS when i saw what you can do with it
06:02:03 <nickela> atude: is like Ferma theorem, no solution
06:02:49 <mm_freak> anyway…  i'll clean up the code a little, extend the tutorial and then upload the first stable release of contstuff
06:03:22 <Philonous> Why does ghc claim that "The data constructors of `[]' are not all in scope" when I try to derive Data instances for [a] ? Does [] have more constructors than [] and (:) ? 
06:05:05 <kmc> aristid, it is from me, i do use ScopedTypeVariables, do you have a solution using only that, did you actually read the article?
06:06:03 <kmc> how would you use fundep / tf?
06:06:13 <yrlnry> I just typed "return 13" at the ghci prompt by mistake, and instead of telling me it didn't know which overloading to use, it just printed 13.  «:t it» says it had type "Integer".  Why did that happen?
06:06:24 <aristid> kmc: i did read the article, but i am confused by it
06:06:27 <kmc> defaulting
06:06:33 <kmc> extended defaulting rules in GHCi yrlnry
06:06:47 <yrlnry> kmc:  Interesting, thanks.   I'll try to find them in the docs.
06:06:58 <kmc> the problem is that someone else has made a class of the form (C x y), and we want to pass around evidence, for some particular x, that there exists an instance (C x y) for *every* y
06:07:02 <aristid> :t runST
06:07:03 <lambdabot> forall a. (forall s. ST s a) -> a
06:07:07 <kmc> (forall y. C x y) => ...
06:07:09 <kmc> except not
06:07:17 <ddarius> yrlnry: The discussion about them is in the GHCi User Guide section.
06:07:27 <kmc> aristid, at what point did you get confused?
06:07:27 <aristid> kmc: the forall s. in runST is the problem?
06:07:35 <kmc> yes essentially
06:07:48 <yrlnry> Seems to be section 2.45 here: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/interactive-evaluation.html
06:08:09 <kmc> when you call (runST m), runST gets to pick any type S it likes, and run m as if it had type «ST S a»
06:08:23 <kmc> (operationally this is not at all what happens, but it's a way to think about the theory)
06:08:28 <aristid> kmc: at the point when you created the data Evidence, i completely lost the train of thought :)
06:08:32 <kmc> ok
06:08:42 * hackagebot GoogleTranslate 0.0.4 - Interface to Google Translate API  http://hackage.haskell.org/package/GoogleTranslate-0.0.4 (AndyStewart)
06:08:55 <zachk> well that last post i made , type checked, but algorithimically dead wrong, this is correct now , im pretty sure ;) http://hpaste.org/paste/40009/zachk#p40012
06:08:59 <kmc> did you follow the paragraph immediately before it? 
06:09:24 <aristid> kmc: well, not sure
06:09:31 <aristid> but i think i understand it slightly better now
06:09:34 <kmc> cool :)
06:09:47 <kmc> i'm new to this blogging thing, so i'm interested in knowing how i can explain things more clearly
06:12:06 <aristid> kmc: maybe more descriptive names for the iterations of the sorting functions?
06:12:13 <kmc> ok
06:12:23 <kmc> what would you call them?
06:12:56 <aristid> maybe sortP_5 could be called sortWithMatchingEvidence or so
06:13:01 <kmc> mm
06:13:05 <zachk> somethingReallyFriggingBigandMeaningful then do srfbm = SomethingReallyBigandMeaningful 
06:13:22 <atude> Cale: So much better now...
06:13:56 <aristid> kmc: it's not like the long names would bother in an illustrative blog posts. nobody has to actually use any but the finalised version of the function
06:17:47 <yrlnry> I wrote "instance ListLike f => Monad f where ..." and ghci said "Illegal instance declaration for `Monad f'..." and a long explanation.   But as far as I can tell all the conditions in the explanation are satisfied.  What's the real problem here?
06:18:49 <yrlnry> It says "All instance types must be of the form (T a1 ... an) where a1 ... an are type *variables* ..." .  Here I understand "T" to be "Monad" and "a1..." to be "f", and f is a type variable, so what's the problem?
06:19:33 <quicksilver> yrlnry: no, it's just talking about the 'f'.
06:19:43 <Zao> yrlnry: Maybe it requires particular kinds?
06:19:48 <yrlnry> Oh, I understand now.
06:19:55 <quicksilver> yrlnry: 'f' should be, for example "Maybe x"
06:19:58 <yrlnry> It has "T" = "f' here, which is a no no.
06:20:00 <yrlnry> Yeah.
06:20:02 <quicksilver> T = Maybe, x = a type variable.
06:20:14 <quicksilver> however you can turn this restriction off, using FlexibleInstances.
06:20:20 <quicksilver> Which is a widely accepted extension.
06:20:23 <yrlnry> Okay, thanks.
06:20:35 <quicksilver> However be aware that you instance provides a monad instance for all types 'f'.
06:20:44 <quicksilver> therefore it overlaps with any other possible instance
06:20:57 <quicksilver> to do *that* requires OverlappingInstances, which is know to be an immoral extension.
06:21:24 <yrlnry> Because it's not smart enough to always understand that it's only when f is already an instance of ListLike?
06:21:53 <quicksilver> it's not a question of smart, or not smart.
06:21:59 <quicksilver> it's a question of how the feature is designed to work.
06:22:14 <quicksilver> contexts are not part of the instance selection process.
06:22:20 <aristid> yrlnry: the safest method would be to wrap a newtype around your ListLike
06:22:24 <ddarius> Due to the open world assumption
06:22:32 <yrlnry> ListLike is not a type.  It is a class.
06:22:38 <aristid> i know.
06:22:41 <yrlnry> What's the "open world assumption"?
06:22:45 * hackagebot spawn 0.1 - Tiny library for joinable computations / threads with results.  http://hackage.haskell.org/package/spawn-0.1 (KeeganMcAllister)
06:23:05 <aristid> sometimes i get the feeling that newtypes might not be the best solution to dealing with the problems of haskell type classes
06:23:27 <ddarius> kmc: Isn't there something like that already on Hackage?
06:23:44 <kmc> ddarius, my wheel is rounder
06:23:49 <aristid> yrlnry: open world assumption = somebody could always come along and add a new instance in another module
06:24:04 <aristid> yrlnry: it allows separating the compiler and linker phases, i think
06:24:11 <yrlnry> Oh, okay.  
06:24:18 <yrlnry> Also reading http://book.realworldhaskell.org/read/using-typeclasses.html now
06:24:26 <kmc> ddarius, it's a lot simpler than the others
06:24:37 <kmc> easier to use, fewer dependencies etc
06:24:49 <yrlnry> Yes, that makes sense.
06:25:01 <kmc> but yeah there's already 3 or 4 similar packages
06:25:15 <kmc> then again we have like 50 json parsers, i discovered today
06:25:18 <aristid> kmc: i wish hackage would generate the docs more often :D
06:25:24 <kmc> yeah
06:25:59 <yrlnry> It has to assume that there might be some module somewhere which will allow it to infer Monad f, via ListLike f => Monad f, even if it doesn't know of any such module just now.
06:27:05 <aristid> yrlnry: well or something else: let's say somebody has a type K, with an instance for ListLike and an instance for Monad. that instance for Monad would compete with yours
06:27:21 <aristid> yrlnry: incidentally, i think [] meets that property
06:27:22 <ddarius> E.g. [] ...
06:28:32 <chrisdone> Baughn: they got back to you yet?
06:28:32 <lambdabot> chrisdone: You have 1 new message. '/msg lambdabot @messages' to read it.
06:28:36 <chrisdone> @messages
06:28:36 <lambdabot> Cale said 1h 30m 59s ago: Proposal: Set the default language on hpaste to Haskell.
06:28:50 <aristid> haha http://www.cis.upenn.edu/~byorgey/haskell-alphabet/U.html
06:28:50 <chrisdone> sounds fair
06:29:12 <ddarius> Anyway, I was suggesting, that the reason the context is ignored in instance resolution is that it is not informational since the open world assumption essentially means all type constructors could satisfy the context.
06:29:13 <yrlnry> Oh, right.  Is there a way to annotate a particular overlapping instance with a promise to the compiler that the two derivations are in fact extensionally equal?
06:29:23 <aristid> chrisdone: why does it ask for the channel? there's no paste announcer planned, is it?
06:29:37 <ddarius> yrlnry: No, because that would be evil.
06:29:40 <aristid> yrlnry: well, the proper way is to use a newtype, but i digress
06:29:41 <yrlnry> Why?
06:29:47 <Baughn> chrisdone: About what?
06:30:03 <Baughn> chrisdone: haskell.org? The foundation is taking care of that now, right?
06:30:23 <yrlnry> What's evil about that? It seems very similar to the way an instance Monad declaration implies that your definition will obey the monad laws, even though the compiler can't know if you are telling the truth.
06:31:06 <Cale> I like http://www.cis.upenn.edu/~byorgey/haskell-alphabet/M.html
06:31:16 <quicksilver> ddarius: I don't know if that's historically true, or merely practically true. I don't know if typeclass resolution was designed thus *because* of the open world assumption
06:31:44 <ddarius> yrlnry: Except that the meaning of your code doesn't rely on the monad laws.  Your code has an unambiguous meaning.  With what you are suggesting, the meaning of the code would depend on how GHC decided to resolve the context which could vary from use to use.
06:31:47 <quicksilver> ddarius: or if typeclass resolution was designed in a way which was simple to implement and explain - which has as one of its properties consistency with the open world assumption.
06:31:58 <chrisdone> Baughn: they, anyone :p I'm just used to greeting you in that way now :p
06:32:11 <chrisdone> aristid: the announcer will return
06:32:24 <aristid> chrisdone: nice
06:32:35 <ddarius> quicksilver: The open world assumption is pretty integral to the intent of type classes (and of avoiding whole program compilation which was a goal of Haskell design.)
06:33:08 <yrlnry> ddarius:  there's really no optimization or anything like that that the compiler might apply that is invalid if my Monad instance is not actually a monad?
06:33:23 <ddarius> yrlnry: That is correct.
06:35:07 <yrlnry> The compiler will not possibly try to compute (fmap f) . (fmap g) by doing fmap (f.g) instead, to avoid the double scan of the list?
06:35:40 <ddarius> yrlnry: It may be able to prove that (and in fact it can for some instances of fmap) but it certainly doesn't do that in general.
06:35:46 <Cale> yrlnry: While this is a law that's required to hold in order for the instance of Functor to be a good one, the compiler doesn't know that law.
06:36:03 <quicksilver> ddarius: *nod*
06:36:20 <yrlnry> How do you know?
06:37:36 <ddarius> yrlnry: I could write (and there surely are) Functor instances which don't satisfy the law and see it readily.
06:37:59 <yrlnry> No, you certainly can't!
06:38:04 <ddarius> But mostly I know because I know Simon Peyton-Jones isn't crazy.
06:38:04 <chrisdone> aristid: I want to be sure the spam trap works first
06:38:06 <Cale> yrlnry: Oh?
06:38:38 <Cale> yrlnry: I could define an fmap for a Tree datatype which in addition to applying the function to the elements, flips the tree over left to right
06:38:44 <yrlnry> How on earth are you going to write a functor instance that shows that the compiler does not in general apply an optimization?  All you can do is write an instance that shows that it didn't apply the optimization *this time*.
06:38:56 <yrlnry> That doesn't even make sense.
06:38:57 <Cale> yrlnry: Then I can tell how many times fmap has been applied modulo 2
06:39:02 <Cale> and the law doesn't hold
06:39:16 <ddarius> yrlnry: I already said that it -does- sometimes apply the optimization, so I certainly can't show that it doesn't sometimes.
06:39:43 <ddarius> yrlnry: I could audit the source code if I were worried about it and needed proof.
06:39:44 <manateeUser> /topic
06:40:04 <ddarius> But at that point I should be worried about many other transformations the compiler may or may not be applying.
06:40:18 <ddarius> (And certainly there are transformations that the compiler does that aren't sound.)
06:40:22 <aristid> suggestions for cool random algorithms that i could implement? :) totally in the mood
06:40:25 <quicksilver> that transformation is not built into the compiler in any way.
06:40:34 <quicksilver> there are RULES for []
06:40:37 <aristid> where random = returns a random variable
06:40:41 <yrlnry> Sure.  I was wondering if you and Cale were already familiar with the innards of the compiler, or if you were repeating something you had read in  a technical report, or what.
06:40:42 <quicksilver> (and for all I know, some other useful Functors)
06:40:45 <quicksilver> but nothing general.
06:40:57 <quicksilver> however, for really really simple cases inlining might be enough.
06:41:35 <quicksilver> e.g. with data IDontHave a = NotHere; fmap f NotHere = NotHere;
06:41:48 <chrisdone> aristid: writer a unifier
06:41:51 <ddarius> Inlining probably works for Maybe.
06:41:53 <quicksilver> it's a bit hard to tell if the optimisation is applied or not but certainly 'f' and 'g' can vanish from the core ;)
06:41:58 <aristid> chrisdone: what is that?
06:42:15 <copumpkin> what adjoint pairs of functors do haskell monads arise from?
06:42:24 <copumpkin> is there a simple way of "factoring" a monad?
06:42:34 <chrisdone> a generalisation of pattern matching where free variables are allowed on both sides
06:42:57 <ddarius> copumpkin: There is more than one way to factor a particular monad, so there isn't a unique adjoint for any monad.
06:43:24 <aristid> chrisdone: is there something i can read about it?
06:43:30 <chrisdone> x = x, x = y, x = X, X = X, X /= Y, (x,X) = (X,x)
06:43:36 <chrisdone> @google unification
06:43:37 <lambdabot> http://en.wikipedia.org/wiki/Unification
06:43:37 <lambdabot> Title: Unification - Wikipedia, the free encyclopedia
06:43:55 <copumpkin> ddarius: any examples of how it would work though? for say, the Maybe Monad
06:44:03 <chrisdone> aristid: http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-29.html#%_sec_4.4.2
06:44:45 <ddarius> copumpkin: There are two (not necessarily distinct) canonical factorizations that you could apply, however, you need categories other than Hask.
06:44:58 <copumpkin> yeah, I'd expect that
06:45:49 <copumpkin> do you know of something I can read on "factoring" monads? or some keywords to search for?
06:46:05 <ddarius> copumpkin: It's covered in most introductions to category theory.
06:46:15 <copumpkin> hmm, must've skipped the wrong parts :)
06:46:22 * copumpkin goes back to basics
06:46:34 <chrisdone> aristid: sicp is awesome
06:47:13 <aristid> chrisdone: heh. how would "patterns" be translatable to random variables?
06:48:02 <chrisdone> whadoyou mean?
06:48:05 <ddarius> copumpkin: See page 88 of TTT.
06:48:14 <ddarius> (for example)
06:48:42 <aristid> chrisdone: well, the SICP unification is deterministic
06:48:54 <aristid> chrisdone: but i was asking about algorithms for RANDOM variables
06:49:35 <chrisdone> oh. ambiguous english language is ambiguous
06:50:08 <aristid> aaah
06:50:33 <aristid> chrisdone: a unifier for random variables sounded plausible enough, so i didn't see our little communication problem earlier :)
06:54:16 <chrisdone> ant colony optimisation?
06:54:51 <chrisdone> .. to solve the travelling salesman problem
06:56:12 <yrlnry> In the category-theoretic functor law (map f) . (map g) == map (f.g), the == is understood as logical identity of arrows, isn't it?  That is, that the two arrows much actually be the same arrow.
06:56:38 <yrlnry> It's not equality-up-to-isomorphism in some weaker sense, is it?
06:56:49 <yrlnry> s/much/must/
06:57:18 <aristid> chrisdone: thanks for the suggestion :)
06:57:57 <zygoloid> yrlnry: yeah, i'm pretty sure they're required to be the very same arrow.
06:58:25 <ddarius> If you do weaken it to isomorphism (and similarly for the unit law) you get a pseudofunctor.
06:58:36 <yrlnry> But it seems to me that the requirements of a Haskell Functor instance are somewhat weaker.
06:59:09 <iocor> does haskell have an insert function of the form insert :: Int -> a -> [a] -> [a] s.t insert 2 7 [1,2,3] == [1,2,7,3] and insert 3 'a' "abc" == "abca"
06:59:15 <Philonous> yrlnry: Functor laws are not enforced in haskell
06:59:16 <yrlnry> If for example your Functor is an instance of Eq, it might be possible to prove that your program will be sound as long as the law holds for the (==) or the Eq instance.
06:59:39 <chrisdone> iocor: not that I know of. perhaps in MissingH
06:59:54 * hackagebot non-negative 0.1 - Non-negative numbers  http://hackage.haskell.org/package/non-negative-0.1 (HenningThielemann)
06:59:55 <Philonous> yrlnry: And equality of functions is generally not computable 
07:00:07 <yrlnry> Philonous:  I know that, thanks.
07:01:17 <zygoloid> yrlnry: it also depends on which function arrows we expect to be in Hask. is it one arrow per function up to intensional equality, extensional equality, or ... something else?
07:01:30 <ddarius> For the purpose of the Functor (and Monad and ...) the laws are intended to be with respect to observational equality.
07:01:48 <yrlnry> ddarius:  that is very helpful, thanks.
07:02:12 <yrlnry> It still seems like that might be unnecessatily restrictive.
07:02:23 <ddarius> However, many people do only intend their instances to hold up to some other notion of observation.
07:02:52 <ddarius> yrlnry: It can be and so people don't write instances that satisfy the laws all the time and thus compilers don't optimize based on the laws.
07:02:53 <yrlnry> Assuming your (==) is sensible, you can imagine that it induces a partition of possible values of your type, into equivalence classes of (==) values.  I wonder if you can really get yourself into any serious trouble if your functor law only holds over these equivalence classes.
07:03:27 <yrlnry> ddarius:  that was also very helpful!
07:03:45 <zygoloid> yrlnry: a model which covers non-Eq functors would be more useful i think.
07:04:03 <ddarius> Nothing uses the laws so nothing will break except expectations.  There is a particularly good example with the associative law for monads.
07:04:36 <yrlnry> What's the example?
07:05:28 <zygoloid> i think we can think of encapsulated types as algebras, and then imagine equality as being either equality within either the inital or the final object in the category of models of the algebra
07:05:32 <ddarius> Say you have: ex = do x <- m; y <- f x; g y and you decide to abstract out the first part: n = do x <- m; f x and you rewrite ex = do y <- n; g y.  You've changed how the code is bracketted.
07:05:44 <zygoloid> i suspect that's a direct generalization of the intensional/extensional equality view.
07:06:55 <yrlnry> Oh, the first one had the innermost parent around the right-hand >>=, and the second has them around the left-hand >>=.
07:07:08 <copumpkin> ddarius: thanks
07:07:44 <ddarius> In fact, that example -is- the monad law for associativity.
07:08:19 <yrlnry> And your point is that if the Monad instance fails to be associative, that modification of the program will produce a surprising result?
07:09:10 <ddarius> yrlnry: A probably unexpected change in result for something that looks like it's a refactoring.
07:09:48 <yrlnry> Okay.
07:10:58 * hackagebot crystalfontz 0.1 - Control Crystalfontz LCD displays.  http://hackage.haskell.org/package/crystalfontz-0.1 (KeeganMcAllister)
07:11:45 <yrlnry> Are there any examples of violations of functor or monad laws that are commonly used anyway?
07:13:31 <zygoloid> do you consider (((... infinitely much stuff ...) >> a) >> a) >> a) >> a) to be a reassociation of (a >> (a >> (a >> (a >> (... infinitely much stuff...)))) ?
07:13:54 <yrlnry> I don't know.
07:14:01 <yrlnry> My first impulse is to say no.
07:14:06 <zygoloid> i'm inclined to agree
07:14:21 <quicksilver> zygoloid: that first expression is meaningless
07:14:21 <kmc> hehe i love this channel
07:14:25 <kmc> this would never happen in C
07:14:27 <blackh> kmc: You're busy today!
07:14:34 <quicksilver> well, not quite.
07:14:35 <kmc> "what if your program has an INFINITE NUMBER of SEMICOLONS"
07:14:47 <kmc> blackh, :)
07:14:48 <quicksilver> but it's equivalent to missing out the >> as afterwards
07:14:55 <yrlnry> quicksilver:  I don't understand why you would object to the first but not the second.
07:14:59 <kmc> i'm *so* ready to take on anyone who gripes about "LCD display"
07:15:01 <Saizan> ?type execState
07:15:02 <lambdabot> forall s a. State s a -> s -> s
07:15:17 <Saizan> > execState (fix (>> put 1)) 0
07:15:18 <lambdabot>   1
07:15:28 <zygoloid> quicksilver: meaningless in what way?
07:15:44 <d-snp> hey I'm trying to understand some haskell code, would this `f = 0 : 1 : z` be a function f that returns an array [0, 1, z] ?
07:15:52 <Saizan> > execWriter (fix (tell [1] >>)) []
07:15:53 <lambdabot>   Couldn't match expected type `[t]'
07:15:54 <lambdabot>         against inferred type `[a] -> t1'
07:15:57 <Saizan> > execWriter (fix (tell [1] >>))
07:15:58 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
07:16:23 <blackh> d-snp: No, it returns a list [0, 1] ++ z
07:16:47 <d-snp> right ok, do you by chance know where it pulls z from?
07:17:01 <d-snp> there's no reference to z anywhere else..
07:17:15 <blackh> d-snp: z has to be defined somewhere
07:17:15 <yrlnry> d-snp:  x:y takes a list y, and an element x, and makes a new list which is just like y but has x appended to the front.  [0,1,z] is a shorthand for 0:1:z:[]
07:17:15 <d-snp> the full line is: g = 0 : 1 : z (+) g (tail g)
07:17:26 <d-snp> I suspect it does a fib sequence
07:17:47 <yrlnry> d-snp:  is there a folllowing line that says "where z = ..." ?
07:17:59 <d-snp> no :\
07:18:19 <yrlnry> Any z anywhere else in the program?
07:18:21 <d-snp> the line is in an obfuscation challenge
07:18:44 <d-snp> http://ictf.cs.ucsb.edu/archive/iCTF_2008/challenges/download/Message.hs
07:18:49 <d-snp> maybe it's not supposed to run at all
07:19:02 <blackh> d-snp: if it said zipWith instead of z, then it would make sense
07:19:08 <d-snp> ehh oh
07:19:16 <d-snp> that might very well be possible
07:19:48 <d-snp> ahhh zipWith (+) g (tail g), I hadn't thought of it like that yet
07:19:56 <yrlnry> Ahhh.
07:22:22 <zygoloid> > fix((0:).scanl(+)1)
07:22:23 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
07:23:52 <yrlnry> :t filter
07:23:53 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
07:25:47 <aristid> :t zipWith (+) <*> tail
07:25:48 <lambdabot> forall a. (Num a) => [a] -> [a]
07:26:12 <aristid> d-snp: f x (g x) can be replaced by (f <*> g) x :)
07:26:12 <d-snp> :t [x | x<-[1..10]]
07:26:13 <lambdabot> forall t. (Num t, Enum t) => [t]
07:26:47 <aristid> and f (g x) x by (f =<< g) x
07:27:02 <aristid> :t \f g x -> (f =<< g) x
07:27:03 <lambdabot> forall a b t. (Monad ((->) t)) => (a -> t -> b) -> (t -> a) -> t -> b
07:27:08 <d-snp> woops how do I make the bot execute it?
07:27:14 <aristid> > 1+1
07:27:15 <lambdabot>   2
07:27:17 <d-snp> ah
07:27:21 <d-snp> > [x | x<-[1..10]]
07:27:22 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
07:27:24 <d-snp> right
07:27:27 <d-snp> ok that I get then :P
07:27:50 <d-snp> > [x | x<-[1..]]
07:27:51 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:27:56 <d-snp> right
07:28:02 <aristid> > [1..]
07:28:03 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:29:17 <elliotstern> [[a,b,] | a <- "ab", b <- "bc" ] => ["ab","ac","bb", "bc"].  Is there any function with similar semantics?  i.e. fun ["ab", "bc"] => ["ab","ac","bb", "bc"]?
07:30:14 <d-snp> aristid: what did you mean with the f <*> g comment?
07:31:40 <d-snp> > 1 !! 2
07:31:40 <lambdabot>   No instance for (GHC.Num.Num [a])
07:31:41 <lambdabot>    arising from a use of `e_112' at <inte...
07:31:57 <d-snp> :t !!
07:31:58 <lambdabot> parse error on input `!!'
07:32:06 <d-snp> !! is nothing in haskell?
07:32:11 <nickela> :t (!!)
07:32:12 <geheimdienst> :t (!!)
07:32:12 <lambdabot> forall a. [a] -> Int -> a
07:32:13 <lambdabot> forall a. [a] -> Int -> a
07:32:16 <d-snp> ah
07:32:25 <geheimdienst> > [42, 37] !! 1
07:32:26 <lambdabot>   37
07:32:39 <d-snp> it indexes?
07:32:44 <geheimdienst> yes sir
07:32:50 <d-snp> > [1,2,3] !! 0
07:32:51 <lambdabot>   1
07:32:53 <d-snp> right
07:33:21 <geheimdienst> although it's not used very often, compared to other programming languages
07:33:43 <d-snp> yeah, we got thought in fp class to also avoid it
07:33:47 <d-snp> taught
07:33:48 <d-snp> lol
07:34:27 <d-snp> but we were taught in a pretty basic functional language, that looks a bit like haskell but is simpler I guess
07:35:31 <nickela> @pl g = 0 : 1 : zipWith (+) <*> tail
07:35:31 <lambdabot> g = 0 : 1 : zipWith (+) <*> tail
07:35:50 <nickela> @pl g = 0 : 1 : zipWith (+) <*> tail $ g
07:35:50 <lambdabot> g = fix (0 : 1 : zipWith (+) <*> tail)
07:37:02 <roconnor> ``It is questionable whether it is good style to use Either to flag exceptional return values and define an according Monad instance for that purpose.'' -- http://www.haskell.org/haskellwiki/Orphan_instance 
07:37:11 <roconnor> Why is this questionable?
07:37:24 <roconnor> ``The explicit-exception package with its Exceptional might be a better choice. ''
07:37:29 <roconnor> why is that a better choice?
07:37:33 <elliotstern> So I have a function which returns n strings of length 3.  I'd like to generate all of the permutations of taking 1 from the first, 1 from the second, etc., just like [[a,b,] | a <- "ab", b <- "bc" ] would do.  Is there a function build in that will do that, or do I need to write it myself?
07:37:43 <nickela> @pl g = 0 : 1 : zipWith (+) g (tail g)
07:37:43 <lambdabot> g = fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
07:37:59 <roconnor> as far as I can tell Exceptional is isomorphic to Either
07:38:09 <blackh> elliotstern: The list monad is what you need to use for that.
07:38:37 <aristid> :t \f g h -> (f . g) . h
07:38:38 <lambdabot> forall a b a1 (f :: * -> *). (Functor f) => (a -> b) -> (a1 -> a) -> f a1 -> f b
07:39:37 <blackh> > sequence ["ab", "cd"]
07:39:38 <lambdabot>   ["ac","ad","bc","bd"]
07:39:59 <nickela> @pl let g = 0 : 1 : (zipWith (+) <*> tail) g
07:39:59 <lambdabot> (line 1, column 41):
07:39:59 <lambdabot> unexpected end of input
07:40:00 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>", ";" or "in"
07:40:34 <nickela> hmm
07:40:35 <Saizan> roconnor: i think because they don't like to use "Left" for errors, problems with fail and orphans aside
07:40:57 <nickela> @pl g = 0 : 1 : (zipWith (+) <*> tail) g
07:40:57 <lambdabot> g = fix ((0 :) . (1 :) . (zipWith (+) <*> tail))
07:41:17 <geheimdienst> roconnor, that paragraph you quoted from to me seems to be mostly concerned with the clash between mtl and monads-tf
07:41:19 <roconnor> Saizan: But reasoning applies equally well to Maybe or List
07:41:29 <aristid> > transpose . sequence $ ["ab", "cd", "ef"]
07:41:30 <lambdabot>   ["aaaabbbb","ccddccdd","efefefef"]
07:42:02 <Saizan> roconnor: i guess so
07:42:08 <geheimdienst> it sounds more like "if you use the monadic Either, people will easily run into package clashes, so consider using Exceptional instead"
07:42:20 <aristid> > sequence . transpose . sequence $ ["ab", "cd", "ef"]
07:42:21 <lambdabot>   ["ace","acf","ace","acf","ace","acf","ace","acf","ace","acf","ace","acf","a...
07:42:41 <aristid> > nub . sequence . transpose . sequence $ ["ab", "cd", "ef"]
07:42:42 <lambdabot>   ["ace","acf","ade","adf","bce","bcf","bde","bdf"]
07:43:04 <roconnor> geheimdienst: I guess my problem is that the words "practical advice" is immediately followed by an ideolgical statement
07:43:06 <roconnor> I will edit
07:43:54 <aristid> > sequence . transpose $ ["ab", "cd", "ef"]
07:43:55 <lambdabot>   ["ab","ad","af","cb","cd","cf","eb","ed","ef"]
07:44:55 <roconnor> > throw "Hi"
07:44:56 <lambdabot>   Not in scope: `throw'
07:45:00 <roconnor> > throwError "Hi"
07:45:01 <lambdabot>   No instance for (GHC.Show.Show (m a))
07:45:01 <lambdabot>    arising from a use of `M8330371995...
07:45:09 <roconnor> > throwError "Hi" :: Either String String
07:45:10 <lambdabot>   Left "Hi"
07:45:32 <roconnor> Saizan: You don't have to use Left
07:46:38 <Saizan> you're still using it.. anyhow it's not that clear to me either
07:48:29 <Saizan> i guess it's that Either is being used just because it's a convenient implementation, rather than an ad-hoc type, and while code reuse is good it's a sufficiently simple type that the threshold is subjective
07:48:45 <kmc> i hate using Either for errors
07:48:47 <kmc> hate it so much
07:48:51 <kmc> it should be a separately named isomorphic type
07:49:41 <geheimdienst> what would you use Either for, then? what uses would be left?
07:49:50 <roconnor> Saizan: Either, List, Maybe, are types that everyone in Haskell uses to glue each others interfaces together.  They should be used whenever possible.  (I don't know if this is a good or bad thing)
07:50:26 <roconnor> kmc: I hate using List for non-determinism.  It should be a sepearately named isomorphic type
07:50:33 <kmc> perhaps so
07:50:41 <kmc> there are practical advantages there
07:50:42 <roconnor> kmc: I hate using Maybe for failure.  I should be a sepearately named isomorphic type
07:50:55 <kmc> the Omega monad can search better than []
07:51:22 <d-snp> http://pastie.org/1172332 <-- where could i and j come from?
07:51:30 <geheimdienst> yeah we could make eleventy different isomorphic types for all kinds of things. what's the point
07:51:48 <d-snp> f is probably another function I should run my fantasy on
07:52:14 <roconnor> geheimdienst: we would get to write eleventy-squared more adaptors
07:52:20 <mightybyte> Anyone had problems installing hmatrix recently?  (Duplicate instance declarations...Arbitrary (Complex a))
07:52:28 <Saizan> anyhow, a Monad (Either e) instance has to be there, and we're going to get one in base :)
07:52:36 <roconnor> mightybyte: ;(
07:53:03 <Saizan> mightybyte: i guess you should use --constraint= to specify an older version of QuickCheck
07:53:14 <Saizan> and maybe mail the maintainer..
07:53:15 <mightybyte> Hmmm, ok.
07:54:09 <Saizan> (a good heuristic is to use the version of QuickCheck that was available at the time of hmatrix's release)
07:54:41 <d-snp> ah nvm, i and j are parameters I'm supposed to brute force
07:55:52 <mightybyte> Saizan: Yep, that heuristic is correct in this case.
07:57:01 <kdvh> Hi, does anyone know of any reading material about information visualization using haskell?
07:57:17 <d-snp> what haskell compiler would you recommend me if I just want to try some interactive haskell snippets?
07:57:25 <quicksilver> ghci
07:57:29 <d-snp> else I'll be abusing the bot too much :P
07:57:41 <d-snp> ok
07:57:52 <geheimdienst> d-snp, check tryhaskell.org
07:58:06 <geheimdienst> apart from that, you can have a private chat with lambdabot
07:58:47 <aristid> but ghci is good too.
07:59:08 <geheimdienst> yup, ghci is great
08:03:02 <Adamant> don't tell lambdabot, but her interpreter is just a big wrapper around ghci :P
08:08:47 <dstcruz> sometimes I feel ashamed of having private conversations with a bot :(
08:09:06 <aristid> @vixen is it necessary to be ashamed of talking to you?
08:09:06 <lambdabot> what about me?
08:09:18 <aristid> @vixen oh, nothing. nothing at all
08:09:18 <lambdabot> yeah
08:09:37 <kmc> @nixon
08:09:37 <lambdabot> Don't try to take on a new personality; it doesn't work.
08:09:51 <kmc> @. elite nixon
08:09:52 <lambdabot> Your 8oy$ WIlL Be home phOr cHRi$t/\/\as.
08:10:07 <kmc> @. elite nixon
08:10:07 <lambdabot> I cAn T4xe I+. Th3 tou9HEr It g3+5, +h3 (ooler i g3t.
08:10:41 <geheimdienst> hot, steamy private conversations with her
08:11:02 <kquick2> Question: f :: a -> b allows me to call "f 32", but f :: (Typeable a) => a -> b won't allow that simple specification and requires f (32::Integer) or something similar.  Is there a way to have undecorated numeric literals automatically interpreted as Integer or Int?
08:11:39 <kmc> kquick2, the reason is that Haskell's extremely ad hoc "defaulting" mechanism only applies to values where the *only* constraints are Prelude.Num and such
08:11:40 * hackagebot event-list 0.1 - Event lists with relative or absolute time stamps  http://hackage.haskell.org/package/event-list-0.1 (HenningThielemann)
08:12:08 <kmc> kquick2, you could enable http://www.haskell.org/ghc/docs/6.6/html/users_guide/ch03s04.html#extended-default-rules
08:12:16 <kmc> err, old manual
08:12:30 <kmc> http://haskell.org/ghc/docs/6.12.2/html/users_guide/interactive-evaluation.html#extended-default-rules
08:12:34 <kmc> -XExtendedDefaultRules
08:12:40 <kmc> but really, defaulting is terrible
08:12:51 <kmc> write the signature, or force it with a function
08:12:59 <kmc> i :: Integer -> Integer; i = id
08:13:01 <kmc> f (i 32)
08:13:42 <geheimdienst> isn't there some overloaded strings thingy in haskell? what is that thing's relation with defaulting?
08:13:57 <zygoloid> > let i :: (forall a. Num a => a) -> Integer; i = id in i 32
08:13:58 <lambdabot>   32
08:14:04 <geheimdienst> cause it seems related. a literal in the source could have multiple types
08:14:26 <zygoloid> geheimdienst: that extension causes "foo" to have type (IsString s) => s
08:14:49 <zygoloid> i don't think it changes the defaulting rules (though i don't remember for sure)
08:15:01 <d-snp> where does a module .. where .. clause end?
08:15:27 <kmc> d-snp, at the closing }
08:15:36 <kmc> probably the closing } is invisible, as is the opening { after where
08:15:42 <kmc> @where layout
08:15:42 <lambdabot> http://haskell.org/onlinereport/lexemes.html#sect2.7
08:15:48 <geheimdienst> at the end of the file
08:15:56 <quicksilver> module... where has a strange exception to the layout rule though
08:16:07 <quicksilver> you're not required to be indented more than the 'm' in module
08:16:08 <copumpkin> preflex: seen edwardk
08:16:08 <preflex>  edwardk was last seen on #haskell-blah 6 days, 21 hours, 56 minutes and 19 seconds ago, saying: sproingie: grad students =P
08:16:20 <quicksilver> unlike all other layout constructs.
08:16:45 <d-snp> ah ok
08:16:55 <quicksilver> in fact, GHC didn't really parse it in the normal way at all and so for a long time had a bug where explicit {,} didn't work with it. (Fixed now)
08:17:04 <kquick2> OK.  I think I won't use ExtendedDefaultRules because we're all hip with types and so callers shouldn't be fazed by "Ambiguous type variable" errors.  Thanks for the info.
08:17:44 * hackagebot llvm-ht 0.7.0.0 - Bindings to the LLVM compiler toolkit with some custom extensions.  http://hackage.haskell.org/package/llvm-ht-0.7.0.0 (HenningThielemann)
08:18:08 <mightybyte> Why does cabal-install rebuild a bunch of things like network, hslogger, etc every time I do "cabal install"...even when I made changes that should not required the rebuild?
08:21:46 * hackagebot llvm-extra 0.1 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.1 (HenningThielemann)
08:22:06 <d-snp> so is it possible to use explicit {'s with where? tryhaskell.org times out on: module Message (M,e) where {e = 10}
08:22:45 <d-snp> I should just look up how module keyword works
08:22:47 <kmc> i doubt it's set up to take in whole modules
08:22:48 <d-snp> @where module
08:22:48 <lambdabot> I know nothing about module.
08:22:59 <kmc> it's probably set up the way GHCi is: an implicit IO "do"-block
08:24:50 <ddarius> d-snp: You can use brackets wherever layout is used which is after any of the following keywords: where, let, do, or of
08:25:05 <d-snp> ok
08:25:22 <d-snp> I was wondering why in my file it also exports M, which isn't declared at all
08:25:30 <d-snp> oh wait it is
08:25:31 <d-snp> nvm
08:25:32 <d-snp> :P
08:30:58 <d-snp> > \n
08:30:58 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
08:31:26 <d-snp> hmm what does \n c -> c do?
08:31:39 <d-snp> I know c -> c is a lambda
08:32:01 <kmc> \ is the lambda
08:32:05 <kmc> \ is supposed to look like λ
08:32:20 <kmc> «\n c -> c» is a function of 2 args (call them n and c) which returns c
08:32:26 <Silvah> :t \n c -> c
08:32:27 <lambdabot> forall t t1. t -> t1 -> t1
08:32:35 <kmc> though in haskell, when we say "function of 2 args" we actually mean a function that returns another function
08:32:39 <Silvah> :t const
08:32:40 <lambdabot> forall a b. a -> b -> a
08:32:50 <kmc> «\n c -> c» is sugar for «\n -> (\c -> c)»
08:32:52 <kmc> :t const id
08:32:53 <lambdabot> forall a b. b -> a -> a
08:32:53 <Silvah> So, it's flip const?
08:32:57 <kmc> :t flip const
08:32:58 <lambdabot> forall b a. a -> b -> b
08:33:17 <kmc> @check \x y -> flip const x y == const id x y
08:33:18 <lambdabot>   "OK, passed 500 tests."
08:33:23 <kmc> that's a neat identity
08:33:35 <kmc> it probably checked with () thereby being silently useless
08:33:41 <kmc> @check \x y -> flip const x y == const id (x :: Char) (y :: Char)
08:33:42 <lambdabot>   "OK, passed 500 tests."
08:36:42 <Twey> Haha
08:37:03 <Twey> ‘Haskell node colouring’ — did you mean ‘Haskell *nude* colouring’?
08:38:48 <vanadium> I certainly do not want to see mr curry nude, colored or not
08:39:01 <medfly> no?
08:41:01 <ddarius> kmc: The type is more proof than quickcheck.
08:41:01 <Twey> Hmph
08:41:08 <kmc> yeah
08:41:10 <Twey> I don't like expressing algorithms like this in Haskell
08:41:15 <Twey> It's hard to make them terminate
08:42:09 <ddarius> Twey: Coloring nudes?
08:43:30 <Twey> Nodes…. but yes :þ
08:43:43 <kmc> graph coloring?
08:44:46 <zygoloid> @free f :: a -> b -> b
08:44:47 <lambdabot> h . f x = f (g x) . h
08:45:20 <Twey> Yes… I'm trying to do the ‘greedy’ algorithm as discussed on http://en.wikipedia.org/wiki/Greedy_coloring
08:45:28 <nomemory> is there a difference between : headFold = foldr1 (\x ax -> x) and headFold = foldr1 (\x _ -> x) ?
08:45:39 <Botje> no
08:46:05 <Botje> except ghc might produce a "unused variable" warning on some compiler settings
08:46:15 <Twey> I can order the nodes, but actually colouring them is difficult, because it's pure so I can't really update the later values from the earlier ones
08:46:24 <nomemory> so I should use "_" whenever I have the chance ?
08:46:36 <Twey> So even if I've already coloured node A, once the algorithm encounters A again, the version it will encounter is uncoloured
08:46:46 <Botje> if you're sure you're not going to use the variable, sure
08:46:52 <Twey> nomemory: In this case, it's foldr1 . const
08:47:02 <kmc> if you want to name the variable but still suppress the warning
08:47:05 <kmc> you can start the name with _
08:47:12 <kmc> > case () of _foo -> ()
08:47:13 <lambdabot>   ()
08:47:20 <Twey> Er, foldr1 const even
08:47:27 <kmc> _foo is an ordinary variable name (unlike _) but ghc will ignore the unusedness of it
08:48:16 <d-snp> if I have: newtype M = M { t :: String }, and a parameter M m, does t m return the string that is in M m? 
08:48:31 <kmc> no
08:48:33 <kmc> m is already the string
08:48:39 <nomemory> Can you please elaborate what you wanted to say with "foldr1 . const" ? (It's my fifth haskell day)
08:48:40 <kmc> t is a function of type M -> String
08:48:42 <zygoloid> t (M m) == m
08:49:01 <kmc> d-snp, what you wrote is equivalent to «newtype M = M String; t (M x) = x»
08:49:02 <Twey> nomemory: The function (\x y -> x) is called ‘const’, and it's part of the Prelude
08:49:16 <d-snp> ah ok thanks kmc :)
08:49:28 <Twey> nomemory: So instead of writing ‘foldr1 (\x y -> x)’, you can just write ‘foldr1 const’.
08:49:50 <kmc> d-snp, btw, newtype is something of an optimization, you can use "data" and it will work in more cases
08:50:14 <nomemory> Twey, what about the left fold ? foldl1 (\ax x -> x) ?
08:50:29 <Twey> nomemory: ‘flip const’ or ‘const id’
08:50:35 <kmc> if you're just starting out, it might be best to ignore 'newtype' for a while and use 'data' only
08:51:03 <nomemory> flip being a function that reverses the parameters, right ?
08:51:09 <Twey> nomemory: Right
08:51:35 <Twey> nomemory: And id being the identity function (\x -> x)
08:51:46 <Zao> nomemory: It switches the first and second parameters of a "function".
08:51:46 <nomemory> so flip const would be (\y x -> x)
08:51:50 <Twey> Yes
08:51:54 <d-snp> my code uses two functions, f and f', f' is pseudo code right? or does it actually do something in haskell?
08:52:01 <Zao> d-snp: It's a valid name.
08:52:11 <Zao> > let x''' = 9001 in x''' + x'''
08:52:12 <lambdabot>   18002
08:52:33 <Zao> Lets you do identifiers'named'like'this if you're silly :)
08:52:37 <Cale> > let x = 2; x' = 3 in x + x'
08:52:38 <lambdabot>   5
08:52:54 <d-snp> ok cool Zao :)
08:53:01 <Cale> > let isn't = not in isn't True
08:53:02 <lambdabot>   False
08:53:08 <Zao> Some name the entry function for a recursion foo and the pure recursive bit foo', or vice versa.
08:53:23 <Twey> nomemory: And const id = (\x y -> x) (\x -> x) = (\y -> (\x -> x)) = (\y x -> x)
08:54:09 <kmc> d-snp, often f' is a "variant" on f but it is just another name
08:54:24 <d-snp> yeah, it's probably the inverse in this case
08:54:28 <FunctorSalad> I call the recursive worker 'go'... don't know where I borrowed that
08:54:33 <d-snp> f is one of the functions I need to guess the working of
08:54:37 <kmc> yeah i use 'go' also
08:54:41 <zygoloid> FunctorSalad: that's how a lot of base is written
08:54:49 <FunctorSalad> that might be it :)
08:54:59 <frerich> I call it "step" for some reason
08:55:08 <nomemory> Twey,  (\x y -> x) (\x -> x) = (\y -> (\x -> x)) = (\y x -> x) -> what's this concept called ?
08:55:15 <nomemory> never encountered until now
08:55:16 <nomemory> ?
08:55:17 <d-snp> there is a line f (op ( f' (ord c) ) )
08:55:32 <Twey> nomemory: It's just me showing you how the function works
08:55:39 <nomemory> It like sending a function as parameter ?
08:55:43 <Twey> nomemory: By evaluating it manually
08:55:55 <Twey> It does involve passing a function to another function, yes
08:56:03 <aristid> i want to get the smallest non-zero value for Float, Double... how can i do that?
08:56:12 <kmc> «(\x y -> x) (\x -> x)» is applying the function «(\x y -> x)» to the argument «(\x -> x)»
08:56:15 <aristid> @hoogle epsilon
08:56:16 <lambdabot> No results found
08:56:28 <zygoloid> nomemory: that's beta-reduction in the lambda calculus
08:57:10 <zygoloid> (or at least, the first step is. the second step is just sugar)
08:57:25 <nomemory> let me 'concentrate' a little on this one :P, it's new :P
08:57:55 <frerich> Reminds me that my first two attempts at starting with Haskell failed because all the forums and chats I read gave me the feeling that you need a bloody math degree to understand the language concepts :-}
08:58:26 <aristid> frerich: heh
08:58:27 <frerich> For that reason, I like kmc's answer. :)
08:58:49 <zygoloid> nomemory: beta-reduction says: '(\x -> a) v'  reduces to  'a' with all free occurrences of 'x' replaced by 'v'.
08:58:51 <kmc> i wasn't answering the same question as the beta-reduction answer
08:59:06 <Twey> Hmph… I suspect I'm using the wrong data-structure.
08:59:07 <kmc> and yes math uses weird terms you haven't seen before, but their very uniqueness makes them easy to googl
08:59:31 <kmc> if you google search "beta reduction" you will find a lot of useful articles on the first page, including the Haskell wiki as the third hit
08:59:53 <FunctorSalad> at which position is the first adult result?
08:59:57 * hackagebot xilinx-lava 5.0.0.0 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.0 (SatnamSingh)
08:59:58 <FunctorSalad> o_O
09:00:04 <Twey> If you're operating on a list of things that have references to items earlier in the list to which changes should be propagated, what's the correct data-structure to be using?
09:00:26 <Zao> Changes? Highly impure of you!
09:00:37 <zygoloid> Twey: possibly just a function from Int?
09:01:02 <Twey> Zao: Well, no, I'm trying to keep it pure or I'd just ST it
09:01:15 <Twey> This is a general problem I have a lot of difficulty solving
09:01:20 <Twey> zygoloid: How does that help?
09:01:44 <frerich> kmc: It just dawned upon me that a lot of failures in my past would be explained by me considering some question A to be answered by a question which was meant for question B. :-}
09:01:47 <d-snp> hmm, that's strange, the first function to be thrown into zipWith should be a function that takes 2 functions right?
09:01:48 <zygoloid> Twey: i guess you'd also want to factor out the taking of the fixed point.
09:02:04 <frerich> kmc: 'by a question' -> 'by an answer'
09:02:16 <d-snp> :t zipWith
09:02:17 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
09:02:23 <d-snp> yeah..
09:02:25 <zygoloid> Twey: that way you can define elements in terms of the values of other elements
09:02:53 <d-snp> :t (\n c -> chr c)
09:02:54 <lambdabot> forall t. t -> Int -> Char
09:03:24 <Twey> zygoloid: I kind of already have that… the problem is that I want to now go through and tag each node with a colour
09:03:41 <Twey> Oh
09:03:51 <Twey> Maybe I'm using the wrong representation for my graph
09:05:36 <nomemory>   (\x y -> x) (\x -> x) = (\y -> (\x -> x)) = (\y x -> x) this started to make sense, thanks!
09:05:49 <d-snp> :t zipWith (\n c -> chr c)
09:05:49 <lambdabot> forall a. [a] -> [Int] -> [Char]
09:05:52 <Twey> nomemory: You're welcome ☺
09:06:02 <d-snp> can anyone explain me why that last thing I said works?
09:06:06 <Twey> nomemory: You see how the ‘x’ becomes the parameter we pass, the (\x -> x)?
09:06:49 <Twey> d-snp: zipWith is a function that takes a function of two parameters and two lists, and passes the parallel elements of the lists to the function in turn, returning a list of the results
09:06:56 <d-snp> yes
09:07:05 <d-snp> but the lambda I said doesn't take 2 parameters does it?
09:07:07 <nomemory> Twey, that's why we write y -> (x -> x) 
09:07:11 <Twey> d-snp: Yes
09:07:17 <nomemory> Twey, that's why we write \y -> (\x -> x) 
09:07:18 <Twey> d-snp: One is called n, the other is called c
09:07:29 <Twey> d-snp: You don't use n, but that doesn't really matter
09:07:29 <d-snp> ooohhh
09:07:41 <d-snp> I thought the n was part of the lambda declaration
09:07:44 <Twey> No
09:07:51 <d-snp> that explains it
09:07:59 <Twey> nomemory: Errr, right
09:08:10 <d-snp> does (\ n c -> (n,c)) also work?
09:08:15 <Twey> d-snp: Yes
09:08:18 <d-snp> ok
09:08:28 <Twey> d-snp: Though if you're passing that function, you should be using plain old ‘zip’ instead
09:08:39 <vanadium> @src zip
09:08:39 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
09:08:39 <lambdabot> zip _      _      = []
09:08:39 <Twey> d-snp: (\n c -> (n, c)) is also known as (,)
09:08:45 <Twey> zip = zipWith (,)
09:08:51 <d-snp> ok :P
09:09:05 <FunctorSalad> > uncurry id 1 2
09:09:06 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:09:06 <lambdabot>    `GHC.Num.Num t' arising f...
09:09:20 <Twey> nomemory: Haskell uses a concept of ‘currying’ to represent multiple-argument functions, so e.g. (\x y -> z) is equivalent to (\x -> \y -> z)
09:09:55 <dstcruz> @src const
09:09:56 <lambdabot> const x _ = x
09:10:06 <FunctorSalad> oh no, it's curry id
09:10:22 <dstcruz> @src curry
09:10:22 <lambdabot> curry f x y = f (x, y)
09:10:58 <Twey> nomemory: So if we pass (\a -> a) to (\x -> \y -> x), we evaluate it, substituting that function for the x: (\y -> \a -> a), which we can then see is the same thing again and rewrite it into the tidier multi-argument sugar, (\y a -> a)
09:12:01 <nomemory> Twey, it a little hard for me to grasp right now, but I am struggling.
09:12:20 <monochrom> > const id div 2 10
09:12:21 <lambdabot>   Ambiguous type variable `t' in the constraint:
09:12:21 <lambdabot>    `GHC.Num.Num t'
09:12:21 <lambdabot>      aris...
09:12:21 <lambdabot> monochrom: You have 1 new message. '/msg lambdabot @messages' to read it.
09:12:38 <monochrom> > const id div 2 10 :: Integer
09:12:39 <lambdabot>   2
09:12:45 <monochrom> \∩/
09:12:50 <Twey> nomemory: Meditate on it a while.  It'll come.  ☺
09:13:02 <roconnor> > runCont (return 7) (+1)
09:13:03 <lambdabot>   8
09:13:26 <monochrom> oh oops
09:13:29 <nomemory> Twey, 5 years ago I though C is hard. No I am redefining "hard" :) .
09:13:39 <Twey> nomemory: It's the same thing
09:13:40 <monochrom> > const id True "second"
09:13:40 <lambdabot>   "second"
09:13:54 <Twey> nomemory: C was hard then because you didn't know it.  Haskell is hard now because you don't know it.
09:14:06 <Twey> nomemory: It would probably be about the same if you'd started with Haskell and moved on to C :þ
09:14:37 <arw> hard almost always means "needs a different way of thinking". thats certainly true for c vs. haskell.
09:15:46 <monochrom> both c and haskell were easy
09:17:17 <Twey> Heh
09:17:26 <medfly> I didn';t find it very difficult to learn C starting with Haskell.
09:18:10 <Twey> medfly: You weren't really starting with Haskell
09:18:12 <Twey> You had PHP too
09:18:19 <monochrom> javascript higher-order functions are hard after haskell. this is only because I keep forgetting "return".
09:18:31 <Twey> Heheh, that happens to me, too, now
09:18:33 <medfly> well that wasn't very hard either.
09:18:58 <medfly> Twey, you're assuming I learned PHP before Haskell?
09:19:32 <Twey> Not assuming
09:19:35 <Twey> Misremembering, perhaps
09:19:41 <monochrom> (\b -> if b then (\y->0) else (\y->1)) --> function (b) { if (b) { function(y){0} } else { function(y){1} } }  argh forgot 3 returns!
09:20:46 <Twey> monochrom: Mozilla added a new syntax: function (b) b ? function (y) 0 : function (y) 1
09:20:54 <Twey> (ternary's the way to go, by the way)
09:21:45 <nomemory> can you please explain the idea between their implementation: http://hpaste.org/40014/reverse_function ?
09:22:04 <xplat> @hoogle f (b -> c) -> f (a -> b) -> f (a -> c)
09:22:04 <lambdabot> Data.Generics.Schemes everywhereBut :: GenericQ Bool -> GenericT -> GenericT
09:22:23 <xplat> that's not riiiiiiight ...
09:22:32 <Twey> 'course, higher-order is nicer: Function.const = function(v) function() v; function(b) Function.const(!!b - 0)
09:23:02 <monochrom> hahaha, the HLint hints section tells you why
09:23:10 <Twey> nomemory: It's exactly the same as yours, but point-free.
09:23:38 <xplat> is there a library function that is equivalent to liftA2 (.) (or liftM2 (.))?
09:23:42 <tommd> nomemory: You remake the 'flip' function, which he used (its a function in the prelude)
09:23:53 <tommd> @src flip
09:23:53 <lambdabot> flip f x y = f y x
09:24:39 <tommd> so "flip (:) acc x" ==> "(:) x acc" == "(\acc x -> x : acc) acc x"
09:24:47 <monochrom> the paste bin is on to replacing us
09:25:02 <Twey> nomemory: (\acc x -> x : acc) = (\acc x -> (:) x acc) {- desugar infix -} = (\acc x -> flip (:) acc x) {- rearrange parameters -} = (\acc -> flip (:) acc) {- remove trailing argument -} = flip (:) {- remove trailing argument -}
09:26:41 <nomemory> Twey, wow, I get it now.
09:27:00 <nomemory> Isn't this a little cryptic ? Removing trailing arguments all the time ?
09:27:08 <Twey> nomemory: Not really
09:27:20 <Twey> nomemory: Haskell is such that (\x -> f x) = f, forall f
09:27:28 <zygoloid> (lies!)
09:27:36 <monochrom> Italian is cryptic too, removing objects and subjects all the time.
09:27:36 <Twey> zygoloid: Really?
09:27:47 <Twey> I didn't think Italian was pro-drop
09:28:03 <zygoloid> > ((\x -> undefined x) `seq` (), undefined `seq` ())
09:28:04 <lambdabot>   ((),*Exception: Prelude.undefined
09:28:15 <monochrom> the English says "I accept it". the Italian says "accepto".  huh?
09:28:18 <Twey> Oh, right, yeah, seq.
09:28:23 <zygoloid> Twey: yeah. seq breaks eta-conversion
09:28:29 <zygoloid> eta-reduction?
09:28:34 <Twey> Reduction, I think
09:28:42 <nomemory> I speak Romanian, pretty close to Italian. :) "I accept it" -> "Accept"
09:28:48 <Twey> nomemory: Haskell is such that (\x -> f x) = f, for *almost all* f.  :þ
09:28:50 <ddarius> Reduction is one way, expansion the other, you can use conversion to mean either way.
09:29:00 <monochrom> well there you go. screw "cryptic"
09:29:05 <zygoloid> (or, for almost all sensible notions of =)
09:29:07 <Saizan> it's accetto in italian, btw :)
09:29:12 <Twey> Or… yeah
09:29:15 <monochrom> oh, oops
09:29:28 <Twey> The Finns approve
09:29:46 <Cale> 入れる
09:31:03 <monochrom> and also http://www.vex.net/~trebla/weblog/pointfree.html
09:35:13 <Cale> Japanese doesn't even really have a translation for "it". I suppose you could use one of the words for "that".
09:35:31 <Cale> But the empty string is basically what they use :)
09:36:07 <Twey> Aye
09:36:22 <zygoloid> Cale: does that mean they can't tell the difference between "sting" and "sitting"? ;)
09:36:35 <vanadium> It means they do not have an IT sector. They outsource everything.
09:37:01 <Twey> Heh.
09:37:15 <Twey> ‘Sting’ is not the problem with ‘sitting’…
09:38:23 * Cale grumbles. I can't seem to find a female TRRS to 2 male TRS adapter in Canada.
09:39:13 <Cale> There's one in the US, of course: http://www.amazon.com/Headset-Buddy-Adapter-Smartphone-Converts/dp/B00332DPDG
09:40:16 <xplat> i don't know what is with all these new connectors.  back in my day we just had rca, 1/4"
09:40:17 <zygoloid> Cale: can't you get one from Source?
09:40:56 <Cale> You mean the store by that name?
09:41:05 <zygoloid> yeah
09:41:17 <Cale> Haven't found one on their site.
09:41:33 <xplat> mono, 1/4" stereo, 1/8" mono, 1/8" stereo, 3-wire, bnc, toslink, rj-11, rj-14, mini handset, the 3 different kinds for cars, ...
09:42:19 <Cale> xplat: Yeah, it's obnoxious.
09:43:56 <zygoloid> don't forget the old aeroplane ones, with two separate TS connectors
10:01:54 <Eduard_Munteanu> o/
10:03:58 <Gracenotes> > 10098 % 27405
10:03:59 <lambdabot>   374 % 1015
10:04:08 <Eduard_Munteanu> Hm, I was doing an exercise in futility, erm... OO in Haskell, and it seems I can't reuse class methods' names in other classes.
10:05:04 <Eduard_Munteanu> Also it seems there's a lot of cruft just to handle dispatch.
10:05:23 <Lemmih> Eduard_Munteanu: Type-classes don't really work like OO classes.
10:05:26 * hackagebot xilinx-lava 5.0.0.1 - The Lava system for Xilinx FPGA design with layout combinators.  http://hackage.haskell.org/package/xilinx-lava-5.0.0.1 (SatnamSingh)
10:05:33 <Gracenotes> typeclasses might not be as fruitful as simple data structures with functions in them
10:06:05 <Gracenotes> you don't have subtyping, since OO doesn't *need* that... but you might...
10:06:19 <Lemmih> Eduard_Munteanu: As Gracenotes said, data structures with functions in them are far closer to OO classes than type-classes are.
10:06:36 <Eduard_Munteanu> Lemmih: I know, I'm using a data definition + type class + instance to define an OO class.
10:07:23 <Eduard_Munteanu> Lemmih, Gracenotes: oh.
10:07:36 <Eduard_Munteanu> Is this a hint to look at GADTs?
10:07:43 <Eduard_Munteanu> Or nothing like that.
10:07:50 <Eduard_Munteanu> s/\./?/
10:08:09 <monoidal> is there a nice way to express zip/zipWith for tuples (a,b) -> (x,y) -> ((a,x),(b,y))?
10:08:17 <Lemmih> Eduard_Munteanu: No.
10:08:30 <Gracenotes> just saying, you can transform simple OO objects based on the type of functions in them: those that modify the object and those that access the object
10:08:51 <copumpkin> :t uncurry (***) . ((,) *** (,))
10:08:52 <lambdabot> forall b b' b1 b'1. (b1, b'1) -> (b, b') -> ((b1, b), (b'1, b'))
10:08:52 <Eduard_Munteanu> Gracenotes: ah, functions a-la record syntax.
10:08:53 <Gracenotes> and the entirety of the object's data will be stored in a closure
10:09:06 <Eduard_Munteanu> and accessors.
10:09:17 <copumpkin> monoidal: ^
10:09:20 <zygoloid> monoidal: you want [(a,b)] -> [(x,y)] -> [((a,x),(b,y))] ?
10:09:36 <monoidal> copumpkin: thanks
10:09:48 <copumpkin> not sure that'd be counted as nice though
10:09:51 <monoidal> zygoloid: no, using tuples only
10:10:03 * zygoloid doesn't understand the zip/zipWith reference
10:10:16 <zygoloid> * penny drops *
10:10:26 <siracusa> @pl \(a,b) (x,y) -> ((a,x),(b,y))
10:10:26 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (,)) . flip . (((.) . (,)) .) . (,))
10:10:30 <monoidal> zygoloid: zip [a,b] [x,y] gives [(a,b),(x,y)]. replace [] with ()
10:10:38 <monoidal> * [(a,x),(b,y)]
10:11:18 <Gracenotes> Eduard_Munteanu: so you're interested in modelling objects, not necessarily inheritance (which is not necessary for OO)
10:11:31 <Gracenotes> but in any case, objects with public interfaces where innards can differ
10:11:56 <zygoloid> @type curry ((fst *** fst) &&& (snd *** snd))
10:11:57 <lambdabot> forall a b a1 b1. (a, b) -> (a1, b1) -> ((a, a1), (b, b1))
10:11:58 <xplat> is there a way i can make Either act like a monad?
10:12:04 <Eduard_Munteanu> Gracenotes: well, I'm just fooling around, I wouldn't really stick to OO in Haskell when writing a real program. Just looking at the limits.
10:12:29 * hackagebot random-extras 0.17 - Additional functions for random values.  http://hackage.haskell.org/package/random-extras-0.17 (AristidBreitkreuz)
10:12:38 <zygoloid> @type curry (join (***) fst &&& join (***) snd) -- a bit more like a zip...
10:12:39 <lambdabot> forall a b. (a, b) -> (a, b) -> ((a, a), (b, b))
10:12:59 <Gracenotes> Eduard_Munteanu: suppose you have, in Java, class Foo { private int i; Foo() { this(0); } Foo(int i) { this.i = i; } int increment() { return ++i; }; int get() { return i; }; void reset() { i = 0; } }. In Haskell, try: data Foo = { increment :: (Foo, Int), get :: Int, reset :: Foo }.
10:13:34 <Gracenotes> constructFoo :: Int -> Foo; constructFoo i = Foo { increment = (constructFoo $ i+1, i); get = i; reset = constructFoo 0 }
10:13:45 <Gracenotes> blankFoo :: Foo; blankFoo = constructFoo 0
10:13:55 <Gracenotes> just one object-y technique
10:14:01 <Eduard_Munteanu> Gracenotes: hm, that looks a lot neater than using typeclasses, thanks.
10:14:27 <Gracenotes> each constructor has its own creation function, which may differ in the private variables used
10:14:29 <aristid> :t on
10:14:30 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
10:15:17 <aristid> :t on (&&&) (join (***))
10:15:18 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b c -> a (b, b) ((c, c), (c, c))
10:15:35 <Eduard_Munteanu> Gracenotes: assuming I'd derive that "class", I'd just embed an object and write glue for manual dispatch to the base class, right?
10:15:39 <aristid> :t on (&&&) (join (***)) fst snd
10:15:40 <lambdabot> forall c. ((c, c), (c, c)) -> ((c, c), (c, c))
10:16:07 <aristid> oh well.
10:16:44 <Gracenotes> Eduard_Munteanu: you can make that class a member of another class by making constructBar :: ... -> Foo -> ... -> Bar. You can say that Bar IS-A Foo though
10:16:53 <Gracenotes> *can't say
10:17:25 <zygoloid> data Foo = Foo { increment :: (Foo, Int) }; get = pred . snd . increment; reset = foldr Foo undefined [1..]
10:17:27 <Gracenotes> and whenever you modify Foo, you call constructBar again with it
10:18:07 <Eduard_Munteanu> Ah, I see. So in this case "using a base-typed pointer to the derived object" C++ scenario won't work.
10:18:09 <Gracenotes> this is when you want to hide private variables, essentially allowing any implementation regardless of types
10:18:26 <zygoloid> type Foo = [Int]; get = head; increment (n:ns) = (ns,n+1); reset = [0..]
10:18:34 <Gracenotes> subtyping in haskell is... eh... so-so task
10:19:21 <Gracenotes> if you define it explicitly like zygoloid does, you can't abstract over the Int type easily such that, say, you can use Doubles on the inside instead and convert to Int to match the interface
10:19:29 <Eduard_Munteanu> Gracenotes: hm, I remember some people used existentials to define OO-like classes. Though I can't see the point of polymorphism here at all.
10:19:44 <xplat> this would be monad with return = Right and join Right Right x = x and join Right Left x = Left x and join Left y = Left y
10:19:49 <Eduard_Munteanu> I see.
10:20:00 <xplat> and maybe fail = Left
10:20:58 <monoidal> xplat: Either e can be made a monad
10:21:23 <monoidal> xplat: it has Error e constraint in some libraries because of fail
10:21:43 <tommd> stupid fail.
10:21:48 <xplat> i'm not seeing an instance for it in appropriate places.  is there a newtype wrapper i should be looking at?
10:22:23 <zygoloid> xplat: it's in Control.Monad.Error iirc
10:22:28 <xplat> i don't want to just make my own orphan instance or duplicate work
10:22:29 <Eduard_Munteanu> xplat: there might be a typo, join Left y = Left y looks like infinite types.
10:22:43 <monoidal> xplat: ErrorT is a monad transformer
10:22:43 <zygoloid> Eduard_Munteanu: there's some missing parens.
10:23:25 <xplat> yeah, i left out all the parens/$s because it was for human consumption
10:23:29 <monoidal> xplat: instance Monad (Either e) -- Defined in Control.Monad.Error
10:23:57 <xplat> monoidal: aha, thanks
10:24:32 <monoidal> > do x <- Right 1; y <- Left "error"; return (x/y)
10:24:33 <lambdabot>   Left "error"
10:24:49 <Eduard_Munteanu> Mm, yes, my bad.
10:26:33 <aristid> :t \a -> do x <- Right 1; y <- Left a; return (x/y)
10:26:34 <lambdabot> forall a b. (Fractional b, Error a) => a -> Either a b
10:27:55 <dufflebunk> Has anyone seen warning like http://hpaste.org/40016/ghc_warning it might be an old GHC version, I can't tell
10:28:43 <kmc> they're warnings coming from the assembler that ghc is invoking
10:28:44 <kmc> probably gas
10:28:48 <zygoloid> > "0000000757b12c00" == "0000000057b12c00"
10:28:49 <lambdabot>   False
10:29:13 <kmc> > length "0000000057b12c00" < length "0000000757b12c00"
10:29:14 <lambdabot>   False
10:29:19 <tommd> dufflebunk: Why can't you tell if its an old GHC version?  ghc --version or do you not have access to the machine?
10:29:19 <kmc> so it's "shortening" it to a longer number
10:29:41 <tommd> dufflebunk: And this is a Windows box, right?
10:29:48 <zygoloid> > map length ["0000000757b12c00", "0000000057b12c00"]
10:29:49 <lambdabot>   [16,16]
10:30:00 <zygoloid> no, it's changing the 7 to a 0
10:30:08 <zygoloid> (shortening it from 64 bits to 32)
10:30:33 <dons> haskell powered planes, http://article.gmane.org/gmane.comp.lang.haskell.cafe/80991 
10:31:43 <roconnor> constant time constant space!
10:31:53 <roconnor> is that a linear programming language?
10:32:16 <aristid> dons: and because it generates C, "only" the generated C needs to undergo the bureaucracy?
10:32:21 <Ke> linear programming language only has simplex-operation
10:32:22 <dons> right
10:32:30 <c_wraith> roconnor, constant time, exponential space is *very* hard. :)
10:33:10 <roconnor> I guess I mean straight-line programming
10:33:14 <aristid> constant time constant space is easy if you don't feel a problem with cheating
10:50:22 <dufflebunk> tommd: It's for the google ai challenge, I don't have access to the server. I submit the code in a zip file.
10:51:50 <tommd> Ahh, I see.  Your submission didn't make any assumptions about the platform, I'm guessing.  No 64/32 bit only code?  Thats the first thing that pops into my head when I see shortening like that.
10:52:23 <dufflebunk> It compiles and runs fine on my (likely much newer) 32 bit ghc, the largest number I have is 900000 for a timeout.
10:53:01 <zygoloid> dufflebunk: http://gcc.gnu.org/bugzilla/show_bug.cgi?id=32750
10:54:13 <dufflebunk> zygoloid: Wow, how did you find that one? Looks like the same kind of warning.
10:54:29 <tommd> Interesting.  Do you have control over the flags?  If you can drop the optimization...
10:55:10 <dufflebunk> No control over the flags. Although perhaps there's a {#- directive I can put in
10:55:16 <dufflebunk> the src
10:55:28 <zygoloid> @go warning "shortened to" gcc
10:55:28 <lambdabot> Maybe you meant: google googleit do
10:55:32 <zygoloid> @google warning "shortened to" gcc
10:55:33 <lambdabot> No Result Found.
10:55:39 <zygoloid> lies!
10:57:24 <zygoloid> dufflebunk: you could try {-# OPTIONS_GHC -optc -O1 #-} but i have no idea whether that'll work
11:01:59 <dstcruz> what tool do people use to install haskell packages is arch?  Do you guys manually download and makepkg every singe package and its dependencies?
11:02:48 <tommd> dstcruz: I always use cabal, but dons has put lots of work into getting Hackage packages moved to AUR.
11:03:09 <zygoloid> can you not just install them with pacman?
11:03:18 <Eduard_Munteanu> It's always best to use distro pkgs when available.
11:03:20 <dstcruz> pacman does not use AUR
11:03:47 <tommd> dstcruz: It's been I while since I ran Arch, but doesn't a program called "yogert" do AUR?
11:03:52 <byorgey> Eduard_Munteanu: that depends on the quality of the distro packages.  and on what you intend to do with them.
11:03:54 <dstcruz> tommd: I've been using cabal aswell, but today cabal does not want to install darcs-fastconvert
11:04:01 <dufflebunk> zygoloid: no such luck. Either the flag doesn't help, or it is ignored.
11:04:13 <Eduard_Munteanu> True. Gentoo here seems to be okay.
11:04:40 <dstcruz> byorgey: you think arch's "quality" is up to par?
11:04:55 <Cale> I disagree about distro packages where available. I actually don't use any of Ubuntu's Haskell stuff at all.
11:05:16 <ManateeLazyCat> Cale: Me too. :)
11:05:27 <zygoloid> dstcruz: http://archlinux.fr/yaourt-en
11:05:43 <ManateeLazyCat> Cale: I just like non-Haskell stuff in Ubuntu's sources.
11:05:46 <byorgey> dstcruz: I don't know, actually.  I use arch but install everything with cabal.
11:05:51 <zygoloid> Cale: my haskell install has been broken on several occasions by distro packages being upgraded
11:06:03 <zygoloid> (my user packages depended on the old version!)
11:06:06 <Cale> zygoloid: Yeah, there's weird stuff like that which happens.
11:06:31 <Eduard_Munteanu> But my answer goes along the lines of ivanm's "Cabal's not a pkg manager" sort of story.
11:06:54 <zygoloid> my conclusion is that using distro packages doesn't work
11:06:56 <Cale> I prefer just to install the generic linux binary GHC, and then bootstrap cabal-install and install cabal packages as user from there.
11:06:59 <dstcruz> byorgey: do you install ghc from pacman? or do you roll your own?
11:08:24 <byorgey> dstcruz: I usually compile it myself, but for research purposes I am often using a cutting-edge version, so I am not very representative =)
11:08:26 <zygoloid> my favourite was when my cabal binary broke on a ghc upgrade and couldn't update itself because it didn't speak the new ghc-api language
11:08:51 <zygoloid> ghc-pkg i think i mean
11:08:58 <byorgey> dstcruz: installing ghc via pacman should be fine
11:11:29 <tommd> dstcruz: I think you might have something broken.  darcs-fastconvert installs fine here.  And I agree with Cale on not bothering with distro packages.
11:12:20 <dstcruz> thanks, I'll try to see what's broken.
11:12:33 <vanadium> gentoo's distro package for cabal-install wants to install its distro package for time, presumably overwriting the time that comes with ghc and fucking everything over
11:13:36 <Eduard_Munteanu> Overwrite? Portage does collision detection when merging ebuilds. Unless that's done on purpose.
11:16:39 <dstcruz> this is very confusing: cabal: dependencies conflict: ghc-6.12.3 requires directory ==1.0.1.1 however
11:16:43 <dstcruz> directory-1.0.1.1 was excluded because ghc-6.12.3 requires directory ==1.0.1.2
11:16:59 <dstcruz> so, does it require 1.0.1.1 or 1.0.1.2?
11:17:20 <monoidal> dstcruz: http://www.haskell.org/cabal/FAQ.html#dependencies-conflict?
11:19:10 <dstcruz> monoidal: thanks for the ref
11:25:22 <xplat> @hoogle (a -> b -> m a) -> a -> [b] -> m a
11:25:23 <lambdabot> Control.Monad foldM :: Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:25:23 <lambdabot> Data.Foldable foldlM :: (Foldable t, Monad m) => (a -> b -> m a) -> a -> t b -> m a
11:25:23 <lambdabot> Control.Monad foldM_ :: Monad m => (a -> b -> m a) -> a -> [b] -> m ()
11:27:14 <mightybyte> dstcruz: I don't need bleeding-edge ghc, so I typically use the distro package manager for the big, infrastructure packages and use cabal for everything else.
11:28:27 <dstcruz> good to see you here, mb
11:29:19 <mightybyte> You also want to install most of your packages as --user.
11:31:52 <dstcruz> which is what happens by default if you do "cabal install x" as a mortal, right?
11:32:33 <mightybyte> Yeah
11:43:44 <dstcruz> so, I guess my take away is: before upgrading things with cabal, make sure that said things are not in the system database (i.e. the top section of ghc-pkg list)
11:43:50 <roconnor> I wish students would think about their code that doesn't type check rather than simply write the smallest change that comes to mind that make the code type check
11:44:00 <dstcruz> ... and, only install ghc with pacman, let cabal deal with the rest
11:44:11 <dcoutts_> dstcruz: see cabal install blah --dry-run
11:44:41 <tommd> roconnor: Don't waste your time on students.
11:44:41 <tommd> /me looks at current situation... smacks forehead.
11:45:04 <roconnor> tommd: it is their code that I inherit
11:45:10 <roconnor> :(
11:45:12 <tommd> oh, drat
11:45:32 <dstcruz> roconnor: I've seen that behaviour with people that are used to fix things by looking at a debugger line
11:45:49 <roconnor> dstcruz: a debugger line?
11:46:35 <merijn> My professors use the term "video game programming" for that. Because its one big adventure ;)
11:46:40 <tommd> I think dstcruz is pointing out that people are trained that way by languages that have 90% of there bugs that are easily fixed with local knowledge (ex: forgot to check for NULL)
11:46:55 <dstcruz> i.e. the debbuger (the one I've seen it done with is .NET's) breaks at a line that is broken, tweak that line until it doesn't break any longer.
11:47:13 <roconnor> merijn: I suppose with dependent types as specifications, such behaviour would actually work/
11:47:30 <dstcruz> tommd: yup
11:47:38 <roconnor> dstcruz: I bet that works just as well as making the smallest change to make the code type check
11:47:52 <ezyang> Is it just me or has haskell-cafe decreased in traffic lately? 
11:47:58 <dstcruz> yes, and it it just as infuriating
11:48:09 <tommd> I too can be the human-driven genetic algorithm, evolving a program that fits the Agda properties.
11:48:24 <tommd> ezyang: And thank god.  I unsubscribed for a time because of all the garbage.
11:48:26 <roconnor> tommd: I guess it is actually true that many type errors the correct fix is also basically the smallest fix.
11:48:46 <roconnor> tommd: but still, I'd like if if they thought about what they are doing...
11:49:06 <tommd> roconnor: I not disagreeing with you.
11:49:09 <roconnor> I know
11:49:10 <roconnor> :)
11:50:05 <tommd> @users
11:50:06 <lambdabot> Unknown command, try @list
11:50:08 <tommd> bah
11:50:23 <tommd> I don't like this crippled lambdabot
11:50:27 <tommd> I want my old bot back.
11:50:34 <tommd> @botsmack
11:50:35 <lambdabot> :)
11:50:39 <roconnor> @lusers
11:50:39 <lambdabot> Unknown command, try @list
11:50:41 <roconnor> :(
11:50:54 <pumpkin> it forgot the stats so often they decided that it wasn't worth it
11:51:06 <tommd> I know, but it was fun anyway.
11:51:10 <tommd> pumpkin++
11:51:13 <tommd> @karma pumpkin
11:51:14 <lambdabot> pumpkin has a karma of 6
11:51:18 <pumpkin> :)
11:53:41 <roconnor> oh also, boolean tests are usually evil
11:54:07 <roconnor> I think we should remove Bool from the Prelude :)
11:54:58 <FunctorSalad_> evil?
11:55:01 <FunctorSalad_> why that
11:55:31 <zygoloid> roconnor: i think we should remove 'if' from the language. but i like Bool. it'd be a pain to have to write "True <- " in all my guards
11:55:49 <roconnor> you branch on the results of bool, but the value of your data accessable doesn't reflect your new information.
11:56:27 <roconnor> functions return Either BadStructure GoodStructure is much better
11:56:32 <roconnor> *returning
11:57:04 <roconnor> Ideally you can reconstruct your original structure from that either.
11:57:09 <zygoloid> roconnor: "more things in heaven and in earth..."
11:57:10 <luite> how would you change the type of (==)?
11:57:18 <roconnor> though in practice people simply use () for BadStructure and toss away the information
11:57:42 <roconnor> basically I'm advocating what is suggested by "View from the Left"
11:58:04 <zygoloid> roconnor: but you're also ruling out a whole huge class of /other/ uses of Bool
11:58:18 <roconnor> luite: the false case should be replaced by a structure that says where the two inputs differ
11:59:08 <roconnor> luite: I think the true branch is more or less okay.  For symmetry you'd just return one of the inputs 
11:59:09 <luite> roconnor: where do two infinite lists differ?
11:59:20 <monoidal> luite: on some n
11:59:41 <luite> not really a good example, it is only semidecidable even if you don't want to report where they differ
12:00:01 <monoidal> it's same with (==). it only returns False and _|_ on infinite lists
12:01:37 <roconnor> zygoloid: yes, I admit there are uses for Bool.  So it is okay to import it when needed :)
12:01:46 <luite> monoidal: depends on what you want it to mean, you you want only the first location, or all? and that said, how do two values of Int differ? is it a bit, or just their difference?
12:02:01 <zygoloid> roconnor: i think there are enough that i'd want to keep, for instance, guard syntax
12:02:28 <roconnor> zygoloid: guards are exactly the cases I'm railing against 
12:02:58 <roconnor> luite: you may want different results for comparisions of Ints depending on your purpose
12:03:20 <roconnor> luite: indeed you may want different results for comparisions of any particular structure
12:03:38 <roconnor> luite: I was just trying to give you some ideas of what is better than (==)
12:04:35 <roconnor> Actually haskell, I think, does do a fair job of reducing uses of Bool.  I think we could go further.
12:05:02 <roconnor> probably the biggest obsitical is that making new data types is heavy weight, and we try to avoid it.
12:05:11 <xplat> heh, cycle = flip . (++)
12:05:12 <roconnor> maybe if derivatives of types were automatically derived
12:05:17 <xplat> er, fix . (++)
12:05:20 <roconnor> @src cycle
12:05:20 <lambdabot> cycle [] = undefined
12:05:21 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
12:05:35 <roconnor> xplat: yours is cuter
12:05:45 <zygoloid> roconnor: i'm actually quite happy that haskell doesn't /force/ more type discipline on me
12:05:50 <FunctorSalad_> what about checks? f n = if n < 0 then error "omg error you can't pass negative numbers11111" else ...
12:05:57 <roconnor> zygoloid: heritic :)
12:06:03 <luite> roconnor: yes I can imagine a few, but none that is general enough to include in a modified prelude
12:06:13 <xplat> roconnor: that reminds me, i am interested in reading your thesis
12:06:17 <roconnor> FunctorSalad_: clearly you need a better type
12:06:30 <roconnor> xplat: it is online
12:07:03 <monoidal> roconnor: something like this? http://hpaste.org/40021/equal_with_information
12:07:03 <FunctorSalad_> roconnor: well, the "n" may be user input
12:07:10 <FunctorSalad_> dependent types won't save you from that AFAIK
12:08:10 <roconnor> FunctorSalad_: you should have a function Int -> Either NegativeNumber NonNegativeNumber
12:08:22 <roconnor> *Integer
12:10:36 <roconnor> monoidal: I might be inclide to type Inf (a,b) = Either (Inf a,b) (a,Inf b)
12:10:45 <xplat> either that or Σn: Integer. n > 0
12:11:04 <xplat> er, n >= 0
12:11:04 <roconnor> monoidal: on the theory that you should be able to recover (a,b) from Maybe (Inf a)
12:11:20 <roconnor> monoidal: Ideally (a,b) and Maybe (Inf a) should be isomorphic
12:11:39 <monoidal> roconnor: (a,a) and Maybe (Inf a)?
12:11:53 <monoidal> or I didn't understand?
12:12:03 <roconnor> monoidal: ya, (a,a) and Maybe (Inf a)
12:12:13 <roconnor> or rather (a,a) and whatever the result of equal is
12:12:26 <monoidal> sigfpe has done something very similar: http://blog.sigfpe.com/2007/09/type-of-distinct-pairs.html
12:12:30 <roconnor> yes
12:12:39 <roconnor> I was going to bring that up
12:13:17 <roconnor> I think that the result of type of equal given a should be EIther (DistinctPair a a) a
12:13:31 <roconnor> so my intuition tells me
12:13:42 <Twey> Wh…y?
12:13:47 <Twey> Oh, right.
12:14:08 <roconnor> the result is isomorphic to the input
12:14:14 <Twey> Yeah
12:14:25 <roconnor> and the top constructor is exactly what you want to do case analysis on
12:14:43 <xplat> it just kind of pulls the single bit of information that you want to the outside
12:14:45 <roconnor> and the braches of your case contain exactly the knowledge that you have
12:14:49 <xplat> like a zipper, in a way
12:14:53 <roconnor> ya
12:15:24 <roconnor> the view from the left is all about taking data, tranforminging it in an isomorphic way to gain a new view
12:15:28 <roconnor> and then splitting that
12:15:40 <roconnor> I think it is a good ideal
12:15:45 <roconnor> to strive for
12:16:19 <roconnor> But as you can see, the type of distinct pairs is not a lightweight thing to write in haskell
12:16:22 * shapr is entertained by one of those recent reddit haskell posts...
12:16:46 <roconnor> shapr: A..Z?
12:17:14 <shapr> Nah, the one from the past hour or so where someone is complaining that the Haskell community should stop thinking about math and write some code.
12:17:38 <roconnor> :)
12:17:45 <shapr> My response: The great thing about open source is... if you see a need, you can fill it yourself. \n Lead, follow or get out of the way. There is no whine.
12:17:46 <shapr>  
12:17:51 <shapr> whoops, accidental blank line.
12:18:05 <roconnor> This line is intentionally left blank
12:18:31 <xplat> code, or code not ... there is no feature request
12:18:32 <kaol> To be filled.
12:18:55 <shapr> xplat: yup, you got it.
12:19:46 <roconnor> shapr: heh, I don't think he'd appreciate my rant againt Bool. 
12:20:09 <lpsmith> you suggest replacing Bool with Int, or something else entirely?
12:20:51 <lpsmith> Or replacing bool with lambda expressions?
12:21:26 <roconnor> lpsmith: replacing Bool as a function result with Either BadStructure GoodStructure
12:21:40 <roconnor> lpsmith: where BadStructure and GoodStructure depend on the function
12:22:00 <roconnor> but ideally "Either BadStructure GoodStructure" should be isomorphic to the input
12:22:43 <roconnor> GoodStructure would be then a type that represents exactly those structures that satify the predicate
12:23:00 <roconnor> and BadStructure would be a type that exactly represents those structures that do not statify the predicate
12:23:23 <lpsmith> ahh, ok
12:27:50 <xplat> a good (==) on lists would just return the prefix that is identical and the suffixes, if any, that begin with the first difference
12:29:24 <roconnor> xplat: yes.  BadListStructure should be something like ([GoodStructure],BadStructure,[a],[a])
12:29:36 <roconnor> or rather
12:29:42 <roconnor> ([a],BadStructure,[a],[a])
12:30:08 <xplat> you still need to have a LeftLonger and RightLonger case
12:30:22 <roconnor> xplat: ah right
12:32:42 <augur> ive attempted to increase my britishness by eating a ploughmans lunch. is it working?
12:32:49 <augur> do i seem more british to you folks?
12:33:07 <xplat> but to do this realistically you need some kind of deriving-on-steroids where you don't even have to list all the instances you want by hand for each type, plus some extra polytypic stuff in general
12:33:08 <bremner> more German actually.
12:33:15 <augur> DAMN
12:33:32 <augur> two world wars and one world cup, doo daa, doo daa.
12:33:36 <augur> bremner: how about now?
12:34:12 <bremner> oops, -> -blah
12:38:55 <roconnor> xplat: yes. :(
12:39:18 <roconnor> xplat: though with these type
12:39:27 <roconnor> xplat: though with these associated types, maybe there is a little hope
12:41:01 <ddarius> Just post that it can't be done on Haskell-Cafe and wait for Oleg.
12:41:13 <roconnor> :)
12:41:31 <roconnor> ah, the good ol'  "It can't be done in your language" trick :)
12:42:01 <yrlnry> If Dave Turner gets his way and we start using total functional languages...
12:42:43 <shapr> Wow, Jim Apple's reply to the purely functional data structures post on cstheory.stackexchange.com is seriously awesome!
12:42:54 <roconnor> @link
12:42:54 <lambdabot> Maybe you meant: kind list ping
12:43:51 <xplat> is there a list of Oleg Facts anywhere?
12:43:56 <ManateeLazyCat> I'm fixing bugs for ready to release next version gtk2hs, if have any GTK+ function you want not exist in gtk2hs, please tell me, welcome to test gtk2hs darcs and report bug! :)
12:44:00 <revenantphx> @oleg
12:44:02 <lambdabot>  Defined.
12:44:05 <revenantphx> hm, what was it.
12:44:10 <revenantphx> oh shit, I just added an empty one
12:44:10 <revenantphx> crap.
12:44:13 <revenantphx> @help
12:44:14 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:44:17 <revenantphx> @help oleg
12:44:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
12:44:21 <revenantphx> @help list
12:44:21 <lambdabot> list [module|command]
12:44:21 <lambdabot> show all commands or command for [module]. http://code.haskell.org/lambdabot/COMMANDS
12:44:25 <revenantphx> @list
12:44:25 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
12:45:34 <Adamant> shapr: is that were all the cool kids post instead of LtU these days?
12:45:38 <Adamant> *where
12:46:18 <ddarius> Perhaps.
12:46:39 <roconnor> how did the AI people kill lisp?
12:46:49 <ddarius> roconnor: By not solving AI.
12:47:26 <roconnor> heh
12:47:26 <mightybyte> shapr: Is stackexchange the open source version or the Spolsky & Atwood version?
12:47:30 <xplat> by solving AI, then the AI killed lisp so there wouldn't be another
12:47:38 <ddarius> I think Neel is on StackOverflow or somewhere.
12:47:47 <zygoloid> augur: you'd seem more british if you just called it a "ploughman's".
12:48:06 <augur> zygoloid: probably!
12:48:31 <zygoloid> augur: you also lost some credibility by saying "folks"
12:48:49 <augur> D:
12:48:49 <ddarius> MathOverflow
12:48:54 <xplat> "lot" would have worked better
12:49:19 <Heffalump> stackexchange is the umbrella site for Spolsky & Atwood sites
12:49:21 <augur> xplat: if i were trying to SPEAK britishy i wouldve certainly said you lot
12:50:06 <xplat> i'm not sure what else about you you expect to seem british over irc.  have you changed to a .uk hostname or something?  :)
12:51:07 <Heffalump> augur: I think you'd need to provide before and after photos.
12:51:38 <bos> that mazieres job on haskell-cafe looks like fun.
12:51:57 <augur> Heffalump: hold on, let me get some bangers and mash and a pint that i can pretend to be enjoying
12:52:11 <augur> actually the bangers and mash would be yummy.
12:52:27 <xplat> make sure it's a warm pint, we'll be checking for condensation
12:53:33 <dstcruz> mightybyte: http://stackexchange.com/sites
12:53:35 <Adamant> zygoloid: like most Southernisms, "folks" is really just a retro-Britism
12:53:58 <zygoloid> augur: i actually had bangers and mash for dinner...
12:54:06 <dstcruz> StackOverflow is an instance of StackExchange, me thinks
12:54:16 <augur> zygoloid: good choice!
12:54:18 <Heffalump> dstcruz: sort of, except that it predates stackexchange
12:54:24 <augur> zygoloid: now i shall pretend to be scottish
12:54:29 <zygoloid> augur: and i have a pint in my hand. it's pear cider, but still...
12:54:34 * augur deep fries the bread and cheese, throws out the onion
12:54:57 <aristid> data StackOverflow -- and it was in the beginning
12:55:11 <aristid> class StackExchange -- but they found the need for a platform
12:55:20 <aristid> instance StackExchange StackOverflow
12:55:28 <Heffalump> augur: that's Glaswegian. Glasgow :: Scotland as Scotland :: Britain
12:55:52 <Heffalump> aristid: you couldn't do that with OO!
12:55:59 <bos> glaswegian is pretty appropriate given the heritage of GHC
12:56:05 <aristid> Heffalump: it depends on the kind of OO :)
12:56:10 <augur> Heffalump: true, but my model for making fun of scotland is frankie boyle, who's from glasgow
12:56:37 <aristid> benmachine: i've been adding lots of shininess: http://hackage.haskell.org/package/random-extras-0.17 :)
12:57:57 <nomemory> is haskell a language that is based on the idea: "there's one way to do things", or on the contrary, "there are many ways to do things"
12:58:00 <nomemory> ?
12:58:59 <aristid> nomemory: neither :)
12:59:17 <aristid> however, "there's a paper on how to do it"
12:59:20 <nomemory> aristid, "there is no way you can do things ?"
12:59:32 <nomemory> :)
12:59:35 <medfly`> zero, one, many
13:00:30 <nomemory> so there's no "haskellic" (god, sounds silly), like in "pythonic" way ?
13:01:26 <ddarius> Python is about the only language that subscribes to Python's philosophy.
13:01:52 <aristid> nomemory: there's no "dictator" in haskell who could force people to agree on one "true way"
13:02:37 <dcoutts_> nomemory: you might like to read "why functional programming matters", it emphasises the idea that programs should be compositional
13:03:12 <nomemory> John Hughes ?
13:03:17 <dcoutts_> yep
13:03:21 <nomemory> i have that document in my queue :)
13:03:44 <roconnor> ddarius: thank goodness
13:04:30 <roconnor> python supports the antithesis of good programming practice i.e. encapsulation
13:04:47 <roconnor> (er, encapsulation is the good programming practice)
13:06:23 <merijn> ddarius: Really? I find most principles of the Zen of Python to just be solid program design principles
13:07:09 <merijn> As such I find it applies to my Haskell code just as much as my python code
13:07:24 <shapr> How so?
13:08:15 <xplat> as an example of how haskell is not TOOWTDI, most functions can be written in either a pointed or point-free style
13:08:36 <aristid> with do or without do
13:08:48 <merijn> shapr: For example: Simple is better than complex. But complex is better then complicated.  Readability counts. Namespaces are one honking great idea -- let's do more of those!
13:08:58 <aristid> xplat: but TOOWTDI does not really apply to python either
13:09:00 <merijn> How are these not principles worth following in any language?
13:09:10 <aristid> TOOWTDI is a myth
13:09:12 <monoidal> still, I'd regard pointfree and pointful as completely equivalent ways. It's like you can write x as x+0.
13:10:04 <roconnor> monoidal and I wear beta-normal-eta-long glasses
13:10:25 <medfly`> what is TOOWTDI?
13:10:33 <shapr> there's only one way to do it
13:10:37 <merijn> The Zen of python also doesn't specify there should be only one way to do things, it says: There should be one-- and preferably only one -- *obvious* way to do it. (http://dpaste.com/246990/ for the entire thing)
13:10:54 <shapr> heippa hei freiksenet 
13:11:20 <roconnor> merijn: wow, that post doesn't even seem remotely related to python
13:11:31 <roconnor> merijn: or even programming
13:11:35 <roconnor> er
13:11:40 <roconnor> s/related/specific/
13:11:45 <medfly`> hello :o
13:11:48 <merijn> roconnor: That was my point :p
13:11:57 <aristid> shapr: stop cursing freiksenet with your witch language
13:11:59 <roconnor> merijn: I'd argue that the title is wrong
13:11:59 <shapr> merijn: I'd argue that recursive is better than flat.
13:12:06 <medfly`> so python is so dictatorish that it forces a lifestyle? :-p
13:12:20 <merijn> Recursive is not the opposite of nested
13:12:36 <shapr> merijn: This sounds like a nifty discussion, do you have a blog?
13:12:40 <merijn> A 5 times nested if statement is nested
13:12:45 <aristid> Nested is not the opposite of recursive
13:12:46 <shapr> Ahh!
13:13:02 <shapr> Excellent point, I wasn't thinking about that.
13:13:14 * roconnor also prefers *structured* (aka nested) to flat
13:13:14 <xplat> 'where' is haskell's excellent way of fighting nesting
13:13:17 <merijn> shapr: Naah, because I don't get around to setting one up, too much to do ;)
13:13:30 <EvanR-work> medfly`: theres only one way to do it
13:13:32 <roconnor> wait are we talking about data structures or layout?
13:13:35 <shapr> merijn: Too bad, I'd like to read about this when I have time to devote brain-cycles to it.
13:13:38 <medfly`> EvanR, oh, ok, thx
13:13:58 <aristid> roconnor: python
13:13:59 <shapr> aristid: Ich habe keine ahnung!
13:14:14 <roconnor> aristid: with regards to "Flat is better than Nested"
13:14:15 <merijn> shapr: Tim Peters wrote it, one of the main python contributors. You get that output when you run "import this" in the interpreter
13:14:18 <aristid> shapr: Spritzlblitz! Blitzkrieg!
13:14:34 <shapr> merijn: I know, I used to be a heavy duty Pythonista before I found Haskell. I've met Guido, etc at the cons.
13:14:41 <shapr> Python got me into Haskell, in fact.
13:14:45 <roconnor> heh, Although that way may not be obvious at first unless you're Dutch.
13:14:46 <merijn> Same here :p
13:14:49 <EvanR-work> python's 'philosophies' were a reactionary measure against perceived status quo of perl practice
13:14:57 <EvanR-work> over reactionary
13:15:30 <roconnor> I'd like to see van Rossum and Dijkstra in a ring.
13:15:46 <aristid> perl got me into haskell, in fact (for _very_ liberal interpretations of "getting into")
13:16:03 <xplat> pugs ftw?
13:16:17 <aristid> xplat: isnt that dead?
13:16:33 <xplat> but it got many people into haskell while it lived
13:16:40 <merijn> Haskell is like a gateway drug to nerdery >.>
13:16:57 <shapr> roconnor: Dijkstra would whip his butt on theory :-P
13:17:13 <shapr> Guido has done wonderful things, but I strongly question his theoretical knowledge.
13:17:13 <FunctorSalad_> eh? by the time you've even heard of haskell you're already way beyond the point of no return
13:17:16 <merijn> Starts out innocent with this "learn functional programming" pretense, but before you know it you're learning type theory and working with Coq
13:17:31 <shapr> merijn: Rocks, don't it?
13:17:33 <xplat> i wonder why GHC never adopted something like TRex
13:17:34 <roconnor> shapr: ah, but what would happen in practice :D
13:17:36 <shapr> preflex: seen japple
13:17:36 <preflex>  Sorry, I haven't seen japple
13:17:49 <shapr> roconnor: In practice, Guido is much younger :-)
13:17:51 <roconnor> shapr: oh I read that as "Dijkstra would whip his butt in theory"
13:18:02 <shapr> roconnor: ARGH
13:18:03 <shapr> too punny
13:18:10 <merijn> Doing a literature study on type theory now for my master's, unfortunately leaves me little time to do any actual hacking >.>
13:18:26 <shapr> merijn: What's your master's subject?
13:18:37 <roconnor> merijn: I got into Haskell from Coq.
13:18:49 <djahandarie> Heh
13:19:08 <xplat> that's like getting into drinking through heroin
13:19:10 <merijn> shapr: Computer science (with a high performance distributed computing they have here)
13:19:22 <merijn> s/they/specialty they/
13:19:28 <shapr> merijn: Sounds like much fun!
13:19:40 <xplat> (not that there's anything wrong with that)
13:19:51 <dstcruz> shapr: yes, it rocks, even if it makes my head hurt
13:19:51 <roconnor> xplat: it was like a practical version of Coq
13:20:26 <merijn> Trying to do a lot of both theoretical and low level hacking subjects. Quite a succes so far. Strangely no one else seems to enjoy either of those. On the upside, that means less competition for jobs later :D
13:21:08 <ddarius> roconnor: That's like saying Word is a practical version of Haskell.
13:21:13 <shapr> dstcruz: Sadly, I loaned out my copy of Rabhi and Lapalme's "Algorithms : A Functional Programming Approach"
13:21:14 <xplat> looking to create the next Cyclone?  or the first BitC?  :)
13:21:21 <shapr> and it's now gone permanently :-(
13:21:36 <ddarius> merijn: What jobs?
13:21:49 <dstcruz> is there an upper bound to age for going to grad school in the CS field?  Specifically in a prog langs area?
13:22:18 <pumpkin> if you're over 22, you're automatically disqualified
13:22:24 <ddarius> dstcruz: Currently it's around 110.
13:22:26 <shapr> dstcruz: I doubt it. I suspect I'm older than you ;-P
13:22:36 <FunctorSalad_> merijn: I'm interested in both too...
13:22:47 <merijn> ddarius: I'm a lazy person, as long as I don't look at jobs I don't have to compute which exist >.>
13:23:06 <FunctorSalad_> pumpkin: seriously?
13:23:24 <ddarius> merijn: [] stores more efficiently than a thunk for (findJobs myCriteria)
13:23:30 <merijn> FunctorSalad_: The largest majority of the people here doesn't >.>
13:23:32 <dstcruz> I know that the age question might sound a bit silly, but I know that in some areas, youth is a bit component of getting accepted into a program
13:23:51 <xplat> 22 in base64?
13:23:52 <pumpkin> no, there's no requirement
13:23:57 <merijn> FunctorSalad_: Out of like 200-300 CS masters we had like 14 in a compiler class
13:23:59 <FunctorSalad_> merijn: 'here' as in this channel would we news to me
13:24:01 <FunctorSalad_> ah
13:24:05 <dstcruz> where as in others they seem to like "older folks"
13:24:34 <merijn> FunctorSalad_: I'd say people in here #haskell are not representative of the world at large :p
13:24:43 <djahandarie> Hmm, grad school.. maybe I could get in by the time I'm 22
13:25:15 <djahandarie> Definitely not sure about going at all though
13:25:20 <merijn> Go to grad school in Europe, almost no one gets into grad school before 22
13:25:36 <merijn> Mostly because going to grad school after your bachelor's is unheard of
13:25:47 <roconnor> Go to grad school in Europe, they pay you better than post-docs in America
13:26:04 <merijn> I'm not even sure they accept people from here without a masters
13:26:20 <ddarius> Sampling #haskell, I extrapolate that 100% of the people in the world visit the #haskell IRC channel.
13:26:23 <djahandarie> Even with a undergrad thesis and mad skills?
13:26:33 <p_l> to start doctorate you need Master's (in Europe)
13:26:36 <adnap> Wow, lots of people in here today.
13:26:51 <merijn> ddarius: I have good hope that there should be research work (academic or corporate) in distributed/high performance computing in the future
13:26:54 <roconnor> ddarius: ack!  Bayes rule!! use bayes' rule
13:26:56 <nomemory> p_l, not true
13:27:14 <nomemory> p_l,  i mean not in all countries
13:27:33 <merijn> nomemory: Maybe not strictly necessary, but certainly the de facto standard in most countries here
13:28:05 <p_l> nomemory: in some you need something in between, like in Scotland, where Honours and Master in Science (not to mistake for normal Masters) allows you to start doctorate
13:29:47 <dstcruz> if you wanted to do a haskelly type of postgrad, where would you look into in the USA?
13:30:01 <merijn> djahandarie: Going to grad school or not seems to really depend on what you want to do...
13:30:49 <orium> does anybody knows a compiler haskell to c compiler which generates a standalone .c file?
13:30:51 <merijn> I like teaching and explaining, plus I want to work on the cutting edge (and not necessarily worry about commercial viability), so grad school seems the place to go for me.
13:31:11 <pumpkin> orium: JHC
13:31:32 <orium> thank you :)
13:35:31 <edwardk> roconnor: you still have to typically pay out of EU rates though =/
13:35:42 <ddarius> pumpkin: You know how to factor comonads now?
13:36:38 <edwardk> orium: keep in mind that jhc generates c files, but its not as feature-rich as ghc
13:37:08 <orium> ok, thanks
13:37:19 <pumpkin> ddarius: no, have been busy doing miscellaneous "getting ready" things for tomorrow :) but I'd imagine it's pretty similar to factoring monads, except backwards
13:41:24 <dcoutts_> orium: check you're not wasting your time, jhc can only compile relatively small progs, not ones that use lots of standard libs or hackage packages
13:42:24 <orium> hum, for what i want that is probably ok
13:42:34 <ddarius> edwardk: Should I start answering questions on MathOverflow?
13:42:34 * hackagebot midi 0.1.5.2 - Handling of MIDI messages and files  http://hackage.haskell.org/package/midi-0.1.5.2 (HenningThielemann)
13:42:55 <edwardk> ddarius: that bored? =)
13:43:41 <ddarius> edwardk: Not really.  I've been playing a lot of violin lately.  I kind of what to play it no.
13:43:44 <ddarius> s/no/now/
13:44:49 <edwardk> Great i get you out here, and now I'll likely lose you to the boston symphony orchestra ;)
13:45:35 * hackagebot midi-alsa 0.1 - Convert between datatypes of the midi and the alsa packages  http://hackage.haskell.org/package/midi-alsa-0.1 (HenningThielemann)
13:45:46 <moosefish> Why would cabal 'suddenly' complain with: "cannot satisfy -package-id filepath-1.1.0.4-8cd460e017dd1650ea2bbcf32381944f: 
13:45:46 <moosefish>     filepath-1.1.0.4-8cd460e017dd1650ea2bbcf32381944f is shadowed by package filepath-1.1.0.4-c303c646a99c2a24d2402008d247eb5f"
13:46:10 <monochrom> perhaps one is installed globally, one is installed userly
13:46:21 <monochrom> when in doubt, delete the user
13:46:37 <moosefish> just rm -Rf ~/.cabal?
13:46:46 <nomemory> for this function: valueToFunc == map ($ 3) [ (+4), (*10), (^2), sqrt ]
13:46:49 <nomemory> what's the signature ?
13:46:52 <merijn> monochrom: Sounds like my motto while I had a sysadmin job :>
13:46:58 <monochrom> actually ~/.ghc
13:46:59 <nomemory> valueToFUnc :: (Floating a) => a -> [a -> a] -> [a] is not working
13:47:01 <moosefish> last I did that I had to manually reinstall every package, as it refued to to recursive dependency installs
13:47:50 <monochrom> you can let ~/.cabal live. user's registry is in ~/.ghc
13:47:51 <monoidal> @type map ($ 3) [ (+4), (*10), (^2), sqrt ]
13:47:52 <lambdabot> forall a. (Floating a) => [a]
13:48:05 <monoidal> nomemory: ^ did you mean this?
13:48:09 <monochrom> OTOH deleting all of ~ is ok too
13:49:12 <monochrom> the world is a better place if everyone picks one and sticks with it: always --global; always --user
13:49:47 <monochrom> if you tend to mix "cabal install blah" and "apt-get install blah", stick with --global for "cabal install blah".
13:49:52 <monoidal> nomemory: map's type is ((a -> b) -> b) -> [a->b] -> [b] with some class constraints I'm too lazy to figure
13:50:23 <EvanR-work> :t map
13:50:24 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:50:28 <EvanR-work> lies!
13:50:34 <monoidal> in this specific case :)
13:50:43 <dcoutts_> monochrom: hmm, I'm not sure it's any better to use --global if you're using apt-get for Haskell packages
13:51:07 <EvanR-work> --global?
13:51:09 <nomemory> monoidal, i am to "noob" to figure :)
13:51:16 <EvanR-work> install system-wide?
13:51:23 <nomemory> *oo
13:51:32 <ddarius> edwardk: That won't be happening for probably several years yet.
13:51:32 <monochrom> There exists an interleaving of "cabal install --user" and "apt-get install" that greatly confuses everything.
13:51:42 <aristid> :t map . flip id
13:51:42 <lambdabot> forall b a. a -> [a -> b] -> [b]
13:52:05 <dcoutts_> monochrom: ah, you mean if you install the same thing per-user and later install it globally via apt-get ?
13:52:34 <dcoutts_> monochrom: then the per-user one would (usually) still take precedence which might not be what you want, is that what you're thinking of?
13:52:45 <monochrom> something like that. install the same thing indirectly due to dependency
13:53:05 <dcoutts_> EvanR-work: right, per user or system wide
13:53:34 * monochrom still has to write his Storage and Identification of Cabalized Packages article to explain all this.
13:53:37 <dcoutts_> EvanR-work: it affects the default install prefix and the package database to register into
13:54:11 <dcoutts_> monochrom: if I get the time then that article will be soon obsolete :-)
13:54:43 <EvanR-work> dcoutts_: i thought this option did not exist because 'why would you want to install system wide' must be new
13:54:46 <dcoutts_> monochrom: I'd like to make cabal do more nix-style package installation
13:55:05 <dcoutts_> EvanR-work: it's been there from the beginning
13:55:47 <monochrom> the logs have the scenerio. I said it in the channel a long time ago.
13:55:59 <monochrom> give me some 10 minutes to find it
13:56:40 * hackagebot http-enumerator 0.0.0 - HTTP client package with enumerator interface and HTTPS support.  http://hackage.haskell.org/package/http-enumerator-0.0.0 (MichaelSnoyman)
13:56:57 <dcoutts_> EvanR-work: when we added the 'cabal' command line program we switched the default from global to per-user
13:57:42 <monoidal> are channel logs downloadable/greppable somewhere? Only place I know is http://tunes.org/~nef/logs/haskell/
13:59:40 <monoidal> which gives unformatted text for each day and doesn't allow searching
14:00:33 <xplat> you could download all of them and then search :)
14:01:03 <ray> ooh, a haskell shirt in the mail
14:01:17 <xplat> is it made of hair?
14:01:24 <dv_> is it pure?
14:01:25 <ray> thank god, no
14:01:39 <Eduard_Munteanu> 100% cotton, no adverse side-effects.
14:01:43 <EvanR-work> lol
14:02:20 <merijn> @where lambdacats
14:02:20 <lambdabot> http://tinyurl.com/lambdacats
14:02:46 <Eduard_Munteanu> ray: where did you order that? (If you did.)
14:03:00 <ray> http://haskell.spreadshirt.com/
14:03:08 <Eduard_Munteanu> Thanks, I'll have a look.
14:03:21 <ray> i think that's by dons?
14:03:30 <Eduard_Munteanu> Hm, good price.
14:03:42 <Eduard_Munteanu> I hope shipping to Europe is cheap too.
14:04:17 <Eduard_Munteanu> Well, is that dons in those photos?
14:04:40 <jnj> Data.Binary.Strict.BitGet.getBit appears to read bits from the most-significant to the least-significant, does anyone know a nice trick to reverse this behaviour? (My only idea is to map something over the ByteString to reverse each Word8)
14:04:55 <merijn> The "I'm not a category theorist" one should have "But I play one on TV!" (or optionally "But I play one on #haskell!") on the back :>
14:05:10 <ray> it says "i just play one on irc" on the back
14:05:13 <Eduard_Munteanu> LOL... "OLEG ALREADY DID IT"
14:05:14 <EvanR-work> jnj: an array of size 256 ;)
14:05:14 <ray> i made that one up, incidentally!
14:05:31 <Eduard_Munteanu> (2nd page)
14:05:51 <merijn> ray: Nice one. It didn't show the back at first :>
14:07:23 <dcoutts_> jnj: how about just doing a map with a function that operated on each word8?
14:07:43 <dcoutts_>  /operated/operates/
14:07:51 <merijn> I didn't get my Knights of the Lambda Calculus card yet, so I don't think I'm hardcore enough to wear any of those shirts :p
14:07:53 <edwardk> merijn: heh, i need that shirt ;)
14:08:10 <edwardk> gotta run
14:08:17 <dcoutts_> merijn: I'm thinking of getting the "bring back monad comprehensions" one
14:08:40 <edwardk> i want to add the diagram to the zygohistomorphic prepromorphism too ;)
14:08:55 <edwardk> gah, really gotta run
14:09:13 <Eduard_Munteanu> Definitely. Categorical diagrams would rock on a t-shirt.
14:10:17 <Adamant> someone really does need to give a "Oleg Already Did It" shirt to Oleg.
14:10:28 <Adamant> I ain't gonna do it, but I'm broke-ish :P
14:11:12 <ddarius> "but"?
14:11:15 <ddarius> Oh.
14:12:32 <merijn> I still need read up on category theory too, got several intro papers lying around. But I guess I'd be better of first finishing my type theory attempts :p
14:13:20 <jnj> dcoutts_: I'm parsing compressed data where individual elements may span bytes. Each compreesed element is preceeded by 2-3 bits stating how to uncompress the element. Anyways, all this soon starts to spill over to the next byte, so handeling one bit at a time is a very intuitive way of processing the data compared to map (which would require some state). Sorry if this makes no sense.. :)
14:13:30 <Eduard_Munteanu> I feel the same. Got Awodey's latest edition, but didn't take it up seriously. Read a few chapters, but I have to do those exercises properly, on paper.
14:14:03 <Eduard_Munteanu> (TAPL is on my gotta-get-soon list)
14:14:03 <dcoutts_> jnj: ah ok right, then a bitstream adapter sounds right
14:14:06 <dufflebunk> zygoloid: Turns out I had another big number, the number of milliseconds in a year. I took it out and the problem went away.
14:14:06 <merijn> Especially since my type theory work is at least worth course credits to me, unlike category theory :p
14:14:22 * ezyang really really wants to get a copy of TAPL 
14:14:28 <merijn> Eduard_Munteanu: I was told TAPL is a good book for type systems and programming, but not so much for type theory
14:14:34 <Eduard_Munteanu> Ah, makes sense then. I don't have any formal education-related needs for it.
14:14:57 <Eduard_Munteanu> merijn: hm, that might be true, but that's okay for me.
14:15:11 <xplat> category theory and type theory go pretty well together
14:15:46 <jnj> Since this is very little data, I have no big problems with mapping a function that reverses a Word8 bit-for-bit. I just figured that a "reverse" getBit would be just as needed as the default one. 
14:16:02 <merijn> Eduard_Munteanu: If you're interested http://www.cs.vu.nl/~femke/courses/lv/notes/notes.pdf these are the course notes for the class Logical Verification here that I'm reading as an intro into type theory now.
14:16:03 <Eduard_Munteanu> Hm, so I hear. Awodey does have a few examples that involve lambda calculus and type theory. They're sorta optional.
14:16:14 <Eduard_Munteanu> merijn: nice, thanks.
14:16:20 <Heffalump> ezyang: why not get one, then? :-)
14:16:40 <merijn> Also covers some Coq
14:16:52 <Eduard_Munteanu> Heh, I'm waiting for a friend to make up his mind and we'll order together from Amazon US.
14:17:05 <xplat> sometime i have to learn about all these recursion patterns
14:17:23 <Eduard_Munteanu> merijn: wow, that's nice then. I was going through Coq myself some time ago.
14:17:46 <xplat> zygohistomorphic prepromorphisms and Elgot coalgebras and stuff
14:18:07 <merijn> No we've gone straight from complex into chinese >.>
14:18:13 <merijn> s/No/Now
14:19:04 <Eduard_Munteanu> That's what they sometimes do here as well. It's Chinese, and the exam revolves around a few "typical" problems/exercises and some theory.
14:19:55 <ddarius> You could study categorical type theory.
14:20:16 <Eduard_Munteanu> Lucky we're allowed to bring books/notes during some exams.
14:20:55 <Eduard_Munteanu> ddarius: ah, I suppose I'll stick to those issues as separate things for now.
14:21:16 <merijn> I'm lucky with some of the profs in the theoretical CS section here. They're supergeniuses.
14:22:10 <merijn> And not in the "they're really smart", but in the "they're so smart they can actually explain all this stuff in a way that I somehow actually get it" sense
14:22:27 <Eduard_Munteanu> merijn: well yes, that's great in some respects. Though my main complaint with my education is that very very few people make good teachers.
14:22:32 <Eduard_Munteanu> Oh.
14:22:53 * hackagebot hoauth 0.3.0 - A Haskell implementation of OAuth 1.0a protocol.  http://hackage.haskell.org/package/hoauth-0.3.0 (DiegoSouza)
14:23:26 <Eduard_Munteanu> (And I'm not blaiming it on them, I praise some of my teachers whose exams I barely passed, but the lecture notes / textbooks were great.)
14:33:51 <Eduard_Munteanu> Uh, I hate it when otherwise worthy software is hosted on CVS... what's wrong with these people...
14:34:18 <Adamant> Eduard_Munteanu: they're old?
14:34:45 <Eduard_Munteanu> Hm, that could be. Though it's Qucs, I thought it started as a student project.
14:36:32 * Eduard_Munteanu gets it through it.
14:36:36 <Eduard_Munteanu> *Git
14:36:59 * hackagebot hamlet 0.5.0.2 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-0.5.0.2 (MichaelSnoyman)
14:59:13 <copumpkin> dolio: SPJ argues that those GADT cases I brought up are the right behavior
14:59:22 <dolio> Really?
14:59:29 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/3927#comment:6
15:00:43 <copumpkin> I can see where he's coming from, but it makes me shudder
15:01:31 <copumpkin> I still think it should be an error and not a warning
15:01:41 <dolio> Yes, _ makes sense there. FZ and FS do not.
15:01:56 <dolio> I'd expect the latter two to be errors.
15:07:08 <krey_> hello, has anyone here used coq, isabelle or twelf? which one would you recommend?
15:08:35 <copumpkin> man, I feel arrogant contradicting SPJ
15:08:51 <danharaj> He's not infallible.
15:09:07 <mreh> danharaj: yes he is
15:09:29 <copumpkin> it's more of a "what am I misunderstanding, cause he's probably right
15:10:05 <Susefreak> I am having troubles with installing a tool. I run "cabal install etqwtools" from the dir with the .cabal package but it will not let me install it.
15:10:07 <mreh> most learning takes place in spite of your teachers I find
15:10:25 <mreh> speaking from a personal perspective
15:11:11 <ddarius> copumpkin: It seems he didn't know what you were asking.  All you are asking for is that that "inaccessible code" warning be an error.
15:11:28 <Eduard_Munteanu> krey_: AFAIK, Coq received the most attention and that's probably going to help you find good tutorials/docs.
15:11:34 <copumpkin> yeah, in retrospect I wasn't very clear
15:11:35 <dcoutts_> Susefreak: you need to be more specific when reporting problems or nobody can help you
15:11:36 <Susefreak> cabal: "etqwtools.cabal" is not valid syntax for a package name or package dependency.
15:12:11 <Susefreak> and ls in the dir gives back: etqwtools.cabal and src/
15:12:12 <Eduard_Munteanu> krey_: also look at Agda if you want something based on / inspired from Haskell.
15:12:16 <dcoutts_> Susefreak: ok so are you running "cabal install" or something like "cabal install etqwtools.cabal"  ?
15:12:31 <Susefreak> cabal install etqwtools
15:12:58 <monoidal> are references given by stToIO (of type IO (STRef RealWorld a)) "safe"/natural? Can I compare them safely for identity etc.?
15:13:02 <ddarius> copumpkin: It's probably harmless and arguably beneficial for that to remain a warning though.
15:13:04 <dafis> Susefreak: if you're in the etqwtools directory, just run 'cabal install' with no args
15:13:08 <dcoutts_> Susefreak: to install the package that lives in the current dir you just say "cabal install"
15:13:10 <ddarius> copumpkin: Also, who is copumpki-?
15:13:15 * hackagebot iyql 0.0.6 - CLI (command line interface) to YQL  http://hackage.haskell.org/package/iyql-0.0.6 (DiegoSouza)
15:13:25 <Susefreak> aah, classic mistake I presume?
15:13:31 <copumpkin> ddarius: whoops, a bouncer I set up and forgot about
15:13:33 <dcoutts_> Susefreak: but the error message is interesting, I wonder if there's something else going on
15:13:40 <copumpkin> ddarius: why arguably beneficial?
15:14:10 <Philippa> copumpkin: you can imagine scenarios reworking some code where some of it's temporarily dead
15:14:15 <Susefreak> dcoutts_:  I'm updating the tool with a newer version
15:14:21 <ddarius> copumpkin: It allows more incremental refactorings and experimentation.
15:14:43 <copumpkin> but look at the test example above
15:14:45 <copumpkin> it rejects that
15:15:37 <copumpkin> it seems analogous
15:15:58 <dcoutts_> Susefreak: you're sure you didn't mention "etqwtools.cabal" anywhere on the command line or in the .cabal file when you got that error message?
15:16:01 <dafis> copumpkin: there you have a type mismatch
15:16:18 <copumpkin> dafis: same with the one below
15:16:34 <copumpkin> it just happens to be between refined types of the parameters
15:17:03 <Susefreak> Nope, I can post my bash history if you want. PS Running haskel from macports
15:17:32 <dcoutts_> Susefreak: can you still reproduce that confusing error message?
15:17:44 <copumpkin> anyway, I might reluctantly buy the refactoring argument, but I think it should behave the same way for test and index
15:18:13 <copumpkin> maybe I'm being too opinionated though
15:18:14 <Susefreak> Just a sec, install right now
15:18:16 <copumpkin> conal would disapprove
15:18:46 <tommd> preflex: seen po8
15:18:46 <preflex>  po8 was last seen on #haskell 221 days, 3 hours, 45 minutes and 2 seconds ago, saying: Oh well; guess I'll email some people.  Thanks anyway.
15:18:53 <tommd> preflex: seen PO8
15:18:53 <preflex>  PO8 was last seen on #haskell 221 days, 3 hours, 45 minutes and 8 seconds ago, saying: Oh well; guess I'll email some people.  Thanks anyway.
15:18:55 <tommd> ok
15:18:58 <ddarius> copumpkin: I don't think conal disapproves having opinions.
15:19:20 <Adamant> conal is pretty reasonable.
15:20:01 <copumpkin> yeah, I was just referring to something he said a while ago about there being too many opinions and opinionated people with too little justification, or something along those lines
15:20:22 <copumpkin> and I'd hesitate to call my opinion an educated one
15:20:45 <Adamant> copumpkin: offer it as a beginner's look at things.
15:20:49 <Susefreak> Gommorah:etqwtools. arnestierman$ cabal install etqwtools.cabal 
15:20:49 <Susefreak> cabal: "etqwtools.cabal" is not valid syntax for a package name or package
15:20:49 <Susefreak> dependency. @dcoutts_ 
15:21:01 <tommd> Can anyone educate me on why Xilinx lava is making some rounds on Hackage while Satnam knows Kansas lava is seeing a fair amount of love these days? 
15:21:02 <Susefreak> yay irc pasting ftw!
15:21:04 <dafis> copumpkin: yes, in the first, there's only one arg, with a fully specified type, hence it's obvious that Fz and Fs have the wrong types, in the second, that can only be determined after refinement. I agree that it would be better if the refinement of the first arg lead to errors on the second rather than warnings, but I can imagine that would be difficult to implement.
15:21:07 <copumpkin> Adamant: that works :) now I can't go back and edit my post without it looking suspicious
15:21:11 <dcoutts_> Susefreak: ok great, so cabal isn't going mad then
15:21:23 <dcoutts_> Susefreak: it's correct to say that's not the right syntax
15:21:31 <dcoutts_> that is: $ cabal install etqwtools.cabal
15:21:40 <dcoutts_> should be: $ cabal install etqwtools
15:21:50 <conal> when i hear opinions, i usually wonder what the speaker really knows, (e.g. observations & preferences), and what ideals s/he is going for.  i get a lot more out of those things than out of opinions.
15:21:51 <tommd> or just "cabal install" if you are in the directory for etqwtools.
15:21:55 <Susefreak> yeah sorry took my complet bash output
15:21:56 <monoidal> Susefreak: you can use http://hpaste.org for longer pastes
15:22:00 <copumpkin> dafis: fair enough; so I guess it boils down to a pragmatic thing:)
15:22:15 <ddarius> dafis: Why would that be difficult to implement?  If it knows enough to give the warning, it can easily give an error instead.
15:22:22 <Susefreak> Yeah usually use pastebin, but was rather lazy this time, thnks for the tip though
15:22:26 <dcoutts_> Susefreak: and note that "cabal install etqwtools" means the one from hackage, not the local one.
15:22:43 <copumpkin> anyway, if anyone wants to chime in on that ticket, either way, feel free to :P
15:22:51 <conal> and so often conflicts on opinions turn out not to be conflicts at all.
15:22:53 <dafis> ddarius: I don't know whether it'd be difficult, I just can imagine it would be.
15:23:16 <Susefreak> aah alright thanks for clearing that up
15:23:27 <ddarius> dafis: How?  It already does it, it just says warning rather than error.
15:23:31 <Susefreak> Thanks a lot and g'night
15:24:02 <copumpkin> also
15:24:08 <copumpkin> in SPJ's example
15:24:12 <copumpkin> it's the same thing I'm advocating :P
15:24:21 <copumpkin> http://snapplr.com/fjwp
15:24:45 <ddarius> copumpkin: The differences in your two examples may be related to the bug itself.
15:25:09 <dafis> ddarius: are the warning producing code and the type checker the same? Might require a major change in the type checker (or not, I'm not familiar at all with the GHC internals)
15:25:21 <copumpkin> but I guess he doesn't specify what it should do on the bad patterns
15:25:36 <copumpkin> since he uses the word "unreachable" in http://snapplr.com/x3jd
15:25:41 <copumpkin> instead of "badly typed"
15:27:36 <ddarius> copumpkin: Anyway, I'm curious to see how SPJ responds.
15:28:28 <copumpkin> me too
15:36:40 <ddarius> http://www.christienmeindertsma.com/files/gimgs/20_img9222.jpg
15:38:08 <monochrom> > ()
15:38:09 <lambdabot>   ()
15:38:09 <medfly`> hehe
15:39:05 <copumpkin> ddarius: is that your kind of knitting?
15:40:31 <ddarius> Having yarn that thick would be awesome.
15:40:54 <ddarius> I'd probably crochet it with my arm to avoid needing to store two large wooden dowels.
15:41:34 <monoidal> unionfind in haskell, comments welcome (first time I used ST): http://hpaste.org/40025/unionfind
15:42:02 <ddarius> Incidentally, I whittled my first crochet hook.
15:45:23 <mreh> is anyone aware of why there can't be a ListMap Arrow 
15:45:54 <ddarius> What's a ListMap?
15:45:55 <mreh> arr = map, f >>> g = g . f
15:47:09 <mreh> the ListMap arrow maps all elements in a list of one type to a list of another type
15:47:17 <monoidal> mreh: I think you could write data ListMap a b = ListMap ([a] -> [b]) and an instance of Arrow for that
15:47:40 <mreh> monoidal: well this paper is insinuating you can't
15:47:51 <mreh> @src Arrow
15:47:51 <lambdabot> class Arrow a where
15:47:51 <lambdabot>     arr, pure   :: (b -> c) -> a b c
15:47:51 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
15:47:51 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
15:47:51 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
15:47:53 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
15:47:55 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
15:48:11 <mreh> oh, I didn't thin about those
15:49:03 <monoidal> ([b] -> [c]) -> ([b'] -> [c']) -> ([b,b'] -> [c,c']) doesn't seem natural
15:50:13 <mreh> quite
15:50:21 <ddarius> :t \f -> uncurry zip . f . unzip
15:50:22 <lambdabot> forall a b a1 b1. (([a1], [b1]) -> ([a], [b])) -> [(a1, b1)] -> [(a, b)]
15:50:50 <mreh> that's not the same
15:51:13 <ddarius> It's not intended to be.
15:51:20 <mreh> okay :)
15:52:43 <ddarius> :t \f g -> uncurry zip . (f *** g) . unzip
15:52:44 <lambdabot> forall a b a1 b1. ([a1] -> [a]) -> ([b1] -> [b]) -> [(a1, b1)] -> [(a, b)]
15:54:35 <ddarius> Laws probably don't hold.
15:54:51 <mreh> hmm
15:54:53 <monoidal> mreh: this paper http://www.cse.chalmers.se/~rjmh/afp-arrows.pdf on page 2 says this can be made an arrow
15:55:05 <monoidal> if 403, use google cache
15:55:23 <Eduard_Munteanu> Hm, I suppose function application can't be overloaded, can it?
15:56:41 <monoidal> mreh: * page 3
15:56:53 * hackagebot haskell-src-meta 0.1.1 - Parse source to template-haskell abstract syntax.  http://hackage.haskell.org/package/haskell-src-meta-0.1.1 (BenMillwood)
15:58:03 <ddarius> Eduard_Munteanu: No.
15:59:59 <Eduard_Munteanu> Aw. I've been thinking of something crazy like data Map a = Map [a], and defining application something like f `apply` (Map xs) = Map $ map f xs
16:00:30 <jmcarthur> Eduard_Munteanu: i've written a preprocessor to do that
16:01:05 <aavogt> what would be the difference between that and having a more general type for f there?
16:01:09 <Eduard_Munteanu> jmcarthur: interesting. Is it anywhere on Hackage?
16:01:34 <jmcarthur> Eduard_Munteanu: it basically just replaces whitespace with ($), so you can overload it by hiding Prelude's ($) and making a type class or whatever
16:01:42 <jmcarthur> Eduard_Munteanu: https://patch-tag.com/r/jmcarthur/overloaded-whitespace/home
16:01:57 <Eduard_Munteanu> aavogt: well if you applied that on lists of lists I suppose there would be some difference, plus it's not explicit.
16:02:06 <Eduard_Munteanu> jmcarthur: thanks.
16:02:11 <jmcarthur> Eduard_Munteanu: i think i have an example somewhere too, h/i
16:02:13 <jmcarthur> *h/o
16:03:41 <vanadium> heh
16:03:43 <aavogt> Eduard_Munteanu: having general types (ex. use typeclasses) isn't explicit either
16:03:47 <jmcarthur> Eduard_Munteanu: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24906  http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24908
16:03:53 <Eduard_Munteanu> Like f [[1, 2], [3]] = [f [1, 2], [3]] = [[f 1, f 2], [f 3]] under those assumptions.
16:04:41 <jmcarthur> Eduard_Munteanu: my overloading is too general to be practical (ambiguities all over the place if you're not careful), but a more restricted overloading may still be useful. i don't know for sure, haven't thought about it in a while
16:04:49 <aavogt> you can write such a function which does that for arbitrarily nested lists
16:05:44 <jmcarthur> Eduard_Munteanu: http://hpaste.org/fastcgi/hpaste.fcgi/view?id=24907  <-- ghci session with those functions
16:05:48 <Eduard_Munteanu> aavogt: yeah, though it's explicit for any given function. I'm not saying it's bad, it's only something I thought of :)
16:05:49 <aavogt> though quite likely you need some ghc extensions like -XOverlappingInstances
16:07:40 <Eduard_Munteanu> jmcarthur: ah, looks nice. I suppose it could be improved by replacing only true function application (possibly get information from GHC core).
16:08:04 <jmcarthur> Eduard_Munteanu: it does only replace true function application
16:08:12 <jmcarthur> *syntactic function application, that is
16:08:47 <jmcarthur> Eduard_Munteanu: if you get information from ghc core then it already type checked and everything, so that wouldn't be very useful
16:10:25 <Eduard_Munteanu> I see.
16:10:32 <Eduard_Munteanu> I'm gonna give it a go.
16:11:11 <jmcarthur> what i found the most annoying is that because it's a preprocessor i can't play with it in ghci
16:12:12 <jmcarthur> i've been playing with repa over the last couple days. it's actually pretty cool!
16:12:34 <Eduard_Munteanu> Repa?
16:12:36 <jmcarthur> i thought it would be weird to reason about... it's different for sure, but i'm getting the hang of it
16:12:43 <jmcarthur> @hackage repa
16:12:43 <lambdabot> http://hackage.haskell.org/package/repa
16:12:47 * Eduard_Munteanu looks
16:13:13 <jmcarthur> could use some polish
16:14:16 <Eduard_Munteanu> Um, I suspect shape just refers to the number of dimensions of the arrau.
16:14:20 <Eduard_Munteanu> *array
16:14:57 <jmcarthur> yeah
16:15:26 <jmcarthur> well, the sizes of those dimensions i think
16:26:29 <taktoa> hello?
16:26:52 <taktoa> how can I modify my quicksort function to sort by the last value of a list of tuples?
16:26:53 <taktoa> http://pastebin.com/HNpGDPTA
16:28:07 <medfly`> @src sortBy
16:28:07 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
16:28:22 <Eduard_Munteanu> taktoa: well, you can start by making a 'last' function a-la fst/snd but for 4-tuples, then use that in the comprehensions.
16:29:00 <Saizan> the easiest way is to pattern match
16:29:46 <ddarius> jmcarthur: You ever play with J?
16:29:47 <taktoa> I've done that
16:29:53 <taktoa> but you must remember
16:30:05 <taktoa> that the tuples must remain together
16:30:14 <Saizan> http://pastebin.com/5xP0DV19 <- like this
16:30:15 <Eduard_Munteanu> taktoa: well it's the comprehensions that do the comparisons.
16:30:30 <taktoa> ie: (1,2,3,4):(1,2,3,5):(1,2,3,6)
16:30:38 <taktoa> can't mix the tuples
16:30:59 <Saizan> or you could newtype the tuples and write your special Ord instance :)
16:31:08 <Saizan> taktoa: look at my paste
16:31:30 <Eduard_Munteanu> taktoa: sure you can if you mean (1,2,3,4):(1,2,3,5):(1,2,3,6):[]
16:32:34 <jmcarthur> ddarius: nope, although i've been meaning to try it
16:34:53 <taktoa> yeah, thanks
16:34:56 <taktoa> it works
16:35:04 <applicative> taktoa, what do you mean, 'can't mix the tuples'
16:51:10 <fserb> I'm trying to compile some OpenGL apps in haskell. Is there any way to tell ghc to automatically convert GLfloat to Float?
16:52:21 <monochrom> realToFrac
16:53:28 <monochrom> or perform all arithmetic on GLfloat directly. it is instance of sufficiently many type classes.
16:53:42 <hpc> @hoogle GLFloat
16:53:42 <lambdabot> No results found
16:53:45 <tommd> fserb: There is no implict coercing in Haskell if that's what you're wondering.
16:53:51 <tommd> hoogle is rather limited.
16:54:04 <hpc> iirc, GLfloat is a type alias for Float
16:54:12 <hpc> and GLint is an alias for Int32
16:54:19 <tommd> It was once, I thought that changed though
16:54:46 <tommd> http://hackage.haskell.org/packages/archive/OpenGLRaw/latest/doc/html/Graphics-Rendering-OpenGL-Raw-Core31.html#t:GLfloat
16:54:50 <tommd> Looks like it isn't anymore
16:55:12 <hpc> huh
16:55:25 <monochrom> \∩/
16:55:40 <fserb> so I was trying to compile bloxorz and I get a "couldn't match GLfloat against inferred type float" :/
16:56:28 <monochrom> is bloxorz very old code?
16:56:30 <dmwit> It means bloxorz is broken. Downgrade your OpenGL binding or fix the bloxorz code yourself. Bonus points for sending a patch. ;-)
16:56:36 <dmwit> bloxorz is not very old -- a year or so
16:56:39 <tommd> Right, because just like hpc, the bloxorz package probably used an older version of the OpenGL package (without proper version bounds, tisk) and assumes GLFloat is a Float.
16:57:32 <aavogt> so just install with the correct --constraint="OpenGL < ... "
16:57:43 <dmwit> yes, exactly
16:57:44 <aavogt> until somebody uploads a corrected version
16:58:27 <fserb> I see. Makes sense.
17:06:48 <xplat> sortBy is an insertion sort? :(
17:07:08 <kmc> the Report's reference implementation is
17:07:08 <copumpkin> no
17:07:12 <kmc> and @src probably gives you that
17:07:27 <kmc> xplat, http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/src/Data-List.html#sortBy
17:07:28 <monoidal> xplat: http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Data-List.html#sortBy
17:07:33 <Eduard_Munteanu> I thought soryB\y was mergesort.
17:07:45 <kmc> sortBy in Haskell is sort.
17:07:47 <d-snp> why can't I do f = 1 in ghci? :)
17:07:55 <monoidal> d-snp: let f = 1
17:07:58 <d-snp> ah
17:08:02 <kmc> sortBy in base-4.2.0.2 in GHC is merge sort
17:08:14 <d-snp> thx :)
17:08:15 <monoidal> d-snp: butin source code on toplevel declarations, don't use let
17:08:36 <Eduard_Munteanu> There's some contention over what's better, quicksort or mergesort. The latter seems to give better _guarantees_, although quicksort _usually_ performs better.
17:09:03 <Eduard_Munteanu> Plus I think the original quicksort isn't stable.
17:09:17 <fserb> if there's no data constructor for GLfloat, the only way to fix the code it is by putting ( ... :: GLfloat) on every single float number there?
17:09:26 <kmc> radish sort!
17:09:28 <d-snp> monoidal: because it lets you override things?
17:09:46 <monoidal> fserb: Quaternion.hs compiles if you change Float to GLfloat in data and some signatures. don't know about rest
17:10:08 <monoidal> d-snp: no, it's the syntax. after you declare a=1, you can't say a=2. Haskell is not imperative
17:10:21 <fserb> monoidal: tried that. The rest breaks
17:10:35 <monoidal> fserb: where's Paths_bloxorz?
17:11:25 <c_wraith> kmc: what if I have other vegetables?
17:11:44 <aavogt> monoidal: that's supposed to be generated by cabal
17:12:13 <aavogt> it is put somewhere like   dist/build/autogen/
17:12:33 <fserb> monoidal: "cabal configure / cabal build" creates it.
17:12:52 <monoidal> thanks
17:13:24 <xplat> ah.  it's nice to know that my original assumption was good.  thanks kmc and monoidal!
17:14:49 <zc00gii> :|, map ain't working for this
17:14:54 <zc00gii> map digitToInt twenty
17:15:03 <d-snp> I'm trying to use this: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Bits.html#v%3Axor , but it won't let me do: xor 1 3
17:15:04 <zc00gii> twenty being a Int
17:15:06 <zc00gii> owait
17:15:07 <zc00gii> DUH
17:15:12 * zc00gii is silly
17:16:30 <monoidal> fserb: in Etc.hs, changing type of piPer2 to GLfloat allows to compile Cubezor
17:17:51 <kmc> Haskell *is* imperative, but not in the usual way.  it's more like we write functional programs that manipulate data which represent imperative programs
17:18:34 <fserb> monoidal: yep.
17:18:37 <kmc> anyway "a=3" isn't that; it's just giving a local name for an expression
17:18:44 <xplat> well, the imperative programs can be constructed lazily
17:18:45 <fserb> monoidal: I got stuck on Main
17:18:49 <monoidal> fserb: the first error in Main.hs can be corrected
17:18:54 <xplat> based on input data
17:19:10 <monoidal> by changing singnature. i've got error only on 261
17:19:12 <d-snp> so, if xor 1 3 doesn't work, do I need to convert them to some type?
17:19:14 <xplat> so if the data represents imperative programs, the imperative programs can be infinitely large
17:20:23 <xplat> this is the real main difference from 'the C programming language is functional'
17:20:28 <Cale> d-snp: yes
17:20:31 <Cale> :t xor
17:20:32 <lambdabot> forall a. (Bits a) => a -> a -> a
17:20:41 <d-snp> how do I make a Bits? :P
17:20:59 <xplat> @info Bits
17:20:59 <lambdabot> Bits
17:21:02 <Cale> d-snp: That's a typeclass constraint. It restricts which types 'a' you're allowed to use
17:21:19 <Cale> d-snp: (They must implement the methods of the Bits typeclass)
17:22:20 <fserb> monoidal, but at this point you need to convert the time delta to GLfloat right?
17:22:20 <Cale> That says "If a is any type and a is an instance of Bits, then xor takes two parameters of type a and produces a result of type a
17:22:23 <Cale> "
17:22:44 <d-snp> so how do I make an instance of Bits? are there converter functions or something?
17:22:52 <monoidal> fserb: yes, in Graphics.UI library there's time :: Data.StateVar.StateVar Double
17:23:01 <monoidal> fserb: don't know how to convert Double to GLfloat
17:23:08 <Cale> Well, what types of values are you working with first of all?
17:23:16 <d-snp> integers
17:23:22 <ari> d-snp: So, being that both of the parameters and the return type must be the same type, you'll just need to fix the type of one of them. For instance (xor 1 3) :: Integer
17:23:23 <d-snp> I just want to xor 2 integers
17:23:31 <Cale> d-snp: Integer is already an instance of Bits
17:23:38 <d-snp> oO
17:23:45 <Cale> So you just take your two values of type Integer and pass them to xor, and it'll work.
17:24:00 <Cale> But they must both be Integer. You can't have one of them be an Int, for example.
17:24:11 <d-snp> http://pastie.org/1173467 <--
17:24:13 <Cale> (They could both be Int, with an Int result)
17:24:15 <d-snp> I get that error..
17:24:19 <Cale> oh
17:24:26 <Eduard_Munteanu> d-snp: there isn't such a thing as "an object/whatever of type Bits", because Bits isn't a type.
17:24:30 <Cale> That means that the compiler can't figure out what type you want them to be
17:24:40 <Cale> So you need a type signature
17:24:46 <Cale> xor 1 3 :: Integer
17:24:49 <Cale> That'll work
17:24:50 <d-snp> ahh
17:24:57 <aavogt> > xor 1 3
17:24:58 <lambdabot>   Ambiguous type variable `a' in the constraint:
17:24:58 <lambdabot>    `Data.Bits.Bits a'
17:24:58 <lambdabot>      a...
17:25:04 <d-snp> cool it worked, thanks :)
17:25:16 <aavogt> usually there's defaulting to save you
17:25:30 <d-snp> so, Bits is more like an interface?
17:25:35 <Cale> Yeah
17:25:40 <xplat> it's too bad you can't eta-expand non-function values :)
17:25:44 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-Bits.html
17:25:50 <Eduard_Munteanu> d-snp: more like a category of types.
17:25:56 <aavogt> I guess it doesn't get applied in the right order for here
17:26:07 <Eduard_Munteanu> d-snp: e.g. types that have a bitwise representation.
17:26:10 <monoidal> fserb: I checked the type mismatch on 261 (newState <- update state dt) is the last compilation error
17:26:23 <aavogt> that is,      xor 1 3 :: (Num a, Bits a) => a -- which could be defaulted to Integer
17:26:25 <fserb> monoidal, I think I've fixed it
17:26:28 <xplat> Bits is like a characteristic some types have and some don't
17:26:41 <Cale> Well, literally a class of types that implement a given interface :)
17:26:42 <monoidal> fserb: how?
17:27:05 <fserb> monoidal:   let dt = realToFrac $ now - lastTime
17:27:23 <Cale> (but not an OO class, which would just be a type)
17:28:00 <monoidal> fserb: works! great
17:28:26 <d-snp> > chr (a !! (xor 1 3 :: Int))
17:28:27 <lambdabot>   Couldn't match expected type `[a]'
17:28:27 <lambdabot>         against inferred type `SimpleRef...
17:28:28 <d-snp> woops
17:28:38 <d-snp> > chr ([0,1,2,3] !! (xor 1 3 :: Int))
17:28:38 <lambdabot>   '\STX'
17:28:46 <d-snp> hey that's weird
17:28:51 <d-snp> I get an error there..
17:29:14 <zc00gii> ok, trying to find a precedence hack to test the length of a show x in a map
17:29:36 <fserb> monoidal: does it show anything but a white screen to you?
17:29:42 <zc00gii> basically, like, map ((== 500) (length (show $))) [1,2,3]
17:29:45 <zc00gii> or something like that
17:29:46 <monoidal> fserb: I can play
17:30:02 <fserb> monoidal: I see only a white screen, maybe my GL is broken somehow...
17:30:06 <Eduard_Munteanu> > let a = [1,2,3,4] in chr (a !! (xor 1 3 :: Int))
17:30:07 <lambdabot>   '\ETX'
17:30:11 <monoidal> fserb: used "cabal install" and then run from ~/.cabal/bin
17:30:18 <Eduard_Munteanu> d-snp: ^
17:30:29 <Eduard_Munteanu> d-snp: basically 'a' wasn't defined there.
17:30:49 <fserb> monoidal, Aha!
17:31:05 <d-snp> yes, but my app gives an error if I use a (defined as [0,1,2,3]) but not if I directly insert [0,1,2,3] there
17:31:21 <d-snp> it says mismatch between Int and Integer
17:31:55 <fserb> monoidal: any idea on how to send this patch?
17:31:57 <d-snp> does it convert literals to the desired type unless they're returned by another function or something?
17:32:08 <Eduard_Munteanu> d-snp: you need another signature
17:32:09 <monoidal> fserb: don't know what is the procedure
17:32:14 <Eduard_Munteanu> :t [1,2,3,4]
17:32:15 <lambdabot> forall t. (Num t) => [t]
17:32:37 <monoidal> fserb: never sent anything to hackage. One way would be to contact maintainer via mail
17:32:38 <Eduard_Munteanu> :t [1,2,3,4] :: [Int]
17:32:39 <lambdabot> [Int]
17:32:44 <d-snp> :t let a = [0,1,2,3,5,11]
17:32:45 <lambdabot> <no location info>: not an expression: `let a = [0,1,2,3,5,11]'
17:33:02 <monoidal> anyone know the policy on upgrading packages?
17:33:07 <hpc> :t let a = [1,2,3] in a
17:33:08 <lambdabot> forall t. (Num t) => [t]
17:33:53 <Eduard_Munteanu> :t (!!)
17:33:54 <lambdabot> forall a. [a] -> Int -> a
17:34:18 <d-snp> ok it works now with :: [Int] behind it
17:34:22 <ari> Monomorphism restriction, then
17:34:46 <ari> Wait, no
17:35:04 <monoidal> fserb: before releasing, would be good to fix the cabal dependency
17:35:23 <monoidal> fserb: and give some lower/upper bounds...
17:35:38 <ari> Just mixed up my ghci flags, I think I'd better go to sleep
17:36:33 <ddarius> We interrupt for a lesson in diplomacy: "Women need to have it pointed out that some men do not know where a Ballroom hold hand in the middle of the back should go; if he gets it wrong you should tell him as otherwise you cannot expect him to learn better."
17:37:14 <fserb> monoidal, I'll try to get some version and I'll email the maintainer and you.
17:37:44 <d-snp> ddarius: the lower the better right?
17:38:27 <hpc> ddarius: such an indignity could only be suffered by those lacking a towering pillar of hat!
17:42:18 <pickles> question: state monad or giant where clause? (In the where clause, some of the variables do depend on others, and it seems like it's clearer for the most part than a state monad would be. also leads to cleaner code too)
17:42:52 <dmwit> Both!
17:42:58 <dmwit> Neither!
17:43:12 <pickles> defining a new datatype? ;)
17:45:20 <pickles> it just seems like the where clause provides for cleaner code than a state monad would give, and it's clearer where things are coming from
17:45:29 <pickles> wondering what general opinions were
17:46:17 <zc00gii> aight, say I'm wanting to do something like this: (length (show 4357598567346565)) == 10
17:46:20 <monochrom> do what is clearest for you.
17:46:35 <Raynes> @pl \x -> (length (show x)) == 10
17:46:35 <lambdabot> (10 ==) . length . show
17:46:49 <zc00gii> but, I want to use a precedence hack like... ((== 10) (length $ show ) $) 4357598567346565
17:47:24 <zc00gii> orite, thanks
17:47:40 <pickles> monochrom: tru
17:54:57 <pickles> so at work we inherited a code base of 4.2 million lines of C++ & MS COM. I rewrote one of the functions in python to debug it and that implementation was half the size of my pseudocode for the original function.
17:55:23 <revenantphx> 4.2....million... lines of C++
17:55:32 <revenantphx> Imagine getting an STL error from that...
17:55:39 <pickles> and on the way home today the SUV in front of me changed lanes and i was pleasanylt surprised to see an old lady going the wrong way in traffic heading right towards me, going 50 mph
17:55:42 <pickles> tru stories
17:55:46 <monochrom> is like 42 lines of haskell, or 420 lines of python
17:55:47 <pickles> </off-topic)
17:55:50 <pickles> *>
17:56:01 <medfly`> hehe
17:56:23 <pickles> (i was going 50mph, not the old lady)
17:56:36 <revenantphx> so I found out, I'll be doing some projects with a CMU professor optimizing algorithms! (potentially)
17:56:41 <revenantphx> that'd be pretty fun ^_^
17:56:47 <revenantphx> It's in C though. (No flaming)
17:57:05 <monochrom> we just char you for c
17:57:16 <revenantphx> That doesn't make much sense.
17:57:22 <revenantphx> oh. Wait.
17:57:23 <revenantphx> I see.
17:57:23 <d-snp> :P
17:57:23 <monoidal> fserb: Great, got the mail. I've got the same changes
17:57:24 <revenantphx> Hah.
17:57:26 <revenantphx> Hahaha.
17:57:51 <pickles> ... im not getting the char for c joke. (must be fried)
17:57:58 <pickles> ah, cheer
17:57:59 <pickles> sry
17:58:10 <monochrom> \∩/
17:58:38 <fserb> monoidal: cool. :)
18:18:25 <etpace> what's the best way to round down to the nearest multiple of 0.05 for a double?
18:20:26 <JoeyA> > ((* 0.05) . realToFrac . floor . (/ 0.05)) 0.09
18:20:26 <lambdabot>   5.0e-2
18:20:35 <JoeyA> That's "a way", but I can't say it's the best.
18:20:36 <pickles> mul by 100 then floor and div by 100?
18:20:48 <etpace> thats not 0.05 pickles 
18:21:18 <pickles> tru
18:21:27 <pickles> sry, im rather tired
18:21:32 <JoeyA> Is there a floating point modulus in Haskell?
18:21:36 <oscillo> divide and multiply by 20 around the floor
18:22:13 <JoeyA> and is there a float to float version of floor (that is, doesn't return an integral)?
18:22:34 <oscillo> x100 /20 floor *20 /100
18:22:51 <oscillo> x = *, btw
18:22:56 <oscillo> =P
18:23:09 <pickles> @let x = *
18:23:09 <lambdabot>   Parse error: VarSym "*"
18:23:17 <pickles> @let x = (*)
18:23:18 <lambdabot>  Defined.
18:23:24 <pickles> ;)
18:23:39 <tommd> Is there a problem with "fromIntegral . floor"?
18:24:17 <JoeyA> ah, quot/rem
18:24:36 <JoeyA> > ((* 0.05) . fromIntegral . floor . (/ 0.05)) 0.09
18:24:36 <lambdabot>   5.0e-2
18:24:41 <JoeyA> > 0.05
18:24:42 <lambdabot>   5.0e-2
18:25:05 <JoeyA> err, quot/rem aren't it
18:25:27 <pickles> nite all
18:25:44 <tommd> Was that supposed to be an answer?
18:26:14 <JoeyA> fromIntegral works, too.  I didn't think to use it because I was thinking too much about floats.
18:26:27 <JoeyA> so no, I can't think of a problem with it.
18:40:02 <JoeyA> @let floorTo p = (*p) . fromIntegral . floor . (/p)
18:40:03 <lambdabot>  <local>:6:0:
18:40:03 <lambdabot>      Warning: Pattern match(es) are overlapped
18:40:03 <lambdabot>               In...
18:40:58 <Draconx|Laptop> fromIntegral . floor is not the same as a floating point floor operation.
18:41:26 <Draconx|Laptop> > fromIntegral . floor $ 1/0
18:41:27 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
18:41:29 <JoeyA> Then how do you do a floating point floor operation?
18:41:59 <Draconx|Laptop> with difficulty.
18:41:59 <rothwell> JoeyA: there's a mod' in Data.Fixed... not sure if you've solved that problem already
18:42:13 <rothwell> "generalisation of mod to any instance of Real"
18:42:38 <Cale> > fromIntegral . floor $ 1/0 :: Double
18:42:39 <lambdabot>   Infinity
18:42:50 <Draconx|Laptop> Cale, okay, now try 0/0
18:42:54 <Cale> heh
18:42:56 <Cale> > fromIntegral . floor $ 0/0 :: Double
18:42:57 <lambdabot>   -Infinity
18:43:11 <Cale> perfect
18:43:41 <Cale> Heh, apparently the floor of NaN is -Infinity ;)
18:44:46 <Draconx|Laptop> it actually depends on the underlying representation of the NaN.
18:44:58 <Cale> I'll have to ask James Anderson about what he thinks of that one ;)
18:45:08 <Draconx|Laptop> in particular, it depends on NaN's sign bit.
18:45:41 <Draconx|Laptop> so it might be -Infinity or Infinity, depending on what you did elsewhere.
18:51:02 <moosefish> cd ..
18:51:11 <moosefish> (whups. sorry)
18:51:12 <gwern> moosefish: $
18:54:00 <sshc> What should I use instead of old-locale?
18:55:16 <sshc> (I particularily want a TimeLocale so that I can use time's Data.Time.FormatTime.formatTime, which :: FormatTime t => TimeLocale -> String -> t -> String)
19:11:38 <absentia> is copilot any good?  and, what is it good for?
19:20:09 <JoeyA> Is [Int] -> Int an example of a monotype (because it has no type variables)?
19:20:27 <dolio> Yes.
19:21:08 <Philippa> ironically, a -> a would be too if it weren't for convention - forall a. a -> a isn't, though
19:21:18 <Philippa> (this sometimes matters when you're trying to work out how GHC thinks)
19:22:21 <JoeyA> absentia: copilot appeared in Hackage only a day or two ago, it seems.
19:23:17 <sshc> What should I use instead of old-locale?  I particularily want a TimeLocale so that I can use time's Data.Time.FormatTime.formatTime, which :: FormatTime t => TimeLocale -> String -> t -> String
19:23:47 <JoeyA> But a -> a is polymorphic, is it not?  Or is it considered monotype in contexts where it's bound by something?
19:25:12 <JoeyA> e.g. if you're defining a length :: [a] -> Int function, to all the elves living in that function, a is as concrete as anything.
19:25:39 <JoeyA> of course, on the outside, it's polymorphic.
19:25:54 <dolio> If you're being explicit about quantification, 'a -> a' might be a monotype with a free variable 'a'.
19:26:05 <dolio> Whereas 'forall a. a -> a' is a polytype.
19:26:52 <JoeyA> so would this be somewhat accurate?  An entire program has this tacked on implicitly:  forall Int Char Bool ... 
19:26:59 <dolio> Haskell types like 'a -> a' are implicitly quantified, though.
19:27:05 <JoeyA> On the outside of the program, it's polymorphic in Int, Char, Bool, etc.
19:27:34 <JoeyA> But once you're staring at the middle of the code (more formally, inside the forall), they're primitive types.
19:27:41 <dolio> But during type checking, you can get errors about 'a -> a' where 'a' is a "rigid type" or something like that, which is more complaining about a -> a in the monotype sense.
19:27:42 <JoeyA> right
19:27:44 <Philippa> you can squint and look at the module system that way if you really insist, and it's more like that in Coq or even in an ML-like system
19:28:26 <Philippa> but it's not something directly supported by the semantics
19:28:49 <Philippa> whereas as dolio says, monotype type variables actually show up in how GHC behaves nowadays
19:29:15 <JoeyA> That's an interesting way to think of it.  I was just thinking that the authors of "Principal type-schemes for functional programs" were simply not making it explicit that type variables have to be bound.
19:29:17 <Philippa> but I probably should've left that bit of confusion out anyway
19:29:30 <moosefish> portupgrade -ai
19:29:50 <Philippa> well, type-schemes do have their variables bound
19:30:10 <Philippa> the typechecker even has to keep track of which variables it's figured out where to bind yet
19:30:19 <JoeyA> maybe that paper's terminology does distinguish between primitives and type variables
19:30:20 <Philippa> (that is, which ones've been generalised)
19:30:26 <Philippa> probably
19:30:29 <JoeyA> Rather than calling them all the same thing when you're inside of a forall.
19:30:31 <ddarius> JoeyA: You -could- view it that way, but there's nothing wrong with constant types.
19:30:51 <ddarius> JoeyA: However, if you are interested in this perspective, you should see how lambdaProlog handles modules.
19:47:32 <kaeser> hmm...
19:47:36 <kaeser> hi :D
19:52:59 <EvanR> how do i do this!
19:53:36 <EvanR> f :: [a] -> Integer -> [a]
19:54:40 <EvanR> return the nth permutation (n < number of permutations)
19:54:58 <EvanR> arbitrary order
19:55:18 <luite> efficiently?
19:55:24 <EvanR> yes
19:55:30 <luite> I was afraid of that ;)
19:55:46 <EvanR> you can choose the order of permutations, does that help
20:00:02 <luite> EvanR: these operations are usually called ranking and unranking (you need unranking here), a quick google gives some results that seem to be relevant
20:00:37 <EvanR> good to know
20:10:11 <EvanR> luite: looks like i actually want a block cipher
20:11:36 <JoeyA> Following "Principal type-schemes for functional programs", if you take length :: forall a. [a] -> Int  and turn it into length :: [Char] -> Int, is that an example of "generic instantiation" as opposed to just "instantiation"?
20:12:32 <JoeyA> whereas if you have a type scheme forall a. a -> b and substituted the b with Char, that would be just "instantiation"?
20:13:26 <JoeyA> When I read it the first time, I think I had it backward because I thought instantiation was the kind I'm familiar with that acts on forall-bound variables.
20:48:50 <cbrad> Is there a way to change the way a Double value is displayed in ghci?
20:49:28 <cbrad> e.g. supply your on Show instance instead of the one defined in GHC.Float
20:56:10 <bos> cbrad: you do that via a newtype
20:57:19 <cbrad> thanks bos (btw bought your mercurial book via oreilly deal of the day last night :-))
20:57:28 <bos> cheers :-)
20:58:00 <cbrad> my motivation is to see if I can use ghci like R or matlab for mathematical computing
20:58:20 <bos> yes, you can, though it takes some work.
20:58:51 <bos> what do you want to do, statistical computing, linear algebra, ...?
20:59:09 <etpace> @hoogle [(k,v)] -> [(k,u)] -> [(k,(v,u))]
20:59:09 <lambdabot> Control.Arrow (&&&) :: Arrow a => a b c -> a b c' -> a b (c, c')
20:59:34 <cbrad> both stats & linear algebra for data/predictive analytics
21:00:09 <cbrad> i have written some stuff in haskell already, but usually fall back to R for experimentation as it is easier
21:00:11 <bos> there exists a statistics package already, with a grab-bag of distributions and functions.
21:00:26 <cbrad> yes i saw that :-)
21:00:32 <bos> R is definitely still easier for hacking on stuff, mostly because its library is so huge.
21:00:45 <Martty> whats R
21:00:54 <bos> although data frames are handy.
21:01:09 <cbrad> Martty: http://www.r-project.org/
21:01:10 <djahandarie> Martty, a programming language for statistical computing
21:01:21 <atude> statistical computing
21:01:41 <djahandarie> Hm I didn't know you were in this channel
21:01:46 <atude> I need to learn to compute, or just perform simple mathematical trick via the computer
21:01:55 <atude> djahandarie: I am :)
21:02:16 <cbrad> I am interested to see if I can make ghci easier to use as a mathematical interpreter so I don't need to fall back to R
21:02:42 <djahandarie> cbrad, what particular features do you feel are lacking?
21:02:44 <cbrad> configuring the display of scalar's and vectors of floating point values is one simple thing
21:03:15 <bos> oh, you want to reduce the precision with with Doubles are printed, that sort of thing?
21:03:22 <cbrad> e.g. matlab has short and long modes
21:03:26 <cbrad> bos: yes
21:03:37 <bos> that's actually somewhat trickier.
21:03:49 <bos> because ghci uses the default Show instance for the type.
21:03:57 <bos> so the display of Double is hard-wired
21:04:04 <cbrad> yes, hence my question of replacing it
21:04:10 <djahandarie> There is showsPrec though isn't there?
21:04:12 <bos> you'd really want a slightly more clever REPL in that case
21:04:16 <bos> djahandarie: unrelated
21:05:08 <atude> I really need some type of Guide to Mathematica so I can input expressions and graph them
21:05:15 <djahandarie> Oh yeah, totally unrelated, my bad
21:05:19 <atude> Has anyone have one of those?
21:05:22 <atude> does*
21:06:14 <cbrad> bos: I was hoping you wouldn't say that
21:06:16 <bos> atude: you'd probably want to ask in a mathematica channel
21:06:25 <atude> bos: it's tooo idle
21:07:49 <djahandarie> Someone should find out how to make CReal faster then everyone can just use that and be happy :)
21:08:07 <cbrad> I would like a maths environment that is good for hacking and bigger/performance intensive applications
21:08:16 <roconnor> djahandarie: what's slow about CReal?
21:08:22 <cbrad> was hoping GHCI / GHCI would do that
21:08:22 <roconnor> > showCReal 1000 pi
21:08:23 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
21:08:40 <roconnor> :)
21:08:42 <cbrad> maybe time to consider clojure & incanter
21:08:44 <djahandarie> > sum [1..100] :: CReal
21:08:45 <lambdabot>   5050.0
21:08:48 <djahandarie> > sum [1..1000] :: CReal
21:08:52 <lambdabot>   mueval-core: Time limit exceeded
21:08:57 <roconnor> :O
21:09:01 <roconnor> :D
21:09:27 <djahandarie> I think it by definition has sharing issues, I'm not sure though, haven't looked much into it
21:09:48 <roconnor> djahandarie: nah, it just doesn't like unbalanced terms
21:10:18 <roconnor> djahandarie: it approximates the last value values 2^1000 times more accurately than the first value
21:10:43 <cbrad> :bos thanks for your help
21:10:59 <djahandarie> roconnor, that sounds like something that could be fixed
21:11:24 <roconnor> not easily
21:13:06 <roconnor> djahandarie: given two real numbers to sum, how is it supposed to know how much accuracy to apply to each number?
21:13:21 <roconnor> djahandarie: so it just does both sized evenly
21:13:23 <djahandarie> Ah crud, looking at this code reminds me I never sent an email to augustss about a bug
21:13:34 <roconnor> djahandarie: was it a bug about cosine?
21:13:43 <djahandarie> No, about digitsToBits
21:14:08 <djahandarie> > showCReal (maxBound :: Int) pi
21:14:09 <lambdabot>   "*Exception: Negative exponent
21:14:29 <roconnor> @type splitAt
21:14:30 <lambdabot> forall a. Int -> [a] -> ([a], [a])
21:15:09 <EvanR> whats the trim function, remove leading / trailing whitespace
21:15:23 <bos> dropWhile isSpace
21:15:36 <djahandarie> > let digitsToBits :: Int -> Int; digitsToBits d = ceiling (fromIntegral d * (logBase 2.0 10.0 :: Double)) + 4; in digitsToBits (maxBound :: Int)
21:15:37 <lambdabot>   -6254109448592744444
21:15:41 <roconnor> > let {dc f z [] = z; dc f z l = let (l1,l2) = splitAt (length l `div` 2) l in f (dc f z l1) (dc f z l2) } in dc (+) 0 [1..1000]
21:15:43 <lambdabot>   *Exception: stack overflow
21:15:55 <roconnor> > let {dc f z [] = z; dc f z l = let (l1,l2) = splitAt (length l `div` 2) l in f (dc f z l1) (dc f z l2) } in dc (+) 0 [1..1000] :: CReal
21:15:57 <lambdabot>   *Exception: stack overflow
21:16:15 <roconnor> :(
21:16:26 * djahandarie is still parsing
21:16:35 <djahandarie> Ah
21:17:12 <roconnor> > let {dc f z [] = z; dc f z l = let (l1,l2) = splitAt (length l `div` 2) l in f (dc f z l1) (dc f z l2) } in dc (+) 0 [1..100] :: CReal
21:17:14 <lambdabot>   *Exception: stack overflow
21:17:33 <roconnor> > let {dc f z [] = z; dc f z l = let (l1,l2) = splitAt (length l `div` 2) l in f (dc f z l1) (dc f z l2) } in dc (+) 0 [1..10] :: CReal
21:17:36 <lambdabot>   *Exception: stack overflow
21:17:39 <djahandarie> lol
21:17:41 <roconnor> > let {dc f z [] = z; dc f z l = let (l1,l2) = splitAt (length l `div` 2) l in f (dc f z l1) (dc f z l2) } in dc (+) 0 [1..1] :: CReal
21:17:43 <lambdabot>   *Exception: stack overflow
21:17:50 <roconnor> oh
21:17:52 <djahandarie> (Should have been obvious by now)
21:18:00 <Pseudonym> Oh, Joseph Kruskal died.  I didn't know that.
21:18:10 <roconnor> > let {dc f z [] = z; dc f z [x] = x; dc f z l = let (l1,l2) = splitAt (length l `div` 2) l in f (dc f z l1) (dc f z l2) } in dc (+) 0 [1..10] :: CReal
21:18:11 <lambdabot>   55.0
21:18:16 <roconnor> > let {dc f z [] = z; dc f z [x] = x; dc f z l = let (l1,l2) = splitAt (length l `div` 2) l in f (dc f z l1) (dc f z l2) } in dc (+) 0 [1..1000] :: CReal
21:18:20 <lambdabot>   mueval-core: Time limit exceeded
21:18:22 <roconnor> damn
21:19:10 <djahandarie> Try using that with -O2
21:21:10 <djahandarie> (An O(1) length that doesn't force anything would be nice in times like these)
21:21:33 <kaeser> how do I handle this code? http://alturl.com/vct89
21:21:50 <djahandarie> Err no one click on that link
21:21:51 <djahandarie> @ops
21:21:51 <lambdabot> Maybe you meant: docs oeis pl
21:21:54 <djahandarie> God damn
21:21:56 <djahandarie> @where ops
21:21:56 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
21:22:10 <kaeser> djahandarie, haha
21:22:28 <kaeser> djahandarie, the volume was high enough?
21:23:08 <djahandarie> No, I have flashblock so nothing really happened at all, thankfully
21:23:23 <kaeser> liar
21:29:07 <EvanR> what is bitwise xor?
21:29:17 <ddarius> @hoogle xor
21:29:17 <lambdabot> Data.Bits xor :: Bits a => a -> a -> a
21:29:19 <djahandarie> xor
21:29:20 <djahandarie> Damn
21:29:36 <ddarius> Haskell's sneaky like that.
21:30:09 <tommd> Haskell is sneaker (or, at least GHC)
21:30:14 <tommd> sneaky
21:30:37 <EvanR> its also a sneaker
21:30:52 <tommd> The RULES pragma makes it sneaky
21:37:07 <byorgey> > 5 `xor` 7
21:37:08 <lambdabot>   Ambiguous type variable `a' in the constraint:
21:37:08 <lambdabot>    `Data.Bits.Bits a'
21:37:08 <lambdabot>      a...
21:37:13 <byorgey> > 5 `xor` 7 :: Integer
21:37:14 <lambdabot>   2
21:38:10 <Jonno_FTW> bitwise xor is exclusive or
21:38:21 <Jonno_FTW> it returns when when the 2 bits are different
21:38:27 <Jonno_FTW> *one when
21:39:16 <Jonno_FTW> > 1 `xor` 1
21:39:17 <lambdabot>   Ambiguous type variable `a' in the constraint:
21:39:17 <lambdabot>    `Data.Bits.Bits a'
21:39:17 <lambdabot>      a...
21:39:23 <Jonno_FTW> > 1 `xor` 1 :: Integer
21:39:23 <lambdabot>   0
21:39:27 <Jonno_FTW> > 1 `xor` 0 :: Integer
21:39:27 <lambdabot>   1
21:39:48 <tommd> What is the SC:go0 rule?
21:39:59 <tommd> SC... humm...
21:40:53 <ezyang> We need a name for monads that satisfy the monad tree modulo tree equivalence. i.e. every nondeterministic monad ever. 
21:41:31 <Rotaerk> call em gonads
21:41:58 <EvanR> hahahahaha
21:42:07 <ezyang> \ldots 
21:49:35 <binilt> How do I get a qualified import work in ghci? For instance, in http://book.realworldhaskell.org/read/barcode-recognition.html of RWH they use M.empty, M.singleton etc in ghci. I am sure the book would have discussed it earlier, but I can find the relevant pages.
21:50:01 <binilt> *can't*
21:50:26 <Jonno_FTW> could you write it into a .hs file then load it?
21:52:14 <binilt> @Jonno_FWT Yes I can. Is that the recommended approach?
21:52:14 <lambdabot> Unknown command, try @list
21:52:26 <binilt> Jonno_FWT Yes I can. Is that the recommended approach?
21:52:44 <Jonno_FTW> umm
21:53:25 <Jonno_FTW> It doesn't look like you can
21:53:32 <Jonno_FTW> do it from the prompt
21:54:38 <binilt> What did you mean by "do it from the prompt"?
21:55:14 <Gracenotes> > 27%300
21:55:15 <lambdabot>   9 % 100
21:55:36 <EvanR> 27
21:56:53 <Gracenotes> > (28%380, 28/380)
21:56:54 <lambdabot>   (7 % 95,7.368421052631578e-2)
21:57:08 <Gracenotes> > 28/380 :: CReal
21:57:09 <lambdabot>   0.0736842105263157894736842105263157894737
21:57:17 <EvanR> someone should really fix the bot
21:57:24 <EvanR> it doesnt know % from /
21:57:25 <Gracenotes> bot broken?
21:57:39 <EvanR> (in C)
21:57:59 <Gracenotes> % is a pretty rational name for what it does
21:58:09 <ezyang> That seems fairly normal... 
21:58:20 <ezyang> We djust don't use % for modulo :-) 
21:58:52 <EvanR> heres a weird thing i just ran into
21:59:21 <Jonno_FTW> binilt: you can't go ghci>:m qualified Data.ByteString.Lazy as BS
21:59:48 <EvanR> hrm
22:00:24 <binilt> Jonno_FTW: yes, I tried that and the :m command does not support such a syntax
22:00:47 <binilt> I am curious how the RWH guys seem to have done it, though.
22:01:09 <Jonno_FTW> miracles
22:01:17 <Jonno_FTW> have you checked the comments on RWH?
22:01:59 <binilt> Yes, I did check the comments
22:04:34 <Jonno_FTW> got a link for the page?
22:05:32 <binilt> BTW, there seems to be an open case for this http://hackage.haskell.org/trac/ghc/ticket/2362
22:05:41 <binilt> well, "closed case", I mean
22:06:21 <binilt> See http://book.realworldhaskell.org/read/barcode-recognition.html. The relevant section is titled "Life without arrays or hashtables"
22:09:06 <augur> ski! <3
22:14:41 <ezyang> Hmm. I wonder if built-in laziness is less expressive than explicitly managed laziness with thunks. 
22:15:02 <ezyang> Maybe that's only true in a language that admits side-effects or something. 
22:20:58 <EvanR> how about this idea, anti hash
22:21:19 <EvanR> it takes input, and outputs something decidedly non random, but also not related to the input
22:21:37 <EvanR> 0 -> aaaa, 1 -> 9494
22:21:57 <EvanR> 2 -> lolo
22:25:11 <QtPlatypus> EvanR: But longer then the source?
22:25:22 <EvanR> fixed length
22:25:59 <EvanR> input any length
22:29:17 <lament> i totally lost my faith in haskell just now
22:29:22 <lament> Prelude> sum [1..1000000]
22:29:22 <lament> *** Exception: stack overflow
22:29:27 <EvanR> haha
22:29:53 <EvanR> > sum [1..1000000]
22:29:55 <lambdabot>   *Exception: stack overflow
22:30:10 <lament> why would sum ever do that
22:30:15 <EvanR> > (1+1000000)/2
22:30:16 <lambdabot>   500000.5
22:30:21 <EvanR> oops
22:30:46 <EvanR> lambdabot: because the algorithm uses laziness unnecessarily
22:31:12 <EvanR> > foldl' (+) 0 [1..1000000]
22:31:13 <lambdabot>   500000500000
22:31:25 <EvanR> lament: 
22:32:10 <lament> never heard of foldl'
22:32:19 <EvanR> foldr foldl foldl', gotta know em
22:33:25 <sbahra> @src sum
22:33:25 <lambdabot> sum = foldl (+) 0
22:33:34 <tommd> @src sum'
22:33:34 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:33:42 <tommd> oh, keep forgetting that never made it into base
23:30:07 <evmar> hi, i'm trying to insert a bunch of stuff in a Data.HashTable with bytestring keys and the profiler tells me my hash function is slow
23:30:24 <evmar> i was surprised there wasn't an obvious hash function available
23:31:02 <evmar> i found some scary looking hash key code in http://www.haskell.org/haskellwiki/Shootout/Knucleotide#Custom_HashTable_.2B_ByteStrings
23:31:10 <evmar> but i was wondering if anyone had some better pointers
23:33:55 <sm> evening all
23:34:20 <ehamberg> g'morning, sm.
23:34:41 <lpsmith> uhh
23:34:41 <sm> can haddock or something else give "haddock coverage" stats for some code ?
23:35:07 <lpsmith> anybody here use attoparsec?
23:36:39 <m3ga> lpsmith: just playing with it myself
23:37:49 <lpsmith> oh,  I noticed an... unexpected behavior
23:38:06 <lpsmith> I was wondering if it's a bug or a feature
23:38:29 <lpsmith> m3ga, in a minute here I'll have it distilled down to something concrete
23:38:40 <lpsmith> err, something simple, rather
23:39:51 <lpsmith> argh
23:39:57 <lpsmith> ghci needs a serious overhaul
23:40:04 <Axman6> hmm, i don't like this... this program has runtimes from 30-50 seconds with the same input
23:40:14 <Axman6> how on earth am i supposed to tell if mine's faster :(
23:40:37 <aristid> Axman6: run it 500 times and compare the average :)
23:40:41 <m3ga> Axman6: guess?
23:40:44 <Axman6> heh
23:40:46 <m3ga> :-)
23:41:02 <Axman6> i think mine should be faster, but my results are pretty random
23:41:32 <gamefreak264> Any pdf recomendatios for a Haskell newcomer?
23:41:50 <Axman6> what do you need a pdf for?
23:41:55 <gamefreak264> Reading?
23:42:06 <gamefreak264> I guess a HTML page would be nice, too
23:42:10 <Axman6> well, do you want a tutorial? or a paper on a certain topic?
23:42:15 <Axman6> @where lyah
23:42:15 <lambdabot> http://www.learnyouahaskell.com/
23:42:19 <Axman6> @where rwh
23:42:19 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
23:43:12 <lpsmith> Ok
23:43:14 <Axman6> the first one is a very good introduction to haskell, you should start with it
23:43:32 <Axman6> excellent, running these two programs a few times seems to shoe mine's a little faster
23:43:44 <etpace> > "hello20100609there" =~ "201\\d\\d\\d\\d\\d" :: String
23:43:45 <lambdabot>   ""
23:43:50 <etpace> mm
23:44:00 <Axman6> though, i think i've ruined the metric bos was after, having the shortest pidigits entry
23:44:12 <etpace> > "hello20100609there" =~ "201\d\d\d\d\d" :: String
23:44:12 <lambdabot>   <no location info>:
23:44:13 <lambdabot>      lexical error in string/character literal at chara...
23:44:13 <lpsmith> parse (string "ab" <|> string "c") "c" returns a "Partial" continuation instead of a "Done" result
23:45:15 <lpsmith> that's rather inconvenient if I have nothing more to feed the parser
23:45:20 <aristid> lpsmith: and if you pass "ab"?
23:45:35 <lpsmith> aristid, I get a Done result
23:46:14 <lpsmith> the problem is that string "ab" expects at least two characters in the string,  since it doesn't have that it returns a continuation asking for more
23:47:02 <Axman6> lpsmith: swap the order of string "ab" and string "c"?
23:47:30 <lpsmith> Axman,  that occurred to me
23:47:35 <lpsmith> actually I'm doing this
23:48:03 <lpsmith> optNewLine = string "\r\n" <|> string "\n" <|> string ""
23:48:08 <Axman6> gamefreak264: if you have any questions, this is the best place to get them answered
23:48:18 <gamefreak264> Axman6:  Thanks
23:48:32 <aristid> lpsmith: wait, attoparsec expects both sides to desire the same length?
23:48:33 <gamefreak264> I'm going to be devling into various tutorials and documentation for a while
23:48:46 <gamefreak264> You won't be hearing much from me
23:48:52 <lpsmith> if I do   optNewLine = string "\n" <|> string "\r\n" <|> string ""
23:48:54 <gamefreak264> *delving
23:48:55 <Axman6> that's a shame
23:49:31 <Axman6> bleh, i totally need to start using criterion for this
23:49:43 <gamefreak264> Oh and thanks for the links, Axman6 
23:49:54 <lpsmith> that works if I have a dos-style newline at the end of the file,  or a unix-style newline,  but gets tricky if the newline is missing altogether
23:50:37 <lpsmith> As in, that fix doesn't work.
23:51:30 <lpsmith> hmm
23:51:50 <lpsmith> it does appear as though I can do this though
23:52:14 <lpsmith> let (Partial k) = parse (string "ab" <|> string "c") "c" in k ""
23:52:37 <lpsmith> that'll return the string "c" as a parsed result if I pass the resulting continuation the empty string
23:53:04 <lpsmith> I don't like that
23:53:26 <lpsmith> maybe it's ok,  but I don't like it much
23:53:31 <aristid> lpsmith: it may be a bug
23:53:55 <aristid> lpsmith: there must be a way to do this properly, and if it doesn't exist, that is a bug
23:55:24 <lpsmith> yeah,  I'll have to email bos about it
23:55:51 <aristid> Partial (ByteString -> Result r)	
23:55:51 <aristid> Supply this continuation with more input so that the parser can resume. To indicate that no more input is available, use an empty string.
23:56:02 <copumpkin> ddarius, dolio : The Man Hath Spoken :) http://hackage.haskell.org/trac/ghc/ticket/3927#comment:8
23:56:06 <aristid> lpsmith: pass an empty string at the end, and see if that works :)
23:56:19 <lpsmith> aristid, yeah, that's what I'm doing :)
23:56:34 <lpsmith> well, one of the ways to make it work
23:56:34 <aristid> lpsmith: but that still smells fishy
23:56:53 <lpsmith> yeah
23:57:00 <lpsmith> I agree
23:57:02 <etpace> how do I use \d with Text.Regex.Posix?
23:57:27 <etpace> \d and \\d do not work
