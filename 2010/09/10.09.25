00:04:37 <jamy> HELLO PEOPLE! WAKEUP!
00:05:18 <jamy> !$@@#$#%$%^&%*&^()&)_@$@#$@#^#$#@%^$%^$%*()
00:06:03 <Ke> didn't L4 only support about 1GB of memory for now
00:06:51 <Tomsik> "Any sufficiently advanced technology is indistinguishable from magic."
00:06:59 <Tomsik> I just thought, aren't we there already?
00:07:01 <Ke> well at most depending on the implementation
00:10:19 <jamy> Ke: i seriously dont know, but its not problem 
00:10:22 <Ke> also the number of processess was indistinguishable from 0
00:11:14 <Ke> not sure though, I guess L4 wanted you to do some of that stuff in userspace, no idea how you are supposed to manage memory from userspace
00:13:36 <jamy> in this kernel make seriously things. If you dont know 
00:24:39 <jamy> kmc: are you here?
00:25:27 <kmc> got to go soon
00:25:36 <objorn> I am receiving a parse error from the "Learn you a Haskell" tutorial: http://hpaste.org/40107
00:26:00 <kmc> objorn, you can't just type "x = y" at the top level in ghci
00:26:07 <kmc> it probably intends you to type it in a file, then load that to ghci
00:26:13 <kmc> you can do "let x = y" in ghci and it's sort of the same thing
00:27:06 <objorn> Oh right! I forgot about that.
00:34:53 <ddarius> Ke: You should read about exokernels, Xok in particular.
00:35:51 <avenge> Whoa, just happened to see that.  I wrote xok.
00:36:22 <avenge> How did it come up?
00:38:45 <lantti> I guess it was this:
00:38:48 <lantti> 10:10 < Ke> not sure though, I guess L4 wanted you to do some of that stuff in  userspace, no idea how you are supposed to manage memory from  userspace
00:39:19 <avenge> Yup, we definitely managed memory from userspace in xok.
00:39:40 <avenge> Even more so in the previous exokernel, Aegis, which Dawson Engler wrote for MIPS, because MIPS has a software-managed TLB.
00:44:04 <avenge> Anyway, totally random to see a kernel I wrote 15 years ago get mentioned in a functional programing IRC channel...
00:46:03 <jamy> if you interesting to join to develop new os on l4, than wellcome to http://sourceforge.net/projects/bel4ka
00:46:54 <patch-tag> what value would return False for isNaN ?
00:48:58 <kmc> > isNan 3
00:48:58 <lambdabot>   Not in scope: `isNan'
00:49:02 <kmc> > isNaN 3
00:49:03 <lambdabot>   False
00:50:05 <patch-tag> sorry, I meant "True" :)
00:50:29 <kmc> > let a = 0/0 in isNaN a
00:50:30 <lambdabot>   True
00:50:51 <kmc> 1/0 and (-1)/0 are not NaN, they are ±Infinity
00:51:00 <kmc> but indeterminite stuff like 0/0 is NaN
00:51:13 <kmc> > let a = 0/0 in a == a
00:51:14 <lambdabot>   False
00:51:36 <kmc> floating-point is really a terrible data type; (==) isn't even reflexive
00:53:12 <patch-tag> thanks kmc
00:55:12 <patch-tag> the singularity in z = x/y is NaN
01:05:15 <patch-tag> is there some library function to test if a float is "reasonable"? (not NaN, not any of the infinities, etc)
01:08:53 <Jafet> patch-tag: it's in C99, so it must be wrong!
01:11:42 <mornfall> I'd sort of expect a > -inf && a < inf to work.
01:20:59 <Baughn> mornfall: Does it?
01:22:08 <mornfall> No idea.
01:22:23 <Baughn> @let inf = 1 / 0
01:22:24 <lambdabot>  Defined.
01:22:32 <Baughn> @let ninf = -1 / 0
01:22:33 <lambdabot>  Defined.
01:22:37 <Baughn> > (inf,ninf)
01:22:38 <lambdabot>   (Infinity,-Infinity)
01:22:52 <Baughn> @check \x -> x > ninf && x < inf
01:22:52 <lambdabot>   Not in scope: `ninf'Not in scope: `inf'
01:23:03 <Baughn> @check \x -> x > (-1/0) && x < (1/0)
01:23:04 <lambdabot>   "OK, passed 500 tests."
01:23:10 <Jafet> > Infinity
01:23:11 <lambdabot>   Not in scope: data constructor `Infinity'
01:23:17 <Baughn> > (0/0)
01:23:18 <lambdabot>   NaN
01:23:27 <Baughn> > (0/0) > inf || (0/0) < inf
01:23:28 <lambdabot>   False
01:23:31 <Jafet> Bah, no type aware Double
01:23:55 * hackagebot sample-frame 0.0.2 - Handling of samples in an (audio) signal  http://hackage.haskell.org/package/sample-frame-0.0.2 (HenningThielemann)
01:32:58 * hackagebot sample-frame-np 0.0.2.1 - Orphan instances for types from sample-frame and numericprelude  http://hackage.haskell.org/package/sample-frame-np-0.0.2.1 (HenningThielemann)
01:41:00 * hackagebot synthesizer-core 0.4.0.2 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.4.0.2 (HenningThielemann)
01:44:01 * hackagebot bidirectionalization-combined 0.1 - Prototype Implementation of Combining Syntatic and Semantic Bidirectionalization (ICFP'10)  http://hackage.haskell.org/package/bidirectionalization-combined-0.1 (JoachimBreitner)
02:09:25 <kmc> @. elite nixon
02:09:26 <lambdabot> t|-|E chiNEse USe Two BrUz|-| $Tr0xEz 7o WRI+e TH3 worD 'CrizI$.' oN3 8RUsH 5+r0xe zTandz0rz phoR d4NGeR; +h3 07|-|3r FoR 0pPOR+uni7y. in 4 crIsiz, b3 4\/\/ArE OF +h3 DAnGer - 8ut R3C09NizE THE
02:09:26 <lambdabot> 0ppOrTuNi+y.
02:12:28 <kmc> @. elite nixon
02:12:28 <lambdabot> PoLITiCS \/\/0ULd B3 4 |-|3L1uV4 gooD BUsIness if iT weReN'T 4 7H3 90Dda/\/\nED p3Opl3.
02:26:42 <lantti> 3
02:31:37 <ManateeLazyCat> Hi all. :)
02:41:24 <tomberek> the standard ordered pair is (a,b)... how about an unordered pair? newtype Unordered a = Unordered (a,a)  ?
02:45:23 <manateeUser> Hi all. :)
02:45:59 <vanadium> hi
02:47:01 <manateeUser> Today I am unlucky.
02:47:03 <illissius_> tomberek: that's still ordered, the difference is that the types need to be the same (dunno whether the bug is in the name or the code ;)
02:48:04 <kmc> an unordered pair would probably need smart constructors
02:48:20 <illissius_> also you could say data Pair a = Pair a a, which might be simpler.
02:48:38 <kmc> the newtype is useful iff you want efficient conversion between ordered and unordered pairs
02:49:07 <illissius_> ah, good point
02:49:49 <kmc> you can make «data U a = MkU a a» such that «(MkU a b == MkU b a) = True», but if you expose MkU then code can still distinguish the two
03:02:52 <tomberek> illissius_ then what's the proper way?
03:04:22 <illissius_> tomberek: meaning you do actually want unordered pairs, and not just pairs whose elements have the same type?
03:04:55 <tomberek> yeah, unordered pairs,, or is that usually not worth the hassle?
03:05:09 <illissius_> I have no idea
03:05:21 <illissius_> depends what you need it for
03:05:50 <illissius_> it would be sort of Set-like, except restricted to 2 elements
03:06:54 <illissius_> you'd hide the constructor for UnorderedPair and export a smart constructor instead, and then rather than fst and snd you'd have things like isElemOf, I guess
03:07:10 <tomberek> yep a 2-set,, where it always has exactly 2 members
03:07:17 <tomberek> almost
03:07:33 <tomberek> {a,a} can be an unordered pair, but not a 2-set
03:08:12 <illissius_> hmm, multiset then :) (or bag, or whatever the name is)
03:09:57 <tomberek> yeah,, these things should be primitives
03:15:38 <Mitar> how can an instance of a data type which has a field which is a function?
03:16:50 <vanadium> Your sentence no predicate
03:17:29 <tensorpudding> vanadium: your rebuttal no verb?
03:17:42 <vanadium> I in kind.
03:21:54 <illissius_> * -> *?
03:23:51 <Mitar> ups ;-)
03:24:09 <Mitar> how can I make a show instance of a data type which has a field which is a function
03:24:42 <vanadium> You can write the instance yourself and just ignore that one field
03:24:46 <Mitar> i can do instance Show (Foo -> Bar) where show _ = "nameOfFunction"
03:24:55 <Mitar> but this is ugly
03:25:16 <Mitar> aha, ok, true, i do not need to derive main data type automatically
03:25:17 <Mitar> true
03:26:03 <Mitar> is there a find/replace standard function for lists?
03:26:37 <vanadium> not sure
03:26:41 <tomberek> Mitar: perhaps you show some example input output?
03:27:14 <vanadium> > let f 'o' = 'y'; f x = x in map f "foobar"
03:27:15 <lambdabot>   "fyybar"
03:27:48 <geheimdienst> > let f 'o' = 'y'; f = id in map f "foobar"
03:27:49 <lambdabot>   Equations for `f' have different numbers of arguments
03:27:49 <lambdabot>    <interactive>:1:4-...
03:29:20 <ski> Mitar : why do you want to `show' a data-structure including a function ?
03:30:37 <ski> > do o <- "foobar"; if o == 'o' then "OO" else [o]
03:30:38 <lambdabot>   "fOOOObar"
03:31:04 <vanadium> now do "oo" -> "O"
03:35:25 <Mitar> if i got an exception i print out state of the statet monad which got an exception
03:35:35 <ski> > unfoldr (\s -> case "oo" `stripPrefix` s of Just s -> Just ('O',s) ; Nothing -> case s of [] -> Nothing; c:s -> Just (c,s)) "foobar"
03:35:36 <lambdabot>   "fObar"
03:35:36 <Mitar> and in this state i have sometimes also stored a function
03:36:44 <ski> if you can serialize the function, then you could print that
03:36:56 <Mitar> i do not need so much information about it
03:37:08 <Mitar> just some simple info, name, or even nothing
03:37:12 <mreh> :t lift
03:37:13 <ski> otherwise, you could also possibly separate your state in two parts, of which one can be printed
03:37:13 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
03:37:16 <Mitar> (more important are other values/parameters)
03:38:37 <ski> Mitar : ok .. why do you need to define a `Show' instance, as opposed to just a `showMyState :: MyState -> String' or `printMyState :: MyState -> IO ()' operation ?
03:39:42 <ski> it is usually expected that `Show' instances convert values to valid haskell code (which could be read back into the same value)
03:40:08 <Mitar> just an easy way to print some debuging info
03:40:18 <Mitar> in most cases (monads I am using) state is normal data type
03:40:25 <Mitar> just in this instance i have some strange function in
03:40:32 <ski> ok, then i suggest not doing a `Show' instance (especially since you're to hand-write it anyway)
03:43:00 <Mitar> hmm
03:43:58 <Mitar> yes, but for other instances of my class (which uses statet) it is easier just to use show
03:44:20 <ski> what is your class ?
03:47:02 <Mitar> a class which tries to be something like OOP interface ;-)
03:47:11 <Mitar> so that it has some common functionality defined
03:47:18 <chrisdone> λ> res <- pasteAndRun "main = putStrLn \"hi!\"" "Haskell" True
03:47:18 <chrisdone> λ> res
03:47:18 <chrisdone> Just ("cZWS3PwC","hi!")
03:47:21 <Mitar> and one of those is using state for manipulating
03:47:23 <chrisdone> CodePad library ^_^
03:48:09 <chrisdone> not sure what namespace to put it under though
03:48:38 <chrisdone> I'm thinking Web.CodePad
03:48:43 <Tomsik> :t (::=)
03:48:44 <lambdabot> Not in scope: data constructor `::='
03:49:32 <Tomsik> Okay guys, what is the best way to do GUI in haskell?
03:49:42 <chrisdone> gtk2hs
03:49:49 <Tomsik> I'm looking at this Grapefruit, but docs don't seem too great
03:49:49 <chrisdone> next!
03:51:06 <spetrea> chrisdone, any online haskell compiler ?
03:52:33 <dom96> ideone or codepad.
03:54:12 <chrisdone> spetrea: yes
03:58:35 <spetrea> chrisdone, name ?
03:59:30 <chrisdone> codepad and ideone
04:00:51 <chrisdone> I was gonna do an ideone API because it's generally more responsive than codepad, but they use SOAP
04:01:12 <chrisdone> I'd rather parse CodePad with TagSoup
04:01:24 <mreh> are you allergic to SOAP?
04:01:55 <dom96> I wanted to create a ideone API too, but i couldn't find any non-GPL SOAP packages.
04:02:43 <chrisdone> http://hpaste.org/40109/simple_codepad_api
04:02:57 <vanadium> What is wrong with GPL for this?
04:03:31 <dom96> I wanted BSD.
04:04:32 <vanadium> It is compatible <:)
04:04:51 <mreh> I thought they were anything but
04:04:56 <chrisdone> compatible like foxes are compatible with chickens
04:05:18 <mreh> foxes mercifully kill their prey
04:05:44 <chrisdone> you can use them both but one engulfs the other in transport
04:05:45 <dom96> Are they? I thought they aren't.
04:07:03 <chrisdone> you can use them together. you just have to change everything to GPL if you're going to redistribute
04:07:35 <chrisdone> (together)
04:07:35 <dom96> yeah, i don't want to do that.
04:09:02 <mreh> hackage seems to embrace BSD more widely, but I may be biased
04:09:10 <mreh> do we have statistics?
04:10:04 <ppavelV6> BSD is much more liberal. For people trying to sell the whole idea of using haskell and libs in a work environment viral nature of GPL is the end of the show
04:10:21 <Mitar> how do i specify multiple extra-lib-dirs for cabal configuration?
04:10:36 <mreh> economically liberal :)
04:11:13 <ppavelV6> mreh: ok :) less limiting :)
04:14:32 <chrisdone> BSD3 is generally the preferred choice in the Haskell landscape
04:15:03 <ppavelV6> chrisdone: agree 
04:26:22 <atude> I think I figured out the hanoi tower problem
04:27:36 <spetrea> atude, nice
04:28:12 <atude> {T[n] >= T^2_[n-1] | n >= 0} right? :D
04:28:48 <atude> I drew it all out as if I was an animator, tried induction for 3, 5, 8, and 16
04:28:53 <atude> I seems to work for all of them
04:29:46 <spetrea> lol I've no idea what you solved and the set you just wrote, very ambigous
04:30:03 <c_wraith> towers of hanoi is a classic recursion exercise.
04:30:12 <c_wraith> That answer looks approximately correct
04:30:24 <c_wraith> I'm too tired to say if it's exactly correct :)
04:31:32 <c_wraith> to move n disks from peg 1 to peg 3, first move n-1 disks to peg 2, then move the biggest disk to peg 3, then move n-1 disks from peg 2 to peg 3.
04:32:01 <atude> I would be a genius long ago
04:32:12 <atude> I did that by only observation :p
04:34:02 <c_wraith> > let steps 1 = 1 ; steps n = 1 + 2 * steps (n-1) in steps 5
04:34:02 <lambdabot>   31
04:40:31 <atude> > let steps 1 = 1 ; steps n = 1 + 2 * steps (n-1) in steps 4
04:40:32 <lambdabot>   15
04:40:55 <co_dh> @src either
04:40:55 <lambdabot> either f _ (Left x)     =  f x
04:40:56 <lambdabot> either _ g (Right y)    =  g y
04:41:09 <co_dh> :t either
04:41:10 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
04:54:07 <Raghs> What are the libraries to use to generate a chart like http://stockcharts.com/h-sc/ui?s=SPY&p=D&b=5&g=5&id=p05007254056
04:54:43 <Raghs> i will use Finance-Quote-Yahoo to get the quotes
04:55:35 <atude> that cannot be right
04:55:45 <atude> > let steps 1 = 1 ; steps n = 1 + 2 * steps (n-1) in steps 4
04:55:46 <lambdabot>   15
04:59:24 <atude> I Get 16 steps
04:59:26 <atude> not 15
05:23:27 <osaunders> @hoogle sleep
05:23:27 <lambdabot> No results found
05:23:33 <osaunders> :(
05:24:05 <osaunders> Is there really no sleep function?
05:24:58 <kaol> @hoogle threadDelay
05:24:59 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
05:27:30 <osaunders> Thanks kaol, that works.
06:22:45 <sshc> What should I use instead of old-locale?  I particularily want a TimeLocale so that I can use time's Data.Time.FormatTime.formatTime, which :: FormatTime t => TimeLocale -> String -> t -> String
06:32:01 <osaunders> @pl x f g = do f; g
06:32:01 <lambdabot> (line 1, column 13):
06:32:01 <lambdabot> unexpected ";"
06:32:01 <lambdabot> expecting variable, "(", operator or end of input
06:32:59 <Baughn> sshc: "For new code, the new locale library is recommended", and never mind that no such thing exists.
06:34:11 <Baughn> sshc: Can't you use old-locale?
06:35:01 <osaunders> @pl x f g = (do f; g)
06:35:01 <lambdabot> (line 1, column 7):
06:35:01 <lambdabot> unexpected "="
06:35:02 <lambdabot> expecting variable, "(", operator or end of input
06:35:54 <Baughn> @. pl undo \f g -> do f; g
06:35:54 <lambdabot> (>>)
06:36:05 <Baughn> osaunders: There you go.
06:36:42 <osaunders> Ooh
06:36:45 <osaunders> ty
06:40:55 <Tomsik> :t undo
06:40:56 <lambdabot> Not in scope: `undo'
06:41:43 <Tomsik> @. pl undo \x y z -> x z y
06:41:43 <lambdabot> flip
06:41:47 <Tomsik> kewl
06:58:23 <Olathe> What do you think of this definition for a monad? A monad is what decides the semantics of a do block.
06:58:28 <aristid> Tomsik: why the undo?
06:58:34 <aristid> @undo \x y z -> x z y
06:58:35 <lambdabot> \ x y z -> x z y
06:58:43 <aristid> @pl \x y z -> x z y
06:58:43 <lambdabot> flip
06:59:03 <aristid> @. unpl pl \x y z -> x z y
06:59:03 <lambdabot> (\ a b c -> a c b)
07:13:47 <mm_freak> Olathe: i think that's too vague to be really helpful, especially with type errors
07:14:36 <Saizan> it's good at giving a concrete idea of what a monad does, if you've seen do-blocks before, it's not a definition by far though
07:16:43 <EvanR> ok
07:16:53 <EvanR> havent done this before
07:17:17 <mreh> newtype RandomGen g => Trans a = Trans (Rand g a) -- what's wrong with that?
07:17:40 <mreh> says g is not in scope
07:17:43 <mauke> the class constraint
07:19:03 <mreh> mauke: could you be more specific?
07:19:14 <mauke> what are you trying to do?
07:19:42 <mreh> make a newtype wrapper for the Monad Rand
07:20:04 * hackagebot augeas 0.3.0 - A Haskell FFI wrapper for the Augeas API  http://hackage.haskell.org/package/augeas-0.3.0 (JudeNagurney)
07:20:04 <mauke> newtype Trans g a = Trans (Rand g a)
07:20:05 <mreh> with a more future proof interface
07:21:16 <aristid> mreh: random-fu has the best randomness monad IMO
07:21:17 <sy_> *Learning me a Haskell
07:21:52 <mreh> aristid: never seen it before, thanks
07:22:10 <aristid> mreh: i've also written some extensions for it, in random-extras :)
07:22:52 <EvanR> in order to 'make a new monad' and implement some monad class like MonadFastCGI, should I use a new type like newtype App a = App (StateT AppState IO a) ?
07:23:38 <mreh> aristid: duly noted, looks good
07:24:44 <mreh> Could use it with Yampa, I've been upgrading its internals to a monadic interface
07:25:27 <aristid> mreh: what do you want to use it for?
07:25:58 <mreh> aristid: distributing random number generators around to the points of a signal function network
07:26:39 <atude> linear algebra?
07:27:12 <mreh> nope
07:27:39 <atude> don't lie to me
07:28:06 <bremner> you are a handsome dude
07:28:17 <atude> :)
07:29:31 <mreh> 0_o
07:41:19 <EvanR> wah
07:41:25 <EvanR> you can instance a type?
07:41:43 <EvanR> no need to newtype?
07:42:32 <roconnor> wow /reddit/r/programming comments are terrible
07:42:41 <roconnor> I should consider unsubscribing
07:42:55 <roconnor> specifically comments in http://www.reddit.com/r/programming/comments/dip0g/omega_language_of_the_future_lambda_the_ultimate/
07:43:04 <EvanR> hahaha
07:43:26 <Saizan> EvanR: instancing for a type synonym is the same as instancing for its definition
07:43:49 <EvanR> so its not a problem as long as that type in the definition doesnt already have an instance
07:44:09 <mreh> what is omega?
07:44:35 <EvanR> Saizan: by the way, is Maybe a type?
07:45:00 <Saizan> "I remember when i learned Lisp at school that different languages can be ranked by how expressional they are" <- _expressional_
07:45:24 <Saizan> EvanR: Maybe is not a type synonym if that's what you are asking
07:45:29 <EvanR> to what degree they support expressions
07:45:35 <mreh> English is hard, lets go coding
07:45:47 <mietek> Does anyone know how to use FTGL with HOpenGL?
07:45:52 <EvanR> cobol, php, C, ... in increasing order
07:46:17 <EvanR> Saizan: no, is it a type by itself. its a type of kind * -> * ? so i think of it as a type constructor
07:47:26 <EvanR> im not clear on the jargon 
07:47:29 <Saizan> EvanR: it is a type constructor, but "type" usually includes those, for types of kind * i've seen used the terms "proper type" or "concrete type"
07:47:37 <EvanR> ah
07:47:40 <Saizan> the jargon is a bit muddy here, unfortunately
07:48:05 <EvanR> because my type is of kind * -> * because it needs to implement a monad class
07:48:10 <mreh> type constructor vs. type constructor, two different things
07:48:15 <EvanR> so it looked weird calling it a type
07:49:03 <EvanR> its literally spelled out "type A = B C" seemed incomplete
07:49:14 * hackagebot nptools 0.3.0 - A collection of random tools  http://hackage.haskell.org/package/nptools-0.3.0 (NicolasPouillard)
07:49:29 <Saizan> for example "type constructor" is often applied to any type of kind that's not *, while it's be more coherent with "data-constructor" if it was only used for those types introduced by data or newtype which can't be reduced further or decomposed 
07:50:48 <babusri> In ghci, when I type pure 10, I get 10, :t pure 10 gives pure 10 :: (Num t, Applicative f) => f t, but when I type let x = pure 10, I get Ambiguous type variable `f' in the constraint: `Applicative f' arising from a use of `pure' at <interactive>:1:8-14, Probable fix: add a type signature that fixes these type variable(s).
07:50:53 <Saizan> EvanR: that's just eta reduction, like you can define "add x = (x+)" and have it be equivalent to a definition like "add x y = x + y" to a first approximation
07:51:20 <EvanR> would it break stuff to say
07:51:27 <EvanR> type A a = B C a
07:51:36 <EvanR> instance MonadFastCGI A where
07:51:46 <Saizan> babusri: in the first case ghci is forcing the f to be IO
07:52:46 <Saizan> babusri: in the latter case it won't, and then the monomorphism restriction kicks in and makes it want to resolve the polymorphism anyhow, which gives you that error because there's no hint on what f should be
07:53:11 <Saizan> babusri: it's probably best to :set -XNoMonomorphismRestriction
07:54:01 <Saizan> EvanR: i don't think that's allowed, since GHC wants type synonyms to appear fully applied in instance heads
07:54:09 <EvanR> oh
07:54:15 <Saizan> EvanR: and it won't bother discovering that it can eta-reduce A
07:54:49 <babusri> Saizan, thanks
07:57:03 <mreh> rec { ~(sf1', ~(b, c)) <- (sfTF' sf1) dt (a, c) } -- GHC doesn't like this
07:57:04 <Saizan> @where report
07:57:04 <lambdabot> http://www.haskell.org/onlinereport/
07:57:12 <mreh> i can't see anything wrong with it
07:57:24 <Saizan> for a clear description of the monomorphism restriction ^^^^
07:57:24 <mreh> I've enabled the RecursiveDo flag
07:57:53 <Saizan> mreh: don't you need a return?
07:58:18 <Saizan> rec { ~(sf1', ~(b, c)) <- (sfTF' sf1) dt (a, c); return ... }
07:58:26 <roconnor> mreh: which flag is for mdo and which flag is for rec?
07:58:28 <atude> C or Haskell for system programming..?
07:58:39 <mauke> C
07:58:43 <roconnor> I also forget the difference between mdo and rec
07:58:53 <atude> C or Haskell for Numberical Analysis?
07:59:04 <EvanR> fortran
07:59:06 <atude> no
07:59:15 <EvanR> matlab
07:59:18 <atude> ....
07:59:22 <atude> C or Haskell
07:59:27 <EvanR> neither
08:00:01 <mreh> roconnor: good call, DoRec is for rec :)
08:00:11 <roconnor> http://www.haskell.org/haskellwiki/MonadFix
08:00:43 <roconnor> mreh: how does rec work?
08:00:50 <roconnor> mreh:  is it a one line mdo?
08:02:46 <Cale> roconnor: It's multiline, it gives you a recursive group
08:03:07 <Cale> The translation into uses of mfix is a bit more direct than with the mdo notation.
08:07:43 <Cale> Though, there's a segmentation thing which still happens in order to break up recursive groups into minimal chunks and changes the meaning a bit.
08:08:19 <Cale> http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#id655032
08:08:25 <Cale> roconnor: ^^
08:14:40 <EvanR> why does this seem wrong
08:14:50 <EvanR> conn <- maybe dbConnect return maybeConn
08:14:54 <atude> because it is...
08:15:01 <dcoutts> benmachine: http://hackage.haskell.org/trac/hackage/ticket/742#comment:1
08:15:26 <dcoutts> EvanR: wrong order of args
08:15:51 <Cale> Um, it seems okay to me.
08:15:54 <Saizan> ?type maybe
08:15:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:16:08 <Cale> But, the use of do-notation here is excessive
08:16:26 <Cale> You can get away with let and fromMaybe
08:16:29 <Saizan> is it? dbConnect is presumably monadic
08:16:44 <Cale> oh, I see
08:16:47 <Cale> right, it would be :)
08:17:11 <Saizan> you'd need fromMaybeM
08:17:22 <Cale> No need for that :)
08:17:28 <EvanR> its too short
08:17:33 <Saizan> you can fmap return, i guess
08:17:34 <EvanR> too much going on!
08:17:50 <Saizan> EvanR: split it across several lines?:P
08:17:54 <EvanR> haha
08:18:03 <EvanR> is it hard to read?
08:18:12 <EvanR> i mean the return there would throw a C person
08:18:32 <EvanR> liftM ?
08:18:36 <EvanR> fmap?
08:18:37 <EvanR> :S
08:18:52 <Saizan> no, it's not hard to read
08:19:14 <Saizan> maybe use "pure" if you're feeling bad for C programmers :)
08:19:19 <EvanR> lol
08:19:53 <EvanR> :hoogle pure
08:19:57 <EvanR> hoogle pure
08:19:59 <EvanR> > hoogle pure
08:20:00 <lambdabot>   Not in scope: `hoogle'
08:20:10 <EvanR> game over
08:20:12 <Saizan> it's from Control.Applicative
08:20:31 <Saizan> it'll require an Applicative instance for your monad
08:20:43 <Cale> :t pure
08:20:44 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
08:20:59 <EvanR> ok screw that
08:21:34 <Cale> I wouldn't use it in conjunction with do-notation usually, unless I was also using lots of applicative notation.
08:21:35 <Tomsik> @unpl (:)
08:21:35 <lambdabot> (:)
08:21:52 <Tomsik> @unpl (.) (.) (.)
08:21:52 <lambdabot> (\ c e f i -> c (e f i))
08:22:16 <Cale> (\x xs -> x:xs)
08:23:16 <Tomsik> @unpl fix x
08:23:16 <lambdabot> fix x
08:23:19 <Cale> (But who would squander our precious natural lambda resources like that ;)
08:24:02 <Tomsik> Well, unless we'll have to invade other channels for more lambdas it seems okay to me
08:24:27 <EvanR> for the most part they arent using theirs
08:24:37 <EvanR> they are too bulky
08:24:46 <EvanR> lower quality lambdas
08:25:14 <Jafet> Are we at peak lambdas?
08:25:55 <Tomsik> I think Greece has plenty of them
08:28:07 <EvanR> we will conquer greece
08:29:32 <Tomsik> I don't know why they don't export them, would make them all rich
08:30:09 <Jafet> Waste disposal is a major complication
08:30:51 * Cale spent over $150 on magnets today :)
08:31:20 <Tomsik> 40$ is the most I ever spent on magnets :p
08:31:23 <Cale> (bought the large set from http://zenmagnets.com/)
08:33:59 <Tomsik> Hm.. little balls of magnetic properties
08:34:22 <Cale> They're surprisingly versatile
08:35:10 <hvr> selectByBitvec bs xs = [ x | (x, b) <- zip xs bs, b ]
08:35:12 <Jafet> unsafeForceField
08:35:23 <hvr> does anyone know, whether there's a better name for that?
08:35:31 <monochrom> composable magnet combinators
08:35:35 <Cale> http://www.youtube.com/watch?v=5m-St7Y2-C8 -- this construction is cool :)
08:35:36 <hvr> (or maybe something similiar already in the stdlib?)
08:36:00 <Tomsik> unsafeAtomicBomb
08:36:07 <Tomsik> it has side effects
08:36:33 <monochrom> there is no one around to observe side effects
08:38:00 <Cale> hvr: It's not... but the list comprehension is pretty clear
08:38:58 <benmachine> my friend bought some rare-earth magnets
08:39:09 <benmachine> then tried to make a hyperbolic football with them
08:39:13 <benmachine> it was pretty neat
08:40:59 <tmo_> gtk2hs question: why is this function giving a "No instance for (TextViewClas Widget) compiling error"?
08:41:13 <tmo_> savePageContents :: NotebookClass self => self -> IO ()
08:41:13 <tmo_> savePageContents self = do
08:41:13 <tmo_>     index <- notebookGetCurrentPage self
08:41:13 <tmo_>     sv    <- notebookGetNthPage self index
08:41:16 <tmo_>     sb    <- textViewGetBuffer (fromJust sv)
08:41:19 <tmo_>     return ()
08:41:20 <benmachine> tmo_: paaaastebin
08:41:32 <hvr> Cale: the same could be said about "filter pred xs = [ x | x <-xs, pred x ]" ;-)
08:41:52 <benmachine> :t filter pred
08:41:53 <lambdabot> [Bool] -> [Bool]
08:41:53 <Cale> hvr: sure
08:41:56 <benmachine> heh heh
08:41:56 <tmo_> benmachine: Sorry, I just thought that the code was short enough.
08:42:15 <Cale> It turned out to be short enough. I was scared for a minute there :)
08:42:16 <benmachine> tmo_: yeah, it's not too bad, but the usual rule of thumb is >3 lines -> pastebin
08:43:46 <Cale> notebookGetNthPage produces a Maybe Widget
08:44:06 <Cale> But Widget isn't an instance of TextViewClass
08:44:24 <tmo_> Cale: hence the (fromJust sv), unless I'm missing a caveat.
08:44:52 <Cale> Nope, that just deals with the possibility that there's no nth page
08:45:08 <Cale> You also need to castToTextView
08:45:51 <tmo_> Hoogle says that the type signature for fromJust is Maybe a -> a, which appears to be what I want (but isn't). What function should I use to remove the Maybe monad?
08:46:09 <Cale> case sv of
08:46:15 <tmo_> Thanks
08:46:16 <Cale>   Nothing -> ... handle failure ...
08:46:25 <Cale>   Just v -> ... use v somehow ...
08:46:50 <Twey> tmo_: Alternatively, ‘maybe’ or ‘fromMaybe’
08:46:54 <Twey> :t maybe
08:46:55 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
08:47:17 <Cale> (The fact that it's a monad isn't particularly important for you unless you're chaining together a bunch of Maybe-producing computations)
08:47:27 <Twey> maybe (default value, which may include ‘error’ or similar) (\v -> use v somehow) sv
08:48:03 <Twey> fromMaybe is just ‘maybe’ with ‘id’ as the ‘use v somehow’ function, so if it's a Just you get the value back directly
08:48:53 <Tomsik> you can use >>=
08:55:58 <Olathe> Saizan: Ahh, OK. Thanks :)
08:56:07 <Olathe> mm_freak: What do you mean by type errors?
08:56:19 <Olathe> mm_freak: As far as the monads go.
09:00:59 <tmo_> Okay, I modified the code as following to handle the Maybe monad, but I'm getting a "couldn't match excepted type 'TextView' against inferred type 'm a'" error.
09:01:03 <tmo_> http://pastebin.com/ERGP0iVc (for reference)
09:02:19 <benmachine> tmo_: what's the type of castToTextView?
09:02:35 <tmo_> castToTextView :: GObjectClass obj => obj -> TextView
09:02:49 <benmachine> right
09:02:54 <benmachine> but you're using it in a <- bind
09:03:07 <benmachine> in an IO do-block
09:03:18 <monochrom> let sv = castToTextView svN
09:03:18 <tmo_> So I want to wrap it in an IO monad then
09:03:27 <benmachine> no you want to do what monochrom says
09:03:28 <tmo_> Or what monochrom said
09:04:06 <tmo_> (Sorry, but I'm somewhat unfamiliar with monads)
09:04:21 <monochrom> TypeDirected->MeaningBindOrLet
09:04:21 <tmo_> (beyond basic IO)
09:04:54 <benmachine> tmo_: not everything is monads :P
09:05:03 <tmo_> True enough :P
09:05:27 <benmachine> understanding types is much more important than understanding monads
09:05:52 <benmachine> (well, is a superset of, pretty much, but anyway)
09:06:01 <monochrom> if you are type-minded, monads and stuff are trivial
09:06:01 <keseldude> still, read about monads. they're not scary, and you won't feel uncomfortable when you use IO
09:06:25 <tmo_> I shall :)
09:06:42 <dcoutts_> benmachine: did you get my message about the cabal ticket you filed?
09:06:51 <benmachine> dcoutts_: yeah, and an email notification
09:07:03 <benmachine> dcoutts_: I've got the markdown open in vim, just wondering how to proceed :)
09:07:14 <benmachine> (thinking about what kind of note where would be useful)
09:07:37 <monochrom> enter "hello world"
09:08:04 <dcoutts_> benmachine: ok great
09:08:18 <dcoutts_> benmachine: perhaps something where it describes the build-depends
09:08:52 <benmachine> dcoutts_: yeah, but I'm thinking cabal-version shoudl also have something about how it can change behaviour
09:08:56 <benmachine> more generally
09:09:11 <dcoutts_> benmachine: to note that it is per-component, but that prior to 1.8 the simple build system incorrectly did it the other way
09:09:23 <benmachine> dcoutts_: the simple build system only?
09:09:31 <dcoutts_> benmachine: yes an explanation of the cabal-version and build-type fields would be great
09:10:11 <dcoutts_> benmachine: the cabal-version really describes the cabal spec, though currently the version number of the cabal lib and thus the simple build system are tied to that
09:11:01 <benmachine> hmm
09:11:11 <dcoutts_> benmachine: and while it's technically a version range, the only range that makes sense is >= x.y for a major version x.y
09:14:33 <EvanR> prepend n zeros
09:14:39 <EvanR> to a list of integers
09:14:55 <EvanR> repeated : must be better than ++ ?
09:15:36 <benmachine> EvanR: I'd guess they're likely to be pretty similar
09:16:20 <EvanR> ++ has the constraint that it must prepend the operand in reverse order
09:16:41 <EvanR> opposite of traversal
09:16:54 <EvanR> since its all zeros seems like i can get away with that
09:17:36 <Adamant> monads are much easier to understand if you have experience with abstract algebra
09:17:50 <EvanR> > (iterate (\xs -> 0:xs) [5,4,2]) !! 9
09:17:51 <lambdabot>   [0,0,0,0,0,0,0,0,0,5,4,2]
09:17:58 <Adamant> then it's like, "oh, just operations"
09:17:59 <aavogt> @src (++)
09:17:59 <lambdabot> []     ++ ys = ys
09:17:59 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:17:59 <lambdabot> -- OR
09:17:59 <lambdabot> xs ++ ys = foldr (:) ys xs
09:18:53 <aavogt> EvanR: using !! probably adds a constant factor over (++)
09:18:57 <wli> New resume bump.
09:19:12 <wli> ARGH sorry wrong channel.
09:19:39 <EvanR> hrm
09:19:43 <EvanR> ++ it is
09:19:45 <Adamant> wli: you don't seem like you would have much of a problem with your resume :P
09:20:26 <benmachine> > appEndo (foldMap Endo (replicate 9 (0 :))) [5,4,2]
09:20:27 <lambdabot>   Not in scope: `foldMap'
09:20:30 <benmachine> :(
09:21:08 <EvanR> wait
09:21:17 <EvanR> why am i implementing multiplication by hand
09:21:28 <EvanR> now that im using haskell i can use Integer instead
09:22:36 <Adamant> libgmp ftw
09:22:38 <EvanR> haskell causes your code to collapse
09:22:42 <benmachine> heh
09:24:44 <EvanR> i started work on that when i didnt know what language i was using
09:25:00 <EvanR> 64bit ints aint enough
09:25:54 <EvanR> for a basic 46 bit block cipher
09:28:51 <Nibble> foldr (:) [1,2] [2,1]
09:28:53 <Nibble> [2,1,1,2]
09:28:55 <Nibble> hmm
09:35:20 <dancor> > foldr (:) [10, 20] [2, 1]
09:35:21 <lambdabot>   [2,1,10,20]
09:38:39 <medfly> @src (++)
09:38:39 <lambdabot> []     ++ ys = ys
09:38:39 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
09:38:40 <lambdabot> -- OR
09:38:40 <lambdabot> xs ++ ys = foldr (:) ys xs
09:38:45 <medfly> ^^
09:43:49 <tmo_> gtk2hs question: I have a SourceView widget inside a Notebook widget, and whenever I type into it beyond the bounds of the widget, the notebook expands. How do I make it so that 1. The SourceView and Notebook widgets expand on window resizing and 2. *not* expand whenever I type large, multilined documents?
09:46:27 <EvanR> @src genericIndex
09:46:28 <lambdabot> Source not found. My mind is going. I can feel it.
09:48:00 <Olathe> @type index
09:48:01 <lambdabot> forall a. (Ix a) => (a, a) -> a -> Int
09:52:48 <EvanR> what my code outputs different results on codepad?
09:55:24 <EvanR> http://codepad.org/rC2P0tTW
09:56:08 <EvanR> my interpreter starts with 0000 but the others are (besides being readable) are totally different
09:56:42 <portnov> any thoughts about http://dumpz.org/22493/ ? :)
09:57:25 <monochrom> heh, "dumpz"
09:57:40 <hirsch> I want to write a tic-tac-toe program. Now I want to write a function which checks if there's a winner after a move. I created a list like that [(1+,1+),(1+,0+)...] which provides the neighborhood positions. Now every field of my board get's evaluated for possible winning-lines. How can I map my position list-tuples to an evaluation function? http://hpaste.org/40112/boardgame
09:58:41 <monochrom> EvanR: perhaps just because codepad uses a different char encoding than ghci default
09:58:52 <EvanR> but the ascii characters are different
09:59:08 <EvanR> and it shows 4 chars
09:59:14 <EvanR> thats what its supposed to be
09:59:31 <EvanR> char encoding problems involving utf8 usually result in wrong number of chars
10:00:27 <dmhouse> hirsch: a position is a winner if any row column or diagonal sums to 3
10:00:51 <monochrom> I see. the line after 0000 should be v6bk
10:01:32 <EvanR> the next line after that should definitely not start with kt
10:02:18 <zachk> hirsch, you need a legal move generating function, that takes a legal board, and generates all legal boards 
10:03:20 <dino-> I'm having building static problems with ghc, specifically with sqlite3.
10:03:47 <dino-> I can see the lib in /usr/lib/
10:04:03 <dino-> And pkg-config is giving me the same arg that ghc is trying.
10:04:15 <dino-> -lsqlite3
10:04:22 <dino-> Also tried -L/usr/lib
10:04:52 <EvanR> monochrom: relativity of computation ;)
10:05:16 <dino-> Tried 'pkgconfig-depends: sqlite3' in .cabal as well.
10:05:25 <dino-> This ring bells with anyone?
10:05:35 <EvanR> as you change relative speed or position in a gravitational field, arithmetic problems have different answers!
10:06:32 <EvanR> ghci gives you the 'rest' or proper answer
10:06:42 <hirsch> dmhouse: that's no option as I want to extend my code later to support 4-in-a-row and I need direct neightbourhood
10:06:56 <EvanR> gotta use lorentz transformation to predict what codepad.org will get
10:10:03 <hirsch> dmhouse: I think the iterative approach is better, I need to check along a line, counting the same stones, quitting when a foreign stone appears
10:10:41 <Olathe> @quote basic
10:10:41 <lambdabot> cjs says: In what other language could I have learned so much about Win32 programming (summary: basically, the Windows 3.0 API but with all sorts of hacks to deal with having more than one thread in
10:10:41 <lambdabot> the system), and come out having *enjoyed* myself? Praise to the Lord!
10:11:22 <Olathe> Does anyone know where the BASIC monad blog entry is?
10:12:25 <EvanR> besides codepad weirdness, its done http://codepad.org/xcjVLE0W
10:13:21 <EvanR> gracefully growing 'easy to read' fingerprints to use in place of hashes
10:13:28 <dmhouse> hirsch: generalisation to n x n isn't hard; winning condition is then that the row or column or diagonal (if n is odd) sums to n or 0
10:16:08 <hirsch> dmhouse: no, a 4-in-a-row field is bigger than 4x4
10:16:18 <monochrom> Olathe: http://augustss.blogspot.com/2009/02/more-basic-not-that-anybody-should-care.html
10:17:14 <dino-> Doesn't work either: extra-libraries: sqlite3
10:17:45 <dmhouse> hirsch: oh?
10:17:59 <monochrom> haha, his blog is heavily spammed :)
10:18:01 <dmhouse> hirsch: oh, I see what you mean
10:18:25 <dmhouse> hirsch: funny, I'd never thought of that game (I know it as "connect 4") as a generalisation of noughts and crosses
10:20:53 <hirsch> I want to develop a generic approach for all kinds of games like that, there should also be a rule how new tiles are put in the board: no rule(tic-tac-toe), one side with gravity (4-in-a-row) or others.
10:23:12 <hirsch> dmhouse: I want to develop a generic approach for all kinds of games like that, there should also be a rule how new tiles are put in the board: no rule(tic-tac-toe), one side with gravity (4-in-a-row) or others.
10:23:36 <EvanR> is go included?
10:24:11 <Jafet> Gomoku would, but it's unrelated.
10:24:16 <hirsch> EvanR: I don't even know the rules ;-)
10:24:28 <EvanR> w-w-w-wat
10:24:29 <EvanR> ;)
10:24:53 <Jafet> There's some proprietary program, zog, that purports to have a custom description language for games.
10:25:43 <monochrom> in go, you can put new tiles unconstrained
10:25:54 <hirsch> http://hpaste.org/40113/boardgame2
10:26:10 <Jafet> In go, you don't win by getting all your stones in a line
10:26:24 <monochrom> but after a tile is put, there is a rule about taking away other tiles.
10:26:31 <EvanR> you win when the other guys gets tired of your insolence
10:26:54 <hirsch> it you want to take a look, any suggestion appreciated
10:27:03 <EvanR> see also pente
10:28:21 <hirsch> EvanR: I think TTT is hard enough for the beginning, as I want to write a MinMax-based AI
10:32:44 <monochrom> Go AI is so far pretty hopeless :)
10:33:08 <monochrom> but tic tac toe and connect 4 are quite ok
10:33:22 <EvanR> i.e. impossible to beat
10:33:49 <monochrom> they are nice exercises
10:34:13 <hirsch> monochrom: "The beginner takes it all"
10:34:23 <monochrom> heh
10:34:48 <monochrom> the next step is reversi
10:35:18 <geheimdienst> > reverse "reversi"
10:35:19 <lambdabot>   "isrever"
10:35:32 <hirsch> :-)
10:35:40 <EvanR> peripherally related to reversi -> http://www.youtube.com/watch?v=tGvHNNOLnCk
10:37:21 <hirsch> any comments on my paste, I'm very unsure with my coding style and haskell-abuse
10:37:38 <hirsch> ?
10:38:07 <monochrom> reversi is probably the first time you decide it takes too long to compute the correct answer, and so you just look ahead for 6 turns or something, and hope the opponent is a normal human.
10:38:48 <hirsch> FP is often elegant if I read others' code, but PITA if I write it myself
10:39:27 <EvanR> its also elegant when you dont read it
10:39:52 <lantti> My FP is more like spaghetti
10:39:54 <Saizan> polish it until it's elegant, then
10:40:14 <bremner> reverse polish for that old-school charm
10:40:15 <EvanR> how do you write spaghetti fp
10:40:48 <hirsch> mine is abuse of dark FP features to write imperative code
10:40:55 <EvanR> 'dark fp'
10:40:57 <EvanR> lol
10:41:05 <lantti> Lots of nested things when I remember that aha, this needs to know this too.
10:41:17 <Martty> fp = function programming? free point? function pointer?
10:41:32 <EvanR> a tree isnt spaghetti
10:42:02 <Jafet> That reminds me of the spaghetti tree
10:42:45 <hirsch> Martty: Functional programming
10:43:05 <monochrom> fountain pen
10:43:22 <EvanR> fun points
10:44:02 <monochrom> forget python
10:44:05 <atude> no
10:44:07 <atude> it's useful
10:44:14 <atude> especially for rapid prototyping
10:44:23 <tmo_> Okay, compile the simple program below and type until the text is larger than the SourceView buffer. Notice how it dynamically expands.
10:44:23 <tmo_> http://pastebin.com/3CuE4enK
10:44:26 <EvanR> it also is useful for doing things only one way
10:44:42 <EvanR> and having batteries included
10:44:45 <tmo_> How do I prevent that kind of dynamic expansion?
10:44:48 <monochrom> oh, I just mean "fp = forget python". not to suggest you to forget python. :)
10:45:26 <atude> monochrom: oh
10:45:39 <EvanR> i rapidly prototype pure functions a lot faster in haskell
10:45:42 <monochrom> python is useful for explaining what is meant by "(\x -> blah)"
10:46:00 <Jafet> You have to forget it every other version, anyway
10:46:01 <EvanR> and by prototype i mean finalize
10:46:34 <djahandarie> Yeah, I generally write code a lot faster in Haskell than anything else when it is pure code
10:46:57 <monochrom> actually, yes, if you write a lot of pure functions, not needing to write "return" every other line is much appreciated.
10:47:25 <djahandarie> The composability is also very helpful
10:47:39 <monoidal> is there an IRC channel for Omega?
10:48:13 <Saizan> we could start one.
10:48:48 <monoidal> #omega
10:49:14 <EvanR> function (x,y){ return expr(x,y); } vs (\x y -> expr x y)
10:49:32 <djahandarie> Or just   expr
10:49:38 <EvanR> hah
10:49:50 <EvanR> yeah but that stands for a literal expression 
10:49:53 <monochrom> I believe that the freenode convention is "#omega" if backed by the creators of Omega, "##omega" if not.
10:49:56 <atude> > 
10:49:57 <lambdabot>   not an expression: `'
10:49:59 <EvanR> might not be easily partialled
10:50:22 <EvanR> though you can partial a freaky number of expressions in haskell with sections
10:50:36 <EvanR> maybe not as readable though
10:51:06 <atude> > for(i; i< 60; i++) { print("%d", i); }
10:51:07 <lambdabot>   <no location info>: parse error on input `;'
10:51:44 <EvanR> > forM_ [0..59] putStrLn
10:51:45 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
10:51:45 <lambdabot>    arising from the literal `...
10:51:52 <EvanR> > forM_ [0..59] print
10:51:53 <lambdabot>   <IO ()>
10:55:11 * hackagebot srcloc 0.1 - Data types for managing source code locations.  http://hackage.haskell.org/package/srcloc-0.1 (GeoffreyMainland)
10:57:02 <monoidal> #omega seems registered, I can't join ##omega. anyway, I'm trying to translate kind polymorphism and get errors in http://hpaste.org/40114/. UHC doesn't support GADTs and I need both
10:57:09 <ddarius> #haskell: Backed by the Creator
10:57:40 <monoidal> anyone who gets it to compile is welcome to paste :)
10:58:11 <ddarius> monoidal: Hack kind polymorphism into GHC.
10:58:27 <geheimdienst> #mega-omega
10:58:47 <mauke> omegano
10:59:37 <geheimdienst> i'd say omicron, but that'd be a little greeko-elitisto-smartasso
11:00:13 <monoidal> the example I want, is: In *, monoids are normal monoids. In * -> *, monoids can be monads or comonads. In * -> * -> *, monoids can be categories or arrows.
11:00:33 <monoidal> but the last one needs GADTs :)
11:02:13 * hackagebot mainland-pretty 0.1 - Pretty printing designed for printing source code.  http://hackage.haskell.org/package/mainland-pretty-0.1 (GeoffreyMainland)
11:07:56 * geheimdienst thinks mainland-pretty is quite an awesome package name
11:08:14 * hackagebot language-c-quote 0.2 - C/CUDA quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.2 (GeoffreyMainland)
11:15:16 * hackagebot numeric-quest 0.1.1.1 - Math and quantum mechanics  http://hackage.haskell.org/package/numeric-quest-0.1.1.1 (HenningThielemann)
11:16:49 <Taslem> Hi, could I get some info on the GHCi?
11:17:18 <Taslem> Is there any way to trace which functions have been called with what values, etc, or a simple way for me to find what line is calling an exception from (!!)
11:18:25 <monoidal> Taslem: I head about http://hackage.haskell.org/package/interlude-0.1.1
11:18:58 <dmwit> Debug.Trace ?
11:21:17 * hackagebot synthesizer-core 0.4.0.3 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.4.0.3 (HenningThielemann)
11:23:14 <mapreduce> Hi.  I installed the Haskell Platform on OS X Snow Leopard and see 'The installation failed.  The installer encountered an error that caused the installation to fail.  Contact the software manufacturer for assistance.'
11:23:30 <mapreduce> Any suggestions, or info about where the log files containing more info might be?
11:24:18 * hackagebot language-c-quote 0.2.0.1 - C/CUDA quasiquoting library.  http://hackage.haskell.org/package/language-c-quote-0.2.0.1 (GeoffreyMainland)
11:43:59 <diracdelta> Hi, suppose I have several Types, A,B,C, and I want to create a generic function that takes a type (not an instance of a type, Int, not 3) and returns a function that will read a file (or string) and return Mabye Type. What is the correct way of doing this? It doesn't seem to be possible to create functions that take a Type as an argument, is that correct?
11:44:44 <c_wraith> You can't pass a type to a function, that's correct
11:44:46 <EvanR> functions can take 'any type' and 'any type implementing specified interface'
11:44:46 <monoidal> diracdelta: if the type is known at compile time, you can use a typeclass
11:44:53 <EvanR> take/return
11:45:31 <monoidal> diracdelta: class Readable a where f :: String -> Maybe a; instance Readable A where f = ...; instance Readable B where f = ...; etc
11:45:48 <EvanR> also existentials
11:46:13 <monoidal> diracdelta: types have to be known at compile time and are erased when the program, so you can't vary them at runtime
11:46:24 <monoidal> *when the program is compiled
11:47:01 <_unK> hi. is pattern matching against bytestrings possible or do I have to unpack them first?
11:47:43 <tommd> you can pattern match to get the length, offset and pointer
11:47:44 <c_wraith> _unK, you can pattern match against them using the OverloadedStrings extension, but be aware of the standard caveats
11:47:56 <Gracenotes> uncons might help
11:48:03 <benmachine> viewpatterns might help
11:48:07 <EvanR> dammit
11:48:11 <EvanR> i was about to say viewpatterns!
11:48:14 <Gracenotes> or both of them together
11:48:25 <tommd> _unK: ViewPatterns might be what you want
11:48:26 <benmachine> indeed
11:48:37 <tommd> damn, need to read what others say
11:48:46 <EvanR> what the hell
11:48:50 <_unK> ok, thx :)
11:48:54 <EvanR> _unK: try view patterns
11:49:19 <tommd> lol, feeding the baby right now too, leave me alone
11:49:20 <benmachine> there are other ways to work with bytestrings other than pattern matches, mind
11:51:56 <diracdelta> monoidal: right. The types will be known at compile time. However, it seems that if I have a type "data x = Constructor Int Int Int", I would like to automatically have a function that simply reads in three integers.
11:52:42 <monoidal> diracdelta: You don't want deriving Read? I think there are some libraries that do deriving magic
11:52:48 <EvanR> data X, X could implement a deserializable class
11:52:52 <EvanR> like Read
11:53:46 <diracdelta> EvanR: I guess that would be want I want. I don't really understand how the deriving functions work. They don't seem to be a concept expressable in Haskell.
11:54:21 <EvanR> its a built in feature
11:54:42 <monoidal> diracdelta: they are only shortcuts that add instances. Instead of data T = A | B | C and writing instance Eq, you can write "deriving Eq". that is possible only for about 10 classes
11:54:48 <EvanR> > show Nothing
11:54:49 <lambdabot>   "Nothing"
11:54:58 <EvanR> > read "Nothing" :: Maybe Int
11:54:59 <lambdabot>   Nothing
11:55:10 <monoidal> diracdelta: there's Template Haskell, that allows to analyze in compile-time how the structures are built
11:55:38 <EvanR> > show (6,4,2)
11:55:38 <lambdabot>   "(6,4,2)"
11:55:52 <EvanR> > read "(6,4,2)" :: (Int,Int,Int)
11:55:53 <lambdabot>   (6,4,2)
11:55:54 <diracdelta> monoidal: Template Haskell I think is what I want. I'll start looking at the references.
11:56:03 <monoidal> diracdelta: you can check http://www.haskell.org/bz/thdoc.htm
11:56:25 * EvanR scratches head. how did we get to template haskell
11:56:59 <monoidal> diracdelta: however, with 3 classes it's simpler to write the parsing manually, or use something like Data.Binary :)
11:57:34 <diracdelta> monoidal: Understood. :)
11:58:20 <nniro> since when is read :: (Read a) => String -> Maybe a   ?
11:59:08 <nniro> my local read is   read :: (Read a) => String -> a
12:00:04 <EvanR> you mean since when it is String -> Maybe Int
12:00:20 <Gracenotes> > read "Just 4" :: Maybe Int
12:00:20 <Heffalump> if you're referring to EvanR's examples above, they are instantiating a with Maybe Int
12:00:21 <lambdabot>   Just 4
12:00:23 <EvanR> since Maybe Int is member of Read
12:00:31 <monoidal> Maybe a is a special case of a
12:00:42 <nniro> ah ok sorry, I haven't noticed :)
12:00:50 <EvanR> as is (Int,Int,Int)
12:01:16 <EvanR> > show ( 4, 6  , 3,)
12:01:17 <lambdabot>   <no location info>: parse error on input `)'
12:01:19 <EvanR> > show ( 4, 6  , 3)
12:01:20 <lambdabot>   "(4,6,3)"
12:01:34 <EvanR> lame ;)
12:03:13 <nniro> I definitely didn't know it was possible to instantiate a polymorph variable with Maybe and still expect that the function properly makes use of it
12:03:34 <monoidal> nniro: in this case, there's instance Read a => Read (Maybe a)
12:04:40 <EvanR> > read "Nothing" :: Maybe a
12:04:41 <lambdabot>   Could not deduce (GHC.Read.Read a) from the context ()
12:04:41 <lambdabot>    arising from a us...
12:04:45 <EvanR> heh
12:05:21 <EvanR> the answers obviously Nothing! xD
12:06:53 <nniro> monoidal: that's really good to know, is it kind of hidden though? I can't find it in the haddock page or when I do :info Read
12:07:22 <monoidal> nniro: it is present if you look at :info Read
12:07:37 <nniro> monoidal: yeah I just noticed it :    instance (Read a) => Read (Maybe a) -- Defined in GHC.Read
12:12:00 <nniro> monoidal: I recall not too long ago someone here told me to implement this using :   mread :: (Read a) => String -> Maybe a
12:12:00 <nniro> mread str = case reads str of; [(a, "")] -> Just a; _ -> Nothing
12:12:40 <monoidal> nniro: yes, that might be a good idea
12:13:03 <monoidal> diracdelta: you might check above if TH is too heavyweight for you :)
12:15:28 <kmc> mread (reads -> [(v,"")]) = Just v; mread _ = Nothing
12:15:35 <kmc> gratuitous use of ViewPatterns :)
12:16:00 <nniro> kmc: alright :)
12:19:00 <benmachine> mread (reads -> [(v,(all isSpace -> True))]) = Just v
12:19:01 <benmachine> :P
12:20:41 <kmc> hmm i wrote a splice in a quote in a splice in a quote
12:20:48 <benmachine> heh
12:20:50 <kmc> i'm not sure i should be trusted with TH
12:21:12 <benmachine> well, it *is* TH
12:21:17 <benmachine> isn't it just a bit like that, anyway
12:21:37 <kmc> yeah
12:22:03 * benmachine holds a vague sort of view that TH is something that will be brilliant in a few years
12:24:20 <kmc> erm
12:24:23 <kmc> is anyone working on it?
12:24:44 * benmachine shrugs
12:24:46 <kmc> i guess QQ is new, but kind of a side thing
12:24:53 <benmachine> someone should be :P
12:24:54 <kmc> they still haven't implemented pattern splices, which are in  the original paper
12:25:19 <benmachine> I thought it was pattern quotes?
12:25:21 <benmachine> or is it both
12:26:31 <kmc> i doubt TH will ever be pretty
12:26:51 <benmachine> oh, maybe not
12:27:01 <benmachine> but it could be afford to be a bit prettier than it is
12:29:10 <sshc> \la
12:29:10 <kmc> yes
12:29:57 <kmc> i should get a syntax highlighting mode which colors different stages with different bgcolor
12:45:59 <aavogt> kmc: so you know beforehand that you'll run into stage restrictions?
12:46:50 * hackagebot UMM 0.3.1 - A small command-line accounting tool  http://hackage.haskell.org/package/UMM-0.3.1 (UweHollerbach)
12:48:35 <nejucomo> I want to write "instance Integral i => MyClass i where …" but this does not seem possible.
12:49:26 <nejucomo> Is it possible to say: "If any type is an Integral, then it is also an instance of MyClass."  ?
12:50:16 <dmhouse> nejucomo: that should work; does it not?
12:53:11 <nejucomo> dmhouse: First ghc tells me I need "FlexibleInstances", then it tells me I need "UndecidableInstances".
12:53:41 <monoidal> nejucomo: This says, "MyClass i is always declared, but you need Integral i"
12:53:44 <nejucomo> I'm familiar with FlexibleInstances in a different context (type aliases or compound type instances, like (a -> b)), but I'm not familiar with UndecidableInstances.
12:53:55 <monoidal> nejucomo: the type checker doesn't backtrack
12:54:14 <nejucomo> I don't understand.  What does "always declared" mean?
12:54:33 <nejucomo> brb
12:54:59 <monoidal> nejucomo: If compiler will need MyClass i somewhere, it'll find this rule, match RHS and the goal will be to match LHS - Integral i. There's no backtracking.
12:57:02 <nejucomo> back.
12:57:49 <nejucomo> I guess this is another case where not understanding the type inference algorithm bites me.
12:58:09 <nejucomo> Do you mean it does not recursively try to fulfill Integral i ?
12:58:58 <dmhouse> nejucomo: can you post some source?
12:59:34 <monoidal> nejucomo: It will. But, if you declare MyClass Bool somewhere later, it won't find it. It'll fail to find Integral Bool.
13:00:19 <nejucomo> I see.
13:01:27 <chrisdone> http://img709.imageshack.us/img709/8238/bahahaha.png
13:01:49 <chrisdone> Just as planned n_n
13:02:06 <nejucomo> So can declare an instance of MyClass Integer, and everywhere I use an Integral and/or Num convert back-and-forth at each callsite.
13:02:11 <Mitar> i am trying to make interface to X11 XGetImage function: http://tronche.com/gui/x/xlib/graphics/images.html#XImage
13:02:16 <nejucomo> But I hoped I could convince the type system to do this for me.
13:02:24 <Mitar> how can I define resulting struct?
13:02:34 <Mitar> (and where does X11 lib free this struct?)
13:04:14 <ddarius> Mitar: Isn't there already a library of bindings to various X functions?
13:09:10 <Mathnerd314> which monads cannot be turned into monad transformers?
13:09:17 <Mitar> i cannot find it
13:09:23 <Mitar> grep also does not find it
13:09:25 <Mitar> it seems it is not
13:10:33 <Philippa> Mathnerd314: IO would be a bit difficult to :-)
13:10:47 <Philippa> I don't know what the canonical pure counterexample is though
13:11:34 <monoidal> two monads S,T can be combined if there's a natural transformation S(T(X)) -> T(S(X)) satisfying some obvious diagrams
13:12:19 <monoidal> then join :: T(S(T(S(X))) -> T(T(S(S(X))) -> T(S(X)) using the transformation and joins of S,T
13:16:25 <Mathnerd314> monoidal: so when can they not be combined? I don't how the CT helps.
13:16:30 <mornfall> I guess any "natural" monad can be made a transformer.
13:17:00 <mornfall> You could probably construct one that you can't, but I'd expect it to be fairly contrived.
13:17:07 <dmwit> Mathnerd314: They can't be combined when there's no natural transformation satisfying the diagrams, of course.
13:17:48 <monoidal> Mathnerd314: don't know either :)
13:17:56 <dmhouse> So anyone read the Omega paper?
13:18:02 <monoidal> as an aside ListT [] is not a monad
13:18:27 <dmwit> monoidal: There is a nice monad transformer for nondeterministic choice, if you want that.
13:18:29 <ddarius> I read it years ago.
13:18:43 <Mathnerd314> monoidal: what? I thought the whole point was that every transformer was a monad...
13:18:51 <ddarius> Incidentally, having a distributive law is stronger than having a monad transformer.
13:19:04 <Saizan> i don't think the existence of that natural transformation is a necessary condition
13:19:07 <monoidal> Mathnerd314: see http://blog.sigfpe.com/2006/11/why-isnt-listt-monad.html
13:19:56 <monoidal> ddarius: That's interesting, where can I read about it?
13:24:21 <Mathnerd314> so ListT is a bad monad transformer because equality depends on order?
13:24:44 <monoidal> Mathnerd314: yes
13:25:09 <monoidal> if you regard it conceptually as SetT, then it a valid transformer (maybe modulo infinite lists)
13:25:14 <kmc> by "bad monad transformer" you mean "not a monad transformer"
13:27:30 <EvanR> alternatively you could mean "decepticon"
13:27:47 <EvanR> if you didnt put the stupid word monad in there
13:28:14 <Mathnerd314> kmc: if equality of lists ignores the ordering of elements, then ListT is a good, well-behaved monad transformer
13:28:22 <ddarius> kmc: Monad transformer over a different category.
13:33:41 <mornfall> monoidal: But there's no SetT! :(
13:33:51 <mornfall> And it really seems to be a fundamental problem to write it.
13:34:36 <mornfall> (Well, you could probably rework the classes to allow it, but it doesn't work with the * -> * Functor, unless I am missing a trick.)
13:35:32 <monoidal> that's right, I didn't claim SetT really exists :)
13:36:17 <monoidal> I hope there will be a solution for some day, something like restricted monads
13:37:11 <kmc> "monad decepticon"
13:37:13 <kmc> i like it
13:37:22 <mornfall> monoidal: Wouldn't it be possible to write a Functor class where the parameter is an associated type instead of f being * -> *?
13:40:20 <mornfall> Ok, I see the problem with that. :)
13:41:44 <monoidal> mornfall: Don't know. I was thinking more about Functor defined with something like kind-polymorphism using Eq kind/class, instead of *. That would require great changes to language, though.
13:42:42 <Phantom_Hoover> How does one ask for lambdabot?
13:42:49 <monoidal> @type 2
13:42:50 <lambdabot> forall t. (Num t) => t
13:43:18 <Lemmih> Phantom_Hoover: Politely.
13:43:20 <Phantom_Hoover> No, on a channel.
13:43:31 <monoidal> @list
13:43:31 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
13:43:56 <mornfall> I'd try to /invite it, but that's just wild guessing on my part.
13:44:14 <Lemmih> Phantom_Hoover: Which channel do you want her to join?
13:44:20 <aavogt> @join #imaginarychannel
13:44:21 <lambdabot> Not enough privileges
13:44:33 <Phantom_Hoover> Lemmih, #esoteric, it would appear.
13:44:35 <monoidal> @sudo join #imaginarychannel
13:44:35 <lambdabot> Maybe you meant: do todo undo
13:44:44 <Lemmih> @join #esoteric
13:45:09 * Lemmih feels privileged.
13:45:14 <mornfall> /nick Lemmih_
13:45:15 <Phantom_Hoover> Thanks.
13:45:34 <aavogt> but you ought to ask Cale to put that in the list of channels she joins by default
13:45:54 <Lemmih> Phantom_Hoover: It's not permanent, though. She'll eventually get bored and wander back to #haskell.
13:46:03 <Phantom_Hoover> Awww.
13:46:08 <medfly> lol
13:46:27 <hvr> is there a reason why mapMaybe is defined rather verbose in http://haskell.org/ghc/docs/6.12.1/html/libraries/base-4.2.0.0/src/Data-Maybe.html#mapMaybe
13:46:36 <hvr> instead of being just: mapMaybe f = catMaybes . map f
13:46:37 <hvr> ?
13:47:45 <Lemmih> hvr: Fear of fusion not happening?
13:47:57 <Mitar> http://tronche.com/gui/x/xlib/graphics/images.html#XImage << how can i represent callback functions in this struct?
13:48:21 <mornfall> monoidal: I guess you could also just say that (==) :: a -> a -> Bool, or something to make it work. :)
13:48:56 <Lemmih> hvr: If the optimizations fail to happen just right then your version will create an intermediate list.
13:49:45 <hvr> Lemmih: is there a simple way to see how ghc optimizes code?
13:49:58 <mornfall> hvr: You can dump core.
13:50:10 <hvr> mornfall: and that's supposed to be simple? ;)
13:50:11 <mornfall> cabal install ghc-core
13:50:16 <Lemmih> hvr: No, but you can do what mornfall said. (:
13:50:50 <mornfall> (not the SEGV kind of core, mind you)
13:50:54 <kmc> floating point literals in Haskell are handled through fromRational, right?
13:51:01 <kmc> yet «read "3.05" :: Rational» fails :/
13:51:04 <kmc> > read "3.05" :: Rational
13:51:05 <lambdabot>   *Exception: Prelude.read: no parse
13:51:17 <hpc> :t 3.0
13:51:18 <lambdabot> forall t. (Fractional t) => t
13:51:33 <hpc> :t fromRational
13:51:34 <lambdabot> forall a. (Fractional a) => Rational -> a
13:51:34 <geheimdienst> > read "3.05" :: Float
13:51:35 <lambdabot>   3.05
13:51:59 <hpc> type Rational = Ratio Integer
13:52:29 <mornfall> Now *that* is an inefficient type.
13:52:31 <Lemmih> kmc: See 'show (3.05 :: Rational)'.
13:52:47 <hpc> > show (3.5 :: Rational)
13:52:48 <lambdabot>   "7 % 2"
13:53:04 <mornfall> > read "7 % 2" :: Rational
13:53:05 <lambdabot>   7 % 2
13:54:50 <dmwit> :t lex
13:54:51 <lambdabot> String -> [(String, String)]
13:54:52 <mornfall> One'd wish for some sort of metaquickcheck to say for all types a such that (Show a, Read a), ((read $ show x) `asTypeOf` x) == x... or something like that anyway
13:54:56 <Lemmih> kmc: Floating point literals are specified as fractions, not strings.
13:55:14 <alise> l
13:55:36 <dmwit> > iterate (\(s, s') -> head (lex s')) ("3.05", "")
13:55:36 <lambdabot>   [("3.05",""),("",""),("",""),("",""),("",""),("",""),("",""),("",""),("",""...
13:55:53 <Mitar> this one is defined really ugly http://hackage.haskell.org/packages/archive/X11/1.5.0.0/doc/html/Graphics-X11-Xlib-Types.html#t:Image
13:56:16 <Mathnerd314> > lex "3.05"
13:56:18 <lambdabot>   [("3.05","")]
13:56:45 <hpc> > lex "3.05 foo baz"
13:56:46 <lambdabot>   [("3.05"," foo baz")]
13:56:58 <hpc> lex == splitAt ' '?
13:57:22 <djahandarie> > lex ".05"
13:57:23 <lambdabot>   [(".","05")]
13:57:23 <mornfall> hpc: Not really, it'll eat any amounts of whitespace.
13:57:25 <benmachine> > lex "foo+bar"
13:57:26 <lambdabot>   [("foo","+bar")]
13:58:13 <hpc> ooh, that's useful
13:58:27 <mornfall> Well, somewhat.
13:58:47 <hpc> it can make simple parsers easy to write
13:59:04 <djahandarie> @hoogle lex
13:59:04 <lambdabot> Prelude lex :: ReadS String
13:59:04 <lambdabot> Text.Read lex :: ReadS String
13:59:04 <lambdabot> Text.Read.Lex lex :: ReadP Lexeme
13:59:05 <mornfall> As long as they have Haskell's lexical structure.
13:59:57 <hpc> i was thinking of using it to parse infix math before doing a pass through shunting-yard
14:00:17 <hpc> for that, i think lex will work perfectly
14:00:34 <mornfall> hpc: It'll lex --2 as "--" "2" and not "-" "-" "2" though.
14:01:06 <hpc> if they use double negation, they deserve the confusion :P
14:01:41 <aristid> > - - 2
14:01:42 <lambdabot>   <no location info>: parse error on input `-'
14:01:48 <aristid> :(
14:01:51 <Mathnerd314> mornfall: can't you see that's prefix decrement :p
14:01:53 <aristid> > - $ - 2
14:01:54 <lambdabot>   <no location info>: parse error on input `$'
14:01:58 <aristid> oO
14:02:02 <aristid> > - (- 2)
14:02:03 <lambdabot>   2
14:02:12 <hpc> haskell sucks at negative numbers
14:02:16 <aristid> hpc: yes
14:05:08 <geheimdienst> > - 2
14:05:11 <lambdabot>   -2
14:05:18 <geheimdienst> 1 - 2
14:05:24 <geheimdienst> > 1 - 2
14:05:25 <lambdabot>   -1
14:10:39 <ddarius> kmc: Want to go running in the Fells some time?
14:13:27 <Xaphiosis> hi
14:13:37 <kmc> ddarius, i suck at running, but maybe
14:13:43 <kmc> do you bike?
14:14:20 <mapreduce> Hi.  I installed the Haskell Platform on OS X Snow Leopard and see 'The installation failed.  The installer encountered an error that caused the installation to fail.  Contact the software manufacturer for assistance.'
14:14:23 <mapreduce> Any suggestions, or info about where the log files containing more info might be?
14:14:30 <ddarius> kmc: I don't own a bike and I haven't really done it since my teenage years though I liked it well enough then.
14:15:07 <mapreduce> I asked this earlier, applicative later asked a couple of questions.  I can't see any info in Console or any evidence that I had a prior-installed Haskell via ports.
14:15:30 <Xaphiosis> could anyone help me figure out why I'm running out of stack when I add a simple printing statement in IO? http://hpaste.org/40118/stack_overflow_strangeness
14:16:18 <Xaphiosis> I'm compiling with -O2 and the passThrough function seems very simple, but adding it causes additional stack usage
14:17:49 <monoidal> mapreduce: I don't use OS X, but maybe check this: http://discussions.apple.com/message.jspa?messageID=10197988
14:18:05 <monoidal> seems the error message is general and not coming from the HP installer
14:19:18 <Lemmih> Xaphiosis: It's probably the 'mapM' that's causing the trouble. 'map' consumes the input list lazily, 'mapM' does not.
14:19:19 <dmwit> Xaphiosis: likely because you're making a deeply-nested thunk.
14:19:26 <dmwit> Xaphiosis: Consider the following instead:
14:19:31 <Xaphiosis> oh
14:20:24 <Xaphiosis> I just want some print output as I go through lists of stuff... for larger problems, it's hard to tell how far we're up to... didn't expect mapM doesn't lazily consume :/
14:20:25 <dmwit> let rfls = map theTRFL [1..limit]; mapM_ (\(n, l) -> when (n `mod` 10000 == 0) $ print n) rfls; let xs = ...
14:20:58 <mapreduce> monoidal: Thanks, that reveals some further info: http://pastebin.com/rdrp1FAy
14:21:02 <dmwit> Oh, I didn't notice you were using rfls later. That suggestion might still overflow then.
14:21:29 <Lemmih> Xaphiosis: You can use Debug.Trace.trace instead.
14:21:39 <Saizan> Xaphiosis: this shouldn't overflow http://hpaste.org/paste/40118/mapm#p40119
14:22:06 <Saizan> Xaphiosis: mapM has to traverse the whole list before returning, because it has to perform all the associated side effects
14:22:21 <Xaphiosis> hmm
14:22:35 <Saizan> mapM_ will also traverse the whole list, but won't use stack when constructing its result
14:22:39 <Saizan> (it's just ())
14:22:51 <Xaphiosis> I'm afraid I don't understand
14:23:09 <Xaphiosis> mapM_ I get, but mapM needing stack I do not
14:23:30 <Xaphiosis> I'll check your solution now, Saizan
14:24:32 <kmc> there's no good way to make a class that has an instance for (a -> b) and an instance for every other type, correct?
14:24:41 <Saizan> Xaphiosis: mapM f [] = return []; mapM f (x:xs) = do y <- f x; ys <- mapM f xs; return (y:ys) --- the implementation is equivalent to this one, so it's not tail recursive
14:24:58 <monoidal> mapreduce: seems the error is in 10 line, the installer cannot find ghc-pkg. don't know why
14:25:19 <Lemmih> kmc: Correct.
14:25:22 <kmc> i'm trying to do something generically over all data constructors
14:25:26 <kmc> of all arity
14:25:33 <monoidal> mapreduce: maybe try installing GHC first, and then download HP tools from http://hackage.haskell.org/platform/mac.html?
14:25:46 <kmc> my workaround is to pass a type-level natural saying how many arguments to consume
14:25:52 <kmc> which makes the API slightly worse but not a big deal
14:26:07 <mapreduce> So I'll open the haskell platform dmg and just click the 'install ghc' bit.
14:26:21 <Lemmih> kmc: You could do what printf does.
14:26:43 <Saizan> we could have a tail recursive mapM though, "mapM f = mapM' id where mapM' acc [] = return (acc []); mapM' acc (x:xs) = do y <- f x; mapM' (acc . (y:)) xs"
14:26:48 <kmc> printf only works for types of the form (a -> b -> ... -> q -> IO ()) or ( that stuff -> String)
14:26:51 <kmc> i.e., two specific types
14:27:07 <kmc> it seems harder if i want (a -> b -> ... -> q -> (any t, unless t contains (->)))
14:27:13 <Xaphiosis> ugh. sorry, it took me a while to recover the machine
14:27:21 <kmc> and by harder i mean impossible without IncoherentInstances and probably then too
14:27:33 <mapreduce> Hmm, it looks like one needs to install ghc before the haskell platform, I was guessing ghc would be included in the platform.
14:27:38 <Xaphiosis> Saizan's solution does indeed not overflow in stack, but it changed the program to eat all the memory on my machine
14:27:43 <Saizan> kmc: you only need OverlappingInstances
14:28:31 <kmc> i had «instance Foo t t» and «instance (Foo t r, Arg a) => Foo (a -> t) r»
14:28:37 <kmc> and the implementation ended up incoherent
14:28:38 <Lemmih> kmc: GHC will pick the least general instance, I believe.
14:28:38 <Saizan> Xaphiosis: heh, yeah, it'll have to keep all of ts in memory at once
14:28:46 <kmc> because you can instantiate t to «a → t₁»
14:29:31 <Xaphiosis> Saizan: oww. that hurt ...
14:29:41 <Lemmih> Xaphiosis: Debug.Trace.trace will print out the items as they are consumed.
14:30:07 <Saizan> kmc: http://pastebin.com/zYLB0zeC <- probably relevant to what you want to do
14:30:22 <Xaphiosis> Lemmih: agreed, but I thought there could be a "nicer" way
14:30:23 <ddarius> kmc: The usual solution is, indeed, to list out all the base cases.
14:30:24 <Lemmih> Xaphiosis: You should just keep in mind that lazy IO can be strange at times.
14:30:38 <kmc> why should i specify extensions in my .cabal file, instead of using {-# LANGUAGE Foo #-}
14:30:39 <orbital_fox> has haskell been used for embedded systems? is it efficient enough?
14:30:49 <Lemmih> Xaphiosis: There isn't a nicer way. Lazy IO is the only answer.
14:30:51 <kmc> orbital_fox, not directly, but it's used to output or verify code for embedded systems
14:30:58 <kmc> http://hackage.haskell.org/package/atom
14:31:03 <kmc> orbital_fox, ^^^
14:31:16 <Xaphiosis> it's a problem I run across every now and again... I'm running something over a list, printing the result, but it could take a while, so I just want some progress indicator on the screen
14:31:22 <kmc> strictly speaking "Haskell" has no level of efficiency; it's a language, not an implementation
14:31:33 <kmc> no existing Haskell implementation would be suitable for a very memory-constrained system
14:31:43 <Lemmih> kmc: It's considered politely to do both, imo.
14:31:55 <kmc> but the definition of "embedded" can go pretty high spec these days
14:31:56 <Xaphiosis> Lemmih: "Lazy IO" ... could you clarify what you mean there?
14:32:03 <kmc> iirc blackh had some Haskell code running on an NSLU2
14:32:13 <kmc> Debian's ARM distribution has GHC
14:32:21 <kmc> there is also Haskell on iPhone and Android
14:32:26 <mapreduce> monoidal: Great, that works fine.
14:32:43 <ddarius> You could also do, newtype Done a = Done a; instance Foo (Done a) where ...; instance Foo b => Foo (a -> b) where ...
14:33:07 <mapreduce> The only thing I'm missing now is that when I evaluate something in ghci, the next line starting with Prelude kind of merges with it, like:
14:33:10 <orbital_fox> kmc cool thanks
14:33:12 <mapreduce> Prelude> 3 * 2
14:33:14 <mapreduce> 6relude>
14:33:22 <Lemmih> Xaphiosis: You want to do IO in a non-strict fashion. You want the order of the side-effects to be determined by the execution order of lazy code.
14:34:08 <Xaphiosis> Lemmih: that's right, but are you saying this is not the current way it works, or am I writing it wrong, or what?
14:34:27 <ddarius> It's using carriage returns and not line feeds (?)
14:35:18 <Lemmih> Xaphiosis: I'm saying that using Debug.Trace.trace is the easiest way of doing lazy IO.
14:35:53 <mapreduce> ddarius: No idea.  Is there a way of altering what it uses?
14:36:04 <Xaphiosis> Lemmih: ok then, I'll stick to that until someone complains and tells me to do something else :)
14:37:38 <Lemmih> Xaphiosis: Actually, we could approach the problem in a different way.
14:39:04 <Xaphiosis> I'm always interested in a different way!
14:39:26 <ddarius> mapreduce: I haven't used any Apple product in over ten years.
14:40:04 <mapreduce> ddarius: I meant altering it from the ghci end.
14:40:24 <Lemmih> Xaphiosis: You want some progress report, don't you? You want some kind of notification every time it has gone through 10k items, right?
14:40:25 <monoidal> mapreduce: you can do ugly trick, by writing something like :set prompt "\rghci> "
14:40:27 <mapreduce> afaict, Terminal.app does the right thing; at least it seems to work for everything else.
14:40:35 <mapreduce> monoidal: Heh.
14:40:41 <mapreduce> So is this a known issue?
14:41:17 <monoidal> mapreduce: didn't experience that, this workaround prints carriage return every prompt so should work
14:41:26 <Xaphiosis> Lemmih: yes, I'm aiming for marking of volume boundaries or threshold boundaries
14:41:40 <monoidal> mapreduce: it doesn't have to work even
14:41:42 <Xaphiosis> Lemmih: but am thus far not clever enough to figure out a good way of doing it
14:41:51 <Xaphiosis> (in haskell)
14:42:41 <Lemmih> Xaphiosis: Break the list up into blocks of 10k. Process each block separately and print a tick after each block.
14:42:52 <mapreduce> monoidal: Hmm, that makes it even worse, it changes the line above, so once I hit return ghci> 3 * 2 becomes
14:42:58 <mapreduce> 6hci> 3 * 2
14:43:15 <ddarius> You would want \nghci not \r.
14:43:29 <kmc> @hoogle concatMapM
14:43:29 <lambdabot> No results found
14:43:46 <mapreduce> \nghci does what I just described but there is a blank line before the next ghci>
14:45:31 <Xaphiosis> Lemmih: that can be very hard to do in a streaming situation like this... I assume that haskell will then keep each 10k block in memory until the notification gets printed, not to mention passing it on to another stream
14:46:34 <Lemmih> Xaphiosis: Oh no, the blocks will be completely lazy. They are created and consumed as needed.
14:46:58 <Xaphiosis> Lemmih: I appreciate what you're trying to say, but I don't think my haskell experience is sufficient for your suggestion to be a solution to my problem... rather, it looks like an even more complex problem
14:47:16 <Xaphiosis> Lemmih: perhaps there is an example or further reading you could point me to such that I don't waste your time?
14:47:39 <Lemmih> Xaphiosis: I'm assuming you want to sum all the primes. If you want to pass the stream on then it /is/ a problem of lazy IO and they's no way around it.
14:48:45 <Xaphiosis> well, the long-winded part of that calculation is calculating totient chain lengths (this is project euler 214 btw), that's what I want progress for... the primes part is easy
14:49:14 <Xaphiosis> insofar as I understand the idea, I do have to "pass the stream on" in this case
14:49:15 <ddarius> The Intel documentation for xlat is bizarre.
14:51:12 <Lemmih> Xaphiosis: I'd concentrate on identifying the nature of the problem. If it is inherently lazy then lazy IO is the correct solution. If it is not inherently lazy then there's a non-lazy solution.
14:52:40 <Lemmih> Xaphiosis: The code you have pasted does not require the use of lazy IO. Other uses of similar code might.
14:53:29 <Xaphiosis> honestly, I can't tell
14:54:38 <Mitar> hmm, i am getting "Warning: -#include and INCLUDE pragmas are deprecated: They no longer have any effect" warning, but I use #include so that hsc2hs can work - is there some other way?
14:54:50 <Lemmih> Xaphiosis: No worries. The intricacies of non-strict evaluation quickly become academic and esoteric.
14:55:51 <Xaphiosis> Hmm. I will think on what you said.
14:56:16 <Xaphiosis> for now, I'm trying to approach things from a more practical context
14:56:31 <Xaphiosis> zygohistomorphic prepromorphisms (sp?) can wait a bit
14:56:34 <Xaphiosis> :)
14:56:55 <Xaphiosis> but thank you for your suggestions
14:57:32 <ddarius> *sigh*  PS/2 fixed keyboard scan code craziness but no one uses it.
15:00:41 <aristid> ddarius: huh? i think a lot of older computers still have PS/2 keyboards
15:00:55 <aristid> and most motherboards still support it
15:01:16 * wli quakes in terror of BIOS and early boot USB drivers.
15:02:13 <Saizan> Xaphiosis: in principle it's as simple as returning a structure with as many intermediate subparts as the number of intermediate results you want
15:03:41 <Xaphiosis> yes, and incidentally parallelism also lies down that path
15:04:08 <Xaphiosis> so I'll definitely look into it, but I have neither an example nor an instant comeback for you guys/gals
15:05:43 <ddarius> aristid: PS/2 defined a PS/2 scan code set but all keyboards support the AT set, so, nowadays the AT set is what is used even though the PS/2 set is much saner.
15:08:44 <aristid> ddarius: ah, i did not know that trivia
15:09:07 <aristid> ddarius: i suppose the code for the AT set was already there, so nobody saw the need for switching?
15:09:45 <Xaphiosis> ddarius: I remember my first logitech wireless keyboard which attached to a PS/2 plug... it'd send some weird battery status code which linux then interpreted as ESC ESC... I'm a vim user, that was a fail.
15:10:58 <mornfall> Xaphiosis: Better than rm -rf /^M : - )
15:11:42 <ddarius> aristid: It was just backwards compatibility, not so much laziness.
15:12:02 <Xaphiosis> mornfall: eeevil :)
15:12:42 <aristid> ddarius: backwards compatibility? huh?
15:14:09 <monochrom> backward compatibility induces laziness
15:14:50 <monochrom> existence of base-3 induces hackage packages bitrotting
15:14:51 <ddarius> aristid: Keyboard handling software already understood AT so keyboards defaulted to it.  If you were writing new keyboard handling software why not use the default that everyone supports rather than the non-default one that not everyone supports.
15:15:24 <aristid> ddarius: ah. well, i suppose that also made sense at the time
15:16:29 <monochrom> type safety = preservation + progress
15:16:39 <monochrom> backward compatibility = preservation + no progress
15:17:46 <Martty> = win32
15:17:48 <ezyang> Things Edward needs to play with: Omega 
15:17:52 <ddarius> The only real problem beyond annoying ugliness is that the AT set doesn't have a break code for the pause button, so there's no way to tell when you release the pause button.
15:17:52 <Ke> no backward compatible makes distro maintenance a pita
15:19:01 <monochrom> it takes two persons to dance the dance of preservation and no progress. <device driver writer> the keyboard emits AT code, I'll stick with it. <keyboard designer> the device driver takes AT code, I'll stick with it.
15:19:07 <aristid> ezyang: are you an edward? or did you mean somebody else?
15:19:34 <ezyang> aristid: I am Edward :-) 
15:19:47 <ezyang> not to be confused with edwardk :^) 
15:20:12 <aristid> ezyang: yes, edwardk is the more canonical edward because his nicks contains the word
15:20:32 <Mitar> this documentation is false: http://haskell.org/ghc/docs/6.12.2/html/users_guide/hsc2hs.html
15:20:41 <geheimdienst> @remember aristid edwardk is the more canonical edward
15:20:41 <lambdabot> It is forever etched in my memory.
15:20:45 <Mitar> "The C compiler to use (default: ghc)" -> The C compiler to use (default: gCc)
15:20:58 <aristid> geheimdienst: haha
15:21:05 <aristid> @quote edward
15:21:05 <lambdabot> quicksilver says: edwardk was designed as a contrivance to test boundary cases in compilers, probably by SPJ.
15:21:25 <aristid> that one is good too :D
15:23:19 <Mitar> hmm
15:23:21 <Mitar> newtype EnvHandle = EnvHandle (Ptr EnvHandle)
15:23:37 <Mitar> i get "multiple declarations" error?
15:25:01 <ezyang> haha, +1 to that quote 
15:26:14 <geheimdienst> am i the only one who half the time reads ezyang as "easy yang"?
15:26:32 <ddarius> Mitar: Are you sure?
15:26:38 <ddarius> (re the documentation)
15:26:45 <Mitar> yes
15:27:07 <ezyang> geheimdienst: No. 
15:27:09 <geheimdienst> ddarius, i dunno much about haskell, but ghc sure don't look like a c compiler to me
15:27:19 <ddarius> geheimdienst: Have you tried it?
15:27:38 * hackagebot numeric-quest 0.1.1.2 - Math and quantum mechanics  http://hackage.haskell.org/package/numeric-quest-0.1.1.2 (HenningThielemann)
15:28:02 <Mitar> http://hpaste.org/40121/multiple_declarations
15:28:04 <geheimdienst> ddarius, have i tried compiling c with ghc? have i tried filling gasoline in my bike?
15:28:14 <geheimdienst> it didn't occur to me
15:28:20 <ddarius> geheimdienst: GHC compiles C fine.
15:28:27 <Lemmih> Mitar: hsc2hs calls GHC which then calls gcc.
15:28:32 <Mitar> setting it to ghc makes hsc2hs fail
15:28:39 <Mitar> if i set -c gcc it works fine
15:28:44 <Mitar> if i set -c ghc it does not
15:28:51 <Mitar> so: default is not ghc ;-)
15:28:54 <geheimdienst> okay i didn't expect that at all
15:28:57 <Mitar> because by default it works
15:29:05 <Lemmih> Mitar: You need to call it with the right arguments, I believe.
15:29:33 <monochrom> $ hsc2hs -v whee.hsc 
15:29:33 <monochrom> Executing: /usr/bin/gcc -c -I/usr/local/haskell-platform-2010.2.0.0/lib/ghc-6.12.3/include/ whee_hsc_make.c -o whee_hsc_make.o
15:29:33 <monochrom> Executing: /usr/bin/gcc whee_hsc_make.o -o whee_hsc_make
15:29:33 <monochrom> Executing: ./whee_hsc_make  >whee.hs
15:29:52 <monochrom> So indeed gcc is called directly rather than through ghc first.
15:29:57 <Lemmih> Oh dear.
15:30:22 <monochrom> However you could "ghc -c whatever.c" just fine
15:31:01 <Mitar> true, but default is GCC not GHC as it is in documentation
15:31:14 <Peaker> ghc can build .c files? Calls gcc?
15:31:18 <avenge> I fully understood hsc2hs by just reading the file /usr/lib/ghc-6.12.3/template-hsc.h.
15:31:20 <monochrom> Yes
15:32:10 <mornfall> hsc2hs is somewhat of an abominatio...
15:32:12 <mornfall> +n
15:33:36 <Peaker> It can't cross-compile, iiuc.
15:33:38 <monochrom> hsc2hs exemplifies how to write a c program to write a haskell program
15:34:08 <monochrom> the next incarnation, template-hsc2hs, exemplies how to write a haskell program to write a c program to write a haskell program
15:35:15 <avenge> I don't think hsc2hs is really all that bad for what it is... It's really just super simple.
15:35:19 <aavogt> fix hsc2hs
15:35:29 <geheimdienst> monochrom, could you please come up with a quine for this setup? a haskell program that writes a c program that writes a haskell program which is the original one again
15:35:37 <avenge> I just don't like mixing hsc and real haskell code, so use a separate hsc module that only defines constants.
15:35:52 <monochrom> I am too dumb to do quines.
15:36:50 <monochrom> but I have a deep stack, so I can read and write multiple-meta-level statements.
15:37:34 <Mitar> is there anybody here who could fix that documentation bug?
15:37:38 <Mitar> or should i open a ticket?
15:37:49 <monochrom> (or deeply nested modal statements if you like)
15:39:16 <mornfall> avenge: Even though it's super simple, it can give you serious WTF on windows.
15:40:11 <avenge> mornfall: ah... I don't use windows, but I believe you.  On Unix it is relatively straight-forward.  The hard part was just realizing that I just had to read that header (instead of hunting around for documentation).
15:40:35 <mornfall> avenge: What happened is that we enabled test-framework dependency in darcs on our windows host, which in turn lists ansi-terminal as a dependency
15:40:52 <mornfall> avenge: ansi-terminal has msvcrt in its extra-libs.
15:41:09 <mornfall> avenge: Which somehow cabal percolates to a completely unrelated hsc2hs call in darcs
15:41:25 <mornfall> avenge: Which makes hsc2hs produce a foo_make.exe which segfaults on startup.
15:41:26 <mornfall> COOL
15:42:08 <mornfall> (It was rather unpleasant to debug for sure.)
15:42:21 <avenge> mornfall:  MTF indeed.  Is cabal somehow passing libraries to hsc2hs?
15:42:31 <avenge> WTF
15:42:55 <mornfall> avenge: It is, and I'm not sure but it might be actually required to do that.
15:43:09 <mornfall> avenge: Since the foo_make.exe thingy may need the symbols to work.
15:43:33 <avenge> mornfall:  Don't understand why foo_make.exe would need any symbols other than printf.
15:43:59 <geheimdienst> flip "WTF" = "M⊥Ł"
15:44:01 <mornfall> avenge: Is it only ever doing sizeof on types and neveols?
15:44:04 <monochrom> ♥ JMacro, sounds nice
15:44:16 <mornfall> Wow.
15:44:20 <mornfall> Never symbols, I typed.
15:44:26 <mornfall> How neveols appeared, I have no idea.
15:44:36 <Mitar> how do I convert Ptr a to a so that I can access data's fields?
15:44:51 <avenge> mornfall: I think pretty much.  It uses sizeof, offsetof, and stuff, but those are all just pre-processor macros.
15:45:09 <mornfall> avenge: You can apply sizeof to variables in C.
15:45:22 <aristid> avenge: sizeof is not a preprocessor macro in C
15:45:28 <mornfall> Although I guess it works statically anyway.
15:45:38 <avenge> I understand, but you don't need to link against a variable to get its size.
15:45:42 <Mitar> peek
15:46:15 <mornfall> Right, so in that case I guess that the libraries are completely superfluous.
15:46:42 <avenge> Here is a valid C program:
15:46:42 <avenge> extern int foo;
15:46:42 <avenge> int main () { return sizeof (foo); }
15:46:42 <avenge>  
15:46:45 <avenge> Links just fine.
15:46:59 <avenge> (without any library containing foo).
15:47:26 <geheimdienst> foo me once, shame on you, foo me twice, ...
15:48:05 <mornfall> avenge: Yeah, that's all because I'm 2/3 asleep.
15:48:13 <mornfall> I should know better.
15:48:24 <mornfall> Well, goodnight. :) Hopefully I won't dream of anything C related.
15:48:43 <Martty> void pointer
15:48:45 <Martty> uhhhhh 
15:49:19 <Member15> -.-
15:49:36 <ddarius> > 80*50
15:49:37 <lambdabot>   4000
16:08:54 <Mitar> is Ptr (peek (Ptr a)) == Ptr a?
16:09:18 <Mitar> if i make peek of a pointer and then make pointer again, do i get the same pointer?
16:09:24 <hpc> you should
16:09:43 <hpc> &(*(&foo)) == &foo in C
16:10:15 <ulfdoz> ugly, even in C.
16:11:40 <Mitar> hmm, yes, but if fact it seems there is no Ptr constructor
16:11:52 <Mitar> so you cannot get pointer back once you peek it off
16:12:34 <hpc> @hoogle a -> Ptr a
16:12:34 <lambdabot> Foreign.ForeignPtr unsafeForeignPtrToPtr :: ForeignPtr a -> Ptr a
16:12:34 <lambdabot> Prelude id :: a -> a
16:12:34 <lambdabot> Data.Function id :: a -> a
16:12:48 <hpc> heh
16:13:40 <rschnck> Do you guys think it would be possible to write a function that gives the list of all subsets in a list (i.e. thisfunction [3,4] =[[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
16:13:47 <rschnck> Oops, sorry. Pressed neter.
16:14:08 <Botje> rschnck: yes. that's certainly possible :)
16:14:10 <rschnck> So to write that function...but without recursion..and using at least one of the following functions: map, foldr, filter, zipwith
16:14:14 <rschnck> Botje: I know, I wrote it already :P
16:14:25 <Itkovian> Any idea where I should look for what's causing this?
16:14:26 <Itkovian> Irrefutable pattern failed for pattern ((source@(sourcePlanet,
16:14:27 <Itkovian>                                 sourceAvailableShips)) : unaffectedSources)
16:14:32 <Cale> > subsequences [3,4,5]
16:14:33 <lambdabot>   [[],[3],[4],[3,4],[5],[3,5],[4,5],[3,4,5]]
16:14:34 <Botje> > foldM (const [True, False]) [3..5]
16:14:35 <lambdabot>   Couldn't match expected type `b -> m a'
16:14:35 <lambdabot>         against inferred type `[GHC...
16:14:44 <alej> Cale I think he wanted this
16:14:44 <Botje> > filterM (const [True, False]) [3..5]
16:14:45 <lambdabot>   [[3,4,5],[3,4],[3,5],[3],[4,5],[4],[5],[]]
16:14:55 <alej> > reverse $ subsequences [3,4,5]
16:14:56 <lambdabot>   [[3,4,5],[4,5],[3,5],[5],[3,4],[4],[3],[]]
16:14:56 <geheimdienst> @src subsequences
16:14:56 <lambdabot> Source not found. My mind is going. I can feel it.
16:15:06 <rschnck> I can't use functions like filterM.
16:15:22 <rschnck> Just map, foldr, filter, zipwith. And some basic thinkings like ++, :, +, -, etc.
16:15:25 <aavogt> > let x:xs = [] in x
16:15:25 <lambdabot>   *Exception: <interactive>:1:137-145: Irrefutable pattern failed for pattern...
16:15:26 <rschnck> things*
16:15:33 <Itkovian> It was a simple sortBy on a list that's guaranteed not to be empty, as I matched the epty pattern earlier
16:15:36 <Botje> rschnck: well, what does the recursive version look like?
16:15:41 <aavogt> Itkovian: it's likely that you have an empty list like that ^^
16:15:48 <Cale> rschnck: Well, there's a pretty straightforward way to do it with recursion and map
16:15:55 <Itkovian> let me paste the source, sec.
16:16:11 <medfly> rschnck, well, #haskell said it is simple.
16:16:24 <medfly> rschnck, which means you're fucked ;-)
16:16:29 <rschnck> Botje: http://paste.ubuntu.com/500631/
16:16:32 <rschnck> That's how I did it.
16:16:38 <Cale> medfly: He said he already did it :)
16:16:42 <medfly> oh, okay.
16:16:44 <medfly> damn!
16:16:58 <Cale> rschnck: Yeah, that's the one
16:17:09 <rschnck> I'm trying to do it without using recursion except for the recursive processes defined in map, foldr, filter, and zipwith.
16:17:10 <Itkovian> aavogt: http://hpaste.org/40122/irrefutable_pattern
16:17:16 <eturpin> Anyone know how I could do this: Just 1 + Just 2
16:17:20 <Botje> rschnck: if you squint a bit you can see a foldr there
16:17:29 <Botje> eturpin: liftM2 (+)
16:17:45 <hpc> > (+) <$> Just 1 <*> Just 2
16:17:46 <lambdabot>   Just 3
16:17:57 <geheimdienst> > fmap (+) [Just 2, Just 3]
16:17:58 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t))
16:17:58 <hpc> same thing, funnier looking
16:17:58 <lambdabot>    arising from a use of...
16:18:01 <Cale> rschnck: Want me to give a foldr solution?
16:18:13 <rschnck> Cale: I'd rather you hint at it so I can figure it out myself :P
16:18:22 <Botje> rschnck: every "step" of the foldr takes an element and creates two copies of the "given" list, one with x prepended and one without
16:18:36 <Cale> rschnck: Well, look at the definition of foldr and try to match the parts of it with your existing recursive version
16:18:42 <eturpin> ok, thanks
16:18:52 <rschnck> Er, I should add I have to use my definition of foldr.
16:19:01 <Cale> foldr f z [] = z
16:19:07 <rschnck> http://paste.ubuntu.com/500632/
16:19:10 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
16:19:13 <Botje> rschnck: it's really better if you add on these constraints up front
16:19:28 <Cale> So, it's pretty clear what z ought to be at least.
16:19:29 <Philonous> > foldr (\x xs -> [[x]] ++ map (x:) xs ++ xs) [] [1..3]
16:19:30 <lambdabot>   [[1],[1,2],[1,2,3],[1,3],[2],[2,3],[3]]
16:19:49 <rschnck> Philonous: o.O
16:20:11 <Cale> Philonous is close
16:20:20 <rschnck> Doesn't include the empty set :P
16:20:22 <Cale> The z parameter is a little off there
16:20:34 <rschnck> Although you could just..arbitarily add it on
16:20:40 <Cale> foldr f z [] = z
16:20:52 <rschnck> What does \x xs -> [[x]] mean?
16:20:55 <Cale> So z should always be how you want the function to respond to the empty list
16:21:00 <aavogt> Itkovian: name shadowing is confusing
16:21:03 <rschnck> What's ->?
16:21:04 <Itkovian> aavogt: ok, bug found:-)
16:21:13 <rschnck> and what's \x?
16:21:18 <Cale> rschnck: (\x -> x^2) is the function which takes a number x, and squares it
16:21:26 <Itkovian> thinking on how to explain it to somebody helps :-)
16:21:27 <Cale> > map (\x -> x^2) [1,2,3,4,5]
16:21:28 <lambdabot>   [1,4,9,16,25]
16:21:31 <rschnck> Oh.
16:21:39 <Philonous> rschnck: \ is lambda, \x -> e means the function that takes one argument, binds it to x and returns e (Which can include x, of course).
16:21:44 <geheimdienst> func x y = ... is the same as \x y -> ...
16:21:44 <medfly> > (\x xs-> [[x]]) [1,2,3]
16:21:44 <Cale> rschnck: More than one parameter can come before the ->
16:21:45 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> [[[t1]]])
16:21:45 <lambdabot>    arising from a u...
16:21:48 <medfly> ;o
16:21:58 <Philonous> rschnck: Or put differently: \x ->e = let f x = e in f
16:22:25 <rschnck> But what about \x xs, then?
16:22:33 <Cale> rschnck: Two parameter function
16:22:40 <rschnck> How does that work?
16:22:48 <medfly> ?
16:22:50 <Philonous> rschnck: \a b -> e = \a -> \b -> e
16:22:52 <Cale> > (\x y -> x^2 + y^2) 3 4
16:22:53 <lambdabot>   25
16:22:55 <rschnck> Ah, okay.
16:22:59 <rschnck> So it's going through the list.
16:23:22 <rschnck> Which means the `->` operation is...probably defined recursively?
16:23:33 <Cale> rschnck: -> is part of the syntax
16:23:45 <rschnck> Oh. Then I can use it.
16:23:46 <medfly> oh NOEZ, syntax!
16:23:51 <hvr> how can I set ghci's .hs search path?
16:23:51 <Cale> \[patterns] -> [expression]
16:24:04 <aavogt> hvr: -ipath
16:24:08 <medfly> it's just syntactic sugar. you can go all defining a function too.
16:24:13 <aavogt> with path being whatever you like
16:24:49 <geheimdienst> i like turtles
16:25:32 <zachk> haskelll needs a nice turtle graphics library 
16:26:12 <alej> that sounds like a fun project
16:26:14 <hpc> @hoogle turtle
16:26:14 <alej> i guess
16:26:14 <lambdabot> No results found
16:26:43 <hpc> you can make some neat stuff with turtles
16:26:47 <alej> soup
16:26:54 <hpc> lol
16:28:15 <Philonous> > foldr (\x xs -> map (x:) xs ++ xs) [[]] [1..3] 
16:28:16 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
16:28:55 <lucca> going with 2d turtles, 3d, or... beyond?
16:29:07 <aavogt> > foldr (\x -> (++) <*> map (x:)) [[]] [1..3]
16:29:08 <lambdabot>   [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
16:29:40 <rschnck> What's the "->" called in Haskell?
16:29:49 <hpc> arrow, perhaps?
16:29:54 <Zao> Depends on context.
16:30:11 <Zao> If in a lambda, it's "the bit that separates the variables from the body"
16:30:12 <rschnck> I want to read up about it
16:30:20 <aavogt> @where report
16:30:20 <lambdabot> http://www.haskell.org/onlinereport/
16:31:27 <rschnck> :r
16:31:29 <rschnck> Oops, sorry :(
16:31:40 <geheimdienst> rschnck: "->" in a lambda is like the "=" in: func x y = blah
16:31:45 <hpc> [sudo password for user rschnck:]
16:32:05 <rschnck> hpc: I've done that before =/
16:32:19 <rschnck> geheimdienst: Ah, just got it to work. Thanks.
16:32:27 <geheimdienst> it just separates the parameters from the function body. not sure if there is anything to "read up" about it
16:32:29 <geheimdienst> :)
16:32:34 <hpc> on one of the other channels i am on, that's a macro for any line consisting of a single word that appears on $PATH
16:34:10 <rschnck> Well how do you apply lamdas to type signatures?
16:34:31 <zachk> ?
16:34:43 <hpc> you don't
16:35:03 <zachk> if you want that define a seperate function or use a where clause 
16:35:13 <rschnck> http://www.haskell.org/pipermail/beginners/2009-February/001044.html
16:35:19 <rschnck> Well look at the first example
16:35:36 <hvr> aavogt: thx
16:36:50 <hpc> :t let foo = \(x,y) = x==y in foo
16:36:51 <lambdabot> parse error on input `='
16:36:59 <hpc> :t let foo = \(x,y) -> x==y in foo
16:37:00 <lambdabot> forall t. (Eq t) => (t, t) -> Bool
16:37:19 <hpc> i don't see where he is getting ((),()) -> Bool as a type
16:37:23 <alej> interesting
16:37:40 <alej> i typed it into ghci on my computer and got ((),()) -> Bool
16:37:46 <alej> 6.12.1
16:38:00 <alej> however, if i type in what you put in
16:38:05 <alej> :t let … in foo
16:38:06 <lambdabot> parse error on input `???'
16:38:15 <alej> then i get Eq t => (t,t) -> Bool
16:38:38 <Botje> alej: yes. that's the dreaded monomorphism restriction
16:38:38 <hpc> wtf, i see it too
16:39:01 <alej> so i gathered from the e-mail, but i dont know what that means
16:39:12 <aristid> :set -XNoMonomorphismRestriction
16:39:13 <aristid> in ghci
16:39:17 <aristid> and you're golden
16:39:23 <hpc> it means a value can't be polymorphic
16:39:43 <hpc> instead of having foo :: a -> b, you have to have a concrete type for a and b
16:39:47 <alej> how come the let statement has a polymorphic type then
16:40:51 <aristid> alej: the monomorphism restriction only applies to some declarations (top-level and something else iirc) and can be circumvented anyways by manually giving the type
16:41:12 <alej> hm ok
16:41:14 <Saizan> > let foo = show in (foo 'a', foo ())
16:41:14 <lambdabot>   ("'a'","()")
16:41:40 <Saizan> without NoMR that'd be an error
16:41:52 <Philonous> rschnck: To understand \ and -> you may want to grab a textbook on lambda calculus. there, \ usually is lambda and -> is . (dot). 
16:42:20 <Saizan> so the MR does apply to let
16:42:47 <alej> i can understand why you wouldn't want a value to be polymorphic, but i dont understand why this applies to 'let foo = (==)' and not 'let foo = (==) in foo'
16:42:49 <alej> in ghci
16:43:07 <rschnck> Philonous: Is there a way to do this without the lambda business?
16:43:19 <rschnck> I'm interested, but I simply don't have the time at the moment to invest in it.
16:43:39 <Saizan> alej: yeah, that's quite obscure, :t is probably performing a generalization over the free type variables at the end
16:44:06 <monochrom> the restriction is triggers on definitions looking like "identifier = blah" and not "identifier v = blah"
16:44:32 <monochrom> it is indifferent to "top level", "let", "where"
16:44:41 <Saizan> right
16:45:08 <Saizan> but "let foo = (==) in foo" is of the first type, but if you ask ghci for :t you don't get anything indicating the type is not polymorphic
16:45:33 <alej> is it some kind of laziness issue?
16:45:39 <Saizan> no
16:45:51 <alej> right that was silly
16:45:52 <alej> hmm
16:46:06 <monochrom> when you enter into ghci "let foo = (==)" there is no error. yet.
16:46:29 <monochrom> the first use doesn't run into error either. yet.  "foo () ()"
16:46:30 <geheimdienst> rschnck: a lambda is just a function which doesn't have a name. consider: "print 42" does the same as "let x = 42 in print 42". similarly, "map (\x -> x*x) [...]" does the same as "let f x = x*x in map f [...]". the lambda just lets you avoid having to make up a name for the function
16:46:52 <rschnck> geheimdienst: Oh.
16:46:53 <monochrom> after that, try "foo 3 4" and be horrified.
16:47:07 <Saizan> well, the rationale for the MR has to do with the sharing you expect from laziness, but laziness doesn't interfere with the typing rules
16:47:09 <rschnck> geheimdienst: Okay, let me mess around a bit in ghci
16:47:10 <alej> similarly, if you do 'let foo = (==)'
16:47:12 <alej> and then type foo
16:47:14 <rschnck> I'll see where I can get with it o.O
16:47:18 <alej> it complains there is no Show instance, naturally
16:47:19 <monochrom> that is the true face of monomorphism. one use fixes the type.
16:47:24 <alej> whereas if you do let foo = (==) in foo
16:47:25 <Saizan> monochrom: are you suggesting that foo takes the type of the first use? because that's false
16:47:31 <alej> you immediately get the complaint about Show
16:47:38 <alej> so i think the difference there probably explains it
16:47:50 <Saizan> monochrom: at the ghci prompt, i mean
16:48:11 <monochrom> I think I am suggesting that. But I verified it with ghci before I spoke.
16:48:20 <monochrom> "No instance for (Num ())"
16:48:34 <alej> well
16:48:46 <monochrom> and foo "x" "x" --> Couldn't match expected type `()' against inferred type `[Char]'
16:48:47 <Saizan> monochrom: that'd happen regardless of the first use, it's simply defaulting to () from the start
16:48:49 <alej> that's not really the case, since if you do 'let foo = (==)' then foo 1 2 it complains
16:48:58 <monochrom> oh, I luck out? :)
16:49:03 <Saizan> yeah
16:49:08 <alej> you needed to test more than the one type
16:49:14 <monochrom> I see.
16:49:16 <Saizan> let foo = (==); :t foo  :)
16:49:29 <alej> yes or that
16:49:29 <alej> hehe
16:49:55 <monochrom> I was afraid to enter ":type foo" because I was afraid of ":type" having side effects of fixing types
16:50:36 <rschnck> http://paste.ubuntu.com/500643/
16:50:38 <rschnck> What does this mean?
16:51:03 <Zao> @type (:)
16:51:04 <monochrom> anyway, "let x = y" at ghci fully enjoys the monomorphsim restriction just fine.
16:51:04 <lambdabot> forall a. a -> [a] -> [a]
16:51:11 <Zao> @type (1:)
16:51:12 <lambdabot> forall t. (Num t) => [t] -> [t]
16:51:22 <Lemmih> rschnck: map (1:) [2,3,4] => [1:2, 1:3, 1:4] which doesn't make sense.
16:51:22 <aavogt> > map (\x -> [1,x]) [1,2,3]
16:51:23 <lambdabot>   [[1,1],[1,2],[1,3]]
16:51:27 <Zao> rschnck: What operator did you mean?
16:51:34 <Saizan> monochrom: ":t let foo = show in foo" is the one that gives puzzling output
16:51:35 <Zao> Or rather, what operation?
16:51:41 <zachk> this aint scheme/lisp 
16:52:07 <alej> Saizan why is that puzzling
16:52:09 <geheimdienst> rschnck, (:) lets you add something to a list, e.g.:
16:52:16 <geheimdienst> > 42 : [37, 11]
16:52:16 <monoidal> rschnck: "No instance for Num [a]" means that you attempted to treat a number as a list. Try (1:) [2,3,4] or map (1:) [[2],[3],[4]]
16:52:16 <lambdabot>   [42,37,11]
16:52:22 <co_dh> In the category of preorder, is every arrow monic?
16:52:22 <alej> Saizan or rather, more puzzling than the earlier problem
16:52:29 <rschnck> geheimdienst: I know...I was just trying to figure out how myFoldr (\x xs -> [[x]] ++ map (x:) xs ++ xs) [] (x:xs) works
16:52:35 <rschnck> it has map(x:) xs in it.
16:52:52 <monoidal> map (1:) [[2],[3]]
16:52:54 <monoidal> > map (1:) [[2],[3]]
16:52:54 <lambdabot>   [[1,2],[1,3]]
16:52:59 <monochrom> I see. But ":type let whee = show in (whee 3, whee ())" shows you the true story.
16:53:01 <geheimdienst> yes, the difference must be that xs contains a list of lists ...
16:53:13 <rschnck> How does xs contain a list of lists, though?
16:53:14 <geheimdienst> > map (1:) [[2,3], [5,6]]
16:53:14 <lambdabot>   [[1,2,3],[1,5,6]]
16:53:42 <Saizan> alej: all the other behaviour follows from the monomorphism restriction and ghci's extended defaulting
16:54:15 <alej> i mean, is it different from let foo = (==) in foo
16:54:19 <alej> in terms of interest
16:54:28 <alej> seems the same, so i didn't know if that's what you meant
16:54:48 <rschnck> Where did we convert xs into a list of lists?
16:54:53 <rschnck> I see how we have [[x]]
16:55:01 <rschnck> But how did we get a list of lists out of xs?
16:55:11 <hpc> map return?
16:55:15 <aristid> :t (1:)
16:55:16 <lambdabot> forall t. (Num t) => [t] -> [t]
16:55:18 <Saizan> alej: ah, no, it's the same
16:55:19 <monochrom> > map (\x -> [1,x]) [2,3,4]
16:55:19 <lambdabot>   [[1,2],[1,3],[1,4]]
16:55:27 <monochrom> is that what you want?
16:55:53 <rschnck> I was just trying to understand the function I pasted above
16:55:59 <monochrom> in any case, [ (1:2), (1:3), (1:4) ] makes no sense.
16:56:04 <rschnck> Yes, I know.
16:56:10 <monochrom> the pasted function makes no sense either.
16:56:16 <rschnck> Oh..
16:56:20 <aristid> :t return . (1:)
16:56:21 <lambdabot> forall (m :: * -> *) t. (Monad m, Num t) => [t] -> m [t]
16:56:26 <rschnck> Well, that clears things up considerably.
16:56:30 <monochrom> type error => makes no sense. drill that into your mind.
16:56:31 <ddarius> co_dh: Yes.
16:56:53 <co_dh> ddarius: thanks, that confirmed what I thought.
16:57:24 <co_dh> Does all the monic arrows formed another category ? since composition preserve monic .
16:57:52 <Saizan> alej: considering how Hindley-Milner polymorphism works (which is the basis for haskell's type system) :t's behaviour here is not that puzzling either, even if inaccurate
16:58:21 <alej> ill take your word for it
16:58:26 <ddarius> co_dh: Yes.
16:58:38 <alej> maybe if i get into graduate school i can study that as i plan to ;)
16:58:48 <alej> i suppose i can either way
16:59:04 <Saizan> it's quite approachable :)
16:59:27 <aavogt> Saizan: so :t should apply MR to expressions before showing you the type?
17:02:52 <monochrom> with ":type let foo = show in foo", ghci internally knows that the monomorphism restriction applies. but since you don't use foo there, the type variable is still uninstantiated though monomorphic. so how should it be displayed? here is the true story:
17:02:53 <Saizan> aavogt: i don't think that'd be much better
17:03:28 <monochrom> originally, it was proposed that the monomorphic type variable be coloured specially
17:03:30 * ddarius doesn't know why there are fireworks going off.
17:03:31 <Saizan> yeah, it's all to prevent users from seeing free type variables (or are they meta-vars?) :)
17:03:37 <alej> ddarius you in cambridge?
17:03:43 <ddarius> alej: Near it.
17:03:51 <alej> ddarius i'm in cambridge, been trying to figure out wtf is going on
17:04:13 <monochrom> then some 1970s terminal users say their terminal are monochromatic, and the colouring becomes funny escape codes in their 1970s terminals.
17:04:28 <ddarius> @google history of IRC
17:04:31 <lambdabot> http://daniel.haxx.se/irchistory.html
17:04:31 <lambdabot> Title: History of IRC (Internet Relay Chat)
17:05:00 <monochrom> since they are the vocal minority, the ghc people conceded to applying the monochromatic restriction, that is, to not specially colour the monomorphic type variable.
17:06:12 <Saizan> monochrom: is that the end?:)
17:06:36 <Saizan> because in that case you're missing why with :set -fglasgow-exts you'll even get foralls
17:06:37 <ddarius> alej: Tell me if you figure it out.
17:06:49 <monochrom> there is a sequel. the ghc people also considered bold, italic... but the same vocal minority objected it on the same 1970s reason, and this led to the monotypographic restriction.
17:06:50 <alej> ddarius sounds like it stopped
17:07:09 <ddarius> alej: Yeah, but it was going last night too and I'm just curious why it happened.
17:07:23 <alej> hmm it was? i didn't even notice. and i was outside in central square
17:07:45 <aavogt> nobody considered using different letters, or some prefix?
17:07:46 <monochrom> oh haha, well, my true story is a joke, an excuse to say monochromatic restriction. :)
17:07:49 <ddarius> monochrom: GHC could do it in reversed colors.
17:10:17 <Saizan> anyhow, without the generalization, ":t map (+1)" would also return a type with free/monomorphic type vars
17:12:07 <Saizan> (in agda you get them as _<some number>, prolog style)
17:12:27 <ddarius> How apropos
17:16:31 <monochrom> that's neat
17:17:01 <rschnck> I'm still rather stuck on this.
17:17:36 <monochrom> eh? don't try to figure out an erroneous program.
17:17:51 <rschnck> I'm not anymore, I'm tring to figure out some alternative way to do it
17:18:03 <monochrom> > map (\x -> [1,x]) [2,3,4]
17:18:04 <lambdabot>   [[1,2],[1,3],[1,4]]
17:18:08 <monochrom> does that help?
17:18:19 * benmachine applies -XNoMonochrom
17:18:20 <rschnck> One sec
17:25:15 <aristid> > let f [] = []; f (x:xs) = map (\y -> [x,y]) xs in f [1,2,3,4]
17:25:16 <lambdabot>   [[1,2],[1,3],[1,4]]
17:25:36 <aristid> :t let f [] = []; f (x:xs) = map (\y -> [x,y]) xs in f
17:25:37 <lambdabot> forall a. [a] -> [[a]]
17:26:21 <rschnck> Erm. I'm still having difficulty.
17:26:42 <rschnck> This is to convert this: http://paste.ubuntu.com/500658/
17:26:46 <rschnck> into a non-recursive function..right?
17:26:51 <rschnck> Presumably using foldr and map
17:27:07 <rschnck> But I'm having difficulty getting my around foldr using map in its function
17:27:24 <rschnck> The most I ever do is something like foldr (+) 0 [1,2,3] = (1+(2+(3+0)))
17:28:03 <rschnck> my head around*
17:28:44 <koninkje> rschnck: you mean map(foldr f z) ?
17:28:51 <koninkje> er, the other way I mean
17:28:55 <Botje> rschnck: map is just another function
17:28:59 <rschnck> no foldr (map f z)
17:29:00 <rschnck> Right
17:29:18 <rschnck> I'm having difficulty visualizing how it'd behave though
17:29:35 <Botje> rschnck: if you already have a value for twosetsgeneral xs
17:29:39 <koninkje> Well, foldr takes (a->b->b,b) to [a] -> b right?
17:29:41 <Botje> what does the function look like then?
17:30:05 <koninkje> so if the a->b->b is map f, then that means a must be [a']
17:30:18 <rschnck> koninkje: my foldr is defined like this: http://paste.ubuntu.com/500668/
17:30:35 <Botje> that doesn't matter :p
17:30:40 <rschnck> Oh :<
17:30:40 <rschnck> Well
17:30:50 <koninkje> rschnck: yea, same thing
17:30:51 <Botje> but since you pasted it:
17:30:52 <rschnck> I can see that if you had 
17:31:12 <Botje> notice how f is called with an element from the list, and *the result of calling foldr f on the rest of the list*
17:31:34 <koninkje> :t \f z -> foldr (map f)
17:31:35 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `[b1]'
17:31:35 <lambdabot>     In the first argument of `foldr', namely `(map f)'
17:31:35 <lambdabot>     In the expression: foldr (map f)
17:31:35 <rschnck> ([1],[2],[3],[4]) and then you concatenated that and mapped [1],[2],[3],[4]
17:31:43 <koninkje> :t \f z -> foldr (map f) z
17:31:43 <lambdabot>     Couldn't match expected type `b -> b' against inferred type `[b1]'
17:31:44 <lambdabot>     In the first argument of `foldr', namely `(map f)'
17:31:44 <lambdabot>     In the expression: foldr (map f) z
17:31:44 <rschnck> You'd slowly get something that resembles a list of subsets
17:31:46 <rschnck> but with duplicates.
17:31:50 <koninkje> lambdabot--
17:32:00 <Botje> so in your case, that's the subsequences of the list after the current element
17:32:29 <rschnck> Huh?
17:32:46 <rschnck> Oh wait
17:33:07 <aristid> :t \x ys -> map (x:) ys ++ ys
17:33:08 <lambdabot> forall a. a -> [[a]] -> [[a]]
17:33:12 <aristid> @pl \x ys -> map (x:) ys ++ ys
17:33:13 <lambdabot> join . ((++) .) . map . (:)
17:33:29 <aristid> lambdabot: heh, that does look relatively complex
17:33:33 <rschnck> I'm confused =[
17:33:50 <Botje> rschnck: look at the second line of your twosetsgeneral
17:33:52 <rschnck> I don't see how you could possibly avoid getting tons of duplicates
17:34:07 <Botje> you want to get to a form like f x (foldr f empty xs)
17:34:26 <rschnck> Wait what's the f x there for?
17:34:49 <Botje> you want to refactor your recursive function into a form amenable to foldr
17:35:11 <Botje> so atm we have (map (x:) (twosetsgeneral xs)) ++ twosetsgeneral xs
17:35:17 <rschnck> Right
17:35:25 <Botje> let's capture that twosetsgeneral xs into a variable:
17:35:45 <Botje> let rest = twosetsgeneral xs in map (x:) rest ++ rest
17:36:30 <Botje> now look back at that foldr
17:36:35 <aristid> rschnick: is this correct? twosetsgeneral [1,2,3,4] = [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4],[2],[3,4],[3],[4],[]]
17:36:43 <Botje> you see that f is called with an x, and with the result of calling foldr .... on xs
17:36:53 <rschnck> aristid: Yes.
17:36:55 <aristid> if so, i have a solution :)
17:37:07 <aristid> rschnck: but you should try to figure it out yourself:)
17:37:09 <Botje> but twosetsgeneral xs is defined as foldr .... xs
17:37:21 <rschnck> aristid: Which is my itnention :P
17:37:26 <aristid> Botje: <Botje> you want to get to a form like f x (foldr f empty xs)
17:37:30 <aristid> Botje: this helped me too :D
17:37:31 <Botje> so the variable "rest" here, is actually the second parameter to f in the call f x (foldr ...)
17:38:04 <rschnck> I don't understand what twosetsgeneral xs in map(x:) rest means
17:38:14 <rschnck> what does the "in" bit mean
17:38:17 <Botje> oh, you don't know let-forms yet?
17:38:20 <rschnck> No.
17:38:23 <Botje> ah.
17:38:31 <Botje> do you know lambdas?
17:38:37 <rschnck> Barely.
17:38:41 <Botje> okay
17:38:48 <Botje> well, a let makes a temporary variable
17:38:53 <Botje> visible only in the block after "in"
17:38:54 <rschnck> Okay, that'd be helpful
17:39:05 <Botje> let a = b + c in print a
17:39:09 <Botje> something like that
17:39:23 <rschnck> So print a = b +c?
17:39:34 <rschnck> No, wait
17:39:40 <Botje> print a === print b + c
17:39:47 <rschnck> Oh
17:39:47 <Botje> well, (b + c), but who's counting
17:39:47 <rschnck> Right
17:39:50 <rschnck> Okay
17:40:08 <Botje> so:
17:40:12 <Botje> we want to get (map (x:) (twosetsgeneral xs)) ++ twosetsgeneral xs
17:40:16 <Lemmih> ?karma Botje 
17:40:17 <lambdabot> Botje has a karma of 3
17:40:19 <Lemmih> ^^ She is.
17:40:25 <Botje> into a form f x (foldr f empty xs)
17:40:52 <Botje> you already know (from your first definition of twosetsgeneral) that empty is [[]]
17:40:58 <rschnck> Right
17:41:09 <Botje> likewise, x and xs are already bound by your pattern match
17:41:48 <monoidal> @djinn (m (m x) -> m x) -> (a -> b) -> (m a -> m b) -> (x -> m y) -> (y -> m z) -> (x -> m z)
17:41:48 <lambdabot> -- f cannot be realized.
17:41:50 <Botje> since we're trying to define twosetsgeneral list as foldr f empty list, the two are interchangeable, right?
17:41:58 <monoidal> @djinn (m (m x) -> m x) -> ((a -> b) -> (m a -> m b)) -> (x -> m y) -> (y -> m z) -> (x -> m z)
17:41:58 <lambdabot> -- f cannot be realized.
17:42:11 <aristid> monoidal: that looks fearsome
17:42:15 <Botje> since in the end you'll write twosetsgeneral list = foldr f [[]] list, and throw away your recursive definition
17:42:16 <rschnck> Botje: Why
17:42:23 <rschnck> Oh, okay
17:42:24 <rschnck> Right
17:42:26 <Botje> that's the point of the exercise
17:42:29 <rschnck> Because we say (x:xs) for recursive reasons
17:42:31 <Botje> so the two are equivalent
17:42:35 <aristid> secs for the win
17:42:40 <rschnck> Okay
17:42:45 <Botje> so, looking at your line of code again:
17:42:52 <Botje> (map (x:) (twosetsgeneral xs)) ++ twosetsgeneral xs
17:42:57 <monoidal> aristid: i'm writing Kleisli composition in Omega :) It's type will be Monoid EndHask m -> Monoid Graph (Kleisli m)
17:43:04 <Botje> this has two recursive calls to twosetsgeneral xs
17:43:12 <Botje> let's use a let-form so we only do one call:
17:43:18 <monoidal> aristid: Monoid Hask = monoid, Monoid EndHask = monad, Monoid Graph = category.  isn't it nice? :)
17:43:21 <aristid> monoidal: is omega as cool as that guy claims?
17:43:30 <Botje> let rest = twosetsgeneral xs in map (x:) rest ++ rest
17:43:40 <Botje> i simply took out the call and put it in a local variable
17:43:44 <aristid> monoidal: what is Graph?
17:43:56 <rschnck> so that's the same as map (x:) twosetsgeneral (xs) ++ twosetsgeneral xs
17:43:57 <monoidal> aristid: I defined every of those symbols
17:44:00 <Botje> yes
17:44:04 <rschnck> Okay
17:44:19 <rschnck> and the rest here
17:44:26 <rschnck> Is the first part of the folding by foldr, right?
17:44:29 <rschnck> "folding"
17:44:34 <monoidal> aristid: the interface rather sucks, many syntactic sugar is missing, but i can feel The Power of Types when writing kind-polymorphic code and type-level functions :)
17:44:44 <Botje> twosetsgeneral list is equivalent to foldr f [[]] list
17:44:50 <Botje> by construction, since that's what we're doing
17:44:59 <Botje> so: 
17:45:08 <monoidal> aristid: a crazy feature is that you can have code polymorphic on level: it is simultaneously a value, type, kind, etc
17:45:10 * koninkje wonders if Omega has changed much since last I looked
17:45:14 <Botje> let rest = foldr f [[]] xs in map (x:) rest ++ rest
17:45:26 <rschnck> OH
17:45:32 <rschnck> So we're replacing the recursive bit with foldr
17:45:35 <Botje> yes
17:45:41 <rschnck> OKAY
17:45:42 <Botje> since that's our goal all along
17:45:55 <Botje> we want an f such that twosetsgeneral list === foldr f [[]] list
17:45:58 * rschnck dies from mercury poison due to all the exploding idea light bulbs
17:46:08 <rschnck> poisoning*
17:46:15 <rschnck> Okay, I get it now
17:46:29 <aristid> monoidal: i suppose you lose type inference that way?
17:46:40 <Botje> so say you have foldr doing the recursive call for you
17:46:50 <rschnck> So if I can get foldr to do the first step
17:46:54 <rschnck> Then it should work, right?
17:47:10 <Botje> foldr automatically calls itself recursively for you
17:47:16 <Botje> myFoldr f b (x:xs) = f x (myFoldr f b (xs))
17:47:38 <monoidal> aristid: in many places type signatures are optional. Once I made a fatal mistake of confusing sorts *2 with kinds *1 and lost 40 minutes wondering why it didn't compile
17:47:39 <Botje> the second parameter to f is the recursive foldr call
17:48:09 <monoidal> aristid: I'll post on reddit finished version
17:48:11 <Botje> so in the line above, rest = foldr f [[]] xs *has already been done*
17:48:17 <Botje> so given those
17:48:22 <Botje> can you now write f?
17:48:22 <aristid> monoidal: i'm not sure if i'll be able to follow it, haha
17:48:26 <Botje> f x rest = ...
17:48:35 <rschnck> wait...why has it already been doen ;-;
17:48:37 <Botje> and then i'll show you how to make a lambda function out of that
17:48:48 <dolio> aristid: I think it's more accurate to say that Omega is a moderately improved version of -fglasgow-exts.
17:48:50 <Botje> it's in the definition of foldr
17:49:00 <monoidal> aristid: in haskell, the hierarchy is values < types < kinds. In Omega, the hierarchy goes futher to infinity. The next level is called sorts (*2), then *3 etc.
17:49:03 <dolio> But I haven't looked that closely.
17:49:09 <aristid> dolio: hah.
17:49:15 <Botje> f is called with x as first parameter, and the result of foldr .... as second
17:49:34 <Botje> which is what the "rest" value above encapsulated
17:50:14 <aristid> monoidal: well i have heard of sorts, but.. you don't even see kinds explicitly that often in haskell
17:50:21 <rschnck> Oh
17:50:25 <rschnck> Because b = [[]]?
17:50:42 <rschnck> Wait crap
17:50:43 <rschnck> One second
17:50:47 <Botje> that's just the value for when the list is empty
17:50:56 <monoidal> aristid: yeah, I'm writing code with many kinds. haven't used sorts
17:51:13 <rschnck> Yes
17:51:36 <Botje> so let's say you are given x and rest as above
17:51:45 <Botje> how do you construct your subsequences?
17:52:22 <rschnck> Rest as in....twosetsgeneral xs or foldr f [[]]?
17:52:36 <aristid> rschnck: both are the same.
17:52:56 <aristid> well, if you add an xs to the foldr
17:53:18 <Botje> (since that's what we're trying to do all along)
17:53:51 <rschnck> Wait
17:54:17 <dolio> aristid: Omega may have pioneered GADTs, though. In which case, GHC has been pulling from it.
17:54:18 <rschnck> So if twosetsgeneral [5] = [5],[]
17:54:28 <rschnck> we want foldr f [[]] [5] = [5], [], right?
17:54:52 <Botje> yes
17:55:50 <rschnck> so is f = [x]++?
17:55:59 <aristid> dolio: so omega is actually quite old? doesn't ghc have gadts for some while now?
17:56:00 <rschnck> ;_;
17:56:28 <dolio> The initial release was in 2005.
17:56:32 <aristid> rschnck: no, f is not [x]++, which is also not legal syntax, in addition to not doing what you want :)
17:56:34 <dolio> I'm pretty sure that predates GADTs in GHC.
17:56:52 <dolio> And an associated paper on GADTs is also from 2005.
17:56:52 <rschnck> Well I'm clearly retarded.
17:56:52 <Botje> rschnck: f x rest = ...
17:56:53 <aristid> dolio: to me, even 2007 is "some while" :D
17:57:03 <rschnck> Botje: I still fail to udnerstand what f x 
17:57:04 <aristid> rschnck: want me to give you the solution? :)
17:57:04 <rschnck> is
17:57:06 <rschnck> NO!
17:57:09 <aristid> ok.
17:57:11 <Botje> rschnck: look back at the let rest = ... in ... line above
17:57:42 <Botje> the body of the let assumes that x is the current element and that rest = foldr f [[]] xs
17:57:45 <rschnck> f x rest = (map (x:) rest ++ rest, right?
17:57:53 <rschnck> o.O
17:58:00 <Botje> yes
17:58:11 <Botje> that's the correct definition of f
17:58:42 * heatsink is extending Haddock with type family instances
17:58:43 <rschnck> so twosetsgeneral (x:xs) = map (myFoldr f [[]] (xs)) ++ myFoldr (xs)
17:58:47 <rschnck> And we just need to figure uot f, right?
17:58:54 <aristid> rschnck: no no
17:58:57 <Botje> rschnck: yes
17:58:58 <rschnck> ++ myFoldr f [[] (xs)*
17:59:01 <aristid> rschnck: you already got the f
17:59:07 <rschnck> ...
17:59:07 <heatsink> I'm not sure what Haddock should produce for them though
17:59:07 <Botje> rschnck: but look more closely
17:59:08 <rschnck> What
17:59:23 <aristid> f x rest = (map (x:) rest ++ rest
17:59:30 <Botje> rschnck: f x rest = map (x:) rest ++ rest
17:59:30 <aristid> you can stop searching, you have found it :)
17:59:50 <rschnck> ....
17:59:53 <rschnck> BUT
17:59:57 <rschnck> rest = foldr f [[]] xs
17:59:58 <Botje> rschnck: if you say twosetsgeneral (x:xs) = map (x:) (myFoldr f [[]] xs) ++ myFoldr f [[]] xs
18:00:01 <rschnck> We haven't defiend what f is!
18:00:09 <rschnck> what function does myFoldr operate with?
18:00:14 <aristid> twosetsgeneral xs = foldr f [[]] xs
18:00:14 <Botje> rschnck: don't those two look similar?
18:00:17 <aristid> with your f
18:00:26 <aristid> f x rest = map (x:) rest ++ rest
18:00:49 <Botje> twosetsgeneral (x:xs) = f x (myFoldr f [[]] xs)
18:01:04 <rschnck> .......
18:01:10 <rschnck> I don't udnerstand what the f is/means.
18:01:18 <Botje> f is a function
18:01:23 <rschnck> Right
18:01:26 <Botje> which expects an element "the current"
18:01:29 <rschnck> And we haven't defined what f is
18:01:32 <rschnck> So how can it possible work
18:01:34 <rschnck> possibly*
18:01:47 <rschnck> foldr (+) 0 [1,2] = 3
18:01:51 <rschnck> f = +
18:01:52 <rschnck> What's our f?
18:01:57 <Botje> 03:00 < aristid> f x rest = map (x:) rest ++ rest
18:02:04 <Botje> that's the definition of f
18:02:12 <aristid> rschnck: you have defined f yourself
18:02:14 <rschnck> what's the x?
18:02:15 <Botje> f takes a current element and the subsequences of the list after x
18:02:23 <Botje> rschnck: it's a parameter
18:02:24 <rschnck> it's that like saying
18:02:25 <rschnck> f of x?
18:02:28 <aristid> rschnck: the x is just a funciton parameter
18:02:28 <Botje> yes
18:02:32 <rschnck> or f(x)
18:02:33 <rschnck> okay.
18:02:41 <Botje> f(x,rest) = ... in a mathematical / javaish notation
18:02:51 <rschnck> ...
18:02:53 <aristid> rschnck: oh, you don't understand functions with multiple parameters yet?
18:02:54 <Botje> but haskell users prefer f x rest = ...
18:02:55 <rschnck> f(x) is recursive.
18:03:02 <Botje> rschnck: no it's not
18:03:09 <Botje> do you see a use of f in its body?
18:03:18 <rschnck> wait 
18:03:21 <rschnck> f(x) rest
18:03:25 <rschnck> So does that mean
18:03:28 <rschnck> function rest that relies on x
18:03:33 <Botje> no
18:03:38 <rschnck> What's the first rest
18:03:40 <rschnck> I don't understand that
18:03:41 <Botje> f x rest is a function with two parameters
18:03:42 <aristid> rschnck: it's just f(x,rest) in curried form :P
18:03:44 <Botje> f(x, rest)
18:03:45 <rschnck> Why is rest on the left
18:03:47 <rschnck> OH
18:04:18 <rschnck> f(x, rest) = map(x:) rest ++ rest  --> f(x, y) = map(x:) y ++ y?
18:04:23 <aavogt> uncurried
18:05:03 <aristid> :t let result = (.) in foldr (join . result (++) . map . (:)) [[]]
18:05:03 <lambdabot> forall a. [a] -> [[a]]
18:05:18 <Botje> rschnck: yes.
18:05:28 <rschnck> so then
18:06:07 <rschnck> twosetsgeneral (x:xs) = map (x:) (myFoldr f [[]] xs) ++ myFoldr f [[]] xs where f x rest = map(x:) rest ++ rest?
18:06:18 <rschnck> Still absurdly confusing
18:06:23 <rschnck> and rest isn't defined in twosetsgeneral
18:06:47 <rschnck> Wait...
18:06:52 <rschnck> Rest = [[]] at first?
18:06:57 <Botje> rschnck: well, yes
18:07:11 <Botje> rschnck: but it's actually the result of calling myFoldr f [[]] xs
18:07:18 <Botje> which happens to be [[]] if you feed it an empty list
18:07:47 <rschnck> So the first step is
18:07:57 <rschnck> map(x:) [[]] + [[]]
18:08:15 <rschnck> so doesn't that mean that
18:08:27 <rschnck> Wait
18:08:28 <rschnck> Goddamnt
18:08:29 <rschnck> I'm confused
18:08:36 <Botje> rschnck: you don't know how many elements are in xs.
18:08:45 <aristid> map (x:) [[]] is curried form for map ((x:), [[]])
18:08:45 <Botje> calmn down, take a deep breath
18:08:47 <Mitar> is there a way to force import of function from a module which does not export it?
18:08:52 <Botje> let's go over it once more:
18:09:02 <Botje> we want to define a function f which takes two arguments
18:09:06 <rschnck> Okay.
18:09:08 <aristid> Botje: i think part of the problem is that he doesn't understand curried functions :)
18:09:11 <benmachine> Mitar: no, it's technically impossible
18:09:13 <heatsink> Mitar: In GHCi, yes.  Otherwise no.
18:09:27 <Botje> such that twosetsgeneral list === foldr f [[]] list
18:09:37 <Mitar> because I would like to use Data.MemoTrie on Word32
18:09:39 <rschnck> Yes.
18:09:40 <Botje> (i'm going to use foldr instead of myfoldr, since they're exactly the same)
18:09:47 <benmachine> Mitar: e.g. if that function was used only once in that module, it'll be entirely inlined and won't even exist anymore
18:09:50 <Mitar> and in Data.MemoTrie nice helpful functions are already defined
18:09:54 <Botje> if you want to find the definition of f
18:10:09 <Botje> you first have to massage the function twosetsgeneral such that it resembles the definition of foldr
18:10:15 <benmachine> Mitar: the easiest way is to go ask the person who wrote MemoTrie to export them, possibly in an Internal module
18:10:15 <Mitar> which are used in Data.Word, but instance of Data.Word32 does not exist
18:10:23 <Botje> the case for twosetsgeneral [] was easy, that's just [[]]
18:10:27 <Mitar> or just make an instance of Word32 ;-)
18:10:34 <benmachine> or that
18:10:35 <rschnck> When b= [[]].
18:10:38 <Botje> yes
18:10:44 <rschnck> Okay.
18:10:50 <Botje> the second case for foldr is myFoldr f b (x:xs) = f x (myFoldr f b (xs))
18:11:21 <Botje> so foldr takes the first element of the list and assigns it to x
18:11:28 <rschnck> Because twosetsgeneral (x:xs) = map(x:) twosetsgeneral(xs)?
18:11:43 <rschnck> ++ twosetsgeneral (which is taken care of by the anture of foldr)?
18:11:52 <Botje> no ..
18:12:09 <rschnck> I don't understand the notion of saying
18:12:17 <Botje> you want to massage the body of twosetsgeneral (x:xs) into the same form as the foldr
18:12:26 <rschnck> myFoldr f b (x:xs) = f x (mfFoldr f b (xs))
18:12:33 <Botje> yeah
18:12:37 <Botje> so you want an expression f
18:12:43 <rschnck> Yeah, but incentive was there t do this
18:12:49 <rschnck> but what incentive*
18:12:58 <Botje> for using a fold?
18:13:07 <Botje> or for rewriting the body of twosetsgeneral?
18:13:12 <rschnck> to say myFoldr f b (x:xs) = f x (myFoldr f b (xs))
18:13:19 <rschnck> How was that the next intuitive step
18:13:22 <Mitar> hmm, how does one use MemoTrie ? just f = (memo f') and then use f?
18:13:31 <Botje> rschnck: you want to get twosetsgeneral in a similar form
18:13:41 <rschnck> How are we getting twosetsgeneral into a similar form
18:13:43 <Botje> and then you can extract the definition of f from that
18:13:44 <rschnck> by modifying myFoldr?
18:13:52 <Botje> no, we're modifying twosetsgeneral
18:14:00 <rschnck> but....it says foldr everywhere
18:14:04 <rschnck> and I don't see twosetsgeneral...
18:14:15 <Botje> 03:08 < Botje> we want to define a function f which takes two arguments
18:14:17 <Botje> 03:09 < Botje> such that twosetsgeneral list === foldr f [[]] list
18:14:26 <rschnck> Oh
18:14:35 <Botje> if we assume we have such a function
18:14:50 <Botje> we can replace all calls to twosetsgeneral by foldr f [[]] 
18:14:56 <Botje> so in the body of twosetsgeneral:
18:15:12 <Botje> twosetsgeneral (x:xs) = map (x:) (foldr f [[]] xs) ++ foldr f [[]] xs
18:15:37 <Botje> i literally replaced every call to twosetsgeneral with foldr f ...
18:15:44 <Botje> that's allowed, right?
18:15:49 <rschnck> I guess :<
18:15:58 <Botje> because that's the goal
18:16:03 <rschnck> Right
18:16:27 <rschnck> I'm still a tad confused how that relates to f x (myFoldr f b (xs))
18:17:05 <Botje> if we temporary call the result of (foldr f [[]] xs), "rest"
18:17:16 <rschnck> Okay.
18:17:24 <Botje> then we can say that the body of twosetsgeneral (x:xs) is an expression in terms of the values x and rest
18:17:33 <Botje> likewise,
18:17:35 <rschnck> Yes
18:17:48 <Botje> the body of foldr f empty (x:xs) = f x (foldr f empty xs)
18:18:00 <Botje> is an expression in terms of the values x and xs
18:18:17 <Botje> right?
18:18:22 <rschnck> Yes
18:18:47 <Botje> so "map (x:) rest ++ rest" is an expression in terms of x and rest.
18:18:48 <Botje> okay
18:18:55 <rschnck> Okay
18:18:55 <Botje> now, rest (as seen above)
18:19:03 <Botje> is the result of calling myfoldr f [[]] on xs
18:19:32 <Botje> if we define a function f which takes two arguments "x" and "rest"
18:19:40 <rschnck> Right, so map(x:) (myfoldr f [[]] xs) ++ (myfoldrf [[]] xs), right?
18:19:40 <Botje> and define it as "map (x:) rest ++ rest"
18:20:04 <Botje> well, let's work with the rest form first
18:20:05 <rschnck> *crosses fingers to be right*
18:20:10 <rschnck> Okay.
18:20:15 <Botje> we can define a function "f x rest = map (x:) rest ++ rest"
18:20:25 <rschnck> Yes.
18:20:28 <Botje> which takes two arguments and uses them to form your subsequences
18:20:41 <Botje> we can now fill in this function to clean up the mess we had:
18:20:59 <Botje> twosetsgeneral (x:xs) = let rest = twosetsgeneral xs in f x rest
18:21:04 <Botje> is that clear?
18:21:13 <rschnck> Yes
18:21:15 <Botje> okay
18:21:21 <rschnck> so f x rest = map (x:) twosetsgeneral xs + twosetsgeneral xs
18:21:23 <Botje> now since rest is only used once i'll put it back in its place
18:21:37 <Botje> rschnck: no, f does not know about xs
18:21:49 <rschnck> But you just said rest = twosetsgeneral xs in f x rest
18:21:50 <Botje> it only knows about rest, which is the result of calling twosetsgeneral on a list
18:22:03 <Botje> rschnck: that's a value we compute
18:22:05 <rschnck> I get the fact that f x rest is only defined in x and rest
18:22:07 <Botje> f itself does not know about xs
18:22:09 <rschnck> so it wouldn't work
18:22:11 <rschnck> Okay
18:22:16 <rschnck> But that's confusing =/
18:22:17 <Botje> yes
18:22:19 <Botje> sorry :)
18:22:25 <Botje> let's just rewrite a /bit/ more first
18:22:36 <rschnck> Okay. Sorry for my idiocy.
18:22:37 <Botje> twosetsgeneral (x:xs) = f x (twosetsgeneral xs)
18:22:44 <Botje> i replaced rest with ..
18:22:46 <Botje> okay?
18:22:48 <rschnck> twosetsgeneral xs.
18:22:52 <Botje> yeah.
18:22:54 <rschnck> Okay.
18:23:00 <Botje> so now i'll replace it with a foldr, since that's the goal
18:23:05 <rschnck> Right
18:23:16 <Botje> and we have that twosetsgeneral xs === foldr f [[]] xs
18:23:17 <Botje> so:
18:23:26 <Botje> twosetsgeneral (x:xs) = f x (foldr f [[]] xs)
18:23:32 <rschnck> Yes.
18:23:41 <rschnck> I get it 
18:23:41 <Botje> where f x rest = map (x:) rest ++ rest
18:23:52 <Botje> and /now/ we have a form that looks like the second case of foldr
18:24:01 <Botje> (which was foldr (x:xs) = f x (foldr f empty xs))
18:24:11 <rschnck> Yes
18:24:11 <Botje> so now we finally have the definition of f we can use for a foldr:
18:24:41 <Botje> and, indeed, we can define twosetsgeneral xs = foldr f [[]] xs
18:24:47 <Botje> where f x rest = map (x:) rest ++ rest
18:25:00 <Botje> which is actual haskell code you can type
18:25:07 <Botje> but there's still one cleanup we can do
18:25:10 <rschnck> wait, so foldr f empty xs is a variable of x
18:25:18 <Botje> no
18:25:28 <Botje> foldr f empty xs uses the variables f, empty, and xs
18:25:39 <Botje> there's no mention of x in there
18:25:45 <rschnck> so it's like f(x,y) = f(x,(foldy r empty xs)) 
18:25:46 <rschnck> Sorry
18:25:50 <rschnck> I messed up what i wanted to say
18:25:51 <rschnck> But like that?
18:26:00 <Botje> uh
18:26:01 <rschnck> jesus
18:26:02 <Botje> almost
18:26:04 <rschnck> I have rs and shit in there
18:26:11 <Botje> yeah. you have to watch your free variables
18:26:31 <Botje> the body of f(x, rest) can only use the variables x, rest, and constants we've defined earlier (like empty)
18:26:34 <rschnck> so it's like f(x,rest) = f(x,(foldr f empty xs)) 
18:26:35 <rschnck> Right?
18:26:39 <Botje> yes
18:26:47 <Botje> except prettier. :)
18:26:56 <rschnck> where twosetsgeneral (x:xs) = map(x:) rest ++ rest
18:27:11 <Botje> you're doing it again
18:27:16 <Botje> twosetsgeneral only knows about x and xs
18:27:18 <rschnck> Oh
18:27:19 <rschnck> jeesus
18:27:19 <Botje> it doesn't know rest
18:27:26 <rschnck> where twosetsgeneral (x:rest) = map(x:) rest ++ rest
18:27:28 <rschnck> Oh wait
18:27:33 <Botje> no
18:27:33 <rschnck> That doesnt make sense=
18:27:34 <rschnck> =/
18:27:36 <rschnck> Yeah
18:27:37 <rschnck> Sorry
18:27:42 <Botje> where f x rest = map (x:) rest ++ rest
18:27:48 <rschnck> Yes
18:28:27 <Botje> so you can use foldr to define twosetsgeneral now
18:28:41 <Botje> since we've mangled twosetsgeneral into a form that's similar to foldr
18:28:48 <Botje> twosetsgeneral xs = [[]]
18:28:50 <Botje> err
18:28:52 <Botje> twosetsgeneral [] = [[]]
18:28:55 <rschnck> Yes
18:29:07 <Botje> twosetsgeneral (x:xs) = f x (foldr f [[]] xs)
18:29:12 <Botje> where f x rest = map (x:) rest ++ rest
18:29:18 <Botje> or
18:29:28 <Botje> twosetsgeneral xs = foldr f [[]] xs
18:29:33 <Botje> where f x rest = map (x:) rest ++ rest
18:29:42 <Botje> now, there's one final step to make
18:29:58 <Botje> which is fully optional, but often done for simple functions f, like this one
18:30:13 <Botje> instead of giving it a name, we use an anonymous function in place of f
18:30:17 <Botje> like this:
18:30:30 <Botje> twosetsgeneral xs = foldr (\x rest -> map (x:) rest ++ rest) [[]] xs
18:30:44 <rschnck> Okay
18:31:10 <aristid> Botje: you could also make it point-free :P
18:31:19 <Botje> aristid: .. no :)
18:31:57 <aristid> :t let result = (.) in foldr (join . result (++) . map . (:)) [[]]
18:31:58 <lambdabot> forall a. [a] -> [[a]]
18:32:10 <Botje> rschnck: so. if you want to reduce a recursive function to an expression you can use with foldr, first reduce the function to a form that looks like the body of foldr
18:32:31 <Botje> and then the definition of empty (or "b" as you call it) and the folding function ("f") should fall out.
18:32:57 <rschnck> Okay, I thknI get it.
18:33:02 <rschnck> I was having trouble before because I was thinking
18:33:09 <rschnck> "rest is just some variable...it is never defined"
18:33:13 <rschnck> but it's defined by b, right?
18:33:22 <rschnck> So in the first instance of the function
18:33:26 <benmachine> :t foldr (\x -> (++) =<< map (x:)) [[]]
18:33:27 <lambdabot> forall a. [a] -> [[a]]
18:33:29 <rschnck> it's map (x:) [[]] ++ [[]],
18:33:30 <aristid> f x rest = ...
18:33:31 * benmachine isn't sure that's not backwards
18:33:37 <aristid> here, x and rest are function parameters
18:33:41 <Botje> aristid: it's "bound" by the function f
18:33:44 <Botje> argh
18:33:50 <rschnck> Right but
18:33:58 <aristid> benmachine: interesting
18:34:01 <rschnck> in foldr (+) 0 [1,2,3,4]
18:34:17 <rschnck> + requiers the 0 to operate on initially
18:34:19 <aristid> (+) a b = ADD THE NUMBERS
18:34:27 <rschnck> and f x rest requires the [[]] to operate on initially
18:34:29 <aristid> rschnck: rest is [[]] initially
18:34:30 <rschnck> right?
18:34:31 <aristid> yes
18:34:32 <rschnck> Yes
18:34:32 <aristid> so?
18:34:40 <rschnck> Well...I wasn't quite making that connection
18:34:41 <Botje> rschnck: well, yes. but rest will be [[]] exactly one time
18:34:43 <rschnck> Now it makes sense
18:34:44 <rschnck> Yes
18:34:46 <rschnck> Now I get it
18:34:48 <Botje> cool :)
18:34:50 <benmachine> :t foldr (((++) =<<) . map . (:)) [[]]
18:34:51 <lambdabot> forall a. [a] -> [[a]]
18:34:53 <benmachine> >_> <_<
18:34:59 <rschnck> Botje: Thanks for sticking with me through my ridiculous retardation
18:35:03 * benmachine obnoxious
18:35:17 <Botje> rschnck: you're welcome
18:35:25 <Botje> it's good practice for when i have to teach in two weeks :)
18:35:33 <rschnck> You teach Haskell?
18:35:56 <Botje> i do lab sessions
18:36:06 <aristid> benmachine: nice, but i think i like your partially pointful version a bit better
18:36:20 <benmachine> aristid: mm, probably
18:36:42 <benmachine> I'm getting used to ap on functions but I can't quite do bind from memory yes
18:36:44 <benmachine> *yet
18:37:24 <rschnck> So this new twosetsgeneral we defined
18:37:27 <rschnck> Is super similar to the old one
18:37:35 <rschnck> It's recursive underneath with foldr, right?
18:37:42 <aristid> yes
18:37:46 <aristid> @src foldr
18:37:46 <lambdabot> foldr f z []     = z
18:37:46 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
18:38:15 <Botje> rschnck: now that it looks like foldr you can collapse twosetsgeneral to a foldr call
18:38:37 <Botje> since foldr checks for emptyness or not for you
18:39:01 <rschnck> Okay, so what would that look like?
18:39:17 <Botje> 03:29 < Botje> twosetsgeneral xs = foldr f [[]] xs
18:39:17 <Botje> 03:29 < Botje> where f x rest = map (x:) rest ++ rest
18:39:33 <Botje> or using a lambda (anonymous function):
18:39:34 <Botje> 03:30 < Botje> twosetsgeneral xs = foldr (\x rest -> map (x:) rest ++ rest)  [[]] xs
18:39:44 <rschnck> Oh, I did it the lambda way already
18:39:47 <aristid> or even dropping the xs :P
18:40:05 <rschnck> Dropping the xs?
18:40:19 <Botje> rschnck: have you learned about currying yet?
18:40:25 <rschnck> No
18:40:30 <Botje> partial application?
18:40:39 <rschnck> And I don't think we will. We're using Haskell as a means to do a basic intro to computation course
18:40:48 <Botje> oh. wow :)
18:40:49 <rschnck> So it's less about Haskell andmore about using Haksell to understand computers
18:41:21 <rschnck> So he taught us the super basics of Haskell and asks us to write functions that model basic set operations, etc
18:41:25 <Botje> rschnck: well, what aristid is referring to is that you can also define twosetsgeneral = foldr (\x rest -> map (x:) rest ++ rest)
18:41:42 <rschnck> What I just did now wasn't assigned. I just wanted to see if it was possible.
18:42:03 <Botje> which is valid because calling a function with less than its desired number of values returns a function which waits for the other arguments
18:42:09 <benmachine> it's like, instead of "this function takes a parameter and applies some other function to the parameter" you just say "this function is the same as some other function"
18:42:35 <Botje> but don't worry about that for now.
18:42:43 <Botje> it's another way of making your definitions "prettier"
18:42:52 <rschnck> How would foldr know to use [[]] for b?
18:43:03 <Botje> uh ...
18:43:03 <Botje> right
18:43:07 <Botje> i forgot the [[]], sorry :)
18:43:08 <aristid> rschnck: he forgot that
18:43:13 <rschnck> Oh
18:43:16 <rschnck> Then I understand that
18:43:29 <Botje> if you look at the times in my pastes, it's already very well past bedtime for me :p
18:43:42 <aristid> Botje: your bedtime is earlier than 6:00?
18:43:51 <Botje> .. in the morning?
18:44:01 <rschnck> It's 6:45 pm here :D
18:44:10 <Botje> other side of the globe :p
18:44:21 <rschnck> Yeah. I used to live in Switzerland. It's a bit odd being so behind.
18:44:50 <benmachine> @time Botje 
18:45:02 <rschnck> @time rschnck 
18:45:05 <lambdabot> Local time for rschnck is Sat Sep 25 18:46:59 2010
18:45:05 <Botje> Sun Sep 26 03:44:41 CEST 2010
18:45:09 <benmachine> oh ok :P
18:45:27 <Botje> so yeah. i'm going to bed :p
18:45:28 <rschnck> Botje: Anyway, thanks for all your help.
18:45:37 <benmachine> your client doesn't respond to VERSION either :o
18:45:39 <rschnck> G'night.
18:45:41 <benmachine> 'night
18:45:55 <Botje> rschnck: you're welcome. if you're more interested in haskell, be sure to check out LYAH or ask around
18:46:02 <Botje> benmachine: weird. it's bog standard irssi
18:46:11 <benmachine> weird.
18:46:28 <rschnck> http://learnyouahaskell.com/
18:46:29 <rschnck> That?
18:46:32 <Botje> yes
18:46:32 <benmachine> yes
18:46:40 <rschnck> :awesome:
18:46:51 <Botje> it starts you learning pretty advanced haskell from zero
18:47:10 <Botje> and the drawings are cool, of course
18:47:16 <Botje> which reminds me, i still need to order my copy
18:47:17 <rschnck> I like pretty pictures
18:47:20 <rschnck> (and pretty Haskell functions)
18:47:26 <rschnck> So one thing
18:47:32 <rschnck> We can omit xs from twosetsgeneral
18:47:44 <rschnck> because I defiend it as [a] -> [[a]]
18:47:47 <rschnck> So it knows what to expect right?
18:47:57 <Botje> even if you didn't give the type it knows that
18:48:02 <rschnck> Because of foldr?
18:48:04 <rschnck> Ah!
18:48:07 <Botje> it knows that foldr takes three arguments
18:48:09 <rschnck> Right
18:48:10 <Botje> and you only give it two
18:48:13 <rschnck> Okay, makes sense now
18:48:19 <rschnck> Is it "proper" to omit the type?
18:48:21 <rschnck> In this case
18:48:36 <benmachine> it's good to include the type signature
18:48:42 <benmachine> it's not necessary as such but it's good
18:48:46 <rschnck> Mmk
18:49:00 <benmachine> in particular, if you get the implementation wrong, GHC will probably give you a better error message
18:49:07 <rschnck> Right.
18:49:20 <rschnck> Okay, great. Thanks so much. I'm going to get dinner.
18:49:20 <benmachine> and, if anyone wants to skimread your code the explicit type signatures are a huge help :)
18:49:28 <heatsink> Usual style is to include type signatures on all top-level declarations and omit them on other declarations unless they're really complicated.
18:50:01 <tmo_> Simple question: is it possible to implement a hash table in a purely functional manner?
18:50:03 <benmachine> or necessary to resolve ambiguity/avoid the DMR/higher-rank polymorphism/other devious reasons >_>
18:50:17 <benmachine> tmo_: depends what you mean by a hash table, I suppose
18:50:27 <benmachine> tmo_: I think the most popular answer would be "it isn't necessary"
18:50:31 <benmachine> buuuut whatever
18:50:47 <alej> i'm curious about that answer: it isn't necessary
18:51:02 <Botje> tmo_: absolutely possible to do functionally
18:51:05 <benmachine> alej: well, if you want a lookup structure, functional people tend to prefer tries
18:51:13 <benmachine> or trees
18:51:18 <Botje> tmo_: you simply use an immutable array with a hashing function
18:51:20 <alej> oh ok so you mean to do a hash table
18:51:51 <Botje> tmo_: however, there's a big problem re. memory usage
18:52:28 <tmo_> Botje: thanks for the answer
18:53:07 <benmachine> tmo_: note that haskell supports doing things in ways that wouldn't typically be considered purely functional, as well
18:53:12 <Botje> sleep now!
18:53:17 <benmachine> sleep well!
18:54:51 <Mitar> what would be the fastest way to dump an array of bytes i got from FFI to file in haskell?
18:55:48 <monoidal> some omega code I've played with (monoids, monads and categories): http://hpaste.org/40123/kind_polymorphism_in_omega
18:56:06 <ezyang> Mitar: Do you have just a pointer to an array of bytes? 
18:56:12 <Mitar> yes
18:56:16 <ezyang> In which case, unsafely construct a bytestring and then use the library function. 
18:56:20 <Mitar> and length
18:56:24 <napping> how about hPutBuf?
18:56:47 <ezyang> napping: That would need marshaling to a String first, no? 
18:56:50 <napping> Handle -> Ptr a -> Int -> IO ()
18:56:54 <ezyang> oh no, it doesn't. 
18:57:05 <ezyang> handy. 
18:57:22 <Mitar> interesting
18:57:26 <Mitar> that looks the best
18:57:58 <Mitar> because writing out in C would block the whole program, using hPutBuf will probably not?
18:58:08 <Mitar> (GHC threads)
18:58:17 <benmachine> whether writing out in C blocks the whole program probably depends on stuff
18:58:33 <ezyang> Mitar: Not if you do it safely. 
18:58:52 <Mitar> safely in the sense of?
18:59:00 <benmachine> foreign import safe, I guess
18:59:49 <Mitar> isn't safe/unsafe the question if they will call back into haskell?
19:00:54 <Mitar> http://www.haskell.org/ghc/dist/current/docs/libraries/base/Control-Concurrent.html#4
19:01:16 <ezyang> Right. 
19:01:43 <ezyang> So unsafe calls don't suspend the runtime. 
19:02:09 <benmachine> Mitar: the way the GHC runtime works, this happens to be the same as is required to block other operations or not
19:02:18 <Mitar> unsafe do block, safe do not
19:03:17 <napping> no, but they do prevent the runtime from preempting your Haskell thread, and garbage collecting
19:03:42 <Mitar> hmm, but probably then i have to write in C function code in a way to handle EINTR errno?
19:04:07 <ezyang> Mitar: Sure. 
19:04:13 <napping> um, you have to write working C code, yes
19:04:15 <Mitar> because when haskell will want to switch threads it will probably call VTIMER
19:04:19 <ezyang> It's not terribly useful though. 
19:04:27 <Mitar> ok, but if the problem is that i have to dump 100 MB ;-)
19:04:36 <Mitar> then probably haskell will interrupt that all the time
19:04:39 <napping> I don't think the runtime tends to raise EINTR or anything
19:04:41 <ezyang> Because POSIX GHC has a signal handler thread that soaks 'em up. 
19:04:48 <Mitar> ok, so i will have to write in smaller chunks
19:04:51 <napping> that would just make C code retry anyway
19:05:16 <Mitar> not raise EINTR, but write system call in C would return EINTR errno
19:05:33 <napping> yeah, that can happen in any C code
19:05:34 <Mitar> because of the VTALARM or how is it called
19:05:44 <Mitar> true
19:05:59 <ezyang> Yeah, SIGVTALRMs are pretty annoying. 
19:06:09 <napping> no, the runtime mostly works by setting a flag that compiled Haskell code checks whenever it allocates memory
19:06:21 <napping> telling it to pack things up and return to the scheduler
19:06:26 <EvanR> whats the use of class MonadIO
19:06:51 <napping> If it's convenient to do the output in C, and you are making a safe call into C that should work fine
19:07:05 <napping> or if you want to return the pointer to Haskell and do hPutBuf, that will work nicely too
19:07:10 <benmachine> EvanR: liftIO works from any monad in a transformer stack
19:07:26 <ezyang> benmachine: If your transformers support MonadIO and IO is on the bottom! 
19:07:34 * ezyang takes of captain pedant hat 
19:07:37 <benmachine> :P
19:07:37 <EvanR> so it doesnt let you just stuff without liftIO
19:07:42 <benmachine> no
19:07:43 <Mitar> napping: but i will probably have to output in C in smaller chunks and retry if write fails because of the interrupt?
19:07:49 <benmachine> it lets you do stuff without lift . lift . lift . lift
19:08:22 <EvanR> do other classes like MonadRandom allow you to use random methods directly without a liftRandom?
19:08:39 <ezyang> EvanR: Yes. 
19:08:49 <EvanR> so MonadIO is especial
19:08:51 <ezyang> So, due to hysterical raisins, most IO functions are written IO a 
19:09:01 <EvanR> lol
19:09:16 <napping> Mitar: I don't know of anything in the runtime that makes it more likely you will see EINTR
19:09:18 <ezyang> but modern monad reasons are MonadRandom m => m a 
19:09:42 <Mitar> hmm
19:09:46 * ezyang is working on a patch for GHC that will have it submit signals to FFI calls in the case of interruptions. 
19:09:46 <napping> Mitar: but even in a standalone C program write(2) may not write as much data as you requested in a single call
19:09:55 <Mitar> but how will then runtime prevent my C call to simply run all the time?
19:10:03 <napping> It's run in a new thread
19:10:19 <napping> So, the RTS makes one system thread per core, for running Haskell code
19:10:19 <EvanR> or all other threads are moved to a new thread
19:10:30 <Mitar> aaa, because of the safe flag it will be run in a seperate system thread?
19:10:52 <Mitar> but this is then slow, to fork a new thread and everything
19:11:01 <napping> not necessarily
19:11:01 <EvanR> it keeps threads around for that reason
19:11:02 <Mitar> then it is better to use hPutBuf?
19:11:10 <Mitar> smart
19:11:43 <ezyang> That seems like the good choice. 
19:11:58 <Mitar> which one now? ;-0
19:11:58 <ezyang> Avoid FFI as much as possible. 
19:12:08 <ezyang> hPutBuf 
19:12:12 <Mitar> i agree
19:12:15 <Mitar> will do it like that
19:12:32 <ezyang> (and this is coming from a guy who spent a summer working on ~essentially FFI bindings :-) 
19:12:45 <Mitar> ;-)
19:12:51 <Mitar> what are you working on?
19:20:34 <tmo_> Let n be a Notebook widget. The statement "set n [notebookChildDetachable := True]
19:20:42 <tmo_> compiles, but I get the following runtime error: (interface:4441): GLib-GObject-WARNING **: IA__g_object_set_property: object class `GtkNotebook' has no property named `detachable'
19:20:42 <tmo_>  
19:21:30 <tmo_> Why is that?
19:22:54 <tensorpudding> is that Haskell?
19:23:01 <tmo_> yes?
19:23:42 <tmo_> The runtime error probably isn't from the haskell source code, since gtk2hs is a gtk binding.
19:53:49 <co_dh> what's the arrow in an Arrow category ? which take a Category C's arrow as object ? 
19:56:08 <mm_freak> Olathe: beginners, who don't understand monads yet, often get type errors for IO code
19:56:09 <danblick> co_dh: http://en.wikipedia.org/wiki/Comma_category#Arrow_category
19:56:25 <co_dh> danblick: thanks
19:56:33 <mm_freak> putStrLn getLine
19:56:34 <Olathe> mm_freak: Ahh, OK.
19:56:41 <mm_freak> that sort of thing
20:09:13 <ddarius> co_dh: The arrows in the arrow category are pairs of arrows of the underlying category that make the squares made with target and source commute.
20:15:50 * hackagebot MemoTrie 0.4.8 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.4.8 (ConalElliott)
20:19:51 * hackagebot improve 0.1.0 - An imperative, verifiable programming language for high assurance applications.  http://hackage.haskell.org/package/improve-0.1.0 (TomHawkins)
20:19:53 * hackagebot vcd 0.2.0 - Reading and writing VCD files.  http://hackage.haskell.org/package/vcd-0.2.0 (TomHawkins)
20:20:52 * hackagebot atom 1.0.7 - A DSL for embedded hard realtime applications.  http://hackage.haskell.org/package/atom-1.0.7 (TomHawkins)
20:22:56 <wavewave> will haskell have dependent type nearby future?
20:23:05 <benmachine> unlikely
20:23:17 <benmachine> dependent types don't tend to support type inference very well
20:23:24 <benmachine> and type inference is a major haskell feature
20:23:45 <benmachine> so a dependently-typed language based on haskell would be a different language, kinda
20:23:46 <wavewave> because of undecidability?
20:23:53 * hackagebot ecu 0.0.2 - Tools for automotive ECU development.  http://hackage.haskell.org/package/ecu-0.0.2 (TomHawkins)
20:23:58 <benmachine> something like that, I'm not too sure of the details
20:25:07 <wavewave> but haskell programs already have some type-level programming.
20:25:59 <benmachine> true, but dependent types would be a fairly major step up from that
20:26:08 <wavewave> I wonder if integers at least can be represented as depedent types. 
20:26:26 <monochrom> try Omega! :)
20:26:40 <ezyang> I hear Omega has what you want. 
20:26:43 <wavewave> 0 :: Z, 1 :: S (Z) , 2 :: S (S (Z))
20:26:47 <dolio> The level of inference that you can have in Haskell is overrated.
20:27:36 <monochrom> Omega has dependent types but it is hoped that in practice you just work with improved GADTs and feel like you're still just doing haskell.
20:27:40 <napping> benmachine: Haskell already gives up on type inference quite a lot
20:27:50 <dolio> Omega doesn't have dependent types.
20:27:55 <dolio> It has GADTs.
20:28:13 <napping> even things like explicit foralls already make the no-annotations type inference undecidable
20:28:38 <ezyang> napping: Well, rank2 is still inferrable :-) 
20:28:39 <monochrom> oops, I misread.
20:28:55 <wavewave> hmm, then more narrow-down question is can omega be included in haskell?
20:29:05 <dolio> I think Omega may have been the original language with GADTs (forgetting about inductive families).
20:29:06 <napping> I think that's one reason O'Caml and other ML family languages have been slower to adopt such things
20:29:07 <ezyang> Not as far s I know? 
20:29:20 <napping> wavewave: we already have GADTs
20:29:35 <napping> I think the other extensions are easier
20:29:45 <dolio> It has other nicer type-level stuff, too.
20:30:13 <dolio> Like, you can write 'kind Nat = Z | S Nat' instead of faking it poorly with 'data Z ; data S n'.
20:30:35 <napping> that seems to be an easier extension
20:30:41 <napping> and there's she
20:31:06 <wavewave> by the way, if we do type-level calculation using GADTs or whatever in haskell, does it have no runtime overhead at all?
20:31:09 <dolio> SHE desugars into faking it poorly, though. :)
20:31:29 <napping> wasn't there something about GHC 7 adding datakinds?
20:31:32 <benmachine> wavewave: types don't exist at runtime, I believe
20:31:37 <napping> wavewave: it has overhead even in Omega
20:31:52 <djahandarie> Type-level programming is overrated... I do kind-level programming.
20:32:08 <napping> the types are erased, true, but the GADTs still have to be manipulated
20:32:08 <wavewave> so if I use 10000 as S ( S ( S ( S ( S ( S .... S (Z)))))...)))) then?
20:32:13 <ezyang> dhandarie: Oh yeah? Well I do programming in Set^3 
20:32:15 * monoidal does level-level programming
20:32:28 <monochrom> They are all overrated. I do javascript programming.
20:32:33 <napping> haha :: Equals Int Char; haha = last [1..]
20:32:43 <napping> er, wrong loop
20:32:46 <napping> but you get the idea
20:33:16 <napping> that's one nice thing about the proper strongly-normalizing dependently typed languages
20:33:28 <monochrom> I should go get a web design job and come back to tell you I do html programming just to make you feel sick. :)
20:34:32 <djahandarie> I wonder if you could somehow write HTML that forces HTML parsers to do calculations
20:35:29 <monochrom> not from my perspective. but it's subjective.
20:36:04 <wavewave> I found that there are some different ways in haskell to have type-level programming, for example to represent natural number.. 
20:36:05 <aristid> djahandarie: other than javascript?
20:36:14 <ezyang> "Don't use Peanos" 
20:36:24 <wavewave> using typeclass, using type families. 
20:37:05 <monochrom> does your "html parser" includes a javascript interpreter? if you support <body><script>document.write(...)</script></body> you already have to calculate a lot. whether you say "it's the javascript interpreter doing the job" or "it's the html parser doing the job" is up to you.
20:37:37 <wavewave> ezyang: what is the best way?
20:37:40 <djahandarie> Obviously no Javascript involved
20:37:57 <aristid> djahandarie: how is that obvious? and what about CSS?
20:38:27 <monochrom> alright then the parser doesn't compute a lot. at most keep some easy state so that <td>hi<td>hello... makes sense.
20:38:28 <ezyang> wavewave: Peanos might be ok for some uses. 
20:38:42 <ezyang> But you probably actually want some sort of binary representation. 
20:38:54 <ezyang> anyway, "there's a library for that" 
20:39:08 <monochrom> rendering is a lot of calculations but I tend to classify them under the renderer rather than parser.
20:40:10 <napping> monochrom: have you used Agda?
20:40:13 <monochrom> no
20:40:19 <monochrom> it's all greek to me. :)
20:40:28 <napping> It doesn't seem to be much harder than Omega
20:40:41 <napping> the only thing it doesn't give you nicely is row types
20:40:43 <wavewave> ezyang: type-level on hackage?
20:40:50 <monochrom> but I have done non-trivial typechecking in pvs
20:40:54 <ezyang> wavewave: I think there's an actual type-numeral package 
20:41:10 <ezyang> Agda's fun, in a "I don't actually feel like getting any work done" way :-) 
20:41:19 <djahandarie> I tried learning Agda once but there was no good document on it, just a bunch of random scattered pdfs
20:41:36 <ezyang> The tutorial is pretty good. 
20:41:39 <djahandarie> I'll revisit it when I get motivated for some reason
20:41:59 * ezyang learned Agda to try to understand glguy's quicksort talk 
20:42:04 <monochrom> non-trivial means I had to tell the typechecker why n>0 is true where I used it.
20:44:08 <wavewave> anyone tried to make a list with type-level natural number length annotation?
20:44:31 <ezyang> yeah, I thinkso. 
20:44:44 <ezyang> Probably look at type level vectors. 
20:44:53 <ezyang> erm, vectors with typed lengths 
20:45:42 <wavewave> ezyang: do you know which pacakge it is?
20:45:54 <wavewave> ezyang: I just want to see the feeling of the code. 
20:46:03 <ezyang> sure, one sec 
20:47:17 <ezyang> lessee, we have... 
20:47:33 <ezyang> AC-Vector-Fancy, typical, vector-static, hmatrix-static 
20:47:48 <ezyang> of highly varying quality and completion :-) 
20:48:02 <wavewave> ezyang: okay thank you. I will look at the codes.
20:48:15 <ezyang> Don't gouge your eyes out too much ;-) 
20:55:02 <wavewave> vector-static is quite simple to understand, but it uses Peano number. 
20:56:41 <wavewave> that means when I call witnessNat :: Natural type -> Integer, it has O(n) runtime overhead. 
20:57:14 <ezyang> YOu mean compile time. 
20:57:35 <wavewave> Hmm I think it's runtime.
20:58:36 <wavewave> since    witnessNat ( undefined :: Type3 ) = s (witnessNat (undefined :: Type2 ) ) 
20:59:01 <wavewave> = s ( s ( witnessNat (undefined :: Type1 ) ) ) = s ( s ( s ( z ) ))))
21:01:04 <Saizan> for which operation does it need witnessNat?
21:01:45 <wavewave> Saizan : That's most default type -> value function.
21:02:39 <wavewave> Saizan: anyway, to have any real world output needing value in runtime
21:03:09 <Saizan> wavewave: yeah, but i don't print the length of my vectors that often
21:03:24 <Saizan> or of my lists
21:03:38 <wavewave> Saizan: Yeah, I am just curious about general dependent type programming in haskell. 
21:04:42 <wavewave> Saizan: of course, for the specific purpose of safe-check of the length of vector, this is enough.
21:05:05 <Saizan> what i mean is that you can work with lists parametrized by their types without having to use witnessNat much, or at all
21:06:16 <wavewave> Saizan: I agree it.
21:07:24 <wavewave> I am now thinking of changing all the integer in my program into type-level integer. hihi
21:10:21 <wavewave> some syntactic sugar for type-level integer can be quite useful..   
21:14:08 <wavewave> Saizan: so do you use Type-level integer regularly?
21:45:43 <kmc> Axiom the_lukewarm : plus 2 2 = 5.
21:48:36 <kmc> @remember ChrisOkasaki Historically, the most common technique for analyzing lazy programs has been to pretend that they are actually strict.
21:48:36 <lambdabot> Good to know.
21:50:33 <genier> aPunchUpAtAWedding = repeat "no"
21:53:43 <co_dh> :t either
21:53:44 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
22:04:13 <newsham> > "Test" :: ByteString
22:04:14 <lambdabot>   Not in scope: type constructor or class `ByteString'
22:04:36 <newsham> > "Test" :: Data.ByteString.ByteString
22:04:36 <lambdabot>   Not in scope:
22:04:37 <lambdabot>    type constructor or class `Data.ByteString.ByteString'
22:07:36 <newsham> hmm.. modern haskell lets you use string literals as BS?
22:09:07 <djahandarie> With -XOverloadedStrings
22:10:18 <newsham> is there a printf that works with BS's too?
22:10:40 <EvanR> printf is pretty crap
22:10:58 <EvanR> but you can show a bytestring before printf %s ing it
22:28:16 <manateeUser> Hi all! :)
22:28:52 <EvanR> manateeLazyUser
22:29:05 <ManateeLazyCat> EvanR: Hi. :)
22:29:19 <EvanR> someone was in here asking about gtk+
22:29:30 <ManateeLazyCat> EvanR: About what? :)
22:29:34 <EvanR> gtk2hs
22:29:43 <ManateeLazyCat> EvanR: I know, which part? :)
22:30:00 <EvanR> thats the thing, no one could decipher it or understand it, i immediately thought of you ;)
22:30:16 <ManateeLazyCat> EvanR: Code ?
22:31:11 <manateeUser> EvanR: Sometimes I am a gtk2hs Service. (Translate by Google):)
22:31:27 <EvanR> http://codepad.org/clAf8yG5
22:34:25 <ManateeLazyCat> EvanR: One possible, tom_ use old gtk+ that not support "detachable" property.
22:35:03 <EvanR> right, version incompatability
22:37:46 <ManateeLazyCat> @tell tmo_ I have seen your error about "IA__g_object_set_property: object class `GtkNotebook' has no property named `detachable'", I guess your install old gtk+ that support "detachable" property yet, instead, you can try notebookGetTabDetachable/notebookSetTabDetachable.
22:37:46 <lambdabot> Consider it noted.
22:38:10 <ManateeLazyCat> @tell tmo_ s/support/don't support, typo, sorry.
22:38:10 <lambdabot> Consider it noted.
22:38:38 <ManateeLazyCat> @tell tmo_ If notebookSetTabDetachable and notebookGetTabDetachable can't work, install newer GTK+ will helpful. :)
22:38:38 <lambdabot> Consider it noted.
22:40:47 <ManateeLazyCat> @tell tmo_ If no one answer you at here, post to gtk2hs list. Then we can answer your question. :)
22:40:47 <lambdabot> Consider it noted.
22:42:04 <manateeUser> Today I failed once. (Translate by Google)
22:42:17 <ManateeLazyCat> should be again. :)
22:52:27 <siracusa> ManateeLazyCat: Hi! I found another gtk2hs problem, but I don't have time for debugging now. Are you online later today?
22:52:41 <ManateeLazyCat> siracusa: What's problem?
22:53:13 <siracusa> a compiler error
22:53:16 <ManateeLazyCat> siracusa: I'm not sure, best post to gtk2hs list if you can't found me. :)
22:53:26 <ManateeLazyCat> siracusa: Paste?
22:55:04 <siracusa> ManateeLazyCat: I'll prepare a paste later. If you're here I tell you, otherwise I send it to the list. I need some sleep now :-)
22:55:37 <ManateeLazyCat> siracusa: Good night. :)
22:55:51 <siracusa> Bye
22:56:32 <manateeUser> siracusa: 晚安 (Translate by Google).
22:56:56 <ManateeLazyCat> Hmm, network delay.....
23:34:47 <Nibble> have you guys seen this? http://marcotmarcot.wordpress.com/2010/03/14/another-interesting-code-using-template-haskell/
23:34:54 <Nibble> amusing
23:35:50 <c_wraith> eh.  that makes perfect sense.
23:35:57 <c_wraith> unsafePerformIO is so-named for a reason
23:35:58 <c_wraith> :)
23:37:06 <medfly> huh, I guess you really can't know what it'll do
23:37:14 <medfly> might launchMissiles too...
23:37:34 <kmc> hehe
23:37:35 <kmc> that's cute
23:37:57 <kmc> also is unsafePerformIO necessary?
23:38:01 <kmc> you can perform IO from the Q monad
23:39:18 <elitheeli> I'm a little confused by monads / IO monad. If I wanted to reverse each member of getArgs and then print the whole thing out, what would I do? "something $ fmap (map reverse) getArgs"? Help?
23:39:38 <kmc> do { xs <- getArgs; print (reverse xs) }
23:39:39 <c_wraith> kmc: unsafePerformIO is what makes lift do the IO
23:39:51 <kmc> c_wraith, you could make the splice as a whole do it without uPIO
23:40:01 <kmc> err print (map reverse xs)
23:40:12 <kmc> the IO monad doesn't have much to do with monads in general
23:40:24 <c_wraith> kmc: his point wasn't "this is a way to ask for input at compile time," it was "huh, this causes it to ask for input at compile time.  That's funny."
23:40:56 <kmc> oh, the point is that it's not obvious from the splice site that IO will occur?
23:41:26 <c_wraith> since the only thing it's doing at the splice site is lift
23:41:32 <kmc> yeah
23:41:55 <elitheeli> kmc: thanks
23:42:56 <kmc> elitheeli, did you read http://haskell.org/haskellwiki/Introduction_to_IO
23:43:11 <kmc> i think it's best to learn IO first as a concrete thing, and worry later about what the word "monad" means
23:43:29 <elitheeli> kmc: cool, thanks
23:43:37 <kmc> "monad" is just the name of an API; IO is one of many things which uses this API.  you don't care about the generic properties of the API if you're only using it with one type
23:54:51 * hackagebot synthesizer-core 0.4.0.4 - Audio signal processing coded in Haskell: Low level part  http://hackage.haskell.org/package/synthesizer-core-0.4.0.4 (HenningThielemann)
23:55:26 <kmc> naming things is hard
23:55:38 <kmc> we need the haskell equivalent of http://www.classnamer.com/
23:56:48 <medfly> just pick a 4 letter word and attach l or r to it
23:57:14 <kmc> also a good Web 2.0 site naming scheme
23:57:23 <kmc> this is the beauty of foldr.com
23:57:43 <kmc> wish the site still worked
